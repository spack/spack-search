{
    "matches": {
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/HISTORY.md": "Julia v0.4.0 Release Notes\n==========================\n\nNew language features\n---------------------\n\n  * Function call overloading: for arbitrary objects `x` (not of type\n    `Function`), `x(...)` is transformed into `call(x, ...)`, and `call`\n    can be overloaded as desired.  Constructors are now a special case of\n    this mechanism, which allows e.g. constructors for abstract types.\n    `T(...)` falls back to `convert(T, x)`, so all `convert` methods implicitly\n    define a constructor ([#8712], [#2403]).\n\n  * Unicode version 8 is now supported for identifiers etcetera ([#7917], [#12031]).\n\n  * Type parameters now permit any `isbits` type, not just `Int` and `Bool` ([#6081]).\n\n  * Keyword argument names can be computed, using syntax such as `f(; symbol => val)` ([#7704]).\n\n  * The syntax `@generated function` enables generation of specialized methods based on\n    argument types. At compile time, the function is called with its arguments bound to their\n    types instead of to their values. The function then returns an expression forming the\n    body of the function to be called at run time ([#7311]).\n\n  * [Documentation system](http://docs.julialang.org/en/release-0.5/manual/documentation/)\n    for functions, methods, types and macros in packages and user code ([#8791]).\n\n  * The syntax `function foo end` can be used to introduce a generic function without\n    yet adding any methods ([#8283]).\n\n  * Incremental precompilation of modules: call `VERSION >= v\"0.4.0-dev+6521\" && __precompile__()` at the top of a\n    module file to automatically precompile it when it is imported ([#12491]), or manually\n    run `Base.compilecache(modulename)`. The resulting precompiled `.ji` file is saved in\n    `~/.julia/lib/v0.4` ([#8745]).\n\n      * See manual section on `Module initialization and precompilation` (under `Modules`) for\n        details and errata.  In particular, to be safely precompilable a module may need an\n        `__init__` function to separate code that must be executed at runtime rather than precompile\n        time.  Modules that are *not* precompilable should call `__precompile__(false)`.\n\n      * The precompiled `.ji` file includes a list of dependencies (modules and files that\n        were imported/included at precompile-time), and the module is automatically recompiled\n        upon `import` when any of its dependencies have changed.  Explicit dependencies\n        on other files can be declared with `include_dependency(path)` ([#12458]).\n\n      * New option `--output-incremental={yes|no}` added to invoke the equivalent of `Base.compilecache`\n        from the command line.\n\n  * The syntax `new{parameters...}(...)` can be used in constructors to specify parameters for\n    the type to be constructed ([#8135]).\n\n  * `++` is now parsed as an infix operator, but does not yet have a default definition ([#11030], [#11686]).\n\n  * Support for inter-task communication using `Channels` ([#12264]).\n    See http://docs.julialang.org/en/release-0.5/manual/parallel-computing/#channels for details.\n\n  * `RemoteRef`s now point to remote channels. The remote channels can be of length greater than 1.\n    Default continues to be of length 1 ([#12385]).\n    See http://docs.julialang.org/en/release-0.5/manual/parallel-computing/#remoterefs-and-abstractchannels for details.\n\n  * `@__LINE__` special macro now available to reflect invocation source line number ([#12727]).\n\nLanguage changes\n----------------\n\n  * Tuple types are now written as `Tuple{A, B}` instead of as `(A, B)`.\n    Tuples of bits types are inlined into structs and arrays, like other\n    immutable types.\n    `...` now does splatting inside parentheses, instead of constructing a\n    variadic tuple type ([#10380]).\n    Variadic tuple types are written as `Tuple{Vararg{T}}`.\n\n  * Using `[x,y]` to concatenate arrays is deprecated, and in the future will\n    construct a vector of `x` and `y` instead ([#3737], [#2488], [#8599]).\n\n  * Significant improvements to `ccall` and `cfunction`\n\n    * As a safer alternative to creating pointers (`Ptr`), the managed reference type\n      `Ref` has been added. A `Ref` points to the data contained by a value in an\n      abstract sense, and in a way that is GC-safe. For example, `Ref(2)` points to\n      a storage location that contains the integer `2`, and `Ref(array,3)` points\n      to the third element of an array. A `Ref` can be automatically converted to a\n      native pointer when passed to a `ccall`.\n\n    * When passing a by-reference argument to `ccall`, you can declare\n      the argument type to be `Ref{T}` instead of `Ptr{T}`, and just\n      pass `x` instead of `&x`.\n\n    * `ccall` is now lowered to call `unsafe_convert(T, cconvert(T, x))` on each\n      argument. `cconvert` falls back to `convert`, but can be used to convert an\n      argument to an arbitrarily-different representation more suitable for passing\n      to C. `unsafe_convert` then handles conversions to `Ptr`.\n\n    * `ccall` and `cfunction` now support correctly passing and returning structs,\n      following the platform ABI (assuming the C types are mirrored accurately in Julia).\n\n    * `cfunction` arguments of struct-like Julia types are now passed by value.\n      If `Ref{T}` is used as a `cfunction` argument type, it will look up the\n      method applicable to `T`, but pass the argument by reference (as Julia functions\n      usually do). However, this should only be used for objects allocated by Julia\n      and for `isbits` types.\n\n  * `convert(Ptr,x)` is deprecated for most types, replaced by\n    `unsafe_convert`. You can still `convert` between pointer types,\n    and between pointers and `Int` or `UInt`.\n\n  * Module `__init__` methods no longer swallow thrown exceptions; they now\n    throw an `InitError` wrapping the thrown exception ([#12576]).\n\n  * Unsigned `BigInt` literal syntax has been removed ([#11105]).\n    Unsigned literals larger than `UInt128` now throw a syntax error.\n\n  * `error(::Exception)` and `error(::Type{Exception})` have been deprecated\n     in favor of using an explicit `throw` ([#9690]).\n\n  * `Uint` etcetera are renamed to `UInt` ([#8905]).\n\n  * `String` is renamed to `AbstractString` ([#8872]).\n\n  * `FloatingPoint` is renamed to `AbstractFloat` ([#12162]).\n\n  * `None` is deprecated; use `Union{}` instead ([#8423]).\n\n  * `Nothing` (the type of `nothing`) is renamed to `Void` ([#8423]).\n\n  * Arrays can be constructed with the syntax `Array{T}(m,n)` ([#3214], [#10075]).\n\n  * `Dict` literal syntax `[a=>b,c=>d]` is replaced by `Dict(a=>b,c=>d)`,\n    `{a=>b}` is replaced by `Dict{Any,Any}(a=>b)`, and\n    `(K=>V)[...]` is replaced by `Dict{K,V}(...)`.\n    The new syntax has many advantages: all of its components are first-class,\n    it generalizes to other types of containers, it is easier to guess how to\n    specify key and value types, and the syntaxes for empty and pre-populated\n    dicts are synchronized. As part of this change, `=>` is parsed as a normal\n    operator, and `Base` defines it to construct `Pair` objects ([#6739]).\n\n  * `Char` is no longer a subtype of `Integer` ([#8816]).\n    Char now supports a more limited set of operations with `Integer` types:\n\n      * comparison / equality\n      * `Char` + `Int` = `Char`\n      * `Char` - `Char` = `Int`\n\n  * `round` rounds to the nearest integer using the default rounding mode,\n    which is ties-to-even by default ([#8750]).\n\n  * A custom triple-quoted string like `x\"\"\"...\"\"\"` no longer invokes an `x_mstr`\n    macro. Instead, the string is first unindented and then `x_str` is invoked,\n    as if the string had been single-quoted ([#10228]).\n\n  * Colons (`:`) within indexing expressions are no longer lowered to the range\n    `1:end`. Instead, the `:` identifier is passed directly. Custom array types\n    that implement `getindex` or `setindex!` methods must also extend those\n    methods to support arguments of type `Colon` ([#10331]).\n\n  * Unions of types should now be written with curly braces instead of parentheses, i.e.\n    `Union{Type1, Type2}` instead of `Union(Type1, Type2)` ([#11432]).\n\n  * The keyword `local` is no longer allowed in global scope. Use `let` instead of\n    `begin` to create a new scope from the top level ([#7234], [#10472]).\n\n  * Triple-quoted strings no longer treat tabs as 8 spaces. Instead, the\n    longest common prefix of spaces and tabs is removed.\n\n  * `global x` in a nested scope is now a syntax error if `x` is local\n    to the enclosing scope ([#7264]/[#11985]).\n\n  * The default `importall Base.Operators` is deprecated, and relying on it\n    will give a warning ([#8113]).\n\n  * `remotecall_fetch` and `fetch` now rethrow any uncaught remote exception locally as a\n    `RemoteException`. Previously they would return the remote exception object.\n    The worker pid, remote exception and remote backtrace are available in the\n    thrown `RemoteException`.\n\n  * If any of the enclosed async operations in a `@sync` block throw exceptions, they\n    are now collected in a `CompositeException` and the `CompositeException` thrown.\n\n\nCommand line option changes\n---------------------------\n\n  * The `-i` option now forces the REPL to run after loading the specified script (if any) ([#11347]).\n\n  * New option `--handle-signals={yes|no}` to disable Julia's signal handlers.\n\n  * The `--depwarn={yes|no|error}` option enables/disables syntax and method deprecation warnings,\n    or turns them into errors ([#9294]).\n\n  * Some command line options are slated for deprecation / removal\n    - `-f, --no-startup` Don't load ~/.juliarc (deprecated, use --startup-file=no)\n    - `-F` Load ~/.juliarc (deprecated, use --startup-file=yes)`\n    - `-P, --post-boot <expr>`  Evaluate <expr>, but don't disable interactive mode (deprecated, use -i -e instead)\n    - `--no-history-file`  Don't load history file (deprecated, use --history-file=no)\n\nCompiler/Runtime improvements\n-----------------------------\n\n  * Functions may be annotated with metadata (`:meta` expressions) to be used by the compiler ([#8297]).\n\n  * `@inline` before a function definition forces the compiler to inline the function ([#8297]).\n\n  * Loads from heap-allocated immutables are hoisted out of loops in more cases ([#8867]).\n\n  * Accessing fields that are always initialized no longer produces undefined checks ([#8827]).\n\n  * New generational garbage collector which greatly reduces GC overhead for many commmon workloads ([#5227]).\n\nLibrary improvements\n--------------------\n\n  * Build with USE_GPL_LIBS=0 to exclude all GPL libraries and code ([#10870]).\n\n  * Linear algebra\n\n    * The `LinAlg` module is now exported.\n\n    * `sparse(A)` now takes any `AbstractMatrix` A as an argument ([#10031]).\n\n    * Factorization API is now type-stable; functions dispatch on `Val{false}` or `Val{true}` instead of a boolean value ([#9575]).\n\n    * Added generic Cholesky factorization, and the Cholesky factorization is now parametrized by the matrix type ([#7236]).\n\n    * Sparse `cholfact` and `ldltfact` functions now accept a `perm` keyword\n      for user-provided permutations and a `shift` keyword to factorize\n      a shifted matrix ([#10844]).\n\n    * New `svds` function for the sparse truncated SVD ([#9425]).\n\n    * `Symmetric` and `Hermitian` immutables are now parametrized by the matrix type ([#7992]).\n\n    * New `ordschur` and `ordschur!` functions for sorting a Schur factorization by the eigenvalues ([#8467],[#9701]).\n\n    * `Givens` type doesn't have a size anymore and is no longer a subtype of `AbstractMatrix` ([#8660]).\n\n    * Large speedup in sparse `\\` and splitting of Cholesky and LDL\u1d40 factorizations into `cholfact` and `ldltfact` ([#10117]).\n\n    * Add sparse least squares to `\\` by adding `qrfact` for sparse matrices based on the SPQR library ([#10180]).\n\n    * Split `Triangular` type into `UpperTriangular`, `LowerTriangular`, `UnitUpperTriagular` and `UnitLowerTriangular` ([#9779])\n\n    * OpenBLAS 64-bit (ILP64) interface is now compiled with a `64_` suffix ([#8734]) to avoid conflicts with external libraries using a 32-bit BLAS ([#4923]).\n\n    * New `vecdot` function, analogous to `vecnorm`, for Euclidean inner products over any iterable container ([#11067]).\n\n    * `p = plan_fft(x)` and similar functions now return a `Base.DFT.Plan` object, rather\n    than an anonymous function.  Calling it via `p(x)` is deprecated in favor of\n    `p * x` or `p \\ x` (for the inverse), and it can also be used with `A_mul_B!`\n    to employ pre-allocated output arrays ([#12087]).\n\n    * `LU{T,Tridiagonal{T}}` now supports extraction of `L`, `U`, `p`, and `P` factors ([#12137]).\n\n    * Allocations in sparse matrix factorizations are now tracked by Julia's garbage collector ([#12034]).\n\n  * Strings\n\n    * NUL-terminated strings should now be passed to C via the new `Cstring` type, not `Ptr{UInt8}` or `Ptr{Cchar}`,\n      in order to check whether the string is free of NUL characters (which would cause silent truncation in C).\n      The analogous type `Cwstring` should be used for NUL-terminated `wchar_t*` strings ([#10994]).\n\n    * `graphemes(s)` returns an iterator over grapheme substrings of `s` ([#9261]).\n\n    * Character predicates such as `islower()`, `isspace()`, etc. use\n      utf8proc to provide uniform cross-platform behavior and\n      up-to-date, locale-independent support for Unicode standards\n      ([#5939]).\n\n    * `reverseind` function to convert indices in reversed strings (e.g. from\n      reversed regex searches) to indices in the original string ([#9249]).\n\n    * `charwidth(c)` and `strwidth(s)` now return up-to-date cross-platform\n      results (via utf8proc) ([#10659]): Julia now likes pizza ([#3721]), but some terminals still don't.\n\n    * `is_valid_char(c)`, (now `isvalid(Char,c)` ([#11241])), now correctly handles Unicode \"non-characters\", which are valid Unicode codepoints ([#11171]).\n\n    * Backreferences in replacement strings in calls to `replace` with a `Regex` pattern are now supported ([#11849]).\n      Use the `s` string prefix to indicate a replacement string contains a backreference. For example, `replace(\"ab\", r\"(.)(.)\", s\"\\2\\1\")` yields \"ba\".\n\n    * Capture groups in regular expressions can now be named using PCRE syntax, `(?P<group_name>...)`. Capture group matches can be accessed by name by indexing a `Match` object with the name of the group ([#11566]).\n\n    * `countlines()` now counts all lines, not just non-empty ([#11947]).\n\n  * Array and AbstractArray improvements\n\n    * New multidimensional iterators and index types for efficient iteration over `AbstractArray`s. Array iteration should generally be written as `for i in eachindex(A) ... end` rather than `for i = 1:length(A) ... end` ([#8432]).\n\n    * New implementation of SubArrays with substantial performance and functionality improvements ([#8501]).\n\n    * AbstractArray subtypes only need to implement `size` and `getindex`\n      for scalar indices to support indexing; all other indexing behaviors\n      (including logical indexing, ranges of indices, vectors, colons, etc.) are\n      implemented in default fallbacks. Similarly, they only need to implement\n      scalar `setindex!` to support all forms of indexed assingment ([#10525]).\n\n    * AbstractArrays that do not extend `similar` now return an `Array` by\n      default ([#10525]).\n\n  * Data structures\n\n    * New `sortperm!` function for pre-allocated index arrays ([#8792]).\n\n    * Switch from `O(N)` to `O(log N)` algorithm for `dequeue!(pq, key)`\n    with `PriorityQueue`. This provides major speedups for large\n    queues ([#8011]).\n\n    * `PriorityQueue` now includes the order type among its\n      parameters, `PriorityQueue{KeyType,ValueType,OrderType}`. An\n      empty queue can be constructed as `pq =\n      PriorityQueue(KeyType,ValueType)`, if you intend to use the\n      default `Forward` order, or `pq = PriorityQueue(KeyType,\n      ValueType, OrderType)` otherwise ([#8011]).\n\n    * Efficient `mean` and `median` for ranges ([#8089]).\n\n    * `deepcopy` recurses through immutable types and makes copies of their mutable fields ([#8560]).\n\n    * `copy(a::DArray)` will now make a copy of a `DArray` ([#9745]).\n\n  * New types\n\n    * Enums are now supported through the `@enum EnumName EnumValue1\n      EnumValue2` syntax. Enum member values also support abitrary\n      value assignment by the `@enum EnumName EnumValue1=1\n      EnumValue2=10 EnumValue3=20` syntax ([#10168]).\n\n    * New `Dates` module for calendar dates and other time-interval calculations ([#7654]).\n\n    * New `Nullable` type for missing data ([#8152]).\n\n    * A new `Val{T}` type allows one to dispatch on bits-type values ([#9452]).\n\n    * `linspace` now returns a `LinSpace` object which lazily computes linear interpolation of values between the start and stop values. It \"lifts\" endpoints which are approximately rational in the same manner as the `colon` operator.\n\n  * Arithmetic\n\n    * `convert` now checks for overflow when truncating integers or converting between\n    signed and unsigned ([#5413]).\n\n    * Arithmetic is type-preserving for more types; e.g. `(x::Int8) + (y::Int8)` now\n    yields an `Int8` ([#3759]).\n\n    * Reductions (e.g. `reduce`, `sum`) widen small types (integers smaller than `Int`, and `Float16`).\n\n    * Added optional rounding argument to floating-point constructors ([#8845]).\n\n    * Equality (`==`) and inequality (`<`/`<=`) comparisons are now correct\n      across all numeric types ([#9133], [#9198]).\n\n    * Rational arithmetic throws errors on overflow ([#8672]).\n\n    * Optional `log` and `log1p` functions implemented in pure Julia (experimental) ([#10008]).\n\n    * The `MathConst` type has been renamed `Irrational` ([#11922]).\n\n    * `isapprox` now has simpler and more sensible default tolerances ([#12393]), supports arrays, and has synonyms `\u2248` ([U+2248](http://www.fileformat.info/info/unicode/char/2248/index.htm), LaTeX `\\approx`) and `\u2249` ([U+2249](http://www.fileformat.info/info/unicode/char/2249/index.htm), LaTeX `\\napprox`) for `isapprox` and `!isapprox`, respectively ([#12472]).\n\n  * Numbers\n\n    * `primes` is now faster and has been extended to generate the primes in a user defined closed interval ([#12025]).\n\n    * The function `primesmask` which generates a prime sieve for a user defined closed interval is now exported ([#12025]).\n\n  * Random numbers\n\n    * Streamlined random number generation APIs [#8246].\n    The default `rand` no longer uses global state in the underlying C library,\n    dSFMT, making it closer to being thread-safe ([#8399], [#8832]).\n    All APIs can now take an `AbstractRNG` argument ([#8854], [#9065]). The seed argument to `srand` is now optional ([#8320], [#8854]).\n    The APIs accepting a range argument are extended to accept an arbitrary\n    `AbstractArray` ([#9049]).\n    Passing a range of `BigInt` to `rand` or `rand!` is now supported ([#9122]).\n    There are speed improvements across the board ([#8808], [#8941], [#8958], [#9083]).\n\n    * Significantly faster `randn` ([#9126], [#9132]).\n\n    * The `randexp` and `randexp!` functions are exported ([#9144]).\n\n  * File\n\n    * Added function `readlink` which returns the value of a symbolic link \"path\" ([#10714]).\n\n    * Added function `ismount` which checks if a directory is a mount point ([#11279]).\n\n    * The `cp` function now accepts keyword arguments `remove_destination` and `follow_symlinks` ([#10888]).\n\n    * The `mv` function now accepts keyword argument `remove_destination` ([#11145]).\n\n  * `Pipe()` creates a bidirectional I/O object that can be passed to `spawn` or `pipeline`\n    for redirecting process streams ([#12739]).\n\n  * Other improvements\n\n    * You can now tab-complete emoji via their [short names](http://www.emoji-cheat-sheet.com/), using `\\:name:<tab>` ([#10709]).\n\n    * `gc_enable` subsumes `gc_disable`, and also returns the previous GC state.\n\n    * `assert`, `@assert` now throws an `AssertionError` exception type ([#9734]).\n\n    * `@simd` now rejects invalid control flow (`@goto` / break / continue) in the inner loop body at compile time ([#8624]).\n\n    * The `machinefile` now supports a host count ([#7616]).\n\n    * `code_native` now outputs branch labels ([#8897]).\n\n    * Added `recvfrom` to get source address of UDP packets ([#9418]).\n\n    * `ClusterManager` performance improvements ([#9309]) and support for changing transports([#9434]).\n\n    * Added `Base.get_process_title` / `Base.set_process_title` ([#9957]).\n\n    * `readavailable` now returns a byte vector instead of a string.\n\n    * New `lock` and `unlock` functions, operating on `ReentrantLock`, to lock a stream during\n      concurrent writes from multiple tasks ([#10679]).\n\n    * `code_llvm` now outputs stripped IR without debug info or other attached metadata.\n      Use `code_llvm_raw` for the unstripped output ([#10747]).\n\n    * New `withenv(var=>val, ...) do ... end` function to temporarily\n      modify environment variables ([#10914]).\n\n    * New function `relpath` returns a relative filepath to path either from the current\n      directory or from an optional start directory ([#10893]).\n\n    * `mktemp` and `mktempdir` now take an optional argument to set which\n      directory the temporary file or directory is created in.\n\n    * New garbage collector tracked memory allocator functions: `jl_malloc`, `jl_calloc`,\n    `jl_realloc`, and `jl_free` with libc API ([[#12034]]).\n\n    * `mktempdir` and `mktemp` now have variants that take a function as its\n      first argument for automated clean-up ([[#9017]]).\n\nDeprecated or removed\n---------------------\n\n  * several syntax whitespace insensitivities have been deprecated ([#11891]).\n    ```julia\n     # function call\n     f (x)\n\n     # getindex\n     x [17]\n     rand(2) [1]\n\n     # function definition\n     f (x) = x^2\n     function foo (x)\n\tx^2\n     end\n    ```\n\n  * indexing with `Real`s that are not subtypes of `Integer` (`Rational`, `AbstractFloat`, etc.) has been deprecated ([#10458]).\n\n  * `push!(A)` has been deprecated, use `append!` instead of splatting arguments to `push!` ([#10400]).\n\n  * `names` for composite datatypes has been deprecated and\n    renamed to `fieldnames` ([#10332]).\n\n  * `DArray` functionality has been removed from `Base` and is now a\n    standalone package under the JuliaParallel umbrella organization ([#10333]).\n\n  * The `Graphics` module has been removed from `Base` and is now a\n    standalone package ([#10150], [#9862]).\n\n  * The `Woodbury` special matrix type has been removed from `LinAlg` ([#10024]).\n\n  * `median` and `median!` no longer accept a `checknan` keyword argument ([#8605]).\n\n  * `inf` and `nan` are now deprecated in favor of `T(Inf)` and `T(NaN)`, respectively ([#8776]).\n\n  * `oftype(T::Type, x)` is deprecated in favor of `convert(T,x)` (or `T(x)`).\n\n  * `{...}` syntax is deprecated in favor of `Any[...]` ([#8578]).\n\n  * `itrunc`, `ifloor`, `iceil` and `iround` are deprecated in favour of\n    `trunc{T<:Integer}(T,x)`, `floor{T<:Integer}(T,x)`, etc.. `trunc` is now\n    always bound-checked;`Base.unsafe_trunc` provides the old unchecked `itrunc`\n    behaviour ([#9133]).\n\n  * `squeeze` now requires that passed dimension(s) are an `Int` or tuple of `Int`s;\n    calling `squeeze` with an arbitrary iterator is deprecated ([#9271]).\n    Additionally, passed dimensions must be unique and correspond to extant\n    dimensions of the input array.\n\n  * `randbool` is deprecated. Use `rand(Bool)` to produce a random boolean value, and\n    `bitrand` to produce a random BitArray ([#9105], [#9569]).\n\n  * `beginswith` is renamed to `startswith` ([#9578]).\n\n  * `null` is renamed to `nullspace` ([#9714]).\n\n  * The operators `|>`, `.>`, `>>`, and `.>>` as used for process I/O redirection\n    are replaced with the `pipeline` function ([#5349], [#12739]).\n\n  * `flipud(A)` and `fliplr(A)` have been deprecated in favor of `flipdim(A, 1)` and\n    `flipdim(A, 2)`, respectively ([#10446]).\n\n  * Numeric conversion functions whose names are lower-case versions of type\n    names have been removed. To convert a scalar, use the type name, e.g.\n    `Int32(x)`. To convert an array to a different element type, use\n    `Array{T}(x)`, `map(T,x)`, or `round(T,x)`. To parse a string as an integer\n    or floating-point number, use `parse` ([#1470], [#6211]).\n\n  * Low-level functions from the C library and dynamic linker have been moved to\n    modules `Libc` and `Libdl`, respectively ([#10328]).\n\n  * The functions `parseint`, `parsefloat`, `float32_isvalid`,\n  `float64_isvalid`, and the string-argument `BigInt` and `BigFloat` have\n  been replaced by `parse` and `tryparse` with a type argument. The string\n  macro `big\"xx\"` can be used to construct `BigInt` and `BigFloat` literals\n  ([#3631], [#5704], [#9487], [#10543], [#10955]).\n\n  * the `--int-literals` compiler option is no longer accepted ([#9597]).\n\n  * Instead of `linrange`, use `linspace` ([#9666]).\n\n  * The functions `is_valid_char`, `is_valid_ascii`, `is_valid_utf8`, `is_valid_utf16`, and\n    `is_valid_utf32` have been replaced by generic `isvalid` methods.\n    The single argument form `isvalid(value)` can now be used for values of type `Char`, `ASCIIString`,\n    `UTF8String`, `UTF16String` and `UTF32String`.\n    The two argument form `isvalid(type, value)` can be used with the above types, with values\n    of type `Vector{UInt8}`, `Vector{UInt16}`, `Vector{UInt32}`, and `Vector{Char}` ([#11241]).\n\n  * Instead of `utf32(64,123,...)` use `utf32(UInt32[64,123,...])` ([#11379]).\n\n  * `start_timer` and `stop_timer` are replaced by `Timer` and `close`.\n\n  * The following internal julia C functions have been renamed, in order to prevent\n    potential naming conflicts with C libraries: ([#11741])\n\n    * `gc_wb*` -> `jl_gc_wb*`\n\n    * `gc_queue_root` -> `jl_gc_queue_root`\n\n    * `allocobj` -> `jl_gc_allocobj`\n\n    * `alloc_[0-3]w` -> `jl_gc_alloc_*w`\n\n    * `diff_gc_total_bytes` -> `jl_gc_diff_total_bytes`\n\n    * `sync_gc_total_bytes` -> `jl_gc_sync_total_bytes`\n\n  * `require(::AbstractString)` and `reload` (see news about addition of `compile`).\n\n  * `cartesianmap` is deprecated in favor of iterating over a `CartesianRange`\n\nJulia v0.3.0 Release Notes\n==========================\n\nNew language features\n---------------------\n\n  * Greatly enhanced performance for passing and returning `Tuple`s ([#4042]).\n\n  * `Tuple`s (of `Integer`s, `Symbol`s, or `Bool`s) can now be used as type\n    parameters ([#5164]).\n\n  * An additional default \"inner\" constructor accepting any arguments is now\n    generated. Constructors that look like `MyType(a, b) = new(a, b)` do not\n    need to be added manually ([#4026], [#7071]).\n\n  * Expanded array type hierarchy to include an abstract `DenseArray` for\n    in-memory arrays with standard strided storage ([#987], [#2345],\n    [#6212]).\n\n  * When reloading code, types whose definitions have not changed can be\n    ignored in some cases.\n\n  * Binary `~` now parses as a vararg macro call to `@~`.\n    For example `x~y~z` => `@~ x y z` ([#4882]).\n\n  * Structure fields can now be accessed by index ([#4806]).\n\n  * If a module contains a function `__init__()`, it will be called when\n    the module is first loaded, and on process startup if a pre-compiled\n    version of the module is present ([#1268]).\n\n  * Multi-line comments ([#69], [#6128]): `#= .... =#`\n\n  * `--check-bounds=yes|no` compiler option\n\n  * Unicode identifiers are normalized (NFC) so that different encodings\n    of equivalent strings are treated as the same identifier ([#5462]).\n\n  * The set of characters permitted in identifiers has been restricted based\n    on Unicode categories. Generally, punctuation, formatting and control\n    characters, and operator symbols are not allowed in identifiers.\n    Number-like characters cannot begin identifiers ([#5936]).\n\n  * Define a limited number of infix Unicode operators ([#552], [#6582]):\n\n    | Precedence class | Operators (with synonyms, if any)\n    | ---------------- | ---------------------------------\n    |   ==             |  \u2265 (>=) \u2264 (<=) \u2261 (===) \u2260 (!=) \u2262 (!==) .\u2265 (.>=) .\u2264 (.<=) .!= (.\u2260) \u2208 (`in`) \u2209 (`(x,y)->!in(x, y)`) \u220b (`(x,y)->in(y, x)`) \u220c (`(x,y)->!in(y, x)`) \u2286 (`issubset`) \u2288 (`(x,y)->!issubset(x, y)`) \u228a (`(x,y)->x\u2286y && x!=y`) |\n    |   +              | \u222a (`union`) |\n    |   *              | \u00f7 (`div`) \u22c5 (`dot`) \u00d7 (`cross`) \u2229 (`intersect`) |\n    |   unary          | \u221a \u221b |\n\n    In addition to these, many of the Unicode operator symbols are parsed\n    as infix operators and are available for user-defined methods ([#6929]).\n\n  * Improved reporting of syntax errors ([#6179])\n\n  * `break` inside a `for` loop with multiple ranges now exits the entire loop nest ([#5154])\n\n  * Local goto statements using the `@goto` and `@label` macros ([#101]).\n\nREPL improvements\n-----------------\n\n  * New native-Julia REPL implementation, eliminating many problems\n    stemming from the old GNU Readline-based REPL ([#6270]).\n\n  * Tab-substitution of LaTeX math symbols (e.g. `\\alpha` by `\u03b1`) ([#6911]).\n    This also works in IJulia and in Emacs ([#6920]).\n\n  * `workspace()` function for obtaining a fresh workspace ([#1195]).\n\nLibrary improvements\n--------------------\n\n  * `isequal` now compares all numbers by value, ignoring type ([#6624]).\n\n  * Implement limited shared-memory parallelism with `SharedArray`s ([#5380]).\n\n  * Well-behaved floating-point ranges ([#2333], [#5636]).\n    Introduced the `FloatRange` type for floating-point ranges with a step,\n    which will give intuitive/correct results for classically problematic\n    ranges like `0.1:0.1:0.3`, `0.0:0.7:2.1` or `1.0:1/49:27.0`.\n\n  * `mod2pi` function ([#4799], [#4862]).\n\n  * New functions `minmax` and `extrema` ([#5275]).\n\n  * New macros `@edit`, `@less`, `@code_typed`, `@code_lowered`, `@code_llvm` and `@code_native` that all function like `@which` ([#5832]).\n\n  * `consume(p)` extended to `consume(p, args...)`, allowing it\n    to optionally pass `args...` back to the producer ([#4775]).\n\n  * `.juliarc.jl` is now loaded for both script and REPL execution ([#5076]).\n\n  * The `Sys` module now includes convenient functions for working with\n    dynamic library handles; `Sys.dllist` will list out all paths currently\n    loaded via `dlopen`, and `Sys.dlpath` will lookup a path from a handle\n\n  * `readdlm` treats multiple whitespace characters as a single delimiter\n    by default (when no delimiter is specified). This is useful for reading\n    fixed-width or messy whitespace-delimited data ([#5403]).\n\n  * The Airy, Bessel, Hankel, and related functions (`airy*`,\n    `bessel*`, `hankel*`) now detect errors returned by the underlying\n    AMOS library, throwing an `AmosException` in that case ([#4967]).\n\n  * `methodswith` now returns an array of `Method`s ([#5464]) rather\n    than just printing its results.\n\n  * `errno([code])` function to get or set the C library's `errno`.\n\n  * `GitHub` module for interacting with the GitHub API.\n\n  * Package improvements\n\n    * Packages are now installed into `.julia/v0.3` by default (or\n      whatever the current Julia version is), so that different\n      versions of Julia can co-exist with incompatible packages.\n      Existing `.julia` installations are unaffected unless `Pkg.init()`\n      is run to re-create the package directories ([#3344], [#5737]).\n\n    * `Pkg.submit(pkg[,commit])` function to automatically submit\n      a GitHub pull request to the package author.\n\n  * Collections improvements\n\n    * `Array` assignment (e.g. `x[:] = y`) ignores singleton dimensions\n      and allows the last dimension of one side to match all trailing dimensions\n      of the other ([#4048], [#4383]).\n\n    * `Dict(kv)` constructor for any iterator on `(key,value)` pairs.\n\n    * Multi-key `Dict`s: `D[x,y...]` is now a synonym for `D[(x,y...)]`\n      for associations `D` ([#4870]).\n\n    * `push!` and `unshift!` can push multiple arguments ([#4782]).\n\n    * `writedlm` and `writecsv` now accept any iterable collection of\n      iterable rows, in addition to `AbstractArray` arguments, and the\n      `writedlm` delimiter can be any printable object (e.g. a\n      `String`) instead of just a `Char`.\n\n    * `isempty` now works for any iterable collection ([#5827]).\n\n    * `unique` now accepts an optional `dim` argument for finding\n      unique rows or columns of a matrix or regions of a\n      multidimensional array ([#5811]).\n\n  * `Number` improvements\n\n    * The `ImaginaryUnit` type no longer exists. Instead, `im` is of type\n      `Complex{Bool}`. Making this work required changing the semantics of\n      boolean multiplication to approximately, `true * x = x` and\n      `false * x = zero(x)`, which can itself be considered useful ([#5468]).\n\n    * `big` is now vectorized ([#4766])\n\n    * `nextpow` and `prevpow` now return the `a^n` values instead of the\n      exponent `n` ([#4819])\n\n    * Overflow detection in `parseint` ([#4874]).\n\n    * `rand` now supports arbitrary `Ranges` arguments ([#5059]).\n\n    * `expm1` and `log1p` now support complex arguments ([#3141]).\n\n    * Broadcasting `.//` is now included ([#7094]).\n\n    * `prevfloat` and `nextfloat` now saturate at -Inf and Inf,\n      respectively, and have otherwise been fixed to follow the IEEE-754\n      standard functions `nextDown` and `nextUp` ([#5025]).\n\n    * New function `widen` for widening numeric types and values, and `widemul`\n      for multiplying to a larger type ([#6169]).\n\n    * `polygamma`, `digamma`, and `trigamma` now accept complex\n      arguments, and `zeta(s, z)` now provides the Hurwitz zeta ([#7125]).\n\n    * Narrow integer types (< 32 bits) are promoted to `Float64` rather\n      than to `Float32` by `float(x)` ([#7390]).\n\n  * `String` improvements\n\n    * Triple-quoted regex strings, `r\"\"\"...\"\"\"` ([#4934]).\n\n    * New string type, `UTF16String` ([#4930]), constructed by\n      `utf16(s)` from another string, a `Uint16` array or pointer, or\n      a byte array (possibly prefixed by a byte-order marker to\n      indicate endian-ness).  Its data is internally `NULL`-terminated\n      for passing to C ([#7016]).\n\n    * `CharString` is renamed to `UTF32String` ([#4943]), and its data\n      is now internally `NULL`-terminated for passing to C ([#7016]).\n      `CharString(c::Char...)` is deprecated in favor of `utf32(c...)`,\n      and `utf32(s)` otherwise has functionality similar to `utf16(s)`.\n\n    * New `WString` and `wstring` synonyms for either `UTF16String`\n      and `utf16` or `UTF32String` and `utf32`, respectively, depending\n      on the width of `Cwchar_t` ([#7016]).\n\n    * `normalize_string` function to perform Unicode normalization,\n      case-folding, and other transformations ([#5576]).\n\n    * `pointer(s, i=1)` for `ByteString`, `UTF16String`, `UTF32String`,\n      and `SubString`s thereof ([#5703]).\n\n    * `bytestring` is automatically called on `String` arguments for\n      conversion to `Ptr{Uint8}` in `ccall` ([#5677]).\n\n  * Linear algebra improvements\n\n      * Balancing options for eigenvector calculations for general matrices ([#5428]).\n\n      * Mutating linear algebra functions no longer promote ([#5526]).\n\n      * `condskeel` for Skeel condition numbers ([#5726]).\n\n      * `norm(::Matrix)` no longer calculates a vector norm when the first\n        dimension is one ([#5545]); it always uses the operator (induced)\n        matrix norm.\n\n      * New `vecnorm(itr, p=2)` function that computes the norm of\n        any iterable collection of numbers as if it were a vector of\n        the same length.  This generalizes and replaces `normfro` ([#6057]),\n        and `norm` is now type-stable ([#6056]).\n\n      * New `UniformScaling` matrix type and identity `I` constant ([#5810]).\n\n      * None of the concrete matrix factorization types are exported from `Base`\n        by default anymore.\n\n    * Sparse linear algebra\n\n      * 1-d sparse `getindex` has been implemented ([#7047])\n\n      * Faster sparse `getindex` ([#7131]).\n\n      * Faster sparse `kron` ([#4958]).\n\n      * `sparse(A) \\ B` now supports a matrix `B` of right-hand sides ([#5196]).\n\n      * `eigs(A, sigma)` now uses shift-and-invert for nonzero shifts `sigma` and inverse iteration for `which=\"SM\"`. If `sigma==nothing` (the new default), computes ordinary (forward) iterations ([#5776]).\n\n      * `sprand` is faster, and whether any entry is nonzero is now determined independently with the specified probability ([#6726]).\n\n    * Dense linear algebra for special matrix types\n\n      * Interconversions between the special matrix types `Diagonal`, `Bidiagonal`,\n        `SymTridiagonal`, `Triangular`, and `Triangular`, and `Matrix` are now allowed\n        for matrices which are representable in both source and destination types ([5e3f074b]).\n\n      * Allow for addition and subtraction over mixed matrix types, automatically promoting\n        the result to the denser matrix type ([a448e080], [#5927])\n\n      * new algorithms for linear solvers and eigensystems of `Bidiagonal`\n        matrices of generic element types ([#5277])\n\n      * new algorithms for linear solvers, eigensystems and singular systems of `Diagonal`\n        matrices of generic element types ([#5263])\n\n      * new algorithms for linear solvers and eigensystems of `Triangular`\n        matrices of generic element types ([#5255])\n\n      * specialized `inv` and `det` methods for `Tridiagonal` and `SymTridiagonal`\n        based on recurrence relations between principal minors ([#5358])\n\n      * specialized `transpose`, `ctranspose`, `istril`, `istriu` methods for\n        `Triangular` ([#5255]) and `Bidiagonal` ([#5277])\n\n      * new LAPACK wrappers\n        - condition number estimate `cond(A::Triangular)` ([#5255])\n\n      * parametrize `Triangular` on matrix type ([#7064])\n\n      * Lyapunov / Sylvester solver ([#7435])\n\n      * `eigvals` for `Symmetric`, `Tridiagonal` and `Hermitian` matrices now\n        support additional method signatures: ([#3688], [#6652], [#6678], [#7647])\n        - `eigvals(M, el, eu)` finds all eigenvalues in the interval `(el, eu]`\n        - `eigvals(M, il:iu)` finds the `il`th through the `iu`th eigenvalues (in ascending order)\n\n    * Dense linear algebra for generic matrix element types\n\n      * LU factorization ([#5381] and [#5430])\n\n      * QR factorization ([#5526])\n\n  * New function `deleteat!` deletes a specified index or indices and\n    returns the updated collection\n\n  * The `setenv` function for external processes now accepts a `dir` keyword\n    argument for specifying the directory to start the child process in ([#4888]).\n\n  * Constructors for collections (`Set`, `Dict`, etc.) now generally accept a\n    single iterable argument giving the elements of the collection ([#4996], [#4871])\n\n  * Ranges and arrays with the same elements are now unequal. This allows hashing\n    and comparing ranges to be faster ([#5778]).\n\n  * Broadcasting now works on arbitrary `AbstractArrays` ([#5387])\n\n  * Reduction functions that accept a pre-allocated output array, including\n    `sum!`, `prod!`, `maximum!`, `minimum!`, `all!`, `any!` ([#6197], [#5387])\n\n  * Faster performance on `fill!` and `copy!` for array types not supporting\n    efficient linear indexing ([#5671], [#5387])\n\n  * Changes to range types ([#5585])\n\n    * `Range` is now the abstract range type, instead of `Ranges`\n\n    * New function `range` for constructing ranges by length\n\n    * `Range` is now `StepRange`, and `Range1` is now `UnitRange`. Their\n      constructors accept end points instead of lengths. Both are subtypes of a\n      new abstract type `OrdinalRange`.\n\n    * Ranges now support `BigInt` and general ordinal types.\n\n    * Very large ranges (e.g. `0:typemax(Int)`) can now be constructed, but some\n      operations (e.g. `length`) will raise an `OverflowError`.\n\n  * Extended API for `cov` and `cor`, which accept keyword arguments `vardim`,\n    `corrected`, and `mean` ([#6273])\n\n  * New functions `randsubseq` and `randsubseq!` to create a random subsequence of an array ([#6726])\n\n  * New macro `@evalpoly` for efficient inline evaluation of polynomials ([#7146]).\n\n  * The signal filtering function `filt` now accepts an optional initial filter state vector. A new in-place function `filt!` is also exported ([#7513]).\n\n  * Significantly faster `cumsum` and `cumprod` ([#7359]).\n\n  * Implement `findmin` and `findmax` over specified array dimensions ([#6716]).\n\n  * Support memory-mapping of files with offsets on Windows ([#7242]).\n\n  * Catch writes to protect memory, such as when trying to modify a mmapped file opened in read-only mode ([#3434]).\n\nEnvironment improvements\n------------------------\n\n  * New `--code-coverage` and `--track-allocation` startup features allow one to measure the number of executions or the amount of memory allocated, respectively, at each line of code ([#5423],[#7464]).\n\n  * `Profile.init` now accepts keyword arguments, and returns the current settings when no arguments are supplied ([#7365]).\n\nBuild improvements\n------------------\n\n  * Dependencies are now verified against stored MD5/SHA512 hashes, to ensure\n    that the correct file has been downloaded and was not modified ([#6773]).\n\n\nDeprecated or removed\n---------------------\n\n  * `convert(Ptr{T1}, x::Array{T2})` is now deprecated unless `T1 == T2`\n    or `T1 == Void` ([#6073]).  (You can still explicitly `convert`\n    one pointer type into another if needed.)\n\n  * `Sys.shlib_ext` has been renamed to `Sys.dlext`\n\n  * `dense` is deprecated in favor of `full` ([#4759]).\n\n  * The `Stat` type is renamed `StatStruct` ([#4670]).\n\n  * `setrounding`, `rounding` and `setrounding` now take an additional\n    argument specifying the floating point type to which they apply. The old\n    behaviour and `[get/set/with]_bigfloat_rounding` functions are deprecated ([#5007]).\n\n  * `cholpfact` and `qrpfact` are deprecated in favor of keyword arguments in\n    `cholfact(..., pivot=true)` and `qrfact(..., pivot=true)` ([#5330]).\n\n  * `symmetrize!` is deprecated in favor of `Base.LinAlg.copytri!` ([#5427]).\n\n  * `myindexes` has been renamed to `localindexes` ([#5475]).\n\n  * `factorize!` is deprecated in favor of `factorize` ([#5526]).\n\n  * `nnz` counts the number of structural nonzeros in a sparse\n    matrix. Use `countnz` for the actual number of nonzeros ([#6769]).\n\n  * `setfield` is renamed `setfield!` ([#5748]).\n\n  * `put` and `take` are renamed `put!` and `take!` ([#5511]).\n\n  * `put!` now returns its first argument, the remote reference ([#5819]).\n\n  * `read` methods that modify a passed array are now called `read!` ([#5970])\n\n  * `infs` and `nans` are deprecated in favor of the more general `fill`.\n\n  * `*` and `div` are no longer supported for `Char`.\n\n  * `Range` is renamed `StepRange` and `Range1` is renamed `UnitRange`.\n    `Ranges` is renamed `Range`.\n\n  * `bitmix` is replaced by a 2-argument form of `hash`.\n\n  * `readsfrom` and `writesto` are replaced by `open` ([#6948]).\n\n  * `insert!` now throws a `BoundsError` if\n    `index > length(collection)+1` ([#7373]).\n\n  * No longer exported from `Base`:\n    * `start_reading`, `stop_reading`, `start_watching` ([#10885]).\n\nJulia v0.2.0 Release Notes\n==========================\n\nThe 0.2 release brings improvements to many areas of Julia. Among the\nmost visible changes are support for 64-bit Windows, keyword arguments\nto functions, immutable types, a redesigned and polished package\nmanager, a multimedia interface supporting usage of Julia in IPython,\na built-in profiler, and major improvements to Julia's linear algebra,\nI/O, and parallel capabilities. These are accompanied by many other\nchanges adding new features, enhancing the library's consistency,\nimproving performance, increasing test coverage, easing installation,\nand expanding the documentation. While not part of Julia proper, the\npackage ecosystem has also grown and matured considerably since the\n0.1 release. See below for more information about the long list of\nchanges that improve Julia's usability and performance.\n\nNew language features\n---------------------\n\n  * Keyword & optional function arguments ([#485], [#1817]).\n\n  * Immutable types ([#13]).\n\n  * Triple-quoted string literals ([#70]).\n\n  * New infix operator `in` (e.g. `x in S`), and corresponding function\n    `in(x,S)`, replacing `contains(S,x)` function ([#2703]).\n\n  * New variable bindings on each for loop and comprehension iteration ([#1571]).\n    For example, before this change:\n\n        julia> map(f->f(), { ()->i for i=1:3 })\n        3-element Any Array:\n         3\n         3\n         3\n\n    and after:\n\n        julia> map(f->f(), { ()->i for i=1:3 })\n        3-element Any Array:\n         1\n         2\n         3\n\n  * Explicit relative importing ([#2375]).\n\n  * Methods can be added to functions in other modules using dot syntax,\n    as in `Foo.bar(x) = 0`.\n\n  * `import module: name1, name2, ...` ([#5214]).\n\n  * A semicolon is now allowed after an `import` or `using` statement ([#4130]).\n\n  * In an interactive session (REPL), you can use `;cmd` to run `cmd` via an interactive\n    shell. For example:\n\n        julia> ;ls\n        CONTRIBUTING.md  Makefile           VERSION      deps/      julia@  ui/\n        DISTRIBUTING.md  NEWS.md            Windows.inc  doc/       src/    usr/\n        LICENSE.md       README.md          base/        etc/       test/\n        Make.inc         README.windows.md  contrib/     examples/  tmp/\n\nNew library functions\n---------------------\n\n  * Sampling profiler ([#2597]).\n\n  * Functions for examining stages of the compiler's output:\n    `code_lowered`, `code_typed`, `code_llvm`, and `code_native`.\n\n  * Multimedia I/O API (display, writemime, etcetera) ([#3932]).\n\n  * MPFR-based `BigFloat` ([#2814]), and many new `BigFloat` operations.\n\n  * New half-precision IEEE floating-point type, `Float16` ([#3467]).\n\n  * Support for setting floating-point rounding modes ([#3149]).\n\n  * `methodswith` shows all methods with an argument of specific type.\n\n  * `mapslices` provides a general way to perform operations on slices of arrays ([#2204]).\n\n  * `repeat` function for constructing Arrays with repeated elements ([#3605]).\n\n  * `Collections.PriorityQueue` type and `Collections.heap` functions ([#2920]).\n\n  * `quadgk` 1d-integration routine ([#3140]).\n\n  * `erfinv` and `erfcinv` functions ([#2987]).\n\n  * `varm`, `stdm` ([#2265]).\n\n  * `digamma`, `invdigamma`, `trigamma` and `polygamma` for calculating derivatives of `gamma` function ([#3233]).\n\n  * `logdet` ([#3070]).\n\n  * Names for C-compatible types: `Cchar`, `Clong`, etc. ([#2370]).\n\n  * `cglobal` to access global variables ([#1815]).\n\n  * `unsafe_pointer_to_objref` ([#2468]) and `pointer_from_objref` ([#2515]).\n\n  * `readandwrite` for external processes.\n\n  * I/O functions `readbytes` and `readbytes!` ([#3878]).\n\n  * `flush_cstdio` function ([#3949]).\n\n  * ClusterManager makes it possible to support different types of compute clusters\n    ([#3649], [#4014]).\n\n  * `rmprocs` for removing processors from a parallel computing session.\n    The system can also tolerate to some extent processors that die unexpectedly\n    ([#3050]).\n\n  * `interrupt` for interrupting worker processes ([#3819]).\n\n  * `timedwait` does a polled wait for an event till a specified timeout.\n\n  * `Condition` type with `wait` and `notify` functions for `Task` synchronization.\n\n  * `versioninfo` provides detailed version information, especially useful when\n    reporting and diagnosing bugs.\n\n  * `detach` for running child processes in a separate process group.\n\n  * `setenv` for passing environment variables to child processes.\n\n  * `ifelse` eagerly-evaluated conditional function, especially useful for\n    vectorized conditionals.\n\nLibrary improvements\n--------------------\n\n  * `isequal` now returns `false` for numbers of different types.\n    This makes it much easier to define hashing for new numeric types.\n    Uses of `Dict` with numeric keys might need to change\n    to account for this increased strictness.\n\n  * A redesigned and rewritten `Pkg` system is much more robust in case of problems.\n    The basic interface to adding and removing package requirements remains the\n    same, but great deal of additional functionality for developing packages in-place\n    was added. See the new [packages chapter] in the manual for further details.\n\n  * Sorting API updates ([#3665]) \u2013 see [sorting functions].\n\n  * The `delete!(d::Dict, key)` function has been split into separate `pop!`\n    and `delete!` functions ([#3439]).\n    `pop!(d,key)` removes `key` from `d` and returns the value that was associated with it;\n    it throws an exception if `d` does not contain `key`.\n    `delete!(d,key)` removes `key` from `d` and succeeds regardless of whether `d`\n    contained `key` or not, returning `d` itself in either case.\n\n  * Linear-algebra factorization routines (`lu`, `chol`, etc.) now return\n    `Factorization` objects (and `lud`, `chold`, etc. are deprecated; [#2212]).\n\n  * A number of improvements to sparse matrix capabilities and sparse linear algebra.\n\n  * More linear algebra fixes and eigensolver hooks\n    for `SymTridiagonal`, `Tridiagonal` and `Bidiagonal` matrix types\n    ([#2606], [#2608], [#2609], [#2611], [#2678], [#2713], [#2720], [#2725]).\n\n  * Change `integer_valued`, `real_valued`, and so on to `isinteger`, `isreal`,\n    and so on, and semantics of the later are now value-based rather than type-based,\n    unlike MATLAB/Octave ([#3071]). `isbool` and `iscomplex` are eliminated in favor\n    of a general `iseltype` function.\n\n  * Transitive comparison of floats with rationals ([#3102]).\n\n  * Fast prime generation with `primes` and fast primality testing with `isprime`.\n\n  * `sum` and `cumsum` now use [pairwise summation] for better accuracy ([#4039]).\n\n  * Dot operators (`.+`, `.*` etc.) now broadcast singleton dimensions of array arguments.\n    This behavior can be applied to any function using `broadcast(f, ...)`.\n\n  * `combinations`, `permutations`, and `partitions` now return iterators instead of a task,\n    and `integer_partitions` has been renamed to `partitions` ([#3989], [#4055]).\n\n  * `isreadable`/`iswritable` methods added for more IO types ([#3872]).\n\n  * Much faster and improved `readdlm` and `writedlm` ([#3350], [#3468], [#3483]).\n\n  * Faster `matchall` ([#3719]), and various string and regex improvements.\n\n  * Documentation of advanced linear algebra features ([#2807]).\n\n  * Support optional RTLD flags in `dlopen` ([#2380]).\n\n  * `pmap` now works with any iterable collection.\n\n  * Options in `pmap` for retrying or ignoring failed tasks.\n\n  * New `sinpi(x)` and `cospi(x)` functions to compute sine and cosine of `pi*x`\n    more accurately ([#4112]).\n\n  * New implementations of elementary complex functions\n    `sqrt`, `log`, `asin`, `acos`, `atan`, `tanh`, `asinh`, `acosh`, `atanh`\n    with correct branch cuts ([#2891]).\n\n  * Improved behavior of `SubArray` ([#4412], [#4284], [#4044], [#3697], [#3790],\n    [#3148], [#2844], [#2644] and various other fixes).\n\n  * New convenience functions in graphics API.\n\n  * Improved backtraces on Windows and OS X.\n\n  * Implementation of reduction functions (including `reduce`, `mapreduce`, `sum`, `prod`,\n    `maximum`, `minimum`, `all`, and `any`) are refactored, with improved type stability,\n    efficiency, and consistency ([#6116], [#7035], [#7061], [#7106]).\n\nDeprecated or removed\n---------------------\n\n  * Methods of `min` and `max` that do reductions were renamed to\n    `minimum` and `maximum`. `min(x)` is now `minimum(x)`, and\n    `min(x,(),dim)` is now `minimum(x,dim)` ([#4235]).\n\n  * `ComplexPair` was renamed to `Complex` and made `immutable`,\n    and `Complex128` and so on are now aliases to the new `Complex` type.\n\n  * `!` was added to the name of many mutating functions,\n    e.g., `push` was renamed `push!` ([#907]).\n\n  * `ref` renamed to `getindex`, and `assign` to `setindex!` ([#1484]).\n\n  * `writeable` renamed to `writable` ([#3874]).\n\n  * `logb` and `ilogb` renamed to `exponent` ([#2516]).\n\n  * `quote_string` became a method of `repr`.\n\n  * `safe_char`, `check_ascii`, and `check_utf8` replaced by\n    `is_valid_char`, `is_valid_ascii`, and `is_valid_utf8`, respectively.\n\n  * `each_line`, `each_match`, `begins_with`, `ends_with`, `parse_float`,\n    `parse_int`, and `seek_end` replaced by: `eachline`, `eachmatch`, and so on\n    (`_` was removed) ([#1539]).\n\n  * `parse_bin(s)` replaced by `parseint(s,2)`;\n    `parse_oct(s)` replaced by `parseint(s,8)`;\n    `parse_hex(s)` replaced by `parseint(s,16)`.\n\n  * `findn_nzs` replaced by `findnz` ([#1539]).\n\n  * `DivideByZeroError` replaced by `DivideError`.\n\n  * `addprocs_ssh`, `addprocs_ssh_tunnel`, and `addprocs_local`\n    replaced by `addprocs` (with keyword options).\n\n  * `remote_call`, `remote_call_fetch`, and `remote_call_wait`\n    replaced by `remotecall`, `remotecall_fetch`, and `remotecall_wait`.\n\n  * `has` replaced by `in` for sets and by `haskey` for dictionaries.\n\n  * `diagmm` and `diagmm!` replaced by `scale` and `scale!` ([#2916]).\n\n  * `unsafe_ref` and `unsafe_assign` replaced by `unsafe_load` and `unsafe_store!`.\n\n  * `add_each!` and `del_each!` replaced by `union!` and `setdiff!`.\n\n  * `isdenormal` renamed to `issubnormal` ([#3105]).\n\n  * `expr` replaced by direct call to `Expr` constructor.\n\n  * `|`, `&`, `$`, `-`, and `~` for sets replaced by\n    `union`, `intersect`, `symdiff`, `setdiff`, and `complement` ([#3272]).\n\n  * `square` function removed.\n\n  * `pascal` function removed.\n\n  * `add` and `add!` for `Set` replaced by `push!`.\n\n  * `ls` function deprecated in favor of `readdir` or `;ls` in the REPL.\n\n  * `start_timer` now expects arguments in units of seconds, not milliseconds.\n\n  * Shell redirection operators `|`, `>`, and `<` eliminated in favor of a new\n    operator `|>` ([#3523]).\n\n  * `amap` is deprecated in favor of new `mapslices` functionality.\n\n  * The `Reverse` iterator was removed since it did not work in many cases.\n\n  * The `gcd` function now returns a non-negative value regardless of\n    the argument signs, and various other sign problems with `invmod`,\n    `lcm`, `gcdx`, and `powermod` were fixed ([#4811]).\n\nMiscellaneous changes\n---------------------\n\n  * `julia-release-*` executables renamed to `julia-*`,\n    and `libjulia-release` renamed to `libjulia` ([#4177]).\n\n  * Packages will now be installed in `.julia/vX.Y`, where\n    X.Y is the current Julia version.\n\nBugfixes and performance updates\n--------------------------------\n\nToo numerous to mention.\n\n[packages chapter]: http://docs.julialang.org/en/release-0.5/manual/packages/\n[sorting functions]: http://docs.julialang.org/en/release-0.5/stdlib/sort/\n[pairwise summation]: https://en.wikipedia.org/wiki/Pairwise_summation\n[a448e080]: https://github.com/JuliaLang/julia/commit/a448e080dc736c7fb326426dfcb2528be36973d3\n[5e3f074b]: https://github.com/JuliaLang/julia/commit/5e3f074b9173044a0a4219f9b285879ff7cec041\n<!--- generated by NEWS-update.jl: -->\n[#13]: https://github.com/JuliaLang/julia/issues/13\n[#69]: https://github.com/JuliaLang/julia/issues/69\n[#70]: https://github.com/JuliaLang/julia/issues/70\n[#101]: https://github.com/JuliaLang/julia/issues/101\n[#485]: https://github.com/JuliaLang/julia/issues/485\n[#552]: https://github.com/JuliaLang/julia/issues/552\n[#907]: https://github.com/JuliaLang/julia/issues/907\n[#987]: https://github.com/JuliaLang/julia/issues/987\n[#1195]: https://github.com/JuliaLang/julia/issues/1195\n[#1268]: https://github.com/JuliaLang/julia/issues/1268\n[#1470]: https://github.com/JuliaLang/julia/issues/1470\n[#1484]: https://github.com/JuliaLang/julia/issues/1484\n[#1539]: https://github.com/JuliaLang/julia/issues/1539\n[#1571]: https://github.com/JuliaLang/julia/issues/1571\n[#1815]: https://github.com/JuliaLang/julia/issues/1815\n[#1817]: https://github.com/JuliaLang/julia/issues/1817\n[#2204]: https://github.com/JuliaLang/julia/issues/2204\n[#2212]: https://github.com/JuliaLang/julia/issues/2212\n[#2265]: https://github.com/JuliaLang/julia/issues/2265\n[#2333]: https://github.com/JuliaLang/julia/issues/2333\n[#2345]: https://github.com/JuliaLang/julia/issues/2345\n[#2370]: https://github.com/JuliaLang/julia/issues/2370\n[#2375]: https://github.com/JuliaLang/julia/issues/2375\n[#2380]: https://github.com/JuliaLang/julia/issues/2380\n[#2403]: https://github.com/JuliaLang/julia/issues/2403\n[#2468]: https://github.com/JuliaLang/julia/issues/2468\n[#2488]: https://github.com/JuliaLang/julia/issues/2488\n[#2515]: https://github.com/JuliaLang/julia/issues/2515\n[#2516]: https://github.com/JuliaLang/julia/issues/2516\n[#2597]: https://github.com/JuliaLang/julia/issues/2597\n[#2606]: https://github.com/JuliaLang/julia/issues/2606\n[#2608]: https://github.com/JuliaLang/julia/issues/2608\n[#2609]: https://github.com/JuliaLang/julia/issues/2609\n[#2611]: https://github.com/JuliaLang/julia/issues/2611\n[#2644]: https://github.com/JuliaLang/julia/issues/2644\n[#2678]: https://github.com/JuliaLang/julia/issues/2678\n[#2703]: https://github.com/JuliaLang/julia/issues/2703\n[#2713]: https://github.com/JuliaLang/julia/issues/2713\n[#2720]: https://github.com/JuliaLang/julia/issues/2720\n[#2725]: https://github.com/JuliaLang/julia/issues/2725\n[#2807]: https://github.com/JuliaLang/julia/issues/2807\n[#2814]: https://github.com/JuliaLang/julia/issues/2814\n[#2844]: https://github.com/JuliaLang/julia/issues/2844\n[#2891]: https://github.com/JuliaLang/julia/issues/2891\n[#2916]: https://github.com/JuliaLang/julia/issues/2916\n[#2920]: https://github.com/JuliaLang/julia/issues/2920\n[#2987]: https://github.com/JuliaLang/julia/issues/2987\n[#3050]: https://github.com/JuliaLang/julia/issues/3050\n[#3070]: https://github.com/JuliaLang/julia/issues/3070\n[#3071]: https://github.com/JuliaLang/julia/issues/3071\n[#3102]: https://github.com/JuliaLang/julia/issues/3102\n[#3105]: https://github.com/JuliaLang/julia/issues/3105\n[#3140]: https://github.com/JuliaLang/julia/issues/3140\n[#3141]: https://github.com/JuliaLang/julia/issues/3141\n[#3148]: https://github.com/JuliaLang/julia/issues/3148\n[#3149]: https://github.com/JuliaLang/julia/issues/3149\n[#3214]: https://github.com/JuliaLang/julia/issues/3214\n[#3233]: https://github.com/JuliaLang/julia/issues/3233\n[#3272]: https://github.com/JuliaLang/julia/issues/3272\n[#3344]: https://github.com/JuliaLang/julia/issues/3344\n[#3350]: https://github.com/JuliaLang/julia/issues/3350\n[#3434]: https://github.com/JuliaLang/julia/issues/3434\n[#3439]: https://github.com/JuliaLang/julia/issues/3439\n[#3467]: https://github.com/JuliaLang/julia/issues/3467\n[#3468]: https://github.com/JuliaLang/julia/issues/3468\n[#3483]: https://github.com/JuliaLang/julia/issues/3483\n[#3523]: https://github.com/JuliaLang/julia/issues/3523\n[#3605]: https://github.com/JuliaLang/julia/issues/3605\n[#3631]: https://github.com/JuliaLang/julia/issues/3631\n[#3649]: https://github.com/JuliaLang/julia/issues/3649\n[#3665]: https://github.com/JuliaLang/julia/issues/3665\n[#3688]: https://github.com/JuliaLang/julia/issues/3688\n[#3697]: https://github.com/JuliaLang/julia/issues/3697\n[#3719]: https://github.com/JuliaLang/julia/issues/3719\n[#3721]: https://github.com/JuliaLang/julia/issues/3721\n[#3737]: https://github.com/JuliaLang/julia/issues/3737\n[#3759]: https://github.com/JuliaLang/julia/issues/3759\n[#3790]: https://github.com/JuliaLang/julia/issues/3790\n[#3819]: https://github.com/JuliaLang/julia/issues/3819\n[#3872]: https://github.com/JuliaLang/julia/issues/3872\n[#3874]: https://github.com/JuliaLang/julia/issues/3874\n[#3878]: https://github.com/JuliaLang/julia/issues/3878\n[#3932]: https://github.com/JuliaLang/julia/issues/3932\n[#3949]: https://github.com/JuliaLang/julia/issues/3949\n[#3989]: https://github.com/JuliaLang/julia/issues/3989\n[#4014]: https://github.com/JuliaLang/julia/issues/4014\n[#4026]: https://github.com/JuliaLang/julia/issues/4026\n[#4039]: https://github.com/JuliaLang/julia/issues/4039\n[#4042]: https://github.com/JuliaLang/julia/issues/4042\n[#4044]: https://github.com/JuliaLang/julia/issues/4044\n[#4048]: https://github.com/JuliaLang/julia/issues/4048\n[#4055]: https://github.com/JuliaLang/julia/issues/4055\n[#4112]: https://github.com/JuliaLang/julia/issues/4112\n[#4130]: https://github.com/JuliaLang/julia/issues/4130\n[#4177]: https://github.com/JuliaLang/julia/issues/4177\n[#4235]: https://github.com/JuliaLang/julia/issues/4235\n[#4284]: https://github.com/JuliaLang/julia/issues/4284\n[#4383]: https://github.com/JuliaLang/julia/issues/4383\n[#4412]: https://github.com/JuliaLang/julia/issues/4412\n[#4670]: https://github.com/JuliaLang/julia/issues/4670\n[#4759]: https://github.com/JuliaLang/julia/issues/4759\n[#4766]: https://github.com/JuliaLang/julia/issues/4766\n[#4775]: https://github.com/JuliaLang/julia/issues/4775\n[#4782]: https://github.com/JuliaLang/julia/issues/4782\n[#4799]: https://github.com/JuliaLang/julia/issues/4799\n[#4806]: https://github.com/JuliaLang/julia/issues/4806\n[#4811]: https://github.com/JuliaLang/julia/issues/4811\n[#4819]: https://github.com/JuliaLang/julia/issues/4819\n[#4862]: https://github.com/JuliaLang/julia/issues/4862\n[#4870]: https://github.com/JuliaLang/julia/issues/4870\n[#4871]: https://github.com/JuliaLang/julia/issues/4871\n[#4874]: https://github.com/JuliaLang/julia/issues/4874\n[#4882]: https://github.com/JuliaLang/julia/issues/4882\n[#4888]: https://github.com/JuliaLang/julia/issues/4888\n[#4923]: https://github.com/JuliaLang/julia/issues/4923\n[#4930]: https://github.com/JuliaLang/julia/issues/4930\n[#4934]: https://github.com/JuliaLang/julia/issues/4934\n[#4943]: https://github.com/JuliaLang/julia/issues/4943\n[#4958]: https://github.com/JuliaLang/julia/issues/4958\n[#4967]: https://github.com/JuliaLang/julia/issues/4967\n[#4996]: https://github.com/JuliaLang/julia/issues/4996\n[#5007]: https://github.com/JuliaLang/julia/issues/5007\n[#5025]: https://github.com/JuliaLang/julia/issues/5025\n[#5059]: https://github.com/JuliaLang/julia/issues/5059\n[#5076]: https://github.com/JuliaLang/julia/issues/5076\n[#5154]: https://github.com/JuliaLang/julia/issues/5154\n[#5164]: https://github.com/JuliaLang/julia/issues/5164\n[#5196]: https://github.com/JuliaLang/julia/issues/5196\n[#5214]: https://github.com/JuliaLang/julia/issues/5214\n[#5227]: https://github.com/JuliaLang/julia/issues/5227\n[#5255]: https://github.com/JuliaLang/julia/issues/5255\n[#5263]: https://github.com/JuliaLang/julia/issues/5263\n[#5275]: https://github.com/JuliaLang/julia/issues/5275\n[#5277]: https://github.com/JuliaLang/julia/issues/5277\n[#5330]: https://github.com/JuliaLang/julia/issues/5330\n[#5349]: https://github.com/JuliaLang/julia/issues/5349\n[#5358]: https://github.com/JuliaLang/julia/issues/5358\n[#5380]: https://github.com/JuliaLang/julia/issues/5380\n[#5381]: https://github.com/JuliaLang/julia/issues/5381\n[#5387]: https://github.com/JuliaLang/julia/issues/5387\n[#5403]: https://github.com/JuliaLang/julia/issues/5403\n[#5413]: https://github.com/JuliaLang/julia/issues/5413\n[#5423]: https://github.com/JuliaLang/julia/issues/5423\n[#5427]: https://github.com/JuliaLang/julia/issues/5427\n[#5428]: https://github.com/JuliaLang/julia/issues/5428\n[#5430]: https://github.com/JuliaLang/julia/issues/5430\n[#5462]: https://github.com/JuliaLang/julia/issues/5462\n[#5464]: https://github.com/JuliaLang/julia/issues/5464\n[#5468]: https://github.com/JuliaLang/julia/issues/5468\n[#5475]: https://github.com/JuliaLang/julia/issues/5475\n[#5511]: https://github.com/JuliaLang/julia/issues/5511\n[#5526]: https://github.com/JuliaLang/julia/issues/5526\n[#5545]: https://github.com/JuliaLang/julia/issues/5545\n[#5576]: https://github.com/JuliaLang/julia/issues/5576\n[#5585]: https://github.com/JuliaLang/julia/issues/5585\n[#5636]: https://github.com/JuliaLang/julia/issues/5636\n[#5671]: https://github.com/JuliaLang/julia/issues/5671\n[#5677]: https://github.com/JuliaLang/julia/issues/5677\n[#5703]: https://github.com/JuliaLang/julia/issues/5703\n[#5704]: https://github.com/JuliaLang/julia/issues/5704\n[#5726]: https://github.com/JuliaLang/julia/issues/5726\n[#5737]: https://github.com/JuliaLang/julia/issues/5737\n[#5748]: https://github.com/JuliaLang/julia/issues/5748\n[#5776]: https://github.com/JuliaLang/julia/issues/5776\n[#5778]: https://github.com/JuliaLang/julia/issues/5778\n[#5810]: https://github.com/JuliaLang/julia/issues/5810\n[#5811]: https://github.com/JuliaLang/julia/issues/5811\n[#5819]: https://github.com/JuliaLang/julia/issues/5819\n[#5827]: https://github.com/JuliaLang/julia/issues/5827\n[#5832]: https://github.com/JuliaLang/julia/issues/5832\n[#5927]: https://github.com/JuliaLang/julia/issues/5927\n[#5936]: https://github.com/JuliaLang/julia/issues/5936\n[#5939]: https://github.com/JuliaLang/julia/issues/5939\n[#5970]: https://github.com/JuliaLang/julia/issues/5970\n[#6056]: https://github.com/JuliaLang/julia/issues/6056\n[#6057]: https://github.com/JuliaLang/julia/issues/6057\n[#6073]: https://github.com/JuliaLang/julia/issues/6073\n[#6081]: https://github.com/JuliaLang/julia/issues/6081\n[#6116]: https://github.com/JuliaLang/julia/issues/6116\n[#6128]: https://github.com/JuliaLang/julia/issues/6128\n[#6169]: https://github.com/JuliaLang/julia/issues/6169\n[#6179]: https://github.com/JuliaLang/julia/issues/6179\n[#6197]: https://github.com/JuliaLang/julia/issues/6197\n[#6211]: https://github.com/JuliaLang/julia/issues/6211\n[#6212]: https://github.com/JuliaLang/julia/issues/6212\n[#6270]: https://github.com/JuliaLang/julia/issues/6270\n[#6273]: https://github.com/JuliaLang/julia/issues/6273\n[#6582]: https://github.com/JuliaLang/julia/issues/6582\n[#6624]: https://github.com/JuliaLang/julia/issues/6624\n[#6652]: https://github.com/JuliaLang/julia/issues/6652\n[#6678]: https://github.com/JuliaLang/julia/issues/6678\n[#6716]: https://github.com/JuliaLang/julia/issues/6716\n[#6726]: https://github.com/JuliaLang/julia/issues/6726\n[#6739]: https://github.com/JuliaLang/julia/issues/6739\n[#6769]: https://github.com/JuliaLang/julia/issues/6769\n[#6773]: https://github.com/JuliaLang/julia/issues/6773\n[#6911]: https://github.com/JuliaLang/julia/issues/6911\n[#6920]: https://github.com/JuliaLang/julia/issues/6920\n[#6929]: https://github.com/JuliaLang/julia/issues/6929\n[#6948]: https://github.com/JuliaLang/julia/issues/6948\n[#7016]: https://github.com/JuliaLang/julia/issues/7016\n[#7035]: https://github.com/JuliaLang/julia/issues/7035\n[#7047]: https://github.com/JuliaLang/julia/issues/7047\n[#7061]: https://github.com/JuliaLang/julia/issues/7061\n[#7064]: https://github.com/JuliaLang/julia/issues/7064\n[#7071]: https://github.com/JuliaLang/julia/issues/7071\n[#7094]: https://github.com/JuliaLang/julia/issues/7094\n[#7106]: https://github.com/JuliaLang/julia/issues/7106\n[#7125]: https://github.com/JuliaLang/julia/issues/7125\n[#7131]: https://github.com/JuliaLang/julia/issues/7131\n[#7146]: https://github.com/JuliaLang/julia/issues/7146\n[#7234]: https://github.com/JuliaLang/julia/issues/7234\n[#7236]: https://github.com/JuliaLang/julia/issues/7236\n[#7242]: https://github.com/JuliaLang/julia/issues/7242\n[#7264]: https://github.com/JuliaLang/julia/issues/7264\n[#7311]: https://github.com/JuliaLang/julia/issues/7311\n[#7359]: https://github.com/JuliaLang/julia/issues/7359\n[#7365]: https://github.com/JuliaLang/julia/issues/7365\n[#7373]: https://github.com/JuliaLang/julia/issues/7373\n[#7390]: https://github.com/JuliaLang/julia/issues/7390\n[#7435]: https://github.com/JuliaLang/julia/issues/7435\n[#7464]: https://github.com/JuliaLang/julia/issues/7464\n[#7513]: https://github.com/JuliaLang/julia/issues/7513\n[#7616]: https://github.com/JuliaLang/julia/issues/7616\n[#7647]: https://github.com/JuliaLang/julia/issues/7647\n[#7654]: https://github.com/JuliaLang/julia/issues/7654\n[#7704]: https://github.com/JuliaLang/julia/issues/7704\n[#7917]: https://github.com/JuliaLang/julia/issues/7917\n[#7992]: https://github.com/JuliaLang/julia/issues/7992\n[#8011]: https://github.com/JuliaLang/julia/issues/8011\n[#8089]: https://github.com/JuliaLang/julia/issues/8089\n[#8113]: https://github.com/JuliaLang/julia/issues/8113\n[#8135]: https://github.com/JuliaLang/julia/issues/8135\n[#8152]: https://github.com/JuliaLang/julia/issues/8152\n[#8246]: https://github.com/JuliaLang/julia/issues/8246\n[#8283]: https://github.com/JuliaLang/julia/issues/8283\n[#8297]: https://github.com/JuliaLang/julia/issues/8297\n[#8320]: https://github.com/JuliaLang/julia/issues/8320\n[#8399]: https://github.com/JuliaLang/julia/issues/8399\n[#8423]: https://github.com/JuliaLang/julia/issues/8423\n[#8432]: https://github.com/JuliaLang/julia/issues/8432\n[#8467]: https://github.com/JuliaLang/julia/issues/8467\n[#8501]: https://github.com/JuliaLang/julia/issues/8501\n[#8560]: https://github.com/JuliaLang/julia/issues/8560\n[#8578]: https://github.com/JuliaLang/julia/issues/8578\n[#8599]: https://github.com/JuliaLang/julia/issues/8599\n[#8605]: https://github.com/JuliaLang/julia/issues/8605\n[#8624]: https://github.com/JuliaLang/julia/issues/8624\n[#8660]: https://github.com/JuliaLang/julia/issues/8660\n[#8672]: https://github.com/JuliaLang/julia/issues/8672\n[#8712]: https://github.com/JuliaLang/julia/issues/8712\n[#8734]: https://github.com/JuliaLang/julia/issues/8734\n[#8745]: https://github.com/JuliaLang/julia/issues/8745\n[#8750]: https://github.com/JuliaLang/julia/issues/8750\n[#8776]: https://github.com/JuliaLang/julia/issues/8776\n[#8791]: https://github.com/JuliaLang/julia/issues/8791\n[#8792]: https://github.com/JuliaLang/julia/issues/8792\n[#8808]: https://github.com/JuliaLang/julia/issues/8808\n[#8816]: https://github.com/JuliaLang/julia/issues/8816\n[#8827]: https://github.com/JuliaLang/julia/issues/8827\n[#8832]: https://github.com/JuliaLang/julia/issues/8832\n[#8845]: https://github.com/JuliaLang/julia/issues/8845\n[#8854]: https://github.com/JuliaLang/julia/issues/8854\n[#8867]: https://github.com/JuliaLang/julia/issues/8867\n[#8872]: https://github.com/JuliaLang/julia/issues/8872\n[#8897]: https://github.com/JuliaLang/julia/issues/8897\n[#8905]: https://github.com/JuliaLang/julia/issues/8905\n[#8941]: https://github.com/JuliaLang/julia/issues/8941\n[#8958]: https://github.com/JuliaLang/julia/issues/8958\n[#9017]: https://github.com/JuliaLang/julia/issues/9017\n[#9049]: https://github.com/JuliaLang/julia/issues/9049\n[#9065]: https://github.com/JuliaLang/julia/issues/9065\n[#9083]: https://github.com/JuliaLang/julia/issues/9083\n[#9105]: https://github.com/JuliaLang/julia/issues/9105\n[#9122]: https://github.com/JuliaLang/julia/issues/9122\n[#9126]: https://github.com/JuliaLang/julia/issues/9126\n[#9132]: https://github.com/JuliaLang/julia/issues/9132\n[#9133]: https://github.com/JuliaLang/julia/issues/9133\n[#9144]: https://github.com/JuliaLang/julia/issues/9144\n[#9198]: https://github.com/JuliaLang/julia/issues/9198\n[#9249]: https://github.com/JuliaLang/julia/issues/9249\n[#9261]: https://github.com/JuliaLang/julia/issues/9261\n[#9271]: https://github.com/JuliaLang/julia/issues/9271\n[#9294]: https://github.com/JuliaLang/julia/issues/9294\n[#9309]: https://github.com/JuliaLang/julia/issues/9309\n[#9418]: https://github.com/JuliaLang/julia/issues/9418\n[#9425]: https://github.com/JuliaLang/julia/issues/9425\n[#9434]: https://github.com/JuliaLang/julia/issues/9434\n[#9452]: https://github.com/JuliaLang/julia/issues/9452\n[#9487]: https://github.com/JuliaLang/julia/issues/9487\n[#9569]: https://github.com/JuliaLang/julia/issues/9569\n[#9575]: https://github.com/JuliaLang/julia/issues/9575\n[#9578]: https://github.com/JuliaLang/julia/issues/9578\n[#9597]: https://github.com/JuliaLang/julia/issues/9597\n[#9666]: https://github.com/JuliaLang/julia/issues/9666\n[#9690]: https://github.com/JuliaLang/julia/issues/9690\n[#9701]: https://github.com/JuliaLang/julia/issues/9701\n[#9714]: https://github.com/JuliaLang/julia/issues/9714\n[#9734]: https://github.com/JuliaLang/julia/issues/9734\n[#9745]: https://github.com/JuliaLang/julia/issues/9745\n[#9779]: https://github.com/JuliaLang/julia/issues/9779\n[#9862]: https://github.com/JuliaLang/julia/issues/9862\n[#9957]: https://github.com/JuliaLang/julia/issues/9957\n[#10008]: https://github.com/JuliaLang/julia/issues/10008\n[#10024]: https://github.com/JuliaLang/julia/issues/10024\n[#10031]: https://github.com/JuliaLang/julia/issues/10031\n[#10075]: https://github.com/JuliaLang/julia/issues/10075\n[#10117]: https://github.com/JuliaLang/julia/issues/10117\n[#10150]: https://github.com/JuliaLang/julia/issues/10150\n[#10168]: https://github.com/JuliaLang/julia/issues/10168\n[#10180]: https://github.com/JuliaLang/julia/issues/10180\n[#10228]: https://github.com/JuliaLang/julia/issues/10228\n[#10328]: https://github.com/JuliaLang/julia/issues/10328\n[#10331]: https://github.com/JuliaLang/julia/issues/10331\n[#10332]: https://github.com/JuliaLang/julia/issues/10332\n[#10333]: https://github.com/JuliaLang/julia/issues/10333\n[#10380]: https://github.com/JuliaLang/julia/issues/10380\n[#10400]: https://github.com/JuliaLang/julia/issues/10400\n[#10446]: https://github.com/JuliaLang/julia/issues/10446\n[#10458]: https://github.com/JuliaLang/julia/issues/10458\n[#10472]: https://github.com/JuliaLang/julia/issues/10472\n[#10525]: https://github.com/JuliaLang/julia/issues/10525\n[#10543]: https://github.com/JuliaLang/julia/issues/10543\n[#10659]: https://github.com/JuliaLang/julia/issues/10659\n[#10679]: https://github.com/JuliaLang/julia/issues/10679\n[#10709]: https://github.com/JuliaLang/julia/issues/10709\n[#10714]: https://github.com/JuliaLang/julia/issues/10714\n[#10747]: https://github.com/JuliaLang/julia/issues/10747\n[#10844]: https://github.com/JuliaLang/julia/issues/10844\n[#10870]: https://github.com/JuliaLang/julia/issues/10870\n[#10885]: https://github.com/JuliaLang/julia/issues/10885\n[#10888]: https://github.com/JuliaLang/julia/issues/10888\n[#10893]: https://github.com/JuliaLang/julia/issues/10893\n[#10914]: https://github.com/JuliaLang/julia/issues/10914\n[#10955]: https://github.com/JuliaLang/julia/issues/10955\n[#10994]: https://github.com/JuliaLang/julia/issues/10994\n[#11030]: https://github.com/JuliaLang/julia/issues/11030\n[#11067]: https://github.com/JuliaLang/julia/issues/11067\n[#11105]: https://github.com/JuliaLang/julia/issues/11105\n[#11145]: https://github.com/JuliaLang/julia/issues/11145\n[#11171]: https://github.com/JuliaLang/julia/issues/11171\n[#11241]: https://github.com/JuliaLang/julia/issues/11241\n[#11279]: https://github.com/JuliaLang/julia/issues/11279\n[#11347]: https://github.com/JuliaLang/julia/issues/11347\n[#11379]: https://github.com/JuliaLang/julia/issues/11379\n[#11432]: https://github.com/JuliaLang/julia/issues/11432\n[#11566]: https://github.com/JuliaLang/julia/issues/11566\n[#11686]: https://github.com/JuliaLang/julia/issues/11686\n[#11741]: https://github.com/JuliaLang/julia/issues/11741\n[#11849]: https://github.com/JuliaLang/julia/issues/11849\n[#11891]: https://github.com/JuliaLang/julia/issues/11891\n[#11922]: https://github.com/JuliaLang/julia/issues/11922\n[#11947]: https://github.com/JuliaLang/julia/issues/11947\n[#11985]: https://github.com/JuliaLang/julia/issues/11985\n[#12025]: https://github.com/JuliaLang/julia/issues/12025\n[#12031]: https://github.com/JuliaLang/julia/issues/12031\n[#12034]: https://github.com/JuliaLang/julia/issues/12034\n[#12087]: https://github.com/JuliaLang/julia/issues/12087\n[#12137]: https://github.com/JuliaLang/julia/issues/12137\n[#12162]: https://github.com/JuliaLang/julia/issues/12162\n[#12264]: https://github.com/JuliaLang/julia/issues/12264\n[#12385]: https://github.com/JuliaLang/julia/issues/12385\n[#12393]: https://github.com/JuliaLang/julia/issues/12393\n[#12458]: https://github.com/JuliaLang/julia/issues/12458\n[#12472]: https://github.com/JuliaLang/julia/issues/12472\n[#12491]: https://github.com/JuliaLang/julia/issues/12491\n[#12576]: https://github.com/JuliaLang/julia/issues/12576\n[#12727]: https://github.com/JuliaLang/julia/issues/12727\n[#12739]: https://github.com/JuliaLang/julia/issues/12739\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/test/libdl.jl": "# This file is a part of Julia. License is MIT: http://julialang.org/license\n\n# these could fail on an embedded installation\n# but for now, we don't handle that case\ndlls = Libdl.dllist()\n@test !isempty(dlls)\n@test length(dlls) > 3 # at a bare minimum, probably have some version of libstdc, libgcc, libjulia, ...\nif !is_windows() || Sys.windows_version() >= Sys.WINDOWS_VISTA_VER\n    for dl in dlls\n        if isfile(dl) && (Libdl.dlopen_e(dl) != C_NULL)\n            @test Base.samefile(Libdl.dlpath(dl), dl)\n        end\n    end\nend\n@test length(filter(dlls) do dl\n        return ismatch(Regex(\"^libjulia(?:.*)\\.$(Libdl.dlext)(?:\\..+)?\\$\"), basename(dl))\n    end) == 1 # look for something libjulia-like (but only one)\n\n# library handle pointer must not be NULL\n@test_throws ArgumentError Libdl.dlsym(C_NULL, :foo)\n@test_throws ArgumentError Libdl.dlsym_e(C_NULL, :foo)\n\ncd(dirname(@__FILE__)) do\n\n# Find the library directory by finding the path of libjulia (or libjulia-debug, as the case may be)\n# and then adding on /julia to that directory path to get the private library directory, if we need\n# to (where \"need to\" is defined as private_libdir/julia/libccalltest.dlext exists\nprivate_libdir = if ccall(:jl_is_debugbuild, Cint, ()) != 0\n    dirname(abspath(Libdl.dlpath(\"libjulia-debug\")))\nelse\n    dirname(abspath(Libdl.dlpath(\"libjulia\")))\nend\n\nif isfile(joinpath(private_libdir,\"julia\",\"libccalltest.\"*Libdl.dlext))\n    private_libdir = joinpath(private_libdir, \"julia\")\nend\n\n@test !isempty(Libdl.find_library([\"libccalltest\"], [private_libdir]))\n@test !isempty(Libdl.find_library(\"libccalltest\", [private_libdir]))\n@test !isempty(Libdl.find_library(:libccalltest, [private_libdir]))\n\n# dlopen should be able to handle absolute and relative paths, with and without dlext\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(abspath(joinpath(private_libdir, \"libccalltest\")))\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(abspath(joinpath(private_libdir, \"libccalltest.$(Libdl.dlext)\")))\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(relpath(joinpath(private_libdir, \"libccalltest\")))\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(relpath(joinpath(private_libdir, \"libccalltest.$(Libdl.dlext)\")))\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(\"./foo\")\n        @test dl == C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# unqualified names present in DL_LOAD_PATH\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(\"libccalltest\")\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(string(\"libccalltest\",\".\",Libdl.dlext))\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# path with dlopen-able file first in load path\n#=\nlet dl = C_NULL,\n    tmpdir = mktempdir(),\n    fpath = joinpath(tmpdir,\"libccalltest\")\n    try\n        write(open(fpath,\"w\"))\n        push!(Libdl.DL_LOAD_PATH, dirname(@__FILE__))\n        push!(Libdl.DL_LOAD_PATH, dirname(fpath))\n        dl = Libdl.dlopen_e(\"libccalltest\")\n        @test dl != C_NULL\n    finally\n        pop!(Libdl.DL_LOAD_PATH)\n        pop!(Libdl.DL_LOAD_PATH)\n        rm(tmpdir, recursive=true)\n    end\nend\n=#\n\n# path with dlopen-able file second in load path\n#=\nlet dl = C_NULL,\n    tmpdir = mktempdir(),\n    fpath = joinpath(tmpdir,\"libccalltest\")\n    try\n        write(open(fpath,\"w\"))\n        push!(Libdl.DL_LOAD_PATH, dirname(fpath))\n        push!(Libdl.DL_LOAD_PATH, dirname(@__FILE__))\n        dl = Libdl.dlopen_e(\"libccalltest\")\n        @test dl != C_NULL\n    finally\n        pop!(Libdl.DL_LOAD_PATH)\n        pop!(Libdl.DL_LOAD_PATH)\n        rm(tmpdir, recursive=true)\n    end\nend\n=#\n\n# test dlpath\nlet dl = C_NULL\n    try\n        path = abspath(joinpath(private_libdir, \"libccalltest\"))\n        dl = Libdl.dlopen(path)\n        @test dl != C_NULL\n        @test Base.samefile(abspath(Libdl.dlpath(dl)),\n                            abspath(Libdl.dlpath(path)))\n        @test Base.samefile(abspath(Libdl.dlpath(dl)),\n                            string(path,\".\",Libdl.dlext))\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# opening a library that does not exist throws an ErrorException\n@test_throws ErrorException Libdl.dlopen(\"./foo\")\n\n# test dlsym\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen(abspath(joinpath(private_libdir, \"libccalltest\")))\n        fptr = Libdl.dlsym(dl, :set_verbose)\n        @test fptr != C_NULL\n        @test_throws ErrorException Libdl.dlsym(dl, :foo)\n\n        fptr = Libdl.dlsym_e(dl, :set_verbose)\n        @test fptr != C_NULL\n        fptr = Libdl.dlsym_e(dl, :foo)\n        @test fptr == C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nif Sys.KERNEL in (:Linux, :FreeBSD)\n    ccall(:jl_read_sonames, Void, ())\nend\n\nend\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/test/cmdlineargs.jl": "# This file is a part of Julia. License is MIT: http://julialang.org/license\n\ncatcmd = `cat`\nif is_windows()\n    try # use busybox-w32 on windows\n        success(`busybox`)\n        catcmd = `busybox cat`\n    end\nend\n\nlet exename = `$(Base.julia_cmd()) --precompiled=yes --startup-file=no`\n    # --version\n    let v = split(readstring(`$exename -v`), \"julia version \")[end]\n        @test Base.VERSION_STRING == chomp(v)\n    end\n    @test readstring(`$exename -v`) == readstring(`$exename --version`)\n\n    # --help\n    let header = \"julia [switches] -- [programfile] [args...]\"\n        @test startswith(readstring(`$exename -h`), header)\n        @test startswith(readstring(`$exename --help`), header)\n    end\n\n    # --quiet\n    # This flag is indirectly tested in test/repl.jl\n\n    # --home\n    @test success(`$exename -H $JULIA_HOME`)\n    @test success(`$exename --home=$JULIA_HOME`)\n\n    # --eval\n    @test  success(`$exename -e \"exit(0)\"`)\n    @test !success(`$exename -e \"exit(1)\"`)\n    @test  success(`$exename --eval=\"exit(0)\"`)\n    @test !success(`$exename --eval=\"exit(1)\"`)\n    @test !success(`$exename -e`)\n    @test !success(`$exename --eval`)\n    # --eval --interactive (replaced --post-boot)\n    @test  success(`$exename -i -e \"exit(0)\"`)\n    @test !success(`$exename -i -e \"exit(1)\"`)\n\n    # --print\n    @test readstring(`$exename -E \"1+1\"`) == \"2\\n\"\n    @test readstring(`$exename --print=\"1+1\"`) == \"2\\n\"\n    @test !success(`$exename -E`)\n    @test !success(`$exename --print`)\n\n    # --load\n    let testfile = tempname()\n        try\n            write(testfile, \"testvar = :test\\n\")\n            @test split(readchomp(`$exename -i --load=$testfile -e \"println(testvar)\"`), '\\n')[end] == \"test\"\n            @test split(readchomp(`$exename -i -e \"println(testvar)\" -L $testfile`), '\\n')[end] == \"test\"\n        finally\n            rm(testfile)\n        end\n    end\n    # -L, --load requires an argument\n    @test !success(`$exename -L`)\n    @test !success(`$exename --load`)\n\n    # --cpu-target\n    # NOTE: this test only holds true when there is a sys.{dll,dylib,so} shared library present.\n    if Libdl.dlopen_e(splitext(unsafe_string(Base.JLOptions().image_file))[1]) != C_NULL\n        @test !success(`$exename -C invalidtarget --precompiled=yes`)\n        @test !success(`$exename --cpu-target=invalidtarget --precompiled=yes`)\n    else\n        warn(\"--cpu-target test not runnable\")\n    end\n\n    # --procs\n    @test readchomp(`$exename -q -p 2 -e \"println(nworkers())\"`) == \"2\"\n    @test !success(`$exename -p 0`)\n    @test !success(`$exename --procs=1.0`)\n\n    # --machinefile\n    # this does not check that machinefile works,\n    # only that the filename gets correctly passed to the option struct\n    let fname = tempname()\n        touch(fname)\n        fname = realpath(fname)\n        try\n            @test readchomp(`$exename --machinefile $fname -e \"println(unsafe_string(Base.JLOptions().machinefile))\"`) == fname\n        finally\n            rm(fname)\n        end\n    end\n\n    # -i, isinteractive\n    @test readchomp(`$exename -E \"isinteractive()\"`) == \"false\"\n    @test readchomp(`$exename -E \"isinteractive()\" -i`) == \"true\"\n\n    # --color\n    @test readchomp(`$exename --color=yes -E \"Base.have_color\"`) == \"true\"\n    @test readchomp(`$exename --color=no -E \"Base.have_color\"`) == \"false\"\n    @test !success(`$exename --color=false`)\n\n    # --history-file\n    @test readchomp(`$exename -E \"Bool(Base.JLOptions().historyfile)\" --history-file=yes`) == \"true\"\n    @test readchomp(`$exename -E \"Bool(Base.JLOptions().historyfile)\" --history-file=no`) == \"false\"\n    @test !success(`$exename --history-file=false`)\n\n    # --code-coverage\n    @test readchomp(`$exename -E \"Bool(Base.JLOptions().code_coverage)\"`) == \"false\"\n    @test readchomp(`$exename -E \"Bool(Base.JLOptions().code_coverage)\" --code-coverage=none`) == \"false\"\n\n    @test readchomp(`$exename -E \"Bool(Base.JLOptions().code_coverage)\" --code-coverage`) == \"true\"\n    @test readchomp(`$exename -E \"Bool(Base.JLOptions().code_coverage)\" --code-coverage=user`) == \"true\"\n\n    # --track-allocation\n    @test readchomp(`$exename -E \"Bool(Base.JLOptions().malloc_log)\"`) == \"false\"\n    @test readchomp(`$exename -E \"Bool(Base.JLOptions().malloc_log)\" --track-allocation=none`) == \"false\"\n\n    @test readchomp(`$exename -E \"Bool(Base.JLOptions().malloc_log)\" --track-allocation`) == \"true\"\n    @test readchomp(`$exename -E \"Bool(Base.JLOptions().malloc_log)\" --track-allocation=user`) == \"true\"\n\n    # --optimize\n    @test readchomp(`$exename -E \"Base.JLOptions().opt_level\"`) == \"2\"\n    @test readchomp(`$exename -E \"Base.JLOptions().opt_level\" -O`) == \"3\"\n    @test readchomp(`$exename -E \"Base.JLOptions().opt_level\" --optimize`) == \"3\"\n    @test readchomp(`$exename -E \"Base.JLOptions().opt_level\" -O0`) == \"0\"\n\n    # --check-bounds\n    let JL_OPTIONS_CHECK_BOUNDS_DEFAULT = 0,\n        JL_OPTIONS_CHECK_BOUNDS_ON = 1,\n        JL_OPTIONS_CHECK_BOUNDS_OFF = 2\n        @test parse(Int,readchomp(`$exename -E \"Int(Base.JLOptions().check_bounds)\"`)) == JL_OPTIONS_CHECK_BOUNDS_DEFAULT\n        @test parse(Int,readchomp(`$exename -E \"Int(Base.JLOptions().check_bounds)\" --check-bounds=yes`)) == JL_OPTIONS_CHECK_BOUNDS_ON\n        @test parse(Int,readchomp(`$exename -E \"Int(Base.JLOptions().check_bounds)\" --check-bounds=no`)) == JL_OPTIONS_CHECK_BOUNDS_OFF\n    end\n    # check-bounds takes yes/no as argument\n    @test !success(`$exename -E \"exit(0)\" --check-bounds=false`)\n\n    # --depwarn\n    @test readchomp(`$exename --depwarn=no -E \"Base.syntax_deprecation_warnings(true)\"`) == \"false\"\n    @test readchomp(`$exename --depwarn=yes -E \"Base.syntax_deprecation_warnings(false)\"`) == \"true\"\n    @test !success(`$exename --depwarn=false`)\n    # test deprecated syntax\n    @test !success(`$exename -e \"foo (x::Int) = x * x\" --depwarn=error`)\n    # test deprecated method\n    @test !success(`$exename -e \"\n        foo() = :foo; bar() = :bar\n        @deprecate foo() bar()\n        foo()\n    \" --depwarn=error`)\n\n    # test deprecated bindings, #13269\n    let code = \"\"\"\n        module Foo\n            import Base: @deprecate_binding\n\n            const NotDeprecated = true\n            @deprecate_binding Deprecated NotDeprecated\n        end\n\n        Foo.Deprecated\n        \"\"\"\n\n        @test !success(`$exename -E \"$code\" --depwarn=error`)\n\n        let out  = Pipe(),\n            proc = spawn(pipeline(`$exename -E \"$code\" --depwarn=yes`, stderr=out)),\n            output = @async readchomp(out)\n\n            close(out.in)\n            wait(proc)\n            @test success(proc)\n            @test wait(output) == \"WARNING: Foo.Deprecated is deprecated.\\n  likely near no file:5\"\n        end\n\n        let out  = Pipe(),\n            proc = spawn(pipeline(`$exename -E \"$code\" --depwarn=no`, stderr=out))\n            output = @async readstring(out)\n\n            wait(proc)\n            close(out.in)\n            @test success(proc)\n            @test wait(output) == \"\"\n        end\n    end\n\n    # --inline\n    @test readchomp(`$exename -E \"Bool(Base.JLOptions().can_inline)\"`) == \"true\"\n    @test readchomp(`$exename --inline=yes -E \"Bool(Base.JLOptions().can_inline)\"`) == \"true\"\n    @test readchomp(`$exename --inline=no -E \"Bool(Base.JLOptions().can_inline)\"`) == \"false\"\n    # --inline takes yes/no as argument\n    @test !success(`$exename --inline=false`)\n\n    # --fast-math\n    let JL_OPTIONS_FAST_MATH_DEFAULT = 0,\n        JL_OPTIONS_FAST_MATH_ON = 1,\n        JL_OPTIONS_FAST_MATH_OFF = 2\n        @test parse(Int,readchomp(`$exename -E \"Int(Base.JLOptions().fast_math)\"`)) == JL_OPTIONS_FAST_MATH_DEFAULT\n        @test parse(Int,readchomp(`$exename --math-mode=user -E \"Int(Base.JLOptions().fast_math)\"`)) == JL_OPTIONS_FAST_MATH_DEFAULT\n        @test parse(Int,readchomp(`$exename --math-mode=ieee -E \"Int(Base.JLOptions().fast_math)\"`)) == JL_OPTIONS_FAST_MATH_OFF\n        @test parse(Int,readchomp(`$exename --math-mode=fast -E \"Int(Base.JLOptions().fast_math)\"`)) == JL_OPTIONS_FAST_MATH_ON\n    end\n\n    # --worker takes default / custom as argument (default/custom arguments tested in test/parallel.jl, test/examples.jl)\n    @test !success(`$exename --worker=true`)\n\n    escape(str) = replace(str, \"\\\\\", \"\\\\\\\\\")\n\n    # test passing arguments\n    let testfile = tempname()\n        try\n            # write a julia source file that just prints ARGS to STDOUT\n            write(testfile, \"\"\"\n                println(ARGS)\n            \"\"\")\n            @test readchomp(`$exename $testfile foo -bar --baz`) == \"String[\\\"foo\\\",\\\"-bar\\\",\\\"--baz\\\"]\"\n            @test readchomp(`$exename $testfile -- foo -bar --baz`) == \"String[\\\"foo\\\",\\\"-bar\\\",\\\"--baz\\\"]\"\n            @test readchomp(`$exename -L $testfile -e 'exit(0)' -- foo -bar --baz`) == \"String[\\\"foo\\\",\\\"-bar\\\",\\\"--baz\\\"]\"\n            @test split(readchomp(`$exename -L $testfile $testfile`), '\\n') == [\"String[\\\"$(escape(testfile))\\\"]\", \"String[]\"]\n            @test !success(`$exename --foo $testfile`)\n            @test readchomp(`$exename -L $testfile -e 'exit(0)' -- foo -bar -- baz`) == \"String[\\\"foo\\\",\\\"-bar\\\",\\\"--\\\",\\\"baz\\\"]\"\n        finally\n            rm(testfile)\n        end\n    end\n\n    # test the script name\n    let a = tempname(), b = tempname()\n        try\n            write(a, \"\"\"\n                println(@__FILE__)\n                println(PROGRAM_FILE)\n                println(length(ARGS))\n                include(\\\"$(escape(b))\\\")\n            \"\"\")\n            write(b, \"\"\"\n                println(@__FILE__)\n                println(PROGRAM_FILE)\n                println(length(ARGS))\n            \"\"\")\n            @test split(readchomp(`$exename $a`), '\\n') == [\"$a\", \"$a\", \"0\", \"$b\", \"$a\", \"0\"]\n            @test split(readchomp(`$exename -L $b -e 'exit(0)'`), '\\n') == [\"$(realpath(b))\", \"\", \"0\"]\n            @test split(readchomp(`$exename -L $b $a`), '\\n') == [\"$(realpath(b))\", \"\", \"1\", \"$a\", \"$a\", \"0\", \"$b\", \"$a\", \"0\"]\n        finally\n            rm(a)\n            rm(b)\n        end\n    end\n\n    # issue #10562\n    @test readchomp(`$exename -e 'println(ARGS);' ''`) == \"String[\\\"\\\"]\"\n\n    # issue #12679\n    @test readchomp(pipeline(ignorestatus(`$exename --startup-file=no --compile=yes -ioo`),stderr=catcmd)) == \"ERROR: unknown option `-o`\"\n    @test readchomp(pipeline(ignorestatus(`$exename --startup-file=no -p`),stderr=catcmd)) == \"ERROR: option `-p/--procs` is missing an argument\"\n    @test readchomp(pipeline(ignorestatus(`$exename --startup-file=no --inline`),stderr=catcmd)) == \"ERROR: option `--inline` is missing an argument\"\n    @test readchomp(pipeline(ignorestatus(`$exename --startup-file=no -e \"@show ARGS\" -now -- julia RUN.jl`),stderr=catcmd)) == \"ERROR: unknown option `-n`\"\n\n    # --compilecache={yes|no}\n    @test readchomp(`$exename -E \"Bool(Base.JLOptions().use_compilecache)\"`) == \"true\"\n    @test readchomp(`$exename --compilecache=yes -E \"Bool(Base.JLOptions().use_compilecache)\"`) == \"true\"\n    @test readchomp(`$exename --compilecache=no -E \"Bool(Base.JLOptions().use_compilecache)\"`) == \"false\"\n    @test !success(`$exename --compilecache=foo -e \"exit(0)\"`)\n\n    # issue #12671, starting from a non-directory\n    # rm(dir) fails on windows with Permission denied\n    # and was an upstream bug in llvm <= v3.3\n    if !is_windows() && VersionNumber(Base.libllvm_version) > v\"3.3\"\n        testdir = mktempdir()\n        cd(testdir) do\n            rm(testdir)\n            @test success(`$exename -e \"exit(0)\"`)\n        end\n    end\nend\n\nlet exename = `$(Base.julia_cmd()) --precompiled=yes`\n    # --startup-file\n    let JL_OPTIONS_STARTUPFILE_ON = 1,\n        JL_OPTIONS_STARTUPFILE_OFF = 2\n        # `HOME=$tmpdir` to avoid errors in the user .juliarc.jl, which hangs the tests.  Issue #17642\n        mktempdir() do tmpdir\n            withenv(\"HOME\"=>tmpdir) do\n                @test parse(Int,readchomp(`$exename -E \"Base.JLOptions().startupfile\" --startup-file=yes`)) == JL_OPTIONS_STARTUPFILE_ON\n            end\n        end\n        @test parse(Int,readchomp(`$exename -E \"Base.JLOptions().startupfile\" --startup-file=no`)) == JL_OPTIONS_STARTUPFILE_OFF\n    end\n    @test !success(`$exename --startup-file=false`)\nend\n\n# Make sure `julia --lisp` doesn't break\nrun(pipeline(DevNull, `$(joinpath(JULIA_HOME, Base.julia_exename())) --lisp`, DevNull))\n\n# Test that `julia [some other option] --lisp` is disallowed\n@test_throws ErrorException run(pipeline(DevNull, pipeline(`$(joinpath(JULIA_HOME, Base.julia_exename())) -Cnative --lisp`, stderr=DevNull), DevNull))\n\n# --precompiled={yes|no}\nlet exename = `$(Base.julia_cmd()) --startup-file=no`\n    @test readchomp(`$exename --precompiled=yes -E \"Bool(Base.JLOptions().use_precompiled)\"`) == \"true\"\n    @test readchomp(`$exename --precompiled=no -E \"Bool(Base.JLOptions().use_precompiled)\"`) == \"false\"\nend\n\n# backtrace contains type and line number info (esp. on windows #17179)\nfor precomp in (\"yes\", \"no\")\n    bt = readstring(pipeline(ignorestatus(`$(Base.julia_cmd()) --startup-file=no --precompiled=$precomp\n        -E 'include(\"____nonexistent_file\")'`), stderr=catcmd))\n    @test contains(bt, \"in include_from_node1\")\n    if is_windows() && Sys.WORD_SIZE == 32 && precomp == \"yes\"\n        # fixme, issue #17251\n        @test_broken contains(bt, \"in include_from_node1(::String) at $(joinpath(\".\",\"loading.jl\"))\")\n    else\n        @test contains(bt, \"in include_from_node1(::String) at $(joinpath(\".\",\"loading.jl\"))\")\n    end\n    lno = match(r\"at \\.[\\/\\\\]loading\\.jl:(\\d+)\", bt)\n    @test length(lno.captures) == 1\n    @test parse(Int, lno.captures[1]) > 0\nend\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/test/ccall.jl": "# This file is a part of Julia. License is MIT: http://julialang.org/license\n\nimport Base.copy, Base.==\n\nconst libccalltest = \"libccalltest\"\n\nconst verbose = false\nccall((:set_verbose, libccalltest), Void, (Int32,), verbose)\n\n\n# Test for proper argument register truncation\nccall_test_func(x) = ccall((:testUcharX, libccalltest), Int32, (UInt8,), x % UInt8)\n@test ccall_test_func(3) == 1\n@test ccall_test_func(259) == 1\n\n\n# Test for proper round-trip of Ref{T} type\nccall_echo_func{T,U}(x, ::Type{T}, ::Type{U}) = ccall((:test_echo_p, libccalltest), T, (U,), x)\n# Make sure object x is still valid (rooted as argument)\n# when loading the pointer. This works as long as we still keep the argument\n# rooted but might fail if we are smarter about eliminating dead root.\n@noinline ccall_echo_load{T,U}(x, ::Type{T}, ::Type{U}) =\n    unsafe_load(ccall_echo_func(x, T, U))\n@noinline ccall_echo_objref{T,U}(x, ::Type{T}, ::Type{U}) =\n    unsafe_pointer_to_objref(ccall_echo_func(x, Ptr{T}, U))\ntype IntLike\n    x::Int\nend\n@test ccall_echo_load(132, Ptr{Int}, Ref{Int}) === 132\n@test ccall_echo_load(Ref(921), Ptr{Int}, Ref{Int}) === 921\n@test ccall_echo_load(IntLike(993), Ptr{Int}, Ref{IntLike}) === 993\n@test ccall_echo_load(IntLike(881), Ptr{IntLike}, Ref{IntLike}).x === 881\n@test ccall_echo_func(532, Int, Int) === 532\nif Sys.WORD_SIZE == 64\n    # this test is valid only for x86_64 and win64\n    @test ccall_echo_func(164, IntLike, Int).x === 164\nend\n@test ccall_echo_func(IntLike(828), Int, IntLike) === 828\n@test ccall_echo_func(913, Any, Any) === 913\n@test ccall_echo_objref(553, Ptr{Any}, Any) === 553\n@test ccall_echo_func(124, Ref{Int}, Any) === 124\n@test ccall_echo_load(422, Ptr{Any}, Ref{Any}) === 422\n@test ccall_echo_load([383], Ptr{Int}, Ref{Int}) === 383\n@test ccall_echo_load(Ref([144,172],2), Ptr{Int}, Ref{Int}) === 172\n# @test ccall_echo_load(Ref([8],1,1), Ptr{Int}, Ref{Int}) === 8\n\n\n## Tests for passing and returning structs\n\nlet a, ci_ary, x\n    a = 20 + 51im\n\n    x = ccall((:ctest, libccalltest), Complex{Int}, (Complex{Int},), a)\n\n    @test x == a + 1 - 2im\n\n    ci_ary = [a] # Make sure the array is alive during unsafe_load\n    x = unsafe_load(ccall((:cptest, libccalltest), Ptr{Complex{Int}},\n                          (Ptr{Complex{Int}},), ci_ary))\n\n    @test x == a + 1 - 2im\n    @test a == 20 + 51im\n\n    x = ccall((:cptest_static, libccalltest), Ptr{Complex{Int}}, (Ptr{Complex{Int}},), &a)\n    @test unsafe_load(x) == a\n    Libc.free(convert(Ptr{Void},x))\nend\n\nlet a, b, x\n    a = 2.84 + 5.2im\n\n    x = ccall((:cgtest, libccalltest), Complex128, (Complex128,), a)\n\n    @test x == a + 1 - 2im\n\n    b = [a] # Make sure the array is alive during unsafe_load\n    x = unsafe_load(ccall((:cgptest, libccalltest), Ptr{Complex128}, (Ptr{Complex128},), b))\n\n    @test x == a + 1 - 2im\n    @test a == 2.84 + 5.2im\nend\n\nlet a, b, x\n    a = 3.34f0 + 53.2f0im\n\n    x = ccall((:cftest, libccalltest), Complex64, (Complex64,), a)\n\n    @test x == a + 1 - 2im\n\n    b = [a] # Make sure the array is alive during unsafe_load\n    x = unsafe_load(ccall((:cfptest, libccalltest), Ptr{Complex64}, (Ptr{Complex64},), b))\n\n    @test x == a + 1 - 2im\n    @test a == 3.34f0 + 53.2f0im\nend\n\n\n## Tests for native Julia data types\n\nlet a\n    a = 2.84 + 5.2im\n\n    @test_throws MethodError ccall((:cptest, libccalltest), Ptr{Complex{Int}}, (Ptr{Complex{Int}},), a)\n    @test_throws MethodError ccall((:cptest, libccalltest), Ptr{Complex{Int}}, (Complex{Int},), &a)\nend\n\n\n## Tests for various sized data types (ByVal)\n\ntype Struct1\n    x::Float32\n    y::Float64\nend\nimmutable Struct1I\n    x::Float32\n    y::Float64\nend\ncopy(a::Struct1) = Struct1(a.x, a.y)\ncopy(a::Struct1I) = a\n\nfunction test_struct1{Struct}(::Type{Struct})\n    a = Struct(352.39422f23, 19.287577)\n    b = Float32(123.456)\n\n    a2 = copy(a)\n    x = ccall((:test_1, libccalltest), Struct, (Struct, Float32), a2, b)\n\n    @test a2.x == a.x && a2.y == a.y\n    @test !(a2 === x)\n\n    @test x.x \u2248 a.x + 1*b\n    @test x.y \u2248 a.y - 2*b\nend\ntest_struct1(Struct1)\ntest_struct1(Struct1I)\n\nlet a, b, x, y\n    a = Complex{Int32}(Int32(10),Int32(31))\n    b = Int32(42)\n\n    x = ccall((:test_2a, libccalltest), Complex{Int32}, (Complex{Int32}, Int32), a, b)\n    y = ccall((:test_2b, libccalltest), Complex{Int32}, (Complex{Int32},Int32), a, b)\n\n    @test a == Complex{Int32}(Int32(10),Int32(31))\n\n    @test x == y\n    @test x == a + b*1 - b*2im\nend\n\nlet a, b, x, y, z\n    a = Complex{Int64}(Int64(20),Int64(51))\n    b = Int64(42)\n\n    x = ccall((:test_3a, libccalltest), Complex{Int64}, (Complex{Int64}, Int64), a, b)\n    y = ccall((:test_3b, libccalltest), Complex{Int64}, (Complex{Int64}, Int64), a, b)\n    z = ccall((:test_128, libccalltest), Complex{Int64}, (Complex{Int64}, Int64), a, b)\n\n    @test a == Complex{Int64}(Int64(20),Int64(51))\n\n    @test x == y\n    @test x == a + b*1 - b*2im\n\n    @test z == a + 1*b\nend\n\ntype Struct4\n    x::Int32\n    y::Int32\n    z::Int32\nend\nimmutable Struct4I\n    x::Int32\n    y::Int32\n    z::Int32\nend\n\nfunction test_struct4{Struct}(::Type{Struct})\n    a = Struct(-512275808,882558299,-2133022131)\n    b = Int32(42)\n\n    x = ccall((:test_4, libccalltest), Struct, (Struct, Int32), a, b)\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\n    @test x.z == a.z+b*3\nend\ntest_struct4(Struct4)\ntest_struct4(Struct4I)\n\ntype Struct5\n    x::Int32\n    y::Int32\n    z::Int32\n    a::Int32\nend\nimmutable Struct5I\n    x::Int32\n    y::Int32\n    z::Int32\n    a::Int32\nend\n\nfunction test_struct5{Struct}(::Type{Struct})\n    a = Struct(1771319039, 406394736, -1269509787, -745020976)\n    b = Int32(42)\n\n    x = ccall((:test_5, libccalltest), Struct, (Struct, Int32), a, b)\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\n    @test x.z == a.z+b*3\n    @test x.a == a.a-b*4\nend\ntest_struct5(Struct5)\ntest_struct5(Struct5I)\n\ntype Struct6\n    x::Int64\n    y::Int64\n    z::Int64\nend\nimmutable Struct6I\n    x::Int64\n    y::Int64\n    z::Int64\nend\n\nfunction test_struct6{Struct}(::Type{Struct})\n    a = Struct(-654017936452753226, -5573248801240918230, -983717165097205098)\n    b = Int64(42)\n\n    x = ccall((:test_6, libccalltest), Struct, (Struct, Int64), a, b)\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\n    @test x.z == a.z+b*3\nend\ntest_struct6(Struct6)\ntest_struct6(Struct6I)\n\ntype Struct7\n    x::Int64\n    y::Cchar\nend\nimmutable Struct7I\n    x::Int64\n    y::Cchar\nend\n\nfunction test_struct7{Struct}(::Type{Struct})\n    a = Struct(-384082741977533896, 'h')\n    b = Int8(42)\n\n    x = ccall((:test_7, libccalltest), Struct, (Struct, Int8), a, b)\n\n    @test x.x == a.x+Int(b)*1\n    @test x.y == a.y-Int(b)*2\nend\ntest_struct7(Struct7)\ntest_struct7(Struct7I)\n\ntype Struct8\n    x::Int32\n    y::Cchar\nend\nimmutable Struct8I\n    x::Int32\n    y::Cchar\nend\n\nfunction test_struct8{Struct}(::Type{Struct})\n    a = Struct(-384082896, 'h')\n    b = Int8(42)\n\n    r8 = ccall((:test_8, libccalltest), Struct, (Struct, Int8), a, b)\n\n    @test r8.x == a.x+b*1\n    @test r8.y == a.y-b*2\nend\ntest_struct8(Struct8)\ntest_struct8(Struct8I)\n\ntype Struct9\n    x::Int32\n    y::Int16\nend\nimmutable Struct9I\n    x::Int32\n    y::Int16\nend\n\nfunction test_struct9{Struct}(::Type{Struct})\n    a = Struct(-394092996, -3840)\n    b = Int16(42)\n\n    x = ccall((:test_9, libccalltest), Struct, (Struct, Int16), a, b)\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\nend\ntest_struct9(Struct9)\ntest_struct9(Struct9I)\n\ntype Struct10\n    x::Cchar\n    y::Cchar\n    z::Cchar\n    a::Cchar\nend\nimmutable Struct10I\n    x::Cchar\n    y::Cchar\n    z::Cchar\n    a::Cchar\nend\n\nfunction test_struct10{Struct}(::Type{Struct})\n    a = Struct('0', '1', '2', '3')\n    b = Int8(2)\n\n    x = ccall((:test_10, libccalltest), Struct, (Struct, Int8), a, b)\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\n    @test x.z == a.z+b*3\n    @test x.a == a.a-b*4\nend\ntest_struct10(Struct10)\ntest_struct10(Struct10I)\n\ntype Struct11\n    x::Complex64\nend\nimmutable Struct11I\n    x::Complex64\nend\n\nfunction test_struct11{Struct}(::Type{Struct})\n    a = Struct(0.8877077f0 + 0.4591081f0im)\n    b = Float32(42)\n\n    x = ccall((:test_11, libccalltest), Struct, (Struct, Float32), a, b)\n\n    @test x.x \u2248 a.x + b*1 - b*2im\nend\ntest_struct11(Struct11)\ntest_struct11(Struct11I)\n\ntype Struct12\n    x::Complex64\n    y::Complex64\nend\nimmutable Struct12I\n    x::Complex64\n    y::Complex64\nend\n\nfunction test_struct12{Struct}(::Type{Struct})\n    a = Struct(0.8877077f5 + 0.4591081f2im, 0.0004842868f0 - 6982.3265f3im)\n    b = Float32(42)\n\n    x = ccall((:test_12, libccalltest), Struct, (Struct, Float32), a, b)\n\n    @test x.x \u2248 a.x + b*1 - b*2im\n    @test x.y \u2248 a.y + b*3 - b*4im\nend\ntest_struct12(Struct12)\ntest_struct12(Struct12I)\n\ntype Struct13\n    x::Complex128\nend\nimmutable Struct13I\n    x::Complex128\nend\n\nfunction test_struct13{Struct}(::Type{Struct})\n    a = Struct(42968.97560380495 - 803.0576845153616im)\n    b = Float64(42)\n\n    x = ccall((:test_13, libccalltest), Struct, (Struct, Float64), a, b)\n\n    @test x.x \u2248 a.x + b*1 - b*2im\nend\ntest_struct13(Struct13)\ntest_struct13(Struct13I)\n\ntype Struct14\n    x::Float32\n    y::Float32\nend\nimmutable Struct14I\n    x::Float32\n    y::Float32\nend\n\nfunction test_struct14{Struct}(::Type{Struct})\n    a = Struct(0.024138331f0, 0.89759064f32)\n    b = Float32(42)\n\n    x = ccall((:test_14, libccalltest), Struct, (Struct, Float32), a, b)\n\n    @test x.x \u2248 a.x + b*1\n    @test x.y \u2248 a.y - b*2\nend\ntest_struct14(Struct14)\ntest_struct14(Struct14I)\n\ntype Struct15\n    x::Float64\n    y::Float64\nend\nimmutable Struct15I\n    x::Float64\n    y::Float64\nend\n\nfunction test_struct15{Struct}(::Type{Struct})\n    a = Struct(4.180997967273657, -0.404218594294923)\n    b = Float64(42)\n\n    x = ccall((:test_15, libccalltest), Struct, (Struct, Float64), a, b)\n\n    @test x.x \u2248 a.x + b*1\n    @test x.y \u2248 a.y - b*2\nend\ntest_struct15(Struct15)\ntest_struct15(Struct15I)\n\ntype Struct16\n    x::Float32\n    y::Float32\n    z::Float32\n    a::Float64\n    b::Float64\n    c::Float64\nend\nimmutable Struct16I\n    x::Float32\n    y::Float32\n    z::Float32\n    a::Float64\n    b::Float64\n    c::Float64\nend\n\nfunction test_struct16{Struct}(::Type{Struct})\n    a = Struct(0.1604656f0, 0.6297606f0, 0.83588994f0,\n               0.6460273620993535, 0.9472692581106656, 0.47328535437352093)\n    b = Float32(42)\n\n    x = ccall((:test_16, libccalltest), Struct, (Struct, Float32), a, b)\n\n    @test x.x \u2248 a.x + b*1\n    @test x.y \u2248 a.y - b*2\n    @test x.z \u2248 a.z + b*3\n    @test x.a \u2248 a.a - b*4\n    @test x.b \u2248 a.b + b*5\n    @test x.c \u2248 a.c - b*6\nend\ntest_struct16(Struct16)\ntest_struct16(Struct16I)\n\ntype Struct17\n    a::Int8\n    b::Int16\nend\nimmutable Struct17I\n    a::Int8\n    b::Int16\nend\n\nfunction test_struct17{Struct}(::Type{Struct})\n    a = Struct(2, 10)\n    b = Int8(2)\n\n    x = ccall((:test_17, libccalltest), Struct, (Struct, Int8), a, b)\n\n    @test x.a == a.a + b * 1\n    @test x.b == a.b - b * 2\nend\ntest_struct17(Struct17)\ntest_struct17(Struct17I)\n\ntype Struct18\n    a::Int8\n    b::Int8\n    c::Int8\nend\nimmutable Struct18I\n    a::Int8\n    b::Int8\n    c::Int8\nend\n\nfunction test_struct18{Struct}(::Type{Struct})\n    a = Struct(2, 10, -3)\n    b = Int8(2)\n\n    x = ccall((:test_18, libccalltest), Struct, (Struct, Int8), a, b)\n\n    @test x.a == a.a + b * 1\n    @test x.b == a.b - b * 2\n    @test x.c == a.c + b * 3\nend\ntest_struct18(Struct18)\ntest_struct18(Struct18I)\n\nlet a, b, x\n    a = Int128(0x7f00123456789abc)<<64 + typemax(UInt64)\n    b = Int64(1)\n\n    x = ccall((:test_128, libccalltest), Int128, (Int128, Int64), a, b)\n\n    @test x == a + b*1\n    @test a == Int128(0x7f00123456789abc)<<64 + typemax(UInt64)\nend\n\ntype Struct_Big\n    x::Int\n    y::Int\n    z::Int8\nend\nimmutable Struct_BigI\n    x::Int\n    y::Int\n    z::Int8\nend\ncopy(a::Struct_Big) = Struct_Big(a.x, a.y, a.z)\ncopy(a::Struct_BigI) = a\n\nfunction test_struct_big{Struct}(::Type{Struct})\n    a = Struct(424,-5,Int8('Z'))\n    a2 = copy(a)\n\n    x = ccall((:test_big, libccalltest), Struct, (Struct,), a2)\n\n    @test a2.x == a.x && a2.y == a.y && a2.z == a.z\n    @test x.x == a.x + 1\n    @test x.y == a.y - 2\n    @test x.z == a.z - Int('A')\nend\ntest_struct_big(Struct_Big)\ntest_struct_big(Struct_BigI)\n\nconst Struct_huge1a = NTuple{8, Int64}\nconst Struct_huge1b = NTuple{9, Int64}\nconst Struct_huge2a = NTuple{8, Cdouble}\nconst Struct_huge2b = NTuple{9, Cdouble}\ntype Struct_huge3a\n    cf::NTuple{3, Complex{Cfloat}}\n    f7::Cfloat\n    f8::Cfloat\nend\ntype Struct_huge3b\n    cf::NTuple{7, Complex{Cfloat}}\n    r8a::Cfloat\n    r8b::Cfloat\nend\ntype Struct_huge3c\n    cf::NTuple{7, Complex{Cfloat}}\n    r8a::Cfloat\n    r8b::Cfloat\n    r9::Cfloat\nend\ntype Struct_huge4a\n    r12::Complex{Cdouble}\n    r34::Complex{Cdouble}\n    r5::Complex{Cfloat}\n    r67::Complex{Cdouble}\n    r8::Cdouble\nend\ntype Struct_huge4b\n    r12::Complex{Cdouble}\n    r34::Complex{Cdouble}\n    r5::Complex{Cfloat}\n    r67::Complex{Cdouble}\n    r89::Complex{Cdouble}\nend\nconst Struct_huge5a = NTuple{8, Complex{Cint}}\nconst Struct_huge5b = NTuple{9, Complex{Cint}}\n\nfunction verify_huge(init, a, b)\n    @test typeof(init) === typeof(a) === typeof(b)\n    verbose && @show (a, b)\n    # make sure a was unmodified\n    for i = 1:nfields(a)\n        @test getfield(init, i) === getfield(a, i)\n    end\n    # make sure b was modifed as expected\n    a1, b1 = getfield(a, 1), getfield(b, 1)\n    while isa(a1, Tuple)\n        @test a1[2:end] === b1[2:end]\n        a1 = a1[1]\n        b1 = b1[1]\n    end\n    if isa(a1, VecElement)\n        a1 = a1.value\n        b1 = b1.value\n    end\n    @test oftype(a1, a1 * 39) === b1\n    for i = 2:nfields(a)\n        @test getfield(a, i) === getfield(b, i)\n    end\nend\nmacro test_huge(i, b, init)\n    f = QuoteNode(Symbol(\"test_huge\", i, b))\n    ty = Symbol(\"Struct_huge\", i, b)\n    return quote\n        let a = $ty($(esc(init))...), f\n            f(b) = ccall(($f, libccalltest), $ty, (Cchar, $ty, Cchar), '0' + $i, a, $b[1])\n            #code_llvm(f, typeof((a,)))\n            verify_huge($ty($(esc(init))...), a, f(a))\n        end\n    end\nend\n@test_huge 1 'a' ((1, 2, 3, 4, 5, 6, 7, 8),)\n@test_huge 1 'b' ((1, 2, 3, 4, 5, 6, 7, 8, 9),)\n@test_huge 2 'a' ((1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0),)\n@test_huge 2 'b' ((1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0),)\n@test_huge 3 'a' ((1.0 + 2.0im, 3.0 + 4.0im, 5.0 + 6.0im), 7.0, 8.0)\n@test_huge 3 'b' ((1.0 + 2.0im, 3.0 + 4.0im, 5.0 + 6.0im, 7.0 + 8.0im, 9.0 + 10.0im, 11.0 + 12.0im, 13.0 + 14.0im), 7.0, 8.0)\n@test_huge 3 'c' ((1.0 + 2.0im, 3.0 + 4.0im, 5.0 + 6.0im, 7.0 + 8.0im, 9.0 + 10.0im, 11.0 + 12.0im, 13.0 + 14.0im), 7.0, 8.0, 9.0)\n@test_huge 4 'a' (1.0 + 2.0im, 3.0 + 4.0im, 5.0f0 + 6.0f0im, 7.0 + 8.0im, 9.0)\n@test_huge 4 'b' (1.0 + 2.0im, 3.0 + 4.0im, 5.0f0 + 6.0f0im, 7.0 + 8.0im, 9.0 + 10.0im)\n@test_huge 5 'a' ((1 + 2im, 3 + 4im, 5 + 6im, 7 + 8im, 9 + 10im, 11 + 12im, 13 + 14im, 15 + 16im),)\n@test_huge 5 'b' ((1 + 2im, 3 + 4im, 5 + 6im, 7 + 8im, 9 + 10im, 11 + 12im, 13 + 14im, 15 + 16im, 17 + 17im),)\n\n## cfunction roundtrip\n\nverbose && Libc.flush_cstdio()\nverbose && println(\"Testing cfunction roundtrip: \")\n\ncf64 = 2.84+5.2im\ncf32 = 3.34f0+53.2f0im\nci32 = Complex{Int32}(Int32(10),Int32(31))\nci64 = Complex{Int64}(Int64(20),Int64(51))\ns1 = Struct1(352.39422f23, 19.287577)\n==(a::Struct1,b::Struct1) = a.x == b.x && a.y == b.y\n\nfor (t,v) in ((Complex{Int32},:ci32),(Complex{Int64},:ci64),\n              (Complex64,:cf32),(Complex128,:cf64),(Struct1,:s1))\n    fname = Symbol(\"foo\",v)\n    fname1 = Symbol(\"foo1\",v)\n    @eval begin\n        verbose && println($t)\n        a = copy($v)\n        verbose && println(\"A: \",a)\n        function $fname1(s::$t)\n            verbose && println(\"B: \",s)\n            @test s == $v\n            @test s === a\n            global c = s\n            s\n        end\n        function $fname1(s)\n            @assert false\n        end\n        function $fname(s::$t)\n            verbose && println(\"B: \",s)\n            @test s == $v\n            if($(t).mutable)\n                @test !(s === a)\n            end\n            global c = s\n            s\n        end\n        function $fname(s)\n            @assert false\n        end\n        b = ccall(cfunction($fname1,Ref{$t},(Ref{$t},)),Ref{$t},(Ref{$t},),a)\n        verbose && println(\"C: \",b)\n        @test b == $v\n        @test b === a\n        @test b === c\n        b = ccall(cfunction($fname,$t,($t,)),$t,($t,),a)\n        verbose && println(\"C: \",b)\n        @test b == $v\n        if ($(t).mutable)\n            @test !(b === c)\n            @test !(b === a)\n        end\n        b = ccall(cfunction($fname1,$t,(Ref{$t},)),$t,(Ref{$t},),a)\n        verbose && println(\"C: \",b)\n        @test b == $v\n        if ($(t).mutable)\n            @test !(b === c)\n            @test !(b === a)\n        end\n        b = ccall(cfunction($fname,Ref{$t},($t,)),Ref{$t},($t,),a)\n        verbose && println(\"C: \",b)\n        @test b == $v\n        @test b === c\n        if ($(t).mutable)\n            @test !(b === a)\n        end\n        b = ccall(cfunction($fname,Any,(Ref{$t},)),Any,(Ref{$t},),$v)\n        verbose && println(\"C: \",b)\n        @test b == $v\n        @test b === c\n        if ($(t).mutable)\n            @test !(b === a)\n        end\n        b = ccall(cfunction($fname,Any,(Ref{Any},)),Any,(Ref{Any},),$v)\n        @test b == $v\n        @test b === c\n        if ($(t).mutable)\n            @test !(b === a)\n        end\n        @test_throws TypeError ccall(cfunction($fname,Ref{AbstractString},(Ref{Any},)),Any,(Ref{Any},),$v)\n        @test_throws TypeError ccall(cfunction($fname,AbstractString,(Ref{Any},)),Any,(Ref{Any},),$v)\n    end\nend\n\n# issue 13031\nfoo13031(x) = Cint(1)\nfoo13031p = cfunction(foo13031, Cint, (Ref{Tuple{}},))\nccall(foo13031p, Cint, (Ref{Tuple{}},), ())\n\nfoo13031(x,y,z) = z\nfoo13031p = cfunction(foo13031, Cint, (Ref{Tuple{}},Ref{Tuple{}},Cint))\nccall(foo13031p, Cint, (Ref{Tuple{}},Ref{Tuple{}},Cint), (), (), 8)\n\n# issue 17219\nfunction ccall_reassigned_ptr(ptr::Ptr{Void})\n    ptr = Libdl.dlsym(Libdl.dlopen(libccalltest), \"test_echo_p\")\n    ccall(ptr, Any, (Any,), \"foo\")\nend\n@test ccall_reassigned_ptr(C_NULL) == \"foo\"\n\n# @threadcall functionality\nthreadcall_test_func(x) =\n    @threadcall((:testUcharX, libccalltest), Int32, (UInt8,), x % UInt8)\n\n@test threadcall_test_func(3) == 1\n@test threadcall_test_func(259) == 1\n\n# issue 17819\n# NOTE: can't use cfunction or reuse ccalltest Struct methods, as those call into the runtime\n@test @threadcall((:threadcall_args, libccalltest), Cint, (Cint, Cint), 1, 2) == 3\n\nlet n=3\n    tids = Culong[]\n    @sync for i in 1:10^n\n        @async push!(tids, @threadcall(:uv_thread_self, Culong, ()))\n    end\n\n    # The work should not be done on the master thread\n    t0 = ccall(:uv_thread_self, Culong, ())\n    @test length(tids) == 10^n\n    for t in tids\n        @test t != t0\n    end\nend\n\n@test ccall(:jl_getpagesize, Clong, ()) == @threadcall(:jl_getpagesize, Clong, ())\n\n# Pointer finalizer (issue #15408)\nlet A = [1]\n    ccall((:set_c_int, libccalltest), Void, (Cint,), 1)\n    @test ccall((:get_c_int, libccalltest), Cint, ()) == 1\n    finalizer(A, cglobal((:finalizer_cptr, libccalltest), Void))\n    finalize(A)\n    @test ccall((:get_c_int, libccalltest), Cint, ()) == -1\nend\n\n# SIMD Registers\n\ntypealias VecReg{N,T} NTuple{N,VecElement{T}}\ntypealias V2xF32 VecReg{2,Float32}\ntypealias V4xF32 VecReg{4,Float32}\ntypealias V2xF64 VecReg{2,Float64}\ntypealias V2xI32 VecReg{2,Int32}\ntypealias V4xI32 VecReg{4,Int32}\n\nimmutable Struct_AA64_1\n    v1::Int32\n    v2::Int128\nend\nimmutable Struct_AA64_2\n    v1::Float16\n    v2::Float64\nend\n\n# This is a homogenious short vector aggregate\nimmutable Struct_AA64_3\n    v1::VecReg{8,Int8}\n    v2::VecReg{2,Float32}\nend\n# This is NOT a homogenious short vector aggregate\nimmutable Struct_AA64_4\n    v2::VecReg{2,Float32}\n    v1::VecReg{8,Int16}\nend\n\ntype Struct_huge1_ppc64\n    m::Int64\n    v::V4xF32\nend\n\ntype Struct_huge2_ppc64\n    v1::V4xF32\n    v2::V2xI32\nend\n\ntype Struct_huge3_ppc64\n    v1::V4xF32\n    f::NTuple{4,Float32}\nend\n\ntype Struct_huge4_ppc64\n    v1::V2xF32\n    v2::V2xF64\nend\n\ntype Struct_huge5_ppc64\n    v1::NTuple{9,V4xF32}\nend\n\ntype Struct_huge6_ppc64\n    v1::NTuple{8,V4xF32}\n    v2::V4xF32\nend\n\ntype Struct_huge7_ppc64\n    v1::VecReg{3,Int32}\n    v2::VecReg{3,Int32}\nend\n\ntype Struct_huge1_ppc64_hva\n    v1::NTuple{8,V4xF32}\nend\n\ntype Struct_huge2_ppc64_hva\n    v1::NTuple{2,NTuple{2,V4xF32}}\nend\n\ntype Struct_huge3_ppc64_hva\n    vf1::V4xF32\n    vf2::Tuple{NTuple{2,V4xF32}}\nend\n\ntype Struct_huge4_ppc64_hva\n    v1::V4xI32\n    v2::V4xF32\nend\n\ntype Struct_huge5_ppc64_hva\n    v1::V4xI32\n    v2::V2xF64\nend\n\nif Sys.ARCH === :x86_64\n    function test_sse(a1::V4xF32,a2::V4xF32,a3::V4xF32,a4::V4xF32)\n        ccall((:test_m128, libccalltest), V4xF32, (V4xF32,V4xF32,V4xF32,V4xF32), a1, a2, a3, a4)\n    end\n\n    function test_sse(a1::V4xI32,a2::V4xI32,a3::V4xI32,a4::V4xI32)\n        ccall((:test_m128i, libccalltest), V4xI32, (V4xI32,V4xI32,V4xI32,V4xI32), a1, a2, a3, a4)\n    end\n\n    foo_ams(a1, a2, a3, a4) = VecReg(ntuple(i->VecElement(a1[i].value+a2[i].value*(a3[i].value-a4[i].value)),4))\n\n    rt_sse{T}(a1::T,a2::T,a3::T,a4::T) = ccall(cfunction(foo_ams,T,(T,T,T,T)), T, (T,T,T,T), a1, a2, a3,a4)\n\n    for s in [Float32,Int32]\n        a1 = VecReg(ntuple(i->VecElement(s(1i)),4))\n        a2 = VecReg(ntuple(i->VecElement(s(2i)),4))\n        a3 = VecReg(ntuple(i->VecElement(s(3i)),4))\n        a4 = VecReg(ntuple(i->VecElement(s(4i)),4))\n        r = VecReg(ntuple(i->VecElement(s(1i+2i*(3i-4i))),4))\n        @test test_sse(a1,a2,a3,a4) == r\n\n        # cfunction round-trip\n        @test rt_sse(a1,a2,a3,a4) == r\n    end\n\nelseif Sys.ARCH === :aarch64\n    for v1 in 1:99:1000, v2 in -100:-1999:-20000\n        @test ccall((:test_aa64_i128_1, libccalltest), Int128,\n                    (Int64, Int128), v1, v2) == v1 * 2 - v2\n    end\n    for v1 in 1:4, v2 in -4:-1, v3_1 in 3:5, v3_2 in 7:9\n        res = ccall((:test_aa64_i128_2, libccalltest), Struct_AA64_1,\n                    (Int64, Int128, Struct_AA64_1),\n                    v1, v2, Struct_AA64_1(v3_1, v3_2))\n        expected = Struct_AA64_1(v1 \u00f7 2 + 1 - v3_1, v2 * 2 - 1 - v3_2)\n        @test res === expected\n    end\n    for v1 in 1:4, v2 in -4:-1, v3 in 3:5, v4 in -(1:3)\n        res = ccall((:test_aa64_fp16_1, libccalltest), Float16,\n                    (Cint, Float32, Float64, Float16),\n                    v1, v2, v3, v4)\n        expected = Float16(v1 + v2 * 2 + v3 * 3 + v4 * 4)\n        @test res === expected\n\n        res = ccall((:test_aa64_fp16_2, libccalltest), Struct_AA64_2,\n                    (Cint, Float32, Float64, Float16),\n                    v1, v2, v3, v4)\n        expected = Struct_AA64_2(v4 / 2 + 1, v1 * 2 + v2 * 4 - v3)\n        @test res === expected\n    end\n    for v1_1 in 1:4, v1_2 in -2:2, v2 in -4:-1, v3_1 in 3:5, v3_2 in 6:8\n        res = ccall((:test_aa64_vec_1, libccalltest),\n                    VecReg{2,Int64},\n                    (VecReg{2,Int32}, Float32, VecReg{2,Int32}),\n                    (VecElement(Int32(v1_1)), VecElement(Int32(v1_2))),\n                    v2, (VecElement(Int32(v3_1)), VecElement(Int32(v3_2))))\n        expected = (VecElement(v1_1 * v2 + v3_1), VecElement(v1_2 * v2 + v3_2))\n        @test res === expected\n    end\n    for v1_11 in 1:4, v1_12 in -2:2, v1_21 in 1:4, v1_22 in -2:2,\n        v2_11 in 1:4, v2_12 in -2:2, v2_21 in 1:4, v2_22 in -2:2\n        v1 = Struct_AA64_3((VecElement(Int8(v1_11)), VecElement(Int8(v1_12)),\n                            VecElement(Int8(0)), VecElement(Int8(0)),\n                            VecElement(Int8(0)), VecElement(Int8(0)),\n                            VecElement(Int8(0)), VecElement(Int8(0))),\n                           (VecElement(Float32(v1_21)),\n                            VecElement(Float32(v1_22))))\n        v2 = Struct_AA64_4((VecElement(Float32(v2_21)),\n                            VecElement(Float32(v2_22))),\n                           (VecElement(Int16(v2_11)), VecElement(Int16(v2_12)),\n                            VecElement(Int16(0)), VecElement(Int16(0)),\n                            VecElement(Int16(0)), VecElement(Int16(0)),\n                            VecElement(Int16(0)), VecElement(Int16(0))))\n        res = ccall((:test_aa64_vec_2, libccalltest),\n                    Struct_AA64_3, (Struct_AA64_3, Struct_AA64_4), v1, v2)\n        expected = Struct_AA64_3((VecElement(Int8(v1_11 + v2_11)),\n                                  VecElement(Int8(v1_12 + v2_12)),\n                                  VecElement(Int8(0)), VecElement(Int8(0)),\n                                  VecElement(Int8(0)), VecElement(Int8(0)),\n                                  VecElement(Int8(0)), VecElement(Int8(0))),\n                                 (VecElement(Float32(v1_21 - v2_21)),\n                                  VecElement(Float32(v1_22 - v2_22))))\n        @test res === expected\n    end\n\nelseif Sys.ARCH === :powerpc64le || Sys.ARCH === :ppc64le\n@test_huge 1 \"_ppc64\" (1, (2.0, 3.0, 4.0, 5.0),)\n@test_huge 2 \"_ppc64\" ((1.0, 2.0, 3.0, 4.0), (11, 12))\n@test_huge 3 \"_ppc64\" ((1, 2, 3, 4), (11.0, 12.0, 13.0, 14.0))\n@test_huge 4 \"_ppc64\" ((1, 2), (11.0, 12.0))\n@test_huge 5 \"_ppc64\" ((((1.0, 2.0, 3.0, 4.0),\n                         (5.0, 6.0, 7.0, 8.0),\n                         (11.0, 12.0, 13.0, 14.0),\n                         (15.0, 16.0, 17.0, 18.0),\n                         (21.0, 22.0, 23.0, 24.0),\n                         (25.0, 26.0, 27.0, 28.0),\n                         (31.0, 32.0, 33.0, 34.0),\n                         (35.0, 36.0, 37.0, 38.0),\n                         (41.0, 42.0, 43.0, 44.0)),))\n@test_huge 6 \"_ppc64\" ((((1.0, 2.0, 3.0, 4.0),\n                         (5.0, 6.0, 7.0, 8.0),\n                         (11.0, 12.0, 13.0, 14.0),\n                         (15.0, 16.0, 17.0, 18.0),\n                         (21.0, 22.0, 23.0, 24.0),\n                         (25.0, 26.0, 27.0, 28.0),\n                         (31.0, 32.0, 33.0, 34.0),\n                         (35.0, 36.0, 37.0, 38.0)),\n                        (41.0, 42.0, 43.0, 44.0)))\n@test_huge 1 \"_ppc64_hva\" ((((1.0, 2.0, 3.0, 4.0),\n                             (5.0, 6.0, 7.0, 8.0),\n                             (11.0, 12.0, 13.0, 14.0),\n                             (15.0, 16.0, 17.0, 18.0),\n                             (21.0, 22.0, 23.0, 24.0),\n                             (25.0, 26.0, 27.0, 28.0),\n                             (31.0, 32.0, 33.0, 34.0),\n                             (35.0, 36.0, 37.0, 38.0)),))\n@test_huge 2 \"_ppc64_hva\" (((((1.0, 2.0, 3.0, 4.0),\n                              (5.0, 6.0, 7.0, 8.0)),\n                             ((11.0, 12.0, 13.0, 14.0),\n                              (15.0, 16.0, 17.0, 18.0))),))\n@test_huge 3 \"_ppc64_hva\" (((1.0, 2.0, 3.0, 4.0),\n                            (((11.0, 12.0, 13.0, 14.0),\n                              (15.0, 16.0, 17.0, 18.0)),)))\n@test_huge 4 \"_ppc64_hva\" (((1, 2, 3, 4),\n                            (11.0, 12.0, 13.0, 14.0)))\n@test_huge 5 \"_ppc64_hva\" (((1, 2, 3, 4),\n                            (11.0, 12.0)))\n\n@test 18451 == ccall((:test_ppc64_vec1long, libccalltest), Int64,\n    (Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Struct_huge1_ppc64),\n    1, 2, 3, 4, 5, 6, 7, 8, 9, Struct_huge1_ppc64(18000, (100, 101, 102, 103)))\n\n@test 941 == ccall((:test_ppc64_vec1long_vec, libccalltest), Int64,\n    (Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, V4xF32),\n    11, 12, 13, 14, 15, 16, 17, 18, 19, (200, 201, 202, 203))\n\n@test V4xF32((614232, 614218, 614204, 614190)) ==\n     ccall((:test_ppc64_vec2, libccalltest), V4xF32,\n    (Int64, V4xF32, V4xF32, V4xF32, V4xF32,\n     V4xF32, V4xF32, V4xF32, V4xF32, V4xF32,\n     V4xF32, V4xF32, V4xF32, V4xF32, V4xF32),\n    600000, (4, 3, 2, 1), (5, 4, 3, 2), (6, 5, 4, 3), (7, 6, 5, 4),\n    (14, 13, 12, 11), (15, 14, 13, 12), (16, 15, 14, 13), (17, 16, 15, 14), (18, 17, 16, 15),\n    (1024, 1023, 1022, 1021), (1025, 1024, 1023, 1022), (1026, 1025, 1024, 1023), (1027, 1026, 1025, 1024), (10028, 10027, 10026, 10025))\n\nelseif Sys.ARCH !== :i686 && Sys.ARCH !== :arm # TODO\nwarn(\"ccall: no VecReg tests run for this platform\")\n\nend\n\n# Special calling convention for `Array`\nfunction f17204(a)\n    b = similar(a)\n    for i in eachindex(a)\n        b[i] = a[i] + 10\n    end\n    return b\nend\n@test ccall(cfunction(f17204, Vector{Any}, Tuple{Vector{Any}}),\n            Vector{Any}, (Vector{Any},), Any[1:10;]) == Any[11:20;]\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/sys.c": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n/*\n  sys.c\n  I/O and operating system utility functions\n*/\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#ifdef _OS_WINDOWS_\n#include <psapi.h>\n#else\n#include <sys/sysctl.h>\n#include <sys/wait.h>\n#include <sys/ptrace.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#endif\n#include <errno.h>\n#include <signal.h>\n#include <fcntl.h>\n\n#ifndef _OS_WINDOWS_\n// for getrusage\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#endif\n\n#ifdef __APPLE__\n#include <mach-o/dyld.h>\n#include <mach-o/nlist.h>\n#include <sys/types.h> // for jl_raise_debugger\n#elif !defined(_OS_WINDOWS_)\n#include <link.h>\n#endif\n\n#ifdef __SSE__\n#include <xmmintrin.h>\n#endif\n\n#if defined _MSC_VER\n#include <io.h>\n#include <intrin.h>\n#endif\n\n#ifdef JL_MSAN_ENABLED\n#include <sanitizer/msan_interface.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(_OS_WINDOWS_) && !defined(_COMPILER_MINGW_)\nJL_DLLEXPORT char *dirname(char *);\n#else\n#include <libgen.h>\n#endif\n\nJL_DLLEXPORT uint32_t jl_getutf8(ios_t *s)\n{\n    uint32_t wc=0;\n    ios_getutf8(s, &wc);\n    return wc;\n}\n\nJL_DLLEXPORT int jl_sizeof_uv_mutex(void) { return sizeof(uv_mutex_t); }\nJL_DLLEXPORT int jl_sizeof_off_t(void) { return sizeof(off_t); }\n#ifndef _OS_WINDOWS_\nJL_DLLEXPORT int jl_sizeof_mode_t(void) { return sizeof(mode_t); }\nJL_DLLEXPORT int jl_ftruncate(int fd, int64_t length)\n{\n    return ftruncate(fd, (off_t)length);\n}\nJL_DLLEXPORT int64_t jl_lseek(int fd, int64_t offset, int whence)\n{\n    return lseek(fd, (off_t)offset, whence);\n}\nJL_DLLEXPORT ssize_t jl_pwrite(int fd, const void *buf, size_t count, int64_t offset)\n{\n    return pwrite(fd, buf, count, (off_t)offset);\n}\nJL_DLLEXPORT void *jl_mmap(void *addr, size_t length, int prot, int flags,\n                           int fd, int64_t offset)\n{\n    return mmap(addr, length, prot, flags, fd, (off_t)offset);\n}\n#else\nJL_DLLEXPORT int64_t jl_lseek(int fd, int64_t offset, int whence)\n{\n    return _lseeki64(fd, offset, whence);\n}\n#endif\nJL_DLLEXPORT int jl_sizeof_ios_t(void) { return sizeof(ios_t); }\n\nJL_DLLEXPORT long jl_ios_fd(ios_t *s) { return s->fd; }\n\nJL_DLLEXPORT int32_t jl_nb_available(ios_t *s)\n{\n    return (int32_t)(s->size - s->bpos);\n}\n\n// --- dir/file stuff ---\n\nJL_DLLEXPORT int jl_sizeof_uv_fs_t(void) { return sizeof(uv_fs_t); }\nJL_DLLEXPORT void jl_uv_fs_req_cleanup(uv_fs_t *req) { uv_fs_req_cleanup(req); }\nJL_DLLEXPORT char *jl_uv_fs_t_ptr(uv_fs_t *req) { return (char*)req->ptr; }\nJL_DLLEXPORT int jl_uv_fs_result(uv_fs_t *f) { return f->result; }\n\n// --- stat ---\nJL_DLLEXPORT int jl_sizeof_stat(void) { return sizeof(uv_stat_t); }\n\nJL_DLLEXPORT int32_t jl_stat(const char *path, char *statbuf)\n{\n    uv_fs_t req;\n    int ret;\n\n    // Ideally one would use the statbuf for the storage in req, but\n    // it's not clear that this is possible using libuv\n    ret = uv_fs_stat(uv_default_loop(), &req, path, NULL);\n    if (ret == 0)\n        memcpy(statbuf, req.ptr, sizeof(uv_stat_t));\n    uv_fs_req_cleanup(&req);\n    return ret;\n}\n\nJL_DLLEXPORT int32_t jl_lstat(const char *path, char *statbuf)\n{\n    uv_fs_t req;\n    int ret;\n\n    ret = uv_fs_lstat(uv_default_loop(), &req, path, NULL);\n    if (ret == 0)\n        memcpy(statbuf, req.ptr, sizeof(uv_stat_t));\n    uv_fs_req_cleanup(&req);\n    return ret;\n}\n\nJL_DLLEXPORT int32_t jl_fstat(int fd, char *statbuf)\n{\n    uv_fs_t req;\n    int ret;\n\n    ret = uv_fs_fstat(uv_default_loop(), &req, fd, NULL);\n    if (ret == 0)\n        memcpy(statbuf, req.ptr, sizeof(uv_stat_t));\n    uv_fs_req_cleanup(&req);\n    return ret;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_dev(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_dev;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_ino(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_ino;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_mode(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_mode;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_nlink(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_nlink;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_uid(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_uid;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_gid(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_gid;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_rdev(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_rdev;\n}\n\nJL_DLLEXPORT uint64_t jl_stat_size(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_size;\n}\n\nJL_DLLEXPORT uint64_t jl_stat_blksize(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_blksize;\n}\n\nJL_DLLEXPORT uint64_t jl_stat_blocks(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_blocks;\n}\n\n/*\n// atime is stupid, let's not support it\nJL_DLLEXPORT double jl_stat_atime(char *statbuf)\n{\n  uv_stat_t *s;\n  s = (uv_stat_t*)statbuf;\n  return (double)s->st_atim.tv_sec + (double)s->st_atim.tv_nsec * 1e-9;\n}\n*/\n\nJL_DLLEXPORT double jl_stat_mtime(char *statbuf)\n{\n    uv_stat_t *s;\n    s = (uv_stat_t*)statbuf;\n    return (double)s->st_mtim.tv_sec + (double)s->st_mtim.tv_nsec * 1e-9;\n}\n\nJL_DLLEXPORT double jl_stat_ctime(char *statbuf)\n{\n    uv_stat_t *s;\n    s = (uv_stat_t*)statbuf;\n    return (double)s->st_ctim.tv_sec + (double)s->st_ctim.tv_nsec * 1e-9;\n}\n\n// --- buffer manipulation ---\n\nJL_DLLEXPORT jl_array_t *jl_takebuf_array(ios_t *s)\n{\n    size_t n;\n    jl_array_t *a;\n    if (s->buf == &s->local[0]) {\n        // small data case. copies, but this can be avoided using the\n        // technique of jl_readuntil below.\n        a = jl_pchar_to_array(s->buf, s->size);\n        ios_trunc(s, 0);\n    }\n    else {\n        char *b = ios_takebuf(s, &n);\n        a = jl_ptr_to_array_1d(jl_array_uint8_type, b, n-1, 1);\n    }\n    return a;\n}\n\nJL_DLLEXPORT jl_value_t *jl_takebuf_string(ios_t *s)\n{\n    jl_array_t *a = jl_takebuf_array(s);\n    JL_GC_PUSH1(&a);\n    jl_value_t *str = jl_array_to_string(a);\n    JL_GC_POP();\n    return str;\n}\n\n// the returned buffer must be manually freed. To determine the size,\n// call position(s) before using this function.\nJL_DLLEXPORT void *jl_takebuf_raw(ios_t *s)\n{\n    size_t sz;\n    void *buf = ios_takebuf(s, &sz);\n    return buf;\n}\n\nJL_DLLEXPORT jl_value_t *jl_readuntil(ios_t *s, uint8_t delim)\n{\n    jl_array_t *a;\n    // manually inlined common case\n    char *pd = (char*)memchr(s->buf+s->bpos, delim, (size_t)(s->size - s->bpos));\n    if (pd) {\n        size_t n = pd-(s->buf+s->bpos)+1;\n        a = jl_alloc_array_1d(jl_array_uint8_type, n);\n        memcpy(jl_array_data(a), s->buf + s->bpos, n);\n        s->bpos += n;\n    }\n    else {\n        a = jl_alloc_array_1d(jl_array_uint8_type, 80);\n        ios_t dest;\n        ios_mem(&dest, 0);\n        ios_setbuf(&dest, (char*)a->data, 80, 0);\n        size_t n = ios_copyuntil(&dest, s, delim);\n        if (dest.buf != a->data) {\n            a = jl_takebuf_array(&dest);\n        }\n        else {\n#ifdef STORE_ARRAY_LEN\n            a->length = n;\n#endif\n            a->nrows = n;\n            ((char*)a->data)[n] = '\\0';\n        }\n    }\n    return (jl_value_t*)a;\n}\n\nJL_DLLEXPORT uint64_t jl_ios_get_nbyte_int(ios_t *s, const size_t n)\n{\n    assert(n <= 8);\n    size_t space, ret;\n    do {\n        space = (size_t)(s->size - s->bpos);\n        ret = ios_readprep(s, n);\n        if (space == ret && ret < n)\n            jl_eof_error();\n    } while(ret < n);\n    uint64_t x = 0;\n    uint8_t *buf = (uint8_t*)&s->buf[s->bpos];\n    if (n == 8) {\n        // expecting loop unrolling optimization\n        for (size_t i = 0; i < 8; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n    }\n    else if (n >= 4) {\n        // expecting loop unrolling optimization\n        for (size_t i = 0; i < 4; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n        for (size_t i = 4; i < n; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n    }\n    else {\n        for (size_t i = 0; i < n; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n    }\n    s->bpos += n;\n    return x;\n}\n\n// -- syscall utilities --\n\nJL_DLLEXPORT int jl_errno(void) { return errno; }\nJL_DLLEXPORT void jl_set_errno(int e) { errno = e; }\n\n// -- get the number of CPU cores --\n\n#ifdef _OS_WINDOWS_\ntypedef DWORD (WINAPI *GAPC)(WORD);\n#ifndef ALL_PROCESSOR_GROUPS\n#define ALL_PROCESSOR_GROUPS 0xffff\n#endif\n#endif\n\nJL_DLLEXPORT int jl_cpu_cores(void)\n{\n#if defined(HW_AVAILCPU) && defined(HW_NCPU)\n    size_t len = 4;\n    int32_t count;\n    int nm[2] = {CTL_HW, HW_AVAILCPU};\n    sysctl(nm, 2, &count, &len, NULL, 0);\n    if (count < 1) {\n        nm[1] = HW_NCPU;\n        sysctl(nm, 2, &count, &len, NULL, 0);\n        if (count < 1) { count = 1; }\n    }\n    return count;\n#elif defined(_SC_NPROCESSORS_ONLN)\n    return sysconf(_SC_NPROCESSORS_ONLN);\n#elif defined(_OS_WINDOWS_)\n    //Try to get WIN7 API method\n    GAPC gapc = (GAPC) jl_dlsym_e(\n        jl_kernel32_handle,\n        \"GetActiveProcessorCount\"\n    );\n\n    if (gapc) {\n        return gapc(ALL_PROCESSOR_GROUPS);\n    }\n    else { //fall back on GetSystemInfo\n        SYSTEM_INFO info;\n        GetSystemInfo(&info);\n        return info.dwNumberOfProcessors;\n    }\n#else\n    return 1;\n#endif\n}\n\n// -- high resolution timers --\n// Returns time in nanosec\nJL_DLLEXPORT uint64_t jl_hrtime(void)\n{\n    return uv_hrtime();\n}\n\n// -- iterating the environment --\n\n#ifdef __APPLE__\n#include <crt_externs.h>\n#else\n#if !defined(_OS_WINDOWS_) || defined(_COMPILER_MINGW_)\nextern char **environ;\n#endif\n#endif\n\nJL_DLLEXPORT jl_value_t *jl_environ(int i)\n{\n#ifdef __APPLE__\n    char **environ = *_NSGetEnviron();\n#endif\n    char *env = environ[i];\n    return env ? jl_pchar_to_string(env, strlen(env)) : jl_nothing;\n}\n\n// -- child process status --\n\n#if defined _MSC_VER || defined _OS_WINDOWS_\n/* Native Woe32 API.  */\n#include <process.h>\n#define waitpid(pid,statusp,options) _cwait (statusp, pid, WAIT_CHILD)\n#define WAIT_T int\n#define WTERMSIG(x) ((x) & 0xff) /* or: SIGABRT ?? */\n#define WCOREDUMP(x) 0\n#define WEXITSTATUS(x) (((x) >> 8) & 0xff) /* or: (x) ?? */\n#define WIFSIGNALED(x) (WTERMSIG (x) != 0) /* or: ((x) == 3) ?? */\n#define WIFEXITED(x) (WTERMSIG (x) == 0) /* or: ((x) != 3) ?? */\n#define WIFSTOPPED(x) 0\n#define WSTOPSIG(x) 0 //Is this correct?\n#endif\n\nint jl_process_exited(int status)      { return WIFEXITED(status); }\nint jl_process_signaled(int status)    { return WIFSIGNALED(status); }\nint jl_process_stopped(int status)     { return WIFSTOPPED(status); }\n\nint jl_process_exit_status(int status) { return WEXITSTATUS(status); }\nint jl_process_term_signal(int status) { return WTERMSIG(status); }\nint jl_process_stop_signal(int status) { return WSTOPSIG(status); }\n\n// -- access to std filehandles --\n\nJL_STREAM *JL_STDIN  = (JL_STREAM*)STDIN_FILENO;\nJL_STREAM *JL_STDOUT = (JL_STREAM*)STDOUT_FILENO;\nJL_STREAM *JL_STDERR = (JL_STREAM*)STDERR_FILENO;\n\nJL_DLLEXPORT JL_STREAM *jl_stdin_stream(void)  { return JL_STDIN; }\nJL_DLLEXPORT JL_STREAM *jl_stdout_stream(void) { return JL_STDOUT; }\nJL_DLLEXPORT JL_STREAM *jl_stderr_stream(void) { return JL_STDERR; }\n\n// CPUID\n\n#ifdef HAVE_CPUID\nJL_DLLEXPORT void jl_cpuid(int32_t CPUInfo[4], int32_t InfoType)\n{\n#if defined _MSC_VER\n    __cpuid(CPUInfo, InfoType);\n#else\n    __asm__ __volatile__ (\n        #if defined(__i386__) && defined(__PIC__)\n        \"xchg %%ebx, %%esi;\"\n        \"cpuid;\"\n        \"xchg %%esi, %%ebx;\":\n        \"=S\" (CPUInfo[1]) ,\n        #else\n        \"cpuid\":\n        \"=b\" (CPUInfo[1]),\n        #endif\n        \"=a\" (CPUInfo[0]),\n        \"=c\" (CPUInfo[2]),\n        \"=d\" (CPUInfo[3]) :\n        \"a\" (InfoType)\n    );\n#endif\n}\n#endif\n\n// -- set/clear the FZ/DAZ flags on x86 & x86-64 --\n#ifdef __SSE__\n\n// Cache of information recovered from jl_cpuid.\n// In a multithreaded environment, there will be races on subnormal_flags,\n// but they are harmless idempotent races.  If we ever embrace C11, then\n// subnormal_flags should be declared atomic.\nstatic volatile int32_t subnormal_flags = 1;\n\nstatic int32_t get_subnormal_flags(void)\n{\n    uint32_t f = subnormal_flags;\n    if (f & 1) {\n        // CPU capabilities not yet inspected.\n        f = 0;\n        int32_t info[4];\n        jl_cpuid(info, 0);\n        if (info[0] >= 1) {\n            jl_cpuid(info, 0x00000001);\n            if (info[3] & (1 << 26)) {\n                // SSE2 supports both FZ and DAZ\n                f = 0x00008040;\n            }\n            else if (info[3] & (1 << 25)) {\n                // SSE supports only the FZ flag\n                f = 0x00008000;\n            }\n        }\n        subnormal_flags = f;\n    }\n    return f;\n}\n\n// Returns non-zero if subnormals go to 0; zero otherwise.\nJL_DLLEXPORT int32_t jl_get_zero_subnormals(void)\n{\n    uint32_t flags = get_subnormal_flags();\n    return _mm_getcsr() & flags;\n}\n\n// Return zero on success, non-zero on failure.\nJL_DLLEXPORT int32_t jl_set_zero_subnormals(int8_t isZero)\n{\n    uint32_t flags = get_subnormal_flags();\n    if (flags) {\n        uint32_t state = _mm_getcsr();\n        if (isZero)\n            state |= flags;\n        else\n            state &= ~flags;\n        _mm_setcsr(state);\n        return 0;\n    }\n    else {\n        // Report a failure only if user is trying to enable FTZ/DAZ.\n        return isZero;\n    }\n}\n\n#elif defined(_CPU_AARCH64_)\n\n// FZ, bit [24]\nstatic const uint32_t fpcr_fz_mask = 1 << 24;\n\nstatic inline uint32_t get_fpcr_aarch64(void)\n{\n    uint32_t fpcr;\n    asm volatile(\"mrs %0, fpcr\" : \"=r\"(fpcr));\n    return fpcr;\n}\n\nstatic inline void set_fpcr_aarch64(uint32_t fpcr)\n{\n    asm volatile(\"msr fpcr, %0\" :: \"r\"(fpcr));\n}\n\nJL_DLLEXPORT int32_t jl_get_zero_subnormals(void)\n{\n    return (get_fpcr_aarch64() & fpcr_fz_mask) != 0;\n}\n\nJL_DLLEXPORT int32_t jl_set_zero_subnormals(int8_t isZero)\n{\n    uint32_t fpcr = get_fpcr_aarch64();\n    fpcr = isZero ? (fpcr | fpcr_fz_mask) : (fpcr & ~fpcr_fz_mask);\n    set_fpcr_aarch64(fpcr);\n    return 0;\n}\n\n#else\n\nJL_DLLEXPORT int32_t jl_get_zero_subnormals(void)\n{\n    return 0;\n}\n\nJL_DLLEXPORT int32_t jl_set_zero_subnormals(int8_t isZero)\n{\n    return isZero;\n}\n\n#endif\n\n// -- processor native alignment information --\n\nJL_DLLEXPORT void jl_native_alignment(uint_t *int8align, uint_t *int16align, uint_t *int32align,\n                                      uint_t *int64align, uint_t *float32align, uint_t *float64align)\n{\n    *int8align = __alignof(uint8_t);\n    *int16align = __alignof(uint16_t);\n    *int32align = __alignof(uint32_t);\n    *int64align = __alignof(uint64_t);\n    *float32align = __alignof(float);\n    *float64align = __alignof(double);\n}\n\nJL_DLLEXPORT jl_value_t *jl_is_char_signed(void)\n{\n    return ((char)255) < 0 ? jl_true : jl_false;\n}\n\n// -- misc sysconf info --\n\n#ifdef _OS_WINDOWS_\nstatic long cachedPagesize = 0;\nJL_DLLEXPORT long jl_getpagesize(void)\n{\n    if (!cachedPagesize) {\n        SYSTEM_INFO systemInfo;\n        GetSystemInfo (&systemInfo);\n        cachedPagesize = systemInfo.dwPageSize;\n    }\n    return cachedPagesize;\n}\n#else\nJL_DLLEXPORT long jl_getpagesize(void)\n{\n    return sysconf(_SC_PAGESIZE);\n}\n#endif\n\n#ifdef _OS_WINDOWS_\nstatic long cachedAllocationGranularity = 0;\nJL_DLLEXPORT long jl_getallocationgranularity(void)\n{\n    if (!cachedAllocationGranularity) {\n        SYSTEM_INFO systemInfo;\n        GetSystemInfo (&systemInfo);\n        cachedAllocationGranularity = systemInfo.dwAllocationGranularity;\n    }\n    return cachedAllocationGranularity;\n}\n#else\nJL_DLLEXPORT long jl_getallocationgranularity(void)\n{\n    return jl_getpagesize();\n}\n#endif\n\nJL_DLLEXPORT long jl_SC_CLK_TCK(void)\n{\n#ifndef _OS_WINDOWS_\n    return sysconf(_SC_CLK_TCK);\n#else\n    return 0;\n#endif\n}\n\nJL_DLLEXPORT size_t jl_get_field_offset(jl_datatype_t *ty, int field)\n{\n    if (ty->layout == NULL || field > jl_datatype_nfields(ty) || field < 1)\n        jl_bounds_error_int((jl_value_t*)ty, field);\n    return jl_field_offset(ty, field - 1);\n}\n\nJL_DLLEXPORT size_t jl_get_alignment(jl_datatype_t *ty)\n{\n    if (ty->layout == NULL)\n        jl_error(\"non-leaf type doesn't have an alignment\");\n    return ty->layout->alignment;\n}\n\n// Takes a handle (as returned from dlopen()) and returns the absolute path to the image loaded\nJL_DLLEXPORT const char *jl_pathname_for_handle(void *handle)\n{\n    if (!handle)\n        return NULL;\n\n#ifdef __APPLE__\n    // Iterate through all images currently in memory\n    for (int32_t i = _dyld_image_count(); i >= 0 ; i--) {\n        // dlopen() each image, check handle\n        const char *image_name = _dyld_get_image_name(i);\n        void *probe_lib = jl_load_dynamic_library(image_name, JL_RTLD_DEFAULT);\n        jl_dlclose(probe_lib);\n\n        // If the handle is the same as what was passed in (modulo mode bits), return this image name\n        if (((intptr_t)handle & (-4)) == ((intptr_t)probe_lib & (-4)))\n            return image_name;\n    }\n\n#elif defined(_OS_WINDOWS_)\n\n    wchar_t *pth16 = (wchar_t*)malloc(32768); // max long path length\n    DWORD n16 = GetModuleFileNameW((HMODULE)handle,pth16,32768);\n    if (n16 <= 0) {\n        free(pth16);\n        return NULL;\n    }\n    pth16[n16] = L'\\0';\n    DWORD n8 = WideCharToMultiByte(CP_UTF8, 0, pth16, -1, NULL, 0, NULL, NULL);\n    if (n8 == 0) {\n        free(pth16);\n        return NULL;\n    }\n    char *filepath = (char*)malloc(++n8);\n    if (!WideCharToMultiByte(CP_UTF8, 0, pth16, -1, filepath, n8, NULL, NULL)) {\n        free(pth16);\n        free(filepath);\n        return NULL;\n    }\n    free(pth16);\n    return filepath;\n\n#else // Linux, FreeBSD, ...\n\n    struct link_map *map;\n    dlinfo(handle, RTLD_DI_LINKMAP, &map);\n#ifdef JL_MSAN_ENABLED\n    __msan_unpoison(&map,sizeof(struct link_map*));\n    if (map) {\n        __msan_unpoison(map, sizeof(struct link_map));\n        __msan_unpoison_string(map->l_name);\n    }\n#endif\n    if (map)\n        return map->l_name;\n\n#endif\n    return NULL;\n}\n\n#ifdef _OS_WINDOWS_\nstatic BOOL CALLBACK jl_EnumerateLoadedModulesProc64(\n  _In_      PCTSTR ModuleName,\n  _In_      DWORD64 ModuleBase,\n  _In_      ULONG ModuleSize,\n  _In_opt_  PVOID a\n)\n{\n    jl_array_grow_end((jl_array_t*)a, 1);\n    //XXX: change to jl_arrayset if array storage allocation for Array{String,1} changes:\n    jl_value_t *v = jl_cstr_to_string(ModuleName);\n    jl_array_ptr_set(a, jl_array_dim0(a)-1, v);\n    return TRUE;\n}\n// Takes a handle (as returned from dlopen()) and returns the absolute path to the image loaded\nJL_DLLEXPORT int jl_dllist(jl_array_t *list)\n{\n    return EnumerateLoadedModules64(GetCurrentProcess(), jl_EnumerateLoadedModulesProc64, list);\n}\n#endif\n\nJL_DLLEXPORT void jl_raise_debugger(void)\n{\n#if defined(_OS_WINDOWS_)\n    if (IsDebuggerPresent() == 1)\n        DebugBreak();\n#else\n    raise(SIGTRAP);\n#endif // _OS_WINDOWS_\n}\n\nJL_DLLEXPORT jl_sym_t *jl_get_UNAME(void)\n{\n    return jl_symbol(JL_BUILD_UNAME);\n}\n\nJL_DLLEXPORT jl_sym_t *jl_get_ARCH(void)\n{\n    return jl_symbol(JL_BUILD_ARCH);\n}\n\nJL_DLLEXPORT size_t jl_maxrss(void)\n{\n#if defined(_OS_WINDOWS_)\n    PROCESS_MEMORY_COUNTERS counter;\n    GetProcessMemoryInfo( GetCurrentProcess( ), &counter, sizeof(counter) );\n    return (size_t)counter.PeakWorkingSetSize;\n\n#elif defined(_OS_LINUX_) || defined(_OS_DARWIN_) || defined (_OS_FREEBSD_)\n    struct rusage rusage;\n    getrusage( RUSAGE_SELF, &rusage );\n\n#if defined(_OS_LINUX_)\n    return (size_t)(rusage.ru_maxrss * 1024);\n#else\n    return (size_t)rusage.ru_maxrss;\n#endif\n\n#else\n    return (size_t)0;\n#endif\n}\n\nJL_DLLEXPORT int jl_threading_enabled(void)\n{\n#ifdef JULIA_ENABLE_THREADING\n    return 1;\n#else\n    return 0;\n#endif\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/runtime_ccall.cpp": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n#include <map>\n#include <string>\n#include <cstdio>\n#include <llvm/Support/Host.h>\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"llvm-version.h\"\nusing namespace llvm;\n\n// --- library symbol lookup ---\n\n// map from \"libX\" to full soname \"libX.so.ver\"\n#if defined(__linux__) || defined(__FreeBSD__)\nstatic uv_rwlock_t soname_lock;\nstatic std::map<std::string, std::string> sonameMap;\nstatic bool got_sonames = false;\n\nextern \"C\" void jl_init_runtime_ccall(void)\n{\n    uv_rwlock_init(&soname_lock);\n}\n\n// This reloads the sonames, necessary after system upgrade.\n// Keep this DLLEXPORTed, this is used by `BinDeps.jl` to make sure\n// newly installed libraries can be found.\nextern \"C\" JL_DLLEXPORT void jl_read_sonames(void)\n{\n    char *line=NULL;\n    size_t sz=0;\n#if defined(__linux__)\n    FILE *ldc = popen(\"/sbin/ldconfig -p\", \"r\");\n#else\n    FILE *ldc = popen(\"/sbin/ldconfig -r\", \"r\");\n#endif\n    if (ldc == NULL) return; // ignore errors in running ldconfig (other than whatever might have been printed to stderr)\n\n    // This loop is not allowed to call julia GC while holding the lock\n    uv_rwlock_wrlock(&soname_lock);\n    sonameMap.clear();\n    while (!feof(ldc)) {\n        ssize_t n = getline(&line, &sz, ldc);\n        if (n == -1)\n            break;\n        if (n > 2 && isspace((unsigned char)line[0])) {\n#ifdef __linux__\n            int i = 0;\n            while (isspace((unsigned char)line[++i])) ;\n            char *name = &line[i];\n            char *dot = strstr(name, \".so\");\n            i = 0;\n#else\n            char *name = strstr(line, \":-l\");\n            if (name == NULL) continue;\n            strncpy(name, \"lib\", 3);\n            char *dot = strchr(name, '.');\n#endif\n\n            if (NULL == dot)\n                continue;\n\n#ifdef __linux__\n            // Detect if this entry is for the current architecture\n            while (!isspace((unsigned char)dot[++i])) ;\n            while (isspace((unsigned char)dot[++i])) ;\n            int j = i;\n            while (!isspace((unsigned char)dot[++j])) ;\n            char *arch = strstr(dot+i,\"x86-64\");\n            if (arch != NULL && arch < dot + j) {\n#ifdef _P32\n                continue;\n#endif\n            }\n            else {\n#ifdef _P64\n                continue;\n#endif\n            }\n#endif // __linux__\n\n            char *abslibpath = strrchr(line, ' ');\n            if (dot != NULL && abslibpath != NULL) {\n                std::string pfx(name, dot - name);\n                // Do not include ' ' in front and '\\n' at the end\n                std::string soname(abslibpath+1, line+n-(abslibpath+1)-1);\n                sonameMap[pfx] = soname;\n            }\n        }\n    }\n\n    free(line);\n    pclose(ldc);\n    uv_rwlock_wrunlock(&soname_lock);\n}\n\n// This API is not thread safe. The return value can be free'd if\n// `jl_read_sonames()` is called on another thread.\nextern \"C\" JL_DLLEXPORT const char *jl_lookup_soname(const char *pfx, size_t n)\n{\n    if (!got_sonames) {\n        jl_read_sonames();\n        got_sonames = true;\n    }\n    const char *res = nullptr;\n    uv_rwlock_rdlock(&soname_lock);\n    auto search = sonameMap.find(std::string(pfx, n));\n    if (search != sonameMap.end())\n        res = search->second.c_str();\n    uv_rwlock_rdunlock(&soname_lock);\n    return res;\n}\n\nextern \"C\" void *jl_dlopen_soname(const char *pfx, size_t n, unsigned flags)\n{\n    if (!got_sonames) {\n        jl_read_sonames();\n        got_sonames = true;\n    }\n    void *res = nullptr;\n    uv_rwlock_rdlock(&soname_lock);\n    auto search = sonameMap.find(std::string(pfx, n));\n    if (search != sonameMap.end())\n        res = jl_dlopen(search->second.c_str(), flags);\n    uv_rwlock_rdunlock(&soname_lock);\n    return res;\n}\n#else\nextern \"C\" void jl_init_runtime_ccall(void)\n{\n}\n#endif\n\n// map from user-specified lib names to handles\nstatic std::map<std::string, void*> libMap;\n\nextern \"C\"\nvoid *jl_get_library(const char *f_lib)\n{\n    void *hnd;\n#ifdef _OS_WINDOWS_\n    if ((intptr_t)f_lib == 1)\n        return jl_exe_handle;\n    if ((intptr_t)f_lib == 2)\n        return jl_dl_handle;\n#endif\n    if (f_lib == NULL)\n        return jl_RTLD_DEFAULT_handle;\n    hnd = libMap[f_lib];\n    if (hnd != NULL)\n        return hnd;\n    hnd = jl_load_dynamic_library(f_lib, JL_RTLD_DEFAULT);\n    if (hnd != NULL)\n        libMap[f_lib] = hnd;\n    return hnd;\n}\n\nextern \"C\" JL_DLLEXPORT\nvoid *jl_load_and_lookup(const char *f_lib, const char *f_name, void **hnd)\n{\n    void *handle = *hnd;\n    if (!handle)\n        *hnd = handle = jl_get_library(f_lib);\n    return jl_dlsym(handle, f_name);\n}\n\n// miscellany\nextern \"C\" JL_DLLEXPORT\njl_value_t *jl_get_cpu_name(void)\n{\n#ifdef LLVM35\n    StringRef HostCPUName = llvm::sys::getHostCPUName();\n#else\n    const std::string& HostCPUName = llvm::sys::getHostCPUName();\n#endif\n    return jl_pchar_to_string(HostCPUName.data(), HostCPUName.size());\n}\n\nextern \"C\" JL_DLLEXPORT\njl_value_t *jl_get_JIT(void)\n{\n#if defined(USE_ORCJIT)\n    const std::string& HostJITName = \"ORCJIT\";\n#elif defined(USE_MCJIT)\n    const std::string& HostJITName = \"MCJIT\";\n#else\n    const std::string& HostJITName = \"Unknown\";\n#endif\n    return jl_pchar_to_string(HostJITName.data(), HostJITName.size());\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/julia_internal.h": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n#ifndef JULIA_INTERNAL_H\n#define JULIA_INTERNAL_H\n\n#include <options.h>\n#include <uv.h>\n#if !defined(_MSC_VER) && !defined(__MINGW32__)\n#include <unistd.h>\n#include <sched.h>\n#else\n#define sleep(x) Sleep(1000*x)\n#endif\n\n#if defined(__has_feature)\n#if __has_feature(address_sanitizer)\n#define JL_ASAN_ENABLED     // Clang flavor\n#endif\n#elif defined(__SANITIZE_ADDRESS__)\n#define JL_ASAN_ENABLED     // GCC flavor\n#endif\n\n#if defined(__has_feature)\n#if __has_feature(memory_sanitizer)\n#define JL_MSAN_ENABLED\n#endif\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"timing.h\"\n\n#define GC_CLEAN  0 // freshly allocated\n#define GC_MARKED 1 // reachable and young\n#define GC_OLD    2 // if it is reachable it will be marked as old\n#define GC_OLD_MARKED (GC_OLD | GC_MARKED) // reachable and old\n\n// useful constants\nextern jl_methtable_t *jl_type_type_mt;\n\n// execution of certain certain unpure\n// statements is prohibited from certain\n// callbacks (such as generated functions)\nextern int in_pure_callback;\ntypedef void (*tracer_cb)(jl_value_t *tracee);\nvoid jl_call_tracer(tracer_cb callback, jl_value_t *tracee);\n\nextern size_t jl_page_size;\nextern jl_function_t *jl_typeinf_func;\n\nJL_DLLEXPORT extern int jl_lineno;\nJL_DLLEXPORT extern const char *jl_filename;\n\nJL_DLLEXPORT jl_value_t *jl_gc_pool_alloc(jl_ptls_t ptls, int pool_offset,\n                                          int osize);\nJL_DLLEXPORT jl_value_t *jl_gc_big_alloc(jl_ptls_t ptls, size_t allocsz);\nint jl_gc_classify_pools(size_t sz, int *osize);\nextern jl_mutex_t gc_perm_lock;\nvoid *jl_gc_perm_alloc_nolock(size_t sz);\nvoid *jl_gc_perm_alloc(size_t sz);\n\n// pools are 16376 bytes large (GC_POOL_SZ - GC_PAGE_OFFSET)\nstatic const int jl_gc_sizeclasses[JL_GC_N_POOLS] = {\n#ifdef _P64\n    8,\n#elif defined(_CPU_ARM_) || defined(_CPU_PPC_)\n    // ARM and PowerPC have max alignment of 8,\n    // make sure allocation of size 8 has that alignment.\n    4, 8,\n#else\n    4, 8, 12,\n#endif\n\n    // 16 pools at 16-byte spacing\n    16, 32, 48, 64, 80, 96, 112, 128,\n    144, 160, 176, 192, 208, 224, 240, 256,\n\n    // the following tables are computed for maximum packing efficiency via the formula:\n    // sz=(div(2^14-8,rng)\u00f716)*16; hcat(sz, (2^14-8)\u00f7sz, 2^14-(2^14-8)\u00f7sz.*sz)'\n\n    // rng = 60:-4:32 (8 pools)\n    272, 288, 304, 336, 368, 400, 448, 496,\n//   60,  56,  53,  48,  44,  40,  36,  33, /pool\n//   64, 256, 272, 256, 192, 384, 256,  16, bytes lost\n\n    // rng = 30:-2:16 (8 pools)\n    544, 576, 624, 672, 736, 816, 896, 1008,\n//   30,  28,  26,  24,  22,  20,  18,  16, /pool\n//   64, 256, 160, 256, 192,  64, 256, 256, bytes lost\n\n    // rng = 15:-1:8 (8 pools)\n    1088, 1168, 1248, 1360, 1488, 1632, 1808, 2032\n//    15,   14,   13,   12,   11,   10,    9,    8, /pool\n//    64,   32,  160,   64,   16,   64,  112,  128, bytes lost\n};\n\nSTATIC_INLINE int jl_gc_alignment(size_t sz)\n{\n    if (sz == 0)\n        return sizeof(void*);\n#ifdef _P64\n    (void)sz;\n    return 16;\n#elif defined(_CPU_ARM_) || defined(_CPU_PPC_)\n    return sz <= 4 ? 8 : 16;\n#else\n    // szclass 8\n    if (sz <= 4)\n        return 8;\n    // szclass 12\n    if (sz <= 8)\n        return 4;\n    // szclass 16+\n    return 16;\n#endif\n}\n\nSTATIC_INLINE int JL_CONST_FUNC jl_gc_szclass(size_t sz)\n{\n#ifdef _P64\n    if (sz <=    8)\n        return 0;\n    const int N = 0;\n#elif defined(_CPU_ARM_) || defined(_CPU_PPC_)\n    if (sz <=    8)\n        return (sz + 3) / 4 - 1;\n    const int N = 1;\n#else\n    if (sz <=   12)\n        return (sz + 3) / 4 - 1;\n    const int N = 2;\n#endif\n    if (sz <=  256)\n        return (sz + 15) / 16 + N;\n    if (sz <=  496)\n        return 16 - 16376 / 4 / LLT_ALIGN(sz, 16 * 4) + 16 + N;\n    if (sz <= 1008)\n        return 16 - 16376 / 2 / LLT_ALIGN(sz, 16 * 2) + 24 + N;\n    return     16 - 16376 / 1 / LLT_ALIGN(sz, 16 * 1) + 32 + N;\n}\n\n#ifdef __GNUC__\n#  define jl_is_constexpr(e) __builtin_constant_p(e)\n#else\n#  define jl_is_constexpr(e) (0)\n#endif\n#define JL_SMALL_BYTE_ALIGNMENT 16\n#define JL_CACHE_BYTE_ALIGNMENT 64\n#define GC_MAX_SZCLASS (2032-sizeof(void*))\n\nSTATIC_INLINE jl_value_t *jl_gc_alloc_(jl_ptls_t ptls, size_t sz, void *ty)\n{\n    const size_t allocsz = sz + sizeof(jl_taggedvalue_t);\n    if (allocsz < sz) // overflow in adding offs, size was \"negative\"\n        jl_throw(jl_memory_exception);\n    jl_value_t *v;\n    if (allocsz <= GC_MAX_SZCLASS + sizeof(jl_taggedvalue_t)) {\n        int pool_id = jl_gc_szclass(allocsz);\n        jl_gc_pool_t *p = &ptls->heap.norm_pools[pool_id];\n        int osize;\n        if (jl_is_constexpr(allocsz)) {\n            osize = jl_gc_sizeclasses[pool_id];\n        }\n        else {\n            osize = p->osize;\n        }\n        v = jl_gc_pool_alloc(ptls, (char*)p - (char*)ptls, osize);\n    }\n    else {\n        v = jl_gc_big_alloc(ptls, allocsz);\n    }\n    jl_set_typeof(v, ty);\n    return v;\n}\nJL_DLLEXPORT jl_value_t *jl_gc_alloc(jl_ptls_t ptls, size_t sz, void *ty);\n// On GCC, only inline when sz is constant\n#ifdef __GNUC__\n#  define jl_gc_alloc(ptls, sz, ty)                             \\\n    (__builtin_constant_p(sz) ? jl_gc_alloc_(ptls, sz, ty) :    \\\n     (jl_gc_alloc)(ptls, sz, ty))\n#else\n#  define jl_gc_alloc(ptls, sz, ty) jl_gc_alloc_(ptls, sz, ty)\n#endif\n\n#define jl_buff_tag ((uintptr_t)0x4eade800)\nSTATIC_INLINE void *jl_gc_alloc_buf(jl_ptls_t ptls, size_t sz)\n{\n    return jl_gc_alloc(ptls, sz, (void*)jl_buff_tag);\n}\n\njl_lambda_info_t *jl_type_infer(jl_lambda_info_t *li, int force);\nvoid jl_generate_fptr(jl_lambda_info_t *li);\nvoid jl_compile_linfo(jl_lambda_info_t *li);\nJL_DLLEXPORT int jl_compile_hint(jl_tupletype_t *types);\njl_lambda_info_t *jl_compile_for_dispatch(jl_lambda_info_t *li);\nJL_DLLEXPORT void jl_set_lambda_code_null(jl_lambda_info_t *li);\n\n// invoke (compiling if necessary) the jlcall function pointer for a method\nSTATIC_INLINE jl_value_t *jl_call_method_internal(jl_lambda_info_t *meth, jl_value_t **args, uint32_t nargs)\n{\n    jl_lambda_info_t *mfptr = meth;\n    if (__unlikely(mfptr->fptr == NULL && mfptr->jlcall_api != 2)) {\n        mfptr = jl_compile_for_dispatch(mfptr);\n        if (!mfptr->fptr)\n            jl_generate_fptr(mfptr);\n    }\n    if (mfptr->jlcall_api == 0)\n        return mfptr->fptr(args[0], &args[1], nargs-1);\n    else if (mfptr->jlcall_api == 1)\n        return ((jl_fptr_sparam_t)mfptr->fptr)(meth->sparam_vals, args[0], &args[1], nargs-1);\n    else if (mfptr->jlcall_api == 2)\n        return meth->constval;\n    else if (mfptr->jlcall_api == 3)\n        return ((jl_fptr_linfo_t)mfptr->fptr)(mfptr, &args[0], nargs, meth->sparam_vals);\n    else\n        abort();\n}\n\njl_tupletype_t *jl_argtype_with_function(jl_function_t *f, jl_tupletype_t *types);\n\nJL_DLLEXPORT jl_value_t *jl_apply_2va(jl_value_t *f, jl_value_t **args, uint32_t nargs);\n\nvoid jl_gc_setmark(jl_ptls_t ptls, jl_value_t *v);\nvoid jl_gc_sync_total_bytes(void);\nvoid jl_gc_track_malloced_array(jl_ptls_t ptls, jl_array_t *a);\nvoid jl_gc_count_allocd(size_t sz);\nvoid jl_gc_run_all_finalizers(jl_ptls_t ptls);\n\nvoid gc_queue_binding(jl_binding_t *bnd);\nvoid gc_setmark_buf(jl_ptls_t ptls, void *buf, int, size_t);\n\nSTATIC_INLINE void jl_gc_wb_binding(jl_binding_t *bnd, void *val) // val isa jl_value_t*\n{\n    if (__unlikely(jl_astaggedvalue(bnd)->bits.gc == 3 &&\n                   (jl_astaggedvalue(val)->bits.gc & 1) == 0))\n        gc_queue_binding(bnd);\n}\n\nSTATIC_INLINE void jl_gc_wb_buf(void *parent, void *bufptr, size_t minsz) // parent isa jl_value_t*\n{\n    // if parent is marked and buf is not\n    if (__unlikely(jl_astaggedvalue(parent)->bits.gc & 1)) {\n        jl_ptls_t ptls = jl_get_ptls_states();\n        gc_setmark_buf(ptls, bufptr, 3, minsz);\n    }\n}\n\nvoid gc_debug_print_status(void);\nvoid gc_debug_critical_error(void);\nvoid jl_print_gc_stats(JL_STREAM *s);\nvoid jl_gc_reset_alloc_count(void);\nint jl_assign_type_uid(void);\njl_value_t *jl_cache_type_(jl_datatype_t *type);\nvoid jl_resort_type_cache(jl_svec_t *c);\nint  jl_get_t_uid_ctr(void);\nvoid jl_set_t_uid_ctr(int i);\nuint32_t jl_get_gs_ctr(void);\nvoid jl_set_gs_ctr(uint32_t ctr);\n\nvoid JL_NORETURN jl_method_error_bare(jl_function_t *f, jl_value_t *args);\nvoid JL_NORETURN jl_method_error(jl_function_t *f, jl_value_t **args, size_t na);\njl_value_t *jl_get_exceptionf(jl_datatype_t *exception_type, const char *fmt, ...);\n\nJL_DLLEXPORT void jl_typeassert(jl_value_t *x, jl_value_t *t);\n\n#define JL_CALLABLE(name)                                               \\\n    JL_DLLEXPORT jl_value_t *name(jl_value_t *F, jl_value_t **args, uint32_t nargs)\n\nJL_CALLABLE(jl_unprotect_stack);\nJL_CALLABLE(jl_f_tuple);\nJL_CALLABLE(jl_f_intrinsic_call);\nextern jl_function_t *jl_unprotect_stack_func;\nvoid jl_install_default_signal_handlers(void);\nvoid restore_signals(void);\nvoid jl_install_thread_signal_handler(jl_ptls_t ptls);\n\njl_fptr_t jl_get_builtin_fptr(jl_value_t *b);\n\nextern uv_loop_t *jl_io_loop;\n\nJL_DLLEXPORT void jl_uv_associate_julia_struct(uv_handle_t *handle,\n                                               jl_value_t *data);\nJL_DLLEXPORT int jl_uv_fs_result(uv_fs_t *f);\n\nint jl_tuple_subtype(jl_value_t **child, size_t cl, jl_datatype_t *pdt, int ta);\n\nint jl_subtype_invariant(jl_value_t *a, jl_value_t *b, int ta);\njl_value_t *jl_type_match(jl_value_t *a, jl_value_t *b);\nextern int type_match_invariance_mask;\njl_value_t *jl_type_match_morespecific(jl_value_t *a, jl_value_t *b);\nint jl_types_equal_generic(jl_value_t *a, jl_value_t *b, int useenv);\njl_datatype_t *jl_inst_concrete_tupletype_v(jl_value_t **p, size_t np);\njl_datatype_t *jl_inst_concrete_tupletype(jl_svec_t *p);\nvoid jl_method_table_insert(jl_methtable_t *mt, jl_method_t *method, jl_tupletype_t *simpletype);\njl_value_t *jl_mk_builtin_func(const char *name, jl_fptr_t fptr);\nSTATIC_INLINE int jl_is_type(jl_value_t *v)\n{\n    jl_value_t *t = jl_typeof(v);\n    return (t == (jl_value_t*)jl_datatype_type || t == (jl_value_t*)jl_uniontype_type ||\n            t == (jl_value_t*)jl_typector_type);\n}\njl_value_t *jl_type_intersection_matching(jl_value_t *a, jl_value_t *b,\n                                          jl_svec_t **penv, jl_svec_t *tvars);\njl_value_t *jl_apply_type_(jl_value_t *tc, jl_value_t **params, size_t n);\njl_value_t *jl_instantiate_type_with(jl_value_t *t, jl_value_t **env, size_t n);\njl_datatype_t *jl_new_uninitialized_datatype(void);\njl_datatype_t *jl_new_abstracttype(jl_value_t *name, jl_datatype_t *super,\n                                   jl_svec_t *parameters);\nvoid jl_precompute_memoized_dt(jl_datatype_t *dt);\njl_datatype_t *jl_wrap_Type(jl_value_t *t);  // x -> Type{x}\njl_datatype_t *jl_wrap_vararg(jl_value_t *t, jl_value_t *n);\nvoid jl_assign_bits(void *dest, jl_value_t *bits);\njl_expr_t *jl_exprn(jl_sym_t *head, size_t n);\njl_function_t *jl_new_generic_function(jl_sym_t *name, jl_module_t *module);\njl_function_t *jl_module_call_func(jl_module_t *m);\nint jl_is_submodule(jl_module_t *child, jl_module_t *parent);\n\njl_value_t *jl_toplevel_eval_flex(jl_value_t *e, int fast, int expanded);\njl_value_t *jl_toplevel_eval_in_warn(jl_module_t *m, jl_value_t *ex,\n                                     int delay_warn);\n\njl_lambda_info_t *jl_wrap_expr(jl_value_t *expr);\njl_value_t *jl_eval_global_var(jl_module_t *m, jl_sym_t *e);\njl_value_t *jl_parse_eval_all(const char *fname,\n                              const char *content, size_t contentlen);\njl_value_t *jl_interpret_toplevel_thunk(jl_lambda_info_t *lam);\njl_value_t *jl_interpret_toplevel_expr(jl_value_t *e);\njl_value_t *jl_static_eval(jl_value_t *ex, void *ctx_, jl_module_t *mod,\n                           jl_lambda_info_t *li, int sparams, int allow_alloc);\nint jl_is_toplevel_only_expr(jl_value_t *e);\njl_value_t *jl_call_scm_on_ast(const char *funcname, jl_value_t *expr);\n\njl_lambda_info_t *jl_method_lookup_by_type(jl_methtable_t *mt, jl_tupletype_t *types,\n                                           int cache, int inexact, int allow_exec);\njl_lambda_info_t *jl_method_lookup(jl_methtable_t *mt, jl_value_t **args, size_t nargs, int cache);\njl_value_t *jl_gf_invoke(jl_tupletype_t *types, jl_value_t **args, size_t nargs);\n\njl_datatype_t *jl_first_argument_datatype(jl_value_t *argtypes);\nint jl_has_intrinsics(jl_lambda_info_t *li, jl_value_t *v, jl_module_t *m);\n\njl_value_t *jl_nth_slot_type(jl_tupletype_t *sig, size_t i);\nvoid jl_compute_field_offsets(jl_datatype_t *st);\njl_array_t *jl_new_array_for_deserialization(jl_value_t *atype, uint32_t ndims, size_t *dims,\n                                             int isunboxed, int elsz);\nvoid jl_module_run_initializer(jl_module_t *m);\nextern jl_array_t *jl_module_init_order;\nextern union jl_typemap_t jl_cfunction_list;\n\n#ifdef JL_USE_INTEL_JITEVENTS\nextern char jl_using_intel_jitevents;\n#endif\n#ifdef JL_USE_OPROFILE_JITEVENTS\nextern char jl_using_oprofile_jitevents;\n#endif\nextern size_t jl_arr_xtralloc_limit;\n\nvoid jl_init_types(void);\nvoid jl_init_box_caches(void);\nvoid jl_init_frontend(void);\nvoid jl_init_primitives(void);\nvoid jl_init_codegen(void);\nvoid jl_init_intrinsic_functions(void);\nvoid jl_init_tasks(void);\nvoid jl_init_stack_limits(int ismaster);\nvoid jl_init_root_task(void *stack, size_t ssize);\nvoid jl_init_serializer(void);\nvoid jl_gc_init(void);\nvoid jl_init_signal_async(void);\nvoid jl_init_debuginfo(void);\nvoid jl_init_runtime_ccall(void);\nvoid jl_mk_thread_heap(jl_ptls_t ptls);\n\nvoid _julia_init(JL_IMAGE_SEARCH rel);\n\nvoid jl_set_base_ctx(char *__stk);\n\nextern ssize_t jl_tls_offset;\nvoid jl_init_threading(void);\nvoid jl_start_threads(void);\nvoid jl_shutdown_threading(void);\n\n// Whether the GC is running\nextern char *jl_safepoint_pages;\nSTATIC_INLINE int jl_addr_is_safepoint(uintptr_t addr)\n{\n    uintptr_t safepoint_addr = (uintptr_t)jl_safepoint_pages;\n    return addr >= safepoint_addr && addr < safepoint_addr + jl_page_size * 3;\n}\nextern volatile uint32_t jl_gc_running;\n// All the functions are safe to be called from within a signal handler\n// provided that the thread will not be interrupted by another asynchronous\n// signal.\n// Initialize the safepoint\nvoid jl_safepoint_init(void);\n// Start the GC, return `1` if the thread should be running the GC.\n// Otherwise, the thread will wait in this function until the GC finishes on\n// another thread and return `0`.\n// The caller should have saved the `gc_state` and set it to `WAITING`\n// before calling this function. If the calling thread is to run the GC,\n// it should also wait for the mutator threads to hit a safepoint **AFTER**\n// this function returns\nint jl_safepoint_start_gc(void);\n// Can only be called by the thread that have got a `1` return value from\n// `jl_safepoint_start_gc()`. This disables the safepoint (for GC,\n// the `mprotect` may not be removed if there's pending SIGINT) and wake\n// up waiting threads if there's any.\n// The caller should restore `gc_state` **AFTER** calling this function.\nvoid jl_safepoint_end_gc(void);\n// Wait for the GC to finish\n// This function does **NOT** modify the `gc_state` to inform the GC thread\n// The caller should set it **BEFORE** calling this function.\nvoid jl_safepoint_wait_gc(void);\n\n// Set pending sigint and enable the mechanisms to deliver the sigint.\nvoid jl_safepoint_enable_sigint(void);\n// If the safepoint is enabled to deliver sigint, disable it\n// so that the thread won't repeatedly trigger it in a sigatomic region\n// while not being able to actually throw the exception.\nvoid jl_safepoint_defer_sigint(void);\n// Clear the sigint pending flag and disable the mechanism to deliver sigint.\n// Return `1` if the sigint should be delivered and `0` if there's no sigint\n// to be delivered.\nint jl_safepoint_consume_sigint(void);\nvoid jl_wake_libuv(void);\n\n#ifdef JULIA_ENABLE_THREADING\njl_get_ptls_states_func jl_get_ptls_states_getter(void);\nstatic inline void jl_set_gc_and_wait(void)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    // reading own gc state doesn't need atomic ops since no one else\n    // should store to it.\n    int8_t state = jl_gc_state(ptls);\n    jl_atomic_store_release(&ptls->gc_state, JL_GC_STATE_WAITING);\n    jl_safepoint_wait_gc();\n    jl_atomic_store_release(&ptls->gc_state, state);\n}\n#endif\n\nvoid jl_dump_native(const char *bc_fname, const char *obj_fname, const char *sysimg_data, size_t sysimg_len);\nint32_t jl_get_llvm_gv(jl_value_t *p);\nint32_t jl_assign_functionID(/*llvm::Function*/void *function);\n// the first argument to jl_idtable_rehash is used to return a value\n// make sure it is rooted if it is used after the function returns\nJL_DLLEXPORT jl_array_t *jl_idtable_rehash(jl_array_t *a, size_t newsz);\n\nJL_DLLEXPORT jl_methtable_t *jl_new_method_table(jl_sym_t *name, jl_module_t *module);\njl_lambda_info_t *jl_get_specialization1(jl_tupletype_t *types);\nint jl_has_call_ambiguities(jl_tupletype_t *types, jl_method_t *m);\nJL_DLLEXPORT jl_lambda_info_t *jl_get_specialized(jl_method_t *m, jl_tupletype_t *types, jl_svec_t *sp, int allow_exec);\nJL_DLLEXPORT jl_value_t *jl_methtable_lookup(jl_methtable_t *mt, jl_tupletype_t *type);\nJL_DLLEXPORT jl_lambda_info_t *jl_specializations_get_linfo(jl_method_t *m, jl_tupletype_t *type, jl_svec_t *sparams, int allow_exec);\n\nuint32_t jl_module_next_counter(jl_module_t *m);\nvoid jl_fptr_to_llvm(jl_fptr_t fptr, jl_lambda_info_t *lam, int specsig);\njl_tupletype_t *arg_type_tuple(jl_value_t **args, size_t nargs);\n\nint jl_has_meta(jl_array_t *body, jl_sym_t *sym);\n\n// backtraces\ntypedef struct {\n    char *func_name;\n    char *file_name;\n    int line;\n    jl_lambda_info_t *linfo;\n    int fromC;\n    int inlined;\n} jl_frame_t;\n\n// Might be called from unmanaged thread\nuint64_t jl_getUnwindInfo(uint64_t dwBase);\n#ifdef _OS_WINDOWS_\n#include <dbghelp.h>\nJL_DLLEXPORT EXCEPTION_DISPOSITION __julia_personality(\n        PEXCEPTION_RECORD ExceptionRecord, void *EstablisherFrame, PCONTEXT ContextRecord, void *DispatcherContext);\nextern HANDLE hMainThread;\ntypedef CONTEXT bt_context_t;\n#if defined(_CPU_X86_64_)\ntypedef CONTEXT bt_cursor_t;\n#else\ntypedef struct {\n    STACKFRAME64 stackframe;\n    CONTEXT context;\n} bt_cursor_t;\n#endif\nextern volatile int jl_in_stackwalk;\n#else\n// This gives unwind only local unwinding options ==> faster code\n#  define UNW_LOCAL_ONLY\n#  include <libunwind.h>\ntypedef unw_context_t bt_context_t;\ntypedef unw_cursor_t bt_cursor_t;\n#  if (!defined(SYSTEM_LIBUNWIND) || UNW_VERSION_MAJOR > 1 ||   \\\n       (UNW_VERSION_MAJOR == 1 && UNW_VERSION_MINOR > 1))\n// Enable our memory manager only for libunwind with our patch or\n// on a newer release\n#    define JL_UNW_HAS_FORMAT_IP 1\n#  endif\n#endif\nsize_t rec_backtrace(uintptr_t *data, size_t maxsize);\nsize_t rec_backtrace_ctx(uintptr_t *data, size_t maxsize, bt_context_t *ctx);\n#ifdef LIBOSXUNWIND\nsize_t rec_backtrace_ctx_dwarf(uintptr_t *data, size_t maxsize, bt_context_t *ctx);\n#endif\nvoid jl_critical_error(int sig, bt_context_t *context, uintptr_t *bt_data, size_t *bt_size);\nJL_DLLEXPORT void jl_raise_debugger(void);\nint jl_getFunctionInfo(jl_frame_t **frames, uintptr_t pointer, int skipC, int noInline);\nJL_DLLEXPORT void jl_gdblookup(uintptr_t ip);\njl_value_t *jl_uncompress_ast_(jl_lambda_info_t*, jl_value_t*, int);\n// *to is NULL or malloc'd pointer, from is allowed to be NULL\nSTATIC_INLINE char *jl_copy_str(char **to, const char *from)\n{\n    if (!from) {\n        free(*to);\n        *to = NULL;\n        return NULL;\n    }\n    size_t len = strlen(from) + 1;\n    *to = (char*)realloc(*to, len);\n    memcpy(*to, from, len);\n    return *to;\n}\n\n// timers\n// Returns time in nanosec\nJL_DLLEXPORT uint64_t jl_hrtime(void);\n\n// libuv stuff:\nJL_DLLEXPORT extern void *jl_dl_handle;\nJL_DLLEXPORT extern void *jl_RTLD_DEFAULT_handle;\n#if defined(_OS_WINDOWS_)\nJL_DLLEXPORT extern void *jl_exe_handle;\nextern void *jl_ntdll_handle;\nextern void *jl_kernel32_handle;\nextern void *jl_crtdll_handle;\nextern void *jl_winsock_handle;\n#endif\n\nvoid *jl_get_library(const char *f_lib);\nJL_DLLEXPORT void *jl_load_and_lookup(const char *f_lib, const char *f_name,\n                                      void **hnd);\nconst char *jl_dlfind_win32(const char *name);\nvoid *jl_dlopen_soname(const char *pfx, size_t n, unsigned flags);\n\n// libuv wrappers:\nJL_DLLEXPORT int jl_fs_rename(const char *src_path, const char *dst_path);\n\n#if defined(_CPU_X86_) || defined(_CPU_X86_64_)\n#define HAVE_CPUID\n#endif\n\n#ifdef SEGV_EXCEPTION\nextern JL_DLLEXPORT jl_value_t *jl_segv_exception;\n#endif\n\n// -- Runtime intrinsics -- //\nconst char *jl_intrinsic_name(int f);\n\nJL_DLLEXPORT jl_value_t *jl_reinterpret(jl_value_t *ty, jl_value_t *v);\nJL_DLLEXPORT jl_value_t *jl_pointerref(jl_value_t *p, jl_value_t *i, jl_value_t *align);\nJL_DLLEXPORT jl_value_t *jl_pointerset(jl_value_t *p, jl_value_t *x, jl_value_t *align, jl_value_t *i);\n\nJL_DLLEXPORT jl_value_t *jl_neg_int(jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_add_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_sub_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_mul_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_sdiv_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_udiv_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_srem_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_urem_int(jl_value_t *a, jl_value_t *b);\n\nJL_DLLEXPORT jl_value_t *jl_neg_float(jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_add_float(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_sub_float(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_mul_float(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_div_float(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_rem_float(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_fma_float(jl_value_t *a, jl_value_t *b, jl_value_t *c);\nJL_DLLEXPORT jl_value_t *jl_muladd_float(jl_value_t *a, jl_value_t *b, jl_value_t *c);\n\nJL_DLLEXPORT jl_value_t *jl_eq_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_ne_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_slt_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_ult_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_sle_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_ule_int(jl_value_t *a, jl_value_t *b);\n\nJL_DLLEXPORT jl_value_t *jl_eq_float(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_ne_float(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_lt_float(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_le_float(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_fpiseq(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_fpislt(jl_value_t *a, jl_value_t *b);\n\nJL_DLLEXPORT jl_value_t *jl_not_int(jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_and_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_or_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_xor_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_shl_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_lshr_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_ashr_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_bswap_int(jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_ctpop_int(jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_ctlz_int(jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_cttz_int(jl_value_t *a);\n\nJL_DLLEXPORT jl_value_t *jl_sext_int(jl_value_t *ty, jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_zext_int(jl_value_t *ty, jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_trunc_int(jl_value_t *ty, jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_sitofp(jl_value_t *ty, jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_uitofp(jl_value_t *ty, jl_value_t *a);\n\nJL_DLLEXPORT jl_value_t *jl_fptoui(jl_value_t *ty, jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_fptosi(jl_value_t *ty, jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_fptrunc(jl_value_t *ty, jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_fpext(jl_value_t *ty, jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_fptoui_auto(jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_fptosi_auto(jl_value_t *a);\n\nJL_DLLEXPORT jl_value_t *jl_checked_fptoui(jl_value_t *ty, jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_checked_fptosi(jl_value_t *ty, jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_checked_trunc_sint(jl_value_t *ty, jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_checked_trunc_uint(jl_value_t *ty, jl_value_t *a);\n\nJL_DLLEXPORT jl_value_t *jl_check_top_bit(jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_checked_sadd_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_checked_uadd_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_checked_ssub_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_checked_usub_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_checked_smul_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_checked_umul_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_checked_sdiv_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_checked_udiv_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_checked_srem_int(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_checked_urem_int(jl_value_t *a, jl_value_t *b);\n\nJL_DLLEXPORT jl_value_t *jl_ceil_llvm(jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_floor_llvm(jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_trunc_llvm(jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_rint_llvm(jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_sqrt_llvm(jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_powi_llvm(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_abs_float(jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_copysign_float(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_flipsign_int(jl_value_t *a, jl_value_t *b);\n\nJL_DLLEXPORT jl_value_t *jl_select_value(jl_value_t *isfalse, jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_arraylen(jl_value_t *a);\nint jl_array_store_unboxed(jl_value_t *el_type);\nint jl_array_isdefined(jl_value_t **args, int nargs);\nJL_DLLEXPORT jl_value_t *(jl_array_data_owner)(jl_array_t *a);\n\n// -- synchronization utilities -- //\n\nextern jl_mutex_t typecache_lock;\nextern jl_mutex_t codegen_lock;\nextern jl_mutex_t safepoint_lock;\n\n// -- gc.c -- //\n\n#if defined(__APPLE__) && defined(JULIA_ENABLE_THREADING)\nvoid jl_mach_gc_end(void);\n#endif\n\n#if defined(_OS_WINDOWS_)\nSTATIC_INLINE void *jl_malloc_aligned(size_t sz, size_t align)\n{\n    return _aligned_malloc(sz ? sz : 1, align);\n}\nSTATIC_INLINE void *jl_realloc_aligned(void *p, size_t sz, size_t oldsz,\n                                       size_t align)\n{\n    (void)oldsz;\n    return _aligned_realloc(p, sz ? sz : 1, align);\n}\nSTATIC_INLINE void jl_free_aligned(void *p)\n{\n    _aligned_free(p);\n}\n#else\nSTATIC_INLINE void *jl_malloc_aligned(size_t sz, size_t align)\n{\n#if defined(_P64) || defined(__APPLE__)\n    if (align <= 16)\n        return malloc(sz);\n#endif\n    void *ptr;\n    if (posix_memalign(&ptr, align, sz))\n        return NULL;\n    return ptr;\n}\nSTATIC_INLINE void *jl_realloc_aligned(void *d, size_t sz, size_t oldsz,\n                                       size_t align)\n{\n#if defined(_P64) || defined(__APPLE__)\n    if (align <= 16)\n        return realloc(d, sz);\n#endif\n    void *b = jl_malloc_aligned(sz, align);\n    if (b != NULL) {\n        memcpy(b, d, oldsz > sz ? sz : oldsz);\n        free(d);\n    }\n    return b;\n}\nSTATIC_INLINE void jl_free_aligned(void *p)\n{\n    free(p);\n}\n#endif\n\n// -- typemap.c -- //\n\nSTATIC_INLINE int is_kind(jl_value_t *v)\n{\n    return (v==(jl_value_t*)jl_uniontype_type ||\n            v==(jl_value_t*)jl_datatype_type ||\n            v==(jl_value_t*)jl_typector_type);\n}\n\n// a descriptor of a jl_typemap_t that gets\n// passed around as self-documentation of the parameters of the type\nstruct jl_typemap_info {\n    int8_t unsorted; // whether this should be unsorted\n    jl_datatype_t **jl_contains; // the type that is being put in this\n};\n\njl_typemap_entry_t *jl_typemap_insert(union jl_typemap_t *cache, jl_value_t *parent,\n                                      jl_tupletype_t *type, jl_svec_t *tvars,\n                                      jl_tupletype_t *simpletype, jl_svec_t *guardsigs,\n                                      jl_value_t *newvalue, int8_t offs,\n                                      const struct jl_typemap_info *tparams,\n                                      jl_value_t **overwritten);\n\njl_typemap_entry_t *jl_typemap_assoc_by_type(union jl_typemap_t ml_or_cache, jl_tupletype_t *types, jl_svec_t **penv,\n        int8_t subtype_inexact__sigseq_useenv, int8_t subtype, int8_t offs);\nstatic jl_typemap_entry_t *const INEXACT_ENTRY = (jl_typemap_entry_t*)(uintptr_t)-1;\njl_typemap_entry_t *jl_typemap_level_assoc_exact(jl_typemap_level_t *cache, jl_value_t **args, size_t n, int8_t offs);\njl_typemap_entry_t *jl_typemap_entry_assoc_exact(jl_typemap_entry_t *mn, jl_value_t **args, size_t n);\nSTATIC_INLINE jl_typemap_entry_t *jl_typemap_assoc_exact(union jl_typemap_t ml_or_cache, jl_value_t **args, size_t n, int8_t offs)\n{\n    // NOTE: This function is a huge performance hot spot!!\n    if (jl_typeof(ml_or_cache.unknown) == (jl_value_t*)jl_typemap_entry_type) {\n        return jl_typemap_entry_assoc_exact(ml_or_cache.leaf, args, n);\n    }\n    else if (jl_typeof(ml_or_cache.unknown) == (jl_value_t*)jl_typemap_level_type) {\n        return jl_typemap_level_assoc_exact(ml_or_cache.node, args, n, offs);\n    }\n    return NULL;\n}\n\ntypedef int (*jl_typemap_visitor_fptr)(jl_typemap_entry_t *l, void *closure);\nint jl_typemap_visitor(union jl_typemap_t a, jl_typemap_visitor_fptr fptr, void *closure);\n\nstruct typemap_intersection_env;\ntypedef int (*jl_typemap_intersection_visitor_fptr)(jl_typemap_entry_t *l, struct typemap_intersection_env *closure);\nstruct typemap_intersection_env {\n    // input values\n    jl_typemap_intersection_visitor_fptr fptr; // fptr to call on a match\n    jl_value_t *type; // type to match\n    jl_value_t *va; // the tparam0 for the vararg in type, if applicable (or NULL)\n    // output values\n    jl_value_t *ti; // intersection type\n    jl_svec_t *env; // intersection env (initialize to null to perform intersection without an environment)\n};\nint jl_typemap_intersection_visitor(union jl_typemap_t a, int offs, struct typemap_intersection_env *closure);\n\nint sigs_eq(jl_value_t *a, jl_value_t *b, int useenv);\n\njl_value_t *jl_lookup_match(jl_value_t *a, jl_value_t *b, jl_svec_t **penv, jl_svec_t *tvars);\n\nunsigned jl_special_vector_alignment(size_t nfields, jl_value_t *field_type);\n\nvoid register_eh_frames(uint8_t *Addr, size_t Size);\nvoid deregister_eh_frames(uint8_t *Addr, size_t Size);\n\nSTATIC_INLINE void *jl_get_frame_addr(void)\n{\n#ifdef __GNUC__\n    return __builtin_frame_address(0);\n#else\n    void *dummy = NULL;\n    // The mask is to suppress the compiler warning about returning\n    // address of local variable\n    return (void*)((uintptr_t)&dummy & ~(uintptr_t)15);\n#endif\n}\n\nJL_DLLEXPORT jl_array_t *jl_array_cconvert_cstring(jl_array_t *a);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/julia.h": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n#ifndef JULIA_H\n#define JULIA_H\n\n//** Configuration options that affect the Julia ABI **//\n// if this is not defined, only individual dimension sizes are\n// stored and not total length, to save space.\n#define STORE_ARRAY_LEN\n//** End Configuration options **//\n\n#include \"libsupport.h\"\n#include <stdint.h>\n#include <string.h>\n\n#include \"htable.h\"\n#include \"arraylist.h\"\n\n#include <setjmp.h>\n#ifndef _OS_WINDOWS_\n#  define jl_jmp_buf sigjmp_buf\n#  if defined(_CPU_ARM_) || defined(_CPU_PPC_)\n#    define MAX_ALIGN 8\n#  elif defined(_CPU_AARCH64_)\n// int128 is 16 bytes aligned on aarch64\n#    define MAX_ALIGN 16\n#  else\n#    define MAX_ALIGN sizeof(void*)\n#  endif\n#else\n#  define jl_jmp_buf jmp_buf\n#  include <malloc.h> //for _resetstkoflw\n#  define MAX_ALIGN 8\n#endif\n\n#ifdef _P64\n#define NWORDS(sz) (((sz)+7)>>3)\n#else\n#define NWORDS(sz) (((sz)+3)>>2)\n#endif\n\n#if defined(__GNUC__)\n#  define JL_NORETURN __attribute__ ((noreturn))\n#  define JL_CONST_FUNC __attribute__((const))\n#elif defined(_COMPILER_MICROSOFT_)\n#  define JL_NORETURN __declspec(noreturn)\n// This is the closest I can find for __attribute__((const))\n#  define JL_CONST_FUNC __declspec(noalias)\n#else\n#  define JL_NORETURN\n#  define JL_CONST_FUNC\n#endif\n\n#define container_of(ptr, type, member) \\\n    ((type *) ((char *)(ptr) - offsetof(type, member)))\n\ntypedef struct _jl_taggedvalue_t jl_taggedvalue_t;\n\n#include <julia_threads.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// core data types ------------------------------------------------------------\n\n// the common fields are hidden before the pointer, but the following macro is\n// used to indicate which types below are subtypes of jl_value_t\n#define JL_DATA_TYPE\n\ntypedef struct _jl_value_t jl_value_t;\n\nstruct _jl_taggedvalue_bits {\n    uintptr_t gc:2;\n};\n\nstruct _jl_taggedvalue_t {\n    union {\n        uintptr_t header;\n        jl_taggedvalue_t *next;\n        jl_value_t *type; // 16-byte aligned\n        struct _jl_taggedvalue_bits bits;\n    };\n    // jl_value_t value;\n};\n\n#define jl_astaggedvalue(v)                                             \\\n    ((jl_taggedvalue_t*)((char*)(v) - sizeof(jl_taggedvalue_t)))\n#define jl_valueof(v)                                           \\\n    ((jl_value_t*)((char*)(v) + sizeof(jl_taggedvalue_t)))\n#define jl_typeof(v)                                                    \\\n    ((jl_value_t*)(jl_astaggedvalue(v)->header & ~(uintptr_t)15))\nstatic inline void jl_set_typeof(void *v, void *t)\n{\n    // Do not call this on a value that is already initialized.\n    jl_taggedvalue_t *tag = jl_astaggedvalue(v);\n    tag->type = (jl_value_t*)t;\n}\n#define jl_typeis(v,t) (jl_typeof(v)==(jl_value_t*)(t))\n\n// Symbols are interned strings (hash-consed) stored as an invasive binary tree.\n// The string data is nul-terminated and hangs off the end of the struct.\ntypedef struct _jl_sym_t {\n    JL_DATA_TYPE\n    struct _jl_sym_t *left;\n    struct _jl_sym_t *right;\n    uintptr_t hash;    // precomputed hash value\n    // JL_ATTRIBUTE_ALIGN_PTRSIZE(char name[]);\n} jl_sym_t;\n\n// A numbered SSA value, for optimized code analysis and generation\n// the `id` is a unique, small number\ntypedef struct _jl_ssavalue_t {\n    JL_DATA_TYPE\n    ssize_t id;\n} jl_ssavalue_t;\n\n// A SimpleVector is an immutable pointer array\n// Data is stored at the end of this variable-length struct.\ntypedef struct {\n    JL_DATA_TYPE\n    size_t length;\n    // pointer size aligned\n    // jl_value_t *data[];\n} jl_svec_t;\n\ntypedef struct {\n    /*\n      how - allocation style\n      0 = data is inlined, or a foreign pointer we don't manage\n      1 = julia-allocated buffer that needs to be marked\n      2 = malloc-allocated pointer this array object manages\n      3 = has a pointer to the Array that owns the data\n    */\n    uint16_t how:2;\n    uint16_t ndims:10;\n    uint16_t pooled:1;\n    uint16_t ptrarray:1;  // representation is pointer array\n    uint16_t isshared:1;  // data is shared by multiple Arrays\n    uint16_t isaligned:1; // data allocated with memalign\n} jl_array_flags_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    void *data;\n#ifdef STORE_ARRAY_LEN\n    size_t length;\n#endif\n    jl_array_flags_t flags;\n    uint16_t elsize;\n    uint32_t offset;  // for 1-d only. does not need to get big.\n    size_t nrows;\n    union {\n        // 1d\n        size_t maxsize;\n        // Nd\n        size_t ncols;\n    };\n    // other dim sizes go here for ndims > 2\n\n    // followed by alignment padding and inline data, or owner pointer\n} jl_array_t;\n\n// compute # of extra words needed to store dimensions\nSTATIC_INLINE int jl_array_ndimwords(uint32_t ndims)\n{\n    return (ndims < 3 ? 0 : ndims-2);\n}\n\ntypedef struct _jl_datatype_t jl_tupletype_t;\nstruct _jl_lambda_info_t;\n\n// TypeMap is an implicitly defined type\n// that can consist of any of the following nodes:\n//   typedef TypeMap Union{TypeMapLevel, TypeMapEntry, Void}\n// it forms a roughly tree-shaped structure, consisting of nodes of TypeMapLevels\n// which split the tree when possible, for example based on the key into the tuple type at `offs`\n// when key is a leaftype, (but only when the tree has enough entries for this to be\n// more efficient than storing them sorted linearly)\n// otherwise the leaf entries are stored sorted, linearly\nunion jl_typemap_t {\n    struct _jl_typemap_level_t *node;\n    struct _jl_typemap_entry_t *leaf;\n    struct _jl_value_t *unknown; // nothing\n};\n\n// \"jlcall\" calling convention signatures.\n// This defines the default ABI used by compiled julia functions.\ntypedef jl_value_t *(*jl_fptr_t)(jl_value_t*, jl_value_t**, uint32_t);\ntypedef jl_value_t *(*jl_fptr_sparam_t)(jl_svec_t*, jl_value_t*, jl_value_t**, uint32_t);\ntypedef jl_value_t *(*jl_fptr_linfo_t)(struct _jl_lambda_info_t*, jl_value_t**, uint32_t, jl_svec_t*);\n\ntypedef struct _jl_llvm_functions_t {\n    void *functionObject;     // jlcall llvm Function\n    void *specFunctionObject; // specialized llvm Function\n} jl_llvm_functions_t;\n\n// This type describes a single method definition, and stores data\n// shared by the specializations of a function.\ntypedef struct _jl_method_t {\n    JL_DATA_TYPE\n    jl_sym_t *name;  // for error reporting\n    struct _jl_module_t *module;\n    jl_sym_t *file;\n    int32_t line;\n\n    // method's type signature. partly redundant with lambda_template->specTypes\n    jl_tupletype_t *sig;\n    // bound type variables (static parameters). redundant with TypeMapEntry->tvars\n    jl_svec_t *tvars;\n    // list of potentially-ambiguous methods (nothing = none, Vector{Any} of Methods otherwise)\n    jl_value_t *ambig;\n\n    // table of all argument types for which we've inferred or compiled this code\n    union jl_typemap_t specializations;\n\n    // the AST template (or, for isstaged, code for the generator)\n    struct _jl_lambda_info_t *lambda_template;\n    jl_array_t *roots;  // pointers in generated code (shared to reduce memory)\n\n    // cache of specializations of this method for invoke(), i.e.\n    // cases where this method was called even though it was not necessarily\n    // the most specific for the argument types.\n    union jl_typemap_t invokes;\n\n    int32_t called;  // bit flags: whether each of the first 8 arguments is called\n    int8_t isstaged;\n    // if there are intrinsic calls, sparams are probably required to compile successfully,\n    // and so unspecialized will be created for each linfo instead of using linfo->def->template\n    // 0 = no, 1 = yes, 2 = not yet known\n    uint8_t needs_sparam_vals_ducttape;\n    uint8_t traced;\n\n// hidden fields:\n    // lock for modifications to the method\n    jl_mutex_t writelock;\n} jl_method_t;\n\n// This holds data for a single executable function body:\n// code in Julia IR, static parameters, and (if it has been compiled)\n// a function pointer.\ntypedef struct _jl_lambda_info_t {\n    JL_DATA_TYPE\n    jl_value_t *rettype;\n    jl_svec_t *sparam_syms; // sparams is a vector of values indexed by symbols\n    jl_svec_t *sparam_vals;\n    jl_tupletype_t *specTypes;  // argument types this was specialized for\n    jl_value_t *code;  // compressed uint8 array, or Any array of statements\n    jl_value_t *slottypes;\n    jl_value_t *ssavaluetypes;  // types of ssa values\n    jl_array_t *slotnames; // names of local variables\n    jl_array_t *slotflags;  // local var bit flags\n    struct _jl_lambda_info_t *unspecialized_ducttape; // if template can't be compiled due to intrinsics, an un-inferred executable copy may get stored here\n    jl_method_t *def; // method this is specialized from, (null if this is a toplevel thunk)\n    jl_value_t *constval;  // value of the function if jlcall_api==2\n    int32_t nargs;\n    int8_t isva;\n    int8_t inferred;\n    int8_t pure;\n    int8_t inlineable;\n    int8_t inInference; // flags to tell if inference is running on this function\n    int8_t inCompile; // flag to tell if codegen is running on this function\n    int8_t jlcall_api; // the c-abi for fptr; 0 = jl_fptr_t, 1 = jl_fptr_sparam_t, 2 = constval\n    int8_t compile_traced; // if set will notify callback if this linfo is compiled\n    jl_fptr_t fptr; // jlcall entry point\n\n// hidden fields:\n    // On the old JIT, handles to all Functions generated for this linfo\n    // For the new JITs, handles to declarations in the shadow module\n    // with the same name as the generated functions for this linfo, suitable\n    // for referencing in LLVM IR\n    jl_llvm_functions_t functionObjectsDecls;\n} jl_lambda_info_t;\n\n// all values are callable as Functions\ntypedef jl_value_t jl_function_t;\n\n// a TypeConstructor (typealias)\n// for example, Vector{T}:\n//   body is the Vector{T} <: Type\n//   parameters is the set {T}, the bound TypeVars in body\ntypedef struct {\n    JL_DATA_TYPE\n    jl_svec_t *parameters;\n    jl_value_t *body;\n} jl_typector_t;\n\n// represents the \"name\" part of a DataType, describing the syntactic structure\n// of a type and storing all data common to different instantiations of the type,\n// including a cache for hash-consed allocation of DataType objects.\ntypedef struct {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    struct _jl_module_t *module;\n    jl_svec_t *names;  // field names\n    // if this is the name of a parametric type, this field points to the\n    // original type.\n    // a type alias, for example, might make a type constructor that is\n    // not the original.\n    jl_value_t *primary;\n    jl_svec_t *cache;        // sorted array\n    jl_svec_t *linearcache;  // unsorted array\n    intptr_t hash;\n    struct _jl_methtable_t *mt;\n} jl_typename_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_svec_t *types;\n} jl_uniontype_t;\n\n// in little-endian, isptr is always the first bit, avoiding the need for a branch in computing isptr\ntypedef struct {\n    uint8_t isptr:1;\n    uint8_t size:7;\n    uint8_t offset;   // offset relative to data start, excluding type tag\n} jl_fielddesc8_t;\n\ntypedef struct {\n    uint16_t isptr:1;\n    uint16_t size:15;\n    uint16_t offset;   // offset relative to data start, excluding type tag\n} jl_fielddesc16_t;\n\ntypedef struct {\n    uint32_t isptr:1;\n    uint32_t size:31;\n    uint32_t offset;   // offset relative to data start, excluding type tag\n} jl_fielddesc32_t;\n\ntypedef struct {\n    uint32_t nfields;\n    uint32_t alignment : 28;  // strictest alignment over all fields\n    uint32_t haspadding : 1;  // has internal undefined bytes\n    uint32_t pointerfree : 1; // has any julia gc pointers\n    uint32_t fielddesc_type : 2; // 0 -> 8, 1 -> 16, 2 -> 32\n    // union {\n    //     jl_fielddesc8_t field8[];\n    //     jl_fielddesc16_t field16[];\n    //     jl_fielddesc32_t field32[];\n    // };\n} jl_datatype_layout_t;\n\ntypedef struct _jl_datatype_t {\n    JL_DATA_TYPE\n    jl_typename_t *name;\n    struct _jl_datatype_t *super;\n    jl_svec_t *parameters;\n    jl_svec_t *types;\n    jl_value_t *instance;  // for singletons\n    const jl_datatype_layout_t *layout;\n    int32_t size; // TODO: move to _jl_datatype_layout_t\n    int32_t ninitialized;\n    uint32_t uid;\n    uint8_t abstract;\n    uint8_t mutabl;\n    // memoized properties\n    void *struct_decl;  //llvm::Type*\n    void *ditype; // llvm::MDNode* to be used as llvm::DIType(ditype)\n    int32_t depth;\n    int8_t hastypevars; // bound\n    int8_t haswildcard; // unbound\n    int8_t isleaftype;\n} jl_datatype_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    jl_value_t *lb;   // lower bound\n    jl_value_t *ub;   // upper bound\n    uint8_t bound;    // part of a constraint environment\n} jl_tvar_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_value_t *value;\n} jl_weakref_t;\n\ntypedef struct {\n    // not first-class\n    jl_sym_t *name;\n    jl_value_t *value;\n    jl_value_t *globalref;  // cached GlobalRef for this binding\n    struct _jl_module_t *owner;  // for individual imported bindings\n    unsigned constp:1;\n    unsigned exportp:1;\n    unsigned imported:1;\n    unsigned deprecated:1;\n} jl_binding_t;\n\ntypedef struct _jl_module_t {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    struct _jl_module_t *parent;\n    htable_t bindings;\n    arraylist_t usings;  // modules with all bindings potentially imported\n    uint8_t istopmod;\n    uint64_t uuid;\n    uint32_t counter;\n} jl_module_t;\n\n// one Type-to-Value entry\ntypedef struct _jl_typemap_entry_t {\n    JL_DATA_TYPE\n    struct _jl_typemap_entry_t *next; // invasive linked list\n    jl_tupletype_t *sig; // the type signature for this entry\n    jl_svec_t *tvars; // the bound type variables for sig\n    jl_tupletype_t *simplesig; // a simple signature for fast rejection\n    jl_svec_t *guardsigs;\n    union {\n        jl_value_t *value;\n        jl_lambda_info_t *linfo; // [nullable] for guard entries\n        jl_method_t *method;\n    } func;\n    // memoized properties of sig:\n    int8_t isleafsig; // isleaftype(sig) & !any(isType, sig) : unsorted and very fast\n    int8_t issimplesig; // all(isleaftype | isAny | isType | isVararg, sig) : sorted and fast\n    int8_t va; // isVararg(sig)\n} jl_typemap_entry_t;\n\n// one level in a TypeMap tree\n// indexed by key if it is a sublevel in an array\nstruct jl_ordereddict_t {\n    jl_array_t *indexes; // Array{Int{8,16,32}}\n    jl_array_t *values; // Array{union jl_typemap_t}\n};\ntypedef struct _jl_typemap_level_t {\n    JL_DATA_TYPE\n    struct jl_ordereddict_t arg1;\n    struct jl_ordereddict_t targ;\n    jl_typemap_entry_t *linear; // union jl_typemap_t (but no more levels)\n    union jl_typemap_t any; // type at offs is Any\n    jl_value_t *key; // [nullable]\n} jl_typemap_level_t;\n\n// contains the TypeMap for one Type\ntypedef struct _jl_methtable_t {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    union jl_typemap_t defs;\n    union jl_typemap_t cache;\n    intptr_t max_args;  // max # of non-vararg arguments in a signature\n    jl_value_t *kwsorter;  // keyword argument sorter function\n    jl_module_t *module; // used for incremental serialization to locate original binding\n    jl_mutex_t writelock;\n} jl_methtable_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_sym_t *head;\n    jl_array_t *args;\n    jl_value_t *etype;\n} jl_expr_t;\n\n// constants and type objects -------------------------------------------------\n\nextern JL_DLLEXPORT jl_datatype_t *jl_any_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_type_type;\nextern JL_DLLEXPORT jl_tvar_t     *jl_typetype_tvar;\nextern JL_DLLEXPORT jl_datatype_t *jl_typetype_type;\nextern JL_DLLEXPORT jl_value_t    *jl_ANY_flag;\nextern JL_DLLEXPORT jl_datatype_t *jl_typename_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_typector_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_sym_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_symbol_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_ssavalue_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_abstractslot_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_slotnumber_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_typedslot_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_simplevector_type;\nextern JL_DLLEXPORT jl_typename_t *jl_tuple_typename;\nextern JL_DLLEXPORT jl_typename_t *jl_vecelement_typename;\nextern JL_DLLEXPORT jl_datatype_t *jl_anytuple_type;\n#define jl_tuple_type jl_anytuple_type\nextern JL_DLLEXPORT jl_datatype_t *jl_anytuple_type_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_vararg_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_tvar_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_task_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_function_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_builtin_type;\n\nextern JL_DLLEXPORT jl_datatype_t *jl_uniontype_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_datatype_type;\n\nextern JL_DLLEXPORT jl_value_t *jl_bottom_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_lambda_info_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_method_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_module_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_abstractarray_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_densearray_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_array_type;\nextern JL_DLLEXPORT jl_typename_t *jl_array_typename;\nextern JL_DLLEXPORT jl_datatype_t *jl_weakref_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_string_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_errorexception_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_argumenterror_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_loaderror_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_initerror_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_typeerror_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_methoderror_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_undefvarerror_type;\nextern JL_DLLEXPORT jl_value_t *jl_stackovf_exception;\nextern JL_DLLEXPORT jl_value_t *jl_memory_exception;\nextern JL_DLLEXPORT jl_value_t *jl_readonlymemory_exception;\nextern JL_DLLEXPORT jl_value_t *jl_diverror_exception;\nextern JL_DLLEXPORT jl_value_t *jl_domain_exception;\nextern JL_DLLEXPORT jl_value_t *jl_overflow_exception;\nextern JL_DLLEXPORT jl_value_t *jl_inexact_exception;\nextern JL_DLLEXPORT jl_value_t *jl_undefref_exception;\nextern JL_DLLEXPORT jl_value_t *jl_interrupt_exception;\nextern JL_DLLEXPORT jl_datatype_t *jl_boundserror_type;\nextern JL_DLLEXPORT jl_value_t *jl_an_empty_vec_any;\n\nextern JL_DLLEXPORT jl_datatype_t *jl_bool_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_char_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_int8_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_uint8_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_int16_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_uint16_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_int32_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_uint32_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_int64_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_uint64_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_float16_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_float32_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_float64_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_floatingpoint_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_number_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_void_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_complex_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_signed_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_voidpointer_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_pointer_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_ref_type;\n\nextern JL_DLLEXPORT jl_value_t *jl_array_uint8_type;\nextern JL_DLLEXPORT jl_value_t *jl_array_any_type;\nextern JL_DLLEXPORT jl_value_t *jl_array_symbol_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_expr_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_globalref_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_linenumbernode_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_labelnode_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_gotonode_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_quotenode_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_newvarnode_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_intrinsic_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_methtable_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_typemap_level_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_typemap_entry_type;\n\nextern JL_DLLEXPORT jl_svec_t *jl_emptysvec;\nextern JL_DLLEXPORT jl_value_t *jl_emptytuple;\nextern JL_DLLEXPORT jl_value_t *jl_true;\nextern JL_DLLEXPORT jl_value_t *jl_false;\nextern JL_DLLEXPORT jl_value_t *jl_nothing;\n\n// some important symbols\nextern jl_sym_t *call_sym;    extern jl_sym_t *invoke_sym;\nextern jl_sym_t *empty_sym;   extern jl_sym_t *body_sym;\nextern jl_sym_t *dots_sym;    extern jl_sym_t *vararg_sym;\nextern jl_sym_t *quote_sym;   extern jl_sym_t *newvar_sym;\nextern jl_sym_t *top_sym;     extern jl_sym_t *dot_sym;\nextern jl_sym_t *line_sym;    extern jl_sym_t *toplevel_sym;\nextern jl_sym_t *core_sym;    extern jl_sym_t *globalref_sym;\nextern JL_DLLEXPORT jl_sym_t *jl_incomplete_sym;\nextern jl_sym_t *error_sym;   extern jl_sym_t *amp_sym;\nextern jl_sym_t *module_sym;  extern jl_sym_t *colons_sym;\nextern jl_sym_t *export_sym;  extern jl_sym_t *import_sym;\nextern jl_sym_t *importall_sym; extern jl_sym_t *using_sym;\nextern jl_sym_t *goto_sym;    extern jl_sym_t *goto_ifnot_sym;\nextern jl_sym_t *label_sym;   extern jl_sym_t *return_sym;\nextern jl_sym_t *lambda_sym;  extern jl_sym_t *assign_sym;\nextern jl_sym_t *method_sym;  extern jl_sym_t *slot_sym;\nextern jl_sym_t *enter_sym;   extern jl_sym_t *leave_sym;\nextern jl_sym_t *exc_sym;     extern jl_sym_t *new_sym;\nextern jl_sym_t *compiler_temp_sym;\nextern jl_sym_t *const_sym;   extern jl_sym_t *thunk_sym;\nextern jl_sym_t *anonymous_sym;  extern jl_sym_t *underscore_sym;\nextern jl_sym_t *abstracttype_sym; extern jl_sym_t *bitstype_sym;\nextern jl_sym_t *compositetype_sym;\nextern jl_sym_t *global_sym; extern jl_sym_t *unused_sym;\nextern jl_sym_t *boundscheck_sym; extern jl_sym_t *inbounds_sym;\nextern jl_sym_t *copyast_sym; extern jl_sym_t *fastmath_sym;\nextern jl_sym_t *pure_sym; extern jl_sym_t *simdloop_sym;\nextern jl_sym_t *meta_sym; extern jl_sym_t *list_sym;\nextern jl_sym_t *inert_sym; extern jl_sym_t *static_parameter_sym;\nextern jl_sym_t *polly_sym; extern jl_sym_t *inline_sym;\n\n// gc -------------------------------------------------------------------------\n\ntypedef struct _jl_gcframe_t {\n    size_t nroots;\n    struct _jl_gcframe_t *prev;\n    // actual roots go here\n} jl_gcframe_t;\n\n// NOTE: it is the caller's responsibility to make sure arguments are\n// rooted such that the gc can see them on the stack.\n// `foo(f(), g())` is not safe,\n// since the result of `f()` is not rooted during the call to `g()`,\n// and the arguments to foo are not gc-protected during the call to foo.\n// foo can't do anything about it, so the caller must do:\n// jl_value_t *x=NULL, *y=NULL; JL_GC_PUSH2(&x, &y);\n// x = f(); y = g(); foo(x, y)\n\n#define jl_pgcstack (jl_get_ptls_states()->pgcstack)\n\n#define JL_GC_PUSH1(arg1)                                                 \\\n  void *__gc_stkf[] = {(void*)3, jl_pgcstack, arg1};                      \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH2(arg1, arg2)                                           \\\n  void *__gc_stkf[] = {(void*)5, jl_pgcstack, arg1, arg2};                \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH3(arg1, arg2, arg3)                                     \\\n  void *__gc_stkf[] = {(void*)7, jl_pgcstack, arg1, arg2, arg3};          \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH4(arg1, arg2, arg3, arg4)                               \\\n  void *__gc_stkf[] = {(void*)9, jl_pgcstack, arg1, arg2, arg3, arg4};    \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH5(arg1, arg2, arg3, arg4, arg5)                               \\\n  void *__gc_stkf[] = {(void*)11, jl_pgcstack, arg1, arg2, arg3, arg4, arg5};    \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSHARGS(rts_var,n)                               \\\n  rts_var = ((jl_value_t**)alloca(((n)+2)*sizeof(jl_value_t*)))+2;    \\\n  ((void**)rts_var)[-2] = (void*)(((size_t)(n))<<1);                  \\\n  ((void**)rts_var)[-1] = jl_pgcstack;                          \\\n  memset((void*)rts_var, 0, (n)*sizeof(jl_value_t*));           \\\n  jl_pgcstack = (jl_gcframe_t*)&(((void**)rts_var)[-2])\n\n#define JL_GC_POP() (jl_pgcstack = jl_pgcstack->prev)\n\nJL_DLLEXPORT int jl_gc_enable(int on);\nJL_DLLEXPORT int jl_gc_is_enabled(void);\nJL_DLLEXPORT int64_t jl_gc_total_bytes(void);\nJL_DLLEXPORT uint64_t jl_gc_total_hrtime(void);\nJL_DLLEXPORT int64_t jl_gc_diff_total_bytes(void);\n\nJL_DLLEXPORT void jl_gc_collect(int);\n\nJL_DLLEXPORT void jl_gc_add_finalizer(jl_value_t *v, jl_function_t *f);\nJL_DLLEXPORT void jl_finalize(jl_value_t *o);\nJL_DLLEXPORT jl_weakref_t *jl_gc_new_weakref(jl_value_t *value);\nJL_DLLEXPORT jl_value_t *jl_gc_alloc_0w(void);\nJL_DLLEXPORT jl_value_t *jl_gc_alloc_1w(void);\nJL_DLLEXPORT jl_value_t *jl_gc_alloc_2w(void);\nJL_DLLEXPORT jl_value_t *jl_gc_alloc_3w(void);\nJL_DLLEXPORT jl_value_t *jl_gc_allocobj(size_t sz);\n\nJL_DLLEXPORT void jl_clear_malloc_data(void);\n\n// GC write barriers\nJL_DLLEXPORT void jl_gc_queue_root(jl_value_t *root); // root isa jl_value_t*\n\n// Do NOT put a safepoint here\nSTATIC_INLINE void jl_gc_wb(void *parent, void *ptr)\n{\n    // parent and ptr isa jl_value_t*\n    if (__unlikely(jl_astaggedvalue(parent)->bits.gc == 3 &&\n                   (jl_astaggedvalue(ptr)->bits.gc & 1) == 0))\n        jl_gc_queue_root((jl_value_t*)parent);\n}\n\nSTATIC_INLINE void jl_gc_wb_back(void *ptr) // ptr isa jl_value_t*\n{\n    // if ptr is old\n    if (__unlikely(jl_astaggedvalue(ptr)->bits.gc == 3)) {\n        jl_gc_queue_root((jl_value_t*)ptr);\n    }\n}\n\nJL_DLLEXPORT void *jl_gc_managed_malloc(size_t sz);\nJL_DLLEXPORT void *jl_gc_managed_realloc(void *d, size_t sz, size_t oldsz,\n                                         int isaligned, jl_value_t *owner);\n\n// object accessors -----------------------------------------------------------\n\n#define jl_svec_len(t)              (((jl_svec_t*)(t))->length)\n#define jl_svec_set_len_unsafe(t,n) (((jl_svec_t*)(t))->length=(n))\n#define jl_svec_data(t) ((jl_value_t**)((char*)(t) + sizeof(jl_svec_t)))\n\nSTATIC_INLINE jl_value_t *jl_svecref(void *t, size_t i)\n{\n    assert(jl_typeis(t,jl_simplevector_type));\n    assert(i < jl_svec_len(t));\n    return jl_svec_data(t)[i];\n}\nSTATIC_INLINE jl_value_t *jl_svecset(void *t, size_t i, void *x)\n{\n    assert(jl_typeis(t,jl_simplevector_type));\n    assert(i < jl_svec_len(t));\n    jl_svec_data(t)[i] = (jl_value_t*)x;\n    if (x) jl_gc_wb(t, x);\n    return (jl_value_t*)x;\n}\n\n#ifdef STORE_ARRAY_LEN\n#define jl_array_len(a)   (((jl_array_t*)(a))->length)\n#else\nJL_DLLEXPORT size_t jl_array_len_(jl_array_t *a);\n#define jl_array_len(a)   jl_array_len_((jl_array_t*)(a))\n#endif\n#define jl_array_data(a)  ((void*)((jl_array_t*)(a))->data)\n#define jl_array_dim(a,i) ((&((jl_array_t*)(a))->nrows)[i])\n#define jl_array_dim0(a)  (((jl_array_t*)(a))->nrows)\n#define jl_array_nrows(a) (((jl_array_t*)(a))->nrows)\n#define jl_array_ndims(a) ((int32_t)(((jl_array_t*)a)->flags.ndims))\n#define jl_array_data_owner_offset(ndims) (offsetof(jl_array_t,ncols) + sizeof(size_t)*(1+jl_array_ndimwords(ndims))) // in bytes\n#define jl_array_data_owner(a) (*((jl_value_t**)((char*)a + jl_array_data_owner_offset(jl_array_ndims(a)))))\n\nSTATIC_INLINE jl_value_t *jl_array_ptr_ref(void *a, size_t i)\n{\n    assert(i < jl_array_len(a));\n    return ((jl_value_t**)(jl_array_data(a)))[i];\n}\nSTATIC_INLINE jl_value_t *jl_array_ptr_set(void *a, size_t i, void *x)\n{\n    assert(i < jl_array_len(a));\n    ((jl_value_t**)(jl_array_data(a)))[i] = (jl_value_t*)x;\n    if (x) {\n        if (((jl_array_t*)a)->flags.how == 3) {\n            a = jl_array_data_owner(a);\n        }\n        jl_gc_wb(a, x);\n    }\n    return (jl_value_t*)x;\n}\n\nSTATIC_INLINE uint8_t jl_array_uint8_ref(void *a, size_t i)\n{\n    assert(i < jl_array_len(a));\n    assert(jl_typeis(a, jl_array_uint8_type));\n    return ((uint8_t*)(jl_array_data(a)))[i];\n}\nSTATIC_INLINE void jl_array_uint8_set(void *a, size_t i, uint8_t x)\n{\n    assert(i < jl_array_len(a));\n    assert(jl_typeis(a, jl_array_uint8_type));\n    ((uint8_t*)(jl_array_data(a)))[i] = x;\n}\n\n#define jl_exprarg(e,n) (((jl_value_t**)jl_array_data(((jl_expr_t*)(e))->args))[n])\n#define jl_exprargset(e, n, v) jl_array_ptr_set(((jl_expr_t*)(e))->args, n, v)\n#define jl_expr_nargs(e) jl_array_len(((jl_expr_t*)(e))->args)\n\n#define jl_fieldref(s,i) jl_get_nth_field(((jl_value_t*)s),i)\n#define jl_nfields(v)    jl_datatype_nfields(jl_typeof(v))\n\n// Not using jl_fieldref to avoid allocations\n#define jl_linenode_line(x) (((intptr_t*)x)[0])\n#define jl_labelnode_label(x) (((intptr_t*)x)[0])\n#define jl_slot_number(x) (((intptr_t*)x)[0])\n#define jl_typedslot_get_type(x) (((jl_value_t**)x)[1])\n#define jl_gotonode_label(x) (((intptr_t*)x)[0])\n#define jl_globalref_mod(s) (*(jl_module_t**)s)\n#define jl_globalref_name(s) (((jl_sym_t**)s)[1])\n\n#define jl_nparams(t)  jl_svec_len(((jl_datatype_t*)(t))->parameters)\n#define jl_tparam0(t)  jl_svecref(((jl_datatype_t*)(t))->parameters, 0)\n#define jl_tparam1(t)  jl_svecref(((jl_datatype_t*)(t))->parameters, 1)\n#define jl_tparam(t,i) jl_svecref(((jl_datatype_t*)(t))->parameters, i)\n\n// get a pointer to the data in a datatype\n#define jl_data_ptr(v)  ((jl_value_t**)v)\n\n#define jl_array_ptr_data(a)   ((jl_value_t**)((jl_array_t*)a)->data)\n#define jl_string_data(s) ((char*)((jl_array_t*)jl_data_ptr(s)[0])->data)\n#define jl_string_len(s)  (jl_array_len((jl_array_t*)(jl_data_ptr(s)[0])))\n#define jl_iostr_data(s)  ((char*)((jl_array_t*)jl_data_ptr(s)[0])->data)\n\n#define jl_gf_mtable(f) (((jl_datatype_t*)jl_typeof(f))->name->mt)\n#define jl_gf_name(f)   (jl_gf_mtable(f)->name)\n\n// struct type info\n#define jl_field_name(st,i)    (jl_sym_t*)jl_svecref(((jl_datatype_t*)st)->name->names, (i))\n#define jl_field_type(st,i)    jl_svecref(((jl_datatype_t*)st)->types, (i))\n#define jl_field_count(st)     jl_svec_len(((jl_datatype_t*)st)->types)\n#define jl_datatype_size(t)    (((jl_datatype_t*)t)->size)\n#define jl_datatype_nfields(t) (((jl_datatype_t*)(t))->layout->nfields)\n\n// inline version with strong type check to detect typos in a `->name` chain\nSTATIC_INLINE char *jl_symbol_name_(jl_sym_t *s)\n{\n    return (char*)s + LLT_ALIGN(sizeof(jl_sym_t), sizeof(void*));\n}\n#define jl_symbol_name(s) jl_symbol_name_(s)\n\n#define jl_dt_layout_fields(d) ((const char*)(d) + sizeof(jl_datatype_layout_t))\n\n#define DEFINE_FIELD_ACCESSORS(f)                                             \\\n    static inline uint32_t jl_field_##f(jl_datatype_t *st, int i)             \\\n    {                                                                         \\\n        const jl_datatype_layout_t *ly = st->layout;                          \\\n        assert(i >= 0 && (size_t)i < ly->nfields);                            \\\n        if (ly->fielddesc_type == 0) {                                        \\\n            return ((const jl_fielddesc8_t*)jl_dt_layout_fields(ly))[i].f;    \\\n        }                                                                     \\\n        else if (ly->fielddesc_type == 1) {                                   \\\n            return ((const jl_fielddesc16_t*)jl_dt_layout_fields(ly))[i].f;   \\\n        }                                                                     \\\n        else {                                                                \\\n            return ((const jl_fielddesc32_t*)jl_dt_layout_fields(ly))[i].f;   \\\n        }                                                                     \\\n    }                                                                         \\\n\nDEFINE_FIELD_ACCESSORS(offset)\nDEFINE_FIELD_ACCESSORS(size)\nstatic inline int jl_field_isptr(jl_datatype_t *st, int i)\n{\n    const jl_datatype_layout_t *ly = st->layout;\n    assert(i >= 0 && (size_t)i < ly->nfields);\n    return ((const jl_fielddesc8_t*)(jl_dt_layout_fields(ly) + (i << (ly->fielddesc_type + 1))))->isptr;\n}\n\nstatic inline uint32_t jl_fielddesc_size(int8_t fielddesc_type)\n{\n    if (fielddesc_type == 0) {\n        return sizeof(jl_fielddesc8_t);\n    }\n    else if (fielddesc_type == 1) {\n        return sizeof(jl_fielddesc16_t);\n    }\n    else {\n        return sizeof(jl_fielddesc32_t);\n    }\n}\n\n#undef DEFINE_FIELD_ACCESSORS\n\n// basic predicates -----------------------------------------------------------\n#define jl_is_nothing(v)     (((jl_value_t*)(v)) == ((jl_value_t*)jl_nothing))\n#define jl_is_tuple(v)       (((jl_datatype_t*)jl_typeof(v))->name == jl_tuple_typename)\n#define jl_is_svec(v)        jl_typeis(v,jl_simplevector_type)\n#define jl_is_simplevector(v) jl_is_svec(v)\n#define jl_is_datatype(v)    jl_typeis(v,jl_datatype_type)\n#define jl_is_mutable(t)     (((jl_datatype_t*)t)->mutabl)\n#define jl_is_mutable_datatype(t) (jl_is_datatype(t) && (((jl_datatype_t*)t)->mutabl))\n#define jl_is_immutable(t)   (!((jl_datatype_t*)t)->mutabl)\n#define jl_is_immutable_datatype(t) (jl_is_datatype(t) && (!((jl_datatype_t*)t)->mutabl))\n#define jl_is_uniontype(v)   jl_typeis(v,jl_uniontype_type)\n#define jl_is_typevar(v)     jl_typeis(v,jl_tvar_type)\n#define jl_is_typector(v)    jl_typeis(v,jl_typector_type)\n#define jl_is_TypeConstructor(v)    jl_typeis(v,jl_typector_type)\n#define jl_is_typename(v)    jl_typeis(v,jl_typename_type)\n#define jl_is_int8(v)        jl_typeis(v,jl_int8_type)\n#define jl_is_int16(v)       jl_typeis(v,jl_int16_type)\n#define jl_is_int32(v)       jl_typeis(v,jl_int32_type)\n#define jl_is_int64(v)       jl_typeis(v,jl_int64_type)\n#define jl_is_uint8(v)       jl_typeis(v,jl_uint8_type)\n#define jl_is_uint16(v)      jl_typeis(v,jl_uint16_type)\n#define jl_is_uint32(v)      jl_typeis(v,jl_uint32_type)\n#define jl_is_uint64(v)      jl_typeis(v,jl_uint64_type)\n#define jl_is_float(v)       jl_subtype(v,(jl_value_t*)jl_floatingpoint_type,1)\n#define jl_is_floattype(v)   jl_subtype(v,(jl_value_t*)jl_floatingpoint_type,0)\n#define jl_is_float32(v)     jl_typeis(v,jl_float32_type)\n#define jl_is_float64(v)     jl_typeis(v,jl_float64_type)\n#define jl_is_bool(v)        jl_typeis(v,jl_bool_type)\n#define jl_is_symbol(v)      jl_typeis(v,jl_sym_type)\n#define jl_is_ssavalue(v)    jl_typeis(v,jl_ssavalue_type)\n#define jl_is_slot(v)        (jl_typeis(v,jl_slotnumber_type) || jl_typeis(v,jl_typedslot_type))\n#define jl_is_expr(v)        jl_typeis(v,jl_expr_type)\n#define jl_is_globalref(v)   jl_typeis(v,jl_globalref_type)\n#define jl_is_labelnode(v)   jl_typeis(v,jl_labelnode_type)\n#define jl_is_gotonode(v)    jl_typeis(v,jl_gotonode_type)\n#define jl_is_quotenode(v)   jl_typeis(v,jl_quotenode_type)\n#define jl_is_newvarnode(v)  jl_typeis(v,jl_newvarnode_type)\n#define jl_is_linenode(v)    jl_typeis(v,jl_linenumbernode_type)\n#define jl_is_lambda_info(v) jl_typeis(v,jl_lambda_info_type)\n#define jl_is_method(v)      jl_typeis(v,jl_method_type)\n#define jl_is_module(v)      jl_typeis(v,jl_module_type)\n#define jl_is_mtable(v)      jl_typeis(v,jl_methtable_type)\n#define jl_is_task(v)        jl_typeis(v,jl_task_type)\n#define jl_is_string(v)      jl_typeis(v,jl_string_type)\n#define jl_is_cpointer(v)    jl_is_cpointer_type(jl_typeof(v))\n#define jl_is_pointer(v)     jl_is_cpointer_type(jl_typeof(v))\n\nSTATIC_INLINE int jl_is_bitstype(void *v)\n{\n    return (jl_is_datatype(v) && jl_is_immutable(v) &&\n            ((jl_datatype_t*)(v))->layout &&\n            jl_datatype_nfields(v) == 0 &&\n            ((jl_datatype_t*)(v))->size > 0);\n}\n\nSTATIC_INLINE int jl_is_structtype(void *v)\n{\n    return (jl_is_datatype(v) &&\n            (jl_field_count(v) > 0 ||\n             ((jl_datatype_t*)(v))->size == 0) &&\n            !((jl_datatype_t*)(v))->abstract);\n}\n\nSTATIC_INLINE int jl_isbits(void *t)   // corresponding to isbits() in julia\n{\n    return (jl_is_datatype(t) && ((jl_datatype_t*)t)->layout &&\n            !((jl_datatype_t*)t)->mutabl && ((jl_datatype_t*)t)->layout->pointerfree);\n}\n\nSTATIC_INLINE int jl_is_datatype_singleton(jl_datatype_t *d)\n{\n    return (d->instance != NULL);\n}\n\nSTATIC_INLINE int jl_is_datatype_make_singleton(jl_datatype_t *d)\n{\n    return (!d->abstract && d->size == 0 && d != jl_sym_type && d->name != jl_array_typename &&\n            d->uid != 0 && (d->name->names == jl_emptysvec || !d->mutabl));\n}\n\nSTATIC_INLINE int jl_is_abstracttype(void *v)\n{\n    return (jl_is_datatype(v) && ((jl_datatype_t*)(v))->abstract);\n}\n\nSTATIC_INLINE int jl_is_array_type(void *t)\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_array_typename);\n}\n\nSTATIC_INLINE int jl_is_array(void *v)\n{\n    jl_value_t *t = jl_typeof(v);\n    return jl_is_array_type(t);\n}\n\nSTATIC_INLINE int jl_is_cpointer_type(jl_value_t *t)\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_pointer_type->name);\n}\n\nSTATIC_INLINE int jl_is_abstract_ref_type(jl_value_t *t)\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_ref_type->name);\n}\n\nSTATIC_INLINE jl_value_t *jl_is_ref_type(jl_value_t *t)\n{\n    if (!jl_is_datatype(t)) return 0;\n    jl_datatype_t *dt = (jl_datatype_t*)t;\n    while (dt != jl_any_type && dt->name != dt->super->name) {\n        if (dt->name == jl_ref_type->name)\n            return (jl_value_t*)dt;\n        dt = dt->super;\n    }\n    return 0;\n}\n\nSTATIC_INLINE int jl_is_tuple_type(void *t)\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_tuple_typename);\n}\n\nSTATIC_INLINE int jl_is_vecelement_type(jl_value_t* t)\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_vecelement_typename);\n}\n\nSTATIC_INLINE int jl_is_type_type(jl_value_t *v)\n{\n    return (jl_is_datatype(v) &&\n            ((jl_datatype_t*)(v))->name == jl_type_type->name);\n}\n\n// object identity\nJL_DLLEXPORT int jl_egal(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT uintptr_t jl_object_id(jl_value_t *v);\n\n// type predicates and basic operations\nJL_DLLEXPORT int jl_is_leaf_type(jl_value_t *v);\nJL_DLLEXPORT int jl_has_typevars(jl_value_t *v);\nJL_DLLEXPORT int jl_subtype(jl_value_t *a, jl_value_t *b, int ta);\nJL_DLLEXPORT int jl_types_equal(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_type_union(jl_svec_t *types);\nJL_DLLEXPORT jl_value_t *jl_type_intersection(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT int jl_args_morespecific(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT const char *jl_typename_str(jl_value_t *v);\nJL_DLLEXPORT const char *jl_typeof_str(jl_value_t *v);\nJL_DLLEXPORT int jl_type_morespecific(jl_value_t *a, jl_value_t *b);\n\n#ifdef NDEBUG\nSTATIC_INLINE int jl_is_leaf_type_(jl_value_t *v)\n{\n    return jl_is_datatype(v) && ((jl_datatype_t*)v)->isleaftype;\n}\n#define jl_is_leaf_type(v) jl_is_leaf_type_(v)\n#endif\n\n// type constructors\nJL_DLLEXPORT jl_typename_t *jl_new_typename(jl_sym_t *name);\nJL_DLLEXPORT jl_tvar_t *jl_new_typevar(jl_sym_t *name,jl_value_t *lb,jl_value_t *ub);\nJL_DLLEXPORT jl_value_t *jl_apply_type(jl_value_t *tc, jl_svec_t *params);\nJL_DLLEXPORT jl_tupletype_t *jl_apply_tuple_type(jl_svec_t *params);\nJL_DLLEXPORT jl_tupletype_t *jl_apply_tuple_type_v(jl_value_t **p, size_t np);\nJL_DLLEXPORT jl_datatype_t *jl_new_datatype(jl_sym_t *name, jl_datatype_t *super,\n                                            jl_svec_t *parameters,\n                                            jl_svec_t *fnames, jl_svec_t *ftypes,\n                                            int abstract, int mutabl,\n                                            int ninitialized);\nJL_DLLEXPORT jl_datatype_t *jl_new_bitstype(jl_value_t *name,\n                                            jl_datatype_t *super,\n                                            jl_svec_t *parameters, size_t nbits);\n\n// constructors\nJL_DLLEXPORT jl_value_t *jl_new_bits(jl_value_t *bt, void *data);\nJL_DLLEXPORT jl_value_t *jl_new_struct(jl_datatype_t *type, ...);\nJL_DLLEXPORT jl_value_t *jl_new_structv(jl_datatype_t *type, jl_value_t **args,\n                                        uint32_t na);\nJL_DLLEXPORT jl_value_t *jl_new_struct_uninit(jl_datatype_t *type);\nJL_DLLEXPORT jl_lambda_info_t *jl_new_lambda_info_uninit(void);\nJL_DLLEXPORT jl_lambda_info_t *jl_new_lambda_info_from_ast(jl_expr_t *ast);\nJL_DLLEXPORT jl_method_t *jl_new_method(jl_lambda_info_t *definition, jl_sym_t *name, jl_tupletype_t *sig, jl_svec_t *tvars, int isstaged);\nJL_DLLEXPORT jl_svec_t *jl_svec(size_t n, ...);\nJL_DLLEXPORT jl_svec_t *jl_svec1(void *a);\nJL_DLLEXPORT jl_svec_t *jl_svec2(void *a, void *b);\nJL_DLLEXPORT jl_svec_t *jl_alloc_svec(size_t n);\nJL_DLLEXPORT jl_svec_t *jl_alloc_svec_uninit(size_t n);\nJL_DLLEXPORT jl_svec_t *jl_svec_copy(jl_svec_t *a);\nJL_DLLEXPORT jl_svec_t *jl_svec_fill(size_t n, jl_value_t *x);\nJL_DLLEXPORT jl_value_t *jl_tupletype_fill(size_t n, jl_value_t *v);\nJL_DLLEXPORT jl_sym_t *jl_symbol(const char *str);\nJL_DLLEXPORT jl_sym_t *jl_symbol_lookup(const char *str);\nJL_DLLEXPORT jl_sym_t *jl_symbol_n(const char *str, int32_t len);\nJL_DLLEXPORT jl_sym_t *jl_gensym(void);\nJL_DLLEXPORT jl_sym_t *jl_tagged_gensym(const char *str, int32_t len);\nJL_DLLEXPORT jl_sym_t *jl_get_root_symbol(void);\nJL_DLLEXPORT jl_value_t *jl_generic_function_def(jl_sym_t *name, jl_value_t **bp,\n                                                 jl_value_t *bp_owner,\n                                                 jl_binding_t *bnd);\nJL_DLLEXPORT void jl_method_def(jl_svec_t *argdata, jl_lambda_info_t *f, jl_value_t *isstaged);\nJL_DLLEXPORT jl_function_t *jl_get_kwsorter(jl_typename_t *tn);\nJL_DLLEXPORT jl_value_t *jl_box_bool(int8_t x);\nJL_DLLEXPORT jl_value_t *jl_box_int8(int8_t x);\nJL_DLLEXPORT jl_value_t *jl_box_uint8(uint8_t x);\nJL_DLLEXPORT jl_value_t *jl_box_int16(int16_t x);\nJL_DLLEXPORT jl_value_t *jl_box_uint16(uint16_t x);\nJL_DLLEXPORT jl_value_t *jl_box_int32(int32_t x);\nJL_DLLEXPORT jl_value_t *jl_box_uint32(uint32_t x);\nJL_DLLEXPORT jl_value_t *jl_box_char(uint32_t x);\nJL_DLLEXPORT jl_value_t *jl_box_int64(int64_t x);\nJL_DLLEXPORT jl_value_t *jl_box_uint64(uint64_t x);\nJL_DLLEXPORT jl_value_t *jl_box_float32(float x);\nJL_DLLEXPORT jl_value_t *jl_box_float64(double x);\nJL_DLLEXPORT jl_value_t *jl_box_voidpointer(void *x);\nJL_DLLEXPORT jl_value_t *jl_box_ssavalue(size_t x);\nJL_DLLEXPORT jl_value_t *jl_box_slotnumber(size_t x);\nJL_DLLEXPORT jl_value_t *jl_box8 (jl_datatype_t *t, int8_t  x);\nJL_DLLEXPORT jl_value_t *jl_box16(jl_datatype_t *t, int16_t x);\nJL_DLLEXPORT jl_value_t *jl_box32(jl_datatype_t *t, int32_t x);\nJL_DLLEXPORT jl_value_t *jl_box64(jl_datatype_t *t, int64_t x);\nJL_DLLEXPORT int8_t jl_unbox_bool(jl_value_t *v);\nJL_DLLEXPORT int8_t jl_unbox_int8(jl_value_t *v);\nJL_DLLEXPORT uint8_t jl_unbox_uint8(jl_value_t *v);\nJL_DLLEXPORT int16_t jl_unbox_int16(jl_value_t *v);\nJL_DLLEXPORT uint16_t jl_unbox_uint16(jl_value_t *v);\nJL_DLLEXPORT int32_t jl_unbox_int32(jl_value_t *v);\nJL_DLLEXPORT uint32_t jl_unbox_uint32(jl_value_t *v);\nJL_DLLEXPORT int64_t jl_unbox_int64(jl_value_t *v);\nJL_DLLEXPORT uint64_t jl_unbox_uint64(jl_value_t *v);\nJL_DLLEXPORT float jl_unbox_float32(jl_value_t *v);\nJL_DLLEXPORT double jl_unbox_float64(jl_value_t *v);\nJL_DLLEXPORT void *jl_unbox_voidpointer(jl_value_t *v);\n\nJL_DLLEXPORT int jl_get_size(jl_value_t *val, size_t *pnt);\n\n#ifdef _P64\n#define jl_box_long(x)   jl_box_int64(x)\n#define jl_box_ulong(x)  jl_box_uint64(x)\n#define jl_unbox_long(x) jl_unbox_int64(x)\n#define jl_is_long(x)    jl_is_int64(x)\n#define jl_long_type     jl_int64_type\n#else\n#define jl_box_long(x)   jl_box_int32(x)\n#define jl_box_ulong(x)  jl_box_uint32(x)\n#define jl_unbox_long(x) jl_unbox_int32(x)\n#define jl_is_long(x)    jl_is_int32(x)\n#define jl_long_type     jl_int32_type\n#endif\n\n// Each tuple can exist in one of 4 Vararg states:\n//   NONE: no vararg                            Tuple{Int,Float32}\n//   INT: vararg with integer length            Tuple{Int,Vararg{Float32,2}}\n//   BOUND: vararg with bound TypeVar length    Tuple{Int,Vararg{Float32,N}}\n//   UNBOUND: vararg with unbound length        Tuple{Int,Vararg{Float32}}\ntypedef enum {\n    JL_VARARG_NONE    = 0,\n    JL_VARARG_INT     = 1,\n    JL_VARARG_BOUND   = 2,\n    JL_VARARG_UNBOUND = 3\n} jl_vararg_kind_t;\n\nSTATIC_INLINE int jl_is_vararg_type(jl_value_t *v)\n{\n    return (jl_is_datatype(v) &&\n            ((jl_datatype_t*)(v))->name == jl_vararg_type->name);\n}\n\nSTATIC_INLINE jl_vararg_kind_t jl_vararg_kind(jl_value_t *v)\n{\n    if (!jl_is_vararg_type(v))\n        return JL_VARARG_NONE;\n    jl_value_t *lenv = jl_tparam1(v);\n    if (jl_is_long(lenv))\n        return JL_VARARG_INT;\n    if (jl_is_typevar(lenv))\n        return ((jl_tvar_t*)lenv)->bound ? JL_VARARG_BOUND : JL_VARARG_UNBOUND;\n    return JL_VARARG_UNBOUND;\n}\n\nSTATIC_INLINE int jl_is_va_tuple(jl_datatype_t *t)\n{\n    assert(jl_is_tuple_type(t));\n    size_t l = jl_svec_len(t->parameters);\n    return (l>0 && jl_is_vararg_type(jl_tparam(t,l-1)));\n}\n\nSTATIC_INLINE jl_vararg_kind_t jl_va_tuple_kind(jl_datatype_t *t)\n{\n    assert(jl_is_tuple_type(t));\n    size_t l = jl_svec_len(t->parameters);\n    if (l == 0)\n        return JL_VARARG_NONE;\n    return jl_vararg_kind(jl_tparam(t,l-1));\n}\n\n// structs\nJL_DLLEXPORT int         jl_field_index(jl_datatype_t *t, jl_sym_t *fld, int err);\nJL_DLLEXPORT jl_value_t *jl_get_nth_field(jl_value_t *v, size_t i);\nJL_DLLEXPORT jl_value_t *jl_get_nth_field_checked(jl_value_t *v, size_t i);\nJL_DLLEXPORT void        jl_set_nth_field(jl_value_t *v, size_t i,\n                                          jl_value_t *rhs);\nJL_DLLEXPORT int         jl_field_isdefined(jl_value_t *v, size_t i);\nJL_DLLEXPORT jl_value_t *jl_get_field(jl_value_t *o, const char *fld);\nJL_DLLEXPORT jl_value_t *jl_value_ptr(jl_value_t *a);\n\n// arrays\nJL_DLLEXPORT jl_array_t *jl_new_array(jl_value_t *atype, jl_value_t *dims);\nJL_DLLEXPORT jl_array_t *jl_reshape_array(jl_value_t *atype, jl_array_t *data,\n                                          jl_value_t *dims);\nJL_DLLEXPORT jl_array_t *jl_ptr_to_array_1d(jl_value_t *atype, void *data,\n                                            size_t nel, int own_buffer);\nJL_DLLEXPORT jl_array_t *jl_ptr_to_array(jl_value_t *atype, void *data,\n                                         jl_value_t *dims, int own_buffer);\n\nJL_DLLEXPORT jl_array_t *jl_alloc_array_1d(jl_value_t *atype, size_t nr);\nJL_DLLEXPORT jl_array_t *jl_alloc_array_2d(jl_value_t *atype, size_t nr,\n                                           size_t nc);\nJL_DLLEXPORT jl_array_t *jl_alloc_array_3d(jl_value_t *atype, size_t nr,\n                                           size_t nc, size_t z);\nJL_DLLEXPORT jl_array_t *jl_pchar_to_array(const char *str, size_t len);\nJL_DLLEXPORT jl_value_t *jl_pchar_to_string(const char *str, size_t len);\nJL_DLLEXPORT jl_value_t *jl_cstr_to_string(const char *str);\nJL_DLLEXPORT jl_value_t *jl_array_to_string(jl_array_t *a);\nJL_DLLEXPORT jl_array_t *jl_alloc_vec_any(size_t n);\nJL_DLLEXPORT jl_value_t *jl_arrayref(jl_array_t *a, size_t i);  // 0-indexed\nJL_DLLEXPORT void jl_arrayset(jl_array_t *a, jl_value_t *v, size_t i);  // 0-indexed\nJL_DLLEXPORT void jl_arrayunset(jl_array_t *a, size_t i);  // 0-indexed\nJL_DLLEXPORT void jl_array_grow_end(jl_array_t *a, size_t inc);\nJL_DLLEXPORT void jl_array_del_end(jl_array_t *a, size_t dec);\nJL_DLLEXPORT void jl_array_grow_beg(jl_array_t *a, size_t inc);\nJL_DLLEXPORT void jl_array_del_beg(jl_array_t *a, size_t dec);\nJL_DLLEXPORT void jl_array_sizehint(jl_array_t *a, size_t sz);\nJL_DLLEXPORT void jl_array_ptr_1d_push(jl_array_t *a, jl_value_t *item);\nJL_DLLEXPORT void jl_array_ptr_1d_push2(jl_array_t *a, jl_value_t *b, jl_value_t *c);\nJL_DLLEXPORT jl_value_t *jl_apply_array_type(jl_datatype_t *type, size_t dim);\n// property access\nJL_DLLEXPORT void *jl_array_ptr(jl_array_t *a);\nJL_DLLEXPORT void *jl_array_eltype(jl_value_t *a);\nJL_DLLEXPORT int jl_array_rank(jl_value_t *a);\nJL_DLLEXPORT size_t jl_array_size(jl_value_t *a, int d);\n\n// strings\nJL_DLLEXPORT const char *jl_string_ptr(jl_value_t *s);\n\n// modules and global variables\nextern JL_DLLEXPORT jl_module_t *jl_main_module;\nextern JL_DLLEXPORT jl_module_t *jl_internal_main_module;\nextern JL_DLLEXPORT jl_module_t *jl_core_module;\nextern JL_DLLEXPORT jl_module_t *jl_base_module;\nextern JL_DLLEXPORT jl_module_t *jl_top_module;\nJL_DLLEXPORT jl_module_t *jl_new_module(jl_sym_t *name);\n// get binding for reading\nJL_DLLEXPORT jl_binding_t *jl_get_binding(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT jl_binding_t *jl_get_binding_or_error(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT jl_value_t *jl_module_globalref(jl_module_t *m, jl_sym_t *var);\n// get binding for assignment\nJL_DLLEXPORT jl_binding_t *jl_get_binding_wr(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT jl_binding_t *jl_get_binding_for_method_def(jl_module_t *m,\n                                                         jl_sym_t *var);\nJL_DLLEXPORT int jl_boundp(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT int jl_defines_or_exports_p(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT int jl_binding_resolved_p(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT int jl_is_const(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT jl_value_t *jl_get_global(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT void jl_set_global(jl_module_t *m, jl_sym_t *var, jl_value_t *val);\nJL_DLLEXPORT void jl_set_const(jl_module_t *m, jl_sym_t *var, jl_value_t *val);\nJL_DLLEXPORT void jl_checked_assignment(jl_binding_t *b, jl_value_t *rhs);\nJL_DLLEXPORT void jl_declare_constant(jl_binding_t *b);\nJL_DLLEXPORT void jl_module_using(jl_module_t *to, jl_module_t *from);\nJL_DLLEXPORT void jl_module_use(jl_module_t *to, jl_module_t *from, jl_sym_t *s);\nJL_DLLEXPORT void jl_module_import(jl_module_t *to, jl_module_t *from,\n                                   jl_sym_t *s);\nJL_DLLEXPORT void jl_module_importall(jl_module_t *to, jl_module_t *from);\nJL_DLLEXPORT void jl_module_export(jl_module_t *from, jl_sym_t *s);\nJL_DLLEXPORT int jl_is_imported(jl_module_t *m, jl_sym_t *s);\nJL_DLLEXPORT jl_module_t *jl_new_main_module(void);\nJL_DLLEXPORT void jl_add_standard_imports(jl_module_t *m);\nSTATIC_INLINE jl_function_t *jl_get_function(jl_module_t *m, const char *name)\n{\n    return (jl_function_t*)jl_get_global(m, jl_symbol(name));\n}\nint jl_is_submodule(jl_module_t *child, jl_module_t *parent);\n\n// eq hash tables\nJL_DLLEXPORT jl_array_t *jl_eqtable_put(jl_array_t *h, void *key, void *val);\nJL_DLLEXPORT jl_value_t *jl_eqtable_get(jl_array_t *h, void *key,\n                                        jl_value_t *deflt);\n\n// system information\nJL_DLLEXPORT int jl_errno(void);\nJL_DLLEXPORT void jl_set_errno(int e);\nJL_DLLEXPORT int32_t jl_stat(const char *path, char *statbuf);\nJL_DLLEXPORT int jl_cpu_cores(void);\nJL_DLLEXPORT long jl_getpagesize(void);\nJL_DLLEXPORT long jl_getallocationgranularity(void);\nJL_DLLEXPORT int jl_is_debugbuild(void);\nJL_DLLEXPORT jl_sym_t *jl_get_UNAME(void);\nJL_DLLEXPORT jl_sym_t *jl_get_ARCH(void);\n\n// environment entries\nJL_DLLEXPORT jl_value_t *jl_environ(int i);\n\n// throwing common exceptions\nJL_DLLEXPORT void JL_NORETURN jl_error(const char *str);\nJL_DLLEXPORT void JL_NORETURN jl_errorf(const char *fmt, ...);\nJL_DLLEXPORT void JL_NORETURN jl_exceptionf(jl_datatype_t *ty,\n                                            const char *fmt, ...);\nJL_DLLEXPORT void JL_NORETURN jl_too_few_args(const char *fname, int min);\nJL_DLLEXPORT void JL_NORETURN jl_too_many_args(const char *fname, int max);\nJL_DLLEXPORT void JL_NORETURN jl_type_error(const char *fname,\n                                            jl_value_t *expected,\n                                            jl_value_t *got);\nJL_DLLEXPORT void JL_NORETURN jl_type_error_rt(const char *fname,\n                                               const char *context,\n                                               jl_value_t *ty, jl_value_t *got);\nJL_DLLEXPORT void JL_NORETURN jl_undefined_var_error(jl_sym_t *var);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error(jl_value_t *v, jl_value_t *t);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_v(jl_value_t *v,\n                                                jl_value_t **idxs, size_t nidxs);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_int(jl_value_t *v, size_t i);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_tuple_int(jl_value_t **v,\n                                                        size_t nv, size_t i);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_unboxed_int(void *v, jl_value_t *vt, size_t i);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_ints(jl_value_t *v, size_t *idxs, size_t nidxs);\nJL_DLLEXPORT void JL_NORETURN jl_eof_error(void);\nJL_DLLEXPORT jl_value_t *jl_exception_occurred(void);\nJL_DLLEXPORT void jl_exception_clear(void);\n\n#define JL_NARGS(fname, min, max)                               \\\n    if (nargs < min) jl_too_few_args(#fname, min);              \\\n    else if (nargs > max) jl_too_many_args(#fname, max);\n\n#define JL_NARGSV(fname, min)                           \\\n    if (nargs < min) jl_too_few_args(#fname, min);\n\n#define JL_TYPECHK(fname, type, v)                                      \\\n    if (!jl_is_##type(v)) {                                             \\\n        jl_type_error(#fname, (jl_value_t*)jl_##type##_type, (v));      \\\n    }\n#define JL_TYPECHKS(fname, type, v)                                     \\\n    if (!jl_is_##type(v)) {                                             \\\n        jl_type_error(fname, (jl_value_t*)jl_##type##_type, (v));       \\\n    }\n\n// initialization functions\ntypedef enum {\n    JL_IMAGE_CWD = 0,\n    JL_IMAGE_JULIA_HOME = 1,\n    //JL_IMAGE_LIBJULIA = 2,\n} JL_IMAGE_SEARCH;\nJL_DLLEXPORT void julia_init(JL_IMAGE_SEARCH rel);\nJL_DLLEXPORT void jl_init(const char *julia_home_dir);\nJL_DLLEXPORT void jl_init_with_image(const char *julia_home_dir,\n                                     const char *image_relative_path);\nJL_DLLEXPORT int jl_is_initialized(void);\nJL_DLLEXPORT void jl_atexit_hook(int status);\nJL_DLLEXPORT void JL_NORETURN jl_exit(int status);\n\nJL_DLLEXPORT int jl_deserialize_verify_header(ios_t *s);\nJL_DLLEXPORT void jl_preload_sysimg_so(const char *fname);\nJL_DLLEXPORT ios_t *jl_create_system_image(void);\nJL_DLLEXPORT void jl_save_system_image(const char *fname);\nJL_DLLEXPORT void jl_restore_system_image(const char *fname);\nJL_DLLEXPORT void jl_restore_system_image_data(const char *buf, size_t len);\nJL_DLLEXPORT int jl_save_incremental(const char *fname, jl_array_t *worklist);\nJL_DLLEXPORT jl_value_t *jl_restore_incremental(const char *fname);\nJL_DLLEXPORT jl_value_t *jl_restore_incremental_from_buf(const char *buf, size_t sz);\n\n// front end interface\nJL_DLLEXPORT jl_value_t *jl_parse_input_line(const char *str, size_t len,\n                                             const char *filename, size_t filename_len);\nJL_DLLEXPORT jl_value_t *jl_parse_string(const char *str, size_t len,\n                                         int pos0, int greedy);\nJL_DLLEXPORT int jl_parse_depwarn(int warn);\nJL_DLLEXPORT jl_value_t *jl_load_file_string(const char *text, size_t len,\n                                             char *filename);\nJL_DLLEXPORT jl_value_t *jl_expand(jl_value_t *expr);\nJL_DLLEXPORT jl_value_t *jl_eval_string(const char *str);\n\n// external libraries\nenum JL_RTLD_CONSTANT {\n     JL_RTLD_LOCAL=1U,\n     JL_RTLD_GLOBAL=2U,\n     JL_RTLD_LAZY=4U,\n     JL_RTLD_NOW=8U,\n     /* Linux/glibc and MacOS X: */\n     JL_RTLD_NODELETE=16U,\n     JL_RTLD_NOLOAD=32U,\n     /* Linux/glibc: */\n     JL_RTLD_DEEPBIND=64U,\n     /* MacOS X 10.5+: */\n     JL_RTLD_FIRST=128U\n};\n#define JL_RTLD_DEFAULT (JL_RTLD_LAZY | JL_RTLD_DEEPBIND)\n\ntypedef void *jl_uv_libhandle; // compatible with dlopen (void*) / LoadLibrary (HMODULE)\nJL_DLLEXPORT jl_uv_libhandle jl_load_dynamic_library(const char *fname, unsigned flags);\nJL_DLLEXPORT jl_uv_libhandle jl_load_dynamic_library_e(const char *fname, unsigned flags);\nJL_DLLEXPORT jl_uv_libhandle jl_dlopen(const char *filename, unsigned flags);\nJL_DLLEXPORT int jl_dlclose(jl_uv_libhandle handle);\nJL_DLLEXPORT void *jl_dlsym_e(jl_uv_libhandle handle, const char *symbol);\nJL_DLLEXPORT void *jl_dlsym(jl_uv_libhandle handle, const char *symbol);\n\n#if defined(__linux__) || defined(__FreeBSD__)\nJL_DLLEXPORT const char *jl_lookup_soname(const char *pfx, size_t n);\n#endif\n\n// compiler\nJL_DLLEXPORT jl_value_t *jl_toplevel_eval(jl_value_t *v);\nJL_DLLEXPORT jl_value_t *jl_toplevel_eval_in(jl_module_t *m, jl_value_t *ex);\nJL_DLLEXPORT jl_value_t *jl_load(const char *fname);\nJL_DLLEXPORT jl_value_t *jl_interpret_toplevel_expr_in(jl_module_t *m, jl_value_t *e,\n                                                       jl_lambda_info_t *lam);\nJL_DLLEXPORT jl_module_t *jl_base_relative_to(jl_module_t *m);\n\n// tracing\nJL_DLLEXPORT void jl_trace_method(jl_method_t *m);\nJL_DLLEXPORT void jl_untrace_method(jl_method_t *m);\nJL_DLLEXPORT void jl_trace_linfo(jl_lambda_info_t *linfo);\nJL_DLLEXPORT void jl_untrace_linfo(jl_lambda_info_t *linfo);\nJL_DLLEXPORT void jl_register_linfo_tracer(void (*callback)(jl_lambda_info_t *tracee));\nJL_DLLEXPORT void jl_register_method_tracer(void (*callback)(jl_lambda_info_t *tracee));\nJL_DLLEXPORT void jl_register_newmeth_tracer(void (*callback)(jl_method_t *tracee));\n\n// AST access\nJL_DLLEXPORT int jl_is_rest_arg(jl_value_t *ex);\n\nJL_DLLEXPORT jl_value_t *jl_copy_ast(jl_value_t *expr);\n\nJL_DLLEXPORT jl_array_t *jl_compress_ast(jl_lambda_info_t *li, jl_array_t *ast);\nJL_DLLEXPORT jl_array_t *jl_uncompress_ast(jl_lambda_info_t *li, jl_array_t *data);\n\nJL_DLLEXPORT int jl_is_operator(char *sym);\nJL_DLLEXPORT int jl_operator_precedence(char *sym);\n\nSTATIC_INLINE int jl_vinfo_sa(uint8_t vi)\n{\n    return (vi&16)!=0;\n}\n\nSTATIC_INLINE int jl_vinfo_usedundef(uint8_t vi)\n{\n    return (vi&32)!=0;\n}\n\n// calling into julia ---------------------------------------------------------\n\nJL_DLLEXPORT jl_value_t *jl_apply_generic(jl_value_t **args, uint32_t nargs);\nJL_DLLEXPORT jl_value_t *jl_invoke(jl_lambda_info_t *meth, jl_value_t **args, uint32_t nargs);\n\nSTATIC_INLINE\njl_value_t *jl_apply(jl_value_t **args, uint32_t nargs)\n{\n    return jl_apply_generic(args, nargs);\n}\n\nJL_DLLEXPORT jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs);\nJL_DLLEXPORT jl_value_t *jl_call0(jl_function_t *f);\nJL_DLLEXPORT jl_value_t *jl_call1(jl_function_t *f, jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_call2(jl_function_t *f, jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_call3(jl_function_t *f, jl_value_t *a,\n                                  jl_value_t *b, jl_value_t *c);\n\n// interfacing with Task runtime\nJL_DLLEXPORT void jl_yield(void);\n\n// async signal handling ------------------------------------------------------\n\nJL_DLLEXPORT void jl_install_sigint_handler(void);\nJL_DLLEXPORT void jl_sigatomic_begin(void);\nJL_DLLEXPORT void jl_sigatomic_end(void);\n\n// tasks and exceptions -------------------------------------------------------\n\ntypedef struct _jl_timing_block_t jl_timing_block_t;\n// info describing an exception handler\ntypedef struct _jl_handler_t {\n    jl_jmp_buf eh_ctx;\n    jl_gcframe_t *gcstack;\n    struct _jl_handler_t *prev;\n    int8_t gc_state;\n#ifdef JULIA_ENABLE_THREADING\n    size_t locks_len;\n#endif\n    sig_atomic_t defer_signal;\n    int finalizers_inhibited;\n    jl_timing_block_t *timing_stack;\n} jl_handler_t;\n\ntypedef struct _jl_task_t {\n    JL_DATA_TYPE\n    struct _jl_task_t *parent;\n    jl_value_t *tls;\n    jl_sym_t *state;\n    jl_value_t *consumers;\n    jl_value_t *donenotify;\n    jl_value_t *result;\n    jl_value_t *exception;\n    jl_value_t *backtrace;\n    jl_function_t *start;\n    jl_jmp_buf ctx;\n    size_t bufsz;\n    void *stkbuf;\n\n    size_t ssize;\n    size_t started:1;\n\n    // current exception handler\n    jl_handler_t *eh;\n    // saved gc stack top for context switches\n    jl_gcframe_t *gcstack;\n    // current module, or NULL if this task has not set one\n    jl_module_t *current_module;\n\n    // id of owning thread\n    // does not need to be defined until the task runs\n    int16_t tid;\n#ifdef JULIA_ENABLE_THREADING\n    // This is statically initialized when the task is not holding any locks\n    arraylist_t locks;\n#endif\n    jl_timing_block_t *timing_stack;\n} jl_task_t;\n\nJL_DLLEXPORT jl_task_t *jl_new_task(jl_function_t *start, size_t ssize);\nJL_DLLEXPORT jl_value_t *jl_switchto(jl_task_t *t, jl_value_t *arg);\nJL_DLLEXPORT void JL_NORETURN jl_throw(jl_value_t *e);\nJL_DLLEXPORT void JL_NORETURN jl_rethrow(void);\nJL_DLLEXPORT void JL_NORETURN jl_rethrow_other(jl_value_t *e);\n\n#ifdef JULIA_ENABLE_THREADING\nstatic inline void jl_lock_frame_push(jl_mutex_t *lock)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    // For early bootstrap\n    if (__unlikely(!ptls->current_task))\n        return;\n    arraylist_t *locks = &ptls->current_task->locks;\n    size_t len = locks->len;\n    if (__unlikely(len >= locks->max)) {\n        arraylist_grow(locks, 1);\n    }\n    else {\n        locks->len = len + 1;\n    }\n    locks->items[len] = (void*)lock;\n}\nstatic inline void jl_lock_frame_pop(void)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    if (__likely(ptls->current_task)) {\n        ptls->current_task->locks.len--;\n    }\n}\n#else\nstatic inline void jl_lock_frame_push(jl_mutex_t *lock)\n{\n    (void)lock;\n}\nstatic inline void jl_lock_frame_pop(void)\n{\n}\n#endif // ifndef JULIA_ENABLE_THREADING\n\nSTATIC_INLINE void jl_eh_restore_state(jl_handler_t *eh)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    jl_task_t *current_task = ptls->current_task;\n    // `eh` may not be `ptls->current_task->eh`. See `jl_pop_handler`\n    // This function should **NOT** have any safepoint before the ones at the\n    // end.\n    sig_atomic_t old_defer_signal = ptls->defer_signal;\n    int8_t old_gc_state = ptls->gc_state;\n    current_task->eh = eh->prev;\n    ptls->pgcstack = eh->gcstack;\n#ifdef JULIA_ENABLE_THREADING\n    arraylist_t *locks = &current_task->locks;\n    if (locks->len > eh->locks_len) {\n        for (size_t i = locks->len;i > eh->locks_len;i--)\n            jl_mutex_unlock_nogc((jl_mutex_t*)locks->items[i - 1]);\n        locks->len = eh->locks_len;\n    }\n#endif\n    ptls->defer_signal = eh->defer_signal;\n    ptls->gc_state = eh->gc_state;\n    ptls->finalizers_inhibited = eh->finalizers_inhibited;\n    if (old_gc_state && !eh->gc_state) {\n        jl_gc_safepoint_(ptls);\n    }\n    if (old_defer_signal && !eh->defer_signal) {\n        jl_sigint_safepoint(ptls);\n    }\n}\n\nJL_DLLEXPORT void jl_enter_handler(jl_handler_t *eh);\nJL_DLLEXPORT void jl_pop_handler(int n);\n\n#if defined(_OS_WINDOWS_)\n#if defined(_COMPILER_MINGW_)\nint __attribute__ ((__nothrow__,__returns_twice__)) jl_setjmp(jmp_buf _Buf);\n__declspec(noreturn) __attribute__ ((__nothrow__)) void jl_longjmp(jmp_buf _Buf,int _Value);\n#else\nint jl_setjmp(jmp_buf _Buf);\nvoid jl_longjmp(jmp_buf _Buf,int _Value);\n#endif\n#define jl_setjmp_f jl_setjmp\n#define jl_setjmp_name \"jl_setjmp\"\n#define jl_setjmp(a,b) jl_setjmp(a)\n#define jl_longjmp(a,b) jl_longjmp(a,b)\n#else\n// determine actual entry point name\n#if defined(sigsetjmp)\n#define jl_setjmp_f    __sigsetjmp\n#define jl_setjmp_name \"__sigsetjmp\"\n#else\n#define jl_setjmp_f    sigsetjmp\n#define jl_setjmp_name \"sigsetjmp\"\n#endif\n#define jl_setjmp(a,b) sigsetjmp(a,b)\n#define jl_longjmp(a,b) siglongjmp(a,b)\n#endif\n\n#define JL_TRY                                                    \\\n    int i__tr, i__ca; jl_handler_t __eh;                          \\\n    jl_enter_handler(&__eh);                                      \\\n    if (!jl_setjmp(__eh.eh_ctx,0))                                \\\n        for (i__tr=1; i__tr; i__tr=0, jl_eh_restore_state(&__eh))\n\n#define JL_EH_POP() jl_eh_restore_state(&__eh)\n\n#ifdef _OS_WINDOWS_\n#define JL_CATCH                                                \\\n    else                                                        \\\n        for (i__ca=1, jl_eh_restore_state(&__eh); i__ca; i__ca=0) \\\n            if (((jl_get_ptls_states()->exception_in_transit==jl_stackovf_exception) && _resetstkoflw()) || 1)\n#else\n#define JL_CATCH                                                \\\n    else                                                        \\\n        for (i__ca=1, jl_eh_restore_state(&__eh); i__ca; i__ca=0)\n#endif\n\n// I/O system -----------------------------------------------------------------\n\n#define JL_STREAM uv_stream_t\n#define JL_STDOUT jl_uv_stdout\n#define JL_STDERR jl_uv_stderr\n#define JL_STDIN  jl_uv_stdin\n\nJL_DLLEXPORT void jl_run_event_loop(uv_loop_t *loop);\nJL_DLLEXPORT int jl_run_once(uv_loop_t *loop);\nJL_DLLEXPORT int jl_process_events(uv_loop_t *loop);\n\nJL_DLLEXPORT uv_loop_t *jl_global_event_loop(void);\n\nJL_DLLEXPORT void jl_close_uv(uv_handle_t *handle);\n\nJL_DLLEXPORT int jl_tcp_bind(uv_tcp_t *handle, uint16_t port, uint32_t host,\n                             unsigned int flags);\n\nJL_DLLEXPORT int jl_sizeof_ios_t(void);\n\nJL_DLLEXPORT jl_array_t *jl_takebuf_array(ios_t *s);\nJL_DLLEXPORT jl_value_t *jl_takebuf_string(ios_t *s);\nJL_DLLEXPORT void *jl_takebuf_raw(ios_t *s);\nJL_DLLEXPORT jl_value_t *jl_readuntil(ios_t *s, uint8_t delim);\n\ntypedef struct {\n    void *data;\n    uv_loop_t *loop;\n    uv_handle_type type;\n    uv_file file;\n} jl_uv_file_t;\n\n#ifdef __GNUC__\n#define _JL_FORMAT_ATTR(type, str, arg) \\\n    __attribute__((format(type, str, arg)))\n#else\n#define _JL_FORMAT_ATTR(type, str, arg)\n#endif\n\nJL_DLLEXPORT int jl_printf(uv_stream_t *s, const char *format, ...)\n    _JL_FORMAT_ATTR(printf, 2, 3);\nJL_DLLEXPORT int jl_vprintf(uv_stream_t *s, const char *format, va_list args)\n    _JL_FORMAT_ATTR(printf, 2, 0);\nJL_DLLEXPORT void jl_safe_printf(const char *str, ...)\n    _JL_FORMAT_ATTR(printf, 1, 2);\n\nextern JL_DLLEXPORT JL_STREAM *JL_STDIN;\nextern JL_DLLEXPORT JL_STREAM *JL_STDOUT;\nextern JL_DLLEXPORT JL_STREAM *JL_STDERR;\n\nJL_DLLEXPORT JL_STREAM *jl_stdout_stream(void);\nJL_DLLEXPORT JL_STREAM *jl_stdin_stream(void);\nJL_DLLEXPORT JL_STREAM *jl_stderr_stream(void);\n\n// showing and std streams\nJL_DLLEXPORT void jl_show(jl_value_t *stream, jl_value_t *v);\nJL_DLLEXPORT void jl_flush_cstdio(void);\nJL_DLLEXPORT jl_value_t *jl_stdout_obj(void);\nJL_DLLEXPORT jl_value_t *jl_stderr_obj(void);\nJL_DLLEXPORT size_t jl_static_show(JL_STREAM *out, jl_value_t *v);\nJL_DLLEXPORT size_t jl_static_show_func_sig(JL_STREAM *s, jl_value_t *type);\nJL_DLLEXPORT void jlbacktrace(void);\n// Mainly for debugging, use `void*` so that no type cast is needed in C++.\nJL_DLLEXPORT void jl_(void *jl_value);\n\n// julia options -----------------------------------------------------------\n// NOTE: This struct needs to be kept in sync with JLOptions type in base/options.jl\ntypedef struct {\n    int8_t quiet;\n    const char *julia_home;\n    const char *julia_bin;\n    const char *eval;\n    const char *print;\n    const char *postboot;\n    const char *load;\n    const char *image_file;\n    const char *cpu_target;\n    int32_t nprocs;\n    const char *machinefile;\n    int8_t isinteractive;\n    int8_t color;\n    int8_t historyfile;\n    int8_t startupfile;\n    int8_t compile_enabled;\n    int8_t code_coverage;\n    int8_t malloc_log;\n    int8_t opt_level;\n    int8_t check_bounds;\n    int8_t depwarn;\n    int8_t can_inline;\n    int8_t fast_math;\n    const char *worker;\n    int8_t handle_signals;\n    int8_t use_precompiled;\n    int8_t use_compilecache;\n    const char *bindto;\n    const char *outputbc;\n    const char *outputo;\n    const char *outputji;\n    int8_t incremental;\n    int8_t image_file_specified;\n} jl_options_t;\n\nextern JL_DLLEXPORT jl_options_t jl_options;\n\n// Parse an argc/argv pair to extract general julia options, passing back out\n// any arguments that should be passed on to the script.\nJL_DLLEXPORT void jl_parse_opts(int *argcp, char ***argvp);\n\n// Set julia-level ARGS array according to the arguments provided in\n// argc/argv\nJL_DLLEXPORT void jl_set_ARGS(int argc, char **argv);\n\nJL_DLLEXPORT int jl_generating_output(void);\n\n// Settings for code_coverage and malloc_log\n// NOTE: if these numbers change, test/cmdlineargs.jl will have to be updated\n#define JL_LOG_NONE 0\n#define JL_LOG_USER 1\n#define JL_LOG_ALL  2\n\n#define JL_OPTIONS_CHECK_BOUNDS_DEFAULT 0\n#define JL_OPTIONS_CHECK_BOUNDS_ON 1\n#define JL_OPTIONS_CHECK_BOUNDS_OFF 2\n\n#define JL_OPTIONS_COMPILE_DEFAULT 1\n#define JL_OPTIONS_COMPILE_OFF 0\n#define JL_OPTIONS_COMPILE_ON  1\n#define JL_OPTIONS_COMPILE_ALL 2\n#define JL_OPTIONS_COMPILE_MIN 3\n\n#define JL_OPTIONS_COLOR_ON 1\n#define JL_OPTIONS_COLOR_OFF 2\n\n#define JL_OPTIONS_HISTORYFILE_ON 1\n#define JL_OPTIONS_HISTORYFILE_OFF 0\n\n#define JL_OPTIONS_STARTUPFILE_ON 1\n#define JL_OPTIONS_STARTUPFILE_OFF 2\n\n#define JL_OPTIONS_DEPWARN_OFF 0\n#define JL_OPTIONS_DEPWARN_ON 1\n#define JL_OPTIONS_DEPWARN_ERROR 2\n\n#define JL_OPTIONS_FAST_MATH_ON 1\n#define JL_OPTIONS_FAST_MATH_OFF 2\n#define JL_OPTIONS_FAST_MATH_DEFAULT 0\n\n#define JL_OPTIONS_HANDLE_SIGNALS_ON 1\n#define JL_OPTIONS_HANDLE_SIGNALS_OFF 0\n\n#define JL_OPTIONS_USE_PRECOMPILED_YES 1\n#define JL_OPTIONS_USE_PRECOMPILED_NO 0\n\n#define JL_OPTIONS_USE_COMPILECACHE_YES 1\n#define JL_OPTIONS_USE_COMPILECACHE_NO 0\n\n// Version information\n#include <julia_version.h>\n\nJL_DLLEXPORT extern int jl_ver_major(void);\nJL_DLLEXPORT extern int jl_ver_minor(void);\nJL_DLLEXPORT extern int jl_ver_patch(void);\nJL_DLLEXPORT extern int jl_ver_is_release(void);\nJL_DLLEXPORT extern const char *jl_ver_string(void);\nJL_DLLEXPORT const char *jl_git_branch(void);\nJL_DLLEXPORT const char *jl_git_commit(void);\n\n// nullable struct representations\ntypedef struct {\n    uint8_t isnull;\n    double value;\n} jl_nullable_float64_t;\n\ntypedef struct {\n    uint8_t isnull;\n    float value;\n} jl_nullable_float32_t;\n\n#define jl_current_module (jl_get_ptls_states()->current_module)\n#define jl_current_task (jl_get_ptls_states()->current_task)\n#define jl_root_task (jl_get_ptls_states()->root_task)\n#define jl_exception_in_transit (jl_get_ptls_states()->exception_in_transit)\n#define jl_task_arg_in_transit (jl_get_ptls_states()->task_arg_in_transit)\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/jitlayers.cpp": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n#include \"llvm-version.h\"\n#include \"platform.h\"\n#include \"options.h\"\n#include <iostream>\n#include <sstream>\n\n// analysis passes\n#include <llvm/Analysis/Passes.h>\n#ifdef LLVM38\n#include <llvm/Analysis/BasicAliasAnalysis.h>\n#include <llvm/Analysis/TypeBasedAliasAnalysis.h>\n#endif\n#ifdef LLVM37\n#include <llvm/Analysis/TargetTransformInfo.h>\n#include <llvm/Analysis/TargetLibraryInfo.h>\n#endif\n#ifdef LLVM35\n#include <llvm/IR/Verifier.h>\n#else\n#include <llvm/Analysis/Verifier.h>\n#endif\n#if defined(USE_POLLY)\n#include <polly/RegisterPasses.h>\n#endif\n\n#include <llvm/Transforms/Scalar.h>\n#include <llvm/Transforms/Utils/BasicBlockUtils.h>\n#include <llvm/Transforms/Instrumentation.h>\n#include <llvm/Transforms/Vectorize.h>\n#ifdef LLVM39\n#include <llvm/Transforms/Scalar/GVN.h>\n#endif\n\nnamespace llvm {\n    extern Pass *createLowerSimdLoopPass();\n}\n\n#include <llvm/Bitcode/ReaderWriter.h>\n#ifdef LLVM35\n#include <llvm/Bitcode/BitcodeWriterPass.h>\n#endif\n\n#include <llvm/Transforms/Utils/Cloning.h>\n#include <llvm/ExecutionEngine/JITEventListener.h>\n\n// target support\n#include <llvm/ADT/Triple.h>\n#include <llvm/Support/TargetRegistry.h>\n#ifndef LLVM37\n#include <llvm/Target/TargetLibraryInfo.h>\n#endif\n#include <llvm/IR/DataLayout.h>\n#include <llvm/Support/DynamicLibrary.h>\n\n\n#include <llvm/Support/raw_ostream.h>\n#include <llvm/Support/FormattedStream.h>\n\nusing namespace llvm;\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"jitlayers.h\"\n#ifdef USE_MCJIT\nRTDyldMemoryManager* createRTDyldMemoryManager(void);\n#endif\n\nstatic Type *T_void;\nstatic IntegerType *T_uint32;\nstatic IntegerType *T_uint64;\nstatic IntegerType *T_size;\nstatic Type *T_psize;\nstatic Type *T_pvoidfunc;\nstatic Type *T_pjlvalue;\nvoid jl_init_jit(Type *T_pjlvalue_)\n{\n    T_void = Type::getVoidTy(jl_LLVMContext);\n    T_uint32 = Type::getInt32Ty(jl_LLVMContext);\n    T_uint64 = Type::getInt64Ty(jl_LLVMContext);\n    if (sizeof(size_t) == 8)\n        T_size = T_uint64;\n    else\n        T_size = T_uint32;\n    T_psize = PointerType::get(T_size, 0);\n    T_pvoidfunc = FunctionType::get(T_void, /*isVarArg*/false)->getPointerTo();\n    T_pjlvalue = T_pjlvalue_;\n}\n\n// Except for parts of this file which were copied from LLVM, under the UIUC license (marked below).\n\n// this defines the set of optimization passes defined for Julia at various optimization levels\n#ifdef LLVM37\nvoid addOptimizationPasses(legacy::PassManager *PM)\n#else\nvoid addOptimizationPasses(PassManager *PM)\n#endif\n{\n    PM->add(createLowerGCFramePass(tbaa_gcframe));\n#ifdef JL_DEBUG_BUILD\n    PM->add(createVerifierPass());\n#endif\n\n#if defined(JL_ASAN_ENABLED)\n#   if defined(LLVM37) && !defined(LLVM38)\n    // LLVM 3.7 BUG: ASAN pass doesn't properly initialize its dependencies\n    initializeTargetLibraryInfoWrapperPassPass(*PassRegistry::getPassRegistry());\n#   endif\n    PM->add(createAddressSanitizerFunctionPass());\n#endif\n#if defined(JL_MSAN_ENABLED)\n    PM->add(llvm::createMemorySanitizerPass(true));\n#endif\n    if (jl_options.opt_level == 0) {\n        PM->add(createLowerPTLSPass(imaging_mode, tbaa_const));\n        return;\n    }\n#ifdef LLVM37\n    PM->add(createTargetTransformInfoWrapperPass(jl_TargetMachine->getTargetIRAnalysis()));\n#else\n    jl_TargetMachine->addAnalysisPasses(*PM);\n#endif\n#ifdef LLVM38\n    PM->add(createTypeBasedAAWrapperPass());\n#else\n    PM->add(createTypeBasedAliasAnalysisPass());\n#endif\n    if (jl_options.opt_level >= 3) {\n#ifdef LLVM38\n        PM->add(createBasicAAWrapperPass());\n#else\n        PM->add(createBasicAliasAnalysisPass());\n#endif\n    }\n    // list of passes from vmkit\n    PM->add(createCFGSimplificationPass()); // Clean up disgusting code\n    PM->add(createPromoteMemoryToRegisterPass());// Kill useless allocas\n\n#ifndef INSTCOMBINE_BUG\n    PM->add(createInstructionCombiningPass()); // Cleanup for scalarrepl.\n#endif\n    // Let the InstCombine pass remove the unnecessary load of\n    // safepoint address first\n    PM->add(createLowerPTLSPass(imaging_mode, tbaa_const));\n    PM->add(createSROAPass());                 // Break up aggregate allocas\n#ifndef INSTCOMBINE_BUG\n    PM->add(createInstructionCombiningPass()); // Cleanup for scalarrepl.\n#endif\n    PM->add(createJumpThreadingPass());        // Thread jumps.\n    // NOTE: CFG simp passes after this point seem to hurt native codegen.\n    // See issue #6112. Should be re-evaluated when we switch to MCJIT.\n    //PM->add(createCFGSimplificationPass());    // Merge & remove BBs\n#ifndef INSTCOMBINE_BUG\n    PM->add(createInstructionCombiningPass()); // Combine silly seq's\n#endif\n\n    //PM->add(createCFGSimplificationPass());    // Merge & remove BBs\n    PM->add(createReassociatePass());          // Reassociate expressions\n\n    // this has the potential to make some things a bit slower\n    //PM->add(createBBVectorizePass());\n\n    PM->add(createEarlyCSEPass()); //// ****\n\n#ifdef USE_POLLY\n    polly::registerPollyPasses(*PM);\n#endif\n\n    PM->add(createLoopIdiomPass()); //// ****\n    PM->add(createLoopRotatePass());           // Rotate loops.\n    // LoopRotate strips metadata from terminator, so run LowerSIMD afterwards\n    PM->add(createLowerSimdLoopPass());        // Annotate loop marked with \"simdloop\" as LLVM parallel loop\n    PM->add(createLICMPass());                 // Hoist loop invariants\n    PM->add(createLoopUnswitchPass());         // Unswitch loops.\n    // Subsequent passes not stripping metadata from terminator\n#ifndef INSTCOMBINE_BUG\n    PM->add(createInstructionCombiningPass());\n#endif\n    PM->add(createIndVarSimplifyPass());       // Canonicalize indvars\n    PM->add(createLoopDeletionPass());         // Delete dead loops\n#if defined(LLVM35)\n    PM->add(createSimpleLoopUnrollPass());     // Unroll small loops\n#else\n    PM->add(createLoopUnrollPass());           // Unroll small loops\n#endif\n#if !defined(LLVM35) && !defined(INSTCOMBINE_BUG)\n    PM->add(createLoopVectorizePass());        // Vectorize loops\n#endif\n    //PM->add(createLoopStrengthReducePass());   // (jwb added)\n\n#ifndef INSTCOMBINE_BUG\n    PM->add(createInstructionCombiningPass()); // Clean up after the unroller\n#endif\n    PM->add(createGVNPass());                  // Remove redundancies\n    PM->add(createMemCpyOptPass());            // Remove memcpy / form memset\n    PM->add(createSCCPPass());                 // Constant prop with SCCP\n\n    // Run instcombine after redundancy elimination to exploit opportunities\n    // opened up by them.\n    PM->add(createSinkingPass()); ////////////// ****\n    PM->add(createInstructionSimplifierPass());///////// ****\n#ifndef INSTCOMBINE_BUG\n    PM->add(createInstructionCombiningPass());\n#endif\n    PM->add(createJumpThreadingPass());         // Thread jumps\n    PM->add(createDeadStoreEliminationPass());  // Delete dead stores\n#if !defined(INSTCOMBINE_BUG)\n    if (jl_options.opt_level >= 3) {\n        PM->add(createSLPVectorizerPass());     // Vectorize straight-line code\n    }\n#endif\n\n    PM->add(createAggressiveDCEPass());         // Delete dead instructions\n#if !defined(INSTCOMBINE_BUG)\n    if (jl_options.opt_level >= 3)\n        PM->add(createInstructionCombiningPass());   // Clean up after SLP loop vectorizer\n#endif\n#if defined(LLVM35)\n    PM->add(createLoopVectorizePass());         // Vectorize loops\n    PM->add(createInstructionCombiningPass());  // Clean up after loop vectorizer\n#endif\n    //PM->add(createCFGSimplificationPass());     // Merge & remove BBs\n}\n\n#ifdef USE_ORCJIT\n\n#ifndef LLVM38\nvoid notifyObjectLoaded(RTDyldMemoryManager *memmgr,\n                        llvm::orc::ObjectLinkingLayerBase::ObjSetHandleT H);\n#endif\n\n// ------------------------ TEMPORARILY COPIED FROM LLVM -----------------\n// This must be kept in sync with gdb/gdb/jit.h .\nextern \"C\" {\n\n  typedef enum {\n    JIT_NOACTION = 0,\n    JIT_REGISTER_FN,\n    JIT_UNREGISTER_FN\n  } jit_actions_t;\n\n  struct jit_code_entry {\n    struct jit_code_entry *next_entry;\n    struct jit_code_entry *prev_entry;\n    const char *symfile_addr;\n    uint64_t symfile_size;\n  };\n\n  struct jit_descriptor {\n    uint32_t version;\n    // This should be jit_actions_t, but we want to be specific about the\n    // bit-width.\n    uint32_t action_flag;\n    struct jit_code_entry *relevant_entry;\n    struct jit_code_entry *first_entry;\n  };\n\n  // We put information about the JITed function in this global, which the\n  // debugger reads.  Make sure to specify the version statically, because the\n  // debugger checks the version before we can set it during runtime.\n  extern struct jit_descriptor __jit_debug_descriptor;\n\n  LLVM_ATTRIBUTE_NOINLINE extern void __jit_debug_register_code();\n}\n\nnamespace {\n\nusing namespace llvm;\nusing namespace llvm::object;\nusing namespace llvm::orc;\n\n/// Do the registration.\nvoid NotifyDebugger(jit_code_entry *JITCodeEntry)\n{\n    __jit_debug_descriptor.action_flag = JIT_REGISTER_FN;\n\n    // Insert this entry at the head of the list.\n    JITCodeEntry->prev_entry = nullptr;\n    jit_code_entry *NextEntry = __jit_debug_descriptor.first_entry;\n    JITCodeEntry->next_entry = NextEntry;\n    if (NextEntry) {\n        NextEntry->prev_entry = JITCodeEntry;\n    }\n    __jit_debug_descriptor.first_entry = JITCodeEntry;\n    __jit_debug_descriptor.relevant_entry = JITCodeEntry;\n    __jit_debug_register_code();\n}\n}\n// ------------------------ END OF TEMPORARY COPY FROM LLVM -----------------\n\n#ifdef _OS_LINUX_\n// Resolve non-lock free atomic functions in the libatomic library.\n// This is the library that provides support for c11/c++11 atomic operations.\nstatic uint64_t resolve_atomic(const char *name)\n{\n    static void *atomic_hdl = jl_load_dynamic_library_e(\"libatomic\",\n                                                        JL_RTLD_LOCAL);\n    static const char *const atomic_prefix = \"__atomic_\";\n    if (!atomic_hdl)\n        return 0;\n    if (strncmp(name, atomic_prefix, strlen(atomic_prefix)) != 0)\n        return 0;\n    return (uintptr_t)jl_dlsym_e(atomic_hdl, name);\n}\n#endif\n\n// Custom object emission notification handler for the JuliaOJIT\nextern JITEventListener *CreateJuliaJITEventListener();\nJuliaOJIT::DebugObjectRegistrar::DebugObjectRegistrar(JuliaOJIT &JIT)\n    : JuliaListener(CreateJuliaJITEventListener()),\n      JIT(JIT) {}\n\nJL_DLLEXPORT void ORCNotifyObjectEmitted(JITEventListener *Listener,\n                                         const object::ObjectFile &obj,\n                                         const object::ObjectFile &debugObj,\n                                         const RuntimeDyld::LoadedObjectInfo &L,\n                                         RTDyldMemoryManager *memmgr);\n\n// TODO: hook up RegisterJITEventListener, instead of hard-coding the GDB and JuliaListener targets\ntemplate <typename ObjSetT, typename LoadResult>\nvoid JuliaOJIT::DebugObjectRegistrar::operator()(ObjectLinkingLayerBase::ObjSetHandleT H, const ObjSetT &Objects,\n                const LoadResult &LOS)\n{\n#ifndef LLVM38\n    notifyObjectLoaded(JIT.MemMgr, H);\n#endif\n    auto oit = Objects.begin();\n    auto lit = LOS.begin();\n    for (; oit != Objects.end(); ++oit, ++lit) {\n#ifdef LLVM39\n        const auto &Object = (*oit)->getBinary();\n#else\n        auto &Object = *oit;\n#endif\n        auto &LO = *lit;\n\n        OwningBinary<object::ObjectFile> SavedObject = LO->getObjectForDebug(*Object);\n\n        // If the debug object is unavailable, save (a copy of) the original object\n        // for our backtraces\n        if (!SavedObject.getBinary()) {\n            // This is unfortunate, but there doesn't seem to be a way to take\n            // ownership of the original buffer\n            auto NewBuffer = MemoryBuffer::getMemBufferCopy(Object->getData(), Object->getFileName());\n            auto NewObj = ObjectFile::createObjectFile(NewBuffer->getMemBufferRef());\n            assert(NewObj);\n            SavedObject = OwningBinary<object::ObjectFile>(std::move(*NewObj),std::move(NewBuffer));\n        }\n        else {\n            NotifyGDB(SavedObject);\n        }\n\n        SavedObjects.push_back(std::move(SavedObject));\n\n        ORCNotifyObjectEmitted(JuliaListener.get(),\n                *Object,\n                *SavedObjects.back().getBinary(),\n                *LO, JIT.MemMgr);\n\n        // record all of the exported symbols defined in this object\n        // in the primary hash table for the enclosing JIT\n        for (auto &Symbol : Object->symbols()) {\n            auto Flags = Symbol.getFlags();\n            if (Flags & object::BasicSymbolRef::SF_Undefined)\n                continue;\n            if (!(Flags & object::BasicSymbolRef::SF_Exported))\n                continue;\n            auto NameOrError = Symbol.getName();\n            assert(NameOrError);\n            auto Name = NameOrError.get();\n            orc::JITSymbol Sym = JIT.CompileLayer.findSymbolIn(H, Name, true);\n            assert(Sym);\n            // note: calling getAddress here eagerly finalizes H\n            // as an alternative, we could store the JITSymbol instead\n            // (which would present a lazy-initializer functor interface instead)\n            JIT.LocalSymbolTable[Name] = (void*)(uintptr_t)Sym.getAddress();\n        }\n    }\n}\n\nvoid JuliaOJIT::DebugObjectRegistrar::NotifyGDB(OwningBinary<object::ObjectFile> &DebugObj)\n{\n    const char *Buffer = DebugObj.getBinary()->getMemoryBufferRef().getBufferStart();\n    size_t      Size = DebugObj.getBinary()->getMemoryBufferRef().getBufferSize();\n\n    assert(Buffer && \"Attempt to register a null object with a debugger.\");\n    jit_code_entry *JITCodeEntry = new jit_code_entry();\n\n    if (!JITCodeEntry) {\n        jl_printf(JL_STDERR, \"WARNING: Allocation failed when registering a JIT entry!\\n\");\n    }\n    else {\n        JITCodeEntry->symfile_addr = Buffer;\n        JITCodeEntry->symfile_size = Size;\n\n        NotifyDebugger(JITCodeEntry);\n    }\n}\n\nJuliaOJIT::JuliaOJIT(TargetMachine &TM)\n  : TM(TM),\n    DL(TM.createDataLayout()),\n    ObjStream(ObjBufferSV),\n    MemMgr(createRTDyldMemoryManager()),\n    ObjectLayer(DebugObjectRegistrar(*this)),\n    CompileLayer(\n            ObjectLayer,\n            [this](Module &M) {\n                JL_TIMING(LLVM_OPT);\n                PM.run(M);\n                std::unique_ptr<MemoryBuffer> ObjBuffer(\n                    new ObjectMemoryBuffer(std::move(ObjBufferSV)));\n                auto Obj = object::ObjectFile::createObjectFile(ObjBuffer->getMemBufferRef());\n\n                if (!Obj) {\n                    M.dump();\n#ifdef LLVM39\n                    std::string Buf;\n                    raw_string_ostream OS(Buf);\n                    logAllUnhandledErrors(Obj.takeError(), OS, \"\");\n                    OS.flush();\n                    llvm::report_fatal_error(\"FATAL: Unable to compile LLVM Module: '\" + Buf + \"'\\n\"\n                        \"The module's content was printed above. Please file a bug report\");\n#else\n                    llvm::report_fatal_error(\"FATAL: Unable to compile LLVM Module.\\n\"\n                        \"The module's content was printed above. Please file a bug report\");\n#endif\n                }\n\n                return OwningObj(std::move(*Obj), std::move(ObjBuffer));\n            }\n        )\n{\n    addOptimizationPasses(&PM);\n    if (TM.addPassesToEmitMC(PM, Ctx, ObjStream))\n        llvm_unreachable(\"Target does not support MC emission.\");\n\n    // Make sure SectionMemoryManager::getSymbolAddressInProcess can resolve\n    // symbols in the program as well. The nullptr argument to the function\n    // tells DynamicLibrary to load the program, not a library.\n    std::string *ErrorStr = nullptr;\n    if (sys::DynamicLibrary::LoadLibraryPermanently(nullptr, ErrorStr))\n        report_fatal_error(\"FATAL: unable to dlopen self\\n\" + *ErrorStr);\n}\n\nvoid JuliaOJIT::addGlobalMapping(StringRef Name, uint64_t Addr)\n{\n    bool successful = GlobalSymbolTable.insert(std::make_pair(Name, (void*)Addr)).second;\n    (void)successful;\n    assert(successful);\n}\n\nvoid JuliaOJIT::addGlobalMapping(const GlobalValue *GV, void *Addr)\n{\n    addGlobalMapping(getMangledName(GV), (uintptr_t)Addr);\n}\n\nvoid *JuliaOJIT::getPointerToGlobalIfAvailable(StringRef S)\n{\n    SymbolTableT::const_iterator pos = GlobalSymbolTable.find(S);\n    if (pos != GlobalSymbolTable.end())\n        return pos->second;\n    return nullptr;\n}\n\nvoid *JuliaOJIT::getPointerToGlobalIfAvailable(const GlobalValue *GV)\n{\n    return getPointerToGlobalIfAvailable(getMangledName(GV));\n}\n\n\nvoid JuliaOJIT::addModule(std::unique_ptr<Module> M)\n{\n#ifndef NDEBUG\n    // validate the relocations for M\n    for (Module::iterator I = M->begin(), E = M->end(); I != E; ) {\n        Function *F = &*I;\n        ++I;\n        if (F->isDeclaration()) {\n            if (F->use_empty())\n                F->eraseFromParent();\n            else if (!(isIntrinsicFunction(F) ||\n                       findUnmangledSymbol(F->getName()) ||\n                       SectionMemoryManager::getSymbolAddressInProcess(\n                           F->getName()))) {\n                std::cerr << \"FATAL ERROR: \"\n                          << \"Symbol \\\"\" << F->getName().str() << \"\\\"\"\n                          << \"not found\";\n                abort();\n            }\n        }\n    }\n#endif\n    JL_TIMING(LLVM_MODULE_FINISH);\n    // We need a memory manager to allocate memory and resolve symbols for this\n    // new module. Create one that resolves symbols by looking back into the JIT.\n    auto Resolver = orc::createLambdaResolver(\n                      [&](const std::string &Name) {\n                        // TODO: consider moving the FunctionMover resolver here\n                        // Step 0: ObjectLinkingLayer has checked whether it is in the current module\n                        // Step 1: See if it's something known to the ExecutionEngine\n                        if (auto Sym = findSymbol(Name, true))\n                          return RuntimeDyld::SymbolInfo(Sym.getAddress(),\n                                                         Sym.getFlags());\n                        // Step 2: Search the program symbols\n                        if (uint64_t addr = SectionMemoryManager::getSymbolAddressInProcess(Name))\n                            return RuntimeDyld::SymbolInfo(addr, JITSymbolFlags::Exported);\n#ifdef _OS_LINUX_\n                        if (uint64_t addr = resolve_atomic(Name.c_str()))\n                            return RuntimeDyld::SymbolInfo(addr, JITSymbolFlags::Exported);\n#endif\n                        // Return failure code\n                        return RuntimeDyld::SymbolInfo(nullptr);\n                      },\n                      [](const std::string &S) { return nullptr; }\n                    );\n    SmallVector<std::unique_ptr<Module>,1> Ms;\n    Ms.push_back(std::move(M));\n    auto modset = CompileLayer.addModuleSet(std::move(Ms), MemMgr,\n                                            std::move(Resolver));\n    // Force LLVM to emit the module so that we can register the symbols\n    // in our lookup table.\n    CompileLayer.emitAndFinalize(modset);\n}\n\nvoid JuliaOJIT::removeModule(ModuleHandleT H)\n{\n    CompileLayer.removeModuleSet(H);\n}\n\norc::JITSymbol JuliaOJIT::findSymbol(const std::string &Name, bool ExportedSymbolsOnly)\n{\n    void *Addr = nullptr;\n    if (ExportedSymbolsOnly) {\n        // Step 1: Check against list of known external globals\n        Addr = getPointerToGlobalIfAvailable(Name);\n    }\n    // Step 2: Search all previously emitted symbols\n    if (Addr == nullptr)\n        Addr = LocalSymbolTable[Name];\n    return orc::JITSymbol((uintptr_t)Addr, JITSymbolFlags::Exported);\n}\n\norc::JITSymbol JuliaOJIT::findUnmangledSymbol(const std::string Name)\n{\n    return findSymbol(getMangledName(Name), true);\n}\n\nuint64_t JuliaOJIT::getGlobalValueAddress(const std::string &Name)\n{\n    return findSymbol(getMangledName(Name), false).getAddress();\n}\n\nuint64_t JuliaOJIT::getFunctionAddress(const std::string &Name)\n{\n    return findSymbol(getMangledName(Name), false).getAddress();\n}\n\nFunction *JuliaOJIT::FindFunctionNamed(const std::string &Name)\n{\n    return shadow_output->getFunction(Name);\n}\n\nvoid JuliaOJIT::RegisterJITEventListener(JITEventListener *L)\n{\n    // TODO\n}\n\nconst DataLayout& JuliaOJIT::getDataLayout() const\n{\n    return DL;\n}\n\nconst Triple& JuliaOJIT::getTargetTriple() const\n{\n    return TM.getTargetTriple();\n}\n\nstd::string JuliaOJIT::getMangledName(const std::string &Name)\n{\n    SmallString<128> FullName;\n    Mangler::getNameWithPrefix(FullName, Name, DL);\n    return FullName.str();\n}\n\nstd::string JuliaOJIT::getMangledName(const GlobalValue *GV)\n{\n    return getMangledName(GV->getName());\n}\n\nJuliaOJIT *jl_ExecutionEngine;\n#else\nExecutionEngine *jl_ExecutionEngine;\n#endif\n\n// MSVC's link.exe requires each function declaration to have a Comdat section\n// So rather than litter the code with conditionals,\n// all global values that get emitted call this function\n// and it decides whether the definition needs a Comdat section and adds the appropriate declaration\n// TODO: consider moving this into jl_add_to_shadow or jl_dump_shadow? the JIT doesn't care, so most calls are now no-ops\ntemplate<class T> // for GlobalObject's\nstatic T *addComdat(T *G)\n{\n#if defined(_OS_WINDOWS_) && defined(LLVM35)\n    if (imaging_mode && !G->isDeclaration()) {\n        // Add comdat information to make MSVC link.exe happy\n        // it's valid to emit this for ld.exe too,\n        // but makes it very slow to link for no benefit\n        if (G->getParent() == shadow_output) {\n#if defined(_COMPILER_MICROSOFT_)\n            Comdat *jl_Comdat = G->getParent()->getOrInsertComdat(G->getName());\n            // ELF only supports Comdat::Any\n            jl_Comdat->setSelectionKind(Comdat::NoDuplicates);\n            G->setComdat(jl_Comdat);\n#endif\n#if defined(_CPU_X86_64_)\n            // Add unwind exception personalities to functions to handle async exceptions\n            assert(!juliapersonality_func || juliapersonality_func->getParent() == shadow_output);\n            if (Function *F = dyn_cast<Function>(G))\n                F->setPersonalityFn(juliapersonality_func);\n#endif\n        }\n        // add __declspec(dllexport) to everything marked for export\n        if (G->getLinkage() == GlobalValue::ExternalLinkage)\n            G->setDLLStorageClass(GlobalValue::DLLExportStorageClass);\n        else\n            G->setDLLStorageClass(GlobalValue::DefaultStorageClass);\n    }\n#endif\n    return G;\n}\n\n// destructively move the contents of src into dest\n// this assumes that the targets of the two modules are the same\n// including the DataLayout and ModuleFlags (for example)\n// and that there is no module-level assembly\nstatic void jl_merge_module(Module *dest, std::unique_ptr<Module> src)\n{\n    assert(dest != src.get());\n    for (Module::global_iterator I = src->global_begin(), E = src->global_end(); I != E;) {\n        GlobalVariable *sG = &*I;\n        GlobalValue *dG = dest->getNamedValue(sG->getName());\n        ++I;\n        // Replace a declaration with the definition:\n        if (dG) {\n            if (sG->isDeclaration()) {\n                sG->replaceAllUsesWith(dG);\n                sG->eraseFromParent();\n                continue;\n            }\n            else {\n                dG->replaceAllUsesWith(sG);\n                dG->eraseFromParent();\n            }\n        }\n        // Reparent the global variable:\n        sG->removeFromParent();\n        dest->getGlobalList().push_back(sG);\n        // Comdat is owned by the Module, recreate it in the new parent:\n        addComdat(sG);\n    }\n\n    for (Module::iterator I = src->begin(), E = src->end(); I != E;) {\n        Function *sG = &*I;\n        GlobalValue *dG = dest->getNamedValue(sG->getName());\n        ++I;\n        // Replace a declaration with the definition:\n        if (dG) {\n            if (sG->isDeclaration()) {\n                sG->replaceAllUsesWith(dG);\n                sG->eraseFromParent();\n                continue;\n            }\n            else {\n                dG->replaceAllUsesWith(sG);\n                dG->eraseFromParent();\n            }\n        }\n        // Reparent the global variable:\n        sG->removeFromParent();\n        dest->getFunctionList().push_back(sG);\n        // Comdat is owned by the Module, recreate it in the new parent:\n        addComdat(sG);\n    }\n\n    for (Module::alias_iterator I = src->alias_begin(), E = src->alias_end(); I != E;) {\n        GlobalAlias *sG = &*I;\n        GlobalValue *dG = dest->getNamedValue(sG->getName());\n        ++I;\n        if (dG) {\n            if (!dG->isDeclaration()) { // aliases are always definitions, so this test is reversed from the above two\n                sG->replaceAllUsesWith(dG);\n                sG->eraseFromParent();\n                continue;\n            }\n            else {\n                dG->replaceAllUsesWith(sG);\n                dG->eraseFromParent();\n            }\n        }\n        sG->removeFromParent();\n        dest->getAliasList().push_back(sG);\n    }\n\n    // metadata nodes need to be explicitly merged not just copied\n    // so there are special passes here for each known type of metadata\n    NamedMDNode *sNMD = src->getNamedMetadata(\"llvm.dbg.cu\");\n    if (sNMD) {\n        NamedMDNode *dNMD = dest->getOrInsertNamedMetadata(\"llvm.dbg.cu\");\n#ifdef LLVM35\n        for (NamedMDNode::op_iterator I = sNMD->op_begin(), E = sNMD->op_end(); I != E; ++I) {\n            dNMD->addOperand(*I);\n        }\n#else\n        for (unsigned i = 0, l = sNMD->getNumOperands(); i < l; i++) {\n            dNMD->addOperand(sNMD->getOperand(i));\n        }\n#endif\n    }\n}\n\n// to finalizing a function, look up its name in the `module_for_fname` map of unfinalized functions\n// and merge it, plus any other modules it depends upon, into `collector`\n// then add `collector` to the execution engine\n//\n// in the old JIT, functions are finalized by adding them to the shadow module\n// (which aliases the engine module), so this is unneeded\n#ifdef USE_MCJIT\nstatic StringMap<Module*> module_for_fname;\nstatic void jl_finalize_function(const std::string &F, Module *collector)\n{\n    std::unique_ptr<Module> m(module_for_fname.lookup(F));\n    if (m) {\n        // probably not many unresolved declarations, but be sure iterate over their Names,\n        // since the declarations may get destroyed by the jl_merge_module call.\n        // this is also why we copy the Name string, rather than save a StringRef\n        SmallVector<std::string, 8> to_finalize;\n        for (Module::iterator I = m->begin(), E = m->end(); I != E; ++I) {\n            Function *F = &*I;\n            if (!F->isDeclaration()) {\n                module_for_fname.erase(F->getName());\n            }\n            else if (!isIntrinsicFunction(F)) {\n                to_finalize.push_back(F->getName().str());\n            }\n        }\n\n        for (const auto F : to_finalize) {\n            jl_finalize_function(F, collector ? collector : m.get());\n        }\n\n        if (collector) {\n            jl_merge_module(collector, std::move(m));\n        }\n        else {\n#if defined(_CPU_X86_64_) && defined(_OS_WINDOWS_) && defined(LLVM35)\n            // Add special values used by debuginfo to build the UnwindData table registration for Win64\n            ArrayType *atype = ArrayType::get(T_uint32, 3); // want 4-byte alignment of 12-bytes of data\n            (new GlobalVariable(*m, atype,\n                false, GlobalVariable::InternalLinkage,\n                ConstantAggregateZero::get(atype), \"__UnwindData\"))->setSection(\".text\");\n            (new GlobalVariable(*m, atype,\n                false, GlobalVariable::InternalLinkage,\n                ConstantAggregateZero::get(atype), \"__catchjmp\"))->setSection(\".text\");\n#endif\n            assert(jl_ExecutionEngine);\n#if defined(LLVM36)\n            jl_ExecutionEngine->addModule(std::move(m));\n#else\n            jl_ExecutionEngine->addModule(m.release());\n#endif\n        }\n    }\n}\nvoid jl_finalize_function(Function *F, Module *collector)\n{\n    jl_finalize_function(F->getName().str(), collector);\n}\n#endif\n\n// this takes ownership of a module after code emission is complete\n// and will add it to the execution engine when required (by jl_finalize_function)\nvoid jl_finalize_module(Module *m, bool shadow)\n{\n#if !defined(USE_ORCJIT)\n    jl_globalPM->run(*m);\n#endif\n#ifdef USE_MCJIT\n    // record the function names that are part of this Module\n    // so it can be added to the JIT when needed\n    for (Module::iterator I = m->begin(), E = m->end(); I != E; ++I) {\n        Function *F = &*I;\n        if (!F->isDeclaration())\n            module_for_fname[F->getName()] = m;\n    }\n#endif\n#if defined(USE_ORCJIT) || defined(USE_MCJIT)\n    // in the newer JITs, the shadow module is separate from the execution module\n    if (shadow)\n#endif\n        jl_add_to_shadow(m);\n}\n\n// helper function for adding a DLLImport (dlsym) address to the execution engine\n// (for values created locally or in the sysimage, jl_emit_and_add_to_shadow is generally preferable)\n#ifdef LLVM35\nvoid add_named_global(GlobalObject *gv, void *addr, bool dllimport)\n#else\nvoid add_named_global(GlobalValue *gv, void *addr, bool dllimport)\n#endif\n{\n#ifdef _OS_WINDOWS_\n    // setting JL_DLLEXPORT correctly only matters when building a binary\n    // (global_proto will strip this from the JIT)\n    if (dllimport && imaging_mode) {\n        assert(gv->getLinkage() == GlobalValue::ExternalLinkage);\n#ifdef LLVM35\n        // add the __declspec(dllimport) attribute\n        gv->setDLLStorageClass(GlobalValue::DLLImportStorageClass);\n#else\n        gv->setLinkage(GlobalValue::DLLImportLinkage);\n#if defined(_P64)\n        // __imp_ variables are indirection pointers, so use malloc to simulate that\n        void **imp_addr = (void**)malloc(sizeof(void*));\n        *imp_addr = addr;\n        addr = (void*)imp_addr;\n#endif\n#endif\n    }\n#endif // _OS_WINDOWS_\n\n    jl_ExecutionEngine->addGlobalMapping(gv, addr);\n}\n\nstatic std::vector<Constant*> jl_sysimg_gvars;\nstatic std::vector<Constant*> jl_sysimg_fvars;\nstatic std::map<void*, jl_value_llvm> jl_value_to_llvm;\n\n// global variables to pointers are pretty common,\n// so this method is available as a convenience for emitting them.\n// for other types, the formula for implementation is straightforward:\n// (see stringConstPtr, for an alternative example to the code below)\n//\n// if in imaging_mode, emit a GlobalVariable with the same name and an initializer to the shadow_module\n// making it valid for emission and reloading in the sysimage\n//\n// then add a global mapping to the current value (usually from calloc'd space)\n// to the execution engine to make it valid for the current session (with the current value)\nvoid* jl_emit_and_add_to_shadow(GlobalVariable *gv, void *gvarinit)\n{\n    PointerType *T = cast<PointerType>(gv->getType()->getElementType()); // pointer is the only supported type here\n\n    GlobalVariable *shadowvar = NULL;\n#if defined(USE_MCJIT) || defined(USE_ORCJIT)\n    if (imaging_mode)\n#endif\n        shadowvar = global_proto(gv, shadow_output);\n\n    if (shadowvar) {\n        shadowvar->setInitializer(ConstantPointerNull::get(T));\n        shadowvar->setLinkage(GlobalVariable::InternalLinkage);\n        addComdat(shadowvar);\n        if (imaging_mode && gvarinit) {\n            // make the pointer valid for future sessions\n            jl_sysimg_gvars.push_back(ConstantExpr::getBitCast(shadowvar, T_psize));\n            jl_value_llvm gv_struct;\n            gv_struct.gv = global_proto(gv);\n            gv_struct.index = jl_sysimg_gvars.size();\n            jl_value_to_llvm[gvarinit] = gv_struct;\n        }\n    }\n\n    // make the pointer valid for this session\n#if defined(USE_MCJIT) || defined(USE_ORCJIT)\n    void *slot = calloc(1, sizeof(void*));\n    jl_ExecutionEngine->addGlobalMapping(gv, slot);\n    return slot;\n#else\n    return jl_ExecutionEngine->getPointerToGlobal(shadowvar);\n#endif\n}\n\n// Emit a slot in the system image to be filled at sysimg init time.\n// Returns the global var. Fill `idx` with 1-base index in the sysimg gv.\n// Use as an optimization for runtime constant addresses to have one less\n// load. (Used only by threading).\nGlobalVariable *jl_emit_sysimg_slot(Module *m, Type *typ, const char *name,\n                                           uintptr_t init, size_t &idx)\n{\n    assert(imaging_mode);\n    // This is **NOT** a external variable or a normal global variable\n    // This is a special internal global slot with a special index\n    // in the global variable table.\n    GlobalVariable *gv = new GlobalVariable(*m, typ, false,\n                                            GlobalVariable::InternalLinkage,\n                                            ConstantPointerNull::get((PointerType*)typ), name);\n    addComdat(gv);\n    // make the pointer valid for this session\n#if defined(USE_MCJIT) || defined(USE_ORCJIT)\n    auto p = new uintptr_t(init);\n    jl_ExecutionEngine->addGlobalMapping(gv, (void*)p);\n#else\n    uintptr_t *p = (uintptr_t*)jl_ExecutionEngine->getPointerToGlobal(gv);\n    *p = init;\n#endif\n    jl_sysimg_gvars.push_back(ConstantExpr::getBitCast(gv, T_psize));\n    idx = jl_sysimg_gvars.size();\n    return gv;\n}\n\nvoid* jl_get_global(GlobalVariable *gv)\n{\n#if defined(USE_MCJIT) || defined(USE_ORCJIT)\n    void *p = (void*)(intptr_t)jl_ExecutionEngine->getPointerToGlobalIfAvailable(gv);\n#else\n    void *p = jl_ExecutionEngine->getPointerToGlobal(\n            shadow_output->getNamedValue(gv->getName()));\n#endif\n    assert(p);\n    return p;\n}\n\n// clones the contents of the module `m` to the shadow_output collector\n// in the old JIT, this is equivalent to also adding it to the execution engine\nvoid jl_add_to_shadow(Module *m)\n{\n#if defined(USE_MCJIT) || defined(USE_ORCJIT)\n#ifndef KEEP_BODIES\n    if (!imaging_mode)\n        return;\n#endif\n    ValueToValueMapTy VMap;\n    std::unique_ptr<Module> clone(CloneModule(m, VMap));\n    for (Module::iterator I = clone->begin(), E = clone->end(); I != E; ++I) {\n        Function *F = &*I;\n        if (!F->isDeclaration()) {\n            F->setLinkage(Function::InternalLinkage);\n            addComdat(F);\n        }\n    }\n#else\n    // on the old jit, the shadow_module is the same as the execution engine_module\n    std::unique_ptr<Module> clone(m);\n#endif\n    jl_merge_module(shadow_output, std::move(clone));\n}\n\n#ifdef HAVE_CPUID\nextern \"C\" {\n    extern void jl_cpuid(int32_t CPUInfo[4], int32_t InfoType);\n}\n#endif\n\nstatic void jl_gen_llvm_globaldata(llvm::Module *mod, ValueToValueMapTy &VMap,\n                                   const char *sysimg_data, size_t sysimg_len)\n{\n    ArrayType *gvars_type = ArrayType::get(T_psize, jl_sysimg_gvars.size());\n    addComdat(new GlobalVariable(*mod,\n                                 gvars_type,\n                                 true,\n                                 GlobalVariable::ExternalLinkage,\n                                 MapValue(ConstantArray::get(gvars_type, ArrayRef<Constant*>(jl_sysimg_gvars)), VMap),\n                                 \"jl_sysimg_gvars\"));\n    ArrayType *fvars_type = ArrayType::get(T_pvoidfunc, jl_sysimg_fvars.size());\n    addComdat(new GlobalVariable(*mod,\n                                 fvars_type,\n                                 true,\n                                 GlobalVariable::ExternalLinkage,\n                                 MapValue(ConstantArray::get(fvars_type, ArrayRef<Constant*>(jl_sysimg_fvars)), VMap),\n                                 \"jl_sysimg_fvars\"));\n    addComdat(new GlobalVariable(*mod,\n                                 T_size,\n                                 true,\n                                 GlobalVariable::ExternalLinkage,\n                                 ConstantInt::get(T_size, globalUnique+1),\n                                 \"jl_globalUnique\"));\n#ifdef JULIA_ENABLE_THREADING\n    addComdat(new GlobalVariable(*mod,\n                                 T_size,\n                                 true,\n                                 GlobalVariable::ExternalLinkage,\n                                 ConstantInt::get(T_size, jltls_states_func_idx),\n                                 \"jl_ptls_states_getter_idx\"));\n#endif\n\n    Constant *feature_string = ConstantDataArray::getString(jl_LLVMContext, jl_options.cpu_target);\n    addComdat(new GlobalVariable(*mod,\n                                 feature_string->getType(),\n                                 true,\n                                 GlobalVariable::ExternalLinkage,\n                                 feature_string,\n                                 \"jl_sysimg_cpu_target\"));\n\n#ifdef HAVE_CPUID\n    // For native also store the cpuid\n    if (strcmp(jl_options.cpu_target,\"native\") == 0) {\n        uint32_t info[4];\n\n        jl_cpuid((int32_t*)info, 1);\n        addComdat(new GlobalVariable(*mod,\n                                     T_uint64,\n                                     true,\n                                     GlobalVariable::ExternalLinkage,\n                                     ConstantInt::get(T_uint64,((uint64_t)info[2])|(((uint64_t)info[3])<<32)),\n                                     \"jl_sysimg_cpu_cpuid\"));\n    }\n#endif\n\n    if (sysimg_data) {\n        Constant *data = ConstantDataArray::get(jl_LLVMContext, ArrayRef<uint8_t>((const unsigned char*)sysimg_data, sysimg_len));\n        addComdat(new GlobalVariable(*mod, data->getType(), true,\n                                     GlobalVariable::ExternalLinkage,\n                                     data, \"jl_system_image_data\"));\n        Constant *len = ConstantInt::get(T_size, sysimg_len);\n        addComdat(new GlobalVariable(*mod, len->getType(), true,\n                                     GlobalVariable::ExternalLinkage,\n                                     len, \"jl_system_image_size\"));\n    }\n}\n\n// takes the running content that has collected in the shadow module and dump it to disk\n// this builds the object file portion of the sysimage files for fast startup\nextern \"C\"\nvoid jl_dump_native(const char *bc_fname, const char *obj_fname, const char *sysimg_data, size_t sysimg_len)\n{\n    assert(imaging_mode);\n    // We don't want to use MCJIT's target machine because\n    // it uses the large code model and we may potentially\n    // want less optimizations there.\n    Triple TheTriple = Triple(jl_TargetMachine->getTargetTriple());\n    // make sure to emit the native object format, even if FORCE_ELF was set in codegen\n#if defined(_OS_WINDOWS_)\n#ifdef LLVM35\n    TheTriple.setObjectFormat(Triple::COFF);\n#else\n    TheTriple.setEnvironment(Triple::UnknownEnvironment);\n#endif\n#elif defined(_OS_DARWIN_)\n#ifdef LLVM35\n    TheTriple.setObjectFormat(Triple::MachO);\n#else\n    TheTriple.setEnvironment(Triple::MachO);\n#endif\n#endif\n#ifdef LLVM35\n    std::unique_ptr<TargetMachine>\n#else\n    OwningPtr<TargetMachine>\n#endif\n    TM(jl_TargetMachine->getTarget().createTargetMachine(\n        TheTriple.getTriple(),\n        jl_TargetMachine->getTargetCPU(),\n        jl_TargetMachine->getTargetFeatureString(),\n        jl_TargetMachine->Options,\n#if defined(_OS_LINUX_) || defined(_OS_FREEBSD_)\n        Reloc::PIC_,\n#elif defined(LLVM39)\n        Optional<Reloc::Model>(),\n#else\n        Reloc::Default,\n#endif\n        CodeModel::Default,\n        CodeGenOpt::Aggressive // -O3 TODO: respect command -O0 flag?\n        ));\n\n#ifdef LLVM37\n    legacy::PassManager PM;\n#else\n    PassManager PM;\n#endif\n#ifndef LLVM37\n    PM.add(new TargetLibraryInfo(Triple(TM->getTargetTriple())));\n#else\n    PM.add(new TargetLibraryInfoWrapperPass(Triple(TM->getTargetTriple())));\n#endif\n\n\n    // set up optimization passes\n#ifdef LLVM37\n    // No DataLayout pass needed anymore.\n#elif defined(LLVM36)\n    PM.add(new DataLayoutPass());\n#elif defined(LLVM35)\n    PM.add(new DataLayoutPass(*jl_ExecutionEngine->getDataLayout()));\n#else\n    PM.add(new DataLayout(*jl_ExecutionEngine->getDataLayout()));\n#endif\n\n    addOptimizationPasses(&PM);\n\n    std::unique_ptr<raw_fd_ostream> bc_OS;\n    std::unique_ptr<raw_fd_ostream> obj_OS;\n#ifdef LLVM37 // 3.7 simplified formatted output; just use the raw stream alone\n    std::unique_ptr<raw_fd_ostream> &bc_FOS = bc_OS;\n    std::unique_ptr<raw_fd_ostream> &obj_FOS = obj_OS;\n#else\n    std::unique_ptr<formatted_raw_ostream> bc_FOS;\n    std::unique_ptr<formatted_raw_ostream> obj_FOS;\n#endif\n\n    if (bc_fname) {\n#if defined(LLVM35)\n        // call output handler directly to avoid special case handling of `-` filename\n        int FD;\n        std::error_code EC = sys::fs::openFileForWrite(bc_fname, FD, sys::fs::F_None);\n        bc_OS.reset(new raw_fd_ostream(FD, true));\n        std::string err;\n        if (EC)\n            err = \"ERROR: failed to open --output-bc file '\" + std::string(bc_fname) + \"': \" + EC.message();\n#else\n        std::string err;\n        bc_OS.reset(new raw_fd_ostream(bc_fname, err, raw_fd_ostream::F_Binary));\n#endif\n        if (!err.empty())\n            jl_safe_printf(\"%s\\n\", err.c_str());\n        else {\n#ifndef LLVM37\n            bc_FOS.reset(new formatted_raw_ostream(*bc_OS.get()));\n#endif\n            PM.add(createBitcodeWriterPass(*bc_FOS.get()));     // Unroll small loops\n        }\n    }\n\n    if (obj_fname) {\n#if defined(LLVM35)\n        // call output handler directly to avoid special case handling of `-` filename\n        int FD;\n        std::error_code EC = sys::fs::openFileForWrite(obj_fname, FD, sys::fs::F_None);\n        obj_OS.reset(new raw_fd_ostream(FD, true));\n        std::string err;\n        if (EC)\n            err = \"ERROR: failed to open --output-o file '\" + std::string(obj_fname) + \"': \" + EC.message();\n#else\n        std::string err;\n        obj_OS.reset(new raw_fd_ostream(obj_fname, err, raw_fd_ostream::F_Binary));\n#endif\n        if (!err.empty())\n            jl_safe_printf(\"%s\\n\", err.c_str());\n        else {\n#ifndef LLVM37\n            obj_FOS.reset(new formatted_raw_ostream(*obj_OS.get()));\n#endif\n            if (TM->addPassesToEmitFile(PM, *obj_FOS.get(), TargetMachine::CGFT_ObjectFile, false)) {\n                jl_safe_printf(\"ERROR: target does not support generation of object files\\n\");\n            }\n        }\n    }\n\n    ValueToValueMapTy VMap;\n#if defined(USE_MCJIT) || defined(USE_ORCJIT)\n    // now copy the module (if using the old JIT), since PM.run may modify it\n    Module *clone = shadow_output;\n#else\n    Module *clone = CloneModule(shadow_output, VMap);\n#endif\n\n#ifdef LLVM37\n    // Reset the target triple to make sure it matches the new target machine\n    clone->setTargetTriple(TM->getTargetTriple().str());\n#ifdef LLVM38\n    clone->setDataLayout(TM->createDataLayout());\n#else\n    clone->setDataLayout(TM->getDataLayout()->getStringRepresentation());\n#endif\n#endif\n\n    // add metadata information\n    jl_gen_llvm_globaldata(clone, VMap, sysimg_data, sysimg_len);\n\n    // do the actual work\n    PM.run(*clone);\n#if !defined(USE_MCJIT) && !defined(USE_ORCJIT)\n    delete clone;\n#endif\n    imaging_mode = false;\n}\n\nextern \"C\" int32_t jl_assign_functionID(void *function)\n{\n    // give the function an index in the constant lookup table\n    assert(imaging_mode);\n    if (function == NULL)\n        return 0;\n    jl_sysimg_fvars.push_back(ConstantExpr::getBitCast(\n                shadow_output->getNamedValue(((Function*)function)->getName()),\n                T_pvoidfunc));\n    return jl_sysimg_fvars.size();\n}\n\nextern \"C\" int32_t jl_get_llvm_gv(jl_value_t *p)\n{\n    // map a jl_value_t memory location to a GlobalVariable\n    std::map<void*, jl_value_llvm>::iterator it;\n    it = jl_value_to_llvm.find(p);\n    if (it == jl_value_to_llvm.end())\n        return 0;\n    return it->second.index;\n}\n\nGlobalVariable *jl_get_global_for(const char *cname, void *addr, Module *M)\n{\n    // emit a GlobalVariable for a jl_value_t named \"cname\"\n    std::map<void*, jl_value_llvm>::iterator it;\n    // first see if there already is a GlobalVariable for this address\n    it = jl_value_to_llvm.find(addr);\n    if (it != jl_value_to_llvm.end())\n        return prepare_global((llvm::GlobalVariable*)it->second.gv, M);\n\n    std::stringstream gvname;\n    gvname << cname << globalUnique++;\n    // no existing GlobalVariable, create one and store it\n    GlobalVariable *gv = new GlobalVariable(*M, T_pjlvalue,\n                           false, GlobalVariable::ExternalLinkage,\n                           NULL, gvname.str());\n    *(void**)jl_emit_and_add_to_shadow(gv, addr) = addr;\n    return gv;\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/init.c": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n/*\n  init.c\n  system initialization and global state\n*/\n#include \"platform.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n#include <fcntl.h>\n\n#include <errno.h>\n\n#if !defined(_OS_WINDOWS_) || defined(_COMPILER_MINGW_)\n#include <getopt.h>\n#endif\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#define DEFINE_BUILTIN_GLOBALS\n#include \"builtin_proto.h\"\n#undef DEFINE_BUILTIN_GLOBALS\n#include \"threading.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef _MSC_VER\nJL_DLLEXPORT char *dirname(char *);\n#else\n#include <libgen.h>\n#endif\n\n#ifdef _OS_WINDOWS_\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n#include <io.h>\nextern int needsSymRefreshModuleList;\nextern BOOL (WINAPI *hSymRefreshModuleList)(HANDLE);\n#else\n#include <sys/resource.h>\n#include <unistd.h>\n#endif\n\n#ifdef JL_ASAN_ENABLED\nJL_DLLEXPORT const char* __asan_default_options() {\n    return \"allow_user_segv_handler=1:detect_leaks=0\";\n    // FIXME: enable LSAN after fixing leaks & defining __lsan_default_suppressions(),\n    //        or defining __lsan_default_options = exitcode=0 once publicly available\n    //        (here and in flisp/flmain.c)\n}\n#endif\n\nstatic const char system_image_path[256] = \"\\0\" JL_SYSTEM_IMAGE_PATH;\n\njl_options_t jl_options = { 0,    // quiet\n                            NULL, // julia_home\n                            NULL, // julia_bin\n                            NULL, // eval\n                            NULL, // print\n                            NULL, // postboot\n                            NULL, // load\n                            &system_image_path[1], // image_file\n                            NULL, // cpu_taget (\"native\", \"core2\", etc...)\n                            0,    // nprocs\n                            NULL, // machinefile\n                            0,    // isinteractive\n                            0,    // color\n                            JL_OPTIONS_HISTORYFILE_ON, // historyfile\n                            0,    // startupfile\n                            JL_OPTIONS_COMPILE_DEFAULT, // compile_enabled\n                            0,    // code_coverage\n                            0,    // malloc_log\n                            2,    // opt_level\n                            JL_OPTIONS_CHECK_BOUNDS_DEFAULT, // check_bounds\n                            1,    // depwarn\n                            1,    // can_inline\n                            JL_OPTIONS_FAST_MATH_DEFAULT,\n                            0,    // worker\n                            JL_OPTIONS_HANDLE_SIGNALS_ON,\n                            JL_OPTIONS_USE_PRECOMPILED_YES,\n                            JL_OPTIONS_USE_COMPILECACHE_YES,\n                            NULL, // bindto\n                            NULL, // outputbc\n                            NULL, // outputo\n                            NULL, // outputji\n                            0, // incremental\n                            0 // image_file_specified\n};\n\nint jl_boot_file_loaded = 0;\nsize_t jl_page_size;\n\nvoid jl_init_stack_limits(int ismaster)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n#ifdef _OS_WINDOWS_\n    (void)ismaster;\n#  ifdef _COMPILER_MICROSOFT_\n#    ifdef _P64\n    void **tib = (void**)__readgsqword(0x30);\n#    else\n    void **tib = (void**)__readfsdword(0x18);\n#    endif\n#  else\n    void **tib;\n#    ifdef _P64\n    __asm__(\"movq %%gs:0x30, %0\" : \"=r\" (tib) : : );\n#    else\n    __asm__(\"movl %%fs:0x18, %0\" : \"=r\" (tib) : : );\n#    endif\n#  endif\n    // https://en.wikipedia.org/wiki/Win32_Thread_Information_Block\n    ptls->stack_hi = (char*)tib[1]; // Stack Base / Bottom of stack (high address)\n    ptls->stack_lo = (char*)tib[2]; // Stack Limit / Ceiling of stack (low address)\n#else\n#  ifdef JULIA_ENABLE_THREADING\n    // Only use pthread_*_np functions to get stack address for non-master\n    // threads since it seems to return bogus values for master thread on Linux\n    // and possibly OSX.\n    if (!ismaster) {\n#    if defined(_OS_LINUX_)\n        pthread_attr_t attr;\n        pthread_getattr_np(pthread_self(), &attr);\n        void *stackaddr;\n        size_t stacksize;\n        pthread_attr_getstack(&attr, &stackaddr, &stacksize);\n        pthread_attr_destroy(&attr);\n        ptls->stack_lo = (char*)stackaddr;\n        ptls->stack_hi = (char*)stackaddr + stacksize;\n        return;\n#    elif defined(_OS_DARWIN_)\n        extern void *pthread_get_stackaddr_np(pthread_t thread);\n        extern size_t pthread_get_stacksize_np(pthread_t thread);\n        pthread_t thread = pthread_self();\n        void *stackaddr = pthread_get_stackaddr_np(thread);\n        size_t stacksize = pthread_get_stacksize_np(thread);\n        ptls->stack_lo = (char*)stackaddr;\n        ptls->stack_hi = (char*)stackaddr + stacksize;\n        return;\n#    elif defined(_OS_FREEBSD_)\n        pthread_attr_t attr;\n        pthread_attr_init(&attr);\n        pthread_attr_get_np(pthread_self(), &attr);\n        void *stackaddr;\n        size_t stacksize;\n        pthread_attr_getstack(&attr, &stackaddr, &stacksize);\n        pthread_attr_destroy(&attr);\n        ptls->stack_lo = (char*)stackaddr;\n        ptls->stack_hi = (char*)stackaddr + stacksize;\n        return;\n#    else\n#      warning \"Getting stack size for thread is not supported.\"\n#    endif\n    }\n#  else\n    (void)ismaster;\n#  endif\n    struct rlimit rl;\n    getrlimit(RLIMIT_STACK, &rl);\n    size_t stack_size = rl.rlim_cur;\n    ptls->stack_hi = (char*)&stack_size;\n    ptls->stack_lo = ptls->stack_hi - stack_size;\n#endif\n}\n\nstatic void jl_find_stack_bottom(void)\n{\n#if !defined(_OS_WINDOWS_)\n#if defined(JL_ASAN_ENABLED) || defined(JL_MSAN_ENABLED)\n    struct rlimit rl;\n\n    // When using the sanitizers, increase stack size because they bloat\n    // stack usage\n    const rlim_t kStackSize = 32 * 1024 * 1024;   // 32MB stack\n    int result;\n\n    result = getrlimit(RLIMIT_STACK, &rl);\n    if (result == 0) {\n        if (rl.rlim_cur < kStackSize) {\n            rl.rlim_cur = kStackSize;\n            result = setrlimit(RLIMIT_STACK, &rl);\n            if (result != 0) {\n                fprintf(stderr, \"setrlimit returned result = %d\\n\", result);\n            }\n        }\n    }\n#endif\n#endif\n    jl_init_stack_limits(1);\n}\n\nstruct uv_shutdown_queue_item { uv_handle_t *h; struct uv_shutdown_queue_item *next; };\nstruct uv_shutdown_queue { struct uv_shutdown_queue_item *first; struct uv_shutdown_queue_item *last; };\n\nstatic void jl_uv_exitcleanup_add(uv_handle_t *handle, struct uv_shutdown_queue *queue)\n{\n    struct uv_shutdown_queue_item *item = (struct uv_shutdown_queue_item*)malloc(sizeof(struct uv_shutdown_queue_item));\n    item->h = handle;\n    item->next = NULL;\n    if (queue->last) queue->last->next = item;\n    if (!queue->first) queue->first = item;\n    queue->last = item;\n}\n\nstatic void jl_uv_exitcleanup_walk(uv_handle_t *handle, void *arg)\n{\n    if (handle != (uv_handle_t*)JL_STDOUT && handle != (uv_handle_t*)JL_STDERR)\n        jl_uv_exitcleanup_add(handle, (struct uv_shutdown_queue*)arg);\n}\n\nvoid jl_write_coverage_data(void);\nvoid jl_write_malloc_log(void);\nstatic void julia_save(void);\n\nstatic struct uv_shutdown_queue_item *next_shutdown_queue_item(struct uv_shutdown_queue_item *item)\n{\n    struct uv_shutdown_queue_item *rv = item->next;\n    free(item);\n    return rv;\n}\n\nvoid jl_init_timing(void);\nvoid jl_destroy_timing(void);\nvoid jl_uv_call_close_callback(jl_value_t *val);\n\nJL_DLLEXPORT void jl_atexit_hook(int exitcode)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    if (exitcode == 0) julia_save();\n    jl_print_gc_stats(JL_STDERR);\n    if (jl_options.code_coverage)\n        jl_write_coverage_data();\n    if (jl_options.malloc_log)\n        jl_write_malloc_log();\n    if (jl_base_module) {\n        jl_value_t *f = jl_get_global(jl_base_module, jl_symbol(\"_atexit\"));\n        if (f != NULL) {\n            JL_TRY {\n                jl_apply(&f, 1);\n            }\n            JL_CATCH {\n                jl_printf(JL_STDERR, \"\\natexit hook threw an error: \");\n                jl_static_show(JL_STDERR, ptls->exception_in_transit);\n            }\n        }\n    }\n\n    jl_gc_run_all_finalizers(ptls);\n\n    uv_loop_t *loop = jl_global_event_loop();\n\n    if (loop == NULL) {\n        return;\n    }\n\n    struct uv_shutdown_queue queue = {NULL, NULL};\n    uv_walk(loop, jl_uv_exitcleanup_walk, &queue);\n    // close stdout and stderr last, since we like being\n    // able to show stuff (incl. printf's)\n    if (JL_STDOUT != (void*) STDOUT_FILENO &&\n        ((uv_handle_t*)JL_STDOUT)->type < UV_HANDLE_TYPE_MAX)\n        jl_uv_exitcleanup_add((uv_handle_t*)JL_STDOUT, &queue);\n    if (JL_STDERR != (void*) STDERR_FILENO &&\n        ((uv_handle_t*)JL_STDERR)->type < UV_HANDLE_TYPE_MAX)\n        jl_uv_exitcleanup_add((uv_handle_t*)JL_STDERR, &queue);\n    //uv_unref((uv_handle_t*)JL_STDOUT);\n    //uv_unref((uv_handle_t*)JL_STDERR);\n    struct uv_shutdown_queue_item *item = queue.first;\n    while (item) {\n        JL_TRY {\n            while (item) {\n                uv_handle_t *handle = item->h;\n                if (handle->type != UV_FILE && uv_is_closing(handle)) {\n                    item = next_shutdown_queue_item(item);\n                    continue;\n                }\n                switch(handle->type) {\n                case UV_PROCESS:\n                    // cause Julia to forget about the Process object\n                    if (handle->data)\n                        jl_uv_call_close_callback((jl_value_t*)handle->data);\n                    // and make libuv think it is already dead\n                    ((uv_process_t*)handle)->pid = 0;\n                    // fall-through\n                case UV_TTY:\n                case UV_UDP:\n                case UV_TCP:\n                case UV_NAMED_PIPE:\n                case UV_POLL:\n                case UV_TIMER:\n                case UV_ASYNC:\n                case UV_FS_EVENT:\n                case UV_FS_POLL:\n                case UV_IDLE:\n                case UV_PREPARE:\n                case UV_CHECK:\n                case UV_SIGNAL:\n                case UV_FILE:\n                    // These will be shutdown as appropriate by jl_close_uv\n                    jl_close_uv(handle);\n                    break;\n                case UV_HANDLE:\n                case UV_STREAM:\n                case UV_UNKNOWN_HANDLE:\n                case UV_HANDLE_TYPE_MAX:\n                case UV_RAW_FD:\n                case UV_RAW_HANDLE:\n                default:\n                    assert(0);\n                }\n                item = next_shutdown_queue_item(item);\n            }\n        }\n        JL_CATCH {\n            //error handling -- continue cleanup, as much as possible\n            uv_unref(item->h);\n            jl_printf(JL_STDERR, \"error during exit cleanup: close: \");\n            jl_static_show(JL_STDERR, ptls->exception_in_transit);\n            item = next_shutdown_queue_item(item);\n        }\n    }\n    // force libuv to spin until everything has finished closing\n    loop->stop_flag = 0;\n    while (uv_run(loop,UV_RUN_DEFAULT)) {}\n\n    jl_destroy_timing();\n#ifdef ENABLE_TIMINGS\n    jl_print_timings();\n#endif\n}\n\nvoid jl_get_builtin_hooks(void);\nvoid jl_get_builtins(void);\n\nJL_DLLEXPORT void *jl_dl_handle;\nvoid *jl_RTLD_DEFAULT_handle;\n#ifdef _OS_WINDOWS_\nJL_DLLEXPORT void *jl_exe_handle;\nvoid *jl_ntdll_handle;\nvoid *jl_kernel32_handle;\nvoid *jl_crtdll_handle;\nvoid *jl_winsock_handle;\n#endif\n\nuv_loop_t *jl_io_loop;\n\nstatic void *init_stdio_handle(uv_file fd,int readable)\n{\n    void *handle;\n    uv_handle_type type = uv_guess_handle(fd);\n    jl_uv_file_t *file;\n#ifndef _OS_WINDOWS_\n    // Duplicate the file descriptor so we can later dup it over if we want to redirect\n    // STDIO without having to worry about closing the associated libuv object.\n    // On windows however, libuv objects remember streams by their HANDLE, so this is\n    // unnecessary.\n    fd = dup(fd);\n#endif\n    //jl_printf(JL_STDOUT, \"%d: %d -- %d\\n\", fd, type, 0);\n    switch(type) {\n        case UV_TTY:\n            handle = malloc(sizeof(uv_tty_t));\n            if (uv_tty_init(jl_io_loop,(uv_tty_t*)handle,fd,readable)) {\n                jl_errorf(\"error initializing stdio in uv_tty_init (%d, %d)\", fd, type);\n            }\n            ((uv_tty_t*)handle)->data=0;\n            uv_tty_set_mode((uv_tty_t*)handle, UV_TTY_MODE_NORMAL); //cooked stdio\n            break;\n        case UV_UNKNOWN_HANDLE:\n            // dup the descriptor with a new one pointing at the bit bucket ...\n#if defined(_OS_WINDOWS_)\n            _dup2(_open(\"NUL\", O_RDWR | O_BINARY, _S_IREAD | _S_IWRITE), fd);\n#else\n            dup2(open(\"/dev/null\", O_RDWR, S_IRUSR | S_IWUSR /* 0600 */ | S_IRGRP | S_IROTH /* 0644 */), fd);\n#endif\n            // ...and continue on as in the UV_FILE case\n        case UV_FILE:\n            file = (jl_uv_file_t*)malloc(sizeof(jl_uv_file_t));\n            file->loop = jl_io_loop;\n            file->type = UV_FILE;\n            file->file = fd;\n            file->data = 0;\n            handle = file;\n            break;\n        case UV_NAMED_PIPE:\n            handle = malloc(sizeof(uv_pipe_t));\n            if (uv_pipe_init(jl_io_loop, (uv_pipe_t*)handle, (readable?UV_PIPE_READABLE:UV_PIPE_WRITABLE))) {\n                jl_errorf(\"error initializing stdio in uv_pipe_init (%d, %d)\", fd, type);\n            }\n            if (uv_pipe_open((uv_pipe_t*)handle,fd)) {\n                jl_errorf(\"error initializing stdio in uv_pipe_open (%d, %d)\", fd, type);\n            }\n            ((uv_pipe_t*)handle)->data=0;\n            break;\n        case UV_TCP:\n            handle = malloc(sizeof(uv_tcp_t));\n            if (uv_tcp_init(jl_io_loop, (uv_tcp_t*)handle)) {\n                jl_errorf(\"error initializing stdio in uv_tcp_init (%d, %d)\", fd, type);\n            }\n            if (uv_tcp_open((uv_tcp_t*)handle,fd)) {\n                jl_errorf(\"error initializing stdio in uv_tcp_open (%d, %d)\", fd, type);\n            }\n            ((uv_tcp_t*)handle)->data=0;\n            break;\n        case UV_UDP:\n        default:\n            jl_errorf(\"this type of handle for stdio is not yet supported (%d, %d)\", fd, type);\n            break;\n    }\n    return handle;\n}\n\nvoid init_stdio(void)\n{   //order must be 2,1,0\n    JL_STDERR = (uv_stream_t*)init_stdio_handle(STDERR_FILENO,0);\n    JL_STDOUT = (uv_stream_t*)init_stdio_handle(STDOUT_FILENO,0);\n    JL_STDIN  = (uv_stream_t*)init_stdio_handle(STDIN_FILENO,1);\n\n    jl_flush_cstdio();\n}\n\n#ifdef JL_USE_INTEL_JITEVENTS\nchar jl_using_intel_jitevents; // Non-zero if running under Intel VTune Amplifier\n#endif\n\n#ifdef JL_USE_OPROFILE_JITEVENTS\nchar jl_using_oprofile_jitevents = 0; // Non-zero if running under OProfile\n#endif\n\nint isabspath(const char *in)\n{\n#ifdef _OS_WINDOWS_\n    char c0 = in[0];\n    if (c0 == '/' || c0 == '\\\\') {\n        return 1; // absolute path relative to %CD% (current drive), or UNC\n    }\n    else {\n        int s = strlen(in);\n        if (s > 2) {\n            char c1 = in[1];\n            char c2 = in[2];\n            if (c1 == ':' && (c2 == '/' || c2 == '\\\\')) return 1; // absolute path\n        }\n    }\n#else\n    if (in[0] == '/') return 1; // absolute path\n#endif\n    return 0; // relative path\n}\n\nstatic char *abspath(const char *in)\n{ // compute an absolute path location, so that chdir doesn't change the file reference\n#ifndef _OS_WINDOWS_\n    char *out = realpath(in, NULL);\n    if (!out) {\n        if (in[0] == PATHSEPSTRING[0]) {\n            out = strdup(in);\n        }\n        else {\n            size_t path_size = PATH_MAX;\n            size_t len = strlen(in);\n            char *path = (char*)malloc(PATH_MAX);\n            if (uv_cwd(path, &path_size)) {\n                jl_error(\"fatal error: unexpected error while retrieving current working directory\");\n            }\n            if (path_size + len + 2 >= PATH_MAX) {\n                jl_error(\"fatal error: current working directory path too long\");\n            }\n            path[path_size] = PATHSEPSTRING[0];\n            memcpy(path + path_size + 1, in, len+1);\n            out = strdup(path);\n            free(path);\n        }\n    }\n#else\n    DWORD n = GetFullPathName(in, 0, NULL, NULL);\n    if (n <= 0) {\n        jl_error(\"fatal error: jl_options.image_file path too long or GetFullPathName failed\");\n    }\n    char *out = (char*)malloc(n);\n    DWORD m = GetFullPathName(in, n, out, NULL);\n    if (n != m + 1) {\n        jl_error(\"fatal error: jl_options.image_file path too long or GetFullPathName failed\");\n    }\n#endif\n    return out;\n}\n\nstatic void jl_resolve_sysimg_location(JL_IMAGE_SEARCH rel)\n{   // this function resolves the paths in jl_options to absolute file locations as needed\n    // and it replaces the pointers to `julia_home`, `julia_bin`, `image_file`, and output file paths\n    // it may fail, print an error, and exit(1) if any of these paths are longer than PATH_MAX\n    //\n    // note: if you care about lost memory, you should call the appropriate `free()` function\n    // on the original pointer for each `char*` you've inserted into `jl_options`, after\n    // calling `julia_init()`\n    char *free_path = (char*)malloc(PATH_MAX);\n    size_t path_size = PATH_MAX;\n    if (uv_exepath(free_path, &path_size)) {\n        jl_error(\"fatal error: unexpected error while retrieving exepath\");\n    }\n    if (path_size >= PATH_MAX) {\n        jl_error(\"fatal error: jl_options.julia_bin path too long\");\n    }\n    jl_options.julia_bin = (char*)malloc(path_size+1);\n    memcpy((char*)jl_options.julia_bin, free_path, path_size);\n    ((char*)jl_options.julia_bin)[path_size] = '\\0';\n    if (!jl_options.julia_home) {\n        jl_options.julia_home = getenv(\"JULIA_HOME\");\n        if (!jl_options.julia_home) {\n            jl_options.julia_home = dirname(free_path);\n        }\n    }\n    if (jl_options.julia_home)\n        jl_options.julia_home = abspath(jl_options.julia_home);\n    free(free_path);\n    free_path = NULL;\n    if (jl_options.image_file) {\n        if (rel == JL_IMAGE_JULIA_HOME && !isabspath(jl_options.image_file)) {\n            // build time path, relative to JULIA_HOME\n            free_path = (char*)malloc(PATH_MAX);\n            int n = snprintf(free_path, PATH_MAX, \"%s\" PATHSEPSTRING \"%s\",\n                             jl_options.julia_home, jl_options.image_file);\n            if (n >= PATH_MAX || n < 0) {\n                jl_error(\"fatal error: jl_options.image_file path too long\");\n            }\n            jl_options.image_file = free_path;\n        }\n        if (jl_options.image_file)\n            jl_options.image_file = abspath(jl_options.image_file);\n        if (free_path) {\n            free(free_path);\n            free_path = NULL;\n        }\n    }\n    if (jl_options.outputo)\n        jl_options.outputo = abspath(jl_options.outputo);\n    if (jl_options.outputji)\n        jl_options.outputji = abspath(jl_options.outputji);\n    if (jl_options.outputbc)\n        jl_options.outputbc = abspath(jl_options.outputbc);\n    if (jl_options.machinefile)\n        jl_options.machinefile = abspath(jl_options.machinefile);\n    if (jl_options.load)\n        jl_options.load = abspath(jl_options.load);\n}\n\nstatic void jl_set_io_wait(int v)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    ptls->io_wait = v;\n}\n\nvoid _julia_init(JL_IMAGE_SEARCH rel)\n{\n    jl_init_timing();\n#ifdef JULIA_ENABLE_THREADING\n    // Make sure we finalize the tls callback before starting any threads.\n    jl_get_ptls_states_getter();\n#endif\n    jl_ptls_t ptls = jl_get_ptls_states();\n    jl_safepoint_init();\n    libsupport_init();\n    ios_set_io_wait_func = jl_set_io_wait;\n    jl_io_loop = uv_default_loop(); // this loop will internal events (spawning process etc.),\n                                    // best to call this first, since it also initializes libuv\n    jl_init_signal_async();\n    restore_signals();\n    jl_resolve_sysimg_location(rel);\n    // loads sysimg if available, and conditionally sets jl_options.cpu_target\n    jl_preload_sysimg_so(jl_options.image_file);\n    if (jl_options.cpu_target == NULL)\n        jl_options.cpu_target = \"native\";\n\n    jl_page_size = jl_getpagesize();\n    uint64_t total_mem = uv_get_total_memory();\n    if (total_mem >= (size_t)-1) {\n        total_mem = (size_t)-1;\n    }\n    jl_arr_xtralloc_limit = total_mem / 100;  // Extra allocation limited to 1% of total RAM\n    jl_find_stack_bottom();\n    jl_dl_handle = jl_load_dynamic_library(NULL, JL_RTLD_DEFAULT);\n#ifdef RTLD_DEFAULT\n    jl_RTLD_DEFAULT_handle = RTLD_DEFAULT;\n#else\n    jl_RTLD_DEFAULT_handle = jl_dl_handle;\n#endif\n#ifdef _OS_WINDOWS_\n    jl_ntdll_handle = jl_dlopen(\"ntdll.dll\", 0); // bypass julia's pathchecking for system dlls\n    jl_kernel32_handle = jl_dlopen(\"kernel32.dll\", 0);\n#if defined(_MSC_VER) && _MSC_VER == 1800\n    jl_crtdll_handle = jl_dlopen(\"msvcr120.dll\", 0);\n#else\n    jl_crtdll_handle = jl_dlopen(\"msvcrt.dll\", 0);\n#endif\n    jl_winsock_handle = jl_dlopen(\"ws2_32.dll\", 0);\n    jl_exe_handle = GetModuleHandleA(NULL);\n    SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS | SYMOPT_LOAD_LINES);\n    if (!SymInitialize(GetCurrentProcess(), NULL, 1)) {\n        jl_printf(JL_STDERR, \"WARNING: failed to initialize stack walk info\\n\");\n    }\n    needsSymRefreshModuleList = 0;\n    HMODULE jl_dbghelp = (HMODULE) jl_dlopen(\"dbghelp.dll\", 0);\n    if (jl_dbghelp)\n        hSymRefreshModuleList = (BOOL (WINAPI*)(HANDLE)) jl_dlsym(jl_dbghelp, \"SymRefreshModuleList\");\n#endif\n\n#if defined(JL_USE_INTEL_JITEVENTS)\n    const char *jit_profiling = getenv(\"ENABLE_JITPROFILING\");\n    if (jit_profiling && atoi(jit_profiling)) {\n        jl_using_intel_jitevents = 1;\n    }\n#endif\n\n#if defined(JL_USE_OPROFILE_JITEVENTS)\n    const char *jit_profiling = getenv(\"ENABLE_JITPROFILING\");\n    if (jit_profiling && atoi(jit_profiling)) {\n        jl_using_oprofile_jitevents = 1;\n    }\n#endif\n\n\n#if defined(__linux__)\n    int ncores = jl_cpu_cores();\n    if (ncores > 1) {\n        cpu_set_t cpumask;\n        CPU_ZERO(&cpumask);\n        for(int i=0; i < ncores; i++) {\n            CPU_SET(i, &cpumask);\n        }\n        sched_setaffinity(0, sizeof(cpu_set_t), &cpumask);\n    }\n#endif\n\n    jl_init_threading();\n\n    jl_gc_init();\n    jl_gc_enable(0);\n    jl_init_frontend();\n    jl_init_types();\n    jl_init_tasks();\n    jl_init_root_task(ptls->stack_lo, ptls->stack_hi-ptls->stack_lo);\n\n#ifdef ENABLE_TIMINGS\n    jl_root_task->timing_stack = jl_root_timing;\n#endif\n\n    init_stdio();\n    // libuv stdio cleanup depends on jl_init_tasks() because JL_TRY is used in jl_atexit_hook()\n\n    if ((jl_options.outputo || jl_options.outputbc) &&\n        (jl_options.code_coverage || jl_options.malloc_log)) {\n        jl_error(\"cannot generate code-coverage or track allocation information while generating a .o or .bc output file\");\n    }\n\n    jl_init_codegen();\n\n    jl_start_threads();\n\n    jl_an_empty_vec_any = (jl_value_t*)jl_alloc_vec_any(0);\n    jl_init_serializer();\n\n    if (!jl_options.image_file) {\n        jl_core_module = jl_new_module(jl_symbol(\"Core\"));\n        jl_type_type->name->mt->module = jl_core_module;\n        jl_top_module = jl_core_module;\n        ptls->current_module = jl_core_module;\n        jl_init_intrinsic_functions();\n        jl_init_primitives();\n        jl_get_builtins();\n\n        jl_new_main_module();\n        jl_internal_main_module = jl_main_module;\n\n        ptls->current_module = jl_core_module;\n        for (int t = 0;t < jl_n_threads;t++) {\n            jl_all_tls_states[t]->root_task->current_module = ptls->current_module;\n        }\n\n        jl_load(\"boot.jl\");\n        jl_get_builtin_hooks();\n        jl_boot_file_loaded = 1;\n        jl_init_box_caches();\n    }\n\n    if (jl_options.image_file) {\n        JL_TRY {\n            jl_restore_system_image(jl_options.image_file);\n        }\n        JL_CATCH {\n            jl_printf(JL_STDERR, \"error during init:\\n\");\n            jl_static_show(JL_STDERR, ptls->exception_in_transit);\n            jl_printf(JL_STDERR, \"\\n\");\n            jl_exit(1);\n        }\n    }\n\n    // set module field of primitive types\n    int i;\n    void **table = jl_core_module->bindings.table;\n    for(i=1; i < jl_core_module->bindings.size; i+=2) {\n        if (table[i] != HT_NOTFOUND) {\n            jl_binding_t *b = (jl_binding_t*)table[i];\n            if (b->value && jl_is_datatype(b->value)) {\n                jl_datatype_t *tt = (jl_datatype_t*)b->value;\n                tt->name->module = jl_core_module;\n                if (tt->name->mt)\n                    tt->name->mt->module = jl_core_module;\n            }\n        }\n    }\n\n    // the Main module is the one which is always open, and set as the\n    // current module for bare (non-module-wrapped) toplevel expressions.\n    // it does \"using Base\" if Base is available.\n    if (jl_base_module != NULL) {\n        jl_add_standard_imports(jl_main_module);\n    }\n    ptls->current_module = jl_main_module;\n    for (int t = 0;t < jl_n_threads;t++) {\n        jl_all_tls_states[t]->root_task->current_module = ptls->current_module;\n    }\n\n    // This needs to be after jl_start_threads\n    if (jl_options.handle_signals == JL_OPTIONS_HANDLE_SIGNALS_ON)\n        jl_install_default_signal_handlers();\n\n    jl_gc_enable(1);\n\n    if (jl_options.image_file && (!jl_generating_output() || jl_options.incremental) && jl_module_init_order) {\n        jl_array_t *init_order = jl_module_init_order;\n        JL_GC_PUSH1(&init_order);\n        jl_module_init_order = NULL;\n        int i, l = jl_array_len(init_order);\n        for (i = 0; i < l; i++) {\n            jl_value_t *mod = jl_array_ptr_ref(init_order, i);\n            jl_module_run_initializer((jl_module_t*)mod);\n        }\n        JL_GC_POP();\n    }\n\n    if (jl_options.handle_signals == JL_OPTIONS_HANDLE_SIGNALS_ON)\n        jl_install_sigint_handler();\n}\n\nextern int asprintf(char **str, const char *fmt, ...);\n\nJL_DLLEXPORT int jl_generating_output(void)\n{\n    return jl_options.outputo || jl_options.outputbc || jl_options.outputji;\n}\n\nvoid jl_precompile(int all);\n\nstatic void julia_save(void)\n{\n    if (!jl_generating_output())\n        return;\n\n    if (!jl_options.incremental)\n        jl_precompile(jl_options.compile_enabled == JL_OPTIONS_COMPILE_ALL);\n\n    if (!jl_module_init_order) {\n        jl_printf(JL_STDERR, \"WARNING: --output requested, but no modules defined during run\\n\");\n        return;\n    }\n\n    jl_array_t *worklist = jl_module_init_order;\n    JL_GC_PUSH1(&worklist);\n    jl_module_init_order = jl_alloc_vec_any(0);\n    int i, l = jl_array_len(worklist);\n    for (i = 0; i < l; i++) {\n        jl_value_t *m = jl_arrayref(worklist, i);\n        if (jl_get_global((jl_module_t*)m, jl_symbol(\"__init__\"))) {\n            jl_array_ptr_1d_push(jl_module_init_order, m);\n        }\n    }\n\n    if (jl_options.incremental) {\n        if (jl_options.outputji)\n            if (jl_save_incremental(jl_options.outputji, worklist))\n                jl_exit(1);\n        if (jl_options.outputbc)\n            jl_printf(JL_STDERR, \"WARNING: incremental output to a .bc file is not implemented\\n\");\n        if (jl_options.outputo)\n            jl_printf(JL_STDERR, \"WARNING: incremental output to a .o file is not implemented\\n\");\n    }\n    else {\n        ios_t *s = NULL;\n        if (jl_options.outputo || jl_options.outputbc)\n            s = jl_create_system_image();\n\n        if (jl_options.outputji) {\n            if (s == NULL) {\n                jl_save_system_image(jl_options.outputji);\n            }\n            else {\n                ios_t f;\n                if (ios_file(&f, jl_options.outputji, 1, 1, 1, 1) == NULL)\n                    jl_errorf(\"cannot open system image file \\\"%s\\\" for writing\", jl_options.outputji);\n                ios_write(&f, (const char*)s->buf, (size_t)s->size);\n                ios_close(&f);\n            }\n        }\n\n        if (jl_options.outputo || jl_options.outputbc)\n            jl_dump_native(jl_options.outputbc,\n                           jl_options.outputo,\n                           (const char*)s->buf, (size_t)s->size);\n    }\n    JL_GC_POP();\n}\n\nstatic jl_value_t *core(const char *name)\n{\n    return jl_get_global(jl_core_module, jl_symbol(name));\n}\n\nstatic jl_value_t *basemod(const char *name)\n{\n    return jl_get_global(jl_base_module, jl_symbol(name));\n}\n\n// fetch references to things defined in boot.jl\nvoid jl_get_builtin_hooks(void)\n{\n    int t;\n    for (t = 0; t < jl_n_threads; t++) {\n        jl_ptls_t ptls2 = jl_all_tls_states[t];\n        ptls2->root_task->tls = jl_nothing;\n        ptls2->root_task->consumers = jl_nothing;\n        ptls2->root_task->donenotify = jl_nothing;\n        ptls2->root_task->exception = jl_nothing;\n        ptls2->root_task->result = jl_nothing;\n    }\n\n    jl_char_type    = (jl_datatype_t*)core(\"Char\");\n    jl_int8_type    = (jl_datatype_t*)core(\"Int8\");\n    jl_int16_type   = (jl_datatype_t*)core(\"Int16\");\n    jl_uint16_type  = (jl_datatype_t*)core(\"UInt16\");\n    jl_uint32_type  = (jl_datatype_t*)core(\"UInt32\");\n    jl_uint64_type  = (jl_datatype_t*)core(\"UInt64\");\n\n    jl_float16_type = (jl_datatype_t*)core(\"Float16\");\n    jl_float32_type = (jl_datatype_t*)core(\"Float32\");\n    jl_float64_type = (jl_datatype_t*)core(\"Float64\");\n    jl_floatingpoint_type = (jl_datatype_t*)core(\"AbstractFloat\");\n    jl_number_type = (jl_datatype_t*)core(\"Number\");\n    jl_signed_type = (jl_datatype_t*)core(\"Signed\");\n\n    jl_errorexception_type = (jl_datatype_t*)core(\"ErrorException\");\n    jl_stackovf_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"StackOverflowError\"));\n    jl_diverror_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"DivideError\"));\n    jl_domain_exception    = jl_new_struct_uninit((jl_datatype_t*)core(\"DomainError\"));\n    jl_overflow_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"OverflowError\"));\n    jl_inexact_exception   = jl_new_struct_uninit((jl_datatype_t*)core(\"InexactError\"));\n    jl_undefref_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"UndefRefError\"));\n    jl_undefvarerror_type  = (jl_datatype_t*)core(\"UndefVarError\");\n    jl_interrupt_exception = jl_new_struct_uninit((jl_datatype_t*)core(\"InterruptException\"));\n    jl_boundserror_type    = (jl_datatype_t*)core(\"BoundsError\");\n    jl_memory_exception    = jl_new_struct_uninit((jl_datatype_t*)core(\"OutOfMemoryError\"));\n    jl_readonlymemory_exception = jl_new_struct_uninit((jl_datatype_t*)core(\"ReadOnlyMemoryError\"));\n    jl_typeerror_type = (jl_datatype_t*)core(\"TypeError\");\n\n#ifdef SEGV_EXCEPTION\n    jl_segv_exception      = jl_new_struct_uninit((jl_datatype_t*)core(\"SegmentationFault\"));\n#endif\n\n    jl_string_type = (jl_datatype_t*)core(\"String\");\n    jl_weakref_type = (jl_datatype_t*)core(\"WeakRef\");\n    jl_vecelement_typename = ((jl_datatype_t*)core(\"VecElement\"))->name;\n}\n\nJL_DLLEXPORT void jl_get_system_hooks(void)\n{\n    if (jl_argumenterror_type) return; // only do this once\n\n    jl_argumenterror_type = (jl_datatype_t*)basemod(\"ArgumentError\");\n    jl_methoderror_type = (jl_datatype_t*)basemod(\"MethodError\");\n    jl_loaderror_type = (jl_datatype_t*)basemod(\"LoadError\");\n    jl_initerror_type = (jl_datatype_t*)basemod(\"InitError\");\n    jl_complex_type = (jl_datatype_t*)basemod(\"Complex\");\n}\n\nvoid jl_get_builtins(void)\n{\n    jl_builtin_throw = core(\"throw\");           jl_builtin_is = core(\"is\");\n    jl_builtin_typeof = core(\"typeof\");         jl_builtin_sizeof = core(\"sizeof\");\n    jl_builtin_issubtype = core(\"issubtype\");   jl_builtin_isa = core(\"isa\");\n    jl_builtin_typeassert = core(\"typeassert\"); jl_builtin__apply = core(\"_apply\");\n    jl_builtin_isdefined = core(\"isdefined\");   jl_builtin_nfields = core(\"nfields\");\n    jl_builtin_tuple = core(\"tuple\");           jl_builtin_svec = core(\"svec\");\n    jl_builtin_getfield = core(\"getfield\");     jl_builtin_setfield = core(\"setfield!\");\n    jl_builtin_fieldtype = core(\"fieldtype\");   jl_builtin_arrayref = core(\"arrayref\");\n    jl_builtin_arrayset = core(\"arrayset\");     jl_builtin_arraysize = core(\"arraysize\");\n    jl_builtin_apply_type = core(\"apply_type\"); jl_builtin_applicable = core(\"applicable\");\n    jl_builtin_invoke = core(\"invoke\");         jl_builtin__expr = core(\"_expr\");\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/dlload.c": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <sys/stat.h>\n\n#include \"platform.h\"\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#ifdef _OS_WINDOWS_\n#include <windows.h>\n#include <direct.h>\n#else\n#include <unistd.h>\n#include <dlfcn.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// The empty extension at the beginning and the end is a trick to change\n// the order of the loop.\n#if defined(__APPLE__)\nstatic char const *const extensions[] = { \"\", \".dylib\", \"\" };\n#elif defined(_OS_WINDOWS_)\nstatic char const *const extensions[] = { \"\", \".dll\", \"\" };\nextern int needsSymRefreshModuleList;\n#else\nstatic char const *const extensions[] = { \"\", \".so\", \"\" };\n#endif\n#define N_EXTENSIONS (sizeof(extensions) / sizeof(char*) - 1)\n\nstatic int endswith_extension(const char *path)\n{\n    if (!path)\n        return 0;\n    size_t len = strlen(path);\n    // Skip the first one since it is empty\n    for (size_t i = 1;i < N_EXTENSIONS;i++) {\n        const char *ext = extensions[i];\n        size_t extlen = strlen(ext);\n        if (len >= extlen && memcmp(ext, path + len - extlen, extlen) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n#define PATHBUF 512\n\nextern char *julia_home;\n\n#define JL_RTLD(flags, FLAG) (flags & JL_RTLD_ ## FLAG ? RTLD_ ## FLAG : 0)\n\nstatic void JL_NORETURN jl_dlerror(const char *fmt, const char *sym)\n{\n#ifdef _OS_WINDOWS_\n    CHAR reason[256];\n    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n            NULL, GetLastError(),\n            MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),\n            reason, sizeof(reason) / sizeof(reason[0]), NULL);\n#else\n    const char *reason = dlerror();\n#endif\n    jl_errorf(fmt, sym, reason);\n}\n\nJL_DLLEXPORT void *jl_dlopen(const char *filename, unsigned flags)\n{\n#if defined(_OS_WINDOWS_)\n    needsSymRefreshModuleList = 1;\n    size_t len = MultiByteToWideChar(CP_UTF8, 0, filename, -1, NULL, 0);\n    if (!len) return NULL;\n    WCHAR *wfilename = (WCHAR*)alloca(len * sizeof(WCHAR));\n    if (!MultiByteToWideChar(CP_UTF8, 0, filename, -1, wfilename, len)) return NULL;\n    return LoadLibraryExW(wfilename, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n#else\n    dlerror(); /* Reset error status. */\n    return dlopen(filename,\n                  (flags & JL_RTLD_NOW ? RTLD_NOW : RTLD_LAZY)\n                  | JL_RTLD(flags, LOCAL)\n                  | JL_RTLD(flags, GLOBAL)\n#ifdef RTLD_NODELETE\n                  | JL_RTLD(flags, NODELETE)\n#endif\n#ifdef RTLD_NOLOAD\n                  | JL_RTLD(flags, NOLOAD)\n#endif\n#if defined(RTLD_DEEPBIND) && !defined(JL_ASAN_ENABLED)\n                  | JL_RTLD(flags, DEEPBIND)\n#endif\n#ifdef RTLD_FIRST\n                  | JL_RTLD(flags, FIRST)\n#endif\n                  );\n#endif\n}\n\nJL_DLLEXPORT int jl_dlclose(void *handle)\n{\n#ifdef _OS_WINDOWS_\n    if (!handle) return -1;\n    return FreeLibrary((HMODULE) handle);\n#else\n    dlerror(); /* Reset error status. */\n    if (!handle) return -1;\n    return dlclose(handle);\n#endif\n}\n\nstatic void *jl_load_dynamic_library_(const char *modname, unsigned flags, int throw_err)\n{\n    char path[PATHBUF];\n    int i;\n    uv_stat_t stbuf;\n    void *handle;\n    // This determines if we try the no-extension name first or last\n    // We want to make sure the last one we try has higher chance of being\n    // a real file since the error reported will otherwise be a unhelpful\n    // file not found error due to the extra or missing extension name.\n    int hasext = endswith_extension(modname);\n\n    /*\n      this branch returns handle of libjulia\n    */\n    if (modname == NULL) {\n#ifdef _OS_WINDOWS_\n        if (!GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n                                (LPCWSTR)(&jl_load_dynamic_library),\n                                (HMODULE*)&handle)) {\n            jl_error(\"could not load base module\");\n        }\n#else\n        handle = dlopen(NULL, RTLD_NOW);\n#endif\n        goto done;\n    }\n    /*\n      this branch shortcuts absolute paths\n    */\n#ifdef _OS_WINDOWS_\n    else if (modname[1] == ':') {\n#else\n    else if (modname[0] == '/') {\n#endif\n        handle = jl_dlopen(modname, flags);\n        if (handle)\n            goto done;\n        // bail out and show the error if file actually exists\n        if (jl_stat(modname, (char*)&stbuf) == 0)\n            goto notfound;\n    }\n    /*\n      this branch permutes all base paths in DL_LOAD_PATH with all extensions\n      note: skip when !jl_base_module to avoid UndefVarError(:DL_LOAD_PATH)\n    */\n    else if (jl_base_module != NULL) {\n        jl_array_t *DL_LOAD_PATH = (jl_array_t*)jl_get_global(jl_base_module, jl_symbol(\"DL_LOAD_PATH\"));\n        if (DL_LOAD_PATH != NULL) {\n            size_t j;\n            for (j = 0; j < jl_array_len(DL_LOAD_PATH); j++) {\n                char *dl_path = jl_string_data(jl_array_ptr_data(DL_LOAD_PATH)[j]);\n                size_t len = strlen(dl_path);\n                if (len == 0)\n                    continue;\n                for (i=0; i < N_EXTENSIONS; i++) {\n                    // Do the no-ext one last if hasext == 1\n                    const char *ext = extensions[i + hasext];\n                    path[0] = '\\0';\n                    if (dl_path[len-1] == PATHSEPSTRING[0])\n                        snprintf(path, PATHBUF, \"%s%s%s\", dl_path, modname, ext);\n                    else\n                        snprintf(path, PATHBUF, \"%s\" PATHSEPSTRING \"%s%s\", dl_path, modname, ext);\n                    handle = jl_dlopen(path, flags);\n                    if (handle)\n                        goto done;\n                    // bail out and show the error if file actually exists\n                    if (jl_stat(path, (char*)&stbuf) == 0)\n                        goto notfound;\n                }\n            }\n        }\n    }\n\n    // now fall back and look in default library paths, for all extensions\n    for(i=0; i < N_EXTENSIONS; i++) {\n        // Do the no-ext one last if hasext == 1\n        const char *ext = extensions[i + hasext];\n        path[0] = '\\0';\n        snprintf(path, PATHBUF, \"%s%s\", modname, ext);\n        handle = jl_dlopen(path, flags);\n        if (handle)\n            goto done;\n    }\n\n#if defined(__linux__) || defined(__FreeBSD__)\n    // check map of versioned libs from \"libX\" to full soname \"libX.so.ver\"\n    handle = jl_dlopen_soname(modname, strlen(modname), flags);\n    if (handle)\n        goto done;\n#endif\n\nnotfound:\n    if (throw_err)\n        jl_dlerror(\"could not load library \\\"%s\\\"\\n%s\", modname);\n    return NULL;\n\ndone:\n    return handle;\n}\n\nJL_DLLEXPORT void *jl_load_dynamic_library_e(const char *modname, unsigned flags)\n{\n    return jl_load_dynamic_library_(modname, flags, 0);\n}\n\nJL_DLLEXPORT void *jl_load_dynamic_library(const char *modname, unsigned flags)\n{\n    return jl_load_dynamic_library_(modname, flags, 1);\n}\n\nJL_DLLEXPORT void *jl_dlsym_e(void *handle, const char *symbol)\n{\n#ifdef _OS_WINDOWS_\n    void *ptr = GetProcAddress((HMODULE) handle, symbol);\n#else\n    dlerror(); /* Reset error status. */\n    void *ptr = dlsym(handle, symbol);\n#endif\n    return ptr;\n}\n\nJL_DLLEXPORT void *jl_dlsym(void *handle, const char *symbol)\n{\n    void *ptr = jl_dlsym_e(handle, symbol);\n    if (!ptr)\n        jl_dlerror(\"could not load symbol \\\"%s\\\":\\n%s\", symbol);\n    return ptr;\n}\n\n#ifdef _OS_WINDOWS_\n//Look for symbols in win32 libraries\nconst char *jl_dlfind_win32(const char *f_name)\n{\n    if (jl_dlsym_e(jl_exe_handle, f_name))\n        return (const char*)1;\n    if (jl_dlsym_e(jl_dl_handle, f_name))\n        return (const char*)2;\n    if (jl_dlsym_e(jl_kernel32_handle, f_name))\n        return \"kernel32\";\n    if (jl_dlsym_e(jl_ntdll_handle, f_name))\n        return \"ntdll\";\n    if (jl_dlsym_e(jl_crtdll_handle, f_name))\n#if defined(_MSC_VER)\n#if _MSC_VER == 1800\n        return \"msvcr120\";\n#else\n#error This version of MSVC has not been tested.\n#endif\n#else\n        return \"msvcrt\";\n#endif\n    if (jl_dlsym_e(jl_winsock_handle, f_name))\n        return \"ws2_32\";\n    // additional common libraries (libc?) could be added here, but in general,\n    // it is better to specify the library explicitly in the code. This exists\n    // mainly to ease compatibility with linux, and for libraries that don't\n    // have a name (julia.exe and libjulia.dll)\n    // We could also loop over all libraries that have been used so far, but, again,\n    // explicit is preferred over implicit\n    return NULL;\n    // oops, we didn't find it. NULL defaults to searching jl_RTLD_DEFAULT_handle,\n    // which defaults to jl_dl_handle, where we won't find it, and will throw the\n    // appropriate error.\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/ccall.cpp": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n#include \"support/hashing.h\"\n\n// --- the ccall, cglobal, and llvm intrinsics ---\n\n// Map from symbol name (in a certain library) to its GV in sysimg and the\n// DL handle address in the current session.\ntypedef StringMap<std::pair<GlobalVariable*,void*>> SymMapGV;\nstatic StringMap<std::pair<GlobalVariable*,SymMapGV>> libMapGV;\n#ifdef _OS_WINDOWS_\nstatic SymMapGV symMapExe;\nstatic SymMapGV symMapDl;\n#endif\nstatic SymMapGV symMapDefault;\n\ntemplate<typename Func>\nstruct LazyModule {\n    Func func;\n    Module *m;\n    template<typename Func2>\n    LazyModule(Func2 &&func)\n        : func(std::forward<Func2>(func)),\n          m(nullptr)\n    {}\n    Module *get()\n    {\n        if (!m)\n            m = func();\n        return m;\n    }\n    Module &operator*()\n    {\n        return *get();\n    }\n};\n\ntemplate<typename Func>\nstatic LazyModule<typename std::remove_reference<Func>::type>\nlazyModule(Func &&func)\n{\n    return LazyModule<typename std::remove_reference<Func>::type>(\n        std::forward<Func>(func));\n}\n\n// Find or create the GVs for the library and symbol lookup.\n// Return `runtime_lib` (whether the library name is a string)\n// Optionally return the symbol address in the current session\n// when `symaddr != nullptr`.\n// The `lib` and `sym` GV returned may not be in the current module.\ntemplate<typename MT>\nstatic bool runtime_sym_gvs(const char *f_lib, const char *f_name, MT &&M,\n                            GlobalVariable *&lib, GlobalVariable *&sym,\n                            void **symaddr=nullptr)\n{\n    void *libsym = NULL;\n    bool runtime_lib = false;\n    GlobalVariable *libptrgv;\n    SymMapGV *symMap;\n#ifdef _OS_WINDOWS_\n    if ((intptr_t)f_lib == 1) {\n        libptrgv = jlexe_var;\n        libsym = jl_exe_handle;\n        symMap = &symMapExe;\n    }\n    else if ((intptr_t)f_lib == 2) {\n        libptrgv = jldll_var;\n        libsym = jl_dl_handle;\n        symMap = &symMapDl;\n    }\n    else\n#endif\n    if (f_lib == NULL) {\n        libptrgv = jlRTLD_DEFAULT_var;\n        libsym = jl_RTLD_DEFAULT_handle;\n        symMap = &symMapDefault;\n    }\n    else {\n        std::string name = \"ccalllib_\";\n        name += f_lib;\n        runtime_lib = true;\n        auto iter = libMapGV.find(f_lib);\n        if (iter == libMapGV.end()) {\n            libptrgv = new GlobalVariable(*M, T_pint8, false,\n                                          GlobalVariable::ExternalLinkage,\n                                          NULL, name);\n            auto &libgv = libMapGV[f_lib];\n            libgv = std::make_pair(global_proto(libptrgv), SymMapGV());\n            symMap = &libgv.second;\n            libsym = jl_get_library(f_lib);\n            assert(libsym != NULL);\n            *(void**)jl_emit_and_add_to_shadow(libptrgv) = libsym;\n        }\n        else {\n            libptrgv = iter->second.first;\n            symMap = &iter->second.second;\n        }\n    }\n    if (libsym == NULL) {\n        libsym = *(void**)jl_get_global(libptrgv);\n    }\n    assert(libsym != NULL);\n\n    GlobalVariable *llvmgv;\n    auto sym_iter = symMap->find(f_name);\n    if (sym_iter == symMap->end()) {\n        // MCJIT forces this to have external linkage eventually, so we would clobber\n        // the symbol of the actual function.\n        std::string name = \"ccall_\";\n        name += f_name;\n        name += \"_\";\n        name += std::to_string(globalUnique++);\n        llvmgv = new GlobalVariable(*M, T_pvoidfunc, false,\n                                    GlobalVariable::ExternalLinkage, NULL, name);\n        llvmgv = global_proto(llvmgv);\n        void *addr = jl_dlsym_e(libsym, f_name);\n        (*symMap)[f_name] = std::make_pair(llvmgv, addr);\n        if (symaddr)\n            *symaddr = addr;\n        *(void**)jl_emit_and_add_to_shadow(llvmgv) = addr;\n    }\n    else {\n        if (symaddr)\n            *symaddr = sym_iter->second.second;\n        llvmgv = sym_iter->second.first;\n    }\n\n    lib = libptrgv;\n    sym = llvmgv;\n    return runtime_lib;\n}\n\nstatic Value *runtime_sym_lookup(PointerType *funcptype, const char *f_lib,\n                                 const char *f_name, Function *f,\n                                 GlobalVariable *libptrgv,\n                                 GlobalVariable *llvmgv, bool runtime_lib)\n{\n    // in pseudo-code, this function emits the following:\n    //   global HMODULE *libptrgv\n    //   global void **llvmgv\n    //   if (*llvmgv == NULL) {\n    //       *llvmgv = jl_load_and_lookup(f_lib, f_name, libptrgv);\n    //   }\n    //   return (*llvmgv)\n    BasicBlock *dlsym_lookup = BasicBlock::Create(jl_LLVMContext, \"dlsym\");\n    BasicBlock *ccall_bb = BasicBlock::Create(jl_LLVMContext, \"ccall\");\n    Constant *initnul = ConstantPointerNull::get((PointerType*)T_pvoidfunc);\n    builder.CreateCondBr(builder.CreateICmpNE(builder.CreateLoad(llvmgv), initnul), ccall_bb, dlsym_lookup);\n\n    assert(f->getParent() != NULL);\n    f->getBasicBlockList().push_back(dlsym_lookup);\n    builder.SetInsertPoint(dlsym_lookup);\n    Value *libname;\n    if (runtime_lib) {\n        libname = stringConstPtr(f_lib);\n    }\n    else {\n        libname = literal_static_pointer_val(f_lib, T_pint8);\n    }\n#ifdef LLVM37\n    Value *llvmf = builder.CreateCall(prepare_call(jldlsym_func), { libname, stringConstPtr(f_name), libptrgv });\n#else\n    Value *llvmf = builder.CreateCall3(prepare_call(jldlsym_func), libname, stringConstPtr(f_name), libptrgv);\n#endif\n    builder.CreateStore(llvmf, llvmgv);\n    builder.CreateBr(ccall_bb);\n\n    f->getBasicBlockList().push_back(ccall_bb);\n    builder.SetInsertPoint(ccall_bb);\n    llvmf = builder.CreateLoad(llvmgv);\n    return builder.CreatePointerCast(llvmf,funcptype);\n}\n\nstatic Value *runtime_sym_lookup(PointerType *funcptype, const char *f_lib,\n                                 const char *f_name, Function *f)\n{\n    GlobalVariable *libptrgv;\n    GlobalVariable *llvmgv;\n    bool runtime_lib = runtime_sym_gvs(f_lib, f_name, f->getParent(),\n                                       libptrgv, llvmgv);\n    libptrgv = prepare_global(libptrgv);\n    llvmgv = prepare_global(llvmgv);\n    return runtime_sym_lookup(funcptype, f_lib, f_name, f, libptrgv, llvmgv,\n                              runtime_lib);\n}\n\n// Map from distinct callee's to its GOT entry.\n// In principle the attribute, function type and calling convention\n// don't need to be part of the key but it seems impossible to forward\n// all the arguments without writing assembly directly.\n// This doesn't matter too much in reality since a single function is usually\n// not called with multiple signatures.\nstatic DenseMap<AttributeSet,\n                std::map<std::tuple<GlobalVariable*,FunctionType*,\n                                    CallingConv::ID>,GlobalVariable*>> allPltMap;\n\n// Emit a \"PLT\" entry that will be lazily initialized\n// when being called the first time.\nstatic Value *emit_plt(FunctionType *functype, const AttributeSet &attrs,\n                       CallingConv::ID cc, const char *f_lib, const char *f_name)\n{\n    assert(imaging_mode);\n    // Don't do this for vararg functions so that the `musttail` is only\n    // an optimization and is not required to function correctly.\n    assert(!functype->isVarArg());\n    GlobalVariable *libptrgv;\n    GlobalVariable *llvmgv;\n    void *symaddr;\n    auto LM = lazyModule([&] {\n            Module *m = new Module(f_name, jl_LLVMContext);\n            jl_setup_module(m);\n            return m;\n        });\n    bool runtime_lib = runtime_sym_gvs(f_lib, f_name, LM,\n                                       libptrgv, llvmgv, &symaddr);\n    PointerType *funcptype = PointerType::get(functype, 0);\n\n    auto &pltMap = allPltMap[attrs];\n    auto key = std::make_tuple(llvmgv, functype, cc);\n    auto &slot = pltMap[key];\n    GlobalVariable *got;\n    if (!slot) {\n        Module *M = LM.get();\n        libptrgv = prepare_global(libptrgv, M);\n        llvmgv = prepare_global(llvmgv, M);\n        BasicBlock *old = builder.GetInsertBlock();\n        DebugLoc olddl = builder.getCurrentDebugLocation();\n        DebugLoc noDbg;\n        builder.SetCurrentDebugLocation(noDbg);\n        std::stringstream funcName;\n        funcName << \"jlplt_\" << f_name << \"_\" << globalUnique++;\n        auto fname = funcName.str();\n        Function *plt = Function::Create(functype,\n                                         GlobalVariable::ExternalLinkage,\n                                         fname, M);\n        plt->setAttributes(attrs);\n        if (cc != CallingConv::C)\n            plt->setCallingConv(cc);\n        funcName << \"_got\";\n        auto gname = funcName.str();\n        got = new GlobalVariable(*M, T_pvoidfunc, false,\n                                 GlobalVariable::ExternalLinkage,\n                                 nullptr, gname);\n        slot = global_proto(got);\n        *(void**)jl_emit_and_add_to_shadow(got) = symaddr;\n        BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", plt);\n        builder.SetInsertPoint(b0);\n        Value *ptr = runtime_sym_lookup(funcptype, f_lib, f_name, plt, libptrgv,\n                                        llvmgv, runtime_lib);\n        builder.CreateStore(builder.CreateBitCast(ptr, T_pvoidfunc), got);\n        SmallVector<Value*, 16> args;\n        for (Function::arg_iterator arg = plt->arg_begin(), arg_e = plt->arg_end(); arg != arg_e; ++arg)\n            args.push_back(&*arg);\n        CallInst *ret = builder.CreateCall(ptr, ArrayRef<Value*>(args));\n        ret->setAttributes(attrs);\n        if (cc != CallingConv::C)\n            ret->setCallingConv(cc);\n        // NoReturn function can trigger LLVM verifier error when declared as\n        // MustTail since other passes might replace the `ret` with\n        // `unreachable` (LLVM should probably accept `unreachable`).\n        if (attrs.hasAttribute(AttributeSet::FunctionIndex,\n                               Attribute::NoReturn)) {\n            builder.CreateUnreachable();\n        }\n        else {\n            // musttail support is very bad on ARM, PPC, PPC64 (as of LLVM 3.9)\n            // Known failures includes vararg (not needed here) and sret.\n#if defined(LLVM37) && (defined(_CPU_X86_) || defined(_CPU_X86_64_) || \\\n                        defined(_CPU_AARCH64_))\n            ret->setTailCallKind(CallInst::TCK_MustTail);\n#endif\n            if (functype->getReturnType() == T_void) {\n                builder.CreateRetVoid();\n            }\n            else {\n                builder.CreateRet(ret);\n            }\n        }\n        builder.SetInsertPoint(old);\n        builder.SetCurrentDebugLocation(olddl);\n        jl_finalize_module(M, true);\n        auto shadowgot =\n            cast<GlobalVariable>(shadow_output->getNamedValue(gname));\n        auto shadowplt = cast<Function>(shadow_output->getNamedValue(fname));\n        shadowgot->setInitializer(ConstantExpr::getBitCast(shadowplt,\n                                                           T_pvoidfunc));\n        got = prepare_global(shadowgot);\n    }\n    else {\n        // `runtime_sym_gvs` shouldn't have created anything in a new module\n        // if it returns a GV that already exists.\n        assert(!LM.m);\n        got = prepare_global(slot);\n    }\n    return builder.CreateBitCast(builder.CreateLoad(got), funcptype);\n}\n\n// --- ABI Implementations ---\n// Partially based on the LDC ABI implementations licensed under the BSD 3-clause license\n\n#if defined ABI_LLVM\n#  include \"abi_llvm.cpp\"\n#elif defined _CPU_X86_64_\n#  if defined _OS_WINDOWS_\n#    include \"abi_win64.cpp\"\n#  else\n#    include \"abi_x86_64.cpp\"\n#  endif\n#elif defined _CPU_X86_\n#  if defined _OS_WINDOWS_\n#    include \"abi_win32.cpp\"\n#  else\n#    include \"abi_x86.cpp\"\n#  endif\n#elif defined _CPU_ARM_\n#  include \"abi_arm.cpp\"\n#elif defined _CPU_AARCH64_\n#  include \"abi_aarch64.cpp\"\n#elif defined _CPU_PPC64_\n#  include \"abi_ppc64le.cpp\"\n#else\n#  warning \"ccall is defaulting to llvm ABI, since no platform ABI has been defined for this CPU/OS combination\"\n#  include \"abi_llvm.cpp\"\n#endif\n\nValue *llvm_type_rewrite(Value *v, Type *from_type, Type *target_type,\n        bool tojulia, /* only matters if byref is set (declares the direction of the byref attribute) */\n        bool byref, /* only applies to arguments, set false for return values -- effectively the same as jl_cgval_t.ispointer() */\n        bool issigned, /* determines whether an integer value should be zero or sign extended */\n        jl_codectx_t *ctx)\n{\n    if (v->getType() == T_void)\n        return UndefValue::get(target_type); // convert undef (unreachable) -> undef (target_type)\n\n    if (byref) {\n        if (tojulia) {\n            Type *ptarget_type = PointerType::get(target_type, 0);\n            if (v->getType() != ptarget_type)\n                v = builder.CreatePointerCast(v, ptarget_type);\n            return builder.CreateAlignedLoad(v, 1); // unknown alignment from C\n        }\n        else {\n            // julia_to_native should already have done the alloca and store\n            if (v->getType() != target_type)\n                v = builder.CreatePointerCast(v, target_type);\n            return v;\n        }\n    }\n    assert(v->getType() == from_type);\n\n    if (target_type == from_type) {\n        return v;\n    }\n\n    assert(from_type->isPointerTy() == target_type->isPointerTy()); // expect that all ABIs consider all pointers to be equivalent\n    if (target_type->isPointerTy()) {\n        return builder.CreatePointerCast(v, target_type);\n    }\n\n    // simple integer and float widening & conversion cases\n    if (from_type->getPrimitiveSizeInBits() > 0 && target_type->getPrimitiveSizeInBits() == from_type->getPrimitiveSizeInBits()) {\n        return emit_bitcast(v, target_type);\n    }\n    if (target_type->isFloatingPointTy() && from_type->isFloatingPointTy()) {\n        if (target_type->getPrimitiveSizeInBits() > from_type->getPrimitiveSizeInBits())\n            return builder.CreateFPExt(v, target_type);\n        else if (target_type->getPrimitiveSizeInBits() < from_type->getPrimitiveSizeInBits())\n            return builder.CreateFPTrunc(v, target_type);\n        else\n            return v;\n    }\n    if (target_type->isIntegerTy() && from_type->isIntegerTy()) {\n        if (issigned)\n            return builder.CreateSExtOrTrunc(v, target_type);\n        else\n            return builder.CreateZExtOrTrunc(v, target_type);\n    }\n\n    // one or both of from_type and target_type is a VectorType or AggregateType\n    // LLVM doesn't allow us to cast these values directly, so\n    // we need to use this alloca copy trick instead\n    // On ARM and AArch64, the ABI requires casting through memory to different\n    // sizes.\n    Value *from;\n    Value *to;\n#ifdef LLVM36\n    const DataLayout &DL = jl_ExecutionEngine->getDataLayout();\n#else\n    const DataLayout &DL = *jl_ExecutionEngine->getDataLayout();\n#endif\n    if (DL.getTypeAllocSize(target_type) >= DL.getTypeAllocSize(from_type)) {\n        to = emit_static_alloca(target_type, ctx);\n        from = builder.CreatePointerCast(to, from_type->getPointerTo());\n    }\n    else {\n        from = emit_static_alloca(from_type, ctx);\n        to = builder.CreatePointerCast(from, target_type->getPointerTo());\n    }\n    builder.CreateStore(v, from);\n    return builder.CreateLoad(to);\n}\n\n// --- argument passing and scratch space utilities ---\n\n// Emit code to convert argument to form expected by C ABI\n// to = desired LLVM type\n// jlto = Julia type of formal argument\n// jvinfo = value of actual argument\nstatic Value *julia_to_native(Type *to, bool toboxed, jl_value_t *jlto, const jl_cgval_t &jvinfo,\n                              bool addressOf, bool byRef, bool inReg, bool needCopy,\n                              bool tojulia, int argn, jl_codectx_t *ctx,\n                              bool *needStackRestore)\n{\n    // We're passing Any\n    if (toboxed) {\n        assert(!addressOf && !byRef); // don't expect any ABI to pass pointers by pointer\n        return boxed(jvinfo, ctx);\n    }\n    assert(jl_is_leaf_type(jlto));\n\n    // TODO: Tuple arguments are currently undefined behavior, for defining the calling convention that they match to.\n    // XXX: However, they are used in the llvmcall test, so I guess it'll have to stay.\n    //if (jl_is_tuple(jlto) || jl_is_tuple_type(jlto)) {\n    //    emit_error(\"ccall: unimplemented: unboxed tuple argument type\", ctx);\n    //    return UndefValue::get(to);\n    //}\n\n    jl_value_t *ety = jlto;\n    if (addressOf) {\n        if (!jl_is_cpointer_type(jlto)) {\n            emit_error(\"ccall: & on argument was not matched by Ptr{T} argument type\", ctx);\n            return UndefValue::get(T_void);\n        }\n        ety = jl_tparam0(jlto);\n        if (jlto == (jl_value_t*)jl_voidpointer_type)\n            ety = jvinfo.typ; // skip the type-check\n        assert(to->isPointerTy());\n    }\n    if (jvinfo.typ != ety && ety != (jl_value_t*)jl_any_type) {\n        if (!addressOf && ety == (jl_value_t*)jl_voidpointer_type) {\n            // allow a bit more flexibility for what can be passed to (void*) due to Ref{T} conversion behavior below\n            if (!jl_is_cpointer_type(jvinfo.typ)) {\n                // emit a typecheck, if not statically known to be correct\n                std::stringstream msg;\n                msg << \"ccall argument \";\n                msg << argn;\n                emit_cpointercheck(jvinfo, msg.str(), ctx);\n            }\n        }\n        else {\n            // emit a typecheck, if not statically known to be correct\n            std::stringstream msg;\n            msg << \"ccall argument \";\n            msg << argn;\n            emit_typecheck(jvinfo, ety, msg.str(), ctx);\n        }\n    }\n\n    if (!addressOf && !byRef)\n        return emit_unbox(to, jvinfo, ety);\n\n    if (addressOf && jvinfo.isboxed) {\n        if (!jl_is_abstracttype(ety)) {\n            if (jl_is_mutable_datatype(ety)) {\n                // no copy, just reference the data field\n                return data_pointer(jvinfo, ctx, to);\n            }\n            else if (jl_is_immutable_datatype(ety) && jlto != (jl_value_t*)jl_voidpointer_type) {\n                // yes copy\n                Value *nbytes;\n                AllocaInst *ai;\n                if (jl_is_leaf_type(ety)) {\n                    int nb = jl_datatype_size(ety);\n                    nbytes = ConstantInt::get(T_int32, nb);\n                    ai = emit_static_alloca(T_int8, nb, ctx);\n                }\n                else {\n                    nbytes = emit_datatype_size(emit_typeof_boxed(jvinfo,ctx));\n                    ai = builder.CreateAlloca(T_int8, nbytes);\n                    *needStackRestore = true;\n                }\n                ai->setAlignment(16);\n                prepare_call(\n                    builder.CreateMemCpy(ai, data_pointer(jvinfo, ctx, T_pint8), nbytes, sizeof(void*))->getCalledValue()); // minimum gc-alignment in julia is pointer size\n                return emit_bitcast(ai, to);\n            }\n        }\n        // emit maybe copy\n        *needStackRestore = true;\n        Value *jvt = emit_typeof_boxed(jvinfo, ctx);\n        BasicBlock *mutableBB = BasicBlock::Create(jl_LLVMContext,\"is-mutable\",ctx->f);\n        BasicBlock *immutableBB = BasicBlock::Create(jl_LLVMContext,\"is-immutable\",ctx->f);\n        BasicBlock *afterBB = BasicBlock::Create(jl_LLVMContext,\"after\",ctx->f);\n        Value *ismutable = emit_datatype_mutabl(jvt);\n        builder.CreateCondBr(ismutable, mutableBB, immutableBB);\n        builder.SetInsertPoint(mutableBB);\n        Value *p1 = data_pointer(jvinfo, ctx, to);\n        builder.CreateBr(afterBB);\n        builder.SetInsertPoint(immutableBB);\n        Value *nbytes = emit_datatype_size(jvt);\n        AllocaInst *ai = builder.CreateAlloca(T_int8, nbytes);\n        ai->setAlignment(16);\n        prepare_call(builder.CreateMemCpy(ai, data_pointer(jvinfo, ctx, T_pint8), nbytes, sizeof(void*))->getCalledValue()); // minimum gc-alignment in julia is pointer size\n        Value *p2 = emit_bitcast(ai, to);\n        builder.CreateBr(afterBB);\n        builder.SetInsertPoint(afterBB);\n        PHINode *p = builder.CreatePHI(to, 2);\n        p->addIncoming(p1, mutableBB);\n        p->addIncoming(p2, immutableBB);\n        return p;\n    }\n\n    // pass the address of an alloca'd thing, not a box\n    // since those are immutable.\n    if (addressOf)\n        to = to->getContainedType(0);\n    Value *slot = emit_static_alloca(to, ctx);\n    if (!jvinfo.ispointer()) {\n        builder.CreateStore(emit_unbox(to, jvinfo, ety), slot);\n    }\n    else {\n        prepare_call(builder.CreateMemCpy(slot, data_pointer(jvinfo, ctx, slot->getType()),\n                    (uint64_t)jl_datatype_size(ety),\n                    (uint64_t)((jl_datatype_t*)ety)->layout->alignment)->getCalledValue());\n        mark_gc_use(jvinfo);\n    }\n    return slot;\n}\n\ntypedef struct {\n    Value *jl_ptr;  // if the argument is a run-time computed pointer\n    void (*fptr)(void);     // if the argument is a constant pointer\n    const char *f_name;   // if the symbol name is known\n    const char *f_lib;    // if a library name is specified\n} native_sym_arg_t;\n\n// --- parse :sym or (:sym, :lib) argument into address info ---\nstatic native_sym_arg_t interpret_symbol_arg(jl_value_t *arg, jl_codectx_t *ctx, const char *fname)\n{\n    jl_value_t *ptr = NULL;\n    Value *jl_ptr=NULL;\n\n    ptr = static_eval(arg, ctx, true);\n    if (ptr == NULL) {\n        jl_value_t *ptr_ty = expr_type(arg, ctx);\n        jl_cgval_t arg1 = emit_expr(arg, ctx);\n        if (!jl_is_cpointer_type(ptr_ty)) {\n            emit_cpointercheck(arg1,\n                               !strcmp(fname,\"ccall\") ?\n                               \"ccall: first argument not a pointer or valid constant expression\" :\n                               \"cglobal: first argument not a pointer or valid constant expression\",\n                               ctx);\n        }\n        arg1 = remark_julia_type(arg1, (jl_value_t*)jl_voidpointer_type);\n        jl_ptr = emit_unbox(T_size, arg1, (jl_value_t*)jl_voidpointer_type);\n    }\n\n    void (*fptr)(void) = NULL;\n    const char *f_name=NULL, *f_lib=NULL;\n    jl_value_t *t0 = NULL, *t1 = NULL;\n    JL_GC_PUSH3(&ptr, &t0, &t1);\n    if (ptr != NULL) {\n        if (jl_is_tuple(ptr) && jl_nfields(ptr)==1) {\n            ptr = jl_fieldref(ptr,0);\n        }\n        if (jl_is_symbol(ptr))\n            f_name = jl_symbol_name((jl_sym_t*)ptr);\n        else if (jl_is_string(ptr))\n            f_name = jl_string_data(ptr);\n        if (f_name != NULL) {\n            // just symbol, default to JuliaDLHandle\n            // will look in process symbol table\n#ifdef _OS_WINDOWS_\n            f_lib = jl_dlfind_win32(f_name);\n#endif\n        }\n        else if (jl_is_cpointer_type(jl_typeof(ptr))) {\n            fptr = *(void(**)(void))jl_data_ptr(ptr);\n        }\n        else if (jl_is_tuple(ptr) && jl_nfields(ptr)>1) {\n            jl_value_t *t0 = jl_fieldref(ptr,0);\n            jl_value_t *t1 = jl_fieldref(ptr,1);\n            if (jl_is_symbol(t0))\n                f_name = jl_symbol_name((jl_sym_t*)t0);\n            else if (jl_is_string(t0))\n                f_name = jl_string_data(t0);\n            else\n                JL_TYPECHKS(fname, symbol, t0);\n            if (jl_is_symbol(t1))\n                f_lib = jl_symbol_name((jl_sym_t*)t1);\n            else if (jl_is_string(t1))\n                f_lib = jl_string_data(t1);\n            else\n                JL_TYPECHKS(fname, symbol, t1);\n        }\n        else {\n            JL_TYPECHKS(fname, pointer, ptr);\n        }\n    }\n    JL_GC_POP();\n    native_sym_arg_t r;\n    r.jl_ptr = jl_ptr;\n    r.fptr = fptr;\n    r.f_name = f_name;\n    r.f_lib = f_lib;\n    return r;\n}\n\n\nstatic jl_value_t* try_eval(jl_value_t *ex, jl_codectx_t *ctx, const char *failure, bool compiletime=false)\n{\n    jl_value_t *constant = NULL;\n    constant = static_eval(ex, ctx, true, true);\n    if (constant || jl_is_ssavalue(ex))\n        return constant;\n    JL_TRY {\n        constant = jl_interpret_toplevel_expr_in(ctx->module, ex, ctx->linfo);\n    }\n    JL_CATCH {\n        if (compiletime)\n            jl_rethrow_with_add(failure);\n        if (failure)\n            emit_error(failure, ctx);\n        constant = NULL;\n    }\n    return constant;\n}\n\n// --- code generator for cglobal ---\n\nstatic jl_cgval_t emit_cglobal(jl_value_t **args, size_t nargs, jl_codectx_t *ctx)\n{\n    JL_NARGS(cglobal, 1, 2);\n    jl_value_t *rt=NULL;\n    Value *res;\n    JL_GC_PUSH1(&rt);\n\n    if (nargs == 2) {\n        rt = try_eval(args[2], ctx, \"error interpreting cglobal pointer type\");\n        if (rt == NULL) {\n            JL_GC_POP();\n            return jl_cgval_t();\n        }\n\n        JL_TYPECHK(cglobal, type, rt);\n        rt = (jl_value_t*)jl_apply_type((jl_value_t*)jl_pointer_type, jl_svec1(rt));\n    }\n    else {\n        rt = (jl_value_t*)jl_voidpointer_type;\n    }\n    Type *lrt = julia_type_to_llvm(rt);\n    if (lrt == NULL) lrt = T_pint8;\n\n    native_sym_arg_t sym = interpret_symbol_arg(args[1], ctx, \"cglobal\");\n\n    if (sym.jl_ptr != NULL) {\n        res = builder.CreateIntToPtr(sym.jl_ptr, lrt);\n    }\n    else if (sym.fptr != NULL) {\n        res = literal_static_pointer_val((void*)(uintptr_t)sym.fptr, lrt);\n        if (imaging_mode)\n            jl_printf(JL_STDERR,\"WARNING: literal address used in cglobal for %s; code cannot be statically compiled\\n\", sym.f_name);\n    }\n    else {\n        if (imaging_mode) {\n            res = runtime_sym_lookup((PointerType*)lrt, sym.f_lib, sym.f_name, ctx->f);\n        }\n        else {\n            void *symaddr = jl_dlsym_e(jl_get_library(sym.f_lib), sym.f_name);\n            if (symaddr == NULL) {\n                std::stringstream msg;\n                msg << \"cglobal: could not find symbol \";\n                msg << sym.f_name;\n                if (sym.f_lib != NULL) {\n#ifdef _OS_WINDOWS_\n                    assert((intptr_t)sym.f_lib != 1 && (intptr_t)sym.f_lib != 2);\n#endif\n                    msg << \" in library \";\n                    msg << sym.f_lib;\n                }\n                emit_error(msg.str(), ctx);\n            }\n            // since we aren't saving this code, there's no sense in\n            // putting anything complicated here: just JIT the address of the cglobal\n            res = literal_static_pointer_val(symaddr, lrt);\n        }\n    }\n\n    JL_GC_POP();\n    return mark_julia_type(res, false, rt, ctx);\n}\n\n#ifdef USE_MCJIT\nclass FunctionMover : public ValueMaterializer\n{\npublic:\n    FunctionMover(llvm::Module *dest,llvm::Module *src) :\n        ValueMaterializer(), VMap(), destModule(dest), srcModule(src),\n        LazyFunctions(0)\n    {\n    }\n    ValueToValueMapTy VMap;\n    llvm::Module *destModule;\n    llvm::Module *srcModule;\n    std::vector<Function *> LazyFunctions;\n\n    Function *CloneFunctionProto(Function *F)\n    {\n        assert(!F->isDeclaration());\n        Function *NewF = Function::Create(F->getFunctionType(),\n                                          Function::ExternalLinkage,\n                                          F->getName(),\n                                          destModule);\n        LazyFunctions.push_back(F);\n        VMap[F] = NewF;\n        return NewF;\n    }\n\n    void CloneFunctionBody(Function *F)\n    {\n        Function *NewF = (Function*)(Value*)VMap[F];\n        assert(NewF != NULL);\n\n        Function::arg_iterator DestI = NewF->arg_begin();\n        for (Function::const_arg_iterator I = F->arg_begin(), E = F->arg_end(); I != E; ++I) {\n            DestI->setName(I->getName());    // Copy the name over...\n            VMap[&*I] = &*(DestI++);        // Add mapping to VMap\n        }\n\n    #ifdef LLVM36\n        // Clone debug info - Not yet public API\n        // llvm::CloneDebugInfoMetadata(NewF,F,VMap);\n    #endif\n\n        SmallVector<ReturnInst*, 8> Returns;\n        llvm::CloneFunctionInto(NewF,F,VMap,true,Returns,\"\",NULL,NULL,this);\n        NewF->setComdat(nullptr);\n        NewF->setSection(\"\");\n    }\n\n    Function *CloneFunction(Function *F)\n    {\n        Function *NewF = (llvm::Function*)MapValue(F,VMap,RF_None,NULL,this);\n        ResolveLazyFunctions();\n        return NewF;\n    }\n\n    void ResolveLazyFunctions()\n    {\n        while (!LazyFunctions.empty()) {\n            Function *F = LazyFunctions.back();\n            LazyFunctions.pop_back();\n\n            CloneFunctionBody(F);\n        }\n    }\n\n    Value *InjectFunctionProto(Function *F)\n    {\n        Function *NewF = destModule->getFunction(F->getName());\n        if (!NewF) {\n            NewF = function_proto(F);\n            NewF->setComdat(nullptr);\n            destModule->getFunctionList().push_back(NewF);\n        }\n        return NewF;\n    }\n\n#if defined(LLVM39)\n    virtual Value *materialize(Value *V) override\n#elif defined(LLVM38)\n    virtual Value *materializeDeclFor(Value *V) override\n#else\n    virtual Value *materializeValueFor (Value *V) override\n#endif\n    {\n        Function *F = dyn_cast<Function>(V);\n        if (F) {\n            if (isIntrinsicFunction(F)) {\n                return destModule->getOrInsertFunction(F->getName(),F->getFunctionType());\n            }\n            if (F->isDeclaration() || F->getParent() != destModule) {\n                if (F->getName().empty())\n                    return CloneFunctionProto(F);\n                Function *shadow = srcModule->getFunction(F->getName());\n                if (shadow != NULL && !shadow->isDeclaration()) {\n                    Function *oldF = destModule->getFunction(F->getName());\n                    if (oldF)\n                        return oldF;\n\n                    #ifdef USE_ORCJIT\n                    if (jl_ExecutionEngine->findSymbol(F->getName(), false))\n                        return InjectFunctionProto(F);\n                    #endif\n\n                    return CloneFunctionProto(shadow);\n                }\n                else if (!F->isDeclaration()) {\n                    return CloneFunctionProto(F);\n                }\n            }\n            // Still a declaration and still in a different module\n            if (F->isDeclaration() && F->getParent() != destModule) {\n                // Create forward declaration in current module\n                return InjectFunctionProto(F);\n            }\n        }\n        else if (isa<GlobalVariable>(V)) {\n            GlobalVariable *GV = cast<GlobalVariable>(V);\n            assert(GV != NULL);\n            GlobalVariable *oldGV = destModule->getGlobalVariable(GV->getName());\n            if (oldGV != NULL)\n                return oldGV;\n            GlobalVariable *newGV = new GlobalVariable(*destModule,\n                GV->getType()->getElementType(),\n                GV->isConstant(),\n                GlobalVariable::ExternalLinkage,\n                NULL,\n                GV->getName(),\n                NULL,\n                GV->getThreadLocalMode(),\n                GV->getType()->getPointerAddressSpace());\n            newGV->copyAttributesFrom(GV);\n            newGV->setComdat(nullptr);\n            if (GV->isDeclaration())\n                return newGV;\n            if (!GV->getName().empty()) {\n                uint64_t addr = jl_ExecutionEngine->getGlobalValueAddress(GV->getName());\n                if (addr != 0) {\n                    newGV->setExternallyInitialized(true);\n                    return newGV;\n                }\n            }\n            if (GV->hasInitializer()) {\n                Value *C = MapValue(GV->getInitializer(),VMap,RF_None,NULL,this);\n                newGV->setInitializer(cast<Constant>(C));\n            }\n            return newGV;\n        }\n        return NULL;\n    };\n};\n#endif\n\n// llvmcall(ir, (rettypes...), (argtypes...), args...)\nstatic jl_cgval_t emit_llvmcall(jl_value_t **args, size_t nargs, jl_codectx_t *ctx)\n{\n    JL_NARGSV(llvmcall, 3);\n    jl_value_t *rt = NULL, *at = NULL, *ir = NULL, *decl = NULL;\n    jl_svec_t *stt = NULL;\n    JL_GC_PUSH5(&ir, &rt, &at, &stt, &decl);\n    at = try_eval(args[3], ctx, \"error statically evaluating llvmcall argument tuple\", true);\n    rt = try_eval(args[2], ctx, \"error statically evaluating llvmcall return type\", true);\n    ir = try_eval(args[1], ctx, \"error statically evaluating llvm IR argument\", true);\n    int i = 1;\n    if (jl_is_tuple(ir)) {\n        // if the IR is a tuple, we expect (declarations, ir)\n        if (jl_nfields(ir) != 2)\n            jl_error(\"Tuple as first argument to llvmcall must have exactly two children\");\n        decl = jl_fieldref(ir,0);\n        ir = jl_fieldref(ir,1);\n        if (!jl_is_string(decl))\n            jl_error(\"Declarations passed to llvmcall must be a string\");\n    }\n    bool isString = jl_is_string(ir);\n    bool isPtr = jl_is_cpointer(ir);\n    if (!isString && !isPtr) {\n        jl_error(\"IR passed to llvmcall must be a string or pointer to an LLVM Function\");\n    }\n\n    JL_TYPECHK(llvmcall, type, rt);\n    JL_TYPECHK(llvmcall, type, at);\n\n    std::stringstream ir_stream;\n\n    stt = jl_alloc_svec(nargs - 3);\n\n    for (size_t i = 0; i < nargs-3; ++i) {\n        jl_svecset(stt,i,expr_type(args[4+i],ctx));\n    }\n\n    // Generate arguments\n    std::string arguments;\n    llvm::raw_string_ostream argstream(arguments);\n    jl_svec_t *tt = ((jl_datatype_t*)at)->parameters;\n    jl_value_t *rtt = rt;\n\n    size_t nargt = jl_svec_len(tt);\n    Value **argvals = (Value**) alloca(nargt*sizeof(Value*));\n    std::vector<llvm::Type*> argtypes;\n    /*\n     * Semantics for arguments are as follows:\n     * If the argument type is immutable (including bitstype), we pass the loaded llvm value\n     * type. Otherwise we pass a pointer to a jl_value_t.\n     */\n    jl_cgval_t *argv = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * nargt);\n    for (size_t i = 0; i < nargt; ++i) {\n        jl_value_t *tti = jl_svecref(tt,i);\n        bool toboxed;\n        Type *t = julia_type_to_llvm(tti, &toboxed);\n        argtypes.push_back(t);\n        if (4+i > nargs) {\n            jl_error(\"Missing arguments to llvmcall!\");\n        }\n        jl_value_t *argi = args[4 + i];\n        jl_cgval_t &arg = argv[i];\n        arg = emit_expr(argi, ctx);\n\n        Value *v = julia_to_native(t, toboxed, tti, arg, false, false, false, false, false, i, ctx, NULL);\n        // make sure args are rooted\n        bool issigned = jl_signed_type && jl_subtype(tti, (jl_value_t*)jl_signed_type, 0);\n        argvals[i] = llvm_type_rewrite(v, t, t, false, false, issigned, ctx);\n    }\n\n    Function *f;\n    bool retboxed;\n    Type *rettype = julia_type_to_llvm(rtt, &retboxed);\n    if (isString) {\n        // Make sure to find a unique name\n        std::string ir_name;\n        while(true) {\n            std::stringstream name;\n            name << (ctx->f->getName().str()) << \"u\" << i++;\n            ir_name = name.str();\n            if (jl_Module->getFunction(ir_name) == NULL)\n                break;\n        }\n\n        bool first = true;\n        for (std::vector<Type *>::iterator it = argtypes.begin(); it != argtypes.end(); ++it) {\n            if (!first)\n                argstream << \",\";\n            else\n                first = false;\n            (*it)->print(argstream);\n            argstream << \" \";\n        }\n\n        std::string rstring;\n        llvm::raw_string_ostream rtypename(rstring);\n        rettype->print(rtypename);\n        std::map<uint64_t,std::string> localDecls;\n\n        if (decl != NULL) {\n            std::stringstream declarations(jl_string_data(decl));\n\n            // parse string line by line\n            std::string declstr;\n            while (std::getline(declarations, declstr, '\\n')) {\n                // Find name of declaration by searching for '@'\n                std::string::size_type atpos = declstr.find('@') + 1;\n                // Find end of declaration by searching for '('\n                std::string::size_type bracepos = declstr.find('(', atpos);\n                // Declaration name is the string between @ and (\n                std::string declname = declstr.substr(atpos, bracepos - atpos);\n\n                // Check if declaration already present in module\n                if(jl_Module->getNamedValue(declname) == NULL) {\n                    ir_stream << \"; Declarations\\n\" << declstr << \"\\n\";\n                }\n            }\n        }\n        ir_stream << \"; Number of arguments: \" << nargt << \"\\n\"\n        << \"define \"<<rtypename.str()<<\" @\\\"\" << ir_name << \"\\\"(\"<<argstream.str()<<\") {\\n\"\n        << jl_string_data(ir) << \"\\n}\";\n        SMDiagnostic Err = SMDiagnostic();\n        std::string ir_string = ir_stream.str();\n#ifdef LLVM36\n        Module *m = NULL;\n        bool failed = parseAssemblyInto(llvm::MemoryBufferRef(ir_string,\"llvmcall\"),*jl_Module,Err);\n        if (!failed)\n            m = jl_Module;\n#else\n        Module *m = ParseAssemblyString(ir_string.c_str(),jl_Module,Err,jl_LLVMContext);\n#endif\n        if (m == NULL) {\n            std::string message = \"Failed to parse LLVM Assembly: \\n\";\n            llvm::raw_string_ostream stream(message);\n            Err.print(\"julia\",stream,true);\n            jl_error(stream.str().c_str());\n        }\n        f = m->getFunction(ir_name);\n    }\n    else {\n        assert(isPtr);\n        // Create Function skeleton\n        f = (llvm::Function*)jl_unbox_voidpointer(ir);\n        assert(f->getReturnType() == rettype);\n        int i = 0;\n        for (std::vector<Type *>::iterator it = argtypes.begin();\n            it != argtypes.end(); ++it, ++i)\n            assert(*it == f->getFunctionType()->getParamType(i));\n\n#ifdef USE_MCJIT\n        if (f->getParent() != jl_Module) {\n            FunctionMover mover(jl_Module, f->getParent());\n            f = mover.CloneFunction(f);\n        }\n#endif\n\n        //f->dump();\n        #ifndef LLVM35\n        if (verifyFunction(*f,PrintMessageAction)) {\n        #else\n        llvm::raw_fd_ostream out(1,false);\n        if (verifyFunction(*f,&out)) {\n        #endif\n            f->dump();\n            jl_error(\"Malformed LLVM Function\");\n        }\n    }\n\n    /*\n     * It might be tempting to just try to set the Always inline attribute on the function\n     * and hope for the best. However, this doesn't work since that would require an inlining\n     * pass (which is a Call Graph pass and cannot be managed by a FunctionPassManager). Instead\n     * We are sneaky and call the inliner directly. This however doesn't work until we've actually\n     * generated the entire function, so we need to store it in the context until the end of the\n     * function. This also has the benefit of looking exactly like we cut/pasted it in in `code_llvm`.\n     */\n\n    // Since we dumped all of f's dependencies into the active module,\n    // we cannot reasonably inline it, so leave it there and just emit\n    // a regular call\n    if (!isString) {\n        static int llvmcallnumbering = 0;\n        std::stringstream name;\n        name << \"jl_llvmcall\" << llvmcallnumbering++;\n        f->setName(name.str());\n        f = cast<Function>(prepare_call(function_proto(f)));\n    }\n    else\n        f->setLinkage(GlobalValue::LinkOnceODRLinkage);\n\n    // the actual call\n    builder.CreateCall(prepare_call(gcroot_flush_func));\n    SmallVector<Value*, 16> gc_uses;\n    for (size_t i = 0; i < nargt; ++i) {\n        const jl_cgval_t &arg = argv[i];\n        push_gc_use(gc_uses, arg);\n    }\n    // Mark GC use before **and** after the llvmcall to make sure the arguments\n    // are alive during the llvmcall even if the llvmcall has `unreachable`.\n    // If the llvmcall generates GC safepoint, it might need to emit its own\n    // gckill.\n    mark_gc_uses(gc_uses);\n    CallInst *inst = builder.CreateCall(f, ArrayRef<Value*>(&argvals[0], nargt));\n    if (isString)\n        ctx->to_inline.push_back(inst);\n    mark_gc_uses(gc_uses);\n\n    JL_GC_POP();\n\n    if (inst->getType() != rettype) {\n        jl_error(\"Return type of llvmcall'ed function does not match declared return type\");\n    }\n\n    return mark_julia_type(inst, retboxed, rtt, ctx);\n}\n\n// --- code generator for ccall itself ---\n\nstatic jl_cgval_t mark_or_box_ccall_result(Value *result, bool isboxed, jl_value_t *rt_expr, jl_value_t *rt, bool static_rt, jl_codectx_t *ctx)\n{\n    if (!static_rt) {\n        // box if concrete type was not statically known\n        assert(rt == (jl_value_t*)jl_voidpointer_type);\n        Value *runtime_bt = boxed(emit_expr(rt_expr, ctx), ctx);\n        int nb = sizeof(void*);\n        // TODO: can this be tighter than tbaa_value?\n        return mark_julia_type(\n            init_bits_value(emit_allocobj(ctx, nb, runtime_bt), result, tbaa_value),\n            true, (jl_value_t*)jl_pointer_type, ctx);\n    }\n    return mark_julia_type(result, isboxed, rt, ctx);\n}\n\nstatic std::string generate_func_sig(\n        Type **lrt, // input parameter of the llvm return type (from julia_struct_to_llvm)\n        Type **prt, // out parameter of the llvm return type for the function signature\n        int &sret, // out parameter for indicating whether return value has been moved to the first argument position\n        std::vector<Type *> &fargt, // vector of llvm output types (julia_struct_to_llvm) for arguments (vararg is the last item, if applicable)\n        std::vector<bool> &fargt_isboxed, // vector of whether the llvm output types is boxed for each argument (vararg is the last item, if applicable)\n        std::vector<Type *> &fargt_sig, // vector of ABI coercion types for call signature\n        Type *&fargt_vasig, // ABI coercion type for vararg list\n        std::vector<bool> &inRegList, // vector of \"inreg\" parameters (vararg is the last item, if applicable)\n        std::vector<bool> &byRefList, // vector of \"byref\" parameters (vararg is the last item, if applicable)\n        AttributeSet &attributes, // vector of function call site attributes (vararg is the last item, if applicable)\n        jl_value_t *rt, // julia return type\n        jl_svec_t *tt, // tuple of julia argument types\n        size_t nargs) // number of actual arguments (can be different from the size of tt when varargs)\n{\n    size_t nargt = jl_svec_len(tt);\n    assert(rt && !jl_is_abstract_ref_type(rt));\n\n    std::vector<AttrBuilder> paramattrs;\n    AbiState abi = default_abi_state;\n    sret = 0;\n\n    if (type_is_ghost(*lrt)) {\n        *prt = *lrt = T_void;\n    }\n    else {\n        if (!jl_is_datatype(rt) || ((jl_datatype_t*)rt)->layout == NULL || jl_is_cpointer_type(rt) || jl_is_array_type(rt)) {\n            *prt = *lrt; // passed as pointer\n        }\n        else if (use_sret(&abi, (jl_datatype_t*)rt)) {\n            paramattrs.push_back(AttrBuilder());\n            paramattrs[0].clear();\n#if !defined(_OS_WINDOWS_) || defined(LLVM35) // llvm used to use the old mingw ABI, skipping this marking works around that difference\n            paramattrs[0].addAttribute(Attribute::StructRet);\n#endif\n            paramattrs[0].addAttribute(Attribute::NoAlias);\n            fargt_sig.push_back(PointerType::get(*lrt, 0));\n            sret = 1;\n            *prt = *lrt;\n        }\n        else {\n            *prt = preferred_llvm_type((jl_datatype_t*)rt, true);\n            if (*prt == NULL)\n                *prt = *lrt;\n        }\n    }\n\n    size_t i;\n    bool current_isVa = false;\n    for(i = 0; i < nargt;) {\n        jl_value_t *tti = jl_svecref(tt,i);\n        if (jl_is_vararg_type(tti)) {\n            current_isVa = true;\n            tti = jl_tparam0(tti);\n        }\n        Type *t = NULL;\n        bool isboxed;\n        Attribute::AttrKind av = Attribute::None;\n        if (jl_is_abstract_ref_type(tti)) {\n            if (jl_is_typevar(jl_tparam0(tti)))\n                jl_error(\"ccall: argument type Ref should have an element type, not Ref{T}\");\n            tti = (jl_value_t*)jl_voidpointer_type;\n            t = T_pint8;\n            isboxed = false;\n        }\n        else {\n            if (jl_is_cpointer_type(tti) && jl_is_typevar(jl_tparam0(tti)))\n                jl_error(\"ccall: argument type Ptr should have an element type, not Ptr{T}\");\n            if (jl_is_bitstype(tti)) {\n                // see pull req #978. need to annotate signext/zeroext for\n                // small integer arguments.\n                jl_datatype_t *bt = (jl_datatype_t*)tti;\n                if (bt->size < 4) {\n                    if (jl_signed_type && jl_subtype(tti, (jl_value_t*)jl_signed_type, 0))\n                        av = Attribute::SExt;\n                    else\n                        av = Attribute::ZExt;\n                }\n            }\n\n            t = julia_struct_to_llvm(tti, &isboxed);\n            if (t == NULL || t == T_void) {\n                std::stringstream msg;\n                msg << \"ccall: the type of argument \";\n                msg << i+1;\n                msg << \" doesn't correspond to a C type\";\n                return msg.str();\n            }\n        }\n\n        // Whether or not LLVM wants us to emit a pointer to the data\n        bool byRef = false;\n\n        // Whether or not to pass this in registers\n        bool inReg = false;\n\n        Type *pat;\n        if (!jl_is_datatype(tti) || ((jl_datatype_t*)tti)->layout == NULL || jl_is_array_type(tti))\n            tti = (jl_value_t*)jl_voidpointer_type; // passed as pointer\n\n        needPassByRef(&abi, (jl_datatype_t*)tti, &byRef, &inReg);\n        if (jl_is_cpointer_type(tti)) {\n            pat = t;\n        }\n        else if (byRef) {\n            pat = PointerType::get(t, 0);\n        }\n        else {\n            pat = preferred_llvm_type((jl_datatype_t*)tti, false);\n            if (pat == NULL)\n                pat = t;\n        }\n\n        byRefList.push_back(byRef);\n        inRegList.push_back(inReg);\n        fargt.push_back(t);\n        fargt_isboxed.push_back(isboxed);\n        if (!current_isVa)\n            fargt_sig.push_back(pat);\n        else\n            fargt_vasig = pat;\n\n        do { // for each arg for which this type applies, add the appropriate LLVM parameter attributes\n            if (i < nargs) { // if vararg, the last declared arg type may not have a corresponding arg value\n                paramattrs.push_back(AttrBuilder());\n                // Note that even though the LLVM argument is called ByVal\n                // this really means that the thing we're passing is pointing to\n                // the thing we want to pass by value\n#ifndef _CPU_AARCH64_\n                // the aarch64 backend seems to interpret ByVal as\n                // implicitly passed on stack.\n                if (byRef)\n                    paramattrs[i + sret].addAttribute(Attribute::ByVal);\n#endif\n                if (inReg)\n                    paramattrs[i + sret].addAttribute(Attribute::InReg);\n                if (av != Attribute::None)\n                    paramattrs[i + sret].addAttribute(av);\n            }\n            i++;\n        } while (current_isVa && i < nargs); // if is this is the vararg, loop to the end\n    }\n\n    for (i = 0; i < nargs + sret; ++i) {\n        if (paramattrs[i].hasAttributes()) {\n            attributes = attributes.addAttributes(jl_LLVMContext, i + 1,\n                                                  AttributeSet::get(jl_LLVMContext, i + 1, paramattrs[i]));\n        }\n    }\n    if (rt == jl_bottom_type)\n        attributes = attributes.addAttribute(jl_LLVMContext,\n                                             AttributeSet::FunctionIndex,\n                                             Attribute::NoReturn);\n    return \"\";\n}\n\n\n// ccall(pointer, rettype, (argtypes...), args...)\nstatic jl_cgval_t emit_ccall(jl_value_t **args, size_t nargs, jl_codectx_t *ctx)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    JL_NARGSV(ccall, 3);\n    jl_value_t *rt=NULL, *at=NULL;\n    JL_GC_PUSH2(&rt, &at);\n\n    native_sym_arg_t symarg = interpret_symbol_arg(args[1], ctx, \"ccall\");\n    Value *jl_ptr=NULL;\n    void (*fptr)(void) = NULL;\n    const char *f_name = NULL, *f_lib = NULL;\n    jl_ptr = symarg.jl_ptr;\n    fptr = symarg.fptr;\n    f_name = symarg.f_name;\n    f_lib = symarg.f_lib;\n    bool isVa = false;\n\n    if (f_name == NULL && fptr == NULL && jl_ptr == NULL) {\n        emit_error(\"ccall: null function pointer\", ctx);\n        JL_GC_POP();\n        return jl_cgval_t();\n    }\n\n    jl_value_t *rtt_ = expr_type(args[2], ctx);\n    bool static_rt = true;  // is return type fully statically known?\n    if (jl_is_type_type(rtt_) && jl_is_leaf_type(jl_tparam0(rtt_))) {\n        rt = jl_tparam0(rtt_);\n    }\n    else {\n        rt = try_eval(args[2], ctx, NULL);\n        if (rt == NULL) {\n            static_rt = false;\n            if (jl_is_type_type(rtt_)) {\n                if (jl_subtype(jl_tparam0(rtt_), (jl_value_t*)jl_pointer_type, 0)) {\n                    // substitute Ptr{Void} for statically-unknown pointer type\n                    rt = (jl_value_t*)jl_voidpointer_type;\n                }\n                else if (jl_subtype(jl_tparam0(rtt_), (jl_value_t*)jl_array_type, 0)) {\n                    // `Array` used as return type just returns a julia object reference\n                    rt = (jl_value_t*)jl_any_type;\n                    static_rt = true;\n                }\n                else if (jl_is_typevar(jl_tparam0(rtt_)) && jl_is_abstract_ref_type(((jl_tvar_t*)jl_tparam0(rtt_))->ub)) {\n                    // `Ref{T}` used as return type just returns T (from a jl_value_t*)\n                    rt = (jl_value_t*)jl_any_type;\n                    static_rt = true;\n                }\n            }\n            if (rt == NULL) {\n                if (jl_is_expr(args[2])) {\n                    jl_expr_t *rtexpr = (jl_expr_t*)args[2];\n                    if (rtexpr->head == call_sym && jl_expr_nargs(rtexpr) == 4 &&\n                        static_eval(jl_exprarg(rtexpr, 0), ctx, true, false) == jl_builtin_apply_type &&\n                        static_eval(jl_exprarg(rtexpr, 1), ctx, true, false) == (jl_value_t*)jl_array_type) {\n                        // `Array` used as return type just returns a julia object reference\n                        rt = (jl_value_t*)jl_any_type;\n                        static_rt = true;\n                    }\n                    else if (rtexpr->head == call_sym && jl_expr_nargs(rtexpr) == 3 &&\n                             static_eval(jl_exprarg(rtexpr, 0), ctx, true, false) == jl_builtin_apply_type &&\n                             static_eval(jl_exprarg(rtexpr, 1), ctx, true, false) == (jl_value_t*)jl_pointer_type) {\n                        // substitute Ptr{Void} for statically-unknown pointer type\n                        rt = (jl_value_t*)jl_voidpointer_type;\n                    }\n                    else if (rtexpr->head == call_sym && jl_expr_nargs(rtexpr) == 3 &&\n                             static_eval(jl_exprarg(rtexpr, 0), ctx, true, false) == jl_builtin_apply_type &&\n                             static_eval(jl_exprarg(rtexpr, 1), ctx, true, false) == (jl_value_t*)jl_ref_type) {\n                        // `Ref{T}` used as return type just returns T (from a jl_value_t*)\n                        rt = (jl_value_t*)jl_any_type;\n                        static_rt = true;\n                    }\n                }\n            }\n            if (rt == NULL) {\n                if (ptls->exception_in_transit &&\n                    jl_typeis(ptls->exception_in_transit,\n                              jl_undefvarerror_type) &&\n                    jl_is_symbol(args[2])) {\n                    std::string msg = \"ccall return type undefined: \" +\n                                      std::string(jl_symbol_name((jl_sym_t*)args[2]));\n                    emit_error(msg.c_str(), ctx);\n                    JL_GC_POP();\n                    return jl_cgval_t();\n                }\n                emit_error(\"error interpreting ccall return type\", ctx);\n                JL_GC_POP();\n                return jl_cgval_t();\n            }\n        }\n    }\n\n    if (jl_is_svec(rt)) {\n        std::string msg = \"in \" + ctx->funcName +\n            \": ccall: missing return type\";\n        jl_error(msg.c_str());\n    }\n    if (jl_is_cpointer_type(rt) && jl_is_typevar(jl_tparam0(rt)))\n        jl_error(\"ccall: return type Ptr should have an element type, not Ptr{_<:T}\");\n\n    if (jl_is_abstract_ref_type(rt)) {\n        if (jl_tparam0(rt) == (jl_value_t*)jl_any_type)\n            jl_error(\"ccall: return type Ref{Any} is invalid. use Ptr{Any} instead.\");\n        rt = (jl_value_t*)jl_any_type; // convert return type to jl_value_t*\n    }\n\n    if (jl_is_array_type(rt)) {\n        // `Array` used as return type just returns a julia object reference\n        rt = (jl_value_t*)jl_any_type;\n    }\n\n    JL_TYPECHK(ccall, type, rt);\n    bool retboxed;\n    Type *lrt = julia_struct_to_llvm(rt, &retboxed);\n    if (lrt == NULL) {\n        emit_error(\"ccall: return type doesn't correspond to a C type\", ctx);\n        JL_GC_POP();\n        return jl_cgval_t();\n    }\n\n    at = try_eval(args[3], ctx, \"error interpreting ccall argument tuple\");\n    if (at == NULL) {\n        JL_GC_POP();\n        return jl_cgval_t();\n    }\n\n    JL_TYPECHK(ccall, simplevector, at);\n    //JL_TYPECHK(ccall, type, at);\n    jl_svec_t *tt = (jl_svec_t*)at;\n\n    // check for calling convention specifier\n    CallingConv::ID cc = CallingConv::C;\n    jl_value_t *last = args[nargs];\n    if (jl_is_expr(last)) {\n        jl_sym_t *lhd = ((jl_expr_t*)last)->head;\n        if (lhd == jl_symbol(\"stdcall\")) {\n            cc = CallingConv::X86_StdCall;\n            nargs--;\n        }\n        else if (lhd == jl_symbol(\"cdecl\")) {\n            cc = CallingConv::C;\n            nargs--;\n        }\n        else if (lhd == jl_symbol(\"fastcall\")) {\n            cc = CallingConv::X86_FastCall;\n            nargs--;\n        }\n        else if (lhd == jl_symbol(\"thiscall\")) {\n            cc = CallingConv::X86_ThisCall;\n            nargs--;\n        }\n    }\n\n    // some sanity checking and check whether there's a vararg\n    size_t i;\n    size_t nargt = jl_svec_len(tt);\n    for(i=0; i < nargt; i++) {\n        jl_value_t *tti = jl_svecref(tt,i);\n        if (jl_is_cpointer_type(tti) && jl_is_typevar(jl_tparam0(tti))) {\n            JL_GC_POP();\n            emit_error(\"ccall: argument type Ptr should have an element type, Ptr{T}\",ctx);\n            return jl_cgval_t();\n        }\n        if (jl_is_vararg_type(tti))\n            isVa = true;\n    }\n\n    if ((!isVa && nargt  != (nargs - 2)/2) ||\n        ( isVa && nargt-1 > (nargs - 2)/2))\n        jl_error(\"ccall: wrong number of arguments to C function\");\n\n    // some special functions\n    if (fptr == (void(*)(void))&jl_array_ptr ||\n        ((f_lib==NULL || (intptr_t)f_lib==2)\n         && f_name && !strcmp(f_name,\"jl_array_ptr\"))) {\n        assert(lrt->isPointerTy());\n        assert(!isVa);\n        assert(nargt==1);\n        jl_value_t *argi = args[4];\n        assert(!(jl_is_expr(argi) && ((jl_expr_t*)argi)->head == amp_sym));\n        jl_cgval_t ary = emit_expr(argi, ctx);\n        JL_GC_POP();\n        return mark_or_box_ccall_result(emit_bitcast(emit_arrayptr(ary, ctx), lrt),\n                                        retboxed, args[2], rt, static_rt, ctx);\n    }\n    if (fptr == (void(*)(void))&jl_value_ptr ||\n        ((f_lib==NULL || (intptr_t)f_lib==2)\n         && f_name && !strcmp(f_name,\"jl_value_ptr\"))) {\n        assert(lrt->isPointerTy());\n        assert(!isVa);\n        assert(nargt==1);\n        jl_value_t *argi = args[4];\n        bool addressOf = false;\n        jl_value_t *tti = jl_svecref(tt,0);\n        if (jl_is_expr(argi) && ((jl_expr_t*)argi)->head == amp_sym) {\n            addressOf = true;\n            argi = jl_exprarg(argi,0);\n        }\n        else if (jl_is_abstract_ref_type(tti)) {\n            tti = (jl_value_t*)jl_voidpointer_type;\n        }\n        Value *ary;\n        Type *largty;\n        bool isboxed;\n        if (addressOf) {\n            largty = T_pjlvalue;\n            isboxed = true;\n        }\n        else {\n            largty = julia_struct_to_llvm(tti, &isboxed);\n        }\n        if (isboxed) {\n            ary = boxed(emit_expr(argi, ctx), ctx);\n        }\n        else {\n            assert(!addressOf);\n            ary = emit_unbox(largty, emit_expr(argi, ctx), tti);\n        }\n        JL_GC_POP();\n        return mark_or_box_ccall_result(emit_bitcast(ary, lrt),\n                                        retboxed, args[2], rt, static_rt, ctx);\n    }\n    if (JL_CPU_WAKE_NOOP &&\n        (fptr == &jl_cpu_wake || ((!f_lib || (intptr_t)f_lib == 2) &&\n                                  f_name && !strcmp(f_name, \"jl_cpu_wake\")))) {\n        assert(lrt == T_void);\n        assert(!isVa);\n        assert(nargt == 0);\n        JL_GC_POP();\n        return ghostValue(jl_void_type);\n    }\n    if (fptr == &jl_gc_safepoint ||\n        ((!f_lib || (intptr_t)f_lib == 2) && f_name &&\n         strcmp(f_name, \"jl_gc_safepoint\") == 0)) {\n        assert(lrt == T_void);\n        assert(!isVa);\n        assert(nargt == 0);\n        JL_GC_POP();\n        builder.CreateCall(prepare_call(gcroot_flush_func));\n        emit_signal_fence();\n        builder.CreateLoad(ctx->signalPage, true);\n        emit_signal_fence();\n        return ghostValue(jl_void_type);\n    }\n#ifdef _OS_LINUX_\n    // directly access the address of a ifunc can cause linker issue on\n    // some configurations (e.g. AArch64 + -Bsymbolic-functions).\n    static const auto ptls_getter = jl_dlsym_e(jl_dlopen(nullptr, 0),\n                                               \"jl_get_ptls_states\");\n#else\n    static const auto ptls_getter = &jl_get_ptls_states;\n#endif\n    if (fptr == (void(*)(void))(uintptr_t)ptls_getter ||\n        ((!f_lib || (intptr_t)f_lib == 2) && f_name &&\n         strcmp(f_name, \"jl_get_ptls_states\") == 0)) {\n        assert(lrt == T_pint8);\n        assert(!isVa);\n        assert(nargt == 0);\n        JL_GC_POP();\n        return mark_or_box_ccall_result(\n            emit_bitcast(ctx->ptlsStates, lrt),\n            retboxed, args[2], rt, static_rt, ctx);\n    }\n    if (fptr == &jl_sigatomic_begin ||\n        ((!f_lib || (intptr_t)f_lib == 2) && f_name &&\n         strcmp(f_name, \"jl_sigatomic_begin\") == 0)) {\n        assert(lrt == T_void);\n        assert(!isVa);\n        assert(nargt == 0);\n        JL_GC_POP();\n        builder.CreateCall(prepare_call(gcroot_flush_func));\n        Value *pdefer_sig = emit_defer_signal(ctx);\n        Value *defer_sig = builder.CreateLoad(pdefer_sig);\n        defer_sig = builder.CreateAdd(defer_sig,\n                                      ConstantInt::get(T_sigatomic, 1));\n        builder.CreateStore(defer_sig, pdefer_sig);\n        emit_signal_fence();\n        return ghostValue(jl_void_type);\n    }\n    if (fptr == &jl_sigatomic_end ||\n        ((!f_lib || (intptr_t)f_lib == 2) && f_name &&\n         strcmp(f_name, \"jl_sigatomic_end\") == 0)) {\n        assert(lrt == T_void);\n        assert(!isVa);\n        assert(nargt == 0);\n        JL_GC_POP();\n        builder.CreateCall(prepare_call(gcroot_flush_func));\n        Value *pdefer_sig = emit_defer_signal(ctx);\n        Value *defer_sig = builder.CreateLoad(pdefer_sig);\n        emit_signal_fence();\n        error_unless(builder.CreateICmpNE(defer_sig,\n                                          ConstantInt::get(T_sigatomic, 0)),\n                     \"sigatomic_end called in non-sigatomic region\", ctx);\n        defer_sig = builder.CreateSub(defer_sig,\n                                      ConstantInt::get(T_sigatomic, 1));\n        builder.CreateStore(defer_sig, pdefer_sig);\n        BasicBlock *checkBB = BasicBlock::Create(jl_LLVMContext, \"check\",\n                                                 ctx->f);\n        BasicBlock *contBB = BasicBlock::Create(jl_LLVMContext, \"cont\");\n        builder.CreateCondBr(\n            builder.CreateICmpEQ(defer_sig, ConstantInt::get(T_sigatomic, 0)),\n            checkBB, contBB);\n        builder.SetInsertPoint(checkBB);\n        builder.CreateLoad(builder.CreateConstGEP1_32(ctx->signalPage, -1),\n                           true);\n        builder.CreateBr(contBB);\n        ctx->f->getBasicBlockList().push_back(contBB);\n        builder.SetInsertPoint(contBB);\n        return ghostValue(jl_void_type);\n    }\n    if (fptr == (void(*)(void))&jl_is_leaf_type ||\n        ((f_lib==NULL || (intptr_t)f_lib==2)\n         && f_name && !strcmp(f_name, \"jl_is_leaf_type\"))) {\n        assert(nargt == 1);\n        jl_value_t *arg = args[4];\n        jl_value_t *ty = expr_type(arg, ctx);\n        if (jl_is_type_type(ty) && !jl_is_typevar(jl_tparam0(ty))) {\n            int isleaf = jl_is_leaf_type(jl_tparam0(ty));\n            JL_GC_POP();\n            return mark_or_box_ccall_result(ConstantInt::get(T_int32, isleaf),\n                    false, args[2], rt, static_rt, ctx);\n        }\n    }\n    if (fptr == (void(*)(void))&jl_function_ptr ||\n        ((f_lib==NULL || (intptr_t)f_lib==2)\n         && f_name && !strcmp(f_name, \"jl_function_ptr\"))) {\n        assert(nargt == 3);\n        jl_value_t *f = static_eval(args[4], ctx, false, false);\n        jl_value_t *frt = expr_type(args[6], ctx);\n        if (f && (jl_is_type_type((jl_value_t*)frt) && !jl_has_typevars(jl_tparam0(frt)))) {\n            jl_value_t *fargt = static_eval(args[8], ctx, true, true);\n            if (fargt) {\n                if (jl_is_tuple(fargt)) {\n                    // TODO: maybe deprecation warning, better checking\n                    fargt = (jl_value_t*)jl_apply_tuple_type_v((jl_value_t**)jl_data_ptr(fargt), jl_nfields(fargt));\n                }\n            }\n            else {\n                fargt = expr_type(args[8], ctx);\n                if (jl_is_type_type((jl_value_t*)fargt))\n                    fargt = jl_tparam0(fargt);\n            }\n            if (jl_is_tuple_type(fargt) && jl_is_leaf_type(fargt)) {\n                frt = jl_tparam0(frt);\n                Value *llvmf = NULL;\n                JL_TRY {\n                    llvmf = jl_cfunction_object((jl_function_t*)f, frt, (jl_tupletype_t*)fargt);\n                }\n                JL_CATCH {\n                    llvmf = NULL;\n                }\n                if (llvmf) {\n                    llvmf = prepare_call(llvmf);\n                    // make sure to emit any side-effects that may have been part of the original expression\n                    emit_expr(args[4], ctx);\n                    emit_expr(args[6], ctx);\n                    emit_expr(args[8], ctx);\n                    JL_GC_POP();\n                    return mark_or_box_ccall_result(emit_bitcast(llvmf, lrt),\n                                                    retboxed, args[2], rt, static_rt, ctx);\n                }\n            }\n        }\n    }\n\n    // save place before arguments, for possible insertion of temp arg\n    // area saving code.\n    Value *stacksave=NULL;\n    BasicBlock::InstListType &instList = builder.GetInsertBlock()->getInstList();\n    Instruction *savespot;\n    if (instList.empty()) {\n        savespot = NULL;\n    }\n    else {\n        // hey C++, there's this thing called pointers...\n        Instruction &_savespot = builder.GetInsertBlock()->back();\n        savespot = &_savespot;\n    }\n\n    std::vector<Type*> fargt(0);\n    std::vector<Type*> fargt_sig(0);\n    std::vector<bool> fargt_isboxed(0);\n    Type *fargt_vasig = NULL;\n    std::vector<bool> inRegList(0);\n    std::vector<bool> byRefList(0);\n    AttributeSet attrs;\n    Type *prt = NULL;\n    int sret = 0;\n    std::string err_msg = generate_func_sig(&lrt, &prt, sret, fargt, fargt_isboxed, fargt_sig, fargt_vasig,\n                                            inRegList, byRefList, attrs, rt, tt, (nargs - 3)/2);\n    if (!err_msg.empty()) {\n        JL_GC_POP();\n        emit_error(err_msg,ctx);\n        return jl_cgval_t();\n    }\n\n    // emit arguments\n    Value **argvals = (Value**) alloca(((nargs - 3) / 2 + sret) * sizeof(Value*));\n    Value *result = NULL;\n    bool needStackRestore = false;\n\n    // First, if the ABI requires us to provide the space for the return\n    // argument, allocate the box and store that as the first argument type\n    bool sretboxed = false;\n    if (sret) {\n        jl_cgval_t sret_val = emit_new_struct(rt,1,NULL,ctx); // TODO: is it valid to be creating an incomplete type this way?\n        assert(sret_val.typ != NULL && \"Type was not concrete\");\n        if (!sret_val.ispointer()) {\n            Value *mem = emit_static_alloca(lrt, ctx);\n            builder.CreateStore(sret_val.V, mem);\n            result = mem;\n        }\n        else {\n            // XXX: result needs a GC root here if result->getType() == T_pjlvalue\n            result = sret_val.V;\n        }\n        argvals[0] = emit_bitcast(result, fargt_sig.at(0));\n        sretboxed = sret_val.isboxed;\n    }\n\n    // number of parameters to the c function\n    jl_cgval_t *argv = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * (nargs - 3)/2);\n    for(i = 4; i < nargs + 1; i += 2) {\n        // Current C function parameter\n        size_t ai = (i - 4) / 2;\n\n        // Julia (expression) value of current parameter\n        jl_value_t *argi = args[i];\n\n        // pass the address of the argument rather than the argument itself\n        bool addressOf = false;\n        if (jl_is_expr(argi) && ((jl_expr_t*)argi)->head == amp_sym) {\n            addressOf = true;\n            argi = jl_exprarg(argi,0);\n        }\n\n        Type *largty; // LLVM type of the current parameter\n        bool toboxed;\n        jl_value_t *jargty; // Julia type of the current parameter\n        bool byRef, inReg; // Argument attributes\n        if (isVa && ai >= nargt - 1) {\n            largty = fargt.at(nargt - 1);\n            toboxed = fargt_isboxed.at(nargt - 1);\n            jargty = jl_tparam0(jl_svecref(tt, nargt - 1));\n            byRef = byRefList.at(nargt - 1);\n            inReg = inRegList.at(nargt - 1);\n        }\n        else {\n            largty = fargt.at(ai);\n            toboxed = fargt_isboxed.at(ai);\n            jargty = jl_svecref(tt, ai);\n            byRef = byRefList.at(ai);\n            inReg = inRegList.at(ai);\n        }\n\n        jl_cgval_t &arg = argv[ai];\n        arg = emit_expr((jl_value_t*)argi, ctx);\n        if (jl_is_abstract_ref_type(jargty)) {\n            if (addressOf) {\n                JL_GC_POP();\n                emit_error(\"ccall: & on a Ref{T} argument is invalid\", ctx);\n                return jl_cgval_t();\n            }\n            if (!jl_is_cpointer_type(arg.typ)) {\n                emit_cpointercheck(arg, \"ccall: argument to Ref{T} is not a pointer\", ctx);\n                arg.typ = (jl_value_t*)jl_voidpointer_type;\n                arg.isboxed = false;\n            }\n            jargty = (jl_value_t*)jl_voidpointer_type;\n        }\n\n        Value *v = julia_to_native(largty, toboxed, jargty, arg, addressOf, byRef, inReg,\n                    need_private_copy(jargty, byRef), false, ai + 1, ctx, &needStackRestore);\n        bool issigned = jl_signed_type && jl_subtype(jargty, (jl_value_t*)jl_signed_type, 0);\n        argvals[ai + sret] = llvm_type_rewrite(v, largty,\n                ai + sret < fargt_sig.size() ? fargt_sig.at(ai + sret) : fargt_vasig,\n                false, byRef, issigned, ctx);\n    }\n\n\n    // make LLVM function object for the target\n    // keep this close to the function call, so that the compiler can\n    // optimize the global pointer load in the common case\n    Value *llvmf;\n    FunctionType *functype = FunctionType::get(sret ? T_void : prt, fargt_sig, isVa);\n\n    if (jl_ptr != NULL) {\n        null_pointer_check(jl_ptr,ctx);\n        Type *funcptype = PointerType::get(functype,0);\n        llvmf = builder.CreateIntToPtr(jl_ptr, funcptype);\n    }\n    else if (fptr != NULL) {\n        Type *funcptype = PointerType::get(functype,0);\n        llvmf = literal_static_pointer_val((void*)(uintptr_t)fptr, funcptype);\n        if (imaging_mode)\n            jl_printf(JL_STDERR,\"WARNING: literal address used in ccall for %s; code cannot be statically compiled\\n\", f_name);\n    }\n    else {\n        assert(f_name != NULL);\n\n        PointerType *funcptype = PointerType::get(functype,0);\n        if (imaging_mode) {\n            // vararg requires musttail,\n            // but musttail is incompatible with noreturn.\n            if (functype->isVarArg())\n                llvmf = runtime_sym_lookup(funcptype, f_lib, f_name, ctx->f);\n            else\n                llvmf = emit_plt(functype, attrs, cc, f_lib, f_name);\n        }\n        else {\n            void *symaddr = jl_dlsym_e(jl_get_library(f_lib), f_name);\n            if (symaddr == NULL) {\n                JL_GC_POP();\n                std::stringstream msg;\n                msg << \"ccall: could not find function \";\n                msg << f_name;\n                if (f_lib != NULL) {\n#ifdef _OS_WINDOWS_\n                    assert((intptr_t)f_lib != 1 && (intptr_t)f_lib != 2);\n#endif\n                    msg << \" in library \";\n                    msg << f_lib;\n                }\n                emit_error(msg.str(), ctx);\n                return jl_cgval_t();\n            }\n            // since we aren't saving this code, there's no sense in\n            // putting anything complicated here: just JIT the function address\n            llvmf = literal_static_pointer_val(symaddr, funcptype);\n        }\n    }\n\n    if (needStackRestore) {\n        stacksave = CallInst::Create(Intrinsic::getDeclaration(jl_Module,\n                                                               Intrinsic::stacksave));\n        if (savespot) {\n#ifdef LLVM38\n                instList.insertAfter(savespot->getIterator(), (Instruction*)stacksave);\n#else\n                instList.insertAfter((Instruction*)savespot, (Instruction*)stacksave);\n#endif\n        }\n        else\n            instList.push_front((Instruction*)stacksave);\n    }\n\n    //llvmf->dump();\n    //for (int i = 0; i < (nargs - 3) / 2 + sret; ++i)\n    //    argvals[i]->dump();\n\n    // Mark GC use before **and** after the ccall to make sure the arguments\n    // are alive during the ccall even if the function called is `noreturn`.\n    SmallVector<Value*, 16> gc_uses;\n    for(i = 4; i < nargs + 1; i += 2) {\n        // Current C function parameter\n        size_t ai = (i - 4) / 2;\n        push_gc_use(gc_uses, argv[ai]);\n\n        // Julia (expression) value of current parameter gcroot\n        jl_value_t *argi = args[i + 1];\n        if (jl_is_long(argi)) continue;\n        jl_cgval_t arg = emit_expr(argi, ctx);\n        push_gc_use(gc_uses, arg);\n    }\n    mark_gc_uses(gc_uses);\n    // the actual call\n    Value *ret = builder.CreateCall(prepare_call(llvmf),\n                                    ArrayRef<Value*>(&argvals[0], (nargs - 3) / 2 + sret));\n    ((CallInst*)ret)->setAttributes(attrs);\n\n    if (cc != CallingConv::C)\n        ((CallInst*)ret)->setCallingConv(cc);\n    if (!sret)\n        result = ret;\n    if (needStackRestore) {\n        assert(stacksave != NULL);\n        builder.CreateCall(Intrinsic::getDeclaration(jl_Module, Intrinsic::stackrestore), stacksave);\n    }\n    if (0) { // Enable this to turn on SSPREQ (-fstack-protector) on the function containing this ccall\n        ctx->f->addFnAttr(Attribute::StackProtectReq);\n    }\n\n    mark_gc_uses(gc_uses);\n    JL_GC_POP();\n    if (rt == jl_bottom_type) {\n        // Do this after we marked all the GC uses.\n        CreateTrap(builder);\n    }\n    // Finally we need to box the result into julia type\n    // However, if we have already created a box for the return\n    // type because the ABI required us to pass a pointer (sret),\n    // then we do not need to do this.\n    if (!sret) {\n        Type *jlrt = julia_type_to_llvm(rt, &retboxed); // compute the real \"julian\" return type and update retboxed\n        if (type_is_ghost(jlrt)) {\n            return ghostValue(rt);\n        }\n        else if (lrt->isStructTy() && retboxed) {\n            assert(jl_is_structtype(rt));\n            jl_cgval_t newst = emit_new_struct(rt, 1, NULL, ctx); // emit a new, empty struct\n            assert(newst.typ != NULL && \"Type was not concrete\");\n            assert(newst.isboxed);\n            size_t rtsz = jl_datatype_size(rt);\n            assert(rtsz > 0);\n            int boxalign = jl_gc_alignment(rtsz);\n#ifndef NDEBUG\n#ifdef LLVM36\n            const DataLayout &DL = jl_ExecutionEngine->getDataLayout();\n#else\n            const DataLayout &DL = *jl_ExecutionEngine->getDataLayout();\n#endif\n            // ARM and AArch64 can use a LLVM type larger than the julia\n            // type. However, the LLVM type size should be no larger than\n            // the GC allocation size. (multiple of `sizeof(void*)`)\n            assert(DL.getTypeStoreSize(lrt) <= LLT_ALIGN(jl_datatype_size(rt),\n                                                         boxalign));\n#endif\n            // copy the data from the return value to the new struct\n            tbaa_decorate(newst.tbaa, builder.CreateAlignedStore(result, emit_bitcast(newst.V, prt->getPointerTo()), boxalign));\n            return newst;\n        }\n        else if (jlrt != prt) {\n            assert(lrt == jlrt); // jl_struct_to_llvm and julia_type_to_llvm should only differ for concrete types, per the case above\n            result = llvm_type_rewrite(result, prt, jlrt, true, false, false, ctx);\n        }\n    }\n    else {\n        retboxed = sretboxed;\n        if (!retboxed)\n            result = builder.CreateLoad(result); // something alloca'd above\n    }\n\n    return mark_or_box_ccall_result(result, retboxed, args[2], rt, static_rt, ctx);\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/searchindex.js": "Search.setIndex({envversion:49,filenames:[\"devdocs/C\",\"devdocs/ast\",\"devdocs/backtraces\",\"devdocs/boundscheck\",\"devdocs/callconv\",\"devdocs/cartesian\",\"devdocs/debuggingtips\",\"devdocs/eval\",\"devdocs/functions\",\"devdocs/init\",\"devdocs/julia\",\"devdocs/llvm\",\"devdocs/locks\",\"devdocs/meta\",\"devdocs/object\",\"devdocs/offset-arrays\",\"devdocs/reflection\",\"devdocs/sanitizers\",\"devdocs/stdio\",\"devdocs/subarrays\",\"devdocs/sysimg\",\"devdocs/types\",\"devdocs/valgrind\",\"index\",\"latex\",\"manual/arrays\",\"manual/calling-c-and-fortran-code\",\"manual/complex-and-rational-numbers\",\"manual/constructors\",\"manual/control-flow\",\"manual/conversion-and-promotion\",\"manual/dates\",\"manual/documentation\",\"manual/embedding\",\"manual/faq\",\"manual/functions\",\"manual/getting-started\",\"manual/handling-operating-system-variation\",\"manual/index\",\"manual/integers-and-floating-point-numbers\",\"manual/interacting-with-julia\",\"manual/interfaces\",\"manual/introduction\",\"manual/linear-algebra\",\"manual/mathematical-operations\",\"manual/metaprogramming\",\"manual/methods\",\"manual/modules\",\"manual/networking-and-streams\",\"manual/noteworthy-differences\",\"manual/packages\",\"manual/parallel-computing\",\"manual/performance-tips\",\"manual/profile\",\"manual/running-external-programs\",\"manual/stacktraces\",\"manual/strings\",\"manual/style-guide\",\"manual/types\",\"manual/unicode-input\",\"manual/variables\",\"manual/variables-and-scoping\",\"manual/workflow-tips\",\"stdlib/arrays\",\"stdlib/base\",\"stdlib/c\",\"stdlib/collections\",\"stdlib/constants\",\"stdlib/dates\",\"stdlib/file\",\"stdlib/index\",\"stdlib/io-network\",\"stdlib/libc\",\"stdlib/libdl\",\"stdlib/linalg\",\"stdlib/math\",\"stdlib/numbers\",\"stdlib/parallel\",\"stdlib/pkg\",\"stdlib/profile\",\"stdlib/punctuation\",\"stdlib/simd-types\",\"stdlib/sort\",\"stdlib/stacktraces\",\"stdlib/strings\",\"stdlib/test\"],objects:{\"\":{\"@__doc__\":[32,4,1,\"\"],Dates:[68,6,0,\"-\"],Libc:[72,6,0,\"-\"],Libdl:[73,6,0,\"-\"],Profile:[79,6,0,\"-\"],StackTraces:[83,6,0,\"-\"],build_sysimg:[20,4,1,\"\"]},\"Base.\":{\"!=\":[75,4,1,\"\"],\"&gt;\":[75,4,1,\"Base..>\"],\"&gt;=\":[75,4,1,\"Base..>=\"],\"&lt;\":[75,4,1,\"Base..<\"],\"&lt;=\":[75,4,1,\"Base..<=\"],\"*\":[75,4,1,\"\"],\"+\":[75,4,1,\"\"],\"-\":[75,4,1,\"\"],\"/\":[75,4,1,\"\"],\"==\":[75,4,1,\"\"],\"\\\\\":[75,4,1,\"\"],\"\\u2260\":[75,4,1,\"\"],\"\\u2264\":[75,4,1,\"\"],\"\\u2265\":[75,4,1,\"\"],\"^\":[75,4,1,\"\"]},\"Base.Base\":{OneTo:[75,4,1,\"\"],channel_from_id:[77,4,1,\"\"],checked_abs:[75,4,1,\"\"],checked_add:[75,4,1,\"\"],checked_cld:[75,4,1,\"\"],checked_div:[75,4,1,\"\"],checked_fld:[75,4,1,\"\"],checked_mod:[75,4,1,\"\"],checked_mul:[75,4,1,\"\"],checked_neg:[75,4,1,\"\"],checked_rem:[75,4,1,\"\"],checked_sub:[75,4,1,\"\"],cluster_cookie:[77,4,1,\"\"],compilecache:[64,4,1,\"\"],datatype_module:[64,4,1,\"\"],function_module:[64,4,1,\"\"],function_name:[64,4,1,\"\"],linearindexing:[63,4,1,\"\"],process_messages:[77,4,1,\"\"],remoteref_id:[77,4,1,\"\"],summarysize:[64,4,1,\"\"],worker_id_from_socket:[77,4,1,\"\"]},\"Base.Collections\":{\"dequeue!\":[66,4,1,\"\"],\"enqueue!\":[66,4,1,\"\"],\"heapify!\":[66,4,1,\"\"],\"heappop!\":[66,4,1,\"\"],\"heappush!\":[66,4,1,\"\"],PriorityQueue:[66,4,1,\"\"],heapify:[66,4,1,\"\"],isheap:[66,4,1,\"\"],peek:[66,4,1,\"\"]},\"Base.FFTW\":{\"plan_r2r!\":[75,4,1,\"\"],\"r2r!\":[75,4,1,\"\"],plan_r2r:[75,4,1,\"\"],r2r:[75,4,1,\"\"]},\"Base.Libc\":{FormatMessage:[72,4,1,\"\"],GetLastError:[72,4,1,\"\"],TmStruct:[72,4,1,\"\"],calloc:[72,4,1,\"\"],errno:[72,4,1,\"\"],flush_cstdio:[72,4,1,\"\"],free:[72,4,1,\"\"],malloc:[72,4,1,\"\"],realloc:[72,4,1,\"\"],strerror:[72,4,1,\"\"],strftime:[72,4,1,\"\"],strptime:[72,4,1,\"\"],time:[72,4,1,\"\"]},\"Base.Libdl\":{DL_LOAD_PATH:[73,5,1,\"\"],RTLD_DEEPBIND:[73,5,1,\"\"],RTLD_FIRST:[73,5,1,\"\"],RTLD_GLOBAL:[73,5,1,\"\"],RTLD_LAZY:[73,5,1,\"\"],RTLD_LOCAL:[73,5,1,\"\"],RTLD_NODELETE:[73,5,1,\"\"],RTLD_NOLOAD:[73,5,1,\"\"],RTLD_NOW:[73,5,1,\"\"],dlclose:[73,4,1,\"\"],dlext:[73,5,1,\"\"],dlopen:[73,4,1,\"\"],dlopen_e:[73,4,1,\"\"],dlsym:[73,4,1,\"\"],dlsym_e:[73,4,1,\"\"],find_library:[73,4,1,\"\"]},\"Base.LinAlg\":{\"lowrankdowndate!\":[74,4,1,\"\"],\"lowrankupdate!\":[74,4,1,\"\"],\"qr!\":[74,4,1,\"\"],BLAS:[74,6,0,\"-\"],Givens:[74,4,1,\"\"],LAPACK:[74,6,0,\"-\"],checksquare:[63,4,1,\"\"],lowrankdowndate:[74,4,1,\"\"],lowrankupdate:[74,4,1,\"\"]},\"Base.LinAlg.BLAS\":{\"axpy!\":[74,4,1,\"\"],\"blascopy!\":[74,4,1,\"\"],\"gbmv!\":[74,4,1,\"\"],\"gemm!\":[74,4,1,\"\"],\"gemv!\":[74,4,1,\"\"],\"ger!\":[74,4,1,\"\"],\"her!\":[74,4,1,\"\"],\"herk!\":[74,4,1,\"\"],\"sbmv!\":[74,4,1,\"\"],\"scal!\":[74,4,1,\"\"],\"symm!\":[74,4,1,\"\"],\"symv!\":[74,4,1,\"\"],\"syr!\":[74,4,1,\"\"],\"syrk!\":[74,4,1,\"\"],\"trmm!\":[74,4,1,\"\"],\"trmv!\":[74,4,1,\"\"],\"trsm!\":[74,4,1,\"\"],\"trsv!\":[74,4,1,\"\"],I:[74,5,1,\"\"],asum:[74,4,1,\"\"],dot:[74,4,1,\"\"],dotc:[74,4,1,\"\"],dotu:[74,4,1,\"\"],gbmv:[74,4,1,\"\"],gemm:[74,4,1,\"\"],gemv:[74,4,1,\"\"],herk:[74,4,1,\"\"],nrm2:[74,4,1,\"\"],sbmv:[74,4,1,\"\"],scal:[74,4,1,\"\"],set_num_threads:[74,4,1,\"\"],symm:[74,4,1,\"\"],symv:[74,4,1,\"\"],syrk:[74,4,1,\"\"],trmm:[74,4,1,\"\"],trmv:[74,4,1,\"\"],trsm:[74,4,1,\"\"],trsv:[74,4,1,\"\"]},\"Base.LinAlg.LAPACK\":{\"bdsdc!\":[74,4,1,\"\"],\"bdsqr!\":[74,4,1,\"\"],\"gbtrf!\":[74,4,1,\"\"],\"gbtrs!\":[74,4,1,\"\"],\"gebak!\":[74,4,1,\"\"],\"gebal!\":[74,4,1,\"\"],\"gebrd!\":[74,4,1,\"\"],\"gecon!\":[74,4,1,\"\"],\"gees!\":[74,4,1,\"\"],\"geev!\":[74,4,1,\"\"],\"geevx!\":[74,4,1,\"\"],\"gehrd!\":[74,4,1,\"\"],\"gelqf!\":[74,4,1,\"\"],\"gels!\":[74,4,1,\"\"],\"gelsd!\":[74,4,1,\"\"],\"gelsy!\":[74,4,1,\"\"],\"gemqrt!\":[74,4,1,\"\"],\"geqlf!\":[74,4,1,\"\"],\"geqp3!\":[74,4,1,\"\"],\"geqrf!\":[74,4,1,\"\"],\"geqrt!\":[74,4,1,\"\"],\"geqrt3!\":[74,4,1,\"\"],\"gerqf!\":[74,4,1,\"\"],\"gesdd!\":[74,4,1,\"\"],\"gesv!\":[74,4,1,\"\"],\"gesvd!\":[74,4,1,\"\"],\"gesvx!\":[74,4,1,\"\"],\"getrf!\":[74,4,1,\"\"],\"getri!\":[74,4,1,\"\"],\"getrs!\":[74,4,1,\"\"],\"gges!\":[74,4,1,\"\"],\"ggev!\":[74,4,1,\"\"],\"gglse!\":[74,4,1,\"\"],\"ggsvd!\":[74,4,1,\"\"],\"ggsvd3!\":[74,4,1,\"\"],\"gtsv!\":[74,4,1,\"\"],\"gttrf!\":[74,4,1,\"\"],\"gttrs!\":[74,4,1,\"\"],\"hesv!\":[74,4,1,\"\"],\"hetrf!\":[74,4,1,\"\"],\"hetri!\":[74,4,1,\"\"],\"hetrs!\":[74,4,1,\"\"],\"orghr!\":[74,4,1,\"\"],\"orglq!\":[74,4,1,\"\"],\"orgql!\":[74,4,1,\"\"],\"orgqr!\":[74,4,1,\"\"],\"orgrq!\":[74,4,1,\"\"],\"ormlq!\":[74,4,1,\"\"],\"ormql!\":[74,4,1,\"\"],\"ormqr!\":[74,4,1,\"\"],\"ormrq!\":[74,4,1,\"\"],\"ormrz!\":[74,4,1,\"\"],\"posv!\":[74,4,1,\"\"],\"potrf!\":[74,4,1,\"\"],\"potri!\":[74,4,1,\"\"],\"potrs!\":[74,4,1,\"\"],\"pstrf!\":[74,4,1,\"\"],\"ptsv!\":[74,4,1,\"\"],\"pttrf!\":[74,4,1,\"\"],\"pttrs!\":[74,4,1,\"\"],\"stebz!\":[74,4,1,\"\"],\"stegr!\":[74,4,1,\"\"],\"stein!\":[74,4,1,\"\"],\"stev!\":[74,4,1,\"\"],\"syconv!\":[74,4,1,\"\"],\"syev!\":[74,4,1,\"\"],\"syevr!\":[74,4,1,\"\"],\"sygvd!\":[74,4,1,\"\"],\"sysv!\":[74,4,1,\"\"],\"sytrf!\":[74,4,1,\"\"],\"sytri!\":[74,4,1,\"\"],\"sytrs!\":[74,4,1,\"\"],\"tgsen!\":[74,4,1,\"\"],\"trcon!\":[74,4,1,\"\"],\"trevc!\":[74,4,1,\"\"],\"trexc!\":[74,4,1,\"\"],\"trrfs!\":[74,4,1,\"\"],\"trsen!\":[74,4,1,\"\"],\"trsyl!\":[74,4,1,\"\"],\"trtri!\":[74,4,1,\"\"],\"trtrs!\":[74,4,1,\"\"],\"tzrzf!\":[74,4,1,\"\"]},\"Base.Mmap\":{\"sync!\":[71,4,1,\"\"],Anonymous:[71,4,1,\"\"],mmap:[71,4,1,\"\"]},\"Base.Pkg\":{\"setprotocol!\":[78,4,1,\"\"],add:[78,4,1,\"\"],available:[78,4,1,\"\"],build:[78,4,1,\"\"],checkout:[78,4,1,\"\"],clone:[78,4,1,\"\"],dependents:[78,4,1,\"\"],dir:[78,4,1,\"\"],edit:[78,4,1,\"\"],free:[78,4,1,\"\"],init:[78,4,1,\"\"],installed:[78,4,1,\"\"],pin:[78,4,1,\"\"],resolve:[78,4,1,\"\"],rm:[78,4,1,\"\"],status:[78,4,1,\"\"],test:[78,4,1,\"\"],update:[78,4,1,\"\"]},\"Base.Profile\":{callers:[79,4,1,\"\"],clear:[79,4,1,\"\"],clear_malloc_data:[79,4,1,\"\"],fetch:[79,4,1,\"\"],init:[79,4,1,\"\"],print:[79,4,1,\"\"],retrieve:[79,4,1,\"\"]},\"Base.StackTraces\":{\"remove_frames!\":[83,4,1,\"\"],lookup:[83,4,1,\"\"]},\"Base.Sys\":{ARCH:[67,5,1,\"\"],CPU_CORES:[67,5,1,\"\"],KERNEL:[67,5,1,\"\"],MACHINE:[67,5,1,\"\"],WORD_SIZE:[67,5,1,\"\"],get_process_title:[64,4,1,\"\"],set_process_title:[64,4,1,\"\"]},\"Base.Test\":{\"@test_approx_eq\":[85,4,1,\"\"],\"@test_approx_eq_eps\":[85,4,1,\"\"],finish:[85,4,1,\"\"],get_testset:[85,4,1,\"\"],get_testset_depth:[85,4,1,\"\"],record:[85,4,1,\"\"]},\"Base.Threads\":{\"@threads\":[77,4,1,\"\"],\"Atomic{T}\":[77,4,1,\"\"],\"atomic_add!{T}\":[77,4,1,\"\"],\"atomic_and!{T}\":[77,4,1,\"\"],\"atomic_cas!{T}\":[77,4,1,\"\"],\"atomic_max!{T}\":[77,4,1,\"\"],\"atomic_min!{T}\":[77,4,1,\"\"],\"atomic_nand!{T}\":[77,4,1,\"\"],\"atomic_or!{T}\":[77,4,1,\"\"],\"atomic_sub!{T}\":[77,4,1,\"\"],\"atomic_xchg!{T}\":[77,4,1,\"\"],\"atomic_xor!{T}\":[77,4,1,\"\"],atomic_fence:[77,4,1,\"\"],nthreads:[77,4,1,\"\"],threadid:[77,4,1,\"\"]},Base:{\"!\":[75,4,1,\"\"],\"!=\":[75,4,1,\"\"],\"!==\":[75,4,1,\"\"],\"$\":[75,4,1,\"\"],\"%\":[75,4,1,\"\"],\"&amp;\":[75,4,1,\"Base.&\"],\"&gt;\":[75,4,1,\"Base.>\"],\"&gt;&gt;\":[75,4,1,\"Base.>>\"],\"&gt;&gt;&gt;\":[75,4,1,\"Base.>>>\"],\"&gt;=\":[75,4,1,\"Base.>=\"],\"&lt;\":[75,4,1,\"Base.<\"],\"&lt;&lt;\":[75,4,1,\"Base.<<\"],\"&lt;:\":[64,4,1,\"Base.<:\"],\"&lt;=\":[75,4,1,\"Base.<=\"],\"*\":[84,4,1,\"\"],\"+\":[75,4,1,\"\"],\"-\":[75,4,1,\"\"],\"/\":[75,4,1,\"\"],\"//\":[75,4,1,\"\"],\":\":[75,4,1,\"\"],\"==\":[75,4,1,\"\"],\"===\":[75,4,1,\"\"],\"@__FILE__\":[69,4,1,\"\"],\"@__LINE__\":[69,4,1,\"\"],\"@allocated\":[64,4,1,\"\"],\"@async\":[77,4,1,\"\"],\"@code_llvm\":[64,4,1,\"\"],\"@code_lowered\":[64,4,1,\"\"],\"@code_native\":[64,4,1,\"\"],\"@code_typed\":[64,4,1,\"\"],\"@code_warntype\":[64,4,1,\"\"],\"@edit\":[64,4,1,\"\"],\"@elapsed\":[64,4,1,\"\"],\"@eval\":[64,4,1,\"\"],\"@evalpoly\":[75,4,1,\"\"],\"@fetch\":[77,4,1,\"\"],\"@fetchfrom\":[77,4,1,\"\"],\"@functionloc\":[64,4,1,\"\"],\"@gensym\":[64,4,1,\"\"],\"@html_str\":[84,4,1,\"\"],\"@less\":[64,4,1,\"\"],\"@parallel\":[77,4,1,\"\"],\"@printf\":[71,4,1,\"\"],\"@profile\":[79,4,1,\"\"],\"@r_str\":[84,4,1,\"\"],\"@schedule\":[77,4,1,\"\"],\"@show\":[64,4,1,\"\"],\"@spawn\":[77,4,1,\"\"],\"@spawnat\":[77,4,1,\"\"],\"@sprintf\":[71,4,1,\"\"],\"@static\":[64,4,1,\"\"],\"@sync\":[77,4,1,\"\"],\"@task\":[77,4,1,\"\"],\"@text_str\":[84,4,1,\"\"],\"@threadcall\":[77,4,1,\"\"],\"@time\":[64,4,1,\"\"],\"@timed\":[64,4,1,\"\"],\"@timev\":[64,4,1,\"\"],\"@which\":[64,4,1,\"\"],\"A_ldiv_B!\":[74,4,1,\"\"],\"A_mul_B!\":[74,4,1,\"\"],\"Ac_ldiv_B!\":[74,4,1,\"\"],\"At_ldiv_B!\":[74,4,1,\"\"],\"Channel{T}\":[77,4,1,\"\"],\"Ptr{T}\":[65,5,1,\"\"],\"Ref{T}\":[65,5,1,\"\"],\"Val{c}\":[64,4,1,\"\"],\"\\\\\":[75,4,1,\"\"],\"\\u00d7\":[74,4,1,\"\"],\"\\u00f7\":[75,4,1,\"\"],\"\\u03b3\":[76,5,1,\"\"],\"\\u03c0\":[76,5,1,\"\"],\"\\u03c6\":[76,5,1,\"\"],\"\\u2208\":[66,4,1,\"\"],\"\\u2209\":[66,4,1,\"\"],\"\\u220b\":[66,4,1,\"\"],\"\\u220c\":[66,4,1,\"\"],\"\\u2229\":[66,4,1,\"\"],\"\\u222a\":[66,4,1,\"\"],\"\\u2260\":[75,4,1,\"\"],\"\\u2261\":[75,4,1,\"\"],\"\\u2262\":[75,4,1,\"\"],\"\\u2264\":[75,4,1,\"\"],\"\\u2265\":[75,4,1,\"\"],\"\\u2286\":[66,4,1,\"\"],\"\\u2288\":[66,4,1,\"\"],\"\\u228a\":[66,4,1,\"\"],\"\\u22c5\":[74,4,1,\"\"],\"^\":[84,4,1,\"\"],\"all!\":[66,4,1,\"\"],\"any!\":[66,4,1,\"\"],\"append!\":[66,4,1,\"\"],\"bfft!\":[75,4,1,\"\"],\"bkfact!\":[74,4,1,\"\"],\"broadcast!\":[63,4,1,\"\"],\"broadcast_setindex!\":[63,4,1,\"\"],\"cholfact!\":[74,4,1,\"\"],\"clamp!\":[75,4,1,\"\"],\"clear!\":[77,4,1,\"\"],\"conj!\":[63,4,1,\"\"],\"copy!\":[65,4,1,\"\"],\"ctranspose!\":[74,4,1,\"\"],\"cumprod!\":[63,4,1,\"\"],\"cumsum!\":[63,4,1,\"\"],\"dct!\":[75,4,1,\"\"],\"delete!\":[66,4,1,\"\"],\"deleteat!\":[66,4,1,\"\"],\"digits!\":[76,4,1,\"\"],\"dropzeros!\":[63,4,1,\"\"],\"eigfact!\":[74,4,1,\"\"],\"eigvals!\":[74,4,1,\"\"],\"empty!\":[66,4,1,\"\"],\"fft!\":[75,4,1,\"\"],\"fill!\":[63,4,1,\"\"],\"filt!\":[75,4,1,\"\"],\"filter!\":[66,4,1,\"\"],\"findmax!\":[66,4,1,\"\"],\"findmin!\":[66,4,1,\"\"],\"flipbits!\":[63,4,1,\"\"],\"float\":[76,4,1,\"\"],\"get!\":[66,4,1,\"\"],\"givens{T}\":[74,4,1,\"\"],\"hessfact!\":[74,4,1,\"\"],\"idct!\":[75,4,1,\"\"],\"ifft!\":[75,4,1,\"\"],\"in\":[66,4,1,\"\"],\"insert!\":[66,4,1,\"\"],\"intersect!\":[66,4,1,\"\"],\"ipermute!\":[63,4,1,\"\"],\"isposdef!\":[74,4,1,\"\"],\"ldltfact!\":[74,4,1,\"\"],\"lqfact!\":[74,4,1,\"\"],\"lufact!\":[74,4,1,\"\"],\"map!\":[66,4,1,\"\"],\"maxabs!\":[66,4,1,\"\"],\"maximum!\":[66,4,1,\"\"],\"mean!\":[75,4,1,\"\"],\"median!\":[75,4,1,\"\"],\"merge!\":[66,4,1,\"\"],\"minabs!\":[66,4,1,\"\"],\"minimum!\":[66,4,1,\"\"],\"normalize!\":[74,4,1,\"\"],\"ordschur!\":[74,4,1,\"\"],\"permute!\":[63,4,1,\"\"],\"permutedims!\":[63,4,1,\"\"],\"plan_bfft!\":[75,4,1,\"\"],\"plan_dct!\":[75,4,1,\"\"],\"plan_fft!\":[75,4,1,\"\"],\"plan_idct!\":[75,4,1,\"\"],\"plan_ifft!\":[75,4,1,\"\"],\"pop!\":[66,4,1,\"\"],\"prepend!\":[66,4,1,\"\"],\"prod!\":[66,4,1,\"\"],\"push!\":[66,4,1,\"\"],\"put!\":[77,4,1,\"\"],\"q::AbstractVector{Tq})\":[63,4,1,\"\"],\"qrfact!\":[74,4,1,\"\"],\"quantile!\":[75,4,1,\"\"],\"rand!\":[76,4,1,\"\"],\"randexp!\":[76,4,1,\"\"],\"randn!\":[76,4,1,\"\"],\"randsubseq!\":[63,4,1,\"\"],\"read!\":[71,4,1,\"\"],\"readbytes!\":[71,4,1,\"\"],\"resize!\":[66,4,1,\"\"],\"reverse!\":[63,4,1,\"\"],\"rol!\":[63,4,1,\"\"],\"ror!\":[63,4,1,\"\"],\"scale!\":[74,4,1,\"\"],\"schurfact!\":[74,4,1,\"\"],\"select!\":[82,4,1,\"\"],\"selectperm!\":[82,4,1,\"\"],\"setdiff!\":[66,4,1,\"\"],\"setfield!\":[64,4,1,\"\"],\"setindex!\":[66,4,1,\"\"],\"shift!\":[66,4,1,\"\"],\"shuffle!\":[63,4,1,\"\"],\"sizehint!\":[66,4,1,\"\"],\"sort!\":[82,4,1,\"\"],\"sortperm!\":[82,4,1,\"\"],\"splice!\":[66,4,1,\"\"],\"sum!\":[66,4,1,\"\"],\"sumabs!\":[66,4,1,\"\"],\"sumabs2!\":[66,4,1,\"\"],\"svdfact!\":[74,4,1,\"\"],\"svdvals!\":[74,4,1,\"\"],\"symdiff!\":[66,4,1,\"\"],\"take!\":[77,4,1,\"\"],\"throw\":[64,4,1,\"\"],\"transpose!\":[74,4,1,\"\"],\"tril!\":[74,4,1,\"\"],\"triu!\":[74,4,1,\"\"],\"typeof\":[64,4,1,\"\"],\"union!\":[66,4,1,\"\"],\"unsafe_copy!\":[65,4,1,\"\"],\"unsafe_store!\":[65,4,1,\"\"],\"unshift!\":[66,4,1,\"\"],\"var\":[75,4,1,\"\"],\"|\":[75,4,1,\"\"],\"|&gt;\":[64,4,1,\"Base.|>\"],\"~\":[75,4,1,\"\"],ANY:[67,5,1,\"\"],ARGS:[67,5,1,\"\"],A_ldiv_Bc:[74,4,1,\"\"],A_ldiv_Bt:[74,4,1,\"\"],A_mul_Bc:[74,4,1,\"\"],A_mul_Bt:[74,4,1,\"\"],A_rdiv_Bc:[74,4,1,\"\"],A_rdiv_Bt:[74,4,1,\"\"],AbstractLock:[77,5,1,\"\"],Ac_ldiv_B:[74,4,1,\"\"],Ac_ldiv_Bc:[74,4,1,\"\"],Ac_mul_B:[74,4,1,\"\"],Ac_mul_Bc:[74,4,1,\"\"],Ac_rdiv_B:[74,4,1,\"\"],Ac_rdiv_Bc:[74,4,1,\"\"],ArgumentError:[64,4,1,\"\"],Array:[63,4,1,\"\"],AssertionError:[64,4,1,\"\"],AsyncCondition:[64,4,1,\"\"],At_ldiv_B:[74,4,1,\"\"],At_ldiv_Bt:[74,4,1,\"\"],At_mul_B:[74,4,1,\"\"],At_mul_Bt:[74,4,1,\"\"],At_rdiv_B:[74,4,1,\"\"],At_rdiv_Bt:[74,4,1,\"\"],Base64DecodePipe:[71,4,1,\"\"],Base64EncodePipe:[71,4,1,\"\"],Bidiagonal:[74,4,1,\"\"],BigFloat:[76,4,1,\"\"],BigInt:[76,4,1,\"\"],BoundsError:[64,4,1,\"\"],C_NULL:[67,5,1,\"\"],CachingPool:[77,4,1,\"\"],Cartesian:[5,6,0,\"-\"],Cchar:[65,5,1,\"\"],Cdouble:[65,5,1,\"\"],Cfloat:[65,5,1,\"\"],Cint:[65,5,1,\"\"],Cintmax_t:[65,5,1,\"\"],Clong:[65,5,1,\"\"],Clonglong:[65,5,1,\"\"],Collections:[66,6,0,\"-\"],Condition:[77,4,1,\"\"],Cptrdiff_t:[65,5,1,\"\"],Cshort:[65,5,1,\"\"],Csize_t:[65,5,1,\"\"],Cssize_t:[65,5,1,\"\"],Cuchar:[65,5,1,\"\"],Cuint:[65,5,1,\"\"],Cuintmax_t:[65,5,1,\"\"],Culong:[65,5,1,\"\"],Culonglong:[65,5,1,\"\"],Cushort:[65,5,1,\"\"],Cwchar_t:[65,5,1,\"\"],DevNull:[64,5,1,\"\"],Diagonal:[74,4,1,\"\"],Dict:[66,4,1,\"\"],DimensionMismatch:[64,4,1,\"\"],DivideError:[64,4,1,\"\"],DomainError:[64,4,1,\"\"],ENDIAN_BOM:[71,5,1,\"\"],ENV:[64,5,1,\"\"],EOFError:[64,4,1,\"\"],EnvHash:[64,4,1,\"\"],ErrorException:[64,4,1,\"\"],Float32:[76,4,1,\"\"],Float64:[76,4,1,\"\"],Future:[77,4,1,\"\"],Hermitian:[74,4,1,\"\"],IOBuffer:[71,4,1,\"\"],IOContext:[71,7,1,\"\"],IPv4:[71,4,1,\"\"],IPv6:[71,4,1,\"\"],InexactError:[64,4,1,\"\"],Inf16:[76,5,1,\"\"],Inf32:[76,5,1,\"\"],Inf:[76,5,1,\"\"],InitError:[64,4,1,\"\"],IntSet:[66,4,1,\"\"],InterruptException:[64,4,1,\"\"],JULIA_HOME:[67,5,1,\"\"],KeyError:[64,4,1,\"\"],LOAD_PATH:[67,5,1,\"\"],LinAlg:[74,6,0,\"-\"],LoadError:[64,4,1,\"\"],MersenneTwister:[76,4,1,\"\"],MethodError:[64,4,1,\"\"],Mutex:[77,4,1,\"\"],NaN16:[76,5,1,\"\"],NaN32:[76,5,1,\"\"],NaN:[76,5,1,\"\"],NullException:[64,4,1,\"\"],Nullable:[64,4,1,\"\"],OutOfMemoryError:[64,4,1,\"\"],OverflowError:[64,4,1,\"\"],PROGRAM_FILE:[67,5,1,\"\"],ParseError:[64,4,1,\"\"],PipeBuffer:[71,4,1,\"\"],Pkg:[78,6,0,\"-\"],ProcessExitedException:[64,4,1,\"\"],RandomDevice:[76,4,1,\"\"],ReadOnlyMemoryError:[64,4,1,\"\"],RecursiveSpinLock:[77,4,1,\"\"],ReentrantLock:[77,4,1,\"\"],RemoteChannel:[77,4,1,\"\"],RemoteException:[77,4,1,\"\"],RoundDown:[75,5,1,\"\"],RoundNearest:[75,5,1,\"\"],RoundNearestTiesAway:[75,5,1,\"\"],RoundNearestTiesUp:[75,5,1,\"\"],RoundToZero:[75,5,1,\"\"],RoundUp:[75,5,1,\"\"],RoundingMode:[75,7,1,\"\"],STDERR:[71,5,1,\"\"],STDIN:[71,5,1,\"\"],STDOUT:[71,5,1,\"\"],Semaphore:[77,4,1,\"\"],Set:[66,4,1,\"\"],SharedArray:[77,4,1,\"\"],SpinLock:[77,4,1,\"\"],StackFrame:[83,5,1,\"\"],StackOverflowError:[64,4,1,\"\"],StackTrace:[83,5,1,\"\"],String:[84,4,1,\"\"],SymTridiagonal:[74,4,1,\"\"],Symbol:[84,4,1,\"\"],Symmetric:[74,4,1,\"\"],SystemError:[64,4,1,\"\"],Task:[77,4,1,\"\"],Test:[85,6,0,\"-\"],TextDisplay:[71,4,1,\"\"],Timer:[64,4,1,\"\"],Tridiagonal:[74,4,1,\"\"],TypeError:[64,4,1,\"\"],UndefRefError:[64,4,1,\"\"],UndefVarError:[64,4,1,\"\"],VERSION:[67,5,1,\"\"],WorkerPool:[77,4,1,\"\"],__precompile__:[64,4,1,\"\"],abs2:[75,4,1,\"\"],abs:[75,4,1,\"\"],abspath:[69,4,1,\"\"],accept:[71,4,1,\"\"],acos:[75,4,1,\"\"],acosd:[75,4,1,\"\"],acosh:[75,4,1,\"\"],acot:[75,4,1,\"\"],acotd:[75,4,1,\"\"],acoth:[75,4,1,\"\"],acquire:[77,4,1,\"\"],acsc:[75,4,1,\"\"],acscd:[75,4,1,\"\"],acsch:[75,4,1,\"\"],addprocs:[77,4,1,\"\"],airy:[75,4,1,\"\"],airyai:[75,4,1,\"\"],airyaiprime:[75,4,1,\"\"],airybi:[75,4,1,\"\"],airybiprime:[75,4,1,\"\"],airyprime:[75,4,1,\"\"],airyx:[75,4,1,\"\"],all:[66,4,1,\"\"],allunique:[66,4,1,\"\"],angle:[75,4,1,\"\"],ans:[64,5,1,\"\"],any:[66,4,1,\"\"],applicable:[64,4,1,\"\"],apropos:[64,4,1,\"\"],ascii:[84,4,1,\"\"],asec:[75,4,1,\"\"],asecd:[75,4,1,\"\"],asech:[75,4,1,\"\"],asin:[75,4,1,\"\"],asind:[75,4,1,\"\"],asinh:[75,4,1,\"\"],assert:[64,4,1,\"\"],asyncmap:[77,4,1,\"\"],atan2:[75,4,1,\"\"],atan:[75,4,1,\"\"],atand:[75,4,1,\"\"],atanh:[75,4,1,\"\"],atexit:[64,4,1,\"\"],atreplinit:[64,4,1,\"\"],backtrace:[64,4,1,\"\"],base64decode:[71,4,1,\"\"],base64encode:[71,4,1,\"\"],base:[76,4,1,\"\"],basename:[69,4,1,\"\"],besselh:[75,4,1,\"\"],besselhx:[75,4,1,\"\"],besseli:[75,4,1,\"\"],besselix:[75,4,1,\"\"],besselj0:[75,4,1,\"\"],besselj1:[75,4,1,\"\"],besselj:[75,4,1,\"\"],besseljx:[75,4,1,\"\"],besselk:[75,4,1,\"\"],besselkx:[75,4,1,\"\"],bessely0:[75,4,1,\"\"],bessely1:[75,4,1,\"\"],bessely:[75,4,1,\"\"],besselyx:[75,4,1,\"\"],beta:[75,4,1,\"\"],bfft:[75,4,1,\"\"],big:[76,4,1,\"\"],bin:[76,4,1,\"\"],bind:[71,4,1,\"\"],binomial:[75,4,1,\"\"],bitbroadcast:[63,4,1,\"\"],bitrand:[76,4,1,\"\"],bits:[76,4,1,\"\"],bkfact:[74,4,1,\"\"],blkdiag:[74,4,1,\"\"],brfft:[75,4,1,\"\"],broadcast:[63,4,1,\"\"],broadcast_getindex:[63,4,1,\"\"],bswap:[76,4,1,\"\"],bytes2hex:[76,4,1,\"\"],cat:[63,4,1,\"\"],catalan:[76,5,1,\"\"],catch_backtrace:[64,4,1,\"\"],catch_stacktrace:[83,4,1,\"\"],cbrt:[75,4,1,\"\"],ccall:[65,4,1,\"\"],cconvert:[65,4,1,\"\"],cd:[69,4,1,\"\"],ceil:[75,4,1,\"\"],cfunction:[65,4,1,\"\"],cglobal:[65,4,1,\"\"],charwidth:[84,4,1,\"\"],checkbounds:[63,4,1,\"\"],checkindex:[63,4,1,\"\"],chmod:[69,4,1,\"\"],chol:[74,4,1,\"\"],cholfact:[74,4,1,\"\"],chomp:[84,4,1,\"\"],chop:[84,4,1,\"\"],chown:[69,4,1,\"\"],chr2ind:[84,4,1,\"\"],circshift:[63,4,1,\"\"],cis:[75,4,1,\"\"],clamp:[75,4,1,\"\"],cld:[75,4,1,\"\"],clipboard:[64,4,1,\"\"],close:[77,4,1,\"\"],cmp:[75,4,1,\"\"],code_llvm:[64,4,1,\"\"],code_lowered:[64,4,1,\"\"],code_native:[64,4,1,\"\"],code_typed:[64,4,1,\"\"],code_warntype:[64,4,1,\"\"],collect:[66,4,1,\"\"],colon:[75,4,1,\"\"],complex:[76,4,1,\"\"],cond:[74,4,1,\"\"],condskeel:[74,4,1,\"\"],conj:[75,4,1,\"\"],connect:[77,4,1,\"\"],consume:[77,4,1,\"\"],contains:[84,4,1,\"\"],conv2:[75,4,1,\"\"],conv:[75,4,1,\"\"],convert:[64,4,1,\"\"],copy:[64,4,1,\"\"],copysign:[75,4,1,\"\"],cor:[75,4,1,\"\"],cos:[75,4,1,\"\"],cosc:[75,4,1,\"\"],cosd:[75,4,1,\"\"],cosh:[75,4,1,\"\"],cospi:[75,4,1,\"\"],cot:[75,4,1,\"\"],cotd:[75,4,1,\"\"],coth:[75,4,1,\"\"],count:[66,4,1,\"\"],count_ones:[76,4,1,\"\"],count_zeros:[76,4,1,\"\"],countfrom:[66,4,1,\"\"],countlines:[71,4,1,\"\"],countnz:[63,4,1,\"\"],cov:[75,4,1,\"\"],cp:[69,4,1,\"\"],cross:[74,4,1,\"\"],csc:[75,4,1,\"\"],cscd:[75,4,1,\"\"],csch:[75,4,1,\"\"],ctime:[69,4,1,\"\"],ctranspose:[74,4,1,\"\"],cummax:[63,4,1,\"\"],cummin:[63,4,1,\"\"],cumprod:[63,4,1,\"\"],cumsum:[63,4,1,\"\"],cumsum_kbn:[63,4,1,\"\"],current_module:[64,4,1,\"\"],current_task:[77,4,1,\"\"],cycle:[66,4,1,\"\"],dawson:[75,4,1,\"\"],dct:[75,4,1,\"\"],dec:[76,4,1,\"\"],deconv:[75,4,1,\"\"],deepcopy:[64,4,1,\"\"],default_worker_pool:[77,4,1,\"\"],deg2rad:[75,4,1,\"\"],den:[75,4,1,\"\"],deserialize:[71,4,1,\"\"],det:[74,4,1,\"\"],detach:[64,4,1,\"\"],diag:[74,4,1,\"\"],diagind:[74,4,1,\"\"],diagm:[74,4,1,\"\"],diff:[63,4,1,\"\"],digamma:[75,4,1,\"\"],digits:[76,4,1,\"\"],dirname:[69,4,1,\"\"],disable_sigint:[65,4,1,\"\"],display:[71,4,1,\"\"],displayable:[71,4,1,\"\"],displaysize:[71,4,1,\"\"],div:[75,4,1,\"\"],divrem:[75,4,1,\"\"],done:[66,4,1,\"\"],dot:[74,4,1,\"\"],download:[69,4,1,\"\"],drop:[66,4,1,\"\"],dropzeros:[63,4,1,\"\"],dump:[71,4,1,\"\"],e:[76,5,1,\"\"],eachindex:[63,4,1,\"\"],eachline:[71,4,1,\"\"],eachmatch:[84,4,1,\"\"],edit:[64,4,1,\"\"],eig:[74,4,1,\"\"],eigfact:[74,4,1,\"\"],eigmax:[74,4,1,\"\"],eigmin:[74,4,1,\"\"],eigs:[74,4,1,\"\"],eigvals:[74,4,1,\"\"],eigvecs:[74,4,1,\"\"],eltype:[66,4,1,\"\"],endof:[66,4,1,\"\"],endswith:[84,4,1,\"\"],enumerate:[66,4,1,\"\"],eof:[71,4,1,\"\"],eps:[64,4,1,\"\"],erf:[75,4,1,\"\"],erfc:[75,4,1,\"\"],erfcinv:[75,4,1,\"\"],erfcx:[75,4,1,\"\"],erfi:[75,4,1,\"\"],erfinv:[75,4,1,\"\"],error:[64,4,1,\"\"],esc:[64,4,1,\"\"],escape_string:[84,4,1,\"\"],eta:[75,4,1,\"\"],eu:[76,5,1,\"\"],eulergamma:[76,5,1,\"\"],eval:[64,4,1,\"\"],evalfile:[64,4,1,\"\"],exit:[64,4,1,\"\"],exp10:[75,4,1,\"\"],exp2:[75,4,1,\"\"],exp:[75,4,1,\"\"],expand:[64,4,1,\"\"],expanduser:[69,4,1,\"\"],expm1:[75,4,1,\"\"],expm:[74,4,1,\"\"],exponent:[76,4,1,\"\"],extrema:[66,4,1,\"\"],eye:[63,4,1,\"\"],factorial:[75,4,1,\"\"],factorize:[74,4,1,\"\"],falses:[63,4,1,\"\"],fd:[71,4,1,\"\"],fdio:[71,4,1,\"\"],fetch:[77,4,1,\"\"],fft:[75,4,1,\"\"],fftshift:[75,4,1,\"\"],fieldname:[64,4,1,\"\"],fieldnames:[64,4,1,\"\"],fieldoffset:[64,4,1,\"\"],fieldtype:[64,4,1,\"\"],filemode:[69,4,1,\"\"],filesize:[69,4,1,\"\"],fill:[63,4,1,\"\"],filt:[75,4,1,\"\"],filter:[66,4,1,\"\"],finalize:[64,4,1,\"\"],finalizer:[64,4,1,\"\"],find:[63,4,1,\"\"],findfirst:[63,4,1,\"\"],findin:[66,4,1,\"\"],findlast:[63,4,1,\"\"],findmax:[66,4,1,\"\"],findmin:[66,4,1,\"\"],findn:[63,4,1,\"\"],findnext:[63,4,1,\"\"],findnz:[63,4,1,\"\"],findprev:[63,4,1,\"\"],first:[66,4,1,\"\"],fld1:[75,4,1,\"\"],fld:[75,4,1,\"\"],fldmod1:[75,4,1,\"\"],fldmod:[75,4,1,\"\"],flipdim:[63,4,1,\"\"],flipsign:[75,4,1,\"\"],floor:[75,4,1,\"\"],flush:[71,4,1,\"\"],fma:[75,4,1,\"\"],foldl:[66,4,1,\"\"],foldr:[66,4,1,\"\"],foreach:[66,4,1,\"\"],frexp:[75,4,1,\"\"],full:[74,4,1,\"\"],fullname:[64,4,1,\"\"],functionloc:[64,4,1,\"\"],gamma:[75,4,1,\"\"],gc:[64,4,1,\"\"],gc_enable:[64,4,1,\"\"],gcd:[75,4,1,\"\"],gcdx:[75,4,1,\"\"],gensym:[64,4,1,\"\"],get:[66,4,1,\"\"],get_zero_subnormals:[76,4,1,\"\"],getaddrinfo:[71,4,1,\"\"],getfield:[64,4,1,\"\"],gethostname:[64,4,1,\"\"],getindex:[66,4,1,\"\"],getipaddr:[64,4,1,\"\"],getkey:[66,4,1,\"\"],getpid:[64,4,1,\"\"],getsockname:[71,4,1,\"\"],givens:[74,4,1,\"\"],golden:[76,5,1,\"\"],gperm:[69,4,1,\"\"],gradient:[63,4,1,\"\"],graphemes:[84,4,1,\"\"],hankelh1:[75,4,1,\"\"],hankelh1x:[75,4,1,\"\"],hankelh2:[75,4,1,\"\"],hankelh2x:[75,4,1,\"\"],hash:[64,4,1,\"\"],haskey:[66,4,1,\"\"],hcat:[63,4,1,\"\"],hessfact:[74,4,1,\"\"],hex2bytes:[76,4,1,\"\"],hex2num:[76,4,1,\"\"],hex:[76,4,1,\"\"],homedir:[69,4,1,\"\"],htol:[71,4,1,\"\"],hton:[71,4,1,\"\"],hvcat:[63,4,1,\"\"],hypot:[75,4,1,\"\"],idct:[75,4,1,\"\"],identity:[64,4,1,\"\"],ifelse:[64,4,1,\"\"],ifft:[75,4,1,\"\"],ifftshift:[75,4,1,\"\"],ignorestatus:[64,4,1,\"\"],im:[76,5,1,\"\"],imag:[75,4,1,\"\"],include:[64,4,1,\"\"],include_dependency:[64,4,1,\"\"],include_string:[64,4,1,\"\"],ind2chr:[84,4,1,\"\"],ind2sub:[63,4,1,\"\"],indexin:[66,4,1,\"\"],indexpids:[77,4,1,\"\"],indices:[63,4,1,\"\"],indmax:[66,4,1,\"\"],indmin:[66,4,1,\"\"],info:[71,4,1,\"\"],init_worker:[77,4,1,\"\"],instances:[64,4,1,\"\"],interrupt:[77,4,1,\"\"],intersect:[66,4,1,\"\"],inv:[74,4,1,\"\"],invdigamma:[75,4,1,\"\"],invmod:[75,4,1,\"\"],invoke:[64,4,1,\"\"],invperm:[63,4,1,\"\"],ipermutedims:[63,4,1,\"\"],irfft:[75,4,1,\"\"],is:[64,4,1,\"\"],is_apple:[64,4,1,\"\"],is_assigned_char:[84,4,1,\"\"],is_bsd:[64,4,1,\"\"],is_linux:[64,4,1,\"\"],is_unix:[64,4,1,\"\"],is_windows:[64,4,1,\"\"],isa:[64,4,1,\"\"],isabspath:[69,4,1,\"\"],isalnum:[84,4,1,\"\"],isalpha:[84,4,1,\"\"],isapprox:[75,4,1,\"\"],isascii:[84,4,1,\"\"],isassigned:[63,4,1,\"\"],isbits:[64,4,1,\"\"],isblockdev:[69,4,1,\"\"],ischardev:[69,4,1,\"\"],iscntrl:[84,4,1,\"\"],isconst:[64,4,1,\"\"],isdefined:[64,4,1,\"\"],isdiag:[74,4,1,\"\"],isdigit:[84,4,1,\"\"],isdir:[69,4,1,\"\"],isdirpath:[69,4,1,\"\"],isempty:[66,4,1,\"\"],isequal:[64,4,1,\"\"],iseven:[76,4,1,\"\"],isfifo:[69,4,1,\"\"],isfile:[69,4,1,\"\"],isfinite:[76,4,1,\"\"],isgraph:[84,4,1,\"\"],ishermitian:[74,4,1,\"\"],isimag:[76,4,1,\"\"],isimmutable:[64,4,1,\"\"],isinf:[76,4,1,\"\"],isinteger:[76,4,1,\"\"],isinteractive:[64,4,1,\"\"],isleaftype:[64,4,1,\"\"],isless:[64,4,1,\"\"],islink:[69,4,1,\"\"],islocked:[77,4,1,\"\"],islower:[84,4,1,\"\"],ismarked:[71,4,1,\"\"],ismatch:[84,4,1,\"\"],ismount:[69,4,1,\"\"],isnan:[76,4,1,\"\"],isnull:[64,4,1,\"\"],isnumber:[84,4,1,\"\"],isodd:[76,4,1,\"\"],isopen:[71,4,1,\"\"],ispath:[69,4,1,\"\"],isperm:[63,4,1,\"\"],isposdef:[74,4,1,\"\"],ispow2:[75,4,1,\"\"],isprint:[84,4,1,\"\"],ispunct:[84,4,1,\"\"],isqrt:[75,4,1,\"\"],isreadable:[71,4,1,\"\"],isreadonly:[71,4,1,\"\"],isready:[77,4,1,\"\"],isreal:[76,4,1,\"\"],issetgid:[69,4,1,\"\"],issetuid:[69,4,1,\"\"],issocket:[69,4,1,\"\"],issorted:[82,4,1,\"\"],isspace:[84,4,1,\"\"],issparse:[63,4,1,\"\"],issticky:[69,4,1,\"\"],issubnormal:[76,4,1,\"\"],issubset:[66,4,1,\"\"],issubtype:[64,4,1,\"\"],issymmetric:[74,4,1,\"\"],istaskdone:[77,4,1,\"\"],istaskstarted:[77,4,1,\"\"],istextmime:[71,4,1,\"\"],istril:[74,4,1,\"\"],istriu:[74,4,1,\"\"],isupper:[84,4,1,\"\"],isvalid:[84,4,1,\"\"],iswritable:[71,4,1,\"\"],isxdigit:[84,4,1,\"\"],iteratoreltype:[66,4,1,\"\"],iteratorsize:[66,4,1,\"\"],join:[84,4,1,\"\"],joinpath:[69,4,1,\"\"],keys:[66,4,1,\"\"],keytype:[66,4,1,\"\"],kill:[77,4,1,\"\"],kron:[74,4,1,\"\"],last:[66,4,1,\"\"],launch:[77,4,1,\"\"],lbeta:[75,4,1,\"\"],lcfirst:[84,4,1,\"\"],lcm:[75,4,1,\"\"],ldexp:[75,4,1,\"\"],ldltfact:[74,4,1,\"\"],leading_ones:[76,4,1,\"\"],leading_zeros:[76,4,1,\"\"],length:[84,4,1,\"\"],less:[64,4,1,\"\"],lexcmp:[64,4,1,\"\"],lexless:[64,4,1,\"\"],lfact:[75,4,1,\"\"],lgamma:[75,4,1,\"\"],linearindices:[63,4,1,\"\"],linreg:[74,4,1,\"\"],linspace:[63,4,1,\"\"],listen:[71,4,1,\"\"],listenany:[71,4,1,\"\"],llvmcall:[65,4,1,\"\"],localindexes:[77,4,1,\"\"],lock:[77,4,1,\"\"],log10:[75,4,1,\"\"],log1p:[75,4,1,\"\"],log2:[75,4,1,\"\"],log:[75,4,1,\"\"],logabsdet:[74,4,1,\"\"],logdet:[74,4,1,\"\"],logm:[74,4,1,\"\"],logspace:[63,4,1,\"\"],lowercase:[84,4,1,\"\"],lpad:[84,4,1,\"\"],lq:[74,4,1,\"\"],lqfact:[74,4,1,\"\"],lstat:[69,4,1,\"\"],lstrip:[84,4,1,\"\"],ltoh:[71,4,1,\"\"],lu:[74,4,1,\"\"],lufact:[74,4,1,\"\"],lyap:[74,4,1,\"\"],macroexpand:[64,4,1,\"\"],manage:[77,4,1,\"\"],map:[66,4,1,\"\"],mapfoldl:[66,4,1,\"\"],mapfoldr:[66,4,1,\"\"],mapreduce:[66,4,1,\"\"],mapreducedim:[63,4,1,\"\"],mapslices:[63,4,1,\"\"],mark:[71,4,1,\"\"],match:[84,4,1,\"\"],matchall:[84,4,1,\"\"],max:[75,4,1,\"\"],maxabs:[66,4,1,\"\"],maximum:[66,4,1,\"\"],maxintfloat:[64,4,1,\"\"],mean:[75,4,1,\"\"],median:[75,4,1,\"\"],merge:[66,4,1,\"\"],method_exists:[64,4,1,\"\"],methods:[64,4,1,\"\"],methodswith:[64,4,1,\"\"],middle:[75,4,1,\"\"],midpoints:[75,4,1,\"\"],mimewritable:[71,4,1,\"\"],min:[75,4,1,\"\"],minabs:[66,4,1,\"\"],minimum:[66,4,1,\"\"],minmax:[75,4,1,\"\"],mkdir:[69,4,1,\"\"],mkpath:[69,4,1,\"\"],mktemp:[69,4,1,\"\"],mktempdir:[69,4,1,\"\"],mod1:[75,4,1,\"\"],mod2pi:[75,4,1,\"\"],mod:[75,4,1,\"\"],modf:[75,4,1,\"\"],module_name:[64,4,1,\"\"],module_parent:[64,4,1,\"\"],mtime:[69,4,1,\"\"],muladd:[75,4,1,\"\"],mv:[69,4,1,\"\"],myid:[77,4,1,\"\"],names:[64,4,1,\"\"],nb_available:[71,4,1,\"\"],ndigits:[75,4,1,\"\"],ndims:[63,4,1,\"\"],next:[66,4,1,\"\"],nextfloat:[76,4,1,\"\"],nextind:[84,4,1,\"\"],nextpow2:[75,4,1,\"\"],nextpow:[75,4,1,\"\"],nextprod:[75,4,1,\"\"],nfields:[64,4,1,\"\"],nnz:[63,4,1,\"\"],nonzeros:[63,4,1,\"\"],norm:[74,4,1,\"\"],normalize:[74,4,1,\"\"],normalize_string:[84,4,1,\"\"],normpath:[69,4,1,\"\"],nothing:[67,5,1,\"\"],notify:[77,4,1,\"\"],nprocs:[77,4,1,\"\"],ntoh:[71,4,1,\"\"],ntuple:[64,4,1,\"\"],nullspace:[74,4,1,\"\"],num2hex:[76,4,1,\"\"],num:[75,4,1,\"\"],nworkers:[77,4,1,\"\"],nzrange:[63,4,1,\"\"],object_id:[64,4,1,\"\"],oct:[76,4,1,\"\"],oftype:[64,4,1,\"\"],one:[76,4,1,\"\"],ones:[63,4,1,\"\"],open:[71,4,1,\"\"],operm:[69,4,1,\"\"],ordschur:[74,4,1,\"\"],parent:[63,4,1,\"\"],parentindexes:[63,4,1,\"\"],parse:[76,4,1,\"\"],peakflops:[74,4,1,\"\"],permutedims:[63,4,1,\"\"],pi:[76,5,1,\"\"],pinv:[74,4,1,\"\"],pipeline:[64,4,1,\"\"],plan_bfft:[75,4,1,\"\"],plan_brfft:[75,4,1,\"\"],plan_dct:[75,4,1,\"\"],plan_fft:[75,4,1,\"\"],plan_idct:[75,4,1,\"\"],plan_ifft:[75,4,1,\"\"],plan_irfft:[75,4,1,\"\"],plan_rfft:[75,4,1,\"\"],pmap:[77,4,1,\"\"],pointer:[65,4,1,\"\"],pointer_from_objref:[65,4,1,\"\"],poll_fd:[71,4,1,\"\"],poll_file:[71,4,1,\"\"],polygamma:[75,4,1,\"\"],popdisplay:[71,4,1,\"\"],position:[71,4,1,\"\"],powermod:[75,4,1,\"\"],precision:[76,4,1,\"\"],precompile:[64,4,1,\"\"],prevfloat:[76,4,1,\"\"],prevind:[84,4,1,\"\"],prevpow2:[75,4,1,\"\"],prevpow:[75,4,1,\"\"],print:[71,4,1,\"\"],print_shortest:[71,4,1,\"\"],print_with_color:[71,4,1,\"\"],println:[71,4,1,\"\"],process_exited:[64,4,1,\"\"],process_running:[64,4,1,\"\"],procs:[77,4,1,\"\"],prod:[66,4,1,\"\"],produce:[77,4,1,\"\"],promote:[64,4,1,\"\"],promote_rule:[64,4,1,\"\"],promote_shape:[63,4,1,\"\"],promote_type:[64,4,1,\"\"],pushdisplay:[71,4,1,\"\"],pwd:[69,4,1,\"\"],qr:[74,4,1,\"\"],qrfact:[74,4,1,\"\"],quadgk:[75,4,1,\"\"],quantile:[75,4,1,\"\"],quit:[64,4,1,\"\"],rad2deg:[75,4,1,\"\"],rand:[76,4,1,\"\"],randcycle:[63,4,1,\"\"],randexp:[76,4,1,\"\"],randjump:[76,4,1,\"\"],randn:[76,4,1,\"\"],randperm:[63,4,1,\"\"],randstring:[84,4,1,\"\"],randsubseq:[63,4,1,\"\"],range:[75,4,1,\"\"],rank:[74,4,1,\"\"],rationalize:[75,4,1,\"\"],read:[71,4,1,\"\"],readandwrite:[64,4,1,\"\"],readavailable:[71,4,1,\"\"],readchomp:[71,4,1,\"\"],readcsv:[71,4,1,\"\"],readdir:[69,4,1,\"\"],readdlm:[71,4,1,\"\"],readline:[71,4,1,\"\"],readlines:[71,4,1,\"\"],readlink:[69,4,1,\"\"],readstring:[71,4,1,\"\"],readuntil:[71,4,1,\"\"],real:[75,4,1,\"\"],realmax:[64,4,1,\"\"],realmin:[64,4,1,\"\"],realpath:[69,4,1,\"\"],recv:[71,4,1,\"\"],recvfrom:[71,4,1,\"\"],redirect_stderr:[71,4,1,\"\"],redirect_stdin:[71,4,1,\"\"],redirect_stdout:[71,4,1,\"\"],redisplay:[71,4,1,\"\"],reduce:[66,4,1,\"\"],reducedim:[63,4,1,\"\"],reenable_sigint:[65,4,1,\"\"],reim:[75,4,1,\"\"],reinterpret:[63,4,1,\"\"],release:[77,4,1,\"\"],reload:[64,4,1,\"\"],relpath:[69,4,1,\"\"],rem:[75,4,1,\"\"],remote:[77,4,1,\"\"],remotecall:[77,4,1,\"\"],remotecall_fetch:[77,4,1,\"\"],remotecall_wait:[77,4,1,\"\"],repeat:[74,4,1,\"\"],repeated:[66,4,1,\"\"],replace:[84,4,1,\"\"],repmat:[74,4,1,\"\"],repr:[84,4,1,\"\"],reprmime:[71,4,1,\"\"],require:[64,4,1,\"\"],reset:[71,4,1,\"\"],reshape:[63,4,1,\"\"],rest:[66,4,1,\"\"],rethrow:[64,4,1,\"\"],retry:[64,4,1,\"\"],reverse:[84,4,1,\"\"],reverseind:[63,4,1,\"\"],rfft:[75,4,1,\"\"],rm:[69,4,1,\"\"],rmprocs:[77,4,1,\"\"],rol:[63,4,1,\"\"],ror:[63,4,1,\"\"],rot180:[63,4,1,\"\"],rotl90:[63,4,1,\"\"],rotr90:[63,4,1,\"\"],round:[75,4,1,\"\"],rounding:[76,4,1,\"\"],rowvals:[63,4,1,\"\"],rpad:[84,4,1,\"\"],rsearch:[84,4,1,\"\"],rsearchindex:[84,4,1,\"\"],rsplit:[84,4,1,\"\"],rstrip:[84,4,1,\"\"],run:[64,4,1,\"\"],runtests:[85,4,1,\"\"],schedule:[77,4,1,\"\"],schur:[74,4,1,\"\"],schurfact:[74,4,1,\"\"],sdata:[77,4,1,\"\"],search:[84,4,1,\"\"],searchindex:[84,4,1,\"\"],searchsorted:[82,4,1,\"\"],searchsortedfirst:[82,4,1,\"\"],searchsortedlast:[82,4,1,\"\"],sec:[75,4,1,\"\"],secd:[75,4,1,\"\"],sech:[75,4,1,\"\"],seek:[71,4,1,\"\"],seekend:[71,4,1,\"\"],seekstart:[71,4,1,\"\"],select:[82,4,1,\"\"],selectperm:[82,4,1,\"\"],send:[71,4,1,\"\"],serialize:[71,4,1,\"\"],set_zero_subnormals:[76,4,1,\"\"],setdiff:[66,4,1,\"\"],setenv:[64,4,1,\"\"],setopt:[71,4,1,\"\"],setprecision:[76,4,1,\"\"],setrounding:[76,4,1,\"\"],show:[71,4,1,\"\"],showall:[71,4,1,\"\"],showcompact:[71,4,1,\"\"],showerror:[71,4,1,\"\"],shuffle:[63,4,1,\"\"],sign:[75,4,1,\"\"],signbit:[75,4,1,\"\"],signed:[76,4,1,\"\"],signif:[75,4,1,\"\"],significand:[76,4,1,\"\"],similar:[63,4,1,\"\"],sin:[75,4,1,\"\"],sinc:[75,4,1,\"\"],sind:[75,4,1,\"\"],sinh:[75,4,1,\"\"],sinpi:[75,4,1,\"\"],size:[63,4,1,\"\"],sizeof:[84,4,1,\"\"],skip:[71,4,1,\"\"],skipchars:[71,4,1,\"\"],sleep:[77,4,1,\"\"],slicedim:[63,4,1,\"\"],sort:[82,4,1,\"\"],sortcols:[82,4,1,\"\"],sortperm:[82,4,1,\"\"],sortrows:[82,4,1,\"\"],sparse:[63,4,1,\"\"],sparsevec:[63,4,1,\"\"],spawn:[64,4,1,\"\"],spdiagm:[63,4,1,\"\"],speye:[63,4,1,\"\"],split:[84,4,1,\"\"],splitdir:[69,4,1,\"\"],splitdrive:[69,4,1,\"\"],splitext:[69,4,1,\"\"],spones:[63,4,1,\"\"],sprand:[63,4,1,\"\"],sprandn:[63,4,1,\"\"],sprint:[71,4,1,\"\"],spzeros:[63,4,1,\"\"],sqrt:[75,4,1,\"\"],sqrtm:[74,4,1,\"\"],squeeze:[63,4,1,\"\"],srand:[76,4,1,\"\"],stacktrace:[83,4,1,\"\"],start:[66,4,1,\"\"],startswith:[84,4,1,\"\"],stat:[69,4,1,\"\"],std:[75,4,1,\"\"],stdm:[75,4,1,\"\"],step:[66,4,1,\"\"],stride:[63,4,1,\"\"],strides:[63,4,1,\"\"],string:[84,4,1,\"\"],stringmime:[71,4,1,\"\"],strip:[84,4,1,\"\"],strwidth:[84,4,1,\"\"],sub2ind:[63,4,1,\"\"],subtypes:[64,4,1,\"\"],success:[64,4,1,\"\"],sum:[66,4,1,\"\"],sum_kbn:[63,4,1,\"\"],sumabs2:[66,4,1,\"\"],sumabs:[66,4,1,\"\"],summary:[71,4,1,\"\"],supertype:[64,4,1,\"\"],svd:[74,4,1,\"\"],svdfact:[74,4,1,\"\"],svds:[74,4,1,\"\"],svdvals:[74,4,1,\"\"],sylvester:[74,4,1,\"\"],symdiff:[66,4,1,\"\"],symlink:[69,4,1,\"\"],systemerror:[65,4,1,\"\"],take:[66,4,1,\"\"],takebuf_array:[71,4,1,\"\"],takebuf_string:[71,4,1,\"\"],tan:[75,4,1,\"\"],tand:[75,4,1,\"\"],tanh:[75,4,1,\"\"],task_local_storage:[77,4,1,\"\"],tempdir:[69,4,1,\"\"],tempname:[69,4,1,\"\"],tic:[64,4,1,\"\"],time:[64,4,1,\"\"],time_ns:[64,4,1,\"\"],timedwait:[77,4,1,\"\"],toc:[64,4,1,\"\"],toq:[64,4,1,\"\"],touch:[69,4,1,\"\"],trace:[74,4,1,\"\"],trailing_ones:[76,4,1,\"\"],trailing_zeros:[76,4,1,\"\"],transcode:[84,4,1,\"\"],transpose:[74,4,1,\"\"],trigamma:[75,4,1,\"\"],tril:[74,4,1,\"\"],triu:[74,4,1,\"\"],trues:[63,4,1,\"\"],trunc:[75,4,1,\"\"],truncate:[71,4,1,\"\"],trylock:[77,4,1,\"\"],tryparse:[76,4,1,\"\"],tuple:[64,4,1,\"\"],typeintersect:[64,4,1,\"\"],typejoin:[64,4,1,\"\"],typemax:[64,4,1,\"\"],typemin:[64,4,1,\"\"],ucfirst:[84,4,1,\"\"],unescape_string:[84,4,1,\"\"],union:[66,4,1,\"\"],unique:[66,4,1,\"\"],unlock:[77,4,1,\"\"],unmark:[71,4,1,\"\"],unsafe_convert:[65,4,1,\"\"],unsafe_load:[65,4,1,\"\"],unsafe_pointer_to_objref:[65,4,1,\"\"],unsafe_read:[71,4,1,\"\"],unsafe_string:[84,4,1,\"\"],unsafe_trunc:[75,4,1,\"\"],unsafe_wrap:[84,4,1,\"\"],unsafe_write:[71,4,1,\"\"],unsigned:[76,4,1,\"\"],uperm:[69,4,1,\"\"],uppercase:[84,4,1,\"\"],valtype:[66,4,1,\"\"],values:[66,4,1,\"\"],varm:[75,4,1,\"\"],vcat:[63,4,1,\"\"],vec:[63,4,1,\"\"],vecdot:[74,4,1,\"\"],vecnorm:[74,4,1,\"\"],versioninfo:[64,4,1,\"\"],view:[63,4,1,\"\"],wait:[77,4,1,\"\"],walkdir:[69,4,1,\"\"],warn:[71,4,1,\"\"],watch_file:[71,4,1,\"\"],which:[64,4,1,\"\"],whos:[64,4,1,\"\"],widemul:[75,4,1,\"\"],widen:[64,4,1,\"\"],windows_version:[64,4,1,\"\"],withenv:[64,4,1,\"\"],workers:[77,4,1,\"\"],workspace:[64,4,1,\"\"],write:[71,4,1,\"\"],writecsv:[71,4,1,\"\"],writedlm:[71,4,1,\"\"],xcorr:[75,4,1,\"\"],yield:[77,4,1,\"\"],yieldto:[77,4,1,\"\"],zero:[76,4,1,\"\"],zeros:[63,4,1,\"\"],zeta:[75,4,1,\"\"],zip:[66,4,1,\"\"]},Dates:{\"UTInstant{T}\":[68,5,1,\"\"],\"default\":[68,4,1,\"\"],\"recur{T&lt;:TimeType}\":[68,4,1,\"Dates.recur{T<:TimeType}\"],CompoundPeriod:[68,7,1,\"\"],Date:[68,5,1,\"\"],DateFormat:[68,4,1,\"\"],DateTime:[68,5,1,\"\"],Day:[68,5,1,\"\"],Hour:[68,5,1,\"\"],Instant:[68,5,1,\"\"],Millisecond:[68,5,1,\"\"],Minute:[68,5,1,\"\"],Month:[68,5,1,\"\"],Period:[68,5,1,\"\"],Second:[68,5,1,\"\"],TimeType:[68,5,1,\"\"],Week:[68,5,1,\"\"],Year:[68,5,1,\"\"],ceil:[68,4,1,\"\"],date2epochdays:[68,4,1,\"\"],datetime2epochms:[68,4,1,\"\"],datetime2julian:[68,4,1,\"\"],datetime2rata:[68,4,1,\"\"],datetime2unix:[68,4,1,\"\"],day:[68,4,1,\"\"],dayabbr:[68,4,1,\"\"],dayname:[68,4,1,\"\"],dayofmonth:[68,4,1,\"\"],dayofquarter:[68,4,1,\"\"],dayofweek:[68,4,1,\"\"],dayofweekofmonth:[68,4,1,\"\"],dayofyear:[68,4,1,\"\"],daysinmonth:[68,4,1,\"\"],daysinyear:[68,4,1,\"\"],daysofweekinmonth:[68,4,1,\"\"],epochdays2date:[68,4,1,\"\"],epochms2datetime:[68,4,1,\"\"],eps:[68,4,1,\"\"],firstdayofmonth:[68,4,1,\"\"],firstdayofquarter:[68,4,1,\"\"],firstdayofweek:[68,4,1,\"\"],firstdayofyear:[68,4,1,\"\"],floor:[68,4,1,\"\"],floorceil:[68,4,1,\"\"],format:[68,4,1,\"\"],hour:[68,4,1,\"\"],isleapyear:[68,4,1,\"\"],julian2datetime:[68,4,1,\"\"],lastdayofmonth:[68,4,1,\"\"],lastdayofquarter:[68,4,1,\"\"],lastdayofweek:[68,4,1,\"\"],lastdayofyear:[68,4,1,\"\"],millisecond:[68,4,1,\"\"],minute:[68,4,1,\"\"],month:[68,4,1,\"\"],monthabbr:[68,4,1,\"\"],monthday:[68,4,1,\"\"],monthname:[68,4,1,\"\"],now:[68,4,1,\"\"],quarterofyear:[68,4,1,\"\"],rata2datetime:[68,4,1,\"\"],round:[68,4,1,\"\"],second:[68,4,1,\"\"],today:[68,4,1,\"\"],tofirst:[68,4,1,\"\"],tolast:[68,4,1,\"\"],tonext:[68,4,1,\"\"],toprev:[68,4,1,\"\"],trunc:[68,4,1,\"\"],unix2datetime:[68,4,1,\"\"],week:[68,4,1,\"\"],year:[68,4,1,\"\"],yearmonth:[68,4,1,\"\"],yearmonthday:[68,4,1,\"\"]}},objnames:{\"0\":[\"jl\",\"function\",\"Julia function\"],\"1\":[\"jl\",\"data\",\"Julia data\"],\"2\":[\"jl\",\"module\",\"Julia module\"],\"3\":[\"jl\",\"type\",\"type\"],\"4\":[\"py\",\"function\",\"Python function\"],\"5\":[\"py\",\"data\",\"Python data\"],\"6\":[\"py\",\"module\",\"Python module\"],\"7\":[\"py\",\"type\",\"type\"]},objtypes:{\"0\":\"jl:function\",\"1\":\"jl:data\",\"2\":\"jl:module\",\"3\":\"jl:type\",\"4\":\"py:function\",\"5\":\"py:data\",\"6\":\"py:module\",\"7\":\"py:type\"},terms:{\"0000001f\":52,\"00025f0\":39,\"000_000_005\":39,\"000a1\":59,\"000a3\":59,\"000a5\":59,\"000a6\":59,\"000a7\":59,\"000a8\":59,\"000a9\":59,\"000aa\":59,\"000ac\":59,\"000ae\":59,\"000af\":59,\"000b0\":59,\"000b1\":59,\"000b2\":59,\"000b3\":59,\"000b4\":59,\"000b6\":59,\"000b7\":59,\"000b9\":59,\"000ba\":59,\"000bc\":59,\"000bd\":59,\"000be\":59,\"000bf\":59,\"000c5\":59,\"000c6\":59,\"000d0\":59,\"000d7\":59,\"000d8\":59,\"000de\":59,\"000df\":59,\"000e5\":59,\"000e6\":59,\"000f0\":59,\"000f7\":59,\"000f8\":59,\"000fe\":59,\"0014a\":59,\"0014b\":59,\"0019e\":59,\"001b5\":59,\"001c2\":59,\"0025b\":59,\"0026c\":59,\"0026d\":59,\"0026f\":59,\"0027a\":59,\"0027b\":59,\"0027c\":59,\"0027d\":59,\"0027e\":59,\"0028a\":59,\"0028b\":59,\"0028c\":59,\"0028d\":59,\"0028e\":59,\"0029e\":59,\"002a4\":59,\"002a7\":59,\"002b0\":59,\"002b2\":59,\"002b3\":59,\"002b7\":59,\"002b8\":59,\"002bc\":59,\"002c7\":59,\"002c8\":59,\"002cc\":59,\"002d0\":59,\"002d1\":59,\"002d2\":59,\"002d3\":59,\"002d4\":59,\"002d5\":59,\"002d8\":59,\"002dc\":59,\"002e1\":59,\"002e2\":59,\"002e3\":59,\"0030a\":59,\"0030b\":59,\"0030c\":59,\"0031a\":59,\"0032a\":59,\"0034d\":59,\"0039a\":59,\"0039b\":59,\"0039c\":59,\"0039d\":59,\"0039e\":59,\"0039f\":59,\"003a0\":59,\"003a1\":59,\"003a3\":59,\"003a4\":59,\"003a5\":59,\"003a6\":59,\"003a7\":59,\"003a8\":59,\"003a9\":59,\"003b1\":59,\"003b2\":59,\"003b3\":59,\"003b4\":59,\"003b5\":59,\"003b6\":59,\"003b7\":59,\"003b8\":59,\"003b9\":59,\"003ba\":59,\"003bb\":59,\"003bc\":59,\"003bd\":59,\"003be\":59,\"003bf\":59,\"003c0\":59,\"003c1\":59,\"003c2\":59,\"003c3\":59,\"003c4\":59,\"003c5\":59,\"003c6\":59,\"003c7\":59,\"003c8\":59,\"003c9\":59,\"003d0\":59,\"003d1\":59,\"003d5\":59,\"003d6\":59,\"003d8\":59,\"003d9\":59,\"003da\":59,\"003db\":59,\"003dc\":59,\"003dd\":59,\"003de\":59,\"003df\":59,\"003e0\":59,\"003e1\":59,\"003f0\":59,\"003f1\":59,\"003f4\":59,\"003f5\":59,\"003f6\":59,\"00a0\":60,\"01d2c\":59,\"01d2e\":59,\"01d30\":59,\"01d31\":59,\"01d33\":59,\"01d34\":59,\"01d35\":59,\"01d36\":59,\"01d37\":59,\"01d38\":59,\"01d39\":59,\"01d3a\":59,\"01d3c\":59,\"01d3e\":59,\"01d3f\":59,\"01d40\":59,\"01d41\":59,\"01d42\":59,\"01d43\":59,\"01d45\":59,\"01d47\":59,\"01d48\":59,\"01d49\":59,\"01d4b\":59,\"01d4d\":59,\"01d4f\":59,\"01d50\":59,\"01d52\":59,\"01d56\":59,\"01d57\":59,\"01d58\":59,\"01d5b\":59,\"01d5d\":59,\"01d5e\":59,\"01d5f\":59,\"01d60\":59,\"01d61\":59,\"01d62\":59,\"01d63\":59,\"01d64\":59,\"01d65\":59,\"01d66\":59,\"01d67\":59,\"01d68\":59,\"01d69\":59,\"01d6a\":59,\"01d9c\":59,\"01da0\":59,\"01da5\":59,\"01db2\":59,\"01dbb\":59,\"01dbf\":59,\"01t00\":[31,68],\"01t12\":[31,68],\"0200a\":59,\"0201b\":59,\"0201c\":59,\"0201d\":59,\"0203a\":59,\"0203c\":59,\"0207a\":59,\"0207b\":59,\"0207c\":59,\"0207d\":59,\"0207e\":59,\"0207f\":59,\"0208a\":59,\"0208b\":59,\"0208c\":59,\"0208d\":59,\"0208e\":59,\"0209a\":59,\"0209b\":59,\"0209c\":59,\"020a7\":59,\"020ac\":59,\"020d0\":59,\"020d1\":59,\"020d2\":59,\"020d6\":59,\"020d7\":59,\"020db\":59,\"020dc\":59,\"020dd\":59,\"020de\":59,\"020df\":59,\"020e1\":59,\"020e4\":59,\"020e7\":59,\"020e8\":59,\"020e9\":59,\"020ec\":59,\"020ed\":59,\"020ee\":59,\"020ef\":59,\"020f0\":59,\"0210a\":59,\"0210b\":59,\"0210c\":59,\"0210d\":59,\"0210e\":59,\"0210f\":59,\"0211a\":59,\"0211b\":59,\"0211c\":59,\"0211d\":59,\"0211e\":59,\"0212b\":59,\"0212c\":59,\"0212d\":59,\"0212f\":59,\"0213c\":59,\"0213d\":59,\"0213e\":59,\"0213f\":59,\"0214a\":59,\"0214b\":59,\"0219a\":59,\"0219b\":59,\"0219c\":59,\"0219d\":59,\"0219e\":59,\"0219f\":59,\"021a0\":59,\"021a1\":59,\"021a2\":59,\"021a3\":59,\"021a4\":59,\"021a5\":59,\"021a6\":59,\"021a7\":59,\"021a8\":59,\"021a9\":59,\"021aa\":59,\"021ab\":59,\"021ac\":59,\"021ad\":59,\"021ae\":59,\"021af\":59,\"021b0\":59,\"021b1\":59,\"021b2\":59,\"021b3\":59,\"021b4\":59,\"021b5\":59,\"021b6\":59,\"021b7\":59,\"021b8\":59,\"021b9\":59,\"021ba\":59,\"021bb\":59,\"021bc\":59,\"021bd\":59,\"021be\":59,\"021bf\":59,\"021c0\":59,\"021c1\":59,\"021c2\":59,\"021c3\":59,\"021c4\":59,\"021c5\":59,\"021c6\":59,\"021c7\":59,\"021c8\":59,\"021c9\":59,\"021ca\":59,\"021cb\":59,\"021cc\":59,\"021cd\":59,\"021ce\":59,\"021cf\":59,\"021d0\":59,\"021d1\":59,\"021d2\":59,\"021d3\":59,\"021d4\":59,\"021d5\":59,\"021d6\":59,\"021d7\":59,\"021d8\":59,\"021d9\":59,\"021da\":59,\"021db\":59,\"021dc\":59,\"021dd\":59,\"021de\":59,\"021df\":59,\"021e0\":59,\"021e1\":59,\"021e2\":59,\"021e3\":59,\"021e4\":59,\"021e5\":59,\"021e6\":59,\"021e7\":59,\"021e8\":59,\"021e9\":59,\"021ea\":59,\"021f4\":59,\"021f5\":59,\"021f6\":59,\"021f7\":59,\"021f8\":59,\"021f9\":59,\"021fa\":59,\"021fb\":59,\"021fc\":59,\"021fd\":59,\"021fe\":59,\"021ff\":59,\"0220a\":59,\"0220b\":59,\"0220c\":59,\"0220d\":59,\"0220e\":59,\"0220f\":59,\"0221a\":59,\"0221b\":59,\"0221c\":59,\"0221d\":59,\"0221e\":59,\"0221f\":59,\"0222a\":59,\"0222b\":59,\"0222c\":59,\"0222d\":59,\"0222e\":59,\"0222f\":59,\"0223a\":59,\"0223b\":59,\"0223c\":59,\"0223d\":59,\"0223e\":59,\"0223f\":59,\"0224a\":59,\"0224b\":59,\"0224c\":59,\"0224d\":59,\"0224e\":59,\"0224f\":59,\"0225a\":59,\"0225b\":59,\"0225c\":59,\"0225d\":59,\"0225e\":59,\"0225f\":59,\"0226a\":59,\"0226b\":59,\"0226c\":59,\"0226d\":59,\"0226e\":59,\"0226f\":59,\"0227a\":59,\"0227b\":59,\"0227c\":59,\"0227d\":59,\"0227e\":59,\"0227f\":59,\"0228a\":59,\"0228b\":59,\"0228d\":59,\"0228e\":59,\"0228f\":59,\"0229a\":59,\"0229b\":59,\"0229c\":59,\"0229d\":59,\"0229e\":59,\"0229f\":59,\"022a0\":59,\"022a1\":59,\"022a2\":59,\"022a3\":59,\"022a4\":59,\"022a5\":59,\"022a7\":59,\"022a8\":59,\"022a9\":59,\"022aa\":59,\"022ab\":59,\"022ac\":59,\"022ad\":59,\"022ae\":59,\"022af\":59,\"022b0\":59,\"022b1\":59,\"022b2\":59,\"022b3\":59,\"022b4\":59,\"022b5\":59,\"022b6\":59,\"022b7\":59,\"022b8\":59,\"022b9\":59,\"022ba\":59,\"022bb\":59,\"022bc\":59,\"022bd\":59,\"022be\":59,\"022bf\":59,\"022c0\":59,\"022c1\":59,\"022c2\":59,\"022c3\":59,\"022c4\":59,\"022c5\":59,\"022c6\":59,\"022c7\":59,\"022c8\":59,\"022c9\":59,\"022ca\":59,\"022cb\":59,\"022cc\":59,\"022cd\":59,\"022ce\":59,\"022cf\":59,\"022d0\":59,\"022d1\":59,\"022d2\":59,\"022d3\":59,\"022d4\":59,\"022d5\":59,\"022d6\":59,\"022d7\":59,\"022d8\":59,\"022d9\":59,\"022da\":59,\"022db\":59,\"022dc\":59,\"022dd\":59,\"022de\":59,\"022df\":59,\"022e0\":59,\"022e1\":59,\"022e2\":59,\"022e3\":59,\"022e4\":59,\"022e5\":59,\"022e6\":59,\"022e7\":59,\"022e8\":59,\"022e9\":59,\"022ea\":59,\"022eb\":59,\"022ec\":59,\"022ed\":59,\"022ee\":59,\"022ef\":59,\"022f0\":59,\"022f1\":59,\"022f2\":59,\"022f3\":59,\"022f4\":59,\"022f5\":59,\"022f6\":59,\"022f7\":59,\"022f8\":59,\"022f9\":59,\"022fa\":59,\"022fb\":59,\"022fc\":59,\"022fd\":59,\"022fe\":59,\"022ff\":59,\"0230a\":59,\"0230b\":59,\"0231a\":59,\"0231b\":59,\"0231c\":59,\"0231d\":59,\"0231e\":59,\"0231f\":59,\"0232c\":59,\"0233d\":59,\"0233f\":59,\"023a3\":59,\"023b0\":59,\"023b1\":59,\"023b4\":59,\"023b5\":59,\"023b6\":59,\"023b7\":59,\"023b8\":59,\"023b9\":59,\"023ce\":59,\"023de\":59,\"023df\":59,\"023e2\":59,\"023e3\":59,\"023e4\":59,\"023e5\":59,\"023e6\":59,\"023e7\":59,\"023e9\":59,\"023ea\":59,\"023eb\":59,\"023ec\":59,\"023f0\":59,\"023f3\":59,\"024c2\":59,\"024c8\":59,\"0258c\":59,\"025a0\":59,\"025a1\":59,\"025a2\":59,\"025a3\":59,\"025a4\":59,\"025a5\":59,\"025a6\":59,\"025a7\":59,\"025a8\":59,\"025a9\":59,\"025aa\":59,\"025ab\":59,\"025ac\":59,\"025ad\":59,\"025ae\":59,\"025af\":59,\"025b0\":59,\"025b1\":59,\"025b2\":59,\"025b3\":59,\"025b4\":59,\"025b5\":59,\"025b6\":59,\"025b7\":59,\"025b8\":59,\"025b9\":59,\"025ba\":59,\"025bb\":59,\"025bc\":59,\"025bd\":59,\"025be\":59,\"025bf\":59,\"025c0\":59,\"025c1\":59,\"025c2\":59,\"025c3\":59,\"025c4\":59,\"025c5\":59,\"025c6\":59,\"025c7\":59,\"025c8\":59,\"025c9\":59,\"025ca\":59,\"025cb\":59,\"025cc\":59,\"025cd\":59,\"025ce\":59,\"025cf\":59,\"025d0\":59,\"025d1\":59,\"025d2\":59,\"025d3\":59,\"025d4\":59,\"025d5\":59,\"025d6\":59,\"025d7\":59,\"025d8\":59,\"025d9\":59,\"025da\":59,\"025db\":59,\"025dc\":59,\"025dd\":59,\"025de\":59,\"025df\":59,\"025e0\":59,\"025e1\":59,\"025e2\":59,\"025e3\":59,\"025e4\":59,\"025e5\":59,\"025e6\":59,\"025e7\":59,\"025e8\":59,\"025e9\":59,\"025ea\":59,\"025eb\":59,\"025ec\":59,\"025ed\":59,\"025ee\":59,\"025ef\":59,\"025f0\":59,\"025f1\":59,\"025f2\":59,\"025f3\":59,\"025f4\":59,\"025f5\":59,\"025f6\":59,\"025f7\":59,\"025f8\":59,\"025f9\":59,\"025fa\":59,\"025fb\":59,\"025fc\":59,\"025fd\":59,\"025fe\":59,\"025ff\":59,\"0260e\":59,\"0261d\":59,\"0263a\":59,\"0263b\":59,\"0263c\":59,\"0263d\":59,\"0263e\":59,\"0263f\":59,\"0264a\":59,\"0264b\":59,\"0264c\":59,\"0264d\":59,\"0264e\":59,\"0264f\":59,\"0266a\":59,\"0266b\":59,\"0266d\":59,\"0266e\":59,\"0266f\":59,\"0267b\":59,\"0267e\":59,\"0267f\":59,\"026a0\":59,\"026a1\":59,\"026a5\":59,\"026aa\":59,\"026ab\":59,\"026ac\":59,\"026b2\":59,\"026bd\":59,\"026be\":59,\"026c4\":59,\"026c5\":59,\"026ce\":59,\"026d4\":59,\"026ea\":59,\"026f2\":59,\"026f3\":59,\"026f5\":59,\"026fa\":59,\"026fd\":59,\"0270a\":59,\"0270b\":59,\"0270c\":59,\"0270f\":59,\"0272a\":59,\"0273d\":59,\"0274c\":59,\"0274e\":59,\"0279b\":59,\"027a1\":59,\"027b0\":59,\"027bf\":59,\"027c0\":59,\"027c1\":59,\"027c2\":59,\"027c8\":59,\"027c9\":59,\"027d1\":59,\"027d2\":59,\"027d5\":59,\"027d6\":59,\"027d7\":59,\"027d8\":59,\"027d9\":59,\"027e6\":59,\"027e7\":59,\"027e8\":59,\"027e9\":59,\"027f0\":59,\"027f1\":59,\"027f5\":59,\"027f6\":59,\"027f7\":59,\"027f8\":59,\"027f9\":59,\"027fa\":59,\"027fb\":59,\"027fc\":59,\"027fd\":59,\"027fe\":59,\"027ff\":59,\"0290a\":59,\"0290b\":59,\"0290c\":59,\"0290d\":59,\"0290e\":59,\"0290f\":59,\"0291d\":59,\"0291e\":59,\"0291f\":59,\"0292a\":59,\"0292b\":59,\"0292c\":59,\"0292d\":59,\"0292e\":59,\"0292f\":59,\"0294a\":59,\"0294b\":59,\"0294c\":59,\"0294d\":59,\"0294e\":59,\"0294f\":59,\"0295a\":59,\"0295b\":59,\"0295c\":59,\"0295d\":59,\"0295e\":59,\"0295f\":59,\"0296a\":59,\"0296b\":59,\"0296c\":59,\"0296d\":59,\"0296e\":59,\"0296f\":59,\"0299b\":59,\"0299c\":59,\"0299d\":59,\"0299e\":59,\"0299f\":59,\"029a0\":59,\"029a1\":59,\"029a2\":59,\"029a3\":59,\"029a4\":59,\"029a5\":59,\"029a6\":59,\"029a7\":59,\"029a8\":59,\"029a9\":59,\"029aa\":59,\"029ab\":59,\"029ac\":59,\"029ad\":59,\"029ae\":59,\"029af\":59,\"029b0\":59,\"029b1\":59,\"029b2\":59,\"029b3\":59,\"029b4\":59,\"029b7\":59,\"029b8\":59,\"029bc\":59,\"029be\":59,\"029bf\":59,\"029c0\":59,\"029c1\":59,\"029c4\":59,\"029c5\":59,\"029c6\":59,\"029c7\":59,\"029ca\":59,\"029cb\":59,\"029cf\":59,\"029d0\":59,\"029df\":59,\"029e1\":59,\"029e2\":59,\"029e3\":59,\"029e4\":59,\"029e5\":59,\"029eb\":59,\"029f4\":59,\"029f6\":59,\"029f7\":59,\"029fa\":59,\"029fb\":59,\"02a00\":59,\"02a01\":59,\"02a02\":59,\"02a03\":59,\"02a04\":59,\"02a05\":59,\"02a06\":59,\"02a07\":59,\"02a08\":59,\"02a09\":59,\"02a0a\":59,\"02a0b\":59,\"02a0c\":59,\"02a0d\":59,\"02a0e\":59,\"02a0f\":59,\"02a10\":59,\"02a11\":59,\"02a12\":59,\"02a13\":59,\"02a14\":59,\"02a15\":59,\"02a16\":59,\"02a18\":59,\"02a19\":59,\"02a1a\":59,\"02a1b\":59,\"02a1c\":59,\"02a1d\":59,\"02a22\":59,\"02a23\":59,\"02a24\":59,\"02a25\":59,\"02a26\":59,\"02a27\":59,\"02a28\":59,\"02a29\":59,\"02a2a\":59,\"02a2b\":59,\"02a2c\":59,\"02a2d\":59,\"02a2e\":59,\"02a2f\":59,\"02a30\":59,\"02a31\":59,\"02a32\":59,\"02a33\":59,\"02a34\":59,\"02a35\":59,\"02a36\":59,\"02a37\":59,\"02a38\":59,\"02a39\":59,\"02a3a\":59,\"02a3b\":59,\"02a3c\":59,\"02a3d\":59,\"02a3f\":59,\"02a40\":59,\"02a41\":59,\"02a42\":59,\"02a43\":59,\"02a44\":59,\"02a45\":59,\"02a4a\":59,\"02a4b\":59,\"02a4c\":59,\"02a4d\":59,\"02a4e\":59,\"02a4f\":59,\"02a50\":59,\"02a51\":59,\"02a52\":59,\"02a53\":59,\"02a54\":59,\"02a55\":59,\"02a56\":59,\"02a57\":59,\"02a58\":59,\"02a5a\":59,\"02a5b\":59,\"02a5c\":59,\"02a5d\":59,\"02a5e\":59,\"02a5f\":59,\"02a60\":59,\"02a61\":59,\"02a62\":59,\"02a63\":59,\"02a66\":59,\"02a67\":59,\"02a6a\":59,\"02a6b\":59,\"02a6c\":59,\"02a6d\":59,\"02a6e\":59,\"02a6f\":59,\"02a70\":59,\"02a71\":59,\"02a72\":59,\"02a73\":59,\"02a74\":59,\"02a75\":59,\"02a76\":59,\"02a77\":59,\"02a78\":59,\"02a79\":59,\"02a7a\":59,\"02a7b\":59,\"02a7c\":59,\"02a7d\":59,\"02a7e\":59,\"02a7f\":59,\"02a80\":59,\"02a81\":59,\"02a82\":59,\"02a83\":59,\"02a84\":59,\"02a85\":59,\"02a86\":59,\"02a87\":59,\"02a88\":59,\"02a89\":59,\"02a8a\":59,\"02a8b\":59,\"02a8c\":59,\"02a8d\":59,\"02a8e\":59,\"02a8f\":59,\"02a90\":59,\"02a91\":59,\"02a92\":59,\"02a93\":59,\"02a94\":59,\"02a95\":59,\"02a96\":59,\"02a97\":59,\"02a98\":59,\"02a99\":59,\"02a9a\":59,\"02a9b\":59,\"02a9c\":59,\"02a9d\":59,\"02a9e\":59,\"02a9f\":59,\"02aa0\":59,\"02aa1\":59,\"02aa2\":59,\"02aa3\":59,\"02aa4\":59,\"02aa5\":59,\"02aa6\":59,\"02aa7\":59,\"02aa8\":59,\"02aa9\":59,\"02aaa\":59,\"02aab\":59,\"02aac\":59,\"02aad\":59,\"02aae\":59,\"02aaf\":59,\"02ab0\":59,\"02ab1\":59,\"02ab2\":59,\"02ab3\":59,\"02ab4\":59,\"02ab5\":59,\"02ab6\":59,\"02ab7\":59,\"02ab8\":59,\"02ab9\":59,\"02aba\":59,\"02abb\":59,\"02abc\":59,\"02abd\":59,\"02abe\":59,\"02abf\":59,\"02ac0\":59,\"02ac1\":59,\"02ac2\":59,\"02ac3\":59,\"02ac4\":59,\"02ac5\":59,\"02ac6\":59,\"02ac7\":59,\"02ac8\":59,\"02ac9\":59,\"02aca\":59,\"02acb\":59,\"02acc\":59,\"02acd\":59,\"02ace\":59,\"02acf\":59,\"02ad0\":59,\"02ad1\":59,\"02ad2\":59,\"02ad3\":59,\"02ad4\":59,\"02ad5\":59,\"02ad6\":59,\"02ad7\":59,\"02ad8\":59,\"02ad9\":59,\"02adb\":59,\"02adc\":59,\"02add\":59,\"02ae3\":59,\"02ae4\":59,\"02af4\":59,\"02af6\":59,\"02af7\":59,\"02af8\":59,\"02af9\":59,\"02afa\":59,\"02b05\":59,\"02b06\":59,\"02b07\":59,\"02b12\":59,\"02b13\":59,\"02b14\":59,\"02b15\":59,\"02b16\":59,\"02b17\":59,\"02b18\":59,\"02b19\":59,\"02b1a\":59,\"02b1b\":59,\"02b1c\":59,\"02b1d\":59,\"02b1e\":59,\"02b1f\":59,\"02b20\":59,\"02b21\":59,\"02b22\":59,\"02b23\":59,\"02b24\":59,\"02b25\":59,\"02b26\":59,\"02b27\":59,\"02b28\":59,\"02b29\":59,\"02b2a\":59,\"02b2b\":59,\"02b2c\":59,\"02b2d\":59,\"02b2e\":59,\"02b2f\":59,\"02b30\":59,\"02b31\":59,\"02b32\":59,\"02b33\":59,\"02b34\":59,\"02b35\":59,\"02b36\":59,\"02b37\":59,\"02b38\":59,\"02b39\":59,\"02b3a\":59,\"02b3b\":59,\"02b3c\":59,\"02b3d\":59,\"02b3e\":59,\"02b3f\":59,\"02b40\":59,\"02b41\":59,\"02b42\":59,\"02b43\":59,\"02b44\":59,\"02b45\":59,\"02b46\":59,\"02b47\":59,\"02b48\":59,\"02b49\":59,\"02b4a\":59,\"02b4b\":59,\"02b4c\":59,\"02b50\":59,\"02b51\":59,\"02b52\":59,\"02b53\":59,\"02b54\":59,\"02b55\":59,\"02c7c\":59,\"02c7d\":59,\"0303d\":59,\"03t00\":31,\"0518977991518im\":27,\"06t00\":68,\"07t00\":[31,68],\"08708053414102428im\":27,\"0b10\":39,\"0b1011_0010\":39,\"0e10\":39,\"0f0\":[39,49,52],\"0fe00\":59,\"0im\":[27,29,30,34,58,74],\"0mq\":51,\"0o10\":39,\"0o777\":69,\"0x0\":49,\"0x00\":[48,49],\"0x000\":49,\"0x0000\":49,\"0x0000000000000000\":64,\"0x0000000000000008\":64,\"0x0000000000000010\":64,\"0x0000000000000018\":64,\"0x0000000000000020\":64,\"0x0000000000000028\":64,\"0x0000000000000030\":64,\"0x0000000000000038\":64,\"0x0000000000000040\":64,\"0x0000000000000048\":64,\"0x0000000000000050\":64,\"0x0000000000000058\":64,\"0x00000001009e9620\":55,\"0x00000001009e9635\":55,\"0x00000001009f64e7\":55,\"0x00000001009fc7b6\":55,\"0x00000001009fdae3\":55,\"0x00000001009fe0d2\":55,\"0x00000001009fe1e8\":55,\"0x0000000100a06418\":55,\"0x0000000100a1321b\":55,\"0x0000000100a26fc2\":55,\"0x000000010265ac5d\":55,\"0x000000010265acc1\":55,\"0x00000001029435df\":55,\"0x0000000102943635\":55,\"0x000000031006feec\":55,\"0x00000003100701b0\":55,\"0x000000031007744b\":55,\"0x0000000310077537\":55,\"0x00007f418d0816b8\":26,\"0x00007f5998a04370\":21,\"0x00007f5998a570d0\":21,\"0x00007fcc7de64850\":21,\"0x00007fcc80c4d930\":21,\"0x00007fd31dc11870\":48,\"0x00007fd31dc11ae0\":48,\"0x00007fd31dc12e60\":48,\"0x00007ffde56bd01a\":6,\"0x00007fff5fbffc45\":26,\"0x00007ffff6541154\":6,\"0x00007ffff65412fe\":6,\"0x00007ffff7928bf7\":6,\"0x000f\":49,\"0x01\":[39,44],\"0x01020304\":71,\"0x0123\":39,\"0x01234567\":39,\"0x0123456789abcdef\":39,\"0x02\":39,\"0x04030201\":71,\"0x08\":39,\"0x0c\":30,\"0x1\":39,\"0x10265acc1\":55,\"0x102943635\":55,\"0x110000\":56,\"0x123\":39,\"0x1234567\":39,\"0x123456789abcdef\":39,\"0x1289d070\":6,\"0x1p0\":39,\"0x2812060\":6,\"0x3100701b0\":55,\"0x310077537\":55,\"0x41\":56,\"0x44\":56,\"0x54\":56,\"0x61\":48,\"0x62\":48,\"0x63\":48,\"0x64\":48,\"0x7ffde56be000\":6,\"0x7ffdf35e8010\":21,\"0x7ffdf367f630\":6,\"0x7ffdf39b1030\":6,\"0x7ffdf42de400\":6,\"0x7ffdf7409150\":21,\"0x7ffdf74091b0\":21,\"0x7ffdf74d7a90\":21,\"0x7ffdf74d7af0\":21,\"0x7ffff6dcb07d\":21,\"0x7fffffffc2b0\":6,\"0x7fffffffcc70\":21,\"0x7fffffffcc90\":21,\"0x80\":56,\"0x84\":44,\"0x88\":56,\"0xb2\":39,\"0xbf\":56,\"0xc3\":56,\"0xdead_beef\":39,\"0xdeadbeef\":39,\"0xe2\":56,\"0xf\":49,\"0xf0\":49,\"0xff\":[39,56],\"0xfff0\":49,\"0xffffff84\":44,\"0xfffffffffffffffff\":1,\"1000x\":6,\"10_000\":39,\"10ffff\":56,\"1368683772161603e\":39,\"13ghz\":2,\"13t00\":[31,68],\"15im\":27,\"15t00\":68,\"17t08\":31,\"17t12\":31,\"18425e\":63,\"1920929f\":39,\"1995y01m\":68,\"1996y01m\":68,\"1d400\":59,\"1d401\":59,\"1d402\":59,\"1d403\":59,\"1d404\":59,\"1d405\":59,\"1d406\":59,\"1d407\":59,\"1d408\":59,\"1d409\":59,\"1d40a\":59,\"1d40b\":59,\"1d40c\":59,\"1d40d\":59,\"1d40e\":59,\"1d40f\":59,\"1d410\":59,\"1d411\":59,\"1d412\":59,\"1d413\":59,\"1d414\":59,\"1d415\":59,\"1d416\":59,\"1d417\":59,\"1d418\":59,\"1d419\":59,\"1d41a\":59,\"1d41b\":59,\"1d41c\":59,\"1d41d\":59,\"1d41e\":59,\"1d41f\":59,\"1d420\":59,\"1d421\":59,\"1d422\":59,\"1d423\":59,\"1d424\":59,\"1d425\":59,\"1d426\":59,\"1d427\":59,\"1d428\":59,\"1d429\":59,\"1d42a\":59,\"1d42b\":59,\"1d42c\":59,\"1d42d\":59,\"1d42e\":59,\"1d42f\":59,\"1d430\":59,\"1d431\":59,\"1d432\":59,\"1d433\":59,\"1d434\":59,\"1d435\":59,\"1d436\":59,\"1d437\":59,\"1d438\":59,\"1d439\":59,\"1d43a\":59,\"1d43b\":59,\"1d43c\":59,\"1d43d\":59,\"1d43e\":59,\"1d43f\":59,\"1d440\":59,\"1d441\":59,\"1d442\":59,\"1d443\":59,\"1d444\":59,\"1d445\":59,\"1d446\":59,\"1d447\":59,\"1d448\":59,\"1d449\":59,\"1d44a\":59,\"1d44b\":59,\"1d44c\":59,\"1d44d\":59,\"1d44e\":59,\"1d44f\":59,\"1d450\":59,\"1d451\":59,\"1d452\":59,\"1d453\":59,\"1d454\":59,\"1d456\":59,\"1d457\":59,\"1d458\":59,\"1d459\":59,\"1d45a\":59,\"1d45b\":59,\"1d45c\":59,\"1d45d\":59,\"1d45e\":59,\"1d45f\":59,\"1d460\":59,\"1d461\":59,\"1d462\":59,\"1d463\":59,\"1d464\":59,\"1d465\":59,\"1d466\":59,\"1d467\":59,\"1d468\":59,\"1d469\":59,\"1d46a\":59,\"1d46b\":59,\"1d46c\":59,\"1d46d\":59,\"1d46e\":59,\"1d46f\":59,\"1d470\":59,\"1d471\":59,\"1d472\":59,\"1d473\":59,\"1d474\":59,\"1d475\":59,\"1d476\":59,\"1d477\":59,\"1d478\":59,\"1d479\":59,\"1d47a\":59,\"1d47b\":59,\"1d47c\":59,\"1d47d\":59,\"1d47e\":59,\"1d47f\":59,\"1d480\":59,\"1d481\":59,\"1d482\":59,\"1d483\":59,\"1d484\":59,\"1d485\":59,\"1d486\":59,\"1d487\":59,\"1d488\":59,\"1d489\":59,\"1d48a\":59,\"1d48b\":59,\"1d48c\":59,\"1d48d\":59,\"1d48e\":59,\"1d48f\":59,\"1d490\":59,\"1d491\":59,\"1d492\":59,\"1d493\":59,\"1d494\":59,\"1d495\":59,\"1d496\":59,\"1d497\":59,\"1d498\":59,\"1d499\":59,\"1d49a\":59,\"1d49b\":59,\"1d49c\":59,\"1d49e\":59,\"1d49f\":59,\"1d4a2\":59,\"1d4a5\":59,\"1d4a6\":59,\"1d4a9\":59,\"1d4aa\":59,\"1d4ab\":59,\"1d4ac\":59,\"1d4ae\":59,\"1d4af\":59,\"1d4b0\":59,\"1d4b1\":59,\"1d4b2\":59,\"1d4b3\":59,\"1d4b4\":59,\"1d4b5\":59,\"1d4b6\":59,\"1d4b7\":59,\"1d4b8\":59,\"1d4b9\":59,\"1d4bb\":59,\"1d4bd\":59,\"1d4be\":59,\"1d4bf\":59,\"1d4c0\":59,\"1d4c1\":59,\"1d4c2\":59,\"1d4c3\":59,\"1d4c5\":59,\"1d4c6\":59,\"1d4c7\":59,\"1d4c8\":59,\"1d4c9\":59,\"1d4ca\":59,\"1d4cb\":59,\"1d4cc\":59,\"1d4cd\":59,\"1d4ce\":59,\"1d4cf\":59,\"1d4d0\":59,\"1d4d1\":59,\"1d4d2\":59,\"1d4d3\":59,\"1d4d4\":59,\"1d4d5\":59,\"1d4d6\":59,\"1d4d7\":59,\"1d4d8\":59,\"1d4d9\":59,\"1d4da\":59,\"1d4db\":59,\"1d4dc\":59,\"1d4dd\":59,\"1d4de\":59,\"1d4df\":59,\"1d4e0\":59,\"1d4e1\":59,\"1d4e2\":59,\"1d4e3\":59,\"1d4e4\":59,\"1d4e5\":59,\"1d4e6\":59,\"1d4e7\":59,\"1d4e8\":59,\"1d4e9\":59,\"1d4ea\":59,\"1d4eb\":59,\"1d4ec\":59,\"1d4ed\":59,\"1d4ee\":59,\"1d4ef\":59,\"1d4f0\":59,\"1d4f1\":59,\"1d4f2\":59,\"1d4f3\":59,\"1d4f4\":59,\"1d4f5\":59,\"1d4f6\":59,\"1d4f7\":59,\"1d4f8\":59,\"1d4f9\":59,\"1d4fa\":59,\"1d4fb\":59,\"1d4fc\":59,\"1d4fd\":59,\"1d4fe\":59,\"1d4ff\":59,\"1d500\":59,\"1d501\":59,\"1d502\":59,\"1d503\":59,\"1d504\":59,\"1d505\":59,\"1d507\":59,\"1d508\":59,\"1d509\":59,\"1d50a\":59,\"1d50d\":59,\"1d50e\":59,\"1d50f\":59,\"1d510\":59,\"1d511\":59,\"1d512\":59,\"1d513\":59,\"1d514\":59,\"1d516\":59,\"1d517\":59,\"1d518\":59,\"1d519\":59,\"1d51a\":59,\"1d51b\":59,\"1d51c\":59,\"1d51e\":59,\"1d51f\":59,\"1d520\":59,\"1d521\":59,\"1d522\":59,\"1d523\":59,\"1d524\":59,\"1d525\":59,\"1d526\":59,\"1d527\":59,\"1d528\":59,\"1d529\":59,\"1d52a\":59,\"1d52b\":59,\"1d52c\":59,\"1d52d\":59,\"1d52e\":59,\"1d52f\":59,\"1d530\":59,\"1d531\":59,\"1d532\":59,\"1d533\":59,\"1d534\":59,\"1d535\":59,\"1d536\":59,\"1d537\":59,\"1d538\":59,\"1d539\":59,\"1d53b\":59,\"1d53c\":59,\"1d53d\":59,\"1d53e\":59,\"1d540\":59,\"1d541\":59,\"1d542\":59,\"1d543\":59,\"1d544\":59,\"1d546\":59,\"1d54a\":59,\"1d54b\":59,\"1d54c\":59,\"1d54d\":59,\"1d54e\":59,\"1d54f\":59,\"1d550\":59,\"1d552\":59,\"1d553\":59,\"1d554\":59,\"1d555\":59,\"1d556\":59,\"1d557\":59,\"1d558\":59,\"1d559\":59,\"1d55a\":59,\"1d55b\":59,\"1d55c\":59,\"1d55d\":59,\"1d55e\":59,\"1d55f\":59,\"1d560\":59,\"1d561\":59,\"1d562\":59,\"1d563\":59,\"1d564\":59,\"1d565\":59,\"1d566\":59,\"1d567\":59,\"1d568\":59,\"1d569\":59,\"1d56a\":59,\"1d56b\":59,\"1d56c\":59,\"1d56d\":59,\"1d56e\":59,\"1d56f\":59,\"1d570\":59,\"1d571\":59,\"1d572\":59,\"1d573\":59,\"1d574\":59,\"1d575\":59,\"1d576\":59,\"1d577\":59,\"1d578\":59,\"1d579\":59,\"1d57a\":59,\"1d57b\":59,\"1d57c\":59,\"1d57d\":59,\"1d57e\":59,\"1d57f\":59,\"1d580\":59,\"1d581\":59,\"1d582\":59,\"1d583\":59,\"1d584\":59,\"1d585\":59,\"1d586\":59,\"1d587\":59,\"1d588\":59,\"1d589\":59,\"1d58a\":59,\"1d58b\":59,\"1d58c\":59,\"1d58d\":59,\"1d58e\":59,\"1d58f\":59,\"1d590\":59,\"1d591\":59,\"1d592\":59,\"1d593\":59,\"1d594\":59,\"1d595\":59,\"1d596\":59,\"1d597\":59,\"1d598\":59,\"1d599\":59,\"1d59a\":59,\"1d59b\":59,\"1d59c\":59,\"1d59d\":59,\"1d59e\":59,\"1d59f\":59,\"1d5a0\":59,\"1d5a1\":59,\"1d5a2\":59,\"1d5a3\":59,\"1d5a4\":59,\"1d5a5\":59,\"1d5a6\":59,\"1d5a7\":59,\"1d5a8\":59,\"1d5a9\":59,\"1d5aa\":59,\"1d5ab\":59,\"1d5ac\":59,\"1d5ad\":59,\"1d5ae\":59,\"1d5af\":59,\"1d5b0\":59,\"1d5b1\":59,\"1d5b2\":59,\"1d5b3\":59,\"1d5b4\":59,\"1d5b5\":59,\"1d5b6\":59,\"1d5b7\":59,\"1d5b8\":59,\"1d5b9\":59,\"1d5ba\":59,\"1d5bb\":59,\"1d5bc\":59,\"1d5bd\":59,\"1d5be\":59,\"1d5bf\":59,\"1d5c0\":59,\"1d5c1\":59,\"1d5c2\":59,\"1d5c3\":59,\"1d5c4\":59,\"1d5c5\":59,\"1d5c6\":59,\"1d5c7\":59,\"1d5c8\":59,\"1d5c9\":59,\"1d5ca\":59,\"1d5cb\":59,\"1d5cc\":59,\"1d5cd\":59,\"1d5ce\":59,\"1d5cf\":59,\"1d5d0\":59,\"1d5d1\":59,\"1d5d2\":59,\"1d5d3\":59,\"1d5d4\":59,\"1d5d5\":59,\"1d5d6\":59,\"1d5d7\":59,\"1d5d8\":59,\"1d5d9\":59,\"1d5da\":59,\"1d5db\":59,\"1d5dc\":59,\"1d5dd\":59,\"1d5de\":59,\"1d5df\":59,\"1d5e0\":59,\"1d5e1\":59,\"1d5e2\":59,\"1d5e3\":59,\"1d5e4\":59,\"1d5e5\":59,\"1d5e6\":59,\"1d5e7\":59,\"1d5e8\":59,\"1d5e9\":59,\"1d5ea\":59,\"1d5eb\":59,\"1d5ec\":59,\"1d5ed\":59,\"1d5ee\":59,\"1d5ef\":59,\"1d5f0\":59,\"1d5f1\":59,\"1d5f2\":59,\"1d5f3\":59,\"1d5f4\":59,\"1d5f5\":59,\"1d5f6\":59,\"1d5f7\":59,\"1d5f8\":59,\"1d5f9\":59,\"1d5fa\":59,\"1d5fb\":59,\"1d5fc\":59,\"1d5fd\":59,\"1d5fe\":59,\"1d5ff\":59,\"1d600\":59,\"1d601\":59,\"1d602\":59,\"1d603\":59,\"1d604\":59,\"1d605\":59,\"1d606\":59,\"1d607\":59,\"1d608\":59,\"1d609\":59,\"1d60a\":59,\"1d60b\":59,\"1d60c\":59,\"1d60d\":59,\"1d60e\":59,\"1d60f\":59,\"1d610\":59,\"1d611\":59,\"1d612\":59,\"1d613\":59,\"1d614\":59,\"1d615\":59,\"1d616\":59,\"1d617\":59,\"1d618\":59,\"1d619\":59,\"1d61a\":59,\"1d61b\":59,\"1d61c\":59,\"1d61d\":59,\"1d61e\":59,\"1d61f\":59,\"1d620\":59,\"1d621\":59,\"1d622\":59,\"1d623\":59,\"1d624\":59,\"1d625\":59,\"1d626\":59,\"1d627\":59,\"1d628\":59,\"1d629\":59,\"1d62a\":59,\"1d62b\":59,\"1d62c\":59,\"1d62d\":59,\"1d62e\":59,\"1d62f\":59,\"1d630\":59,\"1d631\":59,\"1d632\":59,\"1d633\":59,\"1d634\":59,\"1d635\":59,\"1d636\":59,\"1d637\":59,\"1d638\":59,\"1d639\":59,\"1d63a\":59,\"1d63b\":59,\"1d63c\":59,\"1d63d\":59,\"1d63e\":59,\"1d63f\":59,\"1d640\":59,\"1d641\":59,\"1d642\":59,\"1d643\":59,\"1d644\":59,\"1d645\":59,\"1d646\":59,\"1d647\":59,\"1d648\":59,\"1d649\":59,\"1d64a\":59,\"1d64b\":59,\"1d64c\":59,\"1d64d\":59,\"1d64e\":59,\"1d64f\":59,\"1d650\":59,\"1d651\":59,\"1d652\":59,\"1d653\":59,\"1d654\":59,\"1d655\":59,\"1d656\":59,\"1d657\":59,\"1d658\":59,\"1d659\":59,\"1d65a\":59,\"1d65b\":59,\"1d65c\":59,\"1d65d\":59,\"1d65e\":59,\"1d65f\":59,\"1d660\":59,\"1d661\":59,\"1d662\":59,\"1d663\":59,\"1d664\":59,\"1d665\":59,\"1d666\":59,\"1d667\":59,\"1d668\":59,\"1d669\":59,\"1d66a\":59,\"1d66b\":59,\"1d66c\":59,\"1d66d\":59,\"1d66e\":59,\"1d66f\":59,\"1d670\":59,\"1d671\":59,\"1d672\":59,\"1d673\":59,\"1d674\":59,\"1d675\":59,\"1d676\":59,\"1d677\":59,\"1d678\":59,\"1d679\":59,\"1d67a\":59,\"1d67b\":59,\"1d67c\":59,\"1d67d\":59,\"1d67e\":59,\"1d67f\":59,\"1d680\":59,\"1d681\":59,\"1d682\":59,\"1d683\":59,\"1d684\":59,\"1d685\":59,\"1d686\":59,\"1d687\":59,\"1d688\":59,\"1d689\":59,\"1d68a\":59,\"1d68b\":59,\"1d68c\":59,\"1d68d\":59,\"1d68e\":59,\"1d68f\":59,\"1d690\":59,\"1d691\":59,\"1d692\":59,\"1d693\":59,\"1d694\":59,\"1d695\":59,\"1d696\":59,\"1d697\":59,\"1d698\":59,\"1d699\":59,\"1d69a\":59,\"1d69b\":59,\"1d69c\":59,\"1d69d\":59,\"1d69e\":59,\"1d69f\":59,\"1d6a0\":59,\"1d6a1\":59,\"1d6a2\":59,\"1d6a3\":59,\"1d6a4\":59,\"1d6a5\":59,\"1d6a8\":59,\"1d6a9\":59,\"1d6aa\":59,\"1d6ab\":59,\"1d6ac\":59,\"1d6ad\":59,\"1d6ae\":59,\"1d6af\":59,\"1d6b0\":59,\"1d6b1\":59,\"1d6b2\":59,\"1d6b3\":59,\"1d6b4\":59,\"1d6b5\":59,\"1d6b6\":59,\"1d6b7\":59,\"1d6b8\":59,\"1d6b9\":59,\"1d6ba\":59,\"1d6bb\":59,\"1d6bc\":59,\"1d6bd\":59,\"1d6be\":59,\"1d6bf\":59,\"1d6c0\":59,\"1d6c1\":59,\"1d6c2\":59,\"1d6c3\":59,\"1d6c4\":59,\"1d6c5\":59,\"1d6c6\":59,\"1d6c7\":59,\"1d6c8\":59,\"1d6c9\":59,\"1d6ca\":59,\"1d6cb\":59,\"1d6cc\":59,\"1d6cd\":59,\"1d6ce\":59,\"1d6cf\":59,\"1d6d0\":59,\"1d6d1\":59,\"1d6d2\":59,\"1d6d3\":59,\"1d6d4\":59,\"1d6d5\":59,\"1d6d6\":59,\"1d6d7\":59,\"1d6d8\":59,\"1d6d9\":59,\"1d6da\":59,\"1d6db\":59,\"1d6dc\":59,\"1d6dd\":59,\"1d6de\":59,\"1d6df\":59,\"1d6e0\":59,\"1d6e1\":59,\"1d6e2\":59,\"1d6e3\":59,\"1d6e4\":59,\"1d6e5\":59,\"1d6e6\":59,\"1d6e7\":59,\"1d6e8\":59,\"1d6e9\":59,\"1d6ea\":59,\"1d6eb\":59,\"1d6ec\":59,\"1d6ed\":59,\"1d6ee\":59,\"1d6ef\":59,\"1d6f0\":59,\"1d6f1\":59,\"1d6f2\":59,\"1d6f3\":59,\"1d6f4\":59,\"1d6f5\":59,\"1d6f6\":59,\"1d6f7\":59,\"1d6f8\":59,\"1d6f9\":59,\"1d6fa\":59,\"1d6fb\":59,\"1d6fc\":59,\"1d6fd\":59,\"1d6fe\":59,\"1d6ff\":59,\"1d700\":59,\"1d701\":59,\"1d702\":59,\"1d703\":59,\"1d704\":59,\"1d705\":59,\"1d706\":59,\"1d707\":59,\"1d708\":59,\"1d709\":59,\"1d70a\":59,\"1d70b\":59,\"1d70c\":59,\"1d70d\":59,\"1d70e\":59,\"1d70f\":59,\"1d710\":59,\"1d711\":59,\"1d712\":59,\"1d713\":59,\"1d714\":59,\"1d715\":59,\"1d716\":59,\"1d717\":59,\"1d718\":59,\"1d719\":59,\"1d71a\":59,\"1d71b\":59,\"1d71c\":59,\"1d71d\":59,\"1d71e\":59,\"1d71f\":59,\"1d720\":59,\"1d721\":59,\"1d722\":59,\"1d723\":59,\"1d724\":59,\"1d725\":59,\"1d726\":59,\"1d727\":59,\"1d728\":59,\"1d729\":59,\"1d72a\":59,\"1d72b\":59,\"1d72c\":59,\"1d72d\":59,\"1d72e\":59,\"1d72f\":59,\"1d730\":59,\"1d731\":59,\"1d732\":59,\"1d733\":59,\"1d734\":59,\"1d735\":59,\"1d736\":59,\"1d737\":59,\"1d738\":59,\"1d739\":59,\"1d73a\":59,\"1d73b\":59,\"1d73c\":59,\"1d73d\":59,\"1d73e\":59,\"1d73f\":59,\"1d740\":59,\"1d741\":59,\"1d742\":59,\"1d743\":59,\"1d744\":59,\"1d745\":59,\"1d746\":59,\"1d747\":59,\"1d748\":59,\"1d749\":59,\"1d74a\":59,\"1d74b\":59,\"1d74c\":59,\"1d74d\":59,\"1d74e\":59,\"1d74f\":59,\"1d750\":59,\"1d751\":59,\"1d752\":59,\"1d753\":59,\"1d754\":59,\"1d755\":59,\"1d756\":59,\"1d757\":59,\"1d758\":59,\"1d759\":59,\"1d75a\":59,\"1d75b\":59,\"1d75c\":59,\"1d75d\":59,\"1d75e\":59,\"1d75f\":59,\"1d760\":59,\"1d761\":59,\"1d762\":59,\"1d763\":59,\"1d764\":59,\"1d765\":59,\"1d766\":59,\"1d767\":59,\"1d768\":59,\"1d769\":59,\"1d76a\":59,\"1d76b\":59,\"1d76c\":59,\"1d76d\":59,\"1d76e\":59,\"1d76f\":59,\"1d770\":59,\"1d771\":59,\"1d772\":59,\"1d773\":59,\"1d774\":59,\"1d775\":59,\"1d776\":59,\"1d777\":59,\"1d778\":59,\"1d779\":59,\"1d77a\":59,\"1d77b\":59,\"1d77c\":59,\"1d77d\":59,\"1d77e\":59,\"1d77f\":59,\"1d780\":59,\"1d781\":59,\"1d782\":59,\"1d783\":59,\"1d784\":59,\"1d785\":59,\"1d786\":59,\"1d787\":59,\"1d788\":59,\"1d789\":59,\"1d78a\":59,\"1d78b\":59,\"1d78c\":59,\"1d78d\":59,\"1d78e\":59,\"1d78f\":59,\"1d790\":59,\"1d791\":59,\"1d792\":59,\"1d793\":59,\"1d794\":59,\"1d795\":59,\"1d796\":59,\"1d797\":59,\"1d798\":59,\"1d799\":59,\"1d79a\":59,\"1d79b\":59,\"1d79c\":59,\"1d79d\":59,\"1d79e\":59,\"1d79f\":59,\"1d7a0\":59,\"1d7a1\":59,\"1d7a2\":59,\"1d7a3\":59,\"1d7a4\":59,\"1d7a5\":59,\"1d7a6\":59,\"1d7a7\":59,\"1d7a8\":59,\"1d7a9\":59,\"1d7aa\":59,\"1d7ab\":59,\"1d7ac\":59,\"1d7ad\":59,\"1d7ae\":59,\"1d7af\":59,\"1d7b0\":59,\"1d7b1\":59,\"1d7b2\":59,\"1d7b3\":59,\"1d7b4\":59,\"1d7b5\":59,\"1d7b6\":59,\"1d7b7\":59,\"1d7b8\":59,\"1d7b9\":59,\"1d7ba\":59,\"1d7bb\":59,\"1d7bc\":59,\"1d7bd\":59,\"1d7be\":59,\"1d7bf\":59,\"1d7c0\":59,\"1d7c1\":59,\"1d7c2\":59,\"1d7c3\":59,\"1d7c4\":59,\"1d7c5\":59,\"1d7c6\":59,\"1d7c7\":59,\"1d7c8\":59,\"1d7c9\":59,\"1d7ca\":59,\"1d7cb\":59,\"1d7ce\":59,\"1d7cf\":59,\"1d7d0\":59,\"1d7d1\":59,\"1d7d2\":59,\"1d7d3\":59,\"1d7d4\":59,\"1d7d5\":59,\"1d7d6\":59,\"1d7d7\":59,\"1d7d8\":59,\"1d7d9\":59,\"1d7da\":59,\"1d7db\":59,\"1d7dc\":59,\"1d7dd\":59,\"1d7de\":59,\"1d7df\":59,\"1d7e0\":59,\"1d7e1\":59,\"1d7e2\":59,\"1d7e3\":59,\"1d7e4\":59,\"1d7e5\":59,\"1d7e6\":59,\"1d7e7\":59,\"1d7e8\":59,\"1d7e9\":59,\"1d7ea\":59,\"1d7eb\":59,\"1d7ec\":59,\"1d7ed\":59,\"1d7ee\":59,\"1d7ef\":59,\"1d7f0\":59,\"1d7f1\":59,\"1d7f2\":59,\"1d7f3\":59,\"1d7f4\":59,\"1d7f5\":59,\"1d7f6\":59,\"1d7f7\":59,\"1d7f8\":59,\"1d7f9\":59,\"1d7fa\":59,\"1d7fb\":59,\"1d7fc\":59,\"1d7fd\":59,\"1d7fe\":59,\"1d7ff\":59,\"1e10\":39,\"1f004\":59,\"1f0cf\":59,\"1f170\":59,\"1f171\":59,\"1f17e\":59,\"1f17f\":59,\"1f18e\":59,\"1f191\":59,\"1f192\":59,\"1f193\":59,\"1f194\":59,\"1f195\":59,\"1f196\":59,\"1f197\":59,\"1f198\":59,\"1f199\":59,\"1f19a\":59,\"1f201\":59,\"1f202\":59,\"1f21a\":59,\"1f22f\":59,\"1f232\":59,\"1f233\":59,\"1f234\":59,\"1f235\":59,\"1f236\":59,\"1f237\":59,\"1f238\":59,\"1f239\":59,\"1f23a\":59,\"1f250\":59,\"1f251\":59,\"1f300\":59,\"1f301\":59,\"1f302\":59,\"1f303\":59,\"1f304\":59,\"1f305\":59,\"1f306\":59,\"1f307\":59,\"1f308\":59,\"1f309\":59,\"1f30a\":59,\"1f30b\":59,\"1f30c\":59,\"1f30d\":59,\"1f30e\":59,\"1f30f\":59,\"1f310\":59,\"1f311\":59,\"1f312\":59,\"1f313\":59,\"1f314\":59,\"1f315\":59,\"1f316\":59,\"1f317\":59,\"1f318\":59,\"1f319\":59,\"1f31a\":59,\"1f31b\":59,\"1f31c\":59,\"1f31d\":59,\"1f31e\":59,\"1f31f\":59,\"1f320\":59,\"1f330\":59,\"1f331\":59,\"1f332\":59,\"1f333\":59,\"1f334\":59,\"1f335\":59,\"1f337\":59,\"1f338\":59,\"1f339\":59,\"1f33a\":59,\"1f33b\":59,\"1f33c\":59,\"1f33d\":59,\"1f33e\":59,\"1f33f\":59,\"1f340\":59,\"1f341\":59,\"1f342\":59,\"1f343\":59,\"1f344\":59,\"1f345\":59,\"1f346\":59,\"1f347\":59,\"1f348\":59,\"1f349\":59,\"1f34a\":59,\"1f34b\":59,\"1f34c\":59,\"1f34d\":59,\"1f34e\":59,\"1f34f\":59,\"1f350\":59,\"1f351\":59,\"1f352\":59,\"1f353\":59,\"1f354\":59,\"1f355\":59,\"1f356\":59,\"1f357\":59,\"1f358\":59,\"1f359\":59,\"1f35a\":59,\"1f35b\":59,\"1f35c\":59,\"1f35d\":59,\"1f35e\":59,\"1f35f\":59,\"1f360\":59,\"1f361\":59,\"1f362\":59,\"1f363\":59,\"1f364\":59,\"1f365\":59,\"1f366\":59,\"1f367\":59,\"1f368\":59,\"1f369\":59,\"1f36a\":59,\"1f36b\":59,\"1f36c\":59,\"1f36d\":59,\"1f36e\":59,\"1f36f\":59,\"1f370\":59,\"1f371\":59,\"1f372\":59,\"1f373\":59,\"1f374\":59,\"1f375\":59,\"1f376\":59,\"1f377\":59,\"1f378\":59,\"1f379\":59,\"1f37a\":59,\"1f37b\":59,\"1f37c\":59,\"1f380\":59,\"1f381\":59,\"1f382\":59,\"1f383\":59,\"1f384\":59,\"1f385\":59,\"1f386\":59,\"1f387\":59,\"1f388\":59,\"1f389\":59,\"1f38a\":59,\"1f38b\":59,\"1f38c\":59,\"1f38d\":59,\"1f38e\":59,\"1f38f\":59,\"1f390\":59,\"1f391\":59,\"1f392\":59,\"1f393\":59,\"1f3a0\":59,\"1f3a1\":59,\"1f3a2\":59,\"1f3a3\":59,\"1f3a4\":59,\"1f3a5\":59,\"1f3a6\":59,\"1f3a7\":59,\"1f3a8\":59,\"1f3a9\":59,\"1f3aa\":59,\"1f3ab\":59,\"1f3ac\":59,\"1f3ad\":59,\"1f3ae\":59,\"1f3af\":59,\"1f3b0\":59,\"1f3b1\":59,\"1f3b2\":59,\"1f3b3\":59,\"1f3b4\":59,\"1f3b5\":59,\"1f3b6\":59,\"1f3b7\":59,\"1f3b8\":59,\"1f3b9\":59,\"1f3ba\":59,\"1f3bb\":59,\"1f3bc\":59,\"1f3bd\":59,\"1f3be\":59,\"1f3bf\":59,\"1f3c0\":59,\"1f3c1\":59,\"1f3c2\":59,\"1f3c3\":59,\"1f3c4\":59,\"1f3c6\":59,\"1f3c7\":59,\"1f3c8\":59,\"1f3c9\":59,\"1f3ca\":59,\"1f3e0\":59,\"1f3e1\":59,\"1f3e2\":59,\"1f3e3\":59,\"1f3e4\":59,\"1f3e5\":59,\"1f3e6\":59,\"1f3e7\":59,\"1f3e8\":59,\"1f3e9\":59,\"1f3ea\":59,\"1f3eb\":59,\"1f3ec\":59,\"1f3ed\":59,\"1f3ee\":59,\"1f3ef\":59,\"1f3f0\":59,\"1f3fb\":59,\"1f3fc\":59,\"1f3fd\":59,\"1f3fe\":59,\"1f3ff\":59,\"1f400\":59,\"1f401\":59,\"1f402\":59,\"1f403\":59,\"1f404\":59,\"1f405\":59,\"1f406\":59,\"1f407\":59,\"1f408\":59,\"1f409\":59,\"1f40a\":59,\"1f40b\":59,\"1f40c\":59,\"1f40d\":59,\"1f40e\":59,\"1f40f\":59,\"1f410\":59,\"1f411\":59,\"1f412\":59,\"1f413\":59,\"1f414\":59,\"1f415\":59,\"1f416\":59,\"1f417\":59,\"1f418\":59,\"1f419\":59,\"1f41a\":59,\"1f41b\":59,\"1f41c\":59,\"1f41d\":59,\"1f41e\":59,\"1f41f\":59,\"1f420\":59,\"1f421\":59,\"1f422\":59,\"1f423\":59,\"1f424\":59,\"1f425\":59,\"1f426\":59,\"1f427\":59,\"1f428\":59,\"1f429\":59,\"1f42a\":59,\"1f42b\":59,\"1f42c\":59,\"1f42d\":59,\"1f42e\":59,\"1f42f\":59,\"1f430\":59,\"1f431\":59,\"1f432\":59,\"1f433\":59,\"1f434\":59,\"1f435\":59,\"1f436\":59,\"1f437\":59,\"1f438\":59,\"1f439\":59,\"1f43a\":59,\"1f43b\":59,\"1f43c\":59,\"1f43d\":59,\"1f43e\":59,\"1f440\":59,\"1f442\":59,\"1f443\":59,\"1f444\":59,\"1f445\":59,\"1f446\":59,\"1f447\":59,\"1f448\":59,\"1f449\":59,\"1f44a\":59,\"1f44b\":59,\"1f44c\":59,\"1f44d\":59,\"1f44e\":59,\"1f44f\":59,\"1f450\":59,\"1f451\":59,\"1f452\":59,\"1f453\":59,\"1f454\":59,\"1f455\":59,\"1f456\":59,\"1f457\":59,\"1f458\":59,\"1f459\":59,\"1f45a\":59,\"1f45b\":59,\"1f45c\":59,\"1f45d\":59,\"1f45e\":59,\"1f45f\":59,\"1f460\":59,\"1f461\":59,\"1f462\":59,\"1f463\":59,\"1f464\":59,\"1f465\":59,\"1f466\":59,\"1f467\":59,\"1f468\":59,\"1f469\":59,\"1f46a\":59,\"1f46b\":59,\"1f46c\":59,\"1f46d\":59,\"1f46e\":59,\"1f46f\":59,\"1f470\":59,\"1f471\":59,\"1f472\":59,\"1f473\":59,\"1f474\":59,\"1f475\":59,\"1f476\":59,\"1f477\":59,\"1f478\":59,\"1f479\":59,\"1f47a\":59,\"1f47b\":59,\"1f47c\":59,\"1f47d\":59,\"1f47e\":59,\"1f47f\":59,\"1f480\":59,\"1f481\":59,\"1f482\":59,\"1f483\":59,\"1f484\":59,\"1f485\":59,\"1f486\":59,\"1f487\":59,\"1f488\":59,\"1f489\":59,\"1f48a\":59,\"1f48b\":59,\"1f48c\":59,\"1f48d\":59,\"1f48e\":59,\"1f48f\":59,\"1f490\":59,\"1f491\":59,\"1f492\":59,\"1f493\":59,\"1f494\":59,\"1f495\":59,\"1f496\":59,\"1f497\":59,\"1f498\":59,\"1f499\":59,\"1f49a\":59,\"1f49b\":59,\"1f49c\":59,\"1f49d\":59,\"1f49e\":59,\"1f49f\":59,\"1f4a0\":59,\"1f4a1\":59,\"1f4a2\":59,\"1f4a3\":59,\"1f4a4\":59,\"1f4a5\":59,\"1f4a6\":59,\"1f4a7\":59,\"1f4a8\":59,\"1f4a9\":59,\"1f4aa\":59,\"1f4ab\":59,\"1f4ac\":59,\"1f4ad\":59,\"1f4ae\":59,\"1f4af\":59,\"1f4b0\":59,\"1f4b1\":59,\"1f4b2\":59,\"1f4b3\":59,\"1f4b4\":59,\"1f4b5\":59,\"1f4b6\":59,\"1f4b7\":59,\"1f4b8\":59,\"1f4b9\":59,\"1f4ba\":59,\"1f4bb\":59,\"1f4bc\":59,\"1f4bd\":59,\"1f4be\":59,\"1f4bf\":59,\"1f4c0\":59,\"1f4c1\":59,\"1f4c2\":59,\"1f4c3\":59,\"1f4c4\":59,\"1f4c5\":59,\"1f4c6\":59,\"1f4c7\":59,\"1f4c8\":59,\"1f4c9\":59,\"1f4ca\":59,\"1f4cb\":59,\"1f4cc\":59,\"1f4cd\":59,\"1f4ce\":59,\"1f4cf\":59,\"1f4d0\":59,\"1f4d1\":59,\"1f4d2\":59,\"1f4d3\":59,\"1f4d4\":59,\"1f4d5\":59,\"1f4d6\":59,\"1f4d7\":59,\"1f4d8\":59,\"1f4d9\":59,\"1f4da\":59,\"1f4db\":59,\"1f4dc\":59,\"1f4dd\":59,\"1f4de\":59,\"1f4df\":59,\"1f4e0\":59,\"1f4e1\":59,\"1f4e2\":59,\"1f4e3\":59,\"1f4e4\":59,\"1f4e5\":59,\"1f4e6\":59,\"1f4e7\":59,\"1f4e8\":59,\"1f4e9\":59,\"1f4ea\":59,\"1f4eb\":59,\"1f4ec\":59,\"1f4ed\":59,\"1f4ee\":59,\"1f4ef\":59,\"1f4f0\":59,\"1f4f1\":59,\"1f4f2\":59,\"1f4f3\":59,\"1f4f4\":59,\"1f4f5\":59,\"1f4f6\":59,\"1f4f7\":59,\"1f4f9\":59,\"1f4fa\":59,\"1f4fb\":59,\"1f4fc\":59,\"1f500\":59,\"1f501\":59,\"1f502\":59,\"1f503\":59,\"1f504\":59,\"1f505\":59,\"1f506\":59,\"1f507\":59,\"1f508\":59,\"1f509\":59,\"1f50a\":59,\"1f50b\":59,\"1f50c\":59,\"1f50d\":59,\"1f50e\":59,\"1f50f\":59,\"1f510\":59,\"1f511\":59,\"1f512\":59,\"1f513\":59,\"1f514\":59,\"1f515\":59,\"1f516\":59,\"1f517\":59,\"1f518\":59,\"1f519\":59,\"1f51a\":59,\"1f51b\":59,\"1f51c\":59,\"1f51d\":59,\"1f51e\":59,\"1f51f\":59,\"1f520\":59,\"1f521\":59,\"1f522\":59,\"1f523\":59,\"1f524\":59,\"1f525\":59,\"1f526\":59,\"1f527\":59,\"1f528\":59,\"1f529\":59,\"1f52a\":59,\"1f52b\":59,\"1f52c\":59,\"1f52d\":59,\"1f52e\":59,\"1f52f\":59,\"1f530\":59,\"1f531\":59,\"1f532\":59,\"1f533\":59,\"1f534\":59,\"1f535\":59,\"1f536\":59,\"1f537\":59,\"1f538\":59,\"1f539\":59,\"1f53a\":59,\"1f53b\":59,\"1f53c\":59,\"1f53d\":59,\"1f550\":59,\"1f551\":59,\"1f552\":59,\"1f553\":59,\"1f554\":59,\"1f555\":59,\"1f556\":59,\"1f557\":59,\"1f558\":59,\"1f559\":59,\"1f55a\":59,\"1f55b\":59,\"1f55c\":59,\"1f55d\":59,\"1f55e\":59,\"1f55f\":59,\"1f560\":59,\"1f561\":59,\"1f562\":59,\"1f563\":59,\"1f564\":59,\"1f565\":59,\"1f566\":59,\"1f567\":59,\"1f5fb\":59,\"1f5fc\":59,\"1f5fd\":59,\"1f5fe\":59,\"1f5ff\":59,\"1f600\":59,\"1f601\":59,\"1f602\":59,\"1f603\":59,\"1f604\":59,\"1f605\":59,\"1f606\":59,\"1f607\":59,\"1f608\":59,\"1f609\":59,\"1f60a\":59,\"1f60b\":59,\"1f60c\":59,\"1f60d\":59,\"1f60e\":59,\"1f60f\":59,\"1f610\":59,\"1f611\":59,\"1f612\":59,\"1f613\":59,\"1f614\":59,\"1f615\":59,\"1f616\":59,\"1f617\":59,\"1f618\":59,\"1f619\":59,\"1f61a\":59,\"1f61b\":59,\"1f61c\":59,\"1f61d\":59,\"1f61e\":59,\"1f61f\":59,\"1f620\":59,\"1f621\":59,\"1f622\":59,\"1f623\":59,\"1f624\":59,\"1f625\":59,\"1f626\":59,\"1f627\":59,\"1f628\":59,\"1f629\":59,\"1f62a\":59,\"1f62b\":59,\"1f62c\":59,\"1f62d\":59,\"1f62e\":59,\"1f62f\":59,\"1f630\":59,\"1f631\":59,\"1f632\":59,\"1f633\":59,\"1f634\":59,\"1f635\":59,\"1f636\":59,\"1f637\":59,\"1f638\":59,\"1f639\":59,\"1f63a\":59,\"1f63b\":59,\"1f63c\":59,\"1f63d\":59,\"1f63e\":59,\"1f63f\":59,\"1f640\":59,\"1f645\":59,\"1f646\":59,\"1f647\":59,\"1f648\":59,\"1f649\":59,\"1f64a\":59,\"1f64b\":59,\"1f64c\":59,\"1f64d\":59,\"1f64e\":59,\"1f64f\":59,\"1f680\":59,\"1f681\":59,\"1f682\":59,\"1f683\":59,\"1f684\":59,\"1f685\":59,\"1f686\":59,\"1f687\":59,\"1f688\":59,\"1f689\":59,\"1f68a\":59,\"1f68b\":59,\"1f68c\":59,\"1f68d\":59,\"1f68e\":59,\"1f68f\":59,\"1f690\":59,\"1f691\":59,\"1f692\":59,\"1f693\":59,\"1f694\":59,\"1f695\":59,\"1f696\":59,\"1f697\":59,\"1f698\":59,\"1f699\":59,\"1f69a\":59,\"1f69b\":59,\"1f69c\":59,\"1f69d\":59,\"1f69e\":59,\"1f69f\":59,\"1f6a0\":59,\"1f6a1\":59,\"1f6a2\":59,\"1f6a3\":59,\"1f6a4\":59,\"1f6a5\":59,\"1f6a6\":59,\"1f6a7\":59,\"1f6a8\":59,\"1f6a9\":59,\"1f6aa\":59,\"1f6ab\":59,\"1f6ac\":59,\"1f6ad\":59,\"1f6ae\":59,\"1f6af\":59,\"1f6b0\":59,\"1f6b1\":59,\"1f6b2\":59,\"1f6b3\":59,\"1f6b4\":59,\"1f6b5\":59,\"1f6b6\":59,\"1f6b7\":59,\"1f6b8\":59,\"1f6b9\":59,\"1f6ba\":59,\"1f6bb\":59,\"1f6bc\":59,\"1f6bd\":59,\"1f6be\":59,\"1f6bf\":59,\"1f6c0\":59,\"1f6c1\":59,\"1f6c2\":59,\"1f6c3\":59,\"1f6c4\":59,\"1f6c5\":59,\"1fd0983b\":50,\"1im\":[27,30,74],\"1st\":[31,68],\"1xn\":49,\"20f\":75,\"220446049250313e\":[39,85],\"223372036854776e18\":52,\"2499999f0\":39,\"24t12\":68,\"2500001f0\":39,\"25f0\":39,\"28th\":31,\"29t00\":31,\"29th\":31,\"2bb94d6\":36,\"2ffork\":50,\"2fgithub\":50,\"2fjulialang\":50,\"2fmetadata\":50,\"2im\":[27,28,30],\"2nd\":31,\"2pi\":[44,52],\"30e525\":50,\"30ish\":77,\"31st\":31,\"31t00\":[31,68],\"33333334f0\":[64,76],\"3333333f0\":76,\"3ef4f5c4\":50,\"3im\":[27,58],\"4031192506220405im\":27,\"4142135623730951im\":34,\"417b50a\":2,\"459565876494606882133333333333333333333333333333333333333333333333333333333344e\":39,\"4717266720048188im\":27,\"47c198b1\":50,\"4ghz\":52,\"4im\":27,\"4th\":[12,31,68],\"5000025e11\":52,\"5172413793103449im\":27,\"53rd\":68,\"55b6\":59,\"5714285714285714im\":27,\"5f0\":[39,52,64],\"5fcfb13\":50,\"5im\":27,\"5th\":31,\"60im\":27,\"64f437b\":40,\"6e80\":59,\"7071067811865475im\":27,\"75im\":27,\"7861513777574233im\":27,\"793662034335766e\":39,\"7a7a\":59,\"84b8e266dae6de30ab9703150b3bf771ec7b6285\":50,\"8ball\":59,\"8im\":27,\"8p3\":39,\"960664459571898im\":27,\"9f71f4becb05cadacb983c54a72eed744e5c019d\":50,\"\\u00e5ke\":74,\"\\u00ectr\":66,\"\\u0111\":59,\"\\u0127\":[40,59],\"\\u0142\":59,\"\\u014b\":59,\"\\u0153\":59,\"\\u0195\":59,\"\\u019e\":59,\"\\u01b6\":59,\"\\u01c2\":59,\"\\u0250\":59,\"\\u0252\":59,\"\\u0254\":59,\"\\u0256\":59,\"\\u0259\":59,\"\\u025b\":[59,74],\"\\u0263\":59,\"\\u0264\":59,\"\\u0265\":59,\"\\u026c\":59,\"\\u026d\":59,\"\\u026f\":59,\"\\u0270\":59,\"\\u0271\":59,\"\\u0272\":59,\"\\u0273\":59,\"\\u0277\":59,\"\\u0278\":59,\"\\u0279\":59,\"\\u027a\":59,\"\\u027b\":59,\"\\u027c\":59,\"\\u027d\":59,\"\\u027e\":59,\"\\u0282\":59,\"\\u0283\":59,\"\\u0287\":59,\"\\u0288\":59,\"\\u028a\":59,\"\\u028b\":59,\"\\u028c\":59,\"\\u028d\":59,\"\\u028e\":59,\"\\u0290\":59,\"\\u0292\":59,\"\\u0294\":59,\"\\u0295\":59,\"\\u0296\":59,\"\\u029e\":59,\"\\u02a4\":59,\"\\u02a7\":59,\"\\u02b0\":59,\"\\u02b2\":59,\"\\u02b3\":59,\"\\u02b7\":59,\"\\u02b8\":59,\"\\u02bc\":59,\"\\u02c7\":59,\"\\u02c8\":59,\"\\u02cc\":59,\"\\u02d0\":59,\"\\u02d1\":59,\"\\u02e1\":59,\"\\u02e2\":59,\"\\u02e3\":59,\"\\u03b1\":[32,40,59,60,74],\"\\u03b2\":[59,74],\"\\u03b3\":[59,76],\"\\u03b4\":[59,60],\"\\u03b4t\":52,\"\\u03b5\":59,\"\\u03b6\":59,\"\\u03b7\":59,\"\\u03b8\":[58,59],\"\\u03b9\":59,\"\\u03ba\":59,\"\\u03bb\":[43,59,74],\"\\u03bc\":59,\"\\u03bd\":59,\"\\u03be\":59,\"\\u03bf\":59,\"\\u03c0\":[40,59,60,76],\"\\u03c1\":59,\"\\u03c2\":59,\"\\u03c3\":59,\"\\u03c4\":59,\"\\u03c5\":59,\"\\u03c6\":[59,76],\"\\u03c7\":59,\"\\u03c8\":59,\"\\u03c9\":59,\"\\u03d0\":59,\"\\u03d1\":59,\"\\u03d5\":59,\"\\u03d6\":59,\"\\u03d9\":59,\"\\u03db\":59,\"\\u03dd\":59,\"\\u03df\":59,\"\\u03e1\":59,\"\\u03f0\":59,\"\\u03f1\":59,\"\\u03f5\":59,\"\\u1d2c\":59,\"\\u1d2e\":59,\"\\u1d30\":59,\"\\u1d31\":59,\"\\u1d33\":59,\"\\u1d34\":59,\"\\u1d35\":59,\"\\u1d36\":59,\"\\u1d37\":59,\"\\u1d38\":59,\"\\u1d39\":59,\"\\u1d3a\":59,\"\\u1d3c\":59,\"\\u1d3e\":59,\"\\u1d3f\":59,\"\\u1d40\":59,\"\\u1d41\":59,\"\\u1d42\":59,\"\\u1d43\":59,\"\\u1d45\":59,\"\\u1d47\":59,\"\\u1d48\":59,\"\\u1d49\":59,\"\\u1d4b\":59,\"\\u1d4d\":59,\"\\u1d4f\":59,\"\\u1d50\":59,\"\\u1d52\":59,\"\\u1d56\":59,\"\\u1d57\":59,\"\\u1d58\":59,\"\\u1d5b\":59,\"\\u1d5d\":59,\"\\u1d5e\":59,\"\\u1d5f\":59,\"\\u1d60\":59,\"\\u1d61\":59,\"\\u1d62\":59,\"\\u1d63\":59,\"\\u1d64\":59,\"\\u1d65\":59,\"\\u1d66\":59,\"\\u1d67\":59,\"\\u1d68\":59,\"\\u1d69\":59,\"\\u1d6a\":59,\"\\u1d9c\":59,\"\\u1da0\":59,\"\\u1da5\":59,\"\\u1db2\":59,\"\\u1dbb\":59,\"\\u1dbf\":59,\"\\u2070\":59,\"\\u2071\":59,\"\\u2074\":59,\"\\u2075\":59,\"\\u2076\":59,\"\\u2077\":59,\"\\u2078\":59,\"\\u2079\":59,\"\\u207f\":59,\"\\u2080\":59,\"\\u2081\":59,\"\\u2082\":[59,60],\"\\u2083\":59,\"\\u2084\":59,\"\\u2085\":59,\"\\u2086\":59,\"\\u2087\":59,\"\\u2088\":59,\"\\u2089\":59,\"\\u2090\":59,\"\\u2091\":59,\"\\u2092\":59,\"\\u2093\":59,\"\\u2094\":59,\"\\u2102\":59,\"\\u2107\":59,\"\\u210a\":59,\"\\u210b\":59,\"\\u210c\":59,\"\\u210d\":59,\"\\u210e\":59,\"\\u210f\":59,\"\\u2110\":59,\"\\u2111\":59,\"\\u2112\":59,\"\\u2113\":59,\"\\u2115\":59,\"\\u2119\":59,\"\\u211a\":59,\"\\u211b\":59,\"\\u211c\":59,\"\\u211d\":59,\"\\u2124\":59,\"\\u2128\":59,\"\\u212c\":59,\"\\u212d\":59,\"\\u212f\":59,\"\\u2130\":59,\"\\u2131\":59,\"\\u2133\":59,\"\\u2134\":59,\"\\u2135\":59,\"\\u2136\":59,\"\\u2137\":59,\"\\u2138\":59,\"\\u2139\":59,\"\\u213c\":59,\"\\u213d\":59,\"\\u213e\":59,\"\\u213f\":59,\"\\u2145\":59,\"\\u2146\":59,\"\\u2147\":59,\"\\u2148\":59,\"\\u2149\":59,\"\\u214e\":59,\"\\u2c7c\":59,\"\\u2c7d\":59,\"\\u4eba\\u4eba\\u751f\\u800c\\u81ea\\u7531\":60,\"\\u4f60\\u597d\":36,\"\\u5728\\u5c0a\\u4e25\\u548c\\u6743\\u5229\\u4e0a\\u4e00\\u5f8b\\u5e73\\u7b49\":60,\"\\uc548\\ub155\\ud558\\uc138\\uc694\":[36,60],\"abstract\":[1,7,8,15,16,21,25,26,28,30,31,32,39],\"b\\u00e9zout\":75,\"bj\\u00f6rck\":74,\"boolean\":[1,19,21,25,29,30,33,44,46,49,58,63,64,66,71,74,75,76,77,80,84],\"break\":[1,2,6,15,29,31,32,33,34,49,50,51],\"byte\":[14,16,26,36,39,45,48,51,52,53],\"case\":[1,3,5,8,14,15,17,18,19,21,22,25,26,27],\"catch\":[1,6,8,17],\"char\":[6,7,9,14,18,26,33,40,46,48,56,58,65,68,71,74,84],\"class\":[11,25,35,36,44,49,54,56,58,71],\"const\":[1,14,18,26,31,32,33,40,47,52,60,61,64,73,77],\"default\":[3,6,8,11,15,16,17,20,21,22,25,26,28,29,31,32,34],\"double\":59,\"enum\":[26,32,49,64,73],\"export\":[1,5,11,15,16,26,31,33,34,47,50,51,64,65,68,73,74,78,79,83,85],\"false\":49,\"final\":[1,6,7,8,9,12,16,19,21,26,28],\"float\":[6,23,26,27,28,30,36,38],\"fr\\u00e9chet\":74,\"function\":[1,3,4],\"goto\":[52,85],\"int\":[1,8,9,14,15,16,18,19,21,25,26,28,29,30,31,33,34,35,39,40,41,44,45,46,47,49,51,52,53,56,57,58,59,63,64,65,66,68,69,71,74,75,76,77,79,83,85],\"long\":[3,5,15,17,26,29,46,50,51,53,59,61,65,71,74,75,76,77,79,84],\"new\":[1,2,6,7,8,9,12,13,14,15,20,26,28,29],\"null\":[1,6,7,9,18,26,28,33],\"package\":[50,59],\"public\":[47,50,51,59],\"return\":[1,3,4,6,7,8,9,13,15,16,18,19,21,25],\"short\":[6,7,26,28],\"static\":[1,11,18,30,37,42,49],\"super\":[9,26,30,74],\"switch\":[29,34,36,50,51,52,77],\"throw\":[3,8,15,19,26,28],\"transient\":46,\"true\":[1,5,6,8,15,16,19,20,21,25,26,27,28,29,30,31,32,34,36,39,41,44,45,46,48,49,51,52,53,54,55,56,58,59,61,63,64,65,66,68,69,71,74,75,76,77,78,79,82,83,84,85],\"try\":[1,2,3,8,12,15,21,26,27,28],\"typeof\":[8,16,18,26,27,28,29,30,33,34,39,44,45,52,56,57,58,64,66,71,75,85],\"var\":[1,5,21,26,29,40,45,64,75,77],\"void\":[6,14,18,21,26,33,34,47,55,56,57,65,66,67,72,78,83],\"while\":[1,2,5,6,12,14,15,16,17,19,21,26,28,29,30,31,32,33,34,36,39,41,42,45,46,47,48,49,50,51,52,53,54,55,56,57,58,60,61,64,66,68,73,74,75,77,79,82],_130862:16,__doc__:32,__file__:[47,67,69],__init__:[9,18,47,64],__line__:69,__m128:26,__m256:26,__precompile__:[47,64],__text:34,_always_:74,_appli:8,_atexit:[7,9],_beta:59,_chi:59,_expr:8,_fileno:18,_fopen:37,_gamma:59,_getindex:3,_init:62,_j_str267:6,_julia_init:9,_mm256_add_p:26,_mm256_mul_p:26,_mm256_sqrt_p:26,_nogc:12,_noreturn:26,_phi:59,_rho:59,_schwa:59,_start:7,_var0:52,_var1:52,_var2:52,_var3:52,_var4:52,a_1:[5,26],a_2:[5,26],a_3:[5,26],a_ldiv_b:[74,75],a_ldiv_bc:74,a_ldiv_bt:74,a_mul_b:[74,75],a_mul_bc:74,a_mul_bt:74,a_rdiv_bc:74,a_rdiv_bt:74,aaaa1aaaa2aaaa3:56,aarch64:26,abbr:68,abbrevi:[31,45,57,68],abbreviat:68,abc:[59,85],abcd:[48,59],abi_:7,abil:[5,29,42,45,46,47,48,58,71],abl:[3,6,21,28,29,32,34,35,40,41,48,50,51,52,58,61,64],abnrm:74,abort:6,about:[3,6,7,8,10,11,14,15],abov:[1,8,9,12,14,16,19,21,26,29,30,31,32,33,34,35,39,40,41,42,45,46,47,48,50,51,52,53,54,55,56,57,58,61,64,68,71,74,77,83],above:59,abracadabra:56,abruptli:26,abs2:[25,27,44,52,66,75],absenc:[30,31,46,58],absent:14,absolut:[27,31,32,39],abspath:69,abstol:[8,74,75],abstract_cal:53,abstract_call_gf:53,abstract_ev:53,abstractarrai:[3,15,19,25,26,32,35,40,41,46,51,52,57,63,64,66,74,75,76,82],abstractcartesianindex:40,abstractfloat:[16,21,30,46,52,58,63,64,76],abstractli:[46,84],abstractlock:77,abstractmatrix:[19,25,63,74],abstractremoteref:77,abstractrepl:40,abstractrng:76,abstractsparsearrai:40,abstractsparsematrix:25,abstractstr:[26,32,34,39,40,51,56,57,58,64,66,68,69,71,73,76,77,78,84,85],abstractvector:[15,19,25,52,63,71,74,77],abstractworkerpool:77,abus:[28,45],ac_ldiv_b:74,ac_ldiv_bc:74,ac_mul_b:74,ac_mul_bc:74,ac_rdiv_b:74,ac_rdiv_bc:74,accent:[56,59,84],accept:[8,15,16,21,25,26,27,31,32,34,35,40,41,48,49,50,52,56,57,58,59,61,65,66,71,76,77,78,82,84,85],access:[3,6,8,11,14,19,25],accident:[34,45,47,50],accommod:[21,47,63,66,71],accompani:74,accomplish:[26,28,29,31,35,41,45,47,50,54,58,66],accord:[25,31,39,44,50,52,63,64,66,68,74,75,76,82,84],accordingli:[28,35,46,50,52,58,65],account:[39,47,49,50,56,74,85],accumul:[51,52],accur:[2,26,28,44,50,54,75],accuraci:[17,39,47,63,74,75],accurat:75,accurr:59,accustom:49,acd:56,achiev:[3,21,28,34,35,42,45,48,49,50,51,52,75],acidfre:59,aco:[25,44,75],acosd:[25,44,75],acosh:[25,44,75],acot:[25,44,75],acotd:[25,44,75],acoth:[25,44,75],acoustic:74,acquir:[12,77],acronym:[7,50],across:[19,26,42,44,49,51,58,71,74,77,85],acsc:[25,44,75],acscd:[25,44,75],acsch:[25,44,75],act:[6,25,26,35,45,46,49,51,58,63,66,77],action:[7,12,21,29,30,40,45,53],activ:[2,48,54,64,85],actual:[6,8,25,26,28,29,30,31,32,34,35,39,45,48,50,52,53,54,55,56,58,61,64,65,71,75,77],actualli:54,actually:59,acut:59,acute:59,ada:[30,58],adapt:[52,75],add:[1,6,7,8,15,16,22,25,28,31,32,33,34,40,44,45,46,47,48,50,51,52,53,57,58,62,66,71,75,77,78,81],add_builtin_func:9,add_float:52,adder:8,addict:57,addit:[3,5,6,13,17,19,22,25,26,27,28,29,30,31,33,34,36,40,41,42,44,45,46,47,48,50,51,52,56,58,60,62,63,64,66,68,74,75,76,77,81,84],addition:[12,21,25,28,29,31,32,33,34,37,39,41,44,50,51,52,56,64,66,75,77,84],addon:57,addopt:84,addp:81,addproc:[51,77],addr:[71,72],address:[6,12,14,15],adjac:[25,39,63,82,84],adjust:[22,31,50,64,68],adopt:[15,19,52,60],adot:59,advanc:[25,29],advantag:[15,33,34,39,42,45,47,51,52,58,62,77],advantage:59,advection_chunk:51,advection_parallel:51,advection_seri:51,advection_shar:51,advection_shared_chunk:51,advic:52,advis:[32,59,75],aerial:59,aerial_tramwai:59,affect:[9,26,35,47,52,57,61,76,79],affix:51,aforement:46,africa:59,after:[1,6,9,11,22,25,26,28,29,30,31,32,33,34,35,40,44,45,46,47,48,49,50,51,52,53,56,58,60,64,65,69,71,72,74,75,77,78,84,85],afterward:[28,29,32,50,71,77,84],again:[9,26,29,30,35,40,45,48,50,51,52,71,74,77,78,79],against:[11,21,33,34,50,57],agent:50,aggreg:4,aggress:34,agnost:19,agre:[28,56],agroup:56,ah12:74,ahead:[31,51],ahr13:74,aid:[31,33,49],aim:42,airi:[25,44,75],airplan:59,airplane:59,airyai:[25,44,75],airyaiprim:[25,44,75],airybi:[25,44,75],airybiprim:[25,44,75],airyprim:[25,44,75],airyx:[44,75],aka:[21,26],akin:25,alarm:59,alarm_clock:59,albeit:[7,51],alef:59,aleph:59,alert:[26,57,85],alg:82,algebra:[23,34,38],algorithm:[5,12,14,15,19,21,30,34,41,46,50,51,52,58,63,66,74,75,77],alia:9,alias:[25,26,39],alien:59,align:[14,16,26,32],all:[1,3,5,6,7,8,11,12,14,15,16,19,20,21,22,25,26,27,28,29,30,31,32,33,34,35,36,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,56,57,58,59,61,63],all_to_al:[51,77],allequ:59,allevi:56,alloc:[1,7,9,12],allow:[3,5,6,12,15,18,19,21,25,26,27,28,29,30,32,33,34,35,39,40,41,43,44,45,46,47,48,49,50,51,52,53,56,58],allow_user_segv_handl:17,alluniqu:66,almost:[12,25,33,34,43,45,46,49,52,59,61],alon:[26,34,45,57,58,61],along:[7,8,15,25,28,31,32,41,50,51],alpha:[32,40,56,59,60,74],alphabet:84,alphanumer:[32,84],alreadi:[1,12,26,28,32,33,34,35,40,41,45,47,50,51,52,57,58,62,64,66,71,74,77,82],also:[1,5,6,7,8,11,12,14,15,16,17,20,21,22,25,26,27,28,29,30,31,32,33,34,35,36,39,40,41,42,44,45,46,47,48,49,50,51,52,53,55,56,57,58,60,61,62,63,64,65,66,67,68,71,74,75,76,77,78,80,82,83,84,85],alt:40,alter:[15,26,28,35,45,58],altern:[6,8,14,29,30,32,33,34,39,45,47,49,52,53,54,57,62,64,65,66,67,68,69,71,75,84,85],alternat:71,alternation:59,although:[7,14,21,28,29,30,35,42,45,46,49,50,51,52,53,58,61,71,74,75],altogeth:[46,51,52,57],alveolar:59,alwai:[1,2,4,12,13,15,25,26,28,29,30,31,32,33,34,35,36,39,41,42,46,47,49,51,52,54,56,57,58,61,64,66,69,71,75,76,84],amalg:59,amalgamation:59,amazon:51,ambigu:[3,15,39,45,46,50,54],ambul:59,ambulance:59,amd:74,amen:[52,64],american:[59,75],americas:59,among:[15,21,29,35,47,50,51,52,53,57,71,77],amongst:[51,77],amount:[42,45,47,51,52,53,56,63,64,71,77],ampersand:59,amplifi:34,analog:[31,34,52,63],analogu:[49,63],analysi:[7,8],analyt:75,analyz:0,anatomi:29,anchor:59,and_int:52,angdnr:59,angel:59,anger:59,angl:[25,27,44,59,74,75],angle:59,angleubar:59,angri:[56,59,84],angry:59,angstrom:59,anguish:59,anguished:59,ani:[2,3,5,6,7,8,11,12,13,14,15,16,18,19,21,22,25,26,27,28,29,30,31,32,33,34,35,39,40,41,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,61,63,64,65,66,68,71,74,75,77,78,79,84,85],animal:85,annot:1,annuiti:59,annuity:59,anonymousmmap:71,anorm:74,anoth:[3,8,17,21,26,28,29,30,31,32,33,34,40,45,47,48,49,50,51,52,54,57,58,62,64,66,71,77],another:[6,8,22,25,32,45,50,54,56,57,58],answer:[15,25,31,40,51,65,74,75,77],answer_color:40,ant:59,antenna:59,anticlockwise:59,any:[1,6,8,9,13,16,19],anymor:[15,50,61],anyon:[30,45,50,51],anyth:[25,29,34,40,41,42,44,45,47,50,56,64,66,76],anywai:[25,31,34,57],anywher:[26,29,32,35,46,56,58],apach:50,apart:[19,34],apex:58,api:[8,14,26,31,33,34,42,48,50,51,68,71,74,77,82],apl:59,aplboxquest:59,aplboxupcaret:59,aplnotbackslash:59,aplnotslash:59,apolog:54,apostrophe:59,appar:[46,47,56],appeal:[19,34],appear:[1,3,5,8,15,26,28,32,33,34,40,46,49,50,52,53,55,59,61,66,74,82],append:[13,19,26,32,46,49,51,53],appl:[36,40,56,59,64,84],apple:[49,59,64],appli:[4,19,25,27,28,29,30,32,35,39,42,44,45,46,49,50,51,52,58,63,64,66,68,69,71,74,75,77,82,85],applic:[5,8,12,16,25,26,29,30,32,33,35,39,42,46,48,52,53,55,56,64,71,73,74,75,76],applicat:74,apply:[46,66,69,71,75],apply_typ:[8,16],appreci:[11,52],approach:[5,6,19,31,34,35,36,40,42,45,50,51,52,74],approaches:59,appropri:[15,19,25,26,28,29,30,34,39,40,41,42,45,46,48,50,51,52,54,55,56,57,58,64,66,71,74,76,77,84],approv:50,approx:[59,85],approxeq:59,approxeqq:59,approxim:[26,30,53,64,75,85],approximate:59,approximately:59,approxnotequ:59,appveyor:50,apr:68,april:[31,68],apropo:64,aptli:45,aquariu:59,aquarius:59,arabic:56,arbitrari:[1,12,15,25,26,30,32,35],arbitrarili:[32,44,46,49,50,58,76],arc:59,arceq:59,arch:67,archaic:59,architectur:[39,56,67,74],archiv:7,aren:[28,47,50,54,56,74],arg1:[26,36,46,49],arg2:[26,36,46,49],arg3:49,arg:[1,2,4,6,8,13,14,15,18,21,25,27,28,33,34,35,36,40,45,52,64,71,77],argc:[9,26,33],args:[7,9,36,67],args_morespecif:21,argtyp:[33,77],argtype:16,argument:[1,3,4],argumenterror:[27,29,64,66,75,84],argumenttyp:[26,65],argumenttype1:65,argumentvalu:65,argumentvalue1:65,argv:[9,26,33,54],argval:77,ari:[1,43,59],aries:59,aris:[1,6,39,43,45],arisen:[30,58],arithmet:[25,26,27,30],arm:[26,59],armed:21,arnoldi:74,around:[7,8,26,28,33,34,35,45,50,51,57,58,59],arrai:[1,3,4,5,6,8,9,10,11,12,13,14],arrang:[8,26,45,52,54],array3:52,array_typ:33,arraycontain:52,arraymath:46,arrayref:[3,8,52],arrays:8,arrayset:[3,8],arraytyp:41,arriv:[9,29],arrow:[40,59],arrow_backward:59,arrow_double_down:59,arrow_double_up:59,arrow_down:59,arrow_down_smal:59,arrow_forward:59,arrow_heading_down:59,arrow_heading_up:59,arrow_left:59,arrow_lower_left:59,arrow_lower_right:59,arrow_right:59,arrow_right_hook:59,arrow_up:59,arrow_up_down:59,arrow_up_smal:59,arrow_upper_left:59,arrow_upper_right:59,arrows:59,arrows_clockwis:59,arrows_counterclockwis:59,art:59,arthur:46,articl:39,articulated:59,articulated_lorri:59,artifici:46,artist:59,arts:59,ary:59,asan_options:17,ascend:[50,66,75,82],ascii:[9,34,56,71,77,84],asec:[25,44,75],asecd:[25,44,75],asech:[25,44,75],asia:59,asid:[32,57],aside:8,asin:[25,44,75],asind:[25,44,75],asinh:[25,44,75],ask:[19,21,31,41,50,51,52,56,57,58,63],asked:23,asl:50,aspect:[52,54,57,58],assembl:[7,64],assert:[15,26,45,46,52,58,64,72,85],assertionerror:[45,64],assign:[1,16,21,25,26,28,29,31,34,35,41,44,45,47,49,51,52,56,58,60,61,63,64,73,77,84],assist:58,associ:[8,14,15,29,31,32,34,43,46,47,48,50,51,58,60,63,64],assum:[14,15,22,26,29,31,33,39,47,48,50,52,61,63,66,68,71,74,75,82,84],assume:[33,52,58,65],assumpt:[15,22,31,33,75],asteq:59,asteracc:59,asterisk:[32,59],astonish:59,astonished:59,astrosun:59,asum:74,asymp:59,asymptot:75,asymptotically:59,async:[29,34,48,51,52,54,64,77],asynccondit:[26,64],asyncmap:77,at_ldiv_b:74,at_ldiv_bt:74,at_mul_b:74,at_mul_bt:74,at_rdiv_b:74,at_rdiv_bt:74,atan2:[25,44,75],atan:[25,44,75],atand:[25,44,75],atanh:[25,44,75],atexit:[7,64],athletic:59,athletic_sho:59,atm:59,atol:75,atom:[1,77],atomic:77,atomic_:77,atomic_add:77,atomic_and:77,atomic_ca:77,atomic_f:77,atomic_max:77,atomic_min:77,atomic_nand:77,atomic_or:77,atomic_sub:77,atomic_xchg:77,atomic_xor:77,atomicrmw:77,atreplinit:[40,64],attach:[6,32,58],attempt:[2,7,12,19,26,40,47,48,50,52,54,56,58,64,66,71],attent:[25,32,34],attitud:50,attr:16,atyp:14,aubergine:59,audio:71,audit:[2,15,50],aug:68,augment:42,august:68,australia:59,authent:[51,77],author:[32,50,53],auto:8,auto_unbox:6,autom:[20,50],automat:[16,25,26,28,29,30,32],automated:59,automobile:59,autotool:17,aux:54,auxiliari:[28,30],avail:[7,16,18,19,20,26,29,31,34,36,39,40,43,45,47,48,50,51,52,53,55,57,58,60,61,63,64,65,66,67,69,71,72,73,74,75,76,77,78,82,85],availabl:47,averag:25,average:59,avoid:[3,12,15,19,25,26,27,28,31,32,34,35,39,45,46,47,48,49,50,51],avx:26,awad:74,awai:[29,39,50,52,63,75],awar:[26,31,33,46,47,51,54,57],awint:59,awkward:[35,56],awri:2,axi:[44,52],axpi:74,b96:74,b_a:26,b_a_2:26,babi:59,babuska:63,baby:59,baby_bottl:59,baby_chick:59,baby_symbol:59,back:[6,7,9,21,26,28,29,30,33,44,50,51,52,56,58,59,61,63,71,75,77,78],backbon:58,backend:71,backepsilon:59,backhand:59,backppprim:59,backpprim:59,backprim:59,backsim:59,backsimeq:59,backslash:[56,59,60,64,68,71,80],backspac:40,backtick:[32,54,64],backtrac:[2,6,7,9,17,29,53],backtransform:74,backward:[64,74,75],bactrian:59,bad:[8,26,29],bad_funct:55,badge:59,badli:50,bag:[58,59],baggage:59,baggage_claim:59,bagmemb:59,bail:[8,50],balanc:74,ball:59,balloon:59,ballot:59,ballot_box_with_check:59,bamboo:59,banana:[49,56,59,84],band:74,bang:82,bangbang:59,bank:59,banknote:59,banner:[36,40],bar:[28,29,32,34,35,36,45,46,47,50,52,53,54,58,59,61,64,65,66,77,85],bar_chart:59,barb:59,barbar:45,barber:59,barcap:59,barcup:59,baremodul:[32,47,61,64],barleftarrow:59,barleftarrowrightarrowbar:59,barovernorthwestarrow:59,barred:59,barrier:33,barrightarrowdiamond:59,bars:59,barve:59,barwedg:59,base64:71,base64decod:71,base64decodepip:71,base64encod:71,base64encodepip:71,base:[1,2],basebal:59,baseball:59,baselin:8,basenam:69,bash:[11,26],basi:[31,74,82],basic:1,basketbal:59,basketball:59,batch:77,batch_siz:77,bath:59,bathtub:59,batteri:59,battery:59,bauer:74,baz:[28,29,34,35,45,54,58,66],bbb:59,bbba:59,bbbb:59,bbbc:59,bbbd:59,bbbe:59,bbbeight:59,bbbf:59,bbbfive:59,bbbfour:59,bbbg:59,bbbgamma:59,bbbh:59,bbbi:59,bbbj:59,bbbk:59,bbbl:59,bbbm:59,bbbn:59,bbbnine:59,bbbo:59,bbbone:59,bbbp:59,bbbpi:59,bbbq:59,bbbr:59,bbbs:59,bbbseven:59,bbbsix:59,bbbt:59,bbbthree:59,bbbtwo:59,bbbu:59,bbbv:59,bbbw:59,bbbx:59,bbby:59,bbbz:59,bbbzero:59,bbrktbrk:59,bbsum:59,bce:31,bdsdc:74,bdsqr:74,beam:59,beamed:59,bear:59,beating:59,becaus:[6,7,8,15,16,18,21,25,26,28,29,31,33,34,35,42,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,63,65,66,72,74,75,76,79,84,85],because:59,becom:[15,25,28,29,34,35,45,51,52,53,54,55,56,57,58,60,68,74,77],bee:59,been:[2,3,6,7,15,16,28,29,30,34,35,40,42,43,44,47,48,50,51,52,53,54,55,56,58,61,64,71,72,74,77,78],beer:59,beetl:59,beetle:59,befor:[1,5,7,8,9,11,17,18,19,22,25,26,28,29,30,31,32,33,34,35,39,40,42,44,45,46,47,48,49,50,51,52,53,54,56,58,61,64,66,68,69,71,73,74,75,77,82,84],beforehand:26,begin:[1,5,8,9,15,16,19,21,28,29,31,32,34,35,36,40,45,48,50,51,52,53,56,58,60,61,62,66,69,71,77,80,84,85],beginn:59,beginner:59,behav:[1,15,22,25,26,27,28,31,34,45,46,51,52,56,57,58,61,63,66,75],behavior:[3,15,21,25,26,28,29,30,34],behaviour:[30,31,32,51,75,84],behind:[34,48,50,59],believ:42,bell:59,belong:[8,46,50,58,84],below:[5,9,12,15,17,19,21,25,26,29,32,33,35,36,41,45,47,50,51,52,53,56,58,59,61,64,74],belt:59,benchmark:[52,75],beneath:50,benefici:[32,34,35,58],benefit:[48,51,52,77],bento:59,benzene:59,benzenr:59,beowulf:77,bernoulli:63,berr:74,besid:[11,30,50,56,76],beside:59,bess:[25,44,75],bessel:[26,44,75],besselh:[25,44,75],besselhx:75,besselix:[44,75],besselj0:[25,44,75],besselj1:[25,44,75],besselj:[25,44,75],besseljx:[44,75],besselk:[25,44,75],besselkx:[44,75],bessely0:[25,44,75],bessely1:[25,44,75],besselyx:[44,75],best:[2,11,15,19,26,28,29,34,47,49,50,52,53,63,71,74,75],bet:[2,59],beta:25,beth:59,better:[11,15,19,22,25,28,30,45,47,50,51,52,54,57,64,75,79,85],between:[3,5,11],beverage:59,bewar:32,beyond:[25,30,46,56,64,71],bfft:75,bh83:74,bias:74,biceps:59,bicycle:59,bicycles:59,bicyclist:59,bidiagon:[43,74],big:[5,30,64,71,75,76],big_str:1,bigblacktriangledown:59,bigblacktriangleup:59,bigbot:59,bigcap:59,bigcirc:59,bigcup:59,bigcupdot:59,bigfloat:[16,39,49,75],bigger:34,biggest:[51,52],bigint:[30,34,39,49,75,76],biglib:47,bigodot:59,bigoplu:59,bigotim:59,bigslopedve:59,bigslopedwedg:59,bigsqcap:59,bigsqcup:59,bigstar:59,bigtim:59,bigtop:59,bigtriangledown:59,bigtriangleup:59,biguplu:59,bigve:59,bigwedg:59,bigwhitestar:59,bike:[50,59],bikini:59,bilater:63,billiards:59,bin:[2,6,11,26,33,40,71,75,76],bin_arr:76,binari:[2,25,34,36,39,43,44,48,49,50,63,64,66,71,75,76,77,85],binary:59,bind:[1,9,16,27,28,32,34,35,36],bind_addr:[36,51,77],bindep:47,binomi:75,bird:59,birthdai:59,birthday:59,bischof1987:74,bischof:74,bisecting:59,bit:[1,6,7,9],bitarrai:15,bitbroadcast:63,bitbucket:50,bitcod:[36,64],bitfield:69,bitrand:76,bitshift:44,bitstyp:[26,56,58,77,81],bitvector:[63,66,74],bitwis:[25,29,39],bkarow:59,bkfact:74,black:[8,35,40,59,71],black_circl:59,black_jok:59,black_large_squar:59,black_medium_small_squar:59,black_medium_squar:59,black_nib:59,black_small_squar:59,black_square_button:59,blackcircledrightdot:59,blackcircledtwodot:59,blackcircleulquadwhit:59,blackinwhitediamond:59,blackinwhitesquar:59,blacklefthalfcircl:59,blacklozeng:59,blackpointerleft:59,blackpointerright:59,blackrighthalfcircl:59,blacksmilei:59,blacksquar:59,blacktriangl:59,blacktriangledown:59,blacktriangleleft:59,blacktriangleright:59,blank:[32,40,56,59,71,78],blanksymbol:59,blas:[2,25,26,51],blascopi:74,blasfloat:74,blindli:41,blkdiag:74,blkhorzov:59,blksize:[64,69],blkvertov:59,blockful:59,blockhalfshad:59,blocklefthalf:59,blocklowhalf:59,blockqtrshad:59,blockrighthalf:59,blockthreeqtrshad:59,blockuphalf:59,blog:[26,34,39,44,50],blond:59,bloomfilt:50,blossom:59,blow:8,blowfish:59,blue:[40,59,71],blue_book:59,blue_car:59,blue_heart:59,blush:[34,59],boar:59,board:59,boat:59,bodi:[1,3,5,6,8,13,15,29,30,34,35,41,45,46,47,49,52,57,61,65,66,71,77,85],bodyexpr:5,boi:59,boilerpl:[26,45],boldfac:32,bolt:59,bomb:59,bone:59,bonu:21,boo:45,book:[32,39,50,59],bookmark:59,bookmark_tab:59,books:59,bool:[3,6,8,13,21,25,26,29,30,31,34,39,44,46,49,51,52,55,58,63,64,66,68,69,71,74,75,76,77,83,84,85],boom:[31,59],boot:[7,9,21,40,55,58,59],boots:59,bootup:2,borrow:[42,54],bot:59,both:[1,5,7,15,16,19,21,22,25,26,27,28,29,30,31,32,34,35,39,40,41,45,46,47,49,50,51,52,53,54,55,56,57,58,59,61,63,64,66,68,74,75,78,82],bother:15,botsemicircl:59,bottle:59,bottleneck:[52,53],bound:1,boundari:[26,52,56,74],boundscheck:[1,3,15],boundserror:[29,41,45,49,56,64],bouquet:59,bourn:51,bow:59,bowing:59,bowl:59,bowling:59,bowti:59,bowtie:59,box:[4,6,7,9,14,33,52,58,59],boxast:59,boxbar:59,boxbslash:59,boxcircl:59,boxdiag:59,boxdot:59,boxed_uint8_cach:9,boxminu:59,boxplu:59,boxtim:59,boy:59,brace:58,branch:[1,3,29,34],bread:59,breakag:50,bref:51,breve:59,brfft:75,bride:59,bride_with_veil:59,bridg:33,bridge:59,bridge_at_night:59,brief:[39,41,50,51,71],briefcas:59,briefcase:59,briefli:[28,46,52],brightness:59,bring:[32,68],brittl:50,broad:[39,44,64],broadcast_getindex:[25,63],broadcast_setindex:[25,63],broadli:19,broke:50,broken_heart:59,broker:51,brought:[47,51],browser:[53,59],bruce:39,bsd:[6,50,64],bsimilarleftarrow:59,bsimilarrightarrow:59,bsolhsub:59,bswap:76,btime:59,buf:18,buffalo:59,buffer:[18,26,40,48,53,54,58,71,79],bufferstream:51,bug:[15,17,22,26,34,50,52,57,59],bugfix:34,build:2,build_llvm_clang:17,build_sysimg:20,building:59,buildings:59,built:[3,6,9,11,14,21,25,26],builtin:[4,6,7],bulb:59,bulid:11,bulk:[7,50],bullet:[32,59],bullettrain_front:59,bullettrain_sid:59,bullsey:59,bullseye:59,bumpeq:59,bumpeqq:59,bumpy:59,bunch1977:74,bunch:[50,74],bunchkaufman:74,bundl:58,bunny:59,bus:59,busi:53,busstop:59,bust:59,bust_in_silhouett:59,busts:59,busts_in_silhouett:59,button:59,bypass:8,bytes2hex:76,c11:26,c153:74,c169:74,c1cb1c1:50,c394:74,c410:74,c_char_p:33,c_func:83,c_null:[26,67],cableway:59,cach:[6,8,12,21,26,45,47,50,51,52,64,71,75,77],cache_method:8,cachingpool:77,cactu:59,cactus:59,cake:59,calcul:[5,19,29,31,33,39,45,51,52,66,74,75,77,85],calendar:[31,59,68],calendr:31,call1:52,call_array3:52,call_dist:26,callabl:[4,8,28,33,39,46,65,73,77],calle:[26,28,29],caller:[4,12,15,18,26,29,35,45,49,51,52],calloc:72,callstack:55,came:1,camel:[57,59,60],camera:59,camp:[30,58],can:[1,2,5,6,7,8,11,12,13,14,15,17,18,19,20,21,22,25,26,27,28,29,30,31,32,33],cancel:[40,75],cancellation:59,cancer:59,candi:59,candid:[15,21,28,35,46,56,58],candra:59,candrabindu:59,candy:59,canin:85,cannot:[3,7,19,26,28,29,30,32,34,35,39,42,45,46,47,49,50,51,52,54,56,58,61,64,65,66,71,72,74,75,77,81],canon:[8,48,64,68,71,75,84],canonic:[68,69,84],cap:[52,59],capabl:[7,16,42,45,49,51,71,77],capac:66,capdot:59,capit:[39,48,57,60],capital:59,capital_abcd:59,capricorn:59,capricornu:59,captur:[1,8,45,47,51,53,54,56,77,84],capturedexcept:77,capwedg:59,car:[52,59],card:59,card_index:59,cardinal:59,cards:59,care:10,carefulli:[25,30,54],caret:59,carlo:51,caron:59,carousel:59,carousel_hors:59,carp:59,carri:[25,49,51,53],carriag:56,carriagereturn:59,cars:59,cartesianindex:[3,19,25],cartesianindex_2:25,cartesianrang:63,casefold:84,casino:31,cast:[26,33,39,46],castle:59,casual:42,cat2:59,cat:[18,25,50,59,63,64,85],catalan:76,catch_backtrac:[29,64],catch_block:1,catch_stacktrac:[55,83],catdoc:32,categori:[30,44,60,84],caught:[1,6,15],caus:[6,8,12,15,25,26,29,34,35,44,45,47,51,52,53,54,58,64,65,75,77,84,85],caution:[52,57,59,64],cbind:49,cbrt:[25,44,59,75],ccall:[6,7,9,11,18,21],cchar:[26,65],cconvert:[26,65],cdecl:26,cdll:33,cdot:59,cdotp:59,cdoubl:[26,65],cedilla:59,ceil:[25,31,44,50,52,57,68,75,85],ceiling:59,celebration:59,cell:[32,49],center:[8,32],centered:59,central:[43,46],centred:59,cenv_t:21,ceremony:59,certain:3,certainli:[8,54],cetera:75,cflag:33,cflags:[22,33],cfloat:[26,65],cfunc:77,cglobal:[26,65],cgutil:11,chain:[1,3,29,37],chang:[3,11,15,25,26,28,29,31,33,34,39,40,44,45,46,47,48,49],change_arrai:34,change_valu:34,changedfil:50,channel_from_id:77,chapter:[28,45,64],charact:[1,26,31,32,34,40,45,48,49,50,54],character:[26,59],characterist:[34,39,43,51,52],charg:29,chart:59,chart_with_downwards_trend:59,chart_with_upwards_trend:59,charwidth:84,cheatsheet:36,check:1,checkbound:[3,15,63],checkbounds_indic:3,checkbounds_log:3,checked_ab:75,checked_add:75,checked_cld:75,checked_div:75,checked_fld:75,checked_lib:47,checked_mod:75,checked_mul:75,checked_neg:75,checked_rem:75,checked_sub:75,checker:22,checkered_flag:59,checkindex:[3,15,63],checkmark:59,checksquar:63,cheering:59,chequered:59,cherri:59,cherries:59,cherry:59,cherry_blossom:59,chestnut:59,chi:59,chick:59,chicken:59,child:[33,53,54,55,58,64,85],children:[22,54,58,59],children_cross:59,chime:59,chines:56,chmod:69,chocolate:59,chocolate_bar:59,choic:[29,34,46,51,52,53,58,59,74,75,78,79,84],chol:74,choleski:[43,74],choleskypivot:[43,74],cholfact:74,cholmod:74,chomp:[54,71,84],choos:[34,46,50,51,53,57,58,63,71,75,82],chop:84,chosen:[25,29,31,35,47,51,52,66,74,75,77,82],chown:69,chr2ind:[56,84],christmas:59,christmas_tre:59,chunk:[7,26,51,58],church:59,cinema:59,cint:[21,26,65],cintmax_t:[26,65],circ:59,circeq:59,circl:8,circle:59,circlearrowleft:59,circlearrowright:59,circled:59,circledast:59,circledbullet:59,circledcirc:59,circleddash:59,circledequ:59,circledparallel:59,circledr:59,circledrightdot:59,circleds:59,circledstar:59,circledtwodot:59,circledwhitebullet:59,circlellquad:59,circlelrquad:59,circleonleftarrow:59,circleonrightarrow:59,circletophalfblack:59,circleulquad:59,circleurquad:59,circleurquadblack:59,circlevertfil:59,circshift:63,circular:[12,59],circularli:63,circulation:59,circumflex:59,circumst:[3,13,14,29,52],circumv:[6,50,52],circus:59,circus_t:59,cirfnint:59,city_sunris:59,city_sunset:59,cityscape:59,cjk:[36,59,60],claim:59,clamp:75,clang:[17,26,33,52],clap:59,clapper:59,clapping:59,clarifi:[52,57],clariti:[29,50],clark:46,clarke61:46,clash:45,classic:[26,31,35,54,58],classifi:[45,84],claus:1,cld:[44,52,75],clean:[7,9,29,31,50,61,64],cleaner:[39,57],cleanli:28,cleanup:[26,33,47,51,77],clear:[1,6,15,19,28,31,32,34,40,47,50,51],clear_malloc_data:[53,79],clearer:[32,39,53,58],clearest:49,clearli:[26,29,34,35,45,47,58],clever:[30,34,46],cleverest:34,clib:77,click:[36,40,50,59],client:[9,48,51,53,55,64,71],clientsid:48,clinking:59,clipboard:[59,64],clock1030:59,clock10:59,clock1130:59,clock11:59,clock1230:59,clock12:59,clock130:59,clock1:59,clock230:59,clock2:59,clock330:59,clock3:59,clock430:59,clock4:59,clock530:59,clock5:59,clock630:59,clock6:59,clock730:59,clock7:59,clock830:59,clock8:59,clock930:59,clock9:59,clock:[26,59,68],clockoint:59,clockwise:59,clonabl:50,clone:[49,50,78],clong:[26,65],clonglong:[26,65],close:[1,7,21,29,35,48,50,51,53,56,58,64,71,73,74,77],closed:59,closed_book:59,closed_lock_with_kei:59,closed_umbrella:59,closedvarcap:59,closedvarcup:59,closedvarcupsmashprod:59,closer:[16,34,49,74],closest:[21,28,35,46,56,58,64,74],closet:59,closing:59,clothes:59,cloud:[51,59],clover:59,club:59,clubsuit:59,cluster_cooki:[51,77],clutter:32,clwintegr:59,cmd:[1,45,51,54,64],cmd_gen:45,cmp:[34,75,77],cmpxchg:77,coalesc:26,coarser:68,coaster:59,cocktail:59,code_llvm:[16,52,64],code_llvm_raw:64,code_low:[16,52,64],code_n:[16,34,52,64,81],code_typ:[16,52,64],code_warntyp:16,codegen:[6,7,11,12],codepoint:84,coeff:46,coeffici:27,coexist:15,coffe:59,coffman:12,coin:51,col:[52,53,63],cold:59,cold_sweat:59,coll:[66,76],collabor:50,collect:[2,11,21,23,25],collection2:66,collector:[6,7],collid:50,collision:59,colon:[15,19,25,35,40,52,59,63,75],coloneq:59,color:[8,35,36],colptr:[25,64],column:15,columnwis:74,com:[48,50,74],combin:[7,8,19,27,28,29,30,33],combinatori:52,combining:59,come:[5,7,28,29,30,39,40,41,45,49,50,51,52,53,56,61,82],comfort:[34,50],comma:[25,26,45,58,59,61,71],commaminu:59,command:[6,7,9,11,20,22],comment:[11,14,21,28,45,49,50,56,68,71,80,84],comment_char:71,commit:[2,36,40,50,71,74],committe:51,commmon:58,common:[2,14,26,27,28,29,30,34,35,39,40,41,44,45,46,47,48,49,50,51,52,53,54],commonli:[1,14,25,39,51,56,58,66],commun:[50,51],compact:[5,35,42,43,58,71,74,84],compactli:[58,71,74],compar:[3,14,21,25,26,29,30,31,35,42,44,45,50,51,52,56,57,58,64,66,71,75,77,82],comparison:[1,3,25,26,27,29],compat:16,compens:63,compil:[1,2,3,6,7],compilecach:[36,47,64],complain:50,complement:[39,59,75],complementari:[44,75],complet:[6,14,18,25,26,28,30,32,34,35,36],complete_m:28,complex128:[26,74,76],complex64:[26,74,76],complex:[1,7,8,21,23,25,26],complic:[8,19,29,33,41,45,47,50,52,54],compon:[65,66,69,74,75,78,80],componentwis:74,compos:[7,32,56,84],composit:[26,27,28,46,47],composite_typ:8,compositeexcept:[29,77],compoundperiod:68,compq:74,comprehens:1,compress:[1,6],compris:[51,56],comput:[5,7,15,19,21,23,25,26,28,29,30,32,33,34,35,36,38,39,40,41,42,43,44,45,47,49,50],compute_dot:26,computer:59,conceiv:[21,52],concept:[43,46,57,58,61],conceptu:[8,46,56,58],concern:[8,34,45,61],concis:[29,35,52,57,64],conclud:[53,57],conclus:50,concret:[16,19,21,25,28,46,51,52,56,57,58,64],cond:[26,29,49,64,74],condit:1,condition:37,conditionexpr:5,condskeel:74,confetti:59,confetti_bal:59,confid:53,configur:[9,33,40,50,51],confirm:[58,69],conflict:[12,21],confound:59,confounded:59,confus:[30,31,34,47,49,50,53,56],confused:59,cong:59,congdot:59,congratul:[2,59],congratulation:59,congruent:[44,59],conical:59,conictap:59,conj:[27,63,75],conjquant:59,conjug:[49,63,74,75],conjugate:59,conjunct:[35,40,62,63],connect:[29,36,48,50,51,54,56,58,71,77],connect_at:51,connect_id:[51,77],connector:60,conqueq:74,conquer:74,conscious:30,consecut:[1,35,65,71],consecutive:59,consequ:[3,8,15,19,21,34,45,50,51,52,53,58,77],conserv:[50,52],consid:[3,5,8,13,15,19,21,22,26,28,29,30,31,33,34,35,41,44,45,47,48,49,50,51,52,53,56,57,58,61,64,65,68,71,74,77,82],consider:15,consist:[1,8,14,28,32,35,46,50],consol:[40,53,64],constant:[1,7,9,18,23,25],constantli:77,constitut:[21,51],constrain:[21,28,35],constraint:[21,28,46,74],construct:[1,5,6,12,14,19,21],construction:59,construction_work:59,consult:50,consum:[19,29,34,53,54,64,77],consumpt:64,contain:[1,2,3,5,7,8,9,13,14,18,19,20,21,25,26,28,29,31,32,33,35,41,45,47,49,50,51],containing:59,contains:59,contend:77,content:[6,9,20,26,28,32,33,34,45,47,48,50,54,62,64,69,71,75,77,78],context:[3,14,26,28,29,31,33,34,45,47,49,50,51,52,55,58,60,64,71,77,80,83,85],contigu:[19,52,58,84],continu:[1,9,15,21,28,29,30,31,42,46,48,49,52,53,56,68,74,77,85],contour:59,contrast:[21,25,26,34,35,45,49,50,51,52,53,58,61],contravari:58,contrib:[2,22],contribut:[2,22,34,50],contributor:50,contriv:[29,45,52,56],control:[1,7,23,25,26],conv2:75,conv:75,convei:[34,42,61],conveni:[5,13,15,16,19,21,25,27,28,29,30,31,33,35,44,45,46,48,49,50,51,52,56,57,58,61,63,66,68,69,71,74,77,83],convenience:59,convenience_stor:59,convention:15,converg:74,convers:[3,23,25],convert:[1,6,7,8,14,19,25,26,27,28,30,31,32],convolut:75,cook:[9,39,44],cooked:59,cookie:59,cooking:59,cool:59,cooper:[29,48,51],coordin:[8,19,29,44,58,75],cop:59,copi:[1,25,26,33,35,45,47,50,51,52,53,57,58,62,63,64,65,66,69,71,74,76,77,79,82,84],coprod:59,coproduct:59,copy_col:52,copy_col_row:52,copy_row:52,copy_row_col:52,copyast:[1,45],copyright:59,copysign:[8,25,44,75],cor:75,core2:20,core:[1,2,7,8,9,16,19,21,28],corn:59,corner:[50,59],corners:59,corpu:2,correct:[8,26,28,34,39,45,52,58,65,71,75,85],correctli:[19,25,26,30,32,44,47,50,56,72,85],correl:75,correspond:[1,6,8,14,18,19,21],corresponds:59,corrupt:[14,52,56,65],cosc:[25,44,75],cosd:[25,44,75],cosec:75,cosh:[25,44,75],cosin:[74,75],cospi:[25,44,75],cost:[17,34,39,45,53,62,75,82],cot:[25,44,75],cotang:75,cotd:[25,44,75],coth:[25,44,75],could:[8,12,15,19,25,26,28,29,30,31,32,34,35,36,39,40,41,44,45,46,47,48,51,52,53,56,57,58,64,68,71,83,85],count:[25,26,29,31,34,36,41,46,50,51,53,63,66,71,77,79,85],count_head:51,count_on:76,count_zero:76,counter:[11,34,47,53,61,64,66,77],counterintuit:[15,58],counterpart:[25,49,63],counterproduct:52,countfrom:66,countlin:71,countnz:[25,63],coupl:[15,51,52,59],couple:59,couple_with_heart:59,couplekiss:59,cours:[12,28,32,34,35,45,47,50,51,52,53,54,56,58,62],cousin:52,cov:[74,75],covari:[21,26,58,75],cover:[14,32,45,46,51,56,59,74],coverag:[36,53,78],cow2:59,cow:59,cplex:50,cpp:[6,7,11,26],cptrdiff_t:[26,65],cpu:[2,19,20,29,36,51,52,67],cpu_cores:[67,75,77,85],cpu_target:20,crack:28,cracker:59,crash:0,crazi:52,cream:59,creat:[1,2,5,7],creation:[7,14,28,35,69,75],credenti:51,credit:59,credit_card:59,crescent:59,crescent_moon:59,criterion:[31,74],critic:[3,8,16,26,51,52,74,77],crlf:[56,84],crocodil:59,crocodile:59,cross:[7,18,56,59,74,75],crossed:59,crossed_flag:59,crosshatch:59,crossing:59,crown:59,crucial:[22,34,42],cruft:50,cry:59,crying:59,crying_cat_fac:59,crystal:59,crystal_bal:59,cscd:[25,44,75],csch:[25,44,75],cshort:[26,65],csize_t:[26,65],cssize_t:[26,65],cstring:26,cstyle:6,csub:59,csube:59,csup:59,csupe:59,csv:[54,77],ct_eval_cal:53,ctime:[64,69],ctranspos:[35,74],ctrl:[32,64,65,77],cubatur:75,cube:[44,59],cuchar:[26,65],cuint:[26,65],cuintmax_t:[26,65],culong:[26,65],culonglong:[26,65],cumbersom:[48,56],cummax:63,cummin:63,cumprod:63,cumsum:63,cumsum_kbn:63,cumul:[53,63],cup:59,cupdot:59,cupid:59,cupve:59,curat:50,curiou:30,curl:[59,69],curled:59,curli:[1,58],curly:59,curly_loop:59,curlyeqprec:59,curlyeqsucc:59,curlyve:59,curlywedg:59,currenc:60,currency:59,currency_exchang:59,current:[1,5,6,7,8,9,11,20,21,22,25,26,29,33,34,36,41,46,47,48,49,50,51,52,53,54,55,56,58,59,61,64,65,66,67,68,69,71,72,73,74,75,76,77,78,79,82,83,84,85],current_modul:[9,26,47,64],current_task:[12,29,77],curri:59,curry:59,cursor:[32,40],curv:52,curve:59,curvearrowleft:59,curvearrowright:59,curving:59,cushort:[26,65],custard:59,custom:[3,10,11],customari:58,customary_phras:60,customize_color:40,customize_kei:40,customs:59,customtestset:85,customunitrang:15,cut:54,cwchar_t:[26,65,84],cwd:48,cwstring:26,cxx:[17,26],cxxflags:33,cyan:[40,71],cycl:66,cyclic:63,cyclon:59,cyclone:59,cyril:56,d7ff:56,dagger:59,dai:[31,36,40,68],daili:42,dalet:59,daleth:59,damag:[52,54],dan:34,dancer:59,dango:59,dark:59,darrai:51,dart:59,darwin13:[36,40],darwin:64,dash:[50,59],dashed:59,dashleftharpoondown:59,dashrightharpoondown:59,dashv:59,data:[1,3,6,7,11],data_cel:71,dataarrai:75,databas:31,dataflow:8,datafram:[49,50],datarootdir:[20,33],datatyp:[8,15,16,33,40,47,58,64],datatype_modul:64,date2epochdai:68,date:[2,23],date_str:31,dateformat:[31,68],datefunct:31,datetim:23,datetime2epochm:68,datetime2julian:68,datetime2rata:68,datetime2unix:68,david:39,dawson:[25,39,44,75],dayabbr:68,daylight:31,daynam:[31,68],dayofmonth:68,dayofquart:[31,68],dayofweek:[31,68],dayofweekofmonth:[31,68],dayofyear:[31,68],daysinmonth:[31,68],daysinyear:68,daysofweekinmonth:68,dbg:[16,64],dbkarow:59,dblarrowupdown:59,dct:75,ddagger:59,ddddot:59,dddot:59,ddot:59,ddot_:26,ddotseq:59,ddownarrow:59,ddthh:68,de77ee4dc0689b12c5e8b574aef7f70e8b311b0:50,dead:[12,64],deadlock:12,dealloc:26,dealt:31,debug_bootstrap:2,debugg:[6,21],debuginfo:[7,11],dec:[68,76],decad:42,decemb:68,decid:[7,28,35,50,51,52,53,57,58],deciduous:59,deciduous_tre:59,decim:[49,75,76],decis:[19,52,58],declar:[1,3,4,8,12,14,16,21,26,28,29,30],decod:71,decompos:84,decomposit:[25,43,74,84],deconv:75,decor:[32,71],decoration:59,decorative:59,decoupl:46,decreas:[52,53,71],decrement:77,dedent:56,dedic:[15,17,30,40,45],deem:[27,34,46],deep:64,deepcopi:[25,64],deepcopy_intern:64,deeper:[3,53],deepli:[15,29,34,45,53,58],deeply:59,def:[12,21],defalg:82,default_handl:85,default_meta:78,default_retry_max_delay:77,default_retry_on:77,default_sysimg_path:20,default_val:52,default_worker_pool:77,defaultclustermanag:77,defaulttestset:85,defaut:85,defeat:34,defer:71,defici:74,defin:[1,3,6,7,8,9,12,13,14,15,16,17,18,19,21,25,26,27,28,29],definit:1,definition:59,deflat:74,deg2rad:75,degeneraci:74,degrad:34,degre:[28,30,44,59,63,75],degree:59,del:59,delai:[35,53,64,79],delayed:59,deleg:[28,30,46,51,78],delet:6,deleteat:66,deliber:34,delicious:59,delim:[71,84],delimit:[31,32,36,47,49,56,68,71,80,84],delimiter:59,deliv:[65,77],deliveri:17,delivery:59,delta:[50,59,60],demand:[7,14,25,29,58],demonstr:[35,37,45,47,50,51,58],den:[8,27,28,30,58,75],denomin:[25,27,28,30,58,64,75],denorm:[52,76],denot:[34,49,58,85],densearrai:[21,25,40],densest:39,densiti:[25,63],dep:[2,11,78],department:[51,59],department_stor:59,departur:42,depend:[7,14,15,19,21,25,26,29,31,32,34,35,39,45,46,47,48,49,50,51,52,55,56,58,63,64,66,71,73,74,75,77,78,79,80],deploi:42,depth:[8,16,39,78,79],depwarn:36,dereferenc:49,deregist:[51,77],deriv:[25,44,52,64,74,75],desc:85,descend:58,describ:[5,6,7,8,15,17,19,21,22,26,27,28,29,32,33,34,35,39,40,41,42,47,50,51,53,56,58,61,67,71,74,75,77],descript:[9,25,26,32,39,41,44],descriptor:[54,69,71,77],deseri:[7,64,71,77],deserialis:9,deserv:28,design:[3,4,8,15],desir:[7,29,31,47,51,52,53,57,64,69,74,75],desk:59,despit:[21,34,46,53,58],dest:[15,63,65,69,74],destin:[25,64,65,66],destroi:[33,34,74],destruct:66,destructor:26,destructur:[35,56],det:[43,74],detach:64,detail:[7,14,15,16],detect:[17,21,22,34,53,61,71],detect_leak:17,determin:[2,6,7,19,25,26,28,29,30],determinist:[6,45,54],dev:[18,36,40,50,64],devector:[42,49],deviat:[75,76],devic:[47,52,64,69,71],devnul:[64,71],devot:7,dezh:59,dft:75,dht:75,diacrit:[60,84],diaeresis:59,diag:[49,74],diagdown:59,diagind:74,diagm:[49,74],diagnos:52,diagnost:[11,29],diagon:[43,49,58,63,74],diagonal:59,diagpoint:58,diagup:59,diamet:59,diameter:59,diamond:59,diamond_shape_with_a_dot_insid:59,diamondbotblack:59,diamondleftarrow:59,diamondleftarrowbar:59,diamondleftblack:59,diamondrightblack:59,diamondsuit:59,diamondtopblack:59,diassembl:11,dicei:59,diceii:59,diceiii:59,diceiv:59,dicev:59,dicevi:59,dict:[31,40,41,47,49,50,51,63,64,66,71,77,78,79],dictat:[30,58],dictchannel:51,dictionari:[32,35,40,47,50,51,52,57,63,64,66,71,77,78,79],did:[13,20,45,48,51,52,54,64,85],didn:[34,48,57],die:[31,59,68],diff:[19,50,63],differ:[1,8],difference:59,differenti:[58,75],differential:59,difficult:[31,34,35,52,57,58,61],difficulti:[28,34,58],dig:21,digamma:[25,44,59,75],digest:52,digit:[1,7,39,49,56,59,60,68,71,75,76,84],digraph:59,dim:[5,14,15,25,26,32,33,41,45,51,63,65,66,71,75,76,77,82],dimanch:31,dimens:[3,5,15,19,25,32,33,41,44,45,49,51,52,58,63,65,66,71,74,75,76,80,82],dimension:[15,19,23],dimensional:59,dimensionmismatch:[15,64],diminish:42,dingasterisk:59,dir:[36,50,64,69,77,78],direct:[2,16,20,25,26,27,29,45,47,50,58,59,74],directindexstr:40,directli:[1,7,8,11,14,18,19,25,26,27,28,29,30,32,33,39,41,42,45,47,50,51,52,53,54,57,63,64,71,74,78,82,85],directly:59,directori:[2,6,7,11,22,33,47,49,50,53,62,64,67,69,71,77,78],dirichlet:[44,75],dirnam:69,disabl:[1,12,22,33,36,47,52,64,65,71],disable_sigint:65,disadvantag:62,disallow:[36,60],disambigu:[46,56,57,79],disappear:[47,52],disappoint:59,disappointed:59,disappointed_reliev:59,disasm:11,disastr:19,disc:59,discard:[3,50,64],disclaim:45,disconnect:48,discontinu:75,discourag:[49,60,77],discov:[6,15,26,40],discret:[31,68,75],discuss:[16,19,21,29,30,32,35,39,45,46,48,50,52,53,56,58,64],disin:59,disjoint:51,disjquant:59,disk:[2,48,59,71,77],dispar:46,dispatch:[1,4,7,8,16,19,21,26,28,30,35,42,45,46,49],display:71,displays:71,dispos:51,disregard:47,disrupt:57,dist:26,distanc:[25,27,39,63,64],distinct:[1,4,15,21,28,29,31,34,41,45,46,47,51,56,58,61,66,75,84],distinguish:[8,21,31,44,45,49,51,64,82],distr:1,distribut:[2,7,22,25,33,34,42,49,50],div:[19,25,28,30,31,32,39,44,52,59,75],diverg:[50,75],divid:[28,30,31,32,39,44,51,57,74,75],divide:59,divideerror:[29,39,64],divideontim:59,divides:59,divis:[27,28,30,31],division:59,divisor:[28,44,75],divrem:[44,75],dizzi:59,dizzy:59,dizzy_fac:59,dl_load_path:[67,73],dlclose:73,dlext:73,dll:[20,73],dlopen:[26,73],dlopen_:73,dlsym:[26,65,73],dlsym_:73,dmemdebug2:22,dmemdebug:22,dns:71,do_cal:[9,55],do_comput:54,do_not_litt:59,do_quadgk:8,do_test:85,do_work:54,doc:[1,32,36,40,51,75,84],doc_str:32,docil:32,dockerenv:40,dockerinit:40,docstr:[3,32],docsystem:32,doctest:32,document:[5,8],doe:[1,8,9,12,15,19,21,22,25,26,27,28,29,30,31,32,33],does:59,doesn:[6,12,15,19,26,28,30,34,39,45,49,50,52,53,56,57,58,61,64,74,83],dog2:59,dog:[59,85],doi:74,doll:59,dollar:59,dolls:59,dolphin:59,domain:[42,48,49,50,51,52,63,64,71],domainerror:[26,27,29],domin:52,don:[8,15,19,25,26,28,31,34,45,50,52,54],done:[9,26,28,29,31,32,33,34,39,41,45,46,47,48,49,50,51,52,54,57,61,63,64,66,71,74,78],door:59,dot:[25,26],dotc:74,doteq:59,dotequiv:59,doth:64,dotless:59,dotminu:59,dotplu:59,dots:59,dotsim:59,dotsminusdot:59,dotted:59,dottedcircl:59,dottedsquar:59,dottim:59,dotu:74,doubl:[25,26,32,33,36,39,40,45,50,54,56,57,64,65,71,74],doublebarve:59,doubleplu:59,doubt:15,doughnut:59,dow:68,down:[2,8,9,29,31,34,40,53,55,59,66,69,72,77],downarrow:59,downarrowbar:59,downarrowuparrow:59,downdasharrow:59,downdat:74,downdownarrow:59,downharpoonleft:59,downharpoonright:59,downharpoonsleftright:59,downleftrightvector:59,downleftteevector:59,downleftvectorbar:59,download:[34,36,50,69],downrightteevector:59,downrightvectorbar:59,downsid:52,downwards:59,downwhitearrow:59,downzigzagarrow:59,dozen:[34,46],drafting:59,draftingarrow:59,dragon:59,dragon_fac:59,dramat:[19,51],draw:8,drawback:[34,58],drawings:59,drawn:75,drbkarrow:59,dress:59,drill:9,drink:59,drive:[51,69],driver:[51,63,77],droang:59,dromedary:59,dromedary_camel:59,drop:[19,25,63,66,69],droplet:59,drops:59,dropzero:63,dsfmt:53,dsfmt_gv_fill_array_close_open:53,dsol:59,dst:69,dt2:31,dth:68,dtruss:2,du2:74,dual:71,dualmap:59,duck:57,due:[2,8,12,26,29,34,40,50,51,52,53,54,57,64,68,85],dumbsum3:53,dumbsum:53,dummi:58,dummymodul:51,dump:[6,7,8,9,11,16,18,21,31,45,53,71],dup:74,duplic:63,dusk:59,dvd:59,dylib:[20,33,73],dynam:[1,7,8,11,23,26,30,32,33,35,40,42,45,46,47,49,51,52,56,58,64,70,71],dynamic_arch:2,e000:56,e10:39,each:[1,5,6,7,8,9,11,12,14,15,16,18,19,21,25,26,28,29,31,32,33,34,35,36,37,39,40,41,44,45,46,47,49,50,51,52,53,54,55,56,58,61,63,64,65,66,68,71,74,75,77,78,79,82,84,85],eachindex:[25,63],eachlin:[48,66,71],eachmatch:84,eagerli:49,ear:59,ear_of_ric:59,earli:[2,7,9,15,29],earlier:[6,15,28,50,52,77],ears:59,earth:[31,59,68],earth_africa:59,earth_america:59,earth_asia:59,eas:[42,55],easi:[8,17,19,21,25,26,29,32,35,39,40,42,45,50,51,55,57,58,64],easier:[5,29,35,37,47,48,49,50,51,57,58,66],easiest:[6,8,21,29,36,45,50],easili:[1,19,27,28,29,30,32,34,39,41,42,45,46,50,52,54,56,58,82],east:59,eax:34,ec2:51,echo:[18,36,40,45,48,50,54,64],ecosystem:[14,15,52],edg:[45,75,77],edge:77,edit:[16,32,50,60,64,78],edit_move_up:40,edite:40,editor:[50,56],ef45f54b:50,effect:[1,6,8,19,25,26,28,29,32,34,35,39,44],effici:7,efficient:42,effortless:27,egal:[14,64],egg:59,eggplant:59,egsdot:59,eiffel:58,eig:[43,74],eigen:[43,74],eigendecomposit:74,eigensolv:74,eigensystem:74,eigenvalu:74,eigenvector:74,eigfact:74,eight:[56,58,59],eight_pointed_black_star:59,eight_spoked_asterisk:59,eighteen:59,eighth:59,eighthnot:59,eigmax:[43,74],eigmin:[43,74],eigval:[43,74],eigvalu:74,eigvec:[43,74],eip:6,either:[1,3,5,11,15,21,22,25,26,28,29,30,31,32,34,35,36,41,44,45,46,49,50,52,56,57,58,61,63,64,65,69,71,74,75,77,84,85],elaps:[45,52,64,71],electric:59,electric_plug:59,electrical:59,eleg:39,elegant:42,element:[1,5,8,16,19,21,25,26,28,29,31],element_typ:[25,63,66],elementari:[23,27,29,30,38],elementwis:[25,35,44,66,75,77,80],eleph:59,elephant:59,eleven:59,elid:3,elig:61,elimin:[3,7,26,34,42,51,52,64],elint:59,ell:59,ellips:45,ellipse:59,ellipsi:35,ellipsis:59,elor:59,elroang:59,els:[1,5,7,8,9,22,28,29,30,34,35,37,42,44,45,46,47,50,51,52,56,58,60,71],elsdot:59,elseexpr:5,elseif:[1,5,19,29,35,37,52],elsewher:[32,63,71,75],eltyp:[3,8,25,26,41,52,63,66,74,76],eltypeunknown:[41,66],elzand:59,elzbar:59,elzbtdl:59,elzcirfb:59,elzcirfl:59,elzcirfr:59,elzclomeg:59,elzddfnc:59,elzdefa:59,elzdlcorn:59,elzdshfnc:59,elzdyogh:59,elzesh:59,elzfhr:59,elzglst:59,elzhlmrk:59,elzinglst:59,elzinvv:59,elzinvw:59,elzlap:59,elzlmrk:59,elzlow:59,elzlpargt:59,elzltlmr:59,elzltln:59,elzminhat:59,elzopeno:59,elzor:59,elzpalh:59,elzpbgam:59,elzpe:59,elzpgamma:59,elzpscrv:59,elzpupsil:59,elzrai:59,elzrarrx:59,elzreapo:59,elzreglst:59,elzrh:59,elzrl:59,elzrlarr:59,elzrtl:59,elzrtld:59,elzrtll:59,elzrtln:59,elzrtlr:59,elzrtlt:59,elzrtlz:59,elzrttrnr:59,elzrvbull:59,elzsbbrg:59,elzsblhr:59,elzsbrhr:59,elzschwa:59,elzsqfl:59,elzsqfnw:59,elzsqfr:59,elzsqfse:59,elzsqspne:59,elztdcol:59,elztesh:59,elztime:59,elztrna:59,elztrnh:59,elztrnm:59,elztrnmlr:59,elztrnr:59,elztrnrl:59,elztrnsa:59,elztrnt:59,elztrny:59,elzvert:59,elzverti:59,elzvrecto:59,elzxh:59,elzxl:59,elzxrat:59,elzyogh:59,email:[50,59],embed:[14,20,23,26],embed_exampl:33,emblem:59,emdash:59,emerg:30,emiss:7,emit:[3,7,34,36,47,52],emit_cal:6,emit_expr:[6,7],emit_funct:[6,7],emit_intrins:9,emit_known_cal:7,emoji:59,emphas:[45,57,64,77],emphasis:32,empiric:8,emploi:[5,21,74],empti:[8,13,21,25,34,36,40,45,46,48,51,56,58,63,64,66,67,69,73,74,77,80,82,84],empty:[25,32],emptyfunc:46,emptyset:59,emptysetoarr:59,emptysetoarrl:59,emptysetobar:59,emptysetocirc:59,emul:[54,77],enabl:[4,7,11,12,15,17,22,32,33,36,41,47,50,51,52,58,63,64,65,71,83,84],enable_broadcast:71,enc:53,encapsul:26,enclos:[1,25,32,45,47,49,61,64,71,77],enclosecircl:59,enclosediamond:59,enclosesquar:59,enclosetriangl:59,enclosing:59,encod:[19,56,60,71,75,76,84],encompass:61,encount:[2,7,8,35,39,45,47,50,56,58,69],encourag:[15,49,50,54,85],encrypt:51,end:[1,2,3,5,7,8,12,13,15,16,19,21,25,26,28,29,30,31,32,34,35,36,37,39,40,41,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,69,71,74,75,76,77,80,81,84,85],endash:59,ended:59,endian:71,endian_bom:[67,71],ending:59,endof:[35,40,41,56,57,66,84],endors:50,endpoint:75,endswith:84,enforc:[15,28,52,84],eng:59,engin:[39,50],engine:59,english:[31,56,68],enhanc:[39,50,62],enorm:[52,58],enough:[8,11,25,28,30,34,39,42,45,51,52,53,63,64,68,71],enqueu:66,enspac:59,ensur:[3,12,15,18,19,25,26,27,28,32,34,35,44,45,47,50,51,52,57,58,65,71,77,78,85],entail:[31,39,51],enter:[1,2,12,21,32,35,36,39,40,46,48,53,56,60,69],enthusiasm:52,entir:[1,7,19,21,22,25,28,29,32,34,45,48,50,51,53,55,56,58,71,74,75,77,80],entireti:71,entiti:21,entri:[1,8,19,21,25,29,40,44,49,50,58,63,66,69,74,75,77,78],entropi:76,entry:59,enumer:[8,34,49,52,57,64,66],enumnam:64,enumvalue1:64,enumvalue2:64,env:[21,26,40,64,67,78],envcolor:40,envelope:59,envelope_with_arrow:59,envhash:[64,66],eof:[48,71],eoferror:[29,64],eol:71,eparsl:59,ephemer:52,epochdays2d:68,epochms2datetim:68,epsilon:30,eq_float:52,eqc:21,eqcirc:59,eqcolon:59,eqdef:59,eqdot:59,eqeqeq:59,eqgtr:59,eqless:59,eqqgtr:59,eqqless:59,eqqplu:59,eqqsim:59,eqqslantgtr:59,eqqslantless:59,eqsim:59,eqslantgtr:59,eqslantless:59,equ:74,equal:[19,21,26,27,29,32,39,44,45,47,49,50,51],equalleftarrow:59,equalparallel:59,equals:59,equation:32,equiangular:59,equilbr:74,equilibr:74,equiv:59,equival:[14,15,18,21,25,26,28,29,32,34,35,36,39,40,44,45,46,48,49,50,51,52,56,58,61,63,64,65,66,67,68,69,71,74,75,76,77,78,82,84],equivalent:59,equivdd:59,eqvparsl:59,era:31,erf:[25,44,75],erfc:[25,44,75],erfcinv:[25,44,75],erfcx:[25,44,75],erfi:[25,44,75],erfinv:[25,44,75],err:[26,50,54,55,64],errno:[26,64,65,72],erron:39,error:1,errorcod:26,errorexcept:[6,29,54,64],esc:[13,26,32,45,64,71],escap:[32,45,54,56,64,68,71,84],escape_str:[71,84],esh:59,esoter:7,especi:[2,3,19,25,26,28,30,35,44,50,51,52,57,58,61,75,77],especial:50,essenc:52,essenti:[15,26,28,29,33,39,45,58,74],essential:[23,52],ession:45,establish:[33,48,50,51,77],estim:[64,74,75],estimat:74,estimate:75,estimates:59,esym:5,esym_1:5,esym_2:5,esym_n:5,eta:[25,44,59,75],etc:[2,6,18,25,31,34,40,44,47,48,49,51,52,54,56,58,65,68,72,74,75,77,78],etcetera:[28,35,58],eth:59,etymolog:7,euclidean:[74,75],euler:[59,75,76],eulerconst:59,eulergamma:76,eulers:59,euro:59,europe:59,european:59,european_castl:59,european_post_offic:59,ev_in:74,eval_bodi:55,eval_user_input:[53,55],evalfil:64,evalpoli:75,evalu:[1,5,7,8,9,16,25,26,29,33,35,36,39,40,44],evaluat:1,even:[6,14,15,19,21,26,27,28,29,30,31,32,34,35,39,40,42,45,46,47,48,49,50,51,52,53,54,56,57,58,59,60,61,63,64,66,71,74,75,76,84],evenli:31,event:[6,26],eventu:[21,29,35],eventual:7,ever:[8,28,30,46,52,58],evergreen:59,evergreen_tre:59,everi:[6,8,25,26,28,30,31,32,33,34,35,39,41,42,44,45,47,48,49,51,52,56,58,63,64,66,71,74,77],everydai:29,everyth:[6,8,30,31,33,44,50,52,56,58,64,69,71],everywher:[30,34,51,53,62,77],evil:59,ex1:45,ex2:45,ex3:45,exact:[25,27,35,39,57,58,71,75,79],exactli:[4,6,21,26,32,33,35,39,45,46,49,56,58,63,64,65,66,71,74,75,76],examin:[5,6,7,19,21,32,45,47,48,52,53,54,79],exampl:[1,3,5,6,7,8,9,11,13,14,15,16,17,19,20,21,25],exce:42,exceed:[39,75],excel:[34,39,44,56],except:[1,8,12,19,20,21,25,26,27,29,30,31,33,34,35,39,43,44,45,46,49,50,52,53,54,55,56,58,63,64,66,68,71,73,74,75,77,84,85],excerpt:[32,56],excess:[8,52,54],exchang:77,exchange:59,exclam:[59,64],exclamation:59,exclud:[50,56,64,74,75],exclus:[37,44,75,77],exec:[2,54],exec_program:9,execut:[2,5,6],exeflag:[51,77],exenam:[51,77],exhaust:[36,71],exhibit:[25,28,53],exist:[1,12],existingarrai:33,exists:59,exit:[6,7,29,35,36,40,51,64,74,77],exit_cod:7,exitcod:77,exp10:75,exp2:[25,75],exp:[25,27,29,44,58,75],expand:[1,5,7,8,16,19,25,26,32,34,45,63,64,66,69,75,84],expandus:69,expans:[7,19,33,45,55],expat:50,expect:[2,8,12,13,15,25,26,27,28,29,30,31,32,34,42,45,47,48,50,52,53,56,57,58,64,71,75,76,85],expedit:50,expens:[25,41,51,53,63,74,75,77],experi:[15,29,36,39,62],experienc:2,experiment:15,expert:[42,50,63],explain:[8,28,30,50,56,57,58,61,74],explan:[29,79],explic:47,explicit:[1,15,25,26,28,30,33,34,35,39,45,46,47,49,50,51,52,56,58,61,68,77,78],explicitli:[2,12,25,26,27,28,29,30,31,35,39,42,44,46,47,49,50,51,52,53,58,60,63,64,66,74,82,85],exploit:[15,25,58,63,71,75],explor:[45,58,74],explore:62,explos:52,expm1:[25,44,75],expm:[43,74],expon:[25,44,76,80],exponenti:[39,44,49,52,64,74,75,76],expos:[7,8,34,41,48],expr1:45,expr2:45,express:1,expressionless:59,ext:54,extact:74,extend:[7,30,32,33,34,35,41,42,47,51,63,67,74,75,80,84],extens:[28,32,39,41,42,47,50,56,58,73,82,85],extent:31,extern:[2,25,26,29,32,41,47,49,50,51,54,56,64,65,67,69,71,72,75,80,84],external:[23,38,51],extra:[15,19,25,26,35,41,45,50,52,53,55,58,61,71,77,85],extra_repl_keymap:40,extract:[5,6,8,13,14,19,21,27,33,35,45,49],extraordinarili:45,extraterrestrial:59,extrem:[8,30,45,50,52,53,56,58,60,64],extrema:[66,75],extyp:85,eye:59,eyeglass:59,eyeglasses:59,eyes:59,ezh:59,f77:26,f_improv:52,face:[59,74],facepunch:59,facil:42,facilit:[5,29,35,46,51,62,77],facing:59,fact:[28,29,31,34,35,45,51,52,53,54,57,58,68,74,75],factor:[2,17,27],factori:[29,39,44,59,75],factoris:74,factory:59,faddeeva:75,fail:[2,22,26,28,29,32,34,35,45,50,51,54,56,58,64,74,77,84,85],failur:[6,34,47,50,64,72,73,77,85],fairli:[19,28,29,51,55,64],faithfulli:30,fall:[28,30,46,58,75],fallback:[8,15,25,41,47,64,71,75,85],fallen:[58,59],fallen_leaf:59,falling:59,fallingdotseq:59,fals:[1,3,6,8,16,19,20,21,25,26,27,28,29,30,31,34,39,40,44,45,46,47,49,51,52,53,55,56,58,60,61,63,64,65,66,68,69,71,74,75,76,77,78,79,82,83,84,85],falsifi:29,famili:[8,50,58,59],familiar:[31,32,45,48,49,50,56,57],family:59,fan:75,fancier:41,faq:[49,57],far:[6,15,34,35,45,46,49,52,53,58,63,64,66],farther:39,fashion:[3,44,64],fast:[4,19,25,34,35,36,42,43,50,51,52,63,75,77,78,82],fast_forward:59,fast_unwind_on_malloc:17,fastcal:26,faster:[7,19,22,34,45,50,52,57,58,63,66,75,77,82],fastest:[51,75],fastmath:[36,52],fatal:77,father:[39,59],favor:[39,49,74],favorit:50,fax:59,fdiagovnearrow:59,fdiagovrdiag:59,fdio:71,fear:59,fearful:59,featur:[1,5,7,8,15,19,26,28,29,32,36,39,40,42,43,45,46,47,52,56,58,61,76],feb:[31,68],februari:[31,68],feed:[51,54,84],feedback:50,feeder:51,feel:[48,50,58],feet:59,felin:85,femal:59,female:59,feminine:59,femtolisp:[7,9,18,22],fenc:[32,77],fence:59,ferr:74,ferris:59,ferris_wheel:59,fetch:[8,45,51,52,53,54,57,64,69,77,79],fetchfrom:77,few:[2,3,5,6,15],fewer:[1,28,34,46,71],ffast:52,ffi:7,fft:[32,49,75],fftshift:75,fftw:75,field:[1,6,7,8,14,15,16,18],fieldnam:[16,58,64],fieldoffset:[16,64],fieldptr:14,fieldtyp:[8,64],fifo:69,figur:[2,6,31,50,52],file1:[47,51],file2:[47,51],file:1,file_fold:59,filefunclin:[53,79],filemod:69,filenam:[1,7,34,48,64,71,76,77,79],filepath:69,files:69,filesystem:[23,47,64],fill:[7,8,25,26,33,41,42,51,52,53,59,63,66,71,72,74,75,76],fill_two:52,fillval:52,filt:75,filter3:52,filter:[8,25,49,52,66,75],finally_block:1,find:[2,5,11,14,21,22,25,31,34,40,42,43,45,46,47,49,50,52,53,55,56,57,58,63,66,74,75,85],find_librari:73,findfirst:63,findin:66,findlast:63,findmax:66,findmin:66,findn:[25,63],findnext:63,findnz:[25,63],findprev:63,fine:[15,22,31,35,52,58,74],finer:[51,84],finish:[21,26,28,29,30,50,51,77,85],finit:[39,44,52,56,63,64,66,75,76],finite:59,finv:59,fire:[21,59],fire_engin:59,firewal:50,firework:59,fireworks:59,first:[1,2,3,5,6,7,8,11,12,13,15,19,21,25,26,28,29,30,31,32,33,34,35,36,40,41,42,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,63,64,65,66,68,69,71,73,74,75,76,77,78,79,82,83,84,85],first_quarter_moon:59,first_quarter_moon_with_fac:59,firstdayofmonth:68,firstdayofquart:68,firstdayofweek:[31,68],firstdayofyear:68,firstlast:58,fish:59,fish_cak:59,fishey:59,fisheye:59,fishhook:59,fishing:59,fishing_pole_and_fish:59,fist:59,fisted:59,fit:[32,34,42,44,49,52,58,71],fitzpatrick:59,five:[29,32,54,59,71],fix:[8,11,12,15,31,34,39,47],fixbar:50,fixbar_backup:50,fizz:85,fkeep:63,fl_ctx:6,fl_invoke_julia_macro:7,fl_print:[6,18],flag:[1,17,22,33,34,40,47,48,51,55,56,59,69,71,73,75,77,84],flags:59,flashlight:59,flat:[53,59,79],flatness:59,flatten:[19,52],flavor:51,flavour:32,fld1:75,fld:[14,44,52,75],fldmod1:75,fldmod:[44,75],flexed:59,flexibl:[5,28,29,39,42,45,46,51,58,60,71,82],flip:[35,51,75],flipbit:63,flipdim:63,flipsign:[44,75],flisp:[6,7,12,18],float16:[16,39,46,58,76,77],float32:[6,8,15,16,21,25,26,30,39,46,49,52,58,63,64,65,74,76,81],float64:[6,8,16,19,21,25,26,28,29,30,33,34,35,39,41,44,46,49,51,52,57,58,63,64,65,66,68,74,75,76,77,79,82,85],floor:[25,31,44,50,52,57,59,68,75],floorceil:68,flop:74,floppy:59,floppy_disk:59,flow:[1,23],flower:59,flower_playing_card:59,flowing:59,fltn:59,flush:[7,48,54,59,71,72],flush_cstdio:72,flushed:59,fluttering:59,fly:[48,63],fma:75,fmt:[33,40,52,71],fname:6,focu:[1,42,58],focus:[15,21,52],foggi:59,foggy:59,foist:34,fold:[76,84],folded:59,folder:[2,17,20,33,50,51,59],foldl:66,foldr:66,follow:[1,2,5,6,7,8,12,14,15,16,18,21,22,25,26,27,28,29,30,31,32,33,34,35,36,37,39,40,43,44,45,46,47,48,49,50,51,52,53,56,57,58,60,61,62,63,64,65,66,68,71,74,75,76,77,80,81,83,84],follow_symlink:69,font:59,foo:[1,8,21,26,28,29,30,32,34,35,36,45,46,47,50,52,54,57,58,61,63,64,65,66,77,85],foo_data:47,foo_data_ptr:47,foo_init:47,foobar:[26,50,77],food:59,foomanag:51,foot:7,footbal:59,football:59,footprint:59,footprints:59,fopen:[37,71],foral:59,forbid:58,forc:[6,15,20,31,33,34,49,50,51,52,53,54,57,61,64,69,71,79],force:59,forces:59,foreach:66,foremost:19,forest:8,forev:66,forget:50,forgo:63,forgot:50,fork:[6,50,54,59],fork_and_knif:59,forking:59,forksnot:59,forkv:59,formal:[31,74],format:[18,19,25,26,30,31,32,39,40,50,53,58,68,71,72,74,75],format_str:31,formatmessag:72,former:[35,52,54,56],formerli:52,forms:59,formula:[39,41,74],forth:[29,50],fortran90:26,fortran:[15,23,25],fortun:[8,19,42,51,56],forum:51,forward:[40,50,51,52,61,66,74,76,78],forwardord:66,found:[1,8,13,14,21,25,28,29,31,32,33,34,35,40,43,47,48,49,50,52,56,58,63,71,74,77,83,84],fountain:59,four:[4,16,30,32,40,52,56,58,59,63,68,74,82,84],four_leaf_clov:59,fourier:75,fourth:[19,30,46,53,59],fourthroot:59,fpart:75,fpic:[26,33],fptosi:52,fptr:[6,8],fptrunc:6,frac:32,fraction:[44,59,75],fragment:[7,45],fraktur:59,frame:[6,9,12,33,49,55,83],free:[1,12,26,33,34,39,42],freed:[26,33,51,64,72,84],freeli:[50,58],french:[31,59],french_daysofweek:31,frequent:[9,23,29],fresh:[36,40,50,53],freshli:61,frexp:75,fri:[59,68],fricative:59,fridai:[31,68],fried:59,fried_shrimp:59,friendli:11,fries:59,frobeniu:74,frog:59,from:[1,2,3,4,5],from_c:[55,83],front:[1,8,51,52,58,59],frown:59,frowning:59,frozen:7,fruit:[49,64],frustrat:15,fs_caveat:71,fuel:59,fuelpump:59,fuji:59,full:[2,7,16,18,22,25,27,31,39,40,45,47,49,50,51,52,53,56,58,59,63,64,67,68,69,74,77],full_moon:59,full_moon_with_fac:59,fulli:[7,26,28,29,34,40,47,52,56,58,61,64,66,82],fullnam:64,fullouterjoin:59,fun:26,func10:45,func:[5,26,32,33,35,45,52,55,64,68,77,83],funcnam:79,function_modul:64,function_nam:[33,64],function_point:65,functional:59,functionloc:64,functionobject:6,functiontyp:26,functor:46,fundament:[21,28,31,58],further:[3,8,14,16,22,29,31,33,34],furthermor:[26,35,49,51,57,75],fuse:[35,52],fusion:35,fuss:31,fussi:29,fussy_sqrt:29,futur:[7,15,17,26,32,34,35,46,47,50,51,52,57,66,73,74,77,79,81],fwrite:18,gadfli:50,gain:[25,26,58],gambl:31,game:[31,59],game_di:59,gamma:[25,44,59,75],gamut:27,gap:[64,66],garbag:[6,7],garden:59,gather:52,gauss:75,gaussian:25,gbmv:74,gbsn:60,gbtr:74,gbtrf:74,gc_enabl:64,gc_perm_lock:12,gcc:[20,26,33,34],gcd:[28,44,75],gcdx:75,gdb:[0,2],gebak:74,gebal:74,gebrd:74,gecon:74,gee:74,geev:74,geevx:74,gehrd:74,gel:74,gelqf:74,gelsd:74,gelsi:74,gem:59,gemini:59,gemm:74,gemqrt:74,gemv:74,gener:[1,2,4,5],generalizedeigen:74,generalizedschur:74,generalizedsvd:[43,74],gensym:[26,45,64],geometric:59,geometrically:59,geqlf:74,geqp3:74,geqq:59,geqqslant:59,geqrf:74,geqrt3:74,geqrt:74,geqslant:59,ger:74,gerqf:74,gescc:59,gesdd:74,gesdot:59,gesdoto:59,gesdotol:59,gesl:59,gesture:59,gesv:74,gesvd:74,gesvx:74,get:[2,5,6,7,11,12,13,14,15,19,21,23,25,26,28,29,31,33,34],get_process_titl:64,get_testset:85,get_testset_depth:85,get_year:52,get_zero_subnorm:76,getaddrinfo:[48,71],getenv:26,getfield:[8,52,64],gethostnam:[26,64],getindex:[3,19,25,26,35,41,46,51,56,57,63,66,71],getipaddr:64,getkei:66,getlasterror:72,getpid:64,getr:74,getrf:74,getri:74,getsocknam:71,getstdout:47,gflop:52,gge:74,ggev:74,ggg:59,gggnest:59,gglse:74,ggsvd3:74,ggsvd:74,ghost:[4,59],ghz:52,gibbous:59,gid:[64,69],gift:59,gift_heart:59,gigabyt:34,gimel:59,girl:59,gist:2,git:[50,78],github:[2,50,74,78],gitignor:50,give:[1,16,20,25,26,27,28,31,32],given:[1,3,6,7,8,12,13,15,16,19,20,25,26,28,29,30,31,32,34,35,36,39,40,45,46,47,48,50,51,53,55,56,58,63,64,65,66,68,69,71,72,74,75,76,77,78,79,82,83,84,85],gla:59,glass:59,gle:59,glj:59,glm:49,global:[1,9],globalref:[1,52],globe:59,globe_with_meridian:59,gloss:56,glottal:59,glowing:59,glue:26,glyph:59,gmp:39,gmt:68,gnapprox:59,gneq:59,gneqq:59,gnsim:59,gnu:[2,26,33,39,73,76],goal:[49,71],goat:59,goblin:59,goe:[1,2,29,50,54,63,64],goertzel:75,goldberg:39,golden:76,golf:59,good:[6,21,28,31,32,42,47,50,51,52,53,56,59,62],goodby:[56,84],googl:48,got:[34,58,64],gotcha:[26,58],gotoifnot:1,gotonod:1,gotta:8,gperm:69,gracefulli:[7,34,56],gradient:63,gradual:58,graduation:59,grain:[58,74],grandpar:55,grant:52,grape:59,grapes:59,graph:58,graphem:84,graphic:[53,71],grave:59,great:[40,44,45,48,58],greater:[26,28,29,30,31,32,39,44,50,56,59,60,64,66,68,71,74,75,77,82,84],greatest:[26,28,44,50,58,75],greatli:[2,52],greedi:64,greedili:64,greek:[56,59],green:[40,42,59,71],green_appl:59,green_book:59,green_heart:59,greet:[36,40,56],gregorian:[31,68],grep:[54,64],grew:64,grey_exclam:59,grey_quest:59,grid:25,grimac:59,grimacing:59,grin:59,grinning:59,group:[8,11,26,31,56,64,66,69,71,84,85],groupnam:56,grow:[8,39,49,53,64,71],growing:59,grown:71,growth:74,gsime:59,gsiml:59,gsl:26,gsl_permut:26,gsl_permutation_alloc:26,gsl_permutation_fre:26,gsl_sf_bessel_jn_arrai:26,gtcc:59,gtcir:59,gtquest:59,gtrapprox:59,gtrdot:59,gtreqless:59,gtreqqless:59,gtrless:59,gtrsim:59,gtsv:74,gttr:74,gttrf:74,gua:59,guarante:[15,19,25,26,28,29,35,57,58,64,65,66,75],guard:34,guardsman:59,guess:[31,52,74],guid:[2,23],guidanc:50,guidelin:34,guillemet:59,guilsinglleft:59,guilsinglright:59,guitar:59,gun:59,gvertneqq:59,h05:74,habit:50,hacek:59,hack:[8,18],had:[47,48,50,52,53,55],hadamard:49,hair:59,haircut:59,half:[25,34,39,59,74,75,82],halfcomplex:75,halo:59,halv:75,hamburg:59,hamburger:59,hammarl:74,hammer:59,hamster:59,hand:[4,6,7,11,15,28,29,30,31,34,35,36,39,41,42,44,45,49,50,51,58,59,61,74],handbag:59,handi:[13,25,29,35,45,56],handl:[3,6,7,8,9,11,15,18,19,21,23,26],handle:59,handler:[1,8,9,18,29,36,58,65],handoff:7,hands:59,handshak:77,hankei:59,hankel:[44,75],hankelh1:[25,44,75],hankelh1x:[44,75],hankelh2:[25,44,75],hankelh2x:[44,75],happen:[1,3,19,21,29,30,31,32,33,34,35,45,48,51,52,53,54,56,57,58,63,64,74,77,85],happi:50,happy:59,har:51,hard:[5,34,36,45,50,52,60],harder:[52,57],hardest:7,hardli:30,hardwar:[39,51,52,76],harm:[26,27],harpoon:59,hartlei:75,haseltyp:[41,66],hash:[8,21,44,47,49,50,64,66],haskei:[57,66],haskel:58,haslength:[41,66],hasn:50,hasplain:28,hasshap:[41,66],hassl:50,hat:[40,59,60],hatapprox:59,hatched_chick:59,hatching:59,hatching_chick:59,have:[1,2,3,5,8,13,14,15,16,17,19,21,25,26,27,28,29,30,31,32,33,34,35,36,39,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,60,61,62,63,64,66,68,71,72,74,75,76,77,78,79,84,85],haven:[47,50,52],haystack:84,hbar:[40,59],hc2r:75,hcat:[1,25,35,49,63],hdf5:71,head:[1,8,45,59],headach:44,headed:59,header:[2,14,26],header_cel:71,headphon:59,headphone:59,heap:[33,34,47,65],heapifi:66,heappop:66,heappush:66,hear:59,hear_no_evil:59,heart:[21,59],heart_decor:59,heart_ey:59,heart_eyes_cat:59,heartbeat:59,heartpuls:59,hearts:59,heartsuit:[40,59],heatflow:52,heavi:[18,21,28,48],heavili:[19,21,32],heavy:59,heavy_check_mark:59,heavy_division_sign:59,heavy_dollar_sign:59,heavy_minus_sign:59,heavy_multiplication_x:59,heavy_plus_sign:59,hebrew:56,heeled:59,held:[12,15,28,40,51,77],helicopt:59,helicopter:59,hello:[9,18,40,45,48,52,54,56,58,60,64,84],help:[2,6,15,21,22,26,31,32,34,35,36],help_color:40,helper:[7,26],henc:[19,21,29,31,47,51,53,58,63,64,65,74],her:74,herb:59,here:[2,3,5,6,8,11,12,13,14,15,19,21,25,26,28,29,30,31,32,33,34,35,39,40,44,45,46,47,48,50,51,52,53,54,56,57,58,61,62,64,66,76,77,80,82,85],herk:74,hermaphrodit:59,hermitconjmatrix:[40,59],hermitian:[43,59,74],hessenberg:[43,74],hessenbergq:74,hessfact:74,hesv:74,heterogen:[25,71],hetr:74,hetrf:74,hetri:74,heurist:[7,8],hex2byt:76,hex2num:76,hex:[39,49,76],hexadecim:[39,49,56,76,84],hexagon:59,hexagonblack:59,hibiscu:59,hibiscus:59,hidden:[8,45,47,64,85],hide:[26,37],hierarch:[50,58],high:[17,26,29,32],high_bright:59,high_heel:59,higham:74,higher:[2,6,8,19,25,29,31,45,49,51,57,63,64,74,75,76],highest:[42,44,54,64,66],highli:[14,42,50,52,58,74,75],highlight:[16,32,39],hindi:56,hint:[1,8,13,45,48,52,71],hist:40,histori:[36,39,40,50],history_next:40,history_prev:40,hit:[2,12,36,40,50,59],hksearow:[40,59],hkswarow:[40,59],hlower:74,hocho:59,hoist:[7,52],hold:[8,12,21,26,28,30,33,41],holding:59,hole:[52,59],holidai:31,home:[2,36,40,50,51,62,69,77],homebrew:50,homedir:[69,78],homer:36,homogen:[4,26,52,81],homothetic:59,honda:52,honest:31,honey:59,honey_pot:59,honeybee:59,hood:21,hook:[9,43,59,64],hookleftarrow:[40,59],hookrightarrow:[40,59],hoop:59,hop:51,hope:5,hopefulli:[7,15,19,45],horizontal:59,horn:59,horner:75,horns:59,hors:59,horse:59,horse_rac:59,hospit:59,hospital:59,host:[17,26,33,36,48,50,51,64,71,77,78],hostnam:[26,51],hot:[41,59],hotel:59,hotspr:59,hour:[22,31,56,68,72],hourglass:59,hourglass_flowing_sand:59,hous:59,house:59,house_with_garden:59,household:74,how:[6,7,8,9,19,21,25,26,28,29,30,31,32,33],howev:[1,2,3,5,6,8,9,14,15,18,19,21,25,26,27,28,29,30,31,32,33,34,35,39,41,42,44,45,46,47,48,50,51,52,53,54,56,58,60,61,63,64,65,66,71,74,75,76,77,81,85],howmni:74,hrectangl:59,hrectangleblack:59,hslash:[40,59],hspace:[40,59],html:[32,50,58,71,74,84],html_str:84,htol:71,hton:71,http:[32,34,36,40,50,51,71,74,75,78],http_get:64,hub:50,huge:3,human:[1,31,45,55,68],hundr:52,hundred:59,hupper:74,hurt:58,hurwitz:75,hush:59,hushed:59,hvcat:[25,35,49,63],hvcat_fil:52,hwloc:67,hybrid:34,hyndman:75,hyperlink:50,hyphen:[59,84],hypot:[8,25,35,44,75],hypotenus:[35,44,75],i64:16,i686:6,i_1:[5,25],i_2:[5,25],i_3:[5,25],i_d:5,i_j:5,i_k:25,i_n:25,ia1:3,iana:31,iblock:74,iblock_in:74,ice:59,ice_cream:59,icecream:59,icon:50,idct:75,idea:[7,28,32,35,50,52,53,58,62],ideal:[34,39,57],ident:[21,25,26,27,28,32,35,43,44,45,51,52,54,56,58,61,63,64,66,71,74,75,76,77,84],identical:59,identifi:[1,14,15,26,27,32,35,39,41,45,46,47,49,50,51,52,53,56,58,60,77],ideograph:59,ideograph_advantag:59,idiom:[29,56],idiomat:[33,35,46,49,57],idl:77,idx:[51,52,84],ieee:[36,39,44,52,74,75,76],if_fals:80,if_tru:80,ifels:[52,64],iff:64,ifft:75,ifftshift:75,ifst:74,iftru:65,ignor:[1,6,36,40,45,47,50,56,64,71,73,74,75,84],ignorestatu:64,ihi:74,iid:[25,75],iii:75,iiiint:59,iiint:59,iint:59,ijulia:[32,36,58,62,71],ill:74,illus:35,illustr:[29,32,45,47,52,53,58],ilo:74,ilst:74,imag:[7,8,9,14],image_fil:[7,9],imagin:[15,31,45,50,51,52],imaginari:[27,28,44,49,74,75,76],imath:59,immedi:[8,26,28,29,34,35,36,39,44,45,46,47,51,54,56,58,64,72,77,85],immediat:[50,64],immintrin:26,immut:[7,8,19,26,28,31,32],immutabl:26,imp:59,impact:52,imper:[26,29,32,35,42,50],implement:[1,7,8,13,14],impli:[7,17,21,28,30,36,39,44,46,50,52,58,64,74],implic:58,implicit:[26,28,29,51],implicitli:[12,15,19,26,46,47,51,58,64,74],important:41,importantli:19,impos:[21,42,58,60,75],imposs:[33,34,45,52,58],imprecis:85,improp:58,improv:[3,11,20,26,33,34,50,52,53,54,58,66,74,75],imul:34,inabl:34,inadvert:58,inappropri:58,inbound:1,inbox:59,inbox_trai:59,inbuilt:51,inc:34,incant:2,incept:42,inci:[26,74],includ:[1,2,3,5,6,7,8,12,15,16,19,20,21,22,25,26,29,30,31,32,33,34,35,36,37,39,41,42,44,45,47,49,50,51,52,53,55,56,58,60,62,63,64,65,67,68,69,71,74,75,77,82,84,85],include:[2,20,32,47,84],include_depend:[47,64],include_str:64,including:59,inclus:[11,31,66,77],incom:[48,51,77],incoming:59,incoming_envelop:59,incompat:[17,47],inconsist:[26,59,64],inconveni:[30,34],incorpor:50,incorrect:[15,19,45,50,64,65,74,76],incorrectli:52,increas:[25,31,52,53,58,63,64,71,74,75,77],increases:59,increment:[31,34,36,40,47,50,59,66,68],incur:[17,39,45,52,53],incx:[26,74],ind2chr:[56,84],ind2sub:[15,19,63],ind:[15,41,45,63,66],inde:[8,19,21,35,63,66,82],indeed:[8,34,52],indefinit:74,indent:[32,45,47,53,56],indentat:[49,53],independ:[25,26,45,51,53,58,63,64,77,79,82],indetermin:26,index:[1,3,5],indexexpr:5,indexin:[57,66],indexoffset:15,indexpid:[51,77],indic:[1,2,3,10],indicat:85,indicator:59,indice:3,indices1:15,indirect:19,indirectli:25,indistinguish:[46,82],individu:[3,32,34,35,47,50,51,52,53,55,58,66,68,74,84],indmax:[63,66],indmin:66,induc:74,indxin:57,ineffici:[25,56,61],inequ:44,inertia:74,inevit:[30,54],inexact:[44,75],inexacterror:[28,29,30,44,58,64,74,75],inf16:[39,76],inf1:8,inf2:8,inf32:[39,76],inf:[27,39,44,52,74,75,76],infer:[1,6,7,8,12,16,25,28,40,42,45,52,53,61,64,65,66,75,85],inference0:8,infin:[39,44,74,75,76],infinit:[8,27,44,64,75,76],infinity:59,infix:[29,30,35,60,64],influenc:51,inform:[2,3,7,8,11,13,14,19,21,26,28],informat:33,information:59,information_desk_person:59,information_sourc:59,infrastructur:[13,18,50,51,85],infrequ:53,infti:59,ing:[41,51,64],inher:57,inherit:[18,25,41,58,61,71,76,85],init:[9,18,50,51,52,53,66,77,78,79],init_stdio:18,init_work:[51,77],initerror:[29,64],initfn:[51,77],initi:[6,7,8,14],initial:8,initialis:9,inject:52,ink:[59,84],inlin:[1,3,7,13,26,29,32,34,36,52,53,55,56,57,64,75,77,83],inline:1,inner:[1,3,19],innermost:[25,52,83],innersimd:52,innoc:[31,52,59],innocu:[28,45],inod:[64,69],inplaceop:49,input:[1,19,21,23,25],input_color:40,inputindex:19,insan:45,insensit:[56,64,84],insert:1,insertionsort:82,insid:[1,2,3,7,12,13,21,25,26,28,29,30],inside:[35,54,59,61],insist:51,instabl:[34,52,58,64],instal:[33,36,47,50,51,77,78,85],instanc:[1,3,8,14,21,22,25,26,28,29,30,32,33,40,41,43,44,45,46,47,49,51,52,54],instant:[31,68],instanti:[21,26,58,80],instead:[1,3,4,7,8,13,14,16,19,21,25,26,27,28,29,30,31,32,34,35,39,41,44,45,46,47,48,49,50,51,52,54,55,56,57,58,60,61,62,63,64,66,68,69,71,73,74,75,76,77,82,84],insteadof:50,instrm:77,instruct:[2,3,7,9,13,20,26,34,36,42,50,52,53,58,64,77,79,81],instrument:[17,53],insuffici:[22,76,77],int128:[34,39,40,46,49,58,76,77],int128_str:1,int16:[26,39,40,46,58,65,76],int32:[9,25,26,28,30,32,39,40,46,49,52,56,57,58,64,65,66,74,76],int32_t:[8,33],int64:[16,19,21,25,26,27,28,29,30,31,32,34,35,39,40,41,44,45,46,49,51,52,56,58,61,63,64,65,66,68,71,74,76,82,83,85],int8:[8,21,25,26,30,39,40,44,46,58,75,76,77],int_:32,intbar:59,intcap:59,intcup:59,integ:[1,5,9,18,19,21,25,26,27,28,30,31,32,33],integer:[15,16,18,21,23,25,26,28,30,32,36,38],integr:[27,28,33,54,58,71,75],integral:59,integrand:75,integration:59,intel:[2,52],intellig:[32,50,56],intend:[3,5,25,26,37,44,47,50,51,53,60,64,65,66,74,81],intens:[11,42,52],intent:[47,50,51,61,64],intention:[26,45],inter:25,interact:[6,7,14,21,23,26,27,29,33,35,36,38,39],interc:59,intercalate:59,interchang:[49,58],interconvert:25,interest:[11,15,16,21,26,28,34,39,45,50,54],interfac:7,interior:59,interleav:59,intermedi:[1,16,52,63,66,75],intermediari:19,intermitt:85,intern:[1,6,12,16,19],internet:50,interoper:[30,34,39],interpol:[16,19,32,39],interpret:[6,7,9,11,19,25,29,30,32,35,39,42,44,45,47,50,52,53,54,55,56,63,64,68,71,77,78,84],interrobang:59,interrog:16,interrupt:[29,40,51,64,65,77],interruptexcept:[29,64,65],intersect:[21,46,52,64,66],intersect_tupl:21,intersecting:59,intersection:59,interv:[8,25,43,50,53,64,74,75,76,78],interval_:71,interven:[35,54],interview:39,intfunc:34,intmax_t:[26,65],intorstring:58,intprod:59,intprodr:59,intract:19,intrins:[3,7,9,11,26,41,63,64],intrinsic:[7,9],introduc:[26,28,29,34,39,40,45,46,47,51,53,54,56,57,58,61],introductori:[36,53],intset:66,intuit:[11,58,61],intuitiv:58,intx:59,inv:[43,64,74,75],invalid:[3,7,25,26,27,28,33,34,37,47,51,52,56,64,65,76,84],invalidstateexcept:29,invalu:45,invari:[19,21,28,58,74],invdigamma:75,invers:[12,25,44,63,66,74,75,78],inverse:59,inversewhitecircl:59,invert:74,inverted:59,investig:[22,40],invis:30,invmod:75,invnot:59,invok:[1,6,7,8,12,28,29,30,33,35,45,46,47,48,49,53,54,58,64,71,80,82],invoke:64,involv:[7,8,11,19,30,34,47,48,51,57,58,61,62,64,74],invperm:63,invwhitelowerhalfcircl:59,invwhiteupperhalfcircl:59,iobuffer:[51,71,84],iocontext:[48,71],ios_init_stdstream:9,ios_stdout:6,ios_t:18,ios_writ:18,iostream:[18,40,48,71],iota:59,ipaddr:[64,71],ipart:75,ipermut:63,ipermutedim:63,iphon:59,ipiv:74,ipv4:[48,71],ipv6:[48,71],ipv6onli:71,ipython:71,irang:[51,74],irfft:75,irregular:31,irrelev:[45,61],irrespect:77,is_appl:[37,64],is_assigned_char:84,is_bsd:[37,64],is_linux:[37,64],is_unix:[37,64],is_window:[37,64],isa:[8,13,15,19,29,44,45,52,57,58,64],isabspath:69,isalnum:84,isalpha:84,isapprox:[75,85],isascii:84,isassign:[63,64],isbit:[14,16,26,47,58,64],isblockdev:69,ischardev:69,iscntrl:84,isconst:64,isdefin:[8,34,64],isdiag:74,isdigit:84,isdir:69,isdirpath:69,isdst:72,isempti:[45,66],isequ:[27,44,57,64,66],iseven:[35,52,61,63,76],isfifo:69,isfil:[62,69],isfinit:[25,44,76],isgn:74,isgraph:84,isheap:66,ishermitian:74,isimag:76,isimmut:64,isin:59,isindot:59,isine:59,isinf:[8,25,30,44,76],isinfinit:[41,66],isinobar:59,isinteg:76,isinteract:[36,64],isinvb:59,isleaftyp:64,isleapyear:[31,68],isless:[64,75,82],islink:69,islock:77,islow:84,ism:[56,84],ismark:71,ismatch:[56,84],ismount:69,isn:[21,26,30,34,50,54,58,64],isnan:[25,30,44,64,76],isnul:[58,64],isnumb:84,iso:[31,68],isodd:[61,63,66,76],isol:[5,11,49,52],isopen:[48,64,71],ispath:69,isperm:63,isplit:74,isplit_in:74,isposdef:74,ispow2:[25,34,75],isprecompil:64,isprint:84,isprocess:58,ispunct:84,isqrt:75,isread:71,isreadi:[51,77],isreadonli:71,isreal:76,issetgid:69,issetuid:69,issocket:69,issort:82,isspac:[71,84],isspars:[25,63],issticki:69,issu:2,issubnorm:76,issubset:66,issubtyp:[8,57,64],issue8859:74,issue:74,issymmetr:74,istaskdon:[29,77],istaskstart:[29,77],istextmim:71,istream:71,istril:74,istriu:74,istuesdai:31,isupp:[74,84],isva:1,isvalid:[56,84],iswrit:71,isxdigit:84,isym:5,ital:[32,58],item:[21,32,41,49,51,52,64,66,71,75,77],iter1:1,iter2:1,iter:[1,5,9],iteratoreltyp:[41,66],iterators:[41,66],iteratorsmd:25,itersym:5,itertyp:[41,66],ith:65,itr:66,its:59,itself:[1,7,8,12,15,16,20,21,25,26,28,32,34,36,39,41,42,44,45,46,47],ityp:74,izakaya:59,izakaya_lantern:59,j_1:5,j_2:5,j_d:5,jack:59,jack_o_lantern:59,jan:[31,68],januari:[31,68],japan:59,japanes:56,japanese:59,japanese_castl:59,japanese_goblin:59,japanese_ogr:59,jargon:50,java:[29,30,31,34,46,49,56,58,75],javascript:[31,75],jean:59,jeans:59,jeudi:31,jl_:[4,6,21,33],jl_add_standard_import:9,jl_alloc_array_1d:[14,33],jl_alloc_array_2d:[14,33],jl_alloc_array_3d:14,jl_alloc_tupl:14,jl_alloc_vec_ani:14,jl_any_typ:9,jl_appli:[6,8,9,55],jl_apply_array_typ:[14,33],jl_apply_gener:[6,8,9,55],jl_apply_typ:14,jl_args_morespecif:21,jl_array_data:33,jl_array_dim:33,jl_array_len:33,jl_array_ndim:33,jl_array_t:[14,33],jl_ast_context_list_t:12,jl_atexit_hook:7,jl_backtrace_from_her:55,jl_base_modul:[9,33],jl_bottom_typ:21,jl_box_:33,jl_box_float32:33,jl_box_float64:33,jl_box_int32:33,jl_box_uint16:14,jl_box_uint8:9,jl_breakpoint:[6,21],jl_call0:33,jl_call1:33,jl_call2:33,jl_call3:33,jl_call:[8,33],jl_call_method_intern:55,jl_callable:4,jl_compil:6,jl_compile_al:9,jl_core_modul:9,jl_critical_error:6,jl_current_task:9,jl_datatype_t:[9,14],jl_dump_llvm_valu:6,jl_egal:14,jl_error:[6,33],jl_errorf:33,jl_eval_str:[6,33],jl_exception_in_transit:1,jl_exception_occur:33,jl_expand:7,jl_f_appli:9,jl_f_i:9,jl_f_top_ev:9,jl_filenam:6,jl_first_argument_datatyp:8,jl_float64_typ:33,jl_function_t:[6,8,14,33],jl_gc_allocobj:14,jl_gc_collect:33,jl_gc_enabl:33,jl_gc_init:9,jl_gc_is_en:33,jl_gc_pop:33,jl_gc_push1:33,jl_gc_push2:33,jl_gc_push3:33,jl_gc_push4:33,jl_gc_push:33,jl_gc_pushargs:33,jl_gc_run_all_fin:[7,9],jl_gc_wb:[14,33],jl_gdblookup:6,jl_get_builtin_hook:9,jl_get_field:14,jl_get_funct:33,jl_get_glob:[8,9],jl_get_nth_field_check:14,jl_gf_mtabl:6,jl_init:33,jl_init_box_cach:9,jl_init_codegen:[7,9],jl_init_frontend:9,jl_init_intrinsic_funct:9,jl_init_primit:9,jl_init_restored_modul:9,jl_init_seri:9,jl_init_task:9,jl_init_typ:[9,14],jl_int32_typ:9,jl_interpret_cal:55,jl_interpret_toplevel_expr:9,jl_interrupt_except:9,jl_intrinsic_typ:9,jl_is_:33,jl_is_float64:33,jl_is_mut:14,jl_lambda_info_t:[6,7,14],jl_lamdbda_info_t:6,jl_lineno:6,jl_load:[6,7,9],jl_lock:12,jl_macroexpand:7,jl_main_modul:9,jl_method_def:8,jl_module_run_initi:9,jl_new_abstracttyp:9,jl_new_arrai:14,jl_new_arrayv:14,jl_new_bit:14,jl_new_bitstyp:9,jl_new_generic_funct:[8,14],jl_new_lambda_info:14,jl_new_main_modul:9,jl_new_modul:9,jl_new_struct:14,jl_new_structv:14,jl_new_uniontyp:14,jl_null:9,jl_option:[6,7,9,33],jl_parse_eval_al:9,jl_parse_input_lin:9,jl_printf:18,jl_ptr_to_array_1d:33,jl_pvalue_t:14,jl_resolve_sysimg_loc:9,jl_restore_system_imag:[7,9],jl_root_task:9,jl_safe_printf:18,jl_save_system_imag:[7,9],jl_set_typeof:14,jl_share:33,jl_static_show:18,jl_stderr:18,jl_stdin:18,jl_stdout:[9,18],jl_subtype_l:21,jl_svec_t:21,jl_sym_t:14,jl_symbol:[9,14],jl_symbol_nam:6,jl_task_typ:9,jl_throw:[6,9,26],jl_too_few_arg:6,jl_too_many_arg:6,jl_toplevel_ev:9,jl_toplevel_eval_flex:[7,9,55],jl_toplevel_eval_in:9,jl_toplevel_eval_in_warn:55,jl_trampolin:9,jl_tupl:14,jl_tuple_t:14,jl_tupletype_t:6,jl_tuplev:14,jl_type_error:33,jl_type_intersect:21,jl_type_morespecif:21,jl_type_typ:9,jl_typeof:[6,14],jl_typeof_str:33,jl_typetag_t:14,jl_unbox_float64:33,jl_uncompress_ast:6,jl_uniontype_t:14,jl_unlock:12,jl_uv:[9,18],jl_uv_handle_typ:18,jl_uv_put:18,jl_uv_stderr:6,jl_uv_writ:[9,18],jl_value_t:[6,8,9],jl_vprintf:18,jl_yield:51,jlbacktrac:6,jlcall:8,jlcall_:4,jlcall_print_284639:9,jlcapi_:4,jldoctest:32,jle:34,jlfrontend:7,jltype:14,jmath:59,job:[8,9,29,51,52,53,74],jobq:74,jobsvl:74,jobu:74,jobv:74,jobvl:74,jobvr:74,jobvsl:74,jobvsr:74,jobvt:74,jobz:74,john:[39,44],joi:[31,59],join:[56,59,69,71,84],joined:59,joiner:59,joinpath:[20,33,62,69,78],jointli:51,joker:59,journal:74,joy:59,joy_cat:59,jpvt:74,jrang:51,judgment:52,judici:[45,64],jul:68,juli:[31,68],julia_:[4,16],julia_convert_16886:6,julia_dir:33,julia_home:[20,33,67,77],julia_info_color:40,julia_init:7,julia_init_dir:33,julia_intern:55,julia_llvm_args:11,julia_load_path:47,julia_num_threads:51,julia_pkgdir:78,julia_print_284639:9,julia_root:2,julia_warn_color:40,julia_worker_timeout:77,julia_write_282942:9,juliabox:40,juliacon:36,julialang:[32,34,36,40,50,74],julialibm:75,julian2datetim:68,julian_dai:68,juliapars:50,juliarc:[36,40,47,51,62,64,77],juliastat:[49,50],jump:[1,48,52,76],jumppoli:76,jun:68,june:68,juno:32,jupit:59,jupiter:59,just:[1,5,7,8,9,11,14,15,19,21,22,25,26,27,28,29,30,31,32,33,34,35,36,39,40,41,42,44,45,46,48,49,50,51,52,53,54,56],justifi:15,juxtapos:[27,39],juxtaposit:39,k_1:75,k_2:75,kahan:[39,63],kappa:59,karpinski:50,katakana:59,kaufman:74,keep:[8,21,22,26,29,33,40,41,47,50,51,52,62,64,77,84],kei:[8,19,21,29,31,35,36],kept:[14,42,78,84],kernel:[29,37,51],kernelcontract:59,key:59,keyboard:59,keycap:59,keycap_ten:59,keyerror:[29,64],keyfil:51,keymap:40,keytyp:66,kib:50,kick:52,kill:[40,51,64,77],kimono:59,kind:[1,6,8,15,19,22,28,29,30,31,34,35,44,45,46,48,52,56,58,61,64,75],kindli:50,kiss:59,kissing:59,kissing_cat:59,kissing_closed_ey:59,kissing_heart:59,kissing_smiling_ey:59,kiwi:64,knew:51,knife:59,know:[2,7,15,26,29,30,31,33,34,35,39,41,45,47,50,51,52,54,56,57,71,74,77],knowledg:[21,52],known:[1,7,14,21,25,26,27,28,29,31,32,35,36,39,41,45,46,47,50,52,53,57,58,59,63,66,74,75,76],knuth:75,koala:59,koko:59,konstantinid:74,konstantino:74,koppa:59,korean:56,kron:[60,74],kroneck:[60,74],kronrod:75,krylov:74,kung:74,kwarg:[35,77,79],kwftype:8,kwfunc:8,kwsorter:[8,12,21],ky88:74,label:[1,32,35,52,65,84],labelnod:1,labor:11,lack:[34,42,45,49,57,63,77],lady:59,laid:[19,25],lambda:[1,6,55,59,64,74,77],lamda:59,lanczo:74,land:50,langl:59,languag:[3,7,8,15,23,25,26,29,30,31,32,33,34,35,38,42,44,45,46,47],lantern:59,lapack:[2,25,43],lappli:49,laptop:[51,53],larg:[4,8,14,25,30,32,33,34,35,41,42,44,45,47,49,50,51,52,58,63,64,66,68,71,74,75,77,85],large:59,large_blue_circl:59,large_blue_diamond:59,large_orange_diamond:59,larger:[8,25,28,30,31,33,39,49,50,52,56,59,64,66,74,75],largest:[25,30,31,34,39,63,64,66,74,75,76],last:[1,3,5,6,11,21,25,29,30,31,32,33,35,36,39,40,41,44,45,48,49,50,51,56,57,58,59,61,63,64,66,68,69,71,74,75,77,82,84],last_quarter_moon:59,last_quarter_moon_with_fac:59,lastdayofmonth:[31,68],lastdayofquart:[31,68],lastdayofweek:68,lastdayofyear:68,lastmain:64,lat:59,late:59,latenc:[52,54],later:[9,19,25,28,29,31,35,46,50,51,52,57,58,60,64,65,77],latest:[11,34,50,51,78],latex:[5,32,40,60],lather:62,latin:[59,84],latter:[21,30,40,49,50,52,54,56,61,63,74],laugh:59,launch:[6,29,36,51,53,64,77],launch_ntfi:77,law:[42,46],layer:[3,7,26,51],layout:10,lazi:[28,49],lazili:49,lazy:59,lazysinv:59,lbeta:[25,44,75],lceil:59,lcfirst:84,lcm:[44,75],ldexp:[44,75],ldflag:33,ldflags:33,ldlib:33,ldlibs:33,ldlt:74,ldltfact:74,ldot:59,ldsh:59,lea:34,lead:[25,31,34,47,49,50,52,61,74,75,76,84],leading_on:76,leading_zero:76,leaf:[12,14,26,52,59,64],leak:[22,26],leaki:29,leap:[31,68],learn:[7,21,34,36,52],least:[15,21,25,39,44,48,50,51,52,53,56,64,66,71,74,75,76,84],leav:[1,28,29,34,45,50,57,59,77,82],led:53,ledger:59,left:[1,5,25,29,32,34,35,39,40,44,45,49,50,56,58,59,61,63,64,66,68,74,75,77,84],left_luggag:59,left_right_arrow:59,left_sv:74,leftarrow:59,leftarrowapprox:59,leftarrowbackapprox:59,leftarrowbsimilar:59,leftarrowonoplu:59,leftarrowplu:59,leftarrowtail:59,leftarrowtriangl:59,leftarrowx:59,leftbkarrow:59,leftcurvedarrow:59,leftdasharrow:59,leftdbkarrow:59,leftdotarrow:59,leftdownteevector:59,leftdownvectorbar:59,leftharpoonacc:59,leftharpoondown:59,leftharpoonsupdown:59,leftharpoonup:59,leftharpoonupdash:59,leftleftarrow:59,leftmoon:59,leftouterjoin:59,leftrightarrow:59,leftrightarrowcircl:59,leftrightarrowtriangl:59,leftrightharpoon:59,leftrightharpoondownup:59,leftrightharpoonsdown:59,leftrightharpoonsup:59,leftrightharpoonupdown:59,leftrightsquigarrow:59,leftrightvector:59,leftsquigarrow:59,leftteevector:59,leftthreearrow:59,leftthreetim:59,lefttrianglebar:59,leftupdownvector:59,leftupteevector:59,leftupvectorbar:59,leftvectorbar:59,leftwards:59,leftwards_arrow_with_hook:59,leftwavearrow:59,leftwhitearrow:59,leg:59,legaci:9,legacystr:56,legend:43,lehoucq:74,lemon:59,len:[9,12,84],length:[3,4,14],leo:59,leopard:59,leqq:59,leqqslant:59,leqslant:59,lescc:59,lesdot:59,lesdoto:59,lesdotor:59,lesg:59,less:[1,19,21,25,26,28,29,31,34,39,44,45,46,49,50,51,53,54,56,57,58,59,64,68,74,75,77,82,84],lessapprox:59,lessdot:59,lesseqgtr:59,lesseqqgtr:59,lesser:32,lessgtr:59,lesssim:59,let:[1,5,6,7,15,21,25,26,28,29,31,32,33,41,45,47,48,49,50,51,52,53,54,56,58,60],letter:[54,56,59,60,69,84],letters:59,level:[3,7,8,11,12,14,16,19,25,26,29,32],leverag:[28,51],lexcmp:64,lexic:61,lexicograph:[56,64,82],lexless:64,lfact:[25,44,75],lfloor:59,lgamma:[25,44,75],lgblkcircl:59,lgblksquar:59,lge:59,lgwhtcircl:59,lgwhtsquar:59,lib64:40,lib:[6,20,26,33,40,47,64],libc:[26,54,67,72,73],libdist:26,libdl:[67,73],liber:34,liberty:59,libfil:73,libfoo:[26,47],libgit2:50,libgsl:26,libjulia:[20,33],liblapack:26,libllvm:[2,7],libm:[2,52],libopenbla:2,libopenlibm:2,libra:59,librari:[7,9,17],libstdc:33,libsupport_init:9,libuv:[7,9],licens:[42,50,52],license:50,lidict:79,lie:21,lieu:[9,49,74],life:45,lifetim:[51,77],lifo:64,lift:28,ligatur:84,ligature:59,light:59,light_rail:59,lighter:77,lightweight:[6,29,42,50],like:[1,2,3,5,6,8,11,13,15,18,19,21,22,25,26,28,29,30,31,32,33,34,35,40,41,42,44,45],likelihood:3,likewis:[15,16,19,21,29,34,56,58],limit:[7,8,26,30,31,32,36,40,42,45,50,51,53,56,59,68,71,74,75,77,79,84],linalg:[63,74],lindahua:50,line:[1,6,7,9,11,15,18,19,20,21,22,26,28,29,30,31,32],lineag:42,linearcach:21,linearfast:[3,19,25,41,63],linearindex:[3,25,41,63],linearli:[19,25,63],linearslow:[19,25,41,63],linecom:71,lineedit:40,linefe:[59,84],lineinfo:79,linenumbernod:1,liner:[29,54],linerang:79,linfo:[6,55,83],lingo:58,link:[2,11,26],linker:[23,33,70],linreg:74,linspac:[25,49,51,63,66],lint:52,linux:[2,6,9,33,50,51,64],lip:59,lipstick:59,lisp:[7,35,42,45],list:[1,6,8,9,11,12,14,16,19,21,25,26,29],list_of_remote_host:51,listen:[48,51,71],listenani:71,liter:[26,27,29,30],literatur:74,litter:59,littl:[21,31,34,42,46,50,51,52,53,57,58,71],live:[20,34,51,71],ljulia:33,llarc:59,llblacktriangl:59,llbracket:59,llcorner:59,lldb:6,lleftarrow:59,lllnest:59,lltriangl:59,llvm:[2,4,7,9,10],llvm_assertions:11,llvm_debug:11,llvm_sanitize:17,llvm_use_cmake:17,llvm_ver:11,llvmcall:[7,65,81],llvmcontext:12,lmoustach:59,lnapprox:59,lneq:59,lneqq:59,lnsim:59,load:2,load_cache_path:[47,64],load_path:[47,64,67],loader:73,loaderror:[29,64],loan:74,local:[1,9,26,28,29,31,33,36,45,47,50,51,52,56,58],localdatetim:31,localfil:69,localhost:[48,71],localindex:[51,77],locat:[1,8,15,25,33,34,35,36,50,51],lock:10,lock_with_ink_pen:59,locomotive:59,log10:[25,44,75],log1p:[25,44,75],log2:[25,44,75],log:25,logabsdet:74,logarithm:[44,63,74,75],logdet:[43,74],logic:[3,8,25,30,44,47,49,50,51,63,67,74,76,77],logical:[26,59],login:[36,50,51],logm:74,logspac:63,lollipop:59,long_comput:77,longer:[8,15,19,29,33,34,45,50,53,56,62,65,68,77,78,84],longest:56,longjmp:26,longleftarrow:59,longleftrightarrow:59,longleftsquigarrow:59,longmapsfrom:59,longmapsto:59,longrightarrow:59,longrightsquigarrow:59,look:[6,8,9,11,12,21,25,26,33,34,35,41,45,47,50,51,52,53,55,56,58,59,64,66,67,73,77,83,85],lookup:[6,26,47,52,55,71,73,83],loop:[1,3,5,7,8,11],looparrowleft:59,looparrowright:59,loopback:[51,71],loopinc:52,loopinc_prealloc:52,lorry:59,lose:50,loss:[28,31,58,64],lossless:28,losslessli:[64,68],lot:[19,21,25,34,41,58,72],loud_sound:59,loudly:59,loudspeak:59,loudspeaker:59,love:59,love_hotel:59,love_lett:59,low:[7,8,14,19,32,35,39,51,59],low_bright:59,lowercas:[26,31,56,57,84],lowered:59,lowertriangular:43,lowest:[14,27,28,39,44,64,66],lowint:59,lowrankdownd:74,lowrankupd:74,lozeng:59,lozenge:59,lpad:[39,84],lqfact:74,lrarc:59,lrblacktriangl:59,lrcorner:59,lrtriangl:59,lrtriangleeq:59,lsh:59,lsime:59,lsimg:59,lsqhook:59,lst:51,lstat:69,lstrip:84,lt_float:52,ltcc:59,ltcir:59,ltime:59,ltoh:71,ltp:74,ltquest:59,lua:42,lucid:39,lufact:74,luggage:59,lump:53,lunate:59,lundi:31,lutridiagon:43,luu:34,lvboxlin:59,lvertneqq:59,lyap:74,lyapunov:74,m128:81,m256:26,mac:47,mach:77,machin:[7,16,26,30,31],machine:[59,67],machine_spec:77,machinefil:[36,51],macintosh:64,macos:[64,73],macrocal:1,macroexpand:[5,7,16,45,64],macron:59,mad:50,made:[25,28,34,35,47,50,51,52,64,71,77],mag:59,mag_right:59,magenta:[40,71],magic:[3,46],magnifi:58,magnifying:59,magnitud:[44,52,74,75],mahjong:59,mai:[2,3,5,6,7,12,14,15,16,19,20,21,22,25,26,28,29,30,31,32,33,34,35,36,37,39,40,42,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,63,64,65,66,68,71,72,74,75,76,77,78,79,82,84],mail:[52,59],mailbox:59,mailbox_clos:59,mailbox_with_mail:59,mailbox_with_no_mail:59,main:7,mainli:34,mainstream:58,maintain:[1,2,29,47,54,66,77,85],mainten:10,maize:59,major:[8,15,25,33,34,45,47,49,50,51,52,53,56,64,78],make:[2,3,6,7,8,11,12,15,17,18,19,21,22,25,26,27,28,29,30,32,33,34,35,37,39,40,41,42,44,45,46,47,48,49],make_expr2:45,male:59,malform:71,malici:51,malloc:[14,26,33,72],malloc_context_s:17,maltes:59,maltese:59,man:[39,59,73],man_with_gua_pi_mao:59,man_with_turban:59,manag:[2,23,26,29],mangl:26,mani:[1,2,3,5,6,7,8,12,14,15,16,19,20,21,25,26,28,29,30,31,32,33],manipul:[1,6,7,25,26,27,29],manner:[19,25,26,28,29,30,39,44,45,48,51,58,63,64,65,71,75,77],manpag:56,mans:59,mans_sho:59,mantissa:[44,76],manual:[2,7,14,19,21],mao:59,map:[8,9,15,25],mapfoldl:66,mapfoldr:66,maple:59,maple_leaf:59,mapreduc:66,mapreducedim:63,mapsdown:59,mapsfrom:59,mapslic:63,mapsto:59,mapsup:59,mar:[31,59,68],march:[20,31,68],mardi:31,margin:85,mark:[1,3],marker:[71,84],markup:[32,52],masculine:59,mask:[9,25,49,59,69],massag:59,massage:59,master:[36,40,50,51,65,77,78],master_slav:[51,77],match:[1,2,6,8,15,17,21,25,26,28,32,34,35,40,41,42,43,44,45,46,47,50,52,56,58,63,64,66,68,75,77,84,85],matchal:84,math:[5,27,29,32,34,36,40,52,60,75],math_expr:45,mathemat:[23,25,27,29,30,32,34,35,38,39,42],mathematical:59,matlab:[29,34,42],matrix:19,matter:[2,21,25,30,31,34,45,50,51,52,56,58],matur:[26,50],max:[25,40,49,52,53,63,66,68,74,75,77,85],max_arg:21,max_delai:[64,77],max_parallel:[51,77],maxab:66,maxdepth:[53,79],maxev:[8,75],maxim:56,maximum:[25,35,39,49,51,53,57,63,66,74,75,76,77,84],maxintfloat:64,maxit:74,maxsiz:71,maxval:66,mbf:59,mbfa:59,mbfalpha:59,mbfb:59,mbfbeta:59,mbfc:59,mbfchi:59,mbfd:59,mbfdelta:59,mbfdigamma:59,mbfe:59,mbfeight:59,mbfepsilon:59,mbfeta:59,mbff:59,mbffive:59,mbffour:59,mbffrak:59,mbffraka:59,mbffrakb:59,mbffrakc:59,mbffrakd:59,mbffrake:59,mbffrakf:59,mbffrakg:59,mbffrakh:59,mbffraki:59,mbffrakj:59,mbffrakk:59,mbffrakl:59,mbffrakm:59,mbffrakn:59,mbffrako:59,mbffrakp:59,mbffrakq:59,mbffrakr:59,mbffraks:59,mbffrakt:59,mbffraku:59,mbffrakv:59,mbffrakw:59,mbffrakx:59,mbffraky:59,mbffrakz:59,mbfg:59,mbfgamma:59,mbfh:59,mbfi:59,mbfiota:59,mbfit:59,mbfita:59,mbfitalpha:59,mbfitb:59,mbfitbeta:59,mbfitc:59,mbfitchi:59,mbfitd:59,mbfitdelta:59,mbfite:59,mbfitepsilon:59,mbfiteta:59,mbfitf:59,mbfitg:59,mbfitgamma:59,mbfith:59,mbfiti:59,mbfitiota:59,mbfitj:59,mbfitk:59,mbfitkappa:59,mbfitl:59,mbfitlambda:59,mbfitm:59,mbfitmu:59,mbfitn:59,mbfitnabla:59,mbfitnu:59,mbfito:59,mbfitomega:59,mbfitomicron:59,mbfitp:59,mbfitparti:59,mbfitphi:59,mbfitpi:59,mbfitpsi:59,mbfitq:59,mbfitr:59,mbfitrho:59,mbfits:59,mbfitsans:59,mbfitsansa:59,mbfitsansalpha:59,mbfitsansb:59,mbfitsansbeta:59,mbfitsansc:59,mbfitsanschi:59,mbfitsansd:59,mbfitsansdelta:59,mbfitsanse:59,mbfitsansepsilon:59,mbfitsanseta:59,mbfitsansf:59,mbfitsansg:59,mbfitsansgamma:59,mbfitsansh:59,mbfitsansi:59,mbfitsansiota:59,mbfitsansj:59,mbfitsansk:59,mbfitsanskappa:59,mbfitsansl:59,mbfitsanslambda:59,mbfitsansm:59,mbfitsansmu:59,mbfitsansn:59,mbfitsansnabla:59,mbfitsansnu:59,mbfitsanso:59,mbfitsansomega:59,mbfitsansomicron:59,mbfitsansp:59,mbfitsansparti:59,mbfitsansphi:59,mbfitsanspi:59,mbfitsanspsi:59,mbfitsansq:59,mbfitsansr:59,mbfitsansrho:59,mbfitsanss:59,mbfitsanssigma:59,mbfitsanst:59,mbfitsanstau:59,mbfitsanstheta:59,mbfitsansu:59,mbfitsansupsilon:59,mbfitsansv:59,mbfitsansvarepsilon:59,mbfitsansvarkappa:59,mbfitsansvarphi:59,mbfitsansvarpi:59,mbfitsansvarrho:59,mbfitsansvarsigma:59,mbfitsansvartheta:59,mbfitsansw:59,mbfitsansx:59,mbfitsansxi:59,mbfitsansy:59,mbfitsansz:59,mbfitsanszeta:59,mbfitsigma:59,mbfitt:59,mbfittau:59,mbfittheta:59,mbfitu:59,mbfitupsilon:59,mbfitv:59,mbfitvarepsilon:59,mbfitvarkappa:59,mbfitvarphi:59,mbfitvarpi:59,mbfitvarrho:59,mbfitvarsigma:59,mbfitvartheta:59,mbfitw:59,mbfitx:59,mbfitxi:59,mbfity:59,mbfitz:59,mbfitzeta:59,mbfj:59,mbfk:59,mbfkappa:59,mbfl:59,mbflambda:59,mbfm:59,mbfmu:59,mbfn:59,mbfnabla:59,mbfnine:59,mbfnu:59,mbfo:59,mbfomega:59,mbfomicron:59,mbfone:59,mbfp:59,mbfpartial:59,mbfphi:59,mbfpi:59,mbfpsi:59,mbfq:59,mbfr:59,mbfrho:59,mbfs:59,mbfsans:59,mbfsansa:59,mbfsansalpha:59,mbfsansb:59,mbfsansbeta:59,mbfsansc:59,mbfsanschi:59,mbfsansd:59,mbfsansdelta:59,mbfsanse:59,mbfsanseight:59,mbfsansepsilon:59,mbfsanseta:59,mbfsansf:59,mbfsansfiv:59,mbfsansfour:59,mbfsansg:59,mbfsansgamma:59,mbfsansh:59,mbfsansi:59,mbfsansiota:59,mbfsansj:59,mbfsansk:59,mbfsanskappa:59,mbfsansl:59,mbfsanslambda:59,mbfsansm:59,mbfsansmu:59,mbfsansn:59,mbfsansnabla:59,mbfsansnin:59,mbfsansnu:59,mbfsanso:59,mbfsansomega:59,mbfsansomicron:59,mbfsanson:59,mbfsansp:59,mbfsansparti:59,mbfsansphi:59,mbfsanspi:59,mbfsanspsi:59,mbfsansq:59,mbfsansr:59,mbfsansrho:59,mbfsanss:59,mbfsansseven:59,mbfsanssigma:59,mbfsanssix:59,mbfsanst:59,mbfsanstau:59,mbfsanstheta:59,mbfsansthre:59,mbfsanstwo:59,mbfsansu:59,mbfsansupsilon:59,mbfsansv:59,mbfsansvarepsilon:59,mbfsansvarkappa:59,mbfsansvarphi:59,mbfsansvarpi:59,mbfsansvarrho:59,mbfsansvarsigma:59,mbfsansvartheta:59,mbfsansw:59,mbfsansx:59,mbfsansxi:59,mbfsansy:59,mbfsansz:59,mbfsanszero:59,mbfsanszeta:59,mbfscr:59,mbfscra:59,mbfscrb:59,mbfscrc:59,mbfscrd:59,mbfscre:59,mbfscrf:59,mbfscrg:59,mbfscrh:59,mbfscri:59,mbfscrj:59,mbfscrk:59,mbfscrl:59,mbfscrm:59,mbfscrn:59,mbfscro:59,mbfscrp:59,mbfscrq:59,mbfscrr:59,mbfscrs:59,mbfscrt:59,mbfscru:59,mbfscrv:59,mbfscrw:59,mbfscrx:59,mbfscry:59,mbfscrz:59,mbfseven:59,mbfsigma:59,mbfsix:59,mbft:59,mbftau:59,mbftheta:59,mbfthree:59,mbftwo:59,mbfu:59,mbfupsilon:59,mbfv:59,mbfvarepsilon:59,mbfvarkappa:59,mbfvarphi:59,mbfvarpi:59,mbfvarrho:59,mbfvarsigma:59,mbfvartheta:59,mbfw:59,mbfx:59,mbfxi:59,mbfy:59,mbfz:59,mbfzero:59,mbfzeta:59,mcjit:7,mdai:72,mdblkcircl:59,mdblkdiamond:59,mdblklozeng:59,mdblksquar:59,mdlgblkcircl:59,mdlgblkdiamond:59,mdlgwhtdiamond:59,mdnode:11,mdsmblksquar:59,mdsmwhtcircl:59,mdsmwhtsquar:59,mdwhtcircl:59,mdwhtdiamond:59,mdwhtlozeng:59,mdwhtsquar:59,mean:[1,7,8,12,15,19,20,21,25,26,28,29,31,32,33],meaning:[58,66],meaningless:82,meant:[26,30,47,50,54],meantim:50,meanwhil:48,measangledltosw:59,measangledrtos:59,measangleldtosw:59,measanglelutonw:59,measanglerdtos:59,measangleruton:59,measangleultonw:59,measangleurton:59,measeq:59,measur:[31,51],measure:75,measured:59,measuredangl:59,measuredangleleft:59,meat:59,meat_on_bon:59,mechan:[9,10,12],medblackstar:59,media:40,median:75,medical:59,medium:59,medwhitestar:59,mega:59,megaphone:59,melon:59,mem:[52,53,79],member:[49,59,64,66,69],membership:59,memdebug2:22,memdebug:22,memo:59,memori:[7,8,10],men:59,mens:59,mental:[31,50],mention:[17,28,30,32,34,35,46,48,53,58,64,71],mercredi:31,mercuri:59,mercury:59,mere:[51,52],merg:[19,34,35,50,66,78,79],mergesort:82,meridians:59,merit:15,mersenn:76,mersennetwist:76,mesh:51,mess:28,messag:18,met:77,meta:[1,10],meta_branch:[50,78],metacharact:[54,56],metadata:[1,11,13,14,32,47,48],metaprogram:[16,23,32,38,42],meth:46,method:[1,3],method_exist:64,method_to_break:6,methoderror:[15,21,28,29,30,35,39,41,46,56,57,58,64,71,85],methodswith:[16,64],methodt:[8,12,21,47],metro:59,mfrak:59,mfraka:59,mfrakb:59,mfrakc:59,mfrakd:59,mfrake:59,mfrakf:59,mfrakg:59,mfrakh:59,mfraki:59,mfrakj:59,mfrakk:59,mfrakl:59,mfrakm:59,mfrakn:59,mfrako:59,mfrakp:59,mfrakq:59,mfrakr:59,mfraks:59,mfrakt:59,mfraku:59,mfrakv:59,mfrakw:59,mfrakx:59,mfraky:59,mfrakz:59,mho:59,microphon:59,microphone:59,microscop:59,microscope:59,microsecond:[53,64],microsoft:64,mid:[52,59],midbarve:59,midbarwedg:59,middl:[44,51,75],middle:59,midline:59,midpoint:[34,75],midwai:18,might:[1,3,6,8,12,13,15,19,25,26,29,33,34,35,45,46,48,50,51,52,53,57,58,61,62,63,64,66,71,75,76,77,81,85],milky:59,milky_wai:59,mille:59,millisecond:[31,51,64,68,77],mime:[58,71],mimewrit:71,mimic:[26,32,54],min:[5,25,36,49,63,66,72,75,77],minab:66,mind:[22,26,34,52],minibu:59,minibus:59,minidisc:59,minim:[7,22,31,50,51,58,71,74,75],minimum:[25,29,39,49,50,56,63,66,68,71,74,75,77],minmax:75,minor:[8,34,50,52,56,64,78],minu:[44,59,74,75],minus:59,minusdot:59,minusfdot:59,minusrdot:59,minut:[8,31,36,56,68,72],minval:66,mirror:[14,26,31],misalign:32,miser:22,misplac:45,miss:[14,19,32],mit:[36,42,50,59],mita:59,mitalpha:59,mitb:59,mitbbb:59,mitbbbd:59,mitbbbi:59,mitbbbj:59,mitbeta:59,mitc:59,mitchi:59,mitd:59,mitdelta:59,mite:59,mitepsilon:59,miteta:59,mitf:59,mitg:59,mitgamma:59,mith:59,miti:59,mitiota:59,mitj:59,mitk:59,mitkappa:59,mitl:59,mitlambda:59,mitm:59,mitmu:59,mitn:59,mitnabla:59,mitnu:59,mito:59,mitomega:59,mitomicron:59,mitp:59,mitparti:59,mitphi:59,mitpi:59,mitpsi:59,mitq:59,mitr:59,mitrho:59,mits:59,mitsans:59,mitsansa:59,mitsansb:59,mitsansc:59,mitsansd:59,mitsanse:59,mitsansf:59,mitsansg:59,mitsansh:59,mitsansi:59,mitsansj:59,mitsansk:59,mitsansl:59,mitsansm:59,mitsansn:59,mitsanso:59,mitsansp:59,mitsansq:59,mitsansr:59,mitsanss:59,mitsanst:59,mitsansu:59,mitsansv:59,mitsansw:59,mitsansx:59,mitsansy:59,mitsansz:59,mitsigma:59,mitt:59,mittau:59,mittheta:59,mitu:59,mitupsilon:59,mitv:59,mitvarepsilon:59,mitvarkappa:59,mitvarphi:59,mitvarpi:59,mitvarrho:59,mitvarsigma:59,mitvartheta:59,mitw:59,mitx:59,mitxi:59,mity:59,mitz:59,mitzeta:59,mix:30,mixin:47,mixtur:[30,44],mkdir:69,mkpath:69,mktemp:69,mktempdir:69,mlcp:59,mmap:[71,77],mnemon:8,mnt:40,mobile:59,mobile_phone_off:59,mod1:[44,75],mod2pi:[44,75],mod:[1,25,39,44,47,49,64,75],modal:41,mode:[22,31,32,36],model:[42,49,52,59],models:59,modern:[3,39,42,51],modf:75,modif:[12,14,25,26,35,47,53,56,58,61,63,74],modifi:[6,8,20,22,25],modifier:59,modtwosum:59,modul:[1,5,6,7,8,9,12,16,18,20,21,23,31],modular:39,module_nam:64,module_par:64,modulea:15,moduleb:15,modulenam:47,modulo:[44,59,75],modulu:[39,44,49,75],mohi:74,moment:[21,31,50,52],mon:68,mondai:[31,68],money:59,money_with_w:59,moneybag:59,monitor:71,monkei:59,monkey:59,monkey_fac:59,monorail:59,monospace:59,monster:59,mont:51,month:[31,34,68,72],monthabbr:68,monthdai:[31,68],monthnam:[31,68],monthtovalue:31,monthtovalueabbr:31,moon:59,moor:[42,74],more:[1,3,5,6],moreequ:74,moreov:[15,25,26,28,35,44,45,53,54,58],morespecif:21,morev:76,mortar_board:59,most:[1,3,5,6,8,12,14,15,17,19,21,22,25,26,28,29,30,31,32,33,34,35,39,40,41,42,44,45,46,47,49,50,51,52,53,54,55,56,58,60,61,62,63,64,65,66,68,71,74,75,76,77,79,83,84],mostli:[18,42,47,49,56,64,81],motiv:[31,45,51],mount:[59,69],mount_fuji:59,mountain:59,mountain_bicyclist:59,mountain_cablewai:59,mountain_railwai:59,mountains:59,mous:59,mouse2:59,mouse:59,mouth:59,mov:34,move:[8,25,26,29,39,40,42,45,47,50,51,61,69,76,78],movement:40,movie:59,movie_camera:59,moyai:59,mpfr:[39,76],mpi:51,ms_async:67,ms_invalidate:67,ms_sync:67,msans:59,msansa:59,msansb:59,msansc:59,msansd:59,msanse:59,msanseight:59,msansf:59,msansfiv:59,msansfour:59,msansg:59,msansh:59,msansi:59,msansj:59,msansk:59,msansl:59,msansm:59,msansn:59,msansnin:59,msanso:59,msanson:59,msansp:59,msansq:59,msansr:59,msanss:59,msansseven:59,msanssix:59,msanst:59,msansthre:59,msanstwo:59,msansu:59,msansv:59,msansw:59,msansx:59,msansy:59,msansz:59,msanszero:59,mscr:59,mscra:59,mscrb:59,mscrc:59,mscrd:59,mscre:59,mscrf:59,mscrg:59,mscrh:59,mscri:59,mscrj:59,mscrk:59,mscrl:59,mscrm:59,mscrn:59,mscro:59,mscrp:59,mscrq:59,mscrr:59,mscrs:59,mscrt:59,mscru:59,mscrv:59,mscrw:59,mscrx:59,mscry:59,mscrz:59,msg:[45,55,64,71],msg_bodi:45,msys2:33,mtime:[47,64,69,71],mtt:59,mtta:59,mttb:59,mttc:59,mttd:59,mtte:59,mtteight:59,mttf:59,mttfive:59,mttfour:59,mttg:59,mtth:59,mtti:59,mttj:59,mttk:59,mttl:59,mttm:59,mttn:59,mttnine:59,mtto:59,mttone:59,mttp:59,mttq:59,mttr:59,mtts:59,mttseven:59,mttsix:59,mttt:59,mttthree:59,mtttwo:59,mttu:59,mttv:59,mttw:59,mttx:59,mtty:59,mttz:59,mttzero:59,much:[1,7,8,15,17,22,28,29,31,34,39,42,46,47,49,50,51,52,53,54,57,58,59,64,74,75],mug:59,mugs:59,muladd:75,multi:[5,10],multicast:71,multicast_loop:71,multicast_ttl:71,multicor:51,multidimension:[3,5,25],multilin:[29,49],multilinear:45,multimap:59,multimedia:58,multipl:[3,5,6,7,8,14,15,19,20,22,25,26,27,28,29,30,31],multiple:59,multiplex:51,multipli:[30,32,34,39,66,74,75,80],multiplication:59,multiplicativeinvers:40,multiprocess:51,multiset:59,multitask:29,muscl:59,mushroom:59,music:59,musical:59,musical_keyboard:59,musical_not:59,musical_scor:59,must:[2,5,7,8,11,12,14,15,19,25,26,27,28,29,30,32,33,34,35,36,37,39,40,41,42,43,44,45,46,47,48,49,50,51,52,56,58,60,63,64,65,66,68,69,71,74,75,76,77,78,84],mutabl:[1,12,14,25,26,34,35,41,58,61,63,64],mutat:[25,32,34,41,49,60,63,74,82],mute:59,mutex:77,mutual:[37,61],mvs:43,myaccount:50,myambiguouscontain:52,myambiguoustyp:52,myappend:46,myarg:29,myarrai:[3,25,63],mybettercontain:52,mycod:47,mycompar:26,mycompare_c:26,mycontain:52,mycopi:15,mycustomexcept:29,myfix:50,myfork:50,myfun:52,myfunc:[26,52,53],myfunct:[13,49],myid:[47,51,77],myimag:71,myintersect:21,mykei:40,mylib:26,mylibvar:26,mymacro:49,mymodul:[34,45,47],mynewcod:34,mypackag:20,myplu:58,myrang:51,mysimplecontain:52,mystdout:47,mysteri:[21,45],mystillambiguoustyp:52,mysum:5,mytask:29,mytyp:[21,34,47,51,52,57,71],mytypeof:46,myundefvarerror:29,n_1:75,n_d:75,nabla:59,nadir:58,nail:59,nail_car:59,naiv:[8,19,45],nall:5,name:[1,4,6,7,8,9,14,16,20,21,25,26,27,29,30,31,32,34],name_badg:59,namespac:34,nan16:[39,76],nan32:[39,44,76],nan:[27,39,44,52,64,71,75,76,85],nan_dom_err:52,nand:[59,77],nani:5,nanosecond:64,napprox:59,narg:[1,4,6,8,33],nargout:49,narrow:6,nasti:19,nasymp:59,nativetyp:57,natur:[5,19,26,28,29,30,31,34,39,44,50,51,52,57,58,59,69,75],natural:59,navig:50,nb_avail:71,nbad:[56,84],nbumpeq:59,nbyte:[14,71],ncall:5,nce:53,nchunk:51,ncol:49,ncong:59,nconv:74,ncv:74,ndigit:75,ndim:[15,25,33,41,63,74,75],nearbi:44,nearest:[31,39,40,44,47,68,75,77],nearli:[8,25,42,53,54],nearrow:59,necessari:[1,5,8,13,15,19,25,26,27,29,30,32,33,34,35,37,44,45,47,49,50,51,52,54,57,58,61,64,65,66,69,71,77,85],necessarili:[1,13,19,29,31,33,47,56,74],neckti:59,necktie:59,need:[2,5,6,7,8,12,14,15,17,18,19,21,25,26,28,29,30,31,32,33,34,35,40,41,42,44,45,46,47,48,49,50,51,52,53,54,56,57,58,60,61,62,63,64,65,66,68,69,71,73,74,75,77,78,79,82,83,84],needl:84,neg:[27,28,29,31,34,39,44,49,59,74,75,76],negat:[29,39,44,50,68],negated:59,negative:59,negative_squared_cross_mark:59,neglig:82,nehalem:2,neighbor:25,neither:[19,21,29,34,39,46,56,59,63,65,69],nel:84,nelli:46,neovnwarrow:59,neovsearrow:59,neptun:59,neptune:59,neqsim:59,nequiv:59,nest:[3,5,13,16,19,29,32,35,45,53,61,64,75,85],nestabl:80,nested:59,nestedgreatergreat:59,nestedlessless:59,net:52,netlib:74,network:[23,38],neumaier:63,neuter:59,neutral:[59,66],neutral_fac:59,nev:74,never:[15,19,26,29,30,35,36,45,52,54,58,61,65,68,71,75,77],nevertheless:46,new_moon:59,new_moon_with_fac:59,newbranch:50,newcom:[34,50],newer:[8,50,74],newest:78,newli:[34,48,50,51,58,61,77],newlin:[48,56,71,84],newline2l:84,newline2lf:84,newline2p:84,newobj:14,newspap:59,newspaper:59,newstruct:14,newval:77,newvarnod:1,nexist:59,nexpr:5,next:[1,2,8,9,19,20,26,29,31,33,34,39,40,41,45,48,49,50,51,52,53,56,58,61,63,64,66,68,71,72,75,77,84],nextfloat:[39,76],nextidx:51,nextind:[56,84],nextpow2:75,nextpow:75,nextprod:75,nextract:5,nfc:84,nfd:84,nfield:[8,14,64],nfkc:84,nfkd:84,ngener:5,ngeq:59,ngeqslant:59,ngtr:59,ngtrsim:59,nhdownarrow:59,nhead:51,nhuparrow:59,nib:59,nice:32,nichola:74,nif:5,night:59,night_with_star:59,nine:59,niobar:59,nisd:59,niter:74,nle:54,nleftarrow:59,nleftrightarrow:59,nleq:59,nleqslant:59,nless:59,nlesssim:59,nlink:[64,69],nloop:5,nmax:26,nmemb:26,nmid:59,nmin:26,nmult:74,nni:59,nnz:[25,63],no_affinity:2,no_bel:59,no_bicycl:59,no_entri:59,no_entry_sign:59,no_good:59,no_mobile_phon:59,no_mouth:59,no_pedestrian:59,no_smok:59,node:[1,7,36,51,58,64,77],nodej:71,nofield:58,noh:[56,84],noinlin:[1,32,55],nois:[35,39,52,53],nolinebreak:59,nolta:50,nomenclatur:28,nomin:[58,71],non:[1,4,5],none:[1,21,22,25,28,29,34,35,36,41,45,46,52,53,55,57,58,61,63,77,78,85],nonempti:74,nonforking:59,nonneg:29,nonposit:74,nonprincip:74,nonscalar:41,nonsingular:74,nonstandard:64,nonsymmetr:74,nontrivi:[55,63],nonzero:[25,58,63,64,74],noop:43,nope:31,noprint:6,nor:[39,46,51,56,59,63,65,69,77],noreturn:26,norm:[52,58,74,75],normal:[2,6,8,25,26,27,28,29,31,33,34,35,40,45,47,49,50,54,56,59,61,63,64,68,69,71,74,75,76,78,84,85],normalform:84,normalize_str:84,normpath:[69,78],normtyp:74,north:59,nose:59,nostop:6,notabl:[11,26,33,44,61],notat:[25,27,31,35,39,42,44,45,46,49,54,56,58,61,66,71,77],notation:59,note:[2,3,6,7,8,9,12,14,15,16,17,19,20,21,22,25,26,27,29,30,31,32,33,34,35,36,37,39,41,44,45],notebook:[59,71],notebook_with_decorative_cov:59,notes:59,noteworthi:[23,38],notgreatergreat:59,notgreaterless:59,noth:[1,5,8,9,14,15,20,21,26,29,30,33,34,40,45,48,50,52,54,56,57,58,64,67,69,71,74,75,77,78,84],nothing:14,notic:[8,26,29,30,33,34,35,41,45,46,47,48,51,52,55,56,58],notif:[26,51,71,77],notifi:[14,26,29,33,50,51,64,71,77],notin:59,notion:[30,31,54,66,75,82],notlefttrianglebar:59,notlessgreat:59,notlessless:59,notnestedgreatergreat:59,notnestedlessless:59,notori:26,notrighttrianglebar:59,notsquaresubset:59,notsquaresuperset:59,nov:[31,68],novel:3,novemb:[31,68],now:[6,9,12,15,17,19,20,21,26,28,30,31,33,34,41,45,46,48,49,50,51,52,53,55,58,62,68,71,74,77],nowher:30,nparallel:59,npolint:59,nprec:59,npreccurlyeq:59,npreceq:59,nprecsim:59,nproc:[51,77],nref:5,nrightarrow:59,nrm2:74,nrm:8,nrow:49,nsim:59,nsime:59,nsqsubseteq:59,nsqsupseteq:59,nstep:52,nsubset:59,nsubseteq:59,nsubseteqq:59,nsucc:59,nsucccurlyeq:59,nsucceq:59,nsuccsim:59,nsupset:59,nsupseteq:59,nsupseteqq:59,nsv:74,nth:56,nthread:[51,77],ntoh:71,ntriangleleft:59,ntrianglelefteq:59,ntriangleright:59,ntrianglerighteq:59,ntupl:[5,26,41,45,51,52,58,64,74,77,81],nul:[26,64,84],nullabl:[34,51,55,57],nullexcept:[58,64],nullspac:74,num2hex:76,num:[27,28,30,35,58,72,75,76],numbers:59,numcor:85,numer:[11,26,27,28,30,31,34,36],numericextens:50,numero:59,numpi:[49,52],nut:59,nut_and_bolt:59,nutshel:50,nvdash:59,nvleftarrow:59,nvleftarrowtail:59,nvleftrightarrow:59,nvrightarrow:59,nvrightarrowtail:59,nvtwoheadleftarrow:59,nvtwoheadleftarrowtail:59,nvtwoheadrightarrow:59,nvtwoheadrightarrowtail:59,nwarrow:59,nworker:[52,77],nwovnearrow:59,nx1:49,nzind:63,nzrang:63,nzval:[25,63],obar:59,obei:76,obj1:34,obj2:34,obj3:34,obj:[6,28,46,64],objconstructor:34,object:[1,6,7,8,9,10,11],object_id:[47,64],object_inst:65,objectiddict:[47,64,66],oblique:59,observ:[16,30,39,56],obslash:59,obtain:[12,26,29,33,51,53,55,60,63,65,69,71,72,74,75,79,84],obviat:52,obviou:[1,15,19,28,29,31,34,35,51,55,56],obvious:[17,26,60],obviousli:[47,52],occas:58,occasion:[2,34,45,46,50,51,62],occur:[2,6,8,26,29,30,34,35,39,41,45,46,47,49,51,52,53,54,56,58,64,68,71,74,75,77,82,85],occurr:84,ocean:59,ocirc:59,oclock:59,ocommatopright:59,oct:[50,68,76],octal:[39,49,56,76],octave:75,october:68,octopu:59,octopus:59,odd:[19,31,32,50,52,58,61,76],oden:59,odiv:59,odot:59,odotslashdot:59,off:[1,7,29,30,42,44,47,50,51,59,71,74,77],offer:[2,25,44,71],offic:59,office:59,officer:59,offici:[41,50],official:50,offset1:19,offset:[7,15,16,19,25,40,44,45,56,64,65,71,77],often:[2,6,15,19,21,22,25,26,28,29,30,31,32,35,37,39,41,42,43,44,45,46,47,49,50,51,52,53,57,58,64,75,76,77,84],oftentim:52,oftyp:[52,64],ogonek:59,ogre:59,ogreaterthan:59,ohm:59,oiiint:59,oiint:59,oint:59,ointctrclockwis:59,ok_hand:59,ok_woman:59,old:[8,15,33,34,36,39,40,58,71,76,77],older:[5,20,40,59,74],older_man:59,older_woman:59,olessthan:59,omega:59,omicron:59,ominu:59,omiss:15,omit:[4,15,21,25,26,29,30,35,36,46,51,57,58,74,75,84],on_error:77,onc:[1,2,8,28,33,34,44,45,46,47,49,50,51,52,53,54,61,63,64,66,71,77,78],once:[6,15,21,36,39,42,47,50,51,52,71],oncoming:59,oncoming_automobil:59,oncoming_bu:59,oncoming_police_car:59,oncoming_taxi:59,one:[7,8,21,26,28,29,31,32,33,34,35,41,45,47,48,49,50,53,56,57,58,59,79,85],onerror:69,oneto:[15,41,75],ongo:30,onli:[1,3,6,8,9,11,12,14,15,19,21,25,26,27],onlin:[39,50],only:[6,32,51,52,58,64,66,69,72,74,75,77,84],onto:[1,29,34,39,49,51,71],oop:[34,50],op1:45,op2:45,opaqu:[14,26,71,73],open:[2,25,29,35,42,47,48,50,51,53,54,56,59,64,69,71,74,78],open_file_fold:59,open_hand:59,open_mouth:59,openbracketleft:59,openbracketright:59,opene:48,opening:59,oper:[1,6,7,8,11,12,19,20,21],operand:[27,28,29,30,35,44,52,58],operator:59,operm:69,ophiuchu:59,ophiuchus:59,oplu:59,opluslhrim:59,oplusrhrim:59,oppos:[2,29,32,84],opposit:[33,49,58,68,75],opr1:45,opr1f:45,opr2:45,opr2f:45,opt:[11,27,40,41,61,63,71],optical:59,optim:[7,8],optimis:76,option:[1,6,8,9],optional:[5,15,28,32],or_int:52,orang:64,orange:59,orange_book:59,ord:[56,66],order:[1,3,6,7,8,12,19,21,25,26,28,29,31,32,33,35,39,41,44,45,47,49,50,51],ordere:[32,66],orderedpair:28,ordin:51,ordinal:59,ordinalrang:82,ordinari:[8,26,34,45,46,56,58,64,74,75],ordinarili:41,ordschur:74,org:[32,34,36,40,50,51,71,74,75],organ:[3,46,49,50],organiz:58,orghr:74,orglq:74,orgql:74,orgqr:74,orgrq:74,orient:[30,42,46,58,74],origin:[1,8,19,25,26,29,30,31,50,51,52,58,59,64,66,71,72,74,78,82,84],original:59,ormlq:74,ormql:74,ormqr:74,ormrq:74,ormrz:74,ornament:59,orthogon:[19,74],orthogonal:59,oscillatori:75,oslash:59,ostream:71,ostrich:12,osx:[2,9,50,51],other:[2,3,5,6,7,8,9,11,12,14,15,17,19,21,23,25,26,27,28,29,30,31,32,33,34,35,36,38,39,40,41,42,43,44,45,46,47,48],otherlib:47,otherwis:[3,7,11,14,15,16,21,25,26,28,29,31,34,39,44,45,46,49,50,51,54,58,60,63,64,66,68,69,71,74,75,76,77,78,79,84],otim:59,otime:59,otimeshat:59,otimeslhrim:59,otimesrhrim:59,oturnedcomma:59,ouch:34,ouput:2,our:[2,9,19,21,30,31,33,34,41,46,51,52,53,85],ourselv:41,out:[1,2,3,6,8,11,19,21,25,26,27,28,31,32,33,45,46,48,49,50,51,52,53,54,58,59,61,63,64,71,74,75,77,78],outbox:59,outbox_trai:59,outcom:[31,34,47],outfil:35,outlin:29,outliv:[61,64],outofmemoryerror:[26,29,64],output:[2,6,16,18,26,32,33],output_ptr:26,outset:50,outsid:[15,28,29],outstrm:77,outward:46,over:[1,6,7,8,9,19,21,25,26,29,32,34,35,39,41,42,44,45,46,49,50,51,52,56,57,58,59,63,66,68,71,74,75,76,77,79,84,85],overal:[3,28,46,52,53],overbar:59,overbrac:59,overbracket:59,overflow:[34,35],overflowerror:[29,64],overhead:[19,26,34,39,43,49,51,52,53,74],overlap:[18,52,56,63,74,84],overlapping:59,overlay:59,overleftarrow:59,overleftrightarrow:59,overline:59,overrid:[3,11,17,36,41,58,64,66,71,77],overridden:32,overscore:59,overwrit:[35,66,74,75],overwritten:[9,25,60,63,74,75],ovhook:59,own:[1,14,15,21,26,28,29,30,35,41,42,44,45,47,49,50,51,52,53,56,58,63,64,65,66,69,71,74,76,77,84,85],owner:[50,69],ownership:15,pace:[15,42],pack:[26,57,58,63],packag:[15,20,23,25,26,31,32],packagenam:78,packet:71,pad:[26,68,76,84],page:[2,15,19,32,34,40,41,50,59,73],page_facing_up:59,page_with_curl:59,pagealloc:12,pager:[59,64],pai:[25,34],pair:[19,21,26,28,30,32,33,35,44,45,46,47,51,56,58,61,64,66,71,74,75,77],paired:59,palatalized:59,palette:59,palm:59,palm_tre:59,panda:59,panda_fac:59,paper:[39,59],paperclip:59,paq:63,paradigm:[42,46],parallel:[12,23,29,36,38,42,49],parallelogram:59,parallelogramblack:59,param:[14,51,77],paramet:[1,4,8],parameter:[8,29,52,58,74],parametr:[21,25],paren:57,parent:[6,8,14,19,22,25,33,47,53,54,55,58,61,63,64,69,77,85],parenthes:[1,5,25,26,29,32,35,37,39,45,49,56],parenthesi:[35,49],parenthesis:59,parenthet:39,parentindex:[19,63],park:59,parlanc:[31,45,58],parlett:74,pars:[1,5,6],parse_opt:9,parseerror:[29,64],parser:[1,7,9,31,32,45,56,74],part:[1,7,8,25,26,27,28,30,31,32,34,41,45,47,51,52,54,56,58,59,64,68,69,71,74,75,76,78],part_alternation_mark:59,parti:15,partial:[8,21,29,45,50,52,56,59,64,66,68,75,82],partialmeetcontract:59,partialquicksort:82,particip:[30,39,46,50,51,77],particular:3,particularli:[6,21,29,30,46,49,52,56,57,58,64],partit:77,partli:[42,50],partly_sunni:59,party:59,pass:[4,6,7,8],passport:59,passport_control:59,passwd:54,passwordless:[36,51],past:[42,45,54,64],pat:84,patch:[50,51,56],patchwork:46,path:[8,9,26,29,32,33,40],path_to_your_script:2,patholog:45,patient:75,pattern:[5,7,15,25,26,29,41,45,48,49,51,52,56,62,64,68,71,84],paus:48,paw:59,pcre:56,pdf:54,peac:15,peach:59,peak:74,peakflop:74,pear:[49,59],pearson:75,pedagog:30,pedestrian:59,pedestrians:59,peek:66,peer:77,pem:77,pen:59,penalti:[52,57,75],pencil2:59,pencil:[50,59],pend:33,penguin:59,penros:74,pensiv:59,pensive:59,pentagon:59,pentagonblack:59,penv:21,peopl:[50,69],per:[1,26,32,45,47,51,56,59,63],perceiv:84,percept:75,perfect:31,perfectli:[47,51,52,74],perform:[1,3,5,8,13,15,17,19,21,23,25,26,27,29,30,31,32,33,34,35,38,39,41,42,44,45,46,47,49,50,51],performing:59,performing_art:59,perhap:[5,6,12,15,21,28,31,34,41,45,46,51,52,56,58,77],perl:[29,30,35,36,42,54,56,71],perlr:56,perm:[63,74],perman:50,permanent:59,permiss:[52,69],permit:[3,14,21,26,36,44,58,66,76,77],permut:[30,63,74,82],permutation_alloc:26,permutation_fre:26,permutedim:63,perp:59,perpendicular:59,persever:59,persevering:59,persist:47,person:[32,45,50,59],person_frown:59,person_with_blond_hair:59,person_with_pouting_fac:59,personal:59,perspcorrespond:59,perspect:45,perspective:59,pertain:[49,61],pertin:2,perus:28,peseta:59,pharyngeal:59,phase:[2,6,27,47,75],phi:59,philadelphia:74,philosophi:[26,50],phone:59,phones:59,php:31,phrase:7,physic:[31,67,77],pick:[6,8,11,15,21,29,46,50,51,66,75,76,82],pictur:[35,52,85],pid:[51,52,77],piec:[7,18,19,28,29,51,53,57,58],piecewis:46,pig2:59,pig:59,pig_nos:59,pilcrow:59,pile:59,pill:59,pine:59,pineappl:[56,59,84],pineapple:59,pinv:74,pipe:[48,54,59,71],pipebuff:71,pipeendpoint:[18,71],pipeserv:[48,71],pisc:59,pisces:59,pistol:59,pitchfork:59,pitfal:[54,76],pittsburgh:31,piv:74,pivot:[43,74],pivotedcholeski:74,pizza:59,pkg1:78,pkg2:78,pkg:[40,47,50,56,64,78],pkgdev:[50,78],pki:51,place:[3,8,13,18,20,21,25,26,29,30,32,33,34,35,39,40,44,45,47,49,52,53,55,58,59,60,61,63,64,66,71,74,75,77,82],placehold:32,plai:[21,52],plain:[19,26,28,32,35,45,51,56,58,64,71],plan:[11,47,50,75],plan_bfft:75,plan_brfft:75,plan_dct:75,plan_fft:75,plan_idct:75,plan_ifft:75,plan_irfft:75,plan_r2r:75,plan_rfft:75,planck:59,planckconst:59,plane:75,planner:75,platform:[2,6,9,14,18,20,26,34,37,40,51,64,71,72,73,78,85],playing:59,pleas:[2,26,58,69],plot:[35,50,74],plu:[8,40,44,53,57,66,71,74],plug:[59,76],plumb:[51,54],plural:50,plus:59,plusdot:59,pluseqq:59,plushat:59,plussim:59,plussubtwo:59,plustrif:59,pluto:59,pma:50,pmap:[51,77],pmax:49,pmin:49,png:[32,71],point:[1,6,7,8,9,11,12,14,16,18,21,23,25,26,27,28,29,30,32,33,34,35,36,38],point_down:59,point_left:59,point_right:59,point_up:59,point_up_2:59,pointed:59,pointer:[4,7,8,9,14,18,19,25],pointer_from_objref:[21,26,65],pointi:58,pointing:59,pointint:59,pointless:35,points:59,polar:[58,74],pole:59,police:59,police_car:59,polici:[11,51],polish:59,poll:[71,77],poll_fd:[71,77],poll_fil:71,pollint:77,polyalgorithm:74,polygamma:75,polymorph:[30,58],polynomi:[35,39,46,75,76],poo:59,poodl:59,poodle:59,pool:[9,12,14,22,51,77],poor:[28,34],poorer:52,poorli:[19,52],pop:[1,34,57,66,71],pop_loc:1,popdisplai:71,popmeta:13,popper:59,popul:[21,25,26,49,50,76],popular:[27,42,58],port:[36,48,51,54,71,77],port_hint:71,portabl:[26,44,71,79],portion:[2,14,29,51,56,68,76],posdefexcept:74,posit:[8,25,29,31,32,35,39,44,46,50,52,56,61,63,66,71,74,75,76,82,84],posix:73,possess:51,possibl:[8,12,14,19,20,21,22,25,26,28,29,30,31,32,33,34,35,37,39,41,42,45,46,47,50,51,52,53,56],post:[5,26,34,39,44],post_offic:59,postal:59,postal_horn:59,postalmark:59,postbox:59,postexpr:5,postscript:71,posv:74,pot:59,potable:59,potable_wat:59,potato:59,potenti:[8,12,26,29,34,44,45,47,49,50,52,53,60,64,66,71,73],potr:74,potrf:74,potri:74,pouch:59,poultry:59,poultry_leg:59,pound:59,pouting:59,pouting_cat:59,pow:49,power:[5,25,28,29,34,35,41,42],power_by_squar:34,powermod:75,powerpc:26,pppprime:59,ppprime:59,pprime:59,practic:[5,8,15,26,29,30,31,32,47,51,52,56,58,71,81],prai:59,pre:[2,5,9,15,19,21,30,35,50,51],prealloc:[41,52,63,74,75,82],prec:59,precapprox:59,precaut:26,preccurlyeq:59,preced:[26,29,39],precede:59,precedes:59,preceding:59,preceq:59,preceqq:59,precis:[19,25,30,31,34,35],precnapprox:59,precneq:59,precneqq:59,precnsim:59,precsim:59,predefin:[27,30,58],predic:[63,64,66,71],predict:[33,34,52],preemptiv:51,preexpr:5,prefer:[15,32,34,40,42,50,57,64,65,69,71,74,76,82,85],prefix:[4,5,9,25,26,39,40,45,49,51,54,56,64,65,68,73,75,77,78,80,84],preload:51,prematur:26,premium:34,prepar:[5,15,47],prepars:[2,20],prepend:[8,25,32,62,66],preprocessor:45,prereleas:[40,50],prescription:59,presenc:[31,34,51,66,75],present:[1,5,28,32,34,36,39,46,48,50,52,54,58,59,63,64,66,77,84],preserv:[9,25,26,57,66,75],press:[32,40,48,74,77],pressur:51,presum:[8,28],pretend:[8,56],pretti:[31,32,41],prettiest:8,prev:71,prevent:[3,6,12,47,51,52,64],prevfloat:[39,76],prevind:84,previou:[25,29,32,33,35,40,45,50,52,53,54,58,63,64,68,71,74,76,77,79,84],previous:[7,15,16,28,52,58,64,71],prevpow2:75,prevpow:75,primari:[8,21,35,55,58],primarili:[7,56,79,83],prime:[59,60,75],primit:[7,26,27,29,33,39,42,44,51],princess:59,princip:[27,52,74],print:[2,6,7,8,9,11,16,18,21,29,32,33,34,36,40,44,45,47,48,49,50,51,52,53,54,56],print_shortest:71,print_with_color:71,printabl:[71,84],printarg:34,printer:84,printf:10,println:[5,9,16,18,26,29,33,34,36,39,41,44,45,46,48,49,51,52,54,55,56,58,66,69,71],printout:45,prints:59,prior:[30,34,35,68,69,74,83],priori:[14,26],priorit:66,prioriti:[12,66],privat:[41,45,47,50,61],privileg:71,pro:6,probabl:[15,25,26,28,29,31,34,42,44,49,52,53,58,63,64,75],problem:[6,8,26,28,29,30,34,42,45,46,50,51,52,56,57,61,74,75,76],problemat:[15,34,64],proc:[36,40,51,77],proce:[7,50,51],procedur:[2,8,29,50,53,74],proceed:77,process:2,process_exit:64,process_messag:[51,77],process_opt:9,process_run:64,processexitedexcept:64,processor:[20,36,51,52,74,85],processs:77,prod:[25,41,49,59,66],produc:[8,15,25,26,28,29,30,32,34,35,39,45,47,49,51,52,53,54,56,60,64,66,68,71,74,75,77],product:[25,26,29,42,43,49,52,54,59,60,63,66,69,74,75],prof:53,profil:[6,22,23,38,46,52],profileview:[52,53],proflin:59,profoundli:45,profsurf:59,prog:45,prognam:22,program:[2,3,7,9,14,22,23,25,26,29,30,32,33,34,35,36,38,39,40,42],program_file:[36,67,69],programfil:36,programm:[29,30,34,42,45,48,51,58],programmat:[28,32,45,50,51,55,56],progress:[21,52],prohibit:12,project:[33,42,50,52,62,74],projective:59,prolept:[31,68],promis:52,promot:[23,27,28],promote_rul:[30,64],promote_shap:63,promote_typ:[30,57,64],prompt:[6,21,26,32,36],prompt_color:40,promptstat:40,proof:59,propagate_inbound:3,proper:10,propercas:31,properli:[2,15,17,35,47,64],properti:[1,6,13,14,33],property:59,propertylin:59,propon:8,proport:[53,75],proportion:59,proportional:59,propos:[12,50],propto:59,protect:[12,50,65,69,75],proto:78,protocol:[50,78],prototyp:[26,42],prove:59,provid:[4,5,13,15,16,17,18,19,22,25,26,27,28,29,30,31,32,35,36,37,39,41,42,44,45,46,47,48,49,50,51,53,55,56,57,58,60,61,62,63,64,66,68,69,71,74,75,76,77,78,82,83,84,85],provis:28,proxi:[51,77],prurel:59,pseudo:[1,7,50],pseudoinvers:74,psi:59,pstrf:74,pthread:77,pthread_mutex_t:77,ptl:[12,74],ptld:74,ptr:[14,18,21,25],ptrdiff_t:[26,65],ptsv:74,pttr:74,pttrf:74,publicli:50,publish:34,pull:[7,50,53,74,78],pump:59,punctuat:[23,32,56,60,70],punt:19,pure:[3,15,19,35,58,76,77],pure_instruct:34,purer:58,purple:59,purple_heart:59,purpos:[4,8,14,15,16,25,26,32,35,39,45,46,47,51,52,58,61,64,67,71,77],purs:59,purse:59,pursu:68,push:[1,8,19,33,34,41,47,49,50,52,57,66,71,85],push_loc:1,pushdisplai:71,pushmeta:13,pushpin:59,put:[15,32,33,36,40,46,47,50,51,52,53,59,62,63,73,75,77,82,85],put_litter_in_its_plac:59,pwd:[22,62,69,77],pyplot:[50,74],python:[29,30,31,33,35,42,44],qbp:74,qed:59,qrcompactwy:[43,74],qrcompactwyq:74,qrfact:74,qrpackedq:74,qrpivot:[43,74],qsort:26,quad:59,quadgk:[8,75],quadrant:[59,75],quadratur:75,quadruple:59,qualifi:[34,47,61,64],qualiti:26,quantil:75,quantiti:74,quarter:[31,59,68],quarternot:59,quarterofyear:[31,68],quarters:59,quasi:[1,74],quaternion:59,queri:[14,25,29],questeq:59,question:[15,23,30,33],questioned:59,queu:[29,77],queue:[29,51,66,77],quick:[25,40,57],quickest:77,quickli:[8,51,75],quicksort:82,quiet:36,quit:[7,22,25,26,28,29,30,31,34,35,36,40,41,44,45,46,50,51,52,53,54,56,58,61,64,79,82],quot:[1,5,13,16,26],quotat:[32,56],quotation:59,quoteblock:32,quotenod:[1,45],quotient:[44,75],qux:[54,58],qword:34,r2hc:75,r2r:75,r_str:[45,84],r_stream:77,rabbit2:59,rabbit:59,race:[54,77],racehors:59,racing:59,racquet:59,rad2deg:75,radian:[27,44,75],radic:31,radical:59,radio:59,radio_button:59,radiu:8,rage:59,rail:59,railway:59,railway_car:59,rain:59,rainbow:59,rais:[1,8,15,28,29,33,34,44,45,46,47,52,56,58,64,65,69,73,76,77],raised:59,raised_hand:59,raising:59,raising_hand:59,ram:[51,59],ramen:59,ramif:31,rams:59,rand2:51,rand:[25,29,32,41,45,49,51,52,53,71,74,76,77,82],randcycl:63,randexp:76,randjump:76,randn:[25,51,52,74,76,82],random:[25,49,51,52,53,63,64],randomdevic:76,randomli:[51,52,63,76],randommatric:50,randperm:63,randstr:84,randsubseq:63,rang:[5,15,25,26,29,31,34,39,40,41,43,47,49,50,51,52,56,58,63,64,66,68,74,75,77,79,80,82,84,85],rangeexpr:5,rangl:59,rank:[51,74],rapid:85,rapidli:[9,52],rasp:59,rat:[50,59],rata2datetim:68,rata:[31,68],rate:[34,74],rather:[6,15,19,21,25,26,28,29,31,32,34,35,36,39,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,61,63,64,66,69,74,83],ratio:[27,28,30,58,76],ration:23,rational:[1,39],raw:[7,31,47,48,71],rawfd:77,rax:34,rays:59,rbind:49,rbp:34,rc1:[50,56],rc2:56,rceil:59,rcond:74,rcondv:74,rdev:[64,69],rdi:34,rdiagovfdiag:59,rdiagovsearrow:59,rdsh:59,reach:[7,21,28,29,51,71],reachabl:[14,18,64],read:[5,7,11,14,18,29,30,32,33,34],read_and_capit:48,readabl:[25,26,37,45,46,49,55,56,57,71],readandwrit:64,readavail:71,readbyt:71,readchomp:71,readcsv:71,readdir:69,readdlm:71,reader:[28,30,32,51,54,58],readi:[29,35,50,51,53],readili:52,readlin:[48,71],readlink:69,readme:[50,78],readonli:71,readonlymemoryerror:[29,64],readstr:[48,54,71],readuntil:71,real:[3,6,8,21,26,27,28,29,30,31,32,33,34,35,39,40,46,49,51,52,56,57,58,64,71,74,75,76],realist:29,realiz:[34,57,74],realli:[6,8,15,21,26,28,30,32,34,45,50,52,53,57,58,74],realloc:72,realmax:64,realmin:64,realpath:69,reappear:50,rearrang:1,reason:[3,8,15,19,20,21,22,26,28,29,30,31,34,42,45,47,51,52,53,54,56,58,61,74,75,82,84],reassign:[7,34,60],rebind:[34,44,49],rebound:34,rebuild:20,recal:[19,28,30,39,45,46,56,58],recap:58,receiv:[26,41,45,46,50,51,71,77],receiver:59,recent:[6,40,50,55,71,83],reciproc:74,recommend:[5,25,27,32,33,37,39,42,44,46,50,52,53,60,71,74,75,77],recompil:[6,47,52,58,64],recomput:50,reconstruct:[25,34,74],record_backtrac:6,recorder:59,recreational:59,rectangle:59,rectangular:[59,74],recur:[31,68],recurs:[1,7,8,12,16,19,25,26,28,29,45,47,50,53,61,64,69,74,75,77,78],recursivespinlock:77,recv:71,recvfrom:71,recycl:59,recycling:59,red:[8,40,52,59,64,71],red_circl:59,redefin:[34,60],redefinit:34,redesign:47,redft00:75,redft01:75,redft10:75,redft11:75,redirect:[40,54,64,71],redirect_stderr:71,redirect_stdin:71,redirect_stdout:71,redisplai:71,reduc:[3,17,22,26,27,34,35,39,47,49,51,52,53,56,63,64,66,74,77],reducedim:63,reduct:[49,51,52,63,66,77],redund:[30,32,45,50,57,58,71],reenable_sigint:65,reentrant:77,reentrantlock:[34,77],ref:[1,9],refer:[1,2,4],referenc:[25,26,32,33,47,51,56,58,64,65,66,73,77,84],referenti:28,reflect:14,reflector:74,regard:[49,56,72],regardless:[16,18,29,35,39,46,50,58,64],regex:[45,56,64,84],regexmatch:[56,84],region:[51,61,63,66,74,75],regist:[6,7,14,26,40,47,50,51,59,64,71,77,78,82],registered:59,registr:50,regress:74,regular:[25,34,45,51],reid:36,reim:75,reindex:19,reinit_stdio:18,reinstal:50,reinterpret:[25,26,63,76],rejectna:84,rel:[3,14,15,16,19,30,31,32,39],relat:[6,21,23,26,29,31,32,51,52,56,58,64,70,74,76],relation:59,relationship:[11,58,74],relax:[28,59],releas:[11,12,26,33],relev:[7,8,21,26,32,49,51,52,53,57,64,74,77],reli:[3,17,18,19,34,41,57,58,63,69,75,81,82],reliabl:71,reliev:59,relieved:59,reload:[34,47,50,62,64],relpath:69,reltol:[8,75],relton:74,rem:[39,44,75],remain:[7,8,19,26,29,41,45,46,50,51,52,58,63,65,67,82],remaind:[39,44,45,49,75,77,80],remedi:55,rememb:[26,29,31,33,35,50,51,52,57],remind:15,reminisc:[15,45],remot:50,remote_host:51,remotecal:[51,57,77],remotecall_fetch:[51,52,57,77],remotecall_wait:[51,77],remotechannel:[51,77],remoteexcept:[29,77],remoteref_id:77,remov:[3,15,17],remove_destin:69,remove_fram:83,renam:[45,69,71],renc:53,render:[32,33,40,58,59,71],reorder:[52,66,74],rep:52,repeat:[5,17],repeat_on:59,repeatedli:[9,29,50,52,68,71],repetit:[5,29,45,74],repl:[7,9,21,32,33],replac:[5,6,8,11,15],replbackend:55,replic:[25,44],repmat:[25,52,74],repo:[50,78],report:0,repr:84,repres:[1,4,5,8,14,16,18,19,21,25,26,27,28,29,30,31,32,33,34,39,43,45,49,51,52,53,54,56,57],represent:[1,4,7,14,16,25,28,30,31,34,39,44],reprmim:71,reproduc:[32,76],repstr:40,request:[2,3,9,25,28,29,30,33,36,48,50,51,53,63,65,71,74,76,77,84],requir:[1,6,8,12,14,15,16,17,19,25,26,28,29,30,32,33,34,35,41,42,44,45,47,48,49],requisit:[26,57],rescal:74,rese:76,resembl:[51,58],reserv:[35,47,66],reset:[1,50,53,71],reshapedarrai:[19,25,40],resid:[53,68,74],residu:74,resiz:[63,66,71],resolut:[31,48,50,64,68],resolv:[8,26,31,34,39,45,47],resort:50,resourc:[8,12,29],respect:[5,17,21,25,27,29,30,31,32,39,40,44,47,49,52,54,56,58,63,64,65,71,74,75,77,84],respond:50,respons:[26,29,33,50,51,52,64,85],rest:[1,7,25,28,30,50,51,52,66,85],restart:[29,51,62,74,77],restor:[12,64,77],restore_sign:9,restrict:[26,28,46,47,51,58,60,64,71,74,75,77],restroom:59,restructur:32,result:[1,6,7,8,11,14,15,16,21,25,26,27,28,29,30,31,32,33],result_arrai:26,resum:[29,48,77],ret:[16,33,34,52],ret_unbox:33,retain:[15,51,54,63,66],retexpr:45,rethrow:[29,33,64,77],rethrown:77,retri:[64,77],retriev:[18,25,26,31,32,33,48,51,61,66,71,72,79,84,85],retroflex:59,retry_max_delai:77,retry_n:77,retry_on:[64,77],rettyp:77,retun:51,return_to:50,returntyp:[26,65],retval:65,reus:[50,52,61,66,74,75],reusabl:[26,52,57],rev:82,revangl:59,revangleubar:59,reveal:[21,28,53,58],revemptyset:59,revers:[7,8,26,33,40,49,63,65,66,71,82,84],reverse:59,reversed:59,reverseind:63,reverseupequilibrium:59,revert:9,review:26,revisit:74,revolut:68,revolving:59,revolving_heart:59,revstr:40,rewind:59,rewrit:[15,33,35,45,51,52,56],rewritten:45,rfft:75,rfloor:59,rfn:63,rho:59,ribbon:59,rice:59,rice_bal:59,rice_crack:59,rice_scen:59,rich:[41,42,43,48,62,71],richer:[58,71],richest:71,riemann:[44,75],right:[5,7,8,12,15,25,29,30,31,32,34,35,40,41,44,48,49,50,58,59,61,63,64,66,74,75,84],right_sv:74,rightangl:59,rightanglearc:59,rightanglemdot:59,rightarrow:59,rightarrowbackapprox:59,rightarrowbar:59,rightarrowbsimilar:59,rightarrowdiamond:59,rightarrowgtr:59,rightarrowplu:59,rightarrowsupset:59,rightarrowtail:59,rightarrowtriangl:59,rightdasharrow:59,rightdotarrow:59,rightdownteevector:59,rightdownvectorbar:59,righthand:59,rightharpoonacc:59,rightharpoondown:59,rightharpoonsupdown:59,rightharpoonup:59,rightharpoonupdash:59,rightleftarrow:59,rightleftharpoon:59,rightleftharpoonsdown:59,rightleftharpoonsup:59,rightmoon:59,rightmost:74,rightouterjoin:59,rightpentagon:59,rightpentagonblack:59,rightrightarrow:59,rightsquigarrow:59,rightteevector:59,rightthreearrow:59,rightthreetim:59,righttrianglebar:59,rightupdownvector:59,rightupteevector:59,rightupvectorbar:59,rightvectorbar:59,rightwards:59,rightwavearrow:59,rightwhitearrow:59,rind:66,ring:59,ringplu:59,rins:62,rip:6,rising:59,risingdotseq:59,risk:28,ritz:74,ritzvec:74,rival:42,rma:51,rmoustach:59,rmproc:[51,77],rmt:50,rndmat:50,rng:[32,63,76,84],rnk:74,roasted:59,robust:58,rocket:59,rodft00:75,rodft01:75,rodft10:75,rodft11:75,rol:63,role:[21,32,42,52],roll:50,roller:59,roller_coast:59,room:53,rooster:59,root:[2,9,12,27,29,33,40],rootpath:69,ror:63,rose:59,rot180:63,rotat:[31,63,74],rotated:59,rotating_light:59,rotl90:63,rotr90:63,rough:75,roughli:[8,21,75,84],round:[22,25,30],round_pushpin:59,rounddown:[39,68,75,76],rounded:59,roundfromzero:75,roundimpli:59,roundingmod:[31,68,75,76],roundingmodeimaginari:75,roundingmoder:75,roundnearest:[39,75,76],roundnearesttiesawai:75,roundnearesttiesup:[31,68,75],roundtozero:75,roundup:[39,68,75,76],rout:18,routin:[25,26,29,43,47,52,58,72,74],row:[1,25,32,49,51,52,63,71,74,82],rowboat:59,rowval:[25,63],rpad:[52,84],rppolint:59,rrbracket:59,rrid:77,rrightarrow:59,rsearch:84,rsearchindex:84,rsh:59,rsi:34,rsolbar:59,rsp:34,rsplit:84,rsqhook:59,rstrip:84,rtime:59,rtld_deepbind:[67,73],rtld_first:[67,73],rtld_global:[33,67,73],rtld_lazy:[67,73],rtld_local:[67,73],rtld_nodelete:[67,73],rtld_noload:[67,73],rtld_now:[67,73],rtol:75,rubi:[29,35,36,42,54,58],rug:34,rugby:59,rugby_footbal:59,rule:[3,21,26],ruledelai:59,ruler:59,run:1,run_repl:53,runnabl:[29,32,48,77],runner:59,running:59,running_shirt_with_sash:59,runtest:[22,50,78,85],runtim:3,rval:66,rvboxlin:59,s0895479895281484:74,s13:74,s29:6,s84:74,s_1:5,s_2:5,s_3:5,s_4:5,s_j:5,saba:2,sacrif:25,safe:[12,15,26,33,47,51,52,54,56,57],safe_oper:47,safepoint:12,safeti:3,sagittariu:59,sagittarius:59,sai:[6,7,15,28,30,31,34,41,45,50,51,52,53,58,62],sailboat:59,sake:[29,59],salient:58,same:[1,2,6,8,12,15,20,21,25,26,28,29,30,31,32,33],same_typ:46,same_type_numer:46,samedi:31,sampi:59,sampl:[6,22,33,51,53,63,75,79],samuel:74,sand:59,sandal:59,sanit:0,sanitize:17,sanitize_memory:17,sans:59,sanslmirror:59,sanslturn:59,santa:59,sash:59,sat:68,satchel:59,satellit:59,satellite:59,satisfi:[8,19,31,44,50,63,68,74,75],satur:[34,54],saturdai:68,saturn:59,sauc:32,save:[7,8,9,21,25,29,31,33,36,40,41,50,53,62,74,75,79],savouring:59,saw:[21,48],saxophon:59,saxophone:59,sayhello:45,sbin:40,sbmv:74,scal:74,scala:58,scalabl:51,scalar:[4,19,25,26,35,41,43,44,49,64,74,75],scale:42,scan:13,scanner:9,scatter:52,scenario:[3,47,50,51,58],scene:48,schedul:[26,29],scheme:[1,19,35,56],school:59,school_satchel:59,schreiber1989:74,schreiber:74,schur:74,schurfact:74,schwa:59,sci:74,scientif:[26,39,42,64,74],scientist:39,scissor:59,scissors:59,scm:[1,7,50],scope:[1,23,29,34],score:59,scorpio:59,scorpiu:59,scorpius:59,scpolint:59,scratch:62,scream:59,scream_cat:59,screaming:59,screen:[40,71],scriptfil:36,scroll:59,scurel:59,sdata:[51,77],seamless:46,seamlessli:42,search:[9,16,21,32],searchabl:40,searchindex:84,searchsort:[25,82],searchsortedfirst:82,searchsortedlast:82,searrow:59,seat:59,sec:[25,44,52,72,75,77],secant:75,secd:[25,44,75],sech:[25,44,75],second:[1,5,8,9,19,21,25,26,28,29,30,31,32,33,35,39,40,41,44,45,46,47,48,49,50,51,52,53,54,56,57,58,59,63,64,68,71,72,74,75,77,79,84],secret:[32,59],section:[1,5,14,16,22,25,26,27,29,30,32,34,35,40,41,42,43,45,46,49,50,51,52,56,57,58,59,61,63,64,66,75,77],secur:51,see:[6,8,9,14,15,16,18,19,21,22,25,26,28,29,30,31,32,33,34,35,36,39,40,41,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,61,62,63,64,65,66,67,68,69,71,72,73,74,75,76,77,78,79,82,84,85],see_no_evil:59,seed:76,seedl:59,seedling:59,seek:71,seekend:71,seekstart:71,seem:[8,15,21,29,31,34,35,46,50,51,52,58,61],seen:[28,33,39,45,49],segfault:[0,1],segment:[51,59,71,75],select:[3,7,16,25,49,58,62,66,74,75,82],selector:59,selectperm:82,self:[7,18,22,28,32],selfreferenti:28,sem_siz:77,semant:[35,45,56,60,61,75,77],semaphor:77,semi:[8,74],semicircle:59,semicircular:59,semicolon:[5,25,29,35,36,40,49,53],semidirect:59,send:[40,50,51,64,71,77],sens:[15,28,30,33,34,35,44,46,47,51,54,57,58,61,64,66,74,75,77,82],sensibl:28,sensit:[3,21,52,60,64],sent:[6,48,51,54,64,71,77],sentenc:32,seovnearrow:59,sep:68,separ:[6,8,18,19,25,28,29,32,34,35,36,39,41,45,46,47,49,50,51],septemb:68,sequenc:[1,5,7,29,32,39,41,53,56,59,66,71,75,76,84],sequenti:[35,41,66,68,77],seri:[25,29,39,45,56,57,61,63,71],serial:[7,12,47,51,52,64,71,77],serialis:[9,18],serializ:77,serif:59,serifs:59,seriou:8,serious:52,serv:[3,21,28,32,35,52,58,64],server:[48,71],servic:50,session:[6,20,26,29,32],set:[6,7,9,11,17,18,19,20],set_num_thread:[74,75],set_process_titl:64,set_zero_subnorm:[52,76],setdiff:66,setenv:64,setfield:[8,64],setgid:69,setindex:[19,25,26,35,41,63,66],setjmp:1,setminu:59,setopt:71,setprecis:[39,76],setprotocol:[50,78],setround:[39,75,76],setuid:69,setup:33,setup_interfac:40,seven:[32,59],sever:[6,8,14,16,22,26,28,29,31,32,33,34,35,37,39,40,47,48,49,50,51,52,54,58,60,63,71,74,75],sf_bessel_jn_arrai:26,sha1:50,shade:59,shadow:35,shall:12,shallow:64,shape:[15,25,35,41,59,63,66,75],shaped:59,share:8,shared_map:12,sharedarrai:[51,71,77],sharp:59,shaved:59,shaved_ic:59,shed:50,sheep:59,sheer:52,shell:[26,33],shell_color:40,shell_pars:45,shield:52,shift:[15,44,49,63,66,74,75],shini:50,ship:[20,22,26,27,59],shirt:59,shoe:59,shooting:59,shortcake:59,shortcut:[47,68],shorten:68,shorter:[45,48,50,52,68],shortest:[56,71],shorthand:[2,6,9,21,25,44,49,56],shortli:28,shot:29,should:[2,3,5,6,7,8,12,14,15,17,19,20,21,22,25,26,28,30,31,32,33,34,35,36,39,40,41,44,45,46,47,48,49,50,51,52,56,57,58,61,63,64,65,66,68,71,72,74,75,77,84,85],shouldn:64,show:[8,9,21,22,25,32,33,36,40,44,45,46,47,48,50,51,53,54,57,58,59,63,64,71],show_sexpr:[16,45],showal:[71,84],showarg:45,showcompact:[48,71],shower:59,showerror:[29,71],shown:[32,36,40,47,51,52,56,58,60,64,79,85],showpar:64,shrimp:59,shuffl:[59,63],shuffle:59,shut:77,siam:74,side:[6,7,34,35,44,45,47,48,49,50,51,58,61,74],sidestep:58,sig:21,sigabrt:9,sigbus:9,sigdie_handl:[6,9],sigfpe:9,sigill:9,siginfo:9,sigint:[9,65],sigint_handl:9,sigma:[59,74],sign:[7,21,26,28,30,39],signal_strength:59,signatur:[4,6,7,8,13,16,21,26,30,32,35,40,46,51,57,58,64,71],signbit:[44,64,75],signedmultiplicativeinvers:40,signif:75,signific:[1,8,29,32,39,42,45,49,51,52,56,58,75,76],significand:[25,39,44,75,76],significantli:[39,53,58,75],signs:59,signum:64,sigpipe:9,sigquit:9,sigsegv:[6,9],sigsys:9,sigterm:[9,64],sigusr2:6,sigusrs:6,silent:[26,34,52,56,73],silhouette:59,sim:59,simd:[3,11,23],simdloop:11,simeq:59,simge:59,simgtr:59,similar:[2,3,5,7],similarleftarrow:59,similarli:[6,25,26,29,30,31,32,35,39,40,49,50,57,58,61,63,64,66,68,71,74],simle:59,simless:59,simminussim:59,simpl:[5,7,25,26,28,29,31,32,33,34,35,37,41,44,45,46],simpler:[7,31,41,45,48,58],simplest:[15,19,25,28,30,50],simplevector:[1,21],simpli:[1,8,14,19,21,26,28,29,30,31,32,33,34,35,40,41,45,46,47,50,51,56,57,58,63,65,71,75],simplic:[12,58,71],simplif:74,simplifi:[15,26,31,32,45,50,58],simplu:59,simrdot:59,simul:[35,51],simultan:[12,51,54,63,68],sin:[8,25,26,35,44,47,52,58,75],sinc:[1,6,7,8,9,12,14,19,25,26,27,28,29,30,31,32,33,34,35,39,41,44,45,46,47,48,49,50,51,52,53,54,56,57,58,61,63,64,65,66,68,71,72,74,75,77,81,82],sind:[25,44,75],sine:[44,59,74,75],sinewav:59,singl:[1,3,5,8,11,15,19,21,25,26,28,29,30,31,32,34,35,39,41,42,44,45,46,47,49,50,51,52,54,56,57,58,63,64,66,68,71,75,77,79,80,82,84],single:59,singleton:[1,6,8],singular:[43,49,51,74,75],sinh:[25,27,44,75],sinpi:[25,44,75],sit:[2,20],site:[8,34,45,52,58,69,78],sitofp:52,situat:[3,28,29,33,34,35,39,44,45,47,51,52,56,58,65,69,71,73,74,77],six:[32,56,59],six_pointed_star:59,size0:33,size1:33,size:[5,8,14],size_t:[14,21,26,33,65],sizehint:66,sizeof:[8,9,26,33,39,64,84],sizeunknown:[41,66],skeel:74,ski:59,skin:59,skip:[3,7,19,26,67,71,77,85],skipblank:71,skipchar:71,skipstart:71,skull:59,slanted:59,slash:59,sleep:[54,59,77],sleepi:59,sleeping:59,sleepy:59,slice:[19,49,52,59,63,74],slicedim:63,slight:61,slightli:[26,28,31,34,35,45,48,52,56,58,61,66,71,75,77],sloping:59,slot:[1,4,8,31,34,45,59,68],slot_machin:59,slotflag:1,slotnam:1,slotnumb:1,slottyp:1,slow:[19,25,35,42,52],slow_utf8_next:56,slowdown:52,slower:[2,6,25,29,39,42,74],slowest:19,slowli:52,slt_int:[52,85],small:[4,7,25,29,30,33,41,50,51,52,59,63,71,75,82,85],small_blue_diamond:59,small_orange_diamond:59,small_red_triangl:59,small_red_triangle_down:59,smallblacktriangleleft:59,smallblacktriangleright:59,smaller:[7,14,39,52,58,59,66,68,75,77,85],smallest:[25,34,39,64,66,74,75,76],smallin:59,smallni:59,smalltalk:58,smalltriangleleft:59,smalltriangleright:59,smart:51,smash:59,smashtim:59,smblkdiamond:59,smblklozeng:59,smblksquar:59,smc:22,smeparsl:59,smile:59,smile_cat:59,smilei:59,smiley_cat:59,smiling:59,smiling_imp:59,smirk:59,smirk_cat:59,smirking:59,smoke:59,smoking:59,smooth:75,smoothli:[46,50],smt:59,smte:59,smwhitestar:59,smwhtcircl:59,smwhtlozeng:59,smwhtsquar:59,snail:59,snake:59,snapshot:53,sneaki:21,snippet:[33,47],snow:59,snowboard:59,snowboarder:59,snowflak:59,snowflake:59,snowman:59,sob:59,soccer:59,sock:[48,71],socket:[48,51,69,71,77],soft:59,softwar:[39,50,56],software:59,sold:32,sole:26,solid:35,solidus:59,solut:[12,17,28,32,41,50,51,52,54,74,75],solv:[29,45,52,57,61,74],solve_tvar_constraint:21,solver:74,some:[1,2,5,6,7,8,11,13,14,15,19,21,22,25],some_arrai:33,some_complicated_th:37,some_different_th:37,some_old_valu:33,some_other_valu:33,some_specific_typ:33,some_valu:33,some_young_valu:33,somebodi:47,somefunct:34,someon:[28,31,50],someotherfunct:34,someth:[2,5,6,15,21,25,30,33,34,40,41,42,45,48,49,50,52,54,55,56],sometim:[4,6,15,19,25,28,29,30,31,33,34,35,42,45,46,47,48,51,52,53,58,60,64,67,74],somewhat:[21,29,48,52,56,58,61],somewher:[6,8,51,57],soon:[35,51,57,59,64,74],sooner:51,sophist:[28,30,35,45,49,54],sorensen:74,sorri:31,sortcol:82,sortedbi:[53,79],sorter:8,sortingalgorithm:50,sortperm:82,sortrow:82,sos:59,sound:59,sourc:[1,2,7,9,12,20,22,32,33,34,36,42,45,47,50,52,53,55,61,63,64,65,71,77,79,85],source:59,source_path:47,sout:59,south:59,space:[6,9,21,25,29,32,41,44,49,50,51,53,54,56,57,59,63,64,66,71,74,75,77,80,84],space_invad:59,spacing:59,spade:59,spadesuit:59,spaghetti:59,span:[25,32,51,63,74],sparam:14,sparam_sym:1,sparam_v:1,sparkl:59,sparkle:59,sparkler:59,sparkles:59,sparkling:59,sparkling_heart:59,sparsearrai:[41,57,63,74],sparsematrixcsc:[19,25,41,63,64,74],sparser:39,sparsevec:63,sparsevector:[40,63],sparsiti:25,spawn:[6,36,51,54,64,77],spawnat:[51,52,77],spdiagm:63,speak:[5,19,21,42],speak_no_evil:59,speaker:[56,59],specfunctionobject:6,special:[1,3,4,6,8,12,13,14],specif:[1,3,6,7,9,16,19,21,25],specifi:[1,3,5,11,13,15,17,19,21,25,26,28,29,30,31,32,34,35,36,39,41,44,45,46,47,48,49,50],specific:74,spectral:43,spectrum:74,spectyp:6,speech:[59,74],speech_balloon:59,speed:[4,9,42,51,53,59,71,74,76],speedboat:59,speedup:[52,71],spell:61,spend:75,spent:53,spey:[25,63,64],spherical:59,sphericalangl:59,sphericalangleup:59,spin:77,spinlock:77,spiral:59,splashing:59,splat:5,splice:[35,45,57,66,80],split:[19,32],splitdir:69,splitdriv:69,splitext:69,splitter:40,spoil:28,spoked:59,spone:[25,63],spot:[6,52,53],spouting:59,spqr:74,sprand:[25,63,74],sprandn:[25,63],springs:59,sprint:71,sprintf:[71,75],spun:8,spuriou:22,spzero:[25,63],sqcap:59,sqcup:59,sqlozeng:59,sqrint:59,sqrt:[25,27,29,33,34,35,39,40,44,49,52,53,58,59,60,74,75,76],sqrt_second:29,sqrtbottom:59,sqrtm:[43,74],sqsubset:59,sqsubseteq:59,sqsubsetneq:59,sqsupset:59,sqsupseteq:59,squar:[25,27,29,32,33,34,41,43,44,49,51,52,59,63,66,74,75],square:59,squarebotblack:59,squarecrossfil:59,squared:59,squarehfil:59,squarehvfil:59,squarellblack:59,squarellquad:59,squarelrquad:59,squareneswfil:59,squarenwsefil:59,squaresvector:41,squaretopblack:59,squareulblack:59,squareulquad:59,squareurblack:59,squareurquad:59,squarevfil:59,squeez:63,squiggle:59,squoval:59,srand:76,src:[2,7,11,15,18,50,63,65,69,74,84],sret:4,srv:40,ssa:[1,65],ssavalu:1,ssavaluetyp:1,ssh:[36,50,51,77],sshflag:[51,77],ssize_t:[26,65],sspreq:16,ssr:74,stabil:[34,52,57,82,84,85],stack:[1,3,6,8,9,23,29,33,38,52],stackfram:[55,83],stackoverflowerror:64,stacktrac:[23,55],stackwalk:55,stage:[1,6,7,12,26,50,54,64],stai:50,stand:[7,21],standalon:47,standard:[15,16,18,19,21],star2:59,star:[51,59],starequ:59,stars:59,start:[1,2,5,6,7,9,13,15,16,19,20,21,23,25,29,31,32,33,34],start_task:55,startpath:69,startswith:84,stat:[50,69,74],state:[6,9,12,21,28],statement:[1,5,13,16],static_ev:12,static_paramet:1,station:59,statist:[34,49,53,74],statistician:75,statstruct:[64,71],statu:[16,29],statue:59,statue_of_liberti:59,std:[18,41,74,75],stdcall:26,stderr:[6,18,54,64,67,71,72],stderr_fileno:18,stdin:[18,48,54,64,67,71],stdio:[6,9,10],stdm:75,stdout:[18,34,47,48,51,53,54,58,64,67,71,72,79],stdout_fileno:18,steam:59,steam_locomot:59,steaming:59,stebz:74,stefan:50,stefankarpinski:50,stegr:74,stein:74,stem:59,step:[2,6,7,8,11,15,21,28,33,45,47,50,51,52,57,66,68,71,75,76],steprang:[25,31,68],sterl:59,stev:74,stew:59,stewart:74,stick:57,sticki:69,stigma:59,stile:59,still:[6,8,15,18,26,28,29,31,32],stmt1:1,stmt2:1,stone:59,stop:[25,29,31,35,53,59,63,64,68,75,77,79],storag:[8,9,14],storagetyp:[15,63],store:[8,9,14,16,19,20,25,26,28,29,31,32,33,34,46,47,51,52,53,54,57,58,59,60,61,63,64,65,66,71,74,77,79],stori:28,str:[6,14,18,33,40,45,56,64,71,76,84],strace:2,straight:[32,52,59,74,75],straight_rul:59,straightforward:[15,21,31,36,56],straightness:59,strang:35,strange_two:52,strategi:[11,12,19,50],strawberri:59,strawberry:59,strcmp:6,stream:[1,6,9,18,23],streamer:59,street:31,strength:[48,53],strerror:72,strftime:72,stri:40,strict:[28,30,52],stricter:29,strictli:[1,19,21,29,30,49,64],strictly:59,stride1:19,stride:[5,19,25,40,52,63,74],stridedarrai:40,stridedmatrix:[25,40,74],stridedvecormat:40,stridedvector:[25,40,74],stringmim:[40,71],strip:[11,40,50,56,84],stripcc:84,stripignor:84,stripmark:84,strn:59,stroke:59,strokes:59,strong:42,strongest:45,strongli:[33,44,50,54,59,74],strptime:72,struck:59,struct:[1,4,6,7,9,14,21],structinfo:64,structur:[1,4,7,8],structure:26,strwidth:84,stuck:59,stuck_out_tongu:59,stuck_out_tongue_closed_ey:59,stuck_out_tongue_winking_ey:59,studi:[8,11],style:[16,19,23,25,29,35,38,40,45,47,49,52,56],sub2ind:[15,19,45,63],sub2ind_gen:45,sub2ind_gen_impl:45,sub2ind_loop:45,sub2ind_rec:45,sub:[32,47,74,77],subarrai:10,subclass:[46,71],subdiagon:74,subdivid:[58,75],subedot:59,subexpress:[1,29,32,45],subgroup:59,subject:[28,39,44,53,74],sublist:32,submatric:74,submatrix:74,submit:[22,50],submodul:47,submult:59,subroutin:26,subscript:[41,52,59,63],subsequ:[7,25,31,34,35,41,45,46,47,51,56,60,63,64,66,75,76,77,79],subset:[21,30,35,37,50,53,59,60,63,66,74,75,84],subsetapprox:59,subsetdot:59,subseteq:59,subseteqq:59,subsetneq:59,subsetneqq:59,subsetplu:59,subsim:59,subsitut:56,subspac:74,substanti:[34,52,53],substit:8,substitut:[26,33,40,45,56,74],substitutionstr:84,substr:[40,49,56,84],subsub:59,subsup:59,subtl:[22,48,52],subtleti:[39,61,64],subtract:[30,32,34,44,45,75,77],subtyp:[1,8,16],succ:59,succapprox:59,succcurlyeq:59,succe:[28,56,84,85],succeed:[59,74],succeeds:59,succeq:59,succeqq:59,success:[19,28,48,64,73,74,77],successfulli:[6,28,29,50,51,54,64,73],succinctli:[31,52],succnapprox:59,succneq:59,succneqq:59,succnsim:59,succsim:59,suffer:[8,52],suffic:[15,27,52,58],suffici:[30,32,46,58],suffix:[44,49,50,74,84],sugar:49,suggest:[11,26,40,50,52,53,57,66],suit:8,suitabl:[7,65,76],suitespars:74,sum:[3,25,28,30,41,49,51,52,53,59,63,64,66,74,75,76,77],sum_kbn:[57,63],sumab:66,sumabs2:[66,75],sumfoo:52,sumint:59,summar:[32,43,52,64],summarys:64,summat:63,summation:59,summedarrai:28,summer:31,sun:[59,68],sun_with_fac:59,sundai:[31,68],sunflow:59,sunflower:59,sunglass:59,sunglasses:59,sunni:59,sunris:59,sunrise:59,sunrise_over_mountain:59,sunset:59,sup:58,supdsub:59,supedot:59,superdiagon:74,superfici:34,superscript:[58,59],superset:59,supertyp:[40,41,58,64,77],suphsol:59,suphsub:59,supmult:59,supp:22,supper:74,suppli:3,support:[0,1,8,15],suppos:[26,28,29,34,47,50,54,58,85],supset:59,supsetapprox:59,supsetdot:59,supseteq:59,supseteqq:59,supsetneq:59,supsetneqq:59,supsetplu:59,supsim:59,supsub:59,supsup:59,surd:59,sure:[11,15,25,26,29,32,33,35,40,47,48,50,58,71,85],surface:59,surfer:59,surpris:[8,21,31,34,39,44,52,53],surprisingli:[45,51,52,58],surrend:51,surround:[7,26,32,45,46,58],surviv:33,suscept:[57,75],sushi:59,suspect:52,suspend:[29,51,77],suspens:28,suspension:59,suspension_railwai:59,svd:[43,49,51,52,74],svdfact:74,svdval:[43,74],svec:[8,16,21],sven:74,svn:11,swap:[75,76],swarrow:59,sweat:59,sweat_drop:59,sweat_smil:59,sweep:34,sweet:59,sweet_potato:59,swimmer:59,swirl:59,syconv:74,syev:74,syevr:74,sygvd:74,sylvest:74,sym:[5,32,45,73],symbol:[1,2,5,6,8,9,13,14,16,21,26,29,30,32,33,34,35,40],symbols:59,symdiff:66,symlink:69,symm:74,symmetr:[29,43,66,74],symmetri:[30,43,74,75],symptom:2,symtridiagon:[43,74],symv:74,sync:[34,51,52,71,77],synchron:6,synonym:26,syntact:[1,35,39,45,47,49,64],syr:74,syring:59,syringe:59,syrk:74,sys0:6,syscal:6,sysfunc:65,sysimag:36,sysimg_path:20,system:[1,6],systemat:50,systemerror:[29,64,65,69],sysv:74,sytr:74,sytrf:74,sytri:74,t_interpret:53,tabl:2,tabs:59,tack:59,tackl:56,tada:59,tag:[6,7,9,14,26,32],tail:[8,45,54,59],tailed:59,take:[6,7,8,12,16,17,20,21,22,25,26,27,28,29,30,31,32,33,34,35,36,39,41,44,45,46,47,48,49,50,51,52,53,57,58,59,64,65,66,68,71,74,75,77,79,83,84,85],takebuf_arrai:71,takebuf_str:71,taken:[5,8,29,32,36,44,46,49,51],talk:10,tan:[25,44,75],tanabata:59,tanabata_tre:59,tand:[25,44,75],tangent:75,tangerin:59,tangerine:59,tanh:[25,44,75],taocp:75,taper:59,target:[1,20,36,39,52,53,63,69,84],task:[6,7,9,19,20,23],task_local_storag:[29,77],taskhdl:29,tast:50,tau:[59,74],taup:74,tauq:74,tauru:59,taurus:59,taxi:59,tbaa:11,tcpserver:[48,71],tcpsocket:[48,51,71],tea:59,teacup:59,tear:59,teardrop:59,tears:59,teaser:52,technic:[25,32,34,35,36,40,58,63,71,75],techniqu:[6,34,35,42,52,53,58,74,75],technolog:46,tediou:45,tedium:52,telephone:59,telephone_receiv:59,telescop:59,telescope:59,television:59,tell:[1,3,32,33,46,50,56,58,64,72,84],teller:59,tempdir:69,templat:58,tempnam:69,tempor:[31,68],temporari:[1,12,18,25,34,35,45,49,52,54,62,69,82],temporarili:[29,64,65,69],tempt:[52,57],ten:[45,59],tend:[25,44,53,57,75],tendenc:52,tenni:59,tennis:59,tensor:[51,74],tent:[53,59],term:[2,5,7,15,19,21,27,28,30,31,35,41,45,46,47,54,56,58,75],termin:[26,29,33,40,48,49,50,51,56,58,64,68,71,77,84],terminolog:[26,28],ternari:29,terribl:54,territori:50,ters:[29,35,45],tesh:59,test:[2,6,8,14,15,21],test_approx_eq:85,test_approx_eq_ep:85,test_broken:85,test_error:64,test_skip:85,test_throw:85,testabl:57,testall1:17,testcb:77,testset:85,testsetexcept:85,testsocket:48,text:[31,32,36,40],text_color:40,text_str:84,textasciiacut:59,textasciicaron:59,textasciidieresi:59,textasciimacron:59,textbrokenbar:59,textdisplai:71,textdoublepip:59,textexclamdown:59,texthvlig:59,textnrleg:59,textnumero:59,textonehalf:59,textonequart:59,textordfeminin:59,textordmasculin:59,textpertenthousand:59,textperthousand:59,textphi:59,textquestiondown:59,textquotedblleft:59,textquotedblright:59,texttheta:59,textthreequart:59,texttildelow:59,texttrademark:59,textturnk:59,textual:[45,71],textvisiblespac:59,tfunc:12,tgsen:74,than:[1,2,3,6,8,15,19,21,22,25,26,27,28,29,30,31,32,33,34,35,36,39,41,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,63,64,66,68,69,71,74,75,76,77,82,83,84],thank:[39,58],thankfulli:31,thanksgiv:31,the_except:1,the_lock:77,thei:[1,6,7,8,12,19,21,25,26,27,28,29,30,31,32,34,35,39,41,42,44,45,46,47,49,50,51,52,54,56,57,58,59,60,61,63,64,65,66,71,74,76,77,78,82,84,85],them:[7,8,12,19,21,25,26,27,28,29,30,32,34,35,39,43,44,45,47,49,50,51,52,53,54,55,56,57,58,61,64,65,66,71,74,76,77,78],themselv:[16,28,32,35,42,47,51,56,58,66],theoret:12,theori:[21,34,58],therebi:[20,28,35,47,51,52,58,82],therefor:[7,8,11,16,19,21,25,26,28,30,32,35,40,43,45,49,51,52,56,57,58,59,61,62,66,71,74,75],therefore:59,therein:47,thereof:[16,19,58,77],theta:[32,59],thi:[1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,25,26,27,28,29,30,31,32,33,34,35,36,37,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,63,64,65,66,69,71,72,73,74,75,76,77,78,79,82,83,84,85],thickspac:59,thin:[33,59,74],thing1:47,thing2:47,thing:[8,15,19,21,22,28,31,32,33,34,45,48,50,51,52,54,56,57,58,61,75,82],think:[2,19,29,30,31,34,48,51,58],thinspac:59,third:[5,19,25,26,28,30,31,32,35,44,46,53,56,59,63,75,84],thirty:59,this_function_does_not_exist:33,thiscal:26,thisindex:19,thorn:59,those:1,though:[9,19,21,25,26,27,30,31,32,33,35,41,46,48,49,50,53,58,64,74,84,85],thought:[34,51,58,59],thought_balloon:59,thousand:[52,59],thread:[6,10],threadid:[51,65,77],threadpool:51,threadsaf:[12,77],three:[4,8,21,26,29,32,35,39,41,44,45,46,47,50,51,52,54,56,57,58,59,61,71,74,75,84],threearg:34,threedangl:59,threeunderdot:59,threshold:[30,74],threw:[35,85],through:[3,6,7,8,9,12,15,18,21],throughout:[8,15,18,28,41,57,58],throughput:54,throwing:59,thrown:[26,28,29,30,33,56,57,58,64,71,74,77,83,85],thta:4,thu:[3,12,15,25,26,28,30,31,34,39,44,45,46,48,50,51,52,56,57,58,61,66,68,75],thumb:52,thumbs:59,thunk:16,thursdai:[31,68],tic:[49,52,64],ticket:59,tidi:50,tie:[28,59],tieconcat:59,tiger2:59,tiger:59,tight:[3,52,64],tightli:[27,44,63],tightly:59,tild:[59,69],tilde:59,tildetrpl:59,tile:59,till:[51,77],time:[1,2,5,6,7,8,9,12,15,17,20,22,23,25,26,29,31,32,33,34,35,42,43,44,45,46,47,49,50,51],time_n:64,timedout:71,timedwait:77,timeit:52,timelimit:75,timelin:[31,68],timeout:[71,77],timeout_:71,timeperiod:31,timer:[51,64,71],times:59,timesbar:59,timestamp:69,timestep:52,timestr:72,timev:64,timezon:[31,68,72],tini:[51,52],tip:0,tired:59,tired_fac:59,titl:[32,64,74],titlecas:84,tmp:[20,35,40,50,53,62,71],tmstruct:72,to_funct:6,to_index:3,to_shap:41,toc:[49,52,64],todai:[34,68],todo:9,toea:59,tofirst:68,togeth:[7,8,19,28,29,30,32,36,40,45,46,47,51,53,56,57,64,68,77,82,84],toggl:[47,66],toi:[41,51],toilet:59,token:[7,50,84],tokyo:59,tokyo_tow:59,tol:[30,74,75,85],tolast:68,told:26,toler:[30,64,74,75,85],tomato:59,tona:59,tone:59,tonext:[31,68],tongu:59,tongue:59,too:[5,8,14,18,19,32,33,35,41,45,49,50,51,52,58,64,71],took:[34,64],tool:[2,11,22,32,45,50],toolchain:17,top:[8,11,12,14,15,16,26,32,39,41],top_fram:55,topbot:59,topdown:69,tophat:59,topic:[29,32,39,40,64],toplevel:[1,7,9,12,16],topmost:71,toprev:[31,68],topsemicircl:59,toq:64,torch:59,tosa:59,total:[15,50,51,53,64,68,71,75,82,85],touch:69,towa:59,toward:[2,30,31,39,44,75],tower:59,trace:[6,22,23,38],track:[2,7,11,14,29,36,41,50,51,52,53,55,64,77,79],tractor:59,trade:[42,59],trademark:59,tradit:[27,35,41,42,46,56,58,71,84],tradition:[30,35,42,58],traffic:[51,59],traffic_light:59,trail:[26,35,36,40,56,58,63,71,76,84],trailing_on:76,trailing_zero:76,train2:59,train:59,tram:59,tramway:59,tran:74,trang:51,transa:74,transact:[74,77],transb:74,transcod:[56,84],transfer:77,transfinite:59,transform:[7,8,25,28,35,45,49,63,64,66,74,75,77,82,84],transit:31,translat:9,transliter:49,transpar:[14,34],transpos:[25,35,40,41,63,74,80],transposit:[49,74],transversal:59,trap:34,trapezium:59,trapezoid:74,trash:78,travers:[64,69],travi:50,tray:59,trcon:74,treat:[25,26,45,49],tree:[2,7,16,32,33,45,50,53,59,69,79],trend:59,trevc:74,trexc:74,tri:[7,26,31,33,64,71,77],trial:[51,52],triangl:[35,44,74],triangle:59,trianglecdot:59,triangledown:59,triangleleft:59,triangleleftblack:59,trianglelefteq:59,triangleminu:59,triangleplu:59,triangleq:59,triangleright:59,trianglerightblack:59,trianglerighteq:59,triangletim:59,triangular:[43,59,74],triangular_flag_on_post:59,triangular_rul:59,trick:52,tricki:[12,31,44],trickier:47,trident:59,tridiagon:[43,74],trigamma:75,trigger:[6,8,16,21,47,53,64,77],tril:74,trim:63,trip:[7,49,52],tripl:[32,49],triple:59,tripleplu:59,triu:74,triumph:59,trivial:[8,34,50,51,52],trmm:74,trmv:74,trolleybu:59,trolleybus:59,trophi:59,trophy:59,tropical:59,tropical_drink:59,tropical_fish:59,troubl:[51,56,57],trrf:74,trsen:74,trsm:74,trsv:74,trsyl:74,trtr:74,trtri:74,truck:59,trumpet:59,trunc:[25,26,44,52,68,75],truncat:[26,30,44,47,52,53,68,71,75],try_block:1,trylock:77,trypars:76,tst:62,ttl:71,tty:[9,18,48,71],tty_col:53,tue:[31,68],tuesdai:[31,68],tulip:59,tunnel:[51,77],tupl:[1,3,4,5,6,8,11,13,14,15,16,18,19],tuple2:58,turban:59,turn:[1,7,8,13,28,29,31,36,47,52,53,56,58,64,65,74],turnangl:59,turned:59,turnediota:59,turnednot:59,turnstile:59,turtl:59,turtle:59,tutori:36,tvar:21,twelve:59,twice:[44,53],twisted:59,twisted_rightwards_arrow:59,twister:76,two:[1,6,8,14,15,19,21,25,26,28,29,30,31,32],two_heart:59,two_men_holding_hand:59,two_women_holding_hand:59,twocap:59,twocup:59,twoheaddownarrow:59,twoheadleftarrow:59,twoheadleftarrowtail:59,twoheadleftdbkarrow:59,twoheadmapsfrom:59,twoheadmapsto:59,twoheadrightarrow:59,twoheadrightarrowtail:59,twoheaduparrow:59,twoheaduparrowcircl:59,twonot:59,twostep:45,txt:[48,53,54,64,71],typ:[1,45,64],type1:64,type2:64,type_intersection_match:21,type_match:21,type_match_morespecif:21,type_morespecif:21,typea:49,typealia:[26,32,58,81],typeassert:[8,26,58],typeb:49,typecach:12,typecheck:52,typeconstructor:8,typed_comprehens:1,typed_hcat:1,typed_vcat:1,typedef:[14,21,26],typedslot:1,typeerror:[29,58,64],typeinf:[7,12,53],typeinf_uncach:8,typeintersect:[21,64],typejoin:[21,64],typeless:42,typemapentri:47,typemaplevel:47,typemax:[34,39,53,64,71,75,76,79],typemin:[34,39,64,75,76],typenam:8,typesof:16,typic:[1,2,3,7,8,13,14,22,25,26,27,28,29,30,33,35,39,41,42,46,47,49,51,53,55,56,57,58,63,64,65,71,74,75,76,78,82,85],typo:50,tzrzf:74,u10ffff:56,u110000:56,u2200:[45,56],u2203:56,u5272:59,u5408:59,u55b6:59,u6307:59,u6708:59,u6709:59,u6e80:59,u7121:59,u7533:59,u78:56,u7981:59,u7a7a:59,u80:56,uax:84,ucfirst:84,udp:71,udpsocket:71,uff:56,uglier:52,uid:[21,64,69],uint128:[39,46,49,58,76,77],uint128_str:1,uint16:[26,30,39,46,49,58,65,71,76],uint16_t:14,uint32:[26,39,44,46,49,58,63,65,76,84],uint32_t:[8,9,14],uint64:[26,39,46,49,58,64,65,76],uint8:[1,21,26,30,39,44,46,48,49,52,56,57,58,64,65,71,76,77,84],uint8_t:9,uint:[26,39,58,64,65,71,83],uintmax_t:[26,65],uintxx:84,ularc:59,ulblacktriangl:59,ulcorn:59,ull:49,ultim:[28,29,34,71],ultriangl:59,umbrella:[58,59],umfpack:[43,74],umfpacklu:[43,74],uminu:59,unabl:[6,29,51],unalloc:71,unalt:56,unam:67,unambigu:58,unamus:59,unamused:59,unannot:16,unari:[25,39,44,75],unassign:[28,84],unavoid:[15,47,50,51],unawar:31,unbalanc:51,unbind:34,unbound:[21,34,76],unbox:[7,11,14,33],uncaught:29,uncertain:[31,52],uncertainti:[52,53],unchecked_aliasing_permut:63,unchecked_noalias_permut:63,unclear:[12,49],uncommon:50,uncondit:1,uncondition:52,unconnect:[51,77],unconstrain:[46,58],unconvent:[15,63],undeclared_vari:55,undecor:32,undef:21,undefin:[1,14,26,28,35,41,44,45,46,51,57,63,64,65,66,75,77],undefreferror:[28,29,64],undefvarerror:[29,45,61,64],under:[6,19,21],underag:59,underbar:59,underbrac:59,underbracket:59,underdot:59,underflow:[34,75],undergo:2,underleftarrow:59,underleftharpoondown:59,underleftrightarrow:59,underli:[15,19,21,25,26,31,34,39,48,51,52,65,71,74,77],underneath:74,underrightarrow:59,underrightharpoondown:59,underscor:[26,39,57,60],underscore:59,understand:[8,14,16,21,26,29,30,39,42,45,47,51,52,53,55],undesir:54,undoe:75,unduli:58,unencrypt:51,unequ:64,unescap:[56,71,84],unescape_str:[71,84],unevenli:63,unexpect:[29,31,52,60,63,74,76],unexpectedli:[2,22,25,34,52,58],unexport:[3,63],unfamiliar:39,unfavor:58,unfetch:51,unfortun:[19,34,52],unhappi:34,unicod:[23,32,35,38,40,42],unicodeerror:[29,56],unifi:[18,42],unified:59,uniform:[18,19],uniformli:[25,76],uniformsc:[43,74],unimpl:26,uniniti:[17,25,26,28,34,63,71],unintend:3,uninterpret:26,unintuit:[29,42],uninvit:28,union:[8,15],uniqu:[1,6,14,21,27,40,45,46,47,50,53,63,64,66,69,74,75,77],uniquedbyid:47,unit:[23,44,49,52,59,70,74,76,84],unitari:[74,75],unitrang:[15,19,25,52,57,63,66,74],univers:21,universal:59,universaldeclarationofhumanrightsstart:60,unix2datetim:68,unix:[26,48,50,51,53,54,64,68,69,71,78],unknown:[1,11,12,14,26,58],unless:[20,26,47,50,52,53,54,56,57,58,60,61,63,64,68,74,76,77,79,82,84,85],unlik:[25,29,31,32,49,54,56,65],unlike:[1,21,25,29,31,34,41,44,49,51,58,61,77],unlimit:58,unlock:[34,59,77],unmark:71,unmatch:84,unmodifi:[49,69,74,77,82],unnam:65,unname:26,unnatur:42,unnecessari:[31,32,39,48,52,56],unnorm:75,unobtrus:[42,58],unord:[32,64,66,75],unorder:32,unpack:[8,26],unpermut:74,unpin:50,unpreced:42,unpredict:[34,51,64],unquot:[16,45,49,56],unrel:[47,56],unrestrict:12,unrol:[34,45],unsaf:[14,26,36],unsafe_convert:[25,26,65],unsafe_copi:65,unsafe_load:[26,57,65],unsafe_pointer_to_objref:[26,65],unsafe_read:71,unsafe_stor:[26,65],unsafe_str:[26,84],unsafe_trunc:75,unsafe_wrap:[26,65,84],unsafe_writ:71,unscal:74,unset:64,unsettl:34,unshift:66,unsign:[26,39,44,49,58,65,75,76],unsort:25,unspecifi:[28,36,52,66,75,77],unstabl:[34,52,56],unsupport:[26,45],untest:32,until:[7,18,21,26,28,29,46,50,51,58,68,71,75,77],untouch:34,unus:[1,8],unusu:[50,52],unwant:[49,57],unwind:[5,9,29],upand:59,uparrow:59,uparrowbar:59,upcom:47,updasharrow:59,updat:[15,33,34,35,40,41,44,47,49,50,51,64,74,78],updownarrow:59,updownarrowbar:59,updownharpoonleftright:59,updownharpoonrightleft:59,upepsilon:59,upequilibrium:59,uperm:69,upgrad:[50,78],upgrade:50,upharpoonleft:59,upharpoonright:59,upharpoonsleftright:59,upin:59,upint:59,upkoppa:59,uplo:74,upload:50,uplu:59,upmu:59,upnu:59,upoldkoppa:59,upomicron:59,upper:[21,43,50,56,59,60,74,75,77,84],uppercas:[26,48,56,84],uppertriangular:[43,74],upsampi:59,upsilon:59,upstigma:59,upstream:[50,78],upuparrow:59,upvarbeta:59,upward:59,upwards:59,upwhitearrow:59,uranu:59,uranus:59,urarc:59,urblacktriangl:59,urcorn:59,url:[32,50,64,69,74,78],urtriangl:59,usa:50,usabl:[6,7,58],use64bitint:2,use:[11,18,20,25,27,32],use_llvm_shlib:11,use_mmap:71,useclang:17,used:[51,56,64,71],usefulli:[6,46],user:[3,7,11,15,19,20,22,25,26,28,29,30,31,32,34,35,36,39,40,42,45,47,49,50,51,52,53,54,57,58,59,60,64,68,69,71,74,77,79,84,85],userdata:51,userimg:20,userimg_path:20,usernam:50,username:50,using:[0,5],usr:[2,6,11,33,40],usual:[3,4,6,11,25,27,28,31,32,35,42,44,47,48,50,52,53,55,57,61,63,64,71,74,75,76,83],usualli:[52,64,74],ut1:31,utc:[2,36,40,68],utf16:50,utf16string:56,utf32string:56,utf8:[36,60],utf:[26,42],util:[11,40,45,47,58],utinstant:[31,68],uuparrow:59,uv_async_send:[26,64],uv_handle_type:18,uv_handle_type_max:18,uv_stream_t:18,uv_threadpool_size:[51,77],uv_writ:[9,18],uverror:64,uvw:18,va_arg:26,va_list:18,vagu:25,val1:1,val2:1,val:[26,33,45,49,52,58,63,64,74,75,77,85],valgrind:0,valid:[1,15,18,19,20,25,26,28,30,31,33,34,39,41,44,47,49,50,56,57,58,60,63,64,65,66,68,69,71,72,73,74,75,76,77,79,84],valtyp:66,valu:[1,4,5,6,7,8,9,14,15,18,19,21,25],value1:[49,61],value2:49,value3:61,value_t:6,valuetodayofweek:31,valuetomonth:31,valuetyp:66,van:74,var1:[1,61],var2:[1,61],var3:61,var_sym:45,vararg:[8,15,21,26],varbarwedg:59,varcarriagereturn:59,varclubsuit:59,vardiamondsuit:59,vardim:75,vardoublebarwedg:59,varepsilon:59,varheartsuit:59,varhexagon:59,varhexagonblack:59,varhexagonlrbond:59,vari:[34,40,55,71,74],variabl:[1,5],variablenam:49,variad:[1,26],varianc:75,variant:[12,26,32,44,52,56,59,71,74,75,79,82],variat:[8,23,34],variation:59,varieti:[3,16,29,30,58],variou:[7,9,14,26,29,30,36,37,43,46,48,50,51,54,56,58,64,75,84],varisin:59,varisinobar:59,varkappa:59,varlrtriangl:59,varm:75,varni:59,varniobar:59,varnoth:59,varointclockwis:59,varphi:59,varpi:59,varrho:59,varsigma:59,varspadesuit:59,varstar:59,varsubsetneqq:59,varsupsetneq:59,vartheta:59,vartriangl:59,vartriangleleft:59,vartriangleright:59,varveebar:59,vast:[8,45,47],vastli:[20,52],vcat:[1,25,35,49,63],vdash:59,vdot:59,vec:[34,52,59,63],vecdot:74,vecelement:[26,81],vecnorm:[74,75],vect:1,vector1:35,vector2:35,vector:[1,3,4,11,15],vectorize_1arg:25,vectorize_2arg:25,vee:59,veebar:59,veedoublebar:59,veeeq:59,veemidvert:59,veeodot:59,vehicle:59,veil:59,vendredi:31,venu:59,ver:78,verbatim:45,verbos:[45,56,58,64],verbose:6,verbose_fussy_sqrt:29,veri:[1,2,6,7,8,13,19,21,28,29,30,32,34,41,42,45,46,48,49,50,51,52,53,56,58,63,66,75,77,82],verifi:[26,28,33,50,51,52,63,74,85],versa:[19,44,64],versioninfo:[2,64],versionnumb:[50,56,67,78],versu:[27,52,62],vert:59,vertcat:49,vertic:[32,49,63,80],vertical:59,vertical_traffic_light:59,vertoverlai:59,very:59,verymuchless:59,via:[4,7,8,11,15,21,26,32,34,35,36,42,46,47,49,50,51,52,53,54,56,58,61,62,63,64,71,74,75,76,77,81,82,84,85],vibration:59,vibration_mod:59,vice:[19,44,64],victory:59,video:[36,59,71],video_camera:59,video_gam:59,videocassette:59,view:[6,7,16,19,25,31,35,45,47,51,53],viewdata:59,viewindex:19,viewing:59,violat:[12,28,45,58],violin:59,virgo:59,virtual:[7,49],visibl:[25,26,29,31,35,47,49,50,51,61,64,71],visit:[25,63],visual:[1,35,39,50,52,78,84],voiced:59,vol:[74,75],volcano:59,voltage:59,volum:54,volume:59,vrectangleblack:59,vsl:74,vsr:74,vulgar:59,vvdash:59,vvert:59,vysmblkcircl:59,vysmblksquar:59,vysmwhtsquar:59,w_in:74,w_stream:77,wai:[5,6,7,8,9,11,15,18,19,21,22,25,26,28,29,30,32,33,34,36,39,41,42,45,47,48,49,50,51,52,53,56,57,58,61,63,64,71,75,77,82,85],wait:[2,7,12,26,29,34,48,51,52,54,64,71,77],waitfor:77,wake:[64,77],wakeup:26,walk:[6,15,59,69],walkdir:69,waning:59,waning_crescent_moon:59,waning_gibbous_moon:59,want:[3,5,6,7,13,15,22,26,28,29,30],warm:21,warn:[11,18,22],warning:[29,59,60],wast:[25,52],watch:[6,21,49,59,71],watch_fil:71,water:59,water_buffalo:59,watermelon:59,wave:[52,59],waves:59,waving:59,wavy:59,wavy_dash:59,waxing:59,waxing_crescent_moon:59,way:59,wchar_t:[26,65,84],wdai:72,weak:[9,66],weakkeydict:66,weakref:47,weari:59,weary:59,web:50,websit:[32,50],wed:[50,59,68],wedding:59,wedg:59,wedgedot:59,wedgedoublebar:59,wedgemidvert:59,wedgeodot:59,wedgeonwedg:59,wedgeq:59,wednesdai:[31,68],week:[31,68],weight:[25,77],well:[7,8,17,22,29,30,31,32,33,39,40,41,43,44,46,49,50,51,52,53,56,57,58,60,61,63,64,74,75,82],were:[5,6,8,19,26,28,31,34,35,40,44,46,47,49,53,58,74,82],weren:29,west:59,wget:69,whale2:59,whale:59,what:[2,5,6,7,8,12,15,19,21,28,29,30,31,32,33],whatev:[7,9,26,45,50,61,78,82],whatsoev:56,wheel:59,wheelchair:59,when:1,whenc:77,whenev:[7,14,26,28,29,32,35,36,46,47,51,52,64,74],where:[1,3,4,5,6,8,9,11,15,18,19,20,21,25,26,27,28,29,31,32,33,34,35,39,40,41,42,44,45,46,47,49,50,51,52,53,55,57,58,61,63,64,65,66,67,68,69,71,73,74,75,76,77,82,84,85],wherea:[3,5,15,19,21,25,45,49,54,56,58,71,74,75,79],wherebi:25,wherein:[51,58],wherev:[18,32,44,50,66],whether:[1,5,7,8,12,15,18,19,21,27,28,29,30,31,32,33,35,36,39,42,43,44,46,47,50,52,53,55,56],which:[1,3,5,6,7,8,9,12,13,14,15,16,17,19,20,21,25,26,28,29,30,31,32,33,34,35,37,39,40,41,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,61,62,63,64,65,66,67,68,69,71,72,73,74,75,76,77,78,79,82,84,85],whichev:[51,63,64,77],white:[40,59,71],white_check_mark:59,white_circl:59,white_flow:59,white_large_squar:59,white_medium_small_squar:59,white_medium_squar:59,white_small_squar:59,white_square_button:59,whitearrowupfrombar:59,whiteinwhitetriangl:59,whitepointerleft:59,whitepointerright:59,whitespac:[32,39,40,45,49,50,56,71,84],whizbang:50,who:[6,29,33,34,39,47,50,64,69,79],whoa:46,whole:[7,9,25,26,28,47,51,52,56,58,65,71,75,84],whom:56,whoop:55,whose:[1,8,26,28,30,35,44,47,48,51,56,58,63,64,66,69,71,74,75,84],whthorzov:59,whtvertov:59,why:[2,5,21,26,29,31],wide:[26,30,50,53,56,59,84],wideangledown:59,wideangleup:59,widebridgeabov:59,widemul:75,widen:[8,28,64],wider:[25,53],wideutild:59,width:[26,31,35,56,68],wil:50,william:39,willing:34,win32:72,win64:56,wind:[50,59],wind_chim:59,window:[6,9,20,26,33,48,50,51,53,64,69,71,72,77],windows_hid:64,windows_verbatim:64,windows_vers:64,wine:59,wine_glass:59,wings:59,wink:59,winking:59,winston:50,wint_t:26,wip:50,wise:[34,49,52,74,75],wish:[3,13,25,29,50,51,52,63,71,77],with_keyword:52,withenv:64,within:[3,6,13,17,21,25,26,30,32,34,35,39,45,47,49,50,51,52,56,61,62,63,64,66,67,71,74,75,77,84],without:[5,7,13,14,15,19,25,26,28,29,32,33,34,35,39,40,43,45,46,47,49,50,51,52,54,56,57,58,59,60,61,62,63,64,65,66,68,71,74,75,76,77,78,83,84,85],wittingli:20,wizardri:63,woken:[64,77],wolf:59,woman:59,womans:59,womans_cloth:59,womans_hat:59,women:59,womens:59,won:[45,47,50,54,58],word:[7,8,15,21,30,32,34,35,39,40,44,45,46,49,50,53,54,57,58,59,60,67,71],word_size:[2,39,67],work:[5,6,7,8,9,10],workaround:34,workcolptr:63,worker:[6,22,36,51,52,54,59,65,74,77],worker_id_from_socket:77,workerconfig:[51,77],workerpool:77,workflow:[23,34,38],working_dir:64,workload:51,workspac:[47,61,64,74],world:[6,9,28,45,48,52,54,56,58,60,64,84],worri:[26,30,47,48,50,59],worried:59,wors:[19,34,52,58,61],worst:8,worth:[15,21,44,51,57,58,75,77],worthwhil:52,would:[5,7,8,11,12,15,19,20,21,22,25,26,28,29,30,31,32,34,35,44,45,46,47,48,49,50,51,52,53,54,56,57,58,60,61,63,64,65,66,68,71,75,76,77,82,84],wouldn:[1,34],wrap:[1,8,15,26,29,31,33,34,35,39,41,45,49,50,52,57,62,64,65,68,71,74,77,84],wraparound:[39,64],wrapped:59,wrapper:[4,7,9],wreath:59,wrench:[19,59],wrinkl:[8,28],writabl:[71,77],write:[3,5,6,9,12],writeal:54,writecsv:71,writedlm:71,writefunc:71,writelock:12,writer:[51,54],written:[1,4,7,15,21,25,26,27,29,32,33,34,35,36,40,41,42,44,45,46,47,48,49,50,51,52,53,54,57,58,64,65,71,72,75,77],wrong:[2,26,29,35,45,47,64,77],wry:59,www:[32,74,75],x7f:56,x80:56,x86:[26,81],x86_64:[2,26,36,40],x_1:5,x_2:5,x_3:5,x_str:1,xarg:33,xchg:77,xcorr:75,xdata:33,xff:[39,45,56],xggsvd3:74,xinc:52,xor:[44,49,59,77,80],xylophon:[54,56],xyz:64,yank:40,yao:74,ydai:72,year:[31,50,52,64,68,72],yearmonth:[31,68],yearmonthdai:[31,68],yellow:[40,59,71],yellow_heart:59,yen:59,yet:[8,13,15,21,26,29,31,35,39,42,45,46,48,50,52,56,58,64,71,75,85],yield:[1,5,26,34,35,39,51,52,64,66,68,71,75,76,77],yieldto:[29,77],yml:50,ymm:68,yogh:59,you:[2,3,5,6,8,11,13,14,15,17,19,21,22,25,26,27,28,29,30,31,32,33,34,35,36,40,41,42,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,60,62,63,64,65,66,68,71,72,74,75,76,77,78,79,82,85],young:33,your:[2,3,6,13,15,17,22,25,26,28,29,32,34,35,40,41,44,45,47,48],yourself:[21,26,28,32,34,50,52,53],youtub:36,yum:59,yup:59,yyyi:68,yyyymm:31,yyyymmdd:[31,68],zap:59,zbar:59,zero:[3,4,5,9,15,25,26,27,28,29,30,31,33,34,35],zeroarrai:15,zeromq:51,zerorang:15,zerox:45,zeta:[25,44,59,75],zigzag:59,zip2:66,zip:[49,66,71],zlocal:26,zmat:74,zone:31,zzz:59},titles:[\"Developing/debugging Julia&#8217;s C code\",\"Julia ASTs\",\"Reporting and analyzing crashes (segfaults)\",\"Bounds checking\",\"Calling Conventions\",\"Base.Cartesian\",\"gdb debugging tips\",\"Eval of Julia code\",\"Julia Functions\",\"Initialization of the Julia runtime\",\"Documentation of Julia&#8217;s Internals\",\"Working with LLVM\",\"Proper maintenance and care of multi-threading locks\",\"Talking to the compiler (the <code class=\\\"docutils literal\\\"><span class=\\\"pre\\\">:meta</span></code> mechanism)\",\"Memory layout of Julia Objects\",\"Arrays with custom indices\",\"Reflection and introspection\",\"Sanitizer support\",\"printf() and stdio in the Julia runtime\",\"SubArrays\",\"System Image Building\",\"More about types\",\"Using Valgrind with Julia\",\"Julia Documentation\",\"Julia Documentation\",\"Multi-dimensional Arrays\",\"Calling C and Fortran Code\",\"Complex and Rational Numbers\",\"Constructors\",\"Control Flow\",\"Conversion and Promotion\",\"Date and DateTime\",\"Documentation\",\"Embedding Julia\",\"Frequently Asked Questions\",\"Functions\",\"Getting Started\",\"Handling Operating System Variation\",\"The Julia Manual\",\"Integers and Floating-Point Numbers\",\"Interacting With Julia\",\"Interfaces\",\"Introduction\",\"Linear algebra\",\"Mathematical Operations and Elementary Functions\",\"Metaprogramming\",\"Methods\",\"Modules\",\"Networking and Streams\",\"Noteworthy Differences from other Languages\",\"Packages\",\"Parallel Computing\",\"Performance Tips\",\"Profiling\",\"Running External Programs\",\"Stack Traces\",\"Strings\",\"Style Guide\",\"Types\",\"Unicode Input\",\"Variables\",\"Scope of Variables\",\"Workflow Tips\",\"Arrays\",\"Essentials\",\"C Interface\",\"Collections and Data Structures\",\"Constants\",\"Dates and Time\",\"Filesystem\",\"The Julia Standard Library\",\"I/O and Network\",\"C Standard Library\",\"Dynamic Linker\",\"Linear Algebra\",\"Mathematics\",\"Numbers\",\"Tasks and Parallel Computing\",\"Package Manager Functions\",\"Profiling\",\"Punctuation\",\"SIMD Support\",\"Sorting and Related Functions\",\"StackTraces\",\"Strings\",\"Unit Testing\"],titleterms:{\"abstract\":[41,52,58],\"break\":52,\"byte\":56,\"case\":[28,30],\"catch\":[29,57],\"default\":[35,47],\"final\":29,\"float\":[39,57],\"function\":[5,6,8,25,26,29,31,32,33,34,35,44,45,46,52,57,63,64,66,68,74,75,76,78,82],\"import\":[1,34],\"new\":[30,50],\"null\":34,\"return\":[26,33,35],\"short\":29,\"static\":57,\"throw\":[29,33],\"try\":[29,57],_start:9,abi:4,about:[21,26,57],absolut:[44,47],abstractchannel:51,abstracttestset:85,abstractunitrang:15,abus:52,access:[26,32,33,52,58],accessor:[31,68],accumul:53,adding:[8,50],address:[17,48],adjuster:[31,68],admonit:32,advanc:[32,45],aka:[29,52],algebra:[43,74],algorithm:82,alia:11,alias:58,all:64,alloc:[14,34,52,53],allocat:15,allow:60,along:52,ambiguiti:46,analysi:[11,53],analyz:2,annot:15,annotat:52,anonym:[5,35],any:21,append:57,arbitrari:39,argument:[5,8,26,34,35,46,52,57],arithmet:[31,34,39,44],around:64,arrai:[15,25,33,34,41,51,52,56,63,77],asan:17,asked:34,assignment:[25,63],associ:66,ast:1,asynchron:34,attent:52,auto:26,automat:33,availabl:[50,51],avoid:[52,54,57],background:[15,39],backtrac:55,bare:47,barrier:52,base:[5,9,57,62,85],basic:[5,25,45,48,53,56,62,63,85],behavior:[35,39],beta:34,between:[18,34],bigfloat:76,bind:40,bit:[14,26,58],bitarrai:63,bitwis:44,blas:74,block:[1,32,35,61],bold:32,bootstrap:[2,6,7],bottom:21,bound:[3,15],bracket:1,branch:50,breakpoint:6,broadcast:25,broken:[12,85],browser:62,build:[6,11,20,33,45],built:29,builtin:8,call:[1,3,4,6,8,26,33,34],callback:26,caller:57,can:34,care:[12,57],cartesian:[5,19],caveat:22,ccall:[26,77],certain:[6,34],cfunction:26,chain:44,chang:[50,52],channel:51,charact:56,check:[3,15,58],checkout:50,circuit:29,claus:29,clear:53,closur:8,cluster:[51,77],clustermanag:51,code:[0,7,15,18,26,32,45,50,51,57],code_warntyp:52,coeffici:39,collect:[26,51,66],collector:[14,33],color:40,column:[25,52],combin:34,combinator:63,command:33,common:56,comparison:[31,44,55],compat:26,compil:[8,13],complet:40,complex:[27,54],composit:58,compound:29,comprehens:[25,61],compress:25,comput:[51,77],concaten:[25,63],concurr:34,condit:[6,29,57],config:33,configur:53,conflict:39,confus:57,consider:[17,22],consist:57,constant:[26,61,67,68,76],constrain:46,construct:[25,58],constructor:[8,25,28,31,34,63],contain:[52,57],contextu:48,control:[29,53],convent:[4,26,57,60],convers:[26,28,30,44,68],convert:33,cooki:51,core:29,coroutin:29,correspond:[25,26],crash:2,creat:[8,26,50,85],csc:25,custom:[15,40,50,51,58,85],danger:52,data:[12,26,51,66,76],date:[31,68],datetim:31,deadlock:54,deal:6,debug:[0,6],declar:[34,52,58],defin:[30,46],definit:[7,34,47,52],delet:34,dens:25,deprec:[15,26,34,52],dequeu:66,descript:50,design:19,detail:[19,50],determin:33,develop:[0,23,50],differ:[11,34,40,49],dimension:25,dirti:50,dispatch:52,displai:[6,32,53],distribut:51,divers:57,divis:[39,44],document:[10,23,24,32,50],doe:34,domainerror:34,don:57,dot:35,durat:31,dure:[2,6,18,52],dynam:73,editor:62,effect:45,effici:8,elabor:57,element:32,elementari:[43,44],elide:3,embed:33,empty:46,environ:2,epoch:31,epsilon:39,equal:57,equat:32,error:[2,6,29,39,55,64],essential:64,eval:[7,9,45],evalu:45,evaluat:[29,35],event:[29,64],exampl:[26,33,45,48,54],exception:[29,33],excess:57,execut:[7,50,52],exist:[15,50],expansion:7,experiment:[51,77],expos:57,expr:1,express:5,expression:[25,29,45,56],extension:32,external:54,extract:55,factor:43,few:19,field:[19,52,57],file:[6,47,48],filesystem:69,fix:[50,52],flow:29,footnot:32,form:1,format:76,fortran:26,framework:6,free:50,frequent:34,from:[6,49,52],further:35,garbag:[14,26,33,51],gdb:6,gener:[7,8,15,17,22,25,32,45,46,50,57,64,66,71,76,77],get:[36,64],give:34,global:[12,26,32,52,61],glossari:2,guid:[26,32,57],guidelin:50,handl:[29,37,55,57],hard:61,header:32,heap:66,help:40,hierarchi:3,high:33,hoc:50,hold:45,horizont:32,how:34,hygien:45,hyperbol:44,imag:20,image:[7,20,32],immut:34,immutabl:58,implement:[15,25],importal:34,improve:11,inbound:3,incomplet:28,index:[15,19,25,41,63],indexabl:66,indic:15,indirect:26,inferenc:7,info:2,inform:[29,55],initi:[25,47,62],initial:[9,25,28,50],initialis:18,inline:32,inner:28,input:[26,59],insert:6,insid:34,inspect:6,install:50,installat:50,instanc:57,integ:34,integer:[39,76],integrat:75,inter:34,interact:40,interfac:[11,18,41,57,65,77],intern:21,internal:[10,64],interpol:[45,52,54,56],introduct:[21,42,64],introspect:16,invoc:45,issu:8,italic:32,iter:15,iterabl:66,iterat:[25,41,66],itself:50,jit:7,jl_atexit_hook:9,jl_std:18,jl_value_t:14,jltype:21,julia:[0,1,2,4,6,7,8,9,10,11,14,18,20,22,23,24,26,33,34,38,40,57,70,85],julia_init:9,julia_sav:9,julian:40,just:57,kei:40,kernel:52,keybind:40,keyword:[8,35,46,52],lambdainfo:1,languag:49,lapack:74,layout:14,legaci:18,length:15,let:61,level:[33,47,57,74],librari:[18,23,70,72],libuv:18,like:[46,66],line:33,linear:[15,19,43,74],linearindic:15,link:32,linker:73,list:32,liter:[32,39,45,56,57],llvm:[11,65],load:[6,51],local:61,localmanag:51,locat:52,lock:12,log:44,loop:[15,29,51,61],low:74,lower:1,machin:[34,39],machineri:21,macro:[1,5,7,32,45,51,57,85],main:9,mainten:12,make:50,makefil:33,manag:[33,51,77,78],mani:34,manipul:33,manual:[23,38,50],map:[26,51,71],mark:14,markdown:32,mathemat:[44,63,75],matlab:49,matric:[25,43,63],matrix:[25,43,74],mean:34,measur:52,mechan:13,memori:[14,17,26,33,34,52,53,71],messag:29,meta:13,metadata:50,metaprogram:45,method:[6,8,21,25,28,32,46,57],miscellanea:47,miss:[34,58],mix:34,mode:[39,40],modifi:[26,34,57],modul:[32,34,47],more:[7,21,26,52],movement:51,mozilla:6,msan:17,multi:[12,25,51,77],multidimension:33,multimedia:71,multipl:[32,35,52],name:[35,50,57,60],namespac:47,nativ:[4,34],network:[48,51,52,71],nightli:34,non:[15,26,45,56],note:46,noteworthi:49,nothing:34,nullabl:[58,64],number:[1,5,27,39,52,56,76],numer:[39,44,57,75,76],object:[14,32,34,46,58,64],offline:50,onli:28,oper:[25,29,34,43,44,57,63,74],operat:[1,25,35,37,44,56,58,75],optim:11,optimiz:52,option:[11,53],optional:[35,46],order:[52,82],other:[49,85],outer:28,output:[34,48,52],outsid:34,overflow:39,overli:57,overload:57,overus:57,overview:11,ownership:26,packag:[34,50,51,78],pai:52,paragraph:32,parallel:[51,52,77],paramet:[19,33,52,57],parametr:[28,46,58],parenthes:57,pars:7,particular:6,pass:[11,26,34,35],path:47,perform:52,period:[31,68],pin:50,pipelin:54,point:39,pointer:26,possibl:57,post:50,power:44,pre:52,preced:44,precis:39,precompil:[6,47],pretti:58,primit:77,principl:5,print:58,printf:18,priorityqueu:66,process:[6,75],profil:[53,79],program:[45,54],promot:30,prompt:40,propag:3,proper:12,properti:48,ptr:26,publish:50,punctuat:80,python:49,queri:[31,68],question:34,quot:[32,45,54,56],random:76,ration:[27,28,30],read:35,rebas:50,record:6,ref:26,refer:[5,26,32,39,51],reflect:[16,64],regular:56,rel:47,relat:82,releas:34,remot:51,remov:[34,50],repeat:29,repl:[34,62],replac:19,replai:6,report:2,repositori:50,repres:58,represent:45,requir:[50,51],require:50,reshap:15,resolv:48,resourc:36,result:[34,53],root:44,round:[31,39,44,68],rule:[30,32],run:[2,22,54],runtim:[9,18],safe:58,safeti:26,same:34,sanit:17,scale:43,schedul:51,scope:[35,61],script:[2,57],search:40,seemingli:34,segfault:2,sensibl:34,separ:52,session:34,set:[21,66,85],setup:[50,51],share:[12,51,77],shell:40,sign:44,signal:[6,75],simd:[26,81],similar:15,simpl:48,simplifi:62,singleton:[14,58],size:15,slurp:34,soft:61,some:26,someth:57,sort:[21,82],spars:[25,63],speak:50,special:[15,26,35,39,43,44],specif:[26,50,57],specifi:51,splat:34,split:34,squash:50,sshmanag:51,stabl:[34,52],stack:55,stacktrac:83,standard:[23,45,47,56,70,72,74,76],start:36,startup:2,state:29,statement:29,statist:75,statu:50,stdio:18,still:34,storag:[15,25],strang:57,stream:[34,48],string:[1,45,52,56,84],struct:26,structur:[12,66],studi:[28,30],style:57,stylist:60,subarrai:19,subnorm:52,subtyp:21,suit:22,summari:[15,47,50],suppli:5,support:[17,77,81],suppress:22,surfac:1,symbol:45,synchron:[34,51,77],syntax:[1,5,26,32,35,39,64],sysimg:[2,9],system:[7,20,37,64],tab:40,tabl:[8,32],tag:50,taken:52,talk:13,task:[29,77],tcp:48,test:[22,85],text:[48,71],those:6,thread:[12,26,51,77],threadcal:51,threadpool:77,through:26,time:[52,68],timetyp:31,tip:[6,52,62],tool:52,top:47,toplevel:32,topolog:51,trace:55,trait:25,translat:[19,26],transport:51,treat:52,trigonometr:44,tripl:56,true_main:9,tupl:[21,58],tweak:52,two:34,type:[1,7,14,15,19,21,25,26,31,32,33,34,52,57,58,64,68,76,85],typenam:21,typevar:21,unchang:34,under:22,unicod:[56,59],uniform:43,union:[21,57,58],unit:85,unnecessari:57,unregist:50,unsaf:57,untyp:52,update:[44,50],upon:6,usag:[5,47,53],usage:32,use:[33,57],useful:6,using:[15,22,33],utf:56,valgrind:22,valu:[26,34,35,39,44,52,58],vararg:[35,46,58],variabl:[6,26,32,34,52,60,61],variat:37,vector:[25,35,63],version:[2,11,34,56],view:55,want:34,warn:[29,52],what:34,when:[2,26,34,57],whether:57,why:[34,45],work:[11,33,34,48,85],workflow:62,wrapper:[18,26],write:[15,34,52,57],your:50,zero:[39,52]}})",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/genindex.html": "\n\n\n<!DOCTYPE html>\n<!--[if IE 8]><html class=\"no-js lt-ie9\" lang=\"en\" > <![endif]-->\n<!--[if gt IE 8]><!--> <html class=\"no-js\" lang=\"en\" > <!--<![endif]-->\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  \n  <title>Index &mdash; Julia Language 0.5.1 documentation</title>\n  \n\n  \n  \n\n  \n  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>\n\n  \n  \n    \n\n  \n\n  \n  \n    <link rel=\"stylesheet\" href=\"_static/julia.css\" type=\"text/css\" />\n  \n\n  \n    <link rel=\"stylesheet\" href=\"_static/julia.css\" type=\"text/css\" />\n  \n    <link rel=\"top\" title=\"Julia Language 0.5.1 documentation\" href=\"index.html\"/> \n\n  \n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js\"></script>\n\n</head>\n\n<body class=\"wy-body-for-nav\" role=\"document\">\n\n  <div class=\"wy-grid-for-nav\">\n\n    \n    <nav data-toggle=\"wy-nav-shift\" class=\"wy-nav-side\">\n      <div class=\"wy-side-nav-search\">\n        <a href=\"http://julialang.org/\"><img src=\"_static/julia-logo.svg\" class=\"logo\"></a>\n        <!--\n        <a href=\"index.html\" class=\"fa fa-home\"> Julia Language</a>\n        -->\n        <div role=\"search\">\n  <form id =\"rtd-search-form\" class=\"wy-form\" action=\"search.html\" method=\"get\">\n    <input type=\"text\" name=\"q\" placeholder=\"Search docs\" />\n    <input type=\"hidden\" name=\"check_keywords\" value=\"yes\" />\n    <input type=\"hidden\" name=\"area\" value=\"default\" />\n  </form>\n</div>\n      </div>\n\n      <div class=\"wy-menu wy-menu-vertical\" data-spy=\"affix\" role=\"navigation\" aria-label=\"main navigation\">\n        \n        \n            <ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/introduction.html\">Introduction</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/getting-started.html\">Getting Started</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/getting-started.html#resources\">Resources</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/variables.html\">Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/variables.html#allowed-variable-names\">Allowed Variable Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/variables.html#stylistic-conventions\">Stylistic Conventions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/integers-and-floating-point-numbers.html\">Integers and Floating-Point Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/integers-and-floating-point-numbers.html#integers\">Integers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/integers-and-floating-point-numbers.html#floating-point-numbers\">Floating-Point Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/integers-and-floating-point-numbers.html#arbitrary-precision-arithmetic\">Arbitrary Precision Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/integers-and-floating-point-numbers.html#numeric-literal-coefficients\">Numeric Literal Coefficients</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/integers-and-floating-point-numbers.html#literal-zero-and-one\">Literal zero and one</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/mathematical-operations.html\">Mathematical Operations and Elementary Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/mathematical-operations.html#arithmetic-operators\">Arithmetic Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/mathematical-operations.html#bitwise-operators\">Bitwise Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/mathematical-operations.html#updating-operators\">Updating operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/mathematical-operations.html#numeric-comparisons\">Numeric Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/mathematical-operations.html#numerical-conversions\">Numerical Conversions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/complex-and-rational-numbers.html\">Complex and Rational Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/complex-and-rational-numbers.html#complex-numbers\">Complex Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/complex-and-rational-numbers.html#rational-numbers\">Rational Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/strings.html\">Strings</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#characters\">Characters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#string-basics\">String Basics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#unicode-and-utf-8\">Unicode and UTF-8</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#triple-quoted-string-literals\">Triple-Quoted String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#common-operations\">Common Operations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#regular-expressions\">Regular Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#id2\">Byte Array Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#version-number-literals\">Version Number Literals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/functions.html\">Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#argument-passing-behavior\">Argument Passing Behavior</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#the-return-keyword\">The <code class=\"docutils literal\"><span class=\"pre\">return</span></code> Keyword</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#operators-are-functions\">Operators Are Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#operators-with-special-names\">Operators With Special Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#anonymous-functions\">Anonymous Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#multiple-return-values\">Multiple Return Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#varargs-functions\">Varargs Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#optional-arguments\">Optional Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#keyword-arguments\">Keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#evaluation-scope-of-default-values\">Evaluation Scope of Default Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#do-block-syntax-for-function-arguments\">Do-Block Syntax for Function Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#dot-syntax-for-vectorizing-functions\">Dot Syntax for Vectorizing Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#further-reading\">Further Reading</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/control-flow.html\">Control Flow</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/control-flow.html#compound-expressions\">Compound Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/control-flow.html#conditional-evaluation\">Conditional Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/control-flow.html#short-circuit-evaluation\">Short-Circuit Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/control-flow.html#repeated-evaluation-loops\">Repeated Evaluation: Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/control-flow.html#exception-handling\">Exception Handling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/control-flow.html#tasks-aka-coroutines\">Tasks (aka Coroutines)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/variables-and-scoping.html\">Scope of Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/variables-and-scoping.html#global-scope\">Global Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/variables-and-scoping.html#local-scope\">Local Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/variables-and-scoping.html#constants\">Constants</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/types.html\">Types</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#type-declarations\">Type Declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#abstract-types\">Abstract Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#bits-types\">Bits Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#composite-types\">Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#immutable-composite-types\">Immutable Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#declared-types\">Declared Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#type-unions\">Type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#man-parametric-types\">Parametric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#type-aliases\">Type Aliases</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#operations-on-types\">Operations on Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#custom-pretty-printing\">Custom pretty-printing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#value-types\">&#8220;Value types&#8221;</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#nullable-types-representing-missing-values\">Nullable Types: Representing Missing Values</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/methods.html\">Methods</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/methods.html#defining-methods\">Defining Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/methods.html#method-ambiguities\">Method Ambiguities</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/methods.html#parametric-methods\">Parametric Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/methods.html#parametrically-constrained-varargs-methods\">Parametrically-constrained Varargs methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/methods.html#note-on-optional-and-keyword-arguments\">Note on Optional and keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/methods.html#function-like-objects\">Function-like objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/methods.html#empty-generic-functions\">Empty generic functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/constructors.html\">Constructors</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#outer-constructor-methods\">Outer Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#inner-constructor-methods\">Inner Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#incomplete-initialization\">Incomplete Initialization</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#parametric-constructors\">Parametric Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#case-study-rational\">Case Study: Rational</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#constructors-and-conversion\">Constructors and Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#outer-only-constructors\">Outer-only constructors</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/conversion-and-promotion.html\">Conversion and Promotion</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/conversion-and-promotion.html#conversion\">Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/conversion-and-promotion.html#promotion\">Promotion</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/interfaces.html\">Interfaces</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/interfaces.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/interfaces.html#indexing\">Indexing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/interfaces.html#abstract-arrays\">Abstract Arrays</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/modules.html\">Modules</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/modules.html#summary-of-module-usage\">Summary of module usage</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/documentation.html\">Documentation</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/documentation.html#accessing-documentation\">Accessing Documentation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/documentation.html#functions-methods\">Functions &amp; Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/documentation.html#advanced-usage\">Advanced Usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/documentation.html#syntax-guide\">Syntax Guide</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/documentation.html#markdown-syntax\">Markdown syntax</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/documentation.html#markdown-syntax-extensions\">Markdown Syntax Extensions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/metaprogramming.html\">Metaprogramming</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/metaprogramming.html#program-representation\">Program representation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/metaprogramming.html#expressions-and-evaluation\">Expressions and evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/metaprogramming.html#macros\">Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/metaprogramming.html#code-generation\">Code Generation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/metaprogramming.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/metaprogramming.html#generated-functions\">Generated functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/arrays.html\">Multi-dimensional Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/arrays.html#arrays\">Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/arrays.html#sparse-matrices\">Sparse Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/linear-algebra.html\">Linear algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/linear-algebra.html#matrix-factorizations\">Matrix factorizations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/linear-algebra.html#special-matrices\">Special matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/networking-and-streams.html\">Networking and Streams</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/networking-and-streams.html#basic-stream-i-o\">Basic Stream I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/networking-and-streams.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/networking-and-streams.html#io-output-contextual-properties\">IO Output Contextual Properties</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/networking-and-streams.html#working-with-files\">Working with Files</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/networking-and-streams.html#a-simple-tcp-example\">A simple TCP example</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/networking-and-streams.html#resolving-ip-addresses\">Resolving IP Addresses</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/parallel-computing.html\">Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#code-availability-and-loading-packages\">Code Availability and Loading Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#data-movement\">Data Movement</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#parallel-map-and-loops\">Parallel Map and Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#synchronization-with-remote-references\">Synchronization With Remote References</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#scheduling\">Scheduling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#channels\">Channels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#remote-references-and-abstractchannels\">Remote references and AbstractChannels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#remote-references-and-distributed-garbage-collection\">Remote References and Distributed Garbage Collection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#id2\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#shared-arrays-and-distributed-garbage-collection\">Shared Arrays and Distributed Garbage Collection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#clustermanagers\">ClusterManagers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#cluster-managers-with-custom-transports\">Cluster Managers with custom transports</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#network-requirements-for-localmanager-and-sshmanager\">Network requirements for LocalManager and SSHManager</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#cluster-cookie\">Cluster cookie</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#specifying-network-topology-experimental\">Specifying network topology (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#multi-threading-experimental\">Multi-threading (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#threadcall-experimental\">&#64;threadcall (Experimental)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/dates.html\">Date and DateTime</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#durations-comparisons\">Durations/Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#accessor-functions\">Accessor Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#query-functions\">Query Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#timetype-period-arithmetic\">TimeType-Period Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#adjuster-functions\">Adjuster Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#period-types\">Period Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#rounding\">Rounding</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/running-external-programs.html\">Running External Programs</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/running-external-programs.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/running-external-programs.html#quoting\">Quoting</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/running-external-programs.html#pipelines\">Pipelines</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html\">Calling C and Fortran Code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#creating-c-compatible-julia-function-pointers\">Creating C-Compatible Julia Function Pointers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#mapping-c-types-to-julia\">Mapping C Types to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#mapping-c-functions-to-julia\">Mapping C Functions to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#some-examples-of-c-wrappers\">Some Examples of C Wrappers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#garbage-collection-safety\">Garbage Collection Safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#non-constant-function-specifications\">Non-constant Function Specifications</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#indirect-calls\">Indirect Calls</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#calling-convention\">Calling Convention</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#accessing-global-variables\">Accessing Global Variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#accessing-data-through-a-pointer\">Accessing Data through a Pointer</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#thread-safety\">Thread-safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#more-about-callbacks\">More About Callbacks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#c\">C++</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/handling-operating-system-variation.html\">Handling Operating System Variation</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/interacting-with-julia.html\">Interacting With Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/interacting-with-julia.html#the-different-prompt-modes\">The different prompt modes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/interacting-with-julia.html#key-bindings\">Key bindings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/interacting-with-julia.html#tab-completion\">Tab completion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/interacting-with-julia.html#customizing-colors\">Customizing Colors</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/embedding.html\">Embedding Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/embedding.html#high-level-embedding\">High-Level Embedding</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/embedding.html#converting-types\">Converting Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/embedding.html#calling-julia-functions\">Calling Julia Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/embedding.html#memory-management\">Memory Management</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/embedding.html#working-with-arrays\">Working with Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/embedding.html#exceptions\">Exceptions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/packages.html\">Packages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#package-status\">Package Status</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#adding-and-removing-packages\">Adding and Removing Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#offline-installation-of-packages\">Offline Installation of Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#installing-unregistered-packages\">Installing Unregistered Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#updating-packages\">Updating Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#checkout-pin-and-free\">Checkout, Pin and Free</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#custom-metadata-repository\">Custom METADATA Repository</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/packages.html#package-development\">Package Development</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#initial-setup\">Initial Setup</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#making-changes-to-an-existing-package\">Making changes to an existing package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#creating-a-new-package\">Creating a new Package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#fixing-package-requirements\">Fixing Package Requirements</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#man-package-requirements\">Requirements Specification</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/profile.html\">Profiling</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/profile.html#basic-usage\">Basic usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/profile.html#accumulation-and-clearing\">Accumulation and clearing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/profile.html#options-for-controlling-the-display-of-profile-results\">Options for controlling the display of profile results</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/profile.html#configuration\">Configuration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/profile.html#memory-allocation-analysis\">Memory allocation analysis</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/stacktraces.html\">Stack Traces</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/stacktraces.html#viewing-a-stack-trace\">Viewing a stack trace</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/stacktraces.html#extracting-useful-information\">Extracting useful information</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/stacktraces.html#error-handling\">Error handling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/stacktraces.html#comparison-with-backtrace\">Comparison with <code class=\"docutils literal\"><span class=\"pre\">backtrace()</span></code></a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/performance-tips.html\">Performance Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#avoid-global-variables\">Avoid global variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#measure-performance-with-time-and-pay-attention-to-memory-allocation\">Measure performance with <code class=\"docutils literal\"><span class=\"pre\">&#64;time</span></code> and pay attention to memory allocation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#tools\">Tools</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#avoid-containers-with-abstract-type-parameters\">Avoid containers with abstract type parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#type-declarations\">Type declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#break-functions-into-multiple-definitions\">Break functions into multiple definitions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#write-type-stable-functions\">Write &#8220;type-stable&#8221; functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#avoid-changing-the-type-of-a-variable\">Avoid changing the type of a variable</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#separate-kernel-functions-aka-function-barriers\">Separate kernel functions (aka, function barriers)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#types-with-values-as-parameters\">Types with values-as-parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#the-dangers-of-abusing-multiple-dispatch-aka-more-on-types-with-values-as-parameters\">The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#access-arrays-in-memory-order-along-columns\">Access arrays in memory order, along columns</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#pre-allocating-outputs\">Pre-allocating outputs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#avoid-string-interpolation-for-i-o\">Avoid string interpolation for I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#optimize-network-i-o-during-parallel-execution\">Optimize network I/O during parallel execution</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#fix-deprecation-warnings\">Fix deprecation warnings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#tweaks\">Tweaks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#performance-annotations\">Performance Annotations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#treat-subnormal-numbers-as-zeros\">Treat Subnormal Numbers as Zeros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#code-warntype\"><code class=\"docutils literal\"><span class=\"pre\">&#64;code_warntype</span></code></a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/workflow-tips.html\">Workflow Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/workflow-tips.html#repl-based-workflow\">REPL-based workflow</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/workflow-tips.html#browser-based-workflow\">Browser-based workflow</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/style-guide.html\">Style Guide</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#write-functions-not-just-scripts\">Write functions, not just scripts</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#avoid-writing-overly-specific-types\">Avoid writing overly-specific types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#handle-excess-argument-diversity-in-the-caller\">Handle excess argument diversity in the caller</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#append-to-names-of-functions-that-modify-their-arguments\">Append <code class=\"docutils literal\"><span class=\"pre\">!</span></code> to names of functions that modify their arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#avoid-strange-type-unions\">Avoid strange type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#avoid-type-unions-in-fields\">Avoid type Unions in fields</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#avoid-elaborate-container-types\">Avoid elaborate container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#use-naming-conventions-consistent-with-julia-s-base\">Use naming conventions consistent with Julia&#8217;s <code class=\"docutils literal\"><span class=\"pre\">base/</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-overuse-try-catch\">Don&#8217;t overuse try-catch</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-parenthesize-conditions\">Don&#8217;t parenthesize conditions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-overuse\">Don&#8217;t overuse ...</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-use-unnecessary-static-parameters\">Don&#8217;t use unnecessary static parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#avoid-confusion-about-whether-something-is-an-instance-or-a-type\">Avoid confusion about whether something is an instance or a type</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-overuse-macros\">Don&#8217;t overuse macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-expose-unsafe-operations-at-the-interface-level\">Don&#8217;t expose unsafe operations at the interface level</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-overload-methods-of-base-container-types\">Don&#8217;t overload methods of base container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#be-careful-with-type-equality\">Be careful with type equality</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#do-not-write-x-f-x\">Do not write <code class=\"docutils literal\"><span class=\"pre\">x-&gt;f(x)</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible\">Avoid using floats for numeric literals in generic code when possible</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/faq.html\">Frequently Asked Questions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#sessions-and-the-repl\">Sessions and the REPL</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#functions\">Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#types-type-declarations-and-constructors\">Types, type declarations, and constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#packages-and-modules\">Packages and Modules</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#nothingness-and-missing-values\">Nothingness and missing values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#memory\">Memory</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#asynchronous-io-and-concurrent-synchronous-writes\">Asynchronous IO and concurrent synchronous writes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#julia-releases\">Julia Releases</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/noteworthy-differences.html\">Noteworthy Differences from other Languages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/noteworthy-differences.html#noteworthy-differences-from-matlab\">Noteworthy differences from MATLAB</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/noteworthy-differences.html#noteworthy-differences-from-r\">Noteworthy differences from R</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/noteworthy-differences.html#noteworthy-differences-from-python\">Noteworthy differences from Python</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/noteworthy-differences.html#noteworthy-differences-from-c-c\">Noteworthy differences from C/C++</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/unicode-input.html\">Unicode Input</a></li>\n</ul>\n<ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/base.html\">Essentials</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#introduction\">Introduction</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#getting-around\">Getting Around</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#all-objects\">All Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#types\">Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#generic-functions\">Generic Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#syntax\">Syntax</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#nullables\">Nullables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#system\">System</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#errors\">Errors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#events\">Events</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#reflection\">Reflection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#internals\">Internals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/collections.html\">Collections and Data Structures</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#general-collections\">General Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#iterable-collections\">Iterable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#indexable-collections\">Indexable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#associative-collections\">Associative Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#set-like-collections\">Set-Like Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#dequeues\">Dequeues</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#priorityqueue\">PriorityQueue</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#heap-functions\">Heap Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/math.html\">Mathematics</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/math.html#mathematical-operators\">Mathematical Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/math.html#mathematical-functions\">Mathematical Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/math.html#statistics\">Statistics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/math.html#signal-processing\">Signal Processing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/math.html#numerical-integration\">Numerical Integration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/numbers.html\">Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/numbers.html#standard-numeric-types\">Standard Numeric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/numbers.html#data-formats\">Data Formats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/numbers.html#general-number-functions-and-constants\">General Number Functions and Constants</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/numbers.html#bigfloats\">BigFloats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/numbers.html#random-numbers\">Random Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/strings.html\">Strings</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/arrays.html\">Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#basic-functions\">Basic functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#mathematical-operators-and-functions\">Mathematical operators and functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#indexing-assignment-and-concatenation\">Indexing, Assignment, and Concatenation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#array-functions\">Array functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#combinatorics\">Combinatorics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#bitarrays\">BitArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#sparse-vectors-and-matrices\">Sparse Vectors and Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/parallel.html\">Tasks and Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/parallel.html#tasks\">Tasks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/parallel.html#general-parallel-computing-support\">General Parallel Computing Support</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/parallel.html#shared-arrays\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/parallel.html#multi-threading\">Multi-Threading</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/parallel.html#ccall-using-a-threadpool-experimental\">ccall using a threadpool (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/parallel.html#synchronization-primitives\">Synchronization Primitives</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/parallel.html#cluster-manager-interface\">Cluster Manager Interface</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/linalg.html\">Linear Algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/linalg.html#module-Base.LinAlg\">Standard Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/linalg.html#low-level-matrix-operations\">Low-level matrix operations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/linalg.html#module-Base.LinAlg.BLAS\">BLAS Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/linalg.html#module-Base.LinAlg.LAPACK\">LAPACK Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/constants.html\">Constants</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/file.html\">Filesystem</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/io-network.html\">I/O and Network</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/io-network.html#general-i-o\">General I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/io-network.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/io-network.html#multimedia-i-o\">Multimedia I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/io-network.html#memory-mapped-i-o\">Memory-mapped I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/io-network.html#network-i-o\">Network I/O</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/punctuation.html\">Punctuation</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/sort.html\">Sorting and Related Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/sort.html#sorting-functions\">Sorting Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/sort.html#order-related-functions\">Order-Related Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/sort.html#sorting-algorithms\">Sorting Algorithms</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/pkg.html\">Package Manager Functions</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/dates.html\">Dates and Time</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/dates.html#dates-and-time-types\">Dates and Time Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/dates.html#dates-functions\">Dates Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/test.html\">Unit Testing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/test.html#testing-base-julia\">Testing Base Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/test.html#basic-unit-tests\">Basic Unit Tests</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/test.html#working-with-test-sets\">Working with Test Sets</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/test.html#other-test-macros\">Other Test Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/test.html#broken-tests\">Broken Tests</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/test.html#creating-custom-abstracttestset-types\">Creating Custom <code class=\"docutils literal\"><span class=\"pre\">AbstractTestSet</span></code> Types</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/c.html\">C Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/c.html#llvm-interface\">LLVM Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/libc.html\">C Standard Library</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/libdl.html\">Dynamic Linker</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/profile.html\">Profiling</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/stacktraces.html\">StackTraces</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/simd-types.html\">SIMD Support</a></li>\n</ul>\n<ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"devdocs/reflection.html\">Reflection and introspection</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"devdocs/julia.html\">Documentation of Julia&#8217;s Internals</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/init.html\">Initialization of the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/eval.html\">Eval of Julia code</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/ast.html\">Julia ASTs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/types.html\">More about types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/object.html\">Memory layout of Julia Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/functions.html\">Julia Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/callconv.html\">Calling Conventions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/cartesian.html\">Base.Cartesian</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/meta.html\">Talking to the compiler (the <code class=\"docutils literal\"><span class=\"pre\">:meta</span></code> mechanism)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/subarrays.html\">SubArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/sysimg.html\">System Image Building</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/llvm.html\">Working with LLVM</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/stdio.html\">printf() and stdio in the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/boundscheck.html\">Bounds checking</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/locks.html\">Proper maintenance and care of multi-threading locks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/offset-arrays.html\">Arrays with custom indices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"devdocs/C.html\">Developing/debugging Julia&#8217;s C code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/backtraces.html\">Reporting and analyzing crashes (segfaults)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/debuggingtips.html\">gdb debugging tips</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/valgrind.html\">Using Valgrind with Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/sanitizers.html\">Sanitizer support</a></li>\n</ul>\n</li>\n</ul>\n\n        \n      </div>\n      &nbsp;\n    </nav>\n\n    <section data-toggle=\"wy-nav-shift\" class=\"wy-nav-content-wrap\">\n\n      \n      <nav class=\"wy-nav-top\" role=\"navigation\" aria-label=\"top navigation\">\n        <i data-toggle=\"wy-nav-top\" class=\"fa fa-bars\"></i>\n        <a href=\"index.html\">Julia Language</a>\n      </nav>\n\n\n      \n      <div class=\"wy-nav-content\">\n        <div class=\"rst-content\">\n          <div role=\"navigation\" aria-label=\"breadcrumbs navigation\">\n  <ul class=\"wy-breadcrumbs\">\n    <li><a href=\"index.html\">Docs</a> &raquo;</li>\n      \n    <li>Index</li>\n      <li class=\"wy-breadcrumbs-aside\">\n        \n      </li>\n  </ul>\n  <hr/>\n</div>\n          <div role=\"main\" class=\"document\">\n            \n\n<h1 id=\"index\">Index</h1>\n\n<div class=\"genindex-jumpbox\">\n <a href=\"#Symbols\"><strong>Symbols</strong></a>\n | <a href=\"#_\"><strong>_</strong></a>\n | <a href=\"#A\"><strong>A</strong></a>\n | <a href=\"#B\"><strong>B</strong></a>\n | <a href=\"#C\"><strong>C</strong></a>\n | <a href=\"#D\"><strong>D</strong></a>\n | <a href=\"#E\"><strong>E</strong></a>\n | <a href=\"#F\"><strong>F</strong></a>\n | <a href=\"#G\"><strong>G</strong></a>\n | <a href=\"#H\"><strong>H</strong></a>\n | <a href=\"#I\"><strong>I</strong></a>\n | <a href=\"#J\"><strong>J</strong></a>\n | <a href=\"#K\"><strong>K</strong></a>\n | <a href=\"#L\"><strong>L</strong></a>\n | <a href=\"#M\"><strong>M</strong></a>\n | <a href=\"#N\"><strong>N</strong></a>\n | <a href=\"#O\"><strong>O</strong></a>\n | <a href=\"#P\"><strong>P</strong></a>\n | <a href=\"#Q\"><strong>Q</strong></a>\n | <a href=\"#R\"><strong>R</strong></a>\n | <a href=\"#S\"><strong>S</strong></a>\n | <a href=\"#T\"><strong>T</strong></a>\n | <a href=\"#U\"><strong>U</strong></a>\n | <a href=\"#V\"><strong>V</strong></a>\n | <a href=\"#W\"><strong>W</strong></a>\n | <a href=\"#X\"><strong>X</strong></a>\n | <a href=\"#Y\"><strong>Y</strong></a>\n | <a href=\"#Z\"><strong>Z</strong></a>\n | <a href=\"#Symbols\"><strong>Symbols</strong></a>\n \n</div>\n<h2 id=\"Symbols\">Symbols</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.!\">!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.!=\">!=() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.!==\">!==() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.$\">$() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.%\">%() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.&\">&amp;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.*\">*() (in module Base)</a>, <a href=\"stdlib/math.html#Base.*\">[1]</a>, <a href=\"stdlib/strings.html#Base.*\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.+\">+() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.-\">-() (in module Base)</a>, <a href=\"stdlib/math.html#Base.-\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..!=\">.!=() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..*\">.*() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..+\">.+() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..-\">.-() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base../\">./() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..<\">.&lt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..<=\">.&lt;=() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..==\">.==() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..\u2260\">.\u2260() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..>\">.&gt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..>=\">.&gt;=() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..\\\">.\\() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..^\">.^() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..\u2264\">.\u2264() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..\u2265\">.\u2265() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base./\">/() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.//\">//() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.:\">:() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.<\">&lt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.<:\">&lt;:() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.<<\">&lt;&lt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.<=\">&lt;=() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.==\">==() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.===\">===() (in module Base)</a>, <a href=\"stdlib/math.html#Base.===\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.\u2260\">\u2260() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.>\">&gt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.>=\">&gt;=() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.>>\">&gt;&gt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.>>>\">&gt;&gt;&gt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/documentation.html#@__doc__\">@__doc__() (built-in function)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.@__FILE__\">@__FILE__() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.@__LINE__\">@__LINE__() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@allocated\">@allocated() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@async\">@async() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@code_llvm\">@code_llvm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@code_lowered\">@code_lowered() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@code_native\">@code_native() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@code_typed\">@code_typed() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@code_warntype\">@code_warntype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@edit\">@edit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@elapsed\">@elapsed() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@eval\">@eval() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.@evalpoly\">@evalpoly() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@fetch\">@fetch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@fetchfrom\">@fetchfrom() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@functionloc\">@functionloc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@gensym\">@gensym() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.@html_str\">@html_str() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@less\">@less() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@parallel\">@parallel() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.@printf\">@printf() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/profile.html#Base.@profile\">@profile() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.@r_str\">@r_str() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@schedule\">@schedule() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@show\">@show() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@spawn\">@spawn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@spawnat\">@spawnat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.@sprintf\">@sprintf() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@static\">@static() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@sync\">@sync() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@task\">@task() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#Base.Test.@test_approx_eq\">@test_approx_eq() (in module Base.Test)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#Base.Test.@test_approx_eq_eps\">@test_approx_eq_eps() (in module Base.Test)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.@text_str\">@text_str() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@threadcall\">@threadcall() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@time\">@time() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@timed\">@timed() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@timev\">@timev() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@which\">@which() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.\\\">\\() (in module Base)</a>, <a href=\"stdlib/math.html#Base.\\\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.^\">^() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.^\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.|\">|() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.|>\">|&gt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.~\">~() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"_\">_</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.__precompile__\">__precompile__() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"A\">A</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.A_ldiv_B!\">A_ldiv_B!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.A_ldiv_Bc\">A_ldiv_Bc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.A_ldiv_Bt\">A_ldiv_Bt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.A_mul_B!\">A_mul_B!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.A_mul_Bc\">A_mul_Bc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.A_mul_Bt\">A_mul_Bt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.A_rdiv_Bc\">A_rdiv_Bc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.A_rdiv_Bt\">A_rdiv_Bt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.abs\">abs() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.abs2\">abs2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.abspath\">abspath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.AbstractLock\">AbstractLock (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Ac_ldiv_B!\">Ac_ldiv_B!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Ac_ldiv_B\">Ac_ldiv_B() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Ac_ldiv_Bc\">Ac_ldiv_Bc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Ac_mul_B\">Ac_mul_B() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Ac_mul_Bc\">Ac_mul_Bc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Ac_rdiv_B\">Ac_rdiv_B() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Ac_rdiv_Bc\">Ac_rdiv_Bc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.accept\">accept() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acos\">acos() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acosd\">acosd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acosh\">acosh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acot\">acot() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acotd\">acotd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acoth\">acoth() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.acquire\">acquire() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acsc\">acsc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acscd\">acscd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acsch\">acsch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.add\">add() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.addprocs\">addprocs() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.addprocs\">[1]</a>, <a href=\"stdlib/parallel.html#Base.addprocs\">[2]</a>, <a href=\"stdlib/parallel.html#Base.addprocs\">[3]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airy\">airy() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airyai\">airyai() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airyaiprime\">airyaiprime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airybi\">airybi() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airybiprime\">airybiprime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airyprime\">airyprime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airyx\">airyx() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.all!\">all!() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/collections.html#Base.all\">all() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.all\">[1]</a>, <a href=\"stdlib/collections.html#Base.all\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.allunique\">allunique() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.angle\">angle() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ans\">ans (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.ANY\">ANY (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.any!\">any!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.any\">any() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.any\">[1]</a>, <a href=\"stdlib/collections.html#Base.any\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.append!\">append!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.applicable\">applicable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.apropos\">apropos() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.ARGS\">ARGS (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ArgumentError\">ArgumentError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.Array\">Array() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.ascii\">ascii() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.asec\">asec() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.asecd\">asecd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.asech\">asech() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.asin\">asin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.asind\">asind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.asinh\">asinh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.assert\">assert() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.AssertionError\">AssertionError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.asum\">asum() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.AsyncCondition\">AsyncCondition() (in module Base)</a>, <a href=\"stdlib/base.html#Base.AsyncCondition\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.asyncmap\">asyncmap() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.At_ldiv_B!\">At_ldiv_B!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.At_ldiv_B\">At_ldiv_B() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.At_ldiv_Bt\">At_ldiv_Bt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.At_mul_B\">At_mul_B() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.At_mul_Bt\">At_mul_Bt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.At_rdiv_B\">At_rdiv_B() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.At_rdiv_Bt\">At_rdiv_Bt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.atan\">atan() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.atan2\">atan2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.atand\">atand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.atanh\">atanh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.atexit\">atexit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.atreplinit\">atreplinit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.available\">available() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.available\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.axpy!\">axpy!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"B\">B</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.backtrace\">backtrace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/modules.html#index-0\">baremodule</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.base\">base() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"devdocs/cartesian.html#module-Base.Cartesian\">Base.Cartesian (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Base.channel_from_id\">Base.channel_from_id() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.checked_abs\">Base.checked_abs() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.checked_add\">Base.checked_add() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.checked_cld\">Base.checked_cld() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.checked_div\">Base.checked_div() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.checked_fld\">Base.checked_fld() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.checked_mod\">Base.checked_mod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.checked_mul\">Base.checked_mul() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.checked_neg\">Base.checked_neg() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.checked_rem\">Base.checked_rem() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.checked_sub\">Base.checked_sub() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Base.cluster_cookie\">Base.cluster_cookie() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.Base.cluster_cookie\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#module-Base.Collections\">Base.Collections (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Base.compilecache\">Base.compilecache() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Base.datatype_module\">Base.datatype_module() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Base.function_module\">Base.function_module() (in module Base)</a>, <a href=\"stdlib/base.html#Base.Base.function_module\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Base.function_name\">Base.function_name() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#module-Base.LinAlg\">Base.LinAlg (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#module-Base.LinAlg.BLAS\">Base.LinAlg.BLAS (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#module-Base.LinAlg.LAPACK\">Base.LinAlg.LAPACK (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.Base.linearindexing\">Base.linearindexing() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.OneTo\">Base.OneTo() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#module-Base.Pkg\">Base.Pkg (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Base.process_messages\">Base.process_messages() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Base.remoteref_id\">Base.remoteref_id() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Base.summarysize\">Base.summarysize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#module-Base.Test\">Base.Test (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Base.worker_id_from_socket\">Base.worker_id_from_socket() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.base64decode\">base64decode() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.Base64DecodePipe\">Base64DecodePipe() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.base64encode\">base64encode() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.Base64EncodePipe\">Base64EncodePipe() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.basename\">basename() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.bdsdc!\">bdsdc!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.bdsqr!\">bdsqr!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselh\">besselh() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.besselhx\">besselhx() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besseli\">besseli() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselix\">besselix() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselj\">besselj() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselj0\">besselj0() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselj1\">besselj1() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besseljx\">besseljx() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselk\">besselk() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselkx\">besselkx() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.bessely\">bessely() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.bessely0\">bessely0() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.bessely1\">bessely1() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselyx\">besselyx() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.beta\">beta() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.bfft!\">bfft!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.bfft\">bfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Bidiagonal\">Bidiagonal() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.Bidiagonal\">[1]</a>, <a href=\"stdlib/linalg.html#Base.Bidiagonal\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.big\">big() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.BigFloat\">BigFloat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.BigInt\">BigInt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.bin\">bin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.bind\">bind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.binomial\">binomial() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.bitbroadcast\">bitbroadcast() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.bitrand\">bitrand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.bits\">bits() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.bkfact!\">bkfact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.bkfact\">bkfact() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.blascopy!\">blascopy!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.blkdiag\">blkdiag() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.BoundsError\">BoundsError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.brfft\">brfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.broadcast!\">broadcast!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.broadcast\">broadcast() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.broadcast_getindex\">broadcast_getindex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.broadcast_setindex!\">broadcast_setindex!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.bswap\">bswap() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.build\">build() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.build\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"devdocs/sysimg.html#build_sysimg\">build_sysimg() (built-in function)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.bytes2hex\">bytes2hex() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"C\">C</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/constants.html#Base.C_NULL\">C_NULL (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.CachingPool\">CachingPool() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/profile.html#Base.Profile.callers\">callers() (in module Base.Profile)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.calloc\">calloc() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cat\">cat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.catalan\">catalan (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.catch_backtrace\">catch_backtrace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/stacktraces.html#Base.catch_stacktrace\">catch_stacktrace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cbrt\">cbrt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.ccall\">ccall() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cchar\">Cchar (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.cconvert\">cconvert() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.cd\">cd() (in module Base)</a>, <a href=\"stdlib/file.html#Base.cd\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cdouble\">Cdouble (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ceil\">ceil() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/dates.html#Dates.ceil\">(in module Dates)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/c.html#Base.Cfloat\">Cfloat (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.cfunction\">cfunction() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.cglobal\">cglobal() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Channel{T}\">Channel{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.charwidth\">charwidth() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.checkbounds\">checkbounds() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.checkbounds\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.checkindex\">checkindex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.checkout\">checkout() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.chmod\">chmod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.chol\">chol() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.chol\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.cholfact!\">cholfact!() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.cholfact!\">[1]</a>, <a href=\"stdlib/linalg.html#Base.cholfact!\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.cholfact\">cholfact() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.cholfact\">[1]</a>, <a href=\"stdlib/linalg.html#Base.cholfact\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.chomp\">chomp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.chop\">chop() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.chown\">chown() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.chr2ind\">chr2ind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cint\">Cint (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cintmax_t\">Cintmax_t (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.circshift\">circshift() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cis\">cis() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.clamp!\">clamp!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.clamp\">clamp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cld\">cld() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.clear!\">clear!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/profile.html#Base.Profile.clear\">clear() (in module Base.Profile)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/profile.html#Base.Profile.clear_malloc_data\">clear_malloc_data() (in module Base.Profile)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.clipboard\">clipboard() (in module Base)</a>, <a href=\"stdlib/base.html#Base.clipboard\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.clone\">clone() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.clone\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Clong\">Clong (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Clonglong\">Clonglong (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.close\">close() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.close\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cmp\">cmp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.code_llvm\">code_llvm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.code_lowered\">code_lowered() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.code_native\">code_native() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.code_typed\">code_typed() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.code_warntype\">code_warntype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.collect\">collect() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.collect\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.colon\">colon() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.complex\">complex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.CompoundPeriod\">CompoundPeriod() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.cond\">cond() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Condition\">Condition() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.condskeel\">condskeel() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.conj!\">conj!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.conj\">conj() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.connect\">connect() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.connect\">[1]</a>, <a href=\"stdlib/parallel.html#Base.connect\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.consume\">consume() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.contains\">contains() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.conv\">conv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.conv2\">conv2() (in module Base)</a>, <a href=\"stdlib/math.html#Base.conv2\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.convert\">convert() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.copy!\">copy!() (in module Base)</a>, <a href=\"stdlib/c.html#Base.copy!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.copy\">copy() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.copysign\">copysign() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cor\">cor() (in module Base)</a>, <a href=\"stdlib/math.html#Base.cor\">[1]</a>, <a href=\"stdlib/math.html#Base.cor\">[2]</a>, <a href=\"stdlib/math.html#Base.cor\">[3]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cos\">cos() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cosc\">cosc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cosd\">cosd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cosh\">cosh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cospi\">cospi() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cot\">cot() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cotd\">cotd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.coth\">coth() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.count\">count() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.count_ones\">count_ones() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.count_zeros\">count_zeros() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.countfrom\">countfrom() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.countlines\">countlines() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.countnz\">countnz() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cov\">cov() (in module Base)</a>, <a href=\"stdlib/math.html#Base.cov\">[1]</a>, <a href=\"stdlib/math.html#Base.cov\">[2]</a>, <a href=\"stdlib/math.html#Base.cov\">[3]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.cp\">cp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cptrdiff_t\">Cptrdiff_t (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.cross\">cross() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.csc\">csc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cscd\">cscd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.csch\">csch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cshort\">Cshort (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Csize_t\">Csize_t (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cssize_t\">Cssize_t (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.ctime\">ctime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ctranspose!\">ctranspose!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ctranspose\">ctranspose() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cuchar\">Cuchar (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cuint\">Cuint (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cuintmax_t\">Cuintmax_t (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Culong\">Culong (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Culonglong\">Culonglong (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cummax\">cummax() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cummin\">cummin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cumprod!\">cumprod!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cumprod\">cumprod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cumsum!\">cumsum!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cumsum\">cumsum() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cumsum_kbn\">cumsum_kbn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.current_module\">current_module() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.current_task\">current_task() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cushort\">Cushort (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cwchar_t\">Cwchar_t (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.cycle\">cycle() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"D\">D</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Date\">Date (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Date\">Date() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Date\">[1]</a>, <a href=\"stdlib/dates.html#Dates.Date\">[2]</a>, <a href=\"stdlib/dates.html#Dates.Date\">[3]</a>, <a href=\"stdlib/dates.html#Dates.Date\">[4]</a>, <a href=\"stdlib/dates.html#Dates.Date\">[5]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.date2epochdays\">date2epochdays() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.DateFormat\">DateFormat() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#module-Dates\">Dates (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.DateTime\">DateTime (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.DateTime\">DateTime() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.DateTime\">[1]</a>, <a href=\"stdlib/dates.html#Dates.DateTime\">[2]</a>, <a href=\"stdlib/dates.html#Dates.DateTime\">[3]</a>, <a href=\"stdlib/dates.html#Dates.DateTime\">[4]</a>, <a href=\"stdlib/dates.html#Dates.DateTime\">[5]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.datetime2epochms\">datetime2epochms() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.datetime2julian\">datetime2julian() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.datetime2rata\">datetime2rata() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.datetime2unix\">datetime2unix() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.dawson\">dawson() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Day\">Day (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Day\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Day\">Day() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.day\">day() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.dayabbr\">dayabbr() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.dayname\">dayname() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.dayofmonth\">dayofmonth() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.dayofquarter\">dayofquarter() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.dayofweek\">dayofweek() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.dayofweekofmonth\">dayofweekofmonth() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.dayofyear\">dayofyear() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.daysinmonth\">daysinmonth() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.daysinyear\">daysinyear() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.daysofweekinmonth\">daysofweekinmonth() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.dct!\">dct!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.dct\">dct() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.dec\">dec() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.deconv\">deconv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.deepcopy\">deepcopy() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.default\">default() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.default_worker_pool\">default_worker_pool() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.deg2rad\">deg2rad() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.delete!\">delete!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.deleteat!\">deleteat!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.deleteat!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.den\">den() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.dependents\">dependents() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.dequeue!\">dequeue!() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.deserialize\">deserialize() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.det\">det() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.detach\">detach() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.DevNull\">DevNull (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.diag\">diag() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.diagind\">diagind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.diagm\">diagm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Diagonal\">Diagonal() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.Diagonal\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Dict\">Dict() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.diff\">diff() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.digamma\">digamma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.digits!\">digits!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.digits\">digits() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.DimensionMismatch\">DimensionMismatch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.dir\">dir() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.dir\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.dirname\">dirname() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.disable_sigint\">disable_sigint() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.display\">display() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.displayable\">displayable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.displaysize\">displaysize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.div\">div() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.DivideError\">DivideError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.divrem\">divrem() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.DL_LOAD_PATH\">DL_LOAD_PATH (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.dlclose\">dlclose() (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.dlext\">dlext (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.dlopen\">dlopen() (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.dlopen_e\">dlopen_e() (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.dlsym\">dlsym() (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.dlsym_e\">dlsym_e() (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.DomainError\">DomainError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.done\">done() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.dot\">dot() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.dot\">(in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.dotc\">dotc() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.dotu\">dotu() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.download\">download() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.drop\">drop() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.dropzeros!\">dropzeros!() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.dropzeros!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.dropzeros\">dropzeros() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.dropzeros\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.dump\">dump() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"E\">E</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/numbers.html#Base.e\">e (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.eachindex\">eachindex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.eachline\">eachline() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.eachmatch\">eachmatch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.edit\">edit() (in module Base)</a>, <a href=\"stdlib/base.html#Base.edit\">[1]</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.edit\">(in module Base.Pkg)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eig\">eig() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.eig\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigfact!\">eigfact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigfact\">eigfact() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.eigfact\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigmax\">eigmax() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigmin\">eigmin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigs\">eigs() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.eigs\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigvals!\">eigvals!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigvals\">eigvals() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigvecs\">eigvecs() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.eltype\">eltype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.empty!\">empty!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.ENDIAN_BOM\">ENDIAN_BOM (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.endof\">endof() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.endswith\">endswith() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.enqueue!\">enqueue!() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.enumerate\">enumerate() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ENV\">ENV (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.EnvHash\">EnvHash() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.eof\">eof() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.EOFError\">EOFError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.epochdays2date\">epochdays2date() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.epochms2datetime\">epochms2datetime() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.eps\">eps() (in module Base)</a>, <a href=\"stdlib/base.html#Base.eps\">[1]</a>, <a href=\"stdlib/base.html#Base.eps\">[2]</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/dates.html#Dates.eps\">(in module Dates)</a>\n  </dt>\n\n      </dl></dd>\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.erf\">erf() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.erfc\">erfc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.erfcinv\">erfcinv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.erfcx\">erfcx() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.erfi\">erfi() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.erfinv\">erfinv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.errno\">errno() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.error\">error() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ErrorException\">ErrorException() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.esc\">esc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.escape_string\">escape_string() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.escape_string\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.eta\">eta() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.eu\">eu (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.eulergamma\">eulergamma (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.eval\">eval() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.evalfile\">evalfile() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.exit\">exit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.exp\">exp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.exp10\">exp10() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.exp2\">exp2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.expand\">expand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.expanduser\">expanduser() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.expm\">expm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.expm1\">expm1() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.exponent\">exponent() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/modules.html#index-0\">export</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.extrema\">extrema() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.extrema\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.eye\">eye() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.eye\">[1]</a>, <a href=\"stdlib/arrays.html#Base.eye\">[2]</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"F\">F</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.factorial\">factorial() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.factorize\">factorize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.falses\">falses() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.falses\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.fd\">fd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.fdio\">fdio() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.fetch\">fetch() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/profile.html#Base.Profile.fetch\">(in module Base.Profile)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/math.html#Base.fft!\">fft!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.fft\">fft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.fftshift\">fftshift() (in module Base)</a>, <a href=\"stdlib/math.html#Base.fftshift\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.fieldname\">fieldname() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.fieldnames\">fieldnames() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.fieldoffset\">fieldoffset() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.fieldtype\">fieldtype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.filemode\">filemode() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.filesize\">filesize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.fill!\">fill!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.fill\">fill() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.filt!\">filt!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.filt\">filt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.filter!\">filter!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.filter\">filter() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.finalize\">finalize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.finalizer\">finalizer() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.find\">find() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.find\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.find_library\">find_library() (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.findfirst\">findfirst() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.findfirst\">[1]</a>, <a href=\"stdlib/arrays.html#Base.findfirst\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.findin\">findin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.findlast\">findlast() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.findlast\">[1]</a>, <a href=\"stdlib/arrays.html#Base.findlast\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.findmax!\">findmax!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.findmax\">findmax() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.findmax\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.findmin!\">findmin!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.findmin\">findmin() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.findmin\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.findn\">findn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.findnext\">findnext() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.findnext\">[1]</a>, <a href=\"stdlib/arrays.html#Base.findnext\">[2]</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/arrays.html#Base.findnz\">findnz() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.findprev\">findprev() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.findprev\">[1]</a>, <a href=\"stdlib/arrays.html#Base.findprev\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#Base.Test.finish\">finish() (in module Base.Test)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.first\">first() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.firstdayofmonth\">firstdayofmonth() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.firstdayofquarter\">firstdayofquarter() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.firstdayofweek\">firstdayofweek() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.firstdayofyear\">firstdayofyear() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.fld\">fld() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.fld1\">fld1() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.fldmod\">fldmod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.fldmod1\">fldmod1() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.flipbits!\">flipbits!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.flipdim\">flipdim() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.flipsign\">flipsign() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.float\">float() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.Float32\">Float32() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.Float64\">Float64() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.floor\">floor() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/dates.html#Dates.floor\">(in module Dates)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/dates.html#Dates.floorceil\">floorceil() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.flush\">flush() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.flush_cstdio\">flush_cstdio() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.fma\">fma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.foldl\">foldl() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.foldl\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.foldr\">foldr() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.foldr\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.foreach\">foreach() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.format\">format() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.FormatMessage\">FormatMessage() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.free\">free() (in module Base.Libc)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.free\">(in module Base.Pkg)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/math.html#Base.frexp\">frexp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.full\">full() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.full\">[1]</a>, <a href=\"stdlib/linalg.html#Base.full\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.fullname\">fullname() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.functionloc\">functionloc() (in module Base)</a>, <a href=\"stdlib/base.html#Base.functionloc\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Future\">Future() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"G\">G</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.gamma\">gamma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gbmv!\">gbmv!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gbmv\">gbmv() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gbtrf!\">gbtrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gbtrs!\">gbtrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.gc\">gc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.gc_enable\">gc_enable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.gcd\">gcd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.gcdx\">gcdx() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gebak!\">gebak!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gebal!\">gebal!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gebrd!\">gebrd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gecon!\">gecon!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gees!\">gees!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geev!\">geev!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geevx!\">geevx!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gehrd!\">gehrd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gelqf!\">gelqf!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gelqf!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gels!\">gels!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gelsd!\">gelsd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gelsy!\">gelsy!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gemm!\">gemm!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gemm\">gemm() (in module Base.LinAlg.BLAS)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gemm\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gemqrt!\">gemqrt!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gemv!\">gemv!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gemv\">gemv() (in module Base.LinAlg.BLAS)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gemv\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.gensym\">gensym() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqlf!\">geqlf!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqlf!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqp3!\">geqp3!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqp3!\">[1]</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqp3!\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqrf!\">geqrf!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqrf!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqrt!\">geqrt!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqrt!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqrt3!\">geqrt3!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqrt3!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.ger!\">ger!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gerqf!\">gerqf!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gerqf!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gesdd!\">gesdd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gesv!\">gesv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gesvd!\">gesvd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gesvx!\">gesvx!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gesvx!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.get!\">get!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.get!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.get\">get() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.get\">[1]</a>, <a href=\"stdlib/collections.html#Base.get\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#Base.Test.get_testset\">get_testset() (in module Base.Test)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#Base.Test.get_testset_depth\">get_testset_depth() (in module Base.Test)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.get_zero_subnormals\">get_zero_subnormals() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.getaddrinfo\">getaddrinfo() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.getfield\">getfield() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.gethostname\">gethostname() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.getindex\">getindex() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.getindex\">[1]</a>, <a href=\"stdlib/collections.html#Base.getindex\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.getipaddr\">getipaddr() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.getkey\">getkey() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.GetLastError\">GetLastError() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.getpid\">getpid() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.getrf!\">getrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.getri!\">getri!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.getrs!\">getrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.getsockname\">getsockname() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gges!\">gges!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ggev!\">ggev!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gglse!\">gglse!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ggsvd!\">ggsvd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ggsvd3!\">ggsvd3!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.givens\">givens() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.givens\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.givens{T}\">givens{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.golden\">golden (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.gperm\">gperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.gradient\">gradient() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.graphemes\">graphemes() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gtsv!\">gtsv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gttrf!\">gttrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gttrs!\">gttrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"H\">H</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.hankelh1\">hankelh1() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.hankelh1x\">hankelh1x() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.hankelh2\">hankelh2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.hankelh2x\">hankelh2x() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.hash\">hash() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.haskey\">haskey() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.hcat\">hcat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.heapify!\">heapify!() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.heapify\">heapify() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.heappop!\">heappop!() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.heappush!\">heappush!() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.her!\">her!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.herk!\">herk!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.herk\">herk() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Hermitian\">Hermitian() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.hessfact!\">hessfact!() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.hessfact\">hessfact() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.hesv!\">hesv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.hetrf!\">hetrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.hetri!\">hetri!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.hetrs!\">hetrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.hex\">hex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.hex2bytes\">hex2bytes() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.hex2num\">hex2num() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.homedir\">homedir() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Hour\">Hour (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Hour\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Hour\">Hour() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.hour\">hour() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.htol\">htol() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.hton\">hton() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.hvcat\">hvcat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.hypot\">hypot() (in module Base)</a>, <a href=\"stdlib/math.html#Base.hypot\">[1]</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"I\">I</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.I\">I (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.idct!\">idct!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.idct\">idct() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.identity\">identity() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ifelse\">ifelse() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ifft!\">ifft!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ifft\">ifft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ifftshift\">ifftshift() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ignorestatus\">ignorestatus() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.im\">im (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.imag\">imag() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/modules.html#index-0\">import</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/modules.html#index-0\">importall</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.in\">in() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.include\">include() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.include_dependency\">include_dependency() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.include_string\">include_string() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.ind2chr\">ind2chr() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ind2sub\">ind2sub() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.ind2sub\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.indexin\">indexin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.indexpids\">indexpids() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.indices\">indices() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.indices\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.indmax\">indmax() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.indmin\">indmin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.InexactError\">InexactError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.Inf\">Inf (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.Inf16\">Inf16 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.Inf32\">Inf32 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.info\">info() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.init\">init() (in module Base.Pkg)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/profile.html#Base.Profile.init\">(in module Base.Profile)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/parallel.html#Base.init_worker\">init_worker() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.InitError\">InitError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.insert!\">insert!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.installed\">installed() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.installed\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.instances\">instances() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Instant\">Instant (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.interrupt\">interrupt() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.interrupt\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.InterruptException\">InterruptException() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.intersect!\">intersect!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.intersect\">intersect() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.IntSet\">IntSet() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.inv\">inv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.invdigamma\">invdigamma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.invmod\">invmod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.invoke\">invoke() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.invperm\">invperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.IOBuffer\">IOBuffer() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.IOBuffer\">[1]</a>, <a href=\"stdlib/io-network.html#Base.IOBuffer\">[2]</a>, <a href=\"stdlib/io-network.html#Base.IOBuffer\">[3]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.IOContext\">IOContext() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.IOContext\">[1]</a>, <a href=\"stdlib/io-network.html#Base.IOContext\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ipermute!\">ipermute!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ipermutedims\">ipermutedims() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.IPv4\">IPv4() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.IPv6\">IPv6() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.irfft\">irfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.is\">is() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.is_apple\">is_apple() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.is_assigned_char\">is_assigned_char() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.is_bsd\">is_bsd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.is_linux\">is_linux() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.is_unix\">is_unix() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.is_windows\">is_windows() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isa\">isa() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.isabspath\">isabspath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isalnum\">isalnum() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isalpha\">isalpha() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.isapprox\">isapprox() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isascii\">isascii() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.isassigned\">isassigned() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isbits\">isbits() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.isblockdev\">isblockdev() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.ischardev\">ischardev() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/strings.html#Base.iscntrl\">iscntrl() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isconst\">isconst() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isdefined\">isdefined() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.isdiag\">isdiag() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isdigit\">isdigit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.isdir\">isdir() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.isdirpath\">isdirpath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.isempty\">isempty() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isequal\">isequal() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.iseven\">iseven() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.isfifo\">isfifo() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.isfile\">isfile() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isfinite\">isfinite() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isgraph\">isgraph() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.isheap\">isheap() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ishermitian\">ishermitian() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isimag\">isimag() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isimmutable\">isimmutable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isinf\">isinf() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isinteger\">isinteger() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isinteractive\">isinteractive() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isleaftype\">isleaftype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.isleapyear\">isleapyear() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isless\">isless() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.islink\">islink() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.islocked\">islocked() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.islower\">islower() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.ismarked\">ismarked() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.ismatch\">ismatch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.ismount\">ismount() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isnan\">isnan() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isnull\">isnull() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isnumber\">isnumber() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isodd\">isodd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.isopen\">isopen() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.ispath\">ispath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.isperm\">isperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.isposdef!\">isposdef!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.isposdef\">isposdef() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ispow2\">ispow2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isprint\">isprint() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.ispunct\">ispunct() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.isqrt\">isqrt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.isreadable\">isreadable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.isreadonly\">isreadonly() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.isready\">isready() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.isready\">[1]</a>, <a href=\"stdlib/parallel.html#Base.isready\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isreal\">isreal() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.issetgid\">issetgid() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.issetuid\">issetuid() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.issocket\">issocket() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.issorted\">issorted() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isspace\">isspace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.issparse\">issparse() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.issticky\">issticky() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.issubnormal\">issubnormal() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.issubset\">issubset() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.issubset\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.issubtype\">issubtype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.issymmetric\">issymmetric() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.istaskdone\">istaskdone() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.istaskstarted\">istaskstarted() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.istextmime\">istextmime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.istril\">istril() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.istriu\">istriu() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isupper\">isupper() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isvalid\">isvalid() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.isvalid\">[1]</a>, <a href=\"stdlib/strings.html#Base.isvalid\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.iswritable\">iswritable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isxdigit\">isxdigit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.iteratoreltype\">iteratoreltype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.iteratorsize\">iteratorsize() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"J\">J</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/io-network.html#Base.join\">join() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.join\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.joinpath\">joinpath() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/constants.html#Base.JULIA_HOME\">JULIA_HOME (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.julian2datetime\">julian2datetime() (in module Dates)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"K\">K</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.KeyError\">KeyError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.keys\">keys() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.keytype\">keytype() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.kill\">kill() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.kill\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.kron\">kron() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"L\">L</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/collections.html#Base.last\">last() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.lastdayofmonth\">lastdayofmonth() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.lastdayofquarter\">lastdayofquarter() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.lastdayofweek\">lastdayofweek() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.lastdayofyear\">lastdayofyear() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.launch\">launch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.lbeta\">lbeta() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.lcfirst\">lcfirst() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.lcm\">lcm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ldexp\">ldexp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ldltfact!\">ldltfact!() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.ldltfact!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ldltfact\">ldltfact() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.ldltfact\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.leading_ones\">leading_ones() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.leading_zeros\">leading_zeros() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.length\">length() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.length\">[1]</a>, <a href=\"stdlib/strings.html#Base.length\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.less\">less() (in module Base)</a>, <a href=\"stdlib/base.html#Base.less\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.lexcmp\">lexcmp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.lexless\">lexless() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.lfact\">lfact() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.lgamma\">lgamma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#module-Libc\">Libc (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#module-Libdl\">Libdl (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.LinAlg.checksquare\">LinAlg.checksquare() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.Givens\">LinAlg.Givens() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.qr!\">LinAlg.qr!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.linearindices\">linearindices() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.linreg\">linreg() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.linspace\">linspace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.listen\">listen() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.listen\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.listenany\">listenany() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/c.html#Base.llvmcall\">llvmcall() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.LOAD_PATH\">LOAD_PATH (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.LoadError\">LoadError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.localindexes\">localindexes() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.lock\">lock() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.log\">log() (in module Base)</a>, <a href=\"stdlib/math.html#Base.log\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.log10\">log10() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.log1p\">log1p() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.log2\">log2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.logabsdet\">logabsdet() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.logdet\">logdet() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.logm\">logm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.logspace\">logspace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/stacktraces.html#Base.StackTraces.lookup\">lookup() (in module Base.StackTraces)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.lowercase\">lowercase() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.lowrankdowndate!\">lowrankdowndate!() (in module Base.LinAlg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.lowrankdowndate\">lowrankdowndate() (in module Base.LinAlg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.lowrankupdate!\">lowrankupdate!() (in module Base.LinAlg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.lowrankupdate\">lowrankupdate() (in module Base.LinAlg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.lpad\">lpad() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.lq\">lq() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.lqfact!\">lqfact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.lqfact\">lqfact() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.lstat\">lstat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.lstrip\">lstrip() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.ltoh\">ltoh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.lu\">lu() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.lufact!\">lufact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.lufact\">lufact() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.lufact\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.lyap\">lyap() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"M\">M</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.macroexpand\">macroexpand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.malloc\">malloc() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.manage\">manage() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.map!\">map!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.map!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.map\">map() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.mapfoldl\">mapfoldl() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.mapfoldl\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.mapfoldr\">mapfoldr() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.mapfoldr\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.mapreduce\">mapreduce() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.mapreduce\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.mapreducedim\">mapreducedim() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.mapslices\">mapslices() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.mark\">mark() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.match\">match() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.matchall\">matchall() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.max\">max() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.maxabs!\">maxabs!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.maxabs\">maxabs() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.maxabs\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.maximum!\">maximum!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.maximum\">maximum() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.maximum\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.maxintfloat\">maxintfloat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.mean!\">mean!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.mean\">mean() (in module Base)</a>, <a href=\"stdlib/math.html#Base.mean\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.median!\">median!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.median\">median() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.merge!\">merge!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.merge\">merge() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.MersenneTwister\">MersenneTwister() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.method_exists\">method_exists() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.MethodError\">MethodError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.methods\">methods() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.methodswith\">methodswith() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.middle\">middle() (in module Base)</a>, <a href=\"stdlib/math.html#Base.middle\">[1]</a>, <a href=\"stdlib/math.html#Base.middle\">[2]</a>, <a href=\"stdlib/math.html#Base.middle\">[3]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.midpoints\">midpoints() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Millisecond\">Millisecond (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Millisecond\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Millisecond\">Millisecond() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.millisecond\">millisecond() (in module Dates)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/io-network.html#Base.mimewritable\">mimewritable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.min\">min() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.minabs!\">minabs!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.minabs\">minabs() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.minabs\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.minimum!\">minimum!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.minimum\">minimum() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.minimum\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.minmax\">minmax() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Minute\">Minute (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Minute\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Minute\">Minute() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.minute\">minute() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.mkdir\">mkdir() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.mkpath\">mkpath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.mktemp\">mktemp() (in module Base)</a>, <a href=\"stdlib/file.html#Base.mktemp\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.mktempdir\">mktempdir() (in module Base)</a>, <a href=\"stdlib/file.html#Base.mktempdir\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.Mmap.Anonymous\">Mmap.Anonymous() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.Mmap.mmap\">Mmap.mmap() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.Mmap.mmap\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.Mmap.sync!\">Mmap.sync!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.mod\">mod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.mod1\">mod1() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.mod2pi\">mod2pi() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.modf\">modf() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/modules.html#index-0\">module</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.module_name\">module_name() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.module_parent\">module_parent() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Month\">Month (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Month\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Month\">Month() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.month\">month() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.monthabbr\">monthabbr() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.monthday\">monthday() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.monthname\">monthname() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.mtime\">mtime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.muladd\">muladd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Mutex\">Mutex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.mv\">mv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.myid\">myid() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"N\">N</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.names\">names() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.NaN\">NaN (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.NaN16\">NaN16 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.NaN32\">NaN32 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.nb_available\">nb_available() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ndigits\">ndigits() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ndims\">ndims() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.next\">next() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.nextfloat\">nextfloat() (in module Base)</a>, <a href=\"stdlib/numbers.html#Base.nextfloat\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.nextind\">nextind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.nextpow\">nextpow() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.nextpow2\">nextpow2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.nextprod\">nextprod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.nfields\">nfields() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.nnz\">nnz() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.nonzeros\">nonzeros() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.norm\">norm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.normalize!\">normalize!() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.normalize\">normalize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.normalize_string\">normalize_string() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.normpath\">normpath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.nothing\">nothing (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.notify\">notify() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.now\">now() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.now\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.nprocs\">nprocs() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.nrm2\">nrm2() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.ntoh\">ntoh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ntuple\">ntuple() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Nullable\">Nullable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.NullException\">NullException() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.nullspace\">nullspace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.num\">num() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.num2hex\">num2hex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.nworkers\">nworkers() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.nzrange\">nzrange() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"O\">O</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.object_id\">object_id() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.oct\">oct() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.oftype\">oftype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.one\">one() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ones\">ones() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.ones\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.open\">open() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.open\">[1]</a>, <a href=\"stdlib/io-network.html#Base.open\">[2]</a>, <a href=\"stdlib/io-network.html#Base.open\">[3]</a>, <a href=\"stdlib/io-network.html#Base.open\">[4]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.operm\">operm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ordschur!\">ordschur!() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.ordschur!\">[1]</a>, <a href=\"stdlib/linalg.html#Base.ordschur!\">[2]</a>, <a href=\"stdlib/linalg.html#Base.ordschur!\">[3]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ordschur\">ordschur() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.ordschur\">[1]</a>, <a href=\"stdlib/linalg.html#Base.ordschur\">[2]</a>, <a href=\"stdlib/linalg.html#Base.ordschur\">[3]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.orghr!\">orghr!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.orglq!\">orglq!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.orgql!\">orgql!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.orgqr!\">orgqr!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.orgrq!\">orgrq!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ormlq!\">ormlq!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ormql!\">ormql!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ormqr!\">ormqr!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ormrq!\">ormrq!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ormrz!\">ormrz!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.OutOfMemoryError\">OutOfMemoryError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.OverflowError\">OverflowError() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"P\">P</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/arrays.html#Base.parent\">parent() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.parentindexes\">parentindexes() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.parse\">parse() (in module Base)</a>, <a href=\"stdlib/base.html#Base.parse\">[1]</a>, <a href=\"stdlib/numbers.html#Base.parse\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ParseError\">ParseError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.peakflops\">peakflops() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.peek\">peek() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Period\">Period (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.permute!\">permute!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.permutedims!\">permutedims!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.permutedims\">permutedims() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.pi\">pi (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.pin\">pin() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.pin\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.pinv\">pinv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.PipeBuffer\">PipeBuffer() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.PipeBuffer\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.pipeline\">pipeline() (in module Base)</a>, <a href=\"stdlib/base.html#Base.pipeline\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_bfft!\">plan_bfft!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_bfft\">plan_bfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_brfft\">plan_brfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_dct!\">plan_dct!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_dct\">plan_dct() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_fft!\">plan_fft!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_fft\">plan_fft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_idct!\">plan_idct!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_idct\">plan_idct() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_ifft!\">plan_ifft!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_ifft\">plan_ifft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_irfft\">plan_irfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.FFTW.plan_r2r!\">plan_r2r!() (in module Base.FFTW)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.FFTW.plan_r2r\">plan_r2r() (in module Base.FFTW)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_rfft\">plan_rfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.pmap\">pmap() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.pointer\">pointer() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.pointer_from_objref\">pointer_from_objref() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.poll_fd\">poll_fd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.poll_file\">poll_file() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.polygamma\">polygamma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.pop!\">pop!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.pop!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.popdisplay\">popdisplay() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.position\">position() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.posv!\">posv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.potrf!\">potrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.potri!\">potri!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.potrs!\">potrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.powermod\">powermod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.precision\">precision() (in module Base)</a>, <a href=\"stdlib/numbers.html#Base.precision\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.precompile\">precompile() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.prepend!\">prepend!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.prevfloat\">prevfloat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.prevind\">prevind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.prevpow\">prevpow() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.prevpow2\">prevpow2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.print\">print() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/profile.html#Base.Profile.print\">(in module Base.Profile)</a>, <a href=\"stdlib/profile.html#Base.Profile.print\">[1]</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/io-network.html#Base.print_shortest\">print_shortest() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.print_with_color\">print_with_color() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.println\">println() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.PriorityQueue\">PriorityQueue() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.process_exited\">process_exited() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.process_running\">process_running() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ProcessExitedException\">ProcessExitedException() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.procs\">procs() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.procs\">[1]</a>, <a href=\"stdlib/parallel.html#Base.procs\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.prod!\">prod!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.prod\">prod() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.prod\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.produce\">produce() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/profile.html#module-Profile\">Profile (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.PROGRAM_FILE\">PROGRAM_FILE (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.promote\">promote() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.promote_rule\">promote_rule() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.promote_shape\">promote_shape() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.promote_type\">promote_type() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.pstrf!\">pstrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Ptr{T}\">Ptr{T} (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ptsv!\">ptsv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.pttrf!\">pttrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.pttrs!\">pttrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.push!\">push!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.pushdisplay\">pushdisplay() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.put!\">put!() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.put!\">[1]</a>, <a href=\"stdlib/parallel.html#Base.put!\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.pwd\">pwd() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"Q\">Q</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/arrays.html#Base.q::AbstractVector{Tq})\">q::AbstractVector{Tq})() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.qr\">qr() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.qr\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.qrfact!\">qrfact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.qrfact\">qrfact() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.qrfact\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.quadgk\">quadgk() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.quantile!\">quantile!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.quantile\">quantile() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.quarterofyear\">quarterofyear() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.quit\">quit() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"R\">R</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.FFTW.r2r!\">r2r!() (in module Base.FFTW)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.FFTW.r2r\">r2r() (in module Base.FFTW)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.rad2deg\">rad2deg() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.rand!\">rand!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.rand\">rand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.randcycle\">randcycle() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.randexp!\">randexp!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.randexp\">randexp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.randjump\">randjump() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.randn!\">randn!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.randn\">randn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.RandomDevice\">RandomDevice() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.randperm\">randperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.randstring\">randstring() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.randsubseq!\">randsubseq!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.randsubseq\">randsubseq() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.range\">range() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.rank\">rank() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.rata2datetime\">rata2datetime() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.rationalize\">rationalize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.read!\">read!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.read\">read() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.read\">[1]</a>, <a href=\"stdlib/io-network.html#Base.read\">[2]</a>, <a href=\"stdlib/io-network.html#Base.read\">[3]</a>, <a href=\"stdlib/io-network.html#Base.read\">[4]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.readandwrite\">readandwrite() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readavailable\">readavailable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readbytes!\">readbytes!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readchomp\">readchomp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readcsv\">readcsv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.readdir\">readdir() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readdlm\">readdlm() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.readdlm\">[1]</a>, <a href=\"stdlib/io-network.html#Base.readdlm\">[2]</a>, <a href=\"stdlib/io-network.html#Base.readdlm\">[3]</a>, <a href=\"stdlib/io-network.html#Base.readdlm\">[4]</a>, <a href=\"stdlib/io-network.html#Base.readdlm\">[5]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readline\">readline() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readlines\">readlines() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.readlink\">readlink() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ReadOnlyMemoryError\">ReadOnlyMemoryError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readstring\">readstring() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readuntil\">readuntil() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.real\">real() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.realloc\">realloc() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.realmax\">realmax() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.realmin\">realmin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.realpath\">realpath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#Base.Test.record\">record() (in module Base.Test)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.RecursiveSpinLock\">RecursiveSpinLock() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.recur{T<:TimeType}\">recur{T&lt;:TimeType}() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.recv\">recv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.recvfrom\">recvfrom() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.redirect_stderr\">redirect_stderr() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.redirect_stdin\">redirect_stdin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.redirect_stdout\">redirect_stdout() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.redirect_stdout\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.redisplay\">redisplay() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.reduce\">reduce() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.reduce\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.reducedim\">reducedim() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.reenable_sigint\">reenable_sigint() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.ReentrantLock\">ReentrantLock() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Ref{T}\">Ref{T} (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.reim\">reim() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.reinterpret\">reinterpret() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.release\">release() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.reload\">reload() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.relpath\">relpath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.rem\">rem() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/parallel.html#Base.remote\">remote() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.remotecall\">remotecall() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.remotecall\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.remotecall_fetch\">remotecall_fetch() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.remotecall_fetch\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.remotecall_wait\">remotecall_wait() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.remotecall_wait\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.RemoteChannel\">RemoteChannel() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.RemoteChannel\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.RemoteException\">RemoteException() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/stacktraces.html#Base.StackTraces.remove_frames!\">remove_frames!() (in module Base.StackTraces)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.repeat\">repeat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.repeated\">repeated() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.replace\">replace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.repmat\">repmat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.repr\">repr() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.reprmime\">reprmime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.require\">require() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.reset\">reset() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.reshape\">reshape() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.resize!\">resize!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.resolve\">resolve() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.rest\">rest() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.rethrow\">rethrow() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/profile.html#Base.Profile.retrieve\">retrieve() (in module Base.Profile)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.retry\">retry() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.reverse!\">reverse!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.reverse\">reverse() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.reverse\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.reverseind\">reverseind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.rfft\">rfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.rm\">rm() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.rm\">(in module Base.Pkg)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/parallel.html#Base.rmprocs\">rmprocs() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.rol!\">rol!() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.rol!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.rol\">rol() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ror!\">ror!() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.ror!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ror\">ror() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.rot180\">rot180() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.rot180\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.rotl90\">rotl90() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.rotl90\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.rotr90\">rotr90() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.rotr90\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.round\">round() (in module Base)</a>, <a href=\"stdlib/math.html#Base.round\">[1]</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/dates.html#Dates.round\">(in module Dates)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/math.html#Base.RoundDown\">RoundDown (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.rounding\">rounding() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.RoundNearest\">RoundNearest (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.RoundNearestTiesAway\">RoundNearestTiesAway (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.RoundNearestTiesUp\">RoundNearestTiesUp (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.RoundToZero\">RoundToZero (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.RoundUp\">RoundUp (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.rowvals\">rowvals() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.rpad\">rpad() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.rsearch\">rsearch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.rsearchindex\">rsearchindex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.rsplit\">rsplit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.rstrip\">rstrip() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.RTLD_DEEPBIND\">RTLD_DEEPBIND (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.RTLD_FIRST\">RTLD_FIRST (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.RTLD_GLOBAL\">RTLD_GLOBAL (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.RTLD_LAZY\">RTLD_LAZY (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.RTLD_LOCAL\">RTLD_LOCAL (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.RTLD_NODELETE\">RTLD_NODELETE (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.RTLD_NOLOAD\">RTLD_NOLOAD (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.RTLD_NOW\">RTLD_NOW (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.run\">run() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#Base.runtests\">runtests() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"S\">S</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.sbmv!\">sbmv!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.sbmv\">sbmv() (in module Base.LinAlg.BLAS)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.sbmv\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.scal!\">scal!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.scal\">scal() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.scale!\">scale!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.schedule\">schedule() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.schur\">schur() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.schur\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.schurfact!\">schurfact!() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.schurfact!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.schurfact\">schurfact() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.schurfact\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.sdata\">sdata() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.search\">search() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.searchindex\">searchindex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.searchsorted\">searchsorted() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.searchsortedfirst\">searchsortedfirst() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.searchsortedlast\">searchsortedlast() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sec\">sec() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.secd\">secd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sech\">sech() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Second\">Second (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Second\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Second\">Second() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.second\">second() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.seek\">seek() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.seekend\">seekend() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.seekstart\">seekstart() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.select!\">select!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.select\">select() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.selectperm!\">selectperm!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.selectperm\">selectperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Semaphore\">Semaphore() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.send\">send() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.serialize\">serialize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Set\">Set() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.set_num_threads\">set_num_threads() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.set_zero_subnormals\">set_zero_subnormals() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.setdiff!\">setdiff!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.setdiff\">setdiff() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.setenv\">setenv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.setfield!\">setfield!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.setindex!\">setindex!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.setindex!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.setopt\">setopt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.setprecision\">setprecision() (in module Base)</a>, <a href=\"stdlib/numbers.html#Base.setprecision\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.setprotocol!\">setprotocol!() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.setrounding\">setrounding() (in module Base)</a>, <a href=\"stdlib/numbers.html#Base.setrounding\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.SharedArray\">SharedArray() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.SharedArray\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.shift!\">shift!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.show\">show() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.show\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.showall\">showall() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.showcompact\">showcompact() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.showerror\">showerror() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.shuffle!\">shuffle!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.shuffle\">shuffle() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sign\">sign() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.signbit\">signbit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.signed\">signed() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.signif\">signif() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.significand\">significand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.similar\">similar() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.similar\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sin\">sin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sinc\">sinc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sind\">sind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sinh\">sinh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sinpi\">sinpi() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.size\">size() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sizehint!\">sizehint!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.sizeof\">sizeof() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.sizeof\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.skip\">skip() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.skipchars\">skipchars() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.sleep\">sleep() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.slicedim\">slicedim() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.sort!\">sort!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.sort\">sort() (in module Base)</a>, <a href=\"stdlib/sort.html#Base.sort\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.sortcols\">sortcols() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.sortperm!\">sortperm!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.sortperm\">sortperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.sortrows\">sortrows() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.sparse\">sparse() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.sparse\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.sparsevec\">sparsevec() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.sparsevec\">[1]</a>, <a href=\"stdlib/arrays.html#Base.sparsevec\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.spawn\">spawn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.spdiagm\">spdiagm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.speye\">speye() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.speye\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.SpinLock\">SpinLock() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.splice!\">splice!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.splice!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.split\">split() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.splitdir\">splitdir() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.splitdrive\">splitdrive() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.splitext\">splitext() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.spones\">spones() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/arrays.html#Base.sprand\">sprand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.sprandn\">sprandn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.sprint\">sprint() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.spzeros\">spzeros() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sqrt\">sqrt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.sqrtm\">sqrtm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.squeeze\">squeeze() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.srand\">srand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/stacktraces.html#Base.StackFrame\">StackFrame (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.StackOverflowError\">StackOverflowError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/stacktraces.html#Base.StackTrace\">StackTrace (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/stacktraces.html#Base.stacktrace\">stacktrace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/stacktraces.html#module-StackTraces\">StackTraces (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.start\">start() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.startswith\">startswith() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.stat\">stat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.status\">status() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.status\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.std\">std() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.STDERR\">STDERR (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.STDIN\">STDIN (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.stdm\">stdm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.STDOUT\">STDOUT (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.stebz!\">stebz!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.stegr!\">stegr!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.stein!\">stein!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.step\">step() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.stev!\">stev!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.strerror\">strerror() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.strftime\">strftime() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.stride\">stride() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.strides\">strides() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.String\">String() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.string\">string() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.stringmime\">stringmime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.strip\">strip() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.strptime\">strptime() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.strwidth\">strwidth() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.sub2ind\">sub2ind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.subtypes\">subtypes() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.success\">success() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sum!\">sum!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sum\">sum() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.sum\">[1]</a>, <a href=\"stdlib/collections.html#Base.sum\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.sum_kbn\">sum_kbn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sumabs!\">sumabs!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sumabs\">sumabs() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.sumabs\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sumabs2!\">sumabs2!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sumabs2\">sumabs2() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.sumabs2\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.summary\">summary() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.supertype\">supertype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.svd\">svd() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.svd\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.svdfact!\">svdfact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.svdfact\">svdfact() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.svdfact\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.svds\">svds() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.svdvals!\">svdvals!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.svdvals\">svdvals() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.svdvals\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.syconv!\">syconv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.syev!\">syev!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.syevr!\">syevr!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.sygvd!\">sygvd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.sylvester\">sylvester() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.Symbol\">Symbol() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.symdiff!\">symdiff!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.symdiff!\">[1]</a>, <a href=\"stdlib/collections.html#Base.symdiff!\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.symdiff\">symdiff() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.symlink\">symlink() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symm!\">symm!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symm\">symm() (in module Base.LinAlg.BLAS)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symm\">[1]</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symm\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Symmetric\">Symmetric() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.SymTridiagonal\">SymTridiagonal() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symv!\">symv!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symv\">symv() (in module Base.LinAlg.BLAS)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symv\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.syr!\">syr!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.syrk!\">syrk!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.syrk\">syrk() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.Sys.ARCH\">Sys.ARCH (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.Sys.CPU_CORES\">Sys.CPU_CORES (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Sys.get_process_title\">Sys.get_process_title() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.Sys.KERNEL\">Sys.KERNEL (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.Sys.MACHINE\">Sys.MACHINE (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Sys.set_process_title\">Sys.set_process_title() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.Sys.WORD_SIZE\">Sys.WORD_SIZE (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.SystemError\">SystemError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.systemerror\">systemerror() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.sysv!\">sysv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.sytrf!\">sytrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.sytri!\">sytri!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.sytrs!\">sytrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"T\">T</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/parallel.html#Base.take!\">take!() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.take!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.take\">take() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.takebuf_array\">takebuf_array() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.takebuf_string\">takebuf_string() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.tan\">tan() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.tand\">tand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.tanh\">tanh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Task\">Task() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.task_local_storage\">task_local_storage() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.task_local_storage\">[1]</a>, <a href=\"stdlib/parallel.html#Base.task_local_storage\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.tempdir\">tempdir() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.tempname\">tempname() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.test\">test() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.test\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.TextDisplay\">TextDisplay() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.tgsen!\">tgsen!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.@threads\">Threads.@threads() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_add!{T}\">Threads.atomic_add!{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_and!{T}\">Threads.atomic_and!{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_cas!{T}\">Threads.atomic_cas!{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_fence\">Threads.atomic_fence() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_max!{T}\">Threads.atomic_max!{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_min!{T}\">Threads.atomic_min!{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_nand!{T}\">Threads.atomic_nand!{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_or!{T}\">Threads.atomic_or!{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_sub!{T}\">Threads.atomic_sub!{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_xchg!{T}\">Threads.atomic_xchg!{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_xor!{T}\">Threads.atomic_xor!{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.Atomic{T}\">Threads.Atomic{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.nthreads\">Threads.nthreads() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.threadid\">Threads.threadid() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.throw\">throw() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.tic\">tic() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.time\">time() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/libc.html#Base.Libc.time\">(in module Base.Libc)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/base.html#Base.time_ns\">time_ns() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.timedwait\">timedwait() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Timer\">Timer() (in module Base)</a>, <a href=\"stdlib/base.html#Base.Timer\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.TimeType\">TimeType (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.TmStruct\">TmStruct() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.toc\">toc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.today\">today() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.tofirst\">tofirst() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.tolast\">tolast() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.tonext\">tonext() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.tonext\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.toprev\">toprev() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.toprev\">[1]</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.toq\">toq() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.touch\">touch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.trace\">trace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.trailing_ones\">trailing_ones() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.trailing_zeros\">trailing_zeros() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.transcode\">transcode() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.transpose!\">transpose!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.transpose\">transpose() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trcon!\">trcon!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trevc!\">trevc!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trexc!\">trexc!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Tridiagonal\">Tridiagonal() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.Tridiagonal\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.trigamma\">trigamma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.tril!\">tril!() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.tril!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.tril\">tril() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.tril\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.triu!\">triu!() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.triu!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.triu\">triu() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.triu\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trmm!\">trmm!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trmm\">trmm() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trmv!\">trmv!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trmv\">trmv() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trrfs!\">trrfs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trsen!\">trsen!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trsm!\">trsm!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trsm\">trsm() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trsv!\">trsv!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trsv\">trsv() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trsyl!\">trsyl!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trtri!\">trtri!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trtrs!\">trtrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.trues\">trues() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.trues\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.trunc\">trunc() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/dates.html#Dates.trunc\">(in module Dates)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/io-network.html#Base.truncate\">truncate() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.trylock\">trylock() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.tryparse\">tryparse() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.tuple\">tuple() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.TypeError\">TypeError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.typeintersect\">typeintersect() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.typejoin\">typejoin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.typemax\">typemax() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.typemin\">typemin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.typeof\">typeof() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.tzrzf!\">tzrzf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"U\">U</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/strings.html#Base.ucfirst\">ucfirst() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.UndefRefError\">UndefRefError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.UndefVarError\">UndefVarError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.unescape_string\">unescape_string() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.unescape_string\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.union!\">union!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.union\">union() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.unique\">unique() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.unique\">[1]</a>, <a href=\"stdlib/collections.html#Base.unique\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.unix2datetime\">unix2datetime() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.unlock\">unlock() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.unmark\">unmark() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.unsafe_convert\">unsafe_convert() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.unsafe_copy!\">unsafe_copy!() (in module Base)</a>, <a href=\"stdlib/c.html#Base.unsafe_copy!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.unsafe_load\">unsafe_load() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.unsafe_pointer_to_objref\">unsafe_pointer_to_objref() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/io-network.html#Base.unsafe_read\">unsafe_read() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.unsafe_store!\">unsafe_store!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.unsafe_string\">unsafe_string() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.unsafe_trunc\">unsafe_trunc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.unsafe_wrap\">unsafe_wrap() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.unsafe_wrap\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.unsafe_write\">unsafe_write() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.unshift!\">unshift!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.unsigned\">unsigned() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.update\">update() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.uperm\">uperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.uppercase\">uppercase() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/modules.html#index-0\">using</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.UTInstant{T}\">UTInstant{T} (in module Dates)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"V\">V</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/collections.html#Base.valtype\">valtype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.values\">values() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Val{c}\">Val{c}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.var\">var() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.varm\">varm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.vcat\">vcat() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/arrays.html#Base.vec\">vec() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.vecdot\">vecdot() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.vecnorm\">vecnorm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.VERSION\">VERSION (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.versioninfo\">versioninfo() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.view\">view() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"W\">W</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/parallel.html#Base.wait\">wait() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.walkdir\">walkdir() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.warn\">warn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.watch_file\">watch_file() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Week\">Week (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Week\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Week\">Week() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.week\">week() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.which\">which() (in module Base)</a>, <a href=\"stdlib/base.html#Base.which\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.whos\">whos() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.widemul\">widemul() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.widen\">widen() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.windows_version\">windows_version() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.withenv\">withenv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.WorkerPool\">WorkerPool() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.workers\">workers() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.workspace\">workspace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.write\">write() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.writecsv\">writecsv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.writedlm\">writedlm() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"X\">X</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.xcorr\">xcorr() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"Y\">Y</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Year\">Year (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Year\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Year\">Year() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.year\">year() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.yearmonth\">yearmonth() (in module Dates)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/dates.html#Dates.yearmonthday\">yearmonthday() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.yield\">yield() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.yieldto\">yieldto() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"Z\">Z</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/numbers.html#Base.zero\">zero() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.zeros\">zeros() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.zeros\">[1]</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.zeta\">zeta() (in module Base)</a>, <a href=\"stdlib/math.html#Base.zeta\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.zip\">zip() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"Symbols\">Symbols</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.\u00d7\">\u00d7() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.\u00f7\">\u00f7() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.\u03b3\">\u03b3 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.\u03c0\">\u03c0 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.\u03c6\">\u03c6 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u2208\">\u2208() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u2209\">\u2209() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u220b\">\u220b() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u220c\">\u220c() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u2229\">\u2229() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u222a\">\u222a() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.\u2261\">\u2261() (in module Base)</a>, <a href=\"stdlib/math.html#Base.\u2261\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.\u2262\">\u2262() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.\u2264\">\u2264() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.\u2265\">\u2265() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u2286\">\u2286() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.\u2286\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u2288\">\u2288() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u228a\">\u228a() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.\u22c5\">\u22c5() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n\n\n          </div>\n          <footer>\n  \n\n  <hr/>\n\n  <div role=\"contentinfo\">\n    <p>\n    </p>\n  </div>\n\n  <a href=\"https://github.com/snide/sphinx_rtd_theme\">Sphinx theme</a> provided by <a href=\"https://readthedocs.org\">Read the Docs</a>\n</footer>\n        </div>\n      </div>\n\n    </section>\n\n  </div>\n  \n\n  \n\n    <script type=\"text/javascript\">\n        var DOCUMENTATION_OPTIONS = {\n            URL_ROOT:'./',\n            VERSION:'0.5.1',\n            COLLAPSE_INDEX:false,\n            FILE_SUFFIX:'.html',\n            HAS_SOURCE:  true\n        };\n    </script>\n      <script type=\"text/javascript\" src=\"_static/jquery.js\"></script>\n      <script type=\"text/javascript\" src=\"_static/underscore.js\"></script>\n      <script type=\"text/javascript\" src=\"_static/doctools.js\"></script>\n      <script type=\"text/javascript\" src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>\n\n  \n\n  \n  \n    <script type=\"text/javascript\" src=\"_static/js/theme.js\"></script>\n  \n\n  \n  \n  <script type=\"text/javascript\">\n      jQuery(function () {\n          SphinxRtdTheme.StickyNav.enable();\n      });\n  </script>\n   \n\n</body>\n</html>",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_sources/stdlib/libdl.txt": ".. module:: Libdl\n\n****************\n Dynamic Linker\n****************\n\n.. currentmodule:: Base.Libdl\n\nThe names in :mod:`Base.Libdl` are not exported and need to be called e.g. as ``Libdl.dlopen()``.\n\n.. function:: dlopen(libfile::AbstractString [, flags::Integer])\n\n   .. Docstring generated from Julia source\n\n   Load a shared library, returning an opaque handle.\n\n   The optional flags argument is a bitwise-or of zero or more of ``RTLD_LOCAL``\\ , ``RTLD_GLOBAL``\\ , ``RTLD_LAZY``\\ , ``RTLD_NOW``\\ , ``RTLD_NODELETE``\\ , ``RTLD_NOLOAD``\\ , ``RTLD_DEEPBIND``\\ , and ``RTLD_FIRST``\\ . These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default ``dlopen`` flags are ``RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL`` while on other platforms the defaults are ``RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL``\\ . An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance ``RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL`` allows the library's symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.\n\n.. function:: dlopen_e(libfile::AbstractString [, flags::Integer])\n\n   .. Docstring generated from Julia source\n\n   Similar to :func:`dlopen`\\ , except returns a ``NULL`` pointer instead of raising errors.\n\n.. data:: RTLD_DEEPBIND\n          RTLD_FIRST\n          RTLD_GLOBAL\n          RTLD_LAZY\n          RTLD_LOCAL\n          RTLD_NODELETE\n          RTLD_NOLOAD\n          RTLD_NOW\n\n   .. Docstring generated from Julia source\n\n   Enum constant for :func:`dlopen`\\ . See your platform man page for details, if applicable.\n\n.. function:: dlsym(handle, sym)\n\n   .. Docstring generated from Julia source\n\n   Look up a symbol from a shared library handle, return callable function pointer on success.\n\n.. function:: dlsym_e(handle, sym)\n\n   .. Docstring generated from Julia source\n\n   Look up a symbol from a shared library handle, silently return ``NULL`` pointer on lookup failure.\n\n.. function:: dlclose(handle)\n\n   .. Docstring generated from Julia source\n\n   Close shared library referenced by handle.\n\n.. data:: dlext\n\n   .. Docstring generated from Julia source\n\n   File extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.\n\n.. function:: find_library(names, locations)\n\n   .. Docstring generated from Julia source\n\n   Searches for the first library in ``names`` in the paths in the ``locations`` list, ``DL_LOAD_PATH``\\ , or system library paths (in that order) which can successfully be dlopen'd. On success, the return value will be one of the names (potentially prefixed by one of the paths in locations). This string can be assigned to a ``global const`` and used as the library name in future ``ccall``\\ 's. On failure, it returns the empty string.\n\n.. data:: DL_LOAD_PATH\n\n   .. Docstring generated from Julia source\n\n   When calling :func:`dlopen`\\ , the paths in this list will be searched first, in order, before searching the system locations for a valid library handle.\n\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_sources/manual/calling-c-and-fortran-code.txt": ".. _man-calling-c-and-fortran-code:\n\n.. currentmodule:: Base\n\n****************************\n Calling C and Fortran Code\n****************************\n\nThough most code can be written in Julia, there are many high-quality,\nmature libraries for numerical computing already written in C and\nFortran. To allow easy use of this existing code, Julia makes it simple\nand efficient to call C and Fortran functions. Julia has a \"no\nboilerplate\" philosophy: functions can be called directly from Julia\nwithout any \"glue\" code, code generation, or compilation \u2014 even from the\ninteractive prompt. This is accomplished just by making an appropriate call\nwith :func:`ccall` syntax, which looks like an ordinary function call.\n\nThe code to be called must be available as a shared library. Most C and\nFortran libraries ship compiled as shared libraries already, but if you\nare compiling the code yourself using GCC (or Clang), you will need to\nuse the ``-shared`` and ``-fPIC`` options. The machine instructions\ngenerated by Julia's JIT are the same as a native C call would be, so\nthe resulting overhead is the same as calling a library function from C\ncode. (Non-library function calls in both C and Julia can be inlined and\nthus may have even less overhead than calls to shared library functions.\nWhen both libraries and executables are generated by LLVM, it is\npossible to perform whole-program optimizations that can even optimize\nacross this boundary, but Julia does not yet support that. In the\nfuture, however, it may do so, yielding even greater performance gains.)\n\nShared libraries and functions are referenced by a tuple of the\nform ``(:function, \"library\")`` or ``(\"function\", \"library\")`` where ``function``\nis the C-exported function name. ``library`` refers to the shared library\nname: shared libraries available in the (platform-specific) load path\nwill be resolved by name, and if necessary a direct path may be specified.\n\nA function name may be used alone in place of the tuple (just\n``:function`` or ``\"function\"``). In this case the name is resolved within\nthe current process. This form can be used to call C library functions,\nfunctions in the Julia runtime, or functions in an application linked to\nJulia.\n\nBy default, Fortran compilers `generate mangled names\n<https://en.wikipedia.org/wiki/Name_mangling#Fortran>`_\n(for example, converting function names to lowercase or uppercase,\noften appending an underscore), and so to call a Fortran function via\n:func:`ccall` you must pass the mangled identifier corresponding to the rule\nfollowed by your Fortran compiler.  Also, when calling a Fortran\nfunction, all inputs must be passed by reference.\n\nFinally, you can use :func:`ccall` to actually generate a call to the\nlibrary function. Arguments to :func:`ccall` are as follows:\n\n1. (:function, \"library\") pair (must be a constant, but see below).\n\n2. Return type (see below for mapping the declared C type to Julia)\n\n   - This argument will be evaluated at compile-time.\n\n3. A tuple of input types. The input types must be written as a literal tuple,\n   not a tuple-valued variable or expression.\n\n   - This argument will be evaluated at compile-time.\n\n4. The following arguments, if any, are the actual argument values\n   passed to the function.\n\nAs a complete but simple example, the following calls the ``clock``\nfunction from the standard C library::\n\n    julia> t = ccall( (:clock, \"libc\"), Int32, ())\n    2292761\n\n    julia> t\n    2292761\n\n    julia> typeof(ans)\n    Int32\n\n``clock`` takes no arguments and returns an ``Int32``. One common gotcha\nis that a 1-tuple must be written with a trailing comma. For\nexample, to call the ``getenv`` function to get a pointer to the value\nof an environment variable, one makes a call like this::\n\n    julia> path = ccall((:getenv, \"libc\"), Cstring, (Cstring,), \"SHELL\")\n    Cstring(@0x00007fff5fbffc45)\n\n    julia> unsafe_string(path)\n    \"/bin/bash\"\n\nNote that the argument type tuple must be written as ``(Cstring,)``,\nrather than ``(Cstring)``. This is because ``(Cstring)`` is just\nthe expression ``Cstring`` surrounded by parentheses, rather than\na 1-tuple containing ``Cstring``:\n\n.. doctest::\n\n    julia> (Cstring)\n    Cstring\n\n    julia> (Cstring,)\n    (Cstring,)\n\nIn practice, especially when providing reusable functionality, one\ngenerally wraps :func:`ccall` uses in Julia functions that set up arguments\nand then check for errors in whatever manner the C or Fortran function\nindicates them, propagating to the Julia caller as exceptions. This is\nespecially important since C and Fortran APIs are notoriously\ninconsistent about how they indicate error conditions. For example, the\n``getenv`` C library function is wrapped in the following Julia function,\nwhich is a simplified version of the actual definition from\n`env.jl <https://github.com/JuliaLang/julia/blob/release-0.5/base/env.jl>`_::\n\n    function getenv(var::AbstractString)\n      val = ccall((:getenv, \"libc\"),\n                  Cstring, (Cstring,), var)\n      if val == C_NULL\n        error(\"getenv: undefined variable: \", var)\n      end\n      unsafe_string(val)\n    end\n\nThe C ``getenv`` function indicates an error by returning ``NULL``, but\nother standard C functions indicate errors in various different ways,\nincluding by returning -1, 0, 1 and other special values. This wrapper\nthrows an exception clearly indicating the problem if the caller tries\nto get a non-existent environment variable::\n\n    julia> getenv(\"SHELL\")\n    \"/bin/bash\"\n\n    julia> getenv(\"FOOBAR\")\n    getenv: undefined variable: FOOBAR\n\nHere is a slightly more complex example that discovers the local\nmachine's hostname::\n\n    function gethostname()\n      hostname = Array{UInt8}(128)\n      ccall((:gethostname, \"libc\"), Int32,\n            (Ptr{UInt8}, Csize_t),\n            hostname, sizeof(hostname))\n      hostname[end] = 0; # ensure null-termination\n      return unsafe_string(pointer(hostname))\n    end\n\nThis example first allocates an array of bytes, then calls the C library\nfunction ``gethostname`` to fill the array in with the hostname, takes a\npointer to the hostname buffer, and converts the pointer to a Julia\nstring, assuming that it is a NUL-terminated C string. It is common for\nC libraries to use this pattern of requiring the caller to allocate\nmemory to be passed to the callee and filled in. Allocation of memory\nfrom Julia like this is generally accomplished by creating an\nuninitialized array and passing a pointer to its data to the C function.\nThis is why we don't use the ``Cstring`` type here: as the array is\nuninitialized, it could contain NUL bytes. Converting to a ``Cstring`` as\npart of the :func:`ccall` checks for contained NUL bytes and could therefore\nthrow a conversion error.\n\nCreating C-Compatible Julia Function Pointers\n---------------------------------------------\n\nIt is possible to pass Julia functions to native C functions that accept\nfunction pointer arguments. For example, to match C prototypes of the form::\n\n    typedef returntype (*functiontype)(argumenttype,...)\n\nThe function :func:`cfunction` generates the C-compatible function pointer for\na call to a Julia library function.\nArguments to :func:`cfunction` are as follows:\n\n1. A Julia Function\n\n2. Return type\n\n3. A tuple of input types\n\nA classic example is the standard C library ``qsort`` function,\ndeclared as::\n\n    void qsort(void *base, size_t nmemb, size_t size,\n               int(*compare)(const void *a, const void *b));\n\nThe ``base`` argument is a pointer to an array of length ``nmemb``, with elements of\n``size`` bytes each. ``compare`` is a callback function which takes pointers to two\nelements ``a`` and ``b`` and returns an integer less/greater than zero if ``a`` should\nappear before/after ``b`` (or zero if any order is permitted). Now, suppose that we\nhave a 1d array ``A`` of values in Julia that we want to sort using the ``qsort``\nfunction (rather than Julia's built-in ``sort`` function). Before we worry about calling\n``qsort`` and passing arguments, we need to write a comparison function that works for\nsome arbitrary type T::\n\n    function mycompare{T}(a::T, b::T)\n        return convert(Cint, a < b ? -1 : a > b ? +1 : 0)::Cint\n    end\n\nNotice that we have to be careful about the return type: ``qsort`` expects a function\nreturning a C ``int``, so we must be sure to return ``Cint`` via a call to ``convert``\nand a ``typeassert``.\n\nIn order to pass this function to C, we obtain its address using the function ``cfunction``::\n\n    const mycompare_c = cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}))\n\n:func:`cfunction` accepts three arguments: the Julia function (``mycompare``),\nthe return type (``Cint``), and a tuple of the argument types, in this case to\nsort an array of ``Cdouble`` (``Float64``) elements.\n\nThe final call to ``qsort`` looks like this::\n\n    A = [1.3, -2.7, 4.4, 3.1]\n    ccall(:qsort, Void, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Void}),\n          A, length(A), sizeof(eltype(A)), mycompare_c)\n\nAfter this executes, ``A`` is changed to the sorted array ``[-2.7, 1.3, 3.1, 4.4]``.\nNote that Julia knows how to convert an array into a ``Ptr{Cdouble}``, how to compute\nthe size of a type in bytes (identical to C's ``sizeof`` operator), and so on.\nFor fun, try inserting a ``println(\"mycompare($a,$b)\")`` line into ``mycompare``, which\nwill allow you to see the comparisons that ``qsort`` is performing (and to verify that\nit is really calling the Julia function that you passed to it).\n\n\nMapping C Types to Julia\n------------------------\n\nIt is critical to exactly match the declared C type with its declaration\nin Julia. Inconsistencies can cause code that works correctly on one system\nto fail or produce indeterminate results on a different system.\n\nNote that no C header files are used anywhere in the process of calling C\nfunctions: you are responsible for making sure that your Julia types and\ncall signatures accurately reflect those in the C header file. (The `Clang\npackage <https://github.com/ihnorton/Clang.jl>`_ can be used to auto-generate\nJulia code from a C header file.)\n\nAuto-conversion:\n~~~~~~~~~~~~~~~~\n\nJulia automatically inserts calls to the :func:`cconvert` function to convert\neach argument to the specified type. For example, the following call::\n\n    ccall((:foo, \"libfoo\"), Void, (Int32, Float64), x, y)\n\nwill behave as if the following were written::\n\n    ccall((:foo, \"libfoo\"), Void, (Int32, Float64),\n          Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),\n          Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))\n\n:func:`cconvert` normally just calls :func:`convert`, but can be defined to return\nan arbitrary new object more appropriate for passing to C. For example,\nthis is used to convert an ``Array`` of objects (e.g. strings) to an\narray of pointers.\n\n:func:`unsafe_convert` handles conversion to ``Ptr`` types. It is considered\nunsafe because converting an object to a native pointer can hide the object\nfrom the garbage collector, causing it to be freed prematurely.\n\nType Correspondences:\n~~~~~~~~~~~~~~~~~~~~~\n\nFirst, a review of some relevant Julia type terminology:\n\n.. rst-class:: text-wrap\n\n==============================  ==============================  ======================================================\nSyntax / Keyword                Example                         Description\n==============================  ==============================  ======================================================\n``type``                        ``String``                      \"Leaf Type\" :: A group of related data that includes\n                                                                a type-tag, is managed by the Julia GC, and\n                                                                is defined by object-identity.\n                                                                The type parameters of a leaf type must be fully defined\n                                                                (no ``TypeVars`` are allowed)\n                                                                in order for the instance to be constructed.\n\n``abstract``                    ``Any``,                        \"Super Type\" :: A super-type (not a leaf-type)\n                                ``AbstractArray{T,N}``,         that cannot be instantiated, but can be used to\n                                ``Complex{T}``                  describe a group of types.\n\n``{T}``                         ``Vector{Int}``                 \"Type Parameter\" :: A specialization of a type\n                                                                (typically used for dispatch or storage optimization).\n\n                                                                \"TypeVar\" :: The ``T`` in the type parameter declaration\n                                                                is referred to as a TypeVar (short for type variable).\n\n``bitstype``                    ``Int``,                        \"Bits Type\" :: A type with no fields, but a size. It\n                                ``Float64``                     is stored and defined by-value.\n\n``immutable``                   ``Pair{Int,Int}``               \"Immutable\" :: A type with all fields defined to be\n                                                                constant. It is defined by-value. And may be stored\n                                                                with a type-tag.\n\n                                ``Complex128`` (``isbits``)     \"Is-Bits\" :: A ``bitstype``, or an ``immutable`` type\n                                                                where all fields are other ``isbits`` types. It is\n                                                                defined by-value, and is stored without a type-tag.\n\n``type ...; end``               ``nothing``                     \"Singleton\" :: a Leaf Type or Immutable with no fields.\n\n``(...)`` or ``tuple(...)```    ``(1,2,3)``                     \"Tuple\" :: an immutable data-structure similar to an\n                                                                anonymous immutable type, or a constant array.\n                                                                Represented as either an array or a struct.\n\n``typealias``                   Not applicable here             Type aliases, and other similar mechanisms of\n                                                                doing type indirection, are resolved to their base\n                                                                type (this includes assigning a type to another name,\n                                                                or getting the type out of a function call).\n==============================  ==============================  ======================================================\n\nBits Types:\n~~~~~~~~~~~\n\nThere are several special types to be aware of, as no other type can be defined to behave the same:\n\n``Float32``\n    Exactly corresponds to the ``float`` type in C (or ``REAL*4`` in Fortran).\n\n``Float64``\n    Exactly corresponds to the ``double`` type in C (or ``REAL*8`` in Fortran).\n\n``Complex64``\n    Exactly corresponds to the ``complex float`` type in C (or ``COMPLEX*8`` in Fortran).\n\n``Complex128``\n    Exactly corresponds to the ``complex double`` type in C (or ``COMPLEX*16`` in Fortran).\n\n``Signed``\n    Exactly corresponds to the ``signed`` type annotation in C (or any ``INTEGER`` type in Fortran). Any Julia type that is not a subtype of ``Signed`` is assumed to be unsigned.\n\n``Ref{T}``\n    Behaves like a ``Ptr{T}`` that owns its memory.\n\n``Array{T,N}``\n    When an array is passed to C as a ``Ptr{T}`` argument, it is\n    not reinterpret-cast: Julia requires that the element type of the\n    array matches ``T``, and the address of the first element is passed.\n\n    Therefore, if an ``Array`` contains data in the wrong format, it will\n    have to be explicitly converted using a call such as ``trunc(Int32,a)``.\n\n    To pass an array ``A`` as a pointer of a different type *without*\n    converting the data beforehand (for example, to pass a ``Float64`` array\n    to a function that operates on uninterpreted bytes), you can\n    declare the argument as ``Ptr{Void}``.\n\n    If an array of eltype ``Ptr{T}`` is passed as a ``Ptr{Ptr{T}}`` argument,\n    :func:`Base.cconvert` will attempt to first make a null-terminated copy of the array with\n    each element replaced by its :func:`cconvert` version. This allows, for example, passing an ``argv``\n    pointer array of type ``Vector{String}`` to an argument of type ``Ptr{Ptr{Cchar}}``.\n\nOn all systems we currently support, basic C/C++ value types may be\ntranslated to Julia types as follows. Every C type also has a corresponding\nJulia type with the same name, prefixed by C. This can help for writing portable code (and remembering that an ``int`` in C is not the same as an ``Int`` in Julia).\n\n**System Independent:**\n\n.. rst-class:: text-wrap\n\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| C name                            | Fortran name    | Standard Julia Alias | Julia Base Type                   |\n+===================================+=================+======================+===================================+\n| ``unsigned char``                 | ``CHARACTER``   | ``Cuchar``           | ``UInt8``                         |\n|                                   |                 |                      |                                   |\n| ``bool`` (C++)                    |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``short``                         | ``INTEGER*2``   | ``Cshort``           | ``Int16``                         |\n|                                   |                 |                      |                                   |\n|                                   | ``LOGICAL*2``   |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``unsigned short``                |                 | ``Cushort``          | ``UInt16``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``int``                           | ``INTEGER*4``   | ``Cint``             | ``Int32``                         |\n|                                   |                 |                      |                                   |\n| ``BOOL`` (C, typical)             | ``LOGICAL*4``   |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``unsigned int``                  |                 | ``Cuint``            | ``UInt32``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``long long``                     | ``INTEGER*8``   | ``Clonglong``        | ``Int64``                         |\n|                                   |                 |                      |                                   |\n|                                   | ``LOGICAL*8``   |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``unsigned long long``            |                 | ``Culonglong``       | ``UInt64``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``intmax_t``                      |                 | ``Cintmax_t``        | ``Int64``                         |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``uintmax_t``                     |                 | ``Cuintmax_t``       | ``UInt64``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``float``                         | ``REAL*4i``     | ``Cfloat``           | ``Float32``                       |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``double``                        | ``REAL*8``      | ``Cdouble``          | ``Float64``                       |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``complex float``                 | ``COMPLEX*8``   | ``Complex64``        | ``Complex{Float32}``              |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``complex double``                | ``COMPLEX*16``  | ``Complex128``       | ``Complex{Float64}``              |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``ptrdiff_t``                     |                 | ``Cptrdiff_t``       | ``Int``                           |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``ssize_t``                       |                 | ``Cssize_t``         | ``Int``                           |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``size_t``                        |                 | ``Csize_t``          | ``UInt``                          |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``void``                          |                 |                      | ``Void``                          |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``void`` and                      |                 |                      | ``Union{}``                       |\n| ``[[noreturn]]`` or ``_Noreturn`` |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``void*``                         |                 |                      | ``Ptr{Void}``                     |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``T*`` (where T represents an     |                 |                      | ``Ref{T}``                        |\n| appropriately defined type)       |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``char*``                         | ``CHARACTER*N`` |                      | ``Cstring`` if NUL-terminated, or |\n| (or ``char[]``, e.g. a string)    |                 |                      | ``Ptr{UInt8}`` if not             |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``char**`` (or ``*char[]``)       |                 |                      | ``Ptr{Ptr{UInt8}}``               |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``jl_value_t*``                   |                 |                      | ``Any``                           |\n| (any Julia Type)                  |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``jl_value_t**``                  |                 |                      | ``Ref{Any}``                      |\n| (a reference to a Julia Type)     |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``va_arg``                        |                 |                      | Not supported                     |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``...``                           |                 |                      | ``T...`` (where ``T``             |\n| (variadic function specification) |                 |                      | is one of the above types,        |\n|                                   |                 |                      | variadic functions of different   |\n|                                   |                 |                      | argument types are not supported) |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n\nThe ``Cstring`` type is essentially a synonym for ``Ptr{UInt8}``, except the conversion to ``Cstring`` throws an\nerror if the Julia string contains any embedded NUL characters (which would cause the string to be silently\ntruncated if the C routine treats NUL as the terminator).  If you are passing a ``char*`` to a C routine that\ndoes not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that\nyour Julia string does not contain NUL and want to skip the check, you can use ``Ptr{UInt8}`` as the argument type.\n``Cstring`` can also be used as the :func:`ccall` return type, but in that case it obviously does not introduce any extra\nchecks and is only meant to improve readability of the call.\n\n**System-dependent:**\n\n======================  ======================  =======\nC name                  Standard Julia Alias    Julia Base Type\n======================  ======================  =======\n``char``                ``Cchar``               ``Int8`` (x86, x86_64)\n\n                                                ``UInt8`` (powerpc, arm)\n\n``long``                ``Clong``               ``Int`` (UNIX)\n\n                                                ``Int32`` (Windows)\n\n``unsigned long``       ``Culong``              ``UInt`` (UNIX)\n\n                                                ``UInt32`` (Windows)\n\n``wchar_t``             ``Cwchar_t``            ``Int32`` (UNIX)\n\n                                                ``UInt16`` (Windows)\n======================  ======================  =======\n\n.. note::\n\n    When calling a Fortran function, all inputs must be passed by reference, so\n    all type correspondences above should contain an additional ``Ptr{..}`` or\n    ``Ref{..}`` wrapper around their type specification.\n\n.. warning::\n\n    For string arguments (``char*``) the Julia type should be ``Cstring`` (if NUL-\n    terminated data is expected) or either ``Ptr{Cchar}`` or ``Ptr{UInt8}``\n    otherwise (these two pointer types have the same effect), as described above,\n    not ``String``. Similarly, for array arguments (``T[]`` or ``T*``), the\n    Julia type should again be ``Ptr{T}``, not ``Vector{T}``.\n\n.. warning::\n\n    Julia's ``Char`` type is 32 bits, which is not the same as the wide character\n    type (``wchar_t`` or ``wint_t``) on all platforms.\n\n.. warning::\n\n    A return type of ``Union{}`` means the function will not return\n    i.e. C++11 ``[[noreturn]]`` or C11 ``_Noreturn`` (e.g. ``jl_throw`` or\n    ``longjmp``). Do not use this for functions that return\n    no value (``void``) but do return.\n\n.. note::\n\n    For ``wchar_t*`` arguments, the Julia type should be ``Cwstring`` (if the C\n    routine expects a NUL-terminated string) or ``Ptr{Cwchar_t}`` otherwise. Note\n    also that UTF-8 string data in Julia is internally NUL-terminated, so it can\n    be passed to C functions expecting NUL-terminated data without making a copy\n    (but using the ``Cwstring`` type will cause an error to be thrown if the string\n    itself contains NUL characters).\n\n.. note::\n\n    C functions that take an argument of the type ``char**`` can be called by\n    using a ``Ptr{Ptr{UInt8}}`` type within Julia. For example, C functions of the\n    form::\n\n        int main(int argc, char **argv);\n\n    can be called via the following Julia code::\n\n        argv = [ \"a.out\", \"arg1\", \"arg2\" ]\n        ccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)\n\n.. note::\n\n    A C function declared to return ``Void`` will return the value ``nothing`` in\n    Julia.\n\nStruct Type correspondences\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nComposite types, aka ``struct`` in C or ``TYPE`` in Fortran90\n(or ``STRUCTURE`` / ``RECORD`` in some variants of F77),\ncan be mirrored in Julia by creating a ``type`` or ``immutable``\ndefinition with the same field layout.\n\nWhen used recursively, ``isbits`` types are stored inline.\nAll other types are stored as a pointer to the data.\nWhen mirroring a struct used by-value inside another struct in C,\nit is imperative that you do not attempt to manually copy the fields over,\nas this will not preserve the correct field alignment.\nInstead, declare an immutable ``isbits`` type and use that instead.\nUnnamed structs are not possible in the translation to Julia.\n\nPacked structs and union declarations are not supported by Julia.\n\nYou can get a near approximation of a ``union`` if you know, a priori,\nthe field that will have the greatest size (potentially including padding).\nWhen translating your fields to Julia, declare the Julia field to be only\nof that type.\n\nArrays of parameters must be expanded manually, currently\n(either inline, or in an immutable helper type). For example::\n\n    in C:\n    struct B {\n        int A[3];\n    };\n    b_a_2 = B.A[2];\n\n    in Julia:\n    immutable B_A\n        A_1::Cint\n        A_2::Cint\n        A_3::Cint\n    end\n    type B\n        A::B_A\n    end\n    b_a_2 = B.A.(2)\n\nArrays of unknown size are not supported.\n\nIn the future, some of these restrictions may be reduced or eliminated.\n\nSIMD Values\n~~~~~~~~~~~\n\nNote: This feature is currently implemented on 64-bit x86\nand AArch64 platforms only.\n\nIf a C/C++ routine has an argument or return value that is a native\nSIMD type, the corresponding Julia type is a homogeneous tuple\nof ``VecElement`` that naturally maps to the SIMD type.  Specifically:\n\n    - The tuple must be the same size as the SIMD type.\n      For example, a tuple representing an ``__m128`` on x86\n      must have a size of 16 bytes.\n\n    - The element type of the tuple must be an instance of ``VecElement{T}``\n      where ``T`` is a bitstype that is 1, 2, 4 or 8 bytes.\n\nFor instance, consider this C routine that uses AVX intrinsics::\n\n    #include <immintrin.h>\n\n    __m256 dist( __m256 a, __m256 b ) {\n        return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),\n                                            _mm256_mul_ps(b, b)));\n    }\n\nThe following Julia code calls ``dist`` using ``ccall``::\n\n    typealias m256 NTuple{8,VecElement{Float32}}\n\n    a = m256(ntuple(i->VecElement(sin(Float32(i))),8))\n    b = m256(ntuple(i->VecElement(cos(Float32(i))),8))\n\n    function call_dist(a::m256, b::m256)\n        ccall((:dist, \"libdist\"), m256, (m256, m256), a, b)\n    end\n\n    println(call_dist(a,b))\n\nThe host machine must have the requisite SIMD registers.  For example,\nthe code above will not work on hosts without AVX support.\n\nMemory Ownership\n~~~~~~~~~~~~~~~~\n\n**malloc/free**\n\nMemory allocation and deallocation of such objects must be\nhandled by calls to the appropriate cleanup routines in the libraries\nbeing used, just like in any C program. Do not try to free an object\nreceived from a C library with ``Libc.free`` in Julia, as this may result\nin the ``free`` function being called via the wrong ``libc`` library and\ncause Julia to crash. The reverse (passing an object allocated in Julia\nto be freed by an external library) is equally invalid.\n\nWhen to use T, Ptr{T} and Ref{T}\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn Julia code wrapping calls to external C routines, ordinary (non-pointer)\ndata should be declared to be of type ``T`` inside the :func:`ccall`, as they\nare passed by value.  For C code accepting pointers, ``Ref{T}`` should\ngenerally be used for the types of input arguments, allowing the use of\npointers to memory managed by either Julia or C through the implicit call to\n:func:`cconvert`.  In contrast, pointers returned by the C function called\nshould be declared to be of output type ``Ptr{T}``, reflecting that the memory\npointed to is managed by C only. Pointers contained in C structs should be\nrepresented as fields of type ``Ptr{T}`` within the corresponding Julia\nimmutable types designed to mimic the internal structure of corresponding C\nstructs.\n\nIn Julia code wrapping calls to external Fortran routines, all input arguments\nshould be declared as of type ``Ref{T}``, as Fortran passes all variables by\nreference. The return type should either be ``Void`` for Fortran subroutines,\nor a ``T`` for Fortran functions returning the type ``T``.\n\n\nMapping C Functions to Julia\n----------------------------\n\n``ccall``/``cfunction`` argument translation guide\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor translating a C argument list to Julia:\n\n* ``T``, where ``T`` is one of the primitive types:\n  ``char``, ``int``, ``long``, ``short``, ``float``, ``double``, ``complex``, ``enum``\n  or any of their ``typedef`` equivalents\n\n  + ``T``, where ``T`` is an equivalent Julia Bits Type (per the table above)\n  + if ``T`` is an ``enum``, the argument type should be equivalent to ``Cint`` or ``Cuint``\n  + argument value will be copied (passed by value)\n\n* ``struct T`` (including typedef to a struct)\n\n  + ``T``, where ``T`` is a Julia leaf type\n  + argument value will be copied (passed by value)\n\n* ``void*``\n\n  + depends on how this parameter is used, first translate this to the intended pointer type,\n    then determine the Julia equivalent using the remaining rules in this list\n  + this argument may be declared as ``Ptr{Void}``, if it really is just an unknown pointer\n\n* ``jl_value_t*``\n\n  + ``Any``\n  + argument value must be a valid Julia object\n  + currently unsupported by :func:`cfunction`\n\n* ``jl_value_t**``\n\n  + ``Ref{Any}``\n  + argument value must be a valid Julia object (or ``C_NULL``)\n  + currently unsupported by :func:`cfunction`\n\n* ``T*``\n\n  + ``Ref{T}``, where ``T`` is the Julia type corresponding to ``T``\n  + argument value will be copied if it is an ``isbits`` type\n    otherwise, the value must be a valid Julia object\n\n* ``(T*)(...)`` (e.g. a pointer to a function)\n\n  + ``Ptr{Void}`` (you may need to use :func:`cfunction` explicitly to create this pointer)\n\n* ``...`` (e.g. a vararg)\n\n  + ``T...``, where ``T`` is the Julia type\n\n* ``va_arg``\n\n  + not supported\n\n``ccall``/``cfunction`` return type translation guide\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor translating a C return type to Julia:\n\n* ``void``\n\n  + ``Void`` (this will return the singleton instance ``nothing::Void``)\n\n* ``T``, where ``T`` is one of the primitive types:\n  ``char``, ``int``, ``long``, ``short``, ``float``, ``double``, ``complex``, ``enum``\n  or any of their ``typedef`` equivalents\n\n  + ``T``, where ``T`` is an equivalent Julia Bits Type (per the table above)\n  + if ``T`` is an ``enum``, the argument type should be equivalent to ``Cint`` or ``Cuint``\n  + argument value will be copied (returned by-value)\n\n* ``struct T`` (including typedef to a struct)\n\n  + ``T``, where ``T`` is a Julia Leaf Type\n  + argument value will be copied (returned by-value)\n\n* ``void*``\n\n  + depends on how this parameter is used, first translate this to the intended pointer type,\n    then determine the Julia equivalent using the remaining rules in this list\n  + this argument may be declared as ``Ptr{Void}``, if it really is just an unknown pointer\n\n* ``jl_value_t*``\n\n  + ``Any``\n  + argument value must be a valid Julia object\n\n* ``jl_value_t**``\n\n  + ``Ref{Any}``\n  + argument value must be a valid Julia object (or ``C_NULL``)\n\n* ``T*``\n\n  + If the memory is already owned by Julia, or is an ``isbits`` type, and is known to be non-null:\n\n    + ``Ref{T}``, where ``T`` is the Julia type corresponding to ``T``\n    + a return type of ``Ref{Any}`` is invalid, it should either be ``Any``\n      (corresponding to ``jl_value_t*``) or ``Ptr{Any}`` (corresponding to ``Ptr{Any}``)\n    + C **MUST NOT** modify the memory returned via ``Ref{T}`` if ``T`` is an ``isbits`` type\n\n  + If the memory is owned by C:\n\n    + ``Ptr{T}``, where ``T`` is the Julia type corresponding to ``T``\n\n* ``(T*)(...)`` (e.g. a pointer to a function)\n\n  + ``Ptr{Void}`` (you may need to use :func:`cfunction` explicitly to create this pointer)\n\nPassing Pointers for Modifying Inputs\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBecause C doesn't support multiple return values,\noften C functions will take pointers to data that the function will modify.\nTo accomplish this within a :func:`ccall`,\nyou need to first encapsulate the value inside an ``Ref{T}`` of the appropriate type.\nWhen you pass this ``Ref`` object as an argument,\nJulia will automatically pass a C pointer to the encapsulated data::\n\n    width = Ref{Cint}(0)\n    range = Ref{Cfloat}(0)\n    ccall(:foo, Void, (Ref{Cint}, Ref{Cfloat}), width, range)\n\nUpon return, the contents of ``width`` and ``range`` can be retrieved\n(if they were changed by ``foo``) by ``width[]`` and ``range[]``; that is,\nthey act like zero-dimensional arrays.\n\nSpecial Reference Syntax for ccall (deprecated):\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``&`` syntax is deprecated, use the ``Ref{T}`` argument type instead.\n\nA prefix ``&`` is used on an argument to :func:`ccall` to indicate that a pointer\nto a scalar argument should be passed instead of the scalar value itself\n(required for all Fortran function arguments, as noted above). The following\nexample computes a dot product using a BLAS function.\n\n::\n\n    function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})\n      assert(length(DX) == length(DY))\n      n = length(DX)\n      incx = incy = 1\n      product = ccall((:ddot_, \"libLAPACK\"),\n                      Float64,\n                      (Ptr{Int32}, Ptr{Float64}, Ptr{Int32}, Ptr{Float64}, Ptr{Int32}),\n                      &n, DX, &incx, DY, &incy)\n      return product\n    end\n\nThe meaning of prefix ``&`` is not quite the same as in C. In\nparticular, any changes to the referenced variables will not be\nvisible in Julia unless the type is mutable (declared via\n``type``). However, even for immutable types it will not cause any\nharm for called functions to attempt such modifications (that is,\nwriting through the passed pointers). Moreover, ``&`` may be used with\nany expression, such as ``&0`` or ``&f(x)``.\n\nWhen a scalar value is passed with ``&`` as an argument of type\n``Ptr{T}``, the value will first be converted to type ``T``.\n\nSome Examples of C Wrappers\n---------------------------\n\nHere is a simple example of a C wrapper that returns a ``Ptr`` type::\n\n    type gsl_permutation\n    end\n\n    # The corresponding C signature is\n    #     gsl_permutation * gsl_permutation_alloc (size_t n);\n    function permutation_alloc(n::Integer)\n        output_ptr = ccall(\n            (:gsl_permutation_alloc, :libgsl), #name of C function and library\n            Ptr{gsl_permutation},              #output type\n            (Csize_t,),                        #tuple of input types\n            n                                  #name of Julia variable to pass in\n        )\n        if output_ptr==C_NULL # Could not allocate memory\n            throw(OutOfMemoryError())\n        end\n        return output_ptr\n    end\n\nThe `GNU Scientific Library <https://www.gnu.org/software/gsl/>`_ (here assumed\nto be accessible through ``:libgsl``) defines an opaque pointer,\n``gsl_permutation *``, as the return type of the C function\n``gsl_permutation_alloc()``. As user code never has to look inside the\n``gsl_permutation`` struct, the corresponding Julia wrapper simply needs a new\ntype declaration, ``gsl_permutation``, that has no internal fields and whose\nsole purpose is to be placed in the type parameter of a ``Ptr`` type.  The\nreturn type of the :func:`ccall` is declared as ``Ptr{gsl_permutation}``, since the\nmemory allocated and pointed to by ``output_ptr`` is controlled by C (and not\nJulia).\n\nThe input ``n`` is passed by value, and so the function's input signature is\nsimply declared as ``(Csize_t,)`` without any ``Ref`` or ``Ptr`` necessary.\n(If the wrapper was calling a Fortran function instead, the corresponding\nfunction input signature should instead be ``(Ref{Csize_t},)``, since Fortran\nvariables are passed by reference.) Furthermore, ``n`` can be any type that is\nconvertable to a ``Csize_t`` integer; the :func:`ccall` implicitly calls\n:func:`Base.cconvert(Csize_t, n) <cconvert>`.\n\n\nHere is a second example wrapping the corresponding destructor::\n\n    # The corresponding C signature is\n    #     void gsl_permutation_free (gsl_permutation * p);\n    function permutation_free(p::Ref{gsl_permutation})\n        ccall(\n            (:gsl_permutation_free, :libgsl), #name of C function and library\n            Void,                             #output type\n            (Ref{gsl_permutation},),          #tuple of input types\n            p                                 #name of Julia variable to pass in\n        )\n    end\n\nHere, the input ``p`` is declared to be of type ``Ref{gsl_permutation}``,\nmeaning that the memory that ``p`` points to may be managed by Julia or by C.\nA pointer to memory allocated by C should be of type ``Ptr{gsl_permutation}``,\nbut it is convertable using :func:`cconvert` and therefore can be used in the\nsame (covariant) context of the input argument to a :func:`ccall`. A pointer to\nmemory allocated by Julia must be of type ``Ref{gsl_permutation}``, to ensure\nthat the memory address pointed to is valid and that Julia's garbage collector\nmanages the chunk of memory pointed to correctly. Therefore, the\n``Ref{gsl_permutation}`` declaration allows pointers managed by C or Julia to\nbe used.\n\nIf the C wrapper never expects the user to pass pointers to memory managed by\nJulia, then using ``p::Ptr{gsl_permutation}`` for the method signature of the\nwrapper and similarly in the :func:`ccall` is also acceptable.\n\n\nHere is a third example passing Julia arrays::\n\n    # The corresponding C signature is\n    #    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,\n    #                                double result_array[])\n    function sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)\n        if nmax<nmin throw(DomainError()) end\n        result_array = Array{Cdouble}(nmax-nmin+1)\n        errorcode = ccall(\n            (:gsl_sf_bessel_Jn_array, :libgsl), #name of C function and library\n            Cint,                               #output type\n            (Cint, Cint, Cdouble, Ref{Cdouble}),#tuple of input types\n            nmin, nmax, x, result_array         #names of Julia variables to pass in\n        )\n        if errorcode!= 0 error(\"GSL error code $errorcode\") end\n        return result_array\n    end\n\nThe C function wrapped returns an integer error code; the results of the actual\nevaluation of the Bessel J function populate the Julia array ``result_array``.\nThis variable can only be used with corresponding input type declaration\n``Ref{Cdouble}``, since its memory is allocated and managed by\nJulia, not C. The implicit call to :func:`Base.cconvert(Ref{Cdouble},\nresult_array) <cconvert>` unpacks the Julia pointer to a Julia array data\nstructure into a form understandable by C.\n\nNote that for this code to work correctly, ``result_array`` must be declared to\nbe of type ``Ref{Cdouble}`` and not ``Ptr{Cdouble}``. The memory is managed by\nJulia and the ``Ref`` signature alerts Julia's garbage collector to keep\nmanaging the memory for ``result_array`` while the :func:`ccall` executes. If\n``Ptr{Cdouble}`` were used instead, the :func:`ccall` may still work, but\nJulia's garbage collector would not be aware that the memory declared for\n``result_array`` is being used by the external C function. As a result, the\ncode may produce a memory leak if ``result_array`` never gets freed by the\ngarbage collector, or if the garbage collector prematurely frees\n``result_array``, the C function may end up throwing an invalid memory access\nexception.\n\n\n\nGarbage Collection Safety\n-------------------------\nWhen passing data to a :func:`ccall`, it is best to avoid using the :func:`pointer`\nfunction. Instead define a convert method and pass the variables directly to\nthe :func:`ccall`. :func:`ccall` automatically arranges that all of its arguments will be\npreserved from garbage collection until the call returns. If a C API will\nstore a reference to memory allocated by Julia, after the :func:`ccall` returns, you\nmust arrange that the object remains visible to the garbage collector. The\nsuggested way to handle this is to make a global variable of type\n``Array{Ref,1}`` to hold these values, until the C library notifies you that\nit is finished with them.\n\nWhenever you have created a pointer to Julia data, you must ensure the original data\nexists until you are done with using the pointer. Many methods in Julia such as\n:func:`unsafe_load` and :func:`String` make copies of data instead of taking ownership\nof the buffer, so that it is safe to free (or alter) the original data without\naffecting Julia. A notable exception is :func:`unsafe_wrap` which, for performance\nreasons, shares (or can be told to take ownership of) the underlying buffer.\n\nThe garbage collector does not guarantee any order of finalization. That is, if ``a``\ncontained a reference to ``b`` and both ``a`` and ``b`` are due for garbage\ncollection, there is no guarantee that ``b`` would be finalized after ``a``. If\nproper finalization of ``a`` depends on ``b`` being valid, it must be handled in\nother ways.\n\n\nNon-constant Function Specifications\n------------------------------------\n\nA ``(name, library)`` function specification must be a constant expression.\nHowever, it is possible to use computed values as function names by staging\nthrough ``eval`` as follows::\n\n    @eval ccall(($(string(\"a\",\"b\")),\"lib\"), ...\n\nThis expression constructs a name using ``string``, then substitutes this\nname into a new :func:`ccall` expression, which is then evaluated. Keep in mind that\n``eval`` only operates at the top level, so within this expression local\nvariables will not be available (unless their values are substituted with\n``$``). For this reason, ``eval`` is typically only used to form top-level\ndefinitions, for example when wrapping libraries that contain many\nsimilar functions.\n\nIf your usage is more dynamic, use indirect calls as described in the next section.\n\n\nIndirect Calls\n--------------\n\nThe first argument to :func:`ccall` can also be an expression evaluated at run time.\nIn this case, the expression must evaluate to a ``Ptr``,\nwhich will be used as the address of the native function to call.\nThis behavior occurs when the first :func:`ccall` argument contains references to non-constants,\nsuch as local variables, function arguments, or non-constant globals.\n\nFor example, you might lookup the function via ``dlsym``,\nthen cache it in a global variable for that session. For example::\n\n    macro dlsym(func, lib)\n        z, zlocal = gensym(string(func)), gensym()\n        eval(current_module(),:(global $z = C_NULL))\n        z = esc(z)\n        quote\n            let $zlocal::Ptr{Void} = $z::Ptr{Void}\n                if $zlocal == C_NULL\n                   $zlocal = dlsym($(esc(lib))::Ptr{Void}, $(esc(func)))\n                   global $z = $zlocal\n                end\n                $zlocal\n            end\n        end\n    end\n\n    mylibvar = dlopen(\"mylib\")\n    ccall(@dlsym(\"myfunc\", mylibvar), Void, ())\n\n\nCalling Convention\n------------------\n\nThe second argument to :func:`ccall` can optionally be a calling convention\nspecifier (immediately preceding return type). Without any specifier,\nthe platform-default C calling convention is used. Other supported\nconventions are: ``stdcall``, ``cdecl``, ``fastcall``, and ``thiscall``.\nFor example (from ``base/libc.jl``) we see the same ``gethostname`` :func:`ccall` as above,\nbut with the correct signature for Windows::\n\n    hn = Array{UInt8}(256)\n    err = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))\n\nFor more information, please see the `LLVM Language Reference`_.\n\n.. _LLVM Language Reference: http://llvm.org/docs/LangRef.html#calling-conventions\n\n\nAccessing Global Variables\n--------------------------\n\nGlobal variables exported by native libraries can be accessed by name using the\n:func:`cglobal` function. The arguments to :func:`cglobal` are a symbol specification\nidentical to that used by :func:`ccall`, and a type describing the value stored in\nthe variable::\n\n    julia> cglobal((:errno,:libc), Int32)\n    Ptr{Int32} @0x00007f418d0816b8\n\nThe result is a pointer giving the address of the value. The value can be\nmanipulated through this pointer using :func:`unsafe_load` and :func:`unsafe_store!`.\n\n\nAccessing Data through a Pointer\n--------------------------------\nThe following methods are described as \"unsafe\" because a bad pointer\nor type declaration can cause Julia to terminate abruptly.\n\nGiven a ``Ptr{T}``, the contents of type ``T`` can generally be copied from\nthe referenced memory into a Julia object using ``unsafe_load(ptr, [index])``.\nThe index argument is optional (default is 1),\nand follows the Julia-convention of 1-based indexing.\nThis function is intentionally similar to the behavior of :func:`getindex` and :func:`setindex!`\n(e.g. ``[]`` access syntax).\n\nThe return value will be a new object initialized\nto contain a copy of the contents of the referenced memory.\nThe referenced memory can safely be freed or released.\n\nIf ``T`` is ``Any``, then the memory is assumed to contain a reference to\na Julia object (a ``jl_value_t*``), the result will be a reference to this object,\nand the object will not be copied. You must be careful in this case to ensure\nthat the object was always visible to the garbage collector (pointers do not\ncount, but the new reference does) to ensure the memory is not prematurely freed.\nNote that if the object was not originally allocated by Julia, the new object\nwill never be finalized by Julia's garbage collector.  If the ``Ptr`` itself\nis actually a ``jl_value_t*``, it can be converted back to a Julia object\nreference by :func:`unsafe_pointer_to_objref(ptr) <unsafe_pointer_to_objref>`.\n(Julia values ``v`` can be converted to ``jl_value_t*`` pointers, as\n``Ptr{Void}``, by calling :func:`pointer_from_objref(v)\n<pointer_from_objref>`.)\n\nThe reverse operation (writing data to a ``Ptr{T}``), can be performed using\n:func:`unsafe_store!(ptr, value, [index]) <unsafe_store!>`.  Currently, this is only supported\nfor bitstypes or other pointer-free (``isbits``) immutable types.\n\nAny operation that throws an error is probably currently unimplemented\nand should be posted as a bug so that it can be resolved.\n\nIf the pointer of interest is a plain-data array (bitstype or immutable), the\nfunction :func:`unsafe_wrap(Array, ptr,dims,[own]) <unsafe_wrap>` may be\nmore useful. The final parameter should be true if Julia should \"take\nownership\" of the underlying buffer and call ``free(ptr)`` when the returned\n``Array`` object is finalized.  If the ``own`` parameter is omitted or false,\nthe caller must ensure the buffer remains in existence until all access is\ncomplete.\n\nArithmetic on the ``Ptr`` type in Julia (e.g. using ``+``) does not behave the\nsame as C's pointer arithmetic. Adding an integer to a ``Ptr`` in Julia always\nmoves the pointer by some number of *bytes*, not elements. This way, the\naddress values obtained from pointer arithmetic do not depend on the\nelement types of pointers.\n\n\nThread-safety\n-------------\n\nSome C libraries execute their callbacks from a different thread, and\nsince Julia isn't thread-safe you'll need to take some extra\nprecautions. In particular, you'll need to set up a two-layered\nsystem: the C callback should only *schedule* (via Julia's event loop)\nthe execution of your \"real\" callback.\nTo do this, create a ``AsyncCondition`` object and wait on it::\n\n  cond = Base.AsyncCondition()\n  wait(cond)\n\nThe callback you pass to C should only execute a :func:`ccall` to\n``:uv_async_send``, passing ``cb.handle`` as the argument,\ntaking care to avoid any allocations or other interactions with the Julia runtime.\n\nNote that events may be coalesced, so multiple calls to uv_async_send\nmay result in a single wakeup notification to the condition.\n\nMore About Callbacks\n--------------------\n\nFor more details on how to pass callbacks to C libraries, see this\n`blog post <http://julialang.org/blog/2013/05/callback>`_.\n\nC++\n---\n\nLimited support for C++ is provided by the `Cpp <https://github.com/timholy/Cpp.jl>`_,\n`Clang <https://github.com/ihnorton/Clang.jl>`_, and `Cxx <https://github.com/Keno/Cxx.jl>`_ packages.\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/stdlib/libdl.html": "\n\n<!DOCTYPE html>\n<!--[if IE 8]><html class=\"no-js lt-ie9\" lang=\"en\" > <![endif]-->\n<!--[if gt IE 8]><!--> <html class=\"no-js\" lang=\"en\" > <!--<![endif]-->\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  \n  <title>Dynamic Linker &mdash; Julia Language 0.5.1 documentation</title>\n  \n\n  \n  \n\n  \n  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>\n\n  \n  \n    \n\n  \n\n  \n  \n    <link rel=\"stylesheet\" href=\"../_static/julia.css\" type=\"text/css\" />\n  \n\n  \n    <link rel=\"stylesheet\" href=\"../_static/julia.css\" type=\"text/css\" />\n  \n    <link rel=\"top\" title=\"Julia Language 0.5.1 documentation\" href=\"../index.html\"/>\n        <link rel=\"next\" title=\"Profiling\" href=\"profile.html\"/>\n        <link rel=\"prev\" title=\"C Standard Library\" href=\"libc.html\"/> \n\n  \n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js\"></script>\n\n</head>\n\n<body class=\"wy-body-for-nav\" role=\"document\">\n\n  <div class=\"wy-grid-for-nav\">\n\n    \n    <nav data-toggle=\"wy-nav-shift\" class=\"wy-nav-side\">\n      <div class=\"wy-side-nav-search\">\n        <a href=\"http://julialang.org/\"><img src=\"../_static/julia-logo.svg\" class=\"logo\"></a>\n        <!--\n        <a href=\"../index.html\" class=\"fa fa-home\"> Julia Language</a>\n        -->\n        <div role=\"search\">\n  <form id =\"rtd-search-form\" class=\"wy-form\" action=\"../search.html\" method=\"get\">\n    <input type=\"text\" name=\"q\" placeholder=\"Search docs\" />\n    <input type=\"hidden\" name=\"check_keywords\" value=\"yes\" />\n    <input type=\"hidden\" name=\"area\" value=\"default\" />\n  </form>\n</div>\n      </div>\n\n      <div class=\"wy-menu wy-menu-vertical\" data-spy=\"affix\" role=\"navigation\" aria-label=\"main navigation\">\n        \n        \n            <ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/introduction.html\">Introduction</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/getting-started.html\">Getting Started</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/getting-started.html#resources\">Resources</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/variables.html\">Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables.html#allowed-variable-names\">Allowed Variable Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables.html#stylistic-conventions\">Stylistic Conventions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html\">Integers and Floating-Point Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#integers\">Integers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#floating-point-numbers\">Floating-Point Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#arbitrary-precision-arithmetic\">Arbitrary Precision Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#numeric-literal-coefficients\">Numeric Literal Coefficients</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#literal-zero-and-one\">Literal zero and one</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html\">Mathematical Operations and Elementary Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#arithmetic-operators\">Arithmetic Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#bitwise-operators\">Bitwise Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#updating-operators\">Updating operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#numeric-comparisons\">Numeric Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#numerical-conversions\">Numerical Conversions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/complex-and-rational-numbers.html\">Complex and Rational Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/complex-and-rational-numbers.html#complex-numbers\">Complex Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/complex-and-rational-numbers.html#rational-numbers\">Rational Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/strings.html\">Strings</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#characters\">Characters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#string-basics\">String Basics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#unicode-and-utf-8\">Unicode and UTF-8</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#triple-quoted-string-literals\">Triple-Quoted String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#common-operations\">Common Operations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#regular-expressions\">Regular Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#id2\">Byte Array Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#version-number-literals\">Version Number Literals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/functions.html\">Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#argument-passing-behavior\">Argument Passing Behavior</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#the-return-keyword\">The <code class=\"docutils literal\"><span class=\"pre\">return</span></code> Keyword</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#operators-are-functions\">Operators Are Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#operators-with-special-names\">Operators With Special Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#anonymous-functions\">Anonymous Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#multiple-return-values\">Multiple Return Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#varargs-functions\">Varargs Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#optional-arguments\">Optional Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#keyword-arguments\">Keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#evaluation-scope-of-default-values\">Evaluation Scope of Default Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#do-block-syntax-for-function-arguments\">Do-Block Syntax for Function Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#dot-syntax-for-vectorizing-functions\">Dot Syntax for Vectorizing Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#further-reading\">Further Reading</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/control-flow.html\">Control Flow</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#compound-expressions\">Compound Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#conditional-evaluation\">Conditional Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#short-circuit-evaluation\">Short-Circuit Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#repeated-evaluation-loops\">Repeated Evaluation: Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#exception-handling\">Exception Handling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#tasks-aka-coroutines\">Tasks (aka Coroutines)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/variables-and-scoping.html\">Scope of Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables-and-scoping.html#global-scope\">Global Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables-and-scoping.html#local-scope\">Local Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables-and-scoping.html#constants\">Constants</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/types.html\">Types</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#type-declarations\">Type Declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#abstract-types\">Abstract Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#bits-types\">Bits Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#composite-types\">Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#immutable-composite-types\">Immutable Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#declared-types\">Declared Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#type-unions\">Type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#man-parametric-types\">Parametric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#type-aliases\">Type Aliases</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#operations-on-types\">Operations on Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#custom-pretty-printing\">Custom pretty-printing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#value-types\">&#8220;Value types&#8221;</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#nullable-types-representing-missing-values\">Nullable Types: Representing Missing Values</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/methods.html\">Methods</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#defining-methods\">Defining Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#method-ambiguities\">Method Ambiguities</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#parametric-methods\">Parametric Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#parametrically-constrained-varargs-methods\">Parametrically-constrained Varargs methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#note-on-optional-and-keyword-arguments\">Note on Optional and keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#function-like-objects\">Function-like objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#empty-generic-functions\">Empty generic functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/constructors.html\">Constructors</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#outer-constructor-methods\">Outer Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#inner-constructor-methods\">Inner Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#incomplete-initialization\">Incomplete Initialization</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#parametric-constructors\">Parametric Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#case-study-rational\">Case Study: Rational</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#constructors-and-conversion\">Constructors and Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#outer-only-constructors\">Outer-only constructors</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/conversion-and-promotion.html\">Conversion and Promotion</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/conversion-and-promotion.html#conversion\">Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/conversion-and-promotion.html#promotion\">Promotion</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/interfaces.html\">Interfaces</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interfaces.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interfaces.html#indexing\">Indexing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interfaces.html#abstract-arrays\">Abstract Arrays</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/modules.html\">Modules</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/modules.html#summary-of-module-usage\">Summary of module usage</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/documentation.html\">Documentation</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#accessing-documentation\">Accessing Documentation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#functions-methods\">Functions &amp; Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#advanced-usage\">Advanced Usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#syntax-guide\">Syntax Guide</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#markdown-syntax\">Markdown syntax</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#markdown-syntax-extensions\">Markdown Syntax Extensions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html\">Metaprogramming</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#program-representation\">Program representation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#expressions-and-evaluation\">Expressions and evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#macros\">Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#code-generation\">Code Generation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#generated-functions\">Generated functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/arrays.html\">Multi-dimensional Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/arrays.html#arrays\">Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/arrays.html#sparse-matrices\">Sparse Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/linear-algebra.html\">Linear algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/linear-algebra.html#matrix-factorizations\">Matrix factorizations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/linear-algebra.html#special-matrices\">Special matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html\">Networking and Streams</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#basic-stream-i-o\">Basic Stream I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#io-output-contextual-properties\">IO Output Contextual Properties</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#working-with-files\">Working with Files</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#a-simple-tcp-example\">A simple TCP example</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#resolving-ip-addresses\">Resolving IP Addresses</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html\">Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#code-availability-and-loading-packages\">Code Availability and Loading Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#data-movement\">Data Movement</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#parallel-map-and-loops\">Parallel Map and Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#synchronization-with-remote-references\">Synchronization With Remote References</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#scheduling\">Scheduling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#channels\">Channels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#remote-references-and-abstractchannels\">Remote references and AbstractChannels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#remote-references-and-distributed-garbage-collection\">Remote References and Distributed Garbage Collection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#id2\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#shared-arrays-and-distributed-garbage-collection\">Shared Arrays and Distributed Garbage Collection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#clustermanagers\">ClusterManagers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#cluster-managers-with-custom-transports\">Cluster Managers with custom transports</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#network-requirements-for-localmanager-and-sshmanager\">Network requirements for LocalManager and SSHManager</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#cluster-cookie\">Cluster cookie</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#specifying-network-topology-experimental\">Specifying network topology (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#multi-threading-experimental\">Multi-threading (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#threadcall-experimental\">&#64;threadcall (Experimental)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/dates.html\">Date and DateTime</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#durations-comparisons\">Durations/Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#accessor-functions\">Accessor Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#query-functions\">Query Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#timetype-period-arithmetic\">TimeType-Period Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#adjuster-functions\">Adjuster Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#period-types\">Period Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#rounding\">Rounding</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/running-external-programs.html\">Running External Programs</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/running-external-programs.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/running-external-programs.html#quoting\">Quoting</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/running-external-programs.html#pipelines\">Pipelines</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html\">Calling C and Fortran Code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#creating-c-compatible-julia-function-pointers\">Creating C-Compatible Julia Function Pointers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#mapping-c-types-to-julia\">Mapping C Types to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#mapping-c-functions-to-julia\">Mapping C Functions to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#some-examples-of-c-wrappers\">Some Examples of C Wrappers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#garbage-collection-safety\">Garbage Collection Safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#non-constant-function-specifications\">Non-constant Function Specifications</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#indirect-calls\">Indirect Calls</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#calling-convention\">Calling Convention</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#accessing-global-variables\">Accessing Global Variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#accessing-data-through-a-pointer\">Accessing Data through a Pointer</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#thread-safety\">Thread-safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#more-about-callbacks\">More About Callbacks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#c\">C++</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/handling-operating-system-variation.html\">Handling Operating System Variation</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html\">Interacting With Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html#the-different-prompt-modes\">The different prompt modes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html#key-bindings\">Key bindings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html#tab-completion\">Tab completion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html#customizing-colors\">Customizing Colors</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/embedding.html\">Embedding Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#high-level-embedding\">High-Level Embedding</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#converting-types\">Converting Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#calling-julia-functions\">Calling Julia Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#memory-management\">Memory Management</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#working-with-arrays\">Working with Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#exceptions\">Exceptions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/packages.html\">Packages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#package-status\">Package Status</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#adding-and-removing-packages\">Adding and Removing Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#offline-installation-of-packages\">Offline Installation of Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#installing-unregistered-packages\">Installing Unregistered Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#updating-packages\">Updating Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#checkout-pin-and-free\">Checkout, Pin and Free</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#custom-metadata-repository\">Custom METADATA Repository</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/packages.html#package-development\">Package Development</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#initial-setup\">Initial Setup</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#making-changes-to-an-existing-package\">Making changes to an existing package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#creating-a-new-package\">Creating a new Package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#fixing-package-requirements\">Fixing Package Requirements</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#man-package-requirements\">Requirements Specification</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/profile.html\">Profiling</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/profile.html#basic-usage\">Basic usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/profile.html#accumulation-and-clearing\">Accumulation and clearing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/profile.html#options-for-controlling-the-display-of-profile-results\">Options for controlling the display of profile results</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/profile.html#configuration\">Configuration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/profile.html#memory-allocation-analysis\">Memory allocation analysis</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/stacktraces.html\">Stack Traces</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/stacktraces.html#viewing-a-stack-trace\">Viewing a stack trace</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/stacktraces.html#extracting-useful-information\">Extracting useful information</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/stacktraces.html#error-handling\">Error handling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/stacktraces.html#comparison-with-backtrace\">Comparison with <code class=\"docutils literal\"><span class=\"pre\">backtrace()</span></code></a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/performance-tips.html\">Performance Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#avoid-global-variables\">Avoid global variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#measure-performance-with-time-and-pay-attention-to-memory-allocation\">Measure performance with <code class=\"docutils literal\"><span class=\"pre\">&#64;time</span></code> and pay attention to memory allocation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#tools\">Tools</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#avoid-containers-with-abstract-type-parameters\">Avoid containers with abstract type parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#type-declarations\">Type declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#break-functions-into-multiple-definitions\">Break functions into multiple definitions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#write-type-stable-functions\">Write &#8220;type-stable&#8221; functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#avoid-changing-the-type-of-a-variable\">Avoid changing the type of a variable</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#separate-kernel-functions-aka-function-barriers\">Separate kernel functions (aka, function barriers)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#types-with-values-as-parameters\">Types with values-as-parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#the-dangers-of-abusing-multiple-dispatch-aka-more-on-types-with-values-as-parameters\">The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#access-arrays-in-memory-order-along-columns\">Access arrays in memory order, along columns</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#pre-allocating-outputs\">Pre-allocating outputs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#avoid-string-interpolation-for-i-o\">Avoid string interpolation for I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#optimize-network-i-o-during-parallel-execution\">Optimize network I/O during parallel execution</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#fix-deprecation-warnings\">Fix deprecation warnings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#tweaks\">Tweaks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#performance-annotations\">Performance Annotations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#treat-subnormal-numbers-as-zeros\">Treat Subnormal Numbers as Zeros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#code-warntype\"><code class=\"docutils literal\"><span class=\"pre\">&#64;code_warntype</span></code></a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/workflow-tips.html\">Workflow Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/workflow-tips.html#repl-based-workflow\">REPL-based workflow</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/workflow-tips.html#browser-based-workflow\">Browser-based workflow</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/style-guide.html\">Style Guide</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#write-functions-not-just-scripts\">Write functions, not just scripts</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-writing-overly-specific-types\">Avoid writing overly-specific types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#handle-excess-argument-diversity-in-the-caller\">Handle excess argument diversity in the caller</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#append-to-names-of-functions-that-modify-their-arguments\">Append <code class=\"docutils literal\"><span class=\"pre\">!</span></code> to names of functions that modify their arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-strange-type-unions\">Avoid strange type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-type-unions-in-fields\">Avoid type Unions in fields</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-elaborate-container-types\">Avoid elaborate container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#use-naming-conventions-consistent-with-julia-s-base\">Use naming conventions consistent with Julia&#8217;s <code class=\"docutils literal\"><span class=\"pre\">base/</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-overuse-try-catch\">Don&#8217;t overuse try-catch</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-parenthesize-conditions\">Don&#8217;t parenthesize conditions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-overuse\">Don&#8217;t overuse ...</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-use-unnecessary-static-parameters\">Don&#8217;t use unnecessary static parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-confusion-about-whether-something-is-an-instance-or-a-type\">Avoid confusion about whether something is an instance or a type</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-overuse-macros\">Don&#8217;t overuse macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-expose-unsafe-operations-at-the-interface-level\">Don&#8217;t expose unsafe operations at the interface level</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-overload-methods-of-base-container-types\">Don&#8217;t overload methods of base container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#be-careful-with-type-equality\">Be careful with type equality</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#do-not-write-x-f-x\">Do not write <code class=\"docutils literal\"><span class=\"pre\">x-&gt;f(x)</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible\">Avoid using floats for numeric literals in generic code when possible</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/faq.html\">Frequently Asked Questions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#sessions-and-the-repl\">Sessions and the REPL</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#functions\">Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#types-type-declarations-and-constructors\">Types, type declarations, and constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#packages-and-modules\">Packages and Modules</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#nothingness-and-missing-values\">Nothingness and missing values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#memory\">Memory</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#asynchronous-io-and-concurrent-synchronous-writes\">Asynchronous IO and concurrent synchronous writes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#julia-releases\">Julia Releases</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html\">Noteworthy Differences from other Languages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html#noteworthy-differences-from-matlab\">Noteworthy differences from MATLAB</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html#noteworthy-differences-from-r\">Noteworthy differences from R</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html#noteworthy-differences-from-python\">Noteworthy differences from Python</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html#noteworthy-differences-from-c-c\">Noteworthy differences from C/C++</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/unicode-input.html\">Unicode Input</a></li>\n</ul>\n<ul class=\"current\">\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"base.html\">Essentials</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#introduction\">Introduction</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#getting-around\">Getting Around</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#all-objects\">All Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#types\">Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#generic-functions\">Generic Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#syntax\">Syntax</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#nullables\">Nullables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#system\">System</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#errors\">Errors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#events\">Events</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#reflection\">Reflection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#internals\">Internals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"collections.html\">Collections and Data Structures</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#general-collections\">General Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#iterable-collections\">Iterable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#indexable-collections\">Indexable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#associative-collections\">Associative Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#set-like-collections\">Set-Like Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#dequeues\">Dequeues</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#priorityqueue\">PriorityQueue</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#heap-functions\">Heap Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"math.html\">Mathematics</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#mathematical-operators\">Mathematical Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#mathematical-functions\">Mathematical Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#statistics\">Statistics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#signal-processing\">Signal Processing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#numerical-integration\">Numerical Integration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"numbers.html\">Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#standard-numeric-types\">Standard Numeric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#data-formats\">Data Formats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#general-number-functions-and-constants\">General Number Functions and Constants</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#bigfloats\">BigFloats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#random-numbers\">Random Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"strings.html\">Strings</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"arrays.html\">Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#basic-functions\">Basic functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#mathematical-operators-and-functions\">Mathematical operators and functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#indexing-assignment-and-concatenation\">Indexing, Assignment, and Concatenation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#array-functions\">Array functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#combinatorics\">Combinatorics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#bitarrays\">BitArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#sparse-vectors-and-matrices\">Sparse Vectors and Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"parallel.html\">Tasks and Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#tasks\">Tasks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#general-parallel-computing-support\">General Parallel Computing Support</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#shared-arrays\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#multi-threading\">Multi-Threading</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#ccall-using-a-threadpool-experimental\">ccall using a threadpool (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#synchronization-primitives\">Synchronization Primitives</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#cluster-manager-interface\">Cluster Manager Interface</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"linalg.html\">Linear Algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linalg.html#module-Base.LinAlg\">Standard Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linalg.html#low-level-matrix-operations\">Low-level matrix operations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linalg.html#module-Base.LinAlg.BLAS\">BLAS Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linalg.html#module-Base.LinAlg.LAPACK\">LAPACK Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"constants.html\">Constants</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"file.html\">Filesystem</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"io-network.html\">I/O and Network</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#general-i-o\">General I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#multimedia-i-o\">Multimedia I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#memory-mapped-i-o\">Memory-mapped I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#network-i-o\">Network I/O</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"punctuation.html\">Punctuation</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"sort.html\">Sorting and Related Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sort.html#sorting-functions\">Sorting Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sort.html#order-related-functions\">Order-Related Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sort.html#sorting-algorithms\">Sorting Algorithms</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"pkg.html\">Package Manager Functions</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"dates.html\">Dates and Time</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#dates-and-time-types\">Dates and Time Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#dates-functions\">Dates Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"test.html\">Unit Testing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#testing-base-julia\">Testing Base Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#basic-unit-tests\">Basic Unit Tests</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#working-with-test-sets\">Working with Test Sets</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#other-test-macros\">Other Test Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#broken-tests\">Broken Tests</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#creating-custom-abstracttestset-types\">Creating Custom <code class=\"docutils literal\"><span class=\"pre\">AbstractTestSet</span></code> Types</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"c.html\">C Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"c.html#llvm-interface\">LLVM Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"libc.html\">C Standard Library</a></li>\n<li class=\"toctree-l1 current\"><a class=\"current reference internal\" href=\"#\">Dynamic Linker</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"profile.html\">Profiling</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stacktraces.html\">StackTraces</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"simd-types.html\">SIMD Support</a></li>\n</ul>\n<ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/reflection.html\">Reflection and introspection</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/julia.html\">Documentation of Julia&#8217;s Internals</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/init.html\">Initialization of the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/eval.html\">Eval of Julia code</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/ast.html\">Julia ASTs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/types.html\">More about types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/object.html\">Memory layout of Julia Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/functions.html\">Julia Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/callconv.html\">Calling Conventions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/cartesian.html\">Base.Cartesian</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/meta.html\">Talking to the compiler (the <code class=\"docutils literal\"><span class=\"pre\">:meta</span></code> mechanism)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/subarrays.html\">SubArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/sysimg.html\">System Image Building</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/llvm.html\">Working with LLVM</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/stdio.html\">printf() and stdio in the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/boundscheck.html\">Bounds checking</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/locks.html\">Proper maintenance and care of multi-threading locks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/offset-arrays.html\">Arrays with custom indices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/C.html\">Developing/debugging Julia&#8217;s C code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/backtraces.html\">Reporting and analyzing crashes (segfaults)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/debuggingtips.html\">gdb debugging tips</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/valgrind.html\">Using Valgrind with Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/sanitizers.html\">Sanitizer support</a></li>\n</ul>\n</li>\n</ul>\n\n        \n      </div>\n      &nbsp;\n    </nav>\n\n    <section data-toggle=\"wy-nav-shift\" class=\"wy-nav-content-wrap\">\n\n      \n      <nav class=\"wy-nav-top\" role=\"navigation\" aria-label=\"top navigation\">\n        <i data-toggle=\"wy-nav-top\" class=\"fa fa-bars\"></i>\n        <a href=\"../index.html\">Julia Language</a>\n      </nav>\n\n\n      \n      <div class=\"wy-nav-content\">\n        <div class=\"rst-content\">\n          <div role=\"navigation\" aria-label=\"breadcrumbs navigation\">\n  <ul class=\"wy-breadcrumbs\">\n    <li><a href=\"../index.html\">Docs</a> &raquo;</li>\n      \n    <li>Dynamic Linker</li>\n      <li class=\"wy-breadcrumbs-aside\">\n        \n          <a href=\"../_sources/stdlib/libdl.txt\" rel=\"nofollow\"> View page source</a>\n        \n      </li>\n  </ul>\n  <hr/>\n</div>\n          <div role=\"main\" class=\"document\">\n            \n  <span class=\"target\" id=\"module-Libdl\"></span><div class=\"section\" id=\"dynamic-linker\">\n<h1>Dynamic Linker<a class=\"headerlink\" href=\"#dynamic-linker\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<p>The names in <code class=\"xref jl jl-mod docutils literal\"><span class=\"pre\">Base.Libdl</span></code> are not exported and need to be called e.g. as <code class=\"docutils literal\"><span class=\"pre\">Libdl.dlopen()</span></code>.</p>\n<dl class=\"function\">\n<dt id=\"Base.Libdl.dlopen\">\n<code class=\"descname\">dlopen</code><span class=\"sig-paren\">(</span><em>libfile::AbstractString</em><span class=\"optional\">[</span>, <em>flags::Integer</em><span class=\"optional\">]</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.Libdl.dlopen\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Load a shared library, returning an opaque handle.</p>\n<p>The optional flags argument is a bitwise-or of zero or more of <code class=\"docutils literal\"><span class=\"pre\">RTLD_LOCAL</span></code>, <code class=\"docutils literal\"><span class=\"pre\">RTLD_GLOBAL</span></code>, <code class=\"docutils literal\"><span class=\"pre\">RTLD_LAZY</span></code>, <code class=\"docutils literal\"><span class=\"pre\">RTLD_NOW</span></code>, <code class=\"docutils literal\"><span class=\"pre\">RTLD_NODELETE</span></code>, <code class=\"docutils literal\"><span class=\"pre\">RTLD_NOLOAD</span></code>, <code class=\"docutils literal\"><span class=\"pre\">RTLD_DEEPBIND</span></code>, and <code class=\"docutils literal\"><span class=\"pre\">RTLD_FIRST</span></code>. These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default <code class=\"docutils literal\"><span class=\"pre\">dlopen</span></code> flags are <code class=\"docutils literal\"><span class=\"pre\">RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL</span></code> while on other platforms the defaults are <code class=\"docutils literal\"><span class=\"pre\">RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL</span></code>. An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance <code class=\"docutils literal\"><span class=\"pre\">RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL</span></code> allows the library&#8217;s symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.Libdl.dlopen_e\">\n<code class=\"descname\">dlopen_e</code><span class=\"sig-paren\">(</span><em>libfile::AbstractString</em><span class=\"optional\">[</span>, <em>flags::Integer</em><span class=\"optional\">]</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.Libdl.dlopen_e\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Similar to <a class=\"reference internal\" href=\"#Base.Libdl.dlopen\" title=\"Base.Libdl.dlopen\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">dlopen()</span></code></a>, except returns a <code class=\"docutils literal\"><span class=\"pre\">NULL</span></code> pointer instead of raising errors.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Libdl.RTLD_DEEPBIND\">\n<code class=\"descname\">RTLD_DEEPBIND</code><a class=\"headerlink\" href=\"#Base.Libdl.RTLD_DEEPBIND\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dt id=\"Base.Libdl.RTLD_FIRST\">\n<code class=\"descname\">RTLD_FIRST</code><a class=\"headerlink\" href=\"#Base.Libdl.RTLD_FIRST\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dt id=\"Base.Libdl.RTLD_GLOBAL\">\n<code class=\"descname\">RTLD_GLOBAL</code><a class=\"headerlink\" href=\"#Base.Libdl.RTLD_GLOBAL\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dt id=\"Base.Libdl.RTLD_LAZY\">\n<code class=\"descname\">RTLD_LAZY</code><a class=\"headerlink\" href=\"#Base.Libdl.RTLD_LAZY\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dt id=\"Base.Libdl.RTLD_LOCAL\">\n<code class=\"descname\">RTLD_LOCAL</code><a class=\"headerlink\" href=\"#Base.Libdl.RTLD_LOCAL\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dt id=\"Base.Libdl.RTLD_NODELETE\">\n<code class=\"descname\">RTLD_NODELETE</code><a class=\"headerlink\" href=\"#Base.Libdl.RTLD_NODELETE\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dt id=\"Base.Libdl.RTLD_NOLOAD\">\n<code class=\"descname\">RTLD_NOLOAD</code><a class=\"headerlink\" href=\"#Base.Libdl.RTLD_NOLOAD\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dt id=\"Base.Libdl.RTLD_NOW\">\n<code class=\"descname\">RTLD_NOW</code><a class=\"headerlink\" href=\"#Base.Libdl.RTLD_NOW\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Enum constant for <a class=\"reference internal\" href=\"#Base.Libdl.dlopen\" title=\"Base.Libdl.dlopen\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">dlopen()</span></code></a>. See your platform man page for details, if applicable.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.Libdl.dlsym\">\n<code class=\"descname\">dlsym</code><span class=\"sig-paren\">(</span><em>handle</em>, <em>sym</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.Libdl.dlsym\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Look up a symbol from a shared library handle, return callable function pointer on success.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.Libdl.dlsym_e\">\n<code class=\"descname\">dlsym_e</code><span class=\"sig-paren\">(</span><em>handle</em>, <em>sym</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.Libdl.dlsym_e\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Look up a symbol from a shared library handle, silently return <code class=\"docutils literal\"><span class=\"pre\">NULL</span></code> pointer on lookup failure.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.Libdl.dlclose\">\n<code class=\"descname\">dlclose</code><span class=\"sig-paren\">(</span><em>handle</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.Libdl.dlclose\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Close shared library referenced by handle.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Libdl.dlext\">\n<code class=\"descname\">dlext</code><a class=\"headerlink\" href=\"#Base.Libdl.dlext\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>File extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.Libdl.find_library\">\n<code class=\"descname\">find_library</code><span class=\"sig-paren\">(</span><em>names</em>, <em>locations</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.Libdl.find_library\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Searches for the first library in <code class=\"docutils literal\"><span class=\"pre\">names</span></code> in the paths in the <code class=\"docutils literal\"><span class=\"pre\">locations</span></code> list, <code class=\"docutils literal\"><span class=\"pre\">DL_LOAD_PATH</span></code>, or system library paths (in that order) which can successfully be dlopen&#8217;d. On success, the return value will be one of the names (potentially prefixed by one of the paths in locations). This string can be assigned to a <code class=\"docutils literal\"><span class=\"pre\">global</span> <span class=\"pre\">const</span></code> and used as the library name in future <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code>&#8216;s. On failure, it returns the empty string.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Libdl.DL_LOAD_PATH\">\n<code class=\"descname\">DL_LOAD_PATH</code><a class=\"headerlink\" href=\"#Base.Libdl.DL_LOAD_PATH\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>When calling <a class=\"reference internal\" href=\"#Base.Libdl.dlopen\" title=\"Base.Libdl.dlopen\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">dlopen()</span></code></a>, the paths in this list will be searched first, in order, before searching the system locations for a valid library handle.</p>\n</dd></dl>\n\n</div>\n\n\n          </div>\n          <footer>\n  \n    <div class=\"rst-footer-buttons\" role=\"navigation\" aria-label=\"footer navigation\">\n      \n        <a href=\"profile.html\" class=\"btn btn-neutral float-right\" title=\"Profiling\">Next <span class=\"fa fa-arrow-circle-right\"></span></a>\n      \n      \n        <a href=\"libc.html\" class=\"btn btn-neutral\" title=\"C Standard Library\"><span class=\"fa fa-arrow-circle-left\"></span> Previous</a>\n      \n    </div>\n  \n\n  <hr/>\n\n  <div role=\"contentinfo\">\n    <p>\n    </p>\n  </div>\n\n  <a href=\"https://github.com/snide/sphinx_rtd_theme\">Sphinx theme</a> provided by <a href=\"https://readthedocs.org\">Read the Docs</a>\n</footer>\n        </div>\n      </div>\n\n    </section>\n\n  </div>\n  \n\n  \n\n    <script type=\"text/javascript\">\n        var DOCUMENTATION_OPTIONS = {\n            URL_ROOT:'../',\n            VERSION:'0.5.1',\n            COLLAPSE_INDEX:false,\n            FILE_SUFFIX:'.html',\n            HAS_SOURCE:  true\n        };\n    </script>\n      <script type=\"text/javascript\" src=\"../_static/jquery.js\"></script>\n      <script type=\"text/javascript\" src=\"../_static/underscore.js\"></script>\n      <script type=\"text/javascript\" src=\"../_static/doctools.js\"></script>\n      <script type=\"text/javascript\" src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>\n\n  \n\n  \n  \n    <script type=\"text/javascript\" src=\"../_static/js/theme.js\"></script>\n  \n\n  \n  \n  <script type=\"text/javascript\">\n      jQuery(function () {\n          SphinxRtdTheme.StickyNav.enable();\n      });\n  </script>\n   \n\n</body>\n</html>",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/manual/calling-c-and-fortran-code.html": "\n\n<!DOCTYPE html>\n<!--[if IE 8]><html class=\"no-js lt-ie9\" lang=\"en\" > <![endif]-->\n<!--[if gt IE 8]><!--> <html class=\"no-js\" lang=\"en\" > <!--<![endif]-->\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  \n  <title>Calling C and Fortran Code &mdash; Julia Language 0.5.1 documentation</title>\n  \n\n  \n  \n\n  \n  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>\n\n  \n  \n    \n\n  \n\n  \n  \n    <link rel=\"stylesheet\" href=\"../_static/julia.css\" type=\"text/css\" />\n  \n\n  \n    <link rel=\"stylesheet\" href=\"../_static/julia.css\" type=\"text/css\" />\n  \n    <link rel=\"top\" title=\"Julia Language 0.5.1 documentation\" href=\"../index.html\"/>\n        <link rel=\"next\" title=\"Handling Operating System Variation\" href=\"handling-operating-system-variation.html\"/>\n        <link rel=\"prev\" title=\"Running External Programs\" href=\"running-external-programs.html\"/> \n\n  \n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js\"></script>\n\n</head>\n\n<body class=\"wy-body-for-nav\" role=\"document\">\n\n  <div class=\"wy-grid-for-nav\">\n\n    \n    <nav data-toggle=\"wy-nav-shift\" class=\"wy-nav-side\">\n      <div class=\"wy-side-nav-search\">\n        <a href=\"http://julialang.org/\"><img src=\"../_static/julia-logo.svg\" class=\"logo\"></a>\n        <!--\n        <a href=\"../index.html\" class=\"fa fa-home\"> Julia Language</a>\n        -->\n        <div role=\"search\">\n  <form id =\"rtd-search-form\" class=\"wy-form\" action=\"../search.html\" method=\"get\">\n    <input type=\"text\" name=\"q\" placeholder=\"Search docs\" />\n    <input type=\"hidden\" name=\"check_keywords\" value=\"yes\" />\n    <input type=\"hidden\" name=\"area\" value=\"default\" />\n  </form>\n</div>\n      </div>\n\n      <div class=\"wy-menu wy-menu-vertical\" data-spy=\"affix\" role=\"navigation\" aria-label=\"main navigation\">\n        \n        \n            <ul class=\"current\">\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"introduction.html\">Introduction</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"getting-started.html\">Getting Started</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"getting-started.html#resources\">Resources</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"variables.html\">Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"variables.html#allowed-variable-names\">Allowed Variable Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"variables.html#stylistic-conventions\">Stylistic Conventions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"integers-and-floating-point-numbers.html\">Integers and Floating-Point Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"integers-and-floating-point-numbers.html#integers\">Integers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"integers-and-floating-point-numbers.html#floating-point-numbers\">Floating-Point Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"integers-and-floating-point-numbers.html#arbitrary-precision-arithmetic\">Arbitrary Precision Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"integers-and-floating-point-numbers.html#numeric-literal-coefficients\">Numeric Literal Coefficients</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"integers-and-floating-point-numbers.html#literal-zero-and-one\">Literal zero and one</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"mathematical-operations.html\">Mathematical Operations and Elementary Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"mathematical-operations.html#arithmetic-operators\">Arithmetic Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"mathematical-operations.html#bitwise-operators\">Bitwise Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"mathematical-operations.html#updating-operators\">Updating operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"mathematical-operations.html#numeric-comparisons\">Numeric Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"mathematical-operations.html#numerical-conversions\">Numerical Conversions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"complex-and-rational-numbers.html\">Complex and Rational Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"complex-and-rational-numbers.html#complex-numbers\">Complex Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"complex-and-rational-numbers.html#rational-numbers\">Rational Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"strings.html\">Strings</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#characters\">Characters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#string-basics\">String Basics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#unicode-and-utf-8\">Unicode and UTF-8</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#triple-quoted-string-literals\">Triple-Quoted String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#common-operations\">Common Operations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#regular-expressions\">Regular Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#id2\">Byte Array Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#version-number-literals\">Version Number Literals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"functions.html\">Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#argument-passing-behavior\">Argument Passing Behavior</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#the-return-keyword\">The <code class=\"docutils literal\"><span class=\"pre\">return</span></code> Keyword</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#operators-are-functions\">Operators Are Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#operators-with-special-names\">Operators With Special Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#anonymous-functions\">Anonymous Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#multiple-return-values\">Multiple Return Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#varargs-functions\">Varargs Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#optional-arguments\">Optional Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#keyword-arguments\">Keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#evaluation-scope-of-default-values\">Evaluation Scope of Default Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#do-block-syntax-for-function-arguments\">Do-Block Syntax for Function Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#dot-syntax-for-vectorizing-functions\">Dot Syntax for Vectorizing Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#further-reading\">Further Reading</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"control-flow.html\">Control Flow</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"control-flow.html#compound-expressions\">Compound Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"control-flow.html#conditional-evaluation\">Conditional Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"control-flow.html#short-circuit-evaluation\">Short-Circuit Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"control-flow.html#repeated-evaluation-loops\">Repeated Evaluation: Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"control-flow.html#exception-handling\">Exception Handling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"control-flow.html#tasks-aka-coroutines\">Tasks (aka Coroutines)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"variables-and-scoping.html\">Scope of Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"variables-and-scoping.html#global-scope\">Global Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"variables-and-scoping.html#local-scope\">Local Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"variables-and-scoping.html#constants\">Constants</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"types.html\">Types</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#type-declarations\">Type Declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#abstract-types\">Abstract Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#bits-types\">Bits Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#composite-types\">Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#immutable-composite-types\">Immutable Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#declared-types\">Declared Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#type-unions\">Type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#man-parametric-types\">Parametric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#type-aliases\">Type Aliases</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#operations-on-types\">Operations on Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#custom-pretty-printing\">Custom pretty-printing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#value-types\">&#8220;Value types&#8221;</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#nullable-types-representing-missing-values\">Nullable Types: Representing Missing Values</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"methods.html\">Methods</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"methods.html#defining-methods\">Defining Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"methods.html#method-ambiguities\">Method Ambiguities</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"methods.html#parametric-methods\">Parametric Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"methods.html#parametrically-constrained-varargs-methods\">Parametrically-constrained Varargs methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"methods.html#note-on-optional-and-keyword-arguments\">Note on Optional and keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"methods.html#function-like-objects\">Function-like objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"methods.html#empty-generic-functions\">Empty generic functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"constructors.html\">Constructors</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#outer-constructor-methods\">Outer Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#inner-constructor-methods\">Inner Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#incomplete-initialization\">Incomplete Initialization</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#parametric-constructors\">Parametric Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#case-study-rational\">Case Study: Rational</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#constructors-and-conversion\">Constructors and Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#outer-only-constructors\">Outer-only constructors</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"conversion-and-promotion.html\">Conversion and Promotion</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"conversion-and-promotion.html#conversion\">Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"conversion-and-promotion.html#promotion\">Promotion</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"interfaces.html\">Interfaces</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"interfaces.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"interfaces.html#indexing\">Indexing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"interfaces.html#abstract-arrays\">Abstract Arrays</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"modules.html\">Modules</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"modules.html#summary-of-module-usage\">Summary of module usage</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"documentation.html\">Documentation</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"documentation.html#accessing-documentation\">Accessing Documentation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"documentation.html#functions-methods\">Functions &amp; Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"documentation.html#advanced-usage\">Advanced Usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"documentation.html#syntax-guide\">Syntax Guide</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"documentation.html#markdown-syntax\">Markdown syntax</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"documentation.html#markdown-syntax-extensions\">Markdown Syntax Extensions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"metaprogramming.html\">Metaprogramming</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"metaprogramming.html#program-representation\">Program representation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"metaprogramming.html#expressions-and-evaluation\">Expressions and evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"metaprogramming.html#macros\">Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"metaprogramming.html#code-generation\">Code Generation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"metaprogramming.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"metaprogramming.html#generated-functions\">Generated functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"arrays.html\">Multi-dimensional Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#arrays\">Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#sparse-matrices\">Sparse Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"linear-algebra.html\">Linear algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linear-algebra.html#matrix-factorizations\">Matrix factorizations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linear-algebra.html#special-matrices\">Special matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"networking-and-streams.html\">Networking and Streams</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"networking-and-streams.html#basic-stream-i-o\">Basic Stream I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"networking-and-streams.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"networking-and-streams.html#io-output-contextual-properties\">IO Output Contextual Properties</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"networking-and-streams.html#working-with-files\">Working with Files</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"networking-and-streams.html#a-simple-tcp-example\">A simple TCP example</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"networking-and-streams.html#resolving-ip-addresses\">Resolving IP Addresses</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"parallel-computing.html\">Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#code-availability-and-loading-packages\">Code Availability and Loading Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#data-movement\">Data Movement</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#parallel-map-and-loops\">Parallel Map and Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#synchronization-with-remote-references\">Synchronization With Remote References</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#scheduling\">Scheduling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#channels\">Channels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#remote-references-and-abstractchannels\">Remote references and AbstractChannels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#remote-references-and-distributed-garbage-collection\">Remote References and Distributed Garbage Collection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#id2\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#shared-arrays-and-distributed-garbage-collection\">Shared Arrays and Distributed Garbage Collection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#clustermanagers\">ClusterManagers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#cluster-managers-with-custom-transports\">Cluster Managers with custom transports</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#network-requirements-for-localmanager-and-sshmanager\">Network requirements for LocalManager and SSHManager</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#cluster-cookie\">Cluster cookie</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#specifying-network-topology-experimental\">Specifying network topology (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#multi-threading-experimental\">Multi-threading (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#threadcall-experimental\">&#64;threadcall (Experimental)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"dates.html\">Date and DateTime</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#durations-comparisons\">Durations/Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#accessor-functions\">Accessor Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#query-functions\">Query Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#timetype-period-arithmetic\">TimeType-Period Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#adjuster-functions\">Adjuster Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#period-types\">Period Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#rounding\">Rounding</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"running-external-programs.html\">Running External Programs</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"running-external-programs.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"running-external-programs.html#quoting\">Quoting</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"running-external-programs.html#pipelines\">Pipelines</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1 current\"><a class=\"current reference internal\" href=\"#\">Calling C and Fortran Code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#creating-c-compatible-julia-function-pointers\">Creating C-Compatible Julia Function Pointers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#mapping-c-types-to-julia\">Mapping C Types to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#mapping-c-functions-to-julia\">Mapping C Functions to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#some-examples-of-c-wrappers\">Some Examples of C Wrappers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#garbage-collection-safety\">Garbage Collection Safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#non-constant-function-specifications\">Non-constant Function Specifications</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#indirect-calls\">Indirect Calls</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#calling-convention\">Calling Convention</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#accessing-global-variables\">Accessing Global Variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#accessing-data-through-a-pointer\">Accessing Data through a Pointer</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#thread-safety\">Thread-safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#more-about-callbacks\">More About Callbacks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#c\">C++</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"handling-operating-system-variation.html\">Handling Operating System Variation</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"interacting-with-julia.html\">Interacting With Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"interacting-with-julia.html#the-different-prompt-modes\">The different prompt modes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"interacting-with-julia.html#key-bindings\">Key bindings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"interacting-with-julia.html#tab-completion\">Tab completion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"interacting-with-julia.html#customizing-colors\">Customizing Colors</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"embedding.html\">Embedding Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"embedding.html#high-level-embedding\">High-Level Embedding</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"embedding.html#converting-types\">Converting Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"embedding.html#calling-julia-functions\">Calling Julia Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"embedding.html#memory-management\">Memory Management</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"embedding.html#working-with-arrays\">Working with Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"embedding.html#exceptions\">Exceptions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"packages.html\">Packages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#package-status\">Package Status</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#adding-and-removing-packages\">Adding and Removing Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#offline-installation-of-packages\">Offline Installation of Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#installing-unregistered-packages\">Installing Unregistered Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#updating-packages\">Updating Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#checkout-pin-and-free\">Checkout, Pin and Free</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#custom-metadata-repository\">Custom METADATA Repository</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"packages.html#package-development\">Package Development</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#initial-setup\">Initial Setup</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#making-changes-to-an-existing-package\">Making changes to an existing package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#creating-a-new-package\">Creating a new Package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#fixing-package-requirements\">Fixing Package Requirements</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#man-package-requirements\">Requirements Specification</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"profile.html\">Profiling</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"profile.html#basic-usage\">Basic usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"profile.html#accumulation-and-clearing\">Accumulation and clearing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"profile.html#options-for-controlling-the-display-of-profile-results\">Options for controlling the display of profile results</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"profile.html#configuration\">Configuration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"profile.html#memory-allocation-analysis\">Memory allocation analysis</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stacktraces.html\">Stack Traces</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stacktraces.html#viewing-a-stack-trace\">Viewing a stack trace</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stacktraces.html#extracting-useful-information\">Extracting useful information</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stacktraces.html#error-handling\">Error handling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stacktraces.html#comparison-with-backtrace\">Comparison with <code class=\"docutils literal\"><span class=\"pre\">backtrace()</span></code></a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"performance-tips.html\">Performance Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#avoid-global-variables\">Avoid global variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#measure-performance-with-time-and-pay-attention-to-memory-allocation\">Measure performance with <code class=\"docutils literal\"><span class=\"pre\">&#64;time</span></code> and pay attention to memory allocation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#tools\">Tools</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#avoid-containers-with-abstract-type-parameters\">Avoid containers with abstract type parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#type-declarations\">Type declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#break-functions-into-multiple-definitions\">Break functions into multiple definitions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#write-type-stable-functions\">Write &#8220;type-stable&#8221; functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#avoid-changing-the-type-of-a-variable\">Avoid changing the type of a variable</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#separate-kernel-functions-aka-function-barriers\">Separate kernel functions (aka, function barriers)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#types-with-values-as-parameters\">Types with values-as-parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#the-dangers-of-abusing-multiple-dispatch-aka-more-on-types-with-values-as-parameters\">The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#access-arrays-in-memory-order-along-columns\">Access arrays in memory order, along columns</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#pre-allocating-outputs\">Pre-allocating outputs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#avoid-string-interpolation-for-i-o\">Avoid string interpolation for I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#optimize-network-i-o-during-parallel-execution\">Optimize network I/O during parallel execution</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#fix-deprecation-warnings\">Fix deprecation warnings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#tweaks\">Tweaks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#performance-annotations\">Performance Annotations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#treat-subnormal-numbers-as-zeros\">Treat Subnormal Numbers as Zeros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#code-warntype\"><code class=\"docutils literal\"><span class=\"pre\">&#64;code_warntype</span></code></a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"workflow-tips.html\">Workflow Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"workflow-tips.html#repl-based-workflow\">REPL-based workflow</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"workflow-tips.html#browser-based-workflow\">Browser-based workflow</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"style-guide.html\">Style Guide</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#write-functions-not-just-scripts\">Write functions, not just scripts</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#avoid-writing-overly-specific-types\">Avoid writing overly-specific types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#handle-excess-argument-diversity-in-the-caller\">Handle excess argument diversity in the caller</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#append-to-names-of-functions-that-modify-their-arguments\">Append <code class=\"docutils literal\"><span class=\"pre\">!</span></code> to names of functions that modify their arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#avoid-strange-type-unions\">Avoid strange type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#avoid-type-unions-in-fields\">Avoid type Unions in fields</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#avoid-elaborate-container-types\">Avoid elaborate container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#use-naming-conventions-consistent-with-julia-s-base\">Use naming conventions consistent with Julia&#8217;s <code class=\"docutils literal\"><span class=\"pre\">base/</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-overuse-try-catch\">Don&#8217;t overuse try-catch</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-parenthesize-conditions\">Don&#8217;t parenthesize conditions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-overuse\">Don&#8217;t overuse ...</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-use-unnecessary-static-parameters\">Don&#8217;t use unnecessary static parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#avoid-confusion-about-whether-something-is-an-instance-or-a-type\">Avoid confusion about whether something is an instance or a type</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-overuse-macros\">Don&#8217;t overuse macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-expose-unsafe-operations-at-the-interface-level\">Don&#8217;t expose unsafe operations at the interface level</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-overload-methods-of-base-container-types\">Don&#8217;t overload methods of base container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#be-careful-with-type-equality\">Be careful with type equality</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#do-not-write-x-f-x\">Do not write <code class=\"docutils literal\"><span class=\"pre\">x-&gt;f(x)</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible\">Avoid using floats for numeric literals in generic code when possible</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"faq.html\">Frequently Asked Questions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#sessions-and-the-repl\">Sessions and the REPL</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#functions\">Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#types-type-declarations-and-constructors\">Types, type declarations, and constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#packages-and-modules\">Packages and Modules</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#nothingness-and-missing-values\">Nothingness and missing values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#memory\">Memory</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#asynchronous-io-and-concurrent-synchronous-writes\">Asynchronous IO and concurrent synchronous writes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#julia-releases\">Julia Releases</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"noteworthy-differences.html\">Noteworthy Differences from other Languages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"noteworthy-differences.html#noteworthy-differences-from-matlab\">Noteworthy differences from MATLAB</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"noteworthy-differences.html#noteworthy-differences-from-r\">Noteworthy differences from R</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"noteworthy-differences.html#noteworthy-differences-from-python\">Noteworthy differences from Python</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"noteworthy-differences.html#noteworthy-differences-from-c-c\">Noteworthy differences from C/C++</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"unicode-input.html\">Unicode Input</a></li>\n</ul>\n<ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/base.html\">Essentials</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#introduction\">Introduction</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#getting-around\">Getting Around</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#all-objects\">All Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#types\">Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#generic-functions\">Generic Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#syntax\">Syntax</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#nullables\">Nullables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#system\">System</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#errors\">Errors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#events\">Events</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#reflection\">Reflection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#internals\">Internals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/collections.html\">Collections and Data Structures</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#general-collections\">General Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#iterable-collections\">Iterable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#indexable-collections\">Indexable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#associative-collections\">Associative Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#set-like-collections\">Set-Like Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#dequeues\">Dequeues</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#priorityqueue\">PriorityQueue</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#heap-functions\">Heap Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/math.html\">Mathematics</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/math.html#mathematical-operators\">Mathematical Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/math.html#mathematical-functions\">Mathematical Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/math.html#statistics\">Statistics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/math.html#signal-processing\">Signal Processing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/math.html#numerical-integration\">Numerical Integration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/numbers.html\">Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/numbers.html#standard-numeric-types\">Standard Numeric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/numbers.html#data-formats\">Data Formats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/numbers.html#general-number-functions-and-constants\">General Number Functions and Constants</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/numbers.html#bigfloats\">BigFloats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/numbers.html#random-numbers\">Random Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/strings.html\">Strings</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/arrays.html\">Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#basic-functions\">Basic functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#mathematical-operators-and-functions\">Mathematical operators and functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#indexing-assignment-and-concatenation\">Indexing, Assignment, and Concatenation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#array-functions\">Array functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#combinatorics\">Combinatorics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#bitarrays\">BitArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#sparse-vectors-and-matrices\">Sparse Vectors and Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/parallel.html\">Tasks and Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/parallel.html#tasks\">Tasks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/parallel.html#general-parallel-computing-support\">General Parallel Computing Support</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/parallel.html#shared-arrays\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/parallel.html#multi-threading\">Multi-Threading</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/parallel.html#ccall-using-a-threadpool-experimental\">ccall using a threadpool (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/parallel.html#synchronization-primitives\">Synchronization Primitives</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/parallel.html#cluster-manager-interface\">Cluster Manager Interface</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/linalg.html\">Linear Algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/linalg.html#module-Base.LinAlg\">Standard Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/linalg.html#low-level-matrix-operations\">Low-level matrix operations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/linalg.html#module-Base.LinAlg.BLAS\">BLAS Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/linalg.html#module-Base.LinAlg.LAPACK\">LAPACK Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/constants.html\">Constants</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/file.html\">Filesystem</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/io-network.html\">I/O and Network</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/io-network.html#general-i-o\">General I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/io-network.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/io-network.html#multimedia-i-o\">Multimedia I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/io-network.html#memory-mapped-i-o\">Memory-mapped I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/io-network.html#network-i-o\">Network I/O</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/punctuation.html\">Punctuation</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/sort.html\">Sorting and Related Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/sort.html#sorting-functions\">Sorting Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/sort.html#order-related-functions\">Order-Related Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/sort.html#sorting-algorithms\">Sorting Algorithms</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/pkg.html\">Package Manager Functions</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/dates.html\">Dates and Time</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/dates.html#dates-and-time-types\">Dates and Time Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/dates.html#dates-functions\">Dates Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/test.html\">Unit Testing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/test.html#testing-base-julia\">Testing Base Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/test.html#basic-unit-tests\">Basic Unit Tests</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/test.html#working-with-test-sets\">Working with Test Sets</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/test.html#other-test-macros\">Other Test Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/test.html#broken-tests\">Broken Tests</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/test.html#creating-custom-abstracttestset-types\">Creating Custom <code class=\"docutils literal\"><span class=\"pre\">AbstractTestSet</span></code> Types</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/c.html\">C Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/c.html#llvm-interface\">LLVM Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/libc.html\">C Standard Library</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/libdl.html\">Dynamic Linker</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/profile.html\">Profiling</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/stacktraces.html\">StackTraces</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/simd-types.html\">SIMD Support</a></li>\n</ul>\n<ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/reflection.html\">Reflection and introspection</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/julia.html\">Documentation of Julia&#8217;s Internals</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/init.html\">Initialization of the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/eval.html\">Eval of Julia code</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/ast.html\">Julia ASTs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/types.html\">More about types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/object.html\">Memory layout of Julia Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/functions.html\">Julia Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/callconv.html\">Calling Conventions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/cartesian.html\">Base.Cartesian</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/meta.html\">Talking to the compiler (the <code class=\"docutils literal\"><span class=\"pre\">:meta</span></code> mechanism)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/subarrays.html\">SubArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/sysimg.html\">System Image Building</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/llvm.html\">Working with LLVM</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/stdio.html\">printf() and stdio in the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/boundscheck.html\">Bounds checking</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/locks.html\">Proper maintenance and care of multi-threading locks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/offset-arrays.html\">Arrays with custom indices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/C.html\">Developing/debugging Julia&#8217;s C code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/backtraces.html\">Reporting and analyzing crashes (segfaults)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/debuggingtips.html\">gdb debugging tips</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/valgrind.html\">Using Valgrind with Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/sanitizers.html\">Sanitizer support</a></li>\n</ul>\n</li>\n</ul>\n\n        \n      </div>\n      &nbsp;\n    </nav>\n\n    <section data-toggle=\"wy-nav-shift\" class=\"wy-nav-content-wrap\">\n\n      \n      <nav class=\"wy-nav-top\" role=\"navigation\" aria-label=\"top navigation\">\n        <i data-toggle=\"wy-nav-top\" class=\"fa fa-bars\"></i>\n        <a href=\"../index.html\">Julia Language</a>\n      </nav>\n\n\n      \n      <div class=\"wy-nav-content\">\n        <div class=\"rst-content\">\n          <div role=\"navigation\" aria-label=\"breadcrumbs navigation\">\n  <ul class=\"wy-breadcrumbs\">\n    <li><a href=\"../index.html\">Docs</a> &raquo;</li>\n      \n    <li>Calling C and Fortran Code</li>\n      <li class=\"wy-breadcrumbs-aside\">\n        \n          <a href=\"../_sources/manual/calling-c-and-fortran-code.txt\" rel=\"nofollow\"> View page source</a>\n        \n      </li>\n  </ul>\n  <hr/>\n</div>\n          <div role=\"main\" class=\"document\">\n            \n  <div class=\"section\" id=\"calling-c-and-fortran-code\">\n<span id=\"man-calling-c-and-fortran-code\"></span><h1>Calling C and Fortran Code<a class=\"headerlink\" href=\"#calling-c-and-fortran-code\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<p>Though most code can be written in Julia, there are many high-quality,\nmature libraries for numerical computing already written in C and\nFortran. To allow easy use of this existing code, Julia makes it simple\nand efficient to call C and Fortran functions. Julia has a &#8220;no\nboilerplate&#8221; philosophy: functions can be called directly from Julia\nwithout any &#8220;glue&#8221; code, code generation, or compilation \u2014 even from the\ninteractive prompt. This is accomplished just by making an appropriate call\nwith <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> syntax, which looks like an ordinary function call.</p>\n<p>The code to be called must be available as a shared library. Most C and\nFortran libraries ship compiled as shared libraries already, but if you\nare compiling the code yourself using GCC (or Clang), you will need to\nuse the <code class=\"docutils literal\"><span class=\"pre\">-shared</span></code> and <code class=\"docutils literal\"><span class=\"pre\">-fPIC</span></code> options. The machine instructions\ngenerated by Julia&#8217;s JIT are the same as a native C call would be, so\nthe resulting overhead is the same as calling a library function from C\ncode. (Non-library function calls in both C and Julia can be inlined and\nthus may have even less overhead than calls to shared library functions.\nWhen both libraries and executables are generated by LLVM, it is\npossible to perform whole-program optimizations that can even optimize\nacross this boundary, but Julia does not yet support that. In the\nfuture, however, it may do so, yielding even greater performance gains.)</p>\n<p>Shared libraries and functions are referenced by a tuple of the\nform <code class=\"docutils literal\"><span class=\"pre\">(:function,</span> <span class=\"pre\">&quot;library&quot;)</span></code> or <code class=\"docutils literal\"><span class=\"pre\">(&quot;function&quot;,</span> <span class=\"pre\">&quot;library&quot;)</span></code> where <code class=\"docutils literal\"><span class=\"pre\">function</span></code>\nis the C-exported function name. <code class=\"docutils literal\"><span class=\"pre\">library</span></code> refers to the shared library\nname: shared libraries available in the (platform-specific) load path\nwill be resolved by name, and if necessary a direct path may be specified.</p>\n<p>A function name may be used alone in place of the tuple (just\n<code class=\"docutils literal\"><span class=\"pre\">:function</span></code> or <code class=\"docutils literal\"><span class=\"pre\">&quot;function&quot;</span></code>). In this case the name is resolved within\nthe current process. This form can be used to call C library functions,\nfunctions in the Julia runtime, or functions in an application linked to\nJulia.</p>\n<p>By default, Fortran compilers <a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Name_mangling#Fortran\">generate mangled names</a>\n(for example, converting function names to lowercase or uppercase,\noften appending an underscore), and so to call a Fortran function via\n<a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> you must pass the mangled identifier corresponding to the rule\nfollowed by your Fortran compiler.  Also, when calling a Fortran\nfunction, all inputs must be passed by reference.</p>\n<p>Finally, you can use <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> to actually generate a call to the\nlibrary function. Arguments to <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> are as follows:</p>\n<ol class=\"arabic simple\">\n<li>(:function, &#8220;library&#8221;) pair (must be a constant, but see below).</li>\n<li>Return type (see below for mapping the declared C type to Julia)<ul>\n<li>This argument will be evaluated at compile-time.</li>\n</ul>\n</li>\n<li>A tuple of input types. The input types must be written as a literal tuple,\nnot a tuple-valued variable or expression.<ul>\n<li>This argument will be evaluated at compile-time.</li>\n</ul>\n</li>\n<li>The following arguments, if any, are the actual argument values\npassed to the function.</li>\n</ol>\n<p>As a complete but simple example, the following calls the <code class=\"docutils literal\"><span class=\"pre\">clock</span></code>\nfunction from the standard C library:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"k\">ccall</span><span class=\"p\">(</span> <span class=\"p\">(</span><span class=\"o\">:</span><span class=\"n\">clock</span><span class=\"p\">,</span> <span class=\"s\">&quot;libc&quot;</span><span class=\"p\">),</span> <span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"p\">())</span>\n<span class=\"mi\">2292761</span>\n\n<span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"n\">t</span>\n<span class=\"mi\">2292761</span>\n\n<span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"n\">typeof</span><span class=\"p\">(</span><span class=\"n\">ans</span><span class=\"p\">)</span>\n<span class=\"kt\">Int32</span>\n</pre></div>\n</div>\n<p><code class=\"docutils literal\"><span class=\"pre\">clock</span></code> takes no arguments and returns an <code class=\"docutils literal\"><span class=\"pre\">Int32</span></code>. One common gotcha\nis that a 1-tuple must be written with a trailing comma. For\nexample, to call the <code class=\"docutils literal\"><span class=\"pre\">getenv</span></code> function to get a pointer to the value\nof an environment variable, one makes a call like this:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span>julia&gt; path = ccall((:getenv, &quot;libc&quot;), Cstring, (Cstring,), &quot;SHELL&quot;)\nCstring(@0x00007fff5fbffc45)\n\njulia&gt; unsafe_string(path)\n&quot;/bin/bash&quot;\n</pre></div>\n</div>\n<p>Note that the argument type tuple must be written as <code class=\"docutils literal\"><span class=\"pre\">(Cstring,)</span></code>,\nrather than <code class=\"docutils literal\"><span class=\"pre\">(Cstring)</span></code>. This is because <code class=\"docutils literal\"><span class=\"pre\">(Cstring)</span></code> is just\nthe expression <code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code> surrounded by parentheses, rather than\na 1-tuple containing <code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code>:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Cstring</span><span class=\"p\">)</span>\n<span class=\"kt\">Cstring</span>\n\n<span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Cstring</span><span class=\"p\">,)</span>\n<span class=\"p\">(</span><span class=\"kt\">Cstring</span><span class=\"p\">,)</span>\n</pre></div>\n</div>\n<p>In practice, especially when providing reusable functionality, one\ngenerally wraps <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> uses in Julia functions that set up arguments\nand then check for errors in whatever manner the C or Fortran function\nindicates them, propagating to the Julia caller as exceptions. This is\nespecially important since C and Fortran APIs are notoriously\ninconsistent about how they indicate error conditions. For example, the\n<code class=\"docutils literal\"><span class=\"pre\">getenv</span></code> C library function is wrapped in the following Julia function,\nwhich is a simplified version of the actual definition from\n<a class=\"reference external\" href=\"https://github.com/JuliaLang/julia/blob/release-0.5/base/env.jl\">env.jl</a>:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">function</span> <span class=\"n\">getenv</span><span class=\"p\">(</span><span class=\"n\">var</span><span class=\"o\">::</span><span class=\"kt\">AbstractString</span><span class=\"p\">)</span>\n  <span class=\"n\">val</span> <span class=\"o\">=</span> <span class=\"k\">ccall</span><span class=\"p\">((</span><span class=\"o\">:</span><span class=\"n\">getenv</span><span class=\"p\">,</span> <span class=\"s\">&quot;libc&quot;</span><span class=\"p\">),</span>\n              <span class=\"kt\">Cstring</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Cstring</span><span class=\"p\">,),</span> <span class=\"n\">var</span><span class=\"p\">)</span>\n  <span class=\"k\">if</span> <span class=\"n\">val</span> <span class=\"o\">==</span> <span class=\"nb\">C_NULL</span>\n    <span class=\"n\">error</span><span class=\"p\">(</span><span class=\"s\">&quot;getenv: undefined variable: &quot;</span><span class=\"p\">,</span> <span class=\"n\">var</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n  <span class=\"n\">unsafe_string</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n</pre></div>\n</div>\n<p>The C <code class=\"docutils literal\"><span class=\"pre\">getenv</span></code> function indicates an error by returning <code class=\"docutils literal\"><span class=\"pre\">NULL</span></code>, but\nother standard C functions indicate errors in various different ways,\nincluding by returning -1, 0, 1 and other special values. This wrapper\nthrows an exception clearly indicating the problem if the caller tries\nto get a non-existent environment variable:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"n\">getenv</span><span class=\"p\">(</span><span class=\"s\">&quot;SHELL&quot;</span><span class=\"p\">)</span>\n<span class=\"s\">&quot;/bin/bash&quot;</span>\n\n<span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"n\">getenv</span><span class=\"p\">(</span><span class=\"s\">&quot;FOOBAR&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">getenv</span><span class=\"o\">:</span> <span class=\"n\">undefined</span> <span class=\"n\">variable</span><span class=\"o\">:</span> <span class=\"n\">FOOBAR</span>\n</pre></div>\n</div>\n<p>Here is a slightly more complex example that discovers the local\nmachine&#8217;s hostname:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">function</span> <span class=\"n\">gethostname</span><span class=\"p\">()</span>\n  <span class=\"n\">hostname</span> <span class=\"o\">=</span> <span class=\"kt\">Array</span><span class=\"p\">{</span><span class=\"kt\">UInt8</span><span class=\"p\">}(</span><span class=\"mi\">128</span><span class=\"p\">)</span>\n  <span class=\"k\">ccall</span><span class=\"p\">((</span><span class=\"o\">:</span><span class=\"n\">gethostname</span><span class=\"p\">,</span> <span class=\"s\">&quot;libc&quot;</span><span class=\"p\">),</span> <span class=\"kt\">Int32</span><span class=\"p\">,</span>\n        <span class=\"p\">(</span><span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">UInt8</span><span class=\"p\">},</span> <span class=\"kt\">Csize_t</span><span class=\"p\">),</span>\n        <span class=\"n\">hostname</span><span class=\"p\">,</span> <span class=\"n\">sizeof</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"p\">))</span>\n  <span class=\"n\">hostname</span><span class=\"p\">[</span><span class=\"k\">end</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"c\"># ensure null-termination</span>\n  <span class=\"k\">return</span> <span class=\"n\">unsafe_string</span><span class=\"p\">(</span><span class=\"n\">pointer</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"p\">))</span>\n<span class=\"k\">end</span>\n</pre></div>\n</div>\n<p>This example first allocates an array of bytes, then calls the C library\nfunction <code class=\"docutils literal\"><span class=\"pre\">gethostname</span></code> to fill the array in with the hostname, takes a\npointer to the hostname buffer, and converts the pointer to a Julia\nstring, assuming that it is a NUL-terminated C string. It is common for\nC libraries to use this pattern of requiring the caller to allocate\nmemory to be passed to the callee and filled in. Allocation of memory\nfrom Julia like this is generally accomplished by creating an\nuninitialized array and passing a pointer to its data to the C function.\nThis is why we don&#8217;t use the <code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code> type here: as the array is\nuninitialized, it could contain NUL bytes. Converting to a <code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code> as\npart of the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> checks for contained NUL bytes and could therefore\nthrow a conversion error.</p>\n<div class=\"section\" id=\"creating-c-compatible-julia-function-pointers\">\n<h2>Creating C-Compatible Julia Function Pointers<a class=\"headerlink\" href=\"#creating-c-compatible-julia-function-pointers\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>It is possible to pass Julia functions to native C functions that accept\nfunction pointer arguments. For example, to match C prototypes of the form:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">typedef</span> <span class=\"n\">returntype</span> <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">functiontype</span><span class=\"p\">)(</span><span class=\"n\">argumenttype</span><span class=\"p\">,</span><span class=\"o\">...</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>The function <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cfunction\" title=\"Base.cfunction\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cfunction()</span></code></a> generates the C-compatible function pointer for\na call to a Julia library function.\nArguments to <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cfunction\" title=\"Base.cfunction\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cfunction()</span></code></a> are as follows:</p>\n<ol class=\"arabic simple\">\n<li>A Julia Function</li>\n<li>Return type</li>\n<li>A tuple of input types</li>\n</ol>\n<p>A classic example is the standard C library <code class=\"docutils literal\"><span class=\"pre\">qsort</span></code> function,\ndeclared as:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">void</span> <span class=\"n\">qsort</span><span class=\"p\">(</span><span class=\"n\">void</span> <span class=\"o\">*</span><span class=\"n\">base</span><span class=\"p\">,</span> <span class=\"n\">size_t</span> <span class=\"n\">nmemb</span><span class=\"p\">,</span> <span class=\"n\">size_t</span> <span class=\"n\">size</span><span class=\"p\">,</span>\n           <span class=\"n\">int</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">compare</span><span class=\"p\">)(</span><span class=\"kd\">const</span> <span class=\"n\">void</span> <span class=\"o\">*</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"kd\">const</span> <span class=\"n\">void</span> <span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">));</span>\n</pre></div>\n</div>\n<p>The <code class=\"docutils literal\"><span class=\"pre\">base</span></code> argument is a pointer to an array of length <code class=\"docutils literal\"><span class=\"pre\">nmemb</span></code>, with elements of\n<code class=\"docutils literal\"><span class=\"pre\">size</span></code> bytes each. <code class=\"docutils literal\"><span class=\"pre\">compare</span></code> is a callback function which takes pointers to two\nelements <code class=\"docutils literal\"><span class=\"pre\">a</span></code> and <code class=\"docutils literal\"><span class=\"pre\">b</span></code> and returns an integer less/greater than zero if <code class=\"docutils literal\"><span class=\"pre\">a</span></code> should\nappear before/after <code class=\"docutils literal\"><span class=\"pre\">b</span></code> (or zero if any order is permitted). Now, suppose that we\nhave a 1d array <code class=\"docutils literal\"><span class=\"pre\">A</span></code> of values in Julia that we want to sort using the <code class=\"docutils literal\"><span class=\"pre\">qsort</span></code>\nfunction (rather than Julia&#8217;s built-in <code class=\"docutils literal\"><span class=\"pre\">sort</span></code> function). Before we worry about calling\n<code class=\"docutils literal\"><span class=\"pre\">qsort</span></code> and passing arguments, we need to write a comparison function that works for\nsome arbitrary type T:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">function</span> <span class=\"n\">mycompare</span><span class=\"p\">{</span><span class=\"n\">T</span><span class=\"p\">}(</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">::</span><span class=\"n\">T</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">convert</span><span class=\"p\">(</span><span class=\"kt\">Cint</span><span class=\"p\">,</span> <span class=\"n\">a</span> <span class=\"o\">&lt;</span> <span class=\"n\">b</span> <span class=\"o\">?</span> <span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"o\">&gt;</span> <span class=\"n\">b</span> <span class=\"o\">?</span> <span class=\"o\">+</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"o\">::</span><span class=\"kt\">Cint</span>\n<span class=\"k\">end</span>\n</pre></div>\n</div>\n<p>Notice that we have to be careful about the return type: <code class=\"docutils literal\"><span class=\"pre\">qsort</span></code> expects a function\nreturning a C <code class=\"docutils literal\"><span class=\"pre\">int</span></code>, so we must be sure to return <code class=\"docutils literal\"><span class=\"pre\">Cint</span></code> via a call to <code class=\"docutils literal\"><span class=\"pre\">convert</span></code>\nand a <code class=\"docutils literal\"><span class=\"pre\">typeassert</span></code>.</p>\n<p>In order to pass this function to C, we obtain its address using the function <code class=\"docutils literal\"><span class=\"pre\">cfunction</span></code>:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"kd\">const</span> <span class=\"n\">mycompare_c</span> <span class=\"o\">=</span> <span class=\"n\">cfunction</span><span class=\"p\">(</span><span class=\"n\">mycompare</span><span class=\"p\">,</span> <span class=\"kt\">Cint</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Ref</span><span class=\"p\">{</span><span class=\"kt\">Cdouble</span><span class=\"p\">},</span> <span class=\"kt\">Ref</span><span class=\"p\">{</span><span class=\"kt\">Cdouble</span><span class=\"p\">}))</span>\n</pre></div>\n</div>\n<p><a class=\"reference internal\" href=\"../stdlib/c.html#Base.cfunction\" title=\"Base.cfunction\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cfunction()</span></code></a> accepts three arguments: the Julia function (<code class=\"docutils literal\"><span class=\"pre\">mycompare</span></code>),\nthe return type (<code class=\"docutils literal\"><span class=\"pre\">Cint</span></code>), and a tuple of the argument types, in this case to\nsort an array of <code class=\"docutils literal\"><span class=\"pre\">Cdouble</span></code> (<code class=\"docutils literal\"><span class=\"pre\">Float64</span></code>) elements.</p>\n<p>The final call to <code class=\"docutils literal\"><span class=\"pre\">qsort</span></code> looks like this:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">1.3</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">2.7</span><span class=\"p\">,</span> <span class=\"mf\">4.4</span><span class=\"p\">,</span> <span class=\"mf\">3.1</span><span class=\"p\">]</span>\n<span class=\"k\">ccall</span><span class=\"p\">(</span><span class=\"o\">:</span><span class=\"n\">qsort</span><span class=\"p\">,</span> <span class=\"kt\">Void</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Cdouble</span><span class=\"p\">},</span> <span class=\"kt\">Csize_t</span><span class=\"p\">,</span> <span class=\"kt\">Csize_t</span><span class=\"p\">,</span> <span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Void</span><span class=\"p\">}),</span>\n      <span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">),</span> <span class=\"n\">sizeof</span><span class=\"p\">(</span><span class=\"n\">eltype</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)),</span> <span class=\"n\">mycompare_c</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>After this executes, <code class=\"docutils literal\"><span class=\"pre\">A</span></code> is changed to the sorted array <code class=\"docutils literal\"><span class=\"pre\">[-2.7,</span> <span class=\"pre\">1.3,</span> <span class=\"pre\">3.1,</span> <span class=\"pre\">4.4]</span></code>.\nNote that Julia knows how to convert an array into a <code class=\"docutils literal\"><span class=\"pre\">Ptr{Cdouble}</span></code>, how to compute\nthe size of a type in bytes (identical to C&#8217;s <code class=\"docutils literal\"><span class=\"pre\">sizeof</span></code> operator), and so on.\nFor fun, try inserting a <code class=\"docutils literal\"><span class=\"pre\">println(&quot;mycompare($a,$b)&quot;)</span></code> line into <code class=\"docutils literal\"><span class=\"pre\">mycompare</span></code>, which\nwill allow you to see the comparisons that <code class=\"docutils literal\"><span class=\"pre\">qsort</span></code> is performing (and to verify that\nit is really calling the Julia function that you passed to it).</p>\n</div>\n<div class=\"section\" id=\"mapping-c-types-to-julia\">\n<h2>Mapping C Types to Julia<a class=\"headerlink\" href=\"#mapping-c-types-to-julia\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>It is critical to exactly match the declared C type with its declaration\nin Julia. Inconsistencies can cause code that works correctly on one system\nto fail or produce indeterminate results on a different system.</p>\n<p>Note that no C header files are used anywhere in the process of calling C\nfunctions: you are responsible for making sure that your Julia types and\ncall signatures accurately reflect those in the C header file. (The <a class=\"reference external\" href=\"https://github.com/ihnorton/Clang.jl\">Clang\npackage</a> can be used to auto-generate\nJulia code from a C header file.)</p>\n<div class=\"section\" id=\"auto-conversion\">\n<h3>Auto-conversion:<a class=\"headerlink\" href=\"#auto-conversion\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>Julia automatically inserts calls to the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cconvert\" title=\"Base.cconvert\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cconvert()</span></code></a> function to convert\neach argument to the specified type. For example, the following call:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">ccall</span><span class=\"p\">((</span><span class=\"o\">:</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"s\">&quot;libfoo&quot;</span><span class=\"p\">),</span> <span class=\"kt\">Void</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"kt\">Float64</span><span class=\"p\">),</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>will behave as if the following were written:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">ccall</span><span class=\"p\">((</span><span class=\"o\">:</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"s\">&quot;libfoo&quot;</span><span class=\"p\">),</span> <span class=\"kt\">Void</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"kt\">Float64</span><span class=\"p\">),</span>\n      <span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">unsafe_convert</span><span class=\"p\">(</span><span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">cconvert</span><span class=\"p\">(</span><span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">)),</span>\n      <span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">unsafe_convert</span><span class=\"p\">(</span><span class=\"kt\">Float64</span><span class=\"p\">,</span> <span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">cconvert</span><span class=\"p\">(</span><span class=\"kt\">Float64</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)))</span>\n</pre></div>\n</div>\n<p><a class=\"reference internal\" href=\"../stdlib/c.html#Base.cconvert\" title=\"Base.cconvert\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cconvert()</span></code></a> normally just calls <a class=\"reference internal\" href=\"../stdlib/base.html#Base.convert\" title=\"Base.convert\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">convert()</span></code></a>, but can be defined to return\nan arbitrary new object more appropriate for passing to C. For example,\nthis is used to convert an <code class=\"docutils literal\"><span class=\"pre\">Array</span></code> of objects (e.g. strings) to an\narray of pointers.</p>\n<p><a class=\"reference internal\" href=\"../stdlib/c.html#Base.unsafe_convert\" title=\"Base.unsafe_convert\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">unsafe_convert()</span></code></a> handles conversion to <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> types. It is considered\nunsafe because converting an object to a native pointer can hide the object\nfrom the garbage collector, causing it to be freed prematurely.</p>\n</div>\n<div class=\"section\" id=\"type-correspondences\">\n<h3>Type Correspondences:<a class=\"headerlink\" href=\"#type-correspondences\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>First, a review of some relevant Julia type terminology:</p>\n<table border=\"1\" class=\"text-wrap docutils\">\n<colgroup>\n<col width=\"26%\" />\n<col width=\"26%\" />\n<col width=\"48%\" />\n</colgroup>\n<thead valign=\"bottom\">\n<tr class=\"row-odd\"><th class=\"head\">Syntax / Keyword</th>\n<th class=\"head\">Example</th>\n<th class=\"head\">Description</th>\n</tr>\n</thead>\n<tbody valign=\"top\">\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">type</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">String</span></code></td>\n<td>&#8220;Leaf Type&#8221; :: A group of related data that includes\na type-tag, is managed by the Julia GC, and\nis defined by object-identity.\nThe type parameters of a leaf type must be fully defined\n(no <code class=\"docutils literal\"><span class=\"pre\">TypeVars</span></code> are allowed)\nin order for the instance to be constructed.</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">abstract</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Any</span></code>,\n<code class=\"docutils literal\"><span class=\"pre\">AbstractArray{T,N}</span></code>,\n<code class=\"docutils literal\"><span class=\"pre\">Complex{T}</span></code></td>\n<td>&#8220;Super Type&#8221; :: A super-type (not a leaf-type)\nthat cannot be instantiated, but can be used to\ndescribe a group of types.</td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">{T}</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Vector{Int}</span></code></td>\n<td><p class=\"first\">&#8220;Type Parameter&#8221; :: A specialization of a type\n(typically used for dispatch or storage optimization).</p>\n<p class=\"last\">&#8220;TypeVar&#8221; :: The <code class=\"docutils literal\"><span class=\"pre\">T</span></code> in the type parameter declaration\nis referred to as a TypeVar (short for type variable).</p>\n</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">bitstype</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int</span></code>,\n<code class=\"docutils literal\"><span class=\"pre\">Float64</span></code></td>\n<td>&#8220;Bits Type&#8221; :: A type with no fields, but a size. It\nis stored and defined by-value.</td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">immutable</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">Pair{Int,Int}</span></code></p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">Complex128</span></code> (<code class=\"docutils literal\"><span class=\"pre\">isbits</span></code>)</p>\n</td>\n<td><p class=\"first\">&#8220;Immutable&#8221; :: A type with all fields defined to be\nconstant. It is defined by-value. And may be stored\nwith a type-tag.</p>\n<p class=\"last\">&#8220;Is-Bits&#8221; :: A <code class=\"docutils literal\"><span class=\"pre\">bitstype</span></code>, or an <code class=\"docutils literal\"><span class=\"pre\">immutable</span></code> type\nwhere all fields are other <code class=\"docutils literal\"><span class=\"pre\">isbits</span></code> types. It is\ndefined by-value, and is stored without a type-tag.</p>\n</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">type</span> <span class=\"pre\">...;</span> <span class=\"pre\">end</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">nothing</span></code></td>\n<td>&#8220;Singleton&#8221; :: a Leaf Type or Immutable with no fields.</td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">(...)</span></code> or <code class=\"docutils literal\"><span class=\"pre\">tuple(...)`</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">(1,2,3)</span></code></td>\n<td>&#8220;Tuple&#8221; :: an immutable data-structure similar to an\nanonymous immutable type, or a constant array.\nRepresented as either an array or a struct.</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">typealias</span></code></td>\n<td>Not applicable here</td>\n<td>Type aliases, and other similar mechanisms of\ndoing type indirection, are resolved to their base\ntype (this includes assigning a type to another name,\nor getting the type out of a function call).</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"bits-types\">\n<h3>Bits Types:<a class=\"headerlink\" href=\"#bits-types\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>There are several special types to be aware of, as no other type can be defined to behave the same:</p>\n<dl class=\"docutils\">\n<dt><code class=\"docutils literal\"><span class=\"pre\">Float32</span></code></dt>\n<dd>Exactly corresponds to the <code class=\"docutils literal\"><span class=\"pre\">float</span></code> type in C (or <code class=\"docutils literal\"><span class=\"pre\">REAL*4</span></code> in Fortran).</dd>\n<dt><code class=\"docutils literal\"><span class=\"pre\">Float64</span></code></dt>\n<dd>Exactly corresponds to the <code class=\"docutils literal\"><span class=\"pre\">double</span></code> type in C (or <code class=\"docutils literal\"><span class=\"pre\">REAL*8</span></code> in Fortran).</dd>\n<dt><code class=\"docutils literal\"><span class=\"pre\">Complex64</span></code></dt>\n<dd>Exactly corresponds to the <code class=\"docutils literal\"><span class=\"pre\">complex</span> <span class=\"pre\">float</span></code> type in C (or <code class=\"docutils literal\"><span class=\"pre\">COMPLEX*8</span></code> in Fortran).</dd>\n<dt><code class=\"docutils literal\"><span class=\"pre\">Complex128</span></code></dt>\n<dd>Exactly corresponds to the <code class=\"docutils literal\"><span class=\"pre\">complex</span> <span class=\"pre\">double</span></code> type in C (or <code class=\"docutils literal\"><span class=\"pre\">COMPLEX*16</span></code> in Fortran).</dd>\n<dt><code class=\"docutils literal\"><span class=\"pre\">Signed</span></code></dt>\n<dd>Exactly corresponds to the <code class=\"docutils literal\"><span class=\"pre\">signed</span></code> type annotation in C (or any <code class=\"docutils literal\"><span class=\"pre\">INTEGER</span></code> type in Fortran). Any Julia type that is not a subtype of <code class=\"docutils literal\"><span class=\"pre\">Signed</span></code> is assumed to be unsigned.</dd>\n<dt><code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code></dt>\n<dd>Behaves like a <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code> that owns its memory.</dd>\n<dt><code class=\"docutils literal\"><span class=\"pre\">Array{T,N}</span></code></dt>\n<dd><p class=\"first\">When an array is passed to C as a <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code> argument, it is\nnot reinterpret-cast: Julia requires that the element type of the\narray matches <code class=\"docutils literal\"><span class=\"pre\">T</span></code>, and the address of the first element is passed.</p>\n<p>Therefore, if an <code class=\"docutils literal\"><span class=\"pre\">Array</span></code> contains data in the wrong format, it will\nhave to be explicitly converted using a call such as <code class=\"docutils literal\"><span class=\"pre\">trunc(Int32,a)</span></code>.</p>\n<p>To pass an array <code class=\"docutils literal\"><span class=\"pre\">A</span></code> as a pointer of a different type <em>without</em>\nconverting the data beforehand (for example, to pass a <code class=\"docutils literal\"><span class=\"pre\">Float64</span></code> array\nto a function that operates on uninterpreted bytes), you can\ndeclare the argument as <code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code>.</p>\n<p class=\"last\">If an array of eltype <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code> is passed as a <code class=\"docutils literal\"><span class=\"pre\">Ptr{Ptr{T}}</span></code> argument,\n<a class=\"reference internal\" href=\"../stdlib/c.html#Base.cconvert\" title=\"Base.cconvert\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">Base.cconvert()</span></code></a> will attempt to first make a null-terminated copy of the array with\neach element replaced by its <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cconvert\" title=\"Base.cconvert\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cconvert()</span></code></a> version. This allows, for example, passing an <code class=\"docutils literal\"><span class=\"pre\">argv</span></code>\npointer array of type <code class=\"docutils literal\"><span class=\"pre\">Vector{String}</span></code> to an argument of type <code class=\"docutils literal\"><span class=\"pre\">Ptr{Ptr{Cchar}}</span></code>.</p>\n</dd>\n</dl>\n<p>On all systems we currently support, basic C/C++ value types may be\ntranslated to Julia types as follows. Every C type also has a corresponding\nJulia type with the same name, prefixed by C. This can help for writing portable code (and remembering that an <code class=\"docutils literal\"><span class=\"pre\">int</span></code> in C is not the same as an <code class=\"docutils literal\"><span class=\"pre\">Int</span></code> in Julia).</p>\n<p><strong>System Independent:</strong></p>\n<table border=\"1\" class=\"text-wrap docutils\">\n<colgroup>\n<col width=\"32%\" />\n<col width=\"16%\" />\n<col width=\"20%\" />\n<col width=\"32%\" />\n</colgroup>\n<thead valign=\"bottom\">\n<tr class=\"row-odd\"><th class=\"head\">C name</th>\n<th class=\"head\">Fortran name</th>\n<th class=\"head\">Standard Julia Alias</th>\n<th class=\"head\">Julia Base Type</th>\n</tr>\n</thead>\n<tbody valign=\"top\">\n<tr class=\"row-even\"><td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">char</span></code></p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">bool</span></code> (C++)</p>\n</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">CHARACTER</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cuchar</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">UInt8</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">short</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">INTEGER*2</span></code></p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">LOGICAL*2</span></code></p>\n</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cshort</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int16</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">short</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cushort</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">UInt16</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">int</span></code></p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">BOOL</span></code> (C, typical)</p>\n</td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">INTEGER*4</span></code></p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">LOGICAL*4</span></code></p>\n</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cint</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int32</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">int</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cuint</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">UInt32</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">long</span> <span class=\"pre\">long</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">INTEGER*8</span></code></p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">LOGICAL*8</span></code></p>\n</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Clonglong</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int64</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">long</span> <span class=\"pre\">long</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Culonglong</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">UInt64</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">intmax_t</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cintmax_t</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int64</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">uintmax_t</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cuintmax_t</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">UInt64</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">float</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">REAL*4i</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cfloat</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Float32</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">double</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">REAL*8</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cdouble</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Float64</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">complex</span> <span class=\"pre\">float</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">COMPLEX*8</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Complex64</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Complex{Float32}</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">complex</span> <span class=\"pre\">double</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">COMPLEX*16</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Complex128</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Complex{Float64}</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">ptrdiff_t</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cptrdiff_t</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">ssize_t</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cssize_t</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">size_t</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Csize_t</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">UInt</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">void</span></code></td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Void</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">void</span></code> and\n<code class=\"docutils literal\"><span class=\"pre\">[[noreturn]]</span></code> or <code class=\"docutils literal\"><span class=\"pre\">_Noreturn</span></code></td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Union{}</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">void*</span></code></td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">T*</span></code> (where T represents an\nappropriately defined type)</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">char*</span></code>\n(or <code class=\"docutils literal\"><span class=\"pre\">char[]</span></code>, e.g. a string)</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">CHARACTER*N</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code> if NUL-terminated, or\n<code class=\"docutils literal\"><span class=\"pre\">Ptr{UInt8}</span></code> if not</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">char**</span></code> (or <code class=\"docutils literal\"><span class=\"pre\">*char[]</span></code>)</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Ptr{Ptr{UInt8}}</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code>\n(any Julia Type)</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Any</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">jl_value_t**</span></code>\n(a reference to a Julia Type)</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Ref{Any}</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">va_arg</span></code></td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>Not supported</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">...</span></code>\n(variadic function specification)</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">T...</span></code> (where <code class=\"docutils literal\"><span class=\"pre\">T</span></code>\nis one of the above types,\nvariadic functions of different\nargument types are not supported)</td>\n</tr>\n</tbody>\n</table>\n<p>The <code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code> type is essentially a synonym for <code class=\"docutils literal\"><span class=\"pre\">Ptr{UInt8}</span></code>, except the conversion to <code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code> throws an\nerror if the Julia string contains any embedded NUL characters (which would cause the string to be silently\ntruncated if the C routine treats NUL as the terminator).  If you are passing a <code class=\"docutils literal\"><span class=\"pre\">char*</span></code> to a C routine that\ndoes not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that\nyour Julia string does not contain NUL and want to skip the check, you can use <code class=\"docutils literal\"><span class=\"pre\">Ptr{UInt8}</span></code> as the argument type.\n<code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code> can also be used as the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> return type, but in that case it obviously does not introduce any extra\nchecks and is only meant to improve readability of the call.</p>\n<p><strong>System-dependent:</strong></p>\n<table border=\"1\" class=\"docutils\">\n<colgroup>\n<col width=\"32%\" />\n<col width=\"32%\" />\n<col width=\"35%\" />\n</colgroup>\n<thead valign=\"bottom\">\n<tr class=\"row-odd\"><th class=\"head\">C name</th>\n<th class=\"head\">Standard Julia Alias</th>\n<th class=\"head\">Julia Base Type</th>\n</tr>\n</thead>\n<tbody valign=\"top\">\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">char</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cchar</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">Int8</span></code> (x86, x86_64)</p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">UInt8</span></code> (powerpc, arm)</p>\n</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">long</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Clong</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">Int</span></code> (UNIX)</p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">Int32</span></code> (Windows)</p>\n</td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">long</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Culong</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">UInt</span></code> (UNIX)</p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">UInt32</span></code> (Windows)</p>\n</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">wchar_t</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cwchar_t</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">Int32</span></code> (UNIX)</p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">UInt16</span></code> (Windows)</p>\n</td>\n</tr>\n</tbody>\n</table>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">When calling a Fortran function, all inputs must be passed by reference, so\nall type correspondences above should contain an additional <code class=\"docutils literal\"><span class=\"pre\">Ptr{..}</span></code> or\n<code class=\"docutils literal\"><span class=\"pre\">Ref{..}</span></code> wrapper around their type specification.</p>\n</div>\n<div class=\"admonition warning\">\n<p class=\"first admonition-title\">Warning</p>\n<p class=\"last\">For string arguments (<code class=\"docutils literal\"><span class=\"pre\">char*</span></code>) the Julia type should be <code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code> (if NUL-\nterminated data is expected) or either <code class=\"docutils literal\"><span class=\"pre\">Ptr{Cchar}</span></code> or <code class=\"docutils literal\"><span class=\"pre\">Ptr{UInt8}</span></code>\notherwise (these two pointer types have the same effect), as described above,\nnot <code class=\"docutils literal\"><span class=\"pre\">String</span></code>. Similarly, for array arguments (<code class=\"docutils literal\"><span class=\"pre\">T[]</span></code> or <code class=\"docutils literal\"><span class=\"pre\">T*</span></code>), the\nJulia type should again be <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code>, not <code class=\"docutils literal\"><span class=\"pre\">Vector{T}</span></code>.</p>\n</div>\n<div class=\"admonition warning\">\n<p class=\"first admonition-title\">Warning</p>\n<p class=\"last\">Julia&#8217;s <code class=\"docutils literal\"><span class=\"pre\">Char</span></code> type is 32 bits, which is not the same as the wide character\ntype (<code class=\"docutils literal\"><span class=\"pre\">wchar_t</span></code> or <code class=\"docutils literal\"><span class=\"pre\">wint_t</span></code>) on all platforms.</p>\n</div>\n<div class=\"admonition warning\">\n<p class=\"first admonition-title\">Warning</p>\n<p class=\"last\">A return type of <code class=\"docutils literal\"><span class=\"pre\">Union{}</span></code> means the function will not return\ni.e. C++11 <code class=\"docutils literal\"><span class=\"pre\">[[noreturn]]</span></code> or C11 <code class=\"docutils literal\"><span class=\"pre\">_Noreturn</span></code> (e.g. <code class=\"docutils literal\"><span class=\"pre\">jl_throw</span></code> or\n<code class=\"docutils literal\"><span class=\"pre\">longjmp</span></code>). Do not use this for functions that return\nno value (<code class=\"docutils literal\"><span class=\"pre\">void</span></code>) but do return.</p>\n</div>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">For <code class=\"docutils literal\"><span class=\"pre\">wchar_t*</span></code> arguments, the Julia type should be <code class=\"docutils literal\"><span class=\"pre\">Cwstring</span></code> (if the C\nroutine expects a NUL-terminated string) or <code class=\"docutils literal\"><span class=\"pre\">Ptr{Cwchar_t}</span></code> otherwise. Note\nalso that UTF-8 string data in Julia is internally NUL-terminated, so it can\nbe passed to C functions expecting NUL-terminated data without making a copy\n(but using the <code class=\"docutils literal\"><span class=\"pre\">Cwstring</span></code> type will cause an error to be thrown if the string\nitself contains NUL characters).</p>\n</div>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p>C functions that take an argument of the type <code class=\"docutils literal\"><span class=\"pre\">char**</span></code> can be called by\nusing a <code class=\"docutils literal\"><span class=\"pre\">Ptr{Ptr{UInt8}}</span></code> type within Julia. For example, C functions of the\nform:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">int</span> <span class=\"n\">main</span><span class=\"p\">(</span><span class=\"n\">int</span> <span class=\"n\">argc</span><span class=\"p\">,</span> <span class=\"n\">char</span> <span class=\"o\">**</span><span class=\"n\">argv</span><span class=\"p\">);</span>\n</pre></div>\n</div>\n<p>can be called via the following Julia code:</p>\n<div class=\"last highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">argv</span> <span class=\"o\">=</span> <span class=\"p\">[</span> <span class=\"s\">&quot;a.out&quot;</span><span class=\"p\">,</span> <span class=\"s\">&quot;arg1&quot;</span><span class=\"p\">,</span> <span class=\"s\">&quot;arg2&quot;</span> <span class=\"p\">]</span>\n<span class=\"k\">ccall</span><span class=\"p\">(</span><span class=\"o\">:</span><span class=\"n\">main</span><span class=\"p\">,</span> <span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">UInt8</span><span class=\"p\">}}),</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">argv</span><span class=\"p\">),</span> <span class=\"n\">argv</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n</div>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">A C function declared to return <code class=\"docutils literal\"><span class=\"pre\">Void</span></code> will return the value <code class=\"docutils literal\"><span class=\"pre\">nothing</span></code> in\nJulia.</p>\n</div>\n</div>\n<div class=\"section\" id=\"struct-type-correspondences\">\n<h3>Struct Type correspondences<a class=\"headerlink\" href=\"#struct-type-correspondences\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>Composite types, aka <code class=\"docutils literal\"><span class=\"pre\">struct</span></code> in C or <code class=\"docutils literal\"><span class=\"pre\">TYPE</span></code> in Fortran90\n(or <code class=\"docutils literal\"><span class=\"pre\">STRUCTURE</span></code> / <code class=\"docutils literal\"><span class=\"pre\">RECORD</span></code> in some variants of F77),\ncan be mirrored in Julia by creating a <code class=\"docutils literal\"><span class=\"pre\">type</span></code> or <code class=\"docutils literal\"><span class=\"pre\">immutable</span></code>\ndefinition with the same field layout.</p>\n<p>When used recursively, <code class=\"docutils literal\"><span class=\"pre\">isbits</span></code> types are stored inline.\nAll other types are stored as a pointer to the data.\nWhen mirroring a struct used by-value inside another struct in C,\nit is imperative that you do not attempt to manually copy the fields over,\nas this will not preserve the correct field alignment.\nInstead, declare an immutable <code class=\"docutils literal\"><span class=\"pre\">isbits</span></code> type and use that instead.\nUnnamed structs are not possible in the translation to Julia.</p>\n<p>Packed structs and union declarations are not supported by Julia.</p>\n<p>You can get a near approximation of a <code class=\"docutils literal\"><span class=\"pre\">union</span></code> if you know, a priori,\nthe field that will have the greatest size (potentially including padding).\nWhen translating your fields to Julia, declare the Julia field to be only\nof that type.</p>\n<p>Arrays of parameters must be expanded manually, currently\n(either inline, or in an immutable helper type). For example:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"kp\">in</span> <span class=\"n\">C</span><span class=\"o\">:</span>\n<span class=\"n\">struct</span> <span class=\"n\">B</span> <span class=\"p\">{</span>\n    <span class=\"n\">int</span> <span class=\"n\">A</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">];</span>\n<span class=\"p\">};</span>\n<span class=\"n\">b_a_2</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"o\">.</span><span class=\"n\">A</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">];</span>\n\n<span class=\"kp\">in</span> <span class=\"n\">Julia</span><span class=\"o\">:</span>\n<span class=\"k\">immutable</span> <span class=\"n\">B_A</span>\n    <span class=\"n\">A_1</span><span class=\"o\">::</span><span class=\"kt\">Cint</span>\n    <span class=\"n\">A_2</span><span class=\"o\">::</span><span class=\"kt\">Cint</span>\n    <span class=\"n\">A_3</span><span class=\"o\">::</span><span class=\"kt\">Cint</span>\n<span class=\"k\">end</span>\n<span class=\"k\">type</span> <span class=\"n\">B</span>\n    <span class=\"n\">A</span><span class=\"o\">::</span><span class=\"n\">B_A</span>\n<span class=\"k\">end</span>\n<span class=\"n\">b_a_2</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"o\">.</span><span class=\"n\">A</span><span class=\"o\">.</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Arrays of unknown size are not supported.</p>\n<p>In the future, some of these restrictions may be reduced or eliminated.</p>\n</div>\n<div class=\"section\" id=\"simd-values\">\n<h3>SIMD Values<a class=\"headerlink\" href=\"#simd-values\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>Note: This feature is currently implemented on 64-bit x86\nand AArch64 platforms only.</p>\n<p>If a C/C++ routine has an argument or return value that is a native\nSIMD type, the corresponding Julia type is a homogeneous tuple\nof <code class=\"docutils literal\"><span class=\"pre\">VecElement</span></code> that naturally maps to the SIMD type.  Specifically:</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li>The tuple must be the same size as the SIMD type.\nFor example, a tuple representing an <code class=\"docutils literal\"><span class=\"pre\">__m128</span></code> on x86\nmust have a size of 16 bytes.</li>\n<li>The element type of the tuple must be an instance of <code class=\"docutils literal\"><span class=\"pre\">VecElement{T}</span></code>\nwhere <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is a bitstype that is 1, 2, 4 or 8 bytes.</li>\n</ul>\n</div></blockquote>\n<p>For instance, consider this C routine that uses AVX intrinsics:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"c\">#include &lt;immintrin.h&gt;</span>\n\n<span class=\"n\">__m256</span> <span class=\"n\">dist</span><span class=\"p\">(</span> <span class=\"n\">__m256</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">__m256</span> <span class=\"n\">b</span> <span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">_mm256_sqrt_ps</span><span class=\"p\">(</span><span class=\"n\">_mm256_add_ps</span><span class=\"p\">(</span><span class=\"n\">_mm256_mul_ps</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">),</span>\n                                        <span class=\"n\">_mm256_mul_ps</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">)));</span>\n<span class=\"p\">}</span>\n</pre></div>\n</div>\n<p>The following Julia code calls <code class=\"docutils literal\"><span class=\"pre\">dist</span></code> using <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code>:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">typealias</span> <span class=\"n\">m256</span> <span class=\"kt\">NTuple</span><span class=\"p\">{</span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"n\">VecElement</span><span class=\"p\">{</span><span class=\"kt\">Float32</span><span class=\"p\">}}</span>\n\n<span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">m256</span><span class=\"p\">(</span><span class=\"n\">ntuple</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">-&gt;</span><span class=\"n\">VecElement</span><span class=\"p\">(</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"kt\">Float32</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">))),</span><span class=\"mi\">8</span><span class=\"p\">))</span>\n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">m256</span><span class=\"p\">(</span><span class=\"n\">ntuple</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">-&gt;</span><span class=\"n\">VecElement</span><span class=\"p\">(</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"kt\">Float32</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">))),</span><span class=\"mi\">8</span><span class=\"p\">))</span>\n\n<span class=\"k\">function</span> <span class=\"n\">call_dist</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">m256</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">::</span><span class=\"n\">m256</span><span class=\"p\">)</span>\n    <span class=\"k\">ccall</span><span class=\"p\">((</span><span class=\"o\">:</span><span class=\"n\">dist</span><span class=\"p\">,</span> <span class=\"s\">&quot;libdist&quot;</span><span class=\"p\">),</span> <span class=\"n\">m256</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">m256</span><span class=\"p\">,</span> <span class=\"n\">m256</span><span class=\"p\">),</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">println</span><span class=\"p\">(</span><span class=\"n\">call_dist</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<p>The host machine must have the requisite SIMD registers.  For example,\nthe code above will not work on hosts without AVX support.</p>\n</div>\n<div class=\"section\" id=\"memory-ownership\">\n<h3>Memory Ownership<a class=\"headerlink\" href=\"#memory-ownership\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p><strong>malloc/free</strong></p>\n<p>Memory allocation and deallocation of such objects must be\nhandled by calls to the appropriate cleanup routines in the libraries\nbeing used, just like in any C program. Do not try to free an object\nreceived from a C library with <code class=\"docutils literal\"><span class=\"pre\">Libc.free</span></code> in Julia, as this may result\nin the <code class=\"docutils literal\"><span class=\"pre\">free</span></code> function being called via the wrong <code class=\"docutils literal\"><span class=\"pre\">libc</span></code> library and\ncause Julia to crash. The reverse (passing an object allocated in Julia\nto be freed by an external library) is equally invalid.</p>\n</div>\n<div class=\"section\" id=\"when-to-use-t-ptr-t-and-ref-t\">\n<h3>When to use T, Ptr{T} and Ref{T}<a class=\"headerlink\" href=\"#when-to-use-t-ptr-t-and-ref-t\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>In Julia code wrapping calls to external C routines, ordinary (non-pointer)\ndata should be declared to be of type <code class=\"docutils literal\"><span class=\"pre\">T</span></code> inside the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a>, as they\nare passed by value.  For C code accepting pointers, <code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code> should\ngenerally be used for the types of input arguments, allowing the use of\npointers to memory managed by either Julia or C through the implicit call to\n<a class=\"reference internal\" href=\"../stdlib/c.html#Base.cconvert\" title=\"Base.cconvert\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cconvert()</span></code></a>.  In contrast, pointers returned by the C function called\nshould be declared to be of output type <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code>, reflecting that the memory\npointed to is managed by C only. Pointers contained in C structs should be\nrepresented as fields of type <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code> within the corresponding Julia\nimmutable types designed to mimic the internal structure of corresponding C\nstructs.</p>\n<p>In Julia code wrapping calls to external Fortran routines, all input arguments\nshould be declared as of type <code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code>, as Fortran passes all variables by\nreference. The return type should either be <code class=\"docutils literal\"><span class=\"pre\">Void</span></code> for Fortran subroutines,\nor a <code class=\"docutils literal\"><span class=\"pre\">T</span></code> for Fortran functions returning the type <code class=\"docutils literal\"><span class=\"pre\">T</span></code>.</p>\n</div>\n</div>\n<div class=\"section\" id=\"mapping-c-functions-to-julia\">\n<h2>Mapping C Functions to Julia<a class=\"headerlink\" href=\"#mapping-c-functions-to-julia\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<div class=\"section\" id=\"ccall-cfunction-argument-translation-guide\">\n<h3><code class=\"docutils literal\"><span class=\"pre\">ccall</span></code>/<code class=\"docutils literal\"><span class=\"pre\">cfunction</span></code> argument translation guide<a class=\"headerlink\" href=\"#ccall-cfunction-argument-translation-guide\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>For translating a C argument list to Julia:</p>\n<ul class=\"simple\">\n<li><code class=\"docutils literal\"><span class=\"pre\">T</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is one of the primitive types:\n<code class=\"docutils literal\"><span class=\"pre\">char</span></code>, <code class=\"docutils literal\"><span class=\"pre\">int</span></code>, <code class=\"docutils literal\"><span class=\"pre\">long</span></code>, <code class=\"docutils literal\"><span class=\"pre\">short</span></code>, <code class=\"docutils literal\"><span class=\"pre\">float</span></code>, <code class=\"docutils literal\"><span class=\"pre\">double</span></code>, <code class=\"docutils literal\"><span class=\"pre\">complex</span></code>, <code class=\"docutils literal\"><span class=\"pre\">enum</span></code>\nor any of their <code class=\"docutils literal\"><span class=\"pre\">typedef</span></code> equivalents<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">T</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is an equivalent Julia Bits Type (per the table above)</li>\n<li>if <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is an <code class=\"docutils literal\"><span class=\"pre\">enum</span></code>, the argument type should be equivalent to <code class=\"docutils literal\"><span class=\"pre\">Cint</span></code> or <code class=\"docutils literal\"><span class=\"pre\">Cuint</span></code></li>\n<li>argument value will be copied (passed by value)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">struct</span> <span class=\"pre\">T</span></code> (including typedef to a struct)<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">T</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is a Julia leaf type</li>\n<li>argument value will be copied (passed by value)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">void*</span></code><ul>\n<li>depends on how this parameter is used, first translate this to the intended pointer type,\nthen determine the Julia equivalent using the remaining rules in this list</li>\n<li>this argument may be declared as <code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code>, if it really is just an unknown pointer</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code><ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Any</span></code></li>\n<li>argument value must be a valid Julia object</li>\n<li>currently unsupported by <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cfunction\" title=\"Base.cfunction\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cfunction()</span></code></a></li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">jl_value_t**</span></code><ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ref{Any}</span></code></li>\n<li>argument value must be a valid Julia object (or <code class=\"docutils literal\"><span class=\"pre\">C_NULL</span></code>)</li>\n<li>currently unsupported by <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cfunction\" title=\"Base.cfunction\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cfunction()</span></code></a></li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">T*</span></code><ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is the Julia type corresponding to <code class=\"docutils literal\"><span class=\"pre\">T</span></code></li>\n<li>argument value will be copied if it is an <code class=\"docutils literal\"><span class=\"pre\">isbits</span></code> type\notherwise, the value must be a valid Julia object</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">(T*)(...)</span></code> (e.g. a pointer to a function)<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code> (you may need to use <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cfunction\" title=\"Base.cfunction\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cfunction()</span></code></a> explicitly to create this pointer)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">...</span></code> (e.g. a vararg)<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">T...</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is the Julia type</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">va_arg</span></code><ul>\n<li>not supported</li>\n</ul>\n</li>\n</ul>\n</div>\n<div class=\"section\" id=\"ccall-cfunction-return-type-translation-guide\">\n<h3><code class=\"docutils literal\"><span class=\"pre\">ccall</span></code>/<code class=\"docutils literal\"><span class=\"pre\">cfunction</span></code> return type translation guide<a class=\"headerlink\" href=\"#ccall-cfunction-return-type-translation-guide\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>For translating a C return type to Julia:</p>\n<ul class=\"simple\">\n<li><code class=\"docutils literal\"><span class=\"pre\">void</span></code><ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Void</span></code> (this will return the singleton instance <code class=\"docutils literal\"><span class=\"pre\">nothing::Void</span></code>)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">T</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is one of the primitive types:\n<code class=\"docutils literal\"><span class=\"pre\">char</span></code>, <code class=\"docutils literal\"><span class=\"pre\">int</span></code>, <code class=\"docutils literal\"><span class=\"pre\">long</span></code>, <code class=\"docutils literal\"><span class=\"pre\">short</span></code>, <code class=\"docutils literal\"><span class=\"pre\">float</span></code>, <code class=\"docutils literal\"><span class=\"pre\">double</span></code>, <code class=\"docutils literal\"><span class=\"pre\">complex</span></code>, <code class=\"docutils literal\"><span class=\"pre\">enum</span></code>\nor any of their <code class=\"docutils literal\"><span class=\"pre\">typedef</span></code> equivalents<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">T</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is an equivalent Julia Bits Type (per the table above)</li>\n<li>if <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is an <code class=\"docutils literal\"><span class=\"pre\">enum</span></code>, the argument type should be equivalent to <code class=\"docutils literal\"><span class=\"pre\">Cint</span></code> or <code class=\"docutils literal\"><span class=\"pre\">Cuint</span></code></li>\n<li>argument value will be copied (returned by-value)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">struct</span> <span class=\"pre\">T</span></code> (including typedef to a struct)<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">T</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is a Julia Leaf Type</li>\n<li>argument value will be copied (returned by-value)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">void*</span></code><ul>\n<li>depends on how this parameter is used, first translate this to the intended pointer type,\nthen determine the Julia equivalent using the remaining rules in this list</li>\n<li>this argument may be declared as <code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code>, if it really is just an unknown pointer</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code><ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Any</span></code></li>\n<li>argument value must be a valid Julia object</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">jl_value_t**</span></code><ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ref{Any}</span></code></li>\n<li>argument value must be a valid Julia object (or <code class=\"docutils literal\"><span class=\"pre\">C_NULL</span></code>)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">T*</span></code><ul>\n<li>If the memory is already owned by Julia, or is an <code class=\"docutils literal\"><span class=\"pre\">isbits</span></code> type, and is known to be non-null:<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is the Julia type corresponding to <code class=\"docutils literal\"><span class=\"pre\">T</span></code></li>\n<li>a return type of <code class=\"docutils literal\"><span class=\"pre\">Ref{Any}</span></code> is invalid, it should either be <code class=\"docutils literal\"><span class=\"pre\">Any</span></code>\n(corresponding to <code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code>) or <code class=\"docutils literal\"><span class=\"pre\">Ptr{Any}</span></code> (corresponding to <code class=\"docutils literal\"><span class=\"pre\">Ptr{Any}</span></code>)</li>\n<li>C <strong>MUST NOT</strong> modify the memory returned via <code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code> if <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is an <code class=\"docutils literal\"><span class=\"pre\">isbits</span></code> type</li>\n</ul>\n</li>\n<li>If the memory is owned by C:<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is the Julia type corresponding to <code class=\"docutils literal\"><span class=\"pre\">T</span></code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">(T*)(...)</span></code> (e.g. a pointer to a function)<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code> (you may need to use <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cfunction\" title=\"Base.cfunction\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cfunction()</span></code></a> explicitly to create this pointer)</li>\n</ul>\n</li>\n</ul>\n</div>\n<div class=\"section\" id=\"passing-pointers-for-modifying-inputs\">\n<h3>Passing Pointers for Modifying Inputs<a class=\"headerlink\" href=\"#passing-pointers-for-modifying-inputs\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>Because C doesn&#8217;t support multiple return values,\noften C functions will take pointers to data that the function will modify.\nTo accomplish this within a <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a>,\nyou need to first encapsulate the value inside an <code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code> of the appropriate type.\nWhen you pass this <code class=\"docutils literal\"><span class=\"pre\">Ref</span></code> object as an argument,\nJulia will automatically pass a C pointer to the encapsulated data:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">width</span> <span class=\"o\">=</span> <span class=\"kt\">Ref</span><span class=\"p\">{</span><span class=\"kt\">Cint</span><span class=\"p\">}(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">range</span> <span class=\"o\">=</span> <span class=\"kt\">Ref</span><span class=\"p\">{</span><span class=\"kt\">Cfloat</span><span class=\"p\">}(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"k\">ccall</span><span class=\"p\">(</span><span class=\"o\">:</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"kt\">Void</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Ref</span><span class=\"p\">{</span><span class=\"kt\">Cint</span><span class=\"p\">},</span> <span class=\"kt\">Ref</span><span class=\"p\">{</span><span class=\"kt\">Cfloat</span><span class=\"p\">}),</span> <span class=\"n\">width</span><span class=\"p\">,</span> <span class=\"n\">range</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Upon return, the contents of <code class=\"docutils literal\"><span class=\"pre\">width</span></code> and <code class=\"docutils literal\"><span class=\"pre\">range</span></code> can be retrieved\n(if they were changed by <code class=\"docutils literal\"><span class=\"pre\">foo</span></code>) by <code class=\"docutils literal\"><span class=\"pre\">width[]</span></code> and <code class=\"docutils literal\"><span class=\"pre\">range[]</span></code>; that is,\nthey act like zero-dimensional arrays.</p>\n</div>\n<div class=\"section\" id=\"special-reference-syntax-for-ccall-deprecated\">\n<h3>Special Reference Syntax for ccall (deprecated):<a class=\"headerlink\" href=\"#special-reference-syntax-for-ccall-deprecated\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>The <code class=\"docutils literal\"><span class=\"pre\">&amp;</span></code> syntax is deprecated, use the <code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code> argument type instead.</p>\n<p>A prefix <code class=\"docutils literal\"><span class=\"pre\">&amp;</span></code> is used on an argument to <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> to indicate that a pointer\nto a scalar argument should be passed instead of the scalar value itself\n(required for all Fortran function arguments, as noted above). The following\nexample computes a dot product using a BLAS function.</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">function</span> <span class=\"n\">compute_dot</span><span class=\"p\">(</span><span class=\"n\">DX</span><span class=\"o\">::</span><span class=\"kt\">Vector</span><span class=\"p\">{</span><span class=\"kt\">Float64</span><span class=\"p\">},</span> <span class=\"n\">DY</span><span class=\"o\">::</span><span class=\"kt\">Vector</span><span class=\"p\">{</span><span class=\"kt\">Float64</span><span class=\"p\">})</span>\n  <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">DX</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">DY</span><span class=\"p\">))</span>\n  <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">DX</span><span class=\"p\">)</span>\n  <span class=\"n\">incx</span> <span class=\"o\">=</span> <span class=\"n\">incy</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n  <span class=\"n\">product</span> <span class=\"o\">=</span> <span class=\"k\">ccall</span><span class=\"p\">((</span><span class=\"o\">:</span><span class=\"n\">ddot_</span><span class=\"p\">,</span> <span class=\"s\">&quot;libLAPACK&quot;</span><span class=\"p\">),</span>\n                  <span class=\"kt\">Float64</span><span class=\"p\">,</span>\n                  <span class=\"p\">(</span><span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Int32</span><span class=\"p\">},</span> <span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Float64</span><span class=\"p\">},</span> <span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Int32</span><span class=\"p\">},</span> <span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Float64</span><span class=\"p\">},</span> <span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Int32</span><span class=\"p\">}),</span>\n                  <span class=\"o\">&amp;</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">DX</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">incx</span><span class=\"p\">,</span> <span class=\"n\">DY</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">incy</span><span class=\"p\">)</span>\n  <span class=\"k\">return</span> <span class=\"n\">product</span>\n<span class=\"k\">end</span>\n</pre></div>\n</div>\n<p>The meaning of prefix <code class=\"docutils literal\"><span class=\"pre\">&amp;</span></code> is not quite the same as in C. In\nparticular, any changes to the referenced variables will not be\nvisible in Julia unless the type is mutable (declared via\n<code class=\"docutils literal\"><span class=\"pre\">type</span></code>). However, even for immutable types it will not cause any\nharm for called functions to attempt such modifications (that is,\nwriting through the passed pointers). Moreover, <code class=\"docutils literal\"><span class=\"pre\">&amp;</span></code> may be used with\nany expression, such as <code class=\"docutils literal\"><span class=\"pre\">&amp;0</span></code> or <code class=\"docutils literal\"><span class=\"pre\">&amp;f(x)</span></code>.</p>\n<p>When a scalar value is passed with <code class=\"docutils literal\"><span class=\"pre\">&amp;</span></code> as an argument of type\n<code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code>, the value will first be converted to type <code class=\"docutils literal\"><span class=\"pre\">T</span></code>.</p>\n</div>\n</div>\n<div class=\"section\" id=\"some-examples-of-c-wrappers\">\n<h2>Some Examples of C Wrappers<a class=\"headerlink\" href=\"#some-examples-of-c-wrappers\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Here is a simple example of a C wrapper that returns a <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> type:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">type</span> <span class=\"n\">gsl_permutation</span>\n<span class=\"k\">end</span>\n\n<span class=\"c\"># The corresponding C signature is</span>\n<span class=\"c\">#     gsl_permutation * gsl_permutation_alloc (size_t n);</span>\n<span class=\"k\">function</span> <span class=\"n\">permutation_alloc</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">::</span><span class=\"kt\">Integer</span><span class=\"p\">)</span>\n    <span class=\"n\">output_ptr</span> <span class=\"o\">=</span> <span class=\"k\">ccall</span><span class=\"p\">(</span>\n        <span class=\"p\">(</span><span class=\"o\">:</span><span class=\"n\">gsl_permutation_alloc</span><span class=\"p\">,</span> <span class=\"o\">:</span><span class=\"n\">libgsl</span><span class=\"p\">),</span> <span class=\"c\">#name of C function and library</span>\n        <span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"n\">gsl_permutation</span><span class=\"p\">},</span>              <span class=\"c\">#output type</span>\n        <span class=\"p\">(</span><span class=\"kt\">Csize_t</span><span class=\"p\">,),</span>                        <span class=\"c\">#tuple of input types</span>\n        <span class=\"n\">n</span>                                  <span class=\"c\">#name of Julia variable to pass in</span>\n    <span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">output_ptr</span><span class=\"o\">==</span><span class=\"nb\">C_NULL</span> <span class=\"c\"># Could not allocate memory</span>\n        <span class=\"n\">throw</span><span class=\"p\">(</span><span class=\"kt\">OutOfMemoryError</span><span class=\"p\">())</span>\n    <span class=\"k\">end</span>\n    <span class=\"k\">return</span> <span class=\"n\">output_ptr</span>\n<span class=\"k\">end</span>\n</pre></div>\n</div>\n<p>The <a class=\"reference external\" href=\"https://www.gnu.org/software/gsl/\">GNU Scientific Library</a> (here assumed\nto be accessible through <code class=\"docutils literal\"><span class=\"pre\">:libgsl</span></code>) defines an opaque pointer,\n<code class=\"docutils literal\"><span class=\"pre\">gsl_permutation</span> <span class=\"pre\">*</span></code>, as the return type of the C function\n<code class=\"docutils literal\"><span class=\"pre\">gsl_permutation_alloc()</span></code>. As user code never has to look inside the\n<code class=\"docutils literal\"><span class=\"pre\">gsl_permutation</span></code> struct, the corresponding Julia wrapper simply needs a new\ntype declaration, <code class=\"docutils literal\"><span class=\"pre\">gsl_permutation</span></code>, that has no internal fields and whose\nsole purpose is to be placed in the type parameter of a <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> type.  The\nreturn type of the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> is declared as <code class=\"docutils literal\"><span class=\"pre\">Ptr{gsl_permutation}</span></code>, since the\nmemory allocated and pointed to by <code class=\"docutils literal\"><span class=\"pre\">output_ptr</span></code> is controlled by C (and not\nJulia).</p>\n<p>The input <code class=\"docutils literal\"><span class=\"pre\">n</span></code> is passed by value, and so the function&#8217;s input signature is\nsimply declared as <code class=\"docutils literal\"><span class=\"pre\">(Csize_t,)</span></code> without any <code class=\"docutils literal\"><span class=\"pre\">Ref</span></code> or <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> necessary.\n(If the wrapper was calling a Fortran function instead, the corresponding\nfunction input signature should instead be <code class=\"docutils literal\"><span class=\"pre\">(Ref{Csize_t},)</span></code>, since Fortran\nvariables are passed by reference.) Furthermore, <code class=\"docutils literal\"><span class=\"pre\">n</span></code> can be any type that is\nconvertable to a <code class=\"docutils literal\"><span class=\"pre\">Csize_t</span></code> integer; the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> implicitly calls\n<a class=\"reference internal\" href=\"../stdlib/c.html#Base.cconvert\" title=\"Base.cconvert\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">Base.cconvert(Csize_t,</span> <span class=\"pre\">n)</span></code></a>.</p>\n<p>Here is a second example wrapping the corresponding destructor:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"c\"># The corresponding C signature is</span>\n<span class=\"c\">#     void gsl_permutation_free (gsl_permutation * p);</span>\n<span class=\"k\">function</span> <span class=\"n\">permutation_free</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">::</span><span class=\"kt\">Ref</span><span class=\"p\">{</span><span class=\"n\">gsl_permutation</span><span class=\"p\">})</span>\n    <span class=\"k\">ccall</span><span class=\"p\">(</span>\n        <span class=\"p\">(</span><span class=\"o\">:</span><span class=\"n\">gsl_permutation_free</span><span class=\"p\">,</span> <span class=\"o\">:</span><span class=\"n\">libgsl</span><span class=\"p\">),</span> <span class=\"c\">#name of C function and library</span>\n        <span class=\"kt\">Void</span><span class=\"p\">,</span>                             <span class=\"c\">#output type</span>\n        <span class=\"p\">(</span><span class=\"kt\">Ref</span><span class=\"p\">{</span><span class=\"n\">gsl_permutation</span><span class=\"p\">},),</span>          <span class=\"c\">#tuple of input types</span>\n        <span class=\"n\">p</span>                                 <span class=\"c\">#name of Julia variable to pass in</span>\n    <span class=\"p\">)</span>\n<span class=\"k\">end</span>\n</pre></div>\n</div>\n<p>Here, the input <code class=\"docutils literal\"><span class=\"pre\">p</span></code> is declared to be of type <code class=\"docutils literal\"><span class=\"pre\">Ref{gsl_permutation}</span></code>,\nmeaning that the memory that <code class=\"docutils literal\"><span class=\"pre\">p</span></code> points to may be managed by Julia or by C.\nA pointer to memory allocated by C should be of type <code class=\"docutils literal\"><span class=\"pre\">Ptr{gsl_permutation}</span></code>,\nbut it is convertable using <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cconvert\" title=\"Base.cconvert\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cconvert()</span></code></a> and therefore can be used in the\nsame (covariant) context of the input argument to a <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a>. A pointer to\nmemory allocated by Julia must be of type <code class=\"docutils literal\"><span class=\"pre\">Ref{gsl_permutation}</span></code>, to ensure\nthat the memory address pointed to is valid and that Julia&#8217;s garbage collector\nmanages the chunk of memory pointed to correctly. Therefore, the\n<code class=\"docutils literal\"><span class=\"pre\">Ref{gsl_permutation}</span></code> declaration allows pointers managed by C or Julia to\nbe used.</p>\n<p>If the C wrapper never expects the user to pass pointers to memory managed by\nJulia, then using <code class=\"docutils literal\"><span class=\"pre\">p::Ptr{gsl_permutation}</span></code> for the method signature of the\nwrapper and similarly in the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> is also acceptable.</p>\n<p>Here is a third example passing Julia arrays:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"c\"># The corresponding C signature is</span>\n<span class=\"c\">#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,</span>\n<span class=\"c\">#                                double result_array[])</span>\n<span class=\"k\">function</span> <span class=\"n\">sf_bessel_Jn_array</span><span class=\"p\">(</span><span class=\"n\">nmin</span><span class=\"o\">::</span><span class=\"kt\">Integer</span><span class=\"p\">,</span> <span class=\"n\">nmax</span><span class=\"o\">::</span><span class=\"kt\">Integer</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"o\">::</span><span class=\"kt\">Real</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">nmax</span><span class=\"o\">&lt;</span><span class=\"n\">nmin</span> <span class=\"n\">throw</span><span class=\"p\">(</span><span class=\"kt\">DomainError</span><span class=\"p\">())</span> <span class=\"k\">end</span>\n    <span class=\"n\">result_array</span> <span class=\"o\">=</span> <span class=\"kt\">Array</span><span class=\"p\">{</span><span class=\"kt\">Cdouble</span><span class=\"p\">}(</span><span class=\"n\">nmax</span><span class=\"o\">-</span><span class=\"n\">nmin</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">errorcode</span> <span class=\"o\">=</span> <span class=\"k\">ccall</span><span class=\"p\">(</span>\n        <span class=\"p\">(</span><span class=\"o\">:</span><span class=\"n\">gsl_sf_bessel_Jn_array</span><span class=\"p\">,</span> <span class=\"o\">:</span><span class=\"n\">libgsl</span><span class=\"p\">),</span> <span class=\"c\">#name of C function and library</span>\n        <span class=\"kt\">Cint</span><span class=\"p\">,</span>                               <span class=\"c\">#output type</span>\n        <span class=\"p\">(</span><span class=\"kt\">Cint</span><span class=\"p\">,</span> <span class=\"kt\">Cint</span><span class=\"p\">,</span> <span class=\"kt\">Cdouble</span><span class=\"p\">,</span> <span class=\"kt\">Ref</span><span class=\"p\">{</span><span class=\"kt\">Cdouble</span><span class=\"p\">}),</span><span class=\"c\">#tuple of input types</span>\n        <span class=\"n\">nmin</span><span class=\"p\">,</span> <span class=\"n\">nmax</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">result_array</span>         <span class=\"c\">#names of Julia variables to pass in</span>\n    <span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">errorcode!</span><span class=\"o\">=</span> <span class=\"mi\">0</span> <span class=\"n\">error</span><span class=\"p\">(</span><span class=\"s\">&quot;GSL error code </span><span class=\"si\">$errorcode</span><span class=\"s\">&quot;</span><span class=\"p\">)</span> <span class=\"k\">end</span>\n    <span class=\"k\">return</span> <span class=\"n\">result_array</span>\n<span class=\"k\">end</span>\n</pre></div>\n</div>\n<p>The C function wrapped returns an integer error code; the results of the actual\nevaluation of the Bessel J function populate the Julia array <code class=\"docutils literal\"><span class=\"pre\">result_array</span></code>.\nThis variable can only be used with corresponding input type declaration\n<code class=\"docutils literal\"><span class=\"pre\">Ref{Cdouble}</span></code>, since its memory is allocated and managed by\nJulia, not C. The implicit call to <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cconvert\" title=\"Base.cconvert\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">Base.cconvert(Ref{Cdouble},</span>\n<span class=\"pre\">result_array)</span></code></a> unpacks the Julia pointer to a Julia array data\nstructure into a form understandable by C.</p>\n<p>Note that for this code to work correctly, <code class=\"docutils literal\"><span class=\"pre\">result_array</span></code> must be declared to\nbe of type <code class=\"docutils literal\"><span class=\"pre\">Ref{Cdouble}</span></code> and not <code class=\"docutils literal\"><span class=\"pre\">Ptr{Cdouble}</span></code>. The memory is managed by\nJulia and the <code class=\"docutils literal\"><span class=\"pre\">Ref</span></code> signature alerts Julia&#8217;s garbage collector to keep\nmanaging the memory for <code class=\"docutils literal\"><span class=\"pre\">result_array</span></code> while the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> executes. If\n<code class=\"docutils literal\"><span class=\"pre\">Ptr{Cdouble}</span></code> were used instead, the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> may still work, but\nJulia&#8217;s garbage collector would not be aware that the memory declared for\n<code class=\"docutils literal\"><span class=\"pre\">result_array</span></code> is being used by the external C function. As a result, the\ncode may produce a memory leak if <code class=\"docutils literal\"><span class=\"pre\">result_array</span></code> never gets freed by the\ngarbage collector, or if the garbage collector prematurely frees\n<code class=\"docutils literal\"><span class=\"pre\">result_array</span></code>, the C function may end up throwing an invalid memory access\nexception.</p>\n</div>\n<div class=\"section\" id=\"garbage-collection-safety\">\n<h2>Garbage Collection Safety<a class=\"headerlink\" href=\"#garbage-collection-safety\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>When passing data to a <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a>, it is best to avoid using the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.pointer\" title=\"Base.pointer\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">pointer()</span></code></a>\nfunction. Instead define a convert method and pass the variables directly to\nthe <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a>. <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> automatically arranges that all of its arguments will be\npreserved from garbage collection until the call returns. If a C API will\nstore a reference to memory allocated by Julia, after the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> returns, you\nmust arrange that the object remains visible to the garbage collector. The\nsuggested way to handle this is to make a global variable of type\n<code class=\"docutils literal\"><span class=\"pre\">Array{Ref,1}</span></code> to hold these values, until the C library notifies you that\nit is finished with them.</p>\n<p>Whenever you have created a pointer to Julia data, you must ensure the original data\nexists until you are done with using the pointer. Many methods in Julia such as\n<a class=\"reference internal\" href=\"../stdlib/c.html#Base.unsafe_load\" title=\"Base.unsafe_load\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">unsafe_load()</span></code></a> and <a class=\"reference internal\" href=\"../stdlib/strings.html#Base.String\" title=\"Base.String\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">String()</span></code></a> make copies of data instead of taking ownership\nof the buffer, so that it is safe to free (or alter) the original data without\naffecting Julia. A notable exception is <a class=\"reference internal\" href=\"../stdlib/strings.html#Base.unsafe_wrap\" title=\"Base.unsafe_wrap\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">unsafe_wrap()</span></code></a> which, for performance\nreasons, shares (or can be told to take ownership of) the underlying buffer.</p>\n<p>The garbage collector does not guarantee any order of finalization. That is, if <code class=\"docutils literal\"><span class=\"pre\">a</span></code>\ncontained a reference to <code class=\"docutils literal\"><span class=\"pre\">b</span></code> and both <code class=\"docutils literal\"><span class=\"pre\">a</span></code> and <code class=\"docutils literal\"><span class=\"pre\">b</span></code> are due for garbage\ncollection, there is no guarantee that <code class=\"docutils literal\"><span class=\"pre\">b</span></code> would be finalized after <code class=\"docutils literal\"><span class=\"pre\">a</span></code>. If\nproper finalization of <code class=\"docutils literal\"><span class=\"pre\">a</span></code> depends on <code class=\"docutils literal\"><span class=\"pre\">b</span></code> being valid, it must be handled in\nother ways.</p>\n</div>\n<div class=\"section\" id=\"non-constant-function-specifications\">\n<h2>Non-constant Function Specifications<a class=\"headerlink\" href=\"#non-constant-function-specifications\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>A <code class=\"docutils literal\"><span class=\"pre\">(name,</span> <span class=\"pre\">library)</span></code> function specification must be a constant expression.\nHowever, it is possible to use computed values as function names by staging\nthrough <code class=\"docutils literal\"><span class=\"pre\">eval</span></code> as follows:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"nd\">@eval</span> <span class=\"k\">ccall</span><span class=\"p\">((</span><span class=\"o\">$</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">(</span><span class=\"s\">&quot;a&quot;</span><span class=\"p\">,</span><span class=\"s\">&quot;b&quot;</span><span class=\"p\">)),</span><span class=\"s\">&quot;lib&quot;</span><span class=\"p\">),</span> <span class=\"o\">...</span>\n</pre></div>\n</div>\n<p>This expression constructs a name using <code class=\"docutils literal\"><span class=\"pre\">string</span></code>, then substitutes this\nname into a new <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> expression, which is then evaluated. Keep in mind that\n<code class=\"docutils literal\"><span class=\"pre\">eval</span></code> only operates at the top level, so within this expression local\nvariables will not be available (unless their values are substituted with\n<code class=\"docutils literal\"><span class=\"pre\">$</span></code>). For this reason, <code class=\"docutils literal\"><span class=\"pre\">eval</span></code> is typically only used to form top-level\ndefinitions, for example when wrapping libraries that contain many\nsimilar functions.</p>\n<p>If your usage is more dynamic, use indirect calls as described in the next section.</p>\n</div>\n<div class=\"section\" id=\"indirect-calls\">\n<h2>Indirect Calls<a class=\"headerlink\" href=\"#indirect-calls\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>The first argument to <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> can also be an expression evaluated at run time.\nIn this case, the expression must evaluate to a <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code>,\nwhich will be used as the address of the native function to call.\nThis behavior occurs when the first <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> argument contains references to non-constants,\nsuch as local variables, function arguments, or non-constant globals.</p>\n<p>For example, you might lookup the function via <code class=\"docutils literal\"><span class=\"pre\">dlsym</span></code>,\nthen cache it in a global variable for that session. For example:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">macro</span> <span class=\"n\">dlsym</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"n\">lib</span><span class=\"p\">)</span>\n    <span class=\"n\">z</span><span class=\"p\">,</span> <span class=\"n\">zlocal</span> <span class=\"o\">=</span> <span class=\"n\">gensym</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">)),</span> <span class=\"n\">gensym</span><span class=\"p\">()</span>\n    <span class=\"n\">eval</span><span class=\"p\">(</span><span class=\"n\">current_module</span><span class=\"p\">(),</span><span class=\"o\">:</span><span class=\"p\">(</span><span class=\"kd\">global</span> <span class=\"o\">$</span><span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"nb\">C_NULL</span><span class=\"p\">))</span>\n    <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"n\">esc</span><span class=\"p\">(</span><span class=\"n\">z</span><span class=\"p\">)</span>\n    <span class=\"k\">quote</span>\n        <span class=\"k\">let</span> <span class=\"o\">$</span><span class=\"n\">zlocal</span><span class=\"o\">::</span><span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Void</span><span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"o\">$</span><span class=\"n\">z</span><span class=\"o\">::</span><span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Void</span><span class=\"p\">}</span>\n            <span class=\"k\">if</span> <span class=\"o\">$</span><span class=\"n\">zlocal</span> <span class=\"o\">==</span> <span class=\"nb\">C_NULL</span>\n               <span class=\"o\">$</span><span class=\"n\">zlocal</span> <span class=\"o\">=</span> <span class=\"n\">dlsym</span><span class=\"p\">(</span><span class=\"o\">$</span><span class=\"p\">(</span><span class=\"n\">esc</span><span class=\"p\">(</span><span class=\"n\">lib</span><span class=\"p\">))</span><span class=\"o\">::</span><span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Void</span><span class=\"p\">},</span> <span class=\"o\">$</span><span class=\"p\">(</span><span class=\"n\">esc</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">)))</span>\n               <span class=\"kd\">global</span> <span class=\"o\">$</span><span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"o\">$</span><span class=\"n\">zlocal</span>\n            <span class=\"k\">end</span>\n            <span class=\"o\">$</span><span class=\"n\">zlocal</span>\n        <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">mylibvar</span> <span class=\"o\">=</span> <span class=\"n\">dlopen</span><span class=\"p\">(</span><span class=\"s\">&quot;mylib&quot;</span><span class=\"p\">)</span>\n<span class=\"k\">ccall</span><span class=\"p\">(</span><span class=\"nd\">@dlsym</span><span class=\"p\">(</span><span class=\"s\">&quot;myfunc&quot;</span><span class=\"p\">,</span> <span class=\"n\">mylibvar</span><span class=\"p\">),</span> <span class=\"kt\">Void</span><span class=\"p\">,</span> <span class=\"p\">())</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"calling-convention\">\n<h2>Calling Convention<a class=\"headerlink\" href=\"#calling-convention\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>The second argument to <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> can optionally be a calling convention\nspecifier (immediately preceding return type). Without any specifier,\nthe platform-default C calling convention is used. Other supported\nconventions are: <code class=\"docutils literal\"><span class=\"pre\">stdcall</span></code>, <code class=\"docutils literal\"><span class=\"pre\">cdecl</span></code>, <code class=\"docutils literal\"><span class=\"pre\">fastcall</span></code>, and <code class=\"docutils literal\"><span class=\"pre\">thiscall</span></code>.\nFor example (from <code class=\"docutils literal\"><span class=\"pre\">base/libc.jl</span></code>) we see the same <code class=\"docutils literal\"><span class=\"pre\">gethostname</span></code> <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> as above,\nbut with the correct signature for Windows:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">hn</span> <span class=\"o\">=</span> <span class=\"kt\">Array</span><span class=\"p\">{</span><span class=\"kt\">UInt8</span><span class=\"p\">}(</span><span class=\"mi\">256</span><span class=\"p\">)</span>\n<span class=\"n\">err</span> <span class=\"o\">=</span> <span class=\"k\">ccall</span><span class=\"p\">(</span><span class=\"o\">:</span><span class=\"n\">gethostname</span><span class=\"p\">,</span> <span class=\"n\">stdcall</span><span class=\"p\">,</span> <span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">UInt8</span><span class=\"p\">},</span> <span class=\"kt\">UInt32</span><span class=\"p\">),</span> <span class=\"n\">hn</span><span class=\"p\">,</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">hn</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<p>For more information, please see the <a class=\"reference external\" href=\"http://llvm.org/docs/LangRef.html#calling-conventions\">LLVM Language Reference</a>.</p>\n</div>\n<div class=\"section\" id=\"accessing-global-variables\">\n<h2>Accessing Global Variables<a class=\"headerlink\" href=\"#accessing-global-variables\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Global variables exported by native libraries can be accessed by name using the\n<a class=\"reference internal\" href=\"../stdlib/c.html#Base.cglobal\" title=\"Base.cglobal\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cglobal()</span></code></a> function. The arguments to <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cglobal\" title=\"Base.cglobal\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cglobal()</span></code></a> are a symbol specification\nidentical to that used by <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a>, and a type describing the value stored in\nthe variable:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span>julia&gt; cglobal((:errno,:libc), Int32)\nPtr{Int32} @0x00007f418d0816b8\n</pre></div>\n</div>\n<p>The result is a pointer giving the address of the value. The value can be\nmanipulated through this pointer using <a class=\"reference internal\" href=\"../stdlib/c.html#Base.unsafe_load\" title=\"Base.unsafe_load\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">unsafe_load()</span></code></a> and <a class=\"reference internal\" href=\"../stdlib/c.html#Base.unsafe_store!\" title=\"Base.unsafe_store!\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">unsafe_store!()</span></code></a>.</p>\n</div>\n<div class=\"section\" id=\"accessing-data-through-a-pointer\">\n<h2>Accessing Data through a Pointer<a class=\"headerlink\" href=\"#accessing-data-through-a-pointer\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>The following methods are described as &#8220;unsafe&#8221; because a bad pointer\nor type declaration can cause Julia to terminate abruptly.</p>\n<p>Given a <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code>, the contents of type <code class=\"docutils literal\"><span class=\"pre\">T</span></code> can generally be copied from\nthe referenced memory into a Julia object using <code class=\"docutils literal\"><span class=\"pre\">unsafe_load(ptr,</span> <span class=\"pre\">[index])</span></code>.\nThe index argument is optional (default is 1),\nand follows the Julia-convention of 1-based indexing.\nThis function is intentionally similar to the behavior of <a class=\"reference internal\" href=\"../stdlib/collections.html#Base.getindex\" title=\"Base.getindex\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">getindex()</span></code></a> and <a class=\"reference internal\" href=\"../stdlib/collections.html#Base.setindex!\" title=\"Base.setindex!\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">setindex!()</span></code></a>\n(e.g. <code class=\"docutils literal\"><span class=\"pre\">[]</span></code> access syntax).</p>\n<p>The return value will be a new object initialized\nto contain a copy of the contents of the referenced memory.\nThe referenced memory can safely be freed or released.</p>\n<p>If <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is <code class=\"docutils literal\"><span class=\"pre\">Any</span></code>, then the memory is assumed to contain a reference to\na Julia object (a <code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code>), the result will be a reference to this object,\nand the object will not be copied. You must be careful in this case to ensure\nthat the object was always visible to the garbage collector (pointers do not\ncount, but the new reference does) to ensure the memory is not prematurely freed.\nNote that if the object was not originally allocated by Julia, the new object\nwill never be finalized by Julia&#8217;s garbage collector.  If the <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> itself\nis actually a <code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code>, it can be converted back to a Julia object\nreference by <a class=\"reference internal\" href=\"../stdlib/c.html#Base.unsafe_pointer_to_objref\" title=\"Base.unsafe_pointer_to_objref\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">unsafe_pointer_to_objref(ptr)</span></code></a>.\n(Julia values <code class=\"docutils literal\"><span class=\"pre\">v</span></code> can be converted to <code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code> pointers, as\n<code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code>, by calling <a class=\"reference internal\" href=\"../stdlib/c.html#Base.pointer_from_objref\" title=\"Base.pointer_from_objref\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">pointer_from_objref(v)</span></code></a>.)</p>\n<p>The reverse operation (writing data to a <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code>), can be performed using\n<a class=\"reference internal\" href=\"../stdlib/c.html#Base.unsafe_store!\" title=\"Base.unsafe_store!\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">unsafe_store!(ptr,</span> <span class=\"pre\">value,</span> <span class=\"pre\">[index])</span></code></a>.  Currently, this is only supported\nfor bitstypes or other pointer-free (<code class=\"docutils literal\"><span class=\"pre\">isbits</span></code>) immutable types.</p>\n<p>Any operation that throws an error is probably currently unimplemented\nand should be posted as a bug so that it can be resolved.</p>\n<p>If the pointer of interest is a plain-data array (bitstype or immutable), the\nfunction <a class=\"reference internal\" href=\"../stdlib/strings.html#Base.unsafe_wrap\" title=\"Base.unsafe_wrap\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">unsafe_wrap(Array,</span> <span class=\"pre\">ptr,dims,[own])</span></code></a> may be\nmore useful. The final parameter should be true if Julia should &#8220;take\nownership&#8221; of the underlying buffer and call <code class=\"docutils literal\"><span class=\"pre\">free(ptr)</span></code> when the returned\n<code class=\"docutils literal\"><span class=\"pre\">Array</span></code> object is finalized.  If the <code class=\"docutils literal\"><span class=\"pre\">own</span></code> parameter is omitted or false,\nthe caller must ensure the buffer remains in existence until all access is\ncomplete.</p>\n<p>Arithmetic on the <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> type in Julia (e.g. using <code class=\"docutils literal\"><span class=\"pre\">+</span></code>) does not behave the\nsame as C&#8217;s pointer arithmetic. Adding an integer to a <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> in Julia always\nmoves the pointer by some number of <em>bytes</em>, not elements. This way, the\naddress values obtained from pointer arithmetic do not depend on the\nelement types of pointers.</p>\n</div>\n<div class=\"section\" id=\"thread-safety\">\n<h2>Thread-safety<a class=\"headerlink\" href=\"#thread-safety\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Some C libraries execute their callbacks from a different thread, and\nsince Julia isn&#8217;t thread-safe you&#8217;ll need to take some extra\nprecautions. In particular, you&#8217;ll need to set up a two-layered\nsystem: the C callback should only <em>schedule</em> (via Julia&#8217;s event loop)\nthe execution of your &#8220;real&#8221; callback.\nTo do this, create a <code class=\"docutils literal\"><span class=\"pre\">AsyncCondition</span></code> object and wait on it:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">cond</span> <span class=\"o\">=</span> <span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">AsyncCondition</span><span class=\"p\">()</span>\n<span class=\"n\">wait</span><span class=\"p\">(</span><span class=\"n\">cond</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>The callback you pass to C should only execute a <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> to\n<code class=\"docutils literal\"><span class=\"pre\">:uv_async_send</span></code>, passing <code class=\"docutils literal\"><span class=\"pre\">cb.handle</span></code> as the argument,\ntaking care to avoid any allocations or other interactions with the Julia runtime.</p>\n<p>Note that events may be coalesced, so multiple calls to uv_async_send\nmay result in a single wakeup notification to the condition.</p>\n</div>\n<div class=\"section\" id=\"more-about-callbacks\">\n<h2>More About Callbacks<a class=\"headerlink\" href=\"#more-about-callbacks\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>For more details on how to pass callbacks to C libraries, see this\n<a class=\"reference external\" href=\"http://julialang.org/blog/2013/05/callback\">blog post</a>.</p>\n</div>\n<div class=\"section\" id=\"c\">\n<h2>C++<a class=\"headerlink\" href=\"#c\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Limited support for C++ is provided by the <a class=\"reference external\" href=\"https://github.com/timholy/Cpp.jl\">Cpp</a>,\n<a class=\"reference external\" href=\"https://github.com/ihnorton/Clang.jl\">Clang</a>, and <a class=\"reference external\" href=\"https://github.com/Keno/Cxx.jl\">Cxx</a> packages.</p>\n</div>\n</div>\n\n\n          </div>\n          <footer>\n  \n    <div class=\"rst-footer-buttons\" role=\"navigation\" aria-label=\"footer navigation\">\n      \n        <a href=\"handling-operating-system-variation.html\" class=\"btn btn-neutral float-right\" title=\"Handling Operating System Variation\">Next <span class=\"fa fa-arrow-circle-right\"></span></a>\n      \n      \n        <a href=\"running-external-programs.html\" class=\"btn btn-neutral\" title=\"Running External Programs\"><span class=\"fa fa-arrow-circle-left\"></span> Previous</a>\n      \n    </div>\n  \n\n  <hr/>\n\n  <div role=\"contentinfo\">\n    <p>\n    </p>\n  </div>\n\n  <a href=\"https://github.com/snide/sphinx_rtd_theme\">Sphinx theme</a> provided by <a href=\"https://readthedocs.org\">Read the Docs</a>\n</footer>\n        </div>\n      </div>\n\n    </section>\n\n  </div>\n  \n\n  \n\n    <script type=\"text/javascript\">\n        var DOCUMENTATION_OPTIONS = {\n            URL_ROOT:'../',\n            VERSION:'0.5.1',\n            COLLAPSE_INDEX:false,\n            FILE_SUFFIX:'.html',\n            HAS_SOURCE:  true\n        };\n    </script>\n      <script type=\"text/javascript\" src=\"../_static/jquery.js\"></script>\n      <script type=\"text/javascript\" src=\"../_static/underscore.js\"></script>\n      <script type=\"text/javascript\" src=\"../_static/doctools.js\"></script>\n      <script type=\"text/javascript\" src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>\n\n  \n\n  \n  \n    <script type=\"text/javascript\" src=\"../_static/js/theme.js\"></script>\n  \n\n  \n  \n  <script type=\"text/javascript\">\n      jQuery(function () {\n          SphinxRtdTheme.StickyNav.enable();\n      });\n  </script>\n   \n\n</body>\n</html>",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/stdlib/libdl.rst": ".. module:: Libdl\n\n****************\n Dynamic Linker\n****************\n\n.. currentmodule:: Base.Libdl\n\nThe names in :mod:`Base.Libdl` are not exported and need to be called e.g. as ``Libdl.dlopen()``.\n\n.. function:: dlopen(libfile::AbstractString [, flags::Integer])\n\n   .. Docstring generated from Julia source\n\n   Load a shared library, returning an opaque handle.\n\n   The optional flags argument is a bitwise-or of zero or more of ``RTLD_LOCAL``\\ , ``RTLD_GLOBAL``\\ , ``RTLD_LAZY``\\ , ``RTLD_NOW``\\ , ``RTLD_NODELETE``\\ , ``RTLD_NOLOAD``\\ , ``RTLD_DEEPBIND``\\ , and ``RTLD_FIRST``\\ . These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default ``dlopen`` flags are ``RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL`` while on other platforms the defaults are ``RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL``\\ . An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance ``RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL`` allows the library's symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.\n\n.. function:: dlopen_e(libfile::AbstractString [, flags::Integer])\n\n   .. Docstring generated from Julia source\n\n   Similar to :func:`dlopen`\\ , except returns a ``NULL`` pointer instead of raising errors.\n\n.. data:: RTLD_DEEPBIND\n          RTLD_FIRST\n          RTLD_GLOBAL\n          RTLD_LAZY\n          RTLD_LOCAL\n          RTLD_NODELETE\n          RTLD_NOLOAD\n          RTLD_NOW\n\n   .. Docstring generated from Julia source\n\n   Enum constant for :func:`dlopen`\\ . See your platform man page for details, if applicable.\n\n.. function:: dlsym(handle, sym)\n\n   .. Docstring generated from Julia source\n\n   Look up a symbol from a shared library handle, return callable function pointer on success.\n\n.. function:: dlsym_e(handle, sym)\n\n   .. Docstring generated from Julia source\n\n   Look up a symbol from a shared library handle, silently return ``NULL`` pointer on lookup failure.\n\n.. function:: dlclose(handle)\n\n   .. Docstring generated from Julia source\n\n   Close shared library referenced by handle.\n\n.. data:: dlext\n\n   .. Docstring generated from Julia source\n\n   File extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.\n\n.. function:: find_library(names, locations)\n\n   .. Docstring generated from Julia source\n\n   Searches for the first library in ``names`` in the paths in the ``locations`` list, ``DL_LOAD_PATH``\\ , or system library paths (in that order) which can successfully be dlopen'd. On success, the return value will be one of the names (potentially prefixed by one of the paths in locations). This string can be assigned to a ``global const`` and used as the library name in future ``ccall``\\ 's. On failure, it returns the empty string.\n\n.. data:: DL_LOAD_PATH\n\n   .. Docstring generated from Julia source\n\n   When calling :func:`dlopen`\\ , the paths in this list will be searched first, in order, before searching the system locations for a valid library handle.\n\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/manual/calling-c-and-fortran-code.rst": ".. _man-calling-c-and-fortran-code:\n\n.. currentmodule:: Base\n\n****************************\n Calling C and Fortran Code\n****************************\n\nThough most code can be written in Julia, there are many high-quality,\nmature libraries for numerical computing already written in C and\nFortran. To allow easy use of this existing code, Julia makes it simple\nand efficient to call C and Fortran functions. Julia has a \"no\nboilerplate\" philosophy: functions can be called directly from Julia\nwithout any \"glue\" code, code generation, or compilation \u2014 even from the\ninteractive prompt. This is accomplished just by making an appropriate call\nwith :func:`ccall` syntax, which looks like an ordinary function call.\n\nThe code to be called must be available as a shared library. Most C and\nFortran libraries ship compiled as shared libraries already, but if you\nare compiling the code yourself using GCC (or Clang), you will need to\nuse the ``-shared`` and ``-fPIC`` options. The machine instructions\ngenerated by Julia's JIT are the same as a native C call would be, so\nthe resulting overhead is the same as calling a library function from C\ncode. (Non-library function calls in both C and Julia can be inlined and\nthus may have even less overhead than calls to shared library functions.\nWhen both libraries and executables are generated by LLVM, it is\npossible to perform whole-program optimizations that can even optimize\nacross this boundary, but Julia does not yet support that. In the\nfuture, however, it may do so, yielding even greater performance gains.)\n\nShared libraries and functions are referenced by a tuple of the\nform ``(:function, \"library\")`` or ``(\"function\", \"library\")`` where ``function``\nis the C-exported function name. ``library`` refers to the shared library\nname: shared libraries available in the (platform-specific) load path\nwill be resolved by name, and if necessary a direct path may be specified.\n\nA function name may be used alone in place of the tuple (just\n``:function`` or ``\"function\"``). In this case the name is resolved within\nthe current process. This form can be used to call C library functions,\nfunctions in the Julia runtime, or functions in an application linked to\nJulia.\n\nBy default, Fortran compilers `generate mangled names\n<https://en.wikipedia.org/wiki/Name_mangling#Fortran>`_\n(for example, converting function names to lowercase or uppercase,\noften appending an underscore), and so to call a Fortran function via\n:func:`ccall` you must pass the mangled identifier corresponding to the rule\nfollowed by your Fortran compiler.  Also, when calling a Fortran\nfunction, all inputs must be passed by reference.\n\nFinally, you can use :func:`ccall` to actually generate a call to the\nlibrary function. Arguments to :func:`ccall` are as follows:\n\n1. (:function, \"library\") pair (must be a constant, but see below).\n\n2. Return type (see below for mapping the declared C type to Julia)\n\n   - This argument will be evaluated at compile-time.\n\n3. A tuple of input types. The input types must be written as a literal tuple,\n   not a tuple-valued variable or expression.\n\n   - This argument will be evaluated at compile-time.\n\n4. The following arguments, if any, are the actual argument values\n   passed to the function.\n\nAs a complete but simple example, the following calls the ``clock``\nfunction from the standard C library::\n\n    julia> t = ccall( (:clock, \"libc\"), Int32, ())\n    2292761\n\n    julia> t\n    2292761\n\n    julia> typeof(ans)\n    Int32\n\n``clock`` takes no arguments and returns an ``Int32``. One common gotcha\nis that a 1-tuple must be written with a trailing comma. For\nexample, to call the ``getenv`` function to get a pointer to the value\nof an environment variable, one makes a call like this::\n\n    julia> path = ccall((:getenv, \"libc\"), Cstring, (Cstring,), \"SHELL\")\n    Cstring(@0x00007fff5fbffc45)\n\n    julia> unsafe_string(path)\n    \"/bin/bash\"\n\nNote that the argument type tuple must be written as ``(Cstring,)``,\nrather than ``(Cstring)``. This is because ``(Cstring)`` is just\nthe expression ``Cstring`` surrounded by parentheses, rather than\na 1-tuple containing ``Cstring``:\n\n.. doctest::\n\n    julia> (Cstring)\n    Cstring\n\n    julia> (Cstring,)\n    (Cstring,)\n\nIn practice, especially when providing reusable functionality, one\ngenerally wraps :func:`ccall` uses in Julia functions that set up arguments\nand then check for errors in whatever manner the C or Fortran function\nindicates them, propagating to the Julia caller as exceptions. This is\nespecially important since C and Fortran APIs are notoriously\ninconsistent about how they indicate error conditions. For example, the\n``getenv`` C library function is wrapped in the following Julia function,\nwhich is a simplified version of the actual definition from\n`env.jl <https://github.com/JuliaLang/julia/blob/release-0.5/base/env.jl>`_::\n\n    function getenv(var::AbstractString)\n      val = ccall((:getenv, \"libc\"),\n                  Cstring, (Cstring,), var)\n      if val == C_NULL\n        error(\"getenv: undefined variable: \", var)\n      end\n      unsafe_string(val)\n    end\n\nThe C ``getenv`` function indicates an error by returning ``NULL``, but\nother standard C functions indicate errors in various different ways,\nincluding by returning -1, 0, 1 and other special values. This wrapper\nthrows an exception clearly indicating the problem if the caller tries\nto get a non-existent environment variable::\n\n    julia> getenv(\"SHELL\")\n    \"/bin/bash\"\n\n    julia> getenv(\"FOOBAR\")\n    getenv: undefined variable: FOOBAR\n\nHere is a slightly more complex example that discovers the local\nmachine's hostname::\n\n    function gethostname()\n      hostname = Array{UInt8}(128)\n      ccall((:gethostname, \"libc\"), Int32,\n            (Ptr{UInt8}, Csize_t),\n            hostname, sizeof(hostname))\n      hostname[end] = 0; # ensure null-termination\n      return unsafe_string(pointer(hostname))\n    end\n\nThis example first allocates an array of bytes, then calls the C library\nfunction ``gethostname`` to fill the array in with the hostname, takes a\npointer to the hostname buffer, and converts the pointer to a Julia\nstring, assuming that it is a NUL-terminated C string. It is common for\nC libraries to use this pattern of requiring the caller to allocate\nmemory to be passed to the callee and filled in. Allocation of memory\nfrom Julia like this is generally accomplished by creating an\nuninitialized array and passing a pointer to its data to the C function.\nThis is why we don't use the ``Cstring`` type here: as the array is\nuninitialized, it could contain NUL bytes. Converting to a ``Cstring`` as\npart of the :func:`ccall` checks for contained NUL bytes and could therefore\nthrow a conversion error.\n\nCreating C-Compatible Julia Function Pointers\n---------------------------------------------\n\nIt is possible to pass Julia functions to native C functions that accept\nfunction pointer arguments. For example, to match C prototypes of the form::\n\n    typedef returntype (*functiontype)(argumenttype,...)\n\nThe function :func:`cfunction` generates the C-compatible function pointer for\na call to a Julia library function.\nArguments to :func:`cfunction` are as follows:\n\n1. A Julia Function\n\n2. Return type\n\n3. A tuple of input types\n\nA classic example is the standard C library ``qsort`` function,\ndeclared as::\n\n    void qsort(void *base, size_t nmemb, size_t size,\n               int(*compare)(const void *a, const void *b));\n\nThe ``base`` argument is a pointer to an array of length ``nmemb``, with elements of\n``size`` bytes each. ``compare`` is a callback function which takes pointers to two\nelements ``a`` and ``b`` and returns an integer less/greater than zero if ``a`` should\nappear before/after ``b`` (or zero if any order is permitted). Now, suppose that we\nhave a 1d array ``A`` of values in Julia that we want to sort using the ``qsort``\nfunction (rather than Julia's built-in ``sort`` function). Before we worry about calling\n``qsort`` and passing arguments, we need to write a comparison function that works for\nsome arbitrary type T::\n\n    function mycompare{T}(a::T, b::T)\n        return convert(Cint, a < b ? -1 : a > b ? +1 : 0)::Cint\n    end\n\nNotice that we have to be careful about the return type: ``qsort`` expects a function\nreturning a C ``int``, so we must be sure to return ``Cint`` via a call to ``convert``\nand a ``typeassert``.\n\nIn order to pass this function to C, we obtain its address using the function ``cfunction``::\n\n    const mycompare_c = cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}))\n\n:func:`cfunction` accepts three arguments: the Julia function (``mycompare``),\nthe return type (``Cint``), and a tuple of the argument types, in this case to\nsort an array of ``Cdouble`` (``Float64``) elements.\n\nThe final call to ``qsort`` looks like this::\n\n    A = [1.3, -2.7, 4.4, 3.1]\n    ccall(:qsort, Void, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Void}),\n          A, length(A), sizeof(eltype(A)), mycompare_c)\n\nAfter this executes, ``A`` is changed to the sorted array ``[-2.7, 1.3, 3.1, 4.4]``.\nNote that Julia knows how to convert an array into a ``Ptr{Cdouble}``, how to compute\nthe size of a type in bytes (identical to C's ``sizeof`` operator), and so on.\nFor fun, try inserting a ``println(\"mycompare($a,$b)\")`` line into ``mycompare``, which\nwill allow you to see the comparisons that ``qsort`` is performing (and to verify that\nit is really calling the Julia function that you passed to it).\n\n\nMapping C Types to Julia\n------------------------\n\nIt is critical to exactly match the declared C type with its declaration\nin Julia. Inconsistencies can cause code that works correctly on one system\nto fail or produce indeterminate results on a different system.\n\nNote that no C header files are used anywhere in the process of calling C\nfunctions: you are responsible for making sure that your Julia types and\ncall signatures accurately reflect those in the C header file. (The `Clang\npackage <https://github.com/ihnorton/Clang.jl>`_ can be used to auto-generate\nJulia code from a C header file.)\n\nAuto-conversion:\n~~~~~~~~~~~~~~~~\n\nJulia automatically inserts calls to the :func:`cconvert` function to convert\neach argument to the specified type. For example, the following call::\n\n    ccall((:foo, \"libfoo\"), Void, (Int32, Float64), x, y)\n\nwill behave as if the following were written::\n\n    ccall((:foo, \"libfoo\"), Void, (Int32, Float64),\n          Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),\n          Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))\n\n:func:`cconvert` normally just calls :func:`convert`, but can be defined to return\nan arbitrary new object more appropriate for passing to C. For example,\nthis is used to convert an ``Array`` of objects (e.g. strings) to an\narray of pointers.\n\n:func:`unsafe_convert` handles conversion to ``Ptr`` types. It is considered\nunsafe because converting an object to a native pointer can hide the object\nfrom the garbage collector, causing it to be freed prematurely.\n\nType Correspondences:\n~~~~~~~~~~~~~~~~~~~~~\n\nFirst, a review of some relevant Julia type terminology:\n\n.. rst-class:: text-wrap\n\n==============================  ==============================  ======================================================\nSyntax / Keyword                Example                         Description\n==============================  ==============================  ======================================================\n``type``                        ``String``                      \"Leaf Type\" :: A group of related data that includes\n                                                                a type-tag, is managed by the Julia GC, and\n                                                                is defined by object-identity.\n                                                                The type parameters of a leaf type must be fully defined\n                                                                (no ``TypeVars`` are allowed)\n                                                                in order for the instance to be constructed.\n\n``abstract``                    ``Any``,                        \"Super Type\" :: A super-type (not a leaf-type)\n                                ``AbstractArray{T,N}``,         that cannot be instantiated, but can be used to\n                                ``Complex{T}``                  describe a group of types.\n\n``{T}``                         ``Vector{Int}``                 \"Type Parameter\" :: A specialization of a type\n                                                                (typically used for dispatch or storage optimization).\n\n                                                                \"TypeVar\" :: The ``T`` in the type parameter declaration\n                                                                is referred to as a TypeVar (short for type variable).\n\n``bitstype``                    ``Int``,                        \"Bits Type\" :: A type with no fields, but a size. It\n                                ``Float64``                     is stored and defined by-value.\n\n``immutable``                   ``Pair{Int,Int}``               \"Immutable\" :: A type with all fields defined to be\n                                                                constant. It is defined by-value. And may be stored\n                                                                with a type-tag.\n\n                                ``Complex128`` (``isbits``)     \"Is-Bits\" :: A ``bitstype``, or an ``immutable`` type\n                                                                where all fields are other ``isbits`` types. It is\n                                                                defined by-value, and is stored without a type-tag.\n\n``type ...; end``               ``nothing``                     \"Singleton\" :: a Leaf Type or Immutable with no fields.\n\n``(...)`` or ``tuple(...)```    ``(1,2,3)``                     \"Tuple\" :: an immutable data-structure similar to an\n                                                                anonymous immutable type, or a constant array.\n                                                                Represented as either an array or a struct.\n\n``typealias``                   Not applicable here             Type aliases, and other similar mechanisms of\n                                                                doing type indirection, are resolved to their base\n                                                                type (this includes assigning a type to another name,\n                                                                or getting the type out of a function call).\n==============================  ==============================  ======================================================\n\nBits Types:\n~~~~~~~~~~~\n\nThere are several special types to be aware of, as no other type can be defined to behave the same:\n\n``Float32``\n    Exactly corresponds to the ``float`` type in C (or ``REAL*4`` in Fortran).\n\n``Float64``\n    Exactly corresponds to the ``double`` type in C (or ``REAL*8`` in Fortran).\n\n``Complex64``\n    Exactly corresponds to the ``complex float`` type in C (or ``COMPLEX*8`` in Fortran).\n\n``Complex128``\n    Exactly corresponds to the ``complex double`` type in C (or ``COMPLEX*16`` in Fortran).\n\n``Signed``\n    Exactly corresponds to the ``signed`` type annotation in C (or any ``INTEGER`` type in Fortran). Any Julia type that is not a subtype of ``Signed`` is assumed to be unsigned.\n\n``Ref{T}``\n    Behaves like a ``Ptr{T}`` that owns its memory.\n\n``Array{T,N}``\n    When an array is passed to C as a ``Ptr{T}`` argument, it is\n    not reinterpret-cast: Julia requires that the element type of the\n    array matches ``T``, and the address of the first element is passed.\n\n    Therefore, if an ``Array`` contains data in the wrong format, it will\n    have to be explicitly converted using a call such as ``trunc(Int32,a)``.\n\n    To pass an array ``A`` as a pointer of a different type *without*\n    converting the data beforehand (for example, to pass a ``Float64`` array\n    to a function that operates on uninterpreted bytes), you can\n    declare the argument as ``Ptr{Void}``.\n\n    If an array of eltype ``Ptr{T}`` is passed as a ``Ptr{Ptr{T}}`` argument,\n    :func:`Base.cconvert` will attempt to first make a null-terminated copy of the array with\n    each element replaced by its :func:`cconvert` version. This allows, for example, passing an ``argv``\n    pointer array of type ``Vector{String}`` to an argument of type ``Ptr{Ptr{Cchar}}``.\n\nOn all systems we currently support, basic C/C++ value types may be\ntranslated to Julia types as follows. Every C type also has a corresponding\nJulia type with the same name, prefixed by C. This can help for writing portable code (and remembering that an ``int`` in C is not the same as an ``Int`` in Julia).\n\n**System Independent:**\n\n.. rst-class:: text-wrap\n\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| C name                            | Fortran name    | Standard Julia Alias | Julia Base Type                   |\n+===================================+=================+======================+===================================+\n| ``unsigned char``                 | ``CHARACTER``   | ``Cuchar``           | ``UInt8``                         |\n|                                   |                 |                      |                                   |\n| ``bool`` (C++)                    |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``short``                         | ``INTEGER*2``   | ``Cshort``           | ``Int16``                         |\n|                                   |                 |                      |                                   |\n|                                   | ``LOGICAL*2``   |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``unsigned short``                |                 | ``Cushort``          | ``UInt16``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``int``                           | ``INTEGER*4``   | ``Cint``             | ``Int32``                         |\n|                                   |                 |                      |                                   |\n| ``BOOL`` (C, typical)             | ``LOGICAL*4``   |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``unsigned int``                  |                 | ``Cuint``            | ``UInt32``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``long long``                     | ``INTEGER*8``   | ``Clonglong``        | ``Int64``                         |\n|                                   |                 |                      |                                   |\n|                                   | ``LOGICAL*8``   |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``unsigned long long``            |                 | ``Culonglong``       | ``UInt64``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``intmax_t``                      |                 | ``Cintmax_t``        | ``Int64``                         |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``uintmax_t``                     |                 | ``Cuintmax_t``       | ``UInt64``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``float``                         | ``REAL*4i``     | ``Cfloat``           | ``Float32``                       |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``double``                        | ``REAL*8``      | ``Cdouble``          | ``Float64``                       |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``complex float``                 | ``COMPLEX*8``   | ``Complex64``        | ``Complex{Float32}``              |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``complex double``                | ``COMPLEX*16``  | ``Complex128``       | ``Complex{Float64}``              |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``ptrdiff_t``                     |                 | ``Cptrdiff_t``       | ``Int``                           |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``ssize_t``                       |                 | ``Cssize_t``         | ``Int``                           |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``size_t``                        |                 | ``Csize_t``          | ``UInt``                          |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``void``                          |                 |                      | ``Void``                          |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``void`` and                      |                 |                      | ``Union{}``                       |\n| ``[[noreturn]]`` or ``_Noreturn`` |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``void*``                         |                 |                      | ``Ptr{Void}``                     |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``T*`` (where T represents an     |                 |                      | ``Ref{T}``                        |\n| appropriately defined type)       |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``char*``                         | ``CHARACTER*N`` |                      | ``Cstring`` if NUL-terminated, or |\n| (or ``char[]``, e.g. a string)    |                 |                      | ``Ptr{UInt8}`` if not             |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``char**`` (or ``*char[]``)       |                 |                      | ``Ptr{Ptr{UInt8}}``               |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``jl_value_t*``                   |                 |                      | ``Any``                           |\n| (any Julia Type)                  |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``jl_value_t**``                  |                 |                      | ``Ref{Any}``                      |\n| (a reference to a Julia Type)     |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``va_arg``                        |                 |                      | Not supported                     |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``...``                           |                 |                      | ``T...`` (where ``T``             |\n| (variadic function specification) |                 |                      | is one of the above types,        |\n|                                   |                 |                      | variadic functions of different   |\n|                                   |                 |                      | argument types are not supported) |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n\nThe ``Cstring`` type is essentially a synonym for ``Ptr{UInt8}``, except the conversion to ``Cstring`` throws an\nerror if the Julia string contains any embedded NUL characters (which would cause the string to be silently\ntruncated if the C routine treats NUL as the terminator).  If you are passing a ``char*`` to a C routine that\ndoes not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that\nyour Julia string does not contain NUL and want to skip the check, you can use ``Ptr{UInt8}`` as the argument type.\n``Cstring`` can also be used as the :func:`ccall` return type, but in that case it obviously does not introduce any extra\nchecks and is only meant to improve readability of the call.\n\n**System-dependent:**\n\n======================  ======================  =======\nC name                  Standard Julia Alias    Julia Base Type\n======================  ======================  =======\n``char``                ``Cchar``               ``Int8`` (x86, x86_64)\n\n                                                ``UInt8`` (powerpc, arm)\n\n``long``                ``Clong``               ``Int`` (UNIX)\n\n                                                ``Int32`` (Windows)\n\n``unsigned long``       ``Culong``              ``UInt`` (UNIX)\n\n                                                ``UInt32`` (Windows)\n\n``wchar_t``             ``Cwchar_t``            ``Int32`` (UNIX)\n\n                                                ``UInt16`` (Windows)\n======================  ======================  =======\n\n.. note::\n\n    When calling a Fortran function, all inputs must be passed by reference, so\n    all type correspondences above should contain an additional ``Ptr{..}`` or\n    ``Ref{..}`` wrapper around their type specification.\n\n.. warning::\n\n    For string arguments (``char*``) the Julia type should be ``Cstring`` (if NUL-\n    terminated data is expected) or either ``Ptr{Cchar}`` or ``Ptr{UInt8}``\n    otherwise (these two pointer types have the same effect), as described above,\n    not ``String``. Similarly, for array arguments (``T[]`` or ``T*``), the\n    Julia type should again be ``Ptr{T}``, not ``Vector{T}``.\n\n.. warning::\n\n    Julia's ``Char`` type is 32 bits, which is not the same as the wide character\n    type (``wchar_t`` or ``wint_t``) on all platforms.\n\n.. warning::\n\n    A return type of ``Union{}`` means the function will not return\n    i.e. C++11 ``[[noreturn]]`` or C11 ``_Noreturn`` (e.g. ``jl_throw`` or\n    ``longjmp``). Do not use this for functions that return\n    no value (``void``) but do return.\n\n.. note::\n\n    For ``wchar_t*`` arguments, the Julia type should be ``Cwstring`` (if the C\n    routine expects a NUL-terminated string) or ``Ptr{Cwchar_t}`` otherwise. Note\n    also that UTF-8 string data in Julia is internally NUL-terminated, so it can\n    be passed to C functions expecting NUL-terminated data without making a copy\n    (but using the ``Cwstring`` type will cause an error to be thrown if the string\n    itself contains NUL characters).\n\n.. note::\n\n    C functions that take an argument of the type ``char**`` can be called by\n    using a ``Ptr{Ptr{UInt8}}`` type within Julia. For example, C functions of the\n    form::\n\n        int main(int argc, char **argv);\n\n    can be called via the following Julia code::\n\n        argv = [ \"a.out\", \"arg1\", \"arg2\" ]\n        ccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)\n\n.. note::\n\n    A C function declared to return ``Void`` will return the value ``nothing`` in\n    Julia.\n\nStruct Type correspondences\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nComposite types, aka ``struct`` in C or ``TYPE`` in Fortran90\n(or ``STRUCTURE`` / ``RECORD`` in some variants of F77),\ncan be mirrored in Julia by creating a ``type`` or ``immutable``\ndefinition with the same field layout.\n\nWhen used recursively, ``isbits`` types are stored inline.\nAll other types are stored as a pointer to the data.\nWhen mirroring a struct used by-value inside another struct in C,\nit is imperative that you do not attempt to manually copy the fields over,\nas this will not preserve the correct field alignment.\nInstead, declare an immutable ``isbits`` type and use that instead.\nUnnamed structs are not possible in the translation to Julia.\n\nPacked structs and union declarations are not supported by Julia.\n\nYou can get a near approximation of a ``union`` if you know, a priori,\nthe field that will have the greatest size (potentially including padding).\nWhen translating your fields to Julia, declare the Julia field to be only\nof that type.\n\nArrays of parameters must be expanded manually, currently\n(either inline, or in an immutable helper type). For example::\n\n    in C:\n    struct B {\n        int A[3];\n    };\n    b_a_2 = B.A[2];\n\n    in Julia:\n    immutable B_A\n        A_1::Cint\n        A_2::Cint\n        A_3::Cint\n    end\n    type B\n        A::B_A\n    end\n    b_a_2 = B.A.(2)\n\nArrays of unknown size are not supported.\n\nIn the future, some of these restrictions may be reduced or eliminated.\n\nSIMD Values\n~~~~~~~~~~~\n\nNote: This feature is currently implemented on 64-bit x86\nand AArch64 platforms only.\n\nIf a C/C++ routine has an argument or return value that is a native\nSIMD type, the corresponding Julia type is a homogeneous tuple\nof ``VecElement`` that naturally maps to the SIMD type.  Specifically:\n\n    - The tuple must be the same size as the SIMD type.\n      For example, a tuple representing an ``__m128`` on x86\n      must have a size of 16 bytes.\n\n    - The element type of the tuple must be an instance of ``VecElement{T}``\n      where ``T`` is a bitstype that is 1, 2, 4 or 8 bytes.\n\nFor instance, consider this C routine that uses AVX intrinsics::\n\n    #include <immintrin.h>\n\n    __m256 dist( __m256 a, __m256 b ) {\n        return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),\n                                            _mm256_mul_ps(b, b)));\n    }\n\nThe following Julia code calls ``dist`` using ``ccall``::\n\n    typealias m256 NTuple{8,VecElement{Float32}}\n\n    a = m256(ntuple(i->VecElement(sin(Float32(i))),8))\n    b = m256(ntuple(i->VecElement(cos(Float32(i))),8))\n\n    function call_dist(a::m256, b::m256)\n        ccall((:dist, \"libdist\"), m256, (m256, m256), a, b)\n    end\n\n    println(call_dist(a,b))\n\nThe host machine must have the requisite SIMD registers.  For example,\nthe code above will not work on hosts without AVX support.\n\nMemory Ownership\n~~~~~~~~~~~~~~~~\n\n**malloc/free**\n\nMemory allocation and deallocation of such objects must be\nhandled by calls to the appropriate cleanup routines in the libraries\nbeing used, just like in any C program. Do not try to free an object\nreceived from a C library with ``Libc.free`` in Julia, as this may result\nin the ``free`` function being called via the wrong ``libc`` library and\ncause Julia to crash. The reverse (passing an object allocated in Julia\nto be freed by an external library) is equally invalid.\n\nWhen to use T, Ptr{T} and Ref{T}\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn Julia code wrapping calls to external C routines, ordinary (non-pointer)\ndata should be declared to be of type ``T`` inside the :func:`ccall`, as they\nare passed by value.  For C code accepting pointers, ``Ref{T}`` should\ngenerally be used for the types of input arguments, allowing the use of\npointers to memory managed by either Julia or C through the implicit call to\n:func:`cconvert`.  In contrast, pointers returned by the C function called\nshould be declared to be of output type ``Ptr{T}``, reflecting that the memory\npointed to is managed by C only. Pointers contained in C structs should be\nrepresented as fields of type ``Ptr{T}`` within the corresponding Julia\nimmutable types designed to mimic the internal structure of corresponding C\nstructs.\n\nIn Julia code wrapping calls to external Fortran routines, all input arguments\nshould be declared as of type ``Ref{T}``, as Fortran passes all variables by\nreference. The return type should either be ``Void`` for Fortran subroutines,\nor a ``T`` for Fortran functions returning the type ``T``.\n\n\nMapping C Functions to Julia\n----------------------------\n\n``ccall``/``cfunction`` argument translation guide\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor translating a C argument list to Julia:\n\n* ``T``, where ``T`` is one of the primitive types:\n  ``char``, ``int``, ``long``, ``short``, ``float``, ``double``, ``complex``, ``enum``\n  or any of their ``typedef`` equivalents\n\n  + ``T``, where ``T`` is an equivalent Julia Bits Type (per the table above)\n  + if ``T`` is an ``enum``, the argument type should be equivalent to ``Cint`` or ``Cuint``\n  + argument value will be copied (passed by value)\n\n* ``struct T`` (including typedef to a struct)\n\n  + ``T``, where ``T`` is a Julia leaf type\n  + argument value will be copied (passed by value)\n\n* ``void*``\n\n  + depends on how this parameter is used, first translate this to the intended pointer type,\n    then determine the Julia equivalent using the remaining rules in this list\n  + this argument may be declared as ``Ptr{Void}``, if it really is just an unknown pointer\n\n* ``jl_value_t*``\n\n  + ``Any``\n  + argument value must be a valid Julia object\n  + currently unsupported by :func:`cfunction`\n\n* ``jl_value_t**``\n\n  + ``Ref{Any}``\n  + argument value must be a valid Julia object (or ``C_NULL``)\n  + currently unsupported by :func:`cfunction`\n\n* ``T*``\n\n  + ``Ref{T}``, where ``T`` is the Julia type corresponding to ``T``\n  + argument value will be copied if it is an ``isbits`` type\n    otherwise, the value must be a valid Julia object\n\n* ``(T*)(...)`` (e.g. a pointer to a function)\n\n  + ``Ptr{Void}`` (you may need to use :func:`cfunction` explicitly to create this pointer)\n\n* ``...`` (e.g. a vararg)\n\n  + ``T...``, where ``T`` is the Julia type\n\n* ``va_arg``\n\n  + not supported\n\n``ccall``/``cfunction`` return type translation guide\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor translating a C return type to Julia:\n\n* ``void``\n\n  + ``Void`` (this will return the singleton instance ``nothing::Void``)\n\n* ``T``, where ``T`` is one of the primitive types:\n  ``char``, ``int``, ``long``, ``short``, ``float``, ``double``, ``complex``, ``enum``\n  or any of their ``typedef`` equivalents\n\n  + ``T``, where ``T`` is an equivalent Julia Bits Type (per the table above)\n  + if ``T`` is an ``enum``, the argument type should be equivalent to ``Cint`` or ``Cuint``\n  + argument value will be copied (returned by-value)\n\n* ``struct T`` (including typedef to a struct)\n\n  + ``T``, where ``T`` is a Julia Leaf Type\n  + argument value will be copied (returned by-value)\n\n* ``void*``\n\n  + depends on how this parameter is used, first translate this to the intended pointer type,\n    then determine the Julia equivalent using the remaining rules in this list\n  + this argument may be declared as ``Ptr{Void}``, if it really is just an unknown pointer\n\n* ``jl_value_t*``\n\n  + ``Any``\n  + argument value must be a valid Julia object\n\n* ``jl_value_t**``\n\n  + ``Ref{Any}``\n  + argument value must be a valid Julia object (or ``C_NULL``)\n\n* ``T*``\n\n  + If the memory is already owned by Julia, or is an ``isbits`` type, and is known to be non-null:\n\n    + ``Ref{T}``, where ``T`` is the Julia type corresponding to ``T``\n    + a return type of ``Ref{Any}`` is invalid, it should either be ``Any``\n      (corresponding to ``jl_value_t*``) or ``Ptr{Any}`` (corresponding to ``Ptr{Any}``)\n    + C **MUST NOT** modify the memory returned via ``Ref{T}`` if ``T`` is an ``isbits`` type\n\n  + If the memory is owned by C:\n\n    + ``Ptr{T}``, where ``T`` is the Julia type corresponding to ``T``\n\n* ``(T*)(...)`` (e.g. a pointer to a function)\n\n  + ``Ptr{Void}`` (you may need to use :func:`cfunction` explicitly to create this pointer)\n\nPassing Pointers for Modifying Inputs\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBecause C doesn't support multiple return values,\noften C functions will take pointers to data that the function will modify.\nTo accomplish this within a :func:`ccall`,\nyou need to first encapsulate the value inside an ``Ref{T}`` of the appropriate type.\nWhen you pass this ``Ref`` object as an argument,\nJulia will automatically pass a C pointer to the encapsulated data::\n\n    width = Ref{Cint}(0)\n    range = Ref{Cfloat}(0)\n    ccall(:foo, Void, (Ref{Cint}, Ref{Cfloat}), width, range)\n\nUpon return, the contents of ``width`` and ``range`` can be retrieved\n(if they were changed by ``foo``) by ``width[]`` and ``range[]``; that is,\nthey act like zero-dimensional arrays.\n\nSpecial Reference Syntax for ccall (deprecated):\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``&`` syntax is deprecated, use the ``Ref{T}`` argument type instead.\n\nA prefix ``&`` is used on an argument to :func:`ccall` to indicate that a pointer\nto a scalar argument should be passed instead of the scalar value itself\n(required for all Fortran function arguments, as noted above). The following\nexample computes a dot product using a BLAS function.\n\n::\n\n    function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})\n      assert(length(DX) == length(DY))\n      n = length(DX)\n      incx = incy = 1\n      product = ccall((:ddot_, \"libLAPACK\"),\n                      Float64,\n                      (Ptr{Int32}, Ptr{Float64}, Ptr{Int32}, Ptr{Float64}, Ptr{Int32}),\n                      &n, DX, &incx, DY, &incy)\n      return product\n    end\n\nThe meaning of prefix ``&`` is not quite the same as in C. In\nparticular, any changes to the referenced variables will not be\nvisible in Julia unless the type is mutable (declared via\n``type``). However, even for immutable types it will not cause any\nharm for called functions to attempt such modifications (that is,\nwriting through the passed pointers). Moreover, ``&`` may be used with\nany expression, such as ``&0`` or ``&f(x)``.\n\nWhen a scalar value is passed with ``&`` as an argument of type\n``Ptr{T}``, the value will first be converted to type ``T``.\n\nSome Examples of C Wrappers\n---------------------------\n\nHere is a simple example of a C wrapper that returns a ``Ptr`` type::\n\n    type gsl_permutation\n    end\n\n    # The corresponding C signature is\n    #     gsl_permutation * gsl_permutation_alloc (size_t n);\n    function permutation_alloc(n::Integer)\n        output_ptr = ccall(\n            (:gsl_permutation_alloc, :libgsl), #name of C function and library\n            Ptr{gsl_permutation},              #output type\n            (Csize_t,),                        #tuple of input types\n            n                                  #name of Julia variable to pass in\n        )\n        if output_ptr==C_NULL # Could not allocate memory\n            throw(OutOfMemoryError())\n        end\n        return output_ptr\n    end\n\nThe `GNU Scientific Library <https://www.gnu.org/software/gsl/>`_ (here assumed\nto be accessible through ``:libgsl``) defines an opaque pointer,\n``gsl_permutation *``, as the return type of the C function\n``gsl_permutation_alloc()``. As user code never has to look inside the\n``gsl_permutation`` struct, the corresponding Julia wrapper simply needs a new\ntype declaration, ``gsl_permutation``, that has no internal fields and whose\nsole purpose is to be placed in the type parameter of a ``Ptr`` type.  The\nreturn type of the :func:`ccall` is declared as ``Ptr{gsl_permutation}``, since the\nmemory allocated and pointed to by ``output_ptr`` is controlled by C (and not\nJulia).\n\nThe input ``n`` is passed by value, and so the function's input signature is\nsimply declared as ``(Csize_t,)`` without any ``Ref`` or ``Ptr`` necessary.\n(If the wrapper was calling a Fortran function instead, the corresponding\nfunction input signature should instead be ``(Ref{Csize_t},)``, since Fortran\nvariables are passed by reference.) Furthermore, ``n`` can be any type that is\nconvertable to a ``Csize_t`` integer; the :func:`ccall` implicitly calls\n:func:`Base.cconvert(Csize_t, n) <cconvert>`.\n\n\nHere is a second example wrapping the corresponding destructor::\n\n    # The corresponding C signature is\n    #     void gsl_permutation_free (gsl_permutation * p);\n    function permutation_free(p::Ref{gsl_permutation})\n        ccall(\n            (:gsl_permutation_free, :libgsl), #name of C function and library\n            Void,                             #output type\n            (Ref{gsl_permutation},),          #tuple of input types\n            p                                 #name of Julia variable to pass in\n        )\n    end\n\nHere, the input ``p`` is declared to be of type ``Ref{gsl_permutation}``,\nmeaning that the memory that ``p`` points to may be managed by Julia or by C.\nA pointer to memory allocated by C should be of type ``Ptr{gsl_permutation}``,\nbut it is convertable using :func:`cconvert` and therefore can be used in the\nsame (covariant) context of the input argument to a :func:`ccall`. A pointer to\nmemory allocated by Julia must be of type ``Ref{gsl_permutation}``, to ensure\nthat the memory address pointed to is valid and that Julia's garbage collector\nmanages the chunk of memory pointed to correctly. Therefore, the\n``Ref{gsl_permutation}`` declaration allows pointers managed by C or Julia to\nbe used.\n\nIf the C wrapper never expects the user to pass pointers to memory managed by\nJulia, then using ``p::Ptr{gsl_permutation}`` for the method signature of the\nwrapper and similarly in the :func:`ccall` is also acceptable.\n\n\nHere is a third example passing Julia arrays::\n\n    # The corresponding C signature is\n    #    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,\n    #                                double result_array[])\n    function sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)\n        if nmax<nmin throw(DomainError()) end\n        result_array = Array{Cdouble}(nmax-nmin+1)\n        errorcode = ccall(\n            (:gsl_sf_bessel_Jn_array, :libgsl), #name of C function and library\n            Cint,                               #output type\n            (Cint, Cint, Cdouble, Ref{Cdouble}),#tuple of input types\n            nmin, nmax, x, result_array         #names of Julia variables to pass in\n        )\n        if errorcode!= 0 error(\"GSL error code $errorcode\") end\n        return result_array\n    end\n\nThe C function wrapped returns an integer error code; the results of the actual\nevaluation of the Bessel J function populate the Julia array ``result_array``.\nThis variable can only be used with corresponding input type declaration\n``Ref{Cdouble}``, since its memory is allocated and managed by\nJulia, not C. The implicit call to :func:`Base.cconvert(Ref{Cdouble},\nresult_array) <cconvert>` unpacks the Julia pointer to a Julia array data\nstructure into a form understandable by C.\n\nNote that for this code to work correctly, ``result_array`` must be declared to\nbe of type ``Ref{Cdouble}`` and not ``Ptr{Cdouble}``. The memory is managed by\nJulia and the ``Ref`` signature alerts Julia's garbage collector to keep\nmanaging the memory for ``result_array`` while the :func:`ccall` executes. If\n``Ptr{Cdouble}`` were used instead, the :func:`ccall` may still work, but\nJulia's garbage collector would not be aware that the memory declared for\n``result_array`` is being used by the external C function. As a result, the\ncode may produce a memory leak if ``result_array`` never gets freed by the\ngarbage collector, or if the garbage collector prematurely frees\n``result_array``, the C function may end up throwing an invalid memory access\nexception.\n\n\n\nGarbage Collection Safety\n-------------------------\nWhen passing data to a :func:`ccall`, it is best to avoid using the :func:`pointer`\nfunction. Instead define a convert method and pass the variables directly to\nthe :func:`ccall`. :func:`ccall` automatically arranges that all of its arguments will be\npreserved from garbage collection until the call returns. If a C API will\nstore a reference to memory allocated by Julia, after the :func:`ccall` returns, you\nmust arrange that the object remains visible to the garbage collector. The\nsuggested way to handle this is to make a global variable of type\n``Array{Ref,1}`` to hold these values, until the C library notifies you that\nit is finished with them.\n\nWhenever you have created a pointer to Julia data, you must ensure the original data\nexists until you are done with using the pointer. Many methods in Julia such as\n:func:`unsafe_load` and :func:`String` make copies of data instead of taking ownership\nof the buffer, so that it is safe to free (or alter) the original data without\naffecting Julia. A notable exception is :func:`unsafe_wrap` which, for performance\nreasons, shares (or can be told to take ownership of) the underlying buffer.\n\nThe garbage collector does not guarantee any order of finalization. That is, if ``a``\ncontained a reference to ``b`` and both ``a`` and ``b`` are due for garbage\ncollection, there is no guarantee that ``b`` would be finalized after ``a``. If\nproper finalization of ``a`` depends on ``b`` being valid, it must be handled in\nother ways.\n\n\nNon-constant Function Specifications\n------------------------------------\n\nA ``(name, library)`` function specification must be a constant expression.\nHowever, it is possible to use computed values as function names by staging\nthrough ``eval`` as follows::\n\n    @eval ccall(($(string(\"a\",\"b\")),\"lib\"), ...\n\nThis expression constructs a name using ``string``, then substitutes this\nname into a new :func:`ccall` expression, which is then evaluated. Keep in mind that\n``eval`` only operates at the top level, so within this expression local\nvariables will not be available (unless their values are substituted with\n``$``). For this reason, ``eval`` is typically only used to form top-level\ndefinitions, for example when wrapping libraries that contain many\nsimilar functions.\n\nIf your usage is more dynamic, use indirect calls as described in the next section.\n\n\nIndirect Calls\n--------------\n\nThe first argument to :func:`ccall` can also be an expression evaluated at run time.\nIn this case, the expression must evaluate to a ``Ptr``,\nwhich will be used as the address of the native function to call.\nThis behavior occurs when the first :func:`ccall` argument contains references to non-constants,\nsuch as local variables, function arguments, or non-constant globals.\n\nFor example, you might lookup the function via ``dlsym``,\nthen cache it in a global variable for that session. For example::\n\n    macro dlsym(func, lib)\n        z, zlocal = gensym(string(func)), gensym()\n        eval(current_module(),:(global $z = C_NULL))\n        z = esc(z)\n        quote\n            let $zlocal::Ptr{Void} = $z::Ptr{Void}\n                if $zlocal == C_NULL\n                   $zlocal = dlsym($(esc(lib))::Ptr{Void}, $(esc(func)))\n                   global $z = $zlocal\n                end\n                $zlocal\n            end\n        end\n    end\n\n    mylibvar = dlopen(\"mylib\")\n    ccall(@dlsym(\"myfunc\", mylibvar), Void, ())\n\n\nCalling Convention\n------------------\n\nThe second argument to :func:`ccall` can optionally be a calling convention\nspecifier (immediately preceding return type). Without any specifier,\nthe platform-default C calling convention is used. Other supported\nconventions are: ``stdcall``, ``cdecl``, ``fastcall``, and ``thiscall``.\nFor example (from ``base/libc.jl``) we see the same ``gethostname`` :func:`ccall` as above,\nbut with the correct signature for Windows::\n\n    hn = Array{UInt8}(256)\n    err = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))\n\nFor more information, please see the `LLVM Language Reference`_.\n\n.. _LLVM Language Reference: http://llvm.org/docs/LangRef.html#calling-conventions\n\n\nAccessing Global Variables\n--------------------------\n\nGlobal variables exported by native libraries can be accessed by name using the\n:func:`cglobal` function. The arguments to :func:`cglobal` are a symbol specification\nidentical to that used by :func:`ccall`, and a type describing the value stored in\nthe variable::\n\n    julia> cglobal((:errno,:libc), Int32)\n    Ptr{Int32} @0x00007f418d0816b8\n\nThe result is a pointer giving the address of the value. The value can be\nmanipulated through this pointer using :func:`unsafe_load` and :func:`unsafe_store!`.\n\n\nAccessing Data through a Pointer\n--------------------------------\nThe following methods are described as \"unsafe\" because a bad pointer\nor type declaration can cause Julia to terminate abruptly.\n\nGiven a ``Ptr{T}``, the contents of type ``T`` can generally be copied from\nthe referenced memory into a Julia object using ``unsafe_load(ptr, [index])``.\nThe index argument is optional (default is 1),\nand follows the Julia-convention of 1-based indexing.\nThis function is intentionally similar to the behavior of :func:`getindex` and :func:`setindex!`\n(e.g. ``[]`` access syntax).\n\nThe return value will be a new object initialized\nto contain a copy of the contents of the referenced memory.\nThe referenced memory can safely be freed or released.\n\nIf ``T`` is ``Any``, then the memory is assumed to contain a reference to\na Julia object (a ``jl_value_t*``), the result will be a reference to this object,\nand the object will not be copied. You must be careful in this case to ensure\nthat the object was always visible to the garbage collector (pointers do not\ncount, but the new reference does) to ensure the memory is not prematurely freed.\nNote that if the object was not originally allocated by Julia, the new object\nwill never be finalized by Julia's garbage collector.  If the ``Ptr`` itself\nis actually a ``jl_value_t*``, it can be converted back to a Julia object\nreference by :func:`unsafe_pointer_to_objref(ptr) <unsafe_pointer_to_objref>`.\n(Julia values ``v`` can be converted to ``jl_value_t*`` pointers, as\n``Ptr{Void}``, by calling :func:`pointer_from_objref(v)\n<pointer_from_objref>`.)\n\nThe reverse operation (writing data to a ``Ptr{T}``), can be performed using\n:func:`unsafe_store!(ptr, value, [index]) <unsafe_store!>`.  Currently, this is only supported\nfor bitstypes or other pointer-free (``isbits``) immutable types.\n\nAny operation that throws an error is probably currently unimplemented\nand should be posted as a bug so that it can be resolved.\n\nIf the pointer of interest is a plain-data array (bitstype or immutable), the\nfunction :func:`unsafe_wrap(Array, ptr,dims,[own]) <unsafe_wrap>` may be\nmore useful. The final parameter should be true if Julia should \"take\nownership\" of the underlying buffer and call ``free(ptr)`` when the returned\n``Array`` object is finalized.  If the ``own`` parameter is omitted or false,\nthe caller must ensure the buffer remains in existence until all access is\ncomplete.\n\nArithmetic on the ``Ptr`` type in Julia (e.g. using ``+``) does not behave the\nsame as C's pointer arithmetic. Adding an integer to a ``Ptr`` in Julia always\nmoves the pointer by some number of *bytes*, not elements. This way, the\naddress values obtained from pointer arithmetic do not depend on the\nelement types of pointers.\n\n\nThread-safety\n-------------\n\nSome C libraries execute their callbacks from a different thread, and\nsince Julia isn't thread-safe you'll need to take some extra\nprecautions. In particular, you'll need to set up a two-layered\nsystem: the C callback should only *schedule* (via Julia's event loop)\nthe execution of your \"real\" callback.\nTo do this, create a ``AsyncCondition`` object and wait on it::\n\n  cond = Base.AsyncCondition()\n  wait(cond)\n\nThe callback you pass to C should only execute a :func:`ccall` to\n``:uv_async_send``, passing ``cb.handle`` as the argument,\ntaking care to avoid any allocations or other interactions with the Julia runtime.\n\nNote that events may be coalesced, so multiple calls to uv_async_send\nmay result in a single wakeup notification to the condition.\n\nMore About Callbacks\n--------------------\n\nFor more details on how to pass callbacks to C libraries, see this\n`blog post <http://julialang.org/blog/2013/05/callback>`_.\n\nC++\n---\n\nLimited support for C++ is provided by the `Cpp <https://github.com/timholy/Cpp.jl>`_,\n`Clang <https://github.com/ihnorton/Clang.jl>`_, and `Cxx <https://github.com/Keno/Cxx.jl>`_ packages.\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/contrib/build_sysimg.jl": "#!/usr/bin/env julia\n# This file is a part of Julia. License is MIT: http://julialang.org/license\n\n# Build a system image binary at sysimg_path.dlext. Allow insertion of a userimg via\n# userimg_path.  If sysimg_path.dlext is currently loaded into memory, don't continue\n# unless force is set to true.  Allow targeting of a CPU architecture via cpu_target.\nfunction default_sysimg_path(debug=false)\n    if is_unix()\n        splitext(Libdl.dlpath(debug ? \"sys-debug\" : \"sys\"))[1]\n    else\n        joinpath(JULIA_HOME, \"..\", \"lib\", \"julia\", debug ? \"sys-debug\" : \"sys\")\n    end\nend\n\n\"\"\"\n    build_sysimg(sysimg_path=default_sysimg_path, cpu_target=\"native\", userimg_path=nothing; force=false)\n\nRebuild the system image. Store it in `sysimg_path`, which defaults to a file named `sys.ji`\nthat sits in the same folder as `libjulia.{so,dylib}`, except on Windows where it defaults\nto `JULIA_HOME/../lib/julia/sys.ji`.  Use the cpu instruction set given by `cpu_target`.\nValid CPU targets are the same as for the `-C` option to `julia`, or the `-march` option to\n`gcc`.  Defaults to `native`, which means to use all CPU instructions available on the\ncurrent processor. Include the user image file given by `userimg_path`, which should contain\ndirectives such as `using MyPackage` to include that package in the new system image. New\nsystem image will not replace an older image unless `force` is set to true.\n\"\"\"\nfunction build_sysimg(sysimg_path=nothing, cpu_target=\"native\", userimg_path=nothing; force=false, debug=false)\n    if sysimg_path === nothing\n        sysimg_path = default_sysimg_path(debug)\n    end\n\n    # Quit out if a sysimg is already loaded and is in the same spot as sysimg_path, unless forcing\n    sysimg = Libdl.dlopen_e(\"sys\")\n    if sysimg != C_NULL\n        if !force && Base.samefile(Libdl.dlpath(sysimg), \"$(sysimg_path).$(Libdl.dlext)\")\n            info(\"System image already loaded at $(Libdl.dlpath(sysimg)), set force=true to override\")\n            return\n        end\n    end\n\n    # Canonicalize userimg_path before we enter the base_dir\n    if userimg_path !== nothing\n        userimg_path = abspath(userimg_path)\n    end\n\n    # Enter base and setup some useful paths\n    base_dir = dirname(Base.find_source_file(\"sysimg.jl\"))\n    cd(base_dir) do\n        julia = joinpath(JULIA_HOME, debug ? \"julia-debug\" : \"julia\")\n        cc = find_system_compiler()\n\n        # Ensure we have write-permissions to wherever we're trying to write to\n        try\n            touch(\"$sysimg_path.ji\")\n        catch\n            err_msg =  \"Unable to modify $sysimg_path.ji, ensure parent directory exists \"\n            err_msg *= \"and is writable. Absolute paths work best.)\"\n            error( err_msg )\n        end\n\n        # Copy in userimg.jl if it exists\n        if userimg_path !== nothing\n            if !isfile(userimg_path)\n                error(\"$userimg_path is not found, ensure it is an absolute path!\")\n            end\n            if isfile(\"userimg.jl\")\n                error(\"$base_dir/userimg.jl already exists, delete manually to continue.\")\n            end\n            cp(userimg_path, \"userimg.jl\")\n        end\n        try\n            # Start by building inference.{ji,o}\n            inference_path = joinpath(dirname(sysimg_path), \"inference\")\n            info(\"Building inference.o\")\n            println(\"$julia -C $cpu_target --output-ji $inference_path.ji --output-o $inference_path.o coreimg.jl\")\n            run(`$julia -C $cpu_target --output-ji $inference_path.ji --output-o $inference_path.o coreimg.jl`)\n\n            # Bootstrap off of that to create sys.{ji,o}\n            info(\"Building sys.o\")\n            println(\"$julia -C $cpu_target --output-ji $sysimg_path.ji --output-o $sysimg_path.o -J $inference_path.ji --startup-file=no sysimg.jl\")\n            run(`$julia -C $cpu_target --output-ji $sysimg_path.ji --output-o $sysimg_path.o -J $inference_path.ji --startup-file=no sysimg.jl`)\n\n            if cc !== nothing\n                link_sysimg(sysimg_path, cc, debug)\n            else\n                info(\"System image successfully built at $sysimg_path.ji\")\n            end\n\n            if !Base.samefile(\"$(default_sysimg_path(debug)).ji\", \"$sysimg_path.ji\")\n                if Base.isfile(\"$sysimg_path.$(Libdl.dlext)\")\n                    info(\"To run Julia with this image loaded, run: julia -J $sysimg_path.$(Libdl.dlext)\")\n                else\n                    info(\"To run Julia with this image loaded, run: julia -J $sysimg_path.ji\")\n                end\n            else\n                info(\"Julia will automatically load this system image at next startup\")\n            end\n        finally\n            # Cleanup userimg.jl\n            if userimg_path !== nothing && isfile(\"userimg.jl\")\n                rm(\"userimg.jl\")\n            end\n        end\n    end\nend\n\n# Search for a compiler to link sys.o into sys.dl_ext.  Honor LD environment variable.\nfunction find_system_compiler()\n    if haskey( ENV, \"CC\" )\n        if !success(`$(ENV[\"CC\"]) -v`)\n            warn(\"Using compiler override $(ENV[\"CC\"]), but unable to run `$(ENV[\"CC\"]) -v`\")\n        end\n        return ENV[\"CC\"]\n    end\n\n    # On Windows, check to see if WinRPM is installed, and if so, see if gcc is installed\n    if is_windows()\n        try\n            eval(Main, :(using WinRPM))\n            winrpmgcc = joinpath(WinRPM.installdir,\"usr\",\"$(Sys.ARCH)-w64-mingw32\",\n                \"sys-root\",\"mingw\",\"bin\",\"gcc.exe\")\n            if success(`$winrpmgcc --version`)\n                return winrpmgcc\n            else\n                throw()\n            end\n        catch\n            warn(\"Install GCC via `Pkg.add(\\\"WinRPM\\\"); WinRPM.install(\\\"gcc\\\")` to generate sys.dll for faster startup times\")\n        end\n    end\n\n\n    # See if `cc` exists\n    try\n        if success(`cc -v`)\n            return \"cc\"\n        end\n    end\n\n    warn( \"No supported compiler found; startup times will be longer\" )\nend\n\n# Link sys.o into sys.$(dlext)\nfunction link_sysimg(sysimg_path=nothing, cc=find_system_compiler(), debug=false)\n    if sysimg_path === nothing\n        sysimg_path = default_sysimg_path(debug)\n    end\n    julia_libdir = dirname(Libdl.dlpath(debug ? \"libjulia-debug\" : \"libjulia\"))\n\n    FLAGS = [\"-L$julia_libdir\"]\n\n    push!(FLAGS, \"-shared\")\n    push!(FLAGS, debug ? \"-ljulia-debug\" : \"-ljulia\")\n    if is_windows()\n        push!(FLAGS, \"-lssp\")\n    end\n\n    sysimg_file = \"$sysimg_path.$(Libdl.dlext)\"\n    info(\"Linking sys.$(Libdl.dlext)\")\n    # Windows has difficulties overwriting a file in use so we first rename it\n    if is_windows() && isfile(sysimg_file)\n        mv(sysimg_file, \"$sysimg_file.old\"; remove_destination=true)\n        run(`$cc $FLAGS -o $sysimg_file $sysimg_path.o`)\n    else\n        run(`$cc $FLAGS -o $sysimg_file $sysimg_path.o`)\n    end\n    info(\"System image successfully built at $sysimg_path.$(Libdl.dlext)\")\nend\n\n# When running this file as a script, try to do so with default values.  If arguments are passed\n# in, use them as the arguments to build_sysimg above.\n#\n# Also check whether we are running `genstdlib.jl`, in which case we don't want to build a\n# system image and instead only need `build_sysimg`'s docstring to be available.\nif !isdefined(Main, :GenStdLib) && !isinteractive()\n    if length(ARGS) > 5 || (\"--help\" in ARGS || \"-h\" in ARGS)\n        println(\"Usage: build_sysimg.jl <sysimg_path> <cpu_target> <usrimg_path.jl> [--force] [--debug] [--help]\")\n        println(\"   <sysimg_path>    is an absolute, extensionless path to store the system image at\")\n        println(\"   <cpu_target>     is an LLVM cpu target to build the system image against\")\n        println(\"   <usrimg_path.jl> is the path to a user image to be baked into the system image\")\n        println(\"   --debug          Using julia-debug instead of julia to build the system image\")\n        println(\"   --force          Set if you wish to overwrite the default system image\")\n        println(\"   --help           Print out this help text and exit\")\n        println()\n        println(\" Example:\")\n        println(\"   build_sysimg.jl /usr/local/lib/julia/sys core2 ~/my_usrimg.jl --force\")\n        println()\n        println(\" Running this script with no arguments is equivalent to:\")\n        println(\"   build_sysimg.jl $(default_sysimg_path()) native\")\n        return 0\n    end\n\n    debug_flag = \"--debug\" in ARGS\n    filter!(x -> x != \"--debug\", ARGS)\n    force_flag = \"--force\" in ARGS\n    filter!(x -> x != \"--force\", ARGS)\n    build_sysimg(ARGS...; force=force_flag, debug=debug_flag)\nend\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/base/libdl.jl": "# This file is a part of Julia. License is MIT: http://julialang.org/license\n\nmodule Libdl\n\nexport DL_LOAD_PATH, RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL,\n    RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW, dlclose, dlopen, dlopen_e, dlsym, dlsym_e,\n    dlpath, find_library, dlext, dllist\n\n\"\"\"\n    DL_LOAD_PATH\n\nWhen calling [`dlopen`](:func:`dlopen`), the paths in this list will be searched first, in\norder, before searching the system locations for a valid library handle.\n\"\"\"\nconst DL_LOAD_PATH = String[]\nif is_apple()\n    push!(DL_LOAD_PATH, \"@loader_path/julia\")\n    push!(DL_LOAD_PATH, \"@loader_path\")\nend\n\n# constants to match JL_RTLD_* in src/julia.h\nconst RTLD_LOCAL     = 0x00000001\nconst RTLD_GLOBAL    = 0x00000002\nconst RTLD_LAZY      = 0x00000004\nconst RTLD_NOW       = 0x00000008\nconst RTLD_NODELETE  = 0x00000010\nconst RTLD_NOLOAD    = 0x00000020\nconst RTLD_DEEPBIND  = 0x00000040\nconst RTLD_FIRST     = 0x00000080\n\n@doc \"\"\"\n    RTLD_DEEPBIND\n    RTLD_FIRST\n    RTLD_GLOBAL\n    RTLD_LAZY\n    RTLD_LOCAL\n    RTLD_NODELETE\n    RTLD_NOLOAD\n    RTLD_NOW\n\nEnum constant for [`dlopen`](:func:`dlopen`). See your platform man page for details, if\napplicable.\n\"\"\" ->\n(RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL, RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW)\n\n\n\"\"\"\n    dlsym(handle, sym)\n\nLook up a symbol from a shared library handle, return callable function pointer on success.\n\"\"\"\nfunction dlsym(hnd::Ptr, s::Union{Symbol,AbstractString})\n    hnd == C_NULL && throw(ArgumentError(\"NULL library handle\"))\n    ccall(:jl_dlsym, Ptr{Void}, (Ptr{Void}, Cstring), hnd, s)\nend\n\n\"\"\"\n    dlsym_e(handle, sym)\n\nLook up a symbol from a shared library handle, silently return `NULL` pointer on lookup failure.\n\"\"\"\nfunction dlsym_e(hnd::Ptr, s::Union{Symbol,AbstractString})\n    hnd == C_NULL && throw(ArgumentError(\"NULL library handle\"))\n    ccall(:jl_dlsym_e, Ptr{Void}, (Ptr{Void}, Cstring), hnd, s)\nend\n\n\"\"\"\n    dlopen(libfile::AbstractString [, flags::Integer])\n\nLoad a shared library, returning an opaque handle.\n\nThe optional flags argument is a bitwise-or of zero or more of `RTLD_LOCAL`, `RTLD_GLOBAL`,\n`RTLD_LAZY`, `RTLD_NOW`, `RTLD_NODELETE`, `RTLD_NOLOAD`, `RTLD_DEEPBIND`, and `RTLD_FIRST`.\nThese are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS)\ndlopen command, if possible, or are ignored if the specified functionality is not available\non the current platform. The default flags are platform specific. On MacOS the default\n`dlopen` flags are `RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL` while on other platforms the\ndefaults are `RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL`. An important usage of these flags is to\nspecify non default behavior for when the dynamic library loader binds library references to\nexported symbols and if the bound references are put into process local or global scope. For\ninstance `RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL` allows the library's symbols to be available\nfor usage in other shared libraries, addressing situations where there are dependencies\nbetween shared libraries.\n\"\"\"\nfunction dlopen end\n\ndlopen(s::Symbol, flags::Integer = RTLD_LAZY | RTLD_DEEPBIND) =\n    dlopen(string(s), flags)\n\ndlopen(s::AbstractString, flags::Integer = RTLD_LAZY | RTLD_DEEPBIND) =\n    ccall(:jl_load_dynamic_library, Ptr{Void}, (Cstring,UInt32), s, flags)\n\n\"\"\"\n    dlopen_e(libfile::AbstractString [, flags::Integer])\n\nSimilar to [`dlopen`](:func:`dlopen`), except returns a `NULL` pointer instead of raising errors.\n\"\"\"\nfunction dlopen_e end\n\ndlopen_e(s::Symbol, flags::Integer = RTLD_LAZY | RTLD_DEEPBIND) =\n    dlopen_e(string(s), flags)\n\ndlopen_e(s::AbstractString, flags::Integer = RTLD_LAZY | RTLD_DEEPBIND) =\n    ccall(:jl_load_dynamic_library_e, Ptr{Void}, (Cstring,UInt32), s, flags)\n\n\"\"\"\n    dlclose(handle)\n\nClose shared library referenced by handle.\n\"\"\"\nfunction dlclose(p::Ptr)\n    0 == ccall(:jl_dlclose, Cint, (Ptr{Void},), p)\nend\n\n\"\"\"\n    find_library(names, locations)\n\nSearches for the first library in `names` in the paths in the `locations` list,\n`DL_LOAD_PATH`, or system library paths (in that order) which can successfully be dlopen'd.\nOn success, the return value will be one of the names (potentially prefixed by one of the\npaths in locations). This string can be assigned to a `global const` and used as the library\nname in future `ccall`'s. On failure, it returns the empty string.\n\"\"\"\nfunction find_library(libnames, extrapaths=String[])\n    for lib in libnames\n        for path in extrapaths\n            l = joinpath(path, lib)\n            p = dlopen_e(l, RTLD_LAZY)\n            if p != C_NULL\n                dlclose(p)\n                return l\n            end\n        end\n        p = dlopen_e(lib, RTLD_LAZY)\n        if p != C_NULL\n            dlclose(p)\n            return lib\n        end\n    end\n    return \"\"\nend\nfind_library(libname::Union{Symbol,AbstractString}, extrapaths=String[]) =\n    find_library([string(libname)], extrapaths)\n\nfunction dlpath(handle::Ptr{Void})\n    p = ccall(:jl_pathname_for_handle, Cstring, (Ptr{Void},), handle)\n    s = unsafe_string(p)\n    is_windows() && Libc.free(p)\n    return s\nend\n\nfunction dlpath(libname::Union{AbstractString, Symbol})\n    handle = dlopen(libname)\n    path = dlpath(handle)\n    dlclose(handle)\n    return path\nend\n\nif is_apple()\n    const dlext = \"dylib\"\nelseif is_windows()\n    const dlext = \"dll\"\nelse\n    #assume is_linux, or similar\n    const dlext = \"so\"\nend\n\n\"\"\"\n    dlext\n\nFile extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.\n\"\"\"\ndlext\n\nif is_linux()\n    immutable dl_phdr_info\n        # Base address of object\n        addr::Cuint\n\n        # Null-terminated name of object\n        name::Ptr{UInt8}\n\n        # Pointer to array of ELF program headers for this object\n        phdr::Ptr{Void}\n\n        # Number of program headers for this object\n        phnum::Cshort\n    end\n\n    # This callback function called by dl_iterate_phdr() on Linux\n    function dl_phdr_info_callback(di::dl_phdr_info, size::Csize_t, dynamic_libraries::Array{AbstractString,1})\n        # Skip over objects without a path (as they represent this own object)\n        name = unsafe_string(di.name)\n        if !isempty(name)\n            push!(dynamic_libraries, name)\n        end\n        return convert(Cint, 0)::Cint\n    end\nend # linux-only\n\nfunction dllist()\n    dynamic_libraries = Array{AbstractString}(0)\n\n    @static if is_linux()\n        const callback = cfunction(dl_phdr_info_callback, Cint,\n                                   (Ref{dl_phdr_info}, Csize_t, Ref{Array{AbstractString,1}} ))\n        ccall(:dl_iterate_phdr, Cint, (Ptr{Void}, Ref{Array{AbstractString,1}}), callback, dynamic_libraries)\n    end\n\n    @static if is_apple()\n        numImages = ccall(:_dyld_image_count, Cint, (), )\n\n        # start at 1 instead of 0 to skip self\n        for i in 1:numImages-1\n            name = unsafe_string(ccall(:_dyld_get_image_name, Cstring, (UInt32,), i))\n            push!(dynamic_libraries, name)\n        end\n    end\n\n    @static if is_windows()\n        ccall(:jl_dllist, Cint, (Any,), dynamic_libraries)\n    end\n\n    return dynamic_libraries\nend\n\nend # module\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/base/sparse/cholmod.jl": "# This file is a part of Julia. License is MIT: http://julialang.org/license\n\nmodule CHOLMOD\n\nimport Base: (*), convert, copy, eltype, get, getindex, show, size,\n             linearindexing, LinearFast, LinearSlow, ctranspose\n\nimport Base.LinAlg: (\\), A_mul_Bc, A_mul_Bt, Ac_ldiv_B, Ac_mul_B, At_ldiv_B, At_mul_B,\n                 cholfact, cholfact!, det, diag, ishermitian, isposdef,\n                 issymmetric, ldltfact, ldltfact!, logdet\n\nimportall ..SparseArrays\n\nexport\n    Dense,\n    Factor,\n    Sparse\n\nimport ..SparseArrays: AbstractSparseMatrix, SparseMatrixCSC, increment, indtype\n\n#########\n# Setup #\n#########\n\ninclude(\"cholmod_h.jl\")\n\nconst CHOLMOD_MIN_VERSION = v\"2.1.1\"\n\n### These offsets are defined in SuiteSparse_wrapper.c\nconst common_size = ccall((:jl_cholmod_common_size,:libsuitesparse_wrapper),Int,())\n\nconst cholmod_com_offsets = Array{Csize_t}(19)\nccall((:jl_cholmod_common_offsets, :libsuitesparse_wrapper),\n    Void, (Ptr{Csize_t},), cholmod_com_offsets)\n\n## macro to generate the name of the C function according to the integer type\nmacro cholmod_name(nm,typ) string(\"cholmod_\", eval(typ) == SuiteSparse_long ? \"l_\" : \"\", nm) end\n\nfunction start(a::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"start\", SuiteSparse_long), :libcholmod),\n        Cint, (Ptr{UInt8},), a)\n    return a\nend\n\nfunction finish(a::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"finish\", SuiteSparse_long), :libcholmod),\n        Cint, (Ptr{UInt8},), a)\n    return a\nend\n\nfunction defaults(a::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"defaults\", SuiteSparse_long), :libcholmod),\n        Cint, (Ptr{UInt8},), a)\n    return a\nend\n\ncommon() = commonStruct\n\nconst build_version_array = Array{Cint}(3)\nccall((:jl_cholmod_version, :libsuitesparse_wrapper), Cint, (Ptr{Cint},), build_version_array)\nconst build_version = VersionNumber(build_version_array...)\n\nfunction __init__()\n    try\n        ### Check if the linked library is compatible with the Julia code\n        if Libdl.dlsym_e(Libdl.dlopen(\"libcholmod\"), :cholmod_version) != C_NULL\n            current_version_array = Array{Cint}(3)\n            ccall((:cholmod_version, :libcholmod), Cint, (Ptr{Cint},), current_version_array)\n            current_version = VersionNumber(current_version_array...)\n        else # CHOLMOD < 2.1.1 does not include cholmod_version()\n            current_version = v\"0.0.0\"\n        end\n\n\n        if current_version < CHOLMOD_MIN_VERSION\n            warn(\"\"\"\n\n                CHOLMOD version incompatibility\n\n                Julia was compiled with CHOLMOD version $build_version. It is\n                currently linked with a version older than\n                $(CHOLMOD_MIN_VERSION). This might cause Julia to\n                terminate when working with sparse matrix factorizations,\n                e.g. solving systems of equations with \\\\.\n\n                It is recommended that you use Julia with a recent version\n                of CHOLMOD, or download the generic binaries\n                from www.julialang.org, which ship with the correct\n                versions of all dependencies.\n            \"\"\")\n        elseif build_version_array[1] != current_version_array[1]\n            warn(\"\"\"\n\n                CHOLMOD version incompatibility\n\n                Julia was compiled with CHOLMOD version $build_version. It is\n                currently linked with version $current_version.\n                This might cause Julia to terminate when working with\n                sparse matrix factorizations, e.g. solving systems of\n                equations with \\\\.\n\n                It is recommended that you use Julia with the same major\n                version of CHOLMOD as the one used during the build, or\n                download the generic binaries from www.julialang.org,\n                which ship with the correct versions of all dependencies.\n            \"\"\")\n        end\n\n        intsize = Int(ccall((:jl_cholmod_sizeof_long,:libsuitesparse_wrapper),Csize_t,()))\n        if intsize != 4length(IndexTypes)\n            warn(\"\"\"\n\n                 CHOLMOD integer size incompatibility\n\n                 Julia was compiled with a version of CHOLMOD that\n                 supported $(32length(IndexTypes)) bit integers. It is\n                 currently linked with version that supports $(8intsize)\n                 integers. This might cause Julia to terminate when\n                 working with sparse matrix factorizations, e.g. solving\n                 systems of equations with \\\\.\n\n                 This problem can be fixed by modifying the Julia build\n                 configuration or by downloading the OS X or generic\n                 Linux binary from www.julialang.org, which include\n                 the correct versions of all dependencies.\n             \"\"\")\n        end\n\n        ### Initiate CHOLMOD\n        ### The common struct. Controls the type of factorization and keeps pointers\n        ### to temporary memory.\n        global const commonStruct = fill(0xff, common_size)\n\n        global const common_supernodal =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[4] + 1))\n        global const common_final_ll =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[7] + 1))\n        global const common_print =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[13] + 1))\n        global const common_itype =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[18] + 1))\n        global const common_dtype =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[19] + 1))\n        global const common_nmethods =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[15] + 1))\n        global const common_postorder =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[17] + 1))\n\n        start(commonStruct)              # initializes CHOLMOD\n        set_print_level(commonStruct, 0) # no printing from CHOLMOD by default\n\n        # Register gc tracked allocator if CHOLMOD is new enough\n        if current_version >= v\"3.0.0\"\n            cnfg = cglobal((:SuiteSparse_config, :libsuitesparseconfig), Ptr{Void})\n            unsafe_store!(cnfg, cglobal(:jl_malloc, Ptr{Void}), 1)\n            unsafe_store!(cnfg, cglobal(:jl_calloc, Ptr{Void}), 2)\n            unsafe_store!(cnfg, cglobal(:jl_realloc, Ptr{Void}), 3)\n            unsafe_store!(cnfg, cglobal(:jl_free, Ptr{Void}), 4)\n        end\n\n    catch ex\n        Base.showerror_nostdio(ex,\n            \"WARNING: Error during initialization of module CHOLMOD\")\n    end\nend\n\nfunction set_print_level(cm::Array{UInt8}, lev::Integer)\n    global common_print\n    unsafe_store!(common_print, lev)\nend\n\n####################\n# Type definitions #\n####################\n\nabstract SuiteSparseStruct\n\n# The three core data types for CHOLMOD: Dense, Sparse and Factor.\n# CHOLMOD manages the memory, so the Julia versions only wrap a\n# pointer to a struct.  Therefore finalizers should be registered each\n# time a pointer is returned from CHOLMOD.\n\n# Dense\nimmutable C_Dense{T<:VTypes} <: SuiteSparseStruct\n    nrow::Csize_t\n    ncol::Csize_t\n    nzmax::Csize_t\n    d::Csize_t\n    x::Ptr{T}\n    z::Ptr{Void}\n    xtype::Cint\n    dtype::Cint\nend\n\ntype Dense{T<:VTypes} <: DenseMatrix{T}\n    p::Ptr{C_Dense{T}}\nend\n\n# Sparse\nimmutable C_Sparse{Tv<:VTypes} <: SuiteSparseStruct\n    nrow::Csize_t\n    ncol::Csize_t\n    nzmax::Csize_t\n    p::Ptr{SuiteSparse_long}\n    i::Ptr{SuiteSparse_long}\n    nz::Ptr{SuiteSparse_long}\n    x::Ptr{Tv}\n    z::Ptr{Void}\n    stype::Cint\n    itype::Cint\n    xtype::Cint\n    dtype::Cint\n    sorted::Cint\n    packed::Cint\nend\n\n# Corresponds to the exact definition of cholmod_sparse_struct in the library.\n# Useful when reading matrices of unknown type from files as in\n# cholmod_read_sparse\nimmutable C_SparseVoid <: SuiteSparseStruct\n    nrow::Csize_t\n    ncol::Csize_t\n    nzmax::Csize_t\n    p::Ptr{Void}\n    i::Ptr{Void}\n    nz::Ptr{Void}\n    x::Ptr{Void}\n    z::Ptr{Void}\n    stype::Cint\n    itype::Cint\n    xtype::Cint\n    dtype::Cint\n    sorted::Cint\n    packed::Cint\nend\n\ntype Sparse{Tv<:VTypes} <: AbstractSparseMatrix{Tv,SuiteSparse_long}\n    p::Ptr{C_Sparse{Tv}}\n    function Sparse(p::Ptr{C_Sparse{Tv}})\n        if p == C_NULL\n            throw(ArgumentError(\"sparse matrix construction failed for unknown reasons. Please submit a bug report.\"))\n        end\n        new(p)\n    end\nend\nSparse{Tv<:VTypes}(p::Ptr{C_Sparse{Tv}}) = Sparse{Tv}(p)\n\n# Factor\n\nif build_version >= v\"2.1.0\" # CHOLMOD version 2.1.0 or later\n    immutable C_Factor{Tv<:VTypes} <: SuiteSparseStruct\n        n::Csize_t\n        minor::Csize_t\n        Perm::Ptr{SuiteSparse_long}\n        ColCount::Ptr{SuiteSparse_long}\n        IPerm::Ptr{SuiteSparse_long}        # this pointer was added in verison 2.1.0\n        nzmax::Csize_t\n        p::Ptr{SuiteSparse_long}\n        i::Ptr{SuiteSparse_long}\n        x::Ptr{Tv}\n        z::Ptr{Void}\n        nz::Ptr{SuiteSparse_long}\n        next::Ptr{SuiteSparse_long}\n        prev::Ptr{SuiteSparse_long}\n        nsuper::Csize_t\n        ssize::Csize_t\n        xsize::Csize_t\n        maxcsize::Csize_t\n        maxesize::Csize_t\n        super::Ptr{SuiteSparse_long}\n        pi::Ptr{SuiteSparse_long}\n        px::Ptr{SuiteSparse_long}\n        s::Ptr{SuiteSparse_long}\n        ordering::Cint\n        is_ll::Cint\n        is_super::Cint\n        is_monotonic::Cint\n        itype::Cint\n        xtype::Cint\n        dtype::Cint\n    end\nelse\n    immutable C_Factor{Tv<:VTypes} <: SuiteSparseStruct\n        n::Csize_t\n        minor::Csize_t\n        Perm::Ptr{SuiteSparse_long}\n        ColCount::Ptr{SuiteSparse_long}\n        nzmax::Csize_t\n        p::Ptr{SuiteSparse_long}\n        i::Ptr{SuiteSparse_long}\n        x::Ptr{Tv}\n        z::Ptr{Void}\n        nz::Ptr{SuiteSparse_long}\n        next::Ptr{SuiteSparse_long}\n        prev::Ptr{SuiteSparse_long}\n        nsuper::Csize_t\n        ssize::Csize_t\n        xsize::Csize_t\n        maxcsize::Csize_t\n        maxesize::Csize_t\n        super::Ptr{SuiteSparse_long}\n        pi::Ptr{SuiteSparse_long}\n        px::Ptr{SuiteSparse_long}\n        s::Ptr{SuiteSparse_long}\n        ordering::Cint\n        is_ll::Cint\n        is_super::Cint\n        is_monotonic::Cint\n        itype::Cint\n        xtype::Cint\n        dtype::Cint\n    end\nend\n\ntype Factor{Tv} <: Factorization{Tv}\n    p::Ptr{C_Factor{Tv}}\n    function Factor(p::Ptr{C_Factor{Tv}})\n        if p == C_NULL\n            throw(ArgumentError(\"factorization construction failed for unknown reasons. Please submit a bug report.\"))\n        end\n        new(p)\n    end\nend\nFactor{Tv<:VTypes}(p::Ptr{C_Factor{Tv}}) = Factor{Tv}(p)\n\n# Define get similar to get(Nullable) to check pointers. All pointer loads should be wrapped in get to make sure\n# that SuiteSparse is not called with a C_NULL pointer which could cause a segfault. Pointers are set to null\n# when serialized so this can happen when mutiple processes are in use.\nfunction get{T<:SuiteSparseStruct}(p::Ptr{T})\n    if p == C_NULL\n        throw(ArgumentError(\"pointer to the $T object is null. This can happen if the object has been serialized.\"))\n    else\n        return p\n    end\nend\n\n# FactorComponent, for encoding particular factors from a factorization\ntype FactorComponent{Tv,S} <: AbstractMatrix{Tv}\n    F::Factor{Tv}\n\n    function FactorComponent(F::Factor{Tv})\n        s = unsafe_load(get(F.p))\n        if s.is_ll != 0\n            S == :L || S == :U || S == :PtL || S == :UP || throw(CHOLMODException(string(S, \" not supported for sparse LLt matrices; try :L, :U, :PtL, or :UP\")))\n        else\n            S == :L || S == :U || S == :PtL || S == :UP ||\n            S == :D || S == :LD || S == :DU || S == :PtLD || S == :DUP ||\n            throw(CHOLMODException(string(S, \" not supported for sparse LDLt matrices; try :L, :U, :PtL, :UP, :D, :LD, :DU, :PtLD, or :DUP\")))\n        end\n        new(F)\n    end\nend\nfunction FactorComponent{Tv}(F::Factor{Tv}, sym::Symbol)\n    FactorComponent{Tv,sym}(F)\nend\n\nFactor(FC::FactorComponent) = Factor(FC.F)\n\n#################\n# Thin wrappers #\n#################\n\n# Dense wrappers\n## Note! Integer type defaults to Cint, but this is actually not necessary, but\n## making this a choice would require another type parameter in the Dense type\n\n### cholmod_core_h ###\nfunction allocate_dense(nrow::Integer, ncol::Integer, d::Integer, ::Type{Float64})\n    d = Dense(ccall((:cholmod_l_allocate_dense, :libcholmod), Ptr{C_Dense{Float64}},\n        (Csize_t, Csize_t, Csize_t, Cint, Ptr{Void}),\n        nrow, ncol, d, REAL, common()))\n    finalizer(d, free!)\n    d\nend\nfunction allocate_dense(nrow::Integer, ncol::Integer, d::Integer, ::Type{Complex{Float64}})\n    d = Dense(ccall((:cholmod_l_allocate_dense, :libcholmod), Ptr{C_Dense{Complex{Float64}}},\n        (Csize_t, Csize_t, Csize_t, Cint, Ptr{Void}),\n        nrow, ncol, d, COMPLEX, common()))\n    finalizer(d, free!)\n    d\nend\n\nfree_dense!{T}(p::Ptr{C_Dense{T}}) = ccall((:cholmod_l_free_dense, :libcholmod), Cint, (Ref{Ptr{C_Dense{T}}}, Ptr{Void}), p, common())\n\nfunction zeros{T<:VTypes}(m::Integer, n::Integer, ::Type{T})\n    d = Dense(ccall((:cholmod_l_zeros, :libcholmod), Ptr{C_Dense{T}},\n        (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n         m, n, xtyp(T), common()))\n    finalizer(d, free!)\n    d\nend\nzeros(m::Integer, n::Integer) = zeros(m, n, Float64)\n\nfunction ones{T<:VTypes}(m::Integer, n::Integer, ::Type{T})\n    d = Dense(ccall((:cholmod_l_ones, :libcholmod), Ptr{C_Dense{T}},\n        (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n         m, n, xtyp(T), common()))\n    finalizer(d, free!)\n    d\nend\nones(m::Integer, n::Integer) = ones(m, n, Float64)\n\nfunction eye{T<:VTypes}(m::Integer, n::Integer, ::Type{T})\n    d = Dense(ccall((:cholmod_l_eye, :libcholmod), Ptr{C_Dense{T}},\n        (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n         m, n, xtyp(T), common()))\n    finalizer(d, free!)\n    d\nend\neye(m::Integer, n::Integer) = eye(m, n, Float64)\neye(n::Integer) = eye(n, n, Float64)\n\nfunction copy_dense{Tv<:VTypes}(A::Dense{Tv})\n    d = Dense(ccall((:cholmod_l_copy_dense, :libcholmod), Ptr{C_Dense{Tv}},\n        (Ptr{C_Dense{Tv}}, Ptr{UInt8}),\n         get(A.p), common()))\n    finalizer(d, free!)\n    d\nend\n\n### cholmod_matrixops.h ###\nfunction norm_dense{Tv<:VTypes}(D::Dense{Tv}, p::Integer)\n    s = unsafe_load(get(D.p))\n    if p == 2\n        if s.ncol > 1\n            throw(ArgumentError(\"2 norm only supported when matrix has one column\"))\n        end\n    elseif p != 0 && p != 1\n        throw(ArgumentError(\"second argument must be either 0 (Inf norm), 1, or 2\"))\n    end\n    ccall((:cholmod_l_norm_dense, :libcholmod), Cdouble,\n        (Ptr{C_Dense{Tv}}, Cint, Ptr{UInt8}),\n          get(D.p), p, common())\nend\n\n### cholmod_check.h ###\nfunction check_dense{T<:VTypes}(A::Dense{T})\n    ccall((:cholmod_l_check_dense, :libcholmod), Cint,\n          (Ptr{C_Dense{T}}, Ptr{UInt8}),\n          A.p, common())!=0\nend\n\n# Non-Dense wrappers\n### cholmod_core.h ###\nfunction allocate_sparse(nrow::Integer, ncol::Integer, nzmax::Integer, sorted::Bool, packed::Bool, stype::Integer, ::Type{Float64})\n    s = Sparse(ccall((@cholmod_name(\"allocate_sparse\", SuiteSparse_long), :libcholmod), Ptr{C_Sparse{Float64}},\n            (Csize_t, Csize_t, Csize_t, Cint,\n                Cint, Cint, Cint, Ptr{Void}),\n            nrow, ncol, nzmax, sorted,\n                packed, stype, REAL, common()))\n    finalizer(s, free!)\n    s\nend\nfunction allocate_sparse(nrow::Integer, ncol::Integer, nzmax::Integer, sorted::Bool, packed::Bool, stype::Integer, ::Type{Complex{Float64}})\n    s = Sparse(ccall((@cholmod_name(\"allocate_sparse\", SuiteSparse_long), :libcholmod),\n            Ptr{C_Sparse{Complex{Float64}}},\n                (Csize_t, Csize_t, Csize_t, Cint,\n                 Cint, Cint, Cint, Ptr{Void}),\n                nrow, ncol, nzmax, sorted,\n                packed, stype, COMPLEX, common()))\n    finalizer(s, free!)\n    s\nend\nfunction free_sparse!{Tv<:VTypes}(ptr::Ptr{C_Sparse{Tv}})\n    @isok ccall((@cholmod_name(\"free_sparse\", SuiteSparse_long), :libcholmod), Cint,\n            (Ptr{Ptr{C_Sparse{Tv}}}, Ptr{UInt8}),\n                &ptr, common())\nend\n\nfunction free_sparse!(ptr::Ptr{C_SparseVoid})\n    @isok ccall((@cholmod_name(\"free_sparse\", SuiteSparse_long), :libcholmod), Cint,\n            (Ptr{Ptr{C_SparseVoid}}, Ptr{UInt8}),\n                &ptr, common())\nend\n\nfunction free_factor!{Tv<:VTypes}(ptr::Ptr{C_Factor{Tv}})\n    # Warning! Important that finalizer doesn't modify the global Common struct.\n    @isok ccall((@cholmod_name(\"free_factor\", SuiteSparse_long), :libcholmod), Cint,\n            (Ptr{Ptr{C_Factor{Tv}}}, Ptr{Void}),\n                &ptr, common())\nend\n\nfunction aat{Tv<:VRealTypes}(A::Sparse{Tv}, fset::Vector{SuiteSparse_long}, mode::Integer)\n    s = Sparse(ccall((@cholmod_name(\"aat\", SuiteSparse_long), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{SuiteSparse_long}, Csize_t, Cint, Ptr{UInt8}),\n                get(A.p), fset, length(fset), mode, common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction sparse_to_dense{Tv<:VTypes}(A::Sparse{Tv})\n    d = Dense(ccall((@cholmod_name(\"sparse_to_dense\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Dense{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                get(A.p), common()))\n    finalizer(d, free!)\n    d\nend\nfunction dense_to_sparse{Tv<:VTypes}(D::Dense{Tv}, ::Type{SuiteSparse_long})\n    s = Sparse(ccall((@cholmod_name(\"dense_to_sparse\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Dense{Tv}}, Cint, Ptr{UInt8}),\n                get(D.p), true, common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction factor_to_sparse!{Tv<:VTypes}(F::Factor{Tv})\n    ss = unsafe_load(F.p)\n    ss.xtype > PATTERN || throw(CHOLMODException(\"only numeric factors are supported\"))\n    s = Sparse(ccall((@cholmod_name(\"factor_to_sparse\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                get(F.p), common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction change_factor!{Tv<:VTypes}(::Type{Float64}, to_ll::Bool, to_super::Bool, to_packed::Bool, to_monotonic::Bool, F::Factor{Tv})\n    @isok ccall((@cholmod_name(\"change_factor\", SuiteSparse_long),:libcholmod), Cint,\n            (Cint, Cint, Cint, Cint, Cint, Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                REAL, to_ll, to_super, to_packed, to_monotonic, get(F.p), common())\n    Factor{Float64}(F.p)\nend\n\nfunction change_factor!{Tv<:VTypes}(::Type{Complex{Float64}}, to_ll::Bool, to_super::Bool, to_packed::Bool, to_monotonic::Bool, F::Factor{Tv})\n    @isok ccall((@cholmod_name(\"change_factor\", SuiteSparse_long),:libcholmod), Cint,\n            (Cint, Cint, Cint, Cint, Cint, Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                COMPLEX, to_ll, to_super, to_packed, to_monotonic, get(F.p), common())\n    Factor{Complex{Float64}}(F.p)\nend\n\nfunction check_sparse{Tv<:VTypes}(A::Sparse{Tv})\n    ccall((@cholmod_name(\"check_sparse\", SuiteSparse_long),:libcholmod), Cint,\n          (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n          get(A.p), common())!=0\nend\n\nfunction check_factor{Tv<:VTypes}(F::Factor{Tv})\n    ccall((@cholmod_name(\"check_factor\", SuiteSparse_long),:libcholmod), Cint,\n          (Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n          get(F.p), common())!=0\nend\n\nfunction nnz{Tv<:VTypes}(A::Sparse{Tv})\n    ccall((@cholmod_name(\"nnz\", SuiteSparse_long),:libcholmod), Int,\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                get(A.p), common())\nend\n\nfunction speye{Tv<:VTypes}(m::Integer, n::Integer, ::Type{Tv})\n    s = Sparse(ccall((@cholmod_name(\"speye\", SuiteSparse_long), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n                m, n, xtyp(Tv), common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction spzeros{Tv<:VTypes}(m::Integer, n::Integer, nzmax::Integer, ::Type{Tv})\n    s = Sparse(ccall((@cholmod_name(\"spzeros\", SuiteSparse_long), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Csize_t, Csize_t, Csize_t, Cint, Ptr{UInt8}),\n             m, n, nzmax, xtyp(Tv), common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction transpose_{Tv<:VTypes}(A::Sparse{Tv}, values::Integer)\n    s = Sparse(ccall((@cholmod_name(\"transpose\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n                get(A.p), values, common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction copy_factor{Tv<:VTypes}(F::Factor{Tv})\n    f = Factor(ccall((@cholmod_name(\"copy_factor\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Factor{Tv}},\n            (Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                get(F.p), common()))\n    finalizer(f, free!)\n    f\nend\nfunction copy_sparse{Tv<:VTypes}(A::Sparse{Tv})\n    s = Sparse(ccall((@cholmod_name(\"copy_sparse\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                get(A.p), common()))\n    finalizer(s, free!)\n    s\nend\nfunction copy{Tv<:VRealTypes}(A::Sparse{Tv}, stype::Integer, mode::Integer)\n    s = Sparse(ccall((@cholmod_name(\"copy\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Cint, Cint, Ptr{UInt8}),\n                get(A.p), stype, mode, common()))\n    finalizer(s, free!)\n    s\nend\n\n### cholmod_check.h ###\nfunction print_sparse{Tv<:VTypes}(A::Sparse{Tv}, name::String)\n    isascii(name) || error(\"non-ASCII name: $name\")\n    cm = common()\n    set_print_level(cm, 3)\n    @isok ccall((@cholmod_name(\"print_sparse\", SuiteSparse_long),:libcholmod), Cint,\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}, Ptr{UInt8}),\n                 get(A.p), name, cm)\n    nothing\nend\nfunction print_factor{Tv<:VTypes}(F::Factor{Tv}, name::String)\n    cm = common()\n    set_print_level(cm, 3)\n    @isok ccall((@cholmod_name(\"print_factor\", SuiteSparse_long),:libcholmod), Cint,\n            (Ptr{C_Factor{Tv}}, Ptr{UInt8}, Ptr{UInt8}),\n                get(F.p), name, cm)\n    nothing\nend\n\n### cholmod_matrixops.h ###\nfunction ssmult{Tv<:VRealTypes}(A::Sparse{Tv}, B::Sparse{Tv}, stype::Integer, values::Bool, sorted::Bool)\n    lA = unsafe_load(get(A.p))\n    lB = unsafe_load(get(B.p))\n    if lA.ncol != lB.nrow\n        throw(DimensionMismatch(\"inner matrix dimensions do not fit\"))\n    end\n    s = Sparse(ccall((@cholmod_name(\"ssmult\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{C_Sparse{Tv}}, Cint, Cint,\n                Cint, Ptr{UInt8}),\n             get(A.p), get(B.p), stype, values,\n                sorted, common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction norm_sparse{Tv<:VTypes}(A::Sparse{Tv}, norm::Integer)\n    if norm != 0 && norm != 1\n        throw(ArgumentError(\"norm argument must be either 0 or 1\"))\n    end\n    ccall((@cholmod_name(\"norm_sparse\", SuiteSparse_long), :libcholmod), Cdouble,\n            (Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n                get(A.p), norm, common())\nend\n\nfunction horzcat{Tv<:VRealTypes}(A::Sparse{Tv}, B::Sparse{Tv}, values::Bool)\n    s = Sparse(ccall((@cholmod_name(\"horzcat\", SuiteSparse_long), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n             get(A.p), get(B.p), values, common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction scale!{Tv<:VRealTypes}(S::Dense{Tv}, scale::Integer, A::Sparse{Tv})\n    sS = unsafe_load(get(S.p))\n    sA = unsafe_load(get(A.p))\n    sS.ncol == 1 || sS.nrow == 1 || throw(DimensionMismatch(\"first argument must be a vector\"))\n    if scale == SCALAR && sS.nrow != 1\n        throw(DimensionMismatch(\"scaling argument must have length one\"))\n    elseif scale == ROW && sS.nrow*sS.ncol != sA.nrow\n        throw(DimensionMismatch(\"scaling vector has length $(sS.nrow*sS.ncol), but matrix has $(sA.nrow) rows.\"))\n    elseif scale == COL && sS.nrow*sS.ncol != sA.ncol\n        throw(DimensionMismatch(\"scaling vector has length $(sS.nrow*sS.ncol), but matrix has $(sA.ncol) columns\"))\n    elseif scale == SYM\n        if sA.nrow != sA.ncol\n            throw(DimensionMismatch(\"matrix must be square\"))\n        elseif sS.nrow*sS.ncol != sA.nrow\n            throw(DimensionMismatch(\"scaling vector has length $(sS.nrow*sS.ncol), but matrix has $(sA.ncol) columns and rows\"))\n        end\n    end\n\n    sA = unsafe_load(get(A.p))\n    @isok ccall((@cholmod_name(\"scale\",SuiteSparse_long),:libcholmod), Cint,\n            (Ptr{C_Dense{Tv}}, Cint, Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                get(S.p), scale, get(A.p), common())\n    A\nend\n\nfunction sdmult!{Tv<:VTypes}(A::Sparse{Tv}, transpose::Bool, \u03b1::Number, \u03b2::Number, X::Dense{Tv}, Y::Dense{Tv})\n    m, n = size(A)\n    nc = transpose ? m : n\n    nr = transpose ? n : m\n    if nc != size(X, 1)\n        throw(DimensionMismatch(\"incompatible dimensions, $nc and $(size(X,1))\"))\n    end\n    @isok ccall((@cholmod_name(\"sdmult\", SuiteSparse_long),:libcholmod), Cint,\n            (Ptr{C_Sparse{Tv}}, Cint,\n             Ref{Complex128}, Ref{Complex128},\n             Ptr{C_Dense{Tv}}, Ptr{C_Dense{Tv}}, Ptr{UInt8}),\n                get(A.p), transpose, \u03b1, \u03b2, get(X.p), get(Y.p), common())\n    Y\nend\n\nfunction vertcat{Tv<:VRealTypes}(A::Sparse{Tv}, B::Sparse{Tv}, values::Bool)\n    s = Sparse(ccall((@cholmod_name(\"vertcat\", SuiteSparse_long), :libcholmod), Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n                get(A.p), get(B.p), values, common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction symmetry{Tv<:VTypes}(A::Sparse{Tv}, option::Integer)\n    xmatched = Array{SuiteSparse_long}(1)\n    pmatched = Array{SuiteSparse_long}(1)\n    nzoffdiag = Array{SuiteSparse_long}(1)\n    nzdiag = Array{SuiteSparse_long}(1)\n    rv = ccall((@cholmod_name(\"symmetry\", SuiteSparse_long), :libcholmod), Cint,\n            (Ptr{C_Sparse{Tv}}, Cint, Ptr{SuiteSparse_long}, Ptr{SuiteSparse_long},\n                Ptr{SuiteSparse_long}, Ptr{SuiteSparse_long}, Ptr{UInt8}),\n                    get(A.p), option, xmatched, pmatched,\n                        nzoffdiag, nzdiag, common())\n    rv, xmatched[1], pmatched[1], nzoffdiag[1], nzdiag[1]\nend\n\n# cholmod_cholesky.h\n# For analyze, analyze_p, and factorize_p!, the Common argument must be\n# supplied in order to control if the factorization is LLt or LDLt\nfunction analyze{Tv<:VTypes}(A::Sparse{Tv}, cmmn::Vector{UInt8})\n    f = Factor(ccall((@cholmod_name(\"analyze\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Factor{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                get(A.p), cmmn))\n    finalizer(f, free!)\n    f\nend\nfunction analyze_p{Tv<:VTypes}(A::Sparse{Tv}, perm::Vector{SuiteSparse_long},\n    cmmn::Vector{UInt8})\n    length(perm) != size(A,1) && throw(BoundsError())\n    f = Factor(ccall((@cholmod_name(\"analyze_p\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Factor{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{SuiteSparse_long}, Ptr{SuiteSparse_long}, Csize_t, Ptr{UInt8}),\n                get(A.p), perm, C_NULL, 0, cmmn))\n    finalizer(f, free!)\n    f\nend\nfunction factorize!{Tv<:VTypes}(A::Sparse{Tv}, F::Factor{Tv}, cmmn::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"factorize\", SuiteSparse_long),:libcholmod), Cint,\n        (Ptr{C_Sparse{Tv}}, Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n            get(A.p), get(F.p), cmmn)\n    F\nend\nfunction factorize_p!{Tv<:VTypes}(A::Sparse{Tv}, \u03b2::Real, F::Factor{Tv}, cmmn::Vector{UInt8})\n    # note that \u03b2 is passed as a complex number (double beta[2]),\n    # but the CHOLMOD manual says that only beta[0] (real part) is used\n    @isok ccall((@cholmod_name(\"factorize_p\", SuiteSparse_long),:libcholmod), Cint,\n        (Ptr{C_Sparse{Tv}}, Ref{Complex128}, Ptr{SuiteSparse_long}, Csize_t,\n         Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n            get(A.p), \u03b2, C_NULL, 0, get(F.p), cmmn)\n    F\nend\n\nfunction solve{Tv<:VTypes}(sys::Integer, F::Factor{Tv}, B::Dense{Tv})\n    if size(F,1) != size(B,1)\n        throw(DimensionMismatch(\"LHS and RHS should have the same number of rows. LHS has $(size(F,1)) rows, but RHS has $(size(B,1)) rows.\"))\n    end\n    d = Dense(ccall((@cholmod_name(\"solve\", SuiteSparse_long),:libcholmod), Ptr{C_Dense{Tv}},\n            (Cint, Ptr{C_Factor{Tv}}, Ptr{C_Dense{Tv}}, Ptr{UInt8}),\n                sys, get(F.p), get(B.p), common()))\n    finalizer(d, free!)\n    d\nend\n\nfunction spsolve{Tv<:VTypes}(sys::Integer, F::Factor{Tv}, B::Sparse{Tv})\n    if size(F,1) != size(B,1)\n        throw(DimensionMismatch(\"LHS and RHS should have the same number of rows. LHS has $(size(F,1)) rows, but RHS has $(size(B,1)) rows.\"))\n    end\n    s = Sparse(ccall((@cholmod_name(\"spsolve\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Cint, Ptr{C_Factor{Tv}}, Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                sys, get(F.p), get(B.p), common()))\n    finalizer(s, free!)\n    s\nend\n\n# Autodetects the types\nfunction read_sparse(file::Libc.FILE, ::Type{SuiteSparse_long})\n    ptr = ccall((@cholmod_name(\"read_sparse\", SuiteSparse_long), :libcholmod),\n        Ptr{C_SparseVoid},\n            (Ptr{Void}, Ptr{UInt8}),\n                file.ptr, common())\n    if ptr == C_NULL\n        throw(ArgumentError(\"sparse matrix construction failed. Check that input file is valid.\"))\n    end\n    s = Sparse(ptr)\n    finalizer(s, free!)\n    s\nend\n\nfunction read_sparse(file::IO, T)\n    cfile = Libc.FILE(file)\n    try return read_sparse(cfile, T)\n    finally close(cfile)\n    end\nend\n\nfunction get_perm(F::Factor)\n    s = unsafe_load(get(F.p))\n    p = unsafe_wrap(Array, s.Perm, s.n, false)\n    p+1\nend\nget_perm(FC::FactorComponent) = get_perm(Factor(FC))\n\n#########################\n# High level interfaces #\n#########################\n\n# Convertion/construction\nfunction convert{T<:VTypes}(::Type{Dense{T}}, A::StridedVecOrMat)\n    d = allocate_dense(size(A, 1), size(A, 2), stride(A, 2), T)\n    s = unsafe_load(d.p)\n    for i in eachindex(A)\n        unsafe_store!(s.x, A[i], i)\n    end\n    d\nend\nfunction convert(::Type{Dense}, A::StridedVecOrMat)\n    T = promote_type(eltype(A), Float64)\n    return convert(Dense{T}, A)\nend\nconvert(::Type{Dense}, A::Sparse) = sparse_to_dense(A)\n\n# This constructior assumes zero based colptr and rowval\nfunction (::Type{Sparse}){Tv<:VTypes}(m::Integer, n::Integer,\n        colptr0::Vector{SuiteSparse_long}, rowval0::Vector{SuiteSparse_long},\n        nzval::Vector{Tv}, stype)\n    # checks\n    ## length of input\n    if length(colptr0) <= n\n        throw(ArgumentError(\"length of colptr0 must be at least n + 1 = $(n + 1) but was $(length(colptr0))\"))\n    end\n    if colptr0[n + 1] > length(rowval0)\n        throw(ArgumentError(\"length of rowval0 is $(length(rowval0)) but value of colptr0 requires length to be at least $(colptr0[n + 1])\"))\n    end\n    if colptr0[n + 1] > length(nzval)\n        throw(ArgumentError(\"length of nzval is $(length(nzval)) but value of colptr0 requires length to be at least $(colptr0[n + 1])\"))\n    end\n    ## columns are sorted\n    iss = true\n    for i = 2:length(colptr0)\n        if !issorted(view(rowval0, colptr0[i - 1] + 1:colptr0[i]))\n            iss = false\n            break\n        end\n    end\n\n    o = allocate_sparse(m, n, colptr0[n + 1], iss, true, stype, Tv)\n    s = unsafe_load(o.p)\n\n    unsafe_copy!(s.p, pointer(colptr0), n + 1)\n    unsafe_copy!(s.i, pointer(rowval0), colptr0[n + 1])\n    unsafe_copy!(s.x, pointer(nzval) , colptr0[n + 1])\n\n    @isok check_sparse(o)\n\n    return o\nend\n\nfunction (::Type{Sparse}){Tv<:VTypes}(m::Integer, n::Integer,\n        colptr0::Vector{SuiteSparse_long},\n        rowval0::Vector{SuiteSparse_long},\n        nzval::Vector{Tv})\n    o = Sparse(m, n, colptr0, rowval0, nzval, 0)\n\n    # check if array is symmetric and change stype if it is\n    if ishermitian(o)\n        change_stype!(o, -1)\n    end\n    o\nend\n\nfunction (::Type{Sparse}){Tv<:VTypes}(A::SparseMatrixCSC{Tv,SuiteSparse_long}, stype::Integer)\n    ## Check length of input. This should never fail but see #20024\n    if length(A.colptr) <= A.n\n        throw(ArgumentError(\"length of colptr must be at least size(A,2) + 1 = $(A.n + 1) but was $(length(A.colptr))\"))\n    end\n    if nnz(A) > length(A.rowval)\n        throw(ArgumentError(\"length of rowval is $(length(A.rowval)) but value of colptr requires length to be at least $(nnz(A))\"))\n    end\n    if nnz(A) > length(A.nzval)\n        throw(ArgumentError(\"length of nzval is $(length(A.nzval)) but value of colptr requires length to be at least $(nnz(A))\"))\n    end\n\n    o = allocate_sparse(A.m, A.n, nnz(A), true, true, stype, Tv)\n    s = unsafe_load(o.p)\n    for i = 1:(A.n + 1)\n        unsafe_store!(s.p, A.colptr[i] - 1, i)\n    end\n    for i = 1:nnz(A)\n        unsafe_store!(s.i, A.rowval[i] - 1, i)\n    end\n    unsafe_copy!(s.x, pointer(A.nzval), nnz(A))\n\n    @isok check_sparse(o)\n\n    return o\nend\n\n# convert SparseVectors into CHOLMOD Sparse types through a mx1 CSC matrix\nconvert{Tv<:VTypes}(::Type{Sparse}, A::SparseVector{Tv,SuiteSparse_long}) = convert(Sparse, convert(SparseMatrixCSC, A))\nfunction convert{Tv<:VTypes,Ti<:ITypes}(::Type{Sparse}, A::SparseMatrixCSC{Tv,Ti})\n    o = Sparse(A, 0)\n    # check if array is symmetric and change stype if it is\n    if ishermitian(o)\n        change_stype!(o, -1)\n    end\n    o\nend\nconvert{Ti<:ITypes}(::Type{Sparse}, A::SparseMatrixCSC{Complex{Float32},Ti}) = convert(Sparse, convert(SparseMatrixCSC{Complex{Float64},SuiteSparse_long}, A))\nconvert(::Type{Sparse}, A::Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}}) = Sparse(A.data, A.uplo == 'L' ? -1 : 1)\nconvert{Tv<:VTypes}(::Type{Sparse}, A::Hermitian{Tv,SparseMatrixCSC{Tv,SuiteSparse_long}}) = Sparse(A.data, A.uplo == 'L' ? -1 : 1)\nfunction convert{Ti<:ITypes}(::Type{Sparse},\n    A::Union{SparseMatrixCSC{BigFloat,Ti},\n             Symmetric{BigFloat,SparseMatrixCSC{BigFloat,Ti}},\n             Hermitian{Complex{BigFloat},SparseMatrixCSC{Complex{BigFloat},Ti}}},\n    args...)\n    throw(MethodError(convert, (Sparse, A)))\nend\nfunction convert{T,Ti<:ITypes}(::Type{Sparse},\n    A::Union{SparseMatrixCSC{T,Ti},\n             Symmetric{T,SparseMatrixCSC{T,Ti}},\n             Hermitian{T,SparseMatrixCSC{T,Ti}}},\n    args...)\n    return Sparse(convert(AbstractMatrix{promote_type(Float64, T)}, A), args...)\nend\n\n# Useful when reading in files, but not type stable\nfunction convert(::Type{Sparse}, p::Ptr{C_SparseVoid})\n    if p == C_NULL\n        throw(ArgumentError(\"sparse matrix construction failed for unknown reasons. Please submit a bug report.\"))\n    end\n\n    s = unsafe_load(p)\n\n    # Check integer type\n    if s.itype == INT\n        free_sparse!(p)\n        throw(CHOLMODException(\"the value of itype was $s.itype. Only integer type of $SuiteSparse_long is supported.\"))\n    elseif s.itype == INTLONG\n        free_sparse!(p)\n        throw(CHOLMODException(\"the value of itype was $s.itype. This combination of integer types shouldn't happen. Please submit a bug report.\"))\n    elseif s.itype != LONG # must be s.itype == LONG\n        free_sparse!(p)\n        throw(CHOLMODException(\"illegal value of itype: $s.itype\"))\n    end\n\n    # Check for double or single precision\n    if s.dtype == DOUBLE\n        Tv = Float64\n    elseif s.dtype == SINGLE\n        # Tv = Float32 # this should be supported at some point\n        free_sparse!(p)\n        throw(CHOLMODException(\"single precision not supported yet\"))\n    else\n        free_sparse!(p)\n        throw(CHOLMODException(\"illegal value of dtype: $s.dtype\"))\n    end\n\n    # Check for real or complex\n    if s.xtype == COMPLEX\n        Tv = Complex{Tv}\n    elseif s.xtype != REAL\n        free_sparse!(p)\n        throw(CHOLMODException(\"illegal value of xtype: $s.xtype\"))\n    end\n\n    return Sparse(convert(Ptr{C_Sparse{Tv}}, p))\nend\n\nconvert(::Type{Sparse}, A::Dense) = dense_to_sparse(A, SuiteSparse_long)\nconvert(::Type{Sparse}, L::Factor) = factor_to_sparse!(copy(L))\nfunction (::Type{Sparse})(filename::String)\n    open(filename) do f\n        return read_sparse(f, SuiteSparse_long)\n    end\nend\n\n## convertion back to base Julia types\nfunction convert{T}(::Type{Matrix{T}}, D::Dense{T})\n    s = unsafe_load(D.p)\n    a = Array{T}(s.nrow, s.ncol)\n    copy!(a, D)\nend\n\nBase.copy!(dest::Base.PermutedDimsArrays.PermutedDimsArray, src::Dense) = _copy!(dest, src) # ambig\nBase.copy!(dest::AbstractArray, D::Dense) = _copy!(dest, D)\n\nfunction _copy!(dest::AbstractArray, D::Dense)\n    s = unsafe_load(D.p)\n    n = s.nrow*s.ncol\n    n <= length(dest) || throw(BoundsError(dest, n))\n    if s.d == s.nrow && isa(dest, Array)\n        unsafe_copy!(pointer(dest), s.x, s.d*s.ncol)\n    else\n        k = 0\n        for j = 1:s.ncol\n            for i = 1:s.nrow\n                dest[k+=1] = unsafe_load(s.x, i + (j - 1)*s.d)\n            end\n        end\n    end\n    dest\nend\nconvert{T}(::Type{Matrix}, D::Dense{T}) = convert(Matrix{T}, D)\nfunction convert{T}(::Type{Vector{T}}, D::Dense{T})\n    if size(D, 2) > 1\n        throw(DimensionMismatch(\"input must be a vector but had $(size(D, 2)) columns\"))\n    end\n    copy!(Array{T}(size(D, 1)), D)\nend\nconvert{T}(::Type{Vector}, D::Dense{T}) = convert(Vector{T}, D)\n\nfunction convert{Tv}(::Type{SparseMatrixCSC{Tv,SuiteSparse_long}}, A::Sparse{Tv})\n    s = unsafe_load(A.p)\n    if s.stype != 0\n        throw(ArgumentError(\"matrix has stype != 0. Convert to matrix with stype == 0 before converting to SparseMatrixCSC\"))\n    end\n    return SparseMatrixCSC(s.nrow, s.ncol, increment(unsafe_wrap(Array, s.p, (s.ncol + 1,), false)), increment(unsafe_wrap(Array, s.i, (s.nzmax,), false)), copy(unsafe_wrap(Array, s.x, (s.nzmax,), false)))\nend\nfunction convert(::Type{Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}}}, A::Sparse{Float64})\n    s = unsafe_load(A.p)\n    if !issymmetric(A)\n        throw(ArgumentError(\"matrix is not symmetric\"))\n    end\n    return Symmetric(SparseMatrixCSC(s.nrow, s.ncol, increment(unsafe_wrap(Array, s.p, (s.ncol + 1,), false)), increment(unsafe_wrap(Array, s.i, (s.nzmax,), false)), copy(unsafe_wrap(Array, s.x, (s.nzmax,), false))), s.stype > 0 ? :U : :L)\nend\nfunction convert{Tv<:VTypes}(::Type{Hermitian{Tv,SparseMatrixCSC{Tv,SuiteSparse_long}}}, A::Sparse{Tv})\n    s = unsafe_load(A.p)\n    if !ishermitian(A)\n        throw(ArgumentError(\"matrix is not Hermitian\"))\n    end\n    return Hermitian(SparseMatrixCSC(s.nrow, s.ncol, increment(unsafe_wrap(Array, s.p, (s.ncol + 1,), false)), increment(unsafe_wrap(Array, s.i, (s.nzmax,), false)), copy(unsafe_wrap(Array, s.x, (s.nzmax,), false))), s.stype > 0 ? :U : :L)\nend\nfunction sparse(A::Sparse{Float64}) # Notice! Cannot be type stable because of stype\n    s = unsafe_load(A.p)\n    if s.stype == 0\n        return convert(SparseMatrixCSC{Float64,SuiteSparse_long}, A)\n    end\n    return convert(Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}}, A)\nend\nfunction sparse(A::Sparse{Complex{Float64}}) # Notice! Cannot be type stable because of stype\n    s = unsafe_load(A.p)\n    if s.stype == 0\n        return convert(SparseMatrixCSC{Complex{Float64},SuiteSparse_long}, A)\n    end\n    return convert(Hermitian{Complex{Float64},SparseMatrixCSC{Complex{Float64},SuiteSparse_long}}, A)\nend\nfunction sparse(F::Factor)\n    s = unsafe_load(F.p)\n    if s.is_ll != 0\n        L = Sparse(F)\n        A = sparse(L*L')\n    else\n        LD = sparse(F[:LD])\n        L, d = getLd!(LD)\n        A = (L * Diagonal(d)) * L'\n    end\n    SparseArrays.sortSparseMatrixCSC!(A)\n    p = get_perm(F)\n    if p != [1:s.n;]\n        pinv = Array{Int}(length(p))\n        for k = 1:length(p)\n            pinv[p[k]] = k\n        end\n        A = A[pinv,pinv]\n    end\n    A\nend\n\nsparse(D::Dense) = sparse(Sparse(D))\n\nfunction sparse{Tv}(FC::FactorComponent{Tv,:L})\n    F = Factor(FC)\n    s = unsafe_load(F.p)\n    s.is_ll != 0 || throw(CHOLMODException(\"sparse: supported only for :LD on LDLt factorizations\"))\n    sparse(Sparse(F))\nend\nsparse{Tv}(FC::FactorComponent{Tv,:LD}) = sparse(Sparse(Factor(FC)))\n\n# Calculate the offset into the stype field of the cholmod_sparse_struct and\n# change the value\nlet offset = fieldoffset(C_Sparse{Float64}, findfirst(fieldnames(C_Sparse) .== :stype))\n    global change_stype!\n    function change_stype!(A::Sparse, i::Integer)\n        unsafe_store!(convert(Ptr{Cint}, A.p), i, div(offset, 4) + 1)\n        return A\n    end\nend\n\nfree!(A::Dense) = free_dense!(A.p)\nfree!(A::Sparse) = free_sparse!(A.p)\nfree!(F::Factor) = free_factor!(F.p)\n\neltype{T<:VTypes}(::Type{Dense{T}}) = T\neltype{T<:VTypes}(::Type{Factor{T}}) = T\neltype{T<:VTypes}(::Type{Sparse{T}}) = T\n\nnnz(F::Factor) = nnz(Sparse(F))\n\nfunction show(io::IO, F::Factor)\n    println(io, typeof(F))\n    showfactor(io, F)\nend\n\nfunction show(io::IO, FC::FactorComponent)\n    println(io, typeof(FC))\n    showfactor(io, Factor(FC))\nend\n\nfunction showfactor(io::IO, F::Factor)\n    s = unsafe_load(get(F.p))\n    @printf(io, \"type: %12s\\n\", s.is_ll!=0 ? \"LLt\" : \"LDLt\")\n    @printf(io, \"method: %10s\\n\", s.is_super!=0 ? \"supernodal\" : \"simplicial\")\n    @printf(io, \"maxnnz: %10d\\n\", Int(s.nzmax))\n    @printf(io, \"nnz: %13d\\n\", nnz(F))\nend\n\n# getindex not defined for these, so don't use the normal array printer\nshow(io::IO, ::MIME\"text/plain\", FC::FactorComponent) = show(io, FC)\nshow(io::IO, ::MIME\"text/plain\", F::Factor) = show(io, F)\n\nisvalid(A::Dense) = check_dense(A)\nisvalid(A::Sparse) = check_sparse(A)\nisvalid(A::Factor) = check_factor(A)\n\ncopy(A::Dense) = copy_dense(A)\ncopy(A::Sparse) = copy_sparse(A)\ncopy(A::Factor) = copy_factor(A)\n\nfunction size(A::Union{Dense,Sparse})\n    s = unsafe_load(get(A.p))\n    return (Int(s.nrow), Int(s.ncol))\nend\nfunction size(F::Factor, i::Integer)\n    if i < 1\n        throw(ArgumentError(\"dimension must be positive\"))\n    end\n    s = unsafe_load(get(F.p))\n    if i <= 2\n        return Int(s.n)\n    end\n    return 1\nend\nsize(F::Factor) = (size(F, 1), size(F, 2))\n\nlinearindexing(::Dense) = LinearFast()\n\nsize(FC::FactorComponent, i::Integer) = size(FC.F, i)\nsize(FC::FactorComponent) = size(FC.F)\n\nctranspose{Tv}(FC::FactorComponent{Tv,:L}) = FactorComponent{Tv,:U}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:U}) = FactorComponent{Tv,:L}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:PtL}) = FactorComponent{Tv,:UP}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:UP}) = FactorComponent{Tv,:PtL}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:D}) = FC\nctranspose{Tv}(FC::FactorComponent{Tv,:LD}) = FactorComponent{Tv,:DU}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:DU}) = FactorComponent{Tv,:LD}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:PtLD}) = FactorComponent{Tv,:DUP}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:DUP}) = FactorComponent{Tv,:PtLD}(FC.F)\n\nfunction getindex(A::Dense, i::Integer)\n    s = unsafe_load(get(A.p))\n    0 < i <= s.nrow*s.ncol || throw(BoundsError())\n    unsafe_load(s.x, i)\nend\n\nlinearindexing(::Sparse) = LinearSlow()\nfunction getindex{T}(A::Sparse{T}, i0::Integer, i1::Integer)\n    s = unsafe_load(get(A.p))\n    !(1 <= i0 <= s.nrow && 1 <= i1 <= s.ncol) && throw(BoundsError())\n    s.stype < 0 && i0 < i1 && return conj(A[i1,i0])\n    s.stype > 0 && i0 > i1 && return conj(A[i1,i0])\n\n    r1 = Int(unsafe_load(s.p, i1) + 1)\n    r2 = Int(unsafe_load(s.p, i1 + 1))\n    (r1 > r2) && return zero(T)\n    r1 = Int(searchsortedfirst(unsafe_wrap(Array, s.i, (s.nzmax,), false), i0 - 1, r1, r2, Base.Order.Forward))\n    ((r1 > r2) || (unsafe_load(s.i, r1) + 1 != i0)) ? zero(T) : unsafe_load(s.x, r1)\nend\n\nfunction getindex(F::Factor, sym::Symbol)\n    sym == :p && return get_perm(F)\n    FactorComponent(F, sym)\nend\n\nfunction getLd!(S::SparseMatrixCSC)\n    d = Array{eltype(S)}(size(S, 1))\n    fill!(d, 0)\n    col = 1\n    for k = 1:nnz(S)\n        while k >= S.colptr[col+1]\n            col += 1\n        end\n        if S.rowval[k] == col\n            d[col] = S.nzval[k]\n            S.nzval[k] = 1\n        end\n    end\n    S, d\nend\n\n## Multiplication\n(*)(A::Sparse, B::Sparse) = ssmult(A, B, 0, true, true)\n(*)(A::Sparse, B::Dense) = sdmult!(A, false, 1., 0., B, zeros(size(A, 1), size(B, 2)))\n(*)(A::Sparse, B::VecOrMat) = (*)(A, Dense(B))\n\nfunction A_mul_Bc{Tv<:VRealTypes}(A::Sparse{Tv}, B::Sparse{Tv})\n    cm = common()\n\n    if !is(A,B)\n        aa1 = transpose_(B, 2)\n        ## result of ssmult will have stype==0, contain numerical values and be sorted\n        return ssmult(A, aa1, 0, true, true)\n    end\n\n    ## The A*A' case is handled by cholmod_aat. This routine requires\n    ## A->stype == 0 (storage of upper and lower parts). If neccesary\n    ## the matrix A is first converted to stype == 0\n    s = unsafe_load(A.p)\n    if s.stype != 0\n        aa1 = copy(A, 0, 1)\n        return aat(aa1, SuiteSparse_long[0:s.ncol-1;], 1)\n    else\n        return aat(A, SuiteSparse_long[0:s.ncol-1;], 1)\n    end\nend\n\nfunction Ac_mul_B(A::Sparse, B::Sparse)\n    aa1 = transpose_(A, 2)\n    if is(A,B)\n        return A_mul_Bc(aa1, aa1)\n    end\n    ## result of ssmult will have stype==0, contain numerical values and be sorted\n    return ssmult(aa1, B, 0, true, true)\nend\n\nAc_mul_B(A::Sparse, B::Dense) = sdmult!(A, true, 1., 0., B, zeros(size(A, 2), size(B, 2)))\nAc_mul_B(A::Sparse, B::VecOrMat) =  Ac_mul_B(A, Dense(B))\n\n\n## Factorization methods\n\n## Compute that symbolic factorization only\nfunction fact_{Tv<:VTypes}(A::Sparse{Tv}, cm::Array{UInt8};\n    perm::AbstractVector{SuiteSparse_long}=SuiteSparse_long[],\n    postorder::Bool=true, userperm_only::Bool=true)\n\n    sA = unsafe_load(get(A.p))\n    sA.stype == 0 && throw(ArgumentError(\"sparse matrix is not symmetric/Hermitian\"))\n\n    if !postorder\n        unsafe_store!(common_postorder, 0)\n    end\n\n    if isempty(perm)\n        F = analyze(A, cm)\n    else # user permutation provided\n        if userperm_only # use perm even if it is worse than AMD\n            unsafe_store!(common_nmethods, 1)\n        end\n        F = analyze_p(A, SuiteSparse_long[p-1 for p in perm], cm)\n    end\n\n    return F\nend\n\nfunction cholfact!{Tv}(F::Factor{Tv}, A::Sparse{Tv}; shift::Real=0.0)\n    cm = common()\n\n    # Makes it an LLt\n    unsafe_store!(common_final_ll, 1)\n\n    # Compute the numerical factorization\n    factorize_p!(A, shift, F, cm)\n\n    s = unsafe_load(get(F.p))\n    s.minor < size(A, 1) && throw(Base.LinAlg.PosDefException(s.minor))\n    return F\nend\n\n\"\"\"\n    cholfact!(F::Factor, A; shift = 0.0) -> CHOLMOD.Factor\n\nCompute the Cholesky (``LL'``) factorization of `A`, reusing the symbolic\nfactorization `F`. `A` must be a `SparseMatrixCSC`, `Symmetric{SparseMatrixCSC}`,\nor `Hermitian{SparseMatrixCSC}`. Note that even if `A` doesn't\nhave the type tag, it must still be symmetric or Hermitian.\n\n!!! note\n    This method uses the CHOLMOD library from SuiteSparse, which only supports\n    doubles or complex doubles. Input matrices not of those element types will\n    be converted to `SparseMatrixCSC{Float64}` or `SparseMatrixCSC{Complex128}`\n    as appropriate.\n\"\"\"\ncholfact!{T<:Real}(F::Factor, A::Union{SparseMatrixCSC{T},\n        SparseMatrixCSC{Complex{T}},\n        Symmetric{T,SparseMatrixCSC{T,SuiteSparse_long}},\n        Hermitian{Complex{T},SparseMatrixCSC{Complex{T},SuiteSparse_long}},\n        Hermitian{T,SparseMatrixCSC{T,SuiteSparse_long}}};\n    shift = 0.0) =\n    cholfact!(F, Sparse(A); shift = shift)\n\nfunction cholfact(A::Sparse; shift::Real=0.0,\n    perm::AbstractVector{SuiteSparse_long}=SuiteSparse_long[])\n\n    cm = defaults(common())\n    set_print_level(cm, 0)\n\n    # Compute the symbolic factorization\n    F = fact_(A, cm; perm = perm)\n\n    # Compute the numerical factorization\n    cholfact!(F, A; shift = shift)\n\n    s = unsafe_load(get(F.p))\n    s.minor < size(A, 1) && throw(Base.LinAlg.PosDefException(s.minor))\n    return F\nend\n\n\"\"\"\n    cholfact(A; shift = 0.0, perm = Int[]) -> CHOLMOD.Factor\n\nCompute the Cholesky factorization of a sparse positive definite matrix `A`.\n`A` must be a `SparseMatrixCSC`, `Symmetric{SparseMatrixCSC}`, or\n`Hermitian{SparseMatrixCSC}`. Note that even if `A` doesn't\nhave the type tag, it must still be symmetric or Hermitian.\nA fill-reducing permutation is used.\n`F = cholfact(A)` is most frequently used to solve systems of equations with `F\\\\b`,\nbut also the methods `diag`, `det`, `logdet` are defined for `F`.\nYou can also extract individual factors from `F`, using `F[:L]`.\nHowever, since pivoting is on by default, the factorization is internally\nrepresented as `A == P'*L*L'*P` with a permutation matrix `P`;\nusing just `L` without accounting for `P` will give incorrect answers.\nTo include the effects of permutation,\nit's typically preferable to extact \"combined\" factors like `PtL = F[:PtL]`\n(the equivalent of `P'*L`) and `LtP = F[:UP]` (the equivalent of `L'*P`).\n\nSetting optional `shift` keyword argument computes the factorization of\n`A+shift*I` instead of `A`. If the `perm` argument is nonempty,\nit should be a permutation of `1:size(A,1)` giving the ordering to use\n(instead of CHOLMOD's default AMD ordering).\n\n!!! note\n    This method uses the CHOLMOD library from SuiteSparse, which only supports\n    doubles or complex doubles. Input matrices not of those element types will\n    be converted to `SparseMatrixCSC{Float64}` or `SparseMatrixCSC{Complex128}`\n    as appropriate.\n\n    Many other functions from CHOLMOD are wrapped but not exported from the\n    `Base.SparseArrays.CHOLMOD` module.\n\"\"\"\ncholfact{T<:Real}(A::Union{SparseMatrixCSC{T}, SparseMatrixCSC{Complex{T}},\n    Symmetric{T,SparseMatrixCSC{T,SuiteSparse_long}},\n    Hermitian{Complex{T},SparseMatrixCSC{Complex{T},SuiteSparse_long}},\n    Hermitian{T,SparseMatrixCSC{T,SuiteSparse_long}}};\n    kws...) = cholfact(Sparse(A); kws...)\n\n\nfunction ldltfact!{Tv}(F::Factor{Tv}, A::Sparse{Tv}; shift::Real=0.0)\n    cm = common()\n\n    # Compute the numerical factorization\n    factorize_p!(A, shift, F, cm)\n\n    s = unsafe_load(get(F.p))\n    s.minor < size(A, 1) && throw(Base.LinAlg.ArgumentError(\"matrix has one or more zero pivots\"))\n    return F\nend\n\n\"\"\"\n    ldltfact!(F::Factor, A; shift = 0.0) -> CHOLMOD.Factor\n\nCompute the ``LDL'`` factorization of `A`, reusing the symbolic factorization `F`.\n`A` must be a `SparseMatrixCSC`, `Symmetric{SparseMatrixCSC}`, or\n`Hermitian{SparseMatrixCSC}`. Note that even if `A` doesn't\nhave the type tag, it must still be symmetric or Hermitian.\n\n!!! note\n    This method uses the CHOLMOD library from SuiteSparse, which only supports\n    doubles or complex doubles. Input matrices not of those element types will\n    be converted to `SparseMatrixCSC{Float64}` or `SparseMatrixCSC{Complex128}`\n    as appropriate.\n\"\"\"\nldltfact!{T<:Real}(F::Factor, A::Union{SparseMatrixCSC{T},\n    SparseMatrixCSC{Complex{T}},\n    Symmetric{T,SparseMatrixCSC{T,SuiteSparse_long}},\n    Hermitian{Complex{T},SparseMatrixCSC{Complex{T},SuiteSparse_long}},\n    Hermitian{T,SparseMatrixCSC{T,SuiteSparse_long}}};\n    shift = 0.0) =\n    ldltfact!(F, Sparse(A), shift = shift)\n\nfunction ldltfact(A::Sparse; shift::Real=0.0,\n    perm::AbstractVector{SuiteSparse_long}=SuiteSparse_long[])\n\n    cm = defaults(common())\n    set_print_level(cm, 0)\n\n    # Makes it an LDLt\n    unsafe_store!(common_final_ll, 0)\n    # Really make sure it's an LDLt by avoiding supernodal factorisation\n    unsafe_store!(common_supernodal, 0)\n\n    # Compute the symbolic factorization\n    F = fact_(A, cm; perm = perm)\n\n    # Compute the numerical factorization\n    ldltfact!(F, A; shift = shift)\n\n    s = unsafe_load(get(F.p))\n    s.minor < size(A, 1) && throw(Base.LinAlg.ArgumentError(\"matrix has one or more zero pivots\"))\n    return F\nend\n\n\"\"\"\n    ldltfact(A; shift = 0.0, perm=Int[]) -> CHOLMOD.Factor\n\nCompute the ``LDL'`` factorization of a sparse matrix `A`.\n`A` must be a `SparseMatrixCSC`, `Symmetric{SparseMatrixCSC}`, or\n`Hermitian{SparseMatrixCSC}`. Note that even if `A` doesn't\nhave the type tag, it must still be symmetric or Hermitian.\nA fill-reducing permutation is used. `F = ldltfact(A)` is most frequently\nused to solve systems of equations `A*x = b` with `F\\\\b`. The returned\nfactorization object `F` also supports the methods `diag`,\n`det`, and `logdet`. You can extract individual factors from `F` using `F[:L]`.\nHowever, since pivoting is on by default, the factorization is internally\nrepresented as `A == P'*L*D*L'*P` with a permutation matrix `P`;\nusing just `L` without accounting for `P` will give incorrect answers.\nTo include the effects of permutation, it is typically preferable to extact\n\"combined\" factors like `PtL = F[:PtL]` (the equivalent of\n`P'*L`) and `LtP = F[:UP]` (the equivalent of `L'*P`).\nThe complete list of supported factors is `:L, :PtL, :D, :UP, :U, :LD, :DU, :PtLD, :DUP`.\n\nSetting optional `shift` keyword argument computes the factorization of\n`A+shift*I` instead of `A`. If the `perm` argument is nonempty,\nit should be a permutation of `1:size(A,1)` giving the ordering to use\n(instead of CHOLMOD's default AMD ordering).\n\n!!! note\n    This method uses the CHOLMOD library from SuiteSparse, which only supports\n    doubles or complex doubles. Input matrices not of those element types will\n    be converted to `SparseMatrixCSC{Float64}` or `SparseMatrixCSC{Complex128}`\n    as appropriate.\n\n    Many other functions from CHOLMOD are wrapped but not exported from the\n    `Base.SparseArrays.CHOLMOD` module.\n\"\"\"\nldltfact{T<:Real}(A::Union{SparseMatrixCSC{T},SparseMatrixCSC{Complex{T}},\n    Symmetric{T,SparseMatrixCSC{T,SuiteSparse_long}},\n    Hermitian{Complex{T},SparseMatrixCSC{Complex{T},SuiteSparse_long}},\n    Hermitian{T,SparseMatrixCSC{T,SuiteSparse_long}}};\n    kws...) = ldltfact(Sparse(A); kws...)\n\n## Solvers\n\nfor (T, f) in ((:Dense, :solve), (:Sparse, :spsolve))\n    @eval begin\n        # Solve Lx = b and L'x=b where A = L*L'\n        function (\\){T}(L::FactorComponent{T,:L}, B::$T)\n            ($f)(CHOLMOD_L, Factor(L), B)\n        end\n        function (\\){T}(L::FactorComponent{T,:U}, B::$T)\n            ($f)(CHOLMOD_Lt, Factor(L), B)\n        end\n        # Solve PLx = b and L'P'x=b where A = P*L*L'*P'\n        function (\\){T}(L::FactorComponent{T,:PtL}, B::$T)\n            F = Factor(L)\n            ($f)(CHOLMOD_L, F, ($f)(CHOLMOD_P, F, B))  # Confusingly, CHOLMOD_P solves P'x = b\n        end\n        function (\\){T}(L::FactorComponent{T,:UP}, B::$T)\n            F = Factor(L)\n            ($f)(CHOLMOD_Pt, F, ($f)(CHOLMOD_Lt, F, B))\n        end\n        # Solve various equations for A = L*D*L' and A = P*L*D*L'*P'\n        function (\\){T}(L::FactorComponent{T,:D}, B::$T)\n            ($f)(CHOLMOD_D, Factor(L), B)\n        end\n        function (\\){T}(L::FactorComponent{T,:LD}, B::$T)\n            ($f)(CHOLMOD_LD, Factor(L), B)\n        end\n        function (\\){T}(L::FactorComponent{T,:DU}, B::$T)\n            ($f)(CHOLMOD_DLt, Factor(L), B)\n        end\n        function (\\){T}(L::FactorComponent{T,:PtLD}, B::$T)\n            F = Factor(L)\n            ($f)(CHOLMOD_LD, F, ($f)(CHOLMOD_P, F, B))\n        end\n        function (\\){T}(L::FactorComponent{T,:DUP}, B::$T)\n            F = Factor(L)\n            ($f)(CHOLMOD_Pt, F, ($f)(CHOLMOD_DLt, F, B))\n        end\n    end\nend\n\ntypealias SparseVecOrMat{Tv,Ti} Union{SparseVector{Tv,Ti}, SparseMatrixCSC{Tv,Ti}}\n\nfunction (\\)(L::FactorComponent, b::Vector)\n    reshape(convert(Matrix, L\\Dense(b)), length(b))\nend\nfunction (\\)(L::FactorComponent, B::Matrix)\n    convert(Matrix, L\\Dense(B))\nend\nfunction (\\)(L::FactorComponent, B::SparseVecOrMat)\n    sparse(L\\Sparse(B,0))\nend\n\nAc_ldiv_B(L::FactorComponent, B) = ctranspose(L)\\B\n\n(\\){T<:VTypes}(L::Factor{T}, B::Dense{T}) = solve(CHOLMOD_A, L, B)\n(\\)(L::Factor{Float64}, B::VecOrMat{Complex{Float64}}) = complex(L\\real(B), L\\imag(B))\n# First explicit TypeVars are necessary to avoid ambiguity errors with definition in\n# linalg/factorizations.jl\n(\\){T<:VTypes}(L::Factor{T}, b::StridedVector) = Vector(L\\convert(Dense{T}, b))\n(\\){T<:VTypes}(L::Factor{T}, B::StridedMatrix) = Matrix(L\\convert(Dense{T}, B))\n(\\)(L::Factor, B::Sparse) = spsolve(CHOLMOD_A, L, B)\n# When right hand side is sparse, we have to ensure that the rhs is not marked as symmetric.\n(\\)(L::Factor, B::SparseVecOrMat) = sparse(spsolve(CHOLMOD_A, L, Sparse(B, 0)))\n\nAc_ldiv_B(L::Factor, B::Dense) = solve(CHOLMOD_A, L, B)\nAc_ldiv_B(L::Factor, B::VecOrMat) = convert(Matrix, solve(CHOLMOD_A, L, Dense(B)))\nAc_ldiv_B(L::Factor, B::Sparse) = spsolve(CHOLMOD_A, L, B)\nAc_ldiv_B(L::Factor, B::SparseVecOrMat) = Ac_ldiv_B(L, Sparse(B))\n\nfor f in (:\\, :Ac_ldiv_B)\n    @eval function ($f)(A::Union{Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}},\n                          Hermitian{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}},\n                          Hermitian{Complex{Float64},SparseMatrixCSC{Complex{Float64},SuiteSparse_long}}}, B::StridedVecOrMat)\n        try\n            return ($f)(cholfact(A), B)\n        catch e\n            isa(e, LinAlg.PosDefException) || rethrow(e)\n            return ($f)(ldltfact(A) , B)\n        end\n    end\nend\n\n## Other convenience methods\nfunction diag{Tv}(F::Factor{Tv})\n    f = unsafe_load(get(F.p))\n    fsuper = f.super\n    fpi = f.pi\n    res = Base.zeros(Tv, Int(f.n))\n    xv  = f.x\n    if f.is_super!=0\n        px = f.px\n        pos = 1\n        for i in 1:f.nsuper\n            base = unsafe_load(px, i) + 1\n            res[pos] = unsafe_load(xv, base)\n            pos += 1\n            for j in 1:unsafe_load(fsuper, i + 1) - unsafe_load(fsuper, i) - 1\n                res[pos] = unsafe_load(xv, base + j*(unsafe_load(fpi, i + 1) - unsafe_load(fpi, i) + 1))\n                pos += 1\n            end\n        end\n    else\n        c0 = f.p\n        r0 = f.i\n        xv = f.x\n        for j in 1:f.n\n            jj = unsafe_load(c0, j) + 1\n            assert(unsafe_load(r0, jj) == j - 1)\n            res[j] = unsafe_load(xv, jj)\n        end\n    end\n    res\nend\n\nfunction logdet{Tv<:VTypes}(F::Factor{Tv})\n    f = unsafe_load(get(F.p))\n    res = zero(Tv)\n    for d in diag(F); res += log(abs(d)) end\n    f.is_ll!=0 ? 2res : res\nend\n\ndet(L::Factor) = exp(logdet(L))\n\nfunction isposdef{Tv<:VTypes}(A::SparseMatrixCSC{Tv,SuiteSparse_long})\n    if !ishermitian(A)\n        return false\n    end\n    try\n        f = cholfact(A)\n    catch e\n        isa(e, LinAlg.PosDefException) || rethrow(e)\n        return false\n    end\n    true\nend\n\nfunction issymmetric(A::Sparse)\n    s = unsafe_load(A.p)\n    if s.stype != 0\n        return isreal(A)\n    end\n    i = symmetry(A, 1)[1]\n    return i == MM_SYMMETRIC || i == MM_SYMMETRIC_POSDIAG\nend\n\nfunction ishermitian(A::Sparse{Float64})\n    s = unsafe_load(A.p)\n    if s.stype != 0\n        return true\n    else\n        i = symmetry(A, 1)[1]\n        return i == MM_SYMMETRIC || i == MM_SYMMETRIC_POSDIAG\n    end\nend\nfunction ishermitian(A::Sparse{Complex{Float64}})\n    s = unsafe_load(A.p)\n    if s.stype != 0\n        return true\n    else\n        i = symmetry(A, 1)[1]\n        return i == MM_HERMITIAN || i == MM_HERMITIAN_POSDIAG\n    end\nend\n\n(*){Ti}(A::Symmetric{Float64,SparseMatrixCSC{Float64,Ti}}, B::SparseVecOrMat{Float64,Ti}) = sparse(Sparse(A)*Sparse(B))\n(*){Ti}(A::Hermitian{Complex{Float64},SparseMatrixCSC{Complex{Float64},Ti}}, B::SparseVecOrMat{Complex{Float64},Ti}) = sparse(Sparse(A)*Sparse(B))\n(*){Ti}(A::Hermitian{Float64,SparseMatrixCSC{Float64,Ti}}, B::SparseVecOrMat{Float64,Ti}) = sparse(Sparse(A)*Sparse(B))\n\nend #module\n"
    },
    "skipped": [
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/objects.inv",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/up.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/up-pressed.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/plus.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/minus.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/file.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/down.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/down-pressed.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/comment.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/comment-close.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/comment-bright.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/ajax-loader.gif",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/fonts/FontAwesome.otf",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/fonts/fontawesome-webfont.woff",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/fonts/fontawesome-webfont.ttf",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/fonts/fontawesome-webfont.eot",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/images/travis-icon.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/images/jltypes.ai",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/images/github_metadata_pullrequest.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/images/github_metadata_fork.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/images/github_metadata_develbranch.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/virtualenv-15.0.0.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/utf8proc-e3a5ed7b8bb5d0c6bb313d3e1f4d072c04113c4b.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/SuiteSparse-4.4.5.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/pcre2-10.21.tar.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/patchelf-0.9.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/openspecfun-39699a1c1824bf88410cabb8a7438af91ea98f4c.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/openlibm-1581174c85f7b645b15ba1ac1c3a98fb601f0fe7.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/openblas-12ab1804b6ebcd38b26960d65d254314d8bc33d6.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/objconv.zip",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/mpfr-3.1.4.tar.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/mbedtls-2.3.0-gpl.tgz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/llvm-3.7.1.src.tar.xz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/libuv-8d5131b6c1595920dd30644cd1435b4f344b46c8.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/libunwind-1.1-julia2.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/libssh2-6d553a7bb94966466c4db0abf9a26660e786a275.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/libosxunwind-0.0.3.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/libgit2-428e18f8d4765b8ad6cf4022080a81ab16f6fdc4.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/lapack-3.5.0.tgz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/gmp-6.1.0.tar.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/fftw-3.3.4.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/dsfmt-2.2.3.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/curl-7.50.1.tar.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/arpack-ng-3.3.0.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/contrib/windows/julia.ico",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/contrib/windows/7zS.sfx",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/contrib/mac/app/julia.icns"
    ],
    "total_files": 1186
}