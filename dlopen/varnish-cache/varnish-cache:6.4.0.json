{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-varnish-cache-6.4.0-rypi4oyixvgpbmjahq5n45zcm4a7jnyy/spack-src/configure.ac": "AC_PREREQ(2.59)\nAC_COPYRIGHT([Copyright (c) 2006 Verdens Gang AS\nCopyright (c) 2006-2020 Varnish Software])\nAC_REVISION([$Id$])\nAC_INIT([Varnish], [6.4.0], [varnish-dev@varnish-cache.org])\nAC_CONFIG_SRCDIR(include/miniobj.h)\nAC_CONFIG_HEADERS([config.h])\nAC_CONFIG_MACRO_DIR([m4])\nAC_CONFIG_AUX_DIR([build-aux])\nAC_USE_SYSTEM_EXTENSIONS\n\n# save command line CFLAGS for use in VCC_CC (to pass through things like -m64)\n# and make distcheck configure\nOCFLAGS=\"$CFLAGS\"\nEXTCFLAGS=\"$CFLAGS\"\nAC_SUBST(EXTCFLAGS)\n\nAC_CANONICAL_SYSTEM\nAC_LANG(C)\n\nAM_MAINTAINER_MODE([disable])\nAM_INIT_AUTOMAKE([1.11 foreign color-tests parallel-tests])\nAM_SILENT_RULES([yes])\nAC_DISABLE_STATIC\nAC_PROG_LIBTOOL\n\n# Checks for programs.\nAC_GNU_SOURCE\nAC_PROG_CC\nAC_PROG_CC_STDC\n\nAX_PTHREAD(,[AC_MSG_ERROR([Could not configure pthreads support])])\n\nLIBS=\"$PTHREAD_LIBS $LIBS\"\nCFLAGS=\"$CFLAGS $PTHREAD_CFLAGS\"\nCC=\"$PTHREAD_CC\"\n\nAC_PROG_INSTALL\n\nAC_ARG_WITH([rst2man],\n  AS_HELP_STRING([--with-rst2man=PATH], [Location of rst2man (auto)]),\n  [RST2MAN=\"$withval\"],\n  AC_CHECK_PROGS(RST2MAN,\n    [rst2man-3.6 rst2man-3 rst2man rst2man.py],\n    [no]))\nif test \"x$RST2MAN\" = \"xno\"; then\n  AC_MSG_ERROR(\n    [rst2man is needed to build Varnish, please install python3-docutils.])\nfi\n\nAC_ARG_WITH([sphinx-build],\n  AS_HELP_STRING([--with-sphinx-build=PATH], [Location of sphinx-build (auto)]),\n  [SPHINX=\"$withval\"],\n  AC_CHECK_PROGS(SPHINX,\n    [sphinx-build-3.6 sphinx-build-3 sphinx-build],\n    [no]))\nif test \"x$SPHINX\" = \"xno\"; then\n  AC_MSG_ERROR(\n    [sphinx-build is needed to build Varnish, please install python3-sphinx.])\nfi\n\nAC_ARG_WITH([rst2html],\n  AS_HELP_STRING([--with-rst2html=PATH], [Location of rst2html (auto)]),\n  [RST2HTML=\"$withval\"],\n  AC_CHECK_PROGS(RST2HTML,\n     [rst2html-3.6 rst2html-3 rst2html rst2html.py],\n     \"no\"))\n\nif test \"x$RST2HTML\" = \"xno\"; then\n   AC_MSG_ERROR(\n     [rst2html not found - (Weird, we found rst2man?!)])\nfi\n\nAC_ARG_WITH([dot],\n  AS_HELP_STRING([--with-dot=PATH],\n\t\t [Location of the dot tool from graphviz (auto)]),\n  [DOT=\"$withval\"],\n  [AC_CHECK_PROGS(DOT, [dot], [no])\n   if test \"x$DOT\" = \"xno\"; then\n     AC_MSG_WARN(\n       [dot not found - build will fail if svg files are out of date.])\n   fi])\nAM_CONDITIONAL(HAVE_DOT,[test \"x$DOT\" != \"xno\"])\n\n# Define VMOD flags\n_VARNISH_VMOD_LDFLAGS\n\n# Check for python.\n_VARNISH_CHECK_PYTHON\n\n# Check for libraries.\n_VARNISH_SEARCH_LIBS(pthread, pthread_create, [thr pthread c_r])\n_VARNISH_CHECK_LIB(rt, clock_gettime)\n_VARNISH_CHECK_LIB(dl, dlopen)\n_VARNISH_CHECK_LIB(socket, socket)\n_VARNISH_CHECK_LIB(nsl, getaddrinfo)\n\nAC_SUBST(NET_LIBS, \"${SOCKET_LIBS} ${NSL_LIBS}\")\n\n# Userland slab allocator from Solaris, ported to other systems\nAC_CHECK_HEADERS([umem.h])\n\n# XXX: This _may_ be for OS/X\nAC_CHECK_LIBM\nAC_SUBST(LIBM)\n\nm4_ifndef([PKG_PROG_PKG_CONFIG], [m4_fatal([pkg.m4 missing, please install pkg-config])])\nPKG_PROG_PKG_CONFIG\nif test -n $PKG_CONFIG; then\n   PKG_CHECK_MODULES([PCRE], [libpcre])\nelse\n   AC_CHECK_PROG(PCRE_CONFIG, pcre-config, pcre-config)\n   AC_ARG_WITH(pcre-config,\n               AS_HELP_STRING([--with-pcre-config=PATH],\n                              [Location of PCRE pcre-config (auto)]),\n               [pcre_config=\"$withval\"],\n               [pcre_config=\"\"])\n\n  if test \"x$pcre_config\" != \"x\" ; then\n    AC_MSG_CHECKING(for $pcre_config)\n\n    if test -f $pcre_config ; then\n      PCRE_CONFIG=$pcre_config\n      AC_MSG_RESULT(yes)\n    else\n      AC_MSG_RESULT(no - searching PATH)\n    fi\n  fi\n  if test \"x$PCRE_CONFIG\" = \"x\"; then\n    AC_CHECK_PROGS(PCRE_CONFIG, pcre-config)\n  fi\n  PCRE_CFLAGS=`$PCRE_CONFIG --cflags`\n  PCRE_LIBS=`$PCRE_CONFIG --libs`\nfi\nAC_SUBST(PCRE_CFLAGS)\nAC_SUBST(PCRE_LIBS)\n\n# --enable-pcre-jit\nAC_ARG_ENABLE(pcre-jit,\n  AS_HELP_STRING([--enable-pcre-jit],\n    [use the PCRE JIT compiler (default is YES)]),\n    [],\n    [enable_pcre_jit=yes])\nif test \"$enable_pcre_jit\" = yes; then\n  AC_MSG_CHECKING(for PCRE JIT usability)\n  save_CFLAGS=\"${CFLAGS}\"\n  CFLAGS=\"${CFLAGS} ${PCRE_CFLAGS}\"\n  save_LIBS=\"${LIBS}\"\n  LIBS=\"${LIBS} ${PCRE_LIBS}\"\n  AC_RUN_IFELSE(\n    [AC_LANG_PROGRAM([[\n#include <pcre.h>\n#if PCRE_MAJOR != 8 || PCRE_MINOR < 32\n#error no jit\n#endif\n    ]],[[\nconst char *error;\npcre *re;\nint erroroffset;\nre = pcre_compile(\".\", 0, &error, &erroroffset, NULL);\nif (!pcre_study(re, PCRE_STUDY_JIT_COMPILE, &error))\n  return (1);\n    ]])],\n    [AC_MSG_RESULT(yes)\n     AC_DEFINE([USE_PCRE_JIT], [1], [Use the PCRE JIT compiler])\n    ],\n    [AC_MSG_RESULT(no)]\n  )\n  CFLAGS=\"${save_CFLAGS}\"\n  LIBS=\"${save_LIBS}\"\nfi\n\n\nAC_CHECK_HEADERS([edit/readline/readline.h],\n\t[AC_DEFINE([HAVE_LIBEDIT], [1], [Define if we have libedit])\n\tLIBEDIT_LIBS=\"-ledit\"],\n\n\t[PKG_CHECK_MODULES([LIBEDIT], [libedit],\n\t\t# having the module does not imply having the header\n\t\t[AC_CHECK_HEADERS([editline/readline.h],\n\t\t\t\t  [AC_DEFINE([HAVE_LIBEDIT], [1], [Define if we have libedit])],\n\t\t\t\t  [AC_MSG_ERROR([Found libedit, but header file is missing. Hint: Install dev package?])])],\n\t\t[\n\t\t # AX_LIB_READLINE overwrites LIBS which leads to every binary getting\n\t\t # linked against libreadline uselessly. So we re-use LIBEDIT_LIBS which\n\t\t # we have for libedit to add the lib specifically where needed\n\t\t save_LIBS=\"${LIBS}\"\n\t\t AX_LIB_READLINE\n\t\t LIBS=\"${save_LIBS}\"\n\t\t if test \"$ax_cv_lib_readline\" = \"no\"; then\n\t\t\tAC_MSG_ERROR([neither libedit nor another readline compatible library found])\n\t\t fi\n\t\t if test \"x$ax_cv_lib_readline_history\" != \"xyes\"; then\n\t\t\tAC_MSG_ERROR([need readline history support])\n\t\t fi\n\t\t LIBEDIT_LIBS=\"$ax_cv_lib_readline\"\n\t\t])\n\t])\n\nPKG_CHECK_MODULES([CURSES], [ncursesw], [], [\n\tPKG_CHECK_MODULES([CURSES], [ncurses], [], [\n\t\tPKG_CHECK_MODULES([CURSES], [curses], [], [\nAX_WITH_CURSES\nif test \"x$ax_cv_curses\" != xyes; then\n\tAC_MSG_ERROR([requires an X/Open-compatible Curses library])\nfi\nCURSES_LIBS=\"$CURSES_LIB\"\n\t\t])\n\t])\n])\nAC_SUBST([CURSES_LIBS])\n\nAC_CHECK_HEADERS([ncursesw/curses.h ncursesw.h ncurses/curses.h ncurses.h curses.h])\n\n# Checks for header files.\nAC_HEADER_STDC\nAC_CHECK_HEADERS([sys/endian.h])\nAC_CHECK_HEADERS([sys/filio.h])\nAC_CHECK_HEADERS([sys/mount.h], [], [], [#include <sys/param.h>])\nAC_CHECK_HEADERS([sys/personality.h])\nAC_CHECK_HEADERS([sys/statvfs.h])\nAC_CHECK_HEADERS([sys/vfs.h])\nAC_CHECK_HEADERS([endian.h])\nAC_CHECK_HEADERS([pthread_np.h], [], [], [#include <pthread.h>])\nAC_CHECK_HEADERS([priv.h])\nAC_CHECK_HEADERS([fnmatch.h], [], [AC_MSG_ERROR([fnmatch.h is required])])\n\n# Checks for library functions.\nAC_CHECK_FUNCS([nanosleep])\nAC_CHECK_FUNCS([setppriv])\nAC_CHECK_FUNCS([fallocate])\nAC_CHECK_FUNCS([closefrom])\nAC_CHECK_FUNCS([sigaltstack])\nAC_CHECK_FUNCS([getpeereid])\nAC_CHECK_FUNCS([getpeerucred])\nAC_CHECK_FUNCS([fnmatch], [], [AC_MSG_ERROR([fnmatch(3) is required])])\n\nsave_LIBS=\"${LIBS}\"\nLIBS=\"${PTHREAD_LIBS}\"\nAC_CHECK_FUNCS([pthread_set_name_np])\nAC_CHECK_FUNCS([pthread_setname_np])\nAC_CHECK_FUNCS([pthread_mutex_isowned_np])\nAC_CHECK_FUNCS([pthread_getattr_np])\nLIBS=\"${save_LIBS}\"\n\nAC_CHECK_DECL([__SUNPRO_C], [SUNCC=\"yes\"], [SUNCC=\"no\"])\n\n# Support for visibility attribute\nsave_CFLAGS=\"${CFLAGS}\"\nif test \"$SUNCC\" = \"yes\" ; then\n\tCFLAGS=\"${CFLAGS} -errwarn=%all,no%E_EMPTY_TRANSLATION_UNIT\"\nelse\n\tCFLAGS=\"${CFLAGS} -Werror\"\nfi\n\nAC_CACHE_CHECK([whether we have support for visibility attributes],\n\t[ac_cv_have_viz],\n\t[AC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t\t\t#if ((__GNUC__-0) * 10 + __GNUC_MINOR__-0 >= 33 || defined(__SUNPRO_C))\n\t\t\t#  define ZLIB_INTERNAL __attribute__((visibility (\"hidden\")))\n\t\t\t#else\n\t\t\t#  define ZLIB_INTERNAL\n\t\t\t#endif\n\t\t\tint ZLIB_INTERNAL foo;\n\t\t]],[])],\n\t[ac_cv_have_viz=yes],\n\t[ac_cv_have_viz=no])\n])\nif test \"$ac_cv_have_viz\" = no; then\n\tlibvgz_extra_cflags=\"-DNO_VIZ\"\n\tAC_SUBST(libvgz_extra_cflags)\nfi\nCFLAGS=\"${save_CFLAGS}\"\n\nif test \"x$GCC\" = \"xyes\"; then\n\tlibvgz_extra_cflags=\"${libvgz_extra_cflags} -Wno-unknown-warning-option -Wno-implicit-fallthrough\"\n\tAC_SUBST(libvgz_extra_cflags)\nfi\n\nSAN_CFLAGS=\nSAN_LDFLAGS=\nUBSAN_CFLAGS=\nUBSAN_LDFLAGS=\nAC_ARG_ENABLE(ubsan,\n\tAS_HELP_STRING([--enable-ubsan],[enable undefined behavior sanitizer (default is NO)]),\n\tUBSAN_FLAGS=\"-fsanitize=undefined\")\n\nTSAN_CFLAGS=\nTSAN_LDFLAGS=\nAC_ARG_ENABLE(tsan,\n\tAS_HELP_STRING([--enable-tsan],[enable thread sanitizer (default is NO)]),\n\tTSAN_FLAGS=\"-fsanitize=thread\")\n\nASAN_CFLAGS=\nASAN_LDFLAGS=\nAC_ARG_ENABLE(asan,\n\tAS_HELP_STRING([--enable-asan],[enable address sanitizer (default is NO)]),\n\tASAN_FLAGS=\"-fsanitize=address\"\n\tAX_CHECK_COMPILE_FLAG([-fsanitize=address -fsanitize-address-use-after-scope],\n\t\t\t      [ASAN_FLAGS=\"${ASAN_FLAGS} -fsanitize-address-use-after-scope\"]))\n\nMSAN_CFLAGS=\nMSAN_LDFLAGS=\nAC_ARG_ENABLE(msan,\n\tAS_HELP_STRING([--enable-msan],[enable memory sanitizer (default is NO)]),\n\tMSAN_FLAGS=\"-fsanitize=memory\")\n\nif test \"x$UBSAN_FLAGS$TSAN_FLAGS$ASAN_FLAGS$MSAN_FLAGS\" != \"x\"; then\n\tSAN_CFLAGS=\"-D__SANITIZER=1 ${UBSAN_FLAGS} ${TSAN_FLAGS} ${ASAN_FLAGS} ${MSAN_FLAGS} -fPIC -fPIE -fno-omit-frame-pointer\"\n\tSAN_LDFLAGS=\"${UBSAN_FLAGS} ${TSAN_FLAGS} ${ASAN_FLAGS} ${MSAN_FLAGS}\"\n\tsave_CFLAGS=\"${CFLAGS}\"\n\tCFLAGS=\"${CFLAGS} -Werror=unused-command-line-argument\"\n\tAX_CHECK_LINK_FLAG([-pie], [SAN_LDFLAGS=\"${SAN_LDFLAGS} -pie\"])\n\tCFLAGS=\"${save_CFLAGS}\"\n\tcase $CC in\n\tgcc*)\n\t\tSAN_CFLAGS=\"${SAN_CFLAGS} -fuse-ld=gold\"\n\t\t;;\n\tesac\nfi\nAC_SUBST(SAN_CFLAGS)\nAC_SUBST(SAN_LDFLAGS)\n\n# Use jemalloc on Linux\nJEMALLOC_LDADD=\nAC_ARG_WITH([jemalloc],\n            [AS_HELP_STRING([--with-jemalloc],\n              [use jemalloc memory allocator.  Default is yes on Linux,  no elsewhere])],\n            [],\n            [with_jemalloc=check])\n\ncase $target in\n    *-*-linux*)\n        if test \"x$with_jemalloc\" != xno; then\n            AC_CHECK_LIB([jemalloc], [malloc_conf],\n                  [JEMALLOC_LDADD=\"-ljemalloc\"],\n                  [AC_MSG_WARN([No system jemalloc found, using system malloc])])\n\tfi\n\t;;\nesac\nAC_SUBST(JEMALLOC_LDADD)\n\nAC_CHECK_FUNCS([setproctitle])\n\n# if the default libexecinfo on alpine causes issues, you can use libunwind\nAC_ARG_WITH([unwind],\n            [AS_HELP_STRING([--with-unwind],\n              [use libunwind to print stacktraces (use libexecinfo otherwise). Recommended on alpine linux. Defaults to no.])])\n\nif test \"$with_unwind\" = yes; then\n    case $target in\n    *-*-darwin*)\n        # Always present but .pc is not installed\n        ;;\n    *)\n        PKG_CHECK_MODULES([LIBUNWIND], [libunwind])\n        ;;\n    esac\n    AC_DEFINE([WITH_UNWIND], [1],\n              [Define to 1 to use libunwind instead of libexecinfo])\nelse\n    AC_SEARCH_LIBS(backtrace, [execinfo], [], [\n        AC_MSG_ERROR([Could not find backtrace() support])\n    ])\nfi\n\nAM_CONDITIONAL([WITH_UNWIND],\n\t[test \"$with_unwind\" = yes])\n\n# white lie - we don't actually test it\nAC_MSG_CHECKING([whether daemon() works])\ncase $target in\n*-*-darwin*)\n\t# present but not functional\n\tAC_MSG_RESULT([no])\n\tac_cv_func_daemon=no\n\t;;\n*)\n\tAC_CHECK_FUNCS([daemon])\n\t;;\nesac\nAM_CONDITIONAL(HAVE_DAEMON, [test \"x$ac_cv_func_daemon\" != \"xno\"])\n\nAC_SYS_LARGEFILE\n\nsave_LIBS=\"${LIBS}\"\nLIBS=\"${LIBS} ${RT_LIBS}\"\nAC_CHECK_FUNCS([clock_gettime])\nAC_CHECK_FUNCS([gethrtime])\nLIBS=\"${save_LIBS}\"\n\nif test \"x$ac_cv_func_gethrtime\" = xyes && \\\n   test \"x$ac_cv_func_clock_gettime\" = xyes ; then\n  AC_MSG_CHECKING(if clock_gettime is faster than gethrtime)\n  AC_RUN_IFELSE(\n    [AC_LANG_PROGRAM([[\n#include <sys/time.h>\n#include <time.h>\n#include <stdio.h>\n\nstatic hrtime_t cl()\n{\n\tstruct timespec ts;\n\n\t(void) clock_gettime(CLOCK_MONOTONIC, &ts);\n\treturn (ts.tv_sec * 1e9 + ts.tv_nsec);\n}\n    ]],[[\n\thrtime_t s, c, e, t_hr, t_cl;\n\tint i, r, wins;\n\n\twins = 0;\n\tfor (r = 0; r < 10; r++) {\n\t\tc = 0;\n\t\ts = gethrtime();\n\t\tfor (i=0; i<100000; i++)\n\t\t\tc += gethrtime();\n\t\te = gethrtime();\n\t\tt_hr = e - s;\n\t\tfprintf(stderr, \"hrtime\\t\\t%12lu check %lu\\n\",\n\t\t    (unsigned long)t_hr, (unsigned long)c);\n\n\t\tc = 0;\n\t\ts = gethrtime();\n\t\tfor (i=0; i<100000; i++)\n\t\t\tc += cl();\n\t\te = gethrtime();\n\t\tt_cl = e - s;\n\t\tfprintf(stderr, \"clock_gettime\\t%12lu check %lu\\n\",\n\t\t    (unsigned long)t_cl, (unsigned long)c);\n\n\t\tif (t_cl * 2 < t_hr)\n\t\t\twins++;\n\t}\n\tfprintf(stderr, \"clock_gettime wins %d/%d\\n\", wins, r);\n\tif (2 * wins >= r)\n\t\treturn (0);\n\treturn (1);\n    ]])],\n    [AC_MSG_RESULT(yes)\n    ],\n    [AC_MSG_RESULT(no)\n     AC_DEFINE([USE_GETHRTIME], [1], [Define if gethrtime is preferred])\n    ]\n  )\nfi\n\n# --enable-kqueue\nAC_ARG_ENABLE(kqueue,\n    AS_HELP_STRING([--enable-kqueue],\n\t[use kqueue if available (default is YES)]),\n    ,\n    [enable_kqueue=yes])\n\nif test \"$enable_kqueue\" = yes; then\n\tAC_CHECK_FUNCS([kqueue])\nelse\n\tac_cv_func_kqueue=no\nfi\n\n# --enable-epoll\nAC_ARG_ENABLE(epoll,\n    AS_HELP_STRING([--enable-epoll],\n\t[use epoll if available (default is YES)]),\n    ,\n    [enable_epoll=yes])\n\nif test \"$enable_epoll\" = yes; then\n\tAC_CHECK_FUNCS([epoll_ctl])\nelse\n\tac_cv_func_epoll_ctl=no\nfi\n\n# --enable-ports\nAC_ARG_ENABLE(ports,\n    AS_HELP_STRING([--enable-ports],\n\t[use ports if available (default is YES)]),\n    ,\n    [enable_ports=yes])\n\nif test \"$enable_ports\" = yes; then\n\tAC_CHECK_FUNCS([port_create])\nelse\n\tac_cv_func_port_create=no\nfi\n\n# --with-persistent-storage\nAC_ARG_WITH(persistent-storage,\n    AS_HELP_STRING([--with-persistent-storage],\n\t[use deprecated persistent storage (default is NO)]),\n    [],\n    [with_persistent_storage=no])\n\nif test \"$with_persistent_storage\" = yes; then\n\tAC_DEFINE([WITH_PERSISTENT_STORAGE], [1],\n\t\t[Define to 1 to build the deprecated peristent storage.])\nfi\n\nAM_CONDITIONAL([WITH_PERSISTENT_STORAGE],\n\t[test \"$with_persistent_storage\" = yes])\n\nAM_MISSING_HAS_RUN\n\nAC_CHECK_DECL([SO_ACCEPTFILTER],\n    AC_DEFINE(HAVE_ACCEPT_FILTERS,1,[Define to 1 if you have accept filters]),\n    ,\n    [\n#include <sys/types.h>\n#include <sys/socket.h>\n    ]\n)\n\n# Older Solaris versions define SO_{RCV,SND}TIMEO, but do not\n# implement them.\n#\n# Varnish will build and run without these, but connections will not\n# time out, which may leave Varnish vulnerable to denail-of-service\n# attacks which would not be possible on other platforms.\n#\n# Newer Solaris releases with the Volo framework (Solaris 11,\n# Opensolaris starting with onnv_106) do support SO_{RCV,SND}TIMEO\n# (see PSARC 2007/587, initially committed into onnv-gate /\n# OpenSolaris 8348:4137e18bfaf0 Thu Dec 11 20:04:13 2008)\n\nsave_LIBS=\"${LIBS}\"\nLIBS=\"${LIBS} ${NET_LIBS}\"\nAC_CACHE_CHECK([whether SO_RCVTIMEO works],\n  [ac_cv_so_rcvtimeo_works],\n  [AC_RUN_IFELSE(\n    [AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <errno.h>\n    ]],[[\nint s = socket(AF_INET, SOCK_STREAM, 0);\nstruct timeval tv = { 1, 0 };\nif (s < 0 && errno == EPROTONOSUPPORT)\n  s = socket(AF_INET6, SOCK_STREAM, 0);\nif (setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof tv) == 0) {\n  socklen_t l = sizeof tv;\n  if (getsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, &l) == 0) {\n    return (l != sizeof tv);\n  }\n}\nreturn 1;\n    ]])],\n    [ac_cv_so_rcvtimeo_works=yes],\n    [ac_cv_so_rcvtimeo_works=no])\n  ])\nif test \"$ac_cv_so_rcvtimeo_works\" = yes; then\n   AC_DEFINE([SO_RCVTIMEO_WORKS], [1], [Define if SO_RCVTIMEO works])\nfi\nLIBS=\"${save_LIBS}\"\n\nsave_LIBS=\"${LIBS}\"\nLIBS=\"${LIBS} ${NET_LIBS}\"\nAC_CACHE_CHECK([whether SO_SNDTIMEO works],\n  [ac_cv_so_sndtimeo_works],\n  [AC_RUN_IFELSE(\n    [AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <errno.h>\n    ]],[[\nint s = socket(AF_INET, SOCK_STREAM, 0);\nstruct timeval tv = { 1, 0 };\nif (s < 0 && errno == EPROTONOSUPPORT)\n  s = socket(AF_INET6, SOCK_STREAM, 0);\nif (setsockopt(s, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof tv) == 0) {\n  socklen_t l = sizeof tv;\n  if (getsockopt(s, SOL_SOCKET, SO_SNDTIMEO, &tv, &l) == 0) {\n    return (l != sizeof tv);\n  }\n}\nreturn 1;\n    ]])],\n    [ac_cv_so_sndtimeo_works=yes],\n    [ac_cv_so_sndtimeo_works=no])\n  ])\nif test \"$ac_cv_so_sndtimeo_works\" = yes; then\n   AC_DEFINE([SO_SNDTIMEO_WORKS], [1], [Define if SO_SNDTIMEO works])\nfi\n\nif test \"$ac_cv_so_rcvtimeo_works\" = no ||\n   test \"$ac_cv_so_sndtimeo_works\" = no; then\n\tAC_MSG_WARN([connection timeouts will not work])\nfi\nLIBS=\"${save_LIBS}\"\n\n# Check if the OS supports TCP_KEEP(CNT|IDLE|INTVL) socket options\nsave_LIBS=\"${LIBS}\"\nLIBS=\"${LIBS} ${NET_LIBS}\"\nAC_CACHE_CHECK([for TCP_KEEP(CNT|IDLE|INTVL) socket options],\n  [ac_cv_have_tcp_keep],\n  [AC_RUN_IFELSE(\n    [AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <errno.h>\n    ]],[[\nint s = socket(AF_INET, SOCK_STREAM, 0);\nint i = 5;\nif (s < 0 && errno == EPROTONOSUPPORT)\n  s = socket(AF_INET6, SOCK_STREAM, 0);\nif (setsockopt(s, IPPROTO_TCP, TCP_KEEPCNT, &i, sizeof i))\n  return (1);\nif (setsockopt(s, IPPROTO_TCP, TCP_KEEPIDLE, &i, sizeof i))\n  return (1);\nif (setsockopt(s, IPPROTO_TCP, TCP_KEEPINTVL, &i, sizeof i))\n  return (1);\nreturn (0);\n    ]])],\n    [ac_cv_have_tcp_keep=yes],\n    [ac_cv_have_tcp_keep=no])\n  ])\nif test \"$ac_cv_have_tcp_keep\" = yes; then\n   AC_DEFINE([HAVE_TCP_KEEP], [1], [Define if OS supports TCP_KEEP* socket options])\nfi\nLIBS=\"${save_LIBS}\"\n\n# Check if the OS supports TCP_FASTOPEN socket option\nsave_LIBS=\"${LIBS}\"\nLIBS=\"${LIBS} ${NET_LIBS}\"\nAC_CACHE_CHECK([for TCP_FASTOPEN socket option],\n  [ac_cv_have_tcp_fastopen],\n  [AC_RUN_IFELSE(\n    [AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <errno.h>\n    ]],[[\nint s = socket(AF_INET, SOCK_STREAM, 0);\nint i = 5;\nif (s < 0 && errno == EPROTONOSUPPORT)\n  s = socket(AF_INET6, SOCK_STREAM, 0);\nif (setsockopt(s, SOL_TCP, TCP_FASTOPEN, &i, sizeof i))\n  return (1);\nreturn (0);\n    ]])],\n    [ac_cv_have_tcp_fastopen=yes],\n    [ac_cv_have_tcp_fastopen=no])\n  ])\nif test \"$ac_cv_have_tcp_fastopen\" = yes; then\n   AC_DEFINE([HAVE_TCP_FASTOPEN], [1], [Define if OS supports TCP_FASTOPEN socket option])\nfi\nLIBS=\"${save_LIBS}\"\n\n# Run-time directory\nVARNISH_STATE_DIR='${localstatedir}/varnish'\nAC_SUBST(VARNISH_STATE_DIR)\n\n# Default configuration directory.\npkgsysconfdir='${sysconfdir}/varnish'\nAC_SUBST(pkgsysconfdir)\n\n# Check for linker script support\ngl_LD_VERSION_SCRIPT\n\n#######################################################################\n# Now that we're done using the compiler to look for functions and\n# libraries, set CFLAGS to what we want them to be for our own code\n\n# This is a test to see how much havoc Jenkins exposes.\n#\n# The reason for -Wno-error=unused-result is a glibc/gcc interaction\n# idiocy where write is marked as warn_unused_result, causing build\n# failures.\n\nAX_CHECK_COMPILE_FLAG([-Wall],\n     [CFLAGS=\"${CFLAGS} -Wall\"\n      OCFLAGS=\"${OCFLAGS} -Wall\"])\n\nif test \"$SUNCC\" = \"yes\" ; then\n    SUNCC_CFLAGS=\" \\\n\t-errwarn=%all,no%E_EMPTY_TRANSLATION_UNIT \\\n\t-errtags=yes \\\n\t\"\n    AX_CHECK_COMPILE_FLAG([${SUNCC_CFLAGS}],\n\t[CFLAGS=\"${CFLAGS} ${SUNCC_CFLAGS}\"\n\t OCFLAGS=\"${OCFLAGS} ${SUNCC_CFLAGS}\"])\nelse\n    AX_CHECK_COMPILE_FLAG([-Werror],\n\t[CFLAGS=\"${CFLAGS} -Werror\"\n\t OCFLAGS=\"${OCFLAGS} -Werror\"])\nfi\n\nAX_CHECK_COMPILE_FLAG([-Werror=unused-result],\n    [CFLAGS=\"${CFLAGS} -Wno-error=unused-result\"\n     OCFLAGS=\"${OCFLAGS} -Wno-error=unused-result\"],\n    [AX_CHECK_COMPILE_FLAG([-Wunused-result],\n     [CFLAGS=\"${CFLAGS} -Wno-unused-result\"\n      OCFLAGS=\"${OCFLAGS} -Wno-unused-result\"])])\n\n# This corresponds to FreeBSD's WARNS level 6\nDEVELOPER_CFLAGS=\" \\\n -Werror \\\n -Wno-format-y2k \\\n -Wstrict-prototypes \\\n -Wmissing-prototypes \\\n -Wpointer-arith \\\n -Wcast-qual \\\n -Wwrite-strings \\\n -Wshadow \\\n -Wunused-parameter \\\n -Wcast-align \\\n -Wchar-subscripts \\\n -Wnested-externs \\\n -Wextra \\\n -Wno-sign-compare \\\n\"\n\n# These are not compliable yet\nDEVELOPER_GCC_CFLAGS=\"-Wold-style-definition -Wredundant-decls \"\n#DEVELOPER_CFLAGS=\"${DEVELOPER_CFLAGS} ${DEVELOPER_GCC_CFLAGS}\"\n\n# These are compilable\nDEVELOPER_CLANG_CFLAGS=\"-Wmissing-variable-declarations -Wno-string-plus-int\"\n# -Wno-empty-body\n#DEVELOPER_CFLAGS=\"${DEVELOPER_CFLAGS} ${DEVELOPER_CLANG_CFLAGS}\"\n\n# --enable-stack-protector\nAC_ARG_ENABLE(stack-protector,\n       AS_HELP_STRING([--enable-stack-protector],[enable stack protector (default is YES)]),\n       [],\n       [enable_stack_protector=yes])\n\nif test \"x$enable_stack_protector\" != \"xno\"; then\n\tAX_CHECK_COMPILE_FLAG([-fstack-protector],\n\t\tAX_CHECK_LINK_FLAG([-fstack-protector],\n\t\t\t[DEVELOPER_CFLAGS=\"${DEVELOPER_CFLAGS} -fstack-protector\"], [], []),\n\t\t[], [])\nfi\n\n# --enable-developer-warnings\nAC_ARG_ENABLE(developer-warnings,\n\tAS_HELP_STRING([--enable-developer-warnings],[enable strict warnings (default is NO)]),\n\t[],\n\t[enable_developer_warnings=no])\n\nif test \"x$SUNCC\" != \"xyes\" && test \"x$enable_developer_warnings\" != \"xno\"; then\n\t# no known way to specifically disabling missing-field-initializers\n\t# warnings keeping the rest of Wextra\n\tAX_CHECK_COMPILE_FLAG([-Wno-missing-field-initializers],\n\t\t[DEVELOPER_CFLAGS=\"${DEVELOPER_CFLAGS} -Wno-missing-field-initializers\"],\n\t\t[DEVELOPER_CFLAGS=\"${DEVELOPER_CFLAGS} -Wno-extra\"],\n\t\t[])\n\n\tCFLAGS=\"${CFLAGS} ${DEVELOPER_CFLAGS}\"\n\tOCFLAGS=\"${OCFLAGS} ${DEVELOPER_CFLAGS}\"\nfi\n\n# gcc on solaris needs -fstack-protector when calling gcc in linker\n# mode but libtool does not pass it on, so we need to trick it\n# specifically\ncase $CFLAGS in\n  *-fstack-protector*)\n    case $target in\n      *-*-solaris*)\n\tcase $CC in\n\t  gcc*)\n\t    AM_LT_LDFLAGS=\"${AM_LT_LDFLAGS} -Wc,-fstack-protector\"\n\t    ;;\n\tesac\n\t;;\n    esac\n    ;;\nesac\n\n# --enable-debugging-symbols\nAC_ARG_ENABLE(debugging-symbols,\n\tAS_HELP_STRING([--enable-debugging-symbols],[enable debugging symbols (default is NO)]),\n\tif test \"x$SUNCC\" = \"xyes\" ; then\n\t\tCFLAGS=\"${CFLAGS} -O0 -g\"\n\telse\n\t\tCFLAGS=\"${CFLAGS} -O0 -g -fno-inline\"\n\tfi)\n\nAC_SUBST(AM_LT_LDFLAGS)\n\n# Command line for compiling VCL code.  I wish there were a simple way\n# to figure this out dynamically without introducing a run-time\n# dependency on libtool.\nAC_ARG_VAR([VCC_CC], [C compiler command line for VCL code])\nif test \"$ac_cv_env_VCC_CC_set\" = \"set\"; then\n\tVCC_CC=\"$ac_cv_env_VCC_CC_value\"\nelse\n\tcase $target in\n\t*-*-solaris*)\n\t\tcase $PTHREAD_CC in\n\t\t*gcc*)\n\t\t\tVCC_CC=\"$PTHREAD_CC $OCFLAGS $PTHREAD_CFLAGS -fpic -shared -o %o %s\"\n\t\t\tbreak\n\t\t\t;;\n\t\t*cc)\n\t\t\tVCC_CC=\"$PTHREAD_CC $OCFLAGS -errwarn=%all,no%E_STATEMENT_NOT_REACHED $PTHREAD_CFLAGS -Kpic -G -o %o %s\"\n\t\t\t;;\n\t\tesac\n\t\t;;\n\t*-*-darwin*)\n\t\tVCC_CC=\"exec cc $OCFLAGS -dynamiclib -Wl,-undefined,dynamic_lookup -o %o %s\"\n\t\t;;\n\t*)\n\t\tVCC_CC=\"exec $PTHREAD_CC $OCFLAGS $PTHREAD_CFLAGS -fpic -shared -Wl,-x -o %o %s\"\n\t\t;;\n\tesac\nfi\n\nAC_DEFINE_UNQUOTED([VCC_CC],\"$VCC_CC\",[C compiler command line for VCL code])\n\n# Stupid automake needs this\nVTC_TESTS=\"$(cd $srcdir/bin/varnishtest && echo tests/*.vtc)\"\nAC_SUBST(VTC_TESTS)\nAM_SUBST_NOTMAKE(VTC_TESTS)\n\nVSC_SRC=\"$(cd $srcdir/bin/varnishd && echo *.vsc)\"\nVSC_GEN_C=\"$(echo $VSC_SRC | sed 's:\\.vsc:.c:g')\"\nVSC_GEN_H=\"$(echo $VSC_SRC | sed 's:\\.vsc:.h:g')\"\n# automake does not allow to AC_SUBST _SOURCES files (for a good\n# reason), so we automate the cleanup at least\nAC_SUBST(VSC_GEN_C)\nAC_SUBST(VSC_GEN_H)\n\n# Make sure this include dir exists\nAC_CONFIG_COMMANDS([mkdir], [$MKDIR_P doc/sphinx/include])\n\n# Generate output\nAC_CONFIG_FILES([\n    Makefile\n    bin/Makefile\n    bin/varnishadm/Makefile\n    bin/varnishd/Makefile\n    bin/varnishlog/Makefile\n    bin/varnishstat/Makefile\n    bin/varnishtop/Makefile\n    bin/varnishhist/Makefile\n    bin/varnishtest/Makefile\n    bin/varnishncsa/Makefile\n    doc/Makefile\n    doc/graphviz/Makefile\n    doc/sphinx/Makefile\n    doc/sphinx/conf.py\n    etc/Makefile\n    include/Makefile\n    lib/Makefile\n    lib/libvarnish/Makefile\n    lib/libvarnishapi/Makefile\n    lib/libvcc/Makefile\n    lib/libvgz/Makefile\n    lib/libvmod_cookie/Makefile\n    lib/libvmod_debug/Makefile\n    lib/libvmod_std/Makefile\n    lib/libvmod_directors/Makefile\n    lib/libvmod_purge/Makefile\n    lib/libvmod_vtc/Makefile\n    lib/libvmod_blob/Makefile\n    lib/libvmod_unix/Makefile\n    lib/libvmod_proxy/Makefile\n    man/Makefile\n    varnishapi.pc\n    varnishapi-uninstalled.pc\n])\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-varnish-cache-6.4.0-rypi4oyixvgpbmjahq5n45zcm4a7jnyy/spack-src/bin/varnishd/storage/storage_umem.c": "/*-\n * Copyright (c) 2006 Verdens Gang AS\n * Copyright (c) 2006-2011 Varnish Software AS\n * Copyright 2017 UPLEX - Nils Goroll Systemoptimierung\n * All rights reserved.\n *\n * Authors: Poul-Henning Kamp <phk@phk.freebsd.dk>\n *\t    Nils Goroll <nils.goroll@uplex.de>\n *\n * SPDX-License-Identifier: BSD-2-Clause\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * Storage method based on libumem\n */\n\n#include \"config.h\"\n\n#if defined(HAVE_UMEM_H)\n\n#include \"cache/cache_varnishd.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <umem.h>\n#include <dlfcn.h>\n#include <link.h>\n#include <string.h>\n\n#include \"storage/storage.h\"\n#include \"storage/storage_simple.h\"\n\n#include \"vnum.h\"\n#include \"common/heritage.h\"\n\n#include \"VSC_smu.h\"\n\nstruct smu_sc {\n\tunsigned\t\tmagic;\n#define SMU_SC_MAGIC\t\t0x7695f68e\n\tstruct lock\t\tsmu_mtx;\n\tsize_t\t\t\tsmu_max;\n\tsize_t\t\t\tsmu_alloc;\n\tstruct VSC_smu\t\t*stats;\n\tumem_cache_t\t\t*smu_cache;\n};\n\nstruct smu {\n\tunsigned\t\tmagic;\n#define SMU_MAGIC\t\t0x3773300c\n\tstruct storage\t\ts;\n\tsize_t\t\t\tsz;\n\tstruct smu_sc\t\t*sc;\n};\n\n/*\n * We only want the umem slab allocator for cache storage, not also as a\n * substitute for malloc and friends. So we don't link with libumem, but\n * use dlopen/dlsym to get the slab allocator interface into function\n * pointers.\n */\ntypedef void * (*umem_alloc_f)(size_t size, int flags);\ntypedef void (*umem_free_f)(void *buf, size_t size);\ntypedef umem_cache_t * (*umem_cache_create_f)(char *debug_name, size_t bufsize,\n    size_t align, umem_constructor_t *constructor,\n    umem_destructor_t *destructor, umem_reclaim_t *reclaim,\n    void *callback_data, vmem_t *source, int cflags);\ntypedef void (*umem_cache_destroy_f)(umem_cache_t *cache);\ntypedef void * (*umem_cache_alloc_f)(umem_cache_t *cache, int flags);\ntypedef void (*umem_cache_free_f)(umem_cache_t *cache, void *buffer);\n\nstatic void *libumem_hndl = NULL;\nstatic umem_alloc_f umem_allocf = NULL;\nstatic umem_free_f umem_freef = NULL;\nstatic umem_cache_create_f umem_cache_createf = NULL;\nstatic umem_cache_destroy_f umem_cache_destroyf = NULL;\nstatic umem_cache_alloc_f umem_cache_allocf = NULL;\nstatic umem_cache_free_f umem_cache_freef = NULL;\n\nstatic const char * const def_umem_options = \"perthread_cache=0,backend=mmap\";\nstatic const char * const env_umem_options = \"UMEM_OPTIONS\";\n\n/* init required per cache get:\n   smu->sz = size\n   smu->s.ptr;\n   smu->s.space = size\n*/\n\nstatic inline void\nsmu_smu_init(struct smu *smu, struct smu_sc *sc)\n{\n\tINIT_OBJ(smu, SMU_MAGIC);\n\tsmu->s.magic = STORAGE_MAGIC;\n\tsmu->s.priv = smu;\n\tsmu->sc = sc;\n}\n\nstatic int v_matchproto_(umem_constructor_t)\nsmu_smu_constructor(void *buffer, void *callback_data, int flags)\n{\n\tstruct smu *smu = buffer;\n\tstruct smu_sc *sc;\n\n\t(void) flags;\n\tCAST_OBJ_NOTNULL(sc, callback_data, SMU_SC_MAGIC);\n\tsmu_smu_init(smu, sc);\n\treturn (0);\n}\n\nstatic void v_matchproto_(umem_destructor_t)\n\tsmu_smu_destructor(void *buffer, void *callback_data)\n{\n\tstruct smu *smu;\n\tstruct smu_sc *sc;\n\n\tCAST_OBJ_NOTNULL(smu, buffer, SMU_MAGIC);\n\tCAST_OBJ_NOTNULL(sc, callback_data, SMU_SC_MAGIC);\n\tCHECK_OBJ_NOTNULL(&(smu->s), STORAGE_MAGIC);\n\tassert(smu->s.priv == smu);\n\tassert(smu->sc == sc);\n}\n\nstatic struct VSC_lck *lck_smu;\n\nstatic struct storage * v_matchproto_(sml_alloc_f)\nsmu_alloc(const struct stevedore *st, size_t size)\n{\n\tstruct smu_sc *smu_sc;\n\tstruct smu *smu = NULL;\n\tvoid *p;\n\n\tCAST_OBJ_NOTNULL(smu_sc, st->priv, SMU_SC_MAGIC);\n\tLck_Lock(&smu_sc->smu_mtx);\n\tsmu_sc->stats->c_req++;\n\tif (smu_sc->smu_alloc + size > smu_sc->smu_max) {\n\t\tsmu_sc->stats->c_fail++;\n\t\tsize = 0;\n\t} else {\n\t\tsmu_sc->smu_alloc += size;\n\t\tsmu_sc->stats->c_bytes += size;\n\t\tsmu_sc->stats->g_alloc++;\n\t\tsmu_sc->stats->g_bytes += size;\n\t\tif (smu_sc->smu_max != SIZE_MAX)\n\t\t\tsmu_sc->stats->g_space -= size;\n\t}\n\tLck_Unlock(&smu_sc->smu_mtx);\n\n\tif (size == 0)\n\t\treturn (NULL);\n\n\t/*\n\t * Do not collaps the smu allocation with smu->s.ptr: it is not\n\t * a good idea.  Not only would it make ->trim impossible,\n\t * performance-wise it would be a catastropy with chunksized\n\t * allocations growing another full page, just to accommodate the smu.\n\t */\n\n\tp = umem_allocf(size, UMEM_DEFAULT);\n\tif (p != NULL) {\n\t\tAN(smu_sc->smu_cache);\n\t\tsmu = umem_cache_allocf(smu_sc->smu_cache, UMEM_DEFAULT);\n\t\tif (smu != NULL)\n\t\t\tsmu->s.ptr = p;\n\t\telse\n\t\t\tumem_freef(p, size);\n\t}\n\tif (smu == NULL) {\n\t\tLck_Lock(&smu_sc->smu_mtx);\n\t\t/*\n\t\t * XXX: Not nice to have counters go backwards, but we do\n\t\t * XXX: Not want to pick up the lock twice just for stats.\n\t\t */\n\t\tsmu_sc->stats->c_fail++;\n\t\tsmu_sc->smu_alloc -= size;\n\t\tsmu_sc->stats->c_bytes -= size;\n\t\tsmu_sc->stats->g_alloc--;\n\t\tsmu_sc->stats->g_bytes -= size;\n\t\tif (smu_sc->smu_max != SIZE_MAX)\n\t\t\tsmu_sc->stats->g_space += size;\n\t\tLck_Unlock(&smu_sc->smu_mtx);\n\t\treturn (NULL);\n\t}\n\tsmu->sz = size;\n\tsmu->s.space = size;\n#ifndef BUG3210\n\tassert(smu->sc == smu_sc);\n\tassert(smu->s.priv == smu);\n\tAZ(smu->s.len);\n#endif\n\treturn (&smu->s);\n}\n\nstatic void v_matchproto_(sml_free_f)\nsmu_free(struct storage *s)\n{\n\tstruct smu *smu;\n\tstruct smu_sc *sc;\n\n\tCHECK_OBJ_NOTNULL(s, STORAGE_MAGIC);\n\tCAST_OBJ_NOTNULL(smu, s->priv, SMU_MAGIC);\n\tCAST_OBJ_NOTNULL(sc, smu->sc, SMU_SC_MAGIC);\n\n\tLck_Lock(&sc->smu_mtx);\n\tsc->smu_alloc -= smu->sz;\n\tsc->stats->g_alloc--;\n\tsc->stats->g_bytes -= smu->sz;\n\tsc->stats->c_freed += smu->sz;\n\tif (sc->smu_max != SIZE_MAX)\n\t\tsc->stats->g_space += smu->sz;\n\tLck_Unlock(&sc->smu_mtx);\n\n\tumem_freef(smu->s.ptr, smu->sz);\n\tsmu_smu_init(smu, sc);\n\tAN(sc->smu_cache);\n\tumem_cache_freef(sc->smu_cache, smu);\n}\n\nstatic VCL_BYTES v_matchproto_(stv_var_used_space)\nsmu_used_space(const struct stevedore *st)\n{\n\tstruct smu_sc *smu_sc;\n\n\tCAST_OBJ_NOTNULL(smu_sc, st->priv, SMU_SC_MAGIC);\n\treturn (smu_sc->smu_alloc);\n}\n\nstatic VCL_BYTES v_matchproto_(stv_var_free_space)\nsmu_free_space(const struct stevedore *st)\n{\n\tstruct smu_sc *smu_sc;\n\n\tCAST_OBJ_NOTNULL(smu_sc, st->priv, SMU_SC_MAGIC);\n\treturn (smu_sc->smu_max - smu_sc->smu_alloc);\n}\n\nstatic void\nsmu_umem_loaded_warn(void)\n{\n\tconst char *e;\n\tstatic int warned = 0;\n\n\tif (warned++)\n\t\treturn;\n\n\tfprintf(stderr, \"notice:\\tlibumem was already found to be loaded\\n\"\n\t\t\"\\tand will likely be used for all allocations\\n\");\n\n\te = getenv(env_umem_options);\n\tif (e == NULL || ! strstr(e, def_umem_options))\n\t\tfprintf(stderr, \"\\tit is recommended to set %s=%s \"\n\t\t\t\"before starting varnish\\n\",\n\t\t\tenv_umem_options, def_umem_options);\n}\n\nstatic int\nsmu_umem_loaded(void)\n{\n\tvoid *h = NULL;\n\n\th = dlopen(\"libumem.so\", RTLD_NOLOAD);\n\tif (h) {\n\t\tAZ(dlclose(h));\n\t\treturn (1);\n\t}\n\n\th = dlsym(RTLD_DEFAULT, \"umem_alloc\");\n\tif (h)\n\t\treturn (1);\n\n\treturn (0);\n}\n\nstatic void\nsmu_init(struct stevedore *parent, int ac, char * const *av)\n{\n\tstatic int inited = 0;\n\tconst char *e;\n\tuintmax_t u;\n\tstruct smu_sc *sc;\n\n\tASSERT_MGT();\n\tALLOC_OBJ(sc, SMU_SC_MAGIC);\n\tAN(sc);\n\tsc->smu_max = SIZE_MAX;\n\tassert(sc->smu_max == SIZE_MAX);\n\tparent->priv = sc;\n\n\tAZ(av[ac]);\n\tif (ac > 1)\n\t\tARGV_ERR(\"(-sumem) too many arguments\\n\");\n\n\tif (ac == 1 && *av[0] != '\\0') {\n\t\te = VNUM_2bytes(av[0], &u, 0);\n\t\tif (e != NULL)\n\t\t\tARGV_ERR(\"(-sumem) size \\\"%s\\\": %s\\n\", av[0], e);\n\t\tif ((u != (uintmax_t)(size_t)u))\n\t\t\tARGV_ERR(\"(-sumem) size \\\"%s\\\": too big\\n\", av[0]);\n\t\tif (u < 1024*1024)\n\t\t\tARGV_ERR(\"(-sumem) size \\\"%s\\\": too small, \"\n\t\t\t\t \"did you forget to specify M or G?\\n\", av[0]);\n\t\tsc->smu_max = u;\n\t}\n\n\tif (inited++)\n\t\treturn;\n\n\tif (smu_umem_loaded())\n\t\tsmu_umem_loaded_warn();\n\telse\n\t\tAZ(setenv(env_umem_options, def_umem_options, 0));\n\n\t/* Check if these load in the management process. */\n\t(void) dlerror();\n\tlibumem_hndl = dlmopen(LM_ID_NEWLM, \"libumem.so\", RTLD_LAZY);\n\tif (libumem_hndl == NULL)\n\t\tARGV_ERR(\"(-sumem) cannot open libumem.so: %s\", dlerror());\n\n#define DLSYM_UMEM(fptr,sym)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\t(void) dlerror();\t\t\t\t\t\\\n\t\tif (dlsym(libumem_hndl, #sym) == NULL)\t\t\t\\\n\t\t\tARGV_ERR(\"(-sumem) cannot find symbol \"\t\t\\\n\t\t\t\t #sym \": %s\",\t\t\t\t\\\n\t\t\t\t dlerror());\t\t\t\t\\\n\t\tfptr = NULL;\t\t\t\t\t\t\\\n\t} while(0)\n\n\tDLSYM_UMEM(umem_allocf, umem_alloc);\n\tDLSYM_UMEM(umem_freef, umem_free);\n\tDLSYM_UMEM(umem_cache_createf, umem_cache_create);\n\tDLSYM_UMEM(umem_cache_destroyf, umem_cache_destroy);\n\tDLSYM_UMEM(umem_cache_allocf, umem_cache_alloc);\n\tDLSYM_UMEM(umem_cache_freef, umem_cache_free);\n\n#undef DLSYM_UMEM\n\n\tAZ(dlclose(libumem_hndl));\n\tlibumem_hndl = NULL;\n}\n\n/*\n * Load the symbols for use in the child process, assert if they fail to load.\n */\nstatic void\nsmu_open_init(void)\n{\n\tstatic int inited = 0;\n\n\tif (inited++) {\n\t\tAN(libumem_hndl);\n\t\tAN(umem_allocf);\n\t\treturn;\n\t}\n\n\tif (smu_umem_loaded())\n\t\tsmu_umem_loaded_warn();\n\telse\n\t\tAN(getenv(env_umem_options));\n\n\tAZ(libumem_hndl);\n\tlibumem_hndl = dlopen(\"libumem.so\", RTLD_LAZY);\n\tAN(libumem_hndl);\n\n#define DLSYM_UMEM(fptr,sym)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tfptr = (sym ## _f) dlsym(libumem_hndl, #sym);\t\\\n\t\tAN(fptr);\t\t\t\t\t\\\n\t} while(0)\n\n\tDLSYM_UMEM(umem_allocf, umem_alloc);\n\tDLSYM_UMEM(umem_freef, umem_free);\n\tDLSYM_UMEM(umem_cache_createf, umem_cache_create);\n\tDLSYM_UMEM(umem_cache_destroyf, umem_cache_destroy);\n\tDLSYM_UMEM(umem_cache_allocf, umem_cache_alloc);\n\tDLSYM_UMEM(umem_cache_freef, umem_cache_free);\n\n#undef DLSYM_UMEM\n}\n\nstatic void v_matchproto_(storage_open_f)\nsmu_open(struct stevedore *st)\n{\n\tstruct smu_sc *smu_sc;\n\tchar ident[strlen(st->ident) + 1];\n\n\tASSERT_CLI();\n\tst->lru = LRU_Alloc();\n\tif (lck_smu == NULL)\n\t\tlck_smu = Lck_CreateClass(NULL, \"smu\");\n\tCAST_OBJ_NOTNULL(smu_sc, st->priv, SMU_SC_MAGIC);\n\tLck_New(&smu_sc->smu_mtx, lck_smu);\n\tsmu_sc->stats = VSC_smu_New(NULL, NULL, st->ident);\n\tif (smu_sc->smu_max != SIZE_MAX)\n\t\tsmu_sc->stats->g_space = smu_sc->smu_max;\n\n\tsmu_open_init();\n\n\tbstrcpy(ident, st->ident);\n\tsmu_sc->smu_cache = umem_cache_createf(ident,\n\t\t\t\t\t  sizeof(struct smu),\n\t\t\t\t\t  0,\t\t// align\n\t\t\t\t\t  smu_smu_constructor,\n\t\t\t\t\t  smu_smu_destructor,\n\t\t\t\t\t  NULL,\t\t// reclaim\n\t\t\t\t\t  smu_sc,\t// callback_data\n\t\t\t\t\t  NULL,\t\t// source\n\t\t\t\t\t  0\t\t// cflags\n\t\t);\n\tAN(smu_sc->smu_cache);\n}\n\nstatic void v_matchproto_(storage_close_f)\nsmu_close(const struct stevedore *st, int warn)\n{\n\tstruct smu_sc *smu_sc;\n\n\tASSERT_CLI();\n\n\tCAST_OBJ_NOTNULL(smu_sc, st->priv, SMU_SC_MAGIC);\n\tif (warn)\n\t\treturn;\n\n#ifdef WORKAROUND_3190\n\t/* see ticket 3190 for explanation */\n\tumem_cache_destroyf(smu_sc->smu_cache);\n\tsmu_sc->smu_cache = NULL;\n#endif\n\n\t/*\n\t   XXX TODO?\n\t   - LRU_Free\n\t   - Lck Destroy\n\t*/\n}\n\nconst struct stevedore smu_stevedore = {\n\t.magic\t\t=\tSTEVEDORE_MAGIC,\n\t.name\t\t=\t\"umem\",\n\t.init\t\t=\tsmu_init,\n\t.open\t\t=\tsmu_open,\n\t.close\t\t=\tsmu_close,\n\t.sml_alloc\t=\tsmu_alloc,\n\t.sml_free\t=\tsmu_free,\n\t.allocobj\t=\tSML_allocobj,\n\t.panic\t\t=\tSML_panic,\n\t.methods\t=\t&SML_methods,\n\t.var_free_space =\tsmu_free_space,\n\t.var_used_space =\tsmu_used_space,\n};\n\n#endif /* HAVE_UMEM_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-varnish-cache-6.4.0-rypi4oyixvgpbmjahq5n45zcm4a7jnyy/spack-src/bin/varnishd/mgt/mgt_param_tbl.c": "/*-\n * Copyright (c) 2006 Verdens Gang AS\n * Copyright (c) 2006-2015 Varnish Software AS\n * All rights reserved.\n *\n * Author: Poul-Henning Kamp <phk@phk.freebsd.dk>\n *\n * SPDX-License-Identifier: BSD-2-Clause\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"config.h\"\n\n#include <stdio.h>\n\n#include \"mgt/mgt.h\"\n\n#include \"mgt/mgt_param.h\"\n\n\n#define MEMPOOL_TEXT\t\t\t\t\t\t\t\\\n\t\"The three numbers are:\\n\"\t\t\t\t\t\\\n\t\"\\tmin_pool\\tminimum size of free pool.\\n\"\t\t\t\\\n\t\"\\tmax_pool\\tmaximum size of free pool.\\n\"\t\t\t\\\n\t\"\\tmax_age\\tmax age of free element.\"\n\nstruct parspec mgt_parspec[] = {\n#define PARAM(nm, ty, ...) { #nm, tweak_##ty, &mgt_param.nm, __VA_ARGS__ },\n#include \"tbl/params.h\"\n\n\t{ \"cc_command\", tweak_string, &mgt_cc_cmd,\n\t\tNULL, NULL, VCC_CC,\n\t\tNULL,\n\t\t\"Command used for compiling the C source code to a \"\n\t\t\"dlopen(3) loadable object.  Any occurrence of %s in \"\n\t\t\"the string will be replaced with the source file name, \"\n\t\t\"and %o will be replaced with the output file name.\",\n\t\tMUST_RELOAD,\n\t\tNULL, NULL, \"defined when Varnish is built\" },\n\t{ \"vcl_path\", tweak_string, &mgt_vcl_path,\n\t\tNULL, NULL, VARNISH_VCL_DIR,\n\t\tNULL,\n\t\t\"Directory (or colon separated list of directories) \"\n\t\t\"from which relative VCL filenames (vcl.load and \"\n\t\t\"include) are to be found.  By default Varnish searches \"\n\t\t\"VCL files in both the system configuration and shared \"\n\t\t\"data directories to allow packages to drop their VCL \"\n\t\t\"files in a standard location where relative includes \"\n\t\t\"would work.\" },\n\t{ \"vmod_path\", tweak_string, &mgt_vmod_path,\n\t\tNULL, NULL, VARNISH_VMOD_DIR,\n\t\tNULL,\n\t\t\"Directory (or colon separated list of directories) \"\n\t\t\"where VMODs are to be found.\" },\n\t{ \"vcc_err_unref\", tweak_bool, &mgt_vcc_err_unref,\n\t\tNULL, NULL, \"on\",\n\t\t\"bool\",\n\t\t\"Unreferenced VCL objects result in error.\" },\n\t{ \"vcc_allow_inline_c\", tweak_bool, &mgt_vcc_allow_inline_c,\n\t\tNULL, NULL, \"off\",\n\t\t\"bool\",\n\t\t\"Allow inline C code in VCL.\" },\n\t{ \"vcc_unsafe_path\", tweak_bool, &mgt_vcc_unsafe_path,\n\t\tNULL, NULL, \"on\",\n\t\t\"bool\",\n\t\t\"Allow '/' in vmod & include paths.\\n\"\n\t\t\"Allow 'import ... from ...'.\" },\n\t{ \"pcre_match_limit\", tweak_uint,\n\t\t&mgt_param.vre_limits.match,\n\t\t\"1\", NULL, \"10000\",\n\t\tNULL,\n\t\t\"The limit for the number of calls to the internal match()\"\n\t\t\" function in pcre_exec().\\n\\n\"\n\t\t\"(See: PCRE_EXTRA_MATCH_LIMIT in pcre docs.)\\n\\n\"\n\t\t\"This parameter limits how much CPU time\"\n\t\t\" regular expression matching can soak up.\" },\n\t{ \"pcre_match_limit_recursion\", tweak_uint,\n\t\t&mgt_param.vre_limits.match_recursion,\n\t\t\"1\", NULL, \"20\",\n\t\tNULL,\n\t\t\"The recursion depth-limit for the internal match() function\"\n\t\t\" in a pcre_exec().\\n\\n\"\n\t\t\"(See: PCRE_EXTRA_MATCH_LIMIT_RECURSION in pcre docs.)\\n\\n\"\n\t\t\"This puts an upper limit on the amount of stack used\"\n\t\t\" by PCRE for certain classes of regular expressions.\\n\\n\"\n\t\t\"We have set the default value low in order to\"\n\t\t\" prevent crashes, at the cost of possible regexp\"\n\t\t\" matching failures.\\n\\n\"\n\t\t\"Matching failures will show up in the log as VCL_Error\"\n\t\t\" messages with regexp errors -27 or -21.\\n\\n\"\n\t\t\"Testcase r01576 can be useful when tuning this parameter.\" },\n\t{ \"pool_req\", tweak_poolparam, &mgt_param.req_pool,\n\t\tNULL, NULL, \"10,100,10\",\n\t\tNULL,\n\t\t\"Parameters for per worker pool request memory pool.\\n\\n\"\n\t\tMEMPOOL_TEXT },\n\t{ \"pool_sess\", tweak_poolparam, &mgt_param.sess_pool,\n\t\tNULL, NULL, \"10,100,10\",\n\t\tNULL,\n\t\t\"Parameters for per worker pool session memory pool.\\n\\n\"\n\t\tMEMPOOL_TEXT },\n\t{ \"pool_vbo\", tweak_poolparam, &mgt_param.vbo_pool,\n\t\tNULL, NULL, \"10,100,10\",\n\t\tNULL,\n\t\t\"Parameters for backend object fetch memory pool.\\n\\n\"\n\t\tMEMPOOL_TEXT },\n\n\t{ NULL, NULL, NULL }\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-varnish-cache-6.4.0-rypi4oyixvgpbmjahq5n45zcm4a7jnyy/spack-src/bin/varnishd/mgt/mgt_vcc.c": "/*-\n * Copyright (c) 2006 Verdens Gang AS\n * Copyright (c) 2006-2015 Varnish Software AS\n * All rights reserved.\n *\n * Author: Poul-Henning Kamp <phk@phk.freebsd.dk>\n *\n * SPDX-License-Identifier: BSD-2-Clause\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * VCL compiler stuff\n */\n\n#include \"config.h\"\n\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/stat.h>\n\n#include \"mgt/mgt.h\"\n#include \"mgt/mgt_vcl.h\"\n#include \"common/heritage.h\"\n#include \"storage/storage.h\"\n\n#include \"libvcc.h\"\n#include \"vcli_serve.h\"\n#include \"vfil.h\"\n#include \"vsub.h\"\n#include \"vtim.h\"\n\nstruct vcc_priv {\n\tunsigned\tmagic;\n#define VCC_PRIV_MAGIC\t0x70080cb8\n\tconst char\t*vclsrc;\n\tconst char\t*vclsrcfile;\n\tstruct vsb\t*dir;\n\tstruct vsb\t*csrcfile;\n\tstruct vsb\t*libfile;\n\tstruct vsb\t*symfile;\n};\n\nchar *mgt_cc_cmd;\nconst char *mgt_vcl_path;\nconst char *mgt_vmod_path;\nunsigned mgt_vcc_err_unref;\nunsigned mgt_vcc_allow_inline_c;\nunsigned mgt_vcc_unsafe_path;\n\n\n#define VGC_SRC\t\t\"vgc.c\"\n#define VGC_LIB\t\t\"vgc.so\"\n#define VGC_SYM\t\t\"vgc.sym\"\n\n/*--------------------------------------------------------------------*/\n\nvoid\nmgt_DumpBuiltin(void)\n{\n\tprintf(\"%s\\n\", builtin_vcl);\n}\n\n/*--------------------------------------------------------------------\n * Invoke system VCC compiler in a sub-process\n */\n\nstatic void v_noreturn_ v_matchproto_(vsub_func_f)\nrun_vcc(void *priv)\n{\n\tstruct vsb *sb = NULL;\n\tstruct vclprog *vpg;\n\tstruct vcc_priv *vp;\n\tstruct vcc *vcc;\n\tstruct stevedore *stv;\n\tint i;\n\n\tVJ_subproc(JAIL_SUBPROC_VCC);\n\tCAST_OBJ_NOTNULL(vp, priv, VCC_PRIV_MAGIC);\n\n\tAZ(chdir(VSB_data(vp->dir)));\n\n\tvcc = VCC_New();\n\tAN(vcc);\n\tVCC_Builtin_VCL(vcc, builtin_vcl);\n\tVCC_VCL_path(vcc, mgt_vcl_path);\n\tVCC_VMOD_path(vcc, mgt_vmod_path);\n\tVCC_Err_Unref(vcc, mgt_vcc_err_unref);\n\tVCC_Allow_InlineC(vcc, mgt_vcc_allow_inline_c);\n\tVCC_Unsafe_Path(vcc, mgt_vcc_unsafe_path);\n\tSTV_Foreach(stv)\n\t\tVCC_Predef(vcc, \"VCL_STEVEDORE\", stv->ident);\n\tVTAILQ_FOREACH(vpg, &vclhead, list)\n\t\tif (mcf_is_label(vpg))\n\t\t\tVCC_Predef(vcc, \"VCL_VCL\", vpg->name);\n\ti = VCC_Compile(vcc, &sb, vp->vclsrc, vp->vclsrcfile,\n\t    VGC_SRC, VGC_SYM);\n\tif (VSB_len(sb))\n\t\tprintf(\"%s\", VSB_data(sb));\n\tVSB_destroy(&sb);\n\texit(i == 0 ? 0 : 2);\n}\n\n/*--------------------------------------------------------------------\n * Invoke system C compiler in a sub-process\n */\n\nstatic void v_matchproto_(vsub_func_f)\nrun_cc(void *priv)\n{\n\tstruct vcc_priv *vp;\n\tstruct vsb *sb;\n\tint pct;\n\tchar *p;\n\n\tVJ_subproc(JAIL_SUBPROC_CC);\n\tCAST_OBJ_NOTNULL(vp, priv, VCC_PRIV_MAGIC);\n\n\tAZ(chdir(VSB_data(vp->dir)));\n\n\tsb = VSB_new_auto();\n\tAN(sb);\n\tfor (p = mgt_cc_cmd, pct = 0; *p; ++p) {\n\t\tif (pct) {\n\t\t\tswitch (*p) {\n\t\t\tcase 's':\n\t\t\t\tVSB_cat(sb, VGC_SRC);\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tVSB_cat(sb, VGC_LIB);\n\t\t\t\tbreak;\n\t\t\tcase '%':\n\t\t\t\tVSB_putc(sb, '%');\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tVSB_putc(sb, '%');\n\t\t\t\tVSB_putc(sb, *p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpct = 0;\n\t\t} else if (*p == '%') {\n\t\t\tpct = 1;\n\t\t} else {\n\t\t\tVSB_putc(sb, *p);\n\t\t}\n\t}\n\tif (pct)\n\t\tVSB_putc(sb, '%');\n\tAZ(VSB_finish(sb));\n\n\t(void)umask(027);\n\t(void)execl(\"/bin/sh\", \"/bin/sh\", \"-c\", VSB_data(sb), (char*)0);\n\tVSB_destroy(&sb);\t\t\t\t// For flexelint\n}\n\n/*--------------------------------------------------------------------\n * Attempt to open compiled VCL in a sub-process\n */\n\nstatic void v_noreturn_ v_matchproto_(vsub_func_f)\nrun_dlopen(void *priv)\n{\n\tstruct vcc_priv *vp;\n\n\tVJ_subproc(JAIL_SUBPROC_VCLLOAD);\n\tCAST_OBJ_NOTNULL(vp, priv, VCC_PRIV_MAGIC);\n\tif (VCL_TestLoad(VSB_data(vp->libfile)))\n\t\texit(1);\n\texit(0);\n}\n\n/*--------------------------------------------------------------------\n * Touch a filename and make it available to privsep-privs\n */\n\nstatic int\nmgt_vcc_touchfile(const char *fn, struct vsb *sb)\n{\n\tint i;\n\n\ti = open(fn, O_WRONLY|O_CREAT|O_TRUNC, 0640);\n\tif (i < 0) {\n\t\tVSB_printf(sb, \"Failed to create %s: %s\", fn, vstrerror(errno));\n\t\treturn (2);\n\t}\n\tif (fchown(i, mgt_param.uid, mgt_param.gid) != 0)\n\t\tif (geteuid() == 0)\n\t\t\tVSB_printf(sb, \"Failed to change owner on %s: %s\\n\",\n\t\t\t    fn, vstrerror(errno));\n\tclosefd(&i);\n\treturn (0);\n}\n\n/*--------------------------------------------------------------------\n * Compile a VCL program, return shared object, errors in sb.\n */\n\nstatic unsigned\nmgt_vcc_compile(struct vcc_priv *vp, struct vsb *sb, int C_flag)\n{\n\tchar *csrc;\n\tunsigned subs;\n\n\tAN(sb);\n\tVSB_clear(sb);\n\tif (mgt_vcc_touchfile(VSB_data(vp->csrcfile), sb))\n\t\treturn (2);\n\tif (mgt_vcc_touchfile(VSB_data(vp->libfile), sb))\n\t\treturn (2);\n\n\tsubs = VSUB_run(sb, run_vcc, vp, \"VCC-compiler\", -1);\n\tif (subs)\n\t\treturn (subs);\n\n\tif (C_flag) {\n\t\tcsrc = VFIL_readfile(NULL, VSB_data(vp->csrcfile), NULL);\n\t\tAN(csrc);\n\t\tVSB_cat(sb, csrc);\n\t\tfree(csrc);\n\n\t\tVSB_cat(sb, \"/* EXTERNAL SYMBOL TABLE\\n\");\n\t\tcsrc = VFIL_readfile(NULL, VSB_data(vp->symfile), NULL);\n\t\tAN(csrc);\n\t\tVSB_cat(sb, csrc);\n\t\tVSB_cat(sb, \"*/\\n\");\n\t\tfree(csrc);\n\t}\n\n\tsubs = VSUB_run(sb, run_cc, vp, \"C-compiler\", 10);\n\tif (subs)\n\t\treturn (subs);\n\n\tsubs = VSUB_run(sb, run_dlopen, vp, \"dlopen\", 10);\n\treturn (subs);\n}\n\n/*--------------------------------------------------------------------*/\n\nstatic void\nmgt_vcc_init_vp(struct vcc_priv *vp)\n{\n\tINIT_OBJ(vp, VCC_PRIV_MAGIC);\n\tvp->csrcfile = VSB_new_auto();\n\tAN(vp->csrcfile);\n\tvp->libfile = VSB_new_auto();\n\tAN(vp->libfile);\n\tvp->symfile = VSB_new_auto();\n\tAN(vp->symfile);\n\tvp->dir = VSB_new_auto();\n\tAN(vp->dir);\n}\n\nstatic void\nmgt_vcc_fini_vp(struct vcc_priv *vp, int leave_lib)\n{\n\tif (!MGT_DO_DEBUG(DBG_VCL_KEEP)) {\n\t\t(void)unlink(VSB_data(vp->csrcfile));\n\t\t(void)unlink(VSB_data(vp->symfile));\n\t\tif (!leave_lib)\n\t\t\t(void)unlink(VSB_data(vp->libfile));\n\t}\n\t(void)rmdir(VSB_data(vp->dir));\n\tVSB_destroy(&vp->csrcfile);\n\tVSB_destroy(&vp->libfile);\n\tVSB_destroy(&vp->symfile);\n\tVSB_destroy(&vp->dir);\n}\n\nchar *\nmgt_VccCompile(struct cli *cli, struct vclprog *vcl, const char *vclname,\n    const char *vclsrc, const char *vclsrcfile, int C_flag)\n{\n\tstruct vcc_priv vp[1];\n\tstruct vsb *sb;\n\tunsigned status;\n\tchar *p;\n\n\tAN(cli);\n\n\tsb = VSB_new_auto();\n\tAN(sb);\n\n\tmgt_vcc_init_vp(vp);\n\tvp->vclsrc = vclsrc;\n\tvp->vclsrcfile = vclsrcfile;\n\n\t/*\n\t * The subdirectory must have a unique name to 100% certain evade\n\t * the refcounting semantics of dlopen(3).\n\t *\n\t * Bad implementations of dlopen(3) think the shlib you are opening\n\t * is the same, if the filename is the same as one already opened.\n\t *\n\t * Sensible implementations do a stat(2) and requires st_ino and\n\t * st_dev to also match.\n\t *\n\t * A correct implementation would run on filesystems which tickle\n\t * st_gen, and also insist that be the identical, before declaring\n\t * a match.\n\t *\n\t * Since no correct implementations are known to exist, we are subject\n\t * to really interesting races if you do something like:\n\t *\n\t *\t(running on 'boot' vcl)\n\t *\tvcl.load foo /foo.vcl\n\t *\tvcl.use foo\n\t *\tfew/slow requests\n\t *\tvcl.use boot\n\t *\tvcl.discard foo\n\t *\tvcl.load foo /foo.vcl\t// dlopen(3) says \"same-same\"\n\t *\tvcl.use foo\n\t *\n\t * Because discard of the first 'foo' lingers on non-zero reference\n\t * count, and when it finally runs, it trashes the second 'foo' because\n\t * dlopen(3) decided they were really the same thing.\n\t *\n\t * The Best way to reproduce this is to have regexps in the VCL.\n\t */\n\n\tVSB_printf(vp->dir, \"vcl_%s.%.6f\", vclname, VTIM_real());\n\tAZ(VSB_finish(vp->dir));\n\n\tVSB_printf(vp->csrcfile, \"%s/%s\", VSB_data(vp->dir), VGC_SRC);\n\tAZ(VSB_finish(vp->csrcfile));\n\n\tVSB_printf(vp->libfile, \"%s/%s\", VSB_data(vp->dir), VGC_LIB);\n\tAZ(VSB_finish(vp->libfile));\n\n\tVSB_printf(vp->symfile, \"%s/%s\", VSB_data(vp->dir), VGC_SYM);\n\tAZ(VSB_finish(vp->symfile));\n\n\tif (VJ_make_subdir(VSB_data(vp->dir), \"VCL\", cli->sb)) {\n\t\tmgt_vcc_fini_vp(vp, 0);\n\t\tVSB_destroy(&sb);\n\t\tVCLI_Out(cli, \"VCL compilation failed\");\n\t\tVCLI_SetResult(cli, CLIS_PARAM);\n\t\treturn (NULL);\n\t}\n\n\tstatus = mgt_vcc_compile(vp, sb, C_flag);\n\tAZ(VSB_finish(sb));\n\tif (VSB_len(sb) > 0)\n\t\tVCLI_Out(cli, \"%s\", VSB_data(sb));\n\tVSB_destroy(&sb);\n\n\tif (status || C_flag) {\n\t\tmgt_vcc_fini_vp(vp, 0);\n\t\tif (status) {\n\t\t\tVCLI_Out(cli, \"VCL compilation failed\");\n\t\t\tVCLI_SetResult(cli, CLIS_PARAM);\n\t\t}\n\t\treturn (NULL);\n\t}\n\n\tp = VFIL_readfile(NULL, VSB_data(vp->symfile), NULL);\n\tAN(p);\n\tmgt_vcl_symtab(vcl, p);\n\n\tVCLI_Out(cli, \"VCL compiled.\\n\");\n\n\tREPLACE(p, VSB_data(vp->libfile));\n\tmgt_vcc_fini_vp(vp, 1);\n\treturn (p);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-varnish-cache-6.4.0-rypi4oyixvgpbmjahq5n45zcm4a7jnyy/spack-src/bin/varnishd/cache/cache_vcl.c": "/*-\n * Copyright (c) 2006 Verdens Gang AS\n * Copyright (c) 2006-2016 Varnish Software AS\n * All rights reserved.\n *\n * Author: Poul-Henning Kamp <phk@phk.freebsd.dk>\n *\n * SPDX-License-Identifier: BSD-2-Clause\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n */\n\n#include \"config.h\"\n\n#include <dlfcn.h>\n#include <fnmatch.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"cache_varnishd.h\"\n#include \"common/heritage.h\"\n\n#include \"vcl.h\"\n\n#include \"cache_director.h\"\n#include \"cache_vcl.h\"\n#include \"vcli_serve.h\"\n#include \"vtim.h\"\n#include \"vcc_interface.h\"\n\nconst struct vcltemp VCL_TEMP_INIT[1] = {{ .name = \"init\", .is_cold = 1 }};\nconst struct vcltemp VCL_TEMP_COLD[1] = {{ .name = \"cold\", .is_cold = 1 }};\nconst struct vcltemp VCL_TEMP_WARM[1] = {{ .name = \"warm\", .is_warm = 1 }};\nconst struct vcltemp VCL_TEMP_BUSY[1] = {{ .name = \"busy\", .is_warm = 1 }};\nconst struct vcltemp VCL_TEMP_COOLING[1] = {{ .name = \"cooling\" }};\n\n// not really a temperature\nstatic const struct vcltemp VCL_TEMP_LABEL[1] = {{ .name = \"label\" }};\n\n/*\n * XXX: Presently all modifications to this list happen from the\n * CLI event-engine, so no locking is necessary\n */\nstatic VTAILQ_HEAD(, vcl)\tvcl_head =\n    VTAILQ_HEAD_INITIALIZER(vcl_head);\n\nstruct lock\t\tvcl_mtx;\nstruct vcl\t\t*vcl_active; /* protected by vcl_mtx */\n\nstatic struct vrt_ctx ctx_cli;\nstatic unsigned handling_cli;\nstatic struct ws ws_cli;\nstatic uintptr_t ws_snapshot_cli;\nstatic struct vsl_log vsl_cli;\n\n/*--------------------------------------------------------------------*/\n\nvoid\nVCL_Bo2Ctx(struct vrt_ctx *ctx, struct busyobj *bo)\n{\n\n\tCHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo->wrk, WORKER_MAGIC);\n\tctx->vcl = bo->vcl;\n\tctx->syntax = ctx->vcl->conf->syntax;\n\tctx->vsl = bo->vsl;\n\tctx->http_bereq = bo->bereq;\n\tctx->http_beresp = bo->beresp;\n\tctx->bo = bo;\n\tctx->sp = bo->sp;\n\tctx->now = bo->t_prev;\n\tctx->ws = bo->ws;\n\tctx->handling = &bo->wrk->handling;\n\t*ctx->handling = 0;\n}\n\nvoid\nVCL_Req2Ctx(struct vrt_ctx *ctx, struct req *req)\n{\n\n\tCHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(req, REQ_MAGIC);\n\n\tctx->vcl = req->vcl;\n\tctx->syntax = ctx->vcl->conf->syntax;\n\tctx->vsl = req->vsl;\n\tctx->http_req = req->http;\n\tCHECK_OBJ_NOTNULL(req->top, REQTOP_MAGIC);\n\tctx->http_req_top = req->top->topreq->http;\n\tctx->http_resp = req->resp;\n\tctx->req = req;\n\tctx->sp = req->sp;\n\tctx->now = req->t_prev;\n\tctx->ws = req->ws;\n\tctx->handling = &req->wrk->handling;\n\t*ctx->handling = 0;\n}\n\n/*--------------------------------------------------------------------*/\n\nstruct vrt_ctx *\nVCL_Get_CliCtx(int msg)\n{\n\n\tASSERT_CLI();\n\tAZ(ctx_cli.handling);\n\tINIT_OBJ(&ctx_cli, VRT_CTX_MAGIC);\n\thandling_cli = 0;\n\tctx_cli.handling = &handling_cli;\n\tctx_cli.now = VTIM_real();\n\tif (msg) {\n\t\tctx_cli.msg = VSB_new_auto();\n\t\tAN(ctx_cli.msg);\n\t} else {\n\t\tctx_cli.vsl = &vsl_cli;\n\t}\n\tctx_cli.ws = &ws_cli;\n\tWS_Assert(ctx_cli.ws);\n\treturn (&ctx_cli);\n}\n\n/*\n * releases CLI ctx\n *\n * returns finished error msg vsb if VCL_Get_CliCtx(1) was called\n *\n * caller needs to VSB_destroy a non-NULL return value\n *\n */\nstruct vsb *\nVCL_Rel_CliCtx(struct vrt_ctx **ctx)\n{\n\tstruct vsb *r = NULL;\n\n\tASSERT_CLI();\n\tassert(*ctx == &ctx_cli);\n\tAN((*ctx)->handling);\n\tif (ctx_cli.msg) {\n\t\tTAKE_OBJ_NOTNULL(r, &ctx_cli.msg, VSB_MAGIC);\n\t\tAZ(VSB_finish(r));\n\t}\n\tif (ctx_cli.vsl)\n\t\tVSL_Flush(ctx_cli.vsl, 0);\n\tWS_Assert(ctx_cli.ws);\n\tWS_Rollback(&ws_cli, ws_snapshot_cli);\n\tINIT_OBJ(*ctx, VRT_CTX_MAGIC);\n\t*ctx = NULL;\n\n\treturn (r);\n}\n\n/*--------------------------------------------------------------------*/\n\nstatic int\nvcl_send_event(struct vcl *vcl, enum vcl_event_e ev, struct vsb **msg)\n{\n\tint r, havemsg;\n\tunsigned method = 0;\n\tstruct vrt_ctx *ctx;\n\n\tASSERT_CLI();\n\n\tCHECK_OBJ_NOTNULL(vcl, VCL_MAGIC);\n\tCHECK_OBJ_NOTNULL(vcl->conf, VCL_CONF_MAGIC);\n\tAN(msg);\n\tAZ(*msg);\n\n\tswitch (ev) {\n\tcase VCL_EVENT_LOAD:\n\t\tmethod = VCL_MET_INIT;\n\t\t/* FALLTHROUGH */\n\tcase VCL_EVENT_WARM:\n\t\thavemsg = 1;\n\t\tbreak;\n\tcase VCL_EVENT_DISCARD:\n\t\tmethod = VCL_MET_FINI;\n\t\t/* FALLTHROUGH */\n\tcase VCL_EVENT_COLD:\n\t\thavemsg = 0;\n\t\tbreak;\n\tdefault:\n\t\tWRONG(\"vcl_event\");\n\t}\n\n\tctx = VCL_Get_CliCtx(havemsg);\n\n\tAN(ctx->handling);\n\tAZ(*ctx->handling);\n\tAN(ctx->ws);\n\n\tctx->vcl = vcl;\n\tctx->syntax = ctx->vcl->conf->syntax;\n\tctx->method = method;\n\n\tVCL_TaskEnter(cli_task_privs);\n\tr = ctx->vcl->conf->event_vcl(ctx, ev);\n\tVCL_TaskLeave(cli_task_privs);\n\n\t/* if the warm event did not get to vcl_init, vcl_fini\n\t * won't be run, so handling may be zero */\n\tif (method && *ctx->handling && *ctx->handling != VCL_RET_OK) {\n\t\tassert(ev == VCL_EVENT_LOAD);\n\t\tr = 1;\n\t}\n\n\t*msg = VCL_Rel_CliCtx(&ctx);\n\n\tif (r && (ev == VCL_EVENT_COLD || ev == VCL_EVENT_DISCARD))\n\t\tWRONG(\"A VMOD cannot fail COLD or DISCARD events\");\n\n\treturn (r);\n}\n\n/*--------------------------------------------------------------------*/\n\nstruct vcl *\nvcl_find(const char *name)\n{\n\tstruct vcl *vcl;\n\n\tASSERT_CLI();\n\tVTAILQ_FOREACH(vcl, &vcl_head, list) {\n\t\tif (vcl->discard)\n\t\t\tcontinue;\n\t\tif (!strcmp(vcl->loaded_name, name))\n\t\t\treturn (vcl);\n\t}\n\treturn (NULL);\n}\n\n/*--------------------------------------------------------------------*/\n\nvoid\nVCL_Panic(struct vsb *vsb, const char *nm, const struct vcl *vcl)\n{\n\tconst struct vpi_ii *ii;\n\tint i;\n\n\tAN(vsb);\n\tif (vcl == NULL)\n\t\treturn;\n\tVSB_printf(vsb, \"%s = {\\n\", nm);\n\tVSB_indent(vsb, 2);\n\tPAN_CheckMagic(vsb, vcl, VCL_MAGIC);\n\tVSB_printf(vsb, \"name = \\\"%s\\\",\\n\", vcl->loaded_name);\n\tVSB_printf(vsb, \"busy = %u,\\n\", vcl->busy);\n\tVSB_printf(vsb, \"discard = %u,\\n\", vcl->discard);\n\tVSB_printf(vsb, \"state = %s,\\n\", vcl->state);\n\tVSB_printf(vsb, \"temp = %s,\\n\", vcl->temp ? vcl->temp->name : \"(null)\");\n\tVSB_cat(vsb, \"conf = {\\n\");\n\tVSB_indent(vsb, 2);\n\tif (vcl->conf == NULL) {\n\t\tVSB_cat(vsb, \"conf = NULL\\n\");\n\t} else {\n\t\tPAN_CheckMagic(vsb, vcl->conf, VCL_CONF_MAGIC);\n\t\tVSB_printf(vsb, \"syntax = \\\"%u\\\",\\n\", vcl->conf->syntax);\n\t\tVSB_cat(vsb, \"srcname = {\\n\");\n\t\tVSB_indent(vsb, 2);\n\t\tfor (i = 0; i < vcl->conf->nsrc; ++i)\n\t\t\tVSB_printf(vsb, \"\\\"%s\\\",\\n\", vcl->conf->srcname[i]);\n\t\tVSB_indent(vsb, -2);\n\t\tVSB_cat(vsb, \"instances = {\\n\");\n\t\tVSB_indent(vsb, 2);\n\t\tii = vcl->conf->instance_info;\n\t\twhile (ii != NULL && ii->p != NULL) {\n\t\t\tVSB_printf(vsb, \"\\\"%s\\\" = %p,\\n\", ii->name,\n\t\t\t    (const void *)*(const uintptr_t *)ii->p);\n\t\t\tii++;\n\t\t}\n\t\tVSB_indent(vsb, -2);\n\t\tVSB_cat(vsb, \"},\\n\");\n\t}\n\tVSB_indent(vsb, -2);\n\tVSB_cat(vsb, \"},\\n\");\n\tVSB_indent(vsb, -2);\n\tVSB_cat(vsb, \"},\\n\");\n}\n\n/*--------------------------------------------------------------------*/\n\nvoid\nVCL_Update(struct vcl **vcc, struct vcl *vcl)\n{\n\tstruct vcl *old;\n\n\tAN(vcc);\n\n\told = *vcc;\n\t*vcc = NULL;\n\n\tCHECK_OBJ_ORNULL(old, VCL_MAGIC);\n\n\tLck_Lock(&vcl_mtx);\n\tif (old != NULL) {\n\t\tassert(old->busy > 0);\n\t\told->busy--;\n\t}\n\n\tif (vcl == NULL)\n\t\tvcl = vcl_active; /* Sample vcl_active under lock to avoid\n\t\t\t\t   * race */\n\tCHECK_OBJ_NOTNULL(vcl, VCL_MAGIC);\n\tif (vcl->label == NULL) {\n\t\tAN(strcmp(vcl->state, VCL_TEMP_LABEL->name));\n\t\t*vcc = vcl;\n\t} else {\n\t\tAZ(strcmp(vcl->state, VCL_TEMP_LABEL->name));\n\t\t*vcc = vcl->label;\n\t}\n\tCHECK_OBJ_NOTNULL(*vcc, VCL_MAGIC);\n\tAZ((*vcc)->discard);\n\t(*vcc)->busy++;\n\tLck_Unlock(&vcl_mtx);\n\tassert((*vcc)->temp->is_warm);\n}\n\n/*--------------------------------------------------------------------*/\n\nstatic int\nvcl_iterdir(struct cli *cli, const char *pat, const struct vcl *vcl,\n    vcl_be_func *func, void *priv)\n{\n\tint i, found = 0;\n\tstruct vcldir *vdir;\n\n\tLck_AssertHeld(&vcl_mtx);\n\tVTAILQ_FOREACH(vdir, &vcl->director_list, list) {\n\t\tif (fnmatch(pat, vdir->cli_name, 0))\n\t\t\tcontinue;\n\t\tfound++;\n\t\ti = func(cli, vdir->dir, priv);\n\t\tif (i < 0)\n\t\t\treturn (i);\n\t\tfound += i;\n\t}\n\treturn (found);\n}\n\nint\nVCL_IterDirector(struct cli *cli, const char *pat,\n    vcl_be_func *func, void *priv)\n{\n\tint i, found = 0;\n\tstruct vsb *vsb;\n\tstruct vcl *vcl;\n\n\tASSERT_CLI();\n\tvsb = VSB_new_auto();\n\tAN(vsb);\n\tif (pat == NULL || *pat == '\\0' || !strcmp(pat, \"*\")) {\n\t\t// all backends in active VCL\n\t\tVSB_printf(vsb, \"%s.*\", VCL_Name(vcl_active));\n\t\tvcl = vcl_active;\n\t} else if (strchr(pat, '.') == NULL) {\n\t\t// pattern applies to active vcl\n\t\tVSB_printf(vsb, \"%s.%s\", VCL_Name(vcl_active), pat);\n\t\tvcl = vcl_active;\n\t} else {\n\t\t// use pattern as is\n\t\tVSB_cat(vsb, pat);\n\t\tvcl = NULL;\n\t}\n\tAZ(VSB_finish(vsb));\n\tLck_Lock(&vcl_mtx);\n\tif (vcl != NULL) {\n\t\tfound = vcl_iterdir(cli, VSB_data(vsb), vcl, func, priv);\n\t} else {\n\t\tVTAILQ_FOREACH(vcl, &vcl_head, list) {\n\t\t\ti = vcl_iterdir(cli, VSB_data(vsb), vcl, func, priv);\n\t\t\tif (i < 0) {\n\t\t\t\tfound = i;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfound += i;\n\t\t\t}\n\t\t}\n\t}\n\tLck_Unlock(&vcl_mtx);\n\tVSB_destroy(&vsb);\n\treturn (found);\n}\n\nstatic void\nvcl_BackendEvent(const struct vcl *vcl, enum vcl_event_e e)\n{\n\tstruct vcldir *vdir;\n\n\tASSERT_CLI();\n\tCHECK_OBJ_NOTNULL(vcl, VCL_MAGIC);\n\tAZ(vcl->busy);\n\n\tLck_Lock(&vcl_mtx);\n\tVTAILQ_FOREACH(vdir, &vcl->director_list, list)\n\t\tVDI_Event(vdir->dir, e);\n\tLck_Unlock(&vcl_mtx);\n}\n\nstatic void\nvcl_KillBackends(struct vcl *vcl)\n{\n\tstruct vcldir *vdir;\n\n\tCHECK_OBJ_NOTNULL(vcl, VCL_MAGIC);\n\tAZ(vcl->busy);\n\tassert(VTAILQ_EMPTY(&vcl->ref_list));\n\tLck_Lock(&vcl_mtx);\n\twhile (1) {\n\t\tvdir = VTAILQ_FIRST(&vcl->director_list);\n\t\tif (vdir == NULL)\n\t\t\tbreak;\n\t\tVTAILQ_REMOVE(&vcl->director_list, vdir, list);\n\t\tREPLACE(vdir->cli_name, NULL);\n\t\tAN(vdir->methods->destroy);\n\t\tvdir->methods->destroy(vdir->dir);\n\t\tFREE_OBJ(vdir->dir);\n\t\tFREE_OBJ(vdir);\n\t}\n\tLck_Unlock(&vcl_mtx);\n}\n\n/*--------------------------------------------------------------------*/\n\nstatic struct vcl *\nVCL_Open(const char *fn, struct vsb *msg)\n{\n\tstruct vcl *vcl;\n\tvoid *dlh;\n\tstruct VCL_conf const *cnf;\n\n\tAN(fn);\n\tAN(msg);\n\n#ifdef RTLD_NOLOAD\n\t/* Detect bogus caching by dlopen(3) */\n\tdlh = dlopen(fn, RTLD_NOW | RTLD_NOLOAD);\n\tAZ(dlh);\n#endif\n\tdlh = dlopen(fn, RTLD_NOW | RTLD_LOCAL);\n\tif (dlh == NULL) {\n\t\tVSB_cat(msg, \"Could not load compiled VCL.\\n\");\n\t\tVSB_printf(msg, \"\\tdlopen() = %s\\n\", dlerror());\n\t\treturn (NULL);\n\t}\n\tcnf = dlsym(dlh, \"VCL_conf\");\n\tif (cnf == NULL) {\n\t\tVSB_cat(msg, \"Compiled VCL lacks metadata.\\n\");\n\t\t(void)dlclose(dlh);\n\t\treturn (NULL);\n\t}\n\tif (cnf->magic != VCL_CONF_MAGIC) {\n\t\tVSB_cat(msg, \"Compiled VCL has mangled metadata.\\n\");\n\t\t(void)dlclose(dlh);\n\t\treturn (NULL);\n\t}\n\tif (cnf->syntax < heritage.min_vcl_version ||\n\t    cnf->syntax > heritage.max_vcl_version) {\n\t\tVSB_printf(msg, \"Compiled VCL version (%.1f) not supported.\\n\",\n\t\t    .1 * cnf->syntax);\n\t\t(void)dlclose(dlh);\n\t\treturn (NULL);\n\t}\n\tALLOC_OBJ(vcl, VCL_MAGIC);\n\tAN(vcl);\n\tvcl->dlh = dlh;\n\tvcl->conf = cnf;\n\treturn (vcl);\n}\n\nstatic void\nVCL_Close(struct vcl **vclp)\n{\n\tstruct vcl *vcl;\n\n\tCHECK_OBJ_NOTNULL(*vclp, VCL_MAGIC);\n\tvcl = *vclp;\n\t*vclp = NULL;\n\tassert(VTAILQ_EMPTY(&vcl->vfps));\n\tassert(VTAILQ_EMPTY(&vcl->vdps));\n\tAZ(dlclose(vcl->dlh));\n\tFREE_OBJ(vcl);\n}\n\n/*--------------------------------------------------------------------\n * NB: This function is called in/from the test-load subprocess.\n */\n\nint\nVCL_TestLoad(const char *fn)\n{\n\tstruct vsb *vsb;\n\tstruct vcl *vcl;\n\tint retval = 0;\n\n\tAN(fn);\n\tvsb = VSB_new_auto();\n\tAN(vsb);\n\tvcl = VCL_Open(fn, vsb);\n\tif (vcl == NULL) {\n\t\tAZ(VSB_finish(vsb));\n\t\tfprintf(stderr, \"%s\", VSB_data(vsb));\n\t\tretval = -1;\n\t} else\n\t\tVCL_Close(&vcl);\n\tVSB_destroy(&vsb);\n\treturn (retval);\n}\n\n/*--------------------------------------------------------------------*/\n\nstatic struct vsb *\nvcl_print_refs(const struct vcl *vcl)\n{\n\tstruct vsb *msg;\n\tstruct vclref *ref;\n\n\tCHECK_OBJ_NOTNULL(vcl, VCL_MAGIC);\n\tmsg = VSB_new_auto();\n\n\tVSB_printf(msg, \"VCL %s is waiting for:\", vcl->loaded_name);\n\tLck_Lock(&vcl_mtx);\n\tVTAILQ_FOREACH(ref, &vcl->ref_list, list)\n\t\tVSB_printf(msg, \"\\n\\t- %s\", ref->desc);\n\tLck_Unlock(&vcl_mtx);\n\tAZ(VSB_finish(msg));\n\treturn (msg);\n}\n\nstatic int\nvcl_set_state(struct vcl *vcl, const char *state, struct vsb **msg)\n{\n\tstruct vsb *nomsg = NULL;\n\tint i = 0;\n\n\tASSERT_CLI();\n\n\tCHECK_OBJ_NOTNULL(vcl, VCL_MAGIC);\n\tAN(state);\n\tAN(msg);\n\tAZ(*msg);\n\n\tAN(vcl->temp);\n\n\tswitch (state[0]) {\n\tcase '0':\n\t\tif (vcl->temp == VCL_TEMP_COLD)\n\t\t\tbreak;\n\t\tif (vcl->busy == 0 && vcl->temp->is_warm) {\n\t\t\tvcl->temp = VTAILQ_EMPTY(&vcl->ref_list) ?\n\t\t\t    VCL_TEMP_COLD : VCL_TEMP_COOLING;\n\t\t\tAZ(vcl_send_event(vcl, VCL_EVENT_COLD, msg));\n\t\t\tAZ(*msg);\n\t\t\tvcl_BackendEvent(vcl, VCL_EVENT_COLD);\n\t\t}\n\t\telse if (vcl->busy)\n\t\t\tvcl->temp = VCL_TEMP_BUSY;\n\t\telse if (VTAILQ_EMPTY(&vcl->ref_list))\n\t\t\tvcl->temp = VCL_TEMP_COLD;\n\t\telse\n\t\t\tvcl->temp = VCL_TEMP_COOLING;\n\t\tbreak;\n\tcase '1':\n\t\tif (vcl->temp == VCL_TEMP_WARM)\n\t\t\tbreak;\n\t\t/* The warm VCL hasn't seen a cold event yet */\n\t\tif (vcl->temp == VCL_TEMP_BUSY)\n\t\t\tvcl->temp = VCL_TEMP_WARM;\n\t\t/* The VCL must first reach a stable cold state */\n\t\telse if (vcl->temp == VCL_TEMP_COOLING) {\n\t\t\t*msg = vcl_print_refs(vcl);\n\t\t\ti = -1;\n\t\t}\n\t\telse {\n\t\t\tvcl->temp = VCL_TEMP_WARM;\n\t\t\ti = vcl_send_event(vcl, VCL_EVENT_WARM, msg);\n\t\t\tif (i == 0) {\n\t\t\t\tvcl_BackendEvent(vcl, VCL_EVENT_WARM);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tAZ(vcl_send_event(vcl, VCL_EVENT_COLD, &nomsg));\n\t\t\tAZ(nomsg);\n\t\t\tvcl->temp = VCL_TEMP_COLD;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tWRONG(\"Wrong enum state\");\n\t}\n\tif (i == 0 && state[1])\n\t\tbprintf(vcl->state, \"%s\", state + 1);\n\n\treturn (i);\n}\n\nstatic void\nvcl_cancel_load(struct vcl *vcl, struct cli *cli, struct vsb *msg,\n    const char *name, const char *step)\n{\n\n\tCHECK_OBJ_NOTNULL(vcl, VCL_MAGIC);\n\tCHECK_OBJ_NOTNULL(vcl->conf, VCL_CONF_MAGIC);\n\n\tVCLI_SetResult(cli, CLIS_CANT);\n\tVCLI_Out(cli, \"VCL \\\"%s\\\" Failed %s\", name, step);\n\tif (VSB_len(msg))\n\t\tVCLI_Out(cli, \"\\nMessage:\\n\\t%s\", VSB_data(msg));\n\tVSB_destroy(&msg);\n\n\tAZ(vcl_send_event(vcl, VCL_EVENT_DISCARD, &msg));\n\tAZ(msg);\n\n\tvcl_KillBackends(vcl);\n\tfree(vcl->loaded_name);\n\tVCL_Close(&vcl);\n}\n\nstatic void\nvcl_load(struct cli *cli,\n    const char *name, const char *fn, const char *state)\n{\n\tstruct vcl *vcl;\n\tstruct vsb *msg;\n\n\tASSERT_CLI();\n\n\tvcl = vcl_find(name);\n\tAZ(vcl);\n\n\tmsg = VSB_new_auto();\n\tvcl = VCL_Open(fn, msg);\n\tAZ(VSB_finish(msg));\n\tif (vcl == NULL) {\n\t\tVCLI_SetResult(cli, CLIS_PARAM);\n\t\tVCLI_Out(cli, \"%s\", VSB_data(msg));\n\t\tVSB_destroy(&msg);\n\t\treturn;\n\t}\n\n\tVSB_destroy(&msg);\n\n\tvcl->loaded_name = strdup(name);\n\tXXXAN(vcl->loaded_name);\n\tVTAILQ_INIT(&vcl->director_list);\n\tVTAILQ_INIT(&vcl->ref_list);\n\tVTAILQ_INIT(&vcl->vfps);\n\tVTAILQ_INIT(&vcl->vdps);\n\n\tvcl->temp = VCL_TEMP_INIT;\n\n\tif (vcl_send_event(vcl, VCL_EVENT_LOAD, &msg)) {\n\t\tvcl_cancel_load(vcl, cli, msg, name, \"initialization\");\n\t\treturn;\n\t}\n\tVSB_destroy(&msg);\n\n\tif (vcl_set_state(vcl, state, &msg)) {\n\t\tassert(*state == '1');\n\t\tvcl_cancel_load(vcl, cli, msg, name, \"warmup\");\n\t\treturn;\n\t}\n\tif (msg)\n\t\tVSB_destroy(&msg);\n\n\tVCLI_Out(cli, \"Loaded \\\"%s\\\" as \\\"%s\\\"\", fn , name);\n\tVTAILQ_INSERT_TAIL(&vcl_head, vcl, list);\n\tLck_Lock(&vcl_mtx);\n\tif (vcl_active == NULL)\n\t\tvcl_active = vcl;\n\tLck_Unlock(&vcl_mtx);\n\tVSC_C_main->n_vcl++;\n\tVSC_C_main->n_vcl_avail++;\n}\n\n/*--------------------------------------------------------------------*/\n\nvoid\nVCL_Poll(void)\n{\n\tstruct vsb *nomsg = NULL;\n\tstruct vcl *vcl, *vcl2;\n\n\tASSERT_CLI();\n\tVTAILQ_FOREACH_SAFE(vcl, &vcl_head, list, vcl2) {\n\t\tif (vcl->temp == VCL_TEMP_BUSY ||\n\t\t    vcl->temp == VCL_TEMP_COOLING)\n\t\t\tAZ(vcl_set_state(vcl, \"0\", &nomsg));\n\t\tAZ(nomsg);\n\t\tif (vcl->discard && vcl->temp == VCL_TEMP_COLD) {\n\t\t\tAZ(vcl->busy);\n\t\t\tassert(vcl != vcl_active);\n\t\t\tassert(VTAILQ_EMPTY(&vcl->ref_list));\n\t\t\tVTAILQ_REMOVE(&vcl_head, vcl, list);\n\t\t\tAZ(vcl_send_event(vcl, VCL_EVENT_DISCARD, &nomsg));\n\t\t\tAZ(nomsg);\n\t\t\tvcl_KillBackends(vcl);\n\t\t\tfree(vcl->loaded_name);\n\t\t\tVCL_Close(&vcl);\n\t\t\tVSC_C_main->n_vcl--;\n\t\t\tVSC_C_main->n_vcl_discard--;\n\t\t}\n\t}\n}\n\n/*--------------------------------------------------------------------*/\n\nstatic void v_matchproto_(cli_func_t)\nvcl_cli_list(struct cli *cli, const char * const *av, void *priv)\n{\n\tstruct vcl *vcl;\n\tconst char *flg;\n\tstruct vsb *vsb;\n\n\t/* NB: Shall generate same output as mcf_vcl_list() */\n\n\t(void)av;\n\t(void)priv;\n\tASSERT_CLI();\n\tvsb = VSB_new_auto();\n\tAN(vsb);\n\tVTAILQ_FOREACH(vcl, &vcl_head, list) {\n\t\tif (vcl == vcl_active) {\n\t\t\tflg = \"active\";\n\t\t} else if (vcl->discard) {\n\t\t\tflg = \"discarded\";\n\t\t} else\n\t\t\tflg = \"available\";\n\t\tVSB_printf(vsb, \"%s\\t%s\\t%s\\t%6u\\t%s\", flg, vcl->state,\n\t\t    vcl->temp->name, vcl->busy, vcl->loaded_name);\n\t\tif (vcl->label != NULL) {\n\t\t\tVSB_printf(vsb, \"\\t->\\t%s\", vcl->label->loaded_name);\n\t\t\tif (vcl->nrefs)\n\t\t\t\tVSB_printf(vsb, \" (%d return(vcl)%s)\",\n\t\t\t\t    vcl->nrefs, vcl->nrefs > 1 ? \"'s\" : \"\");\n\t\t} else if (vcl->nlabels > 0) {\n\t\t\tVSB_printf(vsb, \"\\t<-\\t(%d label%s)\",\n\t\t\t    vcl->nlabels, vcl->nlabels > 1 ? \"s\" : \"\");\n\t\t}\n\t\tVSB_printf(vsb, \"\\n\");\n\t}\n\tVCLI_VTE(cli, &vsb, 80);\n}\n\nstatic void v_matchproto_(cli_func_t)\nvcl_cli_list_json(struct cli *cli, const char * const *av, void *priv)\n{\n\tstruct vcl *vcl;\n\n\t(void)priv;\n\tASSERT_CLI();\n\tVCLI_JSON_begin(cli, 2, av);\n\tVCLI_Out(cli, \",\\n\");\n\tVTAILQ_FOREACH(vcl, &vcl_head, list) {\n\t\tVCLI_Out(cli, \"{\\n\");\n\t\tVSB_indent(cli->sb, 2);\n\t\tVCLI_Out(cli, \"\\\"status\\\": \");\n\t\tif (vcl == vcl_active) {\n\t\t\tVCLI_Out(cli, \"\\\"active\\\",\\n\");\n\t\t} else if (vcl->discard) {\n\t\t\tVCLI_Out(cli, \"\\\"discarded\\\",\\n\");\n\t\t} else\n\t\t\tVCLI_Out(cli, \"\\\"available\\\",\\n\");\n\t\tVCLI_Out(cli, \"\\\"state\\\": \\\"%s\\\",\\n\", vcl->state);\n\t\tVCLI_Out(cli, \"\\\"temperature\\\": \\\"%s\\\",\\n\", vcl->temp->name);\n\t\tVCLI_Out(cli, \"\\\"busy\\\": %u,\\n\", vcl->busy);\n\t\tVCLI_Out(cli, \"\\\"name\\\": \\\"%s\\\"\", vcl->loaded_name);\n\t\tif (vcl->label != NULL) {\n\t\t\tVCLI_Out(cli, \",\\n\");\n\t\t\tVCLI_Out(cli, \"\\\"label\\\": {\\n\");\n\t\t\tVSB_indent(cli->sb, 2);\n\t\t\t\tVCLI_Out(cli, \"\\\"name\\\": \\\"%s\\\"\",\n\t\t\t\t\t vcl->label->loaded_name);\n\t\t\tif (vcl->nrefs)\n\t\t\t\tVCLI_Out(cli, \",\\n\\\"refs\\\": %d\", vcl->nrefs);\n\t\t\tVCLI_Out(cli, \"\\n\");\n\t\t\tVCLI_Out(cli, \"}\");\n\t\t\tVSB_indent(cli->sb, -2);\n\t\t} else if (vcl->nlabels > 0) {\n\t\t\tVCLI_Out(cli, \",\\n\");\n\t\t\tVCLI_Out(cli, \"\\\"labels\\\": %d\", vcl->nlabels);\n\t\t}\n\t\tVSB_indent(cli->sb, -2);\n\t\tVCLI_Out(cli, \"\\n}\");\n\t\tif (VTAILQ_NEXT(vcl, list) != NULL)\n\t\t\tVCLI_Out(cli, \",\\n\");\n\t}\n\tVCLI_JSON_end(cli);\n}\n\nstatic void v_matchproto_(cli_func_t)\nvcl_cli_load(struct cli *cli, const char * const *av, void *priv)\n{\n\n\tAZ(priv);\n\tASSERT_CLI();\n\t// XXX move back code from vcl_load?\n\tvcl_load(cli, av[2], av[3], av[4]);\n}\n\nstatic void v_matchproto_(cli_func_t)\nvcl_cli_state(struct cli *cli, const char * const *av, void *priv)\n{\n\tstruct vcl *vcl;\n\tstruct vsb *msg = NULL;\n\n\tAZ(priv);\n\tASSERT_CLI();\n\tAN(av[2]);\n\tAN(av[3]);\n\n\tvcl = vcl_find(av[2]);\n\tAN(vcl);\n\n\tif (vcl_set_state(vcl, av[3], &msg)) {\n\t\tCHECK_OBJ_NOTNULL(msg, VSB_MAGIC);\n\n\t\tVCLI_SetResult(cli, CLIS_CANT);\n\t\tVCLI_Out(cli, \"Failed <vcl.state %s %s>\", vcl->loaded_name,\n\t\t    av[3] + 1);\n\t\tif (VSB_len(msg))\n\t\t\tVCLI_Out(cli, \"\\nMessage:\\n\\t%s\", VSB_data(msg));\n\t}\n\tif (msg)\n\t\tVSB_destroy(&msg);\n}\n\nstatic void v_matchproto_(cli_func_t)\nvcl_cli_discard(struct cli *cli, const char * const *av, void *priv)\n{\n\tstruct vcl *vcl;\n\n\tASSERT_CLI();\n\t(void)cli;\n\tAZ(priv);\n\tvcl = vcl_find(av[2]);\n\tAN(vcl);\t\t\t// MGT ensures this\n\tLck_Lock(&vcl_mtx);\n\tassert (vcl != vcl_active);\t// MGT ensures this\n\tAZ(vcl->nlabels);\t\t// MGT ensures this\n\tVSC_C_main->n_vcl_discard++;\n\tVSC_C_main->n_vcl_avail--;\n\tvcl->discard = 1;\n\tif (vcl->label != NULL) {\n\t\tAZ(strcmp(vcl->state, VCL_TEMP_LABEL->name));\n\t\tvcl->label->nlabels--;\n\t\tvcl->label= NULL;\n\t}\n\tLck_Unlock(&vcl_mtx);\n\n\tif (!strcmp(vcl->state, VCL_TEMP_LABEL->name)) {\n\t\tVTAILQ_REMOVE(&vcl_head, vcl, list);\n\t\tfree(vcl->loaded_name);\n\t\tFREE_OBJ(vcl);\n\t} else if (vcl->temp == VCL_TEMP_COLD) {\n\t\tVCL_Poll();\n\t}\n}\n\nstatic void v_matchproto_(cli_func_t)\nvcl_cli_label(struct cli *cli, const char * const *av, void *priv)\n{\n\tstruct vcl *lbl;\n\tstruct vcl *vcl;\n\n\tASSERT_CLI();\n\t(void)cli;\n\t(void)priv;\n\tvcl = vcl_find(av[3]);\n\tAN(vcl);\t\t\t\t// MGT ensures this\n\tlbl = vcl_find(av[2]);\n\tif (lbl == NULL) {\n\t\tALLOC_OBJ(lbl, VCL_MAGIC);\n\t\tAN(lbl);\n\t\tbprintf(lbl->state, \"%s\", VCL_TEMP_LABEL->name);\n\t\tlbl->temp = VCL_TEMP_WARM;\n\t\tREPLACE(lbl->loaded_name, av[2]);\n\t\tVTAILQ_INSERT_TAIL(&vcl_head, lbl, list);\n\t}\n\tif (lbl->label != NULL)\n\t\tlbl->label->nlabels--;\n\tlbl->label = vcl;\n\tvcl->nlabels++;\n}\n\nstatic void v_matchproto_(cli_func_t)\nvcl_cli_use(struct cli *cli, const char * const *av, void *priv)\n{\n\tstruct vcl *vcl;\n\n\tASSERT_CLI();\n\tAN(cli);\n\tAZ(priv);\n\tvcl = vcl_find(av[2]);\n\tAN(vcl);\t\t\t\t// MGT ensures this\n\tassert(vcl->temp == VCL_TEMP_WARM);\t// MGT ensures this\n\tLck_Lock(&vcl_mtx);\n\tvcl_active = vcl;\n\tLck_Unlock(&vcl_mtx);\n}\n\nstatic void v_matchproto_(cli_func_t)\nvcl_cli_show(struct cli *cli, const char * const *av, void *priv)\n{\n\tstruct vcl *vcl;\n\tint verbose = 0;\n\tint i;\n\n\tASSERT_CLI();\n\tAZ(priv);\n\tif (!strcmp(av[2], \"-v\") && av[3] == NULL) {\n\t\tVCLI_Out(cli, \"Too few parameters\");\n\t\tVCLI_SetResult(cli, CLIS_TOOFEW);\n\t\treturn;\n\t} else if (strcmp(av[2], \"-v\") && av[3] != NULL) {\n\t\tVCLI_Out(cli, \"Unknown options '%s'\", av[2]);\n\t\tVCLI_SetResult(cli, CLIS_PARAM);\n\t\treturn;\n\t} else if (av[3] != NULL) {\n\t\tverbose = 1;\n\t\tvcl = vcl_find(av[3]);\n\t} else\n\t\tvcl = vcl_find(av[2]);\n\n\tif (vcl == NULL) {\n\t\tVCLI_Out(cli, \"No VCL named '%s'\",\n\t\t    av[3] == NULL ? av[2] : av[3]);\n\t\tVCLI_SetResult(cli, CLIS_PARAM);\n\t\treturn;\n\t}\n\tCHECK_OBJ_NOTNULL(vcl, VCL_MAGIC);\n\tif (vcl->label) {\n\t\tvcl = vcl->label;\n\t\tCHECK_OBJ_NOTNULL(vcl, VCL_MAGIC);\n\t\tAZ(vcl->label);\n\t}\n\tCHECK_OBJ_NOTNULL(vcl->conf, VCL_CONF_MAGIC);\n\tif (verbose) {\n\t\tfor (i = 0; i < vcl->conf->nsrc; i++)\n\t\t\tVCLI_Out(cli, \"// VCL.SHOW %d %zd %s\\n%s\\n\",\n\t\t\t    i, strlen(vcl->conf->srcbody[i]),\n\t\t\t    vcl->conf->srcname[i],\n\t\t\t    vcl->conf->srcbody[i]);\n\t} else {\n\t\tVCLI_Out(cli, \"%s\", vcl->conf->srcbody[0]);\n\t}\n}\n\n/*--------------------------------------------------------------------*/\n\nstatic struct cli_proto vcl_cmds[] = {\n\t{ CLICMD_VCL_LOAD,\t\t\"\", vcl_cli_load },\n\t{ CLICMD_VCL_LIST,\t\t\"\", vcl_cli_list, vcl_cli_list_json },\n\t{ CLICMD_VCL_STATE,\t\t\"\", vcl_cli_state },\n\t{ CLICMD_VCL_DISCARD,\t\t\"\", vcl_cli_discard },\n\t{ CLICMD_VCL_USE,\t\t\"\", vcl_cli_use },\n\t{ CLICMD_VCL_SHOW,\t\t\"\", vcl_cli_show },\n\t{ CLICMD_VCL_LABEL,\t\t\"\", vcl_cli_label },\n\t{ NULL }\n};\n\nvoid\nVCL_Init(void)\n{\n\n\tassert(cache_param->workspace_client > 0);\n\tWS_Init(&ws_cli, \"cli\", malloc(cache_param->workspace_client),\n\t    cache_param->workspace_client);\n\tws_snapshot_cli = WS_Snapshot(&ws_cli);\n\tCLI_AddFuncs(vcl_cmds);\n\tLck_New(&vcl_mtx, lck_vcl);\n\tVSL_Setup(&vsl_cli, NULL, 0);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-varnish-cache-6.4.0-rypi4oyixvgpbmjahq5n45zcm4a7jnyy/spack-src/bin/varnishd/cache/cache_vrt_vmod.c": "/*-\n * Copyright (c) 2006 Verdens Gang AS\n * Copyright (c) 2006-2015 Varnish Software AS\n * All rights reserved.\n *\n * Author: Poul-Henning Kamp <phk@phk.freebsd.dk>\n *\n * SPDX-License-Identifier: BSD-2-Clause\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * Runtime support for compiled VCL programs\n */\n\n#include \"config.h\"\n\n#include \"cache_varnishd.h\"\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"vcli_serve.h\"\n#include \"vcc_interface.h\"\n#include \"vmod_abi.h\"\n\n/*--------------------------------------------------------------------\n * Modules stuff\n */\n\nstruct vmod {\n\tunsigned\t\tmagic;\n#define VMOD_MAGIC\t\t0xb750219c\n\n\tVTAILQ_ENTRY(vmod)\tlist;\n\n\tint\t\t\tref;\n\n\tchar\t\t\t*nm;\n\tunsigned\t\tnbr;\n\tchar\t\t\t*path;\n\tchar\t\t\t*backup;\n\tvoid\t\t\t*hdl;\n\tconst void\t\t*funcs;\n\tint\t\t\tfunclen;\n\tconst char\t\t*abi;\n\tunsigned\t\tvrt_major;\n\tunsigned\t\tvrt_minor;\n};\n\nstatic VTAILQ_HEAD(,vmod)\tvmods = VTAILQ_HEAD_INITIALIZER(vmods);\n\nstatic unsigned\nvmod_abi_mismatch(const struct vmod_data *d)\n{\n\n\tif (d->vrt_major == 0 && d->vrt_minor == 0)\n\t\treturn (d->abi == NULL || strcmp(d->abi, VMOD_ABI_Version));\n\n\treturn (d->vrt_major != VRT_MAJOR_VERSION ||\n\t    d->vrt_minor > VRT_MINOR_VERSION);\n}\n\nint\nVPI_Vmod_Init(VRT_CTX, struct vmod **hdl, unsigned nbr, void *ptr, int len,\n    const char *nm, const char *path, const char *file_id, const char *backup)\n{\n\tstruct vmod *v;\n\tconst struct vmod_data *d;\n\tchar buf[256];\n\tvoid *dlhdl;\n\n\tASSERT_CLI();\n\tCHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC);\n\tAN(ctx->msg);\n\tAN(hdl);\n\tAZ(*hdl);\n\n\tdlhdl = dlopen(backup, RTLD_NOW | RTLD_LOCAL);\n\tif (dlhdl == NULL) {\n\t\tVSB_printf(ctx->msg, \"Loading vmod %s from %s (%s):\\n\",\n\t\t    nm, backup, path);\n\t\tVSB_printf(ctx->msg, \"dlopen() failed: %s\\n\", dlerror());\n\t\treturn (1);\n\t}\n\n\tVTAILQ_FOREACH(v, &vmods, list)\n\t\tif (v->hdl == dlhdl)\n\t\t\tbreak;\n\tif (v == NULL) {\n\t\tALLOC_OBJ(v, VMOD_MAGIC);\n\t\tAN(v);\n\t\tREPLACE(v->backup, backup);\n\n\t\tv->hdl = dlhdl;\n\n\t\tbprintf(buf, \"Vmod_%s_Data\", nm);\n\t\td = dlsym(v->hdl, buf);\n\t\tif (d == NULL ||\n\t\t    d->file_id == NULL ||\n\t\t    strcmp(d->file_id, file_id)) {\n\t\t\tVSB_printf(ctx->msg, \"Loading vmod %s from %s (%s):\\n\",\n\t\t\t    nm, backup, path);\n\t\t\tVSB_cat(ctx->msg,\n\t\t\t    \"This is no longer the same file seen by\"\n\t\t\t    \" the VCL-compiler.\\n\");\n\t\t\t(void)dlclose(v->hdl);\n\t\t\tFREE_OBJ(v);\n\t\t\treturn (1);\n\t\t}\n\t\tif (vmod_abi_mismatch(d) ||\n\t\t    d->name == NULL ||\n\t\t    strcmp(d->name, nm) ||\n\t\t    d->func == NULL ||\n\t\t    d->func_len <= 0 ||\n\t\t    d->proto == NULL ||\n\t\t    d->json == NULL) {\n\t\t\tVSB_printf(ctx->msg, \"Loading vmod %s from %s (%s):\\n\",\n\t\t\t    nm, backup, path);\n\t\t\tVSB_cat(ctx->msg, \"VMOD data is mangled.\\n\");\n\t\t\t(void)dlclose(v->hdl);\n\t\t\tFREE_OBJ(v);\n\t\t\treturn (1);\n\t\t}\n\n\t\tv->nbr = nbr;\n\t\tv->funclen = d->func_len;\n\t\tv->funcs = d->func;\n\t\tv->abi = d->abi;\n\t\tv->vrt_major = d->vrt_major;\n\t\tv->vrt_minor = d->vrt_minor;\n\n\t\tREPLACE(v->nm, nm);\n\t\tREPLACE(v->path, path);\n\n\t\tVSC_C_main->vmods++;\n\t\tVTAILQ_INSERT_TAIL(&vmods, v, list);\n\t}\n\n\tassert(len == v->funclen);\n\tmemcpy(ptr, v->funcs, v->funclen);\n\tv->ref++;\n\n\t*hdl = v;\n\treturn (0);\n}\n\nvoid\nVPI_Vmod_Unload(struct vmod **hdl)\n{\n\tstruct vmod *v;\n\n\tASSERT_CLI();\n\n\tTAKE_OBJ_NOTNULL(v, hdl, VMOD_MAGIC);\n\n\tVCL_TaskLeave(cli_task_privs);\n\tVCL_TaskEnter(cli_task_privs);\n\n#ifndef DONT_DLCLOSE_VMODS\n\t/*\n\t * atexit(3) handlers are not called during dlclose(3).  We don't\n\t * normally use them, but we do when running GCOV.  This option\n\t * enables us to do that.\n\t */\n\tAZ(dlclose(v->hdl));\n#endif\n\tif (--v->ref != 0)\n\t\treturn;\n\tfree(v->nm);\n\tfree(v->path);\n\tfree(v->backup);\n\tVTAILQ_REMOVE(&vmods, v, list);\n\tVSC_C_main->vmods--;\n\tFREE_OBJ(v);\n}\n\nvoid\nVMOD_Panic(struct vsb *vsb)\n{\n\tstruct vmod *v;\n\n\tVSB_cat(vsb, \"vmods = {\\n\");\n\tVSB_indent(vsb, 2);\n\tVTAILQ_FOREACH(v, &vmods, list)\n\t\tVSB_printf(vsb, \"%s = {%p, %s, %u.%u},\\n\",\n\t\t    v->nm, v, v->abi, v->vrt_major, v->vrt_minor);\n\tVSB_indent(vsb, -2);\n\tVSB_cat(vsb, \"},\\n\");\n}\n\n/*---------------------------------------------------------------------*/\n\nstatic void v_matchproto_(cli_func_t)\nccf_debug_vmod(struct cli *cli, const char * const *av, void *priv)\n{\n\tstruct vmod *v;\n\n\t(void)av;\n\t(void)priv;\n\tASSERT_CLI();\n\tVTAILQ_FOREACH(v, &vmods, list)\n\t\tVCLI_Out(cli, \"%5d %s (%s)\\n\", v->ref, v->nm, v->path);\n}\n\nstatic struct cli_proto vcl_cmds[] = {\n\t{ CLICMD_DEBUG_VMOD,\t\t\t\"d\", ccf_debug_vmod },\n\t{ NULL }\n};\n\nvoid\nVMOD_Init(void)\n{\n\n\tCLI_AddFuncs(vcl_cmds);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-varnish-cache-6.4.0-rypi4oyixvgpbmjahq5n45zcm4a7jnyy/spack-src/lib/libvcc/vcc_vmod.c": "/*-\n * Copyright (c) 2010-2015 Varnish Software AS\n * All rights reserved.\n *\n * Author: Poul-Henning Kamp <phk@phk.freebsd.dk>\n *\n * SPDX-License-Identifier: BSD-2-Clause\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"config.h\"\n\n#include <dlfcn.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"vcc_compile.h\"\n\n#include \"libvcc.h\"\n#include \"vfil.h\"\n#include \"vjsn.h\"\n#include \"vmod_abi.h\"\n#include \"vsb.h\"\n\nstruct vmod_open {\n\tunsigned\t\tmagic;\n#define VMOD_OPEN_MAGIC\t\t0x9995b1f3\n\tvoid\t\t\t*hdl;\n\tconst char\t\t*err;\n};\n\nstatic int\nvcc_path_dlopen(void *priv, const char *fn)\n{\n\tstruct vmod_open *vop;\n\n\tCAST_OBJ_NOTNULL(vop, priv, VMOD_OPEN_MAGIC);\n\tAN(fn);\n\n\tvop->hdl = dlopen(fn, RTLD_NOW | RTLD_LOCAL);\n\tif (vop->hdl == NULL) {\n\t\tvop->err = dlerror();\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\nstatic void\nfunc_sym(struct symbol *sym, const char *vmod_name, const struct vjsn_val *v)\n{\n\n\tassert(v->type == VJSN_ARRAY);\n\tsym->action = vcc_Act_Call;\n\tsym->vmod_name = vmod_name;\n\tsym->eval = vcc_Eval_SymFunc;\n\tsym->eval_priv = v;\n\tv = VTAILQ_FIRST(&v->children);\n\tassert(v->type == VJSN_ARRAY);\n\tv = VTAILQ_FIRST(&v->children);\n\tassert(v->type == VJSN_STRING);\n\tsym->type = VCC_Type(v->value);\n\tAN(sym->type);\n}\n\nstatic void\nvcc_json_always(struct vcc *tl, const struct vjsn *vj, const char *vmod_name)\n{\n\tstruct inifin *ifp;\n\tconst struct vjsn_val *vv, *vv2;\n\tdouble vmod_syntax = 0.0;\n\n\tAN(vj);\n\tAN(vmod_name);\n\tifp = NULL;\n\n\tVTAILQ_FOREACH(vv, &vj->value->children, list) {\n\t\tassert(vv->type == VJSN_ARRAY);\n\t\tvv2 = VTAILQ_FIRST(&vv->children);\n\t\tassert(vv2->type == VJSN_STRING);\n\t\tif (!strcmp(vv2->value, \"$VMOD\")) {\n\t\t\tvmod_syntax =\n\t\t\t    strtod(VTAILQ_NEXT(vv2, list)->value, NULL);\n\t\t\tcontinue;\n\t\t}\n\t\tassert (vmod_syntax == 1.0);\n\t\tif (!strcmp(vv2->value, \"$EVENT\")) {\n\t\t\t/* XXX: What about the rest of the events ? */\n\t\t\tif (ifp == NULL)\n\t\t\t\tifp = New_IniFin(tl);\n\t\t\tvv2 = VTAILQ_NEXT(vv2, list);\n\t\t\tVSB_printf(ifp->ini,\n\t\t\t    \"\\tif (%s(ctx, &vmod_priv_%s, VCL_EVENT_LOAD))\\n\"\n\t\t\t    \"\\t\\treturn(1);\",\n\t\t\t    vv2->value, vmod_name);\n\t\t\tVSB_printf(ifp->fin,\n\t\t\t    \"\\t\\t(void)%s(ctx, &vmod_priv_%s,\\n\"\n\t\t\t    \"\\t\\t\\t    VCL_EVENT_DISCARD);\",\n\t\t\t    vv2->value, vmod_name);\n\t\t\tVSB_printf(ifp->event, \"%s(ctx, &vmod_priv_%s, ev)\",\n\t\t\t    vv2->value, vmod_name);\n\t\t} else if (!strcmp(vv2->value, \"$FUNC\")) {\n\t\t} else if (!strcmp(vv2->value, \"$OBJ\")) {\n\t\t} else {\n\t\t\tVTAILQ_FOREACH(vv2, &vv->children, list)\n\t\t\t\tfprintf(stderr, \"\\tt %s n %s v %s\\n\",\n\t\t\t\t    vv2->type, vv2->name, vv2->value);\n\t\t\tWRONG(\"Vmod JSON syntax error\");\n\t\t}\n\t}\n}\n\nstatic void v_matchproto_(sym_wildcard_t)\nvcc_json_wildcard(struct vcc *tl, struct symbol *msym, struct symbol *tsym)\n{\n\tconst struct vjsn *vj;\n\tconst struct vjsn_val *vv, *vv1, *vv2;\n\n\tassert(msym->kind == SYM_VMOD);\n\tCAST_OBJ_NOTNULL(vj, msym->eval_priv, VJSN_MAGIC);\n\tVTAILQ_FOREACH(vv, &vj->value->children, list) {\n\t\tassert(vv->type == VJSN_ARRAY);\n\t\tvv1 = VTAILQ_FIRST(&vv->children);\n\t\tassert(vv1->type == VJSN_STRING);\n\t\tvv2 = VTAILQ_NEXT(vv1, list);\n\t\tassert(vv2->type == VJSN_STRING);\n\t\tif (!strcmp(vv1->value, \"$FUNC\") &&\n\t\t    !strcmp(vv2->value, tsym->name)) {\n\t\t\ttsym->kind = SYM_FUNC;\n\t\t\ttsym->noref = 1;\n\t\t\tfunc_sym(tsym, msym->vmod_name, VTAILQ_NEXT(vv2, list));\n\t\t\treturn;\n\t\t} else if (!strcmp(vv1->value, \"$OBJ\") &&\n\t\t\t   !strcmp(vv2->value, tsym->name)) {\n\t\t\ttsym->kind = SYM_OBJECT;\n\t\t\ttsym->eval_priv = vv2;\n\t\t\ttsym->vmod_name = msym->vmod_name;\n\t\t\treturn;\n\t\t}\n\t}\n\ttl->err = 1;\n}\n\nstatic const struct vmod_data *\nvcc_VmodSanity(struct vcc *tl, void *hdl, struct token *mod, char *fnp)\n{\n\tchar buf[256];\n\tconst struct vmod_data *vmd;\n\n\tbprintf(buf, \"Vmod_%.*s_Data\", PF(mod));\n\tvmd = dlsym(hdl, buf);\n\tif (vmd == NULL) {\n\t\tVSB_printf(tl->sb, \"Malformed VMOD %.*s\\n\", PF(mod));\n\t\tVSB_printf(tl->sb, \"\\tFile name: %s\\n\", fnp);\n\t\tVSB_cat(tl->sb, \"\\t(no Vmod_Data symbol)\\n\");\n\t\tvcc_ErrWhere(tl, mod);\n\t\treturn (NULL);\n\t}\n\tif (vmd->vrt_major == 0 && vmd->vrt_minor == 0 &&\n\t    (vmd->abi == NULL || strcmp(vmd->abi, VMOD_ABI_Version) != 0)) {\n\t\tVSB_printf(tl->sb, \"Incompatible VMOD %.*s\\n\", PF(mod));\n\t\tVSB_printf(tl->sb, \"\\tFile name: %s\\n\", fnp);\n\t\tVSB_printf(tl->sb, \"\\tABI mismatch, expected <%s>, got <%s>\\n\",\n\t\t\t   VMOD_ABI_Version, vmd->abi);\n\t\tvcc_ErrWhere(tl, mod);\n\t\treturn (NULL);\n\t}\n\tif (vmd->vrt_major != 0 && (vmd->vrt_major != VRT_MAJOR_VERSION ||\n\t    vmd->vrt_minor > VRT_MINOR_VERSION)) {\n\t\tVSB_printf(tl->sb, \"Incompatible VMOD %.*s\\n\", PF(mod));\n\t\tVSB_printf(tl->sb, \"\\tFile name: %s\\n\", fnp);\n\t\tVSB_printf(tl->sb, \"\\tVMOD wants ABI version %u.%u\\n\",\n\t\t    vmd->vrt_major, vmd->vrt_minor);\n\t\tVSB_printf(tl->sb, \"\\tvarnishd provides ABI version %u.%u\\n\",\n\t\t    VRT_MAJOR_VERSION, VRT_MINOR_VERSION);\n\t\tvcc_ErrWhere(tl, mod);\n\t\treturn (NULL);\n\t}\n\tif (vmd->name == NULL ||\n\t    vmd->func == NULL ||\n\t    vmd->func_len <= 0 ||\n\t    vmd->proto == NULL ||\n\t    vmd->abi == NULL) {\n\t\tVSB_printf(tl->sb, \"Mangled VMOD %.*s\\n\", PF(mod));\n\t\tVSB_printf(tl->sb, \"\\tFile name: %s\\n\", fnp);\n\t\tVSB_cat(tl->sb, \"\\tInconsistent metadata\\n\");\n\t\tvcc_ErrWhere(tl, mod);\n\t\treturn (NULL);\n\t}\n\tif (!vcc_IdIs(mod, vmd->name)) {\n\t\tVSB_printf(tl->sb, \"Wrong file for VMOD %.*s\\n\", PF(mod));\n\t\tVSB_printf(tl->sb, \"\\tFile name: %s\\n\", fnp);\n\t\tVSB_printf(tl->sb, \"\\tContains vmod \\\"%s\\\"\\n\", vmd->name);\n\t\tvcc_ErrWhere(tl, mod);\n\t\treturn (NULL);\n\t}\n\treturn (vmd);\n}\n\nvoid\nvcc_ParseImport(struct vcc *tl)\n{\n\tchar fn[1024], *fnpx;\n\tconst char *p;\n\tstruct token *mod, *tmod, *t1;\n\tstruct inifin *ifp;\n\tstruct symbol *msym, *vsym;\n\tconst struct vmod_data *vmd;\n\tstruct vjsn *vj;\n\tstruct vmod_open vop[1];\n\n\tINIT_OBJ(vop, VMOD_OPEN_MAGIC);\n\tt1 = tl->t;\n\tSkipToken(tl, ID);\t\t/* \"import\" */\n\n\tExpectErr(tl, ID);\t\t/* \"vmod_name\" */\n\tmod = tl->t;\n\ttmod = VTAILQ_NEXT(mod, list);\n\tif (tmod->tok == ID && vcc_IdIs(tmod, \"as\")) {\n\t\tvcc_NextToken(tl);\t\t/* \"vmod_name\" */\n\t\tvcc_NextToken(tl);\t\t/* \"as\" */\n\t\tExpectErr(tl, ID);\t\t/* \"vcl_name\" */\n\t}\n\ttmod = tl->t;\n\n\tmsym = VCC_SymbolGet(tl, SYM_VMOD, SYMTAB_CREATE, XREF_NONE);\n\tERRCHK(tl);\n\tAN(msym);\n\n\tif (tl->t->tok == ID) {\n\t\tif (!vcc_IdIs(tl->t, \"from\")) {\n\t\t\tVSB_cat(tl->sb, \"Expected 'from path ...'\\n\");\n\t\t\tvcc_ErrWhere(tl, tl->t);\n\t\t\treturn;\n\t\t}\n\t\tvcc_NextToken(tl);\n\t\tif (!tl->unsafe_path && strchr(tl->t->dec, '/')) {\n\t\t\tVSB_cat(tl->sb,\n\t\t\t    \"'import ... from path ...' is unsafe.\\nAt:\");\n\t\t\tvcc_ErrToken(tl, tl->t);\n\t\t\tvcc_ErrWhere(tl, tl->t);\n\t\t\treturn;\n\t\t}\n\t\tExpectErr(tl, CSTR);\n\t\tp = strrchr(tl->t->dec, '/');\n\t\tif (p != NULL && p[1] == '\\0')\n\t\t\tbprintf(fn, \"%slibvmod_%.*s.so\", tl->t->dec, PF(mod));\n\t\telse\n\t\t\tbprintf(fn, \"%s\", tl->t->dec);\n\t\tvcc_NextToken(tl);\n\t} else {\n\t\tbprintf(fn, \"libvmod_%.*s.so\", PF(mod));\n\t}\n\n\tSkipToken(tl, ';');\n\n\tif (VFIL_searchpath(tl->vmod_path, vcc_path_dlopen, vop, fn, &fnpx)) {\n\t\tif (vop->err == NULL) {\n\t\t\tVSB_printf(tl->sb,\n\t\t\t    \"Could not find VMOD %.*s\\n\", PF(mod));\n\t\t} else {\n\t\t\tVSB_printf(tl->sb,\n\t\t\t    \"Could not open VMOD %.*s\\n\", PF(mod));\n\t\t\tVSB_printf(tl->sb, \"\\tFile name: %s\\n\",\n\t\t\t    fnpx != NULL ? fnpx : fn);\n\t\t\tVSB_printf(tl->sb, \"\\tdlerror: %s\\n\", vop->err);\n\t\t}\n\t\tvcc_ErrWhere(tl, mod);\n\t\tfree(fnpx);\n\t\treturn;\n\t}\n\n\tvmd = vcc_VmodSanity(tl, vop->hdl, mod, fnpx);\n\tif (vmd == NULL || tl->err) {\n\t\tAZ(dlclose(vop->hdl));\n\t\tfree(fnpx);\n\t\treturn;\n\t}\n\n\tif (msym->extra != NULL) {\n\t\tif (!strcmp(msym->extra, vmd->file_id)) {\n\t\t\t/* Identical import is OK */\n\t\t} else {\n\t\t\tVSB_printf(tl->sb,\n\t\t\t    \"Another module already imported as %.*s.\\n\",\n\t\t\t    PF(tmod));\n\t\t\tvcc_ErrWhere2(tl, t1, tl->t);\n\t\t}\n\t\tAZ(dlclose(vop->hdl));\n\t\tfree(fnpx);\n\t\treturn;\n\t}\n\tmsym->def_b = t1;\n\tmsym->def_e = tl->t;\n\n\tVTAILQ_FOREACH(vsym, &tl->sym_vmods, sideways) {\n\t\tassert(vsym->kind == SYM_VMOD);\n\t\tif (!strcmp(vsym->extra, vmd->file_id)) {\n\t\t\t/* Already loaded under different name */\n\t\t\tmsym->eval_priv = vsym->eval_priv;\n\t\t\tmsym->wildcard = vsym->wildcard;\n\t\t\tmsym->extra = vsym->extra;\n\t\t\tmsym->vmod_name = vsym->vmod_name;\n\t\t\tAZ(dlclose(vop->hdl));\n\t\t\tfree(fnpx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tVTAILQ_INSERT_TAIL(&tl->sym_vmods, msym, sideways);\n\n\tifp = New_IniFin(tl);\n\n\tVSB_cat(ifp->ini, \"\\tif (VPI_Vmod_Init(ctx,\\n\");\n\tVSB_printf(ifp->ini, \"\\t    &VGC_vmod_%.*s,\\n\", PF(mod));\n\tVSB_printf(ifp->ini, \"\\t    %u,\\n\", tl->vmod_count++);\n\tVSB_printf(ifp->ini, \"\\t    &%s,\\n\", vmd->func_name);\n\tVSB_printf(ifp->ini, \"\\t    sizeof(%s),\\n\", vmd->func_name);\n\tVSB_printf(ifp->ini, \"\\t    \\\"%.*s\\\",\\n\", PF(mod));\n\tVSB_cat(ifp->ini, \"\\t    \");\n\tVSB_quote(ifp->ini, fnpx, -1, VSB_QUOTE_CSTR);\n\tVSB_cat(ifp->ini, \",\\n\");\n\tAN(vmd);\n\tAN(vmd->file_id);\n\tVSB_printf(ifp->ini, \"\\t    \\\"%s\\\",\\n\", vmd->file_id);\n\tVSB_printf(ifp->ini, \"\\t    \\\"./vmod_cache/_vmod_%.*s.%s\\\"\\n\",\n\t    PF(mod), vmd->file_id);\n\tVSB_cat(ifp->ini, \"\\t    ))\\n\");\n\tVSB_cat(ifp->ini, \"\\t\\treturn(1);\");\n\n\tVSB_cat(tl->symtab, \",\\n    {\\n\");\n\tVSB_cat(tl->symtab, \"\\t\\\"dir\\\": \\\"import\\\",\\n\");\n\tVSB_cat(tl->symtab, \"\\t\\\"type\\\": \\\"$VMOD\\\",\\n\");\n\tVSB_printf(tl->symtab, \"\\t\\\"name\\\": \\\"%.*s\\\",\\n\", PF(mod));\n\tVSB_printf(tl->symtab, \"\\t\\\"file\\\": \\\"%s\\\",\\n\", fnpx);\n\tVSB_printf(tl->symtab, \"\\t\\\"dst\\\": \\\"./vmod_cache/_vmod_%.*s.%s\\\"\\n\",\n\t    PF(mod), vmd->file_id);\n\tVSB_cat(tl->symtab, \"    }\");\n\n\t/* XXX: zero the function pointer structure ?*/\n\tVSB_printf(ifp->fin, \"\\t\\tVRT_priv_fini(&vmod_priv_%.*s);\", PF(mod));\n\tVSB_printf(ifp->final, \"\\t\\tVPI_Vmod_Unload(&VGC_vmod_%.*s);\", PF(mod));\n\n\tvj = vjsn_parse(vmd->json, &p);\n\tXXXAZ(p);\n\tAN(vj);\n\tmsym->eval_priv = vj;\n\tmsym->wildcard = vcc_json_wildcard;\n\tmsym->extra = TlDup(tl, vmd->file_id);\n\tmsym->vmod_name = TlDup(tl, vmd->name);\n\n\tvcc_json_always(tl, vj, msym->vmod_name);\n\n\tFh(tl, 0, \"\\n/* --- BEGIN VMOD %.*s --- */\\n\\n\", PF(mod));\n\tFh(tl, 0, \"static struct vmod *VGC_vmod_%.*s;\\n\", PF(mod));\n\tFh(tl, 0, \"static struct vmod_priv vmod_priv_%.*s;\\n\", PF(mod));\n\tFh(tl, 0, \"\\n%s\\n\", vmd->proto);\n\tFh(tl, 0, \"\\n/* --- END VMOD %.*s --- */\\n\\n\", PF(mod));\n\tfree(fnpx);\n}\n\nvoid v_matchproto_(sym_act_f)\nvcc_Act_New(struct vcc *tl, struct token *t, struct symbol *sym)\n{\n\tstruct symbol *isym, *osym, *msym;\n\tstruct inifin *ifp;\n\tstruct vsb *buf;\n\tconst struct vjsn_val *vv, *vf;\n\tint null_ok = 0;\n\n\t(void)sym;\n\t(void)t;\n\n\tExpectErr(tl, ID);\n\tvcc_ExpectVid(tl, \"VCL object\");\n\tERRCHK(tl);\n\tisym = VCC_HandleSymbol(tl, INSTANCE, \"vo\");\n\tERRCHK(tl);\n\tAN(isym);\n\tisym->noref = 1;\n\n\tSkipToken(tl, '=');\n\tExpectErr(tl, ID);\n\tosym = VCC_SymbolGet(tl, SYM_OBJECT, SYMTAB_EXISTING, XREF_NONE);\n\tERRCHK(tl);\n\tAN(osym);\n\tCAST_OBJ_NOTNULL(vv, osym->eval_priv, VJSN_VAL_MAGIC);\n\t// vv = object name\n\n\tvv = VTAILQ_NEXT(vv, list);\n\t// vv = flags\n\tassert(vv->type == VJSN_OBJECT);\n\tVTAILQ_FOREACH(vf, &vv->children, list)\n\t\tif (!strcmp(vf->name, \"NULL_OK\") && vf->type == VJSN_TRUE)\n\t\t\tnull_ok = 1;\n\tif (!null_ok)\n\t\tVTAILQ_INSERT_TAIL(&tl->sym_objects, isym, sideways);\n\n\tvv = VTAILQ_NEXT(vv, list);\n\t// vv = struct name\n\n\tFh(tl, 0, \"static %s *%s;\\n\\n\", vv->value, isym->rname);\n\tvv = VTAILQ_NEXT(vv, list);\n\n\tvf = VTAILQ_FIRST(&vv->children);\n\tvv = VTAILQ_NEXT(vv, list);\n\tassert(vf->type == VJSN_STRING);\n\tassert(!strcmp(vf->value, \"$INIT\"));\n\n\tvf = VTAILQ_NEXT(vf, list);\n\n\tbuf = VSB_new_auto();\n\tAN(buf);\n\tVSB_printf(buf, \"&%s, \\\"%s\\\"\", isym->rname, isym->name);\n\tAZ(VSB_finish(buf));\n\tvcc_Eval_Func(tl, vf, VSB_data(buf), osym);\n\tVSB_destroy(&buf);\n\tERRCHK(tl);\n\tSkipToken(tl, ';');\n\tisym->def_e = tl->t;\n\n\tvf = VTAILQ_FIRST(&vv->children);\n\tvv = VTAILQ_NEXT(vv, list);\n\tassert(vf->type == VJSN_STRING);\n\tassert(!strcmp(vf->value, \"$FINI\"));\n\n\tvf = VTAILQ_NEXT(vf, list);\n\tvf = VTAILQ_FIRST(&vf->children);\n\tvf = VTAILQ_NEXT(vf, list);\n\tifp = New_IniFin(tl);\n\tVSB_printf(ifp->fin, \"\\t\\tif (%s)\\n\", isym->rname);\n\tVSB_printf(ifp->fin, \"\\t\\t\\t\\t%s(&%s);\", vf->value, isym->rname);\n\n\t/* Instantiate symbols for the methods */\n\tbuf = VSB_new_auto();\n\tAN(buf);\n\n\twhile (vv != NULL) {\n\t\tvf = VTAILQ_FIRST(&vv->children);\n\t\tassert(vf->type == VJSN_STRING);\n\t\tassert(!strcmp(vf->value, \"$METHOD\"));\n\t\tvf = VTAILQ_NEXT(vf, list);\n\t\tassert(vf->type == VJSN_STRING);\n\n\t\tVSB_clear(buf);\n\t\tVSB_printf(buf, \"%s.%s\", isym->name, vf->value);\n\t\tAZ(VSB_finish(buf));\n\t\tmsym = VCC_MkSym(tl, VSB_data(buf), SYM_FUNC, VCL_LOW, VCL_HIGH);\n\t\tAN(msym);\n\t\tfunc_sym(msym, osym->vmod_name, VTAILQ_NEXT(vf, list));\n\t\tmsym->extra = isym->rname;\n\t\tvv = VTAILQ_NEXT(vv, list);\n\t}\n\tVSB_destroy(&buf);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-varnish-cache-6.4.0-rypi4oyixvgpbmjahq5n45zcm4a7jnyy/spack-src/doc/changes.rst": "===================\nAbout this document\n===================\n\n.. keep this section at the top!\n\nThis document contains notes from the Varnish developers about ongoing\ndevelopment and past versions:\n\n* Developers will note here changes which they consider particularly\n  relevant or otherwise noteworthy\n\n* This document is not necessarily up-to-date with the code\n\n* It serves as a basis for release managers and others involved in\n  release documentation\n\n* It is not rendered as part of the official documentation and thus\n  only available in ReStructuredText (rst) format in the source\n  repository and -distribution.\n\nOfficial information about changes in releases and advise on the\nupgrade process can be found in the ``doc/sphinx/whats-new/``\ndirectory, also available in HTML format at\nhttp://varnish-cache.org/docs/trunk/whats-new/index.html and via\nindividual releases. These documents are updated as part of the\nrelease process.\n\n================================\nVarnish Cache 6.4.0 (2019-09-16)\n================================\n\n* The ``MAIN.sess_drop`` counter is gone.\n\n* New configure switch: --with-unwind. Alpine linux appears to offer a\n  ``libexecinfo`` implementation that crashes when called by Varnish, this\n  offers the alternative of using ``libunwind`` instead.\n\n* backend ``none`` was added for \"no backend\".\n\n* ``std.rollback(bereq)`` is now safe to use, fixed bug 3009_\n\n* Fixed ``varnishstat``, ``varnishtop``, ``varnishhist`` and\n  ``varnishadm`` handling INT, TERM and HUP signals (bugs 3088_ and\n  3229_)\n\n* The hash algorithm of the ``hash`` director was changed, so backend\n  selection will change once only when upgrading. Users of the\n  ``hash`` director are advised to consider using the ``shard``\n  director, which, amongst other advantages, offers more stable\n  backend selection through consistent hashing.\n\n* Log records can safely have empty fields or fields containing blanks if\n  they are delimited by \"double quotes\". This was applied to ``SessError``\n  and ``Backend_health``.\n\n* It is now possible for VMOD authors to customize the connection pooling\n  of a dynamic backend. A hash is now computed to determine uniqueness and\n  a backend declaration can contribute arbitrary data to influence the pool.\n\n* The option ``varnishtest -W`` is gone, the same can be achieved with\n  ``varnishtest -p debug=+witness``. A ``witness.sh`` script is available\n  in the source tree to generate a graphviz dot file and detect potential\n  lock cycles from the test logs.\n\n* The ``Process`` timestamp for ``vcl_synth {}`` was wrongly issued\n  before the VCL subroutine, now it gets emitted after VCL returns for\n  consistency with ``vcl_deliver {}``.\n\n* Latencies for newly created worker threads to start work on\n  congested systems have been improved.\n\n* ``VRB_Iterate()`` signature has changed\n\n* ``VRT_fail()`` now also works from director code\n\n* Deliberately closing backend requests through ``return(abandon)``,\n  ``return(fail)`` or ``return(error)`` is no longer accounted as a\n  fetch failure\n\n* Fixed a bug which could cause probes not to run\n\n* The ``if-range`` header is now handled, allowing clients to conditionally\n  request a range based on a date or an ETag.\n\n* Introduced ``struct reqtop`` to hold information on the ESI top\n  request and ``PRIV_TOP``, fixed regression 3019_\n\n* Allow numerical expressions in VCL to be negative / negated\n\n* Add vi-stype CTRL-f / CTRL-b for page down/up to interactive\n  varnishstat\n\n* Fixed wrong handling of an out-of-workspae condition in the proxy\n  vmod and in the workspace allocator, bug 3131_\n\n* Raised the minimum for the ``vcl_cooldown`` parameter to 1s to fix\n  bug 3135_\n\n* Improved creation of additional threads when none are available\n\n* Fixed a race between director creation and the ``backend.list`` CLI\n  command - see bug 3094_\n\n* Added error handling to avoid panics for workspace overflows during\n  session attribute allocation - bug 3145_\n\n* Overloaded the ``+=`` operator to also append to headers\n\n* Fixed set ``*.body`` commands.\n\n* Fixed status for truncated CLI responses, bug 3038_\n\n* New or improved Coccinelle semantic patches that may be useful for\n  VMOD or utilities authors.\n\n* Output VCC warnings also for VCLs loaded via the ``varnishd -f``\n  option, see bug 3160_\n\n* Improved fetch error handling when stale objects are present in\n  cache, see bug 3089_\n\n* Added a ``Notice`` VSL tag (used for ``varnishlog`` logging)\n\n* Always refer to ``sub`` as subroutine in the documentation and error\n  messages to avoid confusion with other terms.\n\n* New ``pid`` command in the Varnish CLI, to get the master and optionally\n  cache process PIDs, for example from ``varnishadm``.\n\n* Fixed a race that could result in a partial response being served in its\n  entirety when it is also compressed with gzip.\n\n* Fixed session close reason reporting and accounting, added ``rx_close_idle``\n  counter for separate accounting when ``timeout_idle`` is reached. Also,\n  ``send_timeout`` is no longer reported as \"remote closed\".\n\n* Fixed handling of request bodies for backend retries\n\n* Fix deadlocks when the maximum number of threads has been reached,\n  in particular with http/2, see 2418_\n\n* Add more vcl control over timeouts with ``sess.timeout_linger``,\n  ``sess.send_timeout`` and ``sess.idle_send_timeout``\n\n* Fix panics due to missing EINVAL handling on MacOS, see 1853_\n\n* Added ``VSLs()`` and ``VSLbs()`` functions for logging ``STRANDS`` to\n  VSL\n\n* Fixed cases where a workspace overflow would not result in a VCL\n  failure, see 3194_\n\n* Added ``WS_VSB_new()`` / ``WS_VSB_finish()`` for VSBs on workspaces\n\n* Imported ``vmod_cookie`` from `varnish_modules`_\n\n  The previously deprecated function ``cookie.filter_except()`` has\n  been removed during import. It was replaced by ``cookie.keep()``\n\n* ``body_status`` and ``req_body_status`` have been collapsed into one\n  type. In particular, the ``REQ_BODY_*`` enums now have been replaced\n  with ``BS_*``.\n\n.. mention VSB_QUOTE_GLOB ?\n\n* Fixed an old regression of the ``Age:`` header for passes, see bug\n  3221_\n\n* Added ``VRT_AllocStrandsWS()`` as a utility function to allocate\n  STRANDS on a workspace.\n\n* Reduced compile time of ``vcl_init{}`` / ``vcl_fini{}`` with gcc,\n  added ``v_dont_optimize`` attribute macro\n\n* Fixed a case where ``send_timeout`` would have no effect when\n  streaming from a backend fetch, see bug 3189_\n\n  *NOTE* Users upgrading varnish should re-check ``send_timeout`` with\n  respect to long pass and streaming fetches and watch out for\n  increased session close rates.\n\n* Added ``VSB_tofile()`` to ``libvarnishapi``, see 3238_\n\n.. _1853: https://github.com/varnishcache/varnish-cache/issues/1853\n.. _2418: https://github.com/varnishcache/varnish-cache/issues/2418\n.. _3009: https://github.com/varnishcache/varnish-cache/issues/3009\n.. _3019: https://github.com/varnishcache/varnish-cache/issues/3019\n.. _3038: https://github.com/varnishcache/varnish-cache/issues/3038\n.. _3088: https://github.com/varnishcache/varnish-cache/issues/3088\n.. _3089: https://github.com/varnishcache/varnish-cache/issues/3089\n.. _3094: https://github.com/varnishcache/varnish-cache/issues/3094\n.. _3131: https://github.com/varnishcache/varnish-cache/issues/3131\n.. _3135: https://github.com/varnishcache/varnish-cache/issues/3135\n.. _3145: https://github.com/varnishcache/varnish-cache/issues/3145\n.. _3160: https://github.com/varnishcache/varnish-cache/issues/3160\n.. _3189: https://github.com/varnishcache/varnish-cache/issues/3189\n.. _3194: https://github.com/varnishcache/varnish-cache/issues/3194\n.. _3221: https://github.com/varnishcache/varnish-cache/issues/3221\n.. _3229: https://github.com/varnishcache/varnish-cache/issues/3229\n.. _3238: https://github.com/varnishcache/varnish-cache/issues/3238\n.. _varnish_modules: https://github.com/varnish/varnish-modules\n\n================================\nVarnish Cache 6.3.0 (2019-09-15)\n================================\n\nIn addition to a significant number of bug fixes, these are the most\nimportant changes in 6.3:\n\n* The Host: header is folded to lower-case in the builtin_vcl.\n\n* Improved performance of shared memory statistics counters.\n\n* Synthetic objects created from ``vcl_backend_error {}`` now replace\n  existing stale objects as ordinary backend fetches would, unless:\n\n  - abandoning the bereq or\n\n  - leaving ``vcl_backend_error {}`` with ``return (deliver) and\n    ``beresp.ttl == 0s`` or\n\n  - there is a waitinglist on the object, in which case, by default,\n    the synthetic object is created with ``ttl = 1s`` / ``grace = 5s``\n    / ``keep = 5s`` avoid hammering on failing backends\n    (note this is existing behavior).\n\n* Retired the ``BackendStart`` log tag - ``BackendOpen`` contains all\n  the information from it\n\nAPIs / VMODs\n------------\n\n* ``WS_Reserve()`` is now deprecated and any use should trigger a\n  compiler warning. It is to be replaced by\n\n  - ``WS_ReserveAll()`` to reserve all of the remaining workspace\n\n    It will always leave the workspace reserved even if 0 bytes are\n    available, so it must always be followed by a call to\n    ``WS_Release()``\n\n  - ``WS_ReserveSize()`` to reserve a fixed amount.\n\n    It will only leave the workspace reserved if the reservation\n    request could be fulfilled.\n\n  We provide a script to help automate this change in the\n  ``tools/coccinelle`` subdirectory of the source tree.\n\n* The RST references generated by ``vmodtool.py`` have been changed to\n  match better the VCL syntax to avoid overhead where references are\n  used. The new scheme for a vmod called *name* is:\n\n  * ``$Function``: *name*\\ .\\ *function*\\ ()\n  * ``$Object`` constructor: *name*\\ .\\ *object*\\ ()\n  * ``$Method``: x\\ *object*\\ .\\ *method*\\ ()\n\n  To illustrate, the old references::\n\n    :ref:`vmod_name.function`\n    :ref:`vmod_name.obj`\n    :ref:`vmod_name.obj.method`\n\n  now are renamed to::\n\n    :ref:`name.function()`\n    :ref:`name.obj()`\n    :ref:`xobj.method()`\n\n  ``tools/vmod_ref_rename.sh`` is provided to automate this task\n\n================================\nVarnish Cache 6.2.0 (2019-03-15)\n================================\n\n* Extend JSON support in the CLI (2783_)\n\n* Improve accuracy of statistics (VSC)\n\n* In ``Error: out of workspace`` log entries, the workspace name is\n  now reported in lowercase\n\n* Adjust code generator python tools to python 3 and prefer python 3\n  over python 2 where available\n\n* Added a thread pool watchdog which will restart the worker process\n  if scheduling tasks onto worker threads appears stuck. The new\n  parameter ``thread_pool_watchdog`` configures it. (2418_)\n\n* Changed ``ExpKill`` log tags to emit microsecond-precision\n  timestamps instead of nanoseconds (2792_)\n\n* Changed the default of the ``thread_pool_watchdog`` parameter\n  to 60 seconds to match the ``cli_timeout`` default\n\n* VSB quoted output has been unified to three-digit octal,\n  VSB_QUOTE_ESCHEX has been added to prefer hex over octal quoting\n\n* Retired long deprecated parameters (VIP16_). Replacement mapping is:\n  ``shm_reclen`` -> ``vsl_reclen``\n  ``vcl_dir`` -> ``vcl_path``\n  ``vmod_dir`` -> ``vmod_path``\n\n* The width of the columns of the ``backend.list`` cli command output\n  is now dynamic.\n\n  For best forward compatibility, we recommend that scripts parse JSON\n  output as obtained using the ``-j`` option.\n\n  See release notes for details.\n\n* The format of the ``backend.list -j`` (JSON) cli command output has\n  changed.\n\n  See release notes for details.\n\n* The undocumented ``-v`` option to the ``backend.list`` cli command\n  has been removed\n\n* Changed the formatting of the ``vcl.list`` command from::\n\n    status\tstate/temperature\tbusy\tname\t[labelinfo]\n\n  to::\n\n    status\tstate\ttemperature\tbusy\tname\t[<-|->]\t[info]\n\n  Column width is now dynamic.\n\n  Field values remain unchanged except for the label information, see\n  varnish-cli(7) for details.\n\n* The ban facility has been extended by bans access to obj.ttl,\n  obj.age, obj.grace and obj.keep and additional inequality operators.\n\n* Many cache lookup optimizations.\n\n* Display the VCL syntax during a panic.\n\n* Update to the VCL diagrams to include hit-for-miss.\n\nVCL\n---\n\n* Added ``req.is_hitmiss`` and ``req.is_hitpass`` (2743_)\n\n\nbundled vmods\n-------------\n\n* Added ``directors.lookup()``\n\nbundled tools\n-------------\n\n* Improved varnish log client performance (2788_)\n\n* For ``varnishtest -L``, also keep VCL C source files\n\n* Add ``param.reset`` command to ``varnishadm``\n\n* Add VSL rate limiting (2837_)\n\n  This adds rate limiting to varnishncsa and varnishlog.\n\n* Make it possible to change ``varnishstat`` update rate. (2741_)\n\nC APIs (for vmod and utility authors)\n-------------------------------------\n\n* ``libvarnish``: ``VRT_VSA_GetPtr`` renamed to ``VSA_GetPtr``\n\n* Included ``vtree.h`` in the distribution for vmods and\n  renamed the red/black tree macros from ``VRB_*`` to ``VRBT_*``\n  to disambiguate from the acronym for Varnish Request Body.\n\n  Changed the internal organisation of dynamic PRIVs (``PRIV_TASK``,\n  ``PRIV_TOP`` from a list to a red/black tree) for performance.\n  (2813_)\n\n* Vmod developers are advised that anything returned by a vmod\n  function/method is assumed to be immutable. In other words, a vmod\n  `must not` modify any data which was previously returned.\n\n* Tolerate null IP addresses for ACL matches.\n\n* Added ``vstrerror()`` as a safe wrapper for ``strerror()`` to avoid\n  a NULL pointer dereference under rare conditions where the latter\n  could return NULL. (2815_)\n\n* Varnish-based tools using the VUT interface should now consider\n  using the ``VUT_Usage()`` function for consistency\n\n* The name of the `event_function` callback for VCL events in vmods is\n  now prefixed by `$Prefix`\\ ``_``\\ ` if `$Prefix` is defined in the\n  ``.vcc`` file, or ``vmod_`` by default.\n\n  So, for example, with ``$Event foo`` and no `$Prefix`, the event\n  function will be called ``vmod_foo`` and with ``$Prefix bar`` it\n  will be called ``bar_foo``.\n\n* In the `vmodtool`\\ -generated ReStructuredText documentation,\n  anchors have been renamed\n\n  * from ``obj_``\\ `class` to `vmodname`\\ ``.``\\ `class` for\n    constructors and\n  * from ``func_``\\ `class` to `vmodname`\\ ``.``\\ `function` for functions and\n  * from ``func_``\\ `class` to `vmodname`\\ ``.``\\ `class`\\ ``.``\\\n    `method` for methods,\n\n  repsectively. In short, the anchor is now named equal to VCL syntax\n  for constructors and functions and similarly to VCL syntax for methods.\n\n* VRT API has been updated to 9.0\n\n  * ``HTTP_Copy()`` was removed, ``HTTP_Dup()`` and ``HTTP_Clone()`` were added\n\n  * Previously, ``VCL_BLOB`` was implemented as ``struct vmod_priv``,\n    which had the following shortcomings:\n\n    * blobs are immutable, but that was not reflected by the ``priv``\n      pointer\n\n    * the existence of a free pointer suggested automatic memory\n      management, which did never and will not exist for blobs.\n\n    The ``VCL_BLOB`` type is now implemented as ``struct vrt_blob``,\n    with the ``blob`` member replacing the former ``priv`` pointer and\n    the ``free`` pointer removed.\n\n    A ``type`` member was added for lightweight type checking similar\n    to the miniobject ``magic`` member, but in contrast to it,\n    ``type`` should never be asserted upon.\n\n    ``VRT_blob()`` was updated accordingly.\n\n  * ``req->req_bodybytes`` was removed. Replacement code snippet::\n\n      AZ(ObjGetU64(req->wrk, req->body_oc, OA_LEN, &u));\n\n  * ``VRT_SetHealth()`` has been removed and ``VRT_SetChanged()``\n    added. ``VRT_LookupDirector()`` (only to be called from CLI\n    contexts) as been added.\n\n    See release notes for details\n\n* vmodtool has been changed significantly to avoid various name\n  clashes. Rather than using literal prefixes/suffixes, vmod authors\n  should now (and might have to for making existing code continue to\n  compile) use the following macros\n\n  * ``VPFX(name)`` to prepend the vmod prefix (``vmod_`` by default)\n\n  * ``VARGS(name)`` as the name of a function/method's argument\n    struct, e.g.::\n\n\tVCL_VOID vmod_test(VRT_CTX, struct VARGS(test) *args) { ...\n\n  * ``VENUM(name)`` to access the enum by the name `name`\n\nFixed bugs\n----------\n\n* Fixed ``varnishhist`` display error (2780_)\n\n* Fix ``varnishstat -f`` in curses mode (interactively, without\n  ``-1``, 2787_)\n\n* Handle an out-of-workspace condition in HTTP/2 delivery more\n  gracefully (2589_)\n\n* Fixed regression introduced just before 6.1.0 release which caused\n  an unnecessary incompatibility with VSL files written by previous\n  versions. (2790_)\n\n* Fix warmup/rampup of the shard director (2823_)\n\n* Fix VRT_priv_task for calls from vcl_pipe {} (2820_)\n\n* Fix assinging <bool> == <bool> (2809_)\n\n* Fix vmod object constructor documentation in the ``vmodtool.py`` -\n  generated RST files\n\n* Fix some stats metrics (vsc) which were wrongly marked as _gauge_\n\n* Fix ``varnishd -I`` (2782_)\n\n* Add error handling for STV_NewObject() (2831_)\n\n* Fix VRT_fail for 'if'/'elseif' conditional expressions (2840_)\n\n.. _2418: https://github.com/varnishcache/varnish-cache/issues/2418\n.. _2589: https://github.com/varnishcache/varnish-cache/issues/2589\n.. _2741: https://github.com/varnishcache/varnish-cache/pull/2741\n.. _2743: https://github.com/varnishcache/varnish-cache/issues/2743\n.. _2780: https://github.com/varnishcache/varnish-cache/issues/2780\n.. _2782: https://github.com/varnishcache/varnish-cache/issues/2782\n.. _2783: https://github.com/varnishcache/varnish-cache/pull/2783\n.. _2787: https://github.com/varnishcache/varnish-cache/issues/2787\n.. _2788: https://github.com/varnishcache/varnish-cache/issues/2788\n.. _2790: https://github.com/varnishcache/varnish-cache/issues/2790\n.. _2792: https://github.com/varnishcache/varnish-cache/pull/2792\n.. _2809: https://github.com/varnishcache/varnish-cache/issues/2809\n.. _2813: https://github.com/varnishcache/varnish-cache/pull/2813\n.. _2815: https://github.com/varnishcache/varnish-cache/issues/2815\n.. _2820: https://github.com/varnishcache/varnish-cache/issues/2820\n.. _2823: https://github.com/varnishcache/varnish-cache/issues/2823\n.. _2831: https://github.com/varnishcache/varnish-cache/issues/2831\n.. _2837: https://github.com/varnishcache/varnish-cache/pull/2837\n.. _2840: https://github.com/varnishcache/varnish-cache/issues/2840\n.. _VIP16: https://github.com/varnishcache/varnish-cache/wiki/VIP16%3A-Retire-parameters-aliases\n\n================================\nVarnish Cache 6.1.0 (2018-09-17)\n================================\n\n* Added -p max_vcl and -p max_vcl_handling for warnings/errors when\n  there are too many undiscarded VCL instances. (2713_)\n\n* ``Content-Length`` header is not rewritten in response to a HEAD\n  request, allows responses to HEAD requests to be cached\n  independently from GET responses.\n\n.. _2713: https://github.com/varnishcache/varnish-cache/issues/2713\n\nVCL\n---\n\n* ``return(fail(\"mumble\"))`` can have a string argument that is\n  emitted by VCC as an error message if the VCL load fails due to the\n  return. (2694_)\n\n* Improved VCC error messages (2696_)\n\n* Fixed ``obj.hits`` in ``vcl_hit`` (had been always 0) (2746_)\n\n.. _2746: https://github.com/varnishcache/varnish-cache/issues/2746\n.. _2696: https://github.com/varnishcache/varnish-cache/issues/2696\n.. _2694: https://github.com/varnishcache/varnish-cache/issues/2694\n\nbundled tools\n-------------\n\n* ``varnishhist``: Improved test coverage\n* ``varnishtest``: Added haproxy CLI send/expect facility\n\nC APIs (for vmod and utility authors)\n-------------------------------------\n\n* libvarnishapi so version bumped to 2.0.0 (2718_)\n\n* For VMOD methods/functions with PRIV_TASK or PRIV_TOP arguments, the\n  struct vrt_priv is allocated on the appropriate workspace. In the\n  out-of-workspace condition, VCL failure is invoked, and the VMOD\n  method/function is not called. (2708_)\n\n* Improved support for the VCL STRANDS type, VMOD blob refactored to\n  use STRANDS (2745_)\n\n.. _2718: https://github.com/varnishcache/varnish-cache/pull/2718\n.. _2745: https://github.com/varnishcache/varnish-cache/issues/2745\n.. _2708: https://github.com/varnishcache/varnish-cache/issues/2708\n\nFixed bugs\n----------\n\n* A series of bug fixes related to excessive object accumulation and\n  Transient storage use in the hit-for-miss case (2760_, 2754_, 2654_,\n  2763_)\n* A series of fixes related to Python and the vmodtool (2761_, 2759_,\n  2742_)\n* UB in varnishhist (2773_)\n* Allow to not have randomness in file_id (2436_)\n* b64.vtc unstable (2753_)\n* VCL_Poll ctx scope (2749_)\n\n.. _2436: https://github.com/varnishcache/varnish-cache/issues/2436\n.. _2654: https://github.com/varnishcache/varnish-cache/issues/2654\n.. _2742: https://github.com/varnishcache/varnish-cache/issues/2742\n.. _2749: https://github.com/varnishcache/varnish-cache/issues/2749\n.. _2753: https://github.com/varnishcache/varnish-cache/issues/2753\n.. _2754: https://github.com/varnishcache/varnish-cache/issues/2754\n.. _2759: https://github.com/varnishcache/varnish-cache/pull/2759\n.. _2760: https://github.com/varnishcache/varnish-cache/pull/2760\n.. _2761: https://github.com/varnishcache/varnish-cache/issues/2761\n.. _2763: https://github.com/varnishcache/varnish-cache/issues/2763\n.. _2773: https://github.com/varnishcache/varnish-cache/issues/2773\n\n================================\nVarnish Cache 6.0.1 (2018-08-29)\n================================\n\n* Added std.fnmatch() (2737_)\n* The variable req.grace is back. (2705_)\n* Importing the same VMOD multiple times is now allowed, if the file_id\n  is identical.\n\n.. _2705: https://github.com/varnishcache/varnish-cache/pull/2705\n.. _2737: https://github.com/varnishcache/varnish-cache/pull/2737\n\nvarnishstat\n-----------\n\n* The counters\n\n  * ``sess_fail_econnaborted``\n  * ``sess_fail_eintr``\n  * ``sess_fail_emfile``\n  * ``sess_fail_ebadf``\n  * ``sess_fail_enomem``\n  * ``sess_fail_other``\n\n  now break down the detailed reason for session accept failures, the\n  sum of which continues to be counted in ``sess_fail``.\n\nVCL and bundled VMODs\n---------------------\n\n* VMOD unix now supports the ``getpeerucred(3)`` case.\n\nbundled tools\n-------------\n\n* ``varnishhist``: The format of the ``-P`` argument has been changed\n  for custom profile definitions to also contain a prefix to match the\n  tag against.\n\n* ``varnishtest``: syslog instances now have to start with a capital S.\n\nFixed bugs which may influence VCL behavior\n--------------------------------------------\n\n* When an object is out of grace but in keep, the client context goes\n  straight to vcl_miss instead of vcl_hit. The documentation has been\n  updated accordingly. (2705_)\n\nFixed bugs\n----------\n\n* Several H2 bugs (2285_, 2572_, 2623_, 2624_, 2679_, 2690_, 2693_)\n* Make large integers work in VCL. (2603_)\n* Print usage on unknown or missing arguments (2608_)\n* Assert error in VPX_Send_Proxy() with proxy backends in pipe mode\n  (2613_)\n* Holddown times for certain backend connection errors (2622_)\n* Enforce Host requirement for HTTP/1.1 requests (2631_)\n* Introduction of '-' CLI prefix allowed empty commands to sneak\n  through. (2647_)\n* VUT apps can be stopped cleanly via vtc process -stop (2649_, 2650_)\n* VUT apps fail gracefully when removing a PID file fails\n* varnishd startup log should mention version (2661_)\n* In curses mode, always filter in the counters necessary for the\n  header lines. (2678_)\n* Assert error in ban_lurker_getfirst() (2681_)\n* Missing command entries in varnishadm help menu (2682_)\n* Handle string literal concatenation correctly (2685_)\n* varnishtop -1 does not work as documented (2686_)\n* Handle sigbus like sigsegv (2693_)\n* Panic on return (retry) of a conditional fetch (2700_)\n* Wrong turn at cache/cache_backend_probe.c:255: Unknown family\n  (2702_, 2726_)\n* VCL failure causes TASK_PRIV reference on reset workspace (2706_)\n* Accurate ban statistics except for a few remaining corner cases\n  (2716_)\n* Assert error in vca_make_session() (2719_)\n* Assert error in vca_tcp_opt_set() (2722_)\n* VCL compiling error on parenthesis (2727_)\n* Assert error in HTC_RxPipeline() (2731_)\n\n.. _2285: https://github.com/varnishcache/varnish-cache/issues/2285\n.. _2572: https://github.com/varnishcache/varnish-cache/issues/2572\n.. _2603: https://github.com/varnishcache/varnish-cache/issues/2603\n.. _2608: https://github.com/varnishcache/varnish-cache/issues/2608\n.. _2613: https://github.com/varnishcache/varnish-cache/issues/2613\n.. _2622: https://github.com/varnishcache/varnish-cache/issues/2622\n.. _2623: https://github.com/varnishcache/varnish-cache/issues/2623\n.. _2624: https://github.com/varnishcache/varnish-cache/issues/2624\n.. _2631: https://github.com/varnishcache/varnish-cache/issues/2631\n.. _2647: https://github.com/varnishcache/varnish-cache/issues/2647\n.. _2649: https://github.com/varnishcache/varnish-cache/issues/2649\n.. _2650: https://github.com/varnishcache/varnish-cache/pull/2650\n.. _2651: https://github.com/varnishcache/varnish-cache/pull/2651\n.. _2661: https://github.com/varnishcache/varnish-cache/issues/2661\n.. _2678: https://github.com/varnishcache/varnish-cache/issues/2678\n.. _2679: https://github.com/varnishcache/varnish-cache/issues/2679\n.. _2681: https://github.com/varnishcache/varnish-cache/issues/2681\n.. _2682: https://github.com/varnishcache/varnish-cache/issues/2682\n.. _2685: https://github.com/varnishcache/varnish-cache/issues/2685\n.. _2686: https://github.com/varnishcache/varnish-cache/issues/2686\n.. _2690: https://github.com/varnishcache/varnish-cache/issues/2690\n.. _2693: https://github.com/varnishcache/varnish-cache/issues/2693\n.. _2695: https://github.com/varnishcache/varnish-cache/issues/2695\n.. _2700: https://github.com/varnishcache/varnish-cache/issues/2700\n.. _2702: https://github.com/varnishcache/varnish-cache/issues/2702\n.. _2706: https://github.com/varnishcache/varnish-cache/issues/2706\n.. _2716: https://github.com/varnishcache/varnish-cache/issues/2716\n.. _2719: https://github.com/varnishcache/varnish-cache/issues/2719\n.. _2722: https://github.com/varnishcache/varnish-cache/issues/2722\n.. _2726: https://github.com/varnishcache/varnish-cache/pull/2726\n.. _2727: https://github.com/varnishcache/varnish-cache/issues/2727\n.. _2731: https://github.com/varnishcache/varnish-cache/issues/2731\n\n================================\nVarnish Cache 6.0.0 (2018-03-15)\n================================\n\nUsage\n-----\n\n* Fixed implementation of the ``max_restarts`` limit: It used to be one\n  less than the number of allowed restarts, it now is the number of\n  ``return(restart)`` calls per request.\n\n* The ``cli_buffer`` parameter has been removed\n\n* Added back ``umem`` storage for Solaris descendants\n\n* The new storage backend type (stevedore) ``default`` now resolves to\n  either ``umem`` (where available) or ``malloc``.\n\n* Since varnish 4.1, the thread workspace as configured by\n  ``workspace_thread`` was not used as documented, delivery also used\n  the client workspace.\n\n  We are now taking delivery IO vectors from the thread workspace, so\n  the parameter documentation is in sync with reality again.\n\n  Users who need to minimize memory footprint might consider\n  decreasing ``workspace_client`` by ``workspace_thread``.\n\n* The new parameter ``esi_iovs`` configures the amount of IO vectors\n  used during ESI delivery. It should not be tuned unless advised by a\n  developer.\n\n* Support Unix domain sockets for the ``-a`` and ``-b`` command-line\n  arguments, and for backend declarations. This requires VCL >= 4.1.\n\nVCL and bundled VMODs\n---------------------\n\n* ``return (fetch)`` is no longer allowed in ``vcl_hit {}``, use\n  ``return (miss)`` instead. Note that ``return (fetch)`` has been\n  deprecated since 4.0.\n\n* Fix behaviour of restarts to how it was originally intended:\n  Restarts now leave all the request properties in place except for\n  ``req.restarts`` and ``req.xid``, which need to change by design.\n\n* ``req.storage``, ``req.hash_ignore_busy`` and\n  ``req.hash_always_miss`` are now accessible from all of the client\n  side subs, not just ``vcl_recv{}``\n\n* ``obj.storage`` is now available in ``vcl_hit{}`` and ``vcl_deliver{}``.\n\n* Removed ``beresp.storage_hint`` for VCL 4.1 (was deprecated since\n  Varnish 5.1)\n\n  For VCL 4.0, compatibility is preserved, but the implementation is\n  changed slightly: ``beresp.storage_hint`` is now referring to the\n  same internal data structure as ``beresp.storage``.\n\n  In particular, it was previously possible to set\n  ``beresp.storage_hint`` to an invalid storage name and later\n  retrieve it back. Doing so will now yield the last successfully set\n  stevedore or the undefined (``NULL``) string.\n\n* IP-valued elements of VCL are equivalent to ``0.0.0.0:0`` when the\n  connection in question was addressed as a UDS. This is implemented\n  with the ``bogo_ip`` in ``vsa.c``.\n\n* ``beresp.backend.ip`` is retired as of VCL 4.1.\n\n* workspace overflows in ``std.log()`` now trigger a VCL failure.\n\n* workspace overflows in ``std.syslog()`` are ignored.\n\n* added ``return(restart)`` from ``vcl_recv{}``.\n\n* The ``alg`` argument of the ``shard`` director ``.reconfigure()``\n  method has been removed - the consistent hashing ring is now always\n  generated using the last 32 bits of a SHA256 hash of ``\"ident%d\"``\n  as with ``alg=SHA256`` or the default.\n\n  We believe that the other algorithms did not yield sufficiently\n  dispersed placement of backends on the consistent hashing ring and\n  thus retire this option without replacement.\n\n  Users of ``.reconfigure(alg=CRC32)`` or ``.reconfigure(alg=RS)`` be\n  advised that when upgrading and removing the ``alg`` argument,\n  consistent hashing values for all backends will change once and only\n  once.\n\n* The ``alg`` argument of the ``shard`` director ``.key()`` method has\n  been removed - it now always hashes its arguments using SHA256 and\n  returns the last 32 bits for use as a shard key.\n\n  Backwards compatibility is provided through `vmod blobdigest`_ with\n  the ``key_blob`` argument of the ``shard`` director ``.backend()``\n  method:\n\n  * for ``alg=CRC32``, replace::\n\n      <dir>.backend(by=KEY, key=<dir>.key(<string>, CRC32))\n\n    with::\n\n      <dir>.backend(by=BLOB, key_blob=blobdigest.hash(ICRC32,\n\tblob.decode(encoded=<string>)))\n\n    `Note:` The `vmod blobdigest`_ hash method corresponding to the\n    shard director CRC32 method is called **I**\\ CRC32\n\n.. _vmod blobdigest: https://code.uplex.de/uplex-varnish/libvmod-blobdigest/blob/master/README.rst\n\n  * for ``alg=RS``, replace::\n\n      <dir>.backend(by=KEY, key=<dir>.key(<string>, RS))\n\n    with::\n\n      <dir>.backend(by=BLOB, key_blob=blobdigest.hash(RS,\n\tblob.decode(encoded=<string>)))\n\n* The ``shard`` director now offers resolution at the time the actual\n  backend connection is made, which is how all other bundled directors\n  work as well: With the ``resolve=LAZY`` argument, other shard\n  parameters are saved for later reference and a director object is\n  returned.\n\n  This enables layering the shard director below other directors.\n\n* The ``shard`` director now also supports getting other parameters\n  from a parameter set object: Rather than passing the required\n  parameters with each ``.backend()`` call, an object can be\n  associated with a shard director defining the parameters. The\n  association can be changed in ``vcl_backend_fetch()`` and individual\n  parameters can be overridden in each ``.backend()`` call.\n\n  The main use case is to segregate shard parameters from director\n  selection: By associating a parameter object with many directors,\n  the same load balancing decision can easily be applied independent\n  of which set of backends is to be used.\n\n* To support parameter overriding, support for positional arguments of\n  the shard director ``.backend()`` method had to be removed. In other\n  words, all parameters to the shard director ``.backend()`` method\n  now need to be named.\n\n* Integers in VCL are now 64 bits wide across all platforms\n  (implemented as ``int64_t`` C type), but due to implementation\n  specifics of the VCL compiler (VCC), integer literals' precision is\n  limited to that of a VCL real (``double`` C type, roughly 53 bits).\n\n  In effect, larger integers are not represented accurately (they get\n  rounded) and may even have their sign changed or trigger a C\n  compiler warning / error.\n\n* Add VMOD unix.\n\n* Add VMOD proxy.\n\nLogging / statistics\n--------------------\n\n* Turned off PROXY protocol debugging by default, can be enabled with\n  the ``protocol`` debug flag.\n\n* added ``cache_hit_grace`` statistics counter.\n\n* added ``n_lru_limited`` counter.\n\n* The byte counters in ReqAcct now show the numbers reported from the\n  operating system rather than what we anticipated to send. This will give\n  more accurate numbers when e.g. the client hung up early without\n  receiving the entire response. Also these counters now show how many\n  bytes was attributed to the body, including any protocol overhead (ie\n  chunked encoding).\n\nbundled tools\n-------------\n\n* ``varnishncsa`` refuses output formats (as defined with the ``-F``\n  command line argument) for tags which could contain control or\n  binary characters. At the time of writing, these are:\n  ``%{H2RxHdr}x``, ``%{H2RxBody}x``, ``%{H2TxHdr}x``, ``%{H2TxBody}x``,\n  ``%{Debug}x``, ``%{HttpGarbage}x`` and ``%{Hash}x``\n\n* The vtc ``server -listen`` command supports UDS addresses, as does\n  the ``client -connect`` command. vtc ``remote.path`` and\n  ``remote.port`` have the values ``0.0.0.0`` and ``0`` when the peer\n  address is UDS. Added ``remote.path`` to vtc, whose value is the\n  path when the address is UDS, and NULL (matching <undef>) for IP\n  addresses.\n\nC APIs (for vmod and utility authors)\n-------------------------------------\n\n* We have now defined three API Stability levels: ``VRT``,\n  ``PACKAGE``, ``SOURCE``.\n\n* New API namespace rules, see `phk_api_spaces_`\n\n* Rules for including API headers have been changed:\n  * many headers can now only be included once\n  * some headers require specific include ordering\n  * only ``cache.h`` _or_ ``vrt.h`` can be included\n\n* Signatures of functions in the VLU API for bytestream into text\n  serialization have been changed\n\n* vcl.h now contains convenience macros ``VCL_MET_TASK_B``,\n  ``VCL_MET_TASK_C`` and ``VCL_MET_TASK_H`` for checking\n  ``ctx->method`` for backend, client and housekeeping\n  (vcl_init/vcl_fini) task context\n\n* vcc files can now contain a ``$Prefix`` stanza to define the prefix\n  for vmod function names (which was fixed to ``vmod`` before)\n\n* vcc files can contain a ``$Synopsis`` stanza with one of the values\n  ``auto`` or ``manual``, default ``auto``. With ``auto``, a more\n  comprehensive SYNOPSIS is generated in the doc output with an\n  overview of objects, methods, functions and their signatures. With\n  ``manual``, the auto-SYNOPSIS is left out, for VMOD authors who\n  prefer to write their own.\n\n* All Varnish internal ``SHA256*`` symbols have been renamed to\n  ``VSHA256*``\n\n* libvarnish now has ``VNUM_duration()`` to convert from a VCL\n  duration like 4h or 5s\n\n* director health state queries have been merged to ``VRT_Healthy()``\n\n* Renamed macros:\n  * ``__match_proto__()`` -> ``v_matchproto_()``\n  * ``__v_printflike()`` -> ``v_printflike_()``\n  * ``__state_variable__()`` -> ``v_statevariable_()``\n  * ``__unused`` -> ``v_unused_``\n  * ``__attribute__((__noreturn__)`` -> ``v_noreturn_``\n\n* ENUMs are now fixed pointers per vcl.\n\n* Added ``VRT_blob()`` utility function to create a blob as a copy\n  of some chunk of data on the workspace.\n\n* Directors now have their own admin health information and always need to\n  have the ``(struct director).admin_health`` initialized to\n  ``VDI_AH_*`` (usually ``VDI_AH_HEALTHY``).\n\nOther changes relevant for VMODs\n--------------------------------\n\n* ``PRIV_*`` function/method arguments are not excluded from\n  auto-generated vmod documentation.\n\nFixed bugs which may influence VCL behaviour\n--------------------------------------------\n\n* After reusing a backend connection fails once, a fresh connection\n  will be opened (2135_).\n\n.. _2135: https://github.com/varnishcache/varnish-cache/pull/2135\n\nFixed bugs\n----------\n\n* Honor first_byte_timeout for recycled backend connections. (1772_)\n\n* Limit backend connection retries to a single retry (2135_)\n\n* H2: Move the req-specific PRIV pointers to struct req. (2268_)\n\n* H2: Don't panic if we reembark with a request body (2305_)\n\n* Clear the objcore attributes flags when (re)initializing an stv object. (2319_)\n\n* H2: Fail streams with missing :method or :path. (2351_)\n\n* H2: Enforce sequence requirement of header block frames. (2387_)\n\n* H2: Hold the sess mutex when evaluating r2->cond. (2434_)\n\n* Use the idle read timeout only on empty requests. (2492_)\n\n* OH leak in http1_reembark. (2495_)\n\n* Fix objcore reference count leak. (2502_)\n\n* Close a race between backend probe and vcl.state=Cold by removing\n  the be->vsc under backend mtx. (2505_)\n\n* Fail gracefully if shard.backend() is called in housekeeping subs (2506_)\n\n* Fix issue #1799 for keep. (2519_)\n\n* oc->last_lru as float gives too little precision. (2527_)\n\n* H2: Don't HTC_RxStuff with a non-reserved workspace. (2539_)\n\n* Various optimizations of VSM. (2430_, 2470_, 2518_, 2535_, 2541_, 2545_, 2546_)\n\n* Problems during late socket initialization performed by the Varnish\n  child process can now be reported back to the management process with an\n  error message. (2551_)\n\n* Fail if ESI is attempted on partial (206) objects.\n\n* Assert error in ban_mark_completed() - ban lurker edge case. (2556_)\n\n* Accurate byte counters (2558_). See Logging / statistics above.\n\n* H2: Fix reembark failure handling. (2563_ and 2592_)\n\n* Working directory permissions insufficient when starting with\n  umask 027. (2570_)\n\n* Always use HTTP/1.1 on backend connections for pass & fetch. (2574_)\n\n* EPIPE is a documented errno in tcp(7) on linux. (2582_)\n\n* H2: Handle failed write(2) in h2_ou_session. (2607_)\n\n.. _1772: https://github.com/varnishcache/varnish-cache/issues/1772\n.. _2135: https://github.com/varnishcache/varnish-cache/pull/2135\n.. _2268: https://github.com/varnishcache/varnish-cache/issues/2268\n.. _2305: https://github.com/varnishcache/varnish-cache/issues/2305\n.. _2319: https://github.com/varnishcache/varnish-cache/issues/2319\n.. _2351: https://github.com/varnishcache/varnish-cache/issues/2351\n.. _2387: https://github.com/varnishcache/varnish-cache/issues/2387\n.. _2430: https://github.com/varnishcache/varnish-cache/issues/2430\n.. _2434: https://github.com/varnishcache/varnish-cache/issues/2434\n.. _2470: https://github.com/varnishcache/varnish-cache/issues/2470\n.. _2492: https://github.com/varnishcache/varnish-cache/issues/2492\n.. _2495: https://github.com/varnishcache/varnish-cache/issues/2495\n.. _2502: https://github.com/varnishcache/varnish-cache/issues/2502\n.. _2505: https://github.com/varnishcache/varnish-cache/issues/2505\n.. _2506: https://github.com/varnishcache/varnish-cache/issues/2506\n.. _2518: https://github.com/varnishcache/varnish-cache/issues/2518\n.. _2519: https://github.com/varnishcache/varnish-cache/pull/2519\n.. _2527: https://github.com/varnishcache/varnish-cache/issues/2527\n.. _2535: https://github.com/varnishcache/varnish-cache/issues/2535\n.. _2539: https://github.com/varnishcache/varnish-cache/issues/2539\n.. _2541: https://github.com/varnishcache/varnish-cache/issues/2541\n.. _2545: https://github.com/varnishcache/varnish-cache/pull/2545\n.. _2546: https://github.com/varnishcache/varnish-cache/issues/2546\n.. _2551: https://github.com/varnishcache/varnish-cache/issues/2551\n.. _2554: https://github.com/varnishcache/varnish-cache/pull/2554\n.. _2556: https://github.com/varnishcache/varnish-cache/issues/2556\n.. _2558: https://github.com/varnishcache/varnish-cache/pull/2558\n.. _2563: https://github.com/varnishcache/varnish-cache/issues/2563\n.. _2570: https://github.com/varnishcache/varnish-cache/issues/2570\n.. _2574: https://github.com/varnishcache/varnish-cache/issues/2574\n.. _2582: https://github.com/varnishcache/varnish-cache/issues/2582\n.. _2592: https://github.com/varnishcache/varnish-cache/issues/2592\n.. _2607: https://github.com/varnishcache/varnish-cache/issues/2607\n\n================================\nVarnish Cache 5.2.1 (2017-11-14)\n================================\n\nBugs fixed\n----------\n\n* 2429_ - Avoid buffer read overflow on vcl_backend_error and -sfile\n* 2492_ - Use the idle read timeout only on empty requests.\n\n.. _2429: https://github.com/varnishcache/varnish-cache/pull/2429\n.. _2492: https://github.com/varnishcache/varnish-cache/issues/2492\n\n================================\nVarnish Cache 5.2.0 (2017-09-15)\n================================\n\n* The ``cli_buffer`` parameter has been deprecated (2382_)\n\n.. _2382: https://github.com/varnishcache/varnish-cache/pull/2382\n\n==================================\nVarnish Cache 5.2-RC1 (2017-09-04)\n==================================\n\nUsage\n-----\n\n* The default for the the -i argument is now the hostname as returned\n  by gethostname(3)\n\n* Where possible (on platforms with setproctitle(3)), the -i argument\n  rather than the -n argument is used for process names\n\n* varnishd -f honors ``vcl_path`` (#2342)\n\n* The ``MAIN.s_req`` statistic has been removed, as it was identical to\n  ``MAIN.client_req``. VSM consumers should be changed to use the\n  latter if necessary.\n\n* A listen address can take a name in the -a argument. This name is used\n  in the logs and later will possibly be available in VCL.\n\nVCL\n---\n\n* VRT_purge fails a transaction if used outside of ``vcl_hit`` and\n  ``vcl_miss`` (#2339)\n\n* Added ``bereq.is_bgfetch`` which is true for background fetches.\n\n* Added VMOD purge (#2404)\n\n* Added VMOD blob (#2407)\n\nC APIs (for vmod and utility authors)\n-------------------------------------\n\n* The VSM API for accessing the shared memory segment has been\n  totally rewritten.  Things should be simpler and more general.\n\n* VSC shared memory layout has changed and the VSC API updated\n  to match it.  This paves the way for user defined VSC counters\n  in VMODS and later possibly also in VCL.\n\n* New vmod vtc for advanced varnishtest usage (#2276)\n\n================================\nVarnish Cache 5.1.3 (2017-08-02)\n================================\n\nBugs fixed\n----------\n\n* 2379_ - Correctly handle bogusly large chunk sizes (VSV00001)\n\n.. _2379: https://github.com/varnishcache/varnish-cache/issues/2379\n\n================================\nVarnish Cache 5.1.2 (2017-04-07)\n================================\n\n* Fix an endless loop in Backend Polling (#2295)\n\n* Fix a Chunked bug in tight workspaces (#2207, #2275)\n\n* Fix a bug relating to req.body when on waitinglist (#2266)\n\n* Handle EPIPE on broken TCP connections (#2267)\n\n* Work around the x86 arch's turbo-double FP format in parameter\n  setup code. (#1875)\n\n* Fix race related to backend probe with proxy header (#2278)\n\n* Keep VCL temperature consistent between mgt/worker also when\n  worker protests.\n\n* A lot of HTTP/2 fixes.\n\n================================\nVarnish Cache 5.1.1 (2017-03-16)\n================================\n\n* Fix bug introduced by stubborn old bugger right before release\n  5.1.0 was cut.\n\n================================\nVarnish Cache 5.1.0 (2017-03-15)\n================================\n\n* Added varnishd command-line options -I, -x and -?, and tightened\n  restrictions on permitted combinations of options.\n\n* More progress on support for HTTP/2.\n\n* Add ``return(fail)`` to almost all VCL subroutines.\n\n* Restored the old hit-for-pass, invoked with\n  ``return(pass(DURATION))`` from\n  ``vcl_backend_response``. hit-for-miss remains the default.  Added\n  the cache_hitmiss stat, and cache_hitpass only counts the new/old\n  hit-for-pass cases. Restored HitPass to the Varnish log, and added\n  HitMiss. Added the HFP prefix to TTL log entries to log a\n  hit-for-pass duration.\n\n* Rolled back the fix for #1206. Client delivery decides solely whether\n  to send a 304 client response, based on client request and response\n  headers.\n\n* Added vtest.sh.\n\n* Added vxid as a lefthand side for VSL queries.\n\n* Added the setenv and write_body commands for Varnish test cases (VTCs).\n  err_shell is deprecated. Also added the operators -cliexpect, -match and\n  -hdrlen, and -reason replaces -msg. Added the ${bad_backend} macro.\n\n* varnishtest can be stopped with the TERM, INT and KILL signals, but\n  not with HUP.\n\n* The fallback director has now an extra, optional parameter to keep\n  using the current backend until it falls sick.\n\n* VMOD shared libraries are now copied to the workdir, to avoid problems\n  when VMODs are updated via packaging systems.\n\n* Bump the VRT version to 6.0.\n\n* Export more symbols from libvarnishapi.so.\n\n* The size of the VSL log is limited to 4G-1b, placing upper bounds on\n  the -l option and the vsl_space and vsm_space parameters.\n\n* Added parameters clock_step, thread_pool_reserve and ban_cutoff.\n\n* Parameters vcl_dir and vmod_dir are deprecated, use vcl_path and\n  vmod_path instead.\n\n* All parameters are defined, even on platforms that don't support\n  them.  An unsupported parameter is documented as such in\n  param.show. Setting such a parameter is not an error, but has no\n  effect.\n\n* Clarified the interpretations of the + and - operators in VCL with\n  operands of the various data types.\n\n* DURATION types may be used in boolean contexts.\n\n* INT, DURATION and REAL values can now be negative.\n\n* Response codes 1000 or greater may now be set in VCL internally.\n  resp.status is delivered modulo 1000 in client responses.\n\n* IP addresses can be compared for equality in VCL.\n\n* Introduce the STEVEDORE data type, and the objects storage.SNAME\n  in VCL.  Added req.storage and beresp.storage; beresp.storage_hint\n  is deprecated.\n\n* Retired the umem stevedore.\n\n* req.ttl is deprecated.\n\n* Added std.getenv() and std.late_100_continue().\n\n* The fetch_failed stat is incremented for any kind of fetch failure.\n\n* Added the stats n_test_gunzip and bans_lurker_obj_killed_cutoff.\n\n* Clarified the meanings of the %r, %{X}i and %{X}o formatters in\n  varnishncsa.\n\nBugs fixed\n----------\n\n* 2251_ - varnishapi.pc and varnishconfdir\n* 2250_ - vrt.h now depends on vdef.h making current vmod fail.\n* 2249_ - \"logexpect -wait\" doesn't fail\n* 2245_ - Varnish doesn't start, if use vmod (vmod_cache dir was permission denied)\n* 2241_ - VSL fails to get hold of SHM\n* 2233_ - Crash on \"Assert error in WS_Assert(), cache/cache_ws.c line 59\"\n* 2227_ - -C flag broken in HEAD\n* 2217_ - fix argument processing -C regression\n* 2207_ - Assert error in V1L_Write()\n* 2205_ - Strange bug when I set client.ip with another string\n* 2203_ - unhandled SIGPIPE\n* 2200_ - Assert error in vev_compact_pfd(), vev.c line 394\n* 2197_ - ESI parser panic on malformed src URL\n* 2190_ - varnishncsa: The %r formatter is NOT equivalent to \"%m http://%{Host}i%U%q %H\"\n* 2186_ - Assert error in sml_iterator(), storage/storage_simple.c line 263\n* 2184_ - Cannot subtract a negative number\n* 2177_ - Clarify interactions between restarts and labels\n* 2175_ - Backend leak between a top VCL and a label\n* 2174_ - Cflags overhaul\n* 2167_ - VCC will not parse a literal negative number where INT is expected\n* 2155_ - vmodtool removes text following $Event from RST docs\n* 2151_ - Health probes do not honor a backend's PROXY protocol setting\n* 2142_ - ip comparison fails\n* 2148_ - varnishncsa cannot decode Authorization header if the format is incorrect.\n* 2143_ - Assert error in exp_inbox(), cache/cache_expire.c line 195\n* 2134_ - Disable Nagle's\n* 2129_ - stack overflow with >4 level esi\n* 2128_ - SIGSEGV NULL Pointer in STV__iter()\n* 2118_ - \"varnishstat -f MAIN.sess_conn -1\" produces empty output\n* 2117_ - SES_Close() EBADF / Wait_Enter() wp->fd <= 0\n* 2115_ - VSM temporary files are not always deleted\n* 2110_ - [CLI] vcl.inline failures\n* 2104_ - Assert error in VFP_Open(), cache/cache_fetch_proc.c line 139: Condition((vc->wrk->vsl) != 0) not true\n* 2099_ - VCC BACKEND/HDR comparison produces duplicate gethdr_s definition\n* 2096_ - H2 t2002 fail on arm64/arm32\n* 2094_ - H2 t2000 fail on arm64/arm32\n* 2078_ - VCL comparison doesn't fold STRING_LIST\n* 2052_ - d12.vtc flaky when compiling with suncc\n* 2042_ - Send a 304 response for a just-gone-stale hitpass object when appropriate\n* 2041_ - Parent process should exit if it fails to start child\n* 2035_ - varnishd stalls with two consecutive Range requests using HTTP persistent connections\n* 2026_ - Add restart of poll in read_tmo\n* 2021_ - vcc \"used before defined\" check\n* 2017_ - \"%r\" field is wrong\n* 2016_ - confusing vcc error when acl referenced before definition\n* 2014_ - req.ttl: retire or document+vtc\n* 2010_ - varnishadm CLI behaving weirdly\n* 1991_ - Starting varnish on Linux with boot param ipv6.disable=1 fails\n* 1988_ - Lost req.url gives misleading error\n* 1914_ - set a custom storage for cache_req_body\n* 1899_ - varnishadm vcl.inline is overly obscure\n* 1874_ - clock-step related crash\n* 1865_ - Panic accessing beresp.backend.ip in vcl_backend_error{}\n* 1856_ - LostHeader setting req.url to an empty string\n* 1834_ - WS_Assert(), cache/cache_ws.c line 59\n* 1830_ - VSL API: \"duplicate link\" errors in request grouping when vsl_buffer is increased\n* 1764_ - nuke_limit is not honored\n* 1750_ - Fail more gracefully on -l >= 4GB\n* 1704_ - fetch_failed not incremented\n\n.. _2251: https://github.com/varnishcache/varnish-cache/issues/2251\n.. _2250: https://github.com/varnishcache/varnish-cache/issues/2250\n.. _2249: https://github.com/varnishcache/varnish-cache/issues/2249\n.. _2245: https://github.com/varnishcache/varnish-cache/issues/2245\n.. _2241: https://github.com/varnishcache/varnish-cache/issues/2241\n.. _2233: https://github.com/varnishcache/varnish-cache/issues/2233\n.. _2227: https://github.com/varnishcache/varnish-cache/issues/2227\n.. _2217: https://github.com/varnishcache/varnish-cache/issues/2217\n.. _2207: https://github.com/varnishcache/varnish-cache/issues/2207\n.. _2205: https://github.com/varnishcache/varnish-cache/issues/2205\n.. _2203: https://github.com/varnishcache/varnish-cache/issues/2203\n.. _2200: https://github.com/varnishcache/varnish-cache/issues/2200\n.. _2197: https://github.com/varnishcache/varnish-cache/issues/2197\n.. _2190: https://github.com/varnishcache/varnish-cache/issues/2190\n.. _2186: https://github.com/varnishcache/varnish-cache/issues/2186\n.. _2184: https://github.com/varnishcache/varnish-cache/issues/2184\n.. _2177: https://github.com/varnishcache/varnish-cache/issues/2177\n.. _2175: https://github.com/varnishcache/varnish-cache/issues/2175\n.. _2174: https://github.com/varnishcache/varnish-cache/issues/2174\n.. _2167: https://github.com/varnishcache/varnish-cache/issues/2167\n.. _2155: https://github.com/varnishcache/varnish-cache/issues/2155\n.. _2151: https://github.com/varnishcache/varnish-cache/issues/2151\n.. _2142: https://github.com/varnishcache/varnish-cache/issues/2142\n.. _2148: https://github.com/varnishcache/varnish-cache/issues/2148\n.. _2143: https://github.com/varnishcache/varnish-cache/issues/2143\n.. _2134: https://github.com/varnishcache/varnish-cache/issues/2134\n.. _2129: https://github.com/varnishcache/varnish-cache/issues/2129\n.. _2128: https://github.com/varnishcache/varnish-cache/issues/2128\n.. _2118: https://github.com/varnishcache/varnish-cache/issues/2118\n.. _2117: https://github.com/varnishcache/varnish-cache/issues/2117\n.. _2115: https://github.com/varnishcache/varnish-cache/issues/2115\n.. _2110: https://github.com/varnishcache/varnish-cache/issues/2110\n.. _2104: https://github.com/varnishcache/varnish-cache/issues/2104\n.. _2099: https://github.com/varnishcache/varnish-cache/issues/2099\n.. _2096: https://github.com/varnishcache/varnish-cache/issues/2096\n.. _2094: https://github.com/varnishcache/varnish-cache/issues/2094\n.. _2078: https://github.com/varnishcache/varnish-cache/issues/2078\n.. _2052: https://github.com/varnishcache/varnish-cache/issues/2052\n.. _2042: https://github.com/varnishcache/varnish-cache/issues/2042\n.. _2041: https://github.com/varnishcache/varnish-cache/issues/2041\n.. _2035: https://github.com/varnishcache/varnish-cache/issues/2035\n.. _2026: https://github.com/varnishcache/varnish-cache/issues/2026\n.. _2021: https://github.com/varnishcache/varnish-cache/issues/2021\n.. _2017: https://github.com/varnishcache/varnish-cache/issues/2017\n.. _2016: https://github.com/varnishcache/varnish-cache/issues/2016\n.. _2014: https://github.com/varnishcache/varnish-cache/issues/2014\n.. _2010: https://github.com/varnishcache/varnish-cache/issues/2010\n.. _1991: https://github.com/varnishcache/varnish-cache/issues/1991\n.. _1988: https://github.com/varnishcache/varnish-cache/issues/1988\n.. _1914: https://github.com/varnishcache/varnish-cache/issues/1914\n.. _1899: https://github.com/varnishcache/varnish-cache/issues/1899\n.. _1874: https://github.com/varnishcache/varnish-cache/issues/1874\n.. _1865: https://github.com/varnishcache/varnish-cache/issues/1865\n.. _1856: https://github.com/varnishcache/varnish-cache/issues/1856\n.. _1834: https://github.com/varnishcache/varnish-cache/issues/1834\n.. _1830: https://github.com/varnishcache/varnish-cache/issues/1830\n.. _1764: https://github.com/varnishcache/varnish-cache/issues/1764\n.. _1750: https://github.com/varnishcache/varnish-cache/issues/1750\n.. _1704: https://github.com/varnishcache/varnish-cache/issues/1704\n\n================================\nVarnish Cache 5.0.0 (2016-09-15)\n================================\n\n* Documentation updates, especially the what's new and upgrade sections.\n\n* Via: header made by Varnish now says 5.0.\n\n* VMOD VRT ABI level increased.\n\n* [vcl] obj.(ttl|age|grace|keep) is now readable in vcl_deliver.\n\n* Latest devicedetect.vcl imported from upstream.\n\n* New system wide VCL directory: ``/usr/share/varnish/vcl/``\n\n* std.integer() can now convert from REAL.\n\nBugs fixed\n----------\n\n* 2086_ - Ignore H2 upgrades if the feature is not enabled.\n* 2054_ - Introduce new macros for out-of-tree VMODs\n* 2022_ - varnishstat -1 -f field inclusion glob doesn't allow VBE backend fields\n* 2008_ - Panic: Assert error in VBE_Delete()\n* 1800_ - PRIV_TASK in vcl_init/fini\n\n.. _2086: https://github.com/varnishcache/varnish-cache/issues/2086\n.. _2054: https://github.com/varnishcache/varnish-cache/issues/2054\n.. _2022: https://github.com/varnishcache/varnish-cache/issues/2022\n.. _2008: https://github.com/varnishcache/varnish-cache/issues/2008\n.. _1800: https://github.com/varnishcache/varnish-cache/issues/1800\n\n\n======================================\nVarnish Cache 5.0.0-beta1 (2016-09-09)\n======================================\n\nThis is the first beta release of the upcoming 5.0 release.\n\nThe list of changes are numerous and will not be expanded on in detail.\n\nThe release notes contain more background information and are highly\nrecommended reading before using any of the new features.\n\nMajor items:\n\n* VCL labels, allowing for per-vhost (or per-anything) separate VCL files.\n\n* (Very!) experimental support for HTTP/2.\n\n* Always send the request body to the backend, making possible to cache\n  responses of POST, PATCH requests etc with appropriate custom VCL and/or\n  VMODs.\n\n* hit-for-pass is now actually hit-for-miss.\n\n* new shard director for loadbalancing by consistent hashing\n\n* ban lurker performance improvements\n\n* access to obj.ttl, obj.age, obj.grace and obj.keep in vcl_deliver\n\nNews for Vmod Authors\n---------------------\n\n* workspace and PRIV_TASK for vcl cli events (init/fini methods)\n\n* PRIV_* now also work for object methods with unchanged scope.\n\n================================\nVarnish Cache 4.1.9 (2017-11-14)\n================================\n\nChanges since 4.1.8:\n\n* Added ``bereq.is_bgfetch`` which is true for background fetches.\n* Add the vtc feature ignore_unknown_macro.\n* Expose to VCL whether or not a fetch is a background fetch (bgfetch)\n* Ignore req.ttl when keeping track of expired objects (see 2422_)\n* Move a cli buffer to VSB (from stack).\n* Use a separate stack for signals.\n\n.. _2422: https://github.com/varnishcache/varnish-cache/pull/2422\n\nBugs fixed\n----------\n\n* 2337_ and 2366_ - Both Upgrade and Connection headers are needed for\n  WebSocket now\n* 2372_ - Fix problem with purging and the n_obj_purged counter\n* 2373_ - VSC n_vcl, n_vcl_avail, n_vcl_discard are gauge\n* 2380_ - Correct regexp in examples.\n* 2390_ - Straighten locking wrt vcl_active\n* 2429_ - Avoid buffer read overflow on vcl_backend_error and -sfile\n* 2492_ - Use the idle read timeout only on empty requests\n\n.. _2337: https://github.com/varnishcache/varnish-cache/issues/2337\n.. _2366: https://github.com/varnishcache/varnish-cache/issues/2366\n.. _2372: https://github.com/varnishcache/varnish-cache/pull/2372\n.. _2373: https://github.com/varnishcache/varnish-cache/issues/2373\n.. _2380: https://github.com/varnishcache/varnish-cache/issues/2380\n.. _2390: https://github.com/varnishcache/varnish-cache/issues/2390\n.. _2429: https://github.com/varnishcache/varnish-cache/pull/2429\n.. _2492: https://github.com/varnishcache/varnish-cache/issues/2492\n\n================================\nVarnish Cache 4.1.8 (2017-08-02)\n================================\n\nChanges since 4.1.7:\n\n* Update in the documentation of timestamps\n\nBugs fixed\n----------\n\n* 2379_ - Correctly handle bogusly large chunk sizes (VSV00001)\n\n.. _2379: https://github.com/varnishcache/varnish-cache/issues/2379\n\n================================\nVarnish Cache 4.1.7 (2017-06-28)\n================================\n\nChanges since 4.1.7-beta1:\n\n* Add extra locking to protect the pools list and refcounts\n* Don't panic on a null ban\n\nBugs fixed\n----------\n\n* 2321_ - Prevent storage backends name collisions\n\n.. _2321: https://github.com/varnishcache/varnish-cache/issues/2321\n\n======================================\nVarnish Cache 4.1.7-beta1 (2017-06-15)\n======================================\n\nChanges since 4.1.6:\n\n* Add -vsl_catchup to varnishtest\n* Add record-prefix support to varnishncsa\n\nBugs fixed\n----------\n* 1764_ - Correctly honor nuke_limit parameter\n* 2022_ - varnishstat -1 -f field inclusion glob doesn't allow VBE\n  backend fields\n* 2069_ - Health probes fail when HTTP response does not contain\n  reason phrase\n* 2118_ - \"varnishstat -f MAIN.sess_conn -1\" produces empty output\n* 2219_ - Remember to reset workspace\n* 2320_ - Rework and fix varnishstat counter filtering\n* 2329_ - Docfix: Only root can jail\n\n.. _1764: https://github.com/varnishcache/varnish-cache/issues/1764\n.. _2022: https://github.com/varnishcache/varnish-cache/issues/2022\n.. _2069: https://github.com/varnishcache/varnish-cache/issues/2069\n.. _2118: https://github.com/varnishcache/varnish-cache/issues/2118\n.. _2219: https://github.com/varnishcache/varnish-cache/issues/2219\n.. _2320: https://github.com/varnishcache/varnish-cache/issues/2320\n.. _2329: https://github.com/varnishcache/varnish-cache/issues/2329\n\n================================\nVarnish Cache 4.1.6 (2017-04-26)\n================================\n\n* Introduce a vxid left hand side for VSL queries. This allows\n  matching on records matching a known vxid.\n* Environment variables are now available in the stdandard VMOD;\n  std.getenv()\n* Add setenv command to varnishtest\n\n\nBugs fixed\n----------\n* 2200_ - Dramatically simplify VEV, fix assert in vev.c\n* 2216_ - Make sure Age is always less than max-age\n* 2233_ - Correct check when parsing the query string\n* 2241_ - VSL fails to get hold of SHM\n* 2270_ - Newly loaded auto VCLs don't get their go_cold timer set\n* 2273_ - Master cooling problem\n* 2275_ - If the client workspace is almost, but not quite exhaused, we may\n  not be able to get enough iovec's to do Chunked transmission.\n* 2295_ - Spinning loop in VBE_Poll causes master to kill child on\n  CLI timeout\n* 2301_ - Don't attempt to check if varnishd is still running if we have\n  already failed.\n* 2313_ - Cannot link to varnishapi, symbols missing\n\n.. _2200: https://github.com/varnishcache/varnish-cache/issues/2200\n.. _2216: https://github.com/varnishcache/varnish-cache/pull/2216\n.. _2233: https://github.com/varnishcache/varnish-cache/issues/2233\n.. _2241: https://github.com/varnishcache/varnish-cache/issues/2241\n.. _2270: https://github.com/varnishcache/varnish-cache/issues/2270\n.. _2273: https://github.com/varnishcache/varnish-cache/pull/2273\n.. _2275: https://github.com/varnishcache/varnish-cache/issues/2275\n.. _2295: https://github.com/varnishcache/varnish-cache/issues/2295\n.. _2301: https://github.com/varnishcache/varnish-cache/issues/2301\n.. _2313: https://github.com/varnishcache/varnish-cache/issues/2313\n\n================================\nVarnish Cache 4.1.5 (2017-02-09)\n================================\n\n* No code changes since 4.1.5-beta2.\n\n======================================\nVarnish Cache 4.1.5-beta2 (2017-02-08)\n======================================\n\n* Update devicedetect.vcl\n\nBugs fixed\n----------\n\n* 1704_ - Reverted the docfix and made the fech_failed counter do\n  what the documentation says it should do\n* 1865_ - Panic accessing beresp.backend.ip in vcl_backend_error\n* 2167_ - VCC will not parse a literal negative number where INT is\n  expected\n* 2184_ - Cannot subtract a negative number\n\n.. _1704: https://github.com/varnishcache/varnish-cache/issues/1704\n.. _1865: https://github.com/varnishcache/varnish-cache/issues/1865\n.. _2167: https://github.com/varnishcache/varnish-cache/issues/2167\n.. _2184: https://github.com/varnishcache/varnish-cache/issues/2184\n\n======================================\nVarnish Cache 4.1.5-beta1 (2017-02-02)\n======================================\n\nBugs fixed\n----------\n\n* 1704_ - (docfix) Clarify description of fetch_failed counter\n* 1834_ - Panic in workspace exhaustion conditions\n* 2106_ - 4.1.3: Varnish crashes with \"Assert error in CNT_Request(),\n  cache/cache_req_fsm.c line 820\"\n* 2134_ - Disable Nagle's\n* 2148_ - varnishncsa cannot decode Authorization header if the\n  format is incorrect.\n* 2168_ - Compare 'bereq.backend' / 'req.backend_hint'\n  myDirector.backend() does not work\n* 2178_ - 4.1 branch does not compile on FreeBSD\n* 2188_ - Fix vsm_free (never incremented)\n* 2190_ - (docfix)varnishncsa: The %r formatter is NOT equivalent to...\n* 2197_ - ESI parser panic on malformed src URL\n\n.. _1704: https://github.com/varnishcache/varnish-cache/issues/1704\n.. _1834: https://github.com/varnishcache/varnish-cache/issues/1834\n.. _2106: https://github.com/varnishcache/varnish-cache/issues/2106\n.. _2134: https://github.com/varnishcache/varnish-cache/issues/2134\n.. _2148: https://github.com/varnishcache/varnish-cache/issues/2148\n.. _2168: https://github.com/varnishcache/varnish-cache/issues/2168\n.. _2178: https://github.com/varnishcache/varnish-cache/issues/2178\n.. _2188: https://github.com/varnishcache/varnish-cache/pull/2188\n.. _2190: https://github.com/varnishcache/varnish-cache/issues/2190\n.. _2197: https://github.com/varnishcache/varnish-cache/issues/2197\n\n================================\nVarnish Cache 4.1.4 (2016-12-01)\n================================\n\nBugs fixed\n----------\n\n* 2035_ - varnishd stalls with two consecutive Range requests using\n  HTTP persistent connections\n\n.. _2035: https://github.com/varnishcache/varnish-cache/issues/2035\n\n======================================\nVarnish Cache 4.1.4-beta3 (2016-11-24)\n======================================\n\n* Include the current time of the panic in the panic output\n* Keep a reserve of idle threads for vital tasks\n\nBugs fixed\n----------\n\n* 1874_ - clock-step related crash\n* 1889_ - (docfix) What does -p flag for backend.list command means\n* 2115_ - VSM temporary files are not always deleted\n* 2129_ - (docfix) stack overflow with >4 level esi\n\n.. _1874: https://github.com/varnishcache/varnish-cache/issues/1874\n.. _1889: https://github.com/varnishcache/varnish-cache/issues/1889\n.. _2115: https://github.com/varnishcache/varnish-cache/issues/2115\n.. _2129: https://github.com/varnishcache/varnish-cache/issues/2129\n\n======================================\nVarnish Cache 4.1.4-beta2 (2016-10-13)\n======================================\n\nBugs fixed\n----------\n\n* 1830_ - VSL API: \"duplicate link\" errors in request grouping when\n  vsl_buffer is increased\n* 2010_ - varnishadm CLI behaving weirdly\n* 2017_ - varnishncsa docfix: \"%r\" field is wrong\n* 2107_ - (docfix) HEAD requestes changed to GET\n\n.. _1830: https://github.com/varnishcache/varnish-cache/issues/1830\n.. _2010: https://github.com/varnishcache/varnish-cache/issues/2010\n.. _2017: https://github.com/varnishcache/varnish-cache/issues/2017\n.. _2107: https://github.com/varnishcache/varnish-cache/issues/2107\n\n======================================\nVarnish Cache 4.1.4-beta1 (2016-09-14)\n======================================\n\n* [varnishhist] Various improvements\n* [varnishtest] A `cmd` feature for custom shell-based checks\n* Documentation improvements (do_stream, sess_herd, timeout_linger, thread_pools)\n* [varnishtop] Documented behavior when both -p and -1 are specified\n\nBugs fixed\n----------\n\n* 2027_ - Racy backend selection\n* 2024_ - panic vmod_rr_resolve() round_robin.c line 75 (be) != NULL\n* 2011_ - VBE.*.conn (concurrent connections to backend) not working as expected\n* 2008_ - Assert error in VBE_Delete()\n* 2007_ - Update documentation part about CLI/management port authentication parameter\n* 1881_ - std.cache_req_body() w/ return(pipe) is broken\n\n.. _2027: https://github.com/varnishcache/varnish-cache/issues/2027\n.. _2024: https://github.com/varnishcache/varnish-cache/issues/2024\n.. _2011: https://github.com/varnishcache/varnish-cache/issues/2011\n.. _2008: https://github.com/varnishcache/varnish-cache/issues/2008\n.. _2007: https://github.com/varnishcache/varnish-cache/issues/2007\n.. _1881: https://github.com/varnishcache/varnish-cache/issues/1881\n\n================================\nVarnish Cache 4.1.3 (2016-07-06)\n================================\n\n* Be stricter when parsing request headers to harden against smuggling attacks.\n\n======================================\nVarnish Cache 4.1.3-beta2 (2016-06-28)\n======================================\n\n* New parameter `vsm_free_cooldown`. Specifies how long freed VSM\n  memory (shared log) will be kept around before actually being freed.\n\n* varnishncsa now accepts `-L` argument to configure the limit on incomplete\n  transactions kept. (Issue 1994_)\n\nBugs fixed\n----------\n\n* 1984_ - Make the counter vsm_cooling act according to spec\n* 1963_ - Avoid abort when changing to a VCL name which is a path\n* 1933_ - Don't trust dlopen refcounting\n\n.. _1994: https://github.com/varnishcache/varnish-cache/issues/1994\n.. _1984: https://github.com/varnishcache/varnish-cache/issues/1984\n.. _1963: https://github.com/varnishcache/varnish-cache/issues/1963\n.. _1933: https://github.com/varnishcache/varnish-cache/issues/1933\n\n======================================\nVarnish Cache 4.1.3-beta1 (2016-06-15)\n======================================\n\n* varnishncsa can now access and log backend requests. (PR #1905)\n\n* [varnishncsa] New output formatters %{Varnish:vxid}x and %{VSL:Tag}x.\n\n* [varnishlog] Added log tag BackendStart on backend transactions.\n\n* On SmartOS, use ports instead of epoll by default.\n\n* Add support for TCP Fast Open where available. Disabled by default.\n\n* [varnishtest] New syncronization primitive barriers added, improving\n  coordination when test cases call external programs.\n\n.. _1905: https://github.com/varnishcache/varnish-cache/pull/1905\n\nBugs fixed\n----------\n\n* 1971_ - Add missing Wait_HeapDelete\n* 1967_ - [ncsa] Remove implicit line feed when using formatfile\n* 1955_ - 4.1.x sometimes duplicates Age and Accept-Ranges headers\n* 1954_ - Correctly handle HTTP/1.1 EOF response\n* 1953_ - Deal with fetch failures in ved_stripgzip\n* 1931_ - Allow VCL set Last-Modified to be used for I-M-S processing\n* 1928_ - req->task members must be set in case we get onto the waitinglist\n* 1924_ - Make std.log() and std.syslog() work from vcl_{init,fini}\n* 1919_ - Avoid ban lurker panic with empty olist\n* 1918_ - Correctly handle EOF responses with HTTP/1.1\n* 1912_ - Fix (insignificant) memory leak with mal-formed ESI directives.\n* 1904_ - Release memory instead of crashing on malformed ESI\n* 1885_ - [vmodtool] Method names should start with a period\n* 1879_ - Correct handling of duplicate headers on IMS header merge\n* 1878_ - Fix a ESI+gzip corner case which had escaped notice until now\n* 1873_ - Check for overrun before looking at the next vsm record\n* 1871_ - Missing error handling code in V1F_Setup_Fetch\n* 1869_ - Remove temporary directory iff called with -C\n* 1883_ - Only accept C identifiers as acls\n* 1855_ - Truncate output if it's wider than 12 chars\n* 1806_ - One minute delay on return (pipe) and a POST-Request\n* 1725_ - Revive the backend_conn counter\n\n.. _1971: https://github.com/varnishcache/varnish-cache/issues/1971\n.. _1967: https://github.com/varnishcache/varnish-cache/issues/1967\n.. _1955: https://github.com/varnishcache/varnish-cache/issues/1955\n.. _1954: https://github.com/varnishcache/varnish-cache/issues/1954\n.. _1953: https://github.com/varnishcache/varnish-cache/issues/1953\n.. _1931: https://github.com/varnishcache/varnish-cache/issues/1931\n.. _1928: https://github.com/varnishcache/varnish-cache/issues/1928\n.. _1924: https://github.com/varnishcache/varnish-cache/issues/1924\n.. _1919: https://github.com/varnishcache/varnish-cache/issues/1919\n.. _1918: https://github.com/varnishcache/varnish-cache/issues/1918\n.. _1912: https://github.com/varnishcache/varnish-cache/issues/1912\n.. _1904: https://github.com/varnishcache/varnish-cache/issues/1904\n.. _1885: https://github.com/varnishcache/varnish-cache/issues/1885\n.. _1883: https://github.com/varnishcache/varnish-cache/issues/1883\n.. _1879: https://github.com/varnishcache/varnish-cache/issues/1879\n.. _1878: https://github.com/varnishcache/varnish-cache/issues/1878\n.. _1873: https://github.com/varnishcache/varnish-cache/issues/1873\n.. _1871: https://github.com/varnishcache/varnish-cache/issues/1871\n.. _1869: https://github.com/varnishcache/varnish-cache/issues/1869\n.. _1855: https://github.com/varnishcache/varnish-cache/issues/1855\n.. _1806: https://github.com/varnishcache/varnish-cache/issues/1806\n.. _1725: https://github.com/varnishcache/varnish-cache/issues/1725\n\n\n================================\nVarnish Cache 4.1.2 (2016-03-04)\n================================\n\n* [vmods] vmodtool improvements for multiple VMODs in a single directory.\n\nBugs fixed\n----------\n\n* 1860_ - ESI-related memory leaks\n* 1863_ - Don't reset the oc->ban pointer from BAN_CheckObject\n* 1864_ - Avoid panic if the lurker is working on a ban to be checked.\n\n.. _1860: https://www.varnish-cache.org/trac/ticket/1860\n.. _1863: https://www.varnish-cache.org/trac/ticket/1863\n.. _1864: https://www.varnish-cache.org/trac/ticket/1864\n\n\n======================================\nVarnish Cache 4.1.2-beta2 (2016-02-25)\n======================================\n\n* [vmods] Passing VCL ACL to a VMOD is now possible.\n\n* [vmods] VRT_MINOR_VERSION increase due to new function: VRT_acl_match()\n\n* Some test case stabilization fixes and minor documentation updates.\n\n* Improved handling of workspace exhaustion when fetching objects.\n\nBugs fixed\n----------\n\n* 1858_ - Hit-for-pass objects are not IMS candidates\n\n.. _1858: https://www.varnish-cache.org/trac/ticket/1858\n\n======================================\nVarnish Cache 4.1.2-beta1 (2016-02-17)\n======================================\n\n* Be stricter when parsing a HTTP request to avoid potential\n  HTTP smuggling attacks against vulnerable backends.\n\n* Some fixes to minor/trivial issues found with clang AddressSanitizer.\n\n* Arithmetric on REAL data type in VCL is now possible.\n\n* vmodtool.py improvements to allow VMODs for 4.0 and 4.1 to share a source tree.\n\n* Off-by-one in WS_Reset() fixed.\n\n* \"https_scheme\" parameter added. Enables graceful handling of compound\n  request URLs with HTTPS scheme. (Bug 1847_)\n\nBugs fixed\n----------\n\n* 1739_ - Workspace overflow handling in VFP_Push()\n* 1837_ - Error compiling VCL if probe is referenced before it is defined\n* 1841_ - Replace alien FD's with /dev/null rather than just closing them\n* 1843_ - Fail HTTP/1.0 POST and PUT requests without Content-Length\n* 1844_ - Correct ENUM handling in object constructors\n* 1851_ - Varnish 4.1.1 fails to build on i386\n* 1852_ - Add a missing VDP flush operation after ESI:includes.\n* 1857_ - Fix timeout calculation for session herding.\n\n.. _1739: https://www.varnish-cache.org/trac/ticket/1739\n.. _1837: https://www.varnish-cache.org/trac/ticket/1837\n.. _1841: https://www.varnish-cache.org/trac/ticket/1841\n.. _1843: https://www.varnish-cache.org/trac/ticket/1843\n.. _1844: https://www.varnish-cache.org/trac/ticket/1844\n.. _1851: https://www.varnish-cache.org/trac/ticket/1851\n.. _1852: https://www.varnish-cache.org/trac/ticket/1852\n.. _1857: https://www.varnish-cache.org/trac/ticket/1857\n.. _1847: https://www.varnish-cache.org/trac/ticket/1847\n\n\n================================\nVarnish Cache 4.1.1 (2016-01-28)\n================================\n\n* No code changes since 4.1.1-beta2.\n\n\n======================================\nVarnish Cache 4.1.1-beta2 (2016-01-22)\n======================================\n\n* Improvements to VCL temperature handling added. This opens for reliably\n  deny warming a cooling VCL from a VMOD.\n\nBugs fixed\n----------\n\n* 1802_ - Segfault after VCL change\n* 1825_ - Cannot Start Varnish After Just Restarting The Service\n* 1842_ - Handle missing waiting list gracefully.\n* 1845_ - Handle whitespace after floats in test fields\n\n.. _1802: https://www.varnish-cache.org/trac/ticket/1802\n.. _1825: https://www.varnish-cache.org/trac/ticket/1825\n.. _1842: https://www.varnish-cache.org/trac/ticket/1842\n.. _1845: https://www.varnish-cache.org/trac/ticket/1845\n\n\n======================================\nVarnish Cache 4.1.1-beta1 (2016-01-15)\n======================================\n\n- Format of \"ban.list\" has changed slightly.\n- [varnishncsa] -w is now required when running deamonized.\n- [varnishncsa] Log format can now be read from file.\n- Port fields extracted from PROXY1 header now work as expected.\n- New VCL state \"busy\" introduced (mostly for VMOD writers).\n- Last traces of varnishreplay removed.\n- If-Modified-Since is now ignored if we have If-None-Match.\n- Zero Content-Length is no longer sent on 304 responses.\n- vcl_dir and vmod_dir now accept a colon separated list of directories.\n- Nested includes starting with \"./\" are relative to the including\n  VCL file now.\n\n\nBugs fixed\n----------\n\n- 1796_ - Don't attempt to allocate a V1L from the workspace if it is overflowed.\n- 1794_ - Fail if multiple -a arguments return the same suckaddr.\n- 1763_ - Restart epoll_wait on EINTR error\n- 1788_ - ObjIter has terrible performance profile when busyobj != NULL\n- 1798_ - Varnish requests painfully slow with large files\n- 1816_ - Use a weak comparison function for If-None-Match\n- 1818_ - Allow grace-hits on hit-for-pass objects, [..]\n- 1821_ - Always slim private & pass objects after delivery.\n- 1823_ - Rush the objheader if there is a waiting list when it is deref'ed.\n- 1826_ - Ignore 0 Content-Lengths in 204 responses\n- 1813_ - Fail if multiple -a arguments return the same suckaddr.\n- 1810_ - Improve handling of HTTP/1.0 clients\n- 1807_ - Return 500 if we cannot decode the stored object into the resp.*\n- 1804_ - Log proxy related messages on the session, not on the request.\n- 1801_ - Relax IP constant parsing\n\n.. _1796: https://www.varnish-cache.org/trac/ticket/1796\n.. _1794: https://www.varnish-cache.org/trac/ticket/1794\n.. _1763: https://www.varnish-cache.org/trac/ticket/1763\n.. _1788: https://www.varnish-cache.org/trac/ticket/1788\n.. _1798: https://www.varnish-cache.org/trac/ticket/1798\n.. _1816: https://www.varnish-cache.org/trac/ticket/1816\n.. _1818: https://www.varnish-cache.org/trac/ticket/1818\n.. _1821: https://www.varnish-cache.org/trac/ticket/1821\n.. _1823: https://www.varnish-cache.org/trac/ticket/1823\n.. _1826: https://www.varnish-cache.org/trac/ticket/1826\n.. _1813: https://www.varnish-cache.org/trac/ticket/1813\n.. _1810: https://www.varnish-cache.org/trac/ticket/1810\n.. _1807: https://www.varnish-cache.org/trac/ticket/1807\n.. _1804: https://www.varnish-cache.org/trac/ticket/1804\n.. _1801: https://www.varnish-cache.org/trac/ticket/1801\n\n\n================================\nVarnish Cache 4.1.0 (2015-09-30)\n================================\n\n- Documentation updates.\n- Stabilization fixes on testcase p00005.vtc.\n- Avoid compiler warning in zlib.\n- Bug 1792_: Avoid using fallocate() with -sfile on non-EXT4.\n\n.. _1792: https://www.varnish-cache.org/trac/ticket/1792\n\n\n======================================\nVarnish Cache 4.1.0-beta1 (2015-09-11)\n======================================\n\n- Redhat packaging files are now separate from the normal tree.\n- Client workspace overflow should now result in a 500 response\n  instead of panic.\n- [varnishstat] -w option has been retired.\n- libvarnishapi release number is increased.\n- Body bytes sent on ESI subrequests with gzip are now counted correctly.\n- [vmod-std] Data type conversion functions now take additional fallback argument.\n\nBugs fixed\n----------\n\n- 1777_ - Disable speculative Range handling on streaming transactions.\n- 1778_ - [varnishstat] Cast to integer to prevent negative values messing the statistics\n- 1781_ - Propagate gzip CRC upwards from nested ESI includes.\n- 1783_ - Align code with RFC7230 section 3.3.3 which allows POST without a body.\n\n.. _1777: https://www.varnish-cache.org/trac/ticket/1777\n.. _1778: https://www.varnish-cache.org/trac/ticket/1778\n.. _1781: https://www.varnish-cache.org/trac/ticket/1781\n.. _1783: https://www.varnish-cache.org/trac/ticket/1783\n\n\n====================================\nVarnish Cache 4.1.0-tp1 (2015-07-08)\n====================================\n\nChanges between 4.0 and 4.1 are numerous. Please read the upgrade\nsection in the documentation for a general overview.\n\n\n============================================\nChanges from 4.0.3-rc3 to 4.0.3 (2015-02-17)\n============================================\n\n* No changes.\n\n================================================\nChanges from 4.0.3-rc2 to 4.0.3-rc3 (2015-02-11)\n================================================\n\n- Superseded objects are now expired immediately.\n\nBugs fixed\n----------\n\n- 1462_ - Use first/last log entry in varnishncsa.\n- 1539_ - Avoid panic when expiry thread modifies a candidate object.\n- 1637_ - Fail the fetch processing if the vep callback failed.\n- 1665_ - Be more accurate when computing client RX_TIMEOUT.\n- 1672_ - Do not panic on unsolicited 304 response to non-200 bereq.\n\n.. _1462: https://www.varnish-cache.org/trac/ticket/1462\n.. _1539: https://www.varnish-cache.org/trac/ticket/1539\n.. _1637: https://www.varnish-cache.org/trac/ticket/1637\n.. _1665: https://www.varnish-cache.org/trac/ticket/1665\n.. _1672: https://www.varnish-cache.org/trac/ticket/1672\n\n\n================================================\nChanges from 4.0.3-rc1 to 4.0.3-rc2 (2015-01-28)\n================================================\n\n- Assorted documentation updates.\n\nBugs fixed\n----------\n\n- 1479_ - Fix out-of-tree builds.\n- 1566_ - Escape VCL string question marks.\n- 1616_ - Correct header file placement.\n- 1620_ - Fail miss properly if out of backend threads. (Also 1621_)\n- 1628_ - Avoid dereferencing null in VBO_DerefBusyObj().\n- 1629_ - Ditch rest of waiting list on failure to reschedule.\n- 1660_ - Don't attempt range delivery on a synth response\n\n.. _1479: https://www.varnish-cache.org/trac/ticket/1479\n.. _1566: https://www.varnish-cache.org/trac/ticket/1578\n.. _1616: https://www.varnish-cache.org/trac/ticket/1616\n.. _1620: https://www.varnish-cache.org/trac/ticket/1620\n.. _1621: https://www.varnish-cache.org/trac/ticket/1621\n.. _1628: https://www.varnish-cache.org/trac/ticket/1628\n.. _1629: https://www.varnish-cache.org/trac/ticket/1629\n.. _1660: https://www.varnish-cache.org/trac/ticket/1660\n\n\n============================================\nChanges from 4.0.2 to 4.0.3-rc1 (2015-01-15)\n============================================\n\n- Support older autoconf (< 2.63b) (el5)\n- A lot of minor documentation fixes.\n- bereq.uncacheable is now read-only.\n- obj.uncacheable is now readable in vcl_deliver.\n- [varnishadm] Prefer exact matches for backend.set_healthy. Bug 1349_.\n- Hard-coded -sfile default size is removed.\n- [packaging] EL6 packages are once again built with -O2.\n- [parameter] fetch_chunksize default is reduced to 16KB. (from 128KB)\n- Added std.time() which converts strings to VCL_TIME.\n- [packaging] packages now Provide strictABI (gitref) and ABI (VRT major/minor) for VMOD use.\n\nBugs fixed\n----------\n\n* 1378_ - Properly escape non-printable characters in varnishncsa.\n* 1596_ - Delay HSH_Complete() until the storage sanity functions has finished.\n* 1506_ - Keep Content-Length from backend if we can.\n* 1602_ - Fix a cornercase related to empty pass objects.\n* 1607_ - Don't leak reqs on failure to revive from waitinglist.\n* 1610_ - Update forgotten varnishlog example to 4.0 syntax.\n* 1612_ - Fix a cornercase related to empty pass objects.\n* 1623_ - Fix varnishhist -d segfault.\n* 1636_ - Outdated paragraph in Vary: documentation\n* 1638_ - Fix panic when retrying a failed backend fetch.\n* 1639_ - Restore the default SIGSEGV handler during pan_ic\n* 1647_ - Relax an assertion for the IMS update candidate object.\n* 1648_ - Avoid partial IMS updates to replace old object.\n* 1650_ - Collapse multiple X-Forwarded-For headers\n\n.. _1349: https://www.varnish-cache.org/trac/ticket/1349\n.. _1378: https://www.varnish-cache.org/trac/ticket/1378\n.. _1596: https://www.varnish-cache.org/trac/ticket/1596\n.. _1506: https://www.varnish-cache.org/trac/ticket/1506\n.. _1602: https://www.varnish-cache.org/trac/ticket/1602\n.. _1607: https://www.varnish-cache.org/trac/ticket/1607\n.. _1610: https://www.varnish-cache.org/trac/ticket/1610\n.. _1612: https://www.varnish-cache.org/trac/ticket/1612\n.. _1623: https://www.varnish-cache.org/trac/ticket/1623\n.. _1636: https://www.varnish-cache.org/trac/ticket/1636\n.. _1638: https://www.varnish-cache.org/trac/ticket/1638\n.. _1639: https://www.varnish-cache.org/trac/ticket/1639\n.. _1647: https://www.varnish-cache.org/trac/ticket/1647\n.. _1648: https://www.varnish-cache.org/trac/ticket/1648\n.. _1650: https://www.varnish-cache.org/trac/ticket/1650\n\n\n============================================\nChanges from 4.0.2-rc1 to 4.0.2 (2014-10-08)\n============================================\n\nNew since 4.0.2-rc1:\n\n- [varnishlog] -k argument is back. (exit after n records)\n- [varnishadm] vcl.show is now listed in help.\n\n\n============================================\nChanges from 4.0.1 to 4.0.2-rc1 (2014-09-23)\n============================================\n\nNew since 4.0.1:\n\n- [libvmod-std] New function strstr() for matching substrings.\n- server.(hostname|identity) is now available in all VCL functions.\n- VCL variable type BYTES was added.\n- `workspace_client` default is now 9k.\n- [varnishstat] Update interval can now be subsecond.\n- Document that reloading VCL does not reload a VMOD.\n- Guru meditation page is now valid HTML5.\n- [varnishstat] hitrate calculation is back.\n- New parameter `group_cc` adds a GID to the grouplist of\n  VCL compiler sandbox.\n- Parameter shm_reclen is now an alias for vsl_reclen.\n- Workspace overflows are now handled with a 500 client response.\n- VCL variable type added: HTTP, representing a HTTP header set.\n- It is now possible to return(synth) from vcl_deliver.\n- [varnishadm] vcl.show now has a -v option that output the\n  complete set of VCL and included VCL files.\n- RHEL7 packaging (systemd) was added.\n- [libvmod-std] querysort() fixed parameter limit has been lifted.\n- Fix small memory leak in ESI parser.\n- Fix unreported race/assert in V1D_Deliver().\n\nBugs fixed\n----------\n\n* 1553_ - Fully reset workspace (incl. Vary state) before reusing it.\n* 1551_ - Handle workspace exhaustion during purge.\n* 1591_ - Group entries correctly in varnishtop.\n* 1592_ - Bail out on workspace exhaustion in VRT_IP_string.\n* 1538_ - Relax VMOD ABI check for release branches.\n* 1584_ - Don't log garbage/non-HTTP requests. [varnishncsa]\n* 1407_ - Don't rename VSM file until child has started.\n* 1466_ - Don't leak request structs on restart after waitinglist.\n* 1580_ - Output warning if started without -b and -f. [varnishd]\n* 1583_ - Abort on fatal sandbox errors on Solaris. (Related: 1572_)\n* 1585_ - Handle fatal sandbox errors.\n* 1572_ - Exit codes have been cleaned up.\n* 1569_ - Order of symbols should not influence compilation result.\n* 1579_ - Clean up type inference in VCL.\n* 1578_ - Don't count Age twice when computing new object TTL.\n* 1574_ - std.syslog() logged empty strings.\n* 1555_ - autoconf editline/readline build issue.\n* 1568_ - Skip NULL arguments when hashing.\n* 1567_ - Compile on systems without SO_SNDTIMEO/SO_RCVTIMEO.\n* 1512_ - Changes to bereq are lost between v_b_r and v_b_f.\n* 1563_ - Increase varnishtest read timeout.\n* 1561_ - Never call a VDP with zero length unless done.\n* 1562_ - Fail correctly when rereading a failed client request body.\n* 1521_ - VCL compilation fails on OSX x86_64.\n* 1547_ - Panic when increasing shm_reclen.\n* 1503_ - Document return(retry).\n* 1581_ - Don't log duplicate Begin records to shmlog.\n* 1588_ - Correct timestamps on pipelined requests.\n* 1575_ - Use all director backends when looking for a healthy one.\n* 1577_ - Read the full request body if shunted to synth.\n* 1532_ - Use correct VCL representation of reals.\n* 1531_ - Work around libedit bug in varnishadm.\n\n.. _1553: https://www.varnish-cache.org/trac/ticket/1553\n.. _1551: https://www.varnish-cache.org/trac/ticket/1551\n.. _1591: https://www.varnish-cache.org/trac/ticket/1591\n.. _1592: https://www.varnish-cache.org/trac/ticket/1592\n.. _1538: https://www.varnish-cache.org/trac/ticket/1538\n.. _1584: https://www.varnish-cache.org/trac/ticket/1584\n.. _1407: https://www.varnish-cache.org/trac/ticket/1407\n.. _1466: https://www.varnish-cache.org/trac/ticket/1466\n.. _1580: https://www.varnish-cache.org/trac/ticket/1580\n.. _1583: https://www.varnish-cache.org/trac/ticket/1583\n.. _1585: https://www.varnish-cache.org/trac/ticket/1585\n.. _1572: https://www.varnish-cache.org/trac/ticket/1572\n.. _1569: https://www.varnish-cache.org/trac/ticket/1569\n.. _1579: https://www.varnish-cache.org/trac/ticket/1579\n.. _1578: https://www.varnish-cache.org/trac/ticket/1578\n.. _1574: https://www.varnish-cache.org/trac/ticket/1574\n.. _1555: https://www.varnish-cache.org/trac/ticket/1555\n.. _1568: https://www.varnish-cache.org/trac/ticket/1568\n.. _1567: https://www.varnish-cache.org/trac/ticket/1567\n.. _1512: https://www.varnish-cache.org/trac/ticket/1512\n.. _1563: https://www.varnish-cache.org/trac/ticket/1563\n.. _1561: https://www.varnish-cache.org/trac/ticket/1561\n.. _1562: https://www.varnish-cache.org/trac/ticket/1562\n.. _1521: https://www.varnish-cache.org/trac/ticket/1521\n.. _1547: https://www.varnish-cache.org/trac/ticket/1547\n.. _1503: https://www.varnish-cache.org/trac/ticket/1503\n.. _1581: https://www.varnish-cache.org/trac/ticket/1581\n.. _1588: https://www.varnish-cache.org/trac/ticket/1588\n.. _1575: https://www.varnish-cache.org/trac/ticket/1575\n.. _1577: https://www.varnish-cache.org/trac/ticket/1577\n.. _1532: https://www.varnish-cache.org/trac/ticket/1532\n.. _1531: https://www.varnish-cache.org/trac/ticket/1531\n\n\n========================================\nChanges from 4.0.0 to 4.0.1 (2014-06-24)\n========================================\n\nNew since 4.0.0:\n\n- New functions in vmod_std: real2time, time2integer, time2real, real.\n- Chunked requests are now supported. (pass)\n- Add std.querysort() that sorts GET query arguments. (from libvmod-boltsort)\n- Varnish will no longer reply with \"200 Not Modified\".\n- Backend IMS is now only attempted when last status was 200.\n- Packaging now uses find-provides instead of find-requires. [redhat]\n- Two new counters: n_purges and n_obj_purged.\n- Core size can now be set from /etc/sysconfig/varnish [redhat]\n- Via header set is now RFC compliant.\n- Removed \"purge\" keyword in VCL. Use return(purge) instead.\n- fallback director is now documented.\n- %D format flag in varnishncsa is now truncated to an integer value.\n- persistent storage backend is now deprecated.\n  https://www.varnish-cache.org/docs/trunk/phk/persistent.html\n- Added format flags %I (total bytes received) and %O (total bytes sent) for\n  varnishncsa.\n- python-docutils >= 0.6 is now required.\n- Support year (y) as a duration in VCL.\n- VMOD ABI requirements are relaxed, a VMOD no longer have to be run on the\n  same git revision as it was compiled for. Replaced by a major/minor ABI counter.\n\n\nBugs fixed\n----------\n\n* 1269_ - Use correct byte counters in varnishncsa when piping a request.\n* 1524_ - Chunked requests should be pipe-able.\n* 1530_ - Expire old object on successful IMS fetch.\n* 1475_ - time-to-first-byte in varnishncsa was potentially dishonest.\n* 1480_ - Porting guide for 4.0 is incomplete.\n* 1482_ - Inherit group memberships of -u specified user.\n* 1473_ - Fail correctly in configure when rst2man is not found.\n* 1486_ - Truncate negative Age values to zero.\n* 1488_ - Don't panic on high request rates.\n* 1489_ - req.esi should only be available in client threads.\n* 1490_ - Fix thread leak when reducing number of threads.\n* 1491_ - Reorder backend connection close procedure to help test cases.\n* 1498_ - Prefix translated VCL names to avoid name clashes.\n* 1499_ - Don't leak an objcore when HSH_Lookup returns expired object.\n* 1493_ - vcl_purge can return synth or restart.\n* 1476_ - Cope with systems having sys/endian.h and endian.h.\n* 1496_ - varnishadm should be consistent in argv ordering.\n* 1494_ - Don't panic on VCL-initiated retry after a backend 500 error.\n* 1139_ - Also reset keep (for IMS) time when purging.\n* 1478_ - Avoid panic when delivering an object that expires during delivery.\n* 1504_ - ACLs can be unreferenced with vcc_err_unref=off set.\n* 1501_ - Handle that a director couldn't pick a backend.\n* 1495_ - Reduce WRK_SumStat contention.\n* 1510_ - Complain on symbol reuse in VCL.\n* 1514_ - Document storage.NAME.free_space and .used_space [docs]\n* 1518_ - Suppress body on 304 response when using ESI.\n* 1519_ - Round-robin director does not support weight. [docs]\n\n\n.. _1269: https://www.varnish-cache.org/trac/ticket/1269\n.. _1524: https://www.varnish-cache.org/trac/ticket/1524\n.. _1530: https://www.varnish-cache.org/trac/ticket/1530\n.. _1475: https://www.varnish-cache.org/trac/ticket/1475\n.. _1480: https://www.varnish-cache.org/trac/ticket/1480\n.. _1482: https://www.varnish-cache.org/trac/ticket/1482\n.. _1473: https://www.varnish-cache.org/trac/ticket/1473\n.. _1486: https://www.varnish-cache.org/trac/ticket/1486\n.. _1488: https://www.varnish-cache.org/trac/ticket/1488\n.. _1489: https://www.varnish-cache.org/trac/ticket/1489\n.. _1490: https://www.varnish-cache.org/trac/ticket/1490\n.. _1491: https://www.varnish-cache.org/trac/ticket/1491\n.. _1498: https://www.varnish-cache.org/trac/ticket/1498\n.. _1499: https://www.varnish-cache.org/trac/ticket/1499\n.. _1493: https://www.varnish-cache.org/trac/ticket/1493\n.. _1476: https://www.varnish-cache.org/trac/ticket/1476\n.. _1496: https://www.varnish-cache.org/trac/ticket/1496\n.. _1494: https://www.varnish-cache.org/trac/ticket/1494\n.. _1139: https://www.varnish-cache.org/trac/ticket/1139\n.. _1478: https://www.varnish-cache.org/trac/ticket/1478\n.. _1504: https://www.varnish-cache.org/trac/ticket/1504\n.. _1501: https://www.varnish-cache.org/trac/ticket/1501\n.. _1495: https://www.varnish-cache.org/trac/ticket/1495\n.. _1510: https://www.varnish-cache.org/trac/ticket/1510\n.. _1518: https://www.varnish-cache.org/trac/ticket/1518\n.. _1519: https://www.varnish-cache.org/trac/ticket/1519\n\n\n==============================================\nChanges from 4.0.0 beta1 to 4.0.0 (2014-04-10)\n==============================================\n\nNew since 4.0.0-beta1:\n\n- improved varnishstat documentation.\n- In VCL, req.backend_hint is available in vcl_hit\n- ncurses is now a dependency.\n\n\nBugs fixed\n----------\n\n* 1469_ - Fix build error on PPC\n* 1468_ - Set ttl=0 on failed objects\n* 1462_ - Handle duplicate ReqURL in varnishncsa.\n* 1467_ - Fix missing clearing of oc->busyobj on HSH_Fail.\n\n\n.. _1469: https://www.varnish-cache.org/trac/ticket/1469\n.. _1468: https://www.varnish-cache.org/trac/ticket/1468\n.. _1462: https://www.varnish-cache.org/trac/ticket/1462\n.. _1467: https://www.varnish-cache.org/trac/ticket/1467\n\n\n==================================================\nChanges from 4.0.0 TP2 to 4.0.0 beta1 (2014-03-27)\n==================================================\n\nNew since TP2:\n\n- Previous always-appended code called default.vcl is now called builtin.vcl.\n  The new example.vcl is recommended as a starting point for new users.\n- vcl_error is now called vcl_synth, and does not any more mandate closing the\n  client connection.\n- New VCL function vcl_backend_error, where you can change the 503 prepared if\n  all your backends are failing. This can then be cached as a regular object.\n- Keyword \"remove\" in VCL is replaced by \"unset\".\n- new timestamp and accounting records in varnishlog.\n- std.timestamp() is introduced.\n- stored objects are now read only, meaning obj.hits now counts per objecthead\n  instead. obj.lastuse saw little use and has been removed.\n- builtin VCL now does return(pipe) for chunked POST and PUT requests.\n- python-docutils and rst2man are now build requirements.\n- cli_timeout is now 60 seconds to avoid slaughtering the child process in\n  times of high IO load/scheduling latency.\n- return(purge) from vcl_recv is now valid.\n- return(hash) is now the default return action from vcl_recv.\n- req.backend is now req.backend_hint. beresp.storage is beresp.storage_hint.\n\n\nBugs fixed\n----------\n\n* 1460_ - tools now use the new timestamp format.\n* 1450_ - varnishstat -l segmentation fault.\n* 1320_ - Work around Content-Length: 0 and Content-Encoding: gzip gracefully.\n* 1458_ - Panic on busy object.\n* 1417_ - Handle return(abandon) in vcl_backend_response.\n* 1455_ - vcl_pipe now sets Connection: close by default on backend requests.\n* 1454_ - X-Forwarded-For is now done in C, before vcl_recv is run.\n* 1436_ - Better explanation when missing an import in VCL.\n* 1440_ - Serve ESI-includes from a different backend.\n* 1441_ - Incorrect grouping when logging ESI subrequests.\n* 1434_ - std.duration can now do ms/milliseconds.\n* 1419_ - Don't put objcores on the ban list until they go non-BUSY.\n* 1405_ - Ban lurker does not always evict all objects.\n\n.. _1460: https://www.varnish-cache.org/trac/ticket/1460\n.. _1450: https://www.varnish-cache.org/trac/ticket/1450\n.. _1320: https://www.varnish-cache.org/trac/ticket/1320\n.. _1458: https://www.varnish-cache.org/trac/ticket/1458\n.. _1417: https://www.varnish-cache.org/trac/ticket/1417\n.. _1455: https://www.varnish-cache.org/trac/ticket/1455\n.. _1454: https://www.varnish-cache.org/trac/ticket/1454\n.. _1436: https://www.varnish-cache.org/trac/ticket/1436\n.. _1440: https://www.varnish-cache.org/trac/ticket/1440\n.. _1441: https://www.varnish-cache.org/trac/ticket/1441\n.. _1434: https://www.varnish-cache.org/trac/ticket/1434\n.. _1419: https://www.varnish-cache.org/trac/ticket/1419\n.. _1405: https://www.varnish-cache.org/trac/ticket/1405\n\n\n================================================\nChanges from 4.0.0 TP1 to 4.0.0 TP2 (2014-01-23)\n================================================\n\nNew since from 4.0.0 TP1\n------------------------\n\n- New VCL_BLOB type to pass binary data between VMODs.\n- New format for VMOD description files. (.vcc)\n\nBugs fixed\n----------\n* 1404_ - Don't send Content-Length on 304 Not Modified responses.\n* 1401_ - Varnish would crash when retrying a backend fetch too many times.\n* 1399_ - Memory get freed while in use by another thread/object\n* 1398_ - Fix NULL deref related to a backend we don't know any more.\n* 1397_ - Crash on backend fetch while LRUing.\n* 1395_ - End up in vcl_error also if fetch fails vcl_backend_response.\n* 1391_ - Client abort and retry during a streaming fetch would make Varnish assert.\n* 1390_ - Fix assert if the ban lurker is overtaken by new duplicate bans.\n* 1385_ - ban lurker doesn't remove (G)one bans\n* 1383_ - varnishncsa logs requests for localhost regardless of host header.\n* 1382_ - varnishncsa prints nulls as part of request string.\n* 1381_ - Ensure vmod_director is installed\n* 1323_ - Add a missing boundary check for Range requests\n* 1268_ - shortlived parameter now uses TTL+grace+keep instead of just TTL.\n\n* Fix build error on OpenBSD (TCP_KEEP)\n* n_object wasn't being decremented correctly on object expire.\n* Example default.vcl in distribution is now 4.0-ready.\n\nOpen issues\n-----------\n\n* 1405_ - Ban lurker does not always evict all objects.\n\n\n.. _1405: https://www.varnish-cache.org/trac/ticket/1405\n.. _1404: https://www.varnish-cache.org/trac/ticket/1404\n.. _1401: https://www.varnish-cache.org/trac/ticket/1401\n.. _1399: https://www.varnish-cache.org/trac/ticket/1399\n.. _1398: https://www.varnish-cache.org/trac/ticket/1398\n.. _1397: https://www.varnish-cache.org/trac/ticket/1397\n.. _1395: https://www.varnish-cache.org/trac/ticket/1395\n.. _1391: https://www.varnish-cache.org/trac/ticket/1391\n.. _1390: https://www.varnish-cache.org/trac/ticket/1390\n.. _1385: https://www.varnish-cache.org/trac/ticket/1385\n.. _1383: https://www.varnish-cache.org/trac/ticket/1383\n.. _1382: https://www.varnish-cache.org/trac/ticket/1382\n.. _1381: https://www.varnish-cache.org/trac/ticket/1381\n.. _1323: https://www.varnish-cache.org/trac/ticket/1323\n.. _1268: https://www.varnish-cache.org/trac/ticket/1268\n\n\n============================================\nChanges from 3.0.7-rc1 to 3.0.7 (2015-03-23)\n============================================\n\n- No changes.\n\n============================================\nChanges from 3.0.6 to 3.0.7-rc1 (2015-03-18)\n============================================\n\n- Requests with multiple Content-Length headers will now fail.\n\n- Stop recognizing a single CR (\\r) as a HTTP line separator.\n  This opened up a possible cache poisoning attack in stacked installations\n  where sslterminator/varnish/backend had different CR handling.\n\n- Improved error detection on master-child process communication, leading to\n  faster recovery (child restart) if communication loses sync.\n\n- Fix a corner-case where Content-Length was wrong for HTTP 1.0 clients,\n  when using gzip and streaming. Bug 1627_.\n\n- More robust handling of hop-by-hop headers.\n\n- [packaging] Coherent Redhat pidfile in init script. Bug 1690_.\n\n- Avoid memory leak when adding bans.\n\n.. _1627: http://varnish-cache.org/trac/ticket/1627\n.. _1690: http://varnish-cache.org/trac/ticket/1690\n\n\n===========================================\nChanges from 3.0.6rc1 to 3.0.6 (2014-10-16)\n===========================================\n\n- Minor changes to documentation.\n- [varnishadm] Add termcap workaround for libedit. Bug 1531_.\n\n\n===========================================\nChanges from 3.0.5 to 3.0.6rc1 (2014-06-24)\n===========================================\n\n- Document storage.<name>.* VCL variables. Bug 1514_.\n- Fix memory alignment panic when http_max_hdr is not a multiple of 4. Bug 1327_.\n- Avoid negative ReqEnd timestamps with ESI. Bug 1297_.\n- %D format for varnishncsa is now an integer (as documented)\n- Fix compile errors with clang.\n- Clear objectcore flags earlier in ban lurker to avoid spinning thread. Bug 1470_.\n- Patch embedded jemalloc to avoid segfault. Bug 1448_.\n- Allow backend names to start with if, include or else. Bug 1439_.\n- Stop handling gzip after gzip body end. Bug 1086_.\n- Document %D and %T for varnishncsa.\n\n.. _1514: https://www.varnish-cache.org/trac/ticket/1514\n.. _1327: https://www.varnish-cache.org/trac/ticket/1327\n.. _1297: https://www.varnish-cache.org/trac/ticket/1297\n.. _1470: https://www.varnish-cache.org/trac/ticket/1470\n.. _1448: https://www.varnish-cache.org/trac/ticket/1448\n.. _1439: https://www.varnish-cache.org/trac/ticket/1439\n.. _1086: https://www.varnish-cache.org/trac/ticket/1086\n\n\n=============================================\nChanges from 3.0.5 rc 1 to 3.0.5 (2013-12-02)\n=============================================\n\nvarnishd\n--------\n\n- Always check the local address of a socket.  This avoids a crash if\n  server.ip is accessed after a client has closed the connection. `Bug #1376`\n\n.. _bug #1376: https://www.varnish-cache.org/trac/ticket/1376\n\n\n================================\nChanges from 3.0.4 to 3.0.5 rc 1\n================================\n\nvarnishd\n--------\n\n- Stop printing error messages on ESI parse errors\n- Fix a problem where Varnish would segfault if the first part of a\n  synthetic page was NULL.  `Bug #1287`\n- If streaming was used, you could in some cases end up with duplicate\n  content headers being sent to clients. `Bug #1272`\n- If we receive a completely garbled request, don't pass through\n  vcl_error, since we could then end up in vcl_recv through a restart\n  and things would go downhill from there. `Bug #1367`\n- Prettify backtraces on panic slightly.\n\n.. _bug #1287: https://www.varnish-cache.org/trac/ticket/1287\n.. _bug #1272: https://www.varnish-cache.org/trac/ticket/1272\n.. _bug #1367: https://www.varnish-cache.org/trac/ticket/1367\n\nvarnishlog\n----------\n\n- Correct an error where -m, -c and -b would interact badly, leading\n  to lack of matches.  Also, emit BackendXID to signify the start of a\n  transaction. `Bug #1325`\n\n.. _bug #1325: https://www.varnish-cache.org/trac/ticket/1325\n\nvarnishadm\n----------\n\n- Handle input from stdin properly. `Bug #1314`\n\n.. _bug #1314: https://www.varnish-cache.org/trac/ticket/1314\n\n\n=============================================\nChanges from 3.0.4 rc 1 to 3.0.4 (2013-06-14)\n=============================================\n\nvarnishd\n--------\n\n- Set the waiter pipe as non-blocking and record overflows.  `Bug\n  #1285`\n- Fix up a bug in the ACL compile code that could lead to false\n  negatives.  CVE-2013-4090.    `Bug #1312`\n- Return an error if the client sends multiple Host headers.\n\n.. _bug #1285: https://www.varnish-cache.org/trac/ticket/1285\n.. _bug #1312: https://www.varnish-cache.org/trac/ticket/1312\n\n\n================================\nChanges from 3.0.3 to 3.0.4 rc 1\n================================\n\nvarnishd\n--------\n\n- Fix error handling when uncompressing fetched objects for ESI\n  processing. `Bug #1184`\n- Be clearer about which timeout was reached in logs.\n- Correctly decrement n_waitinglist counter.  `Bug #1261`\n- Turn off Nagle/set TCP_NODELAY.\n- Avoid panic on malformed Vary headers.  `Bug #1275`\n- Increase the maximum length of backend names.  `Bug #1224`\n- Add support for banning on http.status.  `Bug #1076`\n- Make hit-for-pass correctly prefer the transient storage.\n\n.. _bug #1076: https://www.varnish-cache.org/trac/ticket/1076\n.. _bug #1184: https://www.varnish-cache.org/trac/ticket/1184\n.. _bug #1224: https://www.varnish-cache.org/trac/ticket/1224\n.. _bug #1261: https://www.varnish-cache.org/trac/ticket/1261\n.. _bug #1275: https://www.varnish-cache.org/trac/ticket/1275\n\n\nvarnishlog\n----------\n\n- If -m, but neither -b or -c is given, assume both.  This filters out\n  a lot of noise when -m is used to filter.  `Bug #1071`\n\n.. _bug #1071: https://www.varnish-cache.org/trac/ticket/1071\n\nvarnishadm\n----------\n\n- Improve tab completion and require libedit/readline to build.\n\nvarnishtop\n----------\n\n- Reopen log file if Varnish is restarted.\n\nvarnishncsa\n-----------\n\n- Handle file descriptors above 64k (by ignoring them).  Prevents a\n  crash in some cases with corrupted shared memory logs.\n- Add %D and %T support for more timing information.\n\nOther\n-----\n\n- Documentation updates.\n- Fixes for OSX\n- Disable PCRE JIT-er, since it's broken in some PCRE versions, at\n  least on i386.\n- Make libvarnish prefer exact hits when looking for VSL tags.\n\n\n========================================\nChanges from 3.0.2 to 3.0.3 (2012-08-20)\n========================================\n\nvarnishd\n--------\n\n- Fix a race on the n_sess counter. This race made varnish do excessive\n  session workspace allocations. `Bug #897`_.\n- Fix some crashes in the gzip code when it runs out of memory. `Bug #1037`_.\n  `Bug #1043`_. `Bug #1044`_.\n- Fix a bug where the regular expression parser could end up in an infinite\n  loop. `Bug #1047`_.\n- Fix a memory leak in the regex code.\n- DNS director now uses port 80 by default if not specified.\n- Introduce `idle_send_timeout` and increase default value for `send_timeout`\n  to 600s. This allows a long send timeout for slow clients while still being\n  able to disconnect idle clients.\n- Fix an issue where <esi:remove> did not remove HTML comments. `Bug #1092`_.\n- Fix a crash when passing with streaming on.\n- Fix a crash in the idle session timeout code.\n- Fix an issue where the poll waiter did not timeout clients if all clients\n  were idle. `Bug #1023`_.\n- Log regex errors instead of crashing.\n- Introduce `pcre_match_limit`, and `pcre_match_limit_recursion` parameters.\n- Add CLI commands to manually control health state of a backend.\n- Fix an issue where the s_bodybytes counter is not updated correctly on\n  gunzipped delivery.\n- Fix a crash when we couldn't allocate memory for a fetched object.\n  `Bug #1100`_.\n- Fix an issue where objects could end up in the transient store with a\n  long TTL, when memory could not be allocated for them in the requested\n  store. `Bug #1140`_.\n- Activate req.hash_ignore_busy when req.hash_always_miss is activated.\n  `Bug #1073`_.\n- Reject invalid tcp port numbers for listen address. `Bug #1035`_.\n- Enable JIT for better performing regular expressions. `Bug #1080`_.\n- Return VCL errors in exit code when using -C. `Bug #1069`_.\n- Stricter validation of acl syntax, to avoid a crash with 5-octet IPv4\n  addresses. `Bug #1126`_.\n- Fix a crash when first argument to regsub was null. `Bug #1125`_.\n- Fix a case where varnish delivered corrupt gzip content when using ESI.\n  `Bug #1109`_.\n- Fix a case where varnish didn't remove the old Date header and served\n  it alongside the varnish-generated Date header. `Bug #1104`_.\n- Make saint mode work, for the case where we have no object with that hash.\n  `Bug #1091`_.\n- Don't save the object body on hit-for-pass objects.\n- n_ban_gone counter added to count the number of \"gone\" bans.\n- Ban lurker rewritten to properly sleep when no bans are present, and\n  otherwise to process the list at the configured speed.\n- Fix a case where varnish delivered wrong content for an uncompressed page\n  with compressed ESI child. `Bug #1029`_.\n- Fix an issue where varnish runs out of thread workspace when processing\n  many ESI includes on an object. `Bug #1038`_.\n- Fix a crash when streaming was enabled for an empty body.\n- Better error reporting for some fetch errors.\n- Small performance optimizations.\n\n.. _bug #897: https://www.varnish-cache.org/trac/ticket/897\n.. _bug #1023: https://www.varnish-cache.org/trac/ticket/1023\n.. _bug #1029: https://www.varnish-cache.org/trac/ticket/1029\n.. _bug #1035: https://www.varnish-cache.org/trac/ticket/1035\n.. _bug #1037: https://www.varnish-cache.org/trac/ticket/1037\n.. _bug #1038: https://www.varnish-cache.org/trac/ticket/1038\n.. _bug #1043: https://www.varnish-cache.org/trac/ticket/1043\n.. _bug #1044: https://www.varnish-cache.org/trac/ticket/1044\n.. _bug #1047: https://www.varnish-cache.org/trac/ticket/1047\n.. _bug #1069: https://www.varnish-cache.org/trac/ticket/1069\n.. _bug #1073: https://www.varnish-cache.org/trac/ticket/1073\n.. _bug #1080: https://www.varnish-cache.org/trac/ticket/1080\n.. _bug #1091: https://www.varnish-cache.org/trac/ticket/1091\n.. _bug #1092: https://www.varnish-cache.org/trac/ticket/1092\n.. _bug #1100: https://www.varnish-cache.org/trac/ticket/1100\n.. _bug #1104: https://www.varnish-cache.org/trac/ticket/1104\n.. _bug #1109: https://www.varnish-cache.org/trac/ticket/1109\n.. _bug #1125: https://www.varnish-cache.org/trac/ticket/1125\n.. _bug #1126: https://www.varnish-cache.org/trac/ticket/1126\n.. _bug #1140: https://www.varnish-cache.org/trac/ticket/1140\n\nvarnishncsa\n-----------\n\n- Support for \\t\\n in varnishncsa format strings.\n- Add new format: %{VCL_Log:foo}x which output key:value from std.log() in\n  VCL.\n- Add user-defined date formatting, using %{format}t.\n\nvarnishtest\n-----------\n\n- resp.body is now available for inspection.\n- Make it possible to test for the absence of an HTTP header. `Bug #1062`_.\n- Log the full panic message instead of shortening it to 512 characters.\n\n.. _bug #1062: https://www.varnish-cache.org/trac/ticket/1062\n\nvarnishstat\n-----------\n\n- Add json output (-j).\n\nOther\n-----\n\n- Documentation updates.\n- Bump minimum number of threads to 50 in RPM packages.\n- RPM packaging updates.\n- Fix some compilation warnings on Solaris.\n- Fix some build issues on Open/Net/DragonFly-BSD.\n- Fix build on FreeBSD 10-current.\n- Fix libedit detection on \\*BSD OSes. `Bug #1003`_.\n\n.. _bug #1003: https://www.varnish-cache.org/trac/ticket/1003\n\n\n=============================================\nChanges from 3.0.2 rc 1 to 3.0.2 (2011-10-26)\n=============================================\n\nvarnishd\n--------\n\n- Make the size of the synthetic object workspace equal to\n  `http_resp_size` and add workaround to avoid a crash when setting\n  too long response strings for synthetic objects.\n\n- Ensure the ban lurker always sleeps the advertised 1 second when it\n  does not have anything to do.\n\n- Remove error from `vcl_deliver`.  Previously this would assert while\n  it will now give a syntax error.\n\nvarnishncsa\n-----------\n\n- Add default values for some fields when logging incomplete records\n  and document the default values.\n\nOther\n-----\n\n- Documentation updates\n\n- Some Solaris portability updates.\n\n\n=============================================\nChanges from 3.0.1 to 3.0.2 rc 1 (2011-10-06)\n=============================================\n\nvarnishd\n--------\n\n- Only log the first 20 bytes of extra headers to prevent overflows.\n\n- Fix crasher bug which sometimes happened if responses are queued and\n  the backend sends us Vary. `Bug #994`_.\n\n- Log correct size of compressed when uncompressing them for clients\n  that do not support compression. `Bug #996`_.\n\n- Only send Range responses if we are going to send a body. `Bug #1007`_.\n\n- When varnishd creates a storage file, also unlink it to avoid\n  leaking disk space over time.  `Bug #1008`_.\n\n- The default size of the `-s file` parameter has been changed to\n  100MB instead of 50% of the available disk space.\n\n- The limit on the number of objects we remove from the cache to make\n  room for a new one was mistakenly lowered to 10 in 3.0.1.  This has\n  been raised back to 50.  `Bug #1012`_.\n\n- `http_req_size` and `http_resp_size` have been increased to 8192\n  bytes.  This better matches what other HTTPds have.   `Bug #1016`_.\n\n.. _bug #994: https://www.varnish-cache.org/trac/ticket/994\n.. _bug #992: https://www.varnish-cache.org/trac/ticket/992\n.. _bug #996: https://www.varnish-cache.org/trac/ticket/996\n.. _bug #1007: https://www.varnish-cache.org/trac/ticket/1007\n.. _bug #1008: https://www.varnish-cache.org/trac/ticket/1008\n.. _bug #1012: https://www.varnish-cache.org/trac/ticket/1012\n.. _bug #1016: https://www.varnish-cache.org/trac/ticket/1016\n\nVCL\n---\n\n- Allow relational comparisons of floating point types.\n\n- Make it possible for VMODs to fail loading and so cause the VCL\n  loading to fail.\n\nvarnishncsa\n-----------\n\n- Fixed crash when client was sending illegal HTTP headers.\n\n- `%{Varnish:handling}` in format strings was broken, this has been\n  fixed.\n\nOther\n-----\n\n- Documentation updates\n\n- Some Solaris portability updates.\n\n\n=============================================\nChanges from 3.0.1 rc 1 to 3.0.1 (2011-08-30)\n=============================================\n\nvarnishd\n--------\n\n- Fix crash in streaming code.\n\n- Add `fallback` director, as a variant of the `round-robin`\n  director.\n\n- The parameter `http_req_size` has been reduced on 32 bit machines.\n\nVCL\n---\n\n- Disallow error in the `vcl_init` and `vcl_fini` VCL functions.\n\nvarnishncsa\n-----------\n\n- Fixed crash when using `-X`.\n\n- Fix error when the time to first byte was in the format string.\n\nOther\n-----\n\n- Documentation updates\n\n\n=============================================\nChanges from 3.0.0 to 3.0.1 rc 1 (2011-08-24)\n=============================================\n\nvarnishd\n--------\n\n- Avoid sending an empty end-chunk when sending bodyless responses.\n\n- `http_resp_hdr_len` and `http_req_hdr_len` were set to too low\n  values leading to clients receiving `HTTP 400 Bad Request` errors.\n  The limit has been increased and the error code is now `HTTP 413\n  Request entity too large`.\n\n- Objects with grace or keep set were mistakenly considered as\n  candidates for the transient storage.  They now have their grace and\n  keep limited to limit the memory usage of the transient stevedore.\n\n- If a request was restarted from `vcl_miss` or `vcl_pass` it would\n  crash.  This has been fixed.  `Bug #965`_.\n\n- Only the first few clients waiting for an object from the backend\n  would be woken up when object arrived and this lead to some clients\n  getting stuck for a long time.  This has now been fixed. `Bug #963`_.\n\n- The `hash` and `client` directors would mistakenly retry fetching an\n  object from the same backend unless health probes were enabled.\n  This has been fixed and it will now retry a different backend.\n\n.. _bug #965: https://www.varnish-cache.org/trac/ticket/965\n.. _bug #963: https://www.varnish-cache.org/trac/ticket/963\n\nVCL\n---\n\n- Request specific variables such as `client.*` and `server.*` are now\n  correctly marked as not available in `vcl_init` and `vcl_fini`.\n\n- The VCL compiler would fault if two IP comparisons were done on the\n  same line.  This now works correctly.  `Bug #948`_.\n\n.. _bug #948: https://www.varnish-cache.org/trac/ticket/948\n\nvarnishncsa\n-----------\n\n- Add support for logging arbitrary request and response headers.\n\n- Fix crashes if `hitmiss` and `handling` have not yet been set.\n\n- Avoid printing partial log lines if there is an error in a format\n  string.\n\n- Report user specified format string errors better.\n\nvarnishlog\n----------\n\n- `varnishlog -r` now works correctly again and no longer opens the\n  shared log file of the running Varnish.\n\nOther\n-----\n\n- Various documentation updates.\n\n- Minor compilation fixes for newer compilers.\n\n- A bug in the ESI entity replacement parser has been fixed.  `Bug\n  #961`_.\n\n- The ABI of VMODs are now checked.  This will require a rebuild of\n  all VMODs against the new version of Varnish.\n\n.. _bug #961: https://www.varnish-cache.org/trac/ticket/961\n\n\n=============================================\nChanges from 3.0 beta 2 to 3.0.0 (2011-06-16)\n=============================================\n\nvarnishd\n--------\n\n- Avoid sending an empty end-chunk when sending bodyless responses.\n\nVCL\n---\n\n- The `synthetic` keyword has now been properly marked as only\n  available in `vcl_deliver`.  `Bug #936`_.\n\n.. _bug #936: https://www.varnish-cache.org/trac/ticket/936\n\nvarnishadm\n----------\n\n- Fix crash if the secret file was unreadable.  `Bug #935`_.\n\n- Always exit if `varnishadm` can't connect to the backend for any\n  reason.\n\n.. _bug #935: https://www.varnish-cache.org/trac/ticket/935\n\n\n=====================================\nChanges from 3.0 beta 1 to 3.0 beta 2\n=====================================\n\nvarnishd\n--------\n\n- thread_pool_min and thread_pool_max now each refer to the number of\n  threads per pool, rather than being inconsistent as they were\n  before.\n\n- 307 Temporary redirect is now considered cacheable.  `Bug #908`_.\n\n- The `stats` command has been removed from the CLI interface.  With\n  the new counters, it would mean implementing more and more of\n  varnishstat in the master CLI process and the CLI is\n  single-threaded so we do not want to do this work there in the first\n  place.  Use varnishstat instead.\n\n.. _bug #908: https://www.varnish-cache.org/trac/ticket/908\n\nVCL\n---\n\n- VCL now treats null arguments (unset headers for instance) as empty\n  strings.  `Bug #913`_.\n\n- VCL now has vcl_init and vcl_fini functions that are called when a\n  given VCL has been loaded and unloaded.\n\n- There is no longer any interpolation of the right hand side in bans\n  where the ban is a single string.  This was confusing and you now\n  have to make sure bits are inside or outside string context as\n  appropriate.\n\n- Varnish is now stricter in enforcing no duplication of probes,\n  backends and ACLs.\n\n.. _bug #913: https://www.varnish-cache.org/trac/ticket/913\n\nvarnishncsa\n-----------\n\n- varnishncsa now ignores piped requests, since we have no way of\n  knowing their return status.\n\nVMODs\n-----\n\n- The std module now has proper documentation, including a manual page\n\n\n================================\nChanges from 2.1.5 to 3.0 beta 1\n================================\n\nUpcoming changes\n----------------\n\n- The interpretation of bans will change slightly between 3.0 beta 1\n  and 3.0 release.  Currently, doing ``ban(\"req.url == req.url\")``\n  will cause the right hand req.url to be interpreted in the context\n  of the request creating the ban.  This will change so you will have\n  to do ``ban(\"req.url == \" + req.url)`` instead.  This syntax already\n  works and is recommended.\n\nvarnishd\n--------\n\n- Add streaming on ``pass`` and ``miss``.  This is controlled by the\n  ``beresp.do_stream`` boolean.  This includes support for\n  compression/uncompression.\n- Add support for ESI and gzip.\n- Handle objects larger than 2G.\n- HTTP Range support is now enabled by default\n- The ban lurker is enabled by default\n- if there is a backend or director with the name ``default``, use\n  that as the default backend, otherwise use the first one listed.\n- Add many more stats counters.  Amongst those, add per storage\n  backend stats and per-backend statistics.\n- Syslog the platform we are running on\n- The ``-l`` (shared memory log file) argument has been changed,\n  please see the varnishd manual for the new syntax.\n- The ``-S`` and ``-T`` arguments are now stored in the shmlog\n- Fix off-by-one error when exactly filling up the workspace.  `Bug #693`_.\n- Make it possible to name storage backends.  The names have to be\n  unique.\n- Update usage output to match the code.  `Bug #683`_\n- Add per-backend health information to shared memory log.\n- Always recreate the shared memory log on startup.\n- Add a ``vcl_dir`` parameter.  This is used to resolve relative path\n  names for ``vcl.load`` and ``include`` in .vcl files.\n- Make it possible to specify ``-T :0``.  This causes varnishd to look\n  for a free port automatically.  The port is written in the shared\n  memory log so varnishadm can find it.\n- Classify locks into kinds and collect stats for each kind,\n  recording the data in the shared memory log.\n- Auto-detect necessary flags for pthread support and ``VCC_CC``\n  flags.  This should make Varnish somewhat happier on Solaris.  `Bug\n  #663`_\n- The ``overflow_max`` parameter has been renamed to ``queue_max``.\n- If setting a parameter fails, report which parameter failed as this\n  is not obvious during startup.\n- Add a parameter named ``shortlived``.  Objects whose TTL is less\n  than the parameter go into transient (malloc) storage.\n- Reduce the default ``thread_add_delay`` to 2ms.\n- The ``max_esi_includes`` parameter has been renamed to\n  ``max_esi_depth``.\n- Hash string components are now logged by default.\n- The default connect timeout parameter has been increased to 0.7\n  seconds.\n- The ``err_ttl`` parameter has been removed and is replaced by a\n  setting in default.vcl.\n- The default ``send_timeout`` parameter has been reduced to 1 minute.\n- The default ``ban_lurker`` sleep has been set to 10ms.\n- When an object is banned, make sure to set its grace to 0 as well.\n- Add ``panic.show`` and ``panic.clear`` CLI commands.\n- The default ``http_resp_hdr_len`` and ``http_req_hdr_len`` has been\n  increased to 2048 bytes.\n- If ``vcl_fetch`` results in ``restart`` or ``error``, close the\n  backend connection rather than fetching the object.\n- If allocating storage for an object, try reducing the chunk size\n  before evicting objects to make room.  `Bug #880`_\n- Add ``restart`` from ``vcl_deliver``.  `Bug #411`_\n- Fix an off-by-up-to-one-minus-epsilon bug where if an object from\n  the backend did not have a last-modified header we would send out a\n  304 response which did include a ``Last-Modified`` header set to\n  when we received the object.  However, we would compare the\n  timestamp to the fractional second we got the object, meaning any\n  request with the exact timestamp would get a ``200`` response rather\n  than the correct ``304``.\n- Fix a race condition in the ban lurker where a serving thread and\n  the lurker would both look at an object at the same time, leading to\n  Varnish crashing.\n- If a backend sends a ``Content-Length`` header and we are streaming and\n  we are not uncompressing it, send the ``Content-Length`` header on,\n  allowing browsers to diplay a progress bar.\n- All storage must be at least 1M large.  This is to prevent\n  administrator errors when specifying the size of storage where the\n  admin might have forgotten to specify units.\n\n.. _bug #693: https://www.varnish-cache.org/trac/ticket/693\n.. _bug #683: https://www.varnish-cache.org/trac/ticket/683\n.. _bug #663: https://www.varnish-cache.org/trac/ticket/663\n.. _bug #880: https://www.varnish-cache.org/trac/ticket/880\n.. _bug #411: https://www.varnish-cache.org/trac/ticket/411\n\nTools\n-----\n\ncommon\n******\n\n- Add an ``-m $tag:$regex`` parameter, used for selecting some\n  transactions.  The parameter can be repeated, in which case it is\n  logically and-ed together.\n\nvarnishadm\n**********\n\n- varnishadm will now pick up the -S and -T arguments from the shared\n  memory log, meaning just running it without any arguments will\n  connect to the running varnish.  `Bug #875`_\n- varnishadm now accepts an -n argument to specify the location of the\n  shared memory log file\n- add libedit support\n\n.. _bug #875: https://www.varnish-cache.org/trac/ticket/875\n\nvarnishstat\n***********\n\n- reopen shared memory log if the varnishd process is restarted.\n- Improve support for selecting some, but not all fields using the\n  ``-f`` argument. Please see the documentation for further details on\n  the use of ``-f``.\n- display per-backend health information\n\nvarnishncsa\n***********\n\n- Report error if called with ``-i`` and ``-I`` as they do not make\n  any sense for varnishncsa.\n- Add custom log formats, specified with ``-F``.  Most of the Apache\n  log formats are supported, as well as some Varnish-specific ones.\n  See the documentation for further information.  `Bug #712`_ and `bug #485`_\n\n.. _bug #712: https://www.varnish-cache.org/trac/ticket/712\n.. _bug #485: https://www.varnish-cache.org/trac/ticket/485\n\nvarnishtest\n***********\n\n- add ``-l`` and ``-L`` switches which leave ``/tmp/vtc.*`` behind on\n  error and unconditionally respectively.\n- add ``-j`` parameter to run tests in parallell and use this by\n  default.\n\nvarnishtop\n**********\n\n- add ``-p $period`` parameter.  The units in varnishtop were\n  previously undefined, they are now in requests/period.  The default\n  period is 60 seconds.\n\nvarnishlog\n**********\n\n- group requests by default.  This can be turned off by using ``-O``\n- the ``-o`` parameter is now a no-op and is ignored.\n\nVMODs\n-----\n\n- Add a std VMOD which includes a random function, log, syslog,\n  fileread, collect,\n\nVCL\n---\n\n- Change string concatenation to be done using ``+`` rather than\n  implicitly.\n- Stop using ``%xx`` escapes in VCL strings.\n- Change ``req.hash += value`` to ``hash_data(value)``\n- Variables in VCL now have distinct read/write access\n- ``bereq.connect_timeout`` is now available in ``vcl_pipe``.\n- Make it possible to declare probes outside of a director. Please see\n  the documentation on how to do this.\n- The VCL compiler has been reworked greatly, expanding its abilities\n  with regards to what kinds of expressions it understands.\n- Add ``beresp.backend.name``, ``beresp.backend.ip`` and\n  ``beresp.backend.port`` variables.  They are only available from\n  ``vcl_fetch`` and are read only.  `Bug #481`_\n- The default VCL now calls pass for any objects where\n  ``beresp.http.Vary == \"*\"``.  `Bug #787`_\n- The ``log`` keyword has been moved to the ``std`` VMOD.\n- It is now possible to choose which storage backend to be used\n- Add variables ``storage.$name.free_space``,\n  ``storage.$name.used_space`` and ``storage.$name.happy``\n- The variable ``req.can_gzip`` tells us whether the client accepts\n  gzipped objects or not.\n- ``purge`` is now called ``ban``, since that is what it really is and\n  has always been.\n- ``req.esi_level`` is now available.  `Bug #782`_\n- esi handling is now controlled by the ``beresp.do_esi`` boolean rather\n  than the ``esi`` function.\n- ``beresp.do_gzip`` and ``beresp.do_gunzip`` now control whether an\n  uncompressed object should be compressed and a compressed object\n  should be uncompressed in the cache.\n- make it possible to control compression level using the\n  ``gzip_level`` parameter.\n- ``obj.cacheable`` and ``beresp.cacheable`` have been removed.\n  Cacheability is now solely through the ``beresp.ttl`` and\n  ``beresp.grace`` variables.\n- setting the ``obj.ttl`` or ``beresp.ttl`` to zero now also sets the\n  corresponding grace to zero.  If you want a non-zero grace, set\n  grace after setting the TTL.\n- ``return(pass)`` in ``vcl_fetch`` has been renamed to\n  ``return(hit_for_pass)`` to make it clear that pass in ``vcl_fetch``\n  and ``vcl_recv`` are different beasts.\n- Add actual purge support.  Doing ``purge`` will remove an object and\n  all its variants.\n\n.. _bug #481: https://www.varnish-cache.org/trac/ticket/481\n.. _bug #787: https://www.varnish-cache.org/trac/ticket/787\n.. _bug #782: https://www.varnish-cache.org/trac/ticket/782\n\n\nLibraries\n---------\n\n- ``libvarnishapi`` has been overhauled and the API has been broken.\n  Please see git commit logs and the support tools to understand\n  what's been changed.\n- Add functions to walk over all the available counters.  This is\n  needed because some of the counter names might only be available at\n  runtime.\n- Limit the amount of time varnishapi waits for a shared memory log\n  to appear before returning an error.\n- All libraries but ``libvarnishapi`` have been moved to a private\n  directory as they are not for public consumption and have no ABI/API\n  guarantees.\n\nOther\n-----\n\n- Python is now required to build\n- Varnish Cache is now consistently named Varnish Cache.\n- The compilation process now looks for kqueue on NetBSD\n- Make it possible to use a system jemalloc rather than the bundled\n  version.\n- The documentation has been improved all over and should now be in\n  much better shape than before\n\n\n========================================\nChanges from 2.1.4 to 2.1.5 (2011-01-25)\n========================================\n\nvarnishd\n--------\n\n-  On pass from vcl\\_recv, we did not remove the backends Content-Length\n   header before adding our own. This could cause confusion for browsers\n   and has been fixed.\n\n-  Make pass with content-length work again. An issue with regards to\n   304, Content-Length and pass has been resolved.\n\n-  An issue relating to passed requests with If-Modified-Since headers\n   has been fixed. Varnish did not recognize that the 304-response did\n   not have a body.\n\n-  A potential lock-inversion with the ban lurker thread has been\n   resolved.\n\n-  Several build-dependency issues relating to rst2man have been fixed.\n   Varnish should now build from source without rst2man if you are using\n   tar-balls.\n\n-  Ensure Varnish reads the expected last CRLF after chunked data from\n   the backend. This allows re-use of the connection.\n\n-  Remove a GNU Make-ism during make dist to make BSD happier.\n\n-  Document the log, set, unset, return and restart statements in the\n   VCL documentation.\n\n-  Fix an embarrassingly old bug where Varnish would run out of\n   workspace when requests come in fast over a single connection,\n   typically during synthetic benchmarks.\n\n-  Varnish will now allow If-Modified-Since requests to objects without\n   a Last-Modified-header, and instead use the time the object was\n   cached instead.\n\n-  Do not filter out Content-Range headers in pass.\n\n-  Require -d, -b, -f, -S or -T when starting varnishd. In human terms,\n   this means that it is legal to start varnishd without a Vcl or\n   backend, but only if you have a CLI channel of some kind.\n\n-  Don't suppress Cache-Control headers in pass responses.\n\n-  Merge multi-line Cache-Control and Vary header fields. Until now, no\n   browsers have needed this, but Chromium seems to find it necessary to\n   spread its Cache-Control across two lines, and we get to deal with\n   it.\n\n-  Make new-purge not touch busy objects. This fixes a potential crash\n   when calling VRT\\_purge.\n\n-  If there are everal grace-able objects, pick the least expired one.\n\n-  Fix an issue with varnishadm -T :6082 shorthand.\n\n-  Add bourn-shell like \"here\" documents on the CLI. Typical usage:\n   vcl.inline vcl\\_new << 42 backend foo {...} sub vcl\\_recv {...} 42\n\n-  Add CLI version to the CLI-banner, starting with version 1.0 to mark\n   here-documents.\n\n-  Fix a problem with the expiry thread slacking off during high load.\n\nvarnishtest\n-----------\n\n-  Remove no longer existing -L option.\n\n\n===========================\nChanges from 2.1.3 to 2.1.4\n===========================\n\nvarnishd\n--------\n\n-  An embarrasing typo in the new binary heap layout caused inflated\n   obj/objcore/objhdr counts and could cause odd problems when the LRU\n   expunge mechanism was invoked. This has been fixed.\n\n-  We now have updated documentation in the reStructuredText format.\n   Manual pages and reference documentation are both built from this.\n\n-  We now include a DNS director which uses DNS for choosing which\n   backend to route requests to. Please see the documentation for more\n   details.\n\n-  If you restarted a request, the HTTP header X-Forwarded-For would be\n   updated multiple times. This has been fixed.\n\n-  If a VCL contained a % sign, and the vcl.show CLI command was used,\n   varnishd would crash. This has been fixed.\n\n-  When doing a pass operation, we would remove the Content-Length, Age\n   and Proxy-Auth headers. We are no longer doing this.\n\n-  now has a string representation, making it easier to construct\n   Expires headers in VCL.\n\n-  In a high traffic environment, we would sometimes reuse a file\n   descriptor before flushing the logs from a worker thread to the\n   shared log buffer. This would cause confusion in some of the tools.\n   This has been fixed by explicitly flushing the log when a backend\n   connection is closed.\n\n-  If the communication between the management and the child process\n   gets out of sync, we have no way to recover. Previously, varnishd\n   would be confused, but we now just kill the child and restart it.\n\n-  If the backend closes the connection on us just as we sent a request\n   to it, we retry the request. This should solve some interoperability\n   problems with Apache and the mpm-itk multi processing module.\n\n-  varnishd now only provides help output the current CLI session is\n   authenticated for.\n\n-  If the backend does not tell us which length indication it is using,\n   we now assume the resource ends EOF at.\n\n-  The client director now has a variable client.identity which is used\n   to choose which backend should receive a given request.\n\n-  The Solaris port waiter has been updated, and other portability fixes\n   for Solaris.\n\n-  There was a corner case in the close-down processing of pipes, this\n   has now been fixed.\n\n-  Previously, if we stopped polling a backend which was sick, it never\n   got marked as healthy. This has now been changed.\n\n-  It is now possible to specify ports as part of the .host field in\n   VCL.\n\n-  The synthetic counters were not locked properly, and so the sms\\_\n   counters could underflow. This has now been fixed.\n\n-  The value of obj.status as a string in vcl\\_error would not be\n   correct in all cases. This has been fixed.\n\n-  Varnish would try to trim storage segments completely filled when\n   using the malloc stevedore and the object was received chunked\n   encoding. This has been fixed.\n\n-  If a buggy backend sends us a Vary header with two colons, we would\n   previously abort. We now rather fix this up and ignore the extra\n   colon.\n\n-  req.hash\\_always\\_miss and req.hash\\_ignore\\_busy has been added, to\n   make preloading or periodically refreshing content work better.\n\nvarnishncsa\n-----------\n\n-  varnishncsa would in some cases be confused by ESI requests and\n   output invalid lines. This has now been fixed.\n\nvarnishlog\n----------\n\n-  varnishlog now allows -o and -u together.\n\nvarnishtop\n----------\n\n-  varnishtop would crash on 32 bit architectures. This has been fixed.\n\nlibvarnishapi\n-------------\n\n-  Regex inclusion and exclusion had problems with matching particular\n   parts of the string being matched. This has been fixed.\n\n\n===========================\nChanges from 2.1.2 to 2.1.3\n===========================\n\nvarnishd\n--------\n\n-  Improve scalability of critbit.\n\n-  The critbit hash algorithm has now been tightened to make sure the\n   tree is in a consistent state at all points, and the time we wait for\n   an object to cool off after it is eligible for garbage collection has\n   been tweaked.\n\n-  Add log command to VCL. This emits a VCL\\_log entry into the shared\n   memory log.\n\n-  Only emit Length and ReqEnd log entries if we actually have an XID.\n   This should get rid of some empty log lines in varnishncsa.\n\n-  Destroy directors in a predictable fashion, namely reverse of\n   creation order.\n\n-  Fix bug when ESI elements spanned storage elements causing a panic.\n\n-  In some cases, the VCL compiler would panic instead of giving\n   sensible messages. This has now been fixed.\n\n-  Correct an off-by-one error when the requested range exceeds the size\n   of an object.\n\n-  Handle requests for the end of an object correctly.\n\n-  Allow tabulator characters in the third field of the first line of\n   HTTP requests\n\n-  On Solaris, if the remote end sends us an RST, all system calls\n   related to that socket will return EINVAL. We now handle this better.\n\nlibvarnishapi\n-------------\n\n-  The -X parameter didn't work correctly. This has been fixed.\n\n\n===========================\nChanges from 2.1.1 to 2.1.2\n===========================\n\nvarnishd\n--------\n\n-  When adding Range support for 2.1.1, we accidentally introduced a\n   bug which would append garbage to objects larger than the chunk size,\n   by default 128k. Browsers would do the right thing due to\n   Content-Length, but some load balancers would get very confused.\n\n\n===========================\nChanges from 2.1.1 to 2.1.1\n===========================\n\nvarnishd\n--------\n\n-  The changelog in 2.1.0 included syntax errors, causing the generated\n   changelog to be empty.\n\n-  The help text for default\\_grace was wrongly formatted and included a\n   syntax error. This has now been fixed.\n\n-  varnishd now closes the file descriptor used to read the management\n   secret file (from the -S parameter).\n\n-  The child would previously try to close every valid file descriptor,\n   something which could cause problems if the file descriptor ulimit\n   was set too high. We now keep track of all the file descriptors we\n   open and only close up to that number.\n\n-  ESI was partially broken in 2.1.0 due to a bug in the rollback of\n   session workspace. This has been fixed.\n\n-  Reject the authcommand rather than crash if there is no -S parameter\n   given.\n\n-  Align pointers in allocated objects. This will in theory make Varnish\n   a tiny bit faster at the expense of slightly more memory usage.\n\n-  Ensure the master process process id is updated in the shared memory\n   log file after we go into the background.\n\n-  HEAD requests would be converted to GET requests too early, which\n   affected pass and pipe. This has been fixed.\n\n-  Update the documentation to point out that the TTL is no longer taken\n   into account to decide whether an object is cacheable or not.\n\n-  Add support for completely obliterating an object and all variants of\n   it. Currently, this has to be done using inline C.\n\n-  Add experimental support for the Range header. This has to be enabled\n   using the parameter http\\_range\\_support.\n\n-  The critbit hasher could get into a deadlock and had a race\n   condition. Both those have now been fixed.\n\nvarnishsizes\n-----------~\n\n-  varnishsizes, which is like varnishhist, but for the length of\n   objects, has been added..\n\n\n===========================\nChanges from 2.0.6 to 2.1.0\n===========================\n\nvarnishd\n--------\n\n-  Persistent storage is now experimentally supported using the\n   persistent stevedore. It has the same command line arguments as the\n   file stevedore.\n\n-  obj.\\* is now called beresp.\\* in vcl\\_fetch, and obj.\\* is now\n   read-only.\n\n-  The regular expression engine is now PCRE instead of POSIX regular\n   expressions.\n\n-  req.\\* is now available in vcl\\_deliver.\n\n-  Add saint mode where we can attempt to grace an object if we don't\n   like the backend response for some reason.\n\n   Related, add saintmode\\_threshold which is the threshold for the\n   number of objects to be added to the trouble list before the backend\n   is considered sick.\n\n-  Add a new hashing method called critbit. This autoscales and should\n   work better on large object workloads than the classic hash. Critbit\n   has been made the default hash algorithm.\n\n-  When closing connections, we experimented with sending RST to free up\n   load balancers and free up threads more quickly. This caused some\n   problems with NAT routers and so has been reverted for now.\n\n-  Add thread that checks objects against ban list in order to prevent\n   ban list from growing forever. Note that this needs purges to be\n   written so they don't depend on req.\\*. Enabled by setting\n   ban\\_lurker\\_sleep to a nonzero value.\n\n-  The shared memory log file format was limited to maximum 64k\n   simultaneous connections. This is now a 32 bit field which removes\n   this limitation.\n\n-  Remove obj\\_workspace, this is now sized automatically.\n\n-  Rename acceptors to waiters\n\n-  vcl\\_prefetch has been removed. It was never fully implemented.\n\n-  Add support for authenticating CLI connections.\n\n-  Add hash director that chooses which backend to use depending on\n   req.hash.\n\n-  Add client director that chooses which backend to use depending on\n   the client's IP address. Note that this ignores the X-Forwarded-For\n   header.\n\n-  varnishd now displays a banner by default when you connect to the\n   CLI.\n\n-  Increase performance somewhat by moving statistics gathering into a\n   per-worker structure that is regularly flushed to the global stats.\n\n-  Make sure we store the header and body of object together. This may\n   in some cases improve performance and is needed for persistence.\n\n-  Remove client-side address accounting. It was never used for anything\n   and presented a performance problem.\n\n-  Add a timestamp to bans, so you can know how old they are.\n\n-  Quite a few people got confused over the warning about not being able\n   to lock the shared memory log into RAM, so stop warning about that.\n\n-  Change the default CLI timeout to 10 seconds.\n\n-  We previously forced all inserts into the cache to be GET requests.\n   This has been changed to allow POST as well in order to be able to\n   implement purge-on-POST semantics.\n\n-  The CLI command stats now only lists non-zero values.\n\n-  The CLI command stats now only lists non-zero values.\n\n-  Use daemon(3) from libcompat on Darwin.\n\n-  Remove vcl\\_discard as it causes too much complexity and never\n   actually worked particularly well.\n\n-  Remove vcl\\_timeout as it causes too much complexity and never\n   actually worked particularly well.\n\n-  Update the documentation so it refers to sess\\_workspace, not\n   http\\_workspace.\n\n-  Document the -i switch to varnishd as well as the server.identity and\n   server.hostname VCL variables.\n\n-  purge.hash is now deprecated and no longer shown in help listings.\n\n-  When processing ESI, replace the five mandatory XML entities when we\n   encounter them.\n\n-  Add string representations of time and relative time.\n\n-  Add locking for n\\_vbe\\_conn to make it stop underflowing.\n\n-  When ESI-processing content, check for illegal XML character\n   entities.\n\n-  Varnish can now connect its CLI to a remote instance when starting\n   up, rather than just being connected to.\n\n-  It is no longer needed to specify the maximum number of HTTP headers\n   to allow from backends. This is now a run-time parameter.\n\n-  The X-Forwarded-For header is now generated by vcl\\_recv rather than\n   the C code.\n\n-  It is now possible to not send all CLI traffic to syslog.\n\n-  It is now possible to not send all CLI traffic to syslog.\n\n-  In the case of varnish crashing, it now outputs a identifying string\n   with the OS, OS revision, architecture and storage parameters\n   together with the backtrace.\n\n-  Use exponential backoff when we run out of file descriptors or\n   sessions.\n\n-  Allow setting backend timeouts to zero.\n\n-  Count uptime in the shared memory log.\n\n-  Try to detect the case of two running varnishes with the same shmlog\n   and storage by writing the master and child process ids to the shmlog\n   and refusing to start if they are still running.\n\n-  Make sure to use EOF mode when serving ESI content to HTTP/1.0\n   clients.\n\n-  Make sure we close the connection if it either sends Connection:\n   close or it is a HTTP/1.0 backend that does not send Connection:\n   keep-alive.\n\n-  Increase the default session workspace to 64k on 64-bit systems.\n\n-  Make the epoll waiter use level triggering, not edge triggering as\n   edge triggering caused problems on very busy servers.\n\n-  Handle unforeseen client disconnections better on Solaris.\n\n-  Make session lingering apply to new sessions, not just reused\n   sessions.\n\nvarnishstat\n-----------\n\n-  Make use of the new uptime field in the shared memory log rather than\n   synthesizing it from the start time.\n\nvarnishlog\n----------\n\n-  Exit at the end of the file when started with -d.\n\nvarnishadm\n----------\n\n-  varnishadm can now have a timeout when trying to connect to the\n   running varnishd.\n\n-  varnishadm now knows how to respond to the secret from a secured\n   varnishd\n\n\n===========================\nChanges from 2.0.5 to 2.0.6\n===========================\n\nvarnishd\n--------\n\n-  2.0.5 had an off-by-one error in the ESI handling causing includes to\n   fail a large part of the time. This has now been fixed.\n\n-  Try harder to not confuse backends when sending them backend probes.\n   We half-closed the connection, something some backends thought meant\n   we had dropped the connection. Stop doing so, and add the capability\n   for specifying the expected response code.\n\n-  In 2.0.5, session lingering was turned on. This caused statistics to\n   not be counted often enough in some cases. This has now been fixed.\n\n-  Avoid triggering an assert if the other end closes the connection\n   while we are lingering and waiting for another request from them.\n\n-  When generating backtraces, prefer the built-in backtrace function if\n   such exists. This fixes a problem compiling 2.0.5 on Solaris.\n\n-  Make it possible to specify the per-thread stack size. This might be\n   useful on 32 bit systems with their limited address space.\n\n-  Document the -C option to varnishd.\n\n\n===========================\nChanges from 2.0.4 to 2.0.5\n===========================\n\nvarnishd\n--------\n\n-  Handle object workspace overruns better.\n\n-  Allow turning off ESI processing per request by using set req.esi =\n   off.\n\n-  Tell the kernel that we expect to use the mmap-ed file in a random\n   fashion. On Linux, this turns off/down readahead and increases\n   performance.\n\n-  Make it possible to change the maximum number of HTTP headers we\n   allow by passing --with-max-header-fields=NUM rather than changing\n   the code.\n\n-  Implement support for HTTP continuation lines.\n\n-  Change how connections are closed and only use SO\\_LINGER for orderly\n   connection closure. This should hopefully make worker threads less\n   prone to hangups on network problems.\n\n-  Handle multi-element purges correctly. Previously we ended up with\n   parse errors when this was done from VCL.\n\n-  Handle illegal responses from the backend better by serving a 503\n   page rather than panic-ing.\n\n-  When we run into an assertion that is not true, Varnish would\n   previously dump a little bit of information about itself. Extend that\n   information with a backtrace. Note that this relies on the varnish\n   binary being unstripped.\n\n-  Add a session\\_max parameter that limits the maximum number of\n   sessions we keep open before we start dropping new connections\n   summarily.\n\n-  Try to consume less memory when doing ESI processing by properly\n   rolling back used workspace after processing an object. This should\n   make it possible to turn sess\\_workspace quite a bit for users with\n   ESI-heavy pages.\n\n-  Turn on session\\_linger by default. Tests have shown that\n   session\\_linger helps a fair bit with performance.\n\n-  Rewrite the epoll acceptor for better performance. This should lead\n   to both higher processing rates and maximum number of connections on\n   Linux.\n\n-  Add If-None-Match support, this gives significant bandwidth savings\n   for users with compliant browsers.\n\n-  RFC2616 specifies that ETag, Content-Location, Expires, Cache-Control\n   and Vary should be emitted when delivering a response with the 304\n   response code.\n\n-  Various fixes which makes Varnish compile and work on AIX.\n\n-  Turn on TCP\\_DEFER\\_ACCEPT on Linux. This should make us less\n   suspecible to denial of service attacks as well as give us slightly\n   better performance.\n\n-  Add an .initial property to the backend probe specification. This is\n   the number of good probes we pretend to have seen. The default is one\n   less than .threshold, which means the first probe will decide if we\n   consider the backend healthy.\n\n-  Make it possible to compare strings against other string-like\n   objects, not just plain strings. This allows you to compare two\n   headers, for instance.\n\n-  When support for restart in vcl\\_error was added, there was no check\n   to prevent infinte recursion. This has now been fixed.\n\n-  Turn on purge\\_dups by default. This should make us consume less\n   memory when there are many bans for the same pattern added.\n\n-  Add a new log tag called FetchError which tries to explain why we\n   could not fetch an object from the backend.\n\n-  Change the default srcaddr\\_ttl to 0. It is not used by anything and\n   has been removed in the development version. This will increase\n   performance somewhat.\n\nvarnishtop\n----------\n\n-  varnishtop did not handle variable-length log fields correctly. This\n   is now fixed.\n\n-  varnishtop previously did not print the name of the tag, which made\n   it very hard to understand. We now print out the tag name.\n\n\n===========================\nChanges from 2.0.3 to 2.0.4\n===========================\n\nvarnishd\n--------\n\n-  Make Varnish more portable by pulling in fixes for Solaris and\n   NetBSD.\n\n-  Correct description of -a in the manual page.\n\n-  Ensure we are compiling in C99 mode.\n\n-  If error was called with a null reason, we would crash on Solaris.\n   Make sure this no longer happens.\n\n-  Varnish used to crash if you asked it to use a non-existent waiter.\n   This has now been fixed.\n\n-  Add documentation to the default VCL explaining that using\n   Connection: close in vcl\\_pipe is generally a good idea.\n\n-  Add minimal facility for dealing with TELNET option negotiation by\n   returning WONT to DO and DONT requests.\n\n-  If the backend is unhealthy, use a graced object if one is available.\n\n-  Make server.hostname and server.identity available to VCL. The latter\n   can be set with the -i parameter to varnishd.\n\n-  Make restart available from vcl\\_error.\n\n-  Previously, only the TTL of an object was considered in whether it\n   would be marked as cacheable. This has been changed to take the grace\n   into consideration as well.\n\n-  Previously, if an included ESI fragment had a zero size, we would\n   send out a zero-sized chunk which signifies end-of-transmission. We\n   now ignore zero-sized chunks.\n\n-  We accidentally slept for far too long when we reached the maximum\n   number of open file descriptors. This has been corrected and\n   accept\\_fd\\_holdoff now works correctly.\n\n-  Previously, when ESI processing, we did not look at the full length,\n   but stopped at the first NULL byte. We no longer do that, enabling\n   ESI processing of binary data.\n\nvarnishtest\n-----------\n\n-  Make sure system \"...\" returns successfully to ensure test failures\n   do not go unnoticed.\n\n-  Make it possible to send NULL bytes through the testing framework.\n\n\n===========================\nChanges from 2.0.2 to 2.0.3\n===========================\n\nvarnishd\n--------\n\n-  Handle If-Modified-Since and ESI sub-objects better, fixing a problem\n   where we sometimes neglected to insert included objects.\n\n-  restart in vcl\\_hit is now supported.\n\n-  Setting the TTL of an object to 0 seconds would sometimes cause it to\n   be delivered for up to one second - epsilon. This has been corrected\n   and we should now never deliver those objects to other clients.\n\n-  The malloc storage backend now prints the maximum storage size, just\n   like the file backend.\n\n-  Various small documentation bugs have been fixed.\n\n-  Varnish did not set a default interval for backend probes, causing it\n   to poll the backend continuously. This has been corrected.\n\n-  Allow \"true\" and \"false\" when setting boolean parameters, in addition\n   to on/off, enable/disable and yes/no.\n\n-  Default to always talking HTTP 1.1 with the backend.\n\n-  Varnish did not make sure the file it was loading was a regular file.\n   This could cause Varnish to crash if it was asked to load a directory\n   or other non-regular file. We now check that the file is a regular\n   file before loading it.\n\n-  The binary heap used for expiry processing had scalability problems.\n   Work around this by using stripes of a fixed size, which should make\n   this scale better, particularly when starting up and having lots of\n   objects.\n\n-  When we imported the jemalloc library into the Varnish tree, it did\n   not compile without warnings. This has now been fixed.\n\n-  Varnish took a very long time to detect that the backend did not\n   respond. To remedy this, we now have read timeouts in addition to the\n   connect timeout. Both the first\\_byte\\_timeout and the\n   between\\_bytes\\_timeout defaults to 60 seconds. The connect timeout\n   is no longer in milliseconds, but rather in seconds.\n\n-  Previously, the VCL to C conversion as well as the invocation of the\n   C compiler was done in the management process. This is now done in a\n   separate sub-process. This prevents any bugs in the VCL compiler from\n   affecting the management process.\n\n-  Chunked encoding headers were counted in the statistics for header\n   bytes. They no longer are.\n\n-  ESI processed objects were not counted in the statistics for body\n   bytes. They now are.\n\n-  It is now possible to adjust the maximum record length of log entries\n   in the shmlog by tuning the shm\\_reclen parameter.\n\n-  The management parameters listed in the CLI were not sorted, which\n   made it hard to find the parameter you were looking for. They are now\n   sorted, which should make this easier.\n\n-  Add a new hashing type, \"critbit\", which uses a lock-less tree based\n   lookup algorithm. This is experimental and should not be enabled in\n   production environments without proper testing.\n\n-  The session workspace had a default size of 8k. It is now 16k, which\n   should make VCLs where many headers are processed less prone to\n   panics.\n\n-  We have seen that people seem to be confused as to which actions in\n   the different VCL functions return and which ones don't. Add a new\n   syntax return(action) to make this more explicit. The old syntax is\n   still supported.\n\n-  Varnish would return an error if any of the management IPs listed in\n   the -T parameter could not be listened to. We now only return an\n   error if none of them can be listened to.\n\n-  In the case of the backend or client giving us too many parameters,\n   we used to just ignore the overflowing headers. This is problematic\n   if you end up ignoreing Content-Length, Transfer-Encoding and similar\n   headers. We now give out a 400 error to the client if it sends us too\n   many and 503 if we get too many from the backend.\n\n-  We used panic if we got a too large chunked header. This behaviour\n   has been changed into just failing the transaction.\n\n-  Varnish now supports an extended purge method where it is possible to\n   do purge req.http.host ~ \"web1.com\" && req.url ~ \"\\\\.png\" and\n   similar. See the documentation for details.\n\n-  Under heavy load, Varnish would sometimes crash when trying to update\n   the per-request statistics. This has now been fixed.\n\n-  It is now possible to not save the hash string in the session and\n   object workspace. This will save a lot of memory on sites with many\n   small objects. Disabling the purge\\_hash parameter also disables the\n   purge.hash facility.\n\n-  Varnish now supports !~ as a \"no match\" regular expression matcher.\n\n-  In some cases, you could get serialised access to \"pass\" objects. We\n   now make it default to the default\\_ttl value; this can be overridden\n   in vcl\\_fetch.\n\n-  Varnish did not check the syntax of regsub calls properly. More\n   checking has been added.\n\n-  If the client closed the connection while Varnish was processing ESI\n   elements, Varnish would crash while trying to write the object to the\n   client. We now check if the client has closed the connection.\n\n-  The ESI parser had a bug where it would crash if an XML comment would\n   span storage segments. This has been fixed.\n\nVCL Manual page\n--------------~\n\n-  The documentation on how capturing parentheses work was wrong. This\n   has been corrected.\n\n-  Grace has now been documented.\n\nvarnishreplay\n-------------\n\n-  varnishreplay did not work correctly on Linux, due to a too small\n   stack. This has now been fixed.\n\n\n===========================\nChanges from 2.0.1 to 2.0.2\n===========================\n\nvarnishd\n--------\n\n-  In high-load situations, when using ESI, varnishd would sometimes\n   mishandle objects and crash. This has been worked around.\n\nvarnishreplay\n-------------\n\n-  varnishreplay did not work correctly on Linux, due to a too small\n   stack. This has now been fixed.\n\n\n=========================\nChanges from 2.0 to 2.0.1\n=========================\n\nvarnishd\n--------\n\n-  When receiving a garbled HTTP request, varnishd would sometimes\n   crash. This has been fixed.\n\n-  There was an off-by-one error in the ACL compilation. Now fixed.\n\nRed Hat spec file\n----------------~\n\n-  A typo in the spec file made the .rpm file names wrong.\n\n\n=========================\nChanges from 1.1.2 to 2.0\n=========================\n\nvarnishd\n--------\n\n-  Only look for sendfile on platforms where we know how to use it,\n   which is FreeBSD for now.\n\n-  Make it possible to adjust the shared memory log size and bump the\n   size from 8MB to 80MB.\n\n-  Fix up the handling of request bodies to better match what RFC2616\n   mandates. This makes PUT, DELETE, OPTIONS and TRACE work in addition\n   to POST.\n\n-  Change how backends are defined, to a constant structural defintion\n   style. See https://www.varnish-cache.org/wiki/VclSyntaxChanges\n   for the details.\n\n-  Add directors, which wrap backends. Currently, there's a random\n   director and a round-robin director.\n\n-  Add \"grace\", which is for how long and object will be served, even\n   after it has expired. To use this, both the object's and the\n   request's grace parameter need to be set.\n\n-  Manual pages have been updated for new VCL syntax and varnishd\n   options.\n\n-  Man pages and other docs have been updated.\n\n-  The shared memory log file is now locked in memory, so it should not\n   be paged out to disk.\n\n-  We now handle Vary correctly, as well as Expect.\n\n-  ESI include support is implemented.\n\n-  Make it possible to limit how much memory the malloc uses.\n\n-  Solaris is now supported.\n\n-  There is now a regsuball function, which works like regsub except it\n   replaces all occurrences of the regex, not just the first.\n\n-  Backend and director declarations can have a .connect\\_timeout\n   parameter, which tells us how long to wait for a successful\n   connection.\n\n-  It is now possible to select the acceptor to use by changing the\n   acceptor parameter.\n\n-  Backends can have probes associated with them, which can be checked\n   with req.backend.health in VCL as well as being handled by directors\n   which do load-balancing.\n\n-  Support larger-than-2GB files also on 32 bit hosts. Please note that\n   this does not mean we can support caches bigger than 2GB, it just\n   means logfiles and similar can be bigger.\n\n-  In some cases, we would remove the wrong header when we were\n   stripping Content-Transfer-Encoding headers from a request. This has\n   been fixed.\n\n-  Backends can have a .max\\_connections associated with them.\n\n-  On Linux, we need to set the dumpable bit on the child if we want\n   core dumps. Make sure it's set.\n\n-  Doing purge.hash() with an empty string would cause us to dump core.\n   Fixed so we don't do that any more.\n\n-  We ran into a problem with glibc's malloc on Linux where it seemed\n   like it failed to ever give memory back to the OS, causing the system\n   to swap. We have now switched to jemalloc which appears not to have\n   this problem.\n\n-  max\\_restarts was never checked, so we always ended up running out of\n   workspace. Now, vcl\\_error is called when we reach max\\_restarts.\n\nvarnishtest\n-----------\n\n-  varnishtest is a tool to do correctness tests of varnishd. The test\n   suite is run by using make check.\n\nvarnishtop\n----------\n\n-  We now set the field widths dynamically based on the size of the\n   terminal and the name of the longest field.\n\nvarnishstat\n-----------\n\n-  varnishstat -1 now displays the uptime too.\n\nvarnishncsa\n-----------\n\n-  varnishncsa now does fflush after each write. This makes tail -f work\n   correctly, as well as avoiding broken lines in the log file.\n\n-  It is possible to get varnishncsa to output the X-Forwarded-For\n   instead of the client IP by passing -f to it.\n\nBuild system\n-----------~\n\n-  Various sanity checks have been added to configure, it now complains\n   about no ncurses or if SO\\_RCVTIMEO or SO\\_SNDTIMEO are\n   non-functional. It also aborts if there's no working acceptor\n   mechanism\n\n-  The C compiler invocation is decided by the configure script and can\n   now be overridden by passing VCC\\_CC when running configure.\n\n\n===========================\nChanges from 1.1.1 to 1.1.2\n===========================\n\nvarnishd\n--------\n\n-  When switching to a new VCL configuration, a race condition exists\n   which may cause Varnish to reference a backend which no longer exists\n   (see `ticket #144 <https://www.varnish-cache.org/trac/ticket/144>`_).\n   This race condition has not been entirely eliminated, but it should\n   occur less frequently.\n\n-  When dropping a TCP session before any requests were processed, an\n   assertion would be triggered due to an uninitialized timestamp (see\n   `ticket #132 <https://www.varnish-cache.org/trac/ticket/132>`_). The\n   timestamp is now correctly initialized.\n\n-  Varnish will now correctly generate a Date: header for every response\n   instead of copying the one it got from the backend (see `ticket\n   #157 <https://www.varnish-cache.org/trac/ticket/157>`_).\n\n-  Comparisons in VCL which involve a non-existent string (usually a\n   header which is not present in the request or object being processed)\n   would cause a NULL pointer dereference; now the comparison will\n   simply fail.\n\n-  A bug in the VCL compiler which would cause a double-free when\n   processing include directives has been fixed.\n\n-  A resource leak in the worker thread management code has been fixed.\n\n-  When connecting to a backend, Varnish will usually get the address\n   from a cache. When the cache is refreshed, existing connections may\n   end up with a reference to an address structure which no longer\n   exists, resulting in a crash. This race condition has been somewhat\n   mitigated, but not entirely eliminated (see `ticket\n   #144 <https://www.varnish-cache.org/trac/ticket/144>`_.)\n\n-  Varnish will now pass the correct protocol version in pipe mode: the\n   backend will get what the client sent, and vice versa.\n\n-  The core of the pipe mode code has been rewritten to increase\n   robustness and eliminate spurious error messages when either end\n   closes the connection in a manner Varnish did not anticipate.\n\n-  A memory leak in the backend code has been plugged.\n\n-  When using the kqueue acceptor, if a client shuts down the request\n   side of the connection (as many clients do after sending their final\n   request), it was possible for the acceptor code to receive the EOF\n   event and recycle the session while the last request was still being\n   serviced, resulting in a assertion failure and a crash when the\n   worker thread later tried to delete the session. This should no\n   longer happen (see `ticket\n   #162 <https://www.varnish-cache.org/trac/ticket/162>`_.)\n\n-  A mismatch between the recorded length of a cached object and the\n   amount of data actually present in cache for that object can\n   occasionally occur (see `ticket\n   #167 <https://www.varnish-cache.org/trac/ticket/167>`_.) This has been\n   partially fixed, but may still occur for error pages generated by\n   Varnish when a problem arises while retrieving an object from the\n   backend.\n\n-  Some socket-related system calls may return unexpected error codes\n   when operating on a TCP connection that has been shut down at the\n   other end. These error codes would previously cause assertion\n   failures, but are now recognized as harmless conditions.\n\nvarnishhist\n-----------\n\n-  Pressing 0 though 9 while varnishhist is running will change the\n   refresh interval to the corresponding power of two, in seconds.\n\nvarnishncsa\n-----------\n\n-  The varnishncsa tool can now daemonize and write a PID file like\n   varnishlog, using the same command-line options. It will also reopen\n   its output upon receipt of a SIGHUP if invoked with -w.\n\nvarnishstat\n-----------\n\n-  Pressing 0 though 9 while varnishstat is running will change the\n   refresh interval to the corresponding power of two, in seconds.\n\nBuild system\n-----------~\n\n-  Varnish's <queue.h> has been modified to avoid conflicts with\n   <sys/queue.h> on platforms where the latter is included indirectly\n   through system headers.\n\n-  Several steps have been taken towards Solaris support, but this is\n   not yet complete.\n\n-  When configure was run without an explicit prefix, Varnish's idea of\n   the default state directory would be garbage and a state directory\n   would have to be specified manually with -n. This has been corrected.\n\n\n=========================\nChanges from 1.1 to 1.1.1\n=========================\n\nvarnishd\n--------\n\n-  The code required to allow VCL to read obj.status, which had\n   accidentally been left out, has now been added.\n\n-  Varnish will now always include a Connection: header in its reply to\n   the client, to avoid possible misunderstandings.\n\n-  A bug that triggered an assertion failure when generating synthetic\n   error documents has been corrected.\n\n-  A new VCL function, purge\\_url, provides the same functionality as\n   the url.purge management command.\n\n-  Previously, Varnish assumed that the response body should be sent\n   only if the request method was GET. This was a problem for custom\n   request methods (such as PURGE), so the logic has been changed to\n   always send the response body except in the specific case of a HEAD\n   request.\n\n-  Changes to run-time parameters are now correctly propagated to the\n   child process.\n\n-  Due to the way run-time parameters are initialized at startup,\n   varnishd previously required the nobody user and the nogroup group to\n   exist even if a different user and group were specified on the\n   command line. This has been corrected.\n\n-  Under certain conditions, the VCL compiler would carry on after a\n   syntax error instead of exiting after reporting the error. This has\n   been corrected.\n\n-  The manner in which the hash string is assembled has been modified to\n   reduce memory usage and memory-to-memory copying.\n\n-  Before calling vcl\\_miss, Varnish assembles a tentative request\n   object for the backend request which will usually follow. This object\n   would be leaked if vcl\\_miss returned anything else than fetch. This\n   has been corrected.\n\n-  The code necessary to handle an error return from vcl\\_fetch and\n   vcl\\_deliver had inadvertantly been left out. This has been\n   corrected.\n\n-  Varnish no longer prints a spurious \"child died\" message (the result\n   of reaping the compiler process) after compiling a new VCL\n   configuration.\n\n-  Under some circumstances, due to an error in the workspace management\n   code, Varnish would lose the \"tail\" of a request, i.e. the part of\n   the request that has been received from the client but not yet\n   processed. The most obvious symptom of this was that POST requests\n   would work with some browsers but not others, depending on details of\n   the browser's HTTP implementation. This has been corrected.\n\n-  On some platforms, due to incorrect assumptions in the CLI code, the\n   management process would crash while processing commands received\n   over the management port. This has been corrected.\n\nBuild system\n-----------~\n\n-  The top-level Makefile will now honor $DESTDIR when creating the\n   state directory.\n\n-  The Debian and RedHat packages are now split into three (main / lib /\n   devel) as is customary.\n\n-  A number of compile-time and run-time portability issues have been\n   addressed.\n\n-  The autogen.sh script had workarounds for problems with the GNU\n   autotools on FreeBSD; these are no longer needed and have been\n   removed.\n\n-  The libcompat library has been renamed to libvarnishcompat and is now\n   dynamic rather than static. This simplifies the build process and\n   resolves an issue with the Mac OS X linker.\n\n\n=========================\nChanges from 1.0.4 to 1.1\n=========================\n\nvarnishd\n--------\n\n-  Readability of the C source code generated from VCL code has been\n   improved.\n\n-  Equality (==) and inequality (!=) operators have been implemented for\n   IP addresses (which previously could only be compared using ACLs).\n\n-  The address of the listening socket on which the client connection\n   was received is now available to VCL as the server.ip variable.\n\n-  Each object's hash key is now computed based on a string which is\n   available to VCL as req.hash. A VCL hook named vcl\\_hash has been\n   added to allow VCL scripts to control hash generation (for instance,\n   whether or not to include the value of the Host: header in the hash).\n\n-  The setup code for listening sockets has been modified to detect and\n   handle situations where a host name resolves to multiple IP\n   addresses. It will now attempt to bind to each IP address separately,\n   and report a failure only if none of them worked.\n\n-  Network or protocol errors that occur while retrieving an object from\n   a backend server now result in a synthetic error page being inserted\n   into the cache with a 30-second TTL. This should help avoid driving\n   an overburdened backend server into the ground by repeatedly\n   requesting the same object.\n\n-  The child process will now drop root privileges immediately upon\n   startup. The user and group to use are specified with the user and\n   group run-time parameters, which default to nobody and nogroup,\n   respectively. Other changes have been made in an effort to increase\n   the isolation between parent and child, and reduce the impact of a\n   compromise of the child process.\n\n-  Objects which are received from the backend with a Vary: header are\n   now stored separately according to the values of the headers\n   specified in Vary:. This allows Varnish to correctly cache e.g.\n   compressed and uncompressed versions of the same object.\n\n-  Each Varnish instance now has a name, which by default is the host\n   name of the machine it runs on, but can be any string that would be\n   valid as a relative or absolute directory name. It is used to\n   construct the name of a directory in which the server state as well\n   as all temporary files are stored. This makes it possible to run\n   multiple Varnish instances on the same machine without conflict.\n\n-  When invoked with the -C option, varnishd will now not just translate\n   the VCL code to C, but also compile the C code and attempt to load\n   the resulting shared object.\n\n-  Attempts by VCL code to reference a variable outside its scope or to\n   assign a value to a read-only variable will now result in\n   compile-time rather than run-time errors.\n\n-  The new command-line option -F will make varnishd run in the\n   foreground, without enabling debugging.\n\n-  New VCL variables have been introduced to allow inspection and\n   manipulation of the request sent to the backend (bereq.request,\n   bereq.url, bereq.proto and bereq.http) and the response to the client\n   (resp.proto, resp.status, resp.response and resp.http).\n\n-  Statistics from the storage code (including the amount of data and\n   free space in the cache) are now available to varnishstat and other\n   statistics-gathering tools.\n\n-  Objects are now kept on an LRU list which is kept loosely up-to-date\n   (to within a few seconds). When cache runs out, the objects at the\n   tail end of the LRU list are discarded one by one until there is\n   enough space for the freshly requested object(s). A VCL hook,\n   vcl\\_discard, is allowed to inspect each object and determine its\n   fate by returning either keep or discard.\n\n-  A new VCL hook, vcl\\_deliver, provides a chance to adjust the\n   response before it is sent to the client.\n\n-  A new management command, vcl.show, displays the VCL source code of\n   any loaded configuration.\n\n-  A new VCL variable, now, provides VCL scripts with the current time\n   in seconds since the epoch.\n\n-  A new VCL variable, obj.lastuse, reflects the time in seconds since\n   the object in question was last used.\n\n-  VCL scripts can now add an HTTP header (or modify the value of an\n   existing one) by assigning a value to the corresponding variable, and\n   strip an HTTP header by using the remove keyword.\n\n-  VCL scripts can now modify the HTTP status code of cached objects\n   (obj.status) and responses (resp.status)\n\n-  Numeric and other non-textual variables in VCL can now be assigned to\n   textual variables; they will be converted as needed.\n\n-  VCL scripts can now apply regular expression substitutions to textual\n   variables using the regsub function.\n\n-  A new management command, status, returns the state of the child.\n\n-  Varnish will now build and run on Mac OS X.\n\nvarnishadm\n----------\n\n-  This is a new utility which sends a single command to a Varnish\n   server's management port and prints the result to stdout, greatly\n   simplifying the use of the management port from scripts.\n\nvarnishhist\n-----------\n\n-  The user interface has been greatly improved; the histogram will be\n   automatically rescaled and redrawn when the window size changes, and\n   it is updated regularly rather than at a rate dependent on the amount\n   of log data gathered. In addition, the name of the Varnish instance\n   being watched is displayed in the upper right corner.\n\nvarnishncsa\n-----------\n\n-  In addition to client traffic, varnishncsa can now also process log\n   data from backend traffic.\n\n-  A bug that would cause varnishncsa to segfault when it encountered an\n   empty HTTP header in the log file has been fixed.\n\nvarnishreplay\n-------------\n\n-  This new utility will attempt to recreate the HTTP traffic which\n   resulted in the raw Varnish log data which it is fed.\n\nvarnishstat\n-----------\n\n-  Don't print lifetime averages when it doesn't make any sense, for\n   instance, there is no point in dividing the amount in bytes of free\n   cache space by the lifetime in seconds of the varnishd process.\n\n-  The user interface has been greatly improved; varnishstat will no\n   longer print more than fits in the terminal, and will respond\n   correctly to window resize events. The output produced in one-shot\n   mode has been modified to include symbolic names for each entry. In\n   addition, the name of the Varnish instance being watched is displayed\n   in the upper right corner in curses mode.\n\nvarnishtop\n----------\n\n-  The user interface has been greatly improved; varnishtop will now\n   respond correctly to window resize events, and one-shot mode (-1)\n   actually works. In addition, the name of the Varnish instance being\n   watched is displayed in the upper right corner in curses mode.\n\n\n===========================\nChanges from 1.0.3 to 1.0.4\n===========================\n\nvarnishd\n--------\n\n-  The request workflow has been redesigned to simplify request\n   processing and eliminate code duplication. All codepaths which need\n   to speak HTTP now share a single implementation of the protocol. Some\n   new VCL hooks have been added, though they aren't much use yet. The\n   only real user-visible change should be that Varnish now handles\n   persistent backend connections correctly (see `ticket\n   #56 <https://www.varnish-cache.org/trac/ticket/56>`_).\n\n-  Support for multiple listen addresses has been added.\n\n-  An \"include\" facility has been added to VCL, allowing VCL code to\n   pull in code fragments from multiple files.\n\n-  Multiple definitions of the same VCL function are now concatenated\n   into one in the order in which they appear in the source. This\n   simplifies the mechanism for falling back to the built-in default for\n   cases which aren't handled in custom code, and facilitates\n   modularization.\n\n-  The code used to format management command arguments before passing\n   them on to the child process would underestimate the amount of space\n   needed to hold each argument once quotes and special characters were\n   properly escaped, resulting in a buffer overflow. This has been\n   corrected.\n\n-  The VCL compiler has been overhauled. Several memory leaks have been\n   plugged, and error detection and reporting has been improved\n   throughout. Parts of the compiler have been refactored to simplify\n   future extension of the language.\n\n-  A bug in the VCL compiler which resulted in incorrect parsing of the\n   decrement (-=) operator has been fixed.\n\n-  A new -C command-line option has been added which causes varnishd to\n   compile the VCL code (either from a file specified with -f or the\n   built-in default), print the resulting C code and exit.\n\n-  When processing a backend response using chunked encoding, if a chunk\n   header crosses a read buffer boundary, read additional bytes from the\n   backend connection until the chunk header is complete.\n\n-  A new ping\\_interval run-time parameter controls how often the\n   management process checks that the worker process is alive.\n\n-  A bug which would cause the worker process to dereference a NULL\n   pointer and crash if the backend did not respond has been fixed.\n\n-  In some cases, such as when they are used by AJAX applications to\n   circumvent Internet Explorer's over-eager disk cache, it may be\n   desirable to cache POST requests. However, the code path responsible\n   for delivering objects from cache would only transmit the response\n   body when replying to a GET request. This has been extended to also\n   apply to POST.\n\n   This should be revisited at a later date to allow VCL code to control\n   whether the body is delivered.\n\n-  Varnish now respects Cache-control: s-maxage, and prefers it to\n   Cache-control: max-age if both are present.\n\n   This should be revisited at a later date to allow VCL code to control\n   which headers are used and how they are interpreted.\n\n-  When loading a new VCL script, the management process will now load\n   the compiled object to verify that it links correctly before\n   instructing the worker process to load it.\n\n-  A new -P command-line options has been added which causes varnishd to\n   create a PID file.\n\n-  The sendfile\\_threshold run-time parameter's default value has been\n   set to infinity after a variety of sendfile()-related bugs were\n   discovered on several platforms.\n\nvarnishlog\n----------\n\n-  When grouping log entries by request, varnishlog attempts to collapse\n   the log entry for a call to a VCL function with the log entry for the\n   corresponding return from VCL. When two VCL calls were made in\n   succession, varnishlog would incorrectly omit the newline between the\n   two calls (see `ticket\n   #95 <https://www.varnish-cache.org/trac/ticket/95>`_).\n\n-  New -D and -P command-line options have been added to daemonize and\n   create a pidfile, respectively.\n\n-  The flag that is raised upon reception of a SIGHUP has been marked\n   volatile so it will not be optimized away by the compiler.\n\nvarnishncsa\n-----------\n\n-  The formatting callback has been largely rewritten for clarity,\n   robustness and efficiency.\n\n   If a request included a Host: header, construct and output an\n   absolute URL. This makes varnishncsa output from servers which handle\n   multiple virtual hosts far more useful.\n\n-  The flag that is raised upon reception of a SIGHUP has been marked\n   volatile so it will not be optimized away by the compiler.\n\nDocumentation\n-------------\n\n-  The documentation, especially the VCL documentation, has been greatly\n   extended and improved.\n\nBuild system\n------------\n\n-  The name and location of the curses or ncurses library is now\n   correctly detected by the configure script instead of being hardcoded\n   into affected Makefiles. This allows Varnish to build correctly on a\n   wider range of platforms.\n\n-  Compatibility shims for clock\\_gettime() are now correctly applied\n   where needed, allowing Varnish to build on MacOS X.\n\n-  The autogen.sh script will now correctly detect and warn about\n   automake versions which are known not to work correctly.\n",
        "/tmp/vanessa/spack-stage/spack-stage-varnish-cache-6.4.0-rypi4oyixvgpbmjahq5n45zcm4a7jnyy/spack-src/doc/sphinx/phk/firstdesign.rst": ".. _phk_firstdesign:\n\n===========================\nThe first design of Varnish\n===========================\n\nI have been working on a \"bit-storage\" facility for datamuseum.dk,\nand as part of my \"eat your own dog-food\" policy, I converting my\nown personal archive (41 DVD's worth) as a test.\n\nAlong the way I passed through 2006 and found some files from\nthe birth of Varnish 10 years ago.\n\nThe first Varnish Design notes\n------------------------------\n\nThis file are notes taken during a meeting in Oslo on 2nd feb 2006,\nwhich in essence consisted of Anders Berg cursing Squid for a couple\nof hours.\n\n(Originally the meeting was scheduled for jan 24th but a SAS pilot\nstrike put an end to that.)\n\nTo be honest I knew very little about web-traffic, my own homepage\nwas written in HTML in vi(1), so I had a bit of catching up to do\non that front, but the overall job was pretty simple:  A program\nto move bytes ... fast.\n\nIt is quite interesting to see how many things we got right and\nwhere we kept thinking in the old frame of reference (ie: Squid)::\n\n\tNotes on Varnish\n\t----------------\n\n\tCollected 2006-02-02 to 2006-02-..\n\n\tPoul-Henning Kamp\n\n\n\tPhilosophy\n\t----------\n\n\tIt is not enough to deliver a technically superior piece of software,\n\tif it is not possible for people to deploy it usefully in a sensible\n\tway and timely fashion.\n\n\n\tDeployment scenarios\n\t--------------------\n\n\tThere are two fundamental usage scenarios for Varnish: when the\n\tfirst machine is brought up to offload a struggling backend and\n\twhen a subsequent machine is brought online to help handle the load.\n\n\n\tThe first (layer of) Varnish\n\t----------------------------\n\n\tSomebodys webserver is struggling and they decide to try Varnish.\n\n\tOften this will be a skunkworks operation with some random PC\n\tpurloined from wherever it wasn't being used and the Varnish \"HOWTO\"\n\tin one hand.\n\n\tIf they do it in an orderly fashion before things reach panic proportions,\n\ta sensible model is to setup the Varnish box, test it out from your\n\town browser, see that it answers correctly.  Test it some more and\n\tthen add the IP# to the DNS records so that it takes 50% of the load\n\toff the backend.\n\n\tIf it happens as firefighting at 3AM the backend will be moved to another\n\tIP, the Varnish box given the main IP and things had better work real\n\twell, really fast.\n\n\tIn both cases, it would be ideal if all that is necessary to tell\n\tVarnish are two pieces of information:\n\n\t\tStorage location\n\t\t\tAlternatively we can offer an \"auto\" setting that makes\n\t\t\tVarnish discover what is available and use what it find.\n\n\t\tDNS or IP# of backend.\n\n\t\t\tIP# is useful when the DNS settings are not quite certain\n\t\t\tor when split DNS horizon setups are used.\n\n\tIdeally this can be done on the commandline so that there is no\n\tconfiguration file to edit to get going, just\n\n\t\tvarnish -d /home/varnish -s backend.example.dom\n\n\tand you're off running.\n\n\tA text, curses or HTML based based facility to give some instant\n\tfeedback and stats is necessary.\n\n\tIf circumstances are not conductive to strucured approach, it should\n\tbe possible to repeat this process and set up N independent Varnish\n\tboxes and get some sort of relief without having to read any further\n\tdocumentation.\n\n\n\tThe subsequent (layers of) Varnish\n\t----------------------------------\n\n\tThis is what happens once everybody has caught their breath,\n\tand where we start to talk about Varnish clusters.\n\n\tWe can assume that at this point, the already installed Varnish\n\tmachines have been configured more precisely and that people\n\thave studied Varnish configuration to some level of detail.\n\n\tWhen Varnish machines are put in a cluster, the administrator should\n\tbe able to consider the cluster as a unit and not have to think and\n\tinteract with the individual nodes.\n\n\tSome sort of central management node or facility must exist and\n\tit would be preferable if this was not a physical but a logical\n\tentity so that it can follow the admin to the beach.  Ideally it\n\twould give basic functionality in any browser, even mobile phones.\n\n\tThe focus here is scaleability, we want to avoid per-machine\n\tconfiguration if at all possible.  Ideally, preconfigured hardware\n\tcan be plugged into power and net, find an address with DHCP, contact\n\tpreconfigured management node, get a configuration and start working.\n\n\tBut we also need to think about how we avoid a site of Varnish\n\tmachines from acting like a stampeeding horde when the power or\n\tconnectivity is brought back after a disruption.  Some sort of\n\tslow starting (\"warm-up\" ?) must be implemented to prevent them\n\tfrom hitting all the backend with the full force.\n\n\tAn important aspect of cluster operations is giving a statistically\n\tmeaninful judgement of the cluster size, in particular answering\n\tthe question \"would adding another machine help ?\" precisely.\n\n\tWe should have a facility that allows the administrator to type\n\tin a REGEXP/URL and have all the nodes answer with a checksum, age\n\tand expiry timer for any documents they have which match.  The\n\tresults should be grouped by URL and checksum.\n\n\n\tTechnical concepts\n\t------------------\n\n\tWe want the central Varnish process to be that, just one process, and\n\twe want to keep it small and efficient at all cost.\n\n\tCode that will not be used for the central functionality should not\n\tbe part of the central process.  For instance code to parse, validate\n\tand interpret the (possibly) complex configuration file should be a\n\tseparate program.\n\n\tDepending on the situation, the Varnish process can either invoke\n\tthis program via a pipe or receive the ready to use data structures\n\tvia a network connection.\n\n\tExported data from the Varnish process should be made as cheap as\n\tpossible, likely shared memory.  That will allow us to deploy separate\n\tprocesses for log-grabbing, statistics monitoring and similar\n\t\"off-duty\" tasks and let the central process get on with the\n\timportant job.\n\n\n\tBackend interaction\n\t-------------------\n\n\tWe need a way to tune the backend interaction further than what the\n\tHTTP protocol offers out of the box.\n\n\tWe can assume that all documents we get from the backend has an\n\texpiry timer, if not we will set a default timer (configurable of\n\tcourse).\n\n\tBut we need further policy than that.  Amongst the questions we have\n\tto ask are:\n\n\t\tHow long time after the expiry can we serve a cached copy\n\t\tof this document while we have reason to believe the backend\n\t\tcan supply us with an update ?\n\n\t\tHow long time after the expiry can we serve a cached copy\n\t\tof this document if the backend does not reply or is\n\t\tunreachable.\n\n\t\tIf we cannot serve this document out of cache and the backend\n\t\tcannot inform us, what do we serve instead (404 ?  A default\n\t\tdocument of some sort ?)\n\n\t\tShould we just not serve this page at all if we are in a\n\t\tbandwidth crush (DoS/stampede) situation ?\n\n\tIt may also make sense to have a \"emergency detector\" which triggers\n\twhen the backend is overloaded and offer a scaling factor for all\n\ttimeouts for when in such an emergency state.  Something like \"If\n\tthe average response time of the backend rises above 10 seconds,\n\tmultiply all expiry timers by two\".\n\n\tIt probably also makes sense to have a bandwidth/request traffic\n\tshaper for backend traffic to prevent any one Varnish machine from\n\tpummeling the backend in case of attacks or misconfigured\n\texpiry headers.\n\n\n\tStartup/consistency\n\t-------------------\n\n\tWe need to decide what to do about the cache when the Varnish\n\tprocess starts.  There may be a difference between it starting\n\tfirst time after the machine booted and when it is subsequently\n\t(re)started.\n\n\tBy far the easiest thing to do is to disregard the cache, that saves\n\ta lot of code for locating and validating the contents, but this\n\tcarries a penalty in backend or cluster fetches whenever a node\n\tcomes up.  Lets call this the \"transient cache model\"\n\n\tThe alternative is to allow persistently cached contents to be used\n\taccording to configured criteria:\n\n\t\tCan expired contents be served if we can't contact the\n\t\tbackend ?  (dangerous...)\n\n\t\tCan unexpired contents be served if we can't contact the\n\t\tbackend ?  If so, how much past the expiry ?\n\n\tIt is a very good question how big a fraction of the persistent\n\tcache would be usable after typical downtimes:\n\n\t\tAfter a Varnish process restart:  Nearly all.\n\n\t\tAfter a power-failure ?  Probably at least half, but probably\n\t\tnot the half that contains the most busy pages.\n\n\tAnd we need to take into consideration if validating the format and\n\tcontents of the cache might take more resources and time than getting\n\tthe content from the backend.\n\n\tOff the top of my head, I would prefer the transient model any day\n\tbecause of the simplicity and lack of potential consistency problems,\n\tbut if the load on the back end is intolerable this may not be\n\tpractically feasible.\n\n\tThe best way to decide is to carefully analyze a number of cold\n\tstarts and cache content replacement traces.\n\n\tThe choice we make does affect the storage management part of Varnish,\n\tbut I see that is being modular in any instance, so it may merely be\n\tthat some storage modules come up clean on any start while other\n\twill come up with existing objects cached.\n\n\n\tClustering\n\t----------\n\n\tI'm somewhat torn on clustering for traffic purposes.  For admin\n\tand management: Yes, certainly, but starting to pass objects from\n\tone machine in a cluster to another is likely to be just be a waste\n\tof time and code.\n\n\tToday one can trivially fit 1TB into a 1U machine so the partitioning\n\targument for cache clusters doesn't sound particularly urgent to me.\n\n\tIf all machines in the cluster have sufficient cache capacity, the\n\tother remaining argument is backend offloading, that would likely\n\tbe better mitigated by implementing a 1:10 style two-layer cluster\n\twith the second level node possibly having twice the storage of\n\tthe front row nodes.\n\n\tThe coordination necessary for keeping track of, or discovering in\n\treal-time, who has a given object can easily turn into a traffic\n\tand cpu load nightmare.\n\n\tAnd from a performance point of view, it only reduces quality:\n\tFirst we send out a discovery multicast, then we wait some amount\n\tof time to see if a response arrives only then should we start\n\tto ask the backend for the object.  With a two-level cluster\n\twe can ask the layer-two node right away and if it doesn't have\n\tthe object it can ask the back-end right away, no timeout is\n\tinvolved in that.\n\n\tFinally Consider the impact on a cluster of a \"must get\" object\n\tlike an IMG tag with a misspelled URL.  Every hit on the front page\n\tresults in one get of the wrong URL.  One machine in the cluster\n\task everybody else in the cluster \"do you have this URL\" every\n\ttime somebody gets the frontpage.\n\n\tIf we implement a negative feedback protocol (\"No I don't\"), then\n\teach hit on the wrong URL will result in N+1 packets (assuming multicast).\n\n\tIf we use a silent negative protocol the result is less severe for\n\tthe machine that got the request, but still everybody wakes up to\n\tto find out that no, we didn't have that URL.\n\n\tNegative caching can mitigate this to some extent.\n\n\n\tPrivacy\n\t-------\n\n\tConfiguration data and instructions passed forth and back should\n\tbe encrypted and signed if so configured.  Using PGP keys is\n\ta very tempting and simple solution which would pave the way for\n\tadministrators typing a short ascii encoded pgp signed message\n\tinto a SMS from their Bahamas beach vacation...\n\n\n\tImplementation ideas\n\t--------------------\n\n\tThe simplest storage method mmap(2)'s a disk or file and puts\n\tobjects into the virtual memory on page aligned boundaries,\n\tusing a small struct for metadata.  Data is not persistant\n\tacross reboots.  Object free is incredibly cheap.  Object\n\tallocation should reuse recently freed space if at all possible.\n\t\"First free hole\" is probably a good allocation strategy.\n\tSendfile can be used if filebacked.  If nothing else disks\n\tcan be used by making a 1-file filesystem on them.\n\n\tMore complex storage methods are object per file and object\n\tin database models.  They are relatively trival and well\n\tunderstood.  May offer persistence.\n\n\tRead-Only storage methods may make sense for getting hold\n\tof static emergency contents from CD-ROM etc.\n\n\tTreat each disk arm as a separate storage unit and keep track of\n\tservice time (if possible) to decide storage scheduling.\n\n\tAvoid regular expressions at runtime.  If config file contains\n\tregexps, compile them into executable code and dlopen() it\n\tinto the Varnish process.  Use versioning and refcounts to\n\tdo memory management on such segments.\n\n\tAvoid committing transmit buffer space until we have bandwidth\n\testimate for client.  One possible way:  Send HTTP header\n\tand time ACKs getting back, then calculate transmit buffer size\n\tand send object.  This makes DoS attacks more harmless and\n\tmitigates traffic stampedes.\n\n\tKill all TCP connections after N seconds, nobody waits an hour\n\tfor a web-page to load.\n\n\tAbuse mitigation interface to firewall/traffic shaping:  Allow\n\tthe central node to put an IP/Net into traffic shaping or take\n\tit out of traffic shaping firewall rules.  Monitor/interface\n\tprocess (not main Varnish process) calls script to config\n\tfirewalling.\n\n\t\"Warm-up\" instructions can take a number of forms and we don't know\n\twhat is the most efficient or most usable.  Here are some ideas:\n\n\t    Start at these URL's then...\n\n\t\t... follow all links down to N levels.\n\n\t\t... follow all links that match REGEXP no deeper than N levels down.\n\n\t\t... follow N random links no deeper than M levels down.\n\n\t\t... load N objects by following random links no deeper than\n\t\t    M levels down.\n\n\t    But...\n\n\t\t... never follow any links that match REGEXP\n\n\t\t... never pick up objects larger than N bytes\n\n\t\t... never pick up objects older than T seconds\n\n\n\tIt makes a lot of sense to not actually implement this in the main\n\tVarnish process, but rather supply a template perl or python script\n\tthat primes the cache by requesting the objects through Varnish.\n\t(That would require us to listen separately on 127.0.0.1\n\tso the perlscript can get in touch with Varnish while in warm-up.)\n\n\tOne interesting but quite likely overengineered option in the\n\tcluster case is if the central monitor tracks a fraction of the\n\trequests through the logs of the running machines in the cluster,\n\tspots the hot objects and tell the warming up varnish what objects\n\tto get and from where.\n\n\n\tIn the cluster configuration, it is probably best to run the cluster\n\tinteraction in a separate process rather than the main Varnish\n\tprocess.  From Varnish to cluster info would go through the shared\n\tmemory, but we don't want to implement locking in the shmem so\n\tsome sort of back-channel (UNIX domain or UDP socket ?) is necessary.\n\n\tIf we have such an \"supervisor\" process, it could also be tasked\n\twith restarting the varnish process if vitals signs fail:  A time\n\tstamp in the shmem or kill -0 $pid.\n\n\tIt may even make sense to run the \"supervisor\" process in stand\n\talone mode as well, there it can offer a HTML based interface\n\tto the Varnish process (via shmem).\n\n\tFor cluster use the user would probably just pass an extra argument\n\twhen he starts up Varnish:\n\n\t\tvarnish -c $cluster_args $other_args\n\tvs\n\n\t\tvarnish $other_args\n\n\tand a \"varnish\" shell script will Do The Right Thing.\n\n\n\tShared memory\n\t-------------\n\n\tThe shared memory layout needs to be thought about somewhat.  On one\n\thand we want it to be stable enough to allow people to write programs\n\tor scripts that inspect it, on the other hand doing it entirely in\n\tascii is both slow and prone to race conditions.\n\n\tThe various different data types in the shared memory can either be\n\tput into one single segment(= 1 file) or into individual segments\n\t(= multiple files).  I don't think the number of small data types to\n\tbe big enough to make the latter impractical.\n\n\tStoring the \"big overview\" data in shmem in ASCII or HTML would\n\tallow one to point cat(1) or a browser directly at the mmaped file\n\twith no interpretation necessary, a big plus in my book.\n\n\tSimilarly, if we don't update them too often, statistics could be stored\n\tin shared memory in perl/awk friendly ascii format.\n\n\tBut the logfile will have to be (one or more) FIFO logs, probably at least\n\tthree in fact:  Good requests, Bad requests, and exception messages.\n\n\tIf we decide to make logentries fixed length, we could make them ascii\n\tso that a simple \"sort -n /tmp/shmem.log\" would put them in order after\n\ta leading numeric timestamp, but it is probably better to provide a\n\tutility to cat/tail-f the log and keep the log in a bytestring FIFO\n\tformat.  Overruns should be marked in the output.\n\n\n\t*END*\n\nThe second Varnish Design notes\n-------------------------------\n\nYou will notice above that there is no mention of VCL, it took a\ncouple of weeks for that particular lightning to strike.\n\nInterestingly I know exactly where the lightning came from, and\nwhat it hit.\n\nThe timeframe was around GCC 4.0.0 which was not their best release,\nand I had for some time been pondering a pre-processor for the C\nlanguage to make up for the ISO-C stagnation and braindamage.\n\nI've read most of the \"classic\" compiler books, and probably read\nmore compilers many people (Still to go: `GIER Algol 4 <http://datamuseum.dk/wiki/GIER/GA4GuideToDocumentationAndCode>`_) but to be honest I found\nthem far too theoretical and not very helpful from a *practical* compiler\nconstruction point of view.\n\nBut there is one compiler-book which takes an entirely different\ntake:  `Hanson and Fraser's LCC book. <http://www.amazon.com/gp/search/?field-isbn=0805316701>`_ which throws LEX and YACC under the truck and\nconcentrates on compiling.\n\nTaking their low-down approach to parsing, and emitting C code,\nthere really isn't much compiler left to write, and I had done\nseveral interesting hacks towards my 'K' language.\n\nThe lightning rod was all the ideas Anders had for how Varnish\nshould be able to manipulate the traffic passing through, how\nto decide what to cache, how long time to cache it, where to\ncache it and ... it sounded like a lot of very detailed code\nwhich had to be incredibly configurable.\n\nSoon those two inspiratons collided::\n\n\n\tNotes on Varnish\n\t----------------\n\n\tCollected 2006-02-24 to 2006-02-..\n\n\tPoul-Henning Kamp\n\n\t-----------------------------------------------------------------------\n\tPolicy Configuration\n\n\tPolicy is configured in a simple unidirectional (no loops, no goto)\n\tprogramming language which is compiled into 'C' and from there binary\n\tmodules which are dlopen'ed by the main Varnish process.\n\n\tThe dl object contains one exported symbol, a pointer to a structure\n\twhich contains a reference count, a number of function pointers,\n\ta couple of string variables with identifying information.\n\n\tAll access into the config is protected by the reference counts.\n\n\tMultiple policy configurations can be loaded at the same time\n\tbut only one is the \"active configuration\".  Loading, switching and\n\tunloading of policy configurations happen via the managment\n\tprocess.\n\n\tA global config sequence number is incremented on each switch and\n\tpolicy modified object attributes (ttl, cache/nocache) are all\n\tqualified by the config-sequence under which they were calculated\n\tand invalid if a different policy is now in effect.\n\n\t-----------------------------------------------------------------------\n\tConfiguration Language\n\n\tXXX: include lines.\n\n\tBNF:\n\t\tprogram:\tfunction\n\t\t\t\t| program function\n\n\t\tfunction:\t\"sub\" function_name compound_statement\n\n\t\tcompound_statement:\t\"{\" statements \"}\"\n\n\t\tstatements:\t/* empty */\n\t\t\t\t| statement\n\t\t\t\t| statements statement\n\n\n\t\tstatement:\tif_statement\n\t\t\t\t| call_statement\n\t\t\t\t| \"finish\"\n\t\t\t\t| assignment_statement\n\t\t\t\t| action_statement\n\n\t\tif_statement:\t\"if\" condition compound_statement elif_parts else_part\n\n\t\telif_parts:\t/* empty */\n\t\t\t\t| elif_part\n\t\t\t\t| elif_parts elif_part\n\n\t\telif_part:\t\"elseif\" condition compound_statement\n\t\t\t\t| \"elsif\" condition compound_statement\n\t\t\t\t| \"else if\" condition compound_statement\n\n\t\telse_part:\t/* empty */\n\t\t\t\t| \"else\" compound_statement\n\n\t\tcall_statement:\t\"call\" function_name\n\n\t\tassign_statement:\tfield \"=\" value\n\n\t\tfield:\t\tobject\n\t\t\t\tfield \".\" variable\n\n\t\taction_statement:\taction arguments\n\n\t\targuments:\t/* empty */\n\t\t\t\targuments | argument\n\n\t-----------------------------------------------------------------------\n\tSample request policy program\n\n\t\tsub request_policy {\n\n\t\t\tif (client.ip in 10.0.0.0/8) {\n\t\t\t\tno-cache\n\t\t\t\tfinish\n\t\t\t}\n\n\t\t\tif (req.url.host ~ \"cnn.no$\") {\n\t\t\t\trewrite\ts/cnn.no$/vg.no/\n\t\t\t}\n\n\t\t\tif (req.url.path ~ \"cgi-bin\") {\n\t\t\t\tno-cache\n\t\t\t}\n\n\t\t\tif (req.useragent ~ \"spider\") {\n\t\t\t\tno-new-cache\n\t\t\t}\n\n\t\t\tif (backend.response_time > 0.8s) {\n\t\t\t\tset req.ttlfactor = 1.5\n\t\t\t} elseif (backend.response_time > 1.5s) {\n\t\t\t\tset req.ttlfactor = 2.0\n\t\t\t} elseif (backend.response_time > 2.5s) {\n\t\t\t\tset req.ttlfactor = 5.0\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * the program contains no references to\n\t\t\t * maxage, s-maxage and expires, so the\n\t\t\t * default handling (RFC2616) applies\n\t\t\t */\n\t\t}\n\n\t-----------------------------------------------------------------------\n\tSample fetch policy program\n\n\t\tsub backends {\n\t\t\tset backend.vg.ip = {...}\n\t\t\tset backend.ads.ip = {...}\n\t\t\tset backend.chat.ip = {...}\n\t\t\tset backend.chat.timeout = 10s\n\t\t\tset backend.chat.bandwidth = 2000 MB/s\n\t\t\tset backend.other.ip = {...}\n\t\t}\n\n\t\tsub vg_backend {\n\t\t\tset backend.ip = {10.0.0.1-5}\n\t\t\tset backend.timeout = 4s\n\t\t\tset backend.bandwidth = 2000Mb/s\n\t\t}\n\n\t\tsub fetch_policy {\n\n\t\t\tif (req.url.host ~ \"/vg.no$/\") {\n\t\t\t\tset req.backend = vg\n\t\t\t\tcall vg_backend\n\t\t\t} else {\n\t\t\t\t/* XXX: specify 404 page url ? */\n\t\t\t\terror 404\n\t\t\t}\n\n\t\t\tif (backend.response_time > 2.0s) {\n\t\t\t\tif (req.url.path ~ \"/landbrugspriser/\") {\n\t\t\t\t\terror 504\n\t\t\t\t}\n\t\t\t}\n\t\t\tfetch\n\t\t\tif (backend.down) {\n\t\t\t\tif (obj.exist) {\n\t\t\t\t\tset obj.ttl += 10m\n\t\t\t\t\tfinish\n\t\t\t\t}\n\t\t\t\tswitch_config ohhshit\n\t\t\t}\n\t\t\tif (obj.result == 404) {\n\t\t\t\terror 300 \"http://www.vg.no\"\n\t\t\t}\n\t\t\tif (obj.result != 200) {\n\t\t\t\tfinish\n\t\t\t}\n\t\t\tif (obj.size > 256k) {\n\t\t\t\tno-cache\n\t\t\t} else if (obj.size > 32k && obj.ttl < 2m) {\n\t\t\t\tobj.tll = 5m\n\t\t\t}\n\t\t\tif (backend.response_time > 2.0s) {\n\t\t\t\tset ttl *= 2.0\n\t\t\t}\n\t\t}\n\n\t\tsub prefetch_policy {\n\n\t\t\tif (obj.usage < 10 && obj.ttl < 5m) {\n\t\t\t\tfetch\n\t\t\t}\n\t\t}\n\n\t-----------------------------------------------------------------------\n\tPurging\n\n\tWhen a purge request comes in, the regexp is tagged with the next\n\tgeneration number and added to the tail of the list of purge regexps.\n\n\tBefore a sender transmits an object, it is checked against any\n\tpurge-regexps which have higher generation number than the object\n\tand if it matches the request is sent to a fetcher and the object\n\tpurged.\n\n\tIf there were purge regexps with higher generation to match, but\n\tthey didn't match, the object is tagged with the current generation\n\tnumber and moved to the tail of the list.\n\n\tOtherwise, the object does not change generation number and is\n\tnot moved on the generation list.\n\n\tNew Objects are tagged with the current generation number and put\n\tat the tail of the list.\n\n\tObjects are removed from the generation list when deleted.\n\n\tWhen a purge object has a lower generation number than the first\n\tobject on the generation list, the purge object has been completed\n\tand will be removed.  A log entry is written with number of compares\n\tand number of hits.\n\n\t-----------------------------------------------------------------------\n\tRandom notes\n\n\t\tswap backed storage\n\n\t\tslowstart by config-flipping\n\t\t\tstart-config has peer servers as backend\n\t\t\tonce hitrate goes above limit, management process\n\t\t\tflips config to 'real' config.\n\n\t\tstat-object\n\t\t\talways URL, not regexp\n\n\t\tmanagement + varnish process in one binary, comms via pipe\n\n\t\tChange from config with long expiry to short expiry, how\n\t\tdoes the ttl drop ?  (config sequence number invalidates\n\t\tall calculated/modified attributes.)\n\n\t\tMgt process holds copy of acceptor socket ->  Restart without\n\t\tlost client requests.\n\n\t\tBW limit per client IP: create shortlived object (<4sec)\n\t\tto hold status.  Enforce limits by delaying responses.\n\n\n\t-----------------------------------------------------------------------\n\tSource structure\n\n\n\t\tlibvarnish\n\t\t\tlibrary with interface facilities, for instance\n\t\t\tfunctions to open&read shmem log\n\n\t\tvarnish\n\t\t\tvarnish sources in three classes\n\n\t-----------------------------------------------------------------------\n\tprotocol cluster/mgt/varnish\n\n\tobject_query url -> TTL, size, checksum\n\t{purge,invalidate} regexp\n\tobject_status url -> object metadata\n\n\tload_config filename\n\tswitch_config configname\n\tlist_configs\n\tunload_config\n\n\tfreeze \t# stop the clock, freezes the object store\n\tthaw\n\n\tsuspend\t# stop acceptor accepting new requests\n\tresume\n\n\tstop\t# forced stop (exits) varnish process\n\tstart\n\trestart = \"stop;start\"\n\n\tping $utc_time -> pong $utc_time\n\n\t# cluster only\n\tconfig_contents filename $inline -> compilation messages\n\n\tstats [-mr] -> $data\n\n\tzero stats\n\n\thelp\n\n\t-----------------------------------------------------------------------\n\tCLI (local)\n\t\timport protocol from above\n\n\t\ttelnet localhost someport\n\t\tauthentication:\n\t\t\tpassword $secret\n\t\tsecret stored in {/usr/local}/etc/varnish.secret (400 root:wheel)\n\n\n\t-----------------------------------------------------------------------\n\tHTML (local)\n\n\t\tphp/cgi-bin thttpd ?\n\t\t(alternatively direct from C-code.)\n\t\tEverything the CLI can do +\n\t\tstats\n\t\t\tpopen(\"rrdtool\");\n\t\tlog view\n\n\t-----------------------------------------------------------------------\n\tCLI (cluster)\n\t\timport protocol from above, prefix machine/all\n\t\tcompound stats\n\t\taccept / deny machine (?)\n\t\tcurses if you set termtype\n\n\t-----------------------------------------------------------------------\n\tHTML (cluster)\n\t\tditto\n\t\tditto\n\n\t\thttp://clustercontrol/purge?regexp=fslkdjfslkfdj\n\t\t\tPOST with list of regexp\n\t\t\tauthentication ? (IP access list)\n\n\t-----------------------------------------------------------------------\n\tMail (cluster)\n\n\t\tpgp signed emails with CLI commands\n\n\t-----------------------------------------------------------------------\n\tconnection varnish -> cluster controller\n\n\t\tEncryption\n\t\t\tSSL\n\t\tAuthentication (?)\n\t\t\tIP number checks.\n\n\t\tvarnish -c clusterid -C mycluster_ctrl.vg.no\n\n\t-----------------------------------------------------------------------\n\tFiler\n\t\t/usr/local/sbin/varnish\n\t\t\tcontains mgt + varnish process.\n\t\t\tif -C argument, open SSL to cluster controller.\n\t\t\tArguments:\n\t\t\t\t-p portnumber\n\t\t\t\t-c clusterid@cluster_controller\n\t\t\t\t-f config_file\n\t\t\t\t-m memory_limit\n\t\t\t\t-s kind[,storage-options]\n\t\t\t\t-l logfile,logsize\n\t\t\t\t-b backend ip...\n\t\t\t\t-d debug\n\t\t\t\t-u uid\n\t\t\t\t-a CLI_port\n\n\t\t\tKILL SIGTERM\t-> suspend, stop\n\n\t\t/usr/local/sbin/varnish_cluster\n\t\t\tCluster controller.\n\t\t\tUse syslog\n\n\t\t\tArguments:\n\t\t\t\t-f config file\n\t\t\t\t-d debug\n\t\t\t\t-u uid (?)\n\n\t\t/usr/local/sbin/varnish_logger\n\t\t\tLogfile processor\n\t\t\t-i shmemfile\n\t\t\t-e regexp\n\t\t\t-o \"/var/log/varnish.%Y%m%d.traffic\"\n\t\t\t-e regexp2\n\t\t\t-n \"/var/log/varnish.%Y%m%d.exception\"  (NCSA format)\n\t\t\t-e regexp3\n\t\t\t-s syslog_level,syslogfacility\n\t\t\t-r host:port\tsend via TCP, prefix hostname\n\n\t\t\tSIGHUP: reopen all files.\n\n\t\t/usr/local/bin/varnish_cli\n\t\t\tCommand line tool.\n\n\t\t/usr/local/share/varnish/etc/varnish.conf\n\t\t\tdefault request + fetch + backend scripts\n\n\t\t/usr/local/share/varnish/etc/rfc2616.conf\n\t\t\tRFC2616 compliant handling function\n\n\t\t/usr/local/etc/varnish.conf (optional)\n\t\t\trequest + fetch + backend scripts\n\n\t\t/usr/local/share/varnish/etc/varnish.startup\n\t\t\tdefault startup sequence\n\n\t\t/usr/local/etc/varnish.startup (optional)\n\t\t\tstartup sequence\n\n\t\t/usr/local/etc/varnish_cluster.conf\n\t\t\tXXX\n\n\t\t{/usr/local}/etc/varnish.secret\n\t\t\tCLI password file.\n\n\t-----------------------------------------------------------------------\n\tvarnish.startup\n\n\t\tload config /foo/bar startup_conf\n\t\tswitch config startup_conf\n\t\t!mypreloadscript\n\t\tload config /foo/real real_conf\n\t\tswitch config real_conf\n\t\tresume\n\n\nThe third Varnish Design notes\n-------------------------------\n\nA couple of days later the ideas had gel'ed::\n\n\n\tNotes on Varnish\n\t----------------\n\n\tCollected 2006-02-26 to 2006-03-..\n\n\tPoul-Henning Kamp\n\n\t-----------------------------------------------------------------------\n\n\tObjects available to functions in VCL\n\n\t\tclient\t# The client\n\n\t\treq\t# The request\n\n\t\tobj\t# The object from which we satisfy it\n\n\t\tbackend\t# The chosen supplier\n\n\t-----------------------------------------------------------------------\n\tConfiguration Language\n\n\tXXX: declare IP lists ?\n\n\tBNF:\n\t\tprogram:\tpart\n\t\t\t\t| program part\n\n\t\tpart:\t\t\"sub\" function_name compound\n\t\t\t\t| \"backend\" backend_name compound\n\n\t\tcompound:\t\"{\" statements \"}\"\n\n\t\tstatements:\t/* empty */\n\t\t\t\t| statement\n\t\t\t\t| statements statement\n\n\t\tstatement:\tconditional\n\t\t\t\t| functioncall\n\t\t\t\t| \"set\" field value\n\t\t\t\t| field \"=\" value\n\t\t\t\t| \"no_cache\"\n\t\t\t\t| \"finish\"\n\t\t\t\t| \"no_new_cache\"\n\t\t\t\t| call function_name\n\t\t\t\t| fetch\n\t\t\t\t| error status_code\n\t\t\t\t| error status_code string(message)\n\t\t\t\t| switch_config config_id\n\t\t\t\t| rewrite field string(match) string(replace)\n\n\t\tconditional:\t\"if\" condition compound elif_parts else_part\n\n\t\telif_parts:\t/* empty */\n\t\t\t\t| elif_part\n\t\t\t\t| elif_parts elif_part\n\n\t\telif_part:\t\"elseif\" condition compound\n\t\t\t\t| \"elsif\" condition compound\n\t\t\t\t| \"else if\" condition compound\n\n\t\telse_part:\t/* empty */\n\t\t\t\t| \"else\" compound\n\n\t\tfunctioncal:\t\"call\" function_name\n\n\t\tfield:\t\tobject\n\t\t\t\tfield \".\" variable\n\n\t\tcondition:\t'(' cond_or ')'\n\n\t\tcond_or:\tcond_and\n\t\t\t\t| cond_or '||' cond_and\n\n\t\tcond_and:\tcond_part\n\t\t\t\t| cond_and '&&' cond_part\n\n\t\tcond_part:\t'!' cond_part2\n\t\t\t\t| cond_part2\n\n\t\tcond_part2:\tcondition\n\t\t\t\t| field(int) '<' number\n\t\t\t\t| field(int) '<=' number\n\t\t\t\t| field(int) '>' number\n\t\t\t\t| field(int) '>=' number\n\t\t\t\t| field(int) '=' number\n\t\t\t\t| field(int) '!=' number\n\t\t\t\t| field(IP)  ~ ip_list\n\t\t\t\t| field(string) ~ string(regexp)\n\n\t-----------------------------------------------------------------------\n\tSample request policy program\n\n\t\tsub request_policy {\n\n\t\t\tif (client.ip in 10.0.0.0/8) {\n\t\t\t\tno-cache\n\t\t\t\tfinish\n\t\t\t}\n\n\t\t\tif (req.url.host ~ \"cnn.no$\") {\n\t\t\t\trewrite\ts/cnn.no$/vg.no/\n\t\t\t}\n\n\t\t\tif (req.url.path ~ \"cgi-bin\") {\n\t\t\t\tno-cache\n\t\t\t}\n\n\t\t\tif (req.useragent ~ \"spider\") {\n\t\t\t\tno-new-cache\n\t\t\t}\n\n\t\t\tif (backend.response_time > 0.8s) {\n\t\t\t\tset req.ttlfactor = 1.5\n\t\t\t} elseif (backend.response_time > 1.5s) {\n\t\t\t\tset req.ttlfactor = 2.0\n\t\t\t} elseif (backend.response_time > 2.5s) {\n\t\t\t\tset req.ttlfactor = 5.0\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * the program contains no references to\n\t\t\t * maxage, s-maxage and expires, so the\n\t\t\t * default handling (RFC2616) applies\n\t\t\t */\n\t\t}\n\n\t-----------------------------------------------------------------------\n\tSample fetch policy program\n\n\t\tsub backends {\n\t\t\tset backend.vg.ip = {...}\n\t\t\tset backend.ads.ip = {...}\n\t\t\tset backend.chat.ip = {...}\n\t\t\tset backend.chat.timeout = 10s\n\t\t\tset backend.chat.bandwidth = 2000 MB/s\n\t\t\tset backend.other.ip = {...}\n\t\t}\n\n\t\tsub vg_backend {\n\t\t\tset backend.ip = {10.0.0.1-5}\n\t\t\tset backend.timeout = 4s\n\t\t\tset backend.bandwidth = 2000Mb/s\n\t\t}\n\n\t\tsub fetch_policy {\n\n\t\t\tif (req.url.host ~ \"/vg.no$/\") {\n\t\t\t\tset req.backend = vg\n\t\t\t\tcall vg_backend\n\t\t\t} else {\n\t\t\t\t/* XXX: specify 404 page url ? */\n\t\t\t\terror 404\n\t\t\t}\n\n\t\t\tif (backend.response_time > 2.0s) {\n\t\t\t\tif (req.url.path ~ \"/landbrugspriser/\") {\n\t\t\t\t\terror 504\n\t\t\t\t}\n\t\t\t}\n\t\t\tfetch\n\t\t\tif (backend.down) {\n\t\t\t\tif (obj.exist) {\n\t\t\t\t\tset obj.ttl += 10m\n\t\t\t\t\tfinish\n\t\t\t\t}\n\t\t\t\tswitch_config ohhshit\n\t\t\t}\n\t\t\tif (obj.result == 404) {\n\t\t\t\terror 300 \"http://www.vg.no\"\n\t\t\t}\n\t\t\tif (obj.result != 200) {\n\t\t\t\tfinish\n\t\t\t}\n\t\t\tif (obj.size > 256k) {\n\t\t\t\tno-cache\n\t\t\t} else if (obj.size > 32k && obj.ttl < 2m) {\n\t\t\t\tobj.tll = 5m\n\t\t\t}\n\t\t\tif (backend.response_time > 2.0s) {\n\t\t\t\tset ttl *= 2.0\n\t\t\t}\n\t\t}\n\n\t\tsub prefetch_policy {\n\n\t\t\tif (obj.usage < 10 && obj.ttl < 5m) {\n\t\t\t\tfetch\n\t\t\t}\n\t\t}\n\n\t-----------------------------------------------------------------------\n\tPurging\n\n\tWhen a purge request comes in, the regexp is tagged with the next\n\tgeneration number and added to the tail of the list of purge regexps.\n\n\tBefore a sender transmits an object, it is checked against any\n\tpurge-regexps which have higher generation number than the object\n\tand if it matches the request is sent to a fetcher and the object\n\tpurged.\n\n\tIf there were purge regexps with higher generation to match, but\n\tthey didn't match, the object is tagged with the current generation\n\tnumber and moved to the tail of the list.\n\n\tOtherwise, the object does not change generation number and is\n\tnot moved on the generation list.\n\n\tNew Objects are tagged with the current generation number and put\n\tat the tail of the list.\n\n\tObjects are removed from the generation list when deleted.\n\n\tWhen a purge object has a lower generation number than the first\n\tobject on the generation list, the purge object has been completed\n\tand will be removed.  A log entry is written with number of compares\n\tand number of hits.\n\n\t-----------------------------------------------------------------------\n\tRandom notes\n\n\t\tswap backed storage\n\n\t\tslowstart by config-flipping\n\t\t\tstart-config has peer servers as backend\n\t\t\tonce hitrate goes above limit, management process\n\t\t\tflips config to 'real' config.\n\n\t\tstat-object\n\t\t\talways URL, not regexp\n\n\t\tmanagement + varnish process in one binary, comms via pipe\n\n\t\tChange from config with long expiry to short expiry, how\n\t\tdoes the ttl drop ?  (config sequence number invalidates\n\t\tall calculated/modified attributes.)\n\n\t\tMgt process holds copy of acceptor socket ->  Restart without\n\t\tlost client requests.\n\n\t\tBW limit per client IP: create shortlived object (<4sec)\n\t\tto hold status.  Enforce limits by delaying responses.\n\n\n\t-----------------------------------------------------------------------\n\tSource structure\n\n\n\t\tlibvarnish\n\t\t\tlibrary with interface facilities, for instance\n\t\t\tfunctions to open&read shmem log\n\n\t\tvarnish\n\t\t\tvarnish sources in three classes\n\n\t-----------------------------------------------------------------------\n\tprotocol cluster/mgt/varnish\n\n\tobject_query url -> TTL, size, checksum\n\t{purge,invalidate} regexp\n\tobject_status url -> object metadata\n\n\tload_config filename\n\tswitch_config configname\n\tlist_configs\n\tunload_config\n\n\tfreeze \t# stop the clock, freezes the object store\n\tthaw\n\n\tsuspend\t# stop acceptor accepting new requests\n\tresume\n\n\tstop\t# forced stop (exits) varnish process\n\tstart\n\trestart = \"stop;start\"\n\n\tping $utc_time -> pong $utc_time\n\n\t# cluster only\n\tconfig_contents filename $inline -> compilation messages\n\n\tstats [-mr] -> $data\n\n\tzero stats\n\n\thelp\n\n\t-----------------------------------------------------------------------\n\tCLI (local)\n\t\timport protocol from above\n\n\t\ttelnet localhost someport\n\t\tauthentication:\n\t\t\tpassword $secret\n\t\tsecret stored in {/usr/local}/etc/varnish.secret (400 root:wheel)\n\n\n\t-----------------------------------------------------------------------\n\tHTML (local)\n\n\t\tphp/cgi-bin thttpd ?\n\t\t(alternatively direct from C-code.)\n\t\tEverything the CLI can do +\n\t\tstats\n\t\t\tpopen(\"rrdtool\");\n\t\tlog view\n\n\t-----------------------------------------------------------------------\n\tCLI (cluster)\n\t\timport protocol from above, prefix machine/all\n\t\tcompound stats\n\t\taccept / deny machine (?)\n\t\tcurses if you set termtype\n\n\t-----------------------------------------------------------------------\n\tHTML (cluster)\n\t\tditto\n\t\tditto\n\n\t\thttp://clustercontrol/purge?regexp=fslkdjfslkfdj\n\t\t\tPOST with list of regexp\n\t\t\tauthentication ? (IP access list)\n\n\t-----------------------------------------------------------------------\n\tMail (cluster)\n\n\t\tpgp signed emails with CLI commands\n\n\t-----------------------------------------------------------------------\n\tconnection varnish -> cluster controller\n\n\t\tEncryption\n\t\t\tSSL\n\t\tAuthentication (?)\n\t\t\tIP number checks.\n\n\t\tvarnish -c clusterid -C mycluster_ctrl.vg.no\n\n\t-----------------------------------------------------------------------\n\tFiler\n\t\t/usr/local/sbin/varnish\n\t\t\tcontains mgt + varnish process.\n\t\t\tif -C argument, open SSL to cluster controller.\n\t\t\tArguments:\n\t\t\t\t-p portnumber\n\t\t\t\t-c clusterid@cluster_controller\n\t\t\t\t-f config_file\n\t\t\t\t-m memory_limit\n\t\t\t\t-s kind[,storage-options]\n\t\t\t\t-l logfile,logsize\n\t\t\t\t-b backend ip...\n\t\t\t\t-d debug\n\t\t\t\t-u uid\n\t\t\t\t-a CLI_port\n\n\t\t\tKILL SIGTERM\t-> suspend, stop\n\n\t\t/usr/local/sbin/varnish_cluster\n\t\t\tCluster controller.\n\t\t\tUse syslog\n\n\t\t\tArguments:\n\t\t\t\t-f config file\n\t\t\t\t-d debug\n\t\t\t\t-u uid (?)\n\n\t\t/usr/local/sbin/varnish_logger\n\t\t\tLogfile processor\n\t\t\t-i shmemfile\n\t\t\t-e regexp\n\t\t\t-o \"/var/log/varnish.%Y%m%d.traffic\"\n\t\t\t-e regexp2\n\t\t\t-n \"/var/log/varnish.%Y%m%d.exception\"  (NCSA format)\n\t\t\t-e regexp3\n\t\t\t-s syslog_level,syslogfacility\n\t\t\t-r host:port\tsend via TCP, prefix hostname\n\n\t\t\tSIGHUP: reopen all files.\n\n\t\t/usr/local/bin/varnish_cli\n\t\t\tCommand line tool.\n\n\t\t/usr/local/share/varnish/etc/varnish.conf\n\t\t\tdefault request + fetch + backend scripts\n\n\t\t/usr/local/share/varnish/etc/rfc2616.conf\n\t\t\tRFC2616 compliant handling function\n\n\t\t/usr/local/etc/varnish.conf (optional)\n\t\t\trequest + fetch + backend scripts\n\n\t\t/usr/local/share/varnish/etc/varnish.startup\n\t\t\tdefault startup sequence\n\n\t\t/usr/local/etc/varnish.startup (optional)\n\t\t\tstartup sequence\n\n\t\t/usr/local/etc/varnish_cluster.conf\n\t\t\tXXX\n\n\t\t{/usr/local}/etc/varnish.secret\n\t\t\tCLI password file.\n\n\t-----------------------------------------------------------------------\n\tvarnish.startup\n\n\t\tload config /foo/bar startup_conf\n\t\tswitch config startup_conf\n\t\t!mypreloadscript\n\t\tload config /foo/real real_conf\n\t\tswitch config real_conf\n\t\tresume\n\nFourth Varnish Design Note\n--------------------------\n\nYou'd think we'd be cookin' with gas now, and indeed we were, but now\nall the difficult details started to raise ugly questions, and it\nhas never stopped since::\n\n\tQuestions:\n\n\t*  Which \"Host:\" do we put in the request to the backend ?\n\n\t      The one we got from the client ?\n\n\t      The ip/dns-name of the backend ?\n\n\t      Configurable in VCL backend declaration ?\n\n\t      (test with www.ing.dk)\n\n\t*  Construction of headers for queries to backend ?\n\n\t      How much do we take from client headers, how much do we make up ?\n\n\t      Some sites discriminate contents based on User-Agent header.\n\t\t (test with www.krak.dk/www.rs-components.dk)\n\n\t      Cookies\n\n\t*  Mapping of headers from backend reply to the reply to client\n\n\t      Which fields come from the backend ?\n\n\t      Which fields are made up on the spot ? (expiry time ?)\n\n\t      (Static header fields can be prepended to contents in storage)\n\n\n\t*  3xx replies from the backend\n\n\t      Does varnish follow a redirection or do we pass it to the client ?\n\n\t      Do we cache 3xx replies ?\n\n\nThe first live traffic\n----------------------\n\nThe final bit of history I want to share is the IRC log from the\nfirst time tried to put real live traffic through Varnish.\n\nThe language is interscandinavian, but I think non-vikings can get\nstill get the drift::\n\n\t**** BEGIN LOGGING AT Thu Jul  6 12:36:48 2006\n\n\tJul 06 12:36:48 *\tNow talking on #varnish\n\tJul 06 12:36:48 *\tEvilDES gives channel operator status to andersb\n\tJul 06 12:36:53 *\tEvilDES gives channel operator status to phk\n\tJul 06 12:36:53 <andersb>\thehe\n\tJul 06 12:36:56 <EvilDES>\ts\u00e5nn\n\tJul 06 12:37:00 <andersb>\tJepps, er dere klare?\n\tJul 06 12:37:08 <phk>\tJeg har varnish oppe og k\u00f8re med leonora som backend.\n\tJul 06 12:37:12 *\tEvilDES has changed the topic to: Live testing in progress!\n\tJul 06 12:37:16 *\tEvilDES sets mode +t #varnish\n\tJul 06 12:37:19 <andersb>\tDa setter jeg p\u00e5 trafikk\n\tJul 06 12:37:36 <phk>\tandersb: kan du starte med bare at give us trafiik i 10 sekunder eller s\u00e5 ?\n\tJul 06 12:37:49 *\tedward (edward@f95.linpro.no) has joined #varnish\n\tJul 06 12:38:32 <andersb>\thmm, f\u00f8rst m\u00e5 jeg f\u00e5 trafikk dit.\n\tJul 06 12:38:55 <andersb>\tHar noe kommet? Eller har det blitt suprt etter /systemmeldinger/h.html som er helsefilen?\n\tJul 06 12:39:10 <andersb>\ts/suprt/spurt/\n\tJul 06 12:39:41 <EvilDES>\tser ingenting\n\tJul 06 12:39:45 <phk>\tjeg har ikke set noget endnu...\n\tJul 06 12:40:35 <phk>\tden pr\u00f8ver p\u00e5 port 80\n\tJul 06 12:41:24 <andersb>\tokay..\n\tJul 06 12:41:31 <EvilDES>\tkan vi ikke bare kj\u00f8re varnishd p\u00e5 port 80?\n\tJul 06 12:41:46 <phk>\tok, jeg ville bare helst ikke k\u00f8re som root.\n\tJul 06 12:41:47 <andersb>\tPr\u00f8ver den noe annet n\u00e5?\n\tJul 06 12:41:59 <phk>\tnej stadig 80.\n\tJul 06 12:42:03 <phk>\tJeg starter varnishd som root\n\tJul 06 12:42:08 <EvilDES>\tnei, vent\n\tJul 06 12:42:08 <andersb>\tTopp\n\tJul 06 12:42:11 <andersb>\tokay\n\tJul 06 12:42:15 <andersb>\tkom det 8080 n\u00e5?\n\tJul 06 12:42:18 <EvilDES>\tsysctl reserved_port\n\tJul 06 12:43:04 <andersb>\tokay? F\u00e5r dere 8080 trafikk n\u00e5?\n\tJul 06 12:43:08 <EvilDES>\tsysctl net.inet.ip.portrange.reservedhigh=79\n\tJul 06 12:44:41 <andersb>\tOkay, avventer om vi skal kj\u00f8re 8080 eller 80.\n\tJul 06 12:45:56 <EvilDES>\tstarter den p\u00e5 port 80 som root\n\tJul 06 12:46:01 <phk>\tden k\u00f8rer nu\n\tJul 06 12:46:01 <andersb>\tOkay, vi har funnet ut at m\u00e5ten jeg satte 8080 p\u00e5 i lastbalanserern var feil.\n\tJul 06 12:46:07 <andersb>\tokay p\u00e5 80?\n\tJul 06 12:46:12 <phk>\tvi k\u00f8rer\n\tJul 06 12:46:14 <EvilDES>\tja, masse trafikk\n\tJul 06 12:46:29 <phk>\tomtrent 100 req/sec\n\tJul 06 12:46:37 <phk>\tand we're dead...\n\tJul 06 12:46:40 <EvilDES>\tstopp!\n\tJul 06 12:46:58 <andersb>\tden stopper automatisk.\n\tJul 06 12:47:04 <andersb>\tVi kan bare kj\u00f8re det slik.\n\tJul 06 12:47:06 <EvilDES>\ttok noen sekunder\n\tJul 06 12:47:20 <andersb>\tNpr den begynner svar p\u00e5 80 s\u00e5 vil lastbalanserern finne den fort og sende trafikk.\n\tJul 06 12:47:41 <EvilDES>\tca 1500 connection requests kom inn f\u00f8r den sluttet \u00e5 sende oss trafikk\n\tJul 06 12:47:49 <EvilDES>\talts\u00e5, 1500 etter at varnishd d\u00f8de\n\tJul 06 12:48:02 <andersb>\ttror det er en god nok m\u00e5te \u00e5 gj\u00f8re det p\u00e5. S\u00e5 slipper vi \u00e5 configge hele tiden.\n\tJul 06 12:48:07 <EvilDES>\tgreit\n\tJul 06 12:48:11 <EvilDES>\tdet er dine lesere :)\n\tJul 06 12:48:19 <andersb>\tja :)\n\tJul 06 12:48:35 <andersb>\tkan sette ned retry raten litt.\n\tJul 06 12:49:15 <andersb>\t>> AS3408-2 VG Nett - Real server 21 # retry\n\tJul 06 12:49:16 <andersb>\tCurrent number of failure retries: 4\n\tJul 06 12:49:16 <andersb>\tEnter new number of failure retries [1-63]: 1\n\tJul 06 12:49:33 <andersb>\t^^ before de decalres dead\n\tJul 06 12:49:41 <andersb>\the declairs :)\n\tJul 06 12:51:45 <phk>\tI've saved the core, lets try again for another shot.\n\tJul 06 12:52:09 <andersb>\tsure :)\n\tJul 06 12:52:34 <andersb>\tWhen you start port 80 loadbalancer will send 8 req's for h.html then start gicing traficc\n\tJul 06 12:53:00 <andersb>\t^^ Microsoft keyboard\n\tJul 06 12:53:09 <phk>\tok, jeg starter\n\tJul 06 12:53:10 <EvilDES>\tyou need to get a Linux keyboard\n\tJul 06 12:53:16 <andersb>\tYeah :)\n\tJul 06 12:53:18 <EvilDES>\twoo!\n\tJul 06 12:53:21 <phk>\tboom.\n\tJul 06 12:53:25 <EvilDES>\toops\n\tJul 06 12:53:35 <EvilDES>\t18 connections, 77 requests\n\tJul 06 12:53:40 <EvilDES>\tthat didn't last long...\n\tJul 06 12:54:41 <andersb>\tlonger than me :) *rude joke\n\tJul 06 12:55:04 <phk>\tbewm\n\tJul 06 12:55:22 <andersb>\tcan I follow a log?\n\tJul 06 12:55:39 <andersb>\twith: lt-varnishlog ?\n\tJul 06 12:56:27 <phk>\tsamme fejl\n\tJul 06 12:56:38 <phk>\tandersb: jeg gemmer logfilerne\n\tJul 06 12:57:00 <phk>\tbewm\n\tJul 06 12:57:13 <andersb>\tphk: Jepp, men for min egen del for \u00e5 se n\u00e5r dere skrur p\u00e5 etc. Da l\u00e6rer jeg loadbalancer ting.\n\tJul 06 12:57:51 <phk>\tok, samme fejl igen.\n\tJul 06 12:58:02 <phk>\tjeg foresl\u00e5r vi holder en lille pause mens jeg debugger.\n\tJul 06 12:58:09 <andersb>\tsure.\n\tJul 06 12:58:16 <EvilDES>\tandersb: cd ~varnish/varnish/trunk/varnish-cache/bin/varnishlog\n\tJul 06 12:58:21 <EvilDES>\tandersb: ./varnishlog -o\n\tJul 06 12:58:37 <EvilDES>\tandersb: cd ~varnish/varnish/trunk/varnish-cache/bin/varnishstat\n\tJul 06 12:58:43 <EvilDES>\tandersb: ./varnishstat -c\n\tJul 06 12:58:44 <phk>\teller ./varnislog -r _vlog3 -o | less\n\tJul 06 13:00:02 <andersb>\tJeg g\u00e5r meg en kort tur. Straks tilbake.\n\tJul 06 13:01:27 <phk>\tvi k\u00f8rer igen\n\tJul 06 13:02:31 <phk>\t2k requests\n\tJul 06 13:02:57 <phk>\t3k\n\tJul 06 13:03:39 <phk>\t5k\n\tJul 06 13:03:55 <EvilDES>\tser veldig bra ut\n\tJul 06 13:04:06 <EvilDES>\thit rate > 93%\n\tJul 06 13:04:13 <EvilDES>\t95%\n\tJul 06 13:05:14 <phk>\t800 objects\n\tJul 06 13:05:32 <EvilDES>\tload 0.28\n\tJul 06 13:05:37 <EvilDES>\t0.22\n\tJul 06 13:05:52 <EvilDES>\tCPU 98.9% idle :)\n\tJul 06 13:06:12 <phk>\t4-5 Mbit/sec\n\tJul 06 13:06:42 <andersb>\tnice :)\n\tJul 06 13:06:49 <andersb>\tvi kj\u00f8rer til det krasjer?\n\tJul 06 13:06:58 <phk>\tjep\n\tJul 06 13:07:05 <phk>\tdu m\u00e5 gerne \u00e5bne lidt mere\n\tJul 06 13:07:20 <andersb>\tokay\n\tJul 06 13:07:41 <andersb>\t3 ganger mer...\n\tJul 06 13:08:04 <andersb>\tsi fra n\u00e5r dere vil ha mer.\n\tJul 06 13:08:24 <phk>\tvi gir den lige et par minutter p\u00e5 det her niveau\n\tJul 06 13:09:17 <phk>\tbewm\n\tJul 06 13:09:31 <EvilDES>\t        3351        0.00 Client connections accepted\n\tJul 06 13:09:31 <EvilDES>\t       23159        0.00 Client requests received\n\tJul 06 13:09:31 <EvilDES>\t       21505        0.00 Cache hits\n\tJul 06 13:09:31 <EvilDES>\t        1652        0.00 Cache misses\n\tJul 06 13:10:17 <phk>\tk\u00f8rer igen\n\tJul 06 13:10:19 <EvilDES>\there we go again\n\tJul 06 13:11:06 <phk>\t20mbit/sec\n\tJul 06 13:11:09 <phk>\t100 req/sec\n\tJul 06 13:12:30 <andersb>\tnice :)\n\tJul 06 13:12:46 <andersb>\tdet er gode tall, og jeg skal fortelle dere hvorfor senere\n\tJul 06 13:12:49 <phk>\tsteady 6-8 mbit/sec\n\tJul 06 13:12:52 <andersb>\tokay.\n\tJul 06 13:13:00 <phk>\tca 50 req/sec\n\tJul 06 13:13:04 <EvilDES>\tskal vi \u00f8ke?\n\tJul 06 13:13:14 <phk>\tja, giv den det dobbelte hvis du kan\n\tJul 06 13:13:19 <andersb>\tvi startet med 1 -> 3 -> ?\n\tJul 06 13:13:22 <phk>\t6\n\tJul 06 13:13:23 <andersb>\t6\n\tJul 06 13:13:34 <andersb>\tdone\n\tJul 06 13:13:42 <andersb>\tden hopper opp graceful.\n\tJul 06 13:13:54 <EvilDES>\tboom\n\tJul 06 13:14:06 <andersb>\t:)\n\tJul 06 13:14:11 <EvilDES>\tmen ingen ytelsesproblemer\n\tJul 06 13:14:19 <EvilDES>\tbare bugs i requestparsering\n\tJul 06 13:14:20 <phk>\tk\u00f8rer igen\n\tJul 06 13:14:26 <phk>\tbewm\n\tJul 06 13:14:31 <phk>\tok, vi pauser lige...\n\tJul 06 13:17:40 <phk>\tjeg har et problem med \"pass\" requests, det skal jeg lige have fundet inden vi g\u00e5r videre.\n\tJul 06 13:18:51 <andersb>\tSure.\n\tJul 06 13:28:50 <phk>\tok, vi pr\u00f8ver igen\n\tJul 06 13:29:09 <phk>\tbewm\n\tJul 06 13:29:35 <phk>\tmore debugging\n\tJul 06 13:33:56 <phk>\tOK, found the/one pass-mode bug\n\tJul 06 13:33:58 <phk>\ttrying again\n\tJul 06 13:35:23 <phk>\t150 req/s 24mbit/s, still alive\n\tJul 06 13:37:02 <EvilDES>\tandersb: tror du du klarer \u00e5 komme deg hit til foredraget, eller er du helt \u00f8delagt?\n\tJul 06 13:37:06 <phk>\tandersb: giv den 50% mere trafik\n\tJul 06 13:39:46 <andersb>\tmer trafikk\n\tJul 06 13:39:56 <andersb>\tEvilDES: Nei :(( Men Stein fra VG Nett kommer.\n\tJul 06 13:41:25 <EvilDES>\tbtw, har du noen data om hva load balanceren synes om varnish?\n\tJul 06 13:41:50 <EvilDES>\tjeg regner med at den f\u00f8lger med litt p\u00e5 hvor god jobb vi gj\u00f8r\n\tJul 06 13:43:10 <phk>\tJeg genstarter lige med flere workerthreads...\n\tJul 06 13:43:43 <phk>\tjeg tror 20 workerthreads var for lidt nu...\n\tJul 06 13:43:47 <phk>\tnu har den 220\n\tJul 06 13:44:40 <EvilDES>\t        2976      107.89 Client connections accepted\n\tJul 06 13:44:41 <EvilDES>\t       10748      409.57 Client requests received\n\tJul 06 13:44:41 <EvilDES>\t        9915      389.59 Cache hits\n\tJul 06 13:45:13 <EvilDES>\tdet var alts\u00e5 400 i sekundet :)\n\tJul 06 13:45:45 <phk>\tog ingen indlysende fejl p\u00e5 www.vg.no siden :-)\n\tJul 06 13:45:54 <phk>\tbewm\n\tJul 06 13:47:16 <EvilDES>\tandersb: hvor stor andel av trafikken hadde vi n\u00e5?\n\tJul 06 13:48:06 <EvilDES>\talts\u00e5, vekt i load balanceren i forhold til totalen\n\tJul 06 13:49:20 <phk>\tok, kun 120 threads s\u00e5...\n\tJul 06 13:50:48 <andersb>\t9\n\tJul 06 13:52:45 <phk>\tandersb: 9 -> 12 ?\n\tJul 06 13:52:48 <EvilDES>\tandersb: 9 til varnish, men hvor mye er den totale vekten?\n\tJul 06 13:52:58 <EvilDES>\thar vi 1%? 5%? 10%?\n\tJul 06 13:54:37 <EvilDES>\tn\u00e5 passerte vi nettopp 50000 requests uten kr\u00e6sj\n\tJul 06 13:55:36 <phk>\tmaskinen laver ingenting...  98.5% idle\n\tJul 06 13:56:21 <andersb>\t12 maskiner med weight 20\n\tJul 06 13:56:26 <andersb>\t1 med weight 40\n\tJul 06 13:56:29 <andersb>\tvarnish med 9\n\tJul 06 13:57:01 <andersb>\tsi fra n\u00e5r dere vil ha mer trafikk.\n\tJul 06 13:57:02 <phk>\t9/289 = 3.1%\n\tJul 06 13:57:12 <phk>\tandersb: giv den 15\n\tJul 06 13:57:44 <andersb>\tgjort\n\tJul 06 13:59:43 <andersb>\tdette er morro. Jeg m\u00e5 si det.\n\tJul 06 14:00:27 <phk>\t20-23 Mbit/sec steady, 200 req/sec, 92.9% idle\n\tJul 06 14:00:30 <phk>\tbewm\n\tJul 06 14:00:46 <EvilDES>\tOK\n\tJul 06 14:00:57 <EvilDES>\tjeg tror vi kan sl\u00e5 fast at ytelsen er som den skal v\u00e6re\n\tJul 06 14:01:33 <EvilDES>\tdet er en del bugs, men de b\u00f8r det g\u00e5 an \u00e5 fikse.\n\tJul 06 14:01:34 <andersb>\tJepp :) Det s\u00e5 pent ut...\n\tJul 06 14:01:53 <phk>\tjeg tror ikke vi har set skyggen af hvad Varnish kan yde endnu...\n\tJul 06 14:01:53 <EvilDES>\tandersb: hvordan ligger vi an i forhold til Squid?\n\tJul 06 14:01:58 <andersb>\tpent :)\n\tJul 06 14:02:13 <andersb>\tJeg har ikke f\u00e5tt SNMP opp p\u00e5 dene boksen, jeg burde grafe det...\n\tJul 06 14:02:23 <EvilDES>\tsnmp kj\u00f8rer p\u00e5 c21\n\tJul 06 14:02:33 <EvilDES>\ttror agero satte det opp\n\tJul 06 14:02:36 <EvilDES>\taagero\n\tJul 06 14:02:38 <andersb>\tJa, men jeg har ikke mal i cacti for bsnmpd\n\tJul 06 14:02:43 <EvilDES>\tah, ok\n\tJul 06 14:03:03 <EvilDES>\tmen den burde st\u00f8tte standard v2 mib?\n\tJul 06 14:03:26 <andersb>\tdet er ikke protocoll feil :)\n\tJul 06 14:03:42 <andersb>\tHva er byte hitratio forresetn?\n\tJul 06 14:03:52 <EvilDES>\tdet tror jeg ikke vi m\u00e5ler\n\tJul 06 14:03:55 <EvilDES>\tenda\n\tJul 06 14:03:59 <phk>\tandersb: den har jeg ikke stats p\u00e5 endnu.\n\tJul 06 14:04:22 <phk>\tok, forrige crash ligner en 4k+ HTTP header...\n\tJul 06 14:04:27 <phk>\t(eller en kodefejl)\n\tJul 06 14:06:03 <phk>\tandersb: pr\u00f8v at \u00f8ge vores andel til 20\n\tJul 06 14:06:26 <EvilDES>\thvilken vekt har hver av de andre cachene?\n\tJul 06 14:06:49 <phk>\t20 og en med 40\n\tJul 06 14:07:50 <andersb>\tgjort\n\tJul 06 14:08:59 <phk>\t440 req/s 43mbit/s\n\tJul 06 14:09:17 <phk>\tbewm\n\tJul 06 14:09:18 <EvilDES>\tbewm\n\tJul 06 14:10:30 <EvilDES>\toj\n\tJul 06 14:10:39 <EvilDES>\tvi var oppe over 800 req/s et \u00f8yeblikk\n\tJul 06 14:10:46 <phk>\t60mbit/sec\n\tJul 06 14:10:52 <phk>\tog 90% idle :-)\n\tJul 06 14:10:59 <EvilDES>\tingen swapping\n\tJul 06 14:11:58 <EvilDES>\tog vi bruker nesten ikke noe minne - 3 GB ledig fysisk RAM\n\tJul 06 14:13:02 <phk>\tca 60 syscall / req\n\tJul 06 14:14:31 <andersb>\tnice :)\n\tJul 06 14:14:58 <phk>\tandersb: pr\u00f8v at give os 40\n\tJul 06 14:17:26 <andersb>\tgjort\n\tJul 06 14:18:17 <phk>\tdet ligner at trafikken falder her sidst p\u00e5 eftermiddagen...\n\tJul 06 14:19:07 <andersb>\tja :)\n\tJul 06 14:19:43 <phk>\tandersb: s\u00e5 skal vi nok ikke \u00f8ge mere, nu n\u00e6rmer vi os hvad 100Mbit ethernet kan klare.\n\tJul 06 14:19:58 <andersb>\tbra :)\n\tJul 06 14:20:36 <phk>\t42mbit/s steady\n\tJul 06 14:20:59 <EvilDES>\t40 av 320?\n\tJul 06 14:21:06 <EvilDES>\t12,5%\n\tJul 06 14:21:43 *\tnicholas (nicholas@nfsd.linpro.no) has joined #varnish\n\tJul 06 14:22:00 <phk>\tdet der cluster-noget bliver der da ikke brug for n\u00e5r vi har 87% idle\n\tJul 06 14:23:05 <andersb>\thehe :)\n\tJul 06 14:24:38 <andersb>\tskal stille de andre ned litt for 48 er max\n\tJul 06 14:24:57 <phk>\tjeg tror ikke vi skal g\u00e5 h\u00f8jere f\u00f8r vi har gigE\n\tJul 06 14:25:14 <andersb>\t4-5MB/s\n\tJul 06 14:25:32 <andersb>\tlastbalanserer backer off p\u00e5 100 Mbit\n\tJul 06 14:25:35 <andersb>\t:)\n\tJul 06 14:25:42 <andersb>\tS\u00e5 vi kan kj\u00f8re nesten til taket.\n\tJul 06 14:26:01 <andersb>\thvis det har noe poeng.\n\tJul 06 14:26:09 <andersb>\tcrash :)\n\tJul 06 14:27:33 <phk>\tbewm\n\tJul 06 14:29:08 <andersb>\tStilt inn alle p\u00e5 weight 5\n\tJul 06 14:29:17 <andersb>\tbortsett fra 1 som er 10\n\tJul 06 14:29:20 <andersb>\tvarnish er 5\n\tJul 06 14:29:24 <phk>\ts\u00e5 giv os 20\n\tJul 06 14:29:51 <andersb>\tgjort\n\tJul 06 14:30:58 <phk>\tvi f\u00e5r kun 300 req/s\n\tJul 06 14:31:04 <phk>\tAhh der skete noget.\n\tJul 06 14:32:41 <phk>\tok, ved denne last bliver backend connections et problem, jeg har set dns fejl og connection refused\n\tJul 06 14:33:10 <phk>\tdns fejl\n\tJul 06 14:33:21 <andersb>\tokay, pek den mot 10.0.2.5\n\tJul 06 14:33:28 <andersb>\tdet er layer 2 squid cache\n\tJul 06 14:33:35 <andersb>\tmorro \u00e5 teste det og.\n\tJul 06 14:33:54 <phk>\tdet g\u00f8r jeg n\u00e6ste gang den falder\n\tJul 06 14:34:48 <phk>\tjeg kunne jo ogs\u00e5 bare give leonors IP# istedet... men nu k\u00f8rer vi imod squid\n\tJul 06 14:36:05 <andersb>\tja, gi leonora IP det er sikkert bedre. Eller det kan jo v\u00e6re fint \u00e5 teste mot squid og :)\n\tJul 06 14:39:04 <phk>\tnu k\u00f8rer vi med leonora's IP#\n\tJul 06 14:39:33 <phk>\tnu k\u00f8rer vi med leonora's *rigtige* IP#\n\tJul 06 14:41:20 <phk>\tNu er vi f\u00e6rdige med det her 100Mbit/s ethernet, kan vi f\u00e5 et til ?  :-)\n\tJul 06 14:41:42 <andersb>\tlol :)\n\tJul 06 14:42:00 <andersb>\tFor \u00e5 si det slik. Det tar ikke mange dagene f\u00f8r Gig switch er bestilt :)\n\tJul 06 14:43:05 <phk>\tbewm\n\tJul 06 14:43:13 <phk>\tok, jeg synes vi skal stoppe her.\n\tJul 06 14:43:41 <EvilDES>\tjepp, foredrag om 15 min\n\tJul 06 14:43:57 <andersb>\tjepp\n\tJul 06 14:44:23 <andersb>\tdisabled server\n\tJul 06 14:45:29 <EvilDES>\tdette har v\u00e6rt en veldig bra dag.\n\tJul 06 14:45:49 <EvilDES>\thva skal vi finne p\u00e5 i morgen? skifte ut hele Squid-riggen med en enkelt Varnish-boks? ;)\n\tJul 06 14:45:53 <andersb>\tlol\n\tJul 06 14:46:15 *\tEvilDES m\u00e5 begynne \u00e5 sette i stand til foredraget\n\tJul 06 14:46:17 <andersb>\tda m\u00e5 jeg har Gig switch. Eller s\u00e5 kan v\u00e6re b\u00e6re med en HP maskin \u00e5 koble rett p\u00e5 lastbal :)\n\tJul 06 14:46:22 <phk>\tkan vi ikke n\u00f8jes med en halv varnish box ?\n\tJul 06 14:46:41 <EvilDES>\tvi m\u00e5 ha begge halvdeler for failover\n\tJul 06 14:47:01 <andersb>\t:)\n\tJul 06 14:47:14 <andersb>\tkan faile tilbake til de andre.\n\tJul 06 14:47:25 <andersb>\tJeg klarer ikke holde meg hjemme.\n\tJul 06 14:47:33 <andersb>\t Jeg kommer oppover om litt :)\n\tJul 06 14:47:39 <andersb>\tRinger p\u00e5.\n\tJul 06 14:48:19 <andersb>\tm\u00e5 g\u00e5 en tur n\u00e5 :)\n\tJul 06 14:48:29 *\tandersb has quit (BitchX: no additives or preservatives)\n\tJul 06 14:49:44 <EvilDES>\thttp://www.des.no/varnish/\n\t**** ENDING LOGGING AT Thu Jul  6 14:52:04 2006\n\n*phk*\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-varnish-cache-6.4.0-rypi4oyixvgpbmjahq5n45zcm4a7jnyy/spack-src/doc/sphinx/phk/bjarne.jpeg"
    ],
    "total_files": 1526
}