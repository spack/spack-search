{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/src/cpu/jit_utils/jitprofiling/jitprofiling.c": "/* <copyright>\n\n  Contact Information:\n  http://software.intel.com/en-us/articles/intel-vtune-amplifier-xe/\n\n  BSD LICENSE\n\n  Copyright (c) 2005-2014 Intel Corporation. All rights reserved.\n  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n    * Neither the name of Intel Corporation nor the names of its\n      contributors may be used to endorse or promote products derived\n      from this software without specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n</copyright> */\n\n#include \"ittnotify_config.h\"\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#include <windows.h>\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#if ITT_PLATFORM != ITT_PLATFORM_MAC && ITT_PLATFORM != ITT_PLATFORM_FREEBSD\n#include <malloc.h>\n#endif\n#include <stdlib.h>\n\n#include \"jitprofiling.h\"\n\nstatic const char rcsid[] = \"\\n@(#) $Revision: 471937 $\\n\";\n\n#define DLL_ENVIRONMENT_VAR             \"VS_PROFILER\"\n\n#ifndef NEW_DLL_ENVIRONMENT_VAR\n#if ITT_ARCH==ITT_ARCH_IA32\n#define NEW_DLL_ENVIRONMENT_VAR\t        \"INTEL_JIT_PROFILER32\"\n#else\n#define NEW_DLL_ENVIRONMENT_VAR\t        \"INTEL_JIT_PROFILER64\"\n#endif\n#endif /* NEW_DLL_ENVIRONMENT_VAR */\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#define DEFAULT_DLLNAME                 \"JitPI.dll\"\nHINSTANCE m_libHandle = NULL;\n#elif ITT_PLATFORM==ITT_PLATFORM_MAC\n#define DEFAULT_DLLNAME                 \"libJitPI.dylib\"\nvoid* m_libHandle = NULL;\n#else\n#define DEFAULT_DLLNAME                 \"libJitPI.so\"\nvoid* m_libHandle = NULL;\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n/* default location of JIT profiling agent on Android */\n#define ANDROID_JIT_AGENT_PATH  \"/data/intel/libittnotify.so\"\n\n/* the function pointers */\ntypedef unsigned int(JITAPI *TPInitialize)(void);\nstatic TPInitialize FUNC_Initialize=NULL;\n\ntypedef unsigned int(JITAPI *TPNotify)(unsigned int, void*);\nstatic TPNotify FUNC_NotifyEvent=NULL;\n\nstatic iJIT_IsProfilingActiveFlags executionMode = iJIT_NOTHING_RUNNING;\n\n/* end collector dll part. */\n\n/* loadiJIT_Funcs() : this function is called just in the beginning\n * and is responsible to load the functions from BistroJavaCollector.dll\n * result:\n *  on success: the functions loads, iJIT_DLL_is_missing=0, return value = 1\n *  on failure: the functions are NULL, iJIT_DLL_is_missing=1, return value = 0\n */\nstatic int loadiJIT_Funcs(void);\n\n/* global representing whether the collector can't be loaded */\nstatic int iJIT_DLL_is_missing = 0;\n\nITT_EXTERN_C int JITAPI\niJIT_NotifyEvent(iJIT_JVM_EVENT event_type, void *EventSpecificData)\n{\n    int ReturnValue = 0;\n\n    /* initialization part - the collector has not been loaded yet. */\n    if (!FUNC_NotifyEvent)\n    {\n        if (iJIT_DLL_is_missing)\n            return 0;\n\n        if (!loadiJIT_Funcs())\n            return 0;\n    }\n\n    if (event_type == iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED ||\n        event_type == iJVM_EVENT_TYPE_METHOD_UPDATE)\n    {\n        if (((piJIT_Method_Load)EventSpecificData)->method_id == 0)\n            return 0;\n    }\n    else if (event_type == iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED_V2)\n    {\n        if (((piJIT_Method_Load_V2)EventSpecificData)->method_id == 0)\n            return 0;\n    }\n    else if (event_type == iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED_V3)\n    {\n        if (((piJIT_Method_Load_V3)EventSpecificData)->method_id == 0)\n            return 0;\n    }\n    else if (event_type == iJVM_EVENT_TYPE_METHOD_INLINE_LOAD_FINISHED)\n    {\n        if (((piJIT_Method_Inline_Load)EventSpecificData)->method_id == 0 ||\n            ((piJIT_Method_Inline_Load)EventSpecificData)->parent_method_id == 0)\n            return 0;\n    }\n\n    ReturnValue = (int)FUNC_NotifyEvent(event_type, EventSpecificData);\n\n    return ReturnValue;\n}\n\nITT_EXTERN_C iJIT_IsProfilingActiveFlags JITAPI iJIT_IsProfilingActive()\n{\n    if (!iJIT_DLL_is_missing)\n    {\n        loadiJIT_Funcs();\n    }\n\n    return executionMode;\n}\n\n/* This function loads the collector dll and the relevant functions.\n * on success: all functions load,     iJIT_DLL_is_missing = 0, return value = 1\n * on failure: all functions are NULL, iJIT_DLL_is_missing = 1, return value = 0\n */\nstatic int loadiJIT_Funcs()\n{\n    static int bDllWasLoaded = 0;\n    char *dllName = (char*)rcsid; /* !! Just to avoid unused code elimination */\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n    DWORD dNameLength = 0;\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n    if(bDllWasLoaded)\n    {\n        /* dll was already loaded, no need to do it for the second time */\n        return 1;\n    }\n\n    /* Assumes that the DLL will not be found */\n    iJIT_DLL_is_missing = 1;\n    FUNC_NotifyEvent = NULL;\n\n    if (m_libHandle)\n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        FreeLibrary(m_libHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        dlclose(m_libHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        m_libHandle = NULL;\n    }\n\n    /* Try to get the dll name from the environment */\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n    dNameLength = GetEnvironmentVariableA(NEW_DLL_ENVIRONMENT_VAR, NULL, 0);\n    if (dNameLength)\n    {\n        DWORD envret = 0;\n        dllName = (char*)malloc(sizeof(char) * (dNameLength + 1));\n        if(dllName != NULL)\n        {\n            envret = GetEnvironmentVariableA(NEW_DLL_ENVIRONMENT_VAR, \n                                             dllName, dNameLength);\n            if (envret)\n            {\n                /* Try to load the dll from the PATH... */\n                m_libHandle = LoadLibraryExA(dllName, \n                                             NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n            }\n            free(dllName);\n        }\n    } else {\n        /* Try to use old VS_PROFILER variable */\n        dNameLength = GetEnvironmentVariableA(DLL_ENVIRONMENT_VAR, NULL, 0);\n        if (dNameLength)\n        {\n            DWORD envret = 0;\n            dllName = (char*)malloc(sizeof(char) * (dNameLength + 1));\n            if(dllName != NULL)\n            {\n                envret = GetEnvironmentVariableA(DLL_ENVIRONMENT_VAR, \n                                                 dllName, dNameLength);\n                if (envret)\n                {\n                    /* Try to load the dll from the PATH... */\n                    m_libHandle = LoadLibraryA(dllName);\n                }\n                free(dllName);\n            }\n        }\n    }\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    dllName = getenv(NEW_DLL_ENVIRONMENT_VAR);\n    if (!dllName)\n        dllName = getenv(DLL_ENVIRONMENT_VAR);\n#if defined(__ANDROID__) || defined(ANDROID)\n    if (!dllName)\n        dllName = ANDROID_JIT_AGENT_PATH;\n#endif\n    if (dllName)\n    {\n        /* Try to load the dll from the PATH... */\n        m_libHandle = dlopen(dllName, RTLD_LAZY);\n    }\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n    if (!m_libHandle)\n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        m_libHandle = LoadLibraryA(DEFAULT_DLLNAME);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        m_libHandle = dlopen(DEFAULT_DLLNAME, RTLD_LAZY);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    }\n\n    /* if the dll wasn't loaded - exit. */\n    if (!m_libHandle)\n    {\n        iJIT_DLL_is_missing = 1; /* don't try to initialize\n                                  * JIT agent the second time\n                                  */\n        return 0;\n    }\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n    FUNC_NotifyEvent = (TPNotify)GetProcAddress(m_libHandle, \"NotifyEvent\");\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    FUNC_NotifyEvent = (TPNotify)dlsym(m_libHandle, \"NotifyEvent\");\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    if (!FUNC_NotifyEvent) \n    {\n        FUNC_Initialize = NULL;\n        return 0;\n    }\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n    FUNC_Initialize = (TPInitialize)GetProcAddress(m_libHandle, \"Initialize\");\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    FUNC_Initialize = (TPInitialize)dlsym(m_libHandle, \"Initialize\");\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    if (!FUNC_Initialize) \n    {\n        FUNC_NotifyEvent = NULL;\n        return 0;\n    }\n\n    executionMode = (iJIT_IsProfilingActiveFlags)FUNC_Initialize();\n\n    bDllWasLoaded = 1;\n    iJIT_DLL_is_missing = 0; /* DLL is ok. */\n\n    return 1;\n}\n\nITT_EXTERN_C unsigned int JITAPI iJIT_GetNewMethodID()\n{\n    static unsigned int methodID = 1;\n\n    if (methodID == 0)\n        return 0;  /* ERROR : this is not a valid value */\n\n    return methodID++;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/src/cpu/jit_utils/jitprofiling/ittnotify_config.h": "/* <copyright>\n\n  Contact Information:\n  http://software.intel.com/en-us/articles/intel-vtune-amplifier-xe/\n\n  BSD LICENSE\n\n  Copyright (c) 2005-2014 Intel Corporation. All rights reserved.\n  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n    * Neither the name of Intel Corporation nor the names of its\n      contributors may be used to endorse or promote products derived\n      from this software without specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n</copyright> */\n#ifndef _ITTNOTIFY_CONFIG_H_\n#define _ITTNOTIFY_CONFIG_H_\n\n/** @cond exclude_from_documentation */\n#ifndef ITT_OS_WIN\n#  define ITT_OS_WIN   1\n#endif /* ITT_OS_WIN */\n\n#ifndef ITT_OS_LINUX\n#  define ITT_OS_LINUX 2\n#endif /* ITT_OS_LINUX */\n\n#ifndef ITT_OS_MAC\n#  define ITT_OS_MAC   3\n#endif /* ITT_OS_MAC */\n\n#ifndef ITT_OS_FREEBSD\n#  define ITT_OS_FREEBSD   4\n#endif /* ITT_OS_FREEBSD */\n\n#ifndef ITT_OS\n#  if defined WIN32 || defined _WIN32\n#    define ITT_OS ITT_OS_WIN\n#  elif defined( __APPLE__ ) && defined( __MACH__ )\n#    define ITT_OS ITT_OS_MAC\n#  elif defined( __FreeBSD__ )\n#    define ITT_OS ITT_OS_FREEBSD\n#  else\n#    define ITT_OS ITT_OS_LINUX\n#  endif\n#endif /* ITT_OS */\n\n#ifndef ITT_PLATFORM_WIN\n#  define ITT_PLATFORM_WIN 1\n#endif /* ITT_PLATFORM_WIN */\n\n#ifndef ITT_PLATFORM_POSIX\n#  define ITT_PLATFORM_POSIX 2\n#endif /* ITT_PLATFORM_POSIX */\n\n#ifndef ITT_PLATFORM_MAC\n#  define ITT_PLATFORM_MAC 3\n#endif /* ITT_PLATFORM_MAC */\n\n#ifndef ITT_PLATFORM_FREEBSD\n#  define ITT_PLATFORM_FREEBSD 4\n#endif /* ITT_PLATFORM_FREEBSD */\n\n#ifndef ITT_PLATFORM\n#  if ITT_OS==ITT_OS_WIN\n#    define ITT_PLATFORM ITT_PLATFORM_WIN\n#  elif ITT_OS==ITT_OS_MAC\n#    define ITT_PLATFORM ITT_PLATFORM_MAC\n#  elif ITT_OS==ITT_OS_FREEBSD\n#    define ITT_PLATFORM ITT_PLATFORM_FREEBSD\n#  else\n#    define ITT_PLATFORM ITT_PLATFORM_POSIX\n#  endif\n#endif /* ITT_PLATFORM */\n\n#if defined(_UNICODE) && !defined(UNICODE)\n#define UNICODE\n#endif\n\n#include <stddef.h>\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#include <tchar.h>\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <stdint.h>\n#if defined(UNICODE) || defined(_UNICODE)\n#include <wchar.h>\n#endif /* UNICODE || _UNICODE */\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#ifndef ITTAPI_CDECL\n#  if ITT_PLATFORM==ITT_PLATFORM_WIN\n#    define ITTAPI_CDECL __cdecl\n#  else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#    if defined _M_IX86 || defined __i386__\n#      define ITTAPI_CDECL __attribute__ ((cdecl))\n#    else  /* _M_IX86 || __i386__ */\n#      define ITTAPI_CDECL /* actual only on x86 platform */\n#    endif /* _M_IX86 || __i386__ */\n#  endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* ITTAPI_CDECL */\n\n#ifndef STDCALL\n#  if ITT_PLATFORM==ITT_PLATFORM_WIN\n#    define STDCALL __stdcall\n#  else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#    if defined _M_IX86 || defined __i386__\n#      define STDCALL __attribute__ ((stdcall))\n#    else  /* _M_IX86 || __i386__ */\n#      define STDCALL /* supported only on x86 platform */\n#    endif /* _M_IX86 || __i386__ */\n#  endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* STDCALL */\n\n#define ITTAPI    ITTAPI_CDECL\n#define LIBITTAPI ITTAPI_CDECL\n\n/* TODO: Temporary for compatibility! */\n#define ITTAPI_CALL    ITTAPI_CDECL\n#define LIBITTAPI_CALL ITTAPI_CDECL\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n/* use __forceinline (VC++ specific) */\n#define ITT_INLINE           __forceinline\n#define ITT_INLINE_ATTRIBUTE /* nothing */\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n/*\n * Generally, functions are not inlined unless optimization is specified.\n * For functions declared inline, this attribute inlines the function even\n * if no optimization level was specified.\n */\n#ifdef __STRICT_ANSI__\n#define ITT_INLINE           static\n#define ITT_INLINE_ATTRIBUTE __attribute__((unused))\n#else  /* __STRICT_ANSI__ */\n#define ITT_INLINE           static inline\n#define ITT_INLINE_ATTRIBUTE __attribute__((always_inline, unused))\n#endif /* __STRICT_ANSI__ */\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n/** @endcond */\n\n#ifndef ITT_ARCH_IA32\n#  define ITT_ARCH_IA32  1\n#endif /* ITT_ARCH_IA32 */\n\n#ifndef ITT_ARCH_IA32E\n#  define ITT_ARCH_IA32E 2\n#endif /* ITT_ARCH_IA32E */\n\n#ifndef ITT_ARCH_ARM\n#  define ITT_ARCH_ARM  4\n#endif /* ITT_ARCH_ARM */\n\n#ifndef ITT_ARCH_PPC64\n#  define ITT_ARCH_PPC64  5\n#endif /* ITT_ARCH_PPC64 */\n\n#ifndef ITT_ARCH\n#  if defined _M_IX86 || defined __i386__\n#    define ITT_ARCH ITT_ARCH_IA32\n#  elif defined _M_X64 || defined _M_AMD64 || defined __x86_64__\n#    define ITT_ARCH ITT_ARCH_IA32E\n#  elif defined _M_IA64 || defined __ia64__\n#    define ITT_ARCH ITT_ARCH_IA64\n#  elif defined _M_ARM || defined __arm__\n#    define ITT_ARCH ITT_ARCH_ARM\n#  elif defined __powerpc64__\n#    define ITT_ARCH ITT_ARCH_PPC64\n#  endif\n#endif\n\n#ifdef __cplusplus\n#  define ITT_EXTERN_C extern \"C\"\n#  define ITT_EXTERN_C_BEGIN extern \"C\" {\n#  define ITT_EXTERN_C_END }\n#else\n#  define ITT_EXTERN_C /* nothing */\n#  define ITT_EXTERN_C_BEGIN /* nothing */\n#  define ITT_EXTERN_C_END /* nothing */\n#endif /* __cplusplus */\n\n#define ITT_TO_STR_AUX(x) #x\n#define ITT_TO_STR(x)     ITT_TO_STR_AUX(x)\n\n#define __ITT_BUILD_ASSERT(expr, suffix) do { \\\n    static char __itt_build_check_##suffix[(expr) ? 1 : -1]; \\\n    __itt_build_check_##suffix[0] = 0; \\\n} while(0)\n#define _ITT_BUILD_ASSERT(expr, suffix)  __ITT_BUILD_ASSERT((expr), suffix)\n#define ITT_BUILD_ASSERT(expr)           _ITT_BUILD_ASSERT((expr), __LINE__)\n\n#define ITT_MAGIC { 0xED, 0xAB, 0xAB, 0xEC, 0x0D, 0xEE, 0xDA, 0x30 }\n\n/* Replace with snapshot date YYYYMMDD for promotion build. */\n#define API_VERSION_BUILD    20151119\n\n#ifndef API_VERSION_NUM\n#define API_VERSION_NUM 0.0.0\n#endif /* API_VERSION_NUM */\n\n#define API_VERSION \"ITT-API-Version \" ITT_TO_STR(API_VERSION_NUM) \\\n                                \" (\" ITT_TO_STR(API_VERSION_BUILD) \")\"\n\n/* OS communication functions */\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#include <windows.h>\ntypedef HMODULE           lib_t;\ntypedef DWORD             TIDT;\ntypedef CRITICAL_SECTION  mutex_t;\n#define MUTEX_INITIALIZER { 0 }\n#define strong_alias(name, aliasname) /* empty for Windows */\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <dlfcn.h>\n#if defined(UNICODE) || defined(_UNICODE)\n#include <wchar.h>\n#endif /* UNICODE */\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE 1 /* need for PTHREAD_MUTEX_RECURSIVE */\n#endif /* _GNU_SOURCE */\n#ifndef __USE_UNIX98\n#define __USE_UNIX98 1 /* need for PTHREAD_MUTEX_RECURSIVE, on SLES11.1 with gcc 4.3.4 wherein pthread.h missing dependency on __USE_XOPEN2K8 */\n#endif /*__USE_UNIX98*/\n#include <pthread.h>\ntypedef void*             lib_t;\ntypedef pthread_t         TIDT;\ntypedef pthread_mutex_t   mutex_t;\n#define MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER\n#define _strong_alias(name, aliasname) \\\n            extern __typeof (name) aliasname __attribute__ ((alias (#name)));\n#define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#define __itt_get_proc(lib, name) GetProcAddress(lib, name)\n#define __itt_mutex_init(mutex)   InitializeCriticalSection(mutex)\n#define __itt_mutex_lock(mutex)   EnterCriticalSection(mutex)\n#define __itt_mutex_unlock(mutex) LeaveCriticalSection(mutex)\n#define __itt_load_lib(name)      LoadLibraryA(name)\n#define __itt_unload_lib(handle)  FreeLibrary(handle)\n#define __itt_system_error()      (int)GetLastError()\n#define __itt_fstrcmp(s1, s2)     lstrcmpA(s1, s2)\n#define __itt_fstrnlen(s, l)      strnlen_s(s, l)\n#define __itt_fstrcpyn(s1, b, s2, l) strncpy_s(s1, b, s2, l)\n#define __itt_fstrdup(s)          _strdup(s)\n#define __itt_thread_id()         GetCurrentThreadId()\n#define __itt_thread_yield()      SwitchToThread()\n#ifndef ITT_SIMPLE_INIT\nITT_INLINE long\n__itt_interlocked_increment(volatile long* ptr) ITT_INLINE_ATTRIBUTE;\nITT_INLINE long __itt_interlocked_increment(volatile long* ptr)\n{\n    return InterlockedIncrement(ptr);\n}\n#endif /* ITT_SIMPLE_INIT */\n\n#define DL_SYMBOLS (1)\n#define PTHREAD_SYMBOLS (1)\n\n#else /* ITT_PLATFORM!=ITT_PLATFORM_WIN */\n#define __itt_get_proc(lib, name) dlsym(lib, name)\n#define __itt_mutex_init(mutex)   {\\\n    pthread_mutexattr_t mutex_attr;                                         \\\n    int error_code = pthread_mutexattr_init(&mutex_attr);                   \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutexattr_init\",    \\\n                           error_code);                                     \\\n    error_code = pthread_mutexattr_settype(&mutex_attr,                     \\\n                                           PTHREAD_MUTEX_RECURSIVE);        \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutexattr_settype\", \\\n                           error_code);                                     \\\n    error_code = pthread_mutex_init(mutex, &mutex_attr);                    \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutex_init\",        \\\n                           error_code);                                     \\\n    error_code = pthread_mutexattr_destroy(&mutex_attr);                    \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutexattr_destroy\", \\\n                           error_code);                                     \\\n}\n#define __itt_mutex_lock(mutex)   pthread_mutex_lock(mutex)\n#define __itt_mutex_unlock(mutex) pthread_mutex_unlock(mutex)\n#define __itt_load_lib(name)      dlopen(name, RTLD_LAZY)\n#define __itt_unload_lib(handle)  dlclose(handle)\n#define __itt_system_error()      errno\n#define __itt_fstrcmp(s1, s2)     strcmp(s1, s2)\n\n/* makes customer code define safe APIs for SDL_STRNLEN_S and SDL_STRNCPY_S */\n#ifdef SDL_STRNLEN_S\n#define __itt_fstrnlen(s, l)      SDL_STRNLEN_S(s, l)\n#else\n#define __itt_fstrnlen(s, l)      strlen(s)\n#endif /* SDL_STRNLEN_S */\n#ifdef SDL_STRNCPY_S\n#define __itt_fstrcpyn(s1, b, s2, l) SDL_STRNCPY_S(s1, b, s2, l)\n#else\n#define __itt_fstrcpyn(s1, b, s2, l) strncpy(s1, s2, l)\n#endif /* SDL_STRNCPY_S */\n\n#define __itt_fstrdup(s)          strdup(s)\n#define __itt_thread_id()         pthread_self()\n#define __itt_thread_yield()      sched_yield()\n#if ITT_ARCH==ITT_ARCH_IA64\n#ifdef __INTEL_COMPILER\n#define __TBB_machine_fetchadd4(addr, val) __fetchadd4_acq((void *)addr, val)\n#else  /* __INTEL_COMPILER */\n/* TODO: Add Support for not Intel compilers for IA-64 architecture */\n#endif /* __INTEL_COMPILER */\n#elif ITT_ARCH==ITT_ARCH_IA32 || ITT_ARCH==ITT_ARCH_IA32E /* ITT_ARCH!=ITT_ARCH_IA64 */\nITT_INLINE long\n__TBB_machine_fetchadd4(volatile void* ptr, long addend) ITT_INLINE_ATTRIBUTE;\nITT_INLINE long __TBB_machine_fetchadd4(volatile void* ptr, long addend)\n{\n    long result;\n    __asm__ __volatile__(\"lock\\nxadd %0,%1\"\n                          : \"=r\"(result),\"=m\"(*(int*)ptr)\n                          : \"0\"(addend), \"m\"(*(int*)ptr)\n                          : \"memory\");\n    return result;\n}\n#elif ITT_ARCH==ITT_ARCH_ARM || ITT_ARCH==ITT_ARCH_PPC64\n#define __TBB_machine_fetchadd4(addr, val) __sync_fetch_and_add(addr, val)\n#endif /* ITT_ARCH==ITT_ARCH_IA64 */\n#ifndef ITT_SIMPLE_INIT\nITT_INLINE long\n__itt_interlocked_increment(volatile long* ptr) ITT_INLINE_ATTRIBUTE;\nITT_INLINE long __itt_interlocked_increment(volatile long* ptr)\n{\n    return __TBB_machine_fetchadd4(ptr, 1) + 1L;\n}\n#endif /* ITT_SIMPLE_INIT */\n\n#if 0\nvoid* dlopen(const char*, int) __attribute__((weak));\nvoid* dlsym(void*, const char*) __attribute__((weak));\nint dlclose(void*) __attribute__((weak));\n#else\nvoid* dlopen(const char*, int);\nvoid* dlsym(void*, const char*);\nint dlclose(void*);\n#endif\n#define DL_SYMBOLS (dlopen && dlsym && dlclose)\n\n#if 0\nint pthread_mutex_init(pthread_mutex_t*, const pthread_mutexattr_t*) __attribute__((weak));\nint pthread_mutex_lock(pthread_mutex_t*) __attribute__((weak));\nint pthread_mutex_unlock(pthread_mutex_t*) __attribute__((weak));\nint pthread_mutex_destroy(pthread_mutex_t*) __attribute__((weak));\nint pthread_mutexattr_init(pthread_mutexattr_t*) __attribute__((weak));\nint pthread_mutexattr_settype(pthread_mutexattr_t*, int) __attribute__((weak));\nint pthread_mutexattr_destroy(pthread_mutexattr_t*) __attribute__((weak));\npthread_t pthread_self(void) __attribute__((weak));\n#else\nint pthread_mutex_init(pthread_mutex_t*, const pthread_mutexattr_t*);\nint pthread_mutex_lock(pthread_mutex_t*);\nint pthread_mutex_unlock(pthread_mutex_t*);\nint pthread_mutex_destroy(pthread_mutex_t*);\nint pthread_mutexattr_init(pthread_mutexattr_t*);\nint pthread_mutexattr_settype(pthread_mutexattr_t*, int);\nint pthread_mutexattr_destroy(pthread_mutexattr_t*);\npthread_t pthread_self(void);\n#endif\n#define PTHREAD_SYMBOLS (pthread_mutex_init && pthread_mutex_lock && pthread_mutex_unlock && pthread_mutex_destroy && pthread_mutexattr_init && pthread_mutexattr_settype && pthread_mutexattr_destroy && pthread_self)\n\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\ntypedef enum {\n    __itt_collection_normal = 0,\n    __itt_collection_paused = 1\n} __itt_collection_state;\n\ntypedef enum {\n    __itt_thread_normal  = 0,\n    __itt_thread_ignored = 1\n} __itt_thread_state;\n\n#pragma pack(push, 8)\n\ntypedef struct ___itt_thread_info\n{\n    const char* nameA; /*!< Copy of original name in ASCII. */\n#if defined(UNICODE) || defined(_UNICODE)\n    const wchar_t* nameW; /*!< Copy of original name in UNICODE. */\n#else  /* UNICODE || _UNICODE */\n    void* nameW;\n#endif /* UNICODE || _UNICODE */\n    TIDT               tid;\n    __itt_thread_state state;   /*!< Thread state (paused or normal) */\n    int                extra1;  /*!< Reserved to the runtime */\n    void*              extra2;  /*!< Reserved to the runtime */\n    struct ___itt_thread_info* next;\n} __itt_thread_info;\n\n#include \"ittnotify_types.h\" /* For __itt_group_id definition */\n\ntypedef struct ___itt_api_info_20101001\n{\n    const char*    name;\n    void**         func_ptr;\n    void*          init_func;\n    __itt_group_id group;\n}  __itt_api_info_20101001;\n\ntypedef struct ___itt_api_info\n{\n    const char*    name;\n    void**         func_ptr;\n    void*          init_func;\n    void*          null_func;\n    __itt_group_id group;\n}  __itt_api_info;\n\ntypedef struct __itt_counter_info\n{\n    const char* nameA;  /*!< Copy of original name in ASCII. */\n#if defined(UNICODE) || defined(_UNICODE)\n    const wchar_t* nameW; /*!< Copy of original name in UNICODE. */\n#else  /* UNICODE || _UNICODE */\n    void* nameW;\n#endif /* UNICODE || _UNICODE */\n    const char* domainA;  /*!< Copy of original name in ASCII. */\n#if defined(UNICODE) || defined(_UNICODE)\n    const wchar_t* domainW; /*!< Copy of original name in UNICODE. */\n#else  /* UNICODE || _UNICODE */\n    void* domainW;\n#endif /* UNICODE || _UNICODE */\n    int type;\n    long index;\n    int   extra1; /*!< Reserved to the runtime */\n    void* extra2; /*!< Reserved to the runtime */\n    struct __itt_counter_info* next;\n}  __itt_counter_info_t;\n\nstruct ___itt_domain;\nstruct ___itt_string_handle;\n\ntypedef struct ___itt_global\n{\n    unsigned char          magic[8];\n    unsigned long          version_major;\n    unsigned long          version_minor;\n    unsigned long          version_build;\n    volatile long          api_initialized;\n    volatile long          mutex_initialized;\n    volatile long          atomic_counter;\n    mutex_t                mutex;\n    lib_t                  lib;\n    void*                  error_handler;\n    const char**           dll_path_ptr;\n    __itt_api_info*        api_list_ptr;\n    struct ___itt_global*  next;\n    /* Joinable structures below */\n    __itt_thread_info*     thread_list;\n    struct ___itt_domain*  domain_list;\n    struct ___itt_string_handle* string_list;\n    __itt_collection_state state;\n    __itt_counter_info_t* counter_list;\n} __itt_global;\n\n#pragma pack(pop)\n\n#define NEW_THREAD_INFO_W(gptr,h,h_tail,t,s,n) { \\\n    h = (__itt_thread_info*)malloc(sizeof(__itt_thread_info)); \\\n    if (h != NULL) { \\\n        h->tid    = t; \\\n        h->nameA  = NULL; \\\n        h->nameW  = n ? _wcsdup(n) : NULL; \\\n        h->state  = s; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->thread_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_THREAD_INFO_A(gptr,h,h_tail,t,s,n) { \\\n    h = (__itt_thread_info*)malloc(sizeof(__itt_thread_info)); \\\n    if (h != NULL) { \\\n        h->tid    = t; \\\n        h->nameA  = n ? __itt_fstrdup(n) : NULL; \\\n        h->nameW  = NULL; \\\n        h->state  = s; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->thread_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_DOMAIN_W(gptr,h,h_tail,name) { \\\n    h = (__itt_domain*)malloc(sizeof(__itt_domain)); \\\n    if (h != NULL) { \\\n        h->flags  = 1;    /* domain is enabled by default */ \\\n        h->nameA  = NULL; \\\n        h->nameW  = name ? _wcsdup(name) : NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->domain_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_DOMAIN_A(gptr,h,h_tail,name) { \\\n    h = (__itt_domain*)malloc(sizeof(__itt_domain)); \\\n    if (h != NULL) { \\\n        h->flags  = 1;    /* domain is enabled by default */ \\\n        h->nameA  = name ? __itt_fstrdup(name) : NULL; \\\n        h->nameW  = NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->domain_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_STRING_HANDLE_W(gptr,h,h_tail,name) { \\\n    h = (__itt_string_handle*)malloc(sizeof(__itt_string_handle)); \\\n    if (h != NULL) { \\\n        h->strA   = NULL; \\\n        h->strW   = name ? _wcsdup(name) : NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->string_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_STRING_HANDLE_A(gptr,h,h_tail,name) { \\\n    h = (__itt_string_handle*)malloc(sizeof(__itt_string_handle)); \\\n    if (h != NULL) { \\\n        h->strA   = name ? __itt_fstrdup(name) : NULL; \\\n        h->strW   = NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->string_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_COUNTER_W(gptr,h,h_tail,name,domain,type) { \\\n    h = (__itt_counter_info_t*)malloc(sizeof(__itt_counter_info_t)); \\\n    if (h != NULL) { \\\n        h->nameA   = NULL; \\\n        h->nameW   = name ? _wcsdup(name) : NULL; \\\n        h->domainA   = NULL; \\\n        h->domainW   = name ? _wcsdup(domain) : NULL; \\\n        h->type = type; \\\n        h->index = 0; \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->counter_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_COUNTER_A(gptr,h,h_tail,name,domain,type) { \\\n    h = (__itt_counter_info_t*)malloc(sizeof(__itt_counter_info_t)); \\\n    if (h != NULL) { \\\n        h->nameA   = name ? __itt_fstrdup(name) : NULL; \\\n        h->nameW   = NULL; \\\n        h->domainA   = domain ? __itt_fstrdup(domain) : NULL; \\\n        h->domainW   = NULL; \\\n        h->type = type; \\\n        h->index = 0; \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->counter_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#endif /* _ITTNOTIFY_CONFIG_H_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/src/cpu/xbyak/xbyak_util.h": "/*******************************************************************************\n* Copyright 2016-2019 Intel Corporation\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\n/*******************************************************************************\n* Copyright (c) 2007 MITSUNARI Shigeo\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without\n* modification, are permitted provided that the following conditions are met:\n*\n* Redistributions of source code must retain the above copyright notice, this\n* list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above copyright notice,\n* this list of conditions and the following disclaimer in the documentation\n* and/or other materials provided with the distribution.\n* Neither the name of the copyright owner nor the names of its contributors may\n* be used to endorse or promote products derived from this software without\n* specific prior written permission.\n*\n* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n* THE POSSIBILITY OF SUCH DAMAGE.\n*******************************************************************************/\n\n#ifndef XBYAK_XBYAK_UTIL_H_\n#define XBYAK_XBYAK_UTIL_H_\n\n/**\n\tutility class and functions for Xbyak\n\tXbyak::util::Clock ; rdtsc timer\n\tXbyak::util::Cpu ; detect CPU\n\t@note this header is UNDER CONSTRUCTION!\n*/\n#include \"xbyak.h\"\n\n#if defined(__i386__) || defined(__x86_64__) || defined(_M_IX86) || defined(_M_X64)\n\t#define XBYAK_INTEL_CPU_SPECIFIC\n#endif\n\n#ifdef XBYAK_INTEL_CPU_SPECIFIC\n#ifdef _MSC_VER\n\t#if (_MSC_VER < 1400) && defined(XBYAK32)\n\t\tstatic inline __declspec(naked) void __cpuid(int[4], int)\n\t\t{\n\t\t\t__asm {\n\t\t\t\tpush\tebx\n\t\t\t\tpush\tesi\n\t\t\t\tmov\t\teax, dword ptr [esp + 4 * 2 + 8] // eaxIn\n\t\t\t\tcpuid\n\t\t\t\tmov\t\tesi, dword ptr [esp + 4 * 2 + 4] // data\n\t\t\t\tmov\t\tdword ptr [esi], eax\n\t\t\t\tmov\t\tdword ptr [esi + 4], ebx\n\t\t\t\tmov\t\tdword ptr [esi + 8], ecx\n\t\t\t\tmov\t\tdword ptr [esi + 12], edx\n\t\t\t\tpop\t\tesi\n\t\t\t\tpop\t\tebx\n\t\t\t\tret\n\t\t\t}\n\t\t}\n\t#else\n\t\t#include <intrin.h> // for __cpuid\n\t#endif\n#else\n\t#ifndef __GNUC_PREREQ\n    \t#define __GNUC_PREREQ(major, minor) ((((__GNUC__) << 16) + (__GNUC_MINOR__)) >= (((major) << 16) + (minor)))\n\t#endif\n\t#if __GNUC_PREREQ(4, 3) && !defined(__APPLE__)\n\t\t#include <cpuid.h>\n\t#else\n\t\t#if defined(__APPLE__) && defined(XBYAK32) // avoid err : can't find a register in class `BREG' while reloading `asm'\n\t\t\t#define __cpuid(eaxIn, a, b, c, d) __asm__ __volatile__(\"pushl %%ebx\\ncpuid\\nmovl %%ebp, %%esi\\npopl %%ebx\" : \"=a\"(a), \"=S\"(b), \"=c\"(c), \"=d\"(d) : \"0\"(eaxIn))\n\t\t\t#define __cpuid_count(eaxIn, ecxIn, a, b, c, d) __asm__ __volatile__(\"pushl %%ebx\\ncpuid\\nmovl %%ebp, %%esi\\npopl %%ebx\" : \"=a\"(a), \"=S\"(b), \"=c\"(c), \"=d\"(d) : \"0\"(eaxIn), \"2\"(ecxIn))\n\t\t#else\n\t\t\t#define __cpuid(eaxIn, a, b, c, d) __asm__ __volatile__(\"cpuid\\n\" : \"=a\"(a), \"=b\"(b), \"=c\"(c), \"=d\"(d) : \"0\"(eaxIn))\n\t\t\t#define __cpuid_count(eaxIn, ecxIn, a, b, c, d) __asm__ __volatile__(\"cpuid\\n\" : \"=a\"(a), \"=b\"(b), \"=c\"(c), \"=d\"(d) : \"0\"(eaxIn), \"2\"(ecxIn))\n\t\t#endif\n\t#endif\n#endif\n#endif\n\n#ifdef XBYAK_USE_VTUNE\n\t// -I /opt/intel/vtune_amplifier/include/ -L /opt/intel/vtune_amplifier/lib64 -ljitprofiling -ldl\n\t#include <jitprofiling.h>\n\t#ifdef _MSC_VER\n\t\t#pragma comment(lib, \"libittnotify.lib\")\n\t#endif\n\t#ifdef __linux__\n\t\t#include <dlfcn.h>\n\t#endif\n#endif\n#ifdef __linux__\n\t#define XBYAK_USE_PERF\n#endif\n\nnamespace Xbyak { namespace util {\n\ntypedef enum {\n   SmtLevel = 1,\n   CoreLevel = 2\n} IntelCpuTopologyLevel;\n\n/**\n\tCPU detection class\n*/\nclass Cpu {\n\tuint64 type_;\n\t//system topology\n\tbool x2APIC_supported_;\n\tstatic const size_t maxTopologyLevels = 2;\n\tunsigned int numCores_[maxTopologyLevels];\n\n\tstatic const unsigned int maxNumberCacheLevels = 10;\n\tunsigned int dataCacheSize_[maxNumberCacheLevels];\n\tunsigned int coresSharignDataCache_[maxNumberCacheLevels];\n\tunsigned int dataCacheLevels_;\n\n\tunsigned int get32bitAsBE(const char *x) const\n\t{\n\t\treturn x[0] | (x[1] << 8) | (x[2] << 16) | (x[3] << 24);\n\t}\n\tunsigned int mask(int n) const\n\t{\n\t\treturn (1U << n) - 1;\n\t}\n\tvoid setFamily()\n\t{\n\t\tunsigned int data[4] = {};\n\t\tgetCpuid(1, data);\n\t\tstepping = data[0] & mask(4);\n\t\tmodel = (data[0] >> 4) & mask(4);\n\t\tfamily = (data[0] >> 8) & mask(4);\n\t\t// type = (data[0] >> 12) & mask(2);\n\t\textModel = (data[0] >> 16) & mask(4);\n\t\textFamily = (data[0] >> 20) & mask(8);\n\t\tif (family == 0x0f) {\n\t\t\tdisplayFamily = family + extFamily;\n\t\t} else {\n\t\t\tdisplayFamily = family;\n\t\t}\n\t\tif (family == 6 || family == 0x0f) {\n\t\t\tdisplayModel = (extModel << 4) + model;\n\t\t} else {\n\t\t\tdisplayModel = model;\n\t\t}\n\t}\n\tunsigned int extractBit(unsigned int val, unsigned int base, unsigned int end)\n\t{\n\t\treturn (val >> base) & ((1u << (end - base)) - 1);\n\t}\n\tvoid setNumCores()\n\t{\n\t\tif ((type_ & tINTEL) == 0) return;\n\n\t\tunsigned int data[4] = {};\n\n\t\t /* CAUTION: These numbers are configuration as shipped by Intel. */\n\t\tgetCpuidEx(0x0, 0, data);\n\t\tif (data[0] >= 0xB) {\n\t\t\t /*\n\t\t\t\tif leaf 11 exists(x2APIC is supported),\n\t\t\t\twe use it to get the number of smt cores and cores on socket\n\n\t\t\t\tleaf 0xB can be zeroed-out by a hypervisor\n\t\t\t*/\n\t\t\tx2APIC_supported_ = true;\n\t\t\tfor (unsigned int i = 0; i < maxTopologyLevels; i++) {\n\t\t\t\tgetCpuidEx(0xB, i, data);\n\t\t\t\tIntelCpuTopologyLevel level = (IntelCpuTopologyLevel)extractBit(data[2], 8, 15);\n\t\t\t\tif (level == SmtLevel || level == CoreLevel) {\n\t\t\t\t\tnumCores_[level - 1] = extractBit(data[1], 0, 15);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t   Everybody lies, so we need some sane values to fall back on\n\t\t\t*/\n\t\t\tnumCores_[SmtLevel - 1] = std::max(1u, numCores_[SmtLevel - 1]);\n\t\t\tnumCores_[CoreLevel - 1] = std::max(numCores_[SmtLevel - 1], numCores_[CoreLevel - 1]);\n\t\t} else {\n\t\t\t/*\n\t\t\t\tFailed to deremine num of cores without x2APIC support.\n\t\t\t\tTODO: USE initial APIC ID to determine ncores.\n\t\t\t*/\n\t\t\tnumCores_[SmtLevel - 1] = 0;\n\t\t\tnumCores_[CoreLevel - 1] = 0;\n\t\t}\n\n\t}\n\tvoid setCacheHierarchy()\n\t{\n\t\tif ((type_ & tINTEL) == 0) return;\n\t\tconst unsigned int NO_CACHE = 0;\n\t\tconst unsigned int DATA_CACHE = 1;\n//\t\tconst unsigned int INSTRUCTION_CACHE = 2;\n\t\tconst unsigned int UNIFIED_CACHE = 3;\n\t\tunsigned int smt_width = 0;\n\t\tunsigned int logical_cores = 0;\n\t\tunsigned int data[4] = {};\n\n\t\tif (x2APIC_supported_) {\n\t\t\tsmt_width = numCores_[0];\n\t\t\tlogical_cores = numCores_[1];\n\t\t}\n\n\t\t/*\n\t\t\tAssumptions:\n\t\t\tthe first level of data cache is not shared (which is the\n\t\t\tcase for every existing architecture) and use this to\n\t\t\tdetermine the SMT width for arch not supporting leaf 11.\n\t\t\twhen leaf 4 reports a number of core less than numCores_\n\t\t\ton socket reported by leaf 11, then it is a correct number\n\t\t\tof cores not an upperbound.\n\t\t*/\n\t\tfor (int i = 0; dataCacheLevels_ < maxNumberCacheLevels; i++) {\n\t\t\tgetCpuidEx(0x4, i, data);\n\t\t\tunsigned int cacheType = extractBit(data[0], 0, 4);\n\t\t\tif (cacheType == NO_CACHE) break;\n\t\t\tif (cacheType == DATA_CACHE || cacheType == UNIFIED_CACHE) {\n\t\t\t\tunsigned int actual_logical_cores = extractBit(data[0], 14, 25) + 1;\n\t\t\t\tif (logical_cores != 0) { // true only if leaf 0xB is supported and valid\n\t\t\t\t\tactual_logical_cores = (std::min)(actual_logical_cores, logical_cores);\n\t\t\t\t}\n\t\t\t\tassert(actual_logical_cores != 0);\n\t\t\t\tdataCacheSize_[dataCacheLevels_] =\n\t\t\t\t\t(extractBit(data[1], 22, 31) + 1)\n\t\t\t\t\t* (extractBit(data[1], 12, 21) + 1)\n\t\t\t\t\t* (extractBit(data[1], 0, 11) + 1)\n\t\t\t\t\t* (data[2] + 1);\n\t\t\t\tif (cacheType == DATA_CACHE && smt_width == 0) smt_width = actual_logical_cores;\n\t\t\t\tassert(smt_width != 0);\n\t\t\t\tcoresSharignDataCache_[dataCacheLevels_] = (std::max)(actual_logical_cores / smt_width, 1u);\n\t\t\t\tdataCacheLevels_++;\n\t\t\t}\n\t\t}\n\t}\n\npublic:\n\tint model;\n\tint family;\n\tint stepping;\n\tint extModel;\n\tint extFamily;\n\tint displayFamily; // family + extFamily\n\tint displayModel; // model + extModel\n\n\tunsigned int getNumCores(IntelCpuTopologyLevel level) {\n\t\tif (!x2APIC_supported_) throw Error(ERR_X2APIC_IS_NOT_SUPPORTED);\n\t\tswitch (level) {\n\t\tcase SmtLevel: return numCores_[level - 1];\n\t\tcase CoreLevel: return numCores_[level - 1] / numCores_[SmtLevel - 1];\n\t\tdefault: throw Error(ERR_X2APIC_IS_NOT_SUPPORTED);\n\t\t}\n\t}\n\n\tunsigned int getDataCacheLevels() const { return dataCacheLevels_; }\n\tunsigned int getCoresSharingDataCache(unsigned int i) const\n\t{\n\t\tif (i >= dataCacheLevels_) throw  Error(ERR_BAD_PARAMETER);\n\t\treturn coresSharignDataCache_[i];\n\t}\n\tunsigned int getDataCacheSize(unsigned int i) const\n\t{\n\t\tif (i >= dataCacheLevels_) throw  Error(ERR_BAD_PARAMETER);\n\t\treturn dataCacheSize_[i];\n\t}\n\n\t/*\n\t\tdata[] = { eax, ebx, ecx, edx }\n\t*/\n\tstatic inline void getCpuid(unsigned int eaxIn, unsigned int data[4])\n\t{\n#ifdef XBYAK_INTEL_CPU_SPECIFIC\n\t#ifdef _MSC_VER\n\t\t__cpuid(reinterpret_cast<int*>(data), eaxIn);\n\t#else\n\t\t__cpuid(eaxIn, data[0], data[1], data[2], data[3]);\n\t#endif\n#else\n\t\t(void)eaxIn;\n\t\t(void)data;\n#endif\n\t}\n\tstatic inline void getCpuidEx(unsigned int eaxIn, unsigned int ecxIn, unsigned int data[4])\n\t{\n#ifdef XBYAK_INTEL_CPU_SPECIFIC\n\t#ifdef _MSC_VER\n\t\t__cpuidex(reinterpret_cast<int*>(data), eaxIn, ecxIn);\n\t#else\n\t\t__cpuid_count(eaxIn, ecxIn, data[0], data[1], data[2], data[3]);\n\t#endif\n#else\n\t\t(void)eaxIn;\n\t\t(void)ecxIn;\n\t\t(void)data;\n#endif\n\t}\n\tstatic inline uint64 getXfeature()\n\t{\n#ifdef XBYAK_INTEL_CPU_SPECIFIC\n\t#ifdef _MSC_VER\n\t\treturn _xgetbv(0);\n\t#else\n\t\tunsigned int eax, edx;\n\t\t// xgetvb is not support on gcc 4.2\n//\t\t__asm__ volatile(\"xgetbv\" : \"=a\"(eax), \"=d\"(edx) : \"c\"(0));\n\t\t__asm__ volatile(\".byte 0x0f, 0x01, 0xd0\" : \"=a\"(eax), \"=d\"(edx) : \"c\"(0));\n\t\treturn ((uint64)edx << 32) | eax;\n\t#endif\n#else\n\t\treturn 0;\n#endif\n\t}\n\ttypedef uint64 Type;\n\n\tstatic const Type NONE = 0;\n\tstatic const Type tMMX = 1 << 0;\n\tstatic const Type tMMX2 = 1 << 1;\n\tstatic const Type tCMOV = 1 << 2;\n\tstatic const Type tSSE = 1 << 3;\n\tstatic const Type tSSE2 = 1 << 4;\n\tstatic const Type tSSE3 = 1 << 5;\n\tstatic const Type tSSSE3 = 1 << 6;\n\tstatic const Type tSSE41 = 1 << 7;\n\tstatic const Type tSSE42 = 1 << 8;\n\tstatic const Type tPOPCNT = 1 << 9;\n\tstatic const Type tAESNI = 1 << 10;\n\tstatic const Type tSSE5 = 1 << 11;\n\tstatic const Type tOSXSAVE = 1 << 12;\n\tstatic const Type tPCLMULQDQ = 1 << 13;\n\tstatic const Type tAVX = 1 << 14;\n\tstatic const Type tFMA = 1 << 15;\n\n\tstatic const Type t3DN = 1 << 16;\n\tstatic const Type tE3DN = 1 << 17;\n\tstatic const Type tSSE4a = 1 << 18;\n\tstatic const Type tRDTSCP = 1 << 19;\n\tstatic const Type tAVX2 = 1 << 20;\n\tstatic const Type tBMI1 = 1 << 21; // andn, bextr, blsi, blsmsk, blsr, tzcnt\n\tstatic const Type tBMI2 = 1 << 22; // bzhi, mulx, pdep, pext, rorx, sarx, shlx, shrx\n\tstatic const Type tLZCNT = 1 << 23;\n\n\tstatic const Type tINTEL = 1 << 24;\n\tstatic const Type tAMD = 1 << 25;\n\n\tstatic const Type tENHANCED_REP = 1 << 26; // enhanced rep movsb/stosb\n\tstatic const Type tRDRAND = 1 << 27;\n\tstatic const Type tADX = 1 << 28; // adcx, adox\n\tstatic const Type tRDSEED = 1 << 29; // rdseed\n\tstatic const Type tSMAP = 1 << 30; // stac\n\tstatic const Type tHLE = uint64(1) << 31; // xacquire, xrelease, xtest\n\tstatic const Type tRTM = uint64(1) << 32; // xbegin, xend, xabort\n\tstatic const Type tF16C = uint64(1) << 33; // vcvtph2ps, vcvtps2ph\n\tstatic const Type tMOVBE = uint64(1) << 34; // mobve\n\tstatic const Type tAVX512F = uint64(1) << 35;\n\tstatic const Type tAVX512DQ = uint64(1) << 36;\n\tstatic const Type tAVX512_IFMA = uint64(1) << 37;\n\tstatic const Type tAVX512IFMA = tAVX512_IFMA;\n\tstatic const Type tAVX512PF = uint64(1) << 38;\n\tstatic const Type tAVX512ER = uint64(1) << 39;\n\tstatic const Type tAVX512CD = uint64(1) << 40;\n\tstatic const Type tAVX512BW = uint64(1) << 41;\n\tstatic const Type tAVX512VL = uint64(1) << 42;\n\tstatic const Type tAVX512_VBMI = uint64(1) << 43;\n\tstatic const Type tAVX512VBMI = tAVX512_VBMI; // changed by Intel's manual\n\tstatic const Type tAVX512_4VNNIW = uint64(1) << 44;\n\tstatic const Type tAVX512_4FMAPS = uint64(1) << 45;\n\tstatic const Type tPREFETCHWT1 = uint64(1) << 46;\n\tstatic const Type tPREFETCHW = uint64(1) << 47;\n\tstatic const Type tSHA = uint64(1) << 48;\n\tstatic const Type tMPX = uint64(1) << 49;\n\tstatic const Type tAVX512_VBMI2 = uint64(1) << 50;\n\tstatic const Type tGFNI = uint64(1) << 51;\n\tstatic const Type tVAES = uint64(1) << 52;\n\tstatic const Type tVPCLMULQDQ = uint64(1) << 53;\n\tstatic const Type tAVX512_VNNI = uint64(1) << 54;\n\tstatic const Type tAVX512_BITALG = uint64(1) << 55;\n\tstatic const Type tAVX512_VPOPCNTDQ = uint64(1) << 56;\n\tstatic const Type tAVX512_BF16 = uint64(1) << 57;\n\tstatic const Type tAVX512_VP2INTERSECT = uint64(1) << 58;\n\n\tCpu()\n\t\t: type_(NONE)\n\t\t, x2APIC_supported_(false)\n\t\t, numCores_()\n\t\t, dataCacheSize_()\n\t\t, coresSharignDataCache_()\n\t\t, dataCacheLevels_(0)\n\t{\n\t\tunsigned int data[4] = {};\n\t\tconst unsigned int& EAX = data[0];\n\t\tconst unsigned int& EBX = data[1];\n\t\tconst unsigned int& ECX = data[2];\n\t\tconst unsigned int& EDX = data[3];\n\t\tgetCpuid(0, data);\n\t\tconst unsigned int maxNum = EAX;\n\t\tstatic const char intel[] = \"ntel\";\n\t\tstatic const char amd[] = \"cAMD\";\n\t\tif (ECX == get32bitAsBE(amd)) {\n\t\t\ttype_ |= tAMD;\n\t\t\tgetCpuid(0x80000001, data);\n\t\t\tif (EDX & (1U << 31)) type_ |= t3DN;\n\t\t\tif (EDX & (1U << 15)) type_ |= tCMOV;\n\t\t\tif (EDX & (1U << 30)) type_ |= tE3DN;\n\t\t\tif (EDX & (1U << 22)) type_ |= tMMX2;\n\t\t\tif (EDX & (1U << 27)) type_ |= tRDTSCP;\n\t\t}\n\t\tif (ECX == get32bitAsBE(intel)) {\n\t\t\ttype_ |= tINTEL;\n\t\t\tgetCpuid(0x80000001, data);\n\t\t\tif (EDX & (1U << 27)) type_ |= tRDTSCP;\n\t\t\tif (ECX & (1U << 5)) type_ |= tLZCNT;\n\t\t\tif (ECX & (1U << 8)) type_ |= tPREFETCHW;\n\t\t}\n\t\tgetCpuid(1, data);\n\t\tif (ECX & (1U << 0)) type_ |= tSSE3;\n\t\tif (ECX & (1U << 9)) type_ |= tSSSE3;\n\t\tif (ECX & (1U << 19)) type_ |= tSSE41;\n\t\tif (ECX & (1U << 20)) type_ |= tSSE42;\n\t\tif (ECX & (1U << 22)) type_ |= tMOVBE;\n\t\tif (ECX & (1U << 23)) type_ |= tPOPCNT;\n\t\tif (ECX & (1U << 25)) type_ |= tAESNI;\n\t\tif (ECX & (1U << 1)) type_ |= tPCLMULQDQ;\n\t\tif (ECX & (1U << 27)) type_ |= tOSXSAVE;\n\t\tif (ECX & (1U << 30)) type_ |= tRDRAND;\n\t\tif (ECX & (1U << 29)) type_ |= tF16C;\n\n\t\tif (EDX & (1U << 15)) type_ |= tCMOV;\n\t\tif (EDX & (1U << 23)) type_ |= tMMX;\n\t\tif (EDX & (1U << 25)) type_ |= tMMX2 | tSSE;\n\t\tif (EDX & (1U << 26)) type_ |= tSSE2;\n\n\t\tif (type_ & tOSXSAVE) {\n\t\t\t// check XFEATURE_ENABLED_MASK[2:1] = '11b'\n\t\t\tuint64 bv = getXfeature();\n\t\t\tif ((bv & 6) == 6) {\n\t\t\t\tif (ECX & (1U << 28)) type_ |= tAVX;\n\t\t\t\tif (ECX & (1U << 12)) type_ |= tFMA;\n\t\t\t\tif (((bv >> 5) & 7) == 7) {\n\t\t\t\t\tgetCpuidEx(7, 0, data);\n\t\t\t\t\tif (EBX & (1U << 16)) type_ |= tAVX512F;\n\t\t\t\t\tif (type_ & tAVX512F) {\n\t\t\t\t\t\tif (EBX & (1U << 17)) type_ |= tAVX512DQ;\n\t\t\t\t\t\tif (EBX & (1U << 21)) type_ |= tAVX512_IFMA;\n\t\t\t\t\t\tif (EBX & (1U << 26)) type_ |= tAVX512PF;\n\t\t\t\t\t\tif (EBX & (1U << 27)) type_ |= tAVX512ER;\n\t\t\t\t\t\tif (EBX & (1U << 28)) type_ |= tAVX512CD;\n\t\t\t\t\t\tif (EBX & (1U << 30)) type_ |= tAVX512BW;\n\t\t\t\t\t\tif (EBX & (1U << 31)) type_ |= tAVX512VL;\n\t\t\t\t\t\tif (ECX & (1U << 1)) type_ |= tAVX512_VBMI;\n\t\t\t\t\t\tif (ECX & (1U << 6)) type_ |= tAVX512_VBMI2;\n\t\t\t\t\t\tif (ECX & (1U << 8)) type_ |= tGFNI;\n\t\t\t\t\t\tif (ECX & (1U << 9)) type_ |= tVAES;\n\t\t\t\t\t\tif (ECX & (1U << 10)) type_ |= tVPCLMULQDQ;\n\t\t\t\t\t\tif (ECX & (1U << 11)) type_ |= tAVX512_VNNI;\n\t\t\t\t\t\tif (ECX & (1U << 12)) type_ |= tAVX512_BITALG;\n\t\t\t\t\t\tif (ECX & (1U << 14)) type_ |= tAVX512_VPOPCNTDQ;\n\t\t\t\t\t\tif (EDX & (1U << 2)) type_ |= tAVX512_4VNNIW;\n\t\t\t\t\t\tif (EDX & (1U << 3)) type_ |= tAVX512_4FMAPS;\n\t\t\t\t\t\tif (EDX & (1U << 8)) type_ |= tAVX512_VP2INTERSECT;\n\t\t\t\t\t}\n\t\t\t\t\t// EAX=07H, ECX=1\n\t\t\t\t\tgetCpuidEx(7, 1, data);\n\t\t\t\t\tif (type_ & tAVX512F) {\n\t\t\t\t\t\tif (EAX & (1U << 5)) type_ |= tAVX512_BF16;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (maxNum >= 7) {\n\t\t\tgetCpuidEx(7, 0, data);\n\t\t\tif (type_ & tAVX && (EBX & (1U << 5))) type_ |= tAVX2;\n\t\t\tif (EBX & (1U << 3)) type_ |= tBMI1;\n\t\t\tif (EBX & (1U << 8)) type_ |= tBMI2;\n\t\t\tif (EBX & (1U << 9)) type_ |= tENHANCED_REP;\n\t\t\tif (EBX & (1U << 18)) type_ |= tRDSEED;\n\t\t\tif (EBX & (1U << 19)) type_ |= tADX;\n\t\t\tif (EBX & (1U << 20)) type_ |= tSMAP;\n\t\t\tif (EBX & (1U << 4)) type_ |= tHLE;\n\t\t\tif (EBX & (1U << 11)) type_ |= tRTM;\n\t\t\tif (EBX & (1U << 14)) type_ |= tMPX;\n\t\t\tif (EBX & (1U << 29)) type_ |= tSHA;\n\t\t\tif (ECX & (1U << 0)) type_ |= tPREFETCHWT1;\n\t\t}\n\t\tsetFamily();\n\t\tsetNumCores();\n\t\tsetCacheHierarchy();\n\t}\n\tvoid putFamily() const\n\t{\n\t\tprintf(\"family=%d, model=%X, stepping=%d, extFamily=%d, extModel=%X\\n\",\n\t\t\tfamily, model, stepping, extFamily, extModel);\n\t\tprintf(\"display:family=%X, model=%X\\n\", displayFamily, displayModel);\n\t}\n\tbool has(Type type) const\n\t{\n\t\treturn (type & type_) != 0;\n\t}\n};\n\nclass Clock {\npublic:\n\tstatic inline uint64 getRdtsc()\n\t{\n#ifdef XBYAK_INTEL_CPU_SPECIFIC\n\t#ifdef _MSC_VER\n\t\treturn __rdtsc();\n\t#else\n\t\tunsigned int eax, edx;\n\t\t__asm__ volatile(\"rdtsc\" : \"=a\"(eax), \"=d\"(edx));\n\t\treturn ((uint64)edx << 32) | eax;\n\t#endif\n#else\n\t\t// TODO: Need another impl of Clock or rdtsc-equivalent for non-x86 cpu\n\t\treturn 0;\n#endif\n\t}\n\tClock()\n\t\t: clock_(0)\n\t\t, count_(0)\n\t{\n\t}\n\tvoid begin()\n\t{\n\t\tclock_ -= getRdtsc();\n\t}\n\tvoid end()\n\t{\n\t\tclock_ += getRdtsc();\n\t\tcount_++;\n\t}\n\tint getCount() const { return count_; }\n\tuint64 getClock() const { return clock_; }\n\tvoid clear() { count_ = 0; clock_ = 0; }\nprivate:\n\tuint64 clock_;\n\tint count_;\n};\n\n#ifdef XBYAK64\nconst int UseRCX = 1 << 6;\nconst int UseRDX = 1 << 7;\n\nclass Pack {\n\tstatic const size_t maxTblNum = 15;\n\tconst Xbyak::Reg64 *tbl_[maxTblNum];\n\tsize_t n_;\npublic:\n\tPack() : tbl_(), n_(0) {}\n\tPack(const Xbyak::Reg64 *tbl, size_t n) { init(tbl, n); }\n\tPack(const Pack& rhs)\n\t\t: n_(rhs.n_)\n\t{\n\t\tfor (size_t i = 0; i < n_; i++) tbl_[i] = rhs.tbl_[i];\n\t}\n\tPack& operator=(const Pack& rhs)\n\t{\n\t\tn_ = rhs.n_;\n\t\tfor (size_t i = 0; i < n_; i++) tbl_[i] = rhs.tbl_[i];\n\t\treturn *this;\n\t}\n\tPack(const Xbyak::Reg64& t0)\n\t{ n_ = 1; tbl_[0] = &t0; }\n\tPack(const Xbyak::Reg64& t1, const Xbyak::Reg64& t0)\n\t{ n_ = 2; tbl_[0] = &t0; tbl_[1] = &t1; }\n\tPack(const Xbyak::Reg64& t2, const Xbyak::Reg64& t1, const Xbyak::Reg64& t0)\n\t{ n_ = 3; tbl_[0] = &t0; tbl_[1] = &t1; tbl_[2] = &t2; }\n\tPack(const Xbyak::Reg64& t3, const Xbyak::Reg64& t2, const Xbyak::Reg64& t1, const Xbyak::Reg64& t0)\n\t{ n_ = 4; tbl_[0] = &t0; tbl_[1] = &t1; tbl_[2] = &t2; tbl_[3] = &t3; }\n\tPack(const Xbyak::Reg64& t4, const Xbyak::Reg64& t3, const Xbyak::Reg64& t2, const Xbyak::Reg64& t1, const Xbyak::Reg64& t0)\n\t{ n_ = 5; tbl_[0] = &t0; tbl_[1] = &t1; tbl_[2] = &t2; tbl_[3] = &t3; tbl_[4] = &t4; }\n\tPack(const Xbyak::Reg64& t5, const Xbyak::Reg64& t4, const Xbyak::Reg64& t3, const Xbyak::Reg64& t2, const Xbyak::Reg64& t1, const Xbyak::Reg64& t0)\n\t{ n_ = 6; tbl_[0] = &t0; tbl_[1] = &t1; tbl_[2] = &t2; tbl_[3] = &t3; tbl_[4] = &t4; tbl_[5] = &t5; }\n\tPack(const Xbyak::Reg64& t6, const Xbyak::Reg64& t5, const Xbyak::Reg64& t4, const Xbyak::Reg64& t3, const Xbyak::Reg64& t2, const Xbyak::Reg64& t1, const Xbyak::Reg64& t0)\n\t{ n_ = 7; tbl_[0] = &t0; tbl_[1] = &t1; tbl_[2] = &t2; tbl_[3] = &t3; tbl_[4] = &t4; tbl_[5] = &t5; tbl_[6] = &t6; }\n\tPack(const Xbyak::Reg64& t7, const Xbyak::Reg64& t6, const Xbyak::Reg64& t5, const Xbyak::Reg64& t4, const Xbyak::Reg64& t3, const Xbyak::Reg64& t2, const Xbyak::Reg64& t1, const Xbyak::Reg64& t0)\n\t{ n_ = 8; tbl_[0] = &t0; tbl_[1] = &t1; tbl_[2] = &t2; tbl_[3] = &t3; tbl_[4] = &t4; tbl_[5] = &t5; tbl_[6] = &t6; tbl_[7] = &t7; }\n\tPack(const Xbyak::Reg64& t8, const Xbyak::Reg64& t7, const Xbyak::Reg64& t6, const Xbyak::Reg64& t5, const Xbyak::Reg64& t4, const Xbyak::Reg64& t3, const Xbyak::Reg64& t2, const Xbyak::Reg64& t1, const Xbyak::Reg64& t0)\n\t{ n_ = 9; tbl_[0] = &t0; tbl_[1] = &t1; tbl_[2] = &t2; tbl_[3] = &t3; tbl_[4] = &t4; tbl_[5] = &t5; tbl_[6] = &t6; tbl_[7] = &t7; tbl_[8] = &t8; }\n\tPack(const Xbyak::Reg64& t9, const Xbyak::Reg64& t8, const Xbyak::Reg64& t7, const Xbyak::Reg64& t6, const Xbyak::Reg64& t5, const Xbyak::Reg64& t4, const Xbyak::Reg64& t3, const Xbyak::Reg64& t2, const Xbyak::Reg64& t1, const Xbyak::Reg64& t0)\n\t{ n_ = 10; tbl_[0] = &t0; tbl_[1] = &t1; tbl_[2] = &t2; tbl_[3] = &t3; tbl_[4] = &t4; tbl_[5] = &t5; tbl_[6] = &t6; tbl_[7] = &t7; tbl_[8] = &t8; tbl_[9] = &t9; }\n\tPack& append(const Xbyak::Reg64& t)\n\t{\n\t\tif (n_ == maxTblNum) {\n\t\t\tfprintf(stderr, \"ERR Pack::can't append\\n\");\n\t\t\tthrow Error(ERR_BAD_PARAMETER);\n\t\t}\n\t\ttbl_[n_++] = &t;\n\t\treturn *this;\n\t}\n\tvoid init(const Xbyak::Reg64 *tbl, size_t n)\n\t{\n\t\tif (n > maxTblNum) {\n\t\t\tfprintf(stderr, \"ERR Pack::init bad n=%d\\n\", (int)n);\n\t\t\tthrow Error(ERR_BAD_PARAMETER);\n\t\t}\n\t\tn_ = n;\n\t\tfor (size_t i = 0; i < n; i++) {\n\t\t\ttbl_[i] = &tbl[i];\n\t\t}\n\t}\n\tconst Xbyak::Reg64& operator[](size_t n) const\n\t{\n\t\tif (n >= n_) {\n\t\t\tfprintf(stderr, \"ERR Pack bad n=%d(%d)\\n\", (int)n, (int)n_);\n\t\t\tthrow Error(ERR_BAD_PARAMETER);\n\t\t}\n\t\treturn *tbl_[n];\n\t}\n\tsize_t size() const { return n_; }\n\t/*\n\t\tget tbl[pos, pos + num)\n\t*/\n\tPack sub(size_t pos, size_t num = size_t(-1)) const\n\t{\n\t\tif (num == size_t(-1)) num = n_ - pos;\n\t\tif (pos + num > n_) {\n\t\t\tfprintf(stderr, \"ERR Pack::sub bad pos=%d, num=%d\\n\", (int)pos, (int)num);\n\t\t\tthrow Error(ERR_BAD_PARAMETER);\n\t\t}\n\t\tPack pack;\n\t\tpack.n_ = num;\n\t\tfor (size_t i = 0; i < num; i++) {\n\t\t\tpack.tbl_[i] = tbl_[pos + i];\n\t\t}\n\t\treturn pack;\n\t}\n\tvoid put() const\n\t{\n\t\tfor (size_t i = 0; i < n_; i++) {\n\t\t\tprintf(\"%s \", tbl_[i]->toString());\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n};\n\nclass StackFrame {\n#ifdef XBYAK64_WIN\n\tstatic const int noSaveNum = 6;\n\tstatic const int rcxPos = 0;\n\tstatic const int rdxPos = 1;\n#else\n\tstatic const int noSaveNum = 8;\n\tstatic const int rcxPos = 3;\n\tstatic const int rdxPos = 2;\n#endif\n\tstatic const int maxRegNum = 14; // maxRegNum = 16 - rsp - rax\n\tXbyak::CodeGenerator *code_;\n\tint pNum_;\n\tint tNum_;\n\tbool useRcx_;\n\tbool useRdx_;\n\tint saveNum_;\n\tint P_;\n\tbool makeEpilog_;\n\tXbyak::Reg64 pTbl_[4];\n\tXbyak::Reg64 tTbl_[maxRegNum];\n\tPack p_;\n\tPack t_;\n\tStackFrame(const StackFrame&);\n\tvoid operator=(const StackFrame&);\npublic:\n\tconst Pack& p;\n\tconst Pack& t;\n\t/*\n\t\tmake stack frame\n\t\t@param sf [in] this\n\t\t@param pNum [in] num of function parameter(0 <= pNum <= 4)\n\t\t@param tNum [in] num of temporary register(0 <= tNum, with UseRCX, UseRDX) #{pNum + tNum [+rcx] + [rdx]} <= 14\n\t\t@param stackSizeByte [in] local stack size\n\t\t@param makeEpilog [in] automatically call close() if true\n\n\t\tyou can use\n\t\trax\n\t\tgp0, ..., gp(pNum - 1)\n\t\tgt0, ..., gt(tNum-1)\n\t\trcx if tNum & UseRCX\n\t\trdx if tNum & UseRDX\n\t\trsp[0..stackSizeByte - 1]\n\t*/\n\tStackFrame(Xbyak::CodeGenerator *code, int pNum, int tNum = 0, int stackSizeByte = 0, bool makeEpilog = true)\n\t\t: code_(code)\n\t\t, pNum_(pNum)\n\t\t, tNum_(tNum & ~(UseRCX | UseRDX))\n\t\t, useRcx_((tNum & UseRCX) != 0)\n\t\t, useRdx_((tNum & UseRDX) != 0)\n\t\t, saveNum_(0)\n\t\t, P_(0)\n\t\t, makeEpilog_(makeEpilog)\n\t\t, p(p_)\n\t\t, t(t_)\n\t{\n\t\tusing namespace Xbyak;\n\t\tif (pNum < 0 || pNum > 4) throw Error(ERR_BAD_PNUM);\n\t\tconst int allRegNum = pNum + tNum_ + (useRcx_ ? 1 : 0) + (useRdx_ ? 1 : 0);\n\t\tif (tNum_ < 0 || allRegNum > maxRegNum) throw Error(ERR_BAD_TNUM);\n\t\tconst Reg64& _rsp = code->rsp;\n\t\tsaveNum_ = (std::max)(0, allRegNum - noSaveNum);\n\t\tconst int *tbl = getOrderTbl() + noSaveNum;\n\t\tfor (int i = 0; i < saveNum_; i++) {\n\t\t\tcode->push(Reg64(tbl[i]));\n\t\t}\n\t\tP_ = (stackSizeByte + 7) / 8;\n\t\tif (P_ > 0 && (P_ & 1) == (saveNum_ & 1)) P_++; // (rsp % 16) == 8, then increment P_ for 16 byte alignment\n\t\tP_ *= 8;\n\t\tif (P_ > 0) code->sub(_rsp, P_);\n\t\tint pos = 0;\n\t\tfor (int i = 0; i < pNum; i++) {\n\t\t\tpTbl_[i] = Xbyak::Reg64(getRegIdx(pos));\n\t\t}\n\t\tfor (int i = 0; i < tNum_; i++) {\n\t\t\ttTbl_[i] = Xbyak::Reg64(getRegIdx(pos));\n\t\t}\n\t\tif (useRcx_ && rcxPos < pNum) code_->mov(code_->r10, code_->rcx);\n\t\tif (useRdx_ && rdxPos < pNum) code_->mov(code_->r11, code_->rdx);\n\t\tp_.init(pTbl_, pNum);\n\t\tt_.init(tTbl_, tNum_);\n\t}\n\t/*\n\t\tmake epilog manually\n\t\t@param callRet [in] call ret() if true\n\t*/\n\tvoid close(bool callRet = true)\n\t{\n\t\tusing namespace Xbyak;\n\t\tconst Reg64& _rsp = code_->rsp;\n\t\tconst int *tbl = getOrderTbl() + noSaveNum;\n\t\tif (P_ > 0) code_->add(_rsp, P_);\n\t\tfor (int i = 0; i < saveNum_; i++) {\n\t\t\tcode_->pop(Reg64(tbl[saveNum_ - 1 - i]));\n\t\t}\n\n\t\tif (callRet) code_->ret();\n\t}\n\t~StackFrame()\n\t{\n\t\tif (!makeEpilog_) return;\n\t\tclose();\n\t}\nprivate:\n\tconst int *getOrderTbl() const\n\t{\n\t\tusing namespace Xbyak;\n\t\tstatic const int tbl[] = {\n#ifdef XBYAK64_WIN\n\t\t\tOperand::RCX, Operand::RDX, Operand::R8, Operand::R9, Operand::R10, Operand::R11, Operand::RDI, Operand::RSI,\n#else\n\t\t\tOperand::RDI, Operand::RSI, Operand::RDX, Operand::RCX, Operand::R8, Operand::R9, Operand::R10, Operand::R11,\n#endif\n\t\t\tOperand::RBX, Operand::RBP, Operand::R12, Operand::R13, Operand::R14, Operand::R15\n\t\t};\n\t\treturn &tbl[0];\n\t}\n\tint getRegIdx(int& pos) const\n\t{\n\t\tassert(pos < maxRegNum);\n\t\tusing namespace Xbyak;\n\t\tconst int *tbl = getOrderTbl();\n\t\tint r = tbl[pos++];\n\t\tif (useRcx_) {\n\t\t\tif (r == Operand::RCX) { return Operand::R10; }\n\t\t\tif (r == Operand::R10) { r = tbl[pos++]; }\n\t\t}\n\t\tif (useRdx_) {\n\t\t\tif (r == Operand::RDX) { return Operand::R11; }\n\t\t\tif (r == Operand::R11) { return tbl[pos++]; }\n\t\t}\n\t\treturn r;\n\t}\n};\n#endif\n\nclass Profiler {\n\tint mode_;\n\tconst char *suffix_;\n\tconst void *startAddr_;\n#ifdef XBYAK_USE_PERF\n\tFILE *fp_;\n#endif\npublic:\n\tenum {\n\t\tNone = 0,\n\t\tPerf = 1,\n\t\tVTune = 2\n\t};\n\tProfiler()\n\t\t: mode_(None)\n\t\t, suffix_(0)\n\t\t, startAddr_(0)\n#ifdef XBYAK_USE_PERF\n\t\t, fp_(0)\n#endif\n\t{\n\t}\n\t// append suffix to funcName\n\tvoid setNameSuffix(const char *suffix)\n\t{\n\t\tsuffix_ = suffix;\n\t}\n\tvoid setStartAddr(const void *startAddr)\n\t{\n\t\tstartAddr_ = startAddr;\n\t}\n\tvoid init(int mode)\n\t{\n\t\tmode_ = None;\n\t\tswitch (mode) {\n\t\tdefault:\n\t\tcase None:\n\t\t\treturn;\n\t\tcase Perf:\n#ifdef XBYAK_USE_PERF\n\t\t\tclose();\n\t\t\t{\n\t\t\t\tconst int pid = getpid();\n\t\t\t\tchar name[128];\n\t\t\t\tsnprintf(name, sizeof(name), \"/tmp/perf-%d.map\", pid);\n\t\t\t\tfp_ = fopen(name, \"a+\");\n\t\t\t\tif (fp_ == 0) {\n\t\t\t\t\tfprintf(stderr, \"can't open %s\\n\", name);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmode_ = Perf;\n#endif\n\t\t\treturn;\n\t\tcase VTune:\n#ifdef XBYAK_USE_VTUNE\n\t\t\tdlopen(\"dummy\", RTLD_LAZY); // force to load dlopen to enable jit profiling\n\t\t\tif (iJIT_IsProfilingActive() != iJIT_SAMPLING_ON) {\n\t\t\t\tfprintf(stderr, \"VTune profiling is not active\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmode_ = VTune;\n#endif\n\t\t\treturn;\n\t\t}\n\t}\n\t~Profiler()\n\t{\n\t\tclose();\n\t}\n\tvoid close()\n\t{\n#ifdef XBYAK_USE_PERF\n\t\tif (fp_ == 0) return;\n\t\tfclose(fp_);\n\t\tfp_ = 0;\n#endif\n\t}\n\tvoid set(const char *funcName, const void *startAddr, size_t funcSize) const\n\t{\n\t\tif (mode_ == None) return;\n#if !defined(XBYAK_USE_PERF) && !defined(XBYAK_USE_VTUNE)\n\t\t(void)funcName;\n\t\t(void)startAddr;\n\t\t(void)funcSize;\n#endif\n#ifdef XBYAK_USE_PERF\n\t\tif (mode_ == Perf) {\n\t\t\tif (fp_ == 0) return;\n\t\t\tfprintf(fp_, \"%llx %zx %s%s\\n\", (long long)startAddr, funcSize, funcName, suffix_);\n\t\t\tfflush(fp_);\n\t\t}\n#endif\n#ifdef XBYAK_USE_VTUNE\n\t\tif (mode_ != VTune) return;\n\t\tchar className[] = \"\";\n\t\tchar fileName[] = \"\";\n\t\tiJIT_Method_Load jmethod = {};\n\t\tjmethod.method_id = iJIT_GetNewMethodID();\n\t\tjmethod.class_file_name = className;\n\t\tjmethod.source_file_name = fileName;\n\t\tjmethod.method_load_address = const_cast<void*>(startAddr);\n\t\tjmethod.method_size = funcSize;\n\t\tjmethod.line_number_size = 0;\n\t\tchar buf[128];\n\t\tsnprintf(buf, sizeof(buf), \"%s%s\", funcName, suffix_);\n\t\tjmethod.method_name = buf;\n\t\tiJIT_NotifyEvent(iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED, (void*)&jmethod);\n#endif\n\t}\n\t/*\n\t\tfor continuous set\n\t\tfuncSize = endAddr - <previous set endAddr>\n\t*/\n\tvoid set(const char *funcName, const void *endAddr)\n\t{\n\t\tset(funcName, startAddr_, (size_t)endAddr - (size_t)startAddr_);\n\t\tstartAddr_ = endAddr;\n\t}\n};\n\n} } // end of util\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/programming_model/images/img_dnnl_object_snapshot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/programming_model/images/img_dnnl_programming_flow.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/programming_model/images/img_overview_flow.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/primitives/images/unrolled_stack_rnn.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/advanced/design/strides.png",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/advanced/design/mem_fmt_img1.png",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/advanced/design/mem_fmt_blk.png",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/advanced/design/mem_fmt_padded_blk.png",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/advanced/design/mem_fmt_img2.png",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/usage_models/images/img_diagram.png",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/usage_models/images/img_multiscalar.png",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/usage_models/images/img_training_inference_scope.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/usage_models/images/img_singlescalar.png",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/usage_models/images/img_inference_scope.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/usage_models/images/img_bf16_diagram.png",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_WinChrome-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Fraktur-Bold.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Math-BoldItalic.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Size1-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Main-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_WinIE6-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Vector-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Caligraphic-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Vector-Bold.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_SansSerif-Bold.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Size2-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Main-Bold.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_SansSerif-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Size4-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Math-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Script-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_AMS-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Main-Italic.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Size3-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Caligraphic-Bold.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_SansSerif-Italic.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Fraktur-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Typewriter-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Math-Italic.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_SansSerif-Bold.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Caligraphic-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Vector-Bold.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Math-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Typewriter-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Vector-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Math-Italic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_SansSerif-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Fraktur-Bold.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Script-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Fraktur-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Size2-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Main-Bold.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Math-BoldItalic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Size1-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_SansSerif-Italic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Size4-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Size3-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Main-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_AMS-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Caligraphic-Bold.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Main-Italic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_Normal-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_Arrows-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_Variants-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_Size1-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_Symbols-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_Alphabets-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_Size6-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_DoubleStruck-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_Size2-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_SansSerif-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_Misc-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_Main-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_NonUnicode-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_Size4-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_Size5-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_Marks-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_Fraktur-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_Size3-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_Shapes-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_Operators-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_Monospace-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_Script-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/otf/AsanaMathJax_Latin-Regular.otf",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_Marks-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_Normal-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_DoubleStruck-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_Monospace-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_Shapes-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_Fraktur-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_Variants-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_SansSerif-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_Latin-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_Symbols-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_Size5-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_Size1-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_Arrows-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_Alphabets-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_Main-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_Script-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_Size6-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_NonUnicode-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_Operators-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_Size3-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_Size4-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_Misc-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-onednn-1.2.2-npilyvdyeio4kqmnk3un4fwfv6dsw5cv/spack-src/doc/assets/mathjax/fonts/HTML-CSS/Asana-Math/woff/AsanaMathJax_Size2-Regular.woff"
    ],
    "total_files": 1176
}