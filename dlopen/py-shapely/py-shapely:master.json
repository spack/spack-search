{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-shapely-master-lpvxixefeguidohgwagwexummyorkpq2/spack-src/shapely/geos.py": "\"\"\"\nProxies for libgeos, GEOS-specific exceptions, and utilities\n\"\"\"\n\nimport atexit\nfrom ctypes import (\n    CDLL, cdll, pointer, string_at, DEFAULT_MODE, c_void_p, c_size_t, c_char_p)\nfrom ctypes.util import find_library\nimport glob\nimport logging\nimport os\nimport re\nimport sys\nimport threading\nfrom functools import partial\n\nfrom .ctypes_declarations import prototype, EXCEPTION_HANDLER_FUNCTYPE\nfrom .errors import WKBReadingError, WKTReadingError, TopologicalError, PredicateError\n\n\n# Add message handler to this module's logger\nLOG = logging.getLogger(__name__)\n\n# Find and load the GEOS and C libraries\n# If this ever gets any longer, we'll break it into separate modules\n\ndef load_dll(libname, fallbacks=None, mode=DEFAULT_MODE):\n    lib = find_library(libname)\n    dll = None\n    if lib is not None:\n        try:\n            LOG.debug(\"Trying `CDLL(%s)`\", lib)\n            dll = CDLL(lib, mode=mode)\n        except OSError:\n            LOG.debug(\"Failed `CDLL(%s)`\", lib)\n            pass\n\n    if not dll and fallbacks is not None:\n        for name in fallbacks:\n            try:\n                LOG.debug(\"Trying `CDLL(%s)`\", name)\n                dll = CDLL(name, mode=mode)\n            except OSError:\n                # move on to the next fallback\n                LOG.debug(\"Failed `CDLL(%s)`\", name)\n                pass\n\n    if dll:\n        LOG.debug(\"Library path: %r\", lib or name)\n        LOG.debug(\"DLL: %r\", dll)\n        return dll\n    else:\n        # No shared library was loaded. Raise OSError.\n        raise OSError(\n            \"Could not find lib {} or load any of its variants {}.\".format(\n                libname, fallbacks or []))\n\n_lgeos = None\ndef exists_conda_env():\n    \"\"\"Does this module exist in a conda environment?\"\"\"\n    return os.path.exists(os.path.join(sys.prefix, 'conda-meta'))\n\n\nif sys.platform.startswith('linux'):\n    # Test to see if we have a wheel repaired by auditwheel which contains its\n    # own libgeos_c. Note: auditwheel 3.1 changed the location of libs.\n    geos_whl_so = glob.glob(\n        os.path.abspath(os.path.join(os.path.dirname(__file__), \".libs/libgeos*.so*\"))\n    ) or glob.glob(\n        os.path.abspath(\n            os.path.join(\n                os.path.dirname(__file__), \"..\", \"Shapely.libs\", \"libgeos*.so*\"\n            )\n        )\n    )\n\n    if len(geos_whl_so) > 0:\n        # We have observed problems with CDLL of libgeos_c not automatically\n        # loading the sibling c++ library since the change made by auditwheel\n        # 3.1, so we explicitly load them both.\n        geos_whl_so = sorted(geos_whl_so)\n        CDLL(geos_whl_so[0])\n        _lgeos = CDLL(geos_whl_so[-1])\n        LOG.debug(\"Found GEOS DLL: %r, using it.\", _lgeos)\n\n    elif hasattr(sys, 'frozen'):\n        geos_pyinstaller_so = glob.glob(os.path.join(sys.prefix, 'libgeos_c-*.so.*'))\n        if len(geos_pyinstaller_so) == 1:\n            _lgeos = CDLL(geos_pyinstaller_so[0])\n            LOG.debug(\"Found GEOS DLL: %r, using it.\", _lgeos)\n    elif exists_conda_env():\n        # conda package.\n        _lgeos = CDLL(os.path.join(sys.prefix, 'lib', 'libgeos_c.so'))\n    else:\n        alt_paths = [\n            'libgeos_c.so.1',\n            'libgeos_c.so',\n        ]\n        _lgeos = load_dll('libgeos_c', fallbacks=alt_paths)\n    # Necessary for environments with only libc.musl\n    c_alt_paths = [\n        'libc.musl-x86_64.so.1'\n    ]\n    free = load_dll('c', fallbacks=c_alt_paths).free\n    free.argtypes = [c_void_p]\n    free.restype = None\n\nelif sys.platform == 'darwin':\n    # Test to see if we have a delocated wheel with a GEOS dylib.\n    geos_whl_dylib = os.path.abspath(os.path.join(os.path.dirname(\n        __file__), '.dylibs/libgeos_c.1.dylib'))\n\n    if os.path.exists(geos_whl_dylib):\n        handle = CDLL(None)\n        if hasattr(handle, \"initGEOS_r\"):\n            LOG.debug(\"GEOS already loaded\")\n            _lgeos = handle\n        else:\n            _lgeos = CDLL(geos_whl_dylib)\n            LOG.debug(\"Found GEOS DLL: %r, using it.\", _lgeos)\n\n    elif exists_conda_env():\n        # conda package.\n        _lgeos = CDLL(os.path.join(sys.prefix, 'lib', 'libgeos_c.dylib'))\n    else:\n        if hasattr(sys, 'frozen'):\n            try:\n                # .app file from py2app\n                alt_paths = [os.path.join(\n                    os.environ['RESOURCEPATH'], '..', 'Frameworks',\n                    'libgeos_c.dylib')]\n            except KeyError:\n                # binary from pyinstaller\n                alt_paths = [\n                    os.path.join(sys.executable, 'libgeos_c.dylib')]\n                if hasattr(sys, '_MEIPASS'):\n                    alt_paths.append(\n                        os.path.join(sys._MEIPASS, 'libgeos_c.1.dylib'))\n        else:\n            alt_paths = [\n                # The Framework build from Kyng Chaos\n                \"/Library/Frameworks/GEOS.framework/Versions/Current/GEOS\",\n                # macports\n                '/opt/local/lib/libgeos_c.dylib',\n                # homebrew\n                '/usr/local/lib/libgeos_c.dylib',\n            ]\n        _lgeos = load_dll('geos_c', fallbacks=alt_paths)\n\n    # ctypes.CDLL(None) internally calls dlopen(NULL), and as the dlopen\n    # manpage says, \"If filename is NULL, then the returned handle is for the\n    # main program\". This way we can let the linker do the work to figure out\n    # which libc Python is actually using.\n    free = CDLL(None).free\n    free.argtypes = [c_void_p]\n    free.restype = None\n\nelif sys.platform == 'win32':\n    if exists_conda_env():\n        # conda package.\n        _lgeos = CDLL(os.path.join(sys.prefix, 'Library', 'bin', 'geos_c.dll'))\n    else:\n        try:\n            egg_dlls = os.path.abspath(\n                os.path.join(os.path.dirname(__file__), 'DLLs'))\n            if hasattr(sys, '_MEIPASS'):\n                wininst_dlls = sys._MEIPASS\n            elif hasattr(sys, \"frozen\"):\n                wininst_dlls = os.path.normpath(\n                    os.path.abspath(sys.executable + '../../DLLS'))\n            else:\n                wininst_dlls = os.path.abspath(os.__file__ + \"../../../DLLs\")\n            original_path = os.environ['PATH']\n            os.environ['PATH'] = \"%s;%s;%s\" % \\\n                (egg_dlls, wininst_dlls, original_path)\n            _lgeos = load_dll(\"geos_c.dll\")\n        except (ImportError, WindowsError, OSError):\n            raise\n\n        def free(m):\n            try:\n                cdll.msvcrt.free(m)\n            except WindowsError:\n                # XXX: See http://trac.gispython.org/projects/PCL/ticket/149\n                pass\n\nelif sys.platform == 'sunos5':\n    _lgeos = load_dll('geos_c', fallbacks=['libgeos_c.so.1', 'libgeos_c.so'])\n    free = CDLL('libc.so.1').free\n    free.argtypes = [c_void_p]\n    free.restype = None\nelse:  # other *nix systems\n    _lgeos = load_dll('geos_c', fallbacks=['libgeos_c.so.1', 'libgeos_c.so'])\n    free = load_dll('c', fallbacks=['libc.so.6']).free\n    free.argtypes = [c_void_p]\n    free.restype = None\n\n\ndef _geos_version():\n    GEOSversion = _lgeos.GEOSversion\n    GEOSversion.restype = c_char_p\n    GEOSversion.argtypes = []\n    geos_version_string = GEOSversion().decode('ascii')\n    res = re.findall(r'(\\d+)\\.(\\d+)\\.(\\d+)', geos_version_string)\n    assert len(res) == 2, res\n    geos_version = tuple(int(x) for x in res[0])\n    capi_version = tuple(int(x) for x in res[1])\n    return geos_version_string, geos_version, capi_version\n\ngeos_version_string, geos_version, geos_capi_version = _geos_version()\n\n\n# Record a baseline so that we know what additional functions are declared\n# in ctypes_declarations.\nstart_set = set(_lgeos.__dict__)\n\n# Apply prototypes for the libgeos_c functions\nprototype(_lgeos, geos_version)\n\n# Automatically detect all function declarations, and declare their\n# re-entrant counterpart.\nend_set = set(_lgeos.__dict__)\nnew_func_names = end_set - start_set\n\nfor func_name in new_func_names:\n    new_func_name = \"%s_r\" % func_name\n    if hasattr(_lgeos, new_func_name):\n        new_func = getattr(_lgeos, new_func_name)\n        old_func = getattr(_lgeos, func_name)\n        new_func.restype = old_func.restype\n        if old_func.argtypes is None:\n            # Handle functions that didn't take an argument before,\n            # finishGEOS.\n            new_func.argtypes = [c_void_p]\n        else:\n            new_func.argtypes = [c_void_p] + list(old_func.argtypes)\n        if old_func.errcheck is not None:\n            new_func.errcheck = old_func.errcheck\n\n# Handle special case.\n_lgeos.initGEOS_r.restype = c_void_p\n_lgeos.initGEOS_r.argtypes = \\\n    [EXCEPTION_HANDLER_FUNCTYPE, EXCEPTION_HANDLER_FUNCTYPE]\n_lgeos.finishGEOS_r.argtypes = [c_void_p]\n\n\ndef make_logging_callback(func):\n    \"\"\"Error or notice handler callback producr\n\n    Wraps a logger method, func, as a GEOS callback.\n    \"\"\"\n    def callback(fmt, *fmt_args):\n        fmt = fmt.decode('ascii')\n        conversions = re.findall(r'%.', fmt)\n        args = [\n            string_at(arg).decode('ascii')\n            for spec, arg in zip(conversions, fmt_args)\n            if spec == '%s' and arg is not None]\n\n        func(fmt, *args)\n\n    return callback\n\nerror_handler = make_logging_callback(LOG.error)\nnotice_handler = make_logging_callback(LOG.info)\n\nerror_h = EXCEPTION_HANDLER_FUNCTYPE(error_handler)\nnotice_h = EXCEPTION_HANDLER_FUNCTYPE(notice_handler)\n\n\nclass WKTReader(object):\n\n    _lgeos = None\n    _reader = None\n\n    def __init__(self, lgeos):\n        \"\"\"Create WKT Reader\"\"\"\n        self._lgeos = lgeos\n        self._reader = self._lgeos.GEOSWKTReader_create()\n\n    def __del__(self):\n        \"\"\"Destroy WKT Reader\"\"\"\n        if self._lgeos is not None:\n            self._lgeos.GEOSWKTReader_destroy(self._reader)\n            self._reader = None\n            self._lgeos = None\n\n    def read(self, text):\n        \"\"\"Returns geometry from WKT\"\"\"\n        if not isinstance(text, str):\n            raise TypeError(\"Only str is accepted.\")\n        text = text.encode()\n        c_string = c_char_p(text)\n        geom = self._lgeos.GEOSWKTReader_read(self._reader, c_string)\n        if not geom:\n            raise WKTReadingError(\n                \"Could not create geometry because of errors \"\n                \"while reading input.\")\n        # avoid circular import dependency\n        from shapely.geometry.base import geom_factory\n        return geom_factory(geom)\n\n\nclass WKTWriter(object):\n\n    _lgeos = None\n    _writer = None\n\n    # Establish default output settings\n    defaults = {\n        'trim': True,\n        'output_dimension': 3,\n    }\n\n    # GEOS' defaults for methods without \"get\"\n    _trim = False\n    _rounding_precision = -1\n    _old_3d = False\n\n    @property\n    def trim(self):\n        \"\"\"Trimming of unnecessary decimals (default: True)\"\"\"\n        return getattr(self, '_trim')\n\n    @trim.setter\n    def trim(self, value):\n        self._trim = bool(value)\n        self._lgeos.GEOSWKTWriter_setTrim(self._writer, self._trim)\n\n    @property\n    def rounding_precision(self):\n        \"\"\"Rounding precision when writing the WKT.\n        A precision of -1 (default) disables it.\"\"\"\n        return getattr(self, '_rounding_precision')\n\n    @rounding_precision.setter\n    def rounding_precision(self, value):\n        self._rounding_precision = int(value)\n        self._lgeos.GEOSWKTWriter_setRoundingPrecision(\n            self._writer, self._rounding_precision)\n\n    @property\n    def output_dimension(self):\n        \"\"\"Output dimension, either 2 or 3 (default)\"\"\"\n        return self._lgeos.GEOSWKTWriter_getOutputDimension(\n            self._writer)\n\n    @output_dimension.setter\n    def output_dimension(self, value):\n        self._lgeos.GEOSWKTWriter_setOutputDimension(\n            self._writer, int(value))\n\n    @property\n    def old_3d(self):\n        \"\"\"Show older style for 3D WKT, without 'Z' (default: False)\"\"\"\n        return getattr(self, '_old_3d')\n\n    @old_3d.setter\n    def old_3d(self, value):\n        self._old_3d = bool(value)\n        self._lgeos.GEOSWKTWriter_setOld3D(self._writer, self._old_3d)\n\n    def __init__(self, lgeos, **settings):\n        \"\"\"Create WKT Writer\n\n        Note: older formatting before GEOS 3.3.0 can be achieved by setting\n        the properties:\n            trim = False\n            output_dimension = 2\n        \"\"\"\n        self._lgeos = lgeos\n        self._writer = self._lgeos.GEOSWKTWriter_create()\n\n        applied_settings = self.defaults.copy()\n        applied_settings.update(settings)\n        for name in applied_settings:\n            setattr(self, name, applied_settings[name])\n\n    def __setattr__(self, name, value):\n        \"\"\"Limit setting attributes\"\"\"\n        if hasattr(self, name):\n            object.__setattr__(self, name, value)\n        else:\n            raise AttributeError('%r object has no attribute %r' %\n                                 (self.__class__.__name__, name))\n\n    def __del__(self):\n        \"\"\"Destroy WKT Writer\"\"\"\n        if self._lgeos is not None:\n            self._lgeos.GEOSWKTWriter_destroy(self._writer)\n            self._writer = None\n            self._lgeos = None\n\n    def write(self, geom):\n        \"\"\"Returns WKT string for geometry\"\"\"\n        if geom is None or geom._geom is None:\n            raise ValueError(\"Null geometry supports no operations\")\n        result = self._lgeos.GEOSWKTWriter_write(self._writer, geom._geom)\n        text = string_at(result)\n        lgeos.GEOSFree(result)\n        return text.decode('ascii')\n\n\nclass WKBReader(object):\n\n    _lgeos = None\n    _reader = None\n\n    def __init__(self, lgeos):\n        \"\"\"Create WKB Reader\"\"\"\n        self._lgeos = lgeos\n        self._reader = self._lgeos.GEOSWKBReader_create()\n\n    def __del__(self):\n        \"\"\"Destroy WKB Reader\"\"\"\n        if self._lgeos is not None:\n            self._lgeos.GEOSWKBReader_destroy(self._reader)\n            self._reader = None\n            self._lgeos = None\n\n    def read(self, data):\n        \"\"\"Returns geometry from WKB\"\"\"\n        geom = self._lgeos.GEOSWKBReader_read(\n            self._reader, c_char_p(data), c_size_t(len(data)))\n        if not geom:\n            raise WKBReadingError(\n                \"Could not create geometry because of errors \"\n                \"while reading input.\")\n        # avoid circular import dependency\n        from shapely import geometry\n        return geometry.base.geom_factory(geom)\n\n    def read_hex(self, data):\n        \"\"\"Returns geometry from WKB hex\"\"\"\n        data = data.encode('ascii')\n        geom = self._lgeos.GEOSWKBReader_readHEX(\n            self._reader, c_char_p(data), c_size_t(len(data)))\n        if not geom:\n            raise WKBReadingError(\n                \"Could not create geometry because of errors \"\n                \"while reading input.\")\n        # avoid circular import dependency\n        from shapely import geometry\n        return geometry.base.geom_factory(geom)\n\n\nclass WKBWriter(object):\n\n    _lgeos = None\n    _writer = None\n\n    # EndianType enum in ByteOrderValues.h\n    _ENDIAN_BIG = 0\n    _ENDIAN_LITTLE = 1\n\n    # Establish default output setting\n    defaults = {'output_dimension': 3}\n\n    @property\n    def output_dimension(self):\n        \"\"\"Output dimension, either 2 or 3 (default)\"\"\"\n        return self._lgeos.GEOSWKBWriter_getOutputDimension(self._writer)\n\n    @output_dimension.setter\n    def output_dimension(self, value):\n        self._lgeos.GEOSWKBWriter_setOutputDimension(\n            self._writer, int(value))\n\n    @property\n    def big_endian(self):\n        \"\"\"Byte order is big endian, True (default) or False\"\"\"\n        return (self._lgeos.GEOSWKBWriter_getByteOrder(self._writer) ==\n                self._ENDIAN_BIG)\n\n    @big_endian.setter\n    def big_endian(self, value):\n        self._lgeos.GEOSWKBWriter_setByteOrder(\n            self._writer, self._ENDIAN_BIG if value else self._ENDIAN_LITTLE)\n\n    @property\n    def include_srid(self):\n        \"\"\"Include SRID, True or False (default)\"\"\"\n        return bool(self._lgeos.GEOSWKBWriter_getIncludeSRID(self._writer))\n\n    @include_srid.setter\n    def include_srid(self, value):\n        self._lgeos.GEOSWKBWriter_setIncludeSRID(self._writer, bool(value))\n\n    def __init__(self, lgeos, **settings):\n        \"\"\"Create WKB Writer\"\"\"\n        self._lgeos = lgeos\n        self._writer = self._lgeos.GEOSWKBWriter_create()\n\n        applied_settings = self.defaults.copy()\n        applied_settings.update(settings)\n        for name in applied_settings:\n            setattr(self, name, applied_settings[name])\n\n    def __setattr__(self, name, value):\n        \"\"\"Limit setting attributes\"\"\"\n        if hasattr(self, name):\n            object.__setattr__(self, name, value)\n        else:\n            raise AttributeError('%r object has no attribute %r' %\n                                 (self.__class__.__name__, name))\n\n    def __del__(self):\n        \"\"\"Destroy WKB Writer\"\"\"\n        if self._lgeos is not None:\n            self._lgeos.GEOSWKBWriter_destroy(self._writer)\n            self._writer = None\n            self._lgeos = None\n\n    def write(self, geom):\n        \"\"\"Returns WKB byte string for geometry\"\"\"\n        if geom is None or geom._geom is None:\n            raise ValueError(\"Null geometry supports no operations\")\n        size = c_size_t()\n        result = self._lgeos.GEOSWKBWriter_write(\n            self._writer, geom._geom, pointer(size))\n        data = string_at(result, size.value)\n        lgeos.GEOSFree(result)\n        return data\n\n    def write_hex(self, geom):\n        \"\"\"Returns WKB hex string for geometry\"\"\"\n        if geom is None or geom._geom is None:\n            raise ValueError(\"Null geometry supports no operations\")\n        size = c_size_t()\n        result = self._lgeos.GEOSWKBWriter_writeHEX(\n            self._writer, geom._geom, pointer(size))\n        data = string_at(result, size.value)\n        lgeos.GEOSFree(result)\n        return data.decode('ascii')\n\n\n# Errcheck functions for ctypes\n\ndef errcheck_wkb(result, func, argtuple):\n    \"\"\"Returns bytes from a C pointer\"\"\"\n    if not result:\n        return None\n    size_ref = argtuple[-1]\n    size = size_ref.contents\n    retval = string_at(result, size.value)[:]\n    lgeos.GEOSFree(result)\n    return retval\n\n\ndef errcheck_just_free(result, func, argtuple):\n    \"\"\"Returns string from a C pointer\"\"\"\n    retval = string_at(result)\n    lgeos.GEOSFree(result)\n    return retval.decode('ascii')\n\n\ndef errcheck_null_exception(result, func, argtuple):\n    \"\"\"Wraps errcheck_just_free\n\n    Raises TopologicalError if result is NULL.\n    \"\"\"\n    if not result:\n        raise TopologicalError(\n            \"The operation '{}' could not be performed.\"\n            \"Likely cause is invalidity of the geometry.\".format(\n                func.__name__))\n    return errcheck_just_free(result, func, argtuple)\n\n\ndef errcheck_predicate(result, func, argtuple):\n    \"\"\"Result is 2 on exception, 1 on True, 0 on False\"\"\"\n    if result == 2:\n        raise PredicateError(\"Failed to evaluate %s\" % repr(func))\n    return result\n\n\nclass LGEOSBase(threading.local):\n    \"\"\"Proxy for GEOS C API\n\n    This is a base class. Do not instantiate.\n    \"\"\"\n    methods = {}\n\n    def __init__(self, dll):\n        self._lgeos = dll\n        self.geos_handle = None\n\n    def __del__(self):\n        \"\"\"Cleanup GEOS related processes\"\"\"\n        if self._lgeos is not None:\n            self._lgeos.finishGEOS()\n            self._lgeos = None\n            self.geos_handle = None\n\n\nclass LGEOS330(LGEOSBase):\n    \"\"\"Proxy for GEOS 3.3.0-CAPI-1.7.0\n    \"\"\"\n    geos_version = (3, 3, 0)\n    geos_capi_version = (1, 7, 0)\n\n    def __init__(self, dll):\n        super(LGEOS330, self).__init__(dll)\n        self.geos_handle = self._lgeos.initGEOS_r(notice_h, error_h)\n        keys = list(self._lgeos.__dict__.keys())\n        for key in [x for x in keys if not x.endswith('_r')]:\n            if key + '_r' in keys:\n                reentr_func = getattr(self._lgeos, key + '_r')\n                attr = partial(reentr_func, self.geos_handle)\n                attr.__name__ = reentr_func.__name__\n                setattr(self, key, attr)\n            else:\n                setattr(self, key, getattr(self._lgeos, key))\n\n        # GEOS 3.3.8 from homebrew has, but doesn't advertise\n        # GEOSPolygonize_full. We patch it in explicitly here.\n        key = 'GEOSPolygonize_full'\n        func = getattr(self._lgeos, key + '_r')\n        attr = partial(func, self.geos_handle)\n        attr.__name__ = func.__name__\n        setattr(self, key, attr)\n\n        # Deprecated\n        self.GEOSGeomToWKB_buf.func.errcheck = errcheck_wkb\n        self.GEOSGeomToWKT.func.errcheck = errcheck_just_free\n        self.GEOSRelate.func.errcheck = errcheck_null_exception\n        for pred in (\n                self.GEOSDisjoint,\n                self.GEOSTouches,\n                self.GEOSIntersects,\n                self.GEOSCrosses,\n                self.GEOSWithin,\n                self.GEOSContains,\n                self.GEOSOverlaps,\n                self.GEOSCovers,\n                self.GEOSEquals,\n                self.GEOSEqualsExact,\n                self.GEOSPreparedDisjoint,\n                self.GEOSPreparedTouches,\n                self.GEOSPreparedCrosses,\n                self.GEOSPreparedWithin,\n                self.GEOSPreparedOverlaps,\n                self.GEOSPreparedContains,\n                self.GEOSPreparedContainsProperly,\n                self.GEOSPreparedCovers,\n                self.GEOSPreparedIntersects,\n                self.GEOSRelatePattern,\n                self.GEOSisEmpty,\n                self.GEOSisValid,\n                self.GEOSisSimple,\n                self.GEOSisRing,\n                self.GEOSHasZ,\n                self.GEOSisClosed,\n                self.GEOSCoveredBy):\n            pred.func.errcheck = errcheck_predicate\n\n        self.GEOSisValidReason.func.errcheck = errcheck_just_free\n\n        self.methods['area'] = self.GEOSArea\n        self.methods['boundary'] = self.GEOSBoundary\n        self.methods['buffer'] = self.GEOSBuffer\n        self.methods['centroid'] = self.GEOSGetCentroid\n        self.methods['representative_point'] = self.GEOSPointOnSurface\n        self.methods['convex_hull'] = self.GEOSConvexHull\n        self.methods['distance'] = self.GEOSDistance\n        self.methods['envelope'] = self.GEOSEnvelope\n        self.methods['length'] = self.GEOSLength\n        self.methods['has_z'] = self.GEOSHasZ\n        self.methods['is_empty'] = self.GEOSisEmpty\n        self.methods['is_ring'] = self.GEOSisRing\n        self.methods['is_simple'] = self.GEOSisSimple\n        self.methods['is_valid'] = self.GEOSisValid\n        self.methods['disjoint'] = self.GEOSDisjoint\n        self.methods['touches'] = self.GEOSTouches\n        self.methods['intersects'] = self.GEOSIntersects\n        self.methods['crosses'] = self.GEOSCrosses\n        self.methods['within'] = self.GEOSWithin\n        self.methods['contains'] = self.GEOSContains\n        self.methods['overlaps'] = self.GEOSOverlaps\n        self.methods['covers'] = self.GEOSCovers\n        self.methods['equals'] = self.GEOSEquals\n        self.methods['equals_exact'] = self.GEOSEqualsExact\n        self.methods['relate'] = self.GEOSRelate\n        self.methods['difference'] = self.GEOSDifference\n        self.methods['symmetric_difference'] = self.GEOSSymDifference\n        self.methods['union'] = self.GEOSUnion\n        self.methods['intersection'] = self.GEOSIntersection\n        self.methods['prepared_disjoint'] = self.GEOSPreparedDisjoint\n        self.methods['prepared_touches'] = self.GEOSPreparedTouches\n        self.methods['prepared_intersects'] = self.GEOSPreparedIntersects\n        self.methods['prepared_crosses'] = self.GEOSPreparedCrosses\n        self.methods['prepared_within'] = self.GEOSPreparedWithin\n        self.methods['prepared_contains'] = self.GEOSPreparedContains\n        self.methods['prepared_contains_properly'] = \\\n            self.GEOSPreparedContainsProperly\n        self.methods['prepared_overlaps'] = self.GEOSPreparedOverlaps\n        self.methods['prepared_covers'] = self.GEOSPreparedCovers\n        self.methods['relate_pattern'] = self.GEOSRelatePattern\n        self.methods['simplify'] = self.GEOSSimplify\n        self.methods['topology_preserve_simplify'] = \\\n            self.GEOSTopologyPreserveSimplify\n        self.methods['cascaded_union'] = self.GEOSUnionCascaded\n\n        def parallel_offset(geom, distance, resolution=16, join_style=1,\n                            mitre_limit=5.0, side='right'):\n            if side == 'right':\n                distance *= -1\n            return self.GEOSOffsetCurve(\n                geom, distance, resolution, join_style, mitre_limit)\n\n        self.methods['parallel_offset'] = parallel_offset\n        self.methods['project'] = self.GEOSProject\n        self.methods['project_normalized'] = self.GEOSProjectNormalized\n        self.methods['interpolate'] = self.GEOSInterpolate\n        self.methods['interpolate_normalized'] = \\\n            self.GEOSInterpolateNormalized\n        self.methods['buffer_with_style'] = self.GEOSBufferWithStyle\n        self.methods['hausdorff_distance'] = self.GEOSHausdorffDistance\n        self.methods['unary_union'] = self.GEOSUnaryUnion\n        self.methods['cascaded_union'] = self.methods['unary_union']\n        self.methods['is_closed'] = self.GEOSisClosed\n        self.methods['snap'] = self.GEOSSnap\n        self.methods['shared_paths'] = self.GEOSSharedPaths\n        self.methods['buffer_with_params'] = self.GEOSBufferWithParams\n        self.methods['covered_by'] = self.GEOSCoveredBy\n\n\nclass LGEOS340(LGEOS330):\n    \"\"\"Proxy for GEOS 3.4.0-CAPI-1.8.0\n    \"\"\"\n    geos_version = (3, 4, 0)\n    geos_capi_version = (1, 8, 0)\n\n    def __init__(self, dll):\n        super(LGEOS340, self).__init__(dll)\n        self.methods['delaunay_triangulation'] = self.GEOSDelaunayTriangulation\n        self.methods['nearest_points'] = self.GEOSNearestPoints\n\n\nclass LGEOS350(LGEOS340):\n    \"\"\"Proxy for GEOS 3.5.0-CAPI-1.9.0\n    \"\"\"\n    geos_version = (3, 5, 0)\n    geos_capi_version = (1, 9, 0)\n\n    def __init__(self, dll):\n        super(LGEOS350, self).__init__(dll)\n        self.methods['clip_by_rect'] = self.GEOSClipByRect\n        self.methods['voronoi_diagram'] = self.GEOSVoronoiDiagram\n\n\nclass LGEOS360(LGEOS350):\n    \"\"\"Proxy for GEOS 3.6.0-CAPI-1.10.0\n    \"\"\"\n    geos_version = (3, 6, 0)\n    geos_capi_version = (1, 10, 0)\n\n    def __init__(self, dll):\n        super(LGEOS360, self).__init__(dll)\n        self.methods['minimum_clearance'] = self.GEOSMinimumClearance\n\n\nclass LGEOS380(LGEOS360):\n    \"\"\"Proxy for GEOS 3.8.0-CAPI-1.13.0\"\"\"\n\n    geos_version = (3, 8, 0)\n    geos_capi_version = (1, 13, 0)\n\n    def __init__(self, dll):\n        super(LGEOS380, self).__init__(dll)\n        self.methods['make_valid'] = self.GEOSMakeValid\n\n\nif geos_version >= (3, 8, 0):\n    L = LGEOS380\nelif geos_version >= (3, 6, 0):\n    L = LGEOS360\nelif geos_version >= (3, 5, 0):\n    L = LGEOS350\nelif geos_version >= (3, 4, 0):\n    L = LGEOS340\nelif geos_version >= (3, 3, 0):\n    L = LGEOS330\nelse:\n    raise ValueError('unexpected geos_version: ' + str(geos_version))\n\nlgeos = L(_lgeos)\n\n\ndef cleanup(proxy):\n    del proxy\n\natexit.register(cleanup, lgeos)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-shapely-master-lpvxixefeguidohgwagwexummyorkpq2/spack-src/.git/objects/pack/pack-1c0e98f8b258fd9cac25e435120816722ab4ff6b.idx",
        "/tmp/vanessa/spack-stage/spack-stage-py-shapely-master-lpvxixefeguidohgwagwexummyorkpq2/spack-src/.git/objects/pack/pack-1c0e98f8b258fd9cac25e435120816722ab4ff6b.pack",
        "/tmp/vanessa/spack-stage/spack-stage-py-shapely-master-lpvxixefeguidohgwagwexummyorkpq2/spack-src/docs/images/simplify.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-shapely-master-lpvxixefeguidohgwagwexummyorkpq2/spack-src/docs/images/convex-hull.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-shapely-master-lpvxixefeguidohgwagwexummyorkpq2/spack-src/docs/images/4511827859_b5822043b7_o.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-shapely-master-lpvxixefeguidohgwagwexummyorkpq2/spack-src/docs/images/buffer.png"
    ],
    "total_files": 212
}