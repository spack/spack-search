{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/mesonbuild/build.py": "# Copyright 2012-2017 The Meson development team\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport copy, os, re\nfrom collections import OrderedDict\nimport itertools\n\nfrom . import environment\nfrom . import dependencies\nfrom . import mlog\nfrom .mesonlib import File, MesonException\nfrom .mesonlib import flatten, typeslistify, stringlistify, classify_unity_sources\nfrom .mesonlib import get_filenames_templates_dict, substitute_values\nfrom .environment import for_windows, for_darwin, for_cygwin\nfrom .compilers import is_object, clike_langs, sort_clike, lang_suffixes\n\nknown_basic_kwargs = {'install': True,\n                      'c_pch': True,\n                      'cpp_pch': True,\n                      'c_args': True,\n                      'objc_args': True,\n                      'objcpp_args': True,\n                      'cpp_args': True,\n                      'cs_args': True,\n                      'vala_args': True,\n                      'fortran_args': True,\n                      'd_args': True,\n                      'java_args': True,\n                      'rust_args': True,\n                      'link_args': True,\n                      'link_depends': True,\n                      'link_with': True,\n                      'link_whole': True,\n                      'implicit_include_directories': True,\n                      'include_directories': True,\n                      'dependencies': True,\n                      'install_dir': True,\n                      'main_class': True,\n                      'name_suffix': True,\n                      'gui_app': True,\n                      'extra_files': True,\n                      'install_rpath': True,\n                      'build_rpath': True,\n                      'resources': True,\n                      'sources': True,\n                      'objects': True,\n                      'native': True,\n                      'build_by_default': True,\n                      'override_options': True,\n                      }\n\n# These contain kwargs supported by both static and shared libraries. These are\n# combined here because a library() call might be shared_library() or\n# static_library() at runtime based on the configuration.\n# FIXME: Find a way to pass that info down here so we can have proper target\n# kwargs checking when specifically using shared_library() or static_library().\nknown_lib_kwargs = known_basic_kwargs.copy()\nknown_lib_kwargs.update({'version': True, # Only for shared libs\n                         'soversion': True, # Only for shared libs\n                         'name_prefix': True,\n                         'vs_module_defs': True, # Only for shared libs\n                         'vala_header': True,\n                         'vala_vapi': True,\n                         'vala_gir': True,\n                         'pic': True, # Only for static libs\n                         'rust_crate_type': True, # Only for Rust libs\n                         })\n\nknown_exe_kwargs = known_basic_kwargs.copy()\nknown_exe_kwargs.update({'implib': True,\n                         })\n\nclass InvalidArguments(MesonException):\n    pass\n\nclass Build:\n    \"\"\"A class that holds the status of one build including\n    all dependencies and so on.\n    \"\"\"\n\n    def __init__(self, environment):\n        self.project_name = 'name of master project'\n        self.project_version = None\n        self.environment = environment\n        self.projects = {}\n        self.targets = OrderedDict()\n        self.compilers = OrderedDict()\n        self.cross_compilers = OrderedDict()\n        self.global_args = {}\n        self.projects_args = {}\n        self.global_link_args = {}\n        self.projects_link_args = {}\n        self.tests = []\n        self.benchmarks = []\n        self.headers = []\n        self.man = []\n        self.data = []\n        self.static_linker = None\n        self.static_cross_linker = None\n        self.subprojects = {}\n        self.install_scripts = []\n        self.postconf_scripts = []\n        self.install_dirs = []\n        self.dep_manifest_name = None\n        self.dep_manifest = {}\n        self.cross_stdlibs = {}\n        self.test_setups = {}\n\n    def add_compiler(self, compiler):\n        if self.static_linker is None and compiler.needs_static_linker():\n            self.static_linker = self.environment.detect_static_linker(compiler)\n        lang = compiler.get_language()\n        if lang not in self.compilers:\n            self.compilers[lang] = compiler\n\n    def add_cross_compiler(self, compiler):\n        if not self.cross_compilers:\n            self.static_cross_linker = self.environment.detect_static_linker(compiler)\n        lang = compiler.get_language()\n        if lang not in self.cross_compilers:\n            self.cross_compilers[lang] = compiler\n\n    def get_project(self):\n        return self.projects['']\n\n    def get_targets(self):\n        return self.targets\n\n    def get_tests(self):\n        return self.tests\n\n    def get_benchmarks(self):\n        return self.benchmarks\n\n    def get_headers(self):\n        return self.headers\n\n    def get_man(self):\n        return self.man\n\n    def get_data(self):\n        return self.data\n\n    def get_install_subdirs(self):\n        return self.install_dirs\n\n    def get_global_args(self, compiler):\n        return self.global_args.get(compiler.get_language(), [])\n\n    def get_project_args(self, compiler, project):\n        args = self.projects_args.get(project)\n        if not args:\n            return []\n        return args.get(compiler.get_language(), [])\n\n    def get_global_link_args(self, compiler):\n        return self.global_link_args.get(compiler.get_language(), [])\n\n    def get_project_link_args(self, compiler, project):\n        link_args = self.projects_link_args.get(project)\n        if not link_args:\n            return []\n\n        return link_args.get(compiler.get_language(), [])\n\nclass IncludeDirs:\n    def __init__(self, curdir, dirs, is_system, extra_build_dirs=None):\n        self.curdir = curdir\n        self.incdirs = dirs\n        self.is_system = is_system\n        # Interpreter has validated that all given directories\n        # actually exist.\n        if extra_build_dirs is None:\n            self.extra_build_dirs = []\n        else:\n            self.extra_build_dirs = extra_build_dirs\n\n    def __repr__(self):\n        r = '<{} {}/{}>'\n        return r.format(self.__class__.__name__, self.curdir, self.incdirs)\n\n    def get_curdir(self):\n        return self.curdir\n\n    def get_incdirs(self):\n        return self.incdirs\n\n    def get_extra_build_dirs(self):\n        return self.extra_build_dirs\n\nclass ExtractedObjects:\n    '''\n    Holds a list of sources for which the objects must be extracted\n    '''\n    def __init__(self, target, srclist, is_unity):\n        self.target = target\n        self.srclist = srclist\n        if is_unity:\n            self.check_unity_compatible()\n\n    def __repr__(self):\n        r = '<{0} {1!r}: {2}>'\n        return r.format(self.__class__.__name__, self.target.name, self.srclist)\n\n    def check_unity_compatible(self):\n        # Figure out if the extracted object list is compatible with a Unity\n        # build. When we're doing a Unified build, we go through the sources,\n        # and create a single source file from each subset of the sources that\n        # can be compiled with a specific compiler. Then we create one object\n        # from each unified source file.\n        # If the list of sources for which we want objects is the same as the\n        # list of sources that go into each unified build, we're good.\n        srclist_set = set(self.srclist)\n        # Objects for all the sources are required, so we're compatible\n        if srclist_set == set(self.target.sources):\n            return\n        # Check if the srclist is a subset (of the target's sources) that is\n        # going to form a unified source file and a single object\n        compsrcs = classify_unity_sources(self.target.compilers.values(),\n                                          self.target.sources)\n        for srcs in compsrcs.values():\n            if srclist_set == set(srcs):\n                return\n        msg = 'Single object files can not be extracted in Unity builds. ' \\\n              'You can only extract all the object files at once.'\n        raise MesonException(msg)\n\n\nclass EnvironmentVariables:\n    def __init__(self):\n        self.envvars = []\n\n    def __repr__(self):\n        repr_str = \"<{0}: {1}>\"\n        return repr_str.format(self.__class__.__name__, self.envvars)\n\n    def get_value(self, values, kwargs):\n        separator = kwargs.get('separator', os.pathsep)\n\n        value = ''\n        for var in values:\n            value += separator + var\n        return separator, value.strip(separator)\n\n    def set(self, env, name, values, kwargs):\n        return self.get_value(values, kwargs)[1]\n\n    def append(self, env, name, values, kwargs):\n        sep, value = self.get_value(values, kwargs)\n        if name in env:\n            return env[name] + sep + value\n        return value\n\n    def prepend(self, env, name, values, kwargs):\n        sep, value = self.get_value(values, kwargs)\n        if name in env:\n            return value + sep + env[name]\n\n        return value\n\n    def get_env(self, full_env):\n        env = {}\n        for method, name, values, kwargs in self.envvars:\n            env[name] = method(full_env, name, values, kwargs)\n        return env\n\nclass Target:\n    def __init__(self, name, subdir, build_by_default):\n        if '/' in name or '\\\\' in name:\n            # Fix failing test 53 when this becomes an error.\n            mlog.warning('''Target \"%s\" has a path separator in its name.\nThis is not supported, it can cause unexpected failures and will become\na hard error in the future.''' % name)\n        self.name = name\n        self.subdir = subdir\n        self.build_by_default = build_by_default\n        self.install = False\n        self.build_always = False\n        self.option_overrides = {}\n\n    def get_basename(self):\n        return self.name\n\n    def get_subdir(self):\n        return self.subdir\n\n    def process_kwargs(self, kwargs):\n        if 'build_by_default' in kwargs:\n            self.build_by_default = kwargs['build_by_default']\n            if not isinstance(self.build_by_default, bool):\n                raise InvalidArguments('build_by_default must be a boolean value.')\n        self.option_overrides = self.parse_overrides(kwargs)\n\n    def parse_overrides(self, kwargs):\n        result = {}\n        overrides = stringlistify(kwargs.get('override_options', []))\n        for o in overrides:\n            if '=' not in o:\n                raise InvalidArguments('Overrides must be of form \"key=value\"')\n            k, v = o.split('=', 1)\n            k = k.strip()\n            v = v.strip()\n            result[k] = v\n        return result\n\n\nclass BuildTarget(Target):\n    def __init__(self, name, subdir, subproject, is_cross, sources, objects, environment, kwargs):\n        super().__init__(name, subdir, True)\n        self.subproject = subproject # Can not be calculated from subdir as subproject dirname can be changed per project.\n        self.is_cross = is_cross\n        unity_opt = environment.coredata.get_builtin_option('unity')\n        self.is_unity = unity_opt == 'on' or (unity_opt == 'subprojects' and subproject != '')\n        self.environment = environment\n        self.sources = []\n        self.compilers = OrderedDict()\n        self.objects = []\n        self.external_deps = []\n        self.include_dirs = []\n        self.link_targets = []\n        self.link_whole_targets = []\n        self.link_depends = []\n        self.name_prefix_set = False\n        self.name_suffix_set = False\n        self.filename = 'no_name'\n        # The list of all files outputted by this target. Useful in cases such\n        # as Vala which generates .vapi and .h besides the compiled output.\n        self.outputs = [self.filename]\n        self.need_install = False\n        self.pch = {}\n        self.extra_args = {}\n        self.generated = []\n        self.extra_files = []\n        # Sources can be:\n        # 1. Pre-existing source files in the source tree\n        # 2. Pre-existing sources generated by configure_file in the build tree\n        # 3. Sources files generated by another target or a Generator\n        self.process_sourcelist(sources)\n        # Objects can be:\n        # 1. Pre-existing objects provided by the user with the `objects:` kwarg\n        # 2. Compiled objects created by and extracted from another target\n        self.process_objectlist(objects)\n        self.process_kwargs(kwargs, environment)\n        self.check_unknown_kwargs(kwargs)\n        if not self.sources and not self.generated and not self.objects:\n            raise InvalidArguments('Build target %s has no sources.' % name)\n        self.process_compilers()\n        self.validate_sources()\n        self.validate_cross_install(environment)\n\n    def __lt__(self, other):\n        return self.get_id() < other.get_id()\n\n    def __repr__(self):\n        repr_str = \"<{0} {1}: {2}>\"\n        return repr_str.format(self.__class__.__name__, self.get_id(), self.filename)\n\n    def validate_cross_install(self, environment):\n        if environment.is_cross_build() and not self.is_cross and self.install:\n            raise InvalidArguments('Tried to install a natively built target in a cross build.')\n\n    def get_id(self):\n        # This ID must also be a valid file name on all OSs.\n        # It should also avoid shell metacharacters for obvious\n        # reasons.\n        base = self.name + self.type_suffix()\n        if self.subproject == '':\n            return base\n        return self.subproject + '@@' + base\n\n    def check_unknown_kwargs(self, kwargs):\n        # Override this method in derived classes that have more\n        # keywords.\n        self.check_unknown_kwargs_int(kwargs, known_basic_kwargs)\n\n    def check_unknown_kwargs_int(self, kwargs, known_kwargs):\n        unknowns = []\n        for k in kwargs:\n            if k not in known_kwargs:\n                unknowns.append(k)\n        if len(unknowns) > 0:\n            mlog.warning('Unknown keyword argument(s) in target %s: %s.' %\n                         (self.name, ', '.join(unknowns)))\n\n    def process_objectlist(self, objects):\n        assert(isinstance(objects, list))\n        for s in objects:\n            if hasattr(s, 'held_object'):\n                s = s.held_object\n            if isinstance(s, (str, File, ExtractedObjects)):\n                self.objects.append(s)\n            elif isinstance(s, (GeneratedList, CustomTarget)):\n                msg = 'Generated files are not allowed in the \\'objects\\' kwarg ' + \\\n                    'for target {!r}.\\nIt is meant only for '.format(self.name) + \\\n                    'pre-built object files that are shipped with the\\nsource ' + \\\n                    'tree. Try adding it in the list of sources.'\n                raise InvalidArguments(msg)\n            else:\n                msg = 'Bad object of type {!r} in target {!r}.'.format(type(s).__name__, self.name)\n                raise InvalidArguments(msg)\n\n    def process_sourcelist(self, sources):\n        if not isinstance(sources, list):\n            sources = [sources]\n        added_sources = {} # If the same source is defined multiple times, use it only once.\n        for s in sources:\n            # Holder unpacking. Ugly.\n            if hasattr(s, 'held_object'):\n                s = s.held_object\n            if isinstance(s, File):\n                if s not in added_sources:\n                    self.sources.append(s)\n                    added_sources[s] = True\n            elif isinstance(s, (GeneratedList, CustomTarget)):\n                self.generated.append(s)\n            else:\n                msg = 'Bad source of type {!r} in target {!r}.'.format(type(s).__name__, self.name)\n                raise InvalidArguments(msg)\n\n    @staticmethod\n    def can_compile_remove_sources(compiler, sources):\n        removed = False\n        for s in sources[:]:\n            if compiler.can_compile(s):\n                sources.remove(s)\n                removed = True\n        return removed\n\n    def process_compilers(self):\n        '''\n        Populate self.compilers, which is the list of compilers that this\n        target will use for compiling all its sources.\n        We also add compilers that were used by extracted objects to simplify\n        dynamic linker determination.\n        '''\n        if not self.sources and not self.generated and not self.objects:\n            return\n        # Populate list of compilers\n        if self.is_cross:\n            compilers = self.environment.coredata.cross_compilers\n        else:\n            compilers = self.environment.coredata.compilers\n        # Pre-existing sources\n        sources = list(self.sources)\n        # All generated sources\n        for gensrc in self.generated:\n            for s in gensrc.get_outputs():\n                # Generated objects can't be compiled, so don't use them for\n                # compiler detection. If our target only has generated objects,\n                # we will fall back to using the first c-like compiler we find,\n                # which is what we need.\n                if not is_object(s):\n                    sources.append(s)\n        # Sources that were used to create our extracted objects\n        for o in self.objects:\n            if not isinstance(o, ExtractedObjects):\n                continue\n            for s in o.srclist:\n                # Don't add Vala sources since that will pull in the Vala\n                # compiler even though we will never use it since we are\n                # dealing with compiled C code.\n                if not s.endswith(lang_suffixes['vala']):\n                    sources.append(s)\n        if sources:\n            # For each source, try to add one compiler that can compile it.\n            # It's ok if no compilers can do so, because users are expected to\n            # be able to add arbitrary non-source files to the sources list.\n            for s in sources:\n                for lang, compiler in compilers.items():\n                    if compiler.can_compile(s):\n                        if lang not in self.compilers:\n                            self.compilers[lang] = compiler\n                        break\n            # Re-sort according to clike_langs\n            self.compilers = OrderedDict(sorted(self.compilers.items(),\n                                                key=lambda t: sort_clike(t[0])))\n        else:\n            # No source files, target consists of only object files of unknown\n            # origin. Just add the first clike compiler that we have and hope\n            # that it can link these objects\n            for lang in clike_langs:\n                if lang in compilers:\n                    self.compilers[lang] = compilers[lang]\n                    break\n        # If all our sources are Vala, our target also needs the C compiler but\n        # it won't get added above.\n        if 'vala' in self.compilers and 'c' not in self.compilers:\n            self.compilers['c'] = compilers['c']\n\n    def validate_sources(self):\n        if not self.sources:\n            return\n        for lang in ('cs', 'java'):\n            if lang in self.compilers:\n                check_sources = list(self.sources)\n                compiler = self.compilers[lang]\n                if not self.can_compile_remove_sources(compiler, check_sources):\n                    m = 'No {} sources found in target {!r}'.format(lang, self.name)\n                    raise InvalidArguments(m)\n                if check_sources:\n                    m = '{0} targets can only contain {0} files:\\n'.format(lang.capitalize())\n                    m += '\\n'.join([repr(c) for c in check_sources])\n                    raise InvalidArguments(m)\n                # CSharp and Java targets can't contain any other file types\n                assert(len(self.compilers) == 1)\n                return\n\n    def process_link_depends(self, sources, environment):\n        \"\"\"Process the link_depends keyword argument.\n\n        This is designed to handle strings, Files, and the output of Custom\n        Targets. Notably it doesn't handle generator() returned objects, since\n        adding them as a link depends would inherently cause them to be\n        generated twice, since the output needs to be passed to the ld_args and\n        link_depends.\n        \"\"\"\n        if not isinstance(sources, list):\n            sources = [sources]\n        for s in sources:\n            if hasattr(s, 'held_object'):\n                s = s.held_object\n\n            if isinstance(s, File):\n                self.link_depends.append(s)\n            elif isinstance(s, str):\n                self.link_depends.append(\n                    File.from_source_file(environment.source_dir, self.subdir, s))\n            elif hasattr(s, 'get_outputs'):\n                self.link_depends.extend(\n                    [File.from_built_file(s.subdir, p) for p in s.get_outputs()])\n            else:\n                raise InvalidArguments(\n                    'Link_depends arguments must be strings, Files, '\n                    'or a Custom Target, or lists thereof.')\n\n    def get_original_kwargs(self):\n        return self.kwargs\n\n    def unpack_holder(self, d):\n        if not isinstance(d, list):\n            d = [d]\n        newd = []\n        for i in d:\n            if isinstance(i, list):\n                i = self.unpack_holder(i)\n            elif hasattr(i, 'held_object'):\n                i = i.held_object\n            for t in ['dependencies', 'link_with', 'include_directories', 'sources']:\n                if hasattr(i, t):\n                    setattr(i, t, self.unpack_holder(getattr(i, t)))\n            newd.append(i)\n        return newd\n\n    def copy_kwargs(self, kwargs):\n        self.kwargs = copy.copy(kwargs)\n        # This sucks quite badly. Arguments\n        # are holders but they can't be pickled\n        # so unpack those known.\n        for k, v in self.kwargs.items():\n            if isinstance(v, list):\n                self.kwargs[k] = self.unpack_holder(v)\n            if hasattr(v, 'held_object'):\n                self.kwargs[k] = v.held_object\n        for t in ['dependencies', 'link_with', 'include_directories', 'sources']:\n            if t in self.kwargs:\n                self.kwargs[t] = self.unpack_holder(self.kwargs[t])\n\n    def extract_objects(self, srclist):\n        obj_src = []\n        for src in srclist:\n            if not isinstance(src, str):\n                raise MesonException('Object extraction arguments must be strings.')\n            src = File(False, self.subdir, src)\n            if src not in self.sources:\n                raise MesonException('Tried to extract unknown source %s.' % src)\n            obj_src.append(src)\n        return ExtractedObjects(self, obj_src, self.is_unity)\n\n    def extract_all_objects(self):\n        return ExtractedObjects(self, self.sources, self.is_unity)\n\n    def get_all_link_deps(self):\n        return self.get_transitive_link_deps()\n\n    def get_transitive_link_deps(self):\n        result = []\n        for i in self.link_targets:\n            result += i.get_all_link_deps()\n        return result\n\n    def get_custom_install_dir(self):\n        return self.install_dir\n\n    def process_kwargs(self, kwargs, environment):\n        super().process_kwargs(kwargs)\n        self.copy_kwargs(kwargs)\n        kwargs.get('modules', [])\n        self.need_install = kwargs.get('install', self.need_install)\n        llist = kwargs.get('link_with', [])\n        if not isinstance(llist, list):\n            llist = [llist]\n        for linktarget in llist:\n            # Sorry for this hack. Keyword targets are kept in holders\n            # in kwargs. Unpack here without looking at the exact type.\n            if hasattr(linktarget, \"held_object\"):\n                linktarget = linktarget.held_object\n            self.link(linktarget)\n        lwhole = kwargs.get('link_whole', [])\n        if not isinstance(lwhole, list):\n            lwhole = [lwhole]\n        for linktarget in lwhole:\n            # Sorry for this hack. Keyword targets are kept in holders\n            # in kwargs. Unpack here without looking at the exact type.\n            if hasattr(linktarget, \"held_object\"):\n                linktarget = linktarget.held_object\n            self.link_whole(linktarget)\n        c_pchlist = kwargs.get('c_pch', [])\n        if not isinstance(c_pchlist, list):\n            c_pchlist = [c_pchlist]\n        self.add_pch('c', c_pchlist)\n        cpp_pchlist = kwargs.get('cpp_pch', [])\n        if not isinstance(cpp_pchlist, list):\n            cpp_pchlist = [cpp_pchlist]\n        self.add_pch('cpp', cpp_pchlist)\n        clist = kwargs.get('c_args', [])\n        if not isinstance(clist, list):\n            clist = [clist]\n        self.add_compiler_args('c', clist)\n        cpplist = kwargs.get('cpp_args', [])\n        if not isinstance(cpplist, list):\n            cpplist = [cpplist]\n        self.add_compiler_args('cpp', cpplist)\n        cslist = kwargs.get('cs_args', [])\n        if not isinstance(cslist, list):\n            cslist = [cslist]\n        self.add_compiler_args('cs', cslist)\n        valalist = kwargs.get('vala_args', [])\n        if not isinstance(valalist, list):\n            valalist = [valalist]\n        self.add_compiler_args('vala', valalist)\n        objclist = kwargs.get('objc_args', [])\n        if not isinstance(objclist, list):\n            objclist = [objclist]\n        self.add_compiler_args('objc', objclist)\n        objcpplist = kwargs.get('objcpp_args', [])\n        if not isinstance(objcpplist, list):\n            objcpplist = [objcpplist]\n        self.add_compiler_args('objcpp', objcpplist)\n        fortranlist = kwargs.get('fortran_args', [])\n        if not isinstance(fortranlist, list):\n            fortranlist = [fortranlist]\n        self.add_compiler_args('fortran', fortranlist)\n        rustlist = kwargs.get('rust_args', [])\n        if not isinstance(rustlist, list):\n            rustlist = [rustlist]\n        self.add_compiler_args('rust', rustlist)\n        if not isinstance(self, Executable):\n            self.vala_header = kwargs.get('vala_header', self.name + '.h')\n            self.vala_vapi = kwargs.get('vala_vapi', self.name + '.vapi')\n            self.vala_gir = kwargs.get('vala_gir', None)\n        dlist = stringlistify(kwargs.get('d_args', []))\n        self.add_compiler_args('d', dlist)\n        self.link_args = flatten(kwargs.get('link_args', []))\n        for i in self.link_args:\n            if not isinstance(i, str):\n                raise InvalidArguments('Link_args arguments must be strings.')\n        for l in self.link_args:\n            if '-Wl,-rpath' in l or l.startswith('-rpath'):\n                mlog.warning('''Please do not define rpath with a linker argument, use install_rpath or build_rpath properties instead.\nThis will become a hard error in a future Meson release.''')\n        self.process_link_depends(kwargs.get('link_depends', []), environment)\n        # Target-specific include dirs must be added BEFORE include dirs from\n        # internal deps (added inside self.add_deps()) to override them.\n        inclist = kwargs.get('include_directories', [])\n        if not isinstance(inclist, list):\n            inclist = [inclist]\n        self.add_include_dirs(inclist)\n        # Add dependencies (which also have include_directories)\n        deplist = kwargs.get('dependencies', [])\n        if not isinstance(deplist, list):\n            deplist = [deplist]\n        self.add_deps(deplist)\n        # If an item in this list is False, the output corresponding to\n        # the list index of that item will not be installed\n        self.install_dir = typeslistify(kwargs.get('install_dir', [None]),\n                                        (str, bool))\n        main_class = kwargs.get('main_class', '')\n        if not isinstance(main_class, str):\n            raise InvalidArguments('Main class must be a string')\n        self.main_class = main_class\n        if isinstance(self, Executable):\n            self.gui_app = kwargs.get('gui_app', False)\n            if not isinstance(self.gui_app, bool):\n                raise InvalidArguments('Argument gui_app must be boolean.')\n        elif 'gui_app' in kwargs:\n            raise InvalidArguments('Argument gui_app can only be used on executables.')\n        extra_files = kwargs.get('extra_files', [])\n        if not isinstance(extra_files, list):\n            extra_files = [extra_files]\n        for i in extra_files:\n            assert(isinstance(i, File))\n            trial = os.path.join(environment.get_source_dir(), i.subdir, i.fname)\n            if not(os.path.isfile(trial)):\n                raise InvalidArguments('Tried to add non-existing extra file %s.' % i)\n        self.extra_files = extra_files\n        self.install_rpath = kwargs.get('install_rpath', '')\n        if not isinstance(self.install_rpath, str):\n            raise InvalidArguments('Install_rpath is not a string.')\n        self.build_rpath = kwargs.get('build_rpath', '')\n        if not isinstance(self.build_rpath, str):\n            raise InvalidArguments('Build_rpath is not a string.')\n        resources = kwargs.get('resources', [])\n        if not isinstance(resources, list):\n            resources = [resources]\n        for r in resources:\n            if not isinstance(r, str):\n                raise InvalidArguments('Resource argument is not a string.')\n            trial = os.path.join(environment.get_source_dir(), self.subdir, r)\n            if not os.path.isfile(trial):\n                raise InvalidArguments('Tried to add non-existing resource %s.' % r)\n        self.resources = resources\n        if 'name_prefix' in kwargs:\n            name_prefix = kwargs['name_prefix']\n            if isinstance(name_prefix, list):\n                if name_prefix:\n                    raise InvalidArguments('name_prefix array must be empty to signify null.')\n            elif not isinstance(name_prefix, str):\n                raise InvalidArguments('name_prefix must be a string.')\n            self.prefix = name_prefix\n            self.name_prefix_set = True\n        if 'name_suffix' in kwargs:\n            name_suffix = kwargs['name_suffix']\n            if isinstance(name_suffix, list):\n                if name_suffix:\n                    raise InvalidArguments('name_suffix array must be empty to signify null.')\n            else:\n                if not isinstance(name_suffix, str):\n                    raise InvalidArguments('name_suffix must be a string.')\n                self.suffix = name_suffix\n                self.name_suffix_set = True\n        if isinstance(self, StaticLibrary):\n            # You can't disable PIC on OS X. The compiler ignores -fno-PIC.\n            # PIC is always on for Windows (all code is position-independent\n            # since library loading is done differently)\n            if for_darwin(self.is_cross, self.environment) or for_windows(self.is_cross, self.environment):\n                self.pic = True\n            elif '-fPIC' in clist + cpplist:\n                mlog.warning(\"Use the 'pic' kwarg instead of passing -fPIC manually to static library {!r}\".format(self.name))\n                self.pic = True\n            else:\n                self.pic = kwargs.get('pic', False)\n                if not isinstance(self.pic, bool):\n                    raise InvalidArguments('Argument pic to static library {!r} must be boolean'.format(self.name))\n        self.implicit_include_directories = kwargs.get('implicit_include_directories', True)\n        if not isinstance(self.implicit_include_directories, bool):\n            raise InvalidArguments('Implicit_include_directories must be a boolean.')\n\n    def get_filename(self):\n        return self.filename\n\n    def get_outputs(self):\n        return self.outputs\n\n    def get_extra_args(self, language):\n        return self.extra_args.get(language, [])\n\n    def get_dependencies(self):\n        transitive_deps = []\n        for t in self.link_targets + self.link_whole_targets:\n            transitive_deps.append(t)\n            if isinstance(t, StaticLibrary):\n                transitive_deps += t.get_dependencies()\n        return transitive_deps\n\n    def get_source_subdir(self):\n        return self.subdir\n\n    def get_sources(self):\n        return self.sources\n\n    def get_objects(self):\n        return self.objects\n\n    def get_generated_sources(self):\n        return self.generated\n\n    def should_install(self):\n        return self.need_install\n\n    def has_pch(self):\n        return len(self.pch) > 0\n\n    def get_pch(self, language):\n        try:\n            return self.pch[language]\n        except KeyError:\n            return[]\n\n    def get_include_dirs(self):\n        return self.include_dirs\n\n    def add_deps(self, deps):\n        if not isinstance(deps, list):\n            deps = [deps]\n        for dep in deps:\n            if hasattr(dep, 'held_object'):\n                dep = dep.held_object\n            if isinstance(dep, dependencies.InternalDependency):\n                # Those parts that are internal.\n                self.process_sourcelist(dep.sources)\n                self.add_include_dirs(dep.include_directories)\n                for l in dep.libraries:\n                    self.link(l)\n                # Those parts that are external.\n                extpart = dependencies.InternalDependency('undefined',\n                                                          [],\n                                                          dep.compile_args,\n                                                          dep.link_args,\n                                                          [], [], [])\n                self.external_deps.append(extpart)\n                # Deps of deps.\n                self.add_deps(dep.ext_deps)\n            elif isinstance(dep, dependencies.ExternalDependency):\n                self.external_deps.append(dep)\n                self.process_sourcelist(dep.get_sources())\n            elif isinstance(dep, BuildTarget):\n                raise InvalidArguments('''Tried to use a build target as a dependency.\nYou probably should put it in link_with instead.''')\n            else:\n                # This is a bit of a hack. We do not want Build to know anything\n                # about the interpreter so we can't import it and use isinstance.\n                # This should be reliable enough.\n                if hasattr(dep, 'project_args_frozen') or hasattr(dep, 'global_args_frozen'):\n                    raise InvalidArguments('Tried to use subproject object as a dependency.\\n'\n                                           'You probably wanted to use a dependency declared in it instead.\\n'\n                                           'Access it by calling get_variable() on the subproject object.')\n                raise InvalidArguments('Argument is of an unacceptable type {!r}.\\nMust be '\n                                       'either an external dependency (returned by find_library() or '\n                                       'dependency()) or an internal dependency (returned by '\n                                       'declare_dependency()).'.format(type(dep).__name__))\n\n    def get_external_deps(self):\n        return self.external_deps\n\n    def link(self, target):\n        for t in flatten(target):\n            if hasattr(t, 'held_object'):\n                t = t.held_object\n            if not t.is_linkable_target():\n                raise InvalidArguments('Link target {!r} is not linkable.'.format(t))\n            if isinstance(self, SharedLibrary) and isinstance(t, StaticLibrary) and not t.pic:\n                msg = \"Can't link non-PIC static library {!r} into shared library {!r}. \".format(t.name, self.name)\n                msg += \"Use the 'pic' option to static_library to build with PIC.\"\n                raise InvalidArguments(msg)\n            if self.is_cross != t.is_cross:\n                raise InvalidArguments('Tried to mix cross built and native libraries in target {!r}'.format(self.name))\n            self.link_targets.append(t)\n\n    def link_whole(self, target):\n        for t in flatten(target):\n            if hasattr(t, 'held_object'):\n                t = t.held_object\n            if not isinstance(t, StaticLibrary):\n                raise InvalidArguments('{!r} is not a static library.'.format(t))\n            if isinstance(self, SharedLibrary) and not t.pic:\n                msg = \"Can't link non-PIC static library {!r} into shared library {!r}. \".format(t.name, self.name)\n                msg += \"Use the 'pic' option to static_library to build with PIC.\"\n                raise InvalidArguments(msg)\n            if self.is_cross != t.is_cross:\n                raise InvalidArguments('Tried to mix cross built and native libraries in target {!r}'.format(self.name))\n            self.link_whole_targets.append(t)\n\n    def add_pch(self, language, pchlist):\n        if not pchlist:\n            return\n        elif len(pchlist) == 1:\n            if not environment.is_header(pchlist[0]):\n                raise InvalidArguments('PCH argument %s is not a header.' % pchlist[0])\n        elif len(pchlist) == 2:\n            if environment.is_header(pchlist[0]):\n                if not environment.is_source(pchlist[1]):\n                    raise InvalidArguments('PCH definition must contain one header and at most one source.')\n            elif environment.is_source(pchlist[0]):\n                if not environment.is_header(pchlist[1]):\n                    raise InvalidArguments('PCH definition must contain one header and at most one source.')\n                pchlist = [pchlist[1], pchlist[0]]\n            else:\n                raise InvalidArguments('PCH argument %s is of unknown type.' % pchlist[0])\n        elif len(pchlist) > 2:\n            raise InvalidArguments('PCH definition may have a maximum of 2 files.')\n        self.pch[language] = pchlist\n\n    def add_include_dirs(self, args):\n        ids = []\n        for a in args:\n            # FIXME same hack, forcibly unpack from holder.\n            if hasattr(a, 'held_object'):\n                a = a.held_object\n            if not isinstance(a, IncludeDirs):\n                raise InvalidArguments('Include directory to be added is not an include directory object.')\n            ids.append(a)\n        self.include_dirs += ids\n\n    def add_compiler_args(self, language, args):\n        args = flatten(args)\n        for a in args:\n            if not isinstance(a, (str, File)):\n                raise InvalidArguments('A non-string passed to compiler args.')\n        if language in self.extra_args:\n            self.extra_args[language] += args\n        else:\n            self.extra_args[language] = args\n\n    def get_aliases(self):\n        return {}\n\n    def get_langs_used_by_deps(self):\n        '''\n        Sometimes you want to link to a C++ library that exports C API, which\n        means the linker must link in the C++ stdlib, and we must use a C++\n        compiler for linking. The same is also applicable for objc/objc++, etc,\n        so we can keep using clike_langs for the priority order.\n\n        See: https://github.com/mesonbuild/meson/issues/1653\n        '''\n        langs = []\n        # Check if any of the external libraries were written in this language\n        for dep in self.external_deps:\n            if dep.language not in langs:\n                langs.append(dep.language)\n        # Check if any of the internal libraries this target links to were\n        # written in this language\n        for link_target in itertools.chain(self.link_targets, self.link_whole_targets):\n            for language in link_target.compilers:\n                if language not in langs:\n                    langs.append(language)\n        return langs\n\n    def get_clike_dynamic_linker(self):\n        '''\n        We use the order of languages in `clike_langs` to determine which\n        linker to use in case the target has sources compiled with multiple\n        compilers. All languages other than those in this list have their own\n        linker.\n        Note that Vala outputs C code, so Vala sources can use any linker\n        that can link compiled C. We don't actually need to add an exception\n        for Vala here because of that.\n        '''\n        # Populate list of all compilers, not just those being used to compile\n        # sources in this target\n        if self.is_cross:\n            all_compilers = self.environment.coredata.cross_compilers\n        else:\n            all_compilers = self.environment.coredata.compilers\n        # Languages used by dependencies\n        dep_langs = self.get_langs_used_by_deps()\n        # Pick a compiler based on the language priority-order\n        for l in clike_langs:\n            if l in self.compilers or l in dep_langs:\n                try:\n                    return all_compilers[l]\n                except KeyError:\n                    raise MesonException(\n                        'Could not get a dynamic linker for build target {!r}. '\n                        'Requires a linker for language \"{}\", but that is not '\n                        'a project language.'.format(self.name, l))\n\n        m = 'Could not get a dynamic linker for build target {!r}'\n        raise AssertionError(m.format(self.name))\n\n    def get_using_msvc(self):\n        '''\n        Check if the dynamic linker is MSVC. Used by Executable, StaticLibrary,\n        and SharedLibrary for deciding when to use MSVC-specific file naming\n        and debug filenames.\n\n        If at least some code is built with MSVC and the final library is\n        linked with MSVC, we can be sure that some debug info will be\n        generated. We only check the dynamic linker here because the static\n        linker is guaranteed to be of the same type.\n\n        Interesting cases:\n        1. The Vala compiler outputs C code to be compiled by whatever\n           C compiler we're using, so all objects will still be created by the\n           MSVC compiler.\n        2. If the target contains only objects, process_compilers guesses and\n           picks the first compiler that smells right.\n        '''\n        linker = self.get_clike_dynamic_linker()\n        if linker and linker.get_id() == 'msvc':\n            return True\n        return False\n\n    def is_linkable_target(self):\n        return False\n\n\nclass Generator:\n    def __init__(self, args, kwargs):\n        if len(args) != 1:\n            raise InvalidArguments('Generator requires exactly one positional argument: the executable')\n        exe = args[0]\n        if hasattr(exe, 'held_object'):\n            exe = exe.held_object\n        if not isinstance(exe, (Executable, dependencies.ExternalProgram)):\n            raise InvalidArguments('First generator argument must be an executable.')\n        self.exe = exe\n        self.depfile = None\n        self.process_kwargs(kwargs)\n\n    def __repr__(self):\n        repr_str = \"<{0}: {1}>\"\n        return repr_str.format(self.__class__.__name__, self.exe)\n\n    def get_exe(self):\n        return self.exe\n\n    def process_kwargs(self, kwargs):\n        if 'arguments' not in kwargs:\n            raise InvalidArguments('Generator must have \"arguments\" keyword argument.')\n        args = kwargs['arguments']\n        if isinstance(args, str):\n            args = [args]\n        if not isinstance(args, list):\n            raise InvalidArguments('\"Arguments\" keyword argument must be a string or a list of strings.')\n        for a in args:\n            if not isinstance(a, str):\n                raise InvalidArguments('A non-string object in \"arguments\" keyword argument.')\n        self.arglist = args\n        if 'output' not in kwargs:\n            raise InvalidArguments('Generator must have \"output\" keyword argument.')\n        outputs = kwargs['output']\n        if not isinstance(outputs, list):\n            outputs = [outputs]\n        for rule in outputs:\n            if not isinstance(rule, str):\n                raise InvalidArguments('\"output\" may only contain strings.')\n            if '@BASENAME@' not in rule and '@PLAINNAME@' not in rule:\n                raise InvalidArguments('Every element of \"output\" must contain @BASENAME@ or @PLAINNAME@.')\n            if '/' in rule or '\\\\' in rule:\n                raise InvalidArguments('\"outputs\" must not contain a directory separator.')\n        if len(outputs) > 1:\n            for o in outputs:\n                if '@OUTPUT@' in o:\n                    raise InvalidArguments('Tried to use @OUTPUT@ in a rule with more than one output.')\n        self.outputs = outputs\n        if 'depfile' in kwargs:\n            depfile = kwargs['depfile']\n            if not isinstance(depfile, str):\n                raise InvalidArguments('Depfile must be a string.')\n            if os.path.split(depfile)[1] != depfile:\n                raise InvalidArguments('Depfile must be a plain filename without a subdirectory.')\n            self.depfile = depfile\n\n    def get_base_outnames(self, inname):\n        plainname = os.path.split(inname)[1]\n        basename = os.path.splitext(plainname)[0]\n        return [x.replace('@BASENAME@', basename).replace('@PLAINNAME@', plainname) for x in self.outputs]\n\n    def get_dep_outname(self, inname):\n        if self.depfile is None:\n            raise InvalidArguments('Tried to get dep name for rule that does not have dependency file defined.')\n        plainname = os.path.split(inname)[1]\n        basename = os.path.splitext(plainname)[0]\n        return self.depfile.replace('@BASENAME@', basename).replace('@PLAINNAME@', plainname)\n\n    def get_arglist(self):\n        return self.arglist\n\n    def process_files(self, name, files, state, extra_args=[]):\n        output = GeneratedList(self, extra_args=extra_args)\n        for f in files:\n            if isinstance(f, str):\n                f = File.from_source_file(state.environment.source_dir, state.subdir, f)\n            elif not isinstance(f, File):\n                raise InvalidArguments('{} arguments must be strings or files not {!r}.'.format(name, f))\n            output.add_file(f)\n        return output\n\n\nclass GeneratedList:\n    def __init__(self, generator, extra_args=[]):\n        if hasattr(generator, 'held_object'):\n            generator = generator.held_object\n        self.generator = generator\n        self.name = self.generator.exe\n        self.infilelist = []\n        self.outfilelist = []\n        self.outmap = {}\n        self.extra_depends = []\n        self.extra_args = extra_args\n\n    def add_file(self, newfile):\n        self.infilelist.append(newfile)\n        outfiles = self.generator.get_base_outnames(newfile.fname)\n        self.outfilelist += outfiles\n        self.outmap[newfile] = outfiles\n\n    def get_inputs(self):\n        return self.infilelist\n\n    def get_outputs(self):\n        return self.outfilelist\n\n    def get_outputs_for(self, filename):\n        return self.outmap[filename]\n\n    def get_generator(self):\n        return self.generator\n\n    def get_extra_args(self):\n        return self.extra_args\n\nclass Executable(BuildTarget):\n    def __init__(self, name, subdir, subproject, is_cross, sources, objects, environment, kwargs):\n        super().__init__(name, subdir, subproject, is_cross, sources, objects, environment, kwargs)\n        # Unless overriden, executables have no suffix or prefix. Except on\n        # Windows and with C#/Mono executables where the suffix is 'exe'\n        if not hasattr(self, 'prefix'):\n            self.prefix = ''\n        if not hasattr(self, 'suffix'):\n            # Executable for Windows or C#/Mono\n            if (for_windows(is_cross, environment) or\n                    for_cygwin(is_cross, environment) or 'cs' in self.compilers):\n                self.suffix = 'exe'\n            else:\n                self.suffix = ''\n        self.filename = self.name\n        if self.suffix:\n            self.filename += '.' + self.suffix\n        self.outputs = [self.filename]\n\n        # The import library this target will generate\n        self.import_filename = None\n        # The import library that Visual Studio would generate (and accept)\n        self.vs_import_filename = None\n        # The import library that GCC would generate (and prefer)\n        self.gcc_import_filename = None\n\n        # if implib appears, this target is linkwith:-able, but that only means\n        # something on Windows platforms.\n        self.is_linkwithable = False\n        if 'implib' in kwargs and kwargs['implib']:\n            implib_basename = self.name + '.exe'\n            if not isinstance(kwargs['implib'], bool):\n                implib_basename = kwargs['implib']\n            self.is_linkwithable = True\n            if for_windows(is_cross, environment) or for_cygwin(is_cross, environment):\n                self.vs_import_filename = '{0}.lib'.format(implib_basename)\n                self.gcc_import_filename = 'lib{0}.a'.format(implib_basename)\n\n                if self.get_using_msvc():\n                    self.import_filename = self.vs_import_filename\n                else:\n                    self.import_filename = self.gcc_import_filename\n\n    def type_suffix(self):\n        return \"@exe\"\n\n    def check_unknown_kwargs(self, kwargs):\n        self.check_unknown_kwargs_int(kwargs, known_exe_kwargs)\n\n    def get_import_filename(self):\n        \"\"\"\n        The name of the import library that will be outputted by the compiler\n\n        Returns None if there is no import library required for this platform\n        \"\"\"\n        return self.import_filename\n\n    def get_import_filenameslist(self):\n        if self.import_filename:\n            return [self.vs_import_filename, self.gcc_import_filename]\n        return []\n\n    def is_linkable_target(self):\n        return self.is_linkwithable\n\nclass StaticLibrary(BuildTarget):\n    def __init__(self, name, subdir, subproject, is_cross, sources, objects, environment, kwargs):\n        if 'pic' not in kwargs and 'b_staticpic' in environment.coredata.base_options:\n            kwargs['pic'] = environment.coredata.base_options['b_staticpic'].value\n        super().__init__(name, subdir, subproject, is_cross, sources, objects, environment, kwargs)\n        if 'cs' in self.compilers:\n            raise InvalidArguments('Static libraries not supported for C#.')\n        if 'rust' in self.compilers:\n            # If no crate type is specified, or it's the generic lib type, use rlib\n            if not hasattr(self, 'rust_crate_type') or self.rust_crate_type == 'lib':\n                mlog.debug('Defaulting Rust static library target crate type to rlib')\n                self.rust_crate_type = 'rlib'\n            # Don't let configuration proceed with a non-static crate type\n            elif self.rust_crate_type not in ['rlib', 'staticlib']:\n                raise InvalidArguments('Crate type \"{0}\" invalid for static libraries; must be \"rlib\" or \"staticlib\"'.format(self.rust_crate_type))\n        # By default a static library is named libfoo.a even on Windows because\n        # MSVC does not have a consistent convention for what static libraries\n        # are called. The MSVC CRT uses libfoo.lib syntax but nothing else uses\n        # it and GCC only looks for static libraries called foo.lib and\n        # libfoo.a. However, we cannot use foo.lib because that's the same as\n        # the import library. Using libfoo.a is ok because people using MSVC\n        # always pass the library filename while linking anyway.\n        if not hasattr(self, 'prefix'):\n            self.prefix = 'lib'\n        if not hasattr(self, 'suffix'):\n            if 'rust' in self.compilers:\n                if not hasattr(self, 'rust_crate_type') or self.rust_crate_type == 'rlib':\n                    # default Rust static library suffix\n                    self.suffix = 'rlib'\n                elif self.rust_crate_type == 'staticlib':\n                    self.suffix = 'a'\n            else:\n                self.suffix = 'a'\n        self.filename = self.prefix + self.name + '.' + self.suffix\n        self.outputs = [self.filename]\n\n    def type_suffix(self):\n        return \"@sta\"\n\n    def check_unknown_kwargs(self, kwargs):\n        self.check_unknown_kwargs_int(kwargs, known_lib_kwargs)\n\n    def process_kwargs(self, kwargs, environment):\n        super().process_kwargs(kwargs, environment)\n        if 'rust_crate_type' in kwargs:\n            rust_crate_type = kwargs['rust_crate_type']\n            if isinstance(rust_crate_type, str):\n                self.rust_crate_type = rust_crate_type\n            else:\n                raise InvalidArguments('Invalid rust_crate_type \"{0}\": must be a string.'.format(rust_crate_type))\n\n    def is_linkable_target(self):\n        return True\n\nclass SharedLibrary(BuildTarget):\n    def __init__(self, name, subdir, subproject, is_cross, sources, objects, environment, kwargs):\n        self.soversion = None\n        self.ltversion = None\n        self.vs_module_defs = None\n        # The import library this target will generate\n        self.import_filename = None\n        # The import library that Visual Studio would generate (and accept)\n        self.vs_import_filename = None\n        # The import library that GCC would generate (and prefer)\n        self.gcc_import_filename = None\n        super().__init__(name, subdir, subproject, is_cross, sources, objects, environment, kwargs)\n        if 'rust' in self.compilers:\n            # If no crate type is specified, or it's the generic lib type, use dylib\n            if not hasattr(self, 'rust_crate_type') or self.rust_crate_type == 'lib':\n                mlog.debug('Defaulting Rust dynamic library target crate type to \"dylib\"')\n                self.rust_crate_type = 'dylib'\n            # Don't let configuration proceed with a non-dynamic crate type\n            elif self.rust_crate_type not in ['dylib', 'cdylib']:\n                raise InvalidArguments('Crate type \"{0}\" invalid for dynamic libraries; must be \"dylib\" or \"cdylib\"'.format(self.rust_crate_type))\n        if not hasattr(self, 'prefix'):\n            self.prefix = None\n        if not hasattr(self, 'suffix'):\n            self.suffix = None\n        self.basic_filename_tpl = '{0.prefix}{0.name}.{0.suffix}'\n        self.determine_filenames(is_cross, environment)\n\n    def determine_filenames(self, is_cross, env):\n        \"\"\"\n        See https://github.com/mesonbuild/meson/pull/417 for details.\n\n        First we determine the filename template (self.filename_tpl), then we\n        set the output filename (self.filename).\n\n        The template is needed while creating aliases (self.get_aliases),\n        which are needed while generating .so shared libraries for Linux.\n\n        Besides this, there's also the import library name, which is only used\n        on Windows since on that platform the linker uses a separate library\n        called the \"import library\" during linking instead of the shared\n        library (DLL). The toolchain will output an import library in one of\n        two formats: GCC or Visual Studio.\n\n        When we're building with Visual Studio, the import library that will be\n        generated by the toolchain is self.vs_import_filename, and with\n        MinGW/GCC, it's self.gcc_import_filename. self.import_filename will\n        always contain the import library name this target will generate.\n        \"\"\"\n        prefix = ''\n        suffix = ''\n        self.filename_tpl = self.basic_filename_tpl\n        # If the user already provided the prefix and suffix to us, we don't\n        # need to do any filename suffix/prefix detection.\n        # NOTE: manual prefix/suffix override is currently only tested for C/C++\n        if self.prefix is not None and self.suffix is not None:\n            pass\n        # C# and Mono\n        elif 'cs' in self.compilers:\n            prefix = ''\n            suffix = 'dll'\n            self.filename_tpl = '{0.prefix}{0.name}.{0.suffix}'\n        # C, C++, Swift, Vala\n        # Only Windows uses a separate import library for linking\n        # For all other targets/platforms import_filename stays None\n        elif for_windows(is_cross, env):\n            suffix = 'dll'\n            self.vs_import_filename = '{0}.lib'.format(self.name)\n            self.gcc_import_filename = 'lib{0}.dll.a'.format(self.name)\n            if self.get_using_msvc():\n                # Shared library is of the form foo.dll\n                prefix = ''\n                # Import library is called foo.lib\n                self.import_filename = self.vs_import_filename\n            # Assume GCC-compatible naming\n            else:\n                # Shared library is of the form libfoo.dll\n                prefix = 'lib'\n                # Import library is called libfoo.dll.a\n                self.import_filename = self.gcc_import_filename\n            # Shared library has the soversion if it is defined\n            if self.soversion:\n                self.filename_tpl = '{0.prefix}{0.name}-{0.soversion}.{0.suffix}'\n            else:\n                self.filename_tpl = '{0.prefix}{0.name}.{0.suffix}'\n        elif for_cygwin(is_cross, env):\n            suffix = 'dll'\n            self.gcc_import_filename = 'lib{0}.dll.a'.format(self.name)\n            # Shared library is of the form cygfoo.dll\n            # (ld --dll-search-prefix=cyg is the default)\n            prefix = 'cyg'\n            # Import library is called libfoo.dll.a\n            self.import_filename = self.gcc_import_filename\n            if self.soversion:\n                self.filename_tpl = '{0.prefix}{0.name}-{0.soversion}.{0.suffix}'\n            else:\n                self.filename_tpl = '{0.prefix}{0.name}.{0.suffix}'\n        elif for_darwin(is_cross, env):\n            prefix = 'lib'\n            suffix = 'dylib'\n            # On macOS, the filename can only contain the major version\n            if self.soversion:\n                # libfoo.X.dylib\n                self.filename_tpl = '{0.prefix}{0.name}.{0.soversion}.{0.suffix}'\n            else:\n                # libfoo.dylib\n                self.filename_tpl = '{0.prefix}{0.name}.{0.suffix}'\n        else:\n            prefix = 'lib'\n            suffix = 'so'\n            if self.ltversion:\n                # libfoo.so.X[.Y[.Z]] (.Y and .Z are optional)\n                self.filename_tpl = '{0.prefix}{0.name}.{0.suffix}.{0.ltversion}'\n            elif self.soversion:\n                # libfoo.so.X\n                self.filename_tpl = '{0.prefix}{0.name}.{0.suffix}.{0.soversion}'\n            else:\n                # No versioning, libfoo.so\n                self.filename_tpl = '{0.prefix}{0.name}.{0.suffix}'\n        if self.prefix is None:\n            self.prefix = prefix\n        if self.suffix is None:\n            self.suffix = suffix\n        self.filename = self.filename_tpl.format(self)\n        self.outputs = [self.filename]\n\n    def process_kwargs(self, kwargs, environment):\n        super().process_kwargs(kwargs, environment)\n        # Shared library version\n        if 'version' in kwargs:\n            self.ltversion = kwargs['version']\n            if not isinstance(self.ltversion, str):\n                raise InvalidArguments('Shared library version needs to be a string, not ' + type(self.ltversion).__name__)\n            if not re.fullmatch(r'[0-9]+(\\.[0-9]+){0,2}', self.ltversion):\n                raise InvalidArguments('Invalid Shared library version \"{0}\". Must be of the form X.Y.Z where all three are numbers. Y and Z are optional.'.format(self.ltversion))\n        # Try to extract/deduce the soversion\n        if 'soversion' in kwargs:\n            self.soversion = kwargs['soversion']\n            if isinstance(self.soversion, int):\n                self.soversion = str(self.soversion)\n            if not isinstance(self.soversion, str):\n                raise InvalidArguments('Shared library soversion is not a string or integer.')\n        elif self.ltversion:\n            # library version is defined, get the soversion from that\n            # We replicate what Autotools does here and take the first\n            # number of the version by default.\n            self.soversion = self.ltversion.split('.')[0]\n        # Visual Studio module-definitions file\n        if 'vs_module_defs' in kwargs:\n            path = kwargs['vs_module_defs']\n            if hasattr(path, 'held_object'):\n                path = path.held_object\n            if isinstance(path, str):\n                if os.path.isabs(path):\n                    self.vs_module_defs = File.from_absolute_file(path)\n                else:\n                    self.vs_module_defs = File.from_source_file(environment.source_dir, self.subdir, path)\n                self.link_depends.append(self.vs_module_defs)\n            elif isinstance(path, File):\n                # When passing a generated file.\n                self.vs_module_defs = path\n                self.link_depends.append(path)\n            elif hasattr(path, 'get_filename'):\n                # When passing output of a Custom Target\n                path = File.from_built_file(path.subdir, path.get_filename())\n                self.vs_module_defs = path\n                self.link_depends.append(path)\n            else:\n                raise InvalidArguments(\n                    'Shared library vs_module_defs must be either a string, '\n                    'a file object or a Custom Target')\n        if 'rust_crate_type' in kwargs:\n            rust_crate_type = kwargs['rust_crate_type']\n            if isinstance(rust_crate_type, str):\n                self.rust_crate_type = rust_crate_type\n            else:\n                raise InvalidArguments('Invalid rust_crate_type \"{0}\": must be a string.'.format(rust_crate_type))\n\n    def check_unknown_kwargs(self, kwargs):\n        self.check_unknown_kwargs_int(kwargs, known_lib_kwargs)\n\n    def get_import_filename(self):\n        \"\"\"\n        The name of the import library that will be outputted by the compiler\n\n        Returns None if there is no import library required for this platform\n        \"\"\"\n        return self.import_filename\n\n    def get_import_filenameslist(self):\n        if self.import_filename:\n            return [self.vs_import_filename, self.gcc_import_filename]\n        return []\n\n    def get_all_link_deps(self):\n        return [self] + self.get_transitive_link_deps()\n\n    def get_aliases(self):\n        \"\"\"\n        If the versioned library name is libfoo.so.0.100.0, aliases are:\n        * libfoo.so.0 (soversion) -> libfoo.so.0.100.0\n        * libfoo.so (unversioned; for linking) -> libfoo.so.0\n        Same for dylib:\n        * libfoo.dylib (unversioned; for linking) -> libfoo.0.dylib\n        \"\"\"\n        aliases = {}\n        # Aliases are only useful with .so and .dylib libraries. Also if\n        # there's no self.soversion (no versioning), we don't need aliases.\n        if self.suffix not in ('so', 'dylib') or not self.soversion:\n            return {}\n        # With .so libraries, the minor and micro versions are also in the\n        # filename. If ltversion != soversion we create an soversion alias:\n        # libfoo.so.0 -> libfoo.so.0.100.0\n        # Where libfoo.so.0.100.0 is the actual library\n        if self.suffix == 'so' and self.ltversion and self.ltversion != self.soversion:\n            alias_tpl = self.filename_tpl.replace('ltversion', 'soversion')\n            ltversion_filename = alias_tpl.format(self)\n            aliases[ltversion_filename] = self.filename\n        # libfoo.so.0/libfoo.0.dylib is the actual library\n        else:\n            ltversion_filename = self.filename\n        # Unversioned alias:\n        #  libfoo.so -> libfoo.so.0\n        #  libfoo.dylib -> libfoo.0.dylib\n        aliases[self.basic_filename_tpl.format(self)] = ltversion_filename\n        return aliases\n\n    def type_suffix(self):\n        return \"@sha\"\n\n    def is_linkable_target(self):\n        return True\n\n# A shared library that is meant to be used with dlopen rather than linking\n# into something else.\nclass SharedModule(SharedLibrary):\n    def __init__(self, name, subdir, subproject, is_cross, sources, objects, environment, kwargs):\n        if 'version' in kwargs:\n            raise MesonException('Shared modules must not specify the version kwarg.')\n        if 'soversion' in kwargs:\n            raise MesonException('Shared modules must not specify the soversion kwarg.')\n        super().__init__(name, subdir, subproject, is_cross, sources, objects, environment, kwargs)\n        self.import_filename = None\n\nclass CustomTarget(Target):\n    known_kwargs = {'input': True,\n                    'output': True,\n                    'command': True,\n                    'capture': False,\n                    'install': True,\n                    'install_dir': True,\n                    'build_always': True,\n                    'depends': True,\n                    'depend_files': True,\n                    'depfile': True,\n                    'build_by_default': True,\n                    'override_options': True,\n                    }\n\n    def __init__(self, name, subdir, kwargs, absolute_paths=False):\n        super().__init__(name, subdir, False)\n        self.dependencies = []\n        self.extra_depends = []\n        self.depend_files = [] # Files that this target depends on but are not on the command line.\n        self.depfile = None\n        self.process_kwargs(kwargs)\n        self.extra_files = []\n        # Whether to use absolute paths for all files on the commandline\n        self.absolute_paths = absolute_paths\n        unknowns = []\n        for k in kwargs:\n            if k not in CustomTarget.known_kwargs:\n                unknowns.append(k)\n        if len(unknowns) > 0:\n            mlog.warning('Unknown keyword arguments in target %s: %s' %\n                         (self.name, ', '.join(unknowns)))\n\n    def __lt__(self, other):\n        return self.get_id() < other.get_id()\n\n    def __repr__(self):\n        repr_str = \"<{0} {1}: {2}>\"\n        return repr_str.format(self.__class__.__name__, self.get_id(), self.command)\n\n    def get_id(self):\n        return self.name + self.type_suffix()\n\n    def get_target_dependencies(self):\n        deps = self.dependencies[:]\n        deps += self.extra_depends\n        for c in self.sources:\n            if hasattr(c, 'held_object'):\n                c = c.held_object\n            if isinstance(c, (BuildTarget, CustomTarget)):\n                deps.append(c)\n        return deps\n\n    def flatten_command(self, cmd):\n        if not isinstance(cmd, list):\n            cmd = [cmd]\n        final_cmd = []\n        for c in cmd:\n            if hasattr(c, 'held_object'):\n                c = c.held_object\n            if isinstance(c, str):\n                final_cmd.append(c)\n            elif isinstance(c, File):\n                self.depend_files.append(c)\n                final_cmd.append(c)\n            elif isinstance(c, dependencies.ExternalProgram):\n                if not c.found():\n                    m = 'Tried to use not-found external program {!r} in \"command\"'\n                    raise InvalidArguments(m.format(c.name))\n                self.depend_files.append(File.from_absolute_file(c.get_path()))\n                final_cmd += c.get_command()\n            elif isinstance(c, (BuildTarget, CustomTarget)):\n                self.dependencies.append(c)\n                final_cmd.append(c)\n            elif isinstance(c, list):\n                final_cmd += self.flatten_command(c)\n            else:\n                raise InvalidArguments('Argument {!r} in \"command\" is invalid'.format(c))\n        return final_cmd\n\n    def process_kwargs(self, kwargs):\n        super().process_kwargs(kwargs)\n        sources = flatten(kwargs.get('input', []))\n        self.sources = []\n        for s in sources:\n            if hasattr(s, 'held_object'):\n                s = s.held_object\n            self.sources.append(s)\n        if 'output' not in kwargs:\n            raise InvalidArguments('Missing keyword argument \"output\".')\n        self.outputs = kwargs['output']\n        if not isinstance(self.outputs, list):\n            self.outputs = [self.outputs]\n        # This will substitute values from the input into output and return it.\n        inputs = get_sources_string_names(self.sources)\n        values = get_filenames_templates_dict(inputs, [])\n        for i in self.outputs:\n            if not(isinstance(i, str)):\n                raise InvalidArguments('Output argument not a string.')\n            if '/' in i:\n                raise InvalidArguments('Output must not contain a path segment.')\n            if '@INPUT@' in i or '@INPUT0@' in i:\n                m = 'Output cannot contain @INPUT@ or @INPUT0@, did you ' \\\n                    'mean @PLAINNAME@ or @BASENAME@?'\n                raise InvalidArguments(m)\n            # We already check this during substitution, but the error message\n            # will be unclear/confusing, so check it here.\n            if len(inputs) != 1 and ('@PLAINNAME@' in i or '@BASENAME@' in i):\n                m = \"Output cannot contain @PLAINNAME@ or @BASENAME@ when \" \\\n                    \"there is more than one input (we can't know which to use)\"\n                raise InvalidArguments(m)\n        self.outputs = substitute_values(self.outputs, values)\n        self.capture = kwargs.get('capture', False)\n        if self.capture and len(self.outputs) != 1:\n            raise InvalidArguments('Capturing can only output to a single file.')\n        if 'command' not in kwargs:\n            raise InvalidArguments('Missing keyword argument \"command\".')\n        if 'depfile' in kwargs:\n            depfile = kwargs['depfile']\n            if not isinstance(depfile, str):\n                raise InvalidArguments('Depfile must be a string.')\n            if os.path.split(depfile)[1] != depfile:\n                raise InvalidArguments('Depfile must be a plain filename without a subdirectory.')\n            self.depfile = depfile\n        self.command = self.flatten_command(kwargs['command'])\n        if self.capture:\n            for c in self.command:\n                if isinstance(c, str) and '@OUTPUT@' in c:\n                    raise InvalidArguments('@OUTPUT@ is not allowed when capturing output.')\n        if 'install' in kwargs:\n            self.install = kwargs['install']\n            if not isinstance(self.install, bool):\n                raise InvalidArguments('\"install\" must be boolean.')\n            if self.install:\n                if 'install_dir' not in kwargs:\n                    raise InvalidArguments('\"install_dir\" must be specified '\n                                           'when installing a target')\n                # If an item in this list is False, the output corresponding to\n                # the list index of that item will not be installed\n                self.install_dir = typeslistify(kwargs['install_dir'], (str, bool))\n        else:\n            self.install = False\n            self.install_dir = [None]\n        self.build_always = kwargs.get('build_always', False)\n        if not isinstance(self.build_always, bool):\n            raise InvalidArguments('Argument build_always must be a boolean.')\n        extra_deps = kwargs.get('depends', [])\n        if not isinstance(extra_deps, list):\n            extra_deps = [extra_deps]\n        for ed in extra_deps:\n            while hasattr(ed, 'held_object'):\n                ed = ed.held_object\n            if not isinstance(ed, (CustomTarget, BuildTarget)):\n                raise InvalidArguments('Can only depend on toplevel targets: custom_target or build_target (executable or a library)')\n            self.extra_depends.append(ed)\n        depend_files = kwargs.get('depend_files', [])\n        if not isinstance(depend_files, list):\n            depend_files = [depend_files]\n        for i in depend_files:\n            if isinstance(i, (File, str)):\n                self.depend_files.append(i)\n            else:\n                mlog.debug(i)\n                raise InvalidArguments('Unknown type {!r} in depend_files.'.format(type(i).__name__))\n\n    def get_dependencies(self):\n        return self.dependencies\n\n    def should_install(self):\n        return self.install\n\n    def get_custom_install_dir(self):\n        return self.install_dir\n\n    def get_outputs(self):\n        return self.outputs\n\n    def get_filename(self):\n        return self.outputs[0]\n\n    def get_sources(self):\n        return self.sources\n\n    def get_generated_lists(self):\n        genlists = []\n        for c in self.sources:\n            if hasattr(c, 'held_object'):\n                c = c.held_object\n            if isinstance(c, GeneratedList):\n                genlists.append(c)\n        return genlists\n\n    def get_generated_sources(self):\n        return self.get_generated_lists()\n\n    def type_suffix(self):\n        return \"@cus\"\n\nclass RunTarget(Target):\n    def __init__(self, name, command, args, dependencies, subdir):\n        super().__init__(name, subdir, False)\n        self.command = command\n        self.args = args\n        self.dependencies = dependencies\n\n    def __lt__(self, other):\n        return self.get_id() < other.get_id()\n\n    def __repr__(self):\n        repr_str = \"<{0} {1}: {2}>\"\n        return repr_str.format(self.__class__.__name__, self.get_id(), self.command)\n\n    def get_id(self):\n        return self.name + self.type_suffix()\n\n    def get_dependencies(self):\n        return self.dependencies\n\n    def get_generated_sources(self):\n        return []\n\n    def get_sources(self):\n        return []\n\n    def should_install(self):\n        return False\n\n    def get_filename(self):\n        return self.name\n\n    def type_suffix(self):\n        return \"@run\"\n\nclass Jar(BuildTarget):\n    def __init__(self, name, subdir, subproject, is_cross, sources, objects, environment, kwargs):\n        super().__init__(name, subdir, subproject, is_cross, sources, objects, environment, kwargs)\n        for s in self.sources:\n            if not s.endswith('.java'):\n                raise InvalidArguments('Jar source %s is not a java file.' % s)\n        self.filename = self.name + '.jar'\n        self.outputs = [self.filename]\n        self.java_args = kwargs.get('java_args', [])\n\n    def get_main_class(self):\n        return self.main_class\n\n    def type_suffix(self):\n        return \"@jar\"\n\n    def get_java_args(self):\n        return self.java_args\n\n    def validate_cross_install(self, environment):\n        # All jar targets are installable.\n        pass\n\n\nclass ConfigureFile:\n\n    def __init__(self, subdir, sourcename, targetname, configuration_data):\n        self.subdir = subdir\n        self.sourcename = sourcename\n        self.targetname = targetname\n        self.configuration_data = configuration_data\n\n    def __repr__(self):\n        repr_str = \"<{0}: {1} -> {2}>\"\n        src = os.path.join(self.subdir, self.sourcename)\n        dst = os.path.join(self.subdir, self.targetname)\n        return repr_str.format(self.__class__.__name__, src, dst)\n\n    def get_configuration_data(self):\n        return self.configuration_data\n\n    def get_subdir(self):\n        return self.subdir\n\n    def get_source_name(self):\n        return self.sourcename\n\n    def get_target_name(self):\n        return self.targetname\n\nclass ConfigurationData:\n    def __init__(self):\n        super().__init__()\n        self.values = {}\n\n    def __repr__(self):\n        return repr(self.values)\n\n    def __contains__(self, value):\n        return value in self.values\n\n    def get(self, name):\n        return self.values[name] # (val, desc)\n\n    def keys(self):\n        return self.values.keys()\n\n# A bit poorly named, but this represents plain data files to copy\n# during install.\nclass Data:\n    def __init__(self, sources, install_dir, install_mode=None):\n        self.sources = sources\n        self.install_dir = install_dir\n        self.install_mode = install_mode\n        if not isinstance(self.sources, list):\n            self.sources = [self.sources]\n        for s in self.sources:\n            assert(isinstance(s, File))\n\nclass RunScript(dict):\n    def __init__(self, script, args):\n        super().__init__()\n        assert(isinstance(script, list))\n        assert(isinstance(args, list))\n        self['exe'] = script\n        self['args'] = args\n\nclass TestSetup:\n    def __init__(self, *, exe_wrapper=None, gdb=None, timeout_multiplier=None, env=None):\n        self.exe_wrapper = exe_wrapper\n        self.gdb = gdb\n        self.timeout_multiplier = timeout_multiplier\n        self.env = env\n\ndef get_sources_string_names(sources):\n    '''\n    For the specified list of @sources which can be strings, Files, or targets,\n    get all the output basenames.\n    '''\n    names = []\n    for s in sources:\n        if hasattr(s, 'held_object'):\n            s = s.held_object\n        if isinstance(s, str):\n            names.append(s)\n        elif isinstance(s, (BuildTarget, CustomTarget, GeneratedList)):\n            names += s.get_outputs()\n        elif isinstance(s, File):\n            names.append(s.fname)\n        else:\n            raise AssertionError('Unknown source type: {!r}'.format(s))\n    return names\n",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/test cases/common/156 shared module resolving symbol in executable/prog.c": "#include <stdio.h>\n#include <assert.h>\n#ifdef _WIN32\n#include <windows.h>\n#else\n#include <dlfcn.h>\n#endif\n\n#if defined _WIN32 || defined __CYGWIN__\n  #define DLL_PUBLIC __declspec(dllexport)\n#else\n  #if defined __GNUC__\n    #define DLL_PUBLIC __attribute__ ((visibility(\"default\")))\n  #else\n    #pragma message (\"Compiler does not support symbol visibility.\")\n    #define DLL_PUBLIC\n  #endif\n#endif\n\ntypedef int (*fptr) (void);\n\nint DLL_PUBLIC\nfunc_from_executable(void)\n{\n  return 42;\n}\n\nint\nmain (int argc, char **argv)\n{\n  int expected, actual;\n  fptr importedfunc;\n\n#ifdef _WIN32\n  HMODULE h = LoadLibraryA(argv[1]);\n#else\n  void *h = dlopen(argv[1], RTLD_NOW);\n#endif\n  assert(h != NULL);\n\n#ifdef _WIN32\n  importedfunc = (fptr) GetProcAddress (h, \"func\");\n#else\n  importedfunc = (fptr) dlsym(h, \"func\");\n#endif\n  assert(importedfunc != NULL);\n  assert(importedfunc != func_from_executable);\n\n  actual = (*importedfunc)();\n  expected = func_from_executable();\n  assert(actual == expected);\n\n#ifdef _WIN32\n  FreeLibrary(h);\n#else\n  dlclose(h);\n#endif\n\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/test cases/common/125 shared module/prog.c": "\n#include <stdio.h>\n\nint func_from_language_runtime(void);\ntypedef int (*fptr) (void);\n\n#ifdef _WIN32\n\n#include <windows.h>\n\nwchar_t*\nwin32_get_last_error (void)\n{\n    wchar_t *msg = NULL;\n\n    FormatMessageW (FORMAT_MESSAGE_ALLOCATE_BUFFER\n                    | FORMAT_MESSAGE_IGNORE_INSERTS\n                    | FORMAT_MESSAGE_FROM_SYSTEM,\n                    NULL, GetLastError (), 0,\n                    (LPWSTR) &msg, 0, NULL);\n    return msg;\n}\n\nint\nmain (int argc, char **argv)\n{\n    HINSTANCE handle;\n    fptr importedfunc;\n    int expected, actual;\n    int ret = 1;\n\n    handle = LoadLibraryA (argv[1]);\n    if (!handle) {\n        wchar_t *msg = win32_get_last_error ();\n        printf (\"Could not open %s: %S\\n\", argv[1], msg);\n        goto nohandle;\n    }\n\n    importedfunc = (fptr) GetProcAddress (handle, \"func\");\n    if (importedfunc == NULL) {\n        wchar_t *msg = win32_get_last_error ();\n        printf (\"Could not find 'func': %S\\n\", msg);\n        goto out;\n    }\n\n    actual = importedfunc ();\n    expected = func_from_language_runtime ();\n    if (actual != expected) {\n        printf (\"Got %i instead of %i\\n\", actual, expected);\n        goto out;\n    }\n\n    ret = 0;\nout:\n    FreeLibrary (handle);\nnohandle:\n    return ret;\n}\n\n#else\n\n#include<dlfcn.h>\n#include<assert.h>\n\nint main(int argc, char **argv) {\n    void *dl;\n    fptr importedfunc;\n    int expected, actual;\n    char *error;\n    int ret = 1;\n\n    dlerror();\n    dl = dlopen(argv[1], RTLD_LAZY);\n    error = dlerror();\n    if(error) {\n        printf(\"Could not open %s: %s\\n\", argv[1], error);\n        goto nodl;\n    }\n\n    importedfunc = (fptr) dlsym(dl, \"func\");\n    if (importedfunc == NULL) {\n        printf (\"Could not find 'func'\\n\");\n        goto out;\n    }\n\n    assert(importedfunc != func_from_language_runtime);\n\n    actual = (*importedfunc)();\n    expected = func_from_language_runtime ();\n    if (actual != expected) {\n        printf (\"Got %i instead of %i\\n\", actual, expected);\n        goto out;\n    }\n\n    ret = 0;\nout:\n    dlclose(dl);\nnodl:\n    return ret;\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/test cases/common/125 shared module/module.c": "#if defined _WIN32 || defined __CYGWIN__\n  #define DLL_PUBLIC __declspec(dllexport)\n#else\n  #if defined __GNUC__\n    #define DLL_PUBLIC __attribute__ ((visibility(\"default\")))\n  #else\n    #pragma message (\"Compiler does not support symbol visibility.\")\n    #define DLL_PUBLIC\n  #endif\n#endif\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n\n#include <stdio.h>\n\ntypedef int (*fptr) (void);\n\n#ifdef __CYGWIN__\n\n#include <dlfcn.h>\n\nfptr find_any_f (const char *name) {\n    return (fptr) dlsym(RTLD_DEFAULT, name);\n}\n#else /* _WIN32 */\n\n#include <windows.h>\n#include <tlhelp32.h>\n\n/* Unlike Linux and OS X, when a library is loaded, all the symbols aren't\n * loaded into a single namespace. You must fetch the symbol by iterating over\n * all loaded modules. Code for finding the function from any of the loaded\n * modules is taken from gmodule.c in glib */\nfptr find_any_f (const char *name) {\n    fptr f;\n    HANDLE snapshot;\n    MODULEENTRY32 me32;\n\n    snapshot = CreateToolhelp32Snapshot (TH32CS_SNAPMODULE, 0);\n    if (snapshot == (HANDLE) -1) {\n        printf(\"Could not get snapshot\\n\");\n        return 0;\n    }\n\n    me32.dwSize = sizeof (me32);\n\n    f = NULL;\n    if (Module32First (snapshot, &me32)) {\n        do {\n            if ((f = (fptr) GetProcAddress (me32.hModule, name)) != NULL)\n                break;\n        } while (Module32Next (snapshot, &me32));\n    }\n\n    CloseHandle (snapshot);\n    return f;\n}\n#endif\n\nint DLL_PUBLIC func() {\n    fptr f;\n\n    f = find_any_f (\"func_from_language_runtime\");\n    if (f != NULL)\n        return f();\n    printf (\"Could not find function\\n\");\n    return 1;\n}\n\n#else\n/*\n * Shared modules often have references to symbols that are not defined\n * at link time, but which will be provided from deps of the executable that\n * dlopens it. We need to make sure that this works, i.e. that we do\n * not pass -Wl,--no-undefined when linking modules.\n */\nint func_from_language_runtime();\n\nint DLL_PUBLIC func(void) {\n    return func_from_language_runtime();\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/test cases/common/125 shared module/meson.build": "project('shared module', 'c')\n\ndl = meson.get_compiler('c').find_library('dl', required : false)\nl = shared_library('runtime', 'runtime.c')\n# Do NOT link the module with the runtime library. This\n# is a common approach for plugins that are only used\n# with dlopen. Any symbols are resolved dynamically\n# at runtime.  This requires extra help on Windows, so\n# should be avoided unless really neccessary.\nm = shared_module('mymodule', 'module.c')\ne = executable('prog', 'prog.c', link_with : l, dependencies : dl)\ntest('import test', e, args : m)\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/tools/ac_converter.py": "#!/usr/bin/env python3\n\n# Copyright 2015 The Meson development team\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nhelp_message = \"\"\"Usage: %s <config.h.meson>\n\nThis script reads config.h.meson, looks for header\nchecks and writes the corresponding meson declaration.\n\nCopy config.h.in to config.h.meson, replace #undef\nwith #mesondefine and run this. We can't do this automatically\nbecause some configure scripts have #undef statements\nthat are unrelated to configure checks.\n\"\"\"\n\nimport sys\n\n\n# Add stuff here as it is encountered.\nfunction_data = \\\n    {'HAVE_FEENABLEEXCEPT': ('feenableexcept', 'fenv.h'),\n     'HAVE_FECLEAREXCEPT': ('feclearexcept', 'fenv.h'),\n     'HAVE_FEDISABLEEXCEPT': ('fedisableexcept', 'fenv.h'),\n     'HAVE_MMAP': ('mmap', 'sys/mman.h'),\n     'HAVE_GETPAGESIZE': ('getpagesize', 'unistd.h'),\n     'HAVE_GETISAX': ('getisax', 'sys/auxv.h'),\n     'HAVE_GETTIMEOFDAY': ('gettimeofday', 'sys/time.h'),\n     'HAVE_MPROTECT': ('mprotect', 'sys/mman.h'),\n     'HAVE_POSIX_MEMALIGN': ('posix_memalign', 'stdlib.h'),\n     'HAVE_SIGACTION': ('sigaction', 'signal.h'),\n     'HAVE_ALARM': ('alarm', 'unistd.h'),\n     'HAVE_CTIME_R': ('ctime_r', 'time.h'),\n     'HAVE_DRAND48': ('drand48', 'stdlib.h'),\n     'HAVE_FLOCKFILE': ('flockfile', 'stdio.h'),\n     'HAVE_FORK': ('fork', 'unistd.h'),\n     'HAVE_FUNLOCKFILE': ('funlockfile', 'stdio.h'),\n     'HAVE_GETLINE': ('getline', 'stdio.h'),\n     'HAVE_LINK': ('link', 'unistd.h'),\n     'HAVE_RAISE': ('raise', 'signal.h'),\n     'HAVE_STRNDUP': ('strndup', 'string.h'),\n     'HAVE_SCHED_GETAFFINITY': ('sched_getaffinity', 'sched.h'),\n     'HAVE_WAITPID': ('waitpid', 'sys/wait.h'),\n     'HAVE_XRENDERCREATECONICALGRADIENT': ('XRenderCreateConicalGradient', 'xcb/render.h'),\n     'HAVE_XRENDERCREATELINEARGRADIENT': ('XRenderCreateLinearGradient', 'xcb/render.h'),\n     'HAVE_XRENDERCREATERADIALGRADIENT': ('XRenderCreateRadialGradient', 'xcb/render.h'),\n     'HAVE_XRENDERCREATESOLIDFILL': ('XRenderCreateSolidFill', 'xcb/render.h'),\n     'HAVE_DCGETTEXT': ('dcgettext', 'libintl.h'),\n     'HAVE_ENDMNTENT': ('endmntent', 'mntent.h'),\n     'HAVE_ENDSERVENT': ('endservent', 'netdb.h'),\n     'HAVE_EVENTFD': ('eventfd', 'sys/eventfd.h'),\n     'HAVE_FALLOCATE': ('fallocate', 'fcntl.h'),\n     'HAVE_FCHMOD': ('fchmod', 'sys/stat.h'),\n     'HAVE_FCHOWN': ('fchown', 'unistd.h'),\n     'HAVE_FDWALK': ('fdwalk', 'stdlib.h'),\n     'HAVE_FSYNC': ('fsync', 'unistd.h'),\n     'HAVE_GETC_UNLOCKED': ('getc_unlocked', 'stdio.h'),\n     'HAVE_GETFSSTAT': ('getfsstat', 'sys/mount.h'),\n     'HAVE_GETMNTENT_R': ('getmntent_r', 'mntent.h'),\n     'HAVE_GETPROTOBYNAME_R': ('getprotobyname_r', 'netdb.h'),\n     'HAVE_GETRESUID': ('getresuid', 'unistd.h'),\n     'HAVE_GETVFSSTAT': ('getvfsstat', 'sys/statvfs.h'),\n     'HAVE_GMTIME_R': ('gmtime_r', 'time.h'),\n     'HAVE_HASMNTOPT': ('hasmntopt', 'mntent.h'),\n     'HAVE_IF_INDEXTONAME': ('if_indextoname', 'net/if.h'),\n     'HAVE_IF_NAMETOINDEX': ('if_nametoindex', 'net/if.h'),\n     'HAVE_INOTIFY_INIT1': ('inotify_init1', 'sys/inotify.h'),\n     'HAVE_ISSETUGID': ('issetugid', 'unistd.h'),\n     'HAVE_KEVENT': ('kevent', 'sys/event.h'),\n     'HAVE_KQUEUE': ('kqueue', 'sys/event.h'),\n     'HAVE_LCHMOD': ('lchmod', 'sys/stat.h'),\n     'HAVE_LCHOWN': ('lchown', 'unistd.h'),\n     'HAVE_LSTAT': ('lstat', 'sys/stat.h'),\n     'HAVE_MEMCPY': ('memcpy', 'string.h'),\n     'HAVE_MEMALIGN': ('memalign', 'stdlib.h'),\n     'HAVE_MEMMEM': ('memmem', 'string.h'),\n     'HAVE_NEWLOCALE': ('newlocale', 'locale.h'),\n     'HAVE_PIPE2': ('pipe2', 'fcntl.h'),\n     'HAVE_POLL': ('poll', 'poll.h'),\n     'HAVE_PRLIMIT': ('prlimit', 'sys/resource.h'),\n     'HAVE_PTHREAD_ATTR_SETSTACKSIZE': ('pthread_attr_setstacksize', 'pthread.h'),\n     'HAVE_PTHREAD_CONDATTR_SETCLOCK': ('pthread_condattr_setclock', 'pthread.h'),\n     'HAVE_PTHREAD_COND_TIMEDWAIT_RELATIVE_NP': ('pthread_cond_timedwait_relative_np', 'pthread.h'),\n     'HAVE_READLINK': ('readlink', 'unistd.h'),\n     'HAVE_RES_INIT': ('res_init', 'resolv.h'),\n     'HAVE_SENDMMSG': ('sendmmsg', 'sys/socket.h'),\n     'HAVE_SOCKET': ('socket', 'sys/socket.h'),\n     'HAVE_GETENV': ('getenv', 'stdlib.h'),\n     'HAVE_SETENV': ('setenv', 'stdlib.h'),\n     'HAVE_PUTENV': ('putenv', 'stdlib.h'),\n     'HAVE_UNSETENV': ('unsetenv', 'stdlib.h'),\n     'HAVE_SETMNTENT': ('setmntent', 'mntent.h'),\n     'HAVE_SNPRINTF': ('snprintf', 'stdio.h'),\n     'HAVE_SPLICE': ('splice', 'fcntl.h'),\n     'HAVE_STATFS': ('statfs', 'mount.h'),\n     'HAVE_STATVFS': ('statvfs', 'sys/statvfs.h'),\n     'HAVE_STPCOPY': ('stpcopy', 'string.h'),\n     'HAVE_STRCASECMP': ('strcasecmp', 'strings.h'),\n     'HAVE_STRLCPY': ('strlcpy', 'string.h'),\n     'HAVE_STRNCASECMP': ('strncasecmp', 'strings.h'),\n     'HAVE_STRSIGNAL': ('strsignal', 'signal.h'),\n     'HAVE_STRTOD_L': ('strtod_l', 'stdlib.h'),\n     'HAVE_STRTOLL_L': ('strtoll_l', 'stdlib.h'),\n     'HAVE_STRTOULL_L': ('strtoull_l', 'stdlib.h'),\n     'HAVE_SYMLINK': ('symlink', 'unistd.h'),\n     'HAVE_SYSCTLBYNAME': ('sysctlbyname', 'sys/sysctl.h'),\n     'HAVE_TIMEGM': ('timegm', 'time.h'),\n     'HAVE_USELOCALE': ('uselocale', 'xlocale.h'),\n     'HAVE_UTIMES': ('utimes', 'sys/time.h'),\n     'HAVE_VALLOC': ('valloc', 'stdlib.h'),\n     'HAVE_VASPRINTF': ('vasprintf', 'stdio.h'),\n     'HAVE_VSNPRINTF': ('vsnprintf', 'stdio.h'),\n     'HAVE_BCOPY': ('bcopy', 'strings.h'),\n     'HAVE_STRERROR': ('strerror', 'string.h'),\n     'HAVE_MEMMOVE': ('memmove', 'string.h'),\n     'HAVE_STRTOIMAX': ('strtoimax', 'inttypes.h'),\n     'HAVE_STRTOLL': ('strtoll', 'stdlib.h'),\n     'HAVE_STRTOQ': ('strtoq', 'stdlib.h'),\n     'HAVE_ACCEPT4': ('accept4', 'sys/socket.h'),\n     'HAVE_CHMOD': ('chmod', 'sys/stat.h'),\n     'HAVE_CHOWN': ('chown', 'unistd.h'),\n     'HAVE_FSTAT': ('fstat', 'sys/stat.h'),\n     'HAVE_GETADDRINFO': ('getaddrinfo', 'netdb.h'),\n     'HAVE_GETGRGID_R': ('getgrgid_r', 'grp.h'),\n     'HAVE_GETGRNAM_R': ('getgrnam_r', 'grp.h'),\n     'HAVE_GETGROUPS': ('getgroups', 'grp.h'),\n     'HAVE_GETOPT_LONG': ('getopt_long', 'getopt.h'),\n     'HAVE_GETPWNAM_R': ('getpwnam', 'pwd.h'),\n     'HAVE_GETPWUID_R': ('getpwuid_r', 'pwd.h'),\n     'HAVE_GETUID': ('getuid', 'unistd.h'),\n     'HAVE_LRINTF': ('lrintf', 'math.h'),\n     'HAVE_DECL_ISNAN': ('isnan', 'math.h'),\n     'HAVE_DECL_ISINF': ('isinf', 'math.h'),\n     'HAVE_ROUND': ('round', 'math.h'),\n     'HAVE_NEARBYINT': ('nearbyint', 'math.h'),\n     'HAVE_RINT': ('rint', 'math.h'),\n     'HAVE_MKFIFO': ('mkfifo', 'sys/stat.h'),\n     'HAVE_MLOCK': ('mlock', 'sys/mman.h'),\n     'HAVE_NANOSLEEP': ('nanosleep', 'time.h'),\n     'HAVE_PIPE': ('pipe', 'unistd.h'),\n     'HAVE_PPOLL': ('ppoll', 'poll.h'),\n     'HAVE_REGEXEC': ('regexec', 'regex.h'),\n     'HAVE_SETEGID': ('setegid', 'unistd.h'),\n     'HAVE_SETEUID': ('seteuid', 'unistd.h'),\n     'HAVE_SETPGID': ('setpgid', 'unistd.h'),\n     'HAVE_SETREGID': ('setregid', 'unistd.h'),\n     'HAVE_SETRESGID': ('setresgid', 'unistd.h'),\n     'HAVE_SETRESUID': ('setresuid', 'unistd.h'),\n     'HAVE_SHM_OPEN': ('shm_open', 'fcntl.h'),\n     'HAVE_SLEEP': ('sleep', 'unistd.h'),\n     'HAVE_STRERROR_R': ('strerror_r', 'string.h'),\n     'HAVE_STRTOF': ('strtof', 'stdlib.h'),\n     'HAVE_SYSCONF': ('sysconf', 'unistd.h'),\n     'HAVE_USLEEP': ('usleep', 'unistd.h'),\n     'HAVE_VFORK': ('vfork', 'unistd.h'),\n     'HAVE_MALLOC': ('malloc', 'stdlib.h'),\n     'HAVE_CALLOC': ('calloc', 'stdlib.h'),\n     'HAVE_REALLOC': ('realloc', 'stdlib.h'),\n     'HAVE_FREE': ('free', 'stdlib.h'),\n     'HAVE_ALLOCA': ('alloca', 'alloca.h'),\n     'HAVE_QSORT': ('qsort', 'stdlib.h'),\n     'HAVE_ABS': ('abs', 'stdlib.h'),\n     'HAVE_MEMSET': ('memset', 'string.h'),\n     'HAVE_MEMCMP': ('memcmp', 'string.h'),\n     'HAVE_STRLEN': ('strlen', 'string.h'),\n     'HAVE_STRLCAT': ('strlcat', 'string.h'),\n     'HAVE_STRDUP': ('strdup', 'string.h'),\n     'HAVE__STRREV': ('_strrev', 'string.h'),\n     'HAVE__STRUPR': ('_strupr', 'string.h'),\n     'HAVE__STRLWR': ('_strlwr', 'string.h'),\n     'HAVE_INDEX': ('index', 'strings.h'),\n     'HAVE_RINDEX': ('rindex', 'strings.h'),\n     'HAVE_STRCHR': ('strchr', 'string.h'),\n     'HAVE_STRRCHR': ('strrchr', 'string.h'),\n     'HAVE_STRSTR': ('strstr', 'string.h'),\n     'HAVE_STRTOL': ('strtol', 'stdlib.h'),\n     'HAVE_STRTOUL': ('strtoul', 'stdlib.h'),\n     'HAVE_STRTOULL': ('strtoull', 'stdlib.h'),\n     'HAVE_STRTOD': ('strtod', 'stdlib.h'),\n     'HAVE_ATOI': ('atoi', 'stdlib.h'),\n     'HAVE_ATOF': ('atof', 'stdlib.h'),\n     'HAVE_STRCMP': ('strcmp', 'string.h'),\n     'HAVE_STRNCMP': ('strncmp', 'string.h'),\n     'HAVE_VSSCANF': ('vsscanf', 'stdio.h'),\n     'HAVE_CHROOT': ('chroot', 'unistd.h'),\n     'HAVE_CLOCK': ('clock', 'time.h'),\n     'HAVE_CLOCK_GETRES': ('clock_getres', 'time.h'),\n     'HAVE_CLOCK_GETTIME': ('clock_gettime', 'time.h'),\n     'HAVE_CLOCK_SETTIME': ('clock_settime', 'time.h'),\n     'HAVE_CONFSTR': ('confstr', 'time.h'),\n     'HAVE_CTERMID': ('ctermid', 'stdio.h'),\n     'HAVE_DIRFD': ('dirfd', 'dirent.h'),\n     'HAVE_DLOPEN': ('dlopen', 'dlfcn.h'),\n     'HAVE_DUP2': ('dup2', 'unistd.h'),\n     'HAVE_DUP3': ('dup3', 'unistd.h'),\n     'HAVE_EPOLL_CREATE1': ('epoll_create1', 'sys/epoll.h'),\n     'HAVE_ERF': ('erf', 'math.h'),\n     'HAVE_ERFC': ('erfc', 'math.h'),\n     'HAVE_EXECV': ('execv', 'unistd.h'),\n     'HAVE_FACCESSAT': ('faccessat', 'unistd.h'),\n     'HAVE_FCHDIR': ('fchdir', 'unistd.h'),\n     'HAVE_FCHMODAT': ('fchmodat', 'sys/stat.h'),\n     'HAVE_FDATASYNC': ('fdatasync', 'unistd.h'),\n     'HAVE_FDOPENDIR': ('fdopendir', 'dirent.h'),\n     'HAVE_FEXECVE': ('fexecve', 'unistd.h'),\n     'HAVE_FLOCK': ('flock', 'sys/file.h'),\n     'HAVE_FORKPTY': ('forkpty', 'pty.h'),\n     'HAVE_FPATHCONF': ('fpathconf', 'unistd.h'),\n     'HAVE_FSTATAT': ('fstatat', 'unistd.h'),\n     'HAVE_FSTATVFS': ('fstatvfs', 'sys/statvfs.h'),\n     'HAVE_FTELLO': ('ftello', 'stdio.h'),\n     'HAVE_FTIME': ('ftime', 'sys/timeb.h'),\n     'HAVE_FTRUNCATE': ('ftruncate', 'unistd.h'),\n     'HAVE_FUTIMENS': ('futimens', 'sys/stat.h'),\n     'HAVE_FUTIMES': ('futimes', 'sys/time.h'),\n     'HAVE_GAI_STRERROR': ('gai_strerror', 'netdb.h'),\n     'HAVE_GETGROUPLIST': ('getgrouplist', 'grp.h'),\n     'HAVE_GETHOSTBYNAME': ('gethostbyname', 'netdb.h'),\n     'HAVE_GETHOSTBYNAME_R': ('gethostbyname_r', 'netdb.h'),\n     'HAVE_GETITIMER': ('getitimer', 'sys/time.h'),\n     'HAVE_GETLOADAVG': ('getloadavg', 'stdlib.h'),\n     'HAVE_GETLOGIN': ('getlogin', 'unistd.h'),\n     'HAVE_GETNAMEINFO': ('getnameinfo', 'netdb.h'),\n     'HAVE_GETPEERNAME': ('getpeername', 'sys/socket.h'),\n     'HAVE_GETPGID': ('getpgid', 'unistd.h'),\n     'HAVE_GETPGRP': ('getpgrp', 'unistd.h'),\n     'HAVE_GETPID': ('getpid', 'unistd.h'),\n     'HAVE_GETPRIORITY': ('getpriority', 'sys/resource.h'),\n     'HAVE_GETPWENT': ('getpwent', 'pwd.h'),\n     'HAVE_GETRANDOM': ('getrandom', 'linux/random.h'),\n     'HAVE_GETRESGID': ('getresgid', 'unistd.h'),\n     'HAVE_GETSID': ('getsid', 'unistd.h'),\n     'HAVE_GETSPENT': ('getspent', 'shadow.h'),\n     'HAVE_GETSPNAM': ('getspnam', 'shadow.h'),\n     'HAVE_GETWD': ('getwd', 'unistd.h'),\n     'HAVE_HSTRERROR': ('hstrerror', 'netdb.h'),\n     'HAVE_HTOLE64': ('htole64', 'endian.h'),\n     'HAVE_IF_NAMEINDEX': ('if_nameindex', 'net/if.h'),\n     'HAVE_INET_ATON': ('inet_aton', 'arpa/inet.h'),\n     'HAVE_INET_PTON': ('inet_pton', 'arpa/inet.h'),\n     'HAVE_INITGROUPS': ('initgroups', 'grp.h'),\n     'HAVE_KILL': ('kill', 'signal.h'),\n     'HAVE_KILLPG': ('killpg', 'signal.h'),\n     'HAVE_LINKAT': ('linkat', 'unistd.h'),\n     'HAVE_LOCKF': ('lockf', 'unistd.h'),\n     'HAVE_LUTIMES': ('lutimes', 'sys/time.h'),\n     'HAVE_MAKEDEV': ('makedev', 'sys/sysmacros.h'),\n     'HAVE_MBRTOWC': ('mbrtowc', 'wchar.h'),\n     'HAVE_MEMRCHR': ('memrchr', 'string.h'),\n     'HAVE_MKDIRAT': ('mkdirat', 'sys/stat.h'),\n     'HAVE_MKFIFOAT': ('mkfifoat', 'sys/stat.h'),\n     'HAVE_MKNOD': ('mknod', 'unistd.h'),\n     'HAVE_MKNODAT': ('mknodat', 'unistd.h'),\n     'HAVE_MKTIME': ('mktime', 'unistd.h'),\n     'HAVE_MKREMAP': ('mkremap', 'sys/mman.h'),\n     'HAVE_NICE': ('nice', 'unistd.h'),\n     'HAVE_OPENAT': ('openat', 'fcntl.h'),\n     'HAVE_OPENPTY': ('openpty', 'pty.h'),\n     'HAVE_PATHCONF': ('pathconf', 'unistd.h'),\n     'HAVE_PAUSE': ('pause', 'unistd.h'),\n     'HAVE_PREAD': ('pread', 'unistd.h'),\n     'HAVE_PTHREAD_KILL': ('pthread_kill', 'signal.h'),\n     'HAVE_PTHREAD_SIGMASK': ('pthread_sigmask', 'signal.h'),\n     'HAVE_PWRITE': ('pwrite', 'unistd.h'),\n     'HAVE_READLINKAT': ('readlinkat', 'unistd.h'),\n     'HAVE_READV': ('readv', 'sys/uio.h'),\n     'HAVE_RENAMEAT': ('renamat', 'stdio.h'),\n     'HAVE_SCHED_GET_PRIORITY_MAX': ('sched_get_priority_max', 'sched.h'),\n     'HAVE_SCHED_RR_GET_INTERVAL': ('sched_rr_get_interval', 'sched.h'),\n     'HAVE_SCHED_SETAFFINITY': ('sched_setaffinity', 'sched.h'),\n     'HAVE_SCHED_SETPARAM': ('sched_setparam', 'sched.h'),\n     'HAVE_SCHED_SETSCHEDULER': ('sched_setscheduler', 'sched.h'),\n     'HAVE_SELECT': ('select', 'sys/select.h'),\n     'HAVE_SEM_GETVALUE': ('sem_getvalue', 'semaphore.h'),\n     'HAVE_SEM_OPEN': ('sem_open', 'semaphore.h'),\n     'HAVE_SEM_TIMEDWAIT': ('sem_timedwait', 'semaphore.h'),\n     'HAVE_SEM_UNLINK': ('sem_unlink', 'semaphore.h'),\n     'HAVE_SENDFILE': ('sendfile', 'sys/sendfile.h'),\n     'HAVE_SETGID': ('setgid', 'unistd.h'),\n     'HAVE_SETGROUPS': ('setgroups', 'grp.h'),\n     'HAVE_SETHOSTNAME': ('sethostname', 'unistd.h'),\n     'HAVE_SETITIMER': ('setitimer', 'sys/time.h'),\n     'HAVE_SETLOCALE': ('setlocale', 'locale.h'),\n     'HAVE_SETPGRP': ('setpgrp', 'unistd.h'),\n     'HAVE_SETPRIORITY': ('setpriority', 'sys/resource.h'),\n     'HAVE_SETREUID': ('setreuid', 'unistd.h'),\n     'HAVE_SETSID': ('setsid', 'unistd.h'),\n     'HAVE_SETUID': ('setuid', 'unistd.h'),\n     'HAVE_SETVBUF': ('setvbuf', 'unistd.h'),\n     'HAVE_SIGALTSTACK': ('sigaltstack', 'signal.h'),\n     'HAVE_SIGINTERRUPT': ('siginterrupt', 'signal.h'),\n     'HAVE_SIGPENDING': ('sigpending', 'signal.h'),\n     'HAVE_SIGRELSE': ('sigrelse', 'signal.h'),\n     'HAVE_SIGTIMEDWAIT': ('sigtimedwait', 'signal.h'),\n     'HAVE_SIGWAIT': ('sigwait', 'signal.h'),\n     'HAVE_SIGWAITINFO': ('sigwaitinfo', 'signal.h'),\n     'HAVE_SOCKETPAIR': ('socketpair', 'sys/socket.h'),\n     'HAVE_STRFTIME': ('strftime', 'time.h'),\n     'HAVE_SYMLINKAT': ('symlinkat', 'unistd.h'),\n     'HAVE_SYNC': ('sync', 'unistd.h'),\n     'HAVE_TCGETPGRP': ('tcgetpgrp', 'unistd.h'),\n     'HAVE_TCSETPGRP': ('tcsetpgrp', 'unistd.h'),\n     'HAVE_TEMPNAM': ('tempnam', 'stdio.h'),\n     'HAVE_TIMES': ('times', 'sys/times.h'),\n     'HAVE_TEMPFILE': ('tempfile', 'stdio.h'),\n     'HAVE_TMPNAM': ('tmpnam', 'stdio.h'),\n     'HAVE_TMPNAM_R': ('tmpnam_r', 'stdio.h'),\n     'HAVE_TRUNCATE': ('truncate', 'unistd.h'),\n     'HAVE_TZNAME': ('tzname', 'time.h'),\n     'HAVE_UNAME': ('uname', 'sys/utsname.h'),\n     'HAVE_UNLINKAT': ('unlinkat', 'unistd.h'),\n     'HAVE_UTIMENSAT': ('utimensat', 'sys/stat.h'),\n     'HAVE_WAIT3': ('wait3', 'sys/wait.h'),\n     'HAVE_WAIT4': ('wait4', 'sys/wait.h'),\n     'HAVE_WAITID': ('waitid', 'sys/wait.h'),\n     'HAVE_WRITEV': ('writev', 'sys/uio.h'),\n     'HAVE_WMEMCMP': ('wmemcmp', 'wchar.h'),\n     'HAVE_ATAN': ('atan', 'math.h'),\n     'HAVE_ATAN2': ('atan2', 'math.h'),\n     'HAVE_ACOS': ('acos', 'math.h'),\n     'HAVE_ACOSH': ('acosh', 'math.h'),\n     'HAVE_ASIN': ('asin', 'math.h'),\n     'HAVE_ASINH': ('asinh', 'math.h'),\n     'HAVE_ATANH': ('atanh', 'math.h'),\n     'HAVE_CEIL': ('ceil', 'math.h'),\n     'HAVE_COPYSIGN': ('copysign', 'math.h'),\n     'HAVE_COS': ('cos', 'math.h'),\n     'HAVE_COSH': ('cosh', 'math.h'),\n     'HAVE_COSF': ('cosf', 'math.h'),\n     'HAVE_EXPM1': ('expm1', 'math.h'),\n     'HAVE_FABS': ('fabs', 'math.h'),\n     'HAVE_FINITE': ('finite', 'math.h'),\n     'HAVE_FLOOR': ('floor', 'math.h'),\n     'HAVE_GAMMA': ('gamma', 'math.h'),\n     'HAVE_HYPOT': ('hypot', 'math.h'),\n     'HAVE_ISINF': ('isinf', 'math.h'),\n     'HAVE_LOG': ('log', 'math.h'),\n     'HAVE_LOG1P': ('log1p', 'math.h'),\n     'HAVE_LOG2': ('log2', 'math.h'),\n     'HAVE_LGAMMA': ('lgamma', 'math.h'),\n     'HAVE_POW': ('pow', 'math.h'),\n     'HAVE_SCALBN': ('scalbn', 'math.h'),\n     'HAVE_SIN': ('sin', 'math.h'),\n     'HAVE_SINF': ('sinf', 'math.h'),\n     'HAVE_SINH': ('sinh', 'math.h'),\n     'HAVE_SQRT': ('sqrt', 'math.h'),\n     'HAVE_TGAMMA': ('tgamma', 'math.h'),\n     'HAVE_FSEEKO': ('fseeko', 'stdio.h'),\n     'HAVE_FSEEKO64': ('fseeko64', 'stdio.h'),\n     'HAVE_SETJMP': ('setjmp', 'setjmp.h'),\n     'HAVE_PTHREAD_SETNAME_NP': ('pthread_setname_np', 'pthread.h'),\n     'HAVE_PTHREAD_SET_NAME_NP': ('pthread_set_name_np', 'pthread.h'),\n     }\n\nheaders = []\nfunctions = []\nsizes = []\n\nif len(sys.argv) != 2:\n    print(help_message % sys.argv[0])\n    sys.exit(0)\n\nwith open(sys.argv[1]) as f:\n    for line in f:\n        line = line.strip()\n        arr = line.split()\n\n        # Check for headers.\n        if line.startswith('#mesondefine') and line.endswith('_H'):\n            token = line.split()[1]\n            tarr = token.split('_')[1:-1]\n            tarr = [x.lower() for x in tarr]\n            hname = '/'.join(tarr) + '.h'\n            headers.append((token, hname))\n\n        # Check for functions.\n        try:\n            token = arr[1]\n            if token in function_data:\n                fdata = function_data[token]\n                functions.append((token, fdata[0], fdata[1]))\n            elif token.startswith('HAVE_') and not token.endswith('_H'):\n                functions.append((token, ))\n        except Exception:\n            pass\n\n        # Check for sizeof tests.\n        if len(arr) != 2:\n            continue\n        elem = arr[1]\n        if elem.startswith('SIZEOF_'):\n            typename = elem.split('_', 1)[1] \\\n                .replace('_P', '*') \\\n                .replace('_', ' ') \\\n                .lower() \\\n                .replace('size t', 'size_t')\n            sizes.append((elem, typename))\n\nprint('''cc = meson.get_compiler('c')\ncdata = configuration_data()''')\n\n# Convert header checks.\n\nprint('check_headers = [')\nfor token, hname in headers:\n    print(\"  ['%s', '%s'],\" % (token, hname))\nprint(']\\n')\n\nprint('''foreach h : check_headers\n  if cc.has_header(h.get(1))\n    cdata.set(h.get(0), 1)\n  endif\nendforeach\n''')\n\n# Convert function checks.\n\nprint('check_functions = [')\nfor token in functions:\n    if len(token) == 3:\n        token, fdata0, fdata1 = token\n        print(\"  ['%s', '%s', '#include<%s>'],\" % (token, fdata0, fdata1))\n    else:\n        print('# check token', token)\nprint(']\\n')\n\nprint('''foreach f : check_functions\n  if cc.has_function(f.get(1), prefix : f.get(2))\n    cdata.set(f.get(0), 1)\n  endif\nendforeach\n''')\n\n# Convert sizeof checks.\n\nfor elem, typename in sizes:\n    print(\"cdata.set('%s', cc.sizeof('%s'))\" % (elem, typename))\n\nprint('''\nconfigure_file(input : 'config.h.meson',\n  output : 'config.h',\n  configuration : cdata)''')\n",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/docs/markdown/Reference-manual.md": "# Reference manual\n\n## Functions\n\nThe following functions are available in build files. Click on each to see the description and usage. The objects returned by them are [list afterwards](#returned-objects).\n\n\n### add_global_arguments()\n\n``` meson\n  void add_global_arguments(arg1, arg2, ...)\n```\n\nAdds the positional arguments to the compiler command line for the language specified in `language` keyword argument. If a list of languages is given, the arguments are added to each of the corresponding compiler command lines. Note that there is no way to remove an argument set in this way. If you have an argument that is only used in a subset of targets, you have to specify it in per-target flags.\n\nThe arguments are used in all compiler invocations with the exception of compile tests, because you might need to run a compile test with and without the argument in question. For this reason only the arguments explicitly specified are used during compile tests.\n\n**Note:** Usually you should use `add_project_arguments` instead, because that works even when you project is used as a subproject.\n\n**Note:** You must pass always arguments individually `arg1, arg2, ...` rather than as a string `'arg1 arg2', ...`\n\n### add_global_link_arguments()\n\n``` meson\n    void add_global_link_arguments(*arg1*, *arg2*, ...)\n```\n\nLike `add_global_arguments` but the arguments are passed to the linker.\n\n### add_languages()\n\n``` meson\n  add_languages(*langs*)\n```\n\nAdd support for new programming languages. Equivalent to having them in the `project` declaration. This function is usually used to add languages that are only used on some platforms like this:\n\n```meson\nproject('foobar', 'c')\nif compiling_for_osx\n  add_languages('objc')\nendif\n```\n\nTakes one keyword argument, `required`. It defaults to `true`, which means that if any of the languages specified is not found, Meson will halt. Returns true if all languages specified were found and false otherwise.\n\n### add_project_arguments()\n\n``` meson\n  void add_project_arguments(arg1, arg2, ...)\n```\n\nThis function behaves in the same way as `add_global_arguments` except that the arguments are only used for the current project, they won't be used in any other subproject.\n\n### add_project_link_arguments()\n\n``` meson\n  void add_project_link_arguments(*arg1*, *arg2*, ...)\n```\n\nLike `add_project_arguments` but the arguments are passed to the linker.\n\n### add_test_setup()\n\n``` meson\n  void add_test_setup(*name*, ...)\n```\n\nAdd a custom test setup that can be used to run the tests with a custom setup, for example under Valgrind. The keyword arguments are the following:\n\n- `exe_wrapper` a list containing the wrapper command or script followed by the arguments to it\n- `gdb` if `true`, the tests are also run under `gdb`\n- `timeout_multiplier` a number to multiply the test timeout with\n- `env` an [environment object](#environment-object) to use a custom environment\n\nTo use the test setup, run `mesontest --setup=*name*` inside the build dir.\n\nNote that all these options are also available while running the `mesontest` script for running tests instead of `ninja test` or `msbuild RUN_TESTS.vcxproj`, etc depending on the backend.\n\n### benchmark()\n\n``` meson\n    void benchmark(name, executable, ...)\n```\n\nCreates a benchmark item that will be run when the benchmark target is run. The behavior of this function is identical to `test` with the exception that there is no `is_parallel` keyword, because benchmarks are never run in parallel.\n\n### build_target()\n\nCreates a build target whose type can be set dynamically with the `target_type` keyword argument. This declaration:\n\n```meson\nexecutable(<arguments and keyword arguments>)\n```\n\nis equivalent to this:\n\n```meson\nbuild_target(<arguments and keyword arguments>, target_type : 'executable')\n```\n\nThe object returned by `build_target` and all convenience wrappers for `build_target` such as [`executable`](#executable) and [`library`](#library) has methods that are documented in the [object methods section](#build-target-object) below.\n\n### configuration_data()\n\n``` meson\n    configuration_data_object = configuration_data()\n```\n\nCreates an empty configuration object. You should add your configuration with [its method calls](#configuration-data-object) and finally use it in a call to `configure_file`.\n\n### configure_file()\n\n``` meson\n    generated_file = configure_file(...)\n```\n\nThis function can run in two modes depending on the keyword arguments passed to it.\n\nWhen a [`configuration_data()`](#configuration_data) object is passed to the `configuration:` keyword argument, it takes a template file as the `input:` (optional) and produces the `output:` (required) by substituting values from the configuration data as detailed in [the configuration file documentation](Configuration.md).\n\nWhen a list of strings is passed to the `command:` keyword argument, it takes any source or configured file as the `input:` and assumes that the `output:` is produced when the specified command is run.\n\nThese are all the supported keyword arguments:\n\n- `input` the input file name. If it's not specified in configuration mode, all the variables in the `configuration:` object (see above) are written to the `output:` file.\n- `output` the output file name (since v0.41.0, may contain `@PLAINNAME@` or `@BASENAME@` substitutions). In configuration mode, the permissions of the input file (if it is specified) are copied to the output file.\n- `configuration` as explained above, this is where you pass the configuration data object as returned by `configuration_data()`\n- `command` as explained above, if specified, Meson does not create the file itself but rather runs the specified command, which allows you to do fully custom file generation\n- `capture` when this argument is set to true, Meson captures `stdout` of the `command` and writes it to the target file specified as `output`. Available since v0.41.0.\n- `install_dir` the subdirectory to install the generated file to (e.g. `share/myproject`), if omitted the file is not installed.\n\n### custom_target()\n\n``` meson\n    customtarget custom_target(*name*, ...)\n```\n\nCreate a custom top level build target. The only positional argument is the name of this target and the keyword arguments are the following.\n\n- `input` list of source files. As of 0.41.0 the list will be flattened.\n- `output` list of output files\n- `command` command to run to create outputs from inputs. The command may be strings or the return of `find_program()` or `executable()` (note: always specify commands in array form `['commandname', '-arg1', '-arg2']` rather than as a string `'commandname -arg1 -arg2'` as the latter will *not* work)\n- `install` when true, this target is installed during the install step\n- `install_dir` directory to install to\n- `build_always` if `true` this target is always considered out of date and is rebuilt every time, useful for things such as build timestamps or revision control tags\n- `capture`, there are some compilers that can't be told to write their output to a file but instead write it to standard output. When this argument is set to true, Meson captures `stdout` and writes it to the target file. Note that your command argument list may not contain `@OUTPUT@` when capture mode is active.\n- `depends` specifies that this target depends on the specified target(s), even though it does not take any of them as a command line argument. This is meant for cases where you have a tool that e.g. does globbing internally. Usually you should just put the generated sources as inputs and Meson will set up all dependencies automatically.\n- `depend_files` files ([`string`](#string-object), [`files()`](#files), or [`configure_file()`](#configure_file)) that this target depends on but are not listed in the `command` keyword argument. Useful for adding regen dependencies.\n- `depfile` is a dependency file that the command can write listing all the additional files this target depends on, for example a C compiler would list all the header files it included, and a change in any one of these files triggers a recompilation\n- `build_by_default` *(added 0.38.0)* causes, when set to true, to have this target be built by default, that is, when invoking plain `ninja`; the default value is false\n\nThe list of strings passed to the `command` keyword argument accept the following special string substitutions:\n\n- `@INPUT@` the full path to the input passed to `input`. If more than one input is specified, all of them will be substituted as separate arguments only if the command uses `'@INPUT@'` as a standalone-argument. For instance, this would not work: `command : ['cp', './@INPUT@']`, but this would: `command : ['cp', '@INPUT@']`.\n- `@OUTPUT@` the full path to the output passed to `output`. If more than one outputs are specified, the behavior is the same as `@INPUT@`.\n- `@INPUT0@` `@INPUT1@` `...` the full path to the input with the specified array index in `input`\n- `@OUTPUT0@` `@OUTPUT1@` `...` the full path to the output with the specified array index in `output`\n- `@OUTDIR@` the full path to the directory where the output(s) must be written\n- `@DEPFILE@` the full path to the dependency file passed to `depfile`\n\nThe returned object also has methods that are documented in the [object methods section](#custom-target-object) below.\n\n### declare_dependency()\n\n``` meson\n    dependency_object declare_dependency(...)\n```\n\nThis function returns a [dependency object](#dependency-object) that behaves like the return value of [`dependency`](#dependency) but is internal to the current build. The main use case for this is in subprojects. This allows a subproject to easily specify how it should be used. This makes it interchangeable with the same dependency that is provided externally by the system. This function has the following keyword arguments.\n\n  - `include_directories`, the directories to add to header search path\n  - `link_with`, libraries to link against\n  - `sources`, sources to add to targets (or generated header files that should be built before sources including them are built)\n  - `dependencies`, other dependencies needed to use this dependency\n  - `compile_args`, compile arguments to use\n  - `link_args`, link arguments to use\n  - `version`, the version of this dependency, such as `1.2.3`\n\n### dependency()\n\n``` meson\n    dependency_object dependency(*dependency_name*, ...)\n```\n\nFinds an external dependency (usually a library installed on your system) with the given name with `pkg-config` if possible and with [library-specific fallback detection logic](Dependencies.md) otherwise. This function supports the following keyword arguments:\n\n- `modules` specifies submodules to use for dependencies such as Qt5 or Boost.\n- `required`, when set to false, Meson will proceed with the build even if the dependency is not found\n- `version`, specifies the required version, a string containing a comparison operator followed by the version string, examples include `>1.0.0`, `<=2.3.5` or `3.1.4` for exact matching. (*Added 0.37.0*) You can also specify multiple restrictions by passing a list to this keyword argument, such as: `['>=3.14.0', '<=4.1.0']`.\n- `native` if set to `true`, causes Meson to find the dependency on the build machine system rather than the host system (i.e. where the cross compiled binary will run on), usually only needed if you build a tool to be used during compilation.\n- `static` tells the dependency provider to try to get static libraries instead of dynamic ones (note that this is not supported by all dependency backends)\n- `fallback` specifies a subproject fallback to use in case the dependency is not found in the system. The value is an array `['subproj_name', 'subproj_dep']` where the first value is the name of the subproject and the second is the variable name in that subproject that contains the value of [`declare_dependency`](#declare_dependency).\n- `default_options` *(added 0.37.0)* an array of option values that override those set in the project's `default_options` invocation (like `default_options` in [`project()`](#project), they only have effect when Meson is run for the first time, and command line arguments override any default options in build files)\n- `method` defines the way the dependency is detected, the default is `auto` but can be overridden to be e.g. `qmake` for Qt development, and different dependencies support different values for this (though `auto` will work on all of them)\n- `language` *(added 0.42.0)* defines what language-specific dependency to find if it's available for multiple languages.\n\nThe returned object also has methods that are documented in the [object methods section](#dependency-object) below.\n\n### error()\n\n``` meson\n    void error(message)\n```\n\nPrint the argument string and halts the build process.\n\n### environment()\n\n``` meson\n    environment_object environment()\n```\n\nReturns an empty [environment variable object](#environment-object).\n\n### executable()\n\n``` meson\n    buildtarget executable(*exe_name*, *sources*, ...)\n```\n\nCreates a new executable. The first argument specifies its name and the remaining positional arguments define the input files to use. They can be of the following types:\n\n- Strings relative to the current source directory\n- [`files()`](#files) objects defined in any preceding build file\n- The return value of configure-time generators such as [`configure_file()`](#configure_file)\n- The return value of build-time generators such as [`custom_target()`](#custom_target) or [`generator.process()`](#generator-object)\n\nThese input files can be sources, objects, libraries, or any other file. Meson will automatically categorize them based on the extension and use them accordingly. For instance, sources (`.c`, `.cpp`, `.vala`, `.rs`, etc) will be compiled, objects (`.o`, `.obj`) and libraries (`.so`, `.dll`, etc) will be linked, and all other files (headers, unknown extensions, etc) will be ignored.\n\nWith the Ninja backend, Meson will create a build-time [order-only dependency](https://ninja-build.org/manual.html#ref_dependencies) on all generated input files, including unknown files. For all input files (generated and non-generated), Meson uses the [dependency file](https://ninja-build.org/manual.html#ref_headers) generated by your compiler to determine when to rebuild sources. The behavior is similar for other backends.\n\nExecutable supports the following keyword arguments. Note that just like the positional arguments above, these keyword arguments can also be passed to [shared and static libraries](#library).\n\n- `link_with`, one or more shared or static libraries (built by this project) that this target should be linked with, If passed a list this list will be flattened as of 0.41.0.\n- `link_whole` links all contents of the given static libraries whether they are used by not, equivalent to the `-Wl,--whole-archive` argument flag of GCC, available since 0.40.0. As of 0.41.0 if passed a list that list will be flattened.\n- `<languagename>_pch` precompiled header file to use for the given language\n- `<languagename>_args` compiler flags to use for the given language; eg: `cpp_args` for C++\n- `link_args` flags to use during linking. You can use UNIX-style flags here for all platforms.\n- `link_depends`  strings, files, or custom targets the link step depends on such as a symbol visibility map. The purpose is to automatically trigger a re-link (but not a re-compile) of the target when this file changes.\n- `include_directories` one or more objects created with the `include_directories` function\n- `dependencies` one or more objects created with [`dependency`](#dependency) or [`find_library`](#compiler-object) (for external deps) or [`declare_dependency`](#declare_dependency) (for deps built by the project)\n- `gui_app` when set to true flags this target as a GUI application on platforms where this makes a difference (e.g. Windows)\n- `extra_files` are not used for the build itself but are shown as source files in IDEs that group files by targets (such as Visual Studio)\n- `install`, when set to true, this executable should be installed\n- `install_rpath` a string to set the target's rpath to after install (but *not* before that)\n- `build_rpath` a string to add to target's rpath definition in the build dir, but which will be removed on install\n- `install_dir` override install directory for this file. The value is relative to the `prefix` specified. F.ex, if you want to install plugins into a subdir, you'd use something like this: `install_dir : get_option('libdir') + '/projectname-1.0'`.\n- `objects` list of prebuilt object files (usually for third party products you don't have source to) that should be linked in this target, **never** use this for object files that you build yourself.\n- `name_suffix` the string that will be used as the extension for the target by overriding the default. By default on Windows this is `exe` and on other platforms it is omitted.\n- `build_by_default` causes, when set to true, to have this target be built by default, that is, when invoking plain `ninja`, the default value is true for all built target types, since 0.38.0\n- `override_options` takes an array of strings in the same format as `project`'s `default_options` overriding the values of these options for this target only, since 0.40.0\n- `implib` when set to true, an import library is generated for the executable (the name of the import library is based on *exe_name*).  Alternatively, when set to a string, that gives the base name for the import library.  The import library is used when the returned build target object appears in `link_with:` elsewhere.  Only has any effect on platforms where that is meaningful (e.g. Windows).  Since 0.42.0\n- `implicit_include_directories` is a boolean telling whether Meson adds the current source and build directories to the include path, defaults to `true`, since 0.42.0\n\nThe list of `sources`, `objects`, and `dependencies` is always flattened, which means you can freely nest and add lists while creating the final list. As a corollary, the best way to handle a 'disabled dependency' is by assigning an empty list `[]` to it and passing it like any other dependency to the `dependencies:` keyword argument.\n\nThe returned object also has methods that are documented in the [object methods section](#build-target-object) below.\n\n### find_library()\n\nThis function is deprecated and in the 0.31.0 release it was moved to [the compiler object](#compiler-object) as obtained from `meson.get_compiler(lang)`.\n\n### find_program()\n\n``` meson\n    program find_program(program_name1, program_name2, ...)\n```\n\n`program_name1` here is a string that can be an executable or script to be searched for in `PATH`, or a script in the current source directory.\n\n`program_name2` and later positional arguments are used as fallback strings to search for. This is meant to be used for cases where the program may have many alternative names, such as `foo` and `foo.py`. The function will check for the arguments one by one and the first one that is found is returned. Meson versions earlier than 0.37.0 only accept one argument.\n\nKeyword arguments are the following:\n\n- `required` By default, `required` is set to `true` and Meson will abort if no program can be found. If `required` is set to `false`, Meson continue even if none of the programs can be found. You can then use the `.found()` method on the returned object to check whether it was found or not.\n\nMeson will also autodetect scripts with a shebang line and run them with the executable/interpreter specified in it both on Windows (because the command invocator will reject the command otherwise) and Unixes (if the script file does not have the executable bit set). Hence, you *must not* manually add the interpreter while using this script as part of a list of commands.\n\nIf you need to check for a program in a non-standard location, you can just pass an absolute path to `find_program`, e.g.\n```\nsetcap = find_program('setcap', '/usr/sbin/setcap', '/sbin/setcap', required : false)\n```\n\nIt is also possible to pass an array to `find_program` in case you need to construct the set of paths to search on the fly:\n```\nsetcap = find_program(['setcap', '/usr/sbin/setcap', '/sbin/setcap'], required : false)\n```\n\nThe returned object also has methods that are documented in the [object methods section](#external-program-object) below.\n\n### files()\n\n``` meson\n    file_array files(list_of_filenames)\n```\n\nThis command takes the strings given to it in arguments and returns corresponding File objects that you can use as sources for build targets. The difference is that file objects remember the subdirectory they were defined in and can be used anywhere in the source tree. As an example suppose you have source file `foo.cpp` in subdirectory `bar1` and you would like to use it in a build target that is defined in `bar2`. To make this happen you first create the object in `bar1` like this:\n\n```meson\n    foofile = files('foo.cpp')\n```\n\nThen you can use it in `bar2` like this:\n\n```meson\n    executable('myprog', 'myprog.cpp', foofile, ...)\n```\n\nMeson will then do the right thing.\n\n### generator()\n\n``` meson\n    generator_object gen(*executable*, ...)\n```\n\nSee also: [`custom_target`](#custom_target)\n\nThis function creates a [generator object](#generator-object) that can be used to run custom compilation commands. The only positional argument is the executable to use. It can either be a self-built executable or one returned by find_program. Keyword arguments are the following:\n\n- `arguments` a list of template strings that will be the command line arguments passed to the executable\n- `output` a template string (or list of template strings) defining how an output file name is (or multiple output names are) generated from a single source file name\n- `depfile` is a template string pointing to a dependency file that a generator can write listing all the additional files this target depends on, for example a C compiler would list all the header files it included, and a change in any one of these files triggers a recompilation\n\nThe returned object also has methods that are documented in the [object methods section](#generator-object) below.\n\nThe template strings passed to all the above keyword arguments accept the following special substitutions:\n\n- `@PLAINNAME@`: the complete input file name, e.g: `foo.c` becomes `foo.c` (unchanged)\n- `@BASENAME@`: the base of the input filename, e.g.: `foo.c.y` becomes `foo.c` (extension is removed)\n\nEach string passed to the `outputs` keyword argument *must* be constructed using one or both of these two substitutions.\n\nIn addition to the above substitutions, the `arguments` keyword argument also accepts the following:\n\n- `@OUTPUT@`: the full path to the output file\n- `@INPUT@`: the full path to the input file\n- `@SOURCE_DIR@`: the full path to the root of the source tree\n- `@CURRENT_SOURCE_DIR@`: this is the directory where the currently processed meson.build is located in\n- `@BUILD_DIR@`: the full path to the root of the build dir where the output will be placed\n\nNOTE: Generators should only be used for outputs that will ***only*** be used as inputs for a [build target](#build_target) or a [custom target](#custom_target). When you use the processed output of a generator in multiple targets, the generator will be run multiple times to create outputs for each target. Each output will be created in a target-private directory `@BUILD_DIR@`.\n\nIf you want to generate files for general purposes such as for generating headers to be used by several sources, or data that will be installed, and so on, use a [`custom_target`](#custom_target) instead.\n\n### get_option()\n\n``` meson\n    value get_option(option_name)\n```\n\nObtains the value of the [project build option](Build-options.md) specified in the positional argument.\n\n### get_variable()\n\n``` meson\n    value get_variable(variable_name, fallback)\n```\n\nThis function can be used to dynamically obtain a variable. `res = get_variable(varname, fallback)` takes the value of `varname` (which must be a string) and stores the variable of that name into `res`. If the variable does not exist, the variable `fallback` is stored to `res`instead. If a fallback is not specified, then attempting to read a non-existing variable will cause a fatal error.\n\n### import()\n\n``` meson\n    module_object import(module_name)\n```\n\nImports the given extension module. Returns an opaque object that can be used to call the methods of the module. Here's an example for a hypothetical `testmod` module.\n\n```meson\n    tmod = import('testmod')\n    tmod.do_something()\n```\n\n### include_directories()\n\n``` meson\n    include_object include_directories(directory_names, ...)\n```\n\nReturns an opaque object which contains the directories (relative to the current directory) given in the positional arguments. The result can then be passed to the `include_directories:` keyword argument when building executables or libraries. You can use the returned object in any subdirectory you want, Meson will make the paths work automatically.\n\nNote that this function call itself does not add the directories into the search path, since there is no global search path. For something like that, see [`add_project_arguments()`](#add_project_arguments).\n\nEach directory given is converted to two include paths: one that is relative to the source root and one relative to the build root.\n\nFor example, with the following source tree layout in `/home/user/project.git`:\n\n`meson.build`:\n```meson\nproject(...)\n\nsubdir('include')\nsubdir('src')\n\n...\n```\n\n`include/meson.build`:\n```meson\ninc = include_directories('.')\n\n...\n```\n\n`src/meson.build`:\n```meson\nsources = [...]\n\nexecutable('some-tool', sources,\n  include_directories : inc,\n  ...)\n\n...\n```\n\nIf the build tree is `/tmp/build-tree`, the following include paths will be added to the `executable()` call: `-I/tmp/build-tree/include -I/home/user/project.git/include`.\n\nThis function has one keyword argument `is_system` which, if set, flags the specified directories as system directories. This means that they will be used with the `-isystem` compiler argument rather than `-I` on compilers that support this flag (in practice everything except Visual Studio).\n\n### install_data()\n\n``` meson\n    void install_data(list_of_files, ...)\n```\n\nInstalls files from the source tree that are listed as positional arguments. The following keyword arguments are supported:\n\n- `install_dir` the absolute or relative path to the installation directory. If this is a relative path, it is assumed to be relative to the prefix.\n- `install_mode` specify the file mode in symbolic format and optionally the owner/uid and group/gid for the installed files. For example:\n\n  `install_mode: 'rw-r--r--'` for just the file mode\n\n  `install_mode: ['rw-r--r--', 'nobody', 'nobody']` for the file mode and the user/group\n\n  `install_mode: ['rw-r-----', 0, 0]` for the file mode and uid/gid\n\n To leave any of these three as the default, specify `false`.\n\n### install_headers()\n\n``` meson\n    void install_headers(list_of_headers, ...)\n```\n\nInstalls the specified header files from the source tree into the system header directory (usually `/{prefix}/include`) during the install step. This directory can be overridden by specifying it with the `install_dir` keyword argument. If you just want to install into a subdirectory of the system header directory, then use the `subdir` argument. As an example if this has the value `myproj` then the headers would be installed to `/{prefix}/include/myproj`.\n\nFor example, this will install `common.h` and `kola.h` into `/{prefix}/include`:\n\n```meson\ninstall_headers('common.h', 'proj/kola.h')\n```\n\nThis will install `common.h` and `kola.h` into `/{prefix}/include/myproj`:\n\n```meson\ninstall_headers('common.h', 'proj/kola.h', subdir : 'myproj')\n```\n\nThis will install `common.h` and `kola.h` into `/{prefix}/cust/myproj`:\n\n```meson\ninstall_headers('common.h', 'proj/kola.h', install_dir : 'cust', subdir : 'myproj')\n```\n\n### install_man()\n\n``` meson\n    void install_man(list_of_manpages, ...)\n```\n\nInstalls the specified man files from the source tree into system's man directory during the install step. This directory can be overridden by specifying it with the `install_dir` keyword argument. All man pages are compressed during installation and installed with a `.gz` suffix.\n\n### install_subdir()\n\n``` meson\n    void install_subdir(subdir_name, install_dir : ..., exclude_files : ..., exclude_directories : ...)\n```\n\nInstalls the entire given subdirectory and its contents from the source tree to the location specified by the keyword argument `install_dir`. Note that due to implementation issues this command deletes the entire target dir before copying the files, so you should never use `install_subdir` to install into two overlapping directories (such as `foo` and `foo/bar`) because if you do the behavior is undefined.\n\nThe following keyword arguments are supported:\n\n- `install_dir`: the location to place the installed subdirectory.\n- `exclude_files`: a list of file names that should not be installed.\n  Names are interpreted as paths relative to the `subdir_name` location.\n- `exclude_directories`: a list of directory names that should not be installed.\n  Names are interpreted as paths relative to the `subdir_name` location.\n\n### is_variable()\n\n``` meson\n    bool is_variable(varname)\n```\n\nReturns true if a variable of the given name exists and false otherwise.\n\n### jar()\n\n```meson\n   jar_object jar(name, list_of_sources, ...)\n```\n\nBuild a jar from the specified Java source files. Keyword arguments are the same as [`executable`](#executable)'s, with the addition of `main_class` which specifies the main class to execute when running the jar with `java -jar file.jar`.\n\n### join_paths()\n\n``` meson\n   string join_paths(string1, string2, ...)\n```\n\nJoins the given strings into a file system path segment. For example `join_paths('foo', 'bar')` results in `foo/bar`. If any one of the individual segments is an absolute path, all segments before it are dropped. That means that `join_paths('foo', '/bar')` returns `/bar`.\n\n*Added 0.36.0*\n\n### library()\n\n``` meson\n    buildtarget library(library_name, list_of_sources, ...)\n```\n\nBuilds a library that is either static or shared depending on the value of `default_library` user option. You should use this instead of [`shared_library`](#shared_library) or [`static_library`](#static_library) most of the time. This allows you to toggle your entire project (including subprojects) from shared to static with only one option.\n\nThe keyword arguments for this are the same as for [`executable`](#executable) with the following additions:\n\n- `name_prefix` the string that will be used as the suffix for the target by overriding the default (only used for libraries). By default this is `lib` on all platforms and compilers except with MSVC where it is omitted.\n- `rust_crate_type` specifies the crate type for Rust libraries. Defaults to `dylib` for shared libraries and `rlib` for static libraries.\n\n`static_library` and `shared_library` also accept these keyword arguments.\n\n### message()\n\n``` meson\n    void message(text)\n```\n\nThis function prints its argument to stdout.\n\n### project()\n\n``` meson\n    void project(project_name, list_of_languages, ...)\n```\n\nThe first argument to this function must be a string defining the name of this project. It must be followed by one or more programming languages that the project uses. Supported values for languages are `c`, `cpp` (for `C++`), `objc`, `objcpp`, `fortran`, `java`, `cs` (for `C#`) and `vala`.\n\nThe project name can be any string you want, it's not used for anything except descriptive purposes. However since it is written to e.g. the dependency manifest is usually makes sense to have it be the same as the project tarball or pkg-config name. So for example you would probably want to use the name _libfoobar_ instead of _The Foobar Library_.\n\nProject supports the following keyword arguments.\n\n - `version`, which is a free form string describing the version of this project. You can access the value in your Meson build files with `meson.project_version()`.\n\n - `subproject_dir` specifies the top level directory name that holds Meson subprojects. This is only meant as a compatibility option for existing code bases that house their embedded source code in a custom directory. All new projects should not set this but instead use the default value. It should be noted that this keyword argument is ignored inside subprojects. There can be only one subproject dir and it is set in the top level Meson file.\n\n  - `meson_version` takes a string describing which Meson version the project requires. Usually something like `>0.28.0`.\n\n  - `license` takes a string or array of strings describing the license(s) the code is under. Usually this would be something like `license : 'GPL2+'`, but if the code has multiple licenses you can specify them as an array like this: `license : ['proprietary', 'GPL3']`. Note that the text is informal and is only written to the dependency manifest. Meson does not do any license validation, you are responsible for verifying that you abide by all licensing terms.\n\n - `default_options` takes an array of strings. The strings are in the form `key=value` and have the same format as options to `mesonconf`. For example to set the default project type you would set this: `default_options : ['buildtype=debugoptimized']`. Note that these settings are only used when running Meson for the first time. Global options such as `buildtype` can only be specified in the master project, settings in subprojects are ignored. Project specific options are used normally even in subprojects.\n\n### run_command()\n\n``` meson\n    runresult run_command(command, list_of_args)\n```\n\nRuns the command specified in positional arguments. Returns [an opaque object](#run-result-object) containing the result of the invocation. The script is run from an *unspecified* directory, and Meson will set three environment variables `MESON_SOURCE_ROOT`, `MESON_BUILD_ROOT` and `MESON_SUBDIR` that specify the source directory, build directory and subdirectory the target was defined in, respectively.\n\n### run_target\n\n``` meson\n    buildtarget run_target(target_name, ...)\n```\n\nThis function creates a new top-level target that runs a specified command with the specified arguments. Like all top-level targets, this integrates with the selected backend. For instance, with Ninja you can run it as `ninja target_name`.\n\nThe script is run from an *unspecified* directory, and Meson will set three environment variables `MESON_SOURCE_ROOT`, `MESON_BUILD_ROOT` and `MESON_SUBDIR` that specify the source directory, build directory and subdirectory the target was defined in, respectively.\n\n - `command` is a list containing the command to run and the arguments to pass to it. Each list item may be a string or a target. For instance, passing the return value of [`executable()`](#executable) as the first item will run that executable, or passing a string as the first item will find that command in `PATH` and run it.\n - `depends` is a list of targets that this target depends on but which are not listed in the command array (because, for example, the script does file globbing internally)\n\n### set_variable()\n\n``` meson\n    void set_variable(variable_name, value)\n```\n\nAssigns a value to the given variable name. Calling `set_variable('foo', bar)` is equivalent to `foo = bar`.\n\n### shared_library()\n\n``` meson\n    buildtarget shared_library(library_name, list_of_sources, ...)\n```\n\nBuilds a shared library with the given sources. Positional and keyword arguments are the same as for [`library`](#library) with the following extra keyword arguments.\n\n- `version` a string specifying the version of this shared library, such as `1.1.0`. On Linux and OS X, this is used to set the shared library version in the filename, such as `libfoo.so.1.1.0` and `libfoo.1.1.0.dylib`. If this is not specified, `soversion` is used instead (see below).\n- `soversion` a string specifying the soversion of this shared library, such as `0`. On Linux and Windows this is used to set the soversion (or equivalent) in the filename. For example, if `soversion` is `4`, a Windows DLL will be called `foo-4.dll` and one of the aliases of the Linux shared library would be `libfoo.so.4`. If this is not specified, the first part of `version` is used instead. For example, if `version` is `3.6.0` and `soversion` is not defined, it is set to `3`.\n- `vs_module_defs` a string, a File object, or Custom Target for a Microsoft module definition file for controlling symbol exports, etc., on platforms where that is possible (e.g. Windows).\n\n### shared_module()\n\n``` meson\n    buildtarget shared_module(module_name, list_of_sources, ...)\n```\n\nBuilds a shared module with the given sources. Positional and keyword arguments are the same as for [`library`](#library).\n\nThis is useful for building modules that will be `dlopen()`ed and hence may contain undefined symbols that will be provided by the library that is loading it.\n\n*Added 0.37.0*\n\n### static_library()\n\n``` meson\n    buildtarget static_library(library_name, list_of_sources, ...)\n```\n\nBuilds a static library with the given sources. Positional and keyword arguments are otherwise the same as for [`library`](#library), but it has one argument the others don't have:\n\n - `pic`, (*Added 0.36.0*) builds the library as positional independent code (so it can be linked into a shared library). This option has no effect on Windows and OS X since it doesn't make sense on Windows and PIC cannot be disabled on OS X.\n\n### subdir()\n\n``` meson\n    void subdir(dir_name)\n```\n\nEnters the specified subdirectory and executes the `meson.build` file in it. Once that is done, it returns and execution continues on the line following this `subdir()` command. Variables defined in that `meson.build` file are then available for use in later parts of the current build file and in all subsequent build files executed with `subdir()`.\n\nNote that this means that each `meson.build` file in a source tree can and must only be executed once.\n\n### subproject()\n\n``` meson\n    subproject_object subproject(subproject_name, ...)\n```\n\nTakes the project specified in the positional argument and brings that in the current build specification by returning a [subproject object](#subproject-object). Subprojects must always be placed inside the `subprojects` directory at the top source directory. So for example a subproject called `foo` must be located in `${MESON_SOURCE_ROOT}/subprojects/foo`. Supports the following keyword arguments:\n\n - `version` keyword argument that works just like the one in `dependency`. It specifies what version the subproject should be, as an example `>=1.0.1`\n - `default_options`, *(added 0.37.0)* an array of default option values that override those set in the project's `default_options` invocation (like `default_options` in `project`, they only have effect when Meson is run for the first time, and command line arguments override any default options in build files)\n\nNote that you can use the returned [subproject object](#subproject-object) to access any variable in the subproject. However, if you want to use a dependency object from inside a subproject, an easier way is to use the `fallback:` keyword argument to [`dependency()`](#dependency).\n\n### test()\n\n``` meson\n    void test(name, executable, ...)\n```\n\nDefines a unit test. Takes two positional arguments, the first is the name of this test and the second is the executable to run. Keyword arguments are the following.\n\n- `args` arguments to pass to the executable\n- `env` environment variables to set, such as `['NAME1=value1', 'NAME2=value2']`, or an [`environment()` object](#environment-object) which allows more sophisticated environment juggling\n- `is_parallel` when false, specifies that no other test must be running at the same time as this test\n- `should_fail` when true the test is considered passed if the executable returns a non-zero return value (i.e. reports an error)\n- `timeout` the amount of seconds the test is allowed to run, a test that exceeds its time limit is always considered failed, defaults to 30 seconds\n- `workdir` absolute path that will be used as the working directory for the test\n\nDefined tests can be run in a backend-agnostic way by calling `mesontest` inside the build dir, or by using backend-specific commands, such as `ninja test` or `msbuild RUN_TESTS.vcxproj`.\n\n### vcs_tag()\n\n``` meson\n    customtarget vcs_tag(...)\n```\n\nThis command detects revision control commit information at build time and places it in the specified output file. This file is guaranteed to be up to date on every build. Keywords are similar to `custom_target`.\n\n- `input` file to modify (e.g. `version.c.in`) (required)\n- `output` file to write the results to (e.g. `version.c`) (required)\n- `fallback` version number to use when no revision control information is present, such as when building from a release tarball (defaults to `meson.project_version()`)\n- `command` string list with the command to execute, see [`custom_target`](#custom_target) for details on how this command must be specified\n- `replace_string` string in the input file to substitute with the commit information (defaults to `@VCS_TAG@`)\n\nMeson will read the contents of `input`, substitute the `replace_string` with the detected revision number, and write the result to `output`. This method returns an opaque [`custom_target`](#custom_target) object that can be used as source. If you desire more specific behavior than what this command provides, you should use `custom_target`.\n\n## Built-in objects\n\nThese are built-in objects that are always available.\n\n### `meson` object\n\nThe `meson` object allows you to introspect various properties of the system. This object is always mapped in the `meson` variable. It has the following methods.\n\n- `get_compiler(language)` returns [an object describing a compiler](#compiler-object), takes one positional argument which is the language to use. It also accepts one keyword argument, `native` which when set to true makes Meson return the compiler for the build machine (the \"native\" compiler) and when false it returns the host compiler (the \"cross\" compiler). If `native` is omitted, Meson returns the \"cross\" compiler if we're currently cross-compiling and the \"native\" compiler if we're not.\n\n- `backend()` *(added 0.37.0)* returns a string representing the current backend: `ninja`, `vs2010`, `vs2015`, `vs2017`, or `xcode`.\n\n- `is_cross_build()` returns `true` if the current build is a [cross build](Cross-compilation.md) and `false` otherwise.\n\n- `is_unity()` returns `true` when doing a [unity build](Unity-builds.md) (multiple sources are combined before compilation to reduce build time) and `false` otherwise.\n\n- `is_subproject()` returns `true` if the current project is being built as a subproject of some other project and `false` otherwise.\n\n- `has_exe_wrapper()` returns true when doing a cross build if there is a wrapper command that can be used to execute cross built binaries (for example when cross compiling from Linux to Windows, one can use `wine` as the wrapper).\n\n- `add_install_script(script_name, arg1, arg2, ...)` causes the script given as an argument to be run during the install step, this script will have the environment variables `MESON_SOURCE_ROOT`, `MESON_BUILD_ROOT`, `MESON_INSTALL_PREFIX`, `MESON_INSTALL_DESTDIR_PREFIX`, and `MESONINTROSPECT` set. All additional arguments are passed as parameters.\n\n  To determine the installation location, the script should use the `DESTDIR`, `MESON_INSTALL_PREFIX`, `MESON_INSTALL_DESTDIR_PREFIX` variables. `DESTDIR` will be set only if it is inherited from the outside environment. `MESON_INSTALL_PREFIX` is always set and has the value of the `prefix` option passed to Meson. `MESON_INSTALL_DESTDIR_PREFIX` is always set and contains `DESTDIR` and `prefix` joined together. This is useful because both are absolute paths, and many path-joining functions such as [`os.path.join` in Python](https://docs.python.org/3/library/os.path.html#os.path.join) special-case absolute paths.\n\n  `MESONINTROSPECT` contains the path to the `mesonintrospect` executable that corresponds to the `meson` executable that was used to configure the build. (This might be a different path then the first `mesonintrospect` executable found in `PATH`.) It can be used to query build configuration.\n\n- `add_postconf_script(script_name, arg1, arg2, ...)` will run the executable given as an argument after all project files have been generated. This script will have the environment variables `MESON_SOURCE_ROOT` and `MESON_BUILD_ROOT` set.\n\n- `current_source_dir()` returns a string to the current source directory. Note: **you do not need to use this function** when passing files from the current source directory to a function since that is the default. Also, you can use the `files()` function to refer to files in the current or any other source directory instead of constructing paths manually with `meson.current_source_dir()`.\n\n- `current_build_dir()` returns a string with the absolute path to the current build directory.\n\n- `source_root()` returns a string with the absolute path to the source root directory. Note: you should use the `files()` function to refer to files in the root source directory instead of constructing paths manually with `meson.source_root()`.\n\n- `build_root()` returns a string with the absolute path to the build root directory.\n\n- `project_version()` returns the version string specified in `project` function call.\n\n- `project_name()` returns the project name specified in the `project` function call.\n\n- `version()` return a string with the version of Meson.\n\n- `get_cross_property(propname, fallback_value)` returns the given property from a cross file, the optional second argument is returned if not cross compiling or the given property is not found.\n\n- `install_dependency_manifest(output_name)` installs a manifest file containing a list of all subprojects, their versions and license files to the file name given as the argument.\n\n### `build_machine` object\n\nProvides information about the build machine \u2014 the machine that is doing the actual compilation. See [Cross-compilation](Cross-compilation.md). It has the following methods:\n\n- `cpu_family()` returns the CPU family name. Guaranteed to return `x86` for 32-bit userland on x86 CPUs, `x86_64` for 64-bit userland on x86 CPUs, `arm` for 32-bit userland on all ARM CPUs, etc.\n- `cpu()` returns a more specific CPU name, such as `i686`, `amd64`, etc.\n- `system()` returns the operating system name, such as `windows` (all versions of Windows), `linux` (all Linux distros), `darwin` (all versions of OS X/macOS), `cygwin` (for Cygwin), and `bsd` (all *BSD OSes).\n- `endian()` returns `big` on big-endian systems and `little` on little-endian systems.\n\nCurrently, these values are populated using [`platform.system()`](https://docs.python.org/3.4/library/platform.html#platform.system) and [`platform.machine()`](https://docs.python.org/3.4/library/platform.html#platform.machine). If you think the returned values for any of these are incorrect for your system or CPU, or if your OS is not in the above list, please file [a bug report](https://github.com/mesonbuild/meson/issues/new) with details and we'll look into it.\n\n### `host_machine` object\n\nProvides information about the host machine \u2014 the machine on which the compiled binary will run. See [Cross-compilation](Cross-compilation.md).\n\nIt has the same methods as [`build_machine`](#build_machine-object).\n\nWhen not cross-compiling, all the methods return the same values as `build_machine` (because the build machine is the host machine)\n\nNote that while cross-compiling, it simply returns the values defined in the cross-info file.\n\n### `target_machine` object\n\nProvides information about the target machine \u2014 the machine on which the compiled binary's output will run. Hence, this object should only be used while cross-compiling a compiler. See [Cross-compilation](Cross-compilation.md).\n\nIt has the same methods as [`build_machine`](#build_machine-object).\n\nWhen all compilation is 'native', all the methods return the same values as `build_machine` (because the build machine is the host machine and the target machine).\n\nNote that while cross-compiling, it simply returns the values defined in the cross-info file. If `target_machine` values are not defined in the cross-info file, `host_machine` values are returned instead.\n\n### `compiler` object\n\nThis object is returned by [`meson.get_compiler(lang)`](#meson-object). It represents a compiler for a given language and allows you to query its properties. It has the following methods:\n\n- `get_id()` returns a string identifying the compiler. For example, `gcc`, `msvc`, [and more](Compiler-properties.md#compiler-id).\n- `version()` returns the compiler's version number as a string.\n- `find_library(lib_name, ...)` tries to find the library specified in the positional argument. The [result object](#external-library-object) can be used just like the return value of `dependency`. If the keyword argument `required` is false, Meson will proceed even if the library is not found. By default the library is searched for in the system library directory (e.g. /usr/lib). This can be overridden with the `dirs` keyword argument, which can be either a string or a list of strings.\n- `sizeof(typename, ...)` returns the size of the given type (e.g. `'int'`) or -1 if the type is unknown, to add includes set them in the `prefix` keyword argument, you can specify external dependencies to use with `dependencies` keyword argument.\n- `alignment(typename)` returns the alignment of the type specified in the positional argument, you can specify external dependencies to use with `dependencies` keyword argument.\n- `compiles(code)` returns true if the code fragment given in the positional argument compiles, you can specify external dependencies to use with `dependencies` keyword argument, `code` can be either a string containing source code or a `file` object pointing to the source code.\n- `links(code)` returns true if the code fragment given in the positional argument compiles and links, you can specify external dependencies to use with `dependencies` keyword argument, `code` can be either a string containing source code or a `file` object pointing to the source code.\n- `run(code)` attempts to compile and execute the given code fragment, returns a run result object, you can specify external dependencies to use with `dependencies` keyword argument, `code` can be either a string containing source code or a `file` object pointing to the source code.\n- `has_header` returns true if the specified header can be included, you can specify external dependencies to use with `dependencies` keyword argument and extra code to put above the header test with the `prefix` keyword. In order to look for headers in a specific directory you can use `args : '-I/extra/include/dir`, but this should only be used in exceptional cases for includes that can't be detected via pkg-config and passed via `dependencies`.\n- `has_type(typename)` returns true if the specified token is a type, you can specify external dependencies to use with `dependencies` keyword argument.\n- `has_function(funcname)` returns true if the given function is provided by the standard library or a library passed in with the `args` keyword, you can specify external dependencies to use with `dependencies` keyword argument.\n- `has_member(typename, membername)` takes two arguments, type name and member name and returns true if the type has the specified member, you can specify external dependencies to use with `dependencies` keyword argument.\n- `has_members(typename, membername1, membername2, ...)` takes at least two arguments, type name and one or more member names, returns true if the type has all the specified members, you can specify external dependencies to use with `dependencies` keyword argument.\n- `has_header_symbol(headername, symbolname)` allows one to detect whether a particular symbol (function, variable, #define, type definition, etc) is declared in the specified header, you can specify external dependencies to use with `dependencies` keyword argument.\n- `has_argument(argument_name)` returns true if the compiler accepts the specified command line argument, that is, can compile code without erroring out or printing a warning about an unknown flag, you can specify external dependencies to use with `dependencies` keyword argument.\n- `has_multi_arguments(arg1, arg2, arg3, ...)` is the same as `has_argument` but takes multiple arguments and uses them all in a single compiler invocation, available since 0.37.0.\n- `first_supported_argument(list_of_strings)`, given a list of strings, returns the first argument that passes the `has_argument` test above or an empty array if none pass.\n- `symbols_have_underscore_prefix()` returns `true` if the C symbol mangling is one underscore (`_`) prefixed to the symbol, available since 0.37.0.\n- `compute_int(expr, ...')` computes the value of the given expression (as an example `1 + 2`). When cross compiling this is evaluated with an iterative algorithm, you can specify keyword arguments `low` (defaults to -1024), `high` (defaults to 1024) and `guess` to specify max and min values for the search and the value to try first.\n- `get_define(definename)` returns the given preprocessor symbol's value as a string or empty string if it is not defined.\n\nThe following keyword arguments can be used:\n\n- `name` the name to use for printing a message about the compiler check. Supported by the methods `compiles()`, `links()`, and `run()`. If this keyword argument is not passed to those methods, no message will be printed about the check.\n\n- `prefix` can be used to add #includes and other things that are required for the symbol to be declared. System definitions should be passed via compiler args (eg: `_GNU_SOURCE` is often required for some symbols to be exposed on Linux, and it should be passed via `args` keyword argument, see below). Supported by the methods `sizeof`, `has_type`, `has_function`, `has_member`, `has_members`, `has_header_symbol`.\n\n- `include_directories` specifies extra directories for header searches. *(added 0.38.0)*\n\n- `args` can be used to pass a list of compiler arguments that are required to find the header or symbol. For example, you might need to pass the include path `-Isome/path/to/header` if a header is not in the default include path. In versions newer than 0.38.0 you should use the `include_directories` keyword described above. You may also want to pass a library name `-lfoo` for `has_function` to check for a function. Supported by all methods except `get_id`, `version`, and `find_library`.\n\nNote that if you have a single prefix with all your dependencies, you might find it easier to append to the environment variables `C_INCLUDE_PATH` with GCC/Clang and `INCLUDE` with MSVC to expand the default include path, and `LIBRARY_PATH` with GCC/Clang and `LIB` with MSVC to expand the default library search path.\n\nHowever, with GCC, these variables will be ignored when cross-compiling. In that case you need to use a specs file. See: <http://www.mingw.org/wiki/SpecsFileHOWTO>\n\n### `string` object\n\nAll [strings](Syntax.md#strings) have the following methods. Strings are immutable, all operations return their results as a new string.\n\n - `strip()` removes whitespace at the beginning and end of the string\n - `format()` formats text, see the [Syntax manual](Syntax.md#string-formatting) for usage info\n - `to_upper()` creates an upper case version of the string\n - `to_lower()` creates a lower case version of the string\n - `underscorify()` creates a string where every non-alphabetical non-number character is replaced with `_`\n - `split(split_character)` splits the string at the specified character (or whitespace if not set) and returns the parts in an array\n - `startswith(string)` returns true if string starts with the string specified as the argument\n - `endswith(string)` returns true if string ends with the string specified as the argument\n - `contains(string)` returns true if string contains the string specified as the argument\n - `to_int` returns the string converted to an integer (error if string is not a number)\n - `join(list_of_strings)` is the opposite of split, for example `'.'.join(['a', 'b', 'c']` yields `'a.b.c'`\n - `version_compare(comparison_string)` does semantic version comparison, if `x = '1.2.3'` then `x.version_compare('>1.0.0')` returns `true`\n\n### `Number` object\n\n[Numbers](Syntax.md#numbers) support these methods:\n\n - `is_even()` returns true if the number is even\n - `is_odd()` returns true if the number is odd\n\n### `boolean` object\n\nA [boolean](Syntax.md#booleans) object has two simple methods:\n\n - `to_string()` returns the string `'true'` if the boolean is true or `'false'` otherwise. You can also pass it two strings as positional arguments to specify what to return for true/false. For instance, `bool.to_string('yes', 'no')` will return `yes` if the boolean is true and `no` if it is false.\n - `to_int()` as above, but returns either `1` or `0`\n\n### `array` object\n\nThe following methods are defined for all [arrays](Syntax.md#arrays):\n\n - `length()`, the size of the array\n - `contains(item)`, returns `true` if the array contains the object given as argument, `false` otherwise\n - `get(index, fallback)`, returns the object at the given index, negative indices count from the back of the array, indexing out of bounds returns the `fallback` value *(added 0.38.0)* or, if it is not specified, causes a fatal error\n\nYou can also iterate over arrays with the [`foreach` statement](https://github.com/mesonbuild/meson/wiki/Syntax#foreach-statements).\n\n## Returned objects\n\nThese are objects returned by the [functions listed above](#functions).\n\n### `build target` object\n\nA build target is either an [executable](#executable), [shared](#shared_library), [static library](#static_library) or [shared module](#shared_module).\n\n- `extract_objects()` returns an opaque value representing the generated object files of arguments, usually used to take single object files and link them to unit tests or to compile some source files with custom flags. To use the object file(s) in another build target, use the `objects:` keyword argument.\n\n- `extract_all_objects()` is same as above but returns all object files generated by this target\n\n- `private_dir_include()` returns a opaque value that works like `include_directories` but points to the private directory of this target, usually only needed if an another target needs to access some generated internal headers of this target\n\n- `full_path()` returns a full path pointing to the result target file\n\n### `configuration` data object\n\nThis object is returned by [`configuration_data()`](#configuration_data) and encapsulates configuration values to be used for generating configuration files. A more in-depth description can be found in the [the configuration wiki page](Configuration.md) It has three methods:\n\n - `set(varname, value)`, sets a variable to a given value\n - `set10(varname, boolean_value)` is the same as above but the value is either `true` or `false` and will be written as 1 or 0, respectively\n - `set_quoted(varname, value)` is same as `set` but quotes the value in double quotes (`\"`)\n - `has(varname)`, returns `true` if the specified variable is set\n - `get(varname, default_value)` returns the value of `varname`, if the value has not been set returns `default_value` if it is defined *(added 0.38.0)* and errors out if not\n\nThey all take the `description` keyword that will be written in the result file. The replacement assumes a file with C syntax. If your generated file is source code in some other language, you probably don't want to add a description field because it most likely will cause a syntax error.\n\n### `custom target` object\n\nThis object is returned by [`custom_target`](#custom_target) and contains a target with the following methods:\n\n- `full_path()` returns a full path pointing to the result target file\n\n### `dependency` object\n\nThis object is returned by [`dependency()`](#dependency) and contains an external dependency with the following methods:\n\n - `found()` which returns whether the dependency was found\n - `type_name()` which returns a string describing the type of the dependency, the most common values are `internal` for deps created with `declare_dependencies` and `pkgconfig` for system dependencies obtained with Pkg-config.\n - `version()` is the version number as a string, for example `1.2.8`\n - `get_pkgconfig_variable(varname)` (*Added 0.36.0*) will get the pkg-config variable specified, or, if invoked on a non pkg-config dependency, error out\n\n### `external program` object\n\nThis object is returned by [`find_program()`](#find_program) and contains an external (i.e. not built as part of this project) program and has the following methods:\n\n- `found()` which returns whether the executable was found\n- `path()` which returns an array pointing to the executable (this is an array as opposed to a string because the program might be `['python', 'foo.py']`, for example)\n\n### `environment` object\n\nThis object is returned by [`environment()`](#environment) and stores detailed information about how environment variables should be set during tests. It should be passed as the `env` keyword argument to tests. It has the following methods.\n\n-   `set(varname, value)` sets environment variable in the first\n    argument to the value in the second argument, e.g.\n    `env.set('FOO', 'BAR') sets envvar`FOO`to value`BAR\\`\n-   `append(varname, value)` appends the given value to the old value of\n    the environment variable, e.g.\n    `env.append'('FOO', 'BAR', separator : ';')` produces `BOB;BAR` if\n    `FOO` had the value `BOB` and plain `BAR` if the value was not\n    defined. If the separator is not specified explicitly, the default\n    path separator for the host operating system will be used, i.e. ';'\n    for Windows and ':' for UNIX/POSIX systems.\n-   `prepend(varname, value)` is the same as `append` except that it\n    writes to the beginning of the variable\n\n\n### `external library` object\n\nThis object is returned by [`find_library()`](#find_library) and contains an external (i.e. not built as part of this project) library. This object has only one method, `found`, which returns whether the library was found.\n\n### `generator` object\n\nThis object is returned by [`generator()`](#generator) and contains a generator that is used to transform files from one type to another by an executable (e.g. `idl` files into source code and headers).\n\n* `process(list_of_files)` takes a list of files, causes them to be processed and returns an object containing the result which can then, for example, be passed into a build target definition. The keyword argument `extra_args`, if specified, will be used to replace an entry `@EXTRA_ARGS@` in the argument list.\n\n### `subproject` object\n\nThis object is returned by [`subproject()`](#subproject) and is an opaque object representing it.\n\n- `get_variable(name)` fetches the specified variable from inside the\n  subproject. This is useful to, for instance, get a [declared\n  dependency](#declare_dependency) from the subproject.\n\n### `run result` object\n\nThis object encapsulates the result of trying to compile and run a sample piece of code with [`compiler.run()`](#compiler-object) or [`run_command()`](#run_command). It has the following methods:\n\n- `compiled()` if true, the compilation succeeded, if false it did not and the other methods return unspecified data\n- `returncode()` the return code of executing the compiled binary\n- `stdout()` the standard out produced when the binary was run\n- `stderr()` the standard error produced when the binary was run\n",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/docs/markdown/Release-notes-for-0.37.0.md": "---\ntitle: Release 0.37\nshort-description: Release notes for 0.37\n...\n\n# New features\n\n## Mesontest\n\nMesontest is a new testing tool that allows you to run your tests in many different ways. As an example you can run tests multiple times:\n\n    mesontest --repeat=1000 a_test\n\nor with an arbitrary wrapper executable:\n\n    mesontest --wrap='valgrind --tool=helgrind' a_test\n\nor under `gdb`, 1000 times in a row. This is handy for tests that fail spuriously, as when the crash happens you are given the full GDB command line:\n\n    mesontest --repeat=1000 --gdb a_test\n\n## Mesonrewriter\n\nMesonrewriter is an experimental tool to manipulate your build definitions programmatically. It is not installed by default yet but those interested can run it from the source repository.\n\nAs an example, here is how you would add a source file to a build target:\n\n    mesonrewriter add --target=program --filename=new_source.c\n\n## Shared modules\n\nThe new `shared_module` function allows the creation of shared modules, that is, extension modules such as plugins that are meant to be used solely with `dlopen` rather than linking them to targets.\n\n## Gnome module\n\n- Detect required programs and print useful errors if missing\n\n### gtkdoc\n\n- Allow passing a list of directories to `src_dir` keyword argument\n- Add `namespace` keyword argument\n- Add `mode` keyword argument\n- Fix `gtkdoc-scangobj` finding local libraries\n\n### compile_resources\n\n- Add `gresource_bundle` keyword argument to output `.gresource` files\n- Add `export` and `install_header` keyword arguments\n- Use depfile support available in GLib >= 2.52.0\n\n## i18n module\n\n- Add `merge_file()` function for creating translated files\n- Add `preset` keyword argument to included common gettext flags\n- Read languages from `LINGUAS` file\n\n## LLVM IR compilation\n\nMeson has long had support for compiling assembler (GAS) files. In this release we add support for compiling LLVM IR files in a similar way when building with the Clang compiler. Just add it to the list of files when creating a `library` or `executable` target like any other source file. No special handling is required:\n\n```meson\nexecutable('some-exe', 'main.c', 'asm-file.S', 'ir-file.ll')\n```\n\nAs always, you can also mix LLVM IR files with C++, C, and Assembly (GAS) sources.\n\n## ViM indent and syntax files\n\nWe now include filetype, indent, and syntax files for ViM [with the source tree](https://github.com/mesonbuild/meson/tree/master/syntax-highlighting/vim). Please file issues (or pull requests!) for enhancements or if you face any problems using them.\n\n## Push URLs in .wrap files\n\n[.wrap files](Using-the-WrapDB.md) for subprojects can now include a separate push URL to allow developers to push changes directly from a subproject git checkout.\n\n## pkg-config dependencies\n\nMeson now supports multiple version restrictions while searching for pkg-config dependencies.\n\n```meson\n# Just want a lower limit\ndependency('zlib', version : '>1.2.1')\n# Want both a lower and an upper limit\ndependency('opencv', version : ['>=2.3.0', '<=3.1.0'])\n# Want to exclude one specific broken version\ndependency('foolite', version : ['>=3.12.1', '!=3.13.99'])\n```\n\n## Overriding more binaries with environment variables\n\nYou can now specify the binary to be used for the following tools by setting the corresponding environment variable\n\n| Name | Environment variable |\n| ---- | -------------------- |\n| pkg-config | PKG_CONFIG     |\n| readelf    | READELF        |\n| nm         | NM             |\n\n## Support for `localstatedir`\n\nSimilar to other options such as `bindir` and `datadir`, you can now specify the `localstatedir` for a project by passing `--localstatedir=dir` to `meson` or `-Dlocalstatedir=dir` to `mesonconf` after configuration. You can also access it from inside the `meson.build` file with `get_option('localstatedir')`.\n\n## New compiler function `symbols_have_underscore_prefix`\n\nChecks if the compiler prefixes an underscore to C global symbols with the default calling convention. This is useful when linking to compiled assembly code, or other code that does not have its C symbol mangling handled transparently by the compiler.\n\n```meson\ncc = meson.get_compiler('c')\nconf = configuration_data()\nif cc.symbols_have_underscore_prefix()\n    conf.set('SYMBOLS_HAVE_UNDERSCORE', true)\nendif\n```\n\nC symbol mangling is platform and architecture dependent, and a helper function is needed to detect it. For example, Windows 32-bit prefixes underscore, but 64-bit does not. Linux does not prefix an underscore but OS X does.\n\n## Vala\n\nGLib Resources compiled with [`gnome.compile_resources`](Gnome-module.md#compile_resources) that are added to the sources of a Vala build target will now cause the appropriate `--gresources` flag to be passed to the Vala compiler so you don't need to add that yourself to `vala_args:`.\n\n## Improvements to install scripts\n\nYou can now pass arguments to install scripts added with [`meson.add_install_script()`](Reference-manual.md#meson-object). All arguments after the script name will be passed to the script.\n\nThe `MESON_INSTALL_DESTDIR_PREFIX` environment variable is now set when install scripts are called. This contains the values of the `DESTDIR` environment variable and the `prefix` option passed to Meson joined together. This is useful because both those are usually absolute paths, and joining absolute paths in a cross-platform way is tricky. [`os.path.join` in Python](https://docs.python.org/3/library/os.path.html#os.path.join) will discard all previous path segments when it encounters an absolute path, and simply concatenating them will not work on Windows where absolute paths begin with the drive letter.\n\n## More install directories\n\nAdded new options `sbindir` and `infodir` that can be used for installation.\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/manual tests/4 standalone binaries/myapp.icns",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/manual tests/4 standalone binaries/template.dmg.gz",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/graphics/meson_logo_big.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/test cases/windows/5 resources/res/sample.ico",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/test cases/osx/4 framework/xcode-frameworks.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/test cases/frameworks/4 qt/thing.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/test cases/frameworks/4 qt/thing2.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/docs/images/glib_empty.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/docs/images/buildtime.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/docs/images/glib_build.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/docs/images/gtksample.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/docs/images/conftime.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/docs/images/glib_conf.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/docs/images/emptytime.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/docs/images/glib_link.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/docs/theme/extra/images/meson_logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.42.0-kbyjxglddtke25pctbsm3z5umgdiapzm/spack-src/docs/theme/extra/images/favicon.png"
    ],
    "total_files": 1671
}