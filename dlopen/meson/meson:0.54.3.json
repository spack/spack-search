{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/mesonbuild/build.py": "# Copyright 2012-2017 The Meson development team\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport copy, os, re\nfrom collections import OrderedDict\nimport itertools, pathlib\nimport hashlib\nimport pickle\nfrom functools import lru_cache\nimport typing as T\n\nfrom . import environment\nfrom . import dependencies\nfrom . import mlog\nfrom .mesonlib import (\n    File, MesonException, MachineChoice, PerMachine, OrderedSet, listify,\n    extract_as_list, typeslistify, stringlistify, classify_unity_sources,\n    get_filenames_templates_dict, substitute_values, has_path_sep, unholder\n)\nfrom .compilers import Compiler, is_object, clink_langs, sort_clink, lang_suffixes, is_known_suffix\nfrom .linkers import StaticLinker\nfrom .interpreterbase import FeatureNew\n\npch_kwargs = set(['c_pch', 'cpp_pch'])\n\nlang_arg_kwargs = set([\n    'c_args',\n    'cpp_args',\n    'cuda_args',\n    'd_args',\n    'd_import_dirs',\n    'd_unittest',\n    'd_module_versions',\n    'd_debug',\n    'fortran_args',\n    'java_args',\n    'objc_args',\n    'objcpp_args',\n    'rust_args',\n    'vala_args',\n    'cs_args',\n])\n\nvala_kwargs = set(['vala_header', 'vala_gir', 'vala_vapi'])\nrust_kwargs = set(['rust_crate_type'])\ncs_kwargs = set(['resources', 'cs_args'])\n\nbuildtarget_kwargs = set([\n    'build_by_default',\n    'build_rpath',\n    'dependencies',\n    'extra_files',\n    'gui_app',\n    'link_with',\n    'link_whole',\n    'link_args',\n    'link_depends',\n    'implicit_include_directories',\n    'include_directories',\n    'install',\n    'install_rpath',\n    'install_dir',\n    'install_mode',\n    'name_prefix',\n    'name_suffix',\n    'native',\n    'objects',\n    'override_options',\n    'sources',\n    'gnu_symbol_visibility',\n])\n\nknown_build_target_kwargs = (\n    buildtarget_kwargs |\n    lang_arg_kwargs |\n    pch_kwargs |\n    vala_kwargs |\n    rust_kwargs |\n    cs_kwargs)\n\nknown_exe_kwargs = known_build_target_kwargs | {'implib', 'export_dynamic', 'link_language', 'pie'}\nknown_shlib_kwargs = known_build_target_kwargs | {'version', 'soversion', 'vs_module_defs', 'darwin_versions'}\nknown_shmod_kwargs = known_build_target_kwargs | {'vs_module_defs'}\nknown_stlib_kwargs = known_build_target_kwargs | {'pic'}\nknown_jar_kwargs = known_exe_kwargs | {'main_class'}\n\n@lru_cache(maxsize=None)\ndef get_target_macos_dylib_install_name(ld) -> str:\n    name = ['@rpath/', ld.prefix, ld.name]\n    if ld.soversion is not None:\n        name.append('.' + ld.soversion)\n    name.append('.dylib')\n    return ''.join(name)\n\nclass InvalidArguments(MesonException):\n    pass\n\nclass DependencyOverride:\n    def __init__(self, dep, node, explicit=True):\n        self.dep = dep\n        self.node = node\n        self.explicit = explicit\n\nclass Build:\n    \"\"\"A class that holds the status of one build including\n    all dependencies and so on.\n    \"\"\"\n\n    def __init__(self, environment: environment.Environment):\n        self.project_name = 'name of master project'\n        self.project_version = None\n        self.environment = environment\n        self.projects = {}\n        self.targets = OrderedDict()\n        self.run_target_names = set() # type: T.Set[T.Tuple[str, str]]\n        self.global_args = PerMachine({}, {})         # type: PerMachine[T.Dict[str, T.List[str]]]\n        self.projects_args = PerMachine({}, {})       # type: PerMachine[T.Dict[str, T.List[str]]]\n        self.global_link_args = PerMachine({}, {})    # type: PerMachine[T.Dict[str, T.List[str]]]\n        self.projects_link_args = PerMachine({}, {})  # type: PerMachine[T.Dict[str, T.List[str]]]\n        self.tests = []\n        self.benchmarks = []\n        self.headers = []\n        self.man = []\n        self.data = []\n        self.static_linker = PerMachine(None, None)   # type: PerMachine[StaticLinker]\n        self.subprojects = {}\n        self.subproject_dir = ''\n        self.install_scripts = []\n        self.postconf_scripts = []\n        self.dist_scripts = []\n        self.install_dirs = []\n        self.dep_manifest_name = None\n        self.dep_manifest = {}\n        self.stdlibs = PerMachine({}, {})\n        self.test_setups = {}                         # type: T.Dict[str, TestSetup]\n        self.test_setup_default_name = None\n        self.find_overrides = {}\n        self.searched_programs = set() # The list of all programs that have been searched for.\n        self.dependency_overrides = PerMachine({}, {})\n\n    def copy(self):\n        other = Build(self.environment)\n        for k, v in self.__dict__.items():\n            if isinstance(v, (list, dict, set, OrderedDict)):\n                other.__dict__[k] = v.copy()\n            else:\n                other.__dict__[k] = v\n        return other\n\n    def merge(self, other):\n        for k, v in other.__dict__.items():\n            self.__dict__[k] = v\n\n    def ensure_static_linker(self, compiler):\n        if self.static_linker[compiler.for_machine] is None and compiler.needs_static_linker():\n            self.static_linker[compiler.for_machine] = self.environment.detect_static_linker(compiler)\n\n    def get_project(self):\n        return self.projects['']\n\n    def get_subproject_dir(self):\n        return self.subproject_dir\n\n    def get_targets(self):\n        return self.targets\n\n    def get_tests(self):\n        return self.tests\n\n    def get_benchmarks(self):\n        return self.benchmarks\n\n    def get_headers(self):\n        return self.headers\n\n    def get_man(self):\n        return self.man\n\n    def get_data(self):\n        return self.data\n\n    def get_install_subdirs(self):\n        return self.install_dirs\n\n    def get_global_args(self, compiler, for_machine):\n        d = self.global_args[for_machine]\n        return d.get(compiler.get_language(), [])\n\n    def get_project_args(self, compiler, project, for_machine):\n        d = self.projects_args[for_machine]\n        args = d.get(project)\n        if not args:\n            return []\n        return args.get(compiler.get_language(), [])\n\n    def get_global_link_args(self, compiler, for_machine):\n        d = self.global_link_args[for_machine]\n        return d.get(compiler.get_language(), [])\n\n    def get_project_link_args(self, compiler, project, for_machine):\n        d = self.projects_link_args[for_machine]\n\n        link_args = d.get(project)\n        if not link_args:\n            return []\n\n        return link_args.get(compiler.get_language(), [])\n\nclass IncludeDirs:\n    def __init__(self, curdir, dirs, is_system, extra_build_dirs=None):\n        self.curdir = curdir\n        self.incdirs = dirs\n        self.is_system = is_system\n        # Interpreter has validated that all given directories\n        # actually exist.\n        if extra_build_dirs is None:\n            self.extra_build_dirs = []\n        else:\n            self.extra_build_dirs = extra_build_dirs\n\n    def __repr__(self):\n        r = '<{} {}/{}>'\n        return r.format(self.__class__.__name__, self.curdir, self.incdirs)\n\n    def get_curdir(self):\n        return self.curdir\n\n    def get_incdirs(self):\n        return self.incdirs\n\n    def get_extra_build_dirs(self):\n        return self.extra_build_dirs\n\nclass ExtractedObjects:\n    '''\n    Holds a list of sources for which the objects must be extracted\n    '''\n    def __init__(self, target, srclist=None, genlist=None, objlist=None, recursive=True):\n        self.target = target\n        self.recursive = recursive\n        self.srclist = srclist if srclist is not None else []\n        self.genlist = genlist if genlist is not None else []\n        self.objlist = objlist if objlist is not None else []\n        if self.target.is_unity:\n            self.check_unity_compatible()\n\n    def __repr__(self):\n        r = '<{0} {1!r}: {2}>'\n        return r.format(self.__class__.__name__, self.target.name, self.srclist)\n\n    def classify_all_sources(self, sources, generated_sources):\n        # Merge sources and generated sources\n        sources = list(sources)\n        for gensrc in generated_sources:\n            for s in gensrc.get_outputs():\n                # We cannot know the path where this source will be generated,\n                # but all we need here is the file extension to determine the\n                # compiler.\n                sources.append(s)\n\n        # Filter out headers and all non-source files\n        sources = [s for s in sources if environment.is_source(s) and not environment.is_header(s)]\n\n        return classify_unity_sources(self.target.compilers.values(), sources)\n\n    def check_unity_compatible(self):\n        # Figure out if the extracted object list is compatible with a Unity\n        # build. When we're doing a Unified build, we go through the sources,\n        # and create a single source file from each subset of the sources that\n        # can be compiled with a specific compiler. Then we create one object\n        # from each unified source file. So for each compiler we can either\n        # extra all its sources or none.\n        cmpsrcs = self.classify_all_sources(self.target.sources, self.target.generated)\n        extracted_cmpsrcs = self.classify_all_sources(self.srclist, self.genlist)\n\n        for comp, srcs in extracted_cmpsrcs.items():\n            if set(srcs) != set(cmpsrcs[comp]):\n                raise MesonException('Single object files can not be extracted '\n                                     'in Unity builds. You can only extract all '\n                                     'the object files for each compiler at once.')\n\n    def get_outputs(self, backend):\n        # TODO: Consider if we need to handle genlist here\n        return [\n            backend.object_filename_from_source(self.target, source)\n            for source in self.srclist\n        ]\n\nclass EnvironmentVariables:\n    def __init__(self):\n        self.envvars = []\n        # The set of all env vars we have operations for. Only used for self.has_name()\n        self.varnames = set()\n\n    def __repr__(self):\n        repr_str = \"<{0}: {1}>\"\n        return repr_str.format(self.__class__.__name__, self.envvars)\n\n    def add_var(self, method, name, args, kwargs):\n        self.varnames.add(name)\n        self.envvars.append((method, name, args, kwargs))\n\n    def has_name(self, name):\n        return name in self.varnames\n\n    def get_value(self, values, kwargs):\n        separator = kwargs.get('separator', os.pathsep)\n\n        value = ''\n        for var in values:\n            value += separator + var\n        return separator, value.strip(separator)\n\n    def set(self, env, name, values, kwargs):\n        return self.get_value(values, kwargs)[1]\n\n    def append(self, env, name, values, kwargs):\n        sep, value = self.get_value(values, kwargs)\n        if name in env:\n            return env[name] + sep + value\n        return value\n\n    def prepend(self, env, name, values, kwargs):\n        sep, value = self.get_value(values, kwargs)\n        if name in env:\n            return value + sep + env[name]\n\n        return value\n\n    def get_env(self, full_env: T.Dict[str, str]) -> T.Dict[str, str]:\n        env = full_env.copy()\n        for method, name, values, kwargs in self.envvars:\n            env[name] = method(full_env, name, values, kwargs)\n        return env\n\nclass Target:\n    def __init__(self, name, subdir, subproject, build_by_default, for_machine: MachineChoice):\n        if has_path_sep(name):\n            # Fix failing test 53 when this becomes an error.\n            mlog.warning('''Target \"{}\" has a path separator in its name.\nThis is not supported, it can cause unexpected failures and will become\na hard error in the future.'''.format(name))\n        self.name = name\n        self.subdir = subdir\n        self.subproject = subproject\n        self.build_by_default = build_by_default\n        self.for_machine = for_machine\n        self.install = False\n        self.build_always_stale = False\n        self.option_overrides = {}\n        if not hasattr(self, 'typename'):\n            raise RuntimeError('Target type is not set for target class \"{}\". This is a bug'.format(type(self).__name__))\n\n    def __lt__(self, other: T.Any) -> T.Union[bool, type(NotImplemented)]:\n        if not hasattr(other, 'get_id') and not callable(other.get_id):\n            return NotImplemented\n        return self.get_id() < other.get_id()\n\n    def __le__(self, other: T.Any) -> T.Union[bool, type(NotImplemented)]:\n        if not hasattr(other, 'get_id') and not callable(other.get_id):\n            return NotImplemented\n        return self.get_id() <= other.get_id()\n\n    def __gt__(self, other: T.Any) -> T.Union[bool, type(NotImplemented)]:\n        if not hasattr(other, 'get_id') and not callable(other.get_id):\n            return NotImplemented\n        return self.get_id() > other.get_id()\n\n    def __ge__(self, other: T.Any) -> T.Union[bool, type(NotImplemented)]:\n        if not hasattr(other, 'get_id') and not callable(other.get_id):\n            return NotImplemented\n        return self.get_id() >= other.get_id()\n\n    def get_install_dir(self, environment):\n        # Find the installation directory.\n        default_install_dir = self.get_default_install_dir(environment)\n        outdirs = self.get_custom_install_dir()\n        if outdirs[0] is not None and outdirs[0] != default_install_dir and outdirs[0] is not True:\n            # Either the value is set to a non-default value, or is set to\n            # False (which means we want this specific output out of many\n            # outputs to not be installed).\n            custom_install_dir = True\n        else:\n            custom_install_dir = False\n            outdirs[0] = default_install_dir\n        return outdirs, custom_install_dir\n\n    def get_basename(self):\n        return self.name\n\n    def get_subdir(self):\n        return self.subdir\n\n    def get_typename(self):\n        return self.typename\n\n    @staticmethod\n    def _get_id_hash(target_id):\n        # We don't really need cryptographic security here.\n        # Small-digest hash function with unlikely collision is good enough.\n        h = hashlib.sha256()\n        h.update(target_id.encode(encoding='utf-8', errors='replace'))\n        # This ID should be case-insensitive and should work in Visual Studio,\n        # e.g. it should not start with leading '-'.\n        return h.hexdigest()[:7]\n\n    @staticmethod\n    def construct_id_from_path(subdir, name, type_suffix):\n        \"\"\"Construct target ID from subdir, name and type suffix.\n\n        This helper function is made public mostly for tests.\"\"\"\n        # This ID must also be a valid file name on all OSs.\n        # It should also avoid shell metacharacters for obvious\n        # reasons. '@' is not used as often as '_' in source code names.\n        # In case of collisions consider using checksums.\n        # FIXME replace with assert when slash in names is prohibited\n        name_part = name.replace('/', '@').replace('\\\\', '@')\n        assert not has_path_sep(type_suffix)\n        my_id = name_part + type_suffix\n        if subdir:\n            subdir_part = Target._get_id_hash(subdir)\n            # preserve myid for better debuggability\n            return subdir_part + '@@' + my_id\n        return my_id\n\n    def get_id(self):\n        return self.construct_id_from_path(\n            self.subdir, self.name, self.type_suffix())\n\n    def process_kwargs_base(self, kwargs):\n        if 'build_by_default' in kwargs:\n            self.build_by_default = kwargs['build_by_default']\n            if not isinstance(self.build_by_default, bool):\n                raise InvalidArguments('build_by_default must be a boolean value.')\n        elif kwargs.get('install', False):\n            # For backward compatibility, if build_by_default is not explicitly\n            # set, use the value of 'install' if it's enabled.\n            self.build_by_default = True\n\n        self.option_overrides = self.parse_overrides(kwargs)\n\n    def parse_overrides(self, kwargs) -> dict:\n        result = {}\n        overrides = stringlistify(kwargs.get('override_options', []))\n        for o in overrides:\n            if '=' not in o:\n                raise InvalidArguments('Overrides must be of form \"key=value\"')\n            k, v = o.split('=', 1)\n            k = k.strip()\n            v = v.strip()\n            result[k] = v\n        return result\n\n    def is_linkable_target(self) -> bool:\n        return False\n\nclass BuildTarget(Target):\n    known_kwargs = known_build_target_kwargs\n\n    def __init__(self, name, subdir, subproject, for_machine: MachineChoice, sources, objects, environment, kwargs):\n        super().__init__(name, subdir, subproject, True, for_machine)\n        unity_opt = environment.coredata.get_builtin_option('unity')\n        self.is_unity = unity_opt == 'on' or (unity_opt == 'subprojects' and subproject != '')\n        self.environment = environment\n        self.sources = []\n        self.compilers = OrderedDict() # type: OrderedDict[str, Compiler]\n        self.objects = []\n        self.external_deps = []\n        self.include_dirs = []\n        self.link_language = kwargs.get('link_language')\n        self.link_targets = []\n        self.link_whole_targets = []\n        self.link_depends = []\n        self.added_deps = set()\n        self.name_prefix_set = False\n        self.name_suffix_set = False\n        self.filename = 'no_name'\n        # The list of all files outputted by this target. Useful in cases such\n        # as Vala which generates .vapi and .h besides the compiled output.\n        self.outputs = [self.filename]\n        self.need_install = False\n        self.pch = {}\n        self.extra_args = {}\n        self.generated = []\n        self.extra_files = []\n        self.d_features = {}\n        self.pic = False\n        self.pie = False\n        # Sources can be:\n        # 1. Pre-existing source files in the source tree\n        # 2. Pre-existing sources generated by configure_file in the build tree\n        # 3. Sources files generated by another target or a Generator\n        self.process_sourcelist(sources)\n        # Objects can be:\n        # 1. Pre-existing objects provided by the user with the `objects:` kwarg\n        # 2. Compiled objects created by and extracted from another target\n        self.process_objectlist(objects)\n        self.process_kwargs(kwargs, environment)\n        self.check_unknown_kwargs(kwargs)\n        self.process_compilers()\n        if not any([self.sources, self.generated, self.objects, self.link_whole]):\n            raise InvalidArguments('Build target {} has no sources.'.format(name))\n        self.process_compilers_late()\n        self.validate_sources()\n        self.validate_install(environment)\n        self.check_module_linking()\n\n    def __repr__(self):\n        repr_str = \"<{0} {1}: {2}>\"\n        return repr_str.format(self.__class__.__name__, self.get_id(), self.filename)\n\n    def validate_install(self, environment):\n        if self.for_machine is MachineChoice.BUILD and self.need_install:\n            if environment.is_cross_build():\n                raise InvalidArguments('Tried to install a target for the build machine in a cross build.')\n            else:\n                mlog.warning('Installing target build for the build machine. This will fail in a cross build.')\n\n    def check_unknown_kwargs(self, kwargs):\n        # Override this method in derived classes that have more\n        # keywords.\n        self.check_unknown_kwargs_int(kwargs, self.known_kwargs)\n\n    def check_unknown_kwargs_int(self, kwargs, known_kwargs):\n        unknowns = []\n        for k in kwargs:\n            if k not in known_kwargs:\n                unknowns.append(k)\n        if len(unknowns) > 0:\n            mlog.warning('Unknown keyword argument(s) in target {}: {}.'.format(self.name, ', '.join(unknowns)))\n\n    def process_objectlist(self, objects):\n        assert(isinstance(objects, list))\n        for s in unholder(objects):\n            if isinstance(s, (str, File, ExtractedObjects)):\n                self.objects.append(s)\n            elif isinstance(s, (GeneratedList, CustomTarget)):\n                msg = 'Generated files are not allowed in the \\'objects\\' kwarg ' + \\\n                    'for target {!r}.\\nIt is meant only for '.format(self.name) + \\\n                    'pre-built object files that are shipped with the\\nsource ' + \\\n                    'tree. Try adding it in the list of sources.'\n                raise InvalidArguments(msg)\n            else:\n                msg = 'Bad object of type {!r} in target {!r}.'.format(type(s).__name__, self.name)\n                raise InvalidArguments(msg)\n\n    def process_sourcelist(self, sources):\n        sources = listify(sources)\n        added_sources = {} # If the same source is defined multiple times, use it only once.\n        for s in unholder(sources):\n            if isinstance(s, File):\n                if s not in added_sources:\n                    self.sources.append(s)\n                    added_sources[s] = True\n            elif isinstance(s, (GeneratedList, CustomTarget, CustomTargetIndex)):\n                self.generated.append(s)\n            else:\n                msg = 'Bad source of type {!r} in target {!r}.'.format(type(s).__name__, self.name)\n                raise InvalidArguments(msg)\n\n    @staticmethod\n    def can_compile_remove_sources(compiler, sources):\n        removed = False\n        for s in sources[:]:\n            if compiler.can_compile(s):\n                sources.remove(s)\n                removed = True\n        return removed\n\n    def process_compilers_late(self):\n        \"\"\"Processes additional compilers after kwargs have been evaluated.\n\n        This can add extra compilers that might be required by keyword\n        arguments, such as link_with or dependencies. It will also try to guess\n        which compiler to use if one hasn't been selected already.\n        \"\"\"\n        # Populate list of compilers\n        compilers = self.environment.coredata.compilers[self.for_machine]\n\n        # did user override clink_langs for this target?\n        link_langs = [self.link_language] if self.link_language else clink_langs\n\n        # If this library is linked against another library we need to consider\n        # the languages of those libraries as well.\n        if self.link_targets or self.link_whole_targets:\n            extra = set()\n            for t in itertools.chain(self.link_targets, self.link_whole_targets):\n                if isinstance(t, CustomTarget) or isinstance(t, CustomTargetIndex):\n                    continue # We can't know anything about these.\n                for name, compiler in t.compilers.items():\n                    if name in link_langs:\n                        extra.add((name, compiler))\n            for name, compiler in sorted(extra, key=lambda p: sort_clink(p[0])):\n                self.compilers[name] = compiler\n\n        if not self.compilers:\n            # No source files or parent targets, target consists of only object\n            # files of unknown origin. Just add the first clink compiler\n            # that we have and hope that it can link these objects\n            for lang in link_langs:\n                if lang in compilers:\n                    self.compilers[lang] = compilers[lang]\n                    break\n\n    def process_compilers(self):\n        '''\n        Populate self.compilers, which is the list of compilers that this\n        target will use for compiling all its sources.\n        We also add compilers that were used by extracted objects to simplify\n        dynamic linker determination.\n        '''\n        if not self.sources and not self.generated and not self.objects:\n            return\n        # Populate list of compilers\n        compilers = self.environment.coredata.compilers[self.for_machine]\n        # Pre-existing sources\n        sources = list(self.sources)\n        # All generated sources\n        for gensrc in self.generated:\n            for s in gensrc.get_outputs():\n                # Generated objects can't be compiled, so don't use them for\n                # compiler detection. If our target only has generated objects,\n                # we will fall back to using the first c-like compiler we find,\n                # which is what we need.\n                if not is_object(s):\n                    sources.append(s)\n        for d in unholder(self.external_deps):\n            for s in d.sources:\n                if isinstance(s, (str, File)):\n                    sources.append(s)\n\n        # Sources that were used to create our extracted objects\n        for o in self.objects:\n            if not isinstance(o, ExtractedObjects):\n                continue\n            for s in o.srclist:\n                # Don't add Vala sources since that will pull in the Vala\n                # compiler even though we will never use it since we are\n                # dealing with compiled C code.\n                if not s.endswith(lang_suffixes['vala']):\n                    sources.append(s)\n        if sources:\n            # For each source, try to add one compiler that can compile it.\n            #\n            # If it has a suffix that belongs to a known language, we must have\n            # a compiler for that language.\n            #\n            # Otherwise, it's ok if no compilers can compile it, because users\n            # are expected to be able to add arbitrary non-source files to the\n            # sources list\n            for s in sources:\n                for lang, compiler in compilers.items():\n                    if compiler.can_compile(s):\n                        if lang not in self.compilers:\n                            self.compilers[lang] = compiler\n                        break\n                else:\n                    if is_known_suffix(s):\n                        raise MesonException('No {} machine compiler for \"{}\"'.\n                                             format(self.for_machine.get_lower_case_name(), s))\n\n            # Re-sort according to clink_langs\n            self.compilers = OrderedDict(sorted(self.compilers.items(),\n                                                key=lambda t: sort_clink(t[0])))\n\n        # If all our sources are Vala, our target also needs the C compiler but\n        # it won't get added above.\n        if 'vala' in self.compilers and 'c' not in self.compilers:\n            self.compilers['c'] = compilers['c']\n\n    def validate_sources(self):\n        if not self.sources:\n            return\n        for lang in ('cs', 'java'):\n            if lang in self.compilers:\n                check_sources = list(self.sources)\n                compiler = self.compilers[lang]\n                if not self.can_compile_remove_sources(compiler, check_sources):\n                    m = 'No {} sources found in target {!r}'.format(lang, self.name)\n                    raise InvalidArguments(m)\n                if check_sources:\n                    m = '{0} targets can only contain {0} files:\\n'.format(lang.capitalize())\n                    m += '\\n'.join([repr(c) for c in check_sources])\n                    raise InvalidArguments(m)\n                # CSharp and Java targets can't contain any other file types\n                assert(len(self.compilers) == 1)\n                return\n\n    def process_link_depends(self, sources, environment):\n        \"\"\"Process the link_depends keyword argument.\n\n        This is designed to handle strings, Files, and the output of Custom\n        Targets. Notably it doesn't handle generator() returned objects, since\n        adding them as a link depends would inherently cause them to be\n        generated twice, since the output needs to be passed to the ld_args and\n        link_depends.\n        \"\"\"\n        sources = listify(sources)\n        for s in unholder(sources):\n            if isinstance(s, File):\n                self.link_depends.append(s)\n            elif isinstance(s, str):\n                self.link_depends.append(\n                    File.from_source_file(environment.source_dir, self.subdir, s))\n            elif hasattr(s, 'get_outputs'):\n                self.link_depends.extend(\n                    [File.from_built_file(s.get_subdir(), p) for p in s.get_outputs()])\n            else:\n                raise InvalidArguments(\n                    'Link_depends arguments must be strings, Files, '\n                    'or a Custom Target, or lists thereof.')\n\n    def get_original_kwargs(self):\n        return self.kwargs\n\n    def unpack_holder(self, d):\n        d = listify(d)\n        newd = []\n        for i in d:\n            if isinstance(i, list):\n                i = self.unpack_holder(i)\n            elif hasattr(i, 'held_object'):\n                i = i.held_object\n            for t in ['dependencies', 'link_with', 'include_directories', 'sources']:\n                if hasattr(i, t):\n                    setattr(i, t, self.unpack_holder(getattr(i, t)))\n            newd.append(i)\n        return newd\n\n    def copy_kwargs(self, kwargs):\n        self.kwargs = copy.copy(kwargs)\n        # This sucks quite badly. Arguments\n        # are holders but they can't be pickled\n        # so unpack those known.\n        for k, v in self.kwargs.items():\n            if isinstance(v, list):\n                self.kwargs[k] = self.unpack_holder(v)\n            if hasattr(v, 'held_object'):\n                self.kwargs[k] = v.held_object\n        for t in ['dependencies', 'link_with', 'include_directories', 'sources']:\n            if t in self.kwargs:\n                self.kwargs[t] = self.unpack_holder(self.kwargs[t])\n\n    def extract_objects(self, srclist):\n        obj_src = []\n        for src in srclist:\n            if isinstance(src, str):\n                src = File(False, self.subdir, src)\n            elif isinstance(src, File):\n                FeatureNew('File argument for extract_objects', '0.50.0').use(self.subproject)\n            else:\n                raise MesonException('Object extraction arguments must be strings or Files.')\n            # FIXME: It could be a generated source\n            if src not in self.sources:\n                raise MesonException('Tried to extract unknown source {}.'.format(src))\n            obj_src.append(src)\n        return ExtractedObjects(self, obj_src)\n\n    def extract_all_objects(self, recursive=True):\n        return ExtractedObjects(self, self.sources, self.generated, self.objects,\n                                recursive)\n\n    def get_all_link_deps(self):\n        return self.get_transitive_link_deps()\n\n    @lru_cache(maxsize=None)\n    def get_transitive_link_deps(self):\n        result = []\n        for i in self.link_targets:\n            result += i.get_all_link_deps()\n        return result\n\n    def get_link_deps_mapping(self, prefix, environment):\n        return self.get_transitive_link_deps_mapping(prefix, environment)\n\n    @lru_cache(maxsize=None)\n    def get_transitive_link_deps_mapping(self, prefix, environment):\n        result = {}\n        for i in self.link_targets:\n            mapping = i.get_link_deps_mapping(prefix, environment)\n            #we are merging two dictionaries, while keeping the earlier one dominant\n            result_tmp = mapping.copy()\n            result_tmp.update(result)\n            result = result_tmp\n        return result\n\n    @lru_cache(maxsize=None)\n    def get_link_dep_subdirs(self):\n        result = OrderedSet()\n        for i in self.link_targets:\n            result.add(i.get_subdir())\n            result.update(i.get_link_dep_subdirs())\n        return result\n\n    def get_default_install_dir(self, environment):\n        return environment.get_libdir()\n\n    def get_custom_install_dir(self):\n        return self.install_dir\n\n    def get_custom_install_mode(self):\n        return self.install_mode\n\n    def process_kwargs(self, kwargs, environment):\n        self.process_kwargs_base(kwargs)\n        self.copy_kwargs(kwargs)\n        kwargs.get('modules', [])\n        self.need_install = kwargs.get('install', self.need_install)\n        llist = extract_as_list(kwargs, 'link_with')\n        for linktarget in unholder(llist):\n            if isinstance(linktarget, dependencies.ExternalLibrary):\n                raise MesonException('''An external library was used in link_with keyword argument, which\nis reserved for libraries built as part of this project. External\nlibraries must be passed using the dependencies keyword argument\ninstead, because they are conceptually \"external dependencies\",\njust like those detected with the dependency() function.''')\n            self.link(linktarget)\n        lwhole = extract_as_list(kwargs, 'link_whole')\n        for linktarget in lwhole:\n            self.link_whole(linktarget)\n\n        c_pchlist, cpp_pchlist, clist, cpplist, cudalist, cslist, valalist,  objclist, objcpplist, fortranlist, rustlist \\\n            = [extract_as_list(kwargs, c) for c in ['c_pch', 'cpp_pch', 'c_args', 'cpp_args', 'cuda_args', 'cs_args', 'vala_args', 'objc_args', 'objcpp_args', 'fortran_args', 'rust_args']]\n\n        self.add_pch('c', c_pchlist)\n        self.add_pch('cpp', cpp_pchlist)\n        compiler_args = {'c': clist, 'cpp': cpplist, 'cuda': cudalist, 'cs': cslist, 'vala': valalist, 'objc': objclist, 'objcpp': objcpplist,\n                         'fortran': fortranlist, 'rust': rustlist\n                         }\n        for key, value in compiler_args.items():\n            self.add_compiler_args(key, value)\n\n        if not isinstance(self, Executable) or 'export_dynamic' in kwargs:\n            self.vala_header = kwargs.get('vala_header', self.name + '.h')\n            self.vala_vapi = kwargs.get('vala_vapi', self.name + '.vapi')\n            self.vala_gir = kwargs.get('vala_gir', None)\n\n        dlist = stringlistify(kwargs.get('d_args', []))\n        self.add_compiler_args('d', dlist)\n        dfeatures = dict()\n        dfeature_unittest = kwargs.get('d_unittest', False)\n        if dfeature_unittest:\n            dfeatures['unittest'] = dfeature_unittest\n        dfeature_versions = kwargs.get('d_module_versions', [])\n        if dfeature_versions:\n            dfeatures['versions'] = dfeature_versions\n        dfeature_debug = kwargs.get('d_debug', [])\n        if dfeature_debug:\n            dfeatures['debug'] = dfeature_debug\n        if 'd_import_dirs' in kwargs:\n            dfeature_import_dirs = unholder(extract_as_list(kwargs, 'd_import_dirs'))\n            for d in dfeature_import_dirs:\n                if not isinstance(d, IncludeDirs):\n                    raise InvalidArguments('Arguments to d_import_dirs must be include_directories.')\n            dfeatures['import_dirs'] = dfeature_import_dirs\n        if dfeatures:\n            self.d_features = dfeatures\n\n        self.link_args = extract_as_list(kwargs, 'link_args')\n        for i in self.link_args:\n            if not isinstance(i, str):\n                raise InvalidArguments('Link_args arguments must be strings.')\n        for l in self.link_args:\n            if '-Wl,-rpath' in l or l.startswith('-rpath'):\n                mlog.warning('''Please do not define rpath with a linker argument, use install_rpath or build_rpath properties instead.\nThis will become a hard error in a future Meson release.''')\n        self.process_link_depends(kwargs.get('link_depends', []), environment)\n        # Target-specific include dirs must be added BEFORE include dirs from\n        # internal deps (added inside self.add_deps()) to override them.\n        inclist = extract_as_list(kwargs, 'include_directories')\n        self.add_include_dirs(inclist)\n        # Add dependencies (which also have include_directories)\n        deplist = extract_as_list(kwargs, 'dependencies')\n        self.add_deps(deplist)\n        # If an item in this list is False, the output corresponding to\n        # the list index of that item will not be installed\n        self.install_dir = typeslistify(kwargs.get('install_dir', [None]),\n                                        (str, bool))\n        self.install_mode = kwargs.get('install_mode', None)\n        main_class = kwargs.get('main_class', '')\n        if not isinstance(main_class, str):\n            raise InvalidArguments('Main class must be a string')\n        self.main_class = main_class\n        if isinstance(self, Executable):\n            self.gui_app = kwargs.get('gui_app', False)\n            if not isinstance(self.gui_app, bool):\n                raise InvalidArguments('Argument gui_app must be boolean.')\n        elif 'gui_app' in kwargs:\n            raise InvalidArguments('Argument gui_app can only be used on executables.')\n        extra_files = extract_as_list(kwargs, 'extra_files')\n        for i in extra_files:\n            assert(isinstance(i, File))\n            trial = os.path.join(environment.get_source_dir(), i.subdir, i.fname)\n            if not(os.path.isfile(trial)):\n                raise InvalidArguments('Tried to add non-existing extra file {}.'.format(i))\n        self.extra_files = extra_files\n        self.install_rpath = kwargs.get('install_rpath', '')\n        if not isinstance(self.install_rpath, str):\n            raise InvalidArguments('Install_rpath is not a string.')\n        self.build_rpath = kwargs.get('build_rpath', '')\n        if not isinstance(self.build_rpath, str):\n            raise InvalidArguments('Build_rpath is not a string.')\n        resources = extract_as_list(kwargs, 'resources')\n        for r in resources:\n            if not isinstance(r, str):\n                raise InvalidArguments('Resource argument is not a string.')\n            trial = os.path.join(environment.get_source_dir(), self.subdir, r)\n            if not os.path.isfile(trial):\n                raise InvalidArguments('Tried to add non-existing resource {}.'.format(r))\n        self.resources = resources\n        if 'name_prefix' in kwargs:\n            name_prefix = kwargs['name_prefix']\n            if isinstance(name_prefix, list):\n                if name_prefix:\n                    raise InvalidArguments('name_prefix array must be empty to signify null.')\n            elif not isinstance(name_prefix, str):\n                raise InvalidArguments('name_prefix must be a string.')\n            self.prefix = name_prefix\n            self.name_prefix_set = True\n        if 'name_suffix' in kwargs:\n            name_suffix = kwargs['name_suffix']\n            if isinstance(name_suffix, list):\n                if name_suffix:\n                    raise InvalidArguments('name_suffix array must be empty to signify null.')\n            else:\n                if not isinstance(name_suffix, str):\n                    raise InvalidArguments('name_suffix must be a string.')\n                if name_suffix == '':\n                    raise InvalidArguments('name_suffix should not be an empty string. '\n                                           'If you want meson to use the default behaviour '\n                                           'for each platform pass `[]` (empty array)')\n                self.suffix = name_suffix\n                self.name_suffix_set = True\n        if isinstance(self, StaticLibrary):\n            # You can't disable PIC on OS X. The compiler ignores -fno-PIC.\n            # PIC is always on for Windows (all code is position-independent\n            # since library loading is done differently)\n            m = self.environment.machines[self.for_machine]\n            if m.is_darwin() or m.is_windows():\n                self.pic = True\n            else:\n                self.pic = self._extract_pic_pie(kwargs, 'pic')\n        if isinstance(self, Executable):\n            # Executables must be PIE on Android\n            if self.environment.machines[self.for_machine].is_android():\n                self.pie = True\n            else:\n                self.pie = self._extract_pic_pie(kwargs, 'pie')\n        self.implicit_include_directories = kwargs.get('implicit_include_directories', True)\n        if not isinstance(self.implicit_include_directories, bool):\n            raise InvalidArguments('Implicit_include_directories must be a boolean.')\n        self.gnu_symbol_visibility = kwargs.get('gnu_symbol_visibility', '')\n        if not isinstance(self.gnu_symbol_visibility, str):\n            raise InvalidArguments('GNU symbol visibility must be a string.')\n        if self.gnu_symbol_visibility != '':\n            permitted = ['default', 'internal', 'hidden', 'protected', 'inlineshidden']\n            if self.gnu_symbol_visibility not in permitted:\n                raise InvalidArguments('GNU symbol visibility arg {} not one of: {}'.format(self.symbol_visibility, ', '.join(permitted)))\n\n    def _extract_pic_pie(self, kwargs, arg):\n        # Check if we have -fPIC, -fpic, -fPIE, or -fpie in cflags\n        all_flags = self.extra_args['c'] + self.extra_args['cpp']\n        if '-f' + arg.lower() in all_flags or '-f' + arg.upper() in all_flags:\n            mlog.warning(\"Use the '{}' kwarg instead of passing '{}' manually to {!r}\".format(arg, '-f' + arg, self.name))\n            return True\n\n        val = kwargs.get(arg, False)\n        if not isinstance(val, bool):\n            raise InvalidArguments('Argument {} to {!r} must be boolean'.format(arg, self.name))\n        return val\n\n    def get_filename(self):\n        return self.filename\n\n    def get_outputs(self):\n        return self.outputs\n\n    def get_extra_args(self, language):\n        return self.extra_args.get(language, [])\n\n    def get_dependencies(self, exclude=None, for_pkgconfig=False):\n        transitive_deps = []\n        if exclude is None:\n            exclude = []\n        for t in itertools.chain(self.link_targets, self.link_whole_targets):\n            if t in transitive_deps or t in exclude:\n                continue\n            # When generating `Libs:` and `Libs.private:` lists in pkg-config\n            # files we don't want to include static libraries that we link_whole\n            # or are uninstalled (they're implicitly promoted to link_whole).\n            # But we still need to include their transitive dependencies,\n            # a static library we link_whole would itself link to a shared\n            # library or an installed static library.\n            if not for_pkgconfig or (not t.is_internal() and t not in self.link_whole_targets):\n                transitive_deps.append(t)\n            if isinstance(t, StaticLibrary):\n                transitive_deps += t.get_dependencies(transitive_deps + exclude, for_pkgconfig)\n        return transitive_deps\n\n    def get_source_subdir(self):\n        return self.subdir\n\n    def get_sources(self):\n        return self.sources\n\n    def get_objects(self):\n        return self.objects\n\n    def get_generated_sources(self):\n        return self.generated\n\n    def should_install(self):\n        return self.need_install\n\n    def has_pch(self):\n        return len(self.pch) > 0\n\n    def get_pch(self, language):\n        try:\n            return self.pch[language]\n        except KeyError:\n            return[]\n\n    def get_include_dirs(self):\n        return self.include_dirs\n\n    def add_deps(self, deps):\n        deps = listify(deps)\n        for dep in unholder(deps):\n            if dep in self.added_deps:\n                continue\n            if isinstance(dep, dependencies.InternalDependency):\n                # Those parts that are internal.\n                self.process_sourcelist(dep.sources)\n                self.add_include_dirs(dep.include_directories, dep.get_include_type())\n                for l in dep.libraries:\n                    self.link(l)\n                for l in dep.whole_libraries:\n                    self.link_whole(l)\n                if dep.get_compile_args() or dep.get_link_args():\n                    # Those parts that are external.\n                    extpart = dependencies.InternalDependency('undefined',\n                                                              [],\n                                                              dep.get_compile_args(),\n                                                              dep.get_link_args(),\n                                                              [], [], [], [], {})\n                    self.external_deps.append(extpart)\n                # Deps of deps.\n                self.add_deps(dep.ext_deps)\n            elif isinstance(dep, dependencies.Dependency):\n                if dep not in self.external_deps:\n                    self.external_deps.append(dep)\n                    self.process_sourcelist(dep.get_sources())\n                self.add_deps(dep.ext_deps)\n            elif isinstance(dep, BuildTarget):\n                raise InvalidArguments('''Tried to use a build target as a dependency.\nYou probably should put it in link_with instead.''')\n            else:\n                # This is a bit of a hack. We do not want Build to know anything\n                # about the interpreter so we can't import it and use isinstance.\n                # This should be reliable enough.\n                if hasattr(dep, 'project_args_frozen') or hasattr(dep, 'global_args_frozen'):\n                    raise InvalidArguments('Tried to use subproject object as a dependency.\\n'\n                                           'You probably wanted to use a dependency declared in it instead.\\n'\n                                           'Access it by calling get_variable() on the subproject object.')\n                raise InvalidArguments('Argument is of an unacceptable type {!r}.\\nMust be '\n                                       'either an external dependency (returned by find_library() or '\n                                       'dependency()) or an internal dependency (returned by '\n                                       'declare_dependency()).'.format(type(dep).__name__))\n            self.added_deps.add(dep)\n\n    def get_external_deps(self):\n        return self.external_deps\n\n    def is_internal(self):\n        return isinstance(self, StaticLibrary) and not self.need_install\n\n    def link(self, target):\n        for t in unholder(listify(target)):\n            if isinstance(self, StaticLibrary) and self.need_install and t.is_internal():\n                # When we're a static library and we link_with to an\n                # internal/convenience library, promote to link_whole.\n                return self.link_whole(t)\n            if not isinstance(t, (Target, CustomTargetIndex)):\n                raise InvalidArguments('{!r} is not a target.'.format(t))\n            if not t.is_linkable_target():\n                raise InvalidArguments('Link target {!r} is not linkable.'.format(t))\n            if isinstance(self, SharedLibrary) and isinstance(t, StaticLibrary) and not t.pic:\n                msg = \"Can't link non-PIC static library {!r} into shared library {!r}. \".format(t.name, self.name)\n                msg += \"Use the 'pic' option to static_library to build with PIC.\"\n                raise InvalidArguments(msg)\n            if self.for_machine is not t.for_machine:\n                msg = 'Tried to mix libraries for machines {} and {} in target {!r}'.format(self.for_machine, t.for_machine, self.name)\n                if self.environment.is_cross_build():\n                    raise InvalidArguments(msg + ' This is not possible in a cross build.')\n                else:\n                    mlog.warning(msg + ' This will fail in cross build.')\n            self.link_targets.append(t)\n\n    def link_whole(self, target):\n        for t in unholder(listify(target)):\n            if isinstance(t, (CustomTarget, CustomTargetIndex)):\n                if not t.is_linkable_target():\n                    raise InvalidArguments('Custom target {!r} is not linkable.'.format(t))\n                if not t.get_filename().endswith('.a'):\n                    raise InvalidArguments('Can only link_whole custom targets that are .a archives.')\n                if isinstance(self, StaticLibrary):\n                    # FIXME: We could extract the .a archive to get object files\n                    raise InvalidArguments('Cannot link_whole a custom target into a static library')\n            elif not isinstance(t, StaticLibrary):\n                raise InvalidArguments('{!r} is not a static library.'.format(t))\n            elif isinstance(self, SharedLibrary) and not t.pic:\n                msg = \"Can't link non-PIC static library {!r} into shared library {!r}. \".format(t.name, self.name)\n                msg += \"Use the 'pic' option to static_library to build with PIC.\"\n                raise InvalidArguments(msg)\n            if self.for_machine is not t.for_machine:\n                msg = 'Tried to mix libraries for machines {1} and {2} in target {0!r}'.format(self.name, self.for_machine, t.for_machine)\n                if self.environment.is_cross_build():\n                    raise InvalidArguments(msg + ' This is not possible in a cross build.')\n                else:\n                    mlog.warning(msg + ' This will fail in cross build.')\n            if isinstance(self, StaticLibrary):\n                # When we're a static library and we link_whole: to another static\n                # library, we need to add that target's objects to ourselves.\n                self.objects += t.extract_all_objects_recurse()\n            self.link_whole_targets.append(t)\n\n    def extract_all_objects_recurse(self):\n        objs = [self.extract_all_objects()]\n        for t in self.link_targets:\n            if t.is_internal():\n                objs += t.extract_all_objects_recurse()\n        return objs\n\n    def add_pch(self, language, pchlist):\n        if not pchlist:\n            return\n        elif len(pchlist) == 1:\n            if not environment.is_header(pchlist[0]):\n                raise InvalidArguments('PCH argument {} is not a header.'.format(pchlist[0]))\n        elif len(pchlist) == 2:\n            if environment.is_header(pchlist[0]):\n                if not environment.is_source(pchlist[1]):\n                    raise InvalidArguments('PCH definition must contain one header and at most one source.')\n            elif environment.is_source(pchlist[0]):\n                if not environment.is_header(pchlist[1]):\n                    raise InvalidArguments('PCH definition must contain one header and at most one source.')\n                pchlist = [pchlist[1], pchlist[0]]\n            else:\n                raise InvalidArguments('PCH argument {} is of unknown type.'.format(pchlist[0]))\n\n            if (os.path.dirname(pchlist[0]) != os.path.dirname(pchlist[1])):\n                raise InvalidArguments('PCH files must be stored in the same folder.')\n\n            mlog.warning('PCH source files are deprecated, only a single header file should be used.')\n        elif len(pchlist) > 2:\n            raise InvalidArguments('PCH definition may have a maximum of 2 files.')\n        for f in pchlist:\n            if not isinstance(f, str):\n                raise MesonException('PCH arguments must be strings.')\n            if not os.path.isfile(os.path.join(self.environment.source_dir, self.subdir, f)):\n                raise MesonException('File {} does not exist.'.format(f))\n        self.pch[language] = pchlist\n\n    def add_include_dirs(self, args, set_is_system: T.Optional[str] = None):\n        ids = []\n        for a in unholder(args):\n            if not isinstance(a, IncludeDirs):\n                raise InvalidArguments('Include directory to be added is not an include directory object.')\n            ids.append(a)\n        if set_is_system is None:\n            set_is_system = 'preserve'\n        if set_is_system != 'preserve':\n            is_system = set_is_system == 'system'\n            ids = [IncludeDirs(x.get_curdir(), x.get_incdirs(), is_system, x.get_extra_build_dirs()) for x in ids]\n        self.include_dirs += ids\n\n    def add_compiler_args(self, language, args):\n        args = listify(args)\n        for a in args:\n            if not isinstance(a, (str, File)):\n                raise InvalidArguments('A non-string passed to compiler args.')\n        if language in self.extra_args:\n            self.extra_args[language] += args\n        else:\n            self.extra_args[language] = args\n\n    def get_aliases(self):\n        return {}\n\n    def get_langs_used_by_deps(self) -> T.List[str]:\n        '''\n        Sometimes you want to link to a C++ library that exports C API, which\n        means the linker must link in the C++ stdlib, and we must use a C++\n        compiler for linking. The same is also applicable for objc/objc++, etc,\n        so we can keep using clink_langs for the priority order.\n\n        See: https://github.com/mesonbuild/meson/issues/1653\n        '''\n        langs = []\n\n        # User specified link_language of target (for multi-language targets)\n        if self.link_language:\n            return [self.link_language]\n\n        # Check if any of the external libraries were written in this language\n        for dep in self.external_deps:\n            if dep.language is None:\n                continue\n            if dep.language not in langs:\n                langs.append(dep.language)\n        # Check if any of the internal libraries this target links to were\n        # written in this language\n        for link_target in itertools.chain(self.link_targets, self.link_whole_targets):\n            if isinstance(link_target, (CustomTarget, CustomTargetIndex)):\n                continue\n            for language in link_target.compilers:\n                if language not in langs:\n                    langs.append(language)\n\n        return langs\n\n    def get_clink_dynamic_linker_and_stdlibs(self):\n        '''\n        We use the order of languages in `clink_langs` to determine which\n        linker to use in case the target has sources compiled with multiple\n        compilers. All languages other than those in this list have their own\n        linker.\n        Note that Vala outputs C code, so Vala sources can use any linker\n        that can link compiled C. We don't actually need to add an exception\n        for Vala here because of that.\n        '''\n        # Populate list of all compilers, not just those being used to compile\n        # sources in this target\n        all_compilers = self.environment.coredata.compilers[self.for_machine]\n        # Languages used by dependencies\n        dep_langs = self.get_langs_used_by_deps()\n        # Pick a compiler based on the language priority-order\n        for l in clink_langs:\n            if l in self.compilers or l in dep_langs:\n                try:\n                    linker = all_compilers[l]\n                except KeyError:\n                    raise MesonException(\n                        'Could not get a dynamic linker for build target {!r}. '\n                        'Requires a linker for language \"{}\", but that is not '\n                        'a project language.'.format(self.name, l))\n                stdlib_args = []\n                added_languages = set()\n                for dl in itertools.chain(self.compilers, dep_langs):\n                    if dl != linker.language:\n                        stdlib_args += all_compilers[dl].language_stdlib_only_link_flags()\n                        added_languages.add(dl)\n                # Type of var 'linker' is Compiler.\n                # Pretty hard to fix because the return value is passed everywhere\n                return linker, stdlib_args\n\n        m = 'Could not get a dynamic linker for build target {!r}'\n        raise AssertionError(m.format(self.name))\n\n    def get_using_rustc(self):\n        if len(self.sources) > 0 and self.sources[0].fname.endswith('.rs'):\n            return True\n\n    def get_using_msvc(self):\n        '''\n        Check if the dynamic linker is MSVC. Used by Executable, StaticLibrary,\n        and SharedLibrary for deciding when to use MSVC-specific file naming\n        and debug filenames.\n\n        If at least some code is built with MSVC and the final library is\n        linked with MSVC, we can be sure that some debug info will be\n        generated. We only check the dynamic linker here because the static\n        linker is guaranteed to be of the same type.\n\n        Interesting cases:\n        1. The Vala compiler outputs C code to be compiled by whatever\n           C compiler we're using, so all objects will still be created by the\n           MSVC compiler.\n        2. If the target contains only objects, process_compilers guesses and\n           picks the first compiler that smells right.\n        '''\n        compiler, _ = self.get_clink_dynamic_linker_and_stdlibs()\n        # Mixing many languages with MSVC is not supported yet so ignore stdlibs.\n        if compiler and compiler.get_linker_id() in {'link', 'lld-link', 'xilink', 'optlink'}:\n            return True\n        return False\n\n    def check_module_linking(self):\n        '''\n        Warn if shared modules are linked with target: (link_with) #2865\n        '''\n        for link_target in self.link_targets:\n            if isinstance(link_target, SharedModule):\n                if self.environment.machines[self.for_machine].is_darwin():\n                    raise MesonException('''target links against shared modules.\nThis is not permitted on OSX''')\n                else:\n                    mlog.warning('''target links against shared modules. This is not\nrecommended as it is not supported on some platforms''')\n                return\n\nclass Generator:\n    def __init__(self, args, kwargs):\n        if len(args) != 1:\n            raise InvalidArguments('Generator requires exactly one positional argument: the executable')\n        exe = unholder(args[0])\n        if not isinstance(exe, (Executable, dependencies.ExternalProgram)):\n            raise InvalidArguments('First generator argument must be an executable.')\n        self.exe = exe\n        self.depfile = None\n        self.capture = False\n        self.depends = []\n        self.process_kwargs(kwargs)\n\n    def __repr__(self):\n        repr_str = \"<{0}: {1}>\"\n        return repr_str.format(self.__class__.__name__, self.exe)\n\n    def get_exe(self):\n        return self.exe\n\n    def process_kwargs(self, kwargs):\n        if 'arguments' not in kwargs:\n            raise InvalidArguments('Generator must have \"arguments\" keyword argument.')\n        args = kwargs['arguments']\n        if isinstance(args, str):\n            args = [args]\n        if not isinstance(args, list):\n            raise InvalidArguments('\"Arguments\" keyword argument must be a string or a list of strings.')\n        for a in args:\n            if not isinstance(a, str):\n                raise InvalidArguments('A non-string object in \"arguments\" keyword argument.')\n        self.arglist = args\n        if 'output' not in kwargs:\n            raise InvalidArguments('Generator must have \"output\" keyword argument.')\n        outputs = listify(kwargs['output'])\n        for rule in outputs:\n            if not isinstance(rule, str):\n                raise InvalidArguments('\"output\" may only contain strings.')\n            if '@BASENAME@' not in rule and '@PLAINNAME@' not in rule:\n                raise InvalidArguments('Every element of \"output\" must contain @BASENAME@ or @PLAINNAME@.')\n            if has_path_sep(rule):\n                raise InvalidArguments('\"outputs\" must not contain a directory separator.')\n        if len(outputs) > 1:\n            for o in outputs:\n                if '@OUTPUT@' in o:\n                    raise InvalidArguments('Tried to use @OUTPUT@ in a rule with more than one output.')\n        self.outputs = outputs\n        if 'depfile' in kwargs:\n            depfile = kwargs['depfile']\n            if not isinstance(depfile, str):\n                raise InvalidArguments('Depfile must be a string.')\n            if os.path.basename(depfile) != depfile:\n                raise InvalidArguments('Depfile must be a plain filename without a subdirectory.')\n            self.depfile = depfile\n        if 'capture' in kwargs:\n            capture = kwargs['capture']\n            if not isinstance(capture, bool):\n                raise InvalidArguments('Capture must be boolean.')\n            self.capture = capture\n        if 'depends' in kwargs:\n            depends = unholder(listify(kwargs['depends']))\n            for d in depends:\n                if not (isinstance(d, (BuildTarget, CustomTarget))):\n                    raise InvalidArguments('Depends entries must be build targets.')\n                self.depends.append(d)\n\n    def get_base_outnames(self, inname):\n        plainname = os.path.basename(inname)\n        basename = os.path.splitext(plainname)[0]\n        bases = [x.replace('@BASENAME@', basename).replace('@PLAINNAME@', plainname) for x in self.outputs]\n        return bases\n\n    def get_dep_outname(self, inname):\n        if self.depfile is None:\n            raise InvalidArguments('Tried to get dep name for rule that does not have dependency file defined.')\n        plainname = os.path.basename(inname)\n        basename = os.path.splitext(plainname)[0]\n        return self.depfile.replace('@BASENAME@', basename).replace('@PLAINNAME@', plainname)\n\n    def get_arglist(self, inname):\n        plainname = os.path.basename(inname)\n        basename = os.path.splitext(plainname)[0]\n        return [x.replace('@BASENAME@', basename).replace('@PLAINNAME@', plainname) for x in self.arglist]\n\n    def is_parent_path(self, parent, trial):\n        relpath = pathlib.PurePath(trial).relative_to(parent)\n        return relpath.parts[0] != '..' # For subdirs we can only go \"down\".\n\n    def process_files(self, name, files, state, preserve_path_from=None, extra_args=None):\n        output = GeneratedList(self, state.subdir, preserve_path_from, extra_args=extra_args if extra_args is not None else [])\n        for f in files:\n            if isinstance(f, str):\n                f = File.from_source_file(state.environment.source_dir, state.subdir, f)\n            elif not isinstance(f, File):\n                raise InvalidArguments('{} arguments must be strings or files not {!r}.'.format(name, f))\n            if preserve_path_from:\n                abs_f = f.absolute_path(state.environment.source_dir, state.environment.build_dir)\n                if not self.is_parent_path(preserve_path_from, abs_f):\n                    raise InvalidArguments('When using preserve_path_from, all input files must be in a subdirectory of the given dir.')\n            output.add_file(f, state)\n        return output\n\n\nclass GeneratedList:\n    def __init__(self, generator, subdir, preserve_path_from=None, extra_args=None):\n        self.generator = unholder(generator)\n        self.name = self.generator.exe\n        self.subdir = subdir\n        self.infilelist = []\n        self.outfilelist = []\n        self.outmap = {}\n        self.extra_depends = []\n        self.depend_files = []\n        self.preserve_path_from = preserve_path_from\n        self.extra_args = extra_args if extra_args is not None else []\n        if isinstance(self.generator.exe, dependencies.ExternalProgram):\n            if not self.generator.exe.found():\n                raise InvalidArguments('Tried to use not-found external program as generator')\n            path = self.generator.exe.get_path()\n            if os.path.isabs(path):\n                # Can only add a dependency on an external program which we\n                # know the absolute path of\n                self.depend_files.append(File.from_absolute_file(path))\n\n    def add_preserved_path_segment(self, infile, outfiles, state):\n        result = []\n        in_abs = infile.absolute_path(state.environment.source_dir, state.environment.build_dir)\n        assert(os.path.isabs(self.preserve_path_from))\n        rel = os.path.relpath(in_abs, self.preserve_path_from)\n        path_segment = os.path.dirname(rel)\n        for of in outfiles:\n            result.append(os.path.join(path_segment, of))\n        return result\n\n    def add_file(self, newfile, state):\n        self.infilelist.append(newfile)\n        outfiles = self.generator.get_base_outnames(newfile.fname)\n        if self.preserve_path_from:\n            outfiles = self.add_preserved_path_segment(newfile, outfiles, state)\n        self.outfilelist += outfiles\n        self.outmap[newfile] = outfiles\n\n    def get_inputs(self):\n        return self.infilelist\n\n    def get_outputs(self):\n        return self.outfilelist\n\n    def get_outputs_for(self, filename):\n        return self.outmap[filename]\n\n    def get_generator(self):\n        return self.generator\n\n    def get_extra_args(self):\n        return self.extra_args\n\nclass Executable(BuildTarget):\n    known_kwargs = known_exe_kwargs\n\n    def __init__(self, name, subdir, subproject, for_machine: MachineChoice, sources, objects, environment, kwargs):\n        self.typename = 'executable'\n        if 'pie' not in kwargs and 'b_pie' in environment.coredata.base_options:\n            kwargs['pie'] = environment.coredata.base_options['b_pie'].value\n        super().__init__(name, subdir, subproject, for_machine, sources, objects, environment, kwargs)\n        # Unless overridden, executables have no suffix or prefix. Except on\n        # Windows and with C#/Mono executables where the suffix is 'exe'\n        if not hasattr(self, 'prefix'):\n            self.prefix = ''\n        if not hasattr(self, 'suffix'):\n            machine = environment.machines[for_machine]\n            # Executable for Windows or C#/Mono\n            if machine.is_windows() or machine.is_cygwin() or 'cs' in self.compilers:\n                self.suffix = 'exe'\n            elif machine.system.startswith('wasm') or machine.system == 'emscripten':\n                self.suffix = 'js'\n            elif ('c' in self.compilers and self.compilers['c'].get_id().startswith('arm') or\n                  'cpp' in self.compilers and self.compilers['cpp'].get_id().startswith('arm')):\n                self.suffix = 'axf'\n            elif ('c' in self.compilers and self.compilers['c'].get_id().startswith('ccrx') or\n                  'cpp' in self.compilers and self.compilers['cpp'].get_id().startswith('ccrx')):\n                self.suffix = 'abs'\n            elif ('c' in self.compilers and self.compilers['c'].get_id().startswith('xc16')):\n                self.suffix = 'elf'\n            elif ('c' in self.compilers and self.compilers['c'].get_id().startswith('c2000') or\n                  'cpp' in self.compilers and self.compilers['cpp'].get_id().startswith('c2000')):\n                self.suffix = 'out'\n            else:\n                self.suffix = environment.machines[for_machine].get_exe_suffix()\n        self.filename = self.name\n        if self.suffix:\n            self.filename += '.' + self.suffix\n        self.outputs = [self.filename]\n\n        # The import library this target will generate\n        self.import_filename = None\n        # The import library that Visual Studio would generate (and accept)\n        self.vs_import_filename = None\n        # The import library that GCC would generate (and prefer)\n        self.gcc_import_filename = None\n        # The debugging information file this target will generate\n        self.debug_filename = None\n\n        # Check for export_dynamic\n        self.export_dynamic = False\n        if kwargs.get('export_dynamic'):\n            if not isinstance(kwargs['export_dynamic'], bool):\n                raise InvalidArguments('\"export_dynamic\" keyword argument must be a boolean')\n            self.export_dynamic = True\n        if kwargs.get('implib'):\n            self.export_dynamic = True\n        if self.export_dynamic and kwargs.get('implib') is False:\n            raise InvalidArguments('\"implib\" keyword argument must not be false for if \"export_dynamic\" is true')\n\n        m = environment.machines[for_machine]\n\n        # If using export_dynamic, set the import library name\n        if self.export_dynamic:\n            implib_basename = self.name + '.exe'\n            if not isinstance(kwargs.get('implib', False), bool):\n                implib_basename = kwargs['implib']\n            if m.is_windows() or m.is_cygwin():\n                self.vs_import_filename = '{0}.lib'.format(implib_basename)\n                self.gcc_import_filename = 'lib{0}.a'.format(implib_basename)\n                if self.get_using_msvc():\n                    self.import_filename = self.vs_import_filename\n                else:\n                    self.import_filename = self.gcc_import_filename\n\n        if m.is_windows() and ('cs' in self.compilers or\n                               self.get_using_rustc() or\n                               self.get_using_msvc()):\n            self.debug_filename = self.name + '.pdb'\n\n        # Only linkwithable if using export_dynamic\n        self.is_linkwithable = self.export_dynamic\n\n    def get_default_install_dir(self, environment):\n        return environment.get_bindir()\n\n    def description(self):\n        '''Human friendly description of the executable'''\n        return self.name\n\n    def type_suffix(self):\n        return \"@exe\"\n\n    def get_import_filename(self):\n        \"\"\"\n        The name of the import library that will be outputted by the compiler\n\n        Returns None if there is no import library required for this platform\n        \"\"\"\n        return self.import_filename\n\n    def get_import_filenameslist(self):\n        if self.import_filename:\n            return [self.vs_import_filename, self.gcc_import_filename]\n        return []\n\n    def get_debug_filename(self):\n        \"\"\"\n        The name of debuginfo file that will be created by the compiler\n\n        Returns None if the build won't create any debuginfo file\n        \"\"\"\n        return self.debug_filename\n\n    def is_linkable_target(self):\n        return self.is_linkwithable\n\nclass StaticLibrary(BuildTarget):\n    known_kwargs = known_stlib_kwargs\n\n    def __init__(self, name, subdir, subproject, for_machine: MachineChoice, sources, objects, environment, kwargs):\n        self.typename = 'static library'\n        if 'pic' not in kwargs and 'b_staticpic' in environment.coredata.base_options:\n            kwargs['pic'] = environment.coredata.base_options['b_staticpic'].value\n        super().__init__(name, subdir, subproject, for_machine, sources, objects, environment, kwargs)\n        if 'cs' in self.compilers:\n            raise InvalidArguments('Static libraries not supported for C#.')\n        if 'rust' in self.compilers:\n            # If no crate type is specified, or it's the generic lib type, use rlib\n            if not hasattr(self, 'rust_crate_type') or self.rust_crate_type == 'lib':\n                mlog.debug('Defaulting Rust static library target crate type to rlib')\n                self.rust_crate_type = 'rlib'\n            # Don't let configuration proceed with a non-static crate type\n            elif self.rust_crate_type not in ['rlib', 'staticlib']:\n                raise InvalidArguments('Crate type \"{0}\" invalid for static libraries; must be \"rlib\" or \"staticlib\"'.format(self.rust_crate_type))\n        # By default a static library is named libfoo.a even on Windows because\n        # MSVC does not have a consistent convention for what static libraries\n        # are called. The MSVC CRT uses libfoo.lib syntax but nothing else uses\n        # it and GCC only looks for static libraries called foo.lib and\n        # libfoo.a. However, we cannot use foo.lib because that's the same as\n        # the import library. Using libfoo.a is ok because people using MSVC\n        # always pass the library filename while linking anyway.\n        if not hasattr(self, 'prefix'):\n            self.prefix = 'lib'\n        if not hasattr(self, 'suffix'):\n            if 'rust' in self.compilers:\n                if not hasattr(self, 'rust_crate_type') or self.rust_crate_type == 'rlib':\n                    # default Rust static library suffix\n                    self.suffix = 'rlib'\n                elif self.rust_crate_type == 'staticlib':\n                    self.suffix = 'a'\n            else:\n                self.suffix = 'a'\n        self.filename = self.prefix + self.name + '.' + self.suffix\n        self.outputs = [self.filename]\n\n    def get_link_deps_mapping(self, prefix, environment):\n        return {}\n\n    def get_default_install_dir(self, environment):\n        return environment.get_static_lib_dir()\n\n    def type_suffix(self):\n        return \"@sta\"\n\n    def process_kwargs(self, kwargs, environment):\n        super().process_kwargs(kwargs, environment)\n        if 'rust_crate_type' in kwargs:\n            rust_crate_type = kwargs['rust_crate_type']\n            if isinstance(rust_crate_type, str):\n                self.rust_crate_type = rust_crate_type\n            else:\n                raise InvalidArguments('Invalid rust_crate_type \"{0}\": must be a string.'.format(rust_crate_type))\n\n    def is_linkable_target(self):\n        return True\n\nclass SharedLibrary(BuildTarget):\n    known_kwargs = known_shlib_kwargs\n\n    def __init__(self, name, subdir, subproject, for_machine: MachineChoice, sources, objects, environment, kwargs):\n        self.typename = 'shared library'\n        self.soversion = None\n        self.ltversion = None\n        # Max length 2, first element is compatibility_version, second is current_version\n        self.darwin_versions = []\n        self.vs_module_defs = None\n        # The import library this target will generate\n        self.import_filename = None\n        # The import library that Visual Studio would generate (and accept)\n        self.vs_import_filename = None\n        # The import library that GCC would generate (and prefer)\n        self.gcc_import_filename = None\n        # The debugging information file this target will generate\n        self.debug_filename = None\n        super().__init__(name, subdir, subproject, for_machine, sources, objects, environment, kwargs)\n        if 'rust' in self.compilers:\n            # If no crate type is specified, or it's the generic lib type, use dylib\n            if not hasattr(self, 'rust_crate_type') or self.rust_crate_type == 'lib':\n                mlog.debug('Defaulting Rust dynamic library target crate type to \"dylib\"')\n                self.rust_crate_type = 'dylib'\n            # Don't let configuration proceed with a non-dynamic crate type\n            elif self.rust_crate_type not in ['dylib', 'cdylib']:\n                raise InvalidArguments('Crate type \"{0}\" invalid for dynamic libraries; must be \"dylib\" or \"cdylib\"'.format(self.rust_crate_type))\n        if not hasattr(self, 'prefix'):\n            self.prefix = None\n        if not hasattr(self, 'suffix'):\n            self.suffix = None\n        self.basic_filename_tpl = '{0.prefix}{0.name}.{0.suffix}'\n        self.determine_filenames(environment)\n\n    def get_link_deps_mapping(self, prefix, environment):\n        result = {}\n        mappings = self.get_transitive_link_deps_mapping(prefix, environment)\n        old = get_target_macos_dylib_install_name(self)\n        if old not in mappings:\n            fname = self.get_filename()\n            outdirs, _ = self.get_install_dir(self.environment)\n            new = os.path.join(prefix, outdirs[0], fname)\n            result.update({old: new})\n        mappings.update(result)\n        return mappings\n\n    def get_default_install_dir(self, environment):\n        return environment.get_shared_lib_dir()\n\n    def determine_filenames(self, env):\n        \"\"\"\n        See https://github.com/mesonbuild/meson/pull/417 for details.\n\n        First we determine the filename template (self.filename_tpl), then we\n        set the output filename (self.filename).\n\n        The template is needed while creating aliases (self.get_aliases),\n        which are needed while generating .so shared libraries for Linux.\n\n        Besides this, there's also the import library name, which is only used\n        on Windows since on that platform the linker uses a separate library\n        called the \"import library\" during linking instead of the shared\n        library (DLL). The toolchain will output an import library in one of\n        two formats: GCC or Visual Studio.\n\n        When we're building with Visual Studio, the import library that will be\n        generated by the toolchain is self.vs_import_filename, and with\n        MinGW/GCC, it's self.gcc_import_filename. self.import_filename will\n        always contain the import library name this target will generate.\n        \"\"\"\n        prefix = ''\n        suffix = ''\n        create_debug_file = False\n        self.filename_tpl = self.basic_filename_tpl\n        # NOTE: manual prefix/suffix override is currently only tested for C/C++\n        # C# and Mono\n        if 'cs' in self.compilers:\n            prefix = ''\n            suffix = 'dll'\n            self.filename_tpl = '{0.prefix}{0.name}.{0.suffix}'\n            create_debug_file = True\n        # C, C++, Swift, Vala\n        # Only Windows uses a separate import library for linking\n        # For all other targets/platforms import_filename stays None\n        elif env.machines[self.for_machine].is_windows():\n            suffix = 'dll'\n            self.vs_import_filename = '{0}{1}.lib'.format(self.prefix if self.prefix is not None else '', self.name)\n            self.gcc_import_filename = '{0}{1}.dll.a'.format(self.prefix if self.prefix is not None else 'lib', self.name)\n            if self.get_using_rustc():\n                # Shared library is of the form foo.dll\n                prefix = ''\n                # Import library is called foo.dll.lib\n                self.import_filename = '{0}.dll.lib'.format(self.name)\n                create_debug_file = True\n            elif self.get_using_msvc():\n                # Shared library is of the form foo.dll\n                prefix = ''\n                # Import library is called foo.lib\n                self.import_filename = self.vs_import_filename\n                create_debug_file = True\n            # Assume GCC-compatible naming\n            else:\n                # Shared library is of the form libfoo.dll\n                prefix = 'lib'\n                # Import library is called libfoo.dll.a\n                self.import_filename = self.gcc_import_filename\n            # Shared library has the soversion if it is defined\n            if self.soversion:\n                self.filename_tpl = '{0.prefix}{0.name}-{0.soversion}.{0.suffix}'\n            else:\n                self.filename_tpl = '{0.prefix}{0.name}.{0.suffix}'\n        elif env.machines[self.for_machine].is_cygwin():\n            suffix = 'dll'\n            self.gcc_import_filename = '{0}{1}.dll.a'.format(self.prefix if self.prefix is not None else 'lib', self.name)\n            # Shared library is of the form cygfoo.dll\n            # (ld --dll-search-prefix=cyg is the default)\n            prefix = 'cyg'\n            # Import library is called libfoo.dll.a\n            self.import_filename = self.gcc_import_filename\n            if self.soversion:\n                self.filename_tpl = '{0.prefix}{0.name}-{0.soversion}.{0.suffix}'\n            else:\n                self.filename_tpl = '{0.prefix}{0.name}.{0.suffix}'\n        elif env.machines[self.for_machine].is_darwin():\n            prefix = 'lib'\n            suffix = 'dylib'\n            # On macOS, the filename can only contain the major version\n            if self.soversion:\n                # libfoo.X.dylib\n                self.filename_tpl = '{0.prefix}{0.name}.{0.soversion}.{0.suffix}'\n            else:\n                # libfoo.dylib\n                self.filename_tpl = '{0.prefix}{0.name}.{0.suffix}'\n        elif env.machines[self.for_machine].is_android():\n            prefix = 'lib'\n            suffix = 'so'\n            # Android doesn't support shared_library versioning\n            self.filename_tpl = '{0.prefix}{0.name}.{0.suffix}'\n        else:\n            prefix = 'lib'\n            suffix = 'so'\n            if self.ltversion:\n                # libfoo.so.X[.Y[.Z]] (.Y and .Z are optional)\n                self.filename_tpl = '{0.prefix}{0.name}.{0.suffix}.{0.ltversion}'\n            elif self.soversion:\n                # libfoo.so.X\n                self.filename_tpl = '{0.prefix}{0.name}.{0.suffix}.{0.soversion}'\n            else:\n                # No versioning, libfoo.so\n                self.filename_tpl = '{0.prefix}{0.name}.{0.suffix}'\n        if self.prefix is None:\n            self.prefix = prefix\n        if self.suffix is None:\n            self.suffix = suffix\n        self.filename = self.filename_tpl.format(self)\n        self.outputs = [self.filename]\n        if create_debug_file:\n            self.debug_filename = os.path.splitext(self.filename)[0] + '.pdb'\n\n    @staticmethod\n    def _validate_darwin_versions(darwin_versions):\n        try:\n            if isinstance(darwin_versions, int):\n                darwin_versions = str(darwin_versions)\n            if isinstance(darwin_versions, str):\n                darwin_versions = 2 * [darwin_versions]\n            if not isinstance(darwin_versions, list):\n                raise InvalidArguments('Shared library darwin_versions: must be a string, integer,'\n                                       'or a list, not {!r}'.format(darwin_versions))\n            if len(darwin_versions) > 2:\n                raise InvalidArguments('Shared library darwin_versions: list must contain 2 or fewer elements')\n            if len(darwin_versions) == 1:\n                darwin_versions = 2 * darwin_versions\n            for i, v in enumerate(darwin_versions[:]):\n                if isinstance(v, int):\n                    v = str(v)\n                if not isinstance(v, str):\n                    raise InvalidArguments('Shared library darwin_versions: list elements '\n                                           'must be strings or integers, not {!r}'.format(v))\n                if not re.fullmatch(r'[0-9]+(\\.[0-9]+){0,2}', v):\n                    raise InvalidArguments('Shared library darwin_versions: must be X.Y.Z where '\n                                           'X, Y, Z are numbers, and Y and Z are optional')\n                parts = v.split('.')\n                if len(parts) in (1, 2, 3) and int(parts[0]) > 65535:\n                    raise InvalidArguments('Shared library darwin_versions: must be X.Y.Z '\n                                           'where X is [0, 65535] and Y, Z are optional')\n                if len(parts) in (2, 3) and int(parts[1]) > 255:\n                    raise InvalidArguments('Shared library darwin_versions: must be X.Y.Z '\n                                           'where Y is [0, 255] and Y, Z are optional')\n                if len(parts) == 3 and int(parts[2]) > 255:\n                    raise InvalidArguments('Shared library darwin_versions: must be X.Y.Z '\n                                           'where Z is [0, 255] and Y, Z are optional')\n                darwin_versions[i] = v\n        except ValueError:\n            raise InvalidArguments('Shared library darwin_versions: value is invalid')\n        return darwin_versions\n\n    def process_kwargs(self, kwargs, environment):\n        super().process_kwargs(kwargs, environment)\n\n        if not self.environment.machines[self.for_machine].is_android():\n            supports_versioning = True\n        else:\n            supports_versioning = False\n\n        if supports_versioning:\n            # Shared library version\n            if 'version' in kwargs:\n                self.ltversion = kwargs['version']\n                if not isinstance(self.ltversion, str):\n                    raise InvalidArguments('Shared library version needs to be a string, not ' + type(self.ltversion).__name__)\n                if not re.fullmatch(r'[0-9]+(\\.[0-9]+){0,2}', self.ltversion):\n                    raise InvalidArguments('Invalid Shared library version \"{0}\". Must be of the form X.Y.Z where all three are numbers. Y and Z are optional.'.format(self.ltversion))\n            # Try to extract/deduce the soversion\n            if 'soversion' in kwargs:\n                self.soversion = kwargs['soversion']\n                if isinstance(self.soversion, int):\n                    self.soversion = str(self.soversion)\n                if not isinstance(self.soversion, str):\n                    raise InvalidArguments('Shared library soversion is not a string or integer.')\n            elif self.ltversion:\n                # library version is defined, get the soversion from that\n                # We replicate what Autotools does here and take the first\n                # number of the version by default.\n                self.soversion = self.ltversion.split('.')[0]\n            # macOS, iOS and tvOS dylib compatibility_version and current_version\n            if 'darwin_versions' in kwargs:\n                self.darwin_versions = self._validate_darwin_versions(kwargs['darwin_versions'])\n            elif self.soversion:\n                # If unspecified, pick the soversion\n                self.darwin_versions = 2 * [self.soversion]\n\n        # Visual Studio module-definitions file\n        if 'vs_module_defs' in kwargs:\n            path = unholder(kwargs['vs_module_defs'])\n            if isinstance(path, str):\n                if os.path.isabs(path):\n                    self.vs_module_defs = File.from_absolute_file(path)\n                else:\n                    self.vs_module_defs = File.from_source_file(environment.source_dir, self.subdir, path)\n                self.link_depends.append(self.vs_module_defs)\n            elif isinstance(path, File):\n                # When passing a generated file.\n                self.vs_module_defs = path\n                self.link_depends.append(path)\n            elif hasattr(path, 'get_filename'):\n                # When passing output of a Custom Target\n                path = File.from_built_file(path.subdir, path.get_filename())\n                self.vs_module_defs = path\n                self.link_depends.append(path)\n            else:\n                raise InvalidArguments(\n                    'Shared library vs_module_defs must be either a string, '\n                    'a file object or a Custom Target')\n        if 'rust_crate_type' in kwargs:\n            rust_crate_type = kwargs['rust_crate_type']\n            if isinstance(rust_crate_type, str):\n                self.rust_crate_type = rust_crate_type\n            else:\n                raise InvalidArguments('Invalid rust_crate_type \"{0}\": must be a string.'.format(rust_crate_type))\n\n    def get_import_filename(self):\n        \"\"\"\n        The name of the import library that will be outputted by the compiler\n\n        Returns None if there is no import library required for this platform\n        \"\"\"\n        return self.import_filename\n\n    def get_debug_filename(self):\n        \"\"\"\n        The name of debuginfo file that will be created by the compiler\n\n        Returns None if the build won't create any debuginfo file\n        \"\"\"\n        return self.debug_filename\n\n    def get_import_filenameslist(self):\n        if self.import_filename:\n            return [self.vs_import_filename, self.gcc_import_filename]\n        return []\n\n    def get_all_link_deps(self):\n        return [self] + self.get_transitive_link_deps()\n\n    def get_aliases(self):\n        \"\"\"\n        If the versioned library name is libfoo.so.0.100.0, aliases are:\n        * libfoo.so.0 (soversion) -> libfoo.so.0.100.0\n        * libfoo.so (unversioned; for linking) -> libfoo.so.0\n        Same for dylib:\n        * libfoo.dylib (unversioned; for linking) -> libfoo.0.dylib\n        \"\"\"\n        aliases = {}\n        # Aliases are only useful with .so and .dylib libraries. Also if\n        # there's no self.soversion (no versioning), we don't need aliases.\n        if self.suffix not in ('so', 'dylib') or not self.soversion:\n            return {}\n        # With .so libraries, the minor and micro versions are also in the\n        # filename. If ltversion != soversion we create an soversion alias:\n        # libfoo.so.0 -> libfoo.so.0.100.0\n        # Where libfoo.so.0.100.0 is the actual library\n        if self.suffix == 'so' and self.ltversion and self.ltversion != self.soversion:\n            alias_tpl = self.filename_tpl.replace('ltversion', 'soversion')\n            ltversion_filename = alias_tpl.format(self)\n            aliases[ltversion_filename] = self.filename\n        # libfoo.so.0/libfoo.0.dylib is the actual library\n        else:\n            ltversion_filename = self.filename\n        # Unversioned alias:\n        #  libfoo.so -> libfoo.so.0\n        #  libfoo.dylib -> libfoo.0.dylib\n        aliases[self.basic_filename_tpl.format(self)] = ltversion_filename\n        return aliases\n\n    def type_suffix(self):\n        return \"@sha\"\n\n    def is_linkable_target(self):\n        return True\n\n# A shared library that is meant to be used with dlopen rather than linking\n# into something else.\nclass SharedModule(SharedLibrary):\n    known_kwargs = known_shmod_kwargs\n\n    def __init__(self, name, subdir, subproject, for_machine: MachineChoice, sources, objects, environment, kwargs):\n        if 'version' in kwargs:\n            raise MesonException('Shared modules must not specify the version kwarg.')\n        if 'soversion' in kwargs:\n            raise MesonException('Shared modules must not specify the soversion kwarg.')\n        super().__init__(name, subdir, subproject, for_machine, sources, objects, environment, kwargs)\n        self.typename = 'shared module'\n\n    def get_default_install_dir(self, environment):\n        return environment.get_shared_module_dir()\n\n\nclass CustomTarget(Target):\n    known_kwargs = set([\n        'input',\n        'output',\n        'command',\n        'capture',\n        'install',\n        'install_dir',\n        'install_mode',\n        'build_always',\n        'build_always_stale',\n        'depends',\n        'depend_files',\n        'depfile',\n        'build_by_default',\n        'override_options',\n        'console',\n    ])\n\n    def __init__(self, name, subdir, subproject, kwargs, absolute_paths=False, backend=None):\n        self.typename = 'custom'\n        # TODO expose keyword arg to make MachineChoice.HOST configurable\n        super().__init__(name, subdir, subproject, False, MachineChoice.HOST)\n        self.dependencies = []\n        self.extra_depends = []\n        self.depend_files = [] # Files that this target depends on but are not on the command line.\n        self.depfile = None\n        self.process_kwargs(kwargs, backend)\n        self.extra_files = []\n        # Whether to use absolute paths for all files on the commandline\n        self.absolute_paths = absolute_paths\n        unknowns = []\n        for k in kwargs:\n            if k not in CustomTarget.known_kwargs:\n                unknowns.append(k)\n        if len(unknowns) > 0:\n            mlog.warning('Unknown keyword arguments in target {}: {}'.format(self.name, ', '.join(unknowns)))\n\n    def get_default_install_dir(self, environment):\n        return None\n\n    def __repr__(self):\n        repr_str = \"<{0} {1}: {2}>\"\n        return repr_str.format(self.__class__.__name__, self.get_id(), self.command)\n\n    def get_target_dependencies(self):\n        deps = self.dependencies[:]\n        deps += self.extra_depends\n        for c in unholder(self.sources):\n            if isinstance(c, (BuildTarget, CustomTarget)):\n                deps.append(c)\n        return deps\n\n    def get_transitive_build_target_deps(self):\n        '''\n        Recursively fetch the build targets that this custom target depends on,\n        whether through `command:`, `depends:`, or `sources:` The recursion is\n        only performed on custom targets.\n        This is useful for setting PATH on Windows for finding required DLLs.\n        F.ex, if you have a python script that loads a C module that links to\n        other DLLs in your project.\n        '''\n        bdeps = set()\n        deps = self.get_target_dependencies()\n        for d in deps:\n            if isinstance(d, BuildTarget):\n                bdeps.add(d)\n            elif isinstance(d, CustomTarget):\n                bdeps.update(d.get_transitive_build_target_deps())\n        return bdeps\n\n    def flatten_command(self, cmd):\n        cmd = unholder(listify(cmd))\n        final_cmd = []\n        for c in cmd:\n            if isinstance(c, str):\n                final_cmd.append(c)\n            elif isinstance(c, File):\n                self.depend_files.append(c)\n                final_cmd.append(c)\n            elif isinstance(c, dependencies.ExternalProgram):\n                if not c.found():\n                    raise InvalidArguments('Tried to use not-found external program in \"command\"')\n                path = c.get_path()\n                if os.path.isabs(path):\n                    # Can only add a dependency on an external program which we\n                    # know the absolute path of\n                    self.depend_files.append(File.from_absolute_file(path))\n                final_cmd += c.get_command()\n            elif isinstance(c, (BuildTarget, CustomTarget)):\n                self.dependencies.append(c)\n                final_cmd.append(c)\n            elif isinstance(c, list):\n                final_cmd += self.flatten_command(c)\n            else:\n                raise InvalidArguments('Argument {!r} in \"command\" is invalid'.format(c))\n        return final_cmd\n\n    def process_kwargs(self, kwargs, backend):\n        self.process_kwargs_base(kwargs)\n        self.sources = unholder(extract_as_list(kwargs, 'input'))\n        if 'output' not in kwargs:\n            raise InvalidArguments('Missing keyword argument \"output\".')\n        self.outputs = listify(kwargs['output'])\n        # This will substitute values from the input into output and return it.\n        inputs = get_sources_string_names(self.sources, backend)\n        values = get_filenames_templates_dict(inputs, [])\n        for i in self.outputs:\n            if not(isinstance(i, str)):\n                raise InvalidArguments('Output argument not a string.')\n            if i == '':\n                raise InvalidArguments('Output must not be empty.')\n            if i.strip() == '':\n                raise InvalidArguments('Output must not consist only of whitespace.')\n            if has_path_sep(i):\n                raise InvalidArguments('Output {!r} must not contain a path segment.'.format(i))\n            if '@INPUT@' in i or '@INPUT0@' in i:\n                m = 'Output cannot contain @INPUT@ or @INPUT0@, did you ' \\\n                    'mean @PLAINNAME@ or @BASENAME@?'\n                raise InvalidArguments(m)\n            # We already check this during substitution, but the error message\n            # will be unclear/confusing, so check it here.\n            if len(inputs) != 1 and ('@PLAINNAME@' in i or '@BASENAME@' in i):\n                m = \"Output cannot contain @PLAINNAME@ or @BASENAME@ when \" \\\n                    \"there is more than one input (we can't know which to use)\"\n                raise InvalidArguments(m)\n        self.outputs = substitute_values(self.outputs, values)\n        self.capture = kwargs.get('capture', False)\n        if self.capture and len(self.outputs) != 1:\n            raise InvalidArguments('Capturing can only output to a single file.')\n        self.console = kwargs.get('console', False)\n        if not isinstance(self.console, bool):\n            raise InvalidArguments('\"console\" kwarg only accepts booleans')\n        if self.capture and self.console:\n            raise InvalidArguments(\"Can't both capture output and output to console\")\n        if 'command' not in kwargs:\n            raise InvalidArguments('Missing keyword argument \"command\".')\n        if 'depfile' in kwargs:\n            depfile = kwargs['depfile']\n            if not isinstance(depfile, str):\n                raise InvalidArguments('Depfile must be a string.')\n            if os.path.basename(depfile) != depfile:\n                raise InvalidArguments('Depfile must be a plain filename without a subdirectory.')\n            self.depfile = depfile\n        self.command = self.flatten_command(kwargs['command'])\n        if self.capture:\n            for c in self.command:\n                if isinstance(c, str) and '@OUTPUT@' in c:\n                    raise InvalidArguments('@OUTPUT@ is not allowed when capturing output.')\n        if 'install' in kwargs:\n            self.install = kwargs['install']\n            if not isinstance(self.install, bool):\n                raise InvalidArguments('\"install\" must be boolean.')\n            if self.install:\n                if 'install_dir' not in kwargs:\n                    raise InvalidArguments('\"install_dir\" must be specified '\n                                           'when installing a target')\n\n                if isinstance(kwargs['install_dir'], list):\n                    FeatureNew('multiple install_dir for custom_target', '0.40.0').use(self.subproject)\n                # If an item in this list is False, the output corresponding to\n                # the list index of that item will not be installed\n                self.install_dir = typeslistify(kwargs['install_dir'], (str, bool))\n                self.install_mode = kwargs.get('install_mode', None)\n        else:\n            self.install = False\n            self.install_dir = [None]\n            self.install_mode = None\n        if 'build_always' in kwargs and 'build_always_stale' in kwargs:\n            raise InvalidArguments('build_always and build_always_stale are mutually exclusive. Combine build_by_default and build_always_stale.')\n        elif 'build_always' in kwargs:\n            mlog.deprecation('build_always is deprecated. Combine build_by_default and build_always_stale instead.')\n            if 'build_by_default' not in kwargs:\n                self.build_by_default = kwargs['build_always']\n            self.build_always_stale = kwargs['build_always']\n        elif 'build_always_stale' in kwargs:\n            self.build_always_stale = kwargs['build_always_stale']\n        if not isinstance(self.build_always_stale, bool):\n            raise InvalidArguments('Argument build_always_stale must be a boolean.')\n        extra_deps, depend_files = [extract_as_list(kwargs, c, pop=False) for c in ['depends', 'depend_files']]\n        for ed in unholder(extra_deps):\n            if not isinstance(ed, (CustomTarget, BuildTarget)):\n                raise InvalidArguments('Can only depend on toplevel targets: custom_target or build_target (executable or a library) got: {}({})'\n                                      .format(type(ed), ed))\n            self.extra_depends.append(ed)\n        for i in depend_files:\n            if isinstance(i, (File, str)):\n                self.depend_files.append(i)\n            else:\n                mlog.debug(i)\n                raise InvalidArguments('Unknown type {!r} in depend_files.'.format(type(i).__name__))\n\n    def get_dependencies(self):\n        return self.dependencies\n\n    def should_install(self):\n        return self.install\n\n    def get_custom_install_dir(self):\n        return self.install_dir\n\n    def get_custom_install_mode(self):\n        return self.install_mode\n\n    def get_outputs(self):\n        return self.outputs\n\n    def get_filename(self):\n        return self.outputs[0]\n\n    def get_sources(self):\n        return self.sources\n\n    def get_generated_lists(self):\n        genlists = []\n        for c in unholder(self.sources):\n            if isinstance(c, GeneratedList):\n                genlists.append(c)\n        return genlists\n\n    def get_generated_sources(self):\n        return self.get_generated_lists()\n\n    def get_dep_outname(self, infilenames):\n        if self.depfile is None:\n            raise InvalidArguments('Tried to get depfile name for custom_target that does not have depfile defined.')\n        if len(infilenames):\n            plainname = os.path.basename(infilenames[0])\n            basename = os.path.splitext(plainname)[0]\n            return self.depfile.replace('@BASENAME@', basename).replace('@PLAINNAME@', plainname)\n        else:\n            if '@BASENAME@' in self.depfile or '@PLAINNAME@' in self.depfile:\n                raise InvalidArguments('Substitution in depfile for custom_target that does not have an input file.')\n            return self.depfile\n\n    def is_linkable_target(self):\n        if len(self.outputs) != 1:\n            return False\n        suf = os.path.splitext(self.outputs[0])[-1]\n        if suf == '.a' or suf == '.dll' or suf == '.lib' or suf == '.so':\n            return True\n\n    def get_link_deps_mapping(self, prefix, environment):\n        return {}\n\n    def get_link_dep_subdirs(self):\n        return OrderedSet()\n\n    def get_all_link_deps(self):\n        return []\n\n    def type_suffix(self):\n        return \"@cus\"\n\n    def __getitem__(self, index):\n        return CustomTargetIndex(self, self.outputs[index])\n\n    def __setitem__(self, index, value):\n        raise NotImplementedError\n\n    def __delitem__(self, index):\n        raise NotImplementedError\n\n    def __iter__(self):\n        for i in self.outputs:\n            yield CustomTargetIndex(self, i)\n\nclass RunTarget(Target):\n    def __init__(self, name, command, args, dependencies, subdir, subproject):\n        self.typename = 'run'\n        # These don't produce output artifacts\n        super().__init__(name, subdir, subproject, False, MachineChoice.BUILD)\n        self.command = command\n        self.args = args\n        self.dependencies = dependencies\n\n    def __repr__(self):\n        repr_str = \"<{0} {1}: {2}>\"\n        return repr_str.format(self.__class__.__name__, self.get_id(), self.command)\n\n    def process_kwargs(self, kwargs):\n        return self.process_kwargs_base(kwargs)\n\n    def get_dependencies(self):\n        return self.dependencies\n\n    def get_generated_sources(self):\n        return []\n\n    def get_sources(self):\n        return []\n\n    def should_install(self):\n        return False\n\n    def get_filename(self):\n        return self.name\n\n    def get_outputs(self):\n        if isinstance(self.name, str):\n            return [self.name]\n        elif isinstance(self.name, list):\n            return self.name\n        else:\n            raise RuntimeError('RunTarget: self.name is neither a list nor a string. This is a bug')\n\n    def type_suffix(self):\n        return \"@run\"\n\nclass AliasTarget(RunTarget):\n    def __init__(self, name, dependencies, subdir, subproject):\n        super().__init__(name, '', [], dependencies, subdir, subproject)\n\nclass Jar(BuildTarget):\n    known_kwargs = known_jar_kwargs\n\n    def __init__(self, name, subdir, subproject, for_machine: MachineChoice, sources, objects, environment, kwargs):\n        self.typename = 'jar'\n        super().__init__(name, subdir, subproject, for_machine, sources, objects, environment, kwargs)\n        for s in self.sources:\n            if not s.endswith('.java'):\n                raise InvalidArguments('Jar source {} is not a java file.'.format(s))\n        for t in self.link_targets:\n            if not isinstance(t, Jar):\n                raise InvalidArguments('Link target {} is not a jar target.'.format(t))\n        self.filename = self.name + '.jar'\n        self.outputs = [self.filename]\n        self.java_args = kwargs.get('java_args', [])\n\n    def get_main_class(self):\n        return self.main_class\n\n    def type_suffix(self):\n        return \"@jar\"\n\n    def get_java_args(self):\n        return self.java_args\n\n    def validate_install(self, environment):\n        # All jar targets are installable.\n        pass\n\n    def is_linkable_target(self):\n        return True\n\n    def get_classpath_args(self):\n        cp_paths = [os.path.join(l.get_subdir(), l.get_filename()) for l in self.link_targets]\n        cp_string = os.pathsep.join(cp_paths)\n        if cp_string:\n            return ['-cp', os.pathsep.join(cp_paths)]\n        return []\n\nclass CustomTargetIndex:\n\n    \"\"\"A special opaque object returned by indexing a CustomTarget. This object\n    exists in meson, but acts as a proxy in the backends, making targets depend\n    on the CustomTarget it's derived from, but only adding one source file to\n    the sources.\n    \"\"\"\n\n    def __init__(self, target, output):\n        self.typename = 'custom'\n        self.target = target\n        self.output = output\n        self.for_machine = target.for_machine\n\n    def __repr__(self):\n        return '<CustomTargetIndex: {!r}[{}]>'.format(\n            self.target, self.target.get_outputs().index(self.output))\n\n    def get_outputs(self):\n        return [self.output]\n\n    def get_subdir(self):\n        return self.target.get_subdir()\n\n    def get_filename(self):\n        return self.output\n\n    def get_id(self):\n        return self.target.get_id()\n\n    def get_all_link_deps(self):\n        return self.target.get_all_link_deps()\n\n    def get_link_deps_mapping(self, prefix, environment):\n        return self.target.get_link_deps_mapping(prefix, environment)\n\n    def get_link_dep_subdirs(self):\n        return self.target.get_link_dep_subdirs()\n\n    def is_linkable_target(self):\n        suf = os.path.splitext(self.output)[-1]\n        if suf == '.a' or suf == '.dll' or suf == '.lib' or suf == '.so':\n            return True\n\nclass ConfigureFile:\n\n    def __init__(self, subdir, sourcename, targetname, configuration_data):\n        self.subdir = subdir\n        self.sourcename = sourcename\n        self.targetname = targetname\n        self.configuration_data = configuration_data\n\n    def __repr__(self):\n        repr_str = \"<{0}: {1} -> {2}>\"\n        src = os.path.join(self.subdir, self.sourcename)\n        dst = os.path.join(self.subdir, self.targetname)\n        return repr_str.format(self.__class__.__name__, src, dst)\n\n    def get_configuration_data(self):\n        return self.configuration_data\n\n    def get_subdir(self):\n        return self.subdir\n\n    def get_source_name(self):\n        return self.sourcename\n\n    def get_target_name(self):\n        return self.targetname\n\nclass ConfigurationData:\n    def __init__(self) -> None:\n        super().__init__()\n        self.values = {}  # T.Dict[str, T.Union[str, int, bool]]\n\n    def __repr__(self):\n        return repr(self.values)\n\n    def __contains__(self, value: str) -> bool:\n        return value in self.values\n\n    def get(self, name: str) -> T.Tuple[T.Union[str, int, bool], T.Optional[str]]:\n        return self.values[name] # (val, desc)\n\n    def keys(self) -> T.Iterator[str]:\n        return self.values.keys()\n\n# A bit poorly named, but this represents plain data files to copy\n# during install.\nclass Data:\n    def __init__(self, sources, install_dir, install_mode=None, rename=None):\n        self.sources = sources\n        self.install_dir = install_dir\n        self.install_mode = install_mode\n        self.sources = listify(self.sources)\n        for s in self.sources:\n            assert(isinstance(s, File))\n        if rename is None:\n            self.rename = [os.path.basename(f.fname) for f in self.sources]\n        else:\n            self.rename = stringlistify(rename)\n            if len(self.rename) != len(self.sources):\n                raise MesonException('Size of rename argument is different from number of sources')\n\nclass RunScript(dict):\n    def __init__(self, script, args):\n        super().__init__()\n        assert(isinstance(script, list))\n        assert(isinstance(args, list))\n        self['exe'] = script\n        self['args'] = args\n\nclass TestSetup:\n    def __init__(self, exe_wrapper: T.Optional[T.List[str]], gdb: bool,\n                 timeout_multiplier: int, env: EnvironmentVariables):\n        self.exe_wrapper = exe_wrapper\n        self.gdb = gdb\n        self.timeout_multiplier = timeout_multiplier\n        self.env = env\n\ndef get_sources_string_names(sources, backend):\n    '''\n    For the specified list of @sources which can be strings, Files, or targets,\n    get all the output basenames.\n    '''\n    names = []\n    for s in unholder(sources):\n        if isinstance(s, str):\n            names.append(s)\n        elif isinstance(s, (BuildTarget, CustomTarget, CustomTargetIndex, GeneratedList)):\n            names += s.get_outputs()\n        elif isinstance(s, ExtractedObjects):\n            names += s.get_outputs(backend)\n        elif isinstance(s, File):\n            names.append(s.fname)\n        else:\n            raise AssertionError('Unknown source type: {!r}'.format(s))\n    return names\n\ndef load(build_dir: str) -> Build:\n    filename = os.path.join(build_dir, 'meson-private', 'build.dat')\n    load_fail_msg = 'Build data file {!r} is corrupted. Try with a fresh build tree.'.format(filename)\n    nonexisting_fail_msg = 'No such build data file as \"{!r}\".'.format(filename)\n    try:\n        with open(filename, 'rb') as f:\n            obj = pickle.load(f)\n    except FileNotFoundError:\n        raise MesonException(nonexisting_fail_msg)\n    except (pickle.UnpicklingError, EOFError):\n        raise MesonException(load_fail_msg)\n    except AttributeError:\n        raise MesonException(\n            \"Build data file {!r} references functions or classes that don't \"\n            \"exist. This probably means that it was generated with an old \"\n            \"version of meson. Try running from the source directory \"\n            \"meson {} --wipe\".format(filename, build_dir))\n    if not isinstance(obj, Build):\n        raise MesonException(load_fail_msg)\n    return obj\n\ndef save(obj, filename):\n    with open(filename, 'wb') as f:\n        pickle.dump(obj, f)\n",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/test cases/common/152 shared module resolving symbol in executable/prog.c": "#include <stdio.h>\n#include <assert.h>\n#ifdef _WIN32\n#include <windows.h>\n#else\n#include <dlfcn.h>\n#endif\n\n#if defined _WIN32 || defined __CYGWIN__\n  #define DLL_PUBLIC __declspec(dllexport)\n#else\n  #if defined __GNUC__\n    #define DLL_PUBLIC __attribute__ ((visibility(\"default\")))\n  #else\n    #pragma message (\"Compiler does not support symbol visibility.\")\n    #define DLL_PUBLIC\n  #endif\n#endif\n\ntypedef int (*fptr) (void);\n\nint DLL_PUBLIC\nfunc_from_executable(void)\n{\n  return 42;\n}\n\nint main(int argc, char **argv)\n{\n  int expected, actual;\n  fptr importedfunc;\n\n  if (argc=0) {};  // noop\n\n#ifdef _WIN32\n  HMODULE h = LoadLibraryA(argv[1]);\n#else\n  void *h = dlopen(argv[1], RTLD_NOW);\n#endif\n  assert(h != NULL);\n\n#ifdef _WIN32\n  importedfunc = (fptr) GetProcAddress (h, \"func\");\n#else\n  importedfunc = (fptr) dlsym(h, \"func\");\n#endif\n  assert(importedfunc != NULL);\n  assert(importedfunc != func_from_executable);\n\n  actual = (*importedfunc)();\n  expected = func_from_executable();\n  assert(actual == expected);\n\n#ifdef _WIN32\n  FreeLibrary(h);\n#else\n  dlclose(h);\n#endif\n\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/test cases/common/121 shared module/prog.c": "\n#include <stdio.h>\n\nint func_from_language_runtime(void);\ntypedef int (*fptr) (void);\n\n#ifdef _WIN32\n\n#include <windows.h>\n\nstatic wchar_t*\nwin32_get_last_error (void)\n{\n    wchar_t *msg = NULL;\n\n    FormatMessageW (FORMAT_MESSAGE_ALLOCATE_BUFFER\n                    | FORMAT_MESSAGE_IGNORE_INSERTS\n                    | FORMAT_MESSAGE_FROM_SYSTEM,\n                    NULL, GetLastError (), 0,\n                    (LPWSTR) &msg, 0, NULL);\n    return msg;\n}\n\nint main(int argc, char **argv)\n{\n    HINSTANCE handle;\n    fptr importedfunc;\n    int expected, actual;\n    int ret = 1;\n    if(argc==0) {};\n\n    handle = LoadLibraryA (argv[1]);\n    if (!handle) {\n        wchar_t *msg = win32_get_last_error ();\n        printf (\"Could not open %s: %S\\n\", argv[1], msg);\n        goto nohandle;\n    }\n\n    importedfunc = (fptr) GetProcAddress (handle, \"func\");\n    if (importedfunc == NULL) {\n        wchar_t *msg = win32_get_last_error ();\n        printf (\"Could not find 'func': %S\\n\", msg);\n        goto out;\n    }\n\n    actual = importedfunc ();\n    expected = func_from_language_runtime ();\n    if (actual != expected) {\n        printf (\"Got %i instead of %i\\n\", actual, expected);\n        goto out;\n    }\n\n    ret = 0;\nout:\n    FreeLibrary (handle);\nnohandle:\n    return ret;\n}\n\n#else\n\n#include<dlfcn.h>\n#include<assert.h>\n\nint main(int argc, char **argv) {\n    void *dl;\n    fptr importedfunc;\n    int expected, actual;\n    char *error;\n    int ret = 1;\n    if(argc==0) {};\n\n    dlerror();\n    dl = dlopen(argv[1], RTLD_LAZY);\n    error = dlerror();\n    if(error) {\n        printf(\"Could not open %s: %s\\n\", argv[1], error);\n        goto nodl;\n    }\n\n    importedfunc = (fptr) dlsym(dl, \"func\");\n    if (importedfunc == NULL) {\n        printf (\"Could not find 'func'\\n\");\n        goto out;\n    }\n\n    assert(importedfunc != func_from_language_runtime);\n\n    actual = (*importedfunc)();\n    expected = func_from_language_runtime ();\n    if (actual != expected) {\n        printf (\"Got %i instead of %i\\n\", actual, expected);\n        goto out;\n    }\n\n    ret = 0;\nout:\n    dlclose(dl);\nnodl:\n    return ret;\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/test cases/common/121 shared module/module.c": "#if defined _WIN32 || defined __CYGWIN__\n  #define DLL_PUBLIC __declspec(dllexport)\n#else\n  #if defined __GNUC__\n    #define DLL_PUBLIC __attribute__ ((visibility(\"default\")))\n  #else\n    #pragma message (\"Compiler does not support symbol visibility.\")\n    #define DLL_PUBLIC\n  #endif\n#endif\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n\n#include <stdio.h>\n\ntypedef int (*fptr) (void);\n\n#ifdef __CYGWIN__\n\n#include <dlfcn.h>\n\nfptr find_any_f (const char *name) {\n    return (fptr) dlsym(RTLD_DEFAULT, name);\n}\n#else /* _WIN32 */\n\n#include <windows.h>\n#include <tlhelp32.h>\n\nstatic wchar_t*\nwin32_get_last_error (void)\n{\n    wchar_t *msg = NULL;\n\n    FormatMessageW (FORMAT_MESSAGE_ALLOCATE_BUFFER\n                    | FORMAT_MESSAGE_IGNORE_INSERTS\n                    | FORMAT_MESSAGE_FROM_SYSTEM,\n                    NULL, GetLastError (), 0,\n                    (LPWSTR) &msg, 0, NULL);\n    return msg;\n}\n\n/* Unlike Linux and OS X, when a library is loaded, all the symbols aren't\n * loaded into a single namespace. You must fetch the symbol by iterating over\n * all loaded modules. Code for finding the function from any of the loaded\n * modules is taken from gmodule.c in glib */\nfptr find_any_f (const char *name) {\n    fptr f;\n    HANDLE snapshot;\n    MODULEENTRY32 me32;\n\n    snapshot = CreateToolhelp32Snapshot (TH32CS_SNAPMODULE, 0);\n    if (snapshot == (HANDLE) -1) {\n        wchar_t *msg = win32_get_last_error();\n        printf(\"Could not get snapshot: %S\\n\", msg);\n        return 0;\n    }\n\n    me32.dwSize = sizeof (me32);\n\n    f = NULL;\n    if (Module32First (snapshot, &me32)) {\n        do {\n            if ((f = (fptr) GetProcAddress (me32.hModule, name)) != NULL)\n                break;\n        } while (Module32Next (snapshot, &me32));\n    }\n\n    CloseHandle (snapshot);\n    return f;\n}\n#endif\n\nint DLL_PUBLIC func(void) {\n    fptr f;\n\n    f = find_any_f (\"func_from_language_runtime\");\n    if (f != NULL)\n        return f();\n    printf (\"Could not find function\\n\");\n    return 1;\n}\n\n#else\n/*\n * Shared modules often have references to symbols that are not defined\n * at link time, but which will be provided from deps of the executable that\n * dlopens it. We need to make sure that this works, i.e. that we do\n * not pass -Wl,--no-undefined when linking modules.\n */\nint func_from_language_runtime(void);\n\nint DLL_PUBLIC func(void) {\n    return func_from_language_runtime();\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/test cases/common/121 shared module/meson.build": "project('shared module', 'c')\n\ndl = meson.get_compiler('c').find_library('dl', required : false)\nl = shared_library('runtime', 'runtime.c')\n# Do NOT link the module with the runtime library. This\n# is a common approach for plugins that are only used\n# with dlopen. Any symbols are resolved dynamically\n# at runtime.  This requires extra help on Windows, so\n# should be avoided unless really necessary.\nm = shared_module('mymodule', 'module.c')\ne = executable('prog', 'prog.c',\n  link_with : l, export_dynamic : true, dependencies : dl)\ntest('import test', e, args : m)\n\n# Same as above, but module created with build_target()\nm2 = build_target('mymodule2', 'module.c', target_type: 'shared_module')\ntest('import test 2', e, args : m2)\n\n# Shared module that does not export any symbols\nshared_module('nosyms', 'nosyms.c',\n  install : true,\n  install_dir : join_paths(get_option('libdir'), 'modules'))\n",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/tools/ac_converter.py": "#!/usr/bin/env python3\n\n# Copyright 2015 The Meson development team\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nhelp_message = \"\"\"Usage: {} <config.h.meson>\n\nThis script reads config.h.meson, looks for header\nchecks and writes the corresponding meson declaration.\n\nCopy config.h.in to config.h.meson, replace #undef\nwith #mesondefine and run this. We can't do this automatically\nbecause some configure scripts have #undef statements\nthat are unrelated to configure checks.\n\"\"\"\n\nimport sys\n\n\n# Add stuff here as it is encountered.\nfunction_data = \\\n    {'HAVE_FEENABLEEXCEPT': ('feenableexcept', 'fenv.h'),\n     'HAVE_FECLEAREXCEPT': ('feclearexcept', 'fenv.h'),\n     'HAVE_FEDISABLEEXCEPT': ('fedisableexcept', 'fenv.h'),\n     'HAVE_MMAP': ('mmap', 'sys/mman.h'),\n     'HAVE_GETPAGESIZE': ('getpagesize', 'unistd.h'),\n     'HAVE_GETISAX': ('getisax', 'sys/auxv.h'),\n     'HAVE_GETTIMEOFDAY': ('gettimeofday', 'sys/time.h'),\n     'HAVE_MPROTECT': ('mprotect', 'sys/mman.h'),\n     'HAVE_POSIX_MEMALIGN': ('posix_memalign', 'stdlib.h'),\n     'HAVE_SIGACTION': ('sigaction', 'signal.h'),\n     'HAVE_ALARM': ('alarm', 'unistd.h'),\n     'HAVE_CTIME_R': ('ctime_r', 'time.h'),\n     'HAVE_DRAND48': ('drand48', 'stdlib.h'),\n     'HAVE_FLOCKFILE': ('flockfile', 'stdio.h'),\n     'HAVE_FORK': ('fork', 'unistd.h'),\n     'HAVE_FUNLOCKFILE': ('funlockfile', 'stdio.h'),\n     'HAVE_GETLINE': ('getline', 'stdio.h'),\n     'HAVE_LINK': ('link', 'unistd.h'),\n     'HAVE_RAISE': ('raise', 'signal.h'),\n     'HAVE_STRNDUP': ('strndup', 'string.h'),\n     'HAVE_SCHED_GETAFFINITY': ('sched_getaffinity', 'sched.h'),\n     'HAVE_WAITPID': ('waitpid', 'sys/wait.h'),\n     'HAVE_XRENDERCREATECONICALGRADIENT': ('XRenderCreateConicalGradient', 'xcb/render.h'),\n     'HAVE_XRENDERCREATELINEARGRADIENT': ('XRenderCreateLinearGradient', 'xcb/render.h'),\n     'HAVE_XRENDERCREATERADIALGRADIENT': ('XRenderCreateRadialGradient', 'xcb/render.h'),\n     'HAVE_XRENDERCREATESOLIDFILL': ('XRenderCreateSolidFill', 'xcb/render.h'),\n     'HAVE_DCGETTEXT': ('dcgettext', 'libintl.h'),\n     'HAVE_ENDMNTENT': ('endmntent', 'mntent.h'),\n     'HAVE_ENDSERVENT': ('endservent', 'netdb.h'),\n     'HAVE_EVENTFD': ('eventfd', 'sys/eventfd.h'),\n     'HAVE_FALLOCATE': ('fallocate', 'fcntl.h'),\n     'HAVE_FCHMOD': ('fchmod', 'sys/stat.h'),\n     'HAVE_FCHOWN': ('fchown', 'unistd.h'),\n     'HAVE_FDWALK': ('fdwalk', 'stdlib.h'),\n     'HAVE_FSYNC': ('fsync', 'unistd.h'),\n     'HAVE_GETC_UNLOCKED': ('getc_unlocked', 'stdio.h'),\n     'HAVE_GETFSSTAT': ('getfsstat', 'sys/mount.h'),\n     'HAVE_GETMNTENT_R': ('getmntent_r', 'mntent.h'),\n     'HAVE_GETPROTOBYNAME_R': ('getprotobyname_r', 'netdb.h'),\n     'HAVE_GETRESUID': ('getresuid', 'unistd.h'),\n     'HAVE_GETVFSSTAT': ('getvfsstat', 'sys/statvfs.h'),\n     'HAVE_GMTIME_R': ('gmtime_r', 'time.h'),\n     'HAVE_HASMNTOPT': ('hasmntopt', 'mntent.h'),\n     'HAVE_IF_INDEXTONAME': ('if_indextoname', 'net/if.h'),\n     'HAVE_IF_NAMETOINDEX': ('if_nametoindex', 'net/if.h'),\n     'HAVE_INOTIFY_INIT1': ('inotify_init1', 'sys/inotify.h'),\n     'HAVE_ISSETUGID': ('issetugid', 'unistd.h'),\n     'HAVE_KEVENT': ('kevent', 'sys/event.h'),\n     'HAVE_KQUEUE': ('kqueue', 'sys/event.h'),\n     'HAVE_LCHMOD': ('lchmod', 'sys/stat.h'),\n     'HAVE_LCHOWN': ('lchown', 'unistd.h'),\n     'HAVE_LSTAT': ('lstat', 'sys/stat.h'),\n     'HAVE_MEMCPY': ('memcpy', 'string.h'),\n     'HAVE_MEMALIGN': ('memalign', 'stdlib.h'),\n     'HAVE_MEMMEM': ('memmem', 'string.h'),\n     'HAVE_NEWLOCALE': ('newlocale', 'locale.h'),\n     'HAVE_PIPE2': ('pipe2', 'fcntl.h'),\n     'HAVE_POLL': ('poll', 'poll.h'),\n     'HAVE_PRLIMIT': ('prlimit', 'sys/resource.h'),\n     'HAVE_PTHREAD_ATTR_SETSTACKSIZE': ('pthread_attr_setstacksize', 'pthread.h'),\n     'HAVE_PTHREAD_CONDATTR_SETCLOCK': ('pthread_condattr_setclock', 'pthread.h'),\n     'HAVE_PTHREAD_COND_TIMEDWAIT_RELATIVE_NP': ('pthread_cond_timedwait_relative_np', 'pthread.h'),\n     'HAVE_READLINK': ('readlink', 'unistd.h'),\n     'HAVE_RES_INIT': ('res_init', 'resolv.h'),\n     'HAVE_SENDMMSG': ('sendmmsg', 'sys/socket.h'),\n     'HAVE_SOCKET': ('socket', 'sys/socket.h'),\n     'HAVE_GETENV': ('getenv', 'stdlib.h'),\n     'HAVE_SETENV': ('setenv', 'stdlib.h'),\n     'HAVE_PUTENV': ('putenv', 'stdlib.h'),\n     'HAVE_UNSETENV': ('unsetenv', 'stdlib.h'),\n     'HAVE_SETMNTENT': ('setmntent', 'mntent.h'),\n     'HAVE_SNPRINTF': ('snprintf', 'stdio.h'),\n     'HAVE_SPLICE': ('splice', 'fcntl.h'),\n     'HAVE_STATFS': ('statfs', 'mount.h'),\n     'HAVE_STATVFS': ('statvfs', 'sys/statvfs.h'),\n     'HAVE_STPCOPY': ('stpcopy', 'string.h'),\n     'HAVE_STRCASECMP': ('strcasecmp', 'strings.h'),\n     'HAVE_STRLCPY': ('strlcpy', 'string.h'),\n     'HAVE_STRNCASECMP': ('strncasecmp', 'strings.h'),\n     'HAVE_STRSIGNAL': ('strsignal', 'signal.h'),\n     'HAVE_STRTOD_L': ('strtod_l', 'stdlib.h'),\n     'HAVE_STRTOLL_L': ('strtoll_l', 'stdlib.h'),\n     'HAVE_STRTOULL_L': ('strtoull_l', 'stdlib.h'),\n     'HAVE_SYMLINK': ('symlink', 'unistd.h'),\n     'HAVE_SYSCTLBYNAME': ('sysctlbyname', 'sys/sysctl.h'),\n     'HAVE_TIMEGM': ('timegm', 'time.h'),\n     'HAVE_USELOCALE': ('uselocale', 'xlocale.h'),\n     'HAVE_UTIMES': ('utimes', 'sys/time.h'),\n     'HAVE_VALLOC': ('valloc', 'stdlib.h'),\n     'HAVE_VASPRINTF': ('vasprintf', 'stdio.h'),\n     'HAVE_VSNPRINTF': ('vsnprintf', 'stdio.h'),\n     'HAVE_BCOPY': ('bcopy', 'strings.h'),\n     'HAVE_STRERROR': ('strerror', 'string.h'),\n     'HAVE_MEMMOVE': ('memmove', 'string.h'),\n     'HAVE_STRTOIMAX': ('strtoimax', 'inttypes.h'),\n     'HAVE_STRTOLL': ('strtoll', 'stdlib.h'),\n     'HAVE_STRTOQ': ('strtoq', 'stdlib.h'),\n     'HAVE_ACCEPT4': ('accept4', 'sys/socket.h'),\n     'HAVE_CHMOD': ('chmod', 'sys/stat.h'),\n     'HAVE_CHOWN': ('chown', 'unistd.h'),\n     'HAVE_FSTAT': ('fstat', 'sys/stat.h'),\n     'HAVE_GETADDRINFO': ('getaddrinfo', 'netdb.h'),\n     'HAVE_GETGRGID_R': ('getgrgid_r', 'grp.h'),\n     'HAVE_GETGRNAM_R': ('getgrnam_r', 'grp.h'),\n     'HAVE_GETGROUPS': ('getgroups', 'grp.h'),\n     'HAVE_GETOPT_LONG': ('getopt_long', 'getopt.h'),\n     'HAVE_GETPWNAM_R': ('getpwnam', 'pwd.h'),\n     'HAVE_GETPWUID_R': ('getpwuid_r', 'pwd.h'),\n     'HAVE_GETUID': ('getuid', 'unistd.h'),\n     'HAVE_LRINTF': ('lrintf', 'math.h'),\n     'HAVE_DECL_ISNAN': ('isnan', 'math.h'),\n     'HAVE_DECL_ISINF': ('isinf', 'math.h'),\n     'HAVE_ROUND': ('round', 'math.h'),\n     'HAVE_NEARBYINT': ('nearbyint', 'math.h'),\n     'HAVE_RINT': ('rint', 'math.h'),\n     'HAVE_MKFIFO': ('mkfifo', 'sys/stat.h'),\n     'HAVE_MLOCK': ('mlock', 'sys/mman.h'),\n     'HAVE_NANOSLEEP': ('nanosleep', 'time.h'),\n     'HAVE_PIPE': ('pipe', 'unistd.h'),\n     'HAVE_PPOLL': ('ppoll', 'poll.h'),\n     'HAVE_REGEXEC': ('regexec', 'regex.h'),\n     'HAVE_SETEGID': ('setegid', 'unistd.h'),\n     'HAVE_SETEUID': ('seteuid', 'unistd.h'),\n     'HAVE_SETPGID': ('setpgid', 'unistd.h'),\n     'HAVE_SETREGID': ('setregid', 'unistd.h'),\n     'HAVE_SETRESGID': ('setresgid', 'unistd.h'),\n     'HAVE_SETRESUID': ('setresuid', 'unistd.h'),\n     'HAVE_SHM_OPEN': ('shm_open', 'fcntl.h'),\n     'HAVE_SLEEP': ('sleep', 'unistd.h'),\n     'HAVE_STRERROR_R': ('strerror_r', 'string.h'),\n     'HAVE_STRTOF': ('strtof', 'stdlib.h'),\n     'HAVE_SYSCONF': ('sysconf', 'unistd.h'),\n     'HAVE_USLEEP': ('usleep', 'unistd.h'),\n     'HAVE_VFORK': ('vfork', 'unistd.h'),\n     'HAVE_MALLOC': ('malloc', 'stdlib.h'),\n     'HAVE_CALLOC': ('calloc', 'stdlib.h'),\n     'HAVE_REALLOC': ('realloc', 'stdlib.h'),\n     'HAVE_FREE': ('free', 'stdlib.h'),\n     'HAVE_ALLOCA': ('alloca', 'alloca.h'),\n     'HAVE_QSORT': ('qsort', 'stdlib.h'),\n     'HAVE_ABS': ('abs', 'stdlib.h'),\n     'HAVE_MEMSET': ('memset', 'string.h'),\n     'HAVE_MEMCMP': ('memcmp', 'string.h'),\n     'HAVE_STRLEN': ('strlen', 'string.h'),\n     'HAVE_STRLCAT': ('strlcat', 'string.h'),\n     'HAVE_STRDUP': ('strdup', 'string.h'),\n     'HAVE__STRREV': ('_strrev', 'string.h'),\n     'HAVE__STRUPR': ('_strupr', 'string.h'),\n     'HAVE__STRLWR': ('_strlwr', 'string.h'),\n     'HAVE_INDEX': ('index', 'strings.h'),\n     'HAVE_RINDEX': ('rindex', 'strings.h'),\n     'HAVE_STRCHR': ('strchr', 'string.h'),\n     'HAVE_STRRCHR': ('strrchr', 'string.h'),\n     'HAVE_STRSTR': ('strstr', 'string.h'),\n     'HAVE_STRTOL': ('strtol', 'stdlib.h'),\n     'HAVE_STRTOUL': ('strtoul', 'stdlib.h'),\n     'HAVE_STRTOULL': ('strtoull', 'stdlib.h'),\n     'HAVE_STRTOD': ('strtod', 'stdlib.h'),\n     'HAVE_ATOI': ('atoi', 'stdlib.h'),\n     'HAVE_ATOF': ('atof', 'stdlib.h'),\n     'HAVE_STRCMP': ('strcmp', 'string.h'),\n     'HAVE_STRNCMP': ('strncmp', 'string.h'),\n     'HAVE_VSSCANF': ('vsscanf', 'stdio.h'),\n     'HAVE_CHROOT': ('chroot', 'unistd.h'),\n     'HAVE_CLOCK': ('clock', 'time.h'),\n     'HAVE_CLOCK_GETRES': ('clock_getres', 'time.h'),\n     'HAVE_CLOCK_GETTIME': ('clock_gettime', 'time.h'),\n     'HAVE_CLOCK_SETTIME': ('clock_settime', 'time.h'),\n     'HAVE_CONFSTR': ('confstr', 'time.h'),\n     'HAVE_CTERMID': ('ctermid', 'stdio.h'),\n     'HAVE_DIRFD': ('dirfd', 'dirent.h'),\n     'HAVE_DLOPEN': ('dlopen', 'dlfcn.h'),\n     'HAVE_DUP2': ('dup2', 'unistd.h'),\n     'HAVE_DUP3': ('dup3', 'unistd.h'),\n     'HAVE_EPOLL_CREATE1': ('epoll_create1', 'sys/epoll.h'),\n     'HAVE_ERF': ('erf', 'math.h'),\n     'HAVE_ERFC': ('erfc', 'math.h'),\n     'HAVE_EXECV': ('execv', 'unistd.h'),\n     'HAVE_FACCESSAT': ('faccessat', 'unistd.h'),\n     'HAVE_FCHDIR': ('fchdir', 'unistd.h'),\n     'HAVE_FCHMODAT': ('fchmodat', 'sys/stat.h'),\n     'HAVE_FDATASYNC': ('fdatasync', 'unistd.h'),\n     'HAVE_FDOPENDIR': ('fdopendir', 'dirent.h'),\n     'HAVE_FEXECVE': ('fexecve', 'unistd.h'),\n     'HAVE_FLOCK': ('flock', 'sys/file.h'),\n     'HAVE_FORKPTY': ('forkpty', 'pty.h'),\n     'HAVE_FPATHCONF': ('fpathconf', 'unistd.h'),\n     'HAVE_FSTATAT': ('fstatat', 'unistd.h'),\n     'HAVE_FSTATVFS': ('fstatvfs', 'sys/statvfs.h'),\n     'HAVE_FTELLO': ('ftello', 'stdio.h'),\n     'HAVE_FTIME': ('ftime', 'sys/timeb.h'),\n     'HAVE_FTRUNCATE': ('ftruncate', 'unistd.h'),\n     'HAVE_FUTIMENS': ('futimens', 'sys/stat.h'),\n     'HAVE_FUTIMES': ('futimes', 'sys/time.h'),\n     'HAVE_GAI_STRERROR': ('gai_strerror', 'netdb.h'),\n     'HAVE_GETGROUPLIST': ('getgrouplist', 'grp.h'),\n     'HAVE_GETHOSTBYNAME': ('gethostbyname', 'netdb.h'),\n     'HAVE_GETHOSTBYNAME_R': ('gethostbyname_r', 'netdb.h'),\n     'HAVE_GETITIMER': ('getitimer', 'sys/time.h'),\n     'HAVE_GETLOADAVG': ('getloadavg', 'stdlib.h'),\n     'HAVE_GETLOGIN': ('getlogin', 'unistd.h'),\n     'HAVE_GETNAMEINFO': ('getnameinfo', 'netdb.h'),\n     'HAVE_GETPEERNAME': ('getpeername', 'sys/socket.h'),\n     'HAVE_GETPGID': ('getpgid', 'unistd.h'),\n     'HAVE_GETPGRP': ('getpgrp', 'unistd.h'),\n     'HAVE_GETPID': ('getpid', 'unistd.h'),\n     'HAVE_GETPRIORITY': ('getpriority', 'sys/resource.h'),\n     'HAVE_GETPWENT': ('getpwent', 'pwd.h'),\n     'HAVE_GETRANDOM': ('getrandom', 'linux/random.h'),\n     'HAVE_GETRESGID': ('getresgid', 'unistd.h'),\n     'HAVE_GETSID': ('getsid', 'unistd.h'),\n     'HAVE_GETSPENT': ('getspent', 'shadow.h'),\n     'HAVE_GETSPNAM': ('getspnam', 'shadow.h'),\n     'HAVE_GETWD': ('getwd', 'unistd.h'),\n     'HAVE_HSTRERROR': ('hstrerror', 'netdb.h'),\n     'HAVE_HTOLE64': ('htole64', 'endian.h'),\n     'HAVE_IF_NAMEINDEX': ('if_nameindex', 'net/if.h'),\n     'HAVE_INET_ATON': ('inet_aton', 'arpa/inet.h'),\n     'HAVE_INET_PTON': ('inet_pton', 'arpa/inet.h'),\n     'HAVE_INITGROUPS': ('initgroups', 'grp.h'),\n     'HAVE_KILL': ('kill', 'signal.h'),\n     'HAVE_KILLPG': ('killpg', 'signal.h'),\n     'HAVE_LINKAT': ('linkat', 'unistd.h'),\n     'HAVE_LOCKF': ('lockf', 'unistd.h'),\n     'HAVE_LUTIMES': ('lutimes', 'sys/time.h'),\n     'HAVE_MAKEDEV': ('makedev', 'sys/sysmacros.h'),\n     'HAVE_MBRTOWC': ('mbrtowc', 'wchar.h'),\n     'HAVE_MEMRCHR': ('memrchr', 'string.h'),\n     'HAVE_MKDIRAT': ('mkdirat', 'sys/stat.h'),\n     'HAVE_MKFIFOAT': ('mkfifoat', 'sys/stat.h'),\n     'HAVE_MKNOD': ('mknod', 'unistd.h'),\n     'HAVE_MKNODAT': ('mknodat', 'unistd.h'),\n     'HAVE_MKTIME': ('mktime', 'unistd.h'),\n     'HAVE_MKREMAP': ('mkremap', 'sys/mman.h'),\n     'HAVE_NICE': ('nice', 'unistd.h'),\n     'HAVE_OPENAT': ('openat', 'fcntl.h'),\n     'HAVE_OPENPTY': ('openpty', 'pty.h'),\n     'HAVE_PATHCONF': ('pathconf', 'unistd.h'),\n     'HAVE_PAUSE': ('pause', 'unistd.h'),\n     'HAVE_PREAD': ('pread', 'unistd.h'),\n     'HAVE_PTHREAD_KILL': ('pthread_kill', 'signal.h'),\n     'HAVE_PTHREAD_SIGMASK': ('pthread_sigmask', 'signal.h'),\n     'HAVE_PWRITE': ('pwrite', 'unistd.h'),\n     'HAVE_READLINKAT': ('readlinkat', 'unistd.h'),\n     'HAVE_READV': ('readv', 'sys/uio.h'),\n     'HAVE_RENAMEAT': ('renamat', 'stdio.h'),\n     'HAVE_SCHED_GET_PRIORITY_MAX': ('sched_get_priority_max', 'sched.h'),\n     'HAVE_SCHED_RR_GET_INTERVAL': ('sched_rr_get_interval', 'sched.h'),\n     'HAVE_SCHED_SETAFFINITY': ('sched_setaffinity', 'sched.h'),\n     'HAVE_SCHED_SETPARAM': ('sched_setparam', 'sched.h'),\n     'HAVE_SCHED_SETSCHEDULER': ('sched_setscheduler', 'sched.h'),\n     'HAVE_SELECT': ('select', 'sys/select.h'),\n     'HAVE_SEM_GETVALUE': ('sem_getvalue', 'semaphore.h'),\n     'HAVE_SEM_OPEN': ('sem_open', 'semaphore.h'),\n     'HAVE_SEM_TIMEDWAIT': ('sem_timedwait', 'semaphore.h'),\n     'HAVE_SEM_UNLINK': ('sem_unlink', 'semaphore.h'),\n     'HAVE_SENDFILE': ('sendfile', 'sys/sendfile.h'),\n     'HAVE_SETGID': ('setgid', 'unistd.h'),\n     'HAVE_SETGROUPS': ('setgroups', 'grp.h'),\n     'HAVE_SETHOSTNAME': ('sethostname', 'unistd.h'),\n     'HAVE_SETITIMER': ('setitimer', 'sys/time.h'),\n     'HAVE_SETLOCALE': ('setlocale', 'locale.h'),\n     'HAVE_SETPGRP': ('setpgrp', 'unistd.h'),\n     'HAVE_SETPRIORITY': ('setpriority', 'sys/resource.h'),\n     'HAVE_SETREUID': ('setreuid', 'unistd.h'),\n     'HAVE_SETSID': ('setsid', 'unistd.h'),\n     'HAVE_SETUID': ('setuid', 'unistd.h'),\n     'HAVE_SETVBUF': ('setvbuf', 'unistd.h'),\n     'HAVE_SIGALTSTACK': ('sigaltstack', 'signal.h'),\n     'HAVE_SIGINTERRUPT': ('siginterrupt', 'signal.h'),\n     'HAVE_SIGPENDING': ('sigpending', 'signal.h'),\n     'HAVE_SIGRELSE': ('sigrelse', 'signal.h'),\n     'HAVE_SIGTIMEDWAIT': ('sigtimedwait', 'signal.h'),\n     'HAVE_SIGWAIT': ('sigwait', 'signal.h'),\n     'HAVE_SIGWAITINFO': ('sigwaitinfo', 'signal.h'),\n     'HAVE_SOCKETPAIR': ('socketpair', 'sys/socket.h'),\n     'HAVE_STRFTIME': ('strftime', 'time.h'),\n     'HAVE_SYMLINKAT': ('symlinkat', 'unistd.h'),\n     'HAVE_SYNC': ('sync', 'unistd.h'),\n     'HAVE_TCGETPGRP': ('tcgetpgrp', 'unistd.h'),\n     'HAVE_TCSETPGRP': ('tcsetpgrp', 'unistd.h'),\n     'HAVE_TEMPNAM': ('tempnam', 'stdio.h'),\n     'HAVE_TIMES': ('times', 'sys/times.h'),\n     'HAVE_TEMPFILE': ('tempfile', 'stdio.h'),\n     'HAVE_TMPNAM': ('tmpnam', 'stdio.h'),\n     'HAVE_TMPNAM_R': ('tmpnam_r', 'stdio.h'),\n     'HAVE_TRUNCATE': ('truncate', 'unistd.h'),\n     'HAVE_TZNAME': ('tzname', 'time.h'),\n     'HAVE_UNAME': ('uname', 'sys/utsname.h'),\n     'HAVE_UNLINKAT': ('unlinkat', 'unistd.h'),\n     'HAVE_UTIMENSAT': ('utimensat', 'sys/stat.h'),\n     'HAVE_WAIT3': ('wait3', 'sys/wait.h'),\n     'HAVE_WAIT4': ('wait4', 'sys/wait.h'),\n     'HAVE_WAITID': ('waitid', 'sys/wait.h'),\n     'HAVE_WRITEV': ('writev', 'sys/uio.h'),\n     'HAVE_WMEMCMP': ('wmemcmp', 'wchar.h'),\n     'HAVE_ATAN': ('atan', 'math.h'),\n     'HAVE_ATAN2': ('atan2', 'math.h'),\n     'HAVE_ACOS': ('acos', 'math.h'),\n     'HAVE_ACOSH': ('acosh', 'math.h'),\n     'HAVE_ASIN': ('asin', 'math.h'),\n     'HAVE_ASINH': ('asinh', 'math.h'),\n     'HAVE_ATANH': ('atanh', 'math.h'),\n     'HAVE_CEIL': ('ceil', 'math.h'),\n     'HAVE_COPYSIGN': ('copysign', 'math.h'),\n     'HAVE_COS': ('cos', 'math.h'),\n     'HAVE_COSH': ('cosh', 'math.h'),\n     'HAVE_COSF': ('cosf', 'math.h'),\n     'HAVE_EXPM1': ('expm1', 'math.h'),\n     'HAVE_FABS': ('fabs', 'math.h'),\n     'HAVE_FINITE': ('finite', 'math.h'),\n     'HAVE_FLOOR': ('floor', 'math.h'),\n     'HAVE_GAMMA': ('gamma', 'math.h'),\n     'HAVE_HYPOT': ('hypot', 'math.h'),\n     'HAVE_ISINF': ('isinf', 'math.h'),\n     'HAVE_LOG': ('log', 'math.h'),\n     'HAVE_LOG1P': ('log1p', 'math.h'),\n     'HAVE_LOG2': ('log2', 'math.h'),\n     'HAVE_LGAMMA': ('lgamma', 'math.h'),\n     'HAVE_POW': ('pow', 'math.h'),\n     'HAVE_SCALBN': ('scalbn', 'math.h'),\n     'HAVE_SIN': ('sin', 'math.h'),\n     'HAVE_SINF': ('sinf', 'math.h'),\n     'HAVE_SINH': ('sinh', 'math.h'),\n     'HAVE_SQRT': ('sqrt', 'math.h'),\n     'HAVE_TGAMMA': ('tgamma', 'math.h'),\n     'HAVE_FSEEKO': ('fseeko', 'stdio.h'),\n     'HAVE_FSEEKO64': ('fseeko64', 'stdio.h'),\n     'HAVE_SETJMP': ('setjmp', 'setjmp.h'),\n     'HAVE_PTHREAD_SETNAME_NP': ('pthread_setname_np', 'pthread.h'),\n     'HAVE_PTHREAD_SET_NAME_NP': ('pthread_set_name_np', 'pthread.h'),\n     }\n\nheaders = []\nfunctions = []\nsizes = []\n\nif len(sys.argv) != 2:\n    print(help_message.format(sys.argv[0]))\n    sys.exit(0)\n\nwith open(sys.argv[1]) as f:\n    for line in f:\n        line = line.strip()\n        arr = line.split()\n\n        # Check for headers.\n        if line.startswith('#mesondefine') and line.endswith('_H'):\n            token = line.split()[1]\n            tarr = token.split('_')[1:-1]\n            tarr = [x.lower() for x in tarr]\n            hname = '/'.join(tarr) + '.h'\n            headers.append((token, hname))\n\n        # Check for functions.\n        try:\n            token = arr[1]\n            if token in function_data:\n                fdata = function_data[token]\n                functions.append([token, fdata[0], fdata[1]])\n            elif token.startswith('HAVE_') and not token.endswith('_H'):\n                functions.append([token])\n        except Exception:\n            pass\n\n        # Check for sizeof tests.\n        if len(arr) != 2:\n            continue\n        elem = arr[1]\n        if elem.startswith('SIZEOF_'):\n            typename = elem.split('_', 1)[1] \\\n                .replace('_P', '*') \\\n                .replace('_', ' ') \\\n                .lower() \\\n                .replace('size t', 'size_t')\n            sizes.append((elem, typename))\n\nprint('''cc = meson.get_compiler('c')\ncdata = configuration_data()''')\n\n# Convert header checks.\n\nprint('check_headers = [')\nfor token, hname in headers:\n    print(\"  ['{}', '{}'],\".format(token, hname))\nprint(']\\n')\n\nprint('''foreach h : check_headers\n  if cc.has_header(h.get(1))\n    cdata.set(h.get(0), 1)\n  endif\nendforeach\n''')\n\n# Convert function checks.\n\nprint('check_functions = [')\nfor tok in functions:\n    if len(tok) == 3:\n        tokstr, fdata0, fdata1 = tok\n        print(\"  ['{}', '{}', '#include<{}>'],\".format(tokstr, fdata0, fdata1))\n    else:\n        print('# check token', tok)\nprint(']\\n')\n\nprint('''foreach f : check_functions\n  if cc.has_function(f.get(1), prefix : f.get(2))\n    cdata.set(f.get(0), 1)\n  endif\nendforeach\n''')\n\n# Convert sizeof checks.\n\nfor elem, typename in sizes:\n    print(\"cdata.set('{}', cc.sizeof('{}'))\".format(elem, typename))\n\nprint('''\nconfigure_file(input : 'config.h.meson',\n  output : 'config.h',\n  configuration : cdata)''')\n",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/docs/markdown/Reference-manual.md": "# Reference manual\n\n## Functions\n\nThe following functions are available in build files. Click on each to\nsee the description and usage. The objects returned by them are [list\nafterwards](#returned-objects).\n\n### add_global_arguments()\n\n``` meson\n  void add_global_arguments(arg1, arg2, ...)\n```\n\nAdds the positional arguments to the compiler command line. This\nfunction has two keyword arguments:\n\n- `language` specifies the language(s) that the arguments should be\napplied to. If a list of languages is given, the arguments are added\nto each of the corresponding compiler command lines. Note that there\nis no way to remove an argument set in this way. If you have an\nargument that is only used in a subset of targets, you have to specify\nit in per-target flags.\n\n- `native` is a boolean specifying whether the arguments should be\n  applied to the native or cross compilation. If `true` the arguments\n  will only be used for native compilations. If `false` the arguments\n  will only be used in cross compilations. If omitted, the flags are\n  added to native compilations if compiling natively and cross\n  compilations (only) when cross compiling. Available since 0.48.0\n\nThe arguments are used in all compiler invocations with the exception\nof compile tests, because you might need to run a compile test with\nand without the argument in question. For this reason only the\narguments explicitly specified are used during compile tests.\n\n**Note:** Usually you should use `add_project_arguments` instead,\n  because that works even when you project is used as a subproject.\n\n**Note:** You must pass always arguments individually `arg1, arg2,\n  ...` rather than as a string `'arg1 arg2', ...`\n\n### add_global_link_arguments()\n\n``` meson\n    void add_global_link_arguments(*arg1*, *arg2*, ...)\n```\n\nLike `add_global_arguments` but the arguments are passed to the linker.\n\n### add_languages()\n\n``` meson\n  bool add_languages(*langs*)\n```\n\nAdd programming languages used by the project. Equivalent to having them in the\n`project` declaration. This function is usually used to add languages that are\nonly used under some conditions, like this:\n\n```meson\nproject('foobar', 'c')\nif compiling_for_osx\n  add_languages('objc')\nendif\nif add_languages('cpp', required : false)\n  executable('cpp-app', 'main.cpp')\nendif\n```\n\nTakes the following keyword arguments:\n\n- `required` defaults to `true`, which means that if any of the languages\nspecified is not found, Meson will halt. Since *0.47.0* the value of a\n[`feature`](Build-options.md#features) option can also be passed.\n\n- `native` if set to `true`, the language will be used to compile for the build\n  machine, if `false`, for the host machine. Since *0.54.0*.\n\nReturns `true` if all languages specified were found and `false` otherwise.\n\nIf `native` is omitted, the languages may be used for either build or host\nmachine, but are never required for the build machine.  (i.e. it is equivalent\nto `add_languages(*langs*, native: false, required: *required*) and\nadd_languages(*langs*, native: true, required: false)`. This default behaviour\nmay change to `native: false` in a future meson version.\n\n### add_project_arguments()\n\n``` meson\n  void add_project_arguments(arg1, arg2, ...)\n```\n\nThis function behaves in the same way as `add_global_arguments` except\nthat the arguments are only used for the current project, they won't\nbe used in any other subproject.\n\n### add_project_link_arguments()\n\n``` meson\n  void add_project_link_arguments(*arg1*, *arg2*, ...)\n```\n\nLike `add_project_arguments` but the arguments are passed to the linker.\n\n### add_test_setup()\n\n``` meson\n  void add_test_setup(*name*, ...)\n```\n\nAdd a custom test setup that can be used to run the tests with a\ncustom setup, for example under Valgrind. The keyword arguments are\nthe following:\n\n- `env` environment variables to set, such as `['NAME1=value1',\n  'NAME2=value2']`, or an [`environment()`\n  object](#environment-object) which allows more sophisticated\n  environment juggling. *Since 0.52.0* a dictionary is also accepted.\n- `exe_wrapper` a list containing the wrapper command or script followed by the arguments to it\n- `gdb` if `true`, the tests are also run under `gdb`\n- `timeout_multiplier` a number to multiply the test timeout with\n- `is_default` a bool to set whether this is the default test setup.\n  If `true`, the setup will be used whenever `meson test` is run\n  without the `--setup` option. Since 0.49.0\n\nTo use the test setup, run `meson test --setup=*name*` inside the\nbuild dir.\n\nNote that all these options are also available while running the\n`meson test` script for running tests instead of `ninja test` or\n`msbuild RUN_TESTS.vcxproj`, etc depending on the backend.\n\n### alias_target\n\n``` meson\nruntarget alias_target(target_name, dep1, ...)\n```\n\nSince *0.52.0*\n\nThis function creates a new top-level target. Like all top-level targets, this\nintegrates with the selected backend. For instance, with Ninja you can\nrun it as `ninja target_name`. This is a dummy target that does not execute any\ncommand, but ensures that all dependencies are built. Dependencies can be any\nbuild target (e.g. return value of [executable()](#executable), custom_target(), etc)\n\n### assert()\n\n``` meson\n    void assert(*condition*, *message*)\n```\n\nAbort with an error message if `condition` evaluates to `false`.\n\n*Since 0.53.0* `message` argument is optional and defaults to print the condition\nstatement instead.\n\n### benchmark()\n\n``` meson\n    void benchmark(name, executable, ...)\n```\n\nCreates a benchmark item that will be run when the benchmark target is\nrun. The behavior of this function is identical to [`test()`](#test) except for:\n\n* benchmark() has no `is_parallel` keyword because benchmarks are not run in parallel\n* benchmark() does not automatically add the `MALLOC_PERTURB_` environment variable\n\n*Note:* Prior to 0.52.0 benchmark would warn that `depends` and `priority`\nwere unsupported, this is incorrect\n\n### both_libraries()\n\n``` meson\n    buildtarget = both_libraries(library_name, list_of_sources, ...)\n```\n\nBuilds both a static and shared library with the given\nsources. Positional and keyword arguments are otherwise the same as\nfor [`library`](#library). Source files will be compiled only once and\nobject files will be reused to build both shared and static libraries,\nunless `b_staticpic` user option or `pic` argument are set to false in\nwhich case sources will be compiled twice.\n\nThe returned [buildtarget](#build-target-object) always represents the\nshared library. In addition it supports the following extra methods:\n\n- `get_shared_lib()` returns the shared library build target\n- `get_static_lib()` returns the static library build target\n\n*Added 0.46.0*\n\n### build_target()\n\nCreates a build target whose type can be set dynamically with the\n`target_type` keyword argument.\n\n`target_type` may be set to one of:\n\n- `executable`\n- `shared_library`\n- `shared_module`\n- `static_library`\n- `both_libraries`\n- `library`\n- `jar`\n\nThis declaration:\n\n```meson\nexecutable(<arguments and keyword arguments>)\n```\n\nis equivalent to this:\n\n```meson\nbuild_target(<arguments and keyword arguments>, target_type : 'executable')\n```\n\nThe object returned by `build_target` and all convenience wrappers for\n`build_target` such as [`executable`](#executable) and\n[`library`](#library) has methods that are documented in the [object\nmethods section](#build-target-object) below.\n\n### configuration_data()\n\n``` meson\n    configuration_data_object = configuration_data(...)\n```\n\nCreates an empty configuration object. You should add your\nconfiguration with [its method calls](#configuration-data-object) and\nfinally use it in a call to `configure_file`.\n\nSince *0.49.0* takes an optional dictionary as first argument. If\nprovided, each key/value pair is added into the `configuration_data`\nas if `set()` method was called for each of them.\n\n### configure_file()\n\n``` meson\n    generated_file = configure_file(...)\n```\n\nThis function can run in three modes depending on the keyword arguments\npassed to it.\n\nWhen a [`configuration_data()`](#configuration_data) object is passed\nto the `configuration:` keyword argument, it takes a template file as\nthe `input:` (optional) and produces the `output:` (required) by\nsubstituting values from the configuration data as detailed in [the\nconfiguration file documentation](Configuration.md). Since *0.49.0* a\ndictionary can be passed instead of a\n[`configuration_data()`](#configuration_data) object.\n\nWhen a list of strings is passed to the `command:` keyword argument,\nit takes any source or configured file as the `input:` and assumes\nthat the `output:` is produced when the specified command is run.\n\nSince *0.47.0*, when the `copy:` keyword argument is set to `true`,\nthis function will copy the file provided in `input:` to a file in the\nbuild directory with the name `output:` in the current directory.\n\nThese are all the supported keyword arguments:\n\n- `capture` when this argument is set to true, Meson captures `stdout`\n  of the `command` and writes it to the target file specified as\n  `output`. Available since v0.41.0.\n- `command` as explained above, if specified, Meson does not create\n  the file itself but rather runs the specified command, which allows\n  you to do fully custom file generation. Since *0.52.0* the command can contain\n  file objects and more than one file can be passed to the `input` keyword\n  argument, see [`custom_target()`](#custom_target) for details about string\n  substitutions.\n- `copy` *(added 0.47.0)* as explained above, if specified Meson only\n  copies the file from input to output.\n- `depfile` *(added 0.52.0)* is a dependency file that the command can write listing\n  all the additional files this target depends on. A change\n  in any one of these files triggers a reconfiguration.\n- `format` *(added 0.46.0)* the format of defines. It defaults to `meson`, and so substitutes\n`#mesondefine` statements and variables surrounded by `@` characters, you can also use `cmake`\nto replace `#cmakedefine` statements and variables with the `${variable}` syntax. Finally you can use\n`cmake@` in which case substitutions will apply on `#cmakedefine` statements and variables with\nthe `@variable@` syntax.\n- `input` the input file name. If it's not specified in configuration\n  mode, all the variables in the `configuration:` object (see above)\n  are written to the `output:` file.\n- `install` *(added 0.50.0)* When true, this generated file is installed during\nthe install step, and `install_dir` must be set and not empty. When false, this\ngenerated file is not installed regardless of the value of `install_dir`.\nWhen omitted it defaults to true when `install_dir` is set and not empty,\nfalse otherwise.\n- `install_dir` the subdirectory to install the generated file to\n  (e.g. `share/myproject`), if omitted or given the value of empty\n  string, the file is not installed.\n- `install_mode` *(added 0.47.0)* specify the file mode in symbolic format\n  and optionally the owner/uid and group/gid for the installed files.\n- `output` the output file name (since v0.41.0, may contain\n  `@PLAINNAME@` or `@BASENAME@` substitutions). In configuration mode,\n  the permissions of the input file (if it is specified) are copied to\n  the output file.\n- `output_format` *(added 0.47.0)* the format of the output to generate when no input\n  was specified. It defaults to `c`, in which case preprocessor directives\n  will be prefixed with `#`, you can also use `nasm`, in which case the\n  prefix will be `%`.\n- `encoding` *(added v0.47.0)* set the file encoding for the input and output file,\n  defaults to utf-8. The supported encodings are those of python3, see\n  [standard-encodings](https://docs.python.org/3/library/codecs.html#standard-encodings).\n\n### custom_target()\n\n``` meson\n    customtarget custom_target(*name*, ...)\n```\n\nCreate a custom top level build target. The only positional argument\nis the name of this target and the keyword arguments are the\nfollowing.\n\n- `build_by_default` *(added 0.38)* causes, when set to true, to\n  have this target be built by default. This means it will be built when\n  `ninja` is called without any arguments or asked to build a target\n  like `ninja test` that depends on ninja's [default\n  target](https://ninja-build.org/manual.html#_default_target_statements)\n  set to `all` by meson. The same behavior applies for backends other\n  than `ninja`.  The default value is `false`.\n  *(changed in 0.50)* if `build_by_default` is explicitly set to false, `install`\n  will no longer override it. If `build_by_default` is not set, `install` will\n  still determine its default.\n- `build_always` (deprecated) if `true` this target is always considered out of\n  date and is rebuilt every time.  Equivalent to setting both\n  `build_always_stale` and `build_by_default` to true.\n- `build_always_stale` *(added 0.47)* if `true` the target is always considered out of date.\n  Useful for things such as build timestamps or revision control tags.\n  The associated command is run even if the outputs are up to date.\n- `capture`, there are some compilers that can't be told to write\n  their output to a file but instead write it to standard output. When\n  this argument is set to true, Meson captures `stdout` and writes it\n  to the target file. Note that your command argument list may not\n  contain `@OUTPUT@` when capture mode is active.\n- `console` *(added 0.48)* keyword argument conflicts with `capture`, and is meant\n  for commands that are resource-intensive and take a long time to\n  finish. With the Ninja backend, setting this will add this target\n  to [Ninja's `console` pool](https://ninja-build.org/manual.html#_the_literal_console_literal_pool),\n  which has special properties such as not buffering stdout and\n  serializing all targets in this pool.\n- `command` command to run to create outputs from inputs. The command\n  may be strings or the return value of functions that return file-like\n  objects such as [`find_program()`](#find_program),\n  [`executable()`](#executable), [`configure_file()`](#configure_file),\n  [`files()`](#files), [`custom_target()`](#custom_target), etc.\n  Meson will automatically insert the appropriate dependencies on\n  targets and files listed in this keyword argument.\n  Note: always specify commands in array form `['commandname',\n  '-arg1', '-arg2']` rather than as a string `'commandname -arg1\n  -arg2'` as the latter will *not* work.\n- `depend_files` files ([`string`](#string-object),\n  [`files()`](#files), or [`configure_file()`](#configure_file)) that\n  this target depends on but are not listed in the `command` keyword\n  argument. Useful for adding regen dependencies.\n- `depends` specifies that this target depends on the specified\n  target(s), even though it does not take any of them as a command\n  line argument. This is meant for cases where you have a tool that\n  e.g. does globbing internally. Usually you should just put the\n  generated sources as inputs and Meson will set up all dependencies\n  automatically.\n- `depfile` is a dependency file that the command can write listing\n  all the additional files this target depends on, for example a C\n  compiler would list all the header files it included, and a change\n  in any one of these files triggers a recompilation\n- `input` list of source files. As of 0.41.0 the list will be flattened.\n- `install` when true, this target is installed during the install step\n- `install_dir` directory to install to\n- `install_mode` *(added 0.47.0)* the file mode and optionally the\n  owner/uid and group/gid\n- `output` list of output files\n\nThe list of strings passed to the `command` keyword argument accept\nthe following special string substitutions:\n\n- `@INPUT@` the full path to the input passed to `input`. If more than\n  one input is specified, all of them will be substituted as separate\n  arguments only if the command uses `'@INPUT@'` as a\n  standalone-argument. For instance, this would not work: `command :\n  ['cp', './@INPUT@']`, but this would: `command : ['cp', '@INPUT@']`.\n- `@OUTPUT@` the full path to the output passed to `output`. If more\n  than one outputs are specified, the behavior is the same as\n  `@INPUT@`.\n- `@INPUT0@` `@INPUT1@` `...` the full path to the input with the specified array index in `input`\n- `@OUTPUT0@` `@OUTPUT1@` `...` the full path to the output with the specified array index in `output`\n- `@OUTDIR@` the full path to the directory where the output(s) must be written\n- `@DEPFILE@` the full path to the dependency file passed to `depfile`\n- `@PLAINNAME@`: the input filename, without a path\n- `@BASENAME@`: the input filename, with extension removed\n- `@PRIVATE_DIR@`: path to a directory where the custom target must store all its intermediate files, available since 0.50.1\n\nThe `depfile` keyword argument also accepts the `@BASENAME@` and `@PLAINNAME@`\nsubstitutions. *(since 0.47)*\n\nThe returned object also has methods that are documented in the\n[object methods section](#custom-target-object) below.\n\n### declare_dependency()\n\n``` meson\n    dependency_object declare_dependency(...)\n```\n\nThis function returns a [dependency object](#dependency-object) that\nbehaves like the return value of [`dependency`](#dependency) but is\ninternal to the current build. The main use case for this is in\nsubprojects. This allows a subproject to easily specify how it should\nbe used. This makes it interchangeable with the same dependency that\nis provided externally by the system. This function has the following\nkeyword arguments.\n\n  - `compile_args`, compile arguments to use\n  - `dependencies`, other dependencies needed to use this dependency\n  - `include_directories`, the directories to add to header search path,\n    must be include_directories objects or, since 0.50.0, plain strings\n  - `link_args`, link arguments to use\n  - `link_with`, libraries to link against\n  - `link_whole`, libraries to link fully, same as [`executable`](#executable)\n    Since 0.46.0\n  - `sources`, sources to add to targets (or generated header files\n    that should be built before sources including them are built)\n  - `version`, the version of this dependency, such as `1.2.3`\n  - `variables`, a dictionary of arbitrary strings, this is meant to be used\n    in subprojects where special variables would be provided via cmake or\n    pkg-config. Since 0.54.0\n\n### dependency()\n\n``` meson\n    dependency_object dependency(*dependency_name*, ...)\n```\n\nFinds an external dependency (usually a library installed on your\nsystem) with the given name with `pkg-config` and [with\nCMake](Dependencies.md#cmake) if `pkg-config` fails. Additionally,\nframeworks (OSX only) and [library-specific fallback detection\nlogic](Dependencies.md#dependencies-with-custom-lookup-functionality)\nare also supported. This function supports the following keyword\narguments:\n\n- `default_options` *(added 0.37.0)* an array of default option values\n  that override those set in the subproject's `meson_options.txt`\n  (like `default_options` in [`project()`](#project), they only have\n  effect when Meson is run for the first time, and command line\n  arguments override any default options in build files)\n- `fallback` specifies a subproject fallback to use in case the\n  dependency is not found in the system. The value is an array\n  `['subproj_name', 'subproj_dep']` where the first value is the name\n  of the subproject and the second is the variable name in that\n  subproject that contains a dependency object such as the return\n  value of [`declare_dependency`](#declare_dependency) or\n  [`dependency()`](#dependency), etc. Note that this means the\n  fallback dependency may be a not-found dependency, in which\n  case the value of the `required:` kwarg will be obeyed.\n  *Since 0.54.0* `'subproj_dep'` argument can be omitted in the case the\n  subproject used `meson.override_dependency('dependency_name', subproj_dep)`.\n  In that case, the `fallback` keyword argument can be a single string instead\n  of a list of 2 strings.\n- `language` *(added 0.42.0)* defines what language-specific\n  dependency to find if it's available for multiple languages.\n- `method` defines the way the dependency is detected, the default is\n  `auto` but can be overridden to be e.g. `qmake` for Qt development,\n  and [different dependencies support different values](\n  Dependencies.md#dependencies-with-custom-lookup-functionality)\n  for this (though `auto` will work on all of them)\n- `native` if set to `true`, causes Meson to find the dependency on\n  the build machine system rather than the host system (i.e. where the\n  cross compiled binary will run on), usually only needed if you build\n  a tool to be used during compilation.\n- `not_found_message` *(added 0.50.0)* is an optional string that will\n  be printed as a `message()` if the dependency was not found.\n- `required`, when set to false, Meson will proceed with the build\n  even if the dependency is not found. Since *0.47.0* the value of a\n  [`feature`](Build-options.md#features) option can also be passed.\n- `static` tells the dependency provider to try to get static\n  libraries instead of dynamic ones (note that this is not supported\n  by all dependency backends)\n- `version` specifies the required version, a string containing a\n  comparison operator followed by the version string, examples include\n  `>1.0.0`, `<=2.3.5` or `3.1.4` for exact matching. *(Added 0.37.0)*\n  You can also specify multiple restrictions by passing a list to this\n  keyword argument, such as: `['>=3.14.0', '<=4.1.0']`.\n  These requirements are never met if the version is unknown.\n- `include_type` *(added 0.52.0)* is an enum flag, marking how the dependency\n  flags should be converted. Supported values are `'preserve'`, `'system'` and\n  `'non-system'`. System dependencies may be handled differently on some\n   platforms, for instance, using `-isystem` instead of `-I`, where possible.\n   If `include_type` is set to `'preserve'`, no additional conversion will be\n   performed. The default value is `'preserve'`.\n- other\n[library-specific](Dependencies.md#dependencies-with-custom-lookup-functionality)\nkeywords may also be accepted (e.g. `modules` specifies submodules to use for\ndependencies such as Qt5 or Boost. `components` allows the user to manually\nadd CMake `COMPONENTS` for the `find_package` lookup)\n- `disabler` if `true` and the dependency couldn't be found, return a\n  [disabler object](#disabler-object) instead of a not-found dependency.\n  *Since 0.49.0*\n\nIf dependency_name is `''`, the dependency is always not found.  So\nwith `required: false`, this always returns a dependency object for\nwhich the `found()` method returns `false`, and which can be passed\nlike any other dependency to the `dependencies:` keyword argument of a\n`build_target`.  This can be used to implement a dependency which is\nsometimes not required e.g. in some branches of a conditional, or with\na `fallback:` kwarg, can be used to declare an optional dependency\nthat only looks in the specified subproject, and only if that's\nallowed by `--wrap-mode`.\n\nThe returned object also has methods that are documented in the\n[object methods section](#dependency-object) below.\n\n### disabler()\n\nReturns a [disabler object](#disabler-object). Added in 0.44.0.\n\n### error()\n\n``` meson\n    void error(message)\n```\n\nPrint the argument string and halts the build process.\n\n### environment()\n\n``` meson\n    environment_object environment(...)\n```\n\nReturns an empty [environment variable\nobject](#environment-object). Added in 0.35.0.\n\nSince *0.52.0* takes an optional dictionary as first argument. If\nprovided, each key/value pair is added into the `environment_object`\nas if `set()` method was called for each of them.\n\n### executable()\n\n``` meson\n    buildtarget executable(*exe_name*, *sources*, ...)\n```\n\nCreates a new executable. The first argument specifies its name and\nthe remaining positional arguments define the input files to use. They\ncan be of the following types:\n\n- Strings relative to the current source directory\n- [`files()`](#files) objects defined in any preceding build file\n- The return value of configure-time generators such as [`configure_file()`](#configure_file)\n- The return value of build-time generators such as\n  [`custom_target()`](#custom_target) or\n  [`generator.process()`](#generator-object)\n\nThese input files can be sources, objects, libraries, or any other\nfile. Meson will automatically categorize them based on the extension\nand use them accordingly. For instance, sources (`.c`, `.cpp`,\n`.vala`, `.rs`, etc) will be compiled and objects (`.o`, `.obj`) and\nlibraries (`.so`, `.dll`, etc) will be linked.\n\nWith the Ninja backend, Meson will create a build-time [order-only\ndependency](https://ninja-build.org/manual.html#ref_dependencies) on\nall generated input files, including unknown files. This is needed\nto bootstrap the generation of the real dependencies in the\n[depfile](https://ninja-build.org/manual.html#ref_headers)\ngenerated by your compiler to determine when to rebuild sources.\nNinja relies on this dependency file for all input files, generated\nand non-generated. The behavior is similar for other backends.\n\nExecutable supports the following keyword arguments. Note that just\nlike the positional arguments above, these keyword arguments can also\nbe passed to [shared and static libraries](#library).\n\n- `<languagename>_pch` precompiled header file to use for the given language\n- `<languagename>_args` compiler flags to use for the given language;\n  eg: `cpp_args` for C++\n- `build_by_default` causes, when set to true, to have this target be\n  built by default, that is, when invoking plain `ninja`, the default\n  value is true for all built target types, since 0.38.0\n- `build_rpath` a string to add to target's rpath definition in the\n  build dir, but which will be removed on install\n- `dependencies` one or more objects created with\n  [`dependency`](#dependency) or [`find_library`](#compiler-object)\n  (for external deps) or [`declare_dependency`](#declare_dependency)\n  (for deps built by the project)\n- `extra_files` are not used for the build itself but are shown as\n  source files in IDEs that group files by targets (such as Visual\n  Studio)\n- `gui_app` when set to true flags this target as a GUI application on\n  platforms where this makes a difference (e.g. Windows)\n- `link_args` flags to use during linking. You can use UNIX-style\n  flags here for all platforms.\n- `link_depends` strings, files, or custom targets the link step\n  depends on such as a symbol visibility map. The purpose is to\n  automatically trigger a re-link (but not a re-compile) of the target\n  when this file changes.\n- `link_language` since 0.51.0 makes the linker for this target\n  be for the specified language. This is helpful for multi-language targets.\n- `link_whole` links all contents of the given static libraries\n  whether they are used by not, equivalent to the\n  `-Wl,--whole-archive` argument flag of GCC, available since 0.40.0.\n  As of 0.41.0 if passed a list that list will be flattened. Starting\n  from version 0.51.0 this argument also accepts outputs produced by\n  custom targets. The user must ensure that the output is a library in\n  the correct format.\n- `link_with`, one or more shared or static libraries (built by this\n  project) that this target should be linked with, If passed a list\n  this list will be flattened as of 0.41.0. Starting with version\n  0.51.0, the arguments can also be custom targets. In this case Meson\n  will assume that merely adding the output file in the linker command\n  line is sufficient to make linking work. If this is not sufficient,\n  then the build system writer must write all other steps manually.\n- `export_dynamic` when set to true causes the target's symbols to be\n  dynamically exported, allowing modules built using the\n  [`shared_module`](#shared_module) function to refer to functions,\n  variables and other symbols defined in the executable itself. Implies\n  the `implib` argument.  Since 0.45.0\n- `implib` when set to true, an import library is generated for the\n  executable (the name of the import library is based on *exe_name*).\n  Alternatively, when set to a string, that gives the base name for\n  the import library.  The import library is used when the returned\n  build target object appears in `link_with:` elsewhere.  Only has any\n  effect on platforms where that is meaningful (e.g. Windows). Implies\n  the `export_dynamic` argument.  Since 0.42.0\n- `implicit_include_directories` is a boolean telling whether Meson\n  adds the current source and build directories to the include path,\n  defaults to `true`, since 0.42.0\n- `include_directories` one or more objects created with the\n  `include_directories` function, or, since 0.50.0, strings, which\n  will be transparently expanded to include directory objects\n- `install`, when set to true, this executable should be installed, defaults to `false`\n- `install_dir` override install directory for this file. The value is\n  relative to the `prefix` specified. F.ex, if you want to install\n  plugins into a subdir, you'd use something like this: `install_dir :\n  get_option('libdir') / 'projectname-1.0'`.\n- `install_mode` *(added 0.47.0)* specify the file mode in symbolic format\n  and optionally the owner/uid and group/gid for the installed files.\n- `install_rpath` a string to set the target's rpath to after install\n  (but *not* before that). On Windows, this argument has no effect.\n- `objects` list of prebuilt object files (usually for third party\n  products you don't have source to) that should be linked in this\n  target, **never** use this for object files that you build yourself.\n- `name_suffix` the string that will be used as the extension for the\n  target by overriding the default. By default on Windows this is\n  `exe` and on other platforms it is omitted. Set this to `[]`, or omit\n  the keyword argument for the default behaviour.\n- `override_options` takes an array of strings in the same format as\n  `project`'s `default_options` overriding the values of these options\n  for this target only, since 0.40.0.\n- `gnu_symbol_visibility` specifies how symbols should be exported, see\n  e.g [the GCC Wiki](https://gcc.gnu.org/wiki/Visibility) for more\n  information. This value can either be an empty string or one of\n  `default`, `internal`, `hidden`, `protected` or `inlineshidden`, which\n  is the same as `hidden` but also includes things like C++ implicit\n  constructors as specified in the GCC manual. Ignored on compilers that\n  do not support GNU visibility arguments. Available since 0.48.0.\n- `d_import_dirs` list of directories to look in for string imports used\n  in the D programming language\n- `d_unittest`, when set to true, the D modules are compiled in debug mode\n- `d_module_versions` list of module version identifiers set when compiling D sources\n- `d_debug` list of module debug identifiers set when compiling D sources\n- `pie` *(added 0.49.0)* build a position-independent executable\n- `native`, is a boolean controlling whether the target is compiled for the\n  build or host machines. Defaults to false, building for the host machine.\n\nThe list of `sources`, `objects`, and `dependencies` is always\nflattened, which means you can freely nest and add lists while\ncreating the final list.\n\nThe returned object also has methods that are documented in the\n[object methods section](#build-target-object) below.\n\n### find_library()\n\nThis function is deprecated and in the 0.31.0 release it was moved to\n[the compiler object](#compiler-object) as obtained from\n`meson.get_compiler(lang)`.\n\n### find_program()\n\n``` meson\n    program find_program(program_name1, program_name2, ...)\n```\n\n`program_name1` here is a string that can be an executable or script\nto be searched for in `PATH`, or a script in the current source\ndirectory.\n\n`program_name2` and later positional arguments are used as fallback\nstrings to search for. This is meant to be used for cases where the\nprogram may have many alternative names, such as `foo` and\n`foo.py`. The function will check for the arguments one by one and the\nfirst one that is found is returned. Meson versions earlier than\n0.37.0 only accept one argument.\n\nKeyword arguments are the following:\n\n- `required` By default, `required` is set to `true` and Meson will\n  abort if no program can be found. If `required` is set to `false`,\n  Meson continue even if none of the programs can be found. You can\n  then use the `.found()` method on the [returned object](#external-program-object) to check\n  whether it was found or not. Since *0.47.0*  the value of a\n  [`feature`](Build-options.md#features) option can also be passed to the\n  `required` keyword argument.\n\n- `native` *(since 0.43)* defines how this executable should be searched. By default\n  it is set to `false`, which causes Meson to first look for the\n  executable in the cross file (when cross building) and if it is not\n  defined there, then from the system. If set to `true`, the cross\n  file is ignored and the program is only searched from the system.\n\n- `disabler` if `true` and the program couldn't be found, return a\n  [disabler object](#disabler-object) instead of a not-found object.\n  *Since 0.49.0*\n\n- `version` *(since 0.52.0)* Specifies the required version, see\n  [`dependency()`](#dependency) for argument format. The version of the program\n  is determined by running `program_name --version` command. If stdout is empty\n  it fallbacks to stderr. If the output contains more text than simply a version\n  number, only the first occurrence of numbers separated by dots is kept.\n  If the output is more complicated than that, the version checking will have to\n  be done manually using [`run_command()`](#run_command).\n\n- `dirs` *(since 0.53.0)* Extra list of absolute paths where to look for program\n  names.\n\nMeson will also autodetect scripts with a shebang line and run them\nwith the executable/interpreter specified in it both on Windows\n(because the command invocator will reject the command otherwise) and\nUnixes (if the script file does not have the executable bit\nset). Hence, you *must not* manually add the interpreter while using\nthis script as part of a list of commands.\n\nIf you need to check for a program in a non-standard location, you can\njust pass an absolute path to `find_program`, e.g.\n\n```meson\nsetcap = find_program('setcap', '/usr/sbin/setcap', '/sbin/setcap', required : false)\n```\n\nIt is also possible to pass an array to `find_program` in case you\nneed to construct the set of paths to search on the fly:\n\n```meson\nsetcap = find_program(['setcap', '/usr/sbin/setcap', '/sbin/setcap'], required : false)\n```\n\nThe returned object also has methods that are documented in the\n[object methods section](#external-program-object) below.\n\n### files()\n\n``` meson\n    file_array files(list_of_filenames)\n```\n\nThis command takes the strings given to it in arguments and returns\ncorresponding File objects that you can use as sources for build\ntargets. The difference is that file objects remember the subdirectory\nthey were defined in and can be used anywhere in the source tree. As\nan example suppose you have source file `foo.cpp` in subdirectory\n`bar1` and you would like to use it in a build target that is defined\nin `bar2`. To make this happen you first create the object in `bar1`\nlike this:\n\n```meson\n    foofile = files('foo.cpp')\n```\n\nThen you can use it in `bar2` like this:\n\n```meson\n    executable('myprog', 'myprog.cpp', foofile, ...)\n```\n\nMeson will then do the right thing.\n\n### generator()\n\n``` meson\n    generator_object generator(*executable*, ...)\n```\n\nSee also: [`custom_target`](#custom_target)\n\nThis function creates a [generator object](#generator-object) that can\nbe used to run custom compilation commands. The only positional\nargument is the executable to use. It can either be a self-built\nexecutable or one returned by find_program. Keyword arguments are the\nfollowing:\n\n- `arguments` a list of template strings that will be the command line\n  arguments passed to the executable\n- `depends` is an array of build targets that must be built before this\n  generator can be run. This is used if you have a generator that calls\n  a second executable that is built in this project. Available since 0.51.0\n- `depfile` is a template string pointing to a dependency file that a\n  generator can write listing all the additional files this target\n  depends on, for example a C compiler would list all the header files\n  it included, and a change in any one of these files triggers a\n  recompilation\n- `output` a template string (or list of template strings) defining\n  how an output file name is (or multiple output names are) generated\n  from a single source file name\n- `capture` when this argument is set to true, Meson captures `stdout`\n  of the `executable` and writes it to the target file specified as\n  `output`. Available since v0.43.0.\n\nThe returned object also has methods that are documented in the\n[object methods section](#generator-object) below.\n\nThe template strings passed to all the above keyword arguments accept\nthe following special substitutions:\n\n- `@PLAINNAME@`: the complete input file name, e.g: `foo.c` becomes `foo.c` (unchanged)\n- `@BASENAME@`: the base of the input filename, e.g.: `foo.c.y` becomes `foo.c` (extension is removed)\n\nEach string passed to the `output` keyword argument *must* be\nconstructed using one or both of these two substitutions.\n\nIn addition to the above substitutions, the `arguments` keyword\nargument also accepts the following:\n\n- `@OUTPUT@`: the full path to the output file\n- `@INPUT@`: the full path to the input file\n- `@DEPFILE@`: the full path to the depfile\n- `@SOURCE_DIR@`: the full path to the root of the source tree\n- `@CURRENT_SOURCE_DIR@`: this is the directory where the currently processed meson.build is located in\n- `@BUILD_DIR@`: the full path to the root of the build dir where the output will be placed\n\nNOTE: Generators should only be used for outputs that will ***only***\nbe used as inputs for a [build target](#build_target) or a [custom\ntarget](#custom_target). When you use the processed output of a\ngenerator in multiple targets, the generator will be run multiple\ntimes to create outputs for each target. Each output will be created\nin a target-private directory `@BUILD_DIR@`.\n\nIf you want to generate files for general purposes such as for\ngenerating headers to be used by several sources, or data that will be\ninstalled, and so on, use a [`custom_target`](#custom_target) instead.\n\n### get_option()\n\n``` meson\n    value get_option(option_name)\n```\n\nObtains the value of the [project build option](Build-options.md)\nspecified in the positional argument.\n\nNote that the value returned for built-in options that end in `dir`\nsuch as `bindir` and `libdir` is always a path relative to (and\ninside) the `prefix`.\n\nThe only exceptions are: `sysconfdir`, `localstatedir`, and\n`sharedstatedir` which will return the value passed during\nconfiguration as-is, which may be absolute, or relative to `prefix`.\n[`install_dir` arguments](Installing.md) handles that as expected, but\nif you need the absolute path to one of these e.g. to use in a define\netc., you should use `get_option('prefix') / get_option('localstatedir')`\n\nFor options of type `feature` a\n[feature option object](#feature-option-object)\nis returned instead of a string.\nSee [`feature` options](Build-options.md#features)\ndocumentation for more details.\n\n### get_variable()\n\n``` meson\n    value get_variable(variable_name, fallback)\n```\n\nThis function can be used to dynamically obtain a variable. `res =\nget_variable(varname, fallback)` takes the value of `varname` (which\nmust be a string) and stores the variable of that name into `res`. If\nthe variable does not exist, the variable `fallback` is stored to\n`res`instead. If a fallback is not specified, then attempting to read\na non-existing variable will cause a fatal error.\n\n### import()\n\n``` meson\n    module_object import(module_name)\n```\n\nImports the given extension module. Returns an opaque object that can\nbe used to call the methods of the module. Here's an example for a\nhypothetical `testmod` module.\n\n```meson\n    tmod = import('testmod')\n    tmod.do_something()\n```\n\n### include_directories()\n\n``` meson\n    include_object include_directories(directory_names, ...)\n```\n\nReturns an opaque object which contains the directories (relative to\nthe current directory) given in the positional arguments. The result\ncan then be passed to the `include_directories:` keyword argument when\nbuilding executables or libraries. You can use the returned object in\nany subdirectory you want, Meson will make the paths work\nautomatically.\n\nNote that this function call itself does not add the directories into\nthe search path, since there is no global search path. For something\nlike that, see [`add_project_arguments()`](#add_project_arguments).\n\nSee also `implicit_include_directories` parameter of\n[executable()](#executable), which adds current source and build\ndirectories to include path.\n\nEach directory given is converted to two include paths: one that is\nrelative to the source root and one relative to the build root.\n\nFor example, with the following source tree layout in\n`/home/user/project.git`:\n\n`meson.build`:\n```meson\nproject(...)\n\nsubdir('include')\nsubdir('src')\n\n...\n```\n\n`include/meson.build`:\n```meson\ninc = include_directories('.')\n\n...\n```\n\n`src/meson.build`:\n```meson\nsources = [...]\n\nexecutable('some-tool', sources,\n  include_directories : inc,\n  ...)\n\n...\n```\n\nIf the build tree is `/tmp/build-tree`, the following include paths\nwill be added to the `executable()` call: `-I/tmp/build-tree/include\n-I/home/user/project.git/include`.\n\nThis function has one keyword argument `is_system` which, if set,\nflags the specified directories as system directories. This means that\nthey will be used with the `-isystem` compiler argument rather than\n`-I` on compilers that support this flag (in practice everything\nexcept Visual Studio).\n\n### install_data()\n\n``` meson\n    void install_data(list_of_files, ...)\n```\n\nInstalls files from the source tree that are listed as positional\narguments. The following keyword arguments are supported:\n\n- `install_dir` the absolute or relative path to the installation\n  directory. If this is a relative path, it is assumed to be relative\n  to the prefix.\n\n  If omitted, the directory defaults to `{datadir}/{projectname}` *(added 0.45.0)*.\n\n- `install_mode` specify the file mode in symbolic format and\n  optionally the owner/uid and group/gid for the installed files. For\n  example:\n\n  `install_mode: 'rw-r--r--'` for just the file mode\n\n  `install_mode: ['rw-r--r--', 'nobody', 'nobody']` for the file mode and the user/group\n\n  `install_mode: ['rw-r-----', 0, 0]` for the file mode and uid/gid\n\n To leave any of these three as the default, specify `false`.\n\n- `rename` if specified renames each source file into corresponding\n  file from `rename` list. Nested paths are allowed and they are\n  joined with `install_dir`. Length of `rename` list must be equal to\n  the number of sources.  *(added 0.46.0)*\n\nSee [Installing](Installing.md) for more examples.\n\n### install_headers()\n\n``` meson\n    void install_headers(list_of_headers, ...)\n```\n\nInstalls the specified header files from the source tree into the\nsystem header directory (usually `/{prefix}/include`) during the\ninstall step. This directory can be overridden by specifying it with\nthe `install_dir` keyword argument. If you just want to install into a\nsubdirectory of the system header directory, then use the `subdir`\nargument. As an example if this has the value `myproj` then the\nheaders would be installed to `/{prefix}/include/myproj`.\n\nFor example, this will install `common.h` and `kola.h` into\n`/{prefix}/include`:\n\n```meson\ninstall_headers('common.h', 'proj/kola.h')\n```\n\nThis will install `common.h` and `kola.h` into `/{prefix}/include/myproj`:\n\n```meson\ninstall_headers('common.h', 'proj/kola.h', subdir : 'myproj')\n```\n\nThis will install `common.h` and `kola.h` into `/{prefix}/cust/myproj`:\n\n```meson\ninstall_headers('common.h', 'proj/kola.h', install_dir : 'cust', subdir : 'myproj')\n```\n\nThe `install_mode` argument can be used to specify the file mode in symbolic\nformat and optionally the owner/uid and group/gid for the installed files.\nAn example value could be `['rwxr-sr-x', 'root', 'root']`.\n*(Added 0.47.0)*.\n\n### install_man()\n\n``` meson\n    void install_man(list_of_manpages, ...)\n```\n\nInstalls the specified man files from the source tree into system's\nman directory during the install step. This directory can be\noverridden by specifying it with the `install_dir` keyword\nargument.\n\nThe `install_mode` argument can be used to specify the file mode in symbolic\nformat and optionally the owner/uid and group/gid for the installed files.\nAn example value could be `['rwxr-sr-x', 'root', 'root']`.\n*(Added 0.47.0)*.\n\nSince 0.49.0, [manpages are no longer compressed implicitly][install_man_49].\n\n[install_man_49]: https://mesonbuild.com/Release-notes-for-0-49-0.html#manpages-are-no-longer-compressed-implicitly\n\n### install_subdir()\n\n``` meson\n    void install_subdir(subdir_name, install_dir : ..., exclude_files : ..., exclude_directories : ..., strip_directory : ...)\n```\n\nInstalls the entire given subdirectory and its contents from the\nsource tree to the location specified by the keyword argument\n`install_dir`.\n\nThe following keyword arguments are supported:\n\n- `exclude_files`: a list of file names that should not be installed.\n  Names are interpreted as paths relative to the `subdir_name` location.\n- `exclude_directories`: a list of directory names that should not be installed.\n  Names are interpreted as paths relative to the `subdir_name` location.\n- `install_dir`: the location to place the installed subdirectory.\n- `install_mode`: the file mode in symbolic format and optionally\n  the owner/uid and group/gid for the installed files. *(Added 0.47.0)*\n- `strip_directory`: install directory contents. `strip_directory=false` by default.\n  If `strip_directory=false` only last component of source path is used.\n  Since 0.45.0\n\nFor a given directory `foo`:\n```text\nfoo/\n  bar/\n    file1\n  file2\n```\n`install_subdir('foo', install_dir : 'share', strip_directory : false)` creates\n```text\nshare/\n  foo/\n    bar/\n      file1\n    file2\n```\n\n`install_subdir('foo', install_dir : 'share', strip_directory : true)` creates\n```text\nshare/\n  bar/\n    file1\n  file2\n```\n\n`install_subdir('foo/bar', install_dir : 'share', strip_directory : false)` creates\n```text\nshare/\n  bar/\n    file1\n```\n\n`install_subdir('foo/bar', install_dir : 'share', strip_directory : true)` creates\n```text\nshare/\n  file1\n```\n\n### is_disabler()\n\n``` meson\n    bool is_disabler(var)\n```\n\nReturns true if a variable is a disabler and false otherwise. Added in 0.52.0.\n\n### is_variable()\n\n``` meson\n    bool is_variable(varname)\n```\n\nReturns true if a variable of the given name exists and false otherwise.\n\n### jar()\n\n```meson\n   jar_object jar(name, list_of_sources, ...)\n```\n\nBuild a jar from the specified Java source files. Keyword arguments\nare the same as [`executable`](#executable)'s, with the addition of\n`main_class` which specifies the main class to execute when running\nthe jar with `java -jar file.jar`.\n\n### join_paths()\n\n``` meson\nstring join_paths(string1, string2, ...)\n```\n\nJoins the given strings into a file system path segment. For example\n`join_paths('foo', 'bar')` results in `foo/bar`. If any one of the\nindividual segments is an absolute path, all segments before it are\ndropped. That means that `join_paths('foo', '/bar')` returns `/bar`.\n\n**Warning** Don't use `join_paths()` for sources in [`library`](#library) and\n[`executable`](#executable), you should use [`files`](#files) instead.\n\n*Added 0.36.0*\n\nSince 0.49.0 using the`/` operator on strings is equivalent to calling\n`join_paths`.\n\n```meson\n# res1 and res2 will have identical values\nres1 = join_paths(foo, bar)\nres2 = foo / bar\n```\n\n### library()\n\n``` meson\n    buildtarget library(library_name, list_of_sources, ...)\n```\n\nBuilds a library that is either static, shared or both depending on\nthe value of `default_library`\nuser [option](https://mesonbuild.com/Builtin-options.html).\nYou should use this instead of [`shared_library`](#shared_library),\n[`static_library`](#static_library) or\n[`both_libraries`](#both_libraries) most of the time. This allows you\nto toggle your entire project (including subprojects) from shared to\nstatic with only one option. This option applies to libraries being\nbuilt internal to the entire project. For external dependencies, the\ndefault library type preferred is shared. This can be adapted on a per\nlibrary basis using the [dependency()](#dependency)) `static` keyword.\n\nThe keyword arguments for this are the same as for\n[`executable`](#executable) with the following additions:\n\n- `name_prefix` the string that will be used as the prefix for the\n  target output filename by overriding the default (only used for\n  libraries). By default this is `lib` on all platforms and compilers\n  except with MSVC shared libraries where it is omitted to follow\n  convention.\n- `name_suffix` the string that will be used as the suffix for the\n  target output filename by overriding the default (see also:\n  [executable()](#executable)). By default, for shared libraries this\n  is `dylib` on macOS, `dll` on Windows, and `so` everywhere else.\n  For static libraries, it is `a` everywhere. By convention MSVC\n  static libraries use the `lib` suffix, but we use `a` to avoid a\n  potential name clash with shared libraries which also generate\n  `xxx.lib` import files.\n- `rust_crate_type` specifies the crate type for Rust\n  libraries. Defaults to `dylib` for shared libraries and `rlib` for\n  static libraries.\n\n`static_library`, `shared_library` and `both_libraries` also accept\nthese keyword arguments.\n\nNote: You can set `name_prefix` and `name_suffix` to `[]`, or omit\nthem for the default behaviour for each platform.\n\n### message()\n\n``` meson\n    void message(text)\n```\n\nThis function prints its argument to stdout.\n\n**Since 0.54.0** Can take more more than one argument that will be separated by\nspace.\n\n### warning()\n\n``` meson\n    void warning(text)\n```\n\nThis function prints its argument to stdout prefixed with WARNING:.\n\n*Added 0.44.0*\n\n**Since 0.54.0** Can take more more than one argument that will be separated by\nspace.\n\n### summary()\n\n``` meson\n    void summary(key, value)\n    void summary(dictionary)\n```\n\nThis function is used to summarize build configuration at the end of the build\nprocess. This function provides a way for projects (and subprojects) to report\nthis information in a clear way.\n\nThe content is a series of key/value pairs grouped into sections. If the section\nkeyword argument is omitted, those key/value pairs are implicitly grouped into a section\nwith no title. key/value pairs can optionally be grouped into a dictionary,\nbut keep in mind that dictionaries does not guarantee ordering. `key` must be string,\n`value` can only be integer, boolean, string, or a list of those.\n\n`summary()` can be called multiple times as long as the same section/key\npair doesn't appear twice. All sections will be collected and printed at\nthe end of the configuration in the same order as they have been called.\n\nKeyword arguments:\n- `section` title to group a set of key/value pairs.\n- `bool_yn` if set to true, all boolean values will be replaced by green YES\n  or red NO.\n- `list_sep` *Since 0.54.0* string used to separate list values (e.g. `', '`).\n\nExample:\n```meson\nproject('My Project', version : '1.0')\nsummary({'bindir': get_option('bindir'),\n         'libdir': get_option('libdir'),\n         'datadir': get_option('datadir'),\n        }, section: 'Directories')\nsummary({'Some boolean': false,\n         'Another boolean': true,\n         'Some string': 'Hello World',\n         'A list': ['string', 1, true],\n        }, section: 'Configuration')\n```\n\nOutput:\n```\nMy Project 1.0\n\n  Directories\n             prefix: /opt/gnome\n             bindir: bin\n             libdir: lib/x86_64-linux-gnu\n            datadir: share\n\n  Configuration\n       Some boolean: False\n    Another boolean: True\n        Some string: Hello World\n             A list: string\n                     1\n                     True\n```\n\n*Added 0.53.0*\n\n### project()\n\n``` meson\n    void project(project_name, list_of_languages, ...)\n```\n\nThe first argument to this function must be a string defining the name\nof this project. It is followed by programming languages that the\nproject uses. Supported values for languages are `c`, `cpp` (for\n`C++`), `cuda`, `d`, `objc`, `objcpp`, `fortran`, `java`, `cs` (for `C#`),\n`vala` and `rust`. Since version `0.40.0` the list of languages\nis optional.\n\nThe project name can be any string you want, it's not used for\nanything except descriptive purposes. However since it is written to\ne.g. the dependency manifest is usually makes sense to have it be the\nsame as the project tarball or pkg-config name. So for example you\nwould probably want to use the name _libfoobar_ instead of _The Foobar\nLibrary_.\n\nProject supports the following keyword arguments.\n\n - `default_options` takes an array of strings. The strings are in the\n   form `key=value` and have the same format as options to\n   `meson configure`. For example to set the default project type you would\n   set this: `default_options : ['buildtype=debugoptimized']`. Note\n   that these settings are only used when running Meson for the first\n   time. Global options such as `buildtype` can only be specified in\n   the master project, settings in subprojects are ignored. Project\n   specific options are used normally even in subprojects.\n\n\n  - `license` takes a string or array of strings describing the\n    license(s) the code is under. Usually this would be something like\n    `license : 'GPL2+'`, but if the code has multiple licenses you can\n    specify them as an array like this: `license : ['proprietary',\n    'GPL3']`. Note that the text is informal and is only written to\n    the dependency manifest. Meson does not do any license validation,\n    you are responsible for verifying that you abide by all licensing\n    terms. You can access the value in your Meson build files with\n    `meson.project_license()`.\n\n  - `meson_version` takes a string describing which Meson version the\n    project requires. Usually something like `>=0.28.0`.\n\n  - `subproject_dir` specifies the top level directory name that holds\n    Meson subprojects. This is only meant as a compatibility option\n    for existing code bases that house their embedded source code in a\n    custom directory. All new projects should not set this but instead\n    use the default value. It should be noted that this keyword\n    argument is ignored inside subprojects. There can be only one\n    subproject dir and it is set in the top level Meson file.\n\n - `version`, which is a free form string describing the version of\n   this project. You can access the value in your Meson build files\n   with `meson.project_version()`.\n\n### run_command()\n\n``` meson\n    runresult run_command(command, list_of_args, ...)\n```\n\nRuns the command specified in positional arguments.  `command` can be\na string, or the output of [`find_program()`](#find_program),\n[`files()`](#files) or [`configure_file()`](#configure_file), or [a\ncompiler object](#compiler-object).\n\nReturns [an opaque object](#run-result-object) containing the result\nof the invocation. The command is run from an *unspecified* directory,\nand Meson will set three environment variables `MESON_SOURCE_ROOT`,\n`MESON_BUILD_ROOT` and `MESON_SUBDIR` that specify the source\ndirectory, build directory and subdirectory the target was defined in,\nrespectively.\n\nThis function supports the following keyword arguments:\n\n - `check` takes a boolean. If `true`, the exit status code of the command will\n   be checked, and the configuration will fail if it is non-zero. The default is\n   `false`.\n   Since 0.47.0\n - `env` environment variables to set, such as `['NAME1=value1',\n   'NAME2=value2']`, or an [`environment()`\n   object](#environment-object) which allows more sophisticated\n   environment juggling. *Since 0.52.0* a dictionary is also accepted.\n   Since 0.50.0\n\nSee also [External commands](External-commands.md).\n\n### run_target\n\n``` meson\nruntarget run_target(target_name, ...)\n```\n\nThis function creates a new top-level target that runs a specified\ncommand with the specified arguments. Like all top-level targets, this\nintegrates with the selected backend. For instance, with Ninja you can\nrun it as `ninja target_name`. Note that a run target produces no\noutput as far as Meson is concerned. It is only meant for tasks such\nas running a code formatter or flashing an external device's firmware\nwith a built file.\n\nThe command is run from an *unspecified* directory, and Meson will set\nthree environment variables `MESON_SOURCE_ROOT`, `MESON_BUILD_ROOT`\nand `MESON_SUBDIR` that specify the source directory, build directory\nand subdirectory the target was defined in, respectively.\n\n - `command` is a list containing the command to run and the arguments\n   to pass to it. Each list item may be a string or a target. For\n   instance, passing the return value of [`executable()`](#executable)\n   as the first item will run that executable, or passing a string as\n   the first item will find that command in `PATH` and run it.\n- `depends` is a list of targets that this target depends on but which\n  are not listed in the command array (because, for example, the\n  script does file globbing internally)\n\n### set_variable()\n\n``` meson\n    void set_variable(variable_name, value)\n```\n\nAssigns a value to the given variable name. Calling\n`set_variable('foo', bar)` is equivalent to `foo = bar`.\n\n**Note:** Prior to v0.46.1, the `value` parameter could not be an\narray type, due to flattening of the function parameters.\n\n### shared_library()\n\n``` meson\n    buildtarget shared_library(library_name, list_of_sources, ...)\n```\n\nBuilds a shared library with the given sources. Positional and keyword\narguments are the same as for [`library`](#library) with the following\nextra keyword arguments.\n\n- `soversion` a string specifying the soversion of this shared\n  library, such as `0`. On Linux and Windows this is used to set the\n  soversion (or equivalent) in the filename. For example, if\n  `soversion` is `4`, a Windows DLL will be called `foo-4.dll` and one\n  of the aliases of the Linux shared library would be\n  `libfoo.so.4`. If this is not specified, the first part of `version`\n  is used instead (see below). For example, if `version` is `3.6.0` and\n  `soversion` is not defined, it is set to `3`.\n- `version` a string specifying the version of this shared library,\n  such as `1.1.0`. On Linux and OS X, this is used to set the shared\n  library version in the filename, such as `libfoo.so.1.1.0` and\n  `libfoo.1.1.0.dylib`. If this is not specified, `soversion` is used\n  instead (see above).\n- `darwin_versions` *(added 0.48)* an integer, string, or a list of\n  versions to use for setting dylib `compatibility version` and\n  `current version` on macOS. If a list is specified, it must be\n  either zero, one, or two elements. If only one element is specified\n  or if it's not a list, the specified value will be used for setting\n  both compatibility version and current version. If unspecified, the\n  `soversion` will be used as per the aforementioned rules.\n- `vs_module_defs` a string, a File object, or Custom Target for a\n  Microsoft module definition file for controlling symbol exports,\n  etc., on platforms where that is possible (e.g. Windows).\n\n### shared_module()\n\n``` meson\n    buildtarget shared_module(module_name, list_of_sources, ...)\n```\n\nBuilds a shared module with the given sources. Positional and keyword\narguments are the same as for [`library`](#library).\n\nThis is useful for building modules that will be `dlopen()`ed and\nhence may contain undefined symbols that will be provided by the\nlibrary that is loading it.\n\nIf you want the shared module to be able to refer to functions and\nvariables defined in the [`executable`](#executable) it is loaded by,\nyou will need to set the `export_dynamic` argument of the executable to\n`true`.\n\nSupports the following extra keyword arguments:\n\n- `vs_module_defs`, *(Added 0.52.0)*, a string, a File object, or\n  Custom Target for a Microsoft module definition file for controlling\n  symbol exports, etc., on platforms where that is possible\n  (e.g. Windows).\n\n**Note:** Linking to a shared module is not supported on some\nplatforms, notably OSX.  Consider using a\n[`shared_library`](#shared_library) instead, if you need to both\n`dlopen()` and link with a library.\n\n*Added 0.37.0*\n\n### static_library()\n\n``` meson\n    buildtarget static_library(library_name, list_of_sources, ...)\n```\n\nBuilds a static library with the given sources. Positional and keyword\narguments are otherwise the same as for [`library`](#library), but it\nhas one argument the others don't have:\n\n - `pic`, *(Added 0.36.0)* builds the library as positional\n   independent code (so it can be linked into a shared library). This\n   option has no effect on Windows and OS X since it doesn't make\n   sense on Windows and PIC cannot be disabled on OS X.\n\n### subdir()\n\n``` meson\n    void subdir(dir_name, ...)\n```\n\nEnters the specified subdirectory and executes the `meson.build` file\nin it. Once that is done, it returns and execution continues on the\nline following this `subdir()` command. Variables defined in that\n`meson.build` file are then available for use in later parts of the\ncurrent build file and in all subsequent build files executed with\n`subdir()`.\n\nNote that this means that each `meson.build` file in a source tree can\nand must only be executed once.\n\nThis function has one keyword argument.\n\n - `if_found` takes one or several dependency objects and will only\n   recurse in the subdir if they all return `true` when queried with\n   `.found()`\n\n### subdir_done()\n\n``` meson\n    subdir_done()\n```\n\nStops further interpretation of the meson script file from the point of\nthe invocation. All steps executed up to this point are valid and will\nbe executed by meson. This means that all targets defined before the call\nof `subdir_done` will be build.\n\nIf the current script was called by `subdir` the execution returns to the\ncalling directory and continues as if the script had reached the end.\nIf the current script is the top level script meson configures the project\nas defined up to this point.\n\nExample:\n```meson\nproject('example exit', 'cpp')\nexecutable('exe1', 'exe1.cpp')\nsubdir_done()\nexecutable('exe2', 'exe2.cpp')\n```\n\nThe executable `exe1` will be build, while the executable `exe2` is not\nbuild.\n\n### subproject()\n\n``` meson\n    subproject_object subproject(subproject_name, ...)\n```\n\nTakes the project specified in the positional argument and brings that\nin the current build specification by returning a [subproject\nobject](#subproject-object). Subprojects must always be placed inside\nthe `subprojects` directory at the top source directory. So for\nexample a subproject called `foo` must be located in\n`${MESON_SOURCE_ROOT}/subprojects/foo`. Supports the following keyword\narguments:\n\n - `default_options` *(added 0.37.0)* an array of default option values\n   that override those set in the subproject's `meson_options.txt`\n   (like `default_options` in `project`, they only have effect when\n   Meson is run for the first time, and command line arguments override\n   any default options in build files). *Since 0.54.0* `default_library`\n   built-in option can also be overridden.\n - `version` keyword argument that works just like the one in\n   `dependency`. It specifies what version the subproject should be,\n   as an example `>=1.0.1`\n - `required` *(added 0.48.0)* By default, `required` is `true` and\n   Meson will abort if the subproject could not be setup. You can set\n   this to `false` and then use the `.found()` method on the [returned\n   object](#subproject-object). You may also pass the value of a\n   [`feature`](Build-options.md#features) option, same as\n   [`dependency()`](#dependency).\n\nNote that you can use the returned [subproject\nobject](#subproject-object) to access any variable in the\nsubproject. However, if you want to use a dependency object from\ninside a subproject, an easier way is to use the `fallback:` keyword\nargument to [`dependency()`](#dependency).\n\n[See additional documentation](Subprojects.md).\n\n### test()\n\n``` meson\n    void test(name, executable, ...)\n```\n\nDefines a test to run with the test harness. Takes two positional\narguments, the first is the name of the test and the second is the\nexecutable to run.  The executable can be an [executable build target\nobject](#build-target-object) returned by\n[`executable()`](#executable) or an [external program\nobject](#external-program-object) returned by\n[`find_program()`](#find_program).\n\nBy default, environment variable\n[`MALLOC_PERTURB_`](http://man7.org/linux/man-pages/man3/mallopt.3.html)\nis automatically set by `meson test` to a random value between 1..255.\nThis can help find memory leaks on configurations using glibc,\nincluding with non-GCC compilers. However, this can have a performance impact,\nand may fail a test due to external libraries whose internals are out of the\nuser's control. To check if this feature is causing an expected runtime crash,\ndisable the feature by temporarily setting environment variable\n`MALLOC_PERTURB_=0`. While it's preferable to only temporarily disable this\ncheck, if a project requires permanent disabling of this check\nin meson.build do like:\n\n```meson\nnomalloc = environment({'MALLOC_PERTURB_': '0'})\n\ntest(..., env: nomalloc, ...)\n```\n\n#### test() Keyword arguments\n\n- `args` arguments to pass to the executable\n\n- `env` environment variables to set, such as `['NAME1=value1',\n  'NAME2=value2']`, or an [`environment()`\n  object](#environment-object) which allows more sophisticated\n  environment juggling. *Since 0.52.0* a dictionary is also accepted.\n\n- `is_parallel` when false, specifies that no other test must be\n  running at the same time as this test\n\n- `should_fail` when true the test is considered passed if the\n  executable returns a non-zero return value (i.e. reports an error)\n\n- `suite` `'label'` (or list of labels `['label1', 'label2']`)\n  attached to this test. The suite name is qualified by a (sub)project\n  name resulting in `(sub)project_name:label`. In the case of a list\n  of strings, the suite names will be `(sub)project_name:label1`,\n  `(sub)project_name:label2`, etc.\n\n- `timeout` the amount of seconds the test is allowed to run, a test\n  that exceeds its time limit is always considered failed, defaults to\n  30 seconds\n\n- `workdir` absolute path that will be used as the working directory\n  for the test\n\n- `depends` specifies that this test depends on the specified\n  target(s), even though it does not take any of them as a command\n  line argument. This is meant for cases where test finds those\n  targets internally, e.g. plugins or globbing. Those targets are built\n  before test is executed even if they have `build_by_default : false`.\n  Since 0.46.0\n\n- `protocol` specifies how the test results are parsed and can be one\n  of `exitcode` (the executable's exit code is used by the test harness\n  to record the outcome of the test) or `tap` ([Test Anything\n  Protocol](https://www.testanything.org/)). For more on the Meson test\n  harness protocol read [Unit Tests](Unit-tests.md). Since 0.50.0\n\n- `priority` specifies the priority of a test. Tests with a\n  higher priority are *started* before tests with a lower priority.\n  The starting order of tests with identical priorities is\n  implementation-defined. The default priority is 0, negative numbers are\n  permitted. Since 0.52.0\n\nDefined tests can be run in a backend-agnostic way by calling\n`meson test` inside the build dir, or by using backend-specific\ncommands, such as `ninja test` or `msbuild RUN_TESTS.vcxproj`.\n\n### vcs_tag()\n\n``` meson\n    customtarget vcs_tag(...)\n```\n\nThis command detects revision control commit information at build time\nand places it in the specified output file. This file is guaranteed to\nbe up to date on every build. Keywords are similar to `custom_target`.\n\n- `command` string list with the command to execute, see\n  [`custom_target`](#custom_target) for details on how this command\n  must be specified\n- `fallback` version number to use when no revision control\n  information is present, such as when building from a release tarball\n  (defaults to `meson.project_version()`)\n- `input` file to modify (e.g. `version.c.in`) (required)\n- `output` file to write the results to (e.g. `version.c`) (required)\n- `replace_string` string in the input file to substitute with the\n  commit information (defaults to `@VCS_TAG@`)\n\nMeson will read the contents of `input`, substitute the\n`replace_string` with the detected revision number, and write the\nresult to `output`. This method returns a\n[`custom_target`](#custom_target) object that (as usual) should be\nused to signal dependencies if other targets use the file outputted\nby this.\n\nFor example, if you generate a header with this and want to use that in\na build target, you must add the return value to the sources of that\nbuild target. Without that, Meson will not know the order in which to\nbuild the targets.\n\nIf you desire more specific behavior than what this command provides,\nyou should use `custom_target`.\n\n## Built-in objects\n\nThese are built-in objects that are always available.\n\n### `meson` object\n\nThe `meson` object allows you to introspect various properties of the\nsystem. This object is always mapped in the `meson` variable. It has\nthe following methods.\n\n- `add_dist_script(script_name, arg1, arg, ...)` causes the script\n  given as argument to run during `dist` operation after the\n  distribution source has been generated but before it is\n  archived. Note that this runs the script file that is in the\n  _staging_ directory, not the one in the source directory. If the\n  script file can not be found in the staging directory, it is a hard\n  error. This command can only invoked from the main project, calling\n  it from a subproject is a hard error. Available since 0.48.0. Before\n  0.49.0, the function only accepted a single argument. Since 0.54.0\n  the `MESON_SOURCE_ROOT` and `MESON_BUILD_ROOT` environment variables\n  are set when dist scripts are run.\n\n- `add_install_script(script_name, arg1, arg2, ...)` causes the script\n  given as an argument to be run during the install step, this script\n  will have the environment variables `MESON_SOURCE_ROOT`,\n  `MESON_BUILD_ROOT`, `MESON_INSTALL_PREFIX`,\n  `MESON_INSTALL_DESTDIR_PREFIX`, and `MESONINTROSPECT` set.\n  All positional arguments are passed as parameters.\n\n  *(added 0.54)* If `meson install` is called with the `--quiet` option, the\n  environment variable `MESON_INSTALL_QUIET` will be set.\n\n  Meson uses the `DESTDIR` environment variable as set by the\n  inherited environment to determine the (temporary) installation\n  location for files. Your install script must be aware of this while\n  manipulating and installing files. The correct way to handle this is\n  with the `MESON_INSTALL_DESTDIR_PREFIX` variable which is always set\n  and contains `DESTDIR` (if set) and `prefix` joined together. This\n  is useful because both are usually absolute paths and there are\n  platform-specific edge-cases in joining two absolute paths.\n\n  In case it is needed, `MESON_INSTALL_PREFIX` is also always set and\n  has the value of the `prefix` option passed to Meson.\n\n  `MESONINTROSPECT` contains the path to the introspect command that\n  corresponds to the `meson` executable that was used to configure the\n  build. (This might be a different path then the first executable\n  found in `PATH`.) It can be used to query build configuration. Note\n  that the value will contain many parts, f.ex., it may be `python3\n  /path/to/meson.py introspect`. The user is responsible for splitting\n  the string to an array if needed by splitting lexically like a UNIX\n  shell would. If your script uses Python, `shlex.split()` is the\n  easiest correct way to do this.\n\n- `add_postconf_script(script_name, arg1, arg2, ...)` will run the\n  executable given as an argument after all project files have been\n  generated. This script will have the environment variables\n  `MESON_SOURCE_ROOT` and `MESON_BUILD_ROOT` set.\n\n- `backend()` *(added 0.37.0)* returns a string representing the\n  current backend: `ninja`, `vs2010`, `vs2015`, `vs2017`, `vs2019`,\n  or `xcode`.\n\n- `build_root()` returns a string with the absolute path to the build\n  root directory. Note: this function will return the build root of\n  the parent project if called from a subproject, which is usually\n  not what you want. Try using `current_build_dir()`.\n\n- `source_root()` returns a string with the absolute path to the\n  source root directory. Note: you should use the `files()` function\n  to refer to files in the root source directory instead of\n  constructing paths manually with `meson.source_root()`. This\n  function will return the source root of the parent project if called\n  from a subproject, which is usually not what you want. Try using\n  `current_source_dir()`.\n\n- `current_build_dir()` returns a string with the absolute path to the\n  current build directory.\n\n- `current_source_dir()` returns a string to the current source\n  directory. Note: **you do not need to use this function** when\n  passing files from the current source directory to a function since\n  that is the default. Also, you can use the `files()` function to\n  refer to files in the current or any other source directory instead\n  of constructing paths manually with `meson.current_source_dir()`.\n\n- `get_compiler(language)` returns [an object describing a\n  compiler](#compiler-object), takes one positional argument which is\n  the language to use. It also accepts one keyword argument, `native`\n  which when set to true makes Meson return the compiler for the build\n  machine (the \"native\" compiler) and when false it returns the host\n  compiler (the \"cross\" compiler). If `native` is omitted, Meson\n  returns the \"cross\" compiler if we're currently cross-compiling and\n  the \"native\" compiler if we're not.\n\n- `get_cross_property(propname, fallback_value)`\n  *Consider get_external_property() instead*. Returns the given\n  property from a cross file, the optional fallback_value is returned\n  if not cross compiling or the given property is not found.\n\n- `get_external_property(propname, fallback_value, native: true/false)`\n  *(added 0.54.0)* returns the given property from a native or cross file.\n  The optional fallback_value is returned if the given property is not found.\n  The optional `native: true` forces retrieving a variable from the\n  native file, even when cross-compiling.\n  If `native: false` or not specified, variable is retrieved from the\n  cross-file if cross-compiling, and from the native-file when not cross-compiling.\n\n- `has_exe_wrapper()` returns true when doing a cross build if there\n  is a wrapper command that can be used to execute cross built\n  binaries (for example when cross compiling from Linux to Windows,\n  one can use `wine` as the wrapper).\n\n- `install_dependency_manifest(output_name)` installs a manifest file\n  containing a list of all subprojects, their versions and license\n  files to the file name given as the argument.\n\n- `is_cross_build()` returns `true` if the current build is a [cross\n  build](Cross-compilation.md) and `false` otherwise.\n\n- `is_subproject()` returns `true` if the current project is being\n  built as a subproject of some other project and `false` otherwise.\n\n- `is_unity()` returns `true` when doing a [unity\n  build](Unity-builds.md) (multiple sources are combined before\n  compilation to reduce build time) and `false` otherwise.\n\n- `override_find_program(progname, program)` [*(Added\n  0.46.0)*](Release-notes-for-0.46.0.md#can-override-find_program)\n  specifies that whenever `find_program` is used to find a program\n  named `progname`, Meson should not look it up on the system but\n  instead return `program`, which may either be the result of\n  `find_program`, `configure_file` or `executable`.\n\n  If `program` is an `executable`, it cannot be used during configure.\n\n- `override_dependency(name, dep_object)` [*(Added\n  0.54.0)*](Release-notes-for-0.54.0.md#override-dependency)\n  specifies that whenever `dependency(name, ...)` is used, Meson should not\n  look it up on the system but instead return `dep_object`, which may either be\n  the result of `dependency()` or `declare_dependency()`. It takes optional\n  `native` keyword arguments. Doing this in a subproject allows the parent\n  project to retrieve the dependency without having to know the dependency\n  variable name: `dependency(name, fallback : subproject_name)`.\n\n- `project_version()` returns the version string specified in\n  `project` function call.\n\n- `project_license()` returns the array of licenses specified in\n  `project` function call.\n\n- `project_name()` returns the project name specified in the `project`\n  function call.\n\n- `version()` return a string with the version of Meson.\n\n### `build_machine` object\n\nProvides information about the build machine \u2014 the machine that is\ndoing the actual compilation. See\n[Cross-compilation](Cross-compilation.md). It has the following\nmethods:\n\n- `cpu_family()` returns the CPU family name. [This\n  table](Reference-tables.md#cpu-families) contains all known CPU\n  families. These are guaranteed to continue working.\n\n- `cpu()` returns a more specific CPU name, such as `i686`, `amd64`,\n  etc.\n\n- `system()` returns the operating system name.  [This\n  table](Reference-tables.md#operating-system-names) Lists all of\n  the currently known Operating System names, these are guaranteed to\n  continue working.\n\n- `endian()` returns `big` on big-endian systems and `little` on\n  little-endian systems.\n\nCurrently, these values are populated using\n[`platform.system()`](https://docs.python.org/3.4/library/platform.html#platform.system)\nand\n[`platform.machine()`](https://docs.python.org/3.4/library/platform.html#platform.machine). If\nyou think the returned values for any of these are incorrect for your\nsystem or CPU, or if your OS is not in the linked table, please file\n[a bug report](https://github.com/mesonbuild/meson/issues/new) with\ndetails and we'll look into it.\n\n### `host_machine` object\n\nProvides information about the host machine \u2014 the machine on which the\ncompiled binary will run. See\n[Cross-compilation](Cross-compilation.md).\n\nIt has the same methods as [`build_machine`](#build_machine-object).\n\nWhen not cross-compiling, all the methods return the same values as\n`build_machine` (because the build machine is the host machine)\n\nNote that while cross-compiling, it simply returns the values defined\nin the cross-info file.\n\n### `target_machine` object\n\nProvides information about the target machine \u2014 the machine on which\nthe compiled binary's output will run. Hence, this object should only\nbe used while cross-compiling a compiler. See\n[Cross-compilation](Cross-compilation.md).\n\nIt has the same methods as [`build_machine`](#build_machine-object).\n\nWhen all compilation is 'native', all the methods return the same\nvalues as `build_machine` (because the build machine is the host\nmachine and the target machine).\n\nNote that while cross-compiling, it simply returns the values defined\nin the cross-info file. If `target_machine` values are not defined in\nthe cross-info file, `host_machine` values are returned instead.\n\n### `string` object\n\nAll [strings](Syntax.md#strings) have the following methods. Strings\nare immutable, all operations return their results as a new string.\n\n- `contains(string)` returns true if string contains the string\n  specified as the argument\n\n- `endswith(string)` returns true if string ends with the string\n  specified as the argument\n\n- `format()` formats text, see the [Syntax\n  manual](Syntax.md#string-formatting) for usage info\n\n- `join(list_of_strings)` is the opposite of split, for example\n  `'.'.join(['a', 'b', 'c']` yields `'a.b.c'`\n\n- `split(split_character)` splits the string at the specified\n  character (or whitespace if not set) and returns the parts in an\n  array\n\n- `startswith(string)` returns true if string starts with the string\n  specified as the argument\n\n- `strip()` removes whitespace at the beginning and end of the string\n  *(added 0.43.0)* optionally can take one positional string argument,\n  and all characters in that string will be stripped\n\n- `to_int` returns the string converted to an integer (error if string\n  is not a number)\n\n- `to_lower()` creates a lower case version of the string\n\n- `to_upper()` creates an upper case version of the string\n\n- `underscorify()` creates a string where every non-alphabetical\n  non-number character is replaced with `_`\n\n- `version_compare(comparison_string)` does semantic version\n  comparison, if `x = '1.2.3'` then `x.version_compare('>1.0.0')`\n  returns `true`\n\n### `Number` object\n\n[Numbers](Syntax.md#numbers) support these methods:\n\n - `is_even()` returns true if the number is even\n - `is_odd()` returns true if the number is odd\n - `to_string()` returns the value of the number as a string.\n\n### `boolean` object\n\nA [boolean](Syntax.md#booleans) object has two simple methods:\n\n- `to_int()` as above, but returns either `1` or `0`\n\n- `to_string()` returns the string `'true'` if the boolean is true or\n  `'false'` otherwise. You can also pass it two strings as positional\n  arguments to specify what to return for true/false. For instance,\n  `bool.to_string('yes', 'no')` will return `yes` if the boolean is\n  true and `no` if it is false.\n\n### `array` object\n\nThe following methods are defined for all [arrays](Syntax.md#arrays):\n\n- `contains(item)`, returns `true` if the array contains the object\n  given as argument, `false` otherwise\n\n- `get(index, fallback)`, returns the object at the given index,\n  negative indices count from the back of the array, indexing out of\n  bounds returns the `fallback` value *(added 0.38.0)* or, if it is\n  not specified, causes a fatal error\n\n- `length()`, the size of the array\n\nYou can also iterate over arrays with the [`foreach`\nstatement](Syntax.md#foreach-statements).\n\n### `dictionary` object\n\nThe following methods are defined for all [dictionaries](Syntax.md#dictionaries):\n\n- `has_key(key)` returns `true` if the dictionary contains the key\n  given as argument, `false` otherwise\n\n- `get(key, fallback)`, returns the value for the key given as first\n  argument if it is present in the dictionary, or the optional\n  fallback value given as the second argument. If a single argument\n  was given and the key was not found, causes a fatal error\n\nYou can also iterate over dictionaries with the [`foreach`\nstatement](Syntax.md#foreach-statements).\n\nDictionaries are available since 0.47.0.\n\nSince 0.48.0 dictionaries can be added (e.g. `d1 = d2 + d3` and `d1 += d2`).\nValues from the second dictionary overrides values from the first.\n\n## Returned objects\n\nThese are objects returned by the [functions listed above](#functions).\n\n### `compiler` object\n\nThis object is returned by\n[`meson.get_compiler(lang)`](#meson-object). It represents a compiler\nfor a given language and allows you to query its properties. It has\nthe following methods:\n\n- `alignment(typename)` returns the alignment of the type specified in\n  the positional argument, you can specify external dependencies to\n  use with `dependencies` keyword argument.\n\n- `cmd_array()` returns an array containing the command arguments for\n  the current compiler.\n\n- `compiles(code)` returns true if the code fragment given in the\n  positional argument compiles, you can specify external dependencies\n  to use with `dependencies` keyword argument, `code` can be either a\n  string containing source code or a `file` object pointing to the\n  source code.\n\n- `compute_int(expr, ...')` computes the value of the given expression\n  (as an example `1 + 2`). When cross compiling this is evaluated with\n  an iterative algorithm, you can specify keyword arguments `low`\n  (defaults to -1024), `high` (defaults to 1024) and `guess` to\n  specify max and min values for the search and the value to try\n  first.\n\n- `find_library(lib_name, ...)` tries to find the library specified in\n  the positional argument. The [result\n  object](#external-library-object) can be used just like the return\n  value of `dependency`. If the keyword argument `required` is false,\n  Meson will proceed even if the library is not found. By default the\n  library is searched for in the system library directory\n  (e.g. /usr/lib). This can be overridden with the `dirs` keyword\n  argument, which can be either a string or a list of strings.  Since\n  *0.47.0* the value of a [`feature`](Build-options.md#features)\n  option can also be passed to the `required` keyword argument.\n  *Since 0.49.0* if the keyword argument `disabler` is `true` and the\n  dependency couldn't be found, return a [disabler object](#disabler-object)\n  instead of a not-found dependency. *Since 0.50.0* the `has_headers` keyword\n  argument can be a list of header files that must be found as well, using\n  `has_header()` method. All keyword arguments prefixed with `header_` will be\n  passed down to `has_header()` method with the prefix removed. *Since 0.51.0*\n  the `static` keyword (boolean) can be set to `true` to limit the search to\n  static libraries and `false` for dynamic/shared.\n\n- `first_supported_argument(list_of_strings)`, given a list of\n  strings, returns the first argument that passes the `has_argument`\n  test or an empty array if none pass.\n\n- `first_supported_link_argument(list_of_strings)` *(added 0.46.0)*,\n  given a list of strings, returns the first argument that passes the\n  `has_link_argument` test or an empty array if none pass.\n\n- `get_define(definename)` returns the given preprocessor symbol's\n  value as a string or empty string if it is not defined.\n  Starting with 0.47.0, this method will concatenate string literals as\n  the compiler would. E.g. `\"a\" \"b\"` will become `\"ab\"`.\n\n- `get_id()` returns a string identifying the compiler. For example,\n  `gcc`, `msvc`, [and more](Reference-tables.md#compiler-ids).\n\n- `get_argument_syntax()` *(new in 0.49.0)* returns a string identifying the type\n  of arguments the compiler takes. Can be one of `gcc`, `msvc`, or an undefined\n  string value. This method is useful for identifying compilers that are not\n  gcc or msvc, but use the same argument syntax as one of those two compilers\n  such as clang or icc, especially when they use different syntax on different\n  operating systems.\n\n- `get_linker_id()` *(added 0.53.0)* returns a string identifying the linker.\n   For example, `ld.bfd`, `link`, [and more](Reference-tables.md#linker-ids).\n\n- `get_supported_arguments(list_of_string)` *(added 0.43.0)* returns\n  an array containing only the arguments supported by the compiler,\n  as if `has_argument` were called on them individually.\n\n- `get_supported_link_arguments(list_of_string)` *(added 0.46.0)* returns\n  an array containing only the arguments supported by the linker,\n  as if `has_link_argument` were called on them individually.\n\n- `has_argument(argument_name)` returns true if the compiler accepts\n  the specified command line argument, that is, can compile code\n  without erroring out or printing a warning about an unknown flag.\n\n- `has_link_argument(argument_name)` *(added 0.46.0)* returns true if\n  the linker accepts the specified command line argument, that is, can\n  compile and link code without erroring out or printing a warning\n  about an unknown flag. Link arguments will be passed to the\n  compiler, so should usually have the `-Wl,` prefix. On VisualStudio\n  a `/link` argument will be prepended.\n\n- `has_function(funcname)` returns true if the given function is\n  provided by the standard library or a library passed in with the\n  `args` keyword, you can specify external dependencies to use with\n  `dependencies` keyword argument.\n\n- `check_header` *(added 0.47.0)* returns true if the specified header is *usable* with\n  the specified prefix, dependencies, and arguments.\n  You can specify external dependencies to use with `dependencies`\n  keyword argument and extra code to put above the header test with\n  the `prefix` keyword. In order to look for headers in a specific\n  directory you can use `args : '-I/extra/include/dir`, but this\n  should only be used in exceptional cases for includes that can't be\n  detected via pkg-config and passed via `dependencies`. Since *0.50.0* the\n  `required` keyword argument can be used to abort if the header cannot be\n  found.\n\n- `has_header` returns true if the specified header *exists*, and is\n  faster than `check_header()` since it only does a pre-processor check.\n  You can specify external dependencies to use with `dependencies`\n  keyword argument and extra code to put above the header test with\n  the `prefix` keyword. In order to look for headers in a specific\n  directory you can use `args : '-I/extra/include/dir`, but this\n  should only be used in exceptional cases for includes that can't be\n  detected via pkg-config and passed via `dependencies`. Since *0.50.0* the\n  `required` keyword argument can be used to abort if the header cannot be\n  found.\n\n- `has_header_symbol(headername, symbolname)` allows one to detect\n  whether a particular symbol (function, variable, #define, type\n  definition, etc) is declared in the specified header, you can\n  specify external dependencies to use with `dependencies` keyword\n  argument. Since *0.50.0* the `required` keyword argument can be used to abort\n  if the symbol cannot be found.\n\n- `has_member(typename, membername)` takes two arguments, type name\n  and member name and returns true if the type has the specified\n  member, you can specify external dependencies to use with\n  `dependencies` keyword argument.\n\n- `has_members(typename, membername1, membername2, ...)` takes at\n  least two arguments, type name and one or more member names, returns\n  true if the type has all the specified members, you can specify\n  external dependencies to use with `dependencies` keyword argument.\n\n- `has_multi_arguments(arg1, arg2, arg3, ...)` is the same as\n  `has_argument` but takes multiple arguments and uses them all in a\n  single compiler invocation, available since 0.37.0.\n\n- `has_multi_link_arguments(arg1, arg2, arg3, ...)` *(added 0.46.0)*\n  is the same as `has_link_argument` but takes multiple arguments and\n  uses them all in a single compiler invocation.\n\n- `has_type(typename)` returns true if the specified token is a type,\n  you can specify external dependencies to use with `dependencies`\n  keyword argument.\n\n- `links(code)` returns true if the code fragment given in the\n  positional argument compiles and links, you can specify external\n  dependencies to use with `dependencies` keyword argument, `code` can\n  be either a string containing source code or a `file` object\n  pointing to the source code.\n\n- `run(code)` attempts to compile and execute the given code fragment,\n  returns a run result object, you can specify external dependencies\n  to use with `dependencies` keyword argument, `code` can be either a\n  string containing source code or a `file` object pointing to the\n  source code.\n\n- `symbols_have_underscore_prefix()` returns `true` if the C symbol\n  mangling is one underscore (`_`) prefixed to the symbol, available\n  since 0.37.0.\n\n- `sizeof(typename, ...)` returns the size of the given type\n  (e.g. `'int'`) or -1 if the type is unknown, to add includes set\n  them in the `prefix` keyword argument, you can specify external\n  dependencies to use with `dependencies` keyword argument.\n\n- `version()` returns the compiler's version number as a string.\n\n- `has_function_attribute(name)` *(added in 0.48.0)* returns `true` if the\n  compiler supports the GNU style (`__attribute__(...)`) `name`. This is\n  preferable to manual compile checks as it may be optimized for compilers that\n  do not support such attributes.\n  [This table](Reference-tables.md#gcc-__attribute__) lists all of the\n  supported attributes.\n\n- `get_supported_function_attributes(list_of_names)` *(added in 0.48.0)*\n  returns an array containing any names that are supported GCC style\n  attributes. Equivalent to `has_function_attribute` was called on each of them\n  individually.\n\nThe following keyword arguments can be used:\n\n- `args` can be used to pass a list of compiler arguments that are\n  required to find the header or symbol. For example, you might need\n  to pass the include path `-Isome/path/to/header` if a header is not\n  in the default include path. In versions newer than 0.38.0 you\n  should use the `include_directories` keyword described below. You\n  may also want to pass a library name `-lfoo` for `has_function` to\n  check for a function. Supported by all methods except `get_id`,\n  `version`, and `find_library`.\n\n- `include_directories` specifies extra directories for header\n  searches. *(added 0.38.0)*\n\n- `name` the name to use for printing a message about the compiler\n  check. Supported by the methods `compiles()`, `links()`, and\n  `run()`. If this keyword argument is not passed to those methods, no\n  message will be printed about the check.\n\n- `no_builtin_args` when set to true, the compiler arguments controlled\n  by built-in configuration options are not added.\n\n- `prefix` can be used to add #includes and other things that are\n  required for the symbol to be declared. System definitions should be\n  passed via compiler args (eg: `_GNU_SOURCE` is often required for\n  some symbols to be exposed on Linux, and it should be passed via\n  `args` keyword argument, see below). Supported by the methods\n  `sizeof`, `has_type`, `has_function`, `has_member`, `has_members`,\n  `check_header`, `has_header`, `has_header_symbol`.\n\n**Note:** These compiler checks do not use compiler arguments added with\n`add_*_arguments()`, via `-Dlang_args` on the command-line, or through\n`CFLAGS`/`LDFLAGS`, etc in the environment. Hence, you can trust that\nthe tests will be fully self-contained, and won't fail because of custom\nflags added by other parts of the build file or by users.\n\nNote that if you have a single prefix with all your dependencies, you\nmight find it easier to append to the environment variables\n`C_INCLUDE_PATH` with GCC/Clang and `INCLUDE` with MSVC to expand the\ndefault include path, and `LIBRARY_PATH` with GCC/Clang and `LIB` with\nMSVC to expand the default library search path.\n\nHowever, with GCC, these variables will be ignored when\ncross-compiling. In that case you need to use a specs file. See:\n<http://www.mingw.org/wiki/SpecsFileHOWTO>\n\n### `build target` object\n\nA build target is either an [executable](#executable),\n[shared library](#shared_library), [static library](#static_library),\n[both shared and static library](#both_libraries) or\n[shared module](#shared_module).\n\n- `extract_all_objects()` is same as `extract_objects` but returns all\n  object files generated by this target. Since 0.46.0 keyword argument\n  `recursive` must be set to `true` to also return objects passed to\n  the `object` argument of this target. By default only objects built\n  for this target are returned to maintain backward compatibility with\n  previous versions.  The default will eventually be changed to `true`\n  in a future version.\n\n- `extract_objects(source1, source2, ...)` takes as its arguments\n  a number of source files as [`string`](#string-object) or\n  [`files()`](#files) and returns an opaque value representing the\n  object files generated for those source files. This is typically used\n  to take single object files and link them to unit tests or to compile\n  some source files with custom flags. To use the object file(s)\n  in another build target, use the `objects:` keyword argument.\n\n- `full_path()` returns a full path pointing to the result target file.\n  NOTE: In most cases using the object itself will do the same job as\n  this and will also allow Meson to setup inter-target dependencies\n  correctly. Please file a bug if that doesn't work for you.\n\n- `private_dir_include()` returns a opaque value that works like\n  `include_directories` but points to the private directory of this\n  target, usually only needed if an another target needs to access\n  some generated internal headers of this target\n\n- `name()` *Since 0.54.0*, returns the target name.\n\n\n### `configuration` data object\n\nThis object is returned by\n[`configuration_data()`](#configuration_data) and encapsulates\nconfiguration values to be used for generating configuration files. A\nmore in-depth description can be found in the [the configuration wiki\npage](Configuration.md) It has three methods:\n\n- `get(varname, default_value)` returns the value of `varname`, if the\n  value has not been set returns `default_value` if it is defined\n  *(added 0.38.0)* and errors out if not\n\n- `get_unquoted(varname, default_value)` returns the value of `varname`\n  but without surrounding double quotes (`\"`). If the value has not been\n  set returns `default_value` if it is defined and errors out if not.\n  Available since 0.44.0\n\n- `has(varname)`, returns `true` if the specified variable is set\n\n- `merge_from(other)` takes as argument a different configuration data\n  object and copies all entries from that object to the current\n  object, available since 0.42.0\n\n- `set(varname, value)`, sets a variable to a given value\n\n- `set10(varname, boolean_value)` is the same as above but the value\n  is either `true` or `false` and will be written as 1 or 0,\n  respectively\n\n- `set_quoted(varname, value)` is same as `set` but quotes the value\n  in double quotes (`\"`)\n\nThey all take the `description` keyword that will be written in the\nresult file. The replacement assumes a file with C syntax. If your\ngenerated file is source code in some other language, you probably\ndon't want to add a description field because it most likely will\ncause a syntax error.\n\n### `custom target` object\n\nThis object is returned by [`custom_target`](#custom_target) and\ncontains a target with the following methods:\n\n- `full_path()` returns a full path pointing to the result target file\n  NOTE: In most cases using the object itself will do the same job as\n  this and will also allow Meson to setup inter-target dependencies\n  correctly. Please file a bug if that doesn't work for you.\n  *Since 0.54.0* it can be also called on indexes objects:\n  `custom_targets[i].full_path()`.\n\n- `[index]` returns an opaque object that references this target, and\n  can be used as a source in other targets. When it is used as such it\n  will make that target depend on this custom target, but the only\n  source added will be the one that corresponds to the index of the\n  custom target's output argument.\n\n- `to_list()` *Since 0.54.0*, returns a list of opaque objects that references\n  this target, and can be used as a source in other targets. This can be used to\n  iterate outputs with `foreach` loop.\n\n### `dependency` object\n\nThis object is returned by [`dependency()`](#dependency) and contains\nan external dependency with the following methods:\n\n - `found()` which returns whether the dependency was found\n\n - `name()` *(Added 0.48.0)* returns the name of the dependency that was\n   searched. Returns `internal` for dependencies created with\n   `declare_dependency()`.\n\n - `get_pkgconfig_variable(varname)` *(Added 0.36.0)* will get the\n   pkg-config variable specified, or, if invoked on a non pkg-config\n   dependency, error out. *(Added 0.44.0)* You can also redefine a\n   variable by passing a list to the `define_variable` parameter\n   that can affect the retrieved variable: `['prefix', '/'])`.\n   *(Added 0.45.0)* A warning is issued if the variable is not defined,\n   unless a `default` parameter is specified.\n\n - `get_configtool_variable(varname)` *(Added 0.44.0)* will get the\n   command line argument from the config tool (with `--` prepended), or,\n   if invoked on a non config-tool dependency, error out.\n\n - `type_name()` which returns a string describing the type of the\n   dependency, the most common values are `internal` for deps created\n   with `declare_dependency()` and `pkgconfig` for system dependencies\n   obtained with Pkg-config.\n\n - `version()` is the version number as a string, for example `1.2.8`.\n   `unknown` if the dependency provider doesn't support determining the\n   version.\n\n - `include_type()` returns whether the value set by the `include_type` kwarg\n\n - `as_system(value)` returns a copy of the dependency object, which has changed\n   the value of `include_type` to `value`. The `value` argument is optional and\n   defaults to `'preserve'`.\n\n - `partial_dependency(compile_args : false, link_args : false, links\n   : false, includes : false, source : false)` *(Added 0.46.0)* returns\n   a new dependency object with the same name, version, found status,\n   type name, and methods as the object that called it. This new\n   object will only inherit other attributes from its parent as\n   controlled by keyword arguments.\n\n   If the parent has any dependencies, those will be applied to the new\n   partial dependency with the same rules. So , given:\n\n   ```meson\n   dep1 = declare_dependency(compile_args : '-Werror=foo', link_with : 'libfoo')\n   dep2 = declare_dependency(compile_args : '-Werror=bar', dependencies : dep1)\n   dep3 = dep2.partial_dependency(compile_args : true)\n   ```\n\n   dep3 will add `['-Werror=foo', '-Werror=bar']` to the compiler args\n   of any target it is added to, but libfoo will not be added to the\n   link_args.\n\n   *Note*: A bug present until 0.50.1 results in the above behavior\n   not working correctly.\n\n   The following arguments will add the following attributes:\n\n   - compile_args: any arguments passed to the compiler\n   - link_args: any arguments passed to the linker\n   - links: anything passed via link_with or link_whole\n   - includes: any include_directories\n   - sources: any compiled or static sources the dependency has\n\n - `get_variable(cmake : str, pkgconfig : str, configtool : str,\n   internal: str, default_value : str, pkgconfig_define : [str, str])`\n   *(Added in 0.51.0)* A generic variable getter method, which replaces the\n   get_*type*_variable methods. This allows one to get the variable\n   from a dependency without knowing specifically how that dependency\n   was found. If default_value is set and the value cannot be gotten\n   from the object then default_value is returned, if it is not set\n   then an error is raised.\n\n   *New in 0.54.0, the `internal` keyword*\n\n### `disabler` object\n\nA disabler object is an object that behaves in much the same way as\nNaN numbers do in floating point math. That is when used in any\nstatement (function call, logical op, etc) they will cause the\nstatement evaluation to immediately short circuit to return a disabler\nobject. A disabler object has one method:\n\n  - `found()`, always returns `false`\n\n### `external program` object\n\nThis object is returned by [`find_program()`](#find_program) and\ncontains an external (i.e. not built as part of this project) program\nand has the following methods:\n\n- `found()` which returns whether the executable was found\n\n- `path()` which returns a string pointing to the script or executable\n  **NOTE:** You should not need to use this method. Passing the object\n  itself should work in all cases. For example: `run_command(obj, arg1, arg2)`\n\n### `environment` object\n\nThis object is returned by [`environment()`](#environment) and stores\ndetailed information about how environment variables should be set\nduring tests. It should be passed as the `env` keyword argument to\ntests and other functions. It has the following methods.\n\n- `append(varname, value1, value2, ...)` appends the given values to\n  the old value of the environment variable, e.g.  `env.append('FOO',\n  'BAR', 'BAZ', separator : ';')` produces `BOB;BAR;BAZ` if `FOO` had\n  the value `BOB` and plain `BAR;BAZ` if the value was not defined. If\n  the separator is not specified explicitly, the default path\n  separator for the host operating system will be used, i.e. ';' for\n  Windows and ':' for UNIX/POSIX systems.\n\n- `prepend(varname, value1, value2, ...)` is the same as `append`\n  except that it writes to the beginning of the variable\n\n- `set(varname, value1, value2)` sets the environment variable\n  specified in the first argument to the values in the second argument\n  joined by the separator, e.g.  `env.set('FOO', 'BAR'),` sets envvar\n  `FOO` to value `BAR`. See `append()` above for how separators work.\n\n**Note:** All these methods overwrite the previously-defined value(s)\nif called twice with the same `varname`.\n\n### `external library` object\n\nThis object is returned by [`find_library()`](#find_library) and\ncontains an external (i.e. not built as part of this project)\nlibrary. This object has the following methods:\n\n - `found()` which returns whether the library was found.\n\n - `type_name()` *(added 0.48.0)* which returns a string describing\n   the type of the dependency, which will be `library` in this case.\n\n - `partial_dependency(compile_args : false, link_args : false, links\n   : false, includes : false, source : false)` *(Added 0.46.0)* returns\n   a new dependency object with the same name, version, found status,\n   type name, and methods as the object that called it. This new\n   object will only inherit other attributes from its parent as\n   controlled by keyword arguments.\n\n### Feature option object\n\nThe following methods are defined for all [`feature` options](Build-options.md#features):\n\n- `enabled()` returns whether the feature was set to `'enabled'`\n- `disabled()` returns whether the feature was set to `'disabled'`\n- `auto()` returns whether the feature was set to `'auto'`\n\nFeature options are available since 0.47.0.\n\n### `generator` object\n\nThis object is returned by [`generator()`](#generator) and contains a\ngenerator that is used to transform files from one type to another by\nan executable (e.g. `idl` files into source code and headers).\n\n* `process(list_of_files, ...)` takes a list of files, causes them to\n  be processed and returns an object containing the result which can\n  then, for example, be passed into a build target definition. The\n  keyword argument `extra_args`, if specified, will be used to replace\n  an entry `@EXTRA_ARGS@` in the argument list. The keyword argument\n  `preserve_path_from`, if given, specifies that the output files need\n  to maintain their directory structure inside the target temporary\n  directory. The most common value for this is\n  `meson.current_source_dir()`. With this value when a file called\n  `subdir/one.input` is processed it generates a file `<target private\n  directory>/subdir/one.out` as opposed to `<target private\n  directory>/one.out`.\n\n### `subproject` object\n\nThis object is returned by [`subproject()`](#subproject) and is an\nopaque object representing it.\n\n- `found()` *(added 0.48.0)* which returns whether the subproject was\n  successfully setup\n\n- `get_variable(name, fallback)` fetches the specified variable from\n  inside the subproject. This is useful to, for instance, get a\n  [declared dependency](#declare_dependency) from the\n  [subproject](Subprojects.md).\n\n  If the variable does not exist, the variable `fallback` is returned.\n  If a fallback is not specified, then attempting to read a non-existing\n  variable will cause a fatal error.\n\n### `run result` object\n\nThis object encapsulates the result of trying to compile and run a\nsample piece of code with [`compiler.run()`](#compiler-object) or\n[`run_command()`](#run_command). It has the following methods:\n\n- `compiled()` if true, the compilation succeeded, if false it did not\n  and the other methods return unspecified data. This is only available\n  for `compiler.run()` results.\n- `returncode()` the return code of executing the compiled binary\n- `stderr()` the standard error produced when the command was run\n- `stdout()` the standard out produced when the command was run\n",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/docs/markdown/IDE-integration.md": "---\nshort-description: Meson's API to integrate Meson support into an IDE\n...\n\n# IDE integration\n\nMeson has exporters for Visual Studio and XCode, but writing a custom backend\nfor every IDE out there is not a scalable approach. To solve this problem,\nMeson provides an API that makes it easy for any IDE or build tools to\nintegrate Meson builds and provide an experience comparable to a solution\nnative to the IDE.\n\nAll the resources required for such a IDE integration can be found in\nthe `meson-info` directory in the build directory.\n\nThe first thing to do when setting up a Meson project in an IDE is to select\nthe source and build directories. For this example we assume that the source\nresides in an Eclipse-like directory called `workspace/project` and the build\ntree is nested inside it as `workspace/project/build`. First, we initialize\nMeson by running the following command in the source directory.\n\n    meson builddir\n\nWith this command meson will configure the project and also generate\nintrospection information that is stored in `intro-*.json` files in the\n`meson-info` directory. The introspection dump will be automatically updated\nwhen meson is (re)configured, or the build options change. Thus, an IDE can\nwatch for changes in this directory to know when something changed.\n\nThe `meson-info` directory should contain the following files:\n\n| File                            | Description                                                         |\n| ----                            | -----------                                                         |\n| `intro-benchmarks.json`         | Lists all benchmarks                                                |\n| `intro-buildoptions.json`       | Contains a full list of meson configuration options for the project |\n| `intro-buildsystem_files.json`  | Full list of all meson build files                                  |\n| `intro-dependencies.json`       | Lists all dependencies used in the project                          |\n| `intro-installed.json`          | Contains mapping of files to their installed location               |\n| `intro-projectinfo.json`        | Stores basic information about the project (name, version, etc.)    |\n| `intro-targets.json`            | Full list of all build targets                                      |\n| `intro-tests.json`              | Lists all tests with instructions how to run them                   |\n\nThe content of the JSON files is further specified in the remainder of this document.\n\n## The `targets` section\n\nThe most important file for an IDE is probably `intro-targets.json`. Here each\ntarget with its sources and compiler parameters is specified. The JSON format\nfor one target is defined as follows:\n\n```json\n{\n    \"name\": \"Name of the target\",\n    \"id\": \"The internal ID meson uses\",\n    \"type\": \"<TYPE>\",\n    \"defined_in\": \"/Path/to/the/targets/meson.build\",\n    \"subproject\": null,\n    \"filename\": [\"list\", \"of\", \"generated\", \"files\"],\n    \"build_by_default\": true / false,\n    \"target_sources\": [],\n    \"installed\": true / false,\n}\n```\n\nIf the key `installed` is set to `true`, the key `install_filename` will also\nbe present. It stores the installation location for each file in `filename`.\nIf one file in `filename` is not installed, its corresponding install location\nis set to `null`.\n\nThe `subproject` key specifies the name of the subproject this target was\ndefined in, or `null` if the target was defined in the top level project.\n\nA target usually generates only one file. However, it is possible for custom\ntargets to have multiple outputs.\n\n### Target sources\n\nThe `intro-targets.json` file also stores a list of all source objects of the\ntarget in the `target_sources`. With this information, an IDE can provide code\ncompletion for all source files.\n\n```json\n{\n    \"language\": \"language ID\",\n    \"compiler\": [\"The\", \"compiler\", \"command\"],\n    \"parameters\": [\"list\", \"of\", \"compiler\", \"parameters\"],\n    \"sources\": [\"list\", \"of\", \"all\", \"source\", \"files\", \"for\", \"this\", \"language\"],\n    \"generated_sources\": [\"list\", \"of\", \"all\", \"source\", \"files\", \"that\", \"where\", \"generated\", \"somewhere\", \"else\"]\n}\n```\n\nIt should be noted that the compiler parameters stored in the `parameters`\ndiffer from the actual parameters used to compile the file. This is because\nthe parameters are optimized for the usage in an IDE to provide autocompletion\nsupport, etc. It is thus not recommended to use this introspection information\nfor actual compilation.\n\n### Possible values for `type`\n\nThe following table shows all valid types for a target.\n\n| value of `type`  | Description                                  |\n| ---------------  | -----------                                  |\n| `executable`     | This target will generate an executable file |\n| `static library` | Target for a static library                  |\n| `shared library` | Target for a shared library                  |\n| `shared module`  | A shared library that is meant to be used with dlopen rather than linking into something else |\n| `custom`         | A custom target                              |\n| `run`            | A Meson run target                           |\n| `jar`            | A Java JAR target                            |\n\n### Using `--targets` without a build directory\n\nIt is also possible to get most targets without a build directory. This can be\ndone by running `meson introspect --targets /path/to/meson.build`.\n\nThe generated output is similar to running the introspection with a build\ndirectory or reading the `intro-targets.json`. However, there are some key\ndifferences:\n\n- The paths in `filename` now are _relative_ to the future build directory\n- The `install_filename` key is completely missing\n- There is only one entry in `target_sources`:\n  - With the language set to `unknown`\n  - Empty lists for `compiler` and `parameters` and `generated_sources`\n  - The `sources` list _should_ contain all sources of the target\n\nThere is no guarantee that the sources list in `target_sources` is correct.\nThere might be differences, due to internal limitations. It is also not\nguaranteed that all targets will be listed in the output. It might even be\npossible that targets are listed, which won't exist when meson is run normally.\nThis can happen if a target is defined inside an if statement.\nUse this feature with care.\n\n## Build Options\n\nThe list of all build options (build type, warning level, etc.) is stored in\nthe `intro-buildoptions.json` file. Here is the JSON format for each option.\n\n```json\n{\n    \"name\": \"name of the option\",\n    \"description\": \"the description\",\n    \"type\": \"type ID\",\n    \"value\": \"value depends on type\",\n    \"section\": \"section ID\",\n    \"machine\": \"machine ID\"\n}\n```\n\nThe supported types are:\n\n - string\n - boolean\n - combo\n - integer\n - array\n\nFor the type `combo` the key `choices` is also present. Here all valid values\nfor the option are stored.\n\nThe possible values for `section` are:\n\n - core\n - backend\n - base\n - compiler\n - directory\n - user\n - test\n\nThe `machine` key specifies the machine configuration for the option. Possible\nvalues are:\n\n - any\n - host\n - build\n\nTo set the options, use the `meson configure` command.\n\nSince Meson 0.50.0 it is also possible to get the default buildoptions\nwithout a build directory by providing the root `meson.build` instead of a\nbuild directory to `meson introspect --buildoptions`.\n\nRunning `--buildoptions` without a build directory produces the same output as\nrunning it with a freshly configured build directory.\n\nHowever, this behavior is not guaranteed if subprojects are present. Due to\ninternal limitations all subprojects are processed even if they are never used\nin a real meson run. Because of this options for the subprojects can differ.\n\n## The dependencies section\n\nThe list of all _found_ dependencies can be acquired from\n`intro-dependencies.json`. Here, the name, version, compiler and linker\narguments for a dependency are listed.\n\n### Scanning for dependecie with `--scan-dependencies`\n\nIt is also possible to get most dependencies used without a build directory.\nThis can be done by running `meson introspect --scan-dependencies /path/to/meson.build`.\n\nThe output format is as follows:\n\n```json\n[\n  {\n    \"name\": \"The name of the dependency\",\n    \"required\": true,\n    \"version\": [\">=1.2.3\"],\n    \"conditional\": false,\n    \"has_fallback\": false\n  }\n]\n```\n\nThe `required` keyword specifies whether the dependency is marked as required\nin the `meson.build` (all dependencies are required by default). The\n`conditional` key indicates whether the `dependency()` function was called\ninside a conditional block. In a real meson run these dependencies might not be\nused, thus they _may_ not be required, even if the `required` key is set. The\n`has_fallback` key just indicates whether a fallback was directly set in the\n`dependency()` function. The `version` key always contains a list of version\nrequirements from the `meson.build` and **not** the actual version of the\ndependency on disc. The version list is empty if no version was specified\nin the `meson.build`.\n\n## Tests\n\nCompilation and unit tests are done as usual by running the `ninja` and\n`ninja test` commands. A JSON formatted result log can be found in\n`workspace/project/builddir/meson-logs/testlog.json`.\n\nWhen these tests fail, the user probably wants to run the failing test in a\ndebugger. To make this as integrated as possible, extract the tests from the\n`intro-tests.json` and `intro-benchmarks.json` files. This provides you with\nall the information needed to run the test: what command to execute, command\nline arguments, environment variable settings and how to process the output.\n\n```json\n{\n    \"name\": \"name of the test\",\n    \"workdir\": \"the working directory (can be null)\",\n    \"timeout\": \"the test timeout\",\n    \"suite\": [\"list\", \"of\", \"test\", \"suites\"],\n    \"is_parallel\": true / false,\n    \"protocol\": \"exitcode\" / \"tap\",\n    \"cmd\": [\"command\", \"to\", \"run\"],\n    \"env\": {\n        \"VARIABLE1\": \"value 1\",\n        \"VARIABLE2\": \"value 2\"\n    }\n}\n```\n\n# Programmatic interface\n\nMeson also provides the `meson introspect` for project introspection via the\ncommand line. Use `meson introspect -h` to see all available options.\n\nThis API can also work without a build directory for the `--projectinfo` command.\n\n# Existing integrations\n\n- [Gnome Builder](https://wiki.gnome.org/Apps/Builder)\n- [KDevelop](https://www.kdevelop.org)\n- [Eclipse CDT](https://www.eclipse.org/cdt/) (experimental)\n- [Meson Cmake Wrapper](https://github.com/prozum/meson-cmake-wrapper) (for cmake IDEs)\n- [Meson-UI](https://github.com/michaelbadcrumble/meson-ui) (Meson build GUI)\n- [Meson Syntax Highlighter](https://plugins.jetbrains.com/plugin/13269-meson-syntax-highlighter) plugin for JetBrains IDEs.\n",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/docs/markdown/Release-notes-for-0.37.0.md": "---\ntitle: Release 0.37\nshort-description: Release notes for 0.37\n...\n\n# New features\n\n## Mesontest\n\nMesontest is a new testing tool that allows you to run your tests in many different ways. As an example you can run tests multiple times:\n\n    mesontest --repeat=1000 a_test\n\nor with an arbitrary wrapper executable:\n\n    mesontest --wrap='valgrind --tool=helgrind' a_test\n\nor under `gdb`, 1000 times in a row. This is handy for tests that fail spuriously, as when the crash happens you are given the full GDB command line:\n\n    mesontest --repeat=1000 --gdb a_test\n\n## Mesonrewriter\n\nMesonrewriter is an experimental tool to manipulate your build definitions programmatically. It is not installed by default yet but those interested can run it from the source repository.\n\nAs an example, here is how you would add a source file to a build target:\n\n    mesonrewriter add --target=program --filename=new_source.c\n\n## Shared modules\n\nThe new `shared_module` function allows the creation of shared modules, that is, extension modules such as plugins that are meant to be used solely with `dlopen` rather than linking them to targets.\n\n## Gnome module\n\n- Detect required programs and print useful errors if missing\n\n### gtkdoc\n\n- Allow passing a list of directories to `src_dir` keyword argument\n- Add `namespace` keyword argument\n- Add `mode` keyword argument\n- Fix `gtkdoc-scangobj` finding local libraries\n\n### compile_resources\n\n- Add `gresource_bundle` keyword argument to output `.gresource` files\n- Add `export` and `install_header` keyword arguments\n- Use depfile support available in GLib >= 2.52.0\n\n## i18n module\n\n- Add `merge_file()` function for creating translated files\n- Add `preset` keyword argument to included common gettext flags\n- Read languages from `LINGUAS` file\n\n## LLVM IR compilation\n\nMeson has long had support for compiling assembler (GAS) files. In this release we add support for compiling LLVM IR files in a similar way when building with the Clang compiler. Just add it to the list of files when creating a `library` or `executable` target like any other source file. No special handling is required:\n\n```meson\nexecutable('some-exe', 'main.c', 'asm-file.S', 'ir-file.ll')\n```\n\nAs always, you can also mix LLVM IR files with C++, C, and Assembly (GAS) sources.\n\n## ViM indent and syntax files\n\nWe now include filetype, indent, and syntax files for ViM [with the source tree](https://github.com/mesonbuild/meson/tree/master/data/syntax-highlighting/vim). Please file issues (or pull requests!) for enhancements or if you face any problems using them.\n\n## Push URLs in .wrap files\n\n[.wrap files](Using-the-WrapDB.md) for subprojects can now include a separate push URL to allow developers to push changes directly from a subproject git checkout.\n\n## pkg-config dependencies\n\nMeson now supports multiple version restrictions while searching for pkg-config dependencies.\n\n```meson\n# Just want a lower limit\ndependency('zlib', version : '>1.2.1')\n# Want both a lower and an upper limit\ndependency('opencv', version : ['>=2.3.0', '<=3.1.0'])\n# Want to exclude one specific broken version\ndependency('foolite', version : ['>=3.12.1', '!=3.13.99'])\n```\n\n## Overriding more binaries with environment variables\n\nYou can now specify the binary to be used for the following tools by setting the corresponding environment variable\n\n| Name | Environment variable |\n| ---- | -------------------- |\n| pkg-config | PKG_CONFIG     |\n| readelf    | READELF        |\n| nm         | NM             |\n\n## Support for `localstatedir`\n\nSimilar to other options such as `bindir` and `datadir`, you can now specify the `localstatedir` for a project by passing `--localstatedir=dir` to `meson` or `-Dlocalstatedir=dir` to `mesonconf` after configuration. You can also access it from inside the `meson.build` file with `get_option('localstatedir')`.\n\n## New compiler function `symbols_have_underscore_prefix`\n\nChecks if the compiler prefixes an underscore to C global symbols with the default calling convention. This is useful when linking to compiled assembly code, or other code that does not have its C symbol mangling handled transparently by the compiler.\n\n```meson\ncc = meson.get_compiler('c')\nconf = configuration_data()\nif cc.symbols_have_underscore_prefix()\n    conf.set('SYMBOLS_HAVE_UNDERSCORE', true)\nendif\n```\n\nC symbol mangling is platform and architecture dependent, and a helper function is needed to detect it. For example, Windows 32-bit prefixes underscore, but 64-bit does not. Linux does not prefix an underscore but OS X does.\n\n## Vala\n\nGLib Resources compiled with [`gnome.compile_resources`](Gnome-module.md#compile_resources) that are added to the sources of a Vala build target will now cause the appropriate `--gresources` flag to be passed to the Vala compiler so you don't need to add that yourself to `vala_args:`.\n\n## Improvements to install scripts\n\nYou can now pass arguments to install scripts added with [`meson.add_install_script()`](Reference-manual.md#meson-object). All arguments after the script name will be passed to the script.\n\nThe `MESON_INSTALL_DESTDIR_PREFIX` environment variable is now set when install scripts are called. This contains the values of the `DESTDIR` environment variable and the `prefix` option passed to Meson joined together. This is useful because both those are usually absolute paths, and joining absolute paths in a cross-platform way is tricky. [`os.path.join` in Python](https://docs.python.org/3/library/os.path.html#os.path.join) will discard all previous path segments when it encounters an absolute path, and simply concatenating them will not work on Windows where absolute paths begin with the drive letter.\n\n## More install directories\n\nAdded new options `sbindir` and `infodir` that can be used for installation.\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/manual tests/4 standalone binaries/myapp.icns",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/manual tests/4 standalone binaries/template.dmg.gz",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/graphics/meson_logo_big.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/test cases/common/157 wrap file should not failed/subprojects/packagecache/zlib-1.2.8.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/test cases/common/157 wrap file should not failed/subprojects/packagecache/zlib-1.2.8-8-wrap.zip",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/test cases/common/157 wrap file should not failed/subprojects/packagecache/foo-1.0.tar.xz",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/test cases/common/157 wrap file should not failed/subprojects/packagecache/foo-1.0-patch.tar.xz",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/test cases/common/14 configure file/invalid-utf8.bin.in",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/test cases/common/14 configure file/config8.h.in",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/test cases/windows/14 resources with custom target depend_files/ico/sample.ico.in",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/test cases/windows/5 resources/res/sample.ico",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/test cases/windows/12 resources with custom targets/res/sample.ico",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/test cases/osx/4 framework/xcode-frameworks.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/test cases/unit/73 wrap file url/subprojects/foo-patch.tar.xz",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/test cases/unit/73 wrap file url/subprojects/foo.tar.xz",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/test cases/frameworks/4 qt/thing.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/test cases/frameworks/4 qt/thing2.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/test cases/frameworks/4 qt/subfolder/resources/thing.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/docs/markdown/images/py3-install-3.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/docs/markdown/images/py3-install-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/docs/markdown/images/glib_empty.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/docs/markdown/images/buildtime.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/docs/markdown/images/glib_build.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/docs/markdown/images/gtksample.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/docs/markdown/images/conftime.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/docs/markdown/images/glib_conf.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/docs/markdown/images/emptytime.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/docs/markdown/images/py3-install-1.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/docs/markdown/images/glib_link.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/docs/theme/extra/images/meson_logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-meson-0.54.3-jwq6malndfsvhzxwhrgjw4cqkneavxos/spack-src/docs/theme/extra/images/favicon.png"
    ],
    "total_files": 3145
}