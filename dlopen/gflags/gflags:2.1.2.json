{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-gflags-2.1.2-rtccrkwrphtuglsueo7x2p7ehb6iqs7s/spack-src/src/gflags.cc": "// Copyright (c) 1999, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// ---\n// Revamped and reorganized by Craig Silverstein\n//\n// This file contains the implementation of all our command line flags\n// stuff.  Here's how everything fits together\n//\n// * FlagRegistry owns CommandLineFlags owns FlagValue.\n// * FlagSaver holds a FlagRegistry (saves it at construct time,\n//     restores it at destroy time).\n// * CommandLineFlagParser lives outside that hierarchy, but works on\n//     CommandLineFlags (modifying the FlagValues).\n// * Free functions like SetCommandLineOption() work via one of the\n//     above (such as CommandLineFlagParser).\n//\n// In more detail:\n//\n// -- The main classes that hold flag data:\n//\n// FlagValue holds the current value of a flag.  It's\n// pseudo-templatized: every operation on a FlagValue is typed.  It\n// also deals with storage-lifetime issues (so flag values don't go\n// away in a destructor), which is why we need a whole class to hold a\n// variable's value.\n//\n// CommandLineFlag is all the information about a single command-line\n// flag.  It has a FlagValue for the flag's current value, but also\n// the flag's name, type, etc.\n//\n// FlagRegistry is a collection of CommandLineFlags.  There's the\n// global registry, which is where flags defined via DEFINE_foo()\n// live.  But it's possible to define your own flag, manually, in a\n// different registry you create.  (In practice, multiple registries\n// are used only by FlagSaver).\n//\n// A given FlagValue is owned by exactly one CommandLineFlag.  A given\n// CommandLineFlag is owned by exactly one FlagRegistry.  FlagRegistry\n// has a lock; any operation that writes to a FlagValue or\n// CommandLineFlag owned by that registry must acquire the\n// FlagRegistry lock before doing so.\n//\n// --- Some other classes and free functions:\n//\n// CommandLineFlagInfo is a client-exposed version of CommandLineFlag.\n// Once it's instantiated, it has no dependencies or relationships\n// with any other part of this file.\n//\n// FlagRegisterer is the helper class used by the DEFINE_* macros to\n// allow work to be done at global initialization time.\n//\n// CommandLineFlagParser is the class that reads from the commandline\n// and instantiates flag values based on that.  It needs to poke into\n// the innards of the FlagValue->CommandLineFlag->FlagRegistry class\n// hierarchy to do that.  It's careful to acquire the FlagRegistry\n// lock before doing any writing or other non-const actions.\n//\n// GetCommandLineOption is just a hook into registry routines to\n// retrieve a flag based on its name.  SetCommandLineOption, on the\n// other hand, hooks into CommandLineFlagParser.  Other API functions\n// are, similarly, mostly hooks into the functionality described above.\n\n#include \"config.h\"\n#include \"gflags.h\"\n\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#if defined(HAVE_FNMATCH_H)\n#  include <fnmatch.h>\n#elif defined(HAVE_SHLWAPI_H)\n#  include <shlwapi.h>\n#endif\n#include <stdarg.h> // For va_list and related operations\n#include <stdio.h>\n#include <string.h>\n\n#include <algorithm>\n#include <map>\n#include <string>\n#include <utility>     // for pair<>\n#include <vector>\n\n#include \"mutex.h\"\n#include \"util.h\"\n\n// Special flags, type 1: the 'recursive' flags.  They set another flag's val.\nDEFINE_string(flagfile,   \"\", \"load flags from file\");\nDEFINE_string(fromenv,    \"\", \"set flags from the environment\"\n                              \" [use 'export FLAGS_flag1=value']\");\nDEFINE_string(tryfromenv, \"\", \"set flags from the environment if present\");\n\n// Special flags, type 2: the 'parsing' flags.  They modify how we parse.\nDEFINE_string(undefok, \"\", \"comma-separated list of flag names that it is okay to specify \"\n                           \"on the command line even if the program does not define a flag \"\n                           \"with that name.  IMPORTANT: flags in this list that have \"\n                           \"arguments MUST use the flag=value format\");\n\nnamespace GFLAGS_NAMESPACE {\n\nusing std::map;\nusing std::pair;\nusing std::sort;\nusing std::string;\nusing std::vector;\n\n// This is used by the unittest to test error-exit code\nvoid GFLAGS_DLL_DECL (*gflags_exitfunc)(int) = &exit;  // from stdlib.h\n\n\n// The help message indicating that the commandline flag has been\n// 'stripped'. It will not show up when doing \"-help\" and its\n// variants. The flag is stripped if STRIP_FLAG_HELP is set to 1\n// before including base/gflags.h\n\n// This is used by this file, and also in gflags_reporting.cc\nconst char kStrippedFlagHelp[] = \"\\001\\002\\003\\004 (unknown) \\004\\003\\002\\001\";\n\nnamespace {\n\n// There are also 'reporting' flags, in gflags_reporting.cc.\n\nstatic const char kError[] = \"ERROR: \";\n\n// Indicates that undefined options are to be ignored.\n// Enables deferred processing of flags in dynamically loaded libraries.\nstatic bool allow_command_line_reparsing = false;\n\nstatic bool logging_is_probably_set_up = false;\n\n// This is a 'prototype' validate-function.  'Real' validate\n// functions, take a flag-value as an argument: ValidateFn(bool) or\n// ValidateFn(uint64).  However, for easier storage, we strip off this\n// argument and then restore it when actually calling the function on\n// a flag value.\ntypedef bool (*ValidateFnProto)();\n\n// Whether we should die when reporting an error.\nenum DieWhenReporting { DIE, DO_NOT_DIE };\n\n// Report Error and exit if requested.\nstatic void ReportError(DieWhenReporting should_die, const char* format, ...) {\n  char error_message[255];\n  va_list ap;\n  va_start(ap, format);\n  vsnprintf(error_message, sizeof(error_message), format, ap);\n  va_end(ap);\n  fprintf(stderr, \"%s\", error_message);\n  fflush(stderr);   // should be unnecessary, but cygwin's rxvt buffers stderr\n  if (should_die == DIE) gflags_exitfunc(1);\n}\n\n\n// --------------------------------------------------------------------\n// FlagValue\n//    This represent the value a single flag might have.  The major\n//    functionality is to convert from a string to an object of a\n//    given type, and back.  Thread-compatible.\n// --------------------------------------------------------------------\n\nclass CommandLineFlag;\nclass FlagValue {\n public:\n  FlagValue(void* valbuf, const char* type, bool transfer_ownership_of_value);\n  ~FlagValue();\n\n  bool ParseFrom(const char* spec);\n  string ToString() const;\n\n private:\n  friend class CommandLineFlag;  // for many things, including Validate()\n  friend class GFLAGS_NAMESPACE::FlagSaverImpl;  // calls New()\n  friend class FlagRegistry;     // checks value_buffer_ for flags_by_ptr_ map\n  template <typename T> friend T GetFromEnv(const char*, const char*, T);\n  friend bool TryParseLocked(const CommandLineFlag*, FlagValue*,\n                             const char*, string*);  // for New(), CopyFrom()\n\n  enum ValueType {\n    FV_BOOL = 0,\n    FV_INT32 = 1,\n    FV_INT64 = 2,\n    FV_UINT64 = 3,\n    FV_DOUBLE = 4,\n    FV_STRING = 5,\n    FV_MAX_INDEX = 5,\n  };\n  const char* TypeName() const;\n  bool Equal(const FlagValue& x) const;\n  FlagValue* New() const;   // creates a new one with default value\n  void CopyFrom(const FlagValue& x);\n  int ValueSize() const;\n\n  // Calls the given validate-fn on value_buffer_, and returns\n  // whatever it returns.  But first casts validate_fn_proto to a\n  // function that takes our value as an argument (eg void\n  // (*validate_fn)(bool) for a bool flag).\n  bool Validate(const char* flagname, ValidateFnProto validate_fn_proto) const;\n\n  void* value_buffer_;          // points to the buffer holding our data\n  int8 type_;                   // how to interpret value_\n  bool owns_value_;         // whether to free value on destruct\n\n  FlagValue(const FlagValue&);   // no copying!\n  void operator=(const FlagValue&);\n};\n\n\n// This could be a templated method of FlagValue, but doing so adds to the\n// size of the .o.  Since there's no type-safety here anyway, macro is ok.\n#define VALUE_AS(type)  *reinterpret_cast<type*>(value_buffer_)\n#define OTHER_VALUE_AS(fv, type)  *reinterpret_cast<type*>(fv.value_buffer_)\n#define SET_VALUE_AS(type, value)  VALUE_AS(type) = (value)\n\nFlagValue::FlagValue(void* valbuf, const char* type,\n                     bool transfer_ownership_of_value)\n    : value_buffer_(valbuf),\n      owns_value_(transfer_ownership_of_value) {\n  for (type_ = 0; type_ <= FV_MAX_INDEX; ++type_) {\n    if (!strcmp(type, TypeName())) {\n      break;\n    }\n  }\n  assert(type_ <= FV_MAX_INDEX);  // Unknown typename\n}\n\nFlagValue::~FlagValue() {\n  if (!owns_value_) {\n    return;\n  }\n  switch (type_) {\n    case FV_BOOL: delete reinterpret_cast<bool*>(value_buffer_); break;\n    case FV_INT32: delete reinterpret_cast<int32*>(value_buffer_); break;\n    case FV_INT64: delete reinterpret_cast<int64*>(value_buffer_); break;\n    case FV_UINT64: delete reinterpret_cast<uint64*>(value_buffer_); break;\n    case FV_DOUBLE: delete reinterpret_cast<double*>(value_buffer_); break;\n    case FV_STRING: delete reinterpret_cast<string*>(value_buffer_); break;\n  }\n}\n\nbool FlagValue::ParseFrom(const char* value) {\n  if (type_ == FV_BOOL) {\n    const char* kTrue[] = { \"1\", \"t\", \"true\", \"y\", \"yes\" };\n    const char* kFalse[] = { \"0\", \"f\", \"false\", \"n\", \"no\" };\n    COMPILE_ASSERT(sizeof(kTrue) == sizeof(kFalse), true_false_equal);\n    for (size_t i = 0; i < sizeof(kTrue)/sizeof(*kTrue); ++i) {\n      if (strcasecmp(value, kTrue[i]) == 0) {\n        SET_VALUE_AS(bool, true);\n        return true;\n      } else if (strcasecmp(value, kFalse[i]) == 0) {\n        SET_VALUE_AS(bool, false);\n        return true;\n      }\n    }\n    return false;   // didn't match a legal input\n\n  } else if (type_ == FV_STRING) {\n    SET_VALUE_AS(string, value);\n    return true;\n  }\n\n  // OK, it's likely to be numeric, and we'll be using a strtoXXX method.\n  if (value[0] == '\\0')   // empty-string is only allowed for string type.\n    return false;\n  char* end;\n  // Leading 0x puts us in base 16.  But leading 0 does not put us in base 8!\n  // It caused too many bugs when we had that behavior.\n  int base = 10;    // by default\n  if (value[0] == '0' && (value[1] == 'x' || value[1] == 'X'))\n    base = 16;\n  errno = 0;\n\n  switch (type_) {\n    case FV_INT32: {\n      const int64 r = strto64(value, &end, base);\n      if (errno || end != value + strlen(value))  return false;  // bad parse\n      if (static_cast<int32>(r) != r)  // worked, but number out of range\n        return false;\n      SET_VALUE_AS(int32, static_cast<int32>(r));\n      return true;\n    }\n    case FV_INT64: {\n      const int64 r = strto64(value, &end, base);\n      if (errno || end != value + strlen(value))  return false;  // bad parse\n      SET_VALUE_AS(int64, r);\n      return true;\n    }\n    case FV_UINT64: {\n      while (*value == ' ') value++;\n      if (*value == '-') return false;  // negative number\n      const uint64 r = strtou64(value, &end, base);\n      if (errno || end != value + strlen(value))  return false;  // bad parse\n      SET_VALUE_AS(uint64, r);\n      return true;\n    }\n    case FV_DOUBLE: {\n      const double r = strtod(value, &end);\n      if (errno || end != value + strlen(value))  return false;  // bad parse\n      SET_VALUE_AS(double, r);\n      return true;\n    }\n    default: {\n      assert(false);  // unknown type\n      return false;\n    }\n  }\n}\n\nstring FlagValue::ToString() const {\n  char intbuf[64];    // enough to hold even the biggest number\n  switch (type_) {\n    case FV_BOOL:\n      return VALUE_AS(bool) ? \"true\" : \"false\";\n    case FV_INT32:\n      snprintf(intbuf, sizeof(intbuf), \"%\" PRId32, VALUE_AS(int32));\n      return intbuf;\n    case FV_INT64:\n      snprintf(intbuf, sizeof(intbuf), \"%\" PRId64, VALUE_AS(int64));\n      return intbuf;\n    case FV_UINT64:\n      snprintf(intbuf, sizeof(intbuf), \"%\" PRIu64, VALUE_AS(uint64));\n      return intbuf;\n    case FV_DOUBLE:\n      snprintf(intbuf, sizeof(intbuf), \"%.17g\", VALUE_AS(double));\n      return intbuf;\n    case FV_STRING:\n      return VALUE_AS(string);\n    default:\n      assert(false);\n      return \"\";  // unknown type\n  }\n}\n\nbool FlagValue::Validate(const char* flagname,\n                         ValidateFnProto validate_fn_proto) const {\n  switch (type_) {\n    case FV_BOOL:\n      return reinterpret_cast<bool (*)(const char*, bool)>(\n          validate_fn_proto)(flagname, VALUE_AS(bool));\n    case FV_INT32:\n      return reinterpret_cast<bool (*)(const char*, int32)>(\n          validate_fn_proto)(flagname, VALUE_AS(int32));\n    case FV_INT64:\n      return reinterpret_cast<bool (*)(const char*, int64)>(\n          validate_fn_proto)(flagname, VALUE_AS(int64));\n    case FV_UINT64:\n      return reinterpret_cast<bool (*)(const char*, uint64)>(\n          validate_fn_proto)(flagname, VALUE_AS(uint64));\n    case FV_DOUBLE:\n      return reinterpret_cast<bool (*)(const char*, double)>(\n          validate_fn_proto)(flagname, VALUE_AS(double));\n    case FV_STRING:\n      return reinterpret_cast<bool (*)(const char*, const string&)>(\n          validate_fn_proto)(flagname, VALUE_AS(string));\n    default:\n      assert(false);  // unknown type\n      return false;\n  }\n}\n\nconst char* FlagValue::TypeName() const {\n  static const char types[] =\n      \"bool\\0xx\"\n      \"int32\\0x\"\n      \"int64\\0x\"\n      \"uint64\\0\"\n      \"double\\0\"\n      \"string\";\n  if (type_ > FV_MAX_INDEX) {\n    assert(false);\n    return \"\";\n  }\n  // Directly indexing the strings in the 'types' string, each of them is 7 bytes long.\n  return &types[type_ * 7];\n}\n\nbool FlagValue::Equal(const FlagValue& x) const {\n  if (type_ != x.type_)\n    return false;\n  switch (type_) {\n    case FV_BOOL:   return VALUE_AS(bool) == OTHER_VALUE_AS(x, bool);\n    case FV_INT32:  return VALUE_AS(int32) == OTHER_VALUE_AS(x, int32);\n    case FV_INT64:  return VALUE_AS(int64) == OTHER_VALUE_AS(x, int64);\n    case FV_UINT64: return VALUE_AS(uint64) == OTHER_VALUE_AS(x, uint64);\n    case FV_DOUBLE: return VALUE_AS(double) == OTHER_VALUE_AS(x, double);\n    case FV_STRING: return VALUE_AS(string) == OTHER_VALUE_AS(x, string);\n    default: assert(false); return false;  // unknown type\n  }\n}\n\nFlagValue* FlagValue::New() const {\n  const char *type = TypeName();\n  switch (type_) {\n    case FV_BOOL:   return new FlagValue(new bool(false), type, true);\n    case FV_INT32:  return new FlagValue(new int32(0), type, true);\n    case FV_INT64:  return new FlagValue(new int64(0), type, true);\n    case FV_UINT64: return new FlagValue(new uint64(0), type, true);\n    case FV_DOUBLE: return new FlagValue(new double(0.0), type, true);\n    case FV_STRING: return new FlagValue(new string, type, true);\n    default: assert(false); return NULL;  // unknown type\n  }\n}\n\nvoid FlagValue::CopyFrom(const FlagValue& x) {\n  assert(type_ == x.type_);\n  switch (type_) {\n    case FV_BOOL:   SET_VALUE_AS(bool, OTHER_VALUE_AS(x, bool));      break;\n    case FV_INT32:  SET_VALUE_AS(int32, OTHER_VALUE_AS(x, int32));    break;\n    case FV_INT64:  SET_VALUE_AS(int64, OTHER_VALUE_AS(x, int64));    break;\n    case FV_UINT64: SET_VALUE_AS(uint64, OTHER_VALUE_AS(x, uint64));  break;\n    case FV_DOUBLE: SET_VALUE_AS(double, OTHER_VALUE_AS(x, double));  break;\n    case FV_STRING: SET_VALUE_AS(string, OTHER_VALUE_AS(x, string));  break;\n    default: assert(false);  // unknown type\n  }\n}\n\nint FlagValue::ValueSize() const {\n  if (type_ > FV_MAX_INDEX) {\n    assert(false);  // unknown type\n    return 0;\n  }\n  static const uint8 valuesize[] = {\n    sizeof(bool),\n    sizeof(int32),\n    sizeof(int64),\n    sizeof(uint64),\n    sizeof(double),\n    sizeof(string),\n  };\n  return valuesize[type_];\n}\n\n// --------------------------------------------------------------------\n// CommandLineFlag\n//    This represents a single flag, including its name, description,\n//    default value, and current value.  Mostly this serves as a\n//    struct, though it also knows how to register itself.\n//       All CommandLineFlags are owned by a (exactly one)\n//    FlagRegistry.  If you wish to modify fields in this class, you\n//    should acquire the FlagRegistry lock for the registry that owns\n//    this flag.\n// --------------------------------------------------------------------\n\nclass CommandLineFlag {\n public:\n  // Note: we take over memory-ownership of current_val and default_val.\n  CommandLineFlag(const char* name, const char* help, const char* filename,\n                  FlagValue* current_val, FlagValue* default_val);\n  ~CommandLineFlag();\n\n  const char* name() const { return name_; }\n  const char* help() const { return help_; }\n  const char* filename() const { return file_; }\n  const char* CleanFileName() const;  // nixes irrelevant prefix such as homedir\n  string current_value() const { return current_->ToString(); }\n  string default_value() const { return defvalue_->ToString(); }\n  const char* type_name() const { return defvalue_->TypeName(); }\n  ValidateFnProto validate_function() const { return validate_fn_proto_; }\n  const void* flag_ptr() const { return current_->value_buffer_; }\n\n  void FillCommandLineFlagInfo(struct CommandLineFlagInfo* result);\n\n  // If validate_fn_proto_ is non-NULL, calls it on value, returns result.\n  bool Validate(const FlagValue& value) const;\n  bool ValidateCurrent() const { return Validate(*current_); }\n\n private:\n  // for SetFlagLocked() and setting flags_by_ptr_\n  friend class FlagRegistry;\n  friend class GFLAGS_NAMESPACE::FlagSaverImpl;  // for cloning the values\n  // set validate_fn\n  friend bool AddFlagValidator(const void*, ValidateFnProto);\n\n  // This copies all the non-const members: modified, processed, defvalue, etc.\n  void CopyFrom(const CommandLineFlag& src);\n\n  void UpdateModifiedBit();\n\n  const char* const name_;     // Flag name\n  const char* const help_;     // Help message\n  const char* const file_;     // Which file did this come from?\n  bool modified_;              // Set after default assignment?\n  FlagValue* defvalue_;        // Default value for flag\n  FlagValue* current_;         // Current value for flag\n  // This is a casted, 'generic' version of validate_fn, which actually\n  // takes a flag-value as an arg (void (*validate_fn)(bool), say).\n  // When we pass this to current_->Validate(), it will cast it back to\n  // the proper type.  This may be NULL to mean we have no validate_fn.\n  ValidateFnProto validate_fn_proto_;\n\n  CommandLineFlag(const CommandLineFlag&);   // no copying!\n  void operator=(const CommandLineFlag&);\n};\n\nCommandLineFlag::CommandLineFlag(const char* name, const char* help,\n                                 const char* filename,\n                                 FlagValue* current_val, FlagValue* default_val)\n    : name_(name), help_(help), file_(filename), modified_(false),\n      defvalue_(default_val), current_(current_val), validate_fn_proto_(NULL) {\n}\n\nCommandLineFlag::~CommandLineFlag() {\n  delete current_;\n  delete defvalue_;\n}\n\nconst char* CommandLineFlag::CleanFileName() const {\n  // Compute top-level directory & file that this appears in\n  // search full path backwards.\n  // Stop going backwards at kRootDir; and skip by the first slash.\n  static const char kRootDir[] = \"\";    // can set this to root directory,\n\n  if (sizeof(kRootDir)-1 == 0)          // no prefix to strip\n    return filename();\n\n  const char* clean_name = filename() + strlen(filename()) - 1;\n  while ( clean_name > filename() ) {\n    if (*clean_name == PATH_SEPARATOR) {\n      if (strncmp(clean_name, kRootDir, sizeof(kRootDir)-1) == 0) {\n        clean_name += sizeof(kRootDir)-1;    // past root-dir\n        break;\n      }\n    }\n    --clean_name;\n  }\n  while ( *clean_name == PATH_SEPARATOR ) ++clean_name;  // Skip any slashes\n  return clean_name;\n}\n\nvoid CommandLineFlag::FillCommandLineFlagInfo(\n    CommandLineFlagInfo* result) {\n  result->name = name();\n  result->type = type_name();\n  result->description = help();\n  result->current_value = current_value();\n  result->default_value = default_value();\n  result->filename = CleanFileName();\n  UpdateModifiedBit();\n  result->is_default = !modified_;\n  result->has_validator_fn = validate_function() != NULL;\n  result->flag_ptr = flag_ptr();\n}\n\nvoid CommandLineFlag::UpdateModifiedBit() {\n  // Update the \"modified\" bit in case somebody bypassed the\n  // Flags API and wrote directly through the FLAGS_name variable.\n  if (!modified_ && !current_->Equal(*defvalue_)) {\n    modified_ = true;\n  }\n}\n\nvoid CommandLineFlag::CopyFrom(const CommandLineFlag& src) {\n  // Note we only copy the non-const members; others are fixed at construct time\n  if (modified_ != src.modified_) modified_ = src.modified_;\n  if (!current_->Equal(*src.current_)) current_->CopyFrom(*src.current_);\n  if (!defvalue_->Equal(*src.defvalue_)) defvalue_->CopyFrom(*src.defvalue_);\n  if (validate_fn_proto_ != src.validate_fn_proto_)\n    validate_fn_proto_ = src.validate_fn_proto_;\n}\n\nbool CommandLineFlag::Validate(const FlagValue& value) const {\n\n  if (validate_function() == NULL)\n    return true;\n  else\n    return value.Validate(name(), validate_function());\n}\n\n\n// --------------------------------------------------------------------\n// FlagRegistry\n//    A FlagRegistry singleton object holds all flag objects indexed\n//    by their names so that if you know a flag's name (as a C\n//    string), you can access or set it.  If the function is named\n//    FooLocked(), you must own the registry lock before calling\n//    the function; otherwise, you should *not* hold the lock, and\n//    the function will acquire it itself if needed.\n// --------------------------------------------------------------------\n\nstruct StringCmp {  // Used by the FlagRegistry map class to compare char*'s\n  bool operator() (const char* s1, const char* s2) const {\n    return (strcmp(s1, s2) < 0);\n  }\n};\n\n\nclass FlagRegistry {\n public:\n  FlagRegistry() {\n  }\n  ~FlagRegistry() {\n    // Not using STLDeleteElements as that resides in util and this\n    // class is base.\n    for (FlagMap::iterator p = flags_.begin(), e = flags_.end(); p != e; ++p) {\n      CommandLineFlag* flag = p->second;\n      delete flag;\n    }\n  }\n\n  static void DeleteGlobalRegistry() {\n    delete global_registry_;\n    global_registry_ = NULL;\n  }\n\n  // Store a flag in this registry.  Takes ownership of the given pointer.\n  void RegisterFlag(CommandLineFlag* flag);\n\n  void Lock() { lock_.Lock(); }\n  void Unlock() { lock_.Unlock(); }\n\n  // Returns the flag object for the specified name, or NULL if not found.\n  CommandLineFlag* FindFlagLocked(const char* name);\n\n  // Returns the flag object whose current-value is stored at flag_ptr.\n  // That is, for whom current_->value_buffer_ == flag_ptr\n  CommandLineFlag* FindFlagViaPtrLocked(const void* flag_ptr);\n\n  // A fancier form of FindFlag that works correctly if name is of the\n  // form flag=value.  In that case, we set key to point to flag, and\n  // modify v to point to the value (if present), and return the flag\n  // with the given name.  If the flag does not exist, returns NULL\n  // and sets error_message.\n  CommandLineFlag* SplitArgumentLocked(const char* argument,\n                                       string* key, const char** v,\n                                       string* error_message);\n\n  // Set the value of a flag.  If the flag was successfully set to\n  // value, set msg to indicate the new flag-value, and return true.\n  // Otherwise, set msg to indicate the error, leave flag unchanged,\n  // and return false.  msg can be NULL.\n  bool SetFlagLocked(CommandLineFlag* flag, const char* value,\n                     FlagSettingMode set_mode, string* msg);\n\n  static FlagRegistry* GlobalRegistry();   // returns a singleton registry\n\n private:\n  friend class GFLAGS_NAMESPACE::FlagSaverImpl;  // reads all the flags in order to copy them\n  friend class CommandLineFlagParser;    // for ValidateAllFlags\n  friend void GFLAGS_NAMESPACE::GetAllFlags(vector<CommandLineFlagInfo>*);\n\n  // The map from name to flag, for FindFlagLocked().\n  typedef map<const char*, CommandLineFlag*, StringCmp> FlagMap;\n  typedef FlagMap::iterator FlagIterator;\n  typedef FlagMap::const_iterator FlagConstIterator;\n  FlagMap flags_;\n\n  // The map from current-value pointer to flag, fo FindFlagViaPtrLocked().\n  typedef map<const void*, CommandLineFlag*> FlagPtrMap;\n  FlagPtrMap flags_by_ptr_;\n\n  static FlagRegistry* global_registry_;   // a singleton registry\n\n  Mutex lock_;\n  static Mutex global_registry_lock_;\n\n  static void InitGlobalRegistry();\n\n  // Disallow\n  FlagRegistry(const FlagRegistry&);\n  FlagRegistry& operator=(const FlagRegistry&);\n};\n\nclass FlagRegistryLock {\n public:\n  explicit FlagRegistryLock(FlagRegistry* fr) : fr_(fr) { fr_->Lock(); }\n  ~FlagRegistryLock() { fr_->Unlock(); }\n private:\n  FlagRegistry *const fr_;\n};\n\n\nvoid FlagRegistry::RegisterFlag(CommandLineFlag* flag) {\n  Lock();\n  pair<FlagIterator, bool> ins =\n    flags_.insert(pair<const char*, CommandLineFlag*>(flag->name(), flag));\n  if (ins.second == false) {   // means the name was already in the map\n    if (strcmp(ins.first->second->filename(), flag->filename()) != 0) {\n      ReportError(DIE, \"ERROR: flag '%s' was defined more than once \"\n                  \"(in files '%s' and '%s').\\n\",\n                  flag->name(),\n                  ins.first->second->filename(),\n                  flag->filename());\n    } else {\n      ReportError(DIE, \"ERROR: something wrong with flag '%s' in file '%s'.  \"\n                  \"One possibility: file '%s' is being linked both statically \"\n                  \"and dynamically into this executable.\\n\",\n                  flag->name(),\n                  flag->filename(), flag->filename());\n    }\n  }\n  // Also add to the flags_by_ptr_ map.\n  flags_by_ptr_[flag->current_->value_buffer_] = flag;\n  Unlock();\n}\n\nCommandLineFlag* FlagRegistry::FindFlagLocked(const char* name) {\n  FlagConstIterator i = flags_.find(name);\n  if (i == flags_.end()) {\n    return NULL;\n  } else {\n    return i->second;\n  }\n}\n\nCommandLineFlag* FlagRegistry::FindFlagViaPtrLocked(const void* flag_ptr) {\n  FlagPtrMap::const_iterator i = flags_by_ptr_.find(flag_ptr);\n  if (i == flags_by_ptr_.end()) {\n    return NULL;\n  } else {\n    return i->second;\n  }\n}\n\nCommandLineFlag* FlagRegistry::SplitArgumentLocked(const char* arg,\n                                                   string* key,\n                                                   const char** v,\n                                                   string* error_message) {\n  // Find the flag object for this option\n  const char* flag_name;\n  const char* value = strchr(arg, '=');\n  if (value == NULL) {\n    key->assign(arg);\n    *v = NULL;\n  } else {\n    // Strip out the \"=value\" portion from arg\n    key->assign(arg, value-arg);\n    *v = ++value;    // advance past the '='\n  }\n  flag_name = key->c_str();\n\n  CommandLineFlag* flag = FindFlagLocked(flag_name);\n\n  if (flag == NULL) {\n    // If we can't find the flag-name, then we should return an error.\n    // The one exception is if 1) the flag-name is 'nox', 2) there\n    // exists a flag named 'x', and 3) 'x' is a boolean flag.\n    // In that case, we want to return flag 'x'.\n    if (!(flag_name[0] == 'n' && flag_name[1] == 'o')) {\n      // flag-name is not 'nox', so we're not in the exception case.\n      *error_message = StringPrintf(\"%sunknown command line flag '%s'\\n\",\n                                    kError, key->c_str());\n      return NULL;\n    }\n    flag = FindFlagLocked(flag_name+2);\n    if (flag == NULL) {\n      // No flag named 'x' exists, so we're not in the exception case.\n      *error_message = StringPrintf(\"%sunknown command line flag '%s'\\n\",\n                                    kError, key->c_str());\n      return NULL;\n    }\n    if (strcmp(flag->type_name(), \"bool\") != 0) {\n      // 'x' exists but is not boolean, so we're not in the exception case.\n      *error_message = StringPrintf(\n          \"%sboolean value (%s) specified for %s command line flag\\n\",\n          kError, key->c_str(), flag->type_name());\n      return NULL;\n    }\n    // We're in the exception case!\n    // Make up a fake value to replace the \"no\" we stripped out\n    key->assign(flag_name+2);   // the name without the \"no\"\n    *v = \"0\";\n  }\n\n  // Assign a value if this is a boolean flag\n  if (*v == NULL && strcmp(flag->type_name(), \"bool\") == 0) {\n    *v = \"1\";    // the --nox case was already handled, so this is the --x case\n  }\n\n  return flag;\n}\n\nbool TryParseLocked(const CommandLineFlag* flag, FlagValue* flag_value,\n                    const char* value, string* msg) {\n  // Use tenative_value, not flag_value, until we know value is valid.\n  FlagValue* tentative_value = flag_value->New();\n  if (!tentative_value->ParseFrom(value)) {\n    if (msg) {\n      StringAppendF(msg,\n                    \"%sillegal value '%s' specified for %s flag '%s'\\n\",\n                    kError, value,\n                    flag->type_name(), flag->name());\n    }\n    delete tentative_value;\n    return false;\n  } else if (!flag->Validate(*tentative_value)) {\n    if (msg) {\n      StringAppendF(msg,\n          \"%sfailed validation of new value '%s' for flag '%s'\\n\",\n          kError, tentative_value->ToString().c_str(),\n          flag->name());\n    }\n    delete tentative_value;\n    return false;\n  } else {\n    flag_value->CopyFrom(*tentative_value);\n    if (msg) {\n      StringAppendF(msg, \"%s set to %s\\n\",\n                    flag->name(), flag_value->ToString().c_str());\n    }\n    delete tentative_value;\n    return true;\n  }\n}\n\nbool FlagRegistry::SetFlagLocked(CommandLineFlag* flag,\n                                 const char* value,\n                                 FlagSettingMode set_mode,\n                                 string* msg) {\n  flag->UpdateModifiedBit();\n  switch (set_mode) {\n    case SET_FLAGS_VALUE: {\n      // set or modify the flag's value\n      if (!TryParseLocked(flag, flag->current_, value, msg))\n        return false;\n      flag->modified_ = true;\n      break;\n    }\n    case SET_FLAG_IF_DEFAULT: {\n      // set the flag's value, but only if it hasn't been set by someone else\n      if (!flag->modified_) {\n        if (!TryParseLocked(flag, flag->current_, value, msg))\n          return false;\n        flag->modified_ = true;\n      } else {\n        *msg = StringPrintf(\"%s set to %s\",\n                            flag->name(), flag->current_value().c_str());\n      }\n      break;\n    }\n    case SET_FLAGS_DEFAULT: {\n      // modify the flag's default-value\n      if (!TryParseLocked(flag, flag->defvalue_, value, msg))\n        return false;\n      if (!flag->modified_) {\n        // Need to set both defvalue *and* current, in this case\n        TryParseLocked(flag, flag->current_, value, NULL);\n      }\n      break;\n    }\n    default: {\n      // unknown set_mode\n      assert(false);\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// Get the singleton FlagRegistry object\nFlagRegistry* FlagRegistry::global_registry_ = NULL;\nMutex FlagRegistry::global_registry_lock_(Mutex::LINKER_INITIALIZED);\n\nFlagRegistry* FlagRegistry::GlobalRegistry() {\n  MutexLock acquire_lock(&global_registry_lock_);\n  if (!global_registry_) {\n    global_registry_ = new FlagRegistry;\n  }\n  return global_registry_;\n}\n\n// --------------------------------------------------------------------\n// CommandLineFlagParser\n//    Parsing is done in two stages.  In the first, we go through\n//    argv.  For every flag-like arg we can make sense of, we parse\n//    it and set the appropriate FLAGS_* variable.  For every flag-\n//    like arg we can't make sense of, we store it in a vector,\n//    along with an explanation of the trouble.  In stage 2, we\n//    handle the 'reporting' flags like --help and --mpm_version.\n//    (This is via a call to HandleCommandLineHelpFlags(), in\n//    gflags_reporting.cc.)\n//    An optional stage 3 prints out the error messages.\n//       This is a bit of a simplification.  For instance, --flagfile\n//    is handled as soon as it's seen in stage 1, not in stage 2.\n// --------------------------------------------------------------------\n\nclass CommandLineFlagParser {\n public:\n  // The argument is the flag-registry to register the parsed flags in\n  explicit CommandLineFlagParser(FlagRegistry* reg) : registry_(reg) {}\n  ~CommandLineFlagParser() {}\n\n  // Stage 1: Every time this is called, it reads all flags in argv.\n  // However, it ignores all flags that have been successfully set\n  // before.  Typically this is only called once, so this 'reparsing'\n  // behavior isn't important.  It can be useful when trying to\n  // reparse after loading a dll, though.\n  uint32 ParseNewCommandLineFlags(int* argc, char*** argv, bool remove_flags);\n\n  // Stage 2: print reporting info and exit, if requested.\n  // In gflags_reporting.cc:HandleCommandLineHelpFlags().\n\n  // Stage 3: validate all the commandline flags that have validators\n  // registered.\n  void ValidateAllFlags();\n\n  // Stage 4: report any errors and return true if any were found.\n  bool ReportErrors();\n\n  // Set a particular command line option.  \"newval\" is a string\n  // describing the new value that the option has been set to.  If\n  // option_name does not specify a valid option name, or value is not\n  // a valid value for option_name, newval is empty.  Does recursive\n  // processing for --flagfile and --fromenv.  Returns the new value\n  // if everything went ok, or empty-string if not.  (Actually, the\n  // return-string could hold many flag/value pairs due to --flagfile.)\n  // NB: Must have called registry_->Lock() before calling this function.\n  string ProcessSingleOptionLocked(CommandLineFlag* flag,\n                                   const char* value,\n                                   FlagSettingMode set_mode);\n\n  // Set a whole batch of command line options as specified by contentdata,\n  // which is in flagfile format (and probably has been read from a flagfile).\n  // Returns the new value if everything went ok, or empty-string if\n  // not.  (Actually, the return-string could hold many flag/value\n  // pairs due to --flagfile.)\n  // NB: Must have called registry_->Lock() before calling this function.\n  string ProcessOptionsFromStringLocked(const string& contentdata,\n                                        FlagSettingMode set_mode);\n\n  // These are the 'recursive' flags, defined at the top of this file.\n  // Whenever we see these flags on the commandline, we must take action.\n  // These are called by ProcessSingleOptionLocked and, similarly, return\n  // new values if everything went ok, or the empty-string if not.\n  string ProcessFlagfileLocked(const string& flagval, FlagSettingMode set_mode);\n  // diff fromenv/tryfromenv\n  string ProcessFromenvLocked(const string& flagval, FlagSettingMode set_mode,\n                              bool errors_are_fatal);\n\n private:\n  FlagRegistry* const registry_;\n  map<string, string> error_flags_;      // map from name to error message\n  // This could be a set<string>, but we reuse the map to minimize the .o size\n  map<string, string> undefined_names_;  // --[flag] name was not registered\n};\n\n\n// Parse a list of (comma-separated) flags.\nstatic void ParseFlagList(const char* value, vector<string>* flags) {\n  for (const char *p = value; p && *p; value = p) {\n    p = strchr(value, ',');\n    size_t len;\n    if (p) {\n      len = p - value;\n      p++;\n    } else {\n      len = strlen(value);\n    }\n\n    if (len == 0)\n      ReportError(DIE, \"ERROR: empty flaglist entry\\n\");\n    if (value[0] == '-')\n      ReportError(DIE, \"ERROR: flag \\\"%*s\\\" begins with '-'\\n\", len, value);\n\n    flags->push_back(string(value, len));\n  }\n}\n\n// Snarf an entire file into a C++ string.  This is just so that we\n// can do all the I/O in one place and not worry about it everywhere.\n// Plus, it's convenient to have the whole file contents at hand.\n// Adds a newline at the end of the file.\n#define PFATAL(s)  do { perror(s); gflags_exitfunc(1); } while (0)\n\nstatic string ReadFileIntoString(const char* filename) {\n  const int kBufSize = 8092;\n  char buffer[kBufSize];\n  string s;\n  FILE* fp;\n  if ((errno = SafeFOpen(&fp, filename, \"r\")) != 0) PFATAL(filename);\n  size_t n;\n  while ( (n=fread(buffer, 1, kBufSize, fp)) > 0 ) {\n    if (ferror(fp))  PFATAL(filename);\n    s.append(buffer, n);\n  }\n  fclose(fp);\n  return s;\n}\n\nuint32 CommandLineFlagParser::ParseNewCommandLineFlags(int* argc, char*** argv,\n                                                       bool remove_flags) {\n  const char *program_name = strrchr((*argv)[0], PATH_SEPARATOR);   // nix path\n  program_name = (program_name == NULL ? (*argv)[0] : program_name+1);\n\n  int first_nonopt = *argc;        // for non-options moved to the end\n\n  registry_->Lock();\n  for (int i = 1; i < first_nonopt; i++) {\n    char* arg = (*argv)[i];\n\n    // Like getopt(), we permute non-option flags to be at the end.\n    if (arg[0] != '-' ||           // must be a program argument\n        (arg[0] == '-' && arg[1] == '\\0')) {  // \"-\" is an argument, not a flag\n      memmove((*argv) + i, (*argv) + i+1, (*argc - (i+1)) * sizeof((*argv)[i]));\n      (*argv)[*argc-1] = arg;      // we go last\n      first_nonopt--;              // we've been pushed onto the stack\n      i--;                         // to undo the i++ in the loop\n      continue;\n    }\n\n    if (arg[0] == '-') arg++;      // allow leading '-'\n    if (arg[0] == '-') arg++;      // or leading '--'\n\n    // -- alone means what it does for GNU: stop options parsing\n    if (*arg == '\\0') {\n      first_nonopt = i+1;\n      break;\n    }\n\n    // Find the flag object for this option\n    string key;\n    const char* value;\n    string error_message;\n    CommandLineFlag* flag = registry_->SplitArgumentLocked(arg, &key, &value,\n                                                           &error_message);\n    if (flag == NULL) {\n      undefined_names_[key] = \"\";    // value isn't actually used\n      error_flags_[key] = error_message;\n      continue;\n    }\n\n    if (value == NULL) {\n      // Boolean options are always assigned a value by SplitArgumentLocked()\n      assert(strcmp(flag->type_name(), \"bool\") != 0);\n      if (i+1 >= first_nonopt) {\n        // This flag needs a value, but there is nothing available\n        error_flags_[key] = (string(kError) + \"flag '\" + (*argv)[i] + \"'\"\n                             + \" is missing its argument\");\n        if (flag->help() && flag->help()[0] > '\\001') {\n          // Be useful in case we have a non-stripped description.\n          error_flags_[key] += string(\"; flag description: \") + flag->help();\n        }\n        error_flags_[key] += \"\\n\";\n        break;    // we treat this as an unrecoverable error\n      } else {\n        value = (*argv)[++i];                   // read next arg for value\n\n        // Heuristic to detect the case where someone treats a string arg\n        // like a bool:\n        // --my_string_var --foo=bar\n        // We look for a flag of string type, whose value begins with a\n        // dash, and where the flag-name and value are separated by a\n        // space rather than an '='.\n        // To avoid false positives, we also require the word \"true\"\n        // or \"false\" in the help string.  Without this, a valid usage\n        // \"-lat -30.5\" would trigger the warning.  The common cases we\n        // want to solve talk about true and false as values.\n        if (value[0] == '-'\n            && strcmp(flag->type_name(), \"string\") == 0\n            && (strstr(flag->help(), \"true\")\n                || strstr(flag->help(), \"false\"))) {\n          LOG(WARNING) << \"Did you really mean to set flag '\"\n                       << flag->name() << \"' to the value '\"\n                       << value << \"'?\";\n        }\n      }\n    }\n\n    // TODO(csilvers): only set a flag if we hadn't set it before here\n    ProcessSingleOptionLocked(flag, value, SET_FLAGS_VALUE);\n  }\n  registry_->Unlock();\n\n  if (remove_flags) {   // Fix up argc and argv by removing command line flags\n    (*argv)[first_nonopt-1] = (*argv)[0];\n    (*argv) += (first_nonopt-1);\n    (*argc) -= (first_nonopt-1);\n    first_nonopt = 1;   // because we still don't count argv[0]\n  }\n\n  logging_is_probably_set_up = true;   // because we've parsed --logdir, etc.\n\n  return first_nonopt;\n}\n\nstring CommandLineFlagParser::ProcessFlagfileLocked(const string& flagval,\n                                                    FlagSettingMode set_mode) {\n  if (flagval.empty())\n    return \"\";\n\n  string msg;\n  vector<string> filename_list;\n  ParseFlagList(flagval.c_str(), &filename_list);  // take a list of filenames\n  for (size_t i = 0; i < filename_list.size(); ++i) {\n    const char* file = filename_list[i].c_str();\n    msg += ProcessOptionsFromStringLocked(ReadFileIntoString(file), set_mode);\n  }\n  return msg;\n}\n\nstring CommandLineFlagParser::ProcessFromenvLocked(const string& flagval,\n                                                   FlagSettingMode set_mode,\n                                                   bool errors_are_fatal) {\n  if (flagval.empty())\n    return \"\";\n\n  string msg;\n  vector<string> flaglist;\n  ParseFlagList(flagval.c_str(), &flaglist);\n\n  for (size_t i = 0; i < flaglist.size(); ++i) {\n    const char* flagname = flaglist[i].c_str();\n    CommandLineFlag* flag = registry_->FindFlagLocked(flagname);\n    if (flag == NULL) {\n      error_flags_[flagname] =\n          StringPrintf(\"%sunknown command line flag '%s' \"\n                       \"(via --fromenv or --tryfromenv)\\n\",\n                       kError, flagname);\n      undefined_names_[flagname] = \"\";\n      continue;\n    }\n\n    const string envname = string(\"FLAGS_\") + string(flagname);\n\tstring envval;\n\tif (!SafeGetEnv(envname.c_str(), envval)) {\n      if (errors_are_fatal) {\n        error_flags_[flagname] = (string(kError) + envname +\n                                  \" not found in environment\\n\");\n      }\n      continue;\n    }\n\n    // Avoid infinite recursion.\n    if (envval == \"fromenv\" || envval == \"tryfromenv\") {\n      error_flags_[flagname] =\n          StringPrintf(\"%sinfinite recursion on environment flag '%s'\\n\",\n                       kError, envval.c_str());\n      continue;\n    }\n\n    msg += ProcessSingleOptionLocked(flag, envval.c_str(), set_mode);\n  }\n  return msg;\n}\n\nstring CommandLineFlagParser::ProcessSingleOptionLocked(\n    CommandLineFlag* flag, const char* value, FlagSettingMode set_mode) {\n  string msg;\n  if (value && !registry_->SetFlagLocked(flag, value, set_mode, &msg)) {\n    error_flags_[flag->name()] = msg;\n    return \"\";\n  }\n\n  // The recursive flags, --flagfile and --fromenv and --tryfromenv,\n  // must be dealt with as soon as they're seen.  They will emit\n  // messages of their own.\n  if (strcmp(flag->name(), \"flagfile\") == 0) {\n    msg += ProcessFlagfileLocked(FLAGS_flagfile, set_mode);\n\n  } else if (strcmp(flag->name(), \"fromenv\") == 0) {\n    // last arg indicates envval-not-found is fatal (unlike in --tryfromenv)\n    msg += ProcessFromenvLocked(FLAGS_fromenv, set_mode, true);\n\n  } else if (strcmp(flag->name(), \"tryfromenv\") == 0) {\n    msg += ProcessFromenvLocked(FLAGS_tryfromenv, set_mode, false);\n  }\n\n  return msg;\n}\n\nvoid CommandLineFlagParser::ValidateAllFlags() {\n  FlagRegistryLock frl(registry_);\n  for (FlagRegistry::FlagConstIterator i = registry_->flags_.begin();\n       i != registry_->flags_.end(); ++i) {\n    if (!i->second->ValidateCurrent()) {\n      // only set a message if one isn't already there.  (If there's\n      // an error message, our job is done, even if it's not exactly\n      // the same error.)\n      if (error_flags_[i->second->name()].empty())\n        error_flags_[i->second->name()] =\n            string(kError) + \"--\" + i->second->name() +\n            \" must be set on the commandline\"\n            \" (default value fails validation)\\n\";\n    }\n  }\n}\n\nbool CommandLineFlagParser::ReportErrors() {\n  // error_flags_ indicates errors we saw while parsing.\n  // But we ignore undefined-names if ok'ed by --undef_ok\n  if (!FLAGS_undefok.empty()) {\n    vector<string> flaglist;\n    ParseFlagList(FLAGS_undefok.c_str(), &flaglist);\n    for (size_t i = 0; i < flaglist.size(); ++i) {\n      // We also deal with --no<flag>, in case the flagname was boolean\n      const string no_version = string(\"no\") + flaglist[i];\n      if (undefined_names_.find(flaglist[i]) != undefined_names_.end()) {\n        error_flags_[flaglist[i]] = \"\";    // clear the error message\n      } else if (undefined_names_.find(no_version) != undefined_names_.end()) {\n        error_flags_[no_version] = \"\";\n      }\n    }\n  }\n  // Likewise, if they decided to allow reparsing, all undefined-names\n  // are ok; we just silently ignore them now, and hope that a future\n  // parse will pick them up somehow.\n  if (allow_command_line_reparsing) {\n    for (map<string, string>::const_iterator it = undefined_names_.begin();\n         it != undefined_names_.end();  ++it)\n      error_flags_[it->first] = \"\";      // clear the error message\n  }\n\n  bool found_error = false;\n  string error_message;\n  for (map<string, string>::const_iterator it = error_flags_.begin();\n       it != error_flags_.end(); ++it) {\n    if (!it->second.empty()) {\n      error_message.append(it->second.data(), it->second.size());\n      found_error = true;\n    }\n  }\n  if (found_error)\n    ReportError(DO_NOT_DIE, \"%s\", error_message.c_str());\n  return found_error;\n}\n\nstring CommandLineFlagParser::ProcessOptionsFromStringLocked(\n    const string& contentdata, FlagSettingMode set_mode) {\n  string retval;\n  const char* flagfile_contents = contentdata.c_str();\n  bool flags_are_relevant = true;   // set to false when filenames don't match\n  bool in_filename_section = false;\n\n  const char* line_end = flagfile_contents;\n  // We read this file a line at a time.\n  for (; line_end; flagfile_contents = line_end + 1) {\n    while (*flagfile_contents && isspace(*flagfile_contents))\n      ++flagfile_contents;\n    line_end = strchr(flagfile_contents, '\\n');\n    size_t len = line_end ? line_end - flagfile_contents\n                          : strlen(flagfile_contents);\n    string line(flagfile_contents, len);\n\n    // Each line can be one of four things:\n    // 1) A comment line -- we skip it\n    // 2) An empty line -- we skip it\n    // 3) A list of filenames -- starts a new filenames+flags section\n    // 4) A --flag=value line -- apply if previous filenames match\n    if (line.empty() || line[0] == '#') {\n      // comment or empty line; just ignore\n\n    } else if (line[0] == '-') {    // flag\n      in_filename_section = false;  // instead, it was a flag-line\n      if (!flags_are_relevant)      // skip this flag; applies to someone else\n        continue;\n\n      const char* name_and_val = line.c_str() + 1;    // skip the leading -\n      if (*name_and_val == '-')\n        name_and_val++;                               // skip second - too\n      string key;\n      const char* value;\n      string error_message;\n      CommandLineFlag* flag = registry_->SplitArgumentLocked(name_and_val,\n                                                             &key, &value,\n                                                             &error_message);\n      // By API, errors parsing flagfile lines are silently ignored.\n      if (flag == NULL) {\n        // \"WARNING: flagname '\" + key + \"' not found\\n\"\n      } else if (value == NULL) {\n        // \"WARNING: flagname '\" + key + \"' missing a value\\n\"\n      } else {\n        retval += ProcessSingleOptionLocked(flag, value, set_mode);\n      }\n\n    } else {                        // a filename!\n      if (!in_filename_section) {   // start over: assume filenames don't match\n        in_filename_section = true;\n        flags_are_relevant = false;\n      }\n\n      // Split the line up at spaces into glob-patterns\n      const char* space = line.c_str();   // just has to be non-NULL\n      for (const char* word = line.c_str(); *space; word = space+1) {\n        if (flags_are_relevant)     // we can stop as soon as we match\n          break;\n        space = strchr(word, ' ');\n        if (space == NULL)\n          space = word + strlen(word);\n        const string glob(word, space - word);\n        // We try matching both against the full argv0 and basename(argv0)\n        if (glob == ProgramInvocationName()       // small optimization\n            || glob == ProgramInvocationShortName()\n#if defined(HAVE_FNMATCH_H)\n            || fnmatch(glob.c_str(), ProgramInvocationName(),      FNM_PATHNAME) == 0\n            || fnmatch(glob.c_str(), ProgramInvocationShortName(), FNM_PATHNAME) == 0\n#elif defined(HAVE_SHLWAPI_H)\n            || PathMatchSpec(glob.c_str(), ProgramInvocationName())\n            || PathMatchSpec(glob.c_str(), ProgramInvocationShortName())\n#endif\n            ) {\n          flags_are_relevant = true;\n        }\n      }\n    }\n  }\n  return retval;\n}\n\n// --------------------------------------------------------------------\n// GetFromEnv()\n// AddFlagValidator()\n//    These are helper functions for routines like BoolFromEnv() and\n//    RegisterFlagValidator, defined below.  They're defined here so\n//    they can live in the unnamed namespace (which makes friendship\n//    declarations for these classes possible).\n// --------------------------------------------------------------------\n\ntemplate<typename T>\nT GetFromEnv(const char *varname, const char* type, T dflt) {\n  std::string valstr;\n  if (SafeGetEnv(varname, valstr)) {\n    FlagValue ifv(new T, type, true);\n    if (!ifv.ParseFrom(valstr.c_str())) {\n      ReportError(DIE, \"ERROR: error parsing env variable '%s' with value '%s'\\n\",\n                  varname, valstr.c_str());\n\t}\n    return OTHER_VALUE_AS(ifv, T);\n  } else return dflt;\n}\n\nbool AddFlagValidator(const void* flag_ptr, ValidateFnProto validate_fn_proto) {\n  // We want a lock around this routine, in case two threads try to\n  // add a validator (hopefully the same one!) at once.  We could use\n  // our own thread, but we need to loook at the registry anyway, so\n  // we just steal that one.\n  FlagRegistry* const registry = FlagRegistry::GlobalRegistry();\n  FlagRegistryLock frl(registry);\n  // First, find the flag whose current-flag storage is 'flag'.\n  // This is the CommandLineFlag whose current_->value_buffer_ == flag\n  CommandLineFlag* flag = registry->FindFlagViaPtrLocked(flag_ptr);\n  if (!flag) {\n    LOG(WARNING) << \"Ignoring RegisterValidateFunction() for flag pointer \"\n                 << flag_ptr << \": no flag found at that address\";\n    return false;\n  } else if (validate_fn_proto == flag->validate_function()) {\n    return true;    // ok to register the same function over and over again\n  } else if (validate_fn_proto != NULL && flag->validate_function() != NULL) {\n    LOG(WARNING) << \"Ignoring RegisterValidateFunction() for flag '\"\n                 << flag->name() << \"': validate-fn already registered\";\n    return false;\n  } else {\n    flag->validate_fn_proto_ = validate_fn_proto;\n    return true;\n  }\n}\n\n}  // end unnamed namespaces\n\n\n// Now define the functions that are exported via the .h file\n\n// --------------------------------------------------------------------\n// FlagRegisterer\n//    This class exists merely to have a global constructor (the\n//    kind that runs before main(), that goes an initializes each\n//    flag that's been declared.  Note that it's very important we\n//    don't have a destructor that deletes flag_, because that would\n//    cause us to delete current_storage/defvalue_storage as well,\n//    which can cause a crash if anything tries to access the flag\n//    values in a global destructor.\n// --------------------------------------------------------------------\n\nFlagRegisterer::FlagRegisterer(const char* name, const char* type,\n                               const char* help, const char* filename,\n                               void* current_storage, void* defvalue_storage) {\n  if (help == NULL)\n    help = \"\";\n  // FlagValue expects the type-name to not include any namespace\n  // components, so we get rid of those, if any.\n  if (strchr(type, ':'))\n    type = strrchr(type, ':') + 1;\n  FlagValue* current = new FlagValue(current_storage, type, false);\n  FlagValue* defvalue = new FlagValue(defvalue_storage, type, false);\n  // Importantly, flag_ will never be deleted, so storage is always good.\n  CommandLineFlag* flag = new CommandLineFlag(name, help, filename,\n                                              current, defvalue);\n  FlagRegistry::GlobalRegistry()->RegisterFlag(flag);   // default registry\n}\n\n// --------------------------------------------------------------------\n// GetAllFlags()\n//    The main way the FlagRegistry class exposes its data.  This\n//    returns, as strings, all the info about all the flags in\n//    the main registry, sorted first by filename they are defined\n//    in, and then by flagname.\n// --------------------------------------------------------------------\n\nstruct FilenameFlagnameCmp {\n  bool operator()(const CommandLineFlagInfo& a,\n                  const CommandLineFlagInfo& b) const {\n    int cmp = strcmp(a.filename.c_str(), b.filename.c_str());\n    if (cmp == 0)\n      cmp = strcmp(a.name.c_str(), b.name.c_str());  // secondary sort key\n    return cmp < 0;\n  }\n};\n\nvoid GetAllFlags(vector<CommandLineFlagInfo>* OUTPUT) {\n  FlagRegistry* const registry = FlagRegistry::GlobalRegistry();\n  registry->Lock();\n  for (FlagRegistry::FlagConstIterator i = registry->flags_.begin();\n       i != registry->flags_.end(); ++i) {\n    CommandLineFlagInfo fi;\n    i->second->FillCommandLineFlagInfo(&fi);\n    OUTPUT->push_back(fi);\n  }\n  registry->Unlock();\n  // Now sort the flags, first by filename they occur in, then alphabetically\n  sort(OUTPUT->begin(), OUTPUT->end(), FilenameFlagnameCmp());\n}\n\n// --------------------------------------------------------------------\n// SetArgv()\n// GetArgvs()\n// GetArgv()\n// GetArgv0()\n// ProgramInvocationName()\n// ProgramInvocationShortName()\n// SetUsageMessage()\n// ProgramUsage()\n//    Functions to set and get argv.  Typically the setter is called\n//    by ParseCommandLineFlags.  Also can get the ProgramUsage string,\n//    set by SetUsageMessage.\n// --------------------------------------------------------------------\n\n// These values are not protected by a Mutex because they are normally\n// set only once during program startup.\nstatic const char* argv0 = \"UNKNOWN\";      // just the program name\nstatic const char* cmdline = \"\";           // the entire command-line\nstatic vector<string> argvs;\nstatic uint32 argv_sum = 0;\nstatic const char* program_usage = NULL;\n\nvoid SetArgv(int argc, const char** argv) {\n  static bool called_set_argv = false;\n  if (called_set_argv)         // we already have an argv for you\n    return;\n\n  called_set_argv = true;\n\n  assert(argc > 0);            // every program has at least a progname\n  argv0 = strdup(argv[0]);     // small memory leak, but fn only called once\n  assert(argv0);\n\n  string cmdline_string;       // easier than doing strcats\n  for (int i = 0; i < argc; i++) {\n    if (i != 0) {\n      cmdline_string += \" \";\n    }\n    cmdline_string += argv[i];\n    argvs.push_back(argv[i]);\n  }\n  cmdline = strdup(cmdline_string.c_str());  // another small memory leak\n  assert(cmdline);\n\n  // Compute a simple sum of all the chars in argv\n  for (const char* c = cmdline; *c; c++)\n    argv_sum += *c;\n}\n\nconst vector<string>& GetArgvs() { return argvs; }\nconst char* GetArgv()            { return cmdline; }\nconst char* GetArgv0()           { return argv0; }\nuint32 GetArgvSum()              { return argv_sum; }\nconst char* ProgramInvocationName() {             // like the GNU libc fn\n  return GetArgv0();\n}\nconst char* ProgramInvocationShortName() {        // like the GNU libc fn\n  const char* slash = strrchr(argv0, '/');\n#ifdef OS_WINDOWS\n  if (!slash)  slash = strrchr(argv0, '\\\\');\n#endif\n  return slash ? slash + 1 : argv0;\n}\n\nvoid SetUsageMessage(const string& usage) {\n  if (program_usage != NULL)\n    ReportError(DIE, \"ERROR: SetUsageMessage() called twice\\n\");\n  program_usage = strdup(usage.c_str());      // small memory leak\n}\n\nconst char* ProgramUsage() {\n  if (program_usage) {\n    return program_usage;\n  }\n  return \"Warning: SetUsageMessage() never called\";\n}\n\n// --------------------------------------------------------------------\n// SetVersionString()\n// VersionString()\n// --------------------------------------------------------------------\n\nstatic const char* version_string = NULL;\n\nvoid SetVersionString(const string& version) {\n  if (version_string != NULL)\n    ReportError(DIE, \"ERROR: SetVersionString() called twice\\n\");\n  version_string = strdup(version.c_str());   // small memory leak\n}\n\nconst char* VersionString() {\n  return version_string ? version_string : \"\";\n}\n\n\n// --------------------------------------------------------------------\n// GetCommandLineOption()\n// GetCommandLineFlagInfo()\n// GetCommandLineFlagInfoOrDie()\n// SetCommandLineOption()\n// SetCommandLineOptionWithMode()\n//    The programmatic way to set a flag's value, using a string\n//    for its name rather than the variable itself (that is,\n//    SetCommandLineOption(\"foo\", x) rather than FLAGS_foo = x).\n//    There's also a bit more flexibility here due to the various\n//    set-modes, but typically these are used when you only have\n//    that flag's name as a string, perhaps at runtime.\n//    All of these work on the default, global registry.\n//       For GetCommandLineOption, return false if no such flag\n//    is known, true otherwise.  We clear \"value\" if a suitable\n//    flag is found.\n// --------------------------------------------------------------------\n\n\nbool GetCommandLineOption(const char* name, string* value) {\n  if (NULL == name)\n    return false;\n  assert(value);\n\n  FlagRegistry* const registry = FlagRegistry::GlobalRegistry();\n  FlagRegistryLock frl(registry);\n  CommandLineFlag* flag = registry->FindFlagLocked(name);\n  if (flag == NULL) {\n    return false;\n  } else {\n    *value = flag->current_value();\n    return true;\n  }\n}\n\nbool GetCommandLineFlagInfo(const char* name, CommandLineFlagInfo* OUTPUT) {\n  if (NULL == name) return false;\n  FlagRegistry* const registry = FlagRegistry::GlobalRegistry();\n  FlagRegistryLock frl(registry);\n  CommandLineFlag* flag = registry->FindFlagLocked(name);\n  if (flag == NULL) {\n    return false;\n  } else {\n    assert(OUTPUT);\n    flag->FillCommandLineFlagInfo(OUTPUT);\n    return true;\n  }\n}\n\nCommandLineFlagInfo GetCommandLineFlagInfoOrDie(const char* name) {\n  CommandLineFlagInfo info;\n  if (!GetCommandLineFlagInfo(name, &info)) {\n    fprintf(stderr, \"FATAL ERROR: flag name '%s' doesn't exist\\n\", name);\n    gflags_exitfunc(1);    // almost certainly gflags_exitfunc()\n  }\n  return info;\n}\n\nstring SetCommandLineOptionWithMode(const char* name, const char* value,\n                                    FlagSettingMode set_mode) {\n  string result;\n  FlagRegistry* const registry = FlagRegistry::GlobalRegistry();\n  FlagRegistryLock frl(registry);\n  CommandLineFlag* flag = registry->FindFlagLocked(name);\n  if (flag) {\n    CommandLineFlagParser parser(registry);\n    result = parser.ProcessSingleOptionLocked(flag, value, set_mode);\n    if (!result.empty()) {   // in the error case, we've already logged\n      // Could consider logging this change\n    }\n  }\n  // The API of this function is that we return empty string on error\n  return result;\n}\n\nstring SetCommandLineOption(const char* name, const char* value) {\n  return SetCommandLineOptionWithMode(name, value, SET_FLAGS_VALUE);\n}\n\n// --------------------------------------------------------------------\n// FlagSaver\n// FlagSaverImpl\n//    This class stores the states of all flags at construct time,\n//    and restores all flags to that state at destruct time.\n//    Its major implementation challenge is that it never modifies\n//    pointers in the 'main' registry, so global FLAG_* vars always\n//    point to the right place.\n// --------------------------------------------------------------------\n\nclass FlagSaverImpl {\n public:\n  // Constructs an empty FlagSaverImpl object.\n  explicit FlagSaverImpl(FlagRegistry* main_registry)\n      : main_registry_(main_registry) { }\n  ~FlagSaverImpl() {\n    // reclaim memory from each of our CommandLineFlags\n    vector<CommandLineFlag*>::const_iterator it;\n    for (it = backup_registry_.begin(); it != backup_registry_.end(); ++it)\n      delete *it;\n  }\n\n  // Saves the flag states from the flag registry into this object.\n  // It's an error to call this more than once.\n  // Must be called when the registry mutex is not held.\n  void SaveFromRegistry() {\n    FlagRegistryLock frl(main_registry_);\n    assert(backup_registry_.empty());   // call only once!\n    for (FlagRegistry::FlagConstIterator it = main_registry_->flags_.begin();\n         it != main_registry_->flags_.end();\n         ++it) {\n      const CommandLineFlag* main = it->second;\n      // Sets up all the const variables in backup correctly\n      CommandLineFlag* backup = new CommandLineFlag(\n          main->name(), main->help(), main->filename(),\n          main->current_->New(), main->defvalue_->New());\n      // Sets up all the non-const variables in backup correctly\n      backup->CopyFrom(*main);\n      backup_registry_.push_back(backup);   // add it to a convenient list\n    }\n  }\n\n  // Restores the saved flag states into the flag registry.  We\n  // assume no flags were added or deleted from the registry since\n  // the SaveFromRegistry; if they were, that's trouble!  Must be\n  // called when the registry mutex is not held.\n  void RestoreToRegistry() {\n    FlagRegistryLock frl(main_registry_);\n    vector<CommandLineFlag*>::const_iterator it;\n    for (it = backup_registry_.begin(); it != backup_registry_.end(); ++it) {\n      CommandLineFlag* main = main_registry_->FindFlagLocked((*it)->name());\n      if (main != NULL) {       // if NULL, flag got deleted from registry(!)\n        main->CopyFrom(**it);\n      }\n    }\n  }\n\n private:\n  FlagRegistry* const main_registry_;\n  vector<CommandLineFlag*> backup_registry_;\n\n  FlagSaverImpl(const FlagSaverImpl&);  // no copying!\n  void operator=(const FlagSaverImpl&);\n};\n\nFlagSaver::FlagSaver()\n    : impl_(new FlagSaverImpl(FlagRegistry::GlobalRegistry())) {\n  impl_->SaveFromRegistry();\n}\n\nFlagSaver::~FlagSaver() {\n  impl_->RestoreToRegistry();\n  delete impl_;\n}\n\n\n// --------------------------------------------------------------------\n// CommandlineFlagsIntoString()\n// ReadFlagsFromString()\n// AppendFlagsIntoFile()\n// ReadFromFlagsFile()\n//    These are mostly-deprecated routines that stick the\n//    commandline flags into a file/string and read them back\n//    out again.  I can see a use for CommandlineFlagsIntoString,\n//    for creating a flagfile, but the rest don't seem that useful\n//    -- some, I think, are a poor-man's attempt at FlagSaver --\n//    and are included only until we can delete them from callers.\n//    Note they don't save --flagfile flags (though they do save\n//    the result of having called the flagfile, of course).\n// --------------------------------------------------------------------\n\nstatic string TheseCommandlineFlagsIntoString(\n    const vector<CommandLineFlagInfo>& flags) {\n  vector<CommandLineFlagInfo>::const_iterator i;\n\n  size_t retval_space = 0;\n  for (i = flags.begin(); i != flags.end(); ++i) {\n    // An (over)estimate of how much space it will take to print this flag\n    retval_space += i->name.length() + i->current_value.length() + 5;\n  }\n\n  string retval;\n  retval.reserve(retval_space);\n  for (i = flags.begin(); i != flags.end(); ++i) {\n    retval += \"--\";\n    retval += i->name;\n    retval += \"=\";\n    retval += i->current_value;\n    retval += \"\\n\";\n  }\n  return retval;\n}\n\nstring CommandlineFlagsIntoString() {\n  vector<CommandLineFlagInfo> sorted_flags;\n  GetAllFlags(&sorted_flags);\n  return TheseCommandlineFlagsIntoString(sorted_flags);\n}\n\nbool ReadFlagsFromString(const string& flagfilecontents,\n                         const char* /*prog_name*/,  // TODO(csilvers): nix this\n                         bool errors_are_fatal) {\n  FlagRegistry* const registry = FlagRegistry::GlobalRegistry();\n  FlagSaverImpl saved_states(registry);\n  saved_states.SaveFromRegistry();\n\n  CommandLineFlagParser parser(registry);\n  registry->Lock();\n  parser.ProcessOptionsFromStringLocked(flagfilecontents, SET_FLAGS_VALUE);\n  registry->Unlock();\n  // Should we handle --help and such when reading flags from a string?  Sure.\n  HandleCommandLineHelpFlags();\n  if (parser.ReportErrors()) {\n    // Error.  Restore all global flags to their previous values.\n    if (errors_are_fatal)\n      gflags_exitfunc(1);\n    saved_states.RestoreToRegistry();\n    return false;\n  }\n  return true;\n}\n\n// TODO(csilvers): nix prog_name in favor of ProgramInvocationShortName()\nbool AppendFlagsIntoFile(const string& filename, const char *prog_name) {\n  FILE *fp;\n  if (SafeFOpen(&fp, filename.c_str(), \"a\") != 0) {\n    return false;\n  }\n\n  if (prog_name)\n    fprintf(fp, \"%s\\n\", prog_name);\n\n  vector<CommandLineFlagInfo> flags;\n  GetAllFlags(&flags);\n  // But we don't want --flagfile, which leads to weird recursion issues\n  vector<CommandLineFlagInfo>::iterator i;\n  for (i = flags.begin(); i != flags.end(); ++i) {\n    if (strcmp(i->name.c_str(), \"flagfile\") == 0) {\n      flags.erase(i);\n      break;\n    }\n  }\n  fprintf(fp, \"%s\", TheseCommandlineFlagsIntoString(flags).c_str());\n\n  fclose(fp);\n  return true;\n}\n\nbool ReadFromFlagsFile(const string& filename, const char* prog_name,\n                       bool errors_are_fatal) {\n  return ReadFlagsFromString(ReadFileIntoString(filename.c_str()),\n                             prog_name, errors_are_fatal);\n}\n\n\n// --------------------------------------------------------------------\n// BoolFromEnv()\n// Int32FromEnv()\n// Int64FromEnv()\n// Uint64FromEnv()\n// DoubleFromEnv()\n// StringFromEnv()\n//    Reads the value from the environment and returns it.\n//    We use an FlagValue to make the parsing easy.\n//    Example usage:\n//       DEFINE_bool(myflag, BoolFromEnv(\"MYFLAG_DEFAULT\", false), \"whatever\");\n// --------------------------------------------------------------------\n\nbool BoolFromEnv(const char *v, bool dflt) {\n  return GetFromEnv(v, \"bool\", dflt);\n}\nint32 Int32FromEnv(const char *v, int32 dflt) {\n  return GetFromEnv(v, \"int32\", dflt);\n}\nint64 Int64FromEnv(const char *v, int64 dflt)    {\n  return GetFromEnv(v, \"int64\", dflt);\n}\nuint64 Uint64FromEnv(const char *v, uint64 dflt) {\n  return GetFromEnv(v, \"uint64\", dflt);\n}\ndouble DoubleFromEnv(const char *v, double dflt) {\n  return GetFromEnv(v, \"double\", dflt);\n}\n\n#ifdef _MSC_VER\n#  pragma warning(push)\n#  pragma warning(disable: 4996) // ignore getenv security warning\n#endif\nconst char *StringFromEnv(const char *varname, const char *dflt) {\n  const char* const val = getenv(varname);\n  return val ? val : dflt;\n}\n#ifdef _MSC_VER\n#  pragma warning(pop)\n#endif\n\n\n// --------------------------------------------------------------------\n// RegisterFlagValidator()\n//    RegisterFlagValidator() is the function that clients use to\n//    'decorate' a flag with a validation function.  Once this is\n//    done, every time the flag is set (including when the flag\n//    is parsed from argv), the validator-function is called.\n//       These functions return true if the validator was added\n//    successfully, or false if not: the flag already has a validator,\n//    (only one allowed per flag), the 1st arg isn't a flag, etc.\n//       This function is not thread-safe.\n// --------------------------------------------------------------------\n\nbool RegisterFlagValidator(const bool* flag,\n                           bool (*validate_fn)(const char*, bool)) {\n  return AddFlagValidator(flag, reinterpret_cast<ValidateFnProto>(validate_fn));\n}\nbool RegisterFlagValidator(const int32* flag,\n                           bool (*validate_fn)(const char*, int32)) {\n  return AddFlagValidator(flag, reinterpret_cast<ValidateFnProto>(validate_fn));\n}\nbool RegisterFlagValidator(const int64* flag,\n                           bool (*validate_fn)(const char*, int64)) {\n  return AddFlagValidator(flag, reinterpret_cast<ValidateFnProto>(validate_fn));\n}\nbool RegisterFlagValidator(const uint64* flag,\n                           bool (*validate_fn)(const char*, uint64)) {\n  return AddFlagValidator(flag, reinterpret_cast<ValidateFnProto>(validate_fn));\n}\nbool RegisterFlagValidator(const double* flag,\n                           bool (*validate_fn)(const char*, double)) {\n  return AddFlagValidator(flag, reinterpret_cast<ValidateFnProto>(validate_fn));\n}\nbool RegisterFlagValidator(const string* flag,\n                           bool (*validate_fn)(const char*, const string&)) {\n  return AddFlagValidator(flag, reinterpret_cast<ValidateFnProto>(validate_fn));\n}\n\n\n// --------------------------------------------------------------------\n// ParseCommandLineFlags()\n// ParseCommandLineNonHelpFlags()\n// HandleCommandLineHelpFlags()\n//    This is the main function called from main(), to actually\n//    parse the commandline.  It modifies argc and argv as described\n//    at the top of gflags.h.  You can also divide this\n//    function into two parts, if you want to do work between\n//    the parsing of the flags and the printing of any help output.\n// --------------------------------------------------------------------\n\nstatic uint32 ParseCommandLineFlagsInternal(int* argc, char*** argv,\n                                            bool remove_flags, bool do_report) {\n  SetArgv(*argc, const_cast<const char**>(*argv));    // save it for later\n\n  FlagRegistry* const registry = FlagRegistry::GlobalRegistry();\n  CommandLineFlagParser parser(registry);\n\n  // When we parse the commandline flags, we'll handle --flagfile,\n  // --tryfromenv, etc. as we see them (since flag-evaluation order\n  // may be important).  But sometimes apps set FLAGS_tryfromenv/etc.\n  // manually before calling ParseCommandLineFlags.  We want to evaluate\n  // those too, as if they were the first flags on the commandline.\n  registry->Lock();\n  parser.ProcessFlagfileLocked(FLAGS_flagfile, SET_FLAGS_VALUE);\n  // Last arg here indicates whether flag-not-found is a fatal error or not\n  parser.ProcessFromenvLocked(FLAGS_fromenv, SET_FLAGS_VALUE, true);\n  parser.ProcessFromenvLocked(FLAGS_tryfromenv, SET_FLAGS_VALUE, false);\n  registry->Unlock();\n\n  // Now get the flags specified on the commandline\n  const int r = parser.ParseNewCommandLineFlags(argc, argv, remove_flags);\n\n  if (do_report)\n    HandleCommandLineHelpFlags();   // may cause us to exit on --help, etc.\n\n  // See if any of the unset flags fail their validation checks\n  parser.ValidateAllFlags();\n\n  if (parser.ReportErrors())        // may cause us to exit on illegal flags\n    gflags_exitfunc(1);\n  return r;\n}\n\nuint32 ParseCommandLineFlags(int* argc, char*** argv, bool remove_flags) {\n  return ParseCommandLineFlagsInternal(argc, argv, remove_flags, true);\n}\n\nuint32 ParseCommandLineNonHelpFlags(int* argc, char*** argv,\n                                    bool remove_flags) {\n  return ParseCommandLineFlagsInternal(argc, argv, remove_flags, false);\n}\n\n// --------------------------------------------------------------------\n// AllowCommandLineReparsing()\n// ReparseCommandLineNonHelpFlags()\n//    This is most useful for shared libraries.  The idea is if\n//    a flag is defined in a shared library that is dlopen'ed\n//    sometime after main(), you can ParseCommandLineFlags before\n//    the dlopen, then ReparseCommandLineNonHelpFlags() after the\n//    dlopen, to get the new flags.  But you have to explicitly\n//    Allow() it; otherwise, you get the normal default behavior\n//    of unrecognized flags calling a fatal error.\n// TODO(csilvers): this isn't used.  Just delete it?\n// --------------------------------------------------------------------\n\nvoid AllowCommandLineReparsing() {\n  allow_command_line_reparsing = true;\n}\n\nvoid ReparseCommandLineNonHelpFlags() {\n  // We make a copy of argc and argv to pass in\n  const vector<string>& argvs = GetArgvs();\n  int tmp_argc = static_cast<int>(argvs.size());\n  char** tmp_argv = new char* [tmp_argc + 1];\n  for (int i = 0; i < tmp_argc; ++i)\n    tmp_argv[i] = strdup(argvs[i].c_str());   // TODO(csilvers): don't dup\n\n  ParseCommandLineNonHelpFlags(&tmp_argc, &tmp_argv, false);\n\n  for (int i = 0; i < tmp_argc; ++i)\n    free(tmp_argv[i]);\n  delete[] tmp_argv;\n}\n\nvoid ShutDownCommandLineFlags() {\n  FlagRegistry::DeleteGlobalRegistry();\n}\n\n\n} // namespace GFLAGS_NAMESPACE\n"
    },
    "skipped": [],
    "total_files": 42
}