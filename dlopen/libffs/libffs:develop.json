{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/cod/standard.c": "#include \"config.h\"\n#ifndef LINUX_KERNEL_MODULE\n#include \"stdio.h\"\n#endif\n#ifdef LINUX_KERNEL_MODULE\n#ifndef MODULE\n#define MODULE\n#endif\n#ifndef __KERNEL__\n#define __KERNEL__\n#endif\n#include <linux/kernel.h>\n#include <linux/module.h>\n#endif\n#ifndef LINUX_KERNEL_MODULE\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#endif\n#include \"cod.h\"\n#include \"cod_internal.h\"\n#include \"structs.h\"\n#undef NDEBUG\n#include \"assert.h\"\n#ifndef LINUX_KERNEL_MODULE\n#include <ctype.h>\n#ifdef HAVE_MALLOC_H\n#include <malloc.h>\n#endif\n#include <string.h>\n#else\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#endif\n#include <sys/time.h>\n#ifndef LINUX_KERNEL_MODULE\n#ifdef HAVE_ATL_H\n#include \"atl.h\"\n#endif\n#endif\n#include \"ffs.h\"\n\n#ifndef LINUX_KERNEL_MODULE\n#ifdef HAVE_ATL_H\nstatic int\nattr_set(attr_list l, char *name)\n{\n    atom_t atom = attr_atom_from_string(name);\n    attr_value_type junk;\n    attr_value junk2;\n    if (atom == 0 ) return 0;\n    \n    return query_attr(l, atom, &junk, &junk2);\n}\n\nstatic attr_list\nattr_create_list()\n{\n    return create_attr_list();\n}\n\nstatic void\nattr_free_list(attr_list l)\n{\n    free_attr_list(l);\n}\n\nstatic void\nstd_set_int_attr(attr_list l, char *name, int value)\n{\n    atom_t atom = attr_atom_from_string(name);\n    if (atom == 0 ) return;\n\n    set_int_attr(l, atom, value);\n}\n\nstatic void\nstd_set_long_attr(attr_list l, char *name, long value)\n{\n    atom_t atom = attr_atom_from_string(name);\n    if (atom == 0 ) return;\n\n    set_long_attr(l, atom, value);\n}\n\nstatic void\nstd_set_double_attr(attr_list l, char *name, double value)\n{\n    atom_t atom = attr_atom_from_string(name);\n    if (atom == 0 ) return;\n\n    set_double_attr(l, atom, value);\n}\n\nstatic void\nstd_set_float_attr(attr_list l, char *name, float value)\n{\n    atom_t atom = attr_atom_from_string(name);\n    if (atom == 0 ) return;\n\n    set_float_attr(l, atom, value);\n}\n\nstatic void\nstd_set_string_attr(attr_list l, char *name, char *value)\n{\n    atom_t atom = attr_atom_from_string(name);\n    if (atom == 0 ) return;\n\n    set_string_attr(l, atom, value);\n}\n\nstatic int\nattr_ivalue(attr_list l, char *name)\n{\n    atom_t atom = attr_atom_from_string(name);\n    int i = 0;\n    if (atom == 0 ) return 0;\n    \n    get_int_attr(l, atom, &i);\n    return i;\n}\n\nstatic long\nattr_lvalue(attr_list l, char *name)\n{\n    atom_t atom = attr_atom_from_string(name);\n    long lo = 0;\n    if (atom == 0 ) return 0;\n    \n    get_long_attr(l, atom, &lo);\n    return lo;\n}\n\nstatic double\nattr_dvalue(attr_list l, char *name)\n{\n    atom_t atom = attr_atom_from_string(name);\n    double d;\n    if (atom == 0 ) return 0;\n    \n    get_double_attr(l, atom, &d);\n    return d;\n}\n\nstatic float\nattr_fvalue(attr_list l, char *name)\n{\n    atom_t atom = attr_atom_from_string(name);\n    float f;\n    if (atom == 0 ) return 0;\n    \n    get_float_attr(l, atom, &f);\n    return f;\n}\n\nstatic char *\nattr_svalue(attr_list l, char *name)\n{\n    atom_t atom = attr_atom_from_string(name);\n    char *s;\n    if (atom == 0 ) return 0;\n    \n    get_string_attr(l, atom, &s);\n    return strdup(s);\n}\n#endif\n\nstatic FFSFile \nopen_ffs_file(char * fname, char * mode)\n{\n    FFSFile temp;\n    temp = open_FFSfile(fname, mode);\n    if(!temp) {\n\tfprintf(stderr, \"Could not open FFSfile from CoD\\n\");\n    }\n    return temp;\n}\n\nstatic void close_ffs_file(FFSFile fname)\n{\n    close_FFSfile(fname);\n}\n\nint\ngettimeofday_wrapper(struct timeval * tp)\n{\n    int ret = gettimeofday(tp, NULL);\n    return ret;\n}\n\n\n#include <sys/time.h>\ntypedef struct chr_time {\n    double d1;\n    double d2;\n    double d3;\n} chr_time;\n\n\nstatic void\nchr_get_time( chr_time *time)\n{\n    gettimeofday((struct timeval *) time, NULL);\n}\n\nstatic void\nchr_timer_start( chr_time *time)\n{\n    chr_get_time(time);\n}\n\nstatic void chr_timer_diff( chr_time *diff_time, chr_time *src1, chr_time *src2);\nstatic void\nchr_timer_stop( chr_time *time)\n{\n    struct timeval now;\n    struct timeval duration;\n\n    gettimeofday(&now, NULL);\n    chr_timer_diff((chr_time*)&duration, (chr_time*)&now, time);\n    *((struct timeval *) time) = duration;\n}\n\nstatic int\nchr_timer_eq_zero (chr_time *time)\n{\n    struct timeval *t = (struct timeval *) time; \n    return ((t->tv_sec == 0) && (t->tv_usec == 0));\n}\n\nstatic void\nchr_timer_diff( chr_time *diff, chr_time *src1, chr_time *src2)\n{\n    struct timeval d;\n    struct timeval *s1 = (struct timeval *)src1;\n    struct timeval *s2 = (struct timeval *)src2;\n    d.tv_sec = s1->tv_sec - s2->tv_sec;\n    d.tv_usec = s1->tv_usec - s2->tv_usec;\n    if (d.tv_usec < 0) {\n\td.tv_usec += 1000000;\n\td.tv_sec--;\n    }\n    *((struct timeval*)diff) = d;\n}\n\nstatic void\nchr_timer_sum( chr_time *sum, chr_time *src1, chr_time *src2)\n{\n    struct timeval s;\n    struct timeval *s1 = (struct timeval *)src1;\n    struct timeval *s2 = (struct timeval *)src2;\n    s.tv_sec = s1->tv_sec + s2->tv_sec;\n    s.tv_usec = s1->tv_usec + s2->tv_usec;\n    if (s.tv_usec > 1000000) {\n\ts.tv_usec -= 1000000;\n\ts.tv_sec++;\n    }\n    *((struct timeval*)sum) = s;\n}\n\n\nstatic double\nchr_time_to_secs(chr_time *time)\n{\n    return (double)((struct timeval*)time)->tv_sec + \n\t((double)((struct timeval*)time)->tv_usec)/1000000.0;\n}\n\nstatic double\nchr_time_to_millisecs(chr_time *time)\n{\n    return ((double)((struct timeval*)time)->tv_sec)*1000.0 + \n\t((double)((struct timeval*)time)->tv_usec)/1000.0;\n}\n\nstatic double\nchr_time_to_microsecs(chr_time *time)\n{\n    return ((double)((struct timeval*)time)->tv_sec)*1000000.0 + \n\t((double)((struct timeval*)time)->tv_usec);\n}\n\nstatic double\nchr_time_to_nanosecs(chr_time *time)\n{\n    return ((double)((struct timeval*)time)->tv_sec)*1000000000.0 + \n\t((double)((struct timeval*)time)->tv_usec*1000.0);\n}\n\nstatic double\nchr_approx_resolution()\n{\n    struct timeval start, stop, diff;\n    gettimeofday(&start, NULL);\n    gettimeofday(&stop, NULL);\n    while(start.tv_usec == stop.tv_usec) {\n\tgettimeofday(&stop, NULL);\n    }\n    chr_timer_diff((chr_time*)&diff, (chr_time*)&stop, (chr_time*)&start);\n    return chr_time_to_secs((chr_time*)&diff);\n}\n\nstatic char atl_extern_string[] = \"\\n\\\n\tint attr_set(attr_list l, string name);\\n\\\n\tattr_list create_attr_list();\\n\\\n\tattr_list copy_attr_list(attr_list l);\\n\\\n\tvoid free_attr_list(attr_list l);\\n\t\t\t\t\t\\\n\tvoid set_long_attr(attr_list l, string name, long value);\\n\\\n\tvoid set_float_attr(attr_list l, string name, double value);\\n\\\n\tvoid set_double_attr(attr_list l, string name, double value);\\n\\\n\tvoid set_int_attr(attr_list l, string name, int value);\\n\\\n\tvoid set_string_attr(attr_list l, string name, string value);\\n\\\n\tint attr_ivalue(attr_list l, string name);\\n\\\n\tlong attr_lvalue(attr_list l, string name);\\n\\\n\tdouble attr_dvalue(attr_list l, string name);\\n\\\n\tdouble attr_fvalue(attr_list l, string name);\\n\\\n\tchar* attr_svalue(attr_list l, string name);\\n\";\nstatic char chr_extern_string[] = \"\\n\\\n        void chr_get_time( chr_time *time);\\n\\\n        void chr_timer_diff( chr_time *diff_time, chr_time *src1, chr_time *src2);\\n\\\n\tint chr_timer_eq_zero( chr_time *time);\\n\\\n\tvoid chr_timer_sum( chr_time *sum_time, chr_time *src1, chr_time *src2);\\n\\\n\tvoid chr_timer_start (chr_time *timer);\\n\\\n\tvoid chr_timer_stop (chr_time *timer);\\n\\\n\tdouble chr_time_to_nanosecs (chr_time *time);\\n\\\n\tdouble chr_time_to_microsecs (chr_time *time);\\n\\\n\tdouble chr_time_to_millisecs (chr_time *time);\\n\\\n\tdouble chr_time_to_secs (chr_time *time);\\n\";\n\nstatic char basic_extern_string[] = \"\\n\\\n\tdouble chr_approx_resolution();\\n\\\n\tint gettimeofday(timeval *tp);\\n\\\n\tffs_file open_ffs(char * fname, char * mode);\\n\\\n\tvoid close_ffs(ffs_file fname);\\n\";\n\nstatic char internals[] = \"\\n\\\n\tvoid cod_NoOp(int duration);\\n\";\n\nstatic cod_extern_entry internal_externs[] = \n{\n    {\"cod_NoOp\", (void*)(long)0xdeadbeef},    /* value is unimportant, but can't be NULL */\n    {NULL, NULL}\n};\n\nstatic cod_extern_entry externs[] = \n{\n#ifdef HAVE_ATL_H\n    {\"attr_set\", (void*)(long)attr_set},\n    {\"create_attr_list\", (void*)(long)attr_create_list},\n    {\"copy_attr_list\", (void*)(long)attr_copy_list},\n    {\"free_attr_list\", (void*)(long)attr_free_list},\n    {\"set_int_attr\", (void*)(long)std_set_int_attr},\n    {\"set_long_attr\", (void*)(long)std_set_long_attr},\n    {\"set_double_attr\", (void*)(long)std_set_double_attr},\n    {\"set_float_attr\", (void*)(long)std_set_float_attr},\n    {\"set_string_attr\", (void*)(long)std_set_string_attr},\n    {\"attr_ivalue\", (void*)(long)attr_ivalue},\n    {\"attr_lvalue\", (void*)(long)attr_lvalue},\n    {\"attr_dvalue\", (void*)(long)attr_dvalue},\n    {\"attr_fvalue\", (void*)(long)attr_fvalue},\n    {\"attr_svalue\", (void*)(long)attr_svalue},\n#endif\n    {\"chr_get_time\", (void*)(long)chr_get_time},\n    {\"chr_timer_diff\", (void*)(long)chr_timer_diff},\n    {\"chr_timer_eq_zero\", (void*)(long)chr_timer_eq_zero},\n    {\"chr_timer_sum\", (void*)(long)chr_timer_sum},\n    {\"chr_timer_start\", (void*)(long)chr_timer_start},\n    {\"chr_timer_stop\", (void*)(long)chr_timer_stop},\n    {\"chr_time_to_nanosecs\", (void*)(long)chr_time_to_nanosecs},\n    {\"chr_time_to_microsecs\", (void*)(long)chr_time_to_microsecs},\n    {\"chr_time_to_millisecs\", (void*)(long)chr_time_to_millisecs},\n    {\"chr_time_to_secs\", (void*)(long)chr_time_to_secs},\n    {\"chr_approx_resolution\", (void*)(long)chr_approx_resolution},\n    {\"gettimeofday\", (void*)(long)gettimeofday_wrapper},\n    {\"open_ffs\", (void*)(long)open_ffs_file},\n    {\"close_ffs\", (void*)(long)close_ffs_file},\n    {(void*)0, (void*)0}\n};\n\nFMField chr_time_list[] = {\n    {\"d1\", \"double\", sizeof(double), FMOffset(chr_time*, d1)}, \n    {\"d2\", \"double\", sizeof(double), FMOffset(chr_time*, d2)}, \n    {\"d3\", \"double\", sizeof(double), FMOffset(chr_time*, d3)}, \n    {NULL, NULL, 0, 0}};\n\nFMField timeval_list[] = {\n    {\"tv_sec\", \"integer\", sizeof(((struct timeval*)0)->tv_sec), FMOffset(struct timeval *, tv_sec)}, \n    {\"tv_usec\", \"integer\", sizeof(((struct timeval*)0)->tv_usec), FMOffset(struct timeval *, tv_usec)}, \n    {NULL, NULL, 0, 0}};\n\nextern void\ncod_add_standard_elements(cod_parse_context context)\n{\n    cod_assoc_externs(context, externs);\n#ifdef HAVE_ATL_H\n    sm_ref attr_node = cod_new_reference_type_decl();\n    attr_node->node.reference_type_decl.name = strdup(\"attr_list\");\n    cod_add_decl_to_parse_context(\"attr_list\", attr_node, context);\n    cod_add_decl_to_scope(\"attr_list\", attr_node, context);\n    cod_add_defined_type(\"attr_list\", context);\n    cod_parse_for_context(atl_extern_string, context);\n#endif\n    sm_ref ffs_node = cod_new_reference_type_decl();\n    ffs_node->node.reference_type_decl.name = strdup(\"ffs_file\");\n    cod_add_decl_to_parse_context(\"ffs_file\", ffs_node, context);\n    cod_add_decl_to_scope(\"ffs_file\", ffs_node, context);\n    cod_add_defined_type(\"ffs_file\", context);\n\n    cod_add_int_constant_to_parse_context(\"NULL\", 0, context);\n    cod_add_simple_struct_type(\"chr_time\", chr_time_list, context);\n    cod_parse_for_context(chr_extern_string, context);\n    cod_add_simple_struct_type(\"timeval\", timeval_list, context);\n    cod_add_defined_type(\"cod_type_spec\", context);\n    cod_add_defined_type(\"cod_exec_context\", context);\n    cod_add_defined_type(\"cod_closure_context\", context);\n    cod_semanticize_added_decls(context);\n    \n    cod_parse_for_context(basic_extern_string, context);\n\n    cod_assoc_externs(context, internal_externs);\n    cod_parse_for_context(internals, context);\n    cod_swap_decls_to_standard(context);\n}\n\n#else /* LINUX_KERNEL_MODULE */\n\nextern void\ncod_add_standard_elements(cod_parse_context context)\n{\n}\n#endif /* LINUX_KERNEL_MODULE */\n\n#if NO_DYNAMIC_LINKING\n#define sym(x) (void*)(long)x\n#else\n#define sym(x) (void*)0\n#endif\n\nstatic cod_extern_entry string_externs[] = \n{\n    {\"memchr\", (void*)(long)memchr},\n    {\"memcmp\", (void*)(long)memcmp},\n    {\"memcpy\", (void*)(long)memcpy},\n    {\"memmove\", (void*)(long)memmove},\n    {\"memset\", (void*)(long)memset},\n    {\"strcat\", (void*)(long)strcat},\n    {\"strchr\", (void*)(long)strchr},\n    {\"strcmp\", (void*)(long)strcmp},\n    {\"strcoll\", (void*)(long)strcoll},\n    {\"strcpy\", (void*)(long)strcpy},\n    {\"strcspn\", (void*)(long)strcspn},\n    {\"strerror\", (void*)(long)strerror},\n    {\"strlen\", (void*)(long)strlen},\n    {\"strncat\", (void*)(long)strncat},\n    {\"strncmp\", (void*)(long)strncmp},\n    {\"strncpy\", (void*)(long)strncpy},\n    {\"strpbrk\", (void*)(long)strpbrk},\n    {\"strrchr\", (void*)(long)strrchr},\n    {\"strspn\", (void*)(long)strspn},\n    {\"strstr\", (void*)(long)strstr},\n    {\"strtok\", (void*)(long)strtok},\n    {\"strxfrm\", (void*)(long)strxfrm},\n    {NULL, NULL}\n};\n\nstatic char string_extern_string[] = \"\\n\\\nvoid\t*memchr(const void *s, int c, int size);\\n\\\nint\t memcmp(const void *m, const void *s, int size);\\n\\\nvoid\t*memcpy(void *m, const void *s, int size);\\n\\\nvoid\t*memmove(void *m, const void *s, int size);\\n\\\nvoid\t*memset(void *m, int c, int size);\\n\\\nchar\t*strcat(char *s1, const char *s2);\\n\\\nchar\t*strchr(const char *s1, int c);\\n\\\nint\t strcmp(const char *s1, const char *s2);\\n\\\nint\t strcoll(const char *s1, const char *s2);\\n\\\nchar\t*strcpy(char *s1, const char *s2);\\n\\\nint\t strcspn(const char *s1, const char *s2);\\n\\\nint\t strlen(const char *s);\\n\\\nchar\t*strncat(char *s1, const char *s2, int s);\\n\\\nint\t strncmp(const char *s1, const char *s2, int s);\\n\\\nchar\t*strncpy(char *s1, const char *s2, int s);\\n\\\nchar\t*strpbrk(const char *s1, const char *s2);\\n\\\nchar\t*strrchr(const char *s1, int c);\\n\\\nint\t strspn(const char *s1, const char *s2);\\n\\\nchar\t*strstr(const char *s1, const char *s2);\\n\\\nchar\t*strtok(char *s1, const char *s2);\\n\\\nint\t strxfrm(char *s1, const char *s2, int size);\\n\\\n\";\n\nstatic cod_extern_entry strings_externs[] = \n{\n    {\"bcmp\", (void*)(long)bcmp},\n    {\"bcopy\", (void*)(long)bcopy},\n    {\"bzero\", (void*)(long)bzero},\n    {\"index\", (void*)(long)index},\n    {\"rindex\", (void*)(long)rindex},\n    {\"ffs\", (void*)(long)ffs},\n    {\"strcasecmp\", (void*)(long)strcasecmp},\n    {\"strncasecmp\", (void*)(long)strncasecmp},\n    {NULL, NULL}\n};\n\nstatic char strings_extern_string[] = \"\\n\\\nint\t bcmp(const void *m1, const void *m2, int size);\\n\\\nvoid\t bcopy(const void *m1, void *m2, int size);\\n\\\nvoid\t bzero(void *m, int size);\\n\\\nchar\t*index(const char *s1, int c);\\n\\\nchar\t*rindex(const char *s1, int c);\\n\\\nint\t ffs(int);\\n\\\nint\t strcasecmp(const char *s1, const char *s2);\\n\\\nint\t strncasecmp(const char *s1, const char *s2, int size);\\n\\\n\";\n\n\n#include <math.h>\n\nstatic cod_extern_entry math_externs[] = \n{\n    {\"acos\", sym(acos)},\n    {\"asin\", sym(asin)},\n    {\"atan\", sym(atan)},\n    {\"atan2\", sym(atan2)},\n    {\"cos\", sym(cos)},\n    {\"sin\", sym(sin)},\n    {\"tan\", sym(tan)},\n    {\"acosh\", sym(acosh)},\n    {\"asinh\", sym(asinh)},\n    {\"atanh\", sym(atanh)},\n    {\"cosh\", sym(cosh)},\n    {\"sinh\", sym(sinh)},\n    {\"tanh\", sym(tanh)},\n    {\"exp\", sym(exp)},\n    {\"exp2\", sym(exp2)},\n    {\"expm1\", sym(expm1)},\n    {\"log\", sym(log)},\n    {\"log10\", sym(log10)},\n    {\"log2\", sym(log2)},\n    {\"log1p\", sym(log1p)},\n    {\"logb\", sym(logb)},\n    {\"modf\", sym(modf)},\n    {\"ldexp\", sym(ldexp)},\n    {\"frexp\", sym(frexp)},\n    {\"ilogb\", sym(ilogb)},\n    {\"scalbn\", sym(scalbn)},\n    {\"scalbln\", sym(scalbln)},\n    {\"fabs\", sym(fabs)},\n    {\"cbrt\", sym(cbrt)},\n    {\"hypot\", sym(hypot)},\n    {\"pow\", sym(pow)},\n    {\"sqrt\", sym(sqrt)},\n    {\"erf\", sym(erf)},\n    {\"erfc\", sym(erfc)},\n    {\"lgamma\", sym(lgamma)},\n    {\"tgamma\", sym(tgamma)},\n    {\"ceil\", sym(ceil)},\n    {\"floor\", sym(floor)},\n    {\"nearbyint\", sym(nearbyint)},\n    {\"rint\", sym(rint)},\n    {\"lrint\", sym(lrint)},\n    {\"round\", sym(round)},\n    {\"lround\", sym(lround)},\n    {\"trunc\", sym(trunc)},\n    {\"fmod\", sym(fmod)},\n    {\"remainder\", sym(remainder)},\n    {\"remquo\", sym(remquo)},\n    {\"copysign\", sym(copysign)},\n    {\"nan\", sym(nan)},\n    {NULL, NULL}\n};\n\nstatic char math_extern_string[] = \"\\n\\\ndouble acos(double a);\\n\\\ndouble asin(double a);\\n\\\ndouble atan(double a);\\n\\\ndouble atan2(double b, double a);\\n\\\ndouble cos(double a);\\n\\\ndouble sin(double a);\\n\\\ndouble tan(double a);\\n\\\ndouble acosh(double a);\\n\\\ndouble asinh(double a);\\n\\\ndouble atanh(double a);\\n\\\ndouble cosh(double a);\\n\\\ndouble sinh(double a);\\n\\\ndouble tanh(double a);\\n\\\ndouble exp(double a);\\n\\\ndouble exp2(double a); \\n\\\ndouble expm1(double a); \\n\\\ndouble log(double a);\\n\\\ndouble log10(double a);\\n\\\ndouble log2(double a);\\n\\\ndouble log1p(double a);\\n\\\ndouble logb(double a);\\n\\\ndouble modf(double b, double * a);\\n\\\ndouble ldexp(double b, int a);\\n\\\ndouble frexp(double b, int * a);\\n\\\nint ilogb(double a);\\n\\\ndouble scalbn(double b, int a);\\n\\\ndouble scalbln(double b, long int a);\\n\\\ndouble fabs(double a);\\n\\\ndouble cbrt(double a);\\n\\\ndouble hypot(double b, double a);\\n\\\ndouble pow(double b, double a);\\n\\\ndouble sqrt(double a);\\n\\\ndouble erf(double a);\\n\\\ndouble erfc(double a);\\n\\\ndouble lgamma(double a);\\n\\\ndouble tgamma(double a);\\n\\\ndouble ceil(double a);\\n\\\ndouble floor(double a);\\n\\\ndouble nearbyint(double a);\\n\\\ndouble rint(double a);\\n\\\nlong   lrint(double a);\\n\\\ndouble round(double a);\\n\\\nlong   lround(double a);\\n\\\ndouble trunc(double a);\\n\\\ndouble fmod(double a, double b);\\n\\\ndouble remainder(double a, double b);\\n\\\ndouble remquo(double a, double b, int *c);\\n\\\ndouble copysign(double a, double b);\\n\\\ndouble nan(const char * a);\\n\\\n\";\n\n\n#include <limits.h>\n\nstatic cod_extern_entry limits_externs[] = \n{\n    {NULL, NULL}\n};\n\nstatic char limits_extern_string[] = \"\\n\\\nconst char SCHAR_MAX = 127;\\n\\\nconst char SCHAR_MIN = -128;\\n\\\n\\n\\\nconst unsigned char UCHAR_MAX = 255;\\n\\\nconst char CHAR_MAX = 127;\\n\\\nconst char CHAR_MIN = (-128);\\n\\\n\\n\\\nconst unsigned short USHRT_MAX = 65535;\\n\\\nconst short SHRT_MAX = 32767;\\n\\\nconst short SHRT_MIN = (-32768);\\n\\\n\\n\\\nconst unsigned int\tUINT_MAX = 0xffffffff;\\n\\\nconst int INT_MAX = 2147483647;\\n\\\nconst int INT_MIN = (-2147483647-1);\\n\\\nconst long LONG_MAX = 0x7fffffffffffffffL;\\n\\\nconst long LONG_MIN = (-0x7fffffffffffffffL-1);\\n\\\nconst unsigned long ULONG_MAX = 0xffffffffffffffffUL;\\n\\\n\";\n\n\nstatic void dlload_externs(char *libname, cod_extern_entry *externs);\n\nextern void\ncod_process_include(char *name, cod_parse_context context)\n{\n    int char_count = index(name, '.') - name;\n    if (char_count < 0) char_count = strlen(name);\n    if (strncmp(name, \"string\", char_count) == 0) {\n\tcod_assoc_externs(context, string_externs);\n\tcod_parse_for_context(string_extern_string, context);\n    } else if (strncmp(name, \"strings\", char_count) == 0) {\n\tcod_assoc_externs(context, strings_externs);\n\tcod_parse_for_context(strings_extern_string, context);\n    } else if (strncmp(name, \"math\", char_count) == 0) {\n\tdlload_externs(\"libm\", math_externs);\n\tcod_assoc_externs(context, math_externs);\n\tcod_parse_for_context(math_extern_string, context);\n    } else if (strncmp(name, \"limits\", char_count) == 0) {\n\tcod_parse_for_context(limits_extern_string, context);\n    }\n\n}\n#include <dlfcn.h>\nstatic void \ndlload_externs(char *libname, cod_extern_entry *externs)\n{\n#if NO_DYNAMIC_LINKING\n    return;\n#else\n    int i = 0;\n    char *name = malloc(strlen(libname) + strlen(LIBRARY_EXT) + 1);\n    strcpy(name, libname);\n    strcat(name, LIBRARY_EXT);\n    void *handle = dlopen(name, RTLD_LAZY);\n    free(name);\n    while(externs[i].extern_name) {\n\texterns[i].extern_value = dlsym(handle, externs[i].extern_name);\n\ti++;\n    }\n#endif\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/.git/objects/pack/pack-e9f5c8ac8c8515c7852e01f591692b84bec12184.idx",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/.git/objects/pack/pack-e9f5c8ac8c8515c7852e01f591692b84bec12184.pack",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/tests/tmp.out",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/index_output.raspberrypi.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/file_output.armv6l.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/file_output.ia64.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/file_output.rhe5.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/file_output.rhe5-64.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/context_test_output.rhe5-64-icc.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/context_test_output.rhe6-64.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/file_output.rhe4.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/context_test_output.rhe5-64.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/context_test_output.fc14-64.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/context_test_output.ia64.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/context_test_output.darwin10.8.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/index_output.ppc64.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/file_output.rhe5-64-icc.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/index_output.darwin10.10.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/context_test_output.rhe4-64.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/file_output.osx.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/file_output.sun8-64.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/context_test_output.fc16-64.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/context_test_output.fc14.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/file_output.rhe4-64.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/file_output.fc14-64.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/context_test_output.sun8.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/file_output.rhe6-64.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/context_test_output.sun8-64.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/context_test_output.ub12-64.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/index_output.osx.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/file_output.fc16-64.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/file_output.sun8.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/context_test_output.powerpc64.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/context_test_output.rhe4.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/context_test_output.osx.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/file_output.fc14.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/file_output.powerpc64.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/context_test_output.rhe5.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/file_output.ub12-64.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/context_test_output.arm6l.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/ffs/output_dir/file_output.darwin10.8.bin",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/cod/tests/test_output/t5/t5.sun8-64",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/cod/tests/test_output/t5/t5.ia64",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/cod/tests/test_output/t5/t5.rhe4-64",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/cod/tests/test_output/t5/t5.sun8",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/cod/tests/test_output/t5/t5.rhe4",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/cod/tests/test_output/t1/t1.rhe4-64",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/cod/tests/test_output/t1/t1.ia64",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/cod/tests/test_output/t1/t1.sun8-64",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/cod/tests/test_output/t1/t1.sun8",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/cod/tests/test_output/t1/t1.rhe4",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/doc/server.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/doc/string_mem.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/doc/manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/doc/format_server.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-libffs-develop-fq3xrdbp3tncmmtnsei6scp4xf2jsbzm/spack-src/doc/server.png"
    ],
    "total_files": 234
}