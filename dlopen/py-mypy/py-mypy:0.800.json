{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-mypy-0.800-vulfa6gu6bsx3ah6tkyj74qetamijeij/spack-src/mypy/typeshed/stdlib/3/sys.pyi": "import sys\nfrom builtins import object as _object\nfrom importlib.abc import MetaPathFinder, PathEntryFinder\nfrom types import FrameType, ModuleType, TracebackType\nfrom typing import (\n    Any,\n    AsyncGenerator,\n    Callable,\n    Dict,\n    List,\n    NoReturn,\n    Optional,\n    Sequence,\n    TextIO,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    overload,\n)\n\n_T = TypeVar(\"_T\")\n\n# The following type alias are stub-only and do not exist during runtime\n_ExcInfo = Tuple[Type[BaseException], BaseException, TracebackType]\n_OptExcInfo = Union[_ExcInfo, Tuple[None, None, None]]\n\n# ----- sys variables -----\nif sys.platform != \"win32\":\n    abiflags: str\nargv: List[str]\nbase_exec_prefix: str\nbase_prefix: str\nbyteorder: str\nbuiltin_module_names: Sequence[str]  # actually a tuple of strings\ncopyright: str\nif sys.platform == \"win32\":\n    dllhandle: int\ndont_write_bytecode: bool\ndisplayhook: Callable[[object], Any]\nexcepthook: Callable[[Type[BaseException], BaseException, TracebackType], Any]\nexec_prefix: str\nexecutable: str\nfloat_repr_style: str\nhexversion: int\nlast_type: Optional[Type[BaseException]]\nlast_value: Optional[BaseException]\nlast_traceback: Optional[TracebackType]\nmaxsize: int\nmaxunicode: int\nmeta_path: List[MetaPathFinder]\nmodules: Dict[str, ModuleType]\npath: List[str]\npath_hooks: List[Any]  # TODO precise type; function, path to finder\npath_importer_cache: Dict[str, Optional[PathEntryFinder]]\nplatform: str\nif sys.version_info >= (3, 9):\n    platlibdir: str\nprefix: str\nif sys.version_info >= (3, 8):\n    pycache_prefix: Optional[str]\nps1: str\nps2: str\nstdin: TextIO\nstdout: TextIO\nstderr: TextIO\n__stdin__: TextIO\n__stdout__: TextIO\n__stderr__: TextIO\ntracebacklimit: int\nversion: str\napi_version: int\nwarnoptions: Any\n#  Each entry is a tuple of the form (action, message, category, module,\n#    lineno)\nif sys.platform == \"win32\":\n    winver: str\n_xoptions: Dict[Any, Any]\n\nflags: _flags\n\nclass _flags:\n    debug: int\n    division_warning: int\n    inspect: int\n    interactive: int\n    optimize: int\n    dont_write_bytecode: int\n    no_user_site: int\n    no_site: int\n    ignore_environment: int\n    verbose: int\n    bytes_warning: int\n    quiet: int\n    hash_randomization: int\n    if sys.version_info >= (3, 7):\n        dev_mode: int\n        utf8_mode: int\n\nfloat_info: _float_info\n\nclass _float_info:\n    epsilon: float  # DBL_EPSILON\n    dig: int  # DBL_DIG\n    mant_dig: int  # DBL_MANT_DIG\n    max: float  # DBL_MAX\n    max_exp: int  # DBL_MAX_EXP\n    max_10_exp: int  # DBL_MAX_10_EXP\n    min: float  # DBL_MIN\n    min_exp: int  # DBL_MIN_EXP\n    min_10_exp: int  # DBL_MIN_10_EXP\n    radix: int  # FLT_RADIX\n    rounds: int  # FLT_ROUNDS\n\nhash_info: _hash_info\n\nclass _hash_info:\n    width: int\n    modulus: int\n    inf: int\n    nan: int\n    imag: int\n\nimplementation: _implementation\n\nclass _implementation:\n    name: str\n    version: _version_info\n    hexversion: int\n    cache_tag: str\n\nint_info: _int_info\n\nclass _int_info:\n    bits_per_digit: int\n    sizeof_digit: int\n\nclass _version_info(Tuple[int, int, int, str, int]):\n    major: int\n    minor: int\n    micro: int\n    releaselevel: str\n    serial: int\n\nversion_info: _version_info\n\ndef call_tracing(__func: Callable[..., _T], __args: Any) -> _T: ...\ndef _clear_type_cache() -> None: ...\ndef _current_frames() -> Dict[int, Any]: ...\ndef _debugmallocstats() -> None: ...\ndef __displayhook__(value: object) -> None: ...\ndef __excepthook__(type_: Type[BaseException], value: BaseException, traceback: TracebackType) -> None: ...\ndef exc_info() -> _OptExcInfo: ...\n\n# sys.exit() accepts an optional argument of anything printable\ndef exit(__status: object = ...) -> NoReturn: ...\ndef getdefaultencoding() -> str: ...\n\nif sys.platform != \"win32\":\n    def getdlopenflags() -> int: ...\n\ndef getfilesystemencoding() -> str: ...\ndef getfilesystemencodeerrors() -> str: ...\ndef getrefcount(__object: Any) -> int: ...\ndef getrecursionlimit() -> int: ...\n@overload\ndef getsizeof(obj: object) -> int: ...\n@overload\ndef getsizeof(obj: object, default: int) -> int: ...\ndef getswitchinterval() -> float: ...\ndef _getframe(__depth: int = ...) -> FrameType: ...\n\n_ProfileFunc = Callable[[FrameType, str, Any], Any]\n\ndef getprofile() -> Optional[_ProfileFunc]: ...\ndef setprofile(profilefunc: Optional[_ProfileFunc]) -> None: ...\n\n_TraceFunc = Callable[[FrameType, str, Any], Optional[Callable[[FrameType, str, Any], Any]]]\n\ndef gettrace() -> Optional[_TraceFunc]: ...\ndef settrace(tracefunc: Optional[_TraceFunc]) -> None: ...\n\nclass _WinVersion(Tuple[int, int, int, int, str, int, int, int, int, Tuple[int, int, int]]):\n    major: int\n    minor: int\n    build: int\n    platform: int\n    service_pack: str\n    service_pack_minor: int\n    service_pack_major: int\n    suite_mast: int\n    product_type: int\n    platform_version: Tuple[int, int, int]\n\nif sys.platform == \"win32\":\n    def getwindowsversion() -> _WinVersion: ...\n\ndef intern(__string: str) -> str: ...\ndef is_finalizing() -> bool: ...\n\nif sys.version_info >= (3, 7):\n    __breakpointhook__: Any  # contains the original value of breakpointhook\n    def breakpointhook(*args: Any, **kwargs: Any) -> Any: ...\n\nif sys.platform != \"win32\":\n    def setdlopenflags(__flags: int) -> None: ...\n\ndef setrecursionlimit(__limit: int) -> None: ...\ndef setswitchinterval(__interval: float) -> None: ...\ndef gettotalrefcount() -> int: ...  # Debug builds only\n\nif sys.version_info < (3, 9):\n    def getcheckinterval() -> int: ...  # deprecated\n    def setcheckinterval(__n: int) -> None: ...  # deprecated\n\nif sys.version_info >= (3, 8):\n    # not exported by sys\n    class UnraisableHookArgs:\n        exc_type: Type[BaseException]\n        exc_value: Optional[BaseException]\n        exc_traceback: Optional[TracebackType]\n        err_msg: Optional[str]\n        object: Optional[_object]\n    unraisablehook: Callable[[UnraisableHookArgs], Any]\n    def addaudithook(hook: Callable[[str, Tuple[Any, ...]], Any]) -> None: ...\n    def audit(__event: str, *args: Any) -> None: ...\n\n_AsyncgenHook = Optional[Callable[[AsyncGenerator[Any, Any]], None]]\n\nclass _asyncgen_hooks(Tuple[_AsyncgenHook, _AsyncgenHook]):\n    firstiter: _AsyncgenHook\n    finalizer: _AsyncgenHook\n\ndef get_asyncgen_hooks() -> _asyncgen_hooks: ...\ndef set_asyncgen_hooks(firstiter: _AsyncgenHook = ..., finalizer: _AsyncgenHook = ...) -> None: ...\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-mypy-0.800-vulfa6gu6bsx3ah6tkyj74qetamijeij/spack-src/mypy/typeshed/stdlib/2/sys.pyi": "from types import ClassType, FrameType, ModuleType, TracebackType\nfrom typing import IO, Any, BinaryIO, Callable, Dict, List, NoReturn, Optional, Sequence, Text, Tuple, Type, Union, overload\n\n# The following type alias are stub-only and do not exist during runtime\n_ExcInfo = Tuple[Type[BaseException], BaseException, TracebackType]\n_OptExcInfo = Union[_ExcInfo, Tuple[None, None, None]]\n\nclass _flags:\n    bytes_warning: int\n    debug: int\n    division_new: int\n    division_warning: int\n    dont_write_bytecode: int\n    hash_randomization: int\n    ignore_environment: int\n    inspect: int\n    interactive: int\n    no_site: int\n    no_user_site: int\n    optimize: int\n    py3k_warning: int\n    tabcheck: int\n    unicode: int\n    verbose: int\n\nclass _float_info:\n    max: float\n    max_exp: int\n    max_10_exp: int\n    min: float\n    min_exp: int\n    min_10_exp: int\n    dig: int\n    mant_dig: int\n    epsilon: float\n    radix: int\n    rounds: int\n\nclass _version_info(Tuple[int, int, int, str, int]):\n    major: int\n    minor: int\n    micro: int\n    releaselevel: str\n    serial: int\n\n_mercurial: Tuple[str, str, str]\napi_version: int\nargv: List[str]\nbuiltin_module_names: Tuple[str, ...]\nbyteorder: str\ncopyright: str\ndont_write_bytecode: bool\nexec_prefix: str\nexecutable: str\nflags: _flags\nfloat_repr_style: str\nhexversion: int\nlong_info: object\nmaxint: int\nmaxsize: int\nmaxunicode: int\nmodules: Dict[str, Any]\npath: List[str]\nplatform: str\nprefix: str\npy3kwarning: bool\n__stderr__: IO[str]\n__stdin__: IO[str]\n__stdout__: IO[str]\nstderr: IO[str]\nstdin: IO[str]\nstdout: IO[str]\nsubversion: Tuple[str, str, str]\nversion: str\nwarnoptions: object\nfloat_info: _float_info\nversion_info: _version_info\nps1: str\nps2: str\nlast_type: type\nlast_value: BaseException\nlast_traceback: TracebackType\n# TODO precise types\nmeta_path: List[Any]\npath_hooks: List[Any]\npath_importer_cache: Dict[str, Any]\ndisplayhook: Callable[[object], Any]\nexcepthook: Callable[[Type[BaseException], BaseException, TracebackType], Any]\nexc_type: Optional[type]\nexc_value: Union[BaseException, ClassType]\nexc_traceback: TracebackType\n\nclass _WindowsVersionType:\n    major: Any\n    minor: Any\n    build: Any\n    platform: Any\n    service_pack: Any\n    service_pack_major: Any\n    service_pack_minor: Any\n    suite_mask: Any\n    product_type: Any\n\ndef getwindowsversion() -> _WindowsVersionType: ...\ndef _clear_type_cache() -> None: ...\ndef _current_frames() -> Dict[int, FrameType]: ...\ndef _getframe(depth: int = ...) -> FrameType: ...\ndef call_tracing(fn: Any, args: Any) -> Any: ...\ndef __displayhook__(value: object) -> None: ...\ndef __excepthook__(type_: type, value: BaseException, traceback: TracebackType) -> None: ...\ndef exc_clear() -> None: ...\ndef exc_info() -> _OptExcInfo: ...\n\n# sys.exit() accepts an optional argument of anything printable\ndef exit(arg: Any = ...) -> NoReturn: ...\ndef getcheckinterval() -> int: ...  # deprecated\ndef getdefaultencoding() -> str: ...\ndef getdlopenflags() -> int: ...\ndef getfilesystemencoding() -> str: ...  # In practice, never returns None\ndef getrefcount(arg: Any) -> int: ...\ndef getrecursionlimit() -> int: ...\ndef getsizeof(obj: object, default: int = ...) -> int: ...\ndef getprofile() -> Optional[Any]: ...\ndef gettrace() -> Optional[Any]: ...\ndef setcheckinterval(interval: int) -> None: ...  # deprecated\ndef setdlopenflags(n: int) -> None: ...\ndef setdefaultencoding(encoding: Text) -> None: ...  # only exists after reload(sys)\ndef setprofile(profilefunc: Any) -> None: ...  # TODO type\ndef setrecursionlimit(limit: int) -> None: ...\ndef settrace(tracefunc: Any) -> None: ...  # TODO type\n"
    },
    "skipped": [],
    "total_files": 2073
}