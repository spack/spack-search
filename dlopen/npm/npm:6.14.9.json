{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node-gyp/package/gyp/pylib/gyp/generator/make.py": "# Copyright (c) 2013 Google Inc. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n# Notes:\n#\n# This is all roughly based on the Makefile system used by the Linux\n# kernel, but is a non-recursive make -- we put the entire dependency\n# graph in front of make and let it figure it out.\n#\n# The code below generates a separate .mk file for each target, but\n# all are sourced by the top-level Makefile.  This means that all\n# variables in .mk-files clobber one another.  Be careful to use :=\n# where appropriate for immediate evaluation, and similarly to watch\n# that you're not relying on a variable value to last between different\n# .mk files.\n#\n# TODOs:\n#\n# Global settings and utility functions are currently stuffed in the\n# toplevel Makefile.  It may make sense to generate some .mk files on\n# the side to keep the files readable.\n\nfrom __future__ import print_function\n\nimport os\nimport re\nimport sys\nimport subprocess\nimport gyp\nimport gyp.common\nimport gyp.xcode_emulation\nfrom gyp.common import GetEnvironFallback\nfrom gyp.common import GypError\n\nimport hashlib\n\ngenerator_default_variables = {\n  'EXECUTABLE_PREFIX': '',\n  'EXECUTABLE_SUFFIX': '',\n  'STATIC_LIB_PREFIX': 'lib',\n  'SHARED_LIB_PREFIX': 'lib',\n  'STATIC_LIB_SUFFIX': '.a',\n  'INTERMEDIATE_DIR': '$(obj).$(TOOLSET)/$(TARGET)/geni',\n  'SHARED_INTERMEDIATE_DIR': '$(obj)/gen',\n  'PRODUCT_DIR': '$(builddir)',\n  'RULE_INPUT_ROOT': '%(INPUT_ROOT)s',  # This gets expanded by Python.\n  'RULE_INPUT_DIRNAME': '%(INPUT_DIRNAME)s',  # This gets expanded by Python.\n  'RULE_INPUT_PATH': '$(abspath $<)',\n  'RULE_INPUT_EXT': '$(suffix $<)',\n  'RULE_INPUT_NAME': '$(notdir $<)',\n  'CONFIGURATION_NAME': '$(BUILDTYPE)',\n}\n\n# Make supports multiple toolsets\ngenerator_supports_multiple_toolsets = True\n\n# Request sorted dependencies in the order from dependents to dependencies.\ngenerator_wants_sorted_dependencies = False\n\n# Placates pylint.\ngenerator_additional_non_configuration_keys = []\ngenerator_additional_path_sections = []\ngenerator_extra_sources_for_rules = []\ngenerator_filelist_paths = None\n\n\ndef CalculateVariables(default_variables, params):\n  \"\"\"Calculate additional variables for use in the build (called by gyp).\"\"\"\n  flavor = gyp.common.GetFlavor(params)\n  if flavor == 'mac':\n    default_variables.setdefault('OS', 'mac')\n    default_variables.setdefault('SHARED_LIB_SUFFIX', '.dylib')\n    default_variables.setdefault('SHARED_LIB_DIR',\n                                 generator_default_variables['PRODUCT_DIR'])\n    default_variables.setdefault('LIB_DIR',\n                                 generator_default_variables['PRODUCT_DIR'])\n\n    # Copy additional generator configuration data from Xcode, which is shared\n    # by the Mac Make generator.\n    import gyp.generator.xcode as xcode_generator\n    global generator_additional_non_configuration_keys\n    generator_additional_non_configuration_keys = getattr(xcode_generator,\n        'generator_additional_non_configuration_keys', [])\n    global generator_additional_path_sections\n    generator_additional_path_sections = getattr(xcode_generator,\n        'generator_additional_path_sections', [])\n    global generator_extra_sources_for_rules\n    generator_extra_sources_for_rules = getattr(xcode_generator,\n        'generator_extra_sources_for_rules', [])\n    COMPILABLE_EXTENSIONS.update({'.m': 'objc', '.mm' : 'objcxx'})\n  else:\n    operating_system = flavor\n    if flavor == 'android':\n      operating_system = 'linux'  # Keep this legacy behavior for now.\n    default_variables.setdefault('OS', operating_system)\n    if flavor == 'aix':\n      default_variables.setdefault('SHARED_LIB_SUFFIX', '.a')\n    else:\n      default_variables.setdefault('SHARED_LIB_SUFFIX', '.so')\n    default_variables.setdefault('SHARED_LIB_DIR','$(builddir)/lib.$(TOOLSET)')\n    default_variables.setdefault('LIB_DIR', '$(obj).$(TOOLSET)')\n\n\ndef CalculateGeneratorInputInfo(params):\n  \"\"\"Calculate the generator specific info that gets fed to input (called by\n  gyp).\"\"\"\n  generator_flags = params.get('generator_flags', {})\n  android_ndk_version = generator_flags.get('android_ndk_version', None)\n  # Android NDK requires a strict link order.\n  if android_ndk_version:\n    global generator_wants_sorted_dependencies\n    generator_wants_sorted_dependencies = True\n\n  output_dir = params['options'].generator_output or \\\n               params['options'].toplevel_dir\n  builddir_name = generator_flags.get('output_dir', 'out')\n  qualified_out_dir = os.path.normpath(os.path.join(\n    output_dir, builddir_name, 'gypfiles'))\n\n  global generator_filelist_paths\n  generator_filelist_paths = {\n    'toplevel': params['options'].toplevel_dir,\n    'qualified_out_dir': qualified_out_dir,\n  }\n\n\n# The .d checking code below uses these functions:\n# wildcard, sort, foreach, shell, wordlist\n# wildcard can handle spaces, the rest can't.\n# Since I could find no way to make foreach work with spaces in filenames\n# correctly, the .d files have spaces replaced with another character. The .d\n# file for\n#     Chromium\\ Framework.framework/foo\n# is for example\n#     out/Release/.deps/out/Release/Chromium?Framework.framework/foo\n# This is the replacement character.\nSPACE_REPLACEMENT = '?'\n\n\nLINK_COMMANDS_LINUX = \"\"\"\\\nquiet_cmd_alink = AR($(TOOLSET)) $@\ncmd_alink = rm -f $@ && $(AR.$(TOOLSET)) crs $@ $(filter %.o,$^)\n\nquiet_cmd_alink_thin = AR($(TOOLSET)) $@\ncmd_alink_thin = rm -f $@ && $(AR.$(TOOLSET)) crsT $@ $(filter %.o,$^)\n\n# Due to circular dependencies between libraries :(, we wrap the\n# special \"figure out circular dependencies\" flags around the entire\n# input list during linking.\nquiet_cmd_link = LINK($(TOOLSET)) $@\ncmd_link = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ -Wl,--start-group $(LD_INPUTS) $(LIBS) -Wl,--end-group\n\n# We support two kinds of shared objects (.so):\n# 1) shared_library, which is just bundling together many dependent libraries\n# into a link line.\n# 2) loadable_module, which is generating a module intended for dlopen().\n#\n# They differ only slightly:\n# In the former case, we want to package all dependent code into the .so.\n# In the latter case, we want to package just the API exposed by the\n# outermost module.\n# This means shared_library uses --whole-archive, while loadable_module doesn't.\n# (Note that --whole-archive is incompatible with the --start-group used in\n# normal linking.)\n\n# Other shared-object link notes:\n# - Set SONAME to the library filename so our binaries don't reference\n# the local, absolute paths used on the link command-line.\nquiet_cmd_solink = SOLINK($(TOOLSET)) $@\ncmd_solink = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ -Wl,--whole-archive $(LD_INPUTS) -Wl,--no-whole-archive $(LIBS)\n\nquiet_cmd_solink_module = SOLINK_MODULE($(TOOLSET)) $@\ncmd_solink_module = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ -Wl,--start-group $(filter-out FORCE_DO_CMD, $^) -Wl,--end-group $(LIBS)\n\"\"\"\n\nLINK_COMMANDS_MAC = \"\"\"\\\nquiet_cmd_alink = LIBTOOL-STATIC $@\ncmd_alink = rm -f $@ && ./gyp-mac-tool filter-libtool libtool $(GYP_LIBTOOLFLAGS) -static -o $@ $(filter %.o,$^)\n\nquiet_cmd_link = LINK($(TOOLSET)) $@\ncmd_link = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o \"$@\" $(LD_INPUTS) $(LIBS)\n\nquiet_cmd_solink = SOLINK($(TOOLSET)) $@\ncmd_solink = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o \"$@\" $(LD_INPUTS) $(LIBS)\n\nquiet_cmd_solink_module = SOLINK_MODULE($(TOOLSET)) $@\ncmd_solink_module = $(LINK.$(TOOLSET)) -bundle $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(filter-out FORCE_DO_CMD, $^) $(LIBS)\n\"\"\"\n\nLINK_COMMANDS_ANDROID = \"\"\"\\\nquiet_cmd_alink = AR($(TOOLSET)) $@\ncmd_alink = rm -f $@ && $(AR.$(TOOLSET)) crs $@ $(filter %.o,$^)\n\nquiet_cmd_alink_thin = AR($(TOOLSET)) $@\ncmd_alink_thin = rm -f $@ && $(AR.$(TOOLSET)) crsT $@ $(filter %.o,$^)\n\n# Due to circular dependencies between libraries :(, we wrap the\n# special \"figure out circular dependencies\" flags around the entire\n# input list during linking.\nquiet_cmd_link = LINK($(TOOLSET)) $@\nquiet_cmd_link_host = LINK($(TOOLSET)) $@\ncmd_link = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ -Wl,--start-group $(LD_INPUTS) -Wl,--end-group $(LIBS)\ncmd_link_host = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(LD_INPUTS) $(LIBS)\n\n# Other shared-object link notes:\n# - Set SONAME to the library filename so our binaries don't reference\n# the local, absolute paths used on the link command-line.\nquiet_cmd_solink = SOLINK($(TOOLSET)) $@\ncmd_solink = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ -Wl,--whole-archive $(LD_INPUTS) -Wl,--no-whole-archive $(LIBS)\n\nquiet_cmd_solink_module = SOLINK_MODULE($(TOOLSET)) $@\ncmd_solink_module = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ -Wl,--start-group $(filter-out FORCE_DO_CMD, $^) -Wl,--end-group $(LIBS)\nquiet_cmd_solink_module_host = SOLINK_MODULE($(TOOLSET)) $@\ncmd_solink_module_host = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ $(filter-out FORCE_DO_CMD, $^) $(LIBS)\n\"\"\"\n\n\nLINK_COMMANDS_AIX = \"\"\"\\\nquiet_cmd_alink = AR($(TOOLSET)) $@\ncmd_alink = rm -f $@ && $(AR.$(TOOLSET)) -X32_64 crs $@ $(filter %.o,$^)\n\nquiet_cmd_alink_thin = AR($(TOOLSET)) $@\ncmd_alink_thin = rm -f $@ && $(AR.$(TOOLSET)) -X32_64 crs $@ $(filter %.o,$^)\n\nquiet_cmd_link = LINK($(TOOLSET)) $@\ncmd_link = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(LD_INPUTS) $(LIBS)\n\nquiet_cmd_solink = SOLINK($(TOOLSET)) $@\ncmd_solink = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(LD_INPUTS) $(LIBS)\n\nquiet_cmd_solink_module = SOLINK_MODULE($(TOOLSET)) $@\ncmd_solink_module = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(filter-out FORCE_DO_CMD, $^) $(LIBS)\n\"\"\"\n\n\nLINK_COMMANDS_OS390 = \"\"\"\\\nquiet_cmd_alink = AR($(TOOLSET)) $@\ncmd_alink = rm -f $@ && $(AR.$(TOOLSET)) crs $@ $(filter %.o,$^)\n\nquiet_cmd_alink_thin = AR($(TOOLSET)) $@\ncmd_alink_thin = rm -f $@ && $(AR.$(TOOLSET)) crsT $@ $(filter %.o,$^)\n\nquiet_cmd_link = LINK($(TOOLSET)) $@\ncmd_link = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(LD_INPUTS) $(LIBS)\n\nquiet_cmd_solink = SOLINK($(TOOLSET)) $@\ncmd_solink = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(LD_INPUTS) $(LIBS) -Wl,DLL\n\nquiet_cmd_solink_module = SOLINK_MODULE($(TOOLSET)) $@\ncmd_solink_module = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(filter-out FORCE_DO_CMD, $^) $(LIBS) -Wl,DLL\n\n\"\"\"\n\n\n# Header of toplevel Makefile.\n# This should go into the build tree, but it's easier to keep it here for now.\nSHARED_HEADER = (\"\"\"\\\n# We borrow heavily from the kernel build setup, though we are simpler since\n# we don't have Kconfig tweaking settings on us.\n\n# The implicit make rules have it looking for RCS files, among other things.\n# We instead explicitly write all the rules we care about.\n# It's even quicker (saves ~200ms) to pass -r on the command line.\nMAKEFLAGS=-r\n\n# The source directory tree.\nsrcdir := %(srcdir)s\nabs_srcdir := $(abspath $(srcdir))\n\n# The name of the builddir.\nbuilddir_name ?= %(builddir)s\n\n# The V=1 flag on command line makes us verbosely print command lines.\nifdef V\n  quiet=\nelse\n  quiet=quiet_\nendif\n\n# Specify BUILDTYPE=Release on the command line for a release build.\nBUILDTYPE ?= %(default_configuration)s\n\n# Directory all our build output goes into.\n# Note that this must be two directories beneath src/ for unit tests to pass,\n# as they reach into the src/ directory for data with relative paths.\nbuilddir ?= $(builddir_name)/$(BUILDTYPE)\nabs_builddir := $(abspath $(builddir))\ndepsdir := $(builddir)/.deps\n\n# Object output directory.\nobj := $(builddir)/obj\nabs_obj := $(abspath $(obj))\n\n# We build up a list of every single one of the targets so we can slurp in the\n# generated dependency rule Makefiles in one pass.\nall_deps :=\n\n%(make_global_settings)s\n\nCC.target ?= %(CC.target)s\nCFLAGS.target ?= $(CPPFLAGS) $(CFLAGS)\nCXX.target ?= %(CXX.target)s\nCXXFLAGS.target ?= $(CPPFLAGS) $(CXXFLAGS)\nLINK.target ?= %(LINK.target)s\nLDFLAGS.target ?= $(LDFLAGS)\nAR.target ?= $(AR)\n\n# C++ apps need to be linked with g++.\nLINK ?= $(CXX.target)\n\n# TODO(evan): move all cross-compilation logic to gyp-time so we don't need\n# to replicate this environment fallback in make as well.\nCC.host ?= %(CC.host)s\nCFLAGS.host ?= $(CPPFLAGS_host) $(CFLAGS_host)\nCXX.host ?= %(CXX.host)s\nCXXFLAGS.host ?= $(CPPFLAGS_host) $(CXXFLAGS_host)\nLINK.host ?= %(LINK.host)s\nLDFLAGS.host ?=\nAR.host ?= %(AR.host)s\n\n# Define a dir function that can handle spaces.\n# http://www.gnu.org/software/make/manual/make.html#Syntax-of-Functions\n# \"leading spaces cannot appear in the text of the first argument as written.\n# These characters can be put into the argument value by variable substitution.\"\nempty :=\nspace := $(empty) $(empty)\n\n# http://stackoverflow.com/questions/1189781/using-make-dir-or-notdir-on-a-path-with-spaces\nreplace_spaces = $(subst $(space),\"\"\" + SPACE_REPLACEMENT + \"\"\",$1)\nunreplace_spaces = $(subst \"\"\" + SPACE_REPLACEMENT + \"\"\",$(space),$1)\ndirx = $(call unreplace_spaces,$(dir $(call replace_spaces,$1)))\n\n# Flags to make gcc output dependency info.  Note that you need to be\n# careful here to use the flags that ccache and distcc can understand.\n# We write to a dep file on the side first and then rename at the end\n# so we can't end up with a broken dep file.\ndepfile = $(depsdir)/$(call replace_spaces,$@).d\nDEPFLAGS = %(makedep_args)s -MF $(depfile).raw\n\n# We have to fixup the deps output in a few ways.\n# (1) the file output should mention the proper .o file.\n# ccache or distcc lose the path to the target, so we convert a rule of\n# the form:\n#   foobar.o: DEP1 DEP2\n# into\n#   path/to/foobar.o: DEP1 DEP2\n# (2) we want missing files not to cause us to fail to build.\n# We want to rewrite\n#   foobar.o: DEP1 DEP2 \\\\\n#               DEP3\n# to\n#   DEP1:\n#   DEP2:\n#   DEP3:\n# so if the files are missing, they're just considered phony rules.\n# We have to do some pretty insane escaping to get those backslashes\n# and dollar signs past make, the shell, and sed at the same time.\n# Doesn't work with spaces, but that's fine: .d files have spaces in\n# their names replaced with other characters.\"\"\"\nr\"\"\"\ndefine fixup_dep\n# The depfile may not exist if the input file didn't have any #includes.\ntouch $(depfile).raw\n# Fixup path as in (1).\nsed -e \"s|^$(notdir $@)|$@|\" $(depfile).raw >> $(depfile)\n# Add extra rules as in (2).\n# We remove slashes and replace spaces with new lines;\n# remove blank lines;\n# delete the first line and append a colon to the remaining lines.\nsed -e 's|\\\\||' -e 'y| |\\n|' $(depfile).raw |\\\n  grep -v '^$$'                             |\\\n  sed -e 1d -e 's|$$|:|'                     \\\n    >> $(depfile)\nrm $(depfile).raw\nendef\n\"\"\"\n\"\"\"\n# Command definitions:\n# - cmd_foo is the actual command to run;\n# - quiet_cmd_foo is the brief-output summary of the command.\n\nquiet_cmd_cc = CC($(TOOLSET)) $@\ncmd_cc = $(CC.$(TOOLSET)) $(GYP_CFLAGS) $(DEPFLAGS) $(CFLAGS.$(TOOLSET)) -c -o $@ $<\n\nquiet_cmd_cxx = CXX($(TOOLSET)) $@\ncmd_cxx = $(CXX.$(TOOLSET)) $(GYP_CXXFLAGS) $(DEPFLAGS) $(CXXFLAGS.$(TOOLSET)) -c -o $@ $<\n%(extra_commands)s\nquiet_cmd_touch = TOUCH $@\ncmd_touch = touch $@\n\nquiet_cmd_copy = COPY $@\n# send stderr to /dev/null to ignore messages when linking directories.\ncmd_copy = rm -rf \"$@\" && cp %(copy_archive_args)s \"$<\" \"$@\"\n\n%(link_commands)s\n\"\"\"\n\nr\"\"\"\n# Define an escape_quotes function to escape single quotes.\n# This allows us to handle quotes properly as long as we always use\n# use single quotes and escape_quotes.\nescape_quotes = $(subst ','\\'',$(1))\n# This comment is here just to include a ' to unconfuse syntax highlighting.\n# Define an escape_vars function to escape '$' variable syntax.\n# This allows us to read/write command lines with shell variables (e.g.\n# $LD_LIBRARY_PATH), without triggering make substitution.\nescape_vars = $(subst $$,$$$$,$(1))\n# Helper that expands to a shell command to echo a string exactly as it is in\n# make. This uses printf instead of echo because printf's behaviour with respect\n# to escape sequences is more portable than echo's across different shells\n# (e.g., dash, bash).\nexact_echo = printf '%%s\\n' '$(call escape_quotes,$(1))'\n\"\"\"\n\"\"\"\n# Helper to compare the command we're about to run against the command\n# we logged the last time we ran the command.  Produces an empty\n# string (false) when the commands match.\n# Tricky point: Make has no string-equality test function.\n# The kernel uses the following, but it seems like it would have false\n# positives, where one string reordered its arguments.\n#   arg_check = $(strip $(filter-out $(cmd_$(1)), $(cmd_$@)) \\\\\n#                       $(filter-out $(cmd_$@), $(cmd_$(1))))\n# We instead substitute each for the empty string into the other, and\n# say they're equal if both substitutions produce the empty string.\n# .d files contain \"\"\" + SPACE_REPLACEMENT + \\\n                   \"\"\" instead of spaces, take that into account.\ncommand_changed = $(or $(subst $(cmd_$(1)),,$(cmd_$(call replace_spaces,$@))),\\\\\n                       $(subst $(cmd_$(call replace_spaces,$@)),,$(cmd_$(1))))\n\n# Helper that is non-empty when a prerequisite changes.\n# Normally make does this implicitly, but we force rules to always run\n# so we can check their command lines.\n#   $? -- new prerequisites\n#   $| -- order-only dependencies\nprereq_changed = $(filter-out FORCE_DO_CMD,$(filter-out $|,$?))\n\n# Helper that executes all postbuilds until one fails.\ndefine do_postbuilds\n  @E=0;\\\\\n  for p in $(POSTBUILDS); do\\\\\n    eval $$p;\\\\\n    E=$$?;\\\\\n    if [ $$E -ne 0 ]; then\\\\\n      break;\\\\\n    fi;\\\\\n  done;\\\\\n  if [ $$E -ne 0 ]; then\\\\\n    rm -rf \"$@\";\\\\\n    exit $$E;\\\\\n  fi\nendef\n\n# do_cmd: run a command via the above cmd_foo names, if necessary.\n# Should always run for a given target to handle command-line changes.\n# Second argument, if non-zero, makes it do asm/C/C++ dependency munging.\n# Third argument, if non-zero, makes it do POSTBUILDS processing.\n# Note: We intentionally do NOT call dirx for depfile, since it contains \"\"\" + \\\n                                                     SPACE_REPLACEMENT + \"\"\" for\n# spaces already and dirx strips the \"\"\" + SPACE_REPLACEMENT + \\\n                                     \"\"\" characters.\ndefine do_cmd\n$(if $(or $(command_changed),$(prereq_changed)),\n  @$(call exact_echo,  $($(quiet)cmd_$(1)))\n  @mkdir -p \"$(call dirx,$@)\" \"$(dir $(depfile))\"\n  $(if $(findstring flock,$(word %(flock_index)d,$(cmd_$1))),\n    @$(cmd_$(1))\n    @echo \"  $(quiet_cmd_$(1)): Finished\",\n    @$(cmd_$(1))\n  )\n  @$(call exact_echo,$(call escape_vars,cmd_$(call replace_spaces,$@) := $(cmd_$(1)))) > $(depfile)\n  @$(if $(2),$(fixup_dep))\n  $(if $(and $(3), $(POSTBUILDS)),\n    $(call do_postbuilds)\n  )\n)\nendef\n\n# Declare the \"%(default_target)s\" target first so it is the default,\n# even though we don't have the deps yet.\n.PHONY: %(default_target)s\n%(default_target)s:\n\n# make looks for ways to re-generate included makefiles, but in our case, we\n# don't have a direct way. Explicitly telling make that it has nothing to do\n# for them makes it go faster.\n%%.d: ;\n\n# Use FORCE_DO_CMD to force a target to run.  Should be coupled with\n# do_cmd.\n.PHONY: FORCE_DO_CMD\nFORCE_DO_CMD:\n\n\"\"\")\n\nSHARED_HEADER_MAC_COMMANDS = \"\"\"\nquiet_cmd_objc = CXX($(TOOLSET)) $@\ncmd_objc = $(CC.$(TOOLSET)) $(GYP_OBJCFLAGS) $(DEPFLAGS) -c -o $@ $<\n\nquiet_cmd_objcxx = CXX($(TOOLSET)) $@\ncmd_objcxx = $(CXX.$(TOOLSET)) $(GYP_OBJCXXFLAGS) $(DEPFLAGS) -c -o $@ $<\n\n# Commands for precompiled header files.\nquiet_cmd_pch_c = CXX($(TOOLSET)) $@\ncmd_pch_c = $(CC.$(TOOLSET)) $(GYP_PCH_CFLAGS) $(DEPFLAGS) $(CXXFLAGS.$(TOOLSET)) -c -o $@ $<\nquiet_cmd_pch_cc = CXX($(TOOLSET)) $@\ncmd_pch_cc = $(CC.$(TOOLSET)) $(GYP_PCH_CXXFLAGS) $(DEPFLAGS) $(CXXFLAGS.$(TOOLSET)) -c -o $@ $<\nquiet_cmd_pch_m = CXX($(TOOLSET)) $@\ncmd_pch_m = $(CC.$(TOOLSET)) $(GYP_PCH_OBJCFLAGS) $(DEPFLAGS) -c -o $@ $<\nquiet_cmd_pch_mm = CXX($(TOOLSET)) $@\ncmd_pch_mm = $(CC.$(TOOLSET)) $(GYP_PCH_OBJCXXFLAGS) $(DEPFLAGS) -c -o $@ $<\n\n# gyp-mac-tool is written next to the root Makefile by gyp.\n# Use $(4) for the command, since $(2) and $(3) are used as flag by do_cmd\n# already.\nquiet_cmd_mac_tool = MACTOOL $(4) $<\ncmd_mac_tool = ./gyp-mac-tool $(4) $< \"$@\"\n\nquiet_cmd_mac_package_framework = PACKAGE FRAMEWORK $@\ncmd_mac_package_framework = ./gyp-mac-tool package-framework \"$@\" $(4)\n\nquiet_cmd_infoplist = INFOPLIST $@\ncmd_infoplist = $(CC.$(TOOLSET)) -E -P -Wno-trigraphs -x c $(INFOPLIST_DEFINES) \"$<\" -o \"$@\"\n\"\"\"\n\n\ndef WriteRootHeaderSuffixRules(writer):\n  extensions = sorted(COMPILABLE_EXTENSIONS.keys(), key=str.lower)\n\n  writer.write('# Suffix rules, putting all outputs into $(obj).\\n')\n  for ext in extensions:\n    writer.write('$(obj).$(TOOLSET)/%%.o: $(srcdir)/%%%s FORCE_DO_CMD\\n' % ext)\n    writer.write('\\t@$(call do_cmd,%s,1)\\n' % COMPILABLE_EXTENSIONS[ext])\n\n  writer.write('\\n# Try building from generated source, too.\\n')\n  for ext in extensions:\n    writer.write(\n        '$(obj).$(TOOLSET)/%%.o: $(obj).$(TOOLSET)/%%%s FORCE_DO_CMD\\n' % ext)\n    writer.write('\\t@$(call do_cmd,%s,1)\\n' % COMPILABLE_EXTENSIONS[ext])\n  writer.write('\\n')\n  for ext in extensions:\n    writer.write('$(obj).$(TOOLSET)/%%.o: $(obj)/%%%s FORCE_DO_CMD\\n' % ext)\n    writer.write('\\t@$(call do_cmd,%s,1)\\n' % COMPILABLE_EXTENSIONS[ext])\n  writer.write('\\n')\n\n\nSHARED_HEADER_SUFFIX_RULES_COMMENT1 = (\"\"\"\\\n# Suffix rules, putting all outputs into $(obj).\n\"\"\")\n\n\nSHARED_HEADER_SUFFIX_RULES_COMMENT2 = (\"\"\"\\\n# Try building from generated source, too.\n\"\"\")\n\n\nSHARED_FOOTER = \"\"\"\\\n# \"all\" is a concatenation of the \"all\" targets from all the included\n# sub-makefiles. This is just here to clarify.\nall:\n\n# Add in dependency-tracking rules.  $(all_deps) is the list of every single\n# target in our tree. Only consider the ones with .d (dependency) info:\nd_files := $(wildcard $(foreach f,$(all_deps),$(depsdir)/$(f).d))\nifneq ($(d_files),)\n  include $(d_files)\nendif\n\"\"\"\n\nheader = \"\"\"\\\n# This file is generated by gyp; do not edit.\n\n\"\"\"\n\n# Maps every compilable file extension to the do_cmd that compiles it.\nCOMPILABLE_EXTENSIONS = {\n  '.c': 'cc',\n  '.cc': 'cxx',\n  '.cpp': 'cxx',\n  '.cxx': 'cxx',\n  '.s': 'cc',\n  '.S': 'cc',\n}\n\ndef Compilable(filename):\n  \"\"\"Return true if the file is compilable (should be in OBJS).\"\"\"\n  for res in (filename.endswith(e) for e in COMPILABLE_EXTENSIONS):\n    if res:\n      return True\n  return False\n\n\ndef Linkable(filename):\n  \"\"\"Return true if the file is linkable (should be on the link line).\"\"\"\n  return filename.endswith('.o')\n\n\ndef Target(filename):\n  \"\"\"Translate a compilable filename to its .o target.\"\"\"\n  return os.path.splitext(filename)[0] + '.o'\n\n\ndef EscapeShellArgument(s):\n  \"\"\"Quotes an argument so that it will be interpreted literally by a POSIX\n     shell. Taken from\n     http://stackoverflow.com/questions/35817/whats-the-best-way-to-escape-ossystem-calls-in-python\n     \"\"\"\n  return \"'\" + s.replace(\"'\", \"'\\\\''\") + \"'\"\n\n\ndef EscapeMakeVariableExpansion(s):\n  \"\"\"Make has its own variable expansion syntax using $. We must escape it for\n     string to be interpreted literally.\"\"\"\n  return s.replace('$', '$$')\n\n\ndef EscapeCppDefine(s):\n  \"\"\"Escapes a CPP define so that it will reach the compiler unaltered.\"\"\"\n  s = EscapeShellArgument(s)\n  s = EscapeMakeVariableExpansion(s)\n  # '#' characters must be escaped even embedded in a string, else Make will\n  # treat it as the start of a comment.\n  return s.replace('#', r'\\#')\n\n\ndef QuoteIfNecessary(string):\n  \"\"\"TODO: Should this ideally be replaced with one or more of the above\n     functions?\"\"\"\n  if '\"' in string:\n    string = '\"' + string.replace('\"', '\\\\\"') + '\"'\n  return string\n\n\ndef StringToMakefileVariable(string):\n  \"\"\"Convert a string to a value that is acceptable as a make variable name.\"\"\"\n  return re.sub('[^a-zA-Z0-9_]', '_', string)\n\n\nsrcdir_prefix = ''\ndef Sourceify(path):\n  \"\"\"Convert a path to its source directory form.\"\"\"\n  if '$(' in path:\n    return path\n  if os.path.isabs(path):\n    return path\n  return srcdir_prefix + path\n\n\ndef QuoteSpaces(s, quote=r'\\ '):\n  return s.replace(' ', quote)\n\ndef SourceifyAndQuoteSpaces(path):\n  \"\"\"Convert a path to its source directory form and quote spaces.\"\"\"\n  return QuoteSpaces(Sourceify(path))\n\n# TODO: Avoid code duplication with _ValidateSourcesForMSVSProject in msvs.py.\ndef _ValidateSourcesForOSX(spec, all_sources):\n  \"\"\"Makes sure if duplicate basenames are not specified in the source list.\n\n  Arguments:\n    spec: The target dictionary containing the properties of the target.\n  \"\"\"\n  if spec.get('type', None) != 'static_library':\n    return\n\n  basenames = {}\n  for source in all_sources:\n    name, ext = os.path.splitext(source)\n    is_compiled_file = ext in [\n        '.c', '.cc', '.cpp', '.cxx', '.m', '.mm', '.s', '.S']\n    if not is_compiled_file:\n      continue\n    basename = os.path.basename(name)  # Don't include extension.\n    basenames.setdefault(basename, []).append(source)\n\n  error = ''\n  for basename, files in basenames.items():\n    if len(files) > 1:\n      error += '  %s: %s\\n' % (basename, ' '.join(files))\n\n  if error:\n    print(('static library %s has several files with the same basename:\\n' % spec['target_name'])\n           + error + 'libtool on OS X will generate' + ' warnings for them.')\n    raise GypError('Duplicate basenames in sources section, see list above')\n\n\n# Map from qualified target to path to output.\ntarget_outputs = {}\n# Map from qualified target to any linkable output.  A subset\n# of target_outputs.  E.g. when mybinary depends on liba, we want to\n# include liba in the linker line; when otherbinary depends on\n# mybinary, we just want to build mybinary first.\ntarget_link_deps = {}\n\n\nclass MakefileWriter(object):\n  \"\"\"MakefileWriter packages up the writing of one target-specific foobar.mk.\n\n  Its only real entry point is Write(), and is mostly used for namespacing.\n  \"\"\"\n\n  def __init__(self, generator_flags, flavor):\n    self.generator_flags = generator_flags\n    self.flavor = flavor\n\n    self.suffix_rules_srcdir = {}\n    self.suffix_rules_objdir1 = {}\n    self.suffix_rules_objdir2 = {}\n\n    # Generate suffix rules for all compilable extensions.\n    for ext in COMPILABLE_EXTENSIONS.keys():\n      # Suffix rules for source folder.\n      self.suffix_rules_srcdir.update({ext: (\"\"\"\\\n$(obj).$(TOOLSET)/$(TARGET)/%%.o: $(srcdir)/%%%s FORCE_DO_CMD\n\t@$(call do_cmd,%s,1)\n\"\"\" % (ext, COMPILABLE_EXTENSIONS[ext]))})\n\n      # Suffix rules for generated source files.\n      self.suffix_rules_objdir1.update({ext: (\"\"\"\\\n$(obj).$(TOOLSET)/$(TARGET)/%%.o: $(obj).$(TOOLSET)/%%%s FORCE_DO_CMD\n\t@$(call do_cmd,%s,1)\n\"\"\" % (ext, COMPILABLE_EXTENSIONS[ext]))})\n      self.suffix_rules_objdir2.update({ext: (\"\"\"\\\n$(obj).$(TOOLSET)/$(TARGET)/%%.o: $(obj)/%%%s FORCE_DO_CMD\n\t@$(call do_cmd,%s,1)\n\"\"\" % (ext, COMPILABLE_EXTENSIONS[ext]))})\n\n\n  def Write(self, qualified_target, base_path, output_filename, spec, configs,\n            part_of_all):\n    \"\"\"The main entry point: writes a .mk file for a single target.\n\n    Arguments:\n      qualified_target: target we're generating\n      base_path: path relative to source root we're building in, used to resolve\n                 target-relative paths\n      output_filename: output .mk file name to write\n      spec, configs: gyp info\n      part_of_all: flag indicating this target is part of 'all'\n    \"\"\"\n    gyp.common.EnsureDirExists(output_filename)\n\n    self.fp = open(output_filename, 'w')\n\n    self.fp.write(header)\n\n    self.qualified_target = qualified_target\n    self.path = base_path\n    self.target = spec['target_name']\n    self.type = spec['type']\n    self.toolset = spec['toolset']\n\n    self.is_mac_bundle = gyp.xcode_emulation.IsMacBundle(self.flavor, spec)\n    if self.flavor == 'mac':\n      self.xcode_settings = gyp.xcode_emulation.XcodeSettings(spec)\n    else:\n      self.xcode_settings = None\n\n    deps, link_deps = self.ComputeDeps(spec)\n\n    # Some of the generation below can add extra output, sources, or\n    # link dependencies.  All of the out params of the functions that\n    # follow use names like extra_foo.\n    extra_outputs = []\n    extra_sources = []\n    extra_link_deps = []\n    extra_mac_bundle_resources = []\n    mac_bundle_deps = []\n\n    if self.is_mac_bundle:\n      self.output = self.ComputeMacBundleOutput(spec)\n      self.output_binary = self.ComputeMacBundleBinaryOutput(spec)\n    else:\n      self.output = self.output_binary = self.ComputeOutput(spec)\n\n    self.is_standalone_static_library = bool(\n        spec.get('standalone_static_library', 0))\n    self._INSTALLABLE_TARGETS = ('executable', 'loadable_module',\n                                 'shared_library')\n    if (self.is_standalone_static_library or\n        self.type in self._INSTALLABLE_TARGETS):\n      self.alias = os.path.basename(self.output)\n      install_path = self._InstallableTargetInstallPath()\n    else:\n      self.alias = self.output\n      install_path = self.output\n\n    self.WriteLn(\"TOOLSET := \" + self.toolset)\n    self.WriteLn(\"TARGET := \" + self.target)\n\n    # Actions must come first, since they can generate more OBJs for use below.\n    if 'actions' in spec:\n      self.WriteActions(spec['actions'], extra_sources, extra_outputs,\n                        extra_mac_bundle_resources, part_of_all)\n\n    # Rules must be early like actions.\n    if 'rules' in spec:\n      self.WriteRules(spec['rules'], extra_sources, extra_outputs,\n                      extra_mac_bundle_resources, part_of_all)\n\n    if 'copies' in spec:\n      self.WriteCopies(spec['copies'], extra_outputs, part_of_all)\n\n    # Bundle resources.\n    if self.is_mac_bundle:\n      all_mac_bundle_resources = (\n          spec.get('mac_bundle_resources', []) + extra_mac_bundle_resources)\n      self.WriteMacBundleResources(all_mac_bundle_resources, mac_bundle_deps)\n      self.WriteMacInfoPlist(mac_bundle_deps)\n\n    # Sources.\n    all_sources = spec.get('sources', []) + extra_sources\n    if all_sources:\n      if self.flavor == 'mac':\n        # libtool on OS X generates warnings for duplicate basenames in the same\n        # target.\n        _ValidateSourcesForOSX(spec, all_sources)\n      self.WriteSources(\n          configs, deps, all_sources, extra_outputs,\n          extra_link_deps, part_of_all,\n          gyp.xcode_emulation.MacPrefixHeader(\n              self.xcode_settings, lambda p: Sourceify(self.Absolutify(p)),\n              self.Pchify))\n      sources = list(filter(Compilable, all_sources))\n      if sources:\n        self.WriteLn(SHARED_HEADER_SUFFIX_RULES_COMMENT1)\n        extensions = set([os.path.splitext(s)[1] for s in sources])\n        for ext in extensions:\n          if ext in self.suffix_rules_srcdir:\n            self.WriteLn(self.suffix_rules_srcdir[ext])\n        self.WriteLn(SHARED_HEADER_SUFFIX_RULES_COMMENT2)\n        for ext in extensions:\n          if ext in self.suffix_rules_objdir1:\n            self.WriteLn(self.suffix_rules_objdir1[ext])\n        for ext in extensions:\n          if ext in self.suffix_rules_objdir2:\n            self.WriteLn(self.suffix_rules_objdir2[ext])\n        self.WriteLn('# End of this set of suffix rules')\n\n        # Add dependency from bundle to bundle binary.\n        if self.is_mac_bundle:\n          mac_bundle_deps.append(self.output_binary)\n\n    self.WriteTarget(spec, configs, deps, extra_link_deps + link_deps,\n                     mac_bundle_deps, extra_outputs, part_of_all)\n\n    # Update global list of target outputs, used in dependency tracking.\n    target_outputs[qualified_target] = install_path\n\n    # Update global list of link dependencies.\n    if self.type in ('static_library', 'shared_library'):\n      target_link_deps[qualified_target] = self.output_binary\n\n    # Currently any versions have the same effect, but in future the behavior\n    # could be different.\n    if self.generator_flags.get('android_ndk_version', None):\n      self.WriteAndroidNdkModuleRule(self.target, all_sources, link_deps)\n\n    self.fp.close()\n\n\n  def WriteSubMake(self, output_filename, makefile_path, targets, build_dir):\n    \"\"\"Write a \"sub-project\" Makefile.\n\n    This is a small, wrapper Makefile that calls the top-level Makefile to build\n    the targets from a single gyp file (i.e. a sub-project).\n\n    Arguments:\n      output_filename: sub-project Makefile name to write\n      makefile_path: path to the top-level Makefile\n      targets: list of \"all\" targets for this sub-project\n      build_dir: build output directory, relative to the sub-project\n    \"\"\"\n    gyp.common.EnsureDirExists(output_filename)\n    self.fp = open(output_filename, 'w')\n    self.fp.write(header)\n    # For consistency with other builders, put sub-project build output in the\n    # sub-project dir (see test/subdirectory/gyptest-subdir-all.py).\n    self.WriteLn('export builddir_name ?= %s' %\n                 os.path.join(os.path.dirname(output_filename), build_dir))\n    self.WriteLn('.PHONY: all')\n    self.WriteLn('all:')\n    if makefile_path:\n      makefile_path = ' -C ' + makefile_path\n    self.WriteLn('\\t$(MAKE)%s %s' % (makefile_path, ' '.join(targets)))\n    self.fp.close()\n\n\n  def WriteActions(self, actions, extra_sources, extra_outputs,\n                   extra_mac_bundle_resources, part_of_all):\n    \"\"\"Write Makefile code for any 'actions' from the gyp input.\n\n    extra_sources: a list that will be filled in with newly generated source\n                   files, if any\n    extra_outputs: a list that will be filled in with any outputs of these\n                   actions (used to make other pieces dependent on these\n                   actions)\n    part_of_all: flag indicating this target is part of 'all'\n    \"\"\"\n    env = self.GetSortedXcodeEnv()\n    for action in actions:\n      name = StringToMakefileVariable('%s_%s' % (self.qualified_target,\n                                                 action['action_name']))\n      self.WriteLn('### Rules for action \"%s\":' % action['action_name'])\n      inputs = action['inputs']\n      outputs = action['outputs']\n\n      # Build up a list of outputs.\n      # Collect the output dirs we'll need.\n      dirs = set()\n      for out in outputs:\n        dir = os.path.split(out)[0]\n        if dir:\n          dirs.add(dir)\n      if int(action.get('process_outputs_as_sources', False)):\n        extra_sources += outputs\n      if int(action.get('process_outputs_as_mac_bundle_resources', False)):\n        extra_mac_bundle_resources += outputs\n\n      # Write the actual command.\n      action_commands = action['action']\n      if self.flavor == 'mac':\n        action_commands = [gyp.xcode_emulation.ExpandEnvVars(command, env)\n                          for command in action_commands]\n      command = gyp.common.EncodePOSIXShellList(action_commands)\n      if 'message' in action:\n        self.WriteLn('quiet_cmd_%s = ACTION %s $@' % (name, action['message']))\n      else:\n        self.WriteLn('quiet_cmd_%s = ACTION %s $@' % (name, name))\n      if len(dirs) > 0:\n        command = 'mkdir -p %s' % ' '.join(dirs) + '; ' + command\n\n      cd_action = 'cd %s; ' % Sourceify(self.path or '.')\n\n      # command and cd_action get written to a toplevel variable called\n      # cmd_foo. Toplevel variables can't handle things that change per\n      # makefile like $(TARGET), so hardcode the target.\n      command = command.replace('$(TARGET)', self.target)\n      cd_action = cd_action.replace('$(TARGET)', self.target)\n\n      # Set LD_LIBRARY_PATH in case the action runs an executable from this\n      # build which links to shared libs from this build.\n      # actions run on the host, so they should in theory only use host\n      # libraries, but until everything is made cross-compile safe, also use\n      # target libraries.\n      # TODO(piman): when everything is cross-compile safe, remove lib.target\n      self.WriteLn('cmd_%s = LD_LIBRARY_PATH=$(builddir)/lib.host:'\n                   '$(builddir)/lib.target:$$LD_LIBRARY_PATH; '\n                   'export LD_LIBRARY_PATH; '\n                   '%s%s'\n                   % (name, cd_action, command))\n      self.WriteLn()\n      outputs = [self.Absolutify(output) for output in outputs]\n      # The makefile rules are all relative to the top dir, but the gyp actions\n      # are defined relative to their containing dir.  This replaces the obj\n      # variable for the action rule with an absolute version so that the output\n      # goes in the right place.\n      # Only write the 'obj' and 'builddir' rules for the \"primary\" output (:1);\n      # it's superfluous for the \"extra outputs\", and this avoids accidentally\n      # writing duplicate dummy rules for those outputs.\n      # Same for environment.\n      self.WriteLn(\"%s: obj := $(abs_obj)\" % QuoteSpaces(outputs[0]))\n      self.WriteLn(\"%s: builddir := $(abs_builddir)\" % QuoteSpaces(outputs[0]))\n      self.WriteSortedXcodeEnv(outputs[0], self.GetSortedXcodeEnv())\n\n      for input in inputs:\n        assert ' ' not in input, (\n            \"Spaces in action input filenames not supported (%s)\"  % input)\n      for output in outputs:\n        assert ' ' not in output, (\n            \"Spaces in action output filenames not supported (%s)\"  % output)\n\n      # See the comment in WriteCopies about expanding env vars.\n      outputs = [gyp.xcode_emulation.ExpandEnvVars(o, env) for o in outputs]\n      inputs = [gyp.xcode_emulation.ExpandEnvVars(i, env) for i in inputs]\n\n      self.WriteDoCmd(outputs, [Sourceify(self.Absolutify(i)) for i in inputs],\n                      part_of_all=part_of_all, command=name)\n\n      # Stuff the outputs in a variable so we can refer to them later.\n      outputs_variable = 'action_%s_outputs' % name\n      self.WriteLn('%s := %s' % (outputs_variable, ' '.join(outputs)))\n      extra_outputs.append('$(%s)' % outputs_variable)\n      self.WriteLn()\n\n    self.WriteLn()\n\n\n  def WriteRules(self, rules, extra_sources, extra_outputs,\n                 extra_mac_bundle_resources, part_of_all):\n    \"\"\"Write Makefile code for any 'rules' from the gyp input.\n\n    extra_sources: a list that will be filled in with newly generated source\n                   files, if any\n    extra_outputs: a list that will be filled in with any outputs of these\n                   rules (used to make other pieces dependent on these rules)\n    part_of_all: flag indicating this target is part of 'all'\n    \"\"\"\n    env = self.GetSortedXcodeEnv()\n    for rule in rules:\n      name = StringToMakefileVariable('%s_%s' % (self.qualified_target,\n                                                 rule['rule_name']))\n      count = 0\n      self.WriteLn('### Generated for rule %s:' % name)\n\n      all_outputs = []\n\n      for rule_source in rule.get('rule_sources', []):\n        dirs = set()\n        (rule_source_dirname, rule_source_basename) = os.path.split(rule_source)\n        (rule_source_root, rule_source_ext) = \\\n            os.path.splitext(rule_source_basename)\n\n        outputs = [self.ExpandInputRoot(out, rule_source_root,\n                                        rule_source_dirname)\n                   for out in rule['outputs']]\n\n        for out in outputs:\n          dir = os.path.dirname(out)\n          if dir:\n            dirs.add(dir)\n        if int(rule.get('process_outputs_as_sources', False)):\n          extra_sources += outputs\n        if int(rule.get('process_outputs_as_mac_bundle_resources', False)):\n          extra_mac_bundle_resources += outputs\n        inputs = [Sourceify(self.Absolutify(i)) for i\n                  in [rule_source] + rule.get('inputs', [])]\n        actions = ['$(call do_cmd,%s_%d)' % (name, count)]\n\n        if name == 'resources_grit':\n          # HACK: This is ugly.  Grit intentionally doesn't touch the\n          # timestamp of its output file when the file doesn't change,\n          # which is fine in hash-based dependency systems like scons\n          # and forge, but not kosher in the make world.  After some\n          # discussion, hacking around it here seems like the least\n          # amount of pain.\n          actions += ['@touch --no-create $@']\n\n        # See the comment in WriteCopies about expanding env vars.\n        outputs = [gyp.xcode_emulation.ExpandEnvVars(o, env) for o in outputs]\n        inputs = [gyp.xcode_emulation.ExpandEnvVars(i, env) for i in inputs]\n\n        outputs = [self.Absolutify(output) for output in outputs]\n        all_outputs += outputs\n        # Only write the 'obj' and 'builddir' rules for the \"primary\" output\n        # (:1); it's superfluous for the \"extra outputs\", and this avoids\n        # accidentally writing duplicate dummy rules for those outputs.\n        self.WriteLn('%s: obj := $(abs_obj)' % outputs[0])\n        self.WriteLn('%s: builddir := $(abs_builddir)' % outputs[0])\n        self.WriteMakeRule(outputs, inputs, actions,\n                           command=\"%s_%d\" % (name, count))\n        # Spaces in rule filenames are not supported, but rule variables have\n        # spaces in them (e.g. RULE_INPUT_PATH expands to '$(abspath $<)').\n        # The spaces within the variables are valid, so remove the variables\n        # before checking.\n        variables_with_spaces = re.compile(r'\\$\\([^ ]* \\$<\\)')\n        for output in outputs:\n          output = re.sub(variables_with_spaces, '', output)\n          assert ' ' not in output, (\n              \"Spaces in rule filenames not yet supported (%s)\"  % output)\n        self.WriteLn('all_deps += %s' % ' '.join(outputs))\n\n        action = [self.ExpandInputRoot(ac, rule_source_root,\n                                       rule_source_dirname)\n                  for ac in rule['action']]\n        mkdirs = ''\n        if len(dirs) > 0:\n          mkdirs = 'mkdir -p %s; ' % ' '.join(dirs)\n        cd_action = 'cd %s; ' % Sourceify(self.path or '.')\n\n        # action, cd_action, and mkdirs get written to a toplevel variable\n        # called cmd_foo. Toplevel variables can't handle things that change\n        # per makefile like $(TARGET), so hardcode the target.\n        if self.flavor == 'mac':\n          action = [gyp.xcode_emulation.ExpandEnvVars(command, env)\n                    for command in action]\n        action = gyp.common.EncodePOSIXShellList(action)\n        action = action.replace('$(TARGET)', self.target)\n        cd_action = cd_action.replace('$(TARGET)', self.target)\n        mkdirs = mkdirs.replace('$(TARGET)', self.target)\n\n        # Set LD_LIBRARY_PATH in case the rule runs an executable from this\n        # build which links to shared libs from this build.\n        # rules run on the host, so they should in theory only use host\n        # libraries, but until everything is made cross-compile safe, also use\n        # target libraries.\n        # TODO(piman): when everything is cross-compile safe, remove lib.target\n        self.WriteLn(\n            \"cmd_%(name)s_%(count)d = LD_LIBRARY_PATH=\"\n              \"$(builddir)/lib.host:$(builddir)/lib.target:$$LD_LIBRARY_PATH; \"\n              \"export LD_LIBRARY_PATH; \"\n              \"%(cd_action)s%(mkdirs)s%(action)s\" % {\n          'action': action,\n          'cd_action': cd_action,\n          'count': count,\n          'mkdirs': mkdirs,\n          'name': name,\n        })\n        self.WriteLn(\n            'quiet_cmd_%(name)s_%(count)d = RULE %(name)s_%(count)d $@' % {\n          'count': count,\n          'name': name,\n        })\n        self.WriteLn()\n        count += 1\n\n      outputs_variable = 'rule_%s_outputs' % name\n      self.WriteList(all_outputs, outputs_variable)\n      extra_outputs.append('$(%s)' % outputs_variable)\n\n      self.WriteLn('### Finished generating for rule: %s' % name)\n      self.WriteLn()\n    self.WriteLn('### Finished generating for all rules')\n    self.WriteLn('')\n\n\n  def WriteCopies(self, copies, extra_outputs, part_of_all):\n    \"\"\"Write Makefile code for any 'copies' from the gyp input.\n\n    extra_outputs: a list that will be filled in with any outputs of this action\n                   (used to make other pieces dependent on this action)\n    part_of_all: flag indicating this target is part of 'all'\n    \"\"\"\n    self.WriteLn('### Generated for copy rule.')\n\n    variable = StringToMakefileVariable(self.qualified_target + '_copies')\n    outputs = []\n    for copy in copies:\n      for path in copy['files']:\n        # Absolutify() may call normpath, and will strip trailing slashes.\n        path = Sourceify(self.Absolutify(path))\n        filename = os.path.split(path)[1]\n        output = Sourceify(self.Absolutify(os.path.join(copy['destination'],\n                                                        filename)))\n\n        # If the output path has variables in it, which happens in practice for\n        # 'copies', writing the environment as target-local doesn't work,\n        # because the variables are already needed for the target name.\n        # Copying the environment variables into global make variables doesn't\n        # work either, because then the .d files will potentially contain spaces\n        # after variable expansion, and .d file handling cannot handle spaces.\n        # As a workaround, manually expand variables at gyp time. Since 'copies'\n        # can't run scripts, there's no need to write the env then.\n        # WriteDoCmd() will escape spaces for .d files.\n        env = self.GetSortedXcodeEnv()\n        output = gyp.xcode_emulation.ExpandEnvVars(output, env)\n        path = gyp.xcode_emulation.ExpandEnvVars(path, env)\n        self.WriteDoCmd([output], [path], 'copy', part_of_all)\n        outputs.append(output)\n    self.WriteLn('%s = %s' % (variable, ' '.join(QuoteSpaces(o) for o in outputs)))\n    extra_outputs.append('$(%s)' % variable)\n    self.WriteLn()\n\n\n  def WriteMacBundleResources(self, resources, bundle_deps):\n    \"\"\"Writes Makefile code for 'mac_bundle_resources'.\"\"\"\n    self.WriteLn('### Generated for mac_bundle_resources')\n\n    for output, res in gyp.xcode_emulation.GetMacBundleResources(\n        generator_default_variables['PRODUCT_DIR'], self.xcode_settings,\n        [Sourceify(self.Absolutify(r)) for r in resources]):\n      _, ext = os.path.splitext(output)\n      if ext != '.xcassets':\n        # Make does not supports '.xcassets' emulation.\n        self.WriteDoCmd([output], [res], 'mac_tool,,,copy-bundle-resource',\n                        part_of_all=True)\n        bundle_deps.append(output)\n\n\n  def WriteMacInfoPlist(self, bundle_deps):\n    \"\"\"Write Makefile code for bundle Info.plist files.\"\"\"\n    info_plist, out, defines, extra_env = gyp.xcode_emulation.GetMacInfoPlist(\n        generator_default_variables['PRODUCT_DIR'], self.xcode_settings,\n        lambda p: Sourceify(self.Absolutify(p)))\n    if not info_plist:\n      return\n    if defines:\n      # Create an intermediate file to store preprocessed results.\n      intermediate_plist = ('$(obj).$(TOOLSET)/$(TARGET)/' +\n          os.path.basename(info_plist))\n      self.WriteList(defines, intermediate_plist + ': INFOPLIST_DEFINES', '-D',\n          quoter=EscapeCppDefine)\n      self.WriteMakeRule([intermediate_plist], [info_plist],\n          ['$(call do_cmd,infoplist)',\n           # \"Convert\" the plist so that any weird whitespace changes from the\n           # preprocessor do not affect the XML parser in mac_tool.\n           '@plutil -convert xml1 $@ $@'])\n      info_plist = intermediate_plist\n    # plists can contain envvars and substitute them into the file.\n    self.WriteSortedXcodeEnv(\n        out, self.GetSortedXcodeEnv(additional_settings=extra_env))\n    self.WriteDoCmd([out], [info_plist], 'mac_tool,,,copy-info-plist',\n                    part_of_all=True)\n    bundle_deps.append(out)\n\n\n  def WriteSources(self, configs, deps, sources,\n                   extra_outputs, extra_link_deps,\n                   part_of_all, precompiled_header):\n    \"\"\"Write Makefile code for any 'sources' from the gyp input.\n    These are source files necessary to build the current target.\n\n    configs, deps, sources: input from gyp.\n    extra_outputs: a list of extra outputs this action should be dependent on;\n                   used to serialize action/rules before compilation\n    extra_link_deps: a list that will be filled in with any outputs of\n                     compilation (to be used in link lines)\n    part_of_all: flag indicating this target is part of 'all'\n    \"\"\"\n\n    # Write configuration-specific variables for CFLAGS, etc.\n    for configname in sorted(configs.keys()):\n      config = configs[configname]\n      self.WriteList(config.get('defines'), 'DEFS_%s' % configname, prefix='-D',\n          quoter=EscapeCppDefine)\n\n      if self.flavor == 'mac':\n        cflags = self.xcode_settings.GetCflags(configname)\n        cflags_c = self.xcode_settings.GetCflagsC(configname)\n        cflags_cc = self.xcode_settings.GetCflagsCC(configname)\n        cflags_objc = self.xcode_settings.GetCflagsObjC(configname)\n        cflags_objcc = self.xcode_settings.GetCflagsObjCC(configname)\n      else:\n        cflags = config.get('cflags')\n        cflags_c = config.get('cflags_c')\n        cflags_cc = config.get('cflags_cc')\n\n      self.WriteLn(\"# Flags passed to all source files.\")\n      self.WriteList(cflags, 'CFLAGS_%s' % configname)\n      self.WriteLn(\"# Flags passed to only C files.\")\n      self.WriteList(cflags_c, 'CFLAGS_C_%s' % configname)\n      self.WriteLn(\"# Flags passed to only C++ files.\")\n      self.WriteList(cflags_cc, 'CFLAGS_CC_%s' % configname)\n      if self.flavor == 'mac':\n        self.WriteLn(\"# Flags passed to only ObjC files.\")\n        self.WriteList(cflags_objc, 'CFLAGS_OBJC_%s' % configname)\n        self.WriteLn(\"# Flags passed to only ObjC++ files.\")\n        self.WriteList(cflags_objcc, 'CFLAGS_OBJCC_%s' % configname)\n      includes = config.get('include_dirs')\n      if includes:\n        includes = [Sourceify(self.Absolutify(i)) for i in includes]\n      self.WriteList(includes, 'INCS_%s' % configname, prefix='-I')\n\n    compilable = list(filter(Compilable, sources))\n    objs = [self.Objectify(self.Absolutify(Target(c))) for c in compilable]\n    self.WriteList(objs, 'OBJS')\n\n    for obj in objs:\n      assert ' ' not in obj, (\n          \"Spaces in object filenames not supported (%s)\"  % obj)\n    self.WriteLn('# Add to the list of files we specially track '\n                 'dependencies for.')\n    self.WriteLn('all_deps += $(OBJS)')\n    self.WriteLn()\n\n    # Make sure our dependencies are built first.\n    if deps:\n      self.WriteMakeRule(['$(OBJS)'], deps,\n                         comment = 'Make sure our dependencies are built '\n                                   'before any of us.',\n                         order_only = True)\n\n    # Make sure the actions and rules run first.\n    # If they generate any extra headers etc., the per-.o file dep tracking\n    # will catch the proper rebuilds, so order only is still ok here.\n    if extra_outputs:\n      self.WriteMakeRule(['$(OBJS)'], extra_outputs,\n                         comment = 'Make sure our actions/rules run '\n                                   'before any of us.',\n                         order_only = True)\n\n    pchdeps = precompiled_header.GetObjDependencies(compilable, objs )\n    if pchdeps:\n      self.WriteLn('# Dependencies from obj files to their precompiled headers')\n      for source, obj, gch in pchdeps:\n        self.WriteLn('%s: %s' % (obj, gch))\n      self.WriteLn('# End precompiled header dependencies')\n\n    if objs:\n      extra_link_deps.append('$(OBJS)')\n      self.WriteLn(\"\"\"\\\n# CFLAGS et al overrides must be target-local.\n# See \"Target-specific Variable Values\" in the GNU Make manual.\"\"\")\n      self.WriteLn(\"$(OBJS): TOOLSET := $(TOOLSET)\")\n      self.WriteLn(\"$(OBJS): GYP_CFLAGS := \"\n                   \"$(DEFS_$(BUILDTYPE)) \"\n                   \"$(INCS_$(BUILDTYPE)) \"\n                   \"%s \" % precompiled_header.GetInclude('c') +\n                   \"$(CFLAGS_$(BUILDTYPE)) \"\n                   \"$(CFLAGS_C_$(BUILDTYPE))\")\n      self.WriteLn(\"$(OBJS): GYP_CXXFLAGS := \"\n                   \"$(DEFS_$(BUILDTYPE)) \"\n                   \"$(INCS_$(BUILDTYPE)) \"\n                   \"%s \" % precompiled_header.GetInclude('cc') +\n                   \"$(CFLAGS_$(BUILDTYPE)) \"\n                   \"$(CFLAGS_CC_$(BUILDTYPE))\")\n      if self.flavor == 'mac':\n        self.WriteLn(\"$(OBJS): GYP_OBJCFLAGS := \"\n                     \"$(DEFS_$(BUILDTYPE)) \"\n                     \"$(INCS_$(BUILDTYPE)) \"\n                     \"%s \" % precompiled_header.GetInclude('m') +\n                     \"$(CFLAGS_$(BUILDTYPE)) \"\n                     \"$(CFLAGS_C_$(BUILDTYPE)) \"\n                     \"$(CFLAGS_OBJC_$(BUILDTYPE))\")\n        self.WriteLn(\"$(OBJS): GYP_OBJCXXFLAGS := \"\n                     \"$(DEFS_$(BUILDTYPE)) \"\n                     \"$(INCS_$(BUILDTYPE)) \"\n                     \"%s \" % precompiled_header.GetInclude('mm') +\n                     \"$(CFLAGS_$(BUILDTYPE)) \"\n                     \"$(CFLAGS_CC_$(BUILDTYPE)) \"\n                     \"$(CFLAGS_OBJCC_$(BUILDTYPE))\")\n\n    self.WritePchTargets(precompiled_header.GetPchBuildCommands())\n\n    # If there are any object files in our input file list, link them into our\n    # output.\n    extra_link_deps += list(filter(Linkable, sources))\n\n    self.WriteLn()\n\n  def WritePchTargets(self, pch_commands):\n    \"\"\"Writes make rules to compile prefix headers.\"\"\"\n    if not pch_commands:\n      return\n\n    for gch, lang_flag, lang, input in pch_commands:\n      extra_flags = {\n        'c': '$(CFLAGS_C_$(BUILDTYPE))',\n        'cc': '$(CFLAGS_CC_$(BUILDTYPE))',\n        'm': '$(CFLAGS_C_$(BUILDTYPE)) $(CFLAGS_OBJC_$(BUILDTYPE))',\n        'mm': '$(CFLAGS_CC_$(BUILDTYPE)) $(CFLAGS_OBJCC_$(BUILDTYPE))',\n      }[lang]\n      var_name = {\n        'c': 'GYP_PCH_CFLAGS',\n        'cc': 'GYP_PCH_CXXFLAGS',\n        'm': 'GYP_PCH_OBJCFLAGS',\n        'mm': 'GYP_PCH_OBJCXXFLAGS',\n      }[lang]\n      self.WriteLn(\"%s: %s := %s \" % (gch, var_name, lang_flag) +\n                   \"$(DEFS_$(BUILDTYPE)) \"\n                   \"$(INCS_$(BUILDTYPE)) \"\n                   \"$(CFLAGS_$(BUILDTYPE)) \" +\n                   extra_flags)\n\n      self.WriteLn('%s: %s FORCE_DO_CMD' % (gch, input))\n      self.WriteLn('\\t@$(call do_cmd,pch_%s,1)' % lang)\n      self.WriteLn('')\n      assert ' ' not in gch, (\n          \"Spaces in gch filenames not supported (%s)\"  % gch)\n      self.WriteLn('all_deps += %s' % gch)\n      self.WriteLn('')\n\n\n  def ComputeOutputBasename(self, spec):\n    \"\"\"Return the 'output basename' of a gyp spec.\n\n    E.g., the loadable module 'foobar' in directory 'baz' will produce\n      'libfoobar.so'\n    \"\"\"\n    assert not self.is_mac_bundle\n\n    if self.flavor == 'mac' and self.type in (\n        'static_library', 'executable', 'shared_library', 'loadable_module'):\n      return self.xcode_settings.GetExecutablePath()\n\n    target = spec['target_name']\n    target_prefix = ''\n    target_ext = ''\n    if self.type == 'static_library':\n      if target[:3] == 'lib':\n        target = target[3:]\n      target_prefix = 'lib'\n      target_ext = '.a'\n    elif self.type in ('loadable_module', 'shared_library'):\n      if target[:3] == 'lib':\n        target = target[3:]\n      target_prefix = 'lib'\n      if self.flavor == 'aix':\n        target_ext = '.a'\n      else:\n        target_ext = '.so'\n    elif self.type == 'none':\n      target = '%s.stamp' % target\n    elif self.type != 'executable':\n      print(\"ERROR: What output file should be generated?\",\n             \"type\", self.type, \"target\", target)\n\n    target_prefix = spec.get('product_prefix', target_prefix)\n    target = spec.get('product_name', target)\n    product_ext = spec.get('product_extension')\n    if product_ext:\n      target_ext = '.' + product_ext\n\n    return target_prefix + target + target_ext\n\n\n  def _InstallImmediately(self):\n    return self.toolset == 'target' and self.flavor == 'mac' and self.type in (\n          'static_library', 'executable', 'shared_library', 'loadable_module')\n\n\n  def ComputeOutput(self, spec):\n    \"\"\"Return the 'output' (full output path) of a gyp spec.\n\n    E.g., the loadable module 'foobar' in directory 'baz' will produce\n      '$(obj)/baz/libfoobar.so'\n    \"\"\"\n    assert not self.is_mac_bundle\n\n    path = os.path.join('$(obj).' + self.toolset, self.path)\n    if self.type == 'executable' or self._InstallImmediately():\n      path = '$(builddir)'\n    path = spec.get('product_dir', path)\n    return os.path.join(path, self.ComputeOutputBasename(spec))\n\n\n  def ComputeMacBundleOutput(self, spec):\n    \"\"\"Return the 'output' (full output path) to a bundle output directory.\"\"\"\n    assert self.is_mac_bundle\n    path = generator_default_variables['PRODUCT_DIR']\n    return os.path.join(path, self.xcode_settings.GetWrapperName())\n\n\n  def ComputeMacBundleBinaryOutput(self, spec):\n    \"\"\"Return the 'output' (full output path) to the binary in a bundle.\"\"\"\n    path = generator_default_variables['PRODUCT_DIR']\n    return os.path.join(path, self.xcode_settings.GetExecutablePath())\n\n\n  def ComputeDeps(self, spec):\n    \"\"\"Compute the dependencies of a gyp spec.\n\n    Returns a tuple (deps, link_deps), where each is a list of\n    filenames that will need to be put in front of make for either\n    building (deps) or linking (link_deps).\n    \"\"\"\n    deps = []\n    link_deps = []\n    if 'dependencies' in spec:\n      deps.extend([target_outputs[dep] for dep in spec['dependencies']\n                   if target_outputs[dep]])\n      for dep in spec['dependencies']:\n        if dep in target_link_deps:\n          link_deps.append(target_link_deps[dep])\n      deps.extend(link_deps)\n      # TODO: It seems we need to transitively link in libraries (e.g. -lfoo)?\n      # This hack makes it work:\n      # link_deps.extend(spec.get('libraries', []))\n    return (gyp.common.uniquer(deps), gyp.common.uniquer(link_deps))\n\n\n  def WriteDependencyOnExtraOutputs(self, target, extra_outputs):\n    self.WriteMakeRule([self.output_binary], extra_outputs,\n                       comment = 'Build our special outputs first.',\n                       order_only = True)\n\n\n  def WriteTarget(self, spec, configs, deps, link_deps, bundle_deps,\n                  extra_outputs, part_of_all):\n    \"\"\"Write Makefile code to produce the final target of the gyp spec.\n\n    spec, configs: input from gyp.\n    deps, link_deps: dependency lists; see ComputeDeps()\n    extra_outputs: any extra outputs that our target should depend on\n    part_of_all: flag indicating this target is part of 'all'\n    \"\"\"\n\n    self.WriteLn('### Rules for final target.')\n\n    if extra_outputs:\n      self.WriteDependencyOnExtraOutputs(self.output_binary, extra_outputs)\n      self.WriteMakeRule(extra_outputs, deps,\n                         comment=('Preserve order dependency of '\n                                  'special output on deps.'),\n                         order_only = True)\n\n    target_postbuilds = {}\n    if self.type != 'none':\n      for configname in sorted(configs.keys()):\n        config = configs[configname]\n        if self.flavor == 'mac':\n          ldflags = self.xcode_settings.GetLdflags(configname,\n              generator_default_variables['PRODUCT_DIR'],\n              lambda p: Sourceify(self.Absolutify(p)))\n\n          # TARGET_POSTBUILDS_$(BUILDTYPE) is added to postbuilds later on.\n          gyp_to_build = gyp.common.InvertRelativePath(self.path)\n          target_postbuild = self.xcode_settings.AddImplicitPostbuilds(\n              configname,\n              QuoteSpaces(os.path.normpath(os.path.join(gyp_to_build,\n                                                        self.output))),\n              QuoteSpaces(os.path.normpath(os.path.join(gyp_to_build,\n                                                        self.output_binary))))\n          if target_postbuild:\n            target_postbuilds[configname] = target_postbuild\n        else:\n          ldflags = config.get('ldflags', [])\n          # Compute an rpath for this output if needed.\n          if any(dep.endswith('.so') or '.so.' in dep for dep in deps):\n            # We want to get the literal string \"$ORIGIN\" into the link command,\n            # so we need lots of escaping.\n            ldflags.append(r'-Wl,-rpath=\\$$ORIGIN/lib.%s/' % self.toolset)\n            ldflags.append(r'-Wl,-rpath-link=\\$(builddir)/lib.%s/' %\n                           self.toolset)\n        library_dirs = config.get('library_dirs', [])\n        ldflags += [('-L%s' % library_dir) for library_dir in library_dirs]\n        self.WriteList(ldflags, 'LDFLAGS_%s' % configname)\n        if self.flavor == 'mac':\n          self.WriteList(self.xcode_settings.GetLibtoolflags(configname),\n                         'LIBTOOLFLAGS_%s' % configname)\n      libraries = spec.get('libraries')\n      if libraries:\n        # Remove duplicate entries\n        libraries = gyp.common.uniquer(libraries)\n        if self.flavor == 'mac':\n          libraries = self.xcode_settings.AdjustLibraries(libraries)\n      self.WriteList(libraries, 'LIBS')\n      self.WriteLn('%s: GYP_LDFLAGS := $(LDFLAGS_$(BUILDTYPE))' %\n          QuoteSpaces(self.output_binary))\n      self.WriteLn('%s: LIBS := $(LIBS)' % QuoteSpaces(self.output_binary))\n\n      if self.flavor == 'mac':\n        self.WriteLn('%s: GYP_LIBTOOLFLAGS := $(LIBTOOLFLAGS_$(BUILDTYPE))' %\n            QuoteSpaces(self.output_binary))\n\n    # Postbuild actions. Like actions, but implicitly depend on the target's\n    # output.\n    postbuilds = []\n    if self.flavor == 'mac':\n      if target_postbuilds:\n        postbuilds.append('$(TARGET_POSTBUILDS_$(BUILDTYPE))')\n      postbuilds.extend(\n          gyp.xcode_emulation.GetSpecPostbuildCommands(spec))\n\n    if postbuilds:\n      # Envvars may be referenced by TARGET_POSTBUILDS_$(BUILDTYPE),\n      # so we must output its definition first, since we declare variables\n      # using \":=\".\n      self.WriteSortedXcodeEnv(self.output, self.GetSortedXcodePostbuildEnv())\n\n      for configname in target_postbuilds:\n        self.WriteLn('%s: TARGET_POSTBUILDS_%s := %s' %\n            (QuoteSpaces(self.output),\n             configname,\n             gyp.common.EncodePOSIXShellList(target_postbuilds[configname])))\n\n      # Postbuilds expect to be run in the gyp file's directory, so insert an\n      # implicit postbuild to cd to there.\n      postbuilds.insert(0, gyp.common.EncodePOSIXShellList(['cd', self.path]))\n      for i in range(len(postbuilds)):\n        if not postbuilds[i].startswith('$'):\n          postbuilds[i] = EscapeShellArgument(postbuilds[i])\n      self.WriteLn('%s: builddir := $(abs_builddir)' % QuoteSpaces(self.output))\n      self.WriteLn('%s: POSTBUILDS := %s' % (\n          QuoteSpaces(self.output), ' '.join(postbuilds)))\n\n    # A bundle directory depends on its dependencies such as bundle resources\n    # and bundle binary. When all dependencies have been built, the bundle\n    # needs to be packaged.\n    if self.is_mac_bundle:\n      # If the framework doesn't contain a binary, then nothing depends\n      # on the actions -- make the framework depend on them directly too.\n      self.WriteDependencyOnExtraOutputs(self.output, extra_outputs)\n\n      # Bundle dependencies. Note that the code below adds actions to this\n      # target, so if you move these two lines, move the lines below as well.\n      self.WriteList([QuoteSpaces(dep) for dep in bundle_deps], 'BUNDLE_DEPS')\n      self.WriteLn('%s: $(BUNDLE_DEPS)' % QuoteSpaces(self.output))\n\n      # After the framework is built, package it. Needs to happen before\n      # postbuilds, since postbuilds depend on this.\n      if self.type in ('shared_library', 'loadable_module'):\n        self.WriteLn('\\t@$(call do_cmd,mac_package_framework,,,%s)' %\n            self.xcode_settings.GetFrameworkVersion())\n\n      # Bundle postbuilds can depend on the whole bundle, so run them after\n      # the bundle is packaged, not already after the bundle binary is done.\n      if postbuilds:\n        self.WriteLn('\\t@$(call do_postbuilds)')\n      postbuilds = []  # Don't write postbuilds for target's output.\n\n      # Needed by test/mac/gyptest-rebuild.py.\n      self.WriteLn('\\t@true  # No-op, used by tests')\n\n      # Since this target depends on binary and resources which are in\n      # nested subfolders, the framework directory will be older than\n      # its dependencies usually. To prevent this rule from executing\n      # on every build (expensive, especially with postbuilds), expliclity\n      # update the time on the framework directory.\n      self.WriteLn('\\t@touch -c %s' % QuoteSpaces(self.output))\n\n    if postbuilds:\n      assert not self.is_mac_bundle, ('Postbuilds for bundles should be done '\n          'on the bundle, not the binary (target \\'%s\\')' % self.target)\n      assert 'product_dir' not in spec, ('Postbuilds do not work with '\n          'custom product_dir')\n\n    if self.type == 'executable':\n      self.WriteLn('%s: LD_INPUTS := %s' % (\n          QuoteSpaces(self.output_binary),\n          ' '.join(QuoteSpaces(dep) for dep in link_deps)))\n      if self.toolset == 'host' and self.flavor == 'android':\n        self.WriteDoCmd([self.output_binary], link_deps, 'link_host',\n                        part_of_all, postbuilds=postbuilds)\n      else:\n        self.WriteDoCmd([self.output_binary], link_deps, 'link', part_of_all,\n                        postbuilds=postbuilds)\n\n    elif self.type == 'static_library':\n      for link_dep in link_deps:\n        assert ' ' not in link_dep, (\n            \"Spaces in alink input filenames not supported (%s)\"  % link_dep)\n      if (self.flavor not in ('mac', 'openbsd', 'netbsd', 'win') and not\n          self.is_standalone_static_library):\n        self.WriteDoCmd([self.output_binary], link_deps, 'alink_thin',\n                        part_of_all, postbuilds=postbuilds)\n      else:\n        self.WriteDoCmd([self.output_binary], link_deps, 'alink', part_of_all,\n                        postbuilds=postbuilds)\n    elif self.type == 'shared_library':\n      self.WriteLn('%s: LD_INPUTS := %s' % (\n            QuoteSpaces(self.output_binary),\n            ' '.join(QuoteSpaces(dep) for dep in link_deps)))\n      self.WriteDoCmd([self.output_binary], link_deps, 'solink', part_of_all,\n                      postbuilds=postbuilds)\n    elif self.type == 'loadable_module':\n      for link_dep in link_deps:\n        assert ' ' not in link_dep, (\n            \"Spaces in module input filenames not supported (%s)\"  % link_dep)\n      if self.toolset == 'host' and self.flavor == 'android':\n        self.WriteDoCmd([self.output_binary], link_deps, 'solink_module_host',\n                        part_of_all, postbuilds=postbuilds)\n      else:\n        self.WriteDoCmd(\n            [self.output_binary], link_deps, 'solink_module', part_of_all,\n            postbuilds=postbuilds)\n    elif self.type == 'none':\n      # Write a stamp line.\n      self.WriteDoCmd([self.output_binary], deps, 'touch', part_of_all,\n                      postbuilds=postbuilds)\n    else:\n      print(\"WARNING: no output for\", self.type, self.target)\n\n    # Add an alias for each target (if there are any outputs).\n    # Installable target aliases are created below.\n    if ((self.output and self.output != self.target) and\n        (self.type not in self._INSTALLABLE_TARGETS)):\n      self.WriteMakeRule([self.target], [self.output],\n                         comment='Add target alias', phony = True)\n      if part_of_all:\n        self.WriteMakeRule(['all'], [self.target],\n                           comment = 'Add target alias to \"all\" target.',\n                           phony = True)\n\n    # Add special-case rules for our installable targets.\n    # 1) They need to install to the build dir or \"product\" dir.\n    # 2) They get shortcuts for building (e.g. \"make chrome\").\n    # 3) They are part of \"make all\".\n    if (self.type in self._INSTALLABLE_TARGETS or\n        self.is_standalone_static_library):\n      if self.type == 'shared_library':\n        file_desc = 'shared library'\n      elif self.type == 'static_library':\n        file_desc = 'static library'\n      else:\n        file_desc = 'executable'\n      install_path = self._InstallableTargetInstallPath()\n      installable_deps = [self.output]\n      if (self.flavor == 'mac' and not 'product_dir' in spec and\n          self.toolset == 'target'):\n        # On mac, products are created in install_path immediately.\n        assert install_path == self.output, '%s != %s' % (\n            install_path, self.output)\n\n      # Point the target alias to the final binary output.\n      self.WriteMakeRule([self.target], [install_path],\n                         comment='Add target alias', phony = True)\n      if install_path != self.output:\n        assert not self.is_mac_bundle  # See comment a few lines above.\n        self.WriteDoCmd([install_path], [self.output], 'copy',\n                        comment = 'Copy this to the %s output path.' %\n                        file_desc, part_of_all=part_of_all)\n        installable_deps.append(install_path)\n      if self.output != self.alias and self.alias != self.target:\n        self.WriteMakeRule([self.alias], installable_deps,\n                           comment = 'Short alias for building this %s.' %\n                           file_desc, phony = True)\n      if part_of_all:\n        self.WriteMakeRule(['all'], [install_path],\n                           comment = 'Add %s to \"all\" target.' % file_desc,\n                           phony = True)\n\n\n  def WriteList(self, value_list, variable=None, prefix='',\n                quoter=QuoteIfNecessary):\n    \"\"\"Write a variable definition that is a list of values.\n\n    E.g. WriteList(['a','b'], 'foo', prefix='blah') writes out\n         foo = blaha blahb\n    but in a pretty-printed style.\n    \"\"\"\n    values = ''\n    if value_list:\n      value_list = [quoter(prefix + l) for l in value_list]\n      values = ' \\\\\\n\\t' + ' \\\\\\n\\t'.join(value_list)\n    self.fp.write('%s :=%s\\n\\n' % (variable, values))\n\n\n  def WriteDoCmd(self, outputs, inputs, command, part_of_all, comment=None,\n                 postbuilds=False):\n    \"\"\"Write a Makefile rule that uses do_cmd.\n\n    This makes the outputs dependent on the command line that was run,\n    as well as support the V= make command line flag.\n    \"\"\"\n    suffix = ''\n    if postbuilds:\n      assert ',' not in command\n      suffix = ',,1'  # Tell do_cmd to honor $POSTBUILDS\n    self.WriteMakeRule(outputs, inputs,\n                       actions = ['$(call do_cmd,%s%s)' % (command, suffix)],\n                       comment = comment,\n                       command = command,\n                       force = True)\n    # Add our outputs to the list of targets we read depfiles from.\n    # all_deps is only used for deps file reading, and for deps files we replace\n    # spaces with ? because escaping doesn't work with make's $(sort) and\n    # other functions.\n    outputs = [QuoteSpaces(o, SPACE_REPLACEMENT) for o in outputs]\n    self.WriteLn('all_deps += %s' % ' '.join(outputs))\n\n\n  def WriteMakeRule(self, outputs, inputs, actions=None, comment=None,\n                    order_only=False, force=False, phony=False, command=None):\n    \"\"\"Write a Makefile rule, with some extra tricks.\n\n    outputs: a list of outputs for the rule (note: this is not directly\n             supported by make; see comments below)\n    inputs: a list of inputs for the rule\n    actions: a list of shell commands to run for the rule\n    comment: a comment to put in the Makefile above the rule (also useful\n             for making this Python script's code self-documenting)\n    order_only: if true, makes the dependency order-only\n    force: if true, include FORCE_DO_CMD as an order-only dep\n    phony: if true, the rule does not actually generate the named output, the\n           output is just a name to run the rule\n    command: (optional) command name to generate unambiguous labels\n    \"\"\"\n    outputs = [QuoteSpaces(o) for o in outputs]\n    inputs = [QuoteSpaces(i) for i in inputs]\n\n    if comment:\n      self.WriteLn('# ' + comment)\n    if phony:\n      self.WriteLn('.PHONY: ' + ' '.join(outputs))\n    if actions:\n      self.WriteLn(\"%s: TOOLSET := $(TOOLSET)\" % outputs[0])\n    force_append = ' FORCE_DO_CMD' if force else ''\n\n    if order_only:\n      # Order only rule: Just write a simple rule.\n      # TODO(evanm): just make order_only a list of deps instead of this hack.\n      self.WriteLn('%s: | %s%s' %\n                   (' '.join(outputs), ' '.join(inputs), force_append))\n    elif len(outputs) == 1:\n      # Regular rule, one output: Just write a simple rule.\n      self.WriteLn('%s: %s%s' % (outputs[0], ' '.join(inputs), force_append))\n    else:\n      # Regular rule, more than one output: Multiple outputs are tricky in\n      # make. We will write three rules:\n      # - All outputs depend on an intermediate file.\n      # - Make .INTERMEDIATE depend on the intermediate.\n      # - The intermediate file depends on the inputs and executes the\n      #   actual command.\n      # - The intermediate recipe will 'touch' the intermediate file.\n      # - The multi-output rule will have an do-nothing recipe.\n\n      # Hash the target name to avoid generating overlong filenames.\n      cmddigest = hashlib.sha1((command or self.target).encode('utf-8')).hexdigest()\n      intermediate = \"%s.intermediate\" % cmddigest\n      self.WriteLn('%s: %s' % (' '.join(outputs), intermediate))\n      self.WriteLn('\\t%s' % '@:')\n      self.WriteLn('%s: %s' % ('.INTERMEDIATE', intermediate))\n      self.WriteLn('%s: %s%s' %\n                   (intermediate, ' '.join(inputs), force_append))\n      actions.insert(0, '$(call do_cmd,touch)')\n\n    if actions:\n      for action in actions:\n        self.WriteLn('\\t%s' % action)\n    self.WriteLn()\n\n\n  def WriteAndroidNdkModuleRule(self, module_name, all_sources, link_deps):\n    \"\"\"Write a set of LOCAL_XXX definitions for Android NDK.\n\n    These variable definitions will be used by Android NDK but do nothing for\n    non-Android applications.\n\n    Arguments:\n      module_name: Android NDK module name, which must be unique among all\n          module names.\n      all_sources: A list of source files (will be filtered by Compilable).\n      link_deps: A list of link dependencies, which must be sorted in\n          the order from dependencies to dependents.\n    \"\"\"\n    if self.type not in ('executable', 'shared_library', 'static_library'):\n      return\n\n    self.WriteLn('# Variable definitions for Android applications')\n    self.WriteLn('include $(CLEAR_VARS)')\n    self.WriteLn('LOCAL_MODULE := ' + module_name)\n    self.WriteLn('LOCAL_CFLAGS := $(CFLAGS_$(BUILDTYPE)) '\n                 '$(DEFS_$(BUILDTYPE)) '\n                 # LOCAL_CFLAGS is applied to both of C and C++.  There is\n                 # no way to specify $(CFLAGS_C_$(BUILDTYPE)) only for C\n                 # sources.\n                 '$(CFLAGS_C_$(BUILDTYPE)) '\n                 # $(INCS_$(BUILDTYPE)) includes the prefix '-I' while\n                 # LOCAL_C_INCLUDES does not expect it.  So put it in\n                 # LOCAL_CFLAGS.\n                 '$(INCS_$(BUILDTYPE))')\n    # LOCAL_CXXFLAGS is obsolete and LOCAL_CPPFLAGS is preferred.\n    self.WriteLn('LOCAL_CPPFLAGS := $(CFLAGS_CC_$(BUILDTYPE))')\n    self.WriteLn('LOCAL_C_INCLUDES :=')\n    self.WriteLn('LOCAL_LDLIBS := $(LDFLAGS_$(BUILDTYPE)) $(LIBS)')\n\n    # Detect the C++ extension.\n    cpp_ext = {'.cc': 0, '.cpp': 0, '.cxx': 0}\n    default_cpp_ext = '.cpp'\n    for filename in all_sources:\n      ext = os.path.splitext(filename)[1]\n      if ext in cpp_ext:\n        cpp_ext[ext] += 1\n        if cpp_ext[ext] > cpp_ext[default_cpp_ext]:\n          default_cpp_ext = ext\n    self.WriteLn('LOCAL_CPP_EXTENSION := ' + default_cpp_ext)\n\n    self.WriteList(list(map(self.Absolutify, filter(Compilable, all_sources))),\n                   'LOCAL_SRC_FILES')\n\n    # Filter out those which do not match prefix and suffix and produce\n    # the resulting list without prefix and suffix.\n    def DepsToModules(deps, prefix, suffix):\n      modules = []\n      for filepath in deps:\n        filename = os.path.basename(filepath)\n        if filename.startswith(prefix) and filename.endswith(suffix):\n          modules.append(filename[len(prefix):-len(suffix)])\n      return modules\n\n    # Retrieve the default value of 'SHARED_LIB_SUFFIX'\n    params = {'flavor': 'linux'}\n    default_variables = {}\n    CalculateVariables(default_variables, params)\n\n    self.WriteList(\n        DepsToModules(link_deps,\n                      generator_default_variables['SHARED_LIB_PREFIX'],\n                      default_variables['SHARED_LIB_SUFFIX']),\n        'LOCAL_SHARED_LIBRARIES')\n    self.WriteList(\n        DepsToModules(link_deps,\n                      generator_default_variables['STATIC_LIB_PREFIX'],\n                      generator_default_variables['STATIC_LIB_SUFFIX']),\n        'LOCAL_STATIC_LIBRARIES')\n\n    if self.type == 'executable':\n      self.WriteLn('include $(BUILD_EXECUTABLE)')\n    elif self.type == 'shared_library':\n      self.WriteLn('include $(BUILD_SHARED_LIBRARY)')\n    elif self.type == 'static_library':\n      self.WriteLn('include $(BUILD_STATIC_LIBRARY)')\n    self.WriteLn()\n\n\n  def WriteLn(self, text=''):\n    self.fp.write(text + '\\n')\n\n\n  def GetSortedXcodeEnv(self, additional_settings=None):\n    return gyp.xcode_emulation.GetSortedXcodeEnv(\n        self.xcode_settings, \"$(abs_builddir)\",\n        os.path.join(\"$(abs_srcdir)\", self.path), \"$(BUILDTYPE)\",\n        additional_settings)\n\n\n  def GetSortedXcodePostbuildEnv(self):\n    # CHROMIUM_STRIP_SAVE_FILE is a chromium-specific hack.\n    # TODO(thakis): It would be nice to have some general mechanism instead.\n    strip_save_file = self.xcode_settings.GetPerTargetSetting(\n        'CHROMIUM_STRIP_SAVE_FILE', '')\n    # Even if strip_save_file is empty, explicitly write it. Else a postbuild\n    # might pick up an export from an earlier target.\n    return self.GetSortedXcodeEnv(\n        additional_settings={'CHROMIUM_STRIP_SAVE_FILE': strip_save_file})\n\n\n  def WriteSortedXcodeEnv(self, target, env):\n    for k, v in env:\n      # For\n      #  foo := a\\ b\n      # the escaped space does the right thing. For\n      #  export foo := a\\ b\n      # it does not -- the backslash is written to the env as literal character.\n      # So don't escape spaces in |env[k]|.\n      self.WriteLn('%s: export %s := %s' % (QuoteSpaces(target), k, v))\n\n\n  def Objectify(self, path):\n    \"\"\"Convert a path to its output directory form.\"\"\"\n    if '$(' in path:\n      path = path.replace('$(obj)/', '$(obj).%s/$(TARGET)/' % self.toolset)\n    if not '$(obj)' in path:\n      path = '$(obj).%s/$(TARGET)/%s' % (self.toolset, path)\n    return path\n\n\n  def Pchify(self, path, lang):\n    \"\"\"Convert a prefix header path to its output directory form.\"\"\"\n    path = self.Absolutify(path)\n    if '$(' in path:\n      path = path.replace('$(obj)/', '$(obj).%s/$(TARGET)/pch-%s' %\n                          (self.toolset, lang))\n      return path\n    return '$(obj).%s/$(TARGET)/pch-%s/%s' % (self.toolset, lang, path)\n\n\n  def Absolutify(self, path):\n    \"\"\"Convert a subdirectory-relative path into a base-relative path.\n    Skips over paths that contain variables.\"\"\"\n    if '$(' in path:\n      # Don't call normpath in this case, as it might collapse the\n      # path too aggressively if it features '..'. However it's still\n      # important to strip trailing slashes.\n      return path.rstrip('/')\n    return os.path.normpath(os.path.join(self.path, path))\n\n\n  def ExpandInputRoot(self, template, expansion, dirname):\n    if '%(INPUT_ROOT)s' not in template and '%(INPUT_DIRNAME)s' not in template:\n      return template\n    path = template % {\n        'INPUT_ROOT': expansion,\n        'INPUT_DIRNAME': dirname,\n        }\n    return path\n\n\n  def _InstallableTargetInstallPath(self):\n    \"\"\"Returns the location of the final output for an installable target.\"\"\"\n    # Xcode puts shared_library results into PRODUCT_DIR, and some gyp files\n    # rely on this. Emulate this behavior for mac.\n\n    # XXX(TooTallNate): disabling this code since we don't want this behavior...\n    #if (self.type == 'shared_library' and\n    #    (self.flavor != 'mac' or self.toolset != 'target')):\n    #  # Install all shared libs into a common directory (per toolset) for\n    #  # convenient access with LD_LIBRARY_PATH.\n    #  return '$(builddir)/lib.%s/%s' % (self.toolset, self.alias)\n    return '$(builddir)/' + self.alias\n\n\ndef WriteAutoRegenerationRule(params, root_makefile, makefile_name,\n                              build_files):\n  \"\"\"Write the target to regenerate the Makefile.\"\"\"\n  options = params['options']\n  build_files_args = [gyp.common.RelativePath(filename, options.toplevel_dir)\n                      for filename in params['build_files_arg']]\n\n  gyp_binary = gyp.common.FixIfRelativePath(params['gyp_binary'],\n                                            options.toplevel_dir)\n  if not gyp_binary.startswith(os.sep):\n    gyp_binary = os.path.join('.', gyp_binary)\n\n  root_makefile.write(\n      \"quiet_cmd_regen_makefile = ACTION Regenerating $@\\n\"\n      \"cmd_regen_makefile = cd $(srcdir); %(cmd)s\\n\"\n      \"%(makefile_name)s: %(deps)s\\n\"\n      \"\\t$(call do_cmd,regen_makefile)\\n\\n\" % {\n          'makefile_name': makefile_name,\n          'deps': ' '.join(SourceifyAndQuoteSpaces(bf) for bf in build_files),\n          'cmd': gyp.common.EncodePOSIXShellList(\n                     [gyp_binary, '-fmake'] +\n                     gyp.RegenerateFlags(options) +\n                     build_files_args)})\n\n\ndef PerformBuild(data, configurations, params):\n  options = params['options']\n  for config in configurations:\n    arguments = ['make']\n    if options.toplevel_dir and options.toplevel_dir != '.':\n      arguments += '-C', options.toplevel_dir\n    arguments.append('BUILDTYPE=' + config)\n    print('Building [%s]: %s' % (config, arguments))\n    subprocess.check_call(arguments)\n\n\ndef GenerateOutput(target_list, target_dicts, data, params):\n  options = params['options']\n  flavor = gyp.common.GetFlavor(params)\n  generator_flags = params.get('generator_flags', {})\n  builddir_name = generator_flags.get('output_dir', 'out')\n  android_ndk_version = generator_flags.get('android_ndk_version', None)\n  default_target = generator_flags.get('default_target', 'all')\n\n  def CalculateMakefilePath(build_file, base_name):\n    \"\"\"Determine where to write a Makefile for a given gyp file.\"\"\"\n    # Paths in gyp files are relative to the .gyp file, but we want\n    # paths relative to the source root for the master makefile.  Grab\n    # the path of the .gyp file as the base to relativize against.\n    # E.g. \"foo/bar\" when we're constructing targets for \"foo/bar/baz.gyp\".\n    base_path = gyp.common.RelativePath(os.path.dirname(build_file),\n                                        options.depth)\n    # We write the file in the base_path directory.\n    output_file = os.path.join(options.depth, base_path, base_name)\n    if options.generator_output:\n      output_file = os.path.join(\n          options.depth, options.generator_output, base_path, base_name)\n    base_path = gyp.common.RelativePath(os.path.dirname(build_file),\n                                        options.toplevel_dir)\n    return base_path, output_file\n\n  # TODO:  search for the first non-'Default' target.  This can go\n  # away when we add verification that all targets have the\n  # necessary configurations.\n  default_configuration = None\n  toolsets = set([target_dicts[target]['toolset'] for target in target_list])\n  for target in target_list:\n    spec = target_dicts[target]\n    if spec['default_configuration'] != 'Default':\n      default_configuration = spec['default_configuration']\n      break\n  if not default_configuration:\n    default_configuration = 'Default'\n\n  srcdir = '.'\n  makefile_name = 'Makefile' + options.suffix\n  makefile_path = os.path.join(options.toplevel_dir, makefile_name)\n  if options.generator_output:\n    global srcdir_prefix\n    makefile_path = os.path.join(\n        options.toplevel_dir, options.generator_output, makefile_name)\n    srcdir = gyp.common.RelativePath(srcdir, options.generator_output)\n    srcdir_prefix = '$(srcdir)/'\n\n  flock_command= 'flock'\n  copy_archive_arguments = '-af'\n  makedep_arguments = '-MMD'\n  header_params = {\n      'default_target': default_target,\n      'builddir': builddir_name,\n      'default_configuration': default_configuration,\n      'flock': flock_command,\n      'flock_index': 1,\n      'link_commands': LINK_COMMANDS_LINUX,\n      'extra_commands': '',\n      'srcdir': srcdir,\n      'copy_archive_args': copy_archive_arguments,\n      'makedep_args': makedep_arguments,\n      'CC.target':   GetEnvironFallback(('CC_target', 'CC'), '$(CC)'),\n      'AR.target':   GetEnvironFallback(('AR_target', 'AR'), '$(AR)'),\n      'CXX.target':  GetEnvironFallback(('CXX_target', 'CXX'), '$(CXX)'),\n      'LINK.target': GetEnvironFallback(('LINK_target', 'LINK'), '$(LINK)'),\n      'CC.host':     GetEnvironFallback(('CC_host', 'CC'), 'gcc'),\n      'AR.host':     GetEnvironFallback(('AR_host', 'AR'), 'ar'),\n      'CXX.host':    GetEnvironFallback(('CXX_host', 'CXX'), 'g++'),\n      'LINK.host':   GetEnvironFallback(('LINK_host', 'LINK'), '$(CXX.host)'),\n    }\n  if flavor == 'mac':\n    flock_command = './gyp-mac-tool flock'\n    header_params.update({\n        'flock': flock_command,\n        'flock_index': 2,\n        'link_commands': LINK_COMMANDS_MAC,\n        'extra_commands': SHARED_HEADER_MAC_COMMANDS,\n    })\n  elif flavor == 'android':\n    header_params.update({\n        'link_commands': LINK_COMMANDS_ANDROID,\n    })\n  elif flavor == 'zos':\n    copy_archive_arguments = '-fPR'\n    makedep_arguments = '-qmakedep=gcc'\n    header_params.update({\n        'copy_archive_args': copy_archive_arguments,\n        'makedep_args': makedep_arguments,\n        'link_commands': LINK_COMMANDS_OS390,\n        'CC.target':   GetEnvironFallback(('CC_target', 'CC'), 'njsc'),\n        'CXX.target':  GetEnvironFallback(('CXX_target', 'CXX'), 'njsc++'),\n        'CC.host':     GetEnvironFallback(('CC_host', 'CC'), 'njsc'),\n        'CXX.host':    GetEnvironFallback(('CXX_host', 'CXX'), 'njsc++'),\n    })\n  elif flavor == 'solaris':\n    header_params.update({\n        'flock': './gyp-flock-tool flock',\n        'flock_index': 2,\n    })\n  elif flavor == 'freebsd':\n    # Note: OpenBSD has sysutils/flock. lockf seems to be FreeBSD specific.\n    header_params.update({\n        'flock': 'lockf',\n    })\n  elif flavor == 'openbsd':\n    copy_archive_arguments = '-pPRf'\n    header_params.update({\n        'copy_archive_args': copy_archive_arguments,\n    })\n  elif flavor == 'aix':\n    copy_archive_arguments = '-pPRf'\n    header_params.update({\n        'copy_archive_args': copy_archive_arguments,\n        'link_commands': LINK_COMMANDS_AIX,\n        'flock': './gyp-flock-tool flock',\n        'flock_index': 2,\n    })\n\n  build_file, _, _ = gyp.common.ParseQualifiedTarget(target_list[0])\n  make_global_settings_array = data[build_file].get('make_global_settings', [])\n  wrappers = {}\n  for key, value in make_global_settings_array:\n    if key.endswith('_wrapper'):\n      wrappers[key[:-len('_wrapper')]] = '$(abspath %s)' % value\n  make_global_settings = ''\n  for key, value in make_global_settings_array:\n    if re.match('.*_wrapper', key):\n      continue\n    if value[0] != '$':\n      value = '$(abspath %s)' % value\n    wrapper = wrappers.get(key)\n    if wrapper:\n      value = '%s %s' % (wrapper, value)\n      del wrappers[key]\n    if key in ('CC', 'CC.host', 'CXX', 'CXX.host'):\n      make_global_settings += (\n          'ifneq (,$(filter $(origin %s), undefined default))\\n' % key)\n      # Let gyp-time envvars win over global settings.\n      env_key = key.replace('.', '_')  # CC.host -> CC_host\n      if env_key in os.environ:\n        value = os.environ[env_key]\n      make_global_settings += '  %s = %s\\n' % (key, value)\n      make_global_settings += 'endif\\n'\n    else:\n      make_global_settings += '%s ?= %s\\n' % (key, value)\n  # TODO(ukai): define cmd when only wrapper is specified in\n  # make_global_settings.\n\n  header_params['make_global_settings'] = make_global_settings\n\n  gyp.common.EnsureDirExists(makefile_path)\n  root_makefile = open(makefile_path, 'w')\n  root_makefile.write(SHARED_HEADER % header_params)\n  # Currently any versions have the same effect, but in future the behavior\n  # could be different.\n  if android_ndk_version:\n    root_makefile.write(\n        '# Define LOCAL_PATH for build of Android applications.\\n'\n        'LOCAL_PATH := $(call my-dir)\\n'\n        '\\n')\n  for toolset in toolsets:\n    root_makefile.write('TOOLSET := %s\\n' % toolset)\n    WriteRootHeaderSuffixRules(root_makefile)\n\n  # Put build-time support tools next to the root Makefile.\n  dest_path = os.path.dirname(makefile_path)\n  gyp.common.CopyTool(flavor, dest_path)\n\n  # Find the list of targets that derive from the gyp file(s) being built.\n  needed_targets = set()\n  for build_file in params['build_files']:\n    for target in gyp.common.AllTargets(target_list, target_dicts, build_file):\n      needed_targets.add(target)\n\n  build_files = set()\n  include_list = set()\n  for qualified_target in target_list:\n    build_file, target, toolset = gyp.common.ParseQualifiedTarget(\n        qualified_target)\n\n    this_make_global_settings = data[build_file].get('make_global_settings', [])\n    assert make_global_settings_array == this_make_global_settings, (\n        \"make_global_settings needs to be the same for all targets. %s vs. %s\" %\n        (this_make_global_settings, make_global_settings))\n\n    build_files.add(gyp.common.RelativePath(build_file, options.toplevel_dir))\n    included_files = data[build_file]['included_files']\n    for included_file in included_files:\n      # The included_files entries are relative to the dir of the build file\n      # that included them, so we have to undo that and then make them relative\n      # to the root dir.\n      relative_include_file = gyp.common.RelativePath(\n          gyp.common.UnrelativePath(included_file, build_file),\n          options.toplevel_dir)\n      abs_include_file = os.path.abspath(relative_include_file)\n      # If the include file is from the ~/.gyp dir, we should use absolute path\n      # so that relocating the src dir doesn't break the path.\n      if (params['home_dot_gyp'] and\n          abs_include_file.startswith(params['home_dot_gyp'])):\n        build_files.add(abs_include_file)\n      else:\n        build_files.add(relative_include_file)\n\n    base_path, output_file = CalculateMakefilePath(build_file,\n        target + '.' + toolset + options.suffix + '.mk')\n\n    spec = target_dicts[qualified_target]\n    configs = spec['configurations']\n\n    if flavor == 'mac':\n      gyp.xcode_emulation.MergeGlobalXcodeSettingsToSpec(data[build_file], spec)\n\n    writer = MakefileWriter(generator_flags, flavor)\n    writer.Write(qualified_target, base_path, output_file, spec, configs,\n                 part_of_all=qualified_target in needed_targets)\n\n    # Our root_makefile lives at the source root.  Compute the relative path\n    # from there to the output_file for including.\n    mkfile_rel_path = gyp.common.RelativePath(output_file,\n                                              os.path.dirname(makefile_path))\n    include_list.add(mkfile_rel_path)\n\n  # Write out per-gyp (sub-project) Makefiles.\n  depth_rel_path = gyp.common.RelativePath(options.depth, os.getcwd())\n  for build_file in build_files:\n    # The paths in build_files were relativized above, so undo that before\n    # testing against the non-relativized items in target_list and before\n    # calculating the Makefile path.\n    build_file = os.path.join(depth_rel_path, build_file)\n    gyp_targets = [target_dicts[target]['target_name'] for target in target_list\n                   if target.startswith(build_file) and\n                   target in needed_targets]\n    # Only generate Makefiles for gyp files with targets.\n    if not gyp_targets:\n      continue\n    base_path, output_file = CalculateMakefilePath(build_file,\n        os.path.splitext(os.path.basename(build_file))[0] + '.Makefile')\n    makefile_rel_path = gyp.common.RelativePath(os.path.dirname(makefile_path),\n                                                os.path.dirname(output_file))\n    writer.WriteSubMake(output_file, makefile_rel_path, gyp_targets,\n                        builddir_name)\n\n\n  # Write out the sorted list of includes.\n  root_makefile.write('\\n')\n  for include_file in sorted(include_list):\n    # We wrap each .mk include in an if statement so users can tell make to\n    # not load a file by setting NO_LOAD.  The below make code says, only\n    # load the .mk file if the .mk filename doesn't start with a token in\n    # NO_LOAD.\n    root_makefile.write(\n        \"ifeq ($(strip $(foreach prefix,$(NO_LOAD),\\\\\\n\"\n        \"    $(findstring $(join ^,$(prefix)),\\\\\\n\"\n        \"                 $(join ^,\" + include_file + \")))),)\\n\")\n    root_makefile.write(\"  include \" + include_file + \"\\n\")\n    root_makefile.write(\"endif\\n\")\n  root_makefile.write('\\n')\n\n  if (not generator_flags.get('standalone')\n      and generator_flags.get('auto_regeneration', True)):\n    WriteAutoRegenerationRule(params, root_makefile, makefile_name, build_files)\n\n  root_makefile.write(SHARED_FOOTER)\n\n  root_makefile.close()\n",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/node-gyp/gyp/pylib/gyp/generator/make.py": "# Copyright (c) 2013 Google Inc. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n# Notes:\n#\n# This is all roughly based on the Makefile system used by the Linux\n# kernel, but is a non-recursive make -- we put the entire dependency\n# graph in front of make and let it figure it out.\n#\n# The code below generates a separate .mk file for each target, but\n# all are sourced by the top-level Makefile.  This means that all\n# variables in .mk-files clobber one another.  Be careful to use :=\n# where appropriate for immediate evaluation, and similarly to watch\n# that you're not relying on a variable value to last between different\n# .mk files.\n#\n# TODOs:\n#\n# Global settings and utility functions are currently stuffed in the\n# toplevel Makefile.  It may make sense to generate some .mk files on\n# the side to keep the files readable.\n\nfrom __future__ import print_function\n\nimport os\nimport re\nimport sys\nimport subprocess\nimport gyp\nimport gyp.common\nimport gyp.xcode_emulation\nfrom gyp.common import GetEnvironFallback\nfrom gyp.common import GypError\n\nimport hashlib\n\ngenerator_default_variables = {\n  'EXECUTABLE_PREFIX': '',\n  'EXECUTABLE_SUFFIX': '',\n  'STATIC_LIB_PREFIX': 'lib',\n  'SHARED_LIB_PREFIX': 'lib',\n  'STATIC_LIB_SUFFIX': '.a',\n  'INTERMEDIATE_DIR': '$(obj).$(TOOLSET)/$(TARGET)/geni',\n  'SHARED_INTERMEDIATE_DIR': '$(obj)/gen',\n  'PRODUCT_DIR': '$(builddir)',\n  'RULE_INPUT_ROOT': '%(INPUT_ROOT)s',  # This gets expanded by Python.\n  'RULE_INPUT_DIRNAME': '%(INPUT_DIRNAME)s',  # This gets expanded by Python.\n  'RULE_INPUT_PATH': '$(abspath $<)',\n  'RULE_INPUT_EXT': '$(suffix $<)',\n  'RULE_INPUT_NAME': '$(notdir $<)',\n  'CONFIGURATION_NAME': '$(BUILDTYPE)',\n}\n\n# Make supports multiple toolsets\ngenerator_supports_multiple_toolsets = True\n\n# Request sorted dependencies in the order from dependents to dependencies.\ngenerator_wants_sorted_dependencies = False\n\n# Placates pylint.\ngenerator_additional_non_configuration_keys = []\ngenerator_additional_path_sections = []\ngenerator_extra_sources_for_rules = []\ngenerator_filelist_paths = None\n\n\ndef CalculateVariables(default_variables, params):\n  \"\"\"Calculate additional variables for use in the build (called by gyp).\"\"\"\n  flavor = gyp.common.GetFlavor(params)\n  if flavor == 'mac':\n    default_variables.setdefault('OS', 'mac')\n    default_variables.setdefault('SHARED_LIB_SUFFIX', '.dylib')\n    default_variables.setdefault('SHARED_LIB_DIR',\n                                 generator_default_variables['PRODUCT_DIR'])\n    default_variables.setdefault('LIB_DIR',\n                                 generator_default_variables['PRODUCT_DIR'])\n\n    # Copy additional generator configuration data from Xcode, which is shared\n    # by the Mac Make generator.\n    import gyp.generator.xcode as xcode_generator\n    global generator_additional_non_configuration_keys\n    generator_additional_non_configuration_keys = getattr(xcode_generator,\n        'generator_additional_non_configuration_keys', [])\n    global generator_additional_path_sections\n    generator_additional_path_sections = getattr(xcode_generator,\n        'generator_additional_path_sections', [])\n    global generator_extra_sources_for_rules\n    generator_extra_sources_for_rules = getattr(xcode_generator,\n        'generator_extra_sources_for_rules', [])\n    COMPILABLE_EXTENSIONS.update({'.m': 'objc', '.mm' : 'objcxx'})\n  else:\n    operating_system = flavor\n    if flavor == 'android':\n      operating_system = 'linux'  # Keep this legacy behavior for now.\n    default_variables.setdefault('OS', operating_system)\n    if flavor == 'aix':\n      default_variables.setdefault('SHARED_LIB_SUFFIX', '.a')\n    else:\n      default_variables.setdefault('SHARED_LIB_SUFFIX', '.so')\n    default_variables.setdefault('SHARED_LIB_DIR','$(builddir)/lib.$(TOOLSET)')\n    default_variables.setdefault('LIB_DIR', '$(obj).$(TOOLSET)')\n\n\ndef CalculateGeneratorInputInfo(params):\n  \"\"\"Calculate the generator specific info that gets fed to input (called by\n  gyp).\"\"\"\n  generator_flags = params.get('generator_flags', {})\n  android_ndk_version = generator_flags.get('android_ndk_version', None)\n  # Android NDK requires a strict link order.\n  if android_ndk_version:\n    global generator_wants_sorted_dependencies\n    generator_wants_sorted_dependencies = True\n\n  output_dir = params['options'].generator_output or \\\n               params['options'].toplevel_dir\n  builddir_name = generator_flags.get('output_dir', 'out')\n  qualified_out_dir = os.path.normpath(os.path.join(\n    output_dir, builddir_name, 'gypfiles'))\n\n  global generator_filelist_paths\n  generator_filelist_paths = {\n    'toplevel': params['options'].toplevel_dir,\n    'qualified_out_dir': qualified_out_dir,\n  }\n\n\n# The .d checking code below uses these functions:\n# wildcard, sort, foreach, shell, wordlist\n# wildcard can handle spaces, the rest can't.\n# Since I could find no way to make foreach work with spaces in filenames\n# correctly, the .d files have spaces replaced with another character. The .d\n# file for\n#     Chromium\\ Framework.framework/foo\n# is for example\n#     out/Release/.deps/out/Release/Chromium?Framework.framework/foo\n# This is the replacement character.\nSPACE_REPLACEMENT = '?'\n\n\nLINK_COMMANDS_LINUX = \"\"\"\\\nquiet_cmd_alink = AR($(TOOLSET)) $@\ncmd_alink = rm -f $@ && $(AR.$(TOOLSET)) crs $@ $(filter %.o,$^)\n\nquiet_cmd_alink_thin = AR($(TOOLSET)) $@\ncmd_alink_thin = rm -f $@ && $(AR.$(TOOLSET)) crsT $@ $(filter %.o,$^)\n\n# Due to circular dependencies between libraries :(, we wrap the\n# special \"figure out circular dependencies\" flags around the entire\n# input list during linking.\nquiet_cmd_link = LINK($(TOOLSET)) $@\ncmd_link = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ -Wl,--start-group $(LD_INPUTS) $(LIBS) -Wl,--end-group\n\n# We support two kinds of shared objects (.so):\n# 1) shared_library, which is just bundling together many dependent libraries\n# into a link line.\n# 2) loadable_module, which is generating a module intended for dlopen().\n#\n# They differ only slightly:\n# In the former case, we want to package all dependent code into the .so.\n# In the latter case, we want to package just the API exposed by the\n# outermost module.\n# This means shared_library uses --whole-archive, while loadable_module doesn't.\n# (Note that --whole-archive is incompatible with the --start-group used in\n# normal linking.)\n\n# Other shared-object link notes:\n# - Set SONAME to the library filename so our binaries don't reference\n# the local, absolute paths used on the link command-line.\nquiet_cmd_solink = SOLINK($(TOOLSET)) $@\ncmd_solink = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ -Wl,--whole-archive $(LD_INPUTS) -Wl,--no-whole-archive $(LIBS)\n\nquiet_cmd_solink_module = SOLINK_MODULE($(TOOLSET)) $@\ncmd_solink_module = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ -Wl,--start-group $(filter-out FORCE_DO_CMD, $^) -Wl,--end-group $(LIBS)\n\"\"\"\n\nLINK_COMMANDS_MAC = \"\"\"\\\nquiet_cmd_alink = LIBTOOL-STATIC $@\ncmd_alink = rm -f $@ && ./gyp-mac-tool filter-libtool libtool $(GYP_LIBTOOLFLAGS) -static -o $@ $(filter %.o,$^)\n\nquiet_cmd_link = LINK($(TOOLSET)) $@\ncmd_link = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o \"$@\" $(LD_INPUTS) $(LIBS)\n\nquiet_cmd_solink = SOLINK($(TOOLSET)) $@\ncmd_solink = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o \"$@\" $(LD_INPUTS) $(LIBS)\n\nquiet_cmd_solink_module = SOLINK_MODULE($(TOOLSET)) $@\ncmd_solink_module = $(LINK.$(TOOLSET)) -bundle $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(filter-out FORCE_DO_CMD, $^) $(LIBS)\n\"\"\"\n\nLINK_COMMANDS_ANDROID = \"\"\"\\\nquiet_cmd_alink = AR($(TOOLSET)) $@\ncmd_alink = rm -f $@ && $(AR.$(TOOLSET)) crs $@ $(filter %.o,$^)\n\nquiet_cmd_alink_thin = AR($(TOOLSET)) $@\ncmd_alink_thin = rm -f $@ && $(AR.$(TOOLSET)) crsT $@ $(filter %.o,$^)\n\n# Due to circular dependencies between libraries :(, we wrap the\n# special \"figure out circular dependencies\" flags around the entire\n# input list during linking.\nquiet_cmd_link = LINK($(TOOLSET)) $@\nquiet_cmd_link_host = LINK($(TOOLSET)) $@\ncmd_link = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ -Wl,--start-group $(LD_INPUTS) -Wl,--end-group $(LIBS)\ncmd_link_host = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(LD_INPUTS) $(LIBS)\n\n# Other shared-object link notes:\n# - Set SONAME to the library filename so our binaries don't reference\n# the local, absolute paths used on the link command-line.\nquiet_cmd_solink = SOLINK($(TOOLSET)) $@\ncmd_solink = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ -Wl,--whole-archive $(LD_INPUTS) -Wl,--no-whole-archive $(LIBS)\n\nquiet_cmd_solink_module = SOLINK_MODULE($(TOOLSET)) $@\ncmd_solink_module = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ -Wl,--start-group $(filter-out FORCE_DO_CMD, $^) -Wl,--end-group $(LIBS)\nquiet_cmd_solink_module_host = SOLINK_MODULE($(TOOLSET)) $@\ncmd_solink_module_host = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ $(filter-out FORCE_DO_CMD, $^) $(LIBS)\n\"\"\"\n\n\nLINK_COMMANDS_AIX = \"\"\"\\\nquiet_cmd_alink = AR($(TOOLSET)) $@\ncmd_alink = rm -f $@ && $(AR.$(TOOLSET)) -X32_64 crs $@ $(filter %.o,$^)\n\nquiet_cmd_alink_thin = AR($(TOOLSET)) $@\ncmd_alink_thin = rm -f $@ && $(AR.$(TOOLSET)) -X32_64 crs $@ $(filter %.o,$^)\n\nquiet_cmd_link = LINK($(TOOLSET)) $@\ncmd_link = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(LD_INPUTS) $(LIBS)\n\nquiet_cmd_solink = SOLINK($(TOOLSET)) $@\ncmd_solink = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(LD_INPUTS) $(LIBS)\n\nquiet_cmd_solink_module = SOLINK_MODULE($(TOOLSET)) $@\ncmd_solink_module = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(filter-out FORCE_DO_CMD, $^) $(LIBS)\n\"\"\"\n\n\nLINK_COMMANDS_OS390 = \"\"\"\\\nquiet_cmd_alink = AR($(TOOLSET)) $@\ncmd_alink = rm -f $@ && $(AR.$(TOOLSET)) crs $@ $(filter %.o,$^)\n\nquiet_cmd_alink_thin = AR($(TOOLSET)) $@\ncmd_alink_thin = rm -f $@ && $(AR.$(TOOLSET)) crsT $@ $(filter %.o,$^)\n\nquiet_cmd_link = LINK($(TOOLSET)) $@\ncmd_link = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(LD_INPUTS) $(LIBS)\n\nquiet_cmd_solink = SOLINK($(TOOLSET)) $@\ncmd_solink = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(LD_INPUTS) $(LIBS) -Wl,DLL\n\nquiet_cmd_solink_module = SOLINK_MODULE($(TOOLSET)) $@\ncmd_solink_module = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(filter-out FORCE_DO_CMD, $^) $(LIBS) -Wl,DLL\n\n\"\"\"\n\n\n# Header of toplevel Makefile.\n# This should go into the build tree, but it's easier to keep it here for now.\nSHARED_HEADER = (\"\"\"\\\n# We borrow heavily from the kernel build setup, though we are simpler since\n# we don't have Kconfig tweaking settings on us.\n\n# The implicit make rules have it looking for RCS files, among other things.\n# We instead explicitly write all the rules we care about.\n# It's even quicker (saves ~200ms) to pass -r on the command line.\nMAKEFLAGS=-r\n\n# The source directory tree.\nsrcdir := %(srcdir)s\nabs_srcdir := $(abspath $(srcdir))\n\n# The name of the builddir.\nbuilddir_name ?= %(builddir)s\n\n# The V=1 flag on command line makes us verbosely print command lines.\nifdef V\n  quiet=\nelse\n  quiet=quiet_\nendif\n\n# Specify BUILDTYPE=Release on the command line for a release build.\nBUILDTYPE ?= %(default_configuration)s\n\n# Directory all our build output goes into.\n# Note that this must be two directories beneath src/ for unit tests to pass,\n# as they reach into the src/ directory for data with relative paths.\nbuilddir ?= $(builddir_name)/$(BUILDTYPE)\nabs_builddir := $(abspath $(builddir))\ndepsdir := $(builddir)/.deps\n\n# Object output directory.\nobj := $(builddir)/obj\nabs_obj := $(abspath $(obj))\n\n# We build up a list of every single one of the targets so we can slurp in the\n# generated dependency rule Makefiles in one pass.\nall_deps :=\n\n%(make_global_settings)s\n\nCC.target ?= %(CC.target)s\nCFLAGS.target ?= $(CPPFLAGS) $(CFLAGS)\nCXX.target ?= %(CXX.target)s\nCXXFLAGS.target ?= $(CPPFLAGS) $(CXXFLAGS)\nLINK.target ?= %(LINK.target)s\nLDFLAGS.target ?= $(LDFLAGS)\nAR.target ?= $(AR)\n\n# C++ apps need to be linked with g++.\nLINK ?= $(CXX.target)\n\n# TODO(evan): move all cross-compilation logic to gyp-time so we don't need\n# to replicate this environment fallback in make as well.\nCC.host ?= %(CC.host)s\nCFLAGS.host ?= $(CPPFLAGS_host) $(CFLAGS_host)\nCXX.host ?= %(CXX.host)s\nCXXFLAGS.host ?= $(CPPFLAGS_host) $(CXXFLAGS_host)\nLINK.host ?= %(LINK.host)s\nLDFLAGS.host ?=\nAR.host ?= %(AR.host)s\n\n# Define a dir function that can handle spaces.\n# http://www.gnu.org/software/make/manual/make.html#Syntax-of-Functions\n# \"leading spaces cannot appear in the text of the first argument as written.\n# These characters can be put into the argument value by variable substitution.\"\nempty :=\nspace := $(empty) $(empty)\n\n# http://stackoverflow.com/questions/1189781/using-make-dir-or-notdir-on-a-path-with-spaces\nreplace_spaces = $(subst $(space),\"\"\" + SPACE_REPLACEMENT + \"\"\",$1)\nunreplace_spaces = $(subst \"\"\" + SPACE_REPLACEMENT + \"\"\",$(space),$1)\ndirx = $(call unreplace_spaces,$(dir $(call replace_spaces,$1)))\n\n# Flags to make gcc output dependency info.  Note that you need to be\n# careful here to use the flags that ccache and distcc can understand.\n# We write to a dep file on the side first and then rename at the end\n# so we can't end up with a broken dep file.\ndepfile = $(depsdir)/$(call replace_spaces,$@).d\nDEPFLAGS = %(makedep_args)s -MF $(depfile).raw\n\n# We have to fixup the deps output in a few ways.\n# (1) the file output should mention the proper .o file.\n# ccache or distcc lose the path to the target, so we convert a rule of\n# the form:\n#   foobar.o: DEP1 DEP2\n# into\n#   path/to/foobar.o: DEP1 DEP2\n# (2) we want missing files not to cause us to fail to build.\n# We want to rewrite\n#   foobar.o: DEP1 DEP2 \\\\\n#               DEP3\n# to\n#   DEP1:\n#   DEP2:\n#   DEP3:\n# so if the files are missing, they're just considered phony rules.\n# We have to do some pretty insane escaping to get those backslashes\n# and dollar signs past make, the shell, and sed at the same time.\n# Doesn't work with spaces, but that's fine: .d files have spaces in\n# their names replaced with other characters.\"\"\"\nr\"\"\"\ndefine fixup_dep\n# The depfile may not exist if the input file didn't have any #includes.\ntouch $(depfile).raw\n# Fixup path as in (1).\nsed -e \"s|^$(notdir $@)|$@|\" $(depfile).raw >> $(depfile)\n# Add extra rules as in (2).\n# We remove slashes and replace spaces with new lines;\n# remove blank lines;\n# delete the first line and append a colon to the remaining lines.\nsed -e 's|\\\\||' -e 'y| |\\n|' $(depfile).raw |\\\n  grep -v '^$$'                             |\\\n  sed -e 1d -e 's|$$|:|'                     \\\n    >> $(depfile)\nrm $(depfile).raw\nendef\n\"\"\"\n\"\"\"\n# Command definitions:\n# - cmd_foo is the actual command to run;\n# - quiet_cmd_foo is the brief-output summary of the command.\n\nquiet_cmd_cc = CC($(TOOLSET)) $@\ncmd_cc = $(CC.$(TOOLSET)) $(GYP_CFLAGS) $(DEPFLAGS) $(CFLAGS.$(TOOLSET)) -c -o $@ $<\n\nquiet_cmd_cxx = CXX($(TOOLSET)) $@\ncmd_cxx = $(CXX.$(TOOLSET)) $(GYP_CXXFLAGS) $(DEPFLAGS) $(CXXFLAGS.$(TOOLSET)) -c -o $@ $<\n%(extra_commands)s\nquiet_cmd_touch = TOUCH $@\ncmd_touch = touch $@\n\nquiet_cmd_copy = COPY $@\n# send stderr to /dev/null to ignore messages when linking directories.\ncmd_copy = rm -rf \"$@\" && cp %(copy_archive_args)s \"$<\" \"$@\"\n\n%(link_commands)s\n\"\"\"\n\nr\"\"\"\n# Define an escape_quotes function to escape single quotes.\n# This allows us to handle quotes properly as long as we always use\n# use single quotes and escape_quotes.\nescape_quotes = $(subst ','\\'',$(1))\n# This comment is here just to include a ' to unconfuse syntax highlighting.\n# Define an escape_vars function to escape '$' variable syntax.\n# This allows us to read/write command lines with shell variables (e.g.\n# $LD_LIBRARY_PATH), without triggering make substitution.\nescape_vars = $(subst $$,$$$$,$(1))\n# Helper that expands to a shell command to echo a string exactly as it is in\n# make. This uses printf instead of echo because printf's behaviour with respect\n# to escape sequences is more portable than echo's across different shells\n# (e.g., dash, bash).\nexact_echo = printf '%%s\\n' '$(call escape_quotes,$(1))'\n\"\"\"\n\"\"\"\n# Helper to compare the command we're about to run against the command\n# we logged the last time we ran the command.  Produces an empty\n# string (false) when the commands match.\n# Tricky point: Make has no string-equality test function.\n# The kernel uses the following, but it seems like it would have false\n# positives, where one string reordered its arguments.\n#   arg_check = $(strip $(filter-out $(cmd_$(1)), $(cmd_$@)) \\\\\n#                       $(filter-out $(cmd_$@), $(cmd_$(1))))\n# We instead substitute each for the empty string into the other, and\n# say they're equal if both substitutions produce the empty string.\n# .d files contain \"\"\" + SPACE_REPLACEMENT + \\\n                   \"\"\" instead of spaces, take that into account.\ncommand_changed = $(or $(subst $(cmd_$(1)),,$(cmd_$(call replace_spaces,$@))),\\\\\n                       $(subst $(cmd_$(call replace_spaces,$@)),,$(cmd_$(1))))\n\n# Helper that is non-empty when a prerequisite changes.\n# Normally make does this implicitly, but we force rules to always run\n# so we can check their command lines.\n#   $? -- new prerequisites\n#   $| -- order-only dependencies\nprereq_changed = $(filter-out FORCE_DO_CMD,$(filter-out $|,$?))\n\n# Helper that executes all postbuilds until one fails.\ndefine do_postbuilds\n  @E=0;\\\\\n  for p in $(POSTBUILDS); do\\\\\n    eval $$p;\\\\\n    E=$$?;\\\\\n    if [ $$E -ne 0 ]; then\\\\\n      break;\\\\\n    fi;\\\\\n  done;\\\\\n  if [ $$E -ne 0 ]; then\\\\\n    rm -rf \"$@\";\\\\\n    exit $$E;\\\\\n  fi\nendef\n\n# do_cmd: run a command via the above cmd_foo names, if necessary.\n# Should always run for a given target to handle command-line changes.\n# Second argument, if non-zero, makes it do asm/C/C++ dependency munging.\n# Third argument, if non-zero, makes it do POSTBUILDS processing.\n# Note: We intentionally do NOT call dirx for depfile, since it contains \"\"\" + \\\n                                                     SPACE_REPLACEMENT + \"\"\" for\n# spaces already and dirx strips the \"\"\" + SPACE_REPLACEMENT + \\\n                                     \"\"\" characters.\ndefine do_cmd\n$(if $(or $(command_changed),$(prereq_changed)),\n  @$(call exact_echo,  $($(quiet)cmd_$(1)))\n  @mkdir -p \"$(call dirx,$@)\" \"$(dir $(depfile))\"\n  $(if $(findstring flock,$(word %(flock_index)d,$(cmd_$1))),\n    @$(cmd_$(1))\n    @echo \"  $(quiet_cmd_$(1)): Finished\",\n    @$(cmd_$(1))\n  )\n  @$(call exact_echo,$(call escape_vars,cmd_$(call replace_spaces,$@) := $(cmd_$(1)))) > $(depfile)\n  @$(if $(2),$(fixup_dep))\n  $(if $(and $(3), $(POSTBUILDS)),\n    $(call do_postbuilds)\n  )\n)\nendef\n\n# Declare the \"%(default_target)s\" target first so it is the default,\n# even though we don't have the deps yet.\n.PHONY: %(default_target)s\n%(default_target)s:\n\n# make looks for ways to re-generate included makefiles, but in our case, we\n# don't have a direct way. Explicitly telling make that it has nothing to do\n# for them makes it go faster.\n%%.d: ;\n\n# Use FORCE_DO_CMD to force a target to run.  Should be coupled with\n# do_cmd.\n.PHONY: FORCE_DO_CMD\nFORCE_DO_CMD:\n\n\"\"\")\n\nSHARED_HEADER_MAC_COMMANDS = \"\"\"\nquiet_cmd_objc = CXX($(TOOLSET)) $@\ncmd_objc = $(CC.$(TOOLSET)) $(GYP_OBJCFLAGS) $(DEPFLAGS) -c -o $@ $<\n\nquiet_cmd_objcxx = CXX($(TOOLSET)) $@\ncmd_objcxx = $(CXX.$(TOOLSET)) $(GYP_OBJCXXFLAGS) $(DEPFLAGS) -c -o $@ $<\n\n# Commands for precompiled header files.\nquiet_cmd_pch_c = CXX($(TOOLSET)) $@\ncmd_pch_c = $(CC.$(TOOLSET)) $(GYP_PCH_CFLAGS) $(DEPFLAGS) $(CXXFLAGS.$(TOOLSET)) -c -o $@ $<\nquiet_cmd_pch_cc = CXX($(TOOLSET)) $@\ncmd_pch_cc = $(CC.$(TOOLSET)) $(GYP_PCH_CXXFLAGS) $(DEPFLAGS) $(CXXFLAGS.$(TOOLSET)) -c -o $@ $<\nquiet_cmd_pch_m = CXX($(TOOLSET)) $@\ncmd_pch_m = $(CC.$(TOOLSET)) $(GYP_PCH_OBJCFLAGS) $(DEPFLAGS) -c -o $@ $<\nquiet_cmd_pch_mm = CXX($(TOOLSET)) $@\ncmd_pch_mm = $(CC.$(TOOLSET)) $(GYP_PCH_OBJCXXFLAGS) $(DEPFLAGS) -c -o $@ $<\n\n# gyp-mac-tool is written next to the root Makefile by gyp.\n# Use $(4) for the command, since $(2) and $(3) are used as flag by do_cmd\n# already.\nquiet_cmd_mac_tool = MACTOOL $(4) $<\ncmd_mac_tool = ./gyp-mac-tool $(4) $< \"$@\"\n\nquiet_cmd_mac_package_framework = PACKAGE FRAMEWORK $@\ncmd_mac_package_framework = ./gyp-mac-tool package-framework \"$@\" $(4)\n\nquiet_cmd_infoplist = INFOPLIST $@\ncmd_infoplist = $(CC.$(TOOLSET)) -E -P -Wno-trigraphs -x c $(INFOPLIST_DEFINES) \"$<\" -o \"$@\"\n\"\"\"\n\n\ndef WriteRootHeaderSuffixRules(writer):\n  extensions = sorted(COMPILABLE_EXTENSIONS.keys(), key=str.lower)\n\n  writer.write('# Suffix rules, putting all outputs into $(obj).\\n')\n  for ext in extensions:\n    writer.write('$(obj).$(TOOLSET)/%%.o: $(srcdir)/%%%s FORCE_DO_CMD\\n' % ext)\n    writer.write('\\t@$(call do_cmd,%s,1)\\n' % COMPILABLE_EXTENSIONS[ext])\n\n  writer.write('\\n# Try building from generated source, too.\\n')\n  for ext in extensions:\n    writer.write(\n        '$(obj).$(TOOLSET)/%%.o: $(obj).$(TOOLSET)/%%%s FORCE_DO_CMD\\n' % ext)\n    writer.write('\\t@$(call do_cmd,%s,1)\\n' % COMPILABLE_EXTENSIONS[ext])\n  writer.write('\\n')\n  for ext in extensions:\n    writer.write('$(obj).$(TOOLSET)/%%.o: $(obj)/%%%s FORCE_DO_CMD\\n' % ext)\n    writer.write('\\t@$(call do_cmd,%s,1)\\n' % COMPILABLE_EXTENSIONS[ext])\n  writer.write('\\n')\n\n\nSHARED_HEADER_SUFFIX_RULES_COMMENT1 = (\"\"\"\\\n# Suffix rules, putting all outputs into $(obj).\n\"\"\")\n\n\nSHARED_HEADER_SUFFIX_RULES_COMMENT2 = (\"\"\"\\\n# Try building from generated source, too.\n\"\"\")\n\n\nSHARED_FOOTER = \"\"\"\\\n# \"all\" is a concatenation of the \"all\" targets from all the included\n# sub-makefiles. This is just here to clarify.\nall:\n\n# Add in dependency-tracking rules.  $(all_deps) is the list of every single\n# target in our tree. Only consider the ones with .d (dependency) info:\nd_files := $(wildcard $(foreach f,$(all_deps),$(depsdir)/$(f).d))\nifneq ($(d_files),)\n  include $(d_files)\nendif\n\"\"\"\n\nheader = \"\"\"\\\n# This file is generated by gyp; do not edit.\n\n\"\"\"\n\n# Maps every compilable file extension to the do_cmd that compiles it.\nCOMPILABLE_EXTENSIONS = {\n  '.c': 'cc',\n  '.cc': 'cxx',\n  '.cpp': 'cxx',\n  '.cxx': 'cxx',\n  '.s': 'cc',\n  '.S': 'cc',\n}\n\ndef Compilable(filename):\n  \"\"\"Return true if the file is compilable (should be in OBJS).\"\"\"\n  for res in (filename.endswith(e) for e in COMPILABLE_EXTENSIONS):\n    if res:\n      return True\n  return False\n\n\ndef Linkable(filename):\n  \"\"\"Return true if the file is linkable (should be on the link line).\"\"\"\n  return filename.endswith('.o')\n\n\ndef Target(filename):\n  \"\"\"Translate a compilable filename to its .o target.\"\"\"\n  return os.path.splitext(filename)[0] + '.o'\n\n\ndef EscapeShellArgument(s):\n  \"\"\"Quotes an argument so that it will be interpreted literally by a POSIX\n     shell. Taken from\n     http://stackoverflow.com/questions/35817/whats-the-best-way-to-escape-ossystem-calls-in-python\n     \"\"\"\n  return \"'\" + s.replace(\"'\", \"'\\\\''\") + \"'\"\n\n\ndef EscapeMakeVariableExpansion(s):\n  \"\"\"Make has its own variable expansion syntax using $. We must escape it for\n     string to be interpreted literally.\"\"\"\n  return s.replace('$', '$$')\n\n\ndef EscapeCppDefine(s):\n  \"\"\"Escapes a CPP define so that it will reach the compiler unaltered.\"\"\"\n  s = EscapeShellArgument(s)\n  s = EscapeMakeVariableExpansion(s)\n  # '#' characters must be escaped even embedded in a string, else Make will\n  # treat it as the start of a comment.\n  return s.replace('#', r'\\#')\n\n\ndef QuoteIfNecessary(string):\n  \"\"\"TODO: Should this ideally be replaced with one or more of the above\n     functions?\"\"\"\n  if '\"' in string:\n    string = '\"' + string.replace('\"', '\\\\\"') + '\"'\n  return string\n\n\ndef StringToMakefileVariable(string):\n  \"\"\"Convert a string to a value that is acceptable as a make variable name.\"\"\"\n  return re.sub('[^a-zA-Z0-9_]', '_', string)\n\n\nsrcdir_prefix = ''\ndef Sourceify(path):\n  \"\"\"Convert a path to its source directory form.\"\"\"\n  if '$(' in path:\n    return path\n  if os.path.isabs(path):\n    return path\n  return srcdir_prefix + path\n\n\ndef QuoteSpaces(s, quote=r'\\ '):\n  return s.replace(' ', quote)\n\ndef SourceifyAndQuoteSpaces(path):\n  \"\"\"Convert a path to its source directory form and quote spaces.\"\"\"\n  return QuoteSpaces(Sourceify(path))\n\n# TODO: Avoid code duplication with _ValidateSourcesForMSVSProject in msvs.py.\ndef _ValidateSourcesForOSX(spec, all_sources):\n  \"\"\"Makes sure if duplicate basenames are not specified in the source list.\n\n  Arguments:\n    spec: The target dictionary containing the properties of the target.\n  \"\"\"\n  if spec.get('type', None) != 'static_library':\n    return\n\n  basenames = {}\n  for source in all_sources:\n    name, ext = os.path.splitext(source)\n    is_compiled_file = ext in [\n        '.c', '.cc', '.cpp', '.cxx', '.m', '.mm', '.s', '.S']\n    if not is_compiled_file:\n      continue\n    basename = os.path.basename(name)  # Don't include extension.\n    basenames.setdefault(basename, []).append(source)\n\n  error = ''\n  for basename, files in basenames.items():\n    if len(files) > 1:\n      error += '  %s: %s\\n' % (basename, ' '.join(files))\n\n  if error:\n    print(('static library %s has several files with the same basename:\\n' % spec['target_name'])\n           + error + 'libtool on OS X will generate' + ' warnings for them.')\n    raise GypError('Duplicate basenames in sources section, see list above')\n\n\n# Map from qualified target to path to output.\ntarget_outputs = {}\n# Map from qualified target to any linkable output.  A subset\n# of target_outputs.  E.g. when mybinary depends on liba, we want to\n# include liba in the linker line; when otherbinary depends on\n# mybinary, we just want to build mybinary first.\ntarget_link_deps = {}\n\n\nclass MakefileWriter(object):\n  \"\"\"MakefileWriter packages up the writing of one target-specific foobar.mk.\n\n  Its only real entry point is Write(), and is mostly used for namespacing.\n  \"\"\"\n\n  def __init__(self, generator_flags, flavor):\n    self.generator_flags = generator_flags\n    self.flavor = flavor\n\n    self.suffix_rules_srcdir = {}\n    self.suffix_rules_objdir1 = {}\n    self.suffix_rules_objdir2 = {}\n\n    # Generate suffix rules for all compilable extensions.\n    for ext in COMPILABLE_EXTENSIONS.keys():\n      # Suffix rules for source folder.\n      self.suffix_rules_srcdir.update({ext: (\"\"\"\\\n$(obj).$(TOOLSET)/$(TARGET)/%%.o: $(srcdir)/%%%s FORCE_DO_CMD\n\t@$(call do_cmd,%s,1)\n\"\"\" % (ext, COMPILABLE_EXTENSIONS[ext]))})\n\n      # Suffix rules for generated source files.\n      self.suffix_rules_objdir1.update({ext: (\"\"\"\\\n$(obj).$(TOOLSET)/$(TARGET)/%%.o: $(obj).$(TOOLSET)/%%%s FORCE_DO_CMD\n\t@$(call do_cmd,%s,1)\n\"\"\" % (ext, COMPILABLE_EXTENSIONS[ext]))})\n      self.suffix_rules_objdir2.update({ext: (\"\"\"\\\n$(obj).$(TOOLSET)/$(TARGET)/%%.o: $(obj)/%%%s FORCE_DO_CMD\n\t@$(call do_cmd,%s,1)\n\"\"\" % (ext, COMPILABLE_EXTENSIONS[ext]))})\n\n\n  def Write(self, qualified_target, base_path, output_filename, spec, configs,\n            part_of_all):\n    \"\"\"The main entry point: writes a .mk file for a single target.\n\n    Arguments:\n      qualified_target: target we're generating\n      base_path: path relative to source root we're building in, used to resolve\n                 target-relative paths\n      output_filename: output .mk file name to write\n      spec, configs: gyp info\n      part_of_all: flag indicating this target is part of 'all'\n    \"\"\"\n    gyp.common.EnsureDirExists(output_filename)\n\n    self.fp = open(output_filename, 'w')\n\n    self.fp.write(header)\n\n    self.qualified_target = qualified_target\n    self.path = base_path\n    self.target = spec['target_name']\n    self.type = spec['type']\n    self.toolset = spec['toolset']\n\n    self.is_mac_bundle = gyp.xcode_emulation.IsMacBundle(self.flavor, spec)\n    if self.flavor == 'mac':\n      self.xcode_settings = gyp.xcode_emulation.XcodeSettings(spec)\n    else:\n      self.xcode_settings = None\n\n    deps, link_deps = self.ComputeDeps(spec)\n\n    # Some of the generation below can add extra output, sources, or\n    # link dependencies.  All of the out params of the functions that\n    # follow use names like extra_foo.\n    extra_outputs = []\n    extra_sources = []\n    extra_link_deps = []\n    extra_mac_bundle_resources = []\n    mac_bundle_deps = []\n\n    if self.is_mac_bundle:\n      self.output = self.ComputeMacBundleOutput(spec)\n      self.output_binary = self.ComputeMacBundleBinaryOutput(spec)\n    else:\n      self.output = self.output_binary = self.ComputeOutput(spec)\n\n    self.is_standalone_static_library = bool(\n        spec.get('standalone_static_library', 0))\n    self._INSTALLABLE_TARGETS = ('executable', 'loadable_module',\n                                 'shared_library')\n    if (self.is_standalone_static_library or\n        self.type in self._INSTALLABLE_TARGETS):\n      self.alias = os.path.basename(self.output)\n      install_path = self._InstallableTargetInstallPath()\n    else:\n      self.alias = self.output\n      install_path = self.output\n\n    self.WriteLn(\"TOOLSET := \" + self.toolset)\n    self.WriteLn(\"TARGET := \" + self.target)\n\n    # Actions must come first, since they can generate more OBJs for use below.\n    if 'actions' in spec:\n      self.WriteActions(spec['actions'], extra_sources, extra_outputs,\n                        extra_mac_bundle_resources, part_of_all)\n\n    # Rules must be early like actions.\n    if 'rules' in spec:\n      self.WriteRules(spec['rules'], extra_sources, extra_outputs,\n                      extra_mac_bundle_resources, part_of_all)\n\n    if 'copies' in spec:\n      self.WriteCopies(spec['copies'], extra_outputs, part_of_all)\n\n    # Bundle resources.\n    if self.is_mac_bundle:\n      all_mac_bundle_resources = (\n          spec.get('mac_bundle_resources', []) + extra_mac_bundle_resources)\n      self.WriteMacBundleResources(all_mac_bundle_resources, mac_bundle_deps)\n      self.WriteMacInfoPlist(mac_bundle_deps)\n\n    # Sources.\n    all_sources = spec.get('sources', []) + extra_sources\n    if all_sources:\n      if self.flavor == 'mac':\n        # libtool on OS X generates warnings for duplicate basenames in the same\n        # target.\n        _ValidateSourcesForOSX(spec, all_sources)\n      self.WriteSources(\n          configs, deps, all_sources, extra_outputs,\n          extra_link_deps, part_of_all,\n          gyp.xcode_emulation.MacPrefixHeader(\n              self.xcode_settings, lambda p: Sourceify(self.Absolutify(p)),\n              self.Pchify))\n      sources = list(filter(Compilable, all_sources))\n      if sources:\n        self.WriteLn(SHARED_HEADER_SUFFIX_RULES_COMMENT1)\n        extensions = set([os.path.splitext(s)[1] for s in sources])\n        for ext in extensions:\n          if ext in self.suffix_rules_srcdir:\n            self.WriteLn(self.suffix_rules_srcdir[ext])\n        self.WriteLn(SHARED_HEADER_SUFFIX_RULES_COMMENT2)\n        for ext in extensions:\n          if ext in self.suffix_rules_objdir1:\n            self.WriteLn(self.suffix_rules_objdir1[ext])\n        for ext in extensions:\n          if ext in self.suffix_rules_objdir2:\n            self.WriteLn(self.suffix_rules_objdir2[ext])\n        self.WriteLn('# End of this set of suffix rules')\n\n        # Add dependency from bundle to bundle binary.\n        if self.is_mac_bundle:\n          mac_bundle_deps.append(self.output_binary)\n\n    self.WriteTarget(spec, configs, deps, extra_link_deps + link_deps,\n                     mac_bundle_deps, extra_outputs, part_of_all)\n\n    # Update global list of target outputs, used in dependency tracking.\n    target_outputs[qualified_target] = install_path\n\n    # Update global list of link dependencies.\n    if self.type in ('static_library', 'shared_library'):\n      target_link_deps[qualified_target] = self.output_binary\n\n    # Currently any versions have the same effect, but in future the behavior\n    # could be different.\n    if self.generator_flags.get('android_ndk_version', None):\n      self.WriteAndroidNdkModuleRule(self.target, all_sources, link_deps)\n\n    self.fp.close()\n\n\n  def WriteSubMake(self, output_filename, makefile_path, targets, build_dir):\n    \"\"\"Write a \"sub-project\" Makefile.\n\n    This is a small, wrapper Makefile that calls the top-level Makefile to build\n    the targets from a single gyp file (i.e. a sub-project).\n\n    Arguments:\n      output_filename: sub-project Makefile name to write\n      makefile_path: path to the top-level Makefile\n      targets: list of \"all\" targets for this sub-project\n      build_dir: build output directory, relative to the sub-project\n    \"\"\"\n    gyp.common.EnsureDirExists(output_filename)\n    self.fp = open(output_filename, 'w')\n    self.fp.write(header)\n    # For consistency with other builders, put sub-project build output in the\n    # sub-project dir (see test/subdirectory/gyptest-subdir-all.py).\n    self.WriteLn('export builddir_name ?= %s' %\n                 os.path.join(os.path.dirname(output_filename), build_dir))\n    self.WriteLn('.PHONY: all')\n    self.WriteLn('all:')\n    if makefile_path:\n      makefile_path = ' -C ' + makefile_path\n    self.WriteLn('\\t$(MAKE)%s %s' % (makefile_path, ' '.join(targets)))\n    self.fp.close()\n\n\n  def WriteActions(self, actions, extra_sources, extra_outputs,\n                   extra_mac_bundle_resources, part_of_all):\n    \"\"\"Write Makefile code for any 'actions' from the gyp input.\n\n    extra_sources: a list that will be filled in with newly generated source\n                   files, if any\n    extra_outputs: a list that will be filled in with any outputs of these\n                   actions (used to make other pieces dependent on these\n                   actions)\n    part_of_all: flag indicating this target is part of 'all'\n    \"\"\"\n    env = self.GetSortedXcodeEnv()\n    for action in actions:\n      name = StringToMakefileVariable('%s_%s' % (self.qualified_target,\n                                                 action['action_name']))\n      self.WriteLn('### Rules for action \"%s\":' % action['action_name'])\n      inputs = action['inputs']\n      outputs = action['outputs']\n\n      # Build up a list of outputs.\n      # Collect the output dirs we'll need.\n      dirs = set()\n      for out in outputs:\n        dir = os.path.split(out)[0]\n        if dir:\n          dirs.add(dir)\n      if int(action.get('process_outputs_as_sources', False)):\n        extra_sources += outputs\n      if int(action.get('process_outputs_as_mac_bundle_resources', False)):\n        extra_mac_bundle_resources += outputs\n\n      # Write the actual command.\n      action_commands = action['action']\n      if self.flavor == 'mac':\n        action_commands = [gyp.xcode_emulation.ExpandEnvVars(command, env)\n                          for command in action_commands]\n      command = gyp.common.EncodePOSIXShellList(action_commands)\n      if 'message' in action:\n        self.WriteLn('quiet_cmd_%s = ACTION %s $@' % (name, action['message']))\n      else:\n        self.WriteLn('quiet_cmd_%s = ACTION %s $@' % (name, name))\n      if len(dirs) > 0:\n        command = 'mkdir -p %s' % ' '.join(dirs) + '; ' + command\n\n      cd_action = 'cd %s; ' % Sourceify(self.path or '.')\n\n      # command and cd_action get written to a toplevel variable called\n      # cmd_foo. Toplevel variables can't handle things that change per\n      # makefile like $(TARGET), so hardcode the target.\n      command = command.replace('$(TARGET)', self.target)\n      cd_action = cd_action.replace('$(TARGET)', self.target)\n\n      # Set LD_LIBRARY_PATH in case the action runs an executable from this\n      # build which links to shared libs from this build.\n      # actions run on the host, so they should in theory only use host\n      # libraries, but until everything is made cross-compile safe, also use\n      # target libraries.\n      # TODO(piman): when everything is cross-compile safe, remove lib.target\n      self.WriteLn('cmd_%s = LD_LIBRARY_PATH=$(builddir)/lib.host:'\n                   '$(builddir)/lib.target:$$LD_LIBRARY_PATH; '\n                   'export LD_LIBRARY_PATH; '\n                   '%s%s'\n                   % (name, cd_action, command))\n      self.WriteLn()\n      outputs = [self.Absolutify(output) for output in outputs]\n      # The makefile rules are all relative to the top dir, but the gyp actions\n      # are defined relative to their containing dir.  This replaces the obj\n      # variable for the action rule with an absolute version so that the output\n      # goes in the right place.\n      # Only write the 'obj' and 'builddir' rules for the \"primary\" output (:1);\n      # it's superfluous for the \"extra outputs\", and this avoids accidentally\n      # writing duplicate dummy rules for those outputs.\n      # Same for environment.\n      self.WriteLn(\"%s: obj := $(abs_obj)\" % QuoteSpaces(outputs[0]))\n      self.WriteLn(\"%s: builddir := $(abs_builddir)\" % QuoteSpaces(outputs[0]))\n      self.WriteSortedXcodeEnv(outputs[0], self.GetSortedXcodeEnv())\n\n      for input in inputs:\n        assert ' ' not in input, (\n            \"Spaces in action input filenames not supported (%s)\"  % input)\n      for output in outputs:\n        assert ' ' not in output, (\n            \"Spaces in action output filenames not supported (%s)\"  % output)\n\n      # See the comment in WriteCopies about expanding env vars.\n      outputs = [gyp.xcode_emulation.ExpandEnvVars(o, env) for o in outputs]\n      inputs = [gyp.xcode_emulation.ExpandEnvVars(i, env) for i in inputs]\n\n      self.WriteDoCmd(outputs, [Sourceify(self.Absolutify(i)) for i in inputs],\n                      part_of_all=part_of_all, command=name)\n\n      # Stuff the outputs in a variable so we can refer to them later.\n      outputs_variable = 'action_%s_outputs' % name\n      self.WriteLn('%s := %s' % (outputs_variable, ' '.join(outputs)))\n      extra_outputs.append('$(%s)' % outputs_variable)\n      self.WriteLn()\n\n    self.WriteLn()\n\n\n  def WriteRules(self, rules, extra_sources, extra_outputs,\n                 extra_mac_bundle_resources, part_of_all):\n    \"\"\"Write Makefile code for any 'rules' from the gyp input.\n\n    extra_sources: a list that will be filled in with newly generated source\n                   files, if any\n    extra_outputs: a list that will be filled in with any outputs of these\n                   rules (used to make other pieces dependent on these rules)\n    part_of_all: flag indicating this target is part of 'all'\n    \"\"\"\n    env = self.GetSortedXcodeEnv()\n    for rule in rules:\n      name = StringToMakefileVariable('%s_%s' % (self.qualified_target,\n                                                 rule['rule_name']))\n      count = 0\n      self.WriteLn('### Generated for rule %s:' % name)\n\n      all_outputs = []\n\n      for rule_source in rule.get('rule_sources', []):\n        dirs = set()\n        (rule_source_dirname, rule_source_basename) = os.path.split(rule_source)\n        (rule_source_root, rule_source_ext) = \\\n            os.path.splitext(rule_source_basename)\n\n        outputs = [self.ExpandInputRoot(out, rule_source_root,\n                                        rule_source_dirname)\n                   for out in rule['outputs']]\n\n        for out in outputs:\n          dir = os.path.dirname(out)\n          if dir:\n            dirs.add(dir)\n        if int(rule.get('process_outputs_as_sources', False)):\n          extra_sources += outputs\n        if int(rule.get('process_outputs_as_mac_bundle_resources', False)):\n          extra_mac_bundle_resources += outputs\n        inputs = [Sourceify(self.Absolutify(i)) for i\n                  in [rule_source] + rule.get('inputs', [])]\n        actions = ['$(call do_cmd,%s_%d)' % (name, count)]\n\n        if name == 'resources_grit':\n          # HACK: This is ugly.  Grit intentionally doesn't touch the\n          # timestamp of its output file when the file doesn't change,\n          # which is fine in hash-based dependency systems like scons\n          # and forge, but not kosher in the make world.  After some\n          # discussion, hacking around it here seems like the least\n          # amount of pain.\n          actions += ['@touch --no-create $@']\n\n        # See the comment in WriteCopies about expanding env vars.\n        outputs = [gyp.xcode_emulation.ExpandEnvVars(o, env) for o in outputs]\n        inputs = [gyp.xcode_emulation.ExpandEnvVars(i, env) for i in inputs]\n\n        outputs = [self.Absolutify(output) for output in outputs]\n        all_outputs += outputs\n        # Only write the 'obj' and 'builddir' rules for the \"primary\" output\n        # (:1); it's superfluous for the \"extra outputs\", and this avoids\n        # accidentally writing duplicate dummy rules for those outputs.\n        self.WriteLn('%s: obj := $(abs_obj)' % outputs[0])\n        self.WriteLn('%s: builddir := $(abs_builddir)' % outputs[0])\n        self.WriteMakeRule(outputs, inputs, actions,\n                           command=\"%s_%d\" % (name, count))\n        # Spaces in rule filenames are not supported, but rule variables have\n        # spaces in them (e.g. RULE_INPUT_PATH expands to '$(abspath $<)').\n        # The spaces within the variables are valid, so remove the variables\n        # before checking.\n        variables_with_spaces = re.compile(r'\\$\\([^ ]* \\$<\\)')\n        for output in outputs:\n          output = re.sub(variables_with_spaces, '', output)\n          assert ' ' not in output, (\n              \"Spaces in rule filenames not yet supported (%s)\"  % output)\n        self.WriteLn('all_deps += %s' % ' '.join(outputs))\n\n        action = [self.ExpandInputRoot(ac, rule_source_root,\n                                       rule_source_dirname)\n                  for ac in rule['action']]\n        mkdirs = ''\n        if len(dirs) > 0:\n          mkdirs = 'mkdir -p %s; ' % ' '.join(dirs)\n        cd_action = 'cd %s; ' % Sourceify(self.path or '.')\n\n        # action, cd_action, and mkdirs get written to a toplevel variable\n        # called cmd_foo. Toplevel variables can't handle things that change\n        # per makefile like $(TARGET), so hardcode the target.\n        if self.flavor == 'mac':\n          action = [gyp.xcode_emulation.ExpandEnvVars(command, env)\n                    for command in action]\n        action = gyp.common.EncodePOSIXShellList(action)\n        action = action.replace('$(TARGET)', self.target)\n        cd_action = cd_action.replace('$(TARGET)', self.target)\n        mkdirs = mkdirs.replace('$(TARGET)', self.target)\n\n        # Set LD_LIBRARY_PATH in case the rule runs an executable from this\n        # build which links to shared libs from this build.\n        # rules run on the host, so they should in theory only use host\n        # libraries, but until everything is made cross-compile safe, also use\n        # target libraries.\n        # TODO(piman): when everything is cross-compile safe, remove lib.target\n        self.WriteLn(\n            \"cmd_%(name)s_%(count)d = LD_LIBRARY_PATH=\"\n              \"$(builddir)/lib.host:$(builddir)/lib.target:$$LD_LIBRARY_PATH; \"\n              \"export LD_LIBRARY_PATH; \"\n              \"%(cd_action)s%(mkdirs)s%(action)s\" % {\n          'action': action,\n          'cd_action': cd_action,\n          'count': count,\n          'mkdirs': mkdirs,\n          'name': name,\n        })\n        self.WriteLn(\n            'quiet_cmd_%(name)s_%(count)d = RULE %(name)s_%(count)d $@' % {\n          'count': count,\n          'name': name,\n        })\n        self.WriteLn()\n        count += 1\n\n      outputs_variable = 'rule_%s_outputs' % name\n      self.WriteList(all_outputs, outputs_variable)\n      extra_outputs.append('$(%s)' % outputs_variable)\n\n      self.WriteLn('### Finished generating for rule: %s' % name)\n      self.WriteLn()\n    self.WriteLn('### Finished generating for all rules')\n    self.WriteLn('')\n\n\n  def WriteCopies(self, copies, extra_outputs, part_of_all):\n    \"\"\"Write Makefile code for any 'copies' from the gyp input.\n\n    extra_outputs: a list that will be filled in with any outputs of this action\n                   (used to make other pieces dependent on this action)\n    part_of_all: flag indicating this target is part of 'all'\n    \"\"\"\n    self.WriteLn('### Generated for copy rule.')\n\n    variable = StringToMakefileVariable(self.qualified_target + '_copies')\n    outputs = []\n    for copy in copies:\n      for path in copy['files']:\n        # Absolutify() may call normpath, and will strip trailing slashes.\n        path = Sourceify(self.Absolutify(path))\n        filename = os.path.split(path)[1]\n        output = Sourceify(self.Absolutify(os.path.join(copy['destination'],\n                                                        filename)))\n\n        # If the output path has variables in it, which happens in practice for\n        # 'copies', writing the environment as target-local doesn't work,\n        # because the variables are already needed for the target name.\n        # Copying the environment variables into global make variables doesn't\n        # work either, because then the .d files will potentially contain spaces\n        # after variable expansion, and .d file handling cannot handle spaces.\n        # As a workaround, manually expand variables at gyp time. Since 'copies'\n        # can't run scripts, there's no need to write the env then.\n        # WriteDoCmd() will escape spaces for .d files.\n        env = self.GetSortedXcodeEnv()\n        output = gyp.xcode_emulation.ExpandEnvVars(output, env)\n        path = gyp.xcode_emulation.ExpandEnvVars(path, env)\n        self.WriteDoCmd([output], [path], 'copy', part_of_all)\n        outputs.append(output)\n    self.WriteLn('%s = %s' % (variable, ' '.join(QuoteSpaces(o) for o in outputs)))\n    extra_outputs.append('$(%s)' % variable)\n    self.WriteLn()\n\n\n  def WriteMacBundleResources(self, resources, bundle_deps):\n    \"\"\"Writes Makefile code for 'mac_bundle_resources'.\"\"\"\n    self.WriteLn('### Generated for mac_bundle_resources')\n\n    for output, res in gyp.xcode_emulation.GetMacBundleResources(\n        generator_default_variables['PRODUCT_DIR'], self.xcode_settings,\n        [Sourceify(self.Absolutify(r)) for r in resources]):\n      _, ext = os.path.splitext(output)\n      if ext != '.xcassets':\n        # Make does not supports '.xcassets' emulation.\n        self.WriteDoCmd([output], [res], 'mac_tool,,,copy-bundle-resource',\n                        part_of_all=True)\n        bundle_deps.append(output)\n\n\n  def WriteMacInfoPlist(self, bundle_deps):\n    \"\"\"Write Makefile code for bundle Info.plist files.\"\"\"\n    info_plist, out, defines, extra_env = gyp.xcode_emulation.GetMacInfoPlist(\n        generator_default_variables['PRODUCT_DIR'], self.xcode_settings,\n        lambda p: Sourceify(self.Absolutify(p)))\n    if not info_plist:\n      return\n    if defines:\n      # Create an intermediate file to store preprocessed results.\n      intermediate_plist = ('$(obj).$(TOOLSET)/$(TARGET)/' +\n          os.path.basename(info_plist))\n      self.WriteList(defines, intermediate_plist + ': INFOPLIST_DEFINES', '-D',\n          quoter=EscapeCppDefine)\n      self.WriteMakeRule([intermediate_plist], [info_plist],\n          ['$(call do_cmd,infoplist)',\n           # \"Convert\" the plist so that any weird whitespace changes from the\n           # preprocessor do not affect the XML parser in mac_tool.\n           '@plutil -convert xml1 $@ $@'])\n      info_plist = intermediate_plist\n    # plists can contain envvars and substitute them into the file.\n    self.WriteSortedXcodeEnv(\n        out, self.GetSortedXcodeEnv(additional_settings=extra_env))\n    self.WriteDoCmd([out], [info_plist], 'mac_tool,,,copy-info-plist',\n                    part_of_all=True)\n    bundle_deps.append(out)\n\n\n  def WriteSources(self, configs, deps, sources,\n                   extra_outputs, extra_link_deps,\n                   part_of_all, precompiled_header):\n    \"\"\"Write Makefile code for any 'sources' from the gyp input.\n    These are source files necessary to build the current target.\n\n    configs, deps, sources: input from gyp.\n    extra_outputs: a list of extra outputs this action should be dependent on;\n                   used to serialize action/rules before compilation\n    extra_link_deps: a list that will be filled in with any outputs of\n                     compilation (to be used in link lines)\n    part_of_all: flag indicating this target is part of 'all'\n    \"\"\"\n\n    # Write configuration-specific variables for CFLAGS, etc.\n    for configname in sorted(configs.keys()):\n      config = configs[configname]\n      self.WriteList(config.get('defines'), 'DEFS_%s' % configname, prefix='-D',\n          quoter=EscapeCppDefine)\n\n      if self.flavor == 'mac':\n        cflags = self.xcode_settings.GetCflags(configname)\n        cflags_c = self.xcode_settings.GetCflagsC(configname)\n        cflags_cc = self.xcode_settings.GetCflagsCC(configname)\n        cflags_objc = self.xcode_settings.GetCflagsObjC(configname)\n        cflags_objcc = self.xcode_settings.GetCflagsObjCC(configname)\n      else:\n        cflags = config.get('cflags')\n        cflags_c = config.get('cflags_c')\n        cflags_cc = config.get('cflags_cc')\n\n      self.WriteLn(\"# Flags passed to all source files.\")\n      self.WriteList(cflags, 'CFLAGS_%s' % configname)\n      self.WriteLn(\"# Flags passed to only C files.\")\n      self.WriteList(cflags_c, 'CFLAGS_C_%s' % configname)\n      self.WriteLn(\"# Flags passed to only C++ files.\")\n      self.WriteList(cflags_cc, 'CFLAGS_CC_%s' % configname)\n      if self.flavor == 'mac':\n        self.WriteLn(\"# Flags passed to only ObjC files.\")\n        self.WriteList(cflags_objc, 'CFLAGS_OBJC_%s' % configname)\n        self.WriteLn(\"# Flags passed to only ObjC++ files.\")\n        self.WriteList(cflags_objcc, 'CFLAGS_OBJCC_%s' % configname)\n      includes = config.get('include_dirs')\n      if includes:\n        includes = [Sourceify(self.Absolutify(i)) for i in includes]\n      self.WriteList(includes, 'INCS_%s' % configname, prefix='-I')\n\n    compilable = list(filter(Compilable, sources))\n    objs = [self.Objectify(self.Absolutify(Target(c))) for c in compilable]\n    self.WriteList(objs, 'OBJS')\n\n    for obj in objs:\n      assert ' ' not in obj, (\n          \"Spaces in object filenames not supported (%s)\"  % obj)\n    self.WriteLn('# Add to the list of files we specially track '\n                 'dependencies for.')\n    self.WriteLn('all_deps += $(OBJS)')\n    self.WriteLn()\n\n    # Make sure our dependencies are built first.\n    if deps:\n      self.WriteMakeRule(['$(OBJS)'], deps,\n                         comment = 'Make sure our dependencies are built '\n                                   'before any of us.',\n                         order_only = True)\n\n    # Make sure the actions and rules run first.\n    # If they generate any extra headers etc., the per-.o file dep tracking\n    # will catch the proper rebuilds, so order only is still ok here.\n    if extra_outputs:\n      self.WriteMakeRule(['$(OBJS)'], extra_outputs,\n                         comment = 'Make sure our actions/rules run '\n                                   'before any of us.',\n                         order_only = True)\n\n    pchdeps = precompiled_header.GetObjDependencies(compilable, objs )\n    if pchdeps:\n      self.WriteLn('# Dependencies from obj files to their precompiled headers')\n      for source, obj, gch in pchdeps:\n        self.WriteLn('%s: %s' % (obj, gch))\n      self.WriteLn('# End precompiled header dependencies')\n\n    if objs:\n      extra_link_deps.append('$(OBJS)')\n      self.WriteLn(\"\"\"\\\n# CFLAGS et al overrides must be target-local.\n# See \"Target-specific Variable Values\" in the GNU Make manual.\"\"\")\n      self.WriteLn(\"$(OBJS): TOOLSET := $(TOOLSET)\")\n      self.WriteLn(\"$(OBJS): GYP_CFLAGS := \"\n                   \"$(DEFS_$(BUILDTYPE)) \"\n                   \"$(INCS_$(BUILDTYPE)) \"\n                   \"%s \" % precompiled_header.GetInclude('c') +\n                   \"$(CFLAGS_$(BUILDTYPE)) \"\n                   \"$(CFLAGS_C_$(BUILDTYPE))\")\n      self.WriteLn(\"$(OBJS): GYP_CXXFLAGS := \"\n                   \"$(DEFS_$(BUILDTYPE)) \"\n                   \"$(INCS_$(BUILDTYPE)) \"\n                   \"%s \" % precompiled_header.GetInclude('cc') +\n                   \"$(CFLAGS_$(BUILDTYPE)) \"\n                   \"$(CFLAGS_CC_$(BUILDTYPE))\")\n      if self.flavor == 'mac':\n        self.WriteLn(\"$(OBJS): GYP_OBJCFLAGS := \"\n                     \"$(DEFS_$(BUILDTYPE)) \"\n                     \"$(INCS_$(BUILDTYPE)) \"\n                     \"%s \" % precompiled_header.GetInclude('m') +\n                     \"$(CFLAGS_$(BUILDTYPE)) \"\n                     \"$(CFLAGS_C_$(BUILDTYPE)) \"\n                     \"$(CFLAGS_OBJC_$(BUILDTYPE))\")\n        self.WriteLn(\"$(OBJS): GYP_OBJCXXFLAGS := \"\n                     \"$(DEFS_$(BUILDTYPE)) \"\n                     \"$(INCS_$(BUILDTYPE)) \"\n                     \"%s \" % precompiled_header.GetInclude('mm') +\n                     \"$(CFLAGS_$(BUILDTYPE)) \"\n                     \"$(CFLAGS_CC_$(BUILDTYPE)) \"\n                     \"$(CFLAGS_OBJCC_$(BUILDTYPE))\")\n\n    self.WritePchTargets(precompiled_header.GetPchBuildCommands())\n\n    # If there are any object files in our input file list, link them into our\n    # output.\n    extra_link_deps += list(filter(Linkable, sources))\n\n    self.WriteLn()\n\n  def WritePchTargets(self, pch_commands):\n    \"\"\"Writes make rules to compile prefix headers.\"\"\"\n    if not pch_commands:\n      return\n\n    for gch, lang_flag, lang, input in pch_commands:\n      extra_flags = {\n        'c': '$(CFLAGS_C_$(BUILDTYPE))',\n        'cc': '$(CFLAGS_CC_$(BUILDTYPE))',\n        'm': '$(CFLAGS_C_$(BUILDTYPE)) $(CFLAGS_OBJC_$(BUILDTYPE))',\n        'mm': '$(CFLAGS_CC_$(BUILDTYPE)) $(CFLAGS_OBJCC_$(BUILDTYPE))',\n      }[lang]\n      var_name = {\n        'c': 'GYP_PCH_CFLAGS',\n        'cc': 'GYP_PCH_CXXFLAGS',\n        'm': 'GYP_PCH_OBJCFLAGS',\n        'mm': 'GYP_PCH_OBJCXXFLAGS',\n      }[lang]\n      self.WriteLn(\"%s: %s := %s \" % (gch, var_name, lang_flag) +\n                   \"$(DEFS_$(BUILDTYPE)) \"\n                   \"$(INCS_$(BUILDTYPE)) \"\n                   \"$(CFLAGS_$(BUILDTYPE)) \" +\n                   extra_flags)\n\n      self.WriteLn('%s: %s FORCE_DO_CMD' % (gch, input))\n      self.WriteLn('\\t@$(call do_cmd,pch_%s,1)' % lang)\n      self.WriteLn('')\n      assert ' ' not in gch, (\n          \"Spaces in gch filenames not supported (%s)\"  % gch)\n      self.WriteLn('all_deps += %s' % gch)\n      self.WriteLn('')\n\n\n  def ComputeOutputBasename(self, spec):\n    \"\"\"Return the 'output basename' of a gyp spec.\n\n    E.g., the loadable module 'foobar' in directory 'baz' will produce\n      'libfoobar.so'\n    \"\"\"\n    assert not self.is_mac_bundle\n\n    if self.flavor == 'mac' and self.type in (\n        'static_library', 'executable', 'shared_library', 'loadable_module'):\n      return self.xcode_settings.GetExecutablePath()\n\n    target = spec['target_name']\n    target_prefix = ''\n    target_ext = ''\n    if self.type == 'static_library':\n      if target[:3] == 'lib':\n        target = target[3:]\n      target_prefix = 'lib'\n      target_ext = '.a'\n    elif self.type in ('loadable_module', 'shared_library'):\n      if target[:3] == 'lib':\n        target = target[3:]\n      target_prefix = 'lib'\n      if self.flavor == 'aix':\n        target_ext = '.a'\n      else:\n        target_ext = '.so'\n    elif self.type == 'none':\n      target = '%s.stamp' % target\n    elif self.type != 'executable':\n      print(\"ERROR: What output file should be generated?\",\n             \"type\", self.type, \"target\", target)\n\n    target_prefix = spec.get('product_prefix', target_prefix)\n    target = spec.get('product_name', target)\n    product_ext = spec.get('product_extension')\n    if product_ext:\n      target_ext = '.' + product_ext\n\n    return target_prefix + target + target_ext\n\n\n  def _InstallImmediately(self):\n    return self.toolset == 'target' and self.flavor == 'mac' and self.type in (\n          'static_library', 'executable', 'shared_library', 'loadable_module')\n\n\n  def ComputeOutput(self, spec):\n    \"\"\"Return the 'output' (full output path) of a gyp spec.\n\n    E.g., the loadable module 'foobar' in directory 'baz' will produce\n      '$(obj)/baz/libfoobar.so'\n    \"\"\"\n    assert not self.is_mac_bundle\n\n    path = os.path.join('$(obj).' + self.toolset, self.path)\n    if self.type == 'executable' or self._InstallImmediately():\n      path = '$(builddir)'\n    path = spec.get('product_dir', path)\n    return os.path.join(path, self.ComputeOutputBasename(spec))\n\n\n  def ComputeMacBundleOutput(self, spec):\n    \"\"\"Return the 'output' (full output path) to a bundle output directory.\"\"\"\n    assert self.is_mac_bundle\n    path = generator_default_variables['PRODUCT_DIR']\n    return os.path.join(path, self.xcode_settings.GetWrapperName())\n\n\n  def ComputeMacBundleBinaryOutput(self, spec):\n    \"\"\"Return the 'output' (full output path) to the binary in a bundle.\"\"\"\n    path = generator_default_variables['PRODUCT_DIR']\n    return os.path.join(path, self.xcode_settings.GetExecutablePath())\n\n\n  def ComputeDeps(self, spec):\n    \"\"\"Compute the dependencies of a gyp spec.\n\n    Returns a tuple (deps, link_deps), where each is a list of\n    filenames that will need to be put in front of make for either\n    building (deps) or linking (link_deps).\n    \"\"\"\n    deps = []\n    link_deps = []\n    if 'dependencies' in spec:\n      deps.extend([target_outputs[dep] for dep in spec['dependencies']\n                   if target_outputs[dep]])\n      for dep in spec['dependencies']:\n        if dep in target_link_deps:\n          link_deps.append(target_link_deps[dep])\n      deps.extend(link_deps)\n      # TODO: It seems we need to transitively link in libraries (e.g. -lfoo)?\n      # This hack makes it work:\n      # link_deps.extend(spec.get('libraries', []))\n    return (gyp.common.uniquer(deps), gyp.common.uniquer(link_deps))\n\n\n  def WriteDependencyOnExtraOutputs(self, target, extra_outputs):\n    self.WriteMakeRule([self.output_binary], extra_outputs,\n                       comment = 'Build our special outputs first.',\n                       order_only = True)\n\n\n  def WriteTarget(self, spec, configs, deps, link_deps, bundle_deps,\n                  extra_outputs, part_of_all):\n    \"\"\"Write Makefile code to produce the final target of the gyp spec.\n\n    spec, configs: input from gyp.\n    deps, link_deps: dependency lists; see ComputeDeps()\n    extra_outputs: any extra outputs that our target should depend on\n    part_of_all: flag indicating this target is part of 'all'\n    \"\"\"\n\n    self.WriteLn('### Rules for final target.')\n\n    if extra_outputs:\n      self.WriteDependencyOnExtraOutputs(self.output_binary, extra_outputs)\n      self.WriteMakeRule(extra_outputs, deps,\n                         comment=('Preserve order dependency of '\n                                  'special output on deps.'),\n                         order_only = True)\n\n    target_postbuilds = {}\n    if self.type != 'none':\n      for configname in sorted(configs.keys()):\n        config = configs[configname]\n        if self.flavor == 'mac':\n          ldflags = self.xcode_settings.GetLdflags(configname,\n              generator_default_variables['PRODUCT_DIR'],\n              lambda p: Sourceify(self.Absolutify(p)))\n\n          # TARGET_POSTBUILDS_$(BUILDTYPE) is added to postbuilds later on.\n          gyp_to_build = gyp.common.InvertRelativePath(self.path)\n          target_postbuild = self.xcode_settings.AddImplicitPostbuilds(\n              configname,\n              QuoteSpaces(os.path.normpath(os.path.join(gyp_to_build,\n                                                        self.output))),\n              QuoteSpaces(os.path.normpath(os.path.join(gyp_to_build,\n                                                        self.output_binary))))\n          if target_postbuild:\n            target_postbuilds[configname] = target_postbuild\n        else:\n          ldflags = config.get('ldflags', [])\n          # Compute an rpath for this output if needed.\n          if any(dep.endswith('.so') or '.so.' in dep for dep in deps):\n            # We want to get the literal string \"$ORIGIN\" into the link command,\n            # so we need lots of escaping.\n            ldflags.append(r'-Wl,-rpath=\\$$ORIGIN/lib.%s/' % self.toolset)\n            ldflags.append(r'-Wl,-rpath-link=\\$(builddir)/lib.%s/' %\n                           self.toolset)\n        library_dirs = config.get('library_dirs', [])\n        ldflags += [('-L%s' % library_dir) for library_dir in library_dirs]\n        self.WriteList(ldflags, 'LDFLAGS_%s' % configname)\n        if self.flavor == 'mac':\n          self.WriteList(self.xcode_settings.GetLibtoolflags(configname),\n                         'LIBTOOLFLAGS_%s' % configname)\n      libraries = spec.get('libraries')\n      if libraries:\n        # Remove duplicate entries\n        libraries = gyp.common.uniquer(libraries)\n        if self.flavor == 'mac':\n          libraries = self.xcode_settings.AdjustLibraries(libraries)\n      self.WriteList(libraries, 'LIBS')\n      self.WriteLn('%s: GYP_LDFLAGS := $(LDFLAGS_$(BUILDTYPE))' %\n          QuoteSpaces(self.output_binary))\n      self.WriteLn('%s: LIBS := $(LIBS)' % QuoteSpaces(self.output_binary))\n\n      if self.flavor == 'mac':\n        self.WriteLn('%s: GYP_LIBTOOLFLAGS := $(LIBTOOLFLAGS_$(BUILDTYPE))' %\n            QuoteSpaces(self.output_binary))\n\n    # Postbuild actions. Like actions, but implicitly depend on the target's\n    # output.\n    postbuilds = []\n    if self.flavor == 'mac':\n      if target_postbuilds:\n        postbuilds.append('$(TARGET_POSTBUILDS_$(BUILDTYPE))')\n      postbuilds.extend(\n          gyp.xcode_emulation.GetSpecPostbuildCommands(spec))\n\n    if postbuilds:\n      # Envvars may be referenced by TARGET_POSTBUILDS_$(BUILDTYPE),\n      # so we must output its definition first, since we declare variables\n      # using \":=\".\n      self.WriteSortedXcodeEnv(self.output, self.GetSortedXcodePostbuildEnv())\n\n      for configname in target_postbuilds:\n        self.WriteLn('%s: TARGET_POSTBUILDS_%s := %s' %\n            (QuoteSpaces(self.output),\n             configname,\n             gyp.common.EncodePOSIXShellList(target_postbuilds[configname])))\n\n      # Postbuilds expect to be run in the gyp file's directory, so insert an\n      # implicit postbuild to cd to there.\n      postbuilds.insert(0, gyp.common.EncodePOSIXShellList(['cd', self.path]))\n      for i in range(len(postbuilds)):\n        if not postbuilds[i].startswith('$'):\n          postbuilds[i] = EscapeShellArgument(postbuilds[i])\n      self.WriteLn('%s: builddir := $(abs_builddir)' % QuoteSpaces(self.output))\n      self.WriteLn('%s: POSTBUILDS := %s' % (\n          QuoteSpaces(self.output), ' '.join(postbuilds)))\n\n    # A bundle directory depends on its dependencies such as bundle resources\n    # and bundle binary. When all dependencies have been built, the bundle\n    # needs to be packaged.\n    if self.is_mac_bundle:\n      # If the framework doesn't contain a binary, then nothing depends\n      # on the actions -- make the framework depend on them directly too.\n      self.WriteDependencyOnExtraOutputs(self.output, extra_outputs)\n\n      # Bundle dependencies. Note that the code below adds actions to this\n      # target, so if you move these two lines, move the lines below as well.\n      self.WriteList([QuoteSpaces(dep) for dep in bundle_deps], 'BUNDLE_DEPS')\n      self.WriteLn('%s: $(BUNDLE_DEPS)' % QuoteSpaces(self.output))\n\n      # After the framework is built, package it. Needs to happen before\n      # postbuilds, since postbuilds depend on this.\n      if self.type in ('shared_library', 'loadable_module'):\n        self.WriteLn('\\t@$(call do_cmd,mac_package_framework,,,%s)' %\n            self.xcode_settings.GetFrameworkVersion())\n\n      # Bundle postbuilds can depend on the whole bundle, so run them after\n      # the bundle is packaged, not already after the bundle binary is done.\n      if postbuilds:\n        self.WriteLn('\\t@$(call do_postbuilds)')\n      postbuilds = []  # Don't write postbuilds for target's output.\n\n      # Needed by test/mac/gyptest-rebuild.py.\n      self.WriteLn('\\t@true  # No-op, used by tests')\n\n      # Since this target depends on binary and resources which are in\n      # nested subfolders, the framework directory will be older than\n      # its dependencies usually. To prevent this rule from executing\n      # on every build (expensive, especially with postbuilds), expliclity\n      # update the time on the framework directory.\n      self.WriteLn('\\t@touch -c %s' % QuoteSpaces(self.output))\n\n    if postbuilds:\n      assert not self.is_mac_bundle, ('Postbuilds for bundles should be done '\n          'on the bundle, not the binary (target \\'%s\\')' % self.target)\n      assert 'product_dir' not in spec, ('Postbuilds do not work with '\n          'custom product_dir')\n\n    if self.type == 'executable':\n      self.WriteLn('%s: LD_INPUTS := %s' % (\n          QuoteSpaces(self.output_binary),\n          ' '.join(QuoteSpaces(dep) for dep in link_deps)))\n      if self.toolset == 'host' and self.flavor == 'android':\n        self.WriteDoCmd([self.output_binary], link_deps, 'link_host',\n                        part_of_all, postbuilds=postbuilds)\n      else:\n        self.WriteDoCmd([self.output_binary], link_deps, 'link', part_of_all,\n                        postbuilds=postbuilds)\n\n    elif self.type == 'static_library':\n      for link_dep in link_deps:\n        assert ' ' not in link_dep, (\n            \"Spaces in alink input filenames not supported (%s)\"  % link_dep)\n      if (self.flavor not in ('mac', 'openbsd', 'netbsd', 'win') and not\n          self.is_standalone_static_library):\n        self.WriteDoCmd([self.output_binary], link_deps, 'alink_thin',\n                        part_of_all, postbuilds=postbuilds)\n      else:\n        self.WriteDoCmd([self.output_binary], link_deps, 'alink', part_of_all,\n                        postbuilds=postbuilds)\n    elif self.type == 'shared_library':\n      self.WriteLn('%s: LD_INPUTS := %s' % (\n            QuoteSpaces(self.output_binary),\n            ' '.join(QuoteSpaces(dep) for dep in link_deps)))\n      self.WriteDoCmd([self.output_binary], link_deps, 'solink', part_of_all,\n                      postbuilds=postbuilds)\n    elif self.type == 'loadable_module':\n      for link_dep in link_deps:\n        assert ' ' not in link_dep, (\n            \"Spaces in module input filenames not supported (%s)\"  % link_dep)\n      if self.toolset == 'host' and self.flavor == 'android':\n        self.WriteDoCmd([self.output_binary], link_deps, 'solink_module_host',\n                        part_of_all, postbuilds=postbuilds)\n      else:\n        self.WriteDoCmd(\n            [self.output_binary], link_deps, 'solink_module', part_of_all,\n            postbuilds=postbuilds)\n    elif self.type == 'none':\n      # Write a stamp line.\n      self.WriteDoCmd([self.output_binary], deps, 'touch', part_of_all,\n                      postbuilds=postbuilds)\n    else:\n      print(\"WARNING: no output for\", self.type, self.target)\n\n    # Add an alias for each target (if there are any outputs).\n    # Installable target aliases are created below.\n    if ((self.output and self.output != self.target) and\n        (self.type not in self._INSTALLABLE_TARGETS)):\n      self.WriteMakeRule([self.target], [self.output],\n                         comment='Add target alias', phony = True)\n      if part_of_all:\n        self.WriteMakeRule(['all'], [self.target],\n                           comment = 'Add target alias to \"all\" target.',\n                           phony = True)\n\n    # Add special-case rules for our installable targets.\n    # 1) They need to install to the build dir or \"product\" dir.\n    # 2) They get shortcuts for building (e.g. \"make chrome\").\n    # 3) They are part of \"make all\".\n    if (self.type in self._INSTALLABLE_TARGETS or\n        self.is_standalone_static_library):\n      if self.type == 'shared_library':\n        file_desc = 'shared library'\n      elif self.type == 'static_library':\n        file_desc = 'static library'\n      else:\n        file_desc = 'executable'\n      install_path = self._InstallableTargetInstallPath()\n      installable_deps = [self.output]\n      if (self.flavor == 'mac' and not 'product_dir' in spec and\n          self.toolset == 'target'):\n        # On mac, products are created in install_path immediately.\n        assert install_path == self.output, '%s != %s' % (\n            install_path, self.output)\n\n      # Point the target alias to the final binary output.\n      self.WriteMakeRule([self.target], [install_path],\n                         comment='Add target alias', phony = True)\n      if install_path != self.output:\n        assert not self.is_mac_bundle  # See comment a few lines above.\n        self.WriteDoCmd([install_path], [self.output], 'copy',\n                        comment = 'Copy this to the %s output path.' %\n                        file_desc, part_of_all=part_of_all)\n        installable_deps.append(install_path)\n      if self.output != self.alias and self.alias != self.target:\n        self.WriteMakeRule([self.alias], installable_deps,\n                           comment = 'Short alias for building this %s.' %\n                           file_desc, phony = True)\n      if part_of_all:\n        self.WriteMakeRule(['all'], [install_path],\n                           comment = 'Add %s to \"all\" target.' % file_desc,\n                           phony = True)\n\n\n  def WriteList(self, value_list, variable=None, prefix='',\n                quoter=QuoteIfNecessary):\n    \"\"\"Write a variable definition that is a list of values.\n\n    E.g. WriteList(['a','b'], 'foo', prefix='blah') writes out\n         foo = blaha blahb\n    but in a pretty-printed style.\n    \"\"\"\n    values = ''\n    if value_list:\n      value_list = [quoter(prefix + l) for l in value_list]\n      values = ' \\\\\\n\\t' + ' \\\\\\n\\t'.join(value_list)\n    self.fp.write('%s :=%s\\n\\n' % (variable, values))\n\n\n  def WriteDoCmd(self, outputs, inputs, command, part_of_all, comment=None,\n                 postbuilds=False):\n    \"\"\"Write a Makefile rule that uses do_cmd.\n\n    This makes the outputs dependent on the command line that was run,\n    as well as support the V= make command line flag.\n    \"\"\"\n    suffix = ''\n    if postbuilds:\n      assert ',' not in command\n      suffix = ',,1'  # Tell do_cmd to honor $POSTBUILDS\n    self.WriteMakeRule(outputs, inputs,\n                       actions = ['$(call do_cmd,%s%s)' % (command, suffix)],\n                       comment = comment,\n                       command = command,\n                       force = True)\n    # Add our outputs to the list of targets we read depfiles from.\n    # all_deps is only used for deps file reading, and for deps files we replace\n    # spaces with ? because escaping doesn't work with make's $(sort) and\n    # other functions.\n    outputs = [QuoteSpaces(o, SPACE_REPLACEMENT) for o in outputs]\n    self.WriteLn('all_deps += %s' % ' '.join(outputs))\n\n\n  def WriteMakeRule(self, outputs, inputs, actions=None, comment=None,\n                    order_only=False, force=False, phony=False, command=None):\n    \"\"\"Write a Makefile rule, with some extra tricks.\n\n    outputs: a list of outputs for the rule (note: this is not directly\n             supported by make; see comments below)\n    inputs: a list of inputs for the rule\n    actions: a list of shell commands to run for the rule\n    comment: a comment to put in the Makefile above the rule (also useful\n             for making this Python script's code self-documenting)\n    order_only: if true, makes the dependency order-only\n    force: if true, include FORCE_DO_CMD as an order-only dep\n    phony: if true, the rule does not actually generate the named output, the\n           output is just a name to run the rule\n    command: (optional) command name to generate unambiguous labels\n    \"\"\"\n    outputs = [QuoteSpaces(o) for o in outputs]\n    inputs = [QuoteSpaces(i) for i in inputs]\n\n    if comment:\n      self.WriteLn('# ' + comment)\n    if phony:\n      self.WriteLn('.PHONY: ' + ' '.join(outputs))\n    if actions:\n      self.WriteLn(\"%s: TOOLSET := $(TOOLSET)\" % outputs[0])\n    force_append = ' FORCE_DO_CMD' if force else ''\n\n    if order_only:\n      # Order only rule: Just write a simple rule.\n      # TODO(evanm): just make order_only a list of deps instead of this hack.\n      self.WriteLn('%s: | %s%s' %\n                   (' '.join(outputs), ' '.join(inputs), force_append))\n    elif len(outputs) == 1:\n      # Regular rule, one output: Just write a simple rule.\n      self.WriteLn('%s: %s%s' % (outputs[0], ' '.join(inputs), force_append))\n    else:\n      # Regular rule, more than one output: Multiple outputs are tricky in\n      # make. We will write three rules:\n      # - All outputs depend on an intermediate file.\n      # - Make .INTERMEDIATE depend on the intermediate.\n      # - The intermediate file depends on the inputs and executes the\n      #   actual command.\n      # - The intermediate recipe will 'touch' the intermediate file.\n      # - The multi-output rule will have an do-nothing recipe.\n\n      # Hash the target name to avoid generating overlong filenames.\n      cmddigest = hashlib.sha1((command or self.target).encode('utf-8')).hexdigest()\n      intermediate = \"%s.intermediate\" % cmddigest\n      self.WriteLn('%s: %s' % (' '.join(outputs), intermediate))\n      self.WriteLn('\\t%s' % '@:')\n      self.WriteLn('%s: %s' % ('.INTERMEDIATE', intermediate))\n      self.WriteLn('%s: %s%s' %\n                   (intermediate, ' '.join(inputs), force_append))\n      actions.insert(0, '$(call do_cmd,touch)')\n\n    if actions:\n      for action in actions:\n        self.WriteLn('\\t%s' % action)\n    self.WriteLn()\n\n\n  def WriteAndroidNdkModuleRule(self, module_name, all_sources, link_deps):\n    \"\"\"Write a set of LOCAL_XXX definitions for Android NDK.\n\n    These variable definitions will be used by Android NDK but do nothing for\n    non-Android applications.\n\n    Arguments:\n      module_name: Android NDK module name, which must be unique among all\n          module names.\n      all_sources: A list of source files (will be filtered by Compilable).\n      link_deps: A list of link dependencies, which must be sorted in\n          the order from dependencies to dependents.\n    \"\"\"\n    if self.type not in ('executable', 'shared_library', 'static_library'):\n      return\n\n    self.WriteLn('# Variable definitions for Android applications')\n    self.WriteLn('include $(CLEAR_VARS)')\n    self.WriteLn('LOCAL_MODULE := ' + module_name)\n    self.WriteLn('LOCAL_CFLAGS := $(CFLAGS_$(BUILDTYPE)) '\n                 '$(DEFS_$(BUILDTYPE)) '\n                 # LOCAL_CFLAGS is applied to both of C and C++.  There is\n                 # no way to specify $(CFLAGS_C_$(BUILDTYPE)) only for C\n                 # sources.\n                 '$(CFLAGS_C_$(BUILDTYPE)) '\n                 # $(INCS_$(BUILDTYPE)) includes the prefix '-I' while\n                 # LOCAL_C_INCLUDES does not expect it.  So put it in\n                 # LOCAL_CFLAGS.\n                 '$(INCS_$(BUILDTYPE))')\n    # LOCAL_CXXFLAGS is obsolete and LOCAL_CPPFLAGS is preferred.\n    self.WriteLn('LOCAL_CPPFLAGS := $(CFLAGS_CC_$(BUILDTYPE))')\n    self.WriteLn('LOCAL_C_INCLUDES :=')\n    self.WriteLn('LOCAL_LDLIBS := $(LDFLAGS_$(BUILDTYPE)) $(LIBS)')\n\n    # Detect the C++ extension.\n    cpp_ext = {'.cc': 0, '.cpp': 0, '.cxx': 0}\n    default_cpp_ext = '.cpp'\n    for filename in all_sources:\n      ext = os.path.splitext(filename)[1]\n      if ext in cpp_ext:\n        cpp_ext[ext] += 1\n        if cpp_ext[ext] > cpp_ext[default_cpp_ext]:\n          default_cpp_ext = ext\n    self.WriteLn('LOCAL_CPP_EXTENSION := ' + default_cpp_ext)\n\n    self.WriteList(list(map(self.Absolutify, filter(Compilable, all_sources))),\n                   'LOCAL_SRC_FILES')\n\n    # Filter out those which do not match prefix and suffix and produce\n    # the resulting list without prefix and suffix.\n    def DepsToModules(deps, prefix, suffix):\n      modules = []\n      for filepath in deps:\n        filename = os.path.basename(filepath)\n        if filename.startswith(prefix) and filename.endswith(suffix):\n          modules.append(filename[len(prefix):-len(suffix)])\n      return modules\n\n    # Retrieve the default value of 'SHARED_LIB_SUFFIX'\n    params = {'flavor': 'linux'}\n    default_variables = {}\n    CalculateVariables(default_variables, params)\n\n    self.WriteList(\n        DepsToModules(link_deps,\n                      generator_default_variables['SHARED_LIB_PREFIX'],\n                      default_variables['SHARED_LIB_SUFFIX']),\n        'LOCAL_SHARED_LIBRARIES')\n    self.WriteList(\n        DepsToModules(link_deps,\n                      generator_default_variables['STATIC_LIB_PREFIX'],\n                      generator_default_variables['STATIC_LIB_SUFFIX']),\n        'LOCAL_STATIC_LIBRARIES')\n\n    if self.type == 'executable':\n      self.WriteLn('include $(BUILD_EXECUTABLE)')\n    elif self.type == 'shared_library':\n      self.WriteLn('include $(BUILD_SHARED_LIBRARY)')\n    elif self.type == 'static_library':\n      self.WriteLn('include $(BUILD_STATIC_LIBRARY)')\n    self.WriteLn()\n\n\n  def WriteLn(self, text=''):\n    self.fp.write(text + '\\n')\n\n\n  def GetSortedXcodeEnv(self, additional_settings=None):\n    return gyp.xcode_emulation.GetSortedXcodeEnv(\n        self.xcode_settings, \"$(abs_builddir)\",\n        os.path.join(\"$(abs_srcdir)\", self.path), \"$(BUILDTYPE)\",\n        additional_settings)\n\n\n  def GetSortedXcodePostbuildEnv(self):\n    # CHROMIUM_STRIP_SAVE_FILE is a chromium-specific hack.\n    # TODO(thakis): It would be nice to have some general mechanism instead.\n    strip_save_file = self.xcode_settings.GetPerTargetSetting(\n        'CHROMIUM_STRIP_SAVE_FILE', '')\n    # Even if strip_save_file is empty, explicitly write it. Else a postbuild\n    # might pick up an export from an earlier target.\n    return self.GetSortedXcodeEnv(\n        additional_settings={'CHROMIUM_STRIP_SAVE_FILE': strip_save_file})\n\n\n  def WriteSortedXcodeEnv(self, target, env):\n    for k, v in env:\n      # For\n      #  foo := a\\ b\n      # the escaped space does the right thing. For\n      #  export foo := a\\ b\n      # it does not -- the backslash is written to the env as literal character.\n      # So don't escape spaces in |env[k]|.\n      self.WriteLn('%s: export %s := %s' % (QuoteSpaces(target), k, v))\n\n\n  def Objectify(self, path):\n    \"\"\"Convert a path to its output directory form.\"\"\"\n    if '$(' in path:\n      path = path.replace('$(obj)/', '$(obj).%s/$(TARGET)/' % self.toolset)\n    if not '$(obj)' in path:\n      path = '$(obj).%s/$(TARGET)/%s' % (self.toolset, path)\n    return path\n\n\n  def Pchify(self, path, lang):\n    \"\"\"Convert a prefix header path to its output directory form.\"\"\"\n    path = self.Absolutify(path)\n    if '$(' in path:\n      path = path.replace('$(obj)/', '$(obj).%s/$(TARGET)/pch-%s' %\n                          (self.toolset, lang))\n      return path\n    return '$(obj).%s/$(TARGET)/pch-%s/%s' % (self.toolset, lang, path)\n\n\n  def Absolutify(self, path):\n    \"\"\"Convert a subdirectory-relative path into a base-relative path.\n    Skips over paths that contain variables.\"\"\"\n    if '$(' in path:\n      # Don't call normpath in this case, as it might collapse the\n      # path too aggressively if it features '..'. However it's still\n      # important to strip trailing slashes.\n      return path.rstrip('/')\n    return os.path.normpath(os.path.join(self.path, path))\n\n\n  def ExpandInputRoot(self, template, expansion, dirname):\n    if '%(INPUT_ROOT)s' not in template and '%(INPUT_DIRNAME)s' not in template:\n      return template\n    path = template % {\n        'INPUT_ROOT': expansion,\n        'INPUT_DIRNAME': dirname,\n        }\n    return path\n\n\n  def _InstallableTargetInstallPath(self):\n    \"\"\"Returns the location of the final output for an installable target.\"\"\"\n    # Xcode puts shared_library results into PRODUCT_DIR, and some gyp files\n    # rely on this. Emulate this behavior for mac.\n\n    # XXX(TooTallNate): disabling this code since we don't want this behavior...\n    #if (self.type == 'shared_library' and\n    #    (self.flavor != 'mac' or self.toolset != 'target')):\n    #  # Install all shared libs into a common directory (per toolset) for\n    #  # convenient access with LD_LIBRARY_PATH.\n    #  return '$(builddir)/lib.%s/%s' % (self.toolset, self.alias)\n    return '$(builddir)/' + self.alias\n\n\ndef WriteAutoRegenerationRule(params, root_makefile, makefile_name,\n                              build_files):\n  \"\"\"Write the target to regenerate the Makefile.\"\"\"\n  options = params['options']\n  build_files_args = [gyp.common.RelativePath(filename, options.toplevel_dir)\n                      for filename in params['build_files_arg']]\n\n  gyp_binary = gyp.common.FixIfRelativePath(params['gyp_binary'],\n                                            options.toplevel_dir)\n  if not gyp_binary.startswith(os.sep):\n    gyp_binary = os.path.join('.', gyp_binary)\n\n  root_makefile.write(\n      \"quiet_cmd_regen_makefile = ACTION Regenerating $@\\n\"\n      \"cmd_regen_makefile = cd $(srcdir); %(cmd)s\\n\"\n      \"%(makefile_name)s: %(deps)s\\n\"\n      \"\\t$(call do_cmd,regen_makefile)\\n\\n\" % {\n          'makefile_name': makefile_name,\n          'deps': ' '.join(SourceifyAndQuoteSpaces(bf) for bf in build_files),\n          'cmd': gyp.common.EncodePOSIXShellList(\n                     [gyp_binary, '-fmake'] +\n                     gyp.RegenerateFlags(options) +\n                     build_files_args)})\n\n\ndef PerformBuild(data, configurations, params):\n  options = params['options']\n  for config in configurations:\n    arguments = ['make']\n    if options.toplevel_dir and options.toplevel_dir != '.':\n      arguments += '-C', options.toplevel_dir\n    arguments.append('BUILDTYPE=' + config)\n    print('Building [%s]: %s' % (config, arguments))\n    subprocess.check_call(arguments)\n\n\ndef GenerateOutput(target_list, target_dicts, data, params):\n  options = params['options']\n  flavor = gyp.common.GetFlavor(params)\n  generator_flags = params.get('generator_flags', {})\n  builddir_name = generator_flags.get('output_dir', 'out')\n  android_ndk_version = generator_flags.get('android_ndk_version', None)\n  default_target = generator_flags.get('default_target', 'all')\n\n  def CalculateMakefilePath(build_file, base_name):\n    \"\"\"Determine where to write a Makefile for a given gyp file.\"\"\"\n    # Paths in gyp files are relative to the .gyp file, but we want\n    # paths relative to the source root for the master makefile.  Grab\n    # the path of the .gyp file as the base to relativize against.\n    # E.g. \"foo/bar\" when we're constructing targets for \"foo/bar/baz.gyp\".\n    base_path = gyp.common.RelativePath(os.path.dirname(build_file),\n                                        options.depth)\n    # We write the file in the base_path directory.\n    output_file = os.path.join(options.depth, base_path, base_name)\n    if options.generator_output:\n      output_file = os.path.join(\n          options.depth, options.generator_output, base_path, base_name)\n    base_path = gyp.common.RelativePath(os.path.dirname(build_file),\n                                        options.toplevel_dir)\n    return base_path, output_file\n\n  # TODO:  search for the first non-'Default' target.  This can go\n  # away when we add verification that all targets have the\n  # necessary configurations.\n  default_configuration = None\n  toolsets = set([target_dicts[target]['toolset'] for target in target_list])\n  for target in target_list:\n    spec = target_dicts[target]\n    if spec['default_configuration'] != 'Default':\n      default_configuration = spec['default_configuration']\n      break\n  if not default_configuration:\n    default_configuration = 'Default'\n\n  srcdir = '.'\n  makefile_name = 'Makefile' + options.suffix\n  makefile_path = os.path.join(options.toplevel_dir, makefile_name)\n  if options.generator_output:\n    global srcdir_prefix\n    makefile_path = os.path.join(\n        options.toplevel_dir, options.generator_output, makefile_name)\n    srcdir = gyp.common.RelativePath(srcdir, options.generator_output)\n    srcdir_prefix = '$(srcdir)/'\n\n  flock_command= 'flock'\n  copy_archive_arguments = '-af'\n  makedep_arguments = '-MMD'\n  header_params = {\n      'default_target': default_target,\n      'builddir': builddir_name,\n      'default_configuration': default_configuration,\n      'flock': flock_command,\n      'flock_index': 1,\n      'link_commands': LINK_COMMANDS_LINUX,\n      'extra_commands': '',\n      'srcdir': srcdir,\n      'copy_archive_args': copy_archive_arguments,\n      'makedep_args': makedep_arguments,\n      'CC.target':   GetEnvironFallback(('CC_target', 'CC'), '$(CC)'),\n      'AR.target':   GetEnvironFallback(('AR_target', 'AR'), '$(AR)'),\n      'CXX.target':  GetEnvironFallback(('CXX_target', 'CXX'), '$(CXX)'),\n      'LINK.target': GetEnvironFallback(('LINK_target', 'LINK'), '$(LINK)'),\n      'CC.host':     GetEnvironFallback(('CC_host', 'CC'), 'gcc'),\n      'AR.host':     GetEnvironFallback(('AR_host', 'AR'), 'ar'),\n      'CXX.host':    GetEnvironFallback(('CXX_host', 'CXX'), 'g++'),\n      'LINK.host':   GetEnvironFallback(('LINK_host', 'LINK'), '$(CXX.host)'),\n    }\n  if flavor == 'mac':\n    flock_command = './gyp-mac-tool flock'\n    header_params.update({\n        'flock': flock_command,\n        'flock_index': 2,\n        'link_commands': LINK_COMMANDS_MAC,\n        'extra_commands': SHARED_HEADER_MAC_COMMANDS,\n    })\n  elif flavor == 'android':\n    header_params.update({\n        'link_commands': LINK_COMMANDS_ANDROID,\n    })\n  elif flavor == 'zos':\n    copy_archive_arguments = '-fPR'\n    makedep_arguments = '-qmakedep=gcc'\n    header_params.update({\n        'copy_archive_args': copy_archive_arguments,\n        'makedep_args': makedep_arguments,\n        'link_commands': LINK_COMMANDS_OS390,\n        'CC.target':   GetEnvironFallback(('CC_target', 'CC'), 'njsc'),\n        'CXX.target':  GetEnvironFallback(('CXX_target', 'CXX'), 'njsc++'),\n        'CC.host':     GetEnvironFallback(('CC_host', 'CC'), 'njsc'),\n        'CXX.host':    GetEnvironFallback(('CXX_host', 'CXX'), 'njsc++'),\n    })\n  elif flavor == 'solaris':\n    header_params.update({\n        'flock': './gyp-flock-tool flock',\n        'flock_index': 2,\n    })\n  elif flavor == 'freebsd':\n    # Note: OpenBSD has sysutils/flock. lockf seems to be FreeBSD specific.\n    header_params.update({\n        'flock': 'lockf',\n    })\n  elif flavor == 'openbsd':\n    copy_archive_arguments = '-pPRf'\n    header_params.update({\n        'copy_archive_args': copy_archive_arguments,\n    })\n  elif flavor == 'aix':\n    copy_archive_arguments = '-pPRf'\n    header_params.update({\n        'copy_archive_args': copy_archive_arguments,\n        'link_commands': LINK_COMMANDS_AIX,\n        'flock': './gyp-flock-tool flock',\n        'flock_index': 2,\n    })\n\n  build_file, _, _ = gyp.common.ParseQualifiedTarget(target_list[0])\n  make_global_settings_array = data[build_file].get('make_global_settings', [])\n  wrappers = {}\n  for key, value in make_global_settings_array:\n    if key.endswith('_wrapper'):\n      wrappers[key[:-len('_wrapper')]] = '$(abspath %s)' % value\n  make_global_settings = ''\n  for key, value in make_global_settings_array:\n    if re.match('.*_wrapper', key):\n      continue\n    if value[0] != '$':\n      value = '$(abspath %s)' % value\n    wrapper = wrappers.get(key)\n    if wrapper:\n      value = '%s %s' % (wrapper, value)\n      del wrappers[key]\n    if key in ('CC', 'CC.host', 'CXX', 'CXX.host'):\n      make_global_settings += (\n          'ifneq (,$(filter $(origin %s), undefined default))\\n' % key)\n      # Let gyp-time envvars win over global settings.\n      env_key = key.replace('.', '_')  # CC.host -> CC_host\n      if env_key in os.environ:\n        value = os.environ[env_key]\n      make_global_settings += '  %s = %s\\n' % (key, value)\n      make_global_settings += 'endif\\n'\n    else:\n      make_global_settings += '%s ?= %s\\n' % (key, value)\n  # TODO(ukai): define cmd when only wrapper is specified in\n  # make_global_settings.\n\n  header_params['make_global_settings'] = make_global_settings\n\n  gyp.common.EnsureDirExists(makefile_path)\n  root_makefile = open(makefile_path, 'w')\n  root_makefile.write(SHARED_HEADER % header_params)\n  # Currently any versions have the same effect, but in future the behavior\n  # could be different.\n  if android_ndk_version:\n    root_makefile.write(\n        '# Define LOCAL_PATH for build of Android applications.\\n'\n        'LOCAL_PATH := $(call my-dir)\\n'\n        '\\n')\n  for toolset in toolsets:\n    root_makefile.write('TOOLSET := %s\\n' % toolset)\n    WriteRootHeaderSuffixRules(root_makefile)\n\n  # Put build-time support tools next to the root Makefile.\n  dest_path = os.path.dirname(makefile_path)\n  gyp.common.CopyTool(flavor, dest_path)\n\n  # Find the list of targets that derive from the gyp file(s) being built.\n  needed_targets = set()\n  for build_file in params['build_files']:\n    for target in gyp.common.AllTargets(target_list, target_dicts, build_file):\n      needed_targets.add(target)\n\n  build_files = set()\n  include_list = set()\n  for qualified_target in target_list:\n    build_file, target, toolset = gyp.common.ParseQualifiedTarget(\n        qualified_target)\n\n    this_make_global_settings = data[build_file].get('make_global_settings', [])\n    assert make_global_settings_array == this_make_global_settings, (\n        \"make_global_settings needs to be the same for all targets. %s vs. %s\" %\n        (this_make_global_settings, make_global_settings))\n\n    build_files.add(gyp.common.RelativePath(build_file, options.toplevel_dir))\n    included_files = data[build_file]['included_files']\n    for included_file in included_files:\n      # The included_files entries are relative to the dir of the build file\n      # that included them, so we have to undo that and then make them relative\n      # to the root dir.\n      relative_include_file = gyp.common.RelativePath(\n          gyp.common.UnrelativePath(included_file, build_file),\n          options.toplevel_dir)\n      abs_include_file = os.path.abspath(relative_include_file)\n      # If the include file is from the ~/.gyp dir, we should use absolute path\n      # so that relocating the src dir doesn't break the path.\n      if (params['home_dot_gyp'] and\n          abs_include_file.startswith(params['home_dot_gyp'])):\n        build_files.add(abs_include_file)\n      else:\n        build_files.add(relative_include_file)\n\n    base_path, output_file = CalculateMakefilePath(build_file,\n        target + '.' + toolset + options.suffix + '.mk')\n\n    spec = target_dicts[qualified_target]\n    configs = spec['configurations']\n\n    if flavor == 'mac':\n      gyp.xcode_emulation.MergeGlobalXcodeSettingsToSpec(data[build_file], spec)\n\n    writer = MakefileWriter(generator_flags, flavor)\n    writer.Write(qualified_target, base_path, output_file, spec, configs,\n                 part_of_all=qualified_target in needed_targets)\n\n    # Our root_makefile lives at the source root.  Compute the relative path\n    # from there to the output_file for including.\n    mkfile_rel_path = gyp.common.RelativePath(output_file,\n                                              os.path.dirname(makefile_path))\n    include_list.add(mkfile_rel_path)\n\n  # Write out per-gyp (sub-project) Makefiles.\n  depth_rel_path = gyp.common.RelativePath(options.depth, os.getcwd())\n  for build_file in build_files:\n    # The paths in build_files were relativized above, so undo that before\n    # testing against the non-relativized items in target_list and before\n    # calculating the Makefile path.\n    build_file = os.path.join(depth_rel_path, build_file)\n    gyp_targets = [target_dicts[target]['target_name'] for target in target_list\n                   if target.startswith(build_file) and\n                   target in needed_targets]\n    # Only generate Makefiles for gyp files with targets.\n    if not gyp_targets:\n      continue\n    base_path, output_file = CalculateMakefilePath(build_file,\n        os.path.splitext(os.path.basename(build_file))[0] + '.Makefile')\n    makefile_rel_path = gyp.common.RelativePath(os.path.dirname(makefile_path),\n                                                os.path.dirname(output_file))\n    writer.WriteSubMake(output_file, makefile_rel_path, gyp_targets,\n                        builddir_name)\n\n\n  # Write out the sorted list of includes.\n  root_makefile.write('\\n')\n  for include_file in sorted(include_list):\n    # We wrap each .mk include in an if statement so users can tell make to\n    # not load a file by setting NO_LOAD.  The below make code says, only\n    # load the .mk file if the .mk filename doesn't start with a token in\n    # NO_LOAD.\n    root_makefile.write(\n        \"ifeq ($(strip $(foreach prefix,$(NO_LOAD),\\\\\\n\"\n        \"    $(findstring $(join ^,$(prefix)),\\\\\\n\"\n        \"                 $(join ^,\" + include_file + \")))),)\\n\")\n    root_makefile.write(\"  include \" + include_file + \"\\n\")\n    root_makefile.write(\"endif\\n\")\n  root_makefile.write('\\n')\n\n  if (not generator_flags.get('standalone')\n      and generator_flags.get('auto_regeneration', True)):\n    WriteAutoRegenerationRule(params, root_makefile, makefile_name, build_files)\n\n  root_makefile.write(SHARED_FOOTER)\n\n  root_makefile.close()\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/docs/src/images/npm-icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/docs/public/icons/icon-72x72.png",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/docs/public/icons/icon-144x144.png",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/docs/public/icons/icon-192x192.png",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/docs/public/icons/icon-512x512.png",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/docs/public/icons/icon-384x384.png",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/docs/public/icons/icon-96x96.png",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/docs/public/icons/icon-256x256.png",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/docs/public/icons/icon-48x48.png",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/retry/equation.gif",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/node-gyp/gyp/pylib/gyp/xcode_ninja.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/node-gyp/gyp/pylib/gyp/xcodeproj_file.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/node-gyp/gyp/pylib/gyp/ninja_syntax.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/node-gyp/gyp/pylib/gyp/MSVSVersion.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/node-gyp/gyp/pylib/gyp/input.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/node-gyp/gyp/pylib/gyp/simple_copy.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/node-gyp/gyp/pylib/gyp/MSVSUtil.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/node-gyp/gyp/pylib/gyp/__init__.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/node-gyp/gyp/pylib/gyp/msvs_emulation.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/node-gyp/gyp/pylib/gyp/xcode_emulation.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/node-gyp/gyp/pylib/gyp/common.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/node-gyp/gyp/pylib/gyp/generator/ninja.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/node-gyp/gyp/pylib/gyp/generator/xcode.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/node-gyp/gyp/pylib/gyp/generator/__init__.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/node-gyp/gyp/pylib/gyp/generator/make.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/qrcode-terminal/example/basic.png",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/mute-stream/coverage/lcov-report/sort-arrow-sprite.png",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/promise-retry/node_modules/retry/equation.gif",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/unique-filename/coverage/sort-arrow-sprite.png",
        "/tmp/vanessa/spack-stage/spack-stage-npm-6.14.9-5bqo5dxudizhk6z25rzfkxymdhy2eoaf/spack-src/node_modules/term-size/vendor/windows/term-size.exe"
    ],
    "total_files": 3868
}