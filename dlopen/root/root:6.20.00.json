{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/io/io/src/TGenCollectionProxy.cxx": "// @(#)root/io:$Id$\n// Author: Markus Frank 28/10/04\n\n/*************************************************************************\n * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers.               *\n * All rights reserved.                                                  *\n *                                                                       *\n * For the licensing terms see $ROOTSYS/LICENSE.                         *\n * For the list of contributors see $ROOTSYS/README/CREDITS.             *\n *************************************************************************/\n\n#include \"TGenCollectionProxy.h\"\n#include \"TVirtualStreamerInfo.h\"\n#include \"TStreamerElement.h\"\n#include \"TClassEdit.h\"\n#include \"TClass.h\"\n#include \"TError.h\"\n#include \"TROOT.h\"\n#include \"TInterpreter.h\"\n#include \"Riostream.h\"\n#include \"TVirtualMutex.h\"\n#include \"TStreamerInfoActions.h\"\n#include \"THashTable.h\"\n#include \"THashList.h\"\n#include <stdlib.h>\n\n#include \"TInterpreter.h\" // For gInterpreterMutex\n\n#define MESSAGE(which,text)\n\n/**\n\\class TGenVectorProxy\n\\ingroup IO\nLocal optimization class.\n\nCollection proxies get copied. On copy we switch the type of the\nproxy to the concrete STL type. The concrete types are optimized\nfor element access.\n*/\n\nclass TGenVectorProxy : public TGenCollectionProxy {\npublic:\n   // Standard Destructor\n   TGenVectorProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c)\n   {\n   }\n   // Standard Destructor\n   virtual ~TGenVectorProxy()\n{\n   }\n   // Return the address of the value at index 'idx'\n   virtual void* At(UInt_t idx)\n{\n      if ( fEnv && fEnv->fObject ) {\n         fEnv->fIdx = idx;\n         switch( idx ) {\n         case 0:\n            return fEnv->fStart = fFirst.invoke(fEnv);\n         default:\n            if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);\n            return ((char*)fEnv->fStart) + fValDiff*idx;\n         }\n      }\n      Fatal(\"TGenVectorProxy\",\"At> Logic error - no proxy object set.\");\n      return 0;\n   }\n   // Call to delete/destruct individual item\n   virtual void DeleteItem(Bool_t force, void* ptr) const\n   {\n      if ( force && ptr ) {\n         if ( fVal->fProperties&kNeedDelete) {\n            TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionProxy();\n            TPushPop helper(proxy,ptr);\n            proxy->Clear(\"force\");\n         }\n         fVal->DeleteItem(ptr);\n      }\n   }\n};\n\n/**\n\\class TGenVectorBoolProxy\n\\ingroup IO\nLocal optimization class.\n\nCollection proxies get copied. On copy we switch the type of the\nproxy to the concrete STL type. The concrete types are optimized\nfor element access.\n*/\nclass TGenVectorBoolProxy : public TGenCollectionProxy {\n   Bool_t fLastValue;\n\npublic:\n   TGenVectorBoolProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c), fLastValue(false)\n   {\n      // Standard Constructor.\n   }\n   virtual ~TGenVectorBoolProxy()\n   {\n      // Standard Destructor.\n   }\n   virtual void* At(UInt_t idx)\n   {\n      // Return the address of the value at index 'idx'\n\n      // However we can 'take' the address of the content of std::vector<bool>.\n      if ( fEnv && fEnv->fObject ) {\n         auto vec = (std::vector<bool> *)(fEnv->fObject);\n         fLastValue = (*vec)[idx];\n         fEnv->fIdx = idx;\n         return &fLastValue;\n      }\n      Fatal(\"TGenVectorProxy\",\"At> Logic error - no proxy object set.\");\n      return 0;\n   }\n\n   virtual void DeleteItem(Bool_t force, void* ptr) const\n   {\n      // Call to delete/destruct individual item\n      if ( force && ptr ) {\n         fVal->DeleteItem(ptr);\n      }\n   }\n};\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n//  class TGenBitsetProxy\n//\n//   Local optimization class.\n//\n//   Collection proxies get copied. On copy we switch the type of the\n//   proxy to the concrete STL type. The concrete types are optimized\n//   for element access.\n//\n//////////////////////////////////////////////////////////////////////////\nclass TGenBitsetProxy : public TGenCollectionProxy {\n\npublic:\n   TGenBitsetProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c)\n   {\n      // Standard Constructor.\n   }\n   virtual ~TGenBitsetProxy()\n   {\n      // Standard Destructor.\n   }\n   virtual void* At(UInt_t idx)\n   {\n      // Return the address of the value at index 'idx'\n\n      // However we can 'take' the address of the content of std::vector<bool>.\n      if ( fEnv && fEnv->fObject ) {\n         switch( idx ) {\n            case 0:\n               fEnv->fStart = fFirst.invoke(fEnv);\n               fEnv->fIdx = idx;\n               break;\n            default:\n               fEnv->fIdx = idx - fEnv->fIdx;\n               if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);\n               fNext.invoke(fEnv);\n               fEnv->fIdx = idx;\n               break;\n         }\n         typedef ROOT::TCollectionProxyInfo::Environ<std::pair<size_t,Bool_t> > EnvType_t;\n         EnvType_t *e = (EnvType_t*)fEnv;\n         return &(e->fIterator.second);\n      }\n      Fatal(\"TGenVectorProxy\",\"At> Logic error - no proxy object set.\");\n      return 0;\n   }\n\n   virtual void DeleteItem(Bool_t force, void* ptr) const\n   {\n      // Call to delete/destruct individual item\n      if ( force && ptr ) {\n         fVal->DeleteItem(ptr);\n      }\n   }\n};\n\n/*\n\\class TGenListProxy\n\\ingroup IO\nLocal optimization class.\n\nCollection proxies get copied. On copy we switch the type of the\nproxy to the concrete STL type. The concrete types are optimized\nfor element access.\n**/\n\nclass TGenListProxy : public TGenVectorProxy {\npublic:\n   // Standard Destructor\n   TGenListProxy(const TGenCollectionProxy& c) : TGenVectorProxy(c)\n{\n   }\n   // Standard Destructor\n   virtual ~TGenListProxy()\n{\n   }\n   // Return the address of the value at index 'idx'\n   void* At(UInt_t idx)\n{\n      if ( fEnv && fEnv->fObject ) {\n         switch( idx ) {\n         case 0:\n            fEnv->fIdx = idx;\n            return fEnv->fStart = fFirst.invoke(fEnv);\n         default:  {\n            fEnv->fIdx = idx - fEnv->fIdx;\n            if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);\n            void* result = fNext.invoke(fEnv);\n            fEnv->fIdx = idx;\n            return result;\n         }\n         }\n      }\n      Fatal(\"TGenListProxy\",\"At> Logic error - no proxy object set.\");\n      return 0;\n   }\n};\n\n/**\n\\class TGenSetProxy\n\\ingroup IO\nLocaloptimization class.\n\nCollection proxies get copied. On copy we switch the type of the\nproxy to the concrete STL type. The concrete types are optimized\nfor element access.\n*/\n\nclass TGenSetProxy : public TGenVectorProxy {\npublic:\n   // Standard Destructor\n   TGenSetProxy(const TGenCollectionProxy& c) : TGenVectorProxy(c)\n{\n   }\n   // Standard Destructor\n   virtual ~TGenSetProxy()\n{\n   }\n   // Return the address of the value at index 'idx'\n   void* At(UInt_t idx)\n{\n      if ( fEnv && fEnv->fObject ) {\n         if ( fEnv->fUseTemp ) {\n            return (((char*)fEnv->fTemp)+idx*fValDiff);\n         }\n         switch( idx ) {\n         case 0:\n            fEnv->fIdx = idx;\n            return fEnv->fStart = fFirst.invoke(fEnv);\n         default:  {\n            fEnv->fIdx = idx - fEnv->fIdx;\n            if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);\n            void* result = fNext.invoke(fEnv);\n            fEnv->fIdx = idx;\n            return result;\n         }\n         }\n      }\n      Fatal(\"TGenSetProxy\",\"At> Logic error - no proxy object set.\");\n      return 0;\n   }\n};\n\n/**\n\\class TGenMapProxy\n\\ingroup IO\nLocaloptimization class.\n\nCollection proxies get copied. On copy we switch the type of the\nproxy to the concrete STL type. The concrete types are optimized\nfor element access.\n*/\n\nclass TGenMapProxy : public TGenSetProxy {\npublic:\n   // Standard Destructor\n   TGenMapProxy(const TGenCollectionProxy& c) : TGenSetProxy(c)\n{\n   }\n   // Standard Destructor\n   virtual ~TGenMapProxy()\n{\n   }\n   // Call to delete/destruct individual item\n   virtual void DeleteItem(Bool_t force, void* ptr) const\n   {\n      if (force) {\n         if ( fKey->fProperties&kNeedDelete) {\n            TVirtualCollectionProxy *proxy = fKey->fType->GetCollectionProxy();\n            TPushPop helper(proxy,fKey->fCase&kIsPointer ? *(void**)ptr : ptr);\n            proxy->Clear(\"force\");\n         }\n         if ( fVal->fProperties&kNeedDelete) {\n            TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionProxy();\n            char *addr = ((char*)ptr)+fValOffset;\n            TPushPop helper(proxy,fVal->fCase&kIsPointer ? *(void**)addr : addr);\n            proxy->Clear(\"force\");\n         }\n      }\n      if ( fKey->fCase&kIsPointer ) {\n         fKey->DeleteItem(*(void**)ptr);\n      }\n      if ( fVal->fCase&kIsPointer ) {\n         char *addr = ((char*)ptr)+fValOffset;\n         fVal->DeleteItem(*(void**)addr);\n      }\n   }\n};\n\n////////////////////////////////////////////////////////////////////////////////\n/// Constructor.\n\nTGenCollectionProxy::Value::Value(const std::string& inside_type, Bool_t silent)\n{\n   std::string inside = (inside_type.find(\"const \")==0) ? inside_type.substr(6) : inside_type;\n   fCase = 0;\n   fProperties = 0;\n   fCtor = 0;\n   fDtor = 0;\n   fDelete = 0;\n   fSize = std::string::npos;\n   fKind = kNoType_t;\n\n   // Let's treat the unique_ptr case\n   bool nameChanged = false;\n   std::string intype = TClassEdit::GetNameForIO(inside.c_str(), TClassEdit::EModType::kNone, &nameChanged);\n\n   bool isPointer = nameChanged; // unique_ptr is considered a pointer\n   // The incoming name is normalized (it comes from splitting the name of a TClass),\n   // so all we need to do is drop the last trailing star (if any) and record that information.\n   if (!nameChanged && intype[intype.length()-1] == '*') {\n      isPointer = true;\n      intype.pop_back();\n      if (intype[intype.length()-1] == '*') {\n         // The value is a pointer to a pointer\n         if (!silent)\n            Warning(\"TGenCollectionProxy::Value::Value\", \"I/O not supported for collection of pointer to pointer: %s\", inside_type.c_str());\n         fSize = sizeof(void*);\n         fKind = kVoid_t;\n         return;\n      }\n   }\n\n   if ( intype.substr(0,6) == \"string\" || intype.substr(0,11) == \"std::string\" ) {\n      fCase = kBIT_ISSTRING;\n      fType = TClass::GetClass(\"string\");\n      fCtor = fType->GetNew();\n      fDtor = fType->GetDestructor();\n      fDelete = fType->GetDelete();\n      if (isPointer) {\n         fCase |= kIsPointer;\n         fSize = sizeof(void*);\n      } else {\n         fSize = sizeof(std::string);\n      }\n   }\n   else {\n      // In the case where we have an emulated class,\n      // if the class is nested (in a class or a namespace),\n      // calling G__TypeInfo ti(inside.c_str());\n      // might fail because CINT does not known the nesting\n      // scope, so let's first look for an emulated class:\n\n      fType = TClass::GetClass(intype.c_str(),kTRUE,silent);\n\n      if (fType) {\n         if (isPointer) {\n            fCase |= kIsPointer;\n            fSize = sizeof(void*);\n            if (fType == TString::Class()) {\n               fCase |= kBIT_ISTSTRING;\n            }\n         }\n         fCase  |= kIsClass;\n         fCtor   = fType->GetNew();\n         fDtor   = fType->GetDestructor();\n         fDelete = fType->GetDelete();\n      } else {\n         R__LOCKGUARD(gInterpreterMutex);\n\n         // Try to avoid autoparsing.\n\n         THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );\n         THashList *enumTable = dynamic_cast<THashList*>( gROOT->GetListOfEnums() );\n\n         assert(typeTable && \"The type of the list of type has changed\");\n         assert(enumTable && \"The type of the list of enum has changed\");\n\n         TDataType *fundType = (TDataType *)typeTable->THashTable::FindObject( intype.c_str() );\n         if (fundType && fundType->GetType() < 0x17 && fundType->GetType() > 0) {\n            fKind = (EDataType)fundType->GetType();\n            // R__ASSERT((fKind>0 && fKind<0x17) || (fKind==-1&&(prop&kIsPointer)) );\n\n            fCase |= kIsFundamental;\n            if (isPointer) {\n               fCase |= kIsPointer;\n               fSize = sizeof(void*);\n            } else {\n               fSize = fundType->Size();\n            }\n         } else if (enumTable->THashList::FindObject( intype.c_str() ) ) {\n            // This is a known enum.\n            fCase = kIsEnum;\n            fSize = sizeof(Int_t);\n            fKind = kInt_t;\n            if (isPointer) {\n               fCase |= kIsPointer;\n               fSize = sizeof(void*);\n            }\n         } else {\n            // This fallback solution should be hardly used ...\n            // One of the common use case is to 'discover' that this is a\n            // collection for the content of which we do not have a dictionary\n            // which can happen at least in the following cases:\n            //    - empty emulated collection\n            //    - emulated collection of enums\n            // In those two cases there is no StreamerInfo stored in the file\n            // for the content.\n\n            // R__ASSERT(\"FallBack, should be hardly used.\");\n\n            TypeInfo_t *ti = gCling->TypeInfo_Factory();\n            gCling->TypeInfo_Init(ti,inside.c_str());\n            if ( !gCling->TypeInfo_IsValid(ti) ) {\n               if (isPointer) {\n                  fCase |= kIsPointer;\n                  fSize = sizeof(void*);\n               }\n               // Since we already search for GetClass earlier, this should\n               // never be true.\n//               fType = TClass::GetClass(intype.c_str(),kTRUE,silent);\n//               if (fType) {\n//                  fCase  |= kIsClass;\n//                  fCtor   = fType->GetNew();\n//                  fDtor   = fType->GetDestructor();\n//                  fDelete = fType->GetDelete();\n//               }\n//               else {\n                  // either we have an Emulated enum or a really unknown class!\n                  // let's just claim its an enum :(\n                  fCase = kIsEnum;\n                  fSize = sizeof(Int_t);\n                  fKind = kInt_t;\n//               }\n            }\n            else {\n               Long_t prop = gCling->TypeInfo_Property(ti);\n               if ( prop&kIsPointer ) {\n                  fSize = sizeof(void*);\n               }\n               if ( prop&kIsStruct ) {\n                  prop |= kIsClass;\n               }\n               // Since we already searched GetClass earlier, this should\n               // never be true.\n               R__ASSERT(! (prop&kIsClass) && \"Impossible code path\" );\n//               if ( prop&kIsClass ) {\n//                  fType = TClass::GetClass(intype.c_str(),kTRUE,silent);\n//                  R__ASSERT(fType);\n//                  fCtor   = fType->GetNew();\n//                  fDtor   = fType->GetDestructor();\n//                  fDelete = fType->GetDelete();\n//               }\n//               else\n               if ( prop&kIsFundamental ) {\n                  fundType = gROOT->GetType( intype.c_str() );\n                  if (fundType==0) {\n                     if (intype != \"long double\") {\n                        Error(\"TGenCollectionProxy\",\"Unknown fundamental type %s\",intype.c_str());\n                     }\n                     fSize = sizeof(int);\n                     fKind = kInt_t;\n                  } else {\n                     fKind = (EDataType)fundType->GetType();\n                     fSize = gCling->TypeInfo_Size(ti);\n                     R__ASSERT((fKind>0 && fKind<0x17) || (fKind==-1&&(prop&kIsPointer)) );\n                  }\n               }\n               else if ( prop&kIsEnum ) {\n                  fSize = sizeof(int);\n                  fKind = kInt_t;\n               }\n               fCase = prop & (kIsPointer|kIsFundamental|kIsEnum|kIsClass);\n               if (fType == TString::Class() && (fCase&kIsPointer)) {\n                  fCase |= kBIT_ISTSTRING;\n               }\n            }\n            gCling->TypeInfo_Delete(ti);\n         }\n      }\n      if (fType) {\n         TVirtualCollectionProxy *proxy = fType->GetCollectionProxy();\n         if (proxy && (proxy->GetProperties() & kNeedDelete)) {\n            fProperties |= kNeedDelete;\n         }\n      }\n   }\n   if ( fSize == std::string::npos ) {\n      if ( fType == 0 ) {\n         // The caller should check the validity by calling IsValid()\n      } else {\n         fSize = fType->Size();\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return true if the Value has been properly initialized.\n\nBool_t TGenCollectionProxy::Value::IsValid()\n{\n\n\n   return fSize != std::string::npos;\n}\n\nvoid TGenCollectionProxy::Value::DeleteItem(void* ptr)\n{\n   // Delete an item.\n\n   if ( ptr && fCase&kIsPointer ) {\n      if ( fDelete ) {\n         (*fDelete)(ptr);\n      }\n      else if ( fType ) {\n         fType->Destructor(ptr);\n      }\n      else {\n         ::operator delete(ptr);\n      }\n   }\n}\n\n/**\n \\class TGenCollectionProxy TGenCollectionProxy.cxx\n \\ingroup IO\n\n Proxy around an arbitrary container, which implements basic\n functionality and iteration.\n\n The purpose of this implementation\n is to shield any generated dictionary implementation from the\n underlying streamer/proxy implementation and only expose\n the creation functions.\n\n In particular this is used to implement splitting and abstract\n element access of any container. Access to compiled code is necessary\n to implement the abstract iteration sequence and functionality like\n size(), clear(), resize(). resize() may be a void operation.\n*/\n\n////////////////////////////////////////////////////////////////////////////////\n/// Build a proxy for an emulated container.\n\nTGenCollectionProxy::TGenCollectionProxy(const TGenCollectionProxy& copy)\n   : TVirtualCollectionProxy(copy.fClass),\n     fTypeinfo(copy.fTypeinfo)\n{\n   fEnv            = 0;\n   fName           = copy.fName;\n   fPointers       = copy.fPointers;\n   fSTL_type       = copy.fSTL_type;\n   fSize.call      = copy.fSize.call;\n   fNext.call      = copy.fNext.call;\n   fFirst.call     = copy.fFirst.call;\n   fClear.call     = copy.fClear.call;\n   fResize         = copy.fResize;\n   fDestruct       = copy.fDestruct;\n   fConstruct      = copy.fConstruct;\n   fFeed           = copy.fFeed;\n   fCollect        = copy.fCollect;\n   fCreateEnv.call = copy.fCreateEnv.call;\n   fValOffset      = copy.fValOffset;\n   fValDiff        = copy.fValDiff;\n   fValue          = copy.fValue.load() ? new Value(*copy.fValue) : 0;\n   fVal            = copy.fVal   ? new Value(*copy.fVal)   : 0;\n   fKey            = copy.fKey   ? new Value(*copy.fKey)   : 0;\n   fOnFileClass    = copy.fOnFileClass;\n   fReadMemberWise = new TObjArray(TCollection::kInitCapacity,-1);\n   fConversionReadMemberWise = 0;\n   fWriteMemberWise = 0;\n   fProperties     = copy.fProperties;\n   fFunctionCreateIterators    = copy.fFunctionCreateIterators;\n   fFunctionCopyIterator       = copy.fFunctionCopyIterator;\n   fFunctionNextIterator       = copy.fFunctionNextIterator;\n   fFunctionDeleteIterator     = copy.fFunctionDeleteIterator;\n   fFunctionDeleteTwoIterators = copy.fFunctionDeleteTwoIterators;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Build a proxy for a collection whose type is described by 'collectionClass'.\n\nTGenCollectionProxy::TGenCollectionProxy(Info_t info, size_t iter_size)\n   : TVirtualCollectionProxy(0),\n     fTypeinfo(info)\n{\n   fEnv             = 0;\n   fSize.call       = 0;\n   fFirst.call      = 0;\n   fNext.call       = 0;\n   fClear.call      = 0;\n   fResize          = 0;\n   fDestruct        = 0;\n   fConstruct       = 0;\n   fCollect         = 0;\n   fCreateEnv.call  = 0;\n   fFeed            = 0;\n   fValue           = 0;\n   fKey             = 0;\n   fVal             = 0;\n   fValOffset       = 0;\n   fValDiff         = 0;\n   fPointers        = false;\n   fOnFileClass     = 0;\n   fSTL_type        = ROOT::kNotSTL;\n   Env_t e;\n   if ( iter_size > sizeof(e.fIterator) ) {\n      Fatal(\"TGenCollectionProxy\",\n            \"%s %s are too large:%ld bytes. Maximum is:%ld bytes\",\n            \"Iterators for collection\",\n            fClass->GetName(),\n            (Long_t)iter_size,\n            (Long_t)sizeof(e.fIterator));\n   }\n   fReadMemberWise = new TObjArray(TCollection::kInitCapacity,-1);\n   fConversionReadMemberWise   = 0;\n   fWriteMemberWise            = 0;\n   fFunctionCreateIterators    = 0;\n   fFunctionCopyIterator       = 0;\n   fFunctionNextIterator       = 0;\n   fFunctionDeleteIterator     = 0;\n   fFunctionDeleteTwoIterators = 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Build a proxy for a collection whose type is described by 'collectionClass'.\n\nTGenCollectionProxy::TGenCollectionProxy(const ROOT::TCollectionProxyInfo &info, TClass *cl)\n   : TVirtualCollectionProxy(cl),\n     fTypeinfo(info.fInfo), fOnFileClass(0)\n{\n   fEnv            = 0;\n   fValDiff        = info.fValueDiff;\n   fValOffset      = info.fValueOffset;\n   fSize.call      = info.fSizeFunc;\n   fResize         = info.fResizeFunc;\n   fNext.call      = info.fNextFunc;\n   fFirst.call     = info.fFirstFunc;\n   fClear.call     = info.fClearFunc;\n   fConstruct      = info.fConstructFunc;\n   fDestruct       = info.fDestructFunc;\n   fFeed           = info.fFeedFunc;\n   fCollect        = info.fCollectFunc;\n   fCreateEnv.call = info.fCreateEnv;\n\n   if (cl) {\n      fName = cl->GetName();\n   }\n   CheckFunctions();\n\n   fValue           = 0;\n   fKey             = 0;\n   fVal             = 0;\n   fPointers        = false;\n   fSTL_type        = ROOT::kNotSTL;\n\n   Env_t e;\n   if ( info.fIterSize > sizeof(e.fIterator) ) {\n      Fatal(\"TGenCollectionProxy\",\n            \"%s %s are too large:%ld bytes. Maximum is:%ld bytes\",\n            \"Iterators for collection\",\n            fClass->GetName(),\n            (Long_t)info.fIterSize,\n            (Long_t)sizeof(e.fIterator));\n   }\n   fReadMemberWise = new TObjArray(TCollection::kInitCapacity,-1);\n   fConversionReadMemberWise   = 0;\n   fWriteMemberWise            = 0;\n   fFunctionCreateIterators    = info.fCreateIterators;\n   fFunctionCopyIterator       = info.fCopyIterator;\n   fFunctionNextIterator       = info.fNext;\n   fFunctionDeleteIterator     = info.fDeleteSingleIterator;\n   fFunctionDeleteTwoIterators = info.fDeleteTwoIterators;\n}\n\nnamespace {\n   template <class vec>\n   void clearVector(vec& v)\n   {\n      // Clear out the proxies.\n\n      for(typename vec::iterator i=v.begin(); i != v.end(); ++i) {\n         typename vec::value_type e = *i;\n         if ( e ) {\n            delete e;\n         }\n      }\n      v.clear();\n   }\n}\n////////////////////////////////////////////////////////////////////////////////\n/// Standard destructor\n\nTGenCollectionProxy::~TGenCollectionProxy()\n{\n   clearVector(fProxyList);\n   clearVector(fProxyKept);\n   clearVector(fStaged);\n\n   if ( fValue.load() ) delete fValue.load();\n   if ( fVal   ) delete fVal;\n   if ( fKey   ) delete fKey;\n\n   delete fReadMemberWise;\n   if (fConversionReadMemberWise) {\n      std::map<std::string, TObjArray*>::iterator it;\n      std::map<std::string, TObjArray*>::iterator end = fConversionReadMemberWise->end();\n      for( it = fConversionReadMemberWise->begin(); it != end; ++it ) {\n         delete it->second;\n      }\n      delete fConversionReadMemberWise;\n      fConversionReadMemberWise = 0;\n   }\n   delete fWriteMemberWise;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Virtual copy constructor\n\nTVirtualCollectionProxy* TGenCollectionProxy::Generate() const\n{\n   if ( !fValue.load() ) Initialize(kFALSE);\n\n   if( fPointers )\n      return new TGenCollectionProxy(*this);\n\n   switch(fSTL_type) {\n      case ROOT::kSTLbitset: {\n         return new TGenBitsetProxy(*this);\n      }\n      case ROOT::kSTLvector: {\n         if ((*fValue).fKind == kBool_t) {\n            return new TGenVectorBoolProxy(*this);\n         } else {\n            return new TGenVectorProxy(*this);\n         }\n      }\n      case ROOT::kSTLlist:\n      case ROOT::kSTLforwardlist:\n         return new TGenListProxy(*this);\n      case ROOT::kSTLmap:\n      case ROOT::kSTLunorderedmap:\n      case ROOT::kSTLmultimap:\n      case ROOT::kSTLunorderedmultimap:\n         return new TGenMapProxy(*this);\n      case ROOT::kSTLset:\n      case ROOT::kSTLunorderedset:\n      case ROOT::kSTLmultiset:\n      case ROOT::kSTLunorderedmultiset:\n         return new TGenSetProxy(*this);\n      default:\n         return new TGenCollectionProxy(*this);\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Proxy initializer\n\nTGenCollectionProxy *TGenCollectionProxy::Initialize(Bool_t silent) const\n{\n   TGenCollectionProxy* p = const_cast<TGenCollectionProxy*>(this);\n   if ( fValue.load() ) return p;\n   return p->InitializeEx(silent);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Check existence of function pointers\n\nvoid TGenCollectionProxy::CheckFunctions() const\n{\n   if ( 0 == fSize.call ) {\n      Fatal(\"TGenCollectionProxy\",\"No 'size' function pointer for class %s present.\",fName.c_str());\n   }\n   if ( 0 == fResize ) {\n      Fatal(\"TGenCollectionProxy\",\"No 'resize' function for class %s present.\",fName.c_str());\n   }\n   if ( 0 == fNext.call  ) {\n      Fatal(\"TGenCollectionProxy\",\"No 'next' function for class %s present.\",fName.c_str());\n   }\n   if ( 0 == fFirst.call ) {\n      Fatal(\"TGenCollectionProxy\",\"No 'begin' function for class %s present.\",fName.c_str());\n   }\n   if ( 0 == fClear.call ) {\n      Fatal(\"TGenCollectionProxy\",\"No 'clear' function for class %s present.\",fName.c_str());\n   }\n   if ( 0 == fConstruct ) {\n      Fatal(\"TGenCollectionProxy\",\"No 'block constructor' function for class %s present.\",fName.c_str());\n   }\n   if ( 0 == fDestruct ) {\n      Fatal(\"TGenCollectionProxy\",\"No 'block destructor' function for class %s present.\",fName.c_str());\n   }\n   if ( 0 == fFeed ) {\n      Fatal(\"TGenCollectionProxy\",\"No 'data feed' function for class %s present.\",fName.c_str());\n   }\n   if ( 0 == fCollect ) {\n      Fatal(\"TGenCollectionProxy\",\"No 'data collect' function for class %s present.\",fName.c_str());\n   }\n   if (0 == fCreateEnv.call ) {\n      Fatal(\"TGenCollectionProxy\",\"No 'environment creation' function for class %s present.\",fName.c_str());\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Utility routine to issue a Fatal error is the Value object is not valid\n\nstatic TGenCollectionProxy::Value *R__CreateValue(const std::string &name, Bool_t silent)\n{\n   TGenCollectionProxy::Value *val = new TGenCollectionProxy::Value( name, silent );\n   if ( !val->IsValid() ) {\n      Fatal(\"TGenCollectionProxy\",\"Could not find %s!\",name.c_str());\n   }\n   return val;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Proxy initializer\n\nTGenCollectionProxy *TGenCollectionProxy::InitializeEx(Bool_t silent)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   if (fValue.load()) return this;\n\n   TClass *cl = fClass ? fClass.GetClass() : TClass::GetClass(fTypeinfo,kTRUE,silent);\n   if ( cl ) {\n      fEnv    = 0;\n      fName   = cl->GetName();\n      fPointers   = false;\n      int nested = 0;\n      std::vector<std::string> inside;\n      int num = TClassEdit::GetSplit(cl->GetName(),inside,nested);\n      if ( num > 1 ) {\n         std::string nam;\n         Value* newfValue = nullptr;\n         if ( inside[0].find(\"stdext::hash_\") != std::string::npos )\n            inside[0].replace(3,10,\"::\");\n         if ( inside[0].find(\"__gnu_cxx::hash_\") != std::string::npos )\n            inside[0].replace(0,16,\"std::\");\n         fSTL_type = TClassEdit::STLKind(inside[0]);\n         switch ( fSTL_type ) {\n            case ROOT::kSTLmap:\n            case ROOT::kSTLunorderedmap:\n            case ROOT::kSTLmultimap:\n            case ROOT::kSTLunorderedmultimap:\n            case ROOT::kSTLset:\n            case ROOT::kSTLunorderedset:\n            case ROOT::kSTLmultiset:\n            case ROOT::kSTLunorderedmultiset:\n            case ROOT::kSTLbitset: // not really an associate container but it has no real iterator.\n               fProperties |= kIsAssociative;\n               if (num > 3 && !inside[3].empty()) {\n                  if (! TClassEdit::IsDefAlloc(inside[3].c_str(),inside[0].c_str())) {\n                     fProperties |= kCustomAlloc;\n                  }\n               }\n               break;\n         };\n\n         int slong = sizeof(void*);\n         switch ( fSTL_type ) {\n            case ROOT::kSTLmap:\n            case ROOT::kSTLunorderedmap:\n            case ROOT::kSTLmultimap:\n            case ROOT::kSTLunorderedmultimap:\n               nam = \"pair<\"+inside[1]+\",\"+inside[2];\n               nam += (nam[nam.length()-1]=='>') ? \" >\" : \">\";\n               newfValue = R__CreateValue(nam, silent);\n\n               fVal   = R__CreateValue(inside[2], silent);\n               fKey   = R__CreateValue(inside[1], silent);\n               fPointers = (0 != (fKey->fCase&kIsPointer));\n               if (fPointers || (0 != (fKey->fProperties&kNeedDelete))) {\n                  fProperties |= kNeedDelete;\n               }\n               if ( 0 == fValDiff ) {\n                  fValDiff = fKey->fSize + fVal->fSize;\n                  fValDiff += (slong - fKey->fSize%slong)%slong;\n                  fValDiff += (slong - fValDiff%slong)%slong;\n               }\n               if ( 0 == fValOffset ) {\n                  fValOffset = fKey->fSize;\n                  fValOffset += (slong - fKey->fSize%slong)%slong;\n               }\n               break;\n            case ROOT::kSTLbitset:\n               inside[1] = \"bool\";\n               // Intentional fall through\n            default:\n               newfValue = R__CreateValue(inside[1], silent);\n\n               fVal   = new Value(*newfValue);\n               if ( 0 == fValDiff ) {\n                  fValDiff = fVal->fSize;\n                  fValDiff += (slong - fValDiff%slong)%slong;\n               }\n               if (num > 2 && !inside[2].empty()) {\n                  if (! TClassEdit::IsDefAlloc(inside[2].c_str(),inside[0].c_str())) {\n                     fProperties |= kCustomAlloc;\n                  }\n               }\n               break;\n         }\n\n         fPointers = fPointers || (0 != (fVal->fCase&kIsPointer));\n         if (fPointers || (0 != (fVal->fProperties&kNeedDelete))) {\n            fProperties |= kNeedDelete;\n         }\n         fClass = cl;\n         //fValue must be set last since we use it to indicate that we are initialized\n         fValue = newfValue;\n         return this;\n      }\n      Fatal(\"TGenCollectionProxy\",\"Components of %s not analysed!\",cl->GetName());\n   }\n   Fatal(\"TGenCollectionProxy\",\"Collection class %s not found!\",fTypeinfo.name());\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a pointer to the TClass representing the container\n\nTClass *TGenCollectionProxy::GetCollectionClass() const\n{\n   return fClass ? fClass : Initialize(kFALSE)->fClass;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the type of collection see TClassEdit::ESTLType\n\nInt_t TGenCollectionProxy::GetCollectionType() const\n{\n   if (!fValue.load()) {\n      Initialize(kFALSE);\n   }\n   return fSTL_type;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the offset between two consecutive value_types (memory layout).\n\nULong_t TGenCollectionProxy::GetIncrement() const {\n   if (!fValue.load()) {\n      Initialize(kFALSE);\n   }\n   return fValDiff;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the sizeof the collection object.\n\nUInt_t TGenCollectionProxy::Sizeof() const\n{\n   return fClass->Size();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return true if the content is of type 'pointer to'\n\nBool_t TGenCollectionProxy::HasPointers() const\n{\n   // Initialize proxy in case it hasn't been initialized yet\n   if( !fValue.load() )\n      Initialize(kFALSE);\n\n   // The content of a map and multimap is always a 'pair' and hence\n   // fPointers means \"Flag to indicate if containee has pointers (key or value)\"\n   // so we need to ignore its value for map and multimap;\n   return fPointers && !(fSTL_type == ROOT::kSTLmap || fSTL_type == ROOT::kSTLmultimap ||\n                         fSTL_type == ROOT::kSTLunorderedmap || fSTL_type == ROOT::kSTLunorderedmultimap);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a pointer to the TClass representing the content.\n\nTClass *TGenCollectionProxy::GetValueClass() const\n{\n   if (!fValue.load()) Initialize(kFALSE);\n   return fValue.load() ? (*fValue).fType.GetClass() : 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Update the internal ValueClass when a TClass constructor need to\n/// replace an emulated TClass by the real TClass.\n\nvoid TGenCollectionProxy::UpdateValueClass(const TClass *oldValueType, TClass *newValueType)\n{\n   // Note that we do not need to update anything if we have not yet been\n   // initialized.  In addition (see ROOT-6040) doing an initialization here\n   // might hence a nested dlopen (due to autoloading).\n   if (fValue.load() && (*fValue).fType == oldValueType) {\n      // Set pointer to the TClass representing the content.\n      (*fValue).fType = newValueType;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// If the content is a simple numerical value, return its type (see TDataType)\n\nEDataType TGenCollectionProxy::GetType() const\n{\n   if ( !fValue.load() ) Initialize(kFALSE);\n   return (*fValue).fKind;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the address of the value at index 'idx'\n\nvoid* TGenCollectionProxy::At(UInt_t idx)\n{\n   if ( fEnv && fEnv->fObject ) {\n      switch (fSTL_type) {\n      case ROOT::kSTLvector:\n         if ((*fValue).fKind == kBool_t) {\n            auto vec = (std::vector<bool> *)(fEnv->fObject);\n            fEnv->fLastValueVecBool = (*vec)[idx];\n            fEnv->fIdx = idx;\n            return &(fEnv->fLastValueVecBool);\n         }\n         fEnv->fIdx = idx;\n         switch( idx ) {\n         case 0:\n            return fEnv->fStart = fFirst.invoke(fEnv);\n         default:\n            if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);\n            return ((char*)fEnv->fStart) + fValDiff*idx;\n         }\n      case ROOT::kSTLbitset: {\n         switch (idx) {\n         case 0:\n            fEnv->fStart = fFirst.invoke(fEnv);\n            fEnv->fIdx = idx;\n            break;\n         default:\n            fEnv->fIdx = idx - fEnv->fIdx;\n            if (!fEnv->fStart) fEnv->fStart = fFirst.invoke(fEnv);\n            fNext.invoke(fEnv);\n            fEnv->fIdx = idx;\n            break;\n         }\n         typedef ROOT::TCollectionProxyInfo::Environ <std::pair<size_t, Bool_t>> EnvType_t;\n         EnvType_t *e = (EnvType_t *) fEnv;\n         return &(e->fIterator.second);\n      }\n      case ROOT::kSTLset:\n      case ROOT::kSTLunorderedset:\n      case ROOT::kSTLmultiset:\n      case ROOT::kSTLunorderedmultiset:\n      case ROOT::kSTLmap:\n      case ROOT::kSTLunorderedmap:\n      case ROOT::kSTLmultimap:\n      case ROOT::kSTLunorderedmultimap:\n         if ( fEnv->fUseTemp ) {\n            return (((char*)fEnv->fTemp)+idx*fValDiff);\n         }\n         // Intentional fall through.\n      default:\n         switch( idx ) {\n         case 0:\n            fEnv->fIdx = idx;\n            return fEnv->fStart = fFirst.invoke(fEnv);\n         default:  {\n            fEnv->fIdx = idx - fEnv->fIdx;\n            if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);\n            void* result = fNext.invoke(fEnv);\n            fEnv->fIdx = idx;\n            return result;\n         }\n         }\n      }\n   }\n   Fatal(\"TGenCollectionProxy\",\"At> Logic error - no proxy object set.\");\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Clear the emulated collection.\n\nvoid TGenCollectionProxy::Clear(const char* opt)\n{\n   if ( fEnv && fEnv->fObject ) {\n      if ( (fProperties & kNeedDelete) && opt && *opt=='f' ) {\n         size_t i, n = *(size_t*)fSize.invoke(fEnv);\n         if ( n > 0 ) {\n            for (i=0; i<n; ++i)\n               DeleteItem(true, TGenCollectionProxy::At(i));\n         }\n      }\n      fClear.invoke(fEnv);\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the current size of the container\n\nUInt_t TGenCollectionProxy::Size() const\n{\n   if ( fEnv && fEnv->fObject ) {\n      if (fEnv->fUseTemp) {\n         return fEnv->fSize;\n      } else {\n         return *(size_t*)fSize.invoke(fEnv);\n      }\n   }\n   Fatal(\"TGenCollectionProxy\",\"Size> Logic error - no proxy object set.\");\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Resize the container\n\nvoid TGenCollectionProxy::Resize(UInt_t n, Bool_t force)\n{\n   if ( fEnv && fEnv->fObject ) {\n      if ( force && fPointers ) {\n         size_t i, nold = *(size_t*)fSize.invoke(fEnv);\n         if ( n != nold ) {\n            for (i=n; i<nold; ++i)\n               DeleteItem(true, *(void**)TGenCollectionProxy::At(i));\n         }\n      }\n      MESSAGE(3, \"Resize(n)\" );\n      fEnv->fSize = n;\n      fResize(fEnv->fObject,fEnv->fSize);\n      return;\n   }\n   Fatal(\"TGenCollectionProxy\",\"Resize> Logic error - no proxy object set.\");\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Allocate the needed space.\n/// For associative collection, this returns a TStaging object that\n/// need to be deleted manually __or__ returned by calling Commit(TStaging*)\n\nvoid* TGenCollectionProxy::Allocate(UInt_t n, Bool_t /* forceDelete */ )\n{\n   if ( fEnv && fEnv->fObject ) {\n      switch ( fSTL_type ) {\n         case ROOT::kSTLset:\n         case ROOT::kSTLunorderedset:\n         case ROOT::kSTLmultiset:\n         case ROOT::kSTLunorderedmultiset:\n         case ROOT::kSTLmap:\n         case ROOT::kSTLunorderedmap:\n         case ROOT::kSTLmultimap:\n         case ROOT::kSTLunorderedmultimap:{\n            if ( (fProperties & kNeedDelete) )\n               Clear(\"force\");\n            else\n               fClear.invoke(fEnv);\n            // Commit no longer use the environment and thus no longer decrease\n            // the count.  Consequently we no longer should increase it here.\n            // ++fEnv->fRefCount;\n            fEnv->fSize  = n;\n\n            TStaging *s;\n            if (fStaged.empty()) {\n               s = new TStaging(n,fValDiff);\n            } else {\n               s = fStaged.back();\n               fStaged.pop_back();\n               s->Resize(n);\n            }\n            fConstruct(s->GetContent(),s->GetSize());\n\n            s->SetTarget(fEnv->fObject);\n\n            fEnv->fTemp = s->GetContent();\n            fEnv->fUseTemp = kTRUE;\n            fEnv->fStart = fEnv->fTemp;\n\n            return s;\n         }\n         case ROOT::kSTLvector:\n         case ROOT::kSTLlist:\n         case ROOT::kSTLforwardlist:\n         case ROOT::kSTLdeque:\n            if( (fProperties & kNeedDelete) ) {\n               Clear(\"force\");\n            }\n            fEnv->fSize = n;\n            fResize(fEnv->fObject,n);\n            return fEnv->fObject;\n\n        case ROOT::kSTLbitset: {\n            TStaging *s;\n            if (fStaged.empty()) {\n               s = new TStaging(n,fValDiff);\n            } else {\n               s = fStaged.back();\n               fStaged.pop_back();\n               s->Resize(n);\n            }\n            s->SetTarget(fEnv->fObject);\n\n            fEnv->fTemp = s->GetContent();\n            fEnv->fUseTemp = kTRUE;\n            fEnv->fStart = fEnv->fTemp;\n\n            return s;\n        }\n      }\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Insert data into the container where data is a C-style array of the actual type contained in the collection\n/// of the given size.   For associative container (map, etc.), the data type is the pair<key,value>.\n\nvoid TGenCollectionProxy::Insert(const void *data, void *container, size_t size)\n{\n   fFeed((void*)data,container,size);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Commit the change.\n\nvoid TGenCollectionProxy::Commit(void* from)\n{\n   if (fProperties & kIsAssociative) {\n//      case ROOT::kSTLmap:\n//      case ROOT::kSTLmultimap:\n//      case ROOT::kSTLset:\n//      case ROOT::kSTLmultiset:\n      if ( from ) {\n         TStaging *s = (TStaging*) from;\n         if ( s->GetTarget() ) {\n            fFeed(s->GetContent(),s->GetTarget(),s->GetSize());\n         }\n         fDestruct(s->GetContent(),s->GetSize());\n         s->SetTarget(0);\n         fStaged.push_back(s);\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Add an object.\n\nvoid TGenCollectionProxy::PushProxy(void *objstart)\n{\n   if ( !fValue.load() ) Initialize(kFALSE);\n   if ( !fProxyList.empty() ) {\n      EnvironBase_t* back = fProxyList.back();\n      if ( back->fObject == objstart ) {\n         ++back->fRefCount;\n         fProxyList.push_back(back);\n         fEnv = back;\n         return;\n      }\n   }\n   EnvironBase_t* e    = 0;\n   if ( fProxyKept.empty() ) {\n      e = (EnvironBase_t*)fCreateEnv.invoke();\n      e->fTemp  = 0;\n      e->fUseTemp = kFALSE;\n   }\n   else {\n      e = fProxyKept.back();\n      fProxyKept.pop_back();\n   }\n   e->fSize     = 0;\n   e->fRefCount = 1;\n   e->fObject   = objstart;\n   e->fStart    = 0;\n   e->fIdx      = 0;\n   // ::memset(e->buff,0,sizeof(e->buff));\n   fProxyList.push_back(e);\n   fEnv = e;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Remove the last object.\n\nvoid TGenCollectionProxy::PopProxy()\n{\n   if ( !fProxyList.empty() ) {\n      EnvironBase_t* e = fProxyList.back();\n      if ( --e->fRefCount <= 0 ) {\n         fProxyKept.push_back(e);\n         e->fUseTemp = kFALSE;\n      }\n      fProxyList.pop_back();\n   }\n   fEnv = fProxyList.empty() ? 0 : fProxyList.back();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Call to delete/destruct individual item.\n\nvoid TGenCollectionProxy::DeleteItem(Bool_t force, void* ptr) const\n{\n   if ( force && ptr ) {\n      switch (fSTL_type) {\n         case ROOT::kSTLmap:\n         case ROOT::kSTLunorderedmap:\n         case ROOT::kSTLmultimap:\n         case ROOT::kSTLunorderedmultimap:{\n            if ( fKey->fCase&kIsPointer ) {\n               if (fKey->fProperties&kNeedDelete) {\n                  TVirtualCollectionProxy *proxy = fKey->fType->GetCollectionProxy();\n                  TPushPop helper(proxy,*(void**)ptr);\n                  proxy->Clear(\"force\");\n               }\n               fKey->DeleteItem(*(void**)ptr);\n             } else {\n               if (fKey->fProperties&kNeedDelete) {\n                  TVirtualCollectionProxy *proxy = fKey->fType->GetCollectionProxy();\n                  TPushPop helper(proxy,ptr);\n                  proxy->Clear(\"force\");\n               }\n            }\n            char *addr = ((char*)ptr)+fValOffset;\n            if ( fVal->fCase&kIsPointer ) {\n               if ( fVal->fProperties&kNeedDelete) {\n                  TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionProxy();\n                  TPushPop helper(proxy,*(void**)addr);\n                  proxy->Clear(\"force\");\n               }\n               fVal->DeleteItem(*(void**)addr);\n           } else {\n               if ( fVal->fProperties&kNeedDelete) {\n                  TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionProxy();\n                  TPushPop helper(proxy,addr);\n                  proxy->Clear(\"force\");\n               }\n            }\n            break;\n         }\n         default: {\n            if ( fVal->fCase&kIsPointer ) {\n               if (fVal->fProperties&kNeedDelete) {\n                  TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionProxy();\n                  TPushPop helper(proxy,*(void**)ptr);\n                  proxy->Clear(\"force\");\n               }\n               fVal->DeleteItem(*(void**)ptr);\n            } else {\n               if (fVal->fProperties&kNeedDelete) {\n                  TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionProxy();\n                  TPushPop helper(proxy,ptr);\n                  proxy->Clear(\"force\");\n               }\n            }\n            break;\n         }\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TGenCollectionProxy::ReadBuffer(TBuffer & /* b */, void * /* obj */, const TClass * /* onfileClass */)\n{\n   MayNotUse(\"TGenCollectionProxy::ReadBuffer(TBuffer &, void *, const TClass *)\");\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TGenCollectionProxy::ReadBuffer(TBuffer & /* b */, void * /* obj */)\n{\n   MayNotUse(\"TGenCollectionProxy::ReadBuffer(TBuffer &, void *)\");\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Streamer Function.\n\nvoid TGenCollectionProxy::Streamer(TBuffer &buff)\n{\n   if ( fEnv ) {\n      GetCollectionClass()->Streamer( fEnv->fObject, buff );\n      return;\n   }\n   Fatal(\"TGenCollectionProxy\",\"Streamer> Logic error - no proxy object set.\");\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Streamer I/O overload\n\nvoid TGenCollectionProxy::Streamer(TBuffer &buff, void *objp, int /* siz */ )\n{\n   TPushPop env(this, objp);\n   Streamer(buff);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// TClassStreamer IO overload\n\nvoid TGenCollectionProxy::operator()(TBuffer &b, void *objp)\n{\n   Streamer(b, objp, 0);\n}\n\n\nstruct TGenCollectionProxy__SlowIterator {\n   TVirtualCollectionProxy *fProxy;\n   UInt_t fIndex;\n   TGenCollectionProxy__SlowIterator(TVirtualCollectionProxy *proxy) : fProxy(proxy), fIndex(0) {}\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TGenCollectionProxy__SlowCreateIterators(void * /* collection */, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy)\n{\n   new (*begin_arena) TGenCollectionProxy__SlowIterator(proxy);\n   *(UInt_t*)*end_arena = proxy->Size();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid *TGenCollectionProxy__SlowNext(void *iter, const void *end)\n{\n   TGenCollectionProxy__SlowIterator *iterator = (TGenCollectionProxy__SlowIterator*)iter;\n   if (iterator->fIndex != *(UInt_t*)end) {\n      void *result = iterator->fProxy->At(iterator->fIndex);\n      ++(iterator->fIndex);\n      return result;\n   } else {\n      return 0;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid * TGenCollectionProxy__SlowCopyIterator(void *dest, const void *source)\n{\n   *(TGenCollectionProxy__SlowIterator*)dest = *(TGenCollectionProxy__SlowIterator*)source;\n   return dest;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Nothing to do\n\nvoid TGenCollectionProxy__SlowDeleteSingleIterators(void *)\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Nothing to do\n\nvoid TGenCollectionProxy__SlowDeleteTwoIterators(void *, void *)\n{\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// We can safely assume that the std::vector layout does not really depend on\n/// the content!\n\nvoid TGenCollectionProxy__VectorCreateIterators(void *obj, void **begin_arena, void **end_arena, TVirtualCollectionProxy*)\n{\n   std::vector<char> *vec = (std::vector<char>*)obj;\n   if (vec->empty()) {\n      *begin_arena = 0;\n      *end_arena = 0;\n      return;\n   }\n   *begin_arena = &(*vec->begin());\n#ifdef R__VISUAL_CPLUSPLUS\n   *end_arena = &(*(vec->end()-1)) + 1; // On windows we can not dererence the end iterator at all.\n#else\n   // coverity[past_the_end] Safe on other platforms\n   *end_arena = &(*vec->end());\n#endif\n\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Should not be used.\n\nvoid *TGenCollectionProxy__VectorNext(void *, const void *)\n{\n   R__ASSERT(0);\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid *TGenCollectionProxy__VectorCopyIterator(void *dest, const void *source)\n{\n   *(void**)dest = *(void**)source;\n   return dest;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Nothing to do\n\nvoid TGenCollectionProxy__VectorDeleteSingleIterators(void *)\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Nothing to do\n\nvoid TGenCollectionProxy__VectorDeleteTwoIterators(void *, void *)\n{\n}\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TGenCollectionProxy__StagingCreateIterators(void *obj, void **begin_arena, void **end_arena, TVirtualCollectionProxy *)\n{\n   TGenCollectionProxy::TStaging * s = (TGenCollectionProxy::TStaging*)obj;\n   *begin_arena = s->GetContent();\n   *end_arena = s->GetEnd();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Should not be used.\n\nvoid *TGenCollectionProxy__StagingNext(void *, const void *)\n{\n   R__ASSERT(0);\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid *TGenCollectionProxy__StagingCopyIterator(void *dest, const void *source)\n{\n   *(void**)dest = *(void**)source;\n   return dest;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Nothing to do\n\nvoid TGenCollectionProxy__StagingDeleteSingleIterators(void *)\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Nothing to do\n\nvoid TGenCollectionProxy__StagingDeleteTwoIterators(void *, void *)\n{\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// See typedef void (*CreateIterators_t)(void *collection, void *&begin_arena, void *&end_arena);\n/// begin_arena and end_arena should contain the location of memory arena  of size fgIteratorSize.\n/// If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement)\n/// Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena.\n\nTVirtualCollectionProxy::CreateIterators_t TGenCollectionProxy::GetFunctionCreateIterators(Bool_t read)\n{\n   if (read) {\n      if ( !fValue.load() ) InitializeEx(kFALSE);\n      if ( (fProperties & kIsAssociative) && read)\n         return TGenCollectionProxy__StagingCreateIterators;\n   }\n\n   if ( fFunctionCreateIterators ) return fFunctionCreateIterators;\n\n   if ( !fValue.load() ) InitializeEx(kFALSE);\n\n//   fprintf(stderr,\"GetFunctinCreateIterator for %s will give: \",fClass.GetClassName());\n//   if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated))\n//      fprintf(stderr,\"vector/emulated iterator\\n\");\n//   else if ( (fProperties & kIsAssociative) && read)\n//      fprintf(stderr,\"an associative read iterator\\n\");\n//   else\n//      fprintf(stderr,\"a generic iterator\\n\");\n\n   if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated))\n      return fFunctionCreateIterators = TGenCollectionProxy__VectorCreateIterators;\n   else if ( (fProperties & kIsAssociative) && read)\n      return TGenCollectionProxy__StagingCreateIterators;\n   else\n      return fFunctionCreateIterators = TGenCollectionProxy__SlowCreateIterators;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// See typedef void (*CopyIterator_t)(void *&dest, const void *source);\n/// Copy the iterator source, into dest.   dest should contain should contain the location of memory arena  of size fgIteratorSize.\n/// If the collection iterator are of that size or less, the iterator will be constructed in place in this location (new with placement)\n/// Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest.\n\nTVirtualCollectionProxy::CopyIterator_t TGenCollectionProxy::GetFunctionCopyIterator(Bool_t read)\n{\n   if (read) {\n      if ( !fValue.load() ) InitializeEx(kFALSE);\n      if ( (fProperties & kIsAssociative) && read)\n         return TGenCollectionProxy__StagingCopyIterator;\n   }\n\n   if ( fFunctionCopyIterator ) return fFunctionCopyIterator;\n\n   if ( !fValue.load() ) InitializeEx(kFALSE);\n\n   if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated))\n      return fFunctionCopyIterator = TGenCollectionProxy__VectorCopyIterator;\n   else if ( (fProperties & kIsAssociative) && read)\n      return TGenCollectionProxy__StagingCopyIterator;\n   else\n      return fFunctionCopyIterator = TGenCollectionProxy__SlowCopyIterator;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// See typedef void* (*Next_t)(void *iter, void *end);\n/// iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end()\n/// 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end.\n/// If the end is not reached, 'Next' will return the address of the content unless the collection contains pointers in\n/// which case 'Next' will return the value of the pointer.\n\nTVirtualCollectionProxy::Next_t TGenCollectionProxy::GetFunctionNext(Bool_t read)\n{\n   if (read) {\n      if ( !fValue.load() ) InitializeEx(kFALSE);\n      if ( (fProperties & kIsAssociative) && read)\n         return TGenCollectionProxy__StagingNext;\n   }\n\n   if ( fFunctionNextIterator ) return fFunctionNextIterator;\n\n   if ( !fValue.load() ) InitializeEx(kFALSE);\n\n   if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated))\n      return fFunctionNextIterator = TGenCollectionProxy__VectorNext;\n   else if ( (fProperties & kIsAssociative) && read)\n      return TGenCollectionProxy__StagingNext;\n   else\n      return fFunctionNextIterator = TGenCollectionProxy__SlowNext;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// See typedef void (*DeleteIterator_t)(void *iter);\n/// If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,\n/// Otherwise just call the iterator's destructor.\n\nTVirtualCollectionProxy::DeleteIterator_t TGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read)\n{\n   if (read) {\n      if ( !fValue.load() ) InitializeEx(kFALSE);\n      if ( (fProperties & kIsAssociative) && read)\n         return TGenCollectionProxy__StagingDeleteSingleIterators;\n   }\n\n   if ( fFunctionDeleteIterator ) return fFunctionDeleteIterator;\n\n   if ( !fValue.load() ) InitializeEx(kFALSE);\n\n   if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated))\n      return fFunctionDeleteIterator = TGenCollectionProxy__VectorDeleteSingleIterators;\n   else if ( (fProperties & kIsAssociative) && read)\n      return TGenCollectionProxy__StagingDeleteSingleIterators;\n   else\n      return fFunctionDeleteIterator = TGenCollectionProxy__SlowDeleteSingleIterators;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// See typedef void (*DeleteTwoIterators_t)(void *begin, void *end);\n/// If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,\n/// Otherwise just call the iterator's destructor.\n\nTVirtualCollectionProxy::DeleteTwoIterators_t TGenCollectionProxy::GetFunctionDeleteTwoIterators(Bool_t read)\n{\n   if (read) {\n      if ( !fValue.load() ) InitializeEx(kFALSE);\n      if ( (fProperties & kIsAssociative) && read)\n         return TGenCollectionProxy__StagingDeleteTwoIterators;\n   }\n\n   if ( fFunctionDeleteTwoIterators ) return fFunctionDeleteTwoIterators;\n\n   if ( !fValue.load() ) InitializeEx(kFALSE);\n\n   if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated))\n      return fFunctionDeleteTwoIterators = TGenCollectionProxy__VectorDeleteTwoIterators;\n   else if ( (fProperties & kIsAssociative) && read)\n      return TGenCollectionProxy__StagingDeleteTwoIterators;\n   else\n      return fFunctionDeleteTwoIterators = TGenCollectionProxy__SlowDeleteTwoIterators;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the set of action necessary to stream in this collection member-wise coming from\n/// the old value class layout refered to by 'version'.\n\nTStreamerInfoActions::TActionSequence *TGenCollectionProxy::GetConversionReadMemberWiseActions(TClass *oldClass, Int_t version)\n{\n   if (oldClass == 0) {\n      return 0;\n   }\n   TObjArray* arr = 0;\n   TStreamerInfoActions::TActionSequence *result = 0;\n   if (fConversionReadMemberWise) {\n      std::map<std::string, TObjArray*>::iterator it;\n\n      it = fConversionReadMemberWise->find( oldClass->GetName() );\n\n      if( it != fConversionReadMemberWise->end() ) {\n         arr = it->second;\n      }\n\n      if (arr) {\n         result = (TStreamerInfoActions::TActionSequence *)arr->At(version);\n         if (result) {\n            return result;\n         }\n      }\n   }\n\n   // Need to create it.\n   TClass *valueClass = GetValueClass();\n   if (valueClass == 0) {\n      return 0;\n   }\n   TVirtualStreamerInfo *info = valueClass->GetConversionStreamerInfo(oldClass,version);\n   if (info == 0) {\n      return 0;\n   }\n   result = TStreamerInfoActions::TActionSequence::CreateReadMemberWiseActions(info,*this);\n\n   if (!arr) {\n      arr = new TObjArray(version+10, -1);\n      if (!fConversionReadMemberWise) {\n         fConversionReadMemberWise = new std::map<std::string, TObjArray*>();\n      }\n      (*fConversionReadMemberWise)[oldClass->GetName()] = arr;\n   }\n   arr->AddAtAndExpand( result, version );\n\n   return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the set of action necessary to stream in this collection member-wise coming from\n/// the old value class layout refered to by 'version'.\n\nTStreamerInfoActions::TActionSequence *TGenCollectionProxy::GetReadMemberWiseActions(Int_t version)\n{\n   TStreamerInfoActions::TActionSequence *result = 0;\n   if (version < (fReadMemberWise->GetSize()-1)) { // -1 because the 'index' starts at -1\n      result = (TStreamerInfoActions::TActionSequence *)fReadMemberWise->At(version);\n   }\n   if (result == 0) {\n      // Need to create it.\n      TClass *valueClass = GetValueClass();\n      TVirtualStreamerInfo *info = 0;\n      if (valueClass) {\n         info = valueClass->GetStreamerInfo(version);\n      }\n      result = TStreamerInfoActions::TActionSequence::CreateReadMemberWiseActions(info,*this);\n      fReadMemberWise->AddAtAndExpand(result,version);\n   }\n   return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the set of action necessary to stream out this collection member-wise.\n\nTStreamerInfoActions::TActionSequence *TGenCollectionProxy::GetWriteMemberWiseActions()\n{\n  TStreamerInfoActions::TActionSequence *result = fWriteMemberWise;\n  if (result == 0) {\n     // Need to create it.\n     TClass *valueClass = GetValueClass();\n     TVirtualStreamerInfo *info = 0;\n     if (valueClass) {\n        info = valueClass->GetStreamerInfo();\n     }\n     result = TStreamerInfoActions::TActionSequence::CreateWriteMemberWiseActions(info,*this);\n     fWriteMemberWise=result;\n  }\n  return result;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c": "/*===-- jitprofiling.c - JIT (Just-In-Time) Profiling API----------*- C -*-===*\n *\n *                     The LLVM Compiler Infrastructure\n *\n * This file is distributed under the University of Illinois Open Source\n * License. See LICENSE.TXT for details.\n *\n *===----------------------------------------------------------------------===*\n *\n * This file provides Intel(R) Performance Analyzer JIT (Just-In-Time) \n * Profiling API implementation. \n *\n * NOTE: This file comes in a style different from the rest of LLVM\n * source base since  this is a piece of code shared from Intel(R)\n * products.  Please do not reformat / re-style this code to make\n * subsequent merges and contributions from the original source base eaiser.\n *\n *===----------------------------------------------------------------------===*/\n#include \"ittnotify_config.h\"\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#include <windows.h>\n#pragma optimize(\"\", off)\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <dlfcn.h>\n#include <pthread.h>\n#include <stdint.h>\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <malloc.h>\n#include <stdlib.h>\n\n#include \"jitprofiling.h\"\n\nstatic const char rcsid[] = \"\\n@(#) $Revision: 243501 $\\n\";\n\n#define DLL_ENVIRONMENT_VAR             \"VS_PROFILER\"\n\n#ifndef NEW_DLL_ENVIRONMENT_VAR\n#if ITT_ARCH==ITT_ARCH_IA32\n#define NEW_DLL_ENVIRONMENT_VAR\t        \"INTEL_JIT_PROFILER32\"\n#else\n#define NEW_DLL_ENVIRONMENT_VAR\t        \"INTEL_JIT_PROFILER64\"\n#endif\n#endif /* NEW_DLL_ENVIRONMENT_VAR */\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#define DEFAULT_DLLNAME                 \"JitPI.dll\"\nHINSTANCE m_libHandle = NULL;\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define DEFAULT_DLLNAME                 \"libJitPI.so\"\nvoid* m_libHandle = NULL;\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n/* default location of JIT profiling agent on Android */\n#define ANDROID_JIT_AGENT_PATH  \"/data/intel/libittnotify.so\"\n\n/* the function pointers */\ntypedef unsigned int(*TPInitialize)(void);\nstatic TPInitialize FUNC_Initialize=NULL;\n\ntypedef unsigned int(*TPNotify)(unsigned int, void*);\nstatic TPNotify FUNC_NotifyEvent=NULL;\n\nstatic iJIT_IsProfilingActiveFlags executionMode = iJIT_NOTHING_RUNNING;\n\n/* end collector dll part. */\n\n/* loadiJIT_Funcs() : this function is called just in the beginning \n *  and is responsible to load the functions from BistroJavaCollector.dll\n * result:\n *  on success: the functions loads, iJIT_DLL_is_missing=0, return value = 1\n *  on failure: the functions are NULL, iJIT_DLL_is_missing=1, return value = 0\n */ \nstatic int loadiJIT_Funcs(void);\n\n/* global representing whether the BistroJavaCollector can't be loaded */\nstatic int iJIT_DLL_is_missing = 0;\n\n/* Virtual stack - the struct is used as a virtual stack for each thread.\n * Every thread initializes with a stack of size INIT_TOP_STACK.\n * Every method entry decreases from the current stack point,\n * and when a thread stack reaches its top of stack (return from the global \n * function), the top of stack and the current stack increase. Notice that \n * when returning from a function the stack pointer is the address of \n * the function return.\n*/\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\nstatic DWORD threadLocalStorageHandle = 0;\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nstatic pthread_key_t threadLocalStorageHandle = (pthread_key_t)0;\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#define INIT_TOP_Stack 10000\n\ntypedef struct \n{\n    unsigned int TopStack;\n    unsigned int CurrentStack;\n} ThreadStack, *pThreadStack;\n\n/* end of virtual stack. */\n\n/*\n * The function for reporting virtual-machine related events to VTune.\n * Note: when reporting iJVM_EVENT_TYPE_ENTER_NIDS, there is no need to fill \n * in the stack_id field in the iJIT_Method_NIDS structure, as VTune fills it.\n * The return value in iJVM_EVENT_TYPE_ENTER_NIDS && \n * iJVM_EVENT_TYPE_LEAVE_NIDS events will be 0 in case of failure.\n * in iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED event \n * it will be -1 if EventSpecificData == 0 otherwise it will be 0.\n*/\n\nITT_EXTERN_C int JITAPI \niJIT_NotifyEvent(iJIT_JVM_EVENT event_type, void *EventSpecificData)\n{\n    int ReturnValue;\n\n    /*\n     * This section is for debugging outside of VTune. \n     * It creates the environment variables that indicates call graph mode.\n     * If running outside of VTune remove the remark.\n     *\n     *\n     * static int firstTime = 1;\n     * char DoCallGraph[12] = \"DoCallGraph\";\n     * if (firstTime)\n     * {\n     * firstTime = 0;\n     * SetEnvironmentVariable( \"BISTRO_COLLECTORS_DO_CALLGRAPH\", DoCallGraph);\n     * }\n     *\n     * end of section.\n    */\n\n    /* initialization part - the functions have not been loaded yet. This part\n     *        will load the functions, and check if we are in Call Graph mode. \n     *        (for special treatment).\n     */\n    if (!FUNC_NotifyEvent) \n    {\n        if (iJIT_DLL_is_missing) \n            return 0;\n\n        /* load the Function from the DLL */\n        if (!loadiJIT_Funcs()) \n            return 0;\n\n        /* Call Graph initialization. */\n    }\n\n    /* If the event is method entry/exit, check that in the current mode \n     * VTune is allowed to receive it\n     */\n    if ((event_type == iJVM_EVENT_TYPE_ENTER_NIDS || \n         event_type == iJVM_EVENT_TYPE_LEAVE_NIDS) &&\n        (executionMode != iJIT_CALLGRAPH_ON))\n    {\n        return 0;\n    }\n    /* This section is performed when method enter event occurs.\n     * It updates the virtual stack, or creates it if this is the first \n     * method entry in the thread. The stack pointer is decreased.\n     */\n    if (event_type == iJVM_EVENT_TYPE_ENTER_NIDS)\n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        pThreadStack threadStack = \n            (pThreadStack)TlsGetValue (threadLocalStorageHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        pThreadStack threadStack = \n            (pThreadStack)pthread_getspecific(threadLocalStorageHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n        /* check for use of reserved method IDs */\n        if ( ((piJIT_Method_NIDS) EventSpecificData)->method_id <= 999 )\n            return 0;\n\n        if (!threadStack)\n        {\n            /* initialize the stack. */\n            threadStack = (pThreadStack) calloc (sizeof(ThreadStack), 1);\n            threadStack->TopStack = INIT_TOP_Stack;\n            threadStack->CurrentStack = INIT_TOP_Stack;\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n            TlsSetValue(threadLocalStorageHandle,(void*)threadStack);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n            pthread_setspecific(threadLocalStorageHandle,(void*)threadStack);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        }\n\n        /* decrease the stack. */\n        ((piJIT_Method_NIDS) EventSpecificData)->stack_id = \n            (threadStack->CurrentStack)--;\n    }\n\n    /* This section is performed when method leave event occurs\n     * It updates the virtual stack.\n     *    Increases the stack pointer.\n     *    If the stack pointer reached the top (left the global function)\n     *        increase the pointer and the top pointer.\n     */\n    if (event_type == iJVM_EVENT_TYPE_LEAVE_NIDS)\n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        pThreadStack threadStack = \n           (pThreadStack)TlsGetValue (threadLocalStorageHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        pThreadStack threadStack = \n            (pThreadStack)pthread_getspecific(threadLocalStorageHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n        /* check for use of reserved method IDs */\n        if ( ((piJIT_Method_NIDS) EventSpecificData)->method_id <= 999 )\n            return 0;\n\n        if (!threadStack)\n        {\n            /* Error: first report in this thread is method exit */\n            exit (1);\n        }\n\n        ((piJIT_Method_NIDS) EventSpecificData)->stack_id = \n            ++(threadStack->CurrentStack) + 1;\n\n        if (((piJIT_Method_NIDS) EventSpecificData)->stack_id \n               > threadStack->TopStack)\n            ((piJIT_Method_NIDS) EventSpecificData)->stack_id = \n                (unsigned int)-1;\n    }\n\n    if (event_type == iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED)\n    {\n        /* check for use of reserved method IDs */\n        if ( ((piJIT_Method_Load) EventSpecificData)->method_id <= 999 )\n            return 0;\n    }\n\n    ReturnValue = (int)FUNC_NotifyEvent(event_type, EventSpecificData);   \n\n    return ReturnValue;\n}\n\n/* The new mode call back routine */\nITT_EXTERN_C void JITAPI \niJIT_RegisterCallbackEx(void *userdata, iJIT_ModeChangedEx \n                        NewModeCallBackFuncEx) \n{\n    /* is it already missing... or the load of functions from the DLL failed */\n    if (iJIT_DLL_is_missing || !loadiJIT_Funcs())\n    {\n        /* then do not bother with notifications */\n        NewModeCallBackFuncEx(userdata, iJIT_NO_NOTIFICATIONS);  \n        /* Error: could not load JIT functions. */\n        return;\n    }\n    /* nothing to do with the callback */\n}\n\n/*\n * This function allows the user to query in which mode, if at all, \n *VTune is running\n */\nITT_EXTERN_C iJIT_IsProfilingActiveFlags JITAPI iJIT_IsProfilingActive()\n{\n    if (!iJIT_DLL_is_missing)\n    {\n        loadiJIT_Funcs();\n    }\n\n    return executionMode;\n}\n\n/* this function loads the collector dll (BistroJavaCollector) \n * and the relevant functions.\n * on success: all functions load,     iJIT_DLL_is_missing = 0, return value = 1\n * on failure: all functions are NULL, iJIT_DLL_is_missing = 1, return value = 0\n */ \nstatic int loadiJIT_Funcs()\n{\n    static int bDllWasLoaded = 0;\n    char *dllName = (char*)rcsid; /* !! Just to avoid unused code elimination */\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n    DWORD dNameLength = 0;\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n    if(bDllWasLoaded)\n    {\n        /* dll was already loaded, no need to do it for the second time */\n        return 1;\n    }\n\n    /* Assumes that the DLL will not be found */\n    iJIT_DLL_is_missing = 1;\n    FUNC_NotifyEvent = NULL;\n\n    if (m_libHandle) \n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        FreeLibrary(m_libHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        dlclose(m_libHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        m_libHandle = NULL;\n    }\n\n    /* Try to get the dll name from the environment */\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n    dNameLength = GetEnvironmentVariableA(NEW_DLL_ENVIRONMENT_VAR, NULL, 0);\n    if (dNameLength)\n    {\n        DWORD envret = 0;\n        dllName = (char*)malloc(sizeof(char) * (dNameLength + 1));\n        envret = GetEnvironmentVariableA(NEW_DLL_ENVIRONMENT_VAR, \n                                         dllName, dNameLength);\n        if (envret)\n        {\n            /* Try to load the dll from the PATH... */\n            m_libHandle = LoadLibraryExA(dllName, \n                                         NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n        }\n        free(dllName);\n    } else {\n        /* Try to use old VS_PROFILER variable */\n        dNameLength = GetEnvironmentVariableA(DLL_ENVIRONMENT_VAR, NULL, 0);\n        if (dNameLength)\n        {\n            DWORD envret = 0;\n            dllName = (char*)malloc(sizeof(char) * (dNameLength + 1));\n            envret = GetEnvironmentVariableA(DLL_ENVIRONMENT_VAR, \n                                             dllName, dNameLength);\n            if (envret)\n            {\n                /* Try to load the dll from the PATH... */\n                m_libHandle = LoadLibraryA(dllName);\n            }\n            free(dllName);\n        }\n    }\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    dllName = getenv(NEW_DLL_ENVIRONMENT_VAR);\n    if (!dllName)\n        dllName = getenv(DLL_ENVIRONMENT_VAR);\n#ifdef ANDROID\n    if (!dllName)\n        dllName = ANDROID_JIT_AGENT_PATH;\n#endif\n    if (dllName)\n    {\n        /* Try to load the dll from the PATH... */\n        m_libHandle = dlopen(dllName, RTLD_LAZY);\n    }\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n    if (!m_libHandle)\n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        m_libHandle = LoadLibraryA(DEFAULT_DLLNAME);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        m_libHandle = dlopen(DEFAULT_DLLNAME, RTLD_LAZY);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    }\n\n    /* if the dll wasn't loaded - exit. */\n    if (!m_libHandle)\n    {\n        iJIT_DLL_is_missing = 1; /* don't try to initialize \n                                  * JIT agent the second time \n                                  */\n        return 0;\n    }\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n    FUNC_NotifyEvent = (TPNotify)GetProcAddress(m_libHandle, \"NotifyEvent\");\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    FUNC_NotifyEvent = (TPNotify)(intptr_t)dlsym(m_libHandle, \"NotifyEvent\");\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    if (!FUNC_NotifyEvent) \n    {\n        FUNC_Initialize = NULL;\n        return 0;\n    }\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n    FUNC_Initialize = (TPInitialize)GetProcAddress(m_libHandle, \"Initialize\");\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    FUNC_Initialize = (TPInitialize)(intptr_t)dlsym(m_libHandle, \"Initialize\");\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    if (!FUNC_Initialize) \n    {\n        FUNC_NotifyEvent = NULL;\n        return 0;\n    }\n\n    executionMode = (iJIT_IsProfilingActiveFlags)FUNC_Initialize();\n\n    bDllWasLoaded = 1;\n    iJIT_DLL_is_missing = 0; /* DLL is ok. */\n\n    /*\n     * Call Graph mode: init the thread local storage\n     * (need to store the virtual stack there).\n     */\n    if ( executionMode == iJIT_CALLGRAPH_ON )\n    {\n        /* Allocate a thread local storage slot for the thread \"stack\" */\n        if (!threadLocalStorageHandle)\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n            threadLocalStorageHandle = TlsAlloc();\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        pthread_key_create(&threadLocalStorageHandle, NULL);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    }\n\n    return 1;\n}\n\n/*\n * This function should be called by the user whenever a thread ends, \n * to free the thread \"virtual stack\" storage\n */\nITT_EXTERN_C void JITAPI FinalizeThread()\n{\n    if (threadLocalStorageHandle)\n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        pThreadStack threadStack = \n            (pThreadStack)TlsGetValue (threadLocalStorageHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        pThreadStack threadStack = \n            (pThreadStack)pthread_getspecific(threadLocalStorageHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        if (threadStack)\n        {\n            free (threadStack);\n            threadStack = NULL;\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n            TlsSetValue (threadLocalStorageHandle, threadStack);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n            pthread_setspecific(threadLocalStorageHandle, threadStack);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        }\n    }\n}\n\n/*\n * This function should be called by the user when the process ends, \n * to free the local storage index\n*/\nITT_EXTERN_C void JITAPI FinalizeProcess()\n{\n    if (m_libHandle) \n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        FreeLibrary(m_libHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        dlclose(m_libHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        m_libHandle = NULL;\n    }\n\n    if (threadLocalStorageHandle)\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        TlsFree (threadLocalStorageHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    pthread_key_delete(threadLocalStorageHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n}\n\n/*\n * This function should be called by the user for any method once.\n * The function will return a unique method ID, the user should maintain \n * the ID for each method\n */\nITT_EXTERN_C unsigned int JITAPI iJIT_GetNewMethodID()\n{\n    static unsigned int methodID = 0x100000;\n\n    if (methodID == 0)\n        return 0;  /* ERROR : this is not a valid value */\n\n    return methodID++;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h": "/*===-- ittnotify_config.h - JIT Profiling API internal config-----*- C -*-===*\n *\n *                     The LLVM Compiler Infrastructure\n *\n * This file is distributed under the University of Illinois Open Source\n * License. See LICENSE.TXT for details.\n *\n *===----------------------------------------------------------------------===*\n *\n * This file provides Intel(R) Performance Analyzer JIT (Just-In-Time) \n * Profiling API internal config.\n *\n * NOTE: This file comes in a style different from the rest of LLVM\n * source base since  this is a piece of code shared from Intel(R)\n * products.  Please do not reformat / re-style this code to make\n * subsequent merges and contributions from the original source base eaiser.\n *\n *===----------------------------------------------------------------------===*/\n#ifndef _ITTNOTIFY_CONFIG_H_\n#define _ITTNOTIFY_CONFIG_H_\n\n/** @cond exclude_from_documentation */\n#ifndef ITT_OS_WIN\n#  define ITT_OS_WIN   1\n#endif /* ITT_OS_WIN */\n\n#ifndef ITT_OS_LINUX\n#  define ITT_OS_LINUX 2\n#endif /* ITT_OS_LINUX */\n\n#ifndef ITT_OS_MAC\n#  define ITT_OS_MAC   3\n#endif /* ITT_OS_MAC */\n\n#ifndef ITT_OS\n#  if defined WIN32 || defined _WIN32\n#    define ITT_OS ITT_OS_WIN\n#  elif defined( __APPLE__ ) && defined( __MACH__ )\n#    define ITT_OS ITT_OS_MAC\n#  else\n#    define ITT_OS ITT_OS_LINUX\n#  endif\n#endif /* ITT_OS */\n\n#ifndef ITT_PLATFORM_WIN\n#  define ITT_PLATFORM_WIN 1\n#endif /* ITT_PLATFORM_WIN */\n\n#ifndef ITT_PLATFORM_POSIX\n#  define ITT_PLATFORM_POSIX 2\n#endif /* ITT_PLATFORM_POSIX */\n\n#ifndef ITT_PLATFORM\n#  if ITT_OS==ITT_OS_WIN\n#    define ITT_PLATFORM ITT_PLATFORM_WIN\n#  else\n#    define ITT_PLATFORM ITT_PLATFORM_POSIX\n#  endif /* _WIN32 */\n#endif /* ITT_PLATFORM */\n\n#if defined(_UNICODE) && !defined(UNICODE)\n#define UNICODE\n#endif\n\n#include <stddef.h>\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#include <tchar.h>\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <stdint.h>\n#if defined(UNICODE) || defined(_UNICODE)\n#include <wchar.h>\n#endif /* UNICODE || _UNICODE */\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#ifndef CDECL\n#  if ITT_PLATFORM==ITT_PLATFORM_WIN\n#    define CDECL __cdecl\n#  else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#    if defined _M_X64 || defined _M_AMD64 || defined __x86_64__\n#      define CDECL /* not actual on x86_64 platform */\n#    else  /* _M_X64 || _M_AMD64 || __x86_64__ */\n#      define CDECL __attribute__ ((cdecl))\n#    endif /* _M_X64 || _M_AMD64 || __x86_64__ */\n#  endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* CDECL */\n\n#ifndef STDCALL\n#  if ITT_PLATFORM==ITT_PLATFORM_WIN\n#    define STDCALL __stdcall\n#  else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#    if defined _M_X64 || defined _M_AMD64 || defined __x86_64__\n#      define STDCALL /* not supported on x86_64 platform */\n#    else  /* _M_X64 || _M_AMD64 || __x86_64__ */\n#      define STDCALL __attribute__ ((stdcall))\n#    endif /* _M_X64 || _M_AMD64 || __x86_64__ */\n#  endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* STDCALL */\n\n#define ITTAPI    CDECL\n#define LIBITTAPI CDECL\n\n/* TODO: Temporary for compatibility! */\n#define ITTAPI_CALL    CDECL\n#define LIBITTAPI_CALL CDECL\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n/* use __forceinline (VC++ specific) */\n#define ITT_INLINE           __forceinline\n#define ITT_INLINE_ATTRIBUTE /* nothing */\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n/*\n * Generally, functions are not inlined unless optimization is specified.\n * For functions declared inline, this attribute inlines the function even\n * if no optimization level was specified.\n */\n#ifdef __STRICT_ANSI__\n#define ITT_INLINE           static\n#else  /* __STRICT_ANSI__ */\n#define ITT_INLINE           static inline\n#endif /* __STRICT_ANSI__ */\n#define ITT_INLINE_ATTRIBUTE __attribute__ ((always_inline))\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n/** @endcond */\n\n#ifndef ITT_ARCH_IA32\n#  define ITT_ARCH_IA32  1\n#endif /* ITT_ARCH_IA32 */\n\n#ifndef ITT_ARCH_IA32E\n#  define ITT_ARCH_IA32E 2\n#endif /* ITT_ARCH_IA32E */\n\n#ifndef ITT_ARCH_IA64\n#  define ITT_ARCH_IA64  3\n#endif /* ITT_ARCH_IA64 */\n\n#ifndef ITT_ARCH\n#  if defined _M_X64 || defined _M_AMD64 || defined __x86_64__\n#    define ITT_ARCH ITT_ARCH_IA32E\n#  elif defined _M_IA64 || defined __ia64\n#    define ITT_ARCH ITT_ARCH_IA64\n#  else\n#    define ITT_ARCH ITT_ARCH_IA32\n#  endif\n#endif\n\n#ifdef __cplusplus\n#  define ITT_EXTERN_C extern \"C\"\n#else\n#  define ITT_EXTERN_C /* nothing */\n#endif /* __cplusplus */\n\n#define ITT_TO_STR_AUX(x) #x\n#define ITT_TO_STR(x)     ITT_TO_STR_AUX(x)\n\n#define __ITT_BUILD_ASSERT(expr, suffix) do { \\\n    static char __itt_build_check_##suffix[(expr) ? 1 : -1]; \\\n    __itt_build_check_##suffix[0] = 0; \\\n} while(0)\n#define _ITT_BUILD_ASSERT(expr, suffix)  __ITT_BUILD_ASSERT((expr), suffix)\n#define ITT_BUILD_ASSERT(expr)           _ITT_BUILD_ASSERT((expr), __LINE__)\n\n#define ITT_MAGIC { 0xED, 0xAB, 0xAB, 0xEC, 0x0D, 0xEE, 0xDA, 0x30 }\n\n/* Replace with snapshot date YYYYMMDD for promotion build. */\n#define API_VERSION_BUILD    20111111\n\n#ifndef API_VERSION_NUM\n#define API_VERSION_NUM 0.0.0\n#endif /* API_VERSION_NUM */\n\n#define API_VERSION \"ITT-API-Version \" ITT_TO_STR(API_VERSION_NUM) \\\n                                \" (\" ITT_TO_STR(API_VERSION_BUILD) \")\"\n\n/* OS communication functions */\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#include <windows.h>\ntypedef HMODULE           lib_t;\ntypedef DWORD             TIDT;\ntypedef CRITICAL_SECTION  mutex_t;\n#define MUTEX_INITIALIZER { 0 }\n#define strong_alias(name, aliasname) /* empty for Windows */\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <dlfcn.h>\n#if defined(UNICODE) || defined(_UNICODE)\n#include <wchar.h>\n#endif /* UNICODE */\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE 1 /* need for PTHREAD_MUTEX_RECURSIVE */\n#endif /* _GNU_SOURCE */\n#include <pthread.h>\ntypedef void*             lib_t;\ntypedef pthread_t         TIDT;\ntypedef pthread_mutex_t   mutex_t;\n#define MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER\n#define _strong_alias(name, aliasname) \\\n            extern __typeof (name) aliasname __attribute__ ((alias (#name)));\n#define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#define __itt_get_proc(lib, name) GetProcAddress(lib, name)\n#define __itt_mutex_init(mutex)   InitializeCriticalSection(mutex)\n#define __itt_mutex_lock(mutex)   EnterCriticalSection(mutex)\n#define __itt_mutex_unlock(mutex) LeaveCriticalSection(mutex)\n#define __itt_load_lib(name)      LoadLibraryA(name)\n#define __itt_unload_lib(handle)  FreeLibrary(handle)\n#define __itt_system_error()      (int)GetLastError()\n#define __itt_fstrcmp(s1, s2)     lstrcmpA(s1, s2)\n#define __itt_fstrlen(s)          lstrlenA(s)\n#define __itt_fstrcpyn(s1, s2, l) lstrcpynA(s1, s2, l)\n#define __itt_fstrdup(s)          _strdup(s)\n#define __itt_thread_id()         GetCurrentThreadId()\n#define __itt_thread_yield()      SwitchToThread()\n#ifndef ITT_SIMPLE_INIT\nITT_INLINE long \n__itt_interlocked_increment(volatile long* ptr) ITT_INLINE_ATTRIBUTE;\nITT_INLINE long __itt_interlocked_increment(volatile long* ptr)\n{\n    return InterlockedIncrement(ptr);\n}\n#endif /* ITT_SIMPLE_INIT */\n#else /* ITT_PLATFORM!=ITT_PLATFORM_WIN */\n#define __itt_get_proc(lib, name) dlsym(lib, name)\n#define __itt_mutex_init(mutex)   {\\\n    pthread_mutexattr_t mutex_attr;                                         \\\n    int error_code = pthread_mutexattr_init(&mutex_attr);                   \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutexattr_init\",    \\\n                           error_code);                                     \\\n    error_code = pthread_mutexattr_settype(&mutex_attr,                     \\\n                                           PTHREAD_MUTEX_RECURSIVE);        \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutexattr_settype\", \\\n                           error_code);                                     \\\n    error_code = pthread_mutex_init(mutex, &mutex_attr);                    \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutex_init\",        \\\n                           error_code);                                     \\\n    error_code = pthread_mutexattr_destroy(&mutex_attr);                    \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutexattr_destroy\", \\\n                           error_code);                                     \\\n}\n#define __itt_mutex_lock(mutex)   pthread_mutex_lock(mutex)\n#define __itt_mutex_unlock(mutex) pthread_mutex_unlock(mutex)\n#define __itt_load_lib(name)      dlopen(name, RTLD_LAZY)\n#define __itt_unload_lib(handle)  dlclose(handle)\n#define __itt_system_error()      errno\n#define __itt_fstrcmp(s1, s2)     strcmp(s1, s2)\n#define __itt_fstrlen(s)          strlen(s)\n#define __itt_fstrcpyn(s1, s2, l) strncpy(s1, s2, l)\n#define __itt_fstrdup(s)          strdup(s)\n#define __itt_thread_id()         pthread_self()\n#define __itt_thread_yield()      sched_yield()\n#if ITT_ARCH==ITT_ARCH_IA64\n#ifdef __INTEL_COMPILER\n#define __TBB_machine_fetchadd4(addr, val) __fetchadd4_acq((void *)addr, val)\n#else  /* __INTEL_COMPILER */\n/* TODO: Add Support for not Intel compilers for IA64 */\n#endif /* __INTEL_COMPILER */\n#else /* ITT_ARCH!=ITT_ARCH_IA64 */\nITT_INLINE long\n__TBB_machine_fetchadd4(volatile void* ptr, long addend) ITT_INLINE_ATTRIBUTE;\nITT_INLINE long __TBB_machine_fetchadd4(volatile void* ptr, long addend)\n{\n    long result;\n    __asm__ __volatile__(\"lock\\nxadd %0,%1\"\n                          : \"=r\"(result),\"=m\"(*(long*)ptr)\n                          : \"0\"(addend), \"m\"(*(long*)ptr)\n                          : \"memory\");\n    return result;\n}\n#endif /* ITT_ARCH==ITT_ARCH_IA64 */\n#ifndef ITT_SIMPLE_INIT\nITT_INLINE long \n__itt_interlocked_increment(volatile long* ptr) ITT_INLINE_ATTRIBUTE;\nITT_INLINE long __itt_interlocked_increment(volatile long* ptr)\n{\n    return __TBB_machine_fetchadd4(ptr, 1) + 1L;\n}\n#endif /* ITT_SIMPLE_INIT */\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\ntypedef enum {\n    __itt_collection_normal = 0,\n    __itt_collection_paused = 1\n} __itt_collection_state;\n\ntypedef enum {\n    __itt_thread_normal  = 0,\n    __itt_thread_ignored = 1\n} __itt_thread_state;\n\n#pragma pack(push, 8)\n\ntypedef struct ___itt_thread_info\n{\n    const char* nameA; /*!< Copy of original name in ASCII. */\n#if defined(UNICODE) || defined(_UNICODE)\n    const wchar_t* nameW; /*!< Copy of original name in UNICODE. */\n#else  /* UNICODE || _UNICODE */\n    void* nameW;\n#endif /* UNICODE || _UNICODE */\n    TIDT               tid;\n    __itt_thread_state state;   /*!< Thread state (paused or normal) */\n    int                extra1;  /*!< Reserved to the runtime */\n    void*              extra2;  /*!< Reserved to the runtime */\n    struct ___itt_thread_info* next;\n} __itt_thread_info;\n\n#include \"ittnotify_types.h\" /* For __itt_group_id definition */\n\ntypedef struct ___itt_api_info_20101001\n{\n    const char*    name;\n    void**         func_ptr;\n    void*          init_func;\n    __itt_group_id group;\n}  __itt_api_info_20101001;\n\ntypedef struct ___itt_api_info\n{\n    const char*    name;\n    void**         func_ptr;\n    void*          init_func;\n    void*          null_func;\n    __itt_group_id group;\n}  __itt_api_info;\n\nstruct ___itt_domain;\nstruct ___itt_string_handle;\n\ntypedef struct ___itt_global\n{\n    unsigned char          magic[8];\n    unsigned long          version_major;\n    unsigned long          version_minor;\n    unsigned long          version_build;\n    volatile long          api_initialized;\n    volatile long          mutex_initialized;\n    volatile long          atomic_counter;\n    mutex_t                mutex;\n    lib_t                  lib;\n    void*                  error_handler;\n    const char**           dll_path_ptr;\n    __itt_api_info*        api_list_ptr;\n    struct ___itt_global*  next;\n    /* Joinable structures below */\n    __itt_thread_info*     thread_list;\n    struct ___itt_domain*  domain_list;\n    struct ___itt_string_handle* string_list;\n    __itt_collection_state state;\n} __itt_global;\n\n#pragma pack(pop)\n\n#define NEW_THREAD_INFO_W(gptr,h,h_tail,t,s,n) { \\\n    h = (__itt_thread_info*)malloc(sizeof(__itt_thread_info)); \\\n    if (h != NULL) { \\\n        h->tid    = t; \\\n        h->nameA  = NULL; \\\n        h->nameW  = n ? _wcsdup(n) : NULL; \\\n        h->state  = s; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->thread_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_THREAD_INFO_A(gptr,h,h_tail,t,s,n) { \\\n    h = (__itt_thread_info*)malloc(sizeof(__itt_thread_info)); \\\n    if (h != NULL) { \\\n        h->tid    = t; \\\n        h->nameA  = n ? __itt_fstrdup(n) : NULL; \\\n        h->nameW  = NULL; \\\n        h->state  = s; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->thread_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_DOMAIN_W(gptr,h,h_tail,name) { \\\n    h = (__itt_domain*)malloc(sizeof(__itt_domain)); \\\n    if (h != NULL) { \\\n        h->flags  = 0;    /* domain is disabled by default */ \\\n        h->nameA  = NULL; \\\n        h->nameW  = name ? _wcsdup(name) : NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->domain_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_DOMAIN_A(gptr,h,h_tail,name) { \\\n    h = (__itt_domain*)malloc(sizeof(__itt_domain)); \\\n    if (h != NULL) { \\\n        h->flags  = 0;    /* domain is disabled by default */ \\\n        h->nameA  = name ? __itt_fstrdup(name) : NULL; \\\n        h->nameW  = NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->domain_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_STRING_HANDLE_W(gptr,h,h_tail,name) { \\\n    h = (__itt_string_handle*)malloc(sizeof(__itt_string_handle)); \\\n    if (h != NULL) { \\\n        h->strA   = NULL; \\\n        h->strW   = name ? _wcsdup(name) : NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->string_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_STRING_HANDLE_A(gptr,h,h_tail,name) { \\\n    h = (__itt_string_handle*)malloc(sizeof(__itt_string_handle)); \\\n    if (h != NULL) { \\\n        h->strA   = name ? __itt_fstrdup(name) : NULL; \\\n        h->strW   = NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->string_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#endif /* _ITTNOTIFY_CONFIG_H_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/lib/Support/Windows/DynamicLibrary.inc": "//===- Win32/DynamicLibrary.cpp - Win32 DL Implementation -------*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides the Win32 specific implementation of DynamicLibrary.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"WindowsSupport.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\n#include <psapi.h>\n\n//===----------------------------------------------------------------------===//\n//=== WARNING: Implementation here must contain only Win32 specific code\n//===          and must not be UNIX code.\n//===----------------------------------------------------------------------===//\n\n\nDynamicLibrary::HandleSet::~HandleSet() {\n  for (void *Handle : llvm::reverse(Handles))\n    FreeLibrary(HMODULE(Handle));\n\n  // 'Process' should not be released on Windows.\n  assert((!Process || Process==this) && \"Bad Handle\");\n  // llvm_shutdown called, Return to default\n  DynamicLibrary::SearchOrder = DynamicLibrary::SO_Linker;\n}\n\nvoid *DynamicLibrary::HandleSet::DLOpen(const char *File, std::string *Err) {\n  // Create the instance and return it to be the *Process* handle\n  // simillar to dlopen(NULL, RTLD_LAZY|RTLD_GLOBAL)\n  if (!File)\n    return &(*OpenedHandles);\n\n  SmallVector<wchar_t, MAX_PATH> FileUnicode;\n  if (std::error_code ec = windows::UTF8ToUTF16(File, FileUnicode)) {\n    SetLastError(ec.value());\n    MakeErrMsg(Err, std::string(File) + \": Can't convert to UTF-16\");\n    return &DynamicLibrary::Invalid;\n  }\n\n  HMODULE Handle = LoadLibraryW(FileUnicode.data());\n  if (Handle == NULL) {\n    MakeErrMsg(Err, std::string(File) + \": Can't open\");\n    return &DynamicLibrary::Invalid;\n  }\n\n  return reinterpret_cast<void*>(Handle);\n}\n\nstatic DynamicLibrary::HandleSet *IsOpenedHandlesInstance(void *Handle) {\n  if (!OpenedHandles.isConstructed())\n    return nullptr;\n  DynamicLibrary::HandleSet &Inst = *OpenedHandles;\n  return Handle == &Inst ? &Inst : nullptr;\n}\n\nvoid DynamicLibrary::HandleSet::DLClose(void *Handle) {\n  if (HandleSet* HS = IsOpenedHandlesInstance(Handle))\n    HS->Process = nullptr; // Just drop the *Process* handle.\n  else\n    FreeLibrary((HMODULE)Handle);\n}\n\nstatic bool GetProcessModules(HANDLE H, DWORD &Bytes, HMODULE *Data = nullptr) {\n  // EnumProcessModules will fail on Windows 64 while some versions of\n  // MingW-32 don't have EnumProcessModulesEx.\n  if (\n#ifdef _WIN64\n      !EnumProcessModulesEx(H, Data, Bytes, &Bytes, LIST_MODULES_64BIT)\n#else\n      !EnumProcessModules(H, Data, Bytes, &Bytes)\n#endif\n     ) {\n    std::string Err;\n    if (MakeErrMsg(&Err, \"EnumProcessModules failure\"))\n      llvm::errs() << Err << \"\\n\";\n    return false;\n  }\n  return true;\n}\n\nvoid *DynamicLibrary::HandleSet::DLSym(void *Handle, const char *Symbol) {\n  HandleSet* HS = IsOpenedHandlesInstance(Handle);\n  if (!HS)\n    return (void *)uintptr_t(GetProcAddress((HMODULE)Handle, Symbol));\n\n  // Could have done a dlclose on the *Process* handle\n  if (!HS->Process)\n    return nullptr;\n\n  // Trials indicate EnumProcessModulesEx is consistantly faster than using\n  // EnumerateLoadedModules64 or CreateToolhelp32Snapshot.\n  //\n  // | Handles | DbgHelp.dll | CreateSnapshot | EnumProcessModulesEx\n  // |=========|=============|========================================\n  // | 37      | 0.0000585 * | 0.0003031      | 0.0000152\n  // | 1020    | 0.0026310 * | 0.0121598      | 0.0002683\n  // | 2084    | 0.0149418 * | 0.0369936      | 0.0005610\n  //\n  // * Not including the load time of Dbghelp.dll (~.005 sec)\n  //\n  // There's still a case to somehow cache the result of EnumProcessModulesEx\n  // across invocations, but the complication of doing that properly...\n  // Possibly using LdrRegisterDllNotification to invalidate the cache?\n\n  DWORD Bytes = 0;\n  HMODULE Self = HMODULE(GetCurrentProcess());\n  if (!GetProcessModules(Self, Bytes))\n    return nullptr;\n\n  // Get the most recent list in case any modules added/removed between calls\n  // to EnumProcessModulesEx that gets the amount of, then copies the HMODULES.\n  // MSDN is pretty clear that if the module list changes during the call to\n  // EnumProcessModulesEx the results should not be used.\n  std::vector<HMODULE> Handles;\n  do {\n    assert(Bytes && ((Bytes % sizeof(HMODULE)) == 0) &&\n           \"Should have at least one module and be aligned\");\n    Handles.resize(Bytes / sizeof(HMODULE));\n    if (!GetProcessModules(Self, Bytes, Handles.data()))\n      return nullptr;\n  } while (Bytes != (Handles.size() * sizeof(HMODULE)));\n\n  // Try EXE first, mirroring what dlsym(dlopen(NULL)) does.\n  if (FARPROC Ptr = GetProcAddress(HMODULE(Handles.front()), Symbol))\n    return (void *) uintptr_t(Ptr);\n\n  if (Handles.size() > 1) {\n    // This is different behaviour than what Posix dlsym(dlopen(NULL)) does.\n    // Doing that here is causing real problems for the JIT where msvc.dll\n    // and ucrt.dll can define the same symbols. The runtime linker will choose\n    // symbols from ucrt.dll first, but iterating NOT in reverse here would\n    // mean that the msvc.dll versions would be returned.\n\n    for (auto I = Handles.rbegin(), E = Handles.rend()-1; I != E; ++I) {\n      if (FARPROC Ptr = GetProcAddress(HMODULE(*I), Symbol))\n        return (void *) uintptr_t(Ptr);\n    }\n  }\n  return nullptr;\n}\n\n\n// Stack probing routines are in the support library (e.g. libgcc), but we don't\n// have dynamic linking on windows. Provide a hook.\n#define EXPLICIT_SYMBOL(SYM)                    \\\n  extern \"C\" { extern void *SYM; }\n#define EXPLICIT_SYMBOL2(SYMFROM, SYMTO) EXPLICIT_SYMBOL(SYMTO)\n\n#ifdef _M_IX86\n// Win32 on x86 implements certain single-precision math functions as macros.\n// These functions are not exported by the DLL, but will still be needed\n// for symbol-resolution by the JIT loader. Therefore, this Support libray\n// provides helper functions with the same implementation.\n\n#define INLINE_DEF_SYMBOL1(TYP, SYM)                                           \\\n  extern \"C\" TYP inline_##SYM(TYP _X) { return SYM(_X); }\n#define INLINE_DEF_SYMBOL2(TYP, SYM)                                           \\\n  extern \"C\" TYP inline_##SYM(TYP _X, TYP _Y) { return SYM(_X, _Y); }\n#endif\n\n#include \"explicit_symbols.inc\"\n\n#undef EXPLICIT_SYMBOL\n#undef EXPLICIT_SYMBOL2\n#undef INLINE_DEF_SYMBOL1\n#undef INLINE_DEF_SYMBOL2\n\nstatic void *DoSearch(const char *SymbolName) {\n\n#define EXPLICIT_SYMBOL(SYM)                                                   \\\n  if (!strcmp(SymbolName, #SYM))                                               \\\n    return (void *)&SYM;\n#define EXPLICIT_SYMBOL2(SYMFROM, SYMTO)                                       \\\n  if (!strcmp(SymbolName, #SYMFROM))                                           \\\n    return (void *)&SYMTO;\n\n#ifdef _M_IX86\n#define INLINE_DEF_SYMBOL1(TYP, SYM)                                           \\\n  if (!strcmp(SymbolName, #SYM))                                               \\\n    return (void *)&inline_##SYM;\n#define INLINE_DEF_SYMBOL2(TYP, SYM) INLINE_DEF_SYMBOL1(TYP, SYM)\n#endif\n\n  {\n#include \"explicit_symbols.inc\"\n  }\n\n#undef EXPLICIT_SYMBOL\n#undef EXPLICIT_SYMBOL2\n#undef INLINE_DEF_SYMBOL1\n#undef INLINE_DEF_SYMBOL2\n\n  return nullptr;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/lib/Support/Unix/DynamicLibrary.inc": "//===- Unix/DynamicLibrary.cpp - Unix DL Implementation ---------*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides the UNIX specific implementation of DynamicLibrary.\n//\n//===----------------------------------------------------------------------===//\n\n#if defined(HAVE_DLFCN_H) && defined(HAVE_DLOPEN)\n#include <dlfcn.h>\n\nDynamicLibrary::HandleSet::~HandleSet() {\n  // Close the libraries in reverse order.\n  for (void *Handle : llvm::reverse(Handles))\n    ::dlclose(Handle);\n  if (Process)\n    ::dlclose(Process);\n\n  // llvm_shutdown called, Return to default\n  DynamicLibrary::SearchOrder = DynamicLibrary::SO_Linker;\n}\n\nvoid *DynamicLibrary::HandleSet::DLOpen(const char *File, std::string *Err) {\n  void *Handle = ::dlopen(File, RTLD_LAZY|RTLD_GLOBAL);\n  if (!Handle) {\n    if (Err) *Err = ::dlerror();\n    return &DynamicLibrary::Invalid;\n  }\n\n#ifdef __CYGWIN__\n  // Cygwin searches symbols only in the main\n  // with the handle of dlopen(NULL, RTLD_GLOBAL).\n  if (!File)\n    Handle = RTLD_DEFAULT;\n#endif\n\n  return Handle;\n}\n\nvoid DynamicLibrary::HandleSet::DLClose(void *Handle) {\n  ::dlclose(Handle);\n}\n\nvoid *DynamicLibrary::HandleSet::DLSym(void *Handle, const char *Symbol) {\n  return ::dlsym(Handle, Symbol);\n}\n\n#else // !HAVE_DLOPEN\n\nDynamicLibrary::HandleSet::~HandleSet() {}\n\nvoid *DynamicLibrary::HandleSet::DLOpen(const char *File, std::string *Err) {\n  if (Err) *Err = \"dlopen() not supported on this platform\";\n  return &Invalid;\n}\n\nvoid DynamicLibrary::HandleSet::DLClose(void *Handle) {\n}\n\nvoid *DynamicLibrary::HandleSet::DLSym(void *Handle, const char *Symbol) {\n  return nullptr;\n}\n\n#endif\n\n// Must declare the symbols in the global namespace.\nstatic void *DoSearch(const char* SymbolName) {\n#define EXPLICIT_SYMBOL(SYM) \\\n   extern void *SYM; if (!strcmp(SymbolName, #SYM)) return &SYM\n\n  // If this is darwin, it has some funky issues, try to solve them here.  Some\n  // important symbols are marked 'private external' which doesn't allow\n  // SearchForAddressOfSymbol to find them.  As such, we special case them here,\n  // there is only a small handful of them.\n\n#ifdef __APPLE__\n  {\n    // __eprintf is sometimes used for assert() handling on x86.\n    //\n    // FIXME: Currently disabled when using Clang, as we don't always have our\n    // runtime support libraries available.\n#ifndef __clang__\n#ifdef __i386__\n    EXPLICIT_SYMBOL(__eprintf);\n#endif\n#endif\n  }\n#endif\n\n#ifdef __CYGWIN__\n  {\n    EXPLICIT_SYMBOL(_alloca);\n    EXPLICIT_SYMBOL(__main);\n  }\n#endif\n\n#undef EXPLICIT_SYMBOL\n\n// This macro returns the address of a well-known, explicit symbol\n#define EXPLICIT_SYMBOL(SYM) \\\n   if (!strcmp(SymbolName, #SYM)) return &SYM\n\n// Under glibc we have a weird situation. The stderr/out/in symbols are both\n// macros and global variables because of standards requirements. So, we\n// boldly use the EXPLICIT_SYMBOL macro without checking for a #define first.\n#if defined(__GLIBC__)\n  {\n    EXPLICIT_SYMBOL(stderr);\n    EXPLICIT_SYMBOL(stdout);\n    EXPLICIT_SYMBOL(stdin);\n  }\n#else\n  // For everything else, we want to check to make sure the symbol isn't defined\n  // as a macro before using EXPLICIT_SYMBOL.\n  {\n#ifndef stdin\n    EXPLICIT_SYMBOL(stdin);\n#endif\n#ifndef stdout\n    EXPLICIT_SYMBOL(stdout);\n#endif\n#ifndef stderr\n    EXPLICIT_SYMBOL(stderr);\n#endif\n  }\n#endif\n#undef EXPLICIT_SYMBOL\n\n  return nullptr;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/include/llvm/Config/config.h.cmake": "#ifndef CONFIG_H\n#define CONFIG_H\n\n/* Exported configuration */\n#include \"llvm/Config/llvm-config.h\"\n\n/* Bug report URL. */\n#define BUG_REPORT_URL \"${BUG_REPORT_URL}\"\n\n/* Define to 1 to enable backtraces, and to 0 otherwise. */\n#cmakedefine01 ENABLE_BACKTRACES\n\n/* Define to 1 to enable crash overrides, and to 0 otherwise. */\n#cmakedefine01 ENABLE_CRASH_OVERRIDES\n\n/* Define to 1 if you have the `backtrace' function. */\n#cmakedefine HAVE_BACKTRACE ${HAVE_BACKTRACE}\n\n#define BACKTRACE_HEADER <${BACKTRACE_HEADER}>\n\n/* Define to 1 if you have the <CrashReporterClient.h> header file. */\n#cmakedefine HAVE_CRASHREPORTERCLIENT_H\n\n/* can use __crashreporter_info__ */\n#cmakedefine01 HAVE_CRASHREPORTER_INFO\n\n/* Define to 1 if you have the declaration of `arc4random', and to 0 if you\n   don't. */\n#cmakedefine01 HAVE_DECL_ARC4RANDOM\n\n/* Define to 1 if you have the declaration of `FE_ALL_EXCEPT', and to 0 if you\n   don't. */\n#cmakedefine01 HAVE_DECL_FE_ALL_EXCEPT\n\n/* Define to 1 if you have the declaration of `FE_INEXACT', and to 0 if you\n   don't. */\n#cmakedefine01 HAVE_DECL_FE_INEXACT\n\n/* Define to 1 if you have the declaration of `strerror_s', and to 0 if you\n   don't. */\n#cmakedefine01 HAVE_DECL_STRERROR_S\n\n/* Define to 1 if you have the DIA SDK installed, and to 0 if you don't. */\n#cmakedefine01 LLVM_ENABLE_DIA_SDK\n\n/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.\n   */\n#cmakedefine HAVE_DIRENT_H ${HAVE_DIRENT_H}\n\n/* Define to 1 if you have the <dlfcn.h> header file. */\n#cmakedefine HAVE_DLFCN_H ${HAVE_DLFCN_H}\n\n/* Define if dlopen() is available on this platform. */\n#cmakedefine HAVE_DLOPEN ${HAVE_DLOPEN}\n\n/* Define if dladdr() is available on this platform. */\n#cmakedefine HAVE_DLADDR ${HAVE_DLADDR}\n\n/* Define to 1 if you have the <errno.h> header file. */\n#cmakedefine HAVE_ERRNO_H ${HAVE_ERRNO_H}\n\n/* Define to 1 if you have the <fcntl.h> header file. */\n#cmakedefine HAVE_FCNTL_H ${HAVE_FCNTL_H}\n\n/* Define to 1 if you have the <fenv.h> header file. */\n#cmakedefine HAVE_FENV_H ${HAVE_FENV_H}\n\n/* Define if libffi is available on this platform. */\n#cmakedefine HAVE_FFI_CALL ${HAVE_FFI_CALL}\n\n/* Define to 1 if you have the <ffi/ffi.h> header file. */\n#cmakedefine HAVE_FFI_FFI_H ${HAVE_FFI_FFI_H}\n\n/* Define to 1 if you have the <ffi.h> header file. */\n#cmakedefine HAVE_FFI_H ${HAVE_FFI_H}\n\n/* Define to 1 if you have the `futimens' function. */\n#cmakedefine HAVE_FUTIMENS ${HAVE_FUTIMENS}\n\n/* Define to 1 if you have the `futimes' function. */\n#cmakedefine HAVE_FUTIMES ${HAVE_FUTIMES}\n\n/* Define to 1 if you have the `getcwd' function. */\n#cmakedefine HAVE_GETCWD ${HAVE_GETCWD}\n\n/* Define to 1 if you have the `getpagesize' function. */\n#cmakedefine HAVE_GETPAGESIZE ${HAVE_GETPAGESIZE}\n\n/* Define to 1 if you have the `getrlimit' function. */\n#cmakedefine HAVE_GETRLIMIT ${HAVE_GETRLIMIT}\n\n/* Define to 1 if you have the `getrusage' function. */\n#cmakedefine HAVE_GETRUSAGE ${HAVE_GETRUSAGE}\n\n/* Define to 1 if you have the `gettimeofday' function. */\n#cmakedefine HAVE_GETTIMEOFDAY ${HAVE_GETTIMEOFDAY}\n\n/* Define to 1 if the system has the type `int64_t'. */\n#cmakedefine HAVE_INT64_T ${HAVE_INT64_T}\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#cmakedefine HAVE_INTTYPES_H ${HAVE_INTTYPES_H}\n\n/* Define to 1 if you have the `isatty' function. */\n#cmakedefine HAVE_ISATTY 1\n\n/* Define to 1 if you have the `edit' library (-ledit). */\n#cmakedefine HAVE_LIBEDIT ${HAVE_LIBEDIT}\n\n/* Define to 1 if you have the `psapi' library (-lpsapi). */\n#cmakedefine HAVE_LIBPSAPI ${HAVE_LIBPSAPI}\n\n/* Define to 1 if you have the `pthread' library (-lpthread). */\n#cmakedefine HAVE_LIBPTHREAD ${HAVE_LIBPTHREAD}\n\n/* Define to 1 if you have the `shell32' library (-lshell32). */\n#cmakedefine HAVE_LIBSHELL32 ${HAVE_LIBSHELL32}\n\n/* Define to 1 if you have the `z' library (-lz). */\n#cmakedefine HAVE_LIBZ ${HAVE_LIBZ}\n\n/* Define to 1 if you have the <link.h> header file. */\n#cmakedefine HAVE_LINK_H ${HAVE_LINK_H}\n\n/* Define to 1 if you have the `lseek64' function. */\n#cmakedefine HAVE_LSEEK64 ${HAVE_LSEEK64}\n\n/* Define to 1 if you have the <mach/mach.h> header file. */\n#cmakedefine HAVE_MACH_MACH_H ${HAVE_MACH_MACH_H}\n\n/* Define to 1 if you have the `mallctl' function. */\n#cmakedefine HAVE_MALLCTL ${HAVE_MALLCTL}\n\n/* Define to 1 if you have the `mallinfo' function. */\n#cmakedefine HAVE_MALLINFO ${HAVE_MALLINFO}\n\n/* Define to 1 if you have the <malloc.h> header file. */\n#cmakedefine HAVE_MALLOC_H ${HAVE_MALLOC_H}\n\n/* Define to 1 if you have the <malloc/malloc.h> header file. */\n#cmakedefine HAVE_MALLOC_MALLOC_H ${HAVE_MALLOC_MALLOC_H}\n\n/* Define to 1 if you have the `malloc_zone_statistics' function. */\n#cmakedefine HAVE_MALLOC_ZONE_STATISTICS ${HAVE_MALLOC_ZONE_STATISTICS}\n\n/* Define to 1 if you have the `mkdtemp' function. */\n#cmakedefine HAVE_MKDTEMP ${HAVE_MKDTEMP}\n\n/* Define to 1 if you have the `mkstemp' function. */\n#cmakedefine HAVE_MKSTEMP ${HAVE_MKSTEMP}\n\n/* Define to 1 if you have the `mktemp' function. */\n#cmakedefine HAVE_MKTEMP ${HAVE_MKTEMP}\n\n/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */\n#cmakedefine HAVE_NDIR_H ${HAVE_NDIR_H}\n\n/* Define to 1 if you have the `posix_fallocate' function. */\n#cmakedefine HAVE_POSIX_FALLOCATE ${HAVE_POSIX_FALLOCATE}\n\n/* Define to 1 if you have the `posix_spawn' function. */\n#cmakedefine HAVE_POSIX_SPAWN ${HAVE_POSIX_SPAWN}\n\n/* Define to 1 if you have the `pread' function. */\n#cmakedefine HAVE_PREAD ${HAVE_PREAD}\n\n/* Have pthread_getspecific */\n#cmakedefine HAVE_PTHREAD_GETSPECIFIC ${HAVE_PTHREAD_GETSPECIFIC}\n\n/* Define to 1 if you have the <pthread.h> header file. */\n#cmakedefine HAVE_PTHREAD_H ${HAVE_PTHREAD_H}\n\n/* Have pthread_mutex_lock */\n#cmakedefine HAVE_PTHREAD_MUTEX_LOCK ${HAVE_PTHREAD_MUTEX_LOCK}\n\n/* Have pthread_rwlock_init */\n#cmakedefine HAVE_PTHREAD_RWLOCK_INIT ${HAVE_PTHREAD_RWLOCK_INIT}\n\n/* Define to 1 if you have the `realpath' function. */\n#cmakedefine HAVE_REALPATH ${HAVE_REALPATH}\n\n/* Define to 1 if you have the `sbrk' function. */\n#cmakedefine HAVE_SBRK ${HAVE_SBRK}\n\n/* Define to 1 if you have the `setenv' function. */\n#cmakedefine HAVE_SETENV ${HAVE_SETENV}\n\n/* Define to 1 if you have the `setrlimit' function. */\n#cmakedefine HAVE_SETRLIMIT ${HAVE_SETRLIMIT}\n\n/* Define to 1 if you have the `sigaltstack' function. */\n#cmakedefine HAVE_SIGALTSTACK ${HAVE_SIGALTSTACK}\n\n/* Define to 1 if you have the <signal.h> header file. */\n#cmakedefine HAVE_SIGNAL_H ${HAVE_SIGNAL_H}\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#cmakedefine HAVE_STDINT_H ${HAVE_STDINT_H}\n\n/* Define to 1 if you have the `strerror' function. */\n#cmakedefine HAVE_STRERROR ${HAVE_STRERROR}\n\n/* Define to 1 if you have the `strerror_r' function. */\n#cmakedefine HAVE_STRERROR_R ${HAVE_STRERROR_R}\n\n/* Define to 1 if you have the `strtoll' function. */\n#cmakedefine HAVE_STRTOLL ${HAVE_STRTOLL}\n\n/* Define to 1 if you have the `sysconf' function. */\n#cmakedefine HAVE_SYSCONF ${HAVE_SYSCONF}\n\n/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.\n   */\n#cmakedefine HAVE_SYS_DIR_H ${HAVE_SYS_DIR_H}\n\n/* Define to 1 if you have the <sys/ioctl.h> header file. */\n#cmakedefine HAVE_SYS_IOCTL_H ${HAVE_SYS_IOCTL_H}\n\n/* Define to 1 if you have the <sys/mman.h> header file. */\n#cmakedefine HAVE_SYS_MMAN_H ${HAVE_SYS_MMAN_H}\n\n/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.\n   */\n#cmakedefine HAVE_SYS_NDIR_H ${HAVE_SYS_NDIR_H}\n\n/* Define to 1 if you have the <sys/param.h> header file. */\n#cmakedefine HAVE_SYS_PARAM_H ${HAVE_SYS_PARAM_H}\n\n/* Define to 1 if you have the <sys/resource.h> header file. */\n#cmakedefine HAVE_SYS_RESOURCE_H ${HAVE_SYS_RESOURCE_H}\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#cmakedefine HAVE_SYS_STAT_H ${HAVE_SYS_STAT_H}\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#cmakedefine HAVE_SYS_TIME_H ${HAVE_SYS_TIME_H}\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#cmakedefine HAVE_SYS_TYPES_H ${HAVE_SYS_TYPES_H}\n\n/* Define to 1 if you have the <sys/uio.h> header file. */\n#cmakedefine HAVE_SYS_UIO_H ${HAVE_SYS_UIO_H}\n\n/* Define if the setupterm() function is supported this platform. */\n#cmakedefine HAVE_TERMINFO ${HAVE_TERMINFO}\n\n/* Define if the xar_open() function is supported this platform. */\n#cmakedefine HAVE_LIBXAR ${HAVE_LIBXAR}\n\n/* Define to 1 if you have the <termios.h> header file. */\n#cmakedefine HAVE_TERMIOS_H ${HAVE_TERMIOS_H}\n\n/* Define to 1 if the system has the type `uint64_t'. */\n#cmakedefine HAVE_UINT64_T ${HAVE_UINT64_T}\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#cmakedefine HAVE_UNISTD_H ${HAVE_UNISTD_H}\n\n/* Define to 1 if the system has the type `u_int64_t'. */\n#cmakedefine HAVE_U_INT64_T ${HAVE_U_INT64_T}\n\n/* Define to 1 if you have the <valgrind/valgrind.h> header file. */\n#cmakedefine HAVE_VALGRIND_VALGRIND_H ${HAVE_VALGRIND_VALGRIND_H}\n\n/* Define to 1 if you have the `writev' function. */\n#cmakedefine HAVE_WRITEV ${HAVE_WRITEV}\n\n/* Define to 1 if you have the <zlib.h> header file. */\n#cmakedefine HAVE_ZLIB_H ${HAVE_ZLIB_H}\n\n/* Have host's _alloca */\n#cmakedefine HAVE__ALLOCA ${HAVE__ALLOCA}\n\n/* Define to 1 if you have the `_chsize_s' function. */\n#cmakedefine HAVE__CHSIZE_S ${HAVE__CHSIZE_S}\n\n/* Define to 1 if you have the `_Unwind_Backtrace' function. */\n#cmakedefine HAVE__UNWIND_BACKTRACE ${HAVE__UNWIND_BACKTRACE}\n\n/* Have host's __alloca */\n#cmakedefine HAVE___ALLOCA ${HAVE___ALLOCA}\n\n/* Have host's __ashldi3 */\n#cmakedefine HAVE___ASHLDI3 ${HAVE___ASHLDI3}\n\n/* Have host's __ashrdi3 */\n#cmakedefine HAVE___ASHRDI3 ${HAVE___ASHRDI3}\n\n/* Have host's __chkstk */\n#cmakedefine HAVE___CHKSTK ${HAVE___CHKSTK}\n\n/* Have host's __chkstk_ms */\n#cmakedefine HAVE___CHKSTK_MS ${HAVE___CHKSTK_MS}\n\n/* Have host's __cmpdi2 */\n#cmakedefine HAVE___CMPDI2 ${HAVE___CMPDI2}\n\n/* Have host's __divdi3 */\n#cmakedefine HAVE___DIVDI3 ${HAVE___DIVDI3}\n\n/* Have host's __fixdfdi */\n#cmakedefine HAVE___FIXDFDI ${HAVE___FIXDFDI}\n\n/* Have host's __fixsfdi */\n#cmakedefine HAVE___FIXSFDI ${HAVE___FIXSFDI}\n\n/* Have host's __floatdidf */\n#cmakedefine HAVE___FLOATDIDF ${HAVE___FLOATDIDF}\n\n/* Have host's __lshrdi3 */\n#cmakedefine HAVE___LSHRDI3 ${HAVE___LSHRDI3}\n\n/* Have host's __main */\n#cmakedefine HAVE___MAIN ${HAVE___MAIN}\n\n/* Have host's __moddi3 */\n#cmakedefine HAVE___MODDI3 ${HAVE___MODDI3}\n\n/* Have host's __udivdi3 */\n#cmakedefine HAVE___UDIVDI3 ${HAVE___UDIVDI3}\n\n/* Have host's __umoddi3 */\n#cmakedefine HAVE___UMODDI3 ${HAVE___UMODDI3}\n\n/* Have host's ___chkstk */\n#cmakedefine HAVE____CHKSTK ${HAVE____CHKSTK}\n\n/* Have host's ___chkstk_ms */\n#cmakedefine HAVE____CHKSTK_MS ${HAVE____CHKSTK_MS}\n\n/* Linker version detected at compile time. */\n#cmakedefine HOST_LINK_VERSION \"${HOST_LINK_VERSION}\"\n\n/* Define if we link Polly to the tools */\n#cmakedefine LINK_POLLY_INTO_TOOLS\n\n/* Target triple LLVM will generate code for by default */\n/* Doesn't use `cmakedefine` because it is allowed to be empty. */\n#define LLVM_DEFAULT_TARGET_TRIPLE \"${LLVM_DEFAULT_TARGET_TRIPLE}\"\n\n/* Define if threads enabled */\n#cmakedefine01 LLVM_ENABLE_THREADS\n\n/* Define if zlib compression is available */\n#cmakedefine01 LLVM_ENABLE_ZLIB\n\n/* Has gcc/MSVC atomic intrinsics */\n#cmakedefine01 LLVM_HAS_ATOMICS\n\n/* Host triple LLVM will be executed on */\n#cmakedefine LLVM_HOST_TRIPLE \"${LLVM_HOST_TRIPLE}\"\n\n/* Define if this is Unixish platform */\n#cmakedefine LLVM_ON_UNIX ${LLVM_ON_UNIX}\n\n/* Define if this is Win32ish platform */\n#cmakedefine LLVM_ON_WIN32 ${LLVM_ON_WIN32}\n\n/* Define if overriding target triple is enabled */\n#cmakedefine LLVM_TARGET_TRIPLE_ENV \"${LLVM_TARGET_TRIPLE_ENV}\"\n\n/* Define if we have the Intel JIT API runtime support library */\n#cmakedefine01 LLVM_USE_INTEL_JITEVENTS\n\n/* Define if we have the oprofile JIT-support library */\n#cmakedefine01 LLVM_USE_OPROFILE\n\n/* LLVM version information */\n#cmakedefine LLVM_VERSION_INFO \"${LLVM_VERSION_INFO}\"\n\n/* Whether tools show host and target info when invoked with --version */\n#cmakedefine01 LLVM_VERSION_PRINTER_SHOW_HOST_TARGET_INFO\n\n/* Major version of the LLVM API */\n#define LLVM_VERSION_MAJOR ${LLVM_VERSION_MAJOR}\n\n/* Minor version of the LLVM API */\n#define LLVM_VERSION_MINOR ${LLVM_VERSION_MINOR}\n\n/* Patch version of the LLVM API */\n#define LLVM_VERSION_PATCH ${LLVM_VERSION_PATCH}\n\n/* LLVM version string */\n#define LLVM_VERSION_STRING \"${PACKAGE_VERSION}\"\n\n/* Define to the extension used for shared libraries, say, \".so\". */\n#cmakedefine LTDL_SHLIB_EXT \"${LTDL_SHLIB_EXT}\"\n\n/* Define to the address where bug reports for this package should be sent. */\n#cmakedefine PACKAGE_BUGREPORT \"${PACKAGE_BUGREPORT}\"\n\n/* Define to the full name of this package. */\n#cmakedefine PACKAGE_NAME \"${PACKAGE_NAME}\"\n\n/* Define to the full name and version of this package. */\n#cmakedefine PACKAGE_STRING \"${PACKAGE_STRING}\"\n\n/* Define to the one symbol short name of this package. */\n#undef PACKAGE_TARNAME\n\n/* Define to the version of this package. */\n#cmakedefine PACKAGE_VERSION \"${PACKAGE_VERSION}\"\n\n/* Define to the vendor of this package. */\n#cmakedefine PACKAGE_VENDOR \"${PACKAGE_VENDOR}\"\n\n/* Define as the return type of signal handlers (`int' or `void'). */\n#cmakedefine RETSIGTYPE ${RETSIGTYPE}\n\n/* Define to a function replacing strtoll */\n#cmakedefine strtoll ${strtoll}\n\n/* Define to a function implementing strtoull */\n#cmakedefine strtoull ${strtoull}\n\n/* Define to a function implementing stricmp */\n#cmakedefine stricmp ${stricmp}\n\n/* Define to a function implementing strdup */\n#cmakedefine strdup ${strdup}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/include/llvm/BinaryFormat/ELF.h": "//===- llvm/BinaryFormat/ELF.h - ELF constants and structures ---*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This header contains common, non-processor-specific data structures and\n// constants for the ELF file format.\n//\n// The details of the ELF32 bits in this file are largely based on the Tool\n// Interface Standard (TIS) Executable and Linking Format (ELF) Specification\n// Version 1.2, May 1995. The ELF64 stuff is based on ELF-64 Object File Format\n// Version 1.5, Draft 2, May 1998 as well as OpenBSD header files.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_BINARYFORMAT_ELF_H\n#define LLVM_BINARYFORMAT_ELF_H\n\n#include <cstdint>\n#include <cstring>\n\nnamespace llvm {\nnamespace ELF {\n\nusing Elf32_Addr = uint32_t; // Program address\nusing Elf32_Off = uint32_t;  // File offset\nusing Elf32_Half = uint16_t;\nusing Elf32_Word = uint32_t;\nusing Elf32_Sword = int32_t;\n\nusing Elf64_Addr = uint64_t;\nusing Elf64_Off = uint64_t;\nusing Elf64_Half = uint16_t;\nusing Elf64_Word = uint32_t;\nusing Elf64_Sword = int32_t;\nusing Elf64_Xword = uint64_t;\nusing Elf64_Sxword = int64_t;\n\n// Object file magic string.\nstatic const char ElfMagic[] = {0x7f, 'E', 'L', 'F', '\\0'};\n\n// e_ident size and indices.\nenum {\n  EI_MAG0 = 0,       // File identification index.\n  EI_MAG1 = 1,       // File identification index.\n  EI_MAG2 = 2,       // File identification index.\n  EI_MAG3 = 3,       // File identification index.\n  EI_CLASS = 4,      // File class.\n  EI_DATA = 5,       // Data encoding.\n  EI_VERSION = 6,    // File version.\n  EI_OSABI = 7,      // OS/ABI identification.\n  EI_ABIVERSION = 8, // ABI version.\n  EI_PAD = 9,        // Start of padding bytes.\n  EI_NIDENT = 16     // Number of bytes in e_ident.\n};\n\nstruct Elf32_Ehdr {\n  unsigned char e_ident[EI_NIDENT]; // ELF Identification bytes\n  Elf32_Half e_type;                // Type of file (see ET_* below)\n  Elf32_Half e_machine;   // Required architecture for this file (see EM_*)\n  Elf32_Word e_version;   // Must be equal to 1\n  Elf32_Addr e_entry;     // Address to jump to in order to start program\n  Elf32_Off e_phoff;      // Program header table's file offset, in bytes\n  Elf32_Off e_shoff;      // Section header table's file offset, in bytes\n  Elf32_Word e_flags;     // Processor-specific flags\n  Elf32_Half e_ehsize;    // Size of ELF header, in bytes\n  Elf32_Half e_phentsize; // Size of an entry in the program header table\n  Elf32_Half e_phnum;     // Number of entries in the program header table\n  Elf32_Half e_shentsize; // Size of an entry in the section header table\n  Elf32_Half e_shnum;     // Number of entries in the section header table\n  Elf32_Half e_shstrndx;  // Sect hdr table index of sect name string table\n\n  bool checkMagic() const {\n    return (memcmp(e_ident, ElfMagic, strlen(ElfMagic))) == 0;\n  }\n\n  unsigned char getFileClass() const { return e_ident[EI_CLASS]; }\n  unsigned char getDataEncoding() const { return e_ident[EI_DATA]; }\n};\n\n// 64-bit ELF header. Fields are the same as for ELF32, but with different\n// types (see above).\nstruct Elf64_Ehdr {\n  unsigned char e_ident[EI_NIDENT];\n  Elf64_Half e_type;\n  Elf64_Half e_machine;\n  Elf64_Word e_version;\n  Elf64_Addr e_entry;\n  Elf64_Off e_phoff;\n  Elf64_Off e_shoff;\n  Elf64_Word e_flags;\n  Elf64_Half e_ehsize;\n  Elf64_Half e_phentsize;\n  Elf64_Half e_phnum;\n  Elf64_Half e_shentsize;\n  Elf64_Half e_shnum;\n  Elf64_Half e_shstrndx;\n\n  bool checkMagic() const {\n    return (memcmp(e_ident, ElfMagic, strlen(ElfMagic))) == 0;\n  }\n\n  unsigned char getFileClass() const { return e_ident[EI_CLASS]; }\n  unsigned char getDataEncoding() const { return e_ident[EI_DATA]; }\n};\n\n// File types\nenum {\n  ET_NONE = 0,        // No file type\n  ET_REL = 1,         // Relocatable file\n  ET_EXEC = 2,        // Executable file\n  ET_DYN = 3,         // Shared object file\n  ET_CORE = 4,        // Core file\n  ET_LOPROC = 0xff00, // Beginning of processor-specific codes\n  ET_HIPROC = 0xffff  // Processor-specific\n};\n\n// Versioning\nenum { EV_NONE = 0, EV_CURRENT = 1 };\n\n// Machine architectures\n// See current registered ELF machine architectures at:\n//    http://www.uxsglobal.com/developers/gabi/latest/ch4.eheader.html\nenum {\n  EM_NONE = 0,           // No machine\n  EM_M32 = 1,            // AT&T WE 32100\n  EM_SPARC = 2,          // SPARC\n  EM_386 = 3,            // Intel 386\n  EM_68K = 4,            // Motorola 68000\n  EM_88K = 5,            // Motorola 88000\n  EM_IAMCU = 6,          // Intel MCU\n  EM_860 = 7,            // Intel 80860\n  EM_MIPS = 8,           // MIPS R3000\n  EM_S370 = 9,           // IBM System/370\n  EM_MIPS_RS3_LE = 10,   // MIPS RS3000 Little-endian\n  EM_PARISC = 15,        // Hewlett-Packard PA-RISC\n  EM_VPP500 = 17,        // Fujitsu VPP500\n  EM_SPARC32PLUS = 18,   // Enhanced instruction set SPARC\n  EM_960 = 19,           // Intel 80960\n  EM_PPC = 20,           // PowerPC\n  EM_PPC64 = 21,         // PowerPC64\n  EM_S390 = 22,          // IBM System/390\n  EM_SPU = 23,           // IBM SPU/SPC\n  EM_V800 = 36,          // NEC V800\n  EM_FR20 = 37,          // Fujitsu FR20\n  EM_RH32 = 38,          // TRW RH-32\n  EM_RCE = 39,           // Motorola RCE\n  EM_ARM = 40,           // ARM\n  EM_ALPHA = 41,         // DEC Alpha\n  EM_SH = 42,            // Hitachi SH\n  EM_SPARCV9 = 43,       // SPARC V9\n  EM_TRICORE = 44,       // Siemens TriCore\n  EM_ARC = 45,           // Argonaut RISC Core\n  EM_H8_300 = 46,        // Hitachi H8/300\n  EM_H8_300H = 47,       // Hitachi H8/300H\n  EM_H8S = 48,           // Hitachi H8S\n  EM_H8_500 = 49,        // Hitachi H8/500\n  EM_IA_64 = 50,         // Intel IA-64 processor architecture\n  EM_MIPS_X = 51,        // Stanford MIPS-X\n  EM_COLDFIRE = 52,      // Motorola ColdFire\n  EM_68HC12 = 53,        // Motorola M68HC12\n  EM_MMA = 54,           // Fujitsu MMA Multimedia Accelerator\n  EM_PCP = 55,           // Siemens PCP\n  EM_NCPU = 56,          // Sony nCPU embedded RISC processor\n  EM_NDR1 = 57,          // Denso NDR1 microprocessor\n  EM_STARCORE = 58,      // Motorola Star*Core processor\n  EM_ME16 = 59,          // Toyota ME16 processor\n  EM_ST100 = 60,         // STMicroelectronics ST100 processor\n  EM_TINYJ = 61,         // Advanced Logic Corp. TinyJ embedded processor family\n  EM_X86_64 = 62,        // AMD x86-64 architecture\n  EM_PDSP = 63,          // Sony DSP Processor\n  EM_PDP10 = 64,         // Digital Equipment Corp. PDP-10\n  EM_PDP11 = 65,         // Digital Equipment Corp. PDP-11\n  EM_FX66 = 66,          // Siemens FX66 microcontroller\n  EM_ST9PLUS = 67,       // STMicroelectronics ST9+ 8/16 bit microcontroller\n  EM_ST7 = 68,           // STMicroelectronics ST7 8-bit microcontroller\n  EM_68HC16 = 69,        // Motorola MC68HC16 Microcontroller\n  EM_68HC11 = 70,        // Motorola MC68HC11 Microcontroller\n  EM_68HC08 = 71,        // Motorola MC68HC08 Microcontroller\n  EM_68HC05 = 72,        // Motorola MC68HC05 Microcontroller\n  EM_SVX = 73,           // Silicon Graphics SVx\n  EM_ST19 = 74,          // STMicroelectronics ST19 8-bit microcontroller\n  EM_VAX = 75,           // Digital VAX\n  EM_CRIS = 76,          // Axis Communications 32-bit embedded processor\n  EM_JAVELIN = 77,       // Infineon Technologies 32-bit embedded processor\n  EM_FIREPATH = 78,      // Element 14 64-bit DSP Processor\n  EM_ZSP = 79,           // LSI Logic 16-bit DSP Processor\n  EM_MMIX = 80,          // Donald Knuth's educational 64-bit processor\n  EM_HUANY = 81,         // Harvard University machine-independent object files\n  EM_PRISM = 82,         // SiTera Prism\n  EM_AVR = 83,           // Atmel AVR 8-bit microcontroller\n  EM_FR30 = 84,          // Fujitsu FR30\n  EM_D10V = 85,          // Mitsubishi D10V\n  EM_D30V = 86,          // Mitsubishi D30V\n  EM_V850 = 87,          // NEC v850\n  EM_M32R = 88,          // Mitsubishi M32R\n  EM_MN10300 = 89,       // Matsushita MN10300\n  EM_MN10200 = 90,       // Matsushita MN10200\n  EM_PJ = 91,            // picoJava\n  EM_OPENRISC = 92,      // OpenRISC 32-bit embedded processor\n  EM_ARC_COMPACT = 93,   // ARC International ARCompact processor (old\n                         // spelling/synonym: EM_ARC_A5)\n  EM_XTENSA = 94,        // Tensilica Xtensa Architecture\n  EM_VIDEOCORE = 95,     // Alphamosaic VideoCore processor\n  EM_TMM_GPP = 96,       // Thompson Multimedia General Purpose Processor\n  EM_NS32K = 97,         // National Semiconductor 32000 series\n  EM_TPC = 98,           // Tenor Network TPC processor\n  EM_SNP1K = 99,         // Trebia SNP 1000 processor\n  EM_ST200 = 100,        // STMicroelectronics (www.st.com) ST200\n  EM_IP2K = 101,         // Ubicom IP2xxx microcontroller family\n  EM_MAX = 102,          // MAX Processor\n  EM_CR = 103,           // National Semiconductor CompactRISC microprocessor\n  EM_F2MC16 = 104,       // Fujitsu F2MC16\n  EM_MSP430 = 105,       // Texas Instruments embedded microcontroller msp430\n  EM_BLACKFIN = 106,     // Analog Devices Blackfin (DSP) processor\n  EM_SE_C33 = 107,       // S1C33 Family of Seiko Epson processors\n  EM_SEP = 108,          // Sharp embedded microprocessor\n  EM_ARCA = 109,         // Arca RISC Microprocessor\n  EM_UNICORE = 110,      // Microprocessor series from PKU-Unity Ltd. and MPRC\n                         // of Peking University\n  EM_EXCESS = 111,       // eXcess: 16/32/64-bit configurable embedded CPU\n  EM_DXP = 112,          // Icera Semiconductor Inc. Deep Execution Processor\n  EM_ALTERA_NIOS2 = 113, // Altera Nios II soft-core processor\n  EM_CRX = 114,          // National Semiconductor CompactRISC CRX\n  EM_XGATE = 115,        // Motorola XGATE embedded processor\n  EM_C166 = 116,         // Infineon C16x/XC16x processor\n  EM_M16C = 117,         // Renesas M16C series microprocessors\n  EM_DSPIC30F = 118,     // Microchip Technology dsPIC30F Digital Signal\n                         // Controller\n  EM_CE = 119,           // Freescale Communication Engine RISC core\n  EM_M32C = 120,         // Renesas M32C series microprocessors\n  EM_TSK3000 = 131,      // Altium TSK3000 core\n  EM_RS08 = 132,         // Freescale RS08 embedded processor\n  EM_SHARC = 133,        // Analog Devices SHARC family of 32-bit DSP\n                         // processors\n  EM_ECOG2 = 134,        // Cyan Technology eCOG2 microprocessor\n  EM_SCORE7 = 135,       // Sunplus S+core7 RISC processor\n  EM_DSP24 = 136,        // New Japan Radio (NJR) 24-bit DSP Processor\n  EM_VIDEOCORE3 = 137,   // Broadcom VideoCore III processor\n  EM_LATTICEMICO32 = 138, // RISC processor for Lattice FPGA architecture\n  EM_SE_C17 = 139,        // Seiko Epson C17 family\n  EM_TI_C6000 = 140,      // The Texas Instruments TMS320C6000 DSP family\n  EM_TI_C2000 = 141,      // The Texas Instruments TMS320C2000 DSP family\n  EM_TI_C5500 = 142,      // The Texas Instruments TMS320C55x DSP family\n  EM_MMDSP_PLUS = 160,    // STMicroelectronics 64bit VLIW Data Signal Processor\n  EM_CYPRESS_M8C = 161,   // Cypress M8C microprocessor\n  EM_R32C = 162,          // Renesas R32C series microprocessors\n  EM_TRIMEDIA = 163,      // NXP Semiconductors TriMedia architecture family\n  EM_HEXAGON = 164,       // Qualcomm Hexagon processor\n  EM_8051 = 165,          // Intel 8051 and variants\n  EM_STXP7X = 166,        // STMicroelectronics STxP7x family of configurable\n                          // and extensible RISC processors\n  EM_NDS32 = 167,         // Andes Technology compact code size embedded RISC\n                          // processor family\n  EM_ECOG1 = 168,         // Cyan Technology eCOG1X family\n  EM_ECOG1X = 168,        // Cyan Technology eCOG1X family\n  EM_MAXQ30 = 169,        // Dallas Semiconductor MAXQ30 Core Micro-controllers\n  EM_XIMO16 = 170,        // New Japan Radio (NJR) 16-bit DSP Processor\n  EM_MANIK = 171,         // M2000 Reconfigurable RISC Microprocessor\n  EM_CRAYNV2 = 172,       // Cray Inc. NV2 vector architecture\n  EM_RX = 173,            // Renesas RX family\n  EM_METAG = 174,         // Imagination Technologies META processor\n                          // architecture\n  EM_MCST_ELBRUS = 175,   // MCST Elbrus general purpose hardware architecture\n  EM_ECOG16 = 176,        // Cyan Technology eCOG16 family\n  EM_CR16 = 177,          // National Semiconductor CompactRISC CR16 16-bit\n                          // microprocessor\n  EM_ETPU = 178,          // Freescale Extended Time Processing Unit\n  EM_SLE9X = 179,         // Infineon Technologies SLE9X core\n  EM_L10M = 180,          // Intel L10M\n  EM_K10M = 181,          // Intel K10M\n  EM_AARCH64 = 183,       // ARM AArch64\n  EM_AVR32 = 185,         // Atmel Corporation 32-bit microprocessor family\n  EM_STM8 = 186,          // STMicroeletronics STM8 8-bit microcontroller\n  EM_TILE64 = 187,        // Tilera TILE64 multicore architecture family\n  EM_TILEPRO = 188,       // Tilera TILEPro multicore architecture family\n  EM_CUDA = 190,          // NVIDIA CUDA architecture\n  EM_TILEGX = 191,        // Tilera TILE-Gx multicore architecture family\n  EM_CLOUDSHIELD = 192,   // CloudShield architecture family\n  EM_COREA_1ST = 193,     // KIPO-KAIST Core-A 1st generation processor family\n  EM_COREA_2ND = 194,     // KIPO-KAIST Core-A 2nd generation processor family\n  EM_ARC_COMPACT2 = 195,  // Synopsys ARCompact V2\n  EM_OPEN8 = 196,         // Open8 8-bit RISC soft processor core\n  EM_RL78 = 197,          // Renesas RL78 family\n  EM_VIDEOCORE5 = 198,    // Broadcom VideoCore V processor\n  EM_78KOR = 199,         // Renesas 78KOR family\n  EM_56800EX = 200,       // Freescale 56800EX Digital Signal Controller (DSC)\n  EM_BA1 = 201,           // Beyond BA1 CPU architecture\n  EM_BA2 = 202,           // Beyond BA2 CPU architecture\n  EM_XCORE = 203,         // XMOS xCORE processor family\n  EM_MCHP_PIC = 204,      // Microchip 8-bit PIC(r) family\n  EM_INTEL205 = 205,      // Reserved by Intel\n  EM_INTEL206 = 206,      // Reserved by Intel\n  EM_INTEL207 = 207,      // Reserved by Intel\n  EM_INTEL208 = 208,      // Reserved by Intel\n  EM_INTEL209 = 209,      // Reserved by Intel\n  EM_KM32 = 210,          // KM211 KM32 32-bit processor\n  EM_KMX32 = 211,         // KM211 KMX32 32-bit processor\n  EM_KMX16 = 212,         // KM211 KMX16 16-bit processor\n  EM_KMX8 = 213,          // KM211 KMX8 8-bit processor\n  EM_KVARC = 214,         // KM211 KVARC processor\n  EM_CDP = 215,           // Paneve CDP architecture family\n  EM_COGE = 216,          // Cognitive Smart Memory Processor\n  EM_COOL = 217,          // iCelero CoolEngine\n  EM_NORC = 218,          // Nanoradio Optimized RISC\n  EM_CSR_KALIMBA = 219,   // CSR Kalimba architecture family\n  EM_AMDGPU = 224,        // AMD GPU architecture\n  EM_RISCV = 243,         // RISC-V\n  EM_LANAI = 244,         // Lanai 32-bit processor\n  EM_BPF = 247,           // Linux kernel bpf virtual machine\n\n  // A request has been made to the maintainer of the official registry for\n  // such numbers for an official value for WebAssembly. As soon as one is\n  // allocated, this enum will be updated to use it.\n  EM_WEBASSEMBLY = 0x4157, // WebAssembly architecture\n};\n\n// Object file classes.\nenum {\n  ELFCLASSNONE = 0,\n  ELFCLASS32 = 1, // 32-bit object file\n  ELFCLASS64 = 2  // 64-bit object file\n};\n\n// Object file byte orderings.\nenum {\n  ELFDATANONE = 0, // Invalid data encoding.\n  ELFDATA2LSB = 1, // Little-endian object file\n  ELFDATA2MSB = 2  // Big-endian object file\n};\n\n// OS ABI identification.\nenum {\n  ELFOSABI_NONE = 0,          // UNIX System V ABI\n  ELFOSABI_HPUX = 1,          // HP-UX operating system\n  ELFOSABI_NETBSD = 2,        // NetBSD\n  ELFOSABI_GNU = 3,           // GNU/Linux\n  ELFOSABI_LINUX = 3,         // Historical alias for ELFOSABI_GNU.\n  ELFOSABI_HURD = 4,          // GNU/Hurd\n  ELFOSABI_SOLARIS = 6,       // Solaris\n  ELFOSABI_AIX = 7,           // AIX\n  ELFOSABI_IRIX = 8,          // IRIX\n  ELFOSABI_FREEBSD = 9,       // FreeBSD\n  ELFOSABI_TRU64 = 10,        // TRU64 UNIX\n  ELFOSABI_MODESTO = 11,      // Novell Modesto\n  ELFOSABI_OPENBSD = 12,      // OpenBSD\n  ELFOSABI_OPENVMS = 13,      // OpenVMS\n  ELFOSABI_NSK = 14,          // Hewlett-Packard Non-Stop Kernel\n  ELFOSABI_AROS = 15,         // AROS\n  ELFOSABI_FENIXOS = 16,      // FenixOS\n  ELFOSABI_CLOUDABI = 17,     // Nuxi CloudABI\n  ELFOSABI_C6000_ELFABI = 64, // Bare-metal TMS320C6000\n  ELFOSABI_AMDGPU_HSA = 64,   // AMD HSA runtime\n  ELFOSABI_C6000_LINUX = 65,  // Linux TMS320C6000\n  ELFOSABI_ARM = 97,          // ARM\n  ELFOSABI_STANDALONE = 255   // Standalone (embedded) application\n};\n\n#define ELF_RELOC(name, value) name = value,\n\n// X86_64 relocations.\nenum {\n#include \"ELFRelocs/x86_64.def\"\n};\n\n// i386 relocations.\nenum {\n#include \"ELFRelocs/i386.def\"\n};\n\n// ELF Relocation types for PPC32\nenum {\n#include \"ELFRelocs/PowerPC.def\"\n};\n\n// Specific e_flags for PPC64\nenum {\n  // e_flags bits specifying ABI:\n  // 1 for original ABI using function descriptors,\n  // 2 for revised ABI without function descriptors,\n  // 0 for unspecified or not using any features affected by the differences.\n  EF_PPC64_ABI = 3\n};\n\n// Special values for the st_other field in the symbol table entry for PPC64.\nenum {\n  STO_PPC64_LOCAL_BIT = 5,\n  STO_PPC64_LOCAL_MASK = (7 << STO_PPC64_LOCAL_BIT)\n};\nstatic inline int64_t decodePPC64LocalEntryOffset(unsigned Other) {\n  unsigned Val = (Other & STO_PPC64_LOCAL_MASK) >> STO_PPC64_LOCAL_BIT;\n  return ((1 << Val) >> 2) << 2;\n}\nstatic inline unsigned encodePPC64LocalEntryOffset(int64_t Offset) {\n  unsigned Val =\n      (Offset >= 4 * 4 ? (Offset >= 8 * 4 ? (Offset >= 16 * 4 ? 6 : 5) : 4)\n                       : (Offset >= 2 * 4 ? 3 : (Offset >= 1 * 4 ? 2 : 0)));\n  return Val << STO_PPC64_LOCAL_BIT;\n}\n\n// ELF Relocation types for PPC64\nenum {\n#include \"ELFRelocs/PowerPC64.def\"\n};\n\n// ELF Relocation types for AArch64\nenum {\n#include \"ELFRelocs/AArch64.def\"\n};\n\n// ARM Specific e_flags\nenum : unsigned {\n  EF_ARM_SOFT_FLOAT = 0x00000200U,\n  EF_ARM_VFP_FLOAT = 0x00000400U,\n  EF_ARM_EABI_UNKNOWN = 0x00000000U,\n  EF_ARM_EABI_VER1 = 0x01000000U,\n  EF_ARM_EABI_VER2 = 0x02000000U,\n  EF_ARM_EABI_VER3 = 0x03000000U,\n  EF_ARM_EABI_VER4 = 0x04000000U,\n  EF_ARM_EABI_VER5 = 0x05000000U,\n  EF_ARM_EABIMASK = 0xFF000000U\n};\n\n// ELF Relocation types for ARM\nenum {\n#include \"ELFRelocs/ARM.def\"\n};\n\n// AVR specific e_flags\nenum : unsigned {\n  EF_AVR_ARCH_AVR1 = 1,\n  EF_AVR_ARCH_AVR2 = 2,\n  EF_AVR_ARCH_AVR25 = 25,\n  EF_AVR_ARCH_AVR3 = 3,\n  EF_AVR_ARCH_AVR31 = 31,\n  EF_AVR_ARCH_AVR35 = 35,\n  EF_AVR_ARCH_AVR4 = 4,\n  EF_AVR_ARCH_AVR5 = 5,\n  EF_AVR_ARCH_AVR51 = 51,\n  EF_AVR_ARCH_AVR6 = 6,\n  EF_AVR_ARCH_AVRTINY = 100,\n  EF_AVR_ARCH_XMEGA1 = 101,\n  EF_AVR_ARCH_XMEGA2 = 102,\n  EF_AVR_ARCH_XMEGA3 = 103,\n  EF_AVR_ARCH_XMEGA4 = 104,\n  EF_AVR_ARCH_XMEGA5 = 105,\n  EF_AVR_ARCH_XMEGA6 = 106,\n  EF_AVR_ARCH_XMEGA7 = 107\n};\n\n// ELF Relocation types for AVR\nenum {\n#include \"ELFRelocs/AVR.def\"\n};\n\n// Mips Specific e_flags\nenum : unsigned {\n  EF_MIPS_NOREORDER = 0x00000001, // Don't reorder instructions\n  EF_MIPS_PIC = 0x00000002,       // Position independent code\n  EF_MIPS_CPIC = 0x00000004,      // Call object with Position independent code\n  EF_MIPS_ABI2 = 0x00000020,      // File uses N32 ABI\n  EF_MIPS_32BITMODE = 0x00000100, // Code compiled for a 64-bit machine\n                                  // in 32-bit mode\n  EF_MIPS_FP64 = 0x00000200,      // Code compiled for a 32-bit machine\n                                  // but uses 64-bit FP registers\n  EF_MIPS_NAN2008 = 0x00000400,   // Uses IEE 754-2008 NaN encoding\n\n  // ABI flags\n  EF_MIPS_ABI_O32 = 0x00001000, // This file follows the first MIPS 32 bit ABI\n  EF_MIPS_ABI_O64 = 0x00002000, // O32 ABI extended for 64-bit architecture.\n  EF_MIPS_ABI_EABI32 = 0x00003000, // EABI in 32 bit mode.\n  EF_MIPS_ABI_EABI64 = 0x00004000, // EABI in 64 bit mode.\n  EF_MIPS_ABI = 0x0000f000,        // Mask for selecting EF_MIPS_ABI_ variant.\n\n  // MIPS machine variant\n  EF_MIPS_MACH_NONE = 0x00000000,    // A standard MIPS implementation.\n  EF_MIPS_MACH_3900 = 0x00810000,    // Toshiba R3900\n  EF_MIPS_MACH_4010 = 0x00820000,    // LSI R4010\n  EF_MIPS_MACH_4100 = 0x00830000,    // NEC VR4100\n  EF_MIPS_MACH_4650 = 0x00850000,    // MIPS R4650\n  EF_MIPS_MACH_4120 = 0x00870000,    // NEC VR4120\n  EF_MIPS_MACH_4111 = 0x00880000,    // NEC VR4111/VR4181\n  EF_MIPS_MACH_SB1 = 0x008a0000,     // Broadcom SB-1\n  EF_MIPS_MACH_OCTEON = 0x008b0000,  // Cavium Networks Octeon\n  EF_MIPS_MACH_XLR = 0x008c0000,     // RMI Xlr\n  EF_MIPS_MACH_OCTEON2 = 0x008d0000, // Cavium Networks Octeon2\n  EF_MIPS_MACH_OCTEON3 = 0x008e0000, // Cavium Networks Octeon3\n  EF_MIPS_MACH_5400 = 0x00910000,    // NEC VR5400\n  EF_MIPS_MACH_5900 = 0x00920000,    // MIPS R5900\n  EF_MIPS_MACH_5500 = 0x00980000,    // NEC VR5500\n  EF_MIPS_MACH_9000 = 0x00990000,    // Unknown\n  EF_MIPS_MACH_LS2E = 0x00a00000,    // ST Microelectronics Loongson 2E\n  EF_MIPS_MACH_LS2F = 0x00a10000,    // ST Microelectronics Loongson 2F\n  EF_MIPS_MACH_LS3A = 0x00a20000,    // Loongson 3A\n  EF_MIPS_MACH = 0x00ff0000,         // EF_MIPS_MACH_xxx selection mask\n\n  // ARCH_ASE\n  EF_MIPS_MICROMIPS = 0x02000000,     // microMIPS\n  EF_MIPS_ARCH_ASE_M16 = 0x04000000,  // Has Mips-16 ISA extensions\n  EF_MIPS_ARCH_ASE_MDMX = 0x08000000, // Has MDMX multimedia extensions\n  EF_MIPS_ARCH_ASE = 0x0f000000,      // Mask for EF_MIPS_ARCH_ASE_xxx flags\n\n  // ARCH\n  EF_MIPS_ARCH_1 = 0x00000000,    // MIPS1 instruction set\n  EF_MIPS_ARCH_2 = 0x10000000,    // MIPS2 instruction set\n  EF_MIPS_ARCH_3 = 0x20000000,    // MIPS3 instruction set\n  EF_MIPS_ARCH_4 = 0x30000000,    // MIPS4 instruction set\n  EF_MIPS_ARCH_5 = 0x40000000,    // MIPS5 instruction set\n  EF_MIPS_ARCH_32 = 0x50000000,   // MIPS32 instruction set per linux not elf.h\n  EF_MIPS_ARCH_64 = 0x60000000,   // MIPS64 instruction set per linux not elf.h\n  EF_MIPS_ARCH_32R2 = 0x70000000, // mips32r2, mips32r3, mips32r5\n  EF_MIPS_ARCH_64R2 = 0x80000000, // mips64r2, mips64r3, mips64r5\n  EF_MIPS_ARCH_32R6 = 0x90000000, // mips32r6\n  EF_MIPS_ARCH_64R6 = 0xa0000000, // mips64r6\n  EF_MIPS_ARCH = 0xf0000000       // Mask for applying EF_MIPS_ARCH_ variant\n};\n\n// ELF Relocation types for Mips\nenum {\n#include \"ELFRelocs/Mips.def\"\n};\n\n// Special values for the st_other field in the symbol table entry for MIPS.\nenum {\n  STO_MIPS_OPTIONAL = 0x04,  // Symbol whose definition is optional\n  STO_MIPS_PLT = 0x08,       // PLT entry related dynamic table record\n  STO_MIPS_PIC = 0x20,       // PIC func in an object mixes PIC/non-PIC\n  STO_MIPS_MICROMIPS = 0x80, // MIPS Specific ISA for MicroMips\n  STO_MIPS_MIPS16 = 0xf0     // MIPS Specific ISA for Mips16\n};\n\n// .MIPS.options section descriptor kinds\nenum {\n  ODK_NULL = 0,       // Undefined\n  ODK_REGINFO = 1,    // Register usage information\n  ODK_EXCEPTIONS = 2, // Exception processing options\n  ODK_PAD = 3,        // Section padding options\n  ODK_HWPATCH = 4,    // Hardware patches applied\n  ODK_FILL = 5,       // Linker fill value\n  ODK_TAGS = 6,       // Space for tool identification\n  ODK_HWAND = 7,      // Hardware AND patches applied\n  ODK_HWOR = 8,       // Hardware OR patches applied\n  ODK_GP_GROUP = 9,   // GP group to use for text/data sections\n  ODK_IDENT = 10,     // ID information\n  ODK_PAGESIZE = 11   // Page size information\n};\n\n// Hexagon-specific e_flags\nenum {\n  // Object processor version flags, bits[11:0]\n  EF_HEXAGON_MACH_V2 = 0x00000001,  // Hexagon V2\n  EF_HEXAGON_MACH_V3 = 0x00000002,  // Hexagon V3\n  EF_HEXAGON_MACH_V4 = 0x00000003,  // Hexagon V4\n  EF_HEXAGON_MACH_V5 = 0x00000004,  // Hexagon V5\n  EF_HEXAGON_MACH_V55 = 0x00000005, // Hexagon V55\n  EF_HEXAGON_MACH_V60 = 0x00000060, // Hexagon V60\n  EF_HEXAGON_MACH_V62 = 0x00000062, // Hexagon V62\n\n  // Highest ISA version flags\n  EF_HEXAGON_ISA_MACH = 0x00000000, // Same as specified in bits[11:0]\n                                    // of e_flags\n  EF_HEXAGON_ISA_V2 = 0x00000010,   // Hexagon V2 ISA\n  EF_HEXAGON_ISA_V3 = 0x00000020,   // Hexagon V3 ISA\n  EF_HEXAGON_ISA_V4 = 0x00000030,   // Hexagon V4 ISA\n  EF_HEXAGON_ISA_V5 = 0x00000040,   // Hexagon V5 ISA\n  EF_HEXAGON_ISA_V55 = 0x00000050,  // Hexagon V55 ISA\n  EF_HEXAGON_ISA_V60 = 0x00000060,  // Hexagon V60 ISA\n  EF_HEXAGON_ISA_V62 = 0x00000062,  // Hexagon V62 ISA\n};\n\n// Hexagon-specific section indexes for common small data\nenum {\n  SHN_HEXAGON_SCOMMON = 0xff00,   // Other access sizes\n  SHN_HEXAGON_SCOMMON_1 = 0xff01, // Byte-sized access\n  SHN_HEXAGON_SCOMMON_2 = 0xff02, // Half-word-sized access\n  SHN_HEXAGON_SCOMMON_4 = 0xff03, // Word-sized access\n  SHN_HEXAGON_SCOMMON_8 = 0xff04  // Double-word-size access\n};\n\n// ELF Relocation types for Hexagon\nenum {\n#include \"ELFRelocs/Hexagon.def\"\n};\n\n// ELF Relocation type for Lanai.\nenum {\n#include \"ELFRelocs/Lanai.def\"\n};\n\n// ELF Relocation types for RISC-V\nenum {\n#include \"ELFRelocs/RISCV.def\"\n};\n\n// ELF Relocation types for S390/zSeries\nenum {\n#include \"ELFRelocs/SystemZ.def\"\n};\n\n// ELF Relocation type for Sparc.\nenum {\n#include \"ELFRelocs/Sparc.def\"\n};\n\n// ELF Relocation types for WebAssembly\nenum {\n#include \"ELFRelocs/WebAssembly.def\"\n};\n\n// ELF Relocation types for AMDGPU\nenum {\n#include \"ELFRelocs/AMDGPU.def\"\n};\n\n// ELF Relocation types for BPF\nenum {\n#include \"ELFRelocs/BPF.def\"\n};\n\n#undef ELF_RELOC\n\n// Section header.\nstruct Elf32_Shdr {\n  Elf32_Word sh_name;      // Section name (index into string table)\n  Elf32_Word sh_type;      // Section type (SHT_*)\n  Elf32_Word sh_flags;     // Section flags (SHF_*)\n  Elf32_Addr sh_addr;      // Address where section is to be loaded\n  Elf32_Off sh_offset;     // File offset of section data, in bytes\n  Elf32_Word sh_size;      // Size of section, in bytes\n  Elf32_Word sh_link;      // Section type-specific header table index link\n  Elf32_Word sh_info;      // Section type-specific extra information\n  Elf32_Word sh_addralign; // Section address alignment\n  Elf32_Word sh_entsize;   // Size of records contained within the section\n};\n\n// Section header for ELF64 - same fields as ELF32, different types.\nstruct Elf64_Shdr {\n  Elf64_Word sh_name;\n  Elf64_Word sh_type;\n  Elf64_Xword sh_flags;\n  Elf64_Addr sh_addr;\n  Elf64_Off sh_offset;\n  Elf64_Xword sh_size;\n  Elf64_Word sh_link;\n  Elf64_Word sh_info;\n  Elf64_Xword sh_addralign;\n  Elf64_Xword sh_entsize;\n};\n\n// Special section indices.\nenum {\n  SHN_UNDEF = 0,          // Undefined, missing, irrelevant, or meaningless\n  SHN_LORESERVE = 0xff00, // Lowest reserved index\n  SHN_LOPROC = 0xff00,    // Lowest processor-specific index\n  SHN_HIPROC = 0xff1f,    // Highest processor-specific index\n  SHN_LOOS = 0xff20,      // Lowest operating system-specific index\n  SHN_HIOS = 0xff3f,      // Highest operating system-specific index\n  SHN_ABS = 0xfff1,       // Symbol has absolute value; does not need relocation\n  SHN_COMMON = 0xfff2,    // FORTRAN COMMON or C external global variables\n  SHN_XINDEX = 0xffff,    // Mark that the index is >= SHN_LORESERVE\n  SHN_HIRESERVE = 0xffff  // Highest reserved index\n};\n\n// Section types.\nenum : unsigned {\n  SHT_NULL = 0,                    // No associated section (inactive entry).\n  SHT_PROGBITS = 1,                // Program-defined contents.\n  SHT_SYMTAB = 2,                  // Symbol table.\n  SHT_STRTAB = 3,                  // String table.\n  SHT_RELA = 4,                    // Relocation entries; explicit addends.\n  SHT_HASH = 5,                    // Symbol hash table.\n  SHT_DYNAMIC = 6,                 // Information for dynamic linking.\n  SHT_NOTE = 7,                    // Information about the file.\n  SHT_NOBITS = 8,                  // Data occupies no space in the file.\n  SHT_REL = 9,                     // Relocation entries; no explicit addends.\n  SHT_SHLIB = 10,                  // Reserved.\n  SHT_DYNSYM = 11,                 // Symbol table.\n  SHT_INIT_ARRAY = 14,             // Pointers to initialization functions.\n  SHT_FINI_ARRAY = 15,             // Pointers to termination functions.\n  SHT_PREINIT_ARRAY = 16,          // Pointers to pre-init functions.\n  SHT_GROUP = 17,                  // Section group.\n  SHT_SYMTAB_SHNDX = 18,           // Indices for SHN_XINDEX entries.\n  SHT_LOOS = 0x60000000,           // Lowest operating system-specific type.\n  SHT_LLVM_ODRTAB = 0x6fff4c00,    // LLVM ODR table.\n  SHT_GNU_ATTRIBUTES = 0x6ffffff5, // Object attributes.\n  SHT_GNU_HASH = 0x6ffffff6,       // GNU-style hash table.\n  SHT_GNU_verdef = 0x6ffffffd,     // GNU version definitions.\n  SHT_GNU_verneed = 0x6ffffffe,    // GNU version references.\n  SHT_GNU_versym = 0x6fffffff,     // GNU symbol versions table.\n  SHT_HIOS = 0x6fffffff,           // Highest operating system-specific type.\n  SHT_LOPROC = 0x70000000,         // Lowest processor arch-specific type.\n  // Fixme: All this is duplicated in MCSectionELF. Why??\n  // Exception Index table\n  SHT_ARM_EXIDX = 0x70000001U,\n  // BPABI DLL dynamic linking pre-emption map\n  SHT_ARM_PREEMPTMAP = 0x70000002U,\n  //  Object file compatibility attributes\n  SHT_ARM_ATTRIBUTES = 0x70000003U,\n  SHT_ARM_DEBUGOVERLAY = 0x70000004U,\n  SHT_ARM_OVERLAYSECTION = 0x70000005U,\n  SHT_HEX_ORDERED = 0x70000000,   // Link editor is to sort the entries in\n                                  // this section based on their sizes\n  SHT_X86_64_UNWIND = 0x70000001, // Unwind information\n\n  SHT_MIPS_REGINFO = 0x70000006,  // Register usage information\n  SHT_MIPS_OPTIONS = 0x7000000d,  // General options\n  SHT_MIPS_DWARF = 0x7000001e,    // DWARF debugging section.\n  SHT_MIPS_ABIFLAGS = 0x7000002a, // ABI information.\n\n  SHT_HIPROC = 0x7fffffff, // Highest processor arch-specific type.\n  SHT_LOUSER = 0x80000000, // Lowest type reserved for applications.\n  SHT_HIUSER = 0xffffffff  // Highest type reserved for applications.\n};\n\n// Section flags.\nenum : unsigned {\n  // Section data should be writable during execution.\n  SHF_WRITE = 0x1,\n\n  // Section occupies memory during program execution.\n  SHF_ALLOC = 0x2,\n\n  // Section contains executable machine instructions.\n  SHF_EXECINSTR = 0x4,\n\n  // The data in this section may be merged.\n  SHF_MERGE = 0x10,\n\n  // The data in this section is null-terminated strings.\n  SHF_STRINGS = 0x20,\n\n  // A field in this section holds a section header table index.\n  SHF_INFO_LINK = 0x40U,\n\n  // Adds special ordering requirements for link editors.\n  SHF_LINK_ORDER = 0x80U,\n\n  // This section requires special OS-specific processing to avoid incorrect\n  // behavior.\n  SHF_OS_NONCONFORMING = 0x100U,\n\n  // This section is a member of a section group.\n  SHF_GROUP = 0x200U,\n\n  // This section holds Thread-Local Storage.\n  SHF_TLS = 0x400U,\n\n  // Identifies a section containing compressed data.\n  SHF_COMPRESSED = 0x800U,\n\n  // This section is excluded from the final executable or shared library.\n  SHF_EXCLUDE = 0x80000000U,\n\n  // Start of target-specific flags.\n\n  SHF_MASKOS = 0x0ff00000,\n\n  // Bits indicating processor-specific flags.\n  SHF_MASKPROC = 0xf0000000,\n\n  /// All sections with the \"d\" flag are grouped together by the linker to form\n  /// the data section and the dp register is set to the start of the section by\n  /// the boot code.\n  XCORE_SHF_DP_SECTION = 0x10000000,\n\n  /// All sections with the \"c\" flag are grouped together by the linker to form\n  /// the constant pool and the cp register is set to the start of the constant\n  /// pool by the boot code.\n  XCORE_SHF_CP_SECTION = 0x20000000,\n\n  // If an object file section does not have this flag set, then it may not hold\n  // more than 2GB and can be freely referred to in objects using smaller code\n  // models. Otherwise, only objects using larger code models can refer to them.\n  // For example, a medium code model object can refer to data in a section that\n  // sets this flag besides being able to refer to data in a section that does\n  // not set it; likewise, a small code model object can refer only to code in a\n  // section that does not set this flag.\n  SHF_X86_64_LARGE = 0x10000000,\n\n  // All sections with the GPREL flag are grouped into a global data area\n  // for faster accesses\n  SHF_HEX_GPREL = 0x10000000,\n\n  // Section contains text/data which may be replicated in other sections.\n  // Linker must retain only one copy.\n  SHF_MIPS_NODUPES = 0x01000000,\n\n  // Linker must generate implicit hidden weak names.\n  SHF_MIPS_NAMES = 0x02000000,\n\n  // Section data local to process.\n  SHF_MIPS_LOCAL = 0x04000000,\n\n  // Do not strip this section.\n  SHF_MIPS_NOSTRIP = 0x08000000,\n\n  // Section must be part of global data area.\n  SHF_MIPS_GPREL = 0x10000000,\n\n  // This section should be merged.\n  SHF_MIPS_MERGE = 0x20000000,\n\n  // Address size to be inferred from section entry size.\n  SHF_MIPS_ADDR = 0x40000000,\n\n  // Section data is string data by default.\n  SHF_MIPS_STRING = 0x80000000,\n\n  // Make code section unreadable when in execute-only mode\n  SHF_ARM_PURECODE = 0x20000000\n};\n\n// Section Group Flags\nenum : unsigned {\n  GRP_COMDAT = 0x1,\n  GRP_MASKOS = 0x0ff00000,\n  GRP_MASKPROC = 0xf0000000\n};\n\n// Symbol table entries for ELF32.\nstruct Elf32_Sym {\n  Elf32_Word st_name;     // Symbol name (index into string table)\n  Elf32_Addr st_value;    // Value or address associated with the symbol\n  Elf32_Word st_size;     // Size of the symbol\n  unsigned char st_info;  // Symbol's type and binding attributes\n  unsigned char st_other; // Must be zero; reserved\n  Elf32_Half st_shndx;    // Which section (header table index) it's defined in\n\n  // These accessors and mutators correspond to the ELF32_ST_BIND,\n  // ELF32_ST_TYPE, and ELF32_ST_INFO macros defined in the ELF specification:\n  unsigned char getBinding() const { return st_info >> 4; }\n  unsigned char getType() const { return st_info & 0x0f; }\n  void setBinding(unsigned char b) { setBindingAndType(b, getType()); }\n  void setType(unsigned char t) { setBindingAndType(getBinding(), t); }\n  void setBindingAndType(unsigned char b, unsigned char t) {\n    st_info = (b << 4) + (t & 0x0f);\n  }\n};\n\n// Symbol table entries for ELF64.\nstruct Elf64_Sym {\n  Elf64_Word st_name;     // Symbol name (index into string table)\n  unsigned char st_info;  // Symbol's type and binding attributes\n  unsigned char st_other; // Must be zero; reserved\n  Elf64_Half st_shndx;    // Which section (header tbl index) it's defined in\n  Elf64_Addr st_value;    // Value or address associated with the symbol\n  Elf64_Xword st_size;    // Size of the symbol\n\n  // These accessors and mutators are identical to those defined for ELF32\n  // symbol table entries.\n  unsigned char getBinding() const { return st_info >> 4; }\n  unsigned char getType() const { return st_info & 0x0f; }\n  void setBinding(unsigned char b) { setBindingAndType(b, getType()); }\n  void setType(unsigned char t) { setBindingAndType(getBinding(), t); }\n  void setBindingAndType(unsigned char b, unsigned char t) {\n    st_info = (b << 4) + (t & 0x0f);\n  }\n};\n\n// The size (in bytes) of symbol table entries.\nenum {\n  SYMENTRY_SIZE32 = 16, // 32-bit symbol entry size\n  SYMENTRY_SIZE64 = 24  // 64-bit symbol entry size.\n};\n\n// Symbol bindings.\nenum {\n  STB_LOCAL = 0,  // Local symbol, not visible outside obj file containing def\n  STB_GLOBAL = 1, // Global symbol, visible to all object files being combined\n  STB_WEAK = 2,   // Weak symbol, like global but lower-precedence\n  STB_GNU_UNIQUE = 10,\n  STB_LOOS = 10,   // Lowest operating system-specific binding type\n  STB_HIOS = 12,   // Highest operating system-specific binding type\n  STB_LOPROC = 13, // Lowest processor-specific binding type\n  STB_HIPROC = 15  // Highest processor-specific binding type\n};\n\n// Symbol types.\nenum {\n  STT_NOTYPE = 0,     // Symbol's type is not specified\n  STT_OBJECT = 1,     // Symbol is a data object (variable, array, etc.)\n  STT_FUNC = 2,       // Symbol is executable code (function, etc.)\n  STT_SECTION = 3,    // Symbol refers to a section\n  STT_FILE = 4,       // Local, absolute symbol that refers to a file\n  STT_COMMON = 5,     // An uninitialized common block\n  STT_TLS = 6,        // Thread local data object\n  STT_GNU_IFUNC = 10, // GNU indirect function\n  STT_LOOS = 10,      // Lowest operating system-specific symbol type\n  STT_HIOS = 12,      // Highest operating system-specific symbol type\n  STT_LOPROC = 13,    // Lowest processor-specific symbol type\n  STT_HIPROC = 15,    // Highest processor-specific symbol type\n\n  // AMDGPU symbol types\n  STT_AMDGPU_HSA_KERNEL = 10\n};\n\nenum {\n  STV_DEFAULT = 0,  // Visibility is specified by binding type\n  STV_INTERNAL = 1, // Defined by processor supplements\n  STV_HIDDEN = 2,   // Not visible to other components\n  STV_PROTECTED = 3 // Visible in other components but not preemptable\n};\n\n// Symbol number.\nenum { STN_UNDEF = 0 };\n\n// Special relocation symbols used in the MIPS64 ELF relocation entries\nenum {\n  RSS_UNDEF = 0, // None\n  RSS_GP = 1,    // Value of gp\n  RSS_GP0 = 2,   // Value of gp used to create object being relocated\n  RSS_LOC = 3    // Address of location being relocated\n};\n\n// Relocation entry, without explicit addend.\nstruct Elf32_Rel {\n  Elf32_Addr r_offset; // Location (file byte offset, or program virtual addr)\n  Elf32_Word r_info;   // Symbol table index and type of relocation to apply\n\n  // These accessors and mutators correspond to the ELF32_R_SYM, ELF32_R_TYPE,\n  // and ELF32_R_INFO macros defined in the ELF specification:\n  Elf32_Word getSymbol() const { return (r_info >> 8); }\n  unsigned char getType() const { return (unsigned char)(r_info & 0x0ff); }\n  void setSymbol(Elf32_Word s) { setSymbolAndType(s, getType()); }\n  void setType(unsigned char t) { setSymbolAndType(getSymbol(), t); }\n  void setSymbolAndType(Elf32_Word s, unsigned char t) {\n    r_info = (s << 8) + t;\n  }\n};\n\n// Relocation entry with explicit addend.\nstruct Elf32_Rela {\n  Elf32_Addr r_offset;  // Location (file byte offset, or program virtual addr)\n  Elf32_Word r_info;    // Symbol table index and type of relocation to apply\n  Elf32_Sword r_addend; // Compute value for relocatable field by adding this\n\n  // These accessors and mutators correspond to the ELF32_R_SYM, ELF32_R_TYPE,\n  // and ELF32_R_INFO macros defined in the ELF specification:\n  Elf32_Word getSymbol() const { return (r_info >> 8); }\n  unsigned char getType() const { return (unsigned char)(r_info & 0x0ff); }\n  void setSymbol(Elf32_Word s) { setSymbolAndType(s, getType()); }\n  void setType(unsigned char t) { setSymbolAndType(getSymbol(), t); }\n  void setSymbolAndType(Elf32_Word s, unsigned char t) {\n    r_info = (s << 8) + t;\n  }\n};\n\n// Relocation entry, without explicit addend.\nstruct Elf64_Rel {\n  Elf64_Addr r_offset; // Location (file byte offset, or program virtual addr).\n  Elf64_Xword r_info;  // Symbol table index and type of relocation to apply.\n\n  // These accessors and mutators correspond to the ELF64_R_SYM, ELF64_R_TYPE,\n  // and ELF64_R_INFO macros defined in the ELF specification:\n  Elf64_Word getSymbol() const { return (r_info >> 32); }\n  Elf64_Word getType() const { return (Elf64_Word)(r_info & 0xffffffffL); }\n  void setSymbol(Elf64_Word s) { setSymbolAndType(s, getType()); }\n  void setType(Elf64_Word t) { setSymbolAndType(getSymbol(), t); }\n  void setSymbolAndType(Elf64_Word s, Elf64_Word t) {\n    r_info = ((Elf64_Xword)s << 32) + (t & 0xffffffffL);\n  }\n};\n\n// Relocation entry with explicit addend.\nstruct Elf64_Rela {\n  Elf64_Addr r_offset; // Location (file byte offset, or program virtual addr).\n  Elf64_Xword r_info;  // Symbol table index and type of relocation to apply.\n  Elf64_Sxword r_addend; // Compute value for relocatable field by adding this.\n\n  // These accessors and mutators correspond to the ELF64_R_SYM, ELF64_R_TYPE,\n  // and ELF64_R_INFO macros defined in the ELF specification:\n  Elf64_Word getSymbol() const { return (r_info >> 32); }\n  Elf64_Word getType() const { return (Elf64_Word)(r_info & 0xffffffffL); }\n  void setSymbol(Elf64_Word s) { setSymbolAndType(s, getType()); }\n  void setType(Elf64_Word t) { setSymbolAndType(getSymbol(), t); }\n  void setSymbolAndType(Elf64_Word s, Elf64_Word t) {\n    r_info = ((Elf64_Xword)s << 32) + (t & 0xffffffffL);\n  }\n};\n\n// Program header for ELF32.\nstruct Elf32_Phdr {\n  Elf32_Word p_type;   // Type of segment\n  Elf32_Off p_offset;  // File offset where segment is located, in bytes\n  Elf32_Addr p_vaddr;  // Virtual address of beginning of segment\n  Elf32_Addr p_paddr;  // Physical address of beginning of segment (OS-specific)\n  Elf32_Word p_filesz; // Num. of bytes in file image of segment (may be zero)\n  Elf32_Word p_memsz;  // Num. of bytes in mem image of segment (may be zero)\n  Elf32_Word p_flags;  // Segment flags\n  Elf32_Word p_align;  // Segment alignment constraint\n};\n\n// Program header for ELF64.\nstruct Elf64_Phdr {\n  Elf64_Word p_type;    // Type of segment\n  Elf64_Word p_flags;   // Segment flags\n  Elf64_Off p_offset;   // File offset where segment is located, in bytes\n  Elf64_Addr p_vaddr;   // Virtual address of beginning of segment\n  Elf64_Addr p_paddr;   // Physical addr of beginning of segment (OS-specific)\n  Elf64_Xword p_filesz; // Num. of bytes in file image of segment (may be zero)\n  Elf64_Xword p_memsz;  // Num. of bytes in mem image of segment (may be zero)\n  Elf64_Xword p_align;  // Segment alignment constraint\n};\n\n// Segment types.\nenum {\n  PT_NULL = 0,            // Unused segment.\n  PT_LOAD = 1,            // Loadable segment.\n  PT_DYNAMIC = 2,         // Dynamic linking information.\n  PT_INTERP = 3,          // Interpreter pathname.\n  PT_NOTE = 4,            // Auxiliary information.\n  PT_SHLIB = 5,           // Reserved.\n  PT_PHDR = 6,            // The program header table itself.\n  PT_TLS = 7,             // The thread-local storage template.\n  PT_LOOS = 0x60000000,   // Lowest operating system-specific pt entry type.\n  PT_HIOS = 0x6fffffff,   // Highest operating system-specific pt entry type.\n  PT_LOPROC = 0x70000000, // Lowest processor-specific program hdr entry type.\n  PT_HIPROC = 0x7fffffff, // Highest processor-specific program hdr entry type.\n\n  // x86-64 program header types.\n  // These all contain stack unwind tables.\n  PT_GNU_EH_FRAME = 0x6474e550,\n  PT_SUNW_EH_FRAME = 0x6474e550,\n  PT_SUNW_UNWIND = 0x6464e550,\n\n  PT_GNU_STACK = 0x6474e551, // Indicates stack executability.\n  PT_GNU_RELRO = 0x6474e552, // Read-only after relocation.\n\n  PT_OPENBSD_RANDOMIZE = 0x65a3dbe6, // Fill with random data.\n  PT_OPENBSD_WXNEEDED = 0x65a3dbe7,  // Program does W^X violations.\n  PT_OPENBSD_BOOTDATA = 0x65a41be6,  // Section for boot arguments.\n\n  // ARM program header types.\n  PT_ARM_ARCHEXT = 0x70000000, // Platform architecture compatibility info\n  // These all contain stack unwind tables.\n  PT_ARM_EXIDX = 0x70000001,\n  PT_ARM_UNWIND = 0x70000001,\n\n  // MIPS program header types.\n  PT_MIPS_REGINFO = 0x70000000,  // Register usage information.\n  PT_MIPS_RTPROC = 0x70000001,   // Runtime procedure table.\n  PT_MIPS_OPTIONS = 0x70000002,  // Options segment.\n  PT_MIPS_ABIFLAGS = 0x70000003, // Abiflags segment.\n\n  // WebAssembly program header types.\n  PT_WEBASSEMBLY_FUNCTIONS = PT_LOPROC + 0, // Function definitions.\n};\n\n// Segment flag bits.\nenum : unsigned {\n  PF_X = 1,                // Execute\n  PF_W = 2,                // Write\n  PF_R = 4,                // Read\n  PF_MASKOS = 0x0ff00000,  // Bits for operating system-specific semantics.\n  PF_MASKPROC = 0xf0000000 // Bits for processor-specific semantics.\n};\n\n// Dynamic table entry for ELF32.\nstruct Elf32_Dyn {\n  Elf32_Sword d_tag; // Type of dynamic table entry.\n  union {\n    Elf32_Word d_val; // Integer value of entry.\n    Elf32_Addr d_ptr; // Pointer value of entry.\n  } d_un;\n};\n\n// Dynamic table entry for ELF64.\nstruct Elf64_Dyn {\n  Elf64_Sxword d_tag; // Type of dynamic table entry.\n  union {\n    Elf64_Xword d_val; // Integer value of entry.\n    Elf64_Addr d_ptr;  // Pointer value of entry.\n  } d_un;\n};\n\n// Dynamic table entry tags.\nenum {\n  DT_NULL = 0,          // Marks end of dynamic array.\n  DT_NEEDED = 1,        // String table offset of needed library.\n  DT_PLTRELSZ = 2,      // Size of relocation entries in PLT.\n  DT_PLTGOT = 3,        // Address associated with linkage table.\n  DT_HASH = 4,          // Address of symbolic hash table.\n  DT_STRTAB = 5,        // Address of dynamic string table.\n  DT_SYMTAB = 6,        // Address of dynamic symbol table.\n  DT_RELA = 7,          // Address of relocation table (Rela entries).\n  DT_RELASZ = 8,        // Size of Rela relocation table.\n  DT_RELAENT = 9,       // Size of a Rela relocation entry.\n  DT_STRSZ = 10,        // Total size of the string table.\n  DT_SYMENT = 11,       // Size of a symbol table entry.\n  DT_INIT = 12,         // Address of initialization function.\n  DT_FINI = 13,         // Address of termination function.\n  DT_SONAME = 14,       // String table offset of a shared objects name.\n  DT_RPATH = 15,        // String table offset of library search path.\n  DT_SYMBOLIC = 16,     // Changes symbol resolution algorithm.\n  DT_REL = 17,          // Address of relocation table (Rel entries).\n  DT_RELSZ = 18,        // Size of Rel relocation table.\n  DT_RELENT = 19,       // Size of a Rel relocation entry.\n  DT_PLTREL = 20,       // Type of relocation entry used for linking.\n  DT_DEBUG = 21,        // Reserved for debugger.\n  DT_TEXTREL = 22,      // Relocations exist for non-writable segments.\n  DT_JMPREL = 23,       // Address of relocations associated with PLT.\n  DT_BIND_NOW = 24,     // Process all relocations before execution.\n  DT_INIT_ARRAY = 25,   // Pointer to array of initialization functions.\n  DT_FINI_ARRAY = 26,   // Pointer to array of termination functions.\n  DT_INIT_ARRAYSZ = 27, // Size of DT_INIT_ARRAY.\n  DT_FINI_ARRAYSZ = 28, // Size of DT_FINI_ARRAY.\n  DT_RUNPATH = 29,      // String table offset of lib search path.\n  DT_FLAGS = 30,        // Flags.\n  DT_ENCODING = 32,     // Values from here to DT_LOOS follow the rules\n                        // for the interpretation of the d_un union.\n\n  DT_PREINIT_ARRAY = 32,   // Pointer to array of preinit functions.\n  DT_PREINIT_ARRAYSZ = 33, // Size of the DT_PREINIT_ARRAY array.\n\n  DT_LOOS = 0x60000000,   // Start of environment specific tags.\n  DT_HIOS = 0x6FFFFFFF,   // End of environment specific tags.\n  DT_LOPROC = 0x70000000, // Start of processor specific tags.\n  DT_HIPROC = 0x7FFFFFFF, // End of processor specific tags.\n\n  DT_GNU_HASH = 0x6FFFFEF5, // Reference to the GNU hash table.\n  DT_TLSDESC_PLT =\n      0x6FFFFEF6, // Location of PLT entry for TLS descriptor resolver calls.\n  DT_TLSDESC_GOT = 0x6FFFFEF7, // Location of GOT entry used by TLS descriptor\n                               // resolver PLT entry.\n  DT_RELACOUNT = 0x6FFFFFF9,   // ELF32_Rela count.\n  DT_RELCOUNT = 0x6FFFFFFA,    // ELF32_Rel count.\n\n  DT_FLAGS_1 = 0X6FFFFFFB,    // Flags_1.\n  DT_VERSYM = 0x6FFFFFF0,     // The address of .gnu.version section.\n  DT_VERDEF = 0X6FFFFFFC,     // The address of the version definition table.\n  DT_VERDEFNUM = 0X6FFFFFFD,  // The number of entries in DT_VERDEF.\n  DT_VERNEED = 0X6FFFFFFE,    // The address of the version Dependency table.\n  DT_VERNEEDNUM = 0X6FFFFFFF, // The number of entries in DT_VERNEED.\n\n  // Hexagon specific dynamic table entries\n  DT_HEXAGON_SYMSZ = 0x70000000,\n  DT_HEXAGON_VER = 0x70000001,\n  DT_HEXAGON_PLT = 0x70000002,\n\n  // Mips specific dynamic table entry tags.\n  DT_MIPS_RLD_VERSION = 0x70000001,    // 32 bit version number for runtime\n                                       // linker interface.\n  DT_MIPS_TIME_STAMP = 0x70000002,     // Time stamp.\n  DT_MIPS_ICHECKSUM = 0x70000003,      // Checksum of external strings\n                                       // and common sizes.\n  DT_MIPS_IVERSION = 0x70000004,       // Index of version string\n                                       // in string table.\n  DT_MIPS_FLAGS = 0x70000005,          // 32 bits of flags.\n  DT_MIPS_BASE_ADDRESS = 0x70000006,   // Base address of the segment.\n  DT_MIPS_MSYM = 0x70000007,           // Address of .msym section.\n  DT_MIPS_CONFLICT = 0x70000008,       // Address of .conflict section.\n  DT_MIPS_LIBLIST = 0x70000009,        // Address of .liblist section.\n  DT_MIPS_LOCAL_GOTNO = 0x7000000a,    // Number of local global offset\n                                       // table entries.\n  DT_MIPS_CONFLICTNO = 0x7000000b,     // Number of entries\n                                       // in the .conflict section.\n  DT_MIPS_LIBLISTNO = 0x70000010,      // Number of entries\n                                       // in the .liblist section.\n  DT_MIPS_SYMTABNO = 0x70000011,       // Number of entries\n                                       // in the .dynsym section.\n  DT_MIPS_UNREFEXTNO = 0x70000012,     // Index of first external dynamic symbol\n                                       // not referenced locally.\n  DT_MIPS_GOTSYM = 0x70000013,         // Index of first dynamic symbol\n                                       // in global offset table.\n  DT_MIPS_HIPAGENO = 0x70000014,       // Number of page table entries\n                                       // in global offset table.\n  DT_MIPS_RLD_MAP = 0x70000016,        // Address of run time loader map,\n                                       // used for debugging.\n  DT_MIPS_DELTA_CLASS = 0x70000017,    // Delta C++ class definition.\n  DT_MIPS_DELTA_CLASS_NO = 0x70000018, // Number of entries\n                                       // in DT_MIPS_DELTA_CLASS.\n  DT_MIPS_DELTA_INSTANCE = 0x70000019, // Delta C++ class instances.\n  DT_MIPS_DELTA_INSTANCE_NO = 0x7000001A,     // Number of entries\n                                              // in DT_MIPS_DELTA_INSTANCE.\n  DT_MIPS_DELTA_RELOC = 0x7000001B,           // Delta relocations.\n  DT_MIPS_DELTA_RELOC_NO = 0x7000001C,        // Number of entries\n                                              // in DT_MIPS_DELTA_RELOC.\n  DT_MIPS_DELTA_SYM = 0x7000001D,             // Delta symbols that Delta\n                                              // relocations refer to.\n  DT_MIPS_DELTA_SYM_NO = 0x7000001E,          // Number of entries\n                                              // in DT_MIPS_DELTA_SYM.\n  DT_MIPS_DELTA_CLASSSYM = 0x70000020,        // Delta symbols that hold\n                                              // class declarations.\n  DT_MIPS_DELTA_CLASSSYM_NO = 0x70000021,     // Number of entries\n                                              // in DT_MIPS_DELTA_CLASSSYM.\n  DT_MIPS_CXX_FLAGS = 0x70000022,             // Flags indicating information\n                                              // about C++ flavor.\n  DT_MIPS_PIXIE_INIT = 0x70000023,            // Pixie information.\n  DT_MIPS_SYMBOL_LIB = 0x70000024,            // Address of .MIPS.symlib\n  DT_MIPS_LOCALPAGE_GOTIDX = 0x70000025,      // The GOT index of the first PTE\n                                              // for a segment\n  DT_MIPS_LOCAL_GOTIDX = 0x70000026,          // The GOT index of the first PTE\n                                              // for a local symbol\n  DT_MIPS_HIDDEN_GOTIDX = 0x70000027,         // The GOT index of the first PTE\n                                              // for a hidden symbol\n  DT_MIPS_PROTECTED_GOTIDX = 0x70000028,      // The GOT index of the first PTE\n                                              // for a protected symbol\n  DT_MIPS_OPTIONS = 0x70000029,               // Address of `.MIPS.options'.\n  DT_MIPS_INTERFACE = 0x7000002A,             // Address of `.interface'.\n  DT_MIPS_DYNSTR_ALIGN = 0x7000002B,          // Unknown.\n  DT_MIPS_INTERFACE_SIZE = 0x7000002C,        // Size of the .interface section.\n  DT_MIPS_RLD_TEXT_RESOLVE_ADDR = 0x7000002D, // Size of rld_text_resolve\n                                              // function stored in the GOT.\n  DT_MIPS_PERF_SUFFIX = 0x7000002E,  // Default suffix of DSO to be added\n                                     // by rld on dlopen() calls.\n  DT_MIPS_COMPACT_SIZE = 0x7000002F, // Size of compact relocation\n                                     // section (O32).\n  DT_MIPS_GP_VALUE = 0x70000030,     // GP value for auxiliary GOTs.\n  DT_MIPS_AUX_DYNAMIC = 0x70000031,  // Address of auxiliary .dynamic.\n  DT_MIPS_PLTGOT = 0x70000032,       // Address of the base of the PLTGOT.\n  DT_MIPS_RWPLT = 0x70000034,        // Points to the base\n                                     // of a writable PLT.\n  DT_MIPS_RLD_MAP_REL = 0x70000035,  // Relative offset of run time loader\n                                     // map, used for debugging.\n\n  // Sun machine-independent extensions.\n  DT_AUXILIARY = 0x7FFFFFFD, // Shared object to load before self\n  DT_FILTER = 0x7FFFFFFF     // Shared object to get values from\n};\n\n// DT_FLAGS values.\nenum {\n  DF_ORIGIN = 0x01,    // The object may reference $ORIGIN.\n  DF_SYMBOLIC = 0x02,  // Search the shared lib before searching the exe.\n  DF_TEXTREL = 0x04,   // Relocations may modify a non-writable segment.\n  DF_BIND_NOW = 0x08,  // Process all relocations on load.\n  DF_STATIC_TLS = 0x10 // Reject attempts to load dynamically.\n};\n\n// State flags selectable in the `d_un.d_val' element of the DT_FLAGS_1 entry.\nenum {\n  DF_1_NOW = 0x00000001,       // Set RTLD_NOW for this object.\n  DF_1_GLOBAL = 0x00000002,    // Set RTLD_GLOBAL for this object.\n  DF_1_GROUP = 0x00000004,     // Set RTLD_GROUP for this object.\n  DF_1_NODELETE = 0x00000008,  // Set RTLD_NODELETE for this object.\n  DF_1_LOADFLTR = 0x00000010,  // Trigger filtee loading at runtime.\n  DF_1_INITFIRST = 0x00000020, // Set RTLD_INITFIRST for this object.\n  DF_1_NOOPEN = 0x00000040,    // Set RTLD_NOOPEN for this object.\n  DF_1_ORIGIN = 0x00000080,    // $ORIGIN must be handled.\n  DF_1_DIRECT = 0x00000100,    // Direct binding enabled.\n  DF_1_TRANS = 0x00000200,\n  DF_1_INTERPOSE = 0x00000400,  // Object is used to interpose.\n  DF_1_NODEFLIB = 0x00000800,   // Ignore default lib search path.\n  DF_1_NODUMP = 0x00001000,     // Object can't be dldump'ed.\n  DF_1_CONFALT = 0x00002000,    // Configuration alternative created.\n  DF_1_ENDFILTEE = 0x00004000,  // Filtee terminates filters search.\n  DF_1_DISPRELDNE = 0x00008000, // Disp reloc applied at build time.\n  DF_1_DISPRELPND = 0x00010000, // Disp reloc applied at run-time.\n  DF_1_NODIRECT = 0x00020000,   // Object has no-direct binding.\n  DF_1_IGNMULDEF = 0x00040000,\n  DF_1_NOKSYMS = 0x00080000,\n  DF_1_NOHDR = 0x00100000,\n  DF_1_EDITED = 0x00200000, // Object is modified after built.\n  DF_1_NORELOC = 0x00400000,\n  DF_1_SYMINTPOSE = 0x00800000, // Object has individual interposers.\n  DF_1_GLOBAUDIT = 0x01000000,  // Global auditing required.\n  DF_1_SINGLETON = 0x02000000   // Singleton symbols are used.\n};\n\n// DT_MIPS_FLAGS values.\nenum {\n  RHF_NONE = 0x00000000,                   // No flags.\n  RHF_QUICKSTART = 0x00000001,             // Uses shortcut pointers.\n  RHF_NOTPOT = 0x00000002,                 // Hash size is not a power of two.\n  RHS_NO_LIBRARY_REPLACEMENT = 0x00000004, // Ignore LD_LIBRARY_PATH.\n  RHF_NO_MOVE = 0x00000008,                // DSO address may not be relocated.\n  RHF_SGI_ONLY = 0x00000010,               // SGI specific features.\n  RHF_GUARANTEE_INIT = 0x00000020,         // Guarantee that .init will finish\n                                           // executing before any non-init\n                                           // code in DSO is called.\n  RHF_DELTA_C_PLUS_PLUS = 0x00000040,      // Contains Delta C++ code.\n  RHF_GUARANTEE_START_INIT = 0x00000080,   // Guarantee that .init will start\n                                           // executing before any non-init\n                                           // code in DSO is called.\n  RHF_PIXIE = 0x00000100,                  // Generated by pixie.\n  RHF_DEFAULT_DELAY_LOAD = 0x00000200,     // Delay-load DSO by default.\n  RHF_REQUICKSTART = 0x00000400,           // Object may be requickstarted\n  RHF_REQUICKSTARTED = 0x00000800,         // Object has been requickstarted\n  RHF_CORD = 0x00001000,                   // Generated by cord.\n  RHF_NO_UNRES_UNDEF = 0x00002000,         // Object contains no unresolved\n                                           // undef symbols.\n  RHF_RLD_ORDER_SAFE = 0x00004000          // Symbol table is in a safe order.\n};\n\n// ElfXX_VerDef structure version (GNU versioning)\nenum { VER_DEF_NONE = 0, VER_DEF_CURRENT = 1 };\n\n// VerDef Flags (ElfXX_VerDef::vd_flags)\nenum { VER_FLG_BASE = 0x1, VER_FLG_WEAK = 0x2, VER_FLG_INFO = 0x4 };\n\n// Special constants for the version table. (SHT_GNU_versym/.gnu.version)\nenum {\n  VER_NDX_LOCAL = 0,       // Unversioned local symbol\n  VER_NDX_GLOBAL = 1,      // Unversioned global symbol\n  VERSYM_VERSION = 0x7fff, // Version Index mask\n  VERSYM_HIDDEN = 0x8000   // Hidden bit (non-default version)\n};\n\n// ElfXX_VerNeed structure version (GNU versioning)\nenum { VER_NEED_NONE = 0, VER_NEED_CURRENT = 1 };\n\n// SHT_NOTE section types\nenum {\n  NT_FREEBSD_THRMISC = 7,\n  NT_FREEBSD_PROCSTAT_PROC = 8,\n  NT_FREEBSD_PROCSTAT_FILES = 9,\n  NT_FREEBSD_PROCSTAT_VMMAP = 10,\n  NT_FREEBSD_PROCSTAT_GROUPS = 11,\n  NT_FREEBSD_PROCSTAT_UMASK = 12,\n  NT_FREEBSD_PROCSTAT_RLIMIT = 13,\n  NT_FREEBSD_PROCSTAT_OSREL = 14,\n  NT_FREEBSD_PROCSTAT_PSSTRINGS = 15,\n  NT_FREEBSD_PROCSTAT_AUXV = 16,\n};\n\nenum {\n  NT_GNU_ABI_TAG = 1,\n  NT_GNU_HWCAP = 2,\n  NT_GNU_BUILD_ID = 3,\n  NT_GNU_GOLD_VERSION = 4,\n};\n\nenum {\n  GNU_ABI_TAG_LINUX = 0,\n  GNU_ABI_TAG_HURD = 1,\n  GNU_ABI_TAG_SOLARIS = 2,\n  GNU_ABI_TAG_FREEBSD = 3,\n  GNU_ABI_TAG_NETBSD = 4,\n  GNU_ABI_TAG_SYLLABLE = 5,\n  GNU_ABI_TAG_NACL = 6,\n};\n\n// Compressed section header for ELF32.\nstruct Elf32_Chdr {\n  Elf32_Word ch_type;\n  Elf32_Word ch_size;\n  Elf32_Word ch_addralign;\n};\n\n// Compressed section header for ELF64.\nstruct Elf64_Chdr {\n  Elf64_Word ch_type;\n  Elf64_Word ch_reserved;\n  Elf64_Xword ch_size;\n  Elf64_Xword ch_addralign;\n};\n\n// Legal values for ch_type field of compressed section header.\nenum {\n  ELFCOMPRESS_ZLIB = 1,            // ZLIB/DEFLATE algorithm.\n  ELFCOMPRESS_LOOS = 0x60000000,   // Start of OS-specific.\n  ELFCOMPRESS_HIOS = 0x6fffffff,   // End of OS-specific.\n  ELFCOMPRESS_LOPROC = 0x70000000, // Start of processor-specific.\n  ELFCOMPRESS_HIPROC = 0x7fffffff  // End of processor-specific.\n};\n\n} // end namespace ELF\n} // end namespace llvm\n\n#endif // LLVM_BINARYFORMAT_ELF_H\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/include/llvm/Support/DynamicLibrary.h": "//===-- llvm/Support/DynamicLibrary.h - Portable Dynamic Library -*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the sys::DynamicLibrary class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_DYNAMICLIBRARY_H\n#define LLVM_SUPPORT_DYNAMICLIBRARY_H\n\n#include <string>\n\nnamespace llvm {\n\nclass StringRef;\n\nnamespace sys {\n\n  /// This class provides a portable interface to dynamic libraries which also\n  /// might be known as shared libraries, shared objects, dynamic shared\n  /// objects, or dynamic link libraries. Regardless of the terminology or the\n  /// operating system interface, this class provides a portable interface that\n  /// allows dynamic libraries to be loaded and searched for externally\n  /// defined symbols. This is typically used to provide \"plug-in\" support.\n  /// It also allows for symbols to be defined which don't live in any library,\n  /// but rather the main program itself, useful on Windows where the main\n  /// executable cannot be searched.\n  ///\n  /// Note: there is currently no interface for temporarily loading a library,\n  /// or for unloading libraries when the LLVM library is unloaded.\n  class DynamicLibrary {\n    // Placeholder whose address represents an invalid library.\n    // We use this instead of NULL or a pointer-int pair because the OS library\n    // might define 0 or 1 to be \"special\" handles, such as \"search all\".\n    static char Invalid;\n\n    // Opaque data used to interface with OS-specific dynamic library handling.\n    void *Data;\n\n  public:\n    explicit DynamicLibrary(void *data = &Invalid) : Data(data) {}\n\n    /// Returns true if the object refers to a valid library.\n    bool isValid() const { return Data != &Invalid; }\n\n    /// Searches through the library for the symbol \\p symbolName. If it is\n    /// found, the address of that symbol is returned. If not, NULL is returned.\n    /// Note that NULL will also be returned if the library failed to load.\n    /// Use isValid() to distinguish these cases if it is important.\n    /// Note that this will \\e not search symbols explicitly registered by\n    /// AddSymbol().\n    void *getAddressOfSymbol(const char *symbolName);\n\n    /// This function permanently loads the dynamic library at the given path.\n    /// The library will only be unloaded when llvm_shutdown() is called.\n    /// This returns a valid DynamicLibrary instance on success and an invalid\n    /// instance on failure (see isValid()). \\p *errMsg will only be modified\n    /// if the library fails to load.\n    ///\n    /// It is safe to call this function multiple times for the same library.\n    /// @brief Open a dynamic library permanently.\n    static DynamicLibrary getPermanentLibrary(const char *filename,\n                                              std::string *errMsg = nullptr);\n\n    /// Registers an externally loaded library. The library will be unloaded\n    /// when the program terminates.\n    ///\n    /// It is safe to call this function multiple times for the same library,\n    /// though ownership is only taken if there was no error.\n    ///\n    /// \\returns An empty \\p DynamicLibrary if the library was already loaded.\n    static DynamicLibrary addPermanentLibrary(void *handle,\n                                              std::string *errMsg = nullptr);\n\n    /// This function permanently loads the dynamic library at the given path.\n    /// Use this instead of getPermanentLibrary() when you won't need to get\n    /// symbols from the library itself.\n    ///\n    /// It is safe to call this function multiple times for the same library.\n    static bool LoadLibraryPermanently(const char *Filename,\n                                       std::string *ErrMsg = nullptr) {\n      return !getPermanentLibrary(Filename, ErrMsg).isValid();\n    }\n\n    enum SearchOrdering {\n      /// SO_Linker - Search as a call to dlsym(dlopen(NULL)) would when\n      /// DynamicLibrary::getPermanentLibrary(NULL) has been called or\n      /// search the list of explcitly loaded symbols if not.\n      SO_Linker,\n      /// SO_LoadedFirst - Search all loaded libraries, then as SO_Linker would.\n      SO_LoadedFirst,\n      /// SO_LoadedLast - Search as SO_Linker would, then loaded libraries.\n      /// Only useful to search if libraries with RTLD_LOCAL have been added.\n      SO_LoadedLast,\n      /// SO_LoadOrder - Or this in to search libraries in the ordered loaded.\n      /// The default bahaviour is to search loaded libraries in reverse.\n      SO_LoadOrder = 4\n    };\n    static SearchOrdering SearchOrder; // = SO_Linker\n\n    /// This function will search through all previously loaded dynamic\n    /// libraries for the symbol \\p symbolName. If it is found, the address of\n    /// that symbol is returned. If not, null is returned. Note that this will\n    /// search permanently loaded libraries (getPermanentLibrary()) as well\n    /// as explicitly registered symbols (AddSymbol()).\n    /// @throws std::string on error.\n    /// @brief Search through libraries for address of a symbol\n    static void *SearchForAddressOfSymbol(const char *symbolName);\n\n    /// @brief Convenience function for C++ophiles.\n    static void *SearchForAddressOfSymbol(const std::string &symbolName) {\n      return SearchForAddressOfSymbol(symbolName.c_str());\n    }\n\n    /// This functions permanently adds the symbol \\p symbolName with the\n    /// value \\p symbolValue.  These symbols are searched before any\n    /// libraries.\n    /// @brief Add searchable symbol/value pair.\n    static void AddSymbol(StringRef symbolName, void *symbolValue);\n\n    class HandleSet;\n  };\n\n} // End sys namespace\n} // End llvm namespace\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/include/llvm-c/LinkTimeOptimizer.h": "//===-- llvm/LinkTimeOptimizer.h - LTO Public C Interface -------*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This header provides a C API to use the LLVM link time optimization\n// library. This is intended to be used by linkers which are C-only in\n// their implementation for performing LTO.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_C_LINKTIMEOPTIMIZER_H\n#define LLVM_C_LINKTIMEOPTIMIZER_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * @defgroup LLVMCLinkTimeOptimizer Link Time Optimization\n * @ingroup LLVMC\n *\n * @{\n */\n\n  /// This provides a dummy type for pointers to the LTO object.\n  typedef void* llvm_lto_t;\n\n  /// This provides a C-visible enumerator to manage status codes.\n  /// This should map exactly onto the C++ enumerator LTOStatus.\n  typedef enum llvm_lto_status {\n    LLVM_LTO_UNKNOWN,\n    LLVM_LTO_OPT_SUCCESS,\n    LLVM_LTO_READ_SUCCESS,\n    LLVM_LTO_READ_FAILURE,\n    LLVM_LTO_WRITE_FAILURE,\n    LLVM_LTO_NO_TARGET,\n    LLVM_LTO_NO_WORK,\n    LLVM_LTO_MODULE_MERGE_FAILURE,\n    LLVM_LTO_ASM_FAILURE,\n\n    //  Added C-specific error codes\n    LLVM_LTO_NULL_OBJECT\n  } llvm_lto_status_t;\n\n  /// This provides C interface to initialize link time optimizer. This allows\n  /// linker to use dlopen() interface to dynamically load LinkTimeOptimizer.\n  /// extern \"C\" helps, because dlopen() interface uses name to find the symbol.\n  extern llvm_lto_t llvm_create_optimizer(void);\n  extern void llvm_destroy_optimizer(llvm_lto_t lto);\n\n  extern llvm_lto_status_t llvm_read_object_file\n    (llvm_lto_t lto, const char* input_filename);\n  extern llvm_lto_status_t llvm_optimize_modules\n    (llvm_lto_t lto, const char* output_filename);\n\n/**\n * @}\n */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/cmake/config-ix.cmake": "if( WIN32 AND NOT CYGWIN )\n  # We consider Cygwin as another Unix\n  set(PURE_WINDOWS 1)\nendif()\n\ninclude(CheckIncludeFile)\ninclude(CheckIncludeFileCXX)\ninclude(CheckLibraryExists)\ninclude(CheckSymbolExists)\ninclude(CheckFunctionExists)\ninclude(CheckCXXSourceCompiles)\ninclude(TestBigEndian)\n\ninclude(CheckCompilerVersion)\ninclude(HandleLLVMStdlib)\n\nif( UNIX AND NOT (BEOS OR HAIKU) )\n  # Used by check_symbol_exists:\n  set(CMAKE_REQUIRED_LIBRARIES m)\nendif()\n# x86_64 FreeBSD 9.2 requires libcxxrt to be specified explicitly.\nif( CMAKE_SYSTEM MATCHES \"FreeBSD-9.2-RELEASE\" AND\n    CMAKE_SIZEOF_VOID_P EQUAL 8 )\n  list(APPEND CMAKE_REQUIRED_LIBRARIES \"cxxrt\")\nendif()\n\n# Helper macros and functions\nmacro(add_cxx_include result files)\n  set(${result} \"\")\n  foreach (file_name ${files})\n     set(${result} \"${${result}}#include<${file_name}>\\n\")\n  endforeach()\nendmacro(add_cxx_include files result)\n\nfunction(check_type_exists type files variable)\n  add_cxx_include(includes \"${files}\")\n  CHECK_CXX_SOURCE_COMPILES(\"\n    ${includes} ${type} typeVar;\n    int main() {\n        return 0;\n    }\n    \" ${variable})\nendfunction()\n\n# include checks\ncheck_include_file(dirent.h HAVE_DIRENT_H)\ncheck_include_file(dlfcn.h HAVE_DLFCN_H)\ncheck_include_file(errno.h HAVE_ERRNO_H)\ncheck_include_file(fcntl.h HAVE_FCNTL_H)\ncheck_include_file(inttypes.h HAVE_INTTYPES_H)\ncheck_include_file(link.h HAVE_LINK_H)\ncheck_include_file(malloc.h HAVE_MALLOC_H)\ncheck_include_file(malloc/malloc.h HAVE_MALLOC_MALLOC_H)\ncheck_include_file(ndir.h HAVE_NDIR_H)\nif( NOT PURE_WINDOWS )\n  check_include_file(pthread.h HAVE_PTHREAD_H)\nendif()\ncheck_include_file(signal.h HAVE_SIGNAL_H)\ncheck_include_file(stdint.h HAVE_STDINT_H)\ncheck_include_file(sys/dir.h HAVE_SYS_DIR_H)\ncheck_include_file(sys/ioctl.h HAVE_SYS_IOCTL_H)\ncheck_include_file(sys/mman.h HAVE_SYS_MMAN_H)\ncheck_include_file(sys/ndir.h HAVE_SYS_NDIR_H)\ncheck_include_file(sys/param.h HAVE_SYS_PARAM_H)\ncheck_include_file(sys/resource.h HAVE_SYS_RESOURCE_H)\ncheck_include_file(sys/stat.h HAVE_SYS_STAT_H)\ncheck_include_file(sys/time.h HAVE_SYS_TIME_H)\ncheck_include_file(sys/types.h HAVE_SYS_TYPES_H)\ncheck_include_file(sys/uio.h HAVE_SYS_UIO_H)\ncheck_include_file(termios.h HAVE_TERMIOS_H)\ncheck_include_file(unistd.h HAVE_UNISTD_H)\ncheck_include_file(valgrind/valgrind.h HAVE_VALGRIND_VALGRIND_H)\ncheck_include_file(zlib.h HAVE_ZLIB_H)\ncheck_include_file(fenv.h HAVE_FENV_H)\ncheck_symbol_exists(FE_ALL_EXCEPT \"fenv.h\" HAVE_DECL_FE_ALL_EXCEPT)\ncheck_symbol_exists(FE_INEXACT \"fenv.h\" HAVE_DECL_FE_INEXACT)\n\ncheck_include_file(mach/mach.h HAVE_MACH_MACH_H)\ncheck_include_file(histedit.h HAVE_HISTEDIT_H)\ncheck_include_file(CrashReporterClient.h HAVE_CRASHREPORTERCLIENT_H)\nif(APPLE)\n  include(CheckCSourceCompiles)\n  CHECK_C_SOURCE_COMPILES(\"\n     static const char *__crashreporter_info__ = 0;\n     asm(\\\".desc ___crashreporter_info__, 0x10\\\");\n     int main() { return 0; }\"\n    HAVE_CRASHREPORTER_INFO)\nendif()\n\nif(${CMAKE_SYSTEM_NAME} STREQUAL \"Linux\")\n  check_include_file(linux/magic.h HAVE_LINUX_MAGIC_H)\n  if(NOT HAVE_LINUX_MAGIC_H)\n    # older kernels use split files\n    check_include_file(linux/nfs_fs.h HAVE_LINUX_NFS_FS_H)\n    check_include_file(linux/smb.h HAVE_LINUX_SMB_H)\n  endif()\nendif()\n\n# library checks\nif( NOT PURE_WINDOWS )\n  check_library_exists(pthread pthread_create \"\" HAVE_LIBPTHREAD)\n  if (HAVE_LIBPTHREAD)\n    check_library_exists(pthread pthread_getspecific \"\" HAVE_PTHREAD_GETSPECIFIC)\n    check_library_exists(pthread pthread_rwlock_init \"\" HAVE_PTHREAD_RWLOCK_INIT)\n    check_library_exists(pthread pthread_mutex_lock \"\" HAVE_PTHREAD_MUTEX_LOCK)\n  else()\n    # this could be Android\n    check_library_exists(c pthread_create \"\" PTHREAD_IN_LIBC)\n    if (PTHREAD_IN_LIBC)\n      check_library_exists(c pthread_getspecific \"\" HAVE_PTHREAD_GETSPECIFIC)\n      check_library_exists(c pthread_rwlock_init \"\" HAVE_PTHREAD_RWLOCK_INIT)\n      check_library_exists(c pthread_mutex_lock \"\" HAVE_PTHREAD_MUTEX_LOCK)\n    endif()\n  endif()\n  check_library_exists(dl dlopen \"\" HAVE_LIBDL)\n  check_library_exists(rt clock_gettime \"\" HAVE_LIBRT)\nendif()\n\nif(HAVE_LIBPTHREAD)\n  # We want to find pthreads library and at the moment we do want to\n  # have it reported as '-l<lib>' instead of '-pthread'.\n  # TODO: switch to -pthread once the rest of the build system can deal with it.\n  set(CMAKE_THREAD_PREFER_PTHREAD TRUE)\n  set(THREADS_HAVE_PTHREAD_ARG Off)\n  find_package(Threads REQUIRED)\n  set(LLVM_PTHREAD_LIB ${CMAKE_THREAD_LIBS_INIT})\nendif()\n\n# Don't look for these libraries on Windows. Also don't look for them if we're\n# using MSan, since uninstrumented third party code may call MSan interceptors\n# like strlen, leading to false positives.\nif( NOT PURE_WINDOWS AND NOT LLVM_USE_SANITIZER MATCHES \"Memory.*\")\n  if (LLVM_ENABLE_ZLIB)\n    find_package(ZLIB REQUIRED)\n    #check_library_exists(${ZLIB_LIBRARY} compress2 \"\" HAVE_LIBZ)\n    if (ZLIB_FOUND)\n      set(HAVE_LIBZ 1)\n    endif()\n  else()\n    set(HAVE_LIBZ 0)\n  endif()\n  # Skip libedit if using ASan as it contains memory leaks.\n  if (LLVM_ENABLE_LIBEDIT AND HAVE_HISTEDIT_H AND NOT LLVM_USE_SANITIZER MATCHES \".*Address.*\")\n    check_library_exists(edit el_init \"\" HAVE_LIBEDIT)\n  else()\n    set(HAVE_LIBEDIT 0)\n  endif()\n  if(LLVM_ENABLE_TERMINFO)\n    set(HAVE_TERMINFO 0)\n    foreach(library tinfo terminfo curses ncurses ncursesw)\n      string(TOUPPER ${library} library_suffix)\n      check_library_exists(${library} setupterm \"\" HAVE_TERMINFO_${library_suffix})\n      if(HAVE_TERMINFO_${library_suffix})\n        set(HAVE_TERMINFO 1)\n        set(TERMINFO_LIBS \"${library}\")\n        break()\n      endif()\n    endforeach()\n  else()\n    set(HAVE_TERMINFO 0)\n  endif()\nendif()\n\ncheck_library_exists(xar xar_open \"\" HAVE_LIBXAR)\nif(HAVE_LIBXAR)\n  set(XAR_LIB xar)\nendif()\n\n# function checks\ncheck_symbol_exists(arc4random \"stdlib.h\" HAVE_DECL_ARC4RANDOM)\nfind_package(Backtrace)\nset(HAVE_BACKTRACE ${Backtrace_FOUND})\nset(BACKTRACE_HEADER ${Backtrace_HEADER})\ncheck_symbol_exists(_Unwind_Backtrace \"unwind.h\" HAVE__UNWIND_BACKTRACE)\ncheck_symbol_exists(getpagesize unistd.h HAVE_GETPAGESIZE)\ncheck_symbol_exists(sysconf unistd.h HAVE_SYSCONF)\ncheck_symbol_exists(getrusage sys/resource.h HAVE_GETRUSAGE)\ncheck_symbol_exists(setrlimit sys/resource.h HAVE_SETRLIMIT)\ncheck_symbol_exists(isatty unistd.h HAVE_ISATTY)\ncheck_symbol_exists(futimens sys/stat.h HAVE_FUTIMENS)\ncheck_symbol_exists(futimes sys/time.h HAVE_FUTIMES)\ncheck_symbol_exists(posix_fallocate fcntl.h HAVE_POSIX_FALLOCATE)\n# AddressSanitizer conflicts with lib/Support/Unix/Signals.inc\n# Avoid sigaltstack on Apple platforms, where backtrace() cannot handle it\n# (rdar://7089625) and _Unwind_Backtrace is unusable because it cannot unwind\n# past the signal handler after an assertion failure (rdar://29866587).\nif( HAVE_SIGNAL_H AND NOT LLVM_USE_SANITIZER MATCHES \".*Address.*\" AND NOT APPLE )\n  check_symbol_exists(sigaltstack signal.h HAVE_SIGALTSTACK)\nendif()\nif( HAVE_SYS_UIO_H )\n  check_symbol_exists(writev sys/uio.h HAVE_WRITEV)\nendif()\nset(CMAKE_REQUIRED_DEFINITIONS \"-D_LARGEFILE64_SOURCE\")\ncheck_symbol_exists(lseek64 \"sys/types.h;unistd.h\" HAVE_LSEEK64)\nset(CMAKE_REQUIRED_DEFINITIONS \"\")\ncheck_symbol_exists(mallctl malloc_np.h HAVE_MALLCTL)\ncheck_symbol_exists(mallinfo malloc.h HAVE_MALLINFO)\ncheck_symbol_exists(malloc_zone_statistics malloc/malloc.h\n                    HAVE_MALLOC_ZONE_STATISTICS)\ncheck_symbol_exists(mkdtemp \"stdlib.h;unistd.h\" HAVE_MKDTEMP)\ncheck_symbol_exists(mkstemp \"stdlib.h;unistd.h\" HAVE_MKSTEMP)\ncheck_symbol_exists(mktemp \"stdlib.h;unistd.h\" HAVE_MKTEMP)\ncheck_symbol_exists(getcwd unistd.h HAVE_GETCWD)\ncheck_symbol_exists(gettimeofday sys/time.h HAVE_GETTIMEOFDAY)\ncheck_symbol_exists(getrlimit \"sys/types.h;sys/time.h;sys/resource.h\" HAVE_GETRLIMIT)\ncheck_symbol_exists(posix_spawn spawn.h HAVE_POSIX_SPAWN)\ncheck_symbol_exists(pread unistd.h HAVE_PREAD)\ncheck_symbol_exists(realpath stdlib.h HAVE_REALPATH)\ncheck_symbol_exists(sbrk unistd.h HAVE_SBRK)\ncheck_symbol_exists(strtoll stdlib.h HAVE_STRTOLL)\ncheck_symbol_exists(strerror string.h HAVE_STRERROR)\ncheck_symbol_exists(strerror_r string.h HAVE_STRERROR_R)\ncheck_symbol_exists(strerror_s string.h HAVE_DECL_STRERROR_S)\ncheck_symbol_exists(setenv stdlib.h HAVE_SETENV)\nif( PURE_WINDOWS )\n  check_symbol_exists(_chsize_s io.h HAVE__CHSIZE_S)\n\n  check_function_exists(_alloca HAVE__ALLOCA)\n  check_function_exists(__alloca HAVE___ALLOCA)\n  check_function_exists(__chkstk HAVE___CHKSTK)\n  check_function_exists(__chkstk_ms HAVE___CHKSTK_MS)\n  check_function_exists(___chkstk HAVE____CHKSTK)\n  check_function_exists(___chkstk_ms HAVE____CHKSTK_MS)\n\n  check_function_exists(__ashldi3 HAVE___ASHLDI3)\n  check_function_exists(__ashrdi3 HAVE___ASHRDI3)\n  check_function_exists(__divdi3 HAVE___DIVDI3)\n  check_function_exists(__fixdfdi HAVE___FIXDFDI)\n  check_function_exists(__fixsfdi HAVE___FIXSFDI)\n  check_function_exists(__floatdidf HAVE___FLOATDIDF)\n  check_function_exists(__lshrdi3 HAVE___LSHRDI3)\n  check_function_exists(__moddi3 HAVE___MODDI3)\n  check_function_exists(__udivdi3 HAVE___UDIVDI3)\n  check_function_exists(__umoddi3 HAVE___UMODDI3)\n\n  check_function_exists(__main HAVE___MAIN)\n  check_function_exists(__cmpdi2 HAVE___CMPDI2)\nendif()\nif( HAVE_DLFCN_H )\n  if( HAVE_LIBDL )\n    list(APPEND CMAKE_REQUIRED_LIBRARIES dl)\n  endif()\n  check_symbol_exists(dlopen dlfcn.h HAVE_DLOPEN)\n  check_symbol_exists(dladdr dlfcn.h HAVE_DLADDR)\n  if( HAVE_LIBDL )\n    list(REMOVE_ITEM CMAKE_REQUIRED_LIBRARIES dl)\n  endif()\nendif()\n\ncheck_symbol_exists(__GLIBC__ stdio.h LLVM_USING_GLIBC)\nif( LLVM_USING_GLIBC )\n  add_definitions( -D_GNU_SOURCE )\nendif()\n# This check requires _GNU_SOURCE\nif(HAVE_LIBPTHREAD)\n  check_library_exists(pthread pthread_getname_np \"\" HAVE_PTHREAD_GETNAME_NP)\n  check_library_exists(pthread pthread_setname_np \"\" HAVE_PTHREAD_SETNAME_NP)\nelseif(PTHREAD_IN_LIBC)\n  check_library_exists(c pthread_getname_np \"\" HAVE_PTHREAD_GETNAME_NP)\n  check_library_exists(c pthread_setname_np \"\" HAVE_PTHREAD_SETNAME_NP)\nendif()\n\nset(headers \"sys/types.h\")\n\nif (HAVE_INTTYPES_H)\n  set(headers ${headers} \"inttypes.h\")\nendif()\n\nif (HAVE_STDINT_H)\n  set(headers ${headers} \"stdint.h\")\nendif()\n\ncheck_type_exists(int64_t \"${headers}\" HAVE_INT64_T)\ncheck_type_exists(uint64_t \"${headers}\" HAVE_UINT64_T)\ncheck_type_exists(u_int64_t \"${headers}\" HAVE_U_INT64_T)\n\n# available programs checks\nfunction(llvm_find_program name)\n  string(TOUPPER ${name} NAME)\n  string(REGEX REPLACE \"\\\\.\" \"_\" NAME ${NAME})\n\n  find_program(LLVM_PATH_${NAME} NAMES ${ARGV})\n  mark_as_advanced(LLVM_PATH_${NAME})\n  if(LLVM_PATH_${NAME})\n    set(HAVE_${NAME} 1 CACHE INTERNAL \"Is ${name} available ?\")\n    mark_as_advanced(HAVE_${NAME})\n  else(LLVM_PATH_${NAME})\n    set(HAVE_${NAME} \"\" CACHE INTERNAL \"Is ${name} available ?\")\n  endif(LLVM_PATH_${NAME})\nendfunction()\n\nif (LLVM_ENABLE_DOXYGEN)\n  llvm_find_program(dot)\nendif ()\n\nif( LLVM_ENABLE_FFI )\n  find_path(FFI_INCLUDE_PATH ffi.h PATHS ${FFI_INCLUDE_DIR})\n  if( EXISTS \"${FFI_INCLUDE_PATH}/ffi.h\" )\n    set(FFI_HEADER ffi.h CACHE INTERNAL \"\")\n    set(HAVE_FFI_H 1 CACHE INTERNAL \"\")\n  else()\n    find_path(FFI_INCLUDE_PATH ffi/ffi.h PATHS ${FFI_INCLUDE_DIR})\n    if( EXISTS \"${FFI_INCLUDE_PATH}/ffi/ffi.h\" )\n      set(FFI_HEADER ffi/ffi.h CACHE INTERNAL \"\")\n      set(HAVE_FFI_FFI_H 1 CACHE INTERNAL \"\")\n    endif()\n  endif()\n\n  if( NOT FFI_HEADER )\n    message(FATAL_ERROR \"libffi includes are not found.\")\n  endif()\n\n  find_library(FFI_LIBRARY_PATH ffi PATHS ${FFI_LIBRARY_DIR})\n  if( NOT FFI_LIBRARY_PATH )\n    message(FATAL_ERROR \"libffi is not found.\")\n  endif()\n\n  list(APPEND CMAKE_REQUIRED_LIBRARIES ${FFI_LIBRARY_PATH})\n  list(APPEND CMAKE_REQUIRED_INCLUDES ${FFI_INCLUDE_PATH})\n  check_symbol_exists(ffi_call ${FFI_HEADER} HAVE_FFI_CALL)\n  list(REMOVE_ITEM CMAKE_REQUIRED_INCLUDES ${FFI_INCLUDE_PATH})\n  list(REMOVE_ITEM CMAKE_REQUIRED_LIBRARIES ${FFI_LIBRARY_PATH})\nelse()\n  unset(HAVE_FFI_FFI_H CACHE)\n  unset(HAVE_FFI_H CACHE)\n  unset(HAVE_FFI_CALL CACHE)\nendif( LLVM_ENABLE_FFI )\n\n# Define LLVM_HAS_ATOMICS if gcc or MSVC atomic builtins are supported.\ninclude(CheckAtomic)\n\nif( LLVM_ENABLE_PIC )\n  set(ENABLE_PIC 1)\nelse()\n  set(ENABLE_PIC 0)\n  check_cxx_compiler_flag(\"-fno-pie\" SUPPORTS_NO_PIE_FLAG)\n  if(SUPPORTS_NO_PIE_FLAG)\n    set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -fno-pie\")\n  endif()\nendif()\n\ncheck_cxx_compiler_flag(\"-Wvariadic-macros\" SUPPORTS_VARIADIC_MACROS_FLAG)\ncheck_cxx_compiler_flag(\"-Wgnu-zero-variadic-macro-arguments\"\n                        SUPPORTS_GNU_ZERO_VARIADIC_MACRO_ARGUMENTS_FLAG)\n\nset(USE_NO_MAYBE_UNINITIALIZED 0)\nset(USE_NO_UNINITIALIZED 0)\n\n# Disable gcc's potentially uninitialized use analysis as it presents lots of\n# false positives.\nif (CMAKE_COMPILER_IS_GNUCXX)\n  check_cxx_compiler_flag(\"-Wmaybe-uninitialized\" HAS_MAYBE_UNINITIALIZED)\n  if (HAS_MAYBE_UNINITIALIZED)\n    set(USE_NO_MAYBE_UNINITIALIZED 1)\n  else()\n    # Only recent versions of gcc make the distinction between -Wuninitialized\n    # and -Wmaybe-uninitialized. If -Wmaybe-uninitialized isn't supported, just\n    # turn off all uninitialized use warnings.\n    check_cxx_compiler_flag(\"-Wuninitialized\" HAS_UNINITIALIZED)\n    set(USE_NO_UNINITIALIZED ${HAS_UNINITIALIZED})\n  endif()\nendif()\n\n# By default, we target the host, but this can be overridden at CMake\n# invocation time.\ninclude(GetHostTriple)\nget_host_triple(LLVM_INFERRED_HOST_TRIPLE)\n\nset(LLVM_HOST_TRIPLE \"${LLVM_INFERRED_HOST_TRIPLE}\" CACHE STRING\n    \"Host on which LLVM binaries will run\")\n\n# Determine the native architecture.\nstring(TOLOWER \"${LLVM_TARGET_ARCH}\" LLVM_NATIVE_ARCH)\nif( LLVM_NATIVE_ARCH STREQUAL \"host\" )\n  string(REGEX MATCH \"^[^-]*\" LLVM_NATIVE_ARCH ${LLVM_HOST_TRIPLE})\nendif ()\n\nif (LLVM_NATIVE_ARCH MATCHES \"i[2-6]86\")\n  set(LLVM_NATIVE_ARCH X86)\nelseif (LLVM_NATIVE_ARCH STREQUAL \"x86\")\n  set(LLVM_NATIVE_ARCH X86)\nelseif (LLVM_NATIVE_ARCH STREQUAL \"amd64\")\n  set(LLVM_NATIVE_ARCH X86)\nelseif (LLVM_NATIVE_ARCH STREQUAL \"x86_64\")\n  set(LLVM_NATIVE_ARCH X86)\nelseif (LLVM_NATIVE_ARCH MATCHES \"sparc\")\n  set(LLVM_NATIVE_ARCH Sparc)\nelseif (LLVM_NATIVE_ARCH MATCHES \"powerpc\")\n  set(LLVM_NATIVE_ARCH PowerPC)\nelseif (LLVM_NATIVE_ARCH MATCHES \"aarch64\")\n  set(LLVM_NATIVE_ARCH AArch64)\nelseif (LLVM_NATIVE_ARCH MATCHES \"arm64\")\n  set(LLVM_NATIVE_ARCH AArch64)\nelseif (LLVM_NATIVE_ARCH MATCHES \"arm\")\n  set(LLVM_NATIVE_ARCH ARM)\nelseif (LLVM_NATIVE_ARCH MATCHES \"mips\")\n  set(LLVM_NATIVE_ARCH Mips)\nelseif (LLVM_NATIVE_ARCH MATCHES \"xcore\")\n  set(LLVM_NATIVE_ARCH XCore)\nelseif (LLVM_NATIVE_ARCH MATCHES \"msp430\")\n  set(LLVM_NATIVE_ARCH MSP430)\nelseif (LLVM_NATIVE_ARCH MATCHES \"hexagon\")\n  set(LLVM_NATIVE_ARCH Hexagon)\nelseif (LLVM_NATIVE_ARCH MATCHES \"s390x\")\n  set(LLVM_NATIVE_ARCH SystemZ)\nelseif (LLVM_NATIVE_ARCH MATCHES \"wasm32\")\n  set(LLVM_NATIVE_ARCH WebAssembly)\nelseif (LLVM_NATIVE_ARCH MATCHES \"wasm64\")\n  set(LLVM_NATIVE_ARCH WebAssembly)\nelse ()\n  message(FATAL_ERROR \"Unknown architecture ${LLVM_NATIVE_ARCH}\")\nendif ()\n\n# If build targets includes \"host\", then replace with native architecture.\nlist(FIND LLVM_TARGETS_TO_BUILD \"host\" idx)\nif( NOT idx LESS 0 )\n  list(REMOVE_AT LLVM_TARGETS_TO_BUILD ${idx})\n  list(APPEND LLVM_TARGETS_TO_BUILD ${LLVM_NATIVE_ARCH})\n  list(REMOVE_DUPLICATES LLVM_TARGETS_TO_BUILD)\nendif()\n\nlist(FIND LLVM_TARGETS_TO_BUILD ${LLVM_NATIVE_ARCH} NATIVE_ARCH_IDX)\nif (NATIVE_ARCH_IDX EQUAL -1)\n  message(STATUS\n    \"Native target ${LLVM_NATIVE_ARCH} is not selected; lli will not JIT code\")\nelse ()\n  message(STATUS \"Native target architecture is ${LLVM_NATIVE_ARCH}\")\n  set(LLVM_NATIVE_TARGET LLVMInitialize${LLVM_NATIVE_ARCH}Target)\n  set(LLVM_NATIVE_TARGETINFO LLVMInitialize${LLVM_NATIVE_ARCH}TargetInfo)\n  set(LLVM_NATIVE_TARGETMC LLVMInitialize${LLVM_NATIVE_ARCH}TargetMC)\n  set(LLVM_NATIVE_ASMPRINTER LLVMInitialize${LLVM_NATIVE_ARCH}AsmPrinter)\n\n  # We don't have an ASM parser for all architectures yet.\n  if (EXISTS ${PROJECT_SOURCE_DIR}/lib/Target/${LLVM_NATIVE_ARCH}/AsmParser/CMakeLists.txt)\n    set(LLVM_NATIVE_ASMPARSER LLVMInitialize${LLVM_NATIVE_ARCH}AsmParser)\n  endif ()\n\n  # We don't have an disassembler for all architectures yet.\n  if (EXISTS ${PROJECT_SOURCE_DIR}/lib/Target/${LLVM_NATIVE_ARCH}/Disassembler/CMakeLists.txt)\n    set(LLVM_NATIVE_DISASSEMBLER LLVMInitialize${LLVM_NATIVE_ARCH}Disassembler)\n  endif ()\nendif ()\n\nif( MINGW )\n  set(HAVE_LIBPSAPI 1)\n  set(HAVE_LIBSHELL32 1)\n  # TODO: Check existence of libraries.\n  #   include(CheckLibraryExists)\nendif( MINGW )\n\nif (NOT HAVE_STRTOLL)\n  # Use _strtoi64 if strtoll is not available.\n  check_symbol_exists(_strtoi64 stdlib.h have_strtoi64)\n  if (have_strtoi64)\n    set(HAVE_STRTOLL 1)\n    set(strtoll \"_strtoi64\")\n    set(strtoull \"_strtoui64\")\n  endif ()\nendif ()\n\nif( MSVC )\n  set(SHLIBEXT \".lib\")\n  set(stricmp \"_stricmp\")\n  set(strdup \"_strdup\")\n\n  # See if the DIA SDK is available and usable.\n  set(MSVC_DIA_SDK_DIR \"$ENV{VSINSTALLDIR}DIA SDK\")\n\n  # Due to a bug in MSVC 2013's installation software, it is possible\n  # for MSVC 2013 to write the DIA SDK into the Visual Studio 2012\n  # install directory.  If this happens, the installation is corrupt\n  # and there's nothing we can do.  It happens with enough frequency\n  # though that we should handle it.  We do so by simply checking that\n  # the DIA SDK folder exists.  Should this happen you will need to\n  # uninstall VS 2012 and then re-install VS 2013.\n  if (IS_DIRECTORY ${MSVC_DIA_SDK_DIR})\n    set(HAVE_DIA_SDK 1)\n  else()\n    set(HAVE_DIA_SDK 0)\n  endif()\n\n  option(LLVM_ENABLE_DIA_SDK \"Use MSVC DIA SDK for debugging if available.\"\n                             ${HAVE_DIA_SDK})\n\n  if(LLVM_ENABLE_DIA_SDK AND NOT HAVE_DIA_SDK)\n    message(FATAL_ERROR \"DIA SDK not found. If you have both VS 2012 and 2013 installed, you may need to uninstall the former and re-install the latter afterwards.\")\n  endif()\nelse()\n  set(LLVM_ENABLE_DIA_SDK 0)\nendif( MSVC )\n\n# FIXME: Signal handler return type, currently hardcoded to 'void'\nset(RETSIGTYPE void)\n\nif( LLVM_ENABLE_THREADS )\n  # Check if threading primitives aren't supported on this platform\n  if( NOT HAVE_PTHREAD_H AND NOT WIN32 )\n    set(LLVM_ENABLE_THREADS 0)\n  endif()\nendif()\n\nif( LLVM_ENABLE_THREADS )\n  message(STATUS \"Threads enabled.\")\nelse( LLVM_ENABLE_THREADS )\n  message(STATUS \"Threads disabled.\")\nendif()\n\nif (LLVM_ENABLE_ZLIB )\n  # Check if zlib is available in the system.\n  if ( NOT HAVE_ZLIB_H OR NOT HAVE_LIBZ )\n    set(LLVM_ENABLE_ZLIB 0)\n  endif()\nendif()\n\nif (LLVM_ENABLE_DOXYGEN)\n  message(STATUS \"Doxygen enabled.\")\n  find_package(Doxygen REQUIRED)\n\n  if (DOXYGEN_FOUND)\n    # If we find doxygen and we want to enable doxygen by default create a\n    # global aggregate doxygen target for generating llvm and any/all\n    # subprojects doxygen documentation.\n    if (LLVM_BUILD_DOCS)\n      add_custom_target(doxygen ALL)\n    endif()\n\n    option(LLVM_DOXYGEN_EXTERNAL_SEARCH \"Enable doxygen external search.\" OFF)\n    if (LLVM_DOXYGEN_EXTERNAL_SEARCH)\n      set(LLVM_DOXYGEN_SEARCHENGINE_URL \"\" CACHE STRING \"URL to use for external search.\")\n      set(LLVM_DOXYGEN_SEARCH_MAPPINGS \"\" CACHE STRING \"Doxygen Search Mappings\")\n    endif()\n  endif()\nelse()\n  message(STATUS \"Doxygen disabled.\")\nendif()\n\nset(LLVM_BINDINGS \"\")\nif(WIN32)\n  message(STATUS \"Go bindings disabled.\")\nelse()\n  find_program(GO_EXECUTABLE NAMES go DOC \"go executable\")\n  if(GO_EXECUTABLE STREQUAL \"GO_EXECUTABLE-NOTFOUND\")\n    message(STATUS \"Go bindings disabled.\")\n  else()\n    execute_process(COMMAND ${GO_EXECUTABLE} run ${PROJECT_SOURCE_DIR}/bindings/go/conftest.go\n                    RESULT_VARIABLE GO_CONFTEST)\n    if(GO_CONFTEST STREQUAL \"0\")\n      set(LLVM_BINDINGS \"${LLVM_BINDINGS} go\")\n      message(STATUS \"Go bindings enabled.\")\n    else()\n      message(STATUS \"Go bindings disabled, need at least Go 1.2.\")\n    endif()\n  endif()\nendif()\n\nfind_program(GOLD_EXECUTABLE NAMES ${LLVM_DEFAULT_TARGET_TRIPLE}-ld.gold ld.gold ${LLVM_DEFAULT_TARGET_TRIPLE}-ld ld DOC \"The gold linker\")\nset(LLVM_BINUTILS_INCDIR \"\" CACHE PATH\n\t\"PATH to binutils/include containing plugin-api.h for gold plugin.\")\n\nif(CMAKE_HOST_APPLE AND APPLE)\n  if(NOT CMAKE_XCRUN)\n    find_program(CMAKE_XCRUN NAMES xcrun)\n  endif()\n  if(CMAKE_XCRUN)\n    execute_process(COMMAND ${CMAKE_XCRUN} -find ld\n      OUTPUT_VARIABLE LD64_EXECUTABLE\n      OUTPUT_STRIP_TRAILING_WHITESPACE)\n  else()\n    find_program(LD64_EXECUTABLE NAMES ld DOC \"The ld64 linker\")\n  endif()\n\n  if(LD64_EXECUTABLE)\n    set(LD64_EXECUTABLE ${LD64_EXECUTABLE} CACHE PATH \"ld64 executable\")\n    message(STATUS \"Found ld64 - ${LD64_EXECUTABLE}\")\n  endif()\nendif()\n\nstring(REPLACE \" \" \";\" LLVM_BINDINGS_LIST \"${LLVM_BINDINGS}\")\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp": "//== GenericTaintChecker.cpp ----------------------------------- -*- C++ -*--=//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This checker defines the attack surface for generic taint propagation.\n//\n// The taint information produced by it might be useful to other checkers. For\n// example, checkers should report errors which involve tainted data more\n// aggressively, even if the involved symbols are under constrained.\n//\n//===----------------------------------------------------------------------===//\n#include \"ClangSACheckers.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/Basic/Builtins.h\"\n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/CheckerManager.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include <climits>\n\nusing namespace clang;\nusing namespace ento;\n\nnamespace {\nclass GenericTaintChecker : public Checker< check::PostStmt<CallExpr>,\n                                            check::PreStmt<CallExpr> > {\npublic:\n  static void *getTag() { static int Tag; return &Tag; }\n\n  void checkPostStmt(const CallExpr *CE, CheckerContext &C) const;\n\n  void checkPreStmt(const CallExpr *CE, CheckerContext &C) const;\n\nprivate:\n  static const unsigned InvalidArgIndex = UINT_MAX;\n  /// Denotes the return vale.\n  static const unsigned ReturnValueIndex = UINT_MAX - 1;\n\n  mutable std::unique_ptr<BugType> BT;\n  inline void initBugType() const {\n    if (!BT)\n      BT.reset(new BugType(this, \"Use of Untrusted Data\", \"Untrusted Data\"));\n  }\n\n  /// \\brief Catch taint related bugs. Check if tainted data is passed to a\n  /// system call etc.\n  bool checkPre(const CallExpr *CE, CheckerContext &C) const;\n\n  /// \\brief Add taint sources on a pre-visit.\n  void addSourcesPre(const CallExpr *CE, CheckerContext &C) const;\n\n  /// \\brief Propagate taint generated at pre-visit.\n  bool propagateFromPre(const CallExpr *CE, CheckerContext &C) const;\n\n  /// \\brief Add taint sources on a post visit.\n  void addSourcesPost(const CallExpr *CE, CheckerContext &C) const;\n\n  /// Check if the region the expression evaluates to is the standard input,\n  /// and thus, is tainted.\n  static bool isStdin(const Expr *E, CheckerContext &C);\n\n  /// \\brief Given a pointer argument, return the value it points to.\n  static Optional<SVal> getPointedToSVal(CheckerContext &C, const Expr *Arg);\n\n  /// Functions defining the attack surface.\n  typedef ProgramStateRef (GenericTaintChecker::*FnCheck)(const CallExpr *,\n                                                       CheckerContext &C) const;\n  ProgramStateRef postScanf(const CallExpr *CE, CheckerContext &C) const;\n  ProgramStateRef postSocket(const CallExpr *CE, CheckerContext &C) const;\n  ProgramStateRef postRetTaint(const CallExpr *CE, CheckerContext &C) const;\n\n  /// Taint the scanned input if the file is tainted.\n  ProgramStateRef preFscanf(const CallExpr *CE, CheckerContext &C) const;\n\n  /// Check for CWE-134: Uncontrolled Format String.\n  static const char MsgUncontrolledFormatString[];\n  bool checkUncontrolledFormatString(const CallExpr *CE,\n                                     CheckerContext &C) const;\n\n  /// Check for:\n  /// CERT/STR02-C. \"Sanitize data passed to complex subsystems\"\n  /// CWE-78, \"Failure to Sanitize Data into an OS Command\"\n  static const char MsgSanitizeSystemArgs[];\n  bool checkSystemCall(const CallExpr *CE, StringRef Name,\n                       CheckerContext &C) const;\n\n  /// Check if tainted data is used as a buffer size ins strn.. functions,\n  /// and allocators.\n  static const char MsgTaintedBufferSize[];\n  bool checkTaintedBufferSize(const CallExpr *CE, const FunctionDecl *FDecl,\n                              CheckerContext &C) const;\n\n  /// Generate a report if the expression is tainted or points to tainted data.\n  bool generateReportIfTainted(const Expr *E, const char Msg[],\n                               CheckerContext &C) const;\n\n  /// The bug visitor prints a diagnostic message at the location where a given\n  /// variable was tainted.\n  class TaintBugVisitor\n      : public BugReporterVisitorImpl<TaintBugVisitor> {\n  private:\n    const SVal V;\n\n  public:\n    TaintBugVisitor(const SVal V) : V(V) {}\n    void Profile(llvm::FoldingSetNodeID &ID) const override { ID.Add(V); }\n\n    std::shared_ptr<PathDiagnosticPiece> VisitNode(const ExplodedNode *N,\n                                                   const ExplodedNode *PrevN,\n                                                   BugReporterContext &BRC,\n                                                   BugReport &BR) override;\n  };\n\n  typedef SmallVector<unsigned, 2> ArgVector;\n\n  /// \\brief A struct used to specify taint propagation rules for a function.\n  ///\n  /// If any of the possible taint source arguments is tainted, all of the\n  /// destination arguments should also be tainted. Use InvalidArgIndex in the\n  /// src list to specify that all of the arguments can introduce taint. Use\n  /// InvalidArgIndex in the dst arguments to signify that all the non-const\n  /// pointer and reference arguments might be tainted on return. If\n  /// ReturnValueIndex is added to the dst list, the return value will be\n  /// tainted.\n  struct TaintPropagationRule {\n    /// List of arguments which can be taint sources and should be checked.\n    ArgVector SrcArgs;\n    /// List of arguments which should be tainted on function return.\n    ArgVector DstArgs;\n    // TODO: Check if using other data structures would be more optimal.\n\n    TaintPropagationRule() {}\n\n    TaintPropagationRule(unsigned SArg,\n                         unsigned DArg, bool TaintRet = false) {\n      SrcArgs.push_back(SArg);\n      DstArgs.push_back(DArg);\n      if (TaintRet)\n        DstArgs.push_back(ReturnValueIndex);\n    }\n\n    TaintPropagationRule(unsigned SArg1, unsigned SArg2,\n                         unsigned DArg, bool TaintRet = false) {\n      SrcArgs.push_back(SArg1);\n      SrcArgs.push_back(SArg2);\n      DstArgs.push_back(DArg);\n      if (TaintRet)\n        DstArgs.push_back(ReturnValueIndex);\n    }\n\n    /// Get the propagation rule for a given function.\n    static TaintPropagationRule\n      getTaintPropagationRule(const FunctionDecl *FDecl,\n                              StringRef Name,\n                              CheckerContext &C);\n\n    inline void addSrcArg(unsigned A) { SrcArgs.push_back(A); }\n    inline void addDstArg(unsigned A)  { DstArgs.push_back(A); }\n\n    inline bool isNull() const { return SrcArgs.empty(); }\n\n    inline bool isDestinationArgument(unsigned ArgNum) const {\n      return (std::find(DstArgs.begin(),\n                        DstArgs.end(), ArgNum) != DstArgs.end());\n    }\n\n    static inline bool isTaintedOrPointsToTainted(const Expr *E,\n                                                  ProgramStateRef State,\n                                                  CheckerContext &C) {\n      if (State->isTainted(E, C.getLocationContext()) || isStdin(E, C))\n        return true;\n\n      if (!E->getType().getTypePtr()->isPointerType())\n        return false;\n\n      Optional<SVal> V = getPointedToSVal(C, E);\n      return (V && State->isTainted(*V));\n    }\n\n    /// \\brief Pre-process a function which propagates taint according to the\n    /// taint rule.\n    ProgramStateRef process(const CallExpr *CE, CheckerContext &C) const;\n\n  };\n};\n\nconst unsigned GenericTaintChecker::ReturnValueIndex;\nconst unsigned GenericTaintChecker::InvalidArgIndex;\n\nconst char GenericTaintChecker::MsgUncontrolledFormatString[] =\n  \"Untrusted data is used as a format string \"\n  \"(CWE-134: Uncontrolled Format String)\";\n\nconst char GenericTaintChecker::MsgSanitizeSystemArgs[] =\n  \"Untrusted data is passed to a system call \"\n  \"(CERT/STR02-C. Sanitize data passed to complex subsystems)\";\n\nconst char GenericTaintChecker::MsgTaintedBufferSize[] =\n  \"Untrusted data is used to specify the buffer size \"\n  \"(CERT/STR31-C. Guarantee that storage for strings has sufficient space for \"\n  \"character data and the null terminator)\";\n\n} // end of anonymous namespace\n\n/// A set which is used to pass information from call pre-visit instruction\n/// to the call post-visit. The values are unsigned integers, which are either\n/// ReturnValueIndex, or indexes of the pointer/reference argument, which\n/// points to data, which should be tainted on return.\nREGISTER_SET_WITH_PROGRAMSTATE(TaintArgsOnPostVisit, unsigned)\n\nstd::shared_ptr<PathDiagnosticPiece>\nGenericTaintChecker::TaintBugVisitor::VisitNode(const ExplodedNode *N,\n    const ExplodedNode *PrevN, BugReporterContext &BRC, BugReport &BR) {\n\n  // Find the ExplodedNode where the taint was first introduced\n  if (!N->getState()->isTainted(V) || PrevN->getState()->isTainted(V))\n    return nullptr;\n\n  const Stmt *S = PathDiagnosticLocation::getStmt(N);\n  if (!S)\n    return nullptr;\n\n  const LocationContext *NCtx = N->getLocationContext();\n  PathDiagnosticLocation L =\n      PathDiagnosticLocation::createBegin(S, BRC.getSourceManager(), NCtx);\n  if (!L.isValid() || !L.asLocation().isValid())\n    return nullptr;\n\n  return std::make_shared<PathDiagnosticEventPiece>(\n      L, \"Taint originated here\");\n}\n\nGenericTaintChecker::TaintPropagationRule\nGenericTaintChecker::TaintPropagationRule::getTaintPropagationRule(\n                                                     const FunctionDecl *FDecl,\n                                                     StringRef Name,\n                                                     CheckerContext &C) {\n  // TODO: Currently, we might lose precision here: we always mark a return\n  // value as tainted even if it's just a pointer, pointing to tainted data.\n\n  // Check for exact name match for functions without builtin substitutes.\n  TaintPropagationRule Rule = llvm::StringSwitch<TaintPropagationRule>(Name)\n    .Case(\"atoi\", TaintPropagationRule(0, ReturnValueIndex))\n    .Case(\"atol\", TaintPropagationRule(0, ReturnValueIndex))\n    .Case(\"atoll\", TaintPropagationRule(0, ReturnValueIndex))\n    .Case(\"getc\", TaintPropagationRule(0, ReturnValueIndex))\n    .Case(\"fgetc\", TaintPropagationRule(0, ReturnValueIndex))\n    .Case(\"getc_unlocked\", TaintPropagationRule(0, ReturnValueIndex))\n    .Case(\"getw\", TaintPropagationRule(0, ReturnValueIndex))\n    .Case(\"toupper\", TaintPropagationRule(0, ReturnValueIndex))\n    .Case(\"tolower\", TaintPropagationRule(0, ReturnValueIndex))\n    .Case(\"strchr\", TaintPropagationRule(0, ReturnValueIndex))\n    .Case(\"strrchr\", TaintPropagationRule(0, ReturnValueIndex))\n    .Case(\"read\", TaintPropagationRule(0, 2, 1, true))\n    .Case(\"pread\", TaintPropagationRule(InvalidArgIndex, 1, true))\n    .Case(\"gets\", TaintPropagationRule(InvalidArgIndex, 0, true))\n    .Case(\"fgets\", TaintPropagationRule(2, 0, true))\n    .Case(\"getline\", TaintPropagationRule(2, 0))\n    .Case(\"getdelim\", TaintPropagationRule(3, 0))\n    .Case(\"fgetln\", TaintPropagationRule(0, ReturnValueIndex))\n    .Default(TaintPropagationRule());\n\n  if (!Rule.isNull())\n    return Rule;\n\n  // Check if it's one of the memory setting/copying functions.\n  // This check is specialized but faster then calling isCLibraryFunction.\n  unsigned BId = 0;\n  if ( (BId = FDecl->getMemoryFunctionKind()) )\n    switch(BId) {\n    case Builtin::BImemcpy:\n    case Builtin::BImemmove:\n    case Builtin::BIstrncpy:\n    case Builtin::BIstrncat:\n      return TaintPropagationRule(1, 2, 0, true);\n    case Builtin::BIstrlcpy:\n    case Builtin::BIstrlcat:\n      return TaintPropagationRule(1, 2, 0, false);\n    case Builtin::BIstrndup:\n      return TaintPropagationRule(0, 1, ReturnValueIndex);\n\n    default:\n      break;\n    };\n\n  // Process all other functions which could be defined as builtins.\n  if (Rule.isNull()) {\n    if (C.isCLibraryFunction(FDecl, \"snprintf\") ||\n        C.isCLibraryFunction(FDecl, \"sprintf\"))\n      return TaintPropagationRule(InvalidArgIndex, 0, true);\n    else if (C.isCLibraryFunction(FDecl, \"strcpy\") ||\n             C.isCLibraryFunction(FDecl, \"stpcpy\") ||\n             C.isCLibraryFunction(FDecl, \"strcat\"))\n      return TaintPropagationRule(1, 0, true);\n    else if (C.isCLibraryFunction(FDecl, \"bcopy\"))\n      return TaintPropagationRule(0, 2, 1, false);\n    else if (C.isCLibraryFunction(FDecl, \"strdup\") ||\n             C.isCLibraryFunction(FDecl, \"strdupa\"))\n      return TaintPropagationRule(0, ReturnValueIndex);\n    else if (C.isCLibraryFunction(FDecl, \"wcsdup\"))\n      return TaintPropagationRule(0, ReturnValueIndex);\n  }\n\n  // Skipping the following functions, since they might be used for cleansing\n  // or smart memory copy:\n  // - memccpy - copying until hitting a special character.\n\n  return TaintPropagationRule();\n}\n\nvoid GenericTaintChecker::checkPreStmt(const CallExpr *CE,\n                                       CheckerContext &C) const {\n  // Check for errors first.\n  if (checkPre(CE, C))\n    return;\n\n  // Add taint second.\n  addSourcesPre(CE, C);\n}\n\nvoid GenericTaintChecker::checkPostStmt(const CallExpr *CE,\n                                        CheckerContext &C) const {\n  if (propagateFromPre(CE, C))\n    return;\n  addSourcesPost(CE, C);\n}\n\nvoid GenericTaintChecker::addSourcesPre(const CallExpr *CE,\n                                        CheckerContext &C) const {\n  ProgramStateRef State = nullptr;\n  const FunctionDecl *FDecl = C.getCalleeDecl(CE);\n  if (!FDecl || FDecl->getKind() != Decl::Function)\n    return;\n\n  StringRef Name = C.getCalleeName(FDecl);\n  if (Name.empty())\n    return;\n\n  // First, try generating a propagation rule for this function.\n  TaintPropagationRule Rule =\n    TaintPropagationRule::getTaintPropagationRule(FDecl, Name, C);\n  if (!Rule.isNull()) {\n    State = Rule.process(CE, C);\n    if (!State)\n      return;\n    C.addTransition(State);\n    return;\n  }\n\n  // Otherwise, check if we have custom pre-processing implemented.\n  FnCheck evalFunction = llvm::StringSwitch<FnCheck>(Name)\n    .Case(\"fscanf\", &GenericTaintChecker::preFscanf)\n    .Default(nullptr);\n  // Check and evaluate the call.\n  if (evalFunction)\n    State = (this->*evalFunction)(CE, C);\n  if (!State)\n    return;\n  C.addTransition(State);\n\n}\n\nbool GenericTaintChecker::propagateFromPre(const CallExpr *CE,\n                                           CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\n  // Depending on what was tainted at pre-visit, we determined a set of\n  // arguments which should be tainted after the function returns. These are\n  // stored in the state as TaintArgsOnPostVisit set.\n  TaintArgsOnPostVisitTy TaintArgs = State->get<TaintArgsOnPostVisit>();\n  if (TaintArgs.isEmpty())\n    return false;\n\n  for (llvm::ImmutableSet<unsigned>::iterator\n         I = TaintArgs.begin(), E = TaintArgs.end(); I != E; ++I) {\n    unsigned ArgNum  = *I;\n\n    // Special handling for the tainted return value.\n    if (ArgNum == ReturnValueIndex) {\n      State = State->addTaint(CE, C.getLocationContext());\n      continue;\n    }\n\n    // The arguments are pointer arguments. The data they are pointing at is\n    // tainted after the call.\n    if (CE->getNumArgs() < (ArgNum + 1))\n      return false;\n    const Expr* Arg = CE->getArg(ArgNum);\n    Optional<SVal> V = getPointedToSVal(C, Arg);\n    if (V)\n      State = State->addTaint(*V);\n  }\n\n  // Clear up the taint info from the state.\n  State = State->remove<TaintArgsOnPostVisit>();\n\n  if (State != C.getState()) {\n    C.addTransition(State);\n    return true;\n  }\n  return false;\n}\n\nvoid GenericTaintChecker::addSourcesPost(const CallExpr *CE,\n                                         CheckerContext &C) const {\n  // Define the attack surface.\n  // Set the evaluation function by switching on the callee name.\n  const FunctionDecl *FDecl = C.getCalleeDecl(CE);\n  if (!FDecl || FDecl->getKind() != Decl::Function)\n    return;\n\n  StringRef Name = C.getCalleeName(FDecl);\n  if (Name.empty())\n    return;\n  FnCheck evalFunction = llvm::StringSwitch<FnCheck>(Name)\n    .Case(\"scanf\", &GenericTaintChecker::postScanf)\n    // TODO: Add support for vfscanf & family.\n    .Case(\"getchar\", &GenericTaintChecker::postRetTaint)\n    .Case(\"getchar_unlocked\", &GenericTaintChecker::postRetTaint)\n    .Case(\"getenv\", &GenericTaintChecker::postRetTaint)\n    .Case(\"fopen\", &GenericTaintChecker::postRetTaint)\n    .Case(\"fdopen\", &GenericTaintChecker::postRetTaint)\n    .Case(\"freopen\", &GenericTaintChecker::postRetTaint)\n    .Case(\"getch\", &GenericTaintChecker::postRetTaint)\n    .Case(\"wgetch\", &GenericTaintChecker::postRetTaint)\n    .Case(\"socket\", &GenericTaintChecker::postSocket)\n    .Default(nullptr);\n\n  // If the callee isn't defined, it is not of security concern.\n  // Check and evaluate the call.\n  ProgramStateRef State = nullptr;\n  if (evalFunction)\n    State = (this->*evalFunction)(CE, C);\n  if (!State)\n    return;\n\n  C.addTransition(State);\n}\n\nbool GenericTaintChecker::checkPre(const CallExpr *CE, CheckerContext &C) const{\n\n  if (checkUncontrolledFormatString(CE, C))\n    return true;\n\n  const FunctionDecl *FDecl = C.getCalleeDecl(CE);\n  if (!FDecl || FDecl->getKind() != Decl::Function)\n    return false;\n\n  StringRef Name = C.getCalleeName(FDecl);\n  if (Name.empty())\n    return false;\n\n  if (checkSystemCall(CE, Name, C))\n    return true;\n\n  if (checkTaintedBufferSize(CE, FDecl, C))\n    return true;\n\n  return false;\n}\n\nOptional<SVal> GenericTaintChecker::getPointedToSVal(CheckerContext &C,\n                                            const Expr* Arg) {\n  ProgramStateRef State = C.getState();\n  SVal AddrVal = State->getSVal(Arg->IgnoreParens(), C.getLocationContext());\n  if (AddrVal.isUnknownOrUndef())\n    return None;\n\n  Optional<Loc> AddrLoc = AddrVal.getAs<Loc>();\n  if (!AddrLoc)\n    return None;\n\n  const PointerType *ArgTy =\n    dyn_cast<PointerType>(Arg->getType().getCanonicalType().getTypePtr());\n  return State->getSVal(*AddrLoc, ArgTy ? ArgTy->getPointeeType(): QualType());\n}\n\nProgramStateRef\nGenericTaintChecker::TaintPropagationRule::process(const CallExpr *CE,\n                                                   CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\n  // Check for taint in arguments.\n  bool IsTainted = false;\n  for (ArgVector::const_iterator I = SrcArgs.begin(),\n                                 E = SrcArgs.end(); I != E; ++I) {\n    unsigned ArgNum = *I;\n\n    if (ArgNum == InvalidArgIndex) {\n      // Check if any of the arguments is tainted, but skip the\n      // destination arguments.\n      for (unsigned int i = 0; i < CE->getNumArgs(); ++i) {\n        if (isDestinationArgument(i))\n          continue;\n        if ((IsTainted = isTaintedOrPointsToTainted(CE->getArg(i), State, C)))\n          break;\n      }\n      break;\n    }\n\n    if (CE->getNumArgs() < (ArgNum + 1))\n      return State;\n    if ((IsTainted = isTaintedOrPointsToTainted(CE->getArg(ArgNum), State, C)))\n      break;\n  }\n  if (!IsTainted)\n    return State;\n\n  // Mark the arguments which should be tainted after the function returns.\n  for (ArgVector::const_iterator I = DstArgs.begin(),\n                                 E = DstArgs.end(); I != E; ++I) {\n    unsigned ArgNum = *I;\n\n    // Should we mark all arguments as tainted?\n    if (ArgNum == InvalidArgIndex) {\n      // For all pointer and references that were passed in:\n      //   If they are not pointing to const data, mark data as tainted.\n      //   TODO: So far we are just going one level down; ideally we'd need to\n      //         recurse here.\n      for (unsigned int i = 0; i < CE->getNumArgs(); ++i) {\n        const Expr *Arg = CE->getArg(i);\n        // Process pointer argument.\n        const Type *ArgTy = Arg->getType().getTypePtr();\n        QualType PType = ArgTy->getPointeeType();\n        if ((!PType.isNull() && !PType.isConstQualified())\n            || (ArgTy->isReferenceType() && !Arg->getType().isConstQualified()))\n          State = State->add<TaintArgsOnPostVisit>(i);\n      }\n      continue;\n    }\n\n    // Should mark the return value?\n    if (ArgNum == ReturnValueIndex) {\n      State = State->add<TaintArgsOnPostVisit>(ReturnValueIndex);\n      continue;\n    }\n\n    // Mark the given argument.\n    assert(ArgNum < CE->getNumArgs());\n    State = State->add<TaintArgsOnPostVisit>(ArgNum);\n  }\n\n  return State;\n}\n\n\n// If argument 0 (file descriptor) is tainted, all arguments except for arg 0\n// and arg 1 should get taint.\nProgramStateRef GenericTaintChecker::preFscanf(const CallExpr *CE,\n                                                   CheckerContext &C) const {\n  assert(CE->getNumArgs() >= 2);\n  ProgramStateRef State = C.getState();\n\n  // Check is the file descriptor is tainted.\n  if (State->isTainted(CE->getArg(0), C.getLocationContext()) ||\n      isStdin(CE->getArg(0), C)) {\n    // All arguments except for the first two should get taint.\n    for (unsigned int i = 2; i < CE->getNumArgs(); ++i)\n        State = State->add<TaintArgsOnPostVisit>(i);\n    return State;\n  }\n\n  return nullptr;\n}\n\n\n// If argument 0(protocol domain) is network, the return value should get taint.\nProgramStateRef GenericTaintChecker::postSocket(const CallExpr *CE,\n                                                CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n  if (CE->getNumArgs() < 3)\n    return State;\n\n  SourceLocation DomLoc = CE->getArg(0)->getExprLoc();\n  StringRef DomName = C.getMacroNameOrSpelling(DomLoc);\n  // White list the internal communication protocols.\n  if (DomName.equals(\"AF_SYSTEM\") || DomName.equals(\"AF_LOCAL\") ||\n      DomName.equals(\"AF_UNIX\") || DomName.equals(\"AF_RESERVED_36\"))\n    return State;\n  State = State->addTaint(CE, C.getLocationContext());\n  return State;\n}\n\nProgramStateRef GenericTaintChecker::postScanf(const CallExpr *CE,\n                                                   CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n  if (CE->getNumArgs() < 2)\n    return State;\n\n  // All arguments except for the very first one should get taint.\n  for (unsigned int i = 1; i < CE->getNumArgs(); ++i) {\n    // The arguments are pointer arguments. The data they are pointing at is\n    // tainted after the call.\n    const Expr* Arg = CE->getArg(i);\n    Optional<SVal> V = getPointedToSVal(C, Arg);\n    if (V)\n      State = State->addTaint(*V);\n  }\n  return State;\n}\n\nProgramStateRef GenericTaintChecker::postRetTaint(const CallExpr *CE,\n                                                  CheckerContext &C) const {\n  return C.getState()->addTaint(CE, C.getLocationContext());\n}\n\nbool GenericTaintChecker::isStdin(const Expr *E, CheckerContext &C) {\n  ProgramStateRef State = C.getState();\n  SVal Val = State->getSVal(E, C.getLocationContext());\n\n  // stdin is a pointer, so it would be a region.\n  const MemRegion *MemReg = Val.getAsRegion();\n\n  // The region should be symbolic, we do not know it's value.\n  const SymbolicRegion *SymReg = dyn_cast_or_null<SymbolicRegion>(MemReg);\n  if (!SymReg)\n    return false;\n\n  // Get it's symbol and find the declaration region it's pointing to.\n  const SymbolRegionValue *Sm =dyn_cast<SymbolRegionValue>(SymReg->getSymbol());\n  if (!Sm)\n    return false;\n  const DeclRegion *DeclReg = dyn_cast_or_null<DeclRegion>(Sm->getRegion());\n  if (!DeclReg)\n    return false;\n\n  // This region corresponds to a declaration, find out if it's a global/extern\n  // variable named stdin with the proper type.\n  if (const VarDecl *D = dyn_cast_or_null<VarDecl>(DeclReg->getDecl())) {\n    D = D->getCanonicalDecl();\n    if ((D->getName().find(\"stdin\") != StringRef::npos) && D->isExternC())\n        if (const PointerType * PtrTy =\n              dyn_cast<PointerType>(D->getType().getTypePtr()))\n          if (PtrTy->getPointeeType() == C.getASTContext().getFILEType())\n            return true;\n  }\n  return false;\n}\n\nstatic bool getPrintfFormatArgumentNum(const CallExpr *CE,\n                                       const CheckerContext &C,\n                                       unsigned int &ArgNum) {\n  // Find if the function contains a format string argument.\n  // Handles: fprintf, printf, sprintf, snprintf, vfprintf, vprintf, vsprintf,\n  // vsnprintf, syslog, custom annotated functions.\n  const FunctionDecl *FDecl = C.getCalleeDecl(CE);\n  if (!FDecl)\n    return false;\n  for (const auto *Format : FDecl->specific_attrs<FormatAttr>()) {\n    ArgNum = Format->getFormatIdx() - 1;\n    if ((Format->getType()->getName() == \"printf\") &&\n         CE->getNumArgs() > ArgNum)\n      return true;\n  }\n\n  // Or if a function is named setproctitle (this is a heuristic).\n  if (C.getCalleeName(CE).find(\"setproctitle\") != StringRef::npos) {\n    ArgNum = 0;\n    return true;\n  }\n\n  return false;\n}\n\nbool GenericTaintChecker::generateReportIfTainted(const Expr *E,\n                                                  const char Msg[],\n                                                  CheckerContext &C) const {\n  assert(E);\n\n  // Check for taint.\n  ProgramStateRef State = C.getState();\n  Optional<SVal> PointedToSVal = getPointedToSVal(C, E);\n  SVal TaintedSVal;\n  if (PointedToSVal && State->isTainted(*PointedToSVal))\n    TaintedSVal = *PointedToSVal;\n  else if (State->isTainted(E, C.getLocationContext()))\n    TaintedSVal = C.getSVal(E);\n  else\n    return false;\n\n  // Generate diagnostic.\n  if (ExplodedNode *N = C.generateNonFatalErrorNode()) {\n    initBugType();\n    auto report = llvm::make_unique<BugReport>(*BT, Msg, N);\n    report->addRange(E->getSourceRange());\n    report->addVisitor(llvm::make_unique<TaintBugVisitor>(TaintedSVal));\n    C.emitReport(std::move(report));\n    return true;\n  }\n  return false;\n}\n\nbool GenericTaintChecker::checkUncontrolledFormatString(const CallExpr *CE,\n                                                        CheckerContext &C) const{\n  // Check if the function contains a format string argument.\n  unsigned int ArgNum = 0;\n  if (!getPrintfFormatArgumentNum(CE, C, ArgNum))\n    return false;\n\n  // If either the format string content or the pointer itself are tainted, warn.\n  return generateReportIfTainted(CE->getArg(ArgNum),\n                                 MsgUncontrolledFormatString, C);\n}\n\nbool GenericTaintChecker::checkSystemCall(const CallExpr *CE,\n                                          StringRef Name,\n                                          CheckerContext &C) const {\n  // TODO: It might make sense to run this check on demand. In some cases,\n  // we should check if the environment has been cleansed here. We also might\n  // need to know if the user was reset before these calls(seteuid).\n  unsigned ArgNum = llvm::StringSwitch<unsigned>(Name)\n    .Case(\"system\", 0)\n    .Case(\"popen\", 0)\n    .Case(\"execl\", 0)\n    .Case(\"execle\", 0)\n    .Case(\"execlp\", 0)\n    .Case(\"execv\", 0)\n    .Case(\"execvp\", 0)\n    .Case(\"execvP\", 0)\n    .Case(\"execve\", 0)\n    .Case(\"dlopen\", 0)\n    .Default(UINT_MAX);\n\n  if (ArgNum == UINT_MAX || CE->getNumArgs() < (ArgNum + 1))\n    return false;\n\n  return generateReportIfTainted(CE->getArg(ArgNum), MsgSanitizeSystemArgs, C);\n}\n\n// TODO: Should this check be a part of the CString checker?\n// If yes, should taint be a global setting?\nbool GenericTaintChecker::checkTaintedBufferSize(const CallExpr *CE,\n                                                 const FunctionDecl *FDecl,\n                                                 CheckerContext &C) const {\n  // If the function has a buffer size argument, set ArgNum.\n  unsigned ArgNum = InvalidArgIndex;\n  unsigned BId = 0;\n  if ( (BId = FDecl->getMemoryFunctionKind()) )\n    switch(BId) {\n    case Builtin::BImemcpy:\n    case Builtin::BImemmove:\n    case Builtin::BIstrncpy:\n      ArgNum = 2;\n      break;\n    case Builtin::BIstrndup:\n      ArgNum = 1;\n      break;\n    default:\n      break;\n    };\n\n  if (ArgNum == InvalidArgIndex) {\n    if (C.isCLibraryFunction(FDecl, \"malloc\") ||\n        C.isCLibraryFunction(FDecl, \"calloc\") ||\n        C.isCLibraryFunction(FDecl, \"alloca\"))\n      ArgNum = 0;\n    else if (C.isCLibraryFunction(FDecl, \"memccpy\"))\n      ArgNum = 3;\n    else if (C.isCLibraryFunction(FDecl, \"realloc\"))\n      ArgNum = 1;\n    else if (C.isCLibraryFunction(FDecl, \"bcopy\"))\n      ArgNum = 2;\n  }\n\n  return ArgNum != InvalidArgIndex && CE->getNumArgs() > ArgNum &&\n         generateReportIfTainted(CE->getArg(ArgNum), MsgTaintedBufferSize, C);\n}\n\nvoid ento::registerGenericTaintChecker(CheckerManager &mgr) {\n  mgr.registerChecker<GenericTaintChecker>();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/docs/ControlFlowIntegrityDesign.rst": "===========================================\nControl Flow Integrity Design Documentation\n===========================================\n\nThis page documents the design of the :doc:`ControlFlowIntegrity` schemes\nsupported by Clang.\n\nForward-Edge CFI for Virtual Calls\n==================================\n\nThis scheme works by allocating, for each static type used to make a virtual\ncall, a region of read-only storage in the object file holding a bit vector\nthat maps onto to the region of storage used for those virtual tables. Each\nset bit in the bit vector corresponds to the `address point`_ for a virtual\ntable compatible with the static type for which the bit vector is being built.\n\nFor example, consider the following three C++ classes:\n\n.. code-block:: c++\n\n  struct A {\n    virtual void f1();\n    virtual void f2();\n    virtual void f3();\n  };\n\n  struct B : A {\n    virtual void f1();\n    virtual void f2();\n    virtual void f3();\n  };\n\n  struct C : A {\n    virtual void f1();\n    virtual void f2();\n    virtual void f3();\n  };\n\nThe scheme will cause the virtual tables for A, B and C to be laid out\nconsecutively:\n\n.. csv-table:: Virtual Table Layout for A, B, C\n  :header: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14\n\n  A::offset-to-top, &A::rtti, &A::f1, &A::f2, &A::f3, B::offset-to-top, &B::rtti, &B::f1, &B::f2, &B::f3, C::offset-to-top, &C::rtti, &C::f1, &C::f2, &C::f3\n\nThe bit vector for static types A, B and C will look like this:\n\n.. csv-table:: Bit Vectors for A, B, C\n  :header: Class, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14\n\n  A, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0\n  B, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0\n  C, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0\n\nBit vectors are represented in the object file as byte arrays. By loading\nfrom indexed offsets into the byte array and applying a mask, a program can\ntest bits from the bit set with a relatively short instruction sequence. Bit\nvectors may overlap so long as they use different bits. For the full details,\nsee the `ByteArrayBuilder`_ class.\n\nIn this case, assuming A is laid out at offset 0 in bit 0, B at offset 0 in\nbit 1 and C at offset 0 in bit 2, the byte array would look like this:\n\n.. code-block:: c++\n\n  char bits[] = { 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 5, 0, 0 };\n\nTo emit a virtual call, the compiler will assemble code that checks that\nthe object's virtual table pointer is in-bounds and aligned and that the\nrelevant bit is set in the bit vector.\n\nFor example on x86 a typical virtual call may look like this:\n\n.. code-block:: none\n\n  ca7fbb:       48 8b 0f                mov    (%rdi),%rcx\n  ca7fbe:       48 8d 15 c3 42 fb 07    lea    0x7fb42c3(%rip),%rdx\n  ca7fc5:       48 89 c8                mov    %rcx,%rax\n  ca7fc8:       48 29 d0                sub    %rdx,%rax\n  ca7fcb:       48 c1 c0 3d             rol    $0x3d,%rax\n  ca7fcf:       48 3d 7f 01 00 00       cmp    $0x17f,%rax\n  ca7fd5:       0f 87 36 05 00 00       ja     ca8511\n  ca7fdb:       48 8d 15 c0 0b f7 06    lea    0x6f70bc0(%rip),%rdx\n  ca7fe2:       f6 04 10 10             testb  $0x10,(%rax,%rdx,1)\n  ca7fe6:       0f 84 25 05 00 00       je     ca8511\n  ca7fec:       ff 91 98 00 00 00       callq  *0x98(%rcx)\n    [...]\n  ca8511:       0f 0b                   ud2\n\nThe compiler relies on co-operation from the linker in order to assemble\nthe bit vectors for the whole program. It currently does this using LLVM's\n`type metadata`_ mechanism together with link-time optimization.\n\n.. _address point: https://mentorembedded.github.io/cxx-abi/abi.html#vtable-general\n.. _type metadata: http://llvm.org/docs/TypeMetadata.html\n.. _ByteArrayBuilder: http://llvm.org/docs/doxygen/html/structllvm_1_1ByteArrayBuilder.html\n\nOptimizations\n-------------\n\nThe scheme as described above is the fully general variant of the scheme.\nMost of the time we are able to apply one or more of the following\noptimizations to improve binary size or performance.\n\nIn fact, if you try the above example with the current version of the\ncompiler, you will probably find that it will not use the described virtual\ntable layout or machine instructions. Some of the optimizations we are about\nto introduce cause the compiler to use a different layout or a different\nsequence of machine instructions.\n\nStripping Leading/Trailing Zeros in Bit Vectors\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf a bit vector contains leading or trailing zeros, we can strip them from\nthe vector. The compiler will emit code to check if the pointer is in range\nof the region covered by ones, and perform the bit vector check using a\ntruncated version of the bit vector. For example, the bit vectors for our\nexample class hierarchy will be emitted like this:\n\n.. csv-table:: Bit Vectors for A, B, C\n  :header: Class, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14\n\n  A,  ,  , 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,  ,  \n  B,  ,  ,  ,  ,  ,  ,  , 1,  ,  ,  ,  ,  ,  ,  \n  C,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  , 1,  ,  \n\nShort Inline Bit Vectors\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf the vector is sufficiently short, we can represent it as an inline constant\non x86. This saves us a few instructions when reading the correct element\nof the bit vector.\n\nIf the bit vector fits in 32 bits, the code looks like this:\n\n.. code-block:: none\n\n     dc2:       48 8b 03                mov    (%rbx),%rax\n     dc5:       48 8d 15 14 1e 00 00    lea    0x1e14(%rip),%rdx\n     dcc:       48 89 c1                mov    %rax,%rcx\n     dcf:       48 29 d1                sub    %rdx,%rcx\n     dd2:       48 c1 c1 3d             rol    $0x3d,%rcx\n     dd6:       48 83 f9 03             cmp    $0x3,%rcx\n     dda:       77 2f                   ja     e0b <main+0x9b>\n     ddc:       ba 09 00 00 00          mov    $0x9,%edx\n     de1:       0f a3 ca                bt     %ecx,%edx\n     de4:       73 25                   jae    e0b <main+0x9b>\n     de6:       48 89 df                mov    %rbx,%rdi\n     de9:       ff 10                   callq  *(%rax)\n    [...]\n     e0b:       0f 0b                   ud2    \n\nOr if the bit vector fits in 64 bits:\n\n.. code-block:: none\n\n    11a6:       48 8b 03                mov    (%rbx),%rax\n    11a9:       48 8d 15 d0 28 00 00    lea    0x28d0(%rip),%rdx\n    11b0:       48 89 c1                mov    %rax,%rcx\n    11b3:       48 29 d1                sub    %rdx,%rcx\n    11b6:       48 c1 c1 3d             rol    $0x3d,%rcx\n    11ba:       48 83 f9 2a             cmp    $0x2a,%rcx\n    11be:       77 35                   ja     11f5 <main+0xb5>\n    11c0:       48 ba 09 00 00 00 00    movabs $0x40000000009,%rdx\n    11c7:       04 00 00 \n    11ca:       48 0f a3 ca             bt     %rcx,%rdx\n    11ce:       73 25                   jae    11f5 <main+0xb5>\n    11d0:       48 89 df                mov    %rbx,%rdi\n    11d3:       ff 10                   callq  *(%rax)\n    [...]\n    11f5:       0f 0b                   ud2    \n\nIf the bit vector consists of a single bit, there is only one possible\nvirtual table, and the check can consist of a single equality comparison:\n\n.. code-block:: none\n\n     9a2:   48 8b 03                mov    (%rbx),%rax\n     9a5:   48 8d 0d a4 13 00 00    lea    0x13a4(%rip),%rcx\n     9ac:   48 39 c8                cmp    %rcx,%rax\n     9af:   75 25                   jne    9d6 <main+0x86>\n     9b1:   48 89 df                mov    %rbx,%rdi\n     9b4:   ff 10                   callq  *(%rax)\n     [...]\n     9d6:   0f 0b                   ud2\n\nVirtual Table Layout\n~~~~~~~~~~~~~~~~~~~~\n\nThe compiler lays out classes of disjoint hierarchies in separate regions\nof the object file. At worst, bit vectors in disjoint hierarchies only\nneed to cover their disjoint hierarchy. But the closer that classes in\nsub-hierarchies are laid out to each other, the smaller the bit vectors for\nthose sub-hierarchies need to be (see \"Stripping Leading/Trailing Zeros in Bit\nVectors\" above). The `GlobalLayoutBuilder`_ class is responsible for laying\nout the globals efficiently to minimize the sizes of the underlying bitsets.\n\n.. _GlobalLayoutBuilder: http://llvm.org/viewvc/llvm-project/llvm/trunk/include/llvm/Transforms/IPO/LowerTypeTests.h?view=markup\n\nAlignment\n~~~~~~~~~\n\nIf all gaps between address points in a particular bit vector are multiples\nof powers of 2, the compiler can compress the bit vector by strengthening\nthe alignment requirements of the virtual table pointer. For example, given\nthis class hierarchy:\n\n.. code-block:: c++\n\n  struct A {\n    virtual void f1();\n    virtual void f2();\n  };\n\n  struct B : A {\n    virtual void f1();\n    virtual void f2();\n    virtual void f3();\n    virtual void f4();\n    virtual void f5();\n    virtual void f6();\n  };\n\n  struct C : A {\n    virtual void f1();\n    virtual void f2();\n  };\n\nThe virtual tables will be laid out like this:\n\n.. csv-table:: Virtual Table Layout for A, B, C\n  :header: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n\n  A::offset-to-top, &A::rtti, &A::f1, &A::f2, B::offset-to-top, &B::rtti, &B::f1, &B::f2, &B::f3, &B::f4, &B::f5, &B::f6, C::offset-to-top, &C::rtti, &C::f1, &C::f2\n\nNotice that each address point for A is separated by 4 words. This lets us\nemit a compressed bit vector for A that looks like this:\n\n.. csv-table::\n  :header: 2, 6, 10, 14\n\n  1, 1, 0, 1\n\nAt call sites, the compiler will strengthen the alignment requirements by\nusing a different rotate count. For example, on a 64-bit machine where the\naddress points are 4-word aligned (as in A from our example), the ``rol``\ninstruction may look like this:\n\n.. code-block:: none\n\n     dd2:       48 c1 c1 3b             rol    $0x3b,%rcx\n\nPadding to Powers of 2\n~~~~~~~~~~~~~~~~~~~~~~\n\nOf course, this alignment scheme works best if the address points are\nin fact aligned correctly. To make this more likely to happen, we insert\npadding between virtual tables that in many cases aligns address points to\na power of 2. Specifically, our padding aligns virtual tables to the next\nhighest power of 2 bytes; because address points for specific base classes\nnormally appear at fixed offsets within the virtual table, this normally\nhas the effect of aligning the address points as well.\n\nThis scheme introduces tradeoffs between decreased space overhead for\ninstructions and bit vectors and increased overhead in the form of padding. We\ntherefore limit the amount of padding so that we align to no more than 128\nbytes. This number was found experimentally to provide a good tradeoff.\n\nEliminating Bit Vector Checks for All-Ones Bit Vectors\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf the bit vector is all ones, the bit vector check is redundant; we simply\nneed to check that the address is in range and well aligned. This is more\nlikely to occur if the virtual tables are padded.\n\nForward-Edge CFI for Indirect Function Calls\n============================================\n\nUnder forward-edge CFI for indirect function calls, each unique function\ntype has its own bit vector, and at each call site we need to check that the\nfunction pointer is a member of the function type's bit vector. This scheme\nworks in a similar way to forward-edge CFI for virtual calls, the distinction\nbeing that we need to build bit vectors of function entry points rather than\nof virtual tables.\n\nUnlike when re-arranging global variables, we cannot re-arrange functions\nin a particular order and base our calculations on the layout of the\nfunctions' entry points, as we have no idea how large a particular function\nwill end up being (the function sizes could even depend on how we arrange\nthe functions). Instead, we build a jump table, which is a block of code\nconsisting of one branch instruction for each of the functions in the bit\nset that branches to the target function, and redirect any taken function\naddresses to the corresponding jump table entry. In this way, the distance\nbetween function entry points is predictable and controllable. In the object\nfile's symbol table, the symbols for the target functions also refer to the\njump table entries, so that addresses taken outside the module will pass\nany verification done inside the module.\n\nIn more concrete terms, suppose we have three functions ``f``, ``g``,\n``h`` which are all of the same type, and a function foo that returns their\naddresses:\n\n.. code-block:: none\n\n  f:\n  mov 0, %eax\n  ret\n\n  g:\n  mov 1, %eax\n  ret\n\n  h:\n  mov 2, %eax\n  ret\n\n  foo:\n  mov f, %eax\n  mov g, %edx\n  mov h, %ecx\n  ret\n\nOur jump table will (conceptually) look like this:\n\n.. code-block:: none\n\n  f:\n  jmp .Ltmp0 ; 5 bytes\n  int3       ; 1 byte\n  int3       ; 1 byte\n  int3       ; 1 byte\n\n  g:\n  jmp .Ltmp1 ; 5 bytes\n  int3       ; 1 byte\n  int3       ; 1 byte\n  int3       ; 1 byte\n\n  h:\n  jmp .Ltmp2 ; 5 bytes\n  int3       ; 1 byte\n  int3       ; 1 byte\n  int3       ; 1 byte\n\n  .Ltmp0:\n  mov 0, %eax\n  ret\n\n  .Ltmp1:\n  mov 1, %eax\n  ret\n\n  .Ltmp2:\n  mov 2, %eax\n  ret\n\n  foo:\n  mov f, %eax\n  mov g, %edx\n  mov h, %ecx\n  ret\n\nBecause the addresses of ``f``, ``g``, ``h`` are evenly spaced at a power of\n2, and function types do not overlap (unlike class types with base classes),\nwe can normally apply the `Alignment`_ and `Eliminating Bit Vector Checks\nfor All-Ones Bit Vectors`_ optimizations thus simplifying the check at each\ncall site to a range and alignment check.\n\nShared library support\n======================\n\n**EXPERIMENTAL**\n\nThe basic CFI mode described above assumes that the application is a\nmonolithic binary; at least that all possible virtual/indirect call\ntargets and the entire class hierarchy are known at link time. The\ncross-DSO mode, enabled with **-f[no-]sanitize-cfi-cross-dso** relaxes\nthis requirement by allowing virtual and indirect calls to cross the\nDSO boundary.\n\nAssuming the following setup: the binary consists of several\ninstrumented and several uninstrumented DSOs. Some of them may be\ndlopen-ed/dlclose-d periodically, even frequently.\n\n  - Calls made from uninstrumented DSOs are not checked and just work.\n  - Calls inside any instrumented DSO are fully protected.\n  - Calls between different instrumented DSOs are also protected, with\n     a performance penalty (in addition to the monolithic CFI\n     overhead).\n  - Calls from an instrumented DSO to an uninstrumented one are\n     unchecked and just work, with performance penalty.\n  - Calls from an instrumented DSO outside of any known DSO are\n     detected as CFI violations.\n\nIn the monolithic scheme a call site is instrumented as\n\n.. code-block:: none\n\n   if (!InlinedFastCheck(f))\n     abort();\n   call *f\n\nIn the cross-DSO scheme it becomes\n\n.. code-block:: none\n\n   if (!InlinedFastCheck(f))\n     __cfi_slowpath(CallSiteTypeId, f);\n   call *f\n\nCallSiteTypeId\n--------------\n\n``CallSiteTypeId`` is a stable process-wide identifier of the\ncall-site type. For a virtual call site, the type in question is the class\ntype; for an indirect function call it is the function signature. The\nmapping from a type to an identifier is an ABI detail. In the current,\nexperimental, implementation the identifier of type T is calculated as\nfollows:\n\n  -  Obtain the mangled name for \"typeinfo name for T\".\n  -  Calculate MD5 hash of the name as a string.\n  -  Reinterpret the first 8 bytes of the hash as a little-endian\n     64-bit integer.\n\nIt is possible, but unlikely, that collisions in the\n``CallSiteTypeId`` hashing will result in weaker CFI checks that would\nstill be conservatively correct.\n\nCFI_Check\n---------\n\nIn the general case, only the target DSO knows whether the call to\nfunction ``f`` with type ``CallSiteTypeId`` is valid or not.  To\nexport this information, every DSO implements\n\n.. code-block:: none\n\n   void __cfi_check(uint64 CallSiteTypeId, void *TargetAddr, void *DiagData)\n\nThis function provides external modules with access to CFI checks for\nthe targets inside this DSO.  For each known ``CallSiteTypeId``, this\nfunction performs an ``llvm.type.test`` with the corresponding type\nidentifier. It reports an error if the type is unknown, or if the\ncheck fails. Depending on the values of compiler flags\n``-fsanitize-trap`` and ``-fsanitize-recover``, this function may\nprint an error, abort and/or return to the caller. ``DiagData`` is an\nopaque pointer to the diagnostic information about the error, or\n``null`` if the caller does not provide this information.\n\nThe basic implementation is a large switch statement over all values\nof CallSiteTypeId supported by this DSO, and each case is similar to\nthe InlinedFastCheck() in the basic CFI mode.\n\nCFI Shadow\n----------\n\nTo route CFI checks to the target DSO's __cfi_check function, a\nmapping from possible virtual / indirect call targets to the\ncorresponding __cfi_check functions is maintained. This mapping is\nimplemented as a sparse array of 2 bytes for every possible page (4096\nbytes) of memory. The table is kept readonly most of the time.\n\nThere are 3 types of shadow values:\n\n  -  Address in a CFI-instrumented DSO.\n  -  Unchecked address (a \u201ctrusted\u201d non-instrumented DSO). Encoded as\n     value 0xFFFF.\n  -  Invalid address (everything else). Encoded as value 0.\n\nFor a CFI-instrumented DSO, a shadow value encodes the address of the\n__cfi_check function for all call targets in the corresponding memory\npage. If Addr is the target address, and V is the shadow value, then\nthe address of __cfi_check is calculated as\n\n.. code-block:: none\n\n  __cfi_check = AlignUpTo(Addr, 4096) - (V + 1) * 4096\n\nThis works as long as __cfi_check is aligned by 4096 bytes and located\nbelow any call targets in its DSO, but not more than 256MB apart from\nthem.\n\nCFI_SlowPath\n------------\n\nThe slow path check is implemented in a runtime support library as\n\n.. code-block:: none\n\n  void __cfi_slowpath(uint64 CallSiteTypeId, void *TargetAddr)\n  void __cfi_slowpath_diag(uint64 CallSiteTypeId, void *TargetAddr, void *DiagData)\n\nThese functions loads a shadow value for ``TargetAddr``, finds the\naddress of ``__cfi_check`` as described above and calls\nthat. ``DiagData`` is an opaque pointer to diagnostic data which is\npassed verbatim to ``__cfi_check``, and ``__cfi_slowpath`` passes\n``nullptr`` instead.\n\nCompiler-RT library contains reference implementations of slowpath\nfunctions, but they have unresolvable issues with correctness and\nperformance in the handling of dlopen(). It is recommended that\nplatforms provide their own implementations, usually as part of libc\nor libdl.\n\nPosition-independent executable requirement\n-------------------------------------------\n\nCross-DSO CFI mode requires that the main executable is built as PIE.\nIn non-PIE executables the address of an external function (taken from\nthe main executable) is the address of that function\u2019s PLT record in\nthe main executable. This would break the CFI checks.\n\nBackward-edge CFI for return statements (RCFI)\n==============================================\n\nThis section is a proposal. As of March 2017 it is not implemented.\n\nBackward-edge control flow (`RET` instructions) can be hijacked\nvia overwriting the return address (`RA`) on stack.\nVarious mitigation techniques (e.g. `SafeStack`_, `RFG`_, `Intel CET`_)\ntry to detect or prevent `RA` corruption on stack.\n\nRCFI enforces the expected control flow in several different ways described below.\nRCFI heavily relies on LTO.\n\nLeaf Functions\n--------------\nIf `f()` is a leaf function (i.e. it has no calls\nexcept maybe no-return calls) it can be called using a special calling convention\nthat stores `RA` in a dedicated register `R` before the `CALL` instruction.\n`f()` does not spill `R` and does not use the `RET` instruction,\ninstead it uses the value in `R` to `JMP` to `RA`.\n\nThis flavour of CFI is *precise*, i.e. the function is guaranteed to return\nto the point exactly following the call.\n\nAn alternative approach is to\ncopy `RA` from stack to `R` in the first instruction of `f()`,\nthen `JMP` to `R`.\nThis approach is simpler to implement (does not require changing the caller)\nbut weaker (there is a small window when `RA` is actually stored on stack).\n\n\nFunctions called once\n---------------------\nSuppose `f()` is called in just one place in the program\n(assuming we can verify this in LTO mode).\nIn this case we can replace the `RET` instruction with a `JMP` instruction\nwith the immediate constant for `RA`.\nThis will *precisely* enforce the return control flow no matter what is stored on stack.\n\nAnother variant is to compare `RA` on stack with the known constant and abort\nif they don't match; then `JMP` to the known constant address.\n\nFunctions called in a small number of call sites\n------------------------------------------------\nWe may extend the above approach to cases where `f()`\nis called more than once (but still a small number of times).\nWith LTO we know all possible values of `RA` and we check them\none-by-one (or using binary search) against the value on stack.\nIf the match is found, we `JMP` to the known constant address, otherwise abort.\n\nThis protection is *near-precise*, i.e. it guarantees that the control flow will\nbe transferred to one of the valid return addresses for this function,\nbut not necessary to the point of the most recent `CALL`.\n\nGeneral case\n------------\nFor functions called multiple times a *return jump table* is constructed\nin the same manner as jump tables for indirect function calls (see above).\nThe correct jump table entry (or it's index) is passed by `CALL` to `f()`\n(as an extra argument) and then spilled to stack.\nThe `RET` instruction is replaced with a load of the jump table entry,\njump table range check, and `JMP` to the jump table entry.\n\nThis protection is also *near-precise*.\n\nReturns from functions called indirectly\n----------------------------------------\n\nIf a function is called indirectly, the return jump table is constructed for the\nequivalence class of functions instead of a single function.\n\nCross-DSO calls\n---------------\nConsider two instrumented DSOs, `A` and `B`. `A` defines `f()` and `B` calls it.\n\nThis case will be handled similarly to the cross-DSO scheme using the slow path callback.\n\nNon-goals\n---------\n\nRCFI does not protect `RET` instructions:\n  * in non-instrumented DSOs,\n  * in instrumented DSOs for functions that are called from non-instrumented DSOs,\n  * embedded into other instructions (e.g. `0f4fc3 cmovg %ebx,%eax`).\n\n.. _SafeStack: https://clang.llvm.org/docs/SafeStack.html\n.. _RFG: http://xlab.tencent.com/en/2016/11/02/return-flow-guard\n.. _Intel CET: https://software.intel.com/en-us/blogs/2016/06/09/intel-release-new-technology-specifications-protect-rop-attacks\n\nHardware support\n================\n\nWe believe that the above design can be efficiently implemented in hardware.\nA single new instruction added to an ISA would allow to perform the forward-edge CFI check\nwith fewer bytes per check (smaller code size overhead) and potentially more\nefficiently. The current software-only instrumentation requires at least\n32-bytes per check (on x86_64).\nA hardware instruction may probably be less than ~ 12 bytes.\nSuch instruction would check that the argument pointer is in-bounds,\nand is properly aligned, and if the checks fail it will either trap (in monolithic scheme)\nor call the slow path function (cross-DSO scheme).\nThe bit vector lookup is probably too complex for a hardware implementation.\n\n.. code-block:: none\n\n  //  This instruction checks that 'Ptr'\n  //   * is aligned by (1 << kAlignment) and\n  //   * is inside [kRangeBeg, kRangeBeg+(kRangeSize<<kAlignment))\n  //  and if the check fails it jumps to the given target (slow path).\n  //\n  // 'Ptr' is a register, pointing to the virtual function table\n  //    or to the function which we need to check. We may require an explicit\n  //    fixed register to be used.\n  // 'kAlignment' is a 4-bit constant.\n  // 'kRangeSize' is a ~20-bit constant.\n  // 'kRangeBeg' is a PC-relative constant (~28 bits)\n  //    pointing to the beginning of the allowed range for 'Ptr'.\n  // 'kFailedCheckTarget': is a PC-relative constant (~28 bits)\n  //    representing the target to branch to when the check fails.\n  //    If kFailedCheckTarget==0, the process will trap\n  //    (monolithic binary scheme).\n  //    Otherwise it will jump to a handler that implements `CFI_SlowPath`\n  //    (cross-DSO scheme).\n  CFI_Check(Ptr, kAlignment, kRangeSize, kRangeBeg, kFailedCheckTarget) {\n     if (Ptr < kRangeBeg ||\n         Ptr >= kRangeBeg + (kRangeSize << kAlignment) ||\n         Ptr & ((1 << kAlignment) - 1))\n           Jump(kFailedCheckTarget);\n  }\n\nAn alternative and more compact encoding would not use `kFailedCheckTarget`,\nand will trap on check failure instead.\nThis will allow us to fit the instruction into **8-9 bytes**.\nThe cross-DSO checks will be performed by a trap handler and\nperformance-critical ones will have to be black-listed and checked using the\nsoftware-only scheme.\n\nNote that such hardware extension would be complementary to checks\nat the callee side, such as e.g. **Intel ENDBRANCH**.\nMoreover, CFI would have two benefits over ENDBRANCH: a) precision and b)\nability to protect against invalid casts between polymorphic types.\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/cling/lib/Utils/PlatformPosix.cpp": "//--------------------------------------------------------------------*- C++ -*-\n// CLING - the C++ LLVM-based InterpreterG :)\n// author: Roman Zulak\n//\n// This file is dual-licensed: you can choose to license it under the University\n// of Illinois Open Source License or the GNU Lesser General Public License. See\n// LICENSE.TXT for details.\n//------------------------------------------------------------------------------\n\n#include \"cling/Utils/Platform.h\"\n\n#if defined(LLVM_ON_UNIX)\n\n#include \"cling/Utils/Paths.h\"\n#include \"llvm/ADT/SmallString.h\"\n\n#include <array>\n#include <atomic>\n#include <string>\n#include <cxxabi.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/mman.h>\n\n// PATH_MAX\n#ifdef __APPLE__\n #include <sys/syslimits.h>\n#else\n #include <limits.h>\n#endif\n\n#define PATH_MAXC (PATH_MAX+1)\n\nnamespace cling {\nnamespace utils {\nnamespace platform {\n\nnamespace {\n  struct PointerCheck {\n  private:\n    // A simple round-robin cache: what enters first, leaves first.\n    // MRU cache wasn't worth the extra CPU cycles.\n    static thread_local std::array<const void*, 8> lines;\n    static thread_local unsigned mostRecent;\n    size_t page_size;\n    size_t page_mask;\n\n    // Concurrent writes to the same cache element can result in invalid cache\n    // elements, causing pointer address not being available in the cache even\n    // though they should be, i.e. false cache misses. While can cause a\n    // slow-down, the cost for keeping the cache thread-local or atomic is\n    // much higher (yes, this was measured).\n    void push(const void* P) {\n      mostRecent = (mostRecent + 1) % lines.size();\n      lines[mostRecent] = P;\n    }\n\n  public:\n    PointerCheck() : page_size(::sysconf(_SC_PAGESIZE)), page_mask(~(page_size - 1))\n    {\n       assert(IsPowerOfTwo(page_size));\n    }\n\n    bool operator () (const void* P) {\n      // std::find is considerably slower, do manual search instead.\n      if (P == lines[0] || P == lines[1] || P == lines[2] || P == lines[3]\n          || P == lines[4] || P == lines[5] || P == lines[6] || P == lines[7])\n        return true;\n\n      // Address of page containing P, assuming page_size is a power of 2\n      void *base = (void *)(((const size_t)P) & page_mask);\n\n      // P is invalid only when msync returns -1 and sets errno to ENOMEM\n      if (::msync(base, page_size, MS_ASYNC) != 0) {\n        assert(errno == ENOMEM && \"Unexpected error in call to msync()\");\n        return false;\n      }\n\n      push(P);\n      return true;\n    }\n  private:\n    bool IsPowerOfTwo(size_t n) {\n       /* While n is even and larger than 1, divide by 2 */\n       while (((n & 1) == 0) && n > 1)\n         n >>= 1;\n       return n == 1;\n    }\n  };\n  thread_local std::array<const void*, 8> PointerCheck::lines = {};\n  thread_local unsigned PointerCheck::mostRecent = 0;\n}\n\nbool IsMemoryValid(const void *P) {\n  static PointerCheck sPointerCheck;\n  return sPointerCheck(P);\n}\n\nstd::string GetCwd() {\n  char Buffer[PATH_MAXC];\n  if (::getcwd(Buffer, sizeof(Buffer)))\n    return Buffer;\n\n  ::perror(\"Could not get current working directory\");\n  return std::string();\n}\n\nstatic void DLErr(std::string* Err) {\n  if (!Err)\n    return;\n  if (const char* DyLibError = ::dlerror())\n    *Err = DyLibError;\n}\n\nconst void* DLOpen(const std::string& Path, std::string* Err) {\n  void* Lib = dlopen(Path.c_str(), RTLD_LAZY|RTLD_GLOBAL);\n  DLErr(Err);\n  return Lib;\n}\n\nconst void* DLSym(const std::string& Name, std::string* Err) {\n  if (const void* Self = ::dlopen(nullptr, RTLD_GLOBAL)) {\n    // get dlopen error if there is one\n    DLErr(Err);\n    const void* Sym = ::dlsym(const_cast<void*>(Self), Name.c_str());\n    // overwrite error if dlsym caused one\n    DLErr(Err);\n    // only get dlclose error if dlopen & dlsym haven't emited one\n    DLClose(Self, Err && Err->empty() ? Err : nullptr);\n    return Sym;\n  }\n  DLErr(Err);\n  return nullptr;\n}\n\nvoid DLClose(const void* Lib, std::string* Err) {\n  ::dlclose(const_cast<void*>(Lib));\n  DLErr(Err);\n}\n\nstd::string NormalizePath(const std::string& Path) {\n  char Buf[PATH_MAXC];\n  if (const char* Result = ::realpath(Path.c_str(), Buf))\n    return std::string(Result);\n\n  ::perror(\"realpath\");\n  return std::string();\n}\n\nbool Popen(const std::string& Cmd, llvm::SmallVectorImpl<char>& Buf, bool RdE) {\n  if (FILE *PF = ::popen(RdE ? (Cmd + \" 2>&1\").c_str() : Cmd.c_str(), \"r\")) {\n    Buf.resize(0);\n    const size_t Chunk = Buf.capacity_in_bytes();\n    while (true) {\n      const size_t Len = Buf.size();\n      Buf.resize(Len + Chunk);\n      const size_t R = ::fread(&Buf[Len], sizeof(char), Chunk, PF);\n      if (R < Chunk) {\n        Buf.resize(Len + R);\n        break;\n      }\n    }\n    ::pclose(PF);\n    return !Buf.empty();\n  }\n  return false;\n}\n\nbool GetSystemLibraryPaths(llvm::SmallVectorImpl<std::string>& Paths) {\n#if defined(__APPLE__) || defined(__CYGWIN__)\n  Paths.push_back(\"/usr/local/lib/\");\n  Paths.push_back(\"/usr/X11R6/lib/\");\n  Paths.push_back(\"/usr/lib/\");\n  Paths.push_back(\"/lib/\");\n\n #ifndef __APPLE__\n  Paths.push_back(\"/lib/x86_64-linux-gnu/\");\n  Paths.push_back(\"/usr/local/lib64/\");\n  Paths.push_back(\"/usr/lib64/\");\n  Paths.push_back(\"/lib64/\");\n #endif\n#else\n  llvm::SmallString<1024> Buf;\n  platform::Popen(\"LD_DEBUG=libs LD_PRELOAD=DOESNOTEXIST ls\", Buf, true);\n  const llvm::StringRef Result = Buf.str();\n\n  const std::size_t NPos = std::string::npos;\n  const std::size_t LD = Result.find(\"(LD_LIBRARY_PATH)\");\n  std::size_t From = Result.find(\"search path=\", LD == NPos ? 0 : LD);\n  if (From != NPos) {\n    const std::size_t To = Result.find(\"(system search path)\", From);\n    if (To != NPos) {\n      From += 12;\n      std::string SysPath = Result.substr(From, To-From);\n      SysPath.erase(std::remove_if(SysPath.begin(), SysPath.end(), isspace),\n                    SysPath.end());\n\n      llvm::SmallVector<llvm::StringRef, 10> CurPaths;\n      SplitPaths(SysPath, CurPaths);\n      for (const auto& Path : CurPaths)\n        Paths.push_back(Path.str());\n    }\n  }\n#endif\n  return true;\n}\n\nstd::string Demangle(const std::string& Symbol) {\n  struct AutoFree {\n    char* Str;\n    AutoFree(char* Ptr) : Str(Ptr) {}\n    ~AutoFree() { ::free(Str); };\n  };\n  int status = 0;\n  // Some implementations of __cxa_demangle are giving back length of allocation\n  // Passing NULL for length seems to guarantee null termination.\n  AutoFree af(abi::__cxa_demangle(Symbol.c_str(), NULL, NULL, &status));\n  return status == 0 ? std::string(af.Str) : std::string();\n}\n\n} // namespace platform\n} // namespace utils\n} // namespace cling\n\n#endif // LLVM_ON_UNIX\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/cling/lib/Interpreter/IncrementalParser.cpp": "//------------------------------------------------------------------------------\n// CLING - the C++ LLVM-based InterpreterG :)\n// author:  Axel Naumann <axel@cern.ch>\n//\n// This file is dual-licensed: you can choose to license it under the University\n// of Illinois Open Source License or the GNU Lesser General Public License. See\n// LICENSE.TXT for details.\n//------------------------------------------------------------------------------\n\n#include \"IncrementalParser.h\"\n\n#include \"ASTTransformer.h\"\n#include \"AutoSynthesizer.h\"\n#include \"BackendPasses.h\"\n#include \"CheckEmptyTransactionTransformer.h\"\n#include \"ClingPragmas.h\"\n#include \"DeclCollector.h\"\n#include \"DeclExtractor.h\"\n#include \"DefinitionShadower.h\"\n#include \"DeviceKernelInliner.h\"\n#include \"DynamicLookup.h\"\n#include \"IncrementalExecutor.h\"\n#include \"NullDerefProtectionTransformer.h\"\n#include \"TransactionPool.h\"\n#include \"ValueExtractionSynthesizer.h\"\n#include \"ValuePrinterSynthesizer.h\"\n#include \"cling/Interpreter/CIFactory.h\"\n#include \"cling/Interpreter/Interpreter.h\"\n#include \"cling/Interpreter/InterpreterCallbacks.h\"\n#include \"cling/Interpreter/Transaction.h\"\n#include \"cling/Utils/Diagnostics.h\"\n#include \"cling/Utils/Output.h\"\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclGroup.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/FileManager.h\"\n#include \"clang/CodeGen/ModuleBuilder.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/Frontend/FrontendDiagnostic.h\"\n#include \"clang/Frontend/FrontendPluginRegistry.h\"\n#include \"clang/Frontend/MultiplexConsumer.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"clang/Lex/PreprocessorOptions.h\"\n#include \"clang/Parse/Parser.h\"\n#include \"clang/Sema/Sema.h\"\n#include \"clang/Sema/SemaDiagnostic.h\"\n#include \"clang/Serialization/ASTWriter.h\"\n#include \"clang/Serialization/ASTReader.h\"\n#include \"llvm/Support/Path.h\"\n\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/Support/CrashRecoveryContext.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n\n#include <stdio.h>\n\nusing namespace clang;\n\nnamespace {\n\n  ///\\brief Check the compile-time C++ ABI version vs the run-time ABI version,\n  /// a mismatch could cause havoc. Reports if ABI versions differ.\n  static bool CheckABICompatibility(cling::Interpreter& Interp) {\n#if defined(__GLIBCXX__)\n    #define CLING_CXXABI_VERS       std::to_string(__GLIBCXX__)\n    const char* CLING_CXXABI_NAME = \"__GLIBCXX__\";\n    static constexpr bool CLING_CXXABI_BACKWARDCOMP = true;\n#elif defined(_LIBCPP_VERSION)\n    #define CLING_CXXABI_VERS       std::to_string(_LIBCPP_ABI_VERSION)\n    const char* CLING_CXXABI_NAME = \"_LIBCPP_ABI_VERSION\";\n    static constexpr bool CLING_CXXABI_BACKWARDCOMP = false;\n#elif defined(_CRT_MSVCP_CURRENT)\n    #define CLING_CXXABI_VERS        _CRT_MSVCP_CURRENT\n    const char* CLING_CXXABI_NAME = \"_CRT_MSVCP_CURRENT\";\n    static constexpr bool CLING_CXXABI_BACKWARDCOMP = false;\n#else\n    #error \"Unknown platform for ABI check\";\n#endif\n\n    const std::string CurABI = Interp.getMacroValue(CLING_CXXABI_NAME);\n    if (CurABI == CLING_CXXABI_VERS)\n      return true;\n    if (CurABI.empty()) {\n    cling::errs() <<\n      \"Warning in cling::IncrementalParser::CheckABICompatibility():\\n\"\n      \"  Failed to extract C++ standard library version.\\n\";\n    }\n\n    if (CLING_CXXABI_BACKWARDCOMP && CurABI < CLING_CXXABI_VERS) {\n       // Backward compatible ABIs allow us to interpret old headers\n       // against a newer stdlib.so.\n       return true;\n    }\n\n    cling::errs() <<\n      \"Warning in cling::IncrementalParser::CheckABICompatibility():\\n\"\n      \"  Possible C++ standard library mismatch, compiled with \"\n      << CLING_CXXABI_NAME << \" '\" << CLING_CXXABI_VERS << \"'\\n\"\n      \"  Extraction of runtime standard library version was: '\"\n      << CurABI << \"'\\n\";\n\n    return false;\n  }\n\n  class FilteringDiagConsumer : public cling::utils::DiagnosticsOverride {\n    std::stack<bool> m_IgnorePromptDiags;\n\n    void SyncDiagCountWithTarget() {\n      NumWarnings = m_PrevClient.getNumWarnings();\n      NumErrors = m_PrevClient.getNumErrors();\n    }\n\n    void BeginSourceFile(const LangOptions &LangOpts,\n                         const Preprocessor *PP=nullptr) override {\n      m_PrevClient.BeginSourceFile(LangOpts, PP);\n    }\n\n    void EndSourceFile() override {\n      m_PrevClient.EndSourceFile();\n      SyncDiagCountWithTarget();\n    }\n\n    void finish() override {\n      m_PrevClient.finish();\n      SyncDiagCountWithTarget();\n    }\n\n    void clear() override {\n      m_PrevClient.clear();\n      SyncDiagCountWithTarget();\n    }\n\n    bool IncludeInDiagnosticCounts() const override {\n      return m_PrevClient.IncludeInDiagnosticCounts();\n    }\n\n    void HandleDiagnostic(DiagnosticsEngine::Level DiagLevel,\n                          const Diagnostic &Info) override {\n      if (Ignoring()) {\n        if (Info.getID() == diag::warn_unused_expr\n            || Info.getID() == diag::warn_unused_call\n            || Info.getID() == diag::warn_unused_comparison)\n          return; // ignore!\n        if (Info.getID() == diag::warn_falloff_nonvoid_function) {\n          DiagLevel = DiagnosticsEngine::Error;\n        }\n        if (Info.getID() == diag::ext_return_has_expr) {\n          // An error that we need to suppress.\n          auto Diags = const_cast<DiagnosticsEngine*>(Info.getDiags());\n          assert(Diags->hasErrorOccurred() && \"Expected ErrorOccurred\");\n          if (m_PrevClient.getNumErrors() == 0) { // first error\n            Diags->Reset(true /*soft - only counts, not mappings*/);\n          } // else we had other errors, too.\n          return; // ignore!\n        }\n      }\n      m_PrevClient.HandleDiagnostic(DiagLevel, Info);\n      SyncDiagCountWithTarget();\n    }\n\n    bool Ignoring() const {\n      return !m_IgnorePromptDiags.empty() && m_IgnorePromptDiags.top();\n    }\n\n  public:\n    FilteringDiagConsumer(DiagnosticsEngine& Diags, bool Own) :\n      DiagnosticsOverride(Diags, Own) {\n    }\n\n    struct RAAI {\n      FilteringDiagConsumer& m_Client;\n      RAAI(DiagnosticConsumer& F, bool Ignore) :\n       m_Client(static_cast<FilteringDiagConsumer&>(F)) {\n        m_Client.m_IgnorePromptDiags.push(Ignore);\n      }\n      ~RAAI() { m_Client.m_IgnorePromptDiags.pop(); }\n    };\n  };\n} // unnamed namespace\n\nstatic void HandlePlugins(CompilerInstance& CI,\n                         std::vector<std::unique_ptr<ASTConsumer>>& Consumers) {\n  // Copied from Frontend/FrontendAction.cpp.\n  // FIXME: Remove when we switch to a tools-based cling driver.\n\n  // If the FrontendPluginRegistry has plugins before loading any shared library\n  // this means we have linked our plugins. This is useful when cling runs in\n  // embedded mode (in a shared library). This is the only feasible way to have\n  // plugins if cling is in a single shared library which is dlopen-ed with\n  // RTLD_LOCAL. In that situation plugins can still find the cling, clang and\n  // llvm symbols opened with local visibility.\n  if (FrontendPluginRegistry::begin() == FrontendPluginRegistry::end()) {\n    for (const std::string& Path : CI.getFrontendOpts().Plugins) {\n      std::string Err;\n      if (llvm::sys::DynamicLibrary::LoadLibraryPermanently(Path.c_str(), &Err))\n        CI.getDiagnostics().Report(clang::diag::err_fe_unable_to_load_plugin)\n          << Path << Err;\n    }\n    // If we are not statically linked, we should register the pragmas ourselves\n    // because the dlopen happens after creating the clang::Preprocessor which\n    // calls RegisterBuiltinPragmas.\n    // FIXME: This can be avoided by refactoring our routine and moving it to\n    // the CIFactory. This requires an abstraction which allows us to\n    // conditionally create MultiplexingConsumers.\n\n    // Copied from Lex/Pragma.cpp\n    // Pragmas added by plugins\n    for (PragmaHandlerRegistry::iterator it = PragmaHandlerRegistry::begin(),\n           ie = PragmaHandlerRegistry::end(); it != ie; ++it)\n      CI.getPreprocessor().AddPragmaHandler(it->instantiate().release());\n  }\n\n  for (auto it = clang::FrontendPluginRegistry::begin(),\n         ie = clang::FrontendPluginRegistry::end();\n       it != ie; ++it) {\n    std::unique_ptr<clang::PluginASTAction> P(it->instantiate());\n\n    PluginASTAction::ActionType PluginActionType = P->getActionType();\n    assert(PluginActionType != clang::PluginASTAction::ReplaceAction);\n\n    if (P->ParseArgs(CI, CI.getFrontendOpts().PluginArgs[it->getName()])) {\n      std::unique_ptr<ASTConsumer> PluginConsumer\n        = P->CreateASTConsumer(CI, /*InputFile*/ \"\");\n      if (PluginActionType == clang::PluginASTAction::AddBeforeMainAction)\n        Consumers.insert(Consumers.begin(), std::move(PluginConsumer));\n      else\n        Consumers.push_back(std::move(PluginConsumer));\n    }\n  }\n}\n\nnamespace cling {\n  IncrementalParser::IncrementalParser(Interpreter* interp, const char* llvmdir,\n                                   const ModuleFileExtensions& moduleExtensions)\n      : m_Interpreter(interp) {\n    std::unique_ptr<cling::DeclCollector> consumer;\n    consumer.reset(m_Consumer = new cling::DeclCollector());\n    m_CI.reset(CIFactory::createCI(\"\", interp->getOptions(), llvmdir,\n                                   std::move(consumer), moduleExtensions));\n\n    if (!m_CI) {\n      cling::errs() << \"Compiler instance could not be created.\\n\";\n      return;\n    }\n    // Is the CompilerInstance being used to generate output only?\n    if (m_Interpreter->getOptions().CompilerOpts.HasOutput)\n      return;\n\n    if (!m_Consumer) {\n      cling::errs() << \"No AST consumer available.\\n\";\n      return;\n    }\n\n\n    std::vector<std::unique_ptr<ASTConsumer>> Consumers;\n    HandlePlugins(*m_CI, Consumers);\n    std::unique_ptr<ASTConsumer> WrappedConsumer;\n\n    DiagnosticsEngine& Diag = m_CI->getDiagnostics();\n    if (m_CI->getFrontendOpts().ProgramAction != frontend::ParseSyntaxOnly) {\n      auto CG\n        = std::unique_ptr<clang::CodeGenerator>(CreateLLVMCodeGen(Diag,\n                                                               makeModuleName(),\n                                                    m_CI->getHeaderSearchOpts(),\n                                                    m_CI->getPreprocessorOpts(),\n                                                         m_CI->getCodeGenOpts(),\n                                               *m_Interpreter->getLLVMContext())\n                                                );\n      m_CodeGen = CG.get();\n      assert(m_CodeGen);\n      if (!Consumers.empty()) {\n        Consumers.push_back(std::move(CG));\n        WrappedConsumer.reset(new MultiplexConsumer(std::move(Consumers)));\n      }\n      else\n        WrappedConsumer = std::move(CG);\n    }\n\n    // Initialize the DeclCollector and add callbacks keeping track of macros.\n    m_Consumer->Setup(this, std::move(WrappedConsumer), m_CI->getPreprocessor());\n\n    m_DiagConsumer.reset(new FilteringDiagConsumer(Diag, false));\n\n    initializeVirtualFile();\n  }\n\n  bool\n  IncrementalParser::Initialize(llvm::SmallVectorImpl<ParseResultTransaction>&\n                                result, bool isChildInterpreter) {\n    m_TransactionPool.reset(new TransactionPool);\n    if (hasCodeGenerator())\n      getCodeGenerator()->Initialize(getCI()->getASTContext());\n\n    CompilationOptions CO = m_Interpreter->makeDefaultCompilationOpts();\n    Transaction* CurT = beginTransaction(CO);\n    Preprocessor& PP = m_CI->getPreprocessor();\n    DiagnosticsEngine& Diags = m_CI->getSema().getDiagnostics();\n\n    // Pull in PCH.\n    const std::string& PCHFileName\n      = m_CI->getInvocation().getPreprocessorOpts().ImplicitPCHInclude;\n    if (!PCHFileName.empty()) {\n      Transaction* PchT = beginTransaction(CO);\n      DiagnosticErrorTrap Trap(Diags);\n      m_CI->createPCHExternalASTSource(PCHFileName,\n                                       true /*DisablePCHValidation*/,\n                                       true /*AllowPCHWithCompilerErrors*/,\n                                       0 /*DeserializationListener*/,\n                                       true /*OwnsDeserializationListener*/);\n      result.push_back(endTransaction(PchT));\n      if (Trap.hasErrorOccurred()) {\n        result.push_back(endTransaction(CurT));\n        return false;\n      }\n    }\n\n    addClingPragmas(*m_Interpreter);\n\n    // Must happen after attaching the PCH, else PCH elements will end up\n    // being lexed.\n    PP.EnterMainSourceFile();\n\n    Sema* TheSema = &m_CI->getSema();\n    m_Parser.reset(new Parser(PP, *TheSema, false /*skipFuncBodies*/));\n\n    // Initialize the parser after PP has entered the main source file.\n    m_Parser->Initialize();\n\n    ExternalASTSource *External = TheSema->getASTContext().getExternalSource();\n    if (External)\n      External->StartTranslationUnit(m_Consumer);\n\n    // Start parsing the \"main file\" to warm up lexing (enter caching lex mode\n    // for ParseInternal()'s call EnterSourceFile() to make sense.\n    while (!m_Parser->ParseTopLevelDecl()) {}\n\n    // If I belong to the parent Interpreter, am using C++, and -noruntime\n    // wasn't given on command line, then #include <new> and check ABI\n    if (!isChildInterpreter && m_CI->getLangOpts().CPlusPlus &&\n        !m_Interpreter->getOptions().NoRuntime) {\n      // <new> is needed by the ValuePrinter so it's a good thing to include it.\n      // We need to include it to determine the version number of the standard\n      // library implementation.\n      ParseInternal(\"#include <new>\");\n      // That's really C++ ABI compatibility. C has other problems ;-)\n      CheckABICompatibility(*m_Interpreter);\n    }\n\n    // DO NOT commit the transactions here: static initialization in these\n    // transactions requires gCling through local_cxa_atexit(), but that has not\n    // been defined yet!\n    ParseResultTransaction PRT = endTransaction(CurT);\n    result.push_back(PRT);\n    return true;\n  }\n\n  bool IncrementalParser::isValid(bool initialized) const {\n    return m_CI && m_CI->hasFileManager() && m_Consumer\n           && !m_VirtualFileID.isInvalid()\n           && (!initialized || (m_TransactionPool && m_Parser));\n  }\n\n  namespace {\n    template <class T>\n    struct Reversed {\n      const T &m_orig;\n      auto begin() -> decltype(m_orig.rbegin()) { return m_orig.rbegin(); }\n      auto end() -> decltype (m_orig.rend()) { return m_orig.rend(); }\n    };\n    template <class T>\n    Reversed<T> reverse(const T& orig) { return {orig}; }\n  }\n\n  const Transaction* IncrementalParser::getLastWrapperTransaction() const {\n    if (auto *T = getCurrentTransaction())\n      if (T->getWrapperFD())\n        return T;\n\n    for (auto T: reverse(m_Transactions))\n      if (T->getWrapperFD())\n        return T;\n    return nullptr;\n  }\n\n  const Transaction* IncrementalParser::getCurrentTransaction() const {\n    return m_Consumer->getTransaction();\n  }\n\n  SourceLocation IncrementalParser::getLastMemoryBufferEndLoc() const {\n    const SourceManager& SM = getCI()->getSourceManager();\n    SourceLocation Result = SM.getLocForStartOfFile(m_VirtualFileID);\n    return Result.getLocWithOffset(m_MemoryBuffers.size() + 1);\n  }\n\n  IncrementalParser::~IncrementalParser() {\n    Transaction* T = const_cast<Transaction*>(getFirstTransaction());\n    while (T) {\n      assert((T->getState() == Transaction::kCommitted\n              || T->getState() == Transaction::kRolledBackWithErrors\n              || T->getState() == Transaction::kNumStates // reset from the pool\n              || T->getState() == Transaction::kRolledBack)\n             && \"Not committed?\");\n      const Transaction* nextT = T->getNext();\n      m_TransactionPool->releaseTransaction(T, false);\n      T = const_cast<Transaction*>(nextT);\n    }\n  }\n\n  void IncrementalParser::addTransaction(Transaction* T) {\n    if (!T->isNestedTransaction() && T != getLastTransaction()) {\n      if (getLastTransaction())\n        m_Transactions.back()->setNext(T);\n      m_Transactions.push_back(T);\n    }\n  }\n\n\n  Transaction* IncrementalParser::beginTransaction(const CompilationOptions&\n                                                   Opts) {\n    Transaction* OldCurT = m_Consumer->getTransaction();\n    Transaction* NewCurT = m_TransactionPool->takeTransaction(m_CI->getSema());\n    NewCurT->setCompilationOpts(Opts);\n    // If we are in the middle of transaction and we see another begin\n    // transaction - it must be nested transaction.\n    if (OldCurT && OldCurT != NewCurT\n        && (OldCurT->getState() == Transaction::kCollecting\n            || OldCurT->getState() == Transaction::kCompleted)) {\n      OldCurT->addNestedTransaction(NewCurT); // takes the ownership\n    }\n\n    m_Consumer->setTransaction(NewCurT);\n    return NewCurT;\n  }\n\n  IncrementalParser::ParseResultTransaction\n  IncrementalParser::endTransaction(Transaction* T) {\n    assert(T && \"Null transaction!?\");\n    assert(T->getState() == Transaction::kCollecting);\n\n#ifndef NDEBUG\n    if (T->hasNestedTransactions()) {\n      for(Transaction::const_nested_iterator I = T->nested_begin(),\n            E = T->nested_end(); I != E; ++I)\n        assert((*I)->isCompleted() && \"Nested transaction not completed!?\");\n    }\n#endif\n\n    T->setState(Transaction::kCompleted);\n\n    DiagnosticsEngine& Diag = getCI()->getSema().getDiagnostics();\n\n    //TODO: Make the enum orable.\n    EParseResult ParseResult = kSuccess;\n\n    assert((Diag.hasFatalErrorOccurred() ? Diag.hasErrorOccurred() : true)\n            && \"Diag.hasFatalErrorOccurred without Diag.hasErrorOccurred !\");\n\n    if (Diag.hasErrorOccurred() || T->getIssuedDiags() == Transaction::kErrors) {\n      T->setIssuedDiags(Transaction::kErrors);\n      ParseResult = kFailed;\n    } else if (Diag.getNumWarnings() > 0) {\n      T->setIssuedDiags(Transaction::kWarnings);\n      ParseResult = kSuccessWithWarnings;\n    }\n\n    // Empty transaction, send it back to the pool.\n    if (T->empty()) {\n      assert((!m_Consumer->getTransaction()\n              || (m_Consumer->getTransaction() == T))\n             && \"Cannot release different T\");\n      // If a nested transaction the active one should be its parent\n      // from now on. FIXME: Merge conditional with commitTransaction\n      if (T->isNestedTransaction())\n        m_Consumer->setTransaction(T->getParent());\n      else\n        m_Consumer->setTransaction((Transaction*)0);\n\n      m_TransactionPool->releaseTransaction(T);\n      return ParseResultTransaction(nullptr, ParseResult);\n    }\n\n    addTransaction(T);\n    return ParseResultTransaction(T, ParseResult);\n  }\n\n  std::string IncrementalParser::makeModuleName() {\n    return std::string(\"cling-module-\") + std::to_string(m_ModuleNo++);\n  }\n\n  llvm::Module* IncrementalParser::StartModule() {\n    return getCodeGenerator()->StartModule(makeModuleName(),\n                                           *m_Interpreter->getLLVMContext(),\n                                           getCI()->getCodeGenOpts());\n  }\n\n  void IncrementalParser::commitTransaction(ParseResultTransaction& PRT,\n                                            bool ClearDiagClient) {\n    Transaction* T = PRT.getPointer();\n    if (!T) {\n      if (PRT.getInt() != kSuccess) {\n        // Nothing has been emitted to Codegen, reset the Diags.\n        DiagnosticsEngine& Diags = getCI()->getSema().getDiagnostics();\n        Diags.Reset(/*soft=*/true);\n        if (ClearDiagClient)\n          Diags.getClient()->clear();\n      }\n      return;\n    }\n\n    assert(T->isCompleted() && \"Transaction not ended!?\");\n    assert(T->getState() != Transaction::kCommitted\n           && \"Committing an already committed transaction.\");\n    assert((T->getIssuedDiags() == Transaction::kErrors || !T->empty())\n           && \"Valid Transactions must not be empty;\");\n\n    // If committing a nested transaction the active one should be its parent\n    // from now on.\n    if (T->isNestedTransaction())\n      m_Consumer->setTransaction(T->getParent());\n\n    // Check for errors...\n    if (T->getIssuedDiags() == Transaction::kErrors) {\n      // Make module visible to TransactionUnloader.\n      bool MustStartNewModule = false;\n      if (!T->isNestedTransaction() && hasCodeGenerator()) {\n        MustStartNewModule = true;\n        std::unique_ptr<llvm::Module> M(getCodeGenerator()->ReleaseModule());\n\n        if (M) {\n          T->setModule(std::move(M));\n        }\n      }\n      // Module has been released from Codegen, reset the Diags now.\n      DiagnosticsEngine& Diags = getCI()->getSema().getDiagnostics();\n      Diags.Reset(/*soft=*/true);\n      if (ClearDiagClient)\n        Diags.getClient()->clear();\n\n      PRT.setPointer(nullptr);\n      PRT.setInt(kFailed);\n      m_Interpreter->unload(*T);\n\n      // Create a new module if necessary.\n      if (MustStartNewModule)\n        StartModule();\n\n      return;\n    }\n\n    if (T->hasNestedTransactions()) {\n      Transaction* TopmostParent = T->getTopmostParent();\n      EParseResult PR = kSuccess;\n      if (TopmostParent->getIssuedDiags() == Transaction::kErrors)\n        PR = kFailed;\n      else if (TopmostParent->getIssuedDiags() == Transaction::kWarnings)\n        PR = kSuccessWithWarnings;\n\n      for (Transaction::const_nested_iterator I = T->nested_begin(),\n            E = T->nested_end(); I != E; ++I)\n        if ((*I)->getState() != Transaction::kCommitted) {\n          ParseResultTransaction PRT(*I, PR);\n          commitTransaction(PRT);\n        }\n    }\n\n    // If there was an error coming from the transformers.\n    if (T->getIssuedDiags() == Transaction::kErrors) {\n      m_Interpreter->unload(*T);\n      return;\n    }\n\n    // Here we expect a template instantiation. We need to open the transaction\n    // that we are currently work with.\n    {\n      Transaction* prevConsumerT = m_Consumer->getTransaction();\n      m_Consumer->setTransaction(T);\n      Transaction* nestedT = beginTransaction(T->getCompilationOpts());\n      // Pull all template instantiations in that came from the consumers.\n      getCI()->getSema().PerformPendingInstantiations();\n#ifdef LLVM_ON_WIN32\n      // Microsoft-specific:\n      // Late parsed templates can leave unswallowed \"macro\"-like tokens.\n      // They will seriously confuse the Parser when entering the next\n      // source file. So lex until we are EOF.\n      Token Tok;\n      Tok.setKind(tok::eof);\n      do {\n        getCI()->getSema().getPreprocessor().Lex(Tok);\n      } while (Tok.isNot(tok::eof));\n#endif\n\n      ParseResultTransaction nestedPRT = endTransaction(nestedT);\n      commitTransaction(nestedPRT);\n      m_Consumer->setTransaction(prevConsumerT);\n    }\n    m_Consumer->HandleTranslationUnit(getCI()->getASTContext());\n\n\n    // The static initializers might run anything and can thus cause more\n    // decls that need to end up in a transaction. But this one is done\n    // with CodeGen...\n    if (T->getCompilationOpts().CodeGeneration && hasCodeGenerator()) {\n      Transaction* prevConsumerT = m_Consumer->getTransaction();\n      m_Consumer->setTransaction(T);\n      codeGenTransaction(T);\n      T->setState(Transaction::kCommitted);\n      if (!T->getParent()) {\n        if (m_Interpreter->executeTransaction(*T)\n            >= Interpreter::kExeFirstError) {\n          // Roll back on error in initializers.\n          // T maybe pointing to freed memory after this call:\n          // Interpreter::unload\n          //   IncrementalParser::deregisterTransaction\n          //     TransactionPool::releaseTransaction\n          m_Interpreter->unload(*T);\n          return;\n        }\n      }\n      m_Consumer->setTransaction(prevConsumerT);\n    }\n    T->setState(Transaction::kCommitted);\n\n    {\n      Transaction* prevConsumerT = m_Consumer->getTransaction();\n      if (InterpreterCallbacks* callbacks = m_Interpreter->getCallbacks())\n        callbacks->TransactionCommitted(*T);\n      m_Consumer->setTransaction(prevConsumerT);\n    }\n  }\n\n  void IncrementalParser::emitTransaction(Transaction* T) {\n    for (auto DI = T->decls_begin(), DE = T->decls_end(); DI != DE; ++DI)\n      m_Consumer->HandleTopLevelDecl(DI->m_DGR);\n  }\n\n  void IncrementalParser::codeGenTransaction(Transaction* T) {\n    // codegen the transaction\n    assert(T->getCompilationOpts().CodeGeneration && \"CodeGen turned off\");\n    assert(T->getState() == Transaction::kCompleted && \"Must be completed\");\n    assert(hasCodeGenerator() && \"No CodeGen\");\n\n    // Could trigger derserialization of decls.\n    Transaction* deserT = beginTransaction(CompilationOptions());\n\n\n    // Commit this transaction first - T might need symbols from it, so\n    // trigger emission of weak symbols by providing use.\n    ParseResultTransaction PRT = endTransaction(deserT);\n    commitTransaction(PRT);\n    deserT = PRT.getPointer();\n\n    // This llvm::Module is done; finalize it and pass it to the execution\n    // engine.\n    if (!T->isNestedTransaction() && hasCodeGenerator()) {\n      // The initializers are emitted to the symbol \"_GLOBAL__sub_I_\" + filename.\n      // Make that unique!\n      deserT = beginTransaction(CompilationOptions());\n      // Reset the module builder to clean up global initializers, c'tors, d'tors\n      getCodeGenerator()->HandleTranslationUnit(getCI()->getASTContext());\n      auto PRT = endTransaction(deserT);\n      commitTransaction(PRT);\n      deserT = PRT.getPointer();\n\n      std::unique_ptr<llvm::Module> M(getCodeGenerator()->ReleaseModule());\n\n      if (M)\n        T->setModule(std::move(M));\n\n      if (T->getIssuedDiags() != Transaction::kNone) {\n        // Module has been released from Codegen, reset the Diags now.\n        DiagnosticsEngine& Diags = getCI()->getSema().getDiagnostics();\n        Diags.Reset(/*soft=*/true);\n        Diags.getClient()->clear();\n      }\n\n      // Create a new module.\n      StartModule();\n    }\n  }\n\n  void IncrementalParser::deregisterTransaction(Transaction& T) {\n    if (&T == m_Consumer->getTransaction())\n      m_Consumer->setTransaction(T.getParent());\n\n    if (Transaction* Parent = T.getParent()) {\n      Parent->removeNestedTransaction(&T);\n      T.setParent(0);\n    } else {\n      // Remove from the queue\n      assert(&T == m_Transactions.back() && \"Out of order transaction removal\");\n      m_Transactions.pop_back();\n      if (!m_Transactions.empty())\n        m_Transactions.back()->setNext(0);\n    }\n\n    m_TransactionPool->releaseTransaction(&T);\n  }\n\n  std::vector<const Transaction*> IncrementalParser::getAllTransactions() {\n    std::vector<const Transaction*> result(m_Transactions.size());\n    const cling::Transaction* T = getFirstTransaction();\n    while (T) {\n      result.push_back(T);\n      T = T->getNext();\n    }\n    return result;\n  }\n\n  // Each input line is contained in separate memory buffer. The SourceManager\n  // assigns sort-of invalid FileID for each buffer, i.e there is no FileEntry\n  // for the MemoryBuffer's FileID. That in turn is problem because invalid\n  // SourceLocations are given to the diagnostics. Thus the diagnostics cannot\n  // order the overloads, for example\n  //\n  // Our work-around is creating a virtual file, which doesn't exist on the disk\n  // with enormous size (no allocation is done). That file has valid FileEntry\n  // and so on... We use it for generating valid SourceLocations with valid\n  // offsets so that it doesn't cause any troubles to the diagnostics.\n  //\n  // +---------------------+\n  // | Main memory buffer  |\n  // +---------------------+\n  // |  Virtual file SLoc  |\n  // |    address space    |<-----------------+\n  // |         ...         |<------------+    |\n  // |         ...         |             |    |\n  // |         ...         |<----+       |    |\n  // |         ...         |     |       |    |\n  // +~~~~~~~~~~~~~~~~~~~~~+     |       |    |\n  // |     input_line_1    | ....+.......+..--+\n  // +---------------------+     |       |\n  // |     input_line_2    | ....+.....--+\n  // +---------------------+     |\n  // |          ...        |     |\n  // +---------------------+     |\n  // |     input_line_N    | ..--+\n  // +---------------------+\n  //\n  void IncrementalParser::initializeVirtualFile() {\n    SourceManager& SM = getCI()->getSourceManager();\n    m_VirtualFileID = SM.getMainFileID();\n    if (m_VirtualFileID.isInvalid())\n      cling::errs() << \"VirtualFileID could not be created.\\n\";\n  }\n\n  IncrementalParser::ParseResultTransaction\n  IncrementalParser::Compile(llvm::StringRef input,\n                             const CompilationOptions& Opts) {\n    Transaction* CurT = beginTransaction(Opts);\n    EParseResult ParseRes = ParseInternal(input);\n\n    if (ParseRes == kSuccessWithWarnings)\n      CurT->setIssuedDiags(Transaction::kWarnings);\n    else if (ParseRes == kFailed)\n      CurT->setIssuedDiags(Transaction::kErrors);\n\n    ParseResultTransaction PRT = endTransaction(CurT);\n    commitTransaction(PRT);\n\n    return PRT;\n  }\n\n  // Add the input to the memory buffer, parse it, and add it to the AST.\n  IncrementalParser::EParseResult\n  IncrementalParser::ParseInternal(llvm::StringRef input) {\n    if (input.empty()) return IncrementalParser::kSuccess;\n\n    Sema& S = getCI()->getSema();\n\n    const CompilationOptions& CO\n       = m_Consumer->getTransaction()->getCompilationOpts();\n\n    // Recover resources if we crash before exiting this method.\n    llvm::CrashRecoveryContextCleanupRegistrar<Sema> CleanupSema(&S);\n\n    Preprocessor& PP = m_CI->getPreprocessor();\n    if (!PP.getCurrentLexer()) {\n       PP.EnterSourceFile(m_CI->getSourceManager().getMainFileID(),\n                          0, SourceLocation());\n    }\n    assert(PP.isIncrementalProcessingEnabled() && \"Not in incremental mode!?\");\n    PP.enableIncrementalProcessing();\n\n    smallstream source_name;\n    source_name << \"input_line_\" << (m_MemoryBuffers.size() + 1);\n\n    // Create an uninitialized memory buffer, copy code in and append \"\\n\"\n    size_t InputSize = input.size(); // don't include trailing 0\n    // MemBuffer size should *not* include terminating zero\n    std::unique_ptr<llvm::MemoryBuffer>\n      MB(llvm::MemoryBuffer::getNewUninitMemBuffer(InputSize + 1,\n                                                   source_name.str()));\n    char* MBStart = const_cast<char*>(MB->getBufferStart());\n    memcpy(MBStart, input.data(), InputSize);\n    MBStart[InputSize] = '\\n';\n\n    SourceManager& SM = getCI()->getSourceManager();\n\n    // Create SourceLocation, which will allow clang to order the overload\n    // candidates for example\n    SourceLocation NewLoc = getLastMemoryBufferEndLoc().getLocWithOffset(1);\n\n    llvm::MemoryBuffer* MBNonOwn = MB.get();\n\n    // Create FileID for the current buffer.\n    FileID FID;\n    // Create FileEntry and FileID for the current buffer.\n    // Enabling the completion point only works on FileEntries.\n    const clang::FileEntry* FE\n      = SM.getFileManager().getVirtualFile(source_name.str(), InputSize,\n                                           0 /* mod time*/);\n    SM.overrideFileContents(FE, std::move(MB));\n    FID = SM.createFileID(FE, NewLoc, SrcMgr::C_User);\n    if (CO.CodeCompletionOffset != -1) {\n      // The completion point is set one a 1-based line/column numbering.\n      // It relies on the implementation to account for the wrapper extra line.\n      PP.SetCodeCompletionPoint(FE, 1/* start point 1-based line*/,\n                                CO.CodeCompletionOffset+1/* 1-based column*/);\n    }\n\n    m_MemoryBuffers.push_back(std::make_pair(MBNonOwn, FID));\n\n    // NewLoc only used for diags.\n    PP.EnterSourceFile(FID, /*DirLookup*/0, NewLoc);\n    m_Consumer->getTransaction()->setBufferFID(FID);\n\n    DiagnosticsEngine& Diags = getCI()->getDiagnostics();\n\n    FilteringDiagConsumer::RAAI RAAITmp(*m_DiagConsumer, CO.IgnorePromptDiags);\n\n    DiagnosticErrorTrap Trap(Diags);\n    Sema::SavePendingInstantiationsRAII SavedPendingInstantiations(S);\n\n    Parser::DeclGroupPtrTy ADecl;\n    while (!m_Parser->ParseTopLevelDecl(ADecl)) {\n      // If we got a null return and something *was* parsed, ignore it.  This\n      // is due to a top-level semicolon, an action override, or a parse error\n      // skipping something.\n      if (Trap.hasErrorOccurred())\n        m_Consumer->getTransaction()->setIssuedDiags(Transaction::kErrors);\n      if (ADecl)\n        m_Consumer->HandleTopLevelDecl(ADecl.get());\n    };\n    // If never entered the while block, there's a chance an error occured\n    if (Trap.hasErrorOccurred())\n      m_Consumer->getTransaction()->setIssuedDiags(Transaction::kErrors);\n\n    if (CO.CodeCompletionOffset != -1) {\n      assert((int)SM.getFileOffset(PP.getCodeCompletionLoc())\n             == CO.CodeCompletionOffset\n             && \"Completion point wrongly set!\");\n      assert(PP.isCodeCompletionReached()\n             && \"Code completion set but not reached!\");\n\n      // Let's ignore this transaction:\n      m_Consumer->getTransaction()->setIssuedDiags(Transaction::kErrors);\n\n      return kSuccess;\n    }\n\n#ifdef LLVM_ON_WIN32\n    // Microsoft-specific:\n    // Late parsed templates can leave unswallowed \"macro\"-like tokens.\n    // They will seriously confuse the Parser when entering the next\n    // source file. So lex until we are EOF.\n    Token Tok;\n    Tok.setKind(tok::eof);\n    do {\n      PP.Lex(Tok);\n    } while (Tok.isNot(tok::eof));\n#endif\n\n#ifndef NDEBUG\n    Token AssertTok;\n    PP.Lex(AssertTok);\n    assert(AssertTok.is(tok::eof) && \"Lexer must be EOF when starting incremental parse!\");\n#endif\n\n    // Process any TopLevelDecls generated by #pragma weak.\n    for (llvm::SmallVector<Decl*,2>::iterator I = S.WeakTopLevelDecls().begin(),\n         E = S.WeakTopLevelDecls().end(); I != E; ++I) {\n      m_Consumer->HandleTopLevelDecl(DeclGroupRef(*I));\n    }\n\n    if (m_Consumer->getTransaction()->getIssuedDiags() == Transaction::kErrors)\n      return kFailed;\n    else if (Diags.getNumWarnings())\n      return kSuccessWithWarnings;\n\n    return kSuccess;\n  }\n\n  void IncrementalParser::printTransactionStructure() const {\n    for(size_t i = 0, e = m_Transactions.size(); i < e; ++i) {\n      m_Transactions[i]->printStructureBrief();\n    }\n  }\n\n  void IncrementalParser::SetTransformers(bool isChildInterpreter) {\n    // Add transformers to the IncrementalParser, which owns them\n    Sema* TheSema = &m_CI->getSema();\n    // if the interpreter compiles ptx code, some transformers should not be\n    // used\n    bool isCUDADevice = m_Interpreter->getOptions().CompilerOpts.CUDADevice;\n    // Register the AST Transformers\n    typedef std::unique_ptr<ASTTransformer> ASTTPtr_t;\n    std::vector<ASTTPtr_t> ASTTransformers;\n    ASTTransformers.emplace_back(new AutoSynthesizer(TheSema));\n    ASTTransformers.emplace_back(new EvaluateTSynthesizer(TheSema));\n    if (hasCodeGenerator() && !m_Interpreter->getOptions().NoRuntime) {\n      // Don't protect against crashes if we cannot run anything.\n      // cling might also be in a PCH-generation mode; don't inject our Sema\n      // pointer into the PCH.\n      if (!isCUDADevice)\n        ASTTransformers.emplace_back(\n            new NullDerefProtectionTransformer(m_Interpreter));\n      else\n        ASTTransformers.emplace_back(\n            new DeviceKernelInliner(TheSema));\n    }\n    ASTTransformers.emplace_back(new DefinitionShadower(*TheSema, *m_Interpreter));\n\n    typedef std::unique_ptr<WrapperTransformer> WTPtr_t;\n    std::vector<WTPtr_t> WrapperTransformers;\n    if (!m_Interpreter->getOptions().NoRuntime && !isCUDADevice)\n      WrapperTransformers.emplace_back(new ValuePrinterSynthesizer(TheSema));\n    WrapperTransformers.emplace_back(new DeclExtractor(TheSema));\n    if (!m_Interpreter->getOptions().NoRuntime && !isCUDADevice)\n      WrapperTransformers.emplace_back(new ValueExtractionSynthesizer(TheSema,\n                                                           isChildInterpreter));\n    WrapperTransformers.emplace_back(new CheckEmptyTransactionTransformer(TheSema));\n\n    m_Consumer->SetTransformers(std::move(ASTTransformers),\n                                std::move(WrapperTransformers));\n  }\n\n\n} // namespace cling\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h": "//--------------------------------------------------------------------*- C++ -*-\n// CLING - the C++ LLVM-based InterpreterG :)\n// author:  Vassil Vassilev <vasil.georgiev.vasilev@cern.ch>\n//\n// This file is dual-licensed: you can choose to license it under the University\n// of Illinois Open Source License or the GNU Lesser General Public License. See\n// LICENSE.TXT for details.\n//------------------------------------------------------------------------------\n\n#ifndef CLING_DYNAMIC_LIBRARY_MANAGER_H\n#define CLING_DYNAMIC_LIBRARY_MANAGER_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSet.h\"\n\n#include \"llvm/Support/Path.h\"\n\nnamespace cling {\n  class InterpreterCallbacks;\n  class InvocationOptions;\n\n  ///\\brief A helper class managing dynamic shared objects.\n  ///\n  class DynamicLibraryManager {\n  public:\n    ///\\brief Describes the result of loading a library.\n    ///\n    enum LoadLibResult {\n      kLoadLibSuccess, ///< library loaded successfully\n      kLoadLibAlreadyLoaded,  ///< library was already loaded\n      kLoadLibNotFound, ///< library was not found\n      kLoadLibLoadError, ///< loading the library failed\n      kLoadLibNumResults\n    };\n\n    /// Describes the library search paths.\n    struct SearchPathInfo {\n      /// The search path.\n      ///\n      std::string Path;\n\n      /// True if the Path is on the LD_LIBRARY_PATH.\n      ///\n      bool IsUser;\n    };\n  private:\n    typedef const void* DyLibHandle;\n    typedef llvm::DenseMap<DyLibHandle, std::string> DyLibs;\n    ///\\brief DynamicLibraries loaded by this Interpreter.\n    ///\n    DyLibs m_DyLibs;\n    llvm::StringSet<> m_LoadedLibraries;\n\n    ///\\brief Contains the list of the current include paths.\n    ///\n    const InvocationOptions& m_Opts;\n\n    ///\\brief System's include path, get initialized at construction time.\n    ///\n    llvm::SmallVector<SearchPathInfo, 32> m_SearchPaths;\n\n    InterpreterCallbacks* m_Callbacks;\n\n    ///\\brief Concatenates current include paths and the system include paths\n    /// and performs a lookup for the filename.\n    ///\\param[in] libStem - The filename being looked up\n    ///\n    ///\\returns the canonical path to the file or empty string if not found\n    ///\n    std::string lookupLibInPaths(llvm::StringRef libStem) const;\n\n\n    ///\\brief Concatenates current include paths and the system include paths\n    /// and performs a lookup for the filename. If still not found it tries to\n    /// add the platform-specific extensions (such as so, dll, dylib) and\n    /// retries the lookup (from lookupLibInPaths)\n    ///\\param[in] filename - The filename being looked up\n    ///\n    ///\\returns the canonical path to the file or empty string if not found\n    ///\n    std::string lookupLibMaybeAddExt(llvm::StringRef filename) const;\n  public:\n    DynamicLibraryManager(const InvocationOptions& Opts);\n    ~DynamicLibraryManager();\n    InterpreterCallbacks* getCallbacks() { return m_Callbacks; }\n    const InterpreterCallbacks* getCallbacks() const { return m_Callbacks; }\n    void setCallbacks(InterpreterCallbacks* C) { m_Callbacks = C; }\n\n    ///\\brief Returns the system include paths.\n    ///\n    ///\\returns System include paths.\n    ///\n    const llvm::SmallVectorImpl<SearchPathInfo>& getSearchPath() {\n       return m_SearchPaths;\n    }\n\n    void addSearchPath(llvm::StringRef dir) {\n      m_SearchPaths.emplace_back(SearchPathInfo{dir, /*IsUser*/ true});\n    }\n\n    ///\\brief Looks up a library taking into account the current include paths\n    /// and the system include paths.\n    ///\\param[in] libStem - The filename being looked up\n    ///\n    ///\\returns the canonical path to the file or empty string if not found\n    ///\n    std::string lookupLibrary(llvm::StringRef libStem) const;\n\n    ///\\brief Loads a shared library.\n    ///\n    ///\\param [in] libStem - The file to load.\n    ///\\param [in] permanent - If false, the file can be unloaded later.\n    ///\\param [in] resolved - Whether libStem is an absolute path or resolved\n    ///               from a previous call to DynamicLibraryManager::lookupLibrary\n    ///\n    ///\\returns kLoadLibSuccess on success, kLoadLibAlreadyLoaded if the library\n    /// was already loaded, kLoadLibError if the library cannot be found or any\n    /// other error was encountered.\n    ///\n    LoadLibResult loadLibrary(const std::string& libStem, bool permanent,\n                              bool resolved = false);\n\n    void unloadLibrary(llvm::StringRef libStem);\n\n    ///\\brief Returns true if the file was a dynamic library and it was already\n    /// loaded.\n    ///\n    bool isLibraryLoaded(llvm::StringRef fullPath) const;\n\n    ///\\brief Explicitly tell the execution engine to use symbols from\n    ///       a shared library that would otherwise not be used for symbol\n    ///       resolution, e.g. because it was dlopened with RTLD_LOCAL.\n    ///\\param [in] handle - the system specific shared library handle.\n    ///\n    static void ExposeHiddenSharedLibrarySymbols(void* handle);\n\n    static std::string normalizePath(llvm::StringRef path);\n\n    /// Returns true if file is a shared library.\n    ///\n    ///\\param[in] libFullPath - the full path to file.\n    ///\n    ///\\param[out] exists - sets if the file exists. Useful to distinguish if it\n    ///            is a library but of incompatible file format.\n    ///\n    static bool isSharedLibrary(llvm::StringRef libFullPath, bool* exists = 0);\n  };\n} // end namespace cling\n#endif // CLING_DYNAMIC_LIBRARY_MANAGER_H\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/bindings/pyroot/cppyy.py": "\"\"\" Dynamic C++ bindings generator.\n\"\"\"\n\nimport sys, string\n\n### helper to get the version number from root-config\ndef get_version():\n   try:\n      import commands\n      stat, output = commands.getstatusoutput(\"root-config --version\")\n      if stat == 0:\n         return output\n   except Exception:\n      pass\n   # semi-sensible default in case of failure ...\n   return \"6.03/XY\"\n\n### PyPy has 'cppyy' builtin (if enabled, that is)\nif 'cppyy' in sys.builtin_module_names:\n   _builtin_cppyy = True\n\n   import imp\n   sys.modules[ __name__ ] = \\\n      imp.load_module( 'cppyy', *(None, 'cppyy', ('', '', imp.C_BUILTIN) ) )\n   del imp\n\n   _thismodule = sys.modules[ __name__ ]\n   _backend = _thismodule.gbl\n   _thismodule._backend = _backend\n\n   # custom behavior that is not yet part of PyPy's cppyy\n   def _CreateScopeProxy( self, name ):\n      return getattr( self, name )\n   type(_backend).CreateScopeProxy = _CreateScopeProxy\n\n   def _LookupCppEntity( self, name ):\n      return getattr( self, name )\n   type(_backend).LookupCppEntity = _LookupCppEntity\n\n   class _Double(float): pass\n   type(_backend).Double = _Double\n\n   def _AddressOf( self, obj ):\n      import array\n      return array.array('L', [_thismodule.addressof( obj )] )\n   type(_backend).AddressOf = _AddressOf\n\n   del _AddressOf, _Double, _LookupCppEntity, _CreateScopeProxy\n\nelse:\n   _builtin_cppyy = False\n\n   # load PyROOT C++ extension module, special case for linux and Sun\n   needsGlobal =  ( 0 <= sys.platform.find( 'linux' ) ) or\\\n                  ( 0 <= sys.platform.find( 'sunos' ) )\n   if needsGlobal:\n      # change dl flags to load dictionaries from pre-linked .so's\n      dlflags = sys.getdlopenflags()\n      sys.setdlopenflags( 0x100 | 0x2 )    # RTLD_GLOBAL | RTLD_NOW\n\n   import libPyROOT as _backend\n\n   # reset dl flags if needed\n   if needsGlobal:\n      sys.setdlopenflags( dlflags )\n   del needsGlobal\n\n# PyCintex tests rely on this, but they should not:\nsys.modules[ __name__ ].libPyROOT = _backend\n\nif not _builtin_cppyy:\n   _backend.SetMemoryPolicy( _backend.kMemoryStrict )\n\n\n### -----------------------------------------------------------------------------\n### -- metaclass helper from six ------------------------------------------------\n### -- https://bitbucket.org/gutworth/six/src/8a545f4e906f6f479a6eb8837f31d03731597687/six.py?at=default#cl-800\n#\n# Copyright (c) 2010-2015 Benjamin Peterson\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\ndef with_metaclass(meta, *bases):\n    \"\"\"Create a base class with a metaclass.\"\"\"\n    # This requires a bit of explanation: the basic idea is to make a dummy\n    # metaclass for one level of class instantiation that replaces itself with\n    # the actual metaclass.\n    class metaclass(meta):\n\n        def __new__(cls, name, this_bases, d):\n            return meta(name, bases, d)\n    return type.__new__(metaclass, 'temporary_class', (), {})\n\n### -----------------------------------------------------------------------------\n\n### template support ------------------------------------------------------------\nif not _builtin_cppyy:\n   class Template:\n      def __init__( self, name ):\n         self.__name__ = name\n\n      def __repr__(self):\n         return \"<cppyy.Template '%s' object at %s>\" % (self.__name__, hex(id(self)))\n\n      def __call__( self, *args ):\n         newargs = [ self.__name__[ 0 <= self.__name__.find( 'std::' ) and 5 or 0:] ]\n         for arg in args:\n            if type(arg) == str:\n               arg = ','.join( map( lambda x: x.strip(), arg.split(',') ) )\n            newargs.append( arg )\n         result = _backend.MakeRootTemplateClass( *newargs )\n\n       # special case pythonization (builtin_map is not available from the C-API)\n         if 'push_back' in result.__dict__:\n            def iadd( self, ll ):\n               [ self.push_back(x) for x in ll ]\n               return self\n\n            result.__iadd__ = iadd\n\n         return result\n\n   _backend.Template = Template\n\n\n#--- LoadDictionary function and aliases -----------------------------\ndef loadDictionary(name):\n   # prepend \"lib\" \n   if sys.platform != 'win32' and name[:3] != 'lib':\n       name = 'lib' + name\n   sc = _backend.gSystem.Load(name)\n   if sc == -1: raise RuntimeError(\"Error Loading dictionary\")\nloadDict = loadDictionary\n\ndef load_reflection_info(name):\n   sc = _backend.gSystem.Load(name)\n\n\n#--- Other functions needed -------------------------------------------\nif not _builtin_cppyy:\n   class _ns_meta( type ):\n      def __getattr__( cls, name ):\n         try:\n            attr = _backend.LookupCppEntity( name )\n         except TypeError as e:\n            raise AttributeError(str(e))\n         if type(attr) is _backend.PropertyProxy:\n            setattr( cls.__class__, name, attr )\n            return attr.__get__(cls)\n         setattr( cls, name, attr )\n         return attr\n\n   class _stdmeta( type ):\n      def __getattr__( cls, name ):   # for non-templated classes in std\n         try:\n            klass = _backend.CreateScopeProxy( name, cls )\n         except TypeError as e:\n            raise AttributeError(str(e))\n         setattr( cls, name, klass )\n         return klass\n\n   class _global_cpp( with_metaclass( _ns_meta ) ):\n      class std( with_metaclass( _stdmeta, object ) ):\n         stlclasses = ( 'complex', 'pair', \\\n            'deque', 'list', 'queue', 'stack', 'vector', 'map', 'multimap', 'set', 'multiset' )\n\n         for name in stlclasses:\n            locals()[ name ] = Template( 'std::%s' % name )\n\n         string = _backend.CreateScopeProxy( 'string' )\n\n   def addressOf( obj ) :                  # Cintex-style\n      return _backend.AddressOf( obj )[0]\n   addressof = _backend.addressof          # cppyy-style\n\nelse:\n   _global_cpp = _backend\n \ndef Namespace( name ):\n   if not name:\n      return _global_cpp\n   try:\n      return _backend.LookupCppEntity( name )\n   except AttributeError:\n      pass\n # to help auto-loading, simply declare the namespace\n   _backend.gInterpreter.Declare( 'namespace %s {}' % name )\n   return _backend.LookupCppEntity( name )\nmakeNamespace = Namespace\n\ndef makeClass( name ) :\n   return _backend.CreateScopeProxy( name )\n \ndef getAllClasses() :\n   TClassTable = makeClass( 'TClassTable' )\n   TClassTable.Init()\n   classes = []\n   while True :\n      c = TClassTable.Next()\n      if c : classes.append( c )\n      else : break\n   return classes\n\ndef add_smart_pointer(typename):\n   \"\"\"Add a smart pointer to the list of known smart pointer types.\n   \"\"\"\n   _backend.AddSmartPtrType(typename)\n\n#--- Global namespace and global objects -------------------------------\ngbl  = _global_cpp\nsys.modules['cppyy.gbl'] = gbl\nNULL = 0\nclass double(float): pass\nclass short(int): pass\nclass long_int(int): pass\nclass unsigned_short(int): pass\nclass unsigned_int(int): pass\nclass unsigned_long(int): pass\n\n#--- Copy over locally defined names ------------------------------------\nif _builtin_cppyy:\n   for name in dir():\n      if name[0] != '_': setattr( _thismodule, name, eval(name) )\n\n#--- Compatibility ------------------------------------------------------\nif not _builtin_cppyy:\n   bind_object = _backend.BindObject\n   nullptr = _backend.nullptr\n\n#--- Pythonization factories --------------------------------------------\nimport _pythonization\npy = _pythonization\n_pythonization._set_backend( _backend )\nfrom _pythonization import *\ndel _pythonization\n\n#--- CFFI style ---------------------------------------------------------\ndef cppdef( src ):\n   _backend.gInterpreter.Declare( src )\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/bindings/pyroot/JupyROOT/helpers/cppcompleter.py": "# -*- coding:utf-8 -*-\n\n#-----------------------------------------------------------------------------\n#  Author: Danilo Piparo <Danilo.Piparo@cern.ch> CERN\n#  Author: Enric Tejedor <enric.tejedor.saavedra@cern.ch> CERN\n#-----------------------------------------------------------------------------\n\nfrom JupyROOT.helpers import utils\nimport ROOT\n\n# Jit a wrapper for the ttabcom\n_TTabComHookCode = \"\"\"\nstd::vector<std::string> _TTabComHook(const char* pattern){\n   static auto ttc = new TTabCom;\n   const size_t lineBufSize = 2*1024;  // must be equal to/larger than BUF_SIZE in TTabCom.cxx\n   std::unique_ptr<char[]> completed(new char[lineBufSize]);\n   strncpy(completed.get(), pattern, lineBufSize);\n   completed[lineBufSize-1] = '\\\\0';\n   int pLoc = strlen(completed.get());\n   std::ostringstream oss;\n   Int_t firstChange = ttc->Hook(completed.get(), &pLoc, oss);\n   if (firstChange == -2) { // got some completions in oss\n      auto completions = oss.str();\n      vector<string> completions_v;\n      istringstream f(completions);\n      string s;\n      while (getline(f, s, '\\\\n')) {\n         completions_v.push_back(s);\n      }\n      return completions_v;\n   }\n   if (firstChange == -1) { // found no completions\n      return vector<string>();\n   }\n   // found exactly one completion\n   return vector<string>(1, completed.get());\n}\n\"\"\"\n\nclass CppCompleter(object):\n    '''\n    Completer which interfaces to the TTabCom of ROOT. It is activated\n    (deactivated) upon the load(unload) of the load of the extension.\n\n    >>> comp = CppCompleter()\n    >>> comp.activate()\n    >>> for suggestion in comp._completeImpl(\"TH1\"):\n    ...     print(suggestion)\n    TH1\n    TH1C\n    TH1D\n    TH1Editor\n    TH1F\n    TH1I\n    TH1K\n    TH1S\n    >>> for suggestion in comp._completeImpl(\"TProfile\"):\n    ...     print(suggestion)\n    TProfile\n    TProfile2D\n    TProfile2Poly\n    TProfile2PolyBin\n    TProfile3D\n    >>> garbage = ROOT.gInterpreter.ProcessLine(\"TH1F* h\")\n    >>> for suggestion in comp._completeImpl(\"h->GetA\"):\n    ...     print(suggestion)\n    h->GetArray\n    h->GetAsymmetry\n    h->GetAt\n    h->GetAxisColor\n    >>> garbage = ROOT.gInterpreter.ProcessLine(\"TH1F aa\")\n    >>> for suggestion in comp._completeImpl(\"aa.Add(\"):\n    ...     print(suggestion.replace(\"\\\\t\",\" \"))\n    <BLANKLINE>\n    Bool_t Add(TF1* h1, Double_t c1 = 1, Option_t* option = \"\")\n    Bool_t Add(const TH1* h, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)  // *MENU*\n    Bool_t Add(const TH1* h1, Double_t c1 = 1)\n    >>> for suggestion in comp._completeImpl(\"TROOT::Is\"):\n    ...     print(suggestion)\n    TROOT::IsA\n    TROOT::IsBatch\n    TROOT::IsEqual\n    TROOT::IsEscaped\n    TROOT::IsExecutingMacro\n    TROOT::IsFolder\n    TROOT::IsInterrupted\n    TROOT::IsLineProcessing\n    TROOT::IsModified\n    TROOT::IsOnHeap\n    TROOT::IsProofServ\n    TROOT::IsRootFile\n    TROOT::IsSortable\n    TROOT::IsWebDisplay\n    TROOT::IsWebDisplayBatch\n    TROOT::IsWritable\n    TROOT::IsZombie\n    >>> comp.deactivate()\n    >>> for suggestion in comp._completeImpl(\"TG\"):\n    ...     print(suggestion)\n    '''\n\n    def __init__(self):\n        self.hook = None\n        self.active = True\n        self.firstActivation = True\n        self.accessors = [\".\", \"->\", \"::\"]\n\n    def activate(self):\n        self.active = True\n        if self.firstActivation:\n            utils.declareCppCode('#include \"dlfcn.h\"')\n            dlOpenRint = 'dlopen(\"libRint.so\",RTLD_NOW);'\n            utils.processCppCode(dlOpenRint)\n            utils.declareCppCode(_TTabComHookCode)\n            self.hook = ROOT._TTabComHook\n            self.firstActivation = False\n\n    def deactivate(self):\n        self.active = False\n\n    def _getSuggestions(self,line):\n        if self.active:\n            return self.hook(line)\n        return []\n\n    def _getLastAccessorPos(self,line):\n        accessorPos = -1\n        for accessor in self.accessors:\n            tmpAccessorPos = line.rfind(accessor)\n            if accessorPos < tmpAccessorPos:\n                accessorPos = tmpAccessorPos+len(accessor)\n        return accessorPos\n\n    def _completeImpl(self, line):\n        line=line.split()[-1]\n        suggestions = self._getSuggestions(line)\n        suggestions = filter(lambda s: len(s.strip()) != 0, suggestions)\n        suggestions = sorted(suggestions)\n        if not suggestions: return []\n        # Remove combinations of opening and closing brackets and just opening\n        # brackets at the end of a line. Jupyter seems to expect functions\n        # without these brackets to work properly. The brackets of'operator()'\n        # must not be removed\n        suggestions = [sugg[:-2] if sugg[-2:] == '()' and sugg != 'operator()' else sugg for sugg in suggestions]\n        suggestions = [sugg[:-1] if sugg[-1:] == '(' else sugg for sugg in suggestions]\n        # If a function signature is encountered, add an empty item to the\n        # suggestions. Try to guess a function signature by an opening bracket\n        # ignoring 'operator()'.\n        are_signatures = \"(\" in \"\".join(filter(lambda s: s != 'operator()', suggestions))\n        accessorPos = self._getLastAccessorPos(line)\n        if are_signatures:\n            suggestions = [\" \"] + suggestions\n        elif accessorPos > 0:\n            # Prepend variable name to suggestions. Do not prepend if the\n            # suggestion already contains the variable name, this can happen if\n            # e.g. there is only one valid completion\n            if len(suggestions) > 1 or line[:accessorPos] != suggestions[0][:accessorPos]:\n                suggestions = [line[:accessorPos]+sugg for sugg in suggestions]\n        return suggestions\n\n    def complete(self, ip, event) :\n        '''\n        Autocomplete interfacing to TTabCom. If an accessor of a scope is\n        present in the line, the suggestions are prepended with the line.\n        That's how completers work. For example:\n        myGraph.Set<tab> will return \"myGraph.Set+suggestion in the list of\n        suggestions.\n        '''\n        return self._completeImpl(event.line)\n\n\n_cppCompleter = CppCompleter()\n\ndef load_ipython_extension(ipython):\n    _cppCompleter.activate()\n    ipython.set_hook('complete_command', _cppCompleter.complete, re_key=r\"[(.*)[\\.,::,\\->](.*)]|(.*)\")\n\ndef unload_ipython_extension(ipython):\n    _cppCompleter.deactivate()\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/bindings/jupyroot/python/JupyROOT/helpers/cppcompleter.py": "# -*- coding:utf-8 -*-\n\n#-----------------------------------------------------------------------------\n#  Author: Danilo Piparo <Danilo.Piparo@cern.ch> CERN\n#  Author: Enric Tejedor <enric.tejedor.saavedra@cern.ch> CERN\n#-----------------------------------------------------------------------------\n\nfrom JupyROOT.helpers import utils\nimport ROOT\n\n# Jit a wrapper for the ttabcom\n_TTabComHookCode = \"\"\"\nstd::vector<std::string> _TTabComHook(const char* pattern){\n   static auto ttc = new TTabCom;\n   const size_t lineBufSize = 2*1024;  // must be equal to/larger than BUF_SIZE in TTabCom.cxx\n   std::unique_ptr<char[]> completed(new char[lineBufSize]);\n   strncpy(completed.get(), pattern, lineBufSize);\n   completed[lineBufSize-1] = '\\\\0';\n   int pLoc = strlen(completed.get());\n   std::ostringstream oss;\n   Int_t firstChange = ttc->Hook(completed.get(), &pLoc, oss);\n   if (firstChange == -2) { // got some completions in oss\n      auto completions = oss.str();\n      vector<string> completions_v;\n      istringstream f(completions);\n      string s;\n      while (getline(f, s, '\\\\n')) {\n         completions_v.push_back(s);\n      }\n      return completions_v;\n   }\n   if (firstChange == -1) { // found no completions\n      return vector<string>();\n   }\n   // found exactly one completion\n   return vector<string>(1, completed.get());\n}\n\"\"\"\n\nclass CppCompleter(object):\n    '''\n    Completer which interfaces to the TTabCom of ROOT. It is activated\n    (deactivated) upon the load(unload) of the load of the extension.\n\n    >>> comp = CppCompleter()\n    >>> comp.activate()\n    >>> for suggestion in comp._completeImpl(\"TH1\"):\n    ...     print(suggestion)\n    TH1\n    TH1C\n    TH1D\n    TH1Editor\n    TH1F\n    TH1I\n    TH1K\n    TH1S\n    >>> for suggestion in comp._completeImpl(\"TProfile\"):\n    ...     print(suggestion)\n    TProfile\n    TProfile2D\n    TProfile2Poly\n    TProfile2PolyBin\n    TProfile3D\n    >>> garbage = ROOT.gInterpreter.ProcessLine(\"TH1F* h\")\n    >>> for suggestion in comp._completeImpl(\"h->GetA\"):\n    ...     print(suggestion)\n    h->GetArray\n    h->GetAsymmetry\n    h->GetAt\n    h->GetAxisColor\n    >>> garbage = ROOT.gInterpreter.ProcessLine(\"TH1F aa\")\n    >>> for suggestion in comp._completeImpl(\"aa.Add(\"):\n    ...     print(suggestion.replace(\"\\\\t\",\" \"))\n    <BLANKLINE>\n    Bool_t Add(TF1* h1, Double_t c1 = 1, Option_t* option = \"\")\n    Bool_t Add(const TH1* h, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)  // *MENU*\n    Bool_t Add(const TH1* h1, Double_t c1 = 1)\n    >>> for suggestion in comp._completeImpl(\"TROOT::Is\"):\n    ...     print(suggestion)\n    TROOT::IsA\n    TROOT::IsBatch\n    TROOT::IsEqual\n    TROOT::IsEscaped\n    TROOT::IsExecutingMacro\n    TROOT::IsFolder\n    TROOT::IsInterrupted\n    TROOT::IsLineProcessing\n    TROOT::IsModified\n    TROOT::IsOnHeap\n    TROOT::IsProofServ\n    TROOT::IsRootFile\n    TROOT::IsSortable\n    TROOT::IsWebDisplay\n    TROOT::IsWebDisplayBatch\n    TROOT::IsWritable\n    TROOT::IsZombie\n    >>> comp.deactivate()\n    >>> for suggestion in comp._completeImpl(\"TG\"):\n    ...     print(suggestion)\n    '''\n\n    def __init__(self):\n        self.hook = None\n        self.active = True\n        self.firstActivation = True\n        self.accessors = [\".\", \"->\", \"::\"]\n\n    def activate(self):\n        self.active = True\n        if self.firstActivation:\n            utils.declareCppCode('#include \"dlfcn.h\"')\n            dlOpenRint = 'dlopen(\"libRint.so\",RTLD_NOW);'\n            utils.processCppCode(dlOpenRint)\n            utils.declareCppCode(_TTabComHookCode)\n            self.hook = ROOT._TTabComHook\n            self.firstActivation = False\n\n    def deactivate(self):\n        self.active = False\n\n    def _getSuggestions(self,line):\n        if self.active:\n            return self.hook(line)\n        return []\n\n    def _getLastAccessorPos(self,line):\n        accessorPos = -1\n        for accessor in self.accessors:\n            tmpAccessorPos = line.rfind(accessor)\n            if accessorPos < tmpAccessorPos:\n                accessorPos = tmpAccessorPos+len(accessor)\n        return accessorPos\n\n    def _completeImpl(self, line):\n        line=line.split()[-1]\n        suggestions = self._getSuggestions(line)\n        suggestions = filter(lambda s: len(s.strip()) != 0, suggestions)\n        suggestions = sorted(suggestions)\n        if not suggestions: return []\n        # Remove combinations of opening and closing brackets and just opening\n        # brackets at the end of a line. Jupyter seems to expect functions\n        # without these brackets to work properly. The brackets of'operator()'\n        # must not be removed\n        suggestions = [sugg[:-2] if sugg[-2:] == '()' and sugg != 'operator()' else sugg for sugg in suggestions]\n        suggestions = [sugg[:-1] if sugg[-1:] == '(' else sugg for sugg in suggestions]\n        # If a function signature is encountered, add an empty item to the\n        # suggestions. Try to guess a function signature by an opening bracket\n        # ignoring 'operator()'.\n        are_signatures = \"(\" in \"\".join(filter(lambda s: s != 'operator()', suggestions))\n        accessorPos = self._getLastAccessorPos(line)\n        if are_signatures:\n            suggestions = [\" \"] + suggestions\n        elif accessorPos > 0:\n            # Prepend variable name to suggestions. Do not prepend if the\n            # suggestion already contains the variable name, this can happen if\n            # e.g. there is only one valid completion\n            if len(suggestions) > 1 or line[:accessorPos] != suggestions[0][:accessorPos]:\n                suggestions = [line[:accessorPos]+sugg for sugg in suggestions]\n        return suggestions\n\n    def complete(self, ip, event) :\n        '''\n        Autocomplete interfacing to TTabCom. If an accessor of a scope is\n        present in the line, the suggestions are prepended with the line.\n        That's how completers work. For example:\n        myGraph.Set<tab> will return \"myGraph.Set+suggestion in the list of\n        suggestions.\n        '''\n        return self._completeImpl(event.line)\n\n\n_cppCompleter = CppCompleter()\n\ndef load_ipython_extension(ipython):\n    _cppCompleter.activate()\n    ipython.set_hook('complete_command', _cppCompleter.complete, re_key=r\"[(.*)[\\.,::,\\->](.*)]|(.*)\")\n\ndef unload_ipython_extension(ipython):\n    _cppCompleter.deactivate()\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/bindings/pyroot_experimental/cppyy/cppyy/etc/valgrind-cppyy-cling.supp": "#\n# Cling/LLVM code generation: since cppyy is a python module, there is no\n# proper control over offload ands since functions may be used during atexit()\n# calls, we'll just leak all JITed code rather than risk spurious crashes in\n# hard-to-reproduce cases.\n#\n{\n   lazily JITed callfuncs\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN4llvm4UsernwEm\n   fun:_ZN5clang7CodeGen13CodeGenModule23GetOrCreateLLVMFunctionEN4llvm9StringRefEPNS2_4TypeENS_10GlobalDeclEbbbNS2_13AttributeListENS0_15ForDefinition_tE\n}\n\n{\n   lazily JITed template instantiations\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:__ZN5clang24TemplateDeclInstantiator18VisitCXXMethodDeclEPNS_13CXXMethodDeclEPNS_21TemplateParameterListEb\n}\n\n{\n   lazily JITed template instantiations\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang4Sema38InstantiateClassTemplateSpecializationENS_14SourceLocationEPNS_31ClassTemplateSpecializationDeclENS_26TemplateSpecializationKindEb\n}\n\n{\n   lazily JITed global operators\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN4llvm4UsernwEmj\n   fun:_ZN4llvm14BinaryOperator6CreateENS_11Instruction9BinaryOpsEPNS_5ValueES4_RKNS_5TwineEPS1_\n}\n\n{\n   lazily JITed casts\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN4llvm4UsernwEmj\n   fun:_ZN4llvm8CastInst6CreateENS_11Instruction7CastOpsEPNS_5ValueEPNS_4TypeERKNS_5TwineEPS1_\n}\n\n{\n   lazily JITed casts\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:_Znam\n   ...\n   fun:_ZN20TClingDataMemberInfo6OffsetEv\n}\n\n{\n   cling initialization\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5cling11InterpreterC1EiPKPKcS2_bb\n}\n\n{\n   clang module symbol table\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:allocate\n   ...\n   fun:_ZN5clang7CodeGen13CodeGenModule7ReleaseEv\n   fun:_ZN5cling17IncrementalParser18codeGenTransactionEPNS_11TransactionE\n   fun:_ZN5cling17IncrementalParser17commitTransactionEN4llvm14PointerIntPairIPNS_11TransactionELj2ENS0_12EParseResultENS1_21PointerLikeTypeTraitsIS4_EEEE\n}\n\n{\n   CodeGen\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZL21EmitMemberInitializerRN5clang7CodeGen15CodeGenFunctionEPKNS_13CXXRecordDeclEPNS_18CXXCtorInitializerEPKNS_18CXXConstructorDeclERNS0_15FunctionArgListE\n}\n\n{\n   CodeGen cleanup\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZL11EmitCleanupRN5clang7CodeGen15CodeGenFunctionEPNS0_12EHScopeStack7CleanupENS4_5FlagsEPN4llvm5ValueE\n}\n\n{\n   CodeGen globals\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Zn*\n   ...\n   fun:_ZN5clang7CodeGen13CodeGenModule20EmitGlobalDefinitionENS_10GlobalDeclEPN4llvm11GlobalValueE\n}\n\n{\n   CodeGen cleanup\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN4llvm4UsernwEmj\n   ...\n   fun:_ZN5clang7CodeGen15CodeGenFunction15PopCleanupBlockEb\n}\n\n{\n   cling Module use\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN4llvm6ModuleC1ENS_9StringRefERNS_11LLVMContextE\n}\n\n{\n   cling Module use\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang17CodeGeneratorImpl11StartModuleERKSsRN4llvm11LLVMContextERKNS_14CodeGenOptionsE\n}\n\n{\n   cling macro\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang19PreprocessorOptions11addMacroDefEN4llvm9StringRefE\n}\n\n{\n   llvm target\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN4llvm21RegisterTargetMachineINS_16X86TargetMachineEE9AllocatorERKNS_6TargetENS_9StringRefES6_S6_RKNS_13TargetOptionsENS_5Reloc5ModelENS_9CodeModel5ModelENS_10CodeGenOpt5LevelE\n}\n\n{\n   CodeGent SetFunctionAttributes\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang7CodeGen13CodeGenModule21SetFunctionAttributesENS_10GlobalDeclEPN4llvm8FunctionEbb\n}\n\n{\n   clang using statement\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZNK5clang11DeclContext16using_directivesEv\n}\n\n{\n   clang 'make decl visible'\n   Memcheck:Leak\n   match-leak-kinds: possible\n   ...\n   fun:_ZN5clang11DeclContext28makeDeclVisibleInContextImplEPNS_9NamedDeclEb\n}\n\n{\n   clang visibility\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZL24getExplicitVisibilityAuxPKN5clang9NamedDeclENS0_22ExplicitVisibilityKindEb\n}\n\n{\n   clang result of lookup declaration name\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang11DeclContext6lookupENS_15DeclarationNameE\n}\n\n{\n   clang result of lookup declaration name\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:malloc\n   ...\n   fun:_ZN5clang11DeclContext6lookupENS_15DeclarationNameE\n}\n\n{\n   clang ASTReader\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:malloc\n   ...\n   fun:_ZN5clang9ASTReader*\n}\n\n{\n   clang ASTReader\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang9ASTReader*\n}\n\n{\n   clang ASTReader\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:realloc\n   ...\n   fun:_ZN5clang9ASTReader*\n}\n\n{\n   Sema ActOnEndOfTranslation\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang4Sema25ActOnEndOfTranslationUnitEv\n}\n\n{\n   Function CodeGen\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang7CodeGen15CodeGenFunction12GenerateCodeENS_10GlobalDeclEPN4llvm8FunctionERKNS0_14CGFunctionInfoE\n}\n\n{\n   clang CodeGenFunction Emit*\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang7CodeGen15CodeGenFunction*Emit*\n}\n\n{\n   clang CodeGenFunction global state\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN4llvm4UsernwEmj\n   ...\n   fun:_ZL21emitPointerArithmeticRN5clang7CodeGen15CodeGenFunctionERKN12_GLOBAL__N_19BinOpInfoEb\n}\n\n{\n   clang CodeGenModule Emit*\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang7CodeGen13CodeGenModule*Emit*\n}\n\n{\n   clang CodeGenModule Emit*\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang7CodeGen13CodeGenModule*emit*\n}\n\n{\n   CodeGen VTables\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN4llvm4UsernwEmj\n   ...\n   fun:_ZN5clang7CodeGen14CodeGenVTables17*\n}\n\n{\n   clang AddIncludePath\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang19HeaderSearchOptions7AddPathEN4llvm9StringRefENS_8frontend15IncludeDirGroupEbb\n}\n\n{\n   clang FileManager\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang12HeaderSearch10LookupFileEN4llvm9StringRefENS_14SourceLocationEbPKNS_15DirectoryLookupERS6_NS1_8ArrayRefISt4pairIPKNS_9FileEntryEPKNS_14DirectoryEntryEEEEPNS1_15SmallVectorImplIcEESK_PNS_9ModuleMap11KnownHeaderEbbb\n}\n\n{\n   clang getFile\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang11FileManager7getFileEN4llvm9StringRefEbb\n}\n\n{\n   clang ScalarExprEmitter\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN12_GLOBAL__N_117ScalarExprEmitter20EmitScalarConversionEPN4llvm5ValueEN5clang8QualTypeES5_\n}\n\n{\n   llvm pass manager\n   Memcheck:Leak\n   match-leak-kinds: possible\n   ...\n   fun:_ZN4llvm13FPPassManager13runOnFunctionERNS_8FunctionE\n}\n\n\n{\n   llvm PassManager initialization\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN4llvm13FPPassManager16doInitializationERNS_6ModuleE\n}\n\n{\n   llvm SubTarget initialization\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN4llvm15MCSubtargetInfo19InitMCSubtargetInfoENS_9StringRefES1_S1_NS_8ArrayRefINS_18SubtargetFeatureKVEEES4_PKNS_15SubtargetInfoKVEPKNS_19MCWriteProcResEntryEPKNS_19MCWriteLatencyEntryEPKNS_18MCReadAdvanceEntryEPKNS_10InstrStageEPKjSL_\n}\n\n{\n   cling dynamic library manager\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5cling21DynamicLibraryManager11loadLibraryERKSsb\n}\n\n{\n   llvm compile layer\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN4llvm18ObjectMemoryBufferC1EONS_15SmallVectorImplIcEE\n   fun:_ZNK4llvm14SimpleCompilerclERNS_6ModuleE\n   fun:_ZNSt17_Function_handlerIFN4llvm6object12OwningBinaryINS1_10ObjectFileEEERNS0_6ModuleEENS0_14SimpleCompilerEE9_M_invokeERKSt9_Any_dataS6_\n   fun:_ZNKSt8functionIFN4llvm6object12OwningBinaryINS1_10ObjectFileEEERNS0_6ModuleEEEclES6_\n   fun:_ZN4llvm14IRCompileLayerINS_18ObjectLinkingLayerIN5cling14IncrementalJIT19NotifyObjectLoadedTEEEE12addModuleSetISt6vectorIPNS_6ModuleESaISA_EEEESt14_List_iteratorINS_22ObjectLinkingLayerBase15LinkedObjectSetEET_St10unique_ptrINS_19RTDyldMemoryManagerESt14default_deleteISJ_EE\n}\n\n{\n   InputValidator string\n   Memcheck:Leak\n   match-leak-kinds: possible\n   ...\n   fun:_ZNSs15_M_replace_safeEmmPKcm\n   fun:_ZN5cling14InputValidator5resetEv\n}\n\n{\n   cling pointer checker on uninitialized memory (ROOT-8144)\n   Memcheck:Param\n   write(buf)\n   fun:__write_nocancel\n   ...\n   fun:cling_runtime_internal_throwIfInvalidPointer\n}\n\n\n#\n# ROOT/meta wrappers to JITed Cling code, same as above: kept around so as to\n# not have to deal with complicated shutdown sequences.\n#\n{\n   typedef string\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:_Znam\n   ...\n   fun:_ZN10TClassEdit14ResolveTypedefB5cxx11EPKcb\n}\n\n{\n   TEnums leak\n   Memcheck:Leak\n   fun:_Znwm\n   fun:_ZN8TStorage11ObjectAllocEm\n   fun:_ZN7TObjectnwEm\n   fun:_ZN5TROOT14GetListOfEnumsEv\n}\n\n{\n   list of enums\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN8TStorage11ObjectAllocEm\n   fun:_ZN7TObjectnwEm\n   fun:_ZN12TListOfEnumsC1EP6TClass\n}\n\n{\n   list of enums\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:_Znwm\n   fun:_ZN8TStorage11ObjectAllocEm\n   fun:operator new\n   fun:_ZN6TClass14GetListOfEnumsEb\n}\n\n{\n   TObject::TObject() uses uninitialized value when allocated on the stack\n   Memcheck:Cond\n   fun:_ZN7TObjectC1Ev\n}\n\n{\n   TObject::TObject() uses uninitialized value when allocated on the stack\n   Memcheck:Cond\n   fun:TObject\n}\n\n{\n   dictgen fwd decls\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang6Parser30ParseCXXClassMemberDeclarationENS_15AccessSpecifierEPNS_13AttributeListERKNS0_18ParsedTemplateInfoEPNS_21ParsingDeclRAIIObjectE\n}\n\n{\n   exception translation\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   ...\n   fun:_ZL26HandleInterpreterExceptionPN5cling13MetaProcessorEPKcRNS_11Interpreter17CompilationResultEPNS_5ValueE\n}\n\n{\n   Ignore deficient in dlopen and/or pthread and/or valgrind. See for example https://bugs.kde.org/show_bug.cgi?id=358980.\n   Memcheck:Leak\n   match-leak-kinds: definite\n   ...\n   fun:_dl_signal_error\n}\n\n\n#\n# Python Arena magic checkers\n#\n{\n   ADDRESS_IN_RANGE/Invalid read of size 4\n   Memcheck:Addr4\n   fun:Py_ADDRESS_IN_RANGE\n}\n\n{\n   ADDRESS_IN_RANGE/Invalid read of size 4\n   Memcheck:Value4\n   fun:Py_ADDRESS_IN_RANGE\n}\n\n{\n   ADDRESS_IN_RANGE/Invalid read of size 8 (x86_64 aka amd64)\n   Memcheck:Value8\n   fun:Py_ADDRESS_IN_RANGE\n}\n\n{\n   ADDRESS_IN_RANGE/Conditional jump or move depends on uninitialised value\n   Memcheck:Cond\n   fun:Py_ADDRESS_IN_RANGE\n}\n\n{\n   ADDRESS_IN_RANGE/Invalid read of size 4\n   Memcheck:Addr4\n   fun:PyObject_Free\n}\n\n{\n   ADDRESS_IN_RANGE/Invalid read of size 4\n   Memcheck:Addr4\n   fun:PyObject_Free\n}\n\n{\n   ADDRESS_IN_RANGE/Invalid read of size 8\n   Memcheck:Value8\n   fun:PyObject_Free\n}\n\n{\n   ADDRESS_IN_RANGE/Conditional jump or move depends on uninitialised value\n   Memcheck:Cond\n   fun:PyObject_Free\n}\n\n{\n   ADDRESS_IN_RANGE/Invalid read of size 4\n   Memcheck:Addr4\n   fun:PyObject_Realloc\n}\n\n{\n   ADDRESS_IN_RANGE/Invalid read of size 8\n   Memcheck:Value8\n   fun:PyObject_Realloc\n}\n\n{\n   ADDRESS_IN_RANGE/Conditional jump or move depends on uninitialised value\n   Memcheck:Cond\n   fun:PyObject_Realloc\n}\n\n{\n   Handle PyMalloc confusing valgrind (possibly leaked)\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:_PyObject_GC_Resize\n}\n\n{\n   Handle PyMalloc confusing valgrind (possibly leaked)\n   Memcheck:Leak\n   fun:realloc\n   ...\n   fun:_PyObject_GC_Resize\n}\n\n{\n   Handle PyMalloc confusing valgrind (possibly leaked)\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:_PyObject_GC_NewVar\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/asimage/src/libAfterImage/aclocal.m4": "dnl aclocal.m4 generated automatically by aclocal 1.4-p6\n\ndnl Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl This program is distributed in the hope that it will be useful,\ndnl but WITHOUT ANY WARRANTY, to the extent permitted by law; without\ndnl even the implied warranty of MERCHANTABILITY or FITNESS FOR A\ndnl PARTICULAR PURPOSE.\n\n# lib-prefix.m4 serial 4 (gettext-0.14.2)\ndnl Copyright (C) 2001-2005 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl From Bruno Haible.\n\ndnl AC_LIB_ARG_WITH is synonymous to AC_ARG_WITH in autoconf-2.13, and\ndnl similar to AC_ARG_WITH in autoconf 2.52...2.57 except that is doesn't\ndnl require excessive bracketing.\nifdef([AC_HELP_STRING],\n[AC_DEFUN([AC_LIB_ARG_WITH], [AC_ARG_WITH([$1],[[$2]],[$3],[$4])])],\n[AC_DEFUN([AC_][LIB_ARG_WITH], [AC_ARG_WITH([$1],[$2],[$3],[$4])])])\n\ndnl AC_LIB_PREFIX adds to the CPPFLAGS and LDFLAGS the flags that are needed\ndnl to access previously installed libraries. The basic assumption is that\ndnl a user will want packages to use other packages they previously installed\ndnl with the same --prefix option.\ndnl This macro is not needed if only AC_LIB_LINKFLAGS is used to locate\ndnl libraries, but is otherwise very convenient.\nAC_DEFUN([AC_LIB_PREFIX],\n[\n  AC_BEFORE([$0], [AC_LIB_LINKFLAGS])\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST])\n  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])\n  dnl By default, look in $includedir and $libdir.\n  use_additional=yes\n  AC_LIB_WITH_FINAL_PREFIX([\n    eval additional_includedir=\\\"$includedir\\\"\n    eval additional_libdir=\\\"$libdir\\\"\n  ])\n  AC_LIB_ARG_WITH([lib-prefix],\n[  --with-lib-prefix[=DIR] search for libraries in DIR/include and DIR/lib\n  --without-lib-prefix    don't search for libraries in includedir and libdir],\n[\n    if test \"X$withval\" = \"Xno\"; then\n      use_additional=no\n    else\n      if test \"X$withval\" = \"X\"; then\n        AC_LIB_WITH_FINAL_PREFIX([\n          eval additional_includedir=\\\"$includedir\\\"\n          eval additional_libdir=\\\"$libdir\\\"\n        ])\n      else\n        additional_includedir=\"$withval/include\"\n        additional_libdir=\"$withval/lib\"\n      fi\n    fi\n])\n  if test $use_additional = yes; then\n    dnl Potentially add $additional_includedir to $CPPFLAGS.\n    dnl But don't add it\n    dnl   1. if it's the standard /usr/include,\n    dnl   2. if it's already present in $CPPFLAGS,\n    dnl   3. if it's /usr/local/include and we are using GCC on Linux,\n    dnl   4. if it doesn't exist as a directory.\n    if test \"X$additional_includedir\" != \"X/usr/include\"; then\n      haveit=\n      for x in $CPPFLAGS; do\n        AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n        if test \"X$x\" = \"X-I$additional_includedir\"; then\n          haveit=yes\n          break\n        fi\n      done\n      if test -z \"$haveit\"; then\n        if test \"X$additional_includedir\" = \"X/usr/local/include\"; then\n          if test -n \"$GCC\"; then\n            case $host_os in\n              linux* | gnu* | k*bsd*-gnu) haveit=yes;;\n            esac\n          fi\n        fi\n        if test -z \"$haveit\"; then\n          if test -d \"$additional_includedir\"; then\n            dnl Really add $additional_includedir to $CPPFLAGS.\n            CPPFLAGS=\"${CPPFLAGS}${CPPFLAGS:+ }-I$additional_includedir\"\n          fi\n        fi\n      fi\n    fi\n    dnl Potentially add $additional_libdir to $LDFLAGS.\n    dnl But don't add it\n    dnl   1. if it's the standard /usr/lib,\n    dnl   2. if it's already present in $LDFLAGS,\n    dnl   3. if it's /usr/local/lib and we are using GCC on Linux,\n    dnl   4. if it doesn't exist as a directory.\n    if test \"X$additional_libdir\" != \"X/usr/lib\"; then\n      haveit=\n      for x in $LDFLAGS; do\n        AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n        if test \"X$x\" = \"X-L$additional_libdir\"; then\n          haveit=yes\n          break\n        fi\n      done\n      if test -z \"$haveit\"; then\n        if test \"X$additional_libdir\" = \"X/usr/local/lib\"; then\n          if test -n \"$GCC\"; then\n            case $host_os in\n              linux*) haveit=yes;;\n            esac\n          fi\n        fi\n        if test -z \"$haveit\"; then\n          if test -d \"$additional_libdir\"; then\n            dnl Really add $additional_libdir to $LDFLAGS.\n            LDFLAGS=\"${LDFLAGS}${LDFLAGS:+ }-L$additional_libdir\"\n          fi\n        fi\n      fi\n    fi\n  fi\n])\n\ndnl AC_LIB_PREPARE_PREFIX creates variables acl_final_prefix,\ndnl acl_final_exec_prefix, containing the values to which $prefix and\ndnl $exec_prefix will expand at the end of the configure script.\nAC_DEFUN([AC_LIB_PREPARE_PREFIX],\n[\n  dnl Unfortunately, prefix and exec_prefix get only finally determined\n  dnl at the end of configure.\n  if test \"X$prefix\" = \"XNONE\"; then\n    acl_final_prefix=\"$ac_default_prefix\"\n  else\n    acl_final_prefix=\"$prefix\"\n  fi\n  if test \"X$exec_prefix\" = \"XNONE\"; then\n    acl_final_exec_prefix='${prefix}'\n  else\n    acl_final_exec_prefix=\"$exec_prefix\"\n  fi\n  acl_save_prefix=\"$prefix\"\n  prefix=\"$acl_final_prefix\"\n  eval acl_final_exec_prefix=\\\"$acl_final_exec_prefix\\\"\n  prefix=\"$acl_save_prefix\"\n])\n\ndnl AC_LIB_WITH_FINAL_PREFIX([statement]) evaluates statement, with the\ndnl variables prefix and exec_prefix bound to the values they will have\ndnl at the end of the configure script.\nAC_DEFUN([AC_LIB_WITH_FINAL_PREFIX],\n[\n  acl_save_prefix=\"$prefix\"\n  prefix=\"$acl_final_prefix\"\n  acl_save_exec_prefix=\"$exec_prefix\"\n  exec_prefix=\"$acl_final_exec_prefix\"\n  $1\n  exec_prefix=\"$acl_save_exec_prefix\"\n  prefix=\"$acl_save_prefix\"\n])\n\n# lib-link.m4 serial 6 (gettext-0.14.3)\ndnl Copyright (C) 2001-2005 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl From Bruno Haible.\n\nAC_PREREQ(2.50)\n\ndnl AC_LIB_LINKFLAGS(name [, dependencies]) searches for libname and\ndnl the libraries corresponding to explicit and implicit dependencies.\ndnl Sets and AC_SUBSTs the LIB${NAME} and LTLIB${NAME} variables and\ndnl augments the CPPFLAGS variable.\nAC_DEFUN([AC_LIB_LINKFLAGS],\n[\n  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])\n  AC_REQUIRE([AC_LIB_RPATH])\n  define([Name],[translit([$1],[./-], [___])])\n  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],\n                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n  AC_CACHE_CHECK([how to link with lib[]$1], [ac_cv_lib[]Name[]_libs], [\n    AC_LIB_LINKFLAGS_BODY([$1], [$2])\n    ac_cv_lib[]Name[]_libs=\"$LIB[]NAME\"\n    ac_cv_lib[]Name[]_ltlibs=\"$LTLIB[]NAME\"\n    ac_cv_lib[]Name[]_cppflags=\"$INC[]NAME\"\n  ])\n  LIB[]NAME=\"$ac_cv_lib[]Name[]_libs\"\n  LTLIB[]NAME=\"$ac_cv_lib[]Name[]_ltlibs\"\n  INC[]NAME=\"$ac_cv_lib[]Name[]_cppflags\"\n  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)\n  AC_SUBST([LIB]NAME)\n  AC_SUBST([LTLIB]NAME)\n  dnl Also set HAVE_LIB[]NAME so that AC_LIB_HAVE_LINKFLAGS can reuse the\n  dnl results of this search when this library appears as a dependency.\n  HAVE_LIB[]NAME=yes\n  undefine([Name])\n  undefine([NAME])\n])\n\ndnl AC_LIB_HAVE_LINKFLAGS(name, dependencies, includes, testcode)\ndnl searches for libname and the libraries corresponding to explicit and\ndnl implicit dependencies, together with the specified include files and\ndnl the ability to compile and link the specified testcode. If found, it\ndnl sets and AC_SUBSTs HAVE_LIB${NAME}=yes and the LIB${NAME} and\ndnl LTLIB${NAME} variables and augments the CPPFLAGS variable, and\ndnl #defines HAVE_LIB${NAME} to 1. Otherwise, it sets and AC_SUBSTs\ndnl HAVE_LIB${NAME}=no and LIB${NAME} and LTLIB${NAME} to empty.\nAC_DEFUN([AC_LIB_HAVE_LINKFLAGS],\n[\n  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])\n  AC_REQUIRE([AC_LIB_RPATH])\n  define([Name],[translit([$1],[./-], [___])])\n  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],\n                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n\n  dnl Search for lib[]Name and define LIB[]NAME, LTLIB[]NAME and INC[]NAME\n  dnl accordingly.\n  AC_LIB_LINKFLAGS_BODY([$1], [$2])\n\n  dnl Add $INC[]NAME to CPPFLAGS before performing the following checks,\n  dnl because if the user has installed lib[]Name and not disabled its use\n  dnl via --without-lib[]Name-prefix, they want to use it.\n  ac_save_CPPFLAGS=\"$CPPFLAGS\"\n  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)\n\n  AC_CACHE_CHECK([for lib[]$1], [ac_cv_lib[]Name], [\n    ac_save_LIBS=\"$LIBS\"\n    LIBS=\"$LIBS $LIB[]NAME\"\n    AC_TRY_LINK([$3], [$4], [ac_cv_lib[]Name=yes], [ac_cv_lib[]Name=no])\n    LIBS=\"$ac_save_LIBS\"\n  ])\n  if test \"$ac_cv_lib[]Name\" = yes; then\n    HAVE_LIB[]NAME=yes\n    AC_DEFINE([HAVE_LIB]NAME, 1, [Define if you have the $1 library.])\n    AC_MSG_CHECKING([how to link with lib[]$1])\n    AC_MSG_RESULT([$LIB[]NAME])\n  else\n    HAVE_LIB[]NAME=no\n    dnl If $LIB[]NAME didn't lead to a usable library, we don't need\n    dnl $INC[]NAME either.\n    CPPFLAGS=\"$ac_save_CPPFLAGS\"\n    LIB[]NAME=\n    LTLIB[]NAME=\n  fi\n  AC_SUBST([HAVE_LIB]NAME)\n  AC_SUBST([LIB]NAME)\n  AC_SUBST([LTLIB]NAME)\n  undefine([Name])\n  undefine([NAME])\n])\n\ndnl Determine the platform dependent parameters needed to use rpath:\ndnl libext, shlibext, hardcode_libdir_flag_spec, hardcode_libdir_separator,\ndnl hardcode_direct, hardcode_minus_L.\nAC_DEFUN([AC_LIB_RPATH],\n[\n  dnl Tell automake >= 1.10 to complain if config.rpath is missing.\n  m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([config.rpath])])\n  AC_REQUIRE([AC_PROG_CC])                dnl we use $CC, $GCC, $LDFLAGS\n  AC_REQUIRE([AC_LIB_PROG_LD])            dnl we use $LD, $with_gnu_ld\n  AC_REQUIRE([AC_CANONICAL_HOST])         dnl we use $host\n  AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT]) dnl we use $ac_aux_dir\n  AC_CACHE_CHECK([for shared library run path origin], acl_cv_rpath, [\n    CC=\"$CC\" GCC=\"$GCC\" LDFLAGS=\"$LDFLAGS\" LD=\"$LD\" with_gnu_ld=\"$with_gnu_ld\" \\\n    ${CONFIG_SHELL-/bin/sh} \"$ac_aux_dir/config.rpath\" \"$host\" > conftest.sh\n    . ./conftest.sh\n    rm -f ./conftest.sh\n    acl_cv_rpath=done\n  ])\n  wl=\"$acl_cv_wl\"\n  libext=\"$acl_cv_libext\"\n  shlibext=\"$acl_cv_shlibext\"\n  hardcode_libdir_flag_spec=\"$acl_cv_hardcode_libdir_flag_spec\"\n  hardcode_libdir_separator=\"$acl_cv_hardcode_libdir_separator\"\n  hardcode_direct=\"$acl_cv_hardcode_direct\"\n  hardcode_minus_L=\"$acl_cv_hardcode_minus_L\"\n  dnl Determine whether the user wants rpath handling at all.\n  AC_ARG_ENABLE(rpath,\n    [  --disable-rpath         do not hardcode runtime library paths],\n    :, enable_rpath=yes)\n])\n\ndnl AC_LIB_LINKFLAGS_BODY(name [, dependencies]) searches for libname and\ndnl the libraries corresponding to explicit and implicit dependencies.\ndnl Sets the LIB${NAME}, LTLIB${NAME} and INC${NAME} variables.\nAC_DEFUN([AC_LIB_LINKFLAGS_BODY],\n[\n  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],\n                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n  dnl By default, look in $includedir and $libdir.\n  use_additional=yes\n  AC_LIB_WITH_FINAL_PREFIX([\n    eval additional_includedir=\\\"$includedir\\\"\n    eval additional_libdir=\\\"$libdir\\\"\n  ])\n  AC_LIB_ARG_WITH([lib$1-prefix],\n[  --with-lib$1-prefix[=DIR]  search for lib$1 in DIR/include and DIR/lib\n  --without-lib$1-prefix     don't search for lib$1 in includedir and libdir],\n[\n    if test \"X$withval\" = \"Xno\"; then\n      use_additional=no\n    else\n      if test \"X$withval\" = \"X\"; then\n        AC_LIB_WITH_FINAL_PREFIX([\n          eval additional_includedir=\\\"$includedir\\\"\n          eval additional_libdir=\\\"$libdir\\\"\n        ])\n      else\n        additional_includedir=\"$withval/include\"\n        additional_libdir=\"$withval/lib\"\n      fi\n    fi\n])\n  dnl Search the library and its dependencies in $additional_libdir and\n  dnl $LDFLAGS. Using breadth-first-seach.\n  LIB[]NAME=\n  LTLIB[]NAME=\n  INC[]NAME=\n  rpathdirs=\n  ltrpathdirs=\n  names_already_handled=\n  names_next_round='$1 $2'\n  while test -n \"$names_next_round\"; do\n    names_this_round=\"$names_next_round\"\n    names_next_round=\n    for name in $names_this_round; do\n      already_handled=\n      for n in $names_already_handled; do\n        if test \"$n\" = \"$name\"; then\n          already_handled=yes\n          break\n        fi\n      done\n      if test -z \"$already_handled\"; then\n        names_already_handled=\"$names_already_handled $name\"\n        dnl See if it was already located by an earlier AC_LIB_LINKFLAGS\n        dnl or AC_LIB_HAVE_LINKFLAGS call.\n        uppername=`echo \"$name\" | sed -e 'y|abcdefghijklmnopqrstuvwxyz./-|ABCDEFGHIJKLMNOPQRSTUVWXYZ___|'`\n        eval value=\\\"\\$HAVE_LIB$uppername\\\"\n        if test -n \"$value\"; then\n          if test \"$value\" = yes; then\n            eval value=\\\"\\$LIB$uppername\\\"\n            test -z \"$value\" || LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$value\"\n            eval value=\\\"\\$LTLIB$uppername\\\"\n            test -z \"$value\" || LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }$value\"\n          else\n            dnl An earlier call to AC_LIB_HAVE_LINKFLAGS has determined\n            dnl that this library doesn't exist. So just drop it.\n            :\n          fi\n        else\n          dnl Search the library lib$name in $additional_libdir and $LDFLAGS\n          dnl and the already constructed $LIBNAME/$LTLIBNAME.\n          found_dir=\n          found_la=\n          found_so=\n          found_a=\n          if test $use_additional = yes; then\n            if test -n \"$shlibext\" && test -f \"$additional_libdir/lib$name.$shlibext\"; then\n              found_dir=\"$additional_libdir\"\n              found_so=\"$additional_libdir/lib$name.$shlibext\"\n              if test -f \"$additional_libdir/lib$name.la\"; then\n                found_la=\"$additional_libdir/lib$name.la\"\n              fi\n            else\n              if test -f \"$additional_libdir/lib$name.$libext\"; then\n                found_dir=\"$additional_libdir\"\n                found_a=\"$additional_libdir/lib$name.$libext\"\n                if test -f \"$additional_libdir/lib$name.la\"; then\n                  found_la=\"$additional_libdir/lib$name.la\"\n                fi\n              fi\n            fi\n          fi\n          if test \"X$found_dir\" = \"X\"; then\n            for x in $LDFLAGS $LTLIB[]NAME; do\n              AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n              case \"$x\" in\n                -L*)\n                  dir=`echo \"X$x\" | sed -e 's/^X-L//'`\n                  if test -n \"$shlibext\" && test -f \"$dir/lib$name.$shlibext\"; then\n                    found_dir=\"$dir\"\n                    found_so=\"$dir/lib$name.$shlibext\"\n                    if test -f \"$dir/lib$name.la\"; then\n                      found_la=\"$dir/lib$name.la\"\n                    fi\n                  else\n                    if test -f \"$dir/lib$name.$libext\"; then\n                      found_dir=\"$dir\"\n                      found_a=\"$dir/lib$name.$libext\"\n                      if test -f \"$dir/lib$name.la\"; then\n                        found_la=\"$dir/lib$name.la\"\n                      fi\n                    fi\n                  fi\n                  ;;\n              esac\n              if test \"X$found_dir\" != \"X\"; then\n                break\n              fi\n            done\n          fi\n          if test \"X$found_dir\" != \"X\"; then\n            dnl Found the library.\n            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$found_dir -l$name\"\n            if test \"X$found_so\" != \"X\"; then\n              dnl Linking with a shared library. We attempt to hardcode its\n              dnl directory into the executable's runpath, unless it's the\n              dnl standard /usr/lib.\n              if test \"$enable_rpath\" = no || test \"X$found_dir\" = \"X/usr/lib\"; then\n                dnl No hardcoding is needed.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n              else\n                dnl Use an explicit option to hardcode DIR into the resulting\n                dnl binary.\n                dnl Potentially add DIR to ltrpathdirs.\n                dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.\n                haveit=\n                for x in $ltrpathdirs; do\n                  if test \"X$x\" = \"X$found_dir\"; then\n                    haveit=yes\n                    break\n                  fi\n                done\n                if test -z \"$haveit\"; then\n                  ltrpathdirs=\"$ltrpathdirs $found_dir\"\n                fi\n                dnl The hardcoding into $LIBNAME is system dependent.\n                if test \"$hardcode_direct\" = yes; then\n                  dnl Using DIR/libNAME.so during linking hardcodes DIR into the\n                  dnl resulting binary.\n                  LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                else\n                  if test -n \"$hardcode_libdir_flag_spec\" && test \"$hardcode_minus_L\" = no; then\n                    dnl Use an explicit option to hardcode DIR into the resulting\n                    dnl binary.\n                    LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                    dnl Potentially add DIR to rpathdirs.\n                    dnl The rpathdirs will be appended to $LIBNAME at the end.\n                    haveit=\n                    for x in $rpathdirs; do\n                      if test \"X$x\" = \"X$found_dir\"; then\n                        haveit=yes\n                        break\n                      fi\n                    done\n                    if test -z \"$haveit\"; then\n                      rpathdirs=\"$rpathdirs $found_dir\"\n                    fi\n                  else\n                    dnl Rely on \"-L$found_dir\".\n                    dnl But don't add it if it's already contained in the LDFLAGS\n                    dnl or the already constructed $LIBNAME\n                    haveit=\n                    for x in $LDFLAGS $LIB[]NAME; do\n                      AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                      if test \"X$x\" = \"X-L$found_dir\"; then\n                        haveit=yes\n                        break\n                      fi\n                    done\n                    if test -z \"$haveit\"; then\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir\"\n                    fi\n                    if test \"$hardcode_minus_L\" != no; then\n                      dnl FIXME: Not sure whether we should use\n                      dnl \"-L$found_dir -l$name\" or \"-L$found_dir $found_so\"\n                      dnl here.\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                    else\n                      dnl We cannot use $hardcode_runpath_var and LD_RUN_PATH\n                      dnl here, because this doesn't fit in flags passed to the\n                      dnl compiler. So give up. No hardcoding. This affects only\n                      dnl very old systems.\n                      dnl FIXME: Not sure whether we should use\n                      dnl \"-L$found_dir -l$name\" or \"-L$found_dir $found_so\"\n                      dnl here.\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-l$name\"\n                    fi\n                  fi\n                fi\n              fi\n            else\n              if test \"X$found_a\" != \"X\"; then\n                dnl Linking with a static library.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_a\"\n              else\n                dnl We shouldn't come here, but anyway it's good to have a\n                dnl fallback.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir -l$name\"\n              fi\n            fi\n            dnl Assume the include files are nearby.\n            additional_includedir=\n            case \"$found_dir\" in\n              */lib | */lib/)\n                basedir=`echo \"X$found_dir\" | sed -e 's,^X,,' -e 's,/lib/*$,,'`\n                additional_includedir=\"$basedir/include\"\n                ;;\n            esac\n            if test \"X$additional_includedir\" != \"X\"; then\n              dnl Potentially add $additional_includedir to $INCNAME.\n              dnl But don't add it\n              dnl   1. if it's the standard /usr/include,\n              dnl   2. if it's /usr/local/include and we are using GCC on Linux,\n              dnl   3. if it's already present in $CPPFLAGS or the already\n              dnl      constructed $INCNAME,\n              dnl   4. if it doesn't exist as a directory.\n              if test \"X$additional_includedir\" != \"X/usr/include\"; then\n                haveit=\n                if test \"X$additional_includedir\" = \"X/usr/local/include\"; then\n                  if test -n \"$GCC\"; then\n                    case $host_os in\n                      linux* | gnu* | k*bsd*-gnu) haveit=yes;;\n                    esac\n                  fi\n                fi\n                if test -z \"$haveit\"; then\n                  for x in $CPPFLAGS $INC[]NAME; do\n                    AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                    if test \"X$x\" = \"X-I$additional_includedir\"; then\n                      haveit=yes\n                      break\n                    fi\n                  done\n                  if test -z \"$haveit\"; then\n                    if test -d \"$additional_includedir\"; then\n                      dnl Really add $additional_includedir to $INCNAME.\n                      INC[]NAME=\"${INC[]NAME}${INC[]NAME:+ }-I$additional_includedir\"\n                    fi\n                  fi\n                fi\n              fi\n            fi\n            dnl Look for dependencies.\n            if test -n \"$found_la\"; then\n              dnl Read the .la file. It defines the variables\n              dnl dlname, library_names, old_library, dependency_libs, current,\n              dnl age, revision, installed, dlopen, dlpreopen, libdir.\n              save_libdir=\"$libdir\"\n              case \"$found_la\" in\n                */* | *\\\\*) . \"$found_la\" ;;\n                *) . \"./$found_la\" ;;\n              esac\n              libdir=\"$save_libdir\"\n              dnl We use only dependency_libs.\n              for dep in $dependency_libs; do\n                case \"$dep\" in\n                  -L*)\n                    additional_libdir=`echo \"X$dep\" | sed -e 's/^X-L//'`\n                    dnl Potentially add $additional_libdir to $LIBNAME and $LTLIBNAME.\n                    dnl But don't add it\n                    dnl   1. if it's the standard /usr/lib,\n                    dnl   2. if it's /usr/local/lib and we are using GCC on Linux,\n                    dnl   3. if it's already present in $LDFLAGS or the already\n                    dnl      constructed $LIBNAME,\n                    dnl   4. if it doesn't exist as a directory.\n                    if test \"X$additional_libdir\" != \"X/usr/lib\"; then\n                      haveit=\n                      if test \"X$additional_libdir\" = \"X/usr/local/lib\"; then\n                        if test -n \"$GCC\"; then\n                          case $host_os in\n                            linux* | gnu* | k*bsd*-gnu) haveit=yes;;\n                          esac\n                        fi\n                      fi\n                      if test -z \"$haveit\"; then\n                        haveit=\n                        for x in $LDFLAGS $LIB[]NAME; do\n                          AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                          if test \"X$x\" = \"X-L$additional_libdir\"; then\n                            haveit=yes\n                            break\n                          fi\n                        done\n                        if test -z \"$haveit\"; then\n                          if test -d \"$additional_libdir\"; then\n                            dnl Really add $additional_libdir to $LIBNAME.\n                            LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$additional_libdir\"\n                          fi\n                        fi\n                        haveit=\n                        for x in $LDFLAGS $LTLIB[]NAME; do\n                          AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                          if test \"X$x\" = \"X-L$additional_libdir\"; then\n                            haveit=yes\n                            break\n                          fi\n                        done\n                        if test -z \"$haveit\"; then\n                          if test -d \"$additional_libdir\"; then\n                            dnl Really add $additional_libdir to $LTLIBNAME.\n                            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$additional_libdir\"\n                          fi\n                        fi\n                      fi\n                    fi\n                    ;;\n                  -R*)\n                    dir=`echo \"X$dep\" | sed -e 's/^X-R//'`\n                    if test \"$enable_rpath\" != no; then\n                      dnl Potentially add DIR to rpathdirs.\n                      dnl The rpathdirs will be appended to $LIBNAME at the end.\n                      haveit=\n                      for x in $rpathdirs; do\n                        if test \"X$x\" = \"X$dir\"; then\n                          haveit=yes\n                          break\n                        fi\n                      done\n                      if test -z \"$haveit\"; then\n                        rpathdirs=\"$rpathdirs $dir\"\n                      fi\n                      dnl Potentially add DIR to ltrpathdirs.\n                      dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.\n                      haveit=\n                      for x in $ltrpathdirs; do\n                        if test \"X$x\" = \"X$dir\"; then\n                          haveit=yes\n                          break\n                        fi\n                      done\n                      if test -z \"$haveit\"; then\n                        ltrpathdirs=\"$ltrpathdirs $dir\"\n                      fi\n                    fi\n                    ;;\n                  -l*)\n                    dnl Handle this in the next round.\n                    names_next_round=\"$names_next_round \"`echo \"X$dep\" | sed -e 's/^X-l//'`\n                    ;;\n                  *.la)\n                    dnl Handle this in the next round. Throw away the .la's\n                    dnl directory; it is already contained in a preceding -L\n                    dnl option.\n                    names_next_round=\"$names_next_round \"`echo \"X$dep\" | sed -e 's,^X.*/,,' -e 's,^lib,,' -e 's,\\.la$,,'`\n                    ;;\n                  *)\n                    dnl Most likely an immediate library name.\n                    LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$dep\"\n                    LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }$dep\"\n                    ;;\n                esac\n              done\n            fi\n          else\n            dnl Didn't find the library; assume it is in the system directories\n            dnl known to the linker and runtime loader. (All the system\n            dnl directories known to the linker should also be known to the\n            dnl runtime loader, otherwise the system is severely misconfigured.)\n            LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-l$name\"\n            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-l$name\"\n          fi\n        fi\n      fi\n    done\n  done\n  if test \"X$rpathdirs\" != \"X\"; then\n    if test -n \"$hardcode_libdir_separator\"; then\n      dnl Weird platform: only the last -rpath option counts, the user must\n      dnl pass all path elements in one option. We can arrange that for a\n      dnl single library, but not when more than one $LIBNAMEs are used.\n      alldirs=\n      for found_dir in $rpathdirs; do\n        alldirs=\"${alldirs}${alldirs:+$hardcode_libdir_separator}$found_dir\"\n      done\n      dnl Note: hardcode_libdir_flag_spec uses $libdir and $wl.\n      acl_save_libdir=\"$libdir\"\n      libdir=\"$alldirs\"\n      eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n      libdir=\"$acl_save_libdir\"\n      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$flag\"\n    else\n      dnl The -rpath options are cumulative.\n      for found_dir in $rpathdirs; do\n        acl_save_libdir=\"$libdir\"\n        libdir=\"$found_dir\"\n        eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n        libdir=\"$acl_save_libdir\"\n        LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$flag\"\n      done\n    fi\n  fi\n  if test \"X$ltrpathdirs\" != \"X\"; then\n    dnl When using libtool, the option that works for both libraries and\n    dnl executables is -R. The -R options are cumulative.\n    for found_dir in $ltrpathdirs; do\n      LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-R$found_dir\"\n    done\n  fi\n])\n\ndnl AC_LIB_APPENDTOVAR(VAR, CONTENTS) appends the elements of CONTENTS to VAR,\ndnl unless already present in VAR.\ndnl Works only for CPPFLAGS, not for LIB* variables because that sometimes\ndnl contains two or three consecutive elements that belong together.\nAC_DEFUN([AC_LIB_APPENDTOVAR],\n[\n  for element in [$2]; do\n    haveit=\n    for x in $[$1]; do\n      AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n      if test \"X$x\" = \"X$element\"; then\n        haveit=yes\n        break\n      fi\n    done\n    if test -z \"$haveit\"; then\n      [$1]=\"${[$1]}${[$1]:+ }$element\"\n    fi\n  done\n])\n\n# lib-ld.m4 serial 3 (gettext-0.13)\ndnl Copyright (C) 1996-2003 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl Subroutines of libtool.m4,\ndnl with replacements s/AC_/AC_LIB/ and s/lt_cv/acl_cv/ to avoid collision\ndnl with libtool.m4.\n\ndnl From libtool-1.4. Sets the variable with_gnu_ld to yes or no.\nAC_DEFUN([AC_LIB_PROG_LD_GNU],\n[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], acl_cv_prog_gnu_ld,\n[# I'd rather use --version here, but apparently some GNU ld's only accept -v.\ncase `$LD -v 2>&1 </dev/null` in\n*GNU* | *'with BFD'*)\n  acl_cv_prog_gnu_ld=yes ;;\n*)\n  acl_cv_prog_gnu_ld=no ;;\nesac])\nwith_gnu_ld=$acl_cv_prog_gnu_ld\n])\n\ndnl From libtool-1.4. Sets the variable LD.\nAC_DEFUN([AC_LIB_PROG_LD],\n[AC_ARG_WITH(gnu-ld,\n[  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]],\ntest \"$withval\" = no || with_gnu_ld=yes, with_gnu_ld=no)\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_CANONICAL_HOST])dnl\n# Prepare PATH_SEPARATOR.\n# The user is always right.\nif test \"${PATH_SEPARATOR+set}\" != set; then\n  echo \"#! /bin/sh\" >conf$$.sh\n  echo  \"exit 0\"   >>conf$$.sh\n  chmod +x conf$$.sh\n  if (PATH=\"/nonexistent;.\"; conf$$.sh) >/dev/null 2>&1; then\n    PATH_SEPARATOR=';'\n  else\n    PATH_SEPARATOR=:\n  fi\n  rm -f conf$$.sh\nfi\nac_prog=ld\nif test \"$GCC\" = yes; then\n  # Check if gcc -print-prog-name=ld gives a path.\n  AC_MSG_CHECKING([for ld used by GCC])\n  case $host in\n  *-*-mingw*)\n    # gcc leaves a trailing carriage return which upsets mingw\n    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\\015'` ;;\n  *)\n    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;\n  esac\n  case $ac_prog in\n    # Accept absolute paths.\n    [[\\\\/]* | [A-Za-z]:[\\\\/]*)]\n      [re_direlt='/[^/][^/]*/\\.\\./']\n      # Canonicalize the path of ld\n      ac_prog=`echo $ac_prog| sed 's%\\\\\\\\%/%g'`\n      while echo $ac_prog | grep \"$re_direlt\" > /dev/null 2>&1; do\n\tac_prog=`echo $ac_prog| sed \"s%$re_direlt%/%\"`\n      done\n      test -z \"$LD\" && LD=\"$ac_prog\"\n      ;;\n  \"\")\n    # If it fails, then pretend we aren't using GCC.\n    ac_prog=ld\n    ;;\n  *)\n    # If it is relative, then search for the first ld in PATH.\n    with_gnu_ld=unknown\n    ;;\n  esac\nelif test \"$with_gnu_ld\" = yes; then\n  AC_MSG_CHECKING([for GNU ld])\nelse\n  AC_MSG_CHECKING([for non-GNU ld])\nfi\nAC_CACHE_VAL(acl_cv_path_LD,\n[if test -z \"$LD\"; then\n  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}${PATH_SEPARATOR-:}\"\n  for ac_dir in $PATH; do\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f \"$ac_dir/$ac_prog\" || test -f \"$ac_dir/$ac_prog$ac_exeext\"; then\n      acl_cv_path_LD=\"$ac_dir/$ac_prog\"\n      # Check to see if the program is GNU ld.  I'd rather use --version,\n      # but apparently some GNU ld's only accept -v.\n      # Break only if it was the GNU/non-GNU ld that we prefer.\n      case `\"$acl_cv_path_LD\" -v 2>&1 < /dev/null` in\n      *GNU* | *'with BFD'*)\n\ttest \"$with_gnu_ld\" != no && break ;;\n      *)\n\ttest \"$with_gnu_ld\" != yes && break ;;\n      esac\n    fi\n  done\n  IFS=\"$ac_save_ifs\"\nelse\n  acl_cv_path_LD=\"$LD\" # Let the user override the test with a path.\nfi])\nLD=\"$acl_cv_path_LD\"\nif test -n \"$LD\"; then\n  AC_MSG_RESULT($LD)\nelse\n  AC_MSG_RESULT(no)\nfi\ntest -z \"$LD\" && AC_MSG_ERROR([no acceptable ld found in \\$PATH])\nAC_LIB_PROG_LD_GNU\n])\n\n# pkg.m4 - Macros to locate and utilise pkg-config.            -*- Autoconf -*-\n# \n# Copyright \u00a9 2004 Scott James Remnant <scott@netsplit.com>.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n#\n# As a special exception to the GNU General Public License, if you\n# distribute this file as part of a program that contains a\n# configuration script generated by Autoconf, you may include it under\n# the same distribution terms that you use for the rest of that program.\n\n# PKG_PROG_PKG_CONFIG([MIN-VERSION])\n# ----------------------------------\nAC_DEFUN([PKG_PROG_PKG_CONFIG],\n[m4_pattern_forbid([^_?PKG_[A-Z_]+$])\nm4_pattern_allow([^PKG_CONFIG(_PATH)?$])\nAC_ARG_VAR([PKG_CONFIG], [path to pkg-config utility])dnl\nif test \"x$ac_cv_env_PKG_CONFIG_set\" != \"xset\"; then\n\tAC_PATH_TOOL([PKG_CONFIG], [pkg-config])\nfi\nif test -n \"$PKG_CONFIG\"; then\n\t_pkg_min_version=m4_default([$1], [0.9.0])\n\tAC_MSG_CHECKING([pkg-config is at least version $_pkg_min_version])\n\tif $PKG_CONFIG --atleast-pkgconfig-version $_pkg_min_version; then\n\t\tAC_MSG_RESULT([yes])\n\telse\n\t\tAC_MSG_RESULT([no])\n\t\tPKG_CONFIG=\"\"\n\tfi\n\t\t\nfi[]dnl\n])# PKG_PROG_PKG_CONFIG\n\n# PKG_CHECK_EXISTS(MODULES, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])\n#\n# Check to see whether a particular set of modules exists.  Similar\n# to PKG_CHECK_MODULES(), but does not set variables or print errors.\n#\n#\n# Similar to PKG_CHECK_MODULES, make sure that the first instance of\n# this or PKG_CHECK_MODULES is called, or make sure to call\n# PKG_CHECK_EXISTS manually\n# --------------------------------------------------------------\nAC_DEFUN([PKG_CHECK_EXISTS],\n[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl\nif test -n \"$PKG_CONFIG\" && \\\n    AC_RUN_LOG([$PKG_CONFIG --exists --print-errors \"$1\"]); then\n  m4_ifval([$2], [$2], [:])\nm4_ifvaln([$3], [else\n  $3])dnl\nfi])\n\n\n# _PKG_CONFIG([VARIABLE], [COMMAND], [MODULES])\n# ---------------------------------------------\nm4_define([_PKG_CONFIG],\n[if test -n \"$PKG_CONFIG\"; then\n    if test -n \"$$1\"; then\n        pkg_cv_[]$1=\"$$1\"\n    else\n        PKG_CHECK_EXISTS([$3],\n                         [pkg_cv_[]$1=`$PKG_CONFIG --[]$2 \"$3\" 2>/dev/null`],\n\t\t\t [pkg_failed=yes])\n    fi\nelse\n\tpkg_failed=untried\nfi[]dnl\n])# _PKG_CONFIG\n\n# _PKG_SHORT_ERRORS_SUPPORTED\n# -----------------------------\nAC_DEFUN([_PKG_SHORT_ERRORS_SUPPORTED],\n[AC_REQUIRE([PKG_PROG_PKG_CONFIG])\nif $PKG_CONFIG --atleast-pkgconfig-version 0.20; then\n        _pkg_short_errors_supported=yes\nelse\n        _pkg_short_errors_supported=no\nfi[]dnl\n])# _PKG_SHORT_ERRORS_SUPPORTED\n\n\n# PKG_CHECK_MODULES(VARIABLE-PREFIX, MODULES, [ACTION-IF-FOUND],\n# [ACTION-IF-NOT-FOUND])\n#\n#\n# Note that if there is a possibility the first call to\n# PKG_CHECK_MODULES might not happen, you should be sure to include an\n# explicit call to PKG_PROG_PKG_CONFIG in your configure.ac\n#\n#\n# --------------------------------------------------------------\nAC_DEFUN([PKG_CHECK_MODULES],\n[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl\nAC_ARG_VAR([$1][_CFLAGS], [C compiler flags for $1, overriding pkg-config])dnl\nAC_ARG_VAR([$1][_LIBS], [linker flags for $1, overriding pkg-config])dnl\n\npkg_failed=no\nAC_MSG_CHECKING([for $1])\n\n_PKG_CONFIG([$1][_CFLAGS], [cflags], [$2])\n_PKG_CONFIG([$1][_LIBS], [libs], [$2])\n\nm4_define([_PKG_TEXT], [Alternatively, you may set the environment variables $1[]_CFLAGS\nand $1[]_LIBS to avoid the need to call pkg-config.\nSee the pkg-config man page for more details.])\n\nif test $pkg_failed = yes; then\n        _PKG_SHORT_ERRORS_SUPPORTED\n        if test $_pkg_short_errors_supported = yes; then\n\t        $1[]_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors \"$2\"`\n        else \n\t        $1[]_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors \"$2\"`\n        fi\n\t# Put the nasty error message in config.log where it belongs\n\techo \"$$1[]_PKG_ERRORS\" >&AS_MESSAGE_LOG_FD\n\n\tifelse([$4], , [AC_MSG_ERROR(dnl\n[Package requirements ($2) were not met:\n\n$$1_PKG_ERRORS\n\nConsider adjusting the PKG_CONFIG_PATH environment variable if you\ninstalled software in a non-standard prefix.\n\n_PKG_TEXT\n])],\n\t\t[$4])\nelif test $pkg_failed = untried; then\n\tifelse([$4], , [AC_MSG_FAILURE(dnl\n[The pkg-config script could not be found or is too old.  Make sure it\nis in your PATH or set the PKG_CONFIG environment variable to the full\npath to pkg-config.\n\n_PKG_TEXT\n\nTo get pkg-config, see <http://www.freedesktop.org/software/pkgconfig>.])],\n\t\t[$4])\nelse\n\t$1[]_CFLAGS=$pkg_cv_[]$1[]_CFLAGS\n\t$1[]_LIBS=$pkg_cv_[]$1[]_LIBS\n        AC_MSG_RESULT([yes])\n\tifelse([$3], , :, [$3])\nfi[]dnl\n])# PKG_CHECK_MODULES\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/README.CXXMODULES.md": "# C++ Modules in ROOT. Technology Preview\n\n*Vassil Vassilev, Oksana Shadura, Yuka Takahashi and Raphael Isemann*\n\n## Overview\n\nROOT has several features which interact with libraries and require implicit\nheader inclusion. This can be triggered by reading or writing data on disk,\nor user actions at the prompt. Often, the headers are immutable and reparsing is\nredundant. C++ Modules are designed to minimize the reparsing of the same\nheader content by providing an efficient on-disk representation of C++ Code.\n\nThe ROOT v6.16 release comes with a preview of the module technology;\ndedicated binaries have been built and can be reproduced by passing\n`-Druntime_cxxmodules=On` as configure flag. The goals of this technology\npreview are:\n  * Gain feedback from early adoption -- the technology is being long anticipated\n  by some of the users of ROOT. It improves correctness of ROOT and improves\n  performance when carefully adopted.\n  * Study performance bottlenecks -- the feature is designed with performance\n  considerations in mind. In this document we describe the current performance\n  bottlenecks and trade-offs.\n  * Understand if the gradual migration policy is sufficient -- C++ Modules in\n  ROOT support gradual migration. In particular, ROOT can enable C++ Modules for\n  itself and still run in legacy mode for the third-party code (generating\n  rootmap files and other scaffolding).\n\n\nC++ Modules are here and we would like to give a brief introduction of how the\nfeature works, what are its pros and cons, what's the current state of the\nimplementation and how third-party code can use it.\n\nRead more [[1]].\n\n## Design Goals\n\n  * Coherence with standard C++ -- C++ Modules TS is advancing and will be\n  likely part the upcoming C++20 standard;\n  * Performance -- provide performance that is competitive to ROOT with PCH and\n  advance further the implementation of the C++ Modules in clang to optimize\n  memory footprint and execution time;\n  * Incremental adoption -- provide third-party code with an incremental\n  migration process for their codebases.\n\n## Motivation\n\nAn implementation of the modules concepts exists in the LLVM frontend Clang used\nas a library by ROOT [[2]]. Clang supports the Modules TS and hosts modules \nresearch and development work. The implementation encourages incremental, \nbottom-up [[3]] adoption of the modules feature. Modules in Clang are designed\nto work for C, C++, ObjectiveC, ObjectiveC++ and Swift. Users can enable the\nmodules feature without modifications in header files. The LLVM compiler allows\nusers to specify module interfaces in dedicated file, called *module maps files*.\nA module map file expresses the mapping between a module file and a collection\nof header files. If the compiler finds such file in the include paths it\nautomatically generates, imports and uses module files. The module map files can\nbe mounted using the compiler's virtual file system overlay mechanism to\nnon-writable production library installations.\n\nIn practice, a non-invasive *modularization*  can be done easily by introducing\na module map file.\n\n```cpp\n// A.h   \nint pow2(int x) {\n  return x * x;\n}\n```\n```cpp\n// B.cpp\n#include \"A.h\" // clang rewires this to import A.\nint main() {\n  return pow2(42);\n}\n```\n\n```cpp\n// A.h module interface, aka module map file\nmodule A {\n  header \"A.h\"\n  export * // clang exports the contents of A.h as part of module A.\n}\n```\n\nA.h defines *pow2*, the module map file instructs clang to create *A.pcm* and\nimport it in B.cpp.\n\nIn a number of cases the module map files can be automatically generated if the\nbuild system knows about the list of header files in every package. \n\n\n### Header parsing in ROOT\n\n```cpp\n// A.h\n#include <string>\n#include <vector>\ntemplate <class T, class U = int> struct AStruct {\n  void doIt() { /*...*/ }\n  std::string Name; \n  std::vector<U> Collection;\n  // ...\n};\n\ntemplate<class T, class U = AStruct<T>>\ninline void freeFunction() { /* ... */ }\ninline void do(unsigned N = 1) { /* ... */ }\n\n```      \nThe associated with libA header files form libA's full descriptor. A.h,\npotentially only part of the descriptor of libA, expands to more than 26000\nlines of code.\n\n```cpp\n// Main.cpp\n#include \"A.h\"\nint main() {\n  do();\n  return 0;\n}\n\n```\nMain.cpp, reuses code from libA by including libA's descriptor and links against\nlibA. The full descriptor can contain thousands of files expanding to millions\nof lines of code -- a common case for framework libraries, for instance.\n\nROOT goes further and enhances C++ by allowing the following code to work without\nexplicitly requiring to `#include <A.h>`. Currently, ROOT's lack of support of\nline `#5` is a long-standing, known limitation that is lifted with modules.\n\n\n```cpp\n  // ROOT prompt\n root [] AStruct<float> S0;     // #1: implicit loading of libA. Full descriptor required.\n root [] AStruct<float>* S1;    // #2: implicit loading of libA. No full descriptor required.\n root [] if (gFile) S1->doIt(); // #3: implicit loading of libA. Full descriptor required.\n root [] gSystem->Load(\"libA\"); // #4: explicit loading of libA. No full descriptor required.\n root [] do();                  // #5: error: implicit loading of libA is currently unsupported.\n\n```\n\nThis pattern is not only used in the ROOT prompt but in I/O hotspots such as\n`ShowMembers` and `TClass::IsA`.\n\nA naive implementation of this feature would require inclusion of all reachable\nlibrary descriptors (aka header files) at ROOT startup time. Of course this is\nnot feasible and ROOT inserts a set of optimizations to fence itself from the\ncostly full header inclusion. Unfortunately, several of them are home-grown and\nin a few cases inaccurate (eg line #5) causing a noticeable technical debt.\n\nHere we will briefly describe the three common layers of optimizations: ROOT PCH,\nROOTMAP and RDICT.\n\nThe ROOT precompiled header (PCH) reduces the CPU and memory cost for ROOT's\nmost used libraries. The precompiled header technology is well-understood since\ndecades [[4]]. It is an efficient on-disk representation of the state of the\ncompiler after parsing a set of headers. It can be loaded before starting the\nnext instance to avoid doing redundant work. At build time, rootcling (ROOT's\ndictionary generator) creates such PCH file which is attached at ROOT startup\ntime. Its major drawback is the fact that if third-party users want to include\ntheir libraries, they have to recompile it every time there is a change.\n\nRDICT files store some useful information (in particular about class offsets) in\nROOT files to avoid the potentially expensive call to the interpreter if the\ninformation is not the PCH. For example, ROOT's libGeom and other third-party\ncode. This is done to circumvent the costly call to `ShowMembers` which will\nrequire parsing.\n\nROOTMAP files reduce parsing for code which is not in the PCH. Consider\n`foo::bar` and `S` are defined in `libFoo`'s `Foo.h`:\n```cpp\n// Foo.h\nnamespace foo { struct bar{}; }\nstruct S{};\n```\n\n```bash\n# libFoo.rootmap\n{ decls }\nnamespace foo { }\nstruct S;\n \n[ libFoo.so ]\n# List of selected classes\nclass bar\nstruct S\n```\n\n```cpp\n// G__Foo.cxx (aka libFoo dictionary)\nnamespace {\n  void TriggerDictionaryInitialization_libFoo_Impl() {\n    static const char* headers[] = {\"Foo.h\"}\n    // More scaffolding\n    extern int __Cling_Autoloading_Map;\n    namespace foo{struct __attribute__((annotate(\"$clingAutoload$Foo.h\"))) bar;}\n    struct __attribute__((annotate(\"$clingAutoload$Foo.h\"))) S;\n    // More initialization scaffolding.\n}\n```\n\nThe code snippet bellow demonstrates the efforts which ROOT does to\navoid parsing redundant code.\n\n```cpp\n// ROOT prompt\nroot [] S *s;           // #1: does not require a definition.\nroot [] foo::bar *baz1; // #2: does not require a definition.\nroot [] foo::bar baz2;  // #3: requires a definition.\n```\n\nWhen starting up ROOT, it will locate all files with extensions \\*.rootmap. It\nparses the code in section {decls} and creates an internal map for the entities\ndefined in \\[libFoo.so\\] section. Upon seeing an unknown identifier, the\nimplementation searches in the database if this is a known entity.\n\nLine #1 does not require a definition and the forward declaration consumed at\nstartup is sufficient. Parsing of `Foo.h` is not required. This comes at a cost\nof having some non-trivial patches in clang to merge default function arguments\nand default template arguments. The design of the the ROOTMAP infrastructure\nrequires the default arguments to be attached to more than one declaration which\nis not allowed by standard C++. The behavior of line #1 is equivalent to:\n```cpp\n// ROOT prompt\nroot [] namespace foo { };struct S;\nroot [] S *s;\n```\n\nLine #2 does not require a definition, however, the second identifier lookup\nfails. The implementation knows that `foo::bar` is in *libFoo*. It `dlopen`s\nlibFoo which in turn, during its static initialization, inserts annotated forward\ndeclaration as shown in `G__Foo.cxx`. In turn, this resolves `foo::bar` and\nparsing of `Foo.h` is again avoided at relatively small overhead. However, this\nis very hard to measure because the dictionary of each library can have different\namount of content. In the case where the library is big and the annotated\nforward declarations are many, and we want to include a relatively small header\nfile it may not pay off. Moreover, the loading of the annotated forward\ndeclarations can happen at any time during parsing. This is nick-named\n\"recursive parsing\" and is a code path that exists only in ROOT, never exercised\nby clang itself and is thus not well tested. The behavior of line #2 is\nequivalent to:\n```cpp\n// ROOT prompt\nroot [] namespace foo { };struct S;\nroot [] foo::bar/*store parsing state*/\n        gSystem->Load(\"Foo\");\n        // More scaffolding.\n        extern int __Cling_Autoloading_Map;\n        namespace foo{struct __attribute__((annotate(\"$clingAutoload$Foo.h\"))) bar;}\n        struct __attribute__((annotate(\"$clingAutoload$Foo.h\"))) S;\n        // More initialization scaffolding.\n        /*restore parsing state*/ *baz1;\n```\n\nLine #3 requires a definition and the implementation behaves exactly as in #2.\nThen it is informed that a definition is required, it reads the information in\nthe annotation and parses `Foo.h`. The recursive parsing happens at two places\nmaking this code path error prone.\n```cpp\n// ROOT prompt\nroot [] namespace foo { };struct S;\nroot [] foo::bar/*store parsing state*/\n        gSystem->Load(\"Foo\");\n        // More scaffolding.\n        extern int __Cling_Autoloading_Map;\n        namespace foo{struct __attribute__((annotate(\"$clingAutoload$Foo.h\"))) bar;}\n        struct __attribute__((annotate(\"$clingAutoload$Foo.h\"))) S;\n        // More initialization scaffolding.\n        /*restore parsing state*/ baz1 /*store parsing state*/\n        #include <Foo.h>/*restore parsing state*/;\n```\n\nTo recap, unfortunately, ROOT PCH is not extendable; ROOTMAP requires a lot of\nmaintenance and goes on a very untested codepath, while RDICT has a very limited\nscope. The three features require a lot of mechanisms to work together and the\ncorner cases are very many. The interaction between some of the features often\nbreak design and introduce layering violations.\n\n\n## From C++ Modules to Dictionaries\n\nC++ Modules have native capabilities to avoid reparsing. It combines all\nhome-grown solutions to avoid the costly operation at industry quality.\n\nCurrently, when ROOT is built with `-Druntime_cxxmodules=On` it gives priority to\nC++ Module files (real *pcm* files). If such a file is present it reads all\nnecessary information from it. If no such file is present ROOT falls back to the\nstandard information flow.\n\n### Observable differences from 'standard' ROOT\n\nAs always, ROOT is (mostly) API and ABI compatible. C++ Modules-aware ROOT is no\ndifferent. There are several differences which can be noticed:\n  * \\*modulemap files in $ROOTSYS/include -- those files are used by rootcling to\n  put a set of header files in a single pcm file. For example, all related\n  headers of *libGeom* are persisted in *Geom.pcm*. There are a few notable\n  examples, which are specific to the way we build ROOT. In certain cases we\n  want some header files to be compiled within C context or with RTTI on/off.\n  That's mostly for bootstrapping ROOT (aka rootcling stage1).\n  * modulemap.overlay.yaml -- automatically created virtual filesystem overlay\n  file. This file introduces C++ Modules for external dependencies.\n  For example, to 'modularize' glibc for ROOT we would need to place a modulemap\n  file in (usually) `/usr/include`. This folder is not writable on many\n  platforms. The vfs file tells the compiler to pretend there is a file at a\n  specific location. This way we 'mount' `/usr/include/module.modulemap`\n  non-invasively. The reasons why we need to extend the C++ modules support\n  beyond ROOT is described bellow.\n  * rootcling creates a new binary artifact *Name.pcm* after the library name --\n  this is a temporary solution for the current technology preview. Once we\n  advance further the implementation we will only create Name.pcm without the\n  other 2 artifacts. At a final stage, ROOT might be able to integrate the\n  Name.pcm with the shared library itself.\n  * Preloads all \\*pcm files at start up time -- this currently is the only\n  remaining bottleneck which introduces a relatively small performance overhead\n  at startup time and is described bellow. It will be negligible for third-\n  party code (dominated by header parsing).\n  * Improved correctness in number of cases -- in a few cases ROOT is more\n  correct. In particular, when resolving global variables and function\n  declarations which are not part of the ROOT PCH.\n  * Enhanced symbol resolution mechanisms, bloom filters -- standard ROOT relies\n  on information in ROOTMAP files to react when the llvm JIT issues an\n  unresolved symbol callback. C++ Modules-aware ROOT relies on a behavior much\n  closer to the standard linker behavior. In particular, we start searching on\n  the LD_LIBRARY_PATH descending to the system libraries. The algorithm is very\n  efficient because it uses bloom filters[[5]]. This in turn allows ROOT symbol\n  to be extended to system libraries.\n  \n### Supported Platforms\n\n  We support all platforms with glibc++ versions: 5.2, 6.2 and 7.2 and 8.\n\n  We have experimental support for OSX XCode 10.\n\n## Changes required by the users\n  * Self-contained header files -- every header file should be able to compile\n  on its own. For instance, `cat header.h header.h | gcc -fsyntax-only -xc++ -`.\n  This command concatenates `header.h` twice before compiling it to make sure\n  it has proper include protectors.\n  * Enable it in `rootcling` -- rootcling can produce a C++ Modules-aware\n  dictionary when it is invoked with `-cxxmodule` flag.\n  * Modularization of external dependencies -- if a header file is not explicitly\n  nominated as part of a module and it is transitively included in two modules,\n  both modules contain that header file content. In other words, the header is\n  duplicated. In turn, this leads to performance regressions. If a dictionary\n  depends on a header (directly or indirectly) from a external library (e.g.\n  libxml) it needs to be modularized. As part of our ongoing efforts to move\n  CMSSW to use C++ Modules [[6]] we have implemented a helper tool [[7]]. The\n  tool detects (based on the include paths of the compiler) dependencies and\n  tries to generate the relevant vfs file.\n\n## State of the union\n\nC++ Modules-aware ROOT preloads all modules at start up time. Our motivating\nexample:\n\n```cpp\n// ROOT prompt\nroot [] S *s;           // #1: does not require a definition.\nroot [] foo::bar *baz1; // #2: does not require a definition.\nroot [] foo::bar baz2;  // #3: requires a definition.\n```\n\nbecomes equivalent to\n\n```cpp\n// ROOT prompt\nroot [] import ROOT.*;\nroot [] import Foo.*;\nroot [] S *s;           // #1: does not require a definition.\nroot [] foo::bar *baz1; // #2: does not require a definition.\nroot [] foo::bar baz2;  // #3: requires a definition.\n```\n\nThe implementation avoids recursive actions and relies on a well-defined (by\nthe C++ standard) behavior. Currently, this comes with a constant performance\noverhead which we go in details bellow.\n\n\n### Current limitations\n  * Building pcms with rootcling -- in rare cases there might be issues when\n  building pcm files with rootcling. The easiest will be to open a bug report\n  to clang, however, reproducing a failure outside of rootcling is very difficult\n  at the moment.\n  * Generation of RooFit dictionary hangs -- on some platforms (depending on the\n  version of libstdc++) the generation of the RooFit dictionary goes in an\n  infinite loop. We have fixed a number of such situations. Please contact us if\n  you see such behavior or disable roofit (`-Droofit=Off`).\n\n### Performance\nThis section compares ROOT PCH technology with C++ Modules which is important but\nunfair comparison. As we noted earlier, PCH is very efficient, it cannot be\nextended to the experiments\u2019 software stacks because of its design constraints.\nOn the contrary, the C++ Modules can be used in third-party code where the PCH\nis not available.\n\nThe comparisons are to give a good metric when we are ready to switch ROOT to use\nC++ Modules by default. However, since it is essentially the same technology,\noptimizations of C++ Modules also affect the PCH. We have a few tricks up in\nthe slaves to but they come with given trade-offs. For example, we can avoid\npreloading of all modules at the cost of introducing recursive behavior in\nloading. This requires to build a global module index which is an on-disk\nhash table. It will contain information about the mapping between an\nidentifier and a module name. Upon failed identifier lookup we will use the\nmap to decide which set of modules should be loaded. Another optimization\nincludes building some of the modules without `-fmodules-local-submodule-visibility`.\nIn turn, this would flatten the C++ modules structure and give us performance\ncomparable to the ROOT PCH. The trade-off is that we will decrease the\nencapsulation and leak information about implementation-specific header files.\n\nThe main focus for this technology preview was not in performance due to\ntime considerations. We have invested some resources in optimizations and\nwe would like to show you (probably outdated) preliminary performance\nresults:\n\n  * Memory footprint -- mostly due to importing all C++ Modules at startup\n  we see overhead which depends on the number of preloaded modules. For\n  ROOT it is between 40-60 MB depending on the concrete configuration.\n  When the workload increases we notice that the overall memory performance\n  decreases in number of cases.\n  * Execution times -- likewise we have an execution overhead. For \n  workflows which take ms the slowdown can be 2x. Increasing of the work\n  to seconds shows 50-60% slowdowns.\n\nThe performance of the technology preview is dependent on many factors such\nas configuration of ROOT and workflow. You can read more at our Intel\nIPCC-ROOT Showcase presentation here (pp 25-33)[[8]].\n\nYou can visit our continuous performance monitoring tool where we compare\nthe performance of the technology preview with respect to 'standard' ROOT[[9]].\n*Note: if you get error 400, clean your cache or open a private browser session.*\n\n## How to use\n  Compile ROOT with `-Druntime_cxxmodules=On`. Enjoy.\n\n## Citing ROOT's C++ Modules\n```latex\n% Peer-Reviewed Publication\n%\n% 22nd International Conference on Computing in High Energy and Nuclear Physics (CHEP)\n% 8-14 October, 2016, San Francisco, USA\n%\n@inproceedings{Vassilev_ROOTModules,\n  author = {Vassilev,V.},\n  title = {{Optimizing ROOT's Performance Using C++ Modules}},\n  journal = {Journal of Physics: Conference Series},\n  year = 2017,\n  month = {oct},\n  volume = {898},\n  number = {7},\n  pages = {072023},\n  doi = {10.1088/1742-6596/898/7/072023},\n  url = {https://iopscience.iop.org/article/10.1088/1742-6596/898/7/072023/pdf},\n  publisher = {{IOP} Publishing}\n}\n```\n  \n# Acknowledgement\n\nWe would like to thank the ROOT team.\n\nWe would like to thank Liz Sexton-Kennedy (FNAL) in particular for supporting\nthis project.\n\nWe would like to thank Axel Naumann for early feedback on this document.\n\nThis work has been supported by an Intel Parallel Computing Center grant, by U.S.\nNational Science Foundation grants PHY-1450377 and PHY-1624356, and by the U.S.\nDepartment of Energy, Office of Science.\n\n\n# References\n(1): [Vassilev, V., 2017, October. Optimizing ROOT's Performance Using C++ Modules. In Journal of Physics: Conference Series (Vol. 898, No. 7, p. 072023). IOP Publishing.][1]\n\n(2): [Clang Modules, Official Documentation][2]\n\n(3): [Manuel Klimek, Deploying C++ Modules to 100s of Millions of Lines of Code, 2016, CppCon][3]\n\n(4): [Precompiled Header and Modules Internals, Official Documentation][4]\n\n(5): [Bloom Filter][5]\n\n(6): [C++ Modules support (based on Clang), GitHub Repo][5]\n\n(7): [Make your third party libraries modular][6]\n\n(8): [Vassilev, V., Shadura, O., Takahashi, Y., IPCC-ROOT Showcase Presentation, Nov, 2018][7]\n\n(9): [ROOT Continuous Performance Monitoring System][8]\n\n\n\n[//]: # (Links)\n[1]: https://www.researchgate.net/profile/Vassil_Vassilev3/publication/319717664_Optimizing_ROOT%27s_Performance_Using_C_Modules/links/59bad690aca272aff2d01c1c/Optimizing-ROOTs-Performance-Using-C-Modules.pdf \"Vassilev, V., 2017, October. Optimizing ROOT\u2019s Performance Using C++ Modules. In Journal of Physics: Conference Series (Vol. 898, No. 7, p. 072023). IOP Publishing.\"\n\n[2]: https://clang.llvm.org/docs/Modules.html \"Clang Modules\"\n\n[3]: https://cppcon2016.sched.com/event/7nM2/deploying-c-modules-to-100s-of-millions-of-lines-of-code \"Deploying C++ Modules to 100s of Millions of Lines of Code\"\n\n[4]: https://clang.llvm.org/docs/PCHInternals.html \"Precompiled Header and Modules Internals\"\n\n[5]: https://en.wikipedia.org/wiki/Bloom_filter \"Bloom Filter\"\n\n[6]: https://github.com/cms-sw/cmssw/issues/15248 \"C++ Modules support (based on Clang)\"\n\n[7]: https://github.com/Teemperor/ClangAutoModules \"Make your third party libraries modular\"\n\n[8]: https://ipcc-root.github.io/downloads/20181108-ipcc-princeton-showcase-presentation.pdf \"IPCC-ROOT Showcase Presentation\"\n\n[9]: http://root-bench.cern.ch/ \"ROOT Continuous Performance Monitoring System\"\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/core/base/src/TROOT.cxx": "// @(#)root/base:$Id$\n// Author: Rene Brun   08/12/94\n\n/*************************************************************************\n * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *\n * All rights reserved.                                                  *\n *                                                                       *\n * For the licensing terms see $ROOTSYS/LICENSE.                         *\n * For the list of contributors see $ROOTSYS/README/CREDITS.             *\n *************************************************************************/\n\n/** \\class TROOT\n\\ingroup Base\n\nROOT top level object description.\n\nThe TROOT object is the entry point to the ROOT system.\nThe single instance of TROOT is accessible via the global gROOT.\nUsing the gROOT pointer one has access to basically every object\ncreated in a ROOT based program. The TROOT object is essentially a\ncontainer of several lists pointing to the main ROOT objects.\n\nThe following lists are accessible from gROOT object:\n\n~~~ {.cpp}\n      gROOT->GetListOfClasses\n      gROOT->GetListOfColors\n      gROOT->GetListOfTypes\n      gROOT->GetListOfGlobals\n      gROOT->GetListOfGlobalFunctions\n      gROOT->GetListOfFiles\n      gROOT->GetListOfMappedFiles\n      gROOT->GetListOfSockets\n      gROOT->GetListOfSecContexts\n      gROOT->GetListOfCanvases\n      gROOT->GetListOfStyles\n      gROOT->GetListOfFunctions\n      gROOT->GetListOfSpecials (for example graphical cuts)\n      gROOT->GetListOfGeometries\n      gROOT->GetListOfBrowsers\n      gROOT->GetListOfCleanups\n      gROOT->GetListOfMessageHandlers\n~~~\n\nThe TROOT class provides also many useful services:\n  - Get pointer to an object in any of the lists above\n  - Time utilities TROOT::Time\n\nThe ROOT object must be created as a static object. An example\nof a main program creating an interactive version is shown below:\n\n### Example of a main program\n\n~~~ {.cpp}\n      #include \"TRint.h\"\n\n      int main(int argc, char **argv)\n      {\n         TRint *theApp = new TRint(\"ROOT example\", &argc, argv);\n\n         // Init Intrinsics, build all windows, and enter event loop\n         theApp->Run();\n\n         return(0);\n      }\n~~~\n*/\n\n#include <ROOT/RConfig.hxx>\n#include \"RConfigure.h\"\n#include \"RConfigOptions.h\"\n#include \"RVersion.h\"\n#include \"RGitCommit.h\"\n\n#include <string>\n#include <map>\n#include <stdlib.h>\n#ifdef WIN32\n#include <io.h>\n#include \"Windows4Root.h\"\n#include <Psapi.h>\n#define RTLD_DEFAULT ((void *)::GetModuleHandle(NULL))\n//#define dlsym(library, function_name) ::GetProcAddress((HMODULE)library, function_name)\n#define dlopen(library_name, flags) ::LoadLibrary(library_name)\n#define dlclose(library) ::FreeLibrary((HMODULE)library)\nchar *dlerror() {\n   static char Msg[1000];\n   FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(),\n                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), Msg,\n                 sizeof(Msg), NULL);\n   return Msg;\n}\nFARPROC dlsym(void *library, const char *function_name)\n{\n   HMODULE hMods[1024];\n   DWORD cbNeeded;\n   FARPROC address = NULL;\n   unsigned int i;\n   if (library == RTLD_DEFAULT) {\n      if (EnumProcessModules(::GetCurrentProcess(), hMods, sizeof(hMods), &cbNeeded)) {\n         for (i = 0; i < (cbNeeded / sizeof(HMODULE)); i++) {\n            address = ::GetProcAddress((HMODULE)hMods[i], function_name);\n            if (address)\n               return address;\n         }\n      }\n      return address;\n   } else {\n      return ::GetProcAddress((HMODULE)library, function_name);\n   }\n}\n#else\n#include <dlfcn.h>\n#endif\n\n#include \"Riostream.h\"\n#include \"ROOT/FoundationUtils.hxx\"\n#include \"TROOT.h\"\n#include \"TClass.h\"\n#include \"TClassEdit.h\"\n#include \"TClassGenerator.h\"\n#include \"TDataType.h\"\n#include \"TDatime.h\"\n#include \"TStyle.h\"\n#include \"TObjectTable.h\"\n#include \"TClassTable.h\"\n#include \"TSystem.h\"\n#include \"THashList.h\"\n#include \"TObjArray.h\"\n#include \"TEnv.h\"\n#include \"TError.h\"\n#include \"TColor.h\"\n#include \"TGlobal.h\"\n#include \"TFunction.h\"\n#include \"TVirtualPad.h\"\n#include \"TBrowser.h\"\n#include \"TSystemDirectory.h\"\n#include \"TApplication.h\"\n#include \"TInterpreter.h\"\n#include \"TGuiFactory.h\"\n#include \"TMessageHandler.h\"\n#include \"TFolder.h\"\n#include \"TQObject.h\"\n#include \"TProcessUUID.h\"\n#include \"TPluginManager.h\"\n#include \"TMap.h\"\n#include \"TObjString.h\"\n#include \"TVirtualMutex.h\"\n#include \"TInterpreter.h\"\n#include \"TListOfTypes.h\"\n#include \"TListOfDataMembers.h\"\n#include \"TListOfEnumsWithLock.h\"\n#include \"TListOfFunctions.h\"\n#include \"TListOfFunctionTemplates.h\"\n#include \"TFunctionTemplate.h\"\n#include \"ThreadLocalStorage.h\"\n#include \"TVirtualRWMutex.h\"\n\n#include <string>\nnamespace std {} using namespace std;\n\n#if defined(R__UNIX)\n#if defined(R__HAS_COCOA)\n#include \"TMacOSXSystem.h\"\n#include \"TUrl.h\"\n#else\n#include \"TUnixSystem.h\"\n#endif\n#elif defined(R__WIN32)\n#include \"TWinNTSystem.h\"\n#endif\n\nextern \"C\" void R__SetZipMode(int);\n\nstatic DestroyInterpreter_t *gDestroyInterpreter = 0;\nstatic void *gInterpreterLib = 0;\n\n// Mutex for protection of concurrent gROOT access\nTVirtualMutex* gROOTMutex = 0;\nROOT::TVirtualRWMutex *ROOT::gCoreMutex = nullptr;\n\n// For accessing TThread::Tsd indirectly.\nvoid **(*gThreadTsd)(void*,Int_t) = 0;\n\n//-------- Names of next three routines are a small homage to CMZ --------------\n////////////////////////////////////////////////////////////////////////////////\n/// Return version id as an integer, i.e. \"2.22/04\" -> 22204.\n\nstatic Int_t IVERSQ()\n{\n   Int_t maj, min, cycle;\n   sscanf(ROOT_RELEASE, \"%d.%d/%d\", &maj, &min, &cycle);\n   return 10000*maj + 100*min + cycle;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return built date as integer, i.e. \"Apr 28 2000\" -> 20000428.\n\nstatic Int_t IDATQQ(const char *date)\n{\n   static const char *months[] = {\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\n                                  \"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\n                                  \"Nov\",\"Dec\"};\n\n   char  sm[12];\n   Int_t yy, mm=0, dd;\n   sscanf(date, \"%s %d %d\", sm, &dd, &yy);\n   for (int i = 0; i < 12; i++)\n      if (!strncmp(sm, months[i], 3)) {\n         mm = i+1;\n         break;\n      }\n   return 10000*yy + 100*mm + dd;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return built time as integer (with min precision), i.e.\n/// \"17:32:37\" -> 1732.\n\nstatic Int_t ITIMQQ(const char *time)\n{\n   Int_t hh, mm, ss;\n   sscanf(time, \"%d:%d:%d\", &hh, &mm, &ss);\n   return 100*hh + mm;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Clean up at program termination before global objects go out of scope.\n\nstatic void CleanUpROOTAtExit()\n{\n   if (gROOT) {\n      R__LOCKGUARD(gROOTMutex);\n\n      if (gROOT->GetListOfFiles())\n         gROOT->GetListOfFiles()->Delete(\"slow\");\n      if (gROOT->GetListOfSockets())\n         gROOT->GetListOfSockets()->Delete();\n      if (gROOT->GetListOfMappedFiles())\n         gROOT->GetListOfMappedFiles()->Delete(\"slow\");\n      if (gROOT->GetListOfClosedObjects())\n         gROOT->GetListOfClosedObjects()->Delete(\"slow\");\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// A module and its headers. Intentionally not a copy:\n/// If these strings end up in this struct they are\n/// long lived by definition because they get passed in\n/// before initialization of TCling.\n\nnamespace {\n   struct ModuleHeaderInfo_t {\n      ModuleHeaderInfo_t(const char* moduleName,\n                         const char** headers,\n                         const char** includePaths,\n                         const char* payloadCode,\n                         const char* fwdDeclCode,\n                         void (*triggerFunc)(),\n                         const TROOT::FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,\n                         const char **classesHeaders,\n                         bool hasCxxModule):\n                           fModuleName(moduleName),\n                           fHeaders(headers),\n                           fPayloadCode(payloadCode),\n                           fFwdDeclCode(fwdDeclCode),\n                           fIncludePaths(includePaths),\n                           fTriggerFunc(triggerFunc),\n                           fClassesHeaders(classesHeaders),\n                           fFwdNargsToKeepColl(fwdDeclsArgToSkip),\n                           fHasCxxModule(hasCxxModule) {}\n\n      const char* fModuleName; // module name\n      const char** fHeaders; // 0-terminated array of header files\n      const char* fPayloadCode; // Additional code to be given to cling at library load\n      const char* fFwdDeclCode; // Additional code to let cling know about selected classes and functions\n      const char** fIncludePaths; // 0-terminated array of header files\n      void (*fTriggerFunc)(); // Pointer to the dict initialization used to find the library name\n      const char** fClassesHeaders; // 0-terminated list of classes and related header files\n      const TROOT::FwdDeclArgsToKeepCollection_t fFwdNargsToKeepColl; // Collection of\n                                                                      // pairs of template fwd decls and number of\n      bool fHasCxxModule; // Whether this module has a C++ module alongside it.\n   };\n\n   std::vector<ModuleHeaderInfo_t>& GetModuleHeaderInfoBuffer() {\n      static std::vector<ModuleHeaderInfo_t> moduleHeaderInfoBuffer;\n      return moduleHeaderInfoBuffer;\n   }\n}\n\nInt_t  TROOT::fgDirLevel = 0;\nBool_t TROOT::fgRootInit = kFALSE;\nBool_t TROOT::fgMemCheck = kFALSE;\n\nstatic void at_exit_of_TROOT() {\n   if (ROOT::Internal::gROOTLocal)\n      ROOT::Internal::gROOTLocal->~TROOT();\n}\n\n// This local static object initializes the ROOT system\nnamespace ROOT {\nnamespace Internal {\n   class TROOTAllocator {\n      // Simple wrapper to separate, time-wise, the call to the\n      // TROOT destructor and the actual free-ing of the memory.\n      //\n      // Since the interpreter implementation (currently TCling) is\n      // loaded via dlopen by libCore, the destruction of its global\n      // variable (i.e. in particular clang's) is scheduled before\n      // those in libCore so we need to schedule the call to the TROOT\n      // destructor before that *but* we want to make sure the memory\n      // stay around until libCore itself is unloaded so that code\n      // using gROOT can 'properly' check for validity.\n      //\n      // The order of loading for is:\n      //    libCore.so\n      //    libRint.so\n      //    ... anything other library hard linked to the executable ...\n      //    ... for example libEvent\n      //    libCling.so\n      //    ... other libraries like libTree for example ....\n      // and the destruction order is (of course) the reverse.\n      // By default the unloading of the dictionary, does use\n      // the service of the interpreter ... which of course\n      // fails if libCling is already unloaded by that information\n      // has not been registered per se.\n      //\n      // To solve this problem, we now schedule the destruction\n      // of the TROOT object to happen _just_ before the\n      // unloading/destruction of libCling so that we can\n      // maximize the amount of clean-up we can do correctly\n      // and we can still allocate the TROOT object's memory\n      // statically.\n      //\n      char fHolder[sizeof(TROOT)];\n   public:\n      TROOTAllocator() {\n         new(&(fHolder[0])) TROOT(\"root\", \"The ROOT of EVERYTHING\");\n      }\n\n      ~TROOTAllocator() {\n         if (gROOTLocal) {\n            gROOTLocal->~TROOT();\n         }\n      }\n   };\n\n   // The global gROOT is defined to be a function (ROOT::GetROOT())\n   // which itself is dereferencing a function pointer.\n\n   // Initially this function pointer's value is & GetROOT1 whose role is to\n   // create and initialize the TROOT object itself.\n   // At the very end of the TROOT constructor the value of the function pointer\n   // is switch to & GetROOT2 whose role is to initialize the interpreter.\n\n   // This mechanism was primarily intended to fix the issues with order in which\n   // global TROOT and LLVM globals are initialized. TROOT was initializing\n   // Cling, but Cling could not be used yet due to LLVM globals not being\n   // Initialized yet.  The solution is to delay initializing the interpreter in\n   // TROOT till after main() when all LLVM globals are initialized.\n\n   // Technically, the mechanism used actually delay the interpreter\n   // initialization until the first use of gROOT *after* the end of the\n   // TROOT constructor.\n\n   // So to delay until after the start of main, we also made sure that none\n   // of the ROOT code (mostly the dictionary code) used during library loading\n   // is using gROOT (directly or indirectly).\n\n   // In practice, the initialization of the interpreter is now delayed until\n   // the first use gROOT (or gInterpreter) after the start of main (but user\n   // could easily break this by using gROOT in their library initialization\n   // code).\n\n   extern TROOT *gROOTLocal;\n\n   TROOT *GetROOT1() {\n      if (gROOTLocal)\n         return gROOTLocal;\n      static TROOTAllocator alloc;\n      return gROOTLocal;\n   }\n\n   TROOT *GetROOT2() {\n      static Bool_t initInterpreter = kFALSE;\n      if (!initInterpreter) {\n         initInterpreter = kTRUE;\n         gROOTLocal->InitInterpreter();\n         // Load and init threads library\n         gROOTLocal->InitThreads();\n      }\n      return gROOTLocal;\n   }\n   typedef TROOT *(*GetROOTFun_t)();\n\n   static GetROOTFun_t gGetROOT = &GetROOT1;\n\n   static Func_t GetSymInLibImt(const char *funcname)\n   {\n      const static bool loadSuccess = dlsym(RTLD_DEFAULT, \"usedToIdentifyRootClingByDlSym\")? false : 0 <= gSystem->Load(\"libImt\");\n      if (loadSuccess) {\n         if (auto sym = gSystem->DynFindSymbol(nullptr, funcname)) {\n            return sym;\n         } else {\n            Error(\"GetSymInLibImt\", \"Cannot get symbol %s.\", funcname);\n         }\n      }\n      return nullptr;\n   }\n\n   //////////////////////////////////////////////////////////////////////////////\n   /// Globally enables the parallel branch processing, which is a case of\n   /// implicit multi-threading (IMT) in ROOT, activating the required locks.\n   /// This IMT use case, implemented in TTree::GetEntry, spawns a task for\n   /// each branch of the tree. Therefore, a task takes care of the reading,\n   /// decompression and deserialisation of a given branch.\n   void EnableParBranchProcessing()\n   {\n#ifdef R__USE_IMT\n      if (!IsImplicitMTEnabled())\n         EnableImplicitMT();\n      static void (*sym)() = (void(*)())Internal::GetSymInLibImt(\"ROOT_TImplicitMT_EnableParBranchProcessing\");\n      if (sym)\n         sym();\n#else\n      ::Warning(\"EnableParBranchProcessing\", \"Cannot enable parallel branch processing, please build ROOT with -Dimt=ON\");\n#endif\n   }\n\n   //////////////////////////////////////////////////////////////////////////////\n   /// Globally disables the IMT use case of parallel branch processing,\n   /// deactivating the corresponding locks.\n   void DisableParBranchProcessing()\n   {\n#ifdef R__USE_IMT\n      static void (*sym)() = (void(*)())Internal::GetSymInLibImt(\"ROOT_TImplicitMT_DisableParBranchProcessing\");\n      if (sym)\n         sym();\n#else\n      ::Warning(\"DisableParBranchProcessing\", \"Cannot disable parallel branch processing, please build ROOT with -Dimt=ON\");\n#endif\n   }\n\n   //////////////////////////////////////////////////////////////////////////////\n   /// Returns true if parallel branch processing is enabled.\n   Bool_t IsParBranchProcessingEnabled()\n   {\n#ifdef R__USE_IMT\n      static Bool_t (*sym)() = (Bool_t(*)())Internal::GetSymInLibImt(\"ROOT_TImplicitMT_IsParBranchProcessingEnabled\");\n      if (sym)\n         return sym();\n      else\n         return kFALSE;\n#else\n      return kFALSE;\n#endif\n   }\n\n   ////////////////////////////////////////////////////////////////////////////////\n   /// Globally enables the parallel tree processing, which is a case of\n   /// implicit multi-threading in ROOT, activating the required locks.\n   /// This IMT use case, implemented in TTreeProcessor::Process, receives a user\n   /// function and applies it to subranges of the tree, which correspond to its\n   /// clusters. Hence, for every cluster, a task is spawned to potentially\n   /// process it in parallel with the other clusters.\n   void EnableParTreeProcessing()\n   {\n#ifdef R__USE_IMT\n      if (!IsImplicitMTEnabled())\n         EnableImplicitMT();\n      static void (*sym)() = (void(*)())Internal::GetSymInLibImt(\"ROOT_TImplicitMT_EnableParTreeProcessing\");\n      if (sym)\n         sym();\n#else\n      ::Warning(\"EnableParTreeProcessing\", \"Cannot enable parallel tree processing, please build ROOT with -Dimt=ON\");\n#endif\n   }\n\n   //////////////////////////////////////////////////////////////////////////////\n   /// Globally disables the IMT use case of parallel branch processing,\n   /// deactivating the corresponding locks.\n   void DisableParTreeProcessing()\n   {\n#ifdef R__USE_IMT\n      static void (*sym)() = (void(*)())Internal::GetSymInLibImt(\"ROOT_TImplicitMT_DisableParTreeProcessing\");\n      if (sym)\n         sym();\n#else\n      ::Warning(\"DisableParTreeProcessing\", \"Cannot disable parallel tree processing, please build ROOT with -Dimt=ON\");\n#endif\n   }\n\n   ////////////////////////////////////////////////////////////////////////////////\n   /// Returns true if parallel tree processing is enabled.\n   Bool_t IsParTreeProcessingEnabled()\n   {\n#ifdef R__USE_IMT\n      static Bool_t (*sym)() = (Bool_t(*)())Internal::GetSymInLibImt(\"ROOT_TImplicitMT_IsParTreeProcessingEnabled\");\n      if (sym)\n         return sym();\n      else\n         return kFALSE;\n#else\n      return kFALSE;\n#endif\n   }\n\n   ////////////////////////////////////////////////////////////////////////////////\n   /// Keeps track of the status of ImplicitMT w/o resorting to the load of\n   /// libImt\n   static Bool_t &IsImplicitMTEnabledImpl()\n   {\n      static Bool_t isImplicitMTEnabled = kFALSE;\n      return isImplicitMTEnabled;\n   }\n\n} // end of Internal sub namespace\n// back to ROOT namespace\n\n   TROOT *GetROOT() {\n      return (*Internal::gGetROOT)();\n   }\n\n   TString &GetMacroPath() {\n      static TString macroPath;\n      return macroPath;\n   }\n\n   // clang-format off\n   ////////////////////////////////////////////////////////////////////////////////\n   /// Enables the global mutex to make ROOT thread safe/aware.\n   ///\n   /// The following becomes safe:\n   /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles())\n   /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas)\n   /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum\n   /// - concurrent calls to the interpreter through gInterpreter\n   /// - concurrent loading of ROOT plug-ins\n   ///\n   /// In addition, gDirectory, gFile and gPad become a thread-local variable.\n   /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.\n   /// gFile and gPad default to nullptr, as it is for single-thread programs.\n   ///\n   /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different\n   /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.\n   ///\n   /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.\n   // clang-format on\n   void EnableThreadSafety()\n   {\n      static void (*sym)() = (void(*)())Internal::GetSymInLibImt(\"ROOT_TThread_Initialize\");\n      if (sym)\n         sym();\n   }\n\n   ////////////////////////////////////////////////////////////////////////////////\n   /// @param[in] numthreads Number of threads to use. If not specified or\n   ///                       set to zero, the number of threads is automatically\n   ///                       decided by the implementation. Any other value is\n   ///                       used as a hint.\n   ///\n   /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.\n   /// The following objects and methods automatically take advantage of\n   /// multi-threading if a call to `EnableImplicitMT` has been made before usage:\n   ///\n   ///  - RDataFrame internally runs the event-loop by parallelizing over clusters of entries\n   ///  - TTree::GetEntry reads multiple branches in parallel\n   ///  - TTree::FlushBaskets writes multiple baskets to disk in parallel\n   ///  - TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel\n   ///  - THx::Fit performs in parallel the evaluation of the objective function over the data\n   ///  - TMVA::DNN trains the deep neural networks in parallel\n   ///  - TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel\n   ///\n   /// EnableImplicitMT calls in turn EnableThreadSafety.\n   /// The 'numthreads' parameter allows to control the number of threads to\n   /// be used by the implicit multi-threading. However, this parameter is just\n   /// a hint for ROOT: it will try to satisfy the request if the execution\n   /// scenario allows it. For example, if ROOT is configured to use an external\n   /// scheduler, setting a value for 'numthreads' might not have any effect.\n   void EnableImplicitMT(UInt_t numthreads)\n   {\n#ifdef R__USE_IMT\n      if (ROOT::Internal::IsImplicitMTEnabledImpl())\n         return;\n      EnableThreadSafety();\n      static void (*sym)(UInt_t) = (void(*)(UInt_t))Internal::GetSymInLibImt(\"ROOT_TImplicitMT_EnableImplicitMT\");\n      if (sym)\n         sym(numthreads);\n      ROOT::Internal::IsImplicitMTEnabledImpl() = true;\n#else\n      ::Warning(\"EnableImplicitMT\", \"Cannot enable implicit multi-threading with %d threads, please build ROOT with -Dimt=ON\", numthreads);\n#endif\n   }\n\n   ////////////////////////////////////////////////////////////////////////////////\n   /// Disables the implicit multi-threading in ROOT (see EnableImplicitMT).\n   void DisableImplicitMT()\n   {\n#ifdef R__USE_IMT\n      static void (*sym)() = (void(*)())Internal::GetSymInLibImt(\"ROOT_TImplicitMT_DisableImplicitMT\");\n      if (sym)\n         sym();\n      ROOT::Internal::IsImplicitMTEnabledImpl() = kFALSE;\n#else\n      ::Warning(\"DisableImplicitMT\", \"Cannot disable implicit multi-threading, please build ROOT with -Dimt=ON\");\n#endif\n   }\n\n   ////////////////////////////////////////////////////////////////////////////////\n   /// Returns true if the implicit multi-threading in ROOT is enabled.\n   Bool_t IsImplicitMTEnabled()\n   {\n      return ROOT::Internal::IsImplicitMTEnabledImpl();\n   }\n\n   ////////////////////////////////////////////////////////////////////////////////\n   /// Returns the size of the pool used for implicit multi-threading.\n   UInt_t GetImplicitMTPoolSize()\n   {\n#ifdef R__USE_IMT\n      static UInt_t (*sym)() = (UInt_t(*)())Internal::GetSymInLibImt(\"ROOT_TImplicitMT_GetImplicitMTPoolSize\");\n      if (sym)\n         return sym();\n      else\n         return 0;\n#else\n      return 0;\n#endif\n   }\n\n}\n\nTROOT *ROOT::Internal::gROOTLocal = ROOT::GetROOT();\n\n// Global debug flag (set to > 0 to get debug output).\n// Can be set either via the interpreter (gDebug is exported to CINT),\n// via the rootrc resource \"Root.Debug\", via the shell environment variable\n// ROOTDEBUG, or via the debugger.\nInt_t gDebug;\n\n\nClassImp(TROOT);\n\n////////////////////////////////////////////////////////////////////////////////\n/// Default ctor.\n\nTROOT::TROOT() : TDirectory(),\n     fLineIsProcessing(0), fVersion(0), fVersionInt(0), fVersionCode(0),\n     fVersionDate(0), fVersionTime(0), fBuiltDate(0), fBuiltTime(0),\n     fTimer(0), fApplication(0), fInterpreter(0), fBatch(kTRUE),\n     fIsWebDisplay(kFALSE), fIsWebDisplayBatch(kFALSE), fEditHistograms(kTRUE),\n     fFromPopUp(kTRUE),fMustClean(kTRUE),fReadingObject(kFALSE),fForceStyle(kFALSE),\n     fInterrupt(kFALSE),fEscape(kFALSE),fExecutingMacro(kFALSE),fEditorMode(0),\n     fPrimitive(0),fSelectPad(0),fClasses(0),fTypes(0),fGlobals(0),fGlobalFunctions(0),\n     fClosedObjects(0),fFiles(0),fMappedFiles(0),fSockets(0),fCanvases(0),fStyles(0),fFunctions(0),\n     fTasks(0),fColors(0),fGeometries(0),fBrowsers(0),fSpecials(0),fCleanups(0),\n     fMessageHandlers(0),fStreamerInfo(0),fClassGenerators(0),fSecContexts(0),\n     fProofs(0),fClipboard(0),fDataSets(0),fUUIDs(0),fRootFolder(0),fBrowsables(0),\n     fPluginManager(0)\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Initialize the ROOT system. The creation of the TROOT object initializes\n/// the ROOT system. It must be the first ROOT related action that is\n/// performed by a program. The TROOT object must be created on the stack\n/// (can not be called via new since \"operator new\" is protected). The\n/// TROOT object is either created as a global object (outside the main()\n/// program), or it is one of the first objects created in main().\n/// Make sure that the TROOT object stays in scope for as long as ROOT\n/// related actions are performed. TROOT is a so called singleton so\n/// only one instance of it can be created. The single TROOT object can\n/// always be accessed via the global pointer gROOT.\n/// The name and title arguments can be used to identify the running\n/// application. The initfunc argument can contain an array of\n/// function pointers (last element must be 0). These functions are\n/// executed at the end of the constructor. This way one can easily\n/// extend the ROOT system without adding permanent dependencies\n/// (e.g. the graphics system is initialized via such a function).\n\nTROOT::TROOT(const char *name, const char *title, VoidFuncPtr_t *initfunc)\n   : TDirectory(), fLineIsProcessing(0), fVersion(0), fVersionInt(0), fVersionCode(0),\n     fVersionDate(0), fVersionTime(0), fBuiltDate(0), fBuiltTime(0),\n     fTimer(0), fApplication(0), fInterpreter(0), fBatch(kTRUE),\n     fIsWebDisplay(kFALSE), fIsWebDisplayBatch(kFALSE), fEditHistograms(kTRUE),\n     fFromPopUp(kTRUE),fMustClean(kTRUE),fReadingObject(kFALSE),fForceStyle(kFALSE),\n     fInterrupt(kFALSE),fEscape(kFALSE),fExecutingMacro(kFALSE),fEditorMode(0),\n     fPrimitive(0),fSelectPad(0),fClasses(0),fTypes(0),fGlobals(0),fGlobalFunctions(0),\n     fClosedObjects(0),fFiles(0),fMappedFiles(0),fSockets(0),fCanvases(0),fStyles(0),fFunctions(0),\n     fTasks(0),fColors(0),fGeometries(0),fBrowsers(0),fSpecials(0),fCleanups(0),\n     fMessageHandlers(0),fStreamerInfo(0),fClassGenerators(0),fSecContexts(0),\n     fProofs(0),fClipboard(0),fDataSets(0),fUUIDs(0),fRootFolder(0),fBrowsables(0),\n     fPluginManager(0)\n{\n   if (fgRootInit || ROOT::Internal::gROOTLocal) {\n      //Warning(\"TROOT\", \"only one instance of TROOT allowed\");\n      return;\n   }\n\n   R__LOCKGUARD(gROOTMutex);\n\n   ROOT::Internal::gROOTLocal = this;\n   gDirectory = 0;\n\n   SetName(name);\n   SetTitle(title);\n\n   // will be used by global \"operator delete\" so make sure it is set\n   // before anything is deleted\n   fMappedFiles = 0;\n\n   // create already here, but only initialize it after gEnv has been created\n   gPluginMgr = fPluginManager = new TPluginManager;\n\n   // Initialize Operating System interface\n   InitSystem();\n\n   // Initialize static directory functions\n   GetRootSys();\n   GetBinDir();\n   GetLibDir();\n   GetIncludeDir();\n   GetEtcDir();\n   GetDataDir();\n   GetDocDir();\n   GetMacroDir();\n   GetTutorialDir();\n   GetSourceDir();\n   GetIconPath();\n   GetTTFFontDir();\n\n   gRootDir = GetRootSys().Data();\n\n   TDirectory::BuildDirectory(nullptr, nullptr);\n\n   // Initialize interface to CINT C++ interpreter\n   fVersionInt      = 0;  // check in TROOT dtor in case TCling fails\n   fClasses         = 0;  // might be checked via TCling ctor\n   fEnums           = 0;\n\n   fConfigOptions   = R__CONFIGUREOPTIONS;\n   fConfigFeatures  = R__CONFIGUREFEATURES;\n   fVersion         = ROOT_RELEASE;\n   fVersionCode     = ROOT_VERSION_CODE;\n   fVersionInt      = IVERSQ();\n   fVersionDate     = IDATQQ(ROOT_RELEASE_DATE);\n   fVersionTime     = ITIMQQ(ROOT_RELEASE_TIME);\n   fBuiltDate       = IDATQQ(__DATE__);\n   fBuiltTime       = ITIMQQ(__TIME__);\n\n   ReadGitInfo();\n\n   fClasses         = new THashTable(800,3); fClasses->UseRWLock();\n   //fIdMap           = new IdMap_t;\n   fStreamerInfo    = new TObjArray(100); fStreamerInfo->UseRWLock();\n   fClassGenerators = new TList;\n\n   // usedToIdentifyRootClingByDlSym is available when TROOT is part of\n   // rootcling.\n   if (!dlsym(RTLD_DEFAULT, \"usedToIdentifyRootClingByDlSym\")) {\n      // initialize plugin manager early\n      fPluginManager->LoadHandlersFromEnv(gEnv);\n   }\n\n   TSystemDirectory *workdir = new TSystemDirectory(\"workdir\", gSystem->WorkingDirectory());\n\n   auto setNameLocked = [](TSeqCollection *l, const char *collection_name) {\n      l->SetName(collection_name);\n      l->UseRWLock();\n      return l;\n   };\n\n   fTimer       = 0;\n   fApplication = 0;\n   fColors      = setNameLocked(new TObjArray(1000), \"ListOfColors\");\n   fTypes       = 0;\n   fGlobals     = 0;\n   fGlobalFunctions = 0;\n   // fList was created in TDirectory::Build but with different sizing.\n   delete fList;\n   fList        = new THashList(1000,3); fList->UseRWLock();\n   fClosedObjects = setNameLocked(new TList, \"ClosedFiles\");\n   fFiles       = setNameLocked(new TList, \"Files\");\n   fMappedFiles = setNameLocked(new TList, \"MappedFiles\");\n   fSockets     = setNameLocked(new TList, \"Sockets\");\n   fCanvases    = setNameLocked(new TList, \"Canvases\");\n   fStyles      = setNameLocked(new TList, \"Styles\");\n   fFunctions   = setNameLocked(new TList, \"Functions\");\n   fTasks       = setNameLocked(new TList, \"Tasks\");\n   fGeometries  = setNameLocked(new TList, \"Geometries\");\n   fBrowsers    = setNameLocked(new TList, \"Browsers\");\n   fSpecials    = setNameLocked(new TList, \"Specials\");\n   fBrowsables  = (TList*)setNameLocked(new TList, \"Browsables\");\n   fCleanups    = setNameLocked(new THashList, \"Cleanups\");\n   fMessageHandlers = setNameLocked(new TList, \"MessageHandlers\");\n   fSecContexts = setNameLocked(new TList, \"SecContexts\");\n   fProofs      = setNameLocked(new TList, \"Proofs\");\n   fClipboard   = setNameLocked(new TList, \"Clipboard\");\n   fDataSets    = setNameLocked(new TList, \"DataSets\");\n   fTypes       = new TListOfTypes; fTypes->UseRWLock();\n\n   TProcessID::AddProcessID();\n   fUUIDs = new TProcessUUID();\n\n   fRootFolder = new TFolder();\n   fRootFolder->SetName(\"root\");\n   fRootFolder->SetTitle(\"root of all folders\");\n   fRootFolder->AddFolder(\"Classes\",   \"List of Active Classes\",fClasses);\n   fRootFolder->AddFolder(\"Colors\",    \"List of Active Colors\",fColors);\n   fRootFolder->AddFolder(\"MapFiles\",  \"List of MapFiles\",fMappedFiles);\n   fRootFolder->AddFolder(\"Sockets\",   \"List of Socket Connections\",fSockets);\n   fRootFolder->AddFolder(\"Canvases\",  \"List of Canvases\",fCanvases);\n   fRootFolder->AddFolder(\"Styles\",    \"List of Styles\",fStyles);\n   fRootFolder->AddFolder(\"Functions\", \"List of Functions\",fFunctions);\n   fRootFolder->AddFolder(\"Tasks\",     \"List of Tasks\",fTasks);\n   fRootFolder->AddFolder(\"Geometries\",\"List of Geometries\",fGeometries);\n   fRootFolder->AddFolder(\"Browsers\",  \"List of Browsers\",fBrowsers);\n   fRootFolder->AddFolder(\"Specials\",  \"List of Special Objects\",fSpecials);\n   fRootFolder->AddFolder(\"Handlers\",  \"List of Message Handlers\",fMessageHandlers);\n   fRootFolder->AddFolder(\"Cleanups\",  \"List of RecursiveRemove Collections\",fCleanups);\n   fRootFolder->AddFolder(\"StreamerInfo\",\"List of Active StreamerInfo Classes\",fStreamerInfo);\n   fRootFolder->AddFolder(\"SecContexts\",\"List of Security Contexts\",fSecContexts);\n   fRootFolder->AddFolder(\"PROOF Sessions\", \"List of PROOF sessions\",fProofs);\n   fRootFolder->AddFolder(\"ROOT Memory\",\"List of Objects in the gROOT Directory\",fList);\n   fRootFolder->AddFolder(\"ROOT Files\",\"List of Connected ROOT Files\",fFiles);\n\n   // by default, add the list of files, tasks, canvases and browsers in the Cleanups list\n   fCleanups->Add(fCanvases); fCanvases->SetBit(kMustCleanup);\n   fCleanups->Add(fBrowsers); fBrowsers->SetBit(kMustCleanup);\n   fCleanups->Add(fTasks);    fTasks->SetBit(kMustCleanup);\n   fCleanups->Add(fFiles);    fFiles->SetBit(kMustCleanup);\n   fCleanups->Add(fClosedObjects); fClosedObjects->SetBit(kMustCleanup);\n   // And add TROOT's TDirectory personality\n   fCleanups->Add(fList);\n\n   fExecutingMacro= kFALSE;\n   fForceStyle    = kFALSE;\n   fFromPopUp     = kFALSE;\n   fReadingObject = kFALSE;\n   fInterrupt     = kFALSE;\n   fEscape        = kFALSE;\n   fMustClean     = kTRUE;\n   fPrimitive     = 0;\n   fSelectPad     = 0;\n   fEditorMode    = 0;\n   fDefCanvasName = \"c1\";\n   fEditHistograms= kFALSE;\n   fLineIsProcessing = 1;   // This prevents WIN32 \"Windows\" thread to pick ROOT objects with mouse\n   gDirectory     = this;\n   gPad           = 0;\n\n   //set name of graphical cut class for the graphics editor\n   //cannot call SetCutClassName at this point because the TClass of TCutG\n   //is not yet build\n   fCutClassName = \"TCutG\";\n\n   // Create a default MessageHandler\n   new TMessageHandler((TClass*)0);\n\n   // Create some styles\n   gStyle = 0;\n   TStyle::BuildStyles();\n   SetStyle(gEnv->GetValue(\"Canvas.Style\", \"Modern\"));\n\n   // Setup default (batch) graphics and GUI environment\n   gBatchGuiFactory = new TGuiFactory;\n   gGuiFactory      = gBatchGuiFactory;\n   gGXBatch         = new TVirtualX(\"Batch\", \"ROOT Interface to batch graphics\");\n   gVirtualX        = gGXBatch;\n\n#if defined(R__WIN32)\n   fBatch = kFALSE;\n#elif defined(R__HAS_COCOA)\n   fBatch = kFALSE;\n#else\n   if (gSystem->Getenv(\"DISPLAY\"))\n      fBatch = kFALSE;\n   else\n      fBatch = kTRUE;\n#endif\n\n   int i = 0;\n   while (initfunc && initfunc[i]) {\n      (initfunc[i])();\n      fBatch = kFALSE;  // put system in graphics mode (backward compatible)\n      i++;\n   }\n\n   // Set initial/default list of browsable objects\n   fBrowsables->Add(fRootFolder, \"root\");\n   fBrowsables->Add(fProofs, \"PROOF Sessions\");\n   fBrowsables->Add(workdir, gSystem->WorkingDirectory());\n   fBrowsables->Add(fFiles, \"ROOT Files\");\n\n   atexit(CleanUpROOTAtExit);\n\n   ROOT::Internal::gGetROOT = &ROOT::Internal::GetROOT2;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Clean up and free resources used by ROOT (files, network sockets,\n/// shared memory segments, etc.).\n\nTROOT::~TROOT()\n{\n   using namespace ROOT::Internal;\n\n   if (gROOTLocal == this) {\n\n      // If the interpreter has not yet been initialized, don't bother\n      gGetROOT = &GetROOT1;\n\n      // Mark the object as invalid, so that we can veto some actions\n      // (like autoloading) while we are in the destructor.\n      SetBit(TObject::kInvalidObject);\n\n      // Turn-off the global mutex to avoid recreating mutexes that have\n      // already been deleted during the destruction phase\n      gGlobalMutex = 0;\n\n      // Return when error occurred in TCling, i.e. when setup file(s) are\n      // out of date\n      if (!fVersionInt) return;\n\n      // ATTENTION!!! Order is important!\n\n      SafeDelete(fBrowsables);\n\n      // FIXME: Causes rootcling to deadlock, debug and uncomment\n      // SafeDelete(fRootFolder);\n\n#ifdef R__COMPLETE_MEM_TERMINATION\n      fSpecials->Delete();   SafeDelete(fSpecials);    // delete special objects : PostScript, Minuit, Html\n#endif\n\n      fClosedObjects->Delete(\"slow\"); // and closed files\n      fFiles->Delete(\"slow\");       // and files\n      SafeDelete(fFiles);\n      fSecContexts->Delete(\"slow\"); SafeDelete(fSecContexts); // and security contexts\n      fSockets->Delete();           SafeDelete(fSockets);     // and sockets\n      fMappedFiles->Delete(\"slow\");                     // and mapped files\n      TSeqCollection *tl = fMappedFiles; fMappedFiles = 0; delete tl;\n\n      SafeDelete(fClosedObjects);\n\n      delete fUUIDs;\n      TProcessID::Cleanup();                            // and list of ProcessIDs\n\n      fFunctions->Delete();  SafeDelete(fFunctions);   // etc..\n      fGeometries->Delete(); SafeDelete(fGeometries);\n      fBrowsers->Delete();   SafeDelete(fBrowsers);\n      SafeDelete(fCanvases);\n      fColors->Delete();     SafeDelete(fColors);\n      fStyles->Delete();     SafeDelete(fStyles);\n\n#ifdef R__COMPLETE_MEM_TERMINATION\n      if (gGuiFactory != gBatchGuiFactory) SafeDelete(gGuiFactory);\n      SafeDelete(gBatchGuiFactory);\n      if (gGXBatch != gVirtualX) SafeDelete(gGXBatch);\n      SafeDelete(gVirtualX);\n#endif\n\n      // Stop emitting signals\n      TQObject::BlockAllSignals(kTRUE);\n\n      fMessageHandlers->Delete(); SafeDelete(fMessageHandlers);\n\n#ifdef R__COMPLETE_MEM_TERMINATION\n      SafeDelete(fCanvases);\n      SafeDelete(fTasks);\n      SafeDelete(fProofs);\n      SafeDelete(fDataSets);\n      SafeDelete(fClipboard);\n\n      fCleanups->Clear();\n      delete fPluginManager; gPluginMgr = fPluginManager = 0;\n      delete gClassTable;  gClassTable = 0;\n      delete gEnv; gEnv = 0;\n\n      if (fTypes) fTypes->Delete();\n      SafeDelete(fTypes);\n      if (fGlobals) fGlobals->Delete();\n      SafeDelete(fGlobals);\n      if (fGlobalFunctions) fGlobalFunctions->Delete();\n      SafeDelete(fGlobalFunctions);\n      fEnums.load()->Delete();\n\n      // FIXME: Causes segfault in rootcling, debug and uncomment\n      // fClasses->Delete();    SafeDelete(fClasses);     // TClass'es must be deleted last\n#endif\n\n      // Remove shared libraries produced by the TSystem::CompileMacro() call\n      gSystem->CleanCompiledMacros();\n\n      // Cleanup system class\n      delete gSystem;\n\n      // ROOT-6022:\n      //   if (gInterpreterLib) dlclose(gInterpreterLib);\n#ifdef R__COMPLETE_MEM_TERMINATION\n      // On some 'newer' platform (Fedora Core 17+, Ubuntu 12), the\n      // initialization order is (by default?) is 'wrong' and so we can't\n      // delete the interpreter now .. because any of the static in the\n      // interpreter's library have already been deleted.\n      // On the link line, we must list the most dependent .o file\n      // and end with the least dependent (LLVM libraries), unfortunately,\n      // Fedora Core 17+ or Ubuntu 12 will also execute the initialization\n      // in the same order (hence doing libCore's before LLVM's and\n      // vice et versa for both the destructor.  We worked around the\n      // initialization order by delay the TROOT creation until first use.\n      // We can not do the same for destruction as we have no way of knowing\n      // the last access ...\n      // So for now, let's avoid delete TCling except in the special build\n      // checking the completeness of the termination deletion.\n\n      // TODO: Should we do more cleanup here than just call delete?\n      // Segfaults rootcling in some cases, debug and uncomment:\n      //\n      //    delete fInterpreter;\n\n      // We cannot delete fCleanups because of the logic in atexit which needs it.\n      SafeDelete(fCleanups);\n#endif\n\n#ifndef _MSC_VER\n      // deleting the interpreter makes things crash at exit in some cases\n      delete fInterpreter;\n#endif\n\n      // Prints memory stats\n      TStorage::PrintStatistics();\n\n      gROOTLocal = 0;\n      fgRootInit = kFALSE;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Add a class to the list and map of classes.\n/// This routine is deprecated, use TClass::AddClass directly.\n\nvoid TROOT::AddClass(TClass *cl)\n{\n   TClass::AddClass(cl);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Add a class generator.  This generator will be called by TClass::GetClass\n/// in case its does not find a loaded rootcint dictionary to request the\n/// creation of a TClass object.\n\nvoid TROOT::AddClassGenerator(TClassGenerator *generator)\n{\n   if (!generator) return;\n   fClassGenerators->Add(generator);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Append object to this directory.\n///\n/// If replace is true:\n///   remove any existing objects with the same same (if the name is not \"\")\n\nvoid TROOT::Append(TObject *obj, Bool_t replace /* = kFALSE */)\n{\n   R__LOCKGUARD(gROOTMutex);\n   TDirectory::Append(obj,replace);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Add browsable objects to TBrowser.\n\nvoid TROOT::Browse(TBrowser *b)\n{\n   TObject *obj;\n   TIter next(fBrowsables);\n\n   while ((obj = (TObject *) next())) {\n      const char *opt = next.GetOption();\n      if (opt && strlen(opt))\n         b->Add(obj, opt);\n      else\n         b->Add(obj, obj->GetName());\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// return class status bit kClassSaved for class cl\n/// This function is called by the SavePrimitive functions writing\n/// the C++ code for an object.\n\nBool_t TROOT::ClassSaved(TClass *cl)\n{\n   if (cl == 0) return kFALSE;\n   if (cl->TestBit(TClass::kClassSaved)) return kTRUE;\n   cl->SetBit(TClass::kClassSaved);\n   return kFALSE;\n}\n\nnamespace {\n   static void R__ListSlowClose(TList *files)\n   {\n      // Routine to close a list of files using the 'slow' techniques\n      // that also for the deletion ot update the list itself.\n\n      static TObject harmless;\n      TObjLink *cursor = files->FirstLink();\n      while (cursor) {\n         TDirectory *dir = static_cast<TDirectory*>( cursor->GetObject() );\n         if (dir) {\n            // In order for the iterator to stay valid, we must\n            // prevent the removal of the object (dir) from the list\n            // (which is done in TFile::Close).   We can also can not\n            // just move to the next iterator since the Close might\n            // also (indirectly) remove that file.\n            // So we SetObject to a harmless value, so that 'dir'\n            // is not seen as part of the list.\n            // We will later, remove all the object (see files->Clear()\n            cursor->SetObject(&harmless); // this must not be zero otherwise things go wrong.\n            // See related comment at the files->Clear(\"nodelete\");\n            dir->Close(\"nodelete\");\n            // Put it back\n            cursor->SetObject(dir);\n         }\n         cursor = cursor->Next();\n      };\n      // Now were done, clear the list but do not delete the objects as\n      // they have been moved to the list of closed objects and must be\n      // deleted from there in order to avoid a double delete from a\n      // use objects (on the interpreter stack).\n      files->Clear(\"nodelete\");\n   }\n\n   static void R__ListSlowDeleteContent(TList *files)\n   {\n      // Routine to delete the content of list of files using the 'slow' techniques\n\n      static TObject harmless;\n      TObjLink *cursor = files->FirstLink();\n      while (cursor) {\n         TDirectory *dir = dynamic_cast<TDirectory*>( cursor->GetObject() );\n         if (dir) {\n            // In order for the iterator to stay valid, we must\n            // prevent the removal of the object (dir) from the list\n            // (which is done in TFile::Close).   We can also can not\n            // just move to the next iterator since the Close might\n            // also (indirectly) remove that file.\n            // So we SetObject to a harmless value, so that 'dir'\n            // is not seen as part of the list.\n            // We will later, remove all the object (see files->Clear()\n            cursor->SetObject(&harmless); // this must not be zero otherwise things go wrong.\n            // See related comment at the files->Clear(\"nodelete\");\n            dir->GetList()->Delete(\"slow\");\n            // Put it back\n            cursor->SetObject(dir);\n         }\n         cursor = cursor->Next();\n      };\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Close any files and sockets that gROOT knows about.\n/// This can be used to insures that the files and sockets are closed before any library is unloaded!\n\nvoid TROOT::CloseFiles()\n{\n   if (fFiles && fFiles->First()) {\n      R__ListSlowClose(static_cast<TList*>(fFiles));\n   }\n   // and Close TROOT itself.\n   Close(\"slow\");\n   // Now sockets.\n   if (fSockets && fSockets->First()) {\n      if (0==fCleanups->FindObject(fSockets) ) {\n         fCleanups->Add(fSockets);\n         fSockets->SetBit(kMustCleanup);\n      }\n      CallFunc_t *socketCloser = gInterpreter->CallFunc_Factory();\n      Long_t offset = 0;\n      TClass *socketClass = TClass::GetClass(\"TSocket\");\n      gInterpreter->CallFunc_SetFuncProto(socketCloser, socketClass->GetClassInfo(), \"Close\", \"\", &offset);\n      if (gInterpreter->CallFunc_IsValid(socketCloser)) {\n         static TObject harmless;\n         TObjLink *cursor = static_cast<TList*>(fSockets)->FirstLink();\n         TList notclosed;\n         while (cursor) {\n            TObject *socket = cursor->GetObject();\n            // In order for the iterator to stay valid, we must\n            // prevent the removal of the object (dir) from the list\n            // (which is done in TFile::Close).   We can also can not\n            // just move to the next iterator since the Close might\n            // also (indirectly) remove that file.\n            // So we SetObject to a harmless value, so that 'dir'\n            // is not seen as part of the list.\n            // We will later, remove all the object (see files->Clear()\n            cursor->SetObject(&harmless); // this must not be zero otherwise things go wrong.\n\n            if (socket->IsA()->InheritsFrom(socketClass)) {\n               gInterpreter->CallFunc_Exec(socketCloser, ((char*)socket)+offset);\n               // Put the object in the closed list for later deletion.\n               socket->SetBit(kMustCleanup);\n               fClosedObjects->AddLast(socket);\n            } else {\n               // Crap ... this is not a socket, likely Proof or something, let's try to find a Close\n               Long_t other_offset;\n               CallFunc_t *otherCloser = gInterpreter->CallFunc_Factory();\n               gInterpreter->CallFunc_SetFuncProto(otherCloser, socket->IsA()->GetClassInfo(), \"Close\", \"\", &other_offset);\n               if (gInterpreter->CallFunc_IsValid(otherCloser)) {\n                  gInterpreter->CallFunc_Exec(otherCloser, ((char*)socket)+other_offset);\n                  // Put the object in the closed list for later deletion.\n                  socket->SetBit(kMustCleanup);\n                  fClosedObjects->AddLast(socket);\n               } else {\n                  notclosed.AddLast(socket);\n               }\n               gInterpreter->CallFunc_Delete(otherCloser);\n               // Put it back\n               cursor->SetObject(socket);\n            }\n            cursor = cursor->Next();\n         }\n         // Now were done, clear the list\n         fSockets->Clear();\n         // Read the one we did not close\n         cursor = notclosed.FirstLink();\n         while (cursor) {\n            static_cast<TList*>(fSockets)->AddLast(cursor->GetObject());\n            cursor = cursor->Next();\n         }\n      }\n      gInterpreter->CallFunc_Delete(socketCloser);\n   }\n   if (fMappedFiles && fMappedFiles->First()) {\n      R__ListSlowClose(static_cast<TList*>(fMappedFiles));\n   }\n\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Execute the cleanups necessary at the end of the process, in particular\n/// those that must be executed before the library start being unloaded.\n\nvoid TROOT::EndOfProcessCleanups()\n{\n   // This will not delete the objects 'held' by the TFiles so that\n   // they can still be 'reacheable' when ResetGlobals is run.\n   CloseFiles();\n\n   if (gInterpreter) {\n      gInterpreter->ResetGlobals();\n   }\n\n   // Now delete the objects 'held' by the TFiles so that it\n   // is done before the tear down of the libraries.\n   if (fClosedObjects && fClosedObjects->First()) {\n      R__ListSlowDeleteContent(static_cast<TList*>(fClosedObjects));\n   }\n\n   // Now a set of simpler things to delete.  See the same ordering in\n   // TROOT::~TROOT\n   fFunctions->Delete();\n   fGeometries->Delete();\n   fBrowsers->Delete();\n   fCanvases->Delete(\"slow\");\n   fColors->Delete();\n   fStyles->Delete();\n\n   TQObject::BlockAllSignals(kTRUE);\n\n   if (gInterpreter) {\n      gInterpreter->ShutDown();\n   }\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Find an object in one Root folder\n\nTObject *TROOT::FindObject(const TObject *) const\n{\n   Error(\"FindObject\",\"Not yet implemented\");\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Returns address of a ROOT object if it exists\n///\n/// If name contains at least one \"/\" the function calls FindObjectany\n/// else\n/// This function looks in the following order in the ROOT lists:\n///     - List of files\n///     - List of memory mapped files\n///     - List of functions\n///     - List of geometries\n///     - List of canvases\n///     - List of styles\n///     - List of specials\n///     - List of materials in current geometry\n///     - List of shapes in current geometry\n///     - List of matrices in current geometry\n///     - List of Nodes in current geometry\n///     - Current Directory in memory\n///     - Current Directory on file\n\nTObject *TROOT::FindObject(const char *name) const\n{\n   if (name && strstr(name,\"/\")) return FindObjectAny(name);\n\n   TObject *temp = 0;\n\n   temp   = fFiles->FindObject(name);       if (temp) return temp;\n   temp   = fMappedFiles->FindObject(name); if (temp) return temp;\n   {\n      R__LOCKGUARD(gROOTMutex);\n      temp   = fFunctions->FindObject(name);if (temp) return temp;\n   }\n   temp   = fGeometries->FindObject(name);  if (temp) return temp;\n   temp   = fCanvases->FindObject(name);    if (temp) return temp;\n   temp   = fStyles->FindObject(name);      if (temp) return temp;\n   {\n      R__LOCKGUARD(gROOTMutex);\n      temp = fSpecials->FindObject(name);   if (temp) return temp;\n   }\n   TIter next(fGeometries);\n   TObject *obj;\n   while ((obj=next())) {\n      temp = obj->FindObject(name);         if (temp) return temp;\n   }\n   if (gDirectory) temp = gDirectory->Get(name);\n   if (temp) return temp;\n   if (gPad) {\n      TVirtualPad *canvas = gPad->GetVirtCanvas();\n      if (fCanvases->FindObject(canvas)) {  //this check in case call from TCanvas ctor\n         temp = canvas->FindObject(name);\n         if (!temp && canvas != gPad) temp  = gPad->FindObject(name);\n      }\n   }\n   return temp;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Returns address and folder of a ROOT object if it exists\n///\n/// This function looks in the following order in the ROOT lists:\n///     - List of files\n///     - List of memory mapped files\n///     - List of functions\n///     - List of geometries\n///     - List of canvases\n///     - List of styles\n///     - List of specials\n///     - List of materials in current geometry\n///     - List of shapes in current geometry\n///     - List of matrices in current geometry\n///     - List of Nodes in current geometry\n///     - Current Directory in memory\n///     - Current Directory on file\n\nTObject *TROOT::FindSpecialObject(const char *name, void *&where)\n{\n   TObject *temp = 0;\n   where = 0;\n\n   if (!temp) {\n      temp  = fFiles->FindObject(name);\n      where = fFiles;\n   }\n   if (!temp) {\n      temp  = fMappedFiles->FindObject(name);\n      where = fMappedFiles;\n   }\n   if (!temp) {\n      R__LOCKGUARD(gROOTMutex);\n      temp  = fFunctions->FindObject(name);\n      where = fFunctions;\n   }\n   if (!temp) {\n      temp  = fCanvases->FindObject(name);\n      where = fCanvases;\n   }\n   if (!temp) {\n      temp  = fStyles->FindObject(name);\n      where = fStyles;\n   }\n   if (!temp) {\n      temp  = fSpecials->FindObject(name);\n      where = fSpecials;\n   }\n   if (!temp) {\n      TObject *glast = fGeometries->Last();\n      if (glast) {where = glast; temp = glast->FindObject(name);}\n   }\n   if (!temp && gDirectory) {\n      temp  = gDirectory->Get(name);\n      where = gDirectory;\n   }\n   if (!temp && gPad) {\n      TVirtualPad *canvas = gPad->GetVirtCanvas();\n      if (fCanvases->FindObject(canvas)) {  //this check in case call from TCanvas ctor\n         temp  = canvas->FindObject(name);\n         where = canvas;\n         if (!temp && canvas != gPad) {\n            temp  = gPad->FindObject(name);\n            where = gPad;\n         }\n      }\n   }\n   if (!temp) return 0;\n   if (temp->TestBit(kNotDeleted)) return temp;\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a pointer to the first object with name starting at //root.\n/// This function scans the list of all folders.\n/// if no object found in folders, it scans the memory list of all files.\n\nTObject *TROOT::FindObjectAny(const char *name) const\n{\n   TObject *obj = fRootFolder->FindObjectAny(name);\n   if (obj) return obj;\n   return gDirectory->FindObjectAnyFile(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Scan the memory lists of all files for an object with name\n\nTObject *TROOT::FindObjectAnyFile(const char *name) const\n{\n   R__LOCKGUARD(gROOTMutex);\n   TDirectory *d;\n   TIter next(GetListOfFiles());\n   while ((d = (TDirectory*)next())) {\n      // Call explicitly TDirectory::FindObject to restrict the search to the\n      // already in memory object.\n      TObject *obj = d->TDirectory::FindObject(name);\n      if (obj) return obj;\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Returns class name of a ROOT object including CINT globals.\n\nconst char *TROOT::FindObjectClassName(const char *name) const\n{\n   // Search first in the list of \"standard\" objects\n   TObject *obj = FindObject(name);\n   if (obj) return obj->ClassName();\n\n   // Is it a global variable?\n   TGlobal *g = GetGlobal(name);\n   if (g) return g->GetTypeName();\n\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return path name of obj somewhere in the //root/... path.\n/// The function returns the first occurence of the object in the list\n/// of folders. The returned string points to a static char array in TROOT.\n/// If this function is called in a loop or recursively, it is the\n/// user's responsibility to copy this string in their area.\n\nconst char *TROOT::FindObjectPathName(const TObject *) const\n{\n   Error(\"FindObjectPathName\",\"Not yet implemented\");\n   return \"??\";\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// return a TClass object corresponding to 'name' assuming it is an STL container.\n/// In particular we looking for possible alternative name (default template\n/// parameter, typedefs template arguments, typedefed name).\n\nTClass *TROOT::FindSTLClass(const char *name, Bool_t load, Bool_t silent) const\n{\n   // Example of inputs are\n   //   vector<int>  (*)\n   //   vector<Int_t>\n   //   vector<long long>\n   //   vector<Long_64_t> (*)\n   //   vector<int, allocator<int> >\n   //   vector<Int_t, allocator<int> >\n   //\n   //   One of the possibly expensive operation is the resolving of the typedef\n   //   which can provoke the parsing of the header files (and/or the loading\n   //   of clang pcms information).\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   // Remove std::, allocator, typedef, add Long64_t, etc. in just one call.\n   std::string normalized;\n   TClassEdit::GetNormalizedName(normalized, name);\n\n   TClass *cl = 0;\n   if (normalized != name) cl = TClass::GetClass(normalized.c_str(),load,silent);\n\n   if (load && cl==0) {\n      // Create an Emulated class for this container.\n      cl = gInterpreter->GenerateTClass(normalized.c_str(), kTRUE, silent);\n   }\n\n   return cl;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to class with name. Obsolete, use TClass::GetClass directly\n\nTClass *TROOT::GetClass(const char *name, Bool_t load, Bool_t silent) const\n{\n   return TClass::GetClass(name,load,silent);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to class from its name. Obsolete, use TClass::GetClass directly\n/// See TClass::GetClass\n\nTClass *TROOT::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t silent) const\n{\n   return TClass::GetClass(typeinfo,load,silent);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return address of color with index color.\n\nTColor *TROOT::GetColor(Int_t color) const\n{\n   TColor::InitializeColors();\n   TObjArray *lcolors = (TObjArray*) GetListOfColors();\n   if (!lcolors) return 0;\n   if (color < 0 || color >= lcolors->GetSize()) return 0;\n   TColor *col = (TColor*)lcolors->At(color);\n   if (col && col->GetNumber() == color) return col;\n   TIter   next(lcolors);\n   while ((col = (TColor *) next()))\n      if (col->GetNumber() == color) return col;\n\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a default canvas.\n\nTCanvas *TROOT::MakeDefCanvas() const\n{\n   return (TCanvas*)gROOT->ProcessLine(\"TCanvas::MakeDefCanvas();\");\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to type with name.\n\nTDataType *TROOT::GetType(const char *name, Bool_t /* load */) const\n{\n   return (TDataType*)gROOT->GetListOfTypes()->FindObject(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to file with name.\n\nTFile *TROOT::GetFile(const char *name) const\n{\n   R__LOCKGUARD(gROOTMutex);\n   return (TFile*)GetListOfFiles()->FindObject(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to style with name\n\nTStyle *TROOT::GetStyle(const char *name) const\n{\n   return (TStyle*)GetListOfStyles()->FindObject(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to function with name.\n\nTObject *TROOT::GetFunction(const char *name) const\n{\n   if (name == 0 || name[0] == 0) {\n      return 0;\n   }\n\n   {\n      R__LOCKGUARD(gROOTMutex);\n      TObject *f1 = fFunctions->FindObject(name);\n      if (f1) return f1;\n   }\n\n   gROOT->ProcessLine(\"TF1::InitStandardFunctions();\");\n\n   R__LOCKGUARD(gROOTMutex);\n   return fFunctions->FindObject(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTFunctionTemplate *TROOT::GetFunctionTemplate(const char *name)\n{\n   if (!gInterpreter) return 0;\n\n   if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(0);\n\n   return (TFunctionTemplate*)fFuncTemplate->FindObject(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to global variable by name. If load is true force\n/// reading of all currently defined globals from CINT (more expensive).\n\nTGlobal *TROOT::GetGlobal(const char *name, Bool_t load) const\n{\n   return (TGlobal *)gROOT->GetListOfGlobals(load)->FindObject(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to global variable with address addr.\n\nTGlobal *TROOT::GetGlobal(const TObject *addr, Bool_t /* load */) const\n{\n   if (addr == 0 || ((Long_t)addr) == -1) return 0;\n\n   TInterpreter::DeclId_t decl = gInterpreter->GetDataMemberAtAddr(addr);\n   if (decl) {\n      TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));\n      return (TGlobal*)globals->Get(decl);\n   }\n   // If we are actually looking for a global that is held by a global\n   // pointer (for example gRandom), we need to find a pointer with the\n   // correct value.\n   decl = gInterpreter->GetDataMemberWithValue(addr);\n   if (decl) {\n      TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));\n      return (TGlobal*)globals->Get(decl);\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Internal routine returning, and creating if necessary, the list\n/// of global function.\n\nTListOfFunctions *TROOT::GetGlobalFunctions()\n{\n   if (!fGlobalFunctions) fGlobalFunctions = new TListOfFunctions(0);\n   return fGlobalFunctions;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the collection of functions named \"name\".\n\nTCollection *TROOT::GetListOfFunctionOverloads(const char* name) const\n{\n   return ((TListOfFunctions*)fGlobalFunctions)->GetListForObject(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to global function by name.\n/// If params != 0 it will also resolve overloading other it returns the first\n/// name match.\n/// If params == 0 and load is true force reading of all currently defined\n/// global functions from Cling.\n/// The param string must be of the form: \"3189,\\\"aap\\\",1.3\".\n\nTFunction *TROOT::GetGlobalFunction(const char *function, const char *params,\n                                    Bool_t load)\n{\n   if (!params) {\n      R__LOCKGUARD(gROOTMutex);\n      return (TFunction *)GetListOfGlobalFunctions(load)->FindObject(function);\n   } else {\n      if (!fInterpreter)\n         Fatal(\"GetGlobalFunction\", \"fInterpreter not initialized\");\n\n      R__LOCKGUARD(gROOTMutex);\n      TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithValues(0,\n                                                                 function, params,\n                                                                 false);\n\n      if (!decl) return 0;\n\n      TFunction *f = GetGlobalFunctions()->Get(decl);\n      if (f) return f;\n\n      Error(\"GetGlobalFunction\",\n            \"\\nDid not find matching TFunction <%s> with \\\"%s\\\".\",\n            function,params);\n      return 0;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to global function by name. If proto != 0\n/// it will also resolve overloading. If load is true force reading\n/// of all currently defined global functions from CINT (more expensive).\n/// The proto string must be of the form: \"int, char*, float\".\n\nTFunction *TROOT::GetGlobalFunctionWithPrototype(const char *function,\n                                               const char *proto, Bool_t load)\n{\n   if (!proto) {\n      R__LOCKGUARD(gROOTMutex);\n      return (TFunction *)GetListOfGlobalFunctions(load)->FindObject(function);\n   } else {\n      if (!fInterpreter)\n         Fatal(\"GetGlobalFunctionWithPrototype\", \"fInterpreter not initialized\");\n\n      R__LOCKGUARD(gROOTMutex);\n      TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithPrototype(0,\n                                                                           function, proto);\n\n      if (!decl) return 0;\n\n      TFunction *f = GetGlobalFunctions()->Get(decl);\n      if (f) return f;\n\n      Error(\"GetGlobalFunctionWithPrototype\",\n            \"\\nDid not find matching TFunction <%s> with \\\"%s\\\".\",\n            function,proto);\n      return 0;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to Geometry with name\n\nTObject *TROOT::GetGeometry(const char *name) const\n{\n   return GetListOfGeometries()->FindObject(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTCollection *TROOT::GetListOfEnums(Bool_t load /* = kTRUE */)\n{\n   if(!fEnums.load()) {\n      R__LOCKGUARD(gROOTMutex);\n      // Test again just in case, another thread did the work while we were\n      // waiting.\n      if (!fEnums.load()) fEnums = new TListOfEnumsWithLock(0);\n   }\n   if (load) {\n      R__LOCKGUARD(gROOTMutex);\n      (*fEnums).Load(); // Refresh the list of enums.\n   }\n   return fEnums.load();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTCollection *TROOT::GetListOfFunctionTemplates()\n{\n   R__LOCKGUARD(gROOTMutex);\n   if(!fFuncTemplate) {\n      fFuncTemplate = new TListOfFunctionTemplates(0);\n   }\n   return fFuncTemplate;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return list containing the TGlobals currently defined.\n/// Since globals are created and deleted during execution of the\n/// program, we need to update the list of globals every time we\n/// execute this method. However, when calling this function in\n/// a (tight) loop where no interpreter symbols will be created\n/// you can set load=kFALSE (default).\n\nTCollection *TROOT::GetListOfGlobals(Bool_t load)\n{\n   if (!fGlobals) {\n      fGlobals = new TListOfDataMembers(0);\n      // We add to the list the \"funcky-fake\" globals.\n\n      // provide special functor for gROOT, while ROOT::GetROOT() does not return reference\n      TGlobalMappedFunction::MakeFunctor(\"gROOT\", \"TROOT*\", ROOT::GetROOT, [] {\n         ROOT::GetROOT();\n         return (void *)&ROOT::Internal::gROOTLocal;\n      });\n\n      TGlobalMappedFunction::MakeFunctor(\"gPad\", \"TVirtualPad*\", TVirtualPad::Pad);\n      TGlobalMappedFunction::MakeFunctor(\"gVirtualX\", \"TVirtualX*\", TVirtualX::Instance);\n      TGlobalMappedFunction::MakeFunctor(\"gDirectory\", \"TDirectory*\", TDirectory::CurrentDirectory);\n\n      // Don't let TGlobalMappedFunction delete our globals, now that we take them.\n      fGlobals->AddAll(&TGlobalMappedFunction::GetEarlyRegisteredGlobals());\n      TGlobalMappedFunction::GetEarlyRegisteredGlobals().SetOwner(kFALSE);\n      TGlobalMappedFunction::GetEarlyRegisteredGlobals().Clear();\n   }\n\n   if (!fInterpreter)\n      Fatal(\"GetListOfGlobals\", \"fInterpreter not initialized\");\n\n   if (load) fGlobals->Load();\n\n   return fGlobals;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return list containing the TFunctions currently defined.\n/// Since functions are created and deleted during execution of the\n/// program, we need to update the list of functions every time we\n/// execute this method. However, when calling this function in\n/// a (tight) loop where no interpreter symbols will be created\n/// you can set load=kFALSE (default).\n\nTCollection *TROOT::GetListOfGlobalFunctions(Bool_t load)\n{\n   R__LOCKGUARD(gROOTMutex);\n\n   if (!fGlobalFunctions) {\n      fGlobalFunctions = new TListOfFunctions(0);\n   }\n\n   if (!fInterpreter)\n      Fatal(\"GetListOfGlobalFunctions\", \"fInterpreter not initialized\");\n\n   // A thread that calls with load==true and a thread that calls with load==false\n   // will conflict here (the load==true will be updating the list while the\n   // other is reading it).  To solve the problem, we could use a read-write lock\n   // inside the list itself.\n   if (load) fGlobalFunctions->Load();\n\n   return fGlobalFunctions;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a dynamic list giving access to all TDataTypes (typedefs)\n/// currently defined.\n///\n/// The list is populated on demand.  Calling\n/// ~~~ {.cpp}\n///    gROOT->GetListOfTypes()->FindObject(nameoftype);\n/// ~~~\n/// will return the TDataType corresponding to 'nameoftype'.  If the\n/// TDataType is not already in the list itself and the type does exist,\n/// a new TDataType will be created and added to the list.\n///\n/// Calling\n/// ~~~ {.cpp}\n///    gROOT->GetListOfTypes()->ls(); // or Print()\n/// ~~~\n/// list only the typedefs that have been previously accessed through the\n/// list (plus the builtins types).\n\nTCollection *TROOT::GetListOfTypes(Bool_t /* load */)\n{\n   if (!fInterpreter)\n      Fatal(\"GetListOfTypes\", \"fInterpreter not initialized\");\n\n   return fTypes;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Execute command when system has been idle for idleTimeInSec seconds.\n\nvoid TROOT::Idle(UInt_t idleTimeInSec, const char *command)\n{\n   if (!fApplication.load())\n      TApplication::CreateApplication();\n\n   if (idleTimeInSec <= 0)\n      (*fApplication).RemoveIdleTimer();\n   else\n      (*fApplication).SetIdleTimer(idleTimeInSec, command);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Check whether className is a known class, and only autoload\n/// if we can. Helper function for TROOT::IgnoreInclude().\n\nstatic TClass* R__GetClassIfKnown(const char* className)\n{\n   // Check whether the class is available for auto-loading first:\n   const char* libsToLoad = gInterpreter->GetClassSharedLibs(className);\n   TClass* cla = 0;\n   if (libsToLoad) {\n      // trigger autoload, and only create TClass in this case.\n      return TClass::GetClass(className);\n   } else if (gROOT->GetListOfClasses()\n              && (cla = (TClass*)gROOT->GetListOfClasses()->FindObject(className))) {\n      // cla assigned in if statement\n   } else if (gClassTable->FindObject(className)) {\n      return TClass::GetClass(className);\n   }\n   return cla;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return 1 if the name of the given include file corresponds to a class that\n///  is known to ROOT, e.g. \"TLorentzVector.h\" versus TLorentzVector.\n\nInt_t TROOT::IgnoreInclude(const char *fname, const char * /*expandedfname*/)\n{\n   if (fname == 0) return 0;\n\n   TString stem(fname);\n   // Remove extension if any, ignore files with extension not being .h*\n   Int_t where = stem.Last('.');\n   if (where != kNPOS) {\n      if (stem.EndsWith(\".so\") || stem.EndsWith(\".sl\") ||\n          stem.EndsWith(\".dl\") || stem.EndsWith(\".a\")  ||\n          stem.EndsWith(\".dll\", TString::kIgnoreCase))\n         return 0;\n      stem.Remove(where);\n   }\n\n   TString className = gSystem->BaseName(stem);\n   TClass* cla = R__GetClassIfKnown(className);\n   if (!cla) {\n      // Try again with modifications to the file name:\n      className = stem;\n      className.ReplaceAll(\"/\", \"::\");\n      className.ReplaceAll(\"\\\\\", \"::\");\n      if (className.Contains(\":::\")) {\n         // \"C:\\dir\" becomes \"C:::dir\".\n         // fname corresponds to whatever is stated after #include and\n         // a full path name usually means that it's not a regular #include\n         // but e.g. a \".L\", so we can assume that this is not a header of\n         // a class in a namespace (a global-namespace class would have been\n         // detected already before).\n         return 0;\n      }\n      cla = R__GetClassIfKnown(className);\n   }\n\n   if (!cla) {\n      return 0;\n   }\n\n   // cla is valid, check wether it's actually in the header of the same name:\n   if (cla->GetDeclFileLine() <= 0) return 0; // to a void an error with VisualC++\n   TString decfile = gSystem->BaseName(cla->GetDeclFileName());\n   if (decfile != gSystem->BaseName(fname)) {\n      return 0;\n   }\n   return 1;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Initialize operating system interface.\n\nvoid TROOT::InitSystem()\n{\n   if (gSystem == 0) {\n#if defined(R__UNIX)\n#if defined(R__HAS_COCOA)\n      gSystem = new TMacOSXSystem;\n#else\n      gSystem = new TUnixSystem;\n#endif\n#elif defined(R__WIN32)\n      gSystem = new TWinNTSystem;\n#else\n      gSystem = new TSystem;\n#endif\n\n      if (gSystem->Init())\n         fprintf(stderr, \"Fatal in <TROOT::InitSystem>: can't init operating system layer\\n\");\n\n      if (!gSystem->HomeDirectory()) {\n         fprintf(stderr, \"Fatal in <TROOT::InitSystem>: HOME directory not set\\n\");\n         fprintf(stderr, \"Fix this by defining the HOME shell variable\\n\");\n      }\n\n      // read default files\n      gEnv = new TEnv(\".rootrc\");\n\n      gDebug = gEnv->GetValue(\"Root.Debug\", 0);\n\n      if (!gEnv->GetValue(\"Root.ErrorHandlers\", 1))\n         gSystem->ResetSignals();\n\n      // The old \"Root.ZipMode\" had a discrepancy between documentation vs actual meaning.\n      // Also, a value with the meaning \"default\" wasn't available. To solved this,\n      // \"Root.ZipMode\" was replaced by \"Root.CompressionAlgorithm\". Warn about usage of\n      // the old value, if it's set to 0, but silently translate the setting to\n      // \"Root.CompressionAlgorithm\" for values > 1.\n      Int_t oldzipmode = gEnv->GetValue(\"Root.ZipMode\", -1);\n      if (oldzipmode == 0) {\n         fprintf(stderr, \"Warning in <TROOT::InitSystem>: ignoring old rootrc entry \\\"Root.ZipMode = 0\\\"!\\n\");\n      } else {\n         if (oldzipmode == -1 || oldzipmode == 1) {\n            // Not set or default value, use \"default\" for \"Root.CompressionAlgorithm\":\n            oldzipmode = 0;\n         }\n         // else keep the old zipmode (e.g. \"3\") as \"Root.CompressionAlgorithm\"\n         // if \"Root.CompressionAlgorithm\" isn't set; see below.\n      }\n\n      Int_t zipmode = gEnv->GetValue(\"Root.CompressionAlgorithm\", oldzipmode);\n      if (zipmode != 0) R__SetZipMode(zipmode);\n\n      const char *sdeb;\n      if ((sdeb = gSystem->Getenv(\"ROOTDEBUG\")))\n         gDebug = atoi(sdeb);\n\n      if (gDebug > 0 && isatty(2))\n         fprintf(stderr, \"Info in <TROOT::InitSystem>: running with gDebug = %d\\n\", gDebug);\n\n      if (gEnv->GetValue(\"Root.MemStat\", 0))\n         TStorage::EnableStatistics();\n      int msize = gEnv->GetValue(\"Root.MemStat.size\", -1);\n      int mcnt  = gEnv->GetValue(\"Root.MemStat.cnt\", -1);\n      if (msize != -1 || mcnt != -1)\n         TStorage::EnableStatistics(msize, mcnt);\n\n      fgMemCheck = gEnv->GetValue(\"Root.MemCheck\", 0);\n\n#if defined(R__HAS_COCOA)\n      // create and delete a dummy TUrl so that TObjectStat table does not contain\n      // objects that are deleted after recording is turned-off (in next line),\n      // like the TUrl::fgSpecialProtocols list entries which are created in the\n      // TMacOSXSystem ctor.\n      { TUrl dummy(\"/dummy\"); }\n#endif\n      TObject::SetObjectStat(gEnv->GetValue(\"Root.ObjectStat\", 0));\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Load and initialize thread library.\n\nvoid TROOT::InitThreads()\n{\n   if (gEnv->GetValue(\"Root.UseThreads\", 0) || gEnv->GetValue(\"Root.EnableThreadSafety\", 0)) {\n      ROOT::EnableThreadSafety();\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Initialize the interpreter. Should be called only after main(),\n/// to make sure LLVM/Clang is fully initialized.\n\nvoid TROOT::InitInterpreter()\n{\n   // usedToIdentifyRootClingByDlSym is available when TROOT is part of\n   // rootcling.\n   if (!dlsym(RTLD_DEFAULT, \"usedToIdentifyRootClingByDlSym\")\n       && !dlsym(RTLD_DEFAULT, \"usedToIdentifyStaticRoot\")) {\n      // Make sure no llvm symbols are visible before loading libCling. If they\n      // exist libCling will use those and not ours, causing havoc in the\n      // interpreter. Look for an extern \"C\" symbol to avoid mangling; look for a\n      // symbol from llvm because clang builds on top, so users would likely\n      // have also their own llvm symbols when providing their own clang.\n      void *LLVMEnablePrettyStackTraceAddr = 0;\n      // Can't use gSystem->DynFindSymbol() because that iterates over all *known*\n      // libraries which is not the same!\n      LLVMEnablePrettyStackTraceAddr = dlsym(RTLD_DEFAULT, \"LLVMEnablePrettyStackTrace\");\n      // FIXME: When we configure with -Dclingtest=On we intentionally export the symbols. Silence this error.\n      if (LLVMEnablePrettyStackTraceAddr) {\n         Error(\"InitInterpreter()\", \"LLVM SYMBOLS ARE EXPOSED TO CLING! \"\n               \"This will cause problems; please hide them or dlopen() them \"\n               \"after the call to TROOT::InitInterpreter()!\");\n      }\n\n      char *libRIO = gSystem->DynamicPathName(\"libRIO\");\n      void *libRIOHandle = dlopen(libRIO, RTLD_NOW|RTLD_GLOBAL);\n      delete [] libRIO;\n      if (!libRIOHandle) {\n         TString err = dlerror();\n         fprintf(stderr, \"Fatal in <TROOT::InitInterpreter>: cannot load library %s\\n\", err.Data());\n         exit(1);\n      }\n\n      char *libcling = gSystem->DynamicPathName(\"libCling\");\n      gInterpreterLib = dlopen(libcling, RTLD_LAZY|RTLD_LOCAL);\n      delete [] libcling;\n\n      if (!gInterpreterLib) {\n         TString err = dlerror();\n         fprintf(stderr, \"Fatal in <TROOT::InitInterpreter>: cannot load library %s\\n\", err.Data());\n         exit(1);\n      }\n      dlerror();   // reset error message\n   } else {\n      gInterpreterLib = RTLD_DEFAULT;\n   }\n   CreateInterpreter_t *CreateInterpreter = (CreateInterpreter_t*) dlsym(gInterpreterLib, \"CreateInterpreter\");\n   if (!CreateInterpreter) {\n      TString err = dlerror();\n      fprintf(stderr, \"Fatal in <TROOT::InitInterpreter>: cannot load symbol %s\\n\", err.Data());\n      exit(1);\n   }\n   // Schedule the destruction of TROOT.\n   atexit(at_exit_of_TROOT);\n\n   gDestroyInterpreter = (DestroyInterpreter_t*) dlsym(gInterpreterLib, \"DestroyInterpreter\");\n   if (!gDestroyInterpreter) {\n      TString err = dlerror();\n      fprintf(stderr, \"Fatal in <TROOT::InitInterpreter>: cannot load symbol %s\\n\", err.Data());\n      exit(1);\n   }\n\n   const char *interpArgs[] = {\n#ifdef NDEBUG\n      \"-DNDEBUG\",\n#else\n      \"-UNDEBUG\",\n#endif\n#ifdef DEBUG\n      \"-DDEBUG\",\n#else\n      \"-UDEBUG\",\n#endif\n#ifdef _DEBUG\n      \"-D_DEBUG\",\n#else\n      \"-U_DEBUG\",\n#endif\n      nullptr};\n\n   fInterpreter = CreateInterpreter(gInterpreterLib, interpArgs);\n\n   fCleanups->Add(fInterpreter);\n   fInterpreter->SetBit(kMustCleanup);\n\n   fgRootInit = kTRUE;\n\n   // initialize gClassTable is not already done\n   if (!gClassTable)\n      new TClassTable;\n\n   // Initialize all registered dictionaries.\n   for (std::vector<ModuleHeaderInfo_t>::const_iterator\n           li = GetModuleHeaderInfoBuffer().begin(),\n           le = GetModuleHeaderInfoBuffer().end(); li != le; ++li) {\n         // process buffered module registrations\n      fInterpreter->RegisterModule(li->fModuleName,\n                                   li->fHeaders,\n                                   li->fIncludePaths,\n                                   li->fPayloadCode,\n                                   li->fFwdDeclCode,\n                                   li->fTriggerFunc,\n                                   li->fFwdNargsToKeepColl,\n                                   li->fClassesHeaders,\n                                   kTRUE /*lateRegistration*/,\n                                   li->fHasCxxModule);\n   }\n   GetModuleHeaderInfoBuffer().clear();\n\n   fInterpreter->Initialize();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Helper function used by TClass::GetClass().\n/// This function attempts to load the dictionary for 'classname'\n/// either from the TClassTable or from the list of generator.\n/// If silent is 'true', do not warn about missing dictionary for the class.\n/// (typically used for class that are used only for transient members)\n///\n/// The 'requestedname' is expected to be already normalized.\n\nTClass *TROOT::LoadClass(const char *requestedname, Bool_t silent) const\n{\n   return TClass::LoadClass(requestedname, silent);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Check if class \"classname\" is known to the interpreter (in fact,\n/// this check is not needed anymore, so classname is ignored). If\n/// not it will load library \"libname\". If the library couldn't be found with original\n/// libname and if the name was not prefixed with lib, try to prefix with \"lib\" and search again.\n/// If DynamicPathName still couldn't find the library, return -1.\n/// If check is true it will only check if libname exists and is\n/// readable.\n/// Returns 0 on successful loading, -1 in case libname does not\n/// exist or in case of error and -2 in case of version mismatch.\n\nInt_t TROOT::LoadClass(const char * /*classname*/, const char *libname,\n                       Bool_t check)\n{\n   TString lib(libname);\n\n   // Check if libname exists in path or not\n   if (char *path = gSystem->DynamicPathName(lib, kTRUE)) {\n      // If check == true, only check if it exists and if it's readable\n      if (check) {\n         delete [] path;\n         return 0;\n      }\n\n      // If check == false, try to load the library\n      else {\n         int err = gSystem->Load(path, 0, kTRUE);\n         delete [] path;\n\n         // TSystem::Load returns 1 when the library was already loaded, return success in this case.\n         if (err == 1)\n            err = 0;\n         return err;\n      }\n   } else {\n      // This is the branch where libname didn't exist\n      if (check) {\n         FileStat_t stat;\n         if (!gSystem->GetPathInfo(libname, stat) && (R_ISREG(stat.fMode) &&\n             !gSystem->AccessPathName(libname, kReadPermission)))\n            return 0;\n      }\n\n      // Take care of user who didn't write the whole name\n      if (!lib.BeginsWith(\"lib\")) {\n         lib = \"lib\" + lib;\n         return LoadClass(\"\", lib.Data(), check);\n      }\n   }\n\n   // Execution reaches here when library was prefixed with lib, check is false and couldn't find\n   // the library name.\n   return -1;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return true if the file is local and is (likely) to be a ROOT file\n\nBool_t TROOT::IsRootFile(const char *filename) const\n{\n   Bool_t result = kFALSE;\n   FILE *mayberootfile = fopen(filename,\"rb\");\n   if (mayberootfile) {\n      char header[5];\n      if (fgets(header,5,mayberootfile)) {\n         result = strncmp(header,\"root\",4)==0;\n      }\n      fclose(mayberootfile);\n   }\n   return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// To list all objects of the application.\n/// Loop on all objects created in the ROOT linked lists.\n/// Objects may be files and windows or any other object directly\n/// attached to the ROOT linked list.\n\nvoid TROOT::ls(Option_t *option) const\n{\n//   TObject::SetDirLevel();\n//   GetList()->R__FOR_EACH(TObject,ls)(option);\n   TDirectory::ls(option);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Load a macro in the interpreter's memory. Equivalent to the command line\n/// command \".L filename\". If the filename has \"+\" or \"++\" appended\n/// the macro will be compiled by ACLiC. The filename must have the format:\n/// [path/]macro.C[+|++[g|O]].\n/// The possible error codes are defined by TInterpreter::EErrorCode.\n/// If check is true it will only check if filename exists and is\n/// readable.\n/// Returns 0 on successful loading and -1 in case filename does not\n/// exist or in case of error.\n\nInt_t TROOT::LoadMacro(const char *filename, int *error, Bool_t check)\n{\n   Int_t err = -1;\n   Int_t lerr, *terr;\n   if (error)\n      terr = error;\n   else\n      terr = &lerr;\n\n   if (fInterpreter) {\n      TString aclicMode;\n      TString arguments;\n      TString io;\n      TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);\n\n      if (arguments.Length()) {\n         Warning(\"LoadMacro\", \"argument(%s) ignored in %s\", arguments.Data(), GetMacroPath());\n      }\n      char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);\n      if (!mac) {\n         if (!check)\n            Error(\"LoadMacro\", \"macro %s not found in path %s\", fname.Data(), GetMacroPath());\n         *terr = TInterpreter::kFatal;\n      } else {\n         err = 0;\n         if (!check) {\n            fname = mac;\n            fname += aclicMode;\n            fname += io;\n            gInterpreter->LoadMacro(fname.Data(), (TInterpreter::EErrorCode*)terr);\n            if (*terr)\n               err = -1;\n         }\n      }\n      delete [] mac;\n   }\n   return err;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Execute a macro in the interpreter. Equivalent to the command line\n/// command \".x filename\". If the filename has \"+\" or \"++\" appended\n/// the macro will be compiled by ACLiC. The filename must have the format:\n/// [path/]macro.C[+|++[g|O]][(args)].\n/// The possible error codes are defined by TInterpreter::EErrorCode.\n/// If padUpdate is true (default) update the current pad.\n/// Returns the macro return value.\n\nLong_t TROOT::Macro(const char *filename, Int_t *error, Bool_t padUpdate)\n{\n   Long_t result = 0;\n\n   if (fInterpreter) {\n      TString aclicMode;\n      TString arguments;\n      TString io;\n      TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);\n\n      char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);\n      if (!mac) {\n         Error(\"Macro\", \"macro %s not found in path %s\", fname.Data(), GetMacroPath());\n         if (error)\n            *error = TInterpreter::kFatal;\n      } else {\n         fname = mac;\n         fname += aclicMode;\n         fname += arguments;\n         fname += io;\n         result = gInterpreter->ExecuteMacro(fname, (TInterpreter::EErrorCode*)error);\n      }\n      delete [] mac;\n\n      if (padUpdate && gPad)\n         gPad->Update();\n   }\n\n   return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Process message id called by obj.\n\nvoid  TROOT::Message(Int_t id, const TObject *obj)\n{\n   TIter next(fMessageHandlers);\n   TMessageHandler *mh;\n   while ((mh = (TMessageHandler*)next())) {\n      mh->HandleMessage(id,obj);\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Process interpreter command via TApplication::ProcessLine().\n/// On Win32 the line will be processed asynchronously by sending\n/// it to the CINT interpreter thread. For explicit synchronous processing\n/// use ProcessLineSync(). On non-Win32 platforms there is no difference\n/// between ProcessLine() and ProcessLineSync().\n/// The possible error codes are defined by TInterpreter::EErrorCode. In\n/// particular, error will equal to TInterpreter::kProcessing until the\n/// CINT interpreted thread has finished executing the line.\n/// Returns the result of the command, cast to a Long_t.\n\nLong_t TROOT::ProcessLine(const char *line, Int_t *error)\n{\n   TString sline = line;\n   sline = sline.Strip(TString::kBoth);\n\n   if (!fApplication.load())\n      TApplication::CreateApplication();\n\n   return (*fApplication).ProcessLine(sline, kFALSE, error);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Process interpreter command via TApplication::ProcessLine().\n/// On Win32 the line will be processed synchronously (i.e. it will\n/// only return when the CINT interpreter thread has finished executing\n/// the line). On non-Win32 platforms there is no difference between\n/// ProcessLine() and ProcessLineSync().\n/// The possible error codes are defined by TInterpreter::EErrorCode.\n/// Returns the result of the command, cast to a Long_t.\n\nLong_t TROOT::ProcessLineSync(const char *line, Int_t *error)\n{\n   TString sline = line;\n   sline = sline.Strip(TString::kBoth);\n\n   if (!fApplication.load())\n      TApplication::CreateApplication();\n\n   return (*fApplication).ProcessLine(sline, kTRUE, error);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Process interpreter command directly via CINT interpreter.\n/// Only executable statements are allowed (no variable declarations),\n/// In all other cases use TROOT::ProcessLine().\n/// The possible error codes are defined by TInterpreter::EErrorCode.\n\nLong_t TROOT::ProcessLineFast(const char *line, Int_t *error)\n{\n   TString sline = line;\n   sline = sline.Strip(TString::kBoth);\n\n   if (!fApplication.load())\n      TApplication::CreateApplication();\n\n   Long_t result = 0;\n\n   if (fInterpreter) {\n      TInterpreter::EErrorCode *code = (TInterpreter::EErrorCode*)error;\n      result = gInterpreter->Calc(sline, code);\n   }\n\n   return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Read Git commit information and branch name from the\n/// etc/gitinfo.txt file.\n\nvoid TROOT::ReadGitInfo()\n{\n#ifdef ROOT_GIT_COMMIT\n   fGitCommit = ROOT_GIT_COMMIT;\n#endif\n#ifdef ROOT_GIT_BRANCH\n   fGitBranch = ROOT_GIT_BRANCH;\n#endif\n\n   TString gitinfo = \"gitinfo.txt\";\n   char *filename = gSystem->ConcatFileName(TROOT::GetEtcDir(), gitinfo);\n\n   FILE *fp = fopen(filename, \"r\");\n   if (fp) {\n      TString s;\n      // read branch name\n      s.Gets(fp);\n      fGitBranch = s;\n      // read commit SHA1\n      s.Gets(fp);\n      fGitCommit = s;\n      // read date/time make was run\n      s.Gets(fp);\n      fGitDate = s;\n      fclose(fp);\n   }\n   delete [] filename;\n}\n\nBool_t &GetReadingObject() {\n   TTHREAD_TLS(Bool_t) fgReadingObject = false;\n   return fgReadingObject;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Deprecated (will be removed in next release).\n\nBool_t TROOT::ReadingObject() const\n{\n   return GetReadingObject();\n}\n\nvoid TROOT::SetReadingObject(Bool_t flag)\n{\n   GetReadingObject() = flag;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return date/time make was run.\n\nconst char *TROOT::GetGitDate()\n{\n   if (fGitDate == \"\") {\n      Int_t iday,imonth,iyear, ihour, imin;\n      static const char *months[] = { \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                                      \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" };\n      Int_t idate = gROOT->GetBuiltDate();\n      Int_t itime = gROOT->GetBuiltTime();\n      iday   = idate%100;\n      imonth = (idate/100)%100;\n      iyear  = idate/10000;\n      ihour  = itime/100;\n      imin   = itime%100;\n      fGitDate.Form(\"%s %02d %4d, %02d:%02d:00\", months[imonth-1], iday, iyear, ihour, imin);\n   }\n   return fGitDate;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Recursively remove this object from the list of Cleanups.\n/// Typically RecursiveRemove is implemented by classes that can contain\n/// mulitple references to a same object or shared ownership of the object\n/// with others.\n\nvoid TROOT::RecursiveRemove(TObject *obj)\n{\n   R__READ_LOCKGUARD(ROOT::gCoreMutex);\n\n   fCleanups->RecursiveRemove(obj);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Refresh all browsers. Call this method when some command line\n/// command or script has changed the browser contents. Not needed\n/// for objects that have the kMustCleanup bit set. Most useful to\n/// update browsers that show the file system or other objects external\n/// to the running ROOT session.\n\nvoid TROOT::RefreshBrowsers()\n{\n   TIter next(GetListOfBrowsers());\n   TBrowser *b;\n   while ((b = (TBrowser*) next()))\n      b->SetRefreshFlag(kTRUE);\n}\n////////////////////////////////////////////////////////////////////////////////\n/// Insure that the files, canvases and sockets are closed.\n\nstatic void CallCloseFiles()\n{\n   if (TROOT::Initialized() && ROOT::Internal::gROOTLocal) {\n      gROOT->CloseFiles();\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Called by static dictionary initialization to register clang modules\n/// for headers. Calls TCling::RegisterModule() unless gCling\n/// is NULL, i.e. during startup, where the information is buffered in\n/// the static GetModuleHeaderInfoBuffer().\n\nvoid TROOT::RegisterModule(const char* modulename,\n                           const char** headers,\n                           const char** includePaths,\n                           const char* payloadCode,\n                           const char* fwdDeclCode,\n                           void (*triggerFunc)(),\n                           const TInterpreter::FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,\n                           const char** classesHeaders,\n                           bool hasCxxModule)\n{\n\n   // First a side track to insure proper end of process behavior.\n\n   // Register for each loaded dictionary (and thus for each library),\n   // that we need to Close the ROOT files as soon as this library\n   // might start being unloaded after main.\n   //\n   // By calling atexit here (rather than directly from within the\n   // library) we make sure that this is not called if the library is\n   // 'only' dlclosed.\n\n   // On Ubuntu the linker strips the unused libraries.  Eventhough\n   // stressHistogram is explicitly linked against libNet, it is not\n   // retained and thus is loaded only as needed in the middle part of\n   // the execution.  Concretely this also means that it is loaded\n   // *after* the construction of the TApplication object and thus\n   // after the registration (atexit) of the EndOfProcessCleanups\n   // routine.  Consequently, after the end of main, libNet is\n   // unloaded before EndOfProcessCleanups is called.  When\n   // EndOfProcessCleanups is executed it indirectly needs the TClass\n   // for TSocket and its search will use resources that have already\n   // been unloaded (technically the function static in TUnixSystem's\n   // DynamicPath and the dictionary from libNet).\n\n   // Similarly, the ordering (before this commit) was broken in the\n   // following case:\n\n   //    TApplication creation (EndOfProcessCleanups registration)\n   //    load UserLibrary\n   //    create TFile\n   //    Append UserObject to TFile\n\n   // and after the end of main the order of execution was\n\n   //    unload UserLibrary\n   //    call EndOfProcessCleanups\n   //       Write the TFile\n   //         attempt to write the user object.\n   //    ....\n\n   // where what we need is to have the files closen/written before\n   // the unloading of the library.\n\n   // To solve the problem we now register an atexit function for\n   // every dictionary thus making sure there is at least one executed\n   // before the first library tear down after main.\n\n   // If atexit is called directly within a library's code, the\n   // function will called *either* when the library is 'dlclose'd or\n   // after then end of main (whichever comes first).  We do *not*\n   // want the files to be closed whenever a library is unloaded via\n   // dlclose.  To avoid this, we add the function (CallCloseFiles)\n   // from the dictionary indirectly (via ROOT::RegisterModule).  In\n   // this case the function will only only be called either when\n   // libCore is 'dlclose'd or right after the end of main.\n\n   atexit(CallCloseFiles);\n\n   // Now register with TCling.\n   if (TROOT::Initialized()) {\n      gCling->RegisterModule(modulename, headers, includePaths, payloadCode, fwdDeclCode, triggerFunc,\n                             fwdDeclsArgToSkip, classesHeaders, false, hasCxxModule);\n   } else {\n      GetModuleHeaderInfoBuffer().push_back(ModuleHeaderInfo_t(modulename, headers, includePaths, payloadCode,\n                                                               fwdDeclCode, triggerFunc, fwdDeclsArgToSkip,\n                                                               classesHeaders, hasCxxModule));\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Remove an object from the in-memory list.\n///    Since TROOT is global resource, this is lock protected.\n\nTObject *TROOT::Remove(TObject* obj)\n{\n   R__LOCKGUARD(gROOTMutex);\n   return TDirectory::Remove(obj);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Remove a class from the list and map of classes.\n/// This routine is deprecated, use TClass::RemoveClass directly.\n\nvoid TROOT::RemoveClass(TClass *oldcl)\n{\n   TClass::RemoveClass(oldcl);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Delete all global interpreter objects created since the last call to Reset\n///\n/// If option=\"a\" is set reset to startup context (i.e. unload also\n/// all loaded files, classes, structs, typedefs, etc.).\n///\n/// This function is typically used at the beginning (or end) of an unnamed macro\n/// to clean the environment.\n///\n/// IMPORTANT WARNING:\n/// Do not use this call from within any function (neither compiled nor\n/// interpreted.  This should only be used from a unnamed macro\n/// (which starts with a { (curly braces)  ).  For example, using TROOT::Reset\n/// from within an interpreted function will lead to the unloading of the\n/// dictionary and source file, including the one defining the function being\n/// executed.\n///\n\nvoid TROOT::Reset(Option_t *option)\n{\n   if (IsExecutingMacro()) return;  //True when TMacro::Exec runs\n   if (fInterpreter) {\n      if (!strncmp(option, \"a\", 1)) {\n         fInterpreter->Reset();\n         fInterpreter->SaveContext();\n      } else\n         gInterpreter->ResetGlobals();\n\n      if (fGlobals) fGlobals->Unload();\n      if (fGlobalFunctions) fGlobalFunctions->Unload();\n\n      SaveContext();\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Save the current interpreter context.\n\nvoid TROOT::SaveContext()\n{\n   if (fInterpreter)\n      gInterpreter->SaveGlobalsContext();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Set the default graphical cut class name for the graphics editor\n/// By default the graphics editor creates an instance of a class TCutG.\n/// This function may be called to specify a different class that MUST\n/// derive from TCutG\n\nvoid TROOT::SetCutClassName(const char *name)\n{\n   if (!name) {\n      Error(\"SetCutClassName\",\"Invalid class name\");\n      return;\n   }\n   TClass *cl = TClass::GetClass(name);\n   if (!cl) {\n      Error(\"SetCutClassName\",\"Unknown class:%s\",name);\n      return;\n   }\n   if (!cl->InheritsFrom(\"TCutG\")) {\n      Error(\"SetCutClassName\",\"Class:%s does not derive from TCutG\",name);\n      return;\n   }\n   fCutClassName = name;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Set editor mode\n\nvoid TROOT::SetEditorMode(const char *mode)\n{\n   fEditorMode = 0;\n   if (!mode[0]) return;\n   if (!strcmp(mode,\"Arc\"))      {fEditorMode = kArc;        return;}\n   if (!strcmp(mode,\"Line\"))     {fEditorMode = kLine;       return;}\n   if (!strcmp(mode,\"Arrow\"))    {fEditorMode = kArrow;      return;}\n   if (!strcmp(mode,\"Button\"))   {fEditorMode = kButton;     return;}\n   if (!strcmp(mode,\"Diamond\"))  {fEditorMode = kDiamond;    return;}\n   if (!strcmp(mode,\"Ellipse\"))  {fEditorMode = kEllipse;    return;}\n   if (!strcmp(mode,\"Pad\"))      {fEditorMode = kPad;        return;}\n   if (!strcmp(mode,\"Pave\"))     {fEditorMode = kPave;       return;}\n   if (!strcmp(mode,\"PaveLabel\")){fEditorMode = kPaveLabel;  return;}\n   if (!strcmp(mode,\"PaveText\")) {fEditorMode = kPaveText;   return;}\n   if (!strcmp(mode,\"PavesText\")){fEditorMode = kPavesText;  return;}\n   if (!strcmp(mode,\"PolyLine\")) {fEditorMode = kPolyLine;   return;}\n   if (!strcmp(mode,\"CurlyLine\")){fEditorMode = kCurlyLine;  return;}\n   if (!strcmp(mode,\"CurlyArc\")) {fEditorMode = kCurlyArc;   return;}\n   if (!strcmp(mode,\"Text\"))     {fEditorMode = kText;       return;}\n   if (!strcmp(mode,\"Marker\"))   {fEditorMode = kMarker;     return;}\n   if (!strcmp(mode,\"CutG\"))     {fEditorMode = kCutG;       return;}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Change current style to style with name stylename\n\nvoid TROOT::SetStyle(const char *stylename)\n{\n   TString style_name = stylename;\n\n   TStyle *style = GetStyle(style_name);\n   if (style) style->cd();\n   else       Error(\"SetStyle\",\"Unknown style:%s\",style_name.Data());\n}\n\n\n//-------- Static Member Functions ---------------------------------------------\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Decrease the indentation level for ls().\n\nInt_t TROOT::DecreaseDirLevel()\n{\n   return --fgDirLevel;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n///return directory level\n\nInt_t TROOT::GetDirLevel()\n{\n   return fgDirLevel;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get macro search path. Static utility function.\n\nconst char *TROOT::GetMacroPath()\n{\n   TString &macroPath = ROOT::GetMacroPath();\n\n   if (macroPath.Length() == 0) {\n      macroPath = gEnv->GetValue(\"Root.MacroPath\", (char*)0);\n#if defined(R__WIN32)\n      macroPath.ReplaceAll(\"; \", \";\");\n#else\n      macroPath.ReplaceAll(\": \", \":\");\n#endif\n      if (macroPath.Length() == 0)\n#if !defined(R__WIN32)\n         macroPath = \".:\" + TROOT::GetMacroDir();\n#else\n         macroPath = \".;\" + TROOT::GetMacroDir();\n#endif\n   }\n\n   return macroPath;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Set or extend the macro search path. Static utility function.\n/// If newpath=0 or \"\" reset to value specified in the rootrc file.\n\nvoid TROOT::SetMacroPath(const char *newpath)\n{\n   TString &macroPath = ROOT::GetMacroPath();\n\n   if (!newpath || !*newpath)\n      macroPath = \"\";\n   else\n      macroPath = newpath;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// \\brief Specify where web graphics shall be rendered\n///\n/// The input parameter `webdisplay` defines where web graphics is rendered.\n/// `webdisplay` parameter may contain:\n///\n///  - \"off\": turns off the web display and comes back to normal graphics in\n///    interactive mode.\n///  - \"batch\": turns the web display in batch mode. It can be prepended with\n///    another string which is considered as the new current web display.\n///  - \"nobatch\": turns the web display in interactive mode. It can be\n///    prepended with another string which is considered as the new current web display.\n///\n/// If the option \"off\" is not set, this method turns the normal graphics to\n/// \"Batch\" to avoid the loading of local graphics libraries.\n\nvoid TROOT::SetWebDisplay(const char *webdisplay)\n{\n   const char *wd = webdisplay;\n   if (!wd)\n      wd = \"\";\n\n   if (!strcmp(wd, \"off\")) {\n      fIsWebDisplay = kFALSE;\n      fIsWebDisplayBatch = kFALSE;\n      fWebDisplay = \"\";\n   } else {\n      fIsWebDisplay = kTRUE;\n      if (!strncmp(wd, \"batch\", 5)) {\n         fIsWebDisplayBatch = kTRUE;\n         wd += 5;\n      } else if (!strncmp(wd, \"nobatch\", 7)) {\n         fIsWebDisplayBatch = kFALSE;\n         wd += 7;\n      } else {\n         fIsWebDisplayBatch = kFALSE;\n      }\n      fWebDisplay = wd;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Increase the indentation level for ls().\n\nInt_t TROOT::IncreaseDirLevel()\n{\n   return ++fgDirLevel;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Functions used by ls() to indent an object hierarchy.\n\nvoid TROOT::IndentLevel()\n{\n   for (int i = 0; i < fgDirLevel; i++) std::cout.put(' ');\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Initialize ROOT explicitly.\n\nvoid TROOT::Initialize() {\n   (void) gROOT;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return kTRUE if the TROOT object has been initialized.\n\nBool_t TROOT::Initialized()\n{\n   return fgRootInit;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return kTRUE if the memory leak checker is on.\n\nBool_t TROOT::MemCheck()\n{\n   return fgMemCheck;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return Indentation level for ls().\n\nvoid TROOT::SetDirLevel(Int_t level)\n{\n   fgDirLevel = level;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Convert version code to an integer, i.e. 331527 -> 51507.\n\nInt_t TROOT::ConvertVersionCode2Int(Int_t code)\n{\n   return 10000*(code>>16) + 100*((code&65280)>>8) + (code&255);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Convert version as an integer to version code as used in RVersion.h.\n\nInt_t TROOT::ConvertVersionInt2Code(Int_t v)\n{\n   int a = v/10000;\n   int b = (v - a*10000)/100;\n   int c = v - a*10000 - b*100;\n   return (a << 16) + (b << 8) + c;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return ROOT version code as defined in RVersion.h.\n\nInt_t TROOT::RootVersionCode()\n{\n   return ROOT_VERSION_CODE;\n}\n////////////////////////////////////////////////////////////////////////////////\n/// Provide command line arguments to the interpreter construction.\n/// These arguments are added to the existing flags (e.g. `-DNDEBUG`).\n/// They are evaluated once per process, at the time where TROOT (and thus\n/// TInterpreter) is constructed.\n/// Returns the new flags.\n\nconst std::vector<std::string> &TROOT::AddExtraInterpreterArgs(const std::vector<std::string> &args) {\n   static std::vector<std::string> sArgs = {};\n   sArgs.insert(sArgs.begin(), args.begin(), args.end());\n   return sArgs;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// INTERNAL function!\n/// Used by rootcling to inject interpreter arguments through a C-interface layer.\n\nconst char**& TROOT::GetExtraInterpreterArgs() {\n   static const char** extraInterpArgs = 0;\n   return extraInterpArgs;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#ifdef ROOTPREFIX\nstatic Bool_t IgnorePrefix() {\n   static Bool_t ignorePrefix = gSystem->Getenv(\"ROOTIGNOREPREFIX\");\n   return ignorePrefix;\n}\n#endif\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the rootsys directory in the installation. Static utility function.\n\nconst TString& TROOT::GetRootSys() {\n   // Avoid returning a reference to a temporary because of the conversion\n   // between std::string and TString.\n   const static TString rootsys = ROOT::FoundationUtils::GetRootSys();\n   return rootsys;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the binary directory in the installation. Static utility function.\n\nconst TString& TROOT::GetBinDir() {\n#ifdef ROOTBINDIR\n   if (IgnorePrefix()) {\n#endif\n      static TString rootbindir;\n      if (rootbindir.IsNull()) {\n         rootbindir = \"bin\";\n         gSystem->PrependPathName(GetRootSys(), rootbindir);\n      }\n      return rootbindir;\n#ifdef ROOTBINDIR\n   } else {\n      const static TString rootbindir = ROOTBINDIR;\n      return rootbindir;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the library directory in the installation. Static utility function.\n\nconst TString& TROOT::GetLibDir() {\n#ifdef ROOTLIBDIR\n   if (IgnorePrefix()) {\n#endif\n      static TString rootlibdir;\n      if (rootlibdir.IsNull()) {\n         rootlibdir = \"lib\";\n         gSystem->PrependPathName(GetRootSys(), rootlibdir);\n      }\n      return rootlibdir;\n#ifdef ROOTLIBDIR\n   } else {\n      const static TString rootlibdir = ROOTLIBDIR;\n      return rootlibdir;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the include directory in the installation. Static utility function.\n\nconst TString& TROOT::GetIncludeDir() {\n   // Avoid returning a reference to a temporary because of the conversion\n   // between std::string and TString.\n   const static TString includedir = ROOT::FoundationUtils::GetIncludeDir();\n   return includedir;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the sysconfig directory in the installation. Static utility function.\n\nconst TString& TROOT::GetEtcDir() {\n   // Avoid returning a reference to a temporary because of the conversion\n   // between std::string and TString.\n   const static TString etcdir = ROOT::FoundationUtils::GetEtcDir();\n   return etcdir;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the data directory in the installation. Static utility function.\n\nconst TString& TROOT::GetDataDir() {\n#ifdef ROOTDATADIR\n   if (IgnorePrefix()) {\n#endif\n      return GetRootSys();\n#ifdef ROOTDATADIR\n   } else {\n      const static TString rootdatadir = ROOTDATADIR;\n      return rootdatadir;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the documentation directory in the installation. Static utility function.\n\nconst TString& TROOT::GetDocDir() {\n#ifdef ROOTDOCDIR\n   if (IgnorePrefix()) {\n#endif\n      return GetRootSys();\n#ifdef ROOTDOCDIR\n   } else {\n      const static TString rootdocdir = ROOTDOCDIR;\n      return rootdocdir;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the macro directory in the installation. Static utility function.\n\nconst TString& TROOT::GetMacroDir() {\n#ifdef ROOTMACRODIR\n   if (IgnorePrefix()) {\n#endif\n      static TString rootmacrodir;\n      if (rootmacrodir.IsNull()) {\n         rootmacrodir = \"macros\";\n         gSystem->PrependPathName(GetRootSys(), rootmacrodir);\n      }\n      return rootmacrodir;\n#ifdef ROOTMACRODIR\n   } else {\n      const static TString rootmacrodir = ROOTMACRODIR;\n      return rootmacrodir;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the tutorials directory in the installation. Static utility function.\n\nconst TString& TROOT::GetTutorialDir() {\n#ifdef ROOTTUTDIR\n   if (IgnorePrefix()) {\n#endif\n      static TString roottutdir;\n      if (roottutdir.IsNull()) {\n         roottutdir = \"tutorials\";\n         gSystem->PrependPathName(GetRootSys(), roottutdir);\n      }\n      return roottutdir;\n#ifdef ROOTTUTDIR\n   } else {\n      const static TString roottutdir = ROOTTUTDIR;\n      return roottutdir;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Shut down ROOT.\n\nvoid TROOT::ShutDown()\n{\n   if (gROOT)\n      gROOT->EndOfProcessCleanups();\n   else if (gInterpreter)\n      gInterpreter->ShutDown();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the source directory in the installation. Static utility function.\n\nconst TString& TROOT::GetSourceDir() {\n#ifdef ROOTSRCDIR\n   if (IgnorePrefix()) {\n#endif\n      static TString rootsrcdir;\n      if (rootsrcdir.IsNull()) {\n         rootsrcdir = \"src\";\n         gSystem->PrependPathName(GetRootSys(), rootsrcdir);\n      }\n      return rootsrcdir;\n#ifdef ROOTSRCDIR\n   } else {\n      const static TString rootsrcdir = ROOTSRCDIR;\n      return rootsrcdir;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the icon path in the installation. Static utility function.\n\nconst TString& TROOT::GetIconPath() {\n#ifdef ROOTICONPATH\n   if (IgnorePrefix()) {\n#endif\n      static TString rooticonpath;\n      if (rooticonpath.IsNull()) {\n         rooticonpath = \"icons\";\n         gSystem->PrependPathName(GetRootSys(), rooticonpath);\n      }\n      return rooticonpath;\n#ifdef ROOTICONPATH\n   } else {\n      const static TString rooticonpath = ROOTICONPATH;\n      return rooticonpath;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the fonts directory in the installation. Static utility function.\n\nconst TString& TROOT::GetTTFFontDir() {\n#ifdef TTFFONTDIR\n   if (IgnorePrefix()) {\n#endif\n      static TString ttffontdir;\n      if (ttffontdir.IsNull()) {\n         ttffontdir = \"fonts\";\n         gSystem->PrependPathName(GetRootSys(), ttffontdir);\n      }\n      return ttffontdir;\n#ifdef TTFFONTDIR\n   } else {\n      const static TString ttffontdir = TTFFONTDIR;\n      return ttffontdir;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the tutorials directory in the installation. Static utility function.\n/// Backward compatibility function - do not use for new code\n\nconst char *TROOT::GetTutorialsDir() {\n   return GetTutorialDir();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/core/metacling/src/TCling.cxx": "// @(#)root/meta:$Id$\n// vim: sw=3 ts=3 expandtab foldmethod=indent\n\n/*************************************************************************\n * Copyright (C) 1995-2012, Rene Brun and Fons Rademakers.               *\n * All rights reserved.                                                  *\n *                                                                       *\n * For the licensing terms see $ROOTSYS/LICENSE.                         *\n * For the list of contributors see $ROOTSYS/README/CREDITS.             *\n *************************************************************************/\n\n/** \\class TCling\n\nThis class defines an interface to the cling C++ interpreter.\n\nCling is a full ANSI compliant C++-11 interpreter based on\nclang/LLVM technology.\n*/\n\n#include \"TCling.h\"\n\n#include \"ROOT/FoundationUtils.hxx\"\n\n#include \"TClingBaseClassInfo.h\"\n#include \"TClingCallFunc.h\"\n#include \"TClingClassInfo.h\"\n#include \"TClingDataMemberInfo.h\"\n#include \"TClingMethodArgInfo.h\"\n#include \"TClingMethodInfo.h\"\n#include \"TClingRdictModuleFileExtension.h\"\n#include \"TClingTypedefInfo.h\"\n#include \"TClingTypeInfo.h\"\n#include \"TClingValue.h\"\n\n#include \"TROOT.h\"\n#include \"TApplication.h\"\n#include \"TGlobal.h\"\n#include \"TDataType.h\"\n#include \"TClass.h\"\n#include \"TClassEdit.h\"\n#include \"TClassTable.h\"\n#include \"TClingCallbacks.h\"\n#include \"TBaseClass.h\"\n#include \"TDataMember.h\"\n#include \"TMemberInspector.h\"\n#include \"TMethod.h\"\n#include \"TMethodArg.h\"\n#include \"TFunctionTemplate.h\"\n#include \"TObjArray.h\"\n#include \"TObjString.h\"\n#include \"TString.h\"\n#include \"THashList.h\"\n#include \"TOrdCollection.h\"\n#include \"TVirtualPad.h\"\n#include \"TSystem.h\"\n#include \"TVirtualMutex.h\"\n#include \"TError.h\"\n#include \"TEnv.h\"\n#include \"TEnum.h\"\n#include \"TEnumConstant.h\"\n#include \"THashTable.h\"\n#include \"RConversionRuleParser.h\"\n#include \"RConfigure.h\"\n#include \"compiledata.h\"\n#include \"TClingUtils.h\"\n#include \"TVirtualCollectionProxy.h\"\n#include \"TVirtualStreamerInfo.h\"\n#include \"TListOfDataMembers.h\"\n#include \"TListOfEnums.h\"\n#include \"TListOfEnumsWithLock.h\"\n#include \"TListOfFunctions.h\"\n#include \"TListOfFunctionTemplates.h\"\n#include \"TMemFile.h\"\n#include \"TProtoClass.h\"\n#include \"TStreamerInfo.h\" // This is here to avoid to use the plugin manager\n#include \"ThreadLocalStorage.h\"\n#include \"TFile.h\"\n#include \"TKey.h\"\n#include \"ClingRAII.h\"\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/GlobalDecl.h\"\n#include \"clang/AST/RecordLayout.h\"\n#include \"clang/AST/DeclVisitor.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/CodeGen/ModuleBuilder.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/Frontend/FrontendDiagnostic.h\"\n#include \"clang/Lex/HeaderSearch.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"clang/Lex/PreprocessorOptions.h\"\n#include \"clang/Sema/Lookup.h\"\n#include \"clang/Sema/Sema.h\"\n#include \"clang/Parse/Parser.h\"\n\n#include \"cling/Interpreter/ClangInternalState.h\"\n#include \"cling/Interpreter/DynamicLibraryManager.h\"\n#include \"cling/Interpreter/Interpreter.h\"\n#include \"cling/Interpreter/LookupHelper.h\"\n#include \"cling/Interpreter/Value.h\"\n#include \"cling/Interpreter/Transaction.h\"\n#include \"cling/MetaProcessor/MetaProcessor.h\"\n#include \"cling/Utils/AST.h\"\n#include \"cling/Utils/ParserStateRAII.h\"\n#include \"cling/Utils/SourceNormalization.h\"\n#include \"cling/Interpreter/Exception.h\"\n\n#include \"llvm/IR/GlobalValue.h\"\n#include \"llvm/IR/Module.h\"\n\n#include \"llvm/Support/DynamicLibrary.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/Process.h\"\n#include \"llvm/Object/ELFObjectFile.h\"\n#include \"llvm/Object/ObjectFile.h\"\n#include \"llvm/Object/SymbolicFile.h\"\n#include \"llvm/Support/FileSystem.h\"\n\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <map>\n#include <set>\n#include <stdexcept>\n#include <stdint.h>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <typeinfo>\n#include <unordered_map>\n#include <utility>\n#include <vector>\n#include <functional>\n\n#ifndef R__WIN32\n#include <cxxabi.h>\n#define R__DLLEXPORT __attribute__ ((visibility (\"default\")))\n#include <sys/stat.h>\n#endif\n#include <limits.h>\n#include <stdio.h>\n\n#ifdef __APPLE__\n#include <dlfcn.h>\n#include <mach-o/dyld.h>\n#include <mach-o/loader.h>\n#endif // __APPLE__\n\n#ifdef R__UNIX\n#include <dlfcn.h>\n#endif\n\n#if defined(__CYGWIN__)\n#include <sys/cygwin.h>\n#define HMODULE void *\nextern \"C\" {\n   __declspec(dllimport) void * __stdcall GetCurrentProcess();\n   __declspec(dllimport) bool __stdcall EnumProcessModules(void *, void **, unsigned long, unsigned long *);\n   __declspec(dllimport) unsigned long __stdcall GetModuleFileNameExW(void *, void *, wchar_t *, unsigned long);\n}\n#endif\n\n// Fragment copied from LLVM's raw_ostream.cpp\n#if defined(_MSC_VER)\n#ifndef STDIN_FILENO\n# define STDIN_FILENO 0\n#endif\n#ifndef STDOUT_FILENO\n# define STDOUT_FILENO 1\n#endif\n#ifndef STDERR_FILENO\n# define STDERR_FILENO 2\n#endif\n#ifndef R__WIN32\n//#if defined(HAVE_UNISTD_H)\n# include <unistd.h>\n//#endif\n#else\n#include \"Windows4Root.h\"\n#include <Psapi.h>\n#undef GetModuleFileName\n#define RTLD_DEFAULT ((void *)::GetModuleHandle(NULL))\n#define dlsym(library, function_name) ::GetProcAddress((HMODULE)library, function_name)\n#define dlopen(library_name, flags) ::LoadLibraryA(library_name)\n#define dlclose(library) ::FreeLibrary((HMODULE)library)\n#define R__DLLEXPORT __declspec(dllexport)\n#endif\n#endif\n\n//______________________________________________________________________________\n// Infrastructure to detect and react to libCling being teared down.\n//\nnamespace {\n   class TCling_UnloadMarker {\n   public:\n      ~TCling_UnloadMarker() {\n         if (ROOT::Internal::gROOTLocal) {\n            ROOT::Internal::gROOTLocal->~TROOT();\n         }\n      }\n   };\n   static TCling_UnloadMarker gTClingUnloadMarker;\n}\n\n\n\n//______________________________________________________________________________\n// These functions are helpers for debugging issues with non-LLVMDEV builds.\n//\nR__DLLEXPORT clang::DeclContext* TCling__DEBUG__getDeclContext(clang::Decl* D) {\n   return D->getDeclContext();\n}\nR__DLLEXPORT clang::NamespaceDecl* TCling__DEBUG__DCtoNamespace(clang::DeclContext* DC) {\n   return llvm::dyn_cast<clang::NamespaceDecl>(DC);\n}\nR__DLLEXPORT clang::RecordDecl* TCling__DEBUG__DCtoRecordDecl(clang::DeclContext* DC) {\n   return llvm::dyn_cast<clang::RecordDecl>(DC);\n}\nR__DLLEXPORT void TCling__DEBUG__dump(clang::DeclContext* DC) {\n   return DC->dumpDeclContext();\n}\nR__DLLEXPORT void TCling__DEBUG__dump(clang::Decl* D) {\n   return D->dump();\n}\nR__DLLEXPORT void TCling__DEBUG__dump(clang::FunctionDecl* FD) {\n   return FD->dump();\n}\nR__DLLEXPORT void TCling__DEBUG__decl_dump(void* D) {\n   return ((clang::Decl*)D)->dump();\n}\nR__DLLEXPORT void TCling__DEBUG__printName(clang::Decl* D) {\n   if (clang::NamedDecl* ND = llvm::dyn_cast<clang::NamedDecl>(D)) {\n      std::string name;\n      {\n         llvm::raw_string_ostream OS(name);\n         ND->getNameForDiagnostic(OS, D->getASTContext().getPrintingPolicy(),\n                                  true /*Qualified*/);\n      }\n      printf(\"%s\\n\", name.c_str());\n   }\n}\n//______________________________________________________________________________\n// These functions are helpers for testing issues directly rather than\n// relying on side effects.\n// This is used for the test for ROOT-7462/ROOT-6070\nR__DLLEXPORT bool TCling__TEST_isInvalidDecl(clang::Decl* D) {\n   return D->isInvalidDecl();\n}\nR__DLLEXPORT bool TCling__TEST_isInvalidDecl(ClassInfo_t *input) {\n   TClingClassInfo *info( (TClingClassInfo*) input);\n   assert(info && info->IsValid());\n   return info->GetDecl()->isInvalidDecl();\n}\n\nusing namespace std;\nusing namespace clang;\nusing namespace ROOT;\n\nnamespace {\n  static const std::string gInterpreterClassDef = R\"ICF(\n#undef ClassDef\n#define ClassDef(name, id) \\\n_ClassDefInterp_(name,id,virtual,) \\\nstatic int DeclFileLine() { return __LINE__; }\n#undef ClassDefNV\n#define ClassDefNV(name, id) \\\n_ClassDefInterp_(name,id,,) \\\nstatic int DeclFileLine() { return __LINE__; }\n#undef ClassDefOverride\n#define ClassDefOverride(name, id) \\\n_ClassDefInterp_(name,id,,override) \\\nstatic int DeclFileLine() { return __LINE__; }\n)ICF\";\n\n  static const std::string gNonInterpreterClassDef = R\"ICF(\n#define __ROOTCLING__ 1\n#undef ClassDef\n#define ClassDef(name,id) \\\n_ClassDefOutline_(name,id,virtual,) \\\nstatic int DeclFileLine() { return __LINE__; }\n#undef ClassDefNV\n#define ClassDefNV(name, id)\\\n_ClassDefOutline_(name,id,,)\\\nstatic int DeclFileLine() { return __LINE__; }\n#undef ClassDefOverride\n#define ClassDefOverride(name, id)\\\n_ClassDefOutline_(name,id,,override)\\\nstatic int DeclFileLine() { return __LINE__; }\n)ICF\";\n\n// The macros below use ::Error, so let's ensure it is included\n  static const std::string gClassDefInterpMacro = R\"ICF(\n#include \"TError.h\"\n\n#define _ClassDefInterp_(name,id,virtual_keyword, overrd) \\\nprivate: \\\npublic: \\\n   static TClass *Class() { static TClass* sIsA = 0; if (!sIsA) sIsA = TClass::GetClass(#name); return sIsA; } \\\n   static const char *Class_Name() { return #name; } \\\n   virtual_keyword Bool_t CheckTObjectHashConsistency() const overrd { return true; } \\\n   static Version_t Class_Version() { return id; } \\\n   static TClass *Dictionary() { return 0; } \\\n   virtual_keyword TClass *IsA() const overrd { return name::Class(); } \\\n   virtual_keyword void ShowMembers(TMemberInspector&insp) const overrd { ::ROOT::Class_ShowMembers(name::Class(), this, insp); } \\\n   virtual_keyword void Streamer(TBuffer&) overrd { ::Error(\"Streamer\", \"Cannot stream interpreted class.\"); } \\\n   void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { name::Streamer(ClassDef_StreamerNVirtual_b); } \\\n   static const char *DeclFileName() { return __FILE__; } \\\n   static int ImplFileLine() { return 0; } \\\n   static const char *ImplFileName() { return __FILE__; }\n)ICF\";\n}\nR__EXTERN int optind;\n\n// The functions are used to bridge cling/clang/llvm compiled with no-rtti and\n// ROOT (which uses rtti)\n\n////////////////////////////////////////////////////////////////////////////////\n/// Print a StackTrace!\n\nextern \"C\"\nvoid TCling__PrintStackTrace() {\n   gSystem->StackTrace();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Re-apply the lock count delta that TCling__ResetInterpreterMutex() caused.\n\nextern \"C\" void TCling__RestoreInterpreterMutex(void *delta)\n{\n   ((TCling*)gCling)->ApplyToInterpreterMutex(delta);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Lookup libraries in LD_LIBRARY_PATH and DYLD_LIBRARY_PATH with mangled_name,\n/// which is extracted by error messages we get from callback from cling. Return true\n/// when the missing library was autoloaded.\n\nextern \"C\" bool TCling__LibraryLoadingFailed(const std::string& errmessage, const std::string& libStem, bool permanent, bool resolved)\n{\n   return ((TCling*)gCling)->LibraryLoadingFailed(errmessage, libStem, permanent, resolved);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Reset the interpreter lock to the state it had before interpreter-related\n/// calls happened.\n\nextern \"C\" void *TCling__ResetInterpreterMutex()\n{\n   return ((TCling*)gCling)->RewindInterpreterMutex();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Lock the interpreter.\n\nextern \"C\" void *TCling__LockCompilationDuringUserCodeExecution()\n{\n   if (gInterpreterMutex) {\n      gInterpreterMutex->Lock();\n   }\n   return nullptr;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Unlock the interpreter.\n\nextern \"C\" void TCling__UnlockCompilationDuringUserCodeExecution(void* /*state*/)\n{\n   if (gInterpreterMutex) {\n      gInterpreterMutex->UnLock();\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Update TClingClassInfo for a class (e.g. upon seeing a definition).\n\nstatic void TCling__UpdateClassInfo(const NamedDecl* TD)\n{\n   static Bool_t entered = kFALSE;\n   static vector<const NamedDecl*> updateList;\n   Bool_t topLevel;\n\n   if (entered) topLevel = kFALSE;\n   else {\n      entered = kTRUE;\n      topLevel = kTRUE;\n   }\n   if (topLevel) {\n      ((TCling*)gInterpreter)->UpdateClassInfoWithDecl(TD);\n   } else {\n      // If we are called indirectly from within another call to\n      // TCling::UpdateClassInfo, we delay the update until the dictionary loading\n      // is finished (i.e. when we return to the top level TCling::UpdateClassInfo).\n      // This allows for the dictionary to be fully populated when we actually\n      // update the TClass object.   The updating of the TClass sometimes\n      // (STL containers and when there is an emulated class) forces the building\n      // of the TClass object's real data (which needs the dictionary info).\n      updateList.push_back(TD);\n   }\n   if (topLevel) {\n      while (!updateList.empty()) {\n         ((TCling*)gInterpreter)->UpdateClassInfoWithDecl(updateList.back());\n         updateList.pop_back();\n      }\n      entered = kFALSE;\n   }\n}\n\nvoid TCling::UpdateEnumConstants(TEnum* enumObj, TClass* cl) const {\n   const clang::Decl* D = static_cast<const clang::Decl*>(enumObj->GetDeclId());\n   if(const clang::EnumDecl* ED = dyn_cast<clang::EnumDecl>(D)) {\n      // Add the constants to the enum type.\n      for (EnumDecl::enumerator_iterator EDI = ED->enumerator_begin(),\n                EDE = ED->enumerator_end(); EDI != EDE; ++EDI) {\n         // Get name of the enum type.\n         std::string constbuf;\n         if (const NamedDecl* END = llvm::dyn_cast<NamedDecl>(*EDI)) {\n            PrintingPolicy Policy((*EDI)->getASTContext().getPrintingPolicy());\n            llvm::raw_string_ostream stream(constbuf);\n            // Don't trigger fopen of the source file to count lines:\n            Policy.AnonymousTagLocations = false;\n            (END)->getNameForDiagnostic(stream, Policy, /*Qualified=*/false);\n         }\n         const char* constantName = constbuf.c_str();\n\n         // Get value of the constant.\n         Long64_t value;\n         const llvm::APSInt valAPSInt = (*EDI)->getInitVal();\n         if (valAPSInt.isSigned()) {\n            value = valAPSInt.getSExtValue();\n         } else {\n            value = valAPSInt.getZExtValue();\n         }\n\n         // Create the TEnumConstant or update it if existing\n         TEnumConstant* enumConstant = nullptr;\n         TClingClassInfo* tcCInfo = (TClingClassInfo*)(cl ? cl->GetClassInfo() : 0);\n         TClingDataMemberInfo* tcDmInfo = new TClingDataMemberInfo(GetInterpreterImpl(), *EDI, tcCInfo);\n         DataMemberInfo_t* dmInfo = (DataMemberInfo_t*) tcDmInfo;\n         if (TObject* encAsTObj = enumObj->GetConstants()->FindObject(constantName)){\n            ((TEnumConstant*)encAsTObj)->Update(dmInfo);\n         } else {\n            enumConstant = new TEnumConstant(dmInfo, constantName, value, enumObj);\n         }\n\n         // Add the global constants to the list of Globals.\n         if (!cl) {\n            TCollection* globals = gROOT->GetListOfGlobals(false);\n            if (!globals->FindObject(constantName)) {\n               globals->Add(enumConstant);\n            }\n         }\n      }\n   }\n}\n\nTEnum* TCling::CreateEnum(void *VD, TClass *cl) const\n{\n   // Handle new enum declaration for either global and nested enums.\n\n   // Create the enum type.\n   TEnum* enumType = 0;\n   const clang::Decl* D = static_cast<const clang::Decl*>(VD);\n   std::string buf;\n   if (const EnumDecl* ED = llvm::dyn_cast<EnumDecl>(D)) {\n      // Get name of the enum type.\n      PrintingPolicy Policy(ED->getASTContext().getPrintingPolicy());\n      llvm::raw_string_ostream stream(buf);\n      // Don't trigger fopen of the source file to count lines:\n      Policy.AnonymousTagLocations = false;\n      ED->getNameForDiagnostic(stream, Policy, /*Qualified=*/false);\n      // If the enum is unnamed we do not add it to the list of enums i.e unusable.\n   }\n   if (buf.empty()) {\n      return 0;\n   }\n   const char* name = buf.c_str();\n   enumType = new TEnum(name, VD, cl);\n   UpdateEnumConstants(enumType, cl);\n\n   return enumType;\n}\n\nvoid TCling::HandleNewDecl(const void* DV, bool isDeserialized, std::set<TClass*> &modifiedTClasses) {\n   // Handle new declaration.\n   // Record the modified class, struct and namespaces in 'modifiedTClasses'.\n\n   const clang::Decl* D = static_cast<const clang::Decl*>(DV);\n\n   if (!D->isCanonicalDecl() && !isa<clang::NamespaceDecl>(D)\n       && !dyn_cast<clang::RecordDecl>(D)) return;\n\n   if (isa<clang::FunctionDecl>(D->getDeclContext())\n       || isa<clang::TagDecl>(D->getDeclContext()))\n      return;\n\n   // Don't list templates.\n   if (const clang::CXXRecordDecl* RD = dyn_cast<clang::CXXRecordDecl>(D)) {\n      if (RD->getDescribedClassTemplate())\n         return;\n   } else if (const clang::FunctionDecl* FD = dyn_cast<clang::FunctionDecl>(D)) {\n      if (FD->getDescribedFunctionTemplate())\n         return;\n   }\n\n   if (const RecordDecl *TD = dyn_cast<RecordDecl>(D)) {\n      if (TD->isCanonicalDecl() || TD->isThisDeclarationADefinition())\n         TCling__UpdateClassInfo(TD);\n   }\n   else if (const NamedDecl *ND = dyn_cast<NamedDecl>(D)) {\n\n      if (const TagDecl *TD = dyn_cast<TagDecl>(D)) {\n         // Mostly just for EnumDecl (the other TagDecl are handled\n         // by the 'RecordDecl' if statement.\n         TCling__UpdateClassInfo(TD);\n      } else if (const NamespaceDecl* NSD = dyn_cast<NamespaceDecl>(D)) {\n         TCling__UpdateClassInfo(NSD);\n      }\n\n      // We care about declarations on the global scope.\n      if (!isa<TranslationUnitDecl>(ND->getDeclContext()))\n         return;\n\n      // Enums are lazyly created, thus we don not need to handle them here.\n      if (isa<EnumDecl>(ND))\n         return;\n\n      // ROOT says that global is enum(lazylycreated)/var/field declared on the global\n      // scope.\n      if (!(isa<VarDecl>(ND)))\n         return;\n\n      // Skip if already in the list.\n      if (gROOT->GetListOfGlobals()->FindObject(ND->getNameAsString().c_str()))\n         return;\n\n      // Put the global constants and global enums in the corresponding lists.\n      gROOT->GetListOfGlobals()->Add(new TGlobal((DataMemberInfo_t *)\n                                                 new TClingDataMemberInfo(GetInterpreterImpl(),\n                                                                          cast<ValueDecl>(ND), 0)));\n   }\n}\n\nextern \"C\"\nvoid TCling__GetNormalizedContext(const ROOT::TMetaUtils::TNormalizedCtxt*& normCtxt)\n{\n   // We are sure in this context of the type of the interpreter\n   normCtxt = &( (TCling*) gInterpreter)->GetNormalizedContext();\n}\n\nextern \"C\"\nvoid TCling__UpdateListsOnCommitted(const cling::Transaction &T, cling::Interpreter*) {\n   ((TCling*)gCling)->UpdateListsOnCommitted(T);\n}\n\nextern \"C\"\nvoid TCling__UpdateListsOnUnloaded(const cling::Transaction &T) {\n   ((TCling*)gCling)->UpdateListsOnUnloaded(T);\n}\n\nextern \"C\"\nvoid TCling__InvalidateGlobal(const clang::Decl *D) {\n   ((TCling*)gCling)->InvalidateGlobal(D);\n}\n\nextern \"C\"\nvoid TCling__TransactionRollback(const cling::Transaction &T) {\n   ((TCling*)gCling)->TransactionRollback(T);\n}\n\nextern \"C\" void TCling__LibraryLoadedRTTI(const void* dyLibHandle,\n                                          const char* canonicalName) {\n   ((TCling*)gCling)->LibraryLoaded(dyLibHandle, canonicalName);\n}\n\nextern \"C\" void TCling__RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent)\n{\n   ((TCling *)gCling)->RegisterRdictForLoadPCM(pcmFileNameFullPath, pcmContent);\n}\n\nextern \"C\" void TCling__LibraryUnloadedRTTI(const void* dyLibHandle,\n                                            const char* canonicalName) {\n   ((TCling*)gCling)->LibraryUnloaded(dyLibHandle, canonicalName);\n}\n\n\nextern \"C\"\nTObject* TCling__GetObjectAddress(const char *Name, void *&LookupCtx) {\n   return ((TCling*)gCling)->GetObjectAddress(Name, LookupCtx);\n}\n\nextern \"C\" const Decl* TCling__GetObjectDecl(TObject *obj) {\n   return ((TClingClassInfo*)obj->IsA()->GetClassInfo())->GetDecl();\n}\n\nextern \"C\" R__DLLEXPORT TInterpreter *CreateInterpreter(void* interpLibHandle,\n                                                        const char* argv[])\n{\n   cling::DynamicLibraryManager::ExposeHiddenSharedLibrarySymbols(interpLibHandle);\n   return new TCling(\"C++\", \"cling C++ Interpreter\", argv);\n}\n\nextern \"C\" R__DLLEXPORT void DestroyInterpreter(TInterpreter *interp)\n{\n   delete interp;\n}\n\n// Load library containing specified class. Returns 0 in case of error\n// and 1 in case if success.\nextern \"C\" int TCling__AutoLoadCallback(const char* className)\n{\n   return ((TCling*)gCling)->AutoLoad(className);\n}\n\nextern \"C\" int TCling__AutoParseCallback(const char* className)\n{\n   return ((TCling*)gCling)->AutoParse(className);\n}\n\nextern \"C\" const char* TCling__GetClassSharedLibs(const char* className)\n{\n   return ((TCling*)gCling)->GetClassSharedLibs(className);\n}\n\n// Returns 0 for failure 1 for success\nextern \"C\" int TCling__IsAutoLoadNamespaceCandidate(const clang::NamespaceDecl* nsDecl)\n{\n   return ((TCling*)gCling)->IsAutoLoadNamespaceCandidate(nsDecl);\n}\n\nextern \"C\" int TCling__CompileMacro(const char *fileName, const char *options)\n{\n   string file(fileName);\n   string opt(options);\n   return gSystem->CompileMacro(file.c_str(), opt.c_str());\n}\n\nextern \"C\" void TCling__SplitAclicMode(const char* fileName, string &mode,\n                                       string &args, string &io, string &fname)\n{\n   string file(fileName);\n   TString f, amode, arguments, aclicio;\n   f = gSystem->SplitAclicMode(file.c_str(), amode, arguments, aclicio);\n   mode = amode.Data(); args = arguments.Data();\n   io = aclicio.Data(); fname = f.Data();\n}\n\n// Implemented in TClingCallbacks.\nextern \"C\" void TCling__FindLoadedLibraries(std::vector<std::pair<uint32_t, std::string>> &sLibraries,\n                                 std::vector<std::string> &sPaths,\n                                 cling::Interpreter &interpreter, bool searchSystem);\n\n//______________________________________________________________________________\n//\n//\n//\n\n#ifdef R__WIN32\nextern \"C\" {\n   char *__unDName(char *demangled, const char *mangled, int out_len,\n                   void * (* pAlloc )(size_t), void (* pFree )(void *),\n                   unsigned short int flags);\n}\n#endif\n\n////////////////////////////////////////////////////////////////////////////////\n/// Find a template decl within N nested namespaces, 0<=N<inf\n/// Assumes 1 and only 1 template present and 1 and only 1 entity contained\n/// by the namespace. Example: ns1::ns2::..::nsN::myTemplate\n/// Returns nullptr in case of error\n\nstatic clang::ClassTemplateDecl* FindTemplateInNamespace(clang::Decl* decl)\n{\n   using namespace clang;\n   if (NamespaceDecl* nsd = llvm::dyn_cast<NamespaceDecl>(decl)){\n      return FindTemplateInNamespace(*nsd->decls_begin());\n   }\n\n   if (ClassTemplateDecl* ctd = llvm::dyn_cast<ClassTemplateDecl>(decl)){\n      return ctd;\n   }\n\n   return nullptr; // something went wrong.\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Autoload a library provided the mangled name of a missing symbol.\n\nvoid* llvmLazyFunctionCreator(const std::string& mangled_name)\n{\n   return ((TCling*)gCling)->LazyFunctionCreatorAutoload(mangled_name);\n}\n\n//______________________________________________________________________________\n//\n//\n//\n\nint TCling_GenerateDictionary(const std::vector<std::string> &classes,\n                              const std::vector<std::string> &headers,\n                              const std::vector<std::string> &fwdDecls,\n                              const std::vector<std::string> &unknown)\n{\n   //This function automatically creates the \"LinkDef.h\" file for templated\n   //classes then executes CompileMacro on it.\n   //The name of the file depends on the class name, and it's not generated again\n   //if the file exist.\n   if (classes.empty()) {\n      return 0;\n   }\n   // Use the name of the first class as the main name.\n   const std::string& className = classes[0];\n   //(0) prepare file name\n   TString fileName = \"AutoDict_\";\n   std::string::const_iterator sIt;\n   for (sIt = className.begin(); sIt != className.end(); ++sIt) {\n      if (*sIt == '<' || *sIt == '>' ||\n            *sIt == ' ' || *sIt == '*' ||\n            *sIt == ',' || *sIt == '&' ||\n            *sIt == ':') {\n         fileName += '_';\n      }\n      else {\n         fileName += *sIt;\n      }\n   }\n   if (classes.size() > 1) {\n      Int_t chk = 0;\n      std::vector<std::string>::const_iterator it = classes.begin();\n      while ((++it) != classes.end()) {\n         for (UInt_t cursor = 0; cursor != it->length(); ++cursor) {\n            chk = chk * 3 + it->at(cursor);\n         }\n      }\n      fileName += TString::Format(\"_%u\", chk);\n   }\n   fileName += \".cxx\";\n   if (gSystem->AccessPathName(fileName) != 0) {\n      //file does not exist\n      //(1) prepare file data\n      // If STL, also request iterators' operators.\n      // vector is special: we need to check whether\n      // vector::iterator is a typedef to pointer or a\n      // class.\n      static const std::set<std::string> sSTLTypes {\n         \"vector\",\"list\",\"forward_list\",\"deque\",\"map\",\"unordered_map\",\"multimap\",\n         \"unordered_multimap\",\"set\",\"unordered_set\",\"multiset\",\"unordered_multiset\",\n         \"queue\",\"priority_queue\",\"stack\",\"iterator\"};\n      std::vector<std::string>::const_iterator it;\n      std::string fileContent(\"\");\n      for (it = headers.begin(); it != headers.end(); ++it) {\n         fileContent += \"#include \\\"\" + *it + \"\\\"\\n\";\n      }\n      for (it = unknown.begin(); it != unknown.end(); ++it) {\n         TClass* cl = TClass::GetClass(it->c_str());\n         if (cl && cl->GetDeclFileName()) {\n            TString header(gSystem->BaseName(cl->GetDeclFileName()));\n            TString dir(gSystem->DirName(cl->GetDeclFileName()));\n            TString dirbase(gSystem->BaseName(dir));\n            while (dirbase.Length() && dirbase != \".\"\n                   && dirbase != \"include\" && dirbase != \"inc\"\n                   && dirbase != \"prec_stl\") {\n               gSystem->PrependPathName(dirbase, header);\n               dir = gSystem->DirName(dir);\n            }\n            fileContent += TString(\"#include \\\"\") + header + \"\\\"\\n\";\n         }\n      }\n      for (it = fwdDecls.begin(); it != fwdDecls.end(); ++it) {\n         fileContent += \"class \" + *it + \";\\n\";\n      }\n      fileContent += \"#ifdef __CINT__ \\n\";\n      fileContent += \"#pragma link C++ nestedclasses;\\n\";\n      fileContent += \"#pragma link C++ nestedtypedefs;\\n\";\n      for (it = classes.begin(); it != classes.end(); ++it) {\n         std::string n(*it);\n         size_t posTemplate = n.find('<');\n         std::set<std::string>::const_iterator iSTLType = sSTLTypes.end();\n         if (posTemplate != std::string::npos) {\n            n.erase(posTemplate, std::string::npos);\n            if (n.compare(0, 5, \"std::\") == 0) {\n               n.erase(0, 5);\n            }\n            iSTLType = sSTLTypes.find(n);\n         }\n         fileContent += \"#pragma link C++ class \";\n         fileContent +=    *it + \"+;\\n\" ;\n         fileContent += \"#pragma link C++ class \";\n         if (iSTLType != sSTLTypes.end()) {\n            // STL class; we cannot (and don't need to) store iterators;\n            // their shadow and the compiler's version don't agree. So\n            // don't ask for the '+'\n            fileContent +=    *it + \"::*;\\n\" ;\n         }\n         else {\n            // Not an STL class; we need to allow the I/O of contained\n            // classes (now that we have a dictionary for them).\n            fileContent +=    *it + \"::*+;\\n\" ;\n         }\n      }\n      fileContent += \"#endif\\n\";\n      //end(1)\n      //(2) prepare the file\n      FILE* filePointer;\n      filePointer = fopen(fileName, \"w\");\n      if (filePointer == NULL) {\n         //can't open a file\n         return 1;\n      }\n      //end(2)\n      //write data into the file\n      fprintf(filePointer, \"%s\", fileContent.c_str());\n      fclose(filePointer);\n   }\n   //(3) checking if we can compile a macro, if not then cleaning\n   Int_t oldErrorIgnoreLevel = gErrorIgnoreLevel;\n   gErrorIgnoreLevel = kWarning; // no \"Info: creating library...\"\n   Int_t ret = gSystem->CompileMacro(fileName, \"k\");\n   gErrorIgnoreLevel = oldErrorIgnoreLevel;\n   if (ret == 0) { //can't compile a macro\n      return 2;\n   }\n   //end(3)\n   return 0;\n}\n\nint TCling_GenerateDictionary(const std::string& className,\n                              const std::vector<std::string> &headers,\n                              const std::vector<std::string> &fwdDecls,\n                              const std::vector<std::string> &unknown)\n{\n   //This function automatically creates the \"LinkDef.h\" file for templated\n   //classes then executes CompileMacro on it.\n   //The name of the file depends on the class name, and it's not generated again\n   //if the file exist.\n   std::vector<std::string> classes;\n   classes.push_back(className);\n   return TCling_GenerateDictionary(classes, headers, fwdDecls, unknown);\n}\n\n//______________________________________________________________________________\n//\n//\n//\n\n// It is a \"fantom\" method to synchronize user keyboard input\n// and ROOT prompt line (for WIN32)\nconst char* fantomline = \"TRint::EndOfLineAction();\";\n\n//______________________________________________________________________________\n//\n//\n//\n\nvoid* TCling::fgSetOfSpecials = 0;\n\n//______________________________________________________________________________\n//\n// llvm error handler through exceptions; see also cling/UserInterface\n//\nnamespace {\n   // Handle fatal llvm errors by throwing an exception.\n   // Yes, throwing exceptions in error handlers is bad.\n   // Doing nothing is pretty terrible, too.\n   void exceptionErrorHandler(void * /*user_data*/,\n                              const std::string& reason,\n                              bool /*gen_crash_diag*/) {\n      throw std::runtime_error(std::string(\">>> Interpreter compilation error:\\n\") + reason);\n   }\n}\n\n//______________________________________________________________________________\n//\n//\n//\n\n////////////////////////////////////////////////////////////////////////////////\n\nnamespace{\n   // An instance of this class causes the diagnostics of clang to be suppressed\n   // during its lifetime\n   class clangDiagSuppr {\n   public:\n      clangDiagSuppr(clang::DiagnosticsEngine& diag): fDiagEngine(diag){\n         fOldDiagValue = fDiagEngine.getIgnoreAllWarnings();\n         fDiagEngine.setIgnoreAllWarnings(true);\n      }\n\n      ~clangDiagSuppr() {\n         fDiagEngine.setIgnoreAllWarnings(fOldDiagValue);\n      }\n   private:\n      clang::DiagnosticsEngine& fDiagEngine;\n      bool fOldDiagValue;\n   };\n\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Allow calling autoparsing from TMetaUtils\nbool TClingLookupHelper__AutoParse(const char *cname)\n{\n   return gCling->AutoParse(cname);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Try hard to avoid looking up in the Cling database as this could enduce\n/// an unwanted autoparsing.\n\nbool TClingLookupHelper__ExistingTypeCheck(const std::string &tname,\n                                           std::string &result)\n{\n   result.clear();\n\n   unsigned long offset = 0;\n   if (strncmp(tname.c_str(), \"const \", 6) == 0) {\n      offset = 6;\n   }\n   unsigned long end = tname.length();\n   while( end && (tname[end-1]=='&' || tname[end-1]=='*' || tname[end-1]==']') ) {\n      if ( tname[end-1]==']' ) {\n         --end;\n         while ( end && tname[end-1]!='[' ) --end;\n      }\n      --end;\n   }\n   std::string innerbuf;\n   const char *inner;\n   if (end != tname.length()) {\n      innerbuf = tname.substr(offset,end-offset);\n      inner = innerbuf.c_str();\n   } else {\n      inner = tname.c_str()+offset;\n   }\n\n   //if (strchr(tname.c_str(),'[')!=0) fprintf(stderr,\"DEBUG: checking on %s vs %s %lu %lu\\n\",tname.c_str(),inner,offset,end);\n   if (gROOT->GetListOfClasses()->FindObject(inner)\n       || TClassTable::Check(inner,result) ) {\n      // This is a known class.\n      return true;\n   }\n\n   THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );\n   TDataType *type = (TDataType *)typeTable->THashTable::FindObject( inner );\n   if (type) {\n      // This is a raw type and an already loaded typedef.\n      const char *newname = type->GetFullTypeName();\n      if (type->GetType() == kLong64_t) {\n         newname = \"Long64_t\";\n      } else if (type->GetType() == kULong64_t) {\n         newname = \"ULong64_t\";\n      }\n      if (strcmp(inner,newname) == 0) {\n         return true;\n      }\n      if (offset) result = \"const \";\n      result += newname;\n      if ( end != tname.length() ) {\n         result += tname.substr(end,tname.length()-end);\n      }\n      if (result == tname) result.clear();\n      return true;\n   }\n\n   // Check if the name is an enumerator\n   const auto lastPos = TClassEdit::GetUnqualifiedName(inner);\n   if (lastPos != inner)   // Main switch: case 1 - scoped enum, case 2 global enum\n   {\n      // We have a scope\n      // All of this C gymnastic is to avoid allocations on the heap\n      const auto enName = lastPos;\n      const auto scopeNameSize = ((Long64_t)lastPos - (Long64_t)inner) / sizeof(decltype(*lastPos)) - 2;\n      char *scopeName = new char[scopeNameSize + 1];\n      strncpy(scopeName, inner, scopeNameSize);\n      scopeName[scopeNameSize] = '\\0';\n      // Check if the scope is in the list of classes\n      if (auto scope = static_cast<TClass *>(gROOT->GetListOfClasses()->FindObject(scopeName))) {\n         auto enumTable = dynamic_cast<const THashList *>(scope->GetListOfEnums(false));\n         if (enumTable && enumTable->THashList::FindObject(enName)) return true;\n      }\n      // It may still be in one of the loaded protoclasses\n      else if (auto scope = static_cast<TProtoClass *>(gClassTable->GetProtoNorm(scopeName))) {\n         auto listOfEnums = scope->GetListOfEnums();\n         if (listOfEnums) { // it could be null: no enumerators in the protoclass\n            auto enumTable = dynamic_cast<const THashList *>(listOfEnums);\n            if (enumTable && enumTable->THashList::FindObject(enName)) return true;\n         }\n      }\n      delete [] scopeName;\n   } else\n   {\n      // We don't have any scope: this could only be a global enum\n      auto enumTable = dynamic_cast<const THashList *>(gROOT->GetListOfEnums());\n      if (enumTable && enumTable->THashList::FindObject(inner)) return true;\n   }\n\n   if (gCling->GetClassSharedLibs(inner))\n   {\n      // This is a class name.\n      return true;\n   }\n\n   return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTCling::TUniqueString::TUniqueString(Long64_t size)\n{\n   fContent.reserve(size);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\ninline const char *TCling::TUniqueString::Data()\n{\n   return fContent.c_str();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Append string to the storage if not added already.\n\ninline bool TCling::TUniqueString::Append(const std::string& str)\n{\n   bool notPresent = fLinesHashSet.emplace(fHashFunc(str)).second;\n   if (notPresent){\n      fContent+=str;\n   }\n   return notPresent;\n}\n\nstd::string TCling::ToString(const char* type, void* obj)\n{\n   return fInterpreter->toString(type, obj);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n///\\returns true if the module was loaded.\nstatic bool LoadModule(const std::string &ModuleName, cling::Interpreter &interp)\n{\n   // When starting up ROOT, cling would load all modulemap files on the include\n   // paths. However, in a ROOT session, it is very common to run aclic which\n   // will invoke rootcling and possibly produce a modulemap and a module in\n   // the current folder.\n   //\n   // Before failing, try loading the modulemap in the current folder and try\n   // loading the requested module from it.\n   std::string currentDir = gSystem->WorkingDirectory();\n   assert(!currentDir.empty());\n   gCling->RegisterPrebuiltModulePath(currentDir);\n   return interp.loadModule(ModuleName, /*Complain=*/true);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Loads the C++ modules that we require to run any ROOT program. This is just\n/// supposed to make a C++ module from a modulemap available to the interpreter.\nstatic void LoadModules(const std::vector<std::string> &modules, cling::Interpreter &interp)\n{\n   for (const auto &modName : modules)\n      LoadModule(modName, interp);\n}\n\nstatic bool IsFromRootCling() {\n  // rootcling also uses TCling for generating the dictionary ROOT files.\n  const static bool foundSymbol = dlsym(RTLD_DEFAULT, \"usedToIdentifyRootClingByDlSym\");\n  return foundSymbol;\n}\n\nstatic std::string GetModuleNameAsString(clang::Module *M, const clang::Preprocessor &PP)\n{\n   const HeaderSearchOptions &HSOpts = PP.getHeaderSearchInfo().getHeaderSearchOpts();\n\n   std::string ModuleFileName;\n   if (!HSOpts.PrebuiltModulePaths.empty())\n      // Load the module from *only* in the prebuilt module path.\n      ModuleFileName = PP.getHeaderSearchInfo().getModuleFileName(M->Name, /*ModuleMapPath*/\"\", /*UsePrebuiltPath*/ true);\n   if (ModuleFileName.empty()) return \"\";\n\n   std::string ModuleName = llvm::sys::path::filename(ModuleFileName);\n   // Return stem of the filename\n   return std::string(llvm::sys::path::stem(ModuleName));\n}\n\nstatic void RegisterCxxModules(cling::Interpreter &clingInterp)\n{\n   if (!clingInterp.getCI()->getLangOpts().Modules)\n      return;\n      // Setup core C++ modules if we have any to setup.\n\n      // Load libc and stl first.\n#ifdef R__MACOSX\n   LoadModule(\"Darwin\", clingInterp);\n#else\n   LoadModule(\"libc\", clingInterp);\n#endif\n   LoadModule(\"std\", clingInterp);\n\n   LoadModule(\"_Builtin_intrinsics\", clingInterp);\n\n   // Load core modules\n   // This should be vector in order to be able to pass it to LoadModules\n   std::vector<std::string> CoreModules = {\"ROOT_Foundation_C\",\n                                           \"ROOT_Config\",\n                                           \"ROOT_Rtypes\",\n                                           \"ROOT_Foundation_Stage1_NoRTTI\",\n                                           \"Core\",\n                                           \"RIO\"};\n\n   // FIXME: Reducing those will let us be less dependent on rootmap files\n   static constexpr std::array<const char *, 3> ExcludeModules = {\n      {\"Rtools\", \"RSQLite\", \"RInterface\"}};\n\n   LoadModules(CoreModules, clingInterp);\n\n   // Take this branch only from ROOT because we don't need to preload modules in rootcling\n   if (!IsFromRootCling()) {\n      // Dynamically get all the modules and load them if they are not in core modules\n      clang::CompilerInstance &CI = *clingInterp.getCI();\n      clang::ModuleMap &moduleMap = CI.getPreprocessor().getHeaderSearchInfo().getModuleMap();\n      clang::Preprocessor &PP = CI.getPreprocessor();\n      std::vector<std::string> ModulesPreloaded;\n      for (auto I = moduleMap.module_begin(), E = moduleMap.module_end(); I != E; ++I) {\n         clang::Module *M = I->second;\n         assert(M);\n\n         std::string ModuleName = GetModuleNameAsString(M, PP);\n         if (!ModuleName.empty() &&\n             std::find(CoreModules.begin(), CoreModules.end(), ModuleName) == CoreModules.end() &&\n             std::find(ExcludeModules.begin(), ExcludeModules.end(), ModuleName) ==\n                ExcludeModules.end()) {\n            if (M->IsSystem && !M->IsMissingRequirement)\n               LoadModule(ModuleName, clingInterp);\n            else if (!M->IsSystem && !M->IsMissingRequirement)\n               ModulesPreloaded.push_back(ModuleName);\n         }\n      }\n      LoadModules(ModulesPreloaded, clingInterp);\n   }\n\n   // Check that the gROOT macro was exported by any core module.\n   assert(clingInterp.getMacro(\"gROOT\") && \"Couldn't load gROOT macro?\");\n\n   // C99 decided that it's a very good idea to name a macro `I` (the letter I).\n   // This seems to screw up nearly all the template code out there as `I` is\n   // common template parameter name and iterator variable name.\n   // Let's follow the GCC recommendation and undefine `I` in case any of the\n   // core modules have defined it:\n   // https://www.gnu.org/software/libc/manual/html_node/Complex-Numbers.html\n   clingInterp.declare(\"#ifdef I\\n #undef I\\n #endif\\n\");\n\n   // libc++ complex.h has #define complex _Complex. Give preference to the one\n   // in std.\n   clingInterp.declare(\"#ifdef complex\\n #undef complex\\n #endif\\n\");\n\n   // These macros are from loading R related modules, which conflict with\n   // user's code.\n   clingInterp.declare(\"#ifdef PI\\n #undef PI\\n #endif\\n\");\n   clingInterp.declare(\"#ifdef ERROR\\n #undef ERROR\\n #endif\\n\");\n}\n\nstatic void RegisterPreIncludedHeaders(cling::Interpreter &clingInterp)\n{\n   std::string PreIncludes;\n   bool hasCxxModules = clingInterp.getCI()->getLangOpts().Modules;\n\n   // For the list to also include string, we have to include it now.\n   // rootcling does parts already if needed, e.g. genreflex does not want using\n   // namespace std.\n   if (IsFromRootCling()) {\n      PreIncludes += \"#include \\\"RtypesCore.h\\\"\\n\";\n   } else {\n      if (!hasCxxModules)\n         PreIncludes += \"#include \\\"Rtypes.h\\\"\\n\";\n\n      PreIncludes += gClassDefInterpMacro + \"\\n\"\n                     + gInterpreterClassDef + \"\\n\"\n                     \"#undef ClassImp\\n\"\n                     \"#define ClassImp(X);\\n\";\n   }\n   if (!hasCxxModules)\n      PreIncludes += \"#include <string>\\n\";\n\n   // We must include it even when we have modules because it is marked as\n   // textual in the modulemap due to the nature of the assert header.\n   PreIncludes += \"#include <cassert>\\n\";\n   PreIncludes += \"using namespace std;\\n\";\n   clingInterp.declare(PreIncludes);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Initialize the cling interpreter interface.\n/// \\param argv - array of arguments passed to the cling::Interpreter constructor\n///               e.g. `-DFOO=bar`. The last element of the array must be `nullptr`.\n\nTCling::TCling(const char *name, const char *title, const char* const argv[])\n: TInterpreter(name, title), fMore(0), fGlobalsListSerial(-1), fMapfile(nullptr),\n  fRootmapFiles(nullptr), fLockProcessLine(true), fNormalizedCtxt(0),\n  fPrevLoadedDynLibInfo(0), fClingCallbacks(0), fAutoLoadCallBack(0),\n  fTransactionCount(0), fHeaderParsingOnDemand(true), fIsAutoParsingSuspended(kFALSE)\n{\n   fPrompt[0] = 0;\n   const bool fromRootCling = IsFromRootCling();\n\n   fCxxModulesEnabled = false;\n#ifdef R__USE_CXXMODULES\n   fCxxModulesEnabled = true;\n#endif\n\n   llvm::install_fatal_error_handler(&exceptionErrorHandler);\n\n   fTemporaries = new std::vector<cling::Value>();\n\n   std::vector<std::string> clingArgsStorage;\n   clingArgsStorage.push_back(\"cling4root\");\n   for (const char* const* arg = argv; *arg; ++arg)\n      clingArgsStorage.push_back(*arg);\n\n   // rootcling sets its arguments through TROOT::GetExtraInterpreterArgs().\n   if (!fromRootCling) {\n      ROOT::TMetaUtils::SetPathsForRelocatability(clingArgsStorage);\n\n      // Add -I early so ASTReader can find the headers.\n      std::string interpInclude(TROOT::GetEtcDir().Data());\n      clingArgsStorage.push_back(\"-I\" + interpInclude);\n\n      // Add include path to etc/cling.\n      clingArgsStorage.push_back(\"-I\" + interpInclude + \"/cling\");\n\n      // Add the root include directory and etc/ to list searched by default.\n      clingArgsStorage.push_back(std::string((\"-I\" + TROOT::GetIncludeDir()).Data()));\n\n      // Add the current path to the include path\n      // TCling::AddIncludePath(\".\");\n\n      // Attach the PCH (unless we have C++ modules enabled which provide the\n      // same functionality).\n      if (!fCxxModulesEnabled) {\n         std::string pchFilename = interpInclude + \"/allDict.cxx.pch\";\n         if (gSystem->Getenv(\"ROOT_PCH\")) {\n            pchFilename = gSystem->Getenv(\"ROOT_PCH\");\n         }\n\n         clingArgsStorage.push_back(\"-include-pch\");\n         clingArgsStorage.push_back(pchFilename);\n      }\n\n      clingArgsStorage.push_back(\"-Wno-undefined-inline\");\n      clingArgsStorage.push_back(\"-fsigned-char\");\n   }\n\n   // Process externally passed arguments if present.\n   llvm::Optional<std::string> EnvOpt = llvm::sys::Process::GetEnv(\"EXTRA_CLING_ARGS\");\n   if (EnvOpt.hasValue()) {\n      StringRef Env(*EnvOpt);\n      while (!Env.empty()) {\n         StringRef Arg;\n         std::tie(Arg, Env) = Env.split(' ');\n         clingArgsStorage.push_back(Arg.str());\n      }\n   }\n\n   auto GetEnvVarPath = [](const std::string &EnvVar,\n                            std::vector<std::string> &Paths) {\n      llvm::Optional<std::string> EnvOpt = llvm::sys::Process::GetEnv(EnvVar);\n      if (EnvOpt.hasValue()) {\n         StringRef Env(*EnvOpt);\n         while (!Env.empty()) {\n            StringRef Arg;\n            std::tie(Arg, Env) = Env.split(ROOT::FoundationUtils::GetEnvPathSeparator());\n            if (std::find(Paths.begin(), Paths.end(), Arg.str()) == Paths.end())\n               Paths.push_back(Arg.str());\n         }\n      }\n   };\n\n   if (fCxxModulesEnabled) {\n      std::vector<std::string> Paths;\n      // ROOT usually knows better where its libraries are. This way we can\n      // discover modules without having to should thisroot.sh and should fix\n      // gnuinstall.\n      Paths.push_back(TROOT::GetLibDir().Data());\n      GetEnvVarPath(\"CLING_PREBUILT_MODULE_PATH\", Paths);\n      //GetEnvVarPath(\"LD_LIBRARY_PATH\", Paths);\n      std::string EnvVarPath;\n      for (const std::string& P : Paths)\n         EnvVarPath += P + ROOT::FoundationUtils::GetEnvPathSeparator();\n      // FIXME: We should make cling -fprebuilt-module-path work.\n      gSystem->Setenv(\"CLING_PREBUILT_MODULE_PATH\", EnvVarPath.c_str());\n   }\n\n   // FIXME: This only will enable frontend timing reports.\n   EnvOpt = llvm::sys::Process::GetEnv(\"ROOT_CLING_TIMING\");\n   if (EnvOpt.hasValue())\n     clingArgsStorage.push_back(\"-ftime-report\");\n\n   // Add the overlay file. Note that we cannot factor it out for both root\n   // and rootcling because rootcling activates modules only if -cxxmodule\n   // flag is passed.\n   if (fCxxModulesEnabled && !fromRootCling) {\n      // For now we prefer rootcling to enumerate explicitly its modulemaps.\n      std::vector<std::string> Paths;\n      Paths.push_back(TROOT::GetIncludeDir().Data());\n      GetEnvVarPath(\"CLING_MODULEMAP_PATH\", Paths);\n\n      // Give highest precedence of the modulemap in the cwd.\n      Paths.push_back(gSystem->WorkingDirectory());\n\n      for (const std::string& P : Paths) {\n         std::string ModuleMapLoc = P + ROOT::FoundationUtils::GetPathSeparator()\n            + \"module.modulemap\";\n         if (!llvm::sys::fs::exists(ModuleMapLoc)) {\n            if (gDebug > 1)\n               ::Info(\"TCling::TCling\", \"Modulemap %s does not exist \\n\",\n                      ModuleMapLoc.c_str());\n\n            continue;\n         }\n\n         clingArgsStorage.push_back(\"-fmodule-map-file=\" + ModuleMapLoc);\n      }\n   }\n\n   std::vector<const char*> interpArgs;\n   for (std::vector<std::string>::const_iterator iArg = clingArgsStorage.begin(),\n           eArg = clingArgsStorage.end(); iArg != eArg; ++iArg)\n      interpArgs.push_back(iArg->c_str());\n\n   // Activate C++ modules support. If we are running within rootcling, it's up\n   // to rootcling to set this flag depending on whether it wants to produce\n   // C++ modules.\n   TString vfsArg;\n   if (fCxxModulesEnabled) {\n      if (!fromRootCling) {\n         // We only set this flag, rest is done by the CIFactory.\n         interpArgs.push_back(\"-fmodules\");\n         interpArgs.push_back(\"-fno-implicit-module-maps\");\n         // We should never build modules during runtime, so let's enable the\n         // module build remarks from clang to make it easier to spot when we do\n         // this by accident.\n         interpArgs.push_back(\"-Rmodule-build\");\n      }\n      // ROOT implements its autoloading upon module's link directives. We\n      // generate module A { header \"A.h\" link \"A.so\" export * } where ROOT's\n      // facilities use the link directive to dynamically load the relevant\n      // library. So, we need to suppress clang's default autolink behavior.\n      interpArgs.push_back(\"-fno-autolink\");\n   }\n\n#ifdef R__FAST_MATH\n   // Same setting as in rootcling_impl.cxx.\n   interpArgs.push_back(\"-ffast-math\");\n#endif\n\n   TString llvmResourceDir = TROOT::GetEtcDir() + \"/cling\";\n   // Add statically injected extra arguments, usually coming from rootcling.\n   for (const char** extraArgs = TROOT::GetExtraInterpreterArgs();\n        extraArgs && *extraArgs; ++extraArgs) {\n      if (!strcmp(*extraArgs, \"-resource-dir\")) {\n         // Take the next arg as the llvm resource directory.\n         llvmResourceDir = *(++extraArgs);\n      } else {\n         interpArgs.push_back(*extraArgs);\n      }\n   }\n\n   for (const auto &arg: TROOT::AddExtraInterpreterArgs({})) {\n      interpArgs.push_back(arg.c_str());\n   }\n\n   // Add the Rdict module file extension.\n   cling::Interpreter::ModuleFileExtensions extensions;\n   EnvOpt = llvm::sys::Process::GetEnv(\"ROOTDEBUG_RDICT\");\n   if (!EnvOpt.hasValue())\n      extensions.push_back(std::make_shared<TClingRdictModuleFileExtension>());\n\n   fInterpreter = llvm::make_unique<cling::Interpreter>(interpArgs.size(),\n                                                        &(interpArgs[0]),\n                                                        llvmResourceDir, extensions);\n\n   if (!fromRootCling) {\n      fInterpreter->installLazyFunctionCreator(llvmLazyFunctionCreator);\n   }\n\n   // Don't check whether modules' files exist.\n   fInterpreter->getCI()->getPreprocessorOpts().DisablePCHValidation = true;\n\n   // Until we can disable autoloading during Sema::CorrectTypo() we have\n   // to disable spell checking.\n   fInterpreter->getCI()->getLangOpts().SpellChecking = false;\n\n   // We need stream that doesn't close its file descriptor, thus we are not\n   // using llvm::outs. Keeping file descriptor open we will be able to use\n   // the results in pipes (Savannah #99234).\n   static llvm::raw_fd_ostream fMPOuts (STDOUT_FILENO, /*ShouldClose*/false);\n   fMetaProcessor = llvm::make_unique<cling::MetaProcessor>(*fInterpreter, fMPOuts);\n\n   RegisterCxxModules(*fInterpreter);\n   RegisterPreIncludedHeaders(*fInterpreter);\n\n   // We are now ready (enough is loaded) to init the list of opaque typedefs.\n   fNormalizedCtxt = new ROOT::TMetaUtils::TNormalizedCtxt(fInterpreter->getLookupHelper());\n   fLookupHelper = new ROOT::TMetaUtils::TClingLookupHelper(*fInterpreter, *fNormalizedCtxt,\n                                                            TClingLookupHelper__ExistingTypeCheck,\n                                                            TClingLookupHelper__AutoParse,\n                                                            &fIsShuttingDown);\n   TClassEdit::Init(fLookupHelper);\n\n   // Disallow auto-parsing in rootcling\n   fIsAutoParsingSuspended = fromRootCling;\n\n   ResetAll();\n\n   // Enable dynamic lookup\n   if (!fromRootCling) {\n      fInterpreter->enableDynamicLookup();\n   }\n\n   // Enable ClinG's DefinitionShadower for ROOT.\n   fInterpreter->allowRedefinition();\n\n   // Attach cling callbacks last; they might need TROOT::fInterpreter\n   // and should thus not be triggered during the equivalent of\n   // TROOT::fInterpreter = new TCling;\n   std::unique_ptr<TClingCallbacks>\n      clingCallbacks(new TClingCallbacks(GetInterpreterImpl(), /*hasCodeGen*/ !fromRootCling));\n   fClingCallbacks = clingCallbacks.get();\n   fClingCallbacks->SetAutoParsingSuspended(fIsAutoParsingSuspended);\n   fInterpreter->setCallbacks(std::move(clingCallbacks));\n\n   if (!fromRootCling) {\n      // Make sure cling looks into ROOT's libdir, even if not part of LD_LIBRARY_PATH\n      // e.g. because of an RPATH build.\n      fInterpreter->getDynamicLibraryManager()->addSearchPath(TROOT::GetLibDir().Data());\n   }\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Destroy the interpreter interface.\n\nTCling::~TCling()\n{\n   // ROOT's atexit functions require the interepreter to be available.\n   // Run them before shutting down.\n   if (!IsFromRootCling())\n      GetInterpreterImpl()->runAtExitFuncs();\n   fIsShuttingDown = true;\n   delete fMapfile;\n   delete fRootmapFiles;\n   delete fTemporaries;\n   delete fNormalizedCtxt;\n   delete fLookupHelper;\n   gCling = 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Initialize the interpreter, once TROOT::fInterpreter is set.\n\nvoid TCling::Initialize()\n{\n   fClingCallbacks->Initialize();\n\n   // We are set up. EnableAutoLoading() is checking for fromRootCling.\n   EnableAutoLoading();\n}\n\nvoid TCling::ShutDown()\n{\n   fIsShuttingDown = true;\n   ResetGlobals();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Wrapper around dladdr (and friends)\n\nstatic std::string FindLibraryName(void (*func)())\n{\n#if defined(__CYGWIN__) && defined(__GNUC__)\n   return {};\n#elif defined(G__WIN32)\n   MEMORY_BASIC_INFORMATION mbi;\n   if (!VirtualQuery (func, &mbi, sizeof (mbi)))\n   {\n      return {};\n   }\n\n   HMODULE hMod = (HMODULE) mbi.AllocationBase;\n   char moduleName[MAX_PATH];\n\n   if (!GetModuleFileNameA (hMod, moduleName, sizeof (moduleName)))\n   {\n      return {};\n   }\n   return ROOT::TMetaUtils::GetRealPath(moduleName);\n#else\n   Dl_info info;\n   if (dladdr((void*)func, &info) == 0) {\n      // Not in a known shared library, let's give up\n      return {};\n   } else {\n      if (strchr(info.dli_fname, '/'))\n         return ROOT::TMetaUtils::GetRealPath(info.dli_fname);\n      // Else absolute path. For all we know that's a binary.\n      // Some people have dictionaries in binaries, this is how we find their path:\n      // (see also https://stackoverflow.com/a/1024937/6182509)\n# if defined(R__MACOSX)\n      char buf[PATH_MAX] = { 0 };\n      uint32_t bufsize = sizeof(buf);\n      if (_NSGetExecutablePath(buf, &bufsize) >= 0)\n         return ROOT::TMetaUtils::GetRealPath(buf);\n      return ROOT::TMetaUtils::GetRealPath(info.dli_fname);\n# elif defined(R__UNIX)\n      char buf[PATH_MAX] = { 0 };\n      // Cross our fingers that /proc/self/exe exists.\n      if (readlink(\"/proc/self/exe\", buf, sizeof(buf)) > 0)\n         return ROOT::TMetaUtils::GetRealPath(buf);\n      std::string pipeCmd = std::string(\"which \\\"\") + info.dli_fname + \"\\\"\";\n      FILE* pipe = popen(pipeCmd.c_str(), \"r\");\n      if (!pipe)\n         return ROOT::TMetaUtils::GetRealPath(info.dli_fname);\n      std::string result;\n      while (fgets(buf, sizeof(buf), pipe)) {\n         result += buf;\n      }\n      pclose(pipe);\n      return ROOT::TMetaUtils::GetRealPath(result);\n# else\n#  error \"Unsupported platform.\"\n# endif\n      return {};\n   }\n#endif\n\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Helper to initialize TVirtualStreamerInfo's factor early.\n/// Use static initialization to insure only one TStreamerInfo is created.\nstatic bool R__InitStreamerInfoFactory()\n{\n   // Use lambda since SetFactory return void.\n   auto setFactory = []() {\n      TVirtualStreamerInfo::SetFactory(new TStreamerInfo());\n      return kTRUE;\n   };\n   static bool doneFactory = setFactory();\n   return doneFactory; // avoid unused variable warning.\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Register Rdict data for future loading by LoadPCM;\n\nvoid TCling::RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent)\n{\n   if (IsFromRootCling())\n      return;\n\n   if (llvm::sys::fs::exists(pcmFileNameFullPath)) {\n      ::Error(\"TCling::RegisterRdictForLoadPCM\", \"Rdict '%s' is both in Module extension and in File system.\", pcmFileNameFullPath.c_str());\n      return;\n   }\n\n   // The pcmFileNameFullPath must be resolved already because we cannot resolve\n   // a link to a non-existent file.\n   fPendingRdicts[pcmFileNameFullPath] = *pcmContent;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Tries to load a PCM from TFile; returns true on success.\n\nvoid TCling::LoadPCMImpl(TFile &pcmFile)\n{\n   auto listOfKeys = pcmFile.GetListOfKeys();\n\n   // This is an empty pcm\n   if (listOfKeys && ((listOfKeys->GetSize() == 0) ||                           // Nothing here, or\n                      ((listOfKeys->GetSize() == 1) &&                          // only one, and\n                       !strcmp(((TKey *)listOfKeys->At(0))->GetName(), \"EMPTY\") // name is EMPTY\n                       ))) {\n      return;\n   }\n\n   TObjArray *protoClasses;\n   if (gDebug > 1)\n      ::Info(\"TCling::LoadPCMImpl\", \"reading protoclasses for %s \\n\", pcmFile.GetName());\n\n   pcmFile.GetObject(\"__ProtoClasses\", protoClasses);\n\n   if (protoClasses) {\n      for (auto obj : *protoClasses) {\n         TProtoClass *proto = (TProtoClass *)obj;\n         TClassTable::Add(proto);\n      }\n      // Now that all TClass-es know how to set them up we can update\n      // existing TClasses, which might cause the creation of e.g. TBaseClass\n      // objects which in turn requires the creation of TClasses, that could\n      // come from the PCH, but maybe later in the loop. Instead of resolving\n      // a dependency graph the addition to the TClassTable above allows us\n      // to create these dependent TClasses as needed below.\n      for (auto proto : *protoClasses) {\n         if (TClass *existingCl = (TClass *)gROOT->GetListOfClasses()->FindObject(proto->GetName())) {\n            // We have an existing TClass object. It might be emulated\n            // or interpreted; we now have more information available.\n            // Make that available.\n            if (existingCl->GetState() != TClass::kHasTClassInit) {\n               DictFuncPtr_t dict = gClassTable->GetDict(proto->GetName());\n               if (!dict) {\n                  ::Error(\"TCling::LoadPCM\", \"Inconsistent TClassTable for %s\", proto->GetName());\n               } else {\n                  // This will replace the existing TClass.\n                  TClass *ncl = (*dict)();\n                  if (ncl)\n                     ncl->PostLoadCheck();\n               }\n            }\n         }\n      }\n\n      protoClasses->Clear(); // Ownership was transfered to TClassTable.\n      delete protoClasses;\n   }\n\n   TObjArray *dataTypes;\n   pcmFile.GetObject(\"__Typedefs\", dataTypes);\n   if (dataTypes) {\n      for (auto typedf : *dataTypes)\n         gROOT->GetListOfTypes()->Add(typedf);\n      dataTypes->Clear(); // Ownership was transfered to TListOfTypes.\n      delete dataTypes;\n   }\n\n   TObjArray *enums;\n   pcmFile.GetObject(\"__Enums\", enums);\n   if (enums) {\n      // Cache the pointers\n      auto listOfGlobals = gROOT->GetListOfGlobals();\n      auto listOfEnums = dynamic_cast<THashList *>(gROOT->GetListOfEnums());\n      // Loop on enums and then on enum constants\n      for (auto selEnum : *enums) {\n         const char *enumScope = selEnum->GetTitle();\n         const char *enumName = selEnum->GetName();\n         if (strcmp(enumScope, \"\") == 0) {\n            // This is a global enum and is added to the\n            // list of enums and its constants to the list of globals\n            if (!listOfEnums->THashList::FindObject(enumName)) {\n               ((TEnum *)selEnum)->SetClass(nullptr);\n               listOfEnums->Add(selEnum);\n            }\n            for (auto enumConstant : *static_cast<TEnum *>(selEnum)->GetConstants()) {\n               if (!listOfGlobals->FindObject(enumConstant)) {\n                  listOfGlobals->Add(enumConstant);\n               }\n            }\n         } else {\n            // This enum is in a namespace. A TClass entry is bootstrapped if\n            // none exists yet and the enum is added to it\n            TClass *nsTClassEntry = TClass::GetClass(enumScope);\n            if (!nsTClassEntry) {\n               nsTClassEntry = new TClass(enumScope, 0, TClass::kNamespaceForMeta, true);\n            }\n            auto listOfEnums = nsTClassEntry->fEnums.load();\n            if (!listOfEnums) {\n               if ((kIsClass | kIsStruct | kIsUnion) & nsTClassEntry->Property()) {\n                  // For this case, the list will be immutable once constructed\n                  // (i.e. in this case, by the end of this routine).\n                  listOfEnums = nsTClassEntry->fEnums = new TListOfEnums(nsTClassEntry);\n               } else {\n                  // namespaces can have enums added to them\n                  listOfEnums = nsTClassEntry->fEnums = new TListOfEnumsWithLock(nsTClassEntry);\n               }\n            }\n            if (listOfEnums && !listOfEnums->THashList::FindObject(enumName)) {\n               ((TEnum *)selEnum)->SetClass(nsTClassEntry);\n               listOfEnums->Add(selEnum);\n            }\n         }\n      }\n      enums->Clear();\n      delete enums;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Tries to load a rdict PCM, issues diagnostics if it fails.\n\nvoid TCling::LoadPCM(std::string pcmFileNameFullPath)\n{\n   SuspendAutoloadingRAII autoloadOff(this);\n   SuspendAutoParsing autoparseOff(this);\n   assert(!pcmFileNameFullPath.empty());\n   assert(llvm::sys::path::is_absolute(pcmFileNameFullPath));\n\n   // Easier to work with the ROOT interfaces.\n   TString pcmFileName = pcmFileNameFullPath;\n\n   // Prevent the ROOT-PCMs hitting this during auto-load during\n   // JITting - which will cause recursive compilation.\n   // Avoid to call the plugin manager at all.\n   R__InitStreamerInfoFactory();\n\n   TDirectory::TContext ctxt;\n   llvm::SaveAndRestore<Int_t> SaveGDebug(gDebug);\n   if (gDebug > 5) {\n      gDebug -= 5;\n      ::Info(\"TCling::LoadPCM\", \"Loading ROOT PCM %s\", pcmFileName.Data());\n   } else {\n      gDebug = 0;\n   }\n\n   if (llvm::sys::fs::is_symlink_file(pcmFileNameFullPath))\n      pcmFileNameFullPath = ROOT::TMetaUtils::GetRealPath(pcmFileNameFullPath);\n\n   auto pendingRdict = fPendingRdicts.find(pcmFileNameFullPath);\n   if (pendingRdict != fPendingRdicts.end()) {\n      llvm::StringRef pcmContent = pendingRdict->second;\n      TMemFile::ZeroCopyView_t range{pcmContent.data(), pcmContent.size()};\n      std::string RDictFileOpts = pcmFileNameFullPath + \"?filetype=pcm\";\n      TMemFile pcmMemFile(RDictFileOpts.c_str(), range);\n\n      LoadPCMImpl(pcmMemFile);\n\n      fPendingRdicts.erase(pendingRdict);\n\n      return;\n   }\n\n   if (!llvm::sys::fs::exists(pcmFileNameFullPath)) {\n      ::Error(\"TCling::LoadPCM\", \"ROOT PCM %s file does not exist\",\n              pcmFileNameFullPath.data());\n      if (!fPendingRdicts.empty())\n         for (const auto &rdict : fPendingRdicts)\n            ::Info(\"TCling::LoadPCM\", \"In-memory ROOT PCM candidate %s\\n\",\n                   rdict.first.c_str());\n      return;\n   }\n\n   if (!gROOT->IsRootFile(pcmFileName)) {\n      Fatal(\"LoadPCM\", \"The file %s is not a ROOT as was expected\\n\", pcmFileName.Data());\n      return;\n   }\n   TFile pcmFile(pcmFileName + \"?filetype=pcm\", \"READ\");\n   LoadPCMImpl(pcmFile);\n}\n\n//______________________________________________________________________________\n\nnamespace {\n   using namespace clang;\n\n   class ExtLexicalStorageAdder: public RecursiveASTVisitor<ExtLexicalStorageAdder>{\n      // This class is to be considered an helper for autoparsing.\n      // It visits the AST and marks all classes (in all of their redeclarations)\n      // with the setHasExternalLexicalStorage method.\n   public:\n      bool VisitRecordDecl(clang::RecordDecl* rcd){\n         if (gDebug > 2)\n            Info(\"ExtLexicalStorageAdder\",\n                 \"Adding external lexical storage to class %s\",\n                 rcd->getNameAsString().c_str());\n         auto reDeclPtr = rcd->getMostRecentDecl();\n         do {\n            reDeclPtr->setHasExternalLexicalStorage();\n         } while ((reDeclPtr = reDeclPtr->getPreviousDecl()));\n\n         return false;\n      }\n   };\n\n\n}\n\n////////////////////////////////////////////////////////////////////////////////\n///\\returns true if the module map was loaded, false on error or if the map was\n///         already loaded.\nbool TCling::RegisterPrebuiltModulePath(const std::string &FullPath,\n                                        const std::string &ModuleMapName /*= \"module.modulemap\"*/) const\n{\n   assert(llvm::sys::path::is_absolute(FullPath));\n   Preprocessor &PP = fInterpreter->getCI()->getPreprocessor();\n   FileManager &FM = PP.getFileManager();\n   // FIXME: In a ROOT session we can add an include path (through .I /inc/path)\n   // We should look for modulemap files there too.\n   const DirectoryEntry *DE = FM.getDirectory(FullPath);\n   if (DE) {\n      HeaderSearch &HS = PP.getHeaderSearchInfo();\n      HeaderSearchOptions &HSOpts = HS.getHeaderSearchOpts();\n      const auto &ModPaths = HSOpts.PrebuiltModulePaths;\n      bool pathExists = std::find(ModPaths.begin(), ModPaths.end(), FullPath) != ModPaths.end();\n      if (!pathExists)\n         HSOpts.AddPrebuiltModulePath(FullPath);\n      // We cannot use HS.lookupModuleMapFile(DE, /*IsFramework*/ false);\n      // because its internal call to getFile has CacheFailure set to true.\n      // In our case, modulemaps can appear any time due to ACLiC.\n      // Code copied from HS.lookupModuleMapFile.\n      llvm::SmallString<256> ModuleMapFileName(DE->getName());\n      llvm::sys::path::append(ModuleMapFileName, ModuleMapName);\n      const FileEntry *FE = FM.getFile(ModuleMapFileName, /*openFile*/ false,\n                                       /*CacheFailure*/ false);\n\n      // FIXME: Calling IsLoaded is slow! Replace this with the appropriate\n      // call to the clang::ModuleMap class.\n      if (FE && !this->IsLoaded(FE->getName().data())) {\n         if (!HS.loadModuleMapFile(FE, /*IsSystem*/ false))\n            return true;\n         Error(\"RegisterPrebuiltModulePath\", \"Could not load modulemap in %s\", ModuleMapFileName.c_str());\n      }\n   }\n   return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// List of dicts that have the PCM information already in the PCH.\nstatic const std::unordered_set<std::string> gIgnoredPCMNames = {\"libCore\",\n                                                                 \"libRint\",\n                                                                 \"libThread\",\n                                                                 \"libRIO\",\n                                                                 \"libImt\",\n                                                                 \"libcomplexDict\",\n                                                                 \"libdequeDict\",\n                                                                 \"liblistDict\",\n                                                                 \"libforward_listDict\",\n                                                                 \"libvectorDict\",\n                                                                 \"libmapDict\",\n                                                                 \"libmultimap2Dict\",\n                                                                 \"libmap2Dict\",\n                                                                 \"libmultimapDict\",\n                                                                 \"libsetDict\",\n                                                                 \"libmultisetDict\",\n                                                                 \"libunordered_setDict\",\n                                                                 \"libunordered_multisetDict\",\n                                                                 \"libunordered_mapDict\",\n                                                                 \"libunordered_multimapDict\",\n                                                                 \"libvalarrayDict\",\n                                                                 \"G__GenVector32\",\n                                                                 \"G__Smatrix32\"};\n\nstatic void PrintDlError(const char *dyLibName, const char *modulename)\n{\n#ifdef R__WIN32\n   char dyLibError[1000];\n   FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n                  dyLibError, sizeof(dyLibError), NULL);\n#else\n   const char *dyLibError = dlerror();\n#endif\n   ::Error(\"TCling::RegisterModule\", \"Cannot open shared library %s for dictionary %s:\\n  %s\", dyLibName, modulename,\n           (dyLibError) ? dyLibError : \"\");\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Update all the TClass registered in fClassesToUpdate\n\nvoid TCling::ProcessClassesToUpdate()\n{\n   while (!fClassesToUpdate.empty()) {\n      TClass *oldcl = fClassesToUpdate.back().first;\n      // If somehow the TClass has already been loaded (maybe it was registered several time),\n      // we skip it.  Otherwise, the existing TClass is in mode kInterpreted, kEmulated or\n      // maybe even kForwardDeclared and needs to replaced.\n      if (oldcl->GetState() != TClass::kHasTClassInit) {\n         // if (gDebug > 2) Info(\"RegisterModule\", \"Forcing TClass init for %s\", oldcl->GetName());\n         DictFuncPtr_t dict = fClassesToUpdate.back().second;\n         fClassesToUpdate.pop_back();\n         // Calling func could manipulate the list so, let maintain the list\n         // then call the dictionary function.\n         TClass *ncl = dict();\n         if (ncl) ncl->PostLoadCheck();\n      } else {\n         fClassesToUpdate.pop_back();\n      }\n   }\n}\n////////////////////////////////////////////////////////////////////////////////\n/// Inject the module named \"modulename\" into cling; load all headers.\n/// headers is a 0-terminated array of header files to #include after\n/// loading the module. The module is searched for in all $LD_LIBRARY_PATH\n/// entries (or %PATH% on Windows).\n/// This function gets called by the static initialization of dictionary\n/// libraries.\n/// The payload code is injected \"as is\" in the interpreter.\n/// The value of 'triggerFunc' is used to find the shared library location.\n\nvoid TCling::RegisterModule(const char* modulename,\n                            const char** headers,\n                            const char** includePaths,\n                            const char* payloadCode,\n                            const char* fwdDeclsCode,\n                            void (*triggerFunc)(),\n                            const FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,\n                            const char** classesHeaders,\n                            Bool_t lateRegistration /*=false*/,\n                            Bool_t hasCxxModule /*=false*/)\n{\n   const bool fromRootCling = IsFromRootCling();\n   // We need the dictionary initialization but we don't want to inject the\n   // declarations into the interpreter, except for those we really need for\n   // I/O; see rootcling.cxx after the call to TCling__GetInterpreter().\n   if (fromRootCling) return;\n\n   // When we cannot provide a module for the library we should enable header\n   // parsing. This 'mixed' mode ensures gradual migration to modules.\n   llvm::SaveAndRestore<bool> SaveHeaderParsing(fHeaderParsingOnDemand);\n   fHeaderParsingOnDemand = !hasCxxModule;\n\n   // Treat Aclic Libs in a special way. Do not delay the parsing.\n   bool hasHeaderParsingOnDemand = fHeaderParsingOnDemand;\n   bool isACLiC = strstr(modulename, \"_ACLiC_dict\") != nullptr;\n   if (hasHeaderParsingOnDemand && isACLiC) {\n      if (gDebug>1)\n         Info(\"TCling::RegisterModule\",\n              \"Header parsing on demand is active but this is an Aclic library. Disabling it for this library.\");\n      hasHeaderParsingOnDemand = false;\n   }\n\n\n   // Make sure we relookup symbols that were search for before we loaded\n   // their autoparse information.  We could be more subtil and remove only\n   // the failed one or only the one in this module, but for now this is\n   // better than nothing.\n   fLookedUpClasses.clear();\n\n   // Make sure we do not set off autoloading or autoparsing during the\n   // module registration!\n   SuspendAutoloadingRAII autoLoadOff(this);\n\n   for (const char** inclPath = includePaths; *inclPath; ++inclPath) {\n      TCling::AddIncludePath(*inclPath);\n   }\n   cling::Transaction* T = 0;\n   // Put the template decls and the number of arguments to skip in the TNormalizedCtxt\n   for (auto& fwdDeclArgToSkipPair : fwdDeclsArgToSkip){\n      const std::string& fwdDecl = fwdDeclArgToSkipPair.first;\n      const int nArgsToSkip = fwdDeclArgToSkipPair.second;\n      auto compRes = fInterpreter->declare(fwdDecl.c_str(), &T);\n      assert(cling::Interpreter::kSuccess == compRes &&\n            \"A fwd declaration could not be compiled\");\n      if (compRes!=cling::Interpreter::kSuccess){\n         Warning(\"TCling::RegisterModule\",\n               \"Problems in declaring string '%s' were encountered.\",\n               fwdDecl.c_str()) ;\n         continue;\n      }\n\n      // Drill through namespaces recursively until the template is found\n      if(ClassTemplateDecl* TD = FindTemplateInNamespace(T->getFirstDecl().getSingleDecl())){\n         fNormalizedCtxt->AddTemplAndNargsToKeep(TD->getCanonicalDecl(), nArgsToSkip);\n      }\n\n   }\n\n   // FIXME: Remove #define __ROOTCLING__ once PCMs are there.\n   // This is used to give Sema the same view on ACLiC'ed files (which\n   // are then #included through the dictionary) as rootcling had.\n   TString code = gNonInterpreterClassDef;\n   if (payloadCode)\n      code += payloadCode;\n\n   std::string dyLibName = FindLibraryName(triggerFunc);\n   assert(!llvm::sys::fs::is_symlink_file(dyLibName));\n\n   if (dyLibName.empty()) {\n      ::Error(\"TCling::RegisterModule\", \"Dictionary trigger function for %s not found\", modulename);\n      return;\n   }\n\n   // The triggerFunc may not be in a shared object but in an executable.\n   bool isSharedLib = cling::DynamicLibraryManager::isSharedLibrary(dyLibName);\n\n   bool wasDlopened = false;\n\n   // If this call happens after dlopen has finished (i.e. late registration)\n   // there is no need to dlopen the library recursively. See ROOT-8437 where\n   // the dyLibName would correspond to the binary.\n   if (!lateRegistration) {\n\n      if (isSharedLib) {\n         // We need to open the dictionary shared library, to resolve symbols\n         // requested by the JIT from it: as the library is currently being dlopen'ed,\n         // its symbols are not yet reachable from the process.\n         // Recursive dlopen seems to work just fine.\n         void* dyLibHandle = dlopen(dyLibName.c_str(), RTLD_LAZY | RTLD_GLOBAL);\n         if (dyLibHandle) {\n            fRegisterModuleDyLibs.push_back(dyLibHandle);\n            wasDlopened = true;\n         } else {\n            PrintDlError(dyLibName.c_str(), modulename);\n         }\n      }\n   } // if (!lateRegistration)\n\n   if (hasHeaderParsingOnDemand && fwdDeclsCode){\n      // We now parse the forward declarations. All the classes are then modified\n      // in order for them to have an external lexical storage.\n      std::string fwdDeclsCodeLessEnums;\n      {\n         // Search for enum forward decls and only declare them if no\n         // declaration exists yet.\n         std::string fwdDeclsLine;\n         std::istringstream fwdDeclsCodeStr(fwdDeclsCode);\n         std::vector<std::string> scopes;\n         while (std::getline(fwdDeclsCodeStr, fwdDeclsLine)) {\n            const auto enumPos = fwdDeclsLine.find(\"enum  __attribute__((annotate(\\\"\");\n            // We check if the line contains a fwd declaration of an enum\n            if (enumPos != std::string::npos) {\n               // We clear the scopes which we may have carried from a previous iteration\n               scopes.clear();\n               // We check if the enum is not in a scope. If yes, save its name\n               // and the names of the enclosing scopes.\n               if (enumPos != 0) {\n                  // it's enclosed in namespaces. We need to understand what they are\n                  auto nsPos = fwdDeclsLine.find(\"namespace\");\n                  R__ASSERT(nsPos < enumPos && \"Inconsistent enum and enclosing scope parsing!\");\n                  while (nsPos < enumPos && nsPos != std::string::npos) {\n                     // we have a namespace, let's put it in the collection of scopes\n                     const auto nsNameStart = nsPos + 10;\n                     const auto nsNameEnd = fwdDeclsLine.find('{', nsNameStart);\n                     const auto nsName = fwdDeclsLine.substr(nsNameStart, nsNameEnd - nsNameStart);\n                     scopes.push_back(nsName);\n                     nsPos = fwdDeclsLine.find(\"namespace\", nsNameEnd);\n                  }\n               }\n               clang::DeclContext* DC = 0;\n               for (auto &&aScope: scopes) {\n                  DC = cling::utils::Lookup::Namespace(&fInterpreter->getSema(), aScope.c_str(), DC);\n                  if (!DC) {\n                     // No decl context means we have to fwd declare the enum.\n                     break;\n                  }\n               }\n               if (scopes.empty() || DC) {\n                  // We know the scope; let's look for the enum.\n                  size_t posEnumName = fwdDeclsLine.find(\"\\\"))) \", 32);\n                  R__ASSERT(posEnumName != std::string::npos && \"Inconsistent enum fwd decl!\");\n                  posEnumName += 5; // skip \"\\\"))) \"\n                  while (isspace(fwdDeclsLine[posEnumName]))\n                     ++posEnumName;\n                  size_t posEnumNameEnd = fwdDeclsLine.find(\" : \", posEnumName);\n                  R__ASSERT(posEnumNameEnd  != std::string::npos && \"Inconsistent enum fwd decl (end)!\");\n                  while (isspace(fwdDeclsLine[posEnumNameEnd]))\n                     --posEnumNameEnd;\n                  // posEnumNameEnd now points to the last character of the name.\n\n                  std::string enumName = fwdDeclsLine.substr(posEnumName,\n                                                             posEnumNameEnd - posEnumName + 1);\n\n                  if (clang::NamedDecl* enumDecl\n                      = cling::utils::Lookup::Named(&fInterpreter->getSema(),\n                                                    enumName.c_str(), DC)) {\n                     // We have an existing enum decl (forward or definition);\n                     // skip this.\n                     R__ASSERT(llvm::dyn_cast<clang::EnumDecl>(enumDecl) && \"not an enum decl!\");\n                     (void)enumDecl;\n                     continue;\n                  }\n               }\n            }\n\n            fwdDeclsCodeLessEnums += fwdDeclsLine + \"\\n\";\n         }\n      }\n\n      if (fwdDeclsCodeLessEnums.size() != 0){ // Avoid the overhead if nothing is to be declared\n         auto compRes = fInterpreter->declare(fwdDeclsCodeLessEnums, &T);\n         assert(cling::Interpreter::kSuccess == compRes &&\n               \"The forward declarations could not be compiled\");\n         if (compRes!=cling::Interpreter::kSuccess){\n            Warning(\"TCling::RegisterModule\",\n                  \"Problems in compiling forward declarations for module %s: '%s'\",\n                  modulename, fwdDeclsCodeLessEnums.c_str()) ;\n         }\n         else if (T){\n            // Loop over all decls in the transaction and go through them all\n            // to mark them properly.\n            // In order to do that, we first iterate over all the DelayedCallInfos\n            // within the transaction. Then we loop over all Decls in the DeclGroupRef\n            // contained in the DelayedCallInfos. For each decl, we traverse.\n            ExtLexicalStorageAdder elsa;\n            for (auto dciIt = T->decls_begin();dciIt!=T->decls_end();dciIt++){\n               cling::Transaction::DelayCallInfo& dci = *dciIt;\n               for(auto dit = dci.m_DGR.begin(); dit != dci.m_DGR.end(); ++dit) {\n                  clang::Decl* declPtr = *dit;\n                  elsa.TraverseDecl(declPtr);\n               }\n            }\n         }\n      }\n\n      // Now we register all the headers necessary for the class\n      // Typical format of the array:\n      //    {\"A\", \"classes.h\", \"@\",\n      //     \"vector<A>\", \"vector\", \"@\",\n      //     \"myClass\", payloadCode, \"@\",\n      //    nullptr};\n\n      std::string temp;\n      for (const char** classesHeader = classesHeaders; *classesHeader; ++classesHeader) {\n         temp=*classesHeader;\n\n         size_t theTemplateHash = 0;\n         bool addTemplate = false;\n         size_t posTemplate = temp.find('<');\n         if (posTemplate != std::string::npos) {\n            // Add an entry for the template itself.\n            std::string templateName = temp.substr(0, posTemplate);\n            theTemplateHash = fStringHashFunction(templateName);\n            addTemplate = true;\n         }\n         size_t theHash = fStringHashFunction(temp);\n         classesHeader++;\n         for (const char** classesHeader_inner = classesHeader; 0!=strcmp(*classesHeader_inner,\"@\"); ++classesHeader_inner,++classesHeader){\n            // This is done in order to distinguish headers from files and from the payloadCode\n            if (payloadCode == *classesHeader_inner ){\n               fPayloads.insert(theHash);\n               if (addTemplate) fPayloads.insert(theTemplateHash);\n            }\n            if (gDebug > 2)\n               Info(\"TCling::RegisterModule\",\n                     \"Adding a header for %s\", temp.c_str());\n            fClassesHeadersMap[theHash].push_back(*classesHeader_inner);\n            if (addTemplate) {\n               if (fClassesHeadersMap.find(theTemplateHash) == fClassesHeadersMap.end()) {\n                  fClassesHeadersMap[theTemplateHash].push_back(*classesHeader_inner);\n               }\n               addTemplate = false;\n            }\n         }\n      }\n   }\n\n   clang::Sema &TheSema = fInterpreter->getSema();\n\n   bool ModuleWasSuccessfullyLoaded = false;\n   if (hasCxxModule) {\n      std::string ModuleName = modulename;\n      if (llvm::StringRef(modulename).startswith(\"lib\"))\n         ModuleName = llvm::StringRef(modulename).substr(3).str();\n\n      // In case we are directly loading the library via gSystem->Load() without\n      // specifying the relevant include paths we should try loading the\n      // modulemap next to the library location.\n      clang::Preprocessor &PP = TheSema.getPreprocessor();\n      std::string ModuleMapName;\n      if (isACLiC)\n         ModuleMapName = ModuleName + \".modulemap\";\n      else\n         ModuleMapName = \"module.modulemap\";\n      RegisterPrebuiltModulePath(llvm::sys::path::parent_path(dyLibName),\n                                 ModuleMapName);\n\n      // FIXME: We should only complain for modules which we know to exist. For example, we should not complain about\n      // modules such as GenVector32 because it needs to fall back to GenVector.\n      ModuleWasSuccessfullyLoaded = LoadModule(ModuleName, *fInterpreter);\n      if (!ModuleWasSuccessfullyLoaded) {\n         // Only report if we found the module in the modulemap.\n         clang::HeaderSearch &headerSearch = PP.getHeaderSearchInfo();\n         clang::ModuleMap &moduleMap = headerSearch.getModuleMap();\n         if (moduleMap.findModule(ModuleName))\n            Info(\"TCling::RegisterModule\", \"Module %s in modulemap failed to load.\", ModuleName.c_str());\n      }\n   }\n\n   if (gIgnoredPCMNames.find(modulename) == gIgnoredPCMNames.end()) {\n      llvm::SmallString<256> pcmFileNameFullPath(dyLibName);\n      // The path dyLibName might not be absolute. This can happen if dyLibName\n      // is linked to an executable in the same folder.\n      llvm::sys::fs::make_absolute(pcmFileNameFullPath);\n      llvm::sys::path::remove_filename(pcmFileNameFullPath);\n      llvm::sys::path::append(pcmFileNameFullPath,\n                              ROOT::TMetaUtils::GetModuleFileName(modulename));\n      LoadPCM(pcmFileNameFullPath.str().str());\n   }\n\n   { // scope within which diagnostics are de-activated\n   // For now we disable diagnostics because we saw them already at\n   // dictionary generation time. That won't be an issue with the PCMs.\n\n      clangDiagSuppr diagSuppr(TheSema.getDiagnostics());\n\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n      Warning(\"TCling::RegisterModule\",\"Diagnostics suppression should be gone by now.\");\n#endif\n#endif\n\n      if (!ModuleWasSuccessfullyLoaded && !hasHeaderParsingOnDemand){\n         SuspendAutoParsing autoParseRaii(this);\n\n         const cling::Transaction* watermark = fInterpreter->getLastTransaction();\n         cling::Interpreter::CompilationResult compRes = fInterpreter->parseForModule(code.Data());\n         if (isACLiC) {\n            // Register an unload point.\n            fMetaProcessor->registerUnloadPoint(watermark, headers[0]);\n         }\n\n         assert(cling::Interpreter::kSuccess == compRes &&\n                        \"Payload code of a dictionary could not be parsed correctly.\");\n         if (compRes!=cling::Interpreter::kSuccess) {\n            Warning(\"TCling::RegisterModule\",\n                  \"Problems declaring payload for module %s.\", modulename) ;\n         }\n      }\n   }\n\n   // Now that all the header have been registered/compiled, let's\n   // make sure to 'reset' the TClass that have a class init in this module\n   // but already had their type information available (using information/header\n   // loaded from other modules or from class rules or from opening a TFile\n   // or from loading header in a way that did not provoke the loading of\n   // the library we just loaded).\n   ProcessClassesToUpdate();\n\n   if (!ModuleWasSuccessfullyLoaded && !hasHeaderParsingOnDemand) {\n      // __ROOTCLING__ might be pulled in through PCH\n      fInterpreter->declare(\"#ifdef __ROOTCLING__\\n\"\n                            \"#undef __ROOTCLING__\\n\"\n                            + gInterpreterClassDef +\n                            \"#endif\");\n   }\n\n   if (wasDlopened) {\n      assert(isSharedLib);\n      void* dyLibHandle = fRegisterModuleDyLibs.back();\n      fRegisterModuleDyLibs.pop_back();\n      dlclose(dyLibHandle);\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Register classes that already existed prior to their dictionary loading\n/// and that already had a ClassInfo (and thus would not be refresh via\n/// UpdateClassInfo.\n\nvoid TCling::RegisterTClassUpdate(TClass *oldcl,DictFuncPtr_t dict)\n{\n   fClassesToUpdate.push_back(std::make_pair(oldcl,dict));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// If the dictionary is loaded, we can remove the class from the list\n/// (otherwise the class might be loaded twice).\n\nvoid TCling::UnRegisterTClassUpdate(const TClass *oldcl)\n{\n   typedef std::vector<std::pair<TClass*,DictFuncPtr_t> >::iterator iterator;\n   iterator stop = fClassesToUpdate.end();\n   for(iterator i = fClassesToUpdate.begin();\n       i != stop;\n       ++i)\n   {\n      if ( i->first == oldcl ) {\n         fClassesToUpdate.erase(i);\n         return;\n      }\n   }\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Let cling process a command line.\n///\n/// If the command is executed and the error is 0, then the return value\n/// is the int value corresponding to the result of the executed command\n/// (float and double return values will be truncated).\n///\n\n// Method for handling the interpreter exceptions.\n// the MetaProcessor is passing in as argument to teh function, because\n// cling::Interpreter::CompilationResult is a nested class and it cannot be\n// forward declared, thus this method cannot be a static member function\n// of TCling.\n\nstatic int HandleInterpreterException(cling::MetaProcessor* metaProcessor,\n                                 const char* input_line,\n                                 cling::Interpreter::CompilationResult& compRes,\n                                 cling::Value* result)\n{\n   try {\n      return metaProcessor->process(input_line, compRes, result);\n   }\n   catch (cling::InterpreterException& ex)\n   {\n      Error(\"HandleInterpreterException\", \"%s.\\n%s\", ex.what(), \"Execution of your code was aborted.\");\n      ex.diagnose();\n      compRes = cling::Interpreter::kFailure;\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::DiagnoseIfInterpreterException(const std::exception &e) const\n{\n   if (auto ie = dynamic_cast<const cling::InterpreterException*>(&e)) {\n      ie->diagnose();\n      return true;\n   }\n   return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::ProcessLine(const char* line, EErrorCode* error/*=0*/)\n{\n   // Copy the passed line, it comes from a static buffer in TApplication\n   // which can be reentered through the Cling evaluation routines,\n   // which would overwrite the static buffer and we would forget what we\n   // were doing.\n   //\n   TString sLine(line);\n   if (strstr(line,fantomline)) {\n      // End-Of-Line action\n      // See the comment (copied from above):\n      // It is a \"fantom\" method to synchronize user keyboard input\n      // and ROOT prompt line (for WIN32)\n      // and is implemented by\n      if (gApplication) {\n         if (gApplication->IsCmdThread()) {\n            R__LOCKGUARD(fLockProcessLine ? gInterpreterMutex : 0);\n            gROOT->SetLineIsProcessing();\n\n            UpdateAllCanvases();\n\n            gROOT->SetLineHasBeenProcessed();\n         }\n      }\n      return 0;\n   }\n\n   if (gGlobalMutex && !gInterpreterMutex && fLockProcessLine) {\n      gGlobalMutex->Lock();\n      if (!gInterpreterMutex)\n         gInterpreterMutex = gGlobalMutex->Factory(kTRUE);\n      gGlobalMutex->UnLock();\n   }\n   R__LOCKGUARD_CLING(fLockProcessLine ? gInterpreterMutex : 0);\n   gROOT->SetLineIsProcessing();\n\n   struct InterpreterFlagsRAII {\n      cling::Interpreter* fInterpreter;\n      bool fWasDynamicLookupEnabled;\n\n      InterpreterFlagsRAII(cling::Interpreter* interp):\n         fInterpreter(interp),\n         fWasDynamicLookupEnabled(interp->isDynamicLookupEnabled())\n      {\n         fInterpreter->enableDynamicLookup(true);\n      }\n      ~InterpreterFlagsRAII() {\n         fInterpreter->enableDynamicLookup(fWasDynamicLookupEnabled);\n         gROOT->SetLineHasBeenProcessed();\n      }\n   } interpreterFlagsRAII(GetInterpreterImpl());\n\n   // A non-zero returned value means the given line was\n   // not a complete statement.\n   int indent = 0;\n   // This will hold the resulting value of the evaluation the given line.\n   cling::Value result;\n   cling::Interpreter::CompilationResult compRes = cling::Interpreter::kSuccess;\n   if (!strncmp(sLine.Data(), \".L\", 2) || !strncmp(sLine.Data(), \".x\", 2) ||\n       !strncmp(sLine.Data(), \".X\", 2)) {\n      // If there was a trailing \"+\", then CINT compiled the code above,\n      // and we will need to strip the \"+\" before passing the line to cling.\n      TString mod_line(sLine);\n      TString aclicMode;\n      TString arguments;\n      TString io;\n      TString fname = gSystem->SplitAclicMode(sLine.Data() + 3,\n         aclicMode, arguments, io);\n      if (aclicMode.Length()) {\n         // Remove the leading '+'\n         R__ASSERT(aclicMode[0]=='+' && \"ACLiC mode must start with a +\");\n         aclicMode[0]='k';    // We always want to keep the .so around.\n         if (aclicMode[1]=='+') {\n            // We have a 2nd +\n            aclicMode[1]='f'; // We want to force the recompilation.\n         }\n         if (!gSystem->CompileMacro(fname,aclicMode)) {\n            // ACLiC failed.\n            compRes = cling::Interpreter::kFailure;\n         } else {\n            if (strncmp(sLine.Data(), \".L\", 2) != 0) {\n               // if execution was requested.\n\n               if (arguments.Length()==0) {\n                  arguments = \"()\";\n               }\n               // We need to remove the extension.\n               Ssiz_t ext = fname.Last('.');\n               if (ext != kNPOS) {\n                  fname.Remove(ext);\n               }\n               const char *function = gSystem->BaseName(fname);\n               mod_line = function + arguments + io;\n               indent = HandleInterpreterException(GetMetaProcessorImpl(), mod_line, compRes, &result);\n            }\n         }\n      } else {\n         // not ACLiC\n         size_t unnamedMacroOpenCurly;\n         {\n            std::string code;\n            std::string codeline;\n            std::ifstream in(fname);\n            while (in) {\n               std::getline(in, codeline);\n               code += codeline + \"\\n\";\n            }\n            unnamedMacroOpenCurly\n              = cling::utils::isUnnamedMacro(code, fInterpreter->getCI()->getLangOpts());\n         }\n\n         fCurExecutingMacros.push_back(fname);\n         if (unnamedMacroOpenCurly != std::string::npos) {\n            compRes = fMetaProcessor->readInputFromFile(fname.Data(), &result,\n                                                        unnamedMacroOpenCurly);\n         } else {\n            // No DynLookup for .x, .L of named macros.\n            fInterpreter->enableDynamicLookup(false);\n            indent = HandleInterpreterException(GetMetaProcessorImpl(), mod_line, compRes, &result);\n         }\n         fCurExecutingMacros.pop_back();\n      }\n   } // .L / .X / .x\n   else {\n      if (0!=strncmp(sLine.Data(), \".autodict \",10) && sLine != \".autodict\") {\n         // explicitly ignore .autodict without having to support it\n         // in cling.\n\n         // Turn off autoparsing if this is an include directive\n         bool isInclusionDirective = sLine.Contains(\"\\n#include\") || sLine.BeginsWith(\"#include\");\n         if (isInclusionDirective) {\n            SuspendAutoParsing autoParseRaii(this);\n            indent = HandleInterpreterException(GetMetaProcessorImpl(), sLine, compRes, &result);\n         } else {\n            indent = HandleInterpreterException(GetMetaProcessorImpl(), sLine, compRes, &result);\n         }\n      }\n   }\n   if (result.isValid())\n      RegisterTemporary(result);\n   if (indent) {\n      if (error)\n         *error = kProcessing;\n      return 0;\n   }\n   if (error) {\n      switch (compRes) {\n      case cling::Interpreter::kSuccess: *error = kNoError; break;\n      case cling::Interpreter::kFailure: *error = kRecoverable; break;\n      case cling::Interpreter::kMoreInputExpected: *error = kProcessing; break;\n      }\n   }\n   if (compRes == cling::Interpreter::kSuccess\n       && result.isValid()\n       && !result.isVoid())\n   {\n      return result.simplisticCastAs<long>();\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// No-op; see TRint instead.\n\nvoid TCling::PrintIntro()\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Add the given path to the list of directories in which the interpreter\n/// looks for include files. Only one path item can be specified at a\n/// time, i.e. \"path1:path2\" is NOT supported.\n\nvoid TCling::AddIncludePath(const char *path)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   // Favorite source of annoyance: gSystem->AddIncludePath() needs \"-I\",\n   // gCling->AddIncludePath() does not! Work around that inconsistency:\n   if (path[0] == '-' && path[1] == 'I')\n      path += 2;\n\n   fInterpreter->AddIncludePath(path);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Visit all members over members, recursing over base classes.\n\nvoid TCling::InspectMembers(TMemberInspector& insp, const void* obj,\n                            const TClass* cl, Bool_t isTransient)\n{\n   if (insp.GetObjectValidity() == TMemberInspector::kUnset) {\n      insp.SetObjectValidity(obj ? TMemberInspector::kValidObjectGiven\n                             : TMemberInspector::kNoObjectGiven);\n   }\n\n   if (!cl || cl->GetCollectionProxy()) {\n      // We do not need to investigate the content of the STL\n      // collection, they are opaque to us (and details are\n      // uninteresting).\n      return;\n   }\n\n   static const TClassRef clRefString(\"std::string\");\n   if (clRefString == cl) {\n      // We stream std::string without going through members..\n      return;\n   }\n\n   if (TClassEdit::IsStdArray(cl->GetName())) {\n      // We treat std arrays as C arrays\n      return;\n   }\n\n   const char* cobj = (const char*) obj; // for ptr arithmetics\n\n   // Treat the case of std::complex in a special manner. We want to enforce\n   // the layout of a stl implementation independent class, which is the\n   // complex as implemented in ROOT5.\n\n   // A simple lambda to simplify the code\n   auto inspInspect =  [&] (ptrdiff_t offset){\n      insp.Inspect(const_cast<TClass*>(cl), insp.GetParent(), \"_real\", cobj, isTransient);\n      insp.Inspect(const_cast<TClass*>(cl), insp.GetParent(), \"_imag\", cobj + offset, isTransient);\n   };\n\n   auto complexType = TClassEdit::GetComplexType(cl->GetName());\n   switch(complexType) {\n      case TClassEdit::EComplexType::kNone:\n      {\n        break;\n      }\n      case TClassEdit::EComplexType::kFloat:\n      {\n        inspInspect(sizeof(float));\n        return;\n      }\n      case TClassEdit::EComplexType::kDouble:\n      {\n        inspInspect(sizeof(double));\n        return;\n      }\n      case TClassEdit::EComplexType::kInt:\n      {\n        inspInspect(sizeof(int));\n        return;\n      }\n      case TClassEdit::EComplexType::kLong:\n      {\n        inspInspect(sizeof(long));\n        return;\n      }\n   }\n\n   static clang::PrintingPolicy\n      printPol(fInterpreter->getCI()->getLangOpts());\n   if (printPol.Indentation) {\n      // not yet initialized\n      printPol.Indentation = 0;\n      printPol.SuppressInitializers = true;\n   }\n\n   const char* clname = cl->GetName();\n   // Printf(\"Inspecting class %s\\n\", clname);\n\n   const clang::ASTContext& astContext = fInterpreter->getCI()->getASTContext();\n   const clang::Decl *scopeDecl = 0;\n   const clang::Type *recordType = 0;\n\n   if (cl->GetClassInfo()) {\n      TClingClassInfo * clingCI = (TClingClassInfo *)cl->GetClassInfo();\n      scopeDecl = clingCI->GetDecl();\n      recordType = clingCI->GetType();\n   } else {\n      const cling::LookupHelper& lh = fInterpreter->getLookupHelper();\n      // Diags will complain about private classes:\n      scopeDecl = lh.findScope(clname, cling::LookupHelper::NoDiagnostics,\n                               &recordType);\n   }\n   if (!scopeDecl) {\n      Error(\"InspectMembers\", \"Cannot find Decl for class %s\", clname);\n      return;\n   }\n   const clang::CXXRecordDecl* recordDecl\n     = llvm::dyn_cast<const clang::CXXRecordDecl>(scopeDecl);\n   if (!recordDecl) {\n      Error(\"InspectMembers\", \"Cannot find Decl for class %s is not a CXXRecordDecl.\", clname);\n      return;\n   }\n\n   {\n      // Force possible deserializations first. We need to have no pending\n      // Transaction when passing control flow to the inspector below (ROOT-7779).\n      cling::Interpreter::PushTransactionRAII deserRAII(GetInterpreterImpl());\n\n      astContext.getASTRecordLayout(recordDecl);\n\n      for (clang::RecordDecl::field_iterator iField = recordDecl->field_begin(),\n              eField = recordDecl->field_end(); iField != eField; ++iField) {}\n   }\n\n   const clang::ASTRecordLayout& recLayout\n      = astContext.getASTRecordLayout(recordDecl);\n\n   // TVirtualCollectionProxy *proxy = cl->GetCollectionProxy();\n   // if (proxy && ( proxy->GetProperties() & TVirtualCollectionProxy::kIsEmulated ) ) {\n   //    Error(\"InspectMembers\",\"The TClass for %s has an emulated proxy but we are looking at a compiled version of the collection!\\n\",\n   //          cl->GetName());\n   // }\n   if (cl->Size() != recLayout.getSize().getQuantity()) {\n      Error(\"InspectMembers\",\"TClass and cling disagree on the size of the class %s, respectively %d %lld\\n\",\n            cl->GetName(),cl->Size(),(Long64_t)recLayout.getSize().getQuantity());\n   }\n\n   unsigned iNField = 0;\n   // iterate over fields\n   // FieldDecls are non-static, else it would be a VarDecl.\n   for (clang::RecordDecl::field_iterator iField = recordDecl->field_begin(),\n        eField = recordDecl->field_end(); iField != eField;\n        ++iField, ++iNField) {\n\n\n      clang::QualType memberQT = iField->getType();\n      if (recordType) {\n         // if (we_need_to_do_the_subst_because_the_class_is_a_template_instance_of_double32_t)\n         memberQT = ROOT::TMetaUtils::ReSubstTemplateArg(memberQT, recordType);\n      }\n      memberQT = cling::utils::Transform::GetPartiallyDesugaredType(astContext, memberQT, fNormalizedCtxt->GetConfig(), false /* fully qualify */);\n      if (memberQT.isNull()) {\n         std::string memberName;\n         llvm::raw_string_ostream stream(memberName);\n         // Don't trigger fopen of the source file to count lines:\n         printPol.AnonymousTagLocations = false;\n         iField->getNameForDiagnostic(stream, printPol, true /*fqi*/);\n         stream.flush();\n         Error(\"InspectMembers\",\n               \"Cannot retrieve QualType for member %s while inspecting class %s\",\n               memberName.c_str(), clname);\n         continue; // skip member\n      }\n      const clang::Type* memType = memberQT.getTypePtr();\n      if (!memType) {\n         std::string memberName;\n         llvm::raw_string_ostream stream(memberName);\n         // Don't trigger fopen of the source file to count lines:\n         printPol.AnonymousTagLocations = false;\n         iField->getNameForDiagnostic(stream, printPol, true /*fqi*/);\n         stream.flush();\n         Error(\"InspectMembers\",\n               \"Cannot retrieve Type for member %s while inspecting class %s\",\n               memberName.c_str(), clname);\n         continue; // skip member\n      }\n\n      const clang::Type* memNonPtrType = memType;\n      Bool_t ispointer = false;\n      if (memNonPtrType->isPointerType()) {\n         ispointer = true;\n         clang::QualType ptrQT\n            = memNonPtrType->getAs<clang::PointerType>()->getPointeeType();\n         if (recordType) {\n            // if (we_need_to_do_the_subst_because_the_class_is_a_template_instance_of_double32_t)\n            ptrQT = ROOT::TMetaUtils::ReSubstTemplateArg(ptrQT, recordType);\n         }\n         ptrQT = cling::utils::Transform::GetPartiallyDesugaredType(astContext, ptrQT, fNormalizedCtxt->GetConfig(), false /* fully qualify */);\n         if (ptrQT.isNull()) {\n            std::string memberName;\n            llvm::raw_string_ostream stream(memberName);\n            // Don't trigger fopen of the source file to count lines:\n            printPol.AnonymousTagLocations = false;\n            iField->getNameForDiagnostic(stream, printPol, true /*fqi*/);\n            stream.flush();\n            Error(\"InspectMembers\",\n                  \"Cannot retrieve pointee Type for member %s while inspecting class %s\",\n                  memberName.c_str(), clname);\n            continue; // skip member\n         }\n         memNonPtrType = ptrQT.getTypePtr();\n      }\n\n      // assemble array size(s): \"[12][4][]\"\n      llvm::SmallString<8> arraySize;\n      const clang::ArrayType* arrType = memNonPtrType->getAsArrayTypeUnsafe();\n      unsigned arrLevel = 0;\n      bool haveErrorDueToArray = false;\n      while (arrType) {\n         ++arrLevel;\n         arraySize += '[';\n         const clang::ConstantArrayType* constArrType =\n         clang::dyn_cast<clang::ConstantArrayType>(arrType);\n         if (constArrType) {\n            constArrType->getSize().toStringUnsigned(arraySize);\n         }\n         arraySize += ']';\n         clang::QualType subArrQT = arrType->getElementType();\n         if (subArrQT.isNull()) {\n            std::string memberName;\n            llvm::raw_string_ostream stream(memberName);\n            // Don't trigger fopen of the source file to count lines:\n            printPol.AnonymousTagLocations = false;\n            iField->getNameForDiagnostic(stream, printPol, true /*fqi*/);\n            stream.flush();\n            Error(\"InspectMembers\",\n                  \"Cannot retrieve QualType for array level %d (i.e. element type of %s) for member %s while inspecting class %s\",\n                  arrLevel, subArrQT.getAsString(printPol).c_str(),\n                  memberName.c_str(), clname);\n            haveErrorDueToArray = true;\n            break;\n         }\n         arrType = subArrQT.getTypePtr()->getAsArrayTypeUnsafe();\n      }\n      if (haveErrorDueToArray) {\n         continue; // skip member\n      }\n\n      // construct member name\n      std::string fieldName;\n      if (memType->isPointerType()) {\n         fieldName = \"*\";\n      }\n\n      // Check if this field has a custom ioname, if not, just use the one of the decl\n      std::string ioname(iField->getName());\n      ROOT::TMetaUtils::ExtractAttrPropertyFromName(**iField,\"ioname\",ioname);\n      fieldName += ioname;\n      fieldName += arraySize;\n\n      // get member offset\n      // NOTE currently we do not support bitfield and do not support\n      // member that are not aligned on 'bit' boundaries.\n      clang::CharUnits offset(astContext.toCharUnitsFromBits(recLayout.getFieldOffset(iNField)));\n      ptrdiff_t fieldOffset = offset.getQuantity();\n\n      // R__insp.Inspect(R__cl, R__insp.GetParent(), \"fBits[2]\", fBits);\n      // R__insp.Inspect(R__cl, R__insp.GetParent(), \"fName\", &fName);\n      // R__insp.InspectMember(fName, \"fName.\");\n      // R__insp.Inspect(R__cl, R__insp.GetParent(), \"*fClass\", &fClass);\n\n      // If the class has a custom streamer and the type of the filed is a\n      // private enum, struct or class, skip it.\n      if (!insp.IsTreatingNonAccessibleTypes()){\n         auto iFiledQtype = iField->getType();\n         if (auto tagDecl = iFiledQtype->getAsTagDecl()){\n            auto declAccess = tagDecl->getAccess();\n            if (declAccess == AS_private || declAccess == AS_protected) {\n               continue;\n            }\n         }\n      }\n\n      insp.Inspect(const_cast<TClass*>(cl), insp.GetParent(), fieldName.c_str(), cobj + fieldOffset, isTransient);\n\n      if (!ispointer) {\n         const clang::CXXRecordDecl* fieldRecDecl = memNonPtrType->getAsCXXRecordDecl();\n         if (fieldRecDecl && !fieldRecDecl->isAnonymousStructOrUnion()) {\n            // nested objects get an extra call to InspectMember\n            // R__insp.InspectMember(\"FileStat_t\", (void*)&fFileStat, \"fFileStat.\", false);\n            std::string sFieldRecName;\n            if (!ROOT::TMetaUtils::ExtractAttrPropertyFromName(*fieldRecDecl,\"iotype\",sFieldRecName)){\n               ROOT::TMetaUtils::GetNormalizedName(sFieldRecName,\n                                                   clang::QualType(memNonPtrType,0),\n                                                   *fInterpreter,\n                                                   *fNormalizedCtxt);\n            }\n\n            TDataMember* mbr = cl->GetDataMember(ioname.c_str());\n            // if we can not find the member (which should not really happen),\n            // let's consider it transient.\n            Bool_t transient = isTransient || !mbr || !mbr->IsPersistent();\n\n            insp.InspectMember(sFieldRecName.c_str(), cobj + fieldOffset,\n                               (fieldName + '.').c_str(), transient);\n\n         }\n      }\n   } // loop over fields\n\n   // inspect bases\n   // TNamed::ShowMembers(R__insp);\n   unsigned iNBase = 0;\n   for (clang::CXXRecordDecl::base_class_const_iterator iBase\n        = recordDecl->bases_begin(), eBase = recordDecl->bases_end();\n        iBase != eBase; ++iBase, ++iNBase) {\n      clang::QualType baseQT = iBase->getType();\n      if (baseQT.isNull()) {\n         Error(\"InspectMembers\",\n               \"Cannot find QualType for base number %d while inspecting class %s\",\n               iNBase, clname);\n         continue;\n      }\n      const clang::CXXRecordDecl* baseDecl\n         = baseQT->getAsCXXRecordDecl();\n      if (!baseDecl) {\n         Error(\"InspectMembers\",\n               \"Cannot find CXXRecordDecl for base number %d while inspecting class %s\",\n               iNBase, clname);\n         continue;\n      }\n      TClass* baseCl=nullptr;\n      std::string sBaseName;\n      // Try with the DeclId\n      std::vector<TClass*> foundClasses;\n      TClass::GetClass(static_cast<DeclId_t>(baseDecl), foundClasses);\n      if (foundClasses.size()==1){\n         baseCl=foundClasses[0];\n      } else {\n         // Try with the normalised Name, as a fallback\n         if (!baseCl){\n            ROOT::TMetaUtils::GetNormalizedName(sBaseName,\n                                                baseQT,\n                                                *fInterpreter,\n                                                *fNormalizedCtxt);\n            baseCl = TClass::GetClass(sBaseName.c_str());\n         }\n      }\n\n      if (!baseCl){\n         std::string qualNameForDiag;\n         ROOT::TMetaUtils::GetQualifiedName(qualNameForDiag, *baseDecl);\n         Error(\"InspectMembers\",\n               \"Cannot find TClass for base class %s\", qualNameForDiag.c_str() );\n         continue;\n      }\n\n      int64_t baseOffset;\n      if (iBase->isVirtual()) {\n         if (insp.GetObjectValidity() == TMemberInspector::kNoObjectGiven) {\n            if (!isTransient) {\n               Error(\"InspectMembers\",\n                     \"Base %s of class %s is virtual but no object provided\",\n                     sBaseName.c_str(), clname);\n            }\n            baseOffset = TVirtualStreamerInfo::kNeedObjectForVirtualBaseClass;\n         } else {\n            // We have an object to determine the vbase offset.\n            TClingClassInfo* ci = (TClingClassInfo*)cl->GetClassInfo();\n            TClingClassInfo* baseCi = (TClingClassInfo*)baseCl->GetClassInfo();\n            if (ci && baseCi) {\n               baseOffset = ci->GetBaseOffset(baseCi, const_cast<void*>(obj),\n                                              true /*isDerivedObj*/);\n               if (baseOffset == -1) {\n                  Error(\"InspectMembers\",\n                        \"Error calculating offset of virtual base %s of class %s\",\n                        sBaseName.c_str(), clname);\n               }\n            } else {\n               Error(\"InspectMembers\",\n                     \"Cannot calculate offset of virtual base %s of class %s\",\n                     sBaseName.c_str(), clname);\n               continue;\n            }\n         }\n      } else {\n         baseOffset = recLayout.getBaseClassOffset(baseDecl).getQuantity();\n      }\n      // TOFIX: baseCl can be null here!\n      if (baseCl->IsLoaded()) {\n         // For loaded class, CallShowMember will (especially for TObject)\n         // call the virtual ShowMember rather than the class specific version\n         // resulting in an infinite recursion.\n         InspectMembers(insp, cobj + baseOffset, baseCl, isTransient);\n      } else {\n         baseCl->CallShowMembers(cobj + baseOffset,\n                                 insp, isTransient);\n      }\n   } // loop over bases\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Reset the interpreter internal state in case a previous action was not correctly\n/// terminated.\n\nvoid TCling::ClearFileBusy()\n{\n   // No-op there is not equivalent state (to be cleared) in Cling.\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Delete existing temporary values.\n\nvoid TCling::ClearStack()\n{\n   // No-op for cling due to cling::Value.\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Declare code to the interpreter, without any of the interpreter actions\n/// that could trigger a re-interpretation of the code. I.e. make cling\n/// behave like a compiler: no dynamic lookup, no input wrapping for\n/// subsequent execution, no automatic provision of declarations but just a\n/// plain #include.\n/// Returns true on success, false on failure.\n\nbool TCling::Declare(const char* code)\n{\n   R__LOCKGUARD_CLING(gInterpreterMutex);\n\n   SuspendAutoloadingRAII autoLoadOff(this);\n   SuspendAutoParsing autoParseRaii(this);\n\n   bool oldDynLookup = fInterpreter->isDynamicLookupEnabled();\n   fInterpreter->enableDynamicLookup(false);\n   bool oldRawInput = fInterpreter->isRawInputEnabled();\n   fInterpreter->enableRawInput(true);\n\n   Bool_t ret = LoadText(code);\n\n   fInterpreter->enableRawInput(oldRawInput);\n   fInterpreter->enableDynamicLookup(oldDynLookup);\n   return ret;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Enable the automatic loading of shared libraries when a class\n/// is used that is stored in a not yet loaded library. Uses the\n/// information stored in the class/library map (typically\n/// $ROOTSYS/etc/system.rootmap).\n\nvoid TCling::EnableAutoLoading()\n{\n   if (IsFromRootCling())\n      return;\n\n   // Read the rules before enabling the auto loading to not inadvertently\n   // load the libraries for the classes concerned even-though the user is\n   // *not* using them.\n   // Note this call must happen before the first call to LoadLibraryMap.\n   assert(GetRootMapFiles() == 0 && \"Must be called before LoadLibraryMap!\");\n   TClass::ReadRules(); // Read the default customization rules ...\n\n   LoadLibraryMap();\n   SetClassAutoloading(true);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// It calls a \"fantom\" method to synchronize user keyboard input\n/// and ROOT prompt line.\n\nvoid TCling::EndOfLineAction()\n{\n   ProcessLineSynch(fantomline);\n}\n\n// This static function is a hop of TCling::IsLibraryLoaded, which is taking a lock and calling\n// into this function. This is because we wanted to avoid a duplication in TCling::IsLoaded, which\n// was already taking a lock.\nstatic Bool_t s_IsLibraryLoaded(const char* libname, cling::Interpreter* fInterpreter)\n{\n   // Check shared library.\n   TString tLibName(libname);\n   if (gSystem->FindDynamicLibrary(tLibName, kTRUE))\n      return fInterpreter->getDynamicLibraryManager()->isLibraryLoaded(tLibName.Data());\n   return false;\n}\n\nBool_t TCling::IsLibraryLoaded(const char* libname) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return s_IsLibraryLoaded(libname, GetInterpreterImpl());\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return true if ROOT has cxxmodules pcm for a given library name.\n// FIXME: We need to be able to support lazy loading of pcm generated by ACLiC.\nBool_t TCling::HasPCMForLibrary(const char *libname) const\n{\n   llvm::StringRef ModuleName(libname);\n   ModuleName = llvm::sys::path::stem(ModuleName);\n   ModuleName.consume_front(\"lib\");\n\n   clang::ModuleMap &moduleMap = fInterpreter->getCI()->getPreprocessor().getHeaderSearchInfo().getModuleMap();\n   clang::Module *M = moduleMap.findModule(ModuleName);\n   return M && !M->IsMissingRequirement && M->getASTFile();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return true if the file has already been loaded by cint.\n/// We will try in this order:\n///   actual filename\n///   filename as a path relative to\n///            the include path\n///            the shared library path\n\nBool_t TCling::IsLoaded(const char* filename) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   //FIXME: if we use llvm::sys::fs::make_absolute all this can go away. See\n   // cling::DynamicLibraryManager.\n\n   std::string file_name = filename;\n   size_t at = std::string::npos;\n   while ((at = file_name.find(\"/./\")) != std::string::npos)\n       file_name.replace(at, 3, \"/\");\n\n   std::string filesStr = \"\";\n   llvm::raw_string_ostream filesOS(filesStr);\n   clang::SourceManager &SM = fInterpreter->getCI()->getSourceManager();\n   cling::ClangInternalState::printIncludedFiles(filesOS, SM);\n   filesOS.flush();\n\n   llvm::SmallVector<llvm::StringRef, 100> files;\n   llvm::StringRef(filesStr).split(files, \"\\n\");\n\n   std::set<std::string> fileMap;\n   // Fill fileMap; return early on exact match.\n   for (llvm::SmallVector<llvm::StringRef, 100>::const_iterator\n           iF = files.begin(), iE = files.end(); iF != iE; ++iF) {\n      if ((*iF) == file_name.c_str()) return kTRUE; // exact match\n      fileMap.insert(*iF);\n   }\n\n   if (fileMap.empty()) return kFALSE;\n\n   // Check MacroPath.\n   TString sFilename(file_name.c_str());\n   if (gSystem->FindFile(TROOT::GetMacroPath(), sFilename, kReadPermission)\n       && fileMap.count(sFilename.Data())) {\n      return kTRUE;\n   }\n\n   // Check IncludePath.\n   TString incPath = gSystem->GetIncludePath(); // of the form -Idir1  -Idir2 -Idir3\n   incPath.Append(\":\").Prepend(\" \"); // to match \" -I\" (note leading ' ')\n   incPath.ReplaceAll(\" -I\", \":\");      // of form :dir1 :dir2:dir3\n   while (incPath.Index(\" :\") != -1) {\n      incPath.ReplaceAll(\" :\", \":\");\n   }\n   incPath.Prepend(\".:\");\n   sFilename = file_name.c_str();\n   if (gSystem->FindFile(incPath, sFilename, kReadPermission)\n       && fileMap.count(sFilename.Data())) {\n      return kTRUE;\n   }\n\n   // Check shared library.\n   if (s_IsLibraryLoaded(file_name.c_str(), GetInterpreterImpl()))\n      return kTRUE;\n\n   //FIXME: We must use the cling::Interpreter::lookupFileOrLibrary iface.\n   const clang::DirectoryLookup *CurDir = 0;\n   clang::Preprocessor &PP = fInterpreter->getCI()->getPreprocessor();\n   clang::HeaderSearch &HS = PP.getHeaderSearchInfo();\n   const clang::FileEntry *FE = HS.LookupFile(file_name.c_str(),\n                                              clang::SourceLocation(),\n                                              /*isAngled*/ false,\n                                              /*FromDir*/ 0, CurDir,\n                                              clang::ArrayRef<std::pair<const clang::FileEntry *,\n                                                                        const clang::DirectoryEntry *>>(),\n                                              /*SearchPath*/ 0,\n                                              /*RelativePath*/ 0,\n                                              /*RequestingModule*/ 0,\n                                              /*SuggestedModule*/ 0,\n                                              /*IsMapped*/ 0,\n                                              /*SkipCache*/ false,\n                                              /*BuildSystemModule*/ false,\n                                              /*OpenFile*/ false,\n                                              /*CacheFail*/ false);\n   if (FE && FE->isValid()) {\n      // check in the source manager if the file is actually loaded\n      clang::SourceManager &SM = fInterpreter->getCI()->getSourceManager();\n      // this works only with header (and source) files...\n      clang::FileID FID = SM.translateFile(FE);\n      if (!FID.isInvalid() && FID.getHashValue() == 0)\n         return kFALSE;\n      else {\n         clang::SrcMgr::SLocEntry SLocE = SM.getSLocEntry(FID);\n         if (SLocE.isFile() && SLocE.getFile().getContentCache()->getRawBuffer() == 0)\n            return kFALSE;\n         if (!FID.isInvalid())\n            return kTRUE;\n      }\n      // ...then check shared library again, but with full path now\n      sFilename = FE->getName();\n      if (gSystem->FindDynamicLibrary(sFilename, kTRUE)\n          && fileMap.count(sFilename.Data())) {\n         return kTRUE;\n      }\n   }\n   return kFALSE;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::UpdateListOfLoadedSharedLibraries()\n{\n#if defined(R__WIN32) || defined(__CYGWIN__)\n   HMODULE hModules[1024];\n   void *hProcess;\n   unsigned long cbModules;\n   unsigned int i;\n   hProcess = (void *)::GetCurrentProcess();\n   ::EnumProcessModules(hProcess, hModules, sizeof(hModules), &cbModules);\n   // start at 1 to skip the executable itself\n   for (i = 1; i < (cbModules / sizeof(void *)); i++) {\n      static const int bufsize = 260;\n      wchar_t winname[bufsize];\n      char posixname[bufsize];\n      ::GetModuleFileNameExW(hProcess, hModules[i], winname, bufsize);\n#if defined(__CYGWIN__)\n      cygwin_conv_path(CCP_WIN_W_TO_POSIX, winname, posixname, bufsize);\n#else\n      std::wstring wpath = winname;\n      std::replace(wpath.begin(), wpath.end(), '\\\\', '/');\n      string path(wpath.begin(), wpath.end());\n      strncpy(posixname, path.c_str(), bufsize);\n#endif\n      if (!fSharedLibs.Contains(posixname)) {\n         RegisterLoadedSharedLibrary(posixname);\n      }\n   }\n#elif defined(R__MACOSX)\n   // fPrevLoadedDynLibInfo stores the *next* image index to look at\n   uint32_t imageIndex = (uint32_t) (size_t) fPrevLoadedDynLibInfo;\n\n   while (const mach_header* mh = _dyld_get_image_header(imageIndex)) {\n      // Skip non-dylibs\n      if (mh->filetype == MH_DYLIB) {\n         if (const char* imageName = _dyld_get_image_name(imageIndex)) {\n            RegisterLoadedSharedLibrary(imageName);\n         }\n      }\n\n      ++imageIndex;\n   }\n   fPrevLoadedDynLibInfo = (void*)(size_t)imageIndex;\n#elif defined(R__LINUX)\n   struct PointerNo4 {\n      void* fSkip[3];\n      void* fPtr;\n   };\n   struct LinkMap {\n      void* fAddr;\n      const char* fName;\n      void* fLd;\n      LinkMap* fNext;\n      LinkMap* fPrev;\n   };\n   if (!fPrevLoadedDynLibInfo || fPrevLoadedDynLibInfo == (void*)(size_t)-1) {\n      PointerNo4* procLinkMap = (PointerNo4*)dlopen(0,  RTLD_LAZY | RTLD_GLOBAL);\n      // 4th pointer of 4th pointer is the linkmap.\n      // See http://syprog.blogspot.fr/2011/12/listing-loaded-shared-objects-in-linux.html\n      LinkMap* linkMap = (LinkMap*) ((PointerNo4*)procLinkMap->fPtr)->fPtr;\n      RegisterLoadedSharedLibrary(linkMap->fName);\n      fPrevLoadedDynLibInfo = linkMap;\n      // reduce use count of link map structure:\n      dlclose(procLinkMap);\n   }\n\n   LinkMap* iDyLib = (LinkMap*)fPrevLoadedDynLibInfo;\n   while (iDyLib->fNext) {\n      iDyLib = iDyLib->fNext;\n      RegisterLoadedSharedLibrary(iDyLib->fName);\n   }\n   fPrevLoadedDynLibInfo = iDyLib;\n#else\n   Error(\"TCling::UpdateListOfLoadedSharedLibraries\",\n         \"Platform not supported!\");\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Register a new shared library name with the interpreter; add it to\n/// fSharedLibs.\n\nvoid TCling::RegisterLoadedSharedLibrary(const char* filename)\n{\n   // Ignore NULL filenames, aka \"the process\".\n   if (!filename) return;\n\n   // Tell the interpreter that this library is available; all libraries can be\n   // used to resolve symbols.\n   cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();\n   if (!DLM->isLibraryLoaded(filename)) {\n      DLM->loadLibrary(filename, true /*permanent*/);\n   }\n\n#if defined(R__MACOSX)\n   // Check that this is not a system library\n   auto lenFilename = strlen(filename);\n   if (!strncmp(filename, \"/usr/lib/system/\", 16)\n       || !strncmp(filename, \"/usr/lib/libc++\", 15)\n       || !strncmp(filename, \"/System/Library/Frameworks/\", 27)\n       || !strncmp(filename, \"/System/Library/PrivateFrameworks/\", 34)\n       || !strncmp(filename, \"/System/Library/CoreServices/\", 29)\n       || !strcmp(filename, \"cl_kernels\") // yepp, no directory\n       || strstr(filename, \"/usr/lib/libSystem\")\n       || strstr(filename, \"/usr/lib/libstdc++\")\n       || strstr(filename, \"/usr/lib/libicucore\")\n       || strstr(filename, \"/usr/lib/libbsm\")\n       || strstr(filename, \"/usr/lib/libobjc\")\n       || strstr(filename, \"/usr/lib/libresolv\")\n       || strstr(filename, \"/usr/lib/libauto\")\n       || strstr(filename, \"/usr/lib/libcups\")\n       || strstr(filename, \"/usr/lib/libDiagnosticMessagesClient\")\n       || strstr(filename, \"/usr/lib/liblangid\")\n       || strstr(filename, \"/usr/lib/libCRFSuite\")\n       || strstr(filename, \"/usr/lib/libpam\")\n       || strstr(filename, \"/usr/lib/libOpenScriptingUtil\")\n       || strstr(filename, \"/usr/lib/libextension\")\n       || strstr(filename, \"/usr/lib/libAudioToolboxUtility\")\n       // \"cannot link directly with dylib/framework, your binary is not an allowed client of\n       // /Applications/Xcode-beta.app/Contents/Developer/Platforms/MacOSX.platform/Developer/\n       // SDKs/MacOSX.sdk/usr/lib/libAudioToolboxUtility.tbd for architecture x86_64\n       || (lenFilename > 4 && !strcmp(filename + lenFilename - 4, \".tbd\")))\n      return;\n#elif defined(__CYGWIN__)\n   // Check that this is not a system library\n   static const int bufsize = 260;\n   char posixwindir[bufsize];\n   char *windir = getenv(\"WINDIR\");\n   if (windir)\n      cygwin_conv_path(CCP_WIN_A_TO_POSIX, windir, posixwindir, bufsize);\n   else\n      snprintf(posixwindir, sizeof(posixwindir), \"/Windows/\");\n   if (strstr(filename, posixwindir) ||\n       strstr(filename, \"/usr/bin/cyg\"))\n      return;\n#elif defined(R__WIN32)\n   if (strstr(filename, \"/Windows/\"))\n      return;\n#elif defined (R__LINUX)\n   if (strstr(filename, \"/ld-linux\")\n       || strstr(filename, \"linux-gnu/\")\n       || strstr(filename, \"/libstdc++.\")\n       || strstr(filename, \"/libgcc\")\n       || strstr(filename, \"/libc.\")\n       || strstr(filename, \"/libdl.\")\n       || strstr(filename, \"/libm.\"))\n      return;\n#endif\n   // Update string of available libraries.\n   if (!fSharedLibs.IsNull()) {\n      fSharedLibs.Append(\" \");\n   }\n   fSharedLibs.Append(filename);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Load a library file in cling's memory.\n/// if 'system' is true, the library is never unloaded.\n/// Return 0 on success, -1 on failure.\n\nInt_t TCling::Load(const char* filename, Bool_t system)\n{\n   assert(!IsFromRootCling() && \"Trying to load library from rootcling!\");\n\n   // Used to return 0 on success, 1 on duplicate, -1 on failure, -2 on \"fatal\".\n   R__LOCKGUARD_CLING(gInterpreterMutex);\n   cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();\n   std::string canonLib = DLM->lookupLibrary(filename);\n   cling::DynamicLibraryManager::LoadLibResult res\n      = cling::DynamicLibraryManager::kLoadLibNotFound;\n   if (!canonLib.empty()) {\n      if (system)\n         res = DLM->loadLibrary(filename, system);\n      else {\n         // For the non system libs, we'd like to be able to unload them.\n         // FIXME: Here we lose the information about kLoadLibAlreadyLoaded case.\n         cling::Interpreter::CompilationResult compRes;\n         HandleInterpreterException(GetMetaProcessorImpl(), Form(\".L %s\", canonLib.c_str()), compRes, /*cling::Value*/0);\n         if (compRes == cling::Interpreter::kSuccess)\n            res = cling::DynamicLibraryManager::kLoadLibSuccess;\n      }\n   }\n\n   if (res == cling::DynamicLibraryManager::kLoadLibSuccess) {\n      UpdateListOfLoadedSharedLibraries();\n   }\n   switch (res) {\n   case cling::DynamicLibraryManager::kLoadLibSuccess: return 0;\n   case cling::DynamicLibraryManager::kLoadLibAlreadyLoaded:  return 1;\n   default: break;\n   };\n   return -1;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Load a macro file in cling's memory.\n\nvoid TCling::LoadMacro(const char* filename, EErrorCode* error)\n{\n   ProcessLine(Form(\".L %s\", filename), error);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Let cling process a command line asynch.\n\nLong_t TCling::ProcessLineAsynch(const char* line, EErrorCode* error)\n{\n   return ProcessLine(line, error);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Let cling process a command line synchronously, i.e we are waiting\n/// it will be finished.\n\nLong_t TCling::ProcessLineSynch(const char* line, EErrorCode* error)\n{\n   R__LOCKGUARD_CLING(fLockProcessLine ? gInterpreterMutex : 0);\n   if (gApplication) {\n      if (gApplication->IsCmdThread()) {\n         return ProcessLine(line, error);\n      }\n      return 0;\n   }\n   return ProcessLine(line, error);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Directly execute an executable statement (e.g. \"func()\", \"3+5\", etc.\n/// however not declarations, like \"Int_t x;\").\n\nLong_t TCling::Calc(const char* line, EErrorCode* error)\n{\n#ifdef R__WIN32\n   // Test on ApplicationImp not being 0 is needed because only at end of\n   // TApplication ctor the IsLineProcessing flag is set to 0, so before\n   // we can not use it.\n   if (gApplication && gApplication->GetApplicationImp()) {\n      while (gROOT->IsLineProcessing() && !gApplication) {\n         Warning(\"Calc\", \"waiting for cling thread to free\");\n         gSystem->Sleep(500);\n      }\n      gROOT->SetLineIsProcessing();\n   }\n#endif // R__WIN32\n   R__LOCKGUARD_CLING(gInterpreterMutex);\n   if (error) {\n      *error = TInterpreter::kNoError;\n   }\n   cling::Value valRef;\n   cling::Interpreter::CompilationResult cr = fInterpreter->evaluate(line, valRef);\n   if (cr != cling::Interpreter::kSuccess) {\n      // Failure in compilation.\n      if (error) {\n         // Note: Yes these codes are weird.\n         *error = TInterpreter::kRecoverable;\n      }\n      return 0L;\n   }\n   if (!valRef.isValid()) {\n      // Failure at runtime.\n      if (error) {\n         // Note: Yes these codes are weird.\n         *error = TInterpreter::kDangerous;\n      }\n      return 0L;\n   }\n\n   if (valRef.isVoid()) {\n      return 0;\n   }\n\n   RegisterTemporary(valRef);\n#ifdef R__WIN32\n   if (gApplication && gApplication->GetApplicationImp()) {\n      gROOT->SetLineHasBeenProcessed();\n   }\n#endif // R__WIN32\n   return valRef.simplisticCastAs<long>();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Set a getline function to call when input is needed.\n\nvoid TCling::SetGetline(const char * (*getlineFunc)(const char* prompt),\n                                void (*histaddFunc)(const char* line))\n{\n   // If cling offers a replacement for G__pause(), it would need to\n   // also offer a way to customize at least the history recording.\n\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   Warning(\"SetGetline\",\"Cling should support the equivalent of SetGetlineFunc(getlineFunc, histaddFunc)\");\n#endif\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Helper function to increase the internal Cling count of transactions\n/// that change the AST.\n\nBool_t TCling::HandleNewTransaction(const cling::Transaction &T)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   if ((std::distance(T.decls_begin(), T.decls_end()) != 1)\n      || T.deserialized_decls_begin() != T.deserialized_decls_end()\n      || T.macros_begin() != T.macros_end()\n      || ((!T.getFirstDecl().isNull()) && ((*T.getFirstDecl().begin()) != T.getWrapperFD()))) {\n      fTransactionCount++;\n      return true;\n   }\n   return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Delete object from cling symbol table so it can not be used anymore.\n/// cling objects are always on the heap.\n\nvoid TCling::RecursiveRemove(TObject* obj)\n{\n   // NOTE: When replacing the mutex by a ReadWrite mutex, we **must**\n   // put in place the Read/Write part here.  Keeping the write lock\n   // here is 'catasptrophic' for scaling as it means that ALL calls\n   // to RecursiveRemove will take the write lock and performance\n   // of many threads trying to access the write lock at the same\n   // time is relatively bad.\n   R__READ_LOCKGUARD(ROOT::gCoreMutex);\n   // Note that fgSetOfSpecials is supposed to be updated by TClingCallbacks::tryFindROOTSpecialInternal\n   // (but isn't at the moment).\n   if (obj->IsOnHeap() && fgSetOfSpecials && !((std::set<TObject*>*)fgSetOfSpecials)->empty()) {\n      std::set<TObject*>::iterator iSpecial = ((std::set<TObject*>*)fgSetOfSpecials)->find(obj);\n      if (iSpecial != ((std::set<TObject*>*)fgSetOfSpecials)->end()) {\n         R__WRITE_LOCKGUARD(ROOT::gCoreMutex);\n         DeleteGlobal(obj);\n         ((std::set<TObject*>*)fgSetOfSpecials)->erase(iSpecial);\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Pressing Ctrl+C should forward here. In the case where we have had\n/// continuation requested we must reset it.\n\nvoid TCling::Reset()\n{\n   fMetaProcessor->cancelContinuation();\n   // Reset the Cling state to the state saved by the last call to\n   // TCling::SaveContext().\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   R__LOCKGUARD(gInterpreterMutex);\n   Warning(\"Reset\",\"Cling should support the equivalent of scratch_upto(&fDictPos)\");\n#endif\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Reset the Cling state to its initial state.\n\nvoid TCling::ResetAll()\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   R__LOCKGUARD(gInterpreterMutex);\n   Warning(\"ResetAll\",\"Cling should support the equivalent of complete reset (unload everything but the startup decls.\");\n#endif\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Reset in Cling the list of global variables to the state saved by the last\n/// call to TCling::SaveGlobalsContext().\n///\n/// Note: Right now, all we do is run the global destructors.\n\nvoid TCling::ResetGlobals()\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   // TODO:\n   // Here we should iterate over the transactions (N-3) and revert.\n   // N-3 because the first three internal to cling.\n\n   fInterpreter->runAndRemoveStaticDestructors();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Reset the Cling 'user' global objects/variables state to the state saved by the last\n/// call to TCling::SaveGlobalsContext().\n\nvoid TCling::ResetGlobalVar(void* obj)\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   R__LOCKGUARD(gInterpreterMutex);\n   Warning(\"ResetGlobalVar\",\"Cling should support the equivalent of resetglobalvar(obj)\");\n#endif\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Rewind Cling dictionary to the point where it was before executing\n/// the current macro. This function is typically called after SEGV or\n/// ctlr-C after doing a longjmp back to the prompt.\n\nvoid TCling::RewindDictionary()\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   R__LOCKGUARD(gInterpreterMutex);\n   Warning(\"RewindDictionary\",\"Cling should provide a way to revert transaction similar to rewinddictionary()\");\n#endif\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Delete obj from Cling symbol table so it cannot be accessed anymore.\n/// Returns 1 in case of success and 0 in case object was not in table.\n\nInt_t TCling::DeleteGlobal(void* obj)\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   R__LOCKGUARD(gInterpreterMutex);\n   Warning(\"DeleteGlobal\",\"Cling should provide the equivalent of deleteglobal(obj), see also DeleteVariable.\");\n#endif\n#endif\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Undeclare obj called name.\n/// Returns 1 in case of success, 0 for failure.\n\nInt_t TCling::DeleteVariable(const char* name)\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   Warning(\"DeleteVariable\",\"should do more that just reseting the value to zero\");\n#endif\n#endif\n\n   R__LOCKGUARD(gInterpreterMutex);\n   llvm::StringRef srName(name);\n   const char* unscopedName = name;\n   llvm::StringRef::size_type posScope = srName.rfind(\"::\");\n   const clang::DeclContext* declCtx = 0;\n   if (posScope != llvm::StringRef::npos) {\n      const cling::LookupHelper& lh = fInterpreter->getLookupHelper();\n      const clang::Decl* scopeDecl\n         = lh.findScope(srName.substr(0, posScope),\n                        cling::LookupHelper::WithDiagnostics);\n      if (!scopeDecl) {\n         Error(\"DeleteVariable\", \"Cannot find enclosing scope for variable %s\",\n               name);\n         return 0;\n      }\n      declCtx = llvm::dyn_cast<clang::DeclContext>(scopeDecl);\n      if (!declCtx) {\n         Error(\"DeleteVariable\",\n               \"Enclosing scope for variable %s is not a declaration context\",\n               name);\n         return 0;\n      }\n      unscopedName += posScope + 2;\n   }\n   // Could trigger deserialization of decls.\n   cling::Interpreter::PushTransactionRAII RAII(GetInterpreterImpl());\n   clang::NamedDecl* nVarDecl\n      = cling::utils::Lookup::Named(&fInterpreter->getSema(), unscopedName, declCtx);\n   if (!nVarDecl) {\n      Error(\"DeleteVariable\", \"Unknown variable %s\", name);\n      return 0;\n   }\n   clang::VarDecl* varDecl = llvm::dyn_cast<clang::VarDecl>(nVarDecl);\n   if (!varDecl) {\n      Error(\"DeleteVariable\", \"Entity %s is not a variable\", name);\n      return 0;\n   }\n\n   clang::QualType qType = varDecl->getType();\n   const clang::Type* type = qType->getUnqualifiedDesugaredType();\n   // Cannot set a reference's address to nullptr; the JIT can place it\n   // into read-only memory (ROOT-7100).\n   if (type->isPointerType()) {\n      int** ppInt = (int**)fInterpreter->getAddressOfGlobal(GlobalDecl(varDecl));\n      // set pointer to invalid.\n      if (ppInt) *ppInt = 0;\n   }\n   return 1;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Save the current Cling state.\n\nvoid TCling::SaveContext()\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   R__LOCKGUARD(gInterpreterMutex);\n   Warning(\"SaveContext\",\"Cling should provide a way to record a state watermark similar to store_dictposition(&fDictPos)\");\n#endif\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Save the current Cling state of global objects.\n\nvoid TCling::SaveGlobalsContext()\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   R__LOCKGUARD(gInterpreterMutex);\n   Warning(\"SaveGlobalsContext\",\"Cling should provide a way to record a watermark for the list of global variable similar to store_dictposition(&fDictPosGlobals)\");\n#endif\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// No op: see TClingCallbacks (used to update the list of globals)\n\nvoid TCling::UpdateListOfGlobals()\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// No op: see TClingCallbacks (used to update the list of global functions)\n\nvoid TCling::UpdateListOfGlobalFunctions()\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// No op: see TClingCallbacks (used to update the list of types)\n\nvoid TCling::UpdateListOfTypes()\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Check in what order the member of a tuple are layout.\nenum class ETupleOrdering {\n   kAscending,\n   kDescending,\n   kUnexpected\n};\n\nstruct AlternateTupleIntDoubleAsc\n{\n   Int_t    _0;\n   Double_t _1;\n};\n\nstruct AlternateTupleIntDoubleDes\n{\n   Double_t _1;\n   Int_t    _0;\n};\n\nstatic ETupleOrdering IsTupleAscending()\n{\n   std::tuple<int,double> value;\n   AlternateTupleIntDoubleAsc asc;\n   AlternateTupleIntDoubleDes des;\n\n   size_t offset0 = ((char*)&(std::get<0>(value))) - ((char*)&value);\n   size_t offset1 = ((char*)&(std::get<1>(value))) - ((char*)&value);\n\n   size_t ascOffset0 = ((char*)&(asc._0)) - ((char*)&asc);\n   size_t ascOffset1 = ((char*)&(asc._1)) - ((char*)&asc);\n\n   size_t desOffset0 = ((char*)&(des._0)) - ((char*)&des);\n   size_t desOffset1 = ((char*)&(des._1)) - ((char*)&des);\n\n   if (offset0 == ascOffset0 && offset1 == ascOffset1) {\n      return ETupleOrdering::kAscending;\n   } else if (offset0 == desOffset0 && offset1 == desOffset1) {\n      return ETupleOrdering::kDescending;\n   } else {\n      return ETupleOrdering::kUnexpected;\n   }\n}\n\nstatic std::string AlternateTuple(const char *classname, const cling::LookupHelper& lh)\n{\n   TClassEdit::TSplitType tupleContent(classname);\n   std::string alternateName = \"TEmulatedTuple\";\n   alternateName.append( classname + 5 );\n\n   std::string fullname = \"ROOT::Internal::\" + alternateName;\n   if (lh.findScope(fullname, cling::LookupHelper::NoDiagnostics,\n                    /*resultType*/nullptr, /* intantiateTemplate= */ false))\n      return fullname;\n\n   std::string guard_name;\n   ROOT::TMetaUtils::GetCppName(guard_name,alternateName.c_str());\n   std::ostringstream guard;\n   guard << \"ROOT_INTERNAL_TEmulated_\";\n   guard << guard_name;\n\n   std::ostringstream alternateTuple;\n   alternateTuple << \"#ifndef \" << guard.str() << \"\\n\";\n   alternateTuple << \"#define \" << guard.str() << \"\\n\";\n   alternateTuple << \"namespace ROOT { namespace Internal {\\n\";\n   alternateTuple << \"template <class... Types> struct TEmulatedTuple;\\n\";\n   alternateTuple << \"template <> struct \" << alternateName << \" {\\n\";\n\n   // This could also be a compile time choice ...\n   switch(IsTupleAscending()) {\n      case ETupleOrdering::kAscending: {\n         unsigned int nMember = 0;\n         auto iter = tupleContent.fElements.begin() + 1; // Skip the template name (tuple)\n         auto theEnd = tupleContent.fElements.end() - 1; // skip the 'stars'.\n         while (iter != theEnd) {\n            alternateTuple << \"   \" << *iter << \" _\" << nMember << \";\\n\";\n            ++iter;\n            ++nMember;\n         }\n         break;\n      }\n      case ETupleOrdering::kDescending: {\n         unsigned int nMember = tupleContent.fElements.size() - 3;\n         auto iter = tupleContent.fElements.rbegin() + 1; // Skip the template name (tuple)\n         auto theEnd = tupleContent.fElements.rend() - 1; // skip the 'stars'.\n         while (iter != theEnd) {\n            alternateTuple << \"   \" << *iter << \" _\" << nMember << \";\\n\";\n            ++iter;\n            --nMember;\n         }\n         break;\n      }\n      case ETupleOrdering::kUnexpected: {\n         Fatal(\"TCling::SetClassInfo::AlternateTuple\",\n               \"Layout of std::tuple on this platform is unexpected.\");\n         break;\n      }\n   }\n\n   alternateTuple << \"};\\n\";\n   alternateTuple << \"}}\\n\";\n   alternateTuple << \"#endif\\n\";\n   if (!gCling->Declare(alternateTuple.str().c_str())) {\n      Error(\"Load\",\"Could not declare %s\",alternateName.c_str());\n      return \"\";\n   }\n   alternateName = \"ROOT::Internal::\" + alternateName;\n   return alternateName;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Set pointer to the TClingClassInfo in TClass.\n/// If 'reload' is true, (attempt to) generate a new ClassInfo even if we\n/// already have one.\n\nvoid TCling::SetClassInfo(TClass* cl, Bool_t reload)\n{\n   // We are shutting down, there is no point in reloading, it only triggers\n   // redundant deserializations.\n   if (fIsShuttingDown) {\n      // Remove the decl_id from the DeclIdToTClass map\n      if (cl->fClassInfo) {\n         R__LOCKGUARD(gInterpreterMutex);\n         TClingClassInfo* TClinginfo = (TClingClassInfo*) cl->fClassInfo;\n         // Test again as another thread may have set fClassInfo to nullptr.\n         if (TClinginfo) {\n            TClass::RemoveClassDeclId(TClinginfo->GetDeclId());\n         }\n         delete TClinginfo;\n         cl->fClassInfo = nullptr;\n      }\n      return;\n   }\n\n   R__LOCKGUARD(gInterpreterMutex);\n   if (cl->fClassInfo && !reload) {\n      return;\n   }\n   //Remove the decl_id from the DeclIdToTClass map\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cl->fClassInfo;\n   if (TClinginfo) {\n      TClass::RemoveClassDeclId(TClinginfo->GetDeclId());\n   }\n   delete TClinginfo;\n   cl->fClassInfo = 0;\n   std::string name(cl->GetName());\n\n   // Handle the special case of 'tuple' where we ignore the real implementation\n   // details and just overlay a 'simpler'/'simplistic' version that is easy\n   // for the I/O to understand and handle.\n   if (strncmp(cl->GetName(),\"tuple<\",strlen(\"tuple<\"))==0) {\n\n      name = AlternateTuple(cl->GetName(), fInterpreter->getLookupHelper());\n\n   }\n\n   TClingClassInfo* info = new TClingClassInfo(GetInterpreterImpl(), name.c_str());\n   if (!info->IsValid()) {\n      if (cl->fState != TClass::kHasTClassInit) {\n         if (cl->fStreamerInfo->GetEntries() != 0) {\n            cl->fState = TClass::kEmulated;\n         } else {\n            cl->fState = TClass::kForwardDeclared;\n         }\n      }\n      delete info;\n      return;\n   }\n   cl->fClassInfo = (ClassInfo_t*)info; // Note: We are transferring ownership here.\n   // In case a class contains an external enum, the enum will be seen as a\n   // class. We must detect this special case and make the class a Zombie.\n   // Here we assume that a class has at least one method.\n   // We can NOT call TClass::Property from here, because this method\n   // assumes that the TClass is well formed to do a lot of information\n   // caching. The method SetClassInfo (i.e. here) is usually called during\n   // the building phase of the TClass, hence it is NOT well formed yet.\n   Bool_t zombieCandidate = kFALSE;\n   if (\n      info->IsValid() &&\n      !(info->Property() & (kIsClass | kIsStruct | kIsNamespace))\n   ) {\n      zombieCandidate = kTRUE;\n   }\n   if (!info->IsLoaded()) {\n      if (info->Property() & (kIsNamespace)) {\n         // Namespaces can have info but no corresponding CINT dictionary\n         // because they are auto-created if one of their contained\n         // classes has a dictionary.\n         zombieCandidate = kTRUE;\n      }\n      // this happens when no dictionary is available\n      delete info;\n      cl->fClassInfo = 0;\n   }\n   if (zombieCandidate && !cl->GetCollectionType()) {\n      cl->MakeZombie();\n   }\n   // If we reach here, the info was valid (See early returns).\n   if (cl->fState != TClass::kHasTClassInit) {\n      if (cl->fClassInfo) {\n         cl->fState = TClass::kInterpreted;\n         cl->ResetBit(TClass::kIsEmulation);\n      } else {\n//         if (TClassEdit::IsSTLCont(cl->GetName()) {\n//            There will be an emulated collection proxy, is that the same?\n//            cl->fState = TClass::kEmulated;\n//         } else {\n         if (cl->fStreamerInfo->GetEntries() != 0) {\n            cl->fState = TClass::kEmulated;\n         } else {\n            cl->fState = TClass::kForwardDeclared;\n         }\n//         }\n      }\n   }\n   if (cl->fClassInfo) {\n      TClass::AddClassToDeclIdMap(((TClingClassInfo*)cl->fClassInfo)->GetDeclId(), cl);\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Checks if an entity with the specified name is defined in Cling.\n/// Returns kUnknown if the entity is not defined.\n/// Returns kWithClassDefInline if the entity exists and has a ClassDefInline\n/// Returns kKnown if the entity is defined.\n///\n/// By default, structs, namespaces, classes, enums and unions are looked for.\n/// If the flag isClassOrNamespaceOnly is true, classes, structs and\n/// namespaces only are considered. I.e. if the name is an enum or a union,\n/// the returned value is false.\n///\n/// In the case where the class is not loaded and belongs to a namespace\n/// or is nested, looking for the full class name is outputting a lots of\n/// (expected) error messages.  Currently the only way to avoid this is to\n/// specifically check that each level of nesting is already loaded.\n/// In case of templates the idea is that everything between the outer\n/// '<' and '>' has to be skipped, e.g.: aap<pippo<noot>::klaas>::a_class\n\nTInterpreter::ECheckClassInfo\nTCling::CheckClassInfo(const char *name, Bool_t autoload, Bool_t isClassOrNamespaceOnly /* = kFALSE*/)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   static const char *anonEnum = \"anonymous enum \";\n   static const int cmplen = strlen(anonEnum);\n\n   if (fIsShuttingDown || 0 == strncmp(name, anonEnum, cmplen)) {\n      return kUnknown;\n   }\n\n   // Do not turn on the autoloading if it is globally off.\n   autoload = autoload && IsClassAutoloadingEnabled();\n\n   // Avoid the double search below in case the name is a fundamental type\n   // or typedef to a fundamental type.\n   THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );\n   TDataType *fundType = (TDataType *)typeTable->THashTable::FindObject( name );\n\n   if (fundType && fundType->GetType() < TVirtualStreamerInfo::kObject\n       && fundType->GetType() > 0) {\n      // Fundamental type, no a class.\n      return kUnknown;\n   }\n\n   // Migrated from within TClass::GetClass\n   // If we want to know if a class or a namespace with this name exists in the\n   // interpreter and this is an enum in the type system, before or after loading\n   // according to the autoload function argument, return kUnknown.\n   if (isClassOrNamespaceOnly && TEnum::GetEnum(name, autoload ? TEnum::kAutoload : TEnum::kNone))\n      return kUnknown;\n\n   const char *classname = name;\n\n   int storeAutoload = SetClassAutoloading(autoload);\n\n   // First we want to check whether the decl exist, but _without_\n   // generating any template instantiation. However, the lookup\n   // still will create a forward declaration of the class template instance\n   // if it exist.  In this case, the return value of findScope will still\n   // be zero but the type will be initialized.\n   // Note in the corresponding code in ROOT 5, CINT was not instantiating\n   // this forward declaration.\n   const cling::LookupHelper& lh = fInterpreter->getLookupHelper();\n   const clang::Type *type = 0;\n   const clang::Decl *decl\n      = lh.findScope(classname,\n                     gDebug > 5 ? cling::LookupHelper::WithDiagnostics\n                     : cling::LookupHelper::NoDiagnostics,\n                     &type, /* intantiateTemplate= */ false );\n   if (!decl) {\n      std::string buf = TClassEdit::InsertStd(classname);\n      decl = lh.findScope(buf,\n                          gDebug > 5 ? cling::LookupHelper::WithDiagnostics\n                          : cling::LookupHelper::NoDiagnostics,\n                          &type,false);\n   }\n\n   if (type) {\n      // If decl==0 and the type is valid, then we have a forward declaration.\n      if (!decl) {\n         // If we have a forward declaration for a class template instantiation,\n         // we want to ignore it if it was produced/induced by the call to\n         // findScope, however we can not distinguish those from the\n         // instantiation induce by 'soft' use (and thus also induce by the\n         // same underlying code paths)\n         // ['soft' use = use not requiring a complete definition]\n         // So to reduce the amount of disruption to the existing code we\n         // would just ignore those for STL collection, for which we really\n         // need to have the compiled collection proxy (and thus the TClass\n         // bootstrap).\n         clang::ClassTemplateSpecializationDecl *tmpltDecl =\n            llvm::dyn_cast_or_null<clang::ClassTemplateSpecializationDecl>\n               (type->getAsCXXRecordDecl());\n         if (tmpltDecl && !tmpltDecl->getPointOfInstantiation().isValid()) {\n            // Since the point of instantiation is invalid, we 'guess' that\n            // the 'instantiation' of the forwarded type appended in\n            // findscope.\n            if (ROOT::TMetaUtils::IsSTLCont(*tmpltDecl)) {\n               // For STL Collection we return kUnknown.\n               SetClassAutoloading(storeAutoload);\n               return kUnknown;\n            }\n         }\n      }\n      TClingClassInfo tci(GetInterpreterImpl(), *type);\n      if (!tci.IsValid()) {\n         SetClassAutoloading(storeAutoload);\n         return kUnknown;\n      }\n      auto propertiesMask = isClassOrNamespaceOnly ? kIsClass | kIsStruct | kIsNamespace :\n                                                     kIsClass | kIsStruct | kIsNamespace | kIsEnum | kIsUnion;\n\n      if (tci.Property() & propertiesMask) {\n         bool hasClassDefInline = false;\n         if (isClassOrNamespaceOnly) {\n            // We do not need to check for ClassDefInline when this is called from\n            // TClass::Init, we only do it for the call from TClass::GetClass.\n            auto hasDictionary = tci.GetMethod(\"Dictionary\", \"\", false, 0, ROOT::kExactMatch);\n            auto implLineFunc = tci.GetMethod(\"ImplFileLine\", \"\", false, 0, ROOT::kExactMatch);\n\n            if (hasDictionary.IsValid() && implLineFunc.IsValid()) {\n               int lineNumber = 0;\n               bool success = false;\n               std::tie(success, lineNumber) =\n                  ROOT::TMetaUtils::GetTrivialIntegralReturnValue(implLineFunc.GetMethodDecl(), *fInterpreter);\n               hasClassDefInline = success && (lineNumber == -1);\n            }\n         }\n\n         // fprintf(stderr,\"CheckClassInfo: %s had dict=%d  inline=%d\\n\",name,hasDictionary.IsValid()\n         // , hasClassDefInline);\n\n         // We are now sure that the entry is not in fact an autoload entry.\n         SetClassAutoloading(storeAutoload);\n         if (hasClassDefInline)\n            return kWithClassDefInline;\n         else\n            return kKnown;\n      } else {\n         // We are now sure that the entry is not in fact an autoload entry.\n         SetClassAutoloading(storeAutoload);\n         return kUnknown;\n      }\n   }\n\n   SetClassAutoloading(storeAutoload);\n   if (decl)\n      return kKnown;\n   else\n      return kUnknown;\n\n   // Setting up iterator part of TClingTypedefInfo is too slow.\n   // Copy the lookup code instead:\n   /*\n   TClingTypedefInfo t(fInterpreter, name);\n   if (t.IsValid() && !(t.Property() & kIsFundamental)) {\n      delete[] classname;\n      SetClassAutoloading(storeAutoload);\n      return kTRUE;\n   }\n   */\n\n//   const clang::Decl *decl = lh.findScope(name);\n//   if (!decl) {\n//      std::string buf = TClassEdit::InsertStd(name);\n//      decl = lh.findScope(buf);\n//   }\n\n//   SetClassAutoloading(storeAutoload);\n//   return (decl);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return true if there is a class template by the given name ...\n\nBool_t TCling::CheckClassTemplate(const char *name)\n{\n   const cling::LookupHelper& lh = fInterpreter->getLookupHelper();\n   const clang::Decl *decl\n      = lh.findClassTemplate(name,\n                             gDebug > 5 ? cling::LookupHelper::WithDiagnostics\n                             : cling::LookupHelper::NoDiagnostics);\n   if (!decl) {\n      std::string strname = \"std::\";\n      strname += name;\n      decl = lh.findClassTemplate(strname,\n                                  gDebug > 5 ? cling::LookupHelper::WithDiagnostics\n                                  : cling::LookupHelper::NoDiagnostics);\n   }\n   return 0 != decl;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create list of pointers to base class(es) for TClass cl.\n\nvoid TCling::CreateListOfBaseClasses(TClass *cl) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   if (cl->fBase) {\n      return;\n   }\n   TClingClassInfo *tci = (TClingClassInfo *)cl->GetClassInfo();\n   if (!tci) return;\n   TClingBaseClassInfo t(GetInterpreterImpl(), tci);\n   TList *listOfBase = new TList;\n   while (t.Next()) {\n      // if name cannot be obtained no use to put in list\n      if (t.IsValid() && t.Name()) {\n         TClingBaseClassInfo *a = new TClingBaseClassInfo(t);\n         listOfBase->Add(new TBaseClass((BaseClassInfo_t *)a, cl));\n      }\n   }\n   // Now that is complete, publish it.\n   cl->fBase = listOfBase;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create list of pointers to enums for TClass cl.\n\nvoid TCling::LoadEnums(TListOfEnums& enumList) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   const Decl * D;\n   TClass* cl = enumList.GetClass();\n   if (cl) {\n      D = ((TClingClassInfo*)cl->GetClassInfo())->GetDecl();\n   }\n   else {\n      D = fInterpreter->getCI()->getASTContext().getTranslationUnitDecl();\n   }\n   // Iterate on the decl of the class and get the enums.\n   if (const clang::DeclContext* DC = dyn_cast<clang::DeclContext>(D)) {\n      cling::Interpreter::PushTransactionRAII deserRAII(GetInterpreterImpl());\n      // Collect all contexts of the namespace.\n      llvm::SmallVector< DeclContext *, 4> allDeclContexts;\n      const_cast< clang::DeclContext *>(DC)->collectAllContexts(allDeclContexts);\n      for (llvm::SmallVector<DeclContext*, 4>::iterator declIter = allDeclContexts.begin(), declEnd = allDeclContexts.end();\n           declIter != declEnd; ++declIter) {\n         // Iterate on all decls for each context.\n         for (clang::DeclContext::decl_iterator DI = (*declIter)->decls_begin(),\n              DE = (*declIter)->decls_end(); DI != DE; ++DI) {\n            if (const clang::EnumDecl* ED = dyn_cast<clang::EnumDecl>(*DI)) {\n               // Get name of the enum type.\n               std::string buf;\n               PrintingPolicy Policy(ED->getASTContext().getPrintingPolicy());\n               llvm::raw_string_ostream stream(buf);\n               // Don't trigger fopen of the source file to count lines:\n               Policy.AnonymousTagLocations = false;\n               ED->getNameForDiagnostic(stream, Policy, /*Qualified=*/false);\n               stream.flush();\n               // If the enum is unnamed we do not add it to the list of enums i.e unusable.\n               if (!buf.empty()) {\n                  const char* name = buf.c_str();\n                  // Add the enum to the list of loaded enums.\n                  enumList.Get(ED, name);\n               }\n            }\n         }\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create list of pointers to function templates for TClass cl.\n\nvoid TCling::LoadFunctionTemplates(TClass* cl) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   const Decl * D;\n   TListOfFunctionTemplates* funcTempList;\n   if (cl) {\n      D = ((TClingClassInfo*)cl->GetClassInfo())->GetDecl();\n      funcTempList = (TListOfFunctionTemplates*)cl->GetListOfFunctionTemplates(false);\n   }\n   else {\n      D = fInterpreter->getCI()->getASTContext().getTranslationUnitDecl();\n      funcTempList = (TListOfFunctionTemplates*)gROOT->GetListOfFunctionTemplates();\n   }\n   // Iterate on the decl of the class and get the enums.\n   if (const clang::DeclContext* DC = dyn_cast<clang::DeclContext>(D)) {\n      cling::Interpreter::PushTransactionRAII deserRAII(GetInterpreterImpl());\n      // Collect all contexts of the namespace.\n      llvm::SmallVector< DeclContext *, 4> allDeclContexts;\n      const_cast< clang::DeclContext *>(DC)->collectAllContexts(allDeclContexts);\n      for (llvm::SmallVector<DeclContext*, 4>::iterator declIter = allDeclContexts.begin(),\n           declEnd = allDeclContexts.end(); declIter != declEnd; ++declIter) {\n         // Iterate on all decls for each context.\n         for (clang::DeclContext::decl_iterator DI = (*declIter)->decls_begin(),\n              DE = (*declIter)->decls_end(); DI != DE; ++DI) {\n            if (const clang::FunctionTemplateDecl* FTD = dyn_cast<clang::FunctionTemplateDecl>(*DI)) {\n                  funcTempList->Get(FTD);\n            }\n         }\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the scopes representing using declarations of namespace\n\nstd::vector<std::string> TCling::GetUsingNamespaces(ClassInfo_t *cl) const\n{\n   TClingClassInfo *ci = (TClingClassInfo*)cl;\n   return ci->GetUsingNamespaces();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create list of pointers to data members for TClass cl.\n/// This is now a nop.  The creation and updating is handled in\n/// TListOfDataMembers.\n\nvoid TCling::CreateListOfDataMembers(TClass* cl) const\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create list of pointers to methods for TClass cl.\n/// This is now a nop.  The creation and updating is handled in\n/// TListOfFunctions.\n\nvoid TCling::CreateListOfMethods(TClass* cl) const\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Update the list of pointers to method for TClass cl\n/// This is now a nop.  The creation and updating is handled in\n/// TListOfFunctions.\n\nvoid TCling::UpdateListOfMethods(TClass* cl) const\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Update the list of pointers to data members for TClass cl\n/// This is now a nop.  The creation and updating is handled in\n/// TListOfDataMembers.\n\nvoid TCling::UpdateListOfDataMembers(TClass* cl) const\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create list of pointers to method arguments for TMethod m.\n\nvoid TCling::CreateListOfMethodArgs(TFunction* m) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   if (m->fMethodArgs) {\n      return;\n   }\n   TList *arglist = new TList;\n   TClingMethodArgInfo t(GetInterpreterImpl(), (TClingMethodInfo*)m->fInfo);\n   while (t.Next()) {\n      if (t.IsValid()) {\n         TClingMethodArgInfo* a = new TClingMethodArgInfo(t);\n         arglist->Add(new TMethodArg((MethodArgInfo_t*)a, m));\n      }\n   }\n   m->fMethodArgs = arglist;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Generate a TClass for the given class.\n/// Since the caller has already check the ClassInfo, let it give use the\n/// result (via the value of emulation) rather than recalculate it.\n\nTClass *TCling::GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent /* = kFALSE */)\n{\n// For now the following line would lead to the (unwanted) instantiation\n// of class template.  This could/would need to be resurrected only if\n// we re-introduce so sort of automatic instantiation.   However this would\n// have to include carefull look at the template parameter to avoid\n// creating instance we can not really use (if the parameter are only forward\n// declaration or do not have all the necessary interfaces).\n\n   //   TClingClassInfo tci(fInterpreter, classname);\n   //   if (1 || !tci.IsValid()) {\n\n   Version_t version = 1;\n   if (TClassEdit::IsSTLCont(classname)) {\n      version = TClass::GetClass(\"TVirtualStreamerInfo\")->GetClassVersion();\n   }\n   TClass *cl = new TClass(classname, version, silent);\n   if (emulation) {\n      cl->SetBit(TClass::kIsEmulation);\n   } else {\n      // Set the class version if the class is versioned.\n      // Note that we cannot just call CLASS::Class_Version() as we might not have\n      // an execution engine (when invoked from rootcling).\n\n      // Do not call cl->GetClassVersion(), it has side effects!\n      Version_t oldvers = cl->fClassVersion;\n      if (oldvers == version && cl->GetClassInfo()) {\n         // We have a version and it might need an update.\n         Version_t newvers = oldvers;\n         TClingClassInfo* cli = (TClingClassInfo*)cl->GetClassInfo();\n         if (llvm::isa<clang::NamespaceDecl>(cli->GetDecl())) {\n            // Namespaces don't have class versions.\n            return cl;\n         }\n         TClingMethodInfo mi = cli->GetMethod(\"Class_Version\", \"\", 0 /*poffset*/,\n                                              ROOT::kExactMatch,\n                                              TClingClassInfo::kInThisScope);\n         if (!mi.IsValid()) {\n            if (cl->TestBit(TClass::kIsTObject)) {\n               Error(\"GenerateTClass\",\n                     \"Cannot find %s::Class_Version()! Class version might be wrong.\",\n                     cl->GetName());\n            }\n            return cl;\n         }\n         newvers = ROOT::TMetaUtils::GetClassVersion(llvm::dyn_cast<clang::RecordDecl>(cli->GetDecl()),\n                                                     *fInterpreter);\n         if (newvers == -1) {\n            // Didn't manage to determine the class version from the AST.\n            // Use runtime instead.\n            if ((mi.Property() & kIsStatic)\n                && !fInterpreter->isInSyntaxOnlyMode()) {\n               // This better be a static function.\n               TClingCallFunc callfunc(GetInterpreterImpl(), *fNormalizedCtxt);\n               callfunc.SetFunc(&mi);\n               newvers = callfunc.ExecInt(0);\n            } else {\n               Error(\"GenerateTClass\",\n                     \"Cannot invoke %s::Class_Version()! Class version might be wrong.\",\n                     cl->GetName());\n            }\n         }\n         if (newvers != oldvers) {\n            cl->fClassVersion = newvers;\n            cl->fStreamerInfo->Expand(newvers + 2 + 10);\n         }\n      }\n   }\n\n   return cl;\n\n//   } else {\n//      return GenerateTClass(&tci,silent);\n//   }\n}\n\n#if 0\n////////////////////////////////////////////////////////////////////////////////\n\nstatic void GenerateTClass_GatherInnerIncludes(cling::Interpreter *interp, TString &includes,TClingClassInfo *info)\n{\n   includes += info->FileName();\n\n   const clang::ClassTemplateSpecializationDecl *templateCl\n      = llvm::dyn_cast<clang::ClassTemplateSpecializationDecl>(info->GetDecl());\n   if (templateCl) {\n      for(unsigned int i=0; i <  templateCl->getTemplateArgs().size(); ++i) {\n          const clang::TemplateArgument &arg( templateCl->getTemplateArgs().get(i) );\n          if (arg.getKind() == clang::TemplateArgument::Type) {\n             const clang::Type *uType = ROOT::TMetaUtils::GetUnderlyingType( arg.getAsType() );\n\n            if (!uType->isFundamentalType() && !uType->isEnumeralType()) {\n               // We really need a header file.\n               const clang::CXXRecordDecl *argdecl = uType->getAsCXXRecordDecl();\n               if (argdecl) {\n                  includes += \";\";\n                  TClingClassInfo subinfo(interp,*(argdecl->getASTContext().getRecordType(argdecl).getTypePtr()));\n                  GenerateTClass_GatherInnerIncludes(interp, includes, &subinfo);\n               } else {\n                  std::string Result;\n                  llvm::raw_string_ostream OS(Result);\n                  arg.print(argdecl->getASTContext().getPrintingPolicy(),OS);\n                  Warning(\"TCling::GenerateTClass\",\"Missing header file for %s\",OS.str().c_str());\n               }\n            }\n          }\n      }\n   }\n}\n#endif\n\n////////////////////////////////////////////////////////////////////////////////\n/// Generate a TClass for the given class.\n\nTClass *TCling::GenerateTClass(ClassInfo_t *classinfo, Bool_t silent /* = kFALSE */)\n{\n   TClingClassInfo *info = (TClingClassInfo*)classinfo;\n   if (!info || !info->IsValid()) {\n      Fatal(\"GenerateTClass\",\"Requires a valid ClassInfo object\");\n      return 0;\n   }\n   // We are in the case where we have AST nodes for this class.\n   TClass *cl = 0;\n   std::string classname;\n   info->FullName(classname,*fNormalizedCtxt); // Could we use Name()?\n   if (TClassEdit::IsSTLCont(classname)) {\n#if 0\n      Info(\"GenerateTClass\",\"Will (try to) generate the compiled TClass for %s.\",classname.c_str());\n      // We need to build up the list of required headers, by\n      // looking at each template arguments.\n      TString includes;\n      GenerateTClass_GatherInnerIncludes(fInterpreter,includes,info);\n\n      if (0 == GenerateDictionary(classname.c_str(),includes)) {\n         // 0 means success.\n         cl = TClass::LoadClass(classnam.c_str(), silent);\n         if (cl == 0) {\n            Error(\"GenerateTClass\",\"Even though the dictionary generation for %s seemed successful we can't find the TClass bootstrap!\",classname.c_str());\n         }\n      }\n#endif\n      if (cl == 0) {\n         int version = TClass::GetClass(\"TVirtualStreamerInfo\")->GetClassVersion();\n         cl = new TClass(classinfo, version, 0, 0, -1, -1, silent);\n         cl->SetBit(TClass::kIsEmulation);\n      }\n   } else {\n      // For regular class, just create a TClass on the fly ...\n      // Not quite useful yet, but that what CINT used to do anyway.\n      cl = new TClass(classinfo, 1, 0, 0, -1, -1, silent);\n   }\n   // Add the new TClass to the map of declid and TClass*.\n   if (cl) {\n      TClass::AddClassToDeclIdMap(((TClingClassInfo*)classinfo)->GetDeclId(), cl);\n   }\n   return cl;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Generate the dictionary for the C++ classes listed in the first\n/// argument (in a semi-colon separated list).\n/// 'includes' contains a semi-colon separated list of file to\n/// #include in the dictionary.\n/// For example:\n/// ~~~ {.cpp}\n///    gInterpreter->GenerateDictionary(\"vector<vector<float> >;list<vector<float> >\",\"list;vector\");\n/// ~~~\n/// or\n/// ~~~ {.cpp}\n///    gInterpreter->GenerateDictionary(\"myclass\",\"myclass.h;myhelper.h\");\n/// ~~~\n\nInt_t TCling::GenerateDictionary(const char* classes, const char* includes /* = \"\" */, const char* /* options  = 0 */)\n{\n   if (classes == 0 || classes[0] == 0) {\n      Error(\"TCling::GenerateDictionary\", \"Cannot generate dictionary without passing classes.\");\n      return 0;\n   }\n   // Split the input list\n   std::vector<std::string> listClasses;\n   for (\n      const char* current = classes, *prev = classes;\n      *current != 0;\n      ++current\n   ) {\n      if (*current == ';') {\n         listClasses.push_back(std::string(prev, current - prev));\n         prev = current + 1;\n      }\n      else if (*(current + 1) == 0) {\n         listClasses.push_back(std::string(prev, current + 1 - prev));\n         prev = current + 1;\n      }\n   }\n   std::vector<std::string> listIncludes;\n   if (!includes)\n      includes = \"\";\n   for (\n      const char* current = includes, *prev = includes;\n      *current != 0;\n      ++current\n   ) {\n      if (*current == ';') {\n         listIncludes.push_back(std::string(prev, current - prev));\n         prev = current + 1;\n      }\n      else if (*(current + 1) == 0) {\n         listIncludes.push_back(std::string(prev, current + 1 - prev));\n         prev = current + 1;\n      }\n   }\n   // Generate the temporary dictionary file\n   return !TCling_GenerateDictionary(listClasses, listIncludes,\n      std::vector<std::string>(), std::vector<std::string>());\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to cling Decl of global/static variable that is located\n/// at the address given by addr.\n\nTInterpreter::DeclId_t TCling::GetDataMember(ClassInfo_t *opaque_cl, const char *name) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   DeclId_t d;\n   TClingClassInfo *cl = (TClingClassInfo*)opaque_cl;\n\n   if (cl) {\n      d = cl->GetDataMember(name);\n      // We check if the decl of the data member has an annotation which indicates\n      // an ioname.\n      // In case this is true, if the name requested is not the ioname, we\n      // return 0, as if the member did not exist. In some sense we override\n      // the information in the TClassInfo instance, isolating the typesystem in\n      // TClass from the one in the AST.\n      if (const ValueDecl* decl = (const ValueDecl*) d){\n         std::string ioName;\n         bool hasIoName = ROOT::TMetaUtils::ExtractAttrPropertyFromName(*decl,\"ioname\",ioName);\n         if (hasIoName && ioName != name) return 0;\n      }\n      return d;\n   }\n   // We are looking up for something on the TU scope.\n   // FIXME: We do not want to go through TClingClassInfo(fInterpreter) because of redundant deserializations. That\n   // interface will actually construct iterators and walk over the decls on the global scope. In would return the first\n   // occurrence of a decl with the looked up name. However, that's not what C++ lookup would do: if we want to switch\n   // to a more complete C++ lookup interface we need sift through the found names and pick up the declarations which\n   // are only fulfilling ROOT's understanding for a Data Member.\n   // FIXME: We should probably deprecate the TClingClassInfo(fInterpreter) interface and replace it withe something\n   // similar as below.\n   using namespace clang;\n   Sema& SemaR = fInterpreter->getSema();\n   DeclarationName DName = &SemaR.Context.Idents.get(name);\n\n   LookupResult R(SemaR, DName, SourceLocation(), Sema::LookupOrdinaryName,\n                  Sema::ForRedeclaration);\n\n   // Could trigger deserialization of decls.\n   cling::Interpreter::PushTransactionRAII RAII(GetInterpreterImpl());\n   cling::utils::Lookup::Named(&SemaR, R);\n\n   LookupResult::Filter F = R.makeFilter();\n   // Filter the data-member looking decls.\n   while (F.hasNext()) {\n      NamedDecl *D = F.next();\n      if (isa<VarDecl>(D) || isa<FieldDecl>(D) || isa<EnumConstantDecl>(D) ||\n          isa<IndirectFieldDecl>(D))\n         continue;\n      F.erase();\n   }\n   F.done();\n\n   if (R.isSingleResult())\n      return R.getFoundDecl();\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to cling Decl of global/static variable that is located\n/// at the address given by addr.\n\nTInterpreter::DeclId_t TCling::GetEnum(TClass *cl, const char *name) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   const clang::Decl* possibleEnum = 0;\n   // FInd the context of the decl.\n   if (cl) {\n      TClingClassInfo *cci = (TClingClassInfo*)cl->GetClassInfo();\n      if (cci) {\n         const clang::DeclContext* dc = 0;\n         if (const clang::Decl* D = cci->GetDecl()) {\n            if (!(dc = dyn_cast<clang::NamespaceDecl>(D))) {\n               dc = dyn_cast<clang::RecordDecl>(D);\n            }\n         }\n         if (dc) {\n            // If it is a data member enum.\n            // Could trigger deserialization of decls.\n            cling::Interpreter::PushTransactionRAII RAII(GetInterpreterImpl());\n            possibleEnum = cling::utils::Lookup::Tag(&fInterpreter->getSema(), name, dc);\n         } else {\n            Error(\"TCling::GetEnum\", \"DeclContext not found for %s .\\n\", name);\n         }\n      }\n   } else {\n      // If it is a global enum.\n      // Could trigger deserialization of decls.\n      cling::Interpreter::PushTransactionRAII RAII(GetInterpreterImpl());\n      possibleEnum = cling::utils::Lookup::Tag(&fInterpreter->getSema(), name);\n   }\n   if (possibleEnum && (possibleEnum != (clang::Decl*)-1)\n       && isa<clang::EnumDecl>(possibleEnum)) {\n      return possibleEnum;\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to cling DeclId for a global value\n\nTInterpreter::DeclId_t TCling::GetDeclId( const llvm::GlobalValue *gv ) const\n{\n   if (!gv) return 0;\n\n   llvm::StringRef mangled_name = gv->getName();\n\n   int err = 0;\n   char* demangled_name_c = TClassEdit::DemangleName(mangled_name.str().c_str(), err);\n   if (err) {\n      if (err == -2) {\n         // It might simply be an unmangled global name.\n         DeclId_t d;\n         TClingClassInfo gcl(GetInterpreterImpl());\n         d = gcl.GetDataMember(mangled_name.str().c_str());\n         return d;\n      }\n      return 0;\n   }\n\n   std::string scopename(demangled_name_c);\n   free(demangled_name_c);\n\n   //\n   //  Separate out the class or namespace part of the\n   //  function name.\n   //\n   std::string dataname;\n\n   if (!strncmp(scopename.c_str(), \"typeinfo for \", sizeof(\"typeinfo for \")-1)) {\n      scopename.erase(0, sizeof(\"typeinfo for \")-1);\n   } else if (!strncmp(scopename.c_str(), \"vtable for \", sizeof(\"vtable for \")-1)) {\n      scopename.erase(0, sizeof(\"vtable for \")-1);\n   } else {\n      // See if it is a function\n      std::string::size_type pos = scopename.rfind('(');\n      if (pos != std::string::npos) {\n         return 0;\n      }\n      // Separate the scope and member name\n      pos = scopename.rfind(':');\n      if (pos != std::string::npos) {\n         if ((pos != 0) && (scopename[pos-1] == ':')) {\n            dataname = scopename.substr(pos+1);\n            scopename.erase(pos-1);\n         }\n      } else {\n         scopename.clear();\n         dataname = scopename;\n      }\n   }\n   //fprintf(stderr, \"name: '%s'\\n\", name.c_str());\n   // Now we have the class or namespace name, so do the lookup.\n\n\n   DeclId_t d;\n   if (scopename.size()) {\n      TClingClassInfo cl(GetInterpreterImpl(), scopename.c_str());\n      d = cl.GetDataMember(dataname.c_str());\n   }\n   else {\n      TClingClassInfo gcl(GetInterpreterImpl());\n      d = gcl.GetDataMember(dataname.c_str());\n   }\n   return d;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// NOT IMPLEMENTED.\n\nTInterpreter::DeclId_t TCling::GetDataMemberWithValue(const void *ptrvalue) const\n{\n   Error(\"GetDataMemberWithValue()\", \"not implemented\");\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to cling DeclId for a data member with a given name.\n\nTInterpreter::DeclId_t TCling::GetDataMemberAtAddr(const void *addr) const\n{\n   // NOT IMPLEMENTED.\n   Error(\"GetDataMemberAtAddr()\", \"not implemented\");\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the cling mangled name for a method of a class with parameters\n/// params (params is a string of actual arguments, not formal ones). If the\n/// class is 0 the global function list will be searched.\n\nTString TCling::GetMangledName(TClass* cl, const char* method,\n                               const char* params, Bool_t objectIsConst /* = kFALSE */)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClingCallFunc func(GetInterpreterImpl(), *fNormalizedCtxt);\n   if (cl) {\n      Long_t offset;\n      func.SetFunc((TClingClassInfo*)cl->GetClassInfo(), method, params, objectIsConst,\n         &offset);\n   }\n   else {\n      TClingClassInfo gcl(GetInterpreterImpl());\n      Long_t offset;\n      func.SetFunc(&gcl, method, params, &offset);\n   }\n   TClingMethodInfo* mi = (TClingMethodInfo*) func.FactoryMethod();\n   if (!mi) return \"\";\n   TString mangled_name( mi->GetMangledName() );\n   delete mi;\n   return mangled_name;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the cling mangled name for a method of a class with a certain\n/// prototype, i.e. \"char*,int,float\". If the class is 0 the global function\n/// list will be searched.\n\nTString TCling::GetMangledNameWithPrototype(TClass* cl, const char* method,\n                                            const char* proto, Bool_t objectIsConst /* = kFALSE */,\n                                            EFunctionMatchMode mode /* = kConversionMatch */)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   if (cl) {\n      return ((TClingClassInfo*)cl->GetClassInfo())->\n         GetMethod(method, proto, objectIsConst, 0 /*poffset*/, mode).GetMangledName();\n   }\n   TClingClassInfo gcl(GetInterpreterImpl());\n   return gcl.GetMethod(method, proto, objectIsConst, 0 /*poffset*/, mode).GetMangledName();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to cling interface function for a method of a class with\n/// parameters params (params is a string of actual arguments, not formal\n/// ones). If the class is 0 the global function list will be searched.\n\nvoid* TCling::GetInterfaceMethod(TClass* cl, const char* method,\n                                 const char* params, Bool_t objectIsConst /* = kFALSE */)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClingCallFunc func(GetInterpreterImpl(), *fNormalizedCtxt);\n   if (cl) {\n      Long_t offset;\n      func.SetFunc((TClingClassInfo*)cl->GetClassInfo(), method, params, objectIsConst,\n                   &offset);\n   }\n   else {\n      TClingClassInfo gcl(GetInterpreterImpl());\n      Long_t offset;\n      func.SetFunc(&gcl, method, params, &offset);\n   }\n   return (void*) func.InterfaceMethod();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to cling interface function for a method of a class with\n/// a certain name.\n\nTInterpreter::DeclId_t TCling::GetFunction(ClassInfo_t *opaque_cl, const char* method)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   DeclId_t f;\n   TClingClassInfo *cl = (TClingClassInfo*)opaque_cl;\n   if (cl) {\n      f = cl->GetMethod(method).GetDeclId();\n   }\n   else {\n      TClingClassInfo gcl(GetInterpreterImpl());\n      f = gcl.GetMethod(method).GetDeclId();\n   }\n   return f;\n\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Insert overloads of name in cl to res.\n\nvoid TCling::GetFunctionOverloads(ClassInfo_t *cl, const char *funcname,\n                                  std::vector<DeclId_t>& res) const\n{\n   clang::Sema& S = fInterpreter->getSema();\n   clang::ASTContext& Ctx = S.Context;\n   const clang::Decl* CtxDecl\n      = cl ? (const clang::Decl*)((TClingClassInfo*)cl)->GetDeclId():\n      Ctx.getTranslationUnitDecl();\n   auto RecDecl = llvm::dyn_cast<const clang::RecordDecl>(CtxDecl);\n   const clang::DeclContext* DeclCtx = RecDecl;\n\n   if (!DeclCtx)\n      DeclCtx = dyn_cast<clang::NamespaceDecl>(CtxDecl);\n   if (!DeclCtx) return;\n\n   clang::DeclarationName DName;\n   // The DeclarationName is funcname, unless it's a ctor or dtor.\n   // FIXME: or operator or conversion! See enum clang::DeclarationName::NameKind.\n\n   if (RecDecl) {\n      if (RecDecl->getNameAsString() == funcname) {\n         clang::QualType QT = Ctx.getTypeDeclType(RecDecl);\n         DName = Ctx.DeclarationNames.getCXXConstructorName(Ctx.getCanonicalType(QT));\n      } else if (funcname[0] == '~' && RecDecl->getNameAsString() == funcname + 1) {\n         clang::QualType QT = Ctx.getTypeDeclType(RecDecl);\n         DName = Ctx.DeclarationNames.getCXXDestructorName(Ctx.getCanonicalType(QT));\n      } else {\n         DName = &Ctx.Idents.get(funcname);\n      }\n   } else {\n      DName = &Ctx.Idents.get(funcname);\n   }\n\n   clang::LookupResult R(S, DName, clang::SourceLocation(),\n                         Sema::LookupOrdinaryName, clang::Sema::ForRedeclaration);\n   S.LookupQualifiedName(R, const_cast<DeclContext*>(DeclCtx));\n   if (R.empty()) return;\n   R.resolveKind();\n   res.reserve(res.size() + (R.end() - R.begin()));\n   for (clang::LookupResult::iterator IR = R.begin(), ER = R.end();\n        IR != ER; ++IR) {\n      if (const clang::FunctionDecl* FD\n          = llvm::dyn_cast<const clang::FunctionDecl>(*IR)) {\n         if (!FD->getDescribedFunctionTemplate()) {\n            res.push_back(FD);\n         }\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to cling interface function for a method of a class with\n/// a certain prototype, i.e. \"char*,int,float\". If the class is 0 the global\n/// function list will be searched.\n\nvoid* TCling::GetInterfaceMethodWithPrototype(TClass* cl, const char* method,\n                                              const char* proto,\n                                              Bool_t objectIsConst /* = kFALSE */,\n                                              EFunctionMatchMode mode /* = kConversionMatch */)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   void* f;\n   if (cl) {\n      f = ((TClingClassInfo*)cl->GetClassInfo())->\n         GetMethod(method, proto, objectIsConst, 0 /*poffset*/, mode).InterfaceMethod(*fNormalizedCtxt);\n   }\n   else {\n      TClingClassInfo gcl(GetInterpreterImpl());\n      f = gcl.GetMethod(method, proto, objectIsConst, 0 /*poffset*/, mode).InterfaceMethod(*fNormalizedCtxt);\n   }\n   return f;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to cling DeclId for a method of a class with\n/// a certain prototype, i.e. \"char*,int,float\". If the class is 0 the global\n/// function list will be searched.\n\nTInterpreter::DeclId_t TCling::GetFunctionWithValues(ClassInfo_t *opaque_cl, const char* method,\n                                                     const char* params,\n                                                     Bool_t objectIsConst /* = kFALSE */)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   DeclId_t f;\n   TClingClassInfo *cl = (TClingClassInfo*)opaque_cl;\n   if (cl) {\n      f = cl->GetMethodWithArgs(method, params, objectIsConst, 0 /*poffset*/).GetDeclId();\n   }\n   else {\n      TClingClassInfo gcl(GetInterpreterImpl());\n      f = gcl.GetMethod(method, params, objectIsConst, 0 /*poffset*/).GetDeclId();\n   }\n   return f;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to cling interface function for a method of a class with\n/// a certain prototype, i.e. \"char*,int,float\". If the class is 0 the global\n/// function list will be searched.\n\nTInterpreter::DeclId_t TCling::GetFunctionWithPrototype(ClassInfo_t *opaque_cl, const char* method,\n                                                        const char* proto,\n                                                        Bool_t objectIsConst /* = kFALSE */,\n                                                        EFunctionMatchMode mode /* = kConversionMatch */)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   DeclId_t f;\n   TClingClassInfo *cl = (TClingClassInfo*)opaque_cl;\n   if (cl) {\n      f = cl->GetMethod(method, proto, objectIsConst, 0 /*poffset*/, mode).GetDeclId();\n   }\n   else {\n      TClingClassInfo gcl(GetInterpreterImpl());\n      f = gcl.GetMethod(method, proto, objectIsConst, 0 /*poffset*/, mode).GetDeclId();\n   }\n   return f;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to cling interface function for a method of a class with\n/// a certain name.\n\nTInterpreter::DeclId_t TCling::GetFunctionTemplate(ClassInfo_t *opaque_cl, const char* name)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   DeclId_t f;\n   TClingClassInfo *cl = (TClingClassInfo*)opaque_cl;\n   if (cl) {\n      f = cl->GetFunctionTemplate(name);\n   }\n   else {\n      TClingClassInfo gcl(GetInterpreterImpl());\n      f = gcl.GetFunctionTemplate(name);\n   }\n   return f;\n\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// The 'name' is known to the interpreter, this function returns\n/// the internal version of this name (usually just resolving typedefs)\n/// This is used in particular to synchronize between the name used\n/// by rootcling and by the run-time environment (TClass)\n/// Return 0 if the name is not known.\n\nvoid TCling::GetInterpreterTypeName(const char* name, std::string &output, Bool_t full)\n{\n   output.clear();\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   TClingClassInfo cl(GetInterpreterImpl(), name);\n   if (!cl.IsValid()) {\n      return ;\n   }\n   if (full) {\n      cl.FullName(output,*fNormalizedCtxt);\n      return;\n   }\n   // Well well well, for backward compatibility we need to act a bit too\n   // much like CINT.\n   TClassEdit::TSplitType splitname( cl.Name(), TClassEdit::kDropStd );\n   splitname.ShortType(output, TClassEdit::kDropStd );\n\n   return;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Execute a global function with arguments params.\n///\n/// FIXME: The cint-based version of this code does not check if the\n///        SetFunc() call works, and does not do any real checking\n///        for errors from the Exec() call.  It did fetch the most\n///        recent cint security error and return that in error, but\n///        this does not really translate well to cling/clang.  We\n///        should enhance these interfaces so that we can report\n///        compilation and runtime errors properly.\n\nvoid TCling::Execute(const char* function, const char* params, int* error)\n{\n   R__LOCKGUARD_CLING(gInterpreterMutex);\n   if (error) {\n      *error = TInterpreter::kNoError;\n   }\n   TClingClassInfo cl(GetInterpreterImpl());\n   Long_t offset = 0L;\n   TClingCallFunc func(GetInterpreterImpl(), *fNormalizedCtxt);\n   func.SetFunc(&cl, function, params, &offset);\n   func.Exec(0);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Execute a method from class cl with arguments params.\n///\n/// FIXME: The cint-based version of this code does not check if the\n///        SetFunc() call works, and does not do any real checking\n///        for errors from the Exec() call.  It did fetch the most\n///        recent cint security error and return that in error, but\n///        this does not really translate well to cling/clang.  We\n///        should enhance these interfaces so that we can report\n///        compilation and runtime errors properly.\n\nvoid TCling::Execute(TObject* obj, TClass* cl, const char* method,\n                     const char* params, Bool_t objectIsConst, int* error)\n{\n   R__LOCKGUARD_CLING(gInterpreterMutex);\n   if (error) {\n      *error = TInterpreter::kNoError;\n   }\n   // If the actual class of this object inherits 2nd (or more) from TObject,\n   // 'obj' is unlikely to be the start of the object (as described by IsA()),\n   // hence gInterpreter->Execute will improperly correct the offset.\n   void* addr = cl->DynamicCast(TObject::Class(), obj, kFALSE);\n   Long_t offset = 0L;\n   TClingCallFunc func(GetInterpreterImpl(), *fNormalizedCtxt);\n   func.SetFunc((TClingClassInfo*)cl->GetClassInfo(), method, params, objectIsConst, &offset);\n   void* address = (void*)((Long_t)addr + offset);\n   func.Exec(address);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::Execute(TObject* obj, TClass* cl, const char* method,\n                    const char* params, int* error)\n{\n   Execute(obj,cl,method,params,false,error);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Execute a method from class cl with the arguments in array params\n/// (params[0] ... params[n] = array of TObjString parameters).\n/// Convert the TObjArray array of TObjString parameters to a character\n/// string of comma separated parameters.\n/// The parameters of type 'char' are enclosed in double quotes and all\n/// internal quotes are escaped.\n\nvoid TCling::Execute(TObject* obj, TClass* cl, TMethod* method,\n                     TObjArray* params, int* error)\n{\n   if (!method) {\n      Error(\"Execute\", \"No method was defined\");\n      return;\n   }\n   TList* argList = method->GetListOfMethodArgs();\n   // Check number of actual parameters against of expected formal ones\n\n   Int_t nparms = argList->LastIndex() + 1;\n   Int_t argc   = params ? params->GetEntries() : 0;\n\n   if (argc > nparms) {\n      Error(\"Execute\",\"Too many parameters to call %s, got %d but expected at most %d.\",method->GetName(),argc,nparms);\n      return;\n   }\n   if (nparms != argc) {\n     // Let's see if the 'missing' argument are all defaulted.\n     // if nparms==0 then either we stopped earlier either argc is also zero and we can't reach here.\n     assert(nparms > 0);\n\n     TMethodArg *arg = (TMethodArg *) argList->At( 0 );\n     if (arg && arg->GetDefault() && arg->GetDefault()[0]) {\n        // There is a default value for the first missing\n        // argument, so we are fine.\n     } else {\n        Int_t firstDefault = -1;\n        for (Int_t i = 0; i < nparms; i ++) {\n           arg = (TMethodArg *) argList->At( i );\n           if (arg && arg->GetDefault() && arg->GetDefault()[0]) {\n              firstDefault = i;\n              break;\n           }\n        }\n        if (firstDefault >= 0) {\n           Error(\"Execute\",\"Too few arguments to call %s, got only %d but expected at least %d and at most %d.\",method->GetName(),argc,firstDefault,nparms);\n        } else {\n           Error(\"Execute\",\"Too few arguments to call %s, got only %d but expected %d.\",method->GetName(),argc,nparms);\n        }\n        return;\n     }\n   }\n\n   const char* listpar = \"\";\n   TString complete(10);\n   if (params) {\n      // Create a character string of parameters from TObjArray\n      TIter next(params);\n      for (Int_t i = 0; i < argc; i ++) {\n         TMethodArg* arg = (TMethodArg*) argList->At(i);\n         TClingTypeInfo type(GetInterpreterImpl(), arg->GetFullTypeName());\n         TObjString* nxtpar = (TObjString*) next();\n         if (i) {\n            complete += ',';\n         }\n         if (strstr(type.TrueName(*fNormalizedCtxt), \"char\")) {\n            TString chpar('\\\"');\n            chpar += (nxtpar->String()).ReplaceAll(\"\\\"\", \"\\\\\\\"\");\n            // At this point we have to check if string contains \\\\\"\n            // and apply some more sophisticated parser. Not implemented yet!\n            complete += chpar;\n            complete += '\\\"';\n         }\n         else {\n            complete += nxtpar->String();\n         }\n      }\n      listpar = complete.Data();\n   }\n\n   // And now execute it.\n   R__LOCKGUARD_CLING(gInterpreterMutex);\n   if (error) {\n      *error = TInterpreter::kNoError;\n   }\n   // If the actual class of this object inherits 2nd (or more) from TObject,\n   // 'obj' is unlikely to be the start of the object (as described by IsA()),\n   // hence gInterpreter->Execute will improperly correct the offset.\n   void* addr = cl->DynamicCast(TObject::Class(), obj, kFALSE);\n   TClingCallFunc func(GetInterpreterImpl(), *fNormalizedCtxt);\n   TClingMethodInfo *minfo = (TClingMethodInfo*)method->fInfo;\n   func.Init(*minfo);\n   func.SetArgs(listpar);\n   // Now calculate the 'this' pointer offset for the method\n   // when starting from the class described by cl.\n   const CXXMethodDecl * mdecl = dyn_cast<CXXMethodDecl>(minfo->GetMethodDecl());\n   Long_t offset = ((TClingClassInfo*)cl->GetClassInfo())->GetOffset(mdecl);\n   void* address = (void*)((Long_t)addr + offset);\n   func.Exec(address);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::ExecuteWithArgsAndReturn(TMethod* method, void* address,\n                                      const void* args[] /*=0*/,\n                                      int nargs /*=0*/,\n                                      void* ret/*= 0*/) const\n{\n   if (!method) {\n      Error(\"ExecuteWithArgsAndReturn\", \"No method was defined\");\n      return;\n   }\n\n   TClingMethodInfo* minfo = (TClingMethodInfo*) method->fInfo;\n   TClingCallFunc func(*minfo,*fNormalizedCtxt);\n   func.ExecWithArgsAndReturn(address, args, nargs, ret);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Execute a cling macro.\n\nLong_t TCling::ExecuteMacro(const char* filename, EErrorCode* error)\n{\n   R__LOCKGUARD_CLING(fLockProcessLine ? gInterpreterMutex : 0);\n   fCurExecutingMacros.push_back(filename);\n   Long_t result = TApplication::ExecuteFile(filename, (int*)error);\n   fCurExecutingMacros.pop_back();\n   return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the file name of the current un-included interpreted file.\n/// See the documentation for GetCurrentMacroName().\n\nconst char* TCling::GetTopLevelMacroName() const\n{\n   Warning(\"GetTopLevelMacroName\", \"Must change return type!\");\n   return fCurExecutingMacros.back();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the file name of the currently interpreted file,\n/// included or not. Example to illustrate the difference between\n/// GetCurrentMacroName() and GetTopLevelMacroName():\n/// ~~~ {.cpp}\n///   void inclfile() {\n///   std::cout << \"In inclfile.C\" << std::endl;\n///   std::cout << \"  TCling::GetCurrentMacroName() returns  \" <<\n///      TCling::GetCurrentMacroName() << std::endl;\n///   std::cout << \"  TCling::GetTopLevelMacroName() returns \" <<\n///      TCling::GetTopLevelMacroName() << std::endl;\n///   }\n/// ~~~\n/// ~~~ {.cpp}\n///   void mymacro() {\n///   std::cout << \"In mymacro.C\" << std::endl;\n///   std::cout << \"  TCling::GetCurrentMacroName() returns  \" <<\n///      TCling::GetCurrentMacroName() << std::endl;\n///   std::cout << \"  TCling::GetTopLevelMacroName() returns \" <<\n///      TCling::GetTopLevelMacroName() << std::endl;\n///   std::cout << \"  Now calling inclfile...\" << std::endl;\n///   gInterpreter->ProcessLine(\".x inclfile.C\");;\n///   }\n/// ~~~\n/// Running mymacro.C will print:\n///\n/// ~~~ {.cpp}\n/// root [0] .x mymacro.C\n/// ~~~\n/// In mymacro.C\n/// ~~~ {.cpp}\n///   TCling::GetCurrentMacroName() returns  ./mymacro.C\n///   TCling::GetTopLevelMacroName() returns ./mymacro.C\n/// ~~~\n///   Now calling inclfile...\n/// In inclfile.h\n/// ~~~ {.cpp}\n///   TCling::GetCurrentMacroName() returns  inclfile.C\n///   TCling::GetTopLevelMacroName() returns ./mymacro.C\n/// ~~~\n\nconst char* TCling::GetCurrentMacroName() const\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,0)\n   Warning(\"GetCurrentMacroName\", \"Must change return type!\");\n#endif\n#endif\n   return fCurExecutingMacros.back();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the absolute type of typeDesc.\n/// E.g.: typeDesc = \"class TNamed**\", returns \"TNamed\".\n/// You need to use the result immediately before it is being overwritten.\n\nconst char* TCling::TypeName(const char* typeDesc)\n{\n   TTHREAD_TLS(char*) t = 0;\n   TTHREAD_TLS(unsigned int) tlen = 0;\n\n   unsigned int dlen = strlen(typeDesc);\n   if (dlen > tlen) {\n      delete[] t;\n      t = new char[dlen + 1];\n      tlen = dlen;\n   }\n   const char* s, *template_start;\n   if (!strstr(typeDesc, \"(*)(\")) {\n      s = strchr(typeDesc, ' ');\n      template_start = strchr(typeDesc, '<');\n      if (!strcmp(typeDesc, \"long long\")) {\n         strlcpy(t, typeDesc, dlen + 1);\n      }\n      else if (!strncmp(typeDesc, \"unsigned \", s + 1 - typeDesc)) {\n         strlcpy(t, typeDesc, dlen + 1);\n      }\n      // s is the position of the second 'word' (if any)\n      // except in the case of templates where there will be a space\n      // just before any closing '>': eg.\n      //    TObj<std::vector<UShort_t,__malloc_alloc_template<0> > >*\n      else if (s && (template_start == 0 || (s < template_start))) {\n         strlcpy(t, s + 1, dlen + 1);\n      }\n      else {\n         strlcpy(t, typeDesc, dlen + 1);\n      }\n   }\n   else {\n      strlcpy(t, typeDesc, dlen + 1);\n   }\n   int l = strlen(t);\n   while (l > 0 && (t[l - 1] == '*' || t[l - 1] == '&')) {\n      t[--l] = 0;\n   }\n   return t;\n}\n\nstatic bool requiresRootMap(const char* rootmapfile, cling::Interpreter* interp)\n{\n   assert(rootmapfile && *rootmapfile);\n\n   llvm::StringRef libName = llvm::sys::path::filename(rootmapfile);\n   libName.consume_back(\".rootmap\");\n\n   return !gInterpreter->HasPCMForLibrary(libName.str().c_str());\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Read and parse a rootmapfile in its new format, and return 0 in case of\n/// success, -1 if the file has already been read, and -3 in case its format\n/// is the old one (e.g. containing \"Library.ClassName\"), -4 in case of syntax\n/// error.\n\nint TCling::ReadRootmapFile(const char *rootmapfile, TUniqueString *uniqueString)\n{\n   if (!(rootmapfile && *rootmapfile))\n      return 0;\n\n   if (!requiresRootMap(rootmapfile, GetInterpreterImpl()))\n      return 0; // success\n\n   // For \"class \", \"namespace \", \"typedef \", \"header \", \"enum \", \"var \" respectively\n   const std::map<char, unsigned int> keyLenMap = {{'c',6},{'n',10},{'t',8},{'h',7},{'e',5},{'v',4}};\n\n   std::string rootmapfileNoBackslash(rootmapfile);\n#ifdef _MSC_VER\n   std::replace(rootmapfileNoBackslash.begin(), rootmapfileNoBackslash.end(), '\\\\', '/');\n#endif\n   // Add content of a specific rootmap file\n   if (fRootmapFiles->FindObject(rootmapfileNoBackslash.c_str()))\n      return -1;\n\n   if (uniqueString)\n      uniqueString->Append(std::string(\"\\n#line 1 \\\"Forward declarations from \") + rootmapfileNoBackslash + \"\\\"\\n\");\n\n   std::ifstream file(rootmapfileNoBackslash);\n   std::string line;\n   line.reserve(200);\n   std::string lib_name;\n   line.reserve(100);\n   bool newFormat = false;\n   while (getline(file, line, '\\n')) {\n      if (!newFormat && (line.compare(0, 8, \"Library.\") == 0 || line.compare(0, 8, \"Declare.\") == 0)) {\n         file.close();\n         return -3; // old format\n      }\n      newFormat = true;\n\n      if (line.compare(0, 9, \"{ decls }\") == 0) {\n         // forward declarations\n\n         while (getline(file, line, '\\n')) {\n            if (line[0] == '[')\n               break;\n            if (!uniqueString) {\n               Error(\"ReadRootmapFile\", \"Cannot handle \\\"{ decls }\\\" sections in custom rootmap file %s\",\n                     rootmapfileNoBackslash.c_str());\n               return -4;\n            }\n            uniqueString->Append(line);\n         }\n      }\n      const char firstChar = line[0];\n      if (firstChar == '[') {\n         // new section (library)\n         auto brpos = line.find(']');\n         if (brpos == string::npos)\n            continue;\n         lib_name = line.substr(1, brpos - 1);\n         size_t nspaces = 0;\n         while (lib_name[nspaces] == ' ')\n            ++nspaces;\n         if (nspaces)\n            lib_name.replace(0, nspaces, \"\");\n         if (gDebug > 3) {\n            TString lib_nameTstr(lib_name.c_str());\n            TObjArray *tokens = lib_nameTstr.Tokenize(\" \");\n            const char *lib = ((TObjString *)tokens->At(0))->GetName();\n            const char *wlib = gSystem->DynamicPathName(lib, kTRUE);\n            if (wlib) {\n               Info(\"ReadRootmapFile\", \"new section for %s\", lib_nameTstr.Data());\n            } else {\n               Info(\"ReadRootmapFile\", \"section for %s (library does not exist)\", lib_nameTstr.Data());\n            }\n            delete[] wlib;\n            delete tokens;\n         }\n      } else {\n         auto keyLenIt = keyLenMap.find(firstChar);\n         if (keyLenIt == keyLenMap.end())\n            continue;\n         unsigned int keyLen = keyLenIt->second;\n         // Do not make a copy, just start after the key\n         const char *keyname = line.c_str() + keyLen;\n         if (gDebug > 6)\n            Info(\"ReadRootmapFile\", \"class %s in %s\", keyname, lib_name.c_str());\n         TEnvRec *isThere = fMapfile->Lookup(keyname);\n         if (isThere) {\n            if (lib_name != isThere->GetValue()) { // the same key for two different libs\n               if (firstChar == 'n') {\n                  if (gDebug > 3)\n                     Info(\"ReadRootmapFile\", \"namespace %s found in %s is already in %s\", keyname, lib_name.c_str(),\n                          isThere->GetValue());\n               } else if (firstChar == 'h') { // it is a header: add the libname to the list of libs to be loaded.\n                  lib_name += \" \";\n                  lib_name += isThere->GetValue();\n                  fMapfile->SetValue(keyname, lib_name.c_str());\n               } else if (!TClassEdit::IsSTLCont(keyname)) {\n                  Warning(\"ReadRootmapFile\", \"%s %s found in %s is already in %s\", line.substr(0, keyLen).c_str(),\n                          keyname, lib_name.c_str(), isThere->GetValue());\n               }\n            } else { // the same key for the same lib\n               if (gDebug > 3)\n                  Info(\"ReadRootmapFile\", \"Key %s was already defined for %s\", keyname, lib_name.c_str());\n            }\n         } else {\n            fMapfile->SetValue(keyname, lib_name.c_str());\n         }\n      }\n   }\n   file.close();\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create a resource table and read the (possibly) three resource files, i.e\n/// $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>), $HOME/<name> and\n/// ./<name>. ROOT always reads \".rootrc\" (in TROOT::InitSystem()). You can\n/// read additional user defined resource files by creating additional TEnv\n/// objects. By setting the shell variable ROOTENV_NO_HOME=1 the reading of\n/// the $HOME/<name> resource file will be skipped. This might be useful in\n/// case the home directory resides on an automounted remote file system\n/// and one wants to avoid the file system from being mounted.\n\nvoid TCling::InitRootmapFile(const char *name)\n{\n   assert(requiresRootMap(name, GetInterpreterImpl()) && \"We have a module!\");\n\n   if (!requiresRootMap(name, GetInterpreterImpl()))\n      return;\n\n   Bool_t ignore = fMapfile->IgnoreDuplicates(kFALSE);\n\n   fMapfile->SetRcName(name);\n\n   TString sname = \"system\";\n   sname += name;\n   char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);\n\n   Int_t ret = ReadRootmapFile(s);\n   if (ret == -3) // old format\n      fMapfile->ReadFile(s, kEnvGlobal);\n   delete [] s;\n   if (!gSystem->Getenv(\"ROOTENV_NO_HOME\")) {\n      s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);\n      ret = ReadRootmapFile(s);\n      if (ret == -3) // old format\n         fMapfile->ReadFile(s, kEnvUser);\n      delete [] s;\n      if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())) {\n         ret = ReadRootmapFile(name);\n         if (ret == -3) // old format\n            fMapfile->ReadFile(name, kEnvLocal);\n      }\n   } else {\n      ret = ReadRootmapFile(name);\n      if (ret == -3) // old format\n         fMapfile->ReadFile(name, kEnvLocal);\n   }\n   fMapfile->IgnoreDuplicates(ignore);\n}\n\n\nnamespace {\n   using namespace clang;\n\n   class ExtVisibleStorageAdder: public RecursiveASTVisitor<ExtVisibleStorageAdder>{\n      // This class is to be considered an helper for autoloading.\n      // It is a recursive visitor is used to inspect namespaces coming from\n      // forward declarations in rootmaps and to set the external visible\n      // storage flag for them.\n   public:\n      ExtVisibleStorageAdder(std::unordered_set<const NamespaceDecl*>& nsSet): fNSSet(nsSet) {};\n      bool VisitNamespaceDecl(NamespaceDecl* nsDecl) {\n         // We want to enable the external lookup for this namespace\n         // because it may shadow the lookup of other names contained\n         // in that namespace\n\n         nsDecl->setHasExternalVisibleStorage();\n         fNSSet.insert(nsDecl);\n         return true;\n      }\n   private:\n      std::unordered_set<const NamespaceDecl*>& fNSSet;\n\n   };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Load map between class and library. If rootmapfile is specified a\n/// specific rootmap file can be added (typically used by ACLiC).\n/// In case of error -1 is returned, 0 otherwise.\n/// The interpreter uses this information to automatically load the shared\n/// library for a class (autoload mechanism), see the AutoLoad() methods below.\n\nInt_t TCling::LoadLibraryMap(const char* rootmapfile)\n{\n   if (rootmapfile && *rootmapfile && !requiresRootMap(rootmapfile, GetInterpreterImpl()))\n      return 0;\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   // open the [system].rootmap files\n   if (!fMapfile) {\n      fMapfile = new TEnv();\n      fMapfile->IgnoreDuplicates(kTRUE);\n      fRootmapFiles = new TObjArray;\n      fRootmapFiles->SetOwner();\n      InitRootmapFile(\".rootmap\");\n   }\n\n   // Prepare a list of all forward declarations for cling\n   // For some experiments it is easily as big as 500k characters. To be on the\n   // safe side, we go for 1M.\n   TUniqueString uniqueString(1048576);\n\n   // Load all rootmap files in the dynamic load path ((DY)LD_LIBRARY_PATH, etc.).\n   // A rootmap file must end with the string \".rootmap\".\n   TString ldpath = gSystem->GetDynamicPath();\n   if (ldpath != fRootmapLoadPath) {\n      fRootmapLoadPath = ldpath;\n#ifdef WIN32\n      TObjArray* paths = ldpath.Tokenize(\";\");\n#else\n      TObjArray* paths = ldpath.Tokenize(\":\");\n#endif\n      TString d;\n      for (Int_t i = 0; i < paths->GetEntriesFast(); i++) {\n         d = ((TObjString *)paths->At(i))->GetString();\n         // check if directory already scanned\n         Int_t skip = 0;\n         for (Int_t j = 0; j < i; j++) {\n            TString pd = ((TObjString *)paths->At(j))->GetString();\n            if (pd == d) {\n               skip++;\n               break;\n            }\n         }\n         if (!skip) {\n            void* dirp = gSystem->OpenDirectory(d);\n            if (dirp) {\n               if (gDebug > 3) {\n                  Info(\"LoadLibraryMap\", \"%s\", d.Data());\n               }\n               const char* f1;\n               while ((f1 = gSystem->GetDirEntry(dirp))) {\n                  TString f = f1;\n                  if (f.EndsWith(\".rootmap\")) {\n                     TString p;\n                     p = d + \"/\" + f;\n                     if (!gSystem->AccessPathName(p, kReadPermission)) {\n                        if (!fRootmapFiles->FindObject(f) && f != \".rootmap\") {\n                           if (gDebug > 4) {\n                              Info(\"LoadLibraryMap\", \"   rootmap file: %s\", p.Data());\n                           }\n                           Int_t ret = ReadRootmapFile(p, &uniqueString);\n\n                           if (ret == 0)\n                              fRootmapFiles->Add(new TNamed(gSystem->BaseName(f), p.Data()));\n                           if (ret == -3) {\n                              // old format\n                              fMapfile->ReadFile(p, kEnvGlobal);\n                              fRootmapFiles->Add(new TNamed(f, p));\n                           }\n                        }\n                        // else {\n                        //    fprintf(stderr,\"Reject %s because %s is already there\\n\",p.Data(),f.Data());\n                        //    fRootmapFiles->FindObject(f)->ls();\n                        // }\n                     }\n                  }\n                  if (f.BeginsWith(\"rootmap\")) {\n                     TString p;\n                     p = d + \"/\" + f;\n                     FileStat_t stat;\n                     if (gSystem->GetPathInfo(p, stat) == 0 && R_ISREG(stat.fMode)) {\n                        Warning(\"LoadLibraryMap\", \"please rename %s to end with \\\".rootmap\\\"\", p.Data());\n                     }\n                  }\n               }\n            }\n            gSystem->FreeDirectory(dirp);\n         }\n      }\n      delete paths;\n      if (fMapfile->GetTable() && !fMapfile->GetTable()->GetEntries()) {\n         return -1;\n      }\n   }\n   if (rootmapfile && *rootmapfile) {\n      Int_t res = ReadRootmapFile(rootmapfile, &uniqueString);\n      if (res == 0) {\n         //TString p = gSystem->ConcatFileName(gSystem->pwd(), rootmapfile);\n         //fRootmapFiles->Add(new TNamed(gSystem->BaseName(rootmapfile), p.Data()));\n         fRootmapFiles->Add(new TNamed(gSystem->BaseName(rootmapfile), rootmapfile));\n      }\n      else if (res == -3) {\n         // old format\n         Bool_t ignore = fMapfile->IgnoreDuplicates(kFALSE);\n         fMapfile->ReadFile(rootmapfile, kEnvGlobal);\n         fRootmapFiles->Add(new TNamed(gSystem->BaseName(rootmapfile), rootmapfile));\n         fMapfile->IgnoreDuplicates(ignore);\n      }\n   }\n   TEnvRec* rec;\n   TIter next(fMapfile->GetTable());\n   while ((rec = (TEnvRec*) next())) {\n      TString cls = rec->GetName();\n      if (!strncmp(cls.Data(), \"Library.\", 8) && cls.Length() > 8) {\n         // get the first lib from the list of lib and dependent libs\n         TString libs = rec->GetValue();\n         if (libs == \"\") {\n            continue;\n         }\n         TString delim(\" \");\n         TObjArray* tokens = libs.Tokenize(delim);\n         const char* lib = ((TObjString*)tokens->At(0))->GetName();\n         // convert \"@@\" to \"::\", we used \"@@\" because TEnv\n         // considers \"::\" a terminator\n         cls.Remove(0, 8);\n         cls.ReplaceAll(\"@@\", \"::\");\n         // convert \"-\" to \" \", since class names may have\n         // blanks and TEnv considers a blank a terminator\n         cls.ReplaceAll(\"-\", \" \");\n         if (gDebug > 6) {\n            const char* wlib = gSystem->DynamicPathName(lib, kTRUE);\n            if (wlib) {\n               Info(\"LoadLibraryMap\", \"class %s in %s\", cls.Data(), wlib);\n            }\n            else {\n               Info(\"LoadLibraryMap\", \"class %s in %s (library does not exist)\", cls.Data(), lib);\n            }\n            delete[] wlib;\n         }\n         delete tokens;\n      }\n      else if (!strncmp(cls.Data(), \"Declare.\", 8) && cls.Length() > 8) {\n         cls.Remove(0, 8);\n         // convert \"-\" to \" \", since class names may have\n         // blanks and TEnv considers a blank a terminator\n         cls.ReplaceAll(\"-\", \" \");\n         fInterpreter->declare(cls.Data());\n      }\n   }\n\n   // Process the forward declarations collected\n   cling::Transaction* T = nullptr;\n   auto compRes= fInterpreter->declare(uniqueString.Data(), &T);\n   assert(cling::Interpreter::kSuccess == compRes && \"A declaration in a rootmap could not be compiled\");\n\n   if (compRes!=cling::Interpreter::kSuccess){\n      Warning(\"LoadLibraryMap\",\n               \"Problems in %s declaring '%s' were encountered.\", rootmapfile, uniqueString.Data()) ;\n   }\n\n   if (T){\n      ExtVisibleStorageAdder evsAdder(fNSFromRootmaps);\n      for (auto declIt = T->decls_begin(); declIt < T->decls_end(); ++declIt) {\n         if (declIt->m_DGR.isSingleDecl()) {\n            if (Decl* D = declIt->m_DGR.getSingleDecl()) {\n               if (NamespaceDecl* NSD = dyn_cast<NamespaceDecl>(D)) {\n                  evsAdder.TraverseDecl(NSD);\n               }\n            }\n         }\n      }\n   }\n\n   // clear duplicates\n\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Scan again along the dynamic path for library maps. Entries for the loaded\n/// shared libraries are unloaded first. This can be useful after reseting\n/// the dynamic path through TSystem::SetDynamicPath()\n/// In case of error -1 is returned, 0 otherwise.\n\nInt_t TCling::RescanLibraryMap()\n{\n   UnloadAllSharedLibraryMaps();\n   LoadLibraryMap();\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Reload the library map entries coming from all the loaded shared libraries,\n/// after first unloading the current ones.\n/// In case of error -1 is returned, 0 otherwise.\n\nInt_t TCling::ReloadAllSharedLibraryMaps()\n{\n   const TString sharedLibLStr = GetSharedLibs();\n   const TObjArray* sharedLibL = sharedLibLStr.Tokenize(\" \");\n   const Int_t nrSharedLibs = sharedLibL->GetEntriesFast();\n   for (Int_t ilib = 0; ilib < nrSharedLibs; ilib++) {\n      const TString sharedLibStr = ((TObjString*)sharedLibL->At(ilib))->GetString();\n      const  TString sharedLibBaseStr = gSystem->BaseName(sharedLibStr);\n      const Int_t ret = UnloadLibraryMap(sharedLibBaseStr);\n      if (ret < 0) {\n         continue;\n      }\n      TString rootMapBaseStr = sharedLibBaseStr;\n      if (sharedLibBaseStr.EndsWith(\".dll\")) {\n         rootMapBaseStr.ReplaceAll(\".dll\", \"\");\n      }\n      else if (sharedLibBaseStr.EndsWith(\".DLL\")) {\n         rootMapBaseStr.ReplaceAll(\".DLL\", \"\");\n      }\n      else if (sharedLibBaseStr.EndsWith(\".so\")) {\n         rootMapBaseStr.ReplaceAll(\".so\", \"\");\n      }\n      else if (sharedLibBaseStr.EndsWith(\".sl\")) {\n         rootMapBaseStr.ReplaceAll(\".sl\", \"\");\n      }\n      else if (sharedLibBaseStr.EndsWith(\".dl\")) {\n         rootMapBaseStr.ReplaceAll(\".dl\", \"\");\n      }\n      else if (sharedLibBaseStr.EndsWith(\".a\")) {\n         rootMapBaseStr.ReplaceAll(\".a\", \"\");\n      }\n      else {\n         Error(\"ReloadAllSharedLibraryMaps\", \"Unknown library type %s\", sharedLibBaseStr.Data());\n         delete sharedLibL;\n         return -1;\n      }\n      rootMapBaseStr += \".rootmap\";\n      const char* rootMap = gSystem->Which(gSystem->GetDynamicPath(), rootMapBaseStr);\n      if (!rootMap) {\n         Error(\"ReloadAllSharedLibraryMaps\", \"Could not find rootmap %s in path\", rootMapBaseStr.Data());\n         delete[] rootMap;\n         delete sharedLibL;\n         return -1;\n      }\n      const Int_t status = LoadLibraryMap(rootMap);\n      if (status < 0) {\n         Error(\"ReloadAllSharedLibraryMaps\", \"Error loading map %s\", rootMap);\n         delete[] rootMap;\n         delete sharedLibL;\n         return -1;\n      }\n      delete[] rootMap;\n   }\n   delete sharedLibL;\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Unload the library map entries coming from all the loaded shared libraries.\n/// Returns 0 if succesful\n\nInt_t TCling::UnloadAllSharedLibraryMaps()\n{\n   const TString sharedLibLStr = GetSharedLibs();\n   const TObjArray* sharedLibL = sharedLibLStr.Tokenize(\" \");\n   for (Int_t ilib = 0; ilib < sharedLibL->GetEntriesFast(); ilib++) {\n      const TString sharedLibStr = ((TObjString*)sharedLibL->At(ilib))->GetString();\n      const  TString sharedLibBaseStr = gSystem->BaseName(sharedLibStr);\n      UnloadLibraryMap(sharedLibBaseStr);\n   }\n   delete sharedLibL;\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Unload library map entries coming from the specified library.\n/// Returns -1 in case no entries for the specified library were found,\n/// 0 otherwise.\n\nInt_t TCling::UnloadLibraryMap(const char* library)\n{\n   if (!fMapfile || !library || !*library) {\n      return 0;\n   }\n   TString libname(library);\n   Ssiz_t idx = libname.Last('.');\n   if (idx != kNPOS) {\n      libname.Remove(idx);\n   }\n   size_t len = libname.Length();\n   TEnvRec *rec;\n   TIter next(fMapfile->GetTable());\n   R__LOCKGUARD(gInterpreterMutex);\n   Int_t ret = 0;\n   while ((rec = (TEnvRec *) next())) {\n      TString cls = rec->GetName();\n      if (cls.Length() > 2) {\n         // get the first lib from the list of lib and dependent libs\n         TString libs = rec->GetValue();\n         if (libs == \"\") {\n            continue;\n         }\n         TString delim(\" \");\n         TObjArray* tokens = libs.Tokenize(delim);\n         const char* lib = ((TObjString *)tokens->At(0))->GetName();\n         if (!strncmp(cls.Data(), \"Library.\", 8) && cls.Length() > 8) {\n            // convert \"@@\" to \"::\", we used \"@@\" because TEnv\n            // considers \"::\" a terminator\n            cls.Remove(0, 8);\n            cls.ReplaceAll(\"@@\", \"::\");\n            // convert \"-\" to \" \", since class names may have\n            // blanks and TEnv considers a blank a terminator\n            cls.ReplaceAll(\"-\", \" \");\n         }\n         if (!strncmp(lib, libname.Data(), len)) {\n            if (fMapfile->GetTable()->Remove(rec) == 0) {\n               Error(\"UnloadLibraryMap\", \"entry for <%s, %s> not found in library map table\", cls.Data(), lib);\n               ret = -1;\n            }\n         }\n         delete tokens;\n      }\n   }\n   if (ret >= 0) {\n      TString library_rootmap(library);\n      if (!library_rootmap.EndsWith(\".rootmap\"))\n         library_rootmap.Append(\".rootmap\");\n      TNamed* mfile = 0;\n      while ((mfile = (TNamed *)fRootmapFiles->FindObject(library_rootmap))) {\n         fRootmapFiles->Remove(mfile);\n         delete mfile;\n      }\n      fRootmapFiles->Compress();\n   }\n   return ret;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Register the autoloading information for a class.\n/// libs is a space separated list of libraries.\n\nInt_t TCling::SetClassSharedLibs(const char *cls, const char *libs)\n{\n   if (!cls || !*cls)\n      return 0;\n\n   TString key = TString(\"Library.\") + cls;\n   // convert \"::\" to \"@@\", we used \"@@\" because TEnv\n   // considers \"::\" a terminator\n   key.ReplaceAll(\"::\", \"@@\");\n   // convert \"-\" to \" \", since class names may have\n   // blanks and TEnv considers a blank a terminator\n   key.ReplaceAll(\" \", \"-\");\n\n   R__LOCKGUARD(gInterpreterMutex);\n   if (!fMapfile) {\n      fMapfile = new TEnv();\n      fMapfile->IgnoreDuplicates(kTRUE);\n\n      fRootmapFiles = new TObjArray;\n      fRootmapFiles->SetOwner();\n\n      InitRootmapFile(\".rootmap\");\n   }\n   //fMapfile->SetValue(key, libs);\n   fMapfile->SetValue(cls, libs);\n   return 1;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Demangle the name (from the typeinfo) and then request the class\n/// via the usual name based interface (TClass::GetClass).\n\nTClass *TCling::GetClass(const std::type_info& typeinfo, Bool_t load) const\n{\n   int err = 0;\n   char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);\n   if (err) return 0;\n   TClass* theClass = TClass::GetClass(demangled_name, load, kTRUE);\n   free(demangled_name);\n   return theClass;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Load library containing the specified class. Returns 0 in case of error\n/// and 1 in case if success.\n\nInt_t TCling::AutoLoad(const std::type_info& typeinfo, Bool_t knowDictNotLoaded /* = kFALSE */)\n{\n   assert(IsClassAutoloadingEnabled() && \"Calling when autoloading is off!\");\n\n   int err = 0;\n   char* demangled_name_c = TClassEdit::DemangleTypeIdName(typeinfo, err);\n   if (err) {\n      return 0;\n   }\n\n   std::string demangled_name(demangled_name_c);\n   free(demangled_name_c);\n\n   // AutoLoad expects (because TClass::GetClass already prepares it that way) a\n   // shortened name.\n   TClassEdit::TSplitType splitname( demangled_name.c_str(), (TClassEdit::EModType)(TClassEdit::kLong64 | TClassEdit::kDropStd) );\n   splitname.ShortType(demangled_name, TClassEdit::kDropStlDefault | TClassEdit::kDropStd);\n\n   // No need to worry about typedef, they aren't any ... but there are\n   // inlined namespaces ...\n\n   Int_t result = AutoLoad(demangled_name.c_str());\n   if (result == 0) {\n      demangled_name = TClassEdit::GetLong64_Name(demangled_name);\n      result = AutoLoad(demangled_name.c_str(), knowDictNotLoaded);\n   }\n\n   return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Load library containing the specified class. Returns 0 in case of error\n/// and 1 in case if success.\n\nInt_t TCling::AutoLoad(const char *cls, Bool_t knowDictNotLoaded /* = kFALSE */)\n{\n   // TClass::GetClass explicitly calls gInterpreter->AutoLoad. When called from\n   // rootcling (in *_rdict.pcm file generation) it is a no op.\n   // FIXME: We should avoid calling autoload when we know we are not supposed\n   // to and transform this check into an assert.\n   if (!IsClassAutoloadingEnabled()) {\n      // Never load any library from rootcling/genreflex.\n      if (gDebug > 2) {\n         Info(\"TCling::AutoLoad\", \"Explicitly disabled (the class name is %s)\", cls);\n      }\n      return 0;\n   }\n\n   assert(IsClassAutoloadingEnabled() && \"Calling when autoloading is off!\");\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   if (!knowDictNotLoaded && gClassTable->GetDictNorm(cls)) {\n      // The library is already loaded as the class's dictionary is known.\n      // Return success.\n      // Note: the name (cls) is expected to be normalized as it comes either\n      // from a callbacks (that can/should calculate the normalized name from the\n      // decl) or from TClass::GetClass (which does also calculate the normalized\n      // name).\n      return 1;\n   }\n\n   if (gDebug > 2) {\n      Info(\"TCling::AutoLoad\",\n           \"Trying to autoload for %s\", cls);\n   }\n\n   if (!gROOT || !gInterpreter || gROOT->TestBit(TObject::kInvalidObject)) {\n      if (gDebug > 2) {\n         Info(\"TCling::AutoLoad\",\n              \"Disabled due to gROOT or gInterpreter being invalid/not ready (the class name is %s)\", cls);\n      }\n      return 0;\n   }\n   // Prevent the recursion when the library dictionary are loaded.\n   SuspendAutoloadingRAII autoLoadOff(this);\n   // Try using externally provided callback first.\n   if (fAutoLoadCallBack) {\n      int success = (*(AutoLoadCallBack_t)fAutoLoadCallBack)(cls);\n      if (success)\n         return success;\n   }\n   // lookup class to find list of dependent libraries\n   Int_t status = 0;\n   TString deplibs = GetClassSharedLibs(cls);\n   if (!deplibs.IsNull()) {\n      TString delim(\" \");\n      TObjArray* tokens = deplibs.Tokenize(delim);\n      for (Int_t i = (tokens->GetEntriesFast() - 1); i > 0; --i) {\n         const char* deplib = ((TObjString*)tokens->At(i))->GetName();\n         if (gROOT->LoadClass(cls, deplib) == 0) {\n            if (gDebug > 0) {\n               Info(\"TCling::AutoLoad\",\n                    \"loaded dependent library %s for %s\", deplib, cls);\n            }\n         }\n         else {\n            Error(\"TCling::AutoLoad\",\n                  \"failure loading dependent library %s for %s\",\n                  deplib, cls);\n         }\n      }\n      const char* lib = ((TObjString*)tokens->At(0))->GetName();\n      if (lib && lib[0]) {\n         if (gROOT->LoadClass(cls, lib) == 0) {\n            if (gDebug > 0) {\n               Info(\"TCling::AutoLoad\",\n                    \"loaded library %s for %s\", lib, cls);\n            }\n            status = 1;\n         }\n         else {\n            Error(\"TCling::AutoLoad\",\n                  \"failure loading library %s for %s\", lib, cls);\n         }\n      }\n      delete tokens;\n   }\n\n   return status;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Parse the payload or header.\n\nstatic cling::Interpreter::CompilationResult ExecAutoParse(const char *what,\n                                                           Bool_t header,\n                                                           cling::Interpreter *interpreter)\n{\n   std::string code = gNonInterpreterClassDef ;\n   if (!header) {\n      // This is the complete header file content and not the\n      // name of a header.\n      code += what;\n\n   } else {\n      code += (\"#include \\\"\");\n      code += what;\n      code += \"\\\"\\n\";\n   }\n   code += (\"#ifdef __ROOTCLING__\\n\"\n            \"#undef __ROOTCLING__\\n\"\n            + gInterpreterClassDef +\n            \"#endif\");\n\n   cling::Interpreter::CompilationResult cr;\n   {\n      // scope within which diagnostics are de-activated\n      // For now we disable diagnostics because we saw them already at\n      // dictionary generation time. That won't be an issue with the PCMs.\n\n      Sema &SemaR = interpreter->getSema();\n      ROOT::Internal::ParsingStateRAII parsingStateRAII(interpreter->getParser(), SemaR);\n      clangDiagSuppr diagSuppr(SemaR.getDiagnostics());\n\n      #if defined(R__MUST_REVISIT)\n      #if R__MUST_REVISIT(6,2)\n      Warning(\"TCling::RegisterModule\",\"Diagnostics suppression should be gone by now.\");\n      #endif\n      #endif\n\n      cr = interpreter->parseForModule(code);\n   }\n   return cr;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Helper routine for TCling::AutoParse implementing the actual call to the\n/// parser and looping over template parameters (if\n/// any) and when they don't have a registered header to autoparse,\n/// recurse over their template parameters.\n///\n/// Returns the number of header parsed.\n\nUInt_t TCling::AutoParseImplRecurse(const char *cls, bool topLevel)\n{\n   // We assume the lock has already been taken.\n   //    R__LOCKGUARD(gInterpreterMutex);\n\n   Int_t nHheadersParsed = 0;\n   unsigned long offset = 0;\n   if (strncmp(cls, \"const \", 6) == 0) {\n      offset = 6;\n   }\n\n   // Loop on the possible autoparse keys\n   bool skipFirstEntry = false;\n   std::vector<std::string> autoparseKeys;\n   if (strchr(cls, '<')) {\n      int nestedLoc = 0;\n      TClassEdit::GetSplit(cls + offset, autoparseKeys, nestedLoc, TClassEdit::kDropTrailStar);\n      // Check if we can skip the name of the template in the autoparses\n      // Take all the scopes one by one. If all of them are in the AST, we do not\n      // need to autoparse for that particular template.\n      if (!autoparseKeys.empty() && !autoparseKeys[0].empty()) {\n         // autoparseKeys[0] is empty when the input is not a template instance.\n         // The case strchr(cls, '<') != 0 but still not a template instance can\n         // happens 'just' for string (GetSplit replaces the template by the short name\n         // and then use that for thew splitting)\n         TString templateName(autoparseKeys[0]);\n         auto tokens = templateName.Tokenize(\"::\");\n         clang::NamedDecl* previousScopeAsNamedDecl = nullptr;\n         clang::DeclContext* previousScopeAsContext = fInterpreter->getCI()->getASTContext().getTranslationUnitDecl();\n         if (TClassEdit::IsStdClass(cls + offset))\n            previousScopeAsContext = fInterpreter->getSema().getStdNamespace();\n         auto nTokens = tokens->GetEntries();\n         for (Int_t tk = 0; tk < nTokens; ++tk) {\n            auto scopeObj = tokens->UncheckedAt(tk);\n            auto scopeName = ((TObjString*) scopeObj)->String().Data();\n            previousScopeAsNamedDecl = cling::utils::Lookup::Named(&fInterpreter->getSema(), scopeName, previousScopeAsContext);\n            // Check if we have multiple nodes in the AST with this name\n            if ((clang::NamedDecl*)-1 == previousScopeAsNamedDecl) break;\n            previousScopeAsContext = llvm::dyn_cast_or_null<clang::DeclContext>(previousScopeAsNamedDecl);\n            if (!previousScopeAsContext) break; // this is not a context\n         }\n         delete tokens;\n         // Now, let's check if the last scope, the template, has a definition, i.e. it's not a fwd decl\n         if ((clang::NamedDecl*)-1 != previousScopeAsNamedDecl) {\n            if (auto templateDecl = llvm::dyn_cast_or_null<clang::ClassTemplateDecl>(previousScopeAsNamedDecl)) {\n               if (auto templatedDecl = templateDecl->getTemplatedDecl()) {\n                  skipFirstEntry = templatedDecl->hasDefinition();\n               }\n            }\n         }\n\n      }\n   }\n   if (topLevel) autoparseKeys.emplace_back(cls);\n\n   for (const auto & apKeyStr : autoparseKeys) {\n      if (skipFirstEntry) {\n         skipFirstEntry=false;\n         continue;\n      }\n      if (apKeyStr.empty()) continue;\n      const char *apKey = apKeyStr.c_str();\n      std::size_t normNameHash(fStringHashFunction(apKey));\n      // If the class was not looked up\n      if (gDebug > 1) {\n         Info(\"TCling::AutoParse\",\n              \"Starting autoparse for %s\\n\", apKey);\n      }\n      if (fLookedUpClasses.insert(normNameHash).second) {\n         auto const &iter = fClassesHeadersMap.find(normNameHash);\n         if (iter != fClassesHeadersMap.end()) {\n            const cling::Transaction *T = fInterpreter->getCurrentTransaction();\n            fTransactionHeadersMap.insert({T,normNameHash});\n            auto const &hNamesPtrs = iter->second;\n            if (gDebug > 1) {\n               Info(\"TCling::AutoParse\",\n                    \"We can proceed for %s. We have %s headers.\", apKey, std::to_string(hNamesPtrs.size()).c_str());\n            }\n            for (auto & hName : hNamesPtrs) {\n               if (fParsedPayloadsAddresses.count(hName) == 1) continue;\n               if (0 != fPayloads.count(normNameHash)) {\n                  float initRSSval=0.f, initVSIZEval=0.f;\n                  (void) initRSSval; // Avoid unused var warning\n                  (void) initVSIZEval;\n                  if (gDebug > 0) {\n                     Info(\"AutoParse\",\n                          \"Parsing full payload for %s\", apKey);\n                     ProcInfo_t info;\n                     gSystem->GetProcInfo(&info);\n                     initRSSval = 1e-3*info.fMemResident;\n                     initVSIZEval = 1e-3*info.fMemVirtual;\n                  }\n                  auto cRes = ExecAutoParse(hName, kFALSE, GetInterpreterImpl());\n                  if (cRes != cling::Interpreter::kSuccess) {\n                     if (hName[0] == '\\n')\n                        Error(\"AutoParse\", \"Error parsing payload code for class %s with content:\\n%s\", apKey, hName);\n                  } else {\n                     fParsedPayloadsAddresses.insert(hName);\n                     nHheadersParsed++;\n                     if (gDebug > 0){\n                        ProcInfo_t info;\n                        gSystem->GetProcInfo(&info);\n                        float endRSSval = 1e-3*info.fMemResident;\n                        float endVSIZEval = 1e-3*info.fMemVirtual;\n                        Info(\"Autoparse\", \">>> RSS key %s - before %.3f MB - after %.3f MB - delta %.3f MB\", apKey, initRSSval, endRSSval, endRSSval-initRSSval);\n                        Info(\"Autoparse\", \">>> VSIZE key %s - before %.3f MB - after %.3f MB - delta %.3f MB\", apKey, initVSIZEval, endVSIZEval, endVSIZEval-initVSIZEval);\n                     }\n                  }\n               } else if (!IsLoaded(hName)) {\n                  if (gDebug > 0) {\n                     Info(\"AutoParse\",\n                          \"Parsing single header %s\", hName);\n                  }\n                  auto cRes = ExecAutoParse(hName, kTRUE, GetInterpreterImpl());\n                  if (cRes != cling::Interpreter::kSuccess) {\n                     Error(\"AutoParse\", \"Error parsing headerfile %s for class %s.\", hName, apKey);\n                  } else {\n                     nHheadersParsed++;\n                  }\n               }\n            }\n         }\n         else {\n            // There is no header registered for this class, if this a\n            // template, it will be instantiated if/when it is requested\n            // and if we do no load/parse its components we might end up\n            // not using an eventual specialization.\n            if (strchr(apKey, '<')) {\n               nHheadersParsed += AutoParseImplRecurse(apKey, false);\n            }\n         }\n      }\n   }\n\n   return nHheadersParsed;\n\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Parse the headers relative to the class\n/// Returns 1 in case of success, 0 in case of failure\n\nInt_t TCling::AutoParse(const char *cls)\n{\n   if (llvm::StringRef(cls).contains(\"(lambda)\"))\n      return 0;\n\n   if (!fHeaderParsingOnDemand || fIsAutoParsingSuspended) {\n      if (fClingCallbacks->IsAutoloadingEnabled()) {\n         return AutoLoad(cls);\n      } else {\n         return 0;\n      }\n   }\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   if (gDebug > 1) {\n      Info(\"TCling::AutoParse\",\n           \"Trying to autoparse for %s\", cls);\n   }\n\n   // The catalogue of headers is in the dictionary\n   if (fClingCallbacks->IsAutoloadingEnabled()\n         && !gClassTable->GetDictNorm(cls)) {\n      // Need RAII against recursive (dictionary payload) parsing (ROOT-8445).\n      ROOT::Internal::ParsingStateRAII parsingStateRAII(fInterpreter->getParser(),\n         fInterpreter->getSema());\n      AutoLoad(cls, true /*knowDictNotLoaded*/);\n   }\n\n   // Prevent the recursion when the library dictionary are loaded.\n   SuspendAutoloadingRAII autoLoadOff(this);\n\n   // No recursive header parsing on demand; we require headers to be standalone.\n   SuspendAutoParsing autoParseRAII(this);\n\n   Int_t nHheadersParsed = AutoParseImplRecurse(cls,/*topLevel=*/ true);\n\n   ProcessClassesToUpdate();\n\n   return nHheadersParsed > 0 ? 1 : 0;\n}\n\n// This is a function which gets callback from cling when DynamicLibraryManager->loadLibrary failed for some reason.\n// Try to solve the problem by autoloading. Return true when autoloading success, return\n// false if not.\nbool TCling::LibraryLoadingFailed(const std::string& errmessage, const std::string& libStem, bool permanent, bool resolved)\n{\n   StringRef errMsg(errmessage);\n   if (errMsg.contains(\"undefined symbol: \")) {\n   // This branch is taken when the callback was from DynamicLibraryManager::loadLibrary\n      std::string mangled_name = std::string(errMsg.split(\"undefined symbol: \").second);\n      void* res = ((TCling*)gCling)->LazyFunctionCreatorAutoload(mangled_name);\n      cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();\n      if (res && DLM && (DLM->loadLibrary(libStem, permanent, resolved) == cling::DynamicLibraryManager::kLoadLibSuccess))\n        // Return success when LazyFunctionCreatorAutoload could find mangled_name\n        return true;\n   } else {\n   // The callback is from IncrementalExecutor::diagnoseUnresolvedSymbols\n      if ( ((TCling*)gCling)->LazyFunctionCreatorAutoload(errmessage))\n         return true;\n   }\n\n   return false;\n}\n\n// This is a GNU implementation of hash used in bloom filter!\nstatic uint32_t GNUHash(StringRef S) {\n   uint32_t H = 5381;\n   for (uint8_t C : S)\n      H = (H << 5) + H + C;\n   return H;\n}\n\nstatic StringRef GetGnuHashSection(llvm::object::ObjectFile *file) {\n   for (auto S : file->sections()) {\n      StringRef name;\n      S.getName(name);\n      if (name == \".gnu.hash\") {\n         StringRef content;\n         S.getContents(content);\n         return content;\n      }\n   }\n   return \"\";\n}\n\n/// Bloom filter in a stohastic data structure which can tell us if a symbol\n/// name does not exist in a library with 100% certainty. If it tells us it exists\n/// this may not be true: https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2\n///\n/// ELF has this optimization in the new linkers by default, It is stored in the\n/// gnu.hash section of the object file.\n///\n///\\returns true true if the symbol may be in the library.\nstatic bool MayExistInObjectFile(llvm::object::ObjectFile *soFile, uint32_t hash) {\n   if (!soFile->isELF())\n      return true;\n\n   // LLVM9: soFile->makeTriple().is64Bit()\n   const int bits = 8 * soFile->getBytesInAddress();\n\n   StringRef contents = GetGnuHashSection(soFile);\n   if (contents.size() < 16)\n      // We need to search if the library doesn't have .gnu.hash section!\n      return true;\n   const char* hashContent = contents.data();\n\n   // See https://flapenguin.me/2017/05/10/elf-lookup-dt-gnu-hash/ for .gnu.hash table layout.\n   uint32_t maskWords = *reinterpret_cast<const uint32_t *>(hashContent + 8);\n   uint32_t shift2 = *reinterpret_cast<const uint32_t *>(hashContent + 12);\n   uint32_t hash2 = hash >> shift2;\n   uint32_t n = (hash / bits) % maskWords;\n\n   const char *bloomfilter = hashContent + 16;\n   const char *hash_pos = bloomfilter + n*(bits/8); // * (Bits / 8)\n   uint64_t word = *reinterpret_cast<const uint64_t *>(hash_pos);\n   uint64_t bitmask = ( (1ULL << (hash % bits)) | (1ULL << (hash2 % bits)));\n   return  (bitmask & word) == bitmask;\n}\n\n/// Looks up symbols from a an object file, representing the library.\n///\\returns true on success.\nstatic bool FindSymbol(const std::string &library_filename,\n                       const std::string &mangled_name, unsigned IgnoreSymbolFlags = 0)\n{\n   auto ObjF = llvm::object::ObjectFile::createObjectFile(ROOT::TMetaUtils::GetRealPath(library_filename));\n   if (!ObjF) {\n      if (gDebug > 1)\n         Warning(\"TCling__FindSymbol\", \"Failed to read object file %s\", library_filename.c_str());\n      return false;\n   }\n\n   llvm::object::ObjectFile *BinObjFile = ObjF.get().getBinary();\n\n   uint32_t hashedMangle = GNUHash(mangled_name);\n   // If the symbol does not exist, exit early. In case it may exist, iterate.\n   if (!MayExistInObjectFile(BinObjFile, hashedMangle))\n      return false;\n\n   for (const auto &S : BinObjFile->symbols()) {\n      uint32_t Flags = S.getFlags();\n      // Do not insert in the table symbols flagged to ignore.\n      if (Flags & IgnoreSymbolFlags)\n         continue;\n\n      // Note, we are at last resort and loading library based on a weak\n      // symbol is allowed. Otherwise, the JIT will issue an unresolved\n      // symbol error.\n      //\n      // There are other weak symbol kinds (marked as 'V') to denote\n      // typeinfo and vtables. It is unclear whether we should load such\n      // libraries or from which library we should resolve the symbol.\n      // We seem to not have a way to differentiate it from the symbol API.\n\n      llvm::Expected<StringRef> SymNameErr = S.getName();\n      if (!SymNameErr) {\n         Warning(\"TCling__FindSymbol\", \"Failed to read symbol %s\", mangled_name.c_str());\n         continue;\n      }\n\n      if (SymNameErr.get() == mangled_name) {\n         if (gDebug > 1)\n            Info(\"TCling__FindSymbol\", \"Symbol %s found in %s\\n\",\n                 mangled_name.c_str(), library_filename.c_str());\n         return true;\n      }\n   }\n\n   if (!BinObjFile->isELF())\n      return false;\n\n   // ELF file format has .dynstr section for the dynamic symbol table.\n   const auto *ElfObj = cast<llvm::object::ELFObjectFileBase>(BinObjFile);\n\n   for (const auto &S : ElfObj->getDynamicSymbolIterators()) {\n      uint32_t Flags = S.getFlags();\n      // DO NOT insert to table if symbol was undefined\n      if (Flags & llvm::object::SymbolRef::SF_Undefined)\n         continue;\n\n      // Note, we are at last resort and loading library based on a weak\n      // symbol is allowed. Otherwise, the JIT will issue an unresolved\n      // symbol error.\n      //\n      // There are other weak symbol kinds (marked as 'V') to denote\n      // typeinfo and vtables. It is unclear whether we should load such\n      // libraries or from which library we should resolve the symbol.\n      // We seem to not have a way to differentiate it from the symbol API.\n\n      llvm::Expected<StringRef> SymNameErr = S.getName();\n      if (!SymNameErr) {\n         Warning(\"TCling__FindSymbol\", \"Failed to read symbol %s\", mangled_name.c_str());\n         continue;\n      }\n\n      if (SymNameErr.get() == mangled_name)\n         return true;\n   }\n\n   return false;\n}\n\nstatic std::string ResolveSymbol(const std::string& mangled_name,\n                                 cling::Interpreter *interp,\n                                 bool searchSystem = true) {\n   assert(!mangled_name.empty());\n   using namespace llvm::sys::path;\n   using namespace llvm::sys::fs;\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   static bool sFirstRun = true;\n   static bool sFirstSystemLibrary = true;\n   // LibraryPath contains a pair offset to the canonical dirname (stored as\n   // sPaths[i]) and a filename. For example, `/home/foo/root/lib/libTMVA.so`,\n   // the .first will contain an index in sPaths where `/home/foo/root/lib/`\n   // will be stored and .second `libTMVA.so`.\n   // This approach reduces the duplicate paths as at one location there may be\n   // plenty of libraries.\n   using LibraryPath = std::pair<uint32_t, std::string>;\n   using LibraryPaths = std::vector<LibraryPath>;\n   using BasePaths = std::vector<std::string>;\n   static LibraryPaths sLibraries;\n   static BasePaths sPaths;\n   static LibraryPaths sQueriedLibraries;\n\n   // For system header autoloading\n   static LibraryPaths sSysLibraries;\n\n   if (sFirstRun) {\n      TCling__FindLoadedLibraries(sLibraries, sPaths, *interp, /* searchSystem */ false);\n      sFirstRun = false;\n   }\n\n   auto GetLibFileName = [](const LibraryPath &P, const BasePaths &BaseP) {\n      llvm::SmallString<512> Vec(BaseP[P.first]);\n      llvm::sys::path::append(Vec, StringRef(P.second));\n      return Vec.str().str();\n   };\n\n   if (!sQueriedLibraries.empty()) {\n      // Last call we were asked if a library contains a symbol. Usually, the\n      // caller wants to load this library. Check if was loaded and remove it\n      // from our lists of not-yet-loaded libs.\n      for (const LibraryPath &P : sQueriedLibraries) {\n         const std::string LibName = GetLibFileName(P, sPaths);\n         if (!gCling->IsLibraryLoaded(LibName.c_str()))\n            continue;\n\n         sLibraries.erase(std::remove(sLibraries.begin(), sLibraries.end(), P), sLibraries.end());\n         if (!sSysLibraries.empty())\n            sSysLibraries.erase(std::remove(sSysLibraries.begin(), sSysLibraries.end(), P), sSysLibraries.end());\n      }\n   }\n\n   if (sFirstRun) {\n      TCling__FindLoadedLibraries(sLibraries, sPaths, *interp, /* searchSystem */ false);\n      sFirstRun = false;\n   }\n\n   // Iterate over files under this path. We want to get each \".so\" files\n   for (const LibraryPath &P : sLibraries) {\n      const std::string LibName = GetLibFileName(P, sPaths);\n\n      // FIXME: We should also iterate over the dynamic symbols for ROOT\n      // libraries. However, it seems to be redundant for the moment as we do\n      // not strictly require symbols from those sections. Enable after checking\n      // performance!\n      if (FindSymbol(LibName, mangled_name, /*ignore*/\n                     llvm::object::SymbolRef::SF_Undefined |\n                     llvm::object::SymbolRef::SF_Weak)) {\n         sQueriedLibraries.push_back(P);\n         return LibName;\n      }\n   }\n\n   if (!searchSystem)\n      return \"\";\n\n   // Lookup in non-system libraries failed. Expand the search to the system.\n   if (sFirstSystemLibrary) {\n      TCling__FindLoadedLibraries(sSysLibraries, sPaths, *interp, /* searchSystem */ true);\n      sFirstSystemLibrary = false;\n   }\n\n   for (const LibraryPath &P : sSysLibraries) {\n      const std::string LibName = GetLibFileName(P, sPaths);\n\n      if (FindSymbol(LibName, mangled_name, /*ignore*/\n                     llvm::object::SymbolRef::SF_Undefined |\n                     llvm::object::SymbolRef::SF_Weak)) {\n         sQueriedLibraries.push_back(P);\n         return LibName;\n      }\n   }\n\n   return \"\"; // Search found no match.\n}\n\nstatic void* LazyFunctionCreatorAutoloadForModule(const std::string &mangled_name,\n                                                  cling::Interpreter *interp) {\n// The JIT gives us a mangled name which has only one leading underscore on\n// all platforms, for instance _ZN8TRandom34RndmEv. However, on OSX the\n// linker stores this symbol as __ZN8TRandom34RndmEv (adding an extra _).\n   std::string maybe_prefixed_mangled_name = mangled_name;\n#ifdef R__MACOSX\n   assert(!llvm::StringRef(mangled_name).startswith(\"__\") && \"Already added!\");\n   maybe_prefixed_mangled_name = \"_\" + maybe_prefixed_mangled_name;\n#endif\n\n   std::string LibName = ResolveSymbol(maybe_prefixed_mangled_name, interp);\n   if (LibName.empty())\n      return nullptr;\n\n   if (gSystem->Load(LibName.c_str(), \"\", false) < 0)\n      Error(\"TCling__LazyFunctionCreatorAutoloadForModule\",\n            \"Failed to load library %s\", LibName.c_str());\n\n   void* addr = llvm::sys::DynamicLibrary::SearchForAddressOfSymbol(mangled_name.c_str());\n   return addr;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Autoload a library based on a missing symbol.\n\nvoid* TCling::LazyFunctionCreatorAutoload(const std::string& mangled_name) {\n   if (fCxxModulesEnabled)\n      return LazyFunctionCreatorAutoloadForModule(mangled_name, GetInterpreterImpl());\n\n   // First see whether the symbol is in the library that we are currently\n   // loading. It will have access to the symbols of its dependent libraries,\n   // thus checking \"back()\" is sufficient.\n   if (!fRegisterModuleDyLibs.empty()) {\n      if (void* addr = dlsym(fRegisterModuleDyLibs.back(),\n                             mangled_name.c_str())) {\n         return addr;\n      }\n   }\n\n   int err = 0;\n   char* demangled_name_c = TClassEdit::DemangleName(mangled_name.c_str(), err);\n   if (err) {\n      return 0;\n   }\n\n   std::string name(demangled_name_c);\n   free(demangled_name_c);\n\n   //fprintf(stderr, \"demangled name: '%s'\\n\", demangled_name);\n   //\n   //  Separate out the class or namespace part of the\n   //  function name.\n   //\n\n   std::string::size_type pos = name.find(\"__thiscall \");\n   if (pos != std::string::npos) {\n      name.erase(0, pos + sizeof(\"__thiscall \")-1);\n   }\n   pos = name.find(\"__cdecl \");\n   if (pos != std::string::npos) {\n      name.erase(0, pos + sizeof(\"__cdecl \")-1);\n   }\n   if (!strncmp(name.c_str(), \"typeinfo for \", sizeof(\"typeinfo for \")-1)) {\n      name.erase(0, sizeof(\"typeinfo for \")-1);\n   } else if (!strncmp(name.c_str(), \"vtable for \", sizeof(\"vtable for \")-1)) {\n      name.erase(0, sizeof(\"vtable for \")-1);\n   } else if (!strncmp(name.c_str(), \"operator\", sizeof(\"operator\")-1)\n              && !isalnum(name[sizeof(\"operator\")])) {\n     // operator...(A, B) - let's try with A!\n     name.erase(0, sizeof(\"operator\")-1);\n     pos = name.rfind('(');\n     if (pos != std::string::npos) {\n       name.erase(0, pos + 1);\n       pos = name.find(\",\");\n       if (pos != std::string::npos) {\n         // remove next arg up to end, leaving only the first argument type.\n         name.erase(pos);\n       }\n       pos = name.rfind(\" const\");\n       if (pos != std::string::npos) {\n         name.erase(pos, strlen(\" const\"));\n       }\n       while (!name.empty() && strchr(\"&*\", name.back()))\n         name.erase(name.length() - 1);\n     }\n   } else {\n      TClassEdit::FunctionSplitInfo fsi;\n      TClassEdit::SplitFunction(name, fsi);\n      name = fsi.fScopeName;\n   }\n   //fprintf(stderr, \"name: '%s'\\n\", name.c_str());\n   // Now we have the class or namespace name, so do the lookup.\n   TString libs = GetClassSharedLibs(name.c_str());\n   if (libs.IsNull()) {\n      // Not found in the map, all done.\n      return 0;\n   }\n   //fprintf(stderr, \"library: %s\\n\", iter->second.c_str());\n   // Now we have the name of the libraries to load, so load them.\n\n   TString lib;\n   Ssiz_t posLib = 0;\n   while (libs.Tokenize(lib, posLib)) {\n      if (gSystem->Load(lib, \"\", kFALSE /*system*/) < 0) {\n         // The library load failed, all done.\n         //fprintf(stderr, \"load failed: %s\\n\", errmsg.c_str());\n         return 0;\n      }\n   }\n\n   //fprintf(stderr, \"load succeeded.\\n\");\n   // Get the address of the function being called.\n   void* addr = llvm::sys::DynamicLibrary::SearchForAddressOfSymbol(mangled_name.c_str());\n   //fprintf(stderr, \"addr: %016lx\\n\", reinterpret_cast<unsigned long>(addr));\n   return addr;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nBool_t TCling::IsAutoLoadNamespaceCandidate(const clang::NamespaceDecl* nsDecl)\n{\n   return fNSFromRootmaps.count(nsDecl) != 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Internal function. Actually do the update of the ClassInfo when seeing\n//  new TagDecl or NamespaceDecl.\nvoid TCling::RefreshClassInfo(TClass *cl, const clang::NamedDecl *def, bool alias)\n{\n\n   TClingClassInfo *cci = ((TClingClassInfo *)cl->fClassInfo);\n   if (cci) {\n      // If we only had a forward declaration then update the\n      // TClingClassInfo with the definition if we have it now.\n      const NamedDecl *oldDef = llvm::dyn_cast_or_null<NamedDecl>(cci->GetDecl());\n      if (!oldDef || (def && def != oldDef)) {\n         cl->ResetCaches();\n         TClass::RemoveClassDeclId(cci->GetDeclId());\n         if (def) {\n            // It's a tag decl, not a namespace decl.\n            cci->Init(*cci->GetType());\n            TClass::AddClassToDeclIdMap(cci->GetDeclId(), cl);\n         }\n      }\n   } else if (!cl->TestBit(TClass::kLoading) && !cl->fHasRootPcmInfo) {\n      cl->ResetCaches();\n      // yes, this is almost a waste of time, but we do need to lookup\n      // the 'type' corresponding to the TClass anyway in order to\n      // preserve the opaque typedefs (Double32_t)\n      if (!alias && def != nullptr)\n         cl->fClassInfo = (ClassInfo_t *)new TClingClassInfo(GetInterpreterImpl(), def);\n      else\n         cl->fClassInfo = (ClassInfo_t *)new TClingClassInfo(GetInterpreterImpl(), cl->GetName());\n      if (((TClingClassInfo *)cl->fClassInfo)->IsValid()) {\n         // We now need to update the state and bits.\n         if (cl->fState != TClass::kHasTClassInit) {\n            // if (!cl->fClassInfo->IsValid()) cl->fState = TClass::kForwardDeclared; else\n            cl->fState = TClass::kInterpreted;\n            cl->ResetBit(TClass::kIsEmulation);\n         }\n         TClass::AddClassToDeclIdMap(((TClingClassInfo *)(cl->fClassInfo))->GetDeclId(), cl);\n      } else {\n         delete ((TClingClassInfo *)cl->fClassInfo);\n         cl->fClassInfo = nullptr;\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Internal function. Inform a TClass about its new TagDecl or NamespaceDecl.\nvoid TCling::UpdateClassInfoWithDecl(const NamedDecl* ND)\n{\n   const TagDecl *td = dyn_cast<TagDecl>(ND);\n   const NamespaceDecl *ns = dyn_cast<NamespaceDecl>(ND);\n   const NamedDecl *canon = nullptr;\n\n   std::string name;\n   TagDecl* tdDef = 0;\n   if (td) {\n      canon = tdDef = td->getDefinition();\n      // Let's pass the decl to the TClass only if it has a definition.\n      if (!tdDef) return;\n\n      if (!tdDef->isCompleteDefinition() || llvm::isa<clang::FunctionDecl>(tdDef->getDeclContext())) {\n         // Ignore incomplete definition.\n         // Ignore declaration within a function.\n         return;\n      }\n\n      auto declName = tdDef->getNameAsString();\n      // Check if we have registered the unqualified name into the list\n      // of TClass that are in kNoInfo, kEmulated or kFwdDeclaredState.\n      // Since this is used as heureutistic to avoid spurrious calls to GetNormalizedName\n      // the unqualified name is sufficient (and the fully qualified name might be\n      // 'wrong' if there is difference in spelling in the template paramters (for example)\n      if (!TClass::HasNoInfoOrEmuOrFwdDeclaredDecl(declName.c_str())){\n         // fprintf (stderr,\"WARNING: Impossible to find a TClassEntry in kNoInfo or kEmulated the decl of which would be called %s. Skip w/o building the normalized name.\\n\",declName.c_str() );\n         return;\n      }\n\n      clang::QualType type(tdDef->getTypeForDecl(), 0);\n      ROOT::TMetaUtils::GetNormalizedName(name, type, *fInterpreter, *fNormalizedCtxt);\n   } else if (ns) {\n      canon = ns->getCanonicalDecl();\n      name = ND->getQualifiedNameAsString();\n   } else {\n      name = ND->getQualifiedNameAsString();\n   }\n\n   // Supposedly we are being called while something is being\n   // loaded ... let's now tell the autoloader to do the work\n   // yet another time.\n   SuspendAutoloadingRAII autoLoadOff(this);\n   // FIXME: There can be more than one TClass for a single decl.\n   // for example vector<double> and vector<Double32_t>\n   TClass* cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name.c_str());\n   if (cl && GetModTClasses().find(cl) == GetModTClasses().end()) {\n      RefreshClassInfo(cl, canon, false);\n   }\n   // And here we should find the other 'aliases' (eg. vector<Double32_t>)\n   // and update them too:\n   // foreach(aliascl in gROOT->GetListOfClasses()->FindAliasesOf(name.c_str()))\n   //    RefreshClassInfo(cl, tdDef, true);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// No op: see TClingCallbacks\n\nvoid TCling::UpdateClassInfo(char* item, Long_t tagnum)\n{\n}\n\n//______________________________________________________________________________\n//FIXME: Factor out that function in TClass, because TClass does it already twice\nvoid TCling::UpdateClassInfoWork(const char* item)\n{\n   // This is a no-op as part of the API.\n   // TCling uses UpdateClassInfoWithDecl() instead.\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Update all canvases at end the terminal input command.\n\nvoid TCling::UpdateAllCanvases()\n{\n   TIter next(gROOT->GetListOfCanvases());\n   TVirtualPad* canvas;\n   while ((canvas = (TVirtualPad*)next())) {\n      canvas->Update();\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::UpdateListsOnCommitted(const cling::Transaction &T) {\n   std::set<TClass*> modifiedTClasses; // TClasses that require update after this transaction\n\n   // If the transaction does not contain anything we can return earlier.\n   if (!HandleNewTransaction(T)) return;\n\n   bool isTUTransaction = false;\n   if (!T.empty() && T.decls_begin() + 1 == T.decls_end() && !T.hasNestedTransactions()) {\n      clang::Decl* FirstDecl = *(T.decls_begin()->m_DGR.begin());\n      if (llvm::isa<clang::TranslationUnitDecl>(FirstDecl)) {\n         // The is the first transaction, we have to expose to meta\n         // what's already in the AST.\n         isTUTransaction = true;\n      }\n   }\n\n   std::set<const void*> TransactionDeclSet;\n   if (!isTUTransaction && T.decls_end() - T.decls_begin()) {\n      const clang::Decl* WrapperFD = T.getWrapperFD();\n      for (cling::Transaction::const_iterator I = T.decls_begin(), E = T.decls_end();\n          I != E; ++I) {\n         if (I->m_Call != cling::Transaction::kCCIHandleTopLevelDecl\n             && I->m_Call != cling::Transaction::kCCIHandleTagDeclDefinition)\n            continue;\n\n         for (DeclGroupRef::const_iterator DI = I->m_DGR.begin(),\n                 DE = I->m_DGR.end(); DI != DE; ++DI) {\n            if (*DI == WrapperFD)\n               continue;\n            TransactionDeclSet.insert(*DI);\n            ((TCling*)gCling)->HandleNewDecl(*DI, false, modifiedTClasses);\n         }\n      }\n   }\n\n   // The above might trigger more decls to be deserialized.\n   // Thus the iteration over the deserialized decls must be last.\n   for (cling::Transaction::const_iterator I = T.deserialized_decls_begin(),\n           E = T.deserialized_decls_end(); I != E; ++I) {\n      for (DeclGroupRef::const_iterator DI = I->m_DGR.begin(),\n              DE = I->m_DGR.end(); DI != DE; ++DI)\n         if (TransactionDeclSet.find(*DI) == TransactionDeclSet.end()) {\n            //FIXME: HandleNewDecl should take DeclGroupRef\n            ((TCling*)gCling)->HandleNewDecl(*DI, /*isDeserialized*/true,\n                                             modifiedTClasses);\n         }\n   }\n\n\n   // When fully building the reflection info in TClass, a deserialization\n   // could be triggered, which may result in request for building the\n   // reflection info for the same TClass. This in turn will clear the caches\n   // for the TClass in-flight and cause null ptr derefs.\n   // FIXME: This is a quick fix, solving most of the issues. The actual\n   // question is: Shouldn't TClass provide a lock mechanism on update or lock\n   // itself until the update is done.\n   //\n   std::vector<TClass*> modifiedTClassesDiff(modifiedTClasses.size());\n   std::vector<TClass*>::iterator it;\n   it = set_difference(modifiedTClasses.begin(), modifiedTClasses.end(),\n                       ((TCling*)gCling)->GetModTClasses().begin(),\n                       ((TCling*)gCling)->GetModTClasses().end(),\n                       modifiedTClassesDiff.begin());\n   modifiedTClassesDiff.resize(it - modifiedTClassesDiff.begin());\n\n   // Lock the TClass for updates\n   ((TCling*)gCling)->GetModTClasses().insert(modifiedTClassesDiff.begin(),\n                                              modifiedTClassesDiff.end());\n   for (std::vector<TClass*>::const_iterator I = modifiedTClassesDiff.begin(),\n           E = modifiedTClassesDiff.end(); I != E; ++I) {\n      // Make sure the TClass has not been deleted.\n      if (!gROOT->GetListOfClasses()->FindObject(*I)) {\n         continue;\n      }\n      // Could trigger deserialization of decls.\n      cling::Interpreter::PushTransactionRAII RAII(GetInterpreterImpl());\n      // Unlock the TClass for updates\n      ((TCling*)gCling)->GetModTClasses().erase(*I);\n\n   }\n}\n\n///\\brief Invalidate stored TCling state for declarations included in transaction `T'.\n///\nvoid TCling::UpdateListsOnUnloaded(const cling::Transaction &T)\n{\n   HandleNewTransaction(T);\n\n   auto Lists = std::make_tuple((TListOfDataMembers *)gROOT->GetListOfGlobals(),\n                                (TListOfFunctions *)gROOT->GetListOfGlobalFunctions(),\n                                (TListOfFunctionTemplates *)gROOT->GetListOfFunctionTemplates(),\n                                (TListOfEnums *)gROOT->GetListOfEnums());\n\n   cling::Transaction::const_nested_iterator iNested = T.nested_begin();\n   for (cling::Transaction::const_iterator I = T.decls_begin(), E = T.decls_end();\n        I != E; ++I) {\n      if (I->m_Call == cling::Transaction::kCCIHandleVTable)\n         continue;\n      if (I->m_Call == cling::Transaction::kCCINone) {\n         UpdateListsOnUnloaded(*(*iNested));\n         ++iNested;\n         continue;\n      }\n\n      for (auto &D : I->m_DGR)\n         InvalidateCachedDecl(Lists, D);\n   }\n}\n\n///\\brief Invalidate cached TCling information for the given global declaration.\n///\nvoid TCling::InvalidateGlobal(const Decl *D) {\n   auto Lists = std::make_tuple((TListOfDataMembers *)gROOT->GetListOfGlobals(),\n                                (TListOfFunctions *)gROOT->GetListOfGlobalFunctions(),\n                                (TListOfFunctionTemplates *)gROOT->GetListOfFunctionTemplates(),\n                                (TListOfEnums *)gROOT->GetListOfEnums());\n   InvalidateCachedDecl(Lists, D);\n}\n\n///\\brief Invalidate cached TCling information for the given declaration, and\n/// removed it from the appropriate object list.\n///\\param[in] Lists - std::tuple<TListOfDataMembers&, TListOfFunctions&,\n///                              TListOfFunctionTemplates&, TListOfEnums&>\n///                   of pointers to the (global/class) object lists.\n///\\param[in] D - Decl to discard.\n///\nvoid TCling::InvalidateCachedDecl(const std::tuple<TListOfDataMembers*,\n                                             TListOfFunctions*,\n                                             TListOfFunctionTemplates*,\n                                             TListOfEnums*> &Lists, const Decl *D) {\n   if (D->isFromASTFile())  // `D' came from the PCH; ignore\n      return;\n\n   TListOfDataMembers &LODM = *(std::get<0>(Lists));\n   TListOfFunctions &LOF = *(std::get<1>(Lists));\n   TListOfFunctionTemplates &LOFT = *(std::get<2>(Lists));\n   TListOfEnums &LOE = *(std::get<3>(Lists));\n\n   if (isa<VarDecl>(D) || isa<FieldDecl>(D) || isa<EnumConstantDecl>(D)) {\n      TObject *O = LODM.Find((TDictionary::DeclId_t)D);\n      if (LODM.GetClass())\n         RemoveAndInvalidateObject(LODM, static_cast<TDataMember *>(O));\n      else\n         RemoveAndInvalidateObject(LODM, static_cast<TGlobal *>(O));\n   } else if (isa<FunctionDecl>(D)) {\n      RemoveAndInvalidateObject(LOF, LOF.Find((TDictionary::DeclId_t)D));\n   } else if (isa<FunctionTemplateDecl>(D)) {\n      RemoveAndInvalidateObject(LOFT, LOFT.Get((TDictionary::DeclId_t)D));\n   } else if (isa<EnumDecl>(D)) {\n      TEnum *E = LOE.Find((TDictionary::DeclId_t)D);\n      if (!E)\n         return;\n\n      // Try to invalidate enumerators (for unscoped enumerations).\n      for (TIter I = E->GetConstants(); auto EC = (TEnumConstant *)I(); )\n         RemoveAndInvalidateObject(LODM,\n      \t       \t         \t   (TEnumConstant *)LODM.FindObject(EC->GetName()));\n\n      RemoveAndInvalidateObject(LOE, E);\n   } else if (isa<RecordDecl>(D) || isa<NamespaceDecl>(D)) {\n      if (isa<RecordDecl>(D) && !cast<RecordDecl>(D)->isCompleteDefinition())\n         return;\n\n      std::vector<TClass *> Classes;\n      if (!TClass::GetClass(D->getCanonicalDecl(), Classes))\n         return;\n      for (auto &C : Classes) {\n         auto Lists = std::make_tuple((TListOfDataMembers *)C->GetListOfDataMembers(),\n                                      (TListOfFunctions *)C->GetListOfMethods(),\n                                      (TListOfFunctionTemplates *)C->GetListOfFunctionTemplates(),\n                                      (TListOfEnums *)C->GetListOfEnums());\n         for (auto &I : cast<DeclContext>(D)->decls())\n            InvalidateCachedDecl(Lists, I);\n\n         // For NamespaceDecl (redeclarable), only invalidate this redecl.\n         if (D->getKind() != Decl::Namespace\n             || cast<NamespaceDecl>(D)->isOriginalNamespace())\n            C->ResetClassInfo();\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// If an autoparse was done during a transaction and that it is rolled back,\n// we need to make sure the next request for the same autoparse will be\n// honored.\nvoid TCling::TransactionRollback(const cling::Transaction &T) {\n   auto const &triter = fTransactionHeadersMap.find(&T);\n   if (triter != fTransactionHeadersMap.end()) {\n      std::size_t normNameHash = triter->second;\n\n      fLookedUpClasses.erase(normNameHash);\n\n      auto const &iter = fClassesHeadersMap.find(normNameHash);\n      if (iter != fClassesHeadersMap.end()) {\n         auto const &hNamesPtrs = iter->second;\n         for (auto &hName : hNamesPtrs) {\n            if (gDebug > 0) {\n               Info(\"TransactionRollback\",\n                    \"Restoring ability to autoaparse: %s\", hName);\n            }\n            fParsedPayloadsAddresses.erase(hName);\n         }\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::LibraryLoaded(const void* dyLibHandle, const char* canonicalName) {\n// UpdateListOfLoadedSharedLibraries();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::LibraryUnloaded(const void* dyLibHandle, const char* canonicalName) {\n   fPrevLoadedDynLibInfo = 0;\n   fSharedLibs = \"\";\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the list of shared libraries loaded into the process.\n\nconst char* TCling::GetSharedLibs()\n{\n   UpdateListOfLoadedSharedLibraries();\n   return fSharedLibs;\n}\n\nstatic std::string GetClassSharedLibsForModule(const char *cls, cling::LookupHelper &LH)\n{\n   if (!cls || !*cls)\n      return {};\n\n   using namespace clang;\n   if (const Decl *D = LH.findScope(cls, cling::LookupHelper::NoDiagnostics,\n                                    /*type*/ nullptr, /*instantiate*/ false)) {\n      if (!D->isFromASTFile()) {\n         if (gDebug > 5)\n            Warning(\"GetClassSharedLibsForModule\", \"Decl found for %s is not part of a module\", cls);\n         return {};\n      }\n      class ModuleCollector : public ConstDeclVisitor<ModuleCollector> {\n         llvm::DenseSet<Module *> &m_TopLevelModules;\n\n      public:\n         ModuleCollector(llvm::DenseSet<Module *> &TopLevelModules) : m_TopLevelModules(TopLevelModules) {}\n         void Collect(const Decl *D) { Visit(D); }\n\n         void VisitDecl(const Decl *D)\n         {\n            // FIXME: Such case is described ROOT-7765 where\n            // ROOT_GENERATE_DICTIONARY does not contain the list of headers.\n            // They are specified as #includes in the LinkDef file. This leads to\n            // generation of incomplete modulemap files and this logic fails to\n            // compute the corresponding module of D.\n            // FIXME: If we want to support such a case, we should not rely on\n            // the contents of the modulemap but mangle D and look it up in the\n            // .so files.\n            if (!D->hasOwningModule())\n               return;\n            if (Module *M = D->getOwningModule()->getTopLevelModule())\n               m_TopLevelModules.insert(M);\n         }\n\n         void VisitTemplateArgument(const TemplateArgument &TA)\n         {\n            switch (TA.getKind()) {\n            case TemplateArgument::Null:\n            case TemplateArgument::Integral:\n            case TemplateArgument::Pack:\n            case TemplateArgument::NullPtr:\n            case TemplateArgument::Expression:\n            case TemplateArgument::Template:\n            case TemplateArgument::TemplateExpansion: return;\n            case TemplateArgument::Type:\n               if (const TagType *TagTy = dyn_cast<TagType>(TA.getAsType()))\n                  return Visit(TagTy->getDecl());\n               return;\n            case TemplateArgument::Declaration: return Visit(TA.getAsDecl());\n            }\n            llvm_unreachable(\"Invalid TemplateArgument::Kind!\");\n         }\n\n         void VisitClassTemplateSpecializationDecl(const ClassTemplateSpecializationDecl *CTSD)\n         {\n            if (CTSD->getOwningModule())\n               VisitDecl(CTSD);\n            else\n               VisitDecl(CTSD->getSpecializedTemplate());\n            const TemplateArgumentList &ArgList = CTSD->getTemplateArgs();\n            for (const TemplateArgument *Arg = ArgList.data(), *ArgEnd = Arg + ArgList.size(); Arg != ArgEnd; ++Arg) {\n               VisitTemplateArgument(*Arg);\n            }\n         }\n      };\n\n      llvm::DenseSet<Module *> TopLevelModules;\n      ModuleCollector m(TopLevelModules);\n      m.Collect(D);\n      std::string result;\n      for (auto M : TopLevelModules) {\n         // ROOT-unaware modules (i.e. not processed by rootcling) do not have a\n         // link declaration.\n         if (!M->LinkLibraries.size())\n            continue;\n         // We have preloaded the Core module thus libCore.so\n         if (M->Name == \"Core\")\n            continue;\n         assert(M->LinkLibraries.size() == 1);\n         if (!result.empty())\n            result += ' ';\n         result += M->LinkLibraries[0].Library;\n      }\n      return result;\n   }\n   return {};\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the list of shared libraries containing the code for class cls.\n/// The first library in the list is the one containing the class, the\n/// others are the libraries the first one depends on. Returns 0\n/// in case the library is not found.\n\nconst char* TCling::GetClassSharedLibs(const char* cls)\n{\n   if (fCxxModulesEnabled) {\n      llvm::StringRef className = cls;\n      // If we get a class name containing lambda, we cannot parse it and we\n      // can exit early.\n      // FIXME: This works around a bug when we are instantiating a template\n      // make_unique and the substitution fails. Seen in most of the dataframe\n      // tests.\n      if (className.contains(\"(lambda)\"))\n         return nullptr;\n      // Limit the recursion which can be induced by GetClassSharedLibsForModule.\n      SuspendAutoloadingRAII AutoloadingDisabled(this);\n      cling::LookupHelper &LH = fInterpreter->getLookupHelper();\n      std::string libs = GetClassSharedLibsForModule(cls, LH);\n      if (!libs.empty()) {\n         fAutoLoadLibStorage.push_back(libs);\n         return fAutoLoadLibStorage.back().c_str();\n      }\n   }\n\n   if (!cls || !*cls) {\n      return 0;\n   }\n   // lookup class to find list of libraries\n   if (fMapfile) {\n      TEnvRec* libs_record = 0;\n      libs_record = fMapfile->Lookup(cls);\n      if (libs_record) {\n         const char* libs = libs_record->GetValue();\n         return (*libs) ? libs : 0;\n      }\n      else {\n         // Try the old format...\n         TString c = TString(\"Library.\") + cls;\n         // convert \"::\" to \"@@\", we used \"@@\" because TEnv\n         // considers \"::\" a terminator\n         c.ReplaceAll(\"::\", \"@@\");\n         // convert \"-\" to \" \", since class names may have\n         // blanks and TEnv considers a blank a terminator\n         c.ReplaceAll(\" \", \"-\");\n         // Use TEnv::Lookup here as the rootmap file must start with Library.\n         // and do not support using any stars (so we do not need to waste time\n         // with the search made by TEnv::GetValue).\n         TEnvRec* libs_record = 0;\n         libs_record = fMapfile->Lookup(c);\n         if (libs_record) {\n            const char* libs = libs_record->GetValue();\n            return (*libs) ? libs : 0;\n         }\n      }\n   }\n   return 0;\n}\n\n/// This interface returns a list of dependent libraries in the form:\n/// lib libA.so libB.so libC.so. The first library is the library we are\n/// searching dependencies for.\n/// Note: In order to speed up the search, we display the dependencies of the\n/// libraries which are not yet loaded. For instance, if libB.so was already\n/// loaded the list would contain: lib libA.so libC.so.\nstatic std::string GetSharedLibImmediateDepsSlow(std::string lib,\n                                                 cling::Interpreter *interp,\n                                                 bool skipLoadedLibs = true)\n{\n   TString LibFullPath(lib);\n   if (!llvm::sys::path::is_absolute(lib)) {\n      if (!gSystem->FindDynamicLibrary(LibFullPath, /*quiet=*/true)) {\n         Error(\"TCling__GetSharedLibImmediateDepsSlow\", \"Cannot find library '%s'\", lib.c_str());\n         return \"\";\n      }\n   } else {\n      lib = llvm::sys::path::filename(lib);\n   }\n\n   auto ObjF = llvm::object::ObjectFile::createObjectFile(LibFullPath.Data());\n   if (!ObjF) {\n      Warning(\"TCling__GetSharedLibImmediateDepsSlow\", \"Failed to read object file %s\", lib.c_str());\n      return \"\";\n   }\n\n   llvm::object::ObjectFile *BinObjFile = ObjF.get().getBinary();\n\n   std::set<string> DedupSet;\n   std::string Result = lib + ' ';\n   for (const auto &S : BinObjFile->symbols()) {\n      uint32_t Flags = S.getFlags();\n      if (Flags & llvm::object::SymbolRef::SF_Undefined) {\n         llvm::Expected<StringRef> SymNameErr = S.getName();\n         if (!SymNameErr) {\n            Warning(\"GetSharedLibDepsForModule\", \"Failed to read symbol\");\n            continue;\n         }\n         llvm::StringRef SymName = SymNameErr.get();\n         if (SymName.empty())\n            continue;\n\n         if (BinObjFile->isELF()) {\n          // Skip the symbols which are part of the C/C++ runtime and have a\n          // fixed library version. See binutils ld VERSION. Those reside in\n          // 'system' libraries, which we avoid in ResolveSymbol.\n          if (SymName.contains(\"@@GLIBCXX\") || SymName.contains(\"@@CXXABI\") ||\n              SymName.contains(\"@@GLIBC\") || SymName.contains(\"@@GCC\"))\n            continue;\n\n          // Those are 'weak undefined' symbols produced by gcc. We can\n          // ignore them.\n          // FIXME: It is unclear whether we can ignore all weak undefined\n          // symbols:\n          // http://lists.llvm.org/pipermail/llvm-dev/2017-October/118177.html\n          if (SymName == \"_Jv_RegisterClasses\" ||\n              SymName == \"_ITM_deregisterTMCloneTable\" ||\n              SymName == \"_ITM_registerTMCloneTable\")\n            continue;\n      }\n\n         // If we can find the address of the symbol, we have loaded it. Skip.\n         if (skipLoadedLibs && llvm::sys::DynamicLibrary::SearchForAddressOfSymbol(SymName))\n            continue;\n\n         std::string found = ResolveSymbol(SymName, interp, /*searchSystem*/false);\n         // The expected output is just filename without the full path, which\n         // is not very accurate, because our Dyld implementation might find\n         // a match in location a/b/c.so and if we return just c.so ROOT might\n         // resolve it to y/z/c.so and there we might not be ABI compatible.\n         // FIXME: Teach the users of GetSharedLibDeps to work with full paths.\n         if (!found.empty()) {\n            std::string cand = llvm::sys::path::filename(found).str();\n            if (!DedupSet.insert(cand).second)\n               continue;\n\n            Result += cand + ' ';\n         }\n      }\n   }\n\n   return Result;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the list a libraries on which the specified lib depends. The\n/// returned string contains as first element the lib itself.\n/// Returns 0 in case the lib does not exist or does not have\n/// any dependencies. If useDyld is true, we iterate through all available\n/// libraries and try to construct the dependency chain by resolving each\n/// symbol.\n\nconst char* TCling::GetSharedLibDeps(const char* lib, bool useDyld/* = false*/)\n{\n   if (useDyld) {\n      std::string libs = GetSharedLibImmediateDepsSlow(lib, GetInterpreterImpl());\n      if (!libs.empty()) {\n         fAutoLoadLibStorage.push_back(libs);\n         return fAutoLoadLibStorage.back().c_str();\n      }\n   }\n\n   if (!fMapfile || !lib || !lib[0]) {\n      return 0;\n   }\n   TString libname(lib);\n   Ssiz_t idx = libname.Last('.');\n   if (idx != kNPOS) {\n      libname.Remove(idx);\n   }\n   TEnvRec* rec;\n   TIter next(fMapfile->GetTable());\n   size_t len = libname.Length();\n   while ((rec = (TEnvRec*) next())) {\n      const char* libs = rec->GetValue();\n      if (!strncmp(libs, libname.Data(), len) && strlen(libs) >= len\n            && (!libs[len] || libs[len] == ' ' || libs[len] == '.')) {\n         return libs;\n      }\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// If error messages are disabled, the interpreter should suppress its\n/// failures and warning messages from stdout.\n\nBool_t TCling::IsErrorMessagesEnabled() const\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   Warning(\"IsErrorMessagesEnabled\", \"Interface not available yet.\");\n#endif\n#endif\n   return kTRUE;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// If error messages are disabled, the interpreter should suppress its\n/// failures and warning messages from stdout. Return the previous state.\n\nBool_t TCling::SetErrorMessages(Bool_t enable)\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   Warning(\"SetErrorMessages\", \"Interface not available yet.\");\n#endif\n#endif\n   return TCling::IsErrorMessagesEnabled();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Refresh the list of include paths known to the interpreter and return it\n/// with -I prepended.\n\nconst char* TCling::GetIncludePath()\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   fIncludePath = \"\";\n\n   llvm::SmallVector<std::string, 10> includePaths;//Why 10? Hell if I know.\n   //false - no system header, true - with flags.\n   fInterpreter->GetIncludePaths(includePaths, false, true);\n   if (const size_t nPaths = includePaths.size()) {\n      assert(!(nPaths & 1) && \"GetIncludePath, number of paths and options is not equal\");\n\n      for (size_t i = 0; i < nPaths; i += 2) {\n         if (i)\n            fIncludePath.Append(' ');\n         fIncludePath.Append(includePaths[i].c_str());\n\n         if (includePaths[i] != \"-I\")\n            fIncludePath.Append(' ');\n         fIncludePath.Append('\"');\n         fIncludePath.Append(includePaths[i + 1], includePaths[i + 1].length());\n         fIncludePath.Append('\"');\n      }\n   }\n\n   return fIncludePath;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the directory containing CINT's stl cintdlls.\n\nconst char* TCling::GetSTLIncludePath() const\n{\n   return \"\";\n}\n\n//______________________________________________________________________________\n//                      M I S C\n//______________________________________________________________________________\n\nint TCling::DisplayClass(FILE* /*fout*/, const char* /*name*/, int /*base*/, int /*start*/) const\n{\n   // Interface to cling function\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Interface to cling function\n\nint TCling::DisplayIncludePath(FILE *fout) const\n{\n   assert(fout != 0 && \"DisplayIncludePath, 'fout' parameter is null\");\n\n   llvm::SmallVector<std::string, 10> includePaths;//Why 10? Hell if I know.\n   //false - no system header, true - with flags.\n   fInterpreter->GetIncludePaths(includePaths, false, true);\n   if (const size_t nPaths = includePaths.size()) {\n      assert(!(nPaths & 1) && \"DisplayIncludePath, number of paths and options is not equal\");\n\n      std::string allIncludes(\"include path:\");\n      for (size_t i = 0; i < nPaths; i += 2) {\n         allIncludes += ' ';\n         allIncludes += includePaths[i];\n\n         if (includePaths[i] != \"-I\")\n            allIncludes += ' ';\n         allIncludes += includePaths[i + 1];\n      }\n\n      fprintf(fout, \"%s\\n\", allIncludes.c_str());\n   }\n\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Interface to cling function\n\nvoid* TCling::FindSym(const char* entry) const\n{\n   return fInterpreter->getAddressOfGlobal(entry);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Let the interpreter issue a generic error, and set its error state.\n\nvoid TCling::GenericError(const char* error) const\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   Warning(\"GenericError\",\"Interface not available yet.\");\n#endif\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// This routines used to return the address of the internal wrapper\n/// function (of the interpreter) that was used to call *all* the\n/// interpreted functions that were bytecode compiled (no longer\n/// interpreted line by line).  In Cling, there is no such\n/// wrapper function.\n/// In practice this routines was use to decipher whether the\n/// pointer returns by InterfaceMethod could be used to uniquely\n/// represent the function.  In Cling if the function is in a\n/// useable state (its compiled version is available), this is\n/// always the case.\n/// See TClass::GetMethod.\n\nLong_t TCling::GetExecByteCode() const\n{\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Interface to cling function\n\nint TCling::GetSecurityError() const\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   Warning(\"GetSecurityError\", \"Interface not available yet.\");\n#endif\n#endif\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Load a source file or library called path into the interpreter.\n\nint TCling::LoadFile(const char* path) const\n{\n   cling::Interpreter::CompilationResult compRes;\n   HandleInterpreterException(GetMetaProcessorImpl(), TString::Format(\".L %s\", path), compRes, /*cling::Value*/0);\n   return compRes == cling::Interpreter::kFailure;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Load the declarations from text into the interpreter.\n/// Note that this cannot be (top level) statements; text must contain\n/// top level declarations.\n/// Returns true on success, false on failure.\n\nBool_t TCling::LoadText(const char* text) const\n{\n   return (fInterpreter->declare(text) == cling::Interpreter::kSuccess);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Interface to cling function\n\nconst char* TCling::MapCppName(const char* name) const\n{\n   TTHREAD_TLS_DECL(std::string,buffer);\n   ROOT::TMetaUtils::GetCppName(buffer,name);\n   return buffer.c_str();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// [Place holder for Mutex Lock]\n/// Provide the interpreter with a way to\n/// acquire a lock used to protect critical section\n/// of its code (non-thread safe parts).\n\nvoid TCling::SetAlloclockfunc(void (* /* p */ )()) const\n{\n   // nothing to do for now.\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// [Place holder for Mutex Unlock] Provide the interpreter with a way to\n/// release a lock used to protect critical section\n/// of its code (non-thread safe parts).\n\nvoid TCling::SetAllocunlockfunc(void (* /* p */ )()) const\n{\n   // nothing to do for now.\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Returns if class autoloading is currently enabled.\n\nbool TCling::IsClassAutoloadingEnabled() const\n{\n   if (IsFromRootCling())\n      return false;\n   if (!fClingCallbacks)\n      return false;\n   return fClingCallbacks->IsAutoloadingEnabled();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Enable/Disable the Autoloading of libraries.\n/// Returns the old value, i.e whether it was enabled or not.\n\nint TCling::SetClassAutoloading(int autoload) const\n{\n   // If no state change is required, exit early.\n   // FIXME: In future we probably want to complain if we made a request which\n   // was with the same state as before in order to catch programming errors.\n   if ((bool) autoload == IsClassAutoloadingEnabled())\n      return autoload;\n\n   assert(fClingCallbacks && \"We must have callbacks!\");\n   bool oldVal = fClingCallbacks->IsAutoloadingEnabled();\n   fClingCallbacks->SetAutoloadingEnabled(autoload);\n   return oldVal;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Enable/Disable the Autoparsing of headers.\n/// Returns the old value, i.e whether it was enabled or not.\n\nint TCling::SetClassAutoparsing(int autoparse)\n{\n   bool oldVal = fHeaderParsingOnDemand;\n   fHeaderParsingOnDemand = autoparse;\n   return oldVal;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Suspend the Autoparsing of headers.\n/// Returns the old value, i.e whether it was suspended or not.\n\nBool_t TCling::SetSuspendAutoParsing(Bool_t value) {\n   Bool_t old = fIsAutoParsingSuspended;\n   fIsAutoParsingSuspended = value;\n   if (fClingCallbacks) fClingCallbacks->SetAutoParsingSuspended(value);\n   return old;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Set a callback to receive error messages.\n\nvoid TCling::SetErrmsgcallback(void* p) const\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   Warning(\"SetErrmsgcallback\", \"Interface not available yet.\");\n#endif\n#endif\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create / close a scope for temporaries. No-op for cling; use\n/// cling::Value instead.\n\nvoid TCling::SetTempLevel(int val) const\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::UnloadFile(const char* path) const\n{\n   cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();\n   std::string canonical = DLM->lookupLibrary(path);\n   if (canonical.empty()) {\n      canonical = path;\n   }\n   // Unload a shared library or a source file.\n   cling::Interpreter::CompilationResult compRes;\n   HandleInterpreterException(GetMetaProcessorImpl(), Form(\".U %s\", canonical.c_str()), compRes, /*cling::Value*/0);\n   return compRes == cling::Interpreter::kFailure;\n}\n\nstd::unique_ptr<TInterpreterValue> TCling::MakeInterpreterValue() const {\n   return std::unique_ptr<TInterpreterValue>(new TClingValue);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// The call to Cling's tab complition.\n\nvoid TCling::CodeComplete(const std::string& line, size_t& cursor,\n                          std::vector<std::string>& completions)\n{\n   fInterpreter->codeComplete(line, cursor, completions);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the interpreter value corresponding to the statement.\nint TCling::Evaluate(const char* code, TInterpreterValue& value)\n{\n   auto V = reinterpret_cast<cling::Value*>(value.GetValAddr());\n   auto compRes = fInterpreter->evaluate(code, *V);\n   return compRes!=cling::Interpreter::kSuccess ? 0 : 1 ;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::RegisterTemporary(const TInterpreterValue& value)\n{\n   using namespace cling;\n   const Value* V = reinterpret_cast<const Value*>(value.GetValAddr());\n   RegisterTemporary(*V);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Register value as a temporary, extending its lifetime to that of the\n/// interpreter. This is needed for TCling's compatibility interfaces\n/// returning long - the address of the temporary objects.\n/// As such, \"simple\" types don't need to be stored; they are returned by\n/// value; only pointers / references / objects need to be stored.\n\nvoid TCling::RegisterTemporary(const cling::Value& value)\n{\n   if (value.isValid() && value.needsManagedAllocation()) {\n      R__LOCKGUARD(gInterpreterMutex);\n      fTemporaries->push_back(value);\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// If the interpreter encounters Name, check whether that is an object ROOT\n/// could retrieve. To not re-read objects from disk, cache the name/object\n/// pair for a given LookupCtx.\n\nTObject* TCling::GetObjectAddress(const char *Name, void *&LookupCtx)\n{\n   // The call to FindSpecialObject might induces any kind of use\n   // of the interpreter ... (library loading, function calling, etc.)\n   // ... and we _know_ we are in the middle of parsing, so let's make\n   // sure to save the state and then restore it.\n\n   if (gDirectory) {\n      auto iSpecObjMap = fSpecialObjectMaps.find(gDirectory);\n      if (iSpecObjMap != fSpecialObjectMaps.end()) {\n         auto iSpecObj = iSpecObjMap->second.find(Name);\n         if (iSpecObj != iSpecObjMap->second.end()) {\n            LookupCtx = gDirectory;\n            return iSpecObj->second;\n         }\n      }\n   }\n\n   // Save state of the PP\n   Sema &SemaR = fInterpreter->getSema();\n   ASTContext& C = SemaR.getASTContext();\n   Preprocessor &PP = SemaR.getPreprocessor();\n   Parser& P = const_cast<Parser&>(fInterpreter->getParser());\n   Preprocessor::CleanupAndRestoreCacheRAII cleanupRAII(PP);\n   Parser::ParserCurTokRestoreRAII savedCurToken(P);\n   // After we have saved the token reset the current one to something which\n   // is safe (semi colon usually means empty decl)\n   Token& Tok = const_cast<Token&>(P.getCurToken());\n   Tok.setKind(tok::semi);\n\n   // We can't PushDeclContext, because we go up and the routine that pops\n   // the DeclContext assumes that we drill down always.\n   // We have to be on the global context. At that point we are in a\n   // wrapper function so the parent context must be the global.\n   Sema::ContextAndScopeRAII pushedDCAndS(SemaR, C.getTranslationUnitDecl(),\n                                          SemaR.TUScope);\n\n   TObject* specObj = gROOT->FindSpecialObject(Name, LookupCtx);\n   if (specObj) {\n      if (!LookupCtx) {\n         Error(\"GetObjectAddress\", \"Got a special object without LookupCtx!\");\n      } else {\n         fSpecialObjectMaps[LookupCtx][Name] = specObj;\n      }\n   }\n   return specObj;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Inject function as a friend into klass.\n/// With function being f in void f() {new N::PrivKlass(); } this enables\n/// I/O of non-public classes.\n\nvoid TCling::AddFriendToClass(clang::FunctionDecl* function,\n                              clang::CXXRecordDecl* klass) const\n{\n   using namespace clang;\n   ASTContext& Ctx = klass->getASTContext();\n   FriendDecl::FriendUnion friendUnion(function);\n   // one dummy object for the source location\n   SourceLocation sl;\n   FriendDecl* friendDecl = FriendDecl::Create(Ctx, klass, sl, friendUnion, sl);\n   klass->pushFriendDecl(friendDecl);\n}\n\n//______________________________________________________________________________\n//\n//  DeclId getter.\n//\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a unique identifier of the declaration represented by the\n/// CallFunc\n\nTInterpreter::DeclId_t TCling::GetDeclId(CallFunc_t* func) const\n{\n   if (func) return ((TClingCallFunc*)func)->GetDecl()->getCanonicalDecl();\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a (almost) unique identifier of the declaration represented by the\n/// ClassInfo.  In ROOT, this identifier can point to more than one TClass\n/// when the underlying class is a template instance involving one of the\n/// opaque typedef.\n\nTInterpreter::DeclId_t TCling::GetDeclId(ClassInfo_t* cinfo) const\n{\n   if (cinfo) return ((TClingClassInfo*)cinfo)->GetDeclId();\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a unique identifier of the declaration represented by the\n/// MethodInfo\n\nTInterpreter::DeclId_t TCling::GetDeclId(DataMemberInfo_t* data) const\n{\n   if (data) return ((TClingDataMemberInfo*)data)->GetDeclId();\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a unique identifier of the declaration represented by the\n/// MethodInfo\n\nTInterpreter::DeclId_t TCling::GetDeclId(MethodInfo_t* method) const\n{\n   if (method) return ((TClingMethodInfo*)method)->GetDeclId();\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a unique identifier of the declaration represented by the\n/// TypedefInfo\n\nTInterpreter::DeclId_t TCling::GetDeclId(TypedefInfo_t* tinfo) const\n{\n   if (tinfo) return ((TClingTypedefInfo*)tinfo)->GetDecl()->getCanonicalDecl();\n   return 0;\n}\n\n//______________________________________________________________________________\n//\n//  CallFunc interface\n//\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_Delete(CallFunc_t* func) const\n{\n   delete (TClingCallFunc*) func;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_Exec(CallFunc_t* func, void* address) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->Exec(address);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_Exec(CallFunc_t* func, void* address, TInterpreterValue& val) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->Exec(address, &val);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_ExecWithReturn(CallFunc_t* func, void* address, void* ret) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->ExecWithReturn(address, ret);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_ExecWithArgsAndReturn(CallFunc_t* func, void* address,\n                                            const void* args[] /*=0*/,\n                                            int nargs /*=0*/,\n                                            void* ret/*=0*/) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->ExecWithArgsAndReturn(address, args, nargs, ret);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::CallFunc_ExecInt(CallFunc_t* func, void* address) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   return f->ExecInt(address);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong64_t TCling::CallFunc_ExecInt64(CallFunc_t* func, void* address) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   return f->ExecInt64(address);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nDouble_t TCling::CallFunc_ExecDouble(CallFunc_t* func, void* address) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   return f->ExecDouble(address);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nCallFunc_t* TCling::CallFunc_Factory() const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (CallFunc_t*) new TClingCallFunc(GetInterpreterImpl(), *fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nCallFunc_t* TCling::CallFunc_FactoryCopy(CallFunc_t* func) const\n{\n   return (CallFunc_t*) new TClingCallFunc(*(TClingCallFunc*)func);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nMethodInfo_t* TCling::CallFunc_FactoryMethod(CallFunc_t* func) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   return (MethodInfo_t*) f->FactoryMethod();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_IgnoreExtraArgs(CallFunc_t* func, bool ignore) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->IgnoreExtraArgs(ignore);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_Init(CallFunc_t* func) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->Init();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::CallFunc_IsValid(CallFunc_t* func) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   return f->IsValid();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTInterpreter::CallFuncIFacePtr_t\nTCling::CallFunc_IFacePtr(CallFunc_t * func) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   return f->IFacePtr();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_ResetArg(CallFunc_t* func) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->ResetArg();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetArg(CallFunc_t* func, Long_t param) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->SetArg(param);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetArg(CallFunc_t* func, ULong_t param) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->SetArg(param);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetArg(CallFunc_t* func, Float_t param) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->SetArg(param);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetArg(CallFunc_t* func, Double_t param) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->SetArg(param);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetArg(CallFunc_t* func, Long64_t param) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->SetArg(param);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetArg(CallFunc_t* func, ULong64_t param) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->SetArg(param);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetArgArray(CallFunc_t* func, Long_t* paramArr, Int_t nparam) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->SetArgArray(paramArr, nparam);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetArgs(CallFunc_t* func, const char* param) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->SetArgs(param);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetFunc(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* params, Long_t* offset) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   TClingClassInfo* ci = (TClingClassInfo*) info;\n   f->SetFunc(ci, method, params, offset);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetFunc(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* params, bool objectIsConst, Long_t* offset) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   TClingClassInfo* ci = (TClingClassInfo*) info;\n   f->SetFunc(ci, method, params, objectIsConst, offset);\n}\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetFunc(CallFunc_t* func, MethodInfo_t* info) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   TClingMethodInfo* minfo = (TClingMethodInfo*) info;\n   f->SetFunc(minfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Interface to cling function\n\nvoid TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* proto, Long_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   TClingClassInfo* ci = (TClingClassInfo*) info;\n   f->SetFuncProto(ci, method, proto, offset, mode);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Interface to cling function\n\nvoid TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* proto, bool objectIsConst, Long_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   TClingClassInfo* ci = (TClingClassInfo*) info;\n   f->SetFuncProto(ci, method, proto, objectIsConst, offset, mode);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Interface to cling function\n\nvoid TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, Long_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   TClingClassInfo* ci = (TClingClassInfo*) info;\n   llvm::SmallVector<clang::QualType, 4> funcProto;\n   for (std::vector<TypeInfo_t*>::const_iterator iter = proto.begin(), end = proto.end();\n        iter != end; ++iter) {\n      funcProto.push_back( ((TClingTypeInfo*)(*iter))->GetQualType() );\n   }\n   f->SetFuncProto(ci, method, funcProto, offset, mode);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Interface to cling function\n\nvoid TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, bool objectIsConst, Long_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   TClingClassInfo* ci = (TClingClassInfo*) info;\n   llvm::SmallVector<clang::QualType, 4> funcProto;\n   for (std::vector<TypeInfo_t*>::const_iterator iter = proto.begin(), end = proto.end();\n        iter != end; ++iter) {\n      funcProto.push_back( ((TClingTypeInfo*)(*iter))->GetQualType() );\n   }\n   f->SetFuncProto(ci, method, funcProto, objectIsConst, offset, mode);\n}\n\nstd::string TCling::CallFunc_GetWrapperCode(CallFunc_t *func) const\n{\n   TClingCallFunc *f = (TClingCallFunc *)func;\n   std::string wrapper_name;\n   std::string wrapper;\n   f->get_wrapper_code(wrapper_name, wrapper);\n   return wrapper;\n}\n\n//______________________________________________________________________________\n//\n//  ClassInfo interface\n//\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return true if the entity pointed to by 'declid' is declared in\n/// the context described by 'info'.  If info is null, look into the\n/// global scope (translation unit scope).\n\nBool_t TCling::ClassInfo_Contains(ClassInfo_t *info, DeclId_t declid) const\n{\n   if (!declid) return kFALSE;\n\n   const clang::Decl *scope;\n   if (info) scope = ((TClingClassInfo*)info)->GetDecl();\n   else scope = fInterpreter->getCI()->getASTContext().getTranslationUnitDecl();\n\n   const clang::Decl *decl = reinterpret_cast<const clang::Decl*>(declid);\n   const clang::DeclContext *ctxt = clang::Decl::castToDeclContext(scope);\n   if (!decl || !ctxt) return kFALSE;\n   if (decl->getDeclContext()->Equals(ctxt))\n      return kTRUE;\n   else if ((decl->getDeclContext()->isTransparentContext()\n             || decl->getDeclContext()->isInlineNamespace())\n            && decl->getDeclContext()->getParent()->Equals(ctxt))\n      return kTRUE;\n   return kFALSE;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::ClassInfo_ClassProperty(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->ClassProperty();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::ClassInfo_Delete(ClassInfo_t* cinfo) const\n{\n   delete (TClingClassInfo*) cinfo;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::ClassInfo_Delete(ClassInfo_t* cinfo, void* arena) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   TClinginfo->Delete(arena,*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::ClassInfo_DeleteArray(ClassInfo_t* cinfo, void* arena, bool dtorOnly) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   TClinginfo->DeleteArray(arena, dtorOnly,*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::ClassInfo_Destruct(ClassInfo_t* cinfo, void* arena) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   TClinginfo->Destruct(arena,*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nClassInfo_t* TCling::ClassInfo_Factory(Bool_t all) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (ClassInfo_t*) new TClingClassInfo(GetInterpreterImpl(), all);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nClassInfo_t* TCling::ClassInfo_Factory(ClassInfo_t* cinfo) const\n{\n   return (ClassInfo_t*) new TClingClassInfo(*(TClingClassInfo*)cinfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nClassInfo_t* TCling::ClassInfo_Factory(const char* name) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (ClassInfo_t*) new TClingClassInfo(GetInterpreterImpl(), name);\n}\n\nClassInfo_t* TCling::ClassInfo_Factory(DeclId_t declid) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (ClassInfo_t*) new TClingClassInfo(GetInterpreterImpl(), (const clang::Decl*)declid);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::ClassInfo_GetMethodNArg(ClassInfo_t* cinfo, const char* method, const char* proto, Bool_t objectIsConst /* = false */, EFunctionMatchMode mode /* = kConversionMatch */) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->GetMethodNArg(method, proto, objectIsConst, mode);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::ClassInfo_HasDefaultConstructor(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->HasDefaultConstructor();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::ClassInfo_HasMethod(ClassInfo_t* cinfo, const char* name) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->HasMethod(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::ClassInfo_Init(ClassInfo_t* cinfo, const char* name) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   TClinginfo->Init(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::ClassInfo_Init(ClassInfo_t* cinfo, int tagnum) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   TClinginfo->Init(tagnum);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::ClassInfo_IsBase(ClassInfo_t* cinfo, const char* name) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->IsBase(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::ClassInfo_IsEnum(const char* name) const\n{\n   return TClingClassInfo::IsEnum(GetInterpreterImpl(), name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nBool_t TCling::ClassInfo_IsScopedEnum(ClassInfo_t *info) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) info;\n   return TClinginfo->IsScopedEnum();\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nEDataType TCling::ClassInfo_GetUnderlyingType(ClassInfo_t* info) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) info;\n   return TClinginfo->GetUnderlyingType();\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::ClassInfo_IsLoaded(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->IsLoaded();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::ClassInfo_IsValid(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->IsValid();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::ClassInfo_IsValidMethod(ClassInfo_t* cinfo, const char* method, const char* proto, Long_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->IsValidMethod(method, proto, false, offset, mode);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::ClassInfo_IsValidMethod(ClassInfo_t* cinfo, const char* method, const char* proto, Bool_t objectIsConst, Long_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->IsValidMethod(method, proto, objectIsConst, offset, mode);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::ClassInfo_Next(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->Next();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid* TCling::ClassInfo_New(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->New(*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid* TCling::ClassInfo_New(ClassInfo_t* cinfo, int n) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->New(n,*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid* TCling::ClassInfo_New(ClassInfo_t* cinfo, int n, void* arena) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->New(n, arena,*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid* TCling::ClassInfo_New(ClassInfo_t* cinfo, void* arena) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->New(arena,*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::ClassInfo_Property(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->Property();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::ClassInfo_Size(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->Size();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::ClassInfo_Tagnum(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->Tagnum();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::ClassInfo_FileName(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->FileName();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::ClassInfo_FullName(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   TTHREAD_TLS_DECL(std::string,output);\n   TClinginfo->FullName(output,*fNormalizedCtxt);\n   return output.c_str();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::ClassInfo_Name(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->Name();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::ClassInfo_Title(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->Title();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::ClassInfo_TmpltName(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->TmpltName();\n}\n\n\n\n//______________________________________________________________________________\n//\n//  BaseClassInfo interface\n//\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::BaseClassInfo_Delete(BaseClassInfo_t* bcinfo) const\n{\n   delete(TClingBaseClassInfo*) bcinfo;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nBaseClassInfo_t* TCling::BaseClassInfo_Factory(ClassInfo_t* cinfo) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return (BaseClassInfo_t*) new TClingBaseClassInfo(GetInterpreterImpl(), TClinginfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nBaseClassInfo_t* TCling::BaseClassInfo_Factory(ClassInfo_t* derived,\n   ClassInfo_t* base) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) derived;\n   TClingClassInfo* TClinginfoBase = (TClingClassInfo*) base;\n   return (BaseClassInfo_t*) new TClingBaseClassInfo(GetInterpreterImpl(), TClinginfo, TClinginfoBase);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::BaseClassInfo_Next(BaseClassInfo_t* bcinfo) const\n{\n   TClingBaseClassInfo* TClinginfo = (TClingBaseClassInfo*) bcinfo;\n   return TClinginfo->Next();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::BaseClassInfo_Next(BaseClassInfo_t* bcinfo, int onlyDirect) const\n{\n   TClingBaseClassInfo* TClinginfo = (TClingBaseClassInfo*) bcinfo;\n   return TClinginfo->Next(onlyDirect);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::BaseClassInfo_Offset(BaseClassInfo_t* toBaseClassInfo, void * address, bool isDerivedObject) const\n{\n   TClingBaseClassInfo* TClinginfo = (TClingBaseClassInfo*) toBaseClassInfo;\n   return TClinginfo->Offset(address, isDerivedObject);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::ClassInfo_GetBaseOffset(ClassInfo_t* fromDerived, ClassInfo_t* toBase, void * address, bool isDerivedObject) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) fromDerived;\n   TClingClassInfo* TClinginfoBase = (TClingClassInfo*) toBase;\n   // Offset to the class itself.\n   if (TClinginfo->GetDecl() == TClinginfoBase->GetDecl()) {\n      return 0;\n   }\n   return TClinginfo->GetBaseOffset(TClinginfoBase, address, isDerivedObject);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::BaseClassInfo_Property(BaseClassInfo_t* bcinfo) const\n{\n   TClingBaseClassInfo* TClinginfo = (TClingBaseClassInfo*) bcinfo;\n   return TClinginfo->Property();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nClassInfo_t *TCling::BaseClassInfo_ClassInfo(BaseClassInfo_t *bcinfo) const\n{\n   TClingBaseClassInfo* TClinginfo = (TClingBaseClassInfo*) bcinfo;\n   return (ClassInfo_t *)TClinginfo->GetBase();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::BaseClassInfo_Tagnum(BaseClassInfo_t* bcinfo) const\n{\n   TClingBaseClassInfo* TClinginfo = (TClingBaseClassInfo*) bcinfo;\n   return TClinginfo->Tagnum();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::BaseClassInfo_FullName(BaseClassInfo_t* bcinfo) const\n{\n   TClingBaseClassInfo* TClinginfo = (TClingBaseClassInfo*) bcinfo;\n   TTHREAD_TLS_DECL(std::string,output);\n   TClinginfo->FullName(output,*fNormalizedCtxt);\n   return output.c_str();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::BaseClassInfo_Name(BaseClassInfo_t* bcinfo) const\n{\n   TClingBaseClassInfo* TClinginfo = (TClingBaseClassInfo*) bcinfo;\n   return TClinginfo->Name();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::BaseClassInfo_TmpltName(BaseClassInfo_t* bcinfo) const\n{\n   TClingBaseClassInfo* TClinginfo = (TClingBaseClassInfo*) bcinfo;\n   return TClinginfo->TmpltName();\n}\n\n//______________________________________________________________________________\n//\n//  DataMemberInfo interface\n//\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::DataMemberInfo_ArrayDim(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->ArrayDim();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::DataMemberInfo_Delete(DataMemberInfo_t* dminfo) const\n{\n   delete(TClingDataMemberInfo*) dminfo;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nDataMemberInfo_t* TCling::DataMemberInfo_Factory(ClassInfo_t* clinfo /*= 0*/) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClingClassInfo* TClingclass_info = (TClingClassInfo*) clinfo;\n   return (DataMemberInfo_t*) new TClingDataMemberInfo(GetInterpreterImpl(), TClingclass_info);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nDataMemberInfo_t* TCling::DataMemberInfo_Factory(DeclId_t declid, ClassInfo_t* clinfo) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   const clang::Decl* decl = reinterpret_cast<const clang::Decl*>(declid);\n   const clang::ValueDecl* vd = llvm::dyn_cast_or_null<clang::ValueDecl>(decl);\n   return (DataMemberInfo_t*) new TClingDataMemberInfo(GetInterpreterImpl(), vd, (TClingClassInfo*)clinfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nDataMemberInfo_t* TCling::DataMemberInfo_FactoryCopy(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return (DataMemberInfo_t*) new TClingDataMemberInfo(*TClinginfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::DataMemberInfo_IsValid(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->IsValid();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::DataMemberInfo_MaxIndex(DataMemberInfo_t* dminfo, Int_t dim) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->MaxIndex(dim);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::DataMemberInfo_Next(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->Next();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::DataMemberInfo_Offset(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->Offset();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::DataMemberInfo_Property(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->Property();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::DataMemberInfo_TypeProperty(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->TypeProperty();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::DataMemberInfo_TypeSize(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->TypeSize();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::DataMemberInfo_TypeName(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->TypeName();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::DataMemberInfo_TypeTrueName(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->TypeTrueName(*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::DataMemberInfo_Name(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->Name();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::DataMemberInfo_Title(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->Title();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::DataMemberInfo_ValidArrayIndex(DataMemberInfo_t* dminfo) const\n{\n   TTHREAD_TLS_DECL(std::string,result);\n\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   result = TClinginfo->ValidArrayIndex().str();\n   return result.c_str();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::SetDeclAttr(DeclId_t declId, const char* attribute)\n{\n   Decl* decl = static_cast<Decl*>(const_cast<void*>(declId));\n   ASTContext &C = decl->getASTContext();\n   SourceRange commentRange; // this is a fake comment range\n   decl->addAttr( new (C) AnnotateAttr( commentRange, C, attribute, 0 ) );\n}\n\n//______________________________________________________________________________\n//\n// Function Template interface\n//\n\n////////////////////////////////////////////////////////////////////////////////\n\nstatic void ConstructorName(std::string &name, const clang::NamedDecl *decl,\n                            cling::Interpreter &interp,\n                            const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt)\n{\n   const clang::TypeDecl* td = llvm::dyn_cast<clang::TypeDecl>(decl->getDeclContext());\n   if (!td) return;\n\n   clang::QualType qualType(td->getTypeForDecl(),0);\n   ROOT::TMetaUtils::GetNormalizedName(name, qualType, interp, normCtxt);\n   unsigned int level = 0;\n   for(size_t cursor = name.length()-1; cursor != 0; --cursor) {\n      if (name[cursor] == '>') ++level;\n      else if (name[cursor] == '<' && level) --level;\n      else if (level == 0 && name[cursor] == ':') {\n         name.erase(0,cursor+1);\n         break;\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::GetFunctionName(const clang::FunctionDecl *decl, std::string &output) const\n{\n   output.clear();\n   if (llvm::isa<clang::CXXConstructorDecl>(decl))\n   {\n      ConstructorName(output, decl, *fInterpreter, *fNormalizedCtxt);\n\n   } else if (llvm::isa<clang::CXXDestructorDecl>(decl))\n   {\n      ConstructorName(output, decl, *fInterpreter, *fNormalizedCtxt);\n      output.insert(output.begin(), '~');\n   } else {\n      llvm::raw_string_ostream stream(output);\n      auto printPolicy = decl->getASTContext().getPrintingPolicy();\n      // Don't trigger fopen of the source file to count lines:\n      printPolicy.AnonymousTagLocations = false;\n      decl->getNameForDiagnostic(stream, printPolicy, /*Qualified=*/false);\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a unique identifier of the declaration represented by the\n/// FuncTempInfo\n\nTInterpreter::DeclId_t TCling::GetDeclId(FuncTempInfo_t *info) const\n{\n   return (DeclId_t)info;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Delete the FuncTempInfo_t\n\nvoid   TCling::FuncTempInfo_Delete(FuncTempInfo_t * /* ft_info */) const\n{\n   // Currently the address of ft_info is actually the decl itself,\n   // so we have nothing to do.\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Construct a FuncTempInfo_t\n\nFuncTempInfo_t *TCling::FuncTempInfo_Factory(DeclId_t declid) const\n{\n   // Currently the address of ft_info is actually the decl itself,\n   // so we have nothing to do.\n\n   return (FuncTempInfo_t*)const_cast<void*>(declid);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Construct a FuncTempInfo_t\n\nFuncTempInfo_t *TCling::FuncTempInfo_FactoryCopy(FuncTempInfo_t *ft_info) const\n{\n   // Currently the address of ft_info is actually the decl itself,\n   // so we have nothing to do.\n\n   return (FuncTempInfo_t*)ft_info;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Check validity of a FuncTempInfo_t\n\nBool_t TCling::FuncTempInfo_IsValid(FuncTempInfo_t *t_info) const\n{\n   // Currently the address of ft_info is actually the decl itself,\n   // so we have nothing to do.\n\n   return t_info != 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the maximum number of template arguments of the\n/// function template described by ft_info.\n\nUInt_t TCling::FuncTempInfo_TemplateNargs(FuncTempInfo_t *ft_info) const\n{\n   if (!ft_info) return 0;\n   const clang::FunctionTemplateDecl *ft = (const clang::FunctionTemplateDecl*)ft_info;\n   return ft->getTemplateParameters()->size();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the number of required template arguments of the\n/// function template described by ft_info.\n\nUInt_t TCling::FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t *ft_info) const\n{\n   if (!ft_info) return 0;\n   const clang::FunctionTemplateDecl *ft = (clang::FunctionTemplateDecl*)ft_info;\n   return ft->getTemplateParameters()->getMinRequiredArguments();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the property of the function template.\n\nLong_t TCling::FuncTempInfo_Property(FuncTempInfo_t *ft_info) const\n{\n   if (!ft_info) return 0;\n\n   long property = 0L;\n   property |= kIsCompiled;\n\n   const clang::FunctionTemplateDecl *ft = (clang::FunctionTemplateDecl*)ft_info;\n\n   switch (ft->getAccess()) {\n      case clang::AS_public:\n         property |= kIsPublic;\n         break;\n      case clang::AS_protected:\n         property |= kIsProtected;\n         break;\n      case clang::AS_private:\n         property |= kIsPrivate;\n         break;\n      case clang::AS_none:\n         if (ft->getDeclContext()->isNamespace())\n            property |= kIsPublic;\n         break;\n      default:\n         // IMPOSSIBLE\n         break;\n   }\n\n   const clang::FunctionDecl *fd = ft->getTemplatedDecl();\n   if (const clang::CXXMethodDecl *md =\n       llvm::dyn_cast<clang::CXXMethodDecl>(fd)) {\n      if (md->getTypeQualifiers() & clang::Qualifiers::Const) {\n         property |= kIsConstant | kIsConstMethod;\n      }\n      if (md->isVirtual()) {\n         property |= kIsVirtual;\n      }\n      if (md->isPure()) {\n         property |= kIsPureVirtual;\n      }\n      if (const clang::CXXConstructorDecl *cd =\n          llvm::dyn_cast<clang::CXXConstructorDecl>(md)) {\n         if (cd->isExplicit()) {\n            property |= kIsExplicit;\n         }\n      }\n      else if (const clang::CXXConversionDecl *cd =\n               llvm::dyn_cast<clang::CXXConversionDecl>(md)) {\n         if (cd->isExplicit()) {\n            property |= kIsExplicit;\n         }\n      }\n   }\n   return property;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the property not already defined in Property\n/// See TDictionary's EFunctionProperty\n\nLong_t TCling::FuncTempInfo_ExtraProperty(FuncTempInfo_t* ft_info) const\n{\n   if (!ft_info) return 0;\n\n   long property = 0L;\n   property |= kIsCompiled;\n\n   const clang::FunctionTemplateDecl *ft = (clang::FunctionTemplateDecl*)ft_info;\n   const clang::FunctionDecl *fd = ft->getTemplatedDecl();\n\n   if (fd->isOverloadedOperator())\n      property |= kIsOperator;\n   if (llvm::isa<clang::CXXConversionDecl>(fd))\n      property |= kIsConversion;\n   if (llvm::isa<clang::CXXConstructorDecl>(fd))\n      property |= kIsConstructor;\n   if (llvm::isa<clang::CXXDestructorDecl>(fd))\n      property |= kIsDestructor;\n   if (fd->isInlined())\n      property |= kIsInlined;\n   return property;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the name of this function template.\n\nvoid TCling::FuncTempInfo_Name(FuncTempInfo_t *ft_info, TString &output) const\n{\n   output.Clear();\n   if (!ft_info) return;\n   const clang::FunctionTemplateDecl *ft = (clang::FunctionTemplateDecl*)ft_info;\n   std::string buf;\n   GetFunctionName(ft->getTemplatedDecl(), buf);\n   output = buf;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the comments associates with this function template.\n\nvoid TCling::FuncTempInfo_Title(FuncTempInfo_t *ft_info, TString &output) const\n{\n   output.Clear();\n   if (!ft_info) return;\n   const clang::FunctionTemplateDecl *ft = (const clang::FunctionTemplateDecl*)ft_info;\n\n   // Iterate over the redeclarations, we can have multiple definitions in the\n   // redecl chain (came from merging of pcms).\n   if (const RedeclarableTemplateDecl *AnnotFD\n       = ROOT::TMetaUtils::GetAnnotatedRedeclarable((const RedeclarableTemplateDecl*)ft)) {\n      if (AnnotateAttr *A = AnnotFD->getAttr<AnnotateAttr>()) {\n         output = A->getAnnotation().str();\n         return;\n      }\n   }\n   if (!ft->isFromASTFile()) {\n      // Try to get the comment from the header file if present\n      // but not for decls from AST file, where rootcling would have\n      // created an annotation\n      output = ROOT::TMetaUtils::GetComment(*ft).str();\n   }\n}\n\n\n//______________________________________________________________________________\n//\n//  MethodInfo interface\n//\n\n////////////////////////////////////////////////////////////////////////////////\n/// Interface to cling function\n\nvoid TCling::MethodInfo_Delete(MethodInfo_t* minfo) const\n{\n   delete(TClingMethodInfo*) minfo;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::MethodInfo_CreateSignature(MethodInfo_t* minfo, TString& signature) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   info->CreateSignature(signature);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nMethodInfo_t* TCling::MethodInfo_Factory() const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (MethodInfo_t*) new TClingMethodInfo(GetInterpreterImpl());\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nMethodInfo_t* TCling::MethodInfo_Factory(ClassInfo_t* clinfo) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (MethodInfo_t*) new TClingMethodInfo(GetInterpreterImpl(), (TClingClassInfo*)clinfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nMethodInfo_t* TCling::MethodInfo_Factory(DeclId_t declid) const\n{\n   const clang::Decl* decl = reinterpret_cast<const clang::Decl*>(declid);\n   R__LOCKGUARD(gInterpreterMutex);\n   const clang::FunctionDecl* fd = llvm::dyn_cast_or_null<clang::FunctionDecl>(decl);\n   return (MethodInfo_t*) new TClingMethodInfo(GetInterpreterImpl(), fd);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nMethodInfo_t* TCling::MethodInfo_FactoryCopy(MethodInfo_t* minfo) const\n{\n   return (MethodInfo_t*) new TClingMethodInfo(*(TClingMethodInfo*)minfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid* TCling::MethodInfo_InterfaceMethod(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->InterfaceMethod(*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::MethodInfo_IsValid(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->IsValid();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::MethodInfo_NArg(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->NArg();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::MethodInfo_NDefaultArg(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->NDefaultArg();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::MethodInfo_Next(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->Next();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::MethodInfo_Property(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->Property();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::MethodInfo_ExtraProperty(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->ExtraProperty();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTypeInfo_t* TCling::MethodInfo_Type(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return (TypeInfo_t*)info->Type();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::MethodInfo_GetMangledName(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   TTHREAD_TLS_DECL(TString, mangled_name);\n   mangled_name = info->GetMangledName();\n   return mangled_name;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::MethodInfo_GetPrototype(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->GetPrototype();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::MethodInfo_Name(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->Name();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::MethodInfo_TypeName(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->TypeName();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstd::string TCling::MethodInfo_TypeNormalizedName(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   if (info && info->IsValid())\n      return info->Type()->NormalizedName(*fNormalizedCtxt);\n   else\n      return \"\";\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::MethodInfo_Title(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->Title();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nauto TCling::MethodCallReturnType(TFunction *func) const -> EReturnType\n{\n   if (func) {\n      return MethodInfo_MethodCallReturnType(func->fInfo);\n   } else {\n      return EReturnType::kOther;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nauto TCling::MethodInfo_MethodCallReturnType(MethodInfo_t* minfo) const -> EReturnType\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   if (info && info->IsValid()) {\n      TClingTypeInfo *typeinfo = info->Type();\n      clang::QualType QT( typeinfo->GetQualType().getCanonicalType() );\n      if (QT->isEnumeralType()) {\n         return EReturnType::kLong;\n      } else if (QT->isPointerType()) {\n         // Look for char*\n         QT = llvm::cast<clang::PointerType>(QT)->getPointeeType();\n         if ( QT->isCharType() ) {\n            return EReturnType::kString;\n         } else {\n            return EReturnType::kOther;\n         }\n      } else if ( QT->isFloatingType() ) {\n         int sz = typeinfo->Size();\n         if (sz == 4 || sz == 8) {\n            // Support only float and double.\n            return EReturnType::kDouble;\n         } else {\n            return EReturnType::kOther;\n         }\n      } else if ( QT->isIntegerType() ) {\n         int sz = typeinfo->Size();\n         if (sz <= 8) {\n            // Support only up to long long ... but\n            // FIXME the TMethodCall::Execute only\n            // return long (4 bytes) ...\n            // The v5 implementation of TMethodCall::ReturnType\n            // was not making the distinction so we let it go\n            // as is for now, but we really need to upgrade\n            // TMethodCall::Execute ...\n            return EReturnType::kLong;\n         } else {\n            return EReturnType::kOther;\n         }\n      } else {\n         return EReturnType::kOther;\n      }\n   } else {\n      return EReturnType::kOther;\n   }\n}\n\n//______________________________________________________________________________\n//\n//  MethodArgInfo interface\n//\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::MethodArgInfo_Delete(MethodArgInfo_t* marginfo) const\n{\n   delete(TClingMethodArgInfo*) marginfo;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nMethodArgInfo_t* TCling::MethodArgInfo_Factory() const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (MethodArgInfo_t*) new TClingMethodArgInfo(GetInterpreterImpl());\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nMethodArgInfo_t* TCling::MethodArgInfo_Factory(MethodInfo_t *minfo) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (MethodArgInfo_t*) new TClingMethodArgInfo(GetInterpreterImpl(), (TClingMethodInfo*)minfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nMethodArgInfo_t* TCling::MethodArgInfo_FactoryCopy(MethodArgInfo_t* marginfo) const\n{\n   return (MethodArgInfo_t*)\n          new TClingMethodArgInfo(*(TClingMethodArgInfo*)marginfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::MethodArgInfo_IsValid(MethodArgInfo_t* marginfo) const\n{\n   TClingMethodArgInfo* info = (TClingMethodArgInfo*) marginfo;\n   return info->IsValid();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::MethodArgInfo_Next(MethodArgInfo_t* marginfo) const\n{\n   TClingMethodArgInfo* info = (TClingMethodArgInfo*) marginfo;\n   return info->Next();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::MethodArgInfo_Property(MethodArgInfo_t* marginfo) const\n{\n   TClingMethodArgInfo* info = (TClingMethodArgInfo*) marginfo;\n   return info->Property();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::MethodArgInfo_DefaultValue(MethodArgInfo_t* marginfo) const\n{\n   TClingMethodArgInfo* info = (TClingMethodArgInfo*) marginfo;\n   return info->DefaultValue();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::MethodArgInfo_Name(MethodArgInfo_t* marginfo) const\n{\n   TClingMethodArgInfo* info = (TClingMethodArgInfo*) marginfo;\n   return info->Name();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::MethodArgInfo_TypeName(MethodArgInfo_t* marginfo) const\n{\n   TClingMethodArgInfo* info = (TClingMethodArgInfo*) marginfo;\n   return info->TypeName();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstd::string TCling::MethodArgInfo_TypeNormalizedName(MethodArgInfo_t* marginfo) const\n{\n   TClingMethodArgInfo* info = (TClingMethodArgInfo*) marginfo;\n   return info->Type()->NormalizedName(*fNormalizedCtxt);\n}\n\n//______________________________________________________________________________\n//\n//  TypeInfo interface\n//\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::TypeInfo_Delete(TypeInfo_t* tinfo) const\n{\n   delete (TClingTypeInfo*) tinfo;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTypeInfo_t* TCling::TypeInfo_Factory() const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (TypeInfo_t*) new TClingTypeInfo(GetInterpreterImpl());\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTypeInfo_t* TCling::TypeInfo_Factory(const char *name) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (TypeInfo_t*) new TClingTypeInfo(GetInterpreterImpl(), name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTypeInfo_t* TCling::TypeInfo_FactoryCopy(TypeInfo_t* tinfo) const\n{\n   return (TypeInfo_t*) new TClingTypeInfo(*(TClingTypeInfo*)tinfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::TypeInfo_Init(TypeInfo_t* tinfo, const char* name) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClingTypeInfo* TClinginfo = (TClingTypeInfo*) tinfo;\n   TClinginfo->Init(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::TypeInfo_IsValid(TypeInfo_t* tinfo) const\n{\n   TClingTypeInfo* TClinginfo = (TClingTypeInfo*) tinfo;\n   return TClinginfo->IsValid();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::TypeInfo_Name(TypeInfo_t* tinfo) const\n{\n   TClingTypeInfo* TClinginfo = (TClingTypeInfo*) tinfo;\n   return TClinginfo->Name();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::TypeInfo_Property(TypeInfo_t* tinfo) const\n{\n   TClingTypeInfo* TClinginfo = (TClingTypeInfo*) tinfo;\n   return TClinginfo->Property();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::TypeInfo_RefType(TypeInfo_t* tinfo) const\n{\n   TClingTypeInfo* TClinginfo = (TClingTypeInfo*) tinfo;\n   return TClinginfo->RefType();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::TypeInfo_Size(TypeInfo_t* tinfo) const\n{\n   TClingTypeInfo* TClinginfo = (TClingTypeInfo*) tinfo;\n   return TClinginfo->Size();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::TypeInfo_TrueName(TypeInfo_t* tinfo) const\n{\n   TClingTypeInfo* TClinginfo = (TClingTypeInfo*) tinfo;\n   return TClinginfo->TrueName(*fNormalizedCtxt);\n}\n\n\n//______________________________________________________________________________\n//\n//  TypedefInfo interface\n//\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::TypedefInfo_Delete(TypedefInfo_t* tinfo) const\n{\n   delete(TClingTypedefInfo*) tinfo;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTypedefInfo_t* TCling::TypedefInfo_Factory() const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (TypedefInfo_t*) new TClingTypedefInfo(GetInterpreterImpl());\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTypedefInfo_t* TCling::TypedefInfo_Factory(const char *name) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (TypedefInfo_t*) new TClingTypedefInfo(GetInterpreterImpl(), name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTypedefInfo_t* TCling::TypedefInfo_FactoryCopy(TypedefInfo_t* tinfo) const\n{\n   return (TypedefInfo_t*) new TClingTypedefInfo(*(TClingTypedefInfo*)tinfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::TypedefInfo_Init(TypedefInfo_t* tinfo,\n                              const char* name) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClingTypedefInfo* TClinginfo = (TClingTypedefInfo*) tinfo;\n   TClinginfo->Init(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::TypedefInfo_IsValid(TypedefInfo_t* tinfo) const\n{\n   TClingTypedefInfo* TClinginfo = (TClingTypedefInfo*) tinfo;\n   return TClinginfo->IsValid();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nInt_t TCling::TypedefInfo_Next(TypedefInfo_t* tinfo) const\n{\n   TClingTypedefInfo* TClinginfo = (TClingTypedefInfo*) tinfo;\n   return TClinginfo->Next();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::TypedefInfo_Property(TypedefInfo_t* tinfo) const\n{\n   TClingTypedefInfo* TClinginfo = (TClingTypedefInfo*) tinfo;\n   return TClinginfo->Property();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::TypedefInfo_Size(TypedefInfo_t* tinfo) const\n{\n   TClingTypedefInfo* TClinginfo = (TClingTypedefInfo*) tinfo;\n   return TClinginfo->Size();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::TypedefInfo_TrueName(TypedefInfo_t* tinfo) const\n{\n   TClingTypedefInfo* TClinginfo = (TClingTypedefInfo*) tinfo;\n   return TClinginfo->TrueName(*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::TypedefInfo_Name(TypedefInfo_t* tinfo) const\n{\n   TClingTypedefInfo* TClinginfo = (TClingTypedefInfo*) tinfo;\n   return TClinginfo->Name();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::TypedefInfo_Title(TypedefInfo_t* tinfo) const\n{\n   TClingTypedefInfo* TClinginfo = (TClingTypedefInfo*) tinfo;\n   return TClinginfo->Title();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::SnapshotMutexState(ROOT::TVirtualRWMutex* mtx)\n{\n   if (!fInitialMutex.back()) {\n      if (fInitialMutex.back().fRecurseCount) {\n         Error(\"SnapshotMutexState\", \"fRecurseCount != 0 even though initial mutex state is unset!\");\n      }\n      fInitialMutex.back().fState = mtx->GetStateBefore();\n   }\n   // We will \"forget\" this lock once we backed out of all interpreter frames.\n   // Here we are entering one, so ++.\n   ++fInitialMutex.back().fRecurseCount;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::ForgetMutexState()\n{\n   if (!fInitialMutex.back())\n      return;\n   if (fInitialMutex.back().fRecurseCount == 0) {\n      Error(\"ForgetMutexState\", \"mutex state's recurse count already 0!\");\n   }\n   else if (--fInitialMutex.back().fRecurseCount == 0) {\n      // We have returned from all interpreter frames. Reset the initial lock state.\n      fInitialMutex.back().fState.reset();\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Re-apply the lock count delta that TCling__ResetInterpreterMutex() caused.\n\nvoid TCling::ApplyToInterpreterMutex(void *delta)\n{\n   R__ASSERT(!fInitialMutex.empty() && \"Inconsistent state of fInitialMutex!\");\n   if (gInterpreterMutex) {\n      if (delta) {\n         auto typedDelta = static_cast<TVirtualRWMutex::StateDelta *>(delta);\n         std::unique_ptr<TVirtualRWMutex::StateDelta> uniqueP{typedDelta};\n         gCoreMutex->Apply(std::move(uniqueP));\n      }\n   }\n   fInitialMutex.pop_back();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Reset the interpreter lock to the state it had before interpreter-related\n/// calls happened.\n\nvoid *TCling::RewindInterpreterMutex()\n{\n   if (fInitialMutex.back()) {\n      std::unique_ptr<TVirtualRWMutex::StateDelta> uniqueP = gCoreMutex->Rewind(*fInitialMutex.back().fState);\n      // Need to start a new recurse count.\n      fInitialMutex.emplace_back();\n      return uniqueP.release();\n   }\n   // Need to start a new recurse count.\n   fInitialMutex.emplace_back();\n   return nullptr;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/etc/valgrind-root.supp": "# Additional valgrind suppression file for ROOT.\n#\n# To use, run valgrind with:\n#   valgrind --suppressions=$ROOTSYS/etc/valgrind-root.supp ...\n#\n# This file suppresses known and expected / inevitable valgrind\n# reports, e.g. due to ROOT's runtime type information that must\n# survive until the end of the process and thus leaks.\n# It only suppresses leaks, and a few errors generated by X11.\n\n######### ROOT's RTTI\n{\n   TClass::AddClass()'s std::string\n   Memcheck:Leak\n   fun:_Znw?\n   fun:_ZNSs4_Rep9_S_createE??RKSaIcE\n   ...\n   fun:_ZNSsC1EPKcRKSaIcE\n   fun:_ZN6TClass8AddClassEPS_\n}\n\n{\n   TQClass\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN8TStorage11ObjectAllocEm\n   fun:_ZN7TObjectnwEm\n   fun:_ZNK4ROOT8Internal20TQObjectInitBehavior11CreateClassEPKcsRKSt9type_infoP16TVirtualIsAProxyS3_S3_ii\n   fun:_ZN4ROOT17TGenericClassInfo8GetClassEv\n}\n\n{\n   TCling::CreateListOfBaseClasses(TClass*)\n   Memcheck:Leak\n   fun:_Znw?\n   fun:_ZN8TStorage11ObjectAllocE?\n   fun:_ZN5TCling23CreateListOfBaseClassesEP6TClass\n}\n\n{\n   <insert_a_suppression_name_here>\n   Memcheck:Leak\n   fun:_Znw?\n   fun:_ZN5TList7NewLinkEP7TObjectP8TObjLink\n   fun:_ZN5TList7AddLastEP7TObject\n   fun:_ZN5TCling23CreateListOfBaseClassesEP6TClass\n}\n\n{\n   TGenericClassInfo's fClass generated by ROOT::TQObjectInitBehavior::CreateClass()\n   Memcheck:Leak\n   fun:_Znw?\n   fun:_ZN8TStorage11ObjectAllocE?\n   fun:_ZN7TObjectnwE?\n   fun:_ZNK4ROOT20TQObjectInitBehavior11CreateClassEPKcsRKSt9type_info*\n}\n\n{\n   TClass long name\n   Memcheck:Leak\n   fun:_Zna?\n   fun:_ZN7TString4InitEii\n   fun:_ZN7TStringC1EPKc\n   fun:_ZN6TClassC2EPKc*\n}\n\n{\n   TDictionary long name\n   Memcheck:Leak\n   fun:_Zna?\n   fun:_ZN7TString4InitEii\n   fun:_ZN7TStringC1EPKc\n   fun:_ZN6TNamedC1EPKcS1_\n   fun:_ZN11TDictionaryC1EPKc\n}\n\n{\n   TBaseClass long name\n   Memcheck:Leak\n   fun:_Zna?\n   fun:_ZN7TString7ReplaceEiiPKci\n   fun:_ZN7TStringaSEPKc\n   fun:_ZN6TNamed7SetNameEPKc\n   fun:_ZN10TBaseClassC1EPvP6TClass\n}\n\n{\n   TDataType long name\n   Memcheck:Leak\n   fun:_Zna?\n   fun:_ZN7TString7ReplaceEiiPKci\n   fun:_ZN7TStringaSEPKc\n   ...\n   fun:_ZN9TDataTypeC1EPv\n}\n\n{\n   TMethod title\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN7TMethodC1EP12MethodInfo_tP6TClass\n}\n\n{\n   TDataMember title\n   Memcheck:Leak\n   match-leak-kinds: possible\n   ...\n   fun:_ZNK4llvm9StringRefcvSsEv\n   fun:_ZN4ROOT10TMetaUtils17extractAttrStringEPN5clang4AttrERSs\n   fun:_ZN20TClingDataMemberInfo5TitleEv\n   fun:_ZNK6TCling20DataMemberInfo_TitleEP16DataMemberInfo_t\n}\n\n{\n   TDataMember strings\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   ...\n   fun:_ZN11TDataMember4InitEb\n   fun:_ZN11TDataMemberC1EP16DataMemberInfo_tP6TClass\n   fun:_ZN18TListOfDataMembers3GetEP16DataMemberInfo_tb\n}\n\n{\n   TDataMember list of options\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN5TList7NewLinkEP7TObjectP8TObjLink\n   fun:_ZN5TList7AddLastEP7TObject\n   fun:_ZN5TList3AddEP7TObject\n   fun:_ZN11TDataMember4InitEb\n }\n\n{\n   Anything allocated by TClass::Init: new[]()\n   Memcheck:Leak\n   fun:_Zna?\n   ...\n   fun:_ZN6TClass4InitEPKcs*\n}\n\n{\n   Anything allocated by TClass::Init: new()\n   Memcheck:Leak\n   fun:_Znw?\n   ...\n   fun:_ZN6TClass4InitEPKcs*\n}\n\n{\n   TClass thread local storage\n   Memcheck:Leak\n   fun:_Znw?\n   fun:_ZN8TStorage11ObjectAllocE?\n   fun:_ZN7TObjectnwE?\n   fun:_ZN12_GLOBAL__N_118TClassLocalStorage10GetStorageEPK6TClass\n}\n\n{\n   TThread global mutex\n   Memcheck:Leak\n   fun:_Znw?\n   fun:_ZN8TStorage11ObjectAllocE?\n   fun:_ZN7TObjectnwE?\n   fun:_ZN7TThread4InitEv\n}\n\n{\n   TClass's list of base classes (TDataMember elements)\n   Memcheck:Leak\n   fun:_Znw?\n   fun:_ZN5TList7NewLinkEP7TObjectP8TObjLink\n   fun:_ZN5TList7AddLastEP7TObject\n   fun:_ZN5TList3AddEP7TObject\n   fun:_ZN5TCling23CreateListOfBaseClassesEP6TClass\n}\n\n{\n   TClass's list of base classes (G__DataMemberInfo elements)\n   Memcheck:Leak\n   fun:_Znw?\n   fun:_ZN5TCling23CreateListOfBaseClassesEP6TClass\n}\n\n{\n   TClass's list of base classes (TList container)\n   Memcheck:Leak\n   fun:_Znw?\n   fun:_ZN8TStorage11ObjectAllocE?\n   fun:_ZN7TObjectnwE?\n   fun:_ZN5TCling23CreateListOfBaseClassesEP6TClass\n}\n\n{\n   Unloaded TClass and its fClassInfo\n   Memcheck:Leak\n   fun:_Znw?\n   fun:_ZN*TCling12SetClassInfoEP6TClassb\n   fun:_ZN6TClass11SetUnloadedEv\n}\n\n{\n   TClass::Init calling TCling::SetClassInfo\n   Memcheck:Leak\n   fun:_Znw?\n   fun:_ZN5TCling12SetClassInfoEP6TClassb\n   fun:_ZN6TClass4InitEPKcsPKSt9type_infoP16TVirtualIsAProxyPFvPvR16TMemberInspectorES1_S1_iib\n}\n\n{\n   std::string uses in various place.\n   Memcheck:Leak\n   fun:_Znw?\n   fun:_ZNSs4_Rep9_S_createE??RKSaIcE\n   fun:_ZNSs9_M_mutateE???\n   fun:_ZNSs15_M_replace_safeE??PKc?\n}\n\n{\n   Array of objects allocated in TStreamerInfo::Compile\n   Memcheck:Leak\n   fun:_Zna?\n   fun:_ZN13TStreamerInfo7CompileEv\n}\n\n{\n   Strings allocated in TStreamerInfo::Compile\n   Memcheck:Leak\n   fun:_Zna?\n   fun:_ZN7TString7ReplaceEiiPKci\n   fun:_ZN7TStringaSERK10TSubString\n   fun:_ZN13TStreamerInfo7CompileEv\n}\n\n{\n   String reallocated in TStreamerInfo::Compile\n   Memcheck:Leak\n   fun:_Zna?\n   fun:_ZN7TString7ReplaceEiiPKci\n   fun:_ZN13TStreamerInfo7CompileEv\n\n}\n\n{\n   StreamerInfo virtual table mechanism\n   Memcheck:Leak\n   fun:_Zna?\n   fun:_ZN13TStreamerInfo8BuildOldEv\n   fun:_ZNK6TClass15GetStreamerInfoEi\n}\n\n{\n   StreamerInfo parts\n   Memcheck:Leak\n   fun:_Znw?\n   fun:_ZN8TStorage11ObjectAllocE?\n   fun:_ZN7TObjectnwE?\n   fun:_ZN4ROOTL13new_TObjArrayEPv\n   fun:_ZNK6TClass3NewENS_8ENewTypeE\n   fun:_ZN11TBufferFile13ReadObjectAnyEPK6TClass\n   fun:_ZrsI9TObjArrayER7TBufferS2_RPT_\n   fun:_ZN13TStreamerInfo8StreamerER7TBuffer\n}\n\n{\n   StreamerInfo parts\n   Memcheck:Leak\n   fun:_Zna?\n   fun:_ZN8TStorage5AllocE?\n   fun:_ZN9TObjArray4InitEii\n   fun:_ZN9TObjArrayC1Eii\n   fun:_ZN4ROOTL13new_TObjArrayEPv\n   fun:_ZNK6TClass3NewENS_8ENewTypeE\n   fun:_ZN11TBufferFile13ReadObjectAnyEPK6TClass\n   fun:_ZrsI9TObjArrayER7TBufferS2_RPT_\n   fun:_ZN13TStreamerInfo8StreamerER7TBuffer\n}\n\n{\n   CollectionProxy objects\n   Memcheck:Leak\n   fun:_Znw?\n   fun:_ZN23TCollectionProxyFactory24GenEmulatedClassStreamerEPKc\n}\n\n{\n   CollectionProxy objects\n   Memcheck:Leak\n   fun:_Znw?\n   fun:_ZNK19TGenCollectionProxy8GenerateEv\n   fun:_ZNK6TClass18GetCollectionProxyEv\n}\n\n{\n   CollectionProxy objects\n   Memcheck:Leak\n   fun:_Znw?\n   fun:_ZNK19TGenCollectionProxy8GenerateEv\n   fun:_ZN14TBranchElement4InitEP5TTreeP7TBranchPKcP23TVirtualCollectionProxyiii\n}\n\n{\n   Part of CollectionProxy objects\n   Memcheck:Leak\n   fun:_Znw?\n   ...\n   fun:_ZN19TGenCollectionProxyC1ERKS_\n}\n\n{\n   Part of CollectionProxy objects\n   Memcheck:Leak\n   fun:_Zna?\n   ...\n   fun:_ZN19TGenCollectionProxyC1ERKS_\n}\n\n{\n   TClass's list of RealData.\n   Memcheck:Leak\n   fun:_Znw?\n   fun:_ZN5TList7NewLinkEP7TObjectP8TObjLink\n   fun:_ZN5TList7AddLastEP7TObject\n   fun:_ZN5TList3AddEP7TObject\n   fun:_ZN6TClass21BuildEmulatedRealDataEPKclPS_\n}\n\n{\n   TClass's RealData objects.\n   Memcheck:Leak\n   fun:_Znw?\n   fun:_ZN8TStorage11ObjectAllocE?\n   fun:_ZN7TObjectnwE?\n   fun:_ZN6TClass21BuildEmulatedRealDataEPKclPS_\n}\n\n{\n   TClass's RealData objects.\n   Memcheck:Leak\n   fun:_Znw?\n   fun:_ZN8TStorage11ObjectAllocE?\n   fun:_ZN7TObjectnwE?\n   fun:_ZN6TClass13BuildRealDataEPvb\n}\n\n{\n   TEmulatedCollectionProxy configuration item\n   Memcheck:Leak\n   fun:_Znw?\n   fun:_ZN24TEmulatedCollectionProxy12InitializeExEv\n}\n\n\n{\n   Leaking TROOT member collections\n   Memcheck:Leak\n   fun:_Znwm\n   fun:_ZN8TStorage11ObjectAllocEm\n   fun:_ZN7TObjectnwEm\n   fun:_ZN5TROOTC1EPKcS1_PPFvvE\n   fun:_ZN4ROOT14TROOTAllocatorC2Ev\n   fun:_ZN4ROOT8GetROOT1Ev\n   fun:_ZN4ROOT7GetROOTEv\n}\n\n\n{\n   TEnums leak\n   Memcheck:Leak\n   fun:_Znwm\n   fun:_ZN8TStorage11ObjectAllocEm\n   fun:_ZN7TObjectnwEm\n   fun:_ZN5TROOT14GetListOfEnumsEv\n}\n\n{\n   List of enums\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   fun:_ZN10THashTableC1Eii\n   fun:_ZN9THashListC1Eii\n   fun:_ZN12TListOfEnumsC1EP6TClass\n   fun:_ZN6TClass14GetListOfEnumsEb\n}\n\n{\n   List of enums\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN8TStorage11ObjectAllocEm\n   fun:_ZN7TObjectnwEm\n   fun:_ZN12TListOfEnumsC1EP6TClass\n}\n\n{\n   List of enums\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN5TList7NewLinkEP7TObjectP8TObjLink\n   fun:_ZN5TList7AddLastEP7TObject\n   fun:_ZN9THashList7AddLastEP7TObject\n   fun:_ZN12TListOfEnums3GetEPKvPKc\n}\n\n{\n   List of enums content\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   ...\n   fun:_ZN6TExMap3AddExx\n   fun:_ZN12TListOfEnums3GetEPKvPKc\n\n}\n\n{\n   List of enums\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   ...\n   fun:_ZN6TExMapC1Ei\n   fun:_ZN12TListOfEnumsC1EP6TClass\n}\n\n{\n   List of enums' strings\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   fun:_ZN7TString7ReplaceEiiPKci\n   fun:_ZN7TStringaSEPKc\n   fun:_ZN6TNamed7SetNameEPKc\n   fun:_ZN5TEnumC1EPKcPvP6TClass\n   fun:_ZN12TListOfEnums3GetEPKvPKc\n}\n\n{\n   List of enums' strings\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   fun:_ZN7TString7ReplaceEiiPKci\n   fun:_ZN7TStringaSEPKc\n   fun:_ZN6TNamed7SetNameEPKc\n   fun:_ZN5TEnumC1EPKcPvP6TClass\n   fun:_ZNK6TCling10CreateEnumEPvP6TClass\n}\n\n{\n   TEnum\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   fun:_ZN10THashTableC1Eii\n   fun:_ZN9THashListC1Eii\n   fun:_ZN5TEnumC1EPKcPvP6TClass\n   fun:_ZNK6TCling10CreateEnumEPvP6TClass\n}\n\n{\n   Enum constant\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN5TList7NewLinkEP7TObjectP8TObjLink\n   fun:_ZN5TList7AddLastEP7TObject\n   fun:_ZN5TList3AddEP7TObject\n   fun:_ZN10THashTable3AddEP7TObject\n   fun:_ZN9THashList7AddLastEP7TObject\n   fun:_ZN5TList3AddEP7TObject\n   fun:_ZN5TEnum11AddConstantEP13TEnumConstant\n}\n\n{\n   Enum constant's string.\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   ...\n   fun:_ZN6TNamed7SetNameEPKc\n   fun:_ZN7TGlobalC1EP16DataMemberInfo_t\n   fun:_ZN13TEnumConstantC1EP16DataMemberInfo_tPKcxP5TEnum\n   fun:_ZNK6TCling19UpdateEnumConstantsEP5TEnumP6TClass\n   fun:_ZNK6TCling10CreateEnumEPvP6TClass\n   fun:_ZN12TListOfEnums3GetEPKvPKc\n}\n\n{\n   TDataTypes leak\n   Memcheck:Leak\n   fun:_Znwm\n   fun:_ZN8TStorage11ObjectAllocEm\n   fun:_ZN7TObjectnwEm\n   fun:_ZN5TROOT14GetListOfTypesEb\n}\n\n{\n   Names in TClassTable\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:allocate\n   ...\n   fun:_ZN11TClassTable3AddEPKcsRKSt9type_infoPFP6TClassvEi\n   fun:_ZN4ROOT8AddClassEPKcsRKSt9type_infoPFP6TClassvEi\n   fun:_ZNK4ROOT8Internal20TDefaultInitBehavior8RegisterEPKcsRKSt9type_infoPFP6TClassvEi\n   fun:_ZN4ROOT17TGenericClassInfo4InitEi\n}\n\n{\n   Name in TClassRef in TRefProxy\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:allocate\n   ...\n   fun:_ZNSsC1EPKcRKSaIcE\n   fun:_ZN9TClassRefC1EPKc\n   fun:_ZN9TRefProxyC1Ev\n}\n\n{\n   Name in TClassRef\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN9TClassRefC1EP6TClass\n}\n\n{\n   Name in TClassRef\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN9TClassRef6AssignEP6TClass\n   fun:_ZN9TClassRefaSEP6TClass\n}\n\n{\n   Name in TClassRef in TRefProxy\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN9TClassRef6AssignEP6TClass\n   fun:_ZN9TClassRefaSEP6TClass\n   fun:_ZN9TRefProxy8SetClassEP6TClass\n}\n\n{\n   Name in TClassRef in TBaseClass\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:allocate\n   ...\n   fun:_ZN9TClassRef6AssignEP6TClass\n   fun:_ZN9TClassRefaSEP6TClass\n   fun:_ZN10TBaseClass15GetClassPointerEb\n}\n\n{\n   Name in TClassRef in TClassStreamer\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:allocate\n   ...\n   fun:_ZN9TClassRef6AssignEP6TClass\n   fun:_ZN9TClassRefaSEP6TClass\n   fun:_ZN14TClassStreamer14SetOnFileClassEPK6TClass\n}\n\n{\n   Name in TGenCollectionProxy\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN19TGenCollectionProxyC1ERKN4ROOT6Detail20TCollectionProxyInfoEP6TClass\n}\n\n{\n   TClassClassInfo content\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN4llvm12DenseMapBaseINS_8DenseMapIPKN5clang4DeclESt4pairIlPFlPvbEENS_12DenseMapInfoIS5_EENS_6detail12DenseMapPairIS5_SA_EEEES5_SA_SC_SF_EixERKS5_\n   fun:_ZN15TClingClassInfo18AddBaseOffsetValueEPKN5clang4DeclEl\n}\n\n{\n   Globals leak (collection part)\n   Memcheck:Leak\n   fun:_Znwm\n   fun:_ZN5TList7NewLinkEP7TObjectP8TObjLink\n   fun:_ZN5TList7AddLastEP7TObject\n   fun:_ZN5TList3AddEP7TObject\n   fun:_ZN10THashTable3AddEP7TObject\n   fun:_ZN9THashList7AddLastEP7TObject\n   fun:_ZN18TListOfDataMembers3GetEPKv\n}\n\n{\n   TListOfDataMember collection links\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN5TList7NewLinkEP7TObjectP8TObjLink\n   fun:_ZN5TList7AddLastEP7TObject\n   fun:_ZN9THashList7AddLastEP7TObject\n   fun:_ZN18TListOfDataMembers3GetEP16DataMemberInfo_tb\n}\n\n{\n   TListOfDataMember content\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN8TStorage11ObjectAllocEm\n   fun:_ZN7TObjectnwEm\n   fun:_ZN18TListOfDataMembers3GetEP16DataMemberInfo_tb\n}\n\n{\n   TListOfDataMember container.\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   fun:_ZN6TExMapC1Ei\n   fun:_ZN18TListOfDataMembers3GetEP16DataMemberInfo_tb\n}\n\n{\n   Globals leak (element / TObjLink part)\n   Memcheck:Leak\n   fun:_Znwm\n   fun:_ZN5TList7NewLinkEP7TObjectP8TObjLink\n   fun:_ZN5TList7AddLastEP7TObject\n   fun:_ZN9THashList7AddLastEP7TObject\n   fun:_ZN18TListOfDataMembers3GetEPKv\n   fun:_ZNK18TListOfDataMembers10FindObjectEPKc\n   fun:_ZN6TCling13HandleNewDeclEPKvbRSt3setIP6TClassSt4lessIS4_ESaIS4_EE\n}\n\n\n{\n   Globals leak (element / TGlobal part)\n   Memcheck:Leak\n   fun:_Znwm\n   fun:_ZN8TStorage11ObjectAllocEm\n   fun:_ZN7TObjectnwEm\n   fun:_ZN5TROOT16GetListOfGlobalsEb\n   fun:_ZN6TCling13HandleNewDeclEPKvbRSt3setIP6TClassSt4lessIS4_ESaIS4_EE\n}\n\n{\n   Name in TEnum\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5TEnumC1EPKcPvP6TClass\n}\n\n{\n   Content of the list of base classes\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN5TList7NewLinkEP7TObjectP8TObjLink\n   fun:_ZN5TList7AddLastEP7TObject\n   fun:_ZN5TList3AddEP7TObject\n   fun:_ZNK6TCling23CreateListOfBaseClassesEP6TClass\n}\n\n{\n   Content of of list of base class\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZNK6TCling23CreateListOfBaseClassesEP6TClass\n}\n\n{\n   Content of TBaseClass\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN19TClingBaseClassInfoC1ERKS_\n   fun:_ZNK6TCling23CreateListOfBaseClassesEP6TClass\n}\n\n{\n   List of base classes\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN8TStorage11ObjectAllocEm\n   fun:_ZN7TObjectnwEm\n   fun:_ZNK6TCling23CreateListOfBaseClassesEP6TClass\n}\n\n{\n   TFunction's mangled name\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   fun:_ZN7TString7ReplaceEiiPKci\n   fun:_ZN7TStringaSEPKc\n   fun:_ZN9TFunctionC1EP12MethodInfo_t\n}\n\n{\n   TFunction's name\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   fun:_ZN7TString7ReplaceEiiPKci\n   fun:_ZN7TStringaSEPKc\n   fun:_ZN6TNamed7SetNameEPKc\n   fun:_ZN9TFunctionC1EP12MethodInfo_t\n}\n\n{\n   TListOfFunctions's internal container\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN8TStorage11ObjectAllocEm\n   fun:_ZN7TObjectnwEm\n   fun:_ZN16TListOfFunctionsC1EP6TClass\n}\n\n{\n   TListOfFunctions' content\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN5TList7NewLinkEP7TObjectP8TObjLink\n   fun:_ZN5TList7AddLastEP7TObject\n   fun:_ZN9THashList7AddLastEP7TObject\n   fun:_ZN16TListOfFunctions3GetEPKv\n}\n\n{\n   TListOfFunctions' content\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   fun:_ZN6TExMapC1Ei\n   fun:_ZN16TListOfFunctionsC1EP6TClass\n}\n\n{\n   TListOfFunctions' content\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN5TList7NewLinkEP7TObjectP8TObjLink\n   fun:_ZN5TList7AddLastEP7TObject\n   fun:_ZN5TList3AddEP7TObject\n   fun:_ZN10THashTable3AddEP7TObject\n   fun:_ZN9THashList7AddLastEP7TObject\n   fun:_ZN16TListOfFunctions3GetEPKv\n}\n\n{\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   fun:_ZN6TExMap6ExpandEi\n   fun:_ZN6TExMap3AddEyxx\n   fun:_ZN6TExMap3AddExx\n   fun:_ZN18TListOfDataMembers3GetEP16DataMemberInfo_tb\n}\n\n{\n   TListOfFunctions' content\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   fun:_ZN6TExMap6ExpandEi\n   fun:_ZN6TExMap3AddEyxx\n   fun:_ZN6TExMap3AddExx\n   fun:_ZN16TListOfFunctions3GetEPKv\n }\n\n{\n   TListOfFunctions's content\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN8TStorage11ObjectAllocEm\n   fun:_ZN7TObjectnwEm\n   fun:_ZN9THashListC1Eii\n   fun:_ZN16TListOfFunctionsC1EP6TClass\n}\n\n{\n   TListOfFunctions's content\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN8TStorage11ObjectAllocEm\n   fun:_ZN7TObjectnwEm\n   fun:_ZN10THashTable3AddEP7TObject\n   fun:_ZN9THashList7AddLastEP7TObject\n   fun:_ZN16TListOfFunctions3GetEPKv\n}\n\n{\n   TListOfFunction's content\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZNK6TCling18MethodInfo_FactoryEPKv\n   fun:_ZN16TListOfFunctions3GetEPKv\n}\n\n{\n   TListOfFunction's content\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   fun:_ZN10THashTableC1Eii\n   fun:_ZN9THashListC1Eii\n   fun:_ZN16TListOfFunctionsC1EP6TClass\n}\n\n{\n   TListOfFunction's content\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   fun:_ZN10THashTableC1Eii\n   fun:_ZN16TListOfFunctionsC1EP6TClass\n}\n\n{\n   TListOfFunction's content\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN8TStorage11ObjectAllocEm\n   fun:_ZN7TObjectnwEm\n   fun:_ZN16TListOfFunctions3GetEPKv\n}\n\n{\n   TString in list of functions.\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   fun:_ZN7TString7ReplaceEiiPKci\n   fun:_ZN7TStringaSEPKc\n   fun:_ZN6TNamed8SetTitleEPKc\n   fun:_ZN9TFunctionC1EP12MethodInfo_t\n   fun:_ZN7TMethodC1EP12MethodInfo_tP6TClass\n   fun:_ZN16TListOfFunctions3GetEPKv\n}\n\n{\n   TListOfFunctions unload cache\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN5TList7NewLinkEP7TObjectP8TObjLink\n   fun:_ZN5TList7AddLastEP7TObject\n   fun:_ZN9THashList7AddLastEP7TObject\n   fun:_ZN5TList3AddEP7TObject\n   fun:_ZN16TListOfFunctions6UnloadEv\n}\n\n{\n   TListOfFunctions unload cache\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN5TList7NewLinkEP7TObjectP8TObjLink\n   fun:_ZN5TList7AddLastEP7TObject\n   fun:_ZN5TList3AddEP7TObject\n   fun:_ZN10THashTable3AddEP7TObject\n   fun:_ZN9THashList7AddLastEP7TObject\n   fun:_ZN5TList3AddEP7TObject\n   fun:_ZN16TListOfFunctions6UnloadEv\n}\n\n{\n   TListOfFunctions unload cache\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN8TStorage11ObjectAllocEm\n   fun:_ZN7TObjectnwEm\n   fun:_ZN10THashTable3AddEP7TObject\n   fun:_ZN9THashList7AddLastEP7TObject\n   fun:_ZN5TList3AddEP7TObject\n   fun:_ZN16TListOfFunctions6UnloadEv\n}\n\n{\n   TClass list of methods\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN8TStorage11ObjectAllocEm\n   fun:_ZN7TObjectnwEm\n   fun:_ZN6TClass13GetMethodListEv\n}\n\n{\n   ListOfDataMembers' collection\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   fun:_ZN10THashTableC1Eii\n   fun:_ZN9THashListC1Eii\n   fun:_ZN18TListOfDataMembersC1EP6TClass\n   fun:_ZN6TClass20GetListOfDataMembersEb\n}\n\n{\n   TListOfDataMembers' content\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN9THashList7AddLastEP7TObject\n   fun:_ZN5TList3AddEP7TObject\n   fun:_ZN18TListOfDataMembers6UnloadEv\n}\n\n{\n   TListOfDataMembers' content\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   fun:_ZN6TExMap6ExpandEi\n   fun:_ZN6TExMap3AddEyxx\n   fun:_ZN6TExMap3AddExx\n   fun:_ZN18TListOfDataMembers3GetEP16DataMemberInfo_tb\n}\n\n{\n   TListOfDataMembers' content\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   fun:_ZN10THashTableC1Eii\n   fun:_ZN9THashListC1Eii\n   fun:_ZN18TListOfDataMembers6UnloadEv\n }\n\n{\n   TListOfDataMembers' content\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN8TStorage11ObjectAllocEm\n   fun:_ZN7TObjectnwEm\n   fun:_ZN9THashListC1Eii\n   fun:_ZN18TListOfDataMembers6UnloadEv\n}\n\n{\n   TListOfDataMembers' content\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:_ZN8TStorage11ObjectAllocEm\n   fun:_ZN7TObjectnwEm\n   fun:_ZN18TListOfDataMembers6UnloadEv\n}\n\n######### ROOT I/O\n\n{\n   zlib fill_window issue, see zlib.net FAQ #36 and comment \"If n is not on any hash chain, prev[n] is garbage but\" in zlib deflate.c.  See http://www.zlib.net/zlib_faq.html#faq36.  Even though the code was correct, versions 1.2.4 and later was changed to not stimulate these checkers.\n   Memcheck:Cond\n   fun:fill_window\n   fun:deflate_fast\n   fun:deflate\n}\n\n{\n   zlib deflate issue, see zlib.net FAQ #36: http://www.zlib.net/zlib_faq.html#faq36 which says that it was due to changing from calloc to malloc.  And notes, that even though the code was correct, versions 1.2.4 and later was changed to not stimulate these checkers.\n   Memcheck:Cond\n   fun:longest_match\n   ...\n   fun:deflate\n}\n\n{\n   std::string streaming\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN11TBufferFile13ReadStdStringERSs\n}\n\n######## ROOT TObject on heap\n\n{\n   TObject::TObject() uses uninitialized value\n   Memcheck:Cond\n   fun:_ZN7TObjectC1Ev\n   ...\n}\n\n{\n   TObject::TObject() uses uninitialized value\n   Memcheck:Cond\n   fun:_ZN7TObjectC2Ev\n   ...\n}\n\n{\n   TObject::TObject() uses uninitialized value\n   Memcheck:Cond\n   fun:TObject\n   ...\n}\n\n{\n   TObject::TObject(const TObject&) uses uninitialized value\n   Memcheck:Cond\n   fun:_ZN7TObjectC1ERKS_\n   ...\n}\n\n{\n   TObject::TObject(const TObject&) uses uninitialized value\n   Memcheck:Cond\n   fun:_ZN7TObjectC2ERKS_\n   ...\n}\n\n{\n   TObject::TObject(const TObject&) uses uninitialized value\n   Memcheck:Cond\n   fun:TObject\n   ...\n}\n\n{\n   gcc optimizer confuses valgrind on TObject::~TObject()\n   Memcheck:Cond\n   fun:_ZN7TObjectD1Ev\n   ...\n}\n\n{\n   <insert_a_suppression_name_here>\n   Memcheck:Cond\n   fun:_ZN8TStorage14UpdateIsOnHeapERVKjRVj\n   ...\n}\n\n######## Minimizer\n\n{\n   Global configuration string for Minimizer\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_Z41__static_initialization_and_destruction_0ii\n   fun:_GLOBAL__sub_I_MinimizerOptions.cxx\n}\n\n{\n   Global configuration string for Minimizer\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZNSs15_M_replace_safe*\n   fun:_ZN4ROOT4Math16MinimizerOptions20DefaultMinimizerTypeEv\n}\n\n{\n   Configuration string for global minimizer\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZNSs6appendERKSs\n   fun:_ZN4ROOT3Fit9FitResult10FillResultERKSt10shared_ptrINS_4Math9MinimizerEERKNS0_9FitConfigERKS2_INS3_27IParametricFunctionMultiDimEEbjbPKNS3_21IBaseFunctionMultiDimEj\n}\n\n{\n   Configuration string for global minimizer\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZNSsC1EPKcRKSaIcE\n   fun:_ZNK4ROOT4Math15WrappedMultiTF113ParameterNameEj\n}\n\n{\n   Configuration for global minimizer\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znam\n   fun:_ZN7TMinuit11BuildArraysEi\n   fun:_ZN7TMinuitC1Ei\n   fun:_ZN16TMinuitMinimizer11InitTMinuitEi\n}\n\n######### Misc\n\n{\n   TUnixSystem::Setenv, see its doc\n   Memcheck:Leak\n   fun:_Zna?\n   fun:_ZN11TUnixSystem6SetenvEPKcS1_\n}\n\n{\n   getpwuid() does a __nss_database_lookup which leaks\n   Memcheck:Leak\n   fun:malloc\n   fun:nss_parse_service_list\n   fun:__nss_database_lookup\n   ...\n   fun:getpwuid_r@@GLIBC_*\n}\n\n{\n   getgrgid() does a __nss_database_lookup which leaks\n   Memcheck:Leak\n   fun:malloc\n   fun:nss_parse_service_list\n   fun:__nss_database_lookup\n   obj:*\n   obj:*\n   fun:getgrgid_r@@GLIBC_*\n}\n\n######### X11 errors triggered by ROOT\n\n{\n   ROOT:X11 - GetWindowSize\n   Memcheck:Param\n   write(buf)\n   fun:__write_nocancel\n   obj:*/libX11.*\n   obj:*/libX11.*\n   fun:_XReply\n   fun:XGetGeometry\n   fun:_ZN5TGX1113GetWindowSizeEmRiS0_RjS1_\n}\n{\n   ROOT:X11 - XFlush\n   Memcheck:Param\n   write(buf)\n   fun:__write_nocancel\n   obj:*/libX11.*\n   obj:*/libX11.*\n   fun:XFlush\n   fun:_ZN7TCanvas5BuildEv\n}\n{\n   ROOT:X11 - XDrawString\n   Memcheck:Param\n   write(buf)\n   fun:__write_nocancel\n   obj:*/libX11.*\n   obj:*/libX11.*\n   fun:XDrawString\n   fun:_ZN8TGX11TTF10DrawStringEmmiiPKci\n}\n{\n   ROOT:X11 - XPending\n   Memcheck:Param\n   write(buf)\n   fun:__write_nocancel\n   obj:*/libX11.*\n   obj:*/libX11.*\n   fun:_XEventsQueued\n   fun:XPending\n   fun:_ZN8TGClient15ProcessOneEventEv\n}\n{\n   ROOT:X11 - XCheckTypedWindowEvent\n   Memcheck:Param\n   write(buf)\n   fun:__write_nocancel\n   obj:*/libX11.*\n   obj:*/libX11.*\n   fun:XCheckTypedWindowEvent\n   fun:_ZN5TGX1110CheckEventEm11EGEventTypeR7Event_t\n}\n{\n   ROOT:X11 - XPutImage\n   Memcheck:Param\n   writev(vector[...])\n   fun:writev\n   obj:*/libX11.*\n   fun:_XSend\n   obj:*/libX11.*\n   fun:XPutImage\n   fun:_ZN8TGX11TTF12RenderStringEiiN9TVirtualX9ETextModeE\n}\n{\n   ROOT:X11 - XMoveResizeWindow\n   Memcheck:Param\n   write(buf)\n   fun:__write_nocancel\n   obj:*/libX11.*\n   obj:*/libX11.*\n   fun:XMoveResizeWindow\n   fun:_ZN7TGFrame10MoveResizeEiijj\n}\n{\n   ROOT:X11 - XSetTextProperty\n   Memcheck:Param\n   write(buf)\n   fun:__write_nocancel\n   obj:*/libX11.*\n   obj:*/libX11.*\n   fun:XChangeProperty\n   fun:XSetTextProperty\n   fun:_ZN5TGX1113SetWindowNameEmPc\n}\n{\n   ROOT:X11 - XDrawLines\n   Memcheck:Param\n   write(buf)\n   fun:__write_nocancel\n   obj:*/libX11.*\n   obj:*/libX11.*\n   fun:XDrawLines\n   fun:_ZN4TPad13PaintPolyLineEiPdS0_PKc\n}\n{\n   ROOT:X11 - XDrawLines / _XFlushGCCache\n   Memcheck:Param\n   write(buf)\n   fun:__write_nocancel\n   obj:*/libX11.*\n   obj:*/libX11.*\n   fun:_XFlushGCCache\n   fun:XDrawLines\n   fun:_ZN4TPad13PaintFillAreaEiPdS0_PKc\n}\n{\n   ROOT:X11 - XDrawLines / _XSend\n   Memcheck:Param\n   writev(vector[...])\n   fun:writev\n   obj:*/libX11.*\n   fun:_XSend\n   fun:XDrawLines\n   fun:_ZN4TPad13PaintFillAreaEiPdS0_PKc\n}\n\n{\n   ROOT:X11 - XQueryExtension\n   Memcheck:Param\n   writev(vector[...])\n   fun:writev\n   obj:*/libxcb.*\n   obj:*/libxcb.*\n   fun:xcb_writev\n   fun:_XSend\n   fun:XQueryExtension\n}\n{\n   ROOT:X11 - XftFontOpenXlfd\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:realloc\n   obj:*/libfontconfig.*\n   obj:*/libfontconfig.*\n   fun:FcFontRenderPrepare\n   fun:FcFontMatch\n   fun:XftFontMatch\n   fun:XftFontOpenXlfd\n}\n\n####### System\n\n{\n   Ignore deficient in dlopen and/or pthread and/or valgrind. See for example https://bugs.kde.org/show_bug.cgi?id=358980.\n   Memcheck:Leak\n   match-leak-kinds: definite\n   ...\n   fun:_dl_open\n}\n\n####### Non-leak coming from clang/llvm\n\n{\n   cling initialization\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5cling11InterpreterC1EiPKPKcS2_bb\n}\n\n{\n   clang module symbol table\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   fun:allocate\n   ...\n   fun:_ZN5clang7CodeGen13CodeGenModule7ReleaseEv\n   fun:_ZN5cling17IncrementalParser18codeGenTransactionEPNS_11TransactionE\n   fun:_ZN5cling17IncrementalParser17commitTransactionEN4llvm14PointerIntPairIPNS_11TransactionELj2ENS0_12EParseResultENS1_21PointerLikeTypeTraitsIS4_EEEE\n}\n\n{\n   CodeGen\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZL21EmitMemberInitializerRN5clang7CodeGen15CodeGenFunctionEPKNS_13CXXRecordDeclEPNS_18CXXCtorInitializerEPKNS_18CXXConstructorDeclERNS0_15FunctionArgListE\n}\n\n{\n   CodeGen cleanup\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZL11EmitCleanupRN5clang7CodeGen15CodeGenFunctionEPNS0_12EHScopeStack7CleanupENS4_5FlagsEPN4llvm5ValueE\n}\n\n{\n   CodeGen Globals\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Zn*\n   ...\n   fun:_ZN5clang7CodeGen13CodeGenModule20EmitGlobalDefinitionENS_10GlobalDeclEPN4llvm11GlobalValueE\n}\n\n{\n   cling Module use\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN4llvm6ModuleC1ENS_9StringRefERNS_11LLVMContextE\n}\n\n{\n   cling Module use\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang17CodeGeneratorImpl11StartModuleERKSsRN4llvm11LLVMContextERKNS_14CodeGenOptionsE\n}\n\n{\n   cling macro\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang19PreprocessorOptions11addMacroDefEN4llvm9StringRefE\n}\n\n{\n   llvm target\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN4llvm21RegisterTargetMachineINS_16X86TargetMachineEE9AllocatorERKNS_6TargetENS_9StringRefES6_S6_RKNS_13TargetOptionsENS_5Reloc5ModelENS_9CodeModel5ModelENS_10CodeGenOpt5LevelE\n}\n\n{\n   CodeGent SetFunctionAttributes\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang7CodeGen13CodeGenModule21SetFunctionAttributesENS_10GlobalDeclEPN4llvm8FunctionEbb\n}\n\n{\n   clang using statement\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZNK5clang11DeclContext16using_directivesEv\n}\n\n{\n   clang 'make decl visible'\n   Memcheck:Leak\n   match-leak-kinds: possible\n   ...\n   fun:_ZN5clang11DeclContext28makeDeclVisibleInContextImplEPNS_9NamedDeclEb\n}\n\n{\n   clang visibility\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZL24getExplicitVisibilityAuxPKN5clang9NamedDeclENS0_22ExplicitVisibilityKindEb\n}\n\n{\n   clang result of lookup declaration name\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang11DeclContext6lookupENS_15DeclarationNameE\n}\n\n{\n   clang result of lookup declaration name\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:malloc\n   ...\n   fun:_ZN5clang11DeclContext6lookupENS_15DeclarationNameE\n}\n\n{\n   clang ASTReader\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:malloc\n   ...\n   fun:_ZN5clang9ASTReader*\n}\n\n{\n   clang ASTReader\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang9ASTReader*\n}\n\n{\n   clang ASTReader\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:realloc\n   ...\n   fun:_ZN5clang9ASTReader*\n}\n\n{\n   Sema ActOnEndOfTranslation\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang4Sema25ActOnEndOfTranslationUnitEv\n}\n\n{\n   Function CodeGen\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang7CodeGen15CodeGenFunction12GenerateCodeENS_10GlobalDeclEPN4llvm8FunctionERKNS0_14CGFunctionInfoE\n}\n\n{\n   clang CodeGenFunction Emit*\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Zn*\n   ...\n   fun:_ZN5clang7CodeGen15CodeGenFunction*Emit*\n}\n\n{\n   clang CodeGenModule Emit*\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Zn*\n   ...\n   fun:_ZN5clang7CodeGen13CodeGenModule*Emit*\n}\n\n{\n   clang CodeGenModule Emit*\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Zn*\n   ...\n   fun:_ZN5clang7CodeGen13CodeGenModule*emit*\n}\n\n{\n   clang AddIncludePath\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang19HeaderSearchOptions7AddPathEN4llvm9StringRefENS_8frontend15IncludeDirGroupEbb\n}\n\n{\n   clang FileManager\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang12HeaderSearch10LookupFileEN4llvm9StringRefENS_14SourceLocationEbPKNS_15DirectoryLookupERS6_NS1_8ArrayRefISt4pairIPKNS_9FileEntryEPKNS_14DirectoryEntryEEEEPNS1_15SmallVectorImplIcEESK_PNS_9ModuleMap11KnownHeaderEbbb\n}\n\n{\n   clang getFile\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5clang11FileManager7getFileEN4llvm9StringRefEbb\n}\n\n{\n   clang ScalarExprEmitter\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN12_GLOBAL__N_117ScalarExprEmitter20EmitScalarConversionEPN4llvm5ValueEN5clang8QualTypeES5_\n}\n\n{\n   llvm pass manager\n   Memcheck:Leak\n   match-leak-kinds: possible\n   ...\n   fun:_ZN4llvm13FPPassManager13runOnFunctionERNS_8FunctionE\n}\n\n\n{\n   llvm PassManager initialization\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN4llvm13FPPassManager16doInitializationERNS_6ModuleE\n}\n\n{\n   llvm SubTarget initialization\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN4llvm15MCSubtargetInfo19InitMCSubtargetInfoENS_9StringRefES1_S1_NS_8ArrayRefINS_18SubtargetFeatureKVEEES4_PKNS_15SubtargetInfoKVEPKNS_19MCWriteProcResEntryEPKNS_19MCWriteLatencyEntryEPKNS_18MCReadAdvanceEntryEPKNS_10InstrStageEPKjSL_\n}\n\n{\n   cling dynamic library manager\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN5cling21DynamicLibraryManager11loadLibraryERKSsb\n}\n\n{\n   llvm compile layer\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:_Znwm\n   ...\n   fun:_ZN4llvm18ObjectMemoryBufferC1EONS_15SmallVectorImplIcEE\n   fun:_ZNK4llvm14SimpleCompilerclERNS_6ModuleE\n   fun:_ZNSt17_Function_handlerIFN4llvm6object12OwningBinaryINS1_10ObjectFileEEERNS0_6ModuleEENS0_14SimpleCompilerEE9_M_invokeERKSt9_Any_dataS6_\n   fun:_ZNKSt8functionIFN4llvm6object12OwningBinaryINS1_10ObjectFileEEERNS0_6ModuleEEEclES6_\n   fun:_ZN4llvm14IRCompileLayerINS_18ObjectLinkingLayerIN5cling14IncrementalJIT19NotifyObjectLoadedTEEEE12addModuleSetISt6vectorIPNS_6ModuleESaISA_EEEESt14_List_iteratorINS_22ObjectLinkingLayerBase15LinkedObjectSetEET_St10unique_ptrINS_19RTDyldMemoryManagerESt14default_deleteISJ_EE\n}\n\n{\n   InputValidator string\n   Memcheck:Leak\n   match-leak-kinds: possible\n   ...\n   fun:_ZNSs15_M_replace_safeEmmPKcm\n   fun:_ZN5cling14InputValidator5resetEv\n}\n\n{\n   cling pointer checker on uninitialized memory (ROOT-8144)\n   Memcheck:Param\n   msync(start)\n   ...\n   fun:_ZN5cling5utils14isAddressValidEPKv\n   fun:cling_runtime_internal_throwIfInvalidPointer\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/net/http/civetweb/civetweb.c": "/* Copyright (c) 2013-2018 the Civetweb developers\n * Copyright (c) 2004-2013 Sergey Lyubka\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#define GCC_VERSION                                                            \\\n\t(__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)\n#if GCC_VERSION >= 40500\n/* gcc diagnostic pragmas available */\n#define GCC_DIAGNOSTIC\n#endif\n#endif\n\n#if defined(GCC_DIAGNOSTIC)\n/* Disable unused macros warnings - not all defines are required\n * for all systems and all compilers. */\n#pragma GCC diagnostic ignored \"-Wunused-macros\"\n/* A padding warning is just plain useless */\n#pragma GCC diagnostic ignored \"-Wpadded\"\n#endif\n\n#if defined(__clang__) /* GCC does not (yet) support this pragma */\n/* We must set some flags for the headers we include. These flags\n * are reserved ids according to C99, so we need to disable a\n * warning for that. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wreserved-id-macro\"\n#endif\n\n#if defined(_WIN32)\n#if !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS /* Disable deprecation warning in VS2005 */\n#endif\n#if !defined(_WIN32_WINNT) /* defined for tdm-gcc so we can use getnameinfo */\n#define _WIN32_WINNT 0x0501\n#endif\n#else\n#if !defined(_GNU_SOURCE)\n#define _GNU_SOURCE /* for setgroups(), pthread_setname_np() */\n#endif\n#if defined(__linux__) && !defined(_XOPEN_SOURCE)\n#define _XOPEN_SOURCE 600 /* For flockfile() on Linux */\n#endif\n#if !defined(_LARGEFILE_SOURCE)\n#define _LARGEFILE_SOURCE /* For fseeko(), ftello() */\n#endif\n#if !defined(_FILE_OFFSET_BITS)\n#define _FILE_OFFSET_BITS 64 /* Use 64-bit file offsets by default */\n#endif\n#if !defined(__STDC_FORMAT_MACROS)\n#define __STDC_FORMAT_MACROS /* <inttypes.h> wants this for C++ */\n#endif\n#if !defined(__STDC_LIMIT_MACROS)\n#define __STDC_LIMIT_MACROS /* C++ wants that for INT64_MAX */\n#endif\n#if !defined(_DARWIN_UNLIMITED_SELECT)\n#define _DARWIN_UNLIMITED_SELECT\n#endif\n#if defined(__sun)\n#define __EXTENSIONS__  /* to expose flockfile and friends in stdio.h */\n#define __inline inline /* not recognized on older compiler versions */\n#endif\n#endif\n\n#if defined(__clang__)\n/* Enable reserved-id-macro warning again. */\n#pragma GCC diagnostic pop\n#endif\n\n\n#if defined(USE_LUA)\n#define USE_TIMERS\n#endif\n\n#if defined(_MSC_VER)\n/* 'type cast' : conversion from 'int' to 'HANDLE' of greater size */\n#pragma warning(disable : 4306)\n/* conditional expression is constant: introduced by FD_SET(..) */\n#pragma warning(disable : 4127)\n/* non-constant aggregate initializer: issued due to missing C99 support */\n#pragma warning(disable : 4204)\n/* padding added after data member */\n#pragma warning(disable : 4820)\n/* not defined as a preprocessor macro, replacing with '0' for '#if/#elif' */\n#pragma warning(disable : 4668)\n/* no function prototype given: converting '()' to '(void)' */\n#pragma warning(disable : 4255)\n/* function has been selected for automatic inline expansion */\n#pragma warning(disable : 4711)\n#endif\n\n\n/* This code uses static_assert to check some conditions.\n * Unfortunately some compilers still do not support it, so we have a\n * replacement function here. */\n#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L\n#define mg_static_assert _Static_assert\n#elif defined(__cplusplus) && __cplusplus >= 201103L\n#define mg_static_assert static_assert\n#else\nchar static_assert_replacement[1];\n#define mg_static_assert(cond, txt)                                            \\\n\textern char static_assert_replacement[(cond) ? 1 : -1]\n#endif\n\nmg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,\n                 \"int data type size check\");\nmg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,\n                 \"pointer data type size check\");\nmg_static_assert(sizeof(void *) >= sizeof(int), \"data type size check\");\n\n\n/* Alternative queue is well tested and should be the new default */\n#if defined(NO_ALTERNATIVE_QUEUE)\n#if defined(ALTERNATIVE_QUEUE)\n#error \"Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE or none, but not both\"\n#endif\n#else\n#define ALTERNATIVE_QUEUE\n#endif\n\n\n/* DTL -- including winsock2.h works better if lean and mean */\n#if !defined(WIN32_LEAN_AND_MEAN)\n#define WIN32_LEAN_AND_MEAN\n#endif\n\n#if defined(__SYMBIAN32__)\n/* According to https://en.wikipedia.org/wiki/Symbian#History,\n * Symbian is no longer maintained since 2014-01-01.\n * Recent versions of CivetWeb are no longer tested for Symbian.\n * It makes no sense, to support an abandoned operating system.\n */\n#error \"Symbian is no longer maintained. CivetWeb no longer supports Symbian.\"\n#define NO_SSL /* SSL is not supported */\n#define NO_CGI /* CGI is not supported */\n#define PATH_MAX FILENAME_MAX\n#endif /* __SYMBIAN32__ */\n\n\n#if !defined(CIVETWEB_HEADER_INCLUDED)\n/* Include the header file here, so the CivetWeb interface is defined for the\n * entire implementation, including the following forward definitions. */\n#include \"civetweb.h\"\n#endif\n\n#if !defined(DEBUG_TRACE)\n#if defined(DEBUG)\nstatic void DEBUG_TRACE_FUNC(const char *func,\n                             unsigned line,\n                             PRINTF_FORMAT_STRING(const char *fmt),\n                             ...) PRINTF_ARGS(3, 4);\n\n#define DEBUG_TRACE(fmt, ...)                                                  \\\n\tDEBUG_TRACE_FUNC(__func__, __LINE__, fmt, __VA_ARGS__)\n\n#define NEED_DEBUG_TRACE_FUNC\n\n#else\n#define DEBUG_TRACE(fmt, ...)                                                  \\\n\tdo {                                                                       \\\n\t} while (0)\n#endif /* DEBUG */\n#endif /* DEBUG_TRACE */\n\n\n#if !defined(DEBUG_ASSERT)\n#if defined(DEBUG)\n#define DEBUG_ASSERT(cond)                                                     \\\n\tdo {                                                                       \\\n\t\tif (!(cond)) {                                                         \\\n\t\t\tDEBUG_TRACE(\"ASSERTION FAILED: %s\", #cond);                        \\\n\t\t\texit(2); /* Exit with error */                                     \\\n\t\t}                                                                      \\\n\t} while (0)\n#else\n#define DEBUG_ASSERT(cond)\n#endif /* DEBUG */\n#endif\n\n\n#if defined(__GNUC__) && defined(GCC_INSTRUMENTATION)\nvoid __cyg_profile_func_enter(void *this_fn, void *call_site)\n    __attribute__((no_instrument_function));\n\nvoid __cyg_profile_func_exit(void *this_fn, void *call_site)\n    __attribute__((no_instrument_function));\n\nvoid\n__cyg_profile_func_enter(void *this_fn, void *call_site)\n{\n\tif ((void *)this_fn != (void *)printf) {\n\t\tprintf(\"E %p %p\\n\", this_fn, call_site);\n\t}\n}\n\nvoid\n__cyg_profile_func_exit(void *this_fn, void *call_site)\n{\n\tif ((void *)this_fn != (void *)printf) {\n\t\tprintf(\"X %p %p\\n\", this_fn, call_site);\n\t}\n}\n#endif\n\n\n#if !defined(IGNORE_UNUSED_RESULT)\n#define IGNORE_UNUSED_RESULT(a) ((void)((a) && 1))\n#endif\n\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n\n/* GCC unused function attribute seems fundamentally broken.\n * Several attempts to tell the compiler \"THIS FUNCTION MAY BE USED\n * OR UNUSED\" for individual functions failed.\n * Either the compiler creates an \"unused-function\" warning if a\n * function is not marked with __attribute__((unused)).\n * On the other hand, if the function is marked with this attribute,\n * but is used, the compiler raises a completely idiotic\n * \"used-but-marked-unused\" warning - and\n *   #pragma GCC diagnostic ignored \"-Wused-but-marked-unused\"\n * raises error: unknown option after \"#pragma GCC diagnostic\".\n * Disable this warning completely, until the GCC guys sober up\n * again.\n */\n\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n\n#define FUNCTION_MAY_BE_UNUSED /* __attribute__((unused)) */\n\n#else\n#define FUNCTION_MAY_BE_UNUSED\n#endif\n\n\n/* Some ANSI #includes are not available on Windows CE */\n#if !defined(_WIN32_WCE)\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#endif /* !_WIN32_WCE */\n\n\n#if defined(__clang__)\n/* When using -Weverything, clang does not accept it's own headers\n * in a release build configuration. Disable what is too much in\n * -Weverything. */\n#pragma clang diagnostic ignored \"-Wdisabled-macro-expansion\"\n#endif\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n/* Who on earth came to the conclusion, using __DATE__ should rise\n * an \"expansion of date or time macro is not reproducible\"\n * warning. That's exactly what was intended by using this macro.\n * Just disable this nonsense warning. */\n\n/* And disabling them does not work either:\n * #pragma clang diagnostic ignored \"-Wno-error=date-time\"\n * #pragma clang diagnostic ignored \"-Wdate-time\"\n * So we just have to disable ALL warnings for some lines\n * of code.\n * This seems to be a known GCC bug, not resolved since 2012:\n * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53431\n */\n#endif\n\n\n#if defined(__MACH__) /* Apple OSX section */\n\n#if defined(__clang__)\n#if (__clang_major__ == 3) && ((__clang_minor__ == 7) || (__clang_minor__ == 8))\n/* Avoid warnings for Xcode 7. It seems it does no longer exist in Xcode 8 */\n#pragma clang diagnostic ignored \"-Wno-reserved-id-macro\"\n#pragma clang diagnostic ignored \"-Wno-keyword-macro\"\n#endif\n#endif\n\n#define CLOCK_MONOTONIC (1)\n#define CLOCK_REALTIME (2)\n\n#include <mach/clock.h>\n#include <mach/mach.h>\n#include <mach/mach_time.h>\n#include <sys/errno.h>\n#include <sys/time.h>\n\n/* clock_gettime is not implemented on OSX prior to 10.12 */\nstatic int\n_civet_clock_gettime(int clk_id, struct timespec *t)\n{\n\tmemset(t, 0, sizeof(*t));\n\tif (clk_id == CLOCK_REALTIME) {\n\t\tstruct timeval now;\n\t\tint rv = gettimeofday(&now, NULL);\n\t\tif (rv) {\n\t\t\treturn rv;\n\t\t}\n\t\tt->tv_sec = now.tv_sec;\n\t\tt->tv_nsec = now.tv_usec * 1000;\n\t\treturn 0;\n\n\t} else if (clk_id == CLOCK_MONOTONIC) {\n\t\tstatic uint64_t clock_start_time = 0;\n\t\tstatic mach_timebase_info_data_t timebase_ifo = {0, 0};\n\n\t\tuint64_t now = mach_absolute_time();\n\n\t\tif (clock_start_time == 0) {\n\t\t\tkern_return_t mach_status = mach_timebase_info(&timebase_ifo);\n\t\t\tDEBUG_ASSERT(mach_status == KERN_SUCCESS);\n\n\t\t\t/* appease \"unused variable\" warning for release builds */\n\t\t\t(void)mach_status;\n\n\t\t\tclock_start_time = now;\n\t\t}\n\n\t\tnow = (uint64_t)((double)(now - clock_start_time)\n\t\t                 * (double)timebase_ifo.numer\n\t\t                 / (double)timebase_ifo.denom);\n\n\t\tt->tv_sec = now / 1000000000;\n\t\tt->tv_nsec = now % 1000000000;\n\t\treturn 0;\n\t}\n\treturn -1; /* EINVAL - Clock ID is unknown */\n}\n\n/* if clock_gettime is declared, then __CLOCK_AVAILABILITY will be defined */\n#if defined(__CLOCK_AVAILABILITY)\n/* If we compiled with Mac OSX 10.12 or later, then clock_gettime will be\n * declared but it may be NULL at runtime. So we need to check before using\n * it. */\nstatic int\n_civet_safe_clock_gettime(int clk_id, struct timespec *t)\n{\n\tif (clock_gettime) {\n\t\treturn clock_gettime(clk_id, t);\n\t}\n\treturn _civet_clock_gettime(clk_id, t);\n}\n#define clock_gettime _civet_safe_clock_gettime\n#else\n#define clock_gettime _civet_clock_gettime\n#endif\n\n#endif\n\n\n#include <ctype.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n/********************************************************************/\n/* CivetWeb configuration defines */\n/********************************************************************/\n\n/* Maximum number of threads that can be configured.\n * The number of threads actually created depends on the \"num_threads\"\n * configuration parameter, but this is the upper limit. */\n#if !defined(MAX_WORKER_THREADS)\n#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */\n#endif\n\n/* Timeout interval for select/poll calls.\n * The timeouts depend on \"*_timeout_ms\" configuration values, but long\n * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.\n * This reduces the time required to stop the server. */\n#if !defined(SOCKET_TIMEOUT_QUANTUM)\n#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */\n#endif\n\n/* Do not try to compress files smaller than this limit. */\n#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT)\n#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */\n#endif\n\n#if !defined(PASSWORDS_FILE_NAME)\n#define PASSWORDS_FILE_NAME \".htpasswd\"\n#endif\n\n/* Initial buffer size for all CGI environment variables. In case there is\n * not enough space, another block is allocated. */\n#if !defined(CGI_ENVIRONMENT_SIZE)\n#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */\n#endif\n\n/* Maximum number of environment variables. */\n#if !defined(MAX_CGI_ENVIR_VARS)\n#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */\n#endif\n\n/* General purpose buffer size. */\n#if !defined(MG_BUF_LEN) /* in bytes */\n#define MG_BUF_LEN (1024 * 8)\n#endif\n\n/* Size of the accepted socket queue (in case the old queue implementation\n * is used). */\n#if !defined(MGSQLEN)\n#define MGSQLEN (20) /* count */\n#endif\n\n\n/********************************************************************/\n\n/* Helper makros */\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\n/* Standard defines */\n#if !defined(INT64_MAX)\n#define INT64_MAX (9223372036854775807)\n#endif\n\n#define SHUTDOWN_RD (0)\n#define SHUTDOWN_WR (1)\n#define SHUTDOWN_BOTH (2)\n\nmg_static_assert(MAX_WORKER_THREADS >= 1,\n                 \"worker threads must be a positive number\");\n\nmg_static_assert(sizeof(size_t) == 4 || sizeof(size_t) == 8,\n                 \"size_t data type size check\");\n\n#if defined(_WIN32) /* WINDOWS include block */\n#include <windows.h>\n#include <winsock2.h> /* DTL add for SO_EXCLUSIVE */\n#include <ws2tcpip.h>\n\ntypedef const char *SOCK_OPT_TYPE;\n\n#if !defined(PATH_MAX)\n#define W_PATH_MAX (MAX_PATH)\n/* at most three UTF-8 chars per wchar_t */\n#define PATH_MAX (W_PATH_MAX * 3)\n#else\n#define W_PATH_MAX ((PATH_MAX + 2) / 3)\n#endif\n\nmg_static_assert(PATH_MAX >= 1, \"path length must be a positive number\");\n\n#if !defined(_IN_PORT_T)\n#if !defined(in_port_t)\n#define in_port_t u_short\n#endif\n#endif\n\n#if !defined(_WIN32_WCE)\n#include <direct.h>\n#include <io.h>\n#include <process.h>\n#else            /* _WIN32_WCE */\n#define NO_CGI   /* WinCE has no pipes */\n#define NO_POPEN /* WinCE has no popen */\n\ntypedef long off_t;\n\n#define errno ((int)(GetLastError()))\n#define strerror(x) (_ultoa(x, (char *)_alloca(sizeof(x) * 3), 10))\n#endif /* _WIN32_WCE */\n\n#define MAKEUQUAD(lo, hi)                                                      \\\n\t((uint64_t)(((uint32_t)(lo)) | ((uint64_t)((uint32_t)(hi))) << 32))\n#define RATE_DIFF (10000000) /* 100 nsecs */\n#define EPOCH_DIFF (MAKEUQUAD(0xd53e8000, 0x019db1de))\n#define SYS2UNIX_TIME(lo, hi)                                                  \\\n\t((time_t)((MAKEUQUAD((lo), (hi)) - EPOCH_DIFF) / RATE_DIFF))\n\n/* Visual Studio 6 does not know __func__ or __FUNCTION__\n * The rest of MS compilers use __FUNCTION__, not C99 __func__\n * Also use _strtoui64 on modern M$ compilers */\n#if defined(_MSC_VER)\n#if (_MSC_VER < 1300)\n#define STRX(x) #x\n#define STR(x) STRX(x)\n#define __func__ __FILE__ \":\" STR(__LINE__)\n#define strtoull(x, y, z) ((unsigned __int64)_atoi64(x))\n#define strtoll(x, y, z) (_atoi64(x))\n#else\n#define __func__ __FUNCTION__\n#define strtoull(x, y, z) (_strtoui64(x, y, z))\n#define strtoll(x, y, z) (_strtoi64(x, y, z))\n#endif\n#endif /* _MSC_VER */\n\n#define ERRNO ((int)(GetLastError()))\n#define NO_SOCKLEN_T\n\n#if defined(_WIN64) || defined(__MINGW64__)\n#if !defined(SSL_LIB)\n#define SSL_LIB \"ssleay64.dll\"\n#endif\n#if !defined(CRYPTO_LIB)\n#define CRYPTO_LIB \"libeay64.dll\"\n#endif\n#else\n#if !defined(SSL_LIB)\n#define SSL_LIB \"ssleay32.dll\"\n#endif\n#if !defined(CRYPTO_LIB)\n#define CRYPTO_LIB \"libeay32.dll\"\n#endif\n#endif\n\n#define O_NONBLOCK (0)\n#if !defined(W_OK)\n#define W_OK (2) /* http://msdn.microsoft.com/en-us/library/1w06ktdy.aspx */\n#endif\n#if !defined(EWOULDBLOCK)\n#define EWOULDBLOCK WSAEWOULDBLOCK\n#endif /* !EWOULDBLOCK */\n#define _POSIX_\n#define INT64_FMT \"I64d\"\n#define UINT64_FMT \"I64u\"\n\n#define WINCDECL __cdecl\n#define vsnprintf_impl _vsnprintf\n#define access _access\n#define mg_sleep(x) (Sleep(x))\n\n#define pipe(x) _pipe(x, MG_BUF_LEN, _O_BINARY)\n#if !defined(popen)\n#define popen(x, y) (_popen(x, y))\n#endif\n#if !defined(pclose)\n#define pclose(x) (_pclose(x))\n#endif\n#define close(x) (_close(x))\n#define dlsym(x, y) (GetProcAddress((HINSTANCE)(x), (y)))\n#define RTLD_LAZY (0)\n#define fseeko(x, y, z) ((_lseeki64(_fileno(x), (y), (z)) == -1) ? -1 : 0)\n#define fdopen(x, y) (_fdopen((x), (y)))\n#define write(x, y, z) (_write((x), (y), (unsigned)z))\n#define read(x, y, z) (_read((x), (y), (unsigned)z))\n#define flockfile(x) (EnterCriticalSection(&global_log_file_lock))\n#define funlockfile(x) (LeaveCriticalSection(&global_log_file_lock))\n#define sleep(x) (Sleep((x)*1000))\n#define rmdir(x) (_rmdir(x))\n#if defined(_WIN64) || !defined(__MINGW32__)\n/* Only MinGW 32 bit is missing this function */\n#define timegm(x) (_mkgmtime(x))\n#else\ntime_t timegm(struct tm *tm);\n#define NEED_TIMEGM\n#endif\n\n\n#if !defined(fileno)\n#define fileno(x) (_fileno(x))\n#endif /* !fileno MINGW #defines fileno */\n\ntypedef HANDLE pthread_mutex_t;\ntypedef DWORD pthread_key_t;\ntypedef HANDLE pthread_t;\ntypedef struct {\n\tCRITICAL_SECTION threadIdSec;\n\tstruct mg_workerTLS *waiting_thread; /* The chain of threads */\n} pthread_cond_t;\n\n#if !defined(__clockid_t_defined)\ntypedef DWORD clockid_t;\n#endif\n#if !defined(CLOCK_MONOTONIC)\n#define CLOCK_MONOTONIC (1)\n#endif\n#if !defined(CLOCK_REALTIME)\n#define CLOCK_REALTIME (2)\n#endif\n#if !defined(CLOCK_THREAD)\n#define CLOCK_THREAD (3)\n#endif\n#if !defined(CLOCK_PROCESS)\n#define CLOCK_PROCESS (4)\n#endif\n\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1900)\n#define _TIMESPEC_DEFINED\n#endif\n#if !defined(_TIMESPEC_DEFINED)\nstruct timespec {\n\ttime_t tv_sec; /* seconds */\n\tlong tv_nsec;  /* nanoseconds */\n};\n#endif\n\n#if !defined(WIN_PTHREADS_TIME_H)\n#define MUST_IMPLEMENT_CLOCK_GETTIME\n#endif\n\n#if defined(MUST_IMPLEMENT_CLOCK_GETTIME)\n#define clock_gettime mg_clock_gettime\nstatic int\nclock_gettime(clockid_t clk_id, struct timespec *tp)\n{\n\tFILETIME ft;\n\tULARGE_INTEGER li, li2;\n\tBOOL ok = FALSE;\n\tdouble d;\n\tstatic double perfcnt_per_sec = 0.0;\n\tstatic BOOL initialized = FALSE;\n\n\tif (!initialized) {\n\t\tQueryPerformanceFrequency((LARGE_INTEGER *)&li);\n\t\tperfcnt_per_sec = 1.0 / li.QuadPart;\n\t\tinitialized = TRUE;\n\t}\n\n\tif (tp) {\n\t\tmemset(tp, 0, sizeof(*tp));\n\n\t\tif (clk_id == CLOCK_REALTIME) {\n\n\t\t\t/* BEGIN: CLOCK_REALTIME = wall clock (date and time) */\n\t\t\tGetSystemTimeAsFileTime(&ft);\n\t\t\tli.LowPart = ft.dwLowDateTime;\n\t\t\tli.HighPart = ft.dwHighDateTime;\n\t\t\tli.QuadPart -= 116444736000000000; /* 1.1.1970 in filedate */\n\t\t\ttp->tv_sec = (time_t)(li.QuadPart / 10000000);\n\t\t\ttp->tv_nsec = (long)(li.QuadPart % 10000000) * 100;\n\t\t\tok = TRUE;\n\t\t\t/* END: CLOCK_REALTIME */\n\n\t\t} else if (clk_id == CLOCK_MONOTONIC) {\n\n\t\t\t/* BEGIN: CLOCK_MONOTONIC = stopwatch (time differences) */\n\t\t\tQueryPerformanceCounter((LARGE_INTEGER *)&li);\n\t\t\td = li.QuadPart * perfcnt_per_sec;\n\t\t\ttp->tv_sec = (time_t)d;\n\t\t\td -= (double)tp->tv_sec;\n\t\t\ttp->tv_nsec = (long)(d * 1.0E9);\n\t\t\tok = TRUE;\n\t\t\t/* END: CLOCK_MONOTONIC */\n\n\t\t} else if (clk_id == CLOCK_THREAD) {\n\n\t\t\t/* BEGIN: CLOCK_THREAD = CPU usage of thread */\n\t\t\tFILETIME t_create, t_exit, t_kernel, t_user;\n\t\t\tif (GetThreadTimes(GetCurrentThread(),\n\t\t\t                   &t_create,\n\t\t\t                   &t_exit,\n\t\t\t                   &t_kernel,\n\t\t\t                   &t_user)) {\n\t\t\t\tli.LowPart = t_user.dwLowDateTime;\n\t\t\t\tli.HighPart = t_user.dwHighDateTime;\n\t\t\t\tli2.LowPart = t_kernel.dwLowDateTime;\n\t\t\t\tli2.HighPart = t_kernel.dwHighDateTime;\n\t\t\t\tli.QuadPart += li2.QuadPart;\n\t\t\t\ttp->tv_sec = (time_t)(li.QuadPart / 10000000);\n\t\t\t\ttp->tv_nsec = (long)(li.QuadPart % 10000000) * 100;\n\t\t\t\tok = TRUE;\n\t\t\t}\n\t\t\t/* END: CLOCK_THREAD */\n\n\t\t} else if (clk_id == CLOCK_PROCESS) {\n\n\t\t\t/* BEGIN: CLOCK_PROCESS = CPU usage of process */\n\t\t\tFILETIME t_create, t_exit, t_kernel, t_user;\n\t\t\tif (GetProcessTimes(GetCurrentProcess(),\n\t\t\t                    &t_create,\n\t\t\t                    &t_exit,\n\t\t\t                    &t_kernel,\n\t\t\t                    &t_user)) {\n\t\t\t\tli.LowPart = t_user.dwLowDateTime;\n\t\t\t\tli.HighPart = t_user.dwHighDateTime;\n\t\t\t\tli2.LowPart = t_kernel.dwLowDateTime;\n\t\t\t\tli2.HighPart = t_kernel.dwHighDateTime;\n\t\t\t\tli.QuadPart += li2.QuadPart;\n\t\t\t\ttp->tv_sec = (time_t)(li.QuadPart / 10000000);\n\t\t\t\ttp->tv_nsec = (long)(li.QuadPart % 10000000) * 100;\n\t\t\t\tok = TRUE;\n\t\t\t}\n\t\t\t/* END: CLOCK_PROCESS */\n\n\t\t} else {\n\n\t\t\t/* BEGIN: unknown clock */\n\t\t\t/* ok = FALSE; already set by init */\n\t\t\t/* END: unknown clock */\n\t\t}\n\t}\n\n\treturn ok ? 0 : -1;\n}\n#endif\n\n\n#define pid_t HANDLE /* MINGW typedefs pid_t to int. Using #define here. */\n\nstatic int pthread_mutex_lock(pthread_mutex_t *);\nstatic int pthread_mutex_unlock(pthread_mutex_t *);\nstatic void path_to_unicode(const struct mg_connection *conn,\n                            const char *path,\n                            wchar_t *wbuf,\n                            size_t wbuf_len);\n\n/* All file operations need to be rewritten to solve #246. */\n\nstruct mg_file;\n\nstatic const char *\nmg_fgets(char *buf, size_t size, struct mg_file *filep, char **p);\n\n\n/* POSIX dirent interface */\nstruct dirent {\n\tchar d_name[PATH_MAX];\n};\n\ntypedef struct DIR {\n\tHANDLE handle;\n\tWIN32_FIND_DATAW info;\n\tstruct dirent result;\n} DIR;\n\n#if defined(_WIN32)\n#if !defined(HAVE_POLL)\nstruct pollfd {\n\tSOCKET fd;\n\tshort events;\n\tshort revents;\n};\n#endif\n#endif\n\n/* Mark required libraries */\n#if defined(_MSC_VER)\n#pragma comment(lib, \"Ws2_32.lib\")\n#endif\n\n#else /* defined(_WIN32) - WINDOWS vs UNIX include block */\n\n#include <arpa/inet.h>\n#include <inttypes.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <stdint.h>\n#include <sys/poll.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/utsname.h>\n#include <sys/wait.h>\ntypedef const void *SOCK_OPT_TYPE;\n\n#if defined(ANDROID)\ntypedef unsigned short int in_port_t;\n#endif\n\n#include <dirent.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#define vsnprintf_impl vsnprintf\n\n#if !defined(NO_SSL_DL) && !defined(NO_SSL)\n#include <dlfcn.h>\n#endif\n#include <pthread.h>\n#if defined(__MACH__)\n#define SSL_LIB \"libssl.dylib\"\n#define CRYPTO_LIB \"libcrypto.dylib\"\n#else\n#if !defined(SSL_LIB)\n#define SSL_LIB \"libssl.so\"\n#endif\n#if !defined(CRYPTO_LIB)\n#define CRYPTO_LIB \"libcrypto.so\"\n#endif\n#endif\n#if !defined(O_BINARY)\n#define O_BINARY (0)\n#endif /* O_BINARY */\n#define closesocket(a) (close(a))\n#define mg_mkdir(conn, path, mode) (mkdir(path, mode))\n#define mg_remove(conn, x) (remove(x))\n#define mg_sleep(x) (usleep((x)*1000))\n#define mg_opendir(conn, x) (opendir(x))\n#define mg_closedir(x) (closedir(x))\n#define mg_readdir(x) (readdir(x))\n#define ERRNO (errno)\n#define INVALID_SOCKET (-1)\n#define INT64_FMT PRId64\n#define UINT64_FMT PRIu64\ntypedef int SOCKET;\n#define WINCDECL\n\n#if defined(__hpux)\n/* HPUX 11 does not have monotonic, fall back to realtime */\n#if !defined(CLOCK_MONOTONIC)\n#define CLOCK_MONOTONIC CLOCK_REALTIME\n#endif\n\n/* HPUX defines socklen_t incorrectly as size_t which is 64bit on\n * Itanium.  Without defining _XOPEN_SOURCE or _XOPEN_SOURCE_EXTENDED\n * the prototypes use int* rather than socklen_t* which matches the\n * actual library expectation.  When called with the wrong size arg\n * accept() returns a zero client inet addr and check_acl() always\n * fails.  Since socklen_t is widely used below, just force replace\n * their typedef with int. - DTL\n */\n#define socklen_t int\n#endif /* hpux */\n\n#endif /* defined(_WIN32) - WINDOWS vs UNIX include block */\n\n/* Maximum queue length for pending connections. This value is passed as\n * parameter to the \"listen\" socket call. */\n#if !defined(SOMAXCONN)\n/* This symbol may be defined in winsock2.h so this must after that include */\n#define SOMAXCONN (100) /* in pending connections (count) */\n#endif\n\n/* In case our C library is missing \"timegm\", provide an implementation */\n#if defined(NEED_TIMEGM)\nstatic inline int\nis_leap(int y)\n{\n\treturn (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;\n}\n\nstatic inline int\ncount_leap(int y)\n{\n\treturn (y - 1969) / 4 - (y - 1901) / 100 + (y - 1601) / 400;\n}\n\ntime_t\ntimegm(struct tm *tm)\n{\n\tstatic const unsigned short ydays[] = {\n\t    0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};\n\tint year = tm->tm_year + 1900;\n\tint mon = tm->tm_mon;\n\tint mday = tm->tm_mday - 1;\n\tint hour = tm->tm_hour;\n\tint min = tm->tm_min;\n\tint sec = tm->tm_sec;\n\n\tif (year < 1970 || mon < 0 || mon > 11 || mday < 0\n\t    || (mday >= ydays[mon + 1] - ydays[mon]\n\t                    + (mon == 1 && is_leap(year) ? 1 : 0))\n\t    || hour < 0 || hour > 23 || min < 0 || min > 59 || sec < 0 || sec > 60)\n\t\treturn -1;\n\n\ttime_t res = year - 1970;\n\tres *= 365;\n\tres += mday;\n\tres += ydays[mon] + (mon > 1 && is_leap(year) ? 1 : 0);\n\tres += count_leap(year);\n\n\tres *= 24;\n\tres += hour;\n\tres *= 60;\n\tres += min;\n\tres *= 60;\n\tres += sec;\n\treturn res;\n}\n#endif /* NEED_TIMEGM */\n\n\n/* va_copy should always be a macro, C99 and C++11 - DTL */\n#if !defined(va_copy)\n#define va_copy(x, y) ((x) = (y))\n#endif\n\n\n#if defined(_WIN32)\n/* Create substitutes for POSIX functions in Win32. */\n\n#if defined(GCC_DIAGNOSTIC)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\n\n\nstatic CRITICAL_SECTION global_log_file_lock;\n\nFUNCTION_MAY_BE_UNUSED\nstatic DWORD\npthread_self(void)\n{\n\treturn GetCurrentThreadId();\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_key_create(\n    pthread_key_t *key,\n    void (*_ignored)(void *) /* destructor not supported for Windows */\n)\n{\n\t(void)_ignored;\n\n\tif ((key != 0)) {\n\t\t*key = TlsAlloc();\n\t\treturn (*key != TLS_OUT_OF_INDEXES) ? 0 : -1;\n\t}\n\treturn -2;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_key_delete(pthread_key_t key)\n{\n\treturn TlsFree(key) ? 0 : 1;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_setspecific(pthread_key_t key, void *value)\n{\n\treturn TlsSetValue(key, value) ? 0 : 1;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic void *\npthread_getspecific(pthread_key_t key)\n{\n\treturn TlsGetValue(key);\n}\n\n#if defined(GCC_DIAGNOSTIC)\n/* Enable unused function warning again */\n#pragma GCC diagnostic pop\n#endif\n\nstatic struct pthread_mutex_undefined_struct *pthread_mutex_attr = NULL;\n#else\nstatic pthread_mutexattr_t pthread_mutex_attr;\n#endif /* _WIN32 */\n\n\n#if defined(_WIN32_WCE)\n/* Create substitutes for POSIX functions in Win32. */\n\n#if defined(GCC_DIAGNOSTIC)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic time_t\ntime(time_t *ptime)\n{\n\ttime_t t;\n\tSYSTEMTIME st;\n\tFILETIME ft;\n\n\tGetSystemTime(&st);\n\tSystemTimeToFileTime(&st, &ft);\n\tt = SYS2UNIX_TIME(ft.dwLowDateTime, ft.dwHighDateTime);\n\n\tif (ptime != NULL) {\n\t\t*ptime = t;\n\t}\n\n\treturn t;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic struct tm *\nlocaltime_s(const time_t *ptime, struct tm *ptm)\n{\n\tint64_t t = ((int64_t)*ptime) * RATE_DIFF + EPOCH_DIFF;\n\tFILETIME ft, lft;\n\tSYSTEMTIME st;\n\tTIME_ZONE_INFORMATION tzinfo;\n\n\tif (ptm == NULL) {\n\t\treturn NULL;\n\t}\n\n\t*(int64_t *)&ft = t;\n\tFileTimeToLocalFileTime(&ft, &lft);\n\tFileTimeToSystemTime(&lft, &st);\n\tptm->tm_year = st.wYear - 1900;\n\tptm->tm_mon = st.wMonth - 1;\n\tptm->tm_wday = st.wDayOfWeek;\n\tptm->tm_mday = st.wDay;\n\tptm->tm_hour = st.wHour;\n\tptm->tm_min = st.wMinute;\n\tptm->tm_sec = st.wSecond;\n\tptm->tm_yday = 0; /* hope nobody uses this */\n\tptm->tm_isdst =\n\t    (GetTimeZoneInformation(&tzinfo) == TIME_ZONE_ID_DAYLIGHT) ? 1 : 0;\n\n\treturn ptm;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic struct tm *\ngmtime_s(const time_t *ptime, struct tm *ptm)\n{\n\t/* FIXME(lsm): fix this. */\n\treturn localtime_s(ptime, ptm);\n}\n\n\nstatic int mg_atomic_inc(volatile int *addr);\nstatic struct tm tm_array[MAX_WORKER_THREADS];\nstatic int tm_index = 0;\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic struct tm *\nlocaltime(const time_t *ptime)\n{\n\tint i = mg_atomic_inc(&tm_index) % (sizeof(tm_array) / sizeof(tm_array[0]));\n\treturn localtime_s(ptime, tm_array + i);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic struct tm *\ngmtime(const time_t *ptime)\n{\n\tint i = mg_atomic_inc(&tm_index) % ARRAY_SIZE(tm_array);\n\treturn gmtime_s(ptime, tm_array + i);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic size_t\nstrftime(char *dst, size_t dst_size, const char *fmt, const struct tm *tm)\n{\n\t/* TODO: (void)mg_snprintf(NULL, dst, dst_size, \"implement strftime()\n\t * for WinCE\"); */\n\treturn 0;\n}\n\n#define _beginthreadex(psec, stack, func, prm, flags, ptid)                    \\\n\t(uintptr_t) CreateThread(psec, stack, func, prm, flags, ptid)\n\n#define remove(f) mg_remove(NULL, f)\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nrename(const char *a, const char *b)\n{\n\twchar_t wa[W_PATH_MAX];\n\twchar_t wb[W_PATH_MAX];\n\tpath_to_unicode(NULL, a, wa, ARRAY_SIZE(wa));\n\tpath_to_unicode(NULL, b, wb, ARRAY_SIZE(wb));\n\n\treturn MoveFileW(wa, wb) ? 0 : -1;\n}\n\n\nstruct stat {\n\tint64_t st_size;\n\ttime_t st_mtime;\n};\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nstat(const char *name, struct stat *st)\n{\n\twchar_t wbuf[W_PATH_MAX];\n\tWIN32_FILE_ATTRIBUTE_DATA attr;\n\ttime_t creation_time, write_time;\n\n\tpath_to_unicode(NULL, name, wbuf, ARRAY_SIZE(wbuf));\n\tmemset(&attr, 0, sizeof(attr));\n\n\tGetFileAttributesExW(wbuf, GetFileExInfoStandard, &attr);\n\tst->st_size =\n\t    (((int64_t)attr.nFileSizeHigh) << 32) + (int64_t)attr.nFileSizeLow;\n\n\twrite_time = SYS2UNIX_TIME(attr.ftLastWriteTime.dwLowDateTime,\n\t                           attr.ftLastWriteTime.dwHighDateTime);\n\tcreation_time = SYS2UNIX_TIME(attr.ftCreationTime.dwLowDateTime,\n\t                              attr.ftCreationTime.dwHighDateTime);\n\n\tif (creation_time > write_time) {\n\t\tst->st_mtime = creation_time;\n\t} else {\n\t\tst->st_mtime = write_time;\n\t}\n\treturn 0;\n}\n\n#define access(x, a) 1 /* not required anyway */\n\n/* WinCE-TODO: define stat, remove, rename, _rmdir, _lseeki64 */\n/* Values from errno.h in Windows SDK (Visual Studio). */\n#define EEXIST 17\n#define EACCES 13\n#define ENOENT 2\n\n#if defined(GCC_DIAGNOSTIC)\n/* Enable unused function warning again */\n#pragma GCC diagnostic pop\n#endif\n\n#endif /* defined(_WIN32_WCE) */\n\n\n#if defined(GCC_DIAGNOSTIC)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif /* defined(GCC_DIAGNOSTIC) */\n#if defined(__clang__)\n/* Show no warning in case system functions are not used. */\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-function\"\n#endif\n\nstatic pthread_mutex_t global_lock_mutex;\n\n\n#if defined(_WIN32)\n/* Forward declaration for Windows */\nFUNCTION_MAY_BE_UNUSED\nstatic int pthread_mutex_lock(pthread_mutex_t *mutex);\n\nFUNCTION_MAY_BE_UNUSED\nstatic int pthread_mutex_unlock(pthread_mutex_t *mutex);\n#endif\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic void\nmg_global_lock(void)\n{\n\t(void)pthread_mutex_lock(&global_lock_mutex);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic void\nmg_global_unlock(void)\n{\n\t(void)pthread_mutex_unlock(&global_lock_mutex);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nmg_atomic_inc(volatile int *addr)\n{\n\tint ret;\n#if defined(_WIN32) && !defined(NO_ATOMICS)\n\t/* Depending on the SDK, this function uses either\n\t * (volatile unsigned int *) or (volatile LONG *),\n\t * so whatever you use, the other SDK is likely to raise a warning. */\n\tret = InterlockedIncrement((volatile long *)addr);\n#elif defined(__GNUC__)                                                        \\\n    && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0)))           \\\n    && !defined(NO_ATOMICS)\n\tret = __sync_add_and_fetch(addr, 1);\n#else\n\tmg_global_lock();\n\tret = (++(*addr));\n\tmg_global_unlock();\n#endif\n\treturn ret;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nmg_atomic_dec(volatile int *addr)\n{\n\tint ret;\n#if defined(_WIN32) && !defined(NO_ATOMICS)\n\t/* Depending on the SDK, this function uses either\n\t * (volatile unsigned int *) or (volatile LONG *),\n\t * so whatever you use, the other SDK is likely to raise a warning. */\n\tret = InterlockedDecrement((volatile long *)addr);\n#elif defined(__GNUC__)                                                        \\\n    && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0)))           \\\n    && !defined(NO_ATOMICS)\n\tret = __sync_sub_and_fetch(addr, 1);\n#else\n\tmg_global_lock();\n\tret = (--(*addr));\n\tmg_global_unlock();\n#endif\n\treturn ret;\n}\n\n\n#if defined(USE_SERVER_STATS)\nstatic int64_t\nmg_atomic_add(volatile int64_t *addr, int64_t value)\n{\n\tint64_t ret;\n#if defined(_WIN64) && !defined(NO_ATOMICS)\n\tret = InterlockedAdd64(addr, value);\n#elif defined(__GNUC__)                                                        \\\n    && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0)))           \\\n    && !defined(NO_ATOMICS)\n\tret = __sync_add_and_fetch(addr, value);\n#else\n\tmg_global_lock();\n\t*addr += value;\n\tret = (*addr);\n\tmg_global_unlock();\n#endif\n\treturn ret;\n}\n#endif\n\n\n#if defined(GCC_DIAGNOSTIC)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic pop\n#endif /* defined(GCC_DIAGNOSTIC) */\n#if defined(__clang__)\n/* Show no warning in case system functions are not used. */\n#pragma clang diagnostic pop\n#endif\n\n\n#if defined(USE_SERVER_STATS)\n\nstruct mg_memory_stat {\n\tvolatile int64_t totalMemUsed;\n\tvolatile int64_t maxMemUsed;\n\tvolatile int blockCount;\n};\n\n\nstatic struct mg_memory_stat *get_memory_stat(struct mg_context *ctx);\n\n\nstatic void *\nmg_malloc_ex(size_t size,\n             struct mg_context *ctx,\n             const char *file,\n             unsigned line)\n{\n\tvoid *data = malloc(size + 2 * sizeof(uintptr_t));\n\tvoid *memory = 0;\n\tstruct mg_memory_stat *mstat = get_memory_stat(ctx);\n\n#if defined(MEMORY_DEBUGGING)\n\tchar mallocStr[256];\n#else\n\t(void)file;\n\t(void)line;\n#endif\n\n\tif (data) {\n\t\tint64_t mmem = mg_atomic_add(&mstat->totalMemUsed, (int64_t)size);\n\t\tif (mmem > mstat->maxMemUsed) {\n\t\t\t/* could use atomic compare exchange, but this\n\t\t\t * seems overkill for statistics data */\n\t\t\tmstat->maxMemUsed = mmem;\n\t\t}\n\n\t\tmg_atomic_inc(&mstat->blockCount);\n\t\t((uintptr_t *)data)[0] = size;\n\t\t((uintptr_t *)data)[1] = (uintptr_t)mstat;\n\t\tmemory = (void *)(((char *)data) + 2 * sizeof(uintptr_t));\n\t}\n\n#if defined(MEMORY_DEBUGGING)\n\tsprintf(mallocStr,\n\t        \"MEM: %p %5lu alloc   %7lu %4lu --- %s:%u\\n\",\n\t        memory,\n\t        (unsigned long)size,\n\t        (unsigned long)mstat->totalMemUsed,\n\t        (unsigned long)mstat->blockCount,\n\t        file,\n\t        line);\n#if defined(_WIN32)\n\tOutputDebugStringA(mallocStr);\n#else\n\tDEBUG_TRACE(\"%s\", mallocStr);\n#endif\n#endif\n\n\treturn memory;\n}\n\n\nstatic void *\nmg_calloc_ex(size_t count,\n             size_t size,\n             struct mg_context *ctx,\n             const char *file,\n             unsigned line)\n{\n\tvoid *data = mg_malloc_ex(size * count, ctx, file, line);\n\n\tif (data) {\n\t\tmemset(data, 0, size * count);\n\t}\n\treturn data;\n}\n\n\nstatic void\nmg_free_ex(void *memory, const char *file, unsigned line)\n{\n\tvoid *data = (void *)(((char *)memory) - 2 * sizeof(uintptr_t));\n\n\n#if defined(MEMORY_DEBUGGING)\n\tchar mallocStr[256];\n#else\n\t(void)file;\n\t(void)line;\n#endif\n\n\tif (memory) {\n\t\tuintptr_t size = ((uintptr_t *)data)[0];\n\t\tstruct mg_memory_stat *mstat =\n\t\t    (struct mg_memory_stat *)(((uintptr_t *)data)[1]);\n\t\tmg_atomic_add(&mstat->totalMemUsed, -(int64_t)size);\n\t\tmg_atomic_dec(&mstat->blockCount);\n#if defined(MEMORY_DEBUGGING)\n\t\tsprintf(mallocStr,\n\t\t        \"MEM: %p %5lu free    %7lu %4lu --- %s:%u\\n\",\n\t\t        memory,\n\t\t        (unsigned long)size,\n\t\t        (unsigned long)mstat->totalMemUsed,\n\t\t        (unsigned long)mstat->blockCount,\n\t\t        file,\n\t\t        line);\n#if defined(_WIN32)\n\t\tOutputDebugStringA(mallocStr);\n#else\n\t\tDEBUG_TRACE(\"%s\", mallocStr);\n#endif\n#endif\n\t\tfree(data);\n\t}\n}\n\n\nstatic void *\nmg_realloc_ex(void *memory,\n              size_t newsize,\n              struct mg_context *ctx,\n              const char *file,\n              unsigned line)\n{\n\tvoid *data;\n\tvoid *_realloc;\n\tuintptr_t oldsize;\n\n#if defined(MEMORY_DEBUGGING)\n\tchar mallocStr[256];\n#else\n\t(void)file;\n\t(void)line;\n#endif\n\n\tif (newsize) {\n\t\tif (memory) {\n\t\t\t/* Reallocate existing block */\n\t\t\tstruct mg_memory_stat *mstat;\n\t\t\tdata = (void *)(((char *)memory) - 2 * sizeof(uintptr_t));\n\t\t\toldsize = ((uintptr_t *)data)[0];\n\t\t\tmstat = (struct mg_memory_stat *)((uintptr_t *)data)[1];\n\t\t\t_realloc = realloc(data, newsize + 2 * sizeof(uintptr_t));\n\t\t\tif (_realloc) {\n\t\t\t\tdata = _realloc;\n\t\t\t\tmg_atomic_add(&mstat->totalMemUsed, -(int64_t)oldsize);\n#if defined(MEMORY_DEBUGGING)\n\t\t\t\tsprintf(mallocStr,\n\t\t\t\t        \"MEM: %p %5lu r-free  %7lu %4lu --- %s:%u\\n\",\n\t\t\t\t        memory,\n\t\t\t\t        (unsigned long)oldsize,\n\t\t\t\t        (unsigned long)mstat->totalMemUsed,\n\t\t\t\t        (unsigned long)mstat->blockCount,\n\t\t\t\t        file,\n\t\t\t\t        line);\n#if defined(_WIN32)\n\t\t\t\tOutputDebugStringA(mallocStr);\n#else\n\t\t\t\tDEBUG_TRACE(\"%s\", mallocStr);\n#endif\n#endif\n\t\t\t\tmg_atomic_add(&mstat->totalMemUsed, (int64_t)newsize);\n#if defined(MEMORY_DEBUGGING)\n\t\t\t\tsprintf(mallocStr,\n\t\t\t\t        \"MEM: %p %5lu r-alloc %7lu %4lu --- %s:%u\\n\",\n\t\t\t\t        memory,\n\t\t\t\t        (unsigned long)newsize,\n\t\t\t\t        (unsigned long)mstat->totalMemUsed,\n\t\t\t\t        (unsigned long)mstat->blockCount,\n\t\t\t\t        file,\n\t\t\t\t        line);\n#if defined(_WIN32)\n\t\t\t\tOutputDebugStringA(mallocStr);\n#else\n\t\t\t\tDEBUG_TRACE(\"%s\", mallocStr);\n#endif\n#endif\n\t\t\t\t*(uintptr_t *)data = newsize;\n\t\t\t\tdata = (void *)(((char *)data) + 2 * sizeof(uintptr_t));\n\t\t\t} else {\n#if defined(MEMORY_DEBUGGING)\n#if defined(_WIN32)\n\t\t\t\tOutputDebugStringA(\"MEM: realloc failed\\n\");\n#else\n\t\t\t\tDEBUG_TRACE(\"%s\", \"MEM: realloc failed\\n\");\n#endif\n#endif\n\t\t\t\treturn _realloc;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Allocate new block */\n\t\t\tdata = mg_malloc_ex(newsize, ctx, file, line);\n\t\t}\n\t} else {\n\t\t/* Free existing block */\n\t\tdata = 0;\n\t\tmg_free_ex(memory, file, line);\n\t}\n\n\treturn data;\n}\n\n#define mg_malloc(a) mg_malloc_ex(a, NULL, __FILE__, __LINE__)\n#define mg_calloc(a, b) mg_calloc_ex(a, b, NULL, __FILE__, __LINE__)\n#define mg_realloc(a, b) mg_realloc_ex(a, b, NULL, __FILE__, __LINE__)\n#define mg_free(a) mg_free_ex(a, __FILE__, __LINE__)\n\n#define mg_malloc_ctx(a, c) mg_malloc_ex(a, c, __FILE__, __LINE__)\n#define mg_calloc_ctx(a, b, c) mg_calloc_ex(a, b, c, __FILE__, __LINE__)\n#define mg_realloc_ctx(a, b, c) mg_realloc_ex(a, b, c, __FILE__, __LINE__)\n\n#else /* USE_SERVER_STATS */\n\nstatic __inline void *\nmg_malloc(size_t a)\n{\n\treturn malloc(a);\n}\n\nstatic __inline void *\nmg_calloc(size_t a, size_t b)\n{\n\treturn calloc(a, b);\n}\n\nstatic __inline void *\nmg_realloc(void *a, size_t b)\n{\n\treturn realloc(a, b);\n}\n\nstatic __inline void\nmg_free(void *a)\n{\n\tfree(a);\n}\n\n#define mg_malloc_ctx(a, c) mg_malloc(a)\n#define mg_calloc_ctx(a, b, c) mg_calloc(a, b)\n#define mg_realloc_ctx(a, b, c) mg_realloc(a, b)\n#define mg_free_ctx(a, c) mg_free(a)\n\n#endif /* USE_SERVER_STATS */\n\n\nstatic void mg_vsnprintf(const struct mg_connection *conn,\n                         int *truncated,\n                         char *buf,\n                         size_t buflen,\n                         const char *fmt,\n                         va_list ap);\n\nstatic void mg_snprintf(const struct mg_connection *conn,\n                        int *truncated,\n                        char *buf,\n                        size_t buflen,\n                        PRINTF_FORMAT_STRING(const char *fmt),\n                        ...) PRINTF_ARGS(5, 6);\n\n/* This following lines are just meant as a reminder to use the mg-functions\n * for memory management */\n#if defined(malloc)\n#undef malloc\n#endif\n#if defined(calloc)\n#undef calloc\n#endif\n#if defined(realloc)\n#undef realloc\n#endif\n#if defined(free)\n#undef free\n#endif\n#if defined(snprintf)\n#undef snprintf\n#endif\n#if defined(vsnprintf)\n#undef vsnprintf\n#endif\n#define malloc DO_NOT_USE_THIS_FUNCTION__USE_mg_malloc\n#define calloc DO_NOT_USE_THIS_FUNCTION__USE_mg_calloc\n#define realloc DO_NOT_USE_THIS_FUNCTION__USE_mg_realloc\n#define free DO_NOT_USE_THIS_FUNCTION__USE_mg_free\n#define snprintf DO_NOT_USE_THIS_FUNCTION__USE_mg_snprintf\n#if defined(_WIN32)\n/* vsnprintf must not be used in any system,\n * but this define only works well for Windows. */\n#define vsnprintf DO_NOT_USE_THIS_FUNCTION__USE_mg_vsnprintf\n#endif\n\n\n/* mg_init_library counter */\nstatic int mg_init_library_called = 0;\n\n#if !defined(NO_SSL)\nstatic int mg_ssl_initialized = 0;\n#endif\n\nstatic pthread_key_t sTlsKey; /* Thread local storage index */\nstatic int thread_idx_max = 0;\n\n#if defined(MG_LEGACY_INTERFACE)\n#define MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE\n#endif\n\nstruct mg_workerTLS {\n\tint is_master;\n\tunsigned long thread_idx;\n#if defined(_WIN32)\n\tHANDLE pthread_cond_helper_mutex;\n\tstruct mg_workerTLS *next_waiting_thread;\n#endif\n#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE)\n\tchar txtbuf[4];\n#endif\n};\n\n\n#if defined(GCC_DIAGNOSTIC)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif /* defined(GCC_DIAGNOSTIC) */\n#if defined(__clang__)\n/* Show no warning in case system functions are not used. */\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-function\"\n#endif\n\n\n/* Get a unique thread ID as unsigned long, independent from the data type\n * of thread IDs defined by the operating system API.\n * If two calls to mg_current_thread_id  return the same value, they calls\n * are done from the same thread. If they return different values, they are\n * done from different threads. (Provided this function is used in the same\n * process context and threads are not repeatedly created and deleted, but\n * CivetWeb does not do that).\n * This function must match the signature required for SSL id callbacks:\n * CRYPTO_set_id_callback\n */\nFUNCTION_MAY_BE_UNUSED\nstatic unsigned long\nmg_current_thread_id(void)\n{\n#if defined(_WIN32)\n\treturn GetCurrentThreadId();\n#else\n\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunreachable-code\"\n/* For every compiler, either \"sizeof(pthread_t) > sizeof(unsigned long)\"\n * or not, so one of the two conditions will be unreachable by construction.\n * Unfortunately the C standard does not define a way to check this at\n * compile time, since the #if preprocessor conditions can not use the sizeof\n * operator as an argument. */\n#endif\n\n\tif (sizeof(pthread_t) > sizeof(unsigned long)) {\n\t\t/* This is the problematic case for CRYPTO_set_id_callback:\n\t\t * The OS pthread_t can not be cast to unsigned long. */\n\t\tstruct mg_workerTLS *tls =\n\t\t    (struct mg_workerTLS *)pthread_getspecific(sTlsKey);\n\t\tif (tls == NULL) {\n\t\t\t/* SSL called from an unknown thread: Create some thread index.\n\t\t\t */\n\t\t\ttls = (struct mg_workerTLS *)mg_malloc(sizeof(struct mg_workerTLS));\n\t\t\ttls->is_master = -2; /* -2 means \"3rd party thread\" */\n\t\t\ttls->thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);\n\t\t\tpthread_setspecific(sTlsKey, tls);\n\t\t}\n\t\treturn tls->thread_idx;\n\t} else {\n\t\t/* pthread_t may be any data type, so a simple cast to unsigned long\n\t\t * can rise a warning/error, depending on the platform.\n\t\t * Here memcpy is used as an anything-to-anything cast. */\n\t\tunsigned long ret = 0;\n\t\tpthread_t t = pthread_self();\n\t\tmemcpy(&ret, &t, sizeof(pthread_t));\n\t\treturn ret;\n\t}\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n#endif\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic uint64_t\nmg_get_current_time_ns(void)\n{\n\tstruct timespec tsnow;\n\tclock_gettime(CLOCK_REALTIME, &tsnow);\n\treturn (((uint64_t)tsnow.tv_sec) * 1000000000) + (uint64_t)tsnow.tv_nsec;\n}\n\n\n#if defined(GCC_DIAGNOSTIC)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic pop\n#endif /* defined(GCC_DIAGNOSTIC) */\n#if defined(__clang__)\n/* Show no warning in case system functions are not used. */\n#pragma clang diagnostic pop\n#endif\n\n\n#if defined(NEED_DEBUG_TRACE_FUNC)\nstatic void\nDEBUG_TRACE_FUNC(const char *func, unsigned line, const char *fmt, ...)\n{\n\tva_list args;\n\tuint64_t nsnow;\n\tstatic uint64_t nslast;\n\tstruct timespec tsnow;\n\n\t/* Get some operating system independent thread id */\n\tunsigned long thread_id = mg_current_thread_id();\n\n\tclock_gettime(CLOCK_REALTIME, &tsnow);\n\tnsnow = ((uint64_t)tsnow.tv_sec) * ((uint64_t)1000000000)\n\t        + ((uint64_t)tsnow.tv_nsec);\n\n\tif (!nslast) {\n\t\tnslast = nsnow;\n\t}\n\n\tflockfile(stdout);\n\tprintf(\"*** %lu.%09lu %12\" INT64_FMT \" %lu %s:%u: \",\n\t       (unsigned long)tsnow.tv_sec,\n\t       (unsigned long)tsnow.tv_nsec,\n\t       nsnow - nslast,\n\t       thread_id,\n\t       func,\n\t       line);\n\tva_start(args, fmt);\n\tvprintf(fmt, args);\n\tva_end(args);\n\tputchar('\\n');\n\tfflush(stdout);\n\tfunlockfile(stdout);\n\tnslast = nsnow;\n}\n#endif /* NEED_DEBUG_TRACE_FUNC */\n\n\n#define MD5_STATIC static\n#include \"md5.inl\"\n\n/* Darwin prior to 7.0 and Win32 do not have socklen_t */\n#if defined(NO_SOCKLEN_T)\ntypedef int socklen_t;\n#endif /* NO_SOCKLEN_T */\n\n#define IP_ADDR_STR_LEN (50) /* IPv6 hex string is 46 chars */\n\n#if !defined(MSG_NOSIGNAL)\n#define MSG_NOSIGNAL (0)\n#endif\n\n\n#if defined(NO_SSL)\ntypedef struct SSL SSL; /* dummy for SSL argument to push/pull */\ntypedef struct SSL_CTX SSL_CTX;\n#else\n#if defined(NO_SSL_DL)\n#include <openssl/bn.h>\n#include <openssl/conf.h>\n#include <openssl/crypto.h>\n#include <openssl/dh.h>\n#include <openssl/engine.h>\n#include <openssl/err.h>\n#include <openssl/opensslv.h>\n#include <openssl/pem.h>\n#include <openssl/ssl.h>\n#include <openssl/tls1.h>\n#include <openssl/x509.h>\n\n#if defined(WOLFSSL_VERSION)\n/* Additional defines for WolfSSL, see\n * https://github.com/civetweb/civetweb/issues/583 */\n#include \"wolfssl_extras.inl\"\n#endif\n\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)\n/* If OpenSSL headers are included, automatically select the API version */\n#if !defined(OPENSSL_API_1_1)\n#define OPENSSL_API_1_1\n#endif\n#define OPENSSL_REMOVE_THREAD_STATE()\n#else\n#define OPENSSL_REMOVE_THREAD_STATE() ERR_remove_thread_state(NULL)\n#endif\n\n#else\n\n/* SSL loaded dynamically from DLL.\n * I put the prototypes here to be independent from OpenSSL source\n * installation. */\n\ntypedef struct ssl_st SSL;\ntypedef struct ssl_method_st SSL_METHOD;\ntypedef struct ssl_ctx_st SSL_CTX;\ntypedef struct x509_store_ctx_st X509_STORE_CTX;\ntypedef struct x509_name X509_NAME;\ntypedef struct asn1_integer ASN1_INTEGER;\ntypedef struct bignum BIGNUM;\ntypedef struct ossl_init_settings_st OPENSSL_INIT_SETTINGS;\ntypedef struct evp_md EVP_MD;\ntypedef struct x509 X509;\n\n\n#define SSL_CTRL_OPTIONS (32)\n#define SSL_CTRL_CLEAR_OPTIONS (77)\n#define SSL_CTRL_SET_ECDH_AUTO (94)\n\n#define OPENSSL_INIT_NO_LOAD_SSL_STRINGS 0x00100000L\n#define OPENSSL_INIT_LOAD_SSL_STRINGS 0x00200000L\n#define OPENSSL_INIT_LOAD_CRYPTO_STRINGS 0x00000002L\n\n#define SSL_VERIFY_NONE (0)\n#define SSL_VERIFY_PEER (1)\n#define SSL_VERIFY_FAIL_IF_NO_PEER_CERT (2)\n#define SSL_VERIFY_CLIENT_ONCE (4)\n#define SSL_OP_ALL ((long)(0x80000BFFUL))\n#define SSL_OP_NO_SSLv2 (0x01000000L)\n#define SSL_OP_NO_SSLv3 (0x02000000L)\n#define SSL_OP_NO_TLSv1 (0x04000000L)\n#define SSL_OP_NO_TLSv1_2 (0x08000000L)\n#define SSL_OP_NO_TLSv1_1 (0x10000000L)\n#define SSL_OP_SINGLE_DH_USE (0x00100000L)\n#define SSL_OP_CIPHER_SERVER_PREFERENCE (0x00400000L)\n#define SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION (0x00010000L)\n#define SSL_OP_NO_COMPRESSION (0x00020000L)\n\n#define SSL_CB_HANDSHAKE_START (0x10)\n#define SSL_CB_HANDSHAKE_DONE (0x20)\n\n#define SSL_ERROR_NONE (0)\n#define SSL_ERROR_SSL (1)\n#define SSL_ERROR_WANT_READ (2)\n#define SSL_ERROR_WANT_WRITE (3)\n#define SSL_ERROR_WANT_X509_LOOKUP (4)\n#define SSL_ERROR_SYSCALL (5) /* see errno */\n#define SSL_ERROR_ZERO_RETURN (6)\n#define SSL_ERROR_WANT_CONNECT (7)\n#define SSL_ERROR_WANT_ACCEPT (8)\n\n#define TLSEXT_TYPE_server_name (0)\n#define TLSEXT_NAMETYPE_host_name (0)\n#define SSL_TLSEXT_ERR_OK (0)\n#define SSL_TLSEXT_ERR_ALERT_WARNING (1)\n#define SSL_TLSEXT_ERR_ALERT_FATAL (2)\n#define SSL_TLSEXT_ERR_NOACK (3)\n\nstruct ssl_func {\n\tconst char *name;  /* SSL function name */\n\tvoid (*ptr)(void); /* Function pointer */\n};\n\n\n#if defined(OPENSSL_API_1_1)\n\n#define SSL_free (*(void (*)(SSL *))ssl_sw[0].ptr)\n#define SSL_accept (*(int (*)(SSL *))ssl_sw[1].ptr)\n#define SSL_connect (*(int (*)(SSL *))ssl_sw[2].ptr)\n#define SSL_read (*(int (*)(SSL *, void *, int))ssl_sw[3].ptr)\n#define SSL_write (*(int (*)(SSL *, const void *, int))ssl_sw[4].ptr)\n#define SSL_get_error (*(int (*)(SSL *, int))ssl_sw[5].ptr)\n#define SSL_set_fd (*(int (*)(SSL *, SOCKET))ssl_sw[6].ptr)\n#define SSL_new (*(SSL * (*)(SSL_CTX *)) ssl_sw[7].ptr)\n#define SSL_CTX_new (*(SSL_CTX * (*)(SSL_METHOD *)) ssl_sw[8].ptr)\n#define TLS_server_method (*(SSL_METHOD * (*)(void)) ssl_sw[9].ptr)\n#define OPENSSL_init_ssl                                                       \\\n\t(*(int (*)(uint64_t opts,                                                  \\\n\t           const OPENSSL_INIT_SETTINGS *settings))ssl_sw[10]               \\\n\t      .ptr)\n#define SSL_CTX_use_PrivateKey_file                                            \\\n\t(*(int (*)(SSL_CTX *, const char *, int))ssl_sw[11].ptr)\n#define SSL_CTX_use_certificate_file                                           \\\n\t(*(int (*)(SSL_CTX *, const char *, int))ssl_sw[12].ptr)\n#define SSL_CTX_set_default_passwd_cb                                          \\\n\t(*(void (*)(SSL_CTX *, mg_callback_t))ssl_sw[13].ptr)\n#define SSL_CTX_free (*(void (*)(SSL_CTX *))ssl_sw[14].ptr)\n#define SSL_CTX_use_certificate_chain_file                                     \\\n\t(*(int (*)(SSL_CTX *, const char *))ssl_sw[15].ptr)\n#define TLS_client_method (*(SSL_METHOD * (*)(void)) ssl_sw[16].ptr)\n#define SSL_pending (*(int (*)(SSL *))ssl_sw[17].ptr)\n#define SSL_CTX_set_verify                                                     \\\n\t(*(void (*)(SSL_CTX *,                                                     \\\n\t            int,                                                           \\\n\t            int (*verify_callback)(int, X509_STORE_CTX *)))ssl_sw[18]      \\\n\t      .ptr)\n#define SSL_shutdown (*(int (*)(SSL *))ssl_sw[19].ptr)\n#define SSL_CTX_load_verify_locations                                          \\\n\t(*(int (*)(SSL_CTX *, const char *, const char *))ssl_sw[20].ptr)\n#define SSL_CTX_set_default_verify_paths (*(int (*)(SSL_CTX *))ssl_sw[21].ptr)\n#define SSL_CTX_set_verify_depth (*(void (*)(SSL_CTX *, int))ssl_sw[22].ptr)\n#define SSL_get_peer_certificate (*(X509 * (*)(SSL *)) ssl_sw[23].ptr)\n#define SSL_get_version (*(const char *(*)(SSL *))ssl_sw[24].ptr)\n#define SSL_get_current_cipher (*(SSL_CIPHER * (*)(SSL *)) ssl_sw[25].ptr)\n#define SSL_CIPHER_get_name                                                    \\\n\t(*(const char *(*)(const SSL_CIPHER *))ssl_sw[26].ptr)\n#define SSL_CTX_check_private_key (*(int (*)(SSL_CTX *))ssl_sw[27].ptr)\n#define SSL_CTX_set_session_id_context                                         \\\n\t(*(int (*)(SSL_CTX *, const unsigned char *, unsigned int))ssl_sw[28].ptr)\n#define SSL_CTX_ctrl (*(long (*)(SSL_CTX *, int, long, void *))ssl_sw[29].ptr)\n#define SSL_CTX_set_cipher_list                                                \\\n\t(*(int (*)(SSL_CTX *, const char *))ssl_sw[30].ptr)\n#define SSL_CTX_set_options                                                    \\\n\t(*(unsigned long (*)(SSL_CTX *, unsigned long))ssl_sw[31].ptr)\n#define SSL_CTX_set_info_callback                                              \\\n\t(*(void (*)(SSL_CTX * ctx, void (*callback)(const SSL *, int, int)))       \\\n\t      ssl_sw[32]                                                           \\\n\t          .ptr)\n#define SSL_get_ex_data (*(char *(*)(const SSL *, int))ssl_sw[33].ptr)\n#define SSL_set_ex_data (*(void (*)(SSL *, int, char *))ssl_sw[34].ptr)\n#define SSL_CTX_callback_ctrl                                                  \\\n\t(*(long (*)(SSL_CTX *, int, void (*)(void)))ssl_sw[35].ptr)\n#define SSL_get_servername                                                     \\\n\t(*(const char *(*)(const SSL *, int type))ssl_sw[36].ptr)\n#define SSL_set_SSL_CTX (*(SSL_CTX * (*)(SSL *, SSL_CTX *)) ssl_sw[37].ptr)\n#define SSL_ctrl (*(long (*)(SSL *, int, long, void *))ssl_sw[38].ptr)\n\n#define SSL_CTX_clear_options(ctx, op)                                         \\\n\tSSL_CTX_ctrl((ctx), SSL_CTRL_CLEAR_OPTIONS, (op), NULL)\n#define SSL_CTX_set_ecdh_auto(ctx, onoff)                                      \\\n\tSSL_CTX_ctrl(ctx, SSL_CTRL_SET_ECDH_AUTO, onoff, NULL)\n\n#define SSL_CTRL_SET_TLSEXT_SERVERNAME_CB 53\n#define SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG 54\n#define SSL_CTRL_SET_TLSEXT_HOSTNAME 55\n#define SSL_CTX_set_tlsext_servername_callback(ctx, cb)                        \\\n\tSSL_CTX_callback_ctrl(ctx,                                                 \\\n\t                      SSL_CTRL_SET_TLSEXT_SERVERNAME_CB,                   \\\n\t                      (void (*)(void))cb)\n#define SSL_CTX_set_tlsext_servername_arg(ctx, arg)                            \\\n\tSSL_CTX_ctrl(ctx, SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG, 0, (void *)arg)\n#define SSL_set_tlsext_host_name(ctx, arg)                                     \\\n\tSSL_ctrl(ctx, SSL_CTRL_SET_TLSEXT_HOSTNAME, 0, (void *)arg)\n\n#define X509_get_notBefore(x) ((x)->cert_info->validity->notBefore)\n#define X509_get_notAfter(x) ((x)->cert_info->validity->notAfter)\n\n#define SSL_set_app_data(s, arg) (SSL_set_ex_data(s, 0, (char *)arg))\n#define SSL_get_app_data(s) (SSL_get_ex_data(s, 0))\n\n#define ERR_get_error (*(unsigned long (*)(void))crypto_sw[0].ptr)\n#define ERR_error_string (*(char *(*)(unsigned long, char *))crypto_sw[1].ptr)\n#define CONF_modules_unload (*(void (*)(int))crypto_sw[2].ptr)\n#define X509_free (*(void (*)(X509 *))crypto_sw[3].ptr)\n#define X509_get_subject_name (*(X509_NAME * (*)(X509 *)) crypto_sw[4].ptr)\n#define X509_get_issuer_name (*(X509_NAME * (*)(X509 *)) crypto_sw[5].ptr)\n#define X509_NAME_oneline                                                      \\\n\t(*(char *(*)(X509_NAME *, char *, int))crypto_sw[6].ptr)\n#define X509_get_serialNumber (*(ASN1_INTEGER * (*)(X509 *)) crypto_sw[7].ptr)\n#define EVP_get_digestbyname                                                   \\\n\t(*(const EVP_MD *(*)(const char *))crypto_sw[8].ptr)\n#define EVP_Digest                                                             \\\n\t(*(int (*)(                                                                \\\n\t    const void *, size_t, void *, unsigned int *, const EVP_MD *, void *)) \\\n\t      crypto_sw[9]                                                         \\\n\t          .ptr)\n#define i2d_X509 (*(int (*)(X509 *, unsigned char **))crypto_sw[10].ptr)\n#define BN_bn2hex (*(char *(*)(const BIGNUM *a))crypto_sw[11].ptr)\n#define ASN1_INTEGER_to_BN                                                     \\\n\t(*(BIGNUM * (*)(const ASN1_INTEGER *ai, BIGNUM *bn)) crypto_sw[12].ptr)\n#define BN_free (*(void (*)(const BIGNUM *a))crypto_sw[13].ptr)\n#define CRYPTO_free (*(void (*)(void *addr))crypto_sw[14].ptr)\n\n#define OPENSSL_free(a) CRYPTO_free(a)\n\n#define OPENSSL_REMOVE_THREAD_STATE()\n\n/* init_ssl_ctx() function updates this array.\n * It loads SSL library dynamically and changes NULLs to the actual addresses\n * of respective functions. The macros above (like SSL_connect()) are really\n * just calling these functions indirectly via the pointer. */\nstatic struct ssl_func ssl_sw[] = {{\"SSL_free\", NULL},\n                                   {\"SSL_accept\", NULL},\n                                   {\"SSL_connect\", NULL},\n                                   {\"SSL_read\", NULL},\n                                   {\"SSL_write\", NULL},\n                                   {\"SSL_get_error\", NULL},\n                                   {\"SSL_set_fd\", NULL},\n                                   {\"SSL_new\", NULL},\n                                   {\"SSL_CTX_new\", NULL},\n                                   {\"TLS_server_method\", NULL},\n                                   {\"OPENSSL_init_ssl\", NULL},\n                                   {\"SSL_CTX_use_PrivateKey_file\", NULL},\n                                   {\"SSL_CTX_use_certificate_file\", NULL},\n                                   {\"SSL_CTX_set_default_passwd_cb\", NULL},\n                                   {\"SSL_CTX_free\", NULL},\n                                   {\"SSL_CTX_use_certificate_chain_file\", NULL},\n                                   {\"TLS_client_method\", NULL},\n                                   {\"SSL_pending\", NULL},\n                                   {\"SSL_CTX_set_verify\", NULL},\n                                   {\"SSL_shutdown\", NULL},\n                                   {\"SSL_CTX_load_verify_locations\", NULL},\n                                   {\"SSL_CTX_set_default_verify_paths\", NULL},\n                                   {\"SSL_CTX_set_verify_depth\", NULL},\n                                   {\"SSL_get_peer_certificate\", NULL},\n                                   {\"SSL_get_version\", NULL},\n                                   {\"SSL_get_current_cipher\", NULL},\n                                   {\"SSL_CIPHER_get_name\", NULL},\n                                   {\"SSL_CTX_check_private_key\", NULL},\n                                   {\"SSL_CTX_set_session_id_context\", NULL},\n                                   {\"SSL_CTX_ctrl\", NULL},\n                                   {\"SSL_CTX_set_cipher_list\", NULL},\n                                   {\"SSL_CTX_set_options\", NULL},\n                                   {\"SSL_CTX_set_info_callback\", NULL},\n                                   {\"SSL_get_ex_data\", NULL},\n                                   {\"SSL_set_ex_data\", NULL},\n                                   {\"SSL_CTX_callback_ctrl\", NULL},\n                                   {\"SSL_get_servername\", NULL},\n                                   {\"SSL_set_SSL_CTX\", NULL},\n                                   {\"SSL_ctrl\", NULL},\n                                   {NULL, NULL}};\n\n\n/* Similar array as ssl_sw. These functions could be located in different\n * lib. */\nstatic struct ssl_func crypto_sw[] = {{\"ERR_get_error\", NULL},\n                                      {\"ERR_error_string\", NULL},\n                                      {\"CONF_modules_unload\", NULL},\n                                      {\"X509_free\", NULL},\n                                      {\"X509_get_subject_name\", NULL},\n                                      {\"X509_get_issuer_name\", NULL},\n                                      {\"X509_NAME_oneline\", NULL},\n                                      {\"X509_get_serialNumber\", NULL},\n                                      {\"EVP_get_digestbyname\", NULL},\n                                      {\"EVP_Digest\", NULL},\n                                      {\"i2d_X509\", NULL},\n                                      {\"BN_bn2hex\", NULL},\n                                      {\"ASN1_INTEGER_to_BN\", NULL},\n                                      {\"BN_free\", NULL},\n                                      {\"CRYPTO_free\", NULL},\n                                      {NULL, NULL}};\n#else\n\n#define SSL_free (*(void (*)(SSL *))ssl_sw[0].ptr)\n#define SSL_accept (*(int (*)(SSL *))ssl_sw[1].ptr)\n#define SSL_connect (*(int (*)(SSL *))ssl_sw[2].ptr)\n#define SSL_read (*(int (*)(SSL *, void *, int))ssl_sw[3].ptr)\n#define SSL_write (*(int (*)(SSL *, const void *, int))ssl_sw[4].ptr)\n#define SSL_get_error (*(int (*)(SSL *, int))ssl_sw[5].ptr)\n#define SSL_set_fd (*(int (*)(SSL *, SOCKET))ssl_sw[6].ptr)\n#define SSL_new (*(SSL * (*)(SSL_CTX *)) ssl_sw[7].ptr)\n#define SSL_CTX_new (*(SSL_CTX * (*)(SSL_METHOD *)) ssl_sw[8].ptr)\n#define SSLv23_server_method (*(SSL_METHOD * (*)(void)) ssl_sw[9].ptr)\n#define SSL_library_init (*(int (*)(void))ssl_sw[10].ptr)\n#define SSL_CTX_use_PrivateKey_file                                            \\\n\t(*(int (*)(SSL_CTX *, const char *, int))ssl_sw[11].ptr)\n#define SSL_CTX_use_certificate_file                                           \\\n\t(*(int (*)(SSL_CTX *, const char *, int))ssl_sw[12].ptr)\n#define SSL_CTX_set_default_passwd_cb                                          \\\n\t(*(void (*)(SSL_CTX *, mg_callback_t))ssl_sw[13].ptr)\n#define SSL_CTX_free (*(void (*)(SSL_CTX *))ssl_sw[14].ptr)\n#define SSL_load_error_strings (*(void (*)(void))ssl_sw[15].ptr)\n#define SSL_CTX_use_certificate_chain_file                                     \\\n\t(*(int (*)(SSL_CTX *, const char *))ssl_sw[16].ptr)\n#define SSLv23_client_method (*(SSL_METHOD * (*)(void)) ssl_sw[17].ptr)\n#define SSL_pending (*(int (*)(SSL *))ssl_sw[18].ptr)\n#define SSL_CTX_set_verify                                                     \\\n\t(*(void (*)(SSL_CTX *,                                                     \\\n\t            int,                                                           \\\n\t            int (*verify_callback)(int, X509_STORE_CTX *)))ssl_sw[19]      \\\n\t      .ptr)\n#define SSL_shutdown (*(int (*)(SSL *))ssl_sw[20].ptr)\n#define SSL_CTX_load_verify_locations                                          \\\n\t(*(int (*)(SSL_CTX *, const char *, const char *))ssl_sw[21].ptr)\n#define SSL_CTX_set_default_verify_paths (*(int (*)(SSL_CTX *))ssl_sw[22].ptr)\n#define SSL_CTX_set_verify_depth (*(void (*)(SSL_CTX *, int))ssl_sw[23].ptr)\n#define SSL_get_peer_certificate (*(X509 * (*)(SSL *)) ssl_sw[24].ptr)\n#define SSL_get_version (*(const char *(*)(SSL *))ssl_sw[25].ptr)\n#define SSL_get_current_cipher (*(SSL_CIPHER * (*)(SSL *)) ssl_sw[26].ptr)\n#define SSL_CIPHER_get_name                                                    \\\n\t(*(const char *(*)(const SSL_CIPHER *))ssl_sw[27].ptr)\n#define SSL_CTX_check_private_key (*(int (*)(SSL_CTX *))ssl_sw[28].ptr)\n#define SSL_CTX_set_session_id_context                                         \\\n\t(*(int (*)(SSL_CTX *, const unsigned char *, unsigned int))ssl_sw[29].ptr)\n#define SSL_CTX_ctrl (*(long (*)(SSL_CTX *, int, long, void *))ssl_sw[30].ptr)\n#define SSL_CTX_set_cipher_list                                                \\\n\t(*(int (*)(SSL_CTX *, const char *))ssl_sw[31].ptr)\n#define SSL_CTX_set_info_callback                                              \\\n\t(*(void (*)(SSL_CTX *, void (*callback)(const SSL *, int, int)))ssl_sw[32] \\\n\t      .ptr)\n#define SSL_get_ex_data (*(char *(*)(const SSL *, int))ssl_sw[33].ptr)\n#define SSL_set_ex_data (*(void (*)(SSL *, int, char *))ssl_sw[34].ptr)\n#define SSL_CTX_callback_ctrl                                                  \\\n\t(*(long (*)(SSL_CTX *, int, void (*)(void)))ssl_sw[35].ptr)\n#define SSL_get_servername                                                     \\\n\t(*(const char *(*)(const SSL *, int type))ssl_sw[36].ptr)\n#define SSL_set_SSL_CTX (*(SSL_CTX * (*)(SSL *, SSL_CTX *)) ssl_sw[37].ptr)\n#define SSL_ctrl (*(long (*)(SSL *, int, long, void *))ssl_sw[38].ptr)\n\n#define SSL_CTX_set_options(ctx, op)                                           \\\n\tSSL_CTX_ctrl((ctx), SSL_CTRL_OPTIONS, (op), NULL)\n#define SSL_CTX_clear_options(ctx, op)                                         \\\n\tSSL_CTX_ctrl((ctx), SSL_CTRL_CLEAR_OPTIONS, (op), NULL)\n#define SSL_CTX_set_ecdh_auto(ctx, onoff)                                      \\\n\tSSL_CTX_ctrl(ctx, SSL_CTRL_SET_ECDH_AUTO, onoff, NULL)\n\n#define SSL_CTRL_SET_TLSEXT_SERVERNAME_CB 53\n#define SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG 54\n#define SSL_CTRL_SET_TLSEXT_HOSTNAME 55\n#define SSL_CTX_set_tlsext_servername_callback(ctx, cb)                        \\\n\tSSL_CTX_callback_ctrl(ctx,                                                 \\\n\t                      SSL_CTRL_SET_TLSEXT_SERVERNAME_CB,                   \\\n\t                      (void (*)(void))cb)\n#define SSL_CTX_set_tlsext_servername_arg(ctx, arg)                            \\\n\tSSL_CTX_ctrl(ctx, SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG, 0, (void *)arg)\n#define SSL_set_tlsext_host_name(ctx, arg)                                     \\\n\tSSL_ctrl(ctx, SSL_CTRL_SET_TLSEXT_HOSTNAME, 0, (void *)arg)\n\n#define X509_get_notBefore(x) ((x)->cert_info->validity->notBefore)\n#define X509_get_notAfter(x) ((x)->cert_info->validity->notAfter)\n\n#define SSL_set_app_data(s, arg) (SSL_set_ex_data(s, 0, (char *)arg))\n#define SSL_get_app_data(s) (SSL_get_ex_data(s, 0))\n\n#define CRYPTO_num_locks (*(int (*)(void))crypto_sw[0].ptr)\n#define CRYPTO_set_locking_callback                                            \\\n\t(*(void (*)(void (*)(int, int, const char *, int)))crypto_sw[1].ptr)\n#define CRYPTO_set_id_callback                                                 \\\n\t(*(void (*)(unsigned long (*)(void)))crypto_sw[2].ptr)\n#define ERR_get_error (*(unsigned long (*)(void))crypto_sw[3].ptr)\n#define ERR_error_string (*(char *(*)(unsigned long, char *))crypto_sw[4].ptr)\n#define ERR_remove_state (*(void (*)(unsigned long))crypto_sw[5].ptr)\n#define ERR_free_strings (*(void (*)(void))crypto_sw[6].ptr)\n#define ENGINE_cleanup (*(void (*)(void))crypto_sw[7].ptr)\n#define CONF_modules_unload (*(void (*)(int))crypto_sw[8].ptr)\n#define CRYPTO_cleanup_all_ex_data (*(void (*)(void))crypto_sw[9].ptr)\n#define EVP_cleanup (*(void (*)(void))crypto_sw[10].ptr)\n#define X509_free (*(void (*)(X509 *))crypto_sw[11].ptr)\n#define X509_get_subject_name (*(X509_NAME * (*)(X509 *)) crypto_sw[12].ptr)\n#define X509_get_issuer_name (*(X509_NAME * (*)(X509 *)) crypto_sw[13].ptr)\n#define X509_NAME_oneline                                                      \\\n\t(*(char *(*)(X509_NAME *, char *, int))crypto_sw[14].ptr)\n#define X509_get_serialNumber (*(ASN1_INTEGER * (*)(X509 *)) crypto_sw[15].ptr)\n#define i2c_ASN1_INTEGER                                                       \\\n\t(*(int (*)(ASN1_INTEGER *, unsigned char **))crypto_sw[16].ptr)\n#define EVP_get_digestbyname                                                   \\\n\t(*(const EVP_MD *(*)(const char *))crypto_sw[17].ptr)\n#define EVP_Digest                                                             \\\n\t(*(int (*)(                                                                \\\n\t    const void *, size_t, void *, unsigned int *, const EVP_MD *, void *)) \\\n\t      crypto_sw[18]                                                        \\\n\t          .ptr)\n#define i2d_X509 (*(int (*)(X509 *, unsigned char **))crypto_sw[19].ptr)\n#define BN_bn2hex (*(char *(*)(const BIGNUM *a))crypto_sw[20].ptr)\n#define ASN1_INTEGER_to_BN                                                     \\\n\t(*(BIGNUM * (*)(const ASN1_INTEGER *ai, BIGNUM *bn)) crypto_sw[21].ptr)\n#define BN_free (*(void (*)(const BIGNUM *a))crypto_sw[22].ptr)\n#define CRYPTO_free (*(void (*)(void *addr))crypto_sw[23].ptr)\n\n#define OPENSSL_free(a) CRYPTO_free(a)\n\n/* use here ERR_remove_state,\n * while on some platforms function is not included into library due to\n * deprication */\n#define OPENSSL_REMOVE_THREAD_STATE() ERR_remove_state(0)\n\n/* init_ssl_ctx() function updates this array.\n * It loads SSL library dynamically and changes NULLs to the actual addresses\n * of respective functions. The macros above (like SSL_connect()) are really\n * just calling these functions indirectly via the pointer. */\nstatic struct ssl_func ssl_sw[] = {{\"SSL_free\", NULL},\n                                   {\"SSL_accept\", NULL},\n                                   {\"SSL_connect\", NULL},\n                                   {\"SSL_read\", NULL},\n                                   {\"SSL_write\", NULL},\n                                   {\"SSL_get_error\", NULL},\n                                   {\"SSL_set_fd\", NULL},\n                                   {\"SSL_new\", NULL},\n                                   {\"SSL_CTX_new\", NULL},\n                                   {\"SSLv23_server_method\", NULL},\n                                   {\"SSL_library_init\", NULL},\n                                   {\"SSL_CTX_use_PrivateKey_file\", NULL},\n                                   {\"SSL_CTX_use_certificate_file\", NULL},\n                                   {\"SSL_CTX_set_default_passwd_cb\", NULL},\n                                   {\"SSL_CTX_free\", NULL},\n                                   {\"SSL_load_error_strings\", NULL},\n                                   {\"SSL_CTX_use_certificate_chain_file\", NULL},\n                                   {\"SSLv23_client_method\", NULL},\n                                   {\"SSL_pending\", NULL},\n                                   {\"SSL_CTX_set_verify\", NULL},\n                                   {\"SSL_shutdown\", NULL},\n                                   {\"SSL_CTX_load_verify_locations\", NULL},\n                                   {\"SSL_CTX_set_default_verify_paths\", NULL},\n                                   {\"SSL_CTX_set_verify_depth\", NULL},\n                                   {\"SSL_get_peer_certificate\", NULL},\n                                   {\"SSL_get_version\", NULL},\n                                   {\"SSL_get_current_cipher\", NULL},\n                                   {\"SSL_CIPHER_get_name\", NULL},\n                                   {\"SSL_CTX_check_private_key\", NULL},\n                                   {\"SSL_CTX_set_session_id_context\", NULL},\n                                   {\"SSL_CTX_ctrl\", NULL},\n                                   {\"SSL_CTX_set_cipher_list\", NULL},\n                                   {\"SSL_CTX_set_info_callback\", NULL},\n                                   {\"SSL_get_ex_data\", NULL},\n                                   {\"SSL_set_ex_data\", NULL},\n                                   {\"SSL_CTX_callback_ctrl\", NULL},\n                                   {\"SSL_get_servername\", NULL},\n                                   {\"SSL_set_SSL_CTX\", NULL},\n                                   {\"SSL_ctrl\", NULL},\n                                   {NULL, NULL}};\n\n\n/* Similar array as ssl_sw. These functions could be located in different\n * lib. */\nstatic struct ssl_func crypto_sw[] = {{\"CRYPTO_num_locks\", NULL},\n                                      {\"CRYPTO_set_locking_callback\", NULL},\n                                      {\"CRYPTO_set_id_callback\", NULL},\n                                      {\"ERR_get_error\", NULL},\n                                      {\"ERR_error_string\", NULL},\n                                      {\"ERR_remove_state\", NULL},\n                                      {\"ERR_free_strings\", NULL},\n                                      {\"ENGINE_cleanup\", NULL},\n                                      {\"CONF_modules_unload\", NULL},\n                                      {\"CRYPTO_cleanup_all_ex_data\", NULL},\n                                      {\"EVP_cleanup\", NULL},\n                                      {\"X509_free\", NULL},\n                                      {\"X509_get_subject_name\", NULL},\n                                      {\"X509_get_issuer_name\", NULL},\n                                      {\"X509_NAME_oneline\", NULL},\n                                      {\"X509_get_serialNumber\", NULL},\n                                      {\"i2c_ASN1_INTEGER\", NULL},\n                                      {\"EVP_get_digestbyname\", NULL},\n                                      {\"EVP_Digest\", NULL},\n                                      {\"i2d_X509\", NULL},\n                                      {\"BN_bn2hex\", NULL},\n                                      {\"ASN1_INTEGER_to_BN\", NULL},\n                                      {\"BN_free\", NULL},\n                                      {\"CRYPTO_free\", NULL},\n                                      {NULL, NULL}};\n#endif /* OPENSSL_API_1_1 */\n#endif /* NO_SSL_DL */\n#endif /* NO_SSL */\n\n\n#if !defined(NO_CACHING)\nstatic const char *month_names[] = {\"Jan\",\n                                    \"Feb\",\n                                    \"Mar\",\n                                    \"Apr\",\n                                    \"May\",\n                                    \"Jun\",\n                                    \"Jul\",\n                                    \"Aug\",\n                                    \"Sep\",\n                                    \"Oct\",\n                                    \"Nov\",\n                                    \"Dec\"};\n#endif /* !NO_CACHING */\n\n/* Unified socket address. For IPv6 support, add IPv6 address structure in\n * the\n * union u. */\nunion usa {\n\tstruct sockaddr sa;\n\tstruct sockaddr_in sin;\n#if defined(USE_IPV6)\n\tstruct sockaddr_in6 sin6;\n#endif\n};\n\n/* Describes a string (chunk of memory). */\nstruct vec {\n\tconst char *ptr;\n\tsize_t len;\n};\n\nstruct mg_file_stat {\n\t/* File properties filled by mg_stat: */\n\tuint64_t size;\n\ttime_t last_modified;\n\tint is_directory; /* Set to 1 if mg_stat is called for a directory */\n\tint is_gzipped;   /* Set to 1 if the content is gzipped, in which\n\t                   * case we need a \"Content-Eencoding: gzip\" header */\n\tint location;     /* 0 = nowhere, 1 = on disk, 2 = in memory */\n};\n\nstruct mg_file_in_memory {\n\tchar *p;\n\tuint32_t pos;\n\tchar mode;\n};\n\nstruct mg_file_access {\n\t/* File properties filled by mg_fopen: */\n\tFILE *fp;\n#if defined(MG_USE_OPEN_FILE)\n\t/* TODO (low): Remove obsolete \"file in memory\" implementation.\n\t * In an \"early 2017\" discussion at Google groups\n\t * https://groups.google.com/forum/#!topic/civetweb/h9HT4CmeYqI\n\t * we decided to get rid of this feature (after some fade-out\n\t * phase). */\n\tconst char *membuf;\n#endif\n};\n\nstruct mg_file {\n\tstruct mg_file_stat stat;\n\tstruct mg_file_access access;\n};\n\n#if defined(MG_USE_OPEN_FILE)\n\n#define STRUCT_FILE_INITIALIZER                                                \\\n\t{                                                                          \\\n\t\t{(uint64_t)0, (time_t)0, 0, 0, 0},                                     \\\n\t\t{                                                                      \\\n\t\t\t(FILE *)NULL, (const char *)NULL                                   \\\n\t\t}                                                                      \\\n\t}\n\n#else\n\n#define STRUCT_FILE_INITIALIZER                                                \\\n\t{                                                                          \\\n\t\t{(uint64_t)0, (time_t)0, 0, 0, 0},                                     \\\n\t\t{                                                                      \\\n\t\t\t(FILE *)NULL                                                       \\\n\t\t}                                                                      \\\n\t}\n\n#endif\n\n\n/* Describes listening socket, or socket which was accept()-ed by the master\n * thread and queued for future handling by the worker thread. */\nstruct socket {\n\tSOCKET sock;             /* Listening socket */\n\tunion usa lsa;           /* Local socket address */\n\tunion usa rsa;           /* Remote socket address */\n\tunsigned char is_ssl;    /* Is port SSL-ed */\n\tunsigned char ssl_redir; /* Is port supposed to redirect everything to SSL\n\t                          * port */\n\tunsigned char in_use;    /* Is valid */\n};\n\n\n/* Enum const for all options must be in sync with\n * static struct mg_option config_options[]\n * This is tested in the unit test (test/private.c)\n * \"Private Config Options\"\n */\nenum {\n\t/* Once for each server */\n\tLISTENING_PORTS,\n\tNUM_THREADS,\n\tRUN_AS_USER,\n\tCONFIG_TCP_NODELAY, /* Prepended CONFIG_ to avoid conflict with the\n\t                     * socket option typedef TCP_NODELAY. */\n\tMAX_REQUEST_SIZE,\n\tLINGER_TIMEOUT,\n#if defined(__linux__)\n\tALLOW_SENDFILE_CALL,\n#endif\n#if defined(_WIN32)\n\tCASE_SENSITIVE_FILES,\n#endif\n\tTHROTTLE,\n\tACCESS_LOG_FILE,\n\tERROR_LOG_FILE,\n\tENABLE_KEEP_ALIVE,\n\tREQUEST_TIMEOUT,\n\tKEEP_ALIVE_TIMEOUT,\n#if defined(USE_WEBSOCKET)\n\tWEBSOCKET_TIMEOUT,\n\tENABLE_WEBSOCKET_PING_PONG,\n#endif\n\tDECODE_URL,\n#if defined(USE_LUA)\n\tLUA_BACKGROUND_SCRIPT,\n\tLUA_BACKGROUND_SCRIPT_PARAMS,\n#endif\n#if defined(USE_TIMERS)\n\tCGI_TIMEOUT,\n#endif\n\n\t/* Once for each domain */\n\tDOCUMENT_ROOT,\n\tCGI_EXTENSIONS,\n\tCGI_ENVIRONMENT,\n\tPUT_DELETE_PASSWORDS_FILE,\n\tCGI_INTERPRETER,\n\tPROTECT_URI,\n\tAUTHENTICATION_DOMAIN,\n\tENABLE_AUTH_DOMAIN_CHECK,\n\tSSI_EXTENSIONS,\n\tENABLE_DIRECTORY_LISTING,\n\tGLOBAL_PASSWORDS_FILE,\n\tINDEX_FILES,\n\tACCESS_CONTROL_LIST,\n\tEXTRA_MIME_TYPES,\n\tSSL_CERTIFICATE,\n\tSSL_CERTIFICATE_CHAIN,\n\tURL_REWRITE_PATTERN,\n\tHIDE_FILES,\n\tSSL_DO_VERIFY_PEER,\n\tSSL_CA_PATH,\n\tSSL_CA_FILE,\n\tSSL_VERIFY_DEPTH,\n\tSSL_DEFAULT_VERIFY_PATHS,\n\tSSL_CIPHER_LIST,\n\tSSL_PROTOCOL_VERSION,\n\tSSL_SHORT_TRUST,\n\n#if defined(USE_LUA)\n\tLUA_PRELOAD_FILE,\n\tLUA_SCRIPT_EXTENSIONS,\n\tLUA_SERVER_PAGE_EXTENSIONS,\n#if defined(MG_EXPERIMENTAL_INTERFACES)\n\tLUA_DEBUG_PARAMS,\n#endif\n#endif\n#if defined(USE_DUKTAPE)\n\tDUKTAPE_SCRIPT_EXTENSIONS,\n#endif\n\n#if defined(USE_WEBSOCKET)\n\tWEBSOCKET_ROOT,\n#endif\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\tLUA_WEBSOCKET_EXTENSIONS,\n#endif\n\n\tACCESS_CONTROL_ALLOW_ORIGIN,\n\tACCESS_CONTROL_ALLOW_METHODS,\n\tACCESS_CONTROL_ALLOW_HEADERS,\n\tERROR_PAGES,\n#if !defined(NO_CACHING)\n\tSTATIC_FILE_MAX_AGE,\n#endif\n#if !defined(NO_SSL)\n\tSTRICT_HTTPS_MAX_AGE,\n#endif\n\tADDITIONAL_HEADER,\n\tALLOW_INDEX_SCRIPT_SUB_RES,\n\n\tNUM_OPTIONS\n};\n\n\n/* Config option name, config types, default value.\n * Must be in the same order as the enum const above.\n */\nstatic const struct mg_option config_options[] = {\n\n    /* Once for each server */\n    {\"listening_ports\", MG_CONFIG_TYPE_STRING_LIST, \"8080\"},\n    {\"num_threads\", MG_CONFIG_TYPE_NUMBER, \"50\"},\n    {\"run_as_user\", MG_CONFIG_TYPE_STRING, NULL},\n    {\"tcp_nodelay\", MG_CONFIG_TYPE_NUMBER, \"0\"},\n    {\"max_request_size\", MG_CONFIG_TYPE_NUMBER, \"16384\"},\n    {\"linger_timeout_ms\", MG_CONFIG_TYPE_NUMBER, NULL},\n#if defined(__linux__)\n    {\"allow_sendfile_call\", MG_CONFIG_TYPE_BOOLEAN, \"yes\"},\n#endif\n#if defined(_WIN32)\n    {\"case_sensitive\", MG_CONFIG_TYPE_BOOLEAN, \"no\"},\n#endif\n    {\"throttle\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"access_log_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"error_log_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"enable_keep_alive\", MG_CONFIG_TYPE_BOOLEAN, \"no\"},\n    {\"request_timeout_ms\", MG_CONFIG_TYPE_NUMBER, \"30000\"},\n    {\"keep_alive_timeout_ms\", MG_CONFIG_TYPE_NUMBER, \"500\"},\n#if defined(USE_WEBSOCKET)\n    {\"websocket_timeout_ms\", MG_CONFIG_TYPE_NUMBER, NULL},\n    {\"enable_websocket_ping_pong\", MG_CONFIG_TYPE_BOOLEAN, \"no\"},\n#endif\n    {\"decode_url\", MG_CONFIG_TYPE_BOOLEAN, \"yes\"},\n#if defined(USE_LUA)\n    {\"lua_background_script\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"lua_background_script_params\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n#endif\n#if defined(USE_TIMERS)\n    {\"cgi_timeout_ms\", MG_CONFIG_TYPE_NUMBER, NULL},\n#endif\n\n    /* Once for each domain */\n    {\"document_root\", MG_CONFIG_TYPE_DIRECTORY, NULL},\n    {\"cgi_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.cgi$|**.pl$|**.php$\"},\n    {\"cgi_environment\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"put_delete_auth_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"cgi_interpreter\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"protect_uri\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"authentication_domain\", MG_CONFIG_TYPE_STRING, \"mydomain.com\"},\n    {\"enable_auth_domain_check\", MG_CONFIG_TYPE_BOOLEAN, \"yes\"},\n    {\"ssi_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.shtml$|**.shtm$\"},\n    {\"enable_directory_listing\", MG_CONFIG_TYPE_BOOLEAN, \"yes\"},\n    {\"global_auth_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"index_files\",\n     MG_CONFIG_TYPE_STRING_LIST,\n#if defined(USE_LUA)\n     \"index.xhtml,index.html,index.htm,\"\n     \"index.lp,index.lsp,index.lua,index.cgi,\"\n     \"index.shtml,index.php\"},\n#else\n     \"index.xhtml,index.html,index.htm,index.cgi,index.shtml,index.php\"},\n#endif\n    {\"access_control_list\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"extra_mime_types\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"ssl_certificate\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"ssl_certificate_chain\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"url_rewrite_patterns\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"hide_files_patterns\", MG_CONFIG_TYPE_EXT_PATTERN, NULL},\n\n    {\"ssl_verify_peer\", MG_CONFIG_TYPE_YES_NO_OPTIONAL, \"no\"},\n\n    {\"ssl_ca_path\", MG_CONFIG_TYPE_DIRECTORY, NULL},\n    {\"ssl_ca_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"ssl_verify_depth\", MG_CONFIG_TYPE_NUMBER, \"9\"},\n    {\"ssl_default_verify_paths\", MG_CONFIG_TYPE_BOOLEAN, \"yes\"},\n    {\"ssl_cipher_list\", MG_CONFIG_TYPE_STRING, NULL},\n    {\"ssl_protocol_version\", MG_CONFIG_TYPE_NUMBER, \"0\"},\n    {\"ssl_short_trust\", MG_CONFIG_TYPE_BOOLEAN, \"no\"},\n\n#if defined(USE_LUA)\n    {\"lua_preload_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"lua_script_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.lua$\"},\n    {\"lua_server_page_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.lp$|**.lsp$\"},\n#if defined(MG_EXPERIMENTAL_INTERFACES)\n    {\"lua_debug\", MG_CONFIG_TYPE_STRING, NULL},\n#endif\n#endif\n#if defined(USE_DUKTAPE)\n    /* The support for duktape is still in alpha version state.\n     * The name of this config option might change. */\n    {\"duktape_script_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.ssjs$\"},\n#endif\n\n#if defined(USE_WEBSOCKET)\n    {\"websocket_root\", MG_CONFIG_TYPE_DIRECTORY, NULL},\n#endif\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n    {\"lua_websocket_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.lua$\"},\n#endif\n    {\"access_control_allow_origin\", MG_CONFIG_TYPE_STRING, \"*\"},\n    {\"access_control_allow_methods\", MG_CONFIG_TYPE_STRING, \"*\"},\n    {\"access_control_allow_headers\", MG_CONFIG_TYPE_STRING, \"*\"},\n    {\"error_pages\", MG_CONFIG_TYPE_DIRECTORY, NULL},\n#if !defined(NO_CACHING)\n    {\"static_file_max_age\", MG_CONFIG_TYPE_NUMBER, \"3600\"},\n#endif\n#if !defined(NO_SSL)\n    {\"strict_transport_security_max_age\", MG_CONFIG_TYPE_NUMBER, NULL},\n#endif\n    {\"additional_header\", MG_CONFIG_TYPE_STRING_MULTILINE, NULL},\n    {\"allow_index_script_resource\", MG_CONFIG_TYPE_BOOLEAN, \"no\"},\n\n    {NULL, MG_CONFIG_TYPE_UNKNOWN, NULL}};\n\n\n/* Check if the config_options and the corresponding enum have compatible\n * sizes. */\nmg_static_assert((sizeof(config_options) / sizeof(config_options[0]))\n                     == (NUM_OPTIONS + 1),\n                 \"config_options and enum not sync\");\n\n\nenum { REQUEST_HANDLER, WEBSOCKET_HANDLER, AUTH_HANDLER };\n\n\nstruct mg_handler_info {\n\t/* Name/Pattern of the URI. */\n\tchar *uri;\n\tsize_t uri_len;\n\n\t/* handler type */\n\tint handler_type;\n\n\t/* Handler for http/https or authorization requests. */\n\tmg_request_handler handler;\n\tunsigned int refcount;\n\tpthread_mutex_t refcount_mutex; /* Protects refcount */\n\tpthread_cond_t\n\t    refcount_cond; /* Signaled when handler refcount is decremented */\n\n\t/* Handler for ws/wss (websocket) requests. */\n\tmg_websocket_connect_handler connect_handler;\n\tmg_websocket_ready_handler ready_handler;\n\tmg_websocket_data_handler data_handler;\n\tmg_websocket_close_handler close_handler;\n\n\t/* accepted subprotocols for ws/wss requests. */\n\tstruct mg_websocket_subprotocols *subprotocols;\n\n\t/* Handler for authorization requests */\n\tmg_authorization_handler auth_handler;\n\n\t/* User supplied argument for the handler function. */\n\tvoid *cbdata;\n\n\t/* next handler in a linked list */\n\tstruct mg_handler_info *next;\n};\n\n\nenum {\n\tCONTEXT_INVALID,\n\tCONTEXT_SERVER,\n\tCONTEXT_HTTP_CLIENT,\n\tCONTEXT_WS_CLIENT\n};\n\n\nstruct mg_domain_context {\n\tSSL_CTX *ssl_ctx;                 /* SSL context */\n\tchar *config[NUM_OPTIONS];        /* Civetweb configuration parameters */\n\tstruct mg_handler_info *handlers; /* linked list of uri handlers */\n\n\t/* Server nonce */\n\tuint64_t auth_nonce_mask;  /* Mask for all nonce values */\n\tunsigned long nonce_count; /* Used nonces, used for authentication */\n\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\t/* linked list of shared lua websockets */\n\tstruct mg_shared_lua_websocket_list *shared_lua_websockets;\n#endif\n\n\t/* Linked list of domains */\n\tstruct mg_domain_context *next;\n};\n\n\nstruct mg_context {\n\n\t/* Part 1 - Physical context:\n\t * This holds threads, ports, timeouts, ...\n\t * set for the entire server, independent from the\n\t * addressed hostname.\n\t */\n\n\t/* Connection related */\n\tint context_type; /* See CONTEXT_* above */\n\n\tstruct socket *listening_sockets;\n\tstruct pollfd *listening_socket_fds;\n\tunsigned int num_listening_sockets;\n\n\tstruct mg_connection *worker_connections; /* The connection struct, pre-\n\t                                           * allocated for each worker */\n\n#if defined(USE_SERVER_STATS)\n\tint active_connections;\n\tint max_connections;\n\tint64_t total_connections;\n\tint64_t total_requests;\n\tint64_t total_data_read;\n\tint64_t total_data_written;\n#endif\n\n\t/* Thread related */\n\tvolatile int stop_flag;       /* Should we stop event loop */\n\tpthread_mutex_t thread_mutex; /* Protects (max|num)_threads */\n\n\tpthread_t masterthreadid; /* The master thread ID */\n\tunsigned int\n\t    cfg_worker_threads;      /* The number of configured worker threads. */\n\tpthread_t *worker_threadids; /* The worker thread IDs */\n\n/* Connection to thread dispatching */\n#if defined(ALTERNATIVE_QUEUE)\n\tstruct socket *client_socks;\n\tvoid **client_wait_events;\n#else\n\tstruct socket queue[MGSQLEN]; /* Accepted sockets */\n\tvolatile int sq_head;         /* Head of the socket queue */\n\tvolatile int sq_tail;         /* Tail of the socket queue */\n\tpthread_cond_t sq_full;       /* Signaled when socket is produced */\n\tpthread_cond_t sq_empty;      /* Signaled when socket is consumed */\n#endif\n\n\t/* Memory related */\n\tunsigned int max_request_size; /* The max request size */\n\n#if defined(USE_SERVER_STATS)\n\tstruct mg_memory_stat ctx_memory;\n#endif\n\n\t/* Operating system related */\n\tchar *systemName;  /* What operating system is running */\n\ttime_t start_time; /* Server start time, used for authentication\n\t                    * and for diagnstics. */\n\n#if defined(USE_TIMERS)\n\tstruct ttimers *timers;\n#endif\n\n/* Lua specific: Background operations and shared websockets */\n#if defined(USE_LUA)\n\tvoid *lua_background_state;\n#endif\n\n\t/* Server nonce */\n\tpthread_mutex_t nonce_mutex; /* Protects nonce_count */\n\n\t/* Server callbacks */\n\tstruct mg_callbacks callbacks; /* User-defined callback function */\n\tvoid *user_data;               /* User-defined data */\n\n\t/* Part 2 - Logical domain:\n\t * This holds hostname, TLS certificate, document root, ...\n\t * set for a domain hosted at the server.\n\t * There may be multiple domains hosted at one physical server.\n\t * The default domain \"dd\" is the first element of a list of\n\t * domains.\n\t */\n\tstruct mg_domain_context dd; /* default domain */\n};\n\n\n#if defined(USE_SERVER_STATS)\nstatic struct mg_memory_stat mg_common_memory = {0, 0, 0};\n\nstatic struct mg_memory_stat *\nget_memory_stat(struct mg_context *ctx)\n{\n\tif (ctx) {\n\t\treturn &(ctx->ctx_memory);\n\t}\n\treturn &mg_common_memory;\n}\n#endif\n\nenum {\n\tCONNECTION_TYPE_INVALID,\n\tCONNECTION_TYPE_REQUEST,\n\tCONNECTION_TYPE_RESPONSE\n};\n\nstruct mg_connection {\n\tint connection_type; /* see CONNECTION_TYPE_* above */\n\n\tstruct mg_request_info request_info;\n\tstruct mg_response_info response_info;\n\n\tstruct mg_context *phys_ctx;\n\tstruct mg_domain_context *dom_ctx;\n\n#if defined(USE_SERVER_STATS)\n\tint conn_state; /* 0 = undef, numerical value may change in different\n\t                 * versions. For the current definition, see\n\t                 * mg_get_connection_info_impl */\n#endif\n\n\tconst char *host;         /* Host (HTTP/1.1 header or SNI) */\n\tSSL *ssl;                 /* SSL descriptor */\n\tSSL_CTX *client_ssl_ctx;  /* SSL context for client connections */\n\tstruct socket client;     /* Connected client */\n\ttime_t conn_birth_time;   /* Time (wall clock) when connection was\n\t                           * established */\n\tstruct timespec req_time; /* Time (since system start) when the request\n\t                           * was received */\n\tint64_t num_bytes_sent;   /* Total bytes sent to client */\n\tint64_t content_len;      /* Content-Length header value */\n\tint64_t consumed_content; /* How many bytes of content have been read */\n\tint is_chunked;           /* Transfer-Encoding is chunked:\n\t                           * 0 = not chunked,\n\t                           * 1 = chunked, do data read yet,\n\t                           * 2 = chunked, some data read,\n\t                           * 3 = chunked, all data read\n\t                           */\n\tsize_t chunk_remainder;   /* Unread data from the last chunk */\n\tchar *buf;                /* Buffer for received data */\n\tchar *path_info;          /* PATH_INFO part of the URL */\n\n\tint must_close;       /* 1 if connection must be closed */\n\tint accept_gzip;      /* 1 if gzip encoding is accepted */\n\tint in_error_handler; /* 1 if in handler for user defined error\n\t                       * pages */\n#if defined(USE_WEBSOCKET)\n\tint in_websocket_handling; /* 1 if in read_websocket */\n#endif\n\tint handled_requests; /* Number of requests handled by this connection\n\t                       */\n\tint buf_size;         /* Buffer size */\n\tint request_len;      /* Size of the request + headers in a buffer */\n\tint data_len;         /* Total size of data in a buffer */\n\tint status_code;      /* HTTP reply status code, e.g. 200 */\n\tint throttle;         /* Throttling, bytes/sec. <= 0 means no\n\t                       * throttle */\n\n\ttime_t last_throttle_time;   /* Last time throttled data was sent */\n\tint64_t last_throttle_bytes; /* Bytes sent this second */\n\tpthread_mutex_t mutex;       /* Used by mg_(un)lock_connection to ensure\n\t                              * atomic transmissions for websockets */\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\tvoid *lua_websocket_state; /* Lua_State for a websocket connection */\n#endif\n\n\tint thread_index; /* Thread index within ctx */\n};\n\n\n/* Directory entry */\nstruct de {\n\tstruct mg_connection *conn;\n\tchar *file_name;\n\tstruct mg_file_stat file;\n};\n\n\n#if defined(USE_WEBSOCKET)\nstatic int is_websocket_protocol(const struct mg_connection *conn);\n#else\n#define is_websocket_protocol(conn) (0)\n#endif\n\n\n#define mg_cry_internal(conn, fmt, ...)                                        \\\n\tmg_cry_internal_wrap(conn, __func__, __LINE__, fmt, __VA_ARGS__)\n\nstatic void mg_cry_internal_wrap(const struct mg_connection *conn,\n                                 const char *func,\n                                 unsigned line,\n                                 const char *fmt,\n                                 ...) PRINTF_ARGS(4, 5);\n\n\n#if !defined(NO_THREAD_NAME)\n#if defined(_WIN32) && defined(_MSC_VER)\n/* Set the thread name for debugging purposes in Visual Studio\n * http://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx\n */\n#pragma pack(push, 8)\ntypedef struct tagTHREADNAME_INFO {\n\tDWORD dwType;     /* Must be 0x1000. */\n\tLPCSTR szName;    /* Pointer to name (in user addr space). */\n\tDWORD dwThreadID; /* Thread ID (-1=caller thread). */\n\tDWORD dwFlags;    /* Reserved for future use, must be zero. */\n} THREADNAME_INFO;\n#pragma pack(pop)\n\n#elif defined(__linux__)\n\n#include <sys/prctl.h>\n#include <sys/sendfile.h>\n#if defined(ALTERNATIVE_QUEUE)\n#include <sys/eventfd.h>\n#endif /* ALTERNATIVE_QUEUE */\n\n\n#if defined(ALTERNATIVE_QUEUE)\n\nstatic void *\nevent_create(void)\n{\n\tint evhdl = eventfd(0, EFD_CLOEXEC);\n\tint *ret;\n\n\tif (evhdl == -1) {\n\t\t/* Linux uses -1 on error, Windows NULL. */\n\t\t/* However, Linux does not return 0 on success either. */\n\t\treturn 0;\n\t}\n\n\tret = (int *)mg_malloc(sizeof(int));\n\tif (ret) {\n\t\t*ret = evhdl;\n\t} else {\n\t\t(void)close(evhdl);\n\t}\n\n\treturn (void *)ret;\n}\n\n\nstatic int\nevent_wait(void *eventhdl)\n{\n\tuint64_t u;\n\tint evhdl, s;\n\n\tif (!eventhdl) {\n\t\t/* error */\n\t\treturn 0;\n\t}\n\tevhdl = *(int *)eventhdl;\n\n\ts = (int)read(evhdl, &u, sizeof(u));\n\tif (s != sizeof(u)) {\n\t\t/* error */\n\t\treturn 0;\n\t}\n\t(void)u; /* the value is not required */\n\treturn 1;\n}\n\n\nstatic int\nevent_signal(void *eventhdl)\n{\n\tuint64_t u = 1;\n\tint evhdl, s;\n\n\tif (!eventhdl) {\n\t\t/* error */\n\t\treturn 0;\n\t}\n\tevhdl = *(int *)eventhdl;\n\n\ts = (int)write(evhdl, &u, sizeof(u));\n\tif (s != sizeof(u)) {\n\t\t/* error */\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n\nstatic void\nevent_destroy(void *eventhdl)\n{\n\tint evhdl;\n\n\tif (!eventhdl) {\n\t\t/* error */\n\t\treturn;\n\t}\n\tevhdl = *(int *)eventhdl;\n\n\tclose(evhdl);\n\tmg_free(eventhdl);\n}\n\n\n#endif\n\n#endif\n\n\n#if !defined(__linux__) && !defined(_WIN32) && defined(ALTERNATIVE_QUEUE)\n\nstruct posix_event {\n\tpthread_mutex_t mutex;\n\tpthread_cond_t cond;\n};\n\n\nstatic void *\nevent_create(void)\n{\n\tstruct posix_event *ret = mg_malloc(sizeof(struct posix_event));\n\tif (ret == 0) {\n\t\t/* out of memory */\n\t\treturn 0;\n\t}\n\tif (0 != pthread_mutex_init(&(ret->mutex), NULL)) {\n\t\t/* pthread mutex not available */\n\t\tmg_free(ret);\n\t\treturn 0;\n\t}\n\tif (0 != pthread_cond_init(&(ret->cond), NULL)) {\n\t\t/* pthread cond not available */\n\t\tpthread_mutex_destroy(&(ret->mutex));\n\t\tmg_free(ret);\n\t\treturn 0;\n\t}\n\treturn (void *)ret;\n}\n\n\nstatic int\nevent_wait(void *eventhdl)\n{\n\tstruct posix_event *ev = (struct posix_event *)eventhdl;\n\tpthread_mutex_lock(&(ev->mutex));\n\tpthread_cond_wait(&(ev->cond), &(ev->mutex));\n\tpthread_mutex_unlock(&(ev->mutex));\n\treturn 1;\n}\n\n\nstatic int\nevent_signal(void *eventhdl)\n{\n\tstruct posix_event *ev = (struct posix_event *)eventhdl;\n\tpthread_mutex_lock(&(ev->mutex));\n\tpthread_cond_signal(&(ev->cond));\n\tpthread_mutex_unlock(&(ev->mutex));\n\treturn 1;\n}\n\n\nstatic void\nevent_destroy(void *eventhdl)\n{\n\tstruct posix_event *ev = (struct posix_event *)eventhdl;\n\tpthread_cond_destroy(&(ev->cond));\n\tpthread_mutex_destroy(&(ev->mutex));\n\tmg_free(ev);\n}\n#endif\n\n\nstatic void\nmg_set_thread_name(const char *name)\n{\n\tchar threadName[16 + 1]; /* 16 = Max. thread length in Linux/OSX/.. */\n\n\tmg_snprintf(\n\t    NULL, NULL, threadName, sizeof(threadName), \"civetweb-%s\", name);\n\n#if defined(_WIN32)\n#if defined(_MSC_VER)\n\t/* Windows and Visual Studio Compiler */\n\t__try {\n\t\tTHREADNAME_INFO info;\n\t\tinfo.dwType = 0x1000;\n\t\tinfo.szName = threadName;\n\t\tinfo.dwThreadID = ~0U;\n\t\tinfo.dwFlags = 0;\n\n\t\tRaiseException(0x406D1388,\n\t\t               0,\n\t\t               sizeof(info) / sizeof(ULONG_PTR),\n\t\t               (ULONG_PTR *)&info);\n\t} __except (EXCEPTION_EXECUTE_HANDLER) {\n\t}\n#elif defined(__MINGW32__)\n/* No option known to set thread name for MinGW */\n#endif\n#elif defined(_GNU_SOURCE) && defined(__GLIBC__)                               \\\n    && ((__GLIBC__ > 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ >= 12)))\n/* pthread_setname_np first appeared in glibc in version 2.12*/\n#if defined(__MACH__)\n\t/* OS X only current thread name can be changed */\n\t(void)pthread_setname_np(threadName);\n#else\n\t(void)pthread_setname_np(pthread_self(), threadName);\n#endif\n#elif defined(__linux__)\n\t/* on linux we can use the old prctl function */\n\t(void)prctl(PR_SET_NAME, threadName, 0, 0, 0);\n#endif\n}\n#else /* !defined(NO_THREAD_NAME) */\nvoid\nmg_set_thread_name(const char *threadName)\n{\n}\n#endif\n\n\n#if defined(MG_LEGACY_INTERFACE)\nconst char **\nmg_get_valid_option_names(void)\n{\n\t/* This function is deprecated. Use mg_get_valid_options instead. */\n\tstatic const char\n\t    *data[2 * sizeof(config_options) / sizeof(config_options[0])] = {0};\n\tint i;\n\n\tfor (i = 0; config_options[i].name != NULL; i++) {\n\t\tdata[i * 2] = config_options[i].name;\n\t\tdata[i * 2 + 1] = config_options[i].default_value;\n\t}\n\n\treturn data;\n}\n#endif\n\n\nconst struct mg_option *\nmg_get_valid_options(void)\n{\n\treturn config_options;\n}\n\n\n/* Do not open file (used in is_file_in_memory) */\n#define MG_FOPEN_MODE_NONE (0)\n\n/* Open file for read only access */\n#define MG_FOPEN_MODE_READ (1)\n\n/* Open file for writing, create and overwrite */\n#define MG_FOPEN_MODE_WRITE (2)\n\n/* Open file for writing, create and append */\n#define MG_FOPEN_MODE_APPEND (4)\n\n\n/* If a file is in memory, set all \"stat\" members and the membuf pointer of\n * output filep and return 1, otherwise return 0 and don't modify anything.\n */\nstatic int\nopen_file_in_memory(const struct mg_connection *conn,\n                    const char *path,\n                    struct mg_file *filep,\n                    int mode)\n{\n#if defined(MG_USE_OPEN_FILE)\n\n\tsize_t size = 0;\n\tconst char *buf = NULL;\n\tif (!conn) {\n\t\treturn 0;\n\t}\n\n\tif ((mode != MG_FOPEN_MODE_NONE) && (mode != MG_FOPEN_MODE_READ)) {\n\t\treturn 0;\n\t}\n\n\tif (conn->phys_ctx->callbacks.open_file) {\n\t\tbuf = conn->phys_ctx->callbacks.open_file(conn, path, &size);\n\t\tif (buf != NULL) {\n\t\t\tif (filep == NULL) {\n\t\t\t\t/* This is a file in memory, but we cannot store the\n\t\t\t\t * properties\n\t\t\t\t * now.\n\t\t\t\t * Called from \"is_file_in_memory\" function. */\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t/* NOTE: override filep->size only on success. Otherwise, it\n\t\t\t * might\n\t\t\t * break constructs like if (!mg_stat() || !mg_fopen()) ... */\n\t\t\tfilep->access.membuf = buf;\n\t\t\tfilep->access.fp = NULL;\n\n\t\t\t/* Size was set by the callback */\n\t\t\tfilep->stat.size = size;\n\n\t\t\t/* Assume the data may change during runtime by setting\n\t\t\t * last_modified = now */\n\t\t\tfilep->stat.last_modified = time(NULL);\n\n\t\t\tfilep->stat.is_directory = 0;\n\t\t\tfilep->stat.is_gzipped = 0;\n\t\t}\n\t}\n\n\treturn (buf != NULL);\n\n#else\n\t(void)conn;\n\t(void)path;\n\t(void)filep;\n\t(void)mode;\n\n\treturn 0;\n\n#endif\n}\n\n\nstatic int\nis_file_in_memory(const struct mg_connection *conn, const char *path)\n{\n\treturn open_file_in_memory(conn, path, NULL, MG_FOPEN_MODE_NONE);\n}\n\n\nstatic int\nis_file_opened(const struct mg_file_access *fileacc)\n{\n\tif (!fileacc) {\n\t\treturn 0;\n\t}\n\n#if defined(MG_USE_OPEN_FILE)\n\treturn (fileacc->membuf != NULL) || (fileacc->fp != NULL);\n#else\n\treturn (fileacc->fp != NULL);\n#endif\n}\n\n\nstatic int mg_stat(const struct mg_connection *conn,\n                   const char *path,\n                   struct mg_file_stat *filep);\n\n\n/* mg_fopen will open a file either in memory or on the disk.\n * The input parameter path is a string in UTF-8 encoding.\n * The input parameter mode is MG_FOPEN_MODE_*\n * On success, either fp or membuf will be set in the output\n * struct file. All status members will also be set.\n * The function returns 1 on success, 0 on error. */\nstatic int\nmg_fopen(const struct mg_connection *conn,\n         const char *path,\n         int mode,\n         struct mg_file *filep)\n{\n\tint found;\n\n\tif (!filep) {\n\t\treturn 0;\n\t}\n\tfilep->access.fp = NULL;\n#if defined(MG_USE_OPEN_FILE)\n\tfilep->access.membuf = NULL;\n#endif\n\n\tif (!is_file_in_memory(conn, path)) {\n\n\t\t/* filep is initialized in mg_stat: all fields with memset to,\n\t\t * some fields like size and modification date with values */\n\t\tfound = mg_stat(conn, path, &(filep->stat));\n\n\t\tif ((mode == MG_FOPEN_MODE_READ) && (!found)) {\n\t\t\t/* file does not exist and will not be created */\n\t\t\treturn 0;\n\t\t}\n\n#if defined(_WIN32)\n\t\t{\n\t\t\twchar_t wbuf[W_PATH_MAX];\n\t\t\tpath_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));\n\t\t\tswitch (mode) {\n\t\t\tcase MG_FOPEN_MODE_READ:\n\t\t\t\tfilep->access.fp = _wfopen(wbuf, L\"rb\");\n\t\t\t\tbreak;\n\t\t\tcase MG_FOPEN_MODE_WRITE:\n\t\t\t\tfilep->access.fp = _wfopen(wbuf, L\"wb\");\n\t\t\t\tbreak;\n\t\t\tcase MG_FOPEN_MODE_APPEND:\n\t\t\t\tfilep->access.fp = _wfopen(wbuf, L\"ab\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#else\n\t\t/* Linux et al already use unicode. No need to convert. */\n\t\tswitch (mode) {\n\t\tcase MG_FOPEN_MODE_READ:\n\t\t\tfilep->access.fp = fopen(path, \"r\");\n\t\t\tbreak;\n\t\tcase MG_FOPEN_MODE_WRITE:\n\t\t\tfilep->access.fp = fopen(path, \"w\");\n\t\t\tbreak;\n\t\tcase MG_FOPEN_MODE_APPEND:\n\t\t\tfilep->access.fp = fopen(path, \"a\");\n\t\t\tbreak;\n\t\t}\n\n#endif\n\t\tif (!found) {\n\t\t\t/* File did not exist before fopen was called.\n\t\t\t * Maybe it has been created now. Get stat info\n\t\t\t * like creation time now. */\n\t\t\tfound = mg_stat(conn, path, &(filep->stat));\n\t\t\t(void)found;\n\t\t}\n\n\t\t/* file is on disk */\n\t\treturn (filep->access.fp != NULL);\n\n\t} else {\n#if defined(MG_USE_OPEN_FILE)\n\t\t/* is_file_in_memory returned true */\n\t\tif (open_file_in_memory(conn, path, filep, mode)) {\n\t\t\t/* file is in memory */\n\t\t\treturn (filep->access.membuf != NULL);\n\t\t}\n#endif\n\t}\n\n\t/* Open failed */\n\treturn 0;\n}\n\n\n/* return 0 on success, just like fclose */\nstatic int\nmg_fclose(struct mg_file_access *fileacc)\n{\n\tint ret = -1;\n\tif (fileacc != NULL) {\n\t\tif (fileacc->fp != NULL) {\n\t\t\tret = fclose(fileacc->fp);\n#if defined(MG_USE_OPEN_FILE)\n\t\t} else if (fileacc->membuf != NULL) {\n\t\t\tret = 0;\n#endif\n\t\t}\n\t\t/* reset all members of fileacc */\n\t\tmemset(fileacc, 0, sizeof(*fileacc));\n\t}\n\treturn ret;\n}\n\n\nstatic void\nmg_strlcpy(register char *dst, register const char *src, size_t n)\n{\n\tfor (; *src != '\\0' && n > 1; n--) {\n\t\t*dst++ = *src++;\n\t}\n\t*dst = '\\0';\n}\n\n\nstatic int\nlowercase(const char *s)\n{\n\treturn tolower(*(const unsigned char *)s);\n}\n\n\nint\nmg_strncasecmp(const char *s1, const char *s2, size_t len)\n{\n\tint diff = 0;\n\n\tif (len > 0) {\n\t\tdo {\n\t\t\tdiff = lowercase(s1++) - lowercase(s2++);\n\t\t} while (diff == 0 && s1[-1] != '\\0' && --len > 0);\n\t}\n\n\treturn diff;\n}\n\n\nint\nmg_strcasecmp(const char *s1, const char *s2)\n{\n\tint diff;\n\n\tdo {\n\t\tdiff = lowercase(s1++) - lowercase(s2++);\n\t} while (diff == 0 && s1[-1] != '\\0');\n\n\treturn diff;\n}\n\n\nstatic char *\nmg_strndup_ctx(const char *ptr, size_t len, struct mg_context *ctx)\n{\n\tchar *p;\n\t(void)ctx; /* Avoid Visual Studio warning if USE_SERVER_STATS is not\n\t            * defined */\n\n\tif ((p = (char *)mg_malloc_ctx(len + 1, ctx)) != NULL) {\n\t\tmg_strlcpy(p, ptr, len + 1);\n\t}\n\n\treturn p;\n}\n\n\nstatic char *\nmg_strdup_ctx(const char *str, struct mg_context *ctx)\n{\n\treturn mg_strndup_ctx(str, strlen(str), ctx);\n}\n\nstatic char *\nmg_strdup(const char *str)\n{\n\treturn mg_strndup_ctx(str, strlen(str), NULL);\n}\n\n\nstatic const char *\nmg_strcasestr(const char *big_str, const char *small_str)\n{\n\tsize_t i, big_len = strlen(big_str), small_len = strlen(small_str);\n\n\tif (big_len >= small_len) {\n\t\tfor (i = 0; i <= (big_len - small_len); i++) {\n\t\t\tif (mg_strncasecmp(big_str + i, small_str, small_len) == 0) {\n\t\t\t\treturn big_str + i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n\n/* Return null terminated string of given maximum length.\n * Report errors if length is exceeded. */\nstatic void\nmg_vsnprintf(const struct mg_connection *conn,\n             int *truncated,\n             char *buf,\n             size_t buflen,\n             const char *fmt,\n             va_list ap)\n{\n\tint n, ok;\n\n\tif (buflen == 0) {\n\t\tif (truncated) {\n\t\t\t*truncated = 1;\n\t\t}\n\t\treturn;\n\t}\n\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"\n/* Using fmt as a non-literal is intended here, since it is mostly called\n * indirectly by mg_snprintf */\n#endif\n\n\tn = (int)vsnprintf_impl(buf, buflen, fmt, ap);\n\tok = (n >= 0) && ((size_t)n < buflen);\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n\tif (ok) {\n\t\tif (truncated) {\n\t\t\t*truncated = 0;\n\t\t}\n\t} else {\n\t\tif (truncated) {\n\t\t\t*truncated = 1;\n\t\t}\n\t\tmg_cry_internal(conn,\n\t\t                \"truncating vsnprintf buffer: [%.*s]\",\n\t\t                (int)((buflen > 200) ? 200 : (buflen - 1)),\n\t\t                buf);\n\t\tn = (int)buflen - 1;\n\t}\n\tbuf[n] = '\\0';\n}\n\n\nstatic void\nmg_snprintf(const struct mg_connection *conn,\n            int *truncated,\n            char *buf,\n            size_t buflen,\n            const char *fmt,\n            ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tmg_vsnprintf(conn, truncated, buf, buflen, fmt, ap);\n\tva_end(ap);\n}\n\n\nstatic int\nget_option_index(const char *name)\n{\n\tint i;\n\n\tfor (i = 0; config_options[i].name != NULL; i++) {\n\t\tif (strcmp(config_options[i].name, name) == 0) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nconst char *\nmg_get_option(const struct mg_context *ctx, const char *name)\n{\n\tint i;\n\tif ((i = get_option_index(name)) == -1) {\n\t\treturn NULL;\n\t} else if (!ctx || ctx->dd.config[i] == NULL) {\n\t\treturn \"\";\n\t} else {\n\t\treturn ctx->dd.config[i];\n\t}\n}\n\n#define mg_get_option DO_NOT_USE_THIS_FUNCTION_INTERNALLY__access_directly\n\nstruct mg_context *\nmg_get_context(const struct mg_connection *conn)\n{\n\treturn (conn == NULL) ? (struct mg_context *)NULL : (conn->phys_ctx);\n}\n\n\nvoid *\nmg_get_user_data(const struct mg_context *ctx)\n{\n\treturn (ctx == NULL) ? NULL : ctx->user_data;\n}\n\n\nvoid\nmg_set_user_connection_data(struct mg_connection *conn, void *data)\n{\n\tif (conn != NULL) {\n\t\tconn->request_info.conn_data = data;\n\t}\n}\n\n\nvoid *\nmg_get_user_connection_data(const struct mg_connection *conn)\n{\n\tif (conn != NULL) {\n\t\treturn conn->request_info.conn_data;\n\t}\n\treturn NULL;\n}\n\n\n#if defined(MG_LEGACY_INTERFACE)\n/* Deprecated: Use mg_get_server_ports instead. */\nsize_t\nmg_get_ports(const struct mg_context *ctx, size_t size, int *ports, int *ssl)\n{\n\tsize_t i;\n\tif (!ctx) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < size && i < ctx->num_listening_sockets; i++) {\n\t\tssl[i] = ctx->listening_sockets[i].is_ssl;\n\t\tports[i] =\n#if defined(USE_IPV6)\n\t\t    (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6)\n\t\t        ? ntohs(ctx->listening_sockets[i].lsa.sin6.sin6_port)\n\t\t        :\n#endif\n\t\t        ntohs(ctx->listening_sockets[i].lsa.sin.sin_port);\n\t}\n\treturn i;\n}\n#endif\n\n\nint\nmg_get_server_ports(const struct mg_context *ctx,\n                    int size,\n                    struct mg_server_ports *ports)\n{\n\tint i, cnt = 0;\n\n\tif (size <= 0) {\n\t\treturn -1;\n\t}\n\tmemset(ports, 0, sizeof(*ports) * (size_t)size);\n\tif (!ctx) {\n\t\treturn -1;\n\t}\n\tif (!ctx->listening_sockets) {\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; (i < size) && (i < (int)ctx->num_listening_sockets); i++) {\n\n\t\tports[cnt].port =\n#if defined(USE_IPV6)\n\t\t    (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6)\n\t\t        ? ntohs(ctx->listening_sockets[i].lsa.sin6.sin6_port)\n\t\t        :\n#endif\n\t\t        ntohs(ctx->listening_sockets[i].lsa.sin.sin_port);\n\t\tports[cnt].is_ssl = ctx->listening_sockets[i].is_ssl;\n\t\tports[cnt].is_redirect = ctx->listening_sockets[i].ssl_redir;\n\n\t\tif (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET) {\n\t\t\t/* IPv4 */\n\t\t\tports[cnt].protocol = 1;\n\t\t\tcnt++;\n\t\t} else if (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6) {\n\t\t\t/* IPv6 */\n\t\t\tports[cnt].protocol = 3;\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\n\nstatic void\nsockaddr_to_string(char *buf, size_t len, const union usa *usa)\n{\n\tbuf[0] = '\\0';\n\n\tif (!usa) {\n\t\treturn;\n\t}\n\n\tif (usa->sa.sa_family == AF_INET) {\n\t\tgetnameinfo(&usa->sa,\n\t\t            sizeof(usa->sin),\n\t\t            buf,\n\t\t            (unsigned)len,\n\t\t            NULL,\n\t\t            0,\n\t\t            NI_NUMERICHOST);\n\t}\n#if defined(USE_IPV6)\n\telse if (usa->sa.sa_family == AF_INET6) {\n\t\tgetnameinfo(&usa->sa,\n\t\t            sizeof(usa->sin6),\n\t\t            buf,\n\t\t            (unsigned)len,\n\t\t            NULL,\n\t\t            0,\n\t\t            NI_NUMERICHOST);\n\t}\n#endif\n}\n\n\n/* Convert time_t to a string. According to RFC2616, Sec 14.18, this must be\n * included in all responses other than 100, 101, 5xx. */\nstatic void\ngmt_time_string(char *buf, size_t buf_len, time_t *t)\n{\n#if !defined(REENTRANT_TIME)\n\tstruct tm *tm;\n\n\ttm = ((t != NULL) ? gmtime(t) : NULL);\n\tif (tm != NULL) {\n#else\n\tstruct tm _tm;\n\tstruct tm *tm = &_tm;\n\n\tif (t != NULL) {\n\t\tgmtime_r(t, tm);\n#endif\n\t\tstrftime(buf, buf_len, \"%a, %d %b %Y %H:%M:%S GMT\", tm);\n\t} else {\n\t\tmg_strlcpy(buf, \"Thu, 01 Jan 1970 00:00:00 GMT\", buf_len);\n\t\tbuf[buf_len - 1] = '\\0';\n\t}\n}\n\n\n/* difftime for struct timespec. Return value is in seconds. */\nstatic double\nmg_difftimespec(const struct timespec *ts_now, const struct timespec *ts_before)\n{\n\treturn (double)(ts_now->tv_nsec - ts_before->tv_nsec) * 1.0E-9\n\t       + (double)(ts_now->tv_sec - ts_before->tv_sec);\n}\n\n\n#if defined(MG_EXTERNAL_FUNCTION_mg_cry_internal_impl)\nstatic void mg_cry_internal_impl(const struct mg_connection *conn,\n                                 const char *func,\n                                 unsigned line,\n                                 const char *fmt,\n                                 va_list ap);\n#include \"external_mg_cry_internal_impl.inl\"\n#else\n\n/* Print error message to the opened error log stream. */\nstatic void\nmg_cry_internal_impl(const struct mg_connection *conn,\n                     const char *func,\n                     unsigned line,\n                     const char *fmt,\n                     va_list ap)\n{\n\tchar buf[MG_BUF_LEN], src_addr[IP_ADDR_STR_LEN];\n\tstruct mg_file fi;\n\ttime_t timestamp;\n\n\t/* Unused, in the RELEASE build */\n\t(void)func;\n\t(void)line;\n\n#if defined(GCC_DIAGNOSTIC)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n#endif\n\n\tIGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));\n\n#if defined(GCC_DIAGNOSTIC)\n#pragma GCC diagnostic pop\n#endif\n\n\tbuf[sizeof(buf) - 1] = 0;\n\n\tDEBUG_TRACE(\"mg_cry called from %s:%u: %s\", func, line, buf);\n\n\tif (!conn) {\n\t\tputs(buf);\n\t\treturn;\n\t}\n\n\t/* Do not lock when getting the callback value, here and below.\n\t * I suppose this is fine, since function cannot disappear in the\n\t * same way string option can. */\n\tif ((conn->phys_ctx->callbacks.log_message == NULL)\n\t    || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {\n\n\t\tif (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {\n\t\t\tif (mg_fopen(conn,\n\t\t\t             conn->dom_ctx->config[ERROR_LOG_FILE],\n\t\t\t             MG_FOPEN_MODE_APPEND,\n\t\t\t             &fi)\n\t\t\t    == 0) {\n\t\t\t\tfi.access.fp = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tfi.access.fp = NULL;\n\t\t}\n\n\t\tif (fi.access.fp != NULL) {\n\t\t\tflockfile(fi.access.fp);\n\t\t\ttimestamp = time(NULL);\n\n\t\t\tsockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);\n\t\t\tfprintf(fi.access.fp,\n\t\t\t        \"[%010lu] [error] [client %s] \",\n\t\t\t        (unsigned long)timestamp,\n\t\t\t        src_addr);\n\n\t\t\tif (conn->request_info.request_method != NULL) {\n\t\t\t\tfprintf(fi.access.fp,\n\t\t\t\t        \"%s %s: \",\n\t\t\t\t        conn->request_info.request_method,\n\t\t\t\t        conn->request_info.request_uri\n\t\t\t\t            ? conn->request_info.request_uri\n\t\t\t\t            : \"\");\n\t\t\t}\n\n\t\t\tfprintf(fi.access.fp, \"%s\", buf);\n\t\t\tfputc('\\n', fi.access.fp);\n\t\t\tfflush(fi.access.fp);\n\t\t\tfunlockfile(fi.access.fp);\n\t\t\t(void)mg_fclose(&fi.access); /* Ignore errors. We can't call\n\t\t\t                              * mg_cry here anyway ;-) */\n\t\t}\n\t}\n}\n\n#endif /* Externally provided function */\n\n\nstatic void\nmg_cry_internal_wrap(const struct mg_connection *conn,\n                     const char *func,\n                     unsigned line,\n                     const char *fmt,\n                     ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tmg_cry_internal_impl(conn, func, line, fmt, ap);\n\tva_end(ap);\n}\n\n\nvoid\nmg_cry(const struct mg_connection *conn, const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tmg_cry_internal_impl(conn, \"user\", 0, fmt, ap);\n\tva_end(ap);\n}\n\n\n#define mg_cry DO_NOT_USE_THIS_FUNCTION__USE_mg_cry_internal\n\n\n/* Return fake connection structure. Used for logging, if connection\n * is not applicable at the moment of logging. */\nstatic struct mg_connection *\nfc(struct mg_context *ctx)\n{\n\tstatic struct mg_connection fake_connection;\n\tfake_connection.phys_ctx = ctx;\n\tfake_connection.dom_ctx = &(ctx->dd);\n\treturn &fake_connection;\n}\n\n\nconst char *\nmg_version(void)\n{\n\treturn CIVETWEB_VERSION;\n}\n\n\nconst struct mg_request_info *\nmg_get_request_info(const struct mg_connection *conn)\n{\n\tif (!conn) {\n\t\treturn NULL;\n\t}\n#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE)\n\tif (conn->connection_type == CONNECTION_TYPE_RESPONSE) {\n\t\tchar txt[16];\n\t\tstruct mg_workerTLS *tls =\n\t\t    (struct mg_workerTLS *)pthread_getspecific(sTlsKey);\n\n\t\tsprintf(txt, \"%03i\", conn->response_info.status_code);\n\t\tif (strlen(txt) == 3) {\n\t\t\tmemcpy(tls->txtbuf, txt, 4);\n\t\t} else {\n\t\t\tstrcpy(tls->txtbuf, \"ERR\");\n\t\t}\n\n\t\t((struct mg_connection *)conn)->request_info.local_uri =\n\t\t    ((struct mg_connection *)conn)->request_info.request_uri =\n\t\t        tls->txtbuf; /* use thread safe buffer */\n\n\t\t((struct mg_connection *)conn)->request_info.num_headers =\n\t\t    conn->response_info.num_headers;\n\t\tmemcpy(((struct mg_connection *)conn)->request_info.http_headers,\n\t\t       conn->response_info.http_headers,\n\t\t       sizeof(conn->response_info.http_headers));\n\t} else\n#endif\n\t    if (conn->connection_type != CONNECTION_TYPE_REQUEST) {\n\t\treturn NULL;\n\t}\n\treturn &conn->request_info;\n}\n\n\nconst struct mg_response_info *\nmg_get_response_info(const struct mg_connection *conn)\n{\n\tif (!conn) {\n\t\treturn NULL;\n\t}\n\tif (conn->connection_type != CONNECTION_TYPE_RESPONSE) {\n\t\treturn NULL;\n\t}\n\treturn &conn->response_info;\n}\n\n\nstatic const char *\nget_proto_name(const struct mg_connection *conn)\n{\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunreachable-code\"\n/* Depending on USE_WEBSOCKET and NO_SSL, some oft the protocols might be\n * not supported. Clang raises an \"unreachable code\" warning for parts of ?:\n * unreachable, but splitting into four different #ifdef clauses here is more\n * complicated.\n */\n#endif\n\n\tconst struct mg_request_info *ri = &conn->request_info;\n\n\tconst char *proto =\n\t    (is_websocket_protocol(conn) ? (ri->is_ssl ? \"wss\" : \"ws\")\n\t                                 : (ri->is_ssl ? \"https\" : \"http\"));\n\n\treturn proto;\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n}\n\n\nint\nmg_get_request_link(const struct mg_connection *conn, char *buf, size_t buflen)\n{\n\tif ((buflen < 1) || (buf == 0) || (conn == 0)) {\n\t\treturn -1;\n\t} else {\n\n\t\tint truncated = 0;\n\t\tconst struct mg_request_info *ri = &conn->request_info;\n\n\t\tconst char *proto = get_proto_name(conn);\n\n\t\tif (ri->local_uri == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((ri->request_uri != NULL)\n\t\t    && (0 != strcmp(ri->local_uri, ri->request_uri))) {\n\t\t\t/* The request uri is different from the local uri.\n\t\t\t * This is usually if an absolute URI, including server\n\t\t\t * name has been provided. */\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            buf,\n\t\t\t            buflen,\n\t\t\t            \"%s://%s\",\n\t\t\t            proto,\n\t\t\t            ri->request_uri);\n\t\t\tif (truncated) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\n\t\t} else {\n\n\t\t\t/* The common case is a relative URI, so we have to\n\t\t\t * construct an absolute URI from server name and port */\n\n#if defined(USE_IPV6)\n\t\t\tint is_ipv6 = (conn->client.lsa.sa.sa_family == AF_INET6);\n\t\t\tint port = is_ipv6 ? htons(conn->client.lsa.sin6.sin6_port)\n\t\t\t                   : htons(conn->client.lsa.sin.sin_port);\n#else\n\t\t\tint port = htons(conn->client.lsa.sin.sin_port);\n#endif\n\t\t\tint def_port = ri->is_ssl ? 443 : 80;\n\t\t\tint auth_domain_check_enabled =\n\t\t\t    conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK]\n\t\t\t    && (!mg_strcasecmp(\n\t\t\t           conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK], \"yes\"));\n\t\t\tconst char *server_domain =\n\t\t\t    conn->dom_ctx->config[AUTHENTICATION_DOMAIN];\n\n\t\t\tchar portstr[16];\n\t\t\tchar server_ip[48];\n\n\t\t\tif (port != def_port) {\n\t\t\t\tsprintf(portstr, \":%u\", (unsigned)port);\n\t\t\t} else {\n\t\t\t\tportstr[0] = 0;\n\t\t\t}\n\n\t\t\tif (!auth_domain_check_enabled || !server_domain) {\n\n\t\t\t\tsockaddr_to_string(server_ip,\n\t\t\t\t                   sizeof(server_ip),\n\t\t\t\t                   &conn->client.lsa);\n\n\t\t\t\tserver_domain = server_ip;\n\t\t\t}\n\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            buf,\n\t\t\t            buflen,\n\t\t\t            \"%s://%s%s%s\",\n\t\t\t            proto,\n\t\t\t            server_domain,\n\t\t\t            portstr,\n\t\t\t            ri->local_uri);\n\t\t\tif (truncated) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\n/* Skip the characters until one of the delimiters characters found.\n * 0-terminate resulting word. Skip the delimiter and following whitespaces.\n * Advance pointer to buffer to the next word. Return found 0-terminated\n * word.\n * Delimiters can be quoted with quotechar. */\nstatic char *\nskip_quoted(char **buf,\n            const char *delimiters,\n            const char *whitespace,\n            char quotechar)\n{\n\tchar *p, *begin_word, *end_word, *end_whitespace;\n\n\tbegin_word = *buf;\n\tend_word = begin_word + strcspn(begin_word, delimiters);\n\n\t/* Check for quotechar */\n\tif (end_word > begin_word) {\n\t\tp = end_word - 1;\n\t\twhile (*p == quotechar) {\n\t\t\t/* While the delimiter is quoted, look for the next delimiter.\n\t\t\t */\n\t\t\t/* This happens, e.g., in calls from parse_auth_header,\n\t\t\t * if the user name contains a \" character. */\n\n\t\t\t/* If there is anything beyond end_word, copy it. */\n\t\t\tif (*end_word != '\\0') {\n\t\t\t\tsize_t end_off = strcspn(end_word + 1, delimiters);\n\t\t\t\tmemmove(p, end_word, end_off + 1);\n\t\t\t\tp += end_off; /* p must correspond to end_word - 1 */\n\t\t\t\tend_word += end_off + 1;\n\t\t\t} else {\n\t\t\t\t*p = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (p++; p < end_word; p++) {\n\t\t\t*p = '\\0';\n\t\t}\n\t}\n\n\tif (*end_word == '\\0') {\n\t\t*buf = end_word;\n\t} else {\n\n#if defined(GCC_DIAGNOSTIC)\n/* Disable spurious conversion warning for GCC */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#endif /* defined(GCC_DIAGNOSTIC) */\n\n\t\tend_whitespace = end_word + strspn(&end_word[1], whitespace) + 1;\n\n#if defined(GCC_DIAGNOSTIC)\n#pragma GCC diagnostic pop\n#endif /* defined(GCC_DIAGNOSTIC) */\n\n\t\tfor (p = end_word; p < end_whitespace; p++) {\n\t\t\t*p = '\\0';\n\t\t}\n\n\t\t*buf = end_whitespace;\n\t}\n\n\treturn begin_word;\n}\n\n\n/* Return HTTP header value, or NULL if not found. */\nstatic const char *\nget_header(const struct mg_header *hdr, int num_hdr, const char *name)\n{\n\tint i;\n\tfor (i = 0; i < num_hdr; i++) {\n\t\tif (!mg_strcasecmp(name, hdr[i].name)) {\n\t\t\treturn hdr[i].value;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n\n#if defined(USE_WEBSOCKET)\n/* Retrieve requested HTTP header multiple values, and return the number of\n * found occurrences */\nstatic int\nget_req_headers(const struct mg_request_info *ri,\n                const char *name,\n                const char **output,\n                int output_max_size)\n{\n\tint i;\n\tint cnt = 0;\n\tif (ri) {\n\t\tfor (i = 0; i < ri->num_headers && cnt < output_max_size; i++) {\n\t\t\tif (!mg_strcasecmp(name, ri->http_headers[i].name)) {\n\t\t\t\toutput[cnt++] = ri->http_headers[i].value;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n#endif\n\n\nconst char *\nmg_get_header(const struct mg_connection *conn, const char *name)\n{\n\tif (!conn) {\n\t\treturn NULL;\n\t}\n\n\tif (conn->connection_type == CONNECTION_TYPE_REQUEST) {\n\t\treturn get_header(conn->request_info.http_headers,\n\t\t                  conn->request_info.num_headers,\n\t\t                  name);\n\t}\n\tif (conn->connection_type == CONNECTION_TYPE_RESPONSE) {\n\t\treturn get_header(conn->response_info.http_headers,\n\t\t                  conn->response_info.num_headers,\n\t\t                  name);\n\t}\n\treturn NULL;\n}\n\n\nstatic const char *\nget_http_version(const struct mg_connection *conn)\n{\n\tif (!conn) {\n\t\treturn NULL;\n\t}\n\n\tif (conn->connection_type == CONNECTION_TYPE_REQUEST) {\n\t\treturn conn->request_info.http_version;\n\t}\n\tif (conn->connection_type == CONNECTION_TYPE_RESPONSE) {\n\t\treturn conn->response_info.http_version;\n\t}\n\treturn NULL;\n}\n\n\n/* A helper function for traversing a comma separated list of values.\n * It returns a list pointer shifted to the next value, or NULL if the end\n * of the list found.\n * Value is stored in val vector. If value has form \"x=y\", then eq_val\n * vector is initialized to point to the \"y\" part, and val vector length\n * is adjusted to point only to \"x\". */\nstatic const char *\nnext_option(const char *list, struct vec *val, struct vec *eq_val)\n{\n\tint end;\n\nreparse:\n\tif (val == NULL || list == NULL || *list == '\\0') {\n\t\t/* End of the list */\n\t\treturn NULL;\n\t}\n\n\t/* Skip over leading LWS */\n\twhile (*list == ' ' || *list == '\\t')\n\t\tlist++;\n\n\tval->ptr = list;\n\tif ((list = strchr(val->ptr, ',')) != NULL) {\n\t\t/* Comma found. Store length and shift the list ptr */\n\t\tval->len = ((size_t)(list - val->ptr));\n\t\tlist++;\n\t} else {\n\t\t/* This value is the last one */\n\t\tlist = val->ptr + strlen(val->ptr);\n\t\tval->len = ((size_t)(list - val->ptr));\n\t}\n\n\t/* Adjust length for trailing LWS */\n\tend = (int)val->len - 1;\n\twhile (end >= 0 && ((val->ptr[end] == ' ') || (val->ptr[end] == '\\t')))\n\t\tend--;\n\tval->len = (size_t)(end + 1);\n\n\tif (val->len == 0) {\n\t\t/* Ignore any empty entries. */\n\t\tgoto reparse;\n\t}\n\n\tif (eq_val != NULL) {\n\t\t/* Value has form \"x=y\", adjust pointers and lengths\n\t\t * so that val points to \"x\", and eq_val points to \"y\". */\n\t\teq_val->len = 0;\n\t\teq_val->ptr = (const char *)memchr(val->ptr, '=', val->len);\n\t\tif (eq_val->ptr != NULL) {\n\t\t\teq_val->ptr++; /* Skip over '=' character */\n\t\t\teq_val->len = ((size_t)(val->ptr - eq_val->ptr)) + val->len;\n\t\t\tval->len = ((size_t)(eq_val->ptr - val->ptr)) - 1;\n\t\t}\n\t}\n\n\treturn list;\n}\n\n\n/* A helper function for checking if a comma separated list of values\n * contains\n * the given option (case insensitvely).\n * 'header' can be NULL, in which case false is returned. */\nstatic int\nheader_has_option(const char *header, const char *option)\n{\n\tstruct vec opt_vec;\n\tstruct vec eq_vec;\n\n\tDEBUG_ASSERT(option != NULL);\n\tDEBUG_ASSERT(option[0] != '\\0');\n\n\twhile ((header = next_option(header, &opt_vec, &eq_vec)) != NULL) {\n\t\tif (mg_strncasecmp(option, opt_vec.ptr, opt_vec.len) == 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\n/* Perform case-insensitive match of string against pattern */\nstatic ptrdiff_t\nmatch_prefix(const char *pattern, size_t pattern_len, const char *str)\n{\n\tconst char *or_str;\n\tptrdiff_t i, j, len, res;\n\n\tif ((or_str = (const char *)memchr(pattern, '|', pattern_len)) != NULL) {\n\t\tres = match_prefix(pattern, (size_t)(or_str - pattern), str);\n\t\treturn (res > 0) ? res\n\t\t                 : match_prefix(or_str + 1,\n\t\t                                (size_t)((pattern + pattern_len)\n\t\t                                         - (or_str + 1)),\n\t\t                                str);\n\t}\n\n\tfor (i = 0, j = 0; (i < (ptrdiff_t)pattern_len); i++, j++) {\n\t\tif ((pattern[i] == '?') && (str[j] != '\\0')) {\n\t\t\tcontinue;\n\t\t} else if (pattern[i] == '$') {\n\t\t\treturn (str[j] == '\\0') ? j : -1;\n\t\t} else if (pattern[i] == '*') {\n\t\t\ti++;\n\t\t\tif (pattern[i] == '*') {\n\t\t\t\ti++;\n\t\t\t\tlen = strlen(str + j);\n\t\t\t} else {\n\t\t\t\tlen = strcspn(str + j, \"/\");\n\t\t\t}\n\t\t\tif (i == (ptrdiff_t)pattern_len) {\n\t\t\t\treturn j + len;\n\t\t\t}\n\t\t\tdo {\n\t\t\t\tres = match_prefix(pattern + i, pattern_len - i, str + j + len);\n\t\t\t} while (res == -1 && len-- > 0);\n\t\t\treturn (res == -1) ? -1 : j + res + len;\n\t\t} else if (lowercase(&pattern[i]) != lowercase(&str[j])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn (ptrdiff_t)j;\n}\n\n\n/* HTTP 1.1 assumes keep alive if \"Connection:\" header is not set\n * This function must tolerate situations when connection info is not\n * set up, for example if request parsing failed. */\nstatic int\nshould_keep_alive(const struct mg_connection *conn)\n{\n\tconst char *http_version;\n\tconst char *header;\n\n\t/* First satisfy needs of the server */\n\tif ((conn == NULL) || conn->must_close) {\n\t\t/* Close, if civetweb framework needs to close */\n\t\treturn 0;\n\t}\n\n\tif (mg_strcasecmp(conn->dom_ctx->config[ENABLE_KEEP_ALIVE], \"yes\") != 0) {\n\t\t/* Close, if keep alive is not enabled */\n\t\treturn 0;\n\t}\n\n\t/* Check explicit wish of the client */\n\theader = mg_get_header(conn, \"Connection\");\n\tif (header) {\n\t\t/* If there is a connection header from the client, obey */\n\t\tif (header_has_option(header, \"keep-alive\")) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Use default of the standard */\n\thttp_version = get_http_version(conn);\n\tif (http_version && (0 == strcmp(http_version, \"1.1\"))) {\n\t\t/* HTTP 1.1 default is keep alive */\n\t\treturn 1;\n\t}\n\n\t/* HTTP 1.0 (and earlier) default is to close the connection */\n\treturn 0;\n}\n\n\nstatic int\nshould_decode_url(const struct mg_connection *conn)\n{\n\tif (!conn || !conn->dom_ctx) {\n\t\treturn 0;\n\t}\n\n\treturn (mg_strcasecmp(conn->dom_ctx->config[DECODE_URL], \"yes\") == 0);\n}\n\n\nstatic const char *\nsuggest_connection_header(const struct mg_connection *conn)\n{\n\treturn should_keep_alive(conn) ? \"keep-alive\" : \"close\";\n}\n\n\nstatic int\nsend_no_cache_header(struct mg_connection *conn)\n{\n\t/* Send all current and obsolete cache opt-out directives. */\n\treturn mg_printf(conn,\n\t                 \"Cache-Control: no-cache, no-store, \"\n\t                 \"must-revalidate, private, max-age=0\\r\\n\"\n\t                 \"Pragma: no-cache\\r\\n\"\n\t                 \"Expires: 0\\r\\n\");\n}\n\n\nstatic int\nsend_static_cache_header(struct mg_connection *conn)\n{\n#if !defined(NO_CACHING)\n\t/* Read the server config to check how long a file may be cached.\n\t * The configuration is in seconds. */\n\tint max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);\n\tif (max_age <= 0) {\n\t\t/* 0 means \"do not cache\". All values <0 are reserved\n\t\t * and may be used differently in the future. */\n\t\t/* If a file should not be cached, do not only send\n\t\t * max-age=0, but also pragmas and Expires headers. */\n\t\treturn send_no_cache_header(conn);\n\t}\n\n\t/* Use \"Cache-Control: max-age\" instead of \"Expires\" header.\n\t * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */\n\t/* See also https://www.mnot.net/cache_docs/ */\n\t/* According to RFC 2616, Section 14.21, caching times should not exceed\n\t * one year. A year with 365 days corresponds to 31536000 seconds, a\n\t * leap\n\t * year to 31622400 seconds. For the moment, we just send whatever has\n\t * been configured, still the behavior for >1 year should be considered\n\t * as undefined. */\n\treturn mg_printf(conn, \"Cache-Control: max-age=%u\\r\\n\", (unsigned)max_age);\n#else  /* NO_CACHING */\n\treturn send_no_cache_header(conn);\n#endif /* !NO_CACHING */\n}\n\n\nstatic int\nsend_additional_header(struct mg_connection *conn)\n{\n\tint i = 0;\n\tconst char *header = conn->dom_ctx->config[ADDITIONAL_HEADER];\n\n#if !defined(NO_SSL)\n\tif (conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]) {\n\t\tint max_age = atoi(conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]);\n\t\tif (max_age >= 0) {\n\t\t\ti += mg_printf(conn,\n\t\t\t               \"Strict-Transport-Security: max-age=%u\\r\\n\",\n\t\t\t               (unsigned)max_age);\n\t\t}\n\t}\n#endif\n\n\tif (header && header[0]) {\n\t\ti += mg_printf(conn, \"%s\\r\\n\", header);\n\t}\n\n\treturn i;\n}\n\n\nstatic void handle_file_based_request(struct mg_connection *conn,\n                                      const char *path,\n                                      struct mg_file *filep);\n\n\nconst char *\nmg_get_response_code_text(const struct mg_connection *conn, int response_code)\n{\n\t/* See IANA HTTP status code assignment:\n\t * http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\n\t */\n\n\tswitch (response_code) {\n\t/* RFC2616 Section 10.1 - Informational 1xx */\n\tcase 100:\n\t\treturn \"Continue\"; /* RFC2616 Section 10.1.1 */\n\tcase 101:\n\t\treturn \"Switching Protocols\"; /* RFC2616 Section 10.1.2 */\n\tcase 102:\n\t\treturn \"Processing\"; /* RFC2518 Section 10.1 */\n\n\t/* RFC2616 Section 10.2 - Successful 2xx */\n\tcase 200:\n\t\treturn \"OK\"; /* RFC2616 Section 10.2.1 */\n\tcase 201:\n\t\treturn \"Created\"; /* RFC2616 Section 10.2.2 */\n\tcase 202:\n\t\treturn \"Accepted\"; /* RFC2616 Section 10.2.3 */\n\tcase 203:\n\t\treturn \"Non-Authoritative Information\"; /* RFC2616 Section 10.2.4 */\n\tcase 204:\n\t\treturn \"No Content\"; /* RFC2616 Section 10.2.5 */\n\tcase 205:\n\t\treturn \"Reset Content\"; /* RFC2616 Section 10.2.6 */\n\tcase 206:\n\t\treturn \"Partial Content\"; /* RFC2616 Section 10.2.7 */\n\tcase 207:\n\t\treturn \"Multi-Status\"; /* RFC2518 Section 10.2, RFC4918 Section 11.1\n\t\t                        */\n\tcase 208:\n\t\treturn \"Already Reported\"; /* RFC5842 Section 7.1 */\n\n\tcase 226:\n\t\treturn \"IM used\"; /* RFC3229 Section 10.4.1 */\n\n\t/* RFC2616 Section 10.3 - Redirection 3xx */\n\tcase 300:\n\t\treturn \"Multiple Choices\"; /* RFC2616 Section 10.3.1 */\n\tcase 301:\n\t\treturn \"Moved Permanently\"; /* RFC2616 Section 10.3.2 */\n\tcase 302:\n\t\treturn \"Found\"; /* RFC2616 Section 10.3.3 */\n\tcase 303:\n\t\treturn \"See Other\"; /* RFC2616 Section 10.3.4 */\n\tcase 304:\n\t\treturn \"Not Modified\"; /* RFC2616 Section 10.3.5 */\n\tcase 305:\n\t\treturn \"Use Proxy\"; /* RFC2616 Section 10.3.6 */\n\tcase 307:\n\t\treturn \"Temporary Redirect\"; /* RFC2616 Section 10.3.8 */\n\tcase 308:\n\t\treturn \"Permanent Redirect\"; /* RFC7238 Section 3 */\n\n\t/* RFC2616 Section 10.4 - Client Error 4xx */\n\tcase 400:\n\t\treturn \"Bad Request\"; /* RFC2616 Section 10.4.1 */\n\tcase 401:\n\t\treturn \"Unauthorized\"; /* RFC2616 Section 10.4.2 */\n\tcase 402:\n\t\treturn \"Payment Required\"; /* RFC2616 Section 10.4.3 */\n\tcase 403:\n\t\treturn \"Forbidden\"; /* RFC2616 Section 10.4.4 */\n\tcase 404:\n\t\treturn \"Not Found\"; /* RFC2616 Section 10.4.5 */\n\tcase 405:\n\t\treturn \"Method Not Allowed\"; /* RFC2616 Section 10.4.6 */\n\tcase 406:\n\t\treturn \"Not Acceptable\"; /* RFC2616 Section 10.4.7 */\n\tcase 407:\n\t\treturn \"Proxy Authentication Required\"; /* RFC2616 Section 10.4.8 */\n\tcase 408:\n\t\treturn \"Request Time-out\"; /* RFC2616 Section 10.4.9 */\n\tcase 409:\n\t\treturn \"Conflict\"; /* RFC2616 Section 10.4.10 */\n\tcase 410:\n\t\treturn \"Gone\"; /* RFC2616 Section 10.4.11 */\n\tcase 411:\n\t\treturn \"Length Required\"; /* RFC2616 Section 10.4.12 */\n\tcase 412:\n\t\treturn \"Precondition Failed\"; /* RFC2616 Section 10.4.13 */\n\tcase 413:\n\t\treturn \"Request Entity Too Large\"; /* RFC2616 Section 10.4.14 */\n\tcase 414:\n\t\treturn \"Request-URI Too Large\"; /* RFC2616 Section 10.4.15 */\n\tcase 415:\n\t\treturn \"Unsupported Media Type\"; /* RFC2616 Section 10.4.16 */\n\tcase 416:\n\t\treturn \"Requested range not satisfiable\"; /* RFC2616 Section 10.4.17\n\t\t                                           */\n\tcase 417:\n\t\treturn \"Expectation Failed\"; /* RFC2616 Section 10.4.18 */\n\n\tcase 421:\n\t\treturn \"Misdirected Request\"; /* RFC7540 Section 9.1.2 */\n\tcase 422:\n\t\treturn \"Unproccessable entity\"; /* RFC2518 Section 10.3, RFC4918\n\t\t                                 * Section 11.2 */\n\tcase 423:\n\t\treturn \"Locked\"; /* RFC2518 Section 10.4, RFC4918 Section 11.3 */\n\tcase 424:\n\t\treturn \"Failed Dependency\"; /* RFC2518 Section 10.5, RFC4918\n\t\t                             * Section 11.4 */\n\n\tcase 426:\n\t\treturn \"Upgrade Required\"; /* RFC 2817 Section 4 */\n\n\tcase 428:\n\t\treturn \"Precondition Required\"; /* RFC 6585, Section 3 */\n\tcase 429:\n\t\treturn \"Too Many Requests\"; /* RFC 6585, Section 4 */\n\n\tcase 431:\n\t\treturn \"Request Header Fields Too Large\"; /* RFC 6585, Section 5 */\n\n\tcase 451:\n\t\treturn \"Unavailable For Legal Reasons\"; /* draft-tbray-http-legally-restricted-status-05,\n\t\t                                         * Section 3 */\n\n\t/* RFC2616 Section 10.5 - Server Error 5xx */\n\tcase 500:\n\t\treturn \"Internal Server Error\"; /* RFC2616 Section 10.5.1 */\n\tcase 501:\n\t\treturn \"Not Implemented\"; /* RFC2616 Section 10.5.2 */\n\tcase 502:\n\t\treturn \"Bad Gateway\"; /* RFC2616 Section 10.5.3 */\n\tcase 503:\n\t\treturn \"Service Unavailable\"; /* RFC2616 Section 10.5.4 */\n\tcase 504:\n\t\treturn \"Gateway Time-out\"; /* RFC2616 Section 10.5.5 */\n\tcase 505:\n\t\treturn \"HTTP Version not supported\"; /* RFC2616 Section 10.5.6 */\n\tcase 506:\n\t\treturn \"Variant Also Negotiates\"; /* RFC 2295, Section 8.1 */\n\tcase 507:\n\t\treturn \"Insufficient Storage\"; /* RFC2518 Section 10.6, RFC4918\n\t\t                                * Section 11.5 */\n\tcase 508:\n\t\treturn \"Loop Detected\"; /* RFC5842 Section 7.1 */\n\n\tcase 510:\n\t\treturn \"Not Extended\"; /* RFC 2774, Section 7 */\n\tcase 511:\n\t\treturn \"Network Authentication Required\"; /* RFC 6585, Section 6 */\n\n\t/* Other status codes, not shown in the IANA HTTP status code\n\t * assignment.\n\t * E.g., \"de facto\" standards due to common use, ... */\n\tcase 418:\n\t\treturn \"I am a teapot\"; /* RFC2324 Section 2.3.2 */\n\tcase 419:\n\t\treturn \"Authentication Timeout\"; /* common use */\n\tcase 420:\n\t\treturn \"Enhance Your Calm\"; /* common use */\n\tcase 440:\n\t\treturn \"Login Timeout\"; /* common use */\n\tcase 509:\n\t\treturn \"Bandwidth Limit Exceeded\"; /* common use */\n\n\tdefault:\n\t\t/* This error code is unknown. This should not happen. */\n\t\tif (conn) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Unknown HTTP response code: %u\",\n\t\t\t                response_code);\n\t\t}\n\n\t\t/* Return at least a category according to RFC 2616 Section 10. */\n\t\tif (response_code >= 100 && response_code < 200) {\n\t\t\t/* Unknown informational status code */\n\t\t\treturn \"Information\";\n\t\t}\n\t\tif (response_code >= 200 && response_code < 300) {\n\t\t\t/* Unknown success code */\n\t\t\treturn \"Success\";\n\t\t}\n\t\tif (response_code >= 300 && response_code < 400) {\n\t\t\t/* Unknown redirection code */\n\t\t\treturn \"Redirection\";\n\t\t}\n\t\tif (response_code >= 400 && response_code < 500) {\n\t\t\t/* Unknown request error code */\n\t\t\treturn \"Client Error\";\n\t\t}\n\t\tif (response_code >= 500 && response_code < 600) {\n\t\t\t/* Unknown server error code */\n\t\t\treturn \"Server Error\";\n\t\t}\n\n\t\t/* Response code not even within reasonable range */\n\t\treturn \"\";\n\t}\n}\n\n\nstatic int\nmg_send_http_error_impl(struct mg_connection *conn,\n                        int status,\n                        const char *fmt,\n                        va_list args)\n{\n\tchar errmsg_buf[MG_BUF_LEN];\n\tchar path_buf[PATH_MAX];\n\tva_list ap;\n\tint len, i, page_handler_found, scope, truncated, has_body;\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\tconst char *error_handler = NULL;\n\tstruct mg_file error_page_file = STRUCT_FILE_INITIALIZER;\n\tconst char *error_page_file_ext, *tstr;\n\tint handled_by_callback = 0;\n\n\tconst char *status_text = mg_get_response_code_text(conn, status);\n\n\tif ((conn == NULL) || (fmt == NULL)) {\n\t\treturn -2;\n\t}\n\n\t/* Set status (for log) */\n\tconn->status_code = status;\n\n\t/* Errors 1xx, 204 and 304 MUST NOT send a body */\n\thas_body = ((status > 199) && (status != 204) && (status != 304));\n\n\t/* Prepare message in buf, if required */\n\tif (has_body\n\t    || (!conn->in_error_handler\n\t        && (conn->phys_ctx->callbacks.http_error != NULL))) {\n\t\t/* Store error message in errmsg_buf */\n\t\tva_copy(ap, args);\n\t\tmg_vsnprintf(conn, NULL, errmsg_buf, sizeof(errmsg_buf), fmt, ap);\n\t\tva_end(ap);\n\t\t/* In a debug build, print all html errors */\n\t\tDEBUG_TRACE(\"Error %i - [%s]\", status, errmsg_buf);\n\t}\n\n\t/* If there is a http_error callback, call it.\n\t * But don't do it recursively, if callback calls mg_send_http_error again.\n\t */\n\tif (!conn->in_error_handler\n\t    && (conn->phys_ctx->callbacks.http_error != NULL)) {\n\t\t/* Mark in_error_handler to avoid recursion and call user callback. */\n\t\tconn->in_error_handler = 1;\n\t\thandled_by_callback =\n\t\t    (conn->phys_ctx->callbacks.http_error(conn, status, errmsg_buf)\n\t\t     == 0);\n\t\tconn->in_error_handler = 0;\n\t}\n\n\tif (!handled_by_callback) {\n\t\t/* Check for recursion */\n\t\tif (conn->in_error_handler) {\n\t\t\tDEBUG_TRACE(\n\t\t\t    \"Recursion when handling error %u - fall back to default\",\n\t\t\t    status);\n\t\t} else {\n\t\t\t/* Send user defined error pages, if defined */\n\t\t\terror_handler = conn->dom_ctx->config[ERROR_PAGES];\n\t\t\terror_page_file_ext = conn->dom_ctx->config[INDEX_FILES];\n\t\t\tpage_handler_found = 0;\n\n\t\t\tif (error_handler != NULL) {\n\t\t\t\tfor (scope = 1; (scope <= 3) && !page_handler_found; scope++) {\n\t\t\t\t\tswitch (scope) {\n\t\t\t\t\tcase 1: /* Handler for specific error, e.g. 404 error */\n\t\t\t\t\t\tmg_snprintf(conn,\n\t\t\t\t\t\t            &truncated,\n\t\t\t\t\t\t            path_buf,\n\t\t\t\t\t\t            sizeof(path_buf) - 32,\n\t\t\t\t\t\t            \"%serror%03u.\",\n\t\t\t\t\t\t            error_handler,\n\t\t\t\t\t\t            status);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2: /* Handler for error group, e.g., 5xx error\n\t\t\t\t\t         * handler\n\t\t\t\t\t         * for all server errors (500-599) */\n\t\t\t\t\t\tmg_snprintf(conn,\n\t\t\t\t\t\t            &truncated,\n\t\t\t\t\t\t            path_buf,\n\t\t\t\t\t\t            sizeof(path_buf) - 32,\n\t\t\t\t\t\t            \"%serror%01uxx.\",\n\t\t\t\t\t\t            error_handler,\n\t\t\t\t\t\t            status / 100);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: /* Handler for all errors */\n\t\t\t\t\t\tmg_snprintf(conn,\n\t\t\t\t\t\t            &truncated,\n\t\t\t\t\t\t            path_buf,\n\t\t\t\t\t\t            sizeof(path_buf) - 32,\n\t\t\t\t\t\t            \"%serror.\",\n\t\t\t\t\t\t            error_handler);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* String truncation in buf may only occur if\n\t\t\t\t\t * error_handler is too long. This string is\n\t\t\t\t\t * from the config, not from a client. */\n\t\t\t\t\t(void)truncated;\n\n\t\t\t\t\tlen = (int)strlen(path_buf);\n\n\t\t\t\t\ttstr = strchr(error_page_file_ext, '.');\n\n\t\t\t\t\twhile (tstr) {\n\t\t\t\t\t\tfor (i = 1;\n\t\t\t\t\t\t     (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');\n\t\t\t\t\t\t     i++) {\n\t\t\t\t\t\t\t/* buffer overrun is not possible here, since\n\t\t\t\t\t\t\t * (i < 32) && (len < sizeof(path_buf) - 32)\n\t\t\t\t\t\t\t * ==> (i + len) < sizeof(path_buf) */\n\t\t\t\t\t\t\tpath_buf[len + i - 1] = tstr[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* buffer overrun is not possible here, since\n\t\t\t\t\t\t * (i <= 32) && (len < sizeof(path_buf) - 32)\n\t\t\t\t\t\t * ==> (i + len) <= sizeof(path_buf) */\n\t\t\t\t\t\tpath_buf[len + i - 1] = 0;\n\n\t\t\t\t\t\tif (mg_stat(conn, path_buf, &error_page_file.stat)) {\n\t\t\t\t\t\t\tDEBUG_TRACE(\"Check error page %s - found\",\n\t\t\t\t\t\t\t            path_buf);\n\t\t\t\t\t\t\tpage_handler_found = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tDEBUG_TRACE(\"Check error page %s - not found\",\n\t\t\t\t\t\t            path_buf);\n\n\t\t\t\t\t\ttstr = strchr(tstr + i, '.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (page_handler_found) {\n\t\t\t\tconn->in_error_handler = 1;\n\t\t\t\thandle_file_based_request(conn, path_buf, &error_page_file);\n\t\t\t\tconn->in_error_handler = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/* No custom error page. Send default error page. */\n\t\tgmt_time_string(date, sizeof(date), &curtime);\n\n\t\tconn->must_close = 1;\n\t\tmg_printf(conn, \"HTTP/1.1 %d %s\\r\\n\", status, status_text);\n\t\tsend_no_cache_header(conn);\n\t\tsend_additional_header(conn);\n\t\tif (has_body) {\n\t\t\tmg_printf(conn,\n\t\t\t          \"%s\",\n\t\t\t          \"Content-Type: text/plain; charset=utf-8\\r\\n\");\n\t\t}\n\t\tmg_printf(conn,\n\t\t          \"Date: %s\\r\\n\"\n\t\t          \"Connection: close\\r\\n\\r\\n\",\n\t\t          date);\n\n\t\t/* HTTP responses 1xx, 204 and 304 MUST NOT send a body */\n\t\tif (has_body) {\n\t\t\t/* For other errors, send a generic error message. */\n\t\t\tmg_printf(conn, \"Error %d: %s\\n\", status, status_text);\n\t\t\tmg_write(conn, errmsg_buf, strlen(errmsg_buf));\n\n\t\t} else {\n\t\t\t/* No body allowed. Close the connection. */\n\t\t\tDEBUG_TRACE(\"Error %i\", status);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint\nmg_send_http_error(struct mg_connection *conn, int status, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = mg_send_http_error_impl(conn, status, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}\n\n\nint\nmg_send_http_ok(struct mg_connection *conn,\n                const char *mime_type,\n                long long content_length)\n{\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tif ((mime_type == NULL) || (*mime_type == 0)) {\n\t\t/* Parameter error */\n\t\treturn -2;\n\t}\n\n\tgmt_time_string(date, sizeof(date), &curtime);\n\n\tmg_printf(conn,\n\t          \"HTTP/1.1 200 OK\\r\\n\"\n\t          \"Content-Type: %s\\r\\n\"\n\t          \"Date: %s\\r\\n\"\n\t          \"Connection: %s\\r\\n\",\n\t          mime_type,\n\t          date,\n\t          suggest_connection_header(conn));\n\n\tsend_no_cache_header(conn);\n\tsend_additional_header(conn);\n\tif (content_length < 0) {\n\t\tmg_printf(conn, \"Transfer-Encoding: chunked\\r\\n\\r\\n\");\n\t} else {\n\t\tmg_printf(conn,\n\t\t          \"Content-Length: %\" UINT64_FMT \"\\r\\n\\r\\n\",\n\t\t          (uint64_t)content_length);\n\t}\n\n\treturn 0;\n}\n\n\nint\nmg_send_http_redirect(struct mg_connection *conn,\n                      const char *target_url,\n                      int redirect_code)\n{\n\t/* Send a 30x redirect response.\n\t *\n\t * Redirect types (status codes):\n\t *\n\t * Status | Perm/Temp | Method              | Version\n\t *   301  | permanent | POST->GET undefined | HTTP/1.0\n\t *   302  | temporary | POST->GET undefined | HTTP/1.0\n\t *   303  | temporary | always use GET      | HTTP/1.1\n\t *   307  | temporary | always keep method  | HTTP/1.1\n\t *   308  | permanent | always keep method  | HTTP/1.1\n\t */\n\tconst char *redirect_text;\n\tint ret;\n\tsize_t content_len = 0;\n\tchar reply[MG_BUF_LEN];\n\n\t/* In case redirect_code=0, use 307. */\n\tif (redirect_code == 0) {\n\t\tredirect_code = 307;\n\t}\n\n\t/* In case redirect_code is none of the above, return error. */\n\tif ((redirect_code != 301) && (redirect_code != 302)\n\t    && (redirect_code != 303) && (redirect_code != 307)\n\t    && (redirect_code != 308)) {\n\t\t/* Parameter error */\n\t\treturn -2;\n\t}\n\n\t/* Get proper text for response code */\n\tredirect_text = mg_get_response_code_text(conn, redirect_code);\n\n\t/* If target_url is not defined, redirect to \"/\". */\n\tif ((target_url == NULL) || (*target_url == 0)) {\n\t\ttarget_url = \"/\";\n\t}\n\n#if defined(MG_SEND_REDIRECT_BODY)\n\t/* TODO: condition name? */\n\n\t/* Prepare a response body with a hyperlink.\n\t *\n\t * According to RFC2616 (and RFC1945 before):\n\t * Unless the request method was HEAD, the entity of the\n\t * response SHOULD contain a short hypertext note with a hyperlink to\n\t * the new URI(s).\n\t *\n\t * However, this response body is not useful in M2M communication.\n\t * Probably the original reason in the RFC was, clients not supporting\n\t * a 30x HTTP redirect could still show the HTML page and let the user\n\t * press the link. Since current browsers support 30x HTTP, the additional\n\t * HTML body does not seem to make sense anymore.\n\t *\n\t * The new RFC7231 (Section 6.4) does no longer recommend it (\"SHOULD\"),\n\t * but it only notes:\n\t * The server's response payload usually contains a short\n\t * hypertext note with a hyperlink to the new URI(s).\n\t *\n\t * Deactivated by default. If you need the 30x body, set the define.\n\t */\n\tmg_snprintf(\n\t    conn,\n\t    NULL /* ignore truncation */,\n\t    reply,\n\t    sizeof(reply),\n\t    \"<html><head>%s</head><body><a href=\\\"%s\\\">%s</a></body></html>\",\n\t    redirect_text,\n\t    target_url,\n\t    target_url);\n\tcontent_len = strlen(reply);\n#else\n\treply[0] = 0;\n#endif\n\n\t/* Do not send any additional header. For all other options,\n\t * including caching, there are suitable defaults. */\n\tret = mg_printf(conn,\n\t                \"HTTP/1.1 %i %s\\r\\n\"\n\t                \"Location: %s\\r\\n\"\n\t                \"Content-Length: %u\\r\\n\"\n\t                \"Connection: %s\\r\\n\\r\\n\",\n\t                redirect_code,\n\t                redirect_text,\n\t                target_url,\n\t                (unsigned int)content_len,\n\t                suggest_connection_header(conn));\n\n\t/* Send response body */\n\tif (ret > 0) {\n\t\t/* ... unless it is a HEAD request */\n\t\tif (0 != strcmp(conn->request_info.request_method, \"HEAD\")) {\n\t\t\tret = mg_write(conn, reply, content_len);\n\t\t}\n\t}\n\n\treturn (ret > 0) ? ret : -1;\n}\n\n\n#if defined(_WIN32)\n/* Create substitutes for POSIX functions in Win32. */\n\n#if defined(GCC_DIAGNOSTIC)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_mutex_init(pthread_mutex_t *mutex, void *unused)\n{\n\t(void)unused;\n\t*mutex = CreateMutex(NULL, FALSE, NULL);\n\treturn (*mutex == NULL) ? -1 : 0;\n}\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_mutex_destroy(pthread_mutex_t *mutex)\n{\n\treturn (CloseHandle(*mutex) == 0) ? -1 : 0;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_mutex_lock(pthread_mutex_t *mutex)\n{\n\treturn (WaitForSingleObject(*mutex, (DWORD)INFINITE) == WAIT_OBJECT_0) ? 0\n\t                                                                       : -1;\n}\n\n\n#if defined(ENABLE_UNUSED_PTHREAD_FUNCTIONS)\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_mutex_trylock(pthread_mutex_t *mutex)\n{\n\tswitch (WaitForSingleObject(*mutex, 0)) {\n\tcase WAIT_OBJECT_0:\n\t\treturn 0;\n\tcase WAIT_TIMEOUT:\n\t\treturn -2; /* EBUSY */\n\t}\n\treturn -1;\n}\n#endif\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_mutex_unlock(pthread_mutex_t *mutex)\n{\n\treturn (ReleaseMutex(*mutex) == 0) ? -1 : 0;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_init(pthread_cond_t *cv, const void *unused)\n{\n\t(void)unused;\n\tInitializeCriticalSection(&cv->threadIdSec);\n\tcv->waiting_thread = NULL;\n\treturn 0;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_timedwait(pthread_cond_t *cv,\n                       pthread_mutex_t *mutex,\n                       FUNCTION_MAY_BE_UNUSED const struct timespec *abstime)\n{\n\tstruct mg_workerTLS **ptls,\n\t    *tls = (struct mg_workerTLS *)pthread_getspecific(sTlsKey);\n\tint ok;\n\tint64_t nsnow, nswaitabs, nswaitrel;\n\tDWORD mswaitrel;\n\n\tEnterCriticalSection(&cv->threadIdSec);\n\t/* Add this thread to cv's waiting list */\n\tptls = &cv->waiting_thread;\n\tfor (; *ptls != NULL; ptls = &(*ptls)->next_waiting_thread)\n\t\t;\n\ttls->next_waiting_thread = NULL;\n\t*ptls = tls;\n\tLeaveCriticalSection(&cv->threadIdSec);\n\n\tif (abstime) {\n\t\tnsnow = mg_get_current_time_ns();\n\t\tnswaitabs =\n\t\t    (((int64_t)abstime->tv_sec) * 1000000000) + abstime->tv_nsec;\n\t\tnswaitrel = nswaitabs - nsnow;\n\t\tif (nswaitrel < 0) {\n\t\t\tnswaitrel = 0;\n\t\t}\n\t\tmswaitrel = (DWORD)(nswaitrel / 1000000);\n\t} else {\n\t\tmswaitrel = (DWORD)INFINITE;\n\t}\n\n\tpthread_mutex_unlock(mutex);\n\tok = (WAIT_OBJECT_0\n\t      == WaitForSingleObject(tls->pthread_cond_helper_mutex, mswaitrel));\n\tif (!ok) {\n\t\tok = 1;\n\t\tEnterCriticalSection(&cv->threadIdSec);\n\t\tptls = &cv->waiting_thread;\n\t\tfor (; *ptls != NULL; ptls = &(*ptls)->next_waiting_thread) {\n\t\t\tif (*ptls == tls) {\n\t\t\t\t*ptls = tls->next_waiting_thread;\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tLeaveCriticalSection(&cv->threadIdSec);\n\t\tif (ok) {\n\t\t\tWaitForSingleObject(tls->pthread_cond_helper_mutex,\n\t\t\t                    (DWORD)INFINITE);\n\t\t}\n\t}\n\t/* This thread has been removed from cv's waiting list */\n\tpthread_mutex_lock(mutex);\n\n\treturn ok ? 0 : -1;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *mutex)\n{\n\treturn pthread_cond_timedwait(cv, mutex, NULL);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_signal(pthread_cond_t *cv)\n{\n\tHANDLE wkup = NULL;\n\tBOOL ok = FALSE;\n\n\tEnterCriticalSection(&cv->threadIdSec);\n\tif (cv->waiting_thread) {\n\t\twkup = cv->waiting_thread->pthread_cond_helper_mutex;\n\t\tcv->waiting_thread = cv->waiting_thread->next_waiting_thread;\n\n\t\tok = SetEvent(wkup);\n\t\tDEBUG_ASSERT(ok);\n\t}\n\tLeaveCriticalSection(&cv->threadIdSec);\n\n\treturn ok ? 0 : 1;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_broadcast(pthread_cond_t *cv)\n{\n\tEnterCriticalSection(&cv->threadIdSec);\n\twhile (cv->waiting_thread) {\n\t\tpthread_cond_signal(cv);\n\t}\n\tLeaveCriticalSection(&cv->threadIdSec);\n\n\treturn 0;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_destroy(pthread_cond_t *cv)\n{\n\tEnterCriticalSection(&cv->threadIdSec);\n\tDEBUG_ASSERT(cv->waiting_thread == NULL);\n\tLeaveCriticalSection(&cv->threadIdSec);\n\tDeleteCriticalSection(&cv->threadIdSec);\n\n\treturn 0;\n}\n\n\n#if defined(ALTERNATIVE_QUEUE)\nFUNCTION_MAY_BE_UNUSED\nstatic void *\nevent_create(void)\n{\n\treturn (void *)CreateEvent(NULL, FALSE, FALSE, NULL);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nevent_wait(void *eventhdl)\n{\n\tint res = WaitForSingleObject((HANDLE)eventhdl, (DWORD)INFINITE);\n\treturn (res == WAIT_OBJECT_0);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nevent_signal(void *eventhdl)\n{\n\treturn (int)SetEvent((HANDLE)eventhdl);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic void\nevent_destroy(void *eventhdl)\n{\n\tCloseHandle((HANDLE)eventhdl);\n}\n#endif\n\n\n#if defined(GCC_DIAGNOSTIC)\n/* Enable unused function warning again */\n#pragma GCC diagnostic pop\n#endif\n\n\n/* For Windows, change all slashes to backslashes in path names. */\nstatic void\nchange_slashes_to_backslashes(char *path)\n{\n\tint i;\n\n\tfor (i = 0; path[i] != '\\0'; i++) {\n\t\tif (path[i] == '/') {\n\t\t\tpath[i] = '\\\\';\n\t\t}\n\n\t\t/* remove double backslash (check i > 0 to preserve UNC paths,\n\t\t * like \\\\server\\file.txt) */\n\t\tif ((path[i] == '\\\\') && (i > 0)) {\n\t\t\twhile ((path[i + 1] == '\\\\') || (path[i + 1] == '/')) {\n\t\t\t\t(void)memmove(path + i + 1, path + i + 2, strlen(path + i + 1));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic int\nmg_wcscasecmp(const wchar_t *s1, const wchar_t *s2)\n{\n\tint diff;\n\n\tdo {\n\t\tdiff = tolower(*s1) - tolower(*s2);\n\t\ts1++;\n\t\ts2++;\n\t} while ((diff == 0) && (s1[-1] != '\\0'));\n\n\treturn diff;\n}\n\n\n/* Encode 'path' which is assumed UTF-8 string, into UNICODE string.\n * wbuf and wbuf_len is a target buffer and its length. */\nstatic void\npath_to_unicode(const struct mg_connection *conn,\n                const char *path,\n                wchar_t *wbuf,\n                size_t wbuf_len)\n{\n\tchar buf[PATH_MAX], buf2[PATH_MAX];\n\twchar_t wbuf2[W_PATH_MAX + 1];\n\tDWORD long_len, err;\n\tint (*fcompare)(const wchar_t *, const wchar_t *) = mg_wcscasecmp;\n\n\tmg_strlcpy(buf, path, sizeof(buf));\n\tchange_slashes_to_backslashes(buf);\n\n\t/* Convert to Unicode and back. If doubly-converted string does not\n\t * match the original, something is fishy, reject. */\n\tmemset(wbuf, 0, wbuf_len * sizeof(wchar_t));\n\tMultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int)wbuf_len);\n\tWideCharToMultiByte(\n\t    CP_UTF8, 0, wbuf, (int)wbuf_len, buf2, sizeof(buf2), NULL, NULL);\n\tif (strcmp(buf, buf2) != 0) {\n\t\twbuf[0] = L'\\0';\n\t}\n\n\t/* Windows file systems are not case sensitive, but you can still use\n\t * uppercase and lowercase letters (on all modern file systems).\n\t * The server can check if the URI uses the same upper/lowercase\n\t * letters an the file system, effectively making Windows servers\n\t * case sensitive (like Linux servers are). It is still not possible\n\t * to use two files with the same name in different cases on Windows\n\t * (like /a and /A) - this would be possible in Linux.\n\t * As a default, Windows is not case sensitive, but the case sensitive\n\t * file name check can be activated by an additional configuration. */\n\tif (conn) {\n\t\tif (conn->dom_ctx->config[CASE_SENSITIVE_FILES]\n\t\t    && !mg_strcasecmp(conn->dom_ctx->config[CASE_SENSITIVE_FILES],\n\t\t                      \"yes\")) {\n\t\t\t/* Use case sensitive compare function */\n\t\t\tfcompare = wcscmp;\n\t\t}\n\t}\n\t(void)conn; /* conn is currently unused */\n\n#if !defined(_WIN32_WCE)\n\t/* Only accept a full file path, not a Windows short (8.3) path. */\n\tmemset(wbuf2, 0, ARRAY_SIZE(wbuf2) * sizeof(wchar_t));\n\tlong_len = GetLongPathNameW(wbuf, wbuf2, ARRAY_SIZE(wbuf2) - 1);\n\tif (long_len == 0) {\n\t\terr = GetLastError();\n\t\tif (err == ERROR_FILE_NOT_FOUND) {\n\t\t\t/* File does not exist. This is not always a problem here. */\n\t\t\treturn;\n\t\t}\n\t}\n\tif ((long_len >= ARRAY_SIZE(wbuf2)) || (fcompare(wbuf, wbuf2) != 0)) {\n\t\t/* Short name is used. */\n\t\twbuf[0] = L'\\0';\n\t}\n#else\n\t(void)long_len;\n\t(void)wbuf2;\n\t(void)err;\n\n\tif (strchr(path, '~')) {\n\t\twbuf[0] = L'\\0';\n\t}\n#endif\n}\n\n\n/* Windows happily opens files with some garbage at the end of file name.\n * For example, fopen(\"a.cgi    \", \"r\") on Windows successfully opens\n * \"a.cgi\", despite one would expect an error back.\n * This function returns non-0 if path ends with some garbage. */\nstatic int\npath_cannot_disclose_cgi(const char *path)\n{\n\tstatic const char *allowed_last_characters = \"_-\";\n\tint last = path[strlen(path) - 1];\n\treturn isalnum(last) || strchr(allowed_last_characters, last) != NULL;\n}\n\n\nstatic int\nmg_stat(const struct mg_connection *conn,\n        const char *path,\n        struct mg_file_stat *filep)\n{\n\twchar_t wbuf[W_PATH_MAX];\n\tWIN32_FILE_ATTRIBUTE_DATA info;\n\ttime_t creation_time;\n\n\tif (!filep) {\n\t\treturn 0;\n\t}\n\tmemset(filep, 0, sizeof(*filep));\n\n\tif (conn && is_file_in_memory(conn, path)) {\n\t\t/* filep->is_directory = 0; filep->gzipped = 0; .. already done by\n\t\t * memset */\n\n\t\t/* Quick fix (for 1.9.x): */\n\t\t/* mg_stat must fill all fields, also for files in memory */\n\t\tstruct mg_file tmp_file = STRUCT_FILE_INITIALIZER;\n\t\topen_file_in_memory(conn, path, &tmp_file, MG_FOPEN_MODE_NONE);\n\t\tfilep->size = tmp_file.stat.size;\n\t\tfilep->location = 2;\n\t\t/* TODO: for 1.10: restructure how files in memory are handled */\n\n\t\t/* The \"file in memory\" feature is a candidate for deletion.\n\t\t * Please join the discussion at\n\t\t * https://groups.google.com/forum/#!topic/civetweb/h9HT4CmeYqI\n\t\t */\n\n\t\tfilep->last_modified = time(NULL); /* TODO */\n\t\t/* last_modified = now ... assumes the file may change during\n\t\t * runtime,\n\t\t * so every mg_fopen call may return different data */\n\t\t/* last_modified = conn->phys_ctx.start_time;\n\t\t * May be used it the data does not change during runtime. This\n\t\t * allows\n\t\t * browser caching. Since we do not know, we have to assume the file\n\t\t * in memory may change. */\n\t\treturn 1;\n\t}\n\n\tpath_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));\n\tif (GetFileAttributesExW(wbuf, GetFileExInfoStandard, &info) != 0) {\n\t\tfilep->size = MAKEUQUAD(info.nFileSizeLow, info.nFileSizeHigh);\n\t\tfilep->last_modified =\n\t\t    SYS2UNIX_TIME(info.ftLastWriteTime.dwLowDateTime,\n\t\t                  info.ftLastWriteTime.dwHighDateTime);\n\n\t\t/* On Windows, the file creation time can be higher than the\n\t\t * modification time, e.g. when a file is copied.\n\t\t * Since the Last-Modified timestamp is used for caching\n\t\t * it should be based on the most recent timestamp. */\n\t\tcreation_time = SYS2UNIX_TIME(info.ftCreationTime.dwLowDateTime,\n\t\t                              info.ftCreationTime.dwHighDateTime);\n\t\tif (creation_time > filep->last_modified) {\n\t\t\tfilep->last_modified = creation_time;\n\t\t}\n\n\t\tfilep->is_directory = info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;\n\t\t/* If file name is fishy, reset the file structure and return\n\t\t * error.\n\t\t * Note it is important to reset, not just return the error, cause\n\t\t * functions like is_file_opened() check the struct. */\n\t\tif (!filep->is_directory && !path_cannot_disclose_cgi(path)) {\n\t\t\tmemset(filep, 0, sizeof(*filep));\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int\nmg_remove(const struct mg_connection *conn, const char *path)\n{\n\twchar_t wbuf[W_PATH_MAX];\n\tpath_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));\n\treturn DeleteFileW(wbuf) ? 0 : -1;\n}\n\n\nstatic int\nmg_mkdir(const struct mg_connection *conn, const char *path, int mode)\n{\n\twchar_t wbuf[W_PATH_MAX];\n\t(void)mode;\n\tpath_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));\n\treturn CreateDirectoryW(wbuf, NULL) ? 0 : -1;\n}\n\n\n/* Create substitutes for POSIX functions in Win32. */\n\n#if defined(GCC_DIAGNOSTIC)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\n\n\n/* Implementation of POSIX opendir/closedir/readdir for Windows. */\nFUNCTION_MAY_BE_UNUSED\nstatic DIR *\nmg_opendir(const struct mg_connection *conn, const char *name)\n{\n\tDIR *dir = NULL;\n\twchar_t wpath[W_PATH_MAX];\n\tDWORD attrs;\n\n\tif (name == NULL) {\n\t\tSetLastError(ERROR_BAD_ARGUMENTS);\n\t} else if ((dir = (DIR *)mg_malloc(sizeof(*dir))) == NULL) {\n\t\tSetLastError(ERROR_NOT_ENOUGH_MEMORY);\n\t} else {\n\t\tpath_to_unicode(conn, name, wpath, ARRAY_SIZE(wpath));\n\t\tattrs = GetFileAttributesW(wpath);\n\t\tif ((wcslen(wpath) + 2 < ARRAY_SIZE(wpath)) && (attrs != 0xFFFFFFFF)\n\t\t    && ((attrs & FILE_ATTRIBUTE_DIRECTORY) != 0)) {\n\t\t\t(void)wcscat(wpath, L\"\\\\*\");\n\t\t\tdir->handle = FindFirstFileW(wpath, &dir->info);\n\t\t\tdir->result.d_name[0] = '\\0';\n\t\t} else {\n\t\t\tmg_free(dir);\n\t\t\tdir = NULL;\n\t\t}\n\t}\n\n\treturn dir;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nmg_closedir(DIR *dir)\n{\n\tint result = 0;\n\n\tif (dir != NULL) {\n\t\tif (dir->handle != INVALID_HANDLE_VALUE)\n\t\t\tresult = FindClose(dir->handle) ? 0 : -1;\n\n\t\tmg_free(dir);\n\t} else {\n\t\tresult = -1;\n\t\tSetLastError(ERROR_BAD_ARGUMENTS);\n\t}\n\n\treturn result;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic struct dirent *\nmg_readdir(DIR *dir)\n{\n\tstruct dirent *result = 0;\n\n\tif (dir) {\n\t\tif (dir->handle != INVALID_HANDLE_VALUE) {\n\t\t\tresult = &dir->result;\n\t\t\t(void)WideCharToMultiByte(CP_UTF8,\n\t\t\t                          0,\n\t\t\t                          dir->info.cFileName,\n\t\t\t                          -1,\n\t\t\t                          result->d_name,\n\t\t\t                          sizeof(result->d_name),\n\t\t\t                          NULL,\n\t\t\t                          NULL);\n\n\t\t\tif (!FindNextFileW(dir->handle, &dir->info)) {\n\t\t\t\t(void)FindClose(dir->handle);\n\t\t\t\tdir->handle = INVALID_HANDLE_VALUE;\n\t\t\t}\n\n\t\t} else {\n\t\t\tSetLastError(ERROR_FILE_NOT_FOUND);\n\t\t}\n\t} else {\n\t\tSetLastError(ERROR_BAD_ARGUMENTS);\n\t}\n\n\treturn result;\n}\n\n\n#if !defined(HAVE_POLL)\n#define POLLIN (1)  /* Data ready - read will not block. */\n#define POLLPRI (2) /* Priority data ready. */\n#define POLLOUT (4) /* Send queue not full - write will not block. */\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npoll(struct pollfd *pfd, unsigned int n, int milliseconds)\n{\n\tstruct timeval tv;\n\tfd_set rset;\n\tfd_set wset;\n\tunsigned int i;\n\tint result;\n\tSOCKET maxfd = 0;\n\n\tmemset(&tv, 0, sizeof(tv));\n\ttv.tv_sec = milliseconds / 1000;\n\ttv.tv_usec = (milliseconds % 1000) * 1000;\n\tFD_ZERO(&rset);\n\tFD_ZERO(&wset);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (pfd[i].events & POLLIN) {\n\t\t\tFD_SET((SOCKET)pfd[i].fd, &rset);\n\t\t} else if (pfd[i].events & POLLOUT) {\n\t\t\tFD_SET((SOCKET)pfd[i].fd, &wset);\n\t\t}\n\t\tpfd[i].revents = 0;\n\n\t\tif (pfd[i].fd > maxfd) {\n\t\t\tmaxfd = pfd[i].fd;\n\t\t}\n\t}\n\n\tif ((result = select((int)maxfd + 1, &rset, &wset, NULL, &tv)) > 0) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (FD_ISSET(pfd[i].fd, &rset)) {\n\t\t\t\tpfd[i].revents |= POLLIN;\n\t\t\t}\n\t\t\tif (FD_ISSET(pfd[i].fd, &wset)) {\n\t\t\t\tpfd[i].revents |= POLLOUT;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* We should subtract the time used in select from remaining\n\t * \"milliseconds\", in particular if called from mg_poll with a\n\t * timeout quantum.\n\t * Unfortunately, the remaining time is not stored in \"tv\" in all\n\t * implementations, so the result in \"tv\" must be considered undefined.\n\t * See http://man7.org/linux/man-pages/man2/select.2.html */\n\n\treturn result;\n}\n#endif /* HAVE_POLL */\n\n\n#if defined(GCC_DIAGNOSTIC)\n/* Enable unused function warning again */\n#pragma GCC diagnostic pop\n#endif\n\n\nstatic void\nset_close_on_exec(SOCKET sock, struct mg_connection *conn /* may be null */)\n{\n\t(void)conn; /* Unused. */\n#if defined(_WIN32_WCE)\n\t(void)sock;\n#else\n\t(void)SetHandleInformation((HANDLE)(intptr_t)sock, HANDLE_FLAG_INHERIT, 0);\n#endif\n}\n\n\nint\nmg_start_thread(mg_thread_func_t f, void *p)\n{\n#if defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1)\n\t/* Compile-time option to control stack size, e.g.\n\t * -DUSE_STACK_SIZE=16384\n\t */\n\treturn ((_beginthread((void(__cdecl *)(void *))f, USE_STACK_SIZE, p)\n\t         == ((uintptr_t)(-1L)))\n\t            ? -1\n\t            : 0);\n#else\n\treturn (\n\t    (_beginthread((void(__cdecl *)(void *))f, 0, p) == ((uintptr_t)(-1L)))\n\t        ? -1\n\t        : 0);\n#endif /* defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1) */\n}\n\n\n/* Start a thread storing the thread context. */\nstatic int\nmg_start_thread_with_id(unsigned(__stdcall *f)(void *),\n                        void *p,\n                        pthread_t *threadidptr)\n{\n\tuintptr_t uip;\n\tHANDLE threadhandle;\n\tint result = -1;\n\n\tuip = _beginthreadex(NULL, 0, (unsigned(__stdcall *)(void *))f, p, 0, NULL);\n\tthreadhandle = (HANDLE)uip;\n\tif ((uip != (uintptr_t)(-1L)) && (threadidptr != NULL)) {\n\t\t*threadidptr = threadhandle;\n\t\tresult = 0;\n\t}\n\n\treturn result;\n}\n\n\n/* Wait for a thread to finish. */\nstatic int\nmg_join_thread(pthread_t threadid)\n{\n\tint result;\n\tDWORD dwevent;\n\n\tresult = -1;\n\tdwevent = WaitForSingleObject(threadid, (DWORD)INFINITE);\n\tif (dwevent == WAIT_FAILED) {\n\t\tDEBUG_TRACE(\"WaitForSingleObject() failed, error %d\", ERRNO);\n\t} else {\n\t\tif (dwevent == WAIT_OBJECT_0) {\n\t\t\tCloseHandle(threadid);\n\t\t\tresult = 0;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n#if !defined(NO_SSL_DL) && !defined(NO_SSL)\n/* If SSL is loaded dynamically, dlopen/dlclose is required. */\n/* Create substitutes for POSIX functions in Win32. */\n\n#if defined(GCC_DIAGNOSTIC)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic HANDLE\ndlopen(const char *dll_name, int flags)\n{\n\twchar_t wbuf[W_PATH_MAX];\n\t(void)flags;\n\tpath_to_unicode(NULL, dll_name, wbuf, ARRAY_SIZE(wbuf));\n\treturn LoadLibraryW(wbuf);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\ndlclose(void *handle)\n{\n\tint result;\n\n\tif (FreeLibrary((HMODULE)handle) != 0) {\n\t\tresult = 0;\n\t} else {\n\t\tresult = -1;\n\t}\n\n\treturn result;\n}\n\n\n#if defined(GCC_DIAGNOSTIC)\n/* Enable unused function warning again */\n#pragma GCC diagnostic pop\n#endif\n\n#endif\n\n\n#if !defined(NO_CGI)\n#define SIGKILL (0)\n\n\nstatic int\nkill(pid_t pid, int sig_num)\n{\n\t(void)TerminateProcess((HANDLE)pid, (UINT)sig_num);\n\t(void)CloseHandle((HANDLE)pid);\n\treturn 0;\n}\n\n\n#if !defined(WNOHANG)\n#define WNOHANG (1)\n#endif\n\n\nstatic pid_t\nwaitpid(pid_t pid, int *status, int flags)\n{\n\tDWORD timeout = INFINITE;\n\tDWORD waitres;\n\n\t(void)status; /* Currently not used by any client here */\n\n\tif ((flags | WNOHANG) == WNOHANG) {\n\t\ttimeout = 0;\n\t}\n\n\twaitres = WaitForSingleObject((HANDLE)pid, timeout);\n\tif (waitres == WAIT_OBJECT_0) {\n\t\treturn pid;\n\t}\n\tif (waitres == WAIT_TIMEOUT) {\n\t\treturn 0;\n\t}\n\treturn (pid_t)-1;\n}\n\n\nstatic void\ntrim_trailing_whitespaces(char *s)\n{\n\tchar *e = s + strlen(s) - 1;\n\twhile ((e > s) && isspace(*(unsigned char *)e)) {\n\t\t*e-- = '\\0';\n\t}\n}\n\n\nstatic pid_t\nspawn_process(struct mg_connection *conn,\n              const char *prog,\n              char *envblk,\n              char *envp[],\n              int fdin[2],\n              int fdout[2],\n              int fderr[2],\n              const char *dir)\n{\n\tHANDLE me;\n\tchar *p, *interp, full_interp[PATH_MAX], full_dir[PATH_MAX],\n\t    cmdline[PATH_MAX], buf[PATH_MAX];\n\tint truncated;\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tSTARTUPINFOA si;\n\tPROCESS_INFORMATION pi = {0};\n\n\t(void)envp;\n\n\tmemset(&si, 0, sizeof(si));\n\tsi.cb = sizeof(si);\n\n\tsi.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;\n\tsi.wShowWindow = SW_HIDE;\n\n\tme = GetCurrentProcess();\n\tDuplicateHandle(me,\n\t                (HANDLE)_get_osfhandle(fdin[0]),\n\t                me,\n\t                &si.hStdInput,\n\t                0,\n\t                TRUE,\n\t                DUPLICATE_SAME_ACCESS);\n\tDuplicateHandle(me,\n\t                (HANDLE)_get_osfhandle(fdout[1]),\n\t                me,\n\t                &si.hStdOutput,\n\t                0,\n\t                TRUE,\n\t                DUPLICATE_SAME_ACCESS);\n\tDuplicateHandle(me,\n\t                (HANDLE)_get_osfhandle(fderr[1]),\n\t                me,\n\t                &si.hStdError,\n\t                0,\n\t                TRUE,\n\t                DUPLICATE_SAME_ACCESS);\n\n\t/* Mark handles that should not be inherited. See\n\t * https://msdn.microsoft.com/en-us/library/windows/desktop/ms682499%28v=vs.85%29.aspx\n\t */\n\tSetHandleInformation((HANDLE)_get_osfhandle(fdin[1]),\n\t                     HANDLE_FLAG_INHERIT,\n\t                     0);\n\tSetHandleInformation((HANDLE)_get_osfhandle(fdout[0]),\n\t                     HANDLE_FLAG_INHERIT,\n\t                     0);\n\tSetHandleInformation((HANDLE)_get_osfhandle(fderr[0]),\n\t                     HANDLE_FLAG_INHERIT,\n\t                     0);\n\n\t/* If CGI file is a script, try to read the interpreter line */\n\tinterp = conn->dom_ctx->config[CGI_INTERPRETER];\n\tif (interp == NULL) {\n\t\tbuf[0] = buf[1] = '\\0';\n\n\t\t/* Read the first line of the script into the buffer */\n\t\tmg_snprintf(\n\t\t    conn, &truncated, cmdline, sizeof(cmdline), \"%s/%s\", dir, prog);\n\n\t\tif (truncated) {\n\t\t\tpi.hProcess = (pid_t)-1;\n\t\t\tgoto spawn_cleanup;\n\t\t}\n\n\t\tif (mg_fopen(conn, cmdline, MG_FOPEN_MODE_READ, &file)) {\n#if defined(MG_USE_OPEN_FILE)\n\t\t\tp = (char *)file.access.membuf;\n#else\n\t\t\tp = (char *)NULL;\n#endif\n\t\t\tmg_fgets(buf, sizeof(buf), &file, &p);\n\t\t\t(void)mg_fclose(&file.access); /* ignore error on read only file */\n\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\t}\n\n\t\tif ((buf[0] == '#') && (buf[1] == '!')) {\n\t\t\ttrim_trailing_whitespaces(buf + 2);\n\t\t} else {\n\t\t\tbuf[2] = '\\0';\n\t\t}\n\t\tinterp = buf + 2;\n\t}\n\n\tif (interp[0] != '\\0') {\n\t\tGetFullPathNameA(interp, sizeof(full_interp), full_interp, NULL);\n\t\tinterp = full_interp;\n\t}\n\tGetFullPathNameA(dir, sizeof(full_dir), full_dir, NULL);\n\n\tif (interp[0] != '\\0') {\n\t\tmg_snprintf(conn,\n\t\t            &truncated,\n\t\t            cmdline,\n\t\t            sizeof(cmdline),\n\t\t            \"\\\"%s\\\" \\\"%s\\\\%s\\\"\",\n\t\t            interp,\n\t\t            full_dir,\n\t\t            prog);\n\t} else {\n\t\tmg_snprintf(conn,\n\t\t            &truncated,\n\t\t            cmdline,\n\t\t            sizeof(cmdline),\n\t\t            \"\\\"%s\\\\%s\\\"\",\n\t\t            full_dir,\n\t\t            prog);\n\t}\n\n\tif (truncated) {\n\t\tpi.hProcess = (pid_t)-1;\n\t\tgoto spawn_cleanup;\n\t}\n\n\tDEBUG_TRACE(\"Running [%s]\", cmdline);\n\tif (CreateProcessA(NULL,\n\t                   cmdline,\n\t                   NULL,\n\t                   NULL,\n\t                   TRUE,\n\t                   CREATE_NEW_PROCESS_GROUP,\n\t                   envblk,\n\t                   NULL,\n\t                   &si,\n\t                   &pi)\n\t    == 0) {\n\t\tmg_cry_internal(\n\t\t    conn, \"%s: CreateProcess(%s): %ld\", __func__, cmdline, (long)ERRNO);\n\t\tpi.hProcess = (pid_t)-1;\n\t\t/* goto spawn_cleanup; */\n\t}\n\nspawn_cleanup:\n\t(void)CloseHandle(si.hStdOutput);\n\t(void)CloseHandle(si.hStdError);\n\t(void)CloseHandle(si.hStdInput);\n\tif (pi.hThread != NULL) {\n\t\t(void)CloseHandle(pi.hThread);\n\t}\n\n\treturn (pid_t)pi.hProcess;\n}\n#endif /* !NO_CGI */\n\n\nstatic int\nset_blocking_mode(SOCKET sock)\n{\n\tunsigned long non_blocking = 0;\n\treturn ioctlsocket(sock, (long)FIONBIO, &non_blocking);\n}\n\nstatic int\nset_non_blocking_mode(SOCKET sock)\n{\n\tunsigned long non_blocking = 1;\n\treturn ioctlsocket(sock, (long)FIONBIO, &non_blocking);\n}\n\n#else\n\nstatic int\nmg_stat(const struct mg_connection *conn,\n        const char *path,\n        struct mg_file_stat *filep)\n{\n\tstruct stat st;\n\tif (!filep) {\n\t\treturn 0;\n\t}\n\tmemset(filep, 0, sizeof(*filep));\n\n\tif (conn && is_file_in_memory(conn, path)) {\n\n\t\t/* Quick fix (for 1.9.x): */\n\t\t/* mg_stat must fill all fields, also for files in memory */\n\t\tstruct mg_file tmp_file = STRUCT_FILE_INITIALIZER;\n\t\topen_file_in_memory(conn, path, &tmp_file, MG_FOPEN_MODE_NONE);\n\t\tfilep->size = tmp_file.stat.size;\n\t\tfilep->last_modified = time(NULL);\n\t\tfilep->location = 2;\n\t\t/* TODO: remove legacy \"files in memory\" feature */\n\n\t\treturn 1;\n\t}\n\n\tif (0 == stat(path, &st)) {\n\t\tfilep->size = (uint64_t)(st.st_size);\n\t\tfilep->last_modified = st.st_mtime;\n\t\tfilep->is_directory = S_ISDIR(st.st_mode);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nstatic void\nset_close_on_exec(SOCKET fd, struct mg_connection *conn /* may be null */)\n{\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC) != 0) {\n\t\tif (conn) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: fcntl(F_SETFD FD_CLOEXEC) failed: %s\",\n\t\t\t                __func__,\n\t\t\t                strerror(ERRNO));\n\t\t}\n\t}\n}\n\n\nint\nmg_start_thread(mg_thread_func_t func, void *param)\n{\n\tpthread_t thread_id;\n\tpthread_attr_t attr;\n\tint result;\n\n\t(void)pthread_attr_init(&attr);\n\t(void)pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n#if defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1)\n\t/* Compile-time option to control stack size,\n\t * e.g. -DUSE_STACK_SIZE=16384 */\n\t(void)pthread_attr_setstacksize(&attr, USE_STACK_SIZE);\n#endif /* defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1) */\n\n\tresult = pthread_create(&thread_id, &attr, func, param);\n\tpthread_attr_destroy(&attr);\n\n\treturn result;\n}\n\n\n/* Start a thread storing the thread context. */\nstatic int\nmg_start_thread_with_id(mg_thread_func_t func,\n                        void *param,\n                        pthread_t *threadidptr)\n{\n\tpthread_t thread_id;\n\tpthread_attr_t attr;\n\tint result;\n\n\t(void)pthread_attr_init(&attr);\n\n#if defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1)\n\t/* Compile-time option to control stack size,\n\t * e.g. -DUSE_STACK_SIZE=16384 */\n\t(void)pthread_attr_setstacksize(&attr, USE_STACK_SIZE);\n#endif /* defined(USE_STACK_SIZE) && USE_STACK_SIZE > 1 */\n\n\tresult = pthread_create(&thread_id, &attr, func, param);\n\tpthread_attr_destroy(&attr);\n\tif ((result == 0) && (threadidptr != NULL)) {\n\t\t*threadidptr = thread_id;\n\t}\n\treturn result;\n}\n\n\n/* Wait for a thread to finish. */\nstatic int\nmg_join_thread(pthread_t threadid)\n{\n\tint result;\n\n\tresult = pthread_join(threadid, NULL);\n\treturn result;\n}\n\n\n#if !defined(NO_CGI)\nstatic pid_t\nspawn_process(struct mg_connection *conn,\n              const char *prog,\n              char *envblk,\n              char *envp[],\n              int fdin[2],\n              int fdout[2],\n              int fderr[2],\n              const char *dir)\n{\n\tpid_t pid;\n\tconst char *interp;\n\n\t(void)envblk;\n\n\tif (conn == NULL) {\n\t\treturn 0;\n\t}\n\n\tif ((pid = fork()) == -1) {\n\t\t/* Parent */\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Creating CGI process\\nfork(): %s\",\n\t\t                   strerror(ERRNO));\n\t} else if (pid == 0) {\n\t\t/* Child */\n\t\tif (chdir(dir) != 0) {\n\t\t\tmg_cry_internal(\n\t\t\t    conn, \"%s: chdir(%s): %s\", __func__, dir, strerror(ERRNO));\n\t\t} else if (dup2(fdin[0], 0) == -1) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: dup2(%d, 0): %s\",\n\t\t\t                __func__,\n\t\t\t                fdin[0],\n\t\t\t                strerror(ERRNO));\n\t\t} else if (dup2(fdout[1], 1) == -1) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: dup2(%d, 1): %s\",\n\t\t\t                __func__,\n\t\t\t                fdout[1],\n\t\t\t                strerror(ERRNO));\n\t\t} else if (dup2(fderr[1], 2) == -1) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: dup2(%d, 2): %s\",\n\t\t\t                __func__,\n\t\t\t                fderr[1],\n\t\t\t                strerror(ERRNO));\n\t\t} else {\n\t\t\t/* Keep stderr and stdout in two different pipes.\n\t\t\t * Stdout will be sent back to the client,\n\t\t\t * stderr should go into a server error log. */\n\t\t\t(void)close(fdin[0]);\n\t\t\t(void)close(fdout[1]);\n\t\t\t(void)close(fderr[1]);\n\n\t\t\t/* Close write end fdin and read end fdout and fderr */\n\t\t\t(void)close(fdin[1]);\n\t\t\t(void)close(fdout[0]);\n\t\t\t(void)close(fderr[0]);\n\n\t\t\t/* After exec, all signal handlers are restored to their default\n\t\t\t * values, with one exception of SIGCHLD. According to\n\t\t\t * POSIX.1-2001 and Linux's implementation, SIGCHLD's handler\n\t\t\t * will leave unchanged after exec if it was set to be ignored.\n\t\t\t * Restore it to default action. */\n\t\t\tsignal(SIGCHLD, SIG_DFL);\n\n\t\t\tinterp = conn->dom_ctx->config[CGI_INTERPRETER];\n\t\t\tif (interp == NULL) {\n\t\t\t\t(void)execle(prog, prog, NULL, envp);\n\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t                \"%s: execle(%s): %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                prog,\n\t\t\t\t                strerror(ERRNO));\n\t\t\t} else {\n\t\t\t\t(void)execle(interp, interp, prog, NULL, envp);\n\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t                \"%s: execle(%s %s): %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                interp,\n\t\t\t\t                prog,\n\t\t\t\t                strerror(ERRNO));\n\t\t\t}\n\t\t}\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treturn pid;\n}\n#endif /* !NO_CGI */\n\n\nstatic int\nset_non_blocking_mode(SOCKET sock)\n{\n\tint flags = fcntl(sock, F_GETFL, 0);\n\tif (flags < 0) {\n\t\treturn -1;\n\t}\n\n\tif (fcntl(sock, F_SETFL, (flags | O_NONBLOCK)) < 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int\nset_blocking_mode(SOCKET sock)\n{\n\tint flags = fcntl(sock, F_GETFL, 0);\n\tif (flags < 0) {\n\t\treturn -1;\n\t}\n\n\tif (fcntl(sock, F_SETFL, flags & (~(int)(O_NONBLOCK))) < 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n#endif /* _WIN32 / else */\n\n/* End of initial operating system specific define block. */\n\n\n/* Get a random number (independent of C rand function) */\nstatic uint64_t\nget_random(void)\n{\n\tstatic uint64_t lfsr = 0; /* Linear feedback shift register */\n\tstatic uint64_t lcg = 0;  /* Linear congruential generator */\n\tuint64_t now = mg_get_current_time_ns();\n\n\tif (lfsr == 0) {\n\t\t/* lfsr will be only 0 if has not been initialized,\n\t\t * so this code is called only once. */\n\t\tlfsr = mg_get_current_time_ns();\n\t\tlcg = mg_get_current_time_ns();\n\t} else {\n\t\t/* Get the next step of both random number generators. */\n\t\tlfsr = (lfsr >> 1)\n\t\t       | ((((lfsr >> 0) ^ (lfsr >> 1) ^ (lfsr >> 3) ^ (lfsr >> 4)) & 1)\n\t\t          << 63);\n\t\tlcg = lcg * 6364136223846793005LL + 1442695040888963407LL;\n\t}\n\n\t/* Combining two pseudo-random number generators and a high resolution\n\t * part\n\t * of the current server time will make it hard (impossible?) to guess\n\t * the\n\t * next number. */\n\treturn (lfsr ^ lcg ^ now);\n}\n\n\nstatic int\nmg_poll(struct pollfd *pfd,\n        unsigned int n,\n        int milliseconds,\n        volatile int *stop_server)\n{\n\t/* Call poll, but only for a maximum time of a few seconds.\n\t * This will allow to stop the server after some seconds, instead\n\t * of having to wait for a long socket timeout. */\n\tint ms_now = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */\n\n\tdo {\n\t\tint result;\n\n\t\tif (*stop_server) {\n\t\t\t/* Shut down signal */\n\t\t\treturn -2;\n\t\t}\n\n\t\tif ((milliseconds >= 0) && (milliseconds < ms_now)) {\n\t\t\tms_now = milliseconds;\n\t\t}\n\n\t\tresult = poll(pfd, n, ms_now);\n\t\tif (result != 0) {\n\t\t\t/* Poll returned either success (1) or error (-1).\n\t\t\t * Forward both to the caller. */\n\t\t\treturn result;\n\t\t}\n\n\t\t/* Poll returned timeout (0). */\n\t\tif (milliseconds > 0) {\n\t\t\tmilliseconds -= ms_now;\n\t\t}\n\n\t} while (milliseconds != 0);\n\n\t/* timeout: return 0 */\n\treturn 0;\n}\n\n\n/* Write data to the IO channel - opened file descriptor, socket or SSL\n * descriptor.\n * Return value:\n *  >=0 .. number of bytes successfully written\n *   -1 .. timeout\n *   -2 .. error\n */\nstatic int\npush_inner(struct mg_context *ctx,\n           FILE *fp,\n           SOCKET sock,\n           SSL *ssl,\n           const char *buf,\n           int len,\n           double timeout)\n{\n\tuint64_t start = 0, now = 0, timeout_ns = 0;\n\tint n, err;\n\tunsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */\n\n#if defined(_WIN32)\n\ttypedef int len_t;\n#else\n\ttypedef size_t len_t;\n#endif\n\n\tif (timeout > 0) {\n\t\tnow = mg_get_current_time_ns();\n\t\tstart = now;\n\t\ttimeout_ns = (uint64_t)(timeout * 1.0E9);\n\t}\n\n\tif (ctx == NULL) {\n\t\treturn -2;\n\t}\n\n#if defined(NO_SSL)\n\tif (ssl) {\n\t\treturn -2;\n\t}\n#endif\n\n\t/* Try to read until it succeeds, fails, times out, or the server\n\t * shuts down. */\n\tfor (;;) {\n\n#if !defined(NO_SSL)\n\t\tif (ssl != NULL) {\n\t\t\tn = SSL_write(ssl, buf, len);\n\t\t\tif (n <= 0) {\n\t\t\t\terr = SSL_get_error(ssl, n);\n\t\t\t\tif ((err == SSL_ERROR_SYSCALL) && (n == -1)) {\n\t\t\t\t\terr = ERRNO;\n\t\t\t\t} else if ((err == SSL_ERROR_WANT_READ)\n\t\t\t\t           || (err == SSL_ERROR_WANT_WRITE)) {\n\t\t\t\t\tn = 0;\n\t\t\t\t} else {\n\t\t\t\t\tDEBUG_TRACE(\"SSL_write() failed, error %d\", err);\n\t\t\t\t\treturn -2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t} else\n#endif\n\t\t    if (fp != NULL) {\n\t\t\tn = (int)fwrite(buf, 1, (size_t)len, fp);\n\t\t\tif (ferror(fp)) {\n\t\t\t\tn = -1;\n\t\t\t\terr = ERRNO;\n\t\t\t} else {\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tn = (int)send(sock, buf, (len_t)len, MSG_NOSIGNAL);\n\t\t\terr = (n < 0) ? ERRNO : 0;\n#if defined(_WIN32)\n\t\t\tif (err == WSAEWOULDBLOCK) {\n\t\t\t\terr = 0;\n\t\t\t\tn = 0;\n\t\t\t}\n#else\n\t\t\tif (err == EWOULDBLOCK) {\n\t\t\t\terr = 0;\n\t\t\t\tn = 0;\n\t\t\t}\n#endif\n\t\t\tif (n < 0) {\n\t\t\t\t/* shutdown of the socket at client side */\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->stop_flag) {\n\t\t\treturn -2;\n\t\t}\n\n\t\tif ((n > 0) || ((n == 0) && (len == 0))) {\n\t\t\t/* some data has been read, or no data was requested */\n\t\t\treturn n;\n\t\t}\n\t\tif (n < 0) {\n\t\t\t/* socket error - check errno */\n\t\t\tDEBUG_TRACE(\"send() failed, error %d\", err);\n\n\t\t\t/* TODO (mid): error handling depending on the error code.\n\t\t\t * These codes are different between Windows and Linux.\n\t\t\t * Currently there is no problem with failing send calls,\n\t\t\t * if there is a reproducible situation, it should be\n\t\t\t * investigated in detail.\n\t\t\t */\n\t\t\treturn -2;\n\t\t}\n\n\t\t/* Only in case n=0 (timeout), repeat calling the write function */\n\n\t\t/* If send failed, wait before retry */\n\t\tif (fp != NULL) {\n\t\t\t/* For files, just wait a fixed time.\n\t\t\t * Maybe it helps, maybe not. */\n\t\t\tmg_sleep(5);\n\t\t} else {\n\t\t\t/* For sockets, wait for the socket using poll */\n\t\t\tstruct pollfd pfd[1];\n\t\t\tint pollres;\n\n\t\t\tpfd[0].fd = sock;\n\t\t\tpfd[0].events = POLLOUT;\n\t\t\tpollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));\n\t\t\tif (ctx->stop_flag) {\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t\tif (pollres > 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (timeout > 0) {\n\t\t\tnow = mg_get_current_time_ns();\n\t\t\tif ((now - start) > timeout_ns) {\n\t\t\t\t/* Timeout */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t(void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not\n\t              used */\n\n\treturn -1;\n}\n\n\nstatic int64_t\npush_all(struct mg_context *ctx,\n         FILE *fp,\n         SOCKET sock,\n         SSL *ssl,\n         const char *buf,\n         int64_t len)\n{\n\tdouble timeout = -1.0;\n\tint64_t n, nwritten = 0;\n\n\tif (ctx == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (ctx->dd.config[REQUEST_TIMEOUT]) {\n\t\ttimeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;\n\t}\n\n\twhile ((len > 0) && (ctx->stop_flag == 0)) {\n\t\tn = push_inner(ctx, fp, sock, ssl, buf + nwritten, (int)len, timeout);\n\t\tif (n < 0) {\n\t\t\tif (nwritten == 0) {\n\t\t\t\tnwritten = n; /* Propagate the error */\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (n == 0) {\n\t\t\tbreak; /* No more data to write */\n\t\t} else {\n\t\t\tnwritten += n;\n\t\t\tlen -= n;\n\t\t}\n\t}\n\n\treturn nwritten;\n}\n\n\n/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.\n * Return value:\n *  >=0 .. number of bytes successfully read\n *   -1 .. timeout\n *   -2 .. error\n */\nstatic int\npull_inner(FILE *fp,\n           struct mg_connection *conn,\n           char *buf,\n           int len,\n           double timeout)\n{\n\tint nread, err = 0;\n\n#if defined(_WIN32)\n\ttypedef int len_t;\n#else\n\ttypedef size_t len_t;\n#endif\n#if !defined(NO_SSL)\n\tint ssl_pending;\n#endif\n\n\t/* We need an additional wait loop around this, because in some cases\n\t * with TLSwe may get data from the socket but not from SSL_read.\n\t * In this case we need to repeat at least once.\n\t */\n\n\tif (fp != NULL) {\n#if !defined(_WIN32_WCE)\n\t\t/* Use read() instead of fread(), because if we're reading from the\n\t\t * CGI pipe, fread() may block until IO buffer is filled up. We\n\t\t * cannot afford to block and must pass all read bytes immediately\n\t\t * to the client. */\n\t\tnread = (int)read(fileno(fp), buf, (size_t)len);\n#else\n\t\t/* WinCE does not support CGI pipes */\n\t\tnread = (int)fread(buf, 1, (size_t)len, fp);\n#endif\n\t\terr = (nread < 0) ? ERRNO : 0;\n\t\tif ((nread == 0) && (len > 0)) {\n\t\t\t/* Should get data, but got EOL */\n\t\t\treturn -2;\n\t\t}\n\n#if !defined(NO_SSL)\n\t} else if ((conn->ssl != NULL)\n\t           && ((ssl_pending = SSL_pending(conn->ssl)) > 0)) {\n\t\t/* We already know there is no more data buffered in conn->buf\n\t\t * but there is more available in the SSL layer. So don't poll\n\t\t * conn->client.sock yet. */\n\t\tif (ssl_pending > len) {\n\t\t\tssl_pending = len;\n\t\t}\n\t\tnread = SSL_read(conn->ssl, buf, ssl_pending);\n\t\tif (nread <= 0) {\n\t\t\terr = SSL_get_error(conn->ssl, nread);\n\t\t\tif ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {\n\t\t\t\terr = ERRNO;\n\t\t\t} else if ((err == SSL_ERROR_WANT_READ)\n\t\t\t           || (err == SSL_ERROR_WANT_WRITE)) {\n\t\t\t\tnread = 0;\n\t\t\t} else {\n\t\t\t\tDEBUG_TRACE(\"SSL_read() failed, error %d\", err);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\terr = 0;\n\t\t}\n\n\t} else if (conn->ssl != NULL) {\n\n\t\tstruct pollfd pfd[1];\n\t\tint pollres;\n\n\t\tpfd[0].fd = conn->client.sock;\n\t\tpfd[0].events = POLLIN;\n\t\tpollres = mg_poll(pfd,\n\t\t                  1,\n\t\t                  (int)(timeout * 1000.0),\n\t\t                  &(conn->phys_ctx->stop_flag));\n\t\tif (conn->phys_ctx->stop_flag) {\n\t\t\treturn -2;\n\t\t}\n\t\tif (pollres > 0) {\n\t\t\tnread = SSL_read(conn->ssl, buf, len);\n\t\t\tif (nread <= 0) {\n\t\t\t\terr = SSL_get_error(conn->ssl, nread);\n\t\t\t\tif ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {\n\t\t\t\t\terr = ERRNO;\n\t\t\t\t} else if ((err == SSL_ERROR_WANT_READ)\n\t\t\t\t           || (err == SSL_ERROR_WANT_WRITE)) {\n\t\t\t\t\tnread = 0;\n\t\t\t\t} else {\n\t\t\t\t\tDEBUG_TRACE(\"SSL_read() failed, error %d\", err);\n\t\t\t\t\treturn -2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = 0;\n\t\t\t}\n\n\t\t} else if (pollres < 0) {\n\t\t\t/* Error */\n\t\t\treturn -2;\n\t\t} else {\n\t\t\t/* pollres = 0 means timeout */\n\t\t\tnread = 0;\n\t\t}\n#endif\n\n\t} else {\n\t\tstruct pollfd pfd[1];\n\t\tint pollres;\n\n\t\tpfd[0].fd = conn->client.sock;\n\t\tpfd[0].events = POLLIN;\n\t\tpollres = mg_poll(pfd,\n\t\t                  1,\n\t\t                  (int)(timeout * 1000.0),\n\t\t                  &(conn->phys_ctx->stop_flag));\n\t\tif (conn->phys_ctx->stop_flag) {\n\t\t\treturn -2;\n\t\t}\n\t\tif (pollres > 0) {\n\t\t\tnread = (int)recv(conn->client.sock, buf, (len_t)len, 0);\n\t\t\terr = (nread < 0) ? ERRNO : 0;\n\t\t\tif (nread <= 0) {\n\t\t\t\t/* shutdown of the socket at client side */\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t} else if (pollres < 0) {\n\t\t\t/* error callint poll */\n\t\t\treturn -2;\n\t\t} else {\n\t\t\t/* pollres = 0 means timeout */\n\t\t\tnread = 0;\n\t\t}\n\t}\n\n\tif (conn->phys_ctx->stop_flag) {\n\t\treturn -2;\n\t}\n\n\tif ((nread > 0) || ((nread == 0) && (len == 0))) {\n\t\t/* some data has been read, or no data was requested */\n\t\treturn nread;\n\t}\n\n\tif (nread < 0) {\n/* socket error - check errno */\n#if defined(_WIN32)\n\t\tif (err == WSAEWOULDBLOCK) {\n\t\t\t/* TODO (low): check if this is still required */\n\t\t\t/* standard case if called from close_socket_gracefully */\n\t\t\treturn -2;\n\t\t} else if (err == WSAETIMEDOUT) {\n\t\t\t/* TODO (low): check if this is still required */\n\t\t\t/* timeout is handled by the while loop  */\n\t\t\treturn 0;\n\t\t} else if (err == WSAECONNABORTED) {\n\t\t\t/* See https://www.chilkatsoft.com/p/p_299.asp */\n\t\t\treturn -2;\n\t\t} else {\n\t\t\tDEBUG_TRACE(\"recv() failed, error %d\", err);\n\t\t\treturn -2;\n\t\t}\n#else\n\t\t/* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,\n\t\t * if the timeout is reached and if the socket was set to non-\n\t\t * blocking in close_socket_gracefully, so we can not distinguish\n\t\t * here. We have to wait for the timeout in both cases for now.\n\t\t */\n\t\tif ((err == EAGAIN) || (err == EWOULDBLOCK) || (err == EINTR)) {\n\t\t\t/* TODO (low): check if this is still required */\n\t\t\t/* EAGAIN/EWOULDBLOCK:\n\t\t\t * standard case if called from close_socket_gracefully\n\t\t\t * => should return -1 */\n\t\t\t/* or timeout occurred\n\t\t\t * => the code must stay in the while loop */\n\n\t\t\t/* EINTR can be generated on a socket with a timeout set even\n\t\t\t * when SA_RESTART is effective for all relevant signals\n\t\t\t * (see signal(7)).\n\t\t\t * => stay in the while loop */\n\t\t} else {\n\t\t\tDEBUG_TRACE(\"recv() failed, error %d\", err);\n\t\t\treturn -2;\n\t\t}\n#endif\n\t}\n\n\t/* Timeout occurred, but no data available. */\n\treturn -1;\n}\n\n\nstatic int\npull_all(FILE *fp, struct mg_connection *conn, char *buf, int len)\n{\n\tint n, nread = 0;\n\tdouble timeout = -1.0;\n\tuint64_t start_time = 0, now = 0, timeout_ns = 0;\n\n\tif (conn->dom_ctx->config[REQUEST_TIMEOUT]) {\n\t\ttimeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;\n\t}\n\tif (timeout >= 0.0) {\n\t\tstart_time = mg_get_current_time_ns();\n\t\ttimeout_ns = (uint64_t)(timeout * 1.0E9);\n\t}\n\n\twhile ((len > 0) && (conn->phys_ctx->stop_flag == 0)) {\n\t\tn = pull_inner(fp, conn, buf + nread, len, timeout);\n\t\tif (n == -2) {\n\t\t\tif (nread == 0) {\n\t\t\t\tnread = -1; /* Propagate the error */\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (n == -1) {\n\t\t\t/* timeout */\n\t\t\tif (timeout >= 0.0) {\n\t\t\t\tnow = mg_get_current_time_ns();\n\t\t\t\tif ((now - start_time) <= timeout_ns) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (n == 0) {\n\t\t\tbreak; /* No more data to read */\n\t\t} else {\n\t\t\tconn->consumed_content += n;\n\t\t\tnread += n;\n\t\t\tlen -= n;\n\t\t}\n\t}\n\n\treturn nread;\n}\n\n\nstatic void\ndiscard_unread_request_data(struct mg_connection *conn)\n{\n\tchar buf[MG_BUF_LEN];\n\tsize_t to_read;\n\tint nread;\n\n\tif (conn == NULL) {\n\t\treturn;\n\t}\n\n\tto_read = sizeof(buf);\n\n\tif (conn->is_chunked) {\n\t\t/* Chunked encoding: 3=chunk read completely\n\t\t * completely */\n\t\twhile (conn->is_chunked != 3) {\n\t\t\tnread = mg_read(conn, buf, to_read);\n\t\t\tif (nread <= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t/* Not chunked: content length is known */\n\t\twhile (conn->consumed_content < conn->content_len) {\n\t\t\tif (to_read\n\t\t\t    > (size_t)(conn->content_len - conn->consumed_content)) {\n\t\t\t\tto_read = (size_t)(conn->content_len - conn->consumed_content);\n\t\t\t}\n\n\t\t\tnread = mg_read(conn, buf, to_read);\n\t\t\tif (nread <= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic int\nmg_read_inner(struct mg_connection *conn, void *buf, size_t len)\n{\n\tint64_t n, buffered_len, nread;\n\tint64_t len64 =\n\t    (int64_t)((len > INT_MAX) ? INT_MAX : len); /* since the return value is\n\t                                                 * int, we may not read more\n\t                                                 * bytes */\n\tconst char *body;\n\n\tif (conn == NULL) {\n\t\treturn 0;\n\t}\n\n\t/* If Content-Length is not set for a request with body data\n\t * (e.g., a PUT or POST request), we do not know in advance\n\t * how much data should be read. */\n\tif (conn->consumed_content == 0) {\n\t\tif (conn->is_chunked == 1) {\n\t\t\tconn->content_len = len64;\n\t\t\tconn->is_chunked = 2;\n\t\t} else if (conn->content_len == -1) {\n\t\t\t/* The body data is completed when the connection\n\t\t\t * is closed. */\n\t\t\tconn->content_len = INT64_MAX;\n\t\t\tconn->must_close = 1;\n\t\t}\n\t}\n\n\tnread = 0;\n\tif (conn->consumed_content < conn->content_len) {\n\t\t/* Adjust number of bytes to read. */\n\t\tint64_t left_to_read = conn->content_len - conn->consumed_content;\n\t\tif (left_to_read < len64) {\n\t\t\t/* Do not read more than the total content length of the\n\t\t\t * request.\n\t\t\t */\n\t\t\tlen64 = left_to_read;\n\t\t}\n\n\t\t/* Return buffered data */\n\t\tbuffered_len = (int64_t)(conn->data_len) - (int64_t)conn->request_len\n\t\t               - conn->consumed_content;\n\t\tif (buffered_len > 0) {\n\t\t\tif (len64 < buffered_len) {\n\t\t\t\tbuffered_len = len64;\n\t\t\t}\n\t\t\tbody = conn->buf + conn->request_len + conn->consumed_content;\n\t\t\tmemcpy(buf, body, (size_t)buffered_len);\n\t\t\tlen64 -= buffered_len;\n\t\t\tconn->consumed_content += buffered_len;\n\t\t\tnread += buffered_len;\n\t\t\tbuf = (char *)buf + buffered_len;\n\t\t}\n\n\t\t/* We have returned all buffered data. Read new data from the remote\n\t\t * socket.\n\t\t */\n\t\tif ((n = pull_all(NULL, conn, (char *)buf, (int)len64)) >= 0) {\n\t\t\tnread += n;\n\t\t} else {\n\t\t\tnread = ((nread > 0) ? nread : n);\n\t\t}\n\t}\n\treturn (int)nread;\n}\n\n\nstatic char\nmg_getc(struct mg_connection *conn)\n{\n\tchar c;\n\tif (conn == NULL) {\n\t\treturn 0;\n\t}\n\tif (mg_read_inner(conn, &c, 1) <= 0) {\n\t\treturn (char)0;\n\t}\n\treturn c;\n}\n\n\nint\nmg_read(struct mg_connection *conn, void *buf, size_t len)\n{\n\tif (len > INT_MAX) {\n\t\tlen = INT_MAX;\n\t}\n\n\tif (conn == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (conn->is_chunked) {\n\t\tsize_t all_read = 0;\n\n\t\twhile (len > 0) {\n\t\t\tif (conn->is_chunked == 3) {\n\t\t\t\t/* No more data left to read */\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (conn->chunk_remainder) {\n\t\t\t\t/* copy from the remainder of the last received chunk */\n\t\t\t\tlong read_ret;\n\t\t\t\tsize_t read_now =\n\t\t\t\t    ((conn->chunk_remainder > len) ? (len)\n\t\t\t\t                                   : (conn->chunk_remainder));\n\n\t\t\t\tconn->content_len += (int)read_now;\n\t\t\t\tread_ret =\n\t\t\t\t    mg_read_inner(conn, (char *)buf + all_read, read_now);\n\n\t\t\t\tif (read_ret < 1) {\n\t\t\t\t\t/* read error */\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tall_read += (size_t)read_ret;\n\t\t\t\tconn->chunk_remainder -= (size_t)read_ret;\n\t\t\t\tlen -= (size_t)read_ret;\n\n\t\t\t\tif (conn->chunk_remainder == 0) {\n\t\t\t\t\t/* Add data bytes in the current chunk have been read,\n\t\t\t\t\t * so we are expecting \\r\\n now. */\n\t\t\t\t\tchar x1, x2;\n\t\t\t\t\tconn->content_len += 2;\n\t\t\t\t\tx1 = mg_getc(conn);\n\t\t\t\t\tx2 = mg_getc(conn);\n\t\t\t\t\tif ((x1 != '\\r') || (x2 != '\\n')) {\n\t\t\t\t\t\t/* Protocol violation */\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* fetch a new chunk */\n\t\t\t\tint i = 0;\n\t\t\t\tchar lenbuf[64];\n\t\t\t\tchar *end = 0;\n\t\t\t\tunsigned long chunkSize = 0;\n\n\t\t\t\tfor (i = 0; i < ((int)sizeof(lenbuf) - 1); i++) {\n\t\t\t\t\tconn->content_len++;\n\t\t\t\t\tlenbuf[i] = mg_getc(conn);\n\t\t\t\t\tif ((i > 0) && (lenbuf[i] == '\\r')\n\t\t\t\t\t    && (lenbuf[i - 1] != '\\r')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif ((i > 1) && (lenbuf[i] == '\\n')\n\t\t\t\t\t    && (lenbuf[i - 1] == '\\r')) {\n\t\t\t\t\t\tlenbuf[i + 1] = 0;\n\t\t\t\t\t\tchunkSize = strtoul(lenbuf, &end, 16);\n\t\t\t\t\t\tif (chunkSize == 0) {\n\t\t\t\t\t\t\t/* regular end of content */\n\t\t\t\t\t\t\tconn->is_chunked = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!isxdigit(lenbuf[i])) {\n\t\t\t\t\t\t/* illegal character for chunk length */\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((end == NULL) || (*end != '\\r')) {\n\t\t\t\t\t/* chunksize not set correctly */\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (chunkSize == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconn->chunk_remainder = chunkSize;\n\t\t\t}\n\t\t}\n\n\t\treturn (int)all_read;\n\t}\n\treturn mg_read_inner(conn, buf, len);\n}\n\n\nint\nmg_write(struct mg_connection *conn, const void *buf, size_t len)\n{\n\ttime_t now;\n\tint64_t n, total, allowed;\n\n\tif (conn == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (conn->throttle > 0) {\n\t\tif ((now = time(NULL)) != conn->last_throttle_time) {\n\t\t\tconn->last_throttle_time = now;\n\t\t\tconn->last_throttle_bytes = 0;\n\t\t}\n\t\tallowed = conn->throttle - conn->last_throttle_bytes;\n\t\tif (allowed > (int64_t)len) {\n\t\t\tallowed = (int64_t)len;\n\t\t}\n\t\tif ((total = push_all(conn->phys_ctx,\n\t\t                      NULL,\n\t\t                      conn->client.sock,\n\t\t                      conn->ssl,\n\t\t                      (const char *)buf,\n\t\t                      (int64_t)allowed))\n\t\t    == allowed) {\n\t\t\tbuf = (const char *)buf + total;\n\t\t\tconn->last_throttle_bytes += total;\n\t\t\twhile ((total < (int64_t)len) && (conn->phys_ctx->stop_flag == 0)) {\n\t\t\t\tallowed = (conn->throttle > ((int64_t)len - total))\n\t\t\t\t              ? (int64_t)len - total\n\t\t\t\t              : conn->throttle;\n\t\t\t\tif ((n = push_all(conn->phys_ctx,\n\t\t\t\t                  NULL,\n\t\t\t\t                  conn->client.sock,\n\t\t\t\t                  conn->ssl,\n\t\t\t\t                  (const char *)buf,\n\t\t\t\t                  (int64_t)allowed))\n\t\t\t\t    != allowed) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsleep(1);\n\t\t\t\tconn->last_throttle_bytes = allowed;\n\t\t\t\tconn->last_throttle_time = time(NULL);\n\t\t\t\tbuf = (const char *)buf + n;\n\t\t\t\ttotal += n;\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttotal = push_all(conn->phys_ctx,\n\t\t                 NULL,\n\t\t                 conn->client.sock,\n\t\t                 conn->ssl,\n\t\t                 (const char *)buf,\n\t\t                 (int64_t)len);\n\t}\n\tif (total > 0) {\n\t\tconn->num_bytes_sent += total;\n\t}\n\treturn (int)total;\n}\n\n\n/* Send a chunk, if \"Transfer-Encoding: chunked\" is used */\nint\nmg_send_chunk(struct mg_connection *conn,\n              const char *chunk,\n              unsigned int chunk_len)\n{\n\tchar lenbuf[16];\n\tsize_t lenbuf_len;\n\tint ret;\n\tint t;\n\n\t/* First store the length information in a text buffer. */\n\tsprintf(lenbuf, \"%x\\r\\n\", chunk_len);\n\tlenbuf_len = strlen(lenbuf);\n\n\t/* Then send length information, chunk and terminating \\r\\n. */\n\tret = mg_write(conn, lenbuf, lenbuf_len);\n\tif (ret != (int)lenbuf_len) {\n\t\treturn -1;\n\t}\n\tt = ret;\n\n\tret = mg_write(conn, chunk, chunk_len);\n\tif (ret != (int)chunk_len) {\n\t\treturn -1;\n\t}\n\tt += ret;\n\n\tret = mg_write(conn, \"\\r\\n\", 2);\n\tif (ret != 2) {\n\t\treturn -1;\n\t}\n\tt += ret;\n\n\treturn t;\n}\n\n\n#if defined(GCC_DIAGNOSTIC)\n/* This block forwards format strings to printf implementations,\n * so we need to disable the format-nonliteral warning. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n#endif\n\n\n/* Alternative alloc_vprintf() for non-compliant C runtimes */\nstatic int\nalloc_vprintf2(char **buf, const char *fmt, va_list ap)\n{\n\tva_list ap_copy;\n\tsize_t size = MG_BUF_LEN / 4;\n\tint len = -1;\n\n\t*buf = NULL;\n\twhile (len < 0) {\n\t\tif (*buf) {\n\t\t\tmg_free(*buf);\n\t\t}\n\n\t\tsize *= 4;\n\t\t*buf = (char *)mg_malloc(size);\n\t\tif (!*buf) {\n\t\t\tbreak;\n\t\t}\n\n\t\tva_copy(ap_copy, ap);\n\t\tlen = vsnprintf_impl(*buf, size - 1, fmt, ap_copy);\n\t\tva_end(ap_copy);\n\t\t(*buf)[size - 1] = 0;\n\t}\n\n\treturn len;\n}\n\n\n/* Print message to buffer. If buffer is large enough to hold the message,\n * return buffer. If buffer is to small, allocate large enough buffer on\n * heap,\n * and return allocated buffer. */\nstatic int\nalloc_vprintf(char **out_buf,\n              char *prealloc_buf,\n              size_t prealloc_size,\n              const char *fmt,\n              va_list ap)\n{\n\tva_list ap_copy;\n\tint len;\n\n\t/* Windows is not standard-compliant, and vsnprintf() returns -1 if\n\t * buffer is too small. Also, older versions of msvcrt.dll do not have\n\t * _vscprintf().  However, if size is 0, vsnprintf() behaves correctly.\n\t * Therefore, we make two passes: on first pass, get required message\n\t * length.\n\t * On second pass, actually print the message. */\n\tva_copy(ap_copy, ap);\n\tlen = vsnprintf_impl(NULL, 0, fmt, ap_copy);\n\tva_end(ap_copy);\n\n\tif (len < 0) {\n\t\t/* C runtime is not standard compliant, vsnprintf() returned -1.\n\t\t * Switch to alternative code path that uses incremental\n\t\t * allocations.\n\t\t */\n\t\tva_copy(ap_copy, ap);\n\t\tlen = alloc_vprintf2(out_buf, fmt, ap_copy);\n\t\tva_end(ap_copy);\n\n\t} else if ((size_t)(len) >= prealloc_size) {\n\t\t/* The pre-allocated buffer not large enough. */\n\t\t/* Allocate a new buffer. */\n\t\t*out_buf = (char *)mg_malloc((size_t)(len) + 1);\n\t\tif (!*out_buf) {\n\t\t\t/* Allocation failed. Return -1 as \"out of memory\" error. */\n\t\t\treturn -1;\n\t\t}\n\t\t/* Buffer allocation successful. Store the string there. */\n\t\tva_copy(ap_copy, ap);\n\t\tIGNORE_UNUSED_RESULT(\n\t\t    vsnprintf_impl(*out_buf, (size_t)(len) + 1, fmt, ap_copy));\n\t\tva_end(ap_copy);\n\n\t} else {\n\t\t/* The pre-allocated buffer is large enough.\n\t\t * Use it to store the string and return the address. */\n\t\tva_copy(ap_copy, ap);\n\t\tIGNORE_UNUSED_RESULT(\n\t\t    vsnprintf_impl(prealloc_buf, prealloc_size, fmt, ap_copy));\n\t\tva_end(ap_copy);\n\t\t*out_buf = prealloc_buf;\n\t}\n\n\treturn len;\n}\n\n\n#if defined(GCC_DIAGNOSTIC)\n/* Enable format-nonliteral warning again. */\n#pragma GCC diagnostic pop\n#endif\n\n\nstatic int\nmg_vprintf(struct mg_connection *conn, const char *fmt, va_list ap)\n{\n\tchar mem[MG_BUF_LEN];\n\tchar *buf = NULL;\n\tint len;\n\n\tif ((len = alloc_vprintf(&buf, mem, sizeof(mem), fmt, ap)) > 0) {\n\t\tlen = mg_write(conn, buf, (size_t)len);\n\t}\n\tif ((buf != mem) && (buf != NULL)) {\n\t\tmg_free(buf);\n\t}\n\n\treturn len;\n}\n\n\nint\nmg_printf(struct mg_connection *conn, const char *fmt, ...)\n{\n\tva_list ap;\n\tint result;\n\n\tva_start(ap, fmt);\n\tresult = mg_vprintf(conn, fmt, ap);\n\tva_end(ap);\n\n\treturn result;\n}\n\n\nint\nmg_url_decode(const char *src,\n              int src_len,\n              char *dst,\n              int dst_len,\n              int is_form_url_encoded)\n{\n\tint i, j, a, b;\n#define HEXTOI(x) (isdigit(x) ? (x - '0') : (x - 'W'))\n\n\tfor (i = j = 0; (i < src_len) && (j < (dst_len - 1)); i++, j++) {\n\t\tif ((i < src_len - 2) && (src[i] == '%')\n\t\t    && isxdigit(*(const unsigned char *)(src + i + 1))\n\t\t    && isxdigit(*(const unsigned char *)(src + i + 2))) {\n\t\t\ta = tolower(*(const unsigned char *)(src + i + 1));\n\t\t\tb = tolower(*(const unsigned char *)(src + i + 2));\n\t\t\tdst[j] = (char)((HEXTOI(a) << 4) | HEXTOI(b));\n\t\t\ti += 2;\n\t\t} else if (is_form_url_encoded && (src[i] == '+')) {\n\t\t\tdst[j] = ' ';\n\t\t} else {\n\t\t\tdst[j] = src[i];\n\t\t}\n\t}\n\n\tdst[j] = '\\0'; /* Null-terminate the destination */\n\n\treturn (i >= src_len) ? j : -1;\n}\n\n\nint\nmg_get_var(const char *data,\n           size_t data_len,\n           const char *name,\n           char *dst,\n           size_t dst_len)\n{\n\treturn mg_get_var2(data, data_len, name, dst, dst_len, 0);\n}\n\n\nint\nmg_get_var2(const char *data,\n            size_t data_len,\n            const char *name,\n            char *dst,\n            size_t dst_len,\n            size_t occurrence)\n{\n\tconst char *p, *e, *s;\n\tsize_t name_len;\n\tint len;\n\n\tif ((dst == NULL) || (dst_len == 0)) {\n\t\tlen = -2;\n\t} else if ((data == NULL) || (name == NULL) || (data_len == 0)) {\n\t\tlen = -1;\n\t\tdst[0] = '\\0';\n\t} else {\n\t\tname_len = strlen(name);\n\t\te = data + data_len;\n\t\tlen = -1;\n\t\tdst[0] = '\\0';\n\n\t\t/* data is \"var1=val1&var2=val2...\". Find variable first */\n\t\tfor (p = data; p + name_len < e; p++) {\n\t\t\tif (((p == data) || (p[-1] == '&')) && (p[name_len] == '=')\n\t\t\t    && !mg_strncasecmp(name, p, name_len) && 0 == occurrence--) {\n\t\t\t\t/* Point p to variable value */\n\t\t\t\tp += name_len + 1;\n\n\t\t\t\t/* Point s to the end of the value */\n\t\t\t\ts = (const char *)memchr(p, '&', (size_t)(e - p));\n\t\t\t\tif (s == NULL) {\n\t\t\t\t\ts = e;\n\t\t\t\t}\n\t\t\t\tDEBUG_ASSERT(s >= p);\n\t\t\t\tif (s < p) {\n\t\t\t\t\treturn -3;\n\t\t\t\t}\n\n\t\t\t\t/* Decode variable into destination buffer */\n\t\t\t\tlen = mg_url_decode(p, (int)(s - p), dst, (int)dst_len, 1);\n\n\t\t\t\t/* Redirect error code from -1 to -2 (destination buffer too\n\t\t\t\t * small). */\n\t\t\t\tif (len == -1) {\n\t\t\t\t\tlen = -2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn len;\n}\n\n\n/* HCP24: some changes to compare hole var_name */\nint\nmg_get_cookie(const char *cookie_header,\n              const char *var_name,\n              char *dst,\n              size_t dst_size)\n{\n\tconst char *s, *p, *end;\n\tint name_len, len = -1;\n\n\tif ((dst == NULL) || (dst_size == 0)) {\n\t\treturn -2;\n\t}\n\n\tdst[0] = '\\0';\n\tif ((var_name == NULL) || ((s = cookie_header) == NULL)) {\n\t\treturn -1;\n\t}\n\n\tname_len = (int)strlen(var_name);\n\tend = s + strlen(s);\n\tfor (; (s = mg_strcasestr(s, var_name)) != NULL; s += name_len) {\n\t\tif (s[name_len] == '=') {\n\t\t\t/* HCP24: now check is it a substring or a full cookie name */\n\t\t\tif ((s == cookie_header) || (s[-1] == ' ')) {\n\t\t\t\ts += name_len + 1;\n\t\t\t\tif ((p = strchr(s, ' ')) == NULL) {\n\t\t\t\t\tp = end;\n\t\t\t\t}\n\t\t\t\tif (p[-1] == ';') {\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t\tif ((*s == '\"') && (p[-1] == '\"') && (p > s + 1)) {\n\t\t\t\t\ts++;\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t\tif ((size_t)(p - s) < dst_size) {\n\t\t\t\t\tlen = (int)(p - s);\n\t\t\t\t\tmg_strlcpy(dst, s, (size_t)len + 1);\n\t\t\t\t} else {\n\t\t\t\t\tlen = -3;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn len;\n}\n\n\n#if defined(USE_WEBSOCKET) || defined(USE_LUA)\nstatic void\nbase64_encode(const unsigned char *src, int src_len, char *dst)\n{\n\tstatic const char *b64 =\n\t    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\tint i, j, a, b, c;\n\n\tfor (i = j = 0; i < src_len; i += 3) {\n\t\ta = src[i];\n\t\tb = ((i + 1) >= src_len) ? 0 : src[i + 1];\n\t\tc = ((i + 2) >= src_len) ? 0 : src[i + 2];\n\n\t\tdst[j++] = b64[a >> 2];\n\t\tdst[j++] = b64[((a & 3) << 4) | (b >> 4)];\n\t\tif (i + 1 < src_len) {\n\t\t\tdst[j++] = b64[(b & 15) << 2 | (c >> 6)];\n\t\t}\n\t\tif (i + 2 < src_len) {\n\t\t\tdst[j++] = b64[c & 63];\n\t\t}\n\t}\n\twhile (j % 4 != 0) {\n\t\tdst[j++] = '=';\n\t}\n\tdst[j++] = '\\0';\n}\n#endif\n\n\n#if defined(USE_LUA)\nstatic unsigned char\nb64reverse(char letter)\n{\n\tif ((letter >= 'A') && (letter <= 'Z')) {\n\t\treturn letter - 'A';\n\t}\n\tif ((letter >= 'a') && (letter <= 'z')) {\n\t\treturn letter - 'a' + 26;\n\t}\n\tif ((letter >= '0') && (letter <= '9')) {\n\t\treturn letter - '0' + 52;\n\t}\n\tif (letter == '+') {\n\t\treturn 62;\n\t}\n\tif (letter == '/') {\n\t\treturn 63;\n\t}\n\tif (letter == '=') {\n\t\treturn 255; /* normal end */\n\t}\n\treturn 254; /* error */\n}\n\n\nstatic int\nbase64_decode(const unsigned char *src, int src_len, char *dst, size_t *dst_len)\n{\n\tint i;\n\tunsigned char a, b, c, d;\n\n\t*dst_len = 0;\n\n\tfor (i = 0; i < src_len; i += 4) {\n\t\ta = b64reverse(src[i]);\n\t\tif (a >= 254) {\n\t\t\treturn i;\n\t\t}\n\n\t\tb = b64reverse(((i + 1) >= src_len) ? 0 : src[i + 1]);\n\t\tif (b >= 254) {\n\t\t\treturn i + 1;\n\t\t}\n\n\t\tc = b64reverse(((i + 2) >= src_len) ? 0 : src[i + 2]);\n\t\tif (c == 254) {\n\t\t\treturn i + 2;\n\t\t}\n\n\t\td = b64reverse(((i + 3) >= src_len) ? 0 : src[i + 3]);\n\t\tif (d == 254) {\n\t\t\treturn i + 3;\n\t\t}\n\n\t\tdst[(*dst_len)++] = (a << 2) + (b >> 4);\n\t\tif (c != 255) {\n\t\t\tdst[(*dst_len)++] = (b << 4) + (c >> 2);\n\t\t\tif (d != 255) {\n\t\t\t\tdst[(*dst_len)++] = (c << 6) + d;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n#endif\n\n\nstatic int\nis_put_or_delete_method(const struct mg_connection *conn)\n{\n\tif (conn) {\n\t\tconst char *s = conn->request_info.request_method;\n\t\treturn (s != NULL)\n\t\t       && (!strcmp(s, \"PUT\") || !strcmp(s, \"DELETE\")\n\t\t           || !strcmp(s, \"MKCOL\") || !strcmp(s, \"PATCH\"));\n\t}\n\treturn 0;\n}\n\n\n#if !defined(NO_FILES)\nstatic int\nextention_matches_script(\n    struct mg_connection *conn, /* in: request (must be valid) */\n    const char *filename        /* in: filename  (must be valid) */\n)\n{\n#if !defined(NO_CGI)\n\tif (match_prefix(conn->dom_ctx->config[CGI_EXTENSIONS],\n\t                 strlen(conn->dom_ctx->config[CGI_EXTENSIONS]),\n\t                 filename)\n\t    > 0) {\n\t\treturn 1;\n\t}\n#endif\n#if defined(USE_LUA)\n\tif (match_prefix(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS],\n\t                 strlen(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS]),\n\t                 filename)\n\t    > 0) {\n\t\treturn 1;\n\t}\n#endif\n#if defined(USE_DUKTAPE)\n\tif (match_prefix(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],\n\t                 strlen(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS]),\n\t                 filename)\n\t    > 0) {\n\t\treturn 1;\n\t}\n#endif\n\t/* filename and conn could be unused, if all preocessor conditions\n\t * are false (no script language supported). */\n\t(void)filename;\n\t(void)conn;\n\n\treturn 0;\n}\n\n\n/* For given directory path, substitute it to valid index file.\n * Return 1 if index file has been found, 0 if not found.\n * If the file is found, it's stats is returned in stp. */\nstatic int\nsubstitute_index_file(struct mg_connection *conn,\n                      char *path,\n                      size_t path_len,\n                      struct mg_file_stat *filestat)\n{\n\tconst char *list = conn->dom_ctx->config[INDEX_FILES];\n\tstruct vec filename_vec;\n\tsize_t n = strlen(path);\n\tint found = 0;\n\n\t/* The 'path' given to us points to the directory. Remove all trailing\n\t * directory separator characters from the end of the path, and\n\t * then append single directory separator character. */\n\twhile ((n > 0) && (path[n - 1] == '/')) {\n\t\tn--;\n\t}\n\tpath[n] = '/';\n\n\t/* Traverse index files list. For each entry, append it to the given\n\t * path and see if the file exists. If it exists, break the loop */\n\twhile ((list = next_option(list, &filename_vec, NULL)) != NULL) {\n\t\t/* Ignore too long entries that may overflow path buffer */\n\t\tif ((filename_vec.len + 1) > (path_len - (n + 1))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Prepare full path to the index file */\n\t\tmg_strlcpy(path + n + 1, filename_vec.ptr, filename_vec.len + 1);\n\n\t\t/* Does it exist? */\n\t\tif (mg_stat(conn, path, filestat)) {\n\t\t\t/* Yes it does, break the loop */\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If no index file exists, restore directory path */\n\tif (!found) {\n\t\tpath[n] = '\\0';\n\t}\n\n\treturn found;\n}\n#endif\n\n\nstatic void\ninterpret_uri(struct mg_connection *conn, /* in/out: request (must be valid) */\n              char *filename,             /* out: filename */\n              size_t filename_buf_len,    /* in: size of filename buffer */\n              struct mg_file_stat *filestat, /* out: file status structure */\n              int *is_found,                 /* out: file found (directly) */\n              int *is_script_resource,       /* out: handled by a script? */\n              int *is_websocket_request,     /* out: websocket connetion? */\n              int *is_put_or_delete_request  /* out: put/delete a file? */\n)\n{\n\tchar const *accept_encoding;\n\n#if !defined(NO_FILES)\n\tconst char *uri = conn->request_info.local_uri;\n\tconst char *root = conn->dom_ctx->config[DOCUMENT_ROOT];\n\tconst char *rewrite;\n\tstruct vec a, b;\n\tptrdiff_t match_len;\n\tchar gz_path[PATH_MAX];\n\tint truncated;\n#if !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE)\n\tchar *tmp_str;\n\tsize_t tmp_str_len, sep_pos;\n\tint allow_substitute_script_subresources;\n#endif\n#else\n\t(void)filename_buf_len; /* unused if NO_FILES is defined */\n#endif\n\n\t/* Step 1: Set all initially unknown outputs to zero */\n\tmemset(filestat, 0, sizeof(*filestat));\n\t*filename = 0;\n\t*is_found = 0;\n\t*is_script_resource = 0;\n\n\t/* Step 2: Check if the request attempts to modify the file system */\n\t*is_put_or_delete_request = is_put_or_delete_method(conn);\n\n/* Step 3: Check if it is a websocket request, and modify the document\n * root if required */\n#if defined(USE_WEBSOCKET)\n\t*is_websocket_request = is_websocket_protocol(conn);\n#if !defined(NO_FILES)\n\tif (*is_websocket_request && conn->dom_ctx->config[WEBSOCKET_ROOT]) {\n\t\troot = conn->dom_ctx->config[WEBSOCKET_ROOT];\n\t}\n#endif /* !NO_FILES */\n#else  /* USE_WEBSOCKET */\n\t*is_websocket_request = 0;\n#endif /* USE_WEBSOCKET */\n\n\t/* Step 4: Check if gzip encoded response is allowed */\n\tconn->accept_gzip = 0;\n\tif ((accept_encoding = mg_get_header(conn, \"Accept-Encoding\")) != NULL) {\n\t\tif (strstr(accept_encoding, \"gzip\") != NULL) {\n\t\t\tconn->accept_gzip = 1;\n\t\t}\n\t}\n\n#if !defined(NO_FILES)\n\t/* Step 5: If there is no root directory, don't look for files. */\n\t/* Note that root == NULL is a regular use case here. This occurs,\n\t * if all requests are handled by callbacks, so the WEBSOCKET_ROOT\n\t * config is not required. */\n\tif (root == NULL) {\n\t\t/* all file related outputs have already been set to 0, just return\n\t\t */\n\t\treturn;\n\t}\n\n\t/* Step 6: Determine the local file path from the root path and the\n\t * request uri. */\n\t/* Using filename_buf_len - 1 because memmove() for PATH_INFO may shift\n\t * part of the path one byte on the right. */\n\tmg_snprintf(\n\t    conn, &truncated, filename, filename_buf_len - 1, \"%s%s\", root, uri);\n\n\tif (truncated) {\n\t\tgoto interpret_cleanup;\n\t}\n\n\t/* Step 7: URI rewriting */\n\trewrite = conn->dom_ctx->config[URL_REWRITE_PATTERN];\n\twhile ((rewrite = next_option(rewrite, &a, &b)) != NULL) {\n\t\tif ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            filename,\n\t\t\t            filename_buf_len - 1,\n\t\t\t            \"%.*s%s\",\n\t\t\t            (int)b.len,\n\t\t\t            b.ptr,\n\t\t\t            uri + match_len);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (truncated) {\n\t\tgoto interpret_cleanup;\n\t}\n\n\t/* Step 8: Check if the file exists at the server */\n\t/* Local file path and name, corresponding to requested URI\n\t * is now stored in \"filename\" variable. */\n\tif (mg_stat(conn, filename, filestat)) {\n\t\tint uri_len = (int)strlen(uri);\n\t\tint is_uri_end_slash = (uri_len > 0) && (uri[uri_len - 1] == '/');\n\n\t\t/* 8.1: File exists. */\n\t\t*is_found = 1;\n\n\t\t/* 8.2: Check if it is a script type. */\n\t\tif (extention_matches_script(conn, filename)) {\n\t\t\t/* The request addresses a CGI resource, Lua script or\n\t\t\t * server-side javascript.\n\t\t\t * The URI corresponds to the script itself (like\n\t\t\t * /path/script.cgi), and there is no additional resource\n\t\t\t * path (like /path/script.cgi/something).\n\t\t\t * Requests that modify (replace or delete) a resource, like\n\t\t\t * PUT and DELETE requests, should replace/delete the script\n\t\t\t * file.\n\t\t\t * Requests that read or write from/to a resource, like GET and\n\t\t\t * POST requests, should call the script and return the\n\t\t\t * generated response. */\n\t\t\t*is_script_resource = (!*is_put_or_delete_request);\n\t\t}\n\n\t\t/* 8.3: If the request target is a directory, there could be\n\t\t * a substitute file (index.html, index.cgi, ...). */\n\t\tif (filestat->is_directory && is_uri_end_slash) {\n\t\t\t/* Use a local copy here, since substitute_index_file will\n\t\t\t * change the content of the file status */\n\t\t\tstruct mg_file_stat tmp_filestat;\n\t\t\tmemset(&tmp_filestat, 0, sizeof(tmp_filestat));\n\n\t\t\tif (substitute_index_file(\n\t\t\t        conn, filename, filename_buf_len, &tmp_filestat)) {\n\n\t\t\t\t/* Substitute file found. Copy stat to the output, then\n\t\t\t\t * check if the file is a script file */\n\t\t\t\t*filestat = tmp_filestat;\n\n\t\t\t\tif (extention_matches_script(conn, filename)) {\n\t\t\t\t\t/* Substitute file is a script file */\n\t\t\t\t\t*is_script_resource = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/* Substitute file is a regular file */\n\t\t\t\t\t*is_script_resource = 0;\n\t\t\t\t\t*is_found = (mg_stat(conn, filename, filestat) ? 1 : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* If there is no substitute file, the server could return\n\t\t\t * a directory listing in a later step */\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Step 9: Check for zipped files: */\n\t/* If we can't find the actual file, look for the file\n\t * with the same name but a .gz extension. If we find it,\n\t * use that and set the gzipped flag in the file struct\n\t * to indicate that the response need to have the content-\n\t * encoding: gzip header.\n\t * We can only do this if the browser declares support. */\n\tif (conn->accept_gzip) {\n\t\tmg_snprintf(\n\t\t    conn, &truncated, gz_path, sizeof(gz_path), \"%s.gz\", filename);\n\n\t\tif (truncated) {\n\t\t\tgoto interpret_cleanup;\n\t\t}\n\n\t\tif (mg_stat(conn, gz_path, filestat)) {\n\t\t\tif (filestat) {\n\t\t\t\tfilestat->is_gzipped = 1;\n\t\t\t\t*is_found = 1;\n\t\t\t}\n\t\t\t/* Currently gz files can not be scripts. */\n\t\t\treturn;\n\t\t}\n\t}\n\n#if !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE)\n\t/* Step 10: Script resources may handle sub-resources */\n\t/* Support PATH_INFO for CGI scripts. */\n\ttmp_str_len = strlen(filename);\n\ttmp_str = (char *)mg_malloc_ctx(tmp_str_len + PATH_MAX + 1, conn->phys_ctx);\n\tif (!tmp_str) {\n\t\t/* Out of memory */\n\t\tgoto interpret_cleanup;\n\t}\n\tmemcpy(tmp_str, filename, tmp_str_len + 1);\n\n\t/* Check config, if index scripts may have sub-resources */\n\tallow_substitute_script_subresources =\n\t    !mg_strcasecmp(conn->dom_ctx->config[ALLOW_INDEX_SCRIPT_SUB_RES],\n\t                   \"yes\");\n\n\tsep_pos = tmp_str_len;\n\twhile (sep_pos > 0) {\n\t\tsep_pos--;\n\t\tif (tmp_str[sep_pos] == '/') {\n\t\t\tint is_script = 0, does_exist = 0;\n\n\t\t\ttmp_str[sep_pos] = 0;\n\t\t\tif (tmp_str[0]) {\n\t\t\t\tis_script = extention_matches_script(conn, tmp_str);\n\t\t\t\tdoes_exist = mg_stat(conn, tmp_str, filestat);\n\t\t\t}\n\n\t\t\tif (does_exist && is_script) {\n\t\t\t\tfilename[sep_pos] = 0;\n\t\t\t\tmemmove(filename + sep_pos + 2,\n\t\t\t\t        filename + sep_pos + 1,\n\t\t\t\t        strlen(filename + sep_pos + 1) + 1);\n\t\t\t\tconn->path_info = filename + sep_pos + 1;\n\t\t\t\tfilename[sep_pos + 1] = '/';\n\t\t\t\t*is_script_resource = 1;\n\t\t\t\t*is_found = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (allow_substitute_script_subresources) {\n\t\t\t\tif (substitute_index_file(\n\t\t\t\t        conn, tmp_str, tmp_str_len + PATH_MAX, filestat)) {\n\n\t\t\t\t\t/* some intermediate directory has an index file */\n\t\t\t\t\tif (extention_matches_script(conn, tmp_str)) {\n\n\t\t\t\t\t\tchar *tmp_str2;\n\n\t\t\t\t\t\tDEBUG_TRACE(\"Substitute script %s serving path %s\",\n\t\t\t\t\t\t            tmp_str,\n\t\t\t\t\t\t            filename);\n\n\t\t\t\t\t\t/* this index file is a script */\n\t\t\t\t\t\ttmp_str2 = mg_strdup_ctx(filename + sep_pos + 1,\n\t\t\t\t\t\t                         conn->phys_ctx);\n\t\t\t\t\t\tmg_snprintf(conn,\n\t\t\t\t\t\t            &truncated,\n\t\t\t\t\t\t            filename,\n\t\t\t\t\t\t            filename_buf_len,\n\t\t\t\t\t\t            \"%s//%s\",\n\t\t\t\t\t\t            tmp_str,\n\t\t\t\t\t\t            tmp_str2);\n\t\t\t\t\t\tmg_free(tmp_str2);\n\n\t\t\t\t\t\tif (truncated) {\n\t\t\t\t\t\t\tmg_free(tmp_str);\n\t\t\t\t\t\t\tgoto interpret_cleanup;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsep_pos = strlen(tmp_str);\n\t\t\t\t\t\tfilename[sep_pos] = 0;\n\t\t\t\t\t\tconn->path_info = filename + sep_pos + 1;\n\t\t\t\t\t\t*is_script_resource = 1;\n\t\t\t\t\t\t*is_found = 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tDEBUG_TRACE(\"Substitute file %s serving path %s\",\n\t\t\t\t\t\t            tmp_str,\n\t\t\t\t\t\t            filename);\n\n\t\t\t\t\t\t/* non-script files will not have sub-resources */\n\t\t\t\t\t\tfilename[sep_pos] = 0;\n\t\t\t\t\t\tconn->path_info = 0;\n\t\t\t\t\t\t*is_script_resource = 0;\n\t\t\t\t\t\t*is_found = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttmp_str[sep_pos] = '/';\n\t\t}\n\t}\n\n\tmg_free(tmp_str);\n\n#endif /* !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE) */\n#endif /* !defined(NO_FILES) */\n\treturn;\n\n#if !defined(NO_FILES)\n/* Reset all outputs */\ninterpret_cleanup:\n\tmemset(filestat, 0, sizeof(*filestat));\n\t*filename = 0;\n\t*is_found = 0;\n\t*is_script_resource = 0;\n\t*is_websocket_request = 0;\n\t*is_put_or_delete_request = 0;\n#endif /* !defined(NO_FILES) */\n}\n\n\n/* Check whether full request is buffered. Return:\n * -1  if request or response is malformed\n *  0  if request or response is not yet fully buffered\n * >0  actual request length, including last \\r\\n\\r\\n */\nstatic int\nget_http_header_len(const char *buf, int buflen)\n{\n\tint i;\n\tfor (i = 0; i < buflen; i++) {\n\t\t/* Do an unsigned comparison in some conditions below */\n\t\tconst unsigned char c = ((const unsigned char *)buf)[i];\n\n\t\tif ((c < 128) && ((char)c != '\\r') && ((char)c != '\\n')\n\t\t    && !isprint(c)) {\n\t\t\t/* abort scan as soon as one malformed character is found */\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (i < buflen - 1) {\n\t\t\tif ((buf[i] == '\\n') && (buf[i + 1] == '\\n')) {\n\t\t\t\t/* Two newline, no carriage return - not standard compliant,\n\t\t\t\t * but\n\t\t\t\t * it\n\t\t\t\t * should be accepted */\n\t\t\t\treturn i + 2;\n\t\t\t}\n\t\t}\n\n\t\tif (i < buflen - 3) {\n\t\t\tif ((buf[i] == '\\r') && (buf[i + 1] == '\\n') && (buf[i + 2] == '\\r')\n\t\t\t    && (buf[i + 3] == '\\n')) {\n\t\t\t\t/* Two \\r\\n - standard compliant */\n\t\t\t\treturn i + 4;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n#if !defined(NO_CACHING)\n/* Convert month to the month number. Return -1 on error, or month number */\nstatic int\nget_month_index(const char *s)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(month_names); i++) {\n\t\tif (!strcmp(s, month_names[i])) {\n\t\t\treturn (int)i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n\n/* Parse UTC date-time string, and return the corresponding time_t value. */\nstatic time_t\nparse_date_string(const char *datetime)\n{\n\tchar month_str[32] = {0};\n\tint second, minute, hour, day, month, year;\n\ttime_t result = (time_t)0;\n\tstruct tm tm;\n\n\tif ((sscanf(datetime,\n\t            \"%d/%3s/%d %d:%d:%d\",\n\t            &day,\n\t            month_str,\n\t            &year,\n\t            &hour,\n\t            &minute,\n\t            &second)\n\t     == 6)\n\t    || (sscanf(datetime,\n\t               \"%d %3s %d %d:%d:%d\",\n\t               &day,\n\t               month_str,\n\t               &year,\n\t               &hour,\n\t               &minute,\n\t               &second)\n\t        == 6)\n\t    || (sscanf(datetime,\n\t               \"%*3s, %d %3s %d %d:%d:%d\",\n\t               &day,\n\t               month_str,\n\t               &year,\n\t               &hour,\n\t               &minute,\n\t               &second)\n\t        == 6)\n\t    || (sscanf(datetime,\n\t               \"%d-%3s-%d %d:%d:%d\",\n\t               &day,\n\t               month_str,\n\t               &year,\n\t               &hour,\n\t               &minute,\n\t               &second)\n\t        == 6)) {\n\t\tmonth = get_month_index(month_str);\n\t\tif ((month >= 0) && (year >= 1970)) {\n\t\t\tmemset(&tm, 0, sizeof(tm));\n\t\t\ttm.tm_year = year - 1900;\n\t\t\ttm.tm_mon = month;\n\t\t\ttm.tm_mday = day;\n\t\t\ttm.tm_hour = hour;\n\t\t\ttm.tm_min = minute;\n\t\t\ttm.tm_sec = second;\n\t\t\tresult = timegm(&tm);\n\t\t}\n\t}\n\n\treturn result;\n}\n#endif /* !NO_CACHING */\n\n\n/* Protect against directory disclosure attack by removing '..',\n * excessive '/' and '\\' characters */\nstatic void\nremove_double_dots_and_double_slashes(char *s)\n{\n\tchar *p = s;\n\n\twhile ((s[0] == '.') && (s[1] == '.')) {\n\t\ts++;\n\t}\n\n\twhile (*s != '\\0') {\n\t\t*p++ = *s++;\n\t\tif ((s[-1] == '/') || (s[-1] == '\\\\')) {\n\t\t\t/* Skip all following slashes, backslashes and double-dots */\n\t\t\twhile (s[0] != '\\0') {\n\t\t\t\tif ((s[0] == '/') || (s[0] == '\\\\')) {\n\t\t\t\t\ts++;\n\t\t\t\t} else if ((s[0] == '.') && (s[1] == '.')) {\n\t\t\t\t\ts += 2;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t*p = '\\0';\n}\n\n\nstatic const struct {\n\tconst char *extension;\n\tsize_t ext_len;\n\tconst char *mime_type;\n} builtin_mime_types[] = {\n    /* IANA registered MIME types\n     * (http://www.iana.org/assignments/media-types)\n     * application types */\n    {\".doc\", 4, \"application/msword\"},\n    {\".eps\", 4, \"application/postscript\"},\n    {\".exe\", 4, \"application/octet-stream\"},\n    {\".js\", 3, \"application/javascript\"},\n    {\".json\", 5, \"application/json\"},\n    {\".pdf\", 4, \"application/pdf\"},\n    {\".ps\", 3, \"application/postscript\"},\n    {\".rtf\", 4, \"application/rtf\"},\n    {\".xhtml\", 6, \"application/xhtml+xml\"},\n    {\".xsl\", 4, \"application/xml\"},\n    {\".xslt\", 5, \"application/xml\"},\n\n    /* fonts */\n    {\".ttf\", 4, \"application/font-sfnt\"},\n    {\".cff\", 4, \"application/font-sfnt\"},\n    {\".otf\", 4, \"application/font-sfnt\"},\n    {\".aat\", 4, \"application/font-sfnt\"},\n    {\".sil\", 4, \"application/font-sfnt\"},\n    {\".pfr\", 4, \"application/font-tdpfr\"},\n    {\".woff\", 5, \"application/font-woff\"},\n\n    /* audio */\n    {\".mp3\", 4, \"audio/mpeg\"},\n    {\".oga\", 4, \"audio/ogg\"},\n    {\".ogg\", 4, \"audio/ogg\"},\n\n    /* image */\n    {\".gif\", 4, \"image/gif\"},\n    {\".ief\", 4, \"image/ief\"},\n    {\".jpeg\", 5, \"image/jpeg\"},\n    {\".jpg\", 4, \"image/jpeg\"},\n    {\".jpm\", 4, \"image/jpm\"},\n    {\".jpx\", 4, \"image/jpx\"},\n    {\".png\", 4, \"image/png\"},\n    {\".svg\", 4, \"image/svg+xml\"},\n    {\".tif\", 4, \"image/tiff\"},\n    {\".tiff\", 5, \"image/tiff\"},\n\n    /* model */\n    {\".wrl\", 4, \"model/vrml\"},\n\n    /* text */\n    {\".css\", 4, \"text/css\"},\n    {\".csv\", 4, \"text/csv\"},\n    {\".htm\", 4, \"text/html\"},\n    {\".html\", 5, \"text/html\"},\n    {\".sgm\", 4, \"text/sgml\"},\n    {\".shtm\", 5, \"text/html\"},\n    {\".shtml\", 6, \"text/html\"},\n    {\".txt\", 4, \"text/plain\"},\n    {\".xml\", 4, \"text/xml\"},\n\n    /* video */\n    {\".mov\", 4, \"video/quicktime\"},\n    {\".mp4\", 4, \"video/mp4\"},\n    {\".mpeg\", 5, \"video/mpeg\"},\n    {\".mpg\", 4, \"video/mpeg\"},\n    {\".ogv\", 4, \"video/ogg\"},\n    {\".qt\", 3, \"video/quicktime\"},\n\n    /* not registered types\n     * (http://reference.sitepoint.com/html/mime-types-full,\n     * http://www.hansenb.pdx.edu/DMKB/dict/tutorials/mime_typ.php, ..) */\n    {\".arj\", 4, \"application/x-arj-compressed\"},\n    {\".gz\", 3, \"application/x-gunzip\"},\n    {\".rar\", 4, \"application/x-arj-compressed\"},\n    {\".swf\", 4, \"application/x-shockwave-flash\"},\n    {\".tar\", 4, \"application/x-tar\"},\n    {\".tgz\", 4, \"application/x-tar-gz\"},\n    {\".torrent\", 8, \"application/x-bittorrent\"},\n    {\".ppt\", 4, \"application/x-mspowerpoint\"},\n    {\".xls\", 4, \"application/x-msexcel\"},\n    {\".zip\", 4, \"application/x-zip-compressed\"},\n    {\".aac\",\n     4,\n     \"audio/aac\"}, /* http://en.wikipedia.org/wiki/Advanced_Audio_Coding */\n    {\".aif\", 4, \"audio/x-aif\"},\n    {\".m3u\", 4, \"audio/x-mpegurl\"},\n    {\".mid\", 4, \"audio/x-midi\"},\n    {\".ra\", 3, \"audio/x-pn-realaudio\"},\n    {\".ram\", 4, \"audio/x-pn-realaudio\"},\n    {\".wav\", 4, \"audio/x-wav\"},\n    {\".bmp\", 4, \"image/bmp\"},\n    {\".ico\", 4, \"image/x-icon\"},\n    {\".pct\", 4, \"image/x-pct\"},\n    {\".pict\", 5, \"image/pict\"},\n    {\".rgb\", 4, \"image/x-rgb\"},\n    {\".webm\", 5, \"video/webm\"}, /* http://en.wikipedia.org/wiki/WebM */\n    {\".asf\", 4, \"video/x-ms-asf\"},\n    {\".avi\", 4, \"video/x-msvideo\"},\n    {\".m4v\", 4, \"video/x-m4v\"},\n    {NULL, 0, NULL}};\n\n\nconst char *\nmg_get_builtin_mime_type(const char *path)\n{\n\tconst char *ext;\n\tsize_t i, path_len;\n\n\tpath_len = strlen(path);\n\n\tfor (i = 0; builtin_mime_types[i].extension != NULL; i++) {\n\t\text = path + (path_len - builtin_mime_types[i].ext_len);\n\t\tif ((path_len > builtin_mime_types[i].ext_len)\n\t\t    && (mg_strcasecmp(ext, builtin_mime_types[i].extension) == 0)) {\n\t\t\treturn builtin_mime_types[i].mime_type;\n\t\t}\n\t}\n\n\treturn \"text/plain\";\n}\n\n\n/* Look at the \"path\" extension and figure what mime type it has.\n * Store mime type in the vector. */\nstatic void\nget_mime_type(struct mg_connection *conn, const char *path, struct vec *vec)\n{\n\tstruct vec ext_vec, mime_vec;\n\tconst char *list, *ext;\n\tsize_t path_len;\n\n\tpath_len = strlen(path);\n\n\tif ((conn == NULL) || (vec == NULL)) {\n\t\tif (vec != NULL) {\n\t\t\tmemset(vec, '\\0', sizeof(struct vec));\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Scan user-defined mime types first, in case user wants to\n\t * override default mime types. */\n\tlist = conn->dom_ctx->config[EXTRA_MIME_TYPES];\n\twhile ((list = next_option(list, &ext_vec, &mime_vec)) != NULL) {\n\t\t/* ext now points to the path suffix */\n\t\text = path + path_len - ext_vec.len;\n\t\tif (mg_strncasecmp(ext, ext_vec.ptr, ext_vec.len) == 0) {\n\t\t\t*vec = mime_vec;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvec->ptr = mg_get_builtin_mime_type(path);\n\tvec->len = strlen(vec->ptr);\n}\n\n\n/* Stringify binary data. Output buffer must be twice as big as input,\n * because each byte takes 2 bytes in string representation */\nstatic void\nbin2str(char *to, const unsigned char *p, size_t len)\n{\n\tstatic const char *hex = \"0123456789abcdef\";\n\n\tfor (; len--; p++) {\n\t\t*to++ = hex[p[0] >> 4];\n\t\t*to++ = hex[p[0] & 0x0f];\n\t}\n\t*to = '\\0';\n}\n\n\n/* Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.\n */\nchar *\nmg_md5(char buf[33], ...)\n{\n\tmd5_byte_t hash[16];\n\tconst char *p;\n\tva_list ap;\n\tmd5_state_t ctx;\n\n\tmd5_init(&ctx);\n\n\tva_start(ap, buf);\n\twhile ((p = va_arg(ap, const char *)) != NULL) {\n\t\tmd5_append(&ctx, (const md5_byte_t *)p, strlen(p));\n\t}\n\tva_end(ap);\n\n\tmd5_finish(&ctx, hash);\n\tbin2str(buf, hash, sizeof(hash));\n\treturn buf;\n}\n\n\n/* Check the user's password, return 1 if OK */\nstatic int\ncheck_password(const char *method,\n               const char *ha1,\n               const char *uri,\n               const char *nonce,\n               const char *nc,\n               const char *cnonce,\n               const char *qop,\n               const char *response)\n{\n\tchar ha2[32 + 1], expected_response[32 + 1];\n\n\t/* Some of the parameters may be NULL */\n\tif ((method == NULL) || (nonce == NULL) || (nc == NULL) || (cnonce == NULL)\n\t    || (qop == NULL) || (response == NULL)) {\n\t\treturn 0;\n\t}\n\n\t/* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */\n\tif (strlen(response) != 32) {\n\t\treturn 0;\n\t}\n\n\tmg_md5(ha2, method, \":\", uri, NULL);\n\tmg_md5(expected_response,\n\t       ha1,\n\t       \":\",\n\t       nonce,\n\t       \":\",\n\t       nc,\n\t       \":\",\n\t       cnonce,\n\t       \":\",\n\t       qop,\n\t       \":\",\n\t       ha2,\n\t       NULL);\n\n\treturn mg_strcasecmp(response, expected_response) == 0;\n}\n\n\n/* Use the global passwords file, if specified by auth_gpass option,\n * or search for .htpasswd in the requested directory. */\nstatic void\nopen_auth_file(struct mg_connection *conn,\n               const char *path,\n               struct mg_file *filep)\n{\n\tif ((conn != NULL) && (conn->dom_ctx != NULL)) {\n\t\tchar name[PATH_MAX];\n\t\tconst char *p, *e,\n\t\t    *gpass = conn->dom_ctx->config[GLOBAL_PASSWORDS_FILE];\n\t\tint truncated;\n\n\t\tif (gpass != NULL) {\n\t\t\t/* Use global passwords file */\n\t\t\tif (!mg_fopen(conn, gpass, MG_FOPEN_MODE_READ, filep)) {\n#if defined(DEBUG)\n\t\t\t\t/* Use mg_cry_internal here, since gpass has been configured. */\n\t\t\t\tmg_cry_internal(conn, \"fopen(%s): %s\", gpass, strerror(ERRNO));\n#endif\n\t\t\t}\n\t\t\t/* Important: using local struct mg_file to test path for\n\t\t\t * is_directory flag. If filep is used, mg_stat() makes it\n\t\t\t * appear as if auth file was opened.\n\t\t\t * TODO(mid): Check if this is still required after rewriting\n\t\t\t * mg_stat */\n\t\t} else if (mg_stat(conn, path, &filep->stat)\n\t\t           && filep->stat.is_directory) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            name,\n\t\t\t            sizeof(name),\n\t\t\t            \"%s/%s\",\n\t\t\t            path,\n\t\t\t            PASSWORDS_FILE_NAME);\n\n\t\t\tif (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {\n#if defined(DEBUG)\n\t\t\t\t/* Don't use mg_cry_internal here, but only a trace, since this\n\t\t\t\t * is\n\t\t\t\t * a typical case. It will occur for every directory\n\t\t\t\t * without a password file. */\n\t\t\t\tDEBUG_TRACE(\"fopen(%s): %s\", name, strerror(ERRNO));\n#endif\n\t\t\t}\n\t\t} else {\n\t\t\t/* Try to find .htpasswd in requested directory. */\n\t\t\tfor (p = path, e = p + strlen(p) - 1; e > p; e--) {\n\t\t\t\tif (e[0] == '/') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            name,\n\t\t\t            sizeof(name),\n\t\t\t            \"%.*s/%s\",\n\t\t\t            (int)(e - p),\n\t\t\t            p,\n\t\t\t            PASSWORDS_FILE_NAME);\n\n\t\t\tif (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {\n#if defined(DEBUG)\n\t\t\t\t/* Don't use mg_cry_internal here, but only a trace, since this\n\t\t\t\t * is\n\t\t\t\t * a typical case. It will occur for every directory\n\t\t\t\t * without a password file. */\n\t\t\t\tDEBUG_TRACE(\"fopen(%s): %s\", name, strerror(ERRNO));\n#endif\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/* Parsed Authorization header */\nstruct ah {\n\tchar *user, *uri, *cnonce, *response, *qop, *nc, *nonce;\n};\n\n\n/* Return 1 on success. Always initializes the ah structure. */\nstatic int\nparse_auth_header(struct mg_connection *conn,\n                  char *buf,\n                  size_t buf_size,\n                  struct ah *ah)\n{\n\tchar *name, *value, *s;\n\tconst char *auth_header;\n\tuint64_t nonce;\n\n\tif (!ah || !conn) {\n\t\treturn 0;\n\t}\n\n\t(void)memset(ah, 0, sizeof(*ah));\n\tif (((auth_header = mg_get_header(conn, \"Authorization\")) == NULL)\n\t    || mg_strncasecmp(auth_header, \"Digest \", 7) != 0) {\n\t\treturn 0;\n\t}\n\n\t/* Make modifiable copy of the auth header */\n\t(void)mg_strlcpy(buf, auth_header + 7, buf_size);\n\ts = buf;\n\n\t/* Parse authorization header */\n\tfor (;;) {\n\t\t/* Gobble initial spaces */\n\t\twhile (isspace(*(unsigned char *)s)) {\n\t\t\ts++;\n\t\t}\n\t\tname = skip_quoted(&s, \"=\", \" \", 0);\n\t\t/* Value is either quote-delimited, or ends at first comma or space.\n\t\t */\n\t\tif (s[0] == '\\\"') {\n\t\t\ts++;\n\t\t\tvalue = skip_quoted(&s, \"\\\"\", \" \", '\\\\');\n\t\t\tif (s[0] == ',') {\n\t\t\t\ts++;\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = skip_quoted(&s, \", \", \" \", 0); /* IE uses commas, FF uses\n\t\t\t                                        * spaces */\n\t\t}\n\t\tif (*name == '\\0') {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!strcmp(name, \"username\")) {\n\t\t\tah->user = value;\n\t\t} else if (!strcmp(name, \"cnonce\")) {\n\t\t\tah->cnonce = value;\n\t\t} else if (!strcmp(name, \"response\")) {\n\t\t\tah->response = value;\n\t\t} else if (!strcmp(name, \"uri\")) {\n\t\t\tah->uri = value;\n\t\t} else if (!strcmp(name, \"qop\")) {\n\t\t\tah->qop = value;\n\t\t} else if (!strcmp(name, \"nc\")) {\n\t\t\tah->nc = value;\n\t\t} else if (!strcmp(name, \"nonce\")) {\n\t\t\tah->nonce = value;\n\t\t}\n\t}\n\n#if !defined(NO_NONCE_CHECK)\n\t/* Read the nonce from the response. */\n\tif (ah->nonce == NULL) {\n\t\treturn 0;\n\t}\n\ts = NULL;\n\tnonce = strtoull(ah->nonce, &s, 10);\n\tif ((s == NULL) || (*s != 0)) {\n\t\treturn 0;\n\t}\n\n\t/* Convert the nonce from the client to a number. */\n\tnonce ^= conn->dom_ctx->auth_nonce_mask;\n\n\t/* The converted number corresponds to the time the nounce has been\n\t * created. This should not be earlier than the server start. */\n\t/* Server side nonce check is valuable in all situations but one:\n\t * if the server restarts frequently, but the client should not see\n\t * that, so the server should accept nonces from previous starts. */\n\t/* However, the reasonable default is to not accept a nonce from a\n\t * previous start, so if anyone changed the access rights between\n\t * two restarts, a new login is required. */\n\tif (nonce < (uint64_t)conn->phys_ctx->start_time) {\n\t\t/* nonce is from a previous start of the server and no longer valid\n\t\t * (replay attack?) */\n\t\treturn 0;\n\t}\n\t/* Check if the nonce is too high, so it has not (yet) been used by the\n\t * server. */\n\tif (nonce >= ((uint64_t)conn->phys_ctx->start_time\n\t              + conn->dom_ctx->nonce_count)) {\n\t\treturn 0;\n\t}\n#else\n\t(void)nonce;\n#endif\n\n\t/* CGI needs it as REMOTE_USER */\n\tif (ah->user != NULL) {\n\t\tconn->request_info.remote_user =\n\t\t    mg_strdup_ctx(ah->user, conn->phys_ctx);\n\t} else {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\nstatic const char *\nmg_fgets(char *buf, size_t size, struct mg_file *filep, char **p)\n{\n#if defined(MG_USE_OPEN_FILE)\n\tconst char *eof;\n\tsize_t len;\n\tconst char *memend;\n#else\n\t(void)p; /* parameter is unused */\n#endif\n\n\tif (!filep) {\n\t\treturn NULL;\n\t}\n\n#if defined(MG_USE_OPEN_FILE)\n\tif ((filep->access.membuf != NULL) && (*p != NULL)) {\n\t\tmemend = (const char *)&filep->access.membuf[filep->stat.size];\n\t\t/* Search for \\n from p till the end of stream */\n\t\teof = (char *)memchr(*p, '\\n', (size_t)(memend - *p));\n\t\tif (eof != NULL) {\n\t\t\teof += 1; /* Include \\n */\n\t\t} else {\n\t\t\teof = memend; /* Copy remaining data */\n\t\t}\n\t\tlen =\n\t\t    ((size_t)(eof - *p) > (size - 1)) ? (size - 1) : (size_t)(eof - *p);\n\t\tmemcpy(buf, *p, len);\n\t\tbuf[len] = '\\0';\n\t\t*p += len;\n\t\treturn len ? eof : NULL;\n\t} else /* filep->access.fp block below */\n#endif\n\t    if (filep->access.fp != NULL) {\n\t\treturn fgets(buf, (int)size, filep->access.fp);\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\n/* Define the initial recursion depth for procesesing htpasswd files that\n * include other htpasswd\n * (or even the same) files.  It is not difficult to provide a file or files\n * s.t. they force civetweb\n * to infinitely recurse and then crash.\n */\n#define INITIAL_DEPTH 9\n#if INITIAL_DEPTH <= 0\n#error Bad INITIAL_DEPTH for recursion, set to at least 1\n#endif\n\nstruct read_auth_file_struct {\n\tstruct mg_connection *conn;\n\tstruct ah ah;\n\tconst char *domain;\n\tchar buf[256 + 256 + 40];\n\tconst char *f_user;\n\tconst char *f_domain;\n\tconst char *f_ha1;\n};\n\n\nstatic int\nread_auth_file(struct mg_file *filep,\n               struct read_auth_file_struct *workdata,\n               int depth)\n{\n\tchar *p = NULL /* init if MG_USE_OPEN_FILE is not set */;\n\tint is_authorized = 0;\n\tstruct mg_file fp;\n\tsize_t l;\n\n\tif (!filep || !workdata || (0 == depth)) {\n\t\treturn 0;\n\t}\n\n/* Loop over passwords file */\n#if defined(MG_USE_OPEN_FILE)\n\tp = (char *)filep->access.membuf;\n#endif\n\twhile (mg_fgets(workdata->buf, sizeof(workdata->buf), filep, &p) != NULL) {\n\t\tl = strlen(workdata->buf);\n\t\twhile (l > 0) {\n\t\t\tif (isspace(workdata->buf[l - 1])\n\t\t\t    || iscntrl(workdata->buf[l - 1])) {\n\t\t\t\tl--;\n\t\t\t\tworkdata->buf[l] = 0;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (l < 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tworkdata->f_user = workdata->buf;\n\n\t\tif (workdata->f_user[0] == ':') {\n\t\t\t/* user names may not contain a ':' and may not be empty,\n\t\t\t * so lines starting with ':' may be used for a special purpose\n\t\t\t */\n\t\t\tif (workdata->f_user[1] == '#') {\n\t\t\t\t/* :# is a comment */\n\t\t\t\tcontinue;\n\t\t\t} else if (!strncmp(workdata->f_user + 1, \"include=\", 8)) {\n\t\t\t\tif (mg_fopen(workdata->conn,\n\t\t\t\t             workdata->f_user + 9,\n\t\t\t\t             MG_FOPEN_MODE_READ,\n\t\t\t\t             &fp)) {\n\t\t\t\t\tis_authorized = read_auth_file(&fp, workdata, depth - 1);\n\t\t\t\t\t(void)mg_fclose(\n\t\t\t\t\t    &fp.access); /* ignore error on read only file */\n\n\t\t\t\t\t/* No need to continue processing files once we have a\n\t\t\t\t\t * match, since nothing will reset it back\n\t\t\t\t\t * to 0.\n\t\t\t\t\t */\n\t\t\t\t\tif (is_authorized) {\n\t\t\t\t\t\treturn is_authorized;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmg_cry_internal(workdata->conn,\n\t\t\t\t\t                \"%s: cannot open authorization file: %s\",\n\t\t\t\t\t                __func__,\n\t\t\t\t\t                workdata->buf);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* everything is invalid for the moment (might change in the\n\t\t\t * future) */\n\t\t\tmg_cry_internal(workdata->conn,\n\t\t\t                \"%s: syntax error in authorization file: %s\",\n\t\t\t                __func__,\n\t\t\t                workdata->buf);\n\t\t\tcontinue;\n\t\t}\n\n\t\tworkdata->f_domain = strchr(workdata->f_user, ':');\n\t\tif (workdata->f_domain == NULL) {\n\t\t\tmg_cry_internal(workdata->conn,\n\t\t\t                \"%s: syntax error in authorization file: %s\",\n\t\t\t                __func__,\n\t\t\t                workdata->buf);\n\t\t\tcontinue;\n\t\t}\n\t\t*(char *)(workdata->f_domain) = 0;\n\t\t(workdata->f_domain)++;\n\n\t\tworkdata->f_ha1 = strchr(workdata->f_domain, ':');\n\t\tif (workdata->f_ha1 == NULL) {\n\t\t\tmg_cry_internal(workdata->conn,\n\t\t\t                \"%s: syntax error in authorization file: %s\",\n\t\t\t                __func__,\n\t\t\t                workdata->buf);\n\t\t\tcontinue;\n\t\t}\n\t\t*(char *)(workdata->f_ha1) = 0;\n\t\t(workdata->f_ha1)++;\n\n\t\tif (!strcmp(workdata->ah.user, workdata->f_user)\n\t\t    && !strcmp(workdata->domain, workdata->f_domain)) {\n\t\t\treturn check_password(workdata->conn->request_info.request_method,\n\t\t\t                      workdata->f_ha1,\n\t\t\t                      workdata->ah.uri,\n\t\t\t                      workdata->ah.nonce,\n\t\t\t                      workdata->ah.nc,\n\t\t\t                      workdata->ah.cnonce,\n\t\t\t                      workdata->ah.qop,\n\t\t\t                      workdata->ah.response);\n\t\t}\n\t}\n\n\treturn is_authorized;\n}\n\n\n/* Authorize against the opened passwords file. Return 1 if authorized. */\nstatic int\nauthorize(struct mg_connection *conn, struct mg_file *filep, const char *realm)\n{\n\tstruct read_auth_file_struct workdata;\n\tchar buf[MG_BUF_LEN];\n\n\tif (!conn || !conn->dom_ctx) {\n\t\treturn 0;\n\t}\n\n\tmemset(&workdata, 0, sizeof(workdata));\n\tworkdata.conn = conn;\n\n\tif (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {\n\t\treturn 0;\n\t}\n\n\tif (realm) {\n\t\tworkdata.domain = realm;\n\t} else {\n\t\tworkdata.domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];\n\t}\n\n\treturn read_auth_file(filep, &workdata, INITIAL_DEPTH);\n}\n\n\n/* Public function to check http digest authentication header */\nint\nmg_check_digest_access_authentication(struct mg_connection *conn,\n                                      const char *realm,\n                                      const char *filename)\n{\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tint auth;\n\n\tif (!conn || !filename) {\n\t\treturn -1;\n\t}\n\tif (!mg_fopen(conn, filename, MG_FOPEN_MODE_READ, &file)) {\n\t\treturn -2;\n\t}\n\n\tauth = authorize(conn, &file, realm);\n\n\tmg_fclose(&file.access);\n\n\treturn auth;\n}\n\n\n/* Return 1 if request is authorised, 0 otherwise. */\nstatic int\ncheck_authorization(struct mg_connection *conn, const char *path)\n{\n\tchar fname[PATH_MAX];\n\tstruct vec uri_vec, filename_vec;\n\tconst char *list;\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tint authorized = 1, truncated;\n\n\tif (!conn || !conn->dom_ctx) {\n\t\treturn 0;\n\t}\n\n\tlist = conn->dom_ctx->config[PROTECT_URI];\n\twhile ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {\n\t\tif (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            fname,\n\t\t\t            sizeof(fname),\n\t\t\t            \"%.*s\",\n\t\t\t            (int)filename_vec.len,\n\t\t\t            filename_vec.ptr);\n\n\t\t\tif (truncated\n\t\t\t    || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {\n\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t                \"%s: cannot open %s: %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                fname,\n\t\t\t\t                strerror(errno));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!is_file_opened(&file.access)) {\n\t\topen_auth_file(conn, path, &file);\n\t}\n\n\tif (is_file_opened(&file.access)) {\n\t\tauthorized = authorize(conn, &file, NULL);\n\t\t(void)mg_fclose(&file.access); /* ignore error on read only file */\n\t}\n\n\treturn authorized;\n}\n\n\n/* Internal function. Assumes conn is valid */\nstatic void\nsend_authorization_request(struct mg_connection *conn, const char *realm)\n{\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\tuint64_t nonce = (uint64_t)(conn->phys_ctx->start_time);\n\n\tif (!realm) {\n\t\trealm = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];\n\t}\n\n\t(void)pthread_mutex_lock(&conn->phys_ctx->nonce_mutex);\n\tnonce += conn->dom_ctx->nonce_count;\n\t++conn->dom_ctx->nonce_count;\n\t(void)pthread_mutex_unlock(&conn->phys_ctx->nonce_mutex);\n\n\tnonce ^= conn->dom_ctx->auth_nonce_mask;\n\tconn->status_code = 401;\n\tconn->must_close = 1;\n\n\tgmt_time_string(date, sizeof(date), &curtime);\n\n\tmg_printf(conn, \"HTTP/1.1 401 Unauthorized\\r\\n\");\n\tsend_no_cache_header(conn);\n\tsend_additional_header(conn);\n\tmg_printf(conn,\n\t          \"Date: %s\\r\\n\"\n\t          \"Connection: %s\\r\\n\"\n\t          \"Content-Length: 0\\r\\n\"\n\t          \"WWW-Authenticate: Digest qop=\\\"auth\\\", realm=\\\"%s\\\", \"\n\t          \"nonce=\\\"%\" UINT64_FMT \"\\\"\\r\\n\\r\\n\",\n\t          date,\n\t          suggest_connection_header(conn),\n\t          realm,\n\t          nonce);\n}\n\n\n/* Interface function. Parameters are provided by the user, so do\n * at least some basic checks.\n */\nint\nmg_send_digest_access_authentication_request(struct mg_connection *conn,\n                                             const char *realm)\n{\n\tif (conn && conn->dom_ctx) {\n\t\tsend_authorization_request(conn, realm);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n\n#if !defined(NO_FILES)\nstatic int\nis_authorized_for_put(struct mg_connection *conn)\n{\n\tif (conn) {\n\t\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\t\tconst char *passfile = conn->dom_ctx->config[PUT_DELETE_PASSWORDS_FILE];\n\t\tint ret = 0;\n\n\t\tif (passfile != NULL\n\t\t    && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {\n\t\t\tret = authorize(conn, &file, NULL);\n\t\t\t(void)mg_fclose(&file.access); /* ignore error on read only file */\n\t\t}\n\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n#endif\n\n\nint\nmg_modify_passwords_file(const char *fname,\n                         const char *domain,\n                         const char *user,\n                         const char *pass)\n{\n\tint found, i;\n\tchar line[512], u[512] = \"\", d[512] = \"\", ha1[33], tmp[PATH_MAX + 8];\n\tFILE *fp, *fp2;\n\n\tfound = 0;\n\tfp = fp2 = NULL;\n\n\t/* Regard empty password as no password - remove user record. */\n\tif ((pass != NULL) && (pass[0] == '\\0')) {\n\t\tpass = NULL;\n\t}\n\n\t/* Other arguments must not be empty */\n\tif ((fname == NULL) || (domain == NULL) || (user == NULL)) {\n\t\treturn 0;\n\t}\n\n\t/* Using the given file format, user name and domain must not contain\n\t * ':'\n\t */\n\tif (strchr(user, ':') != NULL) {\n\t\treturn 0;\n\t}\n\tif (strchr(domain, ':') != NULL) {\n\t\treturn 0;\n\t}\n\n\t/* Do not allow control characters like newline in user name and domain.\n\t * Do not allow excessively long names either. */\n\tfor (i = 0; ((i < 255) && (user[i] != 0)); i++) {\n\t\tif (iscntrl(user[i])) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (user[i]) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; ((i < 255) && (domain[i] != 0)); i++) {\n\t\tif (iscntrl(domain[i])) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (domain[i]) {\n\t\treturn 0;\n\t}\n\n\t/* The maximum length of the path to the password file is limited */\n\tif ((strlen(fname) + 4) >= PATH_MAX) {\n\t\treturn 0;\n\t}\n\n\t/* Create a temporary file name. Length has been checked before. */\n\tstrcpy(tmp, fname);\n\tstrcat(tmp, \".tmp\");\n\n\t/* Create the file if does not exist */\n\t/* Use of fopen here is OK, since fname is only ASCII */\n\tif ((fp = fopen(fname, \"a+\")) != NULL) {\n\t\t(void)fclose(fp);\n\t}\n\n\t/* Open the given file and temporary file */\n\tif ((fp = fopen(fname, \"r\")) == NULL) {\n\t\treturn 0;\n\t} else if ((fp2 = fopen(tmp, \"w+\")) == NULL) {\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\n\t/* Copy the stuff to temporary file */\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\t\tif (sscanf(line, \"%255[^:]:%255[^:]:%*s\", u, d) != 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tu[255] = 0;\n\t\td[255] = 0;\n\n\t\tif (!strcmp(u, user) && !strcmp(d, domain)) {\n\t\t\tfound++;\n\t\t\tif (pass != NULL) {\n\t\t\t\tmg_md5(ha1, user, \":\", domain, \":\", pass, NULL);\n\t\t\t\tfprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(fp2, \"%s\", line);\n\t\t}\n\t}\n\n\t/* If new user, just add it */\n\tif (!found && (pass != NULL)) {\n\t\tmg_md5(ha1, user, \":\", domain, \":\", pass, NULL);\n\t\tfprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);\n\t}\n\n\t/* Close files */\n\tfclose(fp);\n\tfclose(fp2);\n\n\t/* Put the temp file in place of real file */\n\tIGNORE_UNUSED_RESULT(remove(fname));\n\tIGNORE_UNUSED_RESULT(rename(tmp, fname));\n\n\treturn 1;\n}\n\n\nstatic int\nis_valid_port(unsigned long port)\n{\n\treturn (port <= 0xffff);\n}\n\n\nstatic int\nmg_inet_pton(int af, const char *src, void *dst, size_t dstlen)\n{\n\tstruct addrinfo hints, *res, *ressave;\n\tint func_ret = 0;\n\tint gai_ret;\n\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_family = af;\n\n\tgai_ret = getaddrinfo(src, NULL, &hints, &res);\n\tif (gai_ret != 0) {\n\t\t/* gai_strerror could be used to convert gai_ret to a string */\n\t\t/* POSIX return values: see\n\t\t * http://pubs.opengroup.org/onlinepubs/9699919799/functions/freeaddrinfo.html\n\t\t */\n\t\t/* Windows return values: see\n\t\t * https://msdn.microsoft.com/en-us/library/windows/desktop/ms738520%28v=vs.85%29.aspx\n\t\t */\n\t\treturn 0;\n\t}\n\n\tressave = res;\n\n\twhile (res) {\n\t\tif (dstlen >= (size_t)res->ai_addrlen) {\n\t\t\tmemcpy(dst, res->ai_addr, res->ai_addrlen);\n\t\t\tfunc_ret = 1;\n\t\t}\n\t\tres = res->ai_next;\n\t}\n\n\tfreeaddrinfo(ressave);\n\treturn func_ret;\n}\n\n\nstatic int\nconnect_socket(struct mg_context *ctx /* may be NULL */,\n               const char *host,\n               int port,\n               int use_ssl,\n               char *ebuf,\n               size_t ebuf_len,\n               SOCKET *sock /* output: socket, must not be NULL */,\n               union usa *sa /* output: socket address, must not be NULL  */\n)\n{\n\tint ip_ver = 0;\n\tint conn_ret = -1;\n\tint ret;\n\t*sock = INVALID_SOCKET;\n\tmemset(sa, 0, sizeof(*sa));\n\n\tif (ebuf_len > 0) {\n\t\t*ebuf = 0;\n\t}\n\n\tif (host == NULL) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"NULL host\");\n\t\treturn 0;\n\t}\n\n\tif ((port <= 0) || !is_valid_port((unsigned)port)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"invalid port\");\n\t\treturn 0;\n\t}\n\n#if !defined(NO_SSL)\n#if !defined(NO_SSL_DL)\n#if defined(OPENSSL_API_1_1)\n\tif (use_ssl && (TLS_client_method == NULL)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"SSL is not initialized\");\n\t\treturn 0;\n\t}\n#else\n\tif (use_ssl && (SSLv23_client_method == NULL)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"SSL is not initialized\");\n\t\treturn 0;\n\t}\n\n#endif /* OPENSSL_API_1_1 */\n#else\n\t(void)use_ssl;\n#endif /* NO_SSL_DL */\n#else\n\t(void)use_ssl;\n#endif /* !defined(NO_SSL) */\n\n\tif (mg_inet_pton(AF_INET, host, &sa->sin, sizeof(sa->sin))) {\n\t\tsa->sin.sin_family = AF_INET;\n\t\tsa->sin.sin_port = htons((uint16_t)port);\n\t\tip_ver = 4;\n#if defined(USE_IPV6)\n\t} else if (mg_inet_pton(AF_INET6, host, &sa->sin6, sizeof(sa->sin6))) {\n\t\tsa->sin6.sin6_family = AF_INET6;\n\t\tsa->sin6.sin6_port = htons((uint16_t)port);\n\t\tip_ver = 6;\n\t} else if (host[0] == '[') {\n\t\t/* While getaddrinfo on Windows will work with [::1],\n\t\t * getaddrinfo on Linux only works with ::1 (without []). */\n\t\tsize_t l = strlen(host + 1);\n\t\tchar *h = (l > 1) ? mg_strdup_ctx(host + 1, ctx) : NULL;\n\t\tif (h) {\n\t\t\th[l - 1] = 0;\n\t\t\tif (mg_inet_pton(AF_INET6, h, &sa->sin6, sizeof(sa->sin6))) {\n\t\t\t\tsa->sin6.sin6_family = AF_INET6;\n\t\t\t\tsa->sin6.sin6_port = htons((uint16_t)port);\n\t\t\t\tip_ver = 6;\n\t\t\t}\n\t\t\tmg_free(h);\n\t\t}\n#endif\n\t}\n\n\tif (ip_ver == 0) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"host not found\");\n\t\treturn 0;\n\t}\n\n\tif (ip_ver == 4) {\n\t\t*sock = socket(PF_INET, SOCK_STREAM, 0);\n\t}\n#if defined(USE_IPV6)\n\telse if (ip_ver == 6) {\n\t\t*sock = socket(PF_INET6, SOCK_STREAM, 0);\n\t}\n#endif\n\n\tif (*sock == INVALID_SOCKET) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"socket(): %s\",\n\t\t            strerror(ERRNO));\n\t\treturn 0;\n\t}\n\n\tif (0 != set_non_blocking_mode(*sock)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"Cannot set socket to non-blocking: %s\",\n\t\t            strerror(ERRNO));\n\t\tclosesocket(*sock);\n\t\t*sock = INVALID_SOCKET;\n\t\treturn 0;\n\t}\n\n\tset_close_on_exec(*sock, fc(ctx));\n\n\tif (ip_ver == 4) {\n\t\t/* connected with IPv4 */\n\t\tconn_ret = connect(*sock,\n\t\t                   (struct sockaddr *)((void *)&sa->sin),\n\t\t                   sizeof(sa->sin));\n\t}\n#if defined(USE_IPV6)\n\telse if (ip_ver == 6) {\n\t\t/* connected with IPv6 */\n\t\tconn_ret = connect(*sock,\n\t\t                   (struct sockaddr *)((void *)&sa->sin6),\n\t\t                   sizeof(sa->sin6));\n\t}\n#endif\n\n#if defined(_WIN32)\n\tif (conn_ret != 0) {\n\t\tDWORD err = WSAGetLastError(); /* could return WSAEWOULDBLOCK */\n\t\tconn_ret = (int)err;\n#if !defined(EINPROGRESS)\n#define EINPROGRESS (WSAEWOULDBLOCK) /* Winsock equivalent */\n#endif                               /* if !defined(EINPROGRESS) */\n\t}\n#endif\n\n\tif ((conn_ret != 0) && (conn_ret != EINPROGRESS)) {\n\t\t/* Data for getsockopt */\n\t\tint sockerr = -1;\n\t\tvoid *psockerr = &sockerr;\n\n#if defined(_WIN32)\n\t\tint len = (int)sizeof(sockerr);\n#else\n\t\tsocklen_t len = (socklen_t)sizeof(sockerr);\n#endif\n\n\t\t/* Data for poll */\n\t\tstruct pollfd pfd[1];\n\t\tint pollres;\n\t\tint ms_wait = 10000; /* 10 second timeout */\n\n\t\t/* For a non-blocking socket, the connect sequence is:\n\t\t * 1) call connect (will not block)\n\t\t * 2) wait until the socket is ready for writing (select or poll)\n\t\t * 3) check connection state with getsockopt\n\t\t */\n\t\tpfd[0].fd = *sock;\n\t\tpfd[0].events = POLLOUT;\n\t\tpollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));\n\n\t\tif (pollres != 1) {\n\t\t\t/* Not connected */\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"connect(%s:%d): timeout\",\n\t\t\t            host,\n\t\t\t            port);\n\t\t\tclosesocket(*sock);\n\t\t\t*sock = INVALID_SOCKET;\n\t\t\treturn 0;\n\t\t}\n\n#if defined(_WIN32)\n\t\tret = getsockopt(*sock, SOL_SOCKET, SO_ERROR, (char *)psockerr, &len);\n#else\n\t\tret = getsockopt(*sock, SOL_SOCKET, SO_ERROR, psockerr, &len);\n#endif\n\n\t\tif ((ret != 0) || (sockerr != 0)) {\n\t\t\t/* Not connected */\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"connect(%s:%d): error %s\",\n\t\t\t            host,\n\t\t\t            port,\n\t\t\t            strerror(sockerr));\n\t\t\tclosesocket(*sock);\n\t\t\t*sock = INVALID_SOCKET;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n\nint\nmg_url_encode(const char *src, char *dst, size_t dst_len)\n{\n\tstatic const char *dont_escape = \"._-$,;~()\";\n\tstatic const char *hex = \"0123456789abcdef\";\n\tchar *pos = dst;\n\tconst char *end = dst + dst_len - 1;\n\n\tfor (; ((*src != '\\0') && (pos < end)); src++, pos++) {\n\t\tif (isalnum(*(const unsigned char *)src)\n\t\t    || (strchr(dont_escape, *(const unsigned char *)src) != NULL)) {\n\t\t\t*pos = *src;\n\t\t} else if (pos + 2 < end) {\n\t\t\tpos[0] = '%';\n\t\t\tpos[1] = hex[(*(const unsigned char *)src) >> 4];\n\t\t\tpos[2] = hex[(*(const unsigned char *)src) & 0xf];\n\t\t\tpos += 2;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*pos = '\\0';\n\treturn (*src == '\\0') ? (int)(pos - dst) : -1;\n}\n\n/* Return 0 on success, non-zero if an error occurs. */\n\nstatic int\nprint_dir_entry(struct de *de)\n{\n\tsize_t hrefsize;\n\tchar *href;\n\tchar size[64], mod[64];\n#if defined(REENTRANT_TIME)\n\tstruct tm _tm;\n\tstruct tm *tm = &_tm;\n#else\n\tstruct tm *tm;\n#endif\n\n\threfsize = PATH_MAX * 3; /* worst case */\n\thref = (char *)mg_malloc(hrefsize);\n\tif (href == NULL) {\n\t\treturn -1;\n\t}\n\tif (de->file.is_directory) {\n\t\tmg_snprintf(de->conn,\n\t\t            NULL, /* Buffer is big enough */\n\t\t            size,\n\t\t            sizeof(size),\n\t\t            \"%s\",\n\t\t            \"[DIRECTORY]\");\n\t} else {\n\t\t/* We use (signed) cast below because MSVC 6 compiler cannot\n\t\t * convert unsigned __int64 to double. Sigh. */\n\t\tif (de->file.size < 1024) {\n\t\t\tmg_snprintf(de->conn,\n\t\t\t            NULL, /* Buffer is big enough */\n\t\t\t            size,\n\t\t\t            sizeof(size),\n\t\t\t            \"%d\",\n\t\t\t            (int)de->file.size);\n\t\t} else if (de->file.size < 0x100000) {\n\t\t\tmg_snprintf(de->conn,\n\t\t\t            NULL, /* Buffer is big enough */\n\t\t\t            size,\n\t\t\t            sizeof(size),\n\t\t\t            \"%.1fk\",\n\t\t\t            (double)de->file.size / 1024.0);\n\t\t} else if (de->file.size < 0x40000000) {\n\t\t\tmg_snprintf(de->conn,\n\t\t\t            NULL, /* Buffer is big enough */\n\t\t\t            size,\n\t\t\t            sizeof(size),\n\t\t\t            \"%.1fM\",\n\t\t\t            (double)de->file.size / 1048576);\n\t\t} else {\n\t\t\tmg_snprintf(de->conn,\n\t\t\t            NULL, /* Buffer is big enough */\n\t\t\t            size,\n\t\t\t            sizeof(size),\n\t\t\t            \"%.1fG\",\n\t\t\t            (double)de->file.size / 1073741824);\n\t\t}\n\t}\n\n\t/* Note: mg_snprintf will not cause a buffer overflow above.\n\t * So, string truncation checks are not required here. */\n\n#if defined(REENTRANT_TIME)\n\tlocaltime_r(&de->file.last_modified, tm);\n#else\n\ttm = localtime(&de->file.last_modified);\n#endif\n\tif (tm != NULL) {\n\t\tstrftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", tm);\n\t} else {\n\t\tmg_strlcpy(mod, \"01-Jan-1970 00:00\", sizeof(mod));\n\t\tmod[sizeof(mod) - 1] = '\\0';\n\t}\n\tmg_url_encode(de->file_name, href, hrefsize);\n\tmg_printf(de->conn,\n\t          \"<tr><td><a href=\\\"%s%s%s\\\">%s%s</a></td>\"\n\t          \"<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\\n\",\n\t          de->conn->request_info.local_uri,\n\t          href,\n\t          de->file.is_directory ? \"/\" : \"\",\n\t          de->file_name,\n\t          de->file.is_directory ? \"/\" : \"\",\n\t          mod,\n\t          size);\n\tmg_free(href);\n\treturn 0;\n}\n\n\n/* This function is called from send_directory() and used for\n * sorting directory entries by size, or name, or modification time.\n * On windows, __cdecl specification is needed in case if project is built\n * with __stdcall convention. qsort always requires __cdels callback. */\nstatic int WINCDECL\ncompare_dir_entries(const void *p1, const void *p2)\n{\n\tif (p1 && p2) {\n\t\tconst struct de *a = (const struct de *)p1, *b = (const struct de *)p2;\n\t\tconst char *query_string = a->conn->request_info.query_string;\n\t\tint cmp_result = 0;\n\n\t\tif (query_string == NULL) {\n\t\t\tquery_string = \"na\";\n\t\t}\n\n\t\tif (a->file.is_directory && !b->file.is_directory) {\n\t\t\treturn -1; /* Always put directories on top */\n\t\t} else if (!a->file.is_directory && b->file.is_directory) {\n\t\t\treturn 1; /* Always put directories on top */\n\t\t} else if (*query_string == 'n') {\n\t\t\tcmp_result = strcmp(a->file_name, b->file_name);\n\t\t} else if (*query_string == 's') {\n\t\t\tcmp_result = (a->file.size == b->file.size)\n\t\t\t                 ? 0\n\t\t\t                 : ((a->file.size > b->file.size) ? 1 : -1);\n\t\t} else if (*query_string == 'd') {\n\t\t\tcmp_result =\n\t\t\t    (a->file.last_modified == b->file.last_modified)\n\t\t\t        ? 0\n\t\t\t        : ((a->file.last_modified > b->file.last_modified) ? 1\n\t\t\t                                                           : -1);\n\t\t}\n\n\t\treturn (query_string[1] == 'd') ? -cmp_result : cmp_result;\n\t}\n\treturn 0;\n}\n\n\nstatic int\nmust_hide_file(struct mg_connection *conn, const char *path)\n{\n\tif (conn && conn->dom_ctx) {\n\t\tconst char *pw_pattern = \"**\" PASSWORDS_FILE_NAME \"$\";\n\t\tconst char *pattern = conn->dom_ctx->config[HIDE_FILES];\n\t\treturn (match_prefix(pw_pattern, strlen(pw_pattern), path) > 0)\n\t\t       || ((pattern != NULL)\n\t\t           && (match_prefix(pattern, strlen(pattern), path) > 0));\n\t}\n\treturn 0;\n}\n\n\nstatic int\nscan_directory(struct mg_connection *conn,\n               const char *dir,\n               void *data,\n               int (*cb)(struct de *, void *))\n{\n\tchar path[PATH_MAX];\n\tstruct dirent *dp;\n\tDIR *dirp;\n\tstruct de de;\n\tint truncated;\n\n\tif ((dirp = mg_opendir(conn, dir)) == NULL) {\n\t\treturn 0;\n\t} else {\n\t\tde.conn = conn;\n\n\t\twhile ((dp = mg_readdir(dirp)) != NULL) {\n\t\t\t/* Do not show current dir and hidden files */\n\t\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")\n\t\t\t    || must_hide_file(conn, dp->d_name)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmg_snprintf(\n\t\t\t    conn, &truncated, path, sizeof(path), \"%s/%s\", dir, dp->d_name);\n\n\t\t\t/* If we don't memset stat structure to zero, mtime will have\n\t\t\t * garbage and strftime() will segfault later on in\n\t\t\t * print_dir_entry(). memset is required only if mg_stat()\n\t\t\t * fails. For more details, see\n\t\t\t * http://code.google.com/p/mongoose/issues/detail?id=79 */\n\t\t\tmemset(&de.file, 0, sizeof(de.file));\n\n\t\t\tif (truncated) {\n\t\t\t\t/* If the path is not complete, skip processing. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!mg_stat(conn, path, &de.file)) {\n\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t                \"%s: mg_stat(%s) failed: %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                path,\n\t\t\t\t                strerror(ERRNO));\n\t\t\t}\n\t\t\tde.file_name = dp->d_name;\n\t\t\tcb(&de, data);\n\t\t}\n\t\t(void)mg_closedir(dirp);\n\t}\n\treturn 1;\n}\n\n\n#if !defined(NO_FILES)\nstatic int\nremove_directory(struct mg_connection *conn, const char *dir)\n{\n\tchar path[PATH_MAX];\n\tstruct dirent *dp;\n\tDIR *dirp;\n\tstruct de de;\n\tint truncated;\n\tint ok = 1;\n\n\tif ((dirp = mg_opendir(conn, dir)) == NULL) {\n\t\treturn 0;\n\t} else {\n\t\tde.conn = conn;\n\n\t\twhile ((dp = mg_readdir(dirp)) != NULL) {\n\t\t\t/* Do not show current dir (but show hidden files as they will\n\t\t\t * also be removed) */\n\t\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmg_snprintf(\n\t\t\t    conn, &truncated, path, sizeof(path), \"%s/%s\", dir, dp->d_name);\n\n\t\t\t/* If we don't memset stat structure to zero, mtime will have\n\t\t\t * garbage and strftime() will segfault later on in\n\t\t\t * print_dir_entry(). memset is required only if mg_stat()\n\t\t\t * fails. For more details, see\n\t\t\t * http://code.google.com/p/mongoose/issues/detail?id=79 */\n\t\t\tmemset(&de.file, 0, sizeof(de.file));\n\n\t\t\tif (truncated) {\n\t\t\t\t/* Do not delete anything shorter */\n\t\t\t\tok = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!mg_stat(conn, path, &de.file)) {\n\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t                \"%s: mg_stat(%s) failed: %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                path,\n\t\t\t\t                strerror(ERRNO));\n\t\t\t\tok = 0;\n\t\t\t}\n\n\t\t\tif (de.file.is_directory) {\n\t\t\t\tif (remove_directory(conn, path) == 0) {\n\t\t\t\t\tok = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* This will fail file is the file is in memory */\n\t\t\t\tif (mg_remove(conn, path) == 0) {\n\t\t\t\t\tok = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t(void)mg_closedir(dirp);\n\n\t\tIGNORE_UNUSED_RESULT(rmdir(dir));\n\t}\n\n\treturn ok;\n}\n#endif\n\n\nstruct dir_scan_data {\n\tstruct de *entries;\n\tunsigned int num_entries;\n\tunsigned int arr_size;\n};\n\n\n/* Behaves like realloc(), but frees original pointer on failure */\nstatic void *\nrealloc2(void *ptr, size_t size)\n{\n\tvoid *new_ptr = mg_realloc(ptr, size);\n\tif (new_ptr == NULL) {\n\t\tmg_free(ptr);\n\t}\n\treturn new_ptr;\n}\n\n\nstatic int\ndir_scan_callback(struct de *de, void *data)\n{\n\tstruct dir_scan_data *dsd = (struct dir_scan_data *)data;\n\n\tif ((dsd->entries == NULL) || (dsd->num_entries >= dsd->arr_size)) {\n\t\tdsd->arr_size *= 2;\n\t\tdsd->entries =\n\t\t    (struct de *)realloc2(dsd->entries,\n\t\t                          dsd->arr_size * sizeof(dsd->entries[0]));\n\t}\n\tif (dsd->entries == NULL) {\n\t\t/* TODO(lsm, low): propagate an error to the caller */\n\t\tdsd->num_entries = 0;\n\t} else {\n\t\tdsd->entries[dsd->num_entries].file_name = mg_strdup(de->file_name);\n\t\tdsd->entries[dsd->num_entries].file = de->file;\n\t\tdsd->entries[dsd->num_entries].conn = de->conn;\n\t\tdsd->num_entries++;\n\t}\n\n\treturn 0;\n}\n\n\nstatic void\nhandle_directory_request(struct mg_connection *conn, const char *dir)\n{\n\tunsigned int i;\n\tint sort_direction;\n\tstruct dir_scan_data data = {NULL, 0, 128};\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tif (!scan_directory(conn, dir, &data, dir_scan_callback)) {\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Cannot open directory\\nopendir(%s): %s\",\n\t\t                   dir,\n\t\t                   strerror(ERRNO));\n\t\treturn;\n\t}\n\n\tgmt_time_string(date, sizeof(date), &curtime);\n\n\tif (!conn) {\n\t\treturn;\n\t}\n\n\tsort_direction = ((conn->request_info.query_string != NULL)\n\t                  && (conn->request_info.query_string[1] == 'd'))\n\t                     ? 'a'\n\t                     : 'd';\n\n\tconn->must_close = 1;\n\tmg_printf(conn, \"HTTP/1.1 200 OK\\r\\n\");\n\tsend_static_cache_header(conn);\n\tsend_additional_header(conn);\n\tmg_printf(conn,\n\t          \"Date: %s\\r\\n\"\n\t          \"Connection: close\\r\\n\"\n\t          \"Content-Type: text/html; charset=utf-8\\r\\n\\r\\n\",\n\t          date);\n\tmg_printf(conn,\n\t          \"<html><head><title>Index of %s</title>\"\n\t          \"<style>th {text-align: left;}</style></head>\"\n\t          \"<body><h1>Index of %s</h1><pre><table cellpadding=\\\"0\\\">\"\n\t          \"<tr><th><a href=\\\"?n%c\\\">Name</a></th>\"\n\t          \"<th><a href=\\\"?d%c\\\">Modified</a></th>\"\n\t          \"<th><a href=\\\"?s%c\\\">Size</a></th></tr>\"\n\t          \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\",\n\t          conn->request_info.local_uri,\n\t          conn->request_info.local_uri,\n\t          sort_direction,\n\t          sort_direction,\n\t          sort_direction);\n\n\t/* Print first entry - link to a parent directory */\n\tmg_printf(conn,\n\t          \"<tr><td><a href=\\\"%s%s\\\">%s</a></td>\"\n\t          \"<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\\n\",\n\t          conn->request_info.local_uri,\n\t          \"..\",\n\t          \"Parent directory\",\n\t          \"-\",\n\t          \"-\");\n\n\t/* Sort and print directory entries */\n\tif (data.entries != NULL) {\n\t\tqsort(data.entries,\n\t\t      (size_t)data.num_entries,\n\t\t      sizeof(data.entries[0]),\n\t\t      compare_dir_entries);\n\t\tfor (i = 0; i < data.num_entries; i++) {\n\t\t\tprint_dir_entry(&data.entries[i]);\n\t\t\tmg_free(data.entries[i].file_name);\n\t\t}\n\t\tmg_free(data.entries);\n\t}\n\n\tmg_printf(conn, \"%s\", \"</table></body></html>\");\n\tconn->status_code = 200;\n}\n\n\n/* Send len bytes from the opened file to the client. */\nstatic void\nsend_file_data(struct mg_connection *conn,\n               struct mg_file *filep,\n               int64_t offset,\n               int64_t len)\n{\n\tchar buf[MG_BUF_LEN];\n\tint to_read, num_read, num_written;\n\tint64_t size;\n\n\tif (!filep || !conn) {\n\t\treturn;\n\t}\n\n\t/* Sanity check the offset */\n\tsize = (filep->stat.size > INT64_MAX) ? INT64_MAX\n\t                                      : (int64_t)(filep->stat.size);\n\toffset = (offset < 0) ? 0 : ((offset > size) ? size : offset);\n\n#if defined(MG_USE_OPEN_FILE)\n\tif ((len > 0) && (filep->access.membuf != NULL) && (size > 0)) {\n\t\t/* file stored in memory */\n\t\tif (len > size - offset) {\n\t\t\tlen = size - offset;\n\t\t}\n\t\tmg_write(conn, filep->access.membuf + offset, (size_t)len);\n\t} else /* else block below */\n#endif\n\t    if (len > 0 && filep->access.fp != NULL) {\n/* file stored on disk */\n#if defined(__linux__)\n\t\t/* sendfile is only available for Linux */\n\t\tif ((conn->ssl == 0) && (conn->throttle == 0)\n\t\t    && (!mg_strcasecmp(conn->dom_ctx->config[ALLOW_SENDFILE_CALL],\n\t\t                       \"yes\"))) {\n\t\t\toff_t sf_offs = (off_t)offset;\n\t\t\tssize_t sf_sent;\n\t\t\tint sf_file = fileno(filep->access.fp);\n\t\t\tint loop_cnt = 0;\n\n\t\t\tdo {\n\t\t\t\t/* 2147479552 (0x7FFFF000) is a limit found by experiment on\n\t\t\t\t * 64 bit Linux (2^31 minus one memory page of 4k?). */\n\t\t\t\tsize_t sf_tosend =\n\t\t\t\t    (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);\n\t\t\t\tsf_sent =\n\t\t\t\t    sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);\n\t\t\t\tif (sf_sent > 0) {\n\t\t\t\t\tlen -= sf_sent;\n\t\t\t\t\toffset += sf_sent;\n\t\t\t\t} else if (loop_cnt == 0) {\n\t\t\t\t\t/* This file can not be sent using sendfile.\n\t\t\t\t\t * This might be the case for pseudo-files in the\n\t\t\t\t\t * /sys/ and /proc/ file system.\n\t\t\t\t\t * Use the regular user mode copy code instead. */\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (sf_sent == 0) {\n\t\t\t\t\t/* No error, but 0 bytes sent. May be EOF? */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tloop_cnt++;\n\n\t\t\t} while ((len > 0) && (sf_sent >= 0));\n\n\t\t\tif (sf_sent > 0) {\n\t\t\t\treturn; /* OK */\n\t\t\t}\n\n\t\t\t/* sf_sent<0 means error, thus fall back to the classic way */\n\t\t\t/* This is always the case, if sf_file is not a \"normal\" file,\n\t\t\t * e.g., for sending data from the output of a CGI process. */\n\t\t\toffset = (int64_t)sf_offs;\n\t\t}\n#endif\n\t\tif ((offset > 0) && (fseeko(filep->access.fp, offset, SEEK_SET) != 0)) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: fseeko() failed: %s\",\n\t\t\t                __func__,\n\t\t\t                strerror(ERRNO));\n\t\t\tmg_send_http_error(\n\t\t\t    conn,\n\t\t\t    500,\n\t\t\t    \"%s\",\n\t\t\t    \"Error: Unable to access file at requested position.\");\n\t\t} else {\n\t\t\twhile (len > 0) {\n\t\t\t\t/* Calculate how much to read from the file in the buffer */\n\t\t\t\tto_read = sizeof(buf);\n\t\t\t\tif ((int64_t)to_read > len) {\n\t\t\t\t\tto_read = (int)len;\n\t\t\t\t}\n\n\t\t\t\t/* Read from file, exit the loop on error */\n\t\t\t\tif ((num_read =\n\t\t\t\t         (int)fread(buf, 1, (size_t)to_read, filep->access.fp))\n\t\t\t\t    <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Send read bytes to the client, exit the loop on error */\n\t\t\t\tif ((num_written = mg_write(conn, buf, (size_t)num_read))\n\t\t\t\t    != num_read) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Both read and were successful, adjust counters */\n\t\t\t\tlen -= num_written;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic int\nparse_range_header(const char *header, int64_t *a, int64_t *b)\n{\n\treturn sscanf(header, \"bytes=%\" INT64_FMT \"-%\" INT64_FMT, a, b);\n}\n\n\nstatic void\nconstruct_etag(char *buf, size_t buf_len, const struct mg_file_stat *filestat)\n{\n\tif ((filestat != NULL) && (buf != NULL)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* All calls to construct_etag use 64 byte buffer */\n\t\t            buf,\n\t\t            buf_len,\n\t\t            \"\\\"%lx.%\" INT64_FMT \"\\\"\",\n\t\t            (unsigned long)filestat->last_modified,\n\t\t            filestat->size);\n\t}\n}\n\n\nstatic void\nfclose_on_exec(struct mg_file_access *filep, struct mg_connection *conn)\n{\n\tif (filep != NULL && filep->fp != NULL) {\n#if defined(_WIN32)\n\t\t(void)conn; /* Unused. */\n#else\n\t\tif (fcntl(fileno(filep->fp), F_SETFD, FD_CLOEXEC) != 0) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: fcntl(F_SETFD FD_CLOEXEC) failed: %s\",\n\t\t\t                __func__,\n\t\t\t                strerror(ERRNO));\n\t\t}\n#endif\n\t}\n}\n\n\n#if defined(USE_ZLIB)\n#include \"mod_zlib.inl\"\n#endif\n\n\nstatic void\nhandle_static_file_request(struct mg_connection *conn,\n                           const char *path,\n                           struct mg_file *filep,\n                           const char *mime_type,\n                           const char *additional_headers)\n{\n\tchar date[64], lm[64], etag[64];\n\tchar range[128]; /* large enough, so there will be no overflow */\n\tconst char *msg = \"OK\", *hdr;\n\ttime_t curtime = time(NULL);\n\tint64_t cl, r1, r2;\n\tstruct vec mime_vec;\n\tint n, truncated;\n\tchar gz_path[PATH_MAX];\n\tconst char *encoding = \"\";\n\tconst char *cors1, *cors2, *cors3;\n\tint is_head_request;\n\n#if defined(USE_ZLIB)\n\t/* Compression is allowed, unless there is a reason not to use compression.\n\t * If the file is already compressed, too small or a \"range\" request was\n\t * made, on the fly compression is not possible. */\n\tint allow_on_the_fly_compression = 1;\n#endif\n\n\tif ((conn == NULL) || (conn->dom_ctx == NULL) || (filep == NULL)) {\n\t\treturn;\n\t}\n\n\tis_head_request = !strcmp(conn->request_info.request_method, \"HEAD\");\n\n\tif (mime_type == NULL) {\n\t\tget_mime_type(conn, path, &mime_vec);\n\t} else {\n\t\tmime_vec.ptr = mime_type;\n\t\tmime_vec.len = strlen(mime_type);\n\t}\n\tif (filep->stat.size > INT64_MAX) {\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: File size is too large to send\\n%\" INT64_FMT,\n\t\t                   filep->stat.size);\n\t\treturn;\n\t}\n\tcl = (int64_t)filep->stat.size;\n\tconn->status_code = 200;\n\trange[0] = '\\0';\n\n#if defined(USE_ZLIB)\n\t/* if this file is in fact a pre-gzipped file, rewrite its filename\n\t * it's important to rewrite the filename after resolving\n\t * the mime type from it, to preserve the actual file's type */\n\tif (!conn->accept_gzip) {\n\t\tallow_on_the_fly_compression = 0;\n\t}\n#endif\n\n\tif (filep->stat.is_gzipped) {\n\t\tmg_snprintf(conn, &truncated, gz_path, sizeof(gz_path), \"%s.gz\", path);\n\n\t\tif (truncated) {\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   500,\n\t\t\t                   \"Error: Path of zipped file too long (%s)\",\n\t\t\t                   path);\n\t\t\treturn;\n\t\t}\n\n\t\tpath = gz_path;\n\t\tencoding = \"Content-Encoding: gzip\\r\\n\";\n\n#if defined(USE_ZLIB)\n\t\t/* File is already compressed. No \"on the fly\" compression. */\n\t\tallow_on_the_fly_compression = 0;\n#endif\n\t}\n\n\tif (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Cannot open file\\nfopen(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t\treturn;\n\t}\n\n\tfclose_on_exec(&filep->access, conn);\n\n\t/* If \"Range\" request was made: parse header, send only selected part\n\t * of the file. */\n\tr1 = r2 = 0;\n\thdr = mg_get_header(conn, \"Range\");\n\tif ((hdr != NULL) && ((n = parse_range_header(hdr, &r1, &r2)) > 0)\n\t    && (r1 >= 0) && (r2 >= 0)) {\n\t\t/* actually, range requests don't play well with a pre-gzipped\n\t\t * file (since the range is specified in the uncompressed space) */\n\t\tif (filep->stat.is_gzipped) {\n\t\t\tmg_send_http_error(\n\t\t\t    conn,\n\t\t\t    416, /* 416 = Range Not Satisfiable */\n\t\t\t    \"%s\",\n\t\t\t    \"Error: Range requests in gzipped files are not supported\");\n\t\t\t(void)mg_fclose(\n\t\t\t    &filep->access); /* ignore error on read only file */\n\t\t\treturn;\n\t\t}\n\t\tconn->status_code = 206;\n\t\tcl = (n == 2) ? (((r2 > cl) ? cl : r2) - r1 + 1) : (cl - r1);\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* range buffer is big enough */\n\t\t            range,\n\t\t            sizeof(range),\n\t\t            \"Content-Range: bytes \"\n\t\t            \"%\" INT64_FMT \"-%\" INT64_FMT \"/%\" INT64_FMT \"\\r\\n\",\n\t\t            r1,\n\t\t            r1 + cl - 1,\n\t\t            filep->stat.size);\n\t\tmsg = \"Partial Content\";\n\n#if defined(USE_ZLIB)\n\t\t/* Do not compress ranges. */\n\t\tallow_on_the_fly_compression = 0;\n#endif\n\t}\n\n/* Do not compress small files. Small files do not benefit from file\n * compression, but there is still some overhead. */\n#if defined(USE_ZLIB)\n\tif (filep->stat.size < MG_FILE_COMPRESSION_SIZE_LIMIT) {\n\t\t/* File is below the size limit. */\n\t\tallow_on_the_fly_compression = 0;\n\t}\n#endif\n\n\t/* Standard CORS header */\n\thdr = mg_get_header(conn, \"Origin\");\n\tif (hdr) {\n\t\t/* Cross-origin resource sharing (CORS), see\n\t\t * http://www.html5rocks.com/en/tutorials/cors/,\n\t\t * http://www.html5rocks.com/static/images/cors_server_flowchart.png\n\t\t * -\n\t\t * preflight is not supported for files. */\n\t\tcors1 = \"Access-Control-Allow-Origin: \";\n\t\tcors2 = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];\n\t\tcors3 = \"\\r\\n\";\n\t} else {\n\t\tcors1 = cors2 = cors3 = \"\";\n\t}\n\n\t/* Prepare Etag, Date, Last-Modified headers. Must be in UTC,\n\t * according to\n\t * http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3 */\n\tgmt_time_string(date, sizeof(date), &curtime);\n\tgmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);\n\tconstruct_etag(etag, sizeof(etag), &filep->stat);\n\n\t/* Send header */\n\t(void)mg_printf(conn,\n\t                \"HTTP/1.1 %d %s\\r\\n\"\n\t                \"%s%s%s\" /* CORS */\n\t                \"Date: %s\\r\\n\"\n\t                \"Last-Modified: %s\\r\\n\"\n\t                \"Etag: %s\\r\\n\"\n\t                \"Content-Type: %.*s\\r\\n\"\n\t                \"Connection: %s\\r\\n\",\n\t                conn->status_code,\n\t                msg,\n\t                cors1,\n\t                cors2,\n\t                cors3,\n\t                date,\n\t                lm,\n\t                etag,\n\t                (int)mime_vec.len,\n\t                mime_vec.ptr,\n\t                suggest_connection_header(conn));\n\tsend_static_cache_header(conn);\n\tsend_additional_header(conn);\n\n#if defined(USE_ZLIB)\n\t/* On the fly compression allowed */\n\tif (allow_on_the_fly_compression) {\n\t\t/* For on the fly compression, we don't know the content size in\n\t\t * advance, so we have to use chunked encoding */\n\t\t(void)mg_printf(conn,\n\t\t                \"Content-Encoding: gzip\\r\\n\"\n\t\t                \"Transfer-Encoding: chunked\\r\\n\");\n\t} else\n#endif\n\t{\n\t\t/* Without on-the-fly compression, we know the content-length\n\t\t * and we can use ranges (with on-the-fly compression we cannot).\n\t\t * So we send these response headers only in this case. */\n\t\t(void)mg_printf(conn,\n\t\t                \"Content-Length: %\" INT64_FMT \"\\r\\n\"\n\t\t                \"Accept-Ranges: bytes\\r\\n\"\n\t\t                \"%s\" /* range */\n\t\t                \"%s\" /* encoding */,\n\t\t                cl,\n\t\t                range,\n\t\t                encoding);\n\t}\n\n\t/* The previous code must not add any header starting with X- to make\n\t * sure no one of the additional_headers is included twice */\n\tif (additional_headers != NULL) {\n\t\t(void)mg_printf(conn,\n\t\t                \"%.*s\\r\\n\\r\\n\",\n\t\t                (int)strlen(additional_headers),\n\t\t                additional_headers);\n\t} else {\n\t\t(void)mg_printf(conn, \"\\r\\n\");\n\t}\n\n\tif (!is_head_request) {\n#if defined(USE_ZLIB)\n\t\tif (allow_on_the_fly_compression) {\n\t\t\t/* Compress and send */\n\t\t\tsend_compressed_data(conn, filep);\n\t\t} else\n#endif\n\t\t{\n\t\t\t/* Send file directly */\n\t\t\tsend_file_data(conn, filep, r1, cl);\n\t\t}\n\t}\n\t(void)mg_fclose(&filep->access); /* ignore error on read only file */\n}\n\n\nint\nmg_send_file_body(struct mg_connection *conn, const char *path)\n{\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tif (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {\n\t\treturn -1;\n\t}\n\tfclose_on_exec(&file.access, conn);\n\tsend_file_data(conn, &file, 0, INT64_MAX);\n\t(void)mg_fclose(&file.access); /* Ignore errors for readonly files */\n\treturn 0;                      /* >= 0 for OK */\n}\n\n\n#if !defined(NO_CACHING)\n/* Return True if we should reply 304 Not Modified. */\nstatic int\nis_not_modified(const struct mg_connection *conn,\n                const struct mg_file_stat *filestat)\n{\n\tchar etag[64];\n\tconst char *ims = mg_get_header(conn, \"If-Modified-Since\");\n\tconst char *inm = mg_get_header(conn, \"If-None-Match\");\n\tconstruct_etag(etag, sizeof(etag), filestat);\n\n\treturn ((inm != NULL) && !mg_strcasecmp(etag, inm))\n\t       || ((ims != NULL)\n\t           && (filestat->last_modified <= parse_date_string(ims)));\n}\n\nstatic void\nhandle_not_modified_static_file_request(struct mg_connection *conn,\n                                        struct mg_file *filep)\n{\n\tchar date[64], lm[64], etag[64];\n\ttime_t curtime = time(NULL);\n\n\tif ((conn == NULL) || (filep == NULL)) {\n\t\treturn;\n\t}\n\tconn->status_code = 304;\n\tgmt_time_string(date, sizeof(date), &curtime);\n\tgmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);\n\tconstruct_etag(etag, sizeof(etag), &filep->stat);\n\n\t(void)mg_printf(conn,\n\t                \"HTTP/1.1 %d %s\\r\\n\"\n\t                \"Date: %s\\r\\n\",\n\t                conn->status_code,\n\t                mg_get_response_code_text(conn, conn->status_code),\n\t                date);\n\tsend_static_cache_header(conn);\n\tsend_additional_header(conn);\n\t(void)mg_printf(conn,\n\t                \"Last-Modified: %s\\r\\n\"\n\t                \"Etag: %s\\r\\n\"\n\t                \"Connection: %s\\r\\n\"\n\t                \"\\r\\n\",\n\t                lm,\n\t                etag,\n\t                suggest_connection_header(conn));\n}\n#endif\n\n\nvoid\nmg_send_file(struct mg_connection *conn, const char *path)\n{\n\tmg_send_mime_file2(conn, path, NULL, NULL);\n}\n\n\nvoid\nmg_send_mime_file(struct mg_connection *conn,\n                  const char *path,\n                  const char *mime_type)\n{\n\tmg_send_mime_file2(conn, path, mime_type, NULL);\n}\n\n\nvoid\nmg_send_mime_file2(struct mg_connection *conn,\n                   const char *path,\n                   const char *mime_type,\n                   const char *additional_headers)\n{\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\n\tif (!conn) {\n\t\t/* No conn */\n\t\treturn;\n\t}\n\n\tif (mg_stat(conn, path, &file.stat)) {\n#if !defined(NO_CACHING)\n\t\tif (is_not_modified(conn, &file.stat)) {\n\t\t\t/* Send 304 \"Not Modified\" - this must not send any body data */\n\t\t\thandle_not_modified_static_file_request(conn, &file);\n\t\t} else\n#endif /* NO_CACHING */\n\t\t    if (file.stat.is_directory) {\n\t\t\tif (!mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],\n\t\t\t                   \"yes\")) {\n\t\t\t\thandle_directory_request(conn, path);\n\t\t\t} else {\n\t\t\t\tmg_send_http_error(conn,\n\t\t\t\t                   403,\n\t\t\t\t                   \"%s\",\n\t\t\t\t                   \"Error: Directory listing denied\");\n\t\t\t}\n\t\t} else {\n\t\t\thandle_static_file_request(\n\t\t\t    conn, path, &file, mime_type, additional_headers);\n\t\t}\n\t} else {\n\t\tmg_send_http_error(conn, 404, \"%s\", \"Error: File not found\");\n\t}\n}\n\n\n/* For a given PUT path, create all intermediate subdirectories.\n * Return  0  if the path itself is a directory.\n * Return  1  if the path leads to a file.\n * Return -1  for if the path is too long.\n * Return -2  if path can not be created.\n */\nstatic int\nput_dir(struct mg_connection *conn, const char *path)\n{\n\tchar buf[PATH_MAX];\n\tconst char *s, *p;\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tsize_t len;\n\tint res = 1;\n\n\tfor (s = p = path + 2; (p = strchr(s, '/')) != NULL; s = ++p) {\n\t\tlen = (size_t)(p - path);\n\t\tif (len >= sizeof(buf)) {\n\t\t\t/* path too long */\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(buf, path, len);\n\t\tbuf[len] = '\\0';\n\n\t\t/* Try to create intermediate directory */\n\t\tDEBUG_TRACE(\"mkdir(%s)\", buf);\n\t\tif (!mg_stat(conn, buf, &file.stat) && mg_mkdir(conn, buf, 0755) != 0) {\n\t\t\t/* path does not exixt and can not be created */\n\t\t\tres = -2;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Is path itself a directory? */\n\t\tif (p[1] == '\\0') {\n\t\t\tres = 0;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n\nstatic void\nremove_bad_file(const struct mg_connection *conn, const char *path)\n{\n\tint r = mg_remove(conn, path);\n\tif (r != 0) {\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: Cannot remove invalid file %s\",\n\t\t                __func__,\n\t\t                path);\n\t}\n}\n\n\nlong long\nmg_store_body(struct mg_connection *conn, const char *path)\n{\n\tchar buf[MG_BUF_LEN];\n\tlong long len = 0;\n\tint ret, n;\n\tstruct mg_file fi;\n\n\tif (conn->consumed_content != 0) {\n\t\tmg_cry_internal(conn, \"%s: Contents already consumed\", __func__);\n\t\treturn -11;\n\t}\n\n\tret = put_dir(conn, path);\n\tif (ret < 0) {\n\t\t/* -1 for path too long,\n\t\t * -2 for path can not be created. */\n\t\treturn ret;\n\t}\n\tif (ret != 1) {\n\t\t/* Return 0 means, path itself is a directory. */\n\t\treturn 0;\n\t}\n\n\tif (mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &fi) == 0) {\n\t\treturn -12;\n\t}\n\n\tret = mg_read(conn, buf, sizeof(buf));\n\twhile (ret > 0) {\n\t\tn = (int)fwrite(buf, 1, (size_t)ret, fi.access.fp);\n\t\tif (n != ret) {\n\t\t\t(void)mg_fclose(\n\t\t\t    &fi.access); /* File is bad and will be removed anyway. */\n\t\t\tremove_bad_file(conn, path);\n\t\t\treturn -13;\n\t\t}\n\t\tlen += ret;\n\t\tret = mg_read(conn, buf, sizeof(buf));\n\t}\n\n\t/* File is open for writing. If fclose fails, there was probably an\n\t * error flushing the buffer to disk, so the file on disk might be\n\t * broken. Delete it and return an error to the caller. */\n\tif (mg_fclose(&fi.access) != 0) {\n\t\tremove_bad_file(conn, path);\n\t\treturn -14;\n\t}\n\n\treturn len;\n}\n\n\n/* Parse a buffer:\n * Forward the string pointer till the end of a word, then\n * terminate it and forward till the begin of the next word.\n */\nstatic int\nskip_to_end_of_word_and_terminate(char **ppw, int eol)\n{\n\t/* Forward until a space is found - use isgraph here */\n\t/* See http://www.cplusplus.com/reference/cctype/ */\n\twhile (isgraph(**ppw)) {\n\t\t(*ppw)++;\n\t}\n\n\t/* Check end of word */\n\tif (eol) {\n\t\t/* must be a end of line */\n\t\tif ((**ppw != '\\r') && (**ppw != '\\n')) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t/* must be a end of a word, but not a line */\n\t\tif (**ppw != ' ') {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Terminate and forward to the next word */\n\tdo {\n\t\t**ppw = 0;\n\t\t(*ppw)++;\n\t} while ((**ppw) && isspace(**ppw));\n\n\t/* Check after term */\n\tif (!eol) {\n\t\t/* if it's not the end of line, there must be a next word */\n\t\tif (!isgraph(**ppw)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* ok */\n\treturn 1;\n}\n\n\n/* Parse HTTP headers from the given buffer, advance buf pointer\n * to the point where parsing stopped.\n * All parameters must be valid pointers (not NULL).\n * Return <0 on error. */\nstatic int\nparse_http_headers(char **buf, struct mg_header hdr[MG_MAX_HEADERS])\n{\n\tint i;\n\tint num_headers = 0;\n\n\tfor (i = 0; i < (int)MG_MAX_HEADERS; i++) {\n\t\tchar *dp = *buf;\n\t\twhile ((*dp != ':') && (*dp >= 33) && (*dp <= 126)) {\n\t\t\tdp++;\n\t\t}\n\t\tif (dp == *buf) {\n\t\t\t/* End of headers reached. */\n\t\t\tbreak;\n\t\t}\n\t\tif (*dp != ':') {\n\t\t\t/* This is not a valid field. */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* End of header key (*dp == ':') */\n\t\t/* Truncate here and set the key name */\n\t\t*dp = 0;\n\t\thdr[i].name = *buf;\n\t\tdo {\n\t\t\tdp++;\n\t\t} while (*dp == ' ');\n\n\t\t/* The rest of the line is the value */\n\t\thdr[i].value = dp;\n\t\t*buf = dp + strcspn(dp, \"\\r\\n\");\n\t\tif (((*buf)[0] != '\\r') || ((*buf)[1] != '\\n')) {\n\t\t\t*buf = NULL;\n\t\t}\n\n\t\tnum_headers = i + 1;\n\t\tif (*buf) {\n\t\t\t(*buf)[0] = 0;\n\t\t\t(*buf)[1] = 0;\n\t\t\t*buf += 2;\n\t\t} else {\n\t\t\t*buf = dp;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((*buf)[0] == '\\r') {\n\t\t\t/* This is the end of the header */\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn num_headers;\n}\n\n\nstruct mg_http_method_info {\n\tconst char *name;\n\tint request_has_body;\n\tint response_has_body;\n\tint is_safe;\n\tint is_idempotent;\n\tint is_cacheable;\n};\n\n\n/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */\nstatic struct mg_http_method_info http_methods[] = {\n    /* HTTP (RFC 2616) */\n    {\"GET\", 0, 1, 1, 1, 1},\n    {\"POST\", 1, 1, 0, 0, 0},\n    {\"PUT\", 1, 0, 0, 1, 0},\n    {\"DELETE\", 0, 0, 0, 1, 0},\n    {\"HEAD\", 0, 0, 1, 1, 1},\n    {\"OPTIONS\", 0, 0, 1, 1, 0},\n    {\"CONNECT\", 1, 1, 0, 0, 0},\n    /* TRACE method (RFC 2616) is not supported for security reasons */\n\n    /* PATCH method (RFC 5789) */\n    {\"PATCH\", 1, 0, 0, 0, 0},\n    /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */\n\n    /* WEBDAV (RFC 2518) */\n    {\"PROPFIND\", 0, 1, 1, 1, 0},\n    /* http://www.webdav.org/specs/rfc4918.html, 9.1:\n     * Some PROPFIND results MAY be cached, with care,\n     * as there is no cache validation mechanism for\n     * most properties. This method is both safe and\n     * idempotent (see Section 9.1 of [RFC2616]). */\n    {\"MKCOL\", 0, 0, 0, 1, 0},\n    /* http://www.webdav.org/specs/rfc4918.html, 9.1:\n     * When MKCOL is invoked without a request body,\n     * the newly created collection SHOULD have no\n     * members. A MKCOL request message may contain\n     * a message body. The precise behavior of a MKCOL\n     * request when the body is present is undefined,\n     * ... ==> We do not support MKCOL with body data.\n     * This method is idempotent, but not safe (see\n     * Section 9.1 of [RFC2616]). Responses to this\n     * method MUST NOT be cached. */\n\n    /* Unsupported WEBDAV Methods: */\n    /* PROPPATCH, COPY, MOVE, LOCK, UNLOCK (RFC 2518) */\n    /* + 11 methods from RFC 3253 */\n    /* ORDERPATCH (RFC 3648) */\n    /* ACL (RFC 3744) */\n    /* SEARCH (RFC 5323) */\n    /* + MicroSoft extensions\n     * https://msdn.microsoft.com/en-us/library/aa142917.aspx */\n\n    /* REPORT method (RFC 3253) */\n    {\"REPORT\", 1, 1, 1, 1, 1},\n    /* REPORT method only allowed for CGI/Lua/LSP and callbacks. */\n    /* It was defined for WEBDAV in RFC 3253, Sec. 3.6\n     * (https://tools.ietf.org/html/rfc3253#section-3.6), but seems\n     * to be useful for REST in case a \"GET request with body\" is\n     * required. */\n\n    {NULL, 0, 0, 0, 0, 0}\n    /* end of list */\n};\n\n\nstatic const struct mg_http_method_info *\nget_http_method_info(const char *method)\n{\n\t/* Check if the method is known to the server. The list of all known\n\t * HTTP methods can be found here at\n\t * http://www.iana.org/assignments/http-methods/http-methods.xhtml\n\t */\n\tconst struct mg_http_method_info *m = http_methods;\n\n\twhile (m->name) {\n\t\tif (!strcmp(m->name, method)) {\n\t\t\treturn m;\n\t\t}\n\t\tm++;\n\t}\n\treturn NULL;\n}\n\n\nstatic int\nis_valid_http_method(const char *method)\n{\n\treturn (get_http_method_info(method) != NULL);\n}\n\n\n/* Parse HTTP request, fill in mg_request_info structure.\n * This function modifies the buffer by NUL-terminating\n * HTTP request components, header names and header values.\n * Parameters:\n *   buf (in/out): pointer to the HTTP header to parse and split\n *   len (in): length of HTTP header buffer\n *   re (out): parsed header as mg_request_info\n * buf and ri must be valid pointers (not NULL), len>0.\n * Returns <0 on error. */\nstatic int\nparse_http_request(char *buf, int len, struct mg_request_info *ri)\n{\n\tint request_length;\n\tint init_skip = 0;\n\n\t/* Reset attributes. DO NOT TOUCH is_ssl, remote_addr,\n\t * remote_port */\n\tri->remote_user = ri->request_method = ri->request_uri = ri->http_version =\n\t    NULL;\n\tri->num_headers = 0;\n\n\t/* RFC says that all initial whitespaces should be ingored */\n\t/* This included all leading \\r and \\n (isspace) */\n\t/* See table: http://www.cplusplus.com/reference/cctype/ */\n\twhile ((len > 0) && isspace(*(unsigned char *)buf)) {\n\t\tbuf++;\n\t\tlen--;\n\t\tinit_skip++;\n\t}\n\n\tif (len == 0) {\n\t\t/* Incomplete request */\n\t\treturn 0;\n\t}\n\n\t/* Control characters are not allowed, including zero */\n\tif (iscntrl(*(unsigned char *)buf)) {\n\t\treturn -1;\n\t}\n\n\t/* Find end of HTTP header */\n\trequest_length = get_http_header_len(buf, len);\n\tif (request_length <= 0) {\n\t\treturn request_length;\n\t}\n\tbuf[request_length - 1] = '\\0';\n\n\tif ((*buf == 0) || (*buf == '\\r') || (*buf == '\\n')) {\n\t\treturn -1;\n\t}\n\n\t/* The first word has to be the HTTP method */\n\tri->request_method = buf;\n\n\tif (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {\n\t\treturn -1;\n\t}\n\n\t/* Check for a valid http method */\n\tif (!is_valid_http_method(ri->request_method)) {\n\t\treturn -1;\n\t}\n\n\t/* The second word is the URI */\n\tri->request_uri = buf;\n\n\tif (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {\n\t\treturn -1;\n\t}\n\n\t/* Next would be the HTTP version */\n\tri->http_version = buf;\n\n\tif (skip_to_end_of_word_and_terminate(&buf, 1) <= 0) {\n\t\treturn -1;\n\t}\n\n\t/* Check for a valid HTTP version key */\n\tif (strncmp(ri->http_version, \"HTTP/\", 5) != 0) {\n\t\t/* Invalid request */\n\t\treturn -1;\n\t}\n\tri->http_version += 5;\n\n\n\t/* Parse all HTTP headers */\n\tri->num_headers = parse_http_headers(&buf, ri->http_headers);\n\tif (ri->num_headers < 0) {\n\t\t/* Error while parsing headers */\n\t\treturn -1;\n\t}\n\n\treturn request_length + init_skip;\n}\n\n\nstatic int\nparse_http_response(char *buf, int len, struct mg_response_info *ri)\n{\n\tint response_length;\n\tint init_skip = 0;\n\tchar *tmp, *tmp2;\n\tlong l;\n\n\t/* Initialize elements. */\n\tri->http_version = ri->status_text = NULL;\n\tri->num_headers = ri->status_code = 0;\n\n\t/* RFC says that all initial whitespaces should be ingored */\n\t/* This included all leading \\r and \\n (isspace) */\n\t/* See table: http://www.cplusplus.com/reference/cctype/ */\n\twhile ((len > 0) && isspace(*(unsigned char *)buf)) {\n\t\tbuf++;\n\t\tlen--;\n\t\tinit_skip++;\n\t}\n\n\tif (len == 0) {\n\t\t/* Incomplete request */\n\t\treturn 0;\n\t}\n\n\t/* Control characters are not allowed, including zero */\n\tif (iscntrl(*(unsigned char *)buf)) {\n\t\treturn -1;\n\t}\n\n\t/* Find end of HTTP header */\n\tresponse_length = get_http_header_len(buf, len);\n\tif (response_length <= 0) {\n\t\treturn response_length;\n\t}\n\tbuf[response_length - 1] = '\\0';\n\n\tif ((*buf == 0) || (*buf == '\\r') || (*buf == '\\n')) {\n\t\treturn -1;\n\t}\n\n\t/* The first word is the HTTP version */\n\t/* Check for a valid HTTP version key */\n\tif (strncmp(buf, \"HTTP/\", 5) != 0) {\n\t\t/* Invalid request */\n\t\treturn -1;\n\t}\n\tbuf += 5;\n\tif (!isgraph(buf[0])) {\n\t\t/* Invalid request */\n\t\treturn -1;\n\t}\n\tri->http_version = buf;\n\n\tif (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {\n\t\treturn -1;\n\t}\n\n\t/* The second word is the status as a number */\n\ttmp = buf;\n\n\tif (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {\n\t\treturn -1;\n\t}\n\n\tl = strtol(tmp, &tmp2, 10);\n\tif ((l < 100) || (l >= 1000) || ((tmp2 - tmp) != 3) || (*tmp2 != 0)) {\n\t\t/* Everything else but a 3 digit code is invalid */\n\t\treturn -1;\n\t}\n\tri->status_code = (int)l;\n\n\t/* The rest of the line is the status text */\n\tri->status_text = buf;\n\n\t/* Find end of status text */\n\t/* isgraph or isspace = isprint */\n\twhile (isprint(*buf)) {\n\t\tbuf++;\n\t}\n\tif ((*buf != '\\r') && (*buf != '\\n')) {\n\t\treturn -1;\n\t}\n\t/* Terminate string and forward buf to next line */\n\tdo {\n\t\t*buf = 0;\n\t\tbuf++;\n\t} while ((*buf) && isspace(*buf));\n\n\n\t/* Parse all HTTP headers */\n\tri->num_headers = parse_http_headers(&buf, ri->http_headers);\n\tif (ri->num_headers < 0) {\n\t\t/* Error while parsing headers */\n\t\treturn -1;\n\t}\n\n\treturn response_length + init_skip;\n}\n\n\n/* Keep reading the input (either opened file descriptor fd, or socket sock,\n * or SSL descriptor ssl) into buffer buf, until \\r\\n\\r\\n appears in the\n * buffer (which marks the end of HTTP request). Buffer buf may already\n * have some data. The length of the data is stored in nread.\n * Upon every read operation, increase nread by the number of bytes read. */\nstatic int\nread_message(FILE *fp,\n             struct mg_connection *conn,\n             char *buf,\n             int bufsiz,\n             int *nread)\n{\n\tint request_len, n = 0;\n\tstruct timespec last_action_time;\n\tdouble request_timeout;\n\n\tif (!conn) {\n\t\treturn 0;\n\t}\n\n\tmemset(&last_action_time, 0, sizeof(last_action_time));\n\n\tif (conn->dom_ctx->config[REQUEST_TIMEOUT]) {\n\t\t/* value of request_timeout is in seconds, config in milliseconds */\n\t\trequest_timeout = atof(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;\n\t} else {\n\t\trequest_timeout = -1.0;\n\t}\n\tif (conn->handled_requests > 0) {\n\t\tif (conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT]) {\n\t\t\trequest_timeout =\n\t\t\t    atof(conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT]) / 1000.0;\n\t\t}\n\t}\n\n\trequest_len = get_http_header_len(buf, *nread);\n\n\t/* first time reading from this connection */\n\tclock_gettime(CLOCK_MONOTONIC, &last_action_time);\n\n\twhile (request_len == 0) {\n\t\t/* Full request not yet received */\n\t\tif (conn->phys_ctx->stop_flag != 0) {\n\t\t\t/* Server is to be stopped. */\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (*nread >= bufsiz) {\n\t\t\t/* Request too long */\n\t\t\treturn -2;\n\t\t}\n\n\t\tn = pull_inner(\n\t\t    fp, conn, buf + *nread, bufsiz - *nread, request_timeout);\n\t\tif (n == -2) {\n\t\t\t/* Receive error */\n\t\t\treturn -1;\n\t\t}\n\t\tif (n > 0) {\n\t\t\t*nread += n;\n\t\t\trequest_len = get_http_header_len(buf, *nread);\n\t\t} else {\n\t\t\trequest_len = 0;\n\t\t}\n\n\t\tif ((request_len == 0) && (request_timeout >= 0)) {\n\t\t\tif (mg_difftimespec(&last_action_time, &(conn->req_time))\n\t\t\t    > request_timeout) {\n\t\t\t\t/* Timeout */\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tclock_gettime(CLOCK_MONOTONIC, &last_action_time);\n\t\t}\n\t}\n\n\treturn request_len;\n}\n\n\n#if !defined(NO_CGI) || !defined(NO_FILES)\nstatic int\nforward_body_data(struct mg_connection *conn, FILE *fp, SOCKET sock, SSL *ssl)\n{\n\tconst char *expect, *body;\n\tchar buf[MG_BUF_LEN];\n\tint to_read, nread, success = 0;\n\tint64_t buffered_len;\n\tdouble timeout = -1.0;\n\n\tif (!conn) {\n\t\treturn 0;\n\t}\n\tif (conn->dom_ctx->config[REQUEST_TIMEOUT]) {\n\t\ttimeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;\n\t}\n\n\texpect = mg_get_header(conn, \"Expect\");\n\tDEBUG_ASSERT(fp != NULL);\n\tif (!fp) {\n\t\tmg_send_http_error(conn, 500, \"%s\", \"Error: NULL File\");\n\t\treturn 0;\n\t}\n\n\tif ((conn->content_len == -1) && (!conn->is_chunked)) {\n\t\t/* Content length is not specified by the client. */\n\t\tmg_send_http_error(conn,\n\t\t                   411,\n\t\t                   \"%s\",\n\t\t                   \"Error: Client did not specify content length\");\n\t} else if ((expect != NULL)\n\t           && (mg_strcasecmp(expect, \"100-continue\") != 0)) {\n\t\t/* Client sent an \"Expect: xyz\" header and xyz is not 100-continue.\n\t\t */\n\t\tmg_send_http_error(conn,\n\t\t                   417,\n\t\t                   \"Error: Can not fulfill expectation %s\",\n\t\t                   expect);\n\t} else {\n\t\tif (expect != NULL) {\n\t\t\t(void)mg_printf(conn, \"%s\", \"HTTP/1.1 100 Continue\\r\\n\\r\\n\");\n\t\t\tconn->status_code = 100;\n\t\t} else {\n\t\t\tconn->status_code = 200;\n\t\t}\n\n\t\tbuffered_len = (int64_t)(conn->data_len) - (int64_t)conn->request_len\n\t\t               - conn->consumed_content;\n\n\t\tDEBUG_ASSERT(buffered_len >= 0);\n\t\tDEBUG_ASSERT(conn->consumed_content == 0);\n\n\t\tif ((buffered_len < 0) || (conn->consumed_content != 0)) {\n\t\t\tmg_send_http_error(conn, 500, \"%s\", \"Error: Size mismatch\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (buffered_len > 0) {\n\t\t\tif ((int64_t)buffered_len > conn->content_len) {\n\t\t\t\tbuffered_len = (int)conn->content_len;\n\t\t\t}\n\t\t\tbody = conn->buf + conn->request_len + conn->consumed_content;\n\t\t\tpush_all(\n\t\t\t    conn->phys_ctx, fp, sock, ssl, body, (int64_t)buffered_len);\n\t\t\tconn->consumed_content += buffered_len;\n\t\t}\n\n\t\tnread = 0;\n\t\twhile (conn->consumed_content < conn->content_len) {\n\t\t\tto_read = sizeof(buf);\n\t\t\tif ((int64_t)to_read > conn->content_len - conn->consumed_content) {\n\t\t\t\tto_read = (int)(conn->content_len - conn->consumed_content);\n\t\t\t}\n\t\t\tnread = pull_inner(NULL, conn, buf, to_read, timeout);\n\t\t\tif (nread == -2) {\n\t\t\t\t/* error */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nread > 0) {\n\t\t\t\tif (push_all(conn->phys_ctx, fp, sock, ssl, buf, nread)\n\t\t\t\t    != nread) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconn->consumed_content += nread;\n\t\t}\n\n\t\tif (conn->consumed_content == conn->content_len) {\n\t\t\tsuccess = (nread >= 0);\n\t\t}\n\n\t\t/* Each error code path in this function must send an error */\n\t\tif (!success) {\n\t\t\t/* NOTE: Maybe some data has already been sent. */\n\t\t\t/* TODO (low): If some data has been sent, a correct error\n\t\t\t * reply can no longer be sent, so just close the connection */\n\t\t\tmg_send_http_error(conn, 500, \"%s\", \"\");\n\t\t}\n\t}\n\n\treturn success;\n}\n#endif\n\n\n#if defined(USE_TIMERS)\n\n#define TIMER_API static\n#include \"timer.inl\"\n\n#endif /* USE_TIMERS */\n\n\n#if !defined(NO_CGI)\n/* This structure helps to create an environment for the spawned CGI\n * program.\n * Environment is an array of \"VARIABLE=VALUE\\0\" ASCIIZ strings,\n * last element must be NULL.\n * However, on Windows there is a requirement that all these\n * VARIABLE=VALUE\\0\n * strings must reside in a contiguous buffer. The end of the buffer is\n * marked by two '\\0' characters.\n * We satisfy both worlds: we create an envp array (which is vars), all\n * entries are actually pointers inside buf. */\nstruct cgi_environment {\n\tstruct mg_connection *conn;\n\t/* Data block */\n\tchar *buf;      /* Environment buffer */\n\tsize_t buflen;  /* Space available in buf */\n\tsize_t bufused; /* Space taken in buf */\n\t                /* Index block */\n\tchar **var;     /* char **envp */\n\tsize_t varlen;  /* Number of variables available in var */\n\tsize_t varused; /* Number of variables stored in var */\n};\n\n\nstatic void addenv(struct cgi_environment *env,\n                   PRINTF_FORMAT_STRING(const char *fmt),\n                   ...) PRINTF_ARGS(2, 3);\n\n/* Append VARIABLE=VALUE\\0 string to the buffer, and add a respective\n * pointer into the vars array. Assumes env != NULL and fmt != NULL. */\nstatic void\naddenv(struct cgi_environment *env, const char *fmt, ...)\n{\n\tsize_t n, space;\n\tint truncated = 0;\n\tchar *added;\n\tva_list ap;\n\n\t/* Calculate how much space is left in the buffer */\n\tspace = (env->buflen - env->bufused);\n\n\t/* Calculate an estimate for the required space */\n\tn = strlen(fmt) + 2 + 128;\n\n\tdo {\n\t\tif (space <= n) {\n\t\t\t/* Allocate new buffer */\n\t\t\tn = env->buflen + CGI_ENVIRONMENT_SIZE;\n\t\t\tadded = (char *)mg_realloc_ctx(env->buf, n, env->conn->phys_ctx);\n\t\t\tif (!added) {\n\t\t\t\t/* Out of memory */\n\t\t\t\tmg_cry_internal(\n\t\t\t\t    env->conn,\n\t\t\t\t    \"%s: Cannot allocate memory for CGI variable [%s]\",\n\t\t\t\t    __func__,\n\t\t\t\t    fmt);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tenv->buf = added;\n\t\t\tenv->buflen = n;\n\t\t\tspace = (env->buflen - env->bufused);\n\t\t}\n\n\t\t/* Make a pointer to the free space int the buffer */\n\t\tadded = env->buf + env->bufused;\n\n\t\t/* Copy VARIABLE=VALUE\\0 string into the free space */\n\t\tva_start(ap, fmt);\n\t\tmg_vsnprintf(env->conn, &truncated, added, (size_t)space, fmt, ap);\n\t\tva_end(ap);\n\n\t\t/* Do not add truncated strings to the environment */\n\t\tif (truncated) {\n\t\t\t/* Reallocate the buffer */\n\t\t\tspace = 0;\n\t\t\tn = 1;\n\t\t}\n\t} while (truncated);\n\n\t/* Calculate number of bytes added to the environment */\n\tn = strlen(added) + 1;\n\tenv->bufused += n;\n\n\t/* Now update the variable index */\n\tspace = (env->varlen - env->varused);\n\tif (space < 2) {\n\t\tmg_cry_internal(env->conn,\n\t\t                \"%s: Cannot register CGI variable [%s]\",\n\t\t                __func__,\n\t\t                fmt);\n\t\treturn;\n\t}\n\n\t/* Append a pointer to the added string into the envp array */\n\tenv->var[env->varused] = added;\n\tenv->varused++;\n}\n\n/* Return 0 on success, non-zero if an error occurs. */\n\nstatic int\nprepare_cgi_environment(struct mg_connection *conn,\n                        const char *prog,\n                        struct cgi_environment *env)\n{\n\tconst char *s;\n\tstruct vec var_vec;\n\tchar *p, src_addr[IP_ADDR_STR_LEN], http_var_name[128];\n\tint i, truncated, uri_len;\n\n\tif ((conn == NULL) || (prog == NULL) || (env == NULL)) {\n\t\treturn -1;\n\t}\n\n\tenv->conn = conn;\n\tenv->buflen = CGI_ENVIRONMENT_SIZE;\n\tenv->bufused = 0;\n\tenv->buf = (char *)mg_malloc_ctx(env->buflen, conn->phys_ctx);\n\tif (env->buf == NULL) {\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: Not enough memory for environmental buffer\",\n\t\t                __func__);\n\t\treturn -1;\n\t}\n\tenv->varlen = MAX_CGI_ENVIR_VARS;\n\tenv->varused = 0;\n\tenv->var =\n\t    (char **)mg_malloc_ctx(env->buflen * sizeof(char *), conn->phys_ctx);\n\tif (env->var == NULL) {\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: Not enough memory for environmental variables\",\n\t\t                __func__);\n\t\tmg_free(env->buf);\n\t\treturn -1;\n\t}\n\n\taddenv(env, \"SERVER_NAME=%s\", conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);\n\taddenv(env, \"SERVER_ROOT=%s\", conn->dom_ctx->config[DOCUMENT_ROOT]);\n\taddenv(env, \"DOCUMENT_ROOT=%s\", conn->dom_ctx->config[DOCUMENT_ROOT]);\n\taddenv(env, \"SERVER_SOFTWARE=CivetWeb/%s\", mg_version());\n\n\t/* Prepare the environment block */\n\taddenv(env, \"%s\", \"GATEWAY_INTERFACE=CGI/1.1\");\n\taddenv(env, \"%s\", \"SERVER_PROTOCOL=HTTP/1.1\");\n\taddenv(env, \"%s\", \"REDIRECT_STATUS=200\"); /* For PHP */\n\n#if defined(USE_IPV6)\n\tif (conn->client.lsa.sa.sa_family == AF_INET6) {\n\t\taddenv(env, \"SERVER_PORT=%d\", ntohs(conn->client.lsa.sin6.sin6_port));\n\t} else\n#endif\n\t{\n\t\taddenv(env, \"SERVER_PORT=%d\", ntohs(conn->client.lsa.sin.sin_port));\n\t}\n\n\tsockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);\n\taddenv(env, \"REMOTE_ADDR=%s\", src_addr);\n\n\taddenv(env, \"REQUEST_METHOD=%s\", conn->request_info.request_method);\n\taddenv(env, \"REMOTE_PORT=%d\", conn->request_info.remote_port);\n\n\taddenv(env, \"REQUEST_URI=%s\", conn->request_info.request_uri);\n\taddenv(env, \"LOCAL_URI=%s\", conn->request_info.local_uri);\n\n\t/* SCRIPT_NAME */\n\turi_len = (int)strlen(conn->request_info.local_uri);\n\tif (conn->path_info == NULL) {\n\t\tif (conn->request_info.local_uri[uri_len - 1] != '/') {\n\t\t\t/* URI: /path_to_script/script.cgi */\n\t\t\taddenv(env, \"SCRIPT_NAME=%s\", conn->request_info.local_uri);\n\t\t} else {\n\t\t\t/* URI: /path_to_script/ ... using index.cgi */\n\t\t\tconst char *index_file = strrchr(prog, '/');\n\t\t\tif (index_file) {\n\t\t\t\taddenv(env,\n\t\t\t\t       \"SCRIPT_NAME=%s%s\",\n\t\t\t\t       conn->request_info.local_uri,\n\t\t\t\t       index_file + 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* URI: /path_to_script/script.cgi/path_info */\n\t\taddenv(env,\n\t\t       \"SCRIPT_NAME=%.*s\",\n\t\t       uri_len - (int)strlen(conn->path_info),\n\t\t       conn->request_info.local_uri);\n\t}\n\n\taddenv(env, \"SCRIPT_FILENAME=%s\", prog);\n\tif (conn->path_info == NULL) {\n\t\taddenv(env, \"PATH_TRANSLATED=%s\", conn->dom_ctx->config[DOCUMENT_ROOT]);\n\t} else {\n\t\taddenv(env,\n\t\t       \"PATH_TRANSLATED=%s%s\",\n\t\t       conn->dom_ctx->config[DOCUMENT_ROOT],\n\t\t       conn->path_info);\n\t}\n\n\taddenv(env, \"HTTPS=%s\", (conn->ssl == NULL) ? \"off\" : \"on\");\n\n\tif ((s = mg_get_header(conn, \"Content-Type\")) != NULL) {\n\t\taddenv(env, \"CONTENT_TYPE=%s\", s);\n\t}\n\tif (conn->request_info.query_string != NULL) {\n\t\taddenv(env, \"QUERY_STRING=%s\", conn->request_info.query_string);\n\t}\n\tif ((s = mg_get_header(conn, \"Content-Length\")) != NULL) {\n\t\taddenv(env, \"CONTENT_LENGTH=%s\", s);\n\t}\n\tif ((s = getenv(\"PATH\")) != NULL) {\n\t\taddenv(env, \"PATH=%s\", s);\n\t}\n\tif (conn->path_info != NULL) {\n\t\taddenv(env, \"PATH_INFO=%s\", conn->path_info);\n\t}\n\n\tif (conn->status_code > 0) {\n\t\t/* CGI error handler should show the status code */\n\t\taddenv(env, \"STATUS=%d\", conn->status_code);\n\t}\n\n#if defined(_WIN32)\n\tif ((s = getenv(\"COMSPEC\")) != NULL) {\n\t\taddenv(env, \"COMSPEC=%s\", s);\n\t}\n\tif ((s = getenv(\"SYSTEMROOT\")) != NULL) {\n\t\taddenv(env, \"SYSTEMROOT=%s\", s);\n\t}\n\tif ((s = getenv(\"SystemDrive\")) != NULL) {\n\t\taddenv(env, \"SystemDrive=%s\", s);\n\t}\n\tif ((s = getenv(\"ProgramFiles\")) != NULL) {\n\t\taddenv(env, \"ProgramFiles=%s\", s);\n\t}\n\tif ((s = getenv(\"ProgramFiles(x86)\")) != NULL) {\n\t\taddenv(env, \"ProgramFiles(x86)=%s\", s);\n\t}\n#else\n\tif ((s = getenv(\"LD_LIBRARY_PATH\")) != NULL) {\n\t\taddenv(env, \"LD_LIBRARY_PATH=%s\", s);\n\t}\n#endif /* _WIN32 */\n\n\tif ((s = getenv(\"PERLLIB\")) != NULL) {\n\t\taddenv(env, \"PERLLIB=%s\", s);\n\t}\n\n\tif (conn->request_info.remote_user != NULL) {\n\t\taddenv(env, \"REMOTE_USER=%s\", conn->request_info.remote_user);\n\t\taddenv(env, \"%s\", \"AUTH_TYPE=Digest\");\n\t}\n\n\t/* Add all headers as HTTP_* variables */\n\tfor (i = 0; i < conn->request_info.num_headers; i++) {\n\n\t\t(void)mg_snprintf(conn,\n\t\t                  &truncated,\n\t\t                  http_var_name,\n\t\t                  sizeof(http_var_name),\n\t\t                  \"HTTP_%s\",\n\t\t                  conn->request_info.http_headers[i].name);\n\n\t\tif (truncated) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: HTTP header variable too long [%s]\",\n\t\t\t                __func__,\n\t\t\t                conn->request_info.http_headers[i].name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Convert variable name into uppercase, and change - to _ */\n\t\tfor (p = http_var_name; *p != '\\0'; p++) {\n\t\t\tif (*p == '-') {\n\t\t\t\t*p = '_';\n\t\t\t}\n\t\t\t*p = (char)toupper(*(unsigned char *)p);\n\t\t}\n\n\t\taddenv(env,\n\t\t       \"%s=%s\",\n\t\t       http_var_name,\n\t\t       conn->request_info.http_headers[i].value);\n\t}\n\n\t/* Add user-specified variables */\n\ts = conn->dom_ctx->config[CGI_ENVIRONMENT];\n\twhile ((s = next_option(s, &var_vec, NULL)) != NULL) {\n\t\taddenv(env, \"%.*s\", (int)var_vec.len, var_vec.ptr);\n\t}\n\n\tenv->var[env->varused] = NULL;\n\tenv->buf[env->bufused] = '\\0';\n\n\treturn 0;\n}\n\n\n/* Data for CGI process control: PID and number of references */\nstruct process_control_data {\n\tpid_t pid;\n\tint references;\n};\n\nstatic int\nabort_process(void *data)\n{\n\t/* Waitpid checks for child status and won't work for a pid that does not\n\t * identify a child of the current process. Thus, if the pid is reused,\n\t * we will not affect a different process. */\n\tstruct process_control_data *proc = (struct process_control_data *)data;\n\tint status = 0;\n\tint refs;\n\tpid_t ret_pid;\n\n\tret_pid = waitpid(proc->pid, &status, WNOHANG);\n\tif ((ret_pid != (pid_t)-1) && (status == 0)) {\n\t\t/* Stop child process */\n\t\tDEBUG_TRACE(\"CGI timer: Stop child process %p\\n\", proc->pid);\n\t\tkill(proc->pid, SIGABRT);\n\n\t\t/* Wait until process is terminated (don't leave zombies) */\n\t\twhile (waitpid(proc->pid, &status, 0) != (pid_t)-1) /* nop */\n\t\t\t;\n\t} else {\n\t\tDEBUG_TRACE(\"CGI timer: Child process %p already stopped\\n\", proc->pid);\n\t}\n\t/* Dec reference counter */\n\trefs = mg_atomic_dec(&proc->references);\n\tif (refs == 0) {\n\t\t/* no more references - free data */\n\t\tmg_free(data);\n\t}\n\n\treturn 0;\n}\n\n\nstatic void\nhandle_cgi_request(struct mg_connection *conn, const char *prog)\n{\n\tchar *buf;\n\tsize_t buflen;\n\tint headers_len, data_len, i, truncated;\n\tint fdin[2] = {-1, -1}, fdout[2] = {-1, -1}, fderr[2] = {-1, -1};\n\tconst char *status, *status_text, *connection_state;\n\tchar *pbuf, dir[PATH_MAX], *p;\n\tstruct mg_request_info ri;\n\tstruct cgi_environment blk;\n\tFILE *in = NULL, *out = NULL, *err = NULL;\n\tstruct mg_file fout = STRUCT_FILE_INITIALIZER;\n\tpid_t pid = (pid_t)-1;\n\tstruct process_control_data *proc = NULL;\n\n#if defined(USE_TIMERS)\n\tdouble cgi_timeout = -1.0;\n\tif (conn->dom_ctx->config[CGI_TIMEOUT]) {\n\t\t/* Get timeout in seconds */\n\t\tcgi_timeout = atof(conn->dom_ctx->config[CGI_TIMEOUT]) * 0.001;\n\t}\n#endif\n\n\tif (conn == NULL) {\n\t\treturn;\n\t}\n\n\tbuf = NULL;\n\tbuflen = conn->phys_ctx->max_request_size;\n\ti = prepare_cgi_environment(conn, prog, &blk);\n\tif (i != 0) {\n\t\tblk.buf = NULL;\n\t\tblk.var = NULL;\n\t\tgoto done;\n\t}\n\n\t/* CGI must be executed in its own directory. 'dir' must point to the\n\t * directory containing executable program, 'p' must point to the\n\t * executable program name relative to 'dir'. */\n\t(void)mg_snprintf(conn, &truncated, dir, sizeof(dir), \"%s\", prog);\n\n\tif (truncated) {\n\t\tmg_cry_internal(conn, \"Error: CGI program \\\"%s\\\": Path too long\", prog);\n\t\tmg_send_http_error(conn, 500, \"Error: %s\", \"CGI path too long\");\n\t\tgoto done;\n\t}\n\n\tif ((p = strrchr(dir, '/')) != NULL) {\n\t\t*p++ = '\\0';\n\t} else {\n\t\tdir[0] = '.';\n\t\tdir[1] = '\\0';\n\t\tp = (char *)prog;\n\t}\n\n\tif ((pipe(fdin) != 0) || (pipe(fdout) != 0) || (pipe(fderr) != 0)) {\n\t\tstatus = strerror(ERRNO);\n\t\tmg_cry_internal(\n\t\t    conn,\n\t\t    \"Error: CGI program \\\"%s\\\": Can not create CGI pipes: %s\",\n\t\t    prog,\n\t\t    status);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Cannot create CGI pipe: %s\",\n\t\t                   status);\n\t\tgoto done;\n\t}\n\n\tproc = (struct process_control_data *)\n\t    mg_malloc_ctx(sizeof(struct process_control_data), conn->phys_ctx);\n\tif (proc == NULL) {\n\t\tmg_cry_internal(conn, \"Error: CGI program \\\"%s\\\": Out or memory\", prog);\n\t\tmg_send_http_error(conn, 500, \"Error: Out of memory [%s]\", prog);\n\t\tgoto done;\n\t}\n\n\tDEBUG_TRACE(\"CGI: spawn %s %s\\n\", dir, p);\n\tpid = spawn_process(conn, p, blk.buf, blk.var, fdin, fdout, fderr, dir);\n\n\tif (pid == (pid_t)-1) {\n\t\tstatus = strerror(ERRNO);\n\t\tmg_cry_internal(\n\t\t    conn,\n\t\t    \"Error: CGI program \\\"%s\\\": Can not spawn CGI process: %s\",\n\t\t    prog,\n\t\t    status);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Cannot spawn CGI process [%s]: %s\",\n\t\t                   prog,\n\t\t                   status);\n\t\tmg_free(proc);\n\t\tproc = NULL;\n\t\tgoto done;\n\t}\n\n\t/* Store data in shared process_control_data */\n\tproc->pid = pid;\n\tproc->references = 1;\n\n#if defined(USE_TIMERS)\n\tif (cgi_timeout > 0.0) {\n\t\tproc->references = 2;\n\n\t\t// Start a timer for CGI\n\t\ttimer_add(conn->phys_ctx,\n\t\t          cgi_timeout /* in seconds */,\n\t\t          0.0,\n\t\t          1,\n\t\t          abort_process,\n\t\t          (void *)proc);\n\t}\n#endif\n\n\t/* Make sure child closes all pipe descriptors. It must dup them to 0,1 */\n\tset_close_on_exec((SOCKET)fdin[0], conn);  /* stdin read */\n\tset_close_on_exec((SOCKET)fdin[1], conn);  /* stdin write */\n\tset_close_on_exec((SOCKET)fdout[0], conn); /* stdout read */\n\tset_close_on_exec((SOCKET)fdout[1], conn); /* stdout write */\n\tset_close_on_exec((SOCKET)fderr[0], conn); /* stderr read */\n\tset_close_on_exec((SOCKET)fderr[1], conn); /* stderr write */\n\n\t/* Parent closes only one side of the pipes.\n\t * If we don't mark them as closed, close() attempt before\n\t * return from this function throws an exception on Windows.\n\t * Windows does not like when closed descriptor is closed again. */\n\t(void)close(fdin[0]);\n\t(void)close(fdout[1]);\n\t(void)close(fderr[1]);\n\tfdin[0] = fdout[1] = fderr[1] = -1;\n\n\tif ((in = fdopen(fdin[1], \"wb\")) == NULL) {\n\t\tstatus = strerror(ERRNO);\n\t\tmg_cry_internal(conn,\n\t\t                \"Error: CGI program \\\"%s\\\": Can not open stdin: %s\",\n\t\t                prog,\n\t\t                status);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: CGI can not open fdin\\nfopen: %s\",\n\t\t                   status);\n\t\tgoto done;\n\t}\n\n\tif ((out = fdopen(fdout[0], \"rb\")) == NULL) {\n\t\tstatus = strerror(ERRNO);\n\t\tmg_cry_internal(conn,\n\t\t                \"Error: CGI program \\\"%s\\\": Can not open stdout: %s\",\n\t\t                prog,\n\t\t                status);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: CGI can not open fdout\\nfopen: %s\",\n\t\t                   status);\n\t\tgoto done;\n\t}\n\n\tif ((err = fdopen(fderr[0], \"rb\")) == NULL) {\n\t\tstatus = strerror(ERRNO);\n\t\tmg_cry_internal(conn,\n\t\t                \"Error: CGI program \\\"%s\\\": Can not open stderr: %s\",\n\t\t                prog,\n\t\t                status);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: CGI can not open fderr\\nfopen: %s\",\n\t\t                   status);\n\t\tgoto done;\n\t}\n\n\tsetbuf(in, NULL);\n\tsetbuf(out, NULL);\n\tsetbuf(err, NULL);\n\tfout.access.fp = out;\n\n\tif ((conn->request_info.content_length != 0) || (conn->is_chunked)) {\n\t\tDEBUG_TRACE(\"CGI: send body data (%lli)\\n\",\n\t\t            (signed long long)conn->request_info.content_length);\n\n\t\t/* This is a POST/PUT request, or another request with body data. */\n\t\tif (!forward_body_data(conn, in, INVALID_SOCKET, NULL)) {\n\t\t\t/* Error sending the body data */\n\t\t\tmg_cry_internal(\n\t\t\t    conn,\n\t\t\t    \"Error: CGI program \\\"%s\\\": Forward body data failed\",\n\t\t\t    prog);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Close so child gets an EOF. */\n\tfclose(in);\n\tin = NULL;\n\tfdin[1] = -1;\n\n\t/* Now read CGI reply into a buffer. We need to set correct\n\t * status code, thus we need to see all HTTP headers first.\n\t * Do not send anything back to client, until we buffer in all\n\t * HTTP headers. */\n\tdata_len = 0;\n\tbuf = (char *)mg_malloc_ctx(buflen, conn->phys_ctx);\n\tif (buf == NULL) {\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Not enough memory for CGI buffer (%u bytes)\",\n\t\t                   (unsigned int)buflen);\n\t\tmg_cry_internal(\n\t\t    conn,\n\t\t    \"Error: CGI program \\\"%s\\\": Not enough memory for buffer (%u \"\n\t\t    \"bytes)\",\n\t\t    prog,\n\t\t    (unsigned int)buflen);\n\t\tgoto done;\n\t}\n\n\tDEBUG_TRACE(\"CGI: %s\", \"wait for response\");\n\theaders_len = read_message(out, conn, buf, (int)buflen, &data_len);\n\tDEBUG_TRACE(\"CGI: response: %li\", (signed long)headers_len);\n\n\tif (headers_len <= 0) {\n\n\t\t/* Could not parse the CGI response. Check if some error message on\n\t\t * stderr. */\n\t\ti = pull_all(err, conn, buf, (int)buflen);\n\t\tif (i > 0) {\n\t\t\t/* CGI program explicitly sent an error */\n\t\t\t/* Write the error message to the internal log */\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Error: CGI program \\\"%s\\\" sent error \"\n\t\t\t                \"message: [%.*s]\",\n\t\t\t                prog,\n\t\t\t                i,\n\t\t\t                buf);\n\t\t\t/* Don't send the error message back to the client */\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   500,\n\t\t\t                   \"Error: CGI program \\\"%s\\\" failed.\",\n\t\t\t                   prog);\n\t\t} else {\n\t\t\t/* CGI program did not explicitly send an error, but a broken\n\t\t\t * respon header */\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Error: CGI program sent malformed or too big \"\n\t\t\t                \"(>%u bytes) HTTP headers: [%.*s]\",\n\t\t\t                (unsigned)buflen,\n\t\t\t                data_len,\n\t\t\t                buf);\n\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   500,\n\t\t\t                   \"Error: CGI program sent malformed or too big \"\n\t\t\t                   \"(>%u bytes) HTTP headers: [%.*s]\",\n\t\t\t                   (unsigned)buflen,\n\t\t\t                   data_len,\n\t\t\t                   buf);\n\t\t}\n\n\t\t/* in both cases, abort processing CGI */\n\t\tgoto done;\n\t}\n\n\tpbuf = buf;\n\tbuf[headers_len - 1] = '\\0';\n\tri.num_headers = parse_http_headers(&pbuf, ri.http_headers);\n\n\t/* Make up and send the status line */\n\tstatus_text = \"OK\";\n\tif ((status = get_header(ri.http_headers, ri.num_headers, \"Status\"))\n\t    != NULL) {\n\t\tconn->status_code = atoi(status);\n\t\tstatus_text = status;\n\t\twhile (isdigit(*(const unsigned char *)status_text)\n\t\t       || *status_text == ' ') {\n\t\t\tstatus_text++;\n\t\t}\n\t} else if (get_header(ri.http_headers, ri.num_headers, \"Location\")\n\t           != NULL) {\n\t\tconn->status_code = 307;\n\t} else {\n\t\tconn->status_code = 200;\n\t}\n\tconnection_state =\n\t    get_header(ri.http_headers, ri.num_headers, \"Connection\");\n\tif (!header_has_option(connection_state, \"keep-alive\")) {\n\t\tconn->must_close = 1;\n\t}\n\n\tDEBUG_TRACE(\"CGI: response %u %s\", conn->status_code, status_text);\n\n\t(void)mg_printf(conn, \"HTTP/1.1 %d %s\\r\\n\", conn->status_code, status_text);\n\n\t/* Send headers */\n\tfor (i = 0; i < ri.num_headers; i++) {\n\t\tmg_printf(conn,\n\t\t          \"%s: %s\\r\\n\",\n\t\t          ri.http_headers[i].name,\n\t\t          ri.http_headers[i].value);\n\t}\n\tmg_write(conn, \"\\r\\n\", 2);\n\n\t/* Send chunk of data that may have been read after the headers */\n\tmg_write(conn, buf + headers_len, (size_t)(data_len - headers_len));\n\n\t/* Read the rest of CGI output and send to the client */\n\tDEBUG_TRACE(\"CGI: %s\", \"forward all data\");\n\tsend_file_data(conn, &fout, 0, INT64_MAX);\n\tDEBUG_TRACE(\"CGI: %s\", \"all data sent\");\n\ndone:\n\tmg_free(blk.var);\n\tmg_free(blk.buf);\n\n\tif (pid != (pid_t)-1) {\n\t\tabort_process((void *)proc);\n\t}\n\n\tif (fdin[0] != -1) {\n\t\tclose(fdin[0]);\n\t}\n\tif (fdout[1] != -1) {\n\t\tclose(fdout[1]);\n\t}\n\n\tif (in != NULL) {\n\t\tfclose(in);\n\t} else if (fdin[1] != -1) {\n\t\tclose(fdin[1]);\n\t}\n\n\tif (out != NULL) {\n\t\tfclose(out);\n\t} else if (fdout[0] != -1) {\n\t\tclose(fdout[0]);\n\t}\n\n\tif (err != NULL) {\n\t\tfclose(err);\n\t} else if (fderr[0] != -1) {\n\t\tclose(fderr[0]);\n\t}\n\n\tif (buf != NULL) {\n\t\tmg_free(buf);\n\t}\n}\n#endif /* !NO_CGI */\n\n\n#if !defined(NO_FILES)\nstatic void\nmkcol(struct mg_connection *conn, const char *path)\n{\n\tint rc, body_len;\n\tstruct de de;\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tif (conn == NULL) {\n\t\treturn;\n\t}\n\n\t/* TODO (mid): Check the mg_send_http_error situations in this function\n\t */\n\n\tmemset(&de.file, 0, sizeof(de.file));\n\tif (!mg_stat(conn, path, &de.file)) {\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: mg_stat(%s) failed: %s\",\n\t\t                __func__,\n\t\t                path,\n\t\t                strerror(ERRNO));\n\t}\n\n\tif (de.file.last_modified) {\n\t\t/* TODO (mid): This check does not seem to make any sense ! */\n\t\t/* TODO (mid): Add a webdav unit test first, before changing\n\t\t * anything here. */\n\t\tmg_send_http_error(\n\t\t    conn, 405, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));\n\t\treturn;\n\t}\n\n\tbody_len = conn->data_len - conn->request_len;\n\tif (body_len > 0) {\n\t\tmg_send_http_error(\n\t\t    conn, 415, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));\n\t\treturn;\n\t}\n\n\trc = mg_mkdir(conn, path, 0755);\n\n\tif (rc == 0) {\n\t\tconn->status_code = 201;\n\t\tgmt_time_string(date, sizeof(date), &curtime);\n\t\tmg_printf(conn,\n\t\t          \"HTTP/1.1 %d Created\\r\\n\"\n\t\t          \"Date: %s\\r\\n\",\n\t\t          conn->status_code,\n\t\t          date);\n\t\tsend_static_cache_header(conn);\n\t\tsend_additional_header(conn);\n\t\tmg_printf(conn,\n\t\t          \"Content-Length: 0\\r\\n\"\n\t\t          \"Connection: %s\\r\\n\\r\\n\",\n\t\t          suggest_connection_header(conn));\n\t} else {\n\t\tif (errno == EEXIST) {\n\t\t\tmg_send_http_error(\n\t\t\t    conn, 405, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));\n\t\t} else if (errno == EACCES) {\n\t\t\tmg_send_http_error(\n\t\t\t    conn, 403, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));\n\t\t} else if (errno == ENOENT) {\n\t\t\tmg_send_http_error(\n\t\t\t    conn, 409, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));\n\t\t} else {\n\t\t\tmg_send_http_error(\n\t\t\t    conn, 500, \"fopen(%s): %s\", path, strerror(ERRNO));\n\t\t}\n\t}\n}\n\n\nstatic void\nput_file(struct mg_connection *conn, const char *path)\n{\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tconst char *range;\n\tint64_t r1, r2;\n\tint rc;\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tif (conn == NULL) {\n\t\treturn;\n\t}\n\n\tif (mg_stat(conn, path, &file.stat)) {\n\t\t/* File already exists */\n\t\tconn->status_code = 200;\n\n\t\tif (file.stat.is_directory) {\n\t\t\t/* This is an already existing directory,\n\t\t\t * so there is nothing to do for the server. */\n\t\t\trc = 0;\n\n\t\t} else {\n\t\t\t/* File exists and is not a directory. */\n\t\t\t/* Can it be replaced? */\n\n#if defined(MG_USE_OPEN_FILE)\n\t\t\tif (file.access.membuf != NULL) {\n\t\t\t\t/* This is an \"in-memory\" file, that can not be replaced */\n\t\t\t\tmg_send_http_error(conn,\n\t\t\t\t                   405,\n\t\t\t\t                   \"Error: Put not possible\\nReplacing %s \"\n\t\t\t\t                   \"is not supported\",\n\t\t\t\t                   path);\n\t\t\t\treturn;\n\t\t\t}\n#endif\n\n\t\t\t/* Check if the server may write this file */\n\t\t\tif (access(path, W_OK) == 0) {\n\t\t\t\t/* Access granted */\n\t\t\t\tconn->status_code = 200;\n\t\t\t\trc = 1;\n\t\t\t} else {\n\t\t\t\tmg_send_http_error(\n\t\t\t\t    conn,\n\t\t\t\t    403,\n\t\t\t\t    \"Error: Put not possible\\nReplacing %s is not allowed\",\n\t\t\t\t    path);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* File should be created */\n\t\tconn->status_code = 201;\n\t\trc = put_dir(conn, path);\n\t}\n\n\tif (rc == 0) {\n\t\t/* put_dir returns 0 if path is a directory */\n\t\tgmt_time_string(date, sizeof(date), &curtime);\n\t\tmg_printf(conn,\n\t\t          \"HTTP/1.1 %d %s\\r\\n\",\n\t\t          conn->status_code,\n\t\t          mg_get_response_code_text(NULL, conn->status_code));\n\t\tsend_no_cache_header(conn);\n\t\tsend_additional_header(conn);\n\t\tmg_printf(conn,\n\t\t          \"Date: %s\\r\\n\"\n\t\t          \"Content-Length: 0\\r\\n\"\n\t\t          \"Connection: %s\\r\\n\\r\\n\",\n\t\t          date,\n\t\t          suggest_connection_header(conn));\n\n\t\t/* Request to create a directory has been fulfilled successfully.\n\t\t * No need to put a file. */\n\t\treturn;\n\t}\n\n\tif (rc == -1) {\n\t\t/* put_dir returns -1 if the path is too long */\n\t\tmg_send_http_error(conn,\n\t\t                   414,\n\t\t                   \"Error: Path too long\\nput_dir(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t\treturn;\n\t}\n\n\tif (rc == -2) {\n\t\t/* put_dir returns -2 if the directory can not be created */\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Can not create directory\\nput_dir(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t\treturn;\n\t}\n\n\t/* A file should be created or overwritten. */\n\t/* Currently CivetWeb does not nead read+write access. */\n\tif (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file)\n\t    || file.access.fp == NULL) {\n\t\t(void)mg_fclose(&file.access);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Can not create file\\nfopen(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t\treturn;\n\t}\n\n\tfclose_on_exec(&file.access, conn);\n\trange = mg_get_header(conn, \"Content-Range\");\n\tr1 = r2 = 0;\n\tif ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {\n\t\tconn->status_code = 206; /* Partial content */\n\t\tfseeko(file.access.fp, r1, SEEK_SET);\n\t}\n\n\tif (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {\n\t\t/* forward_body_data failed.\n\t\t * The error code has already been sent to the client,\n\t\t * and conn->status_code is already set. */\n\t\t(void)mg_fclose(&file.access);\n\t\treturn;\n\t}\n\n\tif (mg_fclose(&file.access) != 0) {\n\t\t/* fclose failed. This might have different reasons, but a likely\n\t\t * one is \"no space on disk\", http 507. */\n\t\tconn->status_code = 507;\n\t}\n\n\tgmt_time_string(date, sizeof(date), &curtime);\n\tmg_printf(conn,\n\t          \"HTTP/1.1 %d %s\\r\\n\",\n\t          conn->status_code,\n\t          mg_get_response_code_text(NULL, conn->status_code));\n\tsend_no_cache_header(conn);\n\tsend_additional_header(conn);\n\tmg_printf(conn,\n\t          \"Date: %s\\r\\n\"\n\t          \"Content-Length: 0\\r\\n\"\n\t          \"Connection: %s\\r\\n\\r\\n\",\n\t          date,\n\t          suggest_connection_header(conn));\n}\n\n\nstatic void\ndelete_file(struct mg_connection *conn, const char *path)\n{\n\tstruct de de;\n\tmemset(&de.file, 0, sizeof(de.file));\n\tif (!mg_stat(conn, path, &de.file)) {\n\t\t/* mg_stat returns 0 if the file does not exist */\n\t\tmg_send_http_error(conn,\n\t\t                   404,\n\t\t                   \"Error: Cannot delete file\\nFile %s not found\",\n\t\t                   path);\n\t\treturn;\n\t}\n\n#if 0 /* Ignore if a file in memory is inside a folder */\n        if (de.access.membuf != NULL) {\n                /* the file is cached in memory */\n                mg_send_http_error(\n                    conn,\n                    405,\n                    \"Error: Delete not possible\\nDeleting %s is not supported\",\n                    path);\n                return;\n        }\n#endif\n\n\tif (de.file.is_directory) {\n\t\tif (remove_directory(conn, path)) {\n\t\t\t/* Delete is successful: Return 204 without content. */\n\t\t\tmg_send_http_error(conn, 204, \"%s\", \"\");\n\t\t} else {\n\t\t\t/* Delete is not successful: Return 500 (Server error). */\n\t\t\tmg_send_http_error(conn, 500, \"Error: Could not delete %s\", path);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* This is an existing file (not a directory).\n\t * Check if write permission is granted. */\n\tif (access(path, W_OK) != 0) {\n\t\t/* File is read only */\n\t\tmg_send_http_error(\n\t\t    conn,\n\t\t    403,\n\t\t    \"Error: Delete not possible\\nDeleting %s is not allowed\",\n\t\t    path);\n\t\treturn;\n\t}\n\n\t/* Try to delete it. */\n\tif (mg_remove(conn, path) == 0) {\n\t\t/* Delete was successful: Return 204 without content. */\n\t\tmg_send_http_error(conn, 204, \"%s\", \"\");\n\t} else {\n\t\t/* Delete not successful (file locked). */\n\t\tmg_send_http_error(conn,\n\t\t                   423,\n\t\t                   \"Error: Cannot delete file\\nremove(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t}\n}\n#endif /* !NO_FILES */\n\n\nstatic void\nsend_ssi_file(struct mg_connection *, const char *, struct mg_file *, int);\n\n\nstatic void\ndo_ssi_include(struct mg_connection *conn,\n               const char *ssi,\n               char *tag,\n               int include_level)\n{\n\tchar file_name[MG_BUF_LEN], path[512], *p;\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tsize_t len;\n\tint truncated = 0;\n\n\tif (conn == NULL) {\n\t\treturn;\n\t}\n\n\t/* sscanf() is safe here, since send_ssi_file() also uses buffer\n\t * of size MG_BUF_LEN to get the tag. So strlen(tag) is\n\t * always < MG_BUF_LEN. */\n\tif (sscanf(tag, \" virtual=\\\"%511[^\\\"]\\\"\", file_name) == 1) {\n\t\t/* File name is relative to the webserver root */\n\t\tfile_name[511] = 0;\n\t\t(void)mg_snprintf(conn,\n\t\t                  &truncated,\n\t\t                  path,\n\t\t                  sizeof(path),\n\t\t                  \"%s/%s\",\n\t\t                  conn->dom_ctx->config[DOCUMENT_ROOT],\n\t\t                  file_name);\n\n\t} else if (sscanf(tag, \" abspath=\\\"%511[^\\\"]\\\"\", file_name) == 1) {\n\t\t/* File name is relative to the webserver working directory\n\t\t * or it is absolute system path */\n\t\tfile_name[511] = 0;\n\t\t(void)\n\t\t    mg_snprintf(conn, &truncated, path, sizeof(path), \"%s\", file_name);\n\n\t} else if ((sscanf(tag, \" file=\\\"%511[^\\\"]\\\"\", file_name) == 1)\n\t           || (sscanf(tag, \" \\\"%511[^\\\"]\\\"\", file_name) == 1)) {\n\t\t/* File name is relative to the currect document */\n\t\tfile_name[511] = 0;\n\t\t(void)mg_snprintf(conn, &truncated, path, sizeof(path), \"%s\", ssi);\n\n\t\tif (!truncated) {\n\t\t\tif ((p = strrchr(path, '/')) != NULL) {\n\t\t\t\tp[1] = '\\0';\n\t\t\t}\n\t\t\tlen = strlen(path);\n\t\t\t(void)mg_snprintf(conn,\n\t\t\t                  &truncated,\n\t\t\t                  path + len,\n\t\t\t                  sizeof(path) - len,\n\t\t\t                  \"%s\",\n\t\t\t                  file_name);\n\t\t}\n\n\t} else {\n\t\tmg_cry_internal(conn, \"Bad SSI #include: [%s]\", tag);\n\t\treturn;\n\t}\n\n\tif (truncated) {\n\t\tmg_cry_internal(conn, \"SSI #include path length overflow: [%s]\", tag);\n\t\treturn;\n\t}\n\n\tif (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {\n\t\tmg_cry_internal(conn,\n\t\t                \"Cannot open SSI #include: [%s]: fopen(%s): %s\",\n\t\t                tag,\n\t\t                path,\n\t\t                strerror(ERRNO));\n\t} else {\n\t\tfclose_on_exec(&file.access, conn);\n\t\tif (match_prefix(conn->dom_ctx->config[SSI_EXTENSIONS],\n\t\t                 strlen(conn->dom_ctx->config[SSI_EXTENSIONS]),\n\t\t                 path)\n\t\t    > 0) {\n\t\t\tsend_ssi_file(conn, path, &file, include_level + 1);\n\t\t} else {\n\t\t\tsend_file_data(conn, &file, 0, INT64_MAX);\n\t\t}\n\t\t(void)mg_fclose(&file.access); /* Ignore errors for readonly files */\n\t}\n}\n\n\n#if !defined(NO_POPEN)\nstatic void\ndo_ssi_exec(struct mg_connection *conn, char *tag)\n{\n\tchar cmd[1024] = \"\";\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\n\tif (sscanf(tag, \" \\\"%1023[^\\\"]\\\"\", cmd) != 1) {\n\t\tmg_cry_internal(conn, \"Bad SSI #exec: [%s]\", tag);\n\t} else {\n\t\tcmd[1023] = 0;\n\t\tif ((file.access.fp = popen(cmd, \"r\")) == NULL) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Cannot SSI #exec: [%s]: %s\",\n\t\t\t                cmd,\n\t\t\t                strerror(ERRNO));\n\t\t} else {\n\t\t\tsend_file_data(conn, &file, 0, INT64_MAX);\n\t\t\tpclose(file.access.fp);\n\t\t}\n\t}\n}\n#endif /* !NO_POPEN */\n\n\nstatic int\nmg_fgetc(struct mg_file *filep, int offset)\n{\n\t(void)offset; /* unused in case MG_USE_OPEN_FILE is set */\n\n\tif (filep == NULL) {\n\t\treturn EOF;\n\t}\n#if defined(MG_USE_OPEN_FILE)\n\tif ((filep->access.membuf != NULL) && (offset >= 0)\n\t    && (((unsigned int)(offset)) < filep->stat.size)) {\n\t\treturn ((const unsigned char *)filep->access.membuf)[offset];\n\t} else /* else block below */\n#endif\n\t    if (filep->access.fp != NULL) {\n\t\treturn fgetc(filep->access.fp);\n\t} else {\n\t\treturn EOF;\n\t}\n}\n\n\nstatic void\nsend_ssi_file(struct mg_connection *conn,\n              const char *path,\n              struct mg_file *filep,\n              int include_level)\n{\n\tchar buf[MG_BUF_LEN];\n\tint ch, offset, len, in_tag, in_ssi_tag;\n\n\tif (include_level > 10) {\n\t\tmg_cry_internal(conn, \"SSI #include level is too deep (%s)\", path);\n\t\treturn;\n\t}\n\n\tin_tag = in_ssi_tag = len = offset = 0;\n\n\t/* Read file, byte by byte, and look for SSI include tags */\n\twhile ((ch = mg_fgetc(filep, offset++)) != EOF) {\n\n\t\tif (in_tag) {\n\t\t\t/* We are in a tag, either SSI tag or html tag */\n\n\t\t\tif (ch == '>') {\n\t\t\t\t/* Tag is closing */\n\t\t\t\tbuf[len++] = '>';\n\n\t\t\t\tif (in_ssi_tag) {\n\t\t\t\t\t/* Handle SSI tag */\n\t\t\t\t\tbuf[len] = 0;\n\n\t\t\t\t\tif ((len > 12) && !memcmp(buf + 5, \"include\", 7)) {\n\t\t\t\t\t\tdo_ssi_include(conn, path, buf + 12, include_level + 1);\n#if !defined(NO_POPEN)\n\t\t\t\t\t} else if ((len > 9) && !memcmp(buf + 5, \"exec\", 4)) {\n\t\t\t\t\t\tdo_ssi_exec(conn, buf + 9);\n#endif /* !NO_POPEN */\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t\t\t                \"%s: unknown SSI \"\n\t\t\t\t\t\t                \"command: \\\"%s\\\"\",\n\t\t\t\t\t\t                path,\n\t\t\t\t\t\t                buf);\n\t\t\t\t\t}\n\t\t\t\t\tlen = 0;\n\t\t\t\t\tin_ssi_tag = in_tag = 0;\n\n\t\t\t\t} else {\n\t\t\t\t\t/* Not an SSI tag */\n\t\t\t\t\t/* Flush buffer */\n\t\t\t\t\t(void)mg_write(conn, buf, (size_t)len);\n\t\t\t\t\tlen = 0;\n\t\t\t\t\tin_tag = 0;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* Tag is still open */\n\t\t\t\tbuf[len++] = (char)(ch & 0xff);\n\n\t\t\t\tif ((len == 5) && !memcmp(buf, \"<!--#\", 5)) {\n\t\t\t\t\t/* All SSI tags start with <!--# */\n\t\t\t\t\tin_ssi_tag = 1;\n\t\t\t\t}\n\n\t\t\t\tif ((len + 2) > (int)sizeof(buf)) {\n\t\t\t\t\t/* Tag to long for buffer */\n\t\t\t\t\tmg_cry_internal(conn, \"%s: tag is too large\", path);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t/* We are not in a tag yet. */\n\t\t\tif (ch == '<') {\n\t\t\t\t/* Tag is opening */\n\t\t\t\tin_tag = 1;\n\n\t\t\t\tif (len > 0) {\n\t\t\t\t\t/* Flush current buffer.\n\t\t\t\t\t * Buffer is filled with \"len\" bytes. */\n\t\t\t\t\t(void)mg_write(conn, buf, (size_t)len);\n\t\t\t\t}\n\t\t\t\t/* Store the < */\n\t\t\t\tlen = 1;\n\t\t\t\tbuf[0] = '<';\n\n\t\t\t} else {\n\t\t\t\t/* No Tag */\n\t\t\t\t/* Add data to buffer */\n\t\t\t\tbuf[len++] = (char)(ch & 0xff);\n\t\t\t\t/* Flush if buffer is full */\n\t\t\t\tif (len == (int)sizeof(buf)) {\n\t\t\t\t\tmg_write(conn, buf, (size_t)len);\n\t\t\t\t\tlen = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Send the rest of buffered data */\n\tif (len > 0) {\n\t\tmg_write(conn, buf, (size_t)len);\n\t}\n}\n\n\nstatic void\nhandle_ssi_file_request(struct mg_connection *conn,\n                        const char *path,\n                        struct mg_file *filep)\n{\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\tconst char *cors1, *cors2, *cors3;\n\n\tif ((conn == NULL) || (path == NULL) || (filep == NULL)) {\n\t\treturn;\n\t}\n\n\tif (mg_get_header(conn, \"Origin\")) {\n\t\t/* Cross-origin resource sharing (CORS). */\n\t\tcors1 = \"Access-Control-Allow-Origin: \";\n\t\tcors2 = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];\n\t\tcors3 = \"\\r\\n\";\n\t} else {\n\t\tcors1 = cors2 = cors3 = \"\";\n\t}\n\n\tif (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {\n\t\t/* File exists (precondition for calling this function),\n\t\t * but can not be opened by the server. */\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Cannot read file\\nfopen(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t} else {\n\t\tconn->must_close = 1;\n\t\tgmt_time_string(date, sizeof(date), &curtime);\n\t\tfclose_on_exec(&filep->access, conn);\n\t\tmg_printf(conn, \"HTTP/1.1 200 OK\\r\\n\");\n\t\tsend_no_cache_header(conn);\n\t\tsend_additional_header(conn);\n\t\tmg_printf(conn,\n\t\t          \"%s%s%s\"\n\t\t          \"Date: %s\\r\\n\"\n\t\t          \"Content-Type: text/html\\r\\n\"\n\t\t          \"Connection: %s\\r\\n\\r\\n\",\n\t\t          cors1,\n\t\t          cors2,\n\t\t          cors3,\n\t\t          date,\n\t\t          suggest_connection_header(conn));\n\t\tsend_ssi_file(conn, path, filep, 0);\n\t\t(void)mg_fclose(&filep->access); /* Ignore errors for readonly files */\n\t}\n}\n\n\n#if !defined(NO_FILES)\nstatic void\nsend_options(struct mg_connection *conn)\n{\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tif (!conn) {\n\t\treturn;\n\t}\n\n\tconn->status_code = 200;\n\tconn->must_close = 1;\n\tgmt_time_string(date, sizeof(date), &curtime);\n\n\t/* We do not set a \"Cache-Control\" header here, but leave the default.\n\t * Since browsers do not send an OPTIONS request, we can not test the\n\t * effect anyway. */\n\tmg_printf(conn,\n\t          \"HTTP/1.1 200 OK\\r\\n\"\n\t          \"Date: %s\\r\\n\"\n\t          \"Connection: %s\\r\\n\"\n\t          \"Allow: GET, POST, HEAD, CONNECT, PUT, DELETE, OPTIONS, \"\n\t          \"PROPFIND, MKCOL\\r\\n\"\n\t          \"DAV: 1\\r\\n\",\n\t          date,\n\t          suggest_connection_header(conn));\n\tsend_additional_header(conn);\n\tmg_printf(conn, \"\\r\\n\");\n}\n\n\n/* Writes PROPFIND properties for a collection element */\nstatic void\nprint_props(struct mg_connection *conn,\n            const char *uri,\n            struct mg_file_stat *filep)\n{\n\tchar mtime[64];\n\n\tif ((conn == NULL) || (uri == NULL) || (filep == NULL)) {\n\t\treturn;\n\t}\n\n\tgmt_time_string(mtime, sizeof(mtime), &filep->last_modified);\n\tmg_printf(conn,\n\t          \"<d:response>\"\n\t          \"<d:href>%s</d:href>\"\n\t          \"<d:propstat>\"\n\t          \"<d:prop>\"\n\t          \"<d:resourcetype>%s</d:resourcetype>\"\n\t          \"<d:getcontentlength>%\" INT64_FMT \"</d:getcontentlength>\"\n\t          \"<d:getlastmodified>%s</d:getlastmodified>\"\n\t          \"</d:prop>\"\n\t          \"<d:status>HTTP/1.1 200 OK</d:status>\"\n\t          \"</d:propstat>\"\n\t          \"</d:response>\\n\",\n\t          uri,\n\t          filep->is_directory ? \"<d:collection/>\" : \"\",\n\t          filep->size,\n\t          mtime);\n}\n\n\nstatic int\nprint_dav_dir_entry(struct de *de, void *data)\n{\n\tchar href[PATH_MAX];\n\tint truncated;\n\n\tstruct mg_connection *conn = (struct mg_connection *)data;\n\tif (!de || !conn) {\n\t\treturn -1;\n\t}\n\tmg_snprintf(conn,\n\t            &truncated,\n\t            href,\n\t            sizeof(href),\n\t            \"%s%s\",\n\t            conn->request_info.local_uri,\n\t            de->file_name);\n\n\tif (!truncated) {\n\t\tsize_t href_encoded_size;\n\t\tchar *href_encoded;\n\n\t\thref_encoded_size = PATH_MAX * 3; /* worst case */\n\t\thref_encoded = (char *)mg_malloc(href_encoded_size);\n\t\tif (href_encoded == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tmg_url_encode(href, href_encoded, href_encoded_size);\n\t\tprint_props(conn, href_encoded, &de->file);\n\t\tmg_free(href_encoded);\n\t}\n\n\treturn 0;\n}\n\n\nstatic void\nhandle_propfind(struct mg_connection *conn,\n                const char *path,\n                struct mg_file_stat *filep)\n{\n\tconst char *depth = mg_get_header(conn, \"Depth\");\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tgmt_time_string(date, sizeof(date), &curtime);\n\n\tif (!conn || !path || !filep || !conn->dom_ctx) {\n\t\treturn;\n\t}\n\n\tconn->must_close = 1;\n\tconn->status_code = 207;\n\tmg_printf(conn,\n\t          \"HTTP/1.1 207 Multi-Status\\r\\n\"\n\t          \"Date: %s\\r\\n\",\n\t          date);\n\tsend_static_cache_header(conn);\n\tsend_additional_header(conn);\n\tmg_printf(conn,\n\t          \"Connection: %s\\r\\n\"\n\t          \"Content-Type: text/xml; charset=utf-8\\r\\n\\r\\n\",\n\t          suggest_connection_header(conn));\n\n\tmg_printf(conn,\n\t          \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n\t          \"<d:multistatus xmlns:d='DAV:'>\\n\");\n\n\t/* Print properties for the requested resource itself */\n\tprint_props(conn, conn->request_info.local_uri, filep);\n\n\t/* If it is a directory, print directory entries too if Depth is not 0\n\t */\n\tif (filep->is_directory\n\t    && !mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],\n\t                      \"yes\")\n\t    && ((depth == NULL) || (strcmp(depth, \"0\") != 0))) {\n\t\tscan_directory(conn, path, conn, &print_dav_dir_entry);\n\t}\n\n\tmg_printf(conn, \"%s\\n\", \"</d:multistatus>\");\n}\n#endif\n\nvoid\nmg_lock_connection(struct mg_connection *conn)\n{\n\tif (conn) {\n\t\t(void)pthread_mutex_lock(&conn->mutex);\n\t}\n}\n\nvoid\nmg_unlock_connection(struct mg_connection *conn)\n{\n\tif (conn) {\n\t\t(void)pthread_mutex_unlock(&conn->mutex);\n\t}\n}\n\nvoid\nmg_lock_context(struct mg_context *ctx)\n{\n\tif (ctx) {\n\t\t(void)pthread_mutex_lock(&ctx->nonce_mutex);\n\t}\n}\n\nvoid\nmg_unlock_context(struct mg_context *ctx)\n{\n\tif (ctx) {\n\t\t(void)pthread_mutex_unlock(&ctx->nonce_mutex);\n\t}\n}\n\n\n#if defined(USE_LUA)\n#include \"mod_lua.inl\"\n#endif /* USE_LUA */\n\n#if defined(USE_DUKTAPE)\n#include \"mod_duktape.inl\"\n#endif /* USE_DUKTAPE */\n\n#if defined(USE_WEBSOCKET)\n\n#if !defined(NO_SSL_DL)\n#define SHA_API static\n#include \"sha1.inl\"\n#endif\n\nstatic int\nsend_websocket_handshake(struct mg_connection *conn, const char *websock_key)\n{\n\tstatic const char *magic = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n\tchar buf[100], sha[20], b64_sha[sizeof(sha) * 2];\n\tSHA_CTX sha_ctx;\n\tint truncated;\n\n\t/* Calculate Sec-WebSocket-Accept reply from Sec-WebSocket-Key. */\n\tmg_snprintf(conn, &truncated, buf, sizeof(buf), \"%s%s\", websock_key, magic);\n\tif (truncated) {\n\t\tconn->must_close = 1;\n\t\treturn 0;\n\t}\n\n\tDEBUG_TRACE(\"%s\", \"Send websocket handshake\");\n\n\tSHA1_Init(&sha_ctx);\n\tSHA1_Update(&sha_ctx, (unsigned char *)buf, (uint32_t)strlen(buf));\n\tSHA1_Final((unsigned char *)sha, &sha_ctx);\n\tbase64_encode((unsigned char *)sha, sizeof(sha), b64_sha);\n\tmg_printf(conn,\n\t          \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n\t          \"Upgrade: websocket\\r\\n\"\n\t          \"Connection: Upgrade\\r\\n\"\n\t          \"Sec-WebSocket-Accept: %s\\r\\n\",\n\t          b64_sha);\n\tif (conn->request_info.acceptedWebSocketSubprotocol) {\n\t\tmg_printf(conn,\n\t\t          \"Sec-WebSocket-Protocol: %s\\r\\n\\r\\n\",\n\t\t          conn->request_info.acceptedWebSocketSubprotocol);\n\t} else {\n\t\tmg_printf(conn, \"%s\", \"\\r\\n\");\n\t}\n\n\treturn 1;\n}\n\n\n#if !defined(MG_MAX_UNANSWERED_PING)\n/* Configuration of the maximum number of websocket PINGs that might\n * stay unanswered before the connection is considered broken.\n * Note: The name of this define may still change (until it is\n * defined as a compile parameter in a documentation).\n */\n#define MG_MAX_UNANSWERED_PING (5)\n#endif\n\n\nstatic void\nread_websocket(struct mg_connection *conn,\n               mg_websocket_data_handler ws_data_handler,\n               void *callback_data)\n{\n\t/* Pointer to the beginning of the portion of the incoming websocket\n\t * message queue.\n\t * The original websocket upgrade request is never removed, so the queue\n\t * begins after it. */\n\tunsigned char *buf = (unsigned char *)conn->buf + conn->request_len;\n\tint n, error, exit_by_callback;\n\tint ret;\n\n\t/* body_len is the length of the entire queue in bytes\n\t * len is the length of the current message\n\t * data_len is the length of the current message's data payload\n\t * header_len is the length of the current message's header */\n\tsize_t i, len, mask_len = 0, header_len, body_len;\n\tuint64_t data_len = 0;\n\n\t/* \"The masking key is a 32-bit value chosen at random by the client.\"\n\t * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5\n\t */\n\tunsigned char mask[4];\n\n\t/* data points to the place where the message is stored when passed to\n\t * the websocket_data callback.  This is either mem on the stack, or a\n\t * dynamically allocated buffer if it is too large. */\n\tunsigned char mem[4096];\n\tunsigned char mop; /* mask flag and opcode */\n\n\n\t/* Variables used for connection monitoring */\n\tdouble timeout = -1.0;\n\tint enable_ping_pong = 0;\n\tint ping_count = 0;\n\n\tif (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {\n\t\tenable_ping_pong =\n\t\t    !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],\n\t\t                   \"yes\");\n\t}\n\n\tif (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {\n\t\ttimeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;\n\t}\n\tif ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {\n\t\ttimeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;\n\t}\n\n\t/* Enter data processing loop */\n\tDEBUG_TRACE(\"Websocket connection %s:%u start data processing loop\",\n\t            conn->request_info.remote_addr,\n\t            conn->request_info.remote_port);\n\tconn->in_websocket_handling = 1;\n\tmg_set_thread_name(\"wsock\");\n\n\t/* Loop continuously, reading messages from the socket, invoking the\n\t * callback, and waiting repeatedly until an error occurs. */\n\twhile (!conn->phys_ctx->stop_flag && !conn->must_close) {\n\t\theader_len = 0;\n\t\tDEBUG_ASSERT(conn->data_len >= conn->request_len);\n\t\tif ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {\n\t\t\tlen = buf[1] & 127;\n\t\t\tmask_len = (buf[1] & 128) ? 4 : 0;\n\t\t\tif ((len < 126) && (body_len >= mask_len)) {\n\t\t\t\t/* inline 7-bit length field */\n\t\t\t\tdata_len = len;\n\t\t\t\theader_len = 2 + mask_len;\n\t\t\t} else if ((len == 126) && (body_len >= (4 + mask_len))) {\n\t\t\t\t/* 16-bit length field */\n\t\t\t\theader_len = 4 + mask_len;\n\t\t\t\tdata_len = ((((size_t)buf[2]) << 8) + buf[3]);\n\t\t\t} else if (body_len >= (10 + mask_len)) {\n\t\t\t\t/* 64-bit length field */\n\t\t\t\tuint32_t l1, l2;\n\t\t\t\tmemcpy(&l1, &buf[2], 4); /* Use memcpy for alignment */\n\t\t\t\tmemcpy(&l2, &buf[6], 4);\n\t\t\t\theader_len = 10 + mask_len;\n\t\t\t\tdata_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);\n\n\t\t\t\tif (data_len > (uint64_t)0x7FFF0000ul) {\n\t\t\t\t\t/* no can do */\n\t\t\t\t\tmg_cry_internal(\n\t\t\t\t\t    conn,\n\t\t\t\t\t    \"%s\",\n\t\t\t\t\t    \"websocket out of memory; closing connection\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((header_len > 0) && (body_len >= header_len)) {\n\t\t\t/* Allocate space to hold websocket payload */\n\t\t\tunsigned char *data = mem;\n\n\t\t\tif ((size_t)data_len > (size_t)sizeof(mem)) {\n\t\t\t\tdata = (unsigned char *)mg_malloc_ctx((size_t)data_len,\n\t\t\t\t                                      conn->phys_ctx);\n\t\t\t\tif (data == NULL) {\n\t\t\t\t\t/* Allocation failed, exit the loop and then close the\n\t\t\t\t\t * connection */\n\t\t\t\t\tmg_cry_internal(\n\t\t\t\t\t    conn,\n\t\t\t\t\t    \"%s\",\n\t\t\t\t\t    \"websocket out of memory; closing connection\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Copy the mask before we shift the queue and destroy it */\n\t\t\tif (mask_len > 0) {\n\t\t\t\tmemcpy(mask, buf + header_len - mask_len, sizeof(mask));\n\t\t\t} else {\n\t\t\t\tmemset(mask, 0, sizeof(mask));\n\t\t\t}\n\n\t\t\t/* Read frame payload from the first message in the queue into\n\t\t\t * data and advance the queue by moving the memory in place. */\n\t\t\tDEBUG_ASSERT(body_len >= header_len);\n\t\t\tif (data_len + (uint64_t)header_len > (uint64_t)body_len) {\n\t\t\t\tmop = buf[0]; /* current mask and opcode */\n\t\t\t\t/* Overflow case */\n\t\t\t\tlen = body_len - header_len;\n\t\t\t\tmemcpy(data, buf + header_len, len);\n\t\t\t\terror = 0;\n\t\t\t\twhile ((uint64_t)len < data_len) {\n\t\t\t\t\tn = pull_inner(NULL,\n\t\t\t\t\t               conn,\n\t\t\t\t\t               (char *)(data + len),\n\t\t\t\t\t               (int)(data_len - len),\n\t\t\t\t\t               timeout);\n\t\t\t\t\tif (n <= -2) {\n\t\t\t\t\t\terror = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (n > 0) {\n\t\t\t\t\t\tlen += (size_t)n;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Timeout: should retry */\n\t\t\t\t\t\t/* TODO: retry condition */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (error) {\n\t\t\t\t\tmg_cry_internal(\n\t\t\t\t\t    conn,\n\t\t\t\t\t    \"%s\",\n\t\t\t\t\t    \"Websocket pull failed; closing connection\");\n\t\t\t\t\tif (data != mem) {\n\t\t\t\t\t\tmg_free(data);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconn->data_len = conn->request_len;\n\n\t\t\t} else {\n\n\t\t\t\tmop = buf[0]; /* current mask and opcode, overwritten by\n\t\t\t\t               * memmove() */\n\n\t\t\t\t/* Length of the message being read at the front of the\n\t\t\t\t * queue. Cast to 31 bit is OK, since we limited\n\t\t\t\t * data_len before. */\n\t\t\t\tlen = (size_t)data_len + header_len;\n\n\t\t\t\t/* Copy the data payload into the data pointer for the\n\t\t\t\t * callback. Cast to 31 bit is OK, since we\n\t\t\t\t * limited data_len */\n\t\t\t\tmemcpy(data, buf + header_len, (size_t)data_len);\n\n\t\t\t\t/* Move the queue forward len bytes */\n\t\t\t\tmemmove(buf, buf + len, body_len - len);\n\n\t\t\t\t/* Mark the queue as advanced */\n\t\t\t\tconn->data_len -= (int)len;\n\t\t\t}\n\n\t\t\t/* Apply mask if necessary */\n\t\t\tif (mask_len > 0) {\n\t\t\t\tfor (i = 0; i < (size_t)data_len; i++) {\n\t\t\t\t\tdata[i] ^= mask[i & 3];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\texit_by_callback = 0;\n\t\t\tif (enable_ping_pong && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PONG)) {\n\t\t\t\t/* filter PONG messages */\n\t\t\t\tDEBUG_TRACE(\"PONG from %s:%u\",\n\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\t/* No unanwered PINGs left */\n\t\t\t\tping_count = 0;\n\t\t\t} else if (enable_ping_pong\n\t\t\t           && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PING)) {\n\t\t\t\t/* reply PING messages */\n\t\t\t\tDEBUG_TRACE(\"Reply PING from %s:%u\",\n\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\tret = mg_websocket_write(conn,\n\t\t\t\t                         MG_WEBSOCKET_OPCODE_PONG,\n\t\t\t\t                         (char *)data,\n\t\t\t\t                         (size_t)data_len);\n\t\t\t\tif (ret <= 0) {\n\t\t\t\t\t/* Error: send failed */\n\t\t\t\t\tDEBUG_TRACE(\"Reply PONG failed (%i)\", ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t} else {\n\t\t\t\t/* Exit the loop if callback signals to exit (server side),\n\t\t\t\t * or \"connection close\" opcode received (client side). */\n\t\t\t\tif ((ws_data_handler != NULL)\n\t\t\t\t    && !ws_data_handler(conn,\n\t\t\t\t                        mop,\n\t\t\t\t                        (char *)data,\n\t\t\t\t                        (size_t)data_len,\n\t\t\t\t                        callback_data)) {\n\t\t\t\t\texit_by_callback = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* It a buffer has been allocated, free it again */\n\t\t\tif (data != mem) {\n\t\t\t\tmg_free(data);\n\t\t\t}\n\n\t\t\tif (exit_by_callback) {\n\t\t\t\tDEBUG_TRACE(\"Callback requests to close connection from %s:%u\",\n\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {\n\t\t\t\t/* Opcode == 8, connection close */\n\t\t\t\tDEBUG_TRACE(\"Message requests to close connection from %s:%u\",\n\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Not breaking the loop, process next websocket frame. */\n\t\t} else {\n\t\t\t/* Read from the socket into the next available location in the\n\t\t\t * message queue. */\n\t\t\tn = pull_inner(NULL,\n\t\t\t               conn,\n\t\t\t               conn->buf + conn->data_len,\n\t\t\t               conn->buf_size - conn->data_len,\n\t\t\t               timeout);\n\t\t\tif (n <= -2) {\n\t\t\t\t/* Error, no bytes read */\n\t\t\t\tDEBUG_TRACE(\"PULL from %s:%u failed\",\n\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n > 0) {\n\t\t\t\tconn->data_len += n;\n\t\t\t\t/* Reset open PING count */\n\t\t\t\tping_count = 0;\n\t\t\t} else {\n\t\t\t\tif (!conn->phys_ctx->stop_flag && !conn->must_close) {\n\t\t\t\t\tif (ping_count > MG_MAX_UNANSWERED_PING) {\n\t\t\t\t\t\t/* Stop sending PING */\n\t\t\t\t\t\tDEBUG_TRACE(\"Too many (%i) unanswered ping from %s:%u \"\n\t\t\t\t\t\t            \"- closing connection\",\n\t\t\t\t\t\t            ping_count,\n\t\t\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (enable_ping_pong) {\n\t\t\t\t\t\t/* Send Websocket PING message */\n\t\t\t\t\t\tDEBUG_TRACE(\"PING to %s:%u\",\n\t\t\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\t\t\tret = mg_websocket_write(conn,\n\t\t\t\t\t\t                         MG_WEBSOCKET_OPCODE_PING,\n\t\t\t\t\t\t                         NULL,\n\t\t\t\t\t\t                         0);\n\n\t\t\t\t\t\tif (ret <= 0) {\n\t\t\t\t\t\t\t/* Error: send failed */\n\t\t\t\t\t\t\tDEBUG_TRACE(\"Send PING failed (%i)\", ret);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tping_count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Timeout: should retry */\n\t\t\t\t/* TODO: get timeout def */\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Leave data processing loop */\n\tmg_set_thread_name(\"worker\");\n\tconn->in_websocket_handling = 0;\n\tDEBUG_TRACE(\"Websocket connection %s:%u left data processing loop\",\n\t            conn->request_info.remote_addr,\n\t            conn->request_info.remote_port);\n}\n\n\nstatic int\nmg_websocket_write_exec(struct mg_connection *conn,\n                        int opcode,\n                        const char *data,\n                        size_t dataLen,\n                        uint32_t masking_key)\n{\n\tunsigned char header[14];\n\tsize_t headerLen;\n\tint retval;\n\n#if defined(GCC_DIAGNOSTIC)\n/* Disable spurious conversion warning for GCC */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\n#endif\n\n\theader[0] = 0x80u | (unsigned char)((unsigned)opcode & 0xf);\n\n#if defined(GCC_DIAGNOSTIC)\n#pragma GCC diagnostic pop\n#endif\n\n\t/* Frame format: http://tools.ietf.org/html/rfc6455#section-5.2 */\n\tif (dataLen < 126) {\n\t\t/* inline 7-bit length field */\n\t\theader[1] = (unsigned char)dataLen;\n\t\theaderLen = 2;\n\t} else if (dataLen <= 0xFFFF) {\n\t\t/* 16-bit length field */\n\t\tuint16_t len = htons((uint16_t)dataLen);\n\t\theader[1] = 126;\n\t\tmemcpy(header + 2, &len, 2);\n\t\theaderLen = 4;\n\t} else {\n\t\t/* 64-bit length field */\n\t\tuint32_t len1 = htonl((uint32_t)((uint64_t)dataLen >> 32));\n\t\tuint32_t len2 = htonl((uint32_t)(dataLen & 0xFFFFFFFFu));\n\t\theader[1] = 127;\n\t\tmemcpy(header + 2, &len1, 4);\n\t\tmemcpy(header + 6, &len2, 4);\n\t\theaderLen = 10;\n\t}\n\n\tif (masking_key) {\n\t\t/* add mask */\n\t\theader[1] |= 0x80;\n\t\tmemcpy(header + headerLen, &masking_key, 4);\n\t\theaderLen += 4;\n\t}\n\n\t/* Note that POSIX/Winsock's send() is threadsafe\n\t * http://stackoverflow.com/questions/1981372/are-parallel-calls-to-send-recv-on-the-same-socket-valid\n\t * but mongoose's mg_printf/mg_write is not (because of the loop in\n\t * push(), although that is only a problem if the packet is large or\n\t * outgoing buffer is full). */\n\n\t/* TODO: Check if this lock should be moved to user land.\n\t * Currently the server sets this lock for websockets, but\n\t * not for any other connection. It must be set for every\n\t * conn read/written by more than one thread, no matter if\n\t * it is a websocket or regular connection. */\n\t(void)mg_lock_connection(conn);\n\n\tretval = mg_write(conn, header, headerLen);\n\tif (retval != (int)headerLen) {\n\t\t/* Did not send complete header */\n\t\tretval = -1;\n\t} else {\n\t\tif (dataLen > 0) {\n\t\t\tretval = mg_write(conn, data, dataLen);\n\t\t}\n\t\t/* if dataLen == 0, the header length (2) is returned */\n\t}\n\n\t/* TODO: Remove this unlock as well, when lock is removed. */\n\tmg_unlock_connection(conn);\n\n\treturn retval;\n}\n\nint\nmg_websocket_write(struct mg_connection *conn,\n                   int opcode,\n                   const char *data,\n                   size_t dataLen)\n{\n\treturn mg_websocket_write_exec(conn, opcode, data, dataLen, 0);\n}\n\n\nstatic void\nmask_data(const char *in, size_t in_len, uint32_t masking_key, char *out)\n{\n\tsize_t i = 0;\n\n\ti = 0;\n\tif ((in_len > 3) && ((ptrdiff_t)in % 4) == 0) {\n\t\t/* Convert in 32 bit words, if data is 4 byte aligned */\n\t\twhile (i < (in_len - 3)) {\n\t\t\t*(uint32_t *)(void *)(out + i) =\n\t\t\t    *(uint32_t *)(void *)(in + i) ^ masking_key;\n\t\t\ti += 4;\n\t\t}\n\t}\n\tif (i != in_len) {\n\t\t/* convert 1-3 remaining bytes if ((dataLen % 4) != 0)*/\n\t\twhile (i < in_len) {\n\t\t\t*(uint8_t *)(void *)(out + i) =\n\t\t\t    *(uint8_t *)(void *)(in + i)\n\t\t\t    ^ *(((uint8_t *)&masking_key) + (i % 4));\n\t\t\ti++;\n\t\t}\n\t}\n}\n\n\nint\nmg_websocket_client_write(struct mg_connection *conn,\n                          int opcode,\n                          const char *data,\n                          size_t dataLen)\n{\n\tint retval = -1;\n\tchar *masked_data =\n\t    (char *)mg_malloc_ctx(((dataLen + 7) / 4) * 4, conn->phys_ctx);\n\tuint32_t masking_key = 0;\n\n\tif (masked_data == NULL) {\n\t\t/* Return -1 in an error case */\n\t\tmg_cry_internal(conn,\n\t\t                \"%s\",\n\t\t                \"Cannot allocate buffer for masked websocket response: \"\n\t\t                \"Out of memory\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\t/* Get a masking key - but not 0 */\n\t\tmasking_key = (uint32_t)get_random();\n\t} while (masking_key == 0);\n\n\tmask_data(data, dataLen, masking_key, masked_data);\n\n\tretval = mg_websocket_write_exec(\n\t    conn, opcode, masked_data, dataLen, masking_key);\n\tmg_free(masked_data);\n\n\treturn retval;\n}\n\n\nstatic void\nhandle_websocket_request(struct mg_connection *conn,\n                         const char *path,\n                         int is_callback_resource,\n                         struct mg_websocket_subprotocols *subprotocols,\n                         mg_websocket_connect_handler ws_connect_handler,\n                         mg_websocket_ready_handler ws_ready_handler,\n                         mg_websocket_data_handler ws_data_handler,\n                         mg_websocket_close_handler ws_close_handler,\n                         void *cbData)\n{\n\tconst char *websock_key = mg_get_header(conn, \"Sec-WebSocket-Key\");\n\tconst char *version = mg_get_header(conn, \"Sec-WebSocket-Version\");\n\tptrdiff_t lua_websock = 0;\n\n#if !defined(USE_LUA)\n\t(void)path;\n#endif\n\n\t/* Step 1: Check websocket protocol version. */\n\t/* Step 1.1: Check Sec-WebSocket-Key. */\n\tif (!websock_key) {\n\t\t/* The RFC standard version (https://tools.ietf.org/html/rfc6455)\n\t\t * requires a Sec-WebSocket-Key header.\n\t\t */\n\t\t/* It could be the hixie draft version\n\t\t * (http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76).\n\t\t */\n\t\tconst char *key1 = mg_get_header(conn, \"Sec-WebSocket-Key1\");\n\t\tconst char *key2 = mg_get_header(conn, \"Sec-WebSocket-Key2\");\n\t\tchar key3[8];\n\n\t\tif ((key1 != NULL) && (key2 != NULL)) {\n\t\t\t/* This version uses 8 byte body data in a GET request */\n\t\t\tconn->content_len = 8;\n\t\t\tif (8 == mg_read(conn, key3, 8)) {\n\t\t\t\t/* This is the hixie version */\n\t\t\t\tmg_send_http_error(conn,\n\t\t\t\t                   426,\n\t\t\t\t                   \"%s\",\n\t\t\t\t                   \"Protocol upgrade to RFC 6455 required\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/* This is an unknown version */\n\t\tmg_send_http_error(conn, 400, \"%s\", \"Malformed websocket request\");\n\t\treturn;\n\t}\n\n\t/* Step 1.2: Check websocket protocol version. */\n\t/* The RFC version (https://tools.ietf.org/html/rfc6455) is 13. */\n\tif ((version == NULL) || (strcmp(version, \"13\") != 0)) {\n\t\t/* Reject wrong versions */\n\t\tmg_send_http_error(conn, 426, \"%s\", \"Protocol upgrade required\");\n\t\treturn;\n\t}\n\n\t/* Step 1.3: Could check for \"Host\", but we do not really nead this\n\t * value for anything, so just ignore it. */\n\n\t/* Step 2: If a callback is responsible, call it. */\n\tif (is_callback_resource) {\n\t\t/* Step 2.1 check and select subprotocol */\n\t\tconst char *protocols[64]; // max 64 headers\n\t\tint nbSubprotocolHeader = get_req_headers(&conn->request_info,\n\t\t                                          \"Sec-WebSocket-Protocol\",\n\t\t                                          protocols,\n\t\t                                          64);\n\t\tif ((nbSubprotocolHeader > 0) && subprotocols) {\n\t\t\tint cnt = 0;\n\t\t\tint idx;\n\t\t\tunsigned long len;\n\t\t\tconst char *sep, *curSubProtocol,\n\t\t\t    *acceptedWebSocketSubprotocol = NULL;\n\n\n\t\t\t/* look for matching subprotocol */\n\t\t\tdo {\n\t\t\t\tconst char *protocol = protocols[cnt];\n\n\t\t\t\tdo {\n\t\t\t\t\tsep = strchr(protocol, ',');\n\t\t\t\t\tcurSubProtocol = protocol;\n\t\t\t\t\tlen = sep ? (unsigned long)(sep - protocol)\n\t\t\t\t\t          : (unsigned long)strlen(protocol);\n\t\t\t\t\twhile (sep && isspace(*++sep))\n\t\t\t\t\t\t; // ignore leading whitespaces\n\t\t\t\t\tprotocol = sep;\n\n\n\t\t\t\t\tfor (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {\n\t\t\t\t\t\tif ((strlen(subprotocols->subprotocols[idx]) == len)\n\t\t\t\t\t\t    && (strncmp(curSubProtocol,\n\t\t\t\t\t\t                subprotocols->subprotocols[idx],\n\t\t\t\t\t\t                len)\n\t\t\t\t\t\t        == 0)) {\n\t\t\t\t\t\t\tacceptedWebSocketSubprotocol =\n\t\t\t\t\t\t\t    subprotocols->subprotocols[idx];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (sep && !acceptedWebSocketSubprotocol);\n\t\t\t} while (++cnt < nbSubprotocolHeader\n\t\t\t         && !acceptedWebSocketSubprotocol);\n\n\t\t\tconn->request_info.acceptedWebSocketSubprotocol =\n\t\t\t    acceptedWebSocketSubprotocol;\n\n\t\t} else if (nbSubprotocolHeader > 0) {\n\t\t\t/* keep legacy behavior */\n\t\t\tconst char *protocol = protocols[0];\n\n\t\t\t/* The protocol is a comma separated list of names. */\n\t\t\t/* The server must only return one value from this list. */\n\t\t\t/* First check if it is a list or just a single value. */\n\t\t\tconst char *sep = strrchr(protocol, ',');\n\t\t\tif (sep == NULL) {\n\t\t\t\t/* Just a single protocol -> accept it. */\n\t\t\t\tconn->request_info.acceptedWebSocketSubprotocol = protocol;\n\t\t\t} else {\n\t\t\t\t/* Multiple protocols -> accept the last one. */\n\t\t\t\t/* This is just a quick fix if the client offers multiple\n\t\t\t\t * protocols. The handler should have a list of accepted\n\t\t\t\t * protocols on his own\n\t\t\t\t * and use it to select one protocol among those the client\n\t\t\t\t * has\n\t\t\t\t * offered.\n\t\t\t\t */\n\t\t\t\twhile (isspace(*++sep)) {\n\t\t\t\t\t; /* ignore leading whitespaces */\n\t\t\t\t}\n\t\t\t\tconn->request_info.acceptedWebSocketSubprotocol = sep;\n\t\t\t}\n\t\t}\n\n\t\tif ((ws_connect_handler != NULL)\n\t\t    && (ws_connect_handler(conn, cbData) != 0)) {\n\t\t\t/* C callback has returned non-zero, do not proceed with\n\t\t\t * handshake.\n\t\t\t */\n\t\t\t/* Note that C callbacks are no longer called when Lua is\n\t\t\t * responsible, so C can no longer filter callbacks for Lua. */\n\t\t\treturn;\n\t\t}\n\t}\n\n#if defined(USE_LUA)\n\t/* Step 3: No callback. Check if Lua is responsible. */\n\telse {\n\t\t/* Step 3.1: Check if Lua is responsible. */\n\t\tif (conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS]) {\n\t\t\tlua_websock = match_prefix(\n\t\t\t    conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS],\n\t\t\t    strlen(conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS]),\n\t\t\t    path);\n\t\t}\n\n\t\tif (lua_websock) {\n\t\t\t/* Step 3.2: Lua is responsible: call it. */\n\t\t\tconn->lua_websocket_state = lua_websocket_new(path, conn);\n\t\t\tif (!conn->lua_websocket_state) {\n\t\t\t\t/* Lua rejected the new client */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\t/* Step 4: Check if there is a responsible websocket handler. */\n\tif (!is_callback_resource && !lua_websock) {\n\t\t/* There is no callback, and Lua is not responsible either. */\n\t\t/* Reply with a 404 Not Found. We are still at a standard\n\t\t * HTTP request here, before the websocket handshake, so\n\t\t * we can still send standard HTTP error replies. */\n\t\tmg_send_http_error(conn, 404, \"%s\", \"Not found\");\n\t\treturn;\n\t}\n\n\t/* Step 5: The websocket connection has been accepted */\n\tif (!send_websocket_handshake(conn, websock_key)) {\n\t\tmg_send_http_error(conn, 500, \"%s\", \"Websocket handshake failed\");\n\t\treturn;\n\t}\n\n\t/* Step 6: Call the ready handler */\n\tif (is_callback_resource) {\n\t\tif (ws_ready_handler != NULL) {\n\t\t\tws_ready_handler(conn, cbData);\n\t\t}\n#if defined(USE_LUA)\n\t} else if (lua_websock) {\n\t\tif (!lua_websocket_ready(conn, conn->lua_websocket_state)) {\n\t\t\t/* the ready handler returned false */\n\t\t\treturn;\n\t\t}\n#endif\n\t}\n\n\t/* Step 7: Enter the read loop */\n\tif (is_callback_resource) {\n\t\tread_websocket(conn, ws_data_handler, cbData);\n#if defined(USE_LUA)\n\t} else if (lua_websock) {\n\t\tread_websocket(conn, lua_websocket_data, conn->lua_websocket_state);\n#endif\n\t}\n\n\t/* Step 8: Call the close handler */\n\tif (ws_close_handler) {\n\t\tws_close_handler(conn, cbData);\n\t}\n}\n\n\nstatic int\nis_websocket_protocol(const struct mg_connection *conn)\n{\n\tconst char *upgrade, *connection;\n\n\t/* A websocket protocoll has the following HTTP headers:\n\t *\n\t * Connection: Upgrade\n\t * Upgrade: Websocket\n\t */\n\n\tupgrade = mg_get_header(conn, \"Upgrade\");\n\tif (upgrade == NULL) {\n\t\treturn 0; /* fail early, don't waste time checking other header\n\t\t           * fields\n\t\t           */\n\t}\n\tif (!mg_strcasestr(upgrade, \"websocket\")) {\n\t\treturn 0;\n\t}\n\n\tconnection = mg_get_header(conn, \"Connection\");\n\tif (connection == NULL) {\n\t\treturn 0;\n\t}\n\tif (!mg_strcasestr(connection, \"upgrade\")) {\n\t\treturn 0;\n\t}\n\n\t/* The headers \"Host\", \"Sec-WebSocket-Key\", \"Sec-WebSocket-Protocol\" and\n\t * \"Sec-WebSocket-Version\" are also required.\n\t * Don't check them here, since even an unsupported websocket protocol\n\t * request still IS a websocket request (in contrast to a standard HTTP\n\t * request). It will fail later in handle_websocket_request.\n\t */\n\n\treturn 1;\n}\n#endif /* !USE_WEBSOCKET */\n\n\nstatic int\nisbyte(int n)\n{\n\treturn (n >= 0) && (n <= 255);\n}\n\n\nstatic int\nparse_net(const char *spec, uint32_t *net, uint32_t *mask)\n{\n\tint n, a, b, c, d, slash = 32, len = 0;\n\n\tif (((sscanf(spec, \"%d.%d.%d.%d/%d%n\", &a, &b, &c, &d, &slash, &n) == 5)\n\t     || (sscanf(spec, \"%d.%d.%d.%d%n\", &a, &b, &c, &d, &n) == 4))\n\t    && isbyte(a) && isbyte(b) && isbyte(c) && isbyte(d) && (slash >= 0)\n\t    && (slash < 33)) {\n\t\tlen = n;\n\t\t*net = ((uint32_t)a << 24) | ((uint32_t)b << 16) | ((uint32_t)c << 8)\n\t\t       | (uint32_t)d;\n\t\t*mask = slash ? (0xffffffffU << (32 - slash)) : 0;\n\t}\n\n\treturn len;\n}\n\n\nstatic int\nset_throttle(const char *spec, uint32_t remote_ip, const char *uri)\n{\n\tint throttle = 0;\n\tstruct vec vec, val;\n\tuint32_t net, mask;\n\tchar mult;\n\tdouble v;\n\n\twhile ((spec = next_option(spec, &vec, &val)) != NULL) {\n\t\tmult = ',';\n\t\tif ((val.ptr == NULL) || (sscanf(val.ptr, \"%lf%c\", &v, &mult) < 1)\n\t\t    || (v < 0)\n\t\t    || ((lowercase(&mult) != 'k') && (lowercase(&mult) != 'm')\n\t\t        && (mult != ','))) {\n\t\t\tcontinue;\n\t\t}\n\t\tv *= (lowercase(&mult) == 'k')\n\t\t         ? 1024\n\t\t         : ((lowercase(&mult) == 'm') ? 1048576 : 1);\n\t\tif (vec.len == 1 && vec.ptr[0] == '*') {\n\t\t\tthrottle = (int)v;\n\t\t} else if (parse_net(vec.ptr, &net, &mask) > 0) {\n\t\t\tif ((remote_ip & mask) == net) {\n\t\t\t\tthrottle = (int)v;\n\t\t\t}\n\t\t} else if (match_prefix(vec.ptr, vec.len, uri) > 0) {\n\t\t\tthrottle = (int)v;\n\t\t}\n\t}\n\n\treturn throttle;\n}\n\n\nstatic uint32_t\nget_remote_ip(const struct mg_connection *conn)\n{\n\tif (!conn) {\n\t\treturn 0;\n\t}\n\treturn ntohl(*(const uint32_t *)&conn->client.rsa.sin.sin_addr);\n}\n\n\n/* The mg_upload function is superseeded by mg_handle_form_request. */\n#include \"handle_form.inl\"\n\n\n#if defined(MG_LEGACY_INTERFACE)\n/* Implement the deprecated mg_upload function by calling the new\n * mg_handle_form_request function. While mg_upload could only handle\n * HTML forms sent as POST request in multipart/form-data format\n * containing only file input elements, mg_handle_form_request can\n * handle all form input elements and all standard request methods. */\nstruct mg_upload_user_data {\n\tstruct mg_connection *conn;\n\tconst char *destination_dir;\n\tint num_uploaded_files;\n};\n\n\n/* Helper function for deprecated mg_upload. */\nstatic int\nmg_upload_field_found(const char *key,\n                      const char *filename,\n                      char *path,\n                      size_t pathlen,\n                      void *user_data)\n{\n\tint truncated = 0;\n\tstruct mg_upload_user_data *fud = (struct mg_upload_user_data *)user_data;\n\t(void)key;\n\n\tif (!filename) {\n\t\tmg_cry_internal(fud->conn, \"%s: No filename set\", __func__);\n\t\treturn FORM_FIELD_STORAGE_ABORT;\n\t}\n\tmg_snprintf(fud->conn,\n\t            &truncated,\n\t            path,\n\t            pathlen - 1,\n\t            \"%s/%s\",\n\t            fud->destination_dir,\n\t            filename);\n\tif (truncated) {\n\t\tmg_cry_internal(fud->conn, \"%s: File path too long\", __func__);\n\t\treturn FORM_FIELD_STORAGE_ABORT;\n\t}\n\treturn FORM_FIELD_STORAGE_STORE;\n}\n\n\n/* Helper function for deprecated mg_upload. */\nstatic int\nmg_upload_field_get(const char *key,\n                    const char *value,\n                    size_t value_size,\n                    void *user_data)\n{\n\t/* Function should never be called */\n\t(void)key;\n\t(void)value;\n\t(void)value_size;\n\t(void)user_data;\n\n\treturn 0;\n}\n\n\n/* Helper function for deprecated mg_upload. */\nstatic int\nmg_upload_field_stored(const char *path, long long file_size, void *user_data)\n{\n\tstruct mg_upload_user_data *fud = (struct mg_upload_user_data *)user_data;\n\t(void)file_size;\n\n\tfud->num_uploaded_files++;\n\tfud->conn->phys_ctx->callbacks.upload(fud->conn, path);\n\n\treturn 0;\n}\n\n\n/* Deprecated function mg_upload - use mg_handle_form_request instead. */\nint\nmg_upload(struct mg_connection *conn, const char *destination_dir)\n{\n\tstruct mg_upload_user_data fud = {conn, destination_dir, 0};\n\tstruct mg_form_data_handler fdh = {mg_upload_field_found,\n\t                                   mg_upload_field_get,\n\t                                   mg_upload_field_stored,\n\t                                   0};\n\tint ret;\n\n\tfdh.user_data = (void *)&fud;\n\tret = mg_handle_form_request(conn, &fdh);\n\n\tif (ret < 0) {\n\t\tmg_cry_internal(conn, \"%s: Error while parsing the request\", __func__);\n\t}\n\n\treturn fud.num_uploaded_files;\n}\n#endif\n\n\nstatic int\nget_first_ssl_listener_index(const struct mg_context *ctx)\n{\n\tunsigned int i;\n\tint idx = -1;\n\tif (ctx) {\n\t\tfor (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets)); i++) {\n\t\t\tidx = ctx->listening_sockets[i].is_ssl ? ((int)(i)) : -1;\n\t\t}\n\t}\n\treturn idx;\n}\n\n\n/* Return host (without port) */\n/* Use mg_free to free the result */\nstatic const char *\nalloc_get_host(struct mg_connection *conn)\n{\n\tchar buf[1025];\n\tsize_t buflen = sizeof(buf);\n\tconst char *host_header = get_header(conn->request_info.http_headers,\n\t                                     conn->request_info.num_headers,\n\t                                     \"Host\");\n\tchar *host;\n\n\tif (host_header != NULL) {\n\t\tchar *pos;\n\n\t\t/* Create a local copy of the \"Host\" header, since it might be\n\t\t * modified here. */\n\t\tmg_strlcpy(buf, host_header, buflen);\n\t\tbuf[buflen - 1] = '\\0';\n\t\thost = buf;\n\t\twhile (isspace(*host)) {\n\t\t\thost++;\n\t\t}\n\n\t\t/* If the \"Host\" is an IPv6 address, like [::1], parse until ]\n\t\t * is found. */\n\t\tif (*host == '[') {\n\t\t\tpos = strchr(host, ']');\n\t\t\tif (!pos) {\n\t\t\t\t/* Malformed hostname starts with '[', but no ']' found */\n\t\t\t\tDEBUG_TRACE(\"%s\", \"Host name format error '[' without ']'\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/* terminate after ']' */\n\t\t\tpos[1] = 0;\n\t\t} else {\n\t\t\t/* Otherwise, a ':' separates hostname and port number */\n\t\t\tpos = strchr(host, ':');\n\t\t\tif (pos != NULL) {\n\t\t\t\t*pos = '\\0';\n\t\t\t}\n\t\t}\n\n\t\tif (conn->ssl) {\n\t\t\t/* This is a HTTPS connection, maybe we have a hostname\n\t\t\t * from SNI (set in ssl_servername_callback). */\n\t\t\tconst char *sslhost = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];\n\t\t\tif (sslhost && (conn->dom_ctx != &(conn->phys_ctx->dd))) {\n\t\t\t\t/* We are not using the default domain */\n\t\t\t\tif (mg_strcasecmp(host, sslhost)) {\n\t\t\t\t\t/* Mismatch between SNI domain and HTTP domain */\n\t\t\t\t\tDEBUG_TRACE(\"Host mismatch: SNI: %s, HTTPS: %s\",\n\t\t\t\t\t            sslhost,\n\t\t\t\t\t            host);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDEBUG_TRACE(\"HTTPS Host: %s\", host);\n\n\t\t} else {\n\t\t\tstruct mg_domain_context *dom = &(conn->phys_ctx->dd);\n\t\t\twhile (dom) {\n\t\t\t\tif (!mg_strcasecmp(host, dom->config[AUTHENTICATION_DOMAIN])) {\n\n\t\t\t\t\t/* Found matching domain */\n\t\t\t\t\tDEBUG_TRACE(\"HTTP domain %s found\",\n\t\t\t\t\t            dom->config[AUTHENTICATION_DOMAIN]);\n\n\t\t\t\t\t/* TODO: Check if this is a HTTP or HTTPS domain */\n\t\t\t\t\tconn->dom_ctx = dom;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdom = dom->next;\n\t\t\t}\n\n\t\t\tDEBUG_TRACE(\"HTTP Host: %s\", host);\n\t\t}\n\n\t} else {\n\t\tsockaddr_to_string(buf, buflen, &conn->client.lsa);\n\t\thost = buf;\n\n\t\tDEBUG_TRACE(\"IP: %s\", host);\n\t}\n\n\treturn mg_strdup_ctx(host, conn->phys_ctx);\n}\n\n\nstatic void\nredirect_to_https_port(struct mg_connection *conn, int ssl_index)\n{\n\tchar target_url[MG_BUF_LEN];\n\tint truncated = 0;\n\n\tconn->must_close = 1;\n\n\t/* Send host, port, uri and (if it exists) ?query_string */\n\tif (conn->host) {\n\n\t\t/* Use \"308 Permanent Redirect\" */\n\t\tint redirect_code = 308;\n\n\t\t/* Create target URL */\n\t\tmg_snprintf(\n\t\t    conn,\n\t\t    &truncated,\n\t\t    target_url,\n\t\t    sizeof(target_url),\n\t\t    \"https://%s:%d%s%s%s\",\n\n\t\t    conn->host,\n#if defined(USE_IPV6)\n\t\t    (conn->phys_ctx->listening_sockets[ssl_index].lsa.sa.sa_family\n\t\t     == AF_INET6)\n\t\t        ? (int)ntohs(conn->phys_ctx->listening_sockets[ssl_index]\n\t\t                         .lsa.sin6.sin6_port)\n\t\t        :\n#endif\n\t\t        (int)ntohs(conn->phys_ctx->listening_sockets[ssl_index]\n\t\t                       .lsa.sin.sin_port),\n\t\t    conn->request_info.local_uri,\n\t\t    (conn->request_info.query_string == NULL) ? \"\" : \"?\",\n\t\t    (conn->request_info.query_string == NULL)\n\t\t        ? \"\"\n\t\t        : conn->request_info.query_string);\n\n\t\t/* Check overflow in location buffer (will not occur if MG_BUF_LEN\n\t\t * is used as buffer size) */\n\t\tif (truncated) {\n\t\t\tmg_send_http_error(conn, 500, \"%s\", \"Redirect URL too long\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* Use redirect helper function */\n\t\tmg_send_http_redirect(conn, target_url, redirect_code);\n\t}\n}\n\n\nstatic void\nhandler_info_acquire(struct mg_handler_info *handler_info)\n{\n\tpthread_mutex_lock(&handler_info->refcount_mutex);\n\thandler_info->refcount++;\n\tpthread_mutex_unlock(&handler_info->refcount_mutex);\n}\n\n\nstatic void\nhandler_info_release(struct mg_handler_info *handler_info)\n{\n\tpthread_mutex_lock(&handler_info->refcount_mutex);\n\thandler_info->refcount--;\n\tpthread_cond_signal(&handler_info->refcount_cond);\n\tpthread_mutex_unlock(&handler_info->refcount_mutex);\n}\n\n\nstatic void\nhandler_info_wait_unused(struct mg_handler_info *handler_info)\n{\n\tpthread_mutex_lock(&handler_info->refcount_mutex);\n\twhile (handler_info->refcount) {\n\t\tpthread_cond_wait(&handler_info->refcount_cond,\n\t\t                  &handler_info->refcount_mutex);\n\t}\n\tpthread_mutex_unlock(&handler_info->refcount_mutex);\n}\n\n\nstatic void\nmg_set_handler_type(struct mg_context *phys_ctx,\n                    struct mg_domain_context *dom_ctx,\n                    const char *uri,\n                    int handler_type,\n                    int is_delete_request,\n                    mg_request_handler handler,\n                    struct mg_websocket_subprotocols *subprotocols,\n                    mg_websocket_connect_handler connect_handler,\n                    mg_websocket_ready_handler ready_handler,\n                    mg_websocket_data_handler data_handler,\n                    mg_websocket_close_handler close_handler,\n                    mg_authorization_handler auth_handler,\n                    void *cbdata)\n{\n\tstruct mg_handler_info *tmp_rh, **lastref;\n\tsize_t urilen = strlen(uri);\n\n\tif (handler_type == WEBSOCKET_HANDLER) {\n\t\tDEBUG_ASSERT(handler == NULL);\n\t\tDEBUG_ASSERT(is_delete_request || connect_handler != NULL\n\t\t             || ready_handler != NULL || data_handler != NULL\n\t\t             || close_handler != NULL);\n\n\t\tDEBUG_ASSERT(auth_handler == NULL);\n\t\tif (handler != NULL) {\n\t\t\treturn;\n\t\t}\n\t\tif (!is_delete_request && (connect_handler == NULL)\n\t\t    && (ready_handler == NULL) && (data_handler == NULL)\n\t\t    && (close_handler == NULL)) {\n\t\t\treturn;\n\t\t}\n\t\tif (auth_handler != NULL) {\n\t\t\treturn;\n\t\t}\n\t} else if (handler_type == REQUEST_HANDLER) {\n\t\tDEBUG_ASSERT(connect_handler == NULL && ready_handler == NULL\n\t\t             && data_handler == NULL && close_handler == NULL);\n\t\tDEBUG_ASSERT(is_delete_request || (handler != NULL));\n\t\tDEBUG_ASSERT(auth_handler == NULL);\n\n\t\tif ((connect_handler != NULL) || (ready_handler != NULL)\n\t\t    || (data_handler != NULL) || (close_handler != NULL)) {\n\t\t\treturn;\n\t\t}\n\t\tif (!is_delete_request && (handler == NULL)) {\n\t\t\treturn;\n\t\t}\n\t\tif (auth_handler != NULL) {\n\t\t\treturn;\n\t\t}\n\t} else { /* AUTH_HANDLER */\n\t\tDEBUG_ASSERT(handler == NULL);\n\t\tDEBUG_ASSERT(connect_handler == NULL && ready_handler == NULL\n\t\t             && data_handler == NULL && close_handler == NULL);\n\t\tDEBUG_ASSERT(auth_handler != NULL);\n\t\tif (handler != NULL) {\n\t\t\treturn;\n\t\t}\n\t\tif ((connect_handler != NULL) || (ready_handler != NULL)\n\t\t    || (data_handler != NULL) || (close_handler != NULL)) {\n\t\t\treturn;\n\t\t}\n\t\tif (!is_delete_request && (auth_handler == NULL)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!phys_ctx || !dom_ctx) {\n\t\treturn;\n\t}\n\n\tmg_lock_context(phys_ctx);\n\n\t/* first try to find an existing handler */\n\tlastref = &(dom_ctx->handlers);\n\tfor (tmp_rh = dom_ctx->handlers; tmp_rh != NULL; tmp_rh = tmp_rh->next) {\n\t\tif (tmp_rh->handler_type == handler_type) {\n\t\t\tif ((urilen == tmp_rh->uri_len) && !strcmp(tmp_rh->uri, uri)) {\n\t\t\t\tif (!is_delete_request) {\n\t\t\t\t\t/* update existing handler */\n\t\t\t\t\tif (handler_type == REQUEST_HANDLER) {\n\t\t\t\t\t\t/* Wait for end of use before updating */\n\t\t\t\t\t\thandler_info_wait_unused(tmp_rh);\n\n\t\t\t\t\t\t/* Ok, the handler is no more use -> Update it */\n\t\t\t\t\t\ttmp_rh->handler = handler;\n\t\t\t\t\t} else if (handler_type == WEBSOCKET_HANDLER) {\n\t\t\t\t\t\ttmp_rh->subprotocols = subprotocols;\n\t\t\t\t\t\ttmp_rh->connect_handler = connect_handler;\n\t\t\t\t\t\ttmp_rh->ready_handler = ready_handler;\n\t\t\t\t\t\ttmp_rh->data_handler = data_handler;\n\t\t\t\t\t\ttmp_rh->close_handler = close_handler;\n\t\t\t\t\t} else { /* AUTH_HANDLER */\n\t\t\t\t\t\ttmp_rh->auth_handler = auth_handler;\n\t\t\t\t\t}\n\t\t\t\t\ttmp_rh->cbdata = cbdata;\n\t\t\t\t} else {\n\t\t\t\t\t/* remove existing handler */\n\t\t\t\t\tif (handler_type == REQUEST_HANDLER) {\n\t\t\t\t\t\t/* Wait for end of use before removing */\n\t\t\t\t\t\thandler_info_wait_unused(tmp_rh);\n\n\t\t\t\t\t\t/* Ok, the handler is no more used -> Destroy resources\n\t\t\t\t\t\t */\n\t\t\t\t\t\tpthread_cond_destroy(&tmp_rh->refcount_cond);\n\t\t\t\t\t\tpthread_mutex_destroy(&tmp_rh->refcount_mutex);\n\t\t\t\t\t}\n\t\t\t\t\t*lastref = tmp_rh->next;\n\t\t\t\t\tmg_free(tmp_rh->uri);\n\t\t\t\t\tmg_free(tmp_rh);\n\t\t\t\t}\n\t\t\t\tmg_unlock_context(phys_ctx);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tlastref = &(tmp_rh->next);\n\t}\n\n\tif (is_delete_request) {\n\t\t/* no handler to set, this was a remove request to a non-existing\n\t\t * handler */\n\t\tmg_unlock_context(phys_ctx);\n\t\treturn;\n\t}\n\n\ttmp_rh =\n\t    (struct mg_handler_info *)mg_calloc_ctx(sizeof(struct mg_handler_info),\n\t                                            1,\n\t                                            phys_ctx);\n\tif (tmp_rh == NULL) {\n\t\tmg_unlock_context(phys_ctx);\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"%s\",\n\t\t                \"Cannot create new request handler struct, OOM\");\n\t\treturn;\n\t}\n\ttmp_rh->uri = mg_strdup_ctx(uri, phys_ctx);\n\tif (!tmp_rh->uri) {\n\t\tmg_unlock_context(phys_ctx);\n\t\tmg_free(tmp_rh);\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"%s\",\n\t\t                \"Cannot create new request handler struct, OOM\");\n\t\treturn;\n\t}\n\ttmp_rh->uri_len = urilen;\n\tif (handler_type == REQUEST_HANDLER) {\n\t\t/* Init refcount mutex and condition */\n\t\tif (0 != pthread_mutex_init(&tmp_rh->refcount_mutex, NULL)) {\n\t\t\tmg_unlock_context(phys_ctx);\n\t\t\tmg_free(tmp_rh);\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", \"Cannot init refcount mutex\");\n\t\t\treturn;\n\t\t}\n\t\tif (0 != pthread_cond_init(&tmp_rh->refcount_cond, NULL)) {\n\t\t\tmg_unlock_context(phys_ctx);\n\t\t\tpthread_mutex_destroy(&tmp_rh->refcount_mutex);\n\t\t\tmg_free(tmp_rh);\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", \"Cannot init refcount cond\");\n\t\t\treturn;\n\t\t}\n\t\ttmp_rh->refcount = 0;\n\t\ttmp_rh->handler = handler;\n\t} else if (handler_type == WEBSOCKET_HANDLER) {\n\t\ttmp_rh->subprotocols = subprotocols;\n\t\ttmp_rh->connect_handler = connect_handler;\n\t\ttmp_rh->ready_handler = ready_handler;\n\t\ttmp_rh->data_handler = data_handler;\n\t\ttmp_rh->close_handler = close_handler;\n\t} else { /* AUTH_HANDLER */\n\t\ttmp_rh->auth_handler = auth_handler;\n\t}\n\ttmp_rh->cbdata = cbdata;\n\ttmp_rh->handler_type = handler_type;\n\ttmp_rh->next = NULL;\n\n\t*lastref = tmp_rh;\n\tmg_unlock_context(phys_ctx);\n}\n\n\nvoid\nmg_set_request_handler(struct mg_context *ctx,\n                       const char *uri,\n                       mg_request_handler handler,\n                       void *cbdata)\n{\n\tmg_set_handler_type(ctx,\n\t                    &(ctx->dd),\n\t                    uri,\n\t                    REQUEST_HANDLER,\n\t                    handler == NULL,\n\t                    handler,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    cbdata);\n}\n\n\nvoid\nmg_set_websocket_handler(struct mg_context *ctx,\n                         const char *uri,\n                         mg_websocket_connect_handler connect_handler,\n                         mg_websocket_ready_handler ready_handler,\n                         mg_websocket_data_handler data_handler,\n                         mg_websocket_close_handler close_handler,\n                         void *cbdata)\n{\n\tmg_set_websocket_handler_with_subprotocols(ctx,\n\t                                           uri,\n\t                                           NULL,\n\t                                           connect_handler,\n\t                                           ready_handler,\n\t                                           data_handler,\n\t                                           close_handler,\n\t                                           cbdata);\n}\n\n\nvoid\nmg_set_websocket_handler_with_subprotocols(\n    struct mg_context *ctx,\n    const char *uri,\n    struct mg_websocket_subprotocols *subprotocols,\n    mg_websocket_connect_handler connect_handler,\n    mg_websocket_ready_handler ready_handler,\n    mg_websocket_data_handler data_handler,\n    mg_websocket_close_handler close_handler,\n    void *cbdata)\n{\n\tint is_delete_request = (connect_handler == NULL) && (ready_handler == NULL)\n\t                        && (data_handler == NULL)\n\t                        && (close_handler == NULL);\n\tmg_set_handler_type(ctx,\n\t                    &(ctx->dd),\n\t                    uri,\n\t                    WEBSOCKET_HANDLER,\n\t                    is_delete_request,\n\t                    NULL,\n\t                    subprotocols,\n\t                    connect_handler,\n\t                    ready_handler,\n\t                    data_handler,\n\t                    close_handler,\n\t                    NULL,\n\t                    cbdata);\n}\n\n\nvoid\nmg_set_auth_handler(struct mg_context *ctx,\n                    const char *uri,\n                    mg_request_handler handler,\n                    void *cbdata)\n{\n\tmg_set_handler_type(ctx,\n\t                    &(ctx->dd),\n\t                    uri,\n\t                    AUTH_HANDLER,\n\t                    handler == NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    handler,\n\t                    cbdata);\n}\n\n\nstatic int\nget_request_handler(struct mg_connection *conn,\n                    int handler_type,\n                    mg_request_handler *handler,\n                    struct mg_websocket_subprotocols **subprotocols,\n                    mg_websocket_connect_handler *connect_handler,\n                    mg_websocket_ready_handler *ready_handler,\n                    mg_websocket_data_handler *data_handler,\n                    mg_websocket_close_handler *close_handler,\n                    mg_authorization_handler *auth_handler,\n                    void **cbdata,\n                    struct mg_handler_info **handler_info)\n{\n\tconst struct mg_request_info *request_info = mg_get_request_info(conn);\n\tif (request_info) {\n\t\tconst char *uri = request_info->local_uri;\n\t\tsize_t urilen = strlen(uri);\n\t\tstruct mg_handler_info *tmp_rh;\n\n\t\tif (!conn || !conn->phys_ctx || !conn->dom_ctx) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tmg_lock_context(conn->phys_ctx);\n\n\t\t/* first try for an exact match */\n\t\tfor (tmp_rh = conn->dom_ctx->handlers; tmp_rh != NULL;\n\t\t     tmp_rh = tmp_rh->next) {\n\t\t\tif (tmp_rh->handler_type == handler_type) {\n\t\t\t\tif ((urilen == tmp_rh->uri_len) && !strcmp(tmp_rh->uri, uri)) {\n\t\t\t\t\tif (handler_type == WEBSOCKET_HANDLER) {\n\t\t\t\t\t\t*subprotocols = tmp_rh->subprotocols;\n\t\t\t\t\t\t*connect_handler = tmp_rh->connect_handler;\n\t\t\t\t\t\t*ready_handler = tmp_rh->ready_handler;\n\t\t\t\t\t\t*data_handler = tmp_rh->data_handler;\n\t\t\t\t\t\t*close_handler = tmp_rh->close_handler;\n\t\t\t\t\t} else if (handler_type == REQUEST_HANDLER) {\n\t\t\t\t\t\t*handler = tmp_rh->handler;\n\t\t\t\t\t\t/* Acquire handler and give it back */\n\t\t\t\t\t\thandler_info_acquire(tmp_rh);\n\t\t\t\t\t\t*handler_info = tmp_rh;\n\t\t\t\t\t} else { /* AUTH_HANDLER */\n\t\t\t\t\t\t*auth_handler = tmp_rh->auth_handler;\n\t\t\t\t\t}\n\t\t\t\t\t*cbdata = tmp_rh->cbdata;\n\t\t\t\t\tmg_unlock_context(conn->phys_ctx);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* next try for a partial match, we will accept uri/something */\n\t\tfor (tmp_rh = conn->dom_ctx->handlers; tmp_rh != NULL;\n\t\t     tmp_rh = tmp_rh->next) {\n\t\t\tif (tmp_rh->handler_type == handler_type) {\n\t\t\t\tif ((tmp_rh->uri_len < urilen) && (uri[tmp_rh->uri_len] == '/')\n\t\t\t\t    && (memcmp(tmp_rh->uri, uri, tmp_rh->uri_len) == 0)) {\n\t\t\t\t\tif (handler_type == WEBSOCKET_HANDLER) {\n\t\t\t\t\t\t*subprotocols = tmp_rh->subprotocols;\n\t\t\t\t\t\t*connect_handler = tmp_rh->connect_handler;\n\t\t\t\t\t\t*ready_handler = tmp_rh->ready_handler;\n\t\t\t\t\t\t*data_handler = tmp_rh->data_handler;\n\t\t\t\t\t\t*close_handler = tmp_rh->close_handler;\n\t\t\t\t\t} else if (handler_type == REQUEST_HANDLER) {\n\t\t\t\t\t\t*handler = tmp_rh->handler;\n\t\t\t\t\t\t/* Acquire handler and give it back */\n\t\t\t\t\t\thandler_info_acquire(tmp_rh);\n\t\t\t\t\t\t*handler_info = tmp_rh;\n\t\t\t\t\t} else { /* AUTH_HANDLER */\n\t\t\t\t\t\t*auth_handler = tmp_rh->auth_handler;\n\t\t\t\t\t}\n\t\t\t\t\t*cbdata = tmp_rh->cbdata;\n\t\t\t\t\tmg_unlock_context(conn->phys_ctx);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* finally try for pattern match */\n\t\tfor (tmp_rh = conn->dom_ctx->handlers; tmp_rh != NULL;\n\t\t     tmp_rh = tmp_rh->next) {\n\t\t\tif (tmp_rh->handler_type == handler_type) {\n\t\t\t\tif (match_prefix(tmp_rh->uri, tmp_rh->uri_len, uri) > 0) {\n\t\t\t\t\tif (handler_type == WEBSOCKET_HANDLER) {\n\t\t\t\t\t\t*subprotocols = tmp_rh->subprotocols;\n\t\t\t\t\t\t*connect_handler = tmp_rh->connect_handler;\n\t\t\t\t\t\t*ready_handler = tmp_rh->ready_handler;\n\t\t\t\t\t\t*data_handler = tmp_rh->data_handler;\n\t\t\t\t\t\t*close_handler = tmp_rh->close_handler;\n\t\t\t\t\t} else if (handler_type == REQUEST_HANDLER) {\n\t\t\t\t\t\t*handler = tmp_rh->handler;\n\t\t\t\t\t\t/* Acquire handler and give it back */\n\t\t\t\t\t\thandler_info_acquire(tmp_rh);\n\t\t\t\t\t\t*handler_info = tmp_rh;\n\t\t\t\t\t} else { /* AUTH_HANDLER */\n\t\t\t\t\t\t*auth_handler = tmp_rh->auth_handler;\n\t\t\t\t\t}\n\t\t\t\t\t*cbdata = tmp_rh->cbdata;\n\t\t\t\t\tmg_unlock_context(conn->phys_ctx);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmg_unlock_context(conn->phys_ctx);\n\t}\n\treturn 0; /* none found */\n}\n\n\n/* Check if the script file is in a path, allowed for script files.\n * This can be used if uploading files is possible not only for the server\n * admin, and the upload mechanism does not check the file extension.\n */\nstatic int\nis_in_script_path(const struct mg_connection *conn, const char *path)\n{\n\t/* TODO (Feature): Add config value for allowed script path.\n\t * Default: All allowed. */\n\t(void)conn;\n\t(void)path;\n\treturn 1;\n}\n\n\n#if defined(USE_WEBSOCKET) && defined(MG_LEGACY_INTERFACE)\nstatic int\ndeprecated_websocket_connect_wrapper(const struct mg_connection *conn,\n                                     void *cbdata)\n{\n\tstruct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;\n\tif (pcallbacks->websocket_connect) {\n\t\treturn pcallbacks->websocket_connect(conn);\n\t}\n\t/* No handler set - assume \"OK\" */\n\treturn 0;\n}\n\n\nstatic void\ndeprecated_websocket_ready_wrapper(struct mg_connection *conn, void *cbdata)\n{\n\tstruct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;\n\tif (pcallbacks->websocket_ready) {\n\t\tpcallbacks->websocket_ready(conn);\n\t}\n}\n\n\nstatic int\ndeprecated_websocket_data_wrapper(struct mg_connection *conn,\n                                  int bits,\n                                  char *data,\n                                  size_t len,\n                                  void *cbdata)\n{\n\tstruct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;\n\tif (pcallbacks->websocket_data) {\n\t\treturn pcallbacks->websocket_data(conn, bits, data, len);\n\t}\n\t/* No handler set - assume \"OK\" */\n\treturn 1;\n}\n#endif\n\n\n/* This is the heart of the Civetweb's logic.\n * This function is called when the request is read, parsed and validated,\n * and Civetweb must decide what action to take: serve a file, or\n * a directory, or call embedded function, etcetera. */\nstatic void\nhandle_request(struct mg_connection *conn)\n{\n\tstruct mg_request_info *ri = &conn->request_info;\n\tchar path[PATH_MAX];\n\tint uri_len, ssl_index;\n\tint is_found = 0, is_script_resource = 0, is_websocket_request = 0,\n\t    is_put_or_delete_request = 0, is_callback_resource = 0;\n\tint i;\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tmg_request_handler callback_handler = NULL;\n\tstruct mg_handler_info *handler_info = NULL;\n\tstruct mg_websocket_subprotocols *subprotocols;\n\tmg_websocket_connect_handler ws_connect_handler = NULL;\n\tmg_websocket_ready_handler ws_ready_handler = NULL;\n\tmg_websocket_data_handler ws_data_handler = NULL;\n\tmg_websocket_close_handler ws_close_handler = NULL;\n\tvoid *callback_data = NULL;\n\tmg_authorization_handler auth_handler = NULL;\n\tvoid *auth_callback_data = NULL;\n\tint handler_type;\n\ttime_t curtime = time(NULL);\n\tchar date[64];\n\n\tpath[0] = 0;\n\n\t/* 1. get the request url */\n\t/* 1.1. split into url and query string */\n\tif ((conn->request_info.query_string = strchr(ri->request_uri, '?'))\n\t    != NULL) {\n\t\t*((char *)conn->request_info.query_string++) = '\\0';\n\t}\n\n\t/* 1.2. do a https redirect, if required. Do not decode URIs yet. */\n\tif (!conn->client.is_ssl && conn->client.ssl_redir) {\n\t\tssl_index = get_first_ssl_listener_index(conn->phys_ctx);\n\t\tif (ssl_index >= 0) {\n\t\t\tredirect_to_https_port(conn, ssl_index);\n\t\t} else {\n\t\t\t/* A http to https forward port has been specified,\n\t\t\t * but no https port to forward to. */\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   503,\n\t\t\t                   \"%s\",\n\t\t\t                   \"Error: SSL forward not configured properly\");\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s\",\n\t\t\t                \"Can not redirect to SSL, no SSL port available\");\n\t\t}\n\t\treturn;\n\t}\n\turi_len = (int)strlen(ri->local_uri);\n\n\t/* 1.3. decode url (if config says so) */\n\tif (should_decode_url(conn)) {\n\t\tmg_url_decode(\n\t\t    ri->local_uri, uri_len, (char *)ri->local_uri, uri_len + 1, 0);\n\t}\n\n\t/* 1.4. clean URIs, so a path like allowed_dir/../forbidden_file is\n\t * not possible */\n\tremove_double_dots_and_double_slashes((char *)ri->local_uri);\n\n\t/* step 1. completed, the url is known now */\n\turi_len = (int)strlen(ri->local_uri);\n\tDEBUG_TRACE(\"URL: %s\", ri->local_uri);\n\n\t/* 2. if this ip has limited speed, set it for this connection */\n\tconn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],\n\t                              get_remote_ip(conn),\n\t                              ri->local_uri);\n\n\t/* 3. call a \"handle everything\" callback, if registered */\n\tif (conn->phys_ctx->callbacks.begin_request != NULL) {\n\t\t/* Note that since V1.7 the \"begin_request\" function is called\n\t\t * before an authorization check. If an authorization check is\n\t\t * required, use a request_handler instead. */\n\t\ti = conn->phys_ctx->callbacks.begin_request(conn);\n\t\tif (i > 0) {\n\t\t\t/* callback already processed the request. Store the\n\t\t\t   return value as a status code for the access log. */\n\t\t\tconn->status_code = i;\n\t\t\tdiscard_unread_request_data(conn);\n\t\t\treturn;\n\t\t} else if (i == 0) {\n\t\t\t/* civetweb should process the request */\n\t\t} else {\n\t\t\t/* unspecified - may change with the next version */\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* request not yet handled by a handler or redirect, so the request\n\t * is processed here */\n\n\t/* 4. Check for CORS preflight requests and handle them (if configured).\n\t * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS\n\t */\n\tif (!strcmp(ri->request_method, \"OPTIONS\")) {\n\t\t/* Send a response to CORS preflights only if\n\t\t * access_control_allow_methods is not NULL and not an empty string.\n\t\t * In this case, scripts can still handle CORS. */\n\t\tconst char *cors_meth_cfg =\n\t\t    conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];\n\t\tconst char *cors_orig_cfg =\n\t\t    conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];\n\t\tconst char *cors_origin =\n\t\t    get_header(ri->http_headers, ri->num_headers, \"Origin\");\n\t\tconst char *cors_acrm = get_header(ri->http_headers,\n\t\t                                   ri->num_headers,\n\t\t                                   \"Access-Control-Request-Method\");\n\n\t\t/* Todo: check if cors_origin is in cors_orig_cfg.\n\t\t * Or, let the client check this. */\n\n\t\tif ((cors_meth_cfg != NULL) && (*cors_meth_cfg != 0)\n\t\t    && (cors_orig_cfg != NULL) && (*cors_orig_cfg != 0)\n\t\t    && (cors_origin != NULL) && (cors_acrm != NULL)) {\n\t\t\t/* This is a valid CORS preflight, and the server is configured\n\t\t\t * to\n\t\t\t * handle it automatically. */\n\t\t\tconst char *cors_acrh =\n\t\t\t    get_header(ri->http_headers,\n\t\t\t               ri->num_headers,\n\t\t\t               \"Access-Control-Request-Headers\");\n\n\t\t\tgmt_time_string(date, sizeof(date), &curtime);\n\t\t\tmg_printf(conn,\n\t\t\t          \"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t          \"Date: %s\\r\\n\"\n\t\t\t          \"Access-Control-Allow-Origin: %s\\r\\n\"\n\t\t\t          \"Access-Control-Allow-Methods: %s\\r\\n\"\n\t\t\t          \"Content-Length: 0\\r\\n\"\n\t\t\t          \"Connection: %s\\r\\n\",\n\t\t\t          date,\n\t\t\t          cors_orig_cfg,\n\t\t\t          ((cors_meth_cfg[0] == '*') ? cors_acrm : cors_meth_cfg),\n\t\t\t          suggest_connection_header(conn));\n\n\t\t\tif (cors_acrh != NULL) {\n\t\t\t\t/* CORS request is asking for additional headers */\n\t\t\t\tconst char *cors_hdr_cfg =\n\t\t\t\t    conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];\n\n\t\t\t\tif ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {\n\t\t\t\t\t/* Allow only if access_control_allow_headers is\n\t\t\t\t\t * not NULL and not an empty string. If this\n\t\t\t\t\t * configuration is set to *, allow everything.\n\t\t\t\t\t * Otherwise this configuration must be a list\n\t\t\t\t\t * of allowed HTTP header names. */\n\t\t\t\t\tmg_printf(conn,\n\t\t\t\t\t          \"Access-Control-Allow-Headers: %s\\r\\n\",\n\t\t\t\t\t          ((cors_hdr_cfg[0] == '*') ? cors_acrh\n\t\t\t\t\t                                    : cors_hdr_cfg));\n\t\t\t\t}\n\t\t\t}\n\t\t\tmg_printf(conn, \"Access-Control-Max-Age: 60\\r\\n\");\n\n\t\t\tmg_printf(conn, \"\\r\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* 5. interpret the url to find out how the request must be handled\n\t */\n\t/* 5.1. first test, if the request targets the regular http(s)://\n\t * protocol namespace or the websocket ws(s):// protocol namespace.\n\t */\n\tis_websocket_request = is_websocket_protocol(conn);\n#if defined(USE_WEBSOCKET)\n\thandler_type = is_websocket_request ? WEBSOCKET_HANDLER : REQUEST_HANDLER;\n#else\n\thandler_type = REQUEST_HANDLER;\n#endif /* defined(USE_WEBSOCKET) */\n\t/* 5.2. check if the request will be handled by a callback */\n\tif (get_request_handler(conn,\n\t                        handler_type,\n\t                        &callback_handler,\n\t                        &subprotocols,\n\t                        &ws_connect_handler,\n\t                        &ws_ready_handler,\n\t                        &ws_data_handler,\n\t                        &ws_close_handler,\n\t                        NULL,\n\t                        &callback_data,\n\t                        &handler_info)) {\n\t\t/* 5.2.1. A callback will handle this request. All requests\n\t\t * handled\n\t\t * by a callback have to be considered as requests to a script\n\t\t * resource. */\n\t\tis_callback_resource = 1;\n\t\tis_script_resource = 1;\n\t\tis_put_or_delete_request = is_put_or_delete_method(conn);\n\t} else {\n\tno_callback_resource:\n\n\t\t/* 5.2.2. No callback is responsible for this request. The URI\n\t\t * addresses a file based resource (static content or Lua/cgi\n\t\t * scripts in the file system). */\n\t\tis_callback_resource = 0;\n\t\tinterpret_uri(conn,\n\t\t              path,\n\t\t              sizeof(path),\n\t\t              &file.stat,\n\t\t              &is_found,\n\t\t              &is_script_resource,\n\t\t              &is_websocket_request,\n\t\t              &is_put_or_delete_request);\n\t}\n\n\t/* 6. authorization check */\n\t/* 6.1. a custom authorization handler is installed */\n\tif (get_request_handler(conn,\n\t                        AUTH_HANDLER,\n\t                        NULL,\n\t                        NULL,\n\t                        NULL,\n\t                        NULL,\n\t                        NULL,\n\t                        NULL,\n\t                        &auth_handler,\n\t                        &auth_callback_data,\n\t                        NULL)) {\n\t\tif (!auth_handler(conn, auth_callback_data)) {\n\t\t\treturn;\n\t\t}\n\t} else if (is_put_or_delete_request && !is_script_resource\n\t           && !is_callback_resource) {\n/* 6.2. this request is a PUT/DELETE to a real file */\n/* 6.2.1. thus, the server must have real files */\n#if defined(NO_FILES)\n\t\tif (1) {\n#else\n\t\tif (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {\n#endif\n\t\t\t/* This server does not have any real files, thus the\n\t\t\t * PUT/DELETE methods are not valid. */\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   405,\n\t\t\t                   \"%s method not allowed\",\n\t\t\t                   conn->request_info.request_method);\n\t\t\treturn;\n\t\t}\n\n#if !defined(NO_FILES)\n\t\t/* 6.2.2. Check if put authorization for static files is\n\t\t * available.\n\t\t */\n\t\tif (!is_authorized_for_put(conn)) {\n\t\t\tsend_authorization_request(conn, NULL);\n\t\t\treturn;\n\t\t}\n#endif\n\n\t} else {\n\t\t/* 6.3. This is either a OPTIONS, GET, HEAD or POST request,\n\t\t * or it is a PUT or DELETE request to a resource that does not\n\t\t * correspond to a file. Check authorization. */\n\t\tif (!check_authorization(conn, path)) {\n\t\t\tsend_authorization_request(conn, NULL);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* request is authorized or does not need authorization */\n\n\t/* 7. check if there are request handlers for this uri */\n\tif (is_callback_resource) {\n\t\tif (!is_websocket_request) {\n\t\t\ti = callback_handler(conn, callback_data);\n\n\t\t\t/* Callback handler will not be used anymore. Release it */\n\t\t\thandler_info_release(handler_info);\n\n\t\t\tif (i > 0) {\n\t\t\t\t/* Do nothing, callback has served the request. Store\n\t\t\t\t * then return value as status code for the log and discard\n\t\t\t\t * all data from the client not used by the callback. */\n\t\t\t\tconn->status_code = i;\n\t\t\t\tdiscard_unread_request_data(conn);\n\t\t\t} else {\n\t\t\t\t/* The handler did NOT handle the request. */\n\t\t\t\t/* Some proper reactions would be:\n\t\t\t\t * a) close the connections without sending anything\n\t\t\t\t * b) send a 404 not found\n\t\t\t\t * c) try if there is a file matching the URI\n\t\t\t\t * It would be possible to do a, b or c in the callback\n\t\t\t\t * implementation, and return 1 - we cannot do anything\n\t\t\t\t * here, that is not possible in the callback.\n\t\t\t\t *\n\t\t\t\t * TODO: What would be the best reaction here?\n\t\t\t\t * (Note: The reaction may change, if there is a better\n\t\t\t\t *idea.)\n\t\t\t\t */\n\n\t\t\t\t/* For the moment, use option c: We look for a proper file,\n\t\t\t\t * but since a file request is not always a script resource,\n\t\t\t\t * the authorization check might be different. */\n\t\t\t\tinterpret_uri(conn,\n\t\t\t\t              path,\n\t\t\t\t              sizeof(path),\n\t\t\t\t              &file.stat,\n\t\t\t\t              &is_found,\n\t\t\t\t              &is_script_resource,\n\t\t\t\t              &is_websocket_request,\n\t\t\t\t              &is_put_or_delete_request);\n\t\t\t\tcallback_handler = NULL;\n\n\t\t\t\t/* Here we are at a dead end:\n\t\t\t\t * According to URI matching, a callback should be\n\t\t\t\t * responsible for handling the request,\n\t\t\t\t * we called it, but the callback declared itself\n\t\t\t\t * not responsible.\n\t\t\t\t * We use a goto here, to get out of this dead end,\n\t\t\t\t * and continue with the default handling.\n\t\t\t\t * A goto here is simpler and better to understand\n\t\t\t\t * than some curious loop. */\n\t\t\t\tgoto no_callback_resource;\n\t\t\t}\n\t\t} else {\n#if defined(USE_WEBSOCKET)\n\t\t\thandle_websocket_request(conn,\n\t\t\t                         path,\n\t\t\t                         is_callback_resource,\n\t\t\t                         subprotocols,\n\t\t\t                         ws_connect_handler,\n\t\t\t                         ws_ready_handler,\n\t\t\t                         ws_data_handler,\n\t\t\t                         ws_close_handler,\n\t\t\t                         callback_data);\n#endif\n\t\t}\n\t\treturn;\n\t}\n\n/* 8. handle websocket requests */\n#if defined(USE_WEBSOCKET)\n\tif (is_websocket_request) {\n\t\tif (is_script_resource) {\n\n\t\t\tif (is_in_script_path(conn, path)) {\n\t\t\t\t/* Websocket Lua script */\n\t\t\t\thandle_websocket_request(conn,\n\t\t\t\t                         path,\n\t\t\t\t                         0 /* Lua Script */,\n\t\t\t\t                         NULL,\n\t\t\t\t                         NULL,\n\t\t\t\t                         NULL,\n\t\t\t\t                         NULL,\n\t\t\t\t                         NULL,\n\t\t\t\t                         conn->phys_ctx->user_data);\n\t\t\t} else {\n\t\t\t\t/* Script was in an illegal path */\n\t\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t\t}\n\t\t} else {\n#if defined(MG_LEGACY_INTERFACE)\n\t\t\thandle_websocket_request(\n\t\t\t    conn,\n\t\t\t    path,\n\t\t\t    !is_script_resource /* could be deprecated global callback */,\n\t\t\t    NULL,\n\t\t\t    deprecated_websocket_connect_wrapper,\n\t\t\t    deprecated_websocket_ready_wrapper,\n\t\t\t    deprecated_websocket_data_wrapper,\n\t\t\t    NULL,\n\t\t\t    conn->phys_ctx->user_data);\n#else\n\t\t\tmg_send_http_error(conn, 404, \"%s\", \"Not found\");\n#endif\n\t\t}\n\t\treturn;\n\t} else\n#endif\n\n#if defined(NO_FILES)\n\t\t/* 9a. In case the server uses only callbacks, this uri is\n\t\t * unknown.\n\t\t * Then, all request handling ends here. */\n\t\tmg_send_http_error(conn, 404, \"%s\", \"Not Found\");\n\n#else\n\t/* 9b. This request is either for a static file or resource handled\n\t * by a script file. Thus, a DOCUMENT_ROOT must exist. */\n\tif (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {\n\t\tmg_send_http_error(conn, 404, \"%s\", \"Not Found\");\n\t\treturn;\n\t}\n\n\t/* 10. Request is handled by a script */\n\tif (is_script_resource) {\n\t\thandle_file_based_request(conn, path, &file);\n\t\treturn;\n\t}\n\n\t/* 11. Handle put/delete/mkcol requests */\n\tif (is_put_or_delete_request) {\n\t\t/* 11.1. PUT method */\n\t\tif (!strcmp(ri->request_method, \"PUT\")) {\n\t\t\tput_file(conn, path);\n\t\t\treturn;\n\t\t}\n\t\t/* 11.2. DELETE method */\n\t\tif (!strcmp(ri->request_method, \"DELETE\")) {\n\t\t\tdelete_file(conn, path);\n\t\t\treturn;\n\t\t}\n\t\t/* 11.3. MKCOL method */\n\t\tif (!strcmp(ri->request_method, \"MKCOL\")) {\n\t\t\tmkcol(conn, path);\n\t\t\treturn;\n\t\t}\n\t\t/* 11.4. PATCH method\n\t\t * This method is not supported for static resources,\n\t\t * only for scripts (Lua, CGI) and callbacks. */\n\t\tmg_send_http_error(conn,\n\t\t                   405,\n\t\t                   \"%s method not allowed\",\n\t\t                   conn->request_info.request_method);\n\t\treturn;\n\t}\n\n\t/* 11. File does not exist, or it was configured that it should be\n\t * hidden */\n\tif (!is_found || (must_hide_file(conn, path))) {\n\t\tmg_send_http_error(conn, 404, \"%s\", \"Not found\");\n\t\treturn;\n\t}\n\n\t/* 12. Directory uris should end with a slash */\n\tif (file.stat.is_directory && (uri_len > 0)\n\t    && (ri->local_uri[uri_len - 1] != '/')) {\n\t\tgmt_time_string(date, sizeof(date), &curtime);\n\t\tmg_printf(conn,\n\t\t          \"HTTP/1.1 301 Moved Permanently\\r\\n\"\n\t\t          \"Location: %s/\\r\\n\"\n\t\t          \"Date: %s\\r\\n\"\n\t\t          /* \"Cache-Control: private\\r\\n\" (= default) */\n\t\t          \"Content-Length: 0\\r\\n\"\n\t\t          \"Connection: %s\\r\\n\",\n\t\t          ri->request_uri,\n\t\t          date,\n\t\t          suggest_connection_header(conn));\n\t\tsend_additional_header(conn);\n\t\tmg_printf(conn, \"\\r\\n\");\n\t\treturn;\n\t}\n\n\t/* 13. Handle other methods than GET/HEAD */\n\t/* 13.1. Handle PROPFIND */\n\tif (!strcmp(ri->request_method, \"PROPFIND\")) {\n\t\thandle_propfind(conn, path, &file.stat);\n\t\treturn;\n\t}\n\t/* 13.2. Handle OPTIONS for files */\n\tif (!strcmp(ri->request_method, \"OPTIONS\")) {\n\t\t/* This standard handler is only used for real files.\n\t\t * Scripts should support the OPTIONS method themselves, to allow a\n\t\t * maximum flexibility.\n\t\t * Lua and CGI scripts may fully support CORS this way (including\n\t\t * preflights). */\n\t\tsend_options(conn);\n\t\treturn;\n\t}\n\t/* 13.3. everything but GET and HEAD (e.g. POST) */\n\tif ((0 != strcmp(ri->request_method, \"GET\"))\n\t    && (0 != strcmp(ri->request_method, \"HEAD\"))) {\n\t\tmg_send_http_error(conn,\n\t\t                   405,\n\t\t                   \"%s method not allowed\",\n\t\t                   conn->request_info.request_method);\n\t\treturn;\n\t}\n\n\t/* 14. directories */\n\tif (file.stat.is_directory) {\n\t\t/* Substitute files have already been handled above. */\n\t\t/* Here we can either generate and send a directory listing,\n\t\t * or send an \"access denied\" error. */\n\t\tif (!mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],\n\t\t                   \"yes\")) {\n\t\t\thandle_directory_request(conn, path);\n\t\t} else {\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   403,\n\t\t\t                   \"%s\",\n\t\t\t                   \"Error: Directory listing denied\");\n\t\t}\n\t\treturn;\n\t}\n\n\t/* 15. read a normal file with GET or HEAD */\n\thandle_file_based_request(conn, path, &file);\n#endif /* !defined(NO_FILES) */\n}\n\n\nstatic void\nhandle_file_based_request(struct mg_connection *conn,\n                          const char *path,\n                          struct mg_file *file)\n{\n\tif (!conn || !conn->dom_ctx) {\n\t\treturn;\n\t}\n\n\tif (0) {\n#if defined(USE_LUA)\n\t} else if (match_prefix(\n\t               conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],\n\t               strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS]),\n\t               path)\n\t           > 0) {\n\t\tif (is_in_script_path(conn, path)) {\n\t\t\t/* Lua server page: an SSI like page containing mostly plain\n\t\t\t * html\n\t\t\t * code\n\t\t\t * plus some tags with server generated contents. */\n\t\t\thandle_lsp_request(conn, path, file, NULL);\n\t\t} else {\n\t\t\t/* Script was in an illegal path */\n\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t}\n\n\t} else if (match_prefix(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS],\n\t                        strlen(\n\t                            conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS]),\n\t                        path)\n\t           > 0) {\n\t\tif (is_in_script_path(conn, path)) {\n\t\t\t/* Lua in-server module script: a CGI like script used to\n\t\t\t * generate\n\t\t\t * the\n\t\t\t * entire reply. */\n\t\t\tmg_exec_lua_script(conn, path, NULL);\n\t\t} else {\n\t\t\t/* Script was in an illegal path */\n\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t}\n#endif\n#if defined(USE_DUKTAPE)\n\t} else if (match_prefix(\n\t               conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],\n\t               strlen(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS]),\n\t               path)\n\t           > 0) {\n\t\tif (is_in_script_path(conn, path)) {\n\t\t\t/* Call duktape to generate the page */\n\t\t\tmg_exec_duktape_script(conn, path);\n\t\t} else {\n\t\t\t/* Script was in an illegal path */\n\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t}\n#endif\n#if !defined(NO_CGI)\n\t} else if (match_prefix(conn->dom_ctx->config[CGI_EXTENSIONS],\n\t                        strlen(conn->dom_ctx->config[CGI_EXTENSIONS]),\n\t                        path)\n\t           > 0) {\n\t\tif (is_in_script_path(conn, path)) {\n\t\t\t/* CGI scripts may support all HTTP methods */\n\t\t\thandle_cgi_request(conn, path);\n\t\t} else {\n\t\t\t/* Script was in an illegal path */\n\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t}\n#endif /* !NO_CGI */\n\t} else if (match_prefix(conn->dom_ctx->config[SSI_EXTENSIONS],\n\t                        strlen(conn->dom_ctx->config[SSI_EXTENSIONS]),\n\t                        path)\n\t           > 0) {\n\t\tif (is_in_script_path(conn, path)) {\n\t\t\thandle_ssi_file_request(conn, path, file);\n\t\t} else {\n\t\t\t/* Script was in an illegal path */\n\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t}\n#if !defined(NO_CACHING)\n\t} else if ((!conn->in_error_handler)\n\t           && is_not_modified(conn, &file->stat)) {\n\t\t/* Send 304 \"Not Modified\" - this must not send any body data */\n\t\thandle_not_modified_static_file_request(conn, file);\n#endif /* !NO_CACHING */\n\t} else {\n\t\thandle_static_file_request(conn, path, file, NULL, NULL);\n\t}\n}\n\n\nstatic void\nclose_all_listening_sockets(struct mg_context *ctx)\n{\n\tunsigned int i;\n\tif (!ctx) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ctx->num_listening_sockets; i++) {\n\t\tclosesocket(ctx->listening_sockets[i].sock);\n\t\tctx->listening_sockets[i].sock = INVALID_SOCKET;\n\t}\n\tmg_free(ctx->listening_sockets);\n\tctx->listening_sockets = NULL;\n\tmg_free(ctx->listening_socket_fds);\n\tctx->listening_socket_fds = NULL;\n}\n\n\n/* Valid listening port specification is: [ip_address:]port[s]\n * Examples for IPv4: 80, 443s, 127.0.0.1:3128, 192.0.2.3:8080s\n * Examples for IPv6: [::]:80, [::1]:80,\n *   [2001:0db8:7654:3210:FEDC:BA98:7654:3210]:443s\n *   see https://tools.ietf.org/html/rfc3513#section-2.2\n * In order to bind to both, IPv4 and IPv6, you can either add\n * both ports using 8080,[::]:8080, or the short form +8080.\n * Both forms differ in detail: 8080,[::]:8080 create two sockets,\n * one only accepting IPv4 the other only IPv6. +8080 creates\n * one socket accepting IPv4 and IPv6. Depending on the IPv6\n * environment, they might work differently, or might not work\n * at all - it must be tested what options work best in the\n * relevant network environment.\n */\nstatic int\nparse_port_string(const struct vec *vec, struct socket *so, int *ip_version)\n{\n\tunsigned int a, b, c, d, port;\n\tint ch, len;\n\tconst char *cb;\n#if defined(USE_IPV6)\n\tchar buf[100] = {0};\n#endif\n\n\t/* MacOS needs that. If we do not zero it, subsequent bind() will fail.\n\t * Also, all-zeroes in the socket address means binding to all addresses\n\t * for both IPv4 and IPv6 (INADDR_ANY and IN6ADDR_ANY_INIT). */\n\tmemset(so, 0, sizeof(*so));\n\tso->lsa.sin.sin_family = AF_INET;\n\t*ip_version = 0;\n\n\t/* Initialize port and len as invalid. */\n\tport = 0;\n\tlen = 0;\n\n\t/* Test for different ways to format this string */\n\tif (sscanf(vec->ptr, \"%u.%u.%u.%u:%u%n\", &a, &b, &c, &d, &port, &len)\n\t    == 5) {\n\t\t/* Bind to a specific IPv4 address, e.g. 192.168.1.5:8080 */\n\t\tso->lsa.sin.sin_addr.s_addr =\n\t\t    htonl((a << 24) | (b << 16) | (c << 8) | d);\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n\n#if defined(USE_IPV6)\n\t} else if (sscanf(vec->ptr, \"[%49[^]]]:%u%n\", buf, &port, &len) == 2\n\t           && mg_inet_pton(\n\t                  AF_INET6, buf, &so->lsa.sin6, sizeof(so->lsa.sin6))) {\n\t\t/* IPv6 address, examples: see above */\n\t\t/* so->lsa.sin6.sin6_family = AF_INET6; already set by mg_inet_pton\n\t\t */\n\t\tso->lsa.sin6.sin6_port = htons((uint16_t)port);\n\t\t*ip_version = 6;\n#endif\n\n\t} else if ((vec->ptr[0] == '+')\n\t           && (sscanf(vec->ptr + 1, \"%u%n\", &port, &len) == 1)) {\n\n\t\t/* Port is specified with a +, bind to IPv6 and IPv4, INADDR_ANY */\n\t\t/* Add 1 to len for the + character we skipped before */\n\t\tlen++;\n\n#if defined(USE_IPV6)\n\t\t/* Set socket family to IPv6, do not use IPV6_V6ONLY */\n\t\tso->lsa.sin6.sin6_family = AF_INET6;\n\t\tso->lsa.sin6.sin6_port = htons((uint16_t)port);\n\t\t*ip_version = 4 + 6;\n#else\n\t\t/* Bind to IPv4 only, since IPv6 is not built in. */\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n#endif\n\n\t} else if (sscanf(vec->ptr, \"%u%n\", &port, &len) == 1) {\n\t\t/* If only port is specified, bind to IPv4, INADDR_ANY */\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n\n\t} else if ((cb = strchr(vec->ptr, ':')) != NULL) {\n\t\t/* String could be a hostname. This check algotithm\n\t\t * will only work for RFC 952 compliant hostnames,\n\t\t * starting with a letter, containing only letters,\n\t\t * digits and hyphen ('-'). Newer specs may allow\n\t\t * more, but this is not guaranteed here, since it\n\t\t * may interfere with rules for port option lists. */\n\n\t\t/* According to RFC 1035, hostnames are restricted to 255 characters\n\t\t * in total (63 between two dots). */\n\t\tchar hostname[256];\n\t\tsize_t hostnlen = (size_t)(cb - vec->ptr);\n\n\t\tif (hostnlen >= sizeof(hostname)) {\n\t\t\t/* This would be invalid in any case */\n\t\t\t*ip_version = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tmemcpy(hostname, vec->ptr, hostnlen);\n\t\thostname[hostnlen] = 0;\n\n\t\tif (mg_inet_pton(\n\t\t        AF_INET, vec->ptr, &so->lsa.sin, sizeof(so->lsa.sin))) {\n\t\t\tif (sscanf(cb + 1, \"%u%n\", &port, &len) == 1) {\n\t\t\t\t*ip_version = 4;\n\t\t\t\tso->lsa.sin.sin_family = AF_INET;\n\t\t\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t\t\tlen += (int)(hostnlen + 1);\n\t\t\t} else {\n\t\t\t\tport = 0;\n\t\t\t\tlen = 0;\n\t\t\t}\n#if defined(USE_IPV6)\n\t\t} else if (mg_inet_pton(AF_INET6,\n\t\t                        vec->ptr,\n\t\t                        &so->lsa.sin6,\n\t\t                        sizeof(so->lsa.sin6))) {\n\t\t\tif (sscanf(cb + 1, \"%u%n\", &port, &len) == 1) {\n\t\t\t\t*ip_version = 6;\n\t\t\t\tso->lsa.sin6.sin6_family = AF_INET6;\n\t\t\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t\t\tlen += (int)(hostnlen + 1);\n\t\t\t} else {\n\t\t\t\tport = 0;\n\t\t\t\tlen = 0;\n\t\t\t}\n#endif\n\t\t}\n\n\n\t} else {\n\t\t/* Parsing failure. */\n\t}\n\n\t/* sscanf and the option splitting code ensure the following condition\n\t */\n\tif ((len < 0) && ((unsigned)len > (unsigned)vec->len)) {\n\t\t*ip_version = 0;\n\t\treturn 0;\n\t}\n\tch = vec->ptr[len]; /* Next character after the port number */\n\tso->is_ssl = (ch == 's');\n\tso->ssl_redir = (ch == 'r');\n\n\t/* Make sure the port is valid and vector ends with 's', 'r' or ',' */\n\tif (is_valid_port(port)\n\t    && ((ch == '\\0') || (ch == 's') || (ch == 'r') || (ch == ','))) {\n\t\treturn 1;\n\t}\n\n\t/* Reset ip_version to 0 if there is an error */\n\t*ip_version = 0;\n\treturn 0;\n}\n\n\n/* Is there any SSL port in use? */\nstatic int\nis_ssl_port_used(const char *ports)\n{\n\tif (ports) {\n\t\t/* There are several different allowed syntax variants:\n\t\t * - \"80\" for a single port using every network interface\n\t\t * - \"localhost:80\" for a single port using only localhost\n\t\t * - \"80,localhost:8080\" for two ports, one bound to localhost\n\t\t * - \"80,127.0.0.1:8084,[::1]:8086\" for three ports, one bound\n\t\t *   to IPv4 localhost, one to IPv6 localhost\n\t\t * - \"+80\" use port 80 for IPv4 and IPv6\n\t\t * - \"+80r,+443s\" port 80 (HTTP) is a redirect to port 443 (HTTPS),\n\t\t *   for both: IPv4 and IPv4\n\t\t * - \"+443s,localhost:8080\" port 443 (HTTPS) for every interface,\n\t\t *   additionally port 8080 bound to localhost connections\n\t\t *\n\t\t * If we just look for 's' anywhere in the string, \"localhost:80\"\n\t\t * will be detected as SSL (false positive).\n\t\t * Looking for 's' after a digit may cause false positives in\n\t\t * \"my24service:8080\".\n\t\t * Looking from 's' backward if there are only ':' and numbers\n\t\t * before will not work for \"24service:8080\" (non SSL, port 8080)\n\t\t * or \"24s\" (SSL, port 24).\n\t\t *\n\t\t * Remark: Initially hostnames were not allowed to start with a\n\t\t * digit (according to RFC 952), this was allowed later (RFC 1123,\n\t\t * Section 2.1).\n\t\t *\n\t\t * To get this correct, the entire string must be parsed as a whole,\n\t\t * reading it as a list element for element and parsing with an\n\t\t * algorithm equivalent to parse_port_string.\n\t\t *\n\t\t * In fact, we use local interface names here, not arbitrary hostnames,\n\t\t * so in most cases the only name will be \"localhost\".\n\t\t *\n\t\t * So, for now, we use this simple algorithm, that may still return\n\t\t * a false positive in bizarre cases.\n\t\t */\n\t\tint i;\n\t\tint portslen = (int)strlen(ports);\n\t\tchar prevIsNumber = 0;\n\n\t\tfor (i = 0; i < portslen; i++) {\n\t\t\tif (prevIsNumber && (ports[i] == 's' || ports[i] == 'r')) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (ports[i] >= '0' && ports[i] <= '9') {\n\t\t\t\tprevIsNumber = 1;\n\t\t\t} else {\n\t\t\t\tprevIsNumber = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nstatic int\nset_ports_option(struct mg_context *phys_ctx)\n{\n\tconst char *list;\n\tint on = 1;\n#if defined(USE_IPV6)\n\tint off = 0;\n#endif\n\tstruct vec vec;\n\tstruct socket so, *ptr;\n\n\tstruct pollfd *pfd;\n\tunion usa usa;\n\tsocklen_t len;\n\tint ip_version;\n\n\tint portsTotal = 0;\n\tint portsOk = 0;\n\n\tif (!phys_ctx) {\n\t\treturn 0;\n\t}\n\n\tmemset(&so, 0, sizeof(so));\n\tmemset(&usa, 0, sizeof(usa));\n\tlen = sizeof(usa);\n\tlist = phys_ctx->dd.config[LISTENING_PORTS];\n\n\twhile ((list = next_option(list, &vec, NULL)) != NULL) {\n\n\t\tportsTotal++;\n\n\t\tif (!parse_port_string(&vec, &so, &ip_version)) {\n\t\t\tmg_cry_internal(\n\t\t\t    fc(phys_ctx),\n\t\t\t    \"%.*s: invalid port spec (entry %i). Expecting list of: %s\",\n\t\t\t    (int)vec.len,\n\t\t\t    vec.ptr,\n\t\t\t    portsTotal,\n\t\t\t    \"[IP_ADDRESS:]PORT[s|r]\");\n\t\t\tcontinue;\n\t\t}\n\n#if !defined(NO_SSL)\n\t\tif (so.is_ssl && phys_ctx->dd.ssl_ctx == NULL) {\n\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"Cannot add SSL socket (entry %i)\",\n\t\t\t                portsTotal);\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\tif ((so.sock = socket(so.lsa.sa.sa_family, SOCK_STREAM, 6))\n\t\t    == INVALID_SOCKET) {\n\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"cannot create socket (entry %i)\",\n\t\t\t                portsTotal);\n\t\t\tcontinue;\n\t\t}\n\n#if defined(_WIN32)\n\t\t/* Windows SO_REUSEADDR lets many procs binds to a\n\t\t * socket, SO_EXCLUSIVEADDRUSE makes the bind fail\n\t\t * if someone already has the socket -- DTL */\n\t\t/* NOTE: If SO_EXCLUSIVEADDRUSE is used,\n\t\t * Windows might need a few seconds before\n\t\t * the same port can be used again in the\n\t\t * same process, so a short Sleep may be\n\t\t * required between mg_stop and mg_start.\n\t\t */\n\t\tif (setsockopt(so.sock,\n\t\t               SOL_SOCKET,\n\t\t               SO_EXCLUSIVEADDRUSE,\n\t\t               (SOCK_OPT_TYPE)&on,\n\t\t               sizeof(on))\n\t\t    != 0) {\n\n\t\t\t/* Set reuse option, but don't abort on errors. */\n\t\t\tmg_cry_internal(\n\t\t\t    fc(phys_ctx),\n\t\t\t    \"cannot set socket option SO_EXCLUSIVEADDRUSE (entry %i)\",\n\t\t\t    portsTotal);\n\t\t}\n#else\n\t\tif (setsockopt(so.sock,\n\t\t               SOL_SOCKET,\n\t\t               SO_REUSEADDR,\n\t\t               (SOCK_OPT_TYPE)&on,\n\t\t               sizeof(on))\n\t\t    != 0) {\n\n\t\t\t/* Set reuse option, but don't abort on errors. */\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"cannot set socket option SO_REUSEADDR (entry %i)\",\n\t\t\t                portsTotal);\n\t\t}\n#endif\n\n\t\tif (ip_version > 4) {\n/* Could be 6 for IPv6 onlyor 10 (4+6) for IPv4+IPv6 */\n#if defined(USE_IPV6)\n\t\t\tif (ip_version > 6) {\n\t\t\t\tif (so.lsa.sa.sa_family == AF_INET6\n\t\t\t\t    && setsockopt(so.sock,\n\t\t\t\t                  IPPROTO_IPV6,\n\t\t\t\t                  IPV6_V6ONLY,\n\t\t\t\t                  (void *)&off,\n\t\t\t\t                  sizeof(off))\n\t\t\t\t           != 0) {\n\n\t\t\t\t\t/* Set IPv6 only option, but don't abort on errors. */\n\t\t\t\t\tmg_cry_internal(\n\t\t\t\t\t    fc(phys_ctx),\n\t\t\t\t\t    \"cannot set socket option IPV6_V6ONLY=off (entry %i)\",\n\t\t\t\t\t    portsTotal);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (so.lsa.sa.sa_family == AF_INET6\n\t\t\t\t    && setsockopt(so.sock,\n\t\t\t\t                  IPPROTO_IPV6,\n\t\t\t\t                  IPV6_V6ONLY,\n\t\t\t\t                  (void *)&on,\n\t\t\t\t                  sizeof(on))\n\t\t\t\t           != 0) {\n\n\t\t\t\t\t/* Set IPv6 only option, but don't abort on errors. */\n\t\t\t\t\tmg_cry_internal(\n\t\t\t\t\t    fc(phys_ctx),\n\t\t\t\t\t    \"cannot set socket option IPV6_V6ONLY=on (entry %i)\",\n\t\t\t\t\t    portsTotal);\n\t\t\t\t}\n\t\t\t}\n#else\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", \"IPv6 not available\");\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tcontinue;\n#endif\n\t\t}\n\n\t\tif (so.lsa.sa.sa_family == AF_INET) {\n\n\t\t\tlen = sizeof(so.lsa.sin);\n\t\t\tif (bind(so.sock, &so.lsa.sa, len) != 0) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"cannot bind to %.*s: %d (%s)\",\n\t\t\t\t                (int)vec.len,\n\t\t\t\t                vec.ptr,\n\t\t\t\t                (int)ERRNO,\n\t\t\t\t                strerror(errno));\n\t\t\t\tclosesocket(so.sock);\n\t\t\t\tso.sock = INVALID_SOCKET;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#if defined(USE_IPV6)\n\t\telse if (so.lsa.sa.sa_family == AF_INET6) {\n\n\t\t\tlen = sizeof(so.lsa.sin6);\n\t\t\tif (bind(so.sock, &so.lsa.sa, len) != 0) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"cannot bind to IPv6 %.*s: %d (%s)\",\n\t\t\t\t                (int)vec.len,\n\t\t\t\t                vec.ptr,\n\t\t\t\t                (int)ERRNO,\n\t\t\t\t                strerror(errno));\n\t\t\t\tclosesocket(so.sock);\n\t\t\t\tso.sock = INVALID_SOCKET;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#endif\n\t\telse {\n\t\t\tmg_cry_internal(\n\t\t\t    fc(phys_ctx),\n\t\t\t    \"cannot bind: address family not supported (entry %i)\",\n\t\t\t    portsTotal);\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (listen(so.sock, SOMAXCONN) != 0) {\n\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"cannot listen to %.*s: %d (%s)\",\n\t\t\t                (int)vec.len,\n\t\t\t                vec.ptr,\n\t\t\t                (int)ERRNO,\n\t\t\t                strerror(errno));\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((getsockname(so.sock, &(usa.sa), &len) != 0)\n\t\t    || (usa.sa.sa_family != so.lsa.sa.sa_family)) {\n\n\t\t\tint err = (int)ERRNO;\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"call to getsockname failed %.*s: %d (%s)\",\n\t\t\t                (int)vec.len,\n\t\t\t                vec.ptr,\n\t\t\t                err,\n\t\t\t                strerror(errno));\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tcontinue;\n\t\t}\n\n/* Update lsa port in case of random free ports */\n#if defined(USE_IPV6)\n\t\tif (so.lsa.sa.sa_family == AF_INET6) {\n\t\t\tso.lsa.sin6.sin6_port = usa.sin6.sin6_port;\n\t\t} else\n#endif\n\t\t{\n\t\t\tso.lsa.sin.sin_port = usa.sin.sin_port;\n\t\t}\n\n\t\tif ((ptr = (struct socket *)\n\t\t         mg_realloc_ctx(phys_ctx->listening_sockets,\n\t\t                        (phys_ctx->num_listening_sockets + 1)\n\t\t                            * sizeof(phys_ctx->listening_sockets[0]),\n\t\t                        phys_ctx))\n\t\t    == NULL) {\n\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", \"Out of memory\");\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((pfd = (struct pollfd *)\n\t\t         mg_realloc_ctx(phys_ctx->listening_socket_fds,\n\t\t                        (phys_ctx->num_listening_sockets + 1)\n\t\t                            * sizeof(phys_ctx->listening_socket_fds[0]),\n\t\t                        phys_ctx))\n\t\t    == NULL) {\n\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", \"Out of memory\");\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tmg_free(ptr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_close_on_exec(so.sock, fc(phys_ctx));\n\t\tphys_ctx->listening_sockets = ptr;\n\t\tphys_ctx->listening_sockets[phys_ctx->num_listening_sockets] = so;\n\t\tphys_ctx->listening_socket_fds = pfd;\n\t\tphys_ctx->num_listening_sockets++;\n\t\tportsOk++;\n\t}\n\n\tif (portsOk != portsTotal) {\n\t\tclose_all_listening_sockets(phys_ctx);\n\t\tportsOk = 0;\n\t}\n\n\treturn portsOk;\n}\n\n\nstatic const char *\nheader_val(const struct mg_connection *conn, const char *header)\n{\n\tconst char *header_value;\n\n\tif ((header_value = mg_get_header(conn, header)) == NULL) {\n\t\treturn \"-\";\n\t} else {\n\t\treturn header_value;\n\t}\n}\n\n\n#if defined(MG_EXTERNAL_FUNCTION_log_access)\nstatic void log_access(const struct mg_connection *conn);\n#include \"external_log_access.inl\"\n#else\n\nstatic void\nlog_access(const struct mg_connection *conn)\n{\n\tconst struct mg_request_info *ri;\n\tstruct mg_file fi;\n\tchar date[64], src_addr[IP_ADDR_STR_LEN];\n\tstruct tm *tm;\n\n\tconst char *referer;\n\tconst char *user_agent;\n\n\tchar buf[4096];\n\n\tif (!conn || !conn->dom_ctx) {\n\t\treturn;\n\t}\n\n\tif (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {\n\t\tif (mg_fopen(conn,\n\t\t             conn->dom_ctx->config[ACCESS_LOG_FILE],\n\t\t             MG_FOPEN_MODE_APPEND,\n\t\t             &fi)\n\t\t    == 0) {\n\t\t\tfi.access.fp = NULL;\n\t\t}\n\t} else {\n\t\tfi.access.fp = NULL;\n\t}\n\n\t/* Log is written to a file and/or a callback. If both are not set,\n\t * executing the rest of the function is pointless. */\n\tif ((fi.access.fp == NULL)\n\t    && (conn->phys_ctx->callbacks.log_access == NULL)) {\n\t\treturn;\n\t}\n\n\ttm = localtime(&conn->conn_birth_time);\n\tif (tm != NULL) {\n\t\tstrftime(date, sizeof(date), \"%d/%b/%Y:%H:%M:%S %z\", tm);\n\t} else {\n\t\tmg_strlcpy(date, \"01/Jan/1970:00:00:00 +0000\", sizeof(date));\n\t\tdate[sizeof(date) - 1] = '\\0';\n\t}\n\n\tri = &conn->request_info;\n\n\tsockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);\n\treferer = header_val(conn, \"Referer\");\n\tuser_agent = header_val(conn, \"User-Agent\");\n\n\tmg_snprintf(conn,\n\t            NULL, /* Ignore truncation in access log */\n\t            buf,\n\t            sizeof(buf),\n\t            \"%s - %s [%s] \\\"%s %s%s%s HTTP/%s\\\" %d %\" INT64_FMT \" %s %s\",\n\t            src_addr,\n\t            (ri->remote_user == NULL) ? \"-\" : ri->remote_user,\n\t            date,\n\t            ri->request_method ? ri->request_method : \"-\",\n\t            ri->request_uri ? ri->request_uri : \"-\",\n\t            ri->query_string ? \"?\" : \"\",\n\t            ri->query_string ? ri->query_string : \"\",\n\t            ri->http_version,\n\t            conn->status_code,\n\t            conn->num_bytes_sent,\n\t            referer,\n\t            user_agent);\n\n\tif (conn->phys_ctx->callbacks.log_access) {\n\t\tconn->phys_ctx->callbacks.log_access(conn, buf);\n\t}\n\n\tif (fi.access.fp) {\n\t\tint ok = 1;\n\t\tflockfile(fi.access.fp);\n\t\tif (fprintf(fi.access.fp, \"%s\\n\", buf) < 1) {\n\t\t\tok = 0;\n\t\t}\n\t\tif (fflush(fi.access.fp) != 0) {\n\t\t\tok = 0;\n\t\t}\n\t\tfunlockfile(fi.access.fp);\n\t\tif (mg_fclose(&fi.access) != 0) {\n\t\t\tok = 0;\n\t\t}\n\t\tif (!ok) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Error writing log file %s\",\n\t\t\t                conn->dom_ctx->config[ACCESS_LOG_FILE]);\n\t\t}\n\t}\n}\n\n#endif /* Externally provided function */\n\n\n/* Verify given socket address against the ACL.\n * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.\n */\nstatic int\ncheck_acl(struct mg_context *phys_ctx, uint32_t remote_ip)\n{\n\tint allowed, flag;\n\tuint32_t net, mask;\n\tstruct vec vec;\n\n\tif (phys_ctx) {\n\t\tconst char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];\n\n\t\t/* If any ACL is set, deny by default */\n\t\tallowed = (list == NULL) ? '+' : '-';\n\n\t\twhile ((list = next_option(list, &vec, NULL)) != NULL) {\n\t\t\tflag = vec.ptr[0];\n\t\t\tif ((flag != '+' && flag != '-')\n\t\t\t    || (parse_net(&vec.ptr[1], &net, &mask) == 0)) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"%s: subnet must be [+|-]x.x.x.x[/x]\",\n\t\t\t\t                __func__);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (net == (remote_ip & mask)) {\n\t\t\t\tallowed = flag;\n\t\t\t}\n\t\t}\n\n\t\treturn allowed == '+';\n\t}\n\treturn -1;\n}\n\n\n#if !defined(_WIN32)\nstatic int\nset_uid_option(struct mg_context *phys_ctx)\n{\n\tint success = 0;\n\n\tif (phys_ctx) {\n\t\t/* We are currently running as curr_uid. */\n\t\tconst uid_t curr_uid = getuid();\n\t\t/* If set, we want to run as run_as_user. */\n\t\tconst char *run_as_user = phys_ctx->dd.config[RUN_AS_USER];\n\t\tconst struct passwd *to_pw = NULL;\n\n\t\tif (run_as_user != NULL && (to_pw = getpwnam(run_as_user)) == NULL) {\n\t\t\t/* run_as_user does not exist on the system. We can't proceed\n\t\t\t * further. */\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"%s: unknown user [%s]\",\n\t\t\t                __func__,\n\t\t\t                run_as_user);\n\t\t} else if (run_as_user == NULL || curr_uid == to_pw->pw_uid) {\n\t\t\t/* There was either no request to change user, or we're already\n\t\t\t * running as run_as_user. Nothing else to do.\n\t\t\t */\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\t/* Valid change request.  */\n\t\t\tif (setgid(to_pw->pw_gid) == -1) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"%s: setgid(%s): %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                run_as_user,\n\t\t\t\t                strerror(errno));\n\t\t\t} else if (setgroups(0, NULL) == -1) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"%s: setgroups(): %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                strerror(errno));\n\t\t\t} else if (setuid(to_pw->pw_uid) == -1) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"%s: setuid(%s): %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                run_as_user,\n\t\t\t\t                strerror(errno));\n\t\t\t} else {\n\t\t\t\tsuccess = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn success;\n}\n#endif /* !_WIN32 */\n\n\nstatic void\ntls_dtor(void *key)\n{\n\tstruct mg_workerTLS *tls = (struct mg_workerTLS *)key;\n\t/* key == pthread_getspecific(sTlsKey); */\n\n\tif (tls) {\n\t\tif (tls->is_master == 2) {\n\t\t\ttls->is_master = -3; /* Mark memory as dead */\n\t\t\tmg_free(tls);\n\t\t}\n\t}\n\tpthread_setspecific(sTlsKey, NULL);\n}\n\n\n#if !defined(NO_SSL)\n\nstatic int ssl_use_pem_file(struct mg_context *phys_ctx,\n                            struct mg_domain_context *dom_ctx,\n                            const char *pem,\n                            const char *chain);\nstatic const char *ssl_error(void);\n\n\nstatic int\nrefresh_trust(struct mg_connection *conn)\n{\n\tstatic int reload_lock = 0;\n\tstatic long int data_check = 0;\n\tvolatile int *p_reload_lock = (volatile int *)&reload_lock;\n\n\tstruct stat cert_buf;\n\tlong int t;\n\tconst char *pem;\n\tconst char *chain;\n\tint should_verify_peer;\n\n\tif ((pem = conn->dom_ctx->config[SSL_CERTIFICATE]) == NULL) {\n\t\t/* If peem is NULL and conn->phys_ctx->callbacks.init_ssl is not,\n\t\t * refresh_trust still can not work. */\n\t\treturn 0;\n\t}\n\tchain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];\n\tif (chain == NULL) {\n\t\t/* pem is not NULL here */\n\t\tchain = pem;\n\t}\n\tif (*chain == 0) {\n\t\tchain = NULL;\n\t}\n\n\tt = data_check;\n\tif (stat(pem, &cert_buf) != -1) {\n\t\tt = (long int)cert_buf.st_mtime;\n\t}\n\n\tif (data_check != t) {\n\t\tdata_check = t;\n\n\t\tshould_verify_peer = 0;\n\t\tif (conn->dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {\n\t\t\tif (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER], \"yes\")\n\t\t\t    == 0) {\n\t\t\t\tshould_verify_peer = 1;\n\t\t\t} else if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER],\n\t\t\t                         \"optional\")\n\t\t\t           == 0) {\n\t\t\t\tshould_verify_peer = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (should_verify_peer) {\n\t\t\tchar *ca_path = conn->dom_ctx->config[SSL_CA_PATH];\n\t\t\tchar *ca_file = conn->dom_ctx->config[SSL_CA_FILE];\n\t\t\tif (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,\n\t\t\t                                  ca_file,\n\t\t\t                                  ca_path)\n\t\t\t    != 1) {\n\t\t\t\tmg_cry_internal(\n\t\t\t\t    fc(conn->phys_ctx),\n\t\t\t\t    \"SSL_CTX_load_verify_locations error: %s \"\n\t\t\t\t    \"ssl_verify_peer requires setting \"\n\t\t\t\t    \"either ssl_ca_path or ssl_ca_file. Is any of them \"\n\t\t\t\t    \"present in \"\n\t\t\t\t    \"the .conf file?\",\n\t\t\t\t    ssl_error());\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (1 == mg_atomic_inc(p_reload_lock)) {\n\t\t\tif (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain)\n\t\t\t    == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*p_reload_lock = 0;\n\t\t}\n\t}\n\t/* lock while cert is reloading */\n\twhile (*p_reload_lock) {\n\t\tsleep(1);\n\t}\n\n\treturn 1;\n}\n\n#if defined(OPENSSL_API_1_1)\n#else\nstatic pthread_mutex_t *ssl_mutexes;\n#endif /* OPENSSL_API_1_1 */\n\nstatic int\nsslize(struct mg_connection *conn,\n       SSL_CTX *s,\n       int (*func)(SSL *),\n       volatile int *stop_server,\n       const struct mg_client_options *client_options)\n{\n\tint ret, err;\n\tint short_trust;\n\tunsigned i;\n\n\tif (!conn) {\n\t\treturn 0;\n\t}\n\n\tshort_trust =\n\t    (conn->dom_ctx->config[SSL_SHORT_TRUST] != NULL)\n\t    && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], \"yes\") == 0);\n\n\tif (short_trust) {\n\t\tint trust_ret = refresh_trust(conn);\n\t\tif (!trust_ret) {\n\t\t\treturn trust_ret;\n\t\t}\n\t}\n\n\tconn->ssl = SSL_new(s);\n\tif (conn->ssl == NULL) {\n\t\treturn 0;\n\t}\n\tSSL_set_app_data(conn->ssl, (char *)conn);\n\n\tret = SSL_set_fd(conn->ssl, conn->client.sock);\n\tif (ret != 1) {\n\t\terr = SSL_get_error(conn->ssl, ret);\n\t\tmg_cry_internal(conn, \"SSL error %i, destroying SSL context\", err);\n\t\tSSL_free(conn->ssl);\n\t\tconn->ssl = NULL;\n\t\tOPENSSL_REMOVE_THREAD_STATE();\n\t\treturn 0;\n\t}\n\n\tif (client_options) {\n\t\tif (client_options->host_name) {\n\t\t\tSSL_set_tlsext_host_name(conn->ssl, client_options->host_name);\n\t\t}\n\t}\n\n\t/* SSL functions may fail and require to be called again:\n\t * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html\n\t * Here \"func\" could be SSL_connect or SSL_accept. */\n\tfor (i = 16; i <= 1024; i *= 2) {\n\t\tret = func(conn->ssl);\n\t\tif (ret != 1) {\n\t\t\terr = SSL_get_error(conn->ssl, ret);\n\t\t\tif ((err == SSL_ERROR_WANT_CONNECT)\n\t\t\t    || (err == SSL_ERROR_WANT_ACCEPT)\n\t\t\t    || (err == SSL_ERROR_WANT_READ) || (err == SSL_ERROR_WANT_WRITE)\n\t\t\t    || (err == SSL_ERROR_WANT_X509_LOOKUP)) {\n\t\t\t\t/* Need to retry the function call \"later\".\n\t\t\t\t * See https://linux.die.net/man/3/ssl_get_error\n\t\t\t\t * This is typical for non-blocking sockets. */\n\t\t\t\tif (*stop_server) {\n\t\t\t\t\t/* Don't wait if the server is going to be stopped. */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmg_sleep(i);\n\n\t\t\t} else if (err == SSL_ERROR_SYSCALL) {\n\t\t\t\t/* This is an IO error. Look at errno. */\n\t\t\t\terr = errno;\n\t\t\t\tmg_cry_internal(conn, \"SSL syscall error %i\", err);\n\t\t\t\tbreak;\n\n\t\t\t} else {\n\t\t\t\t/* This is an SSL specific error, e.g. SSL_ERROR_SSL */\n\t\t\t\tmg_cry_internal(conn, \"sslize error: %s\", ssl_error());\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\t/* success */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret != 1) {\n\t\tSSL_free(conn->ssl);\n\t\tconn->ssl = NULL;\n\t\tOPENSSL_REMOVE_THREAD_STATE();\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\n/* Return OpenSSL error message (from CRYPTO lib) */\nstatic const char *\nssl_error(void)\n{\n\tunsigned long err;\n\terr = ERR_get_error();\n\treturn ((err == 0) ? \"\" : ERR_error_string(err, NULL));\n}\n\n\nstatic int\nhexdump2string(void *mem, int memlen, char *buf, int buflen)\n{\n\tint i;\n\tconst char hexdigit[] = \"0123456789abcdef\";\n\n\tif ((memlen <= 0) || (buflen <= 0)) {\n\t\treturn 0;\n\t}\n\tif (buflen < (3 * memlen)) {\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < memlen; i++) {\n\t\tif (i > 0) {\n\t\t\tbuf[3 * i - 1] = ' ';\n\t\t}\n\t\tbuf[3 * i] = hexdigit[(((uint8_t *)mem)[i] >> 4) & 0xF];\n\t\tbuf[3 * i + 1] = hexdigit[((uint8_t *)mem)[i] & 0xF];\n\t}\n\tbuf[3 * memlen - 1] = 0;\n\n\treturn 1;\n}\n\n\nstatic void\nssl_get_client_cert_info(struct mg_connection *conn)\n{\n\tX509 *cert = SSL_get_peer_certificate(conn->ssl);\n\tif (cert) {\n\t\tchar str_subject[1024];\n\t\tchar str_issuer[1024];\n\t\tchar str_finger[1024];\n\t\tunsigned char buf[256];\n\t\tchar *str_serial = NULL;\n\t\tunsigned int ulen;\n\t\tint ilen;\n\t\tunsigned char *tmp_buf;\n\t\tunsigned char *tmp_p;\n\n\t\t/* Handle to algorithm used for fingerprint */\n\t\tconst EVP_MD *digest = EVP_get_digestbyname(\"sha1\");\n\n\t\t/* Get Subject and issuer */\n\t\tX509_NAME *subj = X509_get_subject_name(cert);\n\t\tX509_NAME *iss = X509_get_issuer_name(cert);\n\n\t\t/* Get serial number */\n\t\tASN1_INTEGER *serial = X509_get_serialNumber(cert);\n\n\t\t/* Translate serial number to a hex string */\n\t\tBIGNUM *serial_bn = ASN1_INTEGER_to_BN(serial, NULL);\n\t\tstr_serial = BN_bn2hex(serial_bn);\n\t\tBN_free(serial_bn);\n\n\t\t/* Translate subject and issuer to a string */\n\t\t(void)X509_NAME_oneline(subj, str_subject, (int)sizeof(str_subject));\n\t\t(void)X509_NAME_oneline(iss, str_issuer, (int)sizeof(str_issuer));\n\n\t\t/* Calculate SHA1 fingerprint and store as a hex string */\n\t\tulen = 0;\n\n\t\t/* ASN1_digest is deprecated. Do the calculation manually,\n\t\t * using EVP_Digest. */\n\t\tilen = i2d_X509(cert, NULL);\n\t\ttmp_buf = (ilen > 0)\n\t\t              ? (unsigned char *)mg_malloc_ctx((unsigned)ilen + 1,\n\t\t                                               conn->phys_ctx)\n\t\t              : NULL;\n\t\tif (tmp_buf) {\n\t\t\ttmp_p = tmp_buf;\n\t\t\t(void)i2d_X509(cert, &tmp_p);\n\t\t\tif (!EVP_Digest(\n\t\t\t        tmp_buf, (unsigned)ilen, buf, &ulen, digest, NULL)) {\n\t\t\t\tulen = 0;\n\t\t\t}\n\t\t\tmg_free(tmp_buf);\n\t\t}\n\n\t\tif (!hexdump2string(\n\t\t        buf, (int)ulen, str_finger, (int)sizeof(str_finger))) {\n\t\t\t*str_finger = 0;\n\t\t}\n\n\t\tconn->request_info.client_cert = (struct mg_client_cert *)\n\t\t    mg_malloc_ctx(sizeof(struct mg_client_cert), conn->phys_ctx);\n\t\tif (conn->request_info.client_cert) {\n\t\t\tconn->request_info.client_cert->peer_cert = (void *)cert;\n\t\t\tconn->request_info.client_cert->subject =\n\t\t\t    mg_strdup_ctx(str_subject, conn->phys_ctx);\n\t\t\tconn->request_info.client_cert->issuer =\n\t\t\t    mg_strdup_ctx(str_issuer, conn->phys_ctx);\n\t\t\tconn->request_info.client_cert->serial =\n\t\t\t    mg_strdup_ctx(str_serial, conn->phys_ctx);\n\t\t\tconn->request_info.client_cert->finger =\n\t\t\t    mg_strdup_ctx(str_finger, conn->phys_ctx);\n\t\t} else {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s\",\n\t\t\t                \"Out of memory: Cannot allocate memory for client \"\n\t\t\t                \"certificate\");\n\t\t}\n\n\t\t/* Strings returned from bn_bn2hex must be freed using OPENSSL_free,\n\t\t * see https://linux.die.net/man/3/bn_bn2hex */\n\t\tOPENSSL_free(str_serial);\n\t}\n}\n\n\n#if defined(OPENSSL_API_1_1)\n#else\nstatic void\nssl_locking_callback(int mode, int mutex_num, const char *file, int line)\n{\n\t(void)line;\n\t(void)file;\n\n\tif (mode & 1) {\n\t\t/* 1 is CRYPTO_LOCK */\n\t\t(void)pthread_mutex_lock(&ssl_mutexes[mutex_num]);\n\t} else {\n\t\t(void)pthread_mutex_unlock(&ssl_mutexes[mutex_num]);\n\t}\n}\n#endif /* OPENSSL_API_1_1 */\n\n\n#if !defined(NO_SSL_DL)\nstatic void *\nload_dll(char *ebuf, size_t ebuf_len, const char *dll_name, struct ssl_func *sw)\n{\n\tunion {\n\t\tvoid *p;\n\t\tvoid (*fp)(void);\n\t} u;\n\tvoid *dll_handle;\n\tstruct ssl_func *fp;\n\tint ok;\n\tint truncated = 0;\n\n\tif ((dll_handle = dlopen(dll_name, RTLD_LAZY)) == NULL) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s: cannot load %s\",\n\t\t            __func__,\n\t\t            dll_name);\n\t\treturn NULL;\n\t}\n\n\tok = 1;\n\tfor (fp = sw; fp->name != NULL; fp++) {\n#if defined(_WIN32)\n\t\t/* GetProcAddress() returns pointer to function */\n\t\tu.fp = (void (*)(void))dlsym(dll_handle, fp->name);\n#else\n\t\t/* dlsym() on UNIX returns void *. ISO C forbids casts of data\n\t\t * pointers to function pointers. We need to use a union to make a\n\t\t * cast. */\n\t\tu.p = dlsym(dll_handle, fp->name);\n#endif /* _WIN32 */\n\t\tif (u.fp == NULL) {\n\t\t\tif (ok) {\n\t\t\t\tmg_snprintf(NULL,\n\t\t\t\t            &truncated,\n\t\t\t\t            ebuf,\n\t\t\t\t            ebuf_len,\n\t\t\t\t            \"%s: %s: cannot find %s\",\n\t\t\t\t            __func__,\n\t\t\t\t            dll_name,\n\t\t\t\t            fp->name);\n\t\t\t\tok = 0;\n\t\t\t} else {\n\t\t\t\tsize_t cur_len = strlen(ebuf);\n\t\t\t\tif (!truncated) {\n\t\t\t\t\tmg_snprintf(NULL,\n\t\t\t\t\t            &truncated,\n\t\t\t\t\t            ebuf + cur_len,\n\t\t\t\t\t            ebuf_len - cur_len - 3,\n\t\t\t\t\t            \", %s\",\n\t\t\t\t\t            fp->name);\n\t\t\t\t\tif (truncated) {\n\t\t\t\t\t\t/* If truncated, add \"...\" */\n\t\t\t\t\t\tstrcat(ebuf, \"...\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Debug:\n\t\t\t * printf(\"Missing function: %s\\n\", fp->name); */\n\t\t} else {\n\t\t\tfp->ptr = u.fp;\n\t\t}\n\t}\n\n\tif (!ok) {\n\t\t(void)dlclose(dll_handle);\n\t\treturn NULL;\n\t}\n\n\treturn dll_handle;\n}\n\n\nstatic void *ssllib_dll_handle;    /* Store the ssl library handle. */\nstatic void *cryptolib_dll_handle; /* Store the crypto library handle. */\n\n#endif /* NO_SSL_DL */\n\n\n#if defined(SSL_ALREADY_INITIALIZED)\nstatic int cryptolib_users = 1; /* Reference counter for crypto library. */\n#else\nstatic int cryptolib_users = 0; /* Reference counter for crypto library. */\n#endif\n\n\nstatic int\ninitialize_ssl(char *ebuf, size_t ebuf_len)\n{\n#if defined(OPENSSL_API_1_1)\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = 0;\n\t}\n\n#if !defined(NO_SSL_DL)\n\tif (!cryptolib_dll_handle) {\n\t\tcryptolib_dll_handle = load_dll(ebuf, ebuf_len, CRYPTO_LIB, crypto_sw);\n\t\tif (!cryptolib_dll_handle) {\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s: error loading library %s\",\n\t\t\t            __func__,\n\t\t\t            CRYPTO_LIB);\n\t\t\tDEBUG_TRACE(\"%s\", ebuf);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif /* NO_SSL_DL */\n\n\tif (mg_atomic_inc(&cryptolib_users) > 1) {\n\t\treturn 1;\n\t}\n\n#else /* not OPENSSL_API_1_1 */\n\tint i, num_locks;\n\tsize_t size;\n\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = 0;\n\t}\n\n#if !defined(NO_SSL_DL)\n\tif (!cryptolib_dll_handle) {\n\t\tcryptolib_dll_handle = load_dll(ebuf, ebuf_len, CRYPTO_LIB, crypto_sw);\n\t\tif (!cryptolib_dll_handle) {\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s: error loading library %s\",\n\t\t\t            __func__,\n\t\t\t            CRYPTO_LIB);\n\t\t\tDEBUG_TRACE(\"%s\", ebuf);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif /* NO_SSL_DL */\n\n\tif (mg_atomic_inc(&cryptolib_users) > 1) {\n\t\treturn 1;\n\t}\n\n\t/* Initialize locking callbacks, needed for thread safety.\n\t * http://www.openssl.org/support/faq.html#PROG1\n\t */\n\tnum_locks = CRYPTO_num_locks();\n\tif (num_locks < 0) {\n\t\tnum_locks = 0;\n\t}\n\tsize = sizeof(pthread_mutex_t) * ((size_t)(num_locks));\n\n\t/* allocate mutex array, if required */\n\tif (num_locks == 0) {\n\t\t/* No mutex array required */\n\t\tssl_mutexes = NULL;\n\t} else {\n\t\t/* Mutex array required - allocate it */\n\t\tssl_mutexes = (pthread_mutex_t *)mg_malloc(size);\n\n\t\t/* Check OOM */\n\t\tif (ssl_mutexes == NULL) {\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s: cannot allocate mutexes: %s\",\n\t\t\t            __func__,\n\t\t\t            ssl_error());\n\t\t\tDEBUG_TRACE(\"%s\", ebuf);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* initialize mutex array */\n\t\tfor (i = 0; i < num_locks; i++) {\n\t\t\tif (0 != pthread_mutex_init(&ssl_mutexes[i], &pthread_mutex_attr)) {\n\t\t\t\tmg_snprintf(NULL,\n\t\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t\t            ebuf,\n\t\t\t\t            ebuf_len,\n\t\t\t\t            \"%s: error initializing mutex %i of %i\",\n\t\t\t\t            __func__,\n\t\t\t\t            i,\n\t\t\t\t            num_locks);\n\t\t\t\tDEBUG_TRACE(\"%s\", ebuf);\n\t\t\t\tmg_free(ssl_mutexes);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tCRYPTO_set_locking_callback(&ssl_locking_callback);\n\tCRYPTO_set_id_callback(&mg_current_thread_id);\n#endif /* OPENSSL_API_1_1 */\n\n#if !defined(NO_SSL_DL)\n\tif (!ssllib_dll_handle) {\n\t\tssllib_dll_handle = load_dll(ebuf, ebuf_len, SSL_LIB, ssl_sw);\n\t\tif (!ssllib_dll_handle) {\n#if !defined(OPENSSL_API_1_1)\n\t\t\tmg_free(ssl_mutexes);\n#endif\n\t\t\tDEBUG_TRACE(\"%s\", ebuf);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif /* NO_SSL_DL */\n\n#if defined(OPENSSL_API_1_1)\n\t/* Initialize SSL library */\n\tOPENSSL_init_ssl(0, NULL);\n\tOPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS\n\t                     | OPENSSL_INIT_LOAD_CRYPTO_STRINGS,\n\t                 NULL);\n#else\n\t/* Initialize SSL library */\n\tSSL_library_init();\n\tSSL_load_error_strings();\n#endif\n\n\treturn 1;\n}\n\n\nstatic int\nssl_use_pem_file(struct mg_context *phys_ctx,\n                 struct mg_domain_context *dom_ctx,\n                 const char *pem,\n                 const char *chain)\n{\n\tif (SSL_CTX_use_certificate_file(dom_ctx->ssl_ctx, pem, 1) == 0) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"%s: cannot open certificate file %s: %s\",\n\t\t                __func__,\n\t\t                pem,\n\t\t                ssl_error());\n\t\treturn 0;\n\t}\n\n\t/* could use SSL_CTX_set_default_passwd_cb_userdata */\n\tif (SSL_CTX_use_PrivateKey_file(dom_ctx->ssl_ctx, pem, 1) == 0) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"%s: cannot open private key file %s: %s\",\n\t\t                __func__,\n\t\t                pem,\n\t\t                ssl_error());\n\t\treturn 0;\n\t}\n\n\tif (SSL_CTX_check_private_key(dom_ctx->ssl_ctx) == 0) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"%s: certificate and private key do not match: %s\",\n\t\t                __func__,\n\t\t                pem);\n\t\treturn 0;\n\t}\n\n\t/* In contrast to OpenSSL, wolfSSL does not support certificate\n\t * chain files that contain private keys and certificates in\n\t * SSL_CTX_use_certificate_chain_file.\n\t * The CivetWeb-Server used pem-Files that contained both information.\n\t * In order to make wolfSSL work, it is split in two files.\n\t * One file that contains key and certificate used by the server and\n\t * an optional chain file for the ssl stack.\n\t */\n\tif (chain) {\n\t\tif (SSL_CTX_use_certificate_chain_file(dom_ctx->ssl_ctx, chain) == 0) {\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"%s: cannot use certificate chain file %s: %s\",\n\t\t\t                __func__,\n\t\t\t                pem,\n\t\t\t                ssl_error());\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n\n#if defined(OPENSSL_API_1_1)\nstatic unsigned long\nssl_get_protocol(int version_id)\n{\n\tlong unsigned ret = (long unsigned)SSL_OP_ALL;\n\tif (version_id > 0)\n\t\tret |= SSL_OP_NO_SSLv2;\n\tif (version_id > 1)\n\t\tret |= SSL_OP_NO_SSLv3;\n\tif (version_id > 2)\n\t\tret |= SSL_OP_NO_TLSv1;\n\tif (version_id > 3)\n\t\tret |= SSL_OP_NO_TLSv1_1;\n\treturn ret;\n}\n#else\nstatic long\nssl_get_protocol(int version_id)\n{\n\tlong ret = (long)SSL_OP_ALL;\n\tif (version_id > 0)\n\t\tret |= SSL_OP_NO_SSLv2;\n\tif (version_id > 1)\n\t\tret |= SSL_OP_NO_SSLv3;\n\tif (version_id > 2)\n\t\tret |= SSL_OP_NO_TLSv1;\n\tif (version_id > 3)\n\t\tret |= SSL_OP_NO_TLSv1_1;\n\treturn ret;\n}\n#endif /* OPENSSL_API_1_1 */\n\n\n/* SSL callback documentation:\n * https://www.openssl.org/docs/man1.1.0/ssl/SSL_set_info_callback.html\n * https://wiki.openssl.org/index.php/Manual:SSL_CTX_set_info_callback(3)\n * https://linux.die.net/man/3/ssl_set_info_callback */\n/* Note: There is no \"const\" for the first argument in the documentation\n * examples, however some (maybe most, but not all) headers of OpenSSL versions\n * / OpenSSL compatibility layers have it. Having a different definition will\n * cause a warning in C and an error in C++. Use \"const SSL *\", while\n * automatical conversion from \"SSL *\" works for all compilers, but not other\n * way around */\nstatic void\nssl_info_callback(const SSL *ssl, int what, int ret)\n{\n\t(void)ret;\n\n\tif (what & SSL_CB_HANDSHAKE_START) {\n\t\tSSL_get_app_data(ssl);\n\t}\n\tif (what & SSL_CB_HANDSHAKE_DONE) {\n\t\t/* TODO: check for openSSL 1.1 */\n\t\t//#define SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS 0x0001\n\t\t// ssl->s3->flags |= SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS;\n\t}\n}\n\n\nstatic int\nssl_servername_callback(SSL *ssl, int *ad, void *arg)\n{\n\tstruct mg_context *ctx = (struct mg_context *)arg;\n\tstruct mg_domain_context *dom =\n\t    (struct mg_domain_context *)ctx ? &(ctx->dd) : NULL;\n\n#if defined(GCC_DIAGNOSTIC)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wcast-align\"\n#endif /* defined(GCC_DIAGNOSTIC) */\n\n\t/* We used an aligned pointer in SSL_set_app_data */\n\tstruct mg_connection *conn = (struct mg_connection *)SSL_get_app_data(ssl);\n\n#if defined(GCC_DIAGNOSTIC)\n#pragma GCC diagnostic pop\n#endif /* defined(GCC_DIAGNOSTIC) */\n\n\tconst char *servername = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);\n\n\t(void)ad;\n\n\tif ((ctx == NULL) || (conn->phys_ctx == ctx)) {\n\t\tDEBUG_TRACE(\"%s\", \"internal error - assertion failed\");\n\t\treturn SSL_TLSEXT_ERR_NOACK;\n\t}\n\n\t/* Old clients (Win XP) will not support SNI. Then, there\n\t * is no server name available in the request - we can\n\t * only work with the default certificate.\n\t * Multiple HTTPS hosts on one IP+port are only possible\n\t * with a certificate containing all alternative names.\n\t */\n\tif ((servername == NULL) || (*servername == 0)) {\n\t\tDEBUG_TRACE(\"%s\", \"SSL connection not supporting SNI\");\n\t\tconn->dom_ctx = &(ctx->dd);\n\t\tSSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);\n\t\treturn SSL_TLSEXT_ERR_NOACK;\n\t}\n\n\tDEBUG_TRACE(\"TLS connection to host %s\", servername);\n\n\twhile (dom) {\n\t\tif (!mg_strcasecmp(servername, dom->config[AUTHENTICATION_DOMAIN])) {\n\n\t\t\t/* Found matching domain */\n\t\t\tDEBUG_TRACE(\"TLS domain %s found\",\n\t\t\t            dom->config[AUTHENTICATION_DOMAIN]);\n\t\t\tSSL_set_SSL_CTX(ssl, dom->ssl_ctx);\n\t\t\tconn->dom_ctx = dom;\n\t\t\treturn SSL_TLSEXT_ERR_OK;\n\t\t}\n\t\tdom = dom->next;\n\t}\n\n\t/* Default domain */\n\tDEBUG_TRACE(\"TLS default domain %s used\",\n\t            ctx->dd.config[AUTHENTICATION_DOMAIN]);\n\tconn->dom_ctx = &(ctx->dd);\n\tSSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);\n\treturn SSL_TLSEXT_ERR_OK;\n}\n\n\n/* Setup SSL CTX as required by CivetWeb */\nstatic int\ninit_ssl_ctx_impl(struct mg_context *phys_ctx,\n                  struct mg_domain_context *dom_ctx,\n                  const char *pem,\n                  const char *chain)\n{\n\tint callback_ret;\n\tint should_verify_peer;\n\tint peer_certificate_optional;\n\tconst char *ca_path;\n\tconst char *ca_file;\n\tint use_default_verify_paths;\n\tint verify_depth;\n\tstruct timespec now_mt;\n\tmd5_byte_t ssl_context_id[16];\n\tmd5_state_t md5state;\n\tint protocol_ver;\n\n#if defined(OPENSSL_API_1_1)\n\tif ((dom_ctx->ssl_ctx = SSL_CTX_new(TLS_server_method())) == NULL) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"SSL_CTX_new (server) error: %s\",\n\t\t                ssl_error());\n\t\treturn 0;\n\t}\n#else\n\tif ((dom_ctx->ssl_ctx = SSL_CTX_new(SSLv23_server_method())) == NULL) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"SSL_CTX_new (server) error: %s\",\n\t\t                ssl_error());\n\t\treturn 0;\n\t}\n#endif /* OPENSSL_API_1_1 */\n\n\tSSL_CTX_clear_options(dom_ctx->ssl_ctx,\n\t                      SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1\n\t                          | SSL_OP_NO_TLSv1_1);\n\tprotocol_ver = atoi(dom_ctx->config[SSL_PROTOCOL_VERSION]);\n\tSSL_CTX_set_options(dom_ctx->ssl_ctx, ssl_get_protocol(protocol_ver));\n\tSSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_SINGLE_DH_USE);\n\tSSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);\n\tSSL_CTX_set_options(dom_ctx->ssl_ctx,\n\t                    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);\n\tSSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_NO_COMPRESSION);\n#if !defined(NO_SSL_DL)\n\tSSL_CTX_set_ecdh_auto(dom_ctx->ssl_ctx, 1);\n#endif /* NO_SSL_DL */\n\n\t/* In SSL documentation examples callback defined without const specifier\n\t * 'void (*)(SSL *, int, int)'   See:\n\t * https://www.openssl.org/docs/man1.0.2/ssl/ssl.html\n\t * https://www.openssl.org/docs/man1.1.0/ssl/ssl.html\n\t * But in the source code const SSL is used:\n\t * 'void (*)(const SSL *, int, int)' See:\n\t * https://github.com/openssl/openssl/blob/1d97c8435171a7af575f73c526d79e1ef0ee5960/ssl/ssl.h#L1173\n\t * Problem about wrong documentation described, but not resolved:\n\t * https://bugs.launchpad.net/ubuntu/+source/openssl/+bug/1147526\n\t * Wrong const cast ignored on C or can be suppressed by compiler flags.\n\t * But when compiled with modern C++ compiler, correct const should be\n\t * provided\n\t */\n\tSSL_CTX_set_info_callback(dom_ctx->ssl_ctx, ssl_info_callback);\n\n\tSSL_CTX_set_tlsext_servername_callback(dom_ctx->ssl_ctx,\n\t                                       ssl_servername_callback);\n\tSSL_CTX_set_tlsext_servername_arg(dom_ctx->ssl_ctx, phys_ctx);\n\n\t/* If a callback has been specified, call it. */\n\tcallback_ret = (phys_ctx->callbacks.init_ssl == NULL)\n\t                   ? 0\n\t                   : (phys_ctx->callbacks.init_ssl(dom_ctx->ssl_ctx,\n\t                                                   phys_ctx->user_data));\n\n\t/* If callback returns 0, civetweb sets up the SSL certificate.\n\t * If it returns 1, civetweb assumes the calback already did this.\n\t * If it returns -1, initializing ssl fails. */\n\tif (callback_ret < 0) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"SSL callback returned error: %i\",\n\t\t                callback_ret);\n\t\treturn 0;\n\t}\n\tif (callback_ret > 0) {\n\t\t/* Callback did everything. */\n\t\treturn 1;\n\t}\n\n\t/* Use some combination of start time, domain and port as a SSL\n\t * context ID. This should be unique on the current machine. */\n\tmd5_init(&md5state);\n\tclock_gettime(CLOCK_MONOTONIC, &now_mt);\n\tmd5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));\n\tmd5_append(&md5state,\n\t           (const md5_byte_t *)phys_ctx->dd.config[LISTENING_PORTS],\n\t           strlen(phys_ctx->dd.config[LISTENING_PORTS]));\n\tmd5_append(&md5state,\n\t           (const md5_byte_t *)dom_ctx->config[AUTHENTICATION_DOMAIN],\n\t           strlen(dom_ctx->config[AUTHENTICATION_DOMAIN]));\n\tmd5_append(&md5state, (const md5_byte_t *)phys_ctx, sizeof(*phys_ctx));\n\tmd5_append(&md5state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));\n\tmd5_finish(&md5state, ssl_context_id);\n\n\tSSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,\n\t                               (unsigned char *)ssl_context_id,\n\t                               sizeof(ssl_context_id));\n\n\tif (pem != NULL) {\n\t\tif (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Should we support client certificates? */\n\t/* Default is \"no\". */\n\tshould_verify_peer = 0;\n\tpeer_certificate_optional = 0;\n\tif (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {\n\t\tif (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], \"yes\") == 0) {\n\t\t\t/* Yes, they are mandatory */\n\t\t\tshould_verify_peer = 1;\n\t\t\tpeer_certificate_optional = 0;\n\t\t} else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],\n\t\t                         \"optional\")\n\t\t           == 0) {\n\t\t\t/* Yes, they are optional */\n\t\t\tshould_verify_peer = 1;\n\t\t\tpeer_certificate_optional = 1;\n\t\t}\n\t}\n\n\tuse_default_verify_paths =\n\t    (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL)\n\t    && (mg_strcasecmp(dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS], \"yes\")\n\t        == 0);\n\n\tif (should_verify_peer) {\n\t\tca_path = dom_ctx->config[SSL_CA_PATH];\n\t\tca_file = dom_ctx->config[SSL_CA_FILE];\n\t\tif (SSL_CTX_load_verify_locations(dom_ctx->ssl_ctx, ca_file, ca_path)\n\t\t    != 1) {\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"SSL_CTX_load_verify_locations error: %s \"\n\t\t\t                \"ssl_verify_peer requires setting \"\n\t\t\t                \"either ssl_ca_path or ssl_ca_file. \"\n\t\t\t                \"Is any of them present in the \"\n\t\t\t                \".conf file?\",\n\t\t\t                ssl_error());\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (peer_certificate_optional) {\n\t\t\tSSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);\n\t\t} else {\n\t\t\tSSL_CTX_set_verify(dom_ctx->ssl_ctx,\n\t\t\t                   SSL_VERIFY_PEER\n\t\t\t                       | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,\n\t\t\t                   NULL);\n\t\t}\n\n\t\tif (use_default_verify_paths\n\t\t    && (SSL_CTX_set_default_verify_paths(dom_ctx->ssl_ctx) != 1)) {\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"SSL_CTX_set_default_verify_paths error: %s\",\n\t\t\t                ssl_error());\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (dom_ctx->config[SSL_VERIFY_DEPTH]) {\n\t\t\tverify_depth = atoi(dom_ctx->config[SSL_VERIFY_DEPTH]);\n\t\t\tSSL_CTX_set_verify_depth(dom_ctx->ssl_ctx, verify_depth);\n\t\t}\n\t}\n\n\tif (dom_ctx->config[SSL_CIPHER_LIST] != NULL) {\n\t\tif (SSL_CTX_set_cipher_list(dom_ctx->ssl_ctx,\n\t\t                            dom_ctx->config[SSL_CIPHER_LIST])\n\t\t    != 1) {\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"SSL_CTX_set_cipher_list error: %s\",\n\t\t\t                ssl_error());\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n\n/* Check if SSL is required.\n * If so, dynamically load SSL library\n * and set up ctx->ssl_ctx pointer. */\nstatic int\ninit_ssl_ctx(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx)\n{\n\tvoid *ssl_ctx = 0;\n\tint callback_ret;\n\tconst char *pem;\n\tconst char *chain;\n\tchar ebuf[128];\n\n\tif (!phys_ctx) {\n\t\treturn 0;\n\t}\n\n\tif (!dom_ctx) {\n\t\tdom_ctx = &(phys_ctx->dd);\n\t}\n\n\tif (!is_ssl_port_used(dom_ctx->config[LISTENING_PORTS])) {\n\t\t/* No SSL port is set. No need to setup SSL. */\n\t\treturn 1;\n\t}\n\n\t/* Check for external SSL_CTX */\n\tcallback_ret =\n\t    (phys_ctx->callbacks.external_ssl_ctx == NULL)\n\t        ? 0\n\t        : (phys_ctx->callbacks.external_ssl_ctx(&ssl_ctx,\n\t                                                phys_ctx->user_data));\n\n\tif (callback_ret < 0) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"external_ssl_ctx callback returned error: %i\",\n\t\t                callback_ret);\n\t\treturn 0;\n\t} else if (callback_ret > 0) {\n\t\tdom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;\n\t\tif (!initialize_ssl(ebuf, sizeof(ebuf))) {\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", ebuf);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\t/* else: external_ssl_ctx does not exist or returns 0,\n\t * CivetWeb should continue initializing SSL */\n\n\t/* If PEM file is not specified and the init_ssl callback\n\t * is not specified, setup will fail. */\n\tif (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL)\n\t    && (phys_ctx->callbacks.init_ssl == NULL)) {\n\t\t/* No certificate and no callback:\n\t\t * Essential data to set up TLS is missing.\n\t\t */\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"Initializing SSL failed: -%s is not set\",\n\t\t                config_options[SSL_CERTIFICATE].name);\n\t\treturn 0;\n\t}\n\n\tchain = dom_ctx->config[SSL_CERTIFICATE_CHAIN];\n\tif (chain == NULL) {\n\t\tchain = pem;\n\t}\n\tif ((chain != NULL) && (*chain == 0)) {\n\t\tchain = NULL;\n\t}\n\n\tif (!initialize_ssl(ebuf, sizeof(ebuf))) {\n\t\tmg_cry_internal(fc(phys_ctx), \"%s\", ebuf);\n\t\treturn 0;\n\t}\n\n\treturn init_ssl_ctx_impl(phys_ctx, dom_ctx, pem, chain);\n}\n\n\nstatic void\nuninitialize_ssl(void)\n{\n#if defined(OPENSSL_API_1_1)\n\n\tif (mg_atomic_dec(&cryptolib_users) == 0) {\n\n\t\t/* Shutdown according to\n\t\t * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup\n\t\t * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl\n\t\t */\n\t\tCONF_modules_unload(1);\n#else\n\tint i;\n\n\tif (mg_atomic_dec(&cryptolib_users) == 0) {\n\n\t\t/* Shutdown according to\n\t\t * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup\n\t\t * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl\n\t\t */\n\t\tCRYPTO_set_locking_callback(NULL);\n\t\tCRYPTO_set_id_callback(NULL);\n\t\tENGINE_cleanup();\n\t\tCONF_modules_unload(1);\n\t\tERR_free_strings();\n\t\tEVP_cleanup();\n\t\tCRYPTO_cleanup_all_ex_data();\n\t\tOPENSSL_REMOVE_THREAD_STATE();\n\n\t\tfor (i = 0; i < CRYPTO_num_locks(); i++) {\n\t\t\tpthread_mutex_destroy(&ssl_mutexes[i]);\n\t\t}\n\t\tmg_free(ssl_mutexes);\n\t\tssl_mutexes = NULL;\n#endif /* OPENSSL_API_1_1 */\n\t}\n}\n#endif /* !NO_SSL */\n\n\nstatic int\nset_gpass_option(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx)\n{\n\tif (phys_ctx) {\n\t\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\t\tconst char *path;\n\t\tif (!dom_ctx) {\n\t\t\tdom_ctx = &(phys_ctx->dd);\n\t\t}\n\t\tpath = dom_ctx->config[GLOBAL_PASSWORDS_FILE];\n\t\tif ((path != NULL) && !mg_stat(fc(phys_ctx), path, &file.stat)) {\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"Cannot open %s: %s\",\n\t\t\t                path,\n\t\t\t                strerror(ERRNO));\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nstatic int\nset_acl_option(struct mg_context *phys_ctx)\n{\n\treturn check_acl(phys_ctx, (uint32_t)0x7f000001UL) != -1;\n}\n\n\nstatic void\nreset_per_request_attributes(struct mg_connection *conn)\n{\n\tif (!conn) {\n\t\treturn;\n\t}\n\tconn->connection_type =\n\t    CONNECTION_TYPE_INVALID; /* Not yet a valid request/response */\n\n\tconn->num_bytes_sent = conn->consumed_content = 0;\n\n\tconn->path_info = NULL;\n\tconn->status_code = -1;\n\tconn->content_len = -1;\n\tconn->is_chunked = 0;\n\tconn->must_close = 0;\n\tconn->request_len = 0;\n\tconn->throttle = 0;\n\tconn->data_len = 0;\n\tconn->chunk_remainder = 0;\n\tconn->accept_gzip = 0;\n\n\tconn->response_info.content_length = conn->request_info.content_length = -1;\n\tconn->response_info.http_version = conn->request_info.http_version = NULL;\n\tconn->response_info.num_headers = conn->request_info.num_headers = 0;\n\tconn->response_info.status_text = NULL;\n\tconn->response_info.status_code = 0;\n\n\tconn->request_info.remote_user = NULL;\n\tconn->request_info.request_method = NULL;\n\tconn->request_info.request_uri = NULL;\n\tconn->request_info.local_uri = NULL;\n\n#if defined(MG_LEGACY_INTERFACE)\n\t/* Legacy before split into local_uri and request_uri */\n\tconn->request_info.uri = NULL;\n#endif\n}\n\n\n#if 0\n/* Note: set_sock_timeout is not required for non-blocking sockets.\n * Leave this function here (commented out) for reference until\n * CivetWeb 1.9 is tested, and the tests confirme this function is\n * no longer required.\n*/\nstatic int\nset_sock_timeout(SOCKET sock, int milliseconds)\n{\n        int r0 = 0, r1, r2;\n\n#if defined(_WIN32)\n        /* Windows specific */\n\n        DWORD tv = (DWORD)milliseconds;\n\n#else\n        /* Linux, ... (not Windows) */\n\n        struct timeval tv;\n\n/* TCP_USER_TIMEOUT/RFC5482 (http://tools.ietf.org/html/rfc5482):\n * max. time waiting for the acknowledged of TCP data before the connection\n * will be forcefully closed and ETIMEDOUT is returned to the application.\n * If this option is not set, the default timeout of 20-30 minutes is used.\n*/\n/* #define TCP_USER_TIMEOUT (18) */\n\n#if defined(TCP_USER_TIMEOUT)\n        unsigned int uto = (unsigned int)milliseconds;\n        r0 = setsockopt(sock, 6, TCP_USER_TIMEOUT, (const void *)&uto, sizeof(uto));\n#endif\n\n        memset(&tv, 0, sizeof(tv));\n        tv.tv_sec = milliseconds / 1000;\n        tv.tv_usec = (milliseconds * 1000) % 1000000;\n\n#endif /* _WIN32 */\n\n        r1 = setsockopt(\n            sock, SOL_SOCKET, SO_RCVTIMEO, (SOCK_OPT_TYPE)&tv, sizeof(tv));\n        r2 = setsockopt(\n            sock, SOL_SOCKET, SO_SNDTIMEO, (SOCK_OPT_TYPE)&tv, sizeof(tv));\n\n        return r0 || r1 || r2;\n}\n#endif\n\n\nstatic int\nset_tcp_nodelay(SOCKET sock, int nodelay_on)\n{\n\tif (setsockopt(sock,\n\t               IPPROTO_TCP,\n\t               TCP_NODELAY,\n\t               (SOCK_OPT_TYPE)&nodelay_on,\n\t               sizeof(nodelay_on))\n\t    != 0) {\n\t\t/* Error */\n\t\treturn 1;\n\t}\n\t/* OK */\n\treturn 0;\n}\n\n\nstatic void\nclose_socket_gracefully(struct mg_connection *conn)\n{\n#if defined(_WIN32)\n\tchar buf[MG_BUF_LEN];\n\tint n;\n#endif\n\tstruct linger linger;\n\tint error_code = 0;\n\tint linger_timeout = -2;\n\tsocklen_t opt_len = sizeof(error_code);\n\n\tif (!conn) {\n\t\treturn;\n\t}\n\n\t/* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:\n\t * \"Note that enabling a nonzero timeout on a nonblocking socket\n\t * is not recommended.\", so set it to blocking now */\n\tset_blocking_mode(conn->client.sock);\n\n\t/* Send FIN to the client */\n\tshutdown(conn->client.sock, SHUTDOWN_WR);\n\n\n#if defined(_WIN32)\n\t/* Read and discard pending incoming data. If we do not do that and\n\t * close\n\t * the socket, the data in the send buffer may be discarded. This\n\t * behaviour is seen on Windows, when client keeps sending data\n\t * when server decides to close the connection; then when client\n\t * does recv() it gets no data back. */\n\tdo {\n\t\tn = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);\n\t} while (n > 0);\n#endif\n\n\tif (conn->dom_ctx->config[LINGER_TIMEOUT]) {\n\t\tlinger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);\n\t}\n\n\t/* Set linger option according to configuration */\n\tif (linger_timeout >= 0) {\n\t\t/* Set linger option to avoid socket hanging out after close. This\n\t\t * prevent ephemeral port exhaust problem under high QPS. */\n\t\tlinger.l_onoff = 1;\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n#pragma warning(disable : 4244)\n#endif\n#if defined(GCC_DIAGNOSTIC)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\n#endif\n\t\t/* Data type of linger structure elements may differ,\n\t\t * so we don't know what cast we need here.\n\t\t * Disable type conversion warnings. */\n\n\t\tlinger.l_linger = (linger_timeout + 999) / 1000;\n\n#if defined(GCC_DIAGNOSTIC)\n#pragma GCC diagnostic pop\n#endif\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n\t} else {\n\t\tlinger.l_onoff = 0;\n\t\tlinger.l_linger = 0;\n\t}\n\n\tif (linger_timeout < -1) {\n\t\t/* Default: don't configure any linger */\n\t} else if (getsockopt(conn->client.sock,\n\t                      SOL_SOCKET,\n\t                      SO_ERROR,\n#if defined(_WIN32) /* WinSock uses different data type here */\n\t                      (char *)&error_code,\n#else\n\t                      &error_code,\n#endif\n\t                      &opt_len)\n\t           != 0) {\n\t\t/* Cannot determine if socket is already closed. This should\n\t\t * not occur and never did in a test. Log an error message\n\t\t * and continue. */\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s\",\n\t\t                __func__,\n\t\t                strerror(ERRNO));\n\t} else if (error_code == ECONNRESET) {\n\t\t/* Socket already closed by client/peer, close socket without linger\n\t\t */\n\t} else {\n\n\t\t/* Set linger timeout */\n\t\tif (setsockopt(conn->client.sock,\n\t\t               SOL_SOCKET,\n\t\t               SO_LINGER,\n\t\t               (char *)&linger,\n\t\t               sizeof(linger))\n\t\t    != 0) {\n\t\t\tmg_cry_internal(\n\t\t\t    conn,\n\t\t\t    \"%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s\",\n\t\t\t    __func__,\n\t\t\t    linger.l_onoff,\n\t\t\t    linger.l_linger,\n\t\t\t    strerror(ERRNO));\n\t\t}\n\t}\n\n\t/* Now we know that our FIN is ACK-ed, safe to close */\n\tclosesocket(conn->client.sock);\n\tconn->client.sock = INVALID_SOCKET;\n}\n\n\nstatic void\nclose_connection(struct mg_connection *conn)\n{\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 6; /* to close */\n#endif\n\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\tif (conn->lua_websocket_state) {\n\t\tlua_websocket_close(conn, conn->lua_websocket_state);\n\t\tconn->lua_websocket_state = NULL;\n\t}\n#endif\n\n\tmg_lock_connection(conn);\n\n\t/* Set close flag, so keep-alive loops will stop */\n\tconn->must_close = 1;\n\n\t/* call the connection_close callback if assigned */\n\tif (conn->phys_ctx->callbacks.connection_close != NULL) {\n\t\tif (conn->phys_ctx->context_type == CONTEXT_SERVER) {\n\t\t\tconn->phys_ctx->callbacks.connection_close(conn);\n\t\t}\n\t}\n\n\t/* Reset user data, after close callback is called.\n\t * Do not reuse it. If the user needs a destructor,\n\t * it must be done in the connection_close callback. */\n\tmg_set_user_connection_data(conn, NULL);\n\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 7; /* closing */\n#endif\n\n#if !defined(NO_SSL)\n\tif (conn->ssl != NULL) {\n\t\t/* Run SSL_shutdown twice to ensure completely close SSL connection\n\t\t */\n\t\tSSL_shutdown(conn->ssl);\n\t\tSSL_free(conn->ssl);\n\t\tOPENSSL_REMOVE_THREAD_STATE();\n\t\tconn->ssl = NULL;\n\t}\n#endif\n\tif (conn->client.sock != INVALID_SOCKET) {\n\t\tclose_socket_gracefully(conn);\n\t\tconn->client.sock = INVALID_SOCKET;\n\t}\n\n\tif (conn->host) {\n\t\tmg_free((void *)conn->host);\n\t\tconn->host = NULL;\n\t}\n\n\tmg_unlock_connection(conn);\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 8; /* closed */\n#endif\n}\n\n\nvoid\nmg_close_connection(struct mg_connection *conn)\n{\n#if defined(USE_WEBSOCKET)\n\tstruct mg_context *client_ctx = NULL;\n#endif /* defined(USE_WEBSOCKET) */\n\n\tif ((conn == NULL) || (conn->phys_ctx == NULL)) {\n\t\treturn;\n\t}\n\n#if defined(USE_WEBSOCKET)\n\tif (conn->phys_ctx->context_type == CONTEXT_SERVER) {\n\t\tif (conn->in_websocket_handling) {\n\t\t\t/* Set close flag, so the server thread can exit. */\n\t\t\tconn->must_close = 1;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (conn->phys_ctx->context_type == CONTEXT_WS_CLIENT) {\n\n\t\tunsigned int i;\n\n\t\t/* ws/wss client */\n\t\tclient_ctx = conn->phys_ctx;\n\n\t\t/* client context: loops must end */\n\t\tclient_ctx->stop_flag = 1;\n\t\tconn->must_close = 1;\n\n\t\t/* We need to get the client thread out of the select/recv call\n\t\t * here. */\n\t\t/* Since we use a sleep quantum of some seconds to check for recv\n\t\t * timeouts, we will just wait a few seconds in mg_join_thread. */\n\n\t\t/* join worker thread */\n\t\tfor (i = 0; i < client_ctx->cfg_worker_threads; i++) {\n\t\t\tif (client_ctx->worker_threadids[i] != 0) {\n\t\t\t\tmg_join_thread(client_ctx->worker_threadids[i]);\n\t\t\t}\n\t\t}\n\t}\n#endif /* defined(USE_WEBSOCKET) */\n\n\tclose_connection(conn);\n\n#if !defined(NO_SSL)\n\tif (conn->client_ssl_ctx != NULL) {\n\t\tSSL_CTX_free((SSL_CTX *)conn->client_ssl_ctx);\n\t}\n#endif\n\n#if defined(USE_WEBSOCKET)\n\tif (client_ctx != NULL) {\n\t\t/* free context */\n\t\tmg_free(client_ctx->worker_threadids);\n\t\tmg_free(client_ctx);\n\t\t(void)pthread_mutex_destroy(&conn->mutex);\n\t\tmg_free(conn);\n\t} else if (conn->phys_ctx->context_type == CONTEXT_HTTP_CLIENT) {\n\t\tmg_free(conn);\n\t}\n#else\n\tif (conn->phys_ctx->context_type == CONTEXT_HTTP_CLIENT) { /* Client */\n\t\tmg_free(conn);\n\t}\n#endif /* defined(USE_WEBSOCKET) */\n}\n\n\n/* Only for memory statistics */\nstatic struct mg_context common_client_context;\n\n\nstatic struct mg_connection *\nmg_connect_client_impl(const struct mg_client_options *client_options,\n                       int use_ssl,\n                       char *ebuf,\n                       size_t ebuf_len)\n{\n\tstruct mg_connection *conn = NULL;\n\tSOCKET sock;\n\tunion usa sa;\n\tstruct sockaddr *psa;\n\tsocklen_t len;\n\n\tunsigned max_req_size =\n\t    (unsigned)atoi(config_options[MAX_REQUEST_SIZE].default_value);\n\n\t/* Size of structures, aligned to 8 bytes */\n\tsize_t conn_size = ((sizeof(struct mg_connection) + 7) >> 3) << 3;\n\tsize_t ctx_size = ((sizeof(struct mg_context) + 7) >> 3) << 3;\n\n\tconn = (struct mg_connection *)mg_calloc_ctx(\n\t    1, conn_size + ctx_size + max_req_size, &common_client_context);\n\n\tif (conn == NULL) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"calloc(): %s\",\n\t\t            strerror(ERRNO));\n\t\treturn NULL;\n\t}\n\n#if defined(GCC_DIAGNOSTIC)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wcast-align\"\n#endif /* defined(GCC_DIAGNOSTIC) */\n\t/* conn_size is aligned to 8 bytes */\n\n\tconn->phys_ctx = (struct mg_context *)(((char *)conn) + conn_size);\n\n#if defined(GCC_DIAGNOSTIC)\n#pragma GCC diagnostic pop\n#endif /* defined(GCC_DIAGNOSTIC) */\n\n\tconn->buf = (((char *)conn) + conn_size + ctx_size);\n\tconn->buf_size = (int)max_req_size;\n\tconn->phys_ctx->context_type = CONTEXT_HTTP_CLIENT;\n\tconn->dom_ctx = &(conn->phys_ctx->dd);\n\n\tif (!connect_socket(&common_client_context,\n\t                    client_options->host,\n\t                    client_options->port,\n\t                    use_ssl,\n\t                    ebuf,\n\t                    ebuf_len,\n\t                    &sock,\n\t                    &sa)) {\n\t\t/* ebuf is set by connect_socket,\n\t\t * free all memory and return NULL; */\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n\n#if !defined(NO_SSL)\n#if defined(OPENSSL_API_1_1)\n\tif (use_ssl\n\t    && (conn->client_ssl_ctx = SSL_CTX_new(TLS_client_method())) == NULL) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"SSL_CTX_new error\");\n\t\tclosesocket(sock);\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n#else\n\tif (use_ssl\n\t    && (conn->client_ssl_ctx = SSL_CTX_new(SSLv23_client_method()))\n\t           == NULL) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"SSL_CTX_new error\");\n\t\tclosesocket(sock);\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n#endif /* OPENSSL_API_1_1 */\n#endif /* NO_SSL */\n\n\n#if defined(USE_IPV6)\n\tlen = (sa.sa.sa_family == AF_INET) ? sizeof(conn->client.rsa.sin)\n\t                                   : sizeof(conn->client.rsa.sin6);\n\tpsa = (sa.sa.sa_family == AF_INET)\n\t          ? (struct sockaddr *)&(conn->client.rsa.sin)\n\t          : (struct sockaddr *)&(conn->client.rsa.sin6);\n#else\n\tlen = sizeof(conn->client.rsa.sin);\n\tpsa = (struct sockaddr *)&(conn->client.rsa.sin);\n#endif\n\n\tconn->client.sock = sock;\n\tconn->client.lsa = sa;\n\n\tif (getsockname(sock, psa, &len) != 0) {\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: getsockname() failed: %s\",\n\t\t                __func__,\n\t\t                strerror(ERRNO));\n\t}\n\n\tconn->client.is_ssl = use_ssl ? 1 : 0;\n\tif (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"Can not create mutex\");\n#if !defined(NO_SSL)\n\t\tSSL_CTX_free(conn->client_ssl_ctx);\n#endif\n\t\tclosesocket(sock);\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n\n\n#if !defined(NO_SSL)\n\tif (use_ssl) {\n\t\tcommon_client_context.dd.ssl_ctx = conn->client_ssl_ctx;\n\n\t\t/* TODO: Check ssl_verify_peer and ssl_ca_path here.\n\t\t * SSL_CTX_set_verify call is needed to switch off server\n\t\t * certificate checking, which is off by default in OpenSSL and\n\t\t * on in yaSSL. */\n\t\t/* TODO: SSL_CTX_set_verify(conn->client_ssl_ctx,\n\t\t * SSL_VERIFY_PEER, verify_ssl_server); */\n\n\t\tif (client_options->client_cert) {\n\t\t\tif (!ssl_use_pem_file(&common_client_context,\n\t\t\t                      &(common_client_context.dd),\n\t\t\t                      client_options->client_cert,\n\t\t\t                      NULL)) {\n\t\t\t\tmg_snprintf(NULL,\n\t\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t\t            ebuf,\n\t\t\t\t            ebuf_len,\n\t\t\t\t            \"Can not use SSL client certificate\");\n\t\t\t\tSSL_CTX_free(conn->client_ssl_ctx);\n\t\t\t\tclosesocket(sock);\n\t\t\t\tmg_free(conn);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (client_options->server_cert) {\n\t\t\tSSL_CTX_load_verify_locations(conn->client_ssl_ctx,\n\t\t\t                              client_options->server_cert,\n\t\t\t                              NULL);\n\t\t\tSSL_CTX_set_verify(conn->client_ssl_ctx, SSL_VERIFY_PEER, NULL);\n\t\t} else {\n\t\t\tSSL_CTX_set_verify(conn->client_ssl_ctx, SSL_VERIFY_NONE, NULL);\n\t\t}\n\n\t\tif (!sslize(conn,\n\t\t            conn->client_ssl_ctx,\n\t\t            SSL_connect,\n\t\t            &(conn->phys_ctx->stop_flag),\n\t\t            client_options)) {\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"SSL connection error\");\n\t\t\tSSL_CTX_free(conn->client_ssl_ctx);\n\t\t\tclosesocket(sock);\n\t\t\tmg_free(conn);\n\t\t\treturn NULL;\n\t\t}\n\t}\n#endif\n\n\tif (0 != set_non_blocking_mode(sock)) {\n\t\tmg_cry_internal(conn,\n\t\t                \"Cannot set non-blocking mode for client %s:%i\",\n\t\t                client_options->host,\n\t\t                client_options->port);\n\t}\n\n\treturn conn;\n}\n\n\nCIVETWEB_API struct mg_connection *\nmg_connect_client_secure(const struct mg_client_options *client_options,\n                         char *error_buffer,\n                         size_t error_buffer_size)\n{\n\treturn mg_connect_client_impl(client_options,\n\t                              1,\n\t                              error_buffer,\n\t                              error_buffer_size);\n}\n\n\nstruct mg_connection *\nmg_connect_client(const char *host,\n                  int port,\n                  int use_ssl,\n                  char *error_buffer,\n                  size_t error_buffer_size)\n{\n\tstruct mg_client_options opts;\n\tmemset(&opts, 0, sizeof(opts));\n\topts.host = host;\n\topts.port = port;\n\treturn mg_connect_client_impl(&opts,\n\t                              use_ssl,\n\t                              error_buffer,\n\t                              error_buffer_size);\n}\n\n\nstatic const struct {\n\tconst char *proto;\n\tsize_t proto_len;\n\tunsigned default_port;\n} abs_uri_protocols[] = {{\"http://\", 7, 80},\n                         {\"https://\", 8, 443},\n                         {\"ws://\", 5, 80},\n                         {\"wss://\", 6, 443},\n                         {NULL, 0, 0}};\n\n\n/* Check if the uri is valid.\n * return 0 for invalid uri,\n * return 1 for *,\n * return 2 for relative uri,\n * return 3 for absolute uri without port,\n * return 4 for absolute uri with port */\nstatic int\nget_uri_type(const char *uri)\n{\n\tint i;\n\tconst char *hostend, *portbegin;\n\tchar *portend;\n\tunsigned long port;\n\n\t/* According to the HTTP standard\n\t * http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2\n\t * URI can be an asterisk (*) or should start with slash (relative uri),\n\t * or it should start with the protocol (absolute uri). */\n\tif ((uri[0] == '*') && (uri[1] == '\\0')) {\n\t\t/* asterisk */\n\t\treturn 1;\n\t}\n\n\t/* Valid URIs according to RFC 3986\n\t * (https://www.ietf.org/rfc/rfc3986.txt)\n\t * must only contain reserved characters :/?#[]@!$&'()*+,;=\n\t * and unreserved characters A-Z a-z 0-9 and -._~\n\t * and % encoded symbols.\n\t */\n\tfor (i = 0; uri[i] != 0; i++) {\n\t\tif (uri[i] < 33) {\n\t\t\t/* control characters and spaces are invalid */\n\t\t\treturn 0;\n\t\t}\n\t\tif (uri[i] > 126) {\n\t\t\t/* non-ascii characters must be % encoded */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tswitch (uri[i]) {\n\t\t\tcase '\"':  /* 34 */\n\t\t\tcase '<':  /* 60 */\n\t\t\tcase '>':  /* 62 */\n\t\t\tcase '\\\\': /* 92 */\n\t\t\tcase '^':  /* 94 */\n\t\t\tcase '`':  /* 96 */\n\t\t\tcase '{':  /* 123 */\n\t\t\tcase '|':  /* 124 */\n\t\t\tcase '}':  /* 125 */\n\t\t\t\treturn 0;\n\t\t\tdefault:\n\t\t\t\t/* character is ok */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* A relative uri starts with a / character */\n\tif (uri[0] == '/') {\n\t\t/* relative uri */\n\t\treturn 2;\n\t}\n\n\t/* It could be an absolute uri: */\n\t/* This function only checks if the uri is valid, not if it is\n\t * addressing the current server. So civetweb can also be used\n\t * as a proxy server. */\n\tfor (i = 0; abs_uri_protocols[i].proto != NULL; i++) {\n\t\tif (mg_strncasecmp(uri,\n\t\t                   abs_uri_protocols[i].proto,\n\t\t                   abs_uri_protocols[i].proto_len)\n\t\t    == 0) {\n\n\t\t\thostend = strchr(uri + abs_uri_protocols[i].proto_len, '/');\n\t\t\tif (!hostend) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tportbegin = strchr(uri + abs_uri_protocols[i].proto_len, ':');\n\t\t\tif (!portbegin) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tport = strtoul(portbegin + 1, &portend, 10);\n\t\t\tif ((portend != hostend) || (port <= 0) || !is_valid_port(port)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\treturn 4;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n/* Return NULL or the relative uri at the current server */\nstatic const char *\nget_rel_url_at_current_server(const char *uri, const struct mg_connection *conn)\n{\n\tconst char *server_domain;\n\tsize_t server_domain_len;\n\tsize_t request_domain_len = 0;\n\tunsigned long port = 0;\n\tint i, auth_domain_check_enabled;\n\tconst char *hostbegin = NULL;\n\tconst char *hostend = NULL;\n\tconst char *portbegin;\n\tchar *portend;\n\n\tauth_domain_check_enabled =\n\t    !mg_strcasecmp(conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK], \"yes\");\n\n\t/* DNS is case insensitive, so use case insensitive string compare here\n\t */\n\tfor (i = 0; abs_uri_protocols[i].proto != NULL; i++) {\n\t\tif (mg_strncasecmp(uri,\n\t\t                   abs_uri_protocols[i].proto,\n\t\t                   abs_uri_protocols[i].proto_len)\n\t\t    == 0) {\n\n\t\t\thostbegin = uri + abs_uri_protocols[i].proto_len;\n\t\t\thostend = strchr(hostbegin, '/');\n\t\t\tif (!hostend) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tportbegin = strchr(hostbegin, ':');\n\t\t\tif ((!portbegin) || (portbegin > hostend)) {\n\t\t\t\tport = abs_uri_protocols[i].default_port;\n\t\t\t\trequest_domain_len = (size_t)(hostend - hostbegin);\n\t\t\t} else {\n\t\t\t\tport = strtoul(portbegin + 1, &portend, 10);\n\t\t\t\tif ((portend != hostend) || (port <= 0)\n\t\t\t\t    || !is_valid_port(port)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\trequest_domain_len = (size_t)(portbegin - hostbegin);\n\t\t\t}\n\t\t\t/* protocol found, port set */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!port) {\n\t\t/* port remains 0 if the protocol is not found */\n\t\treturn 0;\n\t}\n\n/* Check if the request is directed to a different server. */\n/* First check if the port is the same (IPv4 and IPv6). */\n#if defined(USE_IPV6)\n\tif (conn->client.lsa.sa.sa_family == AF_INET6) {\n\t\tif (ntohs(conn->client.lsa.sin6.sin6_port) != port) {\n\t\t\t/* Request is directed to a different port */\n\t\t\treturn 0;\n\t\t}\n\t} else\n#endif\n\t{\n\t\tif (ntohs(conn->client.lsa.sin.sin_port) != port) {\n\t\t\t/* Request is directed to a different port */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Finally check if the server corresponds to the authentication\n\t * domain of the server (the server domain).\n\t * Allow full matches (like http://mydomain.com/path/file.ext), and\n\t * allow subdomain matches (like http://www.mydomain.com/path/file.ext),\n\t * but do not allow substrings (like\n\t * http://notmydomain.com/path/file.ext\n\t * or http://mydomain.com.fake/path/file.ext).\n\t */\n\tif (auth_domain_check_enabled) {\n\t\tserver_domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];\n\t\tserver_domain_len = strlen(server_domain);\n\t\tif ((server_domain_len == 0) || (hostbegin == NULL)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif ((request_domain_len == server_domain_len)\n\t\t    && (!memcmp(server_domain, hostbegin, server_domain_len))) {\n\t\t\t/* Request is directed to this server - full name match. */\n\t\t} else {\n\t\t\tif (request_domain_len < (server_domain_len + 2)) {\n\t\t\t\t/* Request is directed to another server: The server name\n\t\t\t\t * is longer than the request name.\n\t\t\t\t * Drop this case here to avoid overflows in the\n\t\t\t\t * following checks. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (hostbegin[request_domain_len - server_domain_len - 1] != '.') {\n\t\t\t\t/* Request is directed to another server: It could be a\n\t\t\t\t * substring\n\t\t\t\t * like notmyserver.com */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (0\n\t\t\t    != memcmp(server_domain,\n\t\t\t              hostbegin + request_domain_len - server_domain_len,\n\t\t\t              server_domain_len)) {\n\t\t\t\t/* Request is directed to another server:\n\t\t\t\t * The server name is different. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn hostend;\n}\n\n\nstatic int\nget_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err)\n{\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = '\\0';\n\t}\n\t*err = 0;\n\n\treset_per_request_attributes(conn);\n\n\tif (!conn) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Internal error\");\n\t\t*err = 500;\n\t\treturn 0;\n\t}\n\t/* Set the time the request was received. This value should be used for\n\t * timeouts. */\n\tclock_gettime(CLOCK_MONOTONIC, &(conn->req_time));\n\n\tconn->request_len =\n\t    read_message(NULL, conn, conn->buf, conn->buf_size, &conn->data_len);\n\tDEBUG_ASSERT(conn->request_len < 0 || conn->data_len >= conn->request_len);\n\tif ((conn->request_len >= 0) && (conn->data_len < conn->request_len)) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Invalid message size\");\n\t\t*err = 500;\n\t\treturn 0;\n\t}\n\n\tif ((conn->request_len == 0) && (conn->data_len == conn->buf_size)) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Message too large\");\n\t\t*err = 413;\n\t\treturn 0;\n\t}\n\n\tif (conn->request_len <= 0) {\n\t\tif (conn->data_len > 0) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"Malformed message\");\n\t\t\t*err = 400;\n\t\t} else {\n\t\t\t/* Server did not recv anything -> just close the connection */\n\t\t\tconn->must_close = 1;\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"No data received\");\n\t\t\t*err = 0;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n\nstatic int\nget_request(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err)\n{\n\tconst char *cl;\n\tif (!get_message(conn, ebuf, ebuf_len, err)) {\n\t\treturn 0;\n\t}\n\n\tif (parse_http_request(conn->buf, conn->buf_size, &conn->request_info)\n\t    <= 0) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Bad request\");\n\t\t*err = 400;\n\t\treturn 0;\n\t}\n\n\t/* Message is a valid request */\n\n\t/* Is there a \"host\" ? */\n\tconn->host = alloc_get_host(conn);\n\tif (!conn->host) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Bad request: Host mismatch\");\n\t\t*err = 400;\n\t\treturn 0;\n\t}\n\n\t/* Do we know the content length? */\n\tif ((cl = get_header(conn->request_info.http_headers,\n\t                     conn->request_info.num_headers,\n\t                     \"Content-Length\"))\n\t    != NULL) {\n\t\t/* Request/response has content length set */\n\t\tchar *endptr = NULL;\n\t\tconn->content_len = strtoll(cl, &endptr, 10);\n\t\tif (endptr == cl) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"Bad request\");\n\t\t\t*err = 411;\n\t\t\treturn 0;\n\t\t}\n\t\t/* Publish the content length back to the request info. */\n\t\tconn->request_info.content_length = conn->content_len;\n\t} else if ((cl = get_header(conn->request_info.http_headers,\n\t                            conn->request_info.num_headers,\n\t                            \"Transfer-Encoding\"))\n\t               != NULL\n\t           && !mg_strcasecmp(cl, \"chunked\")) {\n\t\tconn->is_chunked = 1;\n\t\tconn->content_len = -1; /* unknown content length */\n\t} else {\n\t\tconst struct mg_http_method_info *meth =\n\t\t    get_http_method_info(conn->request_info.request_method);\n\t\tif (!meth) {\n\t\t\t/* No valid HTTP method */\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"Bad request\");\n\t\t\t*err = 411;\n\t\t\treturn 0;\n\t\t}\n\t\tif (meth->request_has_body) {\n\t\t\t/* POST or PUT request without content length set */\n\t\t\tconn->content_len = -1; /* unknown content length */\n\t\t} else {\n\t\t\t/* Other request */\n\t\t\tconn->content_len = 0; /* No content */\n\t\t}\n\t}\n\n\tconn->connection_type = CONNECTION_TYPE_REQUEST; /* Valid request */\n\treturn 1;\n}\n\n\n/* conn is assumed to be valid in this internal function */\nstatic int\nget_response(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err)\n{\n\tconst char *cl;\n\tif (!get_message(conn, ebuf, ebuf_len, err)) {\n\t\treturn 0;\n\t}\n\n\tif (parse_http_response(conn->buf, conn->buf_size, &conn->response_info)\n\t    <= 0) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Bad response\");\n\t\t*err = 400;\n\t\treturn 0;\n\t}\n\n\t/* Message is a valid response */\n\n\t/* Do we know the content length? */\n\tif ((cl = get_header(conn->response_info.http_headers,\n\t                     conn->response_info.num_headers,\n\t                     \"Content-Length\"))\n\t    != NULL) {\n\t\t/* Request/response has content length set */\n\t\tchar *endptr = NULL;\n\t\tconn->content_len = strtoll(cl, &endptr, 10);\n\t\tif (endptr == cl) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"Bad request\");\n\t\t\t*err = 411;\n\t\t\treturn 0;\n\t\t}\n\t\t/* Publish the content length back to the response info. */\n\t\tconn->response_info.content_length = conn->content_len;\n\n\t\t/* TODO: check if it is still used in response_info */\n\t\tconn->request_info.content_length = conn->content_len;\n\n\t} else if ((cl = get_header(conn->response_info.http_headers,\n\t                            conn->response_info.num_headers,\n\t                            \"Transfer-Encoding\"))\n\t               != NULL\n\t           && !mg_strcasecmp(cl, \"chunked\")) {\n\t\tconn->is_chunked = 1;\n\t\tconn->content_len = -1; /* unknown content length */\n\t} else {\n\t\tconn->content_len = -1; /* unknown content length */\n\t}\n\n\tconn->connection_type = CONNECTION_TYPE_RESPONSE; /* Valid response */\n\treturn 1;\n}\n\n\nint\nmg_get_response(struct mg_connection *conn,\n                char *ebuf,\n                size_t ebuf_len,\n                int timeout)\n{\n\tint err, ret;\n\tchar txt[32]; /* will not overflow */\n\tchar *save_timeout;\n\tchar *new_timeout;\n\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = '\\0';\n\t}\n\n\tif (!conn) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Parameter error\");\n\t\treturn -1;\n\t}\n\n\t/* Implementation of API function for HTTP clients */\n\tsave_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];\n\n\tif (timeout >= 0) {\n\t\tmg_snprintf(conn, NULL, txt, sizeof(txt), \"%i\", timeout);\n\t\tnew_timeout = txt;\n\t\t/* Not required for non-blocking sockets.\n\t\tset_sock_timeout(conn->client.sock, timeout);\n\t\t*/\n\t} else {\n\t\tnew_timeout = NULL;\n\t}\n\n\tconn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;\n\tret = get_response(conn, ebuf, ebuf_len, &err);\n\tconn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;\n\n#if defined(MG_LEGACY_INTERFACE)\n\t/* TODO: 1) uri is deprecated;\n\t *       2) here, ri.uri is the http response code */\n\tconn->request_info.uri = conn->request_info.request_uri;\n#endif\n\tconn->request_info.local_uri = conn->request_info.request_uri;\n\n\t/* TODO (mid): Define proper return values - maybe return length?\n\t * For the first test use <0 for error and >0 for OK */\n\treturn (ret == 0) ? -1 : +1;\n}\n\n\nstruct mg_connection *\nmg_download(const char *host,\n            int port,\n            int use_ssl,\n            char *ebuf,\n            size_t ebuf_len,\n            const char *fmt,\n            ...)\n{\n\tstruct mg_connection *conn;\n\tva_list ap;\n\tint i;\n\tint reqerr;\n\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = '\\0';\n\t}\n\n\tva_start(ap, fmt);\n\n\t/* open a connection */\n\tconn = mg_connect_client(host, port, use_ssl, ebuf, ebuf_len);\n\n\tif (conn != NULL) {\n\t\ti = mg_vprintf(conn, fmt, ap);\n\t\tif (i <= 0) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"Error sending request\");\n\t\t} else {\n\t\t\tget_response(conn, ebuf, ebuf_len, &reqerr);\n\n#if defined(MG_LEGACY_INTERFACE)\n\t\t\t/* TODO: 1) uri is deprecated;\n\t\t\t *       2) here, ri.uri is the http response code */\n\t\t\tconn->request_info.uri = conn->request_info.request_uri;\n#endif\n\t\t\tconn->request_info.local_uri = conn->request_info.request_uri;\n\t\t}\n\t}\n\n\t/* if an error occurred, close the connection */\n\tif ((ebuf[0] != '\\0') && (conn != NULL)) {\n\t\tmg_close_connection(conn);\n\t\tconn = NULL;\n\t}\n\n\tva_end(ap);\n\treturn conn;\n}\n\n\nstruct websocket_client_thread_data {\n\tstruct mg_connection *conn;\n\tmg_websocket_data_handler data_handler;\n\tmg_websocket_close_handler close_handler;\n\tvoid *callback_data;\n};\n\n\n#if defined(USE_WEBSOCKET)\n#if defined(_WIN32)\nstatic unsigned __stdcall websocket_client_thread(void *data)\n#else\nstatic void *\nwebsocket_client_thread(void *data)\n#endif\n{\n\tstruct websocket_client_thread_data *cdata =\n\t    (struct websocket_client_thread_data *)data;\n\n#if !defined(_WIN32)\n\tstruct sigaction sa;\n\n\t/* Ignore SIGPIPE */\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_IGN;\n\tsigaction(SIGPIPE, &sa, NULL);\n#endif\n\n\tmg_set_thread_name(\"ws-clnt\");\n\n\tif (cdata->conn->phys_ctx) {\n\t\tif (cdata->conn->phys_ctx->callbacks.init_thread) {\n\t\t\t/* 3 indicates a websocket client thread */\n\t\t\t/* TODO: check if conn->phys_ctx can be set */\n\t\t\tcdata->conn->phys_ctx->callbacks.init_thread(cdata->conn->phys_ctx,\n\t\t\t                                             3);\n\t\t}\n\t}\n\n\tread_websocket(cdata->conn, cdata->data_handler, cdata->callback_data);\n\n\tDEBUG_TRACE(\"%s\", \"Websocket client thread exited\\n\");\n\n\tif (cdata->close_handler != NULL) {\n\t\tcdata->close_handler(cdata->conn, cdata->callback_data);\n\t}\n\n\t/* The websocket_client context has only this thread. If it runs out,\n\t   set the stop_flag to 2 (= \"stopped\"). */\n\tcdata->conn->phys_ctx->stop_flag = 2;\n\n\tmg_free((void *)cdata);\n\n#if defined(_WIN32)\n\treturn 0;\n#else\n\treturn NULL;\n#endif\n}\n#endif\n\n\nstruct mg_connection *\nmg_connect_websocket_client(const char *host,\n                            int port,\n                            int use_ssl,\n                            char *error_buffer,\n                            size_t error_buffer_size,\n                            const char *path,\n                            const char *origin,\n                            mg_websocket_data_handler data_func,\n                            mg_websocket_close_handler close_func,\n                            void *user_data)\n{\n\tstruct mg_connection *conn = NULL;\n\n#if defined(USE_WEBSOCKET)\n\tstruct mg_context *newctx = NULL;\n\tstruct websocket_client_thread_data *thread_data;\n\tstatic const char *magic = \"x3JJHMbDL1EzLkh9GBhXDw==\";\n\tstatic const char *handshake_req;\n\n\tif (origin != NULL) {\n\t\thandshake_req = \"GET %s HTTP/1.1\\r\\n\"\n\t\t                \"Host: %s\\r\\n\"\n\t\t                \"Upgrade: websocket\\r\\n\"\n\t\t                \"Connection: Upgrade\\r\\n\"\n\t\t                \"Sec-WebSocket-Key: %s\\r\\n\"\n\t\t                \"Sec-WebSocket-Version: 13\\r\\n\"\n\t\t                \"Origin: %s\\r\\n\"\n\t\t                \"\\r\\n\";\n\t} else {\n\t\thandshake_req = \"GET %s HTTP/1.1\\r\\n\"\n\t\t                \"Host: %s\\r\\n\"\n\t\t                \"Upgrade: websocket\\r\\n\"\n\t\t                \"Connection: Upgrade\\r\\n\"\n\t\t                \"Sec-WebSocket-Key: %s\\r\\n\"\n\t\t                \"Sec-WebSocket-Version: 13\\r\\n\"\n\t\t                \"\\r\\n\";\n\t}\n\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"\n#endif\n\n\t/* Establish the client connection and request upgrade */\n\tconn = mg_download(host,\n\t                   port,\n\t                   use_ssl,\n\t                   error_buffer,\n\t                   error_buffer_size,\n\t                   handshake_req,\n\t                   path,\n\t                   host,\n\t                   magic,\n\t                   origin);\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n\t/* Connection object will be null if something goes wrong */\n\tif (conn == NULL) {\n\t\tif (!*error_buffer) {\n\t\t\t/* There should be already an error message */\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            error_buffer,\n\t\t\t            error_buffer_size,\n\t\t\t            \"Unexpected error\");\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (conn->response_info.status_code != 101) {\n\t\t/* We sent an \"upgrade\" request. For a correct websocket\n\t\t * protocol handshake, we expect a \"101 Continue\" response.\n\t\t * Otherwise it is a protocol violation. Maybe the HTTP\n\t\t * Server does not know websockets. */\n\t\tif (!*error_buffer) {\n\t\t\t/* set an error, if not yet set */\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            error_buffer,\n\t\t\t            error_buffer_size,\n\t\t\t            \"Unexpected server reply\");\n\t\t}\n\n\t\tDEBUG_TRACE(\"Websocket client connect error: %s\\r\\n\", error_buffer);\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n\n\t/* For client connections, mg_context is fake. Since we need to set a\n\t * callback function, we need to create a copy and modify it. */\n\tnewctx = (struct mg_context *)mg_malloc(sizeof(struct mg_context));\n\tif (!newctx) {\n\t\tDEBUG_TRACE(\"%s\\r\\n\", \"Out of memory\");\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n\n\tmemcpy(newctx, conn->phys_ctx, sizeof(struct mg_context));\n\tnewctx->user_data = user_data;\n\tnewctx->context_type = CONTEXT_WS_CLIENT; /* ws/wss client context */\n\tnewctx->cfg_worker_threads = 1; /* one worker thread will be created */\n\tnewctx->worker_threadids =\n\t    (pthread_t *)mg_calloc_ctx(newctx->cfg_worker_threads,\n\t                               sizeof(pthread_t),\n\t                               newctx);\n\n\tconn->phys_ctx = newctx;\n\tconn->dom_ctx = &(newctx->dd);\n\n\tthread_data = (struct websocket_client_thread_data *)\n\t    mg_calloc_ctx(sizeof(struct websocket_client_thread_data), 1, newctx);\n\tif (!thread_data) {\n\t\tDEBUG_TRACE(\"%s\\r\\n\", \"Out of memory\");\n\t\tmg_free(newctx);\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n\n\tthread_data->conn = conn;\n\tthread_data->data_handler = data_func;\n\tthread_data->close_handler = close_func;\n\tthread_data->callback_data = user_data;\n\n\t/* Start a thread to read the websocket client connection\n\t * This thread will automatically stop when mg_disconnect is\n\t * called on the client connection */\n\tif (mg_start_thread_with_id(websocket_client_thread,\n\t                            (void *)thread_data,\n\t                            newctx->worker_threadids)\n\t    != 0) {\n\t\tmg_free((void *)thread_data);\n\t\tmg_free((void *)newctx->worker_threadids);\n\t\tmg_free((void *)newctx);\n\t\tmg_free((void *)conn);\n\t\tconn = NULL;\n\t\tDEBUG_TRACE(\"%s\",\n\t\t            \"Websocket client connect thread could not be started\\r\\n\");\n\t}\n\n#else\n\t/* Appease \"unused parameter\" warnings */\n\t(void)host;\n\t(void)port;\n\t(void)use_ssl;\n\t(void)error_buffer;\n\t(void)error_buffer_size;\n\t(void)path;\n\t(void)origin;\n\t(void)user_data;\n\t(void)data_func;\n\t(void)close_func;\n#endif\n\n\treturn conn;\n}\n\n\n/* Prepare connection data structure */\nstatic void\ninit_connection(struct mg_connection *conn)\n{\n\t/* Is keep alive allowed by the server */\n\tint keep_alive_enabled =\n\t    !mg_strcasecmp(conn->dom_ctx->config[ENABLE_KEEP_ALIVE], \"yes\");\n\n\tif (!keep_alive_enabled) {\n\t\tconn->must_close = 1;\n\t}\n\n\t/* Important: on new connection, reset the receiving buffer. Credit\n\t * goes to crule42. */\n\tconn->data_len = 0;\n\tconn->handled_requests = 0;\n\tmg_set_user_connection_data(conn, NULL);\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 2; /* init */\n#endif\n\n\t/* call the init_connection callback if assigned */\n\tif (conn->phys_ctx->callbacks.init_connection != NULL) {\n\t\tif (conn->phys_ctx->context_type == CONTEXT_SERVER) {\n\t\t\tvoid *conn_data = NULL;\n\t\t\tconn->phys_ctx->callbacks.init_connection(conn, &conn_data);\n\t\t\tmg_set_user_connection_data(conn, conn_data);\n\t\t}\n\t}\n}\n\n\n/* Process a connection - may handle multiple requests\n * using the same connection.\n * Must be called with a valid connection (conn  and\n * conn->phys_ctx must be valid).\n */\nstatic void\nprocess_new_connection(struct mg_connection *conn)\n{\n\tstruct mg_request_info *ri = &conn->request_info;\n\tint keep_alive, discard_len;\n\tchar ebuf[100];\n\tconst char *hostend;\n\tint reqerr, uri_type;\n\n#if defined(USE_SERVER_STATS)\n\tint mcon = mg_atomic_inc(&(conn->phys_ctx->active_connections));\n\tmg_atomic_add(&(conn->phys_ctx->total_connections), 1);\n\tif (mcon > (conn->phys_ctx->max_connections)) {\n\t\t/* could use atomic compare exchange, but this\n\t\t * seems overkill for statistics data */\n\t\tconn->phys_ctx->max_connections = mcon;\n\t}\n#endif\n\n\tinit_connection(conn);\n\n\tDEBUG_TRACE(\"Start processing connection from %s\",\n\t            conn->request_info.remote_addr);\n\n\t/* Loop over multiple requests sent using the same connection\n\t * (while \"keep alive\"). */\n\tdo {\n\n\t\tDEBUG_TRACE(\"calling get_request (%i times for this connection)\",\n\t\t            conn->handled_requests + 1);\n\n#if defined(USE_SERVER_STATS)\n\t\tconn->conn_state = 3; /* ready */\n#endif\n\n\t\tif (!get_request(conn, ebuf, sizeof(ebuf), &reqerr)) {\n\t\t\t/* The request sent by the client could not be understood by\n\t\t\t * the server, or it was incomplete or a timeout. Send an\n\t\t\t * error message and close the connection. */\n\t\t\tif (reqerr > 0) {\n\t\t\t\tDEBUG_ASSERT(ebuf[0] != '\\0');\n\t\t\t\tmg_send_http_error(conn, reqerr, \"%s\", ebuf);\n\t\t\t}\n\t\t} else if (strcmp(ri->http_version, \"1.0\")\n\t\t           && strcmp(ri->http_version, \"1.1\")) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            sizeof(ebuf),\n\t\t\t            \"Bad HTTP version: [%s]\",\n\t\t\t            ri->http_version);\n\t\t\tmg_send_http_error(conn, 505, \"%s\", ebuf);\n\t\t}\n\n\t\tif (ebuf[0] == '\\0') {\n\t\t\turi_type = get_uri_type(conn->request_info.request_uri);\n\t\t\tswitch (uri_type) {\n\t\t\tcase 1:\n\t\t\t\t/* Asterisk */\n\t\t\t\tconn->request_info.local_uri = NULL;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t/* relative uri */\n\t\t\t\tconn->request_info.local_uri = conn->request_info.request_uri;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\tcase 4:\n\t\t\t\t/* absolute uri (with/without port) */\n\t\t\t\thostend = get_rel_url_at_current_server(\n\t\t\t\t    conn->request_info.request_uri, conn);\n\t\t\t\tif (hostend) {\n\t\t\t\t\tconn->request_info.local_uri = hostend;\n\t\t\t\t} else {\n\t\t\t\t\tconn->request_info.local_uri = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmg_snprintf(conn,\n\t\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t\t            ebuf,\n\t\t\t\t            sizeof(ebuf),\n\t\t\t\t            \"Invalid URI\");\n\t\t\t\tmg_send_http_error(conn, 400, \"%s\", ebuf);\n\t\t\t\tconn->request_info.local_uri = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\n#if defined(MG_LEGACY_INTERFACE)\n\t\t\t/* Legacy before split into local_uri and request_uri */\n\t\t\tconn->request_info.uri = conn->request_info.local_uri;\n#endif\n\t\t}\n\n\t\tDEBUG_TRACE(\"http: %s, error: %s\",\n\t\t            (ri->http_version ? ri->http_version : \"none\"),\n\t\t            (ebuf[0] ? ebuf : \"none\"));\n\n\t\tif (ebuf[0] == '\\0') {\n\t\t\tif (conn->request_info.local_uri) {\n\n/* handle request to local server */\n#if defined(USE_SERVER_STATS)\n\t\t\t\tconn->conn_state = 4; /* processing */\n#endif\n\t\t\t\thandle_request(conn);\n\n#if defined(USE_SERVER_STATS)\n\t\t\t\tconn->conn_state = 5; /* processed */\n\n\t\t\t\tmg_atomic_add(&(conn->phys_ctx->total_data_read),\n\t\t\t\t              conn->consumed_content);\n\t\t\t\tmg_atomic_add(&(conn->phys_ctx->total_data_written),\n\t\t\t\t              conn->num_bytes_sent);\n#endif\n\n\t\t\t\tDEBUG_TRACE(\"%s\", \"handle_request done\");\n\n\t\t\t\tif (conn->phys_ctx->callbacks.end_request != NULL) {\n\t\t\t\t\tconn->phys_ctx->callbacks.end_request(conn,\n\t\t\t\t\t                                      conn->status_code);\n\t\t\t\t\tDEBUG_TRACE(\"%s\", \"end_request callback done\");\n\t\t\t\t}\n\t\t\t\tlog_access(conn);\n\t\t\t} else {\n\t\t\t\t/* TODO: handle non-local request (PROXY) */\n\t\t\t\tconn->must_close = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tconn->must_close = 1;\n\t\t}\n\n\t\tif (ri->remote_user != NULL) {\n\t\t\tmg_free((void *)ri->remote_user);\n\t\t\t/* Important! When having connections with and without auth\n\t\t\t * would cause double free and then crash */\n\t\t\tri->remote_user = NULL;\n\t\t}\n\n\t\t/* NOTE(lsm): order is important here. should_keep_alive() call\n\t\t * is using parsed request, which will be invalid after\n\t\t * memmove's below.\n\t\t * Therefore, memorize should_keep_alive() result now for later\n\t\t * use in loop exit condition. */\n\t\tkeep_alive = (conn->phys_ctx->stop_flag == 0) && should_keep_alive(conn)\n\t\t             && (conn->content_len >= 0);\n\n\n\t\t/* Discard all buffered data for this request */\n\t\tdiscard_len = ((conn->content_len >= 0) && (conn->request_len > 0)\n\t\t               && ((conn->request_len + conn->content_len)\n\t\t                   < (int64_t)conn->data_len))\n\t\t                  ? (int)(conn->request_len + conn->content_len)\n\t\t                  : conn->data_len;\n\t\tDEBUG_ASSERT(discard_len >= 0);\n\t\tif (discard_len < 0) {\n\t\t\tDEBUG_TRACE(\"internal error: discard_len = %li\",\n\t\t\t            (long int)discard_len);\n\t\t\tbreak;\n\t\t}\n\t\tconn->data_len -= discard_len;\n\t\tif (conn->data_len > 0) {\n\t\t\tDEBUG_TRACE(\"discard_len = %lu\", (long unsigned)discard_len);\n\t\t\tmemmove(conn->buf, conn->buf + discard_len, (size_t)conn->data_len);\n\t\t}\n\n\t\tDEBUG_ASSERT(conn->data_len >= 0);\n\t\tDEBUG_ASSERT(conn->data_len <= conn->buf_size);\n\n\t\tif ((conn->data_len < 0) || (conn->data_len > conn->buf_size)) {\n\t\t\tDEBUG_TRACE(\"internal error: data_len = %li, buf_size = %li\",\n\t\t\t            (long int)conn->data_len,\n\t\t\t            (long int)conn->buf_size);\n\t\t\tbreak;\n\t\t}\n\n\t\tconn->handled_requests++;\n\n\t} while (keep_alive);\n\n\tDEBUG_TRACE(\"Done processing connection from %s (%f sec)\",\n\t            conn->request_info.remote_addr,\n\t            difftime(time(NULL), conn->conn_birth_time));\n\n\tclose_connection(conn);\n\n#if defined(USE_SERVER_STATS)\n\tmg_atomic_add(&(conn->phys_ctx->total_requests), conn->handled_requests);\n\tmg_atomic_dec(&(conn->phys_ctx->active_connections));\n#endif\n}\n\n\n#if defined(ALTERNATIVE_QUEUE)\n\nstatic void\nproduce_socket(struct mg_context *ctx, const struct socket *sp)\n{\n\tunsigned int i;\n\n\twhile (!ctx->stop_flag) {\n\t\tfor (i = 0; i < ctx->cfg_worker_threads; i++) {\n\t\t\t/* find a free worker slot and signal it */\n\t\t\tif (ctx->client_socks[i].in_use == 0) {\n\t\t\t\tctx->client_socks[i] = *sp;\n\t\t\t\tctx->client_socks[i].in_use = 1;\n\t\t\t\tevent_signal(ctx->client_wait_events[i]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/* queue is full */\n\t\tmg_sleep(1);\n\t}\n}\n\n\nstatic int\nconsume_socket(struct mg_context *ctx, struct socket *sp, int thread_index)\n{\n\tDEBUG_TRACE(\"%s\", \"going idle\");\n\tctx->client_socks[thread_index].in_use = 0;\n\tevent_wait(ctx->client_wait_events[thread_index]);\n\t*sp = ctx->client_socks[thread_index];\n\tDEBUG_TRACE(\"grabbed socket %d, going busy\", sp ? sp->sock : -1);\n\n\treturn !ctx->stop_flag;\n}\n\n#else /* ALTERNATIVE_QUEUE */\n\n/* Worker threads take accepted socket from the queue */\nstatic int\nconsume_socket(struct mg_context *ctx, struct socket *sp, int thread_index)\n{\n#define QUEUE_SIZE(ctx) ((int)(ARRAY_SIZE(ctx->queue)))\n\n\t(void)thread_index;\n\n\t(void)pthread_mutex_lock(&ctx->thread_mutex);\n\tDEBUG_TRACE(\"%s\", \"going idle\");\n\n\t/* If the queue is empty, wait. We're idle at this point. */\n\twhile ((ctx->sq_head == ctx->sq_tail) && (ctx->stop_flag == 0)) {\n\t\tpthread_cond_wait(&ctx->sq_full, &ctx->thread_mutex);\n\t}\n\n\t/* If we're stopping, sq_head may be equal to sq_tail. */\n\tif (ctx->sq_head > ctx->sq_tail) {\n\t\t/* Copy socket from the queue and increment tail */\n\t\t*sp = ctx->queue[ctx->sq_tail % QUEUE_SIZE(ctx)];\n\t\tctx->sq_tail++;\n\n\t\tDEBUG_TRACE(\"grabbed socket %d, going busy\", sp ? sp->sock : -1);\n\n\t\t/* Wrap pointers if needed */\n\t\twhile (ctx->sq_tail > QUEUE_SIZE(ctx)) {\n\t\t\tctx->sq_tail -= QUEUE_SIZE(ctx);\n\t\t\tctx->sq_head -= QUEUE_SIZE(ctx);\n\t\t}\n\t}\n\n\t(void)pthread_cond_signal(&ctx->sq_empty);\n\t(void)pthread_mutex_unlock(&ctx->thread_mutex);\n\n\treturn !ctx->stop_flag;\n#undef QUEUE_SIZE\n}\n\n\n/* Master thread adds accepted socket to a queue */\nstatic void\nproduce_socket(struct mg_context *ctx, const struct socket *sp)\n{\n#define QUEUE_SIZE(ctx) ((int)(ARRAY_SIZE(ctx->queue)))\n\tif (!ctx) {\n\t\treturn;\n\t}\n\t(void)pthread_mutex_lock(&ctx->thread_mutex);\n\n\t/* If the queue is full, wait */\n\twhile ((ctx->stop_flag == 0)\n\t       && (ctx->sq_head - ctx->sq_tail >= QUEUE_SIZE(ctx))) {\n\t\t(void)pthread_cond_wait(&ctx->sq_empty, &ctx->thread_mutex);\n\t}\n\n\tif (ctx->sq_head - ctx->sq_tail < QUEUE_SIZE(ctx)) {\n\t\t/* Copy socket to the queue and increment head */\n\t\tctx->queue[ctx->sq_head % QUEUE_SIZE(ctx)] = *sp;\n\t\tctx->sq_head++;\n\t\tDEBUG_TRACE(\"queued socket %d\", sp ? sp->sock : -1);\n\t}\n\n\t(void)pthread_cond_signal(&ctx->sq_full);\n\t(void)pthread_mutex_unlock(&ctx->thread_mutex);\n#undef QUEUE_SIZE\n}\n#endif /* ALTERNATIVE_QUEUE */\n\n\nstruct worker_thread_args {\n\tstruct mg_context *ctx;\n\tint index;\n};\n\n\nstatic void *\nworker_thread_run(struct worker_thread_args *thread_args)\n{\n\tstruct mg_context *ctx = thread_args->ctx;\n\tstruct mg_connection *conn;\n\tstruct mg_workerTLS tls;\n#if defined(MG_LEGACY_INTERFACE)\n\tuint32_t addr;\n#endif\n\n\tmg_set_thread_name(\"worker\");\n\n\ttls.is_master = 0;\n\ttls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);\n#if defined(_WIN32)\n\ttls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);\n#endif\n\n\t/* Initialize thread local storage before calling any callback */\n\tpthread_setspecific(sTlsKey, &tls);\n\n\tif (ctx->callbacks.init_thread) {\n\t\t/* call init_thread for a worker thread (type 1) */\n\t\tctx->callbacks.init_thread(ctx, 1);\n\t}\n\n\t/* Connection structure has been pre-allocated */\n\tif (((int)thread_args->index < 0)\n\t    || ((unsigned)thread_args->index\n\t        >= (unsigned)ctx->cfg_worker_threads)) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"Internal error: Invalid worker index %i\",\n\t\t                (int)thread_args->index);\n\t\treturn NULL;\n\t}\n\tconn = ctx->worker_connections + thread_args->index;\n\n\t/* Request buffers are not pre-allocated. They are private to the\n\t * request and do not contain any state information that might be\n\t * of interest to anyone observing a server status.  */\n\tconn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->phys_ctx);\n\tif (conn->buf == NULL) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"Out of memory: Cannot allocate buffer for worker %i\",\n\t\t                (int)thread_args->index);\n\t\treturn NULL;\n\t}\n\tconn->buf_size = (int)ctx->max_request_size;\n\n\tconn->phys_ctx = ctx;\n\tconn->dom_ctx = &(ctx->dd); /* Use default domain and default host */\n\tconn->host = NULL;          /* until we have more information. */\n\n\tconn->thread_index = thread_args->index;\n\tconn->request_info.user_data = ctx->user_data;\n\t/* Allocate a mutex for this connection to allow communication both\n\t * within the request handler and from elsewhere in the application\n\t */\n\tif (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {\n\t\tmg_free(conn->buf);\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"Cannot create mutex\");\n\t\treturn NULL;\n\t}\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 1; /* not consumed */\n#endif\n\n#if defined(ALTERNATIVE_QUEUE)\n\twhile ((ctx->stop_flag == 0)\n\t       && consume_socket(ctx, &conn->client, conn->thread_index)) {\n#else\n\t/* Call consume_socket() even when ctx->stop_flag > 0, to let it\n\t * signal sq_empty condvar to wake up the master waiting in\n\t * produce_socket() */\n\twhile (consume_socket(ctx, &conn->client, conn->thread_index)) {\n#endif\n\n\t\tconn->conn_birth_time = time(NULL);\n\n/* Fill in IP, port info early so even if SSL setup below fails,\n * error handler would have the corresponding info.\n * Thanks to Johannes Winkelmann for the patch.\n */\n#if defined(USE_IPV6)\n\t\tif (conn->client.rsa.sa.sa_family == AF_INET6) {\n\t\t\tconn->request_info.remote_port =\n\t\t\t    ntohs(conn->client.rsa.sin6.sin6_port);\n\t\t} else\n#endif\n\t\t{\n\t\t\tconn->request_info.remote_port =\n\t\t\t    ntohs(conn->client.rsa.sin.sin_port);\n\t\t}\n\n\t\tsockaddr_to_string(conn->request_info.remote_addr,\n\t\t                   sizeof(conn->request_info.remote_addr),\n\t\t                   &conn->client.rsa);\n\n\t\tDEBUG_TRACE(\"Start processing connection from %s\",\n\t\t            conn->request_info.remote_addr);\n\n\t\tconn->request_info.is_ssl = conn->client.is_ssl;\n\n\t\tif (conn->client.is_ssl) {\n#if !defined(NO_SSL)\n\t\t\t/* HTTPS connection */\n\t\t\tif (sslize(conn,\n\t\t\t           conn->dom_ctx->ssl_ctx,\n\t\t\t           SSL_accept,\n\t\t\t           &(conn->phys_ctx->stop_flag),\n\t\t\t           NULL)) {\n\t\t\t\t/* conn->dom_ctx is set in get_request */\n\n\t\t\t\t/* Get SSL client certificate information (if set) */\n\t\t\t\tssl_get_client_cert_info(conn);\n\n\t\t\t\t/* process HTTPS connection */\n\t\t\t\tprocess_new_connection(conn);\n\n\t\t\t\t/* Free client certificate info */\n\t\t\t\tif (conn->request_info.client_cert) {\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->subject));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->issuer));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->serial));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->finger));\n\t\t\t\t\t/* Free certificate memory */\n\t\t\t\t\tX509_free(\n\t\t\t\t\t    (X509 *)conn->request_info.client_cert->peer_cert);\n\t\t\t\t\tconn->request_info.client_cert->peer_cert = 0;\n\t\t\t\t\tconn->request_info.client_cert->subject = 0;\n\t\t\t\t\tconn->request_info.client_cert->issuer = 0;\n\t\t\t\t\tconn->request_info.client_cert->serial = 0;\n\t\t\t\t\tconn->request_info.client_cert->finger = 0;\n\t\t\t\t\tmg_free(conn->request_info.client_cert);\n\t\t\t\t\tconn->request_info.client_cert = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* make sure the connection is cleaned up on SSL failure */\n\t\t\t\tclose_connection(conn);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\t/* process HTTP connection */\n\t\t\tprocess_new_connection(conn);\n\t\t}\n\n\t\tDEBUG_TRACE(\"%s\", \"Connection closed\");\n\t}\n\n\n\tpthread_setspecific(sTlsKey, NULL);\n#if defined(_WIN32)\n\tCloseHandle(tls.pthread_cond_helper_mutex);\n#endif\n\tpthread_mutex_destroy(&conn->mutex);\n\n\t/* Free the request buffer. */\n\tconn->buf_size = 0;\n\tmg_free(conn->buf);\n\tconn->buf = NULL;\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 9; /* done */\n#endif\n\n\tDEBUG_TRACE(\"%s\", \"exiting\");\n\treturn NULL;\n}\n\n\n/* Threads have different return types on Windows and Unix. */\n#if defined(_WIN32)\nstatic unsigned __stdcall worker_thread(void *thread_func_param)\n{\n\tstruct worker_thread_args *pwta =\n\t    (struct worker_thread_args *)thread_func_param;\n\tworker_thread_run(pwta);\n\tmg_free(thread_func_param);\n\treturn 0;\n}\n#else\nstatic void *\nworker_thread(void *thread_func_param)\n{\n\tstruct worker_thread_args *pwta =\n\t    (struct worker_thread_args *)thread_func_param;\n\tstruct sigaction sa;\n\n\t/* Ignore SIGPIPE */\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_IGN;\n\tsigaction(SIGPIPE, &sa, NULL);\n\n\tworker_thread_run(pwta);\n\tmg_free(thread_func_param);\n\treturn NULL;\n}\n#endif /* _WIN32 */\n\n\n/* This is an internal function, thus all arguments are expected to be\n * valid - a NULL check is not required. */\nstatic void\naccept_new_connection(const struct socket *listener, struct mg_context *ctx)\n{\n\tstruct socket so;\n\tchar src_addr[IP_ADDR_STR_LEN];\n\tsocklen_t len = sizeof(so.rsa);\n\tint on = 1;\n\n\tif ((so.sock = accept(listener->sock, &so.rsa.sa, &len))\n\t    == INVALID_SOCKET) {\n\t} else if (!check_acl(ctx, ntohl(*(uint32_t *)&so.rsa.sin.sin_addr))) {\n\t\tsockaddr_to_string(src_addr, sizeof(src_addr), &so.rsa);\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s: %s is not allowed to connect\",\n\t\t                __func__,\n\t\t                src_addr);\n\t\tclosesocket(so.sock);\n\t} else {\n\t\t/* Put so socket structure into the queue */\n\t\tDEBUG_TRACE(\"Accepted socket %d\", (int)so.sock);\n\t\tset_close_on_exec(so.sock, fc(ctx));\n\t\tso.is_ssl = listener->is_ssl;\n\t\tso.ssl_redir = listener->ssl_redir;\n\t\tif (getsockname(so.sock, &so.lsa.sa, &len) != 0) {\n\t\t\tmg_cry_internal(fc(ctx),\n\t\t\t                \"%s: getsockname() failed: %s\",\n\t\t\t                __func__,\n\t\t\t                strerror(ERRNO));\n\t\t}\n\n\t\t/* Set TCP keep-alive. This is needed because if HTTP-level\n\t\t * keep-alive\n\t\t * is enabled, and client resets the connection, server won't get\n\t\t * TCP FIN or RST and will keep the connection open forever. With\n\t\t * TCP keep-alive, next keep-alive handshake will figure out that\n\t\t * the client is down and will close the server end.\n\t\t * Thanks to Igor Klopov who suggested the patch. */\n\t\tif (setsockopt(so.sock,\n\t\t               SOL_SOCKET,\n\t\t               SO_KEEPALIVE,\n\t\t               (SOCK_OPT_TYPE)&on,\n\t\t               sizeof(on))\n\t\t    != 0) {\n\t\t\tmg_cry_internal(\n\t\t\t    fc(ctx),\n\t\t\t    \"%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s\",\n\t\t\t    __func__,\n\t\t\t    strerror(ERRNO));\n\t\t}\n\n\t\t/* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced\n\t\t * to effectively fill up the underlying IP packet payload and\n\t\t * reduce the overhead of sending lots of small buffers. However\n\t\t * this hurts the server's throughput (ie. operations per second)\n\t\t * when HTTP 1.1 persistent connections are used and the responses\n\t\t * are relatively small (eg. less than 1400 bytes).\n\t\t */\n\t\tif ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL)\n\t\t    && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], \"1\"))) {\n\t\t\tif (set_tcp_nodelay(so.sock, 1) != 0) {\n\t\t\t\tmg_cry_internal(\n\t\t\t\t    fc(ctx),\n\t\t\t\t    \"%s: setsockopt(IPPROTO_TCP TCP_NODELAY) failed: %s\",\n\t\t\t\t    __func__,\n\t\t\t\t    strerror(ERRNO));\n\t\t\t}\n\t\t}\n\n\t\t/* We are using non-blocking sockets. Thus, the\n\t\t * set_sock_timeout(so.sock, timeout);\n\t\t * call is no longer required. */\n\n\t\t/* The \"non blocking\" property should already be\n\t\t * inherited from the parent socket. Set it for\n\t\t * non-compliant socket implementations. */\n\t\tset_non_blocking_mode(so.sock);\n\n\t\tso.in_use = 0;\n\t\tproduce_socket(ctx, &so);\n\t}\n}\n\n\nstatic void\nmaster_thread_run(void *thread_func_param)\n{\n\tstruct mg_context *ctx = (struct mg_context *)thread_func_param;\n\tstruct mg_workerTLS tls;\n\tstruct pollfd *pfd;\n\tunsigned int i;\n\tunsigned int workerthreadcount;\n\n\tif (!ctx) {\n\t\treturn;\n\t}\n\n\tmg_set_thread_name(\"master\");\n\n/* Increase priority of the master thread */\n#if defined(_WIN32)\n\tSetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);\n#elif defined(USE_MASTER_THREAD_PRIORITY)\n\tint min_prio = sched_get_priority_min(SCHED_RR);\n\tint max_prio = sched_get_priority_max(SCHED_RR);\n\tif ((min_prio >= 0) && (max_prio >= 0)\n\t    && ((USE_MASTER_THREAD_PRIORITY) <= max_prio)\n\t    && ((USE_MASTER_THREAD_PRIORITY) >= min_prio)) {\n\t\tstruct sched_param sched_param = {0};\n\t\tsched_param.sched_priority = (USE_MASTER_THREAD_PRIORITY);\n\t\tpthread_setschedparam(pthread_self(), SCHED_RR, &sched_param);\n\t}\n#endif\n\n/* Initialize thread local storage */\n#if defined(_WIN32)\n\ttls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);\n#endif\n\ttls.is_master = 1;\n\tpthread_setspecific(sTlsKey, &tls);\n\n\tif (ctx->callbacks.init_thread) {\n\t\t/* Callback for the master thread (type 0) */\n\t\tctx->callbacks.init_thread(ctx, 0);\n\t}\n\n\t/* Server starts *now* */\n\tctx->start_time = time(NULL);\n\n\t/* Start the server */\n\tpfd = ctx->listening_socket_fds;\n\twhile (ctx->stop_flag == 0) {\n\t\tfor (i = 0; i < ctx->num_listening_sockets; i++) {\n\t\t\tpfd[i].fd = ctx->listening_sockets[i].sock;\n\t\t\tpfd[i].events = POLLIN;\n\t\t}\n\n\t\tif (poll(pfd, ctx->num_listening_sockets, 200) > 0) {\n\t\t\tfor (i = 0; i < ctx->num_listening_sockets; i++) {\n\t\t\t\t/* NOTE(lsm): on QNX, poll() returns POLLRDNORM after the\n\t\t\t\t * successful poll, and POLLIN is defined as\n\t\t\t\t * (POLLRDNORM | POLLRDBAND)\n\t\t\t\t * Therefore, we're checking pfd[i].revents & POLLIN, not\n\t\t\t\t * pfd[i].revents == POLLIN. */\n\t\t\t\tif ((ctx->stop_flag == 0) && (pfd[i].revents & POLLIN)) {\n\t\t\t\t\taccept_new_connection(&ctx->listening_sockets[i], ctx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Here stop_flag is 1 - Initiate shutdown. */\n\tDEBUG_TRACE(\"%s\", \"stopping workers\");\n\n\t/* Stop signal received: somebody called mg_stop. Quit. */\n\tclose_all_listening_sockets(ctx);\n\n\t/* Wakeup workers that are waiting for connections to handle. */\n\t(void)pthread_mutex_lock(&ctx->thread_mutex);\n#if defined(ALTERNATIVE_QUEUE)\n\tfor (i = 0; i < ctx->cfg_worker_threads; i++) {\n\t\tevent_signal(ctx->client_wait_events[i]);\n\n\t\t/* Since we know all sockets, we can shutdown the connections. */\n\t\tif (ctx->client_socks[i].in_use) {\n\t\t\tshutdown(ctx->client_socks[i].sock, SHUTDOWN_BOTH);\n\t\t}\n\t}\n#else\n\tpthread_cond_broadcast(&ctx->sq_full);\n#endif\n\t(void)pthread_mutex_unlock(&ctx->thread_mutex);\n\n\t/* Join all worker threads to avoid leaking threads. */\n\tworkerthreadcount = ctx->cfg_worker_threads;\n\tfor (i = 0; i < workerthreadcount; i++) {\n\t\tif (ctx->worker_threadids[i] != 0) {\n\t\t\tmg_join_thread(ctx->worker_threadids[i]);\n\t\t}\n\t}\n\n#if defined(USE_LUA)\n\t/* Free Lua state of lua background task */\n\tif (ctx->lua_background_state) {\n\t\tlua_State *lstate = (lua_State *)ctx->lua_background_state;\n\t\tlua_getglobal(lstate, LUABACKGROUNDPARAMS);\n\t\tif (lua_istable(lstate, -1)) {\n\t\t\treg_boolean(lstate, \"shutdown\", 1);\n\t\t\tlua_pop(lstate, 1);\n\t\t\tmg_sleep(2);\n\t\t}\n\t\tlua_close(lstate);\n\t\tctx->lua_background_state = 0;\n\t}\n#endif\n\n\tDEBUG_TRACE(\"%s\", \"exiting\");\n\n#if defined(_WIN32)\n\tCloseHandle(tls.pthread_cond_helper_mutex);\n#endif\n\tpthread_setspecific(sTlsKey, NULL);\n\n\t/* Signal mg_stop() that we're done.\n\t * WARNING: This must be the very last thing this\n\t * thread does, as ctx becomes invalid after this line. */\n\tctx->stop_flag = 2;\n}\n\n\n/* Threads have different return types on Windows and Unix. */\n#if defined(_WIN32)\nstatic unsigned __stdcall master_thread(void *thread_func_param)\n{\n\tmaster_thread_run(thread_func_param);\n\treturn 0;\n}\n#else\nstatic void *\nmaster_thread(void *thread_func_param)\n{\n\tstruct sigaction sa;\n\n\t/* Ignore SIGPIPE */\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_IGN;\n\tsigaction(SIGPIPE, &sa, NULL);\n\n\tmaster_thread_run(thread_func_param);\n\treturn NULL;\n}\n#endif /* _WIN32 */\n\n\nstatic void\nfree_context(struct mg_context *ctx)\n{\n\tint i;\n\tstruct mg_handler_info *tmp_rh;\n\n\tif (ctx == NULL) {\n\t\treturn;\n\t}\n\n\tif (ctx->callbacks.exit_context) {\n\t\tctx->callbacks.exit_context(ctx);\n\t}\n\n\t/* All threads exited, no sync is needed. Destroy thread mutex and\n\t * condvars\n\t */\n\t(void)pthread_mutex_destroy(&ctx->thread_mutex);\n#if defined(ALTERNATIVE_QUEUE)\n\tmg_free(ctx->client_socks);\n\tfor (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {\n\t\tevent_destroy(ctx->client_wait_events[i]);\n\t}\n\tmg_free(ctx->client_wait_events);\n#else\n\t(void)pthread_cond_destroy(&ctx->sq_empty);\n\t(void)pthread_cond_destroy(&ctx->sq_full);\n#endif\n\n\t/* Destroy other context global data structures mutex */\n\t(void)pthread_mutex_destroy(&ctx->nonce_mutex);\n\n#if defined(USE_TIMERS)\n\ttimers_exit(ctx);\n#endif\n\n\t/* Deallocate config parameters */\n\tfor (i = 0; i < NUM_OPTIONS; i++) {\n\t\tif (ctx->dd.config[i] != NULL) {\n#if defined(_MSC_VER)\n#pragma warning(suppress : 6001)\n#endif\n\t\t\tmg_free(ctx->dd.config[i]);\n\t\t}\n\t}\n\n\t/* Deallocate request handlers */\n\twhile (ctx->dd.handlers) {\n\t\ttmp_rh = ctx->dd.handlers;\n\t\tctx->dd.handlers = tmp_rh->next;\n\t\tif (tmp_rh->handler_type == REQUEST_HANDLER) {\n\t\t\tpthread_cond_destroy(&tmp_rh->refcount_cond);\n\t\t\tpthread_mutex_destroy(&tmp_rh->refcount_mutex);\n\t\t}\n\t\tmg_free(tmp_rh->uri);\n\t\tmg_free(tmp_rh);\n\t}\n\n#if !defined(NO_SSL)\n\t/* Deallocate SSL context */\n\tif (ctx->dd.ssl_ctx != NULL) {\n\t\tvoid *ssl_ctx = (void *)ctx->dd.ssl_ctx;\n\t\tint callback_ret =\n\t\t    (ctx->callbacks.external_ssl_ctx == NULL)\n\t\t        ? 0\n\t\t        : (ctx->callbacks.external_ssl_ctx(&ssl_ctx, ctx->user_data));\n\n\t\tif (callback_ret == 0) {\n\t\t\tSSL_CTX_free(ctx->dd.ssl_ctx);\n\t\t}\n\t\t/* else: ignore error and ommit SSL_CTX_free in case\n\t\t * callback_ret is 1 */\n\t}\n#endif /* !NO_SSL */\n\n\t/* Deallocate worker thread ID array */\n\tif (ctx->worker_threadids != NULL) {\n\t\tmg_free(ctx->worker_threadids);\n\t}\n\n\t/* Deallocate worker thread ID array */\n\tif (ctx->worker_connections != NULL) {\n\t\tmg_free(ctx->worker_connections);\n\t}\n\n\t/* deallocate system name string */\n\tmg_free(ctx->systemName);\n\n\t/* Deallocate context itself */\n\tmg_free(ctx);\n}\n\n\nvoid\nmg_stop(struct mg_context *ctx)\n{\n\tpthread_t mt;\n\tif (!ctx) {\n\t\treturn;\n\t}\n\n\t/* We don't use a lock here. Calling mg_stop with the same ctx from\n\t * two threads is not allowed. */\n\tmt = ctx->masterthreadid;\n\tif (mt == 0) {\n\t\treturn;\n\t}\n\n\tctx->masterthreadid = 0;\n\n\t/* Set stop flag, so all threads know they have to exit. */\n\tctx->stop_flag = 1;\n\n\t/* Wait until everything has stopped. */\n\twhile (ctx->stop_flag != 2) {\n\t\t(void)mg_sleep(10);\n\t}\n\n\tmg_join_thread(mt);\n\tfree_context(ctx);\n\n#if defined(_WIN32)\n\t(void)WSACleanup();\n#endif /* _WIN32 */\n}\n\n\nstatic void\nget_system_name(char **sysName)\n{\n#if defined(_WIN32)\n#if !defined(__SYMBIAN32__)\n#if defined(_WIN32_WCE)\n\t*sysName = mg_strdup(\"WinCE\");\n#else\n\tchar name[128];\n\tDWORD dwVersion = 0;\n\tDWORD dwMajorVersion = 0;\n\tDWORD dwMinorVersion = 0;\n\tDWORD dwBuild = 0;\n\tBOOL wowRet, isWoW = FALSE;\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n/* GetVersion was declared deprecated */\n#pragma warning(disable : 4996)\n#endif\n\tdwVersion = GetVersion();\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n\tdwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));\n\tdwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));\n\tdwBuild = ((dwVersion < 0x80000000) ? (DWORD)(HIWORD(dwVersion)) : 0);\n\t(void)dwBuild;\n\n\twowRet = IsWow64Process(GetCurrentProcess(), &isWoW);\n\n\tsprintf(name,\n\t        \"Windows %u.%u%s\",\n\t        (unsigned)dwMajorVersion,\n\t        (unsigned)dwMinorVersion,\n\t        (wowRet ? (isWoW ? \" (WoW64)\" : \"\") : \" (?)\"));\n\n\t*sysName = mg_strdup(name);\n#endif\n#else\n\t*sysName = mg_strdup(\"Symbian\");\n#endif\n#else\n\tstruct utsname name;\n\tmemset(&name, 0, sizeof(name));\n\tuname(&name);\n\t*sysName = mg_strdup(name.sysname);\n#endif\n}\n\n\nstruct mg_context *\nmg_start(const struct mg_callbacks *callbacks,\n         void *user_data,\n         const char **options)\n{\n\tstruct mg_context *ctx;\n\tconst char *name, *value, *default_value;\n\tint idx, ok, workerthreadcount;\n\tunsigned int i;\n\tint itmp;\n\tvoid (*exit_callback)(const struct mg_context *ctx) = 0;\n\n\tstruct mg_workerTLS tls;\n\n#if defined(_WIN32)\n\tWSADATA data;\n\tWSAStartup(MAKEWORD(2, 2), &data);\n#endif /* _WIN32  */\n\n\t/* Allocate context and initialize reasonable general case defaults. */\n\tif ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {\n\t\treturn NULL;\n\t}\n\n\t/* Random number generator will initialize at the first call */\n\tctx->dd.auth_nonce_mask =\n\t    (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);\n\n\tif (mg_init_library_called == 0) {\n\t\t/* Legacy INIT, if mg_start is called without mg_init_library.\n\t\t * Note: This may cause a memory leak */\n\t\tconst char *ports_option =\n\t\t    config_options[LISTENING_PORTS].default_value;\n\n\t\tif (options) {\n\t\t\tconst char **run_options = options;\n\t\t\tconst char *optname = config_options[LISTENING_PORTS].name;\n\n\t\t\t/* Try to find the \"listening_ports\" option */\n\t\t\twhile (*run_options) {\n\t\t\t\tif (!strcmp(*run_options, optname)) {\n\t\t\t\t\tports_option = run_options[1];\n\t\t\t\t}\n\t\t\t\trun_options += 2;\n\t\t\t}\n\t\t}\n\n\t\tif (is_ssl_port_used(ports_option)) {\n\t\t\t/* Initialize with SSL support */\n\t\t\tmg_init_library(MG_FEATURES_TLS);\n\t\t} else {\n\t\t\t/* Initialize without SSL support */\n\t\t\tmg_init_library(MG_FEATURES_DEFAULT);\n\t\t}\n\t}\n\n\ttls.is_master = -1;\n\ttls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);\n#if defined(_WIN32)\n\ttls.pthread_cond_helper_mutex = NULL;\n#endif\n\tpthread_setspecific(sTlsKey, &tls);\n\n\tok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));\n#if !defined(ALTERNATIVE_QUEUE)\n\tok &= (0 == pthread_cond_init(&ctx->sq_empty, NULL));\n\tok &= (0 == pthread_cond_init(&ctx->sq_full, NULL));\n#endif\n\tok &= (0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr));\n\tif (!ok) {\n\t\t/* Fatal error - abort start. However, this situation should never\n\t\t * occur in practice. */\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s\",\n\t\t                \"Cannot initialize thread synchronization objects\");\n\t\tmg_free(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\tif (callbacks) {\n\t\tctx->callbacks = *callbacks;\n\t\texit_callback = callbacks->exit_context;\n\t\tctx->callbacks.exit_context = 0;\n\t}\n\tctx->user_data = user_data;\n\tctx->dd.handlers = NULL;\n\tctx->dd.next = NULL;\n\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\tctx->dd.shared_lua_websockets = NULL;\n#endif\n\n\t/* Store options */\n\twhile (options && (name = *options++) != NULL) {\n\t\tif ((idx = get_option_index(name)) == -1) {\n\t\t\tmg_cry_internal(fc(ctx), \"Invalid option: %s\", name);\n\t\t\tfree_context(ctx);\n\t\t\tpthread_setspecific(sTlsKey, NULL);\n\t\t\treturn NULL;\n\t\t} else if ((value = *options++) == NULL) {\n\t\t\tmg_cry_internal(fc(ctx), \"%s: option value cannot be NULL\", name);\n\t\t\tfree_context(ctx);\n\t\t\tpthread_setspecific(sTlsKey, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (ctx->dd.config[idx] != NULL) {\n\t\t\tmg_cry_internal(fc(ctx), \"warning: %s: duplicate option\", name);\n\t\t\tmg_free(ctx->dd.config[idx]);\n\t\t}\n\t\tctx->dd.config[idx] = mg_strdup_ctx(value, ctx);\n\t\tDEBUG_TRACE(\"[%s] -> [%s]\", name, value);\n\t}\n\n\t/* Set default value if needed */\n\tfor (i = 0; config_options[i].name != NULL; i++) {\n\t\tdefault_value = config_options[i].default_value;\n\t\tif ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {\n\t\t\tctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);\n\t\t}\n\t}\n\n\t/* Request size option */\n\titmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);\n\tif (itmp < 1024) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"max_request_size too small\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\tctx->max_request_size = (unsigned)itmp;\n\n\t/* Worker thread count option */\n\tworkerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);\n\n\tif (workerthreadcount > MAX_WORKER_THREADS) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"Too many worker threads\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\tif (workerthreadcount <= 0) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"Invalid number of worker threads\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n/* Document root */\n#if defined(NO_FILES)\n\tif (ctx->dd.config[DOCUMENT_ROOT] != NULL) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"Document root must not be set\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n#endif\n\n\tget_system_name(&ctx->systemName);\n\n#if defined(USE_LUA)\n\t/* If a Lua background script has been configured, start it. */\n\tif (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {\n\t\tchar ebuf[256];\n\t\tstruct vec opt_vec;\n\t\tstruct vec eq_vec;\n\t\tconst char *sparams;\n\t\tlua_State *state = mg_prepare_lua_context_script(\n\t\t    ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));\n\t\tif (!state) {\n\t\t\tmg_cry_internal(fc(ctx), \"lua_background_script error: %s\", ebuf);\n\t\t\tfree_context(ctx);\n\t\t\tpthread_setspecific(sTlsKey, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t\tctx->lua_background_state = (void *)state;\n\n\t\tlua_newtable(state);\n\t\treg_boolean(state, \"shutdown\", 0);\n\n\t\tsparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];\n\n\t\twhile ((sparams = next_option(sparams, &opt_vec, &eq_vec)) != NULL) {\n\t\t\treg_llstring(\n\t\t\t    state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);\n\t\t\tif (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tlua_setglobal(state, LUABACKGROUNDPARAMS);\n\n\t} else {\n\t\tctx->lua_background_state = 0;\n\t}\n#endif\n\n\t/* NOTE(lsm): order is important here. SSL certificates must\n\t * be initialized before listening ports. UID must be set last. */\n\tif (!set_gpass_option(ctx, NULL) ||\n#if !defined(NO_SSL)\n\t    !init_ssl_ctx(ctx, NULL) ||\n#endif\n\t    !set_ports_option(ctx) ||\n#if !defined(_WIN32)\n\t    !set_uid_option(ctx) ||\n#endif\n\t    !set_acl_option(ctx)) {\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\tctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));\n\tctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,\n\t                                                   sizeof(pthread_t),\n\t                                                   ctx);\n\n\tif (ctx->worker_threadids == NULL) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s\",\n\t\t                \"Not enough memory for worker thread ID array\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\tctx->worker_connections =\n\t    (struct mg_connection *)mg_calloc_ctx(ctx->cfg_worker_threads,\n\t                                          sizeof(struct mg_connection),\n\t                                          ctx);\n\tif (ctx->worker_connections == NULL) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s\",\n\t\t                \"Not enough memory for worker thread connection array\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\n#if defined(ALTERNATIVE_QUEUE)\n\tctx->client_wait_events =\n\t    (void **)mg_calloc_ctx(sizeof(ctx->client_wait_events[0]),\n\t                           ctx->cfg_worker_threads,\n\t                           ctx);\n\tif (ctx->client_wait_events == NULL) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s\",\n\t\t                \"Not enough memory for worker event array\");\n\t\tmg_free(ctx->worker_threadids);\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\tctx->client_socks =\n\t    (struct socket *)mg_calloc_ctx(sizeof(ctx->client_socks[0]),\n\t                                   ctx->cfg_worker_threads,\n\t                                   ctx);\n\tif (ctx->client_socks == NULL) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s\",\n\t\t                \"Not enough memory for worker socket array\");\n\t\tmg_free(ctx->client_wait_events);\n\t\tmg_free(ctx->worker_threadids);\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {\n\t\tctx->client_wait_events[i] = event_create();\n\t\tif (ctx->client_wait_events[i] == 0) {\n\t\t\tmg_cry_internal(fc(ctx), \"Error creating worker event %i\", i);\n\t\t\twhile (i > 0) {\n\t\t\t\ti--;\n\t\t\t\tevent_destroy(ctx->client_wait_events[i]);\n\t\t\t}\n\t\t\tmg_free(ctx->client_socks);\n\t\t\tmg_free(ctx->client_wait_events);\n\t\t\tmg_free(ctx->worker_threadids);\n\t\t\tfree_context(ctx);\n\t\t\tpthread_setspecific(sTlsKey, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t}\n#endif\n\n\n#if defined(USE_TIMERS)\n\tif (timers_init(ctx) != 0) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"Error creating timers\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n#endif\n\n\t/* Context has been created - init user libraries */\n\tif (ctx->callbacks.init_context) {\n\t\tctx->callbacks.init_context(ctx);\n\t}\n\tctx->callbacks.exit_context = exit_callback;\n\tctx->context_type = CONTEXT_SERVER; /* server context */\n\n\t/* Start master (listening) thread */\n\tmg_start_thread_with_id(master_thread, ctx, &ctx->masterthreadid);\n\n\t/* Start worker threads */\n\tfor (i = 0; i < ctx->cfg_worker_threads; i++) {\n\t\tstruct worker_thread_args *wta = (struct worker_thread_args *)\n\t\t    mg_malloc_ctx(sizeof(struct worker_thread_args), ctx);\n\t\tif (wta) {\n\t\t\twta->ctx = ctx;\n\t\t\twta->index = (int)i;\n\t\t}\n\n\t\tif ((wta == NULL)\n\t\t    || (mg_start_thread_with_id(worker_thread,\n\t\t                                wta,\n\t\t                                &ctx->worker_threadids[i])\n\t\t        != 0)) {\n\n\t\t\t/* thread was not created */\n\t\t\tif (wta != NULL) {\n\t\t\t\tmg_free(wta);\n\t\t\t}\n\n\t\t\tif (i > 0) {\n\t\t\t\tmg_cry_internal(fc(ctx),\n\t\t\t\t                \"Cannot start worker thread %i: error %ld\",\n\t\t\t\t                i + 1,\n\t\t\t\t                (long)ERRNO);\n\t\t\t} else {\n\t\t\t\tmg_cry_internal(fc(ctx),\n\t\t\t\t                \"Cannot create threads: error %ld\",\n\t\t\t\t                (long)ERRNO);\n\t\t\t\tfree_context(ctx);\n\t\t\t\tpthread_setspecific(sTlsKey, NULL);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpthread_setspecific(sTlsKey, NULL);\n\treturn ctx;\n}\n\n\n#if defined(MG_EXPERIMENTAL_INTERFACES)\n/* Add an additional domain to an already running web server. */\nint\nmg_start_domain(struct mg_context *ctx, const char **options)\n{\n\tconst char *name;\n\tconst char *value;\n\tconst char *default_value;\n\tstruct mg_domain_context *new_dom;\n\tstruct mg_domain_context *dom;\n\tint idx, i;\n\n\tif ((ctx == NULL) || (ctx->stop_flag != 0) || (options == NULL)) {\n\t\treturn -1;\n\t}\n\n\tnew_dom = (struct mg_domain_context *)\n\t    mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);\n\n\tif (!new_dom) {\n\t\t/* Out of memory */\n\t\treturn -6;\n\t}\n\n\t/* Store options - TODO: unite duplicate code */\n\twhile (options && (name = *options++) != NULL) {\n\t\tif ((idx = get_option_index(name)) == -1) {\n\t\t\tmg_cry_internal(fc(ctx), \"Invalid option: %s\", name);\n\t\t\tmg_free(new_dom);\n\t\t\treturn -2;\n\t\t} else if ((value = *options++) == NULL) {\n\t\t\tmg_cry_internal(fc(ctx), \"%s: option value cannot be NULL\", name);\n\t\t\tmg_free(new_dom);\n\t\t\treturn -2;\n\t\t}\n\t\tif (new_dom->config[idx] != NULL) {\n\t\t\tmg_cry_internal(fc(ctx), \"warning: %s: duplicate option\", name);\n\t\t\tmg_free(new_dom->config[idx]);\n\t\t}\n\t\tnew_dom->config[idx] = mg_strdup_ctx(value, ctx);\n\t\tDEBUG_TRACE(\"[%s] -> [%s]\", name, value);\n\t}\n\n\t/* Authentication domain is mandatory */\n\t/* TODO: Maybe use a new option hostname? */\n\tif (!new_dom->config[AUTHENTICATION_DOMAIN]) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"authentication domain required\");\n\t\tmg_free(new_dom);\n\t\treturn -4;\n\t}\n\n\t/* Set default value if needed. Take the config value from\n\t * ctx as a default value. */\n\tfor (i = 0; config_options[i].name != NULL; i++) {\n\t\tdefault_value = ctx->dd.config[i];\n\t\tif ((new_dom->config[i] == NULL) && (default_value != NULL)) {\n\t\t\tnew_dom->config[i] = mg_strdup_ctx(default_value, ctx);\n\t\t}\n\t}\n\n\tnew_dom->handlers = NULL;\n\tnew_dom->next = NULL;\n\tnew_dom->nonce_count = 0;\n\tnew_dom->auth_nonce_mask =\n\t    (uint64_t)get_random() ^ ((uint64_t)get_random() << 31);\n\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\tnew_dom->shared_lua_websockets = NULL;\n#endif\n\n\tif (!init_ssl_ctx(ctx, new_dom)) {\n\t\t/* Init SSL failed */\n\t\tmg_free(new_dom);\n\t\treturn -3;\n\t}\n\n\t/* Add element to linked list. */\n\tmg_lock_context(ctx);\n\n\tidx = 0;\n\tdom = &(ctx->dd);\n\tfor (;;) {\n\t\tif (!strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],\n\t\t                dom->config[AUTHENTICATION_DOMAIN])) {\n\t\t\t/* Domain collision */\n\t\t\tmg_cry_internal(fc(ctx),\n\t\t\t                \"domain %s already in use\",\n\t\t\t                new_dom->config[AUTHENTICATION_DOMAIN]);\n\t\t\tmg_free(new_dom);\n\t\t\treturn -5;\n\t\t}\n\n\t\t/* Count number of domains */\n\t\tidx++;\n\n\t\tif (dom->next == NULL) {\n\t\t\tdom->next = new_dom;\n\t\t\tbreak;\n\t\t}\n\t\tdom = dom->next;\n\t}\n\n\tmg_unlock_context(ctx);\n\n\t/* Return domain number */\n\treturn idx;\n}\n#endif\n\n\n/* Feature check API function */\nunsigned\nmg_check_feature(unsigned feature)\n{\n\tstatic const unsigned feature_set = 0\n/* Set bits for available features according to API documentation.\n * This bit mask is created at compile time, according to the active\n * preprocessor defines. It is a single const value at runtime. */\n#if !defined(NO_FILES)\n\t                                    | MG_FEATURES_FILES\n#endif\n#if !defined(NO_SSL)\n\t                                    | MG_FEATURES_SSL\n#endif\n#if !defined(NO_CGI)\n\t                                    | MG_FEATURES_CGI\n#endif\n#if defined(USE_IPV6)\n\t                                    | MG_FEATURES_IPV6\n#endif\n#if defined(USE_WEBSOCKET)\n\t                                    | MG_FEATURES_WEBSOCKET\n#endif\n#if defined(USE_LUA)\n\t                                    | MG_FEATURES_LUA\n#endif\n#if defined(USE_DUKTAPE)\n\t                                    | MG_FEATURES_SSJS\n#endif\n#if !defined(NO_CACHING)\n\t                                    | MG_FEATURES_CACHE\n#endif\n#if defined(USE_SERVER_STATS)\n\t                                    | MG_FEATURES_STATS\n#endif\n#if defined(USE_ZLIB)\n\t                                    | MG_FEATURES_COMPRESSION\n#endif\n\n/* Set some extra bits not defined in the API documentation.\n * These bits may change without further notice. */\n#if defined(MG_LEGACY_INTERFACE)\n\t                                    | 0x00008000u\n#endif\n#if defined(MG_EXPERIMENTAL_INTERFACES)\n\t                                    | 0x00004000u\n#endif\n#if defined(MEMORY_DEBUGGING)\n\t                                    | 0x00001000u\n#endif\n#if defined(USE_TIMERS)\n\t                                    | 0x00020000u\n#endif\n#if !defined(NO_NONCE_CHECK)\n\t                                    | 0x00040000u\n#endif\n#if !defined(NO_POPEN)\n\t                                    | 0x00080000u\n#endif\n\t    ;\n\treturn (feature & feature_set);\n}\n\n\n/* strcat with additional NULL check to avoid clang scan-build warning. */\n#define strcat0(a, b)                                                          \\\n\t{                                                                          \\\n\t\tif ((a != NULL) && (b != NULL)) {                                      \\\n\t\t\tstrcat(a, b);                                                      \\\n\t\t}                                                                      \\\n\t}\n\n\n/* Get system information. It can be printed or stored by the caller.\n * Return the size of available information. */\nstatic int\nmg_get_system_info_impl(char *buffer, int buflen)\n{\n\tchar block[256];\n\tint system_info_length = 0;\n\n#if defined(_WIN32)\n\tconst char *eol = \"\\r\\n\";\n#else\n\tconst char *eol = \"\\n\";\n#endif\n\n\tconst char *eoobj = \"}\";\n\tint reserved_len = (int)strlen(eoobj) + (int)strlen(eol);\n\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\tbuflen = 0;\n\t} else {\n\t\t*buffer = 0;\n\t}\n\n\tmg_snprintf(NULL, NULL, block, sizeof(block), \"{%s\", eol);\n\tsystem_info_length += (int)strlen(block);\n\tif (system_info_length < buflen) {\n\t\tstrcat0(buffer, block);\n\t}\n\n\t/* Server version */\n\t{\n\t\tconst char *version = mg_version();\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"version\\\" : \\\"%s\\\",%s\",\n\t\t            version,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* System info */\n\t{\n#if defined(_WIN32)\n\t\tDWORD dwVersion = 0;\n\t\tDWORD dwMajorVersion = 0;\n\t\tDWORD dwMinorVersion = 0;\n\t\tSYSTEM_INFO si;\n\n\t\tGetSystemInfo(&si);\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n/* GetVersion was declared deprecated */\n#pragma warning(disable : 4996)\n#endif\n\t\tdwVersion = GetVersion();\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n\t\tdwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));\n\t\tdwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));\n\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"os\\\" : \\\"Windows %u.%u\\\",%s\",\n\t\t            (unsigned)dwMajorVersion,\n\t\t            (unsigned)dwMinorVersion,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"cpu\\\" : \\\"type %u, cores %u, mask %x\\\",%s\",\n\t\t            (unsigned)si.wProcessorArchitecture,\n\t\t            (unsigned)si.dwNumberOfProcessors,\n\t\t            (unsigned)si.dwActiveProcessorMask,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#else\n\t\tstruct utsname name;\n\t\tmemset(&name, 0, sizeof(name));\n\t\tuname(&name);\n\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"os\\\" : \\\"%s %s (%s) - %s\\\",%s\",\n\t\t            name.sysname,\n\t\t            name.version,\n\t\t            name.release,\n\t\t            name.machine,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#endif\n\t}\n\n\t/* Features */\n\t{\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"features\\\" : %lu,%s\"\n\t\t            \"\\\"feature_list\\\" : \\\"Server:%s%s%s%s%s%s%s%s%s\\\",%s\",\n\t\t            (unsigned long)mg_check_feature(0xFFFFFFFFu),\n\t\t            eol,\n\t\t            mg_check_feature(MG_FEATURES_FILES) ? \" Files\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_SSL) ? \" HTTPS\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_CGI) ? \" CGI\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_IPV6) ? \" IPv6\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_WEBSOCKET) ? \" WebSockets\"\n\t\t                                                    : \"\",\n\t\t            mg_check_feature(MG_FEATURES_LUA) ? \" Lua\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_SSJS) ? \" JavaScript\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_CACHE) ? \" Cache\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_STATS) ? \" Stats\" : \"\",\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\n#if defined(USE_LUA)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"lua_version\\\" : \\\"%u (%s)\\\",%s\",\n\t\t            (unsigned)LUA_VERSION_NUM,\n\t\t            LUA_RELEASE,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#endif\n#if defined(USE_DUKTAPE)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"javascript\\\" : \\\"Duktape %u.%u.%u\\\",%s\",\n\t\t            (unsigned)DUK_VERSION / 10000,\n\t\t            ((unsigned)DUK_VERSION / 100) % 100,\n\t\t            (unsigned)DUK_VERSION % 100,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#endif\n\t}\n\n\t/* Build date */\n\t{\n#if defined(GCC_DIAGNOSTIC)\n#if GCC_VERSION >= 50000\n#pragma GCC diagnostic push\n/* Disable bogus compiler warning -Wdate-time */\n#pragma GCC diagnostic ignored \"-Wdate-time\"\n#endif\n#endif\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"build\\\" : \\\"%s\\\",%s\",\n\t\t            __DATE__,\n\t\t            eol);\n\n#if defined(GCC_DIAGNOSTIC)\n#if GCC_VERSION >= 50000\n#pragma GCC diagnostic pop\n#endif\n#endif\n\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\n\t/* Compiler information */\n\t/* http://sourceforge.net/p/predef/wiki/Compilers/ */\n\t{\n#if defined(_MSC_VER)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"MSC: %u (%u)\\\",%s\",\n\t\t            (unsigned)_MSC_VER,\n\t\t            (unsigned)_MSC_FULL_VER,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__MINGW64__)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"MinGW64: %u.%u\\\",%s\",\n\t\t            (unsigned)__MINGW64_VERSION_MAJOR,\n\t\t            (unsigned)__MINGW64_VERSION_MINOR,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"MinGW32: %u.%u\\\",%s\",\n\t\t            (unsigned)__MINGW32_MAJOR_VERSION,\n\t\t            (unsigned)__MINGW32_MINOR_VERSION,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__MINGW32__)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"MinGW32: %u.%u\\\",%s\",\n\t\t            (unsigned)__MINGW32_MAJOR_VERSION,\n\t\t            (unsigned)__MINGW32_MINOR_VERSION,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__clang__)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"clang: %u.%u.%u (%s)\\\",%s\",\n\t\t            __clang_major__,\n\t\t            __clang_minor__,\n\t\t            __clang_patchlevel__,\n\t\t            __clang_version__,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__GNUC__)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"gcc: %u.%u.%u\\\",%s\",\n\t\t            (unsigned)__GNUC__,\n\t\t            (unsigned)__GNUC_MINOR__,\n\t\t            (unsigned)__GNUC_PATCHLEVEL__,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__INTEL_COMPILER)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"Intel C/C++: %u\\\",%s\",\n\t\t            (unsigned)__INTEL_COMPILER,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__BORLANDC__)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"Borland C: 0x%x\\\",%s\",\n\t\t            (unsigned)__BORLANDC__,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__SUNPRO_C)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"Solaris: 0x%x\\\",%s\",\n\t\t            (unsigned)__SUNPRO_C,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#else\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"other\\\",%s\",\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#endif\n\t}\n\n\t/* Determine 32/64 bit data mode.\n\t * see https://en.wikipedia.org/wiki/64-bit_computing */\n\t{\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"data_model\\\" : \\\"int:%u/%u/%u/%u, float:%u/%u/%u, \"\n\t\t            \"char:%u/%u, \"\n\t\t            \"ptr:%u, size:%u, time:%u\\\"%s\",\n\t\t            (unsigned)sizeof(short),\n\t\t            (unsigned)sizeof(int),\n\t\t            (unsigned)sizeof(long),\n\t\t            (unsigned)sizeof(long long),\n\t\t            (unsigned)sizeof(float),\n\t\t            (unsigned)sizeof(double),\n\t\t            (unsigned)sizeof(long double),\n\t\t            (unsigned)sizeof(char),\n\t\t            (unsigned)sizeof(wchar_t),\n\t\t            (unsigned)sizeof(void *),\n\t\t            (unsigned)sizeof(size_t),\n\t\t            (unsigned)sizeof(time_t),\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Terminate string */\n\tif ((buflen > 0) && buffer && buffer[0]) {\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, eoobj);\n\t\t\tstrcat0(buffer, eol);\n\t\t}\n\t}\n\tsystem_info_length += reserved_len;\n\n\treturn system_info_length;\n}\n\n\n#if defined(USE_SERVER_STATS)\n/* Get context information. It can be printed or stored by the caller.\n * Return the size of available information. */\nstatic int\nmg_get_context_info_impl(const struct mg_context *ctx, char *buffer, int buflen)\n\n{\n\tchar block[256];\n\tint context_info_length = 0;\n\n#if defined(_WIN32)\n\tconst char *eol = \"\\r\\n\";\n#else\n\tconst char *eol = \"\\n\";\n#endif\n\tstruct mg_memory_stat *ms = get_memory_stat((struct mg_context *)ctx);\n\n\tconst char *eoobj = \"}\";\n\tint reserved_len = (int)strlen(eoobj) + (int)strlen(eol);\n\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\tbuflen = 0;\n\t} else {\n\t\t*buffer = 0;\n\t}\n\n\tmg_snprintf(NULL, NULL, block, sizeof(block), \"{%s\", eol);\n\tcontext_info_length += (int)strlen(block);\n\tif (context_info_length < buflen) {\n\t\tstrcat0(buffer, block);\n\t}\n\n\tif (ms) { /* <-- should be always true */\n\t\t/* Memory information */\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"memory\\\" : {%s\"\n\t\t            \"\\\"blocks\\\" : %i,%s\"\n\t\t            \"\\\"used\\\" : %\" INT64_FMT \",%s\"\n\t\t            \"\\\"maxUsed\\\" : %\" INT64_FMT \"%s\"\n\t\t            \"}%s%s\",\n\t\t            eol,\n\t\t            ms->blockCount,\n\t\t            eol,\n\t\t            ms->totalMemUsed,\n\t\t            eol,\n\t\t            ms->maxMemUsed,\n\t\t            eol,\n\t\t            (ctx ? \",\" : \"\"),\n\t\t            eol);\n\n\t\tcontext_info_length += (int)strlen(block);\n\t\tif (context_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\tif (ctx) {\n\t\t/* Declare all variables at begin of the block, to comply\n\t\t * with old C standards. */\n\t\tchar start_time_str[64] = {0};\n\t\tchar now_str[64] = {0};\n\t\ttime_t start_time = ctx->start_time;\n\t\ttime_t now = time(NULL);\n\n\t\t/* Connections information */\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"connections\\\" : {%s\"\n\t\t            \"\\\"active\\\" : %i,%s\"\n\t\t            \"\\\"maxActive\\\" : %i,%s\"\n\t\t            \"\\\"total\\\" : %\" INT64_FMT \"%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            ctx->active_connections,\n\t\t            eol,\n\t\t            ctx->max_connections,\n\t\t            eol,\n\t\t            ctx->total_connections,\n\t\t            eol,\n\t\t            eol);\n\n\t\tcontext_info_length += (int)strlen(block);\n\t\tif (context_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\n\t\t/* Requests information */\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"requests\\\" : {%s\"\n\t\t            \"\\\"total\\\" : %\" INT64_FMT \"%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            ctx->total_requests,\n\t\t            eol,\n\t\t            eol);\n\n\t\tcontext_info_length += (int)strlen(block);\n\t\tif (context_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\n\t\t/* Data information */\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"data\\\" : {%s\"\n\t\t            \"\\\"read\\\" : %\" INT64_FMT \"%s,\"\n\t\t            \"\\\"written\\\" : %\" INT64_FMT \"%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            ctx->total_data_read,\n\t\t            eol,\n\t\t            ctx->total_data_written,\n\t\t            eol,\n\t\t            eol);\n\n\t\tcontext_info_length += (int)strlen(block);\n\t\tif (context_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\n\t\t/* Execution time information */\n\t\tgmt_time_string(start_time_str,\n\t\t                sizeof(start_time_str) - 1,\n\t\t                &start_time);\n\t\tgmt_time_string(now_str, sizeof(now_str) - 1, &now);\n\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"time\\\" : {%s\"\n\t\t            \"\\\"uptime\\\" : %.0f,%s\"\n\t\t            \"\\\"start\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"now\\\" : \\\"%s\\\"%s\"\n\t\t            \"}%s\",\n\t\t            eol,\n\t\t            difftime(now, start_time),\n\t\t            eol,\n\t\t            start_time_str,\n\t\t            eol,\n\t\t            now_str,\n\t\t            eol,\n\t\t            eol);\n\n\t\tcontext_info_length += (int)strlen(block);\n\t\tif (context_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Terminate string */\n\tif ((buflen > 0) && buffer && buffer[0]) {\n\t\tif (context_info_length < buflen) {\n\t\t\tstrcat0(buffer, eoobj);\n\t\t\tstrcat0(buffer, eol);\n\t\t}\n\t}\n\tcontext_info_length += reserved_len;\n\n\treturn context_info_length;\n}\n#endif\n\n\n#if defined(MG_EXPERIMENTAL_INTERFACES)\n/* Get connection information. It can be printed or stored by the caller.\n * Return the size of available information. */\nstatic int\nmg_get_connection_info_impl(const struct mg_context *ctx,\n                            int idx,\n                            char *buffer,\n                            int buflen)\n{\n\tconst struct mg_connection *conn;\n\tconst struct mg_request_info *ri;\n\tchar block[256];\n\tint connection_info_length = 0;\n\tint state = 0;\n\tconst char *state_str = \"unknown\";\n\n#if defined(_WIN32)\n\tconst char *eol = \"\\r\\n\";\n#else\n\tconst char *eol = \"\\n\";\n#endif\n\n\tconst char *eoobj = \"}\";\n\tint reserved_len = (int)strlen(eoobj) + (int)strlen(eol);\n\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\tbuflen = 0;\n\t} else {\n\t\t*buffer = 0;\n\t}\n\n\tif ((ctx == NULL) || (idx < 0)) {\n\t\t/* Parameter error */\n\t\treturn 0;\n\t}\n\n\tif ((unsigned)idx >= ctx->cfg_worker_threads) {\n\t\t/* Out of range */\n\t\treturn 0;\n\t}\n\n\t/* Take connection [idx]. This connection is not locked in\n\t * any way, so some other thread might use it. */\n\tconn = (ctx->worker_connections) + idx;\n\n\t/* Initialize output string */\n\tmg_snprintf(NULL, NULL, block, sizeof(block), \"{%s\", eol);\n\tconnection_info_length += (int)strlen(block);\n\tif (connection_info_length < buflen) {\n\t\tstrcat0(buffer, block);\n\t}\n\n\t/* Init variables */\n\tri = &(conn->request_info);\n\n#if defined(USE_SERVER_STATS)\n\tstate = conn->conn_state;\n\n\t/* State as string */\n\tswitch (state) {\n\tcase 0:\n\t\tstate_str = \"undefined\";\n\t\tbreak;\n\tcase 1:\n\t\tstate_str = \"not used\";\n\t\tbreak;\n\tcase 2:\n\t\tstate_str = \"init\";\n\t\tbreak;\n\tcase 3:\n\t\tstate_str = \"ready\";\n\t\tbreak;\n\tcase 4:\n\t\tstate_str = \"processing\";\n\t\tbreak;\n\tcase 5:\n\t\tstate_str = \"processed\";\n\t\tbreak;\n\tcase 6:\n\t\tstate_str = \"to close\";\n\t\tbreak;\n\tcase 7:\n\t\tstate_str = \"closing\";\n\t\tbreak;\n\tcase 8:\n\t\tstate_str = \"closed\";\n\t\tbreak;\n\tcase 9:\n\t\tstate_str = \"done\";\n\t\tbreak;\n\t}\n#endif\n\n\t/* Connection info */\n\tif ((state >= 3) && (state < 9)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"connection\\\" : {%s\"\n\t\t            \"\\\"remote\\\" : {%s\"\n\t\t            \"\\\"protocol\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"addr\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"port\\\" : %u%s\"\n\t\t            \"},%s\"\n\t\t            \"\\\"handled_requests\\\" : %u%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            eol,\n\t\t            get_proto_name(conn),\n\t\t            eol,\n\t\t            ri->remote_addr,\n\t\t            eol,\n\t\t            ri->remote_port,\n\t\t            eol,\n\t\t            eol,\n\t\t            conn->handled_requests,\n\t\t            eol,\n\t\t            eol);\n\n\t\tconnection_info_length += (int)strlen(block);\n\t\tif (connection_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Request info */\n\tif ((state >= 4) && (state < 6)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"request_info\\\" : {%s\"\n\t\t            \"\\\"method\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"uri\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"query\\\" : %s%s%s%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            ri->request_method,\n\t\t            eol,\n\t\t            ri->request_uri,\n\t\t            eol,\n\t\t            ri->query_string ? \"\\\"\" : \"\",\n\t\t            ri->query_string ? ri->query_string : \"null\",\n\t\t            ri->query_string ? \"\\\"\" : \"\",\n\t\t            eol,\n\t\t            eol);\n\n\t\tconnection_info_length += (int)strlen(block);\n\t\tif (connection_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Execution time information */\n\tif ((state >= 2) && (state < 9)) {\n\t\tchar start_time_str[64] = {0};\n\t\tchar now_str[64] = {0};\n\t\ttime_t start_time = conn->conn_birth_time;\n\t\ttime_t now = time(NULL);\n\n\t\tgmt_time_string(start_time_str,\n\t\t                sizeof(start_time_str) - 1,\n\t\t                &start_time);\n\t\tgmt_time_string(now_str, sizeof(now_str) - 1, &now);\n\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"time\\\" : {%s\"\n\t\t            \"\\\"uptime\\\" : %.0f,%s\"\n\t\t            \"\\\"start\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"now\\\" : \\\"%s\\\"%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            difftime(now, start_time),\n\t\t            eol,\n\t\t            start_time_str,\n\t\t            eol,\n\t\t            now_str,\n\t\t            eol,\n\t\t            eol);\n\n\t\tconnection_info_length += (int)strlen(block);\n\t\tif (connection_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Remote user name */\n\tif ((ri->remote_user) && (state < 9)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"user\\\" : {%s\"\n\t\t            \"\\\"name\\\" : \\\"%s\\\",%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            ri->remote_user,\n\t\t            eol,\n\t\t            eol);\n\n\t\tconnection_info_length += (int)strlen(block);\n\t\tif (connection_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Data block */\n\tif (state >= 3) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"data\\\" : {%s\"\n\t\t            \"\\\"read\\\" : %\" INT64_FMT \",%s\"\n\t\t            \"\\\"written\\\" : %\" INT64_FMT \"%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            conn->consumed_content,\n\t\t            eol,\n\t\t            conn->num_bytes_sent,\n\t\t            eol,\n\t\t            eol);\n\n\t\tconnection_info_length += (int)strlen(block);\n\t\tif (connection_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* State */\n\tmg_snprintf(NULL,\n\t            NULL,\n\t            block,\n\t            sizeof(block),\n\t            \"\\\"state\\\" : \\\"%s\\\"%s\",\n\t            state_str,\n\t            eol);\n\n\tconnection_info_length += (int)strlen(block);\n\tif (connection_info_length + reserved_len < buflen) {\n\t\tstrcat0(buffer, block);\n\t}\n\n\t/* Terminate string */\n\tif ((buflen > 0) && buffer && buffer[0]) {\n\t\tif (connection_info_length < buflen) {\n\t\t\tstrcat0(buffer, eoobj);\n\t\t\tstrcat0(buffer, eol);\n\t\t}\n\t}\n\tconnection_info_length += reserved_len;\n\n\treturn connection_info_length;\n}\n#endif\n\n\n/* Get system information. It can be printed or stored by the caller.\n * Return the size of available information. */\nint\nmg_get_system_info(char *buffer, int buflen)\n{\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\treturn mg_get_system_info_impl(NULL, 0);\n\t} else {\n\t\t/* Reset buffer, so we can always use strcat. */\n\t\tbuffer[0] = 0;\n\t\treturn mg_get_system_info_impl(buffer, buflen);\n\t}\n}\n\n\n/* Get context information. It can be printed or stored by the caller.\n * Return the size of available information. */\nint\nmg_get_context_info(const struct mg_context *ctx, char *buffer, int buflen)\n{\n#if defined(USE_SERVER_STATS)\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\treturn mg_get_context_info_impl(ctx, NULL, 0);\n\t} else {\n\t\t/* Reset buffer, so we can always use strcat. */\n\t\tbuffer[0] = 0;\n\t\treturn mg_get_context_info_impl(ctx, buffer, buflen);\n\t}\n#else\n\t(void)ctx;\n\tif ((buffer != NULL) && (buflen > 0)) {\n\t\tbuffer[0] = 0;\n\t}\n\treturn 0;\n#endif\n}\n\n\n#if defined(MG_EXPERIMENTAL_INTERFACES)\nint\nmg_get_connection_info(const struct mg_context *ctx,\n                       int idx,\n                       char *buffer,\n                       int buflen)\n{\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\treturn mg_get_connection_info_impl(ctx, idx, NULL, 0);\n\t} else {\n\t\t/* Reset buffer, so we can always use strcat. */\n\t\tbuffer[0] = 0;\n\t\treturn mg_get_connection_info_impl(ctx, idx, buffer, buflen);\n\t}\n}\n#endif\n\n\n/* Initialize this library. This function does not need to be thread safe.\n */\nunsigned\nmg_init_library(unsigned features)\n{\n#if !defined(NO_SSL)\n\tchar ebuf[128];\n#endif\n\n\tunsigned features_to_init = mg_check_feature(features & 0xFFu);\n\tunsigned features_inited = features_to_init;\n\n\tif (mg_init_library_called <= 0) {\n\t\t/* Not initialized yet */\n\t\tif (0 != pthread_mutex_init(&global_lock_mutex, NULL)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tmg_global_lock();\n\n\tif (mg_init_library_called <= 0) {\n\t\tif (0 != pthread_key_create(&sTlsKey, tls_dtor)) {\n\t\t\t/* Fatal error - abort start. However, this situation should\n\t\t\t * never occur in practice. */\n\t\t\tmg_global_unlock();\n\t\t\treturn 0;\n\t\t}\n\n#if defined(_WIN32)\n\t\tInitializeCriticalSection(&global_log_file_lock);\n#endif\n#if !defined(_WIN32)\n\t\tpthread_mutexattr_init(&pthread_mutex_attr);\n\t\tpthread_mutexattr_settype(&pthread_mutex_attr, PTHREAD_MUTEX_RECURSIVE);\n#endif\n\n#if defined(USE_LUA)\n\t\tlua_init_optional_libraries();\n#endif\n\t}\n\n\tmg_global_unlock();\n\n#if !defined(NO_SSL)\n\tif (features_to_init & MG_FEATURES_SSL) {\n\t\tif (!mg_ssl_initialized) {\n\t\t\tif (initialize_ssl(ebuf, sizeof(ebuf))) {\n\t\t\t\tmg_ssl_initialized = 1;\n\t\t\t} else {\n\t\t\t\t(void)ebuf;\n\t\t\t\tDEBUG_TRACE(\"Initializing SSL failed: %s\", ebuf);\n\t\t\t\tfeatures_inited &= ~((unsigned)(MG_FEATURES_SSL));\n\t\t\t}\n\t\t} else {\n\t\t\t/* ssl already initialized */\n\t\t}\n\t}\n#endif\n\n\t/* Start WinSock for Windows */\n\tmg_global_lock();\n\tif (mg_init_library_called <= 0) {\n#if defined(_WIN32)\n\t\tWSADATA data;\n\t\tWSAStartup(MAKEWORD(2, 2), &data);\n#endif /* _WIN32 */\n\t\tmg_init_library_called = 1;\n\t} else {\n\t\tmg_init_library_called++;\n\t}\n\tmg_global_unlock();\n\n\treturn features_inited;\n}\n\n\n/* Un-initialize this library. */\nunsigned\nmg_exit_library(void)\n{\n\tif (mg_init_library_called <= 0) {\n\t\treturn 0;\n\t}\n\n\tmg_global_lock();\n\n\tmg_init_library_called--;\n\tif (mg_init_library_called == 0) {\n#if defined(_WIN32)\n\t\t(void)WSACleanup();\n#endif /* _WIN32  */\n#if !defined(NO_SSL)\n\t\tif (mg_ssl_initialized) {\n\t\t\tuninitialize_ssl();\n\t\t\tmg_ssl_initialized = 0;\n\t\t}\n#endif\n\n#if defined(_WIN32)\n\t\t(void)DeleteCriticalSection(&global_log_file_lock);\n#endif /* _WIN32 */\n#if !defined(_WIN32)\n\t\t(void)pthread_mutexattr_destroy(&pthread_mutex_attr);\n#endif\n\n\t\t(void)pthread_key_delete(sTlsKey);\n\n#if defined(USE_LUA)\n\t\tlua_exit_optional_libraries();\n#endif\n\n\t\tmg_global_unlock();\n\t\t(void)pthread_mutex_destroy(&global_lock_mutex);\n\t\treturn 1;\n\t}\n\n\tmg_global_unlock();\n\treturn 1;\n}\n\n\n/* End of civetweb.c */\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf3d/glew/src/glew.c": "/*\n** The OpenGL Extension Wrangler Library\n** Copyright (C) 2002-2008, Milan Ikits <milan ikits[]ieee org>\n** Copyright (C) 2002-2008, Marcelo E. Magallon <mmagallo[]debian org>\n** Copyright (C) 2002, Lev Povalahev\n** All rights reserved.\n**\n** Redistribution and use in source and binary forms, with or without\n** modification, are permitted provided that the following conditions are met:\n**\n** * Redistributions of source code must retain the above copyright notice,\n**   this list of conditions and the following disclaimer.\n** * Redistributions in binary form must reproduce the above copyright notice,\n**   this list of conditions and the following disclaimer in the documentation\n**   and/or other materials provided with the distribution.\n** * The name of the author may be used to endorse or promote products\n**   derived from this software without specific prior written permission.\n**\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n** AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n** ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n** LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n** THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* ROOT additions begin */\n#include \"RConfigure.h\"\n\n#define GLEW_BUILD\n\n#if defined(__APPLE__) && !defined(R__HAS_COCOA)\n#  define GLEW_APPLE_GLX\n#endif\n\n/* ROOT additions end */\n\n\n#include <GL/glew.h>\n\n#if defined(_WIN32)\n#  include <GL/wglew.h>\n#elif !defined(__APPLE__) || defined(GLEW_APPLE_GLX)\n#  include <GL/glxew.h>\n#endif\n\n\n/*\n * Define glewGetContext and related helper macros.\n */\n#ifdef GLEW_MX\n#  define glewGetContext() ctx\n#  ifdef _WIN32\n#    define GLEW_CONTEXT_ARG_DEF_INIT GLEWContext* ctx\n#    define GLEW_CONTEXT_ARG_VAR_INIT ctx\n#    define wglewGetContext() ctx\n#    define WGLEW_CONTEXT_ARG_DEF_INIT WGLEWContext* ctx\n#    define WGLEW_CONTEXT_ARG_DEF_LIST WGLEWContext* ctx\n#  else /* _WIN32 */\n#    define GLEW_CONTEXT_ARG_DEF_INIT void\n#    define GLEW_CONTEXT_ARG_VAR_INIT\n#    define glxewGetContext() ctx\n#    define GLXEW_CONTEXT_ARG_DEF_INIT void\n#    define GLXEW_CONTEXT_ARG_DEF_LIST GLXEWContext* ctx\n#  endif /* _WIN32 */\n#  define GLEW_CONTEXT_ARG_DEF_LIST GLEWContext* ctx\n#else /* GLEW_MX */\n#  define GLEW_CONTEXT_ARG_DEF_INIT void\n#  define GLEW_CONTEXT_ARG_VAR_INIT\n#  define GLEW_CONTEXT_ARG_DEF_LIST void\n#  define WGLEW_CONTEXT_ARG_DEF_INIT void\n#  define WGLEW_CONTEXT_ARG_DEF_LIST void\n#  define GLXEW_CONTEXT_ARG_DEF_INIT void\n#  define GLXEW_CONTEXT_ARG_DEF_LIST void\n#endif /* GLEW_MX */\n\n#if defined(__APPLE__)\n#include <AvailabilityMacros.h>\n#if !defined(MAC_OS_X_VERSION_10_3) || (MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3)\n#define USE_APPLE_LEGACY_NSSYMBOL\n#include <mach-o/dyld.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid* NSGLGetProcAddress (const GLubyte *name)\n{\n  static const struct mach_header* image = NULL;\n  NSSymbol symbol;\n  char* symbolName;\n  if (NULL == image)\n  {\n    image = NSAddImage(\"/System/Library/Frameworks/OpenGL.framework/Versions/Current/OpenGL\", NSADDIMAGE_OPTION_RETURN_ON_ERROR);\n  }\n  /* prepend a '_' for the Unix C symbol mangling convention */\n  symbolName = malloc(strlen((const char*)name) + 2);\n  strcpy(symbolName+1, (const char*)name);\n  symbolName[0] = '_';\n  symbol = NULL;\n  /* if (NSIsSymbolNameDefined(symbolName))\n   symbol = NSLookupAndBindSymbol(symbolName); */\n  symbol = image ? NSLookupSymbolInImage(image, symbolName, NSLOOKUPSYMBOLINIMAGE_OPTION_BIND | NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR) : NULL;\n  free(symbolName);\n  return symbol ? NSAddressOfSymbol(symbol) : NULL;\n}\n#endif /* MAC_OS_X_VERSION_10_3 */\n#endif /* __APPLE__ */\n\n#if defined(__sgi) || defined (__sun) || (defined(__APPLE__) && !defined(USE_APPLE_LEGACY_NSSYMBOL))\n#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid* dlGetProcAddress (const GLubyte* name)\n{\n  static void* h = NULL;\n  static void* gpa;\n\n  if (h == NULL)\n  {\n    if ((h = dlopen(NULL, RTLD_LAZY | RTLD_LOCAL)) == NULL) return NULL;\n    gpa = dlsym(h, \"glXGetProcAddress\");\n  }\n\n  if (gpa != NULL)\n    return ((void*(*)(const GLubyte*))gpa)(name);\n  else\n    return dlsym(h, (const char*)name);\n}\n#endif /* __sgi || __sun || __APPLE__ && !USE_APPLE_LEGACY_NSSYMBOL */\n\n/*\n * Define glewGetProcAddress.\n */\n#if defined(_WIN32)\n#  define glewGetProcAddress(name) wglGetProcAddress((LPCSTR)name)\n#else\n#  if defined(__APPLE__)\n#    if defined USE_APPLE_LEGACY_NSSYMBOL\n#      define glewGetProcAddress(name) NSGLGetProcAddress(name)\n#    else\n#      define glewGetProcAddress(name) dlGetProcAddress(name)\n#    endif\n#  else\n#    if defined(__sgi) || defined(__sun)\n#      define glewGetProcAddress(name) dlGetProcAddress(name)\n#    else /* __linux */\n#      define glewGetProcAddress(name) (*glXGetProcAddressARB)(name)\n#    endif\n#  endif\n#endif\n\n/*\n * Define GLboolean const cast.\n */\n#define CONST_CAST(x) (*(GLboolean*)&x)\n\n/*\n * GLEW, just like OpenGL or GLU, does not rely on the standard C library.\n * These functions implement the functionality required in this file.\n */\nstatic GLuint _glewStrLen (const GLubyte* s)\n{\n  GLuint i=0;\n  if (s == NULL) return 0;\n  while (s[i] != '\\0') i++;\n  return i;\n}\n\nstatic GLuint _glewStrCLen (const GLubyte* s, GLubyte c)\n{\n  GLuint i=0;\n  if (s == NULL) return 0;\n  while (s[i] != '\\0' && s[i] != c) i++;\n  return (s[i] == '\\0' || s[i] == c) ? i : 0;\n}\n\nstatic GLboolean _glewStrSame (const GLubyte* a, const GLubyte* b, GLuint n)\n{\n  GLuint i=0;\n  if(a == NULL || b == NULL)\n    return (a == NULL && b == NULL && n == 0) ? GL_TRUE : GL_FALSE;\n  while (i < n && a[i] != '\\0' && b[i] != '\\0' && a[i] == b[i]) i++;\n  return i == n ? GL_TRUE : GL_FALSE;\n}\n\nstatic GLboolean _glewStrSame1 (GLubyte** a, GLuint* na, const GLubyte* b, GLuint nb)\n{\n  while (*na > 0 && (**a == ' ' || **a == '\\n' || **a == '\\r' || **a == '\\t'))\n  {\n    (*a)++;\n    (*na)--;\n  }\n  if(*na >= nb)\n  {\n    GLuint i=0;\n    while (i < nb && (*a)+i != NULL && b+i != NULL && (*a)[i] == b[i]) i++;\n     if(i == nb)\n     {\n        *a = *a + nb;\n        *na = *na - nb;\n        return GL_TRUE;\n     }\n  }\n  return GL_FALSE;\n}\n\nstatic GLboolean _glewStrSame2 (GLubyte** a, GLuint* na, const GLubyte* b, GLuint nb)\n{\n  if(*na >= nb)\n  {\n    GLuint i=0;\n    while (i < nb && (*a)+i != NULL && b+i != NULL && (*a)[i] == b[i]) i++;\n     if(i == nb)\n     {\n        *a = *a + nb;\n        *na = *na - nb;\n        return GL_TRUE;\n     }\n  }\n  return GL_FALSE;\n}\n\nstatic GLboolean _glewStrSame3 (GLubyte** a, GLuint* na, const GLubyte* b, GLuint nb)\n{\n  if(*na >= nb)\n  {\n    GLuint i=0;\n    while (i < nb && (*a)+i != NULL && b+i != NULL && (*a)[i] == b[i]) i++;\n    if (i == nb && (*na == nb || (*a)[i] == ' ' || (*a)[i] == '\\n' || (*a)[i] == '\\r' || (*a)[i] == '\\t'))\n    {\n      *a = *a + nb;\n      *na = *na - nb;\n      return GL_TRUE;\n    }\n  }\n  return GL_FALSE;\n}\n\n#if !defined(_WIN32) || !defined(GLEW_MX)\n\nPFNGLCOPYTEXSUBIMAGE3DPROC __glewCopyTexSubImage3D = NULL;\nPFNGLDRAWRANGEELEMENTSPROC __glewDrawRangeElements = NULL;\nPFNGLTEXIMAGE3DPROC __glewTexImage3D = NULL;\nPFNGLTEXSUBIMAGE3DPROC __glewTexSubImage3D = NULL;\n\nPFNGLACTIVETEXTUREPROC __glewActiveTexture = NULL;\nPFNGLCLIENTACTIVETEXTUREPROC __glewClientActiveTexture = NULL;\nPFNGLCOMPRESSEDTEXIMAGE1DPROC __glewCompressedTexImage1D = NULL;\nPFNGLCOMPRESSEDTEXIMAGE2DPROC __glewCompressedTexImage2D = NULL;\nPFNGLCOMPRESSEDTEXIMAGE3DPROC __glewCompressedTexImage3D = NULL;\nPFNGLCOMPRESSEDTEXSUBIMAGE1DPROC __glewCompressedTexSubImage1D = NULL;\nPFNGLCOMPRESSEDTEXSUBIMAGE2DPROC __glewCompressedTexSubImage2D = NULL;\nPFNGLCOMPRESSEDTEXSUBIMAGE3DPROC __glewCompressedTexSubImage3D = NULL;\nPFNGLGETCOMPRESSEDTEXIMAGEPROC __glewGetCompressedTexImage = NULL;\nPFNGLLOADTRANSPOSEMATRIXDPROC __glewLoadTransposeMatrixd = NULL;\nPFNGLLOADTRANSPOSEMATRIXFPROC __glewLoadTransposeMatrixf = NULL;\nPFNGLMULTTRANSPOSEMATRIXDPROC __glewMultTransposeMatrixd = NULL;\nPFNGLMULTTRANSPOSEMATRIXFPROC __glewMultTransposeMatrixf = NULL;\nPFNGLMULTITEXCOORD1DPROC __glewMultiTexCoord1d = NULL;\nPFNGLMULTITEXCOORD1DVPROC __glewMultiTexCoord1dv = NULL;\nPFNGLMULTITEXCOORD1FPROC __glewMultiTexCoord1f = NULL;\nPFNGLMULTITEXCOORD1FVPROC __glewMultiTexCoord1fv = NULL;\nPFNGLMULTITEXCOORD1IPROC __glewMultiTexCoord1i = NULL;\nPFNGLMULTITEXCOORD1IVPROC __glewMultiTexCoord1iv = NULL;\nPFNGLMULTITEXCOORD1SPROC __glewMultiTexCoord1s = NULL;\nPFNGLMULTITEXCOORD1SVPROC __glewMultiTexCoord1sv = NULL;\nPFNGLMULTITEXCOORD2DPROC __glewMultiTexCoord2d = NULL;\nPFNGLMULTITEXCOORD2DVPROC __glewMultiTexCoord2dv = NULL;\nPFNGLMULTITEXCOORD2FPROC __glewMultiTexCoord2f = NULL;\nPFNGLMULTITEXCOORD2FVPROC __glewMultiTexCoord2fv = NULL;\nPFNGLMULTITEXCOORD2IPROC __glewMultiTexCoord2i = NULL;\nPFNGLMULTITEXCOORD2IVPROC __glewMultiTexCoord2iv = NULL;\nPFNGLMULTITEXCOORD2SPROC __glewMultiTexCoord2s = NULL;\nPFNGLMULTITEXCOORD2SVPROC __glewMultiTexCoord2sv = NULL;\nPFNGLMULTITEXCOORD3DPROC __glewMultiTexCoord3d = NULL;\nPFNGLMULTITEXCOORD3DVPROC __glewMultiTexCoord3dv = NULL;\nPFNGLMULTITEXCOORD3FPROC __glewMultiTexCoord3f = NULL;\nPFNGLMULTITEXCOORD3FVPROC __glewMultiTexCoord3fv = NULL;\nPFNGLMULTITEXCOORD3IPROC __glewMultiTexCoord3i = NULL;\nPFNGLMULTITEXCOORD3IVPROC __glewMultiTexCoord3iv = NULL;\nPFNGLMULTITEXCOORD3SPROC __glewMultiTexCoord3s = NULL;\nPFNGLMULTITEXCOORD3SVPROC __glewMultiTexCoord3sv = NULL;\nPFNGLMULTITEXCOORD4DPROC __glewMultiTexCoord4d = NULL;\nPFNGLMULTITEXCOORD4DVPROC __glewMultiTexCoord4dv = NULL;\nPFNGLMULTITEXCOORD4FPROC __glewMultiTexCoord4f = NULL;\nPFNGLMULTITEXCOORD4FVPROC __glewMultiTexCoord4fv = NULL;\nPFNGLMULTITEXCOORD4IPROC __glewMultiTexCoord4i = NULL;\nPFNGLMULTITEXCOORD4IVPROC __glewMultiTexCoord4iv = NULL;\nPFNGLMULTITEXCOORD4SPROC __glewMultiTexCoord4s = NULL;\nPFNGLMULTITEXCOORD4SVPROC __glewMultiTexCoord4sv = NULL;\nPFNGLSAMPLECOVERAGEPROC __glewSampleCoverage = NULL;\n\nPFNGLBLENDCOLORPROC __glewBlendColor = NULL;\nPFNGLBLENDEQUATIONPROC __glewBlendEquation = NULL;\nPFNGLBLENDFUNCSEPARATEPROC __glewBlendFuncSeparate = NULL;\nPFNGLFOGCOORDPOINTERPROC __glewFogCoordPointer = NULL;\nPFNGLFOGCOORDDPROC __glewFogCoordd = NULL;\nPFNGLFOGCOORDDVPROC __glewFogCoorddv = NULL;\nPFNGLFOGCOORDFPROC __glewFogCoordf = NULL;\nPFNGLFOGCOORDFVPROC __glewFogCoordfv = NULL;\nPFNGLMULTIDRAWARRAYSPROC __glewMultiDrawArrays = NULL;\nPFNGLMULTIDRAWELEMENTSPROC __glewMultiDrawElements = NULL;\nPFNGLPOINTPARAMETERFPROC __glewPointParameterf = NULL;\nPFNGLPOINTPARAMETERFVPROC __glewPointParameterfv = NULL;\nPFNGLPOINTPARAMETERIPROC __glewPointParameteri = NULL;\nPFNGLPOINTPARAMETERIVPROC __glewPointParameteriv = NULL;\nPFNGLSECONDARYCOLOR3BPROC __glewSecondaryColor3b = NULL;\nPFNGLSECONDARYCOLOR3BVPROC __glewSecondaryColor3bv = NULL;\nPFNGLSECONDARYCOLOR3DPROC __glewSecondaryColor3d = NULL;\nPFNGLSECONDARYCOLOR3DVPROC __glewSecondaryColor3dv = NULL;\nPFNGLSECONDARYCOLOR3FPROC __glewSecondaryColor3f = NULL;\nPFNGLSECONDARYCOLOR3FVPROC __glewSecondaryColor3fv = NULL;\nPFNGLSECONDARYCOLOR3IPROC __glewSecondaryColor3i = NULL;\nPFNGLSECONDARYCOLOR3IVPROC __glewSecondaryColor3iv = NULL;\nPFNGLSECONDARYCOLOR3SPROC __glewSecondaryColor3s = NULL;\nPFNGLSECONDARYCOLOR3SVPROC __glewSecondaryColor3sv = NULL;\nPFNGLSECONDARYCOLOR3UBPROC __glewSecondaryColor3ub = NULL;\nPFNGLSECONDARYCOLOR3UBVPROC __glewSecondaryColor3ubv = NULL;\nPFNGLSECONDARYCOLOR3UIPROC __glewSecondaryColor3ui = NULL;\nPFNGLSECONDARYCOLOR3UIVPROC __glewSecondaryColor3uiv = NULL;\nPFNGLSECONDARYCOLOR3USPROC __glewSecondaryColor3us = NULL;\nPFNGLSECONDARYCOLOR3USVPROC __glewSecondaryColor3usv = NULL;\nPFNGLSECONDARYCOLORPOINTERPROC __glewSecondaryColorPointer = NULL;\nPFNGLWINDOWPOS2DPROC __glewWindowPos2d = NULL;\nPFNGLWINDOWPOS2DVPROC __glewWindowPos2dv = NULL;\nPFNGLWINDOWPOS2FPROC __glewWindowPos2f = NULL;\nPFNGLWINDOWPOS2FVPROC __glewWindowPos2fv = NULL;\nPFNGLWINDOWPOS2IPROC __glewWindowPos2i = NULL;\nPFNGLWINDOWPOS2IVPROC __glewWindowPos2iv = NULL;\nPFNGLWINDOWPOS2SPROC __glewWindowPos2s = NULL;\nPFNGLWINDOWPOS2SVPROC __glewWindowPos2sv = NULL;\nPFNGLWINDOWPOS3DPROC __glewWindowPos3d = NULL;\nPFNGLWINDOWPOS3DVPROC __glewWindowPos3dv = NULL;\nPFNGLWINDOWPOS3FPROC __glewWindowPos3f = NULL;\nPFNGLWINDOWPOS3FVPROC __glewWindowPos3fv = NULL;\nPFNGLWINDOWPOS3IPROC __glewWindowPos3i = NULL;\nPFNGLWINDOWPOS3IVPROC __glewWindowPos3iv = NULL;\nPFNGLWINDOWPOS3SPROC __glewWindowPos3s = NULL;\nPFNGLWINDOWPOS3SVPROC __glewWindowPos3sv = NULL;\n\nPFNGLBEGINQUERYPROC __glewBeginQuery = NULL;\nPFNGLBINDBUFFERPROC __glewBindBuffer = NULL;\nPFNGLBUFFERDATAPROC __glewBufferData = NULL;\nPFNGLBUFFERSUBDATAPROC __glewBufferSubData = NULL;\nPFNGLDELETEBUFFERSPROC __glewDeleteBuffers = NULL;\nPFNGLDELETEQUERIESPROC __glewDeleteQueries = NULL;\nPFNGLENDQUERYPROC __glewEndQuery = NULL;\nPFNGLGENBUFFERSPROC __glewGenBuffers = NULL;\nPFNGLGENQUERIESPROC __glewGenQueries = NULL;\nPFNGLGETBUFFERPARAMETERIVPROC __glewGetBufferParameteriv = NULL;\nPFNGLGETBUFFERPOINTERVPROC __glewGetBufferPointerv = NULL;\nPFNGLGETBUFFERSUBDATAPROC __glewGetBufferSubData = NULL;\nPFNGLGETQUERYOBJECTIVPROC __glewGetQueryObjectiv = NULL;\nPFNGLGETQUERYOBJECTUIVPROC __glewGetQueryObjectuiv = NULL;\nPFNGLGETQUERYIVPROC __glewGetQueryiv = NULL;\nPFNGLISBUFFERPROC __glewIsBuffer = NULL;\nPFNGLISQUERYPROC __glewIsQuery = NULL;\nPFNGLMAPBUFFERPROC __glewMapBuffer = NULL;\nPFNGLUNMAPBUFFERPROC __glewUnmapBuffer = NULL;\n\nPFNGLATTACHSHADERPROC __glewAttachShader = NULL;\nPFNGLBINDATTRIBLOCATIONPROC __glewBindAttribLocation = NULL;\nPFNGLBLENDEQUATIONSEPARATEPROC __glewBlendEquationSeparate = NULL;\nPFNGLCOMPILESHADERPROC __glewCompileShader = NULL;\nPFNGLCREATEPROGRAMPROC __glewCreateProgram = NULL;\nPFNGLCREATESHADERPROC __glewCreateShader = NULL;\nPFNGLDELETEPROGRAMPROC __glewDeleteProgram = NULL;\nPFNGLDELETESHADERPROC __glewDeleteShader = NULL;\nPFNGLDETACHSHADERPROC __glewDetachShader = NULL;\nPFNGLDISABLEVERTEXATTRIBARRAYPROC __glewDisableVertexAttribArray = NULL;\nPFNGLDRAWBUFFERSPROC __glewDrawBuffers = NULL;\nPFNGLENABLEVERTEXATTRIBARRAYPROC __glewEnableVertexAttribArray = NULL;\nPFNGLGETACTIVEATTRIBPROC __glewGetActiveAttrib = NULL;\nPFNGLGETACTIVEUNIFORMPROC __glewGetActiveUniform = NULL;\nPFNGLGETATTACHEDSHADERSPROC __glewGetAttachedShaders = NULL;\nPFNGLGETATTRIBLOCATIONPROC __glewGetAttribLocation = NULL;\nPFNGLGETPROGRAMINFOLOGPROC __glewGetProgramInfoLog = NULL;\nPFNGLGETPROGRAMIVPROC __glewGetProgramiv = NULL;\nPFNGLGETSHADERINFOLOGPROC __glewGetShaderInfoLog = NULL;\nPFNGLGETSHADERSOURCEPROC __glewGetShaderSource = NULL;\nPFNGLGETSHADERIVPROC __glewGetShaderiv = NULL;\nPFNGLGETUNIFORMLOCATIONPROC __glewGetUniformLocation = NULL;\nPFNGLGETUNIFORMFVPROC __glewGetUniformfv = NULL;\nPFNGLGETUNIFORMIVPROC __glewGetUniformiv = NULL;\nPFNGLGETVERTEXATTRIBPOINTERVPROC __glewGetVertexAttribPointerv = NULL;\nPFNGLGETVERTEXATTRIBDVPROC __glewGetVertexAttribdv = NULL;\nPFNGLGETVERTEXATTRIBFVPROC __glewGetVertexAttribfv = NULL;\nPFNGLGETVERTEXATTRIBIVPROC __glewGetVertexAttribiv = NULL;\nPFNGLISPROGRAMPROC __glewIsProgram = NULL;\nPFNGLISSHADERPROC __glewIsShader = NULL;\nPFNGLLINKPROGRAMPROC __glewLinkProgram = NULL;\nPFNGLSHADERSOURCEPROC __glewShaderSource = NULL;\nPFNGLSTENCILFUNCSEPARATEPROC __glewStencilFuncSeparate = NULL;\nPFNGLSTENCILMASKSEPARATEPROC __glewStencilMaskSeparate = NULL;\nPFNGLSTENCILOPSEPARATEPROC __glewStencilOpSeparate = NULL;\nPFNGLUNIFORM1FPROC __glewUniform1f = NULL;\nPFNGLUNIFORM1FVPROC __glewUniform1fv = NULL;\nPFNGLUNIFORM1IPROC __glewUniform1i = NULL;\nPFNGLUNIFORM1IVPROC __glewUniform1iv = NULL;\nPFNGLUNIFORM2FPROC __glewUniform2f = NULL;\nPFNGLUNIFORM2FVPROC __glewUniform2fv = NULL;\nPFNGLUNIFORM2IPROC __glewUniform2i = NULL;\nPFNGLUNIFORM2IVPROC __glewUniform2iv = NULL;\nPFNGLUNIFORM3FPROC __glewUniform3f = NULL;\nPFNGLUNIFORM3FVPROC __glewUniform3fv = NULL;\nPFNGLUNIFORM3IPROC __glewUniform3i = NULL;\nPFNGLUNIFORM3IVPROC __glewUniform3iv = NULL;\nPFNGLUNIFORM4FPROC __glewUniform4f = NULL;\nPFNGLUNIFORM4FVPROC __glewUniform4fv = NULL;\nPFNGLUNIFORM4IPROC __glewUniform4i = NULL;\nPFNGLUNIFORM4IVPROC __glewUniform4iv = NULL;\nPFNGLUNIFORMMATRIX2FVPROC __glewUniformMatrix2fv = NULL;\nPFNGLUNIFORMMATRIX3FVPROC __glewUniformMatrix3fv = NULL;\nPFNGLUNIFORMMATRIX4FVPROC __glewUniformMatrix4fv = NULL;\nPFNGLUSEPROGRAMPROC __glewUseProgram = NULL;\nPFNGLVALIDATEPROGRAMPROC __glewValidateProgram = NULL;\nPFNGLVERTEXATTRIB1DPROC __glewVertexAttrib1d = NULL;\nPFNGLVERTEXATTRIB1DVPROC __glewVertexAttrib1dv = NULL;\nPFNGLVERTEXATTRIB1FPROC __glewVertexAttrib1f = NULL;\nPFNGLVERTEXATTRIB1FVPROC __glewVertexAttrib1fv = NULL;\nPFNGLVERTEXATTRIB1SPROC __glewVertexAttrib1s = NULL;\nPFNGLVERTEXATTRIB1SVPROC __glewVertexAttrib1sv = NULL;\nPFNGLVERTEXATTRIB2DPROC __glewVertexAttrib2d = NULL;\nPFNGLVERTEXATTRIB2DVPROC __glewVertexAttrib2dv = NULL;\nPFNGLVERTEXATTRIB2FPROC __glewVertexAttrib2f = NULL;\nPFNGLVERTEXATTRIB2FVPROC __glewVertexAttrib2fv = NULL;\nPFNGLVERTEXATTRIB2SPROC __glewVertexAttrib2s = NULL;\nPFNGLVERTEXATTRIB2SVPROC __glewVertexAttrib2sv = NULL;\nPFNGLVERTEXATTRIB3DPROC __glewVertexAttrib3d = NULL;\nPFNGLVERTEXATTRIB3DVPROC __glewVertexAttrib3dv = NULL;\nPFNGLVERTEXATTRIB3FPROC __glewVertexAttrib3f = NULL;\nPFNGLVERTEXATTRIB3FVPROC __glewVertexAttrib3fv = NULL;\nPFNGLVERTEXATTRIB3SPROC __glewVertexAttrib3s = NULL;\nPFNGLVERTEXATTRIB3SVPROC __glewVertexAttrib3sv = NULL;\nPFNGLVERTEXATTRIB4NBVPROC __glewVertexAttrib4Nbv = NULL;\nPFNGLVERTEXATTRIB4NIVPROC __glewVertexAttrib4Niv = NULL;\nPFNGLVERTEXATTRIB4NSVPROC __glewVertexAttrib4Nsv = NULL;\nPFNGLVERTEXATTRIB4NUBPROC __glewVertexAttrib4Nub = NULL;\nPFNGLVERTEXATTRIB4NUBVPROC __glewVertexAttrib4Nubv = NULL;\nPFNGLVERTEXATTRIB4NUIVPROC __glewVertexAttrib4Nuiv = NULL;\nPFNGLVERTEXATTRIB4NUSVPROC __glewVertexAttrib4Nusv = NULL;\nPFNGLVERTEXATTRIB4BVPROC __glewVertexAttrib4bv = NULL;\nPFNGLVERTEXATTRIB4DPROC __glewVertexAttrib4d = NULL;\nPFNGLVERTEXATTRIB4DVPROC __glewVertexAttrib4dv = NULL;\nPFNGLVERTEXATTRIB4FPROC __glewVertexAttrib4f = NULL;\nPFNGLVERTEXATTRIB4FVPROC __glewVertexAttrib4fv = NULL;\nPFNGLVERTEXATTRIB4IVPROC __glewVertexAttrib4iv = NULL;\nPFNGLVERTEXATTRIB4SPROC __glewVertexAttrib4s = NULL;\nPFNGLVERTEXATTRIB4SVPROC __glewVertexAttrib4sv = NULL;\nPFNGLVERTEXATTRIB4UBVPROC __glewVertexAttrib4ubv = NULL;\nPFNGLVERTEXATTRIB4UIVPROC __glewVertexAttrib4uiv = NULL;\nPFNGLVERTEXATTRIB4USVPROC __glewVertexAttrib4usv = NULL;\nPFNGLVERTEXATTRIBPOINTERPROC __glewVertexAttribPointer = NULL;\n\nPFNGLUNIFORMMATRIX2X3FVPROC __glewUniformMatrix2x3fv = NULL;\nPFNGLUNIFORMMATRIX2X4FVPROC __glewUniformMatrix2x4fv = NULL;\nPFNGLUNIFORMMATRIX3X2FVPROC __glewUniformMatrix3x2fv = NULL;\nPFNGLUNIFORMMATRIX3X4FVPROC __glewUniformMatrix3x4fv = NULL;\nPFNGLUNIFORMMATRIX4X2FVPROC __glewUniformMatrix4x2fv = NULL;\nPFNGLUNIFORMMATRIX4X3FVPROC __glewUniformMatrix4x3fv = NULL;\n\nPFNGLBEGINCONDITIONALRENDERPROC __glewBeginConditionalRender = NULL;\nPFNGLBEGINTRANSFORMFEEDBACKPROC __glewBeginTransformFeedback = NULL;\nPFNGLBINDBUFFERBASEPROC __glewBindBufferBase = NULL;\nPFNGLBINDBUFFERRANGEPROC __glewBindBufferRange = NULL;\nPFNGLBINDFRAGDATALOCATIONPROC __glewBindFragDataLocation = NULL;\nPFNGLCLAMPCOLORPROC __glewClampColor = NULL;\nPFNGLCLEARBUFFERFIPROC __glewClearBufferfi = NULL;\nPFNGLCLEARBUFFERFVPROC __glewClearBufferfv = NULL;\nPFNGLCLEARBUFFERIVPROC __glewClearBufferiv = NULL;\nPFNGLCLEARBUFFERUIVPROC __glewClearBufferuiv = NULL;\nPFNGLCOLORMASKIPROC __glewColorMaski = NULL;\nPFNGLDISABLEIPROC __glewDisablei = NULL;\nPFNGLENABLEIPROC __glewEnablei = NULL;\nPFNGLENDCONDITIONALRENDERPROC __glewEndConditionalRender = NULL;\nPFNGLENDTRANSFORMFEEDBACKPROC __glewEndTransformFeedback = NULL;\nPFNGLGETBOOLEANI_VPROC __glewGetBooleani_v = NULL;\nPFNGLGETFRAGDATALOCATIONPROC __glewGetFragDataLocation = NULL;\nPFNGLGETINTEGERI_VPROC __glewGetIntegeri_v = NULL;\nPFNGLGETSTRINGIPROC __glewGetStringi = NULL;\nPFNGLGETTEXPARAMETERIIVPROC __glewGetTexParameterIiv = NULL;\nPFNGLGETTEXPARAMETERIUIVPROC __glewGetTexParameterIuiv = NULL;\nPFNGLGETTRANSFORMFEEDBACKVARYINGPROC __glewGetTransformFeedbackVarying = NULL;\nPFNGLGETUNIFORMUIVPROC __glewGetUniformuiv = NULL;\nPFNGLGETVERTEXATTRIBIIVPROC __glewGetVertexAttribIiv = NULL;\nPFNGLGETVERTEXATTRIBIUIVPROC __glewGetVertexAttribIuiv = NULL;\nPFNGLISENABLEDIPROC __glewIsEnabledi = NULL;\nPFNGLTEXPARAMETERIIVPROC __glewTexParameterIiv = NULL;\nPFNGLTEXPARAMETERIUIVPROC __glewTexParameterIuiv = NULL;\nPFNGLTRANSFORMFEEDBACKVARYINGSPROC __glewTransformFeedbackVaryings = NULL;\nPFNGLUNIFORM1UIPROC __glewUniform1ui = NULL;\nPFNGLUNIFORM1UIVPROC __glewUniform1uiv = NULL;\nPFNGLUNIFORM2UIPROC __glewUniform2ui = NULL;\nPFNGLUNIFORM2UIVPROC __glewUniform2uiv = NULL;\nPFNGLUNIFORM3UIPROC __glewUniform3ui = NULL;\nPFNGLUNIFORM3UIVPROC __glewUniform3uiv = NULL;\nPFNGLUNIFORM4UIPROC __glewUniform4ui = NULL;\nPFNGLUNIFORM4UIVPROC __glewUniform4uiv = NULL;\nPFNGLVERTEXATTRIBI1IPROC __glewVertexAttribI1i = NULL;\nPFNGLVERTEXATTRIBI1IVPROC __glewVertexAttribI1iv = NULL;\nPFNGLVERTEXATTRIBI1UIPROC __glewVertexAttribI1ui = NULL;\nPFNGLVERTEXATTRIBI1UIVPROC __glewVertexAttribI1uiv = NULL;\nPFNGLVERTEXATTRIBI2IPROC __glewVertexAttribI2i = NULL;\nPFNGLVERTEXATTRIBI2IVPROC __glewVertexAttribI2iv = NULL;\nPFNGLVERTEXATTRIBI2UIPROC __glewVertexAttribI2ui = NULL;\nPFNGLVERTEXATTRIBI2UIVPROC __glewVertexAttribI2uiv = NULL;\nPFNGLVERTEXATTRIBI3IPROC __glewVertexAttribI3i = NULL;\nPFNGLVERTEXATTRIBI3IVPROC __glewVertexAttribI3iv = NULL;\nPFNGLVERTEXATTRIBI3UIPROC __glewVertexAttribI3ui = NULL;\nPFNGLVERTEXATTRIBI3UIVPROC __glewVertexAttribI3uiv = NULL;\nPFNGLVERTEXATTRIBI4BVPROC __glewVertexAttribI4bv = NULL;\nPFNGLVERTEXATTRIBI4IPROC __glewVertexAttribI4i = NULL;\nPFNGLVERTEXATTRIBI4IVPROC __glewVertexAttribI4iv = NULL;\nPFNGLVERTEXATTRIBI4SVPROC __glewVertexAttribI4sv = NULL;\nPFNGLVERTEXATTRIBI4UBVPROC __glewVertexAttribI4ubv = NULL;\nPFNGLVERTEXATTRIBI4UIPROC __glewVertexAttribI4ui = NULL;\nPFNGLVERTEXATTRIBI4UIVPROC __glewVertexAttribI4uiv = NULL;\nPFNGLVERTEXATTRIBI4USVPROC __glewVertexAttribI4usv = NULL;\nPFNGLVERTEXATTRIBIPOINTERPROC __glewVertexAttribIPointer = NULL;\n\nPFNGLTBUFFERMASK3DFXPROC __glewTbufferMask3DFX = NULL;\n\nPFNGLDRAWELEMENTARRAYAPPLEPROC __glewDrawElementArrayAPPLE = NULL;\nPFNGLDRAWRANGEELEMENTARRAYAPPLEPROC __glewDrawRangeElementArrayAPPLE = NULL;\nPFNGLELEMENTPOINTERAPPLEPROC __glewElementPointerAPPLE = NULL;\nPFNGLMULTIDRAWELEMENTARRAYAPPLEPROC __glewMultiDrawElementArrayAPPLE = NULL;\nPFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC __glewMultiDrawRangeElementArrayAPPLE = NULL;\n\nPFNGLDELETEFENCESAPPLEPROC __glewDeleteFencesAPPLE = NULL;\nPFNGLFINISHFENCEAPPLEPROC __glewFinishFenceAPPLE = NULL;\nPFNGLFINISHOBJECTAPPLEPROC __glewFinishObjectAPPLE = NULL;\nPFNGLGENFENCESAPPLEPROC __glewGenFencesAPPLE = NULL;\nPFNGLISFENCEAPPLEPROC __glewIsFenceAPPLE = NULL;\nPFNGLSETFENCEAPPLEPROC __glewSetFenceAPPLE = NULL;\nPFNGLTESTFENCEAPPLEPROC __glewTestFenceAPPLE = NULL;\nPFNGLTESTOBJECTAPPLEPROC __glewTestObjectAPPLE = NULL;\n\nPFNGLBUFFERPARAMETERIAPPLEPROC __glewBufferParameteriAPPLE = NULL;\nPFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC __glewFlushMappedBufferRangeAPPLE = NULL;\n\nPFNGLGETTEXPARAMETERPOINTERVAPPLEPROC __glewGetTexParameterPointervAPPLE = NULL;\nPFNGLTEXTURERANGEAPPLEPROC __glewTextureRangeAPPLE = NULL;\n\nPFNGLBINDVERTEXARRAYAPPLEPROC __glewBindVertexArrayAPPLE = NULL;\nPFNGLDELETEVERTEXARRAYSAPPLEPROC __glewDeleteVertexArraysAPPLE = NULL;\nPFNGLGENVERTEXARRAYSAPPLEPROC __glewGenVertexArraysAPPLE = NULL;\nPFNGLISVERTEXARRAYAPPLEPROC __glewIsVertexArrayAPPLE = NULL;\n\nPFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC __glewFlushVertexArrayRangeAPPLE = NULL;\nPFNGLVERTEXARRAYPARAMETERIAPPLEPROC __glewVertexArrayParameteriAPPLE = NULL;\nPFNGLVERTEXARRAYRANGEAPPLEPROC __glewVertexArrayRangeAPPLE = NULL;\n\nPFNGLCLAMPCOLORARBPROC __glewClampColorARB = NULL;\n\nPFNGLDRAWBUFFERSARBPROC __glewDrawBuffersARB = NULL;\n\nPFNGLDRAWARRAYSINSTANCEDARBPROC __glewDrawArraysInstancedARB = NULL;\nPFNGLDRAWELEMENTSINSTANCEDARBPROC __glewDrawElementsInstancedARB = NULL;\n\nPFNGLBINDFRAMEBUFFERPROC __glewBindFramebuffer = NULL;\nPFNGLBINDRENDERBUFFERPROC __glewBindRenderbuffer = NULL;\nPFNGLBLITFRAMEBUFFERPROC __glewBlitFramebuffer = NULL;\nPFNGLCHECKFRAMEBUFFERSTATUSPROC __glewCheckFramebufferStatus = NULL;\nPFNGLDELETEFRAMEBUFFERSPROC __glewDeleteFramebuffers = NULL;\nPFNGLDELETERENDERBUFFERSPROC __glewDeleteRenderbuffers = NULL;\nPFNGLFRAMEBUFFERRENDERBUFFERPROC __glewFramebufferRenderbuffer = NULL;\nPFNGLFRAMEBUFFERTEXTURELAYERPROC __glewFramebufferTextureLayer = NULL;\nPFNGLFRAMEBUFFERTEXTURE1DPROC __glewFramebufferTexture1D = NULL;\nPFNGLFRAMEBUFFERTEXTURE2DPROC __glewFramebufferTexture2D = NULL;\nPFNGLFRAMEBUFFERTEXTURE3DPROC __glewFramebufferTexture3D = NULL;\nPFNGLGENFRAMEBUFFERSPROC __glewGenFramebuffers = NULL;\nPFNGLGENRENDERBUFFERSPROC __glewGenRenderbuffers = NULL;\nPFNGLGENERATEMIPMAPPROC __glewGenerateMipmap = NULL;\nPFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC __glewGetFramebufferAttachmentParameteriv = NULL;\nPFNGLGETRENDERBUFFERPARAMETERIVPROC __glewGetRenderbufferParameteriv = NULL;\nPFNGLISFRAMEBUFFERPROC __glewIsFramebuffer = NULL;\nPFNGLISRENDERBUFFERPROC __glewIsRenderbuffer = NULL;\nPFNGLRENDERBUFFERSTORAGEPROC __glewRenderbufferStorage = NULL;\nPFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC __glewRenderbufferStorageMultisample = NULL;\n\nPFNGLFRAMEBUFFERTEXTUREARBPROC __glewFramebufferTextureARB = NULL;\nPFNGLFRAMEBUFFERTEXTUREFACEARBPROC __glewFramebufferTextureFaceARB = NULL;\nPFNGLFRAMEBUFFERTEXTURELAYERARBPROC __glewFramebufferTextureLayerARB = NULL;\nPFNGLPROGRAMPARAMETERIARBPROC __glewProgramParameteriARB = NULL;\n\nPFNGLCOLORSUBTABLEPROC __glewColorSubTable = NULL;\nPFNGLCOLORTABLEPROC __glewColorTable = NULL;\nPFNGLCOLORTABLEPARAMETERFVPROC __glewColorTableParameterfv = NULL;\nPFNGLCOLORTABLEPARAMETERIVPROC __glewColorTableParameteriv = NULL;\nPFNGLCONVOLUTIONFILTER1DPROC __glewConvolutionFilter1D = NULL;\nPFNGLCONVOLUTIONFILTER2DPROC __glewConvolutionFilter2D = NULL;\nPFNGLCONVOLUTIONPARAMETERFPROC __glewConvolutionParameterf = NULL;\nPFNGLCONVOLUTIONPARAMETERFVPROC __glewConvolutionParameterfv = NULL;\nPFNGLCONVOLUTIONPARAMETERIPROC __glewConvolutionParameteri = NULL;\nPFNGLCONVOLUTIONPARAMETERIVPROC __glewConvolutionParameteriv = NULL;\nPFNGLCOPYCOLORSUBTABLEPROC __glewCopyColorSubTable = NULL;\nPFNGLCOPYCOLORTABLEPROC __glewCopyColorTable = NULL;\nPFNGLCOPYCONVOLUTIONFILTER1DPROC __glewCopyConvolutionFilter1D = NULL;\nPFNGLCOPYCONVOLUTIONFILTER2DPROC __glewCopyConvolutionFilter2D = NULL;\nPFNGLGETCOLORTABLEPROC __glewGetColorTable = NULL;\nPFNGLGETCOLORTABLEPARAMETERFVPROC __glewGetColorTableParameterfv = NULL;\nPFNGLGETCOLORTABLEPARAMETERIVPROC __glewGetColorTableParameteriv = NULL;\nPFNGLGETCONVOLUTIONFILTERPROC __glewGetConvolutionFilter = NULL;\nPFNGLGETCONVOLUTIONPARAMETERFVPROC __glewGetConvolutionParameterfv = NULL;\nPFNGLGETCONVOLUTIONPARAMETERIVPROC __glewGetConvolutionParameteriv = NULL;\nPFNGLGETHISTOGRAMPROC __glewGetHistogram = NULL;\nPFNGLGETHISTOGRAMPARAMETERFVPROC __glewGetHistogramParameterfv = NULL;\nPFNGLGETHISTOGRAMPARAMETERIVPROC __glewGetHistogramParameteriv = NULL;\nPFNGLGETMINMAXPROC __glewGetMinmax = NULL;\nPFNGLGETMINMAXPARAMETERFVPROC __glewGetMinmaxParameterfv = NULL;\nPFNGLGETMINMAXPARAMETERIVPROC __glewGetMinmaxParameteriv = NULL;\nPFNGLGETSEPARABLEFILTERPROC __glewGetSeparableFilter = NULL;\nPFNGLHISTOGRAMPROC __glewHistogram = NULL;\nPFNGLMINMAXPROC __glewMinmax = NULL;\nPFNGLRESETHISTOGRAMPROC __glewResetHistogram = NULL;\nPFNGLRESETMINMAXPROC __glewResetMinmax = NULL;\nPFNGLSEPARABLEFILTER2DPROC __glewSeparableFilter2D = NULL;\n\nPFNGLVERTEXATTRIBDIVISORARBPROC __glewVertexAttribDivisorARB = NULL;\n\nPFNGLFLUSHMAPPEDBUFFERRANGEPROC __glewFlushMappedBufferRange = NULL;\nPFNGLMAPBUFFERRANGEPROC __glewMapBufferRange = NULL;\n\nPFNGLCURRENTPALETTEMATRIXARBPROC __glewCurrentPaletteMatrixARB = NULL;\nPFNGLMATRIXINDEXPOINTERARBPROC __glewMatrixIndexPointerARB = NULL;\nPFNGLMATRIXINDEXUBVARBPROC __glewMatrixIndexubvARB = NULL;\nPFNGLMATRIXINDEXUIVARBPROC __glewMatrixIndexuivARB = NULL;\nPFNGLMATRIXINDEXUSVARBPROC __glewMatrixIndexusvARB = NULL;\n\nPFNGLSAMPLECOVERAGEARBPROC __glewSampleCoverageARB = NULL;\n\nPFNGLACTIVETEXTUREARBPROC __glewActiveTextureARB = NULL;\nPFNGLCLIENTACTIVETEXTUREARBPROC __glewClientActiveTextureARB = NULL;\nPFNGLMULTITEXCOORD1DARBPROC __glewMultiTexCoord1dARB = NULL;\nPFNGLMULTITEXCOORD1DVARBPROC __glewMultiTexCoord1dvARB = NULL;\nPFNGLMULTITEXCOORD1FARBPROC __glewMultiTexCoord1fARB = NULL;\nPFNGLMULTITEXCOORD1FVARBPROC __glewMultiTexCoord1fvARB = NULL;\nPFNGLMULTITEXCOORD1IARBPROC __glewMultiTexCoord1iARB = NULL;\nPFNGLMULTITEXCOORD1IVARBPROC __glewMultiTexCoord1ivARB = NULL;\nPFNGLMULTITEXCOORD1SARBPROC __glewMultiTexCoord1sARB = NULL;\nPFNGLMULTITEXCOORD1SVARBPROC __glewMultiTexCoord1svARB = NULL;\nPFNGLMULTITEXCOORD2DARBPROC __glewMultiTexCoord2dARB = NULL;\nPFNGLMULTITEXCOORD2DVARBPROC __glewMultiTexCoord2dvARB = NULL;\nPFNGLMULTITEXCOORD2FARBPROC __glewMultiTexCoord2fARB = NULL;\nPFNGLMULTITEXCOORD2FVARBPROC __glewMultiTexCoord2fvARB = NULL;\nPFNGLMULTITEXCOORD2IARBPROC __glewMultiTexCoord2iARB = NULL;\nPFNGLMULTITEXCOORD2IVARBPROC __glewMultiTexCoord2ivARB = NULL;\nPFNGLMULTITEXCOORD2SARBPROC __glewMultiTexCoord2sARB = NULL;\nPFNGLMULTITEXCOORD2SVARBPROC __glewMultiTexCoord2svARB = NULL;\nPFNGLMULTITEXCOORD3DARBPROC __glewMultiTexCoord3dARB = NULL;\nPFNGLMULTITEXCOORD3DVARBPROC __glewMultiTexCoord3dvARB = NULL;\nPFNGLMULTITEXCOORD3FARBPROC __glewMultiTexCoord3fARB = NULL;\nPFNGLMULTITEXCOORD3FVARBPROC __glewMultiTexCoord3fvARB = NULL;\nPFNGLMULTITEXCOORD3IARBPROC __glewMultiTexCoord3iARB = NULL;\nPFNGLMULTITEXCOORD3IVARBPROC __glewMultiTexCoord3ivARB = NULL;\nPFNGLMULTITEXCOORD3SARBPROC __glewMultiTexCoord3sARB = NULL;\nPFNGLMULTITEXCOORD3SVARBPROC __glewMultiTexCoord3svARB = NULL;\nPFNGLMULTITEXCOORD4DARBPROC __glewMultiTexCoord4dARB = NULL;\nPFNGLMULTITEXCOORD4DVARBPROC __glewMultiTexCoord4dvARB = NULL;\nPFNGLMULTITEXCOORD4FARBPROC __glewMultiTexCoord4fARB = NULL;\nPFNGLMULTITEXCOORD4FVARBPROC __glewMultiTexCoord4fvARB = NULL;\nPFNGLMULTITEXCOORD4IARBPROC __glewMultiTexCoord4iARB = NULL;\nPFNGLMULTITEXCOORD4IVARBPROC __glewMultiTexCoord4ivARB = NULL;\nPFNGLMULTITEXCOORD4SARBPROC __glewMultiTexCoord4sARB = NULL;\nPFNGLMULTITEXCOORD4SVARBPROC __glewMultiTexCoord4svARB = NULL;\n\nPFNGLBEGINQUERYARBPROC __glewBeginQueryARB = NULL;\nPFNGLDELETEQUERIESARBPROC __glewDeleteQueriesARB = NULL;\nPFNGLENDQUERYARBPROC __glewEndQueryARB = NULL;\nPFNGLGENQUERIESARBPROC __glewGenQueriesARB = NULL;\nPFNGLGETQUERYOBJECTIVARBPROC __glewGetQueryObjectivARB = NULL;\nPFNGLGETQUERYOBJECTUIVARBPROC __glewGetQueryObjectuivARB = NULL;\nPFNGLGETQUERYIVARBPROC __glewGetQueryivARB = NULL;\nPFNGLISQUERYARBPROC __glewIsQueryARB = NULL;\n\nPFNGLPOINTPARAMETERFARBPROC __glewPointParameterfARB = NULL;\nPFNGLPOINTPARAMETERFVARBPROC __glewPointParameterfvARB = NULL;\n\nPFNGLATTACHOBJECTARBPROC __glewAttachObjectARB = NULL;\nPFNGLCOMPILESHADERARBPROC __glewCompileShaderARB = NULL;\nPFNGLCREATEPROGRAMOBJECTARBPROC __glewCreateProgramObjectARB = NULL;\nPFNGLCREATESHADEROBJECTARBPROC __glewCreateShaderObjectARB = NULL;\nPFNGLDELETEOBJECTARBPROC __glewDeleteObjectARB = NULL;\nPFNGLDETACHOBJECTARBPROC __glewDetachObjectARB = NULL;\nPFNGLGETACTIVEUNIFORMARBPROC __glewGetActiveUniformARB = NULL;\nPFNGLGETATTACHEDOBJECTSARBPROC __glewGetAttachedObjectsARB = NULL;\nPFNGLGETHANDLEARBPROC __glewGetHandleARB = NULL;\nPFNGLGETINFOLOGARBPROC __glewGetInfoLogARB = NULL;\nPFNGLGETOBJECTPARAMETERFVARBPROC __glewGetObjectParameterfvARB = NULL;\nPFNGLGETOBJECTPARAMETERIVARBPROC __glewGetObjectParameterivARB = NULL;\nPFNGLGETSHADERSOURCEARBPROC __glewGetShaderSourceARB = NULL;\nPFNGLGETUNIFORMLOCATIONARBPROC __glewGetUniformLocationARB = NULL;\nPFNGLGETUNIFORMFVARBPROC __glewGetUniformfvARB = NULL;\nPFNGLGETUNIFORMIVARBPROC __glewGetUniformivARB = NULL;\nPFNGLLINKPROGRAMARBPROC __glewLinkProgramARB = NULL;\nPFNGLSHADERSOURCEARBPROC __glewShaderSourceARB = NULL;\nPFNGLUNIFORM1FARBPROC __glewUniform1fARB = NULL;\nPFNGLUNIFORM1FVARBPROC __glewUniform1fvARB = NULL;\nPFNGLUNIFORM1IARBPROC __glewUniform1iARB = NULL;\nPFNGLUNIFORM1IVARBPROC __glewUniform1ivARB = NULL;\nPFNGLUNIFORM2FARBPROC __glewUniform2fARB = NULL;\nPFNGLUNIFORM2FVARBPROC __glewUniform2fvARB = NULL;\nPFNGLUNIFORM2IARBPROC __glewUniform2iARB = NULL;\nPFNGLUNIFORM2IVARBPROC __glewUniform2ivARB = NULL;\nPFNGLUNIFORM3FARBPROC __glewUniform3fARB = NULL;\nPFNGLUNIFORM3FVARBPROC __glewUniform3fvARB = NULL;\nPFNGLUNIFORM3IARBPROC __glewUniform3iARB = NULL;\nPFNGLUNIFORM3IVARBPROC __glewUniform3ivARB = NULL;\nPFNGLUNIFORM4FARBPROC __glewUniform4fARB = NULL;\nPFNGLUNIFORM4FVARBPROC __glewUniform4fvARB = NULL;\nPFNGLUNIFORM4IARBPROC __glewUniform4iARB = NULL;\nPFNGLUNIFORM4IVARBPROC __glewUniform4ivARB = NULL;\nPFNGLUNIFORMMATRIX2FVARBPROC __glewUniformMatrix2fvARB = NULL;\nPFNGLUNIFORMMATRIX3FVARBPROC __glewUniformMatrix3fvARB = NULL;\nPFNGLUNIFORMMATRIX4FVARBPROC __glewUniformMatrix4fvARB = NULL;\nPFNGLUSEPROGRAMOBJECTARBPROC __glewUseProgramObjectARB = NULL;\nPFNGLVALIDATEPROGRAMARBPROC __glewValidateProgramARB = NULL;\n\nPFNGLTEXBUFFERARBPROC __glewTexBufferARB = NULL;\n\nPFNGLCOMPRESSEDTEXIMAGE1DARBPROC __glewCompressedTexImage1DARB = NULL;\nPFNGLCOMPRESSEDTEXIMAGE2DARBPROC __glewCompressedTexImage2DARB = NULL;\nPFNGLCOMPRESSEDTEXIMAGE3DARBPROC __glewCompressedTexImage3DARB = NULL;\nPFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC __glewCompressedTexSubImage1DARB = NULL;\nPFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC __glewCompressedTexSubImage2DARB = NULL;\nPFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC __glewCompressedTexSubImage3DARB = NULL;\nPFNGLGETCOMPRESSEDTEXIMAGEARBPROC __glewGetCompressedTexImageARB = NULL;\n\nPFNGLLOADTRANSPOSEMATRIXDARBPROC __glewLoadTransposeMatrixdARB = NULL;\nPFNGLLOADTRANSPOSEMATRIXFARBPROC __glewLoadTransposeMatrixfARB = NULL;\nPFNGLMULTTRANSPOSEMATRIXDARBPROC __glewMultTransposeMatrixdARB = NULL;\nPFNGLMULTTRANSPOSEMATRIXFARBPROC __glewMultTransposeMatrixfARB = NULL;\n\nPFNGLBINDVERTEXARRAYPROC __glewBindVertexArray = NULL;\nPFNGLDELETEVERTEXARRAYSPROC __glewDeleteVertexArrays = NULL;\nPFNGLGENVERTEXARRAYSPROC __glewGenVertexArrays = NULL;\nPFNGLISVERTEXARRAYPROC __glewIsVertexArray = NULL;\n\nPFNGLVERTEXBLENDARBPROC __glewVertexBlendARB = NULL;\nPFNGLWEIGHTPOINTERARBPROC __glewWeightPointerARB = NULL;\nPFNGLWEIGHTBVARBPROC __glewWeightbvARB = NULL;\nPFNGLWEIGHTDVARBPROC __glewWeightdvARB = NULL;\nPFNGLWEIGHTFVARBPROC __glewWeightfvARB = NULL;\nPFNGLWEIGHTIVARBPROC __glewWeightivARB = NULL;\nPFNGLWEIGHTSVARBPROC __glewWeightsvARB = NULL;\nPFNGLWEIGHTUBVARBPROC __glewWeightubvARB = NULL;\nPFNGLWEIGHTUIVARBPROC __glewWeightuivARB = NULL;\nPFNGLWEIGHTUSVARBPROC __glewWeightusvARB = NULL;\n\nPFNGLBINDBUFFERARBPROC __glewBindBufferARB = NULL;\nPFNGLBUFFERDATAARBPROC __glewBufferDataARB = NULL;\nPFNGLBUFFERSUBDATAARBPROC __glewBufferSubDataARB = NULL;\nPFNGLDELETEBUFFERSARBPROC __glewDeleteBuffersARB = NULL;\nPFNGLGENBUFFERSARBPROC __glewGenBuffersARB = NULL;\nPFNGLGETBUFFERPARAMETERIVARBPROC __glewGetBufferParameterivARB = NULL;\nPFNGLGETBUFFERPOINTERVARBPROC __glewGetBufferPointervARB = NULL;\nPFNGLGETBUFFERSUBDATAARBPROC __glewGetBufferSubDataARB = NULL;\nPFNGLISBUFFERARBPROC __glewIsBufferARB = NULL;\nPFNGLMAPBUFFERARBPROC __glewMapBufferARB = NULL;\nPFNGLUNMAPBUFFERARBPROC __glewUnmapBufferARB = NULL;\n\nPFNGLBINDPROGRAMARBPROC __glewBindProgramARB = NULL;\nPFNGLDELETEPROGRAMSARBPROC __glewDeleteProgramsARB = NULL;\nPFNGLDISABLEVERTEXATTRIBARRAYARBPROC __glewDisableVertexAttribArrayARB = NULL;\nPFNGLENABLEVERTEXATTRIBARRAYARBPROC __glewEnableVertexAttribArrayARB = NULL;\nPFNGLGENPROGRAMSARBPROC __glewGenProgramsARB = NULL;\nPFNGLGETPROGRAMENVPARAMETERDVARBPROC __glewGetProgramEnvParameterdvARB = NULL;\nPFNGLGETPROGRAMENVPARAMETERFVARBPROC __glewGetProgramEnvParameterfvARB = NULL;\nPFNGLGETPROGRAMLOCALPARAMETERDVARBPROC __glewGetProgramLocalParameterdvARB = NULL;\nPFNGLGETPROGRAMLOCALPARAMETERFVARBPROC __glewGetProgramLocalParameterfvARB = NULL;\nPFNGLGETPROGRAMSTRINGARBPROC __glewGetProgramStringARB = NULL;\nPFNGLGETPROGRAMIVARBPROC __glewGetProgramivARB = NULL;\nPFNGLGETVERTEXATTRIBPOINTERVARBPROC __glewGetVertexAttribPointervARB = NULL;\nPFNGLGETVERTEXATTRIBDVARBPROC __glewGetVertexAttribdvARB = NULL;\nPFNGLGETVERTEXATTRIBFVARBPROC __glewGetVertexAttribfvARB = NULL;\nPFNGLGETVERTEXATTRIBIVARBPROC __glewGetVertexAttribivARB = NULL;\nPFNGLISPROGRAMARBPROC __glewIsProgramARB = NULL;\nPFNGLPROGRAMENVPARAMETER4DARBPROC __glewProgramEnvParameter4dARB = NULL;\nPFNGLPROGRAMENVPARAMETER4DVARBPROC __glewProgramEnvParameter4dvARB = NULL;\nPFNGLPROGRAMENVPARAMETER4FARBPROC __glewProgramEnvParameter4fARB = NULL;\nPFNGLPROGRAMENVPARAMETER4FVARBPROC __glewProgramEnvParameter4fvARB = NULL;\nPFNGLPROGRAMLOCALPARAMETER4DARBPROC __glewProgramLocalParameter4dARB = NULL;\nPFNGLPROGRAMLOCALPARAMETER4DVARBPROC __glewProgramLocalParameter4dvARB = NULL;\nPFNGLPROGRAMLOCALPARAMETER4FARBPROC __glewProgramLocalParameter4fARB = NULL;\nPFNGLPROGRAMLOCALPARAMETER4FVARBPROC __glewProgramLocalParameter4fvARB = NULL;\nPFNGLPROGRAMSTRINGARBPROC __glewProgramStringARB = NULL;\nPFNGLVERTEXATTRIB1DARBPROC __glewVertexAttrib1dARB = NULL;\nPFNGLVERTEXATTRIB1DVARBPROC __glewVertexAttrib1dvARB = NULL;\nPFNGLVERTEXATTRIB1FARBPROC __glewVertexAttrib1fARB = NULL;\nPFNGLVERTEXATTRIB1FVARBPROC __glewVertexAttrib1fvARB = NULL;\nPFNGLVERTEXATTRIB1SARBPROC __glewVertexAttrib1sARB = NULL;\nPFNGLVERTEXATTRIB1SVARBPROC __glewVertexAttrib1svARB = NULL;\nPFNGLVERTEXATTRIB2DARBPROC __glewVertexAttrib2dARB = NULL;\nPFNGLVERTEXATTRIB2DVARBPROC __glewVertexAttrib2dvARB = NULL;\nPFNGLVERTEXATTRIB2FARBPROC __glewVertexAttrib2fARB = NULL;\nPFNGLVERTEXATTRIB2FVARBPROC __glewVertexAttrib2fvARB = NULL;\nPFNGLVERTEXATTRIB2SARBPROC __glewVertexAttrib2sARB = NULL;\nPFNGLVERTEXATTRIB2SVARBPROC __glewVertexAttrib2svARB = NULL;\nPFNGLVERTEXATTRIB3DARBPROC __glewVertexAttrib3dARB = NULL;\nPFNGLVERTEXATTRIB3DVARBPROC __glewVertexAttrib3dvARB = NULL;\nPFNGLVERTEXATTRIB3FARBPROC __glewVertexAttrib3fARB = NULL;\nPFNGLVERTEXATTRIB3FVARBPROC __glewVertexAttrib3fvARB = NULL;\nPFNGLVERTEXATTRIB3SARBPROC __glewVertexAttrib3sARB = NULL;\nPFNGLVERTEXATTRIB3SVARBPROC __glewVertexAttrib3svARB = NULL;\nPFNGLVERTEXATTRIB4NBVARBPROC __glewVertexAttrib4NbvARB = NULL;\nPFNGLVERTEXATTRIB4NIVARBPROC __glewVertexAttrib4NivARB = NULL;\nPFNGLVERTEXATTRIB4NSVARBPROC __glewVertexAttrib4NsvARB = NULL;\nPFNGLVERTEXATTRIB4NUBARBPROC __glewVertexAttrib4NubARB = NULL;\nPFNGLVERTEXATTRIB4NUBVARBPROC __glewVertexAttrib4NubvARB = NULL;\nPFNGLVERTEXATTRIB4NUIVARBPROC __glewVertexAttrib4NuivARB = NULL;\nPFNGLVERTEXATTRIB4NUSVARBPROC __glewVertexAttrib4NusvARB = NULL;\nPFNGLVERTEXATTRIB4BVARBPROC __glewVertexAttrib4bvARB = NULL;\nPFNGLVERTEXATTRIB4DARBPROC __glewVertexAttrib4dARB = NULL;\nPFNGLVERTEXATTRIB4DVARBPROC __glewVertexAttrib4dvARB = NULL;\nPFNGLVERTEXATTRIB4FARBPROC __glewVertexAttrib4fARB = NULL;\nPFNGLVERTEXATTRIB4FVARBPROC __glewVertexAttrib4fvARB = NULL;\nPFNGLVERTEXATTRIB4IVARBPROC __glewVertexAttrib4ivARB = NULL;\nPFNGLVERTEXATTRIB4SARBPROC __glewVertexAttrib4sARB = NULL;\nPFNGLVERTEXATTRIB4SVARBPROC __glewVertexAttrib4svARB = NULL;\nPFNGLVERTEXATTRIB4UBVARBPROC __glewVertexAttrib4ubvARB = NULL;\nPFNGLVERTEXATTRIB4UIVARBPROC __glewVertexAttrib4uivARB = NULL;\nPFNGLVERTEXATTRIB4USVARBPROC __glewVertexAttrib4usvARB = NULL;\nPFNGLVERTEXATTRIBPOINTERARBPROC __glewVertexAttribPointerARB = NULL;\n\nPFNGLBINDATTRIBLOCATIONARBPROC __glewBindAttribLocationARB = NULL;\nPFNGLGETACTIVEATTRIBARBPROC __glewGetActiveAttribARB = NULL;\nPFNGLGETATTRIBLOCATIONARBPROC __glewGetAttribLocationARB = NULL;\n\nPFNGLWINDOWPOS2DARBPROC __glewWindowPos2dARB = NULL;\nPFNGLWINDOWPOS2DVARBPROC __glewWindowPos2dvARB = NULL;\nPFNGLWINDOWPOS2FARBPROC __glewWindowPos2fARB = NULL;\nPFNGLWINDOWPOS2FVARBPROC __glewWindowPos2fvARB = NULL;\nPFNGLWINDOWPOS2IARBPROC __glewWindowPos2iARB = NULL;\nPFNGLWINDOWPOS2IVARBPROC __glewWindowPos2ivARB = NULL;\nPFNGLWINDOWPOS2SARBPROC __glewWindowPos2sARB = NULL;\nPFNGLWINDOWPOS2SVARBPROC __glewWindowPos2svARB = NULL;\nPFNGLWINDOWPOS3DARBPROC __glewWindowPos3dARB = NULL;\nPFNGLWINDOWPOS3DVARBPROC __glewWindowPos3dvARB = NULL;\nPFNGLWINDOWPOS3FARBPROC __glewWindowPos3fARB = NULL;\nPFNGLWINDOWPOS3FVARBPROC __glewWindowPos3fvARB = NULL;\nPFNGLWINDOWPOS3IARBPROC __glewWindowPos3iARB = NULL;\nPFNGLWINDOWPOS3IVARBPROC __glewWindowPos3ivARB = NULL;\nPFNGLWINDOWPOS3SARBPROC __glewWindowPos3sARB = NULL;\nPFNGLWINDOWPOS3SVARBPROC __glewWindowPos3svARB = NULL;\n\nPFNGLDRAWBUFFERSATIPROC __glewDrawBuffersATI = NULL;\n\nPFNGLDRAWELEMENTARRAYATIPROC __glewDrawElementArrayATI = NULL;\nPFNGLDRAWRANGEELEMENTARRAYATIPROC __glewDrawRangeElementArrayATI = NULL;\nPFNGLELEMENTPOINTERATIPROC __glewElementPointerATI = NULL;\n\nPFNGLGETTEXBUMPPARAMETERFVATIPROC __glewGetTexBumpParameterfvATI = NULL;\nPFNGLGETTEXBUMPPARAMETERIVATIPROC __glewGetTexBumpParameterivATI = NULL;\nPFNGLTEXBUMPPARAMETERFVATIPROC __glewTexBumpParameterfvATI = NULL;\nPFNGLTEXBUMPPARAMETERIVATIPROC __glewTexBumpParameterivATI = NULL;\n\nPFNGLALPHAFRAGMENTOP1ATIPROC __glewAlphaFragmentOp1ATI = NULL;\nPFNGLALPHAFRAGMENTOP2ATIPROC __glewAlphaFragmentOp2ATI = NULL;\nPFNGLALPHAFRAGMENTOP3ATIPROC __glewAlphaFragmentOp3ATI = NULL;\nPFNGLBEGINFRAGMENTSHADERATIPROC __glewBeginFragmentShaderATI = NULL;\nPFNGLBINDFRAGMENTSHADERATIPROC __glewBindFragmentShaderATI = NULL;\nPFNGLCOLORFRAGMENTOP1ATIPROC __glewColorFragmentOp1ATI = NULL;\nPFNGLCOLORFRAGMENTOP2ATIPROC __glewColorFragmentOp2ATI = NULL;\nPFNGLCOLORFRAGMENTOP3ATIPROC __glewColorFragmentOp3ATI = NULL;\nPFNGLDELETEFRAGMENTSHADERATIPROC __glewDeleteFragmentShaderATI = NULL;\nPFNGLENDFRAGMENTSHADERATIPROC __glewEndFragmentShaderATI = NULL;\nPFNGLGENFRAGMENTSHADERSATIPROC __glewGenFragmentShadersATI = NULL;\nPFNGLPASSTEXCOORDATIPROC __glewPassTexCoordATI = NULL;\nPFNGLSAMPLEMAPATIPROC __glewSampleMapATI = NULL;\nPFNGLSETFRAGMENTSHADERCONSTANTATIPROC __glewSetFragmentShaderConstantATI = NULL;\n\nPFNGLMAPOBJECTBUFFERATIPROC __glewMapObjectBufferATI = NULL;\nPFNGLUNMAPOBJECTBUFFERATIPROC __glewUnmapObjectBufferATI = NULL;\n\nPFNGLPNTRIANGLESFATIPROC __glPNTrianglewesfATI = NULL;\nPFNGLPNTRIANGLESIATIPROC __glPNTrianglewesiATI = NULL;\n\nPFNGLSTENCILFUNCSEPARATEATIPROC __glewStencilFuncSeparateATI = NULL;\nPFNGLSTENCILOPSEPARATEATIPROC __glewStencilOpSeparateATI = NULL;\n\nPFNGLARRAYOBJECTATIPROC __glewArrayObjectATI = NULL;\nPFNGLFREEOBJECTBUFFERATIPROC __glewFreeObjectBufferATI = NULL;\nPFNGLGETARRAYOBJECTFVATIPROC __glewGetArrayObjectfvATI = NULL;\nPFNGLGETARRAYOBJECTIVATIPROC __glewGetArrayObjectivATI = NULL;\nPFNGLGETOBJECTBUFFERFVATIPROC __glewGetObjectBufferfvATI = NULL;\nPFNGLGETOBJECTBUFFERIVATIPROC __glewGetObjectBufferivATI = NULL;\nPFNGLGETVARIANTARRAYOBJECTFVATIPROC __glewGetVariantArrayObjectfvATI = NULL;\nPFNGLGETVARIANTARRAYOBJECTIVATIPROC __glewGetVariantArrayObjectivATI = NULL;\nPFNGLISOBJECTBUFFERATIPROC __glewIsObjectBufferATI = NULL;\nPFNGLNEWOBJECTBUFFERATIPROC __glewNewObjectBufferATI = NULL;\nPFNGLUPDATEOBJECTBUFFERATIPROC __glewUpdateObjectBufferATI = NULL;\nPFNGLVARIANTARRAYOBJECTATIPROC __glewVariantArrayObjectATI = NULL;\n\nPFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC __glewGetVertexAttribArrayObjectfvATI = NULL;\nPFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC __glewGetVertexAttribArrayObjectivATI = NULL;\nPFNGLVERTEXATTRIBARRAYOBJECTATIPROC __glewVertexAttribArrayObjectATI = NULL;\n\nPFNGLCLIENTACTIVEVERTEXSTREAMATIPROC __glewClientActiveVertexStreamATI = NULL;\nPFNGLNORMALSTREAM3BATIPROC __glewNormalStream3bATI = NULL;\nPFNGLNORMALSTREAM3BVATIPROC __glewNormalStream3bvATI = NULL;\nPFNGLNORMALSTREAM3DATIPROC __glewNormalStream3dATI = NULL;\nPFNGLNORMALSTREAM3DVATIPROC __glewNormalStream3dvATI = NULL;\nPFNGLNORMALSTREAM3FATIPROC __glewNormalStream3fATI = NULL;\nPFNGLNORMALSTREAM3FVATIPROC __glewNormalStream3fvATI = NULL;\nPFNGLNORMALSTREAM3IATIPROC __glewNormalStream3iATI = NULL;\nPFNGLNORMALSTREAM3IVATIPROC __glewNormalStream3ivATI = NULL;\nPFNGLNORMALSTREAM3SATIPROC __glewNormalStream3sATI = NULL;\nPFNGLNORMALSTREAM3SVATIPROC __glewNormalStream3svATI = NULL;\nPFNGLVERTEXBLENDENVFATIPROC __glewVertexBlendEnvfATI = NULL;\nPFNGLVERTEXBLENDENVIATIPROC __glewVertexBlendEnviATI = NULL;\nPFNGLVERTEXSTREAM2DATIPROC __glewVertexStream2dATI = NULL;\nPFNGLVERTEXSTREAM2DVATIPROC __glewVertexStream2dvATI = NULL;\nPFNGLVERTEXSTREAM2FATIPROC __glewVertexStream2fATI = NULL;\nPFNGLVERTEXSTREAM2FVATIPROC __glewVertexStream2fvATI = NULL;\nPFNGLVERTEXSTREAM2IATIPROC __glewVertexStream2iATI = NULL;\nPFNGLVERTEXSTREAM2IVATIPROC __glewVertexStream2ivATI = NULL;\nPFNGLVERTEXSTREAM2SATIPROC __glewVertexStream2sATI = NULL;\nPFNGLVERTEXSTREAM2SVATIPROC __glewVertexStream2svATI = NULL;\nPFNGLVERTEXSTREAM3DATIPROC __glewVertexStream3dATI = NULL;\nPFNGLVERTEXSTREAM3DVATIPROC __glewVertexStream3dvATI = NULL;\nPFNGLVERTEXSTREAM3FATIPROC __glewVertexStream3fATI = NULL;\nPFNGLVERTEXSTREAM3FVATIPROC __glewVertexStream3fvATI = NULL;\nPFNGLVERTEXSTREAM3IATIPROC __glewVertexStream3iATI = NULL;\nPFNGLVERTEXSTREAM3IVATIPROC __glewVertexStream3ivATI = NULL;\nPFNGLVERTEXSTREAM3SATIPROC __glewVertexStream3sATI = NULL;\nPFNGLVERTEXSTREAM3SVATIPROC __glewVertexStream3svATI = NULL;\nPFNGLVERTEXSTREAM4DATIPROC __glewVertexStream4dATI = NULL;\nPFNGLVERTEXSTREAM4DVATIPROC __glewVertexStream4dvATI = NULL;\nPFNGLVERTEXSTREAM4FATIPROC __glewVertexStream4fATI = NULL;\nPFNGLVERTEXSTREAM4FVATIPROC __glewVertexStream4fvATI = NULL;\nPFNGLVERTEXSTREAM4IATIPROC __glewVertexStream4iATI = NULL;\nPFNGLVERTEXSTREAM4IVATIPROC __glewVertexStream4ivATI = NULL;\nPFNGLVERTEXSTREAM4SATIPROC __glewVertexStream4sATI = NULL;\nPFNGLVERTEXSTREAM4SVATIPROC __glewVertexStream4svATI = NULL;\n\nPFNGLGETUNIFORMBUFFERSIZEEXTPROC __glewGetUniformBufferSizeEXT = NULL;\nPFNGLGETUNIFORMOFFSETEXTPROC __glewGetUniformOffsetEXT = NULL;\nPFNGLUNIFORMBUFFEREXTPROC __glewUniformBufferEXT = NULL;\n\nPFNGLBLENDCOLOREXTPROC __glewBlendColorEXT = NULL;\n\nPFNGLBLENDEQUATIONSEPARATEEXTPROC __glewBlendEquationSeparateEXT = NULL;\n\nPFNGLBLENDFUNCSEPARATEEXTPROC __glewBlendFuncSeparateEXT = NULL;\n\nPFNGLBLENDEQUATIONEXTPROC __glewBlendEquationEXT = NULL;\n\nPFNGLCOLORSUBTABLEEXTPROC __glewColorSubTableEXT = NULL;\nPFNGLCOPYCOLORSUBTABLEEXTPROC __glewCopyColorSubTableEXT = NULL;\n\nPFNGLLOCKARRAYSEXTPROC __glewLockArraysEXT = NULL;\nPFNGLUNLOCKARRAYSEXTPROC __glewUnlockArraysEXT = NULL;\n\nPFNGLCONVOLUTIONFILTER1DEXTPROC __glewConvolutionFilter1DEXT = NULL;\nPFNGLCONVOLUTIONFILTER2DEXTPROC __glewConvolutionFilter2DEXT = NULL;\nPFNGLCONVOLUTIONPARAMETERFEXTPROC __glewConvolutionParameterfEXT = NULL;\nPFNGLCONVOLUTIONPARAMETERFVEXTPROC __glewConvolutionParameterfvEXT = NULL;\nPFNGLCONVOLUTIONPARAMETERIEXTPROC __glewConvolutionParameteriEXT = NULL;\nPFNGLCONVOLUTIONPARAMETERIVEXTPROC __glewConvolutionParameterivEXT = NULL;\nPFNGLCOPYCONVOLUTIONFILTER1DEXTPROC __glewCopyConvolutionFilter1DEXT = NULL;\nPFNGLCOPYCONVOLUTIONFILTER2DEXTPROC __glewCopyConvolutionFilter2DEXT = NULL;\nPFNGLGETCONVOLUTIONFILTEREXTPROC __glewGetConvolutionFilterEXT = NULL;\nPFNGLGETCONVOLUTIONPARAMETERFVEXTPROC __glewGetConvolutionParameterfvEXT = NULL;\nPFNGLGETCONVOLUTIONPARAMETERIVEXTPROC __glewGetConvolutionParameterivEXT = NULL;\nPFNGLGETSEPARABLEFILTEREXTPROC __glewGetSeparableFilterEXT = NULL;\nPFNGLSEPARABLEFILTER2DEXTPROC __glewSeparableFilter2DEXT = NULL;\n\nPFNGLBINORMALPOINTEREXTPROC __glewBinormalPointerEXT = NULL;\nPFNGLTANGENTPOINTEREXTPROC __glewTangentPointerEXT = NULL;\n\nPFNGLCOPYTEXIMAGE1DEXTPROC __glewCopyTexImage1DEXT = NULL;\nPFNGLCOPYTEXIMAGE2DEXTPROC __glewCopyTexImage2DEXT = NULL;\nPFNGLCOPYTEXSUBIMAGE1DEXTPROC __glewCopyTexSubImage1DEXT = NULL;\nPFNGLCOPYTEXSUBIMAGE2DEXTPROC __glewCopyTexSubImage2DEXT = NULL;\nPFNGLCOPYTEXSUBIMAGE3DEXTPROC __glewCopyTexSubImage3DEXT = NULL;\n\nPFNGLCULLPARAMETERDVEXTPROC __glewCullParameterdvEXT = NULL;\nPFNGLCULLPARAMETERFVEXTPROC __glewCullParameterfvEXT = NULL;\n\nPFNGLDEPTHBOUNDSEXTPROC __glewDepthBoundsEXT = NULL;\n\nPFNGLBINDMULTITEXTUREEXTPROC __glewBindMultiTextureEXT = NULL;\nPFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC __glewCheckNamedFramebufferStatusEXT = NULL;\nPFNGLCLIENTATTRIBDEFAULTEXTPROC __glewClientAttribDefaultEXT = NULL;\nPFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC __glewCompressedMultiTexImage1DEXT = NULL;\nPFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC __glewCompressedMultiTexImage2DEXT = NULL;\nPFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC __glewCompressedMultiTexImage3DEXT = NULL;\nPFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC __glewCompressedMultiTexSubImage1DEXT = NULL;\nPFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC __glewCompressedMultiTexSubImage2DEXT = NULL;\nPFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC __glewCompressedMultiTexSubImage3DEXT = NULL;\nPFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC __glewCompressedTextureImage1DEXT = NULL;\nPFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC __glewCompressedTextureImage2DEXT = NULL;\nPFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC __glewCompressedTextureImage3DEXT = NULL;\nPFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC __glewCompressedTextureSubImage1DEXT = NULL;\nPFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC __glewCompressedTextureSubImage2DEXT = NULL;\nPFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC __glewCompressedTextureSubImage3DEXT = NULL;\nPFNGLCOPYMULTITEXIMAGE1DEXTPROC __glewCopyMultiTexImage1DEXT = NULL;\nPFNGLCOPYMULTITEXIMAGE2DEXTPROC __glewCopyMultiTexImage2DEXT = NULL;\nPFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC __glewCopyMultiTexSubImage1DEXT = NULL;\nPFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC __glewCopyMultiTexSubImage2DEXT = NULL;\nPFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC __glewCopyMultiTexSubImage3DEXT = NULL;\nPFNGLCOPYTEXTUREIMAGE1DEXTPROC __glewCopyTextureImage1DEXT = NULL;\nPFNGLCOPYTEXTUREIMAGE2DEXTPROC __glewCopyTextureImage2DEXT = NULL;\nPFNGLCOPYTEXTURESUBIMAGE1DEXTPROC __glewCopyTextureSubImage1DEXT = NULL;\nPFNGLCOPYTEXTURESUBIMAGE2DEXTPROC __glewCopyTextureSubImage2DEXT = NULL;\nPFNGLCOPYTEXTURESUBIMAGE3DEXTPROC __glewCopyTextureSubImage3DEXT = NULL;\nPFNGLDISABLECLIENTSTATEINDEXEDEXTPROC __glewDisableClientStateIndexedEXT = NULL;\nPFNGLENABLECLIENTSTATEINDEXEDEXTPROC __glewEnableClientStateIndexedEXT = NULL;\nPFNGLFRAMEBUFFERDRAWBUFFEREXTPROC __glewFramebufferDrawBufferEXT = NULL;\nPFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC __glewFramebufferDrawBuffersEXT = NULL;\nPFNGLFRAMEBUFFERREADBUFFEREXTPROC __glewFramebufferReadBufferEXT = NULL;\nPFNGLGENERATEMULTITEXMIPMAPEXTPROC __glewGenerateMultiTexMipmapEXT = NULL;\nPFNGLGENERATETEXTUREMIPMAPEXTPROC __glewGenerateTextureMipmapEXT = NULL;\nPFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC __glewGetCompressedMultiTexImageEXT = NULL;\nPFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC __glewGetCompressedTextureImageEXT = NULL;\nPFNGLGETDOUBLEINDEXEDVEXTPROC __glewGetDoubleIndexedvEXT = NULL;\nPFNGLGETFLOATINDEXEDVEXTPROC __glewGetFloatIndexedvEXT = NULL;\nPFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC __glewGetFramebufferParameterivEXT = NULL;\nPFNGLGETMULTITEXENVFVEXTPROC __glewGetMultiTexEnvfvEXT = NULL;\nPFNGLGETMULTITEXENVIVEXTPROC __glewGetMultiTexEnvivEXT = NULL;\nPFNGLGETMULTITEXGENDVEXTPROC __glewGetMultiTexGendvEXT = NULL;\nPFNGLGETMULTITEXGENFVEXTPROC __glewGetMultiTexGenfvEXT = NULL;\nPFNGLGETMULTITEXGENIVEXTPROC __glewGetMultiTexGenivEXT = NULL;\nPFNGLGETMULTITEXIMAGEEXTPROC __glewGetMultiTexImageEXT = NULL;\nPFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC __glewGetMultiTexLevelParameterfvEXT = NULL;\nPFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC __glewGetMultiTexLevelParameterivEXT = NULL;\nPFNGLGETMULTITEXPARAMETERIIVEXTPROC __glewGetMultiTexParameterIivEXT = NULL;\nPFNGLGETMULTITEXPARAMETERIUIVEXTPROC __glewGetMultiTexParameterIuivEXT = NULL;\nPFNGLGETMULTITEXPARAMETERFVEXTPROC __glewGetMultiTexParameterfvEXT = NULL;\nPFNGLGETMULTITEXPARAMETERIVEXTPROC __glewGetMultiTexParameterivEXT = NULL;\nPFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC __glewGetNamedBufferParameterivEXT = NULL;\nPFNGLGETNAMEDBUFFERPOINTERVEXTPROC __glewGetNamedBufferPointervEXT = NULL;\nPFNGLGETNAMEDBUFFERSUBDATAEXTPROC __glewGetNamedBufferSubDataEXT = NULL;\nPFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetNamedFramebufferAttachmentParameterivEXT = NULL;\nPFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC __glewGetNamedProgramLocalParameterIivEXT = NULL;\nPFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC __glewGetNamedProgramLocalParameterIuivEXT = NULL;\nPFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC __glewGetNamedProgramLocalParameterdvEXT = NULL;\nPFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC __glewGetNamedProgramLocalParameterfvEXT = NULL;\nPFNGLGETNAMEDPROGRAMSTRINGEXTPROC __glewGetNamedProgramStringEXT = NULL;\nPFNGLGETNAMEDPROGRAMIVEXTPROC __glewGetNamedProgramivEXT = NULL;\nPFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC __glewGetNamedRenderbufferParameterivEXT = NULL;\nPFNGLGETPOINTERINDEXEDVEXTPROC __glewGetPointerIndexedvEXT = NULL;\nPFNGLGETTEXTUREIMAGEEXTPROC __glewGetTextureImageEXT = NULL;\nPFNGLGETTEXTURELEVELPARAMETERFVEXTPROC __glewGetTextureLevelParameterfvEXT = NULL;\nPFNGLGETTEXTURELEVELPARAMETERIVEXTPROC __glewGetTextureLevelParameterivEXT = NULL;\nPFNGLGETTEXTUREPARAMETERIIVEXTPROC __glewGetTextureParameterIivEXT = NULL;\nPFNGLGETTEXTUREPARAMETERIUIVEXTPROC __glewGetTextureParameterIuivEXT = NULL;\nPFNGLGETTEXTUREPARAMETERFVEXTPROC __glewGetTextureParameterfvEXT = NULL;\nPFNGLGETTEXTUREPARAMETERIVEXTPROC __glewGetTextureParameterivEXT = NULL;\nPFNGLMAPNAMEDBUFFEREXTPROC __glewMapNamedBufferEXT = NULL;\nPFNGLMATRIXFRUSTUMEXTPROC __glewMatrixFrustumEXT = NULL;\nPFNGLMATRIXLOADIDENTITYEXTPROC __glewMatrixLoadIdentityEXT = NULL;\nPFNGLMATRIXLOADTRANSPOSEDEXTPROC __glewMatrixLoadTransposedEXT = NULL;\nPFNGLMATRIXLOADTRANSPOSEFEXTPROC __glewMatrixLoadTransposefEXT = NULL;\nPFNGLMATRIXLOADDEXTPROC __glewMatrixLoaddEXT = NULL;\nPFNGLMATRIXLOADFEXTPROC __glewMatrixLoadfEXT = NULL;\nPFNGLMATRIXMULTTRANSPOSEDEXTPROC __glewMatrixMultTransposedEXT = NULL;\nPFNGLMATRIXMULTTRANSPOSEFEXTPROC __glewMatrixMultTransposefEXT = NULL;\nPFNGLMATRIXMULTDEXTPROC __glewMatrixMultdEXT = NULL;\nPFNGLMATRIXMULTFEXTPROC __glewMatrixMultfEXT = NULL;\nPFNGLMATRIXORTHOEXTPROC __glewMatrixOrthoEXT = NULL;\nPFNGLMATRIXPOPEXTPROC __glewMatrixPopEXT = NULL;\nPFNGLMATRIXPUSHEXTPROC __glewMatrixPushEXT = NULL;\nPFNGLMATRIXROTATEDEXTPROC __glewMatrixRotatedEXT = NULL;\nPFNGLMATRIXROTATEFEXTPROC __glewMatrixRotatefEXT = NULL;\nPFNGLMATRIXSCALEDEXTPROC __glewMatrixScaledEXT = NULL;\nPFNGLMATRIXSCALEFEXTPROC __glewMatrixScalefEXT = NULL;\nPFNGLMATRIXTRANSLATEDEXTPROC __glewMatrixTranslatedEXT = NULL;\nPFNGLMATRIXTRANSLATEFEXTPROC __glewMatrixTranslatefEXT = NULL;\nPFNGLMULTITEXBUFFEREXTPROC __glewMultiTexBufferEXT = NULL;\nPFNGLMULTITEXCOORDPOINTEREXTPROC __glewMultiTexCoordPointerEXT = NULL;\nPFNGLMULTITEXENVFEXTPROC __glewMultiTexEnvfEXT = NULL;\nPFNGLMULTITEXENVFVEXTPROC __glewMultiTexEnvfvEXT = NULL;\nPFNGLMULTITEXENVIEXTPROC __glewMultiTexEnviEXT = NULL;\nPFNGLMULTITEXENVIVEXTPROC __glewMultiTexEnvivEXT = NULL;\nPFNGLMULTITEXGENDEXTPROC __glewMultiTexGendEXT = NULL;\nPFNGLMULTITEXGENDVEXTPROC __glewMultiTexGendvEXT = NULL;\nPFNGLMULTITEXGENFEXTPROC __glewMultiTexGenfEXT = NULL;\nPFNGLMULTITEXGENFVEXTPROC __glewMultiTexGenfvEXT = NULL;\nPFNGLMULTITEXGENIEXTPROC __glewMultiTexGeniEXT = NULL;\nPFNGLMULTITEXGENIVEXTPROC __glewMultiTexGenivEXT = NULL;\nPFNGLMULTITEXIMAGE1DEXTPROC __glewMultiTexImage1DEXT = NULL;\nPFNGLMULTITEXIMAGE2DEXTPROC __glewMultiTexImage2DEXT = NULL;\nPFNGLMULTITEXIMAGE3DEXTPROC __glewMultiTexImage3DEXT = NULL;\nPFNGLMULTITEXPARAMETERIIVEXTPROC __glewMultiTexParameterIivEXT = NULL;\nPFNGLMULTITEXPARAMETERIUIVEXTPROC __glewMultiTexParameterIuivEXT = NULL;\nPFNGLMULTITEXPARAMETERFEXTPROC __glewMultiTexParameterfEXT = NULL;\nPFNGLMULTITEXPARAMETERFVEXTPROC __glewMultiTexParameterfvEXT = NULL;\nPFNGLMULTITEXPARAMETERIEXTPROC __glewMultiTexParameteriEXT = NULL;\nPFNGLMULTITEXPARAMETERIVEXTPROC __glewMultiTexParameterivEXT = NULL;\nPFNGLMULTITEXRENDERBUFFEREXTPROC __glewMultiTexRenderbufferEXT = NULL;\nPFNGLMULTITEXSUBIMAGE1DEXTPROC __glewMultiTexSubImage1DEXT = NULL;\nPFNGLMULTITEXSUBIMAGE2DEXTPROC __glewMultiTexSubImage2DEXT = NULL;\nPFNGLMULTITEXSUBIMAGE3DEXTPROC __glewMultiTexSubImage3DEXT = NULL;\nPFNGLNAMEDBUFFERDATAEXTPROC __glewNamedBufferDataEXT = NULL;\nPFNGLNAMEDBUFFERSUBDATAEXTPROC __glewNamedBufferSubDataEXT = NULL;\nPFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC __glewNamedFramebufferRenderbufferEXT = NULL;\nPFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC __glewNamedFramebufferTexture1DEXT = NULL;\nPFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC __glewNamedFramebufferTexture2DEXT = NULL;\nPFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC __glewNamedFramebufferTexture3DEXT = NULL;\nPFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC __glewNamedFramebufferTextureEXT = NULL;\nPFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC __glewNamedFramebufferTextureFaceEXT = NULL;\nPFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC __glewNamedFramebufferTextureLayerEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC __glewNamedProgramLocalParameter4dEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC __glewNamedProgramLocalParameter4dvEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC __glewNamedProgramLocalParameter4fEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC __glewNamedProgramLocalParameter4fvEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC __glewNamedProgramLocalParameterI4iEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC __glewNamedProgramLocalParameterI4ivEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC __glewNamedProgramLocalParameterI4uiEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC __glewNamedProgramLocalParameterI4uivEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC __glewNamedProgramLocalParameters4fvEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC __glewNamedProgramLocalParametersI4ivEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC __glewNamedProgramLocalParametersI4uivEXT = NULL;\nPFNGLNAMEDPROGRAMSTRINGEXTPROC __glewNamedProgramStringEXT = NULL;\nPFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC __glewNamedRenderbufferStorageEXT = NULL;\nPFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC __glewNamedRenderbufferStorageMultisampleCoverageEXT = NULL;\nPFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewNamedRenderbufferStorageMultisampleEXT = NULL;\nPFNGLPROGRAMUNIFORM1FEXTPROC __glewProgramUniform1fEXT = NULL;\nPFNGLPROGRAMUNIFORM1FVEXTPROC __glewProgramUniform1fvEXT = NULL;\nPFNGLPROGRAMUNIFORM1IEXTPROC __glewProgramUniform1iEXT = NULL;\nPFNGLPROGRAMUNIFORM1IVEXTPROC __glewProgramUniform1ivEXT = NULL;\nPFNGLPROGRAMUNIFORM1UIEXTPROC __glewProgramUniform1uiEXT = NULL;\nPFNGLPROGRAMUNIFORM1UIVEXTPROC __glewProgramUniform1uivEXT = NULL;\nPFNGLPROGRAMUNIFORM2FEXTPROC __glewProgramUniform2fEXT = NULL;\nPFNGLPROGRAMUNIFORM2FVEXTPROC __glewProgramUniform2fvEXT = NULL;\nPFNGLPROGRAMUNIFORM2IEXTPROC __glewProgramUniform2iEXT = NULL;\nPFNGLPROGRAMUNIFORM2IVEXTPROC __glewProgramUniform2ivEXT = NULL;\nPFNGLPROGRAMUNIFORM2UIEXTPROC __glewProgramUniform2uiEXT = NULL;\nPFNGLPROGRAMUNIFORM2UIVEXTPROC __glewProgramUniform2uivEXT = NULL;\nPFNGLPROGRAMUNIFORM3FEXTPROC __glewProgramUniform3fEXT = NULL;\nPFNGLPROGRAMUNIFORM3FVEXTPROC __glewProgramUniform3fvEXT = NULL;\nPFNGLPROGRAMUNIFORM3IEXTPROC __glewProgramUniform3iEXT = NULL;\nPFNGLPROGRAMUNIFORM3IVEXTPROC __glewProgramUniform3ivEXT = NULL;\nPFNGLPROGRAMUNIFORM3UIEXTPROC __glewProgramUniform3uiEXT = NULL;\nPFNGLPROGRAMUNIFORM3UIVEXTPROC __glewProgramUniform3uivEXT = NULL;\nPFNGLPROGRAMUNIFORM4FEXTPROC __glewProgramUniform4fEXT = NULL;\nPFNGLPROGRAMUNIFORM4FVEXTPROC __glewProgramUniform4fvEXT = NULL;\nPFNGLPROGRAMUNIFORM4IEXTPROC __glewProgramUniform4iEXT = NULL;\nPFNGLPROGRAMUNIFORM4IVEXTPROC __glewProgramUniform4ivEXT = NULL;\nPFNGLPROGRAMUNIFORM4UIEXTPROC __glewProgramUniform4uiEXT = NULL;\nPFNGLPROGRAMUNIFORM4UIVEXTPROC __glewProgramUniform4uivEXT = NULL;\nPFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC __glewProgramUniformMatrix2fvEXT = NULL;\nPFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC __glewProgramUniformMatrix2x3fvEXT = NULL;\nPFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC __glewProgramUniformMatrix2x4fvEXT = NULL;\nPFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC __glewProgramUniformMatrix3fvEXT = NULL;\nPFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC __glewProgramUniformMatrix3x2fvEXT = NULL;\nPFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC __glewProgramUniformMatrix3x4fvEXT = NULL;\nPFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC __glewProgramUniformMatrix4fvEXT = NULL;\nPFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC __glewProgramUniformMatrix4x2fvEXT = NULL;\nPFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC __glewProgramUniformMatrix4x3fvEXT = NULL;\nPFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC __glewPushClientAttribDefaultEXT = NULL;\nPFNGLTEXTUREBUFFEREXTPROC __glewTextureBufferEXT = NULL;\nPFNGLTEXTUREIMAGE1DEXTPROC __glewTextureImage1DEXT = NULL;\nPFNGLTEXTUREIMAGE2DEXTPROC __glewTextureImage2DEXT = NULL;\nPFNGLTEXTUREIMAGE3DEXTPROC __glewTextureImage3DEXT = NULL;\nPFNGLTEXTUREPARAMETERIIVEXTPROC __glewTextureParameterIivEXT = NULL;\nPFNGLTEXTUREPARAMETERIUIVEXTPROC __glewTextureParameterIuivEXT = NULL;\nPFNGLTEXTUREPARAMETERFEXTPROC __glewTextureParameterfEXT = NULL;\nPFNGLTEXTUREPARAMETERFVEXTPROC __glewTextureParameterfvEXT = NULL;\nPFNGLTEXTUREPARAMETERIEXTPROC __glewTextureParameteriEXT = NULL;\nPFNGLTEXTUREPARAMETERIVEXTPROC __glewTextureParameterivEXT = NULL;\nPFNGLTEXTURERENDERBUFFEREXTPROC __glewTextureRenderbufferEXT = NULL;\nPFNGLTEXTURESUBIMAGE1DEXTPROC __glewTextureSubImage1DEXT = NULL;\nPFNGLTEXTURESUBIMAGE2DEXTPROC __glewTextureSubImage2DEXT = NULL;\nPFNGLTEXTURESUBIMAGE3DEXTPROC __glewTextureSubImage3DEXT = NULL;\nPFNGLUNMAPNAMEDBUFFEREXTPROC __glewUnmapNamedBufferEXT = NULL;\n\nPFNGLCOLORMASKINDEXEDEXTPROC __glewColorMaskIndexedEXT = NULL;\nPFNGLDISABLEINDEXEDEXTPROC __glewDisableIndexedEXT = NULL;\nPFNGLENABLEINDEXEDEXTPROC __glewEnableIndexedEXT = NULL;\nPFNGLGETBOOLEANINDEXEDVEXTPROC __glewGetBooleanIndexedvEXT = NULL;\nPFNGLGETINTEGERINDEXEDVEXTPROC __glewGetIntegerIndexedvEXT = NULL;\nPFNGLISENABLEDINDEXEDEXTPROC __glewIsEnabledIndexedEXT = NULL;\n\nPFNGLDRAWARRAYSINSTANCEDEXTPROC __glewDrawArraysInstancedEXT = NULL;\nPFNGLDRAWELEMENTSINSTANCEDEXTPROC __glewDrawElementsInstancedEXT = NULL;\n\nPFNGLDRAWRANGEELEMENTSEXTPROC __glewDrawRangeElementsEXT = NULL;\n\nPFNGLFOGCOORDPOINTEREXTPROC __glewFogCoordPointerEXT = NULL;\nPFNGLFOGCOORDDEXTPROC __glewFogCoorddEXT = NULL;\nPFNGLFOGCOORDDVEXTPROC __glewFogCoorddvEXT = NULL;\nPFNGLFOGCOORDFEXTPROC __glewFogCoordfEXT = NULL;\nPFNGLFOGCOORDFVEXTPROC __glewFogCoordfvEXT = NULL;\n\nPFNGLFRAGMENTCOLORMATERIALEXTPROC __glewFragmentColorMaterialEXT = NULL;\nPFNGLFRAGMENTLIGHTMODELFEXTPROC __glewFragmentLightModelfEXT = NULL;\nPFNGLFRAGMENTLIGHTMODELFVEXTPROC __glewFragmentLightModelfvEXT = NULL;\nPFNGLFRAGMENTLIGHTMODELIEXTPROC __glewFragmentLightModeliEXT = NULL;\nPFNGLFRAGMENTLIGHTMODELIVEXTPROC __glewFragmentLightModelivEXT = NULL;\nPFNGLFRAGMENTLIGHTFEXTPROC __glewFragmentLightfEXT = NULL;\nPFNGLFRAGMENTLIGHTFVEXTPROC __glewFragmentLightfvEXT = NULL;\nPFNGLFRAGMENTLIGHTIEXTPROC __glewFragmentLightiEXT = NULL;\nPFNGLFRAGMENTLIGHTIVEXTPROC __glewFragmentLightivEXT = NULL;\nPFNGLFRAGMENTMATERIALFEXTPROC __glewFragmentMaterialfEXT = NULL;\nPFNGLFRAGMENTMATERIALFVEXTPROC __glewFragmentMaterialfvEXT = NULL;\nPFNGLFRAGMENTMATERIALIEXTPROC __glewFragmentMaterialiEXT = NULL;\nPFNGLFRAGMENTMATERIALIVEXTPROC __glewFragmentMaterialivEXT = NULL;\nPFNGLGETFRAGMENTLIGHTFVEXTPROC __glewGetFragmentLightfvEXT = NULL;\nPFNGLGETFRAGMENTLIGHTIVEXTPROC __glewGetFragmentLightivEXT = NULL;\nPFNGLGETFRAGMENTMATERIALFVEXTPROC __glewGetFragmentMaterialfvEXT = NULL;\nPFNGLGETFRAGMENTMATERIALIVEXTPROC __glewGetFragmentMaterialivEXT = NULL;\nPFNGLLIGHTENVIEXTPROC __glewLightEnviEXT = NULL;\n\nPFNGLBLITFRAMEBUFFEREXTPROC __glewBlitFramebufferEXT = NULL;\n\nPFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewRenderbufferStorageMultisampleEXT = NULL;\n\nPFNGLBINDFRAMEBUFFEREXTPROC __glewBindFramebufferEXT = NULL;\nPFNGLBINDRENDERBUFFEREXTPROC __glewBindRenderbufferEXT = NULL;\nPFNGLCHECKFRAMEBUFFERSTATUSEXTPROC __glewCheckFramebufferStatusEXT = NULL;\nPFNGLDELETEFRAMEBUFFERSEXTPROC __glewDeleteFramebuffersEXT = NULL;\nPFNGLDELETERENDERBUFFERSEXTPROC __glewDeleteRenderbuffersEXT = NULL;\nPFNGLFRAMEBUFFERRENDERBUFFEREXTPROC __glewFramebufferRenderbufferEXT = NULL;\nPFNGLFRAMEBUFFERTEXTURE1DEXTPROC __glewFramebufferTexture1DEXT = NULL;\nPFNGLFRAMEBUFFERTEXTURE2DEXTPROC __glewFramebufferTexture2DEXT = NULL;\nPFNGLFRAMEBUFFERTEXTURE3DEXTPROC __glewFramebufferTexture3DEXT = NULL;\nPFNGLGENFRAMEBUFFERSEXTPROC __glewGenFramebuffersEXT = NULL;\nPFNGLGENRENDERBUFFERSEXTPROC __glewGenRenderbuffersEXT = NULL;\nPFNGLGENERATEMIPMAPEXTPROC __glewGenerateMipmapEXT = NULL;\nPFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetFramebufferAttachmentParameterivEXT = NULL;\nPFNGLGETRENDERBUFFERPARAMETERIVEXTPROC __glewGetRenderbufferParameterivEXT = NULL;\nPFNGLISFRAMEBUFFEREXTPROC __glewIsFramebufferEXT = NULL;\nPFNGLISRENDERBUFFEREXTPROC __glewIsRenderbufferEXT = NULL;\nPFNGLRENDERBUFFERSTORAGEEXTPROC __glewRenderbufferStorageEXT = NULL;\n\nPFNGLFRAMEBUFFERTEXTUREEXTPROC __glewFramebufferTextureEXT = NULL;\nPFNGLFRAMEBUFFERTEXTUREFACEEXTPROC __glewFramebufferTextureFaceEXT = NULL;\nPFNGLFRAMEBUFFERTEXTURELAYEREXTPROC __glewFramebufferTextureLayerEXT = NULL;\nPFNGLPROGRAMPARAMETERIEXTPROC __glewProgramParameteriEXT = NULL;\n\nPFNGLPROGRAMENVPARAMETERS4FVEXTPROC __glewProgramEnvParameters4fvEXT = NULL;\nPFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC __glewProgramLocalParameters4fvEXT = NULL;\n\nPFNGLBINDFRAGDATALOCATIONEXTPROC __glewBindFragDataLocationEXT = NULL;\nPFNGLGETFRAGDATALOCATIONEXTPROC __glewGetFragDataLocationEXT = NULL;\nPFNGLGETUNIFORMUIVEXTPROC __glewGetUniformuivEXT = NULL;\nPFNGLGETVERTEXATTRIBIIVEXTPROC __glewGetVertexAttribIivEXT = NULL;\nPFNGLGETVERTEXATTRIBIUIVEXTPROC __glewGetVertexAttribIuivEXT = NULL;\nPFNGLUNIFORM1UIEXTPROC __glewUniform1uiEXT = NULL;\nPFNGLUNIFORM1UIVEXTPROC __glewUniform1uivEXT = NULL;\nPFNGLUNIFORM2UIEXTPROC __glewUniform2uiEXT = NULL;\nPFNGLUNIFORM2UIVEXTPROC __glewUniform2uivEXT = NULL;\nPFNGLUNIFORM3UIEXTPROC __glewUniform3uiEXT = NULL;\nPFNGLUNIFORM3UIVEXTPROC __glewUniform3uivEXT = NULL;\nPFNGLUNIFORM4UIEXTPROC __glewUniform4uiEXT = NULL;\nPFNGLUNIFORM4UIVEXTPROC __glewUniform4uivEXT = NULL;\nPFNGLVERTEXATTRIBI1IEXTPROC __glewVertexAttribI1iEXT = NULL;\nPFNGLVERTEXATTRIBI1IVEXTPROC __glewVertexAttribI1ivEXT = NULL;\nPFNGLVERTEXATTRIBI1UIEXTPROC __glewVertexAttribI1uiEXT = NULL;\nPFNGLVERTEXATTRIBI1UIVEXTPROC __glewVertexAttribI1uivEXT = NULL;\nPFNGLVERTEXATTRIBI2IEXTPROC __glewVertexAttribI2iEXT = NULL;\nPFNGLVERTEXATTRIBI2IVEXTPROC __glewVertexAttribI2ivEXT = NULL;\nPFNGLVERTEXATTRIBI2UIEXTPROC __glewVertexAttribI2uiEXT = NULL;\nPFNGLVERTEXATTRIBI2UIVEXTPROC __glewVertexAttribI2uivEXT = NULL;\nPFNGLVERTEXATTRIBI3IEXTPROC __glewVertexAttribI3iEXT = NULL;\nPFNGLVERTEXATTRIBI3IVEXTPROC __glewVertexAttribI3ivEXT = NULL;\nPFNGLVERTEXATTRIBI3UIEXTPROC __glewVertexAttribI3uiEXT = NULL;\nPFNGLVERTEXATTRIBI3UIVEXTPROC __glewVertexAttribI3uivEXT = NULL;\nPFNGLVERTEXATTRIBI4BVEXTPROC __glewVertexAttribI4bvEXT = NULL;\nPFNGLVERTEXATTRIBI4IEXTPROC __glewVertexAttribI4iEXT = NULL;\nPFNGLVERTEXATTRIBI4IVEXTPROC __glewVertexAttribI4ivEXT = NULL;\nPFNGLVERTEXATTRIBI4SVEXTPROC __glewVertexAttribI4svEXT = NULL;\nPFNGLVERTEXATTRIBI4UBVEXTPROC __glewVertexAttribI4ubvEXT = NULL;\nPFNGLVERTEXATTRIBI4UIEXTPROC __glewVertexAttribI4uiEXT = NULL;\nPFNGLVERTEXATTRIBI4UIVEXTPROC __glewVertexAttribI4uivEXT = NULL;\nPFNGLVERTEXATTRIBI4USVEXTPROC __glewVertexAttribI4usvEXT = NULL;\nPFNGLVERTEXATTRIBIPOINTEREXTPROC __glewVertexAttribIPointerEXT = NULL;\n\nPFNGLGETHISTOGRAMEXTPROC __glewGetHistogramEXT = NULL;\nPFNGLGETHISTOGRAMPARAMETERFVEXTPROC __glewGetHistogramParameterfvEXT = NULL;\nPFNGLGETHISTOGRAMPARAMETERIVEXTPROC __glewGetHistogramParameterivEXT = NULL;\nPFNGLGETMINMAXEXTPROC __glewGetMinmaxEXT = NULL;\nPFNGLGETMINMAXPARAMETERFVEXTPROC __glewGetMinmaxParameterfvEXT = NULL;\nPFNGLGETMINMAXPARAMETERIVEXTPROC __glewGetMinmaxParameterivEXT = NULL;\nPFNGLHISTOGRAMEXTPROC __glewHistogramEXT = NULL;\nPFNGLMINMAXEXTPROC __glewMinmaxEXT = NULL;\nPFNGLRESETHISTOGRAMEXTPROC __glewResetHistogramEXT = NULL;\nPFNGLRESETMINMAXEXTPROC __glewResetMinmaxEXT = NULL;\n\nPFNGLINDEXFUNCEXTPROC __glewIndexFuncEXT = NULL;\n\nPFNGLINDEXMATERIALEXTPROC __glewIndexMaterialEXT = NULL;\n\nPFNGLAPPLYTEXTUREEXTPROC __glewApplyTextureEXT = NULL;\nPFNGLTEXTURELIGHTEXTPROC __glewTextureLightEXT = NULL;\nPFNGLTEXTUREMATERIALEXTPROC __glewTextureMaterialEXT = NULL;\n\nPFNGLMULTIDRAWARRAYSEXTPROC __glewMultiDrawArraysEXT = NULL;\nPFNGLMULTIDRAWELEMENTSEXTPROC __glewMultiDrawElementsEXT = NULL;\n\nPFNGLSAMPLEMASKEXTPROC __glewSampleMaskEXT = NULL;\nPFNGLSAMPLEPATTERNEXTPROC __glewSamplePatternEXT = NULL;\n\nPFNGLCOLORTABLEEXTPROC __glewColorTableEXT = NULL;\nPFNGLGETCOLORTABLEEXTPROC __glewGetColorTableEXT = NULL;\nPFNGLGETCOLORTABLEPARAMETERFVEXTPROC __glewGetColorTableParameterfvEXT = NULL;\nPFNGLGETCOLORTABLEPARAMETERIVEXTPROC __glewGetColorTableParameterivEXT = NULL;\n\nPFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC __glewGetPixelTransformParameterfvEXT = NULL;\nPFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC __glewGetPixelTransformParameterivEXT = NULL;\nPFNGLPIXELTRANSFORMPARAMETERFEXTPROC __glewPixelTransformParameterfEXT = NULL;\nPFNGLPIXELTRANSFORMPARAMETERFVEXTPROC __glewPixelTransformParameterfvEXT = NULL;\nPFNGLPIXELTRANSFORMPARAMETERIEXTPROC __glewPixelTransformParameteriEXT = NULL;\nPFNGLPIXELTRANSFORMPARAMETERIVEXTPROC __glewPixelTransformParameterivEXT = NULL;\n\nPFNGLPOINTPARAMETERFEXTPROC __glewPointParameterfEXT = NULL;\nPFNGLPOINTPARAMETERFVEXTPROC __glewPointParameterfvEXT = NULL;\n\nPFNGLPOLYGONOFFSETEXTPROC __glewPolygonOffsetEXT = NULL;\n\nPFNGLBEGINSCENEEXTPROC __glewBeginSceneEXT = NULL;\nPFNGLENDSCENEEXTPROC __glewEndSceneEXT = NULL;\n\nPFNGLSECONDARYCOLOR3BEXTPROC __glewSecondaryColor3bEXT = NULL;\nPFNGLSECONDARYCOLOR3BVEXTPROC __glewSecondaryColor3bvEXT = NULL;\nPFNGLSECONDARYCOLOR3DEXTPROC __glewSecondaryColor3dEXT = NULL;\nPFNGLSECONDARYCOLOR3DVEXTPROC __glewSecondaryColor3dvEXT = NULL;\nPFNGLSECONDARYCOLOR3FEXTPROC __glewSecondaryColor3fEXT = NULL;\nPFNGLSECONDARYCOLOR3FVEXTPROC __glewSecondaryColor3fvEXT = NULL;\nPFNGLSECONDARYCOLOR3IEXTPROC __glewSecondaryColor3iEXT = NULL;\nPFNGLSECONDARYCOLOR3IVEXTPROC __glewSecondaryColor3ivEXT = NULL;\nPFNGLSECONDARYCOLOR3SEXTPROC __glewSecondaryColor3sEXT = NULL;\nPFNGLSECONDARYCOLOR3SVEXTPROC __glewSecondaryColor3svEXT = NULL;\nPFNGLSECONDARYCOLOR3UBEXTPROC __glewSecondaryColor3ubEXT = NULL;\nPFNGLSECONDARYCOLOR3UBVEXTPROC __glewSecondaryColor3ubvEXT = NULL;\nPFNGLSECONDARYCOLOR3UIEXTPROC __glewSecondaryColor3uiEXT = NULL;\nPFNGLSECONDARYCOLOR3UIVEXTPROC __glewSecondaryColor3uivEXT = NULL;\nPFNGLSECONDARYCOLOR3USEXTPROC __glewSecondaryColor3usEXT = NULL;\nPFNGLSECONDARYCOLOR3USVEXTPROC __glewSecondaryColor3usvEXT = NULL;\nPFNGLSECONDARYCOLORPOINTEREXTPROC __glewSecondaryColorPointerEXT = NULL;\n\nPFNGLACTIVESTENCILFACEEXTPROC __glewActiveStencilFaceEXT = NULL;\n\nPFNGLTEXSUBIMAGE1DEXTPROC __glewTexSubImage1DEXT = NULL;\nPFNGLTEXSUBIMAGE2DEXTPROC __glewTexSubImage2DEXT = NULL;\nPFNGLTEXSUBIMAGE3DEXTPROC __glewTexSubImage3DEXT = NULL;\n\nPFNGLTEXIMAGE3DEXTPROC __glewTexImage3DEXT = NULL;\n\nPFNGLTEXBUFFEREXTPROC __glewTexBufferEXT = NULL;\n\nPFNGLCLEARCOLORIIEXTPROC __glewClearColorIiEXT = NULL;\nPFNGLCLEARCOLORIUIEXTPROC __glewClearColorIuiEXT = NULL;\nPFNGLGETTEXPARAMETERIIVEXTPROC __glewGetTexParameterIivEXT = NULL;\nPFNGLGETTEXPARAMETERIUIVEXTPROC __glewGetTexParameterIuivEXT = NULL;\nPFNGLTEXPARAMETERIIVEXTPROC __glewTexParameterIivEXT = NULL;\nPFNGLTEXPARAMETERIUIVEXTPROC __glewTexParameterIuivEXT = NULL;\n\nPFNGLARETEXTURESRESIDENTEXTPROC __glewAreTexturesResidentEXT = NULL;\nPFNGLBINDTEXTUREEXTPROC __glewBindTextureEXT = NULL;\nPFNGLDELETETEXTURESEXTPROC __glewDeleteTexturesEXT = NULL;\nPFNGLGENTEXTURESEXTPROC __glewGenTexturesEXT = NULL;\nPFNGLISTEXTUREEXTPROC __glewIsTextureEXT = NULL;\nPFNGLPRIORITIZETEXTURESEXTPROC __glewPrioritizeTexturesEXT = NULL;\n\nPFNGLTEXTURENORMALEXTPROC __glewTextureNormalEXT = NULL;\n\nPFNGLGETQUERYOBJECTI64VEXTPROC __glewGetQueryObjecti64vEXT = NULL;\nPFNGLGETQUERYOBJECTUI64VEXTPROC __glewGetQueryObjectui64vEXT = NULL;\n\nPFNGLBEGINTRANSFORMFEEDBACKEXTPROC __glewBeginTransformFeedbackEXT = NULL;\nPFNGLBINDBUFFERBASEEXTPROC __glewBindBufferBaseEXT = NULL;\nPFNGLBINDBUFFEROFFSETEXTPROC __glewBindBufferOffsetEXT = NULL;\nPFNGLBINDBUFFERRANGEEXTPROC __glewBindBufferRangeEXT = NULL;\nPFNGLENDTRANSFORMFEEDBACKEXTPROC __glewEndTransformFeedbackEXT = NULL;\nPFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC __glewGetTransformFeedbackVaryingEXT = NULL;\nPFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC __glewTransformFeedbackVaryingsEXT = NULL;\n\nPFNGLARRAYELEMENTEXTPROC __glewArrayElementEXT = NULL;\nPFNGLCOLORPOINTEREXTPROC __glewColorPointerEXT = NULL;\nPFNGLDRAWARRAYSEXTPROC __glewDrawArraysEXT = NULL;\nPFNGLEDGEFLAGPOINTEREXTPROC __glewEdgeFlagPointerEXT = NULL;\nPFNGLGETPOINTERVEXTPROC __glewGetPointervEXT = NULL;\nPFNGLINDEXPOINTEREXTPROC __glewIndexPointerEXT = NULL;\nPFNGLNORMALPOINTEREXTPROC __glewNormalPointerEXT = NULL;\nPFNGLTEXCOORDPOINTEREXTPROC __glewTexCoordPointerEXT = NULL;\nPFNGLVERTEXPOINTEREXTPROC __glewVertexPointerEXT = NULL;\n\nPFNGLBEGINVERTEXSHADEREXTPROC __glewBeginVertexShaderEXT = NULL;\nPFNGLBINDLIGHTPARAMETEREXTPROC __glewBindLightParameterEXT = NULL;\nPFNGLBINDMATERIALPARAMETEREXTPROC __glewBindMaterialParameterEXT = NULL;\nPFNGLBINDPARAMETEREXTPROC __glewBindParameterEXT = NULL;\nPFNGLBINDTEXGENPARAMETEREXTPROC __glewBindTexGenParameterEXT = NULL;\nPFNGLBINDTEXTUREUNITPARAMETEREXTPROC __glewBindTextureUnitParameterEXT = NULL;\nPFNGLBINDVERTEXSHADEREXTPROC __glewBindVertexShaderEXT = NULL;\nPFNGLDELETEVERTEXSHADEREXTPROC __glewDeleteVertexShaderEXT = NULL;\nPFNGLDISABLEVARIANTCLIENTSTATEEXTPROC __glewDisableVariantClientStateEXT = NULL;\nPFNGLENABLEVARIANTCLIENTSTATEEXTPROC __glewEnableVariantClientStateEXT = NULL;\nPFNGLENDVERTEXSHADEREXTPROC __glewEndVertexShaderEXT = NULL;\nPFNGLEXTRACTCOMPONENTEXTPROC __glewExtractComponentEXT = NULL;\nPFNGLGENSYMBOLSEXTPROC __glewGenSymbolsEXT = NULL;\nPFNGLGENVERTEXSHADERSEXTPROC __glewGenVertexShadersEXT = NULL;\nPFNGLGETINVARIANTBOOLEANVEXTPROC __glewGetInvariantBooleanvEXT = NULL;\nPFNGLGETINVARIANTFLOATVEXTPROC __glewGetInvariantFloatvEXT = NULL;\nPFNGLGETINVARIANTINTEGERVEXTPROC __glewGetInvariantIntegervEXT = NULL;\nPFNGLGETLOCALCONSTANTBOOLEANVEXTPROC __glewGetLocalConstantBooleanvEXT = NULL;\nPFNGLGETLOCALCONSTANTFLOATVEXTPROC __glewGetLocalConstantFloatvEXT = NULL;\nPFNGLGETLOCALCONSTANTINTEGERVEXTPROC __glewGetLocalConstantIntegervEXT = NULL;\nPFNGLGETVARIANTBOOLEANVEXTPROC __glewGetVariantBooleanvEXT = NULL;\nPFNGLGETVARIANTFLOATVEXTPROC __glewGetVariantFloatvEXT = NULL;\nPFNGLGETVARIANTINTEGERVEXTPROC __glewGetVariantIntegervEXT = NULL;\nPFNGLGETVARIANTPOINTERVEXTPROC __glewGetVariantPointervEXT = NULL;\nPFNGLINSERTCOMPONENTEXTPROC __glewInsertComponentEXT = NULL;\nPFNGLISVARIANTENABLEDEXTPROC __glewIsVariantEnabledEXT = NULL;\nPFNGLSETINVARIANTEXTPROC __glewSetInvariantEXT = NULL;\nPFNGLSETLOCALCONSTANTEXTPROC __glewSetLocalConstantEXT = NULL;\nPFNGLSHADEROP1EXTPROC __glewShaderOp1EXT = NULL;\nPFNGLSHADEROP2EXTPROC __glewShaderOp2EXT = NULL;\nPFNGLSHADEROP3EXTPROC __glewShaderOp3EXT = NULL;\nPFNGLSWIZZLEEXTPROC __glewSwizzleEXT = NULL;\nPFNGLVARIANTPOINTEREXTPROC __glewVariantPointerEXT = NULL;\nPFNGLVARIANTBVEXTPROC __glewVariantbvEXT = NULL;\nPFNGLVARIANTDVEXTPROC __glewVariantdvEXT = NULL;\nPFNGLVARIANTFVEXTPROC __glewVariantfvEXT = NULL;\nPFNGLVARIANTIVEXTPROC __glewVariantivEXT = NULL;\nPFNGLVARIANTSVEXTPROC __glewVariantsvEXT = NULL;\nPFNGLVARIANTUBVEXTPROC __glewVariantubvEXT = NULL;\nPFNGLVARIANTUIVEXTPROC __glewVariantuivEXT = NULL;\nPFNGLVARIANTUSVEXTPROC __glewVariantusvEXT = NULL;\nPFNGLWRITEMASKEXTPROC __glewWriteMaskEXT = NULL;\n\nPFNGLVERTEXWEIGHTPOINTEREXTPROC __glewVertexWeightPointerEXT = NULL;\nPFNGLVERTEXWEIGHTFEXTPROC __glewVertexWeightfEXT = NULL;\nPFNGLVERTEXWEIGHTFVEXTPROC __glewVertexWeightfvEXT = NULL;\n\nPFNGLFRAMETERMINATORGREMEDYPROC __glewFrameTerminatorGREMEDY = NULL;\n\nPFNGLSTRINGMARKERGREMEDYPROC __glewStringMarkerGREMEDY = NULL;\n\nPFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC __glewGetImageTransformParameterfvHP = NULL;\nPFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC __glewGetImageTransformParameterivHP = NULL;\nPFNGLIMAGETRANSFORMPARAMETERFHPPROC __glewImageTransformParameterfHP = NULL;\nPFNGLIMAGETRANSFORMPARAMETERFVHPPROC __glewImageTransformParameterfvHP = NULL;\nPFNGLIMAGETRANSFORMPARAMETERIHPPROC __glewImageTransformParameteriHP = NULL;\nPFNGLIMAGETRANSFORMPARAMETERIVHPPROC __glewImageTransformParameterivHP = NULL;\n\nPFNGLMULTIMODEDRAWARRAYSIBMPROC __glewMultiModeDrawArraysIBM = NULL;\nPFNGLMULTIMODEDRAWELEMENTSIBMPROC __glewMultiModeDrawElementsIBM = NULL;\n\nPFNGLCOLORPOINTERLISTIBMPROC __glewColorPointerListIBM = NULL;\nPFNGLEDGEFLAGPOINTERLISTIBMPROC __glewEdgeFlagPointerListIBM = NULL;\nPFNGLFOGCOORDPOINTERLISTIBMPROC __glewFogCoordPointerListIBM = NULL;\nPFNGLINDEXPOINTERLISTIBMPROC __glewIndexPointerListIBM = NULL;\nPFNGLNORMALPOINTERLISTIBMPROC __glewNormalPointerListIBM = NULL;\nPFNGLSECONDARYCOLORPOINTERLISTIBMPROC __glewSecondaryColorPointerListIBM = NULL;\nPFNGLTEXCOORDPOINTERLISTIBMPROC __glewTexCoordPointerListIBM = NULL;\nPFNGLVERTEXPOINTERLISTIBMPROC __glewVertexPointerListIBM = NULL;\n\nPFNGLCOLORPOINTERVINTELPROC __glewColorPointervINTEL = NULL;\nPFNGLNORMALPOINTERVINTELPROC __glewNormalPointervINTEL = NULL;\nPFNGLTEXCOORDPOINTERVINTELPROC __glewTexCoordPointervINTEL = NULL;\nPFNGLVERTEXPOINTERVINTELPROC __glewVertexPointervINTEL = NULL;\n\nPFNGLTEXSCISSORFUNCINTELPROC __glewTexScissorFuncINTEL = NULL;\nPFNGLTEXSCISSORINTELPROC __glewTexScissorINTEL = NULL;\n\nPFNGLBUFFERREGIONENABLEDEXTPROC __glewBufferRegionEnabledEXT = NULL;\nPFNGLDELETEBUFFERREGIONEXTPROC __glewDeleteBufferRegionEXT = NULL;\nPFNGLDRAWBUFFERREGIONEXTPROC __glewDrawBufferRegionEXT = NULL;\nPFNGLNEWBUFFERREGIONEXTPROC __glewNewBufferRegionEXT = NULL;\nPFNGLREADBUFFERREGIONEXTPROC __glewReadBufferRegionEXT = NULL;\n\nPFNGLRESIZEBUFFERSMESAPROC __glewResizeBuffersMESA = NULL;\n\nPFNGLWINDOWPOS2DMESAPROC __glewWindowPos2dMESA = NULL;\nPFNGLWINDOWPOS2DVMESAPROC __glewWindowPos2dvMESA = NULL;\nPFNGLWINDOWPOS2FMESAPROC __glewWindowPos2fMESA = NULL;\nPFNGLWINDOWPOS2FVMESAPROC __glewWindowPos2fvMESA = NULL;\nPFNGLWINDOWPOS2IMESAPROC __glewWindowPos2iMESA = NULL;\nPFNGLWINDOWPOS2IVMESAPROC __glewWindowPos2ivMESA = NULL;\nPFNGLWINDOWPOS2SMESAPROC __glewWindowPos2sMESA = NULL;\nPFNGLWINDOWPOS2SVMESAPROC __glewWindowPos2svMESA = NULL;\nPFNGLWINDOWPOS3DMESAPROC __glewWindowPos3dMESA = NULL;\nPFNGLWINDOWPOS3DVMESAPROC __glewWindowPos3dvMESA = NULL;\nPFNGLWINDOWPOS3FMESAPROC __glewWindowPos3fMESA = NULL;\nPFNGLWINDOWPOS3FVMESAPROC __glewWindowPos3fvMESA = NULL;\nPFNGLWINDOWPOS3IMESAPROC __glewWindowPos3iMESA = NULL;\nPFNGLWINDOWPOS3IVMESAPROC __glewWindowPos3ivMESA = NULL;\nPFNGLWINDOWPOS3SMESAPROC __glewWindowPos3sMESA = NULL;\nPFNGLWINDOWPOS3SVMESAPROC __glewWindowPos3svMESA = NULL;\nPFNGLWINDOWPOS4DMESAPROC __glewWindowPos4dMESA = NULL;\nPFNGLWINDOWPOS4DVMESAPROC __glewWindowPos4dvMESA = NULL;\nPFNGLWINDOWPOS4FMESAPROC __glewWindowPos4fMESA = NULL;\nPFNGLWINDOWPOS4FVMESAPROC __glewWindowPos4fvMESA = NULL;\nPFNGLWINDOWPOS4IMESAPROC __glewWindowPos4iMESA = NULL;\nPFNGLWINDOWPOS4IVMESAPROC __glewWindowPos4ivMESA = NULL;\nPFNGLWINDOWPOS4SMESAPROC __glewWindowPos4sMESA = NULL;\nPFNGLWINDOWPOS4SVMESAPROC __glewWindowPos4svMESA = NULL;\n\nPFNGLBEGINCONDITIONALRENDERNVPROC __glewBeginConditionalRenderNV = NULL;\nPFNGLENDCONDITIONALRENDERNVPROC __glewEndConditionalRenderNV = NULL;\n\nPFNGLCLEARDEPTHDNVPROC __glewClearDepthdNV = NULL;\nPFNGLDEPTHBOUNDSDNVPROC __glewDepthBoundsdNV = NULL;\nPFNGLDEPTHRANGEDNVPROC __glewDepthRangedNV = NULL;\n\nPFNGLEVALMAPSNVPROC __glewEvalMapsNV = NULL;\nPFNGLGETMAPATTRIBPARAMETERFVNVPROC __glewGetMapAttribParameterfvNV = NULL;\nPFNGLGETMAPATTRIBPARAMETERIVNVPROC __glewGetMapAttribParameterivNV = NULL;\nPFNGLGETMAPCONTROLPOINTSNVPROC __glewGetMapControlPointsNV = NULL;\nPFNGLGETMAPPARAMETERFVNVPROC __glewGetMapParameterfvNV = NULL;\nPFNGLGETMAPPARAMETERIVNVPROC __glewGetMapParameterivNV = NULL;\nPFNGLMAPCONTROLPOINTSNVPROC __glewMapControlPointsNV = NULL;\nPFNGLMAPPARAMETERFVNVPROC __glewMapParameterfvNV = NULL;\nPFNGLMAPPARAMETERIVNVPROC __glewMapParameterivNV = NULL;\n\nPFNGLGETMULTISAMPLEFVNVPROC __glewGetMultisamplefvNV = NULL;\nPFNGLSAMPLEMASKINDEXEDNVPROC __glewSampleMaskIndexedNV = NULL;\nPFNGLTEXRENDERBUFFERNVPROC __glewTexRenderbufferNV = NULL;\n\nPFNGLDELETEFENCESNVPROC __glewDeleteFencesNV = NULL;\nPFNGLFINISHFENCENVPROC __glewFinishFenceNV = NULL;\nPFNGLGENFENCESNVPROC __glewGenFencesNV = NULL;\nPFNGLGETFENCEIVNVPROC __glewGetFenceivNV = NULL;\nPFNGLISFENCENVPROC __glewIsFenceNV = NULL;\nPFNGLSETFENCENVPROC __glewSetFenceNV = NULL;\nPFNGLTESTFENCENVPROC __glewTestFenceNV = NULL;\n\nPFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC __glewGetProgramNamedParameterdvNV = NULL;\nPFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC __glewGetProgramNamedParameterfvNV = NULL;\nPFNGLPROGRAMNAMEDPARAMETER4DNVPROC __glewProgramNamedParameter4dNV = NULL;\nPFNGLPROGRAMNAMEDPARAMETER4DVNVPROC __glewProgramNamedParameter4dvNV = NULL;\nPFNGLPROGRAMNAMEDPARAMETER4FNVPROC __glewProgramNamedParameter4fNV = NULL;\nPFNGLPROGRAMNAMEDPARAMETER4FVNVPROC __glewProgramNamedParameter4fvNV = NULL;\n\nPFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC __glewRenderbufferStorageMultisampleCoverageNV = NULL;\n\nPFNGLPROGRAMVERTEXLIMITNVPROC __glewProgramVertexLimitNV = NULL;\n\nPFNGLPROGRAMENVPARAMETERI4INVPROC __glewProgramEnvParameterI4iNV = NULL;\nPFNGLPROGRAMENVPARAMETERI4IVNVPROC __glewProgramEnvParameterI4ivNV = NULL;\nPFNGLPROGRAMENVPARAMETERI4UINVPROC __glewProgramEnvParameterI4uiNV = NULL;\nPFNGLPROGRAMENVPARAMETERI4UIVNVPROC __glewProgramEnvParameterI4uivNV = NULL;\nPFNGLPROGRAMENVPARAMETERSI4IVNVPROC __glewProgramEnvParametersI4ivNV = NULL;\nPFNGLPROGRAMENVPARAMETERSI4UIVNVPROC __glewProgramEnvParametersI4uivNV = NULL;\nPFNGLPROGRAMLOCALPARAMETERI4INVPROC __glewProgramLocalParameterI4iNV = NULL;\nPFNGLPROGRAMLOCALPARAMETERI4IVNVPROC __glewProgramLocalParameterI4ivNV = NULL;\nPFNGLPROGRAMLOCALPARAMETERI4UINVPROC __glewProgramLocalParameterI4uiNV = NULL;\nPFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC __glewProgramLocalParameterI4uivNV = NULL;\nPFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC __glewProgramLocalParametersI4ivNV = NULL;\nPFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC __glewProgramLocalParametersI4uivNV = NULL;\n\nPFNGLCOLOR3HNVPROC __glewColor3hNV = NULL;\nPFNGLCOLOR3HVNVPROC __glewColor3hvNV = NULL;\nPFNGLCOLOR4HNVPROC __glewColor4hNV = NULL;\nPFNGLCOLOR4HVNVPROC __glewColor4hvNV = NULL;\nPFNGLFOGCOORDHNVPROC __glewFogCoordhNV = NULL;\nPFNGLFOGCOORDHVNVPROC __glewFogCoordhvNV = NULL;\nPFNGLMULTITEXCOORD1HNVPROC __glewMultiTexCoord1hNV = NULL;\nPFNGLMULTITEXCOORD1HVNVPROC __glewMultiTexCoord1hvNV = NULL;\nPFNGLMULTITEXCOORD2HNVPROC __glewMultiTexCoord2hNV = NULL;\nPFNGLMULTITEXCOORD2HVNVPROC __glewMultiTexCoord2hvNV = NULL;\nPFNGLMULTITEXCOORD3HNVPROC __glewMultiTexCoord3hNV = NULL;\nPFNGLMULTITEXCOORD3HVNVPROC __glewMultiTexCoord3hvNV = NULL;\nPFNGLMULTITEXCOORD4HNVPROC __glewMultiTexCoord4hNV = NULL;\nPFNGLMULTITEXCOORD4HVNVPROC __glewMultiTexCoord4hvNV = NULL;\nPFNGLNORMAL3HNVPROC __glewNormal3hNV = NULL;\nPFNGLNORMAL3HVNVPROC __glewNormal3hvNV = NULL;\nPFNGLSECONDARYCOLOR3HNVPROC __glewSecondaryColor3hNV = NULL;\nPFNGLSECONDARYCOLOR3HVNVPROC __glewSecondaryColor3hvNV = NULL;\nPFNGLTEXCOORD1HNVPROC __glewTexCoord1hNV = NULL;\nPFNGLTEXCOORD1HVNVPROC __glewTexCoord1hvNV = NULL;\nPFNGLTEXCOORD2HNVPROC __glewTexCoord2hNV = NULL;\nPFNGLTEXCOORD2HVNVPROC __glewTexCoord2hvNV = NULL;\nPFNGLTEXCOORD3HNVPROC __glewTexCoord3hNV = NULL;\nPFNGLTEXCOORD3HVNVPROC __glewTexCoord3hvNV = NULL;\nPFNGLTEXCOORD4HNVPROC __glewTexCoord4hNV = NULL;\nPFNGLTEXCOORD4HVNVPROC __glewTexCoord4hvNV = NULL;\nPFNGLVERTEX2HNVPROC __glewVertex2hNV = NULL;\nPFNGLVERTEX2HVNVPROC __glewVertex2hvNV = NULL;\nPFNGLVERTEX3HNVPROC __glewVertex3hNV = NULL;\nPFNGLVERTEX3HVNVPROC __glewVertex3hvNV = NULL;\nPFNGLVERTEX4HNVPROC __glewVertex4hNV = NULL;\nPFNGLVERTEX4HVNVPROC __glewVertex4hvNV = NULL;\nPFNGLVERTEXATTRIB1HNVPROC __glewVertexAttrib1hNV = NULL;\nPFNGLVERTEXATTRIB1HVNVPROC __glewVertexAttrib1hvNV = NULL;\nPFNGLVERTEXATTRIB2HNVPROC __glewVertexAttrib2hNV = NULL;\nPFNGLVERTEXATTRIB2HVNVPROC __glewVertexAttrib2hvNV = NULL;\nPFNGLVERTEXATTRIB3HNVPROC __glewVertexAttrib3hNV = NULL;\nPFNGLVERTEXATTRIB3HVNVPROC __glewVertexAttrib3hvNV = NULL;\nPFNGLVERTEXATTRIB4HNVPROC __glewVertexAttrib4hNV = NULL;\nPFNGLVERTEXATTRIB4HVNVPROC __glewVertexAttrib4hvNV = NULL;\nPFNGLVERTEXATTRIBS1HVNVPROC __glewVertexAttribs1hvNV = NULL;\nPFNGLVERTEXATTRIBS2HVNVPROC __glewVertexAttribs2hvNV = NULL;\nPFNGLVERTEXATTRIBS3HVNVPROC __glewVertexAttribs3hvNV = NULL;\nPFNGLVERTEXATTRIBS4HVNVPROC __glewVertexAttribs4hvNV = NULL;\nPFNGLVERTEXWEIGHTHNVPROC __glewVertexWeighthNV = NULL;\nPFNGLVERTEXWEIGHTHVNVPROC __glewVertexWeighthvNV = NULL;\n\nPFNGLBEGINOCCLUSIONQUERYNVPROC __glewBeginOcclusionQueryNV = NULL;\nPFNGLDELETEOCCLUSIONQUERIESNVPROC __glewDeleteOcclusionQueriesNV = NULL;\nPFNGLENDOCCLUSIONQUERYNVPROC __glewEndOcclusionQueryNV = NULL;\nPFNGLGENOCCLUSIONQUERIESNVPROC __glewGenOcclusionQueriesNV = NULL;\nPFNGLGETOCCLUSIONQUERYIVNVPROC __glewGetOcclusionQueryivNV = NULL;\nPFNGLGETOCCLUSIONQUERYUIVNVPROC __glewGetOcclusionQueryuivNV = NULL;\nPFNGLISOCCLUSIONQUERYNVPROC __glewIsOcclusionQueryNV = NULL;\n\nPFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC __glewProgramBufferParametersIivNV = NULL;\nPFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC __glewProgramBufferParametersIuivNV = NULL;\nPFNGLPROGRAMBUFFERPARAMETERSFVNVPROC __glewProgramBufferParametersfvNV = NULL;\n\nPFNGLFLUSHPIXELDATARANGENVPROC __glewFlushPixelDataRangeNV = NULL;\nPFNGLPIXELDATARANGENVPROC __glewPixelDataRangeNV = NULL;\n\nPFNGLPOINTPARAMETERINVPROC __glewPointParameteriNV = NULL;\nPFNGLPOINTPARAMETERIVNVPROC __glewPointParameterivNV = NULL;\n\nPFNGLGETVIDEOI64VNVPROC __glewGetVideoi64vNV = NULL;\nPFNGLGETVIDEOIVNVPROC __glewGetVideoivNV = NULL;\nPFNGLGETVIDEOUI64VNVPROC __glewGetVideoui64vNV = NULL;\nPFNGLGETVIDEOUIVNVPROC __glewGetVideouivNV = NULL;\nPFNGLPRESENTFRAMEDUALFILLNVPROC __glewPresentFrameDualFillNV = NULL;\nPFNGLPRESENTFRAMEKEYEDNVPROC __glewPresentFrameKeyedNV = NULL;\nPFNGLVIDEOPARAMETERIVNVPROC __glewVideoParameterivNV = NULL;\n\nPFNGLPRIMITIVERESTARTINDEXNVPROC __glewPrimitiveRestartIndexNV = NULL;\nPFNGLPRIMITIVERESTARTNVPROC __glewPrimitiveRestartNV = NULL;\n\nPFNGLCOMBINERINPUTNVPROC __glewCombinerInputNV = NULL;\nPFNGLCOMBINEROUTPUTNVPROC __glewCombinerOutputNV = NULL;\nPFNGLCOMBINERPARAMETERFNVPROC __glewCombinerParameterfNV = NULL;\nPFNGLCOMBINERPARAMETERFVNVPROC __glewCombinerParameterfvNV = NULL;\nPFNGLCOMBINERPARAMETERINVPROC __glewCombinerParameteriNV = NULL;\nPFNGLCOMBINERPARAMETERIVNVPROC __glewCombinerParameterivNV = NULL;\nPFNGLFINALCOMBINERINPUTNVPROC __glewFinalCombinerInputNV = NULL;\nPFNGLGETCOMBINERINPUTPARAMETERFVNVPROC __glewGetCombinerInputParameterfvNV = NULL;\nPFNGLGETCOMBINERINPUTPARAMETERIVNVPROC __glewGetCombinerInputParameterivNV = NULL;\nPFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC __glewGetCombinerOutputParameterfvNV = NULL;\nPFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC __glewGetCombinerOutputParameterivNV = NULL;\nPFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC __glewGetFinalCombinerInputParameterfvNV = NULL;\nPFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC __glewGetFinalCombinerInputParameterivNV = NULL;\n\nPFNGLCOMBINERSTAGEPARAMETERFVNVPROC __glewCombinerStageParameterfvNV = NULL;\nPFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC __glewGetCombinerStageParameterfvNV = NULL;\n\nPFNGLACTIVEVARYINGNVPROC __glewActiveVaryingNV = NULL;\nPFNGLBEGINTRANSFORMFEEDBACKNVPROC __glewBeginTransformFeedbackNV = NULL;\nPFNGLBINDBUFFERBASENVPROC __glewBindBufferBaseNV = NULL;\nPFNGLBINDBUFFEROFFSETNVPROC __glewBindBufferOffsetNV = NULL;\nPFNGLBINDBUFFERRANGENVPROC __glewBindBufferRangeNV = NULL;\nPFNGLENDTRANSFORMFEEDBACKNVPROC __glewEndTransformFeedbackNV = NULL;\nPFNGLGETACTIVEVARYINGNVPROC __glewGetActiveVaryingNV = NULL;\nPFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC __glewGetTransformFeedbackVaryingNV = NULL;\nPFNGLGETVARYINGLOCATIONNVPROC __glewGetVaryingLocationNV = NULL;\nPFNGLTRANSFORMFEEDBACKATTRIBSNVPROC __glewTransformFeedbackAttribsNV = NULL;\nPFNGLTRANSFORMFEEDBACKVARYINGSNVPROC __glewTransformFeedbackVaryingsNV = NULL;\n\nPFNGLFLUSHVERTEXARRAYRANGENVPROC __glewFlushVertexArrayRangeNV = NULL;\nPFNGLVERTEXARRAYRANGENVPROC __glewVertexArrayRangeNV = NULL;\n\nPFNGLAREPROGRAMSRESIDENTNVPROC __glewAreProgramsResidentNV = NULL;\nPFNGLBINDPROGRAMNVPROC __glewBindProgramNV = NULL;\nPFNGLDELETEPROGRAMSNVPROC __glewDeleteProgramsNV = NULL;\nPFNGLEXECUTEPROGRAMNVPROC __glewExecuteProgramNV = NULL;\nPFNGLGENPROGRAMSNVPROC __glewGenProgramsNV = NULL;\nPFNGLGETPROGRAMPARAMETERDVNVPROC __glewGetProgramParameterdvNV = NULL;\nPFNGLGETPROGRAMPARAMETERFVNVPROC __glewGetProgramParameterfvNV = NULL;\nPFNGLGETPROGRAMSTRINGNVPROC __glewGetProgramStringNV = NULL;\nPFNGLGETPROGRAMIVNVPROC __glewGetProgramivNV = NULL;\nPFNGLGETTRACKMATRIXIVNVPROC __glewGetTrackMatrixivNV = NULL;\nPFNGLGETVERTEXATTRIBPOINTERVNVPROC __glewGetVertexAttribPointervNV = NULL;\nPFNGLGETVERTEXATTRIBDVNVPROC __glewGetVertexAttribdvNV = NULL;\nPFNGLGETVERTEXATTRIBFVNVPROC __glewGetVertexAttribfvNV = NULL;\nPFNGLGETVERTEXATTRIBIVNVPROC __glewGetVertexAttribivNV = NULL;\nPFNGLISPROGRAMNVPROC __glewIsProgramNV = NULL;\nPFNGLLOADPROGRAMNVPROC __glewLoadProgramNV = NULL;\nPFNGLPROGRAMPARAMETER4DNVPROC __glewProgramParameter4dNV = NULL;\nPFNGLPROGRAMPARAMETER4DVNVPROC __glewProgramParameter4dvNV = NULL;\nPFNGLPROGRAMPARAMETER4FNVPROC __glewProgramParameter4fNV = NULL;\nPFNGLPROGRAMPARAMETER4FVNVPROC __glewProgramParameter4fvNV = NULL;\nPFNGLPROGRAMPARAMETERS4DVNVPROC __glewProgramParameters4dvNV = NULL;\nPFNGLPROGRAMPARAMETERS4FVNVPROC __glewProgramParameters4fvNV = NULL;\nPFNGLREQUESTRESIDENTPROGRAMSNVPROC __glewRequestResidentProgramsNV = NULL;\nPFNGLTRACKMATRIXNVPROC __glewTrackMatrixNV = NULL;\nPFNGLVERTEXATTRIB1DNVPROC __glewVertexAttrib1dNV = NULL;\nPFNGLVERTEXATTRIB1DVNVPROC __glewVertexAttrib1dvNV = NULL;\nPFNGLVERTEXATTRIB1FNVPROC __glewVertexAttrib1fNV = NULL;\nPFNGLVERTEXATTRIB1FVNVPROC __glewVertexAttrib1fvNV = NULL;\nPFNGLVERTEXATTRIB1SNVPROC __glewVertexAttrib1sNV = NULL;\nPFNGLVERTEXATTRIB1SVNVPROC __glewVertexAttrib1svNV = NULL;\nPFNGLVERTEXATTRIB2DNVPROC __glewVertexAttrib2dNV = NULL;\nPFNGLVERTEXATTRIB2DVNVPROC __glewVertexAttrib2dvNV = NULL;\nPFNGLVERTEXATTRIB2FNVPROC __glewVertexAttrib2fNV = NULL;\nPFNGLVERTEXATTRIB2FVNVPROC __glewVertexAttrib2fvNV = NULL;\nPFNGLVERTEXATTRIB2SNVPROC __glewVertexAttrib2sNV = NULL;\nPFNGLVERTEXATTRIB2SVNVPROC __glewVertexAttrib2svNV = NULL;\nPFNGLVERTEXATTRIB3DNVPROC __glewVertexAttrib3dNV = NULL;\nPFNGLVERTEXATTRIB3DVNVPROC __glewVertexAttrib3dvNV = NULL;\nPFNGLVERTEXATTRIB3FNVPROC __glewVertexAttrib3fNV = NULL;\nPFNGLVERTEXATTRIB3FVNVPROC __glewVertexAttrib3fvNV = NULL;\nPFNGLVERTEXATTRIB3SNVPROC __glewVertexAttrib3sNV = NULL;\nPFNGLVERTEXATTRIB3SVNVPROC __glewVertexAttrib3svNV = NULL;\nPFNGLVERTEXATTRIB4DNVPROC __glewVertexAttrib4dNV = NULL;\nPFNGLVERTEXATTRIB4DVNVPROC __glewVertexAttrib4dvNV = NULL;\nPFNGLVERTEXATTRIB4FNVPROC __glewVertexAttrib4fNV = NULL;\nPFNGLVERTEXATTRIB4FVNVPROC __glewVertexAttrib4fvNV = NULL;\nPFNGLVERTEXATTRIB4SNVPROC __glewVertexAttrib4sNV = NULL;\nPFNGLVERTEXATTRIB4SVNVPROC __glewVertexAttrib4svNV = NULL;\nPFNGLVERTEXATTRIB4UBNVPROC __glewVertexAttrib4ubNV = NULL;\nPFNGLVERTEXATTRIB4UBVNVPROC __glewVertexAttrib4ubvNV = NULL;\nPFNGLVERTEXATTRIBPOINTERNVPROC __glewVertexAttribPointerNV = NULL;\nPFNGLVERTEXATTRIBS1DVNVPROC __glewVertexAttribs1dvNV = NULL;\nPFNGLVERTEXATTRIBS1FVNVPROC __glewVertexAttribs1fvNV = NULL;\nPFNGLVERTEXATTRIBS1SVNVPROC __glewVertexAttribs1svNV = NULL;\nPFNGLVERTEXATTRIBS2DVNVPROC __glewVertexAttribs2dvNV = NULL;\nPFNGLVERTEXATTRIBS2FVNVPROC __glewVertexAttribs2fvNV = NULL;\nPFNGLVERTEXATTRIBS2SVNVPROC __glewVertexAttribs2svNV = NULL;\nPFNGLVERTEXATTRIBS3DVNVPROC __glewVertexAttribs3dvNV = NULL;\nPFNGLVERTEXATTRIBS3FVNVPROC __glewVertexAttribs3fvNV = NULL;\nPFNGLVERTEXATTRIBS3SVNVPROC __glewVertexAttribs3svNV = NULL;\nPFNGLVERTEXATTRIBS4DVNVPROC __glewVertexAttribs4dvNV = NULL;\nPFNGLVERTEXATTRIBS4FVNVPROC __glewVertexAttribs4fvNV = NULL;\nPFNGLVERTEXATTRIBS4SVNVPROC __glewVertexAttribs4svNV = NULL;\nPFNGLVERTEXATTRIBS4UBVNVPROC __glewVertexAttribs4ubvNV = NULL;\n\nPFNGLCLEARDEPTHFOESPROC __glewClearDepthfOES = NULL;\nPFNGLCLIPPLANEFOESPROC __glewClipPlanefOES = NULL;\nPFNGLDEPTHRANGEFOESPROC __glewDepthRangefOES = NULL;\nPFNGLFRUSTUMFOESPROC __glewFrustumfOES = NULL;\nPFNGLGETCLIPPLANEFOESPROC __glewGetClipPlanefOES = NULL;\nPFNGLORTHOFOESPROC __glewOrthofOES = NULL;\n\nPFNGLDETAILTEXFUNCSGISPROC __glewDetailTexFuncSGIS = NULL;\nPFNGLGETDETAILTEXFUNCSGISPROC __glewGetDetailTexFuncSGIS = NULL;\n\nPFNGLFOGFUNCSGISPROC __glewFogFuncSGIS = NULL;\nPFNGLGETFOGFUNCSGISPROC __glewGetFogFuncSGIS = NULL;\n\nPFNGLSAMPLEMASKSGISPROC __glewSampleMaskSGIS = NULL;\nPFNGLSAMPLEPATTERNSGISPROC __glewSamplePatternSGIS = NULL;\n\nPFNGLGETSHARPENTEXFUNCSGISPROC __glewGetSharpenTexFuncSGIS = NULL;\nPFNGLSHARPENTEXFUNCSGISPROC __glewSharpenTexFuncSGIS = NULL;\n\nPFNGLTEXIMAGE4DSGISPROC __glewTexImage4DSGIS = NULL;\nPFNGLTEXSUBIMAGE4DSGISPROC __glewTexSubImage4DSGIS = NULL;\n\nPFNGLGETTEXFILTERFUNCSGISPROC __glewGetTexFilterFuncSGIS = NULL;\nPFNGLTEXFILTERFUNCSGISPROC __glewTexFilterFuncSGIS = NULL;\n\nPFNGLASYNCMARKERSGIXPROC __glewAsyncMarkerSGIX = NULL;\nPFNGLDELETEASYNCMARKERSSGIXPROC __glewDeleteAsyncMarkersSGIX = NULL;\nPFNGLFINISHASYNCSGIXPROC __glewFinishAsyncSGIX = NULL;\nPFNGLGENASYNCMARKERSSGIXPROC __glewGenAsyncMarkersSGIX = NULL;\nPFNGLISASYNCMARKERSGIXPROC __glewIsAsyncMarkerSGIX = NULL;\nPFNGLPOLLASYNCSGIXPROC __glewPollAsyncSGIX = NULL;\n\nPFNGLFLUSHRASTERSGIXPROC __glewFlushRasterSGIX = NULL;\n\nPFNGLTEXTUREFOGSGIXPROC __glewTextureFogSGIX = NULL;\n\nPFNGLFRAGMENTCOLORMATERIALSGIXPROC __glewFragmentColorMaterialSGIX = NULL;\nPFNGLFRAGMENTLIGHTMODELFSGIXPROC __glewFragmentLightModelfSGIX = NULL;\nPFNGLFRAGMENTLIGHTMODELFVSGIXPROC __glewFragmentLightModelfvSGIX = NULL;\nPFNGLFRAGMENTLIGHTMODELISGIXPROC __glewFragmentLightModeliSGIX = NULL;\nPFNGLFRAGMENTLIGHTMODELIVSGIXPROC __glewFragmentLightModelivSGIX = NULL;\nPFNGLFRAGMENTLIGHTFSGIXPROC __glewFragmentLightfSGIX = NULL;\nPFNGLFRAGMENTLIGHTFVSGIXPROC __glewFragmentLightfvSGIX = NULL;\nPFNGLFRAGMENTLIGHTISGIXPROC __glewFragmentLightiSGIX = NULL;\nPFNGLFRAGMENTLIGHTIVSGIXPROC __glewFragmentLightivSGIX = NULL;\nPFNGLFRAGMENTMATERIALFSGIXPROC __glewFragmentMaterialfSGIX = NULL;\nPFNGLFRAGMENTMATERIALFVSGIXPROC __glewFragmentMaterialfvSGIX = NULL;\nPFNGLFRAGMENTMATERIALISGIXPROC __glewFragmentMaterialiSGIX = NULL;\nPFNGLFRAGMENTMATERIALIVSGIXPROC __glewFragmentMaterialivSGIX = NULL;\nPFNGLGETFRAGMENTLIGHTFVSGIXPROC __glewGetFragmentLightfvSGIX = NULL;\nPFNGLGETFRAGMENTLIGHTIVSGIXPROC __glewGetFragmentLightivSGIX = NULL;\nPFNGLGETFRAGMENTMATERIALFVSGIXPROC __glewGetFragmentMaterialfvSGIX = NULL;\nPFNGLGETFRAGMENTMATERIALIVSGIXPROC __glewGetFragmentMaterialivSGIX = NULL;\n\nPFNGLFRAMEZOOMSGIXPROC __glewFrameZoomSGIX = NULL;\n\nPFNGLPIXELTEXGENSGIXPROC __glewPixelTexGenSGIX = NULL;\n\nPFNGLREFERENCEPLANESGIXPROC __glewReferencePlaneSGIX = NULL;\n\nPFNGLSPRITEPARAMETERFSGIXPROC __glewSpriteParameterfSGIX = NULL;\nPFNGLSPRITEPARAMETERFVSGIXPROC __glewSpriteParameterfvSGIX = NULL;\nPFNGLSPRITEPARAMETERISGIXPROC __glewSpriteParameteriSGIX = NULL;\nPFNGLSPRITEPARAMETERIVSGIXPROC __glewSpriteParameterivSGIX = NULL;\n\nPFNGLTAGSAMPLEBUFFERSGIXPROC __glewTagSampleBufferSGIX = NULL;\n\nPFNGLCOLORTABLEPARAMETERFVSGIPROC __glewColorTableParameterfvSGI = NULL;\nPFNGLCOLORTABLEPARAMETERIVSGIPROC __glewColorTableParameterivSGI = NULL;\nPFNGLCOLORTABLESGIPROC __glewColorTableSGI = NULL;\nPFNGLCOPYCOLORTABLESGIPROC __glewCopyColorTableSGI = NULL;\nPFNGLGETCOLORTABLEPARAMETERFVSGIPROC __glewGetColorTableParameterfvSGI = NULL;\nPFNGLGETCOLORTABLEPARAMETERIVSGIPROC __glewGetColorTableParameterivSGI = NULL;\nPFNGLGETCOLORTABLESGIPROC __glewGetColorTableSGI = NULL;\n\nPFNGLFINISHTEXTURESUNXPROC __glewFinishTextureSUNX = NULL;\n\nPFNGLGLOBALALPHAFACTORBSUNPROC __glewGlobalAlphaFactorbSUN = NULL;\nPFNGLGLOBALALPHAFACTORDSUNPROC __glewGlobalAlphaFactordSUN = NULL;\nPFNGLGLOBALALPHAFACTORFSUNPROC __glewGlobalAlphaFactorfSUN = NULL;\nPFNGLGLOBALALPHAFACTORISUNPROC __glewGlobalAlphaFactoriSUN = NULL;\nPFNGLGLOBALALPHAFACTORSSUNPROC __glewGlobalAlphaFactorsSUN = NULL;\nPFNGLGLOBALALPHAFACTORUBSUNPROC __glewGlobalAlphaFactorubSUN = NULL;\nPFNGLGLOBALALPHAFACTORUISUNPROC __glewGlobalAlphaFactoruiSUN = NULL;\nPFNGLGLOBALALPHAFACTORUSSUNPROC __glewGlobalAlphaFactorusSUN = NULL;\n\nPFNGLREADVIDEOPIXELSSUNPROC __glewReadVideoPixelsSUN = NULL;\n\nPFNGLREPLACEMENTCODEPOINTERSUNPROC __glewReplacementCodePointerSUN = NULL;\nPFNGLREPLACEMENTCODEUBSUNPROC __glewReplacementCodeubSUN = NULL;\nPFNGLREPLACEMENTCODEUBVSUNPROC __glewReplacementCodeubvSUN = NULL;\nPFNGLREPLACEMENTCODEUISUNPROC __glewReplacementCodeuiSUN = NULL;\nPFNGLREPLACEMENTCODEUIVSUNPROC __glewReplacementCodeuivSUN = NULL;\nPFNGLREPLACEMENTCODEUSSUNPROC __glewReplacementCodeusSUN = NULL;\nPFNGLREPLACEMENTCODEUSVSUNPROC __glewReplacementCodeusvSUN = NULL;\n\nPFNGLCOLOR3FVERTEX3FSUNPROC __glewColor3fVertex3fSUN = NULL;\nPFNGLCOLOR3FVERTEX3FVSUNPROC __glewColor3fVertex3fvSUN = NULL;\nPFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewColor4fNormal3fVertex3fSUN = NULL;\nPFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewColor4fNormal3fVertex3fvSUN = NULL;\nPFNGLCOLOR4UBVERTEX2FSUNPROC __glewColor4ubVertex2fSUN = NULL;\nPFNGLCOLOR4UBVERTEX2FVSUNPROC __glewColor4ubVertex2fvSUN = NULL;\nPFNGLCOLOR4UBVERTEX3FSUNPROC __glewColor4ubVertex3fSUN = NULL;\nPFNGLCOLOR4UBVERTEX3FVSUNPROC __glewColor4ubVertex3fvSUN = NULL;\nPFNGLNORMAL3FVERTEX3FSUNPROC __glewNormal3fVertex3fSUN = NULL;\nPFNGLNORMAL3FVERTEX3FVSUNPROC __glewNormal3fVertex3fvSUN = NULL;\nPFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC __glewReplacementCodeuiColor3fVertex3fSUN = NULL;\nPFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor3fVertex3fvSUN = NULL;\nPFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fSUN = NULL;\nPFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fvSUN = NULL;\nPFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC __glewReplacementCodeuiColor4ubVertex3fSUN = NULL;\nPFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC __glewReplacementCodeuiColor4ubVertex3fvSUN = NULL;\nPFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiNormal3fVertex3fSUN = NULL;\nPFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiNormal3fVertex3fvSUN = NULL;\nPFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = NULL;\nPFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = NULL;\nPFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = NULL;\nPFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = NULL;\nPFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fSUN = NULL;\nPFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fvSUN = NULL;\nPFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC __glewReplacementCodeuiVertex3fSUN = NULL;\nPFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC __glewReplacementCodeuiVertex3fvSUN = NULL;\nPFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC __glewTexCoord2fColor3fVertex3fSUN = NULL;\nPFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC __glewTexCoord2fColor3fVertex3fvSUN = NULL;\nPFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fSUN = NULL;\nPFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fvSUN = NULL;\nPFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC __glewTexCoord2fColor4ubVertex3fSUN = NULL;\nPFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC __glewTexCoord2fColor4ubVertex3fvSUN = NULL;\nPFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fNormal3fVertex3fSUN = NULL;\nPFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fNormal3fVertex3fvSUN = NULL;\nPFNGLTEXCOORD2FVERTEX3FSUNPROC __glewTexCoord2fVertex3fSUN = NULL;\nPFNGLTEXCOORD2FVERTEX3FVSUNPROC __glewTexCoord2fVertex3fvSUN = NULL;\nPFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fSUN = NULL;\nPFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fvSUN = NULL;\nPFNGLTEXCOORD4FVERTEX4FSUNPROC __glewTexCoord4fVertex4fSUN = NULL;\nPFNGLTEXCOORD4FVERTEX4FVSUNPROC __glewTexCoord4fVertex4fvSUN = NULL;\n\nPFNGLADDSWAPHINTRECTWINPROC __glewAddSwapHintRectWIN = NULL;\n\n#endif /* !WIN32 || !GLEW_MX */\n\n#if !defined(GLEW_MX)\n\nGLboolean __GLEW_VERSION_1_1 = GL_FALSE;\nGLboolean __GLEW_VERSION_1_2 = GL_FALSE;\nGLboolean __GLEW_VERSION_1_3 = GL_FALSE;\nGLboolean __GLEW_VERSION_1_4 = GL_FALSE;\nGLboolean __GLEW_VERSION_1_5 = GL_FALSE;\nGLboolean __GLEW_VERSION_2_0 = GL_FALSE;\nGLboolean __GLEW_VERSION_2_1 = GL_FALSE;\nGLboolean __GLEW_VERSION_3_0 = GL_FALSE;\nGLboolean __GLEW_3DFX_multisample = GL_FALSE;\nGLboolean __GLEW_3DFX_tbuffer = GL_FALSE;\nGLboolean __GLEW_3DFX_texture_compression_FXT1 = GL_FALSE;\nGLboolean __GLEW_APPLE_client_storage = GL_FALSE;\nGLboolean __GLEW_APPLE_element_array = GL_FALSE;\nGLboolean __GLEW_APPLE_fence = GL_FALSE;\nGLboolean __GLEW_APPLE_float_pixels = GL_FALSE;\nGLboolean __GLEW_APPLE_flush_buffer_range = GL_FALSE;\nGLboolean __GLEW_APPLE_pixel_buffer = GL_FALSE;\nGLboolean __GLEW_APPLE_specular_vector = GL_FALSE;\nGLboolean __GLEW_APPLE_texture_range = GL_FALSE;\nGLboolean __GLEW_APPLE_transform_hint = GL_FALSE;\nGLboolean __GLEW_APPLE_vertex_array_object = GL_FALSE;\nGLboolean __GLEW_APPLE_vertex_array_range = GL_FALSE;\nGLboolean __GLEW_APPLE_ycbcr_422 = GL_FALSE;\nGLboolean __GLEW_ARB_color_buffer_float = GL_FALSE;\nGLboolean __GLEW_ARB_depth_buffer_float = GL_FALSE;\nGLboolean __GLEW_ARB_depth_texture = GL_FALSE;\nGLboolean __GLEW_ARB_draw_buffers = GL_FALSE;\nGLboolean __GLEW_ARB_draw_instanced = GL_FALSE;\nGLboolean __GLEW_ARB_fragment_program = GL_FALSE;\nGLboolean __GLEW_ARB_fragment_program_shadow = GL_FALSE;\nGLboolean __GLEW_ARB_fragment_shader = GL_FALSE;\nGLboolean __GLEW_ARB_framebuffer_object = GL_FALSE;\nGLboolean __GLEW_ARB_framebuffer_sRGB = GL_FALSE;\nGLboolean __GLEW_ARB_geometry_shader4 = GL_FALSE;\nGLboolean __GLEW_ARB_half_float_pixel = GL_FALSE;\nGLboolean __GLEW_ARB_half_float_vertex = GL_FALSE;\nGLboolean __GLEW_ARB_imaging = GL_FALSE;\nGLboolean __GLEW_ARB_instanced_arrays = GL_FALSE;\nGLboolean __GLEW_ARB_map_buffer_range = GL_FALSE;\nGLboolean __GLEW_ARB_matrix_palette = GL_FALSE;\nGLboolean __GLEW_ARB_multisample = GL_FALSE;\nGLboolean __GLEW_ARB_multitexture = GL_FALSE;\nGLboolean __GLEW_ARB_occlusion_query = GL_FALSE;\nGLboolean __GLEW_ARB_pixel_buffer_object = GL_FALSE;\nGLboolean __GLEW_ARB_point_parameters = GL_FALSE;\nGLboolean __GLEW_ARB_point_sprite = GL_FALSE;\nGLboolean __GLEW_ARB_shader_objects = GL_FALSE;\nGLboolean __GLEW_ARB_shading_language_100 = GL_FALSE;\nGLboolean __GLEW_ARB_shadow = GL_FALSE;\nGLboolean __GLEW_ARB_shadow_ambient = GL_FALSE;\nGLboolean __GLEW_ARB_texture_border_clamp = GL_FALSE;\nGLboolean __GLEW_ARB_texture_buffer_object = GL_FALSE;\nGLboolean __GLEW_ARB_texture_compression = GL_FALSE;\nGLboolean __GLEW_ARB_texture_compression_rgtc = GL_FALSE;\nGLboolean __GLEW_ARB_texture_cube_map = GL_FALSE;\nGLboolean __GLEW_ARB_texture_env_add = GL_FALSE;\nGLboolean __GLEW_ARB_texture_env_combine = GL_FALSE;\nGLboolean __GLEW_ARB_texture_env_crossbar = GL_FALSE;\nGLboolean __GLEW_ARB_texture_env_dot3 = GL_FALSE;\nGLboolean __GLEW_ARB_texture_float = GL_FALSE;\nGLboolean __GLEW_ARB_texture_mirrored_repeat = GL_FALSE;\nGLboolean __GLEW_ARB_texture_non_power_of_two = GL_FALSE;\nGLboolean __GLEW_ARB_texture_rectangle = GL_FALSE;\nGLboolean __GLEW_ARB_texture_rg = GL_FALSE;\nGLboolean __GLEW_ARB_transpose_matrix = GL_FALSE;\nGLboolean __GLEW_ARB_vertex_array_object = GL_FALSE;\nGLboolean __GLEW_ARB_vertex_blend = GL_FALSE;\nGLboolean __GLEW_ARB_vertex_buffer_object = GL_FALSE;\nGLboolean __GLEW_ARB_vertex_program = GL_FALSE;\nGLboolean __GLEW_ARB_vertex_shader = GL_FALSE;\nGLboolean __GLEW_ARB_window_pos = GL_FALSE;\nGLboolean __GLEW_ATIX_point_sprites = GL_FALSE;\nGLboolean __GLEW_ATIX_texture_env_combine3 = GL_FALSE;\nGLboolean __GLEW_ATIX_texture_env_route = GL_FALSE;\nGLboolean __GLEW_ATIX_vertex_shader_output_point_size = GL_FALSE;\nGLboolean __GLEW_ATI_draw_buffers = GL_FALSE;\nGLboolean __GLEW_ATI_element_array = GL_FALSE;\nGLboolean __GLEW_ATI_envmap_bumpmap = GL_FALSE;\nGLboolean __GLEW_ATI_fragment_shader = GL_FALSE;\nGLboolean __GLEW_ATI_map_object_buffer = GL_FALSE;\nGLboolean __GLEW_ATI_pn_triangles = GL_FALSE;\nGLboolean __GLEW_ATI_separate_stencil = GL_FALSE;\nGLboolean __GLEW_ATI_shader_texture_lod = GL_FALSE;\nGLboolean __GLEW_ATI_text_fragment_shader = GL_FALSE;\nGLboolean __GLEW_ATI_texture_compression_3dc = GL_FALSE;\nGLboolean __GLEW_ATI_texture_env_combine3 = GL_FALSE;\nGLboolean __GLEW_ATI_texture_float = GL_FALSE;\nGLboolean __GLEW_ATI_texture_mirror_once = GL_FALSE;\nGLboolean __GLEW_ATI_vertex_array_object = GL_FALSE;\nGLboolean __GLEW_ATI_vertex_attrib_array_object = GL_FALSE;\nGLboolean __GLEW_ATI_vertex_streams = GL_FALSE;\nGLboolean __GLEW_EXT_422_pixels = GL_FALSE;\nGLboolean __GLEW_EXT_Cg_shader = GL_FALSE;\nGLboolean __GLEW_EXT_abgr = GL_FALSE;\nGLboolean __GLEW_EXT_bgra = GL_FALSE;\nGLboolean __GLEW_EXT_bindable_uniform = GL_FALSE;\nGLboolean __GLEW_EXT_blend_color = GL_FALSE;\nGLboolean __GLEW_EXT_blend_equation_separate = GL_FALSE;\nGLboolean __GLEW_EXT_blend_func_separate = GL_FALSE;\nGLboolean __GLEW_EXT_blend_logic_op = GL_FALSE;\nGLboolean __GLEW_EXT_blend_minmax = GL_FALSE;\nGLboolean __GLEW_EXT_blend_subtract = GL_FALSE;\nGLboolean __GLEW_EXT_clip_volume_hint = GL_FALSE;\nGLboolean __GLEW_EXT_cmyka = GL_FALSE;\nGLboolean __GLEW_EXT_color_subtable = GL_FALSE;\nGLboolean __GLEW_EXT_compiled_vertex_array = GL_FALSE;\nGLboolean __GLEW_EXT_convolution = GL_FALSE;\nGLboolean __GLEW_EXT_coordinate_frame = GL_FALSE;\nGLboolean __GLEW_EXT_copy_texture = GL_FALSE;\nGLboolean __GLEW_EXT_cull_vertex = GL_FALSE;\nGLboolean __GLEW_EXT_depth_bounds_test = GL_FALSE;\nGLboolean __GLEW_EXT_direct_state_access = GL_FALSE;\nGLboolean __GLEW_EXT_draw_buffers2 = GL_FALSE;\nGLboolean __GLEW_EXT_draw_instanced = GL_FALSE;\nGLboolean __GLEW_EXT_draw_range_elements = GL_FALSE;\nGLboolean __GLEW_EXT_fog_coord = GL_FALSE;\nGLboolean __GLEW_EXT_fragment_lighting = GL_FALSE;\nGLboolean __GLEW_EXT_framebuffer_blit = GL_FALSE;\nGLboolean __GLEW_EXT_framebuffer_multisample = GL_FALSE;\nGLboolean __GLEW_EXT_framebuffer_object = GL_FALSE;\nGLboolean __GLEW_EXT_framebuffer_sRGB = GL_FALSE;\nGLboolean __GLEW_EXT_geometry_shader4 = GL_FALSE;\nGLboolean __GLEW_EXT_gpu_program_parameters = GL_FALSE;\nGLboolean __GLEW_EXT_gpu_shader4 = GL_FALSE;\nGLboolean __GLEW_EXT_histogram = GL_FALSE;\nGLboolean __GLEW_EXT_index_array_formats = GL_FALSE;\nGLboolean __GLEW_EXT_index_func = GL_FALSE;\nGLboolean __GLEW_EXT_index_material = GL_FALSE;\nGLboolean __GLEW_EXT_index_texture = GL_FALSE;\nGLboolean __GLEW_EXT_light_texture = GL_FALSE;\nGLboolean __GLEW_EXT_misc_attribute = GL_FALSE;\nGLboolean __GLEW_EXT_multi_draw_arrays = GL_FALSE;\nGLboolean __GLEW_EXT_multisample = GL_FALSE;\nGLboolean __GLEW_EXT_packed_depth_stencil = GL_FALSE;\nGLboolean __GLEW_EXT_packed_float = GL_FALSE;\nGLboolean __GLEW_EXT_packed_pixels = GL_FALSE;\nGLboolean __GLEW_EXT_paletted_texture = GL_FALSE;\nGLboolean __GLEW_EXT_pixel_buffer_object = GL_FALSE;\nGLboolean __GLEW_EXT_pixel_transform = GL_FALSE;\nGLboolean __GLEW_EXT_pixel_transform_color_table = GL_FALSE;\nGLboolean __GLEW_EXT_point_parameters = GL_FALSE;\nGLboolean __GLEW_EXT_polygon_offset = GL_FALSE;\nGLboolean __GLEW_EXT_rescale_normal = GL_FALSE;\nGLboolean __GLEW_EXT_scene_marker = GL_FALSE;\nGLboolean __GLEW_EXT_secondary_color = GL_FALSE;\nGLboolean __GLEW_EXT_separate_specular_color = GL_FALSE;\nGLboolean __GLEW_EXT_shadow_funcs = GL_FALSE;\nGLboolean __GLEW_EXT_shared_texture_palette = GL_FALSE;\nGLboolean __GLEW_EXT_stencil_clear_tag = GL_FALSE;\nGLboolean __GLEW_EXT_stencil_two_side = GL_FALSE;\nGLboolean __GLEW_EXT_stencil_wrap = GL_FALSE;\nGLboolean __GLEW_EXT_subtexture = GL_FALSE;\nGLboolean __GLEW_EXT_texture = GL_FALSE;\nGLboolean __GLEW_EXT_texture3D = GL_FALSE;\nGLboolean __GLEW_EXT_texture_array = GL_FALSE;\nGLboolean __GLEW_EXT_texture_buffer_object = GL_FALSE;\nGLboolean __GLEW_EXT_texture_compression_dxt1 = GL_FALSE;\nGLboolean __GLEW_EXT_texture_compression_latc = GL_FALSE;\nGLboolean __GLEW_EXT_texture_compression_rgtc = GL_FALSE;\nGLboolean __GLEW_EXT_texture_compression_s3tc = GL_FALSE;\nGLboolean __GLEW_EXT_texture_cube_map = GL_FALSE;\nGLboolean __GLEW_EXT_texture_edge_clamp = GL_FALSE;\nGLboolean __GLEW_EXT_texture_env = GL_FALSE;\nGLboolean __GLEW_EXT_texture_env_add = GL_FALSE;\nGLboolean __GLEW_EXT_texture_env_combine = GL_FALSE;\nGLboolean __GLEW_EXT_texture_env_dot3 = GL_FALSE;\nGLboolean __GLEW_EXT_texture_filter_anisotropic = GL_FALSE;\nGLboolean __GLEW_EXT_texture_integer = GL_FALSE;\nGLboolean __GLEW_EXT_texture_lod_bias = GL_FALSE;\nGLboolean __GLEW_EXT_texture_mirror_clamp = GL_FALSE;\nGLboolean __GLEW_EXT_texture_object = GL_FALSE;\nGLboolean __GLEW_EXT_texture_perturb_normal = GL_FALSE;\nGLboolean __GLEW_EXT_texture_rectangle = GL_FALSE;\nGLboolean __GLEW_EXT_texture_sRGB = GL_FALSE;\nGLboolean __GLEW_EXT_texture_shared_exponent = GL_FALSE;\nGLboolean __GLEW_EXT_texture_swizzle = GL_FALSE;\nGLboolean __GLEW_EXT_timer_query = GL_FALSE;\nGLboolean __GLEW_EXT_transform_feedback = GL_FALSE;\nGLboolean __GLEW_EXT_vertex_array = GL_FALSE;\nGLboolean __GLEW_EXT_vertex_array_bgra = GL_FALSE;\nGLboolean __GLEW_EXT_vertex_shader = GL_FALSE;\nGLboolean __GLEW_EXT_vertex_weighting = GL_FALSE;\nGLboolean __GLEW_GREMEDY_frame_terminator = GL_FALSE;\nGLboolean __GLEW_GREMEDY_string_marker = GL_FALSE;\nGLboolean __GLEW_HP_convolution_border_modes = GL_FALSE;\nGLboolean __GLEW_HP_image_transform = GL_FALSE;\nGLboolean __GLEW_HP_occlusion_test = GL_FALSE;\nGLboolean __GLEW_HP_texture_lighting = GL_FALSE;\nGLboolean __GLEW_IBM_cull_vertex = GL_FALSE;\nGLboolean __GLEW_IBM_multimode_draw_arrays = GL_FALSE;\nGLboolean __GLEW_IBM_rasterpos_clip = GL_FALSE;\nGLboolean __GLEW_IBM_static_data = GL_FALSE;\nGLboolean __GLEW_IBM_texture_mirrored_repeat = GL_FALSE;\nGLboolean __GLEW_IBM_vertex_array_lists = GL_FALSE;\nGLboolean __GLEW_INGR_color_clamp = GL_FALSE;\nGLboolean __GLEW_INGR_interlace_read = GL_FALSE;\nGLboolean __GLEW_INTEL_parallel_arrays = GL_FALSE;\nGLboolean __GLEW_INTEL_texture_scissor = GL_FALSE;\nGLboolean __GLEW_KTX_buffer_region = GL_FALSE;\nGLboolean __GLEW_MESAX_texture_stack = GL_FALSE;\nGLboolean __GLEW_MESA_pack_invert = GL_FALSE;\nGLboolean __GLEW_MESA_resize_buffers = GL_FALSE;\nGLboolean __GLEW_MESA_window_pos = GL_FALSE;\nGLboolean __GLEW_MESA_ycbcr_texture = GL_FALSE;\nGLboolean __GLEW_NV_blend_square = GL_FALSE;\nGLboolean __GLEW_NV_conditional_render = GL_FALSE;\nGLboolean __GLEW_NV_copy_depth_to_color = GL_FALSE;\nGLboolean __GLEW_NV_depth_buffer_float = GL_FALSE;\nGLboolean __GLEW_NV_depth_clamp = GL_FALSE;\nGLboolean __GLEW_NV_depth_range_unclamped = GL_FALSE;\nGLboolean __GLEW_NV_evaluators = GL_FALSE;\nGLboolean __GLEW_NV_explicit_multisample = GL_FALSE;\nGLboolean __GLEW_NV_fence = GL_FALSE;\nGLboolean __GLEW_NV_float_buffer = GL_FALSE;\nGLboolean __GLEW_NV_fog_distance = GL_FALSE;\nGLboolean __GLEW_NV_fragment_program = GL_FALSE;\nGLboolean __GLEW_NV_fragment_program2 = GL_FALSE;\nGLboolean __GLEW_NV_fragment_program4 = GL_FALSE;\nGLboolean __GLEW_NV_fragment_program_option = GL_FALSE;\nGLboolean __GLEW_NV_framebuffer_multisample_coverage = GL_FALSE;\nGLboolean __GLEW_NV_geometry_program4 = GL_FALSE;\nGLboolean __GLEW_NV_geometry_shader4 = GL_FALSE;\nGLboolean __GLEW_NV_gpu_program4 = GL_FALSE;\nGLboolean __GLEW_NV_half_float = GL_FALSE;\nGLboolean __GLEW_NV_light_max_exponent = GL_FALSE;\nGLboolean __GLEW_NV_multisample_filter_hint = GL_FALSE;\nGLboolean __GLEW_NV_occlusion_query = GL_FALSE;\nGLboolean __GLEW_NV_packed_depth_stencil = GL_FALSE;\nGLboolean __GLEW_NV_parameter_buffer_object = GL_FALSE;\nGLboolean __GLEW_NV_pixel_data_range = GL_FALSE;\nGLboolean __GLEW_NV_point_sprite = GL_FALSE;\nGLboolean __GLEW_NV_present_video = GL_FALSE;\nGLboolean __GLEW_NV_primitive_restart = GL_FALSE;\nGLboolean __GLEW_NV_register_combiners = GL_FALSE;\nGLboolean __GLEW_NV_register_combiners2 = GL_FALSE;\nGLboolean __GLEW_NV_texgen_emboss = GL_FALSE;\nGLboolean __GLEW_NV_texgen_reflection = GL_FALSE;\nGLboolean __GLEW_NV_texture_compression_vtc = GL_FALSE;\nGLboolean __GLEW_NV_texture_env_combine4 = GL_FALSE;\nGLboolean __GLEW_NV_texture_expand_normal = GL_FALSE;\nGLboolean __GLEW_NV_texture_rectangle = GL_FALSE;\nGLboolean __GLEW_NV_texture_shader = GL_FALSE;\nGLboolean __GLEW_NV_texture_shader2 = GL_FALSE;\nGLboolean __GLEW_NV_texture_shader3 = GL_FALSE;\nGLboolean __GLEW_NV_transform_feedback = GL_FALSE;\nGLboolean __GLEW_NV_vertex_array_range = GL_FALSE;\nGLboolean __GLEW_NV_vertex_array_range2 = GL_FALSE;\nGLboolean __GLEW_NV_vertex_program = GL_FALSE;\nGLboolean __GLEW_NV_vertex_program1_1 = GL_FALSE;\nGLboolean __GLEW_NV_vertex_program2 = GL_FALSE;\nGLboolean __GLEW_NV_vertex_program2_option = GL_FALSE;\nGLboolean __GLEW_NV_vertex_program3 = GL_FALSE;\nGLboolean __GLEW_NV_vertex_program4 = GL_FALSE;\nGLboolean __GLEW_OES_byte_coordinates = GL_FALSE;\nGLboolean __GLEW_OES_compressed_paletted_texture = GL_FALSE;\nGLboolean __GLEW_OES_read_format = GL_FALSE;\nGLboolean __GLEW_OES_single_precision = GL_FALSE;\nGLboolean __GLEW_OML_interlace = GL_FALSE;\nGLboolean __GLEW_OML_resample = GL_FALSE;\nGLboolean __GLEW_OML_subsample = GL_FALSE;\nGLboolean __GLEW_PGI_misc_hints = GL_FALSE;\nGLboolean __GLEW_PGI_vertex_hints = GL_FALSE;\nGLboolean __GLEW_REND_screen_coordinates = GL_FALSE;\nGLboolean __GLEW_S3_s3tc = GL_FALSE;\nGLboolean __GLEW_SGIS_color_range = GL_FALSE;\nGLboolean __GLEW_SGIS_detail_texture = GL_FALSE;\nGLboolean __GLEW_SGIS_fog_function = GL_FALSE;\nGLboolean __GLEW_SGIS_generate_mipmap = GL_FALSE;\nGLboolean __GLEW_SGIS_multisample = GL_FALSE;\nGLboolean __GLEW_SGIS_pixel_texture = GL_FALSE;\nGLboolean __GLEW_SGIS_point_line_texgen = GL_FALSE;\nGLboolean __GLEW_SGIS_sharpen_texture = GL_FALSE;\nGLboolean __GLEW_SGIS_texture4D = GL_FALSE;\nGLboolean __GLEW_SGIS_texture_border_clamp = GL_FALSE;\nGLboolean __GLEW_SGIS_texture_edge_clamp = GL_FALSE;\nGLboolean __GLEW_SGIS_texture_filter4 = GL_FALSE;\nGLboolean __GLEW_SGIS_texture_lod = GL_FALSE;\nGLboolean __GLEW_SGIS_texture_select = GL_FALSE;\nGLboolean __GLEW_SGIX_async = GL_FALSE;\nGLboolean __GLEW_SGIX_async_histogram = GL_FALSE;\nGLboolean __GLEW_SGIX_async_pixel = GL_FALSE;\nGLboolean __GLEW_SGIX_blend_alpha_minmax = GL_FALSE;\nGLboolean __GLEW_SGIX_clipmap = GL_FALSE;\nGLboolean __GLEW_SGIX_convolution_accuracy = GL_FALSE;\nGLboolean __GLEW_SGIX_depth_texture = GL_FALSE;\nGLboolean __GLEW_SGIX_flush_raster = GL_FALSE;\nGLboolean __GLEW_SGIX_fog_offset = GL_FALSE;\nGLboolean __GLEW_SGIX_fog_texture = GL_FALSE;\nGLboolean __GLEW_SGIX_fragment_specular_lighting = GL_FALSE;\nGLboolean __GLEW_SGIX_framezoom = GL_FALSE;\nGLboolean __GLEW_SGIX_interlace = GL_FALSE;\nGLboolean __GLEW_SGIX_ir_instrument1 = GL_FALSE;\nGLboolean __GLEW_SGIX_list_priority = GL_FALSE;\nGLboolean __GLEW_SGIX_pixel_texture = GL_FALSE;\nGLboolean __GLEW_SGIX_pixel_texture_bits = GL_FALSE;\nGLboolean __GLEW_SGIX_reference_plane = GL_FALSE;\nGLboolean __GLEW_SGIX_resample = GL_FALSE;\nGLboolean __GLEW_SGIX_shadow = GL_FALSE;\nGLboolean __GLEW_SGIX_shadow_ambient = GL_FALSE;\nGLboolean __GLEW_SGIX_sprite = GL_FALSE;\nGLboolean __GLEW_SGIX_tag_sample_buffer = GL_FALSE;\nGLboolean __GLEW_SGIX_texture_add_env = GL_FALSE;\nGLboolean __GLEW_SGIX_texture_coordinate_clamp = GL_FALSE;\nGLboolean __GLEW_SGIX_texture_lod_bias = GL_FALSE;\nGLboolean __GLEW_SGIX_texture_multi_buffer = GL_FALSE;\nGLboolean __GLEW_SGIX_texture_range = GL_FALSE;\nGLboolean __GLEW_SGIX_texture_scale_bias = GL_FALSE;\nGLboolean __GLEW_SGIX_vertex_preclip = GL_FALSE;\nGLboolean __GLEW_SGIX_vertex_preclip_hint = GL_FALSE;\nGLboolean __GLEW_SGIX_ycrcb = GL_FALSE;\nGLboolean __GLEW_SGI_color_matrix = GL_FALSE;\nGLboolean __GLEW_SGI_color_table = GL_FALSE;\nGLboolean __GLEW_SGI_texture_color_table = GL_FALSE;\nGLboolean __GLEW_SUNX_constant_data = GL_FALSE;\nGLboolean __GLEW_SUN_convolution_border_modes = GL_FALSE;\nGLboolean __GLEW_SUN_global_alpha = GL_FALSE;\nGLboolean __GLEW_SUN_mesh_array = GL_FALSE;\nGLboolean __GLEW_SUN_read_video_pixels = GL_FALSE;\nGLboolean __GLEW_SUN_slice_accum = GL_FALSE;\nGLboolean __GLEW_SUN_triangle_list = GL_FALSE;\nGLboolean __GLEW_SUN_vertex = GL_FALSE;\nGLboolean __GLEW_WIN_phong_shading = GL_FALSE;\nGLboolean __GLEW_WIN_specular_fog = GL_FALSE;\nGLboolean __GLEW_WIN_swap_hint = GL_FALSE;\n\n#endif /* !GLEW_MX */\n\n#ifdef GL_VERSION_1_2\n\nstatic GLboolean _glewInit_GL_VERSION_1_2 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glCopyTexSubImage3D = (PFNGLCOPYTEXSUBIMAGE3DPROC)glewGetProcAddress((const GLubyte*)\"glCopyTexSubImage3D\")) == NULL) || r;\n  r = ((glDrawRangeElements = (PFNGLDRAWRANGEELEMENTSPROC)glewGetProcAddress((const GLubyte*)\"glDrawRangeElements\")) == NULL) || r;\n  r = ((glTexImage3D = (PFNGLTEXIMAGE3DPROC)glewGetProcAddress((const GLubyte*)\"glTexImage3D\")) == NULL) || r;\n  r = ((glTexSubImage3D = (PFNGLTEXSUBIMAGE3DPROC)glewGetProcAddress((const GLubyte*)\"glTexSubImage3D\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_VERSION_1_2 */\n\n#ifdef GL_VERSION_1_3\n\nstatic GLboolean _glewInit_GL_VERSION_1_3 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glActiveTexture = (PFNGLACTIVETEXTUREPROC)glewGetProcAddress((const GLubyte*)\"glActiveTexture\")) == NULL) || r;\n  r = ((glClientActiveTexture = (PFNGLCLIENTACTIVETEXTUREPROC)glewGetProcAddress((const GLubyte*)\"glClientActiveTexture\")) == NULL) || r;\n  r = ((glCompressedTexImage1D = (PFNGLCOMPRESSEDTEXIMAGE1DPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexImage1D\")) == NULL) || r;\n  r = ((glCompressedTexImage2D = (PFNGLCOMPRESSEDTEXIMAGE2DPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexImage2D\")) == NULL) || r;\n  r = ((glCompressedTexImage3D = (PFNGLCOMPRESSEDTEXIMAGE3DPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexImage3D\")) == NULL) || r;\n  r = ((glCompressedTexSubImage1D = (PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexSubImage1D\")) == NULL) || r;\n  r = ((glCompressedTexSubImage2D = (PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexSubImage2D\")) == NULL) || r;\n  r = ((glCompressedTexSubImage3D = (PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexSubImage3D\")) == NULL) || r;\n  r = ((glGetCompressedTexImage = (PFNGLGETCOMPRESSEDTEXIMAGEPROC)glewGetProcAddress((const GLubyte*)\"glGetCompressedTexImage\")) == NULL) || r;\n  r = ((glLoadTransposeMatrixd = (PFNGLLOADTRANSPOSEMATRIXDPROC)glewGetProcAddress((const GLubyte*)\"glLoadTransposeMatrixd\")) == NULL) || r;\n  r = ((glLoadTransposeMatrixf = (PFNGLLOADTRANSPOSEMATRIXFPROC)glewGetProcAddress((const GLubyte*)\"glLoadTransposeMatrixf\")) == NULL) || r;\n  r = ((glMultTransposeMatrixd = (PFNGLMULTTRANSPOSEMATRIXDPROC)glewGetProcAddress((const GLubyte*)\"glMultTransposeMatrixd\")) == NULL) || r;\n  r = ((glMultTransposeMatrixf = (PFNGLMULTTRANSPOSEMATRIXFPROC)glewGetProcAddress((const GLubyte*)\"glMultTransposeMatrixf\")) == NULL) || r;\n  r = ((glMultiTexCoord1d = (PFNGLMULTITEXCOORD1DPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1d\")) == NULL) || r;\n  r = ((glMultiTexCoord1dv = (PFNGLMULTITEXCOORD1DVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1dv\")) == NULL) || r;\n  r = ((glMultiTexCoord1f = (PFNGLMULTITEXCOORD1FPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1f\")) == NULL) || r;\n  r = ((glMultiTexCoord1fv = (PFNGLMULTITEXCOORD1FVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1fv\")) == NULL) || r;\n  r = ((glMultiTexCoord1i = (PFNGLMULTITEXCOORD1IPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1i\")) == NULL) || r;\n  r = ((glMultiTexCoord1iv = (PFNGLMULTITEXCOORD1IVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1iv\")) == NULL) || r;\n  r = ((glMultiTexCoord1s = (PFNGLMULTITEXCOORD1SPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1s\")) == NULL) || r;\n  r = ((glMultiTexCoord1sv = (PFNGLMULTITEXCOORD1SVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1sv\")) == NULL) || r;\n  r = ((glMultiTexCoord2d = (PFNGLMULTITEXCOORD2DPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2d\")) == NULL) || r;\n  r = ((glMultiTexCoord2dv = (PFNGLMULTITEXCOORD2DVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2dv\")) == NULL) || r;\n  r = ((glMultiTexCoord2f = (PFNGLMULTITEXCOORD2FPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2f\")) == NULL) || r;\n  r = ((glMultiTexCoord2fv = (PFNGLMULTITEXCOORD2FVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2fv\")) == NULL) || r;\n  r = ((glMultiTexCoord2i = (PFNGLMULTITEXCOORD2IPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2i\")) == NULL) || r;\n  r = ((glMultiTexCoord2iv = (PFNGLMULTITEXCOORD2IVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2iv\")) == NULL) || r;\n  r = ((glMultiTexCoord2s = (PFNGLMULTITEXCOORD2SPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2s\")) == NULL) || r;\n  r = ((glMultiTexCoord2sv = (PFNGLMULTITEXCOORD2SVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2sv\")) == NULL) || r;\n  r = ((glMultiTexCoord3d = (PFNGLMULTITEXCOORD3DPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3d\")) == NULL) || r;\n  r = ((glMultiTexCoord3dv = (PFNGLMULTITEXCOORD3DVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3dv\")) == NULL) || r;\n  r = ((glMultiTexCoord3f = (PFNGLMULTITEXCOORD3FPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3f\")) == NULL) || r;\n  r = ((glMultiTexCoord3fv = (PFNGLMULTITEXCOORD3FVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3fv\")) == NULL) || r;\n  r = ((glMultiTexCoord3i = (PFNGLMULTITEXCOORD3IPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3i\")) == NULL) || r;\n  r = ((glMultiTexCoord3iv = (PFNGLMULTITEXCOORD3IVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3iv\")) == NULL) || r;\n  r = ((glMultiTexCoord3s = (PFNGLMULTITEXCOORD3SPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3s\")) == NULL) || r;\n  r = ((glMultiTexCoord3sv = (PFNGLMULTITEXCOORD3SVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3sv\")) == NULL) || r;\n  r = ((glMultiTexCoord4d = (PFNGLMULTITEXCOORD4DPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4d\")) == NULL) || r;\n  r = ((glMultiTexCoord4dv = (PFNGLMULTITEXCOORD4DVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4dv\")) == NULL) || r;\n  r = ((glMultiTexCoord4f = (PFNGLMULTITEXCOORD4FPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4f\")) == NULL) || r;\n  r = ((glMultiTexCoord4fv = (PFNGLMULTITEXCOORD4FVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4fv\")) == NULL) || r;\n  r = ((glMultiTexCoord4i = (PFNGLMULTITEXCOORD4IPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4i\")) == NULL) || r;\n  r = ((glMultiTexCoord4iv = (PFNGLMULTITEXCOORD4IVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4iv\")) == NULL) || r;\n  r = ((glMultiTexCoord4s = (PFNGLMULTITEXCOORD4SPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4s\")) == NULL) || r;\n  r = ((glMultiTexCoord4sv = (PFNGLMULTITEXCOORD4SVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4sv\")) == NULL) || r;\n  r = ((glSampleCoverage = (PFNGLSAMPLECOVERAGEPROC)glewGetProcAddress((const GLubyte*)\"glSampleCoverage\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_VERSION_1_3 */\n\n#ifdef GL_VERSION_1_4\n\nstatic GLboolean _glewInit_GL_VERSION_1_4 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBlendColor = (PFNGLBLENDCOLORPROC)glewGetProcAddress((const GLubyte*)\"glBlendColor\")) == NULL) || r;\n  r = ((glBlendEquation = (PFNGLBLENDEQUATIONPROC)glewGetProcAddress((const GLubyte*)\"glBlendEquation\")) == NULL) || r;\n  r = ((glBlendFuncSeparate = (PFNGLBLENDFUNCSEPARATEPROC)glewGetProcAddress((const GLubyte*)\"glBlendFuncSeparate\")) == NULL) || r;\n  r = ((glFogCoordPointer = (PFNGLFOGCOORDPOINTERPROC)glewGetProcAddress((const GLubyte*)\"glFogCoordPointer\")) == NULL) || r;\n  r = ((glFogCoordd = (PFNGLFOGCOORDDPROC)glewGetProcAddress((const GLubyte*)\"glFogCoordd\")) == NULL) || r;\n  r = ((glFogCoorddv = (PFNGLFOGCOORDDVPROC)glewGetProcAddress((const GLubyte*)\"glFogCoorddv\")) == NULL) || r;\n  r = ((glFogCoordf = (PFNGLFOGCOORDFPROC)glewGetProcAddress((const GLubyte*)\"glFogCoordf\")) == NULL) || r;\n  r = ((glFogCoordfv = (PFNGLFOGCOORDFVPROC)glewGetProcAddress((const GLubyte*)\"glFogCoordfv\")) == NULL) || r;\n  r = ((glMultiDrawArrays = (PFNGLMULTIDRAWARRAYSPROC)glewGetProcAddress((const GLubyte*)\"glMultiDrawArrays\")) == NULL) || r;\n  r = ((glMultiDrawElements = (PFNGLMULTIDRAWELEMENTSPROC)glewGetProcAddress((const GLubyte*)\"glMultiDrawElements\")) == NULL) || r;\n  r = ((glPointParameterf = (PFNGLPOINTPARAMETERFPROC)glewGetProcAddress((const GLubyte*)\"glPointParameterf\")) == NULL) || r;\n  r = ((glPointParameterfv = (PFNGLPOINTPARAMETERFVPROC)glewGetProcAddress((const GLubyte*)\"glPointParameterfv\")) == NULL) || r;\n  r = ((glPointParameteri = (PFNGLPOINTPARAMETERIPROC)glewGetProcAddress((const GLubyte*)\"glPointParameteri\")) == NULL) || r;\n  r = ((glPointParameteriv = (PFNGLPOINTPARAMETERIVPROC)glewGetProcAddress((const GLubyte*)\"glPointParameteriv\")) == NULL) || r;\n  r = ((glSecondaryColor3b = (PFNGLSECONDARYCOLOR3BPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3b\")) == NULL) || r;\n  r = ((glSecondaryColor3bv = (PFNGLSECONDARYCOLOR3BVPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3bv\")) == NULL) || r;\n  r = ((glSecondaryColor3d = (PFNGLSECONDARYCOLOR3DPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3d\")) == NULL) || r;\n  r = ((glSecondaryColor3dv = (PFNGLSECONDARYCOLOR3DVPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3dv\")) == NULL) || r;\n  r = ((glSecondaryColor3f = (PFNGLSECONDARYCOLOR3FPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3f\")) == NULL) || r;\n  r = ((glSecondaryColor3fv = (PFNGLSECONDARYCOLOR3FVPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3fv\")) == NULL) || r;\n  r = ((glSecondaryColor3i = (PFNGLSECONDARYCOLOR3IPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3i\")) == NULL) || r;\n  r = ((glSecondaryColor3iv = (PFNGLSECONDARYCOLOR3IVPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3iv\")) == NULL) || r;\n  r = ((glSecondaryColor3s = (PFNGLSECONDARYCOLOR3SPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3s\")) == NULL) || r;\n  r = ((glSecondaryColor3sv = (PFNGLSECONDARYCOLOR3SVPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3sv\")) == NULL) || r;\n  r = ((glSecondaryColor3ub = (PFNGLSECONDARYCOLOR3UBPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3ub\")) == NULL) || r;\n  r = ((glSecondaryColor3ubv = (PFNGLSECONDARYCOLOR3UBVPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3ubv\")) == NULL) || r;\n  r = ((glSecondaryColor3ui = (PFNGLSECONDARYCOLOR3UIPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3ui\")) == NULL) || r;\n  r = ((glSecondaryColor3uiv = (PFNGLSECONDARYCOLOR3UIVPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3uiv\")) == NULL) || r;\n  r = ((glSecondaryColor3us = (PFNGLSECONDARYCOLOR3USPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3us\")) == NULL) || r;\n  r = ((glSecondaryColor3usv = (PFNGLSECONDARYCOLOR3USVPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3usv\")) == NULL) || r;\n  r = ((glSecondaryColorPointer = (PFNGLSECONDARYCOLORPOINTERPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColorPointer\")) == NULL) || r;\n  r = ((glWindowPos2d = (PFNGLWINDOWPOS2DPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2d\")) == NULL) || r;\n  r = ((glWindowPos2dv = (PFNGLWINDOWPOS2DVPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2dv\")) == NULL) || r;\n  r = ((glWindowPos2f = (PFNGLWINDOWPOS2FPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2f\")) == NULL) || r;\n  r = ((glWindowPos2fv = (PFNGLWINDOWPOS2FVPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2fv\")) == NULL) || r;\n  r = ((glWindowPos2i = (PFNGLWINDOWPOS2IPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2i\")) == NULL) || r;\n  r = ((glWindowPos2iv = (PFNGLWINDOWPOS2IVPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2iv\")) == NULL) || r;\n  r = ((glWindowPos2s = (PFNGLWINDOWPOS2SPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2s\")) == NULL) || r;\n  r = ((glWindowPos2sv = (PFNGLWINDOWPOS2SVPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2sv\")) == NULL) || r;\n  r = ((glWindowPos3d = (PFNGLWINDOWPOS3DPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3d\")) == NULL) || r;\n  r = ((glWindowPos3dv = (PFNGLWINDOWPOS3DVPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3dv\")) == NULL) || r;\n  r = ((glWindowPos3f = (PFNGLWINDOWPOS3FPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3f\")) == NULL) || r;\n  r = ((glWindowPos3fv = (PFNGLWINDOWPOS3FVPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3fv\")) == NULL) || r;\n  r = ((glWindowPos3i = (PFNGLWINDOWPOS3IPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3i\")) == NULL) || r;\n  r = ((glWindowPos3iv = (PFNGLWINDOWPOS3IVPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3iv\")) == NULL) || r;\n  r = ((glWindowPos3s = (PFNGLWINDOWPOS3SPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3s\")) == NULL) || r;\n  r = ((glWindowPos3sv = (PFNGLWINDOWPOS3SVPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3sv\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_VERSION_1_4 */\n\n#ifdef GL_VERSION_1_5\n\nstatic GLboolean _glewInit_GL_VERSION_1_5 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBeginQuery = (PFNGLBEGINQUERYPROC)glewGetProcAddress((const GLubyte*)\"glBeginQuery\")) == NULL) || r;\n  r = ((glBindBuffer = (PFNGLBINDBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glBindBuffer\")) == NULL) || r;\n  r = ((glBufferData = (PFNGLBUFFERDATAPROC)glewGetProcAddress((const GLubyte*)\"glBufferData\")) == NULL) || r;\n  r = ((glBufferSubData = (PFNGLBUFFERSUBDATAPROC)glewGetProcAddress((const GLubyte*)\"glBufferSubData\")) == NULL) || r;\n  r = ((glDeleteBuffers = (PFNGLDELETEBUFFERSPROC)glewGetProcAddress((const GLubyte*)\"glDeleteBuffers\")) == NULL) || r;\n  r = ((glDeleteQueries = (PFNGLDELETEQUERIESPROC)glewGetProcAddress((const GLubyte*)\"glDeleteQueries\")) == NULL) || r;\n  r = ((glEndQuery = (PFNGLENDQUERYPROC)glewGetProcAddress((const GLubyte*)\"glEndQuery\")) == NULL) || r;\n  r = ((glGenBuffers = (PFNGLGENBUFFERSPROC)glewGetProcAddress((const GLubyte*)\"glGenBuffers\")) == NULL) || r;\n  r = ((glGenQueries = (PFNGLGENQUERIESPROC)glewGetProcAddress((const GLubyte*)\"glGenQueries\")) == NULL) || r;\n  r = ((glGetBufferParameteriv = (PFNGLGETBUFFERPARAMETERIVPROC)glewGetProcAddress((const GLubyte*)\"glGetBufferParameteriv\")) == NULL) || r;\n  r = ((glGetBufferPointerv = (PFNGLGETBUFFERPOINTERVPROC)glewGetProcAddress((const GLubyte*)\"glGetBufferPointerv\")) == NULL) || r;\n  r = ((glGetBufferSubData = (PFNGLGETBUFFERSUBDATAPROC)glewGetProcAddress((const GLubyte*)\"glGetBufferSubData\")) == NULL) || r;\n  r = ((glGetQueryObjectiv = (PFNGLGETQUERYOBJECTIVPROC)glewGetProcAddress((const GLubyte*)\"glGetQueryObjectiv\")) == NULL) || r;\n  r = ((glGetQueryObjectuiv = (PFNGLGETQUERYOBJECTUIVPROC)glewGetProcAddress((const GLubyte*)\"glGetQueryObjectuiv\")) == NULL) || r;\n  r = ((glGetQueryiv = (PFNGLGETQUERYIVPROC)glewGetProcAddress((const GLubyte*)\"glGetQueryiv\")) == NULL) || r;\n  r = ((glIsBuffer = (PFNGLISBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glIsBuffer\")) == NULL) || r;\n  r = ((glIsQuery = (PFNGLISQUERYPROC)glewGetProcAddress((const GLubyte*)\"glIsQuery\")) == NULL) || r;\n  r = ((glMapBuffer = (PFNGLMAPBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glMapBuffer\")) == NULL) || r;\n  r = ((glUnmapBuffer = (PFNGLUNMAPBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glUnmapBuffer\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_VERSION_1_5 */\n\n#ifdef GL_VERSION_2_0\n\nstatic GLboolean _glewInit_GL_VERSION_2_0 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glAttachShader = (PFNGLATTACHSHADERPROC)glewGetProcAddress((const GLubyte*)\"glAttachShader\")) == NULL) || r;\n  r = ((glBindAttribLocation = (PFNGLBINDATTRIBLOCATIONPROC)glewGetProcAddress((const GLubyte*)\"glBindAttribLocation\")) == NULL) || r;\n  r = ((glBlendEquationSeparate = (PFNGLBLENDEQUATIONSEPARATEPROC)glewGetProcAddress((const GLubyte*)\"glBlendEquationSeparate\")) == NULL) || r;\n  r = ((glCompileShader = (PFNGLCOMPILESHADERPROC)glewGetProcAddress((const GLubyte*)\"glCompileShader\")) == NULL) || r;\n  r = ((glCreateProgram = (PFNGLCREATEPROGRAMPROC)glewGetProcAddress((const GLubyte*)\"glCreateProgram\")) == NULL) || r;\n  r = ((glCreateShader = (PFNGLCREATESHADERPROC)glewGetProcAddress((const GLubyte*)\"glCreateShader\")) == NULL) || r;\n  r = ((glDeleteProgram = (PFNGLDELETEPROGRAMPROC)glewGetProcAddress((const GLubyte*)\"glDeleteProgram\")) == NULL) || r;\n  r = ((glDeleteShader = (PFNGLDELETESHADERPROC)glewGetProcAddress((const GLubyte*)\"glDeleteShader\")) == NULL) || r;\n  r = ((glDetachShader = (PFNGLDETACHSHADERPROC)glewGetProcAddress((const GLubyte*)\"glDetachShader\")) == NULL) || r;\n  r = ((glDisableVertexAttribArray = (PFNGLDISABLEVERTEXATTRIBARRAYPROC)glewGetProcAddress((const GLubyte*)\"glDisableVertexAttribArray\")) == NULL) || r;\n  r = ((glDrawBuffers = (PFNGLDRAWBUFFERSPROC)glewGetProcAddress((const GLubyte*)\"glDrawBuffers\")) == NULL) || r;\n  r = ((glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC)glewGetProcAddress((const GLubyte*)\"glEnableVertexAttribArray\")) == NULL) || r;\n  r = ((glGetActiveAttrib = (PFNGLGETACTIVEATTRIBPROC)glewGetProcAddress((const GLubyte*)\"glGetActiveAttrib\")) == NULL) || r;\n  r = ((glGetActiveUniform = (PFNGLGETACTIVEUNIFORMPROC)glewGetProcAddress((const GLubyte*)\"glGetActiveUniform\")) == NULL) || r;\n  r = ((glGetAttachedShaders = (PFNGLGETATTACHEDSHADERSPROC)glewGetProcAddress((const GLubyte*)\"glGetAttachedShaders\")) == NULL) || r;\n  r = ((glGetAttribLocation = (PFNGLGETATTRIBLOCATIONPROC)glewGetProcAddress((const GLubyte*)\"glGetAttribLocation\")) == NULL) || r;\n  r = ((glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramInfoLog\")) == NULL) || r;\n  r = ((glGetProgramiv = (PFNGLGETPROGRAMIVPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramiv\")) == NULL) || r;\n  r = ((glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC)glewGetProcAddress((const GLubyte*)\"glGetShaderInfoLog\")) == NULL) || r;\n  r = ((glGetShaderSource = (PFNGLGETSHADERSOURCEPROC)glewGetProcAddress((const GLubyte*)\"glGetShaderSource\")) == NULL) || r;\n  r = ((glGetShaderiv = (PFNGLGETSHADERIVPROC)glewGetProcAddress((const GLubyte*)\"glGetShaderiv\")) == NULL) || r;\n  r = ((glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC)glewGetProcAddress((const GLubyte*)\"glGetUniformLocation\")) == NULL) || r;\n  r = ((glGetUniformfv = (PFNGLGETUNIFORMFVPROC)glewGetProcAddress((const GLubyte*)\"glGetUniformfv\")) == NULL) || r;\n  r = ((glGetUniformiv = (PFNGLGETUNIFORMIVPROC)glewGetProcAddress((const GLubyte*)\"glGetUniformiv\")) == NULL) || r;\n  r = ((glGetVertexAttribPointerv = (PFNGLGETVERTEXATTRIBPOINTERVPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribPointerv\")) == NULL) || r;\n  r = ((glGetVertexAttribdv = (PFNGLGETVERTEXATTRIBDVPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribdv\")) == NULL) || r;\n  r = ((glGetVertexAttribfv = (PFNGLGETVERTEXATTRIBFVPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribfv\")) == NULL) || r;\n  r = ((glGetVertexAttribiv = (PFNGLGETVERTEXATTRIBIVPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribiv\")) == NULL) || r;\n  r = ((glIsProgram = (PFNGLISPROGRAMPROC)glewGetProcAddress((const GLubyte*)\"glIsProgram\")) == NULL) || r;\n  r = ((glIsShader = (PFNGLISSHADERPROC)glewGetProcAddress((const GLubyte*)\"glIsShader\")) == NULL) || r;\n  r = ((glLinkProgram = (PFNGLLINKPROGRAMPROC)glewGetProcAddress((const GLubyte*)\"glLinkProgram\")) == NULL) || r;\n  r = ((glShaderSource = (PFNGLSHADERSOURCEPROC)glewGetProcAddress((const GLubyte*)\"glShaderSource\")) == NULL) || r;\n  r = ((glStencilFuncSeparate = (PFNGLSTENCILFUNCSEPARATEPROC)glewGetProcAddress((const GLubyte*)\"glStencilFuncSeparate\")) == NULL) || r;\n  r = ((glStencilMaskSeparate = (PFNGLSTENCILMASKSEPARATEPROC)glewGetProcAddress((const GLubyte*)\"glStencilMaskSeparate\")) == NULL) || r;\n  r = ((glStencilOpSeparate = (PFNGLSTENCILOPSEPARATEPROC)glewGetProcAddress((const GLubyte*)\"glStencilOpSeparate\")) == NULL) || r;\n  r = ((glUniform1f = (PFNGLUNIFORM1FPROC)glewGetProcAddress((const GLubyte*)\"glUniform1f\")) == NULL) || r;\n  r = ((glUniform1fv = (PFNGLUNIFORM1FVPROC)glewGetProcAddress((const GLubyte*)\"glUniform1fv\")) == NULL) || r;\n  r = ((glUniform1i = (PFNGLUNIFORM1IPROC)glewGetProcAddress((const GLubyte*)\"glUniform1i\")) == NULL) || r;\n  r = ((glUniform1iv = (PFNGLUNIFORM1IVPROC)glewGetProcAddress((const GLubyte*)\"glUniform1iv\")) == NULL) || r;\n  r = ((glUniform2f = (PFNGLUNIFORM2FPROC)glewGetProcAddress((const GLubyte*)\"glUniform2f\")) == NULL) || r;\n  r = ((glUniform2fv = (PFNGLUNIFORM2FVPROC)glewGetProcAddress((const GLubyte*)\"glUniform2fv\")) == NULL) || r;\n  r = ((glUniform2i = (PFNGLUNIFORM2IPROC)glewGetProcAddress((const GLubyte*)\"glUniform2i\")) == NULL) || r;\n  r = ((glUniform2iv = (PFNGLUNIFORM2IVPROC)glewGetProcAddress((const GLubyte*)\"glUniform2iv\")) == NULL) || r;\n  r = ((glUniform3f = (PFNGLUNIFORM3FPROC)glewGetProcAddress((const GLubyte*)\"glUniform3f\")) == NULL) || r;\n  r = ((glUniform3fv = (PFNGLUNIFORM3FVPROC)glewGetProcAddress((const GLubyte*)\"glUniform3fv\")) == NULL) || r;\n  r = ((glUniform3i = (PFNGLUNIFORM3IPROC)glewGetProcAddress((const GLubyte*)\"glUniform3i\")) == NULL) || r;\n  r = ((glUniform3iv = (PFNGLUNIFORM3IVPROC)glewGetProcAddress((const GLubyte*)\"glUniform3iv\")) == NULL) || r;\n  r = ((glUniform4f = (PFNGLUNIFORM4FPROC)glewGetProcAddress((const GLubyte*)\"glUniform4f\")) == NULL) || r;\n  r = ((glUniform4fv = (PFNGLUNIFORM4FVPROC)glewGetProcAddress((const GLubyte*)\"glUniform4fv\")) == NULL) || r;\n  r = ((glUniform4i = (PFNGLUNIFORM4IPROC)glewGetProcAddress((const GLubyte*)\"glUniform4i\")) == NULL) || r;\n  r = ((glUniform4iv = (PFNGLUNIFORM4IVPROC)glewGetProcAddress((const GLubyte*)\"glUniform4iv\")) == NULL) || r;\n  r = ((glUniformMatrix2fv = (PFNGLUNIFORMMATRIX2FVPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix2fv\")) == NULL) || r;\n  r = ((glUniformMatrix3fv = (PFNGLUNIFORMMATRIX3FVPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix3fv\")) == NULL) || r;\n  r = ((glUniformMatrix4fv = (PFNGLUNIFORMMATRIX4FVPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix4fv\")) == NULL) || r;\n  r = ((glUseProgram = (PFNGLUSEPROGRAMPROC)glewGetProcAddress((const GLubyte*)\"glUseProgram\")) == NULL) || r;\n  r = ((glValidateProgram = (PFNGLVALIDATEPROGRAMPROC)glewGetProcAddress((const GLubyte*)\"glValidateProgram\")) == NULL) || r;\n  r = ((glVertexAttrib1d = (PFNGLVERTEXATTRIB1DPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1d\")) == NULL) || r;\n  r = ((glVertexAttrib1dv = (PFNGLVERTEXATTRIB1DVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1dv\")) == NULL) || r;\n  r = ((glVertexAttrib1f = (PFNGLVERTEXATTRIB1FPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1f\")) == NULL) || r;\n  r = ((glVertexAttrib1fv = (PFNGLVERTEXATTRIB1FVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1fv\")) == NULL) || r;\n  r = ((glVertexAttrib1s = (PFNGLVERTEXATTRIB1SPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1s\")) == NULL) || r;\n  r = ((glVertexAttrib1sv = (PFNGLVERTEXATTRIB1SVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1sv\")) == NULL) || r;\n  r = ((glVertexAttrib2d = (PFNGLVERTEXATTRIB2DPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2d\")) == NULL) || r;\n  r = ((glVertexAttrib2dv = (PFNGLVERTEXATTRIB2DVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2dv\")) == NULL) || r;\n  r = ((glVertexAttrib2f = (PFNGLVERTEXATTRIB2FPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2f\")) == NULL) || r;\n  r = ((glVertexAttrib2fv = (PFNGLVERTEXATTRIB2FVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2fv\")) == NULL) || r;\n  r = ((glVertexAttrib2s = (PFNGLVERTEXATTRIB2SPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2s\")) == NULL) || r;\n  r = ((glVertexAttrib2sv = (PFNGLVERTEXATTRIB2SVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2sv\")) == NULL) || r;\n  r = ((glVertexAttrib3d = (PFNGLVERTEXATTRIB3DPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3d\")) == NULL) || r;\n  r = ((glVertexAttrib3dv = (PFNGLVERTEXATTRIB3DVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3dv\")) == NULL) || r;\n  r = ((glVertexAttrib3f = (PFNGLVERTEXATTRIB3FPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3f\")) == NULL) || r;\n  r = ((glVertexAttrib3fv = (PFNGLVERTEXATTRIB3FVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3fv\")) == NULL) || r;\n  r = ((glVertexAttrib3s = (PFNGLVERTEXATTRIB3SPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3s\")) == NULL) || r;\n  r = ((glVertexAttrib3sv = (PFNGLVERTEXATTRIB3SVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3sv\")) == NULL) || r;\n  r = ((glVertexAttrib4Nbv = (PFNGLVERTEXATTRIB4NBVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4Nbv\")) == NULL) || r;\n  r = ((glVertexAttrib4Niv = (PFNGLVERTEXATTRIB4NIVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4Niv\")) == NULL) || r;\n  r = ((glVertexAttrib4Nsv = (PFNGLVERTEXATTRIB4NSVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4Nsv\")) == NULL) || r;\n  r = ((glVertexAttrib4Nub = (PFNGLVERTEXATTRIB4NUBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4Nub\")) == NULL) || r;\n  r = ((glVertexAttrib4Nubv = (PFNGLVERTEXATTRIB4NUBVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4Nubv\")) == NULL) || r;\n  r = ((glVertexAttrib4Nuiv = (PFNGLVERTEXATTRIB4NUIVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4Nuiv\")) == NULL) || r;\n  r = ((glVertexAttrib4Nusv = (PFNGLVERTEXATTRIB4NUSVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4Nusv\")) == NULL) || r;\n  r = ((glVertexAttrib4bv = (PFNGLVERTEXATTRIB4BVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4bv\")) == NULL) || r;\n  r = ((glVertexAttrib4d = (PFNGLVERTEXATTRIB4DPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4d\")) == NULL) || r;\n  r = ((glVertexAttrib4dv = (PFNGLVERTEXATTRIB4DVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4dv\")) == NULL) || r;\n  r = ((glVertexAttrib4f = (PFNGLVERTEXATTRIB4FPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4f\")) == NULL) || r;\n  r = ((glVertexAttrib4fv = (PFNGLVERTEXATTRIB4FVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4fv\")) == NULL) || r;\n  r = ((glVertexAttrib4iv = (PFNGLVERTEXATTRIB4IVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4iv\")) == NULL) || r;\n  r = ((glVertexAttrib4s = (PFNGLVERTEXATTRIB4SPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4s\")) == NULL) || r;\n  r = ((glVertexAttrib4sv = (PFNGLVERTEXATTRIB4SVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4sv\")) == NULL) || r;\n  r = ((glVertexAttrib4ubv = (PFNGLVERTEXATTRIB4UBVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4ubv\")) == NULL) || r;\n  r = ((glVertexAttrib4uiv = (PFNGLVERTEXATTRIB4UIVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4uiv\")) == NULL) || r;\n  r = ((glVertexAttrib4usv = (PFNGLVERTEXATTRIB4USVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4usv\")) == NULL) || r;\n  r = ((glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribPointer\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_VERSION_2_0 */\n\n#ifdef GL_VERSION_2_1\n\nstatic GLboolean _glewInit_GL_VERSION_2_1 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glUniformMatrix2x3fv = (PFNGLUNIFORMMATRIX2X3FVPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix2x3fv\")) == NULL) || r;\n  r = ((glUniformMatrix2x4fv = (PFNGLUNIFORMMATRIX2X4FVPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix2x4fv\")) == NULL) || r;\n  r = ((glUniformMatrix3x2fv = (PFNGLUNIFORMMATRIX3X2FVPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix3x2fv\")) == NULL) || r;\n  r = ((glUniformMatrix3x4fv = (PFNGLUNIFORMMATRIX3X4FVPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix3x4fv\")) == NULL) || r;\n  r = ((glUniformMatrix4x2fv = (PFNGLUNIFORMMATRIX4X2FVPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix4x2fv\")) == NULL) || r;\n  r = ((glUniformMatrix4x3fv = (PFNGLUNIFORMMATRIX4X3FVPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix4x3fv\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_VERSION_2_1 */\n\n#ifdef GL_VERSION_3_0\n\nstatic GLboolean _glewInit_GL_VERSION_3_0 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBeginConditionalRender = (PFNGLBEGINCONDITIONALRENDERPROC)glewGetProcAddress((const GLubyte*)\"glBeginConditionalRender\")) == NULL) || r;\n  r = ((glBeginTransformFeedback = (PFNGLBEGINTRANSFORMFEEDBACKPROC)glewGetProcAddress((const GLubyte*)\"glBeginTransformFeedback\")) == NULL) || r;\n  r = ((glBindBufferBase = (PFNGLBINDBUFFERBASEPROC)glewGetProcAddress((const GLubyte*)\"glBindBufferBase\")) == NULL) || r;\n  r = ((glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC)glewGetProcAddress((const GLubyte*)\"glBindBufferRange\")) == NULL) || r;\n  r = ((glBindFragDataLocation = (PFNGLBINDFRAGDATALOCATIONPROC)glewGetProcAddress((const GLubyte*)\"glBindFragDataLocation\")) == NULL) || r;\n  r = ((glClampColor = (PFNGLCLAMPCOLORPROC)glewGetProcAddress((const GLubyte*)\"glClampColor\")) == NULL) || r;\n  r = ((glClearBufferfi = (PFNGLCLEARBUFFERFIPROC)glewGetProcAddress((const GLubyte*)\"glClearBufferfi\")) == NULL) || r;\n  r = ((glClearBufferfv = (PFNGLCLEARBUFFERFVPROC)glewGetProcAddress((const GLubyte*)\"glClearBufferfv\")) == NULL) || r;\n  r = ((glClearBufferiv = (PFNGLCLEARBUFFERIVPROC)glewGetProcAddress((const GLubyte*)\"glClearBufferiv\")) == NULL) || r;\n  r = ((glClearBufferuiv = (PFNGLCLEARBUFFERUIVPROC)glewGetProcAddress((const GLubyte*)\"glClearBufferuiv\")) == NULL) || r;\n  r = ((glColorMaski = (PFNGLCOLORMASKIPROC)glewGetProcAddress((const GLubyte*)\"glColorMaski\")) == NULL) || r;\n  r = ((glDisablei = (PFNGLDISABLEIPROC)glewGetProcAddress((const GLubyte*)\"glDisablei\")) == NULL) || r;\n  r = ((glEnablei = (PFNGLENABLEIPROC)glewGetProcAddress((const GLubyte*)\"glEnablei\")) == NULL) || r;\n  r = ((glEndConditionalRender = (PFNGLENDCONDITIONALRENDERPROC)glewGetProcAddress((const GLubyte*)\"glEndConditionalRender\")) == NULL) || r;\n  r = ((glEndTransformFeedback = (PFNGLENDTRANSFORMFEEDBACKPROC)glewGetProcAddress((const GLubyte*)\"glEndTransformFeedback\")) == NULL) || r;\n  r = ((glGetBooleani_v = (PFNGLGETBOOLEANI_VPROC)glewGetProcAddress((const GLubyte*)\"glGetBooleani_v\")) == NULL) || r;\n  r = ((glGetFragDataLocation = (PFNGLGETFRAGDATALOCATIONPROC)glewGetProcAddress((const GLubyte*)\"glGetFragDataLocation\")) == NULL) || r;\n  r = ((glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC)glewGetProcAddress((const GLubyte*)\"glGetIntegeri_v\")) == NULL) || r;\n  r = ((glGetStringi = (PFNGLGETSTRINGIPROC)glewGetProcAddress((const GLubyte*)\"glGetStringi\")) == NULL) || r;\n  r = ((glGetTexParameterIiv = (PFNGLGETTEXPARAMETERIIVPROC)glewGetProcAddress((const GLubyte*)\"glGetTexParameterIiv\")) == NULL) || r;\n  r = ((glGetTexParameterIuiv = (PFNGLGETTEXPARAMETERIUIVPROC)glewGetProcAddress((const GLubyte*)\"glGetTexParameterIuiv\")) == NULL) || r;\n  r = ((glGetTransformFeedbackVarying = (PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)glewGetProcAddress((const GLubyte*)\"glGetTransformFeedbackVarying\")) == NULL) || r;\n  r = ((glGetUniformuiv = (PFNGLGETUNIFORMUIVPROC)glewGetProcAddress((const GLubyte*)\"glGetUniformuiv\")) == NULL) || r;\n  r = ((glGetVertexAttribIiv = (PFNGLGETVERTEXATTRIBIIVPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribIiv\")) == NULL) || r;\n  r = ((glGetVertexAttribIuiv = (PFNGLGETVERTEXATTRIBIUIVPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribIuiv\")) == NULL) || r;\n  r = ((glIsEnabledi = (PFNGLISENABLEDIPROC)glewGetProcAddress((const GLubyte*)\"glIsEnabledi\")) == NULL) || r;\n  r = ((glTexParameterIiv = (PFNGLTEXPARAMETERIIVPROC)glewGetProcAddress((const GLubyte*)\"glTexParameterIiv\")) == NULL) || r;\n  r = ((glTexParameterIuiv = (PFNGLTEXPARAMETERIUIVPROC)glewGetProcAddress((const GLubyte*)\"glTexParameterIuiv\")) == NULL) || r;\n  r = ((glTransformFeedbackVaryings = (PFNGLTRANSFORMFEEDBACKVARYINGSPROC)glewGetProcAddress((const GLubyte*)\"glTransformFeedbackVaryings\")) == NULL) || r;\n  r = ((glUniform1ui = (PFNGLUNIFORM1UIPROC)glewGetProcAddress((const GLubyte*)\"glUniform1ui\")) == NULL) || r;\n  r = ((glUniform1uiv = (PFNGLUNIFORM1UIVPROC)glewGetProcAddress((const GLubyte*)\"glUniform1uiv\")) == NULL) || r;\n  r = ((glUniform2ui = (PFNGLUNIFORM2UIPROC)glewGetProcAddress((const GLubyte*)\"glUniform2ui\")) == NULL) || r;\n  r = ((glUniform2uiv = (PFNGLUNIFORM2UIVPROC)glewGetProcAddress((const GLubyte*)\"glUniform2uiv\")) == NULL) || r;\n  r = ((glUniform3ui = (PFNGLUNIFORM3UIPROC)glewGetProcAddress((const GLubyte*)\"glUniform3ui\")) == NULL) || r;\n  r = ((glUniform3uiv = (PFNGLUNIFORM3UIVPROC)glewGetProcAddress((const GLubyte*)\"glUniform3uiv\")) == NULL) || r;\n  r = ((glUniform4ui = (PFNGLUNIFORM4UIPROC)glewGetProcAddress((const GLubyte*)\"glUniform4ui\")) == NULL) || r;\n  r = ((glUniform4uiv = (PFNGLUNIFORM4UIVPROC)glewGetProcAddress((const GLubyte*)\"glUniform4uiv\")) == NULL) || r;\n  r = ((glVertexAttribI1i = (PFNGLVERTEXATTRIBI1IPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI1i\")) == NULL) || r;\n  r = ((glVertexAttribI1iv = (PFNGLVERTEXATTRIBI1IVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI1iv\")) == NULL) || r;\n  r = ((glVertexAttribI1ui = (PFNGLVERTEXATTRIBI1UIPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI1ui\")) == NULL) || r;\n  r = ((glVertexAttribI1uiv = (PFNGLVERTEXATTRIBI1UIVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI1uiv\")) == NULL) || r;\n  r = ((glVertexAttribI2i = (PFNGLVERTEXATTRIBI2IPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI2i\")) == NULL) || r;\n  r = ((glVertexAttribI2iv = (PFNGLVERTEXATTRIBI2IVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI2iv\")) == NULL) || r;\n  r = ((glVertexAttribI2ui = (PFNGLVERTEXATTRIBI2UIPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI2ui\")) == NULL) || r;\n  r = ((glVertexAttribI2uiv = (PFNGLVERTEXATTRIBI2UIVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI2uiv\")) == NULL) || r;\n  r = ((glVertexAttribI3i = (PFNGLVERTEXATTRIBI3IPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI3i\")) == NULL) || r;\n  r = ((glVertexAttribI3iv = (PFNGLVERTEXATTRIBI3IVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI3iv\")) == NULL) || r;\n  r = ((glVertexAttribI3ui = (PFNGLVERTEXATTRIBI3UIPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI3ui\")) == NULL) || r;\n  r = ((glVertexAttribI3uiv = (PFNGLVERTEXATTRIBI3UIVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI3uiv\")) == NULL) || r;\n  r = ((glVertexAttribI4bv = (PFNGLVERTEXATTRIBI4BVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4bv\")) == NULL) || r;\n  r = ((glVertexAttribI4i = (PFNGLVERTEXATTRIBI4IPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4i\")) == NULL) || r;\n  r = ((glVertexAttribI4iv = (PFNGLVERTEXATTRIBI4IVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4iv\")) == NULL) || r;\n  r = ((glVertexAttribI4sv = (PFNGLVERTEXATTRIBI4SVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4sv\")) == NULL) || r;\n  r = ((glVertexAttribI4ubv = (PFNGLVERTEXATTRIBI4UBVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4ubv\")) == NULL) || r;\n  r = ((glVertexAttribI4ui = (PFNGLVERTEXATTRIBI4UIPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4ui\")) == NULL) || r;\n  r = ((glVertexAttribI4uiv = (PFNGLVERTEXATTRIBI4UIVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4uiv\")) == NULL) || r;\n  r = ((glVertexAttribI4usv = (PFNGLVERTEXATTRIBI4USVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4usv\")) == NULL) || r;\n  r = ((glVertexAttribIPointer = (PFNGLVERTEXATTRIBIPOINTERPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribIPointer\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_VERSION_3_0 */\n\n#ifdef GL_3DFX_multisample\n\n#endif /* GL_3DFX_multisample */\n\n#ifdef GL_3DFX_tbuffer\n\nstatic GLboolean _glewInit_GL_3DFX_tbuffer (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glTbufferMask3DFX = (PFNGLTBUFFERMASK3DFXPROC)glewGetProcAddress((const GLubyte*)\"glTbufferMask3DFX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_3DFX_tbuffer */\n\n#ifdef GL_3DFX_texture_compression_FXT1\n\n#endif /* GL_3DFX_texture_compression_FXT1 */\n\n#ifdef GL_APPLE_client_storage\n\n#endif /* GL_APPLE_client_storage */\n\n#ifdef GL_APPLE_element_array\n\nstatic GLboolean _glewInit_GL_APPLE_element_array (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDrawElementArrayAPPLE = (PFNGLDRAWELEMENTARRAYAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glDrawElementArrayAPPLE\")) == NULL) || r;\n  r = ((glDrawRangeElementArrayAPPLE = (PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glDrawRangeElementArrayAPPLE\")) == NULL) || r;\n  r = ((glElementPointerAPPLE = (PFNGLELEMENTPOINTERAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glElementPointerAPPLE\")) == NULL) || r;\n  r = ((glMultiDrawElementArrayAPPLE = (PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glMultiDrawElementArrayAPPLE\")) == NULL) || r;\n  r = ((glMultiDrawRangeElementArrayAPPLE = (PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glMultiDrawRangeElementArrayAPPLE\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_APPLE_element_array */\n\n#ifdef GL_APPLE_fence\n\nstatic GLboolean _glewInit_GL_APPLE_fence (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDeleteFencesAPPLE = (PFNGLDELETEFENCESAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glDeleteFencesAPPLE\")) == NULL) || r;\n  r = ((glFinishFenceAPPLE = (PFNGLFINISHFENCEAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glFinishFenceAPPLE\")) == NULL) || r;\n  r = ((glFinishObjectAPPLE = (PFNGLFINISHOBJECTAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glFinishObjectAPPLE\")) == NULL) || r;\n  r = ((glGenFencesAPPLE = (PFNGLGENFENCESAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glGenFencesAPPLE\")) == NULL) || r;\n  r = ((glIsFenceAPPLE = (PFNGLISFENCEAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glIsFenceAPPLE\")) == NULL) || r;\n  r = ((glSetFenceAPPLE = (PFNGLSETFENCEAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glSetFenceAPPLE\")) == NULL) || r;\n  r = ((glTestFenceAPPLE = (PFNGLTESTFENCEAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glTestFenceAPPLE\")) == NULL) || r;\n  r = ((glTestObjectAPPLE = (PFNGLTESTOBJECTAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glTestObjectAPPLE\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_APPLE_fence */\n\n#ifdef GL_APPLE_float_pixels\n\n#endif /* GL_APPLE_float_pixels */\n\n#ifdef GL_APPLE_flush_buffer_range\n\nstatic GLboolean _glewInit_GL_APPLE_flush_buffer_range (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBufferParameteriAPPLE = (PFNGLBUFFERPARAMETERIAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glBufferParameteriAPPLE\")) == NULL) || r;\n  r = ((glFlushMappedBufferRangeAPPLE = (PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glFlushMappedBufferRangeAPPLE\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_APPLE_flush_buffer_range */\n\n#ifdef GL_APPLE_pixel_buffer\n\n#endif /* GL_APPLE_pixel_buffer */\n\n#ifdef GL_APPLE_specular_vector\n\n#endif /* GL_APPLE_specular_vector */\n\n#ifdef GL_APPLE_texture_range\n\nstatic GLboolean _glewInit_GL_APPLE_texture_range (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetTexParameterPointervAPPLE = (PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glGetTexParameterPointervAPPLE\")) == NULL) || r;\n  r = ((glTextureRangeAPPLE = (PFNGLTEXTURERANGEAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glTextureRangeAPPLE\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_APPLE_texture_range */\n\n#ifdef GL_APPLE_transform_hint\n\n#endif /* GL_APPLE_transform_hint */\n\n#ifdef GL_APPLE_vertex_array_object\n\nstatic GLboolean _glewInit_GL_APPLE_vertex_array_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBindVertexArrayAPPLE = (PFNGLBINDVERTEXARRAYAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glBindVertexArrayAPPLE\")) == NULL) || r;\n  r = ((glDeleteVertexArraysAPPLE = (PFNGLDELETEVERTEXARRAYSAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glDeleteVertexArraysAPPLE\")) == NULL) || r;\n  r = ((glGenVertexArraysAPPLE = (PFNGLGENVERTEXARRAYSAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glGenVertexArraysAPPLE\")) == NULL) || r;\n  r = ((glIsVertexArrayAPPLE = (PFNGLISVERTEXARRAYAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glIsVertexArrayAPPLE\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_APPLE_vertex_array_object */\n\n#ifdef GL_APPLE_vertex_array_range\n\nstatic GLboolean _glewInit_GL_APPLE_vertex_array_range (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFlushVertexArrayRangeAPPLE = (PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glFlushVertexArrayRangeAPPLE\")) == NULL) || r;\n  r = ((glVertexArrayParameteriAPPLE = (PFNGLVERTEXARRAYPARAMETERIAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glVertexArrayParameteriAPPLE\")) == NULL) || r;\n  r = ((glVertexArrayRangeAPPLE = (PFNGLVERTEXARRAYRANGEAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glVertexArrayRangeAPPLE\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_APPLE_vertex_array_range */\n\n#ifdef GL_APPLE_ycbcr_422\n\n#endif /* GL_APPLE_ycbcr_422 */\n\n#ifdef GL_ARB_color_buffer_float\n\nstatic GLboolean _glewInit_GL_ARB_color_buffer_float (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glClampColorARB = (PFNGLCLAMPCOLORARBPROC)glewGetProcAddress((const GLubyte*)\"glClampColorARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_color_buffer_float */\n\n#ifdef GL_ARB_depth_buffer_float\n\n#endif /* GL_ARB_depth_buffer_float */\n\n#ifdef GL_ARB_depth_texture\n\n#endif /* GL_ARB_depth_texture */\n\n#ifdef GL_ARB_draw_buffers\n\nstatic GLboolean _glewInit_GL_ARB_draw_buffers (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDrawBuffersARB = (PFNGLDRAWBUFFERSARBPROC)glewGetProcAddress((const GLubyte*)\"glDrawBuffersARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_draw_buffers */\n\n#ifdef GL_ARB_draw_instanced\n\nstatic GLboolean _glewInit_GL_ARB_draw_instanced (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDrawArraysInstancedARB = (PFNGLDRAWARRAYSINSTANCEDARBPROC)glewGetProcAddress((const GLubyte*)\"glDrawArraysInstancedARB\")) == NULL) || r;\n  r = ((glDrawElementsInstancedARB = (PFNGLDRAWELEMENTSINSTANCEDARBPROC)glewGetProcAddress((const GLubyte*)\"glDrawElementsInstancedARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_draw_instanced */\n\n#ifdef GL_ARB_fragment_program\n\n#endif /* GL_ARB_fragment_program */\n\n#ifdef GL_ARB_fragment_program_shadow\n\n#endif /* GL_ARB_fragment_program_shadow */\n\n#ifdef GL_ARB_fragment_shader\n\n#endif /* GL_ARB_fragment_shader */\n\n#ifdef GL_ARB_framebuffer_object\n\nstatic GLboolean _glewInit_GL_ARB_framebuffer_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBindFramebuffer = (PFNGLBINDFRAMEBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glBindFramebuffer\")) == NULL) || r;\n  r = ((glBindRenderbuffer = (PFNGLBINDRENDERBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glBindRenderbuffer\")) == NULL) || r;\n  r = ((glBlitFramebuffer = (PFNGLBLITFRAMEBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glBlitFramebuffer\")) == NULL) || r;\n  r = ((glCheckFramebufferStatus = (PFNGLCHECKFRAMEBUFFERSTATUSPROC)glewGetProcAddress((const GLubyte*)\"glCheckFramebufferStatus\")) == NULL) || r;\n  r = ((glDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC)glewGetProcAddress((const GLubyte*)\"glDeleteFramebuffers\")) == NULL) || r;\n  r = ((glDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC)glewGetProcAddress((const GLubyte*)\"glDeleteRenderbuffers\")) == NULL) || r;\n  r = ((glFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferRenderbuffer\")) == NULL) || r;\n  r = ((glFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTextureLayer\")) == NULL) || r;\n  r = ((glFramebufferTexture1D = (PFNGLFRAMEBUFFERTEXTURE1DPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTexture1D\")) == NULL) || r;\n  r = ((glFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTexture2D\")) == NULL) || r;\n  r = ((glFramebufferTexture3D = (PFNGLFRAMEBUFFERTEXTURE3DPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTexture3D\")) == NULL) || r;\n  r = ((glGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC)glewGetProcAddress((const GLubyte*)\"glGenFramebuffers\")) == NULL) || r;\n  r = ((glGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC)glewGetProcAddress((const GLubyte*)\"glGenRenderbuffers\")) == NULL) || r;\n  r = ((glGenerateMipmap = (PFNGLGENERATEMIPMAPPROC)glewGetProcAddress((const GLubyte*)\"glGenerateMipmap\")) == NULL) || r;\n  r = ((glGetFramebufferAttachmentParameteriv = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)glewGetProcAddress((const GLubyte*)\"glGetFramebufferAttachmentParameteriv\")) == NULL) || r;\n  r = ((glGetRenderbufferParameteriv = (PFNGLGETRENDERBUFFERPARAMETERIVPROC)glewGetProcAddress((const GLubyte*)\"glGetRenderbufferParameteriv\")) == NULL) || r;\n  r = ((glIsFramebuffer = (PFNGLISFRAMEBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glIsFramebuffer\")) == NULL) || r;\n  r = ((glIsRenderbuffer = (PFNGLISRENDERBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glIsRenderbuffer\")) == NULL) || r;\n  r = ((glRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC)glewGetProcAddress((const GLubyte*)\"glRenderbufferStorage\")) == NULL) || r;\n  r = ((glRenderbufferStorageMultisample = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)glewGetProcAddress((const GLubyte*)\"glRenderbufferStorageMultisample\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_framebuffer_object */\n\n#ifdef GL_ARB_framebuffer_sRGB\n\n#endif /* GL_ARB_framebuffer_sRGB */\n\n#ifdef GL_ARB_geometry_shader4\n\nstatic GLboolean _glewInit_GL_ARB_geometry_shader4 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFramebufferTextureARB = (PFNGLFRAMEBUFFERTEXTUREARBPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTextureARB\")) == NULL) || r;\n  r = ((glFramebufferTextureFaceARB = (PFNGLFRAMEBUFFERTEXTUREFACEARBPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTextureFaceARB\")) == NULL) || r;\n  r = ((glFramebufferTextureLayerARB = (PFNGLFRAMEBUFFERTEXTURELAYERARBPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTextureLayerARB\")) == NULL) || r;\n  r = ((glProgramParameteriARB = (PFNGLPROGRAMPARAMETERIARBPROC)glewGetProcAddress((const GLubyte*)\"glProgramParameteriARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_geometry_shader4 */\n\n#ifdef GL_ARB_half_float_pixel\n\n#endif /* GL_ARB_half_float_pixel */\n\n#ifdef GL_ARB_half_float_vertex\n\n#endif /* GL_ARB_half_float_vertex */\n\n#ifdef GL_ARB_imaging\n\nstatic GLboolean _glewInit_GL_ARB_imaging (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBlendEquation = (PFNGLBLENDEQUATIONPROC)glewGetProcAddress((const GLubyte*)\"glBlendEquation\")) == NULL) || r;\n  r = ((glColorSubTable = (PFNGLCOLORSUBTABLEPROC)glewGetProcAddress((const GLubyte*)\"glColorSubTable\")) == NULL) || r;\n  r = ((glColorTable = (PFNGLCOLORTABLEPROC)glewGetProcAddress((const GLubyte*)\"glColorTable\")) == NULL) || r;\n  r = ((glColorTableParameterfv = (PFNGLCOLORTABLEPARAMETERFVPROC)glewGetProcAddress((const GLubyte*)\"glColorTableParameterfv\")) == NULL) || r;\n  r = ((glColorTableParameteriv = (PFNGLCOLORTABLEPARAMETERIVPROC)glewGetProcAddress((const GLubyte*)\"glColorTableParameteriv\")) == NULL) || r;\n  r = ((glConvolutionFilter1D = (PFNGLCONVOLUTIONFILTER1DPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionFilter1D\")) == NULL) || r;\n  r = ((glConvolutionFilter2D = (PFNGLCONVOLUTIONFILTER2DPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionFilter2D\")) == NULL) || r;\n  r = ((glConvolutionParameterf = (PFNGLCONVOLUTIONPARAMETERFPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionParameterf\")) == NULL) || r;\n  r = ((glConvolutionParameterfv = (PFNGLCONVOLUTIONPARAMETERFVPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionParameterfv\")) == NULL) || r;\n  r = ((glConvolutionParameteri = (PFNGLCONVOLUTIONPARAMETERIPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionParameteri\")) == NULL) || r;\n  r = ((glConvolutionParameteriv = (PFNGLCONVOLUTIONPARAMETERIVPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionParameteriv\")) == NULL) || r;\n  r = ((glCopyColorSubTable = (PFNGLCOPYCOLORSUBTABLEPROC)glewGetProcAddress((const GLubyte*)\"glCopyColorSubTable\")) == NULL) || r;\n  r = ((glCopyColorTable = (PFNGLCOPYCOLORTABLEPROC)glewGetProcAddress((const GLubyte*)\"glCopyColorTable\")) == NULL) || r;\n  r = ((glCopyConvolutionFilter1D = (PFNGLCOPYCONVOLUTIONFILTER1DPROC)glewGetProcAddress((const GLubyte*)\"glCopyConvolutionFilter1D\")) == NULL) || r;\n  r = ((glCopyConvolutionFilter2D = (PFNGLCOPYCONVOLUTIONFILTER2DPROC)glewGetProcAddress((const GLubyte*)\"glCopyConvolutionFilter2D\")) == NULL) || r;\n  r = ((glGetColorTable = (PFNGLGETCOLORTABLEPROC)glewGetProcAddress((const GLubyte*)\"glGetColorTable\")) == NULL) || r;\n  r = ((glGetColorTableParameterfv = (PFNGLGETCOLORTABLEPARAMETERFVPROC)glewGetProcAddress((const GLubyte*)\"glGetColorTableParameterfv\")) == NULL) || r;\n  r = ((glGetColorTableParameteriv = (PFNGLGETCOLORTABLEPARAMETERIVPROC)glewGetProcAddress((const GLubyte*)\"glGetColorTableParameteriv\")) == NULL) || r;\n  r = ((glGetConvolutionFilter = (PFNGLGETCONVOLUTIONFILTERPROC)glewGetProcAddress((const GLubyte*)\"glGetConvolutionFilter\")) == NULL) || r;\n  r = ((glGetConvolutionParameterfv = (PFNGLGETCONVOLUTIONPARAMETERFVPROC)glewGetProcAddress((const GLubyte*)\"glGetConvolutionParameterfv\")) == NULL) || r;\n  r = ((glGetConvolutionParameteriv = (PFNGLGETCONVOLUTIONPARAMETERIVPROC)glewGetProcAddress((const GLubyte*)\"glGetConvolutionParameteriv\")) == NULL) || r;\n  r = ((glGetHistogram = (PFNGLGETHISTOGRAMPROC)glewGetProcAddress((const GLubyte*)\"glGetHistogram\")) == NULL) || r;\n  r = ((glGetHistogramParameterfv = (PFNGLGETHISTOGRAMPARAMETERFVPROC)glewGetProcAddress((const GLubyte*)\"glGetHistogramParameterfv\")) == NULL) || r;\n  r = ((glGetHistogramParameteriv = (PFNGLGETHISTOGRAMPARAMETERIVPROC)glewGetProcAddress((const GLubyte*)\"glGetHistogramParameteriv\")) == NULL) || r;\n  r = ((glGetMinmax = (PFNGLGETMINMAXPROC)glewGetProcAddress((const GLubyte*)\"glGetMinmax\")) == NULL) || r;\n  r = ((glGetMinmaxParameterfv = (PFNGLGETMINMAXPARAMETERFVPROC)glewGetProcAddress((const GLubyte*)\"glGetMinmaxParameterfv\")) == NULL) || r;\n  r = ((glGetMinmaxParameteriv = (PFNGLGETMINMAXPARAMETERIVPROC)glewGetProcAddress((const GLubyte*)\"glGetMinmaxParameteriv\")) == NULL) || r;\n  r = ((glGetSeparableFilter = (PFNGLGETSEPARABLEFILTERPROC)glewGetProcAddress((const GLubyte*)\"glGetSeparableFilter\")) == NULL) || r;\n  r = ((glHistogram = (PFNGLHISTOGRAMPROC)glewGetProcAddress((const GLubyte*)\"glHistogram\")) == NULL) || r;\n  r = ((glMinmax = (PFNGLMINMAXPROC)glewGetProcAddress((const GLubyte*)\"glMinmax\")) == NULL) || r;\n  r = ((glResetHistogram = (PFNGLRESETHISTOGRAMPROC)glewGetProcAddress((const GLubyte*)\"glResetHistogram\")) == NULL) || r;\n  r = ((glResetMinmax = (PFNGLRESETMINMAXPROC)glewGetProcAddress((const GLubyte*)\"glResetMinmax\")) == NULL) || r;\n  r = ((glSeparableFilter2D = (PFNGLSEPARABLEFILTER2DPROC)glewGetProcAddress((const GLubyte*)\"glSeparableFilter2D\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_imaging */\n\n#ifdef GL_ARB_instanced_arrays\n\nstatic GLboolean _glewInit_GL_ARB_instanced_arrays (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glVertexAttribDivisorARB = (PFNGLVERTEXATTRIBDIVISORARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribDivisorARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_instanced_arrays */\n\n#ifdef GL_ARB_map_buffer_range\n\nstatic GLboolean _glewInit_GL_ARB_map_buffer_range (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFlushMappedBufferRange = (PFNGLFLUSHMAPPEDBUFFERRANGEPROC)glewGetProcAddress((const GLubyte*)\"glFlushMappedBufferRange\")) == NULL) || r;\n  r = ((glMapBufferRange = (PFNGLMAPBUFFERRANGEPROC)glewGetProcAddress((const GLubyte*)\"glMapBufferRange\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_map_buffer_range */\n\n#ifdef GL_ARB_matrix_palette\n\nstatic GLboolean _glewInit_GL_ARB_matrix_palette (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glCurrentPaletteMatrixARB = (PFNGLCURRENTPALETTEMATRIXARBPROC)glewGetProcAddress((const GLubyte*)\"glCurrentPaletteMatrixARB\")) == NULL) || r;\n  r = ((glMatrixIndexPointerARB = (PFNGLMATRIXINDEXPOINTERARBPROC)glewGetProcAddress((const GLubyte*)\"glMatrixIndexPointerARB\")) == NULL) || r;\n  r = ((glMatrixIndexubvARB = (PFNGLMATRIXINDEXUBVARBPROC)glewGetProcAddress((const GLubyte*)\"glMatrixIndexubvARB\")) == NULL) || r;\n  r = ((glMatrixIndexuivARB = (PFNGLMATRIXINDEXUIVARBPROC)glewGetProcAddress((const GLubyte*)\"glMatrixIndexuivARB\")) == NULL) || r;\n  r = ((glMatrixIndexusvARB = (PFNGLMATRIXINDEXUSVARBPROC)glewGetProcAddress((const GLubyte*)\"glMatrixIndexusvARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_matrix_palette */\n\n#ifdef GL_ARB_multisample\n\nstatic GLboolean _glewInit_GL_ARB_multisample (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glSampleCoverageARB = (PFNGLSAMPLECOVERAGEARBPROC)glewGetProcAddress((const GLubyte*)\"glSampleCoverageARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_multisample */\n\n#ifdef GL_ARB_multitexture\n\nstatic GLboolean _glewInit_GL_ARB_multitexture (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glActiveTextureARB = (PFNGLACTIVETEXTUREARBPROC)glewGetProcAddress((const GLubyte*)\"glActiveTextureARB\")) == NULL) || r;\n  r = ((glClientActiveTextureARB = (PFNGLCLIENTACTIVETEXTUREARBPROC)glewGetProcAddress((const GLubyte*)\"glClientActiveTextureARB\")) == NULL) || r;\n  r = ((glMultiTexCoord1dARB = (PFNGLMULTITEXCOORD1DARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1dARB\")) == NULL) || r;\n  r = ((glMultiTexCoord1dvARB = (PFNGLMULTITEXCOORD1DVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1dvARB\")) == NULL) || r;\n  r = ((glMultiTexCoord1fARB = (PFNGLMULTITEXCOORD1FARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1fARB\")) == NULL) || r;\n  r = ((glMultiTexCoord1fvARB = (PFNGLMULTITEXCOORD1FVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1fvARB\")) == NULL) || r;\n  r = ((glMultiTexCoord1iARB = (PFNGLMULTITEXCOORD1IARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1iARB\")) == NULL) || r;\n  r = ((glMultiTexCoord1ivARB = (PFNGLMULTITEXCOORD1IVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1ivARB\")) == NULL) || r;\n  r = ((glMultiTexCoord1sARB = (PFNGLMULTITEXCOORD1SARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1sARB\")) == NULL) || r;\n  r = ((glMultiTexCoord1svARB = (PFNGLMULTITEXCOORD1SVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1svARB\")) == NULL) || r;\n  r = ((glMultiTexCoord2dARB = (PFNGLMULTITEXCOORD2DARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2dARB\")) == NULL) || r;\n  r = ((glMultiTexCoord2dvARB = (PFNGLMULTITEXCOORD2DVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2dvARB\")) == NULL) || r;\n  r = ((glMultiTexCoord2fARB = (PFNGLMULTITEXCOORD2FARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2fARB\")) == NULL) || r;\n  r = ((glMultiTexCoord2fvARB = (PFNGLMULTITEXCOORD2FVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2fvARB\")) == NULL) || r;\n  r = ((glMultiTexCoord2iARB = (PFNGLMULTITEXCOORD2IARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2iARB\")) == NULL) || r;\n  r = ((glMultiTexCoord2ivARB = (PFNGLMULTITEXCOORD2IVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2ivARB\")) == NULL) || r;\n  r = ((glMultiTexCoord2sARB = (PFNGLMULTITEXCOORD2SARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2sARB\")) == NULL) || r;\n  r = ((glMultiTexCoord2svARB = (PFNGLMULTITEXCOORD2SVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2svARB\")) == NULL) || r;\n  r = ((glMultiTexCoord3dARB = (PFNGLMULTITEXCOORD3DARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3dARB\")) == NULL) || r;\n  r = ((glMultiTexCoord3dvARB = (PFNGLMULTITEXCOORD3DVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3dvARB\")) == NULL) || r;\n  r = ((glMultiTexCoord3fARB = (PFNGLMULTITEXCOORD3FARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3fARB\")) == NULL) || r;\n  r = ((glMultiTexCoord3fvARB = (PFNGLMULTITEXCOORD3FVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3fvARB\")) == NULL) || r;\n  r = ((glMultiTexCoord3iARB = (PFNGLMULTITEXCOORD3IARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3iARB\")) == NULL) || r;\n  r = ((glMultiTexCoord3ivARB = (PFNGLMULTITEXCOORD3IVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3ivARB\")) == NULL) || r;\n  r = ((glMultiTexCoord3sARB = (PFNGLMULTITEXCOORD3SARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3sARB\")) == NULL) || r;\n  r = ((glMultiTexCoord3svARB = (PFNGLMULTITEXCOORD3SVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3svARB\")) == NULL) || r;\n  r = ((glMultiTexCoord4dARB = (PFNGLMULTITEXCOORD4DARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4dARB\")) == NULL) || r;\n  r = ((glMultiTexCoord4dvARB = (PFNGLMULTITEXCOORD4DVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4dvARB\")) == NULL) || r;\n  r = ((glMultiTexCoord4fARB = (PFNGLMULTITEXCOORD4FARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4fARB\")) == NULL) || r;\n  r = ((glMultiTexCoord4fvARB = (PFNGLMULTITEXCOORD4FVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4fvARB\")) == NULL) || r;\n  r = ((glMultiTexCoord4iARB = (PFNGLMULTITEXCOORD4IARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4iARB\")) == NULL) || r;\n  r = ((glMultiTexCoord4ivARB = (PFNGLMULTITEXCOORD4IVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4ivARB\")) == NULL) || r;\n  r = ((glMultiTexCoord4sARB = (PFNGLMULTITEXCOORD4SARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4sARB\")) == NULL) || r;\n  r = ((glMultiTexCoord4svARB = (PFNGLMULTITEXCOORD4SVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4svARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_multitexture */\n\n#ifdef GL_ARB_occlusion_query\n\nstatic GLboolean _glewInit_GL_ARB_occlusion_query (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBeginQueryARB = (PFNGLBEGINQUERYARBPROC)glewGetProcAddress((const GLubyte*)\"glBeginQueryARB\")) == NULL) || r;\n  r = ((glDeleteQueriesARB = (PFNGLDELETEQUERIESARBPROC)glewGetProcAddress((const GLubyte*)\"glDeleteQueriesARB\")) == NULL) || r;\n  r = ((glEndQueryARB = (PFNGLENDQUERYARBPROC)glewGetProcAddress((const GLubyte*)\"glEndQueryARB\")) == NULL) || r;\n  r = ((glGenQueriesARB = (PFNGLGENQUERIESARBPROC)glewGetProcAddress((const GLubyte*)\"glGenQueriesARB\")) == NULL) || r;\n  r = ((glGetQueryObjectivARB = (PFNGLGETQUERYOBJECTIVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetQueryObjectivARB\")) == NULL) || r;\n  r = ((glGetQueryObjectuivARB = (PFNGLGETQUERYOBJECTUIVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetQueryObjectuivARB\")) == NULL) || r;\n  r = ((glGetQueryivARB = (PFNGLGETQUERYIVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetQueryivARB\")) == NULL) || r;\n  r = ((glIsQueryARB = (PFNGLISQUERYARBPROC)glewGetProcAddress((const GLubyte*)\"glIsQueryARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_occlusion_query */\n\n#ifdef GL_ARB_pixel_buffer_object\n\n#endif /* GL_ARB_pixel_buffer_object */\n\n#ifdef GL_ARB_point_parameters\n\nstatic GLboolean _glewInit_GL_ARB_point_parameters (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glPointParameterfARB = (PFNGLPOINTPARAMETERFARBPROC)glewGetProcAddress((const GLubyte*)\"glPointParameterfARB\")) == NULL) || r;\n  r = ((glPointParameterfvARB = (PFNGLPOINTPARAMETERFVARBPROC)glewGetProcAddress((const GLubyte*)\"glPointParameterfvARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_point_parameters */\n\n#ifdef GL_ARB_point_sprite\n\n#endif /* GL_ARB_point_sprite */\n\n#ifdef GL_ARB_shader_objects\n\nstatic GLboolean _glewInit_GL_ARB_shader_objects (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glAttachObjectARB = (PFNGLATTACHOBJECTARBPROC)glewGetProcAddress((const GLubyte*)\"glAttachObjectARB\")) == NULL) || r;\n  r = ((glCompileShaderARB = (PFNGLCOMPILESHADERARBPROC)glewGetProcAddress((const GLubyte*)\"glCompileShaderARB\")) == NULL) || r;\n  r = ((glCreateProgramObjectARB = (PFNGLCREATEPROGRAMOBJECTARBPROC)glewGetProcAddress((const GLubyte*)\"glCreateProgramObjectARB\")) == NULL) || r;\n  r = ((glCreateShaderObjectARB = (PFNGLCREATESHADEROBJECTARBPROC)glewGetProcAddress((const GLubyte*)\"glCreateShaderObjectARB\")) == NULL) || r;\n  r = ((glDeleteObjectARB = (PFNGLDELETEOBJECTARBPROC)glewGetProcAddress((const GLubyte*)\"glDeleteObjectARB\")) == NULL) || r;\n  r = ((glDetachObjectARB = (PFNGLDETACHOBJECTARBPROC)glewGetProcAddress((const GLubyte*)\"glDetachObjectARB\")) == NULL) || r;\n  r = ((glGetActiveUniformARB = (PFNGLGETACTIVEUNIFORMARBPROC)glewGetProcAddress((const GLubyte*)\"glGetActiveUniformARB\")) == NULL) || r;\n  r = ((glGetAttachedObjectsARB = (PFNGLGETATTACHEDOBJECTSARBPROC)glewGetProcAddress((const GLubyte*)\"glGetAttachedObjectsARB\")) == NULL) || r;\n  r = ((glGetHandleARB = (PFNGLGETHANDLEARBPROC)glewGetProcAddress((const GLubyte*)\"glGetHandleARB\")) == NULL) || r;\n  r = ((glGetInfoLogARB = (PFNGLGETINFOLOGARBPROC)glewGetProcAddress((const GLubyte*)\"glGetInfoLogARB\")) == NULL) || r;\n  r = ((glGetObjectParameterfvARB = (PFNGLGETOBJECTPARAMETERFVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetObjectParameterfvARB\")) == NULL) || r;\n  r = ((glGetObjectParameterivARB = (PFNGLGETOBJECTPARAMETERIVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetObjectParameterivARB\")) == NULL) || r;\n  r = ((glGetShaderSourceARB = (PFNGLGETSHADERSOURCEARBPROC)glewGetProcAddress((const GLubyte*)\"glGetShaderSourceARB\")) == NULL) || r;\n  r = ((glGetUniformLocationARB = (PFNGLGETUNIFORMLOCATIONARBPROC)glewGetProcAddress((const GLubyte*)\"glGetUniformLocationARB\")) == NULL) || r;\n  r = ((glGetUniformfvARB = (PFNGLGETUNIFORMFVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetUniformfvARB\")) == NULL) || r;\n  r = ((glGetUniformivARB = (PFNGLGETUNIFORMIVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetUniformivARB\")) == NULL) || r;\n  r = ((glLinkProgramARB = (PFNGLLINKPROGRAMARBPROC)glewGetProcAddress((const GLubyte*)\"glLinkProgramARB\")) == NULL) || r;\n  r = ((glShaderSourceARB = (PFNGLSHADERSOURCEARBPROC)glewGetProcAddress((const GLubyte*)\"glShaderSourceARB\")) == NULL) || r;\n  r = ((glUniform1fARB = (PFNGLUNIFORM1FARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform1fARB\")) == NULL) || r;\n  r = ((glUniform1fvARB = (PFNGLUNIFORM1FVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform1fvARB\")) == NULL) || r;\n  r = ((glUniform1iARB = (PFNGLUNIFORM1IARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform1iARB\")) == NULL) || r;\n  r = ((glUniform1ivARB = (PFNGLUNIFORM1IVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform1ivARB\")) == NULL) || r;\n  r = ((glUniform2fARB = (PFNGLUNIFORM2FARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform2fARB\")) == NULL) || r;\n  r = ((glUniform2fvARB = (PFNGLUNIFORM2FVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform2fvARB\")) == NULL) || r;\n  r = ((glUniform2iARB = (PFNGLUNIFORM2IARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform2iARB\")) == NULL) || r;\n  r = ((glUniform2ivARB = (PFNGLUNIFORM2IVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform2ivARB\")) == NULL) || r;\n  r = ((glUniform3fARB = (PFNGLUNIFORM3FARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform3fARB\")) == NULL) || r;\n  r = ((glUniform3fvARB = (PFNGLUNIFORM3FVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform3fvARB\")) == NULL) || r;\n  r = ((glUniform3iARB = (PFNGLUNIFORM3IARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform3iARB\")) == NULL) || r;\n  r = ((glUniform3ivARB = (PFNGLUNIFORM3IVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform3ivARB\")) == NULL) || r;\n  r = ((glUniform4fARB = (PFNGLUNIFORM4FARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform4fARB\")) == NULL) || r;\n  r = ((glUniform4fvARB = (PFNGLUNIFORM4FVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform4fvARB\")) == NULL) || r;\n  r = ((glUniform4iARB = (PFNGLUNIFORM4IARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform4iARB\")) == NULL) || r;\n  r = ((glUniform4ivARB = (PFNGLUNIFORM4IVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform4ivARB\")) == NULL) || r;\n  r = ((glUniformMatrix2fvARB = (PFNGLUNIFORMMATRIX2FVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix2fvARB\")) == NULL) || r;\n  r = ((glUniformMatrix3fvARB = (PFNGLUNIFORMMATRIX3FVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix3fvARB\")) == NULL) || r;\n  r = ((glUniformMatrix4fvARB = (PFNGLUNIFORMMATRIX4FVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix4fvARB\")) == NULL) || r;\n  r = ((glUseProgramObjectARB = (PFNGLUSEPROGRAMOBJECTARBPROC)glewGetProcAddress((const GLubyte*)\"glUseProgramObjectARB\")) == NULL) || r;\n  r = ((glValidateProgramARB = (PFNGLVALIDATEPROGRAMARBPROC)glewGetProcAddress((const GLubyte*)\"glValidateProgramARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_shader_objects */\n\n#ifdef GL_ARB_shading_language_100\n\n#endif /* GL_ARB_shading_language_100 */\n\n#ifdef GL_ARB_shadow\n\n#endif /* GL_ARB_shadow */\n\n#ifdef GL_ARB_shadow_ambient\n\n#endif /* GL_ARB_shadow_ambient */\n\n#ifdef GL_ARB_texture_border_clamp\n\n#endif /* GL_ARB_texture_border_clamp */\n\n#ifdef GL_ARB_texture_buffer_object\n\nstatic GLboolean _glewInit_GL_ARB_texture_buffer_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glTexBufferARB = (PFNGLTEXBUFFERARBPROC)glewGetProcAddress((const GLubyte*)\"glTexBufferARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_texture_buffer_object */\n\n#ifdef GL_ARB_texture_compression\n\nstatic GLboolean _glewInit_GL_ARB_texture_compression (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glCompressedTexImage1DARB = (PFNGLCOMPRESSEDTEXIMAGE1DARBPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexImage1DARB\")) == NULL) || r;\n  r = ((glCompressedTexImage2DARB = (PFNGLCOMPRESSEDTEXIMAGE2DARBPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexImage2DARB\")) == NULL) || r;\n  r = ((glCompressedTexImage3DARB = (PFNGLCOMPRESSEDTEXIMAGE3DARBPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexImage3DARB\")) == NULL) || r;\n  r = ((glCompressedTexSubImage1DARB = (PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexSubImage1DARB\")) == NULL) || r;\n  r = ((glCompressedTexSubImage2DARB = (PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexSubImage2DARB\")) == NULL) || r;\n  r = ((glCompressedTexSubImage3DARB = (PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexSubImage3DARB\")) == NULL) || r;\n  r = ((glGetCompressedTexImageARB = (PFNGLGETCOMPRESSEDTEXIMAGEARBPROC)glewGetProcAddress((const GLubyte*)\"glGetCompressedTexImageARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_texture_compression */\n\n#ifdef GL_ARB_texture_compression_rgtc\n\n#endif /* GL_ARB_texture_compression_rgtc */\n\n#ifdef GL_ARB_texture_cube_map\n\n#endif /* GL_ARB_texture_cube_map */\n\n#ifdef GL_ARB_texture_env_add\n\n#endif /* GL_ARB_texture_env_add */\n\n#ifdef GL_ARB_texture_env_combine\n\n#endif /* GL_ARB_texture_env_combine */\n\n#ifdef GL_ARB_texture_env_crossbar\n\n#endif /* GL_ARB_texture_env_crossbar */\n\n#ifdef GL_ARB_texture_env_dot3\n\n#endif /* GL_ARB_texture_env_dot3 */\n\n#ifdef GL_ARB_texture_float\n\n#endif /* GL_ARB_texture_float */\n\n#ifdef GL_ARB_texture_mirrored_repeat\n\n#endif /* GL_ARB_texture_mirrored_repeat */\n\n#ifdef GL_ARB_texture_non_power_of_two\n\n#endif /* GL_ARB_texture_non_power_of_two */\n\n#ifdef GL_ARB_texture_rectangle\n\n#endif /* GL_ARB_texture_rectangle */\n\n#ifdef GL_ARB_texture_rg\n\n#endif /* GL_ARB_texture_rg */\n\n#ifdef GL_ARB_transpose_matrix\n\nstatic GLboolean _glewInit_GL_ARB_transpose_matrix (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glLoadTransposeMatrixdARB = (PFNGLLOADTRANSPOSEMATRIXDARBPROC)glewGetProcAddress((const GLubyte*)\"glLoadTransposeMatrixdARB\")) == NULL) || r;\n  r = ((glLoadTransposeMatrixfARB = (PFNGLLOADTRANSPOSEMATRIXFARBPROC)glewGetProcAddress((const GLubyte*)\"glLoadTransposeMatrixfARB\")) == NULL) || r;\n  r = ((glMultTransposeMatrixdARB = (PFNGLMULTTRANSPOSEMATRIXDARBPROC)glewGetProcAddress((const GLubyte*)\"glMultTransposeMatrixdARB\")) == NULL) || r;\n  r = ((glMultTransposeMatrixfARB = (PFNGLMULTTRANSPOSEMATRIXFARBPROC)glewGetProcAddress((const GLubyte*)\"glMultTransposeMatrixfARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_transpose_matrix */\n\n#ifdef GL_ARB_vertex_array_object\n\nstatic GLboolean _glewInit_GL_ARB_vertex_array_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC)glewGetProcAddress((const GLubyte*)\"glBindVertexArray\")) == NULL) || r;\n  r = ((glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC)glewGetProcAddress((const GLubyte*)\"glDeleteVertexArrays\")) == NULL) || r;\n  r = ((glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC)glewGetProcAddress((const GLubyte*)\"glGenVertexArrays\")) == NULL) || r;\n  r = ((glIsVertexArray = (PFNGLISVERTEXARRAYPROC)glewGetProcAddress((const GLubyte*)\"glIsVertexArray\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_vertex_array_object */\n\n#ifdef GL_ARB_vertex_blend\n\nstatic GLboolean _glewInit_GL_ARB_vertex_blend (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glVertexBlendARB = (PFNGLVERTEXBLENDARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexBlendARB\")) == NULL) || r;\n  r = ((glWeightPointerARB = (PFNGLWEIGHTPOINTERARBPROC)glewGetProcAddress((const GLubyte*)\"glWeightPointerARB\")) == NULL) || r;\n  r = ((glWeightbvARB = (PFNGLWEIGHTBVARBPROC)glewGetProcAddress((const GLubyte*)\"glWeightbvARB\")) == NULL) || r;\n  r = ((glWeightdvARB = (PFNGLWEIGHTDVARBPROC)glewGetProcAddress((const GLubyte*)\"glWeightdvARB\")) == NULL) || r;\n  r = ((glWeightfvARB = (PFNGLWEIGHTFVARBPROC)glewGetProcAddress((const GLubyte*)\"glWeightfvARB\")) == NULL) || r;\n  r = ((glWeightivARB = (PFNGLWEIGHTIVARBPROC)glewGetProcAddress((const GLubyte*)\"glWeightivARB\")) == NULL) || r;\n  r = ((glWeightsvARB = (PFNGLWEIGHTSVARBPROC)glewGetProcAddress((const GLubyte*)\"glWeightsvARB\")) == NULL) || r;\n  r = ((glWeightubvARB = (PFNGLWEIGHTUBVARBPROC)glewGetProcAddress((const GLubyte*)\"glWeightubvARB\")) == NULL) || r;\n  r = ((glWeightuivARB = (PFNGLWEIGHTUIVARBPROC)glewGetProcAddress((const GLubyte*)\"glWeightuivARB\")) == NULL) || r;\n  r = ((glWeightusvARB = (PFNGLWEIGHTUSVARBPROC)glewGetProcAddress((const GLubyte*)\"glWeightusvARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_vertex_blend */\n\n#ifdef GL_ARB_vertex_buffer_object\n\nstatic GLboolean _glewInit_GL_ARB_vertex_buffer_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBindBufferARB = (PFNGLBINDBUFFERARBPROC)glewGetProcAddress((const GLubyte*)\"glBindBufferARB\")) == NULL) || r;\n  r = ((glBufferDataARB = (PFNGLBUFFERDATAARBPROC)glewGetProcAddress((const GLubyte*)\"glBufferDataARB\")) == NULL) || r;\n  r = ((glBufferSubDataARB = (PFNGLBUFFERSUBDATAARBPROC)glewGetProcAddress((const GLubyte*)\"glBufferSubDataARB\")) == NULL) || r;\n  r = ((glDeleteBuffersARB = (PFNGLDELETEBUFFERSARBPROC)glewGetProcAddress((const GLubyte*)\"glDeleteBuffersARB\")) == NULL) || r;\n  r = ((glGenBuffersARB = (PFNGLGENBUFFERSARBPROC)glewGetProcAddress((const GLubyte*)\"glGenBuffersARB\")) == NULL) || r;\n  r = ((glGetBufferParameterivARB = (PFNGLGETBUFFERPARAMETERIVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetBufferParameterivARB\")) == NULL) || r;\n  r = ((glGetBufferPointervARB = (PFNGLGETBUFFERPOINTERVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetBufferPointervARB\")) == NULL) || r;\n  r = ((glGetBufferSubDataARB = (PFNGLGETBUFFERSUBDATAARBPROC)glewGetProcAddress((const GLubyte*)\"glGetBufferSubDataARB\")) == NULL) || r;\n  r = ((glIsBufferARB = (PFNGLISBUFFERARBPROC)glewGetProcAddress((const GLubyte*)\"glIsBufferARB\")) == NULL) || r;\n  r = ((glMapBufferARB = (PFNGLMAPBUFFERARBPROC)glewGetProcAddress((const GLubyte*)\"glMapBufferARB\")) == NULL) || r;\n  r = ((glUnmapBufferARB = (PFNGLUNMAPBUFFERARBPROC)glewGetProcAddress((const GLubyte*)\"glUnmapBufferARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_vertex_buffer_object */\n\n#ifdef GL_ARB_vertex_program\n\nstatic GLboolean _glewInit_GL_ARB_vertex_program (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBindProgramARB = (PFNGLBINDPROGRAMARBPROC)glewGetProcAddress((const GLubyte*)\"glBindProgramARB\")) == NULL) || r;\n  r = ((glDeleteProgramsARB = (PFNGLDELETEPROGRAMSARBPROC)glewGetProcAddress((const GLubyte*)\"glDeleteProgramsARB\")) == NULL) || r;\n  r = ((glDisableVertexAttribArrayARB = (PFNGLDISABLEVERTEXATTRIBARRAYARBPROC)glewGetProcAddress((const GLubyte*)\"glDisableVertexAttribArrayARB\")) == NULL) || r;\n  r = ((glEnableVertexAttribArrayARB = (PFNGLENABLEVERTEXATTRIBARRAYARBPROC)glewGetProcAddress((const GLubyte*)\"glEnableVertexAttribArrayARB\")) == NULL) || r;\n  r = ((glGenProgramsARB = (PFNGLGENPROGRAMSARBPROC)glewGetProcAddress((const GLubyte*)\"glGenProgramsARB\")) == NULL) || r;\n  r = ((glGetProgramEnvParameterdvARB = (PFNGLGETPROGRAMENVPARAMETERDVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramEnvParameterdvARB\")) == NULL) || r;\n  r = ((glGetProgramEnvParameterfvARB = (PFNGLGETPROGRAMENVPARAMETERFVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramEnvParameterfvARB\")) == NULL) || r;\n  r = ((glGetProgramLocalParameterdvARB = (PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramLocalParameterdvARB\")) == NULL) || r;\n  r = ((glGetProgramLocalParameterfvARB = (PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramLocalParameterfvARB\")) == NULL) || r;\n  r = ((glGetProgramStringARB = (PFNGLGETPROGRAMSTRINGARBPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramStringARB\")) == NULL) || r;\n  r = ((glGetProgramivARB = (PFNGLGETPROGRAMIVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramivARB\")) == NULL) || r;\n  r = ((glGetVertexAttribPointervARB = (PFNGLGETVERTEXATTRIBPOINTERVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribPointervARB\")) == NULL) || r;\n  r = ((glGetVertexAttribdvARB = (PFNGLGETVERTEXATTRIBDVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribdvARB\")) == NULL) || r;\n  r = ((glGetVertexAttribfvARB = (PFNGLGETVERTEXATTRIBFVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribfvARB\")) == NULL) || r;\n  r = ((glGetVertexAttribivARB = (PFNGLGETVERTEXATTRIBIVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribivARB\")) == NULL) || r;\n  r = ((glIsProgramARB = (PFNGLISPROGRAMARBPROC)glewGetProcAddress((const GLubyte*)\"glIsProgramARB\")) == NULL) || r;\n  r = ((glProgramEnvParameter4dARB = (PFNGLPROGRAMENVPARAMETER4DARBPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParameter4dARB\")) == NULL) || r;\n  r = ((glProgramEnvParameter4dvARB = (PFNGLPROGRAMENVPARAMETER4DVARBPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParameter4dvARB\")) == NULL) || r;\n  r = ((glProgramEnvParameter4fARB = (PFNGLPROGRAMENVPARAMETER4FARBPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParameter4fARB\")) == NULL) || r;\n  r = ((glProgramEnvParameter4fvARB = (PFNGLPROGRAMENVPARAMETER4FVARBPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParameter4fvARB\")) == NULL) || r;\n  r = ((glProgramLocalParameter4dARB = (PFNGLPROGRAMLOCALPARAMETER4DARBPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParameter4dARB\")) == NULL) || r;\n  r = ((glProgramLocalParameter4dvARB = (PFNGLPROGRAMLOCALPARAMETER4DVARBPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParameter4dvARB\")) == NULL) || r;\n  r = ((glProgramLocalParameter4fARB = (PFNGLPROGRAMLOCALPARAMETER4FARBPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParameter4fARB\")) == NULL) || r;\n  r = ((glProgramLocalParameter4fvARB = (PFNGLPROGRAMLOCALPARAMETER4FVARBPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParameter4fvARB\")) == NULL) || r;\n  r = ((glProgramStringARB = (PFNGLPROGRAMSTRINGARBPROC)glewGetProcAddress((const GLubyte*)\"glProgramStringARB\")) == NULL) || r;\n  r = ((glVertexAttrib1dARB = (PFNGLVERTEXATTRIB1DARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1dARB\")) == NULL) || r;\n  r = ((glVertexAttrib1dvARB = (PFNGLVERTEXATTRIB1DVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1dvARB\")) == NULL) || r;\n  r = ((glVertexAttrib1fARB = (PFNGLVERTEXATTRIB1FARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1fARB\")) == NULL) || r;\n  r = ((glVertexAttrib1fvARB = (PFNGLVERTEXATTRIB1FVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1fvARB\")) == NULL) || r;\n  r = ((glVertexAttrib1sARB = (PFNGLVERTEXATTRIB1SARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1sARB\")) == NULL) || r;\n  r = ((glVertexAttrib1svARB = (PFNGLVERTEXATTRIB1SVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1svARB\")) == NULL) || r;\n  r = ((glVertexAttrib2dARB = (PFNGLVERTEXATTRIB2DARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2dARB\")) == NULL) || r;\n  r = ((glVertexAttrib2dvARB = (PFNGLVERTEXATTRIB2DVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2dvARB\")) == NULL) || r;\n  r = ((glVertexAttrib2fARB = (PFNGLVERTEXATTRIB2FARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2fARB\")) == NULL) || r;\n  r = ((glVertexAttrib2fvARB = (PFNGLVERTEXATTRIB2FVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2fvARB\")) == NULL) || r;\n  r = ((glVertexAttrib2sARB = (PFNGLVERTEXATTRIB2SARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2sARB\")) == NULL) || r;\n  r = ((glVertexAttrib2svARB = (PFNGLVERTEXATTRIB2SVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2svARB\")) == NULL) || r;\n  r = ((glVertexAttrib3dARB = (PFNGLVERTEXATTRIB3DARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3dARB\")) == NULL) || r;\n  r = ((glVertexAttrib3dvARB = (PFNGLVERTEXATTRIB3DVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3dvARB\")) == NULL) || r;\n  r = ((glVertexAttrib3fARB = (PFNGLVERTEXATTRIB3FARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3fARB\")) == NULL) || r;\n  r = ((glVertexAttrib3fvARB = (PFNGLVERTEXATTRIB3FVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3fvARB\")) == NULL) || r;\n  r = ((glVertexAttrib3sARB = (PFNGLVERTEXATTRIB3SARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3sARB\")) == NULL) || r;\n  r = ((glVertexAttrib3svARB = (PFNGLVERTEXATTRIB3SVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3svARB\")) == NULL) || r;\n  r = ((glVertexAttrib4NbvARB = (PFNGLVERTEXATTRIB4NBVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4NbvARB\")) == NULL) || r;\n  r = ((glVertexAttrib4NivARB = (PFNGLVERTEXATTRIB4NIVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4NivARB\")) == NULL) || r;\n  r = ((glVertexAttrib4NsvARB = (PFNGLVERTEXATTRIB4NSVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4NsvARB\")) == NULL) || r;\n  r = ((glVertexAttrib4NubARB = (PFNGLVERTEXATTRIB4NUBARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4NubARB\")) == NULL) || r;\n  r = ((glVertexAttrib4NubvARB = (PFNGLVERTEXATTRIB4NUBVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4NubvARB\")) == NULL) || r;\n  r = ((glVertexAttrib4NuivARB = (PFNGLVERTEXATTRIB4NUIVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4NuivARB\")) == NULL) || r;\n  r = ((glVertexAttrib4NusvARB = (PFNGLVERTEXATTRIB4NUSVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4NusvARB\")) == NULL) || r;\n  r = ((glVertexAttrib4bvARB = (PFNGLVERTEXATTRIB4BVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4bvARB\")) == NULL) || r;\n  r = ((glVertexAttrib4dARB = (PFNGLVERTEXATTRIB4DARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4dARB\")) == NULL) || r;\n  r = ((glVertexAttrib4dvARB = (PFNGLVERTEXATTRIB4DVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4dvARB\")) == NULL) || r;\n  r = ((glVertexAttrib4fARB = (PFNGLVERTEXATTRIB4FARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4fARB\")) == NULL) || r;\n  r = ((glVertexAttrib4fvARB = (PFNGLVERTEXATTRIB4FVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4fvARB\")) == NULL) || r;\n  r = ((glVertexAttrib4ivARB = (PFNGLVERTEXATTRIB4IVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4ivARB\")) == NULL) || r;\n  r = ((glVertexAttrib4sARB = (PFNGLVERTEXATTRIB4SARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4sARB\")) == NULL) || r;\n  r = ((glVertexAttrib4svARB = (PFNGLVERTEXATTRIB4SVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4svARB\")) == NULL) || r;\n  r = ((glVertexAttrib4ubvARB = (PFNGLVERTEXATTRIB4UBVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4ubvARB\")) == NULL) || r;\n  r = ((glVertexAttrib4uivARB = (PFNGLVERTEXATTRIB4UIVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4uivARB\")) == NULL) || r;\n  r = ((glVertexAttrib4usvARB = (PFNGLVERTEXATTRIB4USVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4usvARB\")) == NULL) || r;\n  r = ((glVertexAttribPointerARB = (PFNGLVERTEXATTRIBPOINTERARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribPointerARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_vertex_program */\n\n#ifdef GL_ARB_vertex_shader\n\nstatic GLboolean _glewInit_GL_ARB_vertex_shader (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBindAttribLocationARB = (PFNGLBINDATTRIBLOCATIONARBPROC)glewGetProcAddress((const GLubyte*)\"glBindAttribLocationARB\")) == NULL) || r;\n  r = ((glGetActiveAttribARB = (PFNGLGETACTIVEATTRIBARBPROC)glewGetProcAddress((const GLubyte*)\"glGetActiveAttribARB\")) == NULL) || r;\n  r = ((glGetAttribLocationARB = (PFNGLGETATTRIBLOCATIONARBPROC)glewGetProcAddress((const GLubyte*)\"glGetAttribLocationARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_vertex_shader */\n\n#ifdef GL_ARB_window_pos\n\nstatic GLboolean _glewInit_GL_ARB_window_pos (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glWindowPos2dARB = (PFNGLWINDOWPOS2DARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2dARB\")) == NULL) || r;\n  r = ((glWindowPos2dvARB = (PFNGLWINDOWPOS2DVARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2dvARB\")) == NULL) || r;\n  r = ((glWindowPos2fARB = (PFNGLWINDOWPOS2FARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2fARB\")) == NULL) || r;\n  r = ((glWindowPos2fvARB = (PFNGLWINDOWPOS2FVARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2fvARB\")) == NULL) || r;\n  r = ((glWindowPos2iARB = (PFNGLWINDOWPOS2IARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2iARB\")) == NULL) || r;\n  r = ((glWindowPos2ivARB = (PFNGLWINDOWPOS2IVARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2ivARB\")) == NULL) || r;\n  r = ((glWindowPos2sARB = (PFNGLWINDOWPOS2SARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2sARB\")) == NULL) || r;\n  r = ((glWindowPos2svARB = (PFNGLWINDOWPOS2SVARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2svARB\")) == NULL) || r;\n  r = ((glWindowPos3dARB = (PFNGLWINDOWPOS3DARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3dARB\")) == NULL) || r;\n  r = ((glWindowPos3dvARB = (PFNGLWINDOWPOS3DVARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3dvARB\")) == NULL) || r;\n  r = ((glWindowPos3fARB = (PFNGLWINDOWPOS3FARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3fARB\")) == NULL) || r;\n  r = ((glWindowPos3fvARB = (PFNGLWINDOWPOS3FVARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3fvARB\")) == NULL) || r;\n  r = ((glWindowPos3iARB = (PFNGLWINDOWPOS3IARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3iARB\")) == NULL) || r;\n  r = ((glWindowPos3ivARB = (PFNGLWINDOWPOS3IVARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3ivARB\")) == NULL) || r;\n  r = ((glWindowPos3sARB = (PFNGLWINDOWPOS3SARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3sARB\")) == NULL) || r;\n  r = ((glWindowPos3svARB = (PFNGLWINDOWPOS3SVARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3svARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_window_pos */\n\n#ifdef GL_ATIX_point_sprites\n\n#endif /* GL_ATIX_point_sprites */\n\n#ifdef GL_ATIX_texture_env_combine3\n\n#endif /* GL_ATIX_texture_env_combine3 */\n\n#ifdef GL_ATIX_texture_env_route\n\n#endif /* GL_ATIX_texture_env_route */\n\n#ifdef GL_ATIX_vertex_shader_output_point_size\n\n#endif /* GL_ATIX_vertex_shader_output_point_size */\n\n#ifdef GL_ATI_draw_buffers\n\nstatic GLboolean _glewInit_GL_ATI_draw_buffers (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDrawBuffersATI = (PFNGLDRAWBUFFERSATIPROC)glewGetProcAddress((const GLubyte*)\"glDrawBuffersATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ATI_draw_buffers */\n\n#ifdef GL_ATI_element_array\n\nstatic GLboolean _glewInit_GL_ATI_element_array (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDrawElementArrayATI = (PFNGLDRAWELEMENTARRAYATIPROC)glewGetProcAddress((const GLubyte*)\"glDrawElementArrayATI\")) == NULL) || r;\n  r = ((glDrawRangeElementArrayATI = (PFNGLDRAWRANGEELEMENTARRAYATIPROC)glewGetProcAddress((const GLubyte*)\"glDrawRangeElementArrayATI\")) == NULL) || r;\n  r = ((glElementPointerATI = (PFNGLELEMENTPOINTERATIPROC)glewGetProcAddress((const GLubyte*)\"glElementPointerATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ATI_element_array */\n\n#ifdef GL_ATI_envmap_bumpmap\n\nstatic GLboolean _glewInit_GL_ATI_envmap_bumpmap (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetTexBumpParameterfvATI = (PFNGLGETTEXBUMPPARAMETERFVATIPROC)glewGetProcAddress((const GLubyte*)\"glGetTexBumpParameterfvATI\")) == NULL) || r;\n  r = ((glGetTexBumpParameterivATI = (PFNGLGETTEXBUMPPARAMETERIVATIPROC)glewGetProcAddress((const GLubyte*)\"glGetTexBumpParameterivATI\")) == NULL) || r;\n  r = ((glTexBumpParameterfvATI = (PFNGLTEXBUMPPARAMETERFVATIPROC)glewGetProcAddress((const GLubyte*)\"glTexBumpParameterfvATI\")) == NULL) || r;\n  r = ((glTexBumpParameterivATI = (PFNGLTEXBUMPPARAMETERIVATIPROC)glewGetProcAddress((const GLubyte*)\"glTexBumpParameterivATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ATI_envmap_bumpmap */\n\n#ifdef GL_ATI_fragment_shader\n\nstatic GLboolean _glewInit_GL_ATI_fragment_shader (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glAlphaFragmentOp1ATI = (PFNGLALPHAFRAGMENTOP1ATIPROC)glewGetProcAddress((const GLubyte*)\"glAlphaFragmentOp1ATI\")) == NULL) || r;\n  r = ((glAlphaFragmentOp2ATI = (PFNGLALPHAFRAGMENTOP2ATIPROC)glewGetProcAddress((const GLubyte*)\"glAlphaFragmentOp2ATI\")) == NULL) || r;\n  r = ((glAlphaFragmentOp3ATI = (PFNGLALPHAFRAGMENTOP3ATIPROC)glewGetProcAddress((const GLubyte*)\"glAlphaFragmentOp3ATI\")) == NULL) || r;\n  r = ((glBeginFragmentShaderATI = (PFNGLBEGINFRAGMENTSHADERATIPROC)glewGetProcAddress((const GLubyte*)\"glBeginFragmentShaderATI\")) == NULL) || r;\n  r = ((glBindFragmentShaderATI = (PFNGLBINDFRAGMENTSHADERATIPROC)glewGetProcAddress((const GLubyte*)\"glBindFragmentShaderATI\")) == NULL) || r;\n  r = ((glColorFragmentOp1ATI = (PFNGLCOLORFRAGMENTOP1ATIPROC)glewGetProcAddress((const GLubyte*)\"glColorFragmentOp1ATI\")) == NULL) || r;\n  r = ((glColorFragmentOp2ATI = (PFNGLCOLORFRAGMENTOP2ATIPROC)glewGetProcAddress((const GLubyte*)\"glColorFragmentOp2ATI\")) == NULL) || r;\n  r = ((glColorFragmentOp3ATI = (PFNGLCOLORFRAGMENTOP3ATIPROC)glewGetProcAddress((const GLubyte*)\"glColorFragmentOp3ATI\")) == NULL) || r;\n  r = ((glDeleteFragmentShaderATI = (PFNGLDELETEFRAGMENTSHADERATIPROC)glewGetProcAddress((const GLubyte*)\"glDeleteFragmentShaderATI\")) == NULL) || r;\n  r = ((glEndFragmentShaderATI = (PFNGLENDFRAGMENTSHADERATIPROC)glewGetProcAddress((const GLubyte*)\"glEndFragmentShaderATI\")) == NULL) || r;\n  r = ((glGenFragmentShadersATI = (PFNGLGENFRAGMENTSHADERSATIPROC)glewGetProcAddress((const GLubyte*)\"glGenFragmentShadersATI\")) == NULL) || r;\n  r = ((glPassTexCoordATI = (PFNGLPASSTEXCOORDATIPROC)glewGetProcAddress((const GLubyte*)\"glPassTexCoordATI\")) == NULL) || r;\n  r = ((glSampleMapATI = (PFNGLSAMPLEMAPATIPROC)glewGetProcAddress((const GLubyte*)\"glSampleMapATI\")) == NULL) || r;\n  r = ((glSetFragmentShaderConstantATI = (PFNGLSETFRAGMENTSHADERCONSTANTATIPROC)glewGetProcAddress((const GLubyte*)\"glSetFragmentShaderConstantATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ATI_fragment_shader */\n\n#ifdef GL_ATI_map_object_buffer\n\nstatic GLboolean _glewInit_GL_ATI_map_object_buffer (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glMapObjectBufferATI = (PFNGLMAPOBJECTBUFFERATIPROC)glewGetProcAddress((const GLubyte*)\"glMapObjectBufferATI\")) == NULL) || r;\n  r = ((glUnmapObjectBufferATI = (PFNGLUNMAPOBJECTBUFFERATIPROC)glewGetProcAddress((const GLubyte*)\"glUnmapObjectBufferATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ATI_map_object_buffer */\n\n#ifdef GL_ATI_pn_triangles\n\nstatic GLboolean _glewInit_GL_ATI_pn_triangles (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glPNTrianglesfATI = (PFNGLPNTRIANGLESFATIPROC)glewGetProcAddress((const GLubyte*)\"glPNTrianglesfATI\")) == NULL) || r;\n  r = ((glPNTrianglesiATI = (PFNGLPNTRIANGLESIATIPROC)glewGetProcAddress((const GLubyte*)\"glPNTrianglesiATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ATI_pn_triangles */\n\n#ifdef GL_ATI_separate_stencil\n\nstatic GLboolean _glewInit_GL_ATI_separate_stencil (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glStencilFuncSeparateATI = (PFNGLSTENCILFUNCSEPARATEATIPROC)glewGetProcAddress((const GLubyte*)\"glStencilFuncSeparateATI\")) == NULL) || r;\n  r = ((glStencilOpSeparateATI = (PFNGLSTENCILOPSEPARATEATIPROC)glewGetProcAddress((const GLubyte*)\"glStencilOpSeparateATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ATI_separate_stencil */\n\n#ifdef GL_ATI_shader_texture_lod\n\n#endif /* GL_ATI_shader_texture_lod */\n\n#ifdef GL_ATI_text_fragment_shader\n\n#endif /* GL_ATI_text_fragment_shader */\n\n#ifdef GL_ATI_texture_compression_3dc\n\n#endif /* GL_ATI_texture_compression_3dc */\n\n#ifdef GL_ATI_texture_env_combine3\n\n#endif /* GL_ATI_texture_env_combine3 */\n\n#ifdef GL_ATI_texture_float\n\n#endif /* GL_ATI_texture_float */\n\n#ifdef GL_ATI_texture_mirror_once\n\n#endif /* GL_ATI_texture_mirror_once */\n\n#ifdef GL_ATI_vertex_array_object\n\nstatic GLboolean _glewInit_GL_ATI_vertex_array_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glArrayObjectATI = (PFNGLARRAYOBJECTATIPROC)glewGetProcAddress((const GLubyte*)\"glArrayObjectATI\")) == NULL) || r;\n  r = ((glFreeObjectBufferATI = (PFNGLFREEOBJECTBUFFERATIPROC)glewGetProcAddress((const GLubyte*)\"glFreeObjectBufferATI\")) == NULL) || r;\n  r = ((glGetArrayObjectfvATI = (PFNGLGETARRAYOBJECTFVATIPROC)glewGetProcAddress((const GLubyte*)\"glGetArrayObjectfvATI\")) == NULL) || r;\n  r = ((glGetArrayObjectivATI = (PFNGLGETARRAYOBJECTIVATIPROC)glewGetProcAddress((const GLubyte*)\"glGetArrayObjectivATI\")) == NULL) || r;\n  r = ((glGetObjectBufferfvATI = (PFNGLGETOBJECTBUFFERFVATIPROC)glewGetProcAddress((const GLubyte*)\"glGetObjectBufferfvATI\")) == NULL) || r;\n  r = ((glGetObjectBufferivATI = (PFNGLGETOBJECTBUFFERIVATIPROC)glewGetProcAddress((const GLubyte*)\"glGetObjectBufferivATI\")) == NULL) || r;\n  r = ((glGetVariantArrayObjectfvATI = (PFNGLGETVARIANTARRAYOBJECTFVATIPROC)glewGetProcAddress((const GLubyte*)\"glGetVariantArrayObjectfvATI\")) == NULL) || r;\n  r = ((glGetVariantArrayObjectivATI = (PFNGLGETVARIANTARRAYOBJECTIVATIPROC)glewGetProcAddress((const GLubyte*)\"glGetVariantArrayObjectivATI\")) == NULL) || r;\n  r = ((glIsObjectBufferATI = (PFNGLISOBJECTBUFFERATIPROC)glewGetProcAddress((const GLubyte*)\"glIsObjectBufferATI\")) == NULL) || r;\n  r = ((glNewObjectBufferATI = (PFNGLNEWOBJECTBUFFERATIPROC)glewGetProcAddress((const GLubyte*)\"glNewObjectBufferATI\")) == NULL) || r;\n  r = ((glUpdateObjectBufferATI = (PFNGLUPDATEOBJECTBUFFERATIPROC)glewGetProcAddress((const GLubyte*)\"glUpdateObjectBufferATI\")) == NULL) || r;\n  r = ((glVariantArrayObjectATI = (PFNGLVARIANTARRAYOBJECTATIPROC)glewGetProcAddress((const GLubyte*)\"glVariantArrayObjectATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ATI_vertex_array_object */\n\n#ifdef GL_ATI_vertex_attrib_array_object\n\nstatic GLboolean _glewInit_GL_ATI_vertex_attrib_array_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetVertexAttribArrayObjectfvATI = (PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribArrayObjectfvATI\")) == NULL) || r;\n  r = ((glGetVertexAttribArrayObjectivATI = (PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribArrayObjectivATI\")) == NULL) || r;\n  r = ((glVertexAttribArrayObjectATI = (PFNGLVERTEXATTRIBARRAYOBJECTATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribArrayObjectATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ATI_vertex_attrib_array_object */\n\n#ifdef GL_ATI_vertex_streams\n\nstatic GLboolean _glewInit_GL_ATI_vertex_streams (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glClientActiveVertexStreamATI = (PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC)glewGetProcAddress((const GLubyte*)\"glClientActiveVertexStreamATI\")) == NULL) || r;\n  r = ((glNormalStream3bATI = (PFNGLNORMALSTREAM3BATIPROC)glewGetProcAddress((const GLubyte*)\"glNormalStream3bATI\")) == NULL) || r;\n  r = ((glNormalStream3bvATI = (PFNGLNORMALSTREAM3BVATIPROC)glewGetProcAddress((const GLubyte*)\"glNormalStream3bvATI\")) == NULL) || r;\n  r = ((glNormalStream3dATI = (PFNGLNORMALSTREAM3DATIPROC)glewGetProcAddress((const GLubyte*)\"glNormalStream3dATI\")) == NULL) || r;\n  r = ((glNormalStream3dvATI = (PFNGLNORMALSTREAM3DVATIPROC)glewGetProcAddress((const GLubyte*)\"glNormalStream3dvATI\")) == NULL) || r;\n  r = ((glNormalStream3fATI = (PFNGLNORMALSTREAM3FATIPROC)glewGetProcAddress((const GLubyte*)\"glNormalStream3fATI\")) == NULL) || r;\n  r = ((glNormalStream3fvATI = (PFNGLNORMALSTREAM3FVATIPROC)glewGetProcAddress((const GLubyte*)\"glNormalStream3fvATI\")) == NULL) || r;\n  r = ((glNormalStream3iATI = (PFNGLNORMALSTREAM3IATIPROC)glewGetProcAddress((const GLubyte*)\"glNormalStream3iATI\")) == NULL) || r;\n  r = ((glNormalStream3ivATI = (PFNGLNORMALSTREAM3IVATIPROC)glewGetProcAddress((const GLubyte*)\"glNormalStream3ivATI\")) == NULL) || r;\n  r = ((glNormalStream3sATI = (PFNGLNORMALSTREAM3SATIPROC)glewGetProcAddress((const GLubyte*)\"glNormalStream3sATI\")) == NULL) || r;\n  r = ((glNormalStream3svATI = (PFNGLNORMALSTREAM3SVATIPROC)glewGetProcAddress((const GLubyte*)\"glNormalStream3svATI\")) == NULL) || r;\n  r = ((glVertexBlendEnvfATI = (PFNGLVERTEXBLENDENVFATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexBlendEnvfATI\")) == NULL) || r;\n  r = ((glVertexBlendEnviATI = (PFNGLVERTEXBLENDENVIATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexBlendEnviATI\")) == NULL) || r;\n  r = ((glVertexStream2dATI = (PFNGLVERTEXSTREAM2DATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream2dATI\")) == NULL) || r;\n  r = ((glVertexStream2dvATI = (PFNGLVERTEXSTREAM2DVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream2dvATI\")) == NULL) || r;\n  r = ((glVertexStream2fATI = (PFNGLVERTEXSTREAM2FATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream2fATI\")) == NULL) || r;\n  r = ((glVertexStream2fvATI = (PFNGLVERTEXSTREAM2FVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream2fvATI\")) == NULL) || r;\n  r = ((glVertexStream2iATI = (PFNGLVERTEXSTREAM2IATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream2iATI\")) == NULL) || r;\n  r = ((glVertexStream2ivATI = (PFNGLVERTEXSTREAM2IVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream2ivATI\")) == NULL) || r;\n  r = ((glVertexStream2sATI = (PFNGLVERTEXSTREAM2SATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream2sATI\")) == NULL) || r;\n  r = ((glVertexStream2svATI = (PFNGLVERTEXSTREAM2SVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream2svATI\")) == NULL) || r;\n  r = ((glVertexStream3dATI = (PFNGLVERTEXSTREAM3DATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream3dATI\")) == NULL) || r;\n  r = ((glVertexStream3dvATI = (PFNGLVERTEXSTREAM3DVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream3dvATI\")) == NULL) || r;\n  r = ((glVertexStream3fATI = (PFNGLVERTEXSTREAM3FATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream3fATI\")) == NULL) || r;\n  r = ((glVertexStream3fvATI = (PFNGLVERTEXSTREAM3FVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream3fvATI\")) == NULL) || r;\n  r = ((glVertexStream3iATI = (PFNGLVERTEXSTREAM3IATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream3iATI\")) == NULL) || r;\n  r = ((glVertexStream3ivATI = (PFNGLVERTEXSTREAM3IVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream3ivATI\")) == NULL) || r;\n  r = ((glVertexStream3sATI = (PFNGLVERTEXSTREAM3SATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream3sATI\")) == NULL) || r;\n  r = ((glVertexStream3svATI = (PFNGLVERTEXSTREAM3SVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream3svATI\")) == NULL) || r;\n  r = ((glVertexStream4dATI = (PFNGLVERTEXSTREAM4DATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream4dATI\")) == NULL) || r;\n  r = ((glVertexStream4dvATI = (PFNGLVERTEXSTREAM4DVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream4dvATI\")) == NULL) || r;\n  r = ((glVertexStream4fATI = (PFNGLVERTEXSTREAM4FATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream4fATI\")) == NULL) || r;\n  r = ((glVertexStream4fvATI = (PFNGLVERTEXSTREAM4FVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream4fvATI\")) == NULL) || r;\n  r = ((glVertexStream4iATI = (PFNGLVERTEXSTREAM4IATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream4iATI\")) == NULL) || r;\n  r = ((glVertexStream4ivATI = (PFNGLVERTEXSTREAM4IVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream4ivATI\")) == NULL) || r;\n  r = ((glVertexStream4sATI = (PFNGLVERTEXSTREAM4SATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream4sATI\")) == NULL) || r;\n  r = ((glVertexStream4svATI = (PFNGLVERTEXSTREAM4SVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream4svATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ATI_vertex_streams */\n\n#ifdef GL_EXT_422_pixels\n\n#endif /* GL_EXT_422_pixels */\n\n#ifdef GL_EXT_Cg_shader\n\n#endif /* GL_EXT_Cg_shader */\n\n#ifdef GL_EXT_abgr\n\n#endif /* GL_EXT_abgr */\n\n#ifdef GL_EXT_bgra\n\n#endif /* GL_EXT_bgra */\n\n#ifdef GL_EXT_bindable_uniform\n\nstatic GLboolean _glewInit_GL_EXT_bindable_uniform (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetUniformBufferSizeEXT = (PFNGLGETUNIFORMBUFFERSIZEEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetUniformBufferSizeEXT\")) == NULL) || r;\n  r = ((glGetUniformOffsetEXT = (PFNGLGETUNIFORMOFFSETEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetUniformOffsetEXT\")) == NULL) || r;\n  r = ((glUniformBufferEXT = (PFNGLUNIFORMBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glUniformBufferEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_bindable_uniform */\n\n#ifdef GL_EXT_blend_color\n\nstatic GLboolean _glewInit_GL_EXT_blend_color (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBlendColorEXT = (PFNGLBLENDCOLOREXTPROC)glewGetProcAddress((const GLubyte*)\"glBlendColorEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_blend_color */\n\n#ifdef GL_EXT_blend_equation_separate\n\nstatic GLboolean _glewInit_GL_EXT_blend_equation_separate (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBlendEquationSeparateEXT = (PFNGLBLENDEQUATIONSEPARATEEXTPROC)glewGetProcAddress((const GLubyte*)\"glBlendEquationSeparateEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_blend_equation_separate */\n\n#ifdef GL_EXT_blend_func_separate\n\nstatic GLboolean _glewInit_GL_EXT_blend_func_separate (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBlendFuncSeparateEXT = (PFNGLBLENDFUNCSEPARATEEXTPROC)glewGetProcAddress((const GLubyte*)\"glBlendFuncSeparateEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_blend_func_separate */\n\n#ifdef GL_EXT_blend_logic_op\n\n#endif /* GL_EXT_blend_logic_op */\n\n#ifdef GL_EXT_blend_minmax\n\nstatic GLboolean _glewInit_GL_EXT_blend_minmax (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBlendEquationEXT = (PFNGLBLENDEQUATIONEXTPROC)glewGetProcAddress((const GLubyte*)\"glBlendEquationEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_blend_minmax */\n\n#ifdef GL_EXT_blend_subtract\n\n#endif /* GL_EXT_blend_subtract */\n\n#ifdef GL_EXT_clip_volume_hint\n\n#endif /* GL_EXT_clip_volume_hint */\n\n#ifdef GL_EXT_cmyka\n\n#endif /* GL_EXT_cmyka */\n\n#ifdef GL_EXT_color_subtable\n\nstatic GLboolean _glewInit_GL_EXT_color_subtable (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glColorSubTableEXT = (PFNGLCOLORSUBTABLEEXTPROC)glewGetProcAddress((const GLubyte*)\"glColorSubTableEXT\")) == NULL) || r;\n  r = ((glCopyColorSubTableEXT = (PFNGLCOPYCOLORSUBTABLEEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyColorSubTableEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_color_subtable */\n\n#ifdef GL_EXT_compiled_vertex_array\n\nstatic GLboolean _glewInit_GL_EXT_compiled_vertex_array (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glLockArraysEXT = (PFNGLLOCKARRAYSEXTPROC)glewGetProcAddress((const GLubyte*)\"glLockArraysEXT\")) == NULL) || r;\n  r = ((glUnlockArraysEXT = (PFNGLUNLOCKARRAYSEXTPROC)glewGetProcAddress((const GLubyte*)\"glUnlockArraysEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_compiled_vertex_array */\n\n#ifdef GL_EXT_convolution\n\nstatic GLboolean _glewInit_GL_EXT_convolution (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glConvolutionFilter1DEXT = (PFNGLCONVOLUTIONFILTER1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionFilter1DEXT\")) == NULL) || r;\n  r = ((glConvolutionFilter2DEXT = (PFNGLCONVOLUTIONFILTER2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionFilter2DEXT\")) == NULL) || r;\n  r = ((glConvolutionParameterfEXT = (PFNGLCONVOLUTIONPARAMETERFEXTPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionParameterfEXT\")) == NULL) || r;\n  r = ((glConvolutionParameterfvEXT = (PFNGLCONVOLUTIONPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionParameterfvEXT\")) == NULL) || r;\n  r = ((glConvolutionParameteriEXT = (PFNGLCONVOLUTIONPARAMETERIEXTPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionParameteriEXT\")) == NULL) || r;\n  r = ((glConvolutionParameterivEXT = (PFNGLCONVOLUTIONPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionParameterivEXT\")) == NULL) || r;\n  r = ((glCopyConvolutionFilter1DEXT = (PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyConvolutionFilter1DEXT\")) == NULL) || r;\n  r = ((glCopyConvolutionFilter2DEXT = (PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyConvolutionFilter2DEXT\")) == NULL) || r;\n  r = ((glGetConvolutionFilterEXT = (PFNGLGETCONVOLUTIONFILTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glGetConvolutionFilterEXT\")) == NULL) || r;\n  r = ((glGetConvolutionParameterfvEXT = (PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetConvolutionParameterfvEXT\")) == NULL) || r;\n  r = ((glGetConvolutionParameterivEXT = (PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetConvolutionParameterivEXT\")) == NULL) || r;\n  r = ((glGetSeparableFilterEXT = (PFNGLGETSEPARABLEFILTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glGetSeparableFilterEXT\")) == NULL) || r;\n  r = ((glSeparableFilter2DEXT = (PFNGLSEPARABLEFILTER2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glSeparableFilter2DEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_convolution */\n\n#ifdef GL_EXT_coordinate_frame\n\nstatic GLboolean _glewInit_GL_EXT_coordinate_frame (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBinormalPointerEXT = (PFNGLBINORMALPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBinormalPointerEXT\")) == NULL) || r;\n  r = ((glTangentPointerEXT = (PFNGLTANGENTPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glTangentPointerEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_coordinate_frame */\n\n#ifdef GL_EXT_copy_texture\n\nstatic GLboolean _glewInit_GL_EXT_copy_texture (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glCopyTexImage1DEXT = (PFNGLCOPYTEXIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyTexImage1DEXT\")) == NULL) || r;\n  r = ((glCopyTexImage2DEXT = (PFNGLCOPYTEXIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyTexImage2DEXT\")) == NULL) || r;\n  r = ((glCopyTexSubImage1DEXT = (PFNGLCOPYTEXSUBIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyTexSubImage1DEXT\")) == NULL) || r;\n  r = ((glCopyTexSubImage2DEXT = (PFNGLCOPYTEXSUBIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyTexSubImage2DEXT\")) == NULL) || r;\n  r = ((glCopyTexSubImage3DEXT = (PFNGLCOPYTEXSUBIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyTexSubImage3DEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_copy_texture */\n\n#ifdef GL_EXT_cull_vertex\n\nstatic GLboolean _glewInit_GL_EXT_cull_vertex (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glCullParameterdvEXT = (PFNGLCULLPARAMETERDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glCullParameterdvEXT\")) == NULL) || r;\n  r = ((glCullParameterfvEXT = (PFNGLCULLPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glCullParameterfvEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_cull_vertex */\n\n#ifdef GL_EXT_depth_bounds_test\n\nstatic GLboolean _glewInit_GL_EXT_depth_bounds_test (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDepthBoundsEXT = (PFNGLDEPTHBOUNDSEXTPROC)glewGetProcAddress((const GLubyte*)\"glDepthBoundsEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_depth_bounds_test */\n\n#ifdef GL_EXT_direct_state_access\n\nstatic GLboolean _glewInit_GL_EXT_direct_state_access (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBindMultiTextureEXT = (PFNGLBINDMULTITEXTUREEXTPROC)glewGetProcAddress((const GLubyte*)\"glBindMultiTextureEXT\")) == NULL) || r;\n  r = ((glCheckNamedFramebufferStatusEXT = (PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC)glewGetProcAddress((const GLubyte*)\"glCheckNamedFramebufferStatusEXT\")) == NULL) || r;\n  r = ((glClientAttribDefaultEXT = (PFNGLCLIENTATTRIBDEFAULTEXTPROC)glewGetProcAddress((const GLubyte*)\"glClientAttribDefaultEXT\")) == NULL) || r;\n  r = ((glCompressedMultiTexImage1DEXT = (PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedMultiTexImage1DEXT\")) == NULL) || r;\n  r = ((glCompressedMultiTexImage2DEXT = (PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedMultiTexImage2DEXT\")) == NULL) || r;\n  r = ((glCompressedMultiTexImage3DEXT = (PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedMultiTexImage3DEXT\")) == NULL) || r;\n  r = ((glCompressedMultiTexSubImage1DEXT = (PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedMultiTexSubImage1DEXT\")) == NULL) || r;\n  r = ((glCompressedMultiTexSubImage2DEXT = (PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedMultiTexSubImage2DEXT\")) == NULL) || r;\n  r = ((glCompressedMultiTexSubImage3DEXT = (PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedMultiTexSubImage3DEXT\")) == NULL) || r;\n  r = ((glCompressedTextureImage1DEXT = (PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTextureImage1DEXT\")) == NULL) || r;\n  r = ((glCompressedTextureImage2DEXT = (PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTextureImage2DEXT\")) == NULL) || r;\n  r = ((glCompressedTextureImage3DEXT = (PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTextureImage3DEXT\")) == NULL) || r;\n  r = ((glCompressedTextureSubImage1DEXT = (PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTextureSubImage1DEXT\")) == NULL) || r;\n  r = ((glCompressedTextureSubImage2DEXT = (PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTextureSubImage2DEXT\")) == NULL) || r;\n  r = ((glCompressedTextureSubImage3DEXT = (PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTextureSubImage3DEXT\")) == NULL) || r;\n  r = ((glCopyMultiTexImage1DEXT = (PFNGLCOPYMULTITEXIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyMultiTexImage1DEXT\")) == NULL) || r;\n  r = ((glCopyMultiTexImage2DEXT = (PFNGLCOPYMULTITEXIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyMultiTexImage2DEXT\")) == NULL) || r;\n  r = ((glCopyMultiTexSubImage1DEXT = (PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyMultiTexSubImage1DEXT\")) == NULL) || r;\n  r = ((glCopyMultiTexSubImage2DEXT = (PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyMultiTexSubImage2DEXT\")) == NULL) || r;\n  r = ((glCopyMultiTexSubImage3DEXT = (PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyMultiTexSubImage3DEXT\")) == NULL) || r;\n  r = ((glCopyTextureImage1DEXT = (PFNGLCOPYTEXTUREIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyTextureImage1DEXT\")) == NULL) || r;\n  r = ((glCopyTextureImage2DEXT = (PFNGLCOPYTEXTUREIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyTextureImage2DEXT\")) == NULL) || r;\n  r = ((glCopyTextureSubImage1DEXT = (PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyTextureSubImage1DEXT\")) == NULL) || r;\n  r = ((glCopyTextureSubImage2DEXT = (PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyTextureSubImage2DEXT\")) == NULL) || r;\n  r = ((glCopyTextureSubImage3DEXT = (PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyTextureSubImage3DEXT\")) == NULL) || r;\n  r = ((glDisableClientStateIndexedEXT = (PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glDisableClientStateIndexedEXT\")) == NULL) || r;\n  r = ((glEnableClientStateIndexedEXT = (PFNGLENABLECLIENTSTATEINDEXEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glEnableClientStateIndexedEXT\")) == NULL) || r;\n  r = ((glFramebufferDrawBufferEXT = (PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferDrawBufferEXT\")) == NULL) || r;\n  r = ((glFramebufferDrawBuffersEXT = (PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferDrawBuffersEXT\")) == NULL) || r;\n  r = ((glFramebufferReadBufferEXT = (PFNGLFRAMEBUFFERREADBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferReadBufferEXT\")) == NULL) || r;\n  r = ((glGenerateMultiTexMipmapEXT = (PFNGLGENERATEMULTITEXMIPMAPEXTPROC)glewGetProcAddress((const GLubyte*)\"glGenerateMultiTexMipmapEXT\")) == NULL) || r;\n  r = ((glGenerateTextureMipmapEXT = (PFNGLGENERATETEXTUREMIPMAPEXTPROC)glewGetProcAddress((const GLubyte*)\"glGenerateTextureMipmapEXT\")) == NULL) || r;\n  r = ((glGetCompressedMultiTexImageEXT = (PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetCompressedMultiTexImageEXT\")) == NULL) || r;\n  r = ((glGetCompressedTextureImageEXT = (PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetCompressedTextureImageEXT\")) == NULL) || r;\n  r = ((glGetDoubleIndexedvEXT = (PFNGLGETDOUBLEINDEXEDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetDoubleIndexedvEXT\")) == NULL) || r;\n  r = ((glGetFloatIndexedvEXT = (PFNGLGETFLOATINDEXEDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetFloatIndexedvEXT\")) == NULL) || r;\n  r = ((glGetFramebufferParameterivEXT = (PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetFramebufferParameterivEXT\")) == NULL) || r;\n  r = ((glGetMultiTexEnvfvEXT = (PFNGLGETMULTITEXENVFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexEnvfvEXT\")) == NULL) || r;\n  r = ((glGetMultiTexEnvivEXT = (PFNGLGETMULTITEXENVIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexEnvivEXT\")) == NULL) || r;\n  r = ((glGetMultiTexGendvEXT = (PFNGLGETMULTITEXGENDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexGendvEXT\")) == NULL) || r;\n  r = ((glGetMultiTexGenfvEXT = (PFNGLGETMULTITEXGENFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexGenfvEXT\")) == NULL) || r;\n  r = ((glGetMultiTexGenivEXT = (PFNGLGETMULTITEXGENIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexGenivEXT\")) == NULL) || r;\n  r = ((glGetMultiTexImageEXT = (PFNGLGETMULTITEXIMAGEEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexImageEXT\")) == NULL) || r;\n  r = ((glGetMultiTexLevelParameterfvEXT = (PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexLevelParameterfvEXT\")) == NULL) || r;\n  r = ((glGetMultiTexLevelParameterivEXT = (PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexLevelParameterivEXT\")) == NULL) || r;\n  r = ((glGetMultiTexParameterIivEXT = (PFNGLGETMULTITEXPARAMETERIIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexParameterIivEXT\")) == NULL) || r;\n  r = ((glGetMultiTexParameterIuivEXT = (PFNGLGETMULTITEXPARAMETERIUIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexParameterIuivEXT\")) == NULL) || r;\n  r = ((glGetMultiTexParameterfvEXT = (PFNGLGETMULTITEXPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexParameterfvEXT\")) == NULL) || r;\n  r = ((glGetMultiTexParameterivEXT = (PFNGLGETMULTITEXPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexParameterivEXT\")) == NULL) || r;\n  r = ((glGetNamedBufferParameterivEXT = (PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedBufferParameterivEXT\")) == NULL) || r;\n  r = ((glGetNamedBufferPointervEXT = (PFNGLGETNAMEDBUFFERPOINTERVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedBufferPointervEXT\")) == NULL) || r;\n  r = ((glGetNamedBufferSubDataEXT = (PFNGLGETNAMEDBUFFERSUBDATAEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedBufferSubDataEXT\")) == NULL) || r;\n  r = ((glGetNamedFramebufferAttachmentParameterivEXT = (PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedFramebufferAttachmentParameterivEXT\")) == NULL) || r;\n  r = ((glGetNamedProgramLocalParameterIivEXT = (PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedProgramLocalParameterIivEXT\")) == NULL) || r;\n  r = ((glGetNamedProgramLocalParameterIuivEXT = (PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedProgramLocalParameterIuivEXT\")) == NULL) || r;\n  r = ((glGetNamedProgramLocalParameterdvEXT = (PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedProgramLocalParameterdvEXT\")) == NULL) || r;\n  r = ((glGetNamedProgramLocalParameterfvEXT = (PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedProgramLocalParameterfvEXT\")) == NULL) || r;\n  r = ((glGetNamedProgramStringEXT = (PFNGLGETNAMEDPROGRAMSTRINGEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedProgramStringEXT\")) == NULL) || r;\n  r = ((glGetNamedProgramivEXT = (PFNGLGETNAMEDPROGRAMIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedProgramivEXT\")) == NULL) || r;\n  r = ((glGetNamedRenderbufferParameterivEXT = (PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedRenderbufferParameterivEXT\")) == NULL) || r;\n  r = ((glGetPointerIndexedvEXT = (PFNGLGETPOINTERINDEXEDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetPointerIndexedvEXT\")) == NULL) || r;\n  r = ((glGetTextureImageEXT = (PFNGLGETTEXTUREIMAGEEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetTextureImageEXT\")) == NULL) || r;\n  r = ((glGetTextureLevelParameterfvEXT = (PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetTextureLevelParameterfvEXT\")) == NULL) || r;\n  r = ((glGetTextureLevelParameterivEXT = (PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetTextureLevelParameterivEXT\")) == NULL) || r;\n  r = ((glGetTextureParameterIivEXT = (PFNGLGETTEXTUREPARAMETERIIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetTextureParameterIivEXT\")) == NULL) || r;\n  r = ((glGetTextureParameterIuivEXT = (PFNGLGETTEXTUREPARAMETERIUIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetTextureParameterIuivEXT\")) == NULL) || r;\n  r = ((glGetTextureParameterfvEXT = (PFNGLGETTEXTUREPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetTextureParameterfvEXT\")) == NULL) || r;\n  r = ((glGetTextureParameterivEXT = (PFNGLGETTEXTUREPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetTextureParameterivEXT\")) == NULL) || r;\n  r = ((glMapNamedBufferEXT = (PFNGLMAPNAMEDBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glMapNamedBufferEXT\")) == NULL) || r;\n  r = ((glMatrixFrustumEXT = (PFNGLMATRIXFRUSTUMEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixFrustumEXT\")) == NULL) || r;\n  r = ((glMatrixLoadIdentityEXT = (PFNGLMATRIXLOADIDENTITYEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixLoadIdentityEXT\")) == NULL) || r;\n  r = ((glMatrixLoadTransposedEXT = (PFNGLMATRIXLOADTRANSPOSEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixLoadTransposedEXT\")) == NULL) || r;\n  r = ((glMatrixLoadTransposefEXT = (PFNGLMATRIXLOADTRANSPOSEFEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixLoadTransposefEXT\")) == NULL) || r;\n  r = ((glMatrixLoaddEXT = (PFNGLMATRIXLOADDEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixLoaddEXT\")) == NULL) || r;\n  r = ((glMatrixLoadfEXT = (PFNGLMATRIXLOADFEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixLoadfEXT\")) == NULL) || r;\n  r = ((glMatrixMultTransposedEXT = (PFNGLMATRIXMULTTRANSPOSEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixMultTransposedEXT\")) == NULL) || r;\n  r = ((glMatrixMultTransposefEXT = (PFNGLMATRIXMULTTRANSPOSEFEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixMultTransposefEXT\")) == NULL) || r;\n  r = ((glMatrixMultdEXT = (PFNGLMATRIXMULTDEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixMultdEXT\")) == NULL) || r;\n  r = ((glMatrixMultfEXT = (PFNGLMATRIXMULTFEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixMultfEXT\")) == NULL) || r;\n  r = ((glMatrixOrthoEXT = (PFNGLMATRIXORTHOEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixOrthoEXT\")) == NULL) || r;\n  r = ((glMatrixPopEXT = (PFNGLMATRIXPOPEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixPopEXT\")) == NULL) || r;\n  r = ((glMatrixPushEXT = (PFNGLMATRIXPUSHEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixPushEXT\")) == NULL) || r;\n  r = ((glMatrixRotatedEXT = (PFNGLMATRIXROTATEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixRotatedEXT\")) == NULL) || r;\n  r = ((glMatrixRotatefEXT = (PFNGLMATRIXROTATEFEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixRotatefEXT\")) == NULL) || r;\n  r = ((glMatrixScaledEXT = (PFNGLMATRIXSCALEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixScaledEXT\")) == NULL) || r;\n  r = ((glMatrixScalefEXT = (PFNGLMATRIXSCALEFEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixScalefEXT\")) == NULL) || r;\n  r = ((glMatrixTranslatedEXT = (PFNGLMATRIXTRANSLATEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixTranslatedEXT\")) == NULL) || r;\n  r = ((glMatrixTranslatefEXT = (PFNGLMATRIXTRANSLATEFEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixTranslatefEXT\")) == NULL) || r;\n  r = ((glMultiTexBufferEXT = (PFNGLMULTITEXBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexBufferEXT\")) == NULL) || r;\n  r = ((glMultiTexCoordPointerEXT = (PFNGLMULTITEXCOORDPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoordPointerEXT\")) == NULL) || r;\n  r = ((glMultiTexEnvfEXT = (PFNGLMULTITEXENVFEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexEnvfEXT\")) == NULL) || r;\n  r = ((glMultiTexEnvfvEXT = (PFNGLMULTITEXENVFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexEnvfvEXT\")) == NULL) || r;\n  r = ((glMultiTexEnviEXT = (PFNGLMULTITEXENVIEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexEnviEXT\")) == NULL) || r;\n  r = ((glMultiTexEnvivEXT = (PFNGLMULTITEXENVIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexEnvivEXT\")) == NULL) || r;\n  r = ((glMultiTexGendEXT = (PFNGLMULTITEXGENDEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexGendEXT\")) == NULL) || r;\n  r = ((glMultiTexGendvEXT = (PFNGLMULTITEXGENDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexGendvEXT\")) == NULL) || r;\n  r = ((glMultiTexGenfEXT = (PFNGLMULTITEXGENFEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexGenfEXT\")) == NULL) || r;\n  r = ((glMultiTexGenfvEXT = (PFNGLMULTITEXGENFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexGenfvEXT\")) == NULL) || r;\n  r = ((glMultiTexGeniEXT = (PFNGLMULTITEXGENIEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexGeniEXT\")) == NULL) || r;\n  r = ((glMultiTexGenivEXT = (PFNGLMULTITEXGENIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexGenivEXT\")) == NULL) || r;\n  r = ((glMultiTexImage1DEXT = (PFNGLMULTITEXIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexImage1DEXT\")) == NULL) || r;\n  r = ((glMultiTexImage2DEXT = (PFNGLMULTITEXIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexImage2DEXT\")) == NULL) || r;\n  r = ((glMultiTexImage3DEXT = (PFNGLMULTITEXIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexImage3DEXT\")) == NULL) || r;\n  r = ((glMultiTexParameterIivEXT = (PFNGLMULTITEXPARAMETERIIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexParameterIivEXT\")) == NULL) || r;\n  r = ((glMultiTexParameterIuivEXT = (PFNGLMULTITEXPARAMETERIUIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexParameterIuivEXT\")) == NULL) || r;\n  r = ((glMultiTexParameterfEXT = (PFNGLMULTITEXPARAMETERFEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexParameterfEXT\")) == NULL) || r;\n  r = ((glMultiTexParameterfvEXT = (PFNGLMULTITEXPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexParameterfvEXT\")) == NULL) || r;\n  r = ((glMultiTexParameteriEXT = (PFNGLMULTITEXPARAMETERIEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexParameteriEXT\")) == NULL) || r;\n  r = ((glMultiTexParameterivEXT = (PFNGLMULTITEXPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexParameterivEXT\")) == NULL) || r;\n  r = ((glMultiTexRenderbufferEXT = (PFNGLMULTITEXRENDERBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexRenderbufferEXT\")) == NULL) || r;\n  r = ((glMultiTexSubImage1DEXT = (PFNGLMULTITEXSUBIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexSubImage1DEXT\")) == NULL) || r;\n  r = ((glMultiTexSubImage2DEXT = (PFNGLMULTITEXSUBIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexSubImage2DEXT\")) == NULL) || r;\n  r = ((glMultiTexSubImage3DEXT = (PFNGLMULTITEXSUBIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexSubImage3DEXT\")) == NULL) || r;\n  r = ((glNamedBufferDataEXT = (PFNGLNAMEDBUFFERDATAEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedBufferDataEXT\")) == NULL) || r;\n  r = ((glNamedBufferSubDataEXT = (PFNGLNAMEDBUFFERSUBDATAEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedBufferSubDataEXT\")) == NULL) || r;\n  r = ((glNamedFramebufferRenderbufferEXT = (PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedFramebufferRenderbufferEXT\")) == NULL) || r;\n  r = ((glNamedFramebufferTexture1DEXT = (PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedFramebufferTexture1DEXT\")) == NULL) || r;\n  r = ((glNamedFramebufferTexture2DEXT = (PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedFramebufferTexture2DEXT\")) == NULL) || r;\n  r = ((glNamedFramebufferTexture3DEXT = (PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedFramebufferTexture3DEXT\")) == NULL) || r;\n  r = ((glNamedFramebufferTextureEXT = (PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedFramebufferTextureEXT\")) == NULL) || r;\n  r = ((glNamedFramebufferTextureFaceEXT = (PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedFramebufferTextureFaceEXT\")) == NULL) || r;\n  r = ((glNamedFramebufferTextureLayerEXT = (PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedFramebufferTextureLayerEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParameter4dEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParameter4dEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParameter4dvEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParameter4dvEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParameter4fEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParameter4fEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParameter4fvEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParameter4fvEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParameterI4iEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParameterI4iEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParameterI4ivEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParameterI4ivEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParameterI4uiEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParameterI4uiEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParameterI4uivEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParameterI4uivEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParameters4fvEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParameters4fvEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParametersI4ivEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParametersI4ivEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParametersI4uivEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParametersI4uivEXT\")) == NULL) || r;\n  r = ((glNamedProgramStringEXT = (PFNGLNAMEDPROGRAMSTRINGEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramStringEXT\")) == NULL) || r;\n  r = ((glNamedRenderbufferStorageEXT = (PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedRenderbufferStorageEXT\")) == NULL) || r;\n  r = ((glNamedRenderbufferStorageMultisampleCoverageEXT = (PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedRenderbufferStorageMultisampleCoverageEXT\")) == NULL) || r;\n  r = ((glNamedRenderbufferStorageMultisampleEXT = (PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedRenderbufferStorageMultisampleEXT\")) == NULL) || r;\n  r = ((glProgramUniform1fEXT = (PFNGLPROGRAMUNIFORM1FEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform1fEXT\")) == NULL) || r;\n  r = ((glProgramUniform1fvEXT = (PFNGLPROGRAMUNIFORM1FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform1fvEXT\")) == NULL) || r;\n  r = ((glProgramUniform1iEXT = (PFNGLPROGRAMUNIFORM1IEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform1iEXT\")) == NULL) || r;\n  r = ((glProgramUniform1ivEXT = (PFNGLPROGRAMUNIFORM1IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform1ivEXT\")) == NULL) || r;\n  r = ((glProgramUniform1uiEXT = (PFNGLPROGRAMUNIFORM1UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform1uiEXT\")) == NULL) || r;\n  r = ((glProgramUniform1uivEXT = (PFNGLPROGRAMUNIFORM1UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform1uivEXT\")) == NULL) || r;\n  r = ((glProgramUniform2fEXT = (PFNGLPROGRAMUNIFORM2FEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform2fEXT\")) == NULL) || r;\n  r = ((glProgramUniform2fvEXT = (PFNGLPROGRAMUNIFORM2FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform2fvEXT\")) == NULL) || r;\n  r = ((glProgramUniform2iEXT = (PFNGLPROGRAMUNIFORM2IEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform2iEXT\")) == NULL) || r;\n  r = ((glProgramUniform2ivEXT = (PFNGLPROGRAMUNIFORM2IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform2ivEXT\")) == NULL) || r;\n  r = ((glProgramUniform2uiEXT = (PFNGLPROGRAMUNIFORM2UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform2uiEXT\")) == NULL) || r;\n  r = ((glProgramUniform2uivEXT = (PFNGLPROGRAMUNIFORM2UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform2uivEXT\")) == NULL) || r;\n  r = ((glProgramUniform3fEXT = (PFNGLPROGRAMUNIFORM3FEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform3fEXT\")) == NULL) || r;\n  r = ((glProgramUniform3fvEXT = (PFNGLPROGRAMUNIFORM3FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform3fvEXT\")) == NULL) || r;\n  r = ((glProgramUniform3iEXT = (PFNGLPROGRAMUNIFORM3IEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform3iEXT\")) == NULL) || r;\n  r = ((glProgramUniform3ivEXT = (PFNGLPROGRAMUNIFORM3IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform3ivEXT\")) == NULL) || r;\n  r = ((glProgramUniform3uiEXT = (PFNGLPROGRAMUNIFORM3UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform3uiEXT\")) == NULL) || r;\n  r = ((glProgramUniform3uivEXT = (PFNGLPROGRAMUNIFORM3UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform3uivEXT\")) == NULL) || r;\n  r = ((glProgramUniform4fEXT = (PFNGLPROGRAMUNIFORM4FEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform4fEXT\")) == NULL) || r;\n  r = ((glProgramUniform4fvEXT = (PFNGLPROGRAMUNIFORM4FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform4fvEXT\")) == NULL) || r;\n  r = ((glProgramUniform4iEXT = (PFNGLPROGRAMUNIFORM4IEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform4iEXT\")) == NULL) || r;\n  r = ((glProgramUniform4ivEXT = (PFNGLPROGRAMUNIFORM4IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform4ivEXT\")) == NULL) || r;\n  r = ((glProgramUniform4uiEXT = (PFNGLPROGRAMUNIFORM4UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform4uiEXT\")) == NULL) || r;\n  r = ((glProgramUniform4uivEXT = (PFNGLPROGRAMUNIFORM4UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform4uivEXT\")) == NULL) || r;\n  r = ((glProgramUniformMatrix2fvEXT = (PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniformMatrix2fvEXT\")) == NULL) || r;\n  r = ((glProgramUniformMatrix2x3fvEXT = (PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniformMatrix2x3fvEXT\")) == NULL) || r;\n  r = ((glProgramUniformMatrix2x4fvEXT = (PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniformMatrix2x4fvEXT\")) == NULL) || r;\n  r = ((glProgramUniformMatrix3fvEXT = (PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniformMatrix3fvEXT\")) == NULL) || r;\n  r = ((glProgramUniformMatrix3x2fvEXT = (PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniformMatrix3x2fvEXT\")) == NULL) || r;\n  r = ((glProgramUniformMatrix3x4fvEXT = (PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniformMatrix3x4fvEXT\")) == NULL) || r;\n  r = ((glProgramUniformMatrix4fvEXT = (PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniformMatrix4fvEXT\")) == NULL) || r;\n  r = ((glProgramUniformMatrix4x2fvEXT = (PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniformMatrix4x2fvEXT\")) == NULL) || r;\n  r = ((glProgramUniformMatrix4x3fvEXT = (PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniformMatrix4x3fvEXT\")) == NULL) || r;\n  r = ((glPushClientAttribDefaultEXT = (PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC)glewGetProcAddress((const GLubyte*)\"glPushClientAttribDefaultEXT\")) == NULL) || r;\n  r = ((glTextureBufferEXT = (PFNGLTEXTUREBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureBufferEXT\")) == NULL) || r;\n  r = ((glTextureImage1DEXT = (PFNGLTEXTUREIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureImage1DEXT\")) == NULL) || r;\n  r = ((glTextureImage2DEXT = (PFNGLTEXTUREIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureImage2DEXT\")) == NULL) || r;\n  r = ((glTextureImage3DEXT = (PFNGLTEXTUREIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureImage3DEXT\")) == NULL) || r;\n  r = ((glTextureParameterIivEXT = (PFNGLTEXTUREPARAMETERIIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureParameterIivEXT\")) == NULL) || r;\n  r = ((glTextureParameterIuivEXT = (PFNGLTEXTUREPARAMETERIUIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureParameterIuivEXT\")) == NULL) || r;\n  r = ((glTextureParameterfEXT = (PFNGLTEXTUREPARAMETERFEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureParameterfEXT\")) == NULL) || r;\n  r = ((glTextureParameterfvEXT = (PFNGLTEXTUREPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureParameterfvEXT\")) == NULL) || r;\n  r = ((glTextureParameteriEXT = (PFNGLTEXTUREPARAMETERIEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureParameteriEXT\")) == NULL) || r;\n  r = ((glTextureParameterivEXT = (PFNGLTEXTUREPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureParameterivEXT\")) == NULL) || r;\n  r = ((glTextureRenderbufferEXT = (PFNGLTEXTURERENDERBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureRenderbufferEXT\")) == NULL) || r;\n  r = ((glTextureSubImage1DEXT = (PFNGLTEXTURESUBIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureSubImage1DEXT\")) == NULL) || r;\n  r = ((glTextureSubImage2DEXT = (PFNGLTEXTURESUBIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureSubImage2DEXT\")) == NULL) || r;\n  r = ((glTextureSubImage3DEXT = (PFNGLTEXTURESUBIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureSubImage3DEXT\")) == NULL) || r;\n  r = ((glUnmapNamedBufferEXT = (PFNGLUNMAPNAMEDBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glUnmapNamedBufferEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_direct_state_access */\n\n#ifdef GL_EXT_draw_buffers2\n\nstatic GLboolean _glewInit_GL_EXT_draw_buffers2 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glColorMaskIndexedEXT = (PFNGLCOLORMASKINDEXEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glColorMaskIndexedEXT\")) == NULL) || r;\n  r = ((glDisableIndexedEXT = (PFNGLDISABLEINDEXEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glDisableIndexedEXT\")) == NULL) || r;\n  r = ((glEnableIndexedEXT = (PFNGLENABLEINDEXEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glEnableIndexedEXT\")) == NULL) || r;\n  r = ((glGetBooleanIndexedvEXT = (PFNGLGETBOOLEANINDEXEDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetBooleanIndexedvEXT\")) == NULL) || r;\n  r = ((glGetIntegerIndexedvEXT = (PFNGLGETINTEGERINDEXEDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetIntegerIndexedvEXT\")) == NULL) || r;\n  r = ((glIsEnabledIndexedEXT = (PFNGLISENABLEDINDEXEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glIsEnabledIndexedEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_draw_buffers2 */\n\n#ifdef GL_EXT_draw_instanced\n\nstatic GLboolean _glewInit_GL_EXT_draw_instanced (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDrawArraysInstancedEXT = (PFNGLDRAWARRAYSINSTANCEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glDrawArraysInstancedEXT\")) == NULL) || r;\n  r = ((glDrawElementsInstancedEXT = (PFNGLDRAWELEMENTSINSTANCEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glDrawElementsInstancedEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_draw_instanced */\n\n#ifdef GL_EXT_draw_range_elements\n\nstatic GLboolean _glewInit_GL_EXT_draw_range_elements (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDrawRangeElementsEXT = (PFNGLDRAWRANGEELEMENTSEXTPROC)glewGetProcAddress((const GLubyte*)\"glDrawRangeElementsEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_draw_range_elements */\n\n#ifdef GL_EXT_fog_coord\n\nstatic GLboolean _glewInit_GL_EXT_fog_coord (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFogCoordPointerEXT = (PFNGLFOGCOORDPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glFogCoordPointerEXT\")) == NULL) || r;\n  r = ((glFogCoorddEXT = (PFNGLFOGCOORDDEXTPROC)glewGetProcAddress((const GLubyte*)\"glFogCoorddEXT\")) == NULL) || r;\n  r = ((glFogCoorddvEXT = (PFNGLFOGCOORDDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glFogCoorddvEXT\")) == NULL) || r;\n  r = ((glFogCoordfEXT = (PFNGLFOGCOORDFEXTPROC)glewGetProcAddress((const GLubyte*)\"glFogCoordfEXT\")) == NULL) || r;\n  r = ((glFogCoordfvEXT = (PFNGLFOGCOORDFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glFogCoordfvEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_fog_coord */\n\n#ifdef GL_EXT_fragment_lighting\n\nstatic GLboolean _glewInit_GL_EXT_fragment_lighting (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFragmentColorMaterialEXT = (PFNGLFRAGMENTCOLORMATERIALEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentColorMaterialEXT\")) == NULL) || r;\n  r = ((glFragmentLightModelfEXT = (PFNGLFRAGMENTLIGHTMODELFEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightModelfEXT\")) == NULL) || r;\n  r = ((glFragmentLightModelfvEXT = (PFNGLFRAGMENTLIGHTMODELFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightModelfvEXT\")) == NULL) || r;\n  r = ((glFragmentLightModeliEXT = (PFNGLFRAGMENTLIGHTMODELIEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightModeliEXT\")) == NULL) || r;\n  r = ((glFragmentLightModelivEXT = (PFNGLFRAGMENTLIGHTMODELIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightModelivEXT\")) == NULL) || r;\n  r = ((glFragmentLightfEXT = (PFNGLFRAGMENTLIGHTFEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightfEXT\")) == NULL) || r;\n  r = ((glFragmentLightfvEXT = (PFNGLFRAGMENTLIGHTFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightfvEXT\")) == NULL) || r;\n  r = ((glFragmentLightiEXT = (PFNGLFRAGMENTLIGHTIEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightiEXT\")) == NULL) || r;\n  r = ((glFragmentLightivEXT = (PFNGLFRAGMENTLIGHTIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightivEXT\")) == NULL) || r;\n  r = ((glFragmentMaterialfEXT = (PFNGLFRAGMENTMATERIALFEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentMaterialfEXT\")) == NULL) || r;\n  r = ((glFragmentMaterialfvEXT = (PFNGLFRAGMENTMATERIALFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentMaterialfvEXT\")) == NULL) || r;\n  r = ((glFragmentMaterialiEXT = (PFNGLFRAGMENTMATERIALIEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentMaterialiEXT\")) == NULL) || r;\n  r = ((glFragmentMaterialivEXT = (PFNGLFRAGMENTMATERIALIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentMaterialivEXT\")) == NULL) || r;\n  r = ((glGetFragmentLightfvEXT = (PFNGLGETFRAGMENTLIGHTFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetFragmentLightfvEXT\")) == NULL) || r;\n  r = ((glGetFragmentLightivEXT = (PFNGLGETFRAGMENTLIGHTIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetFragmentLightivEXT\")) == NULL) || r;\n  r = ((glGetFragmentMaterialfvEXT = (PFNGLGETFRAGMENTMATERIALFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetFragmentMaterialfvEXT\")) == NULL) || r;\n  r = ((glGetFragmentMaterialivEXT = (PFNGLGETFRAGMENTMATERIALIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetFragmentMaterialivEXT\")) == NULL) || r;\n  r = ((glLightEnviEXT = (PFNGLLIGHTENVIEXTPROC)glewGetProcAddress((const GLubyte*)\"glLightEnviEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_fragment_lighting */\n\n#ifdef GL_EXT_framebuffer_blit\n\nstatic GLboolean _glewInit_GL_EXT_framebuffer_blit (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBlitFramebufferEXT = (PFNGLBLITFRAMEBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBlitFramebufferEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_framebuffer_blit */\n\n#ifdef GL_EXT_framebuffer_multisample\n\nstatic GLboolean _glewInit_GL_EXT_framebuffer_multisample (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glRenderbufferStorageMultisampleEXT = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC)glewGetProcAddress((const GLubyte*)\"glRenderbufferStorageMultisampleEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_framebuffer_multisample */\n\n#ifdef GL_EXT_framebuffer_object\n\nstatic GLboolean _glewInit_GL_EXT_framebuffer_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBindFramebufferEXT = (PFNGLBINDFRAMEBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBindFramebufferEXT\")) == NULL) || r;\n  r = ((glBindRenderbufferEXT = (PFNGLBINDRENDERBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBindRenderbufferEXT\")) == NULL) || r;\n  r = ((glCheckFramebufferStatusEXT = (PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC)glewGetProcAddress((const GLubyte*)\"glCheckFramebufferStatusEXT\")) == NULL) || r;\n  r = ((glDeleteFramebuffersEXT = (PFNGLDELETEFRAMEBUFFERSEXTPROC)glewGetProcAddress((const GLubyte*)\"glDeleteFramebuffersEXT\")) == NULL) || r;\n  r = ((glDeleteRenderbuffersEXT = (PFNGLDELETERENDERBUFFERSEXTPROC)glewGetProcAddress((const GLubyte*)\"glDeleteRenderbuffersEXT\")) == NULL) || r;\n  r = ((glFramebufferRenderbufferEXT = (PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferRenderbufferEXT\")) == NULL) || r;\n  r = ((glFramebufferTexture1DEXT = (PFNGLFRAMEBUFFERTEXTURE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTexture1DEXT\")) == NULL) || r;\n  r = ((glFramebufferTexture2DEXT = (PFNGLFRAMEBUFFERTEXTURE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTexture2DEXT\")) == NULL) || r;\n  r = ((glFramebufferTexture3DEXT = (PFNGLFRAMEBUFFERTEXTURE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTexture3DEXT\")) == NULL) || r;\n  r = ((glGenFramebuffersEXT = (PFNGLGENFRAMEBUFFERSEXTPROC)glewGetProcAddress((const GLubyte*)\"glGenFramebuffersEXT\")) == NULL) || r;\n  r = ((glGenRenderbuffersEXT = (PFNGLGENRENDERBUFFERSEXTPROC)glewGetProcAddress((const GLubyte*)\"glGenRenderbuffersEXT\")) == NULL) || r;\n  r = ((glGenerateMipmapEXT = (PFNGLGENERATEMIPMAPEXTPROC)glewGetProcAddress((const GLubyte*)\"glGenerateMipmapEXT\")) == NULL) || r;\n  r = ((glGetFramebufferAttachmentParameterivEXT = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetFramebufferAttachmentParameterivEXT\")) == NULL) || r;\n  r = ((glGetRenderbufferParameterivEXT = (PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetRenderbufferParameterivEXT\")) == NULL) || r;\n  r = ((glIsFramebufferEXT = (PFNGLISFRAMEBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glIsFramebufferEXT\")) == NULL) || r;\n  r = ((glIsRenderbufferEXT = (PFNGLISRENDERBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glIsRenderbufferEXT\")) == NULL) || r;\n  r = ((glRenderbufferStorageEXT = (PFNGLRENDERBUFFERSTORAGEEXTPROC)glewGetProcAddress((const GLubyte*)\"glRenderbufferStorageEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_framebuffer_object */\n\n#ifdef GL_EXT_framebuffer_sRGB\n\n#endif /* GL_EXT_framebuffer_sRGB */\n\n#ifdef GL_EXT_geometry_shader4\n\nstatic GLboolean _glewInit_GL_EXT_geometry_shader4 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFramebufferTextureEXT = (PFNGLFRAMEBUFFERTEXTUREEXTPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTextureEXT\")) == NULL) || r;\n  r = ((glFramebufferTextureFaceEXT = (PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTextureFaceEXT\")) == NULL) || r;\n  r = ((glFramebufferTextureLayerEXT = (PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTextureLayerEXT\")) == NULL) || r;\n  r = ((glProgramParameteriEXT = (PFNGLPROGRAMPARAMETERIEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramParameteriEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_geometry_shader4 */\n\n#ifdef GL_EXT_gpu_program_parameters\n\nstatic GLboolean _glewInit_GL_EXT_gpu_program_parameters (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glProgramEnvParameters4fvEXT = (PFNGLPROGRAMENVPARAMETERS4FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParameters4fvEXT\")) == NULL) || r;\n  r = ((glProgramLocalParameters4fvEXT = (PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParameters4fvEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_gpu_program_parameters */\n\n#ifdef GL_EXT_gpu_shader4\n\nstatic GLboolean _glewInit_GL_EXT_gpu_shader4 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBindFragDataLocationEXT = (PFNGLBINDFRAGDATALOCATIONEXTPROC)glewGetProcAddress((const GLubyte*)\"glBindFragDataLocationEXT\")) == NULL) || r;\n  r = ((glGetFragDataLocationEXT = (PFNGLGETFRAGDATALOCATIONEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetFragDataLocationEXT\")) == NULL) || r;\n  r = ((glGetUniformuivEXT = (PFNGLGETUNIFORMUIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetUniformuivEXT\")) == NULL) || r;\n  r = ((glGetVertexAttribIivEXT = (PFNGLGETVERTEXATTRIBIIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribIivEXT\")) == NULL) || r;\n  r = ((glGetVertexAttribIuivEXT = (PFNGLGETVERTEXATTRIBIUIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribIuivEXT\")) == NULL) || r;\n  r = ((glUniform1uiEXT = (PFNGLUNIFORM1UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glUniform1uiEXT\")) == NULL) || r;\n  r = ((glUniform1uivEXT = (PFNGLUNIFORM1UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glUniform1uivEXT\")) == NULL) || r;\n  r = ((glUniform2uiEXT = (PFNGLUNIFORM2UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glUniform2uiEXT\")) == NULL) || r;\n  r = ((glUniform2uivEXT = (PFNGLUNIFORM2UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glUniform2uivEXT\")) == NULL) || r;\n  r = ((glUniform3uiEXT = (PFNGLUNIFORM3UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glUniform3uiEXT\")) == NULL) || r;\n  r = ((glUniform3uivEXT = (PFNGLUNIFORM3UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glUniform3uivEXT\")) == NULL) || r;\n  r = ((glUniform4uiEXT = (PFNGLUNIFORM4UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glUniform4uiEXT\")) == NULL) || r;\n  r = ((glUniform4uivEXT = (PFNGLUNIFORM4UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glUniform4uivEXT\")) == NULL) || r;\n  r = ((glVertexAttribI1iEXT = (PFNGLVERTEXATTRIBI1IEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI1iEXT\")) == NULL) || r;\n  r = ((glVertexAttribI1ivEXT = (PFNGLVERTEXATTRIBI1IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI1ivEXT\")) == NULL) || r;\n  r = ((glVertexAttribI1uiEXT = (PFNGLVERTEXATTRIBI1UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI1uiEXT\")) == NULL) || r;\n  r = ((glVertexAttribI1uivEXT = (PFNGLVERTEXATTRIBI1UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI1uivEXT\")) == NULL) || r;\n  r = ((glVertexAttribI2iEXT = (PFNGLVERTEXATTRIBI2IEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI2iEXT\")) == NULL) || r;\n  r = ((glVertexAttribI2ivEXT = (PFNGLVERTEXATTRIBI2IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI2ivEXT\")) == NULL) || r;\n  r = ((glVertexAttribI2uiEXT = (PFNGLVERTEXATTRIBI2UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI2uiEXT\")) == NULL) || r;\n  r = ((glVertexAttribI2uivEXT = (PFNGLVERTEXATTRIBI2UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI2uivEXT\")) == NULL) || r;\n  r = ((glVertexAttribI3iEXT = (PFNGLVERTEXATTRIBI3IEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI3iEXT\")) == NULL) || r;\n  r = ((glVertexAttribI3ivEXT = (PFNGLVERTEXATTRIBI3IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI3ivEXT\")) == NULL) || r;\n  r = ((glVertexAttribI3uiEXT = (PFNGLVERTEXATTRIBI3UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI3uiEXT\")) == NULL) || r;\n  r = ((glVertexAttribI3uivEXT = (PFNGLVERTEXATTRIBI3UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI3uivEXT\")) == NULL) || r;\n  r = ((glVertexAttribI4bvEXT = (PFNGLVERTEXATTRIBI4BVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4bvEXT\")) == NULL) || r;\n  r = ((glVertexAttribI4iEXT = (PFNGLVERTEXATTRIBI4IEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4iEXT\")) == NULL) || r;\n  r = ((glVertexAttribI4ivEXT = (PFNGLVERTEXATTRIBI4IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4ivEXT\")) == NULL) || r;\n  r = ((glVertexAttribI4svEXT = (PFNGLVERTEXATTRIBI4SVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4svEXT\")) == NULL) || r;\n  r = ((glVertexAttribI4ubvEXT = (PFNGLVERTEXATTRIBI4UBVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4ubvEXT\")) == NULL) || r;\n  r = ((glVertexAttribI4uiEXT = (PFNGLVERTEXATTRIBI4UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4uiEXT\")) == NULL) || r;\n  r = ((glVertexAttribI4uivEXT = (PFNGLVERTEXATTRIBI4UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4uivEXT\")) == NULL) || r;\n  r = ((glVertexAttribI4usvEXT = (PFNGLVERTEXATTRIBI4USVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4usvEXT\")) == NULL) || r;\n  r = ((glVertexAttribIPointerEXT = (PFNGLVERTEXATTRIBIPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribIPointerEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_gpu_shader4 */\n\n#ifdef GL_EXT_histogram\n\nstatic GLboolean _glewInit_GL_EXT_histogram (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetHistogramEXT = (PFNGLGETHISTOGRAMEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetHistogramEXT\")) == NULL) || r;\n  r = ((glGetHistogramParameterfvEXT = (PFNGLGETHISTOGRAMPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetHistogramParameterfvEXT\")) == NULL) || r;\n  r = ((glGetHistogramParameterivEXT = (PFNGLGETHISTOGRAMPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetHistogramParameterivEXT\")) == NULL) || r;\n  r = ((glGetMinmaxEXT = (PFNGLGETMINMAXEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMinmaxEXT\")) == NULL) || r;\n  r = ((glGetMinmaxParameterfvEXT = (PFNGLGETMINMAXPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMinmaxParameterfvEXT\")) == NULL) || r;\n  r = ((glGetMinmaxParameterivEXT = (PFNGLGETMINMAXPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMinmaxParameterivEXT\")) == NULL) || r;\n  r = ((glHistogramEXT = (PFNGLHISTOGRAMEXTPROC)glewGetProcAddress((const GLubyte*)\"glHistogramEXT\")) == NULL) || r;\n  r = ((glMinmaxEXT = (PFNGLMINMAXEXTPROC)glewGetProcAddress((const GLubyte*)\"glMinmaxEXT\")) == NULL) || r;\n  r = ((glResetHistogramEXT = (PFNGLRESETHISTOGRAMEXTPROC)glewGetProcAddress((const GLubyte*)\"glResetHistogramEXT\")) == NULL) || r;\n  r = ((glResetMinmaxEXT = (PFNGLRESETMINMAXEXTPROC)glewGetProcAddress((const GLubyte*)\"glResetMinmaxEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_histogram */\n\n#ifdef GL_EXT_index_array_formats\n\n#endif /* GL_EXT_index_array_formats */\n\n#ifdef GL_EXT_index_func\n\nstatic GLboolean _glewInit_GL_EXT_index_func (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glIndexFuncEXT = (PFNGLINDEXFUNCEXTPROC)glewGetProcAddress((const GLubyte*)\"glIndexFuncEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_index_func */\n\n#ifdef GL_EXT_index_material\n\nstatic GLboolean _glewInit_GL_EXT_index_material (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glIndexMaterialEXT = (PFNGLINDEXMATERIALEXTPROC)glewGetProcAddress((const GLubyte*)\"glIndexMaterialEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_index_material */\n\n#ifdef GL_EXT_index_texture\n\n#endif /* GL_EXT_index_texture */\n\n#ifdef GL_EXT_light_texture\n\nstatic GLboolean _glewInit_GL_EXT_light_texture (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glApplyTextureEXT = (PFNGLAPPLYTEXTUREEXTPROC)glewGetProcAddress((const GLubyte*)\"glApplyTextureEXT\")) == NULL) || r;\n  r = ((glTextureLightEXT = (PFNGLTEXTURELIGHTEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureLightEXT\")) == NULL) || r;\n  r = ((glTextureMaterialEXT = (PFNGLTEXTUREMATERIALEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureMaterialEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_light_texture */\n\n#ifdef GL_EXT_misc_attribute\n\n#endif /* GL_EXT_misc_attribute */\n\n#ifdef GL_EXT_multi_draw_arrays\n\nstatic GLboolean _glewInit_GL_EXT_multi_draw_arrays (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glMultiDrawArraysEXT = (PFNGLMULTIDRAWARRAYSEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiDrawArraysEXT\")) == NULL) || r;\n  r = ((glMultiDrawElementsEXT = (PFNGLMULTIDRAWELEMENTSEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiDrawElementsEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_multi_draw_arrays */\n\n#ifdef GL_EXT_multisample\n\nstatic GLboolean _glewInit_GL_EXT_multisample (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glSampleMaskEXT = (PFNGLSAMPLEMASKEXTPROC)glewGetProcAddress((const GLubyte*)\"glSampleMaskEXT\")) == NULL) || r;\n  r = ((glSamplePatternEXT = (PFNGLSAMPLEPATTERNEXTPROC)glewGetProcAddress((const GLubyte*)\"glSamplePatternEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_multisample */\n\n#ifdef GL_EXT_packed_depth_stencil\n\n#endif /* GL_EXT_packed_depth_stencil */\n\n#ifdef GL_EXT_packed_float\n\n#endif /* GL_EXT_packed_float */\n\n#ifdef GL_EXT_packed_pixels\n\n#endif /* GL_EXT_packed_pixels */\n\n#ifdef GL_EXT_paletted_texture\n\nstatic GLboolean _glewInit_GL_EXT_paletted_texture (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glColorTableEXT = (PFNGLCOLORTABLEEXTPROC)glewGetProcAddress((const GLubyte*)\"glColorTableEXT\")) == NULL) || r;\n  r = ((glGetColorTableEXT = (PFNGLGETCOLORTABLEEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetColorTableEXT\")) == NULL) || r;\n  r = ((glGetColorTableParameterfvEXT = (PFNGLGETCOLORTABLEPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetColorTableParameterfvEXT\")) == NULL) || r;\n  r = ((glGetColorTableParameterivEXT = (PFNGLGETCOLORTABLEPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetColorTableParameterivEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_paletted_texture */\n\n#ifdef GL_EXT_pixel_buffer_object\n\n#endif /* GL_EXT_pixel_buffer_object */\n\n#ifdef GL_EXT_pixel_transform\n\nstatic GLboolean _glewInit_GL_EXT_pixel_transform (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetPixelTransformParameterfvEXT = (PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetPixelTransformParameterfvEXT\")) == NULL) || r;\n  r = ((glGetPixelTransformParameterivEXT = (PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetPixelTransformParameterivEXT\")) == NULL) || r;\n  r = ((glPixelTransformParameterfEXT = (PFNGLPIXELTRANSFORMPARAMETERFEXTPROC)glewGetProcAddress((const GLubyte*)\"glPixelTransformParameterfEXT\")) == NULL) || r;\n  r = ((glPixelTransformParameterfvEXT = (PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glPixelTransformParameterfvEXT\")) == NULL) || r;\n  r = ((glPixelTransformParameteriEXT = (PFNGLPIXELTRANSFORMPARAMETERIEXTPROC)glewGetProcAddress((const GLubyte*)\"glPixelTransformParameteriEXT\")) == NULL) || r;\n  r = ((glPixelTransformParameterivEXT = (PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glPixelTransformParameterivEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_pixel_transform */\n\n#ifdef GL_EXT_pixel_transform_color_table\n\n#endif /* GL_EXT_pixel_transform_color_table */\n\n#ifdef GL_EXT_point_parameters\n\nstatic GLboolean _glewInit_GL_EXT_point_parameters (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glPointParameterfEXT = (PFNGLPOINTPARAMETERFEXTPROC)glewGetProcAddress((const GLubyte*)\"glPointParameterfEXT\")) == NULL) || r;\n  r = ((glPointParameterfvEXT = (PFNGLPOINTPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glPointParameterfvEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_point_parameters */\n\n#ifdef GL_EXT_polygon_offset\n\nstatic GLboolean _glewInit_GL_EXT_polygon_offset (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glPolygonOffsetEXT = (PFNGLPOLYGONOFFSETEXTPROC)glewGetProcAddress((const GLubyte*)\"glPolygonOffsetEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_polygon_offset */\n\n#ifdef GL_EXT_rescale_normal\n\n#endif /* GL_EXT_rescale_normal */\n\n#ifdef GL_EXT_scene_marker\n\nstatic GLboolean _glewInit_GL_EXT_scene_marker (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBeginSceneEXT = (PFNGLBEGINSCENEEXTPROC)glewGetProcAddress((const GLubyte*)\"glBeginSceneEXT\")) == NULL) || r;\n  r = ((glEndSceneEXT = (PFNGLENDSCENEEXTPROC)glewGetProcAddress((const GLubyte*)\"glEndSceneEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_scene_marker */\n\n#ifdef GL_EXT_secondary_color\n\nstatic GLboolean _glewInit_GL_EXT_secondary_color (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glSecondaryColor3bEXT = (PFNGLSECONDARYCOLOR3BEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3bEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3bvEXT = (PFNGLSECONDARYCOLOR3BVEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3bvEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3dEXT = (PFNGLSECONDARYCOLOR3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3dEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3dvEXT = (PFNGLSECONDARYCOLOR3DVEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3dvEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3fEXT = (PFNGLSECONDARYCOLOR3FEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3fEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3fvEXT = (PFNGLSECONDARYCOLOR3FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3fvEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3iEXT = (PFNGLSECONDARYCOLOR3IEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3iEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3ivEXT = (PFNGLSECONDARYCOLOR3IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3ivEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3sEXT = (PFNGLSECONDARYCOLOR3SEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3sEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3svEXT = (PFNGLSECONDARYCOLOR3SVEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3svEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3ubEXT = (PFNGLSECONDARYCOLOR3UBEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3ubEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3ubvEXT = (PFNGLSECONDARYCOLOR3UBVEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3ubvEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3uiEXT = (PFNGLSECONDARYCOLOR3UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3uiEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3uivEXT = (PFNGLSECONDARYCOLOR3UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3uivEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3usEXT = (PFNGLSECONDARYCOLOR3USEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3usEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3usvEXT = (PFNGLSECONDARYCOLOR3USVEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3usvEXT\")) == NULL) || r;\n  r = ((glSecondaryColorPointerEXT = (PFNGLSECONDARYCOLORPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColorPointerEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_secondary_color */\n\n#ifdef GL_EXT_separate_specular_color\n\n#endif /* GL_EXT_separate_specular_color */\n\n#ifdef GL_EXT_shadow_funcs\n\n#endif /* GL_EXT_shadow_funcs */\n\n#ifdef GL_EXT_shared_texture_palette\n\n#endif /* GL_EXT_shared_texture_palette */\n\n#ifdef GL_EXT_stencil_clear_tag\n\n#endif /* GL_EXT_stencil_clear_tag */\n\n#ifdef GL_EXT_stencil_two_side\n\nstatic GLboolean _glewInit_GL_EXT_stencil_two_side (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glActiveStencilFaceEXT = (PFNGLACTIVESTENCILFACEEXTPROC)glewGetProcAddress((const GLubyte*)\"glActiveStencilFaceEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_stencil_two_side */\n\n#ifdef GL_EXT_stencil_wrap\n\n#endif /* GL_EXT_stencil_wrap */\n\n#ifdef GL_EXT_subtexture\n\nstatic GLboolean _glewInit_GL_EXT_subtexture (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glTexSubImage1DEXT = (PFNGLTEXSUBIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glTexSubImage1DEXT\")) == NULL) || r;\n  r = ((glTexSubImage2DEXT = (PFNGLTEXSUBIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glTexSubImage2DEXT\")) == NULL) || r;\n  r = ((glTexSubImage3DEXT = (PFNGLTEXSUBIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glTexSubImage3DEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_subtexture */\n\n#ifdef GL_EXT_texture\n\n#endif /* GL_EXT_texture */\n\n#ifdef GL_EXT_texture3D\n\nstatic GLboolean _glewInit_GL_EXT_texture3D (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glTexImage3DEXT = (PFNGLTEXIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glTexImage3DEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_texture3D */\n\n#ifdef GL_EXT_texture_array\n\n#endif /* GL_EXT_texture_array */\n\n#ifdef GL_EXT_texture_buffer_object\n\nstatic GLboolean _glewInit_GL_EXT_texture_buffer_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glTexBufferEXT = (PFNGLTEXBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glTexBufferEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_texture_buffer_object */\n\n#ifdef GL_EXT_texture_compression_dxt1\n\n#endif /* GL_EXT_texture_compression_dxt1 */\n\n#ifdef GL_EXT_texture_compression_latc\n\n#endif /* GL_EXT_texture_compression_latc */\n\n#ifdef GL_EXT_texture_compression_rgtc\n\n#endif /* GL_EXT_texture_compression_rgtc */\n\n#ifdef GL_EXT_texture_compression_s3tc\n\n#endif /* GL_EXT_texture_compression_s3tc */\n\n#ifdef GL_EXT_texture_cube_map\n\n#endif /* GL_EXT_texture_cube_map */\n\n#ifdef GL_EXT_texture_edge_clamp\n\n#endif /* GL_EXT_texture_edge_clamp */\n\n#ifdef GL_EXT_texture_env\n\n#endif /* GL_EXT_texture_env */\n\n#ifdef GL_EXT_texture_env_add\n\n#endif /* GL_EXT_texture_env_add */\n\n#ifdef GL_EXT_texture_env_combine\n\n#endif /* GL_EXT_texture_env_combine */\n\n#ifdef GL_EXT_texture_env_dot3\n\n#endif /* GL_EXT_texture_env_dot3 */\n\n#ifdef GL_EXT_texture_filter_anisotropic\n\n#endif /* GL_EXT_texture_filter_anisotropic */\n\n#ifdef GL_EXT_texture_integer\n\nstatic GLboolean _glewInit_GL_EXT_texture_integer (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glClearColorIiEXT = (PFNGLCLEARCOLORIIEXTPROC)glewGetProcAddress((const GLubyte*)\"glClearColorIiEXT\")) == NULL) || r;\n  r = ((glClearColorIuiEXT = (PFNGLCLEARCOLORIUIEXTPROC)glewGetProcAddress((const GLubyte*)\"glClearColorIuiEXT\")) == NULL) || r;\n  r = ((glGetTexParameterIivEXT = (PFNGLGETTEXPARAMETERIIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetTexParameterIivEXT\")) == NULL) || r;\n  r = ((glGetTexParameterIuivEXT = (PFNGLGETTEXPARAMETERIUIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetTexParameterIuivEXT\")) == NULL) || r;\n  r = ((glTexParameterIivEXT = (PFNGLTEXPARAMETERIIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glTexParameterIivEXT\")) == NULL) || r;\n  r = ((glTexParameterIuivEXT = (PFNGLTEXPARAMETERIUIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glTexParameterIuivEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_texture_integer */\n\n#ifdef GL_EXT_texture_lod_bias\n\n#endif /* GL_EXT_texture_lod_bias */\n\n#ifdef GL_EXT_texture_mirror_clamp\n\n#endif /* GL_EXT_texture_mirror_clamp */\n\n#ifdef GL_EXT_texture_object\n\nstatic GLboolean _glewInit_GL_EXT_texture_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glAreTexturesResidentEXT = (PFNGLARETEXTURESRESIDENTEXTPROC)glewGetProcAddress((const GLubyte*)\"glAreTexturesResidentEXT\")) == NULL) || r;\n  r = ((glBindTextureEXT = (PFNGLBINDTEXTUREEXTPROC)glewGetProcAddress((const GLubyte*)\"glBindTextureEXT\")) == NULL) || r;\n  r = ((glDeleteTexturesEXT = (PFNGLDELETETEXTURESEXTPROC)glewGetProcAddress((const GLubyte*)\"glDeleteTexturesEXT\")) == NULL) || r;\n  r = ((glGenTexturesEXT = (PFNGLGENTEXTURESEXTPROC)glewGetProcAddress((const GLubyte*)\"glGenTexturesEXT\")) == NULL) || r;\n  r = ((glIsTextureEXT = (PFNGLISTEXTUREEXTPROC)glewGetProcAddress((const GLubyte*)\"glIsTextureEXT\")) == NULL) || r;\n  r = ((glPrioritizeTexturesEXT = (PFNGLPRIORITIZETEXTURESEXTPROC)glewGetProcAddress((const GLubyte*)\"glPrioritizeTexturesEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_texture_object */\n\n#ifdef GL_EXT_texture_perturb_normal\n\nstatic GLboolean _glewInit_GL_EXT_texture_perturb_normal (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glTextureNormalEXT = (PFNGLTEXTURENORMALEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureNormalEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_texture_perturb_normal */\n\n#ifdef GL_EXT_texture_rectangle\n\n#endif /* GL_EXT_texture_rectangle */\n\n#ifdef GL_EXT_texture_sRGB\n\n#endif /* GL_EXT_texture_sRGB */\n\n#ifdef GL_EXT_texture_shared_exponent\n\n#endif /* GL_EXT_texture_shared_exponent */\n\n#ifdef GL_EXT_texture_swizzle\n\n#endif /* GL_EXT_texture_swizzle */\n\n#ifdef GL_EXT_timer_query\n\nstatic GLboolean _glewInit_GL_EXT_timer_query (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetQueryObjecti64vEXT = (PFNGLGETQUERYOBJECTI64VEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetQueryObjecti64vEXT\")) == NULL) || r;\n  r = ((glGetQueryObjectui64vEXT = (PFNGLGETQUERYOBJECTUI64VEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetQueryObjectui64vEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_timer_query */\n\n#ifdef GL_EXT_transform_feedback\n\nstatic GLboolean _glewInit_GL_EXT_transform_feedback (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBeginTransformFeedbackEXT = (PFNGLBEGINTRANSFORMFEEDBACKEXTPROC)glewGetProcAddress((const GLubyte*)\"glBeginTransformFeedbackEXT\")) == NULL) || r;\n  r = ((glBindBufferBaseEXT = (PFNGLBINDBUFFERBASEEXTPROC)glewGetProcAddress((const GLubyte*)\"glBindBufferBaseEXT\")) == NULL) || r;\n  r = ((glBindBufferOffsetEXT = (PFNGLBINDBUFFEROFFSETEXTPROC)glewGetProcAddress((const GLubyte*)\"glBindBufferOffsetEXT\")) == NULL) || r;\n  r = ((glBindBufferRangeEXT = (PFNGLBINDBUFFERRANGEEXTPROC)glewGetProcAddress((const GLubyte*)\"glBindBufferRangeEXT\")) == NULL) || r;\n  r = ((glEndTransformFeedbackEXT = (PFNGLENDTRANSFORMFEEDBACKEXTPROC)glewGetProcAddress((const GLubyte*)\"glEndTransformFeedbackEXT\")) == NULL) || r;\n  r = ((glGetTransformFeedbackVaryingEXT = (PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetTransformFeedbackVaryingEXT\")) == NULL) || r;\n  r = ((glTransformFeedbackVaryingsEXT = (PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC)glewGetProcAddress((const GLubyte*)\"glTransformFeedbackVaryingsEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_transform_feedback */\n\n#ifdef GL_EXT_vertex_array\n\nstatic GLboolean _glewInit_GL_EXT_vertex_array (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glArrayElementEXT = (PFNGLARRAYELEMENTEXTPROC)glewGetProcAddress((const GLubyte*)\"glArrayElementEXT\")) == NULL) || r;\n  r = ((glColorPointerEXT = (PFNGLCOLORPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glColorPointerEXT\")) == NULL) || r;\n  r = ((glDrawArraysEXT = (PFNGLDRAWARRAYSEXTPROC)glewGetProcAddress((const GLubyte*)\"glDrawArraysEXT\")) == NULL) || r;\n  r = ((glEdgeFlagPointerEXT = (PFNGLEDGEFLAGPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glEdgeFlagPointerEXT\")) == NULL) || r;\n  r = ((glGetPointervEXT = (PFNGLGETPOINTERVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetPointervEXT\")) == NULL) || r;\n  r = ((glIndexPointerEXT = (PFNGLINDEXPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glIndexPointerEXT\")) == NULL) || r;\n  r = ((glNormalPointerEXT = (PFNGLNORMALPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glNormalPointerEXT\")) == NULL) || r;\n  r = ((glTexCoordPointerEXT = (PFNGLTEXCOORDPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glTexCoordPointerEXT\")) == NULL) || r;\n  r = ((glVertexPointerEXT = (PFNGLVERTEXPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexPointerEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_vertex_array */\n\n#ifdef GL_EXT_vertex_array_bgra\n\n#endif /* GL_EXT_vertex_array_bgra */\n\n#ifdef GL_EXT_vertex_shader\n\nstatic GLboolean _glewInit_GL_EXT_vertex_shader (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBeginVertexShaderEXT = (PFNGLBEGINVERTEXSHADEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBeginVertexShaderEXT\")) == NULL) || r;\n  r = ((glBindLightParameterEXT = (PFNGLBINDLIGHTPARAMETEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBindLightParameterEXT\")) == NULL) || r;\n  r = ((glBindMaterialParameterEXT = (PFNGLBINDMATERIALPARAMETEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBindMaterialParameterEXT\")) == NULL) || r;\n  r = ((glBindParameterEXT = (PFNGLBINDPARAMETEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBindParameterEXT\")) == NULL) || r;\n  r = ((glBindTexGenParameterEXT = (PFNGLBINDTEXGENPARAMETEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBindTexGenParameterEXT\")) == NULL) || r;\n  r = ((glBindTextureUnitParameterEXT = (PFNGLBINDTEXTUREUNITPARAMETEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBindTextureUnitParameterEXT\")) == NULL) || r;\n  r = ((glBindVertexShaderEXT = (PFNGLBINDVERTEXSHADEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBindVertexShaderEXT\")) == NULL) || r;\n  r = ((glDeleteVertexShaderEXT = (PFNGLDELETEVERTEXSHADEREXTPROC)glewGetProcAddress((const GLubyte*)\"glDeleteVertexShaderEXT\")) == NULL) || r;\n  r = ((glDisableVariantClientStateEXT = (PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC)glewGetProcAddress((const GLubyte*)\"glDisableVariantClientStateEXT\")) == NULL) || r;\n  r = ((glEnableVariantClientStateEXT = (PFNGLENABLEVARIANTCLIENTSTATEEXTPROC)glewGetProcAddress((const GLubyte*)\"glEnableVariantClientStateEXT\")) == NULL) || r;\n  r = ((glEndVertexShaderEXT = (PFNGLENDVERTEXSHADEREXTPROC)glewGetProcAddress((const GLubyte*)\"glEndVertexShaderEXT\")) == NULL) || r;\n  r = ((glExtractComponentEXT = (PFNGLEXTRACTCOMPONENTEXTPROC)glewGetProcAddress((const GLubyte*)\"glExtractComponentEXT\")) == NULL) || r;\n  r = ((glGenSymbolsEXT = (PFNGLGENSYMBOLSEXTPROC)glewGetProcAddress((const GLubyte*)\"glGenSymbolsEXT\")) == NULL) || r;\n  r = ((glGenVertexShadersEXT = (PFNGLGENVERTEXSHADERSEXTPROC)glewGetProcAddress((const GLubyte*)\"glGenVertexShadersEXT\")) == NULL) || r;\n  r = ((glGetInvariantBooleanvEXT = (PFNGLGETINVARIANTBOOLEANVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetInvariantBooleanvEXT\")) == NULL) || r;\n  r = ((glGetInvariantFloatvEXT = (PFNGLGETINVARIANTFLOATVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetInvariantFloatvEXT\")) == NULL) || r;\n  r = ((glGetInvariantIntegervEXT = (PFNGLGETINVARIANTINTEGERVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetInvariantIntegervEXT\")) == NULL) || r;\n  r = ((glGetLocalConstantBooleanvEXT = (PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetLocalConstantBooleanvEXT\")) == NULL) || r;\n  r = ((glGetLocalConstantFloatvEXT = (PFNGLGETLOCALCONSTANTFLOATVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetLocalConstantFloatvEXT\")) == NULL) || r;\n  r = ((glGetLocalConstantIntegervEXT = (PFNGLGETLOCALCONSTANTINTEGERVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetLocalConstantIntegervEXT\")) == NULL) || r;\n  r = ((glGetVariantBooleanvEXT = (PFNGLGETVARIANTBOOLEANVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetVariantBooleanvEXT\")) == NULL) || r;\n  r = ((glGetVariantFloatvEXT = (PFNGLGETVARIANTFLOATVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetVariantFloatvEXT\")) == NULL) || r;\n  r = ((glGetVariantIntegervEXT = (PFNGLGETVARIANTINTEGERVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetVariantIntegervEXT\")) == NULL) || r;\n  r = ((glGetVariantPointervEXT = (PFNGLGETVARIANTPOINTERVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetVariantPointervEXT\")) == NULL) || r;\n  r = ((glInsertComponentEXT = (PFNGLINSERTCOMPONENTEXTPROC)glewGetProcAddress((const GLubyte*)\"glInsertComponentEXT\")) == NULL) || r;\n  r = ((glIsVariantEnabledEXT = (PFNGLISVARIANTENABLEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glIsVariantEnabledEXT\")) == NULL) || r;\n  r = ((glSetInvariantEXT = (PFNGLSETINVARIANTEXTPROC)glewGetProcAddress((const GLubyte*)\"glSetInvariantEXT\")) == NULL) || r;\n  r = ((glSetLocalConstantEXT = (PFNGLSETLOCALCONSTANTEXTPROC)glewGetProcAddress((const GLubyte*)\"glSetLocalConstantEXT\")) == NULL) || r;\n  r = ((glShaderOp1EXT = (PFNGLSHADEROP1EXTPROC)glewGetProcAddress((const GLubyte*)\"glShaderOp1EXT\")) == NULL) || r;\n  r = ((glShaderOp2EXT = (PFNGLSHADEROP2EXTPROC)glewGetProcAddress((const GLubyte*)\"glShaderOp2EXT\")) == NULL) || r;\n  r = ((glShaderOp3EXT = (PFNGLSHADEROP3EXTPROC)glewGetProcAddress((const GLubyte*)\"glShaderOp3EXT\")) == NULL) || r;\n  r = ((glSwizzleEXT = (PFNGLSWIZZLEEXTPROC)glewGetProcAddress((const GLubyte*)\"glSwizzleEXT\")) == NULL) || r;\n  r = ((glVariantPointerEXT = (PFNGLVARIANTPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glVariantPointerEXT\")) == NULL) || r;\n  r = ((glVariantbvEXT = (PFNGLVARIANTBVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVariantbvEXT\")) == NULL) || r;\n  r = ((glVariantdvEXT = (PFNGLVARIANTDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVariantdvEXT\")) == NULL) || r;\n  r = ((glVariantfvEXT = (PFNGLVARIANTFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVariantfvEXT\")) == NULL) || r;\n  r = ((glVariantivEXT = (PFNGLVARIANTIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVariantivEXT\")) == NULL) || r;\n  r = ((glVariantsvEXT = (PFNGLVARIANTSVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVariantsvEXT\")) == NULL) || r;\n  r = ((glVariantubvEXT = (PFNGLVARIANTUBVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVariantubvEXT\")) == NULL) || r;\n  r = ((glVariantuivEXT = (PFNGLVARIANTUIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVariantuivEXT\")) == NULL) || r;\n  r = ((glVariantusvEXT = (PFNGLVARIANTUSVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVariantusvEXT\")) == NULL) || r;\n  r = ((glWriteMaskEXT = (PFNGLWRITEMASKEXTPROC)glewGetProcAddress((const GLubyte*)\"glWriteMaskEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_vertex_shader */\n\n#ifdef GL_EXT_vertex_weighting\n\nstatic GLboolean _glewInit_GL_EXT_vertex_weighting (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glVertexWeightPointerEXT = (PFNGLVERTEXWEIGHTPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexWeightPointerEXT\")) == NULL) || r;\n  r = ((glVertexWeightfEXT = (PFNGLVERTEXWEIGHTFEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexWeightfEXT\")) == NULL) || r;\n  r = ((glVertexWeightfvEXT = (PFNGLVERTEXWEIGHTFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexWeightfvEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_vertex_weighting */\n\n#ifdef GL_GREMEDY_frame_terminator\n\nstatic GLboolean _glewInit_GL_GREMEDY_frame_terminator (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFrameTerminatorGREMEDY = (PFNGLFRAMETERMINATORGREMEDYPROC)glewGetProcAddress((const GLubyte*)\"glFrameTerminatorGREMEDY\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_GREMEDY_frame_terminator */\n\n#ifdef GL_GREMEDY_string_marker\n\nstatic GLboolean _glewInit_GL_GREMEDY_string_marker (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glStringMarkerGREMEDY = (PFNGLSTRINGMARKERGREMEDYPROC)glewGetProcAddress((const GLubyte*)\"glStringMarkerGREMEDY\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_GREMEDY_string_marker */\n\n#ifdef GL_HP_convolution_border_modes\n\n#endif /* GL_HP_convolution_border_modes */\n\n#ifdef GL_HP_image_transform\n\nstatic GLboolean _glewInit_GL_HP_image_transform (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetImageTransformParameterfvHP = (PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC)glewGetProcAddress((const GLubyte*)\"glGetImageTransformParameterfvHP\")) == NULL) || r;\n  r = ((glGetImageTransformParameterivHP = (PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC)glewGetProcAddress((const GLubyte*)\"glGetImageTransformParameterivHP\")) == NULL) || r;\n  r = ((glImageTransformParameterfHP = (PFNGLIMAGETRANSFORMPARAMETERFHPPROC)glewGetProcAddress((const GLubyte*)\"glImageTransformParameterfHP\")) == NULL) || r;\n  r = ((glImageTransformParameterfvHP = (PFNGLIMAGETRANSFORMPARAMETERFVHPPROC)glewGetProcAddress((const GLubyte*)\"glImageTransformParameterfvHP\")) == NULL) || r;\n  r = ((glImageTransformParameteriHP = (PFNGLIMAGETRANSFORMPARAMETERIHPPROC)glewGetProcAddress((const GLubyte*)\"glImageTransformParameteriHP\")) == NULL) || r;\n  r = ((glImageTransformParameterivHP = (PFNGLIMAGETRANSFORMPARAMETERIVHPPROC)glewGetProcAddress((const GLubyte*)\"glImageTransformParameterivHP\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_HP_image_transform */\n\n#ifdef GL_HP_occlusion_test\n\n#endif /* GL_HP_occlusion_test */\n\n#ifdef GL_HP_texture_lighting\n\n#endif /* GL_HP_texture_lighting */\n\n#ifdef GL_IBM_cull_vertex\n\n#endif /* GL_IBM_cull_vertex */\n\n#ifdef GL_IBM_multimode_draw_arrays\n\nstatic GLboolean _glewInit_GL_IBM_multimode_draw_arrays (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glMultiModeDrawArraysIBM = (PFNGLMULTIMODEDRAWARRAYSIBMPROC)glewGetProcAddress((const GLubyte*)\"glMultiModeDrawArraysIBM\")) == NULL) || r;\n  r = ((glMultiModeDrawElementsIBM = (PFNGLMULTIMODEDRAWELEMENTSIBMPROC)glewGetProcAddress((const GLubyte*)\"glMultiModeDrawElementsIBM\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_IBM_multimode_draw_arrays */\n\n#ifdef GL_IBM_rasterpos_clip\n\n#endif /* GL_IBM_rasterpos_clip */\n\n#ifdef GL_IBM_static_data\n\n#endif /* GL_IBM_static_data */\n\n#ifdef GL_IBM_texture_mirrored_repeat\n\n#endif /* GL_IBM_texture_mirrored_repeat */\n\n#ifdef GL_IBM_vertex_array_lists\n\nstatic GLboolean _glewInit_GL_IBM_vertex_array_lists (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glColorPointerListIBM = (PFNGLCOLORPOINTERLISTIBMPROC)glewGetProcAddress((const GLubyte*)\"glColorPointerListIBM\")) == NULL) || r;\n  r = ((glEdgeFlagPointerListIBM = (PFNGLEDGEFLAGPOINTERLISTIBMPROC)glewGetProcAddress((const GLubyte*)\"glEdgeFlagPointerListIBM\")) == NULL) || r;\n  r = ((glFogCoordPointerListIBM = (PFNGLFOGCOORDPOINTERLISTIBMPROC)glewGetProcAddress((const GLubyte*)\"glFogCoordPointerListIBM\")) == NULL) || r;\n  r = ((glIndexPointerListIBM = (PFNGLINDEXPOINTERLISTIBMPROC)glewGetProcAddress((const GLubyte*)\"glIndexPointerListIBM\")) == NULL) || r;\n  r = ((glNormalPointerListIBM = (PFNGLNORMALPOINTERLISTIBMPROC)glewGetProcAddress((const GLubyte*)\"glNormalPointerListIBM\")) == NULL) || r;\n  r = ((glSecondaryColorPointerListIBM = (PFNGLSECONDARYCOLORPOINTERLISTIBMPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColorPointerListIBM\")) == NULL) || r;\n  r = ((glTexCoordPointerListIBM = (PFNGLTEXCOORDPOINTERLISTIBMPROC)glewGetProcAddress((const GLubyte*)\"glTexCoordPointerListIBM\")) == NULL) || r;\n  r = ((glVertexPointerListIBM = (PFNGLVERTEXPOINTERLISTIBMPROC)glewGetProcAddress((const GLubyte*)\"glVertexPointerListIBM\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_IBM_vertex_array_lists */\n\n#ifdef GL_INGR_color_clamp\n\n#endif /* GL_INGR_color_clamp */\n\n#ifdef GL_INGR_interlace_read\n\n#endif /* GL_INGR_interlace_read */\n\n#ifdef GL_INTEL_parallel_arrays\n\nstatic GLboolean _glewInit_GL_INTEL_parallel_arrays (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glColorPointervINTEL = (PFNGLCOLORPOINTERVINTELPROC)glewGetProcAddress((const GLubyte*)\"glColorPointervINTEL\")) == NULL) || r;\n  r = ((glNormalPointervINTEL = (PFNGLNORMALPOINTERVINTELPROC)glewGetProcAddress((const GLubyte*)\"glNormalPointervINTEL\")) == NULL) || r;\n  r = ((glTexCoordPointervINTEL = (PFNGLTEXCOORDPOINTERVINTELPROC)glewGetProcAddress((const GLubyte*)\"glTexCoordPointervINTEL\")) == NULL) || r;\n  r = ((glVertexPointervINTEL = (PFNGLVERTEXPOINTERVINTELPROC)glewGetProcAddress((const GLubyte*)\"glVertexPointervINTEL\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_INTEL_parallel_arrays */\n\n#ifdef GL_INTEL_texture_scissor\n\nstatic GLboolean _glewInit_GL_INTEL_texture_scissor (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glTexScissorFuncINTEL = (PFNGLTEXSCISSORFUNCINTELPROC)glewGetProcAddress((const GLubyte*)\"glTexScissorFuncINTEL\")) == NULL) || r;\n  r = ((glTexScissorINTEL = (PFNGLTEXSCISSORINTELPROC)glewGetProcAddress((const GLubyte*)\"glTexScissorINTEL\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_INTEL_texture_scissor */\n\n#ifdef GL_KTX_buffer_region\n\nstatic GLboolean _glewInit_GL_KTX_buffer_region (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBufferRegionEnabledEXT = (PFNGLBUFFERREGIONENABLEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glBufferRegionEnabledEXT\")) == NULL) || r;\n  r = ((glDeleteBufferRegionEXT = (PFNGLDELETEBUFFERREGIONEXTPROC)glewGetProcAddress((const GLubyte*)\"glDeleteBufferRegionEXT\")) == NULL) || r;\n  r = ((glDrawBufferRegionEXT = (PFNGLDRAWBUFFERREGIONEXTPROC)glewGetProcAddress((const GLubyte*)\"glDrawBufferRegionEXT\")) == NULL) || r;\n  r = ((glNewBufferRegionEXT = (PFNGLNEWBUFFERREGIONEXTPROC)glewGetProcAddress((const GLubyte*)\"glNewBufferRegionEXT\")) == NULL) || r;\n  r = ((glReadBufferRegionEXT = (PFNGLREADBUFFERREGIONEXTPROC)glewGetProcAddress((const GLubyte*)\"glReadBufferRegionEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_KTX_buffer_region */\n\n#ifdef GL_MESAX_texture_stack\n\n#endif /* GL_MESAX_texture_stack */\n\n#ifdef GL_MESA_pack_invert\n\n#endif /* GL_MESA_pack_invert */\n\n#ifdef GL_MESA_resize_buffers\n\nstatic GLboolean _glewInit_GL_MESA_resize_buffers (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glResizeBuffersMESA = (PFNGLRESIZEBUFFERSMESAPROC)glewGetProcAddress((const GLubyte*)\"glResizeBuffersMESA\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_MESA_resize_buffers */\n\n#ifdef GL_MESA_window_pos\n\nstatic GLboolean _glewInit_GL_MESA_window_pos (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glWindowPos2dMESA = (PFNGLWINDOWPOS2DMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2dMESA\")) == NULL) || r;\n  r = ((glWindowPos2dvMESA = (PFNGLWINDOWPOS2DVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2dvMESA\")) == NULL) || r;\n  r = ((glWindowPos2fMESA = (PFNGLWINDOWPOS2FMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2fMESA\")) == NULL) || r;\n  r = ((glWindowPos2fvMESA = (PFNGLWINDOWPOS2FVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2fvMESA\")) == NULL) || r;\n  r = ((glWindowPos2iMESA = (PFNGLWINDOWPOS2IMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2iMESA\")) == NULL) || r;\n  r = ((glWindowPos2ivMESA = (PFNGLWINDOWPOS2IVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2ivMESA\")) == NULL) || r;\n  r = ((glWindowPos2sMESA = (PFNGLWINDOWPOS2SMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2sMESA\")) == NULL) || r;\n  r = ((glWindowPos2svMESA = (PFNGLWINDOWPOS2SVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2svMESA\")) == NULL) || r;\n  r = ((glWindowPos3dMESA = (PFNGLWINDOWPOS3DMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3dMESA\")) == NULL) || r;\n  r = ((glWindowPos3dvMESA = (PFNGLWINDOWPOS3DVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3dvMESA\")) == NULL) || r;\n  r = ((glWindowPos3fMESA = (PFNGLWINDOWPOS3FMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3fMESA\")) == NULL) || r;\n  r = ((glWindowPos3fvMESA = (PFNGLWINDOWPOS3FVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3fvMESA\")) == NULL) || r;\n  r = ((glWindowPos3iMESA = (PFNGLWINDOWPOS3IMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3iMESA\")) == NULL) || r;\n  r = ((glWindowPos3ivMESA = (PFNGLWINDOWPOS3IVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3ivMESA\")) == NULL) || r;\n  r = ((glWindowPos3sMESA = (PFNGLWINDOWPOS3SMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3sMESA\")) == NULL) || r;\n  r = ((glWindowPos3svMESA = (PFNGLWINDOWPOS3SVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3svMESA\")) == NULL) || r;\n  r = ((glWindowPos4dMESA = (PFNGLWINDOWPOS4DMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos4dMESA\")) == NULL) || r;\n  r = ((glWindowPos4dvMESA = (PFNGLWINDOWPOS4DVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos4dvMESA\")) == NULL) || r;\n  r = ((glWindowPos4fMESA = (PFNGLWINDOWPOS4FMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos4fMESA\")) == NULL) || r;\n  r = ((glWindowPos4fvMESA = (PFNGLWINDOWPOS4FVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos4fvMESA\")) == NULL) || r;\n  r = ((glWindowPos4iMESA = (PFNGLWINDOWPOS4IMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos4iMESA\")) == NULL) || r;\n  r = ((glWindowPos4ivMESA = (PFNGLWINDOWPOS4IVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos4ivMESA\")) == NULL) || r;\n  r = ((glWindowPos4sMESA = (PFNGLWINDOWPOS4SMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos4sMESA\")) == NULL) || r;\n  r = ((glWindowPos4svMESA = (PFNGLWINDOWPOS4SVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos4svMESA\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_MESA_window_pos */\n\n#ifdef GL_MESA_ycbcr_texture\n\n#endif /* GL_MESA_ycbcr_texture */\n\n#ifdef GL_NV_blend_square\n\n#endif /* GL_NV_blend_square */\n\n#ifdef GL_NV_conditional_render\n\nstatic GLboolean _glewInit_GL_NV_conditional_render (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBeginConditionalRenderNV = (PFNGLBEGINCONDITIONALRENDERNVPROC)glewGetProcAddress((const GLubyte*)\"glBeginConditionalRenderNV\")) == NULL) || r;\n  r = ((glEndConditionalRenderNV = (PFNGLENDCONDITIONALRENDERNVPROC)glewGetProcAddress((const GLubyte*)\"glEndConditionalRenderNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_conditional_render */\n\n#ifdef GL_NV_copy_depth_to_color\n\n#endif /* GL_NV_copy_depth_to_color */\n\n#ifdef GL_NV_depth_buffer_float\n\nstatic GLboolean _glewInit_GL_NV_depth_buffer_float (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glClearDepthdNV = (PFNGLCLEARDEPTHDNVPROC)glewGetProcAddress((const GLubyte*)\"glClearDepthdNV\")) == NULL) || r;\n  r = ((glDepthBoundsdNV = (PFNGLDEPTHBOUNDSDNVPROC)glewGetProcAddress((const GLubyte*)\"glDepthBoundsdNV\")) == NULL) || r;\n  r = ((glDepthRangedNV = (PFNGLDEPTHRANGEDNVPROC)glewGetProcAddress((const GLubyte*)\"glDepthRangedNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_depth_buffer_float */\n\n#ifdef GL_NV_depth_clamp\n\n#endif /* GL_NV_depth_clamp */\n\n#ifdef GL_NV_depth_range_unclamped\n\n#endif /* GL_NV_depth_range_unclamped */\n\n#ifdef GL_NV_evaluators\n\nstatic GLboolean _glewInit_GL_NV_evaluators (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glEvalMapsNV = (PFNGLEVALMAPSNVPROC)glewGetProcAddress((const GLubyte*)\"glEvalMapsNV\")) == NULL) || r;\n  r = ((glGetMapAttribParameterfvNV = (PFNGLGETMAPATTRIBPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetMapAttribParameterfvNV\")) == NULL) || r;\n  r = ((glGetMapAttribParameterivNV = (PFNGLGETMAPATTRIBPARAMETERIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetMapAttribParameterivNV\")) == NULL) || r;\n  r = ((glGetMapControlPointsNV = (PFNGLGETMAPCONTROLPOINTSNVPROC)glewGetProcAddress((const GLubyte*)\"glGetMapControlPointsNV\")) == NULL) || r;\n  r = ((glGetMapParameterfvNV = (PFNGLGETMAPPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetMapParameterfvNV\")) == NULL) || r;\n  r = ((glGetMapParameterivNV = (PFNGLGETMAPPARAMETERIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetMapParameterivNV\")) == NULL) || r;\n  r = ((glMapControlPointsNV = (PFNGLMAPCONTROLPOINTSNVPROC)glewGetProcAddress((const GLubyte*)\"glMapControlPointsNV\")) == NULL) || r;\n  r = ((glMapParameterfvNV = (PFNGLMAPPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glMapParameterfvNV\")) == NULL) || r;\n  r = ((glMapParameterivNV = (PFNGLMAPPARAMETERIVNVPROC)glewGetProcAddress((const GLubyte*)\"glMapParameterivNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_evaluators */\n\n#ifdef GL_NV_explicit_multisample\n\nstatic GLboolean _glewInit_GL_NV_explicit_multisample (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetMultisamplefvNV = (PFNGLGETMULTISAMPLEFVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetMultisamplefvNV\")) == NULL) || r;\n  r = ((glSampleMaskIndexedNV = (PFNGLSAMPLEMASKINDEXEDNVPROC)glewGetProcAddress((const GLubyte*)\"glSampleMaskIndexedNV\")) == NULL) || r;\n  r = ((glTexRenderbufferNV = (PFNGLTEXRENDERBUFFERNVPROC)glewGetProcAddress((const GLubyte*)\"glTexRenderbufferNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_explicit_multisample */\n\n#ifdef GL_NV_fence\n\nstatic GLboolean _glewInit_GL_NV_fence (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDeleteFencesNV = (PFNGLDELETEFENCESNVPROC)glewGetProcAddress((const GLubyte*)\"glDeleteFencesNV\")) == NULL) || r;\n  r = ((glFinishFenceNV = (PFNGLFINISHFENCENVPROC)glewGetProcAddress((const GLubyte*)\"glFinishFenceNV\")) == NULL) || r;\n  r = ((glGenFencesNV = (PFNGLGENFENCESNVPROC)glewGetProcAddress((const GLubyte*)\"glGenFencesNV\")) == NULL) || r;\n  r = ((glGetFenceivNV = (PFNGLGETFENCEIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetFenceivNV\")) == NULL) || r;\n  r = ((glIsFenceNV = (PFNGLISFENCENVPROC)glewGetProcAddress((const GLubyte*)\"glIsFenceNV\")) == NULL) || r;\n  r = ((glSetFenceNV = (PFNGLSETFENCENVPROC)glewGetProcAddress((const GLubyte*)\"glSetFenceNV\")) == NULL) || r;\n  r = ((glTestFenceNV = (PFNGLTESTFENCENVPROC)glewGetProcAddress((const GLubyte*)\"glTestFenceNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_fence */\n\n#ifdef GL_NV_float_buffer\n\n#endif /* GL_NV_float_buffer */\n\n#ifdef GL_NV_fog_distance\n\n#endif /* GL_NV_fog_distance */\n\n#ifdef GL_NV_fragment_program\n\nstatic GLboolean _glewInit_GL_NV_fragment_program (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetProgramNamedParameterdvNV = (PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramNamedParameterdvNV\")) == NULL) || r;\n  r = ((glGetProgramNamedParameterfvNV = (PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramNamedParameterfvNV\")) == NULL) || r;\n  r = ((glProgramNamedParameter4dNV = (PFNGLPROGRAMNAMEDPARAMETER4DNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramNamedParameter4dNV\")) == NULL) || r;\n  r = ((glProgramNamedParameter4dvNV = (PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramNamedParameter4dvNV\")) == NULL) || r;\n  r = ((glProgramNamedParameter4fNV = (PFNGLPROGRAMNAMEDPARAMETER4FNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramNamedParameter4fNV\")) == NULL) || r;\n  r = ((glProgramNamedParameter4fvNV = (PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramNamedParameter4fvNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_fragment_program */\n\n#ifdef GL_NV_fragment_program2\n\n#endif /* GL_NV_fragment_program2 */\n\n#ifdef GL_NV_fragment_program4\n\n#endif /* GL_NV_fragment_program4 */\n\n#ifdef GL_NV_fragment_program_option\n\n#endif /* GL_NV_fragment_program_option */\n\n#ifdef GL_NV_framebuffer_multisample_coverage\n\nstatic GLboolean _glewInit_GL_NV_framebuffer_multisample_coverage (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glRenderbufferStorageMultisampleCoverageNV = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC)glewGetProcAddress((const GLubyte*)\"glRenderbufferStorageMultisampleCoverageNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_framebuffer_multisample_coverage */\n\n#ifdef GL_NV_geometry_program4\n\nstatic GLboolean _glewInit_GL_NV_geometry_program4 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glProgramVertexLimitNV = (PFNGLPROGRAMVERTEXLIMITNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramVertexLimitNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_geometry_program4 */\n\n#ifdef GL_NV_geometry_shader4\n\n#endif /* GL_NV_geometry_shader4 */\n\n#ifdef GL_NV_gpu_program4\n\nstatic GLboolean _glewInit_GL_NV_gpu_program4 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glProgramEnvParameterI4iNV = (PFNGLPROGRAMENVPARAMETERI4INVPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParameterI4iNV\")) == NULL) || r;\n  r = ((glProgramEnvParameterI4ivNV = (PFNGLPROGRAMENVPARAMETERI4IVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParameterI4ivNV\")) == NULL) || r;\n  r = ((glProgramEnvParameterI4uiNV = (PFNGLPROGRAMENVPARAMETERI4UINVPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParameterI4uiNV\")) == NULL) || r;\n  r = ((glProgramEnvParameterI4uivNV = (PFNGLPROGRAMENVPARAMETERI4UIVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParameterI4uivNV\")) == NULL) || r;\n  r = ((glProgramEnvParametersI4ivNV = (PFNGLPROGRAMENVPARAMETERSI4IVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParametersI4ivNV\")) == NULL) || r;\n  r = ((glProgramEnvParametersI4uivNV = (PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParametersI4uivNV\")) == NULL) || r;\n  r = ((glProgramLocalParameterI4iNV = (PFNGLPROGRAMLOCALPARAMETERI4INVPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParameterI4iNV\")) == NULL) || r;\n  r = ((glProgramLocalParameterI4ivNV = (PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParameterI4ivNV\")) == NULL) || r;\n  r = ((glProgramLocalParameterI4uiNV = (PFNGLPROGRAMLOCALPARAMETERI4UINVPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParameterI4uiNV\")) == NULL) || r;\n  r = ((glProgramLocalParameterI4uivNV = (PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParameterI4uivNV\")) == NULL) || r;\n  r = ((glProgramLocalParametersI4ivNV = (PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParametersI4ivNV\")) == NULL) || r;\n  r = ((glProgramLocalParametersI4uivNV = (PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParametersI4uivNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_gpu_program4 */\n\n#ifdef GL_NV_half_float\n\nstatic GLboolean _glewInit_GL_NV_half_float (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glColor3hNV = (PFNGLCOLOR3HNVPROC)glewGetProcAddress((const GLubyte*)\"glColor3hNV\")) == NULL) || r;\n  r = ((glColor3hvNV = (PFNGLCOLOR3HVNVPROC)glewGetProcAddress((const GLubyte*)\"glColor3hvNV\")) == NULL) || r;\n  r = ((glColor4hNV = (PFNGLCOLOR4HNVPROC)glewGetProcAddress((const GLubyte*)\"glColor4hNV\")) == NULL) || r;\n  r = ((glColor4hvNV = (PFNGLCOLOR4HVNVPROC)glewGetProcAddress((const GLubyte*)\"glColor4hvNV\")) == NULL) || r;\n  r = ((glFogCoordhNV = (PFNGLFOGCOORDHNVPROC)glewGetProcAddress((const GLubyte*)\"glFogCoordhNV\")) == NULL) || r;\n  r = ((glFogCoordhvNV = (PFNGLFOGCOORDHVNVPROC)glewGetProcAddress((const GLubyte*)\"glFogCoordhvNV\")) == NULL) || r;\n  r = ((glMultiTexCoord1hNV = (PFNGLMULTITEXCOORD1HNVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1hNV\")) == NULL) || r;\n  r = ((glMultiTexCoord1hvNV = (PFNGLMULTITEXCOORD1HVNVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1hvNV\")) == NULL) || r;\n  r = ((glMultiTexCoord2hNV = (PFNGLMULTITEXCOORD2HNVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2hNV\")) == NULL) || r;\n  r = ((glMultiTexCoord2hvNV = (PFNGLMULTITEXCOORD2HVNVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2hvNV\")) == NULL) || r;\n  r = ((glMultiTexCoord3hNV = (PFNGLMULTITEXCOORD3HNVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3hNV\")) == NULL) || r;\n  r = ((glMultiTexCoord3hvNV = (PFNGLMULTITEXCOORD3HVNVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3hvNV\")) == NULL) || r;\n  r = ((glMultiTexCoord4hNV = (PFNGLMULTITEXCOORD4HNVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4hNV\")) == NULL) || r;\n  r = ((glMultiTexCoord4hvNV = (PFNGLMULTITEXCOORD4HVNVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4hvNV\")) == NULL) || r;\n  r = ((glNormal3hNV = (PFNGLNORMAL3HNVPROC)glewGetProcAddress((const GLubyte*)\"glNormal3hNV\")) == NULL) || r;\n  r = ((glNormal3hvNV = (PFNGLNORMAL3HVNVPROC)glewGetProcAddress((const GLubyte*)\"glNormal3hvNV\")) == NULL) || r;\n  r = ((glSecondaryColor3hNV = (PFNGLSECONDARYCOLOR3HNVPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3hNV\")) == NULL) || r;\n  r = ((glSecondaryColor3hvNV = (PFNGLSECONDARYCOLOR3HVNVPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3hvNV\")) == NULL) || r;\n  r = ((glTexCoord1hNV = (PFNGLTEXCOORD1HNVPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord1hNV\")) == NULL) || r;\n  r = ((glTexCoord1hvNV = (PFNGLTEXCOORD1HVNVPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord1hvNV\")) == NULL) || r;\n  r = ((glTexCoord2hNV = (PFNGLTEXCOORD2HNVPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2hNV\")) == NULL) || r;\n  r = ((glTexCoord2hvNV = (PFNGLTEXCOORD2HVNVPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2hvNV\")) == NULL) || r;\n  r = ((glTexCoord3hNV = (PFNGLTEXCOORD3HNVPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord3hNV\")) == NULL) || r;\n  r = ((glTexCoord3hvNV = (PFNGLTEXCOORD3HVNVPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord3hvNV\")) == NULL) || r;\n  r = ((glTexCoord4hNV = (PFNGLTEXCOORD4HNVPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord4hNV\")) == NULL) || r;\n  r = ((glTexCoord4hvNV = (PFNGLTEXCOORD4HVNVPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord4hvNV\")) == NULL) || r;\n  r = ((glVertex2hNV = (PFNGLVERTEX2HNVPROC)glewGetProcAddress((const GLubyte*)\"glVertex2hNV\")) == NULL) || r;\n  r = ((glVertex2hvNV = (PFNGLVERTEX2HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertex2hvNV\")) == NULL) || r;\n  r = ((glVertex3hNV = (PFNGLVERTEX3HNVPROC)glewGetProcAddress((const GLubyte*)\"glVertex3hNV\")) == NULL) || r;\n  r = ((glVertex3hvNV = (PFNGLVERTEX3HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertex3hvNV\")) == NULL) || r;\n  r = ((glVertex4hNV = (PFNGLVERTEX4HNVPROC)glewGetProcAddress((const GLubyte*)\"glVertex4hNV\")) == NULL) || r;\n  r = ((glVertex4hvNV = (PFNGLVERTEX4HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertex4hvNV\")) == NULL) || r;\n  r = ((glVertexAttrib1hNV = (PFNGLVERTEXATTRIB1HNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1hNV\")) == NULL) || r;\n  r = ((glVertexAttrib1hvNV = (PFNGLVERTEXATTRIB1HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1hvNV\")) == NULL) || r;\n  r = ((glVertexAttrib2hNV = (PFNGLVERTEXATTRIB2HNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2hNV\")) == NULL) || r;\n  r = ((glVertexAttrib2hvNV = (PFNGLVERTEXATTRIB2HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2hvNV\")) == NULL) || r;\n  r = ((glVertexAttrib3hNV = (PFNGLVERTEXATTRIB3HNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3hNV\")) == NULL) || r;\n  r = ((glVertexAttrib3hvNV = (PFNGLVERTEXATTRIB3HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3hvNV\")) == NULL) || r;\n  r = ((glVertexAttrib4hNV = (PFNGLVERTEXATTRIB4HNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4hNV\")) == NULL) || r;\n  r = ((glVertexAttrib4hvNV = (PFNGLVERTEXATTRIB4HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4hvNV\")) == NULL) || r;\n  r = ((glVertexAttribs1hvNV = (PFNGLVERTEXATTRIBS1HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs1hvNV\")) == NULL) || r;\n  r = ((glVertexAttribs2hvNV = (PFNGLVERTEXATTRIBS2HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs2hvNV\")) == NULL) || r;\n  r = ((glVertexAttribs3hvNV = (PFNGLVERTEXATTRIBS3HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs3hvNV\")) == NULL) || r;\n  r = ((glVertexAttribs4hvNV = (PFNGLVERTEXATTRIBS4HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs4hvNV\")) == NULL) || r;\n  r = ((glVertexWeighthNV = (PFNGLVERTEXWEIGHTHNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexWeighthNV\")) == NULL) || r;\n  r = ((glVertexWeighthvNV = (PFNGLVERTEXWEIGHTHVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexWeighthvNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_half_float */\n\n#ifdef GL_NV_light_max_exponent\n\n#endif /* GL_NV_light_max_exponent */\n\n#ifdef GL_NV_multisample_filter_hint\n\n#endif /* GL_NV_multisample_filter_hint */\n\n#ifdef GL_NV_occlusion_query\n\nstatic GLboolean _glewInit_GL_NV_occlusion_query (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBeginOcclusionQueryNV = (PFNGLBEGINOCCLUSIONQUERYNVPROC)glewGetProcAddress((const GLubyte*)\"glBeginOcclusionQueryNV\")) == NULL) || r;\n  r = ((glDeleteOcclusionQueriesNV = (PFNGLDELETEOCCLUSIONQUERIESNVPROC)glewGetProcAddress((const GLubyte*)\"glDeleteOcclusionQueriesNV\")) == NULL) || r;\n  r = ((glEndOcclusionQueryNV = (PFNGLENDOCCLUSIONQUERYNVPROC)glewGetProcAddress((const GLubyte*)\"glEndOcclusionQueryNV\")) == NULL) || r;\n  r = ((glGenOcclusionQueriesNV = (PFNGLGENOCCLUSIONQUERIESNVPROC)glewGetProcAddress((const GLubyte*)\"glGenOcclusionQueriesNV\")) == NULL) || r;\n  r = ((glGetOcclusionQueryivNV = (PFNGLGETOCCLUSIONQUERYIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetOcclusionQueryivNV\")) == NULL) || r;\n  r = ((glGetOcclusionQueryuivNV = (PFNGLGETOCCLUSIONQUERYUIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetOcclusionQueryuivNV\")) == NULL) || r;\n  r = ((glIsOcclusionQueryNV = (PFNGLISOCCLUSIONQUERYNVPROC)glewGetProcAddress((const GLubyte*)\"glIsOcclusionQueryNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_occlusion_query */\n\n#ifdef GL_NV_packed_depth_stencil\n\n#endif /* GL_NV_packed_depth_stencil */\n\n#ifdef GL_NV_parameter_buffer_object\n\nstatic GLboolean _glewInit_GL_NV_parameter_buffer_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glProgramBufferParametersIivNV = (PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramBufferParametersIivNV\")) == NULL) || r;\n  r = ((glProgramBufferParametersIuivNV = (PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramBufferParametersIuivNV\")) == NULL) || r;\n  r = ((glProgramBufferParametersfvNV = (PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramBufferParametersfvNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_parameter_buffer_object */\n\n#ifdef GL_NV_pixel_data_range\n\nstatic GLboolean _glewInit_GL_NV_pixel_data_range (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFlushPixelDataRangeNV = (PFNGLFLUSHPIXELDATARANGENVPROC)glewGetProcAddress((const GLubyte*)\"glFlushPixelDataRangeNV\")) == NULL) || r;\n  r = ((glPixelDataRangeNV = (PFNGLPIXELDATARANGENVPROC)glewGetProcAddress((const GLubyte*)\"glPixelDataRangeNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_pixel_data_range */\n\n#ifdef GL_NV_point_sprite\n\nstatic GLboolean _glewInit_GL_NV_point_sprite (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glPointParameteriNV = (PFNGLPOINTPARAMETERINVPROC)glewGetProcAddress((const GLubyte*)\"glPointParameteriNV\")) == NULL) || r;\n  r = ((glPointParameterivNV = (PFNGLPOINTPARAMETERIVNVPROC)glewGetProcAddress((const GLubyte*)\"glPointParameterivNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_point_sprite */\n\n#ifdef GL_NV_present_video\n\nstatic GLboolean _glewInit_GL_NV_present_video (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetVideoi64vNV = (PFNGLGETVIDEOI64VNVPROC)glewGetProcAddress((const GLubyte*)\"glGetVideoi64vNV\")) == NULL) || r;\n  r = ((glGetVideoivNV = (PFNGLGETVIDEOIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetVideoivNV\")) == NULL) || r;\n  r = ((glGetVideoui64vNV = (PFNGLGETVIDEOUI64VNVPROC)glewGetProcAddress((const GLubyte*)\"glGetVideoui64vNV\")) == NULL) || r;\n  r = ((glGetVideouivNV = (PFNGLGETVIDEOUIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetVideouivNV\")) == NULL) || r;\n  r = ((glPresentFrameDualFillNV = (PFNGLPRESENTFRAMEDUALFILLNVPROC)glewGetProcAddress((const GLubyte*)\"glPresentFrameDualFillNV\")) == NULL) || r;\n  r = ((glPresentFrameKeyedNV = (PFNGLPRESENTFRAMEKEYEDNVPROC)glewGetProcAddress((const GLubyte*)\"glPresentFrameKeyedNV\")) == NULL) || r;\n  r = ((glVideoParameterivNV = (PFNGLVIDEOPARAMETERIVNVPROC)glewGetProcAddress((const GLubyte*)\"glVideoParameterivNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_present_video */\n\n#ifdef GL_NV_primitive_restart\n\nstatic GLboolean _glewInit_GL_NV_primitive_restart (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glPrimitiveRestartIndexNV = (PFNGLPRIMITIVERESTARTINDEXNVPROC)glewGetProcAddress((const GLubyte*)\"glPrimitiveRestartIndexNV\")) == NULL) || r;\n  r = ((glPrimitiveRestartNV = (PFNGLPRIMITIVERESTARTNVPROC)glewGetProcAddress((const GLubyte*)\"glPrimitiveRestartNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_primitive_restart */\n\n#ifdef GL_NV_register_combiners\n\nstatic GLboolean _glewInit_GL_NV_register_combiners (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glCombinerInputNV = (PFNGLCOMBINERINPUTNVPROC)glewGetProcAddress((const GLubyte*)\"glCombinerInputNV\")) == NULL) || r;\n  r = ((glCombinerOutputNV = (PFNGLCOMBINEROUTPUTNVPROC)glewGetProcAddress((const GLubyte*)\"glCombinerOutputNV\")) == NULL) || r;\n  r = ((glCombinerParameterfNV = (PFNGLCOMBINERPARAMETERFNVPROC)glewGetProcAddress((const GLubyte*)\"glCombinerParameterfNV\")) == NULL) || r;\n  r = ((glCombinerParameterfvNV = (PFNGLCOMBINERPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glCombinerParameterfvNV\")) == NULL) || r;\n  r = ((glCombinerParameteriNV = (PFNGLCOMBINERPARAMETERINVPROC)glewGetProcAddress((const GLubyte*)\"glCombinerParameteriNV\")) == NULL) || r;\n  r = ((glCombinerParameterivNV = (PFNGLCOMBINERPARAMETERIVNVPROC)glewGetProcAddress((const GLubyte*)\"glCombinerParameterivNV\")) == NULL) || r;\n  r = ((glFinalCombinerInputNV = (PFNGLFINALCOMBINERINPUTNVPROC)glewGetProcAddress((const GLubyte*)\"glFinalCombinerInputNV\")) == NULL) || r;\n  r = ((glGetCombinerInputParameterfvNV = (PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetCombinerInputParameterfvNV\")) == NULL) || r;\n  r = ((glGetCombinerInputParameterivNV = (PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetCombinerInputParameterivNV\")) == NULL) || r;\n  r = ((glGetCombinerOutputParameterfvNV = (PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetCombinerOutputParameterfvNV\")) == NULL) || r;\n  r = ((glGetCombinerOutputParameterivNV = (PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetCombinerOutputParameterivNV\")) == NULL) || r;\n  r = ((glGetFinalCombinerInputParameterfvNV = (PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetFinalCombinerInputParameterfvNV\")) == NULL) || r;\n  r = ((glGetFinalCombinerInputParameterivNV = (PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetFinalCombinerInputParameterivNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_register_combiners */\n\n#ifdef GL_NV_register_combiners2\n\nstatic GLboolean _glewInit_GL_NV_register_combiners2 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glCombinerStageParameterfvNV = (PFNGLCOMBINERSTAGEPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glCombinerStageParameterfvNV\")) == NULL) || r;\n  r = ((glGetCombinerStageParameterfvNV = (PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetCombinerStageParameterfvNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_register_combiners2 */\n\n#ifdef GL_NV_texgen_emboss\n\n#endif /* GL_NV_texgen_emboss */\n\n#ifdef GL_NV_texgen_reflection\n\n#endif /* GL_NV_texgen_reflection */\n\n#ifdef GL_NV_texture_compression_vtc\n\n#endif /* GL_NV_texture_compression_vtc */\n\n#ifdef GL_NV_texture_env_combine4\n\n#endif /* GL_NV_texture_env_combine4 */\n\n#ifdef GL_NV_texture_expand_normal\n\n#endif /* GL_NV_texture_expand_normal */\n\n#ifdef GL_NV_texture_rectangle\n\n#endif /* GL_NV_texture_rectangle */\n\n#ifdef GL_NV_texture_shader\n\n#endif /* GL_NV_texture_shader */\n\n#ifdef GL_NV_texture_shader2\n\n#endif /* GL_NV_texture_shader2 */\n\n#ifdef GL_NV_texture_shader3\n\n#endif /* GL_NV_texture_shader3 */\n\n#ifdef GL_NV_transform_feedback\n\nstatic GLboolean _glewInit_GL_NV_transform_feedback (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glActiveVaryingNV = (PFNGLACTIVEVARYINGNVPROC)glewGetProcAddress((const GLubyte*)\"glActiveVaryingNV\")) == NULL) || r;\n  r = ((glBeginTransformFeedbackNV = (PFNGLBEGINTRANSFORMFEEDBACKNVPROC)glewGetProcAddress((const GLubyte*)\"glBeginTransformFeedbackNV\")) == NULL) || r;\n  r = ((glBindBufferBaseNV = (PFNGLBINDBUFFERBASENVPROC)glewGetProcAddress((const GLubyte*)\"glBindBufferBaseNV\")) == NULL) || r;\n  r = ((glBindBufferOffsetNV = (PFNGLBINDBUFFEROFFSETNVPROC)glewGetProcAddress((const GLubyte*)\"glBindBufferOffsetNV\")) == NULL) || r;\n  r = ((glBindBufferRangeNV = (PFNGLBINDBUFFERRANGENVPROC)glewGetProcAddress((const GLubyte*)\"glBindBufferRangeNV\")) == NULL) || r;\n  r = ((glEndTransformFeedbackNV = (PFNGLENDTRANSFORMFEEDBACKNVPROC)glewGetProcAddress((const GLubyte*)\"glEndTransformFeedbackNV\")) == NULL) || r;\n  r = ((glGetActiveVaryingNV = (PFNGLGETACTIVEVARYINGNVPROC)glewGetProcAddress((const GLubyte*)\"glGetActiveVaryingNV\")) == NULL) || r;\n  r = ((glGetTransformFeedbackVaryingNV = (PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC)glewGetProcAddress((const GLubyte*)\"glGetTransformFeedbackVaryingNV\")) == NULL) || r;\n  r = ((glGetVaryingLocationNV = (PFNGLGETVARYINGLOCATIONNVPROC)glewGetProcAddress((const GLubyte*)\"glGetVaryingLocationNV\")) == NULL) || r;\n  r = ((glTransformFeedbackAttribsNV = (PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC)glewGetProcAddress((const GLubyte*)\"glTransformFeedbackAttribsNV\")) == NULL) || r;\n  r = ((glTransformFeedbackVaryingsNV = (PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC)glewGetProcAddress((const GLubyte*)\"glTransformFeedbackVaryingsNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_transform_feedback */\n\n#ifdef GL_NV_vertex_array_range\n\nstatic GLboolean _glewInit_GL_NV_vertex_array_range (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFlushVertexArrayRangeNV = (PFNGLFLUSHVERTEXARRAYRANGENVPROC)glewGetProcAddress((const GLubyte*)\"glFlushVertexArrayRangeNV\")) == NULL) || r;\n  r = ((glVertexArrayRangeNV = (PFNGLVERTEXARRAYRANGENVPROC)glewGetProcAddress((const GLubyte*)\"glVertexArrayRangeNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_vertex_array_range */\n\n#ifdef GL_NV_vertex_array_range2\n\n#endif /* GL_NV_vertex_array_range2 */\n\n#ifdef GL_NV_vertex_program\n\nstatic GLboolean _glewInit_GL_NV_vertex_program (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glAreProgramsResidentNV = (PFNGLAREPROGRAMSRESIDENTNVPROC)glewGetProcAddress((const GLubyte*)\"glAreProgramsResidentNV\")) == NULL) || r;\n  r = ((glBindProgramNV = (PFNGLBINDPROGRAMNVPROC)glewGetProcAddress((const GLubyte*)\"glBindProgramNV\")) == NULL) || r;\n  r = ((glDeleteProgramsNV = (PFNGLDELETEPROGRAMSNVPROC)glewGetProcAddress((const GLubyte*)\"glDeleteProgramsNV\")) == NULL) || r;\n  r = ((glExecuteProgramNV = (PFNGLEXECUTEPROGRAMNVPROC)glewGetProcAddress((const GLubyte*)\"glExecuteProgramNV\")) == NULL) || r;\n  r = ((glGenProgramsNV = (PFNGLGENPROGRAMSNVPROC)glewGetProcAddress((const GLubyte*)\"glGenProgramsNV\")) == NULL) || r;\n  r = ((glGetProgramParameterdvNV = (PFNGLGETPROGRAMPARAMETERDVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramParameterdvNV\")) == NULL) || r;\n  r = ((glGetProgramParameterfvNV = (PFNGLGETPROGRAMPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramParameterfvNV\")) == NULL) || r;\n  r = ((glGetProgramStringNV = (PFNGLGETPROGRAMSTRINGNVPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramStringNV\")) == NULL) || r;\n  r = ((glGetProgramivNV = (PFNGLGETPROGRAMIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramivNV\")) == NULL) || r;\n  r = ((glGetTrackMatrixivNV = (PFNGLGETTRACKMATRIXIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetTrackMatrixivNV\")) == NULL) || r;\n  r = ((glGetVertexAttribPointervNV = (PFNGLGETVERTEXATTRIBPOINTERVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribPointervNV\")) == NULL) || r;\n  r = ((glGetVertexAttribdvNV = (PFNGLGETVERTEXATTRIBDVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribdvNV\")) == NULL) || r;\n  r = ((glGetVertexAttribfvNV = (PFNGLGETVERTEXATTRIBFVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribfvNV\")) == NULL) || r;\n  r = ((glGetVertexAttribivNV = (PFNGLGETVERTEXATTRIBIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribivNV\")) == NULL) || r;\n  r = ((glIsProgramNV = (PFNGLISPROGRAMNVPROC)glewGetProcAddress((const GLubyte*)\"glIsProgramNV\")) == NULL) || r;\n  r = ((glLoadProgramNV = (PFNGLLOADPROGRAMNVPROC)glewGetProcAddress((const GLubyte*)\"glLoadProgramNV\")) == NULL) || r;\n  r = ((glProgramParameter4dNV = (PFNGLPROGRAMPARAMETER4DNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramParameter4dNV\")) == NULL) || r;\n  r = ((glProgramParameter4dvNV = (PFNGLPROGRAMPARAMETER4DVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramParameter4dvNV\")) == NULL) || r;\n  r = ((glProgramParameter4fNV = (PFNGLPROGRAMPARAMETER4FNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramParameter4fNV\")) == NULL) || r;\n  r = ((glProgramParameter4fvNV = (PFNGLPROGRAMPARAMETER4FVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramParameter4fvNV\")) == NULL) || r;\n  r = ((glProgramParameters4dvNV = (PFNGLPROGRAMPARAMETERS4DVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramParameters4dvNV\")) == NULL) || r;\n  r = ((glProgramParameters4fvNV = (PFNGLPROGRAMPARAMETERS4FVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramParameters4fvNV\")) == NULL) || r;\n  r = ((glRequestResidentProgramsNV = (PFNGLREQUESTRESIDENTPROGRAMSNVPROC)glewGetProcAddress((const GLubyte*)\"glRequestResidentProgramsNV\")) == NULL) || r;\n  r = ((glTrackMatrixNV = (PFNGLTRACKMATRIXNVPROC)glewGetProcAddress((const GLubyte*)\"glTrackMatrixNV\")) == NULL) || r;\n  r = ((glVertexAttrib1dNV = (PFNGLVERTEXATTRIB1DNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1dNV\")) == NULL) || r;\n  r = ((glVertexAttrib1dvNV = (PFNGLVERTEXATTRIB1DVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1dvNV\")) == NULL) || r;\n  r = ((glVertexAttrib1fNV = (PFNGLVERTEXATTRIB1FNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1fNV\")) == NULL) || r;\n  r = ((glVertexAttrib1fvNV = (PFNGLVERTEXATTRIB1FVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1fvNV\")) == NULL) || r;\n  r = ((glVertexAttrib1sNV = (PFNGLVERTEXATTRIB1SNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1sNV\")) == NULL) || r;\n  r = ((glVertexAttrib1svNV = (PFNGLVERTEXATTRIB1SVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1svNV\")) == NULL) || r;\n  r = ((glVertexAttrib2dNV = (PFNGLVERTEXATTRIB2DNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2dNV\")) == NULL) || r;\n  r = ((glVertexAttrib2dvNV = (PFNGLVERTEXATTRIB2DVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2dvNV\")) == NULL) || r;\n  r = ((glVertexAttrib2fNV = (PFNGLVERTEXATTRIB2FNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2fNV\")) == NULL) || r;\n  r = ((glVertexAttrib2fvNV = (PFNGLVERTEXATTRIB2FVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2fvNV\")) == NULL) || r;\n  r = ((glVertexAttrib2sNV = (PFNGLVERTEXATTRIB2SNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2sNV\")) == NULL) || r;\n  r = ((glVertexAttrib2svNV = (PFNGLVERTEXATTRIB2SVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2svNV\")) == NULL) || r;\n  r = ((glVertexAttrib3dNV = (PFNGLVERTEXATTRIB3DNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3dNV\")) == NULL) || r;\n  r = ((glVertexAttrib3dvNV = (PFNGLVERTEXATTRIB3DVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3dvNV\")) == NULL) || r;\n  r = ((glVertexAttrib3fNV = (PFNGLVERTEXATTRIB3FNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3fNV\")) == NULL) || r;\n  r = ((glVertexAttrib3fvNV = (PFNGLVERTEXATTRIB3FVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3fvNV\")) == NULL) || r;\n  r = ((glVertexAttrib3sNV = (PFNGLVERTEXATTRIB3SNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3sNV\")) == NULL) || r;\n  r = ((glVertexAttrib3svNV = (PFNGLVERTEXATTRIB3SVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3svNV\")) == NULL) || r;\n  r = ((glVertexAttrib4dNV = (PFNGLVERTEXATTRIB4DNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4dNV\")) == NULL) || r;\n  r = ((glVertexAttrib4dvNV = (PFNGLVERTEXATTRIB4DVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4dvNV\")) == NULL) || r;\n  r = ((glVertexAttrib4fNV = (PFNGLVERTEXATTRIB4FNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4fNV\")) == NULL) || r;\n  r = ((glVertexAttrib4fvNV = (PFNGLVERTEXATTRIB4FVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4fvNV\")) == NULL) || r;\n  r = ((glVertexAttrib4sNV = (PFNGLVERTEXATTRIB4SNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4sNV\")) == NULL) || r;\n  r = ((glVertexAttrib4svNV = (PFNGLVERTEXATTRIB4SVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4svNV\")) == NULL) || r;\n  r = ((glVertexAttrib4ubNV = (PFNGLVERTEXATTRIB4UBNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4ubNV\")) == NULL) || r;\n  r = ((glVertexAttrib4ubvNV = (PFNGLVERTEXATTRIB4UBVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4ubvNV\")) == NULL) || r;\n  r = ((glVertexAttribPointerNV = (PFNGLVERTEXATTRIBPOINTERNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribPointerNV\")) == NULL) || r;\n  r = ((glVertexAttribs1dvNV = (PFNGLVERTEXATTRIBS1DVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs1dvNV\")) == NULL) || r;\n  r = ((glVertexAttribs1fvNV = (PFNGLVERTEXATTRIBS1FVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs1fvNV\")) == NULL) || r;\n  r = ((glVertexAttribs1svNV = (PFNGLVERTEXATTRIBS1SVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs1svNV\")) == NULL) || r;\n  r = ((glVertexAttribs2dvNV = (PFNGLVERTEXATTRIBS2DVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs2dvNV\")) == NULL) || r;\n  r = ((glVertexAttribs2fvNV = (PFNGLVERTEXATTRIBS2FVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs2fvNV\")) == NULL) || r;\n  r = ((glVertexAttribs2svNV = (PFNGLVERTEXATTRIBS2SVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs2svNV\")) == NULL) || r;\n  r = ((glVertexAttribs3dvNV = (PFNGLVERTEXATTRIBS3DVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs3dvNV\")) == NULL) || r;\n  r = ((glVertexAttribs3fvNV = (PFNGLVERTEXATTRIBS3FVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs3fvNV\")) == NULL) || r;\n  r = ((glVertexAttribs3svNV = (PFNGLVERTEXATTRIBS3SVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs3svNV\")) == NULL) || r;\n  r = ((glVertexAttribs4dvNV = (PFNGLVERTEXATTRIBS4DVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs4dvNV\")) == NULL) || r;\n  r = ((glVertexAttribs4fvNV = (PFNGLVERTEXATTRIBS4FVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs4fvNV\")) == NULL) || r;\n  r = ((glVertexAttribs4svNV = (PFNGLVERTEXATTRIBS4SVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs4svNV\")) == NULL) || r;\n  r = ((glVertexAttribs4ubvNV = (PFNGLVERTEXATTRIBS4UBVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs4ubvNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_vertex_program */\n\n#ifdef GL_NV_vertex_program1_1\n\n#endif /* GL_NV_vertex_program1_1 */\n\n#ifdef GL_NV_vertex_program2\n\n#endif /* GL_NV_vertex_program2 */\n\n#ifdef GL_NV_vertex_program2_option\n\n#endif /* GL_NV_vertex_program2_option */\n\n#ifdef GL_NV_vertex_program3\n\n#endif /* GL_NV_vertex_program3 */\n\n#ifdef GL_NV_vertex_program4\n\n#endif /* GL_NV_vertex_program4 */\n\n#ifdef GL_OES_byte_coordinates\n\n#endif /* GL_OES_byte_coordinates */\n\n#ifdef GL_OES_compressed_paletted_texture\n\n#endif /* GL_OES_compressed_paletted_texture */\n\n#ifdef GL_OES_read_format\n\n#endif /* GL_OES_read_format */\n\n#ifdef GL_OES_single_precision\n\nstatic GLboolean _glewInit_GL_OES_single_precision (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glClearDepthfOES = (PFNGLCLEARDEPTHFOESPROC)glewGetProcAddress((const GLubyte*)\"glClearDepthfOES\")) == NULL) || r;\n  r = ((glClipPlanefOES = (PFNGLCLIPPLANEFOESPROC)glewGetProcAddress((const GLubyte*)\"glClipPlanefOES\")) == NULL) || r;\n  r = ((glDepthRangefOES = (PFNGLDEPTHRANGEFOESPROC)glewGetProcAddress((const GLubyte*)\"glDepthRangefOES\")) == NULL) || r;\n  r = ((glFrustumfOES = (PFNGLFRUSTUMFOESPROC)glewGetProcAddress((const GLubyte*)\"glFrustumfOES\")) == NULL) || r;\n  r = ((glGetClipPlanefOES = (PFNGLGETCLIPPLANEFOESPROC)glewGetProcAddress((const GLubyte*)\"glGetClipPlanefOES\")) == NULL) || r;\n  r = ((glOrthofOES = (PFNGLORTHOFOESPROC)glewGetProcAddress((const GLubyte*)\"glOrthofOES\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_OES_single_precision */\n\n#ifdef GL_OML_interlace\n\n#endif /* GL_OML_interlace */\n\n#ifdef GL_OML_resample\n\n#endif /* GL_OML_resample */\n\n#ifdef GL_OML_subsample\n\n#endif /* GL_OML_subsample */\n\n#ifdef GL_PGI_misc_hints\n\n#endif /* GL_PGI_misc_hints */\n\n#ifdef GL_PGI_vertex_hints\n\n#endif /* GL_PGI_vertex_hints */\n\n#ifdef GL_REND_screen_coordinates\n\n#endif /* GL_REND_screen_coordinates */\n\n#ifdef GL_S3_s3tc\n\n#endif /* GL_S3_s3tc */\n\n#ifdef GL_SGIS_color_range\n\n#endif /* GL_SGIS_color_range */\n\n#ifdef GL_SGIS_detail_texture\n\nstatic GLboolean _glewInit_GL_SGIS_detail_texture (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDetailTexFuncSGIS = (PFNGLDETAILTEXFUNCSGISPROC)glewGetProcAddress((const GLubyte*)\"glDetailTexFuncSGIS\")) == NULL) || r;\n  r = ((glGetDetailTexFuncSGIS = (PFNGLGETDETAILTEXFUNCSGISPROC)glewGetProcAddress((const GLubyte*)\"glGetDetailTexFuncSGIS\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIS_detail_texture */\n\n#ifdef GL_SGIS_fog_function\n\nstatic GLboolean _glewInit_GL_SGIS_fog_function (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFogFuncSGIS = (PFNGLFOGFUNCSGISPROC)glewGetProcAddress((const GLubyte*)\"glFogFuncSGIS\")) == NULL) || r;\n  r = ((glGetFogFuncSGIS = (PFNGLGETFOGFUNCSGISPROC)glewGetProcAddress((const GLubyte*)\"glGetFogFuncSGIS\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIS_fog_function */\n\n#ifdef GL_SGIS_generate_mipmap\n\n#endif /* GL_SGIS_generate_mipmap */\n\n#ifdef GL_SGIS_multisample\n\nstatic GLboolean _glewInit_GL_SGIS_multisample (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glSampleMaskSGIS = (PFNGLSAMPLEMASKSGISPROC)glewGetProcAddress((const GLubyte*)\"glSampleMaskSGIS\")) == NULL) || r;\n  r = ((glSamplePatternSGIS = (PFNGLSAMPLEPATTERNSGISPROC)glewGetProcAddress((const GLubyte*)\"glSamplePatternSGIS\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIS_multisample */\n\n#ifdef GL_SGIS_pixel_texture\n\n#endif /* GL_SGIS_pixel_texture */\n\n#ifdef GL_SGIS_point_line_texgen\n\n#endif /* GL_SGIS_point_line_texgen */\n\n#ifdef GL_SGIS_sharpen_texture\n\nstatic GLboolean _glewInit_GL_SGIS_sharpen_texture (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetSharpenTexFuncSGIS = (PFNGLGETSHARPENTEXFUNCSGISPROC)glewGetProcAddress((const GLubyte*)\"glGetSharpenTexFuncSGIS\")) == NULL) || r;\n  r = ((glSharpenTexFuncSGIS = (PFNGLSHARPENTEXFUNCSGISPROC)glewGetProcAddress((const GLubyte*)\"glSharpenTexFuncSGIS\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIS_sharpen_texture */\n\n#ifdef GL_SGIS_texture4D\n\nstatic GLboolean _glewInit_GL_SGIS_texture4D (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glTexImage4DSGIS = (PFNGLTEXIMAGE4DSGISPROC)glewGetProcAddress((const GLubyte*)\"glTexImage4DSGIS\")) == NULL) || r;\n  r = ((glTexSubImage4DSGIS = (PFNGLTEXSUBIMAGE4DSGISPROC)glewGetProcAddress((const GLubyte*)\"glTexSubImage4DSGIS\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIS_texture4D */\n\n#ifdef GL_SGIS_texture_border_clamp\n\n#endif /* GL_SGIS_texture_border_clamp */\n\n#ifdef GL_SGIS_texture_edge_clamp\n\n#endif /* GL_SGIS_texture_edge_clamp */\n\n#ifdef GL_SGIS_texture_filter4\n\nstatic GLboolean _glewInit_GL_SGIS_texture_filter4 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetTexFilterFuncSGIS = (PFNGLGETTEXFILTERFUNCSGISPROC)glewGetProcAddress((const GLubyte*)\"glGetTexFilterFuncSGIS\")) == NULL) || r;\n  r = ((glTexFilterFuncSGIS = (PFNGLTEXFILTERFUNCSGISPROC)glewGetProcAddress((const GLubyte*)\"glTexFilterFuncSGIS\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIS_texture_filter4 */\n\n#ifdef GL_SGIS_texture_lod\n\n#endif /* GL_SGIS_texture_lod */\n\n#ifdef GL_SGIS_texture_select\n\n#endif /* GL_SGIS_texture_select */\n\n#ifdef GL_SGIX_async\n\nstatic GLboolean _glewInit_GL_SGIX_async (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glAsyncMarkerSGIX = (PFNGLASYNCMARKERSGIXPROC)glewGetProcAddress((const GLubyte*)\"glAsyncMarkerSGIX\")) == NULL) || r;\n  r = ((glDeleteAsyncMarkersSGIX = (PFNGLDELETEASYNCMARKERSSGIXPROC)glewGetProcAddress((const GLubyte*)\"glDeleteAsyncMarkersSGIX\")) == NULL) || r;\n  r = ((glFinishAsyncSGIX = (PFNGLFINISHASYNCSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFinishAsyncSGIX\")) == NULL) || r;\n  r = ((glGenAsyncMarkersSGIX = (PFNGLGENASYNCMARKERSSGIXPROC)glewGetProcAddress((const GLubyte*)\"glGenAsyncMarkersSGIX\")) == NULL) || r;\n  r = ((glIsAsyncMarkerSGIX = (PFNGLISASYNCMARKERSGIXPROC)glewGetProcAddress((const GLubyte*)\"glIsAsyncMarkerSGIX\")) == NULL) || r;\n  r = ((glPollAsyncSGIX = (PFNGLPOLLASYNCSGIXPROC)glewGetProcAddress((const GLubyte*)\"glPollAsyncSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIX_async */\n\n#ifdef GL_SGIX_async_histogram\n\n#endif /* GL_SGIX_async_histogram */\n\n#ifdef GL_SGIX_async_pixel\n\n#endif /* GL_SGIX_async_pixel */\n\n#ifdef GL_SGIX_blend_alpha_minmax\n\n#endif /* GL_SGIX_blend_alpha_minmax */\n\n#ifdef GL_SGIX_clipmap\n\n#endif /* GL_SGIX_clipmap */\n\n#ifdef GL_SGIX_convolution_accuracy\n\n#endif /* GL_SGIX_convolution_accuracy */\n\n#ifdef GL_SGIX_depth_texture\n\n#endif /* GL_SGIX_depth_texture */\n\n#ifdef GL_SGIX_flush_raster\n\nstatic GLboolean _glewInit_GL_SGIX_flush_raster (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFlushRasterSGIX = (PFNGLFLUSHRASTERSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFlushRasterSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIX_flush_raster */\n\n#ifdef GL_SGIX_fog_offset\n\n#endif /* GL_SGIX_fog_offset */\n\n#ifdef GL_SGIX_fog_texture\n\nstatic GLboolean _glewInit_GL_SGIX_fog_texture (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glTextureFogSGIX = (PFNGLTEXTUREFOGSGIXPROC)glewGetProcAddress((const GLubyte*)\"glTextureFogSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIX_fog_texture */\n\n#ifdef GL_SGIX_fragment_specular_lighting\n\nstatic GLboolean _glewInit_GL_SGIX_fragment_specular_lighting (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFragmentColorMaterialSGIX = (PFNGLFRAGMENTCOLORMATERIALSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentColorMaterialSGIX\")) == NULL) || r;\n  r = ((glFragmentLightModelfSGIX = (PFNGLFRAGMENTLIGHTMODELFSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightModelfSGIX\")) == NULL) || r;\n  r = ((glFragmentLightModelfvSGIX = (PFNGLFRAGMENTLIGHTMODELFVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightModelfvSGIX\")) == NULL) || r;\n  r = ((glFragmentLightModeliSGIX = (PFNGLFRAGMENTLIGHTMODELISGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightModeliSGIX\")) == NULL) || r;\n  r = ((glFragmentLightModelivSGIX = (PFNGLFRAGMENTLIGHTMODELIVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightModelivSGIX\")) == NULL) || r;\n  r = ((glFragmentLightfSGIX = (PFNGLFRAGMENTLIGHTFSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightfSGIX\")) == NULL) || r;\n  r = ((glFragmentLightfvSGIX = (PFNGLFRAGMENTLIGHTFVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightfvSGIX\")) == NULL) || r;\n  r = ((glFragmentLightiSGIX = (PFNGLFRAGMENTLIGHTISGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightiSGIX\")) == NULL) || r;\n  r = ((glFragmentLightivSGIX = (PFNGLFRAGMENTLIGHTIVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightivSGIX\")) == NULL) || r;\n  r = ((glFragmentMaterialfSGIX = (PFNGLFRAGMENTMATERIALFSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentMaterialfSGIX\")) == NULL) || r;\n  r = ((glFragmentMaterialfvSGIX = (PFNGLFRAGMENTMATERIALFVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentMaterialfvSGIX\")) == NULL) || r;\n  r = ((glFragmentMaterialiSGIX = (PFNGLFRAGMENTMATERIALISGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentMaterialiSGIX\")) == NULL) || r;\n  r = ((glFragmentMaterialivSGIX = (PFNGLFRAGMENTMATERIALIVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentMaterialivSGIX\")) == NULL) || r;\n  r = ((glGetFragmentLightfvSGIX = (PFNGLGETFRAGMENTLIGHTFVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glGetFragmentLightfvSGIX\")) == NULL) || r;\n  r = ((glGetFragmentLightivSGIX = (PFNGLGETFRAGMENTLIGHTIVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glGetFragmentLightivSGIX\")) == NULL) || r;\n  r = ((glGetFragmentMaterialfvSGIX = (PFNGLGETFRAGMENTMATERIALFVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glGetFragmentMaterialfvSGIX\")) == NULL) || r;\n  r = ((glGetFragmentMaterialivSGIX = (PFNGLGETFRAGMENTMATERIALIVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glGetFragmentMaterialivSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIX_fragment_specular_lighting */\n\n#ifdef GL_SGIX_framezoom\n\nstatic GLboolean _glewInit_GL_SGIX_framezoom (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFrameZoomSGIX = (PFNGLFRAMEZOOMSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFrameZoomSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIX_framezoom */\n\n#ifdef GL_SGIX_interlace\n\n#endif /* GL_SGIX_interlace */\n\n#ifdef GL_SGIX_ir_instrument1\n\n#endif /* GL_SGIX_ir_instrument1 */\n\n#ifdef GL_SGIX_list_priority\n\n#endif /* GL_SGIX_list_priority */\n\n#ifdef GL_SGIX_pixel_texture\n\nstatic GLboolean _glewInit_GL_SGIX_pixel_texture (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glPixelTexGenSGIX = (PFNGLPIXELTEXGENSGIXPROC)glewGetProcAddress((const GLubyte*)\"glPixelTexGenSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIX_pixel_texture */\n\n#ifdef GL_SGIX_pixel_texture_bits\n\n#endif /* GL_SGIX_pixel_texture_bits */\n\n#ifdef GL_SGIX_reference_plane\n\nstatic GLboolean _glewInit_GL_SGIX_reference_plane (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glReferencePlaneSGIX = (PFNGLREFERENCEPLANESGIXPROC)glewGetProcAddress((const GLubyte*)\"glReferencePlaneSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIX_reference_plane */\n\n#ifdef GL_SGIX_resample\n\n#endif /* GL_SGIX_resample */\n\n#ifdef GL_SGIX_shadow\n\n#endif /* GL_SGIX_shadow */\n\n#ifdef GL_SGIX_shadow_ambient\n\n#endif /* GL_SGIX_shadow_ambient */\n\n#ifdef GL_SGIX_sprite\n\nstatic GLboolean _glewInit_GL_SGIX_sprite (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glSpriteParameterfSGIX = (PFNGLSPRITEPARAMETERFSGIXPROC)glewGetProcAddress((const GLubyte*)\"glSpriteParameterfSGIX\")) == NULL) || r;\n  r = ((glSpriteParameterfvSGIX = (PFNGLSPRITEPARAMETERFVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glSpriteParameterfvSGIX\")) == NULL) || r;\n  r = ((glSpriteParameteriSGIX = (PFNGLSPRITEPARAMETERISGIXPROC)glewGetProcAddress((const GLubyte*)\"glSpriteParameteriSGIX\")) == NULL) || r;\n  r = ((glSpriteParameterivSGIX = (PFNGLSPRITEPARAMETERIVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glSpriteParameterivSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIX_sprite */\n\n#ifdef GL_SGIX_tag_sample_buffer\n\nstatic GLboolean _glewInit_GL_SGIX_tag_sample_buffer (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glTagSampleBufferSGIX = (PFNGLTAGSAMPLEBUFFERSGIXPROC)glewGetProcAddress((const GLubyte*)\"glTagSampleBufferSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIX_tag_sample_buffer */\n\n#ifdef GL_SGIX_texture_add_env\n\n#endif /* GL_SGIX_texture_add_env */\n\n#ifdef GL_SGIX_texture_coordinate_clamp\n\n#endif /* GL_SGIX_texture_coordinate_clamp */\n\n#ifdef GL_SGIX_texture_lod_bias\n\n#endif /* GL_SGIX_texture_lod_bias */\n\n#ifdef GL_SGIX_texture_multi_buffer\n\n#endif /* GL_SGIX_texture_multi_buffer */\n\n#ifdef GL_SGIX_texture_range\n\n#endif /* GL_SGIX_texture_range */\n\n#ifdef GL_SGIX_texture_scale_bias\n\n#endif /* GL_SGIX_texture_scale_bias */\n\n#ifdef GL_SGIX_vertex_preclip\n\n#endif /* GL_SGIX_vertex_preclip */\n\n#ifdef GL_SGIX_vertex_preclip_hint\n\n#endif /* GL_SGIX_vertex_preclip_hint */\n\n#ifdef GL_SGIX_ycrcb\n\n#endif /* GL_SGIX_ycrcb */\n\n#ifdef GL_SGI_color_matrix\n\n#endif /* GL_SGI_color_matrix */\n\n#ifdef GL_SGI_color_table\n\nstatic GLboolean _glewInit_GL_SGI_color_table (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glColorTableParameterfvSGI = (PFNGLCOLORTABLEPARAMETERFVSGIPROC)glewGetProcAddress((const GLubyte*)\"glColorTableParameterfvSGI\")) == NULL) || r;\n  r = ((glColorTableParameterivSGI = (PFNGLCOLORTABLEPARAMETERIVSGIPROC)glewGetProcAddress((const GLubyte*)\"glColorTableParameterivSGI\")) == NULL) || r;\n  r = ((glColorTableSGI = (PFNGLCOLORTABLESGIPROC)glewGetProcAddress((const GLubyte*)\"glColorTableSGI\")) == NULL) || r;\n  r = ((glCopyColorTableSGI = (PFNGLCOPYCOLORTABLESGIPROC)glewGetProcAddress((const GLubyte*)\"glCopyColorTableSGI\")) == NULL) || r;\n  r = ((glGetColorTableParameterfvSGI = (PFNGLGETCOLORTABLEPARAMETERFVSGIPROC)glewGetProcAddress((const GLubyte*)\"glGetColorTableParameterfvSGI\")) == NULL) || r;\n  r = ((glGetColorTableParameterivSGI = (PFNGLGETCOLORTABLEPARAMETERIVSGIPROC)glewGetProcAddress((const GLubyte*)\"glGetColorTableParameterivSGI\")) == NULL) || r;\n  r = ((glGetColorTableSGI = (PFNGLGETCOLORTABLESGIPROC)glewGetProcAddress((const GLubyte*)\"glGetColorTableSGI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGI_color_table */\n\n#ifdef GL_SGI_texture_color_table\n\n#endif /* GL_SGI_texture_color_table */\n\n#ifdef GL_SUNX_constant_data\n\nstatic GLboolean _glewInit_GL_SUNX_constant_data (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFinishTextureSUNX = (PFNGLFINISHTEXTURESUNXPROC)glewGetProcAddress((const GLubyte*)\"glFinishTextureSUNX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SUNX_constant_data */\n\n#ifdef GL_SUN_convolution_border_modes\n\n#endif /* GL_SUN_convolution_border_modes */\n\n#ifdef GL_SUN_global_alpha\n\nstatic GLboolean _glewInit_GL_SUN_global_alpha (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGlobalAlphaFactorbSUN = (PFNGLGLOBALALPHAFACTORBSUNPROC)glewGetProcAddress((const GLubyte*)\"glGlobalAlphaFactorbSUN\")) == NULL) || r;\n  r = ((glGlobalAlphaFactordSUN = (PFNGLGLOBALALPHAFACTORDSUNPROC)glewGetProcAddress((const GLubyte*)\"glGlobalAlphaFactordSUN\")) == NULL) || r;\n  r = ((glGlobalAlphaFactorfSUN = (PFNGLGLOBALALPHAFACTORFSUNPROC)glewGetProcAddress((const GLubyte*)\"glGlobalAlphaFactorfSUN\")) == NULL) || r;\n  r = ((glGlobalAlphaFactoriSUN = (PFNGLGLOBALALPHAFACTORISUNPROC)glewGetProcAddress((const GLubyte*)\"glGlobalAlphaFactoriSUN\")) == NULL) || r;\n  r = ((glGlobalAlphaFactorsSUN = (PFNGLGLOBALALPHAFACTORSSUNPROC)glewGetProcAddress((const GLubyte*)\"glGlobalAlphaFactorsSUN\")) == NULL) || r;\n  r = ((glGlobalAlphaFactorubSUN = (PFNGLGLOBALALPHAFACTORUBSUNPROC)glewGetProcAddress((const GLubyte*)\"glGlobalAlphaFactorubSUN\")) == NULL) || r;\n  r = ((glGlobalAlphaFactoruiSUN = (PFNGLGLOBALALPHAFACTORUISUNPROC)glewGetProcAddress((const GLubyte*)\"glGlobalAlphaFactoruiSUN\")) == NULL) || r;\n  r = ((glGlobalAlphaFactorusSUN = (PFNGLGLOBALALPHAFACTORUSSUNPROC)glewGetProcAddress((const GLubyte*)\"glGlobalAlphaFactorusSUN\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SUN_global_alpha */\n\n#ifdef GL_SUN_mesh_array\n\n#endif /* GL_SUN_mesh_array */\n\n#ifdef GL_SUN_read_video_pixels\n\nstatic GLboolean _glewInit_GL_SUN_read_video_pixels (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glReadVideoPixelsSUN = (PFNGLREADVIDEOPIXELSSUNPROC)glewGetProcAddress((const GLubyte*)\"glReadVideoPixelsSUN\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SUN_read_video_pixels */\n\n#ifdef GL_SUN_slice_accum\n\n#endif /* GL_SUN_slice_accum */\n\n#ifdef GL_SUN_triangle_list\n\nstatic GLboolean _glewInit_GL_SUN_triangle_list (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glReplacementCodePointerSUN = (PFNGLREPLACEMENTCODEPOINTERSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodePointerSUN\")) == NULL) || r;\n  r = ((glReplacementCodeubSUN = (PFNGLREPLACEMENTCODEUBSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeubSUN\")) == NULL) || r;\n  r = ((glReplacementCodeubvSUN = (PFNGLREPLACEMENTCODEUBVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeubvSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiSUN = (PFNGLREPLACEMENTCODEUISUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuivSUN = (PFNGLREPLACEMENTCODEUIVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuivSUN\")) == NULL) || r;\n  r = ((glReplacementCodeusSUN = (PFNGLREPLACEMENTCODEUSSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeusSUN\")) == NULL) || r;\n  r = ((glReplacementCodeusvSUN = (PFNGLREPLACEMENTCODEUSVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeusvSUN\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SUN_triangle_list */\n\n#ifdef GL_SUN_vertex\n\nstatic GLboolean _glewInit_GL_SUN_vertex (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glColor3fVertex3fSUN = (PFNGLCOLOR3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glColor3fVertex3fSUN\")) == NULL) || r;\n  r = ((glColor3fVertex3fvSUN = (PFNGLCOLOR3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glColor3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glColor4fNormal3fVertex3fSUN = (PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glColor4fNormal3fVertex3fSUN\")) == NULL) || r;\n  r = ((glColor4fNormal3fVertex3fvSUN = (PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glColor4fNormal3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glColor4ubVertex2fSUN = (PFNGLCOLOR4UBVERTEX2FSUNPROC)glewGetProcAddress((const GLubyte*)\"glColor4ubVertex2fSUN\")) == NULL) || r;\n  r = ((glColor4ubVertex2fvSUN = (PFNGLCOLOR4UBVERTEX2FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glColor4ubVertex2fvSUN\")) == NULL) || r;\n  r = ((glColor4ubVertex3fSUN = (PFNGLCOLOR4UBVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glColor4ubVertex3fSUN\")) == NULL) || r;\n  r = ((glColor4ubVertex3fvSUN = (PFNGLCOLOR4UBVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glColor4ubVertex3fvSUN\")) == NULL) || r;\n  r = ((glNormal3fVertex3fSUN = (PFNGLNORMAL3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glNormal3fVertex3fSUN\")) == NULL) || r;\n  r = ((glNormal3fVertex3fvSUN = (PFNGLNORMAL3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glNormal3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiColor3fVertex3fSUN = (PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiColor3fVertex3fSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiColor3fVertex3fvSUN = (PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiColor3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiColor4fNormal3fVertex3fSUN = (PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiColor4fNormal3fVertex3fSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiColor4fNormal3fVertex3fvSUN = (PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiColor4fNormal3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiColor4ubVertex3fSUN = (PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiColor4ubVertex3fSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiColor4ubVertex3fvSUN = (PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiColor4ubVertex3fvSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiNormal3fVertex3fSUN = (PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiNormal3fVertex3fSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiNormal3fVertex3fvSUN = (PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiNormal3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = (PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = (PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = (PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = (PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiTexCoord2fVertex3fSUN = (PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiTexCoord2fVertex3fSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiTexCoord2fVertex3fvSUN = (PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiTexCoord2fVertex3fvSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiVertex3fSUN = (PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiVertex3fSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiVertex3fvSUN = (PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiVertex3fvSUN\")) == NULL) || r;\n  r = ((glTexCoord2fColor3fVertex3fSUN = (PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2fColor3fVertex3fSUN\")) == NULL) || r;\n  r = ((glTexCoord2fColor3fVertex3fvSUN = (PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2fColor3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glTexCoord2fColor4fNormal3fVertex3fSUN = (PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2fColor4fNormal3fVertex3fSUN\")) == NULL) || r;\n  r = ((glTexCoord2fColor4fNormal3fVertex3fvSUN = (PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2fColor4fNormal3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glTexCoord2fColor4ubVertex3fSUN = (PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2fColor4ubVertex3fSUN\")) == NULL) || r;\n  r = ((glTexCoord2fColor4ubVertex3fvSUN = (PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2fColor4ubVertex3fvSUN\")) == NULL) || r;\n  r = ((glTexCoord2fNormal3fVertex3fSUN = (PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2fNormal3fVertex3fSUN\")) == NULL) || r;\n  r = ((glTexCoord2fNormal3fVertex3fvSUN = (PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2fNormal3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glTexCoord2fVertex3fSUN = (PFNGLTEXCOORD2FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2fVertex3fSUN\")) == NULL) || r;\n  r = ((glTexCoord2fVertex3fvSUN = (PFNGLTEXCOORD2FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2fVertex3fvSUN\")) == NULL) || r;\n  r = ((glTexCoord4fColor4fNormal3fVertex4fSUN = (PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord4fColor4fNormal3fVertex4fSUN\")) == NULL) || r;\n  r = ((glTexCoord4fColor4fNormal3fVertex4fvSUN = (PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord4fColor4fNormal3fVertex4fvSUN\")) == NULL) || r;\n  r = ((glTexCoord4fVertex4fSUN = (PFNGLTEXCOORD4FVERTEX4FSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord4fVertex4fSUN\")) == NULL) || r;\n  r = ((glTexCoord4fVertex4fvSUN = (PFNGLTEXCOORD4FVERTEX4FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord4fVertex4fvSUN\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SUN_vertex */\n\n#ifdef GL_WIN_phong_shading\n\n#endif /* GL_WIN_phong_shading */\n\n#ifdef GL_WIN_specular_fog\n\n#endif /* GL_WIN_specular_fog */\n\n#ifdef GL_WIN_swap_hint\n\nstatic GLboolean _glewInit_GL_WIN_swap_hint (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glAddSwapHintRectWIN = (PFNGLADDSWAPHINTRECTWINPROC)glewGetProcAddress((const GLubyte*)\"glAddSwapHintRectWIN\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_WIN_swap_hint */\n\n/* ------------------------------------------------------------------------- */\n\n/*\n * Search for name in the extensions string. Use of strstr()\n * is not sufficient because extension names can be prefixes of\n * other extension names. Could use strtok() but the constant\n * string returned by glGetString might be in read-only memory.\n */\nGLboolean glewGetExtension (const char* name)\n{\n  GLubyte* p;\n  GLubyte* end;\n  GLuint len = _glewStrLen((const GLubyte*)name);\n  p = (GLubyte*)glGetString(GL_EXTENSIONS);\n  if (0 == p) return GL_FALSE;\n  end = p + _glewStrLen(p);\n  while (p < end)\n  {\n    GLuint n = _glewStrCLen(p, ' ');\n    if (len == n && _glewStrSame((const GLubyte*)name, p, n)) return GL_TRUE;\n    p += n+1;\n  }\n  return GL_FALSE;\n}\n\n/* ------------------------------------------------------------------------- */\n\n/*\n * MT 2010-12-22: Always export this symbol so that AGL can be used on mac\n * by calling this function instead of glewInit() wrapper -- which would also\n * invoke GLX init -- and fail for pure AGL programs.\n\n * #ifndef GLEW_MX\n * static\n * #endif\n*/\nGLenum glewContextInit (GLEW_CONTEXT_ARG_DEF_LIST)\n{\n  const GLubyte* s;\n   GLuint dot, major, minor;\n   /* query opengl version */\n   s = glGetString(GL_VERSION);\n   dot = _glewStrCLen(s, '.');\n   major = dot-1;\n   minor = dot+1;\n   if (dot == 0 || s[minor] == '\\0')\n   return GLEW_ERROR_NO_GL_VERSION;\n   if (s[major] == '1' && s[minor] == '0')\n   {\n      return GLEW_ERROR_GL_VERSION_10_ONLY;\n   }\n   else\n   {\n      CONST_CAST(GLEW_VERSION_1_1) = GL_TRUE;\n      if (s[major] >= '2')\n      {\n         CONST_CAST(GLEW_VERSION_1_2) = GL_TRUE;\n         CONST_CAST(GLEW_VERSION_1_3) = GL_TRUE;\n         CONST_CAST(GLEW_VERSION_1_4) = GL_TRUE;\n         CONST_CAST(GLEW_VERSION_1_5) = GL_TRUE;\n         CONST_CAST(GLEW_VERSION_2_0) = GL_TRUE;\n         if (s[minor] >= '1')\n         {\n            CONST_CAST(GLEW_VERSION_2_1) = GL_TRUE;\n         }\n      }\n      else\n      {\n         if (s[minor] >= '5')\n         {\n            CONST_CAST(GLEW_VERSION_1_2) = GL_TRUE;\n            CONST_CAST(GLEW_VERSION_1_3) = GL_TRUE;\n            CONST_CAST(GLEW_VERSION_1_4) = GL_TRUE;\n            CONST_CAST(GLEW_VERSION_1_5) = GL_TRUE;\n            CONST_CAST(GLEW_VERSION_2_0) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_2_1) = GL_FALSE;\n         }\n         if (s[minor] == '4')\n         {\n            CONST_CAST(GLEW_VERSION_1_2) = GL_TRUE;\n            CONST_CAST(GLEW_VERSION_1_3) = GL_TRUE;\n            CONST_CAST(GLEW_VERSION_1_4) = GL_TRUE;\n            CONST_CAST(GLEW_VERSION_1_5) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_2_0) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_2_1) = GL_FALSE;\n         }\n         if (s[minor] == '3')\n         {\n            CONST_CAST(GLEW_VERSION_1_2) = GL_TRUE;\n            CONST_CAST(GLEW_VERSION_1_3) = GL_TRUE;\n            CONST_CAST(GLEW_VERSION_1_4) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_1_5) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_2_0) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_2_1) = GL_FALSE;\n         }\n         if (s[minor] == '2')\n         {\n            CONST_CAST(GLEW_VERSION_1_2) = GL_TRUE;\n            CONST_CAST(GLEW_VERSION_1_3) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_1_4) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_1_5) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_2_0) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_2_1) = GL_FALSE;\n         }\n         if (s[minor] < '2')\n         {\n            CONST_CAST(GLEW_VERSION_1_2) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_1_3) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_1_4) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_1_5) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_2_0) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_2_1) = GL_FALSE;\n         }\n      }\n   }\n  /* initialize extensions */\n#ifdef GL_VERSION_1_2\n  if (glewExperimental || GLEW_VERSION_1_2) CONST_CAST(GLEW_VERSION_1_2) = !_glewInit_GL_VERSION_1_2(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_VERSION_1_2 */\n#ifdef GL_VERSION_1_3\n  if (glewExperimental || GLEW_VERSION_1_3) CONST_CAST(GLEW_VERSION_1_3) = !_glewInit_GL_VERSION_1_3(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_VERSION_1_3 */\n#ifdef GL_VERSION_1_4\n  if (glewExperimental || GLEW_VERSION_1_4) CONST_CAST(GLEW_VERSION_1_4) = !_glewInit_GL_VERSION_1_4(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_VERSION_1_4 */\n#ifdef GL_VERSION_1_5\n  if (glewExperimental || GLEW_VERSION_1_5) CONST_CAST(GLEW_VERSION_1_5) = !_glewInit_GL_VERSION_1_5(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_VERSION_1_5 */\n#ifdef GL_VERSION_2_0\n  if (glewExperimental || GLEW_VERSION_2_0) CONST_CAST(GLEW_VERSION_2_0) = !_glewInit_GL_VERSION_2_0(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_VERSION_2_0 */\n#ifdef GL_VERSION_2_1\n  if (glewExperimental || GLEW_VERSION_2_1) CONST_CAST(GLEW_VERSION_2_1) = !_glewInit_GL_VERSION_2_1(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_VERSION_2_1 */\n#ifdef GL_VERSION_3_0\n  if (glewExperimental || GLEW_VERSION_3_0) CONST_CAST(GLEW_VERSION_3_0) = !_glewInit_GL_VERSION_3_0(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_VERSION_3_0 */\n#ifdef GL_3DFX_multisample\n  CONST_CAST(GLEW_3DFX_multisample) = glewGetExtension(\"GL_3DFX_multisample\");\n#endif /* GL_3DFX_multisample */\n#ifdef GL_3DFX_tbuffer\n  CONST_CAST(GLEW_3DFX_tbuffer) = glewGetExtension(\"GL_3DFX_tbuffer\");\n  if (glewExperimental || GLEW_3DFX_tbuffer) CONST_CAST(GLEW_3DFX_tbuffer) = !_glewInit_GL_3DFX_tbuffer(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_3DFX_tbuffer */\n#ifdef GL_3DFX_texture_compression_FXT1\n  CONST_CAST(GLEW_3DFX_texture_compression_FXT1) = glewGetExtension(\"GL_3DFX_texture_compression_FXT1\");\n#endif /* GL_3DFX_texture_compression_FXT1 */\n#ifdef GL_APPLE_client_storage\n  CONST_CAST(GLEW_APPLE_client_storage) = glewGetExtension(\"GL_APPLE_client_storage\");\n#endif /* GL_APPLE_client_storage */\n#ifdef GL_APPLE_element_array\n  CONST_CAST(GLEW_APPLE_element_array) = glewGetExtension(\"GL_APPLE_element_array\");\n  if (glewExperimental || GLEW_APPLE_element_array) CONST_CAST(GLEW_APPLE_element_array) = !_glewInit_GL_APPLE_element_array(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_APPLE_element_array */\n#ifdef GL_APPLE_fence\n  CONST_CAST(GLEW_APPLE_fence) = glewGetExtension(\"GL_APPLE_fence\");\n  if (glewExperimental || GLEW_APPLE_fence) CONST_CAST(GLEW_APPLE_fence) = !_glewInit_GL_APPLE_fence(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_APPLE_fence */\n#ifdef GL_APPLE_float_pixels\n  CONST_CAST(GLEW_APPLE_float_pixels) = glewGetExtension(\"GL_APPLE_float_pixels\");\n#endif /* GL_APPLE_float_pixels */\n#ifdef GL_APPLE_flush_buffer_range\n  CONST_CAST(GLEW_APPLE_flush_buffer_range) = glewGetExtension(\"GL_APPLE_flush_buffer_range\");\n  if (glewExperimental || GLEW_APPLE_flush_buffer_range) CONST_CAST(GLEW_APPLE_flush_buffer_range) = !_glewInit_GL_APPLE_flush_buffer_range(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_APPLE_flush_buffer_range */\n#ifdef GL_APPLE_pixel_buffer\n  CONST_CAST(GLEW_APPLE_pixel_buffer) = glewGetExtension(\"GL_APPLE_pixel_buffer\");\n#endif /* GL_APPLE_pixel_buffer */\n#ifdef GL_APPLE_specular_vector\n  CONST_CAST(GLEW_APPLE_specular_vector) = glewGetExtension(\"GL_APPLE_specular_vector\");\n#endif /* GL_APPLE_specular_vector */\n#ifdef GL_APPLE_texture_range\n  CONST_CAST(GLEW_APPLE_texture_range) = glewGetExtension(\"GL_APPLE_texture_range\");\n  if (glewExperimental || GLEW_APPLE_texture_range) CONST_CAST(GLEW_APPLE_texture_range) = !_glewInit_GL_APPLE_texture_range(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_APPLE_texture_range */\n#ifdef GL_APPLE_transform_hint\n  CONST_CAST(GLEW_APPLE_transform_hint) = glewGetExtension(\"GL_APPLE_transform_hint\");\n#endif /* GL_APPLE_transform_hint */\n#ifdef GL_APPLE_vertex_array_object\n  CONST_CAST(GLEW_APPLE_vertex_array_object) = glewGetExtension(\"GL_APPLE_vertex_array_object\");\n  if (glewExperimental || GLEW_APPLE_vertex_array_object) CONST_CAST(GLEW_APPLE_vertex_array_object) = !_glewInit_GL_APPLE_vertex_array_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_APPLE_vertex_array_object */\n#ifdef GL_APPLE_vertex_array_range\n  CONST_CAST(GLEW_APPLE_vertex_array_range) = glewGetExtension(\"GL_APPLE_vertex_array_range\");\n  if (glewExperimental || GLEW_APPLE_vertex_array_range) CONST_CAST(GLEW_APPLE_vertex_array_range) = !_glewInit_GL_APPLE_vertex_array_range(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_APPLE_vertex_array_range */\n#ifdef GL_APPLE_ycbcr_422\n  CONST_CAST(GLEW_APPLE_ycbcr_422) = glewGetExtension(\"GL_APPLE_ycbcr_422\");\n#endif /* GL_APPLE_ycbcr_422 */\n#ifdef GL_ARB_color_buffer_float\n  CONST_CAST(GLEW_ARB_color_buffer_float) = glewGetExtension(\"GL_ARB_color_buffer_float\");\n  if (glewExperimental || GLEW_ARB_color_buffer_float) CONST_CAST(GLEW_ARB_color_buffer_float) = !_glewInit_GL_ARB_color_buffer_float(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_color_buffer_float */\n#ifdef GL_ARB_depth_buffer_float\n  CONST_CAST(GLEW_ARB_depth_buffer_float) = glewGetExtension(\"GL_ARB_depth_buffer_float\");\n#endif /* GL_ARB_depth_buffer_float */\n#ifdef GL_ARB_depth_texture\n  CONST_CAST(GLEW_ARB_depth_texture) = glewGetExtension(\"GL_ARB_depth_texture\");\n#endif /* GL_ARB_depth_texture */\n#ifdef GL_ARB_draw_buffers\n  CONST_CAST(GLEW_ARB_draw_buffers) = glewGetExtension(\"GL_ARB_draw_buffers\");\n  if (glewExperimental || GLEW_ARB_draw_buffers) CONST_CAST(GLEW_ARB_draw_buffers) = !_glewInit_GL_ARB_draw_buffers(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_draw_buffers */\n#ifdef GL_ARB_draw_instanced\n  CONST_CAST(GLEW_ARB_draw_instanced) = glewGetExtension(\"GL_ARB_draw_instanced\");\n  if (glewExperimental || GLEW_ARB_draw_instanced) CONST_CAST(GLEW_ARB_draw_instanced) = !_glewInit_GL_ARB_draw_instanced(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_draw_instanced */\n#ifdef GL_ARB_fragment_program\n  CONST_CAST(GLEW_ARB_fragment_program) = glewGetExtension(\"GL_ARB_fragment_program\");\n#endif /* GL_ARB_fragment_program */\n#ifdef GL_ARB_fragment_program_shadow\n  CONST_CAST(GLEW_ARB_fragment_program_shadow) = glewGetExtension(\"GL_ARB_fragment_program_shadow\");\n#endif /* GL_ARB_fragment_program_shadow */\n#ifdef GL_ARB_fragment_shader\n  CONST_CAST(GLEW_ARB_fragment_shader) = glewGetExtension(\"GL_ARB_fragment_shader\");\n#endif /* GL_ARB_fragment_shader */\n#ifdef GL_ARB_framebuffer_object\n  CONST_CAST(GLEW_ARB_framebuffer_object) = glewGetExtension(\"GL_ARB_framebuffer_object\");\n  if (glewExperimental || GLEW_ARB_framebuffer_object) CONST_CAST(GLEW_ARB_framebuffer_object) = !_glewInit_GL_ARB_framebuffer_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_framebuffer_object */\n#ifdef GL_ARB_framebuffer_sRGB\n  CONST_CAST(GLEW_ARB_framebuffer_sRGB) = glewGetExtension(\"GL_ARB_framebuffer_sRGB\");\n#endif /* GL_ARB_framebuffer_sRGB */\n#ifdef GL_ARB_geometry_shader4\n  CONST_CAST(GLEW_ARB_geometry_shader4) = glewGetExtension(\"GL_ARB_geometry_shader4\");\n  if (glewExperimental || GLEW_ARB_geometry_shader4) CONST_CAST(GLEW_ARB_geometry_shader4) = !_glewInit_GL_ARB_geometry_shader4(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_geometry_shader4 */\n#ifdef GL_ARB_half_float_pixel\n  CONST_CAST(GLEW_ARB_half_float_pixel) = glewGetExtension(\"GL_ARB_half_float_pixel\");\n#endif /* GL_ARB_half_float_pixel */\n#ifdef GL_ARB_half_float_vertex\n  CONST_CAST(GLEW_ARB_half_float_vertex) = glewGetExtension(\"GL_ARB_half_float_vertex\");\n#endif /* GL_ARB_half_float_vertex */\n#ifdef GL_ARB_imaging\n  CONST_CAST(GLEW_ARB_imaging) = glewGetExtension(\"GL_ARB_imaging\");\n  if (glewExperimental || GLEW_ARB_imaging) CONST_CAST(GLEW_ARB_imaging) = !_glewInit_GL_ARB_imaging(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_imaging */\n#ifdef GL_ARB_instanced_arrays\n  CONST_CAST(GLEW_ARB_instanced_arrays) = glewGetExtension(\"GL_ARB_instanced_arrays\");\n  if (glewExperimental || GLEW_ARB_instanced_arrays) CONST_CAST(GLEW_ARB_instanced_arrays) = !_glewInit_GL_ARB_instanced_arrays(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_instanced_arrays */\n#ifdef GL_ARB_map_buffer_range\n  CONST_CAST(GLEW_ARB_map_buffer_range) = glewGetExtension(\"GL_ARB_map_buffer_range\");\n  if (glewExperimental || GLEW_ARB_map_buffer_range) CONST_CAST(GLEW_ARB_map_buffer_range) = !_glewInit_GL_ARB_map_buffer_range(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_map_buffer_range */\n#ifdef GL_ARB_matrix_palette\n  CONST_CAST(GLEW_ARB_matrix_palette) = glewGetExtension(\"GL_ARB_matrix_palette\");\n  if (glewExperimental || GLEW_ARB_matrix_palette) CONST_CAST(GLEW_ARB_matrix_palette) = !_glewInit_GL_ARB_matrix_palette(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_matrix_palette */\n#ifdef GL_ARB_multisample\n  CONST_CAST(GLEW_ARB_multisample) = glewGetExtension(\"GL_ARB_multisample\");\n  if (glewExperimental || GLEW_ARB_multisample) CONST_CAST(GLEW_ARB_multisample) = !_glewInit_GL_ARB_multisample(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_multisample */\n#ifdef GL_ARB_multitexture\n  CONST_CAST(GLEW_ARB_multitexture) = glewGetExtension(\"GL_ARB_multitexture\");\n  if (glewExperimental || GLEW_ARB_multitexture) CONST_CAST(GLEW_ARB_multitexture) = !_glewInit_GL_ARB_multitexture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_multitexture */\n#ifdef GL_ARB_occlusion_query\n  CONST_CAST(GLEW_ARB_occlusion_query) = glewGetExtension(\"GL_ARB_occlusion_query\");\n  if (glewExperimental || GLEW_ARB_occlusion_query) CONST_CAST(GLEW_ARB_occlusion_query) = !_glewInit_GL_ARB_occlusion_query(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_occlusion_query */\n#ifdef GL_ARB_pixel_buffer_object\n  CONST_CAST(GLEW_ARB_pixel_buffer_object) = glewGetExtension(\"GL_ARB_pixel_buffer_object\");\n#endif /* GL_ARB_pixel_buffer_object */\n#ifdef GL_ARB_point_parameters\n  CONST_CAST(GLEW_ARB_point_parameters) = glewGetExtension(\"GL_ARB_point_parameters\");\n  if (glewExperimental || GLEW_ARB_point_parameters) CONST_CAST(GLEW_ARB_point_parameters) = !_glewInit_GL_ARB_point_parameters(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_point_parameters */\n#ifdef GL_ARB_point_sprite\n  CONST_CAST(GLEW_ARB_point_sprite) = glewGetExtension(\"GL_ARB_point_sprite\");\n#endif /* GL_ARB_point_sprite */\n#ifdef GL_ARB_shader_objects\n  CONST_CAST(GLEW_ARB_shader_objects) = glewGetExtension(\"GL_ARB_shader_objects\");\n  if (glewExperimental || GLEW_ARB_shader_objects) CONST_CAST(GLEW_ARB_shader_objects) = !_glewInit_GL_ARB_shader_objects(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_shader_objects */\n#ifdef GL_ARB_shading_language_100\n  CONST_CAST(GLEW_ARB_shading_language_100) = glewGetExtension(\"GL_ARB_shading_language_100\");\n#endif /* GL_ARB_shading_language_100 */\n#ifdef GL_ARB_shadow\n  CONST_CAST(GLEW_ARB_shadow) = glewGetExtension(\"GL_ARB_shadow\");\n#endif /* GL_ARB_shadow */\n#ifdef GL_ARB_shadow_ambient\n  CONST_CAST(GLEW_ARB_shadow_ambient) = glewGetExtension(\"GL_ARB_shadow_ambient\");\n#endif /* GL_ARB_shadow_ambient */\n#ifdef GL_ARB_texture_border_clamp\n  CONST_CAST(GLEW_ARB_texture_border_clamp) = glewGetExtension(\"GL_ARB_texture_border_clamp\");\n#endif /* GL_ARB_texture_border_clamp */\n#ifdef GL_ARB_texture_buffer_object\n  CONST_CAST(GLEW_ARB_texture_buffer_object) = glewGetExtension(\"GL_ARB_texture_buffer_object\");\n  if (glewExperimental || GLEW_ARB_texture_buffer_object) CONST_CAST(GLEW_ARB_texture_buffer_object) = !_glewInit_GL_ARB_texture_buffer_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_texture_buffer_object */\n#ifdef GL_ARB_texture_compression\n  CONST_CAST(GLEW_ARB_texture_compression) = glewGetExtension(\"GL_ARB_texture_compression\");\n  if (glewExperimental || GLEW_ARB_texture_compression) CONST_CAST(GLEW_ARB_texture_compression) = !_glewInit_GL_ARB_texture_compression(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_texture_compression */\n#ifdef GL_ARB_texture_compression_rgtc\n  CONST_CAST(GLEW_ARB_texture_compression_rgtc) = glewGetExtension(\"GL_ARB_texture_compression_rgtc\");\n#endif /* GL_ARB_texture_compression_rgtc */\n#ifdef GL_ARB_texture_cube_map\n  CONST_CAST(GLEW_ARB_texture_cube_map) = glewGetExtension(\"GL_ARB_texture_cube_map\");\n#endif /* GL_ARB_texture_cube_map */\n#ifdef GL_ARB_texture_env_add\n  CONST_CAST(GLEW_ARB_texture_env_add) = glewGetExtension(\"GL_ARB_texture_env_add\");\n#endif /* GL_ARB_texture_env_add */\n#ifdef GL_ARB_texture_env_combine\n  CONST_CAST(GLEW_ARB_texture_env_combine) = glewGetExtension(\"GL_ARB_texture_env_combine\");\n#endif /* GL_ARB_texture_env_combine */\n#ifdef GL_ARB_texture_env_crossbar\n  CONST_CAST(GLEW_ARB_texture_env_crossbar) = glewGetExtension(\"GL_ARB_texture_env_crossbar\");\n#endif /* GL_ARB_texture_env_crossbar */\n#ifdef GL_ARB_texture_env_dot3\n  CONST_CAST(GLEW_ARB_texture_env_dot3) = glewGetExtension(\"GL_ARB_texture_env_dot3\");\n#endif /* GL_ARB_texture_env_dot3 */\n#ifdef GL_ARB_texture_float\n  CONST_CAST(GLEW_ARB_texture_float) = glewGetExtension(\"GL_ARB_texture_float\");\n#endif /* GL_ARB_texture_float */\n#ifdef GL_ARB_texture_mirrored_repeat\n  CONST_CAST(GLEW_ARB_texture_mirrored_repeat) = glewGetExtension(\"GL_ARB_texture_mirrored_repeat\");\n#endif /* GL_ARB_texture_mirrored_repeat */\n#ifdef GL_ARB_texture_non_power_of_two\n  CONST_CAST(GLEW_ARB_texture_non_power_of_two) = glewGetExtension(\"GL_ARB_texture_non_power_of_two\");\n#endif /* GL_ARB_texture_non_power_of_two */\n#ifdef GL_ARB_texture_rectangle\n  CONST_CAST(GLEW_ARB_texture_rectangle) = glewGetExtension(\"GL_ARB_texture_rectangle\");\n#endif /* GL_ARB_texture_rectangle */\n#ifdef GL_ARB_texture_rg\n  CONST_CAST(GLEW_ARB_texture_rg) = glewGetExtension(\"GL_ARB_texture_rg\");\n#endif /* GL_ARB_texture_rg */\n#ifdef GL_ARB_transpose_matrix\n  CONST_CAST(GLEW_ARB_transpose_matrix) = glewGetExtension(\"GL_ARB_transpose_matrix\");\n  if (glewExperimental || GLEW_ARB_transpose_matrix) CONST_CAST(GLEW_ARB_transpose_matrix) = !_glewInit_GL_ARB_transpose_matrix(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_transpose_matrix */\n#ifdef GL_ARB_vertex_array_object\n  CONST_CAST(GLEW_ARB_vertex_array_object) = glewGetExtension(\"GL_ARB_vertex_array_object\");\n  if (glewExperimental || GLEW_ARB_vertex_array_object) CONST_CAST(GLEW_ARB_vertex_array_object) = !_glewInit_GL_ARB_vertex_array_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_vertex_array_object */\n#ifdef GL_ARB_vertex_blend\n  CONST_CAST(GLEW_ARB_vertex_blend) = glewGetExtension(\"GL_ARB_vertex_blend\");\n  if (glewExperimental || GLEW_ARB_vertex_blend) CONST_CAST(GLEW_ARB_vertex_blend) = !_glewInit_GL_ARB_vertex_blend(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_vertex_blend */\n#ifdef GL_ARB_vertex_buffer_object\n  CONST_CAST(GLEW_ARB_vertex_buffer_object) = glewGetExtension(\"GL_ARB_vertex_buffer_object\");\n  if (glewExperimental || GLEW_ARB_vertex_buffer_object) CONST_CAST(GLEW_ARB_vertex_buffer_object) = !_glewInit_GL_ARB_vertex_buffer_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_vertex_buffer_object */\n#ifdef GL_ARB_vertex_program\n  CONST_CAST(GLEW_ARB_vertex_program) = glewGetExtension(\"GL_ARB_vertex_program\");\n  if (glewExperimental || GLEW_ARB_vertex_program) CONST_CAST(GLEW_ARB_vertex_program) = !_glewInit_GL_ARB_vertex_program(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_vertex_program */\n#ifdef GL_ARB_vertex_shader\n  CONST_CAST(GLEW_ARB_vertex_shader) = glewGetExtension(\"GL_ARB_vertex_shader\");\n  if (glewExperimental || GLEW_ARB_vertex_shader) CONST_CAST(GLEW_ARB_vertex_shader) = !_glewInit_GL_ARB_vertex_shader(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_vertex_shader */\n#ifdef GL_ARB_window_pos\n  CONST_CAST(GLEW_ARB_window_pos) = glewGetExtension(\"GL_ARB_window_pos\");\n  if (glewExperimental || GLEW_ARB_window_pos) CONST_CAST(GLEW_ARB_window_pos) = !_glewInit_GL_ARB_window_pos(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_window_pos */\n#ifdef GL_ATIX_point_sprites\n  CONST_CAST(GLEW_ATIX_point_sprites) = glewGetExtension(\"GL_ATIX_point_sprites\");\n#endif /* GL_ATIX_point_sprites */\n#ifdef GL_ATIX_texture_env_combine3\n  CONST_CAST(GLEW_ATIX_texture_env_combine3) = glewGetExtension(\"GL_ATIX_texture_env_combine3\");\n#endif /* GL_ATIX_texture_env_combine3 */\n#ifdef GL_ATIX_texture_env_route\n  CONST_CAST(GLEW_ATIX_texture_env_route) = glewGetExtension(\"GL_ATIX_texture_env_route\");\n#endif /* GL_ATIX_texture_env_route */\n#ifdef GL_ATIX_vertex_shader_output_point_size\n  CONST_CAST(GLEW_ATIX_vertex_shader_output_point_size) = glewGetExtension(\"GL_ATIX_vertex_shader_output_point_size\");\n#endif /* GL_ATIX_vertex_shader_output_point_size */\n#ifdef GL_ATI_draw_buffers\n  CONST_CAST(GLEW_ATI_draw_buffers) = glewGetExtension(\"GL_ATI_draw_buffers\");\n  if (glewExperimental || GLEW_ATI_draw_buffers) CONST_CAST(GLEW_ATI_draw_buffers) = !_glewInit_GL_ATI_draw_buffers(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ATI_draw_buffers */\n#ifdef GL_ATI_element_array\n  CONST_CAST(GLEW_ATI_element_array) = glewGetExtension(\"GL_ATI_element_array\");\n  if (glewExperimental || GLEW_ATI_element_array) CONST_CAST(GLEW_ATI_element_array) = !_glewInit_GL_ATI_element_array(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ATI_element_array */\n#ifdef GL_ATI_envmap_bumpmap\n  CONST_CAST(GLEW_ATI_envmap_bumpmap) = glewGetExtension(\"GL_ATI_envmap_bumpmap\");\n  if (glewExperimental || GLEW_ATI_envmap_bumpmap) CONST_CAST(GLEW_ATI_envmap_bumpmap) = !_glewInit_GL_ATI_envmap_bumpmap(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ATI_envmap_bumpmap */\n#ifdef GL_ATI_fragment_shader\n  CONST_CAST(GLEW_ATI_fragment_shader) = glewGetExtension(\"GL_ATI_fragment_shader\");\n  if (glewExperimental || GLEW_ATI_fragment_shader) CONST_CAST(GLEW_ATI_fragment_shader) = !_glewInit_GL_ATI_fragment_shader(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ATI_fragment_shader */\n#ifdef GL_ATI_map_object_buffer\n  CONST_CAST(GLEW_ATI_map_object_buffer) = glewGetExtension(\"GL_ATI_map_object_buffer\");\n  if (glewExperimental || GLEW_ATI_map_object_buffer) CONST_CAST(GLEW_ATI_map_object_buffer) = !_glewInit_GL_ATI_map_object_buffer(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ATI_map_object_buffer */\n#ifdef GL_ATI_pn_triangles\n  CONST_CAST(GLEW_ATI_pn_triangles) = glewGetExtension(\"GL_ATI_pn_triangles\");\n  if (glewExperimental || GLEW_ATI_pn_triangles) CONST_CAST(GLEW_ATI_pn_triangles) = !_glewInit_GL_ATI_pn_triangles(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ATI_pn_triangles */\n#ifdef GL_ATI_separate_stencil\n  CONST_CAST(GLEW_ATI_separate_stencil) = glewGetExtension(\"GL_ATI_separate_stencil\");\n  if (glewExperimental || GLEW_ATI_separate_stencil) CONST_CAST(GLEW_ATI_separate_stencil) = !_glewInit_GL_ATI_separate_stencil(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ATI_separate_stencil */\n#ifdef GL_ATI_shader_texture_lod\n  CONST_CAST(GLEW_ATI_shader_texture_lod) = glewGetExtension(\"GL_ATI_shader_texture_lod\");\n#endif /* GL_ATI_shader_texture_lod */\n#ifdef GL_ATI_text_fragment_shader\n  CONST_CAST(GLEW_ATI_text_fragment_shader) = glewGetExtension(\"GL_ATI_text_fragment_shader\");\n#endif /* GL_ATI_text_fragment_shader */\n#ifdef GL_ATI_texture_compression_3dc\n  CONST_CAST(GLEW_ATI_texture_compression_3dc) = glewGetExtension(\"GL_ATI_texture_compression_3dc\");\n#endif /* GL_ATI_texture_compression_3dc */\n#ifdef GL_ATI_texture_env_combine3\n  CONST_CAST(GLEW_ATI_texture_env_combine3) = glewGetExtension(\"GL_ATI_texture_env_combine3\");\n#endif /* GL_ATI_texture_env_combine3 */\n#ifdef GL_ATI_texture_float\n  CONST_CAST(GLEW_ATI_texture_float) = glewGetExtension(\"GL_ATI_texture_float\");\n#endif /* GL_ATI_texture_float */\n#ifdef GL_ATI_texture_mirror_once\n  CONST_CAST(GLEW_ATI_texture_mirror_once) = glewGetExtension(\"GL_ATI_texture_mirror_once\");\n#endif /* GL_ATI_texture_mirror_once */\n#ifdef GL_ATI_vertex_array_object\n  CONST_CAST(GLEW_ATI_vertex_array_object) = glewGetExtension(\"GL_ATI_vertex_array_object\");\n  if (glewExperimental || GLEW_ATI_vertex_array_object) CONST_CAST(GLEW_ATI_vertex_array_object) = !_glewInit_GL_ATI_vertex_array_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ATI_vertex_array_object */\n#ifdef GL_ATI_vertex_attrib_array_object\n  CONST_CAST(GLEW_ATI_vertex_attrib_array_object) = glewGetExtension(\"GL_ATI_vertex_attrib_array_object\");\n  if (glewExperimental || GLEW_ATI_vertex_attrib_array_object) CONST_CAST(GLEW_ATI_vertex_attrib_array_object) = !_glewInit_GL_ATI_vertex_attrib_array_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ATI_vertex_attrib_array_object */\n#ifdef GL_ATI_vertex_streams\n  CONST_CAST(GLEW_ATI_vertex_streams) = glewGetExtension(\"GL_ATI_vertex_streams\");\n  if (glewExperimental || GLEW_ATI_vertex_streams) CONST_CAST(GLEW_ATI_vertex_streams) = !_glewInit_GL_ATI_vertex_streams(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ATI_vertex_streams */\n#ifdef GL_EXT_422_pixels\n  CONST_CAST(GLEW_EXT_422_pixels) = glewGetExtension(\"GL_EXT_422_pixels\");\n#endif /* GL_EXT_422_pixels */\n#ifdef GL_EXT_Cg_shader\n  CONST_CAST(GLEW_EXT_Cg_shader) = glewGetExtension(\"GL_EXT_Cg_shader\");\n#endif /* GL_EXT_Cg_shader */\n#ifdef GL_EXT_abgr\n  CONST_CAST(GLEW_EXT_abgr) = glewGetExtension(\"GL_EXT_abgr\");\n#endif /* GL_EXT_abgr */\n#ifdef GL_EXT_bgra\n  CONST_CAST(GLEW_EXT_bgra) = glewGetExtension(\"GL_EXT_bgra\");\n#endif /* GL_EXT_bgra */\n#ifdef GL_EXT_bindable_uniform\n  CONST_CAST(GLEW_EXT_bindable_uniform) = glewGetExtension(\"GL_EXT_bindable_uniform\");\n  if (glewExperimental || GLEW_EXT_bindable_uniform) CONST_CAST(GLEW_EXT_bindable_uniform) = !_glewInit_GL_EXT_bindable_uniform(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_bindable_uniform */\n#ifdef GL_EXT_blend_color\n  CONST_CAST(GLEW_EXT_blend_color) = glewGetExtension(\"GL_EXT_blend_color\");\n  if (glewExperimental || GLEW_EXT_blend_color) CONST_CAST(GLEW_EXT_blend_color) = !_glewInit_GL_EXT_blend_color(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_blend_color */\n#ifdef GL_EXT_blend_equation_separate\n  CONST_CAST(GLEW_EXT_blend_equation_separate) = glewGetExtension(\"GL_EXT_blend_equation_separate\");\n  if (glewExperimental || GLEW_EXT_blend_equation_separate) CONST_CAST(GLEW_EXT_blend_equation_separate) = !_glewInit_GL_EXT_blend_equation_separate(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_blend_equation_separate */\n#ifdef GL_EXT_blend_func_separate\n  CONST_CAST(GLEW_EXT_blend_func_separate) = glewGetExtension(\"GL_EXT_blend_func_separate\");\n  if (glewExperimental || GLEW_EXT_blend_func_separate) CONST_CAST(GLEW_EXT_blend_func_separate) = !_glewInit_GL_EXT_blend_func_separate(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_blend_func_separate */\n#ifdef GL_EXT_blend_logic_op\n  CONST_CAST(GLEW_EXT_blend_logic_op) = glewGetExtension(\"GL_EXT_blend_logic_op\");\n#endif /* GL_EXT_blend_logic_op */\n#ifdef GL_EXT_blend_minmax\n  CONST_CAST(GLEW_EXT_blend_minmax) = glewGetExtension(\"GL_EXT_blend_minmax\");\n  if (glewExperimental || GLEW_EXT_blend_minmax) CONST_CAST(GLEW_EXT_blend_minmax) = !_glewInit_GL_EXT_blend_minmax(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_blend_minmax */\n#ifdef GL_EXT_blend_subtract\n  CONST_CAST(GLEW_EXT_blend_subtract) = glewGetExtension(\"GL_EXT_blend_subtract\");\n#endif /* GL_EXT_blend_subtract */\n#ifdef GL_EXT_clip_volume_hint\n  CONST_CAST(GLEW_EXT_clip_volume_hint) = glewGetExtension(\"GL_EXT_clip_volume_hint\");\n#endif /* GL_EXT_clip_volume_hint */\n#ifdef GL_EXT_cmyka\n  CONST_CAST(GLEW_EXT_cmyka) = glewGetExtension(\"GL_EXT_cmyka\");\n#endif /* GL_EXT_cmyka */\n#ifdef GL_EXT_color_subtable\n  CONST_CAST(GLEW_EXT_color_subtable) = glewGetExtension(\"GL_EXT_color_subtable\");\n  if (glewExperimental || GLEW_EXT_color_subtable) CONST_CAST(GLEW_EXT_color_subtable) = !_glewInit_GL_EXT_color_subtable(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_color_subtable */\n#ifdef GL_EXT_compiled_vertex_array\n  CONST_CAST(GLEW_EXT_compiled_vertex_array) = glewGetExtension(\"GL_EXT_compiled_vertex_array\");\n  if (glewExperimental || GLEW_EXT_compiled_vertex_array) CONST_CAST(GLEW_EXT_compiled_vertex_array) = !_glewInit_GL_EXT_compiled_vertex_array(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_compiled_vertex_array */\n#ifdef GL_EXT_convolution\n  CONST_CAST(GLEW_EXT_convolution) = glewGetExtension(\"GL_EXT_convolution\");\n  if (glewExperimental || GLEW_EXT_convolution) CONST_CAST(GLEW_EXT_convolution) = !_glewInit_GL_EXT_convolution(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_convolution */\n#ifdef GL_EXT_coordinate_frame\n  CONST_CAST(GLEW_EXT_coordinate_frame) = glewGetExtension(\"GL_EXT_coordinate_frame\");\n  if (glewExperimental || GLEW_EXT_coordinate_frame) CONST_CAST(GLEW_EXT_coordinate_frame) = !_glewInit_GL_EXT_coordinate_frame(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_coordinate_frame */\n#ifdef GL_EXT_copy_texture\n  CONST_CAST(GLEW_EXT_copy_texture) = glewGetExtension(\"GL_EXT_copy_texture\");\n  if (glewExperimental || GLEW_EXT_copy_texture) CONST_CAST(GLEW_EXT_copy_texture) = !_glewInit_GL_EXT_copy_texture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_copy_texture */\n#ifdef GL_EXT_cull_vertex\n  CONST_CAST(GLEW_EXT_cull_vertex) = glewGetExtension(\"GL_EXT_cull_vertex\");\n  if (glewExperimental || GLEW_EXT_cull_vertex) CONST_CAST(GLEW_EXT_cull_vertex) = !_glewInit_GL_EXT_cull_vertex(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_cull_vertex */\n#ifdef GL_EXT_depth_bounds_test\n  CONST_CAST(GLEW_EXT_depth_bounds_test) = glewGetExtension(\"GL_EXT_depth_bounds_test\");\n  if (glewExperimental || GLEW_EXT_depth_bounds_test) CONST_CAST(GLEW_EXT_depth_bounds_test) = !_glewInit_GL_EXT_depth_bounds_test(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_depth_bounds_test */\n#ifdef GL_EXT_direct_state_access\n  CONST_CAST(GLEW_EXT_direct_state_access) = glewGetExtension(\"GL_EXT_direct_state_access\");\n  if (glewExperimental || GLEW_EXT_direct_state_access) CONST_CAST(GLEW_EXT_direct_state_access) = !_glewInit_GL_EXT_direct_state_access(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_direct_state_access */\n#ifdef GL_EXT_draw_buffers2\n  CONST_CAST(GLEW_EXT_draw_buffers2) = glewGetExtension(\"GL_EXT_draw_buffers2\");\n  if (glewExperimental || GLEW_EXT_draw_buffers2) CONST_CAST(GLEW_EXT_draw_buffers2) = !_glewInit_GL_EXT_draw_buffers2(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_draw_buffers2 */\n#ifdef GL_EXT_draw_instanced\n  CONST_CAST(GLEW_EXT_draw_instanced) = glewGetExtension(\"GL_EXT_draw_instanced\");\n  if (glewExperimental || GLEW_EXT_draw_instanced) CONST_CAST(GLEW_EXT_draw_instanced) = !_glewInit_GL_EXT_draw_instanced(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_draw_instanced */\n#ifdef GL_EXT_draw_range_elements\n  CONST_CAST(GLEW_EXT_draw_range_elements) = glewGetExtension(\"GL_EXT_draw_range_elements\");\n  if (glewExperimental || GLEW_EXT_draw_range_elements) CONST_CAST(GLEW_EXT_draw_range_elements) = !_glewInit_GL_EXT_draw_range_elements(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_draw_range_elements */\n#ifdef GL_EXT_fog_coord\n  CONST_CAST(GLEW_EXT_fog_coord) = glewGetExtension(\"GL_EXT_fog_coord\");\n  if (glewExperimental || GLEW_EXT_fog_coord) CONST_CAST(GLEW_EXT_fog_coord) = !_glewInit_GL_EXT_fog_coord(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_fog_coord */\n#ifdef GL_EXT_fragment_lighting\n  CONST_CAST(GLEW_EXT_fragment_lighting) = glewGetExtension(\"GL_EXT_fragment_lighting\");\n  if (glewExperimental || GLEW_EXT_fragment_lighting) CONST_CAST(GLEW_EXT_fragment_lighting) = !_glewInit_GL_EXT_fragment_lighting(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_fragment_lighting */\n#ifdef GL_EXT_framebuffer_blit\n  CONST_CAST(GLEW_EXT_framebuffer_blit) = glewGetExtension(\"GL_EXT_framebuffer_blit\");\n  if (glewExperimental || GLEW_EXT_framebuffer_blit) CONST_CAST(GLEW_EXT_framebuffer_blit) = !_glewInit_GL_EXT_framebuffer_blit(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_framebuffer_blit */\n#ifdef GL_EXT_framebuffer_multisample\n  CONST_CAST(GLEW_EXT_framebuffer_multisample) = glewGetExtension(\"GL_EXT_framebuffer_multisample\");\n  if (glewExperimental || GLEW_EXT_framebuffer_multisample) CONST_CAST(GLEW_EXT_framebuffer_multisample) = !_glewInit_GL_EXT_framebuffer_multisample(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_framebuffer_multisample */\n#ifdef GL_EXT_framebuffer_object\n  CONST_CAST(GLEW_EXT_framebuffer_object) = glewGetExtension(\"GL_EXT_framebuffer_object\");\n  if (glewExperimental || GLEW_EXT_framebuffer_object) CONST_CAST(GLEW_EXT_framebuffer_object) = !_glewInit_GL_EXT_framebuffer_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_framebuffer_object */\n#ifdef GL_EXT_framebuffer_sRGB\n  CONST_CAST(GLEW_EXT_framebuffer_sRGB) = glewGetExtension(\"GL_EXT_framebuffer_sRGB\");\n#endif /* GL_EXT_framebuffer_sRGB */\n#ifdef GL_EXT_geometry_shader4\n  CONST_CAST(GLEW_EXT_geometry_shader4) = glewGetExtension(\"GL_EXT_geometry_shader4\");\n  if (glewExperimental || GLEW_EXT_geometry_shader4) CONST_CAST(GLEW_EXT_geometry_shader4) = !_glewInit_GL_EXT_geometry_shader4(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_geometry_shader4 */\n#ifdef GL_EXT_gpu_program_parameters\n  CONST_CAST(GLEW_EXT_gpu_program_parameters) = glewGetExtension(\"GL_EXT_gpu_program_parameters\");\n  if (glewExperimental || GLEW_EXT_gpu_program_parameters) CONST_CAST(GLEW_EXT_gpu_program_parameters) = !_glewInit_GL_EXT_gpu_program_parameters(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_gpu_program_parameters */\n#ifdef GL_EXT_gpu_shader4\n  CONST_CAST(GLEW_EXT_gpu_shader4) = glewGetExtension(\"GL_EXT_gpu_shader4\");\n  if (glewExperimental || GLEW_EXT_gpu_shader4) CONST_CAST(GLEW_EXT_gpu_shader4) = !_glewInit_GL_EXT_gpu_shader4(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_gpu_shader4 */\n#ifdef GL_EXT_histogram\n  CONST_CAST(GLEW_EXT_histogram) = glewGetExtension(\"GL_EXT_histogram\");\n  if (glewExperimental || GLEW_EXT_histogram) CONST_CAST(GLEW_EXT_histogram) = !_glewInit_GL_EXT_histogram(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_histogram */\n#ifdef GL_EXT_index_array_formats\n  CONST_CAST(GLEW_EXT_index_array_formats) = glewGetExtension(\"GL_EXT_index_array_formats\");\n#endif /* GL_EXT_index_array_formats */\n#ifdef GL_EXT_index_func\n  CONST_CAST(GLEW_EXT_index_func) = glewGetExtension(\"GL_EXT_index_func\");\n  if (glewExperimental || GLEW_EXT_index_func) CONST_CAST(GLEW_EXT_index_func) = !_glewInit_GL_EXT_index_func(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_index_func */\n#ifdef GL_EXT_index_material\n  CONST_CAST(GLEW_EXT_index_material) = glewGetExtension(\"GL_EXT_index_material\");\n  if (glewExperimental || GLEW_EXT_index_material) CONST_CAST(GLEW_EXT_index_material) = !_glewInit_GL_EXT_index_material(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_index_material */\n#ifdef GL_EXT_index_texture\n  CONST_CAST(GLEW_EXT_index_texture) = glewGetExtension(\"GL_EXT_index_texture\");\n#endif /* GL_EXT_index_texture */\n#ifdef GL_EXT_light_texture\n  CONST_CAST(GLEW_EXT_light_texture) = glewGetExtension(\"GL_EXT_light_texture\");\n  if (glewExperimental || GLEW_EXT_light_texture) CONST_CAST(GLEW_EXT_light_texture) = !_glewInit_GL_EXT_light_texture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_light_texture */\n#ifdef GL_EXT_misc_attribute\n  CONST_CAST(GLEW_EXT_misc_attribute) = glewGetExtension(\"GL_EXT_misc_attribute\");\n#endif /* GL_EXT_misc_attribute */\n#ifdef GL_EXT_multi_draw_arrays\n  CONST_CAST(GLEW_EXT_multi_draw_arrays) = glewGetExtension(\"GL_EXT_multi_draw_arrays\");\n  if (glewExperimental || GLEW_EXT_multi_draw_arrays) CONST_CAST(GLEW_EXT_multi_draw_arrays) = !_glewInit_GL_EXT_multi_draw_arrays(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_multi_draw_arrays */\n#ifdef GL_EXT_multisample\n  CONST_CAST(GLEW_EXT_multisample) = glewGetExtension(\"GL_EXT_multisample\");\n  if (glewExperimental || GLEW_EXT_multisample) CONST_CAST(GLEW_EXT_multisample) = !_glewInit_GL_EXT_multisample(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_multisample */\n#ifdef GL_EXT_packed_depth_stencil\n  CONST_CAST(GLEW_EXT_packed_depth_stencil) = glewGetExtension(\"GL_EXT_packed_depth_stencil\");\n#endif /* GL_EXT_packed_depth_stencil */\n#ifdef GL_EXT_packed_float\n  CONST_CAST(GLEW_EXT_packed_float) = glewGetExtension(\"GL_EXT_packed_float\");\n#endif /* GL_EXT_packed_float */\n#ifdef GL_EXT_packed_pixels\n  CONST_CAST(GLEW_EXT_packed_pixels) = glewGetExtension(\"GL_EXT_packed_pixels\");\n#endif /* GL_EXT_packed_pixels */\n#ifdef GL_EXT_paletted_texture\n  CONST_CAST(GLEW_EXT_paletted_texture) = glewGetExtension(\"GL_EXT_paletted_texture\");\n  if (glewExperimental || GLEW_EXT_paletted_texture) CONST_CAST(GLEW_EXT_paletted_texture) = !_glewInit_GL_EXT_paletted_texture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_paletted_texture */\n#ifdef GL_EXT_pixel_buffer_object\n  CONST_CAST(GLEW_EXT_pixel_buffer_object) = glewGetExtension(\"GL_EXT_pixel_buffer_object\");\n#endif /* GL_EXT_pixel_buffer_object */\n#ifdef GL_EXT_pixel_transform\n  CONST_CAST(GLEW_EXT_pixel_transform) = glewGetExtension(\"GL_EXT_pixel_transform\");\n  if (glewExperimental || GLEW_EXT_pixel_transform) CONST_CAST(GLEW_EXT_pixel_transform) = !_glewInit_GL_EXT_pixel_transform(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_pixel_transform */\n#ifdef GL_EXT_pixel_transform_color_table\n  CONST_CAST(GLEW_EXT_pixel_transform_color_table) = glewGetExtension(\"GL_EXT_pixel_transform_color_table\");\n#endif /* GL_EXT_pixel_transform_color_table */\n#ifdef GL_EXT_point_parameters\n  CONST_CAST(GLEW_EXT_point_parameters) = glewGetExtension(\"GL_EXT_point_parameters\");\n  if (glewExperimental || GLEW_EXT_point_parameters) CONST_CAST(GLEW_EXT_point_parameters) = !_glewInit_GL_EXT_point_parameters(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_point_parameters */\n#ifdef GL_EXT_polygon_offset\n  CONST_CAST(GLEW_EXT_polygon_offset) = glewGetExtension(\"GL_EXT_polygon_offset\");\n  if (glewExperimental || GLEW_EXT_polygon_offset) CONST_CAST(GLEW_EXT_polygon_offset) = !_glewInit_GL_EXT_polygon_offset(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_polygon_offset */\n#ifdef GL_EXT_rescale_normal\n  CONST_CAST(GLEW_EXT_rescale_normal) = glewGetExtension(\"GL_EXT_rescale_normal\");\n#endif /* GL_EXT_rescale_normal */\n#ifdef GL_EXT_scene_marker\n  CONST_CAST(GLEW_EXT_scene_marker) = glewGetExtension(\"GL_EXT_scene_marker\");\n  if (glewExperimental || GLEW_EXT_scene_marker) CONST_CAST(GLEW_EXT_scene_marker) = !_glewInit_GL_EXT_scene_marker(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_scene_marker */\n#ifdef GL_EXT_secondary_color\n  CONST_CAST(GLEW_EXT_secondary_color) = glewGetExtension(\"GL_EXT_secondary_color\");\n  if (glewExperimental || GLEW_EXT_secondary_color) CONST_CAST(GLEW_EXT_secondary_color) = !_glewInit_GL_EXT_secondary_color(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_secondary_color */\n#ifdef GL_EXT_separate_specular_color\n  CONST_CAST(GLEW_EXT_separate_specular_color) = glewGetExtension(\"GL_EXT_separate_specular_color\");\n#endif /* GL_EXT_separate_specular_color */\n#ifdef GL_EXT_shadow_funcs\n  CONST_CAST(GLEW_EXT_shadow_funcs) = glewGetExtension(\"GL_EXT_shadow_funcs\");\n#endif /* GL_EXT_shadow_funcs */\n#ifdef GL_EXT_shared_texture_palette\n  CONST_CAST(GLEW_EXT_shared_texture_palette) = glewGetExtension(\"GL_EXT_shared_texture_palette\");\n#endif /* GL_EXT_shared_texture_palette */\n#ifdef GL_EXT_stencil_clear_tag\n  CONST_CAST(GLEW_EXT_stencil_clear_tag) = glewGetExtension(\"GL_EXT_stencil_clear_tag\");\n#endif /* GL_EXT_stencil_clear_tag */\n#ifdef GL_EXT_stencil_two_side\n  CONST_CAST(GLEW_EXT_stencil_two_side) = glewGetExtension(\"GL_EXT_stencil_two_side\");\n  if (glewExperimental || GLEW_EXT_stencil_two_side) CONST_CAST(GLEW_EXT_stencil_two_side) = !_glewInit_GL_EXT_stencil_two_side(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_stencil_two_side */\n#ifdef GL_EXT_stencil_wrap\n  CONST_CAST(GLEW_EXT_stencil_wrap) = glewGetExtension(\"GL_EXT_stencil_wrap\");\n#endif /* GL_EXT_stencil_wrap */\n#ifdef GL_EXT_subtexture\n  CONST_CAST(GLEW_EXT_subtexture) = glewGetExtension(\"GL_EXT_subtexture\");\n  if (glewExperimental || GLEW_EXT_subtexture) CONST_CAST(GLEW_EXT_subtexture) = !_glewInit_GL_EXT_subtexture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_subtexture */\n#ifdef GL_EXT_texture\n  CONST_CAST(GLEW_EXT_texture) = glewGetExtension(\"GL_EXT_texture\");\n#endif /* GL_EXT_texture */\n#ifdef GL_EXT_texture3D\n  CONST_CAST(GLEW_EXT_texture3D) = glewGetExtension(\"GL_EXT_texture3D\");\n  if (glewExperimental || GLEW_EXT_texture3D) CONST_CAST(GLEW_EXT_texture3D) = !_glewInit_GL_EXT_texture3D(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_texture3D */\n#ifdef GL_EXT_texture_array\n  CONST_CAST(GLEW_EXT_texture_array) = glewGetExtension(\"GL_EXT_texture_array\");\n#endif /* GL_EXT_texture_array */\n#ifdef GL_EXT_texture_buffer_object\n  CONST_CAST(GLEW_EXT_texture_buffer_object) = glewGetExtension(\"GL_EXT_texture_buffer_object\");\n  if (glewExperimental || GLEW_EXT_texture_buffer_object) CONST_CAST(GLEW_EXT_texture_buffer_object) = !_glewInit_GL_EXT_texture_buffer_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_texture_buffer_object */\n#ifdef GL_EXT_texture_compression_dxt1\n  CONST_CAST(GLEW_EXT_texture_compression_dxt1) = glewGetExtension(\"GL_EXT_texture_compression_dxt1\");\n#endif /* GL_EXT_texture_compression_dxt1 */\n#ifdef GL_EXT_texture_compression_latc\n  CONST_CAST(GLEW_EXT_texture_compression_latc) = glewGetExtension(\"GL_EXT_texture_compression_latc\");\n#endif /* GL_EXT_texture_compression_latc */\n#ifdef GL_EXT_texture_compression_rgtc\n  CONST_CAST(GLEW_EXT_texture_compression_rgtc) = glewGetExtension(\"GL_EXT_texture_compression_rgtc\");\n#endif /* GL_EXT_texture_compression_rgtc */\n#ifdef GL_EXT_texture_compression_s3tc\n  CONST_CAST(GLEW_EXT_texture_compression_s3tc) = glewGetExtension(\"GL_EXT_texture_compression_s3tc\");\n#endif /* GL_EXT_texture_compression_s3tc */\n#ifdef GL_EXT_texture_cube_map\n  CONST_CAST(GLEW_EXT_texture_cube_map) = glewGetExtension(\"GL_EXT_texture_cube_map\");\n#endif /* GL_EXT_texture_cube_map */\n#ifdef GL_EXT_texture_edge_clamp\n  CONST_CAST(GLEW_EXT_texture_edge_clamp) = glewGetExtension(\"GL_EXT_texture_edge_clamp\");\n#endif /* GL_EXT_texture_edge_clamp */\n#ifdef GL_EXT_texture_env\n  CONST_CAST(GLEW_EXT_texture_env) = glewGetExtension(\"GL_EXT_texture_env\");\n#endif /* GL_EXT_texture_env */\n#ifdef GL_EXT_texture_env_add\n  CONST_CAST(GLEW_EXT_texture_env_add) = glewGetExtension(\"GL_EXT_texture_env_add\");\n#endif /* GL_EXT_texture_env_add */\n#ifdef GL_EXT_texture_env_combine\n  CONST_CAST(GLEW_EXT_texture_env_combine) = glewGetExtension(\"GL_EXT_texture_env_combine\");\n#endif /* GL_EXT_texture_env_combine */\n#ifdef GL_EXT_texture_env_dot3\n  CONST_CAST(GLEW_EXT_texture_env_dot3) = glewGetExtension(\"GL_EXT_texture_env_dot3\");\n#endif /* GL_EXT_texture_env_dot3 */\n#ifdef GL_EXT_texture_filter_anisotropic\n  CONST_CAST(GLEW_EXT_texture_filter_anisotropic) = glewGetExtension(\"GL_EXT_texture_filter_anisotropic\");\n#endif /* GL_EXT_texture_filter_anisotropic */\n#ifdef GL_EXT_texture_integer\n  CONST_CAST(GLEW_EXT_texture_integer) = glewGetExtension(\"GL_EXT_texture_integer\");\n  if (glewExperimental || GLEW_EXT_texture_integer) CONST_CAST(GLEW_EXT_texture_integer) = !_glewInit_GL_EXT_texture_integer(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_texture_integer */\n#ifdef GL_EXT_texture_lod_bias\n  CONST_CAST(GLEW_EXT_texture_lod_bias) = glewGetExtension(\"GL_EXT_texture_lod_bias\");\n#endif /* GL_EXT_texture_lod_bias */\n#ifdef GL_EXT_texture_mirror_clamp\n  CONST_CAST(GLEW_EXT_texture_mirror_clamp) = glewGetExtension(\"GL_EXT_texture_mirror_clamp\");\n#endif /* GL_EXT_texture_mirror_clamp */\n#ifdef GL_EXT_texture_object\n  CONST_CAST(GLEW_EXT_texture_object) = glewGetExtension(\"GL_EXT_texture_object\");\n  if (glewExperimental || GLEW_EXT_texture_object) CONST_CAST(GLEW_EXT_texture_object) = !_glewInit_GL_EXT_texture_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_texture_object */\n#ifdef GL_EXT_texture_perturb_normal\n  CONST_CAST(GLEW_EXT_texture_perturb_normal) = glewGetExtension(\"GL_EXT_texture_perturb_normal\");\n  if (glewExperimental || GLEW_EXT_texture_perturb_normal) CONST_CAST(GLEW_EXT_texture_perturb_normal) = !_glewInit_GL_EXT_texture_perturb_normal(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_texture_perturb_normal */\n#ifdef GL_EXT_texture_rectangle\n  CONST_CAST(GLEW_EXT_texture_rectangle) = glewGetExtension(\"GL_EXT_texture_rectangle\");\n#endif /* GL_EXT_texture_rectangle */\n#ifdef GL_EXT_texture_sRGB\n  CONST_CAST(GLEW_EXT_texture_sRGB) = glewGetExtension(\"GL_EXT_texture_sRGB\");\n#endif /* GL_EXT_texture_sRGB */\n#ifdef GL_EXT_texture_shared_exponent\n  CONST_CAST(GLEW_EXT_texture_shared_exponent) = glewGetExtension(\"GL_EXT_texture_shared_exponent\");\n#endif /* GL_EXT_texture_shared_exponent */\n#ifdef GL_EXT_texture_swizzle\n  CONST_CAST(GLEW_EXT_texture_swizzle) = glewGetExtension(\"GL_EXT_texture_swizzle\");\n#endif /* GL_EXT_texture_swizzle */\n#ifdef GL_EXT_timer_query\n  CONST_CAST(GLEW_EXT_timer_query) = glewGetExtension(\"GL_EXT_timer_query\");\n  if (glewExperimental || GLEW_EXT_timer_query) CONST_CAST(GLEW_EXT_timer_query) = !_glewInit_GL_EXT_timer_query(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_timer_query */\n#ifdef GL_EXT_transform_feedback\n  CONST_CAST(GLEW_EXT_transform_feedback) = glewGetExtension(\"GL_EXT_transform_feedback\");\n  if (glewExperimental || GLEW_EXT_transform_feedback) CONST_CAST(GLEW_EXT_transform_feedback) = !_glewInit_GL_EXT_transform_feedback(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_transform_feedback */\n#ifdef GL_EXT_vertex_array\n  CONST_CAST(GLEW_EXT_vertex_array) = glewGetExtension(\"GL_EXT_vertex_array\");\n  if (glewExperimental || GLEW_EXT_vertex_array) CONST_CAST(GLEW_EXT_vertex_array) = !_glewInit_GL_EXT_vertex_array(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_vertex_array */\n#ifdef GL_EXT_vertex_array_bgra\n  CONST_CAST(GLEW_EXT_vertex_array_bgra) = glewGetExtension(\"GL_EXT_vertex_array_bgra\");\n#endif /* GL_EXT_vertex_array_bgra */\n#ifdef GL_EXT_vertex_shader\n  CONST_CAST(GLEW_EXT_vertex_shader) = glewGetExtension(\"GL_EXT_vertex_shader\");\n  if (glewExperimental || GLEW_EXT_vertex_shader) CONST_CAST(GLEW_EXT_vertex_shader) = !_glewInit_GL_EXT_vertex_shader(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_vertex_shader */\n#ifdef GL_EXT_vertex_weighting\n  CONST_CAST(GLEW_EXT_vertex_weighting) = glewGetExtension(\"GL_EXT_vertex_weighting\");\n  if (glewExperimental || GLEW_EXT_vertex_weighting) CONST_CAST(GLEW_EXT_vertex_weighting) = !_glewInit_GL_EXT_vertex_weighting(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_vertex_weighting */\n#ifdef GL_GREMEDY_frame_terminator\n  CONST_CAST(GLEW_GREMEDY_frame_terminator) = glewGetExtension(\"GL_GREMEDY_frame_terminator\");\n  if (glewExperimental || GLEW_GREMEDY_frame_terminator) CONST_CAST(GLEW_GREMEDY_frame_terminator) = !_glewInit_GL_GREMEDY_frame_terminator(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_GREMEDY_frame_terminator */\n#ifdef GL_GREMEDY_string_marker\n  CONST_CAST(GLEW_GREMEDY_string_marker) = glewGetExtension(\"GL_GREMEDY_string_marker\");\n  if (glewExperimental || GLEW_GREMEDY_string_marker) CONST_CAST(GLEW_GREMEDY_string_marker) = !_glewInit_GL_GREMEDY_string_marker(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_GREMEDY_string_marker */\n#ifdef GL_HP_convolution_border_modes\n  CONST_CAST(GLEW_HP_convolution_border_modes) = glewGetExtension(\"GL_HP_convolution_border_modes\");\n#endif /* GL_HP_convolution_border_modes */\n#ifdef GL_HP_image_transform\n  CONST_CAST(GLEW_HP_image_transform) = glewGetExtension(\"GL_HP_image_transform\");\n  if (glewExperimental || GLEW_HP_image_transform) CONST_CAST(GLEW_HP_image_transform) = !_glewInit_GL_HP_image_transform(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_HP_image_transform */\n#ifdef GL_HP_occlusion_test\n  CONST_CAST(GLEW_HP_occlusion_test) = glewGetExtension(\"GL_HP_occlusion_test\");\n#endif /* GL_HP_occlusion_test */\n#ifdef GL_HP_texture_lighting\n  CONST_CAST(GLEW_HP_texture_lighting) = glewGetExtension(\"GL_HP_texture_lighting\");\n#endif /* GL_HP_texture_lighting */\n#ifdef GL_IBM_cull_vertex\n  CONST_CAST(GLEW_IBM_cull_vertex) = glewGetExtension(\"GL_IBM_cull_vertex\");\n#endif /* GL_IBM_cull_vertex */\n#ifdef GL_IBM_multimode_draw_arrays\n  CONST_CAST(GLEW_IBM_multimode_draw_arrays) = glewGetExtension(\"GL_IBM_multimode_draw_arrays\");\n  if (glewExperimental || GLEW_IBM_multimode_draw_arrays) CONST_CAST(GLEW_IBM_multimode_draw_arrays) = !_glewInit_GL_IBM_multimode_draw_arrays(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_IBM_multimode_draw_arrays */\n#ifdef GL_IBM_rasterpos_clip\n  CONST_CAST(GLEW_IBM_rasterpos_clip) = glewGetExtension(\"GL_IBM_rasterpos_clip\");\n#endif /* GL_IBM_rasterpos_clip */\n#ifdef GL_IBM_static_data\n  CONST_CAST(GLEW_IBM_static_data) = glewGetExtension(\"GL_IBM_static_data\");\n#endif /* GL_IBM_static_data */\n#ifdef GL_IBM_texture_mirrored_repeat\n  CONST_CAST(GLEW_IBM_texture_mirrored_repeat) = glewGetExtension(\"GL_IBM_texture_mirrored_repeat\");\n#endif /* GL_IBM_texture_mirrored_repeat */\n#ifdef GL_IBM_vertex_array_lists\n  CONST_CAST(GLEW_IBM_vertex_array_lists) = glewGetExtension(\"GL_IBM_vertex_array_lists\");\n  if (glewExperimental || GLEW_IBM_vertex_array_lists) CONST_CAST(GLEW_IBM_vertex_array_lists) = !_glewInit_GL_IBM_vertex_array_lists(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_IBM_vertex_array_lists */\n#ifdef GL_INGR_color_clamp\n  CONST_CAST(GLEW_INGR_color_clamp) = glewGetExtension(\"GL_INGR_color_clamp\");\n#endif /* GL_INGR_color_clamp */\n#ifdef GL_INGR_interlace_read\n  CONST_CAST(GLEW_INGR_interlace_read) = glewGetExtension(\"GL_INGR_interlace_read\");\n#endif /* GL_INGR_interlace_read */\n#ifdef GL_INTEL_parallel_arrays\n  CONST_CAST(GLEW_INTEL_parallel_arrays) = glewGetExtension(\"GL_INTEL_parallel_arrays\");\n  if (glewExperimental || GLEW_INTEL_parallel_arrays) CONST_CAST(GLEW_INTEL_parallel_arrays) = !_glewInit_GL_INTEL_parallel_arrays(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_INTEL_parallel_arrays */\n#ifdef GL_INTEL_texture_scissor\n  CONST_CAST(GLEW_INTEL_texture_scissor) = glewGetExtension(\"GL_INTEL_texture_scissor\");\n  if (glewExperimental || GLEW_INTEL_texture_scissor) CONST_CAST(GLEW_INTEL_texture_scissor) = !_glewInit_GL_INTEL_texture_scissor(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_INTEL_texture_scissor */\n#ifdef GL_KTX_buffer_region\n  CONST_CAST(GLEW_KTX_buffer_region) = glewGetExtension(\"GL_KTX_buffer_region\");\n  if (glewExperimental || GLEW_KTX_buffer_region) CONST_CAST(GLEW_KTX_buffer_region) = !_glewInit_GL_KTX_buffer_region(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_KTX_buffer_region */\n#ifdef GL_MESAX_texture_stack\n  CONST_CAST(GLEW_MESAX_texture_stack) = glewGetExtension(\"GL_MESAX_texture_stack\");\n#endif /* GL_MESAX_texture_stack */\n#ifdef GL_MESA_pack_invert\n  CONST_CAST(GLEW_MESA_pack_invert) = glewGetExtension(\"GL_MESA_pack_invert\");\n#endif /* GL_MESA_pack_invert */\n#ifdef GL_MESA_resize_buffers\n  CONST_CAST(GLEW_MESA_resize_buffers) = glewGetExtension(\"GL_MESA_resize_buffers\");\n  if (glewExperimental || GLEW_MESA_resize_buffers) CONST_CAST(GLEW_MESA_resize_buffers) = !_glewInit_GL_MESA_resize_buffers(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_MESA_resize_buffers */\n#ifdef GL_MESA_window_pos\n  CONST_CAST(GLEW_MESA_window_pos) = glewGetExtension(\"GL_MESA_window_pos\");\n  if (glewExperimental || GLEW_MESA_window_pos) CONST_CAST(GLEW_MESA_window_pos) = !_glewInit_GL_MESA_window_pos(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_MESA_window_pos */\n#ifdef GL_MESA_ycbcr_texture\n  CONST_CAST(GLEW_MESA_ycbcr_texture) = glewGetExtension(\"GL_MESA_ycbcr_texture\");\n#endif /* GL_MESA_ycbcr_texture */\n#ifdef GL_NV_blend_square\n  CONST_CAST(GLEW_NV_blend_square) = glewGetExtension(\"GL_NV_blend_square\");\n#endif /* GL_NV_blend_square */\n#ifdef GL_NV_conditional_render\n  CONST_CAST(GLEW_NV_conditional_render) = glewGetExtension(\"GL_NV_conditional_render\");\n  if (glewExperimental || GLEW_NV_conditional_render) CONST_CAST(GLEW_NV_conditional_render) = !_glewInit_GL_NV_conditional_render(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_conditional_render */\n#ifdef GL_NV_copy_depth_to_color\n  CONST_CAST(GLEW_NV_copy_depth_to_color) = glewGetExtension(\"GL_NV_copy_depth_to_color\");\n#endif /* GL_NV_copy_depth_to_color */\n#ifdef GL_NV_depth_buffer_float\n  CONST_CAST(GLEW_NV_depth_buffer_float) = glewGetExtension(\"GL_NV_depth_buffer_float\");\n  if (glewExperimental || GLEW_NV_depth_buffer_float) CONST_CAST(GLEW_NV_depth_buffer_float) = !_glewInit_GL_NV_depth_buffer_float(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_depth_buffer_float */\n#ifdef GL_NV_depth_clamp\n  CONST_CAST(GLEW_NV_depth_clamp) = glewGetExtension(\"GL_NV_depth_clamp\");\n#endif /* GL_NV_depth_clamp */\n#ifdef GL_NV_depth_range_unclamped\n  CONST_CAST(GLEW_NV_depth_range_unclamped) = glewGetExtension(\"GL_NV_depth_range_unclamped\");\n#endif /* GL_NV_depth_range_unclamped */\n#ifdef GL_NV_evaluators\n  CONST_CAST(GLEW_NV_evaluators) = glewGetExtension(\"GL_NV_evaluators\");\n  if (glewExperimental || GLEW_NV_evaluators) CONST_CAST(GLEW_NV_evaluators) = !_glewInit_GL_NV_evaluators(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_evaluators */\n#ifdef GL_NV_explicit_multisample\n  CONST_CAST(GLEW_NV_explicit_multisample) = glewGetExtension(\"GL_NV_explicit_multisample\");\n  if (glewExperimental || GLEW_NV_explicit_multisample) CONST_CAST(GLEW_NV_explicit_multisample) = !_glewInit_GL_NV_explicit_multisample(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_explicit_multisample */\n#ifdef GL_NV_fence\n  CONST_CAST(GLEW_NV_fence) = glewGetExtension(\"GL_NV_fence\");\n  if (glewExperimental || GLEW_NV_fence) CONST_CAST(GLEW_NV_fence) = !_glewInit_GL_NV_fence(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_fence */\n#ifdef GL_NV_float_buffer\n  CONST_CAST(GLEW_NV_float_buffer) = glewGetExtension(\"GL_NV_float_buffer\");\n#endif /* GL_NV_float_buffer */\n#ifdef GL_NV_fog_distance\n  CONST_CAST(GLEW_NV_fog_distance) = glewGetExtension(\"GL_NV_fog_distance\");\n#endif /* GL_NV_fog_distance */\n#ifdef GL_NV_fragment_program\n  CONST_CAST(GLEW_NV_fragment_program) = glewGetExtension(\"GL_NV_fragment_program\");\n  if (glewExperimental || GLEW_NV_fragment_program) CONST_CAST(GLEW_NV_fragment_program) = !_glewInit_GL_NV_fragment_program(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_fragment_program */\n#ifdef GL_NV_fragment_program2\n  CONST_CAST(GLEW_NV_fragment_program2) = glewGetExtension(\"GL_NV_fragment_program2\");\n#endif /* GL_NV_fragment_program2 */\n#ifdef GL_NV_fragment_program4\n  CONST_CAST(GLEW_NV_fragment_program4) = glewGetExtension(\"GL_NV_fragment_program4\");\n#endif /* GL_NV_fragment_program4 */\n#ifdef GL_NV_fragment_program_option\n  CONST_CAST(GLEW_NV_fragment_program_option) = glewGetExtension(\"GL_NV_fragment_program_option\");\n#endif /* GL_NV_fragment_program_option */\n#ifdef GL_NV_framebuffer_multisample_coverage\n  CONST_CAST(GLEW_NV_framebuffer_multisample_coverage) = glewGetExtension(\"GL_NV_framebuffer_multisample_coverage\");\n  if (glewExperimental || GLEW_NV_framebuffer_multisample_coverage) CONST_CAST(GLEW_NV_framebuffer_multisample_coverage) = !_glewInit_GL_NV_framebuffer_multisample_coverage(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_framebuffer_multisample_coverage */\n#ifdef GL_NV_geometry_program4\n  CONST_CAST(GLEW_NV_geometry_program4) = glewGetExtension(\"GL_NV_geometry_program4\");\n  if (glewExperimental || GLEW_NV_geometry_program4) CONST_CAST(GLEW_NV_geometry_program4) = !_glewInit_GL_NV_geometry_program4(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_geometry_program4 */\n#ifdef GL_NV_geometry_shader4\n  CONST_CAST(GLEW_NV_geometry_shader4) = glewGetExtension(\"GL_NV_geometry_shader4\");\n#endif /* GL_NV_geometry_shader4 */\n#ifdef GL_NV_gpu_program4\n  CONST_CAST(GLEW_NV_gpu_program4) = glewGetExtension(\"GL_NV_gpu_program4\");\n  if (glewExperimental || GLEW_NV_gpu_program4) CONST_CAST(GLEW_NV_gpu_program4) = !_glewInit_GL_NV_gpu_program4(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_gpu_program4 */\n#ifdef GL_NV_half_float\n  CONST_CAST(GLEW_NV_half_float) = glewGetExtension(\"GL_NV_half_float\");\n  if (glewExperimental || GLEW_NV_half_float) CONST_CAST(GLEW_NV_half_float) = !_glewInit_GL_NV_half_float(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_half_float */\n#ifdef GL_NV_light_max_exponent\n  CONST_CAST(GLEW_NV_light_max_exponent) = glewGetExtension(\"GL_NV_light_max_exponent\");\n#endif /* GL_NV_light_max_exponent */\n#ifdef GL_NV_multisample_filter_hint\n  CONST_CAST(GLEW_NV_multisample_filter_hint) = glewGetExtension(\"GL_NV_multisample_filter_hint\");\n#endif /* GL_NV_multisample_filter_hint */\n#ifdef GL_NV_occlusion_query\n  CONST_CAST(GLEW_NV_occlusion_query) = glewGetExtension(\"GL_NV_occlusion_query\");\n  if (glewExperimental || GLEW_NV_occlusion_query) CONST_CAST(GLEW_NV_occlusion_query) = !_glewInit_GL_NV_occlusion_query(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_occlusion_query */\n#ifdef GL_NV_packed_depth_stencil\n  CONST_CAST(GLEW_NV_packed_depth_stencil) = glewGetExtension(\"GL_NV_packed_depth_stencil\");\n#endif /* GL_NV_packed_depth_stencil */\n#ifdef GL_NV_parameter_buffer_object\n  CONST_CAST(GLEW_NV_parameter_buffer_object) = glewGetExtension(\"GL_NV_parameter_buffer_object\");\n  if (glewExperimental || GLEW_NV_parameter_buffer_object) CONST_CAST(GLEW_NV_parameter_buffer_object) = !_glewInit_GL_NV_parameter_buffer_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_parameter_buffer_object */\n#ifdef GL_NV_pixel_data_range\n  CONST_CAST(GLEW_NV_pixel_data_range) = glewGetExtension(\"GL_NV_pixel_data_range\");\n  if (glewExperimental || GLEW_NV_pixel_data_range) CONST_CAST(GLEW_NV_pixel_data_range) = !_glewInit_GL_NV_pixel_data_range(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_pixel_data_range */\n#ifdef GL_NV_point_sprite\n  CONST_CAST(GLEW_NV_point_sprite) = glewGetExtension(\"GL_NV_point_sprite\");\n  if (glewExperimental || GLEW_NV_point_sprite) CONST_CAST(GLEW_NV_point_sprite) = !_glewInit_GL_NV_point_sprite(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_point_sprite */\n#ifdef GL_NV_present_video\n  CONST_CAST(GLEW_NV_present_video) = glewGetExtension(\"GL_NV_present_video\");\n  if (glewExperimental || GLEW_NV_present_video) CONST_CAST(GLEW_NV_present_video) = !_glewInit_GL_NV_present_video(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_present_video */\n#ifdef GL_NV_primitive_restart\n  CONST_CAST(GLEW_NV_primitive_restart) = glewGetExtension(\"GL_NV_primitive_restart\");\n  if (glewExperimental || GLEW_NV_primitive_restart) CONST_CAST(GLEW_NV_primitive_restart) = !_glewInit_GL_NV_primitive_restart(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_primitive_restart */\n#ifdef GL_NV_register_combiners\n  CONST_CAST(GLEW_NV_register_combiners) = glewGetExtension(\"GL_NV_register_combiners\");\n  if (glewExperimental || GLEW_NV_register_combiners) CONST_CAST(GLEW_NV_register_combiners) = !_glewInit_GL_NV_register_combiners(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_register_combiners */\n#ifdef GL_NV_register_combiners2\n  CONST_CAST(GLEW_NV_register_combiners2) = glewGetExtension(\"GL_NV_register_combiners2\");\n  if (glewExperimental || GLEW_NV_register_combiners2) CONST_CAST(GLEW_NV_register_combiners2) = !_glewInit_GL_NV_register_combiners2(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_register_combiners2 */\n#ifdef GL_NV_texgen_emboss\n  CONST_CAST(GLEW_NV_texgen_emboss) = glewGetExtension(\"GL_NV_texgen_emboss\");\n#endif /* GL_NV_texgen_emboss */\n#ifdef GL_NV_texgen_reflection\n  CONST_CAST(GLEW_NV_texgen_reflection) = glewGetExtension(\"GL_NV_texgen_reflection\");\n#endif /* GL_NV_texgen_reflection */\n#ifdef GL_NV_texture_compression_vtc\n  CONST_CAST(GLEW_NV_texture_compression_vtc) = glewGetExtension(\"GL_NV_texture_compression_vtc\");\n#endif /* GL_NV_texture_compression_vtc */\n#ifdef GL_NV_texture_env_combine4\n  CONST_CAST(GLEW_NV_texture_env_combine4) = glewGetExtension(\"GL_NV_texture_env_combine4\");\n#endif /* GL_NV_texture_env_combine4 */\n#ifdef GL_NV_texture_expand_normal\n  CONST_CAST(GLEW_NV_texture_expand_normal) = glewGetExtension(\"GL_NV_texture_expand_normal\");\n#endif /* GL_NV_texture_expand_normal */\n#ifdef GL_NV_texture_rectangle\n  CONST_CAST(GLEW_NV_texture_rectangle) = glewGetExtension(\"GL_NV_texture_rectangle\");\n#endif /* GL_NV_texture_rectangle */\n#ifdef GL_NV_texture_shader\n  CONST_CAST(GLEW_NV_texture_shader) = glewGetExtension(\"GL_NV_texture_shader\");\n#endif /* GL_NV_texture_shader */\n#ifdef GL_NV_texture_shader2\n  CONST_CAST(GLEW_NV_texture_shader2) = glewGetExtension(\"GL_NV_texture_shader2\");\n#endif /* GL_NV_texture_shader2 */\n#ifdef GL_NV_texture_shader3\n  CONST_CAST(GLEW_NV_texture_shader3) = glewGetExtension(\"GL_NV_texture_shader3\");\n#endif /* GL_NV_texture_shader3 */\n#ifdef GL_NV_transform_feedback\n  CONST_CAST(GLEW_NV_transform_feedback) = glewGetExtension(\"GL_NV_transform_feedback\");\n  if (glewExperimental || GLEW_NV_transform_feedback) CONST_CAST(GLEW_NV_transform_feedback) = !_glewInit_GL_NV_transform_feedback(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_transform_feedback */\n#ifdef GL_NV_vertex_array_range\n  CONST_CAST(GLEW_NV_vertex_array_range) = glewGetExtension(\"GL_NV_vertex_array_range\");\n  if (glewExperimental || GLEW_NV_vertex_array_range) CONST_CAST(GLEW_NV_vertex_array_range) = !_glewInit_GL_NV_vertex_array_range(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_vertex_array_range */\n#ifdef GL_NV_vertex_array_range2\n  CONST_CAST(GLEW_NV_vertex_array_range2) = glewGetExtension(\"GL_NV_vertex_array_range2\");\n#endif /* GL_NV_vertex_array_range2 */\n#ifdef GL_NV_vertex_program\n  CONST_CAST(GLEW_NV_vertex_program) = glewGetExtension(\"GL_NV_vertex_program\");\n  if (glewExperimental || GLEW_NV_vertex_program) CONST_CAST(GLEW_NV_vertex_program) = !_glewInit_GL_NV_vertex_program(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_vertex_program */\n#ifdef GL_NV_vertex_program1_1\n  CONST_CAST(GLEW_NV_vertex_program1_1) = glewGetExtension(\"GL_NV_vertex_program1_1\");\n#endif /* GL_NV_vertex_program1_1 */\n#ifdef GL_NV_vertex_program2\n  CONST_CAST(GLEW_NV_vertex_program2) = glewGetExtension(\"GL_NV_vertex_program2\");\n#endif /* GL_NV_vertex_program2 */\n#ifdef GL_NV_vertex_program2_option\n  CONST_CAST(GLEW_NV_vertex_program2_option) = glewGetExtension(\"GL_NV_vertex_program2_option\");\n#endif /* GL_NV_vertex_program2_option */\n#ifdef GL_NV_vertex_program3\n  CONST_CAST(GLEW_NV_vertex_program3) = glewGetExtension(\"GL_NV_vertex_program3\");\n#endif /* GL_NV_vertex_program3 */\n#ifdef GL_NV_vertex_program4\n  CONST_CAST(GLEW_NV_vertex_program4) = glewGetExtension(\"GL_NV_vertex_program4\");\n#endif /* GL_NV_vertex_program4 */\n#ifdef GL_OES_byte_coordinates\n  CONST_CAST(GLEW_OES_byte_coordinates) = glewGetExtension(\"GL_OES_byte_coordinates\");\n#endif /* GL_OES_byte_coordinates */\n#ifdef GL_OES_compressed_paletted_texture\n  CONST_CAST(GLEW_OES_compressed_paletted_texture) = glewGetExtension(\"GL_OES_compressed_paletted_texture\");\n#endif /* GL_OES_compressed_paletted_texture */\n#ifdef GL_OES_read_format\n  CONST_CAST(GLEW_OES_read_format) = glewGetExtension(\"GL_OES_read_format\");\n#endif /* GL_OES_read_format */\n#ifdef GL_OES_single_precision\n  CONST_CAST(GLEW_OES_single_precision) = glewGetExtension(\"GL_OES_single_precision\");\n  if (glewExperimental || GLEW_OES_single_precision) CONST_CAST(GLEW_OES_single_precision) = !_glewInit_GL_OES_single_precision(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_OES_single_precision */\n#ifdef GL_OML_interlace\n  CONST_CAST(GLEW_OML_interlace) = glewGetExtension(\"GL_OML_interlace\");\n#endif /* GL_OML_interlace */\n#ifdef GL_OML_resample\n  CONST_CAST(GLEW_OML_resample) = glewGetExtension(\"GL_OML_resample\");\n#endif /* GL_OML_resample */\n#ifdef GL_OML_subsample\n  CONST_CAST(GLEW_OML_subsample) = glewGetExtension(\"GL_OML_subsample\");\n#endif /* GL_OML_subsample */\n#ifdef GL_PGI_misc_hints\n  CONST_CAST(GLEW_PGI_misc_hints) = glewGetExtension(\"GL_PGI_misc_hints\");\n#endif /* GL_PGI_misc_hints */\n#ifdef GL_PGI_vertex_hints\n  CONST_CAST(GLEW_PGI_vertex_hints) = glewGetExtension(\"GL_PGI_vertex_hints\");\n#endif /* GL_PGI_vertex_hints */\n#ifdef GL_REND_screen_coordinates\n  CONST_CAST(GLEW_REND_screen_coordinates) = glewGetExtension(\"GL_REND_screen_coordinates\");\n#endif /* GL_REND_screen_coordinates */\n#ifdef GL_S3_s3tc\n  CONST_CAST(GLEW_S3_s3tc) = glewGetExtension(\"GL_S3_s3tc\");\n#endif /* GL_S3_s3tc */\n#ifdef GL_SGIS_color_range\n  CONST_CAST(GLEW_SGIS_color_range) = glewGetExtension(\"GL_SGIS_color_range\");\n#endif /* GL_SGIS_color_range */\n#ifdef GL_SGIS_detail_texture\n  CONST_CAST(GLEW_SGIS_detail_texture) = glewGetExtension(\"GL_SGIS_detail_texture\");\n  if (glewExperimental || GLEW_SGIS_detail_texture) CONST_CAST(GLEW_SGIS_detail_texture) = !_glewInit_GL_SGIS_detail_texture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIS_detail_texture */\n#ifdef GL_SGIS_fog_function\n  CONST_CAST(GLEW_SGIS_fog_function) = glewGetExtension(\"GL_SGIS_fog_function\");\n  if (glewExperimental || GLEW_SGIS_fog_function) CONST_CAST(GLEW_SGIS_fog_function) = !_glewInit_GL_SGIS_fog_function(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIS_fog_function */\n#ifdef GL_SGIS_generate_mipmap\n  CONST_CAST(GLEW_SGIS_generate_mipmap) = glewGetExtension(\"GL_SGIS_generate_mipmap\");\n#endif /* GL_SGIS_generate_mipmap */\n#ifdef GL_SGIS_multisample\n  CONST_CAST(GLEW_SGIS_multisample) = glewGetExtension(\"GL_SGIS_multisample\");\n  if (glewExperimental || GLEW_SGIS_multisample) CONST_CAST(GLEW_SGIS_multisample) = !_glewInit_GL_SGIS_multisample(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIS_multisample */\n#ifdef GL_SGIS_pixel_texture\n  CONST_CAST(GLEW_SGIS_pixel_texture) = glewGetExtension(\"GL_SGIS_pixel_texture\");\n#endif /* GL_SGIS_pixel_texture */\n#ifdef GL_SGIS_point_line_texgen\n  CONST_CAST(GLEW_SGIS_point_line_texgen) = glewGetExtension(\"GL_SGIS_point_line_texgen\");\n#endif /* GL_SGIS_point_line_texgen */\n#ifdef GL_SGIS_sharpen_texture\n  CONST_CAST(GLEW_SGIS_sharpen_texture) = glewGetExtension(\"GL_SGIS_sharpen_texture\");\n  if (glewExperimental || GLEW_SGIS_sharpen_texture) CONST_CAST(GLEW_SGIS_sharpen_texture) = !_glewInit_GL_SGIS_sharpen_texture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIS_sharpen_texture */\n#ifdef GL_SGIS_texture4D\n  CONST_CAST(GLEW_SGIS_texture4D) = glewGetExtension(\"GL_SGIS_texture4D\");\n  if (glewExperimental || GLEW_SGIS_texture4D) CONST_CAST(GLEW_SGIS_texture4D) = !_glewInit_GL_SGIS_texture4D(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIS_texture4D */\n#ifdef GL_SGIS_texture_border_clamp\n  CONST_CAST(GLEW_SGIS_texture_border_clamp) = glewGetExtension(\"GL_SGIS_texture_border_clamp\");\n#endif /* GL_SGIS_texture_border_clamp */\n#ifdef GL_SGIS_texture_edge_clamp\n  CONST_CAST(GLEW_SGIS_texture_edge_clamp) = glewGetExtension(\"GL_SGIS_texture_edge_clamp\");\n#endif /* GL_SGIS_texture_edge_clamp */\n#ifdef GL_SGIS_texture_filter4\n  CONST_CAST(GLEW_SGIS_texture_filter4) = glewGetExtension(\"GL_SGIS_texture_filter4\");\n  if (glewExperimental || GLEW_SGIS_texture_filter4) CONST_CAST(GLEW_SGIS_texture_filter4) = !_glewInit_GL_SGIS_texture_filter4(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIS_texture_filter4 */\n#ifdef GL_SGIS_texture_lod\n  CONST_CAST(GLEW_SGIS_texture_lod) = glewGetExtension(\"GL_SGIS_texture_lod\");\n#endif /* GL_SGIS_texture_lod */\n#ifdef GL_SGIS_texture_select\n  CONST_CAST(GLEW_SGIS_texture_select) = glewGetExtension(\"GL_SGIS_texture_select\");\n#endif /* GL_SGIS_texture_select */\n#ifdef GL_SGIX_async\n  CONST_CAST(GLEW_SGIX_async) = glewGetExtension(\"GL_SGIX_async\");\n  if (glewExperimental || GLEW_SGIX_async) CONST_CAST(GLEW_SGIX_async) = !_glewInit_GL_SGIX_async(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIX_async */\n#ifdef GL_SGIX_async_histogram\n  CONST_CAST(GLEW_SGIX_async_histogram) = glewGetExtension(\"GL_SGIX_async_histogram\");\n#endif /* GL_SGIX_async_histogram */\n#ifdef GL_SGIX_async_pixel\n  CONST_CAST(GLEW_SGIX_async_pixel) = glewGetExtension(\"GL_SGIX_async_pixel\");\n#endif /* GL_SGIX_async_pixel */\n#ifdef GL_SGIX_blend_alpha_minmax\n  CONST_CAST(GLEW_SGIX_blend_alpha_minmax) = glewGetExtension(\"GL_SGIX_blend_alpha_minmax\");\n#endif /* GL_SGIX_blend_alpha_minmax */\n#ifdef GL_SGIX_clipmap\n  CONST_CAST(GLEW_SGIX_clipmap) = glewGetExtension(\"GL_SGIX_clipmap\");\n#endif /* GL_SGIX_clipmap */\n#ifdef GL_SGIX_convolution_accuracy\n  CONST_CAST(GLEW_SGIX_convolution_accuracy) = glewGetExtension(\"GL_SGIX_convolution_accuracy\");\n#endif /* GL_SGIX_convolution_accuracy */\n#ifdef GL_SGIX_depth_texture\n  CONST_CAST(GLEW_SGIX_depth_texture) = glewGetExtension(\"GL_SGIX_depth_texture\");\n#endif /* GL_SGIX_depth_texture */\n#ifdef GL_SGIX_flush_raster\n  CONST_CAST(GLEW_SGIX_flush_raster) = glewGetExtension(\"GL_SGIX_flush_raster\");\n  if (glewExperimental || GLEW_SGIX_flush_raster) CONST_CAST(GLEW_SGIX_flush_raster) = !_glewInit_GL_SGIX_flush_raster(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIX_flush_raster */\n#ifdef GL_SGIX_fog_offset\n  CONST_CAST(GLEW_SGIX_fog_offset) = glewGetExtension(\"GL_SGIX_fog_offset\");\n#endif /* GL_SGIX_fog_offset */\n#ifdef GL_SGIX_fog_texture\n  CONST_CAST(GLEW_SGIX_fog_texture) = glewGetExtension(\"GL_SGIX_fog_texture\");\n  if (glewExperimental || GLEW_SGIX_fog_texture) CONST_CAST(GLEW_SGIX_fog_texture) = !_glewInit_GL_SGIX_fog_texture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIX_fog_texture */\n#ifdef GL_SGIX_fragment_specular_lighting\n  CONST_CAST(GLEW_SGIX_fragment_specular_lighting) = glewGetExtension(\"GL_SGIX_fragment_specular_lighting\");\n  if (glewExperimental || GLEW_SGIX_fragment_specular_lighting) CONST_CAST(GLEW_SGIX_fragment_specular_lighting) = !_glewInit_GL_SGIX_fragment_specular_lighting(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIX_fragment_specular_lighting */\n#ifdef GL_SGIX_framezoom\n  CONST_CAST(GLEW_SGIX_framezoom) = glewGetExtension(\"GL_SGIX_framezoom\");\n  if (glewExperimental || GLEW_SGIX_framezoom) CONST_CAST(GLEW_SGIX_framezoom) = !_glewInit_GL_SGIX_framezoom(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIX_framezoom */\n#ifdef GL_SGIX_interlace\n  CONST_CAST(GLEW_SGIX_interlace) = glewGetExtension(\"GL_SGIX_interlace\");\n#endif /* GL_SGIX_interlace */\n#ifdef GL_SGIX_ir_instrument1\n  CONST_CAST(GLEW_SGIX_ir_instrument1) = glewGetExtension(\"GL_SGIX_ir_instrument1\");\n#endif /* GL_SGIX_ir_instrument1 */\n#ifdef GL_SGIX_list_priority\n  CONST_CAST(GLEW_SGIX_list_priority) = glewGetExtension(\"GL_SGIX_list_priority\");\n#endif /* GL_SGIX_list_priority */\n#ifdef GL_SGIX_pixel_texture\n  CONST_CAST(GLEW_SGIX_pixel_texture) = glewGetExtension(\"GL_SGIX_pixel_texture\");\n  if (glewExperimental || GLEW_SGIX_pixel_texture) CONST_CAST(GLEW_SGIX_pixel_texture) = !_glewInit_GL_SGIX_pixel_texture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIX_pixel_texture */\n#ifdef GL_SGIX_pixel_texture_bits\n  CONST_CAST(GLEW_SGIX_pixel_texture_bits) = glewGetExtension(\"GL_SGIX_pixel_texture_bits\");\n#endif /* GL_SGIX_pixel_texture_bits */\n#ifdef GL_SGIX_reference_plane\n  CONST_CAST(GLEW_SGIX_reference_plane) = glewGetExtension(\"GL_SGIX_reference_plane\");\n  if (glewExperimental || GLEW_SGIX_reference_plane) CONST_CAST(GLEW_SGIX_reference_plane) = !_glewInit_GL_SGIX_reference_plane(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIX_reference_plane */\n#ifdef GL_SGIX_resample\n  CONST_CAST(GLEW_SGIX_resample) = glewGetExtension(\"GL_SGIX_resample\");\n#endif /* GL_SGIX_resample */\n#ifdef GL_SGIX_shadow\n  CONST_CAST(GLEW_SGIX_shadow) = glewGetExtension(\"GL_SGIX_shadow\");\n#endif /* GL_SGIX_shadow */\n#ifdef GL_SGIX_shadow_ambient\n  CONST_CAST(GLEW_SGIX_shadow_ambient) = glewGetExtension(\"GL_SGIX_shadow_ambient\");\n#endif /* GL_SGIX_shadow_ambient */\n#ifdef GL_SGIX_sprite\n  CONST_CAST(GLEW_SGIX_sprite) = glewGetExtension(\"GL_SGIX_sprite\");\n  if (glewExperimental || GLEW_SGIX_sprite) CONST_CAST(GLEW_SGIX_sprite) = !_glewInit_GL_SGIX_sprite(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIX_sprite */\n#ifdef GL_SGIX_tag_sample_buffer\n  CONST_CAST(GLEW_SGIX_tag_sample_buffer) = glewGetExtension(\"GL_SGIX_tag_sample_buffer\");\n  if (glewExperimental || GLEW_SGIX_tag_sample_buffer) CONST_CAST(GLEW_SGIX_tag_sample_buffer) = !_glewInit_GL_SGIX_tag_sample_buffer(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIX_tag_sample_buffer */\n#ifdef GL_SGIX_texture_add_env\n  CONST_CAST(GLEW_SGIX_texture_add_env) = glewGetExtension(\"GL_SGIX_texture_add_env\");\n#endif /* GL_SGIX_texture_add_env */\n#ifdef GL_SGIX_texture_coordinate_clamp\n  CONST_CAST(GLEW_SGIX_texture_coordinate_clamp) = glewGetExtension(\"GL_SGIX_texture_coordinate_clamp\");\n#endif /* GL_SGIX_texture_coordinate_clamp */\n#ifdef GL_SGIX_texture_lod_bias\n  CONST_CAST(GLEW_SGIX_texture_lod_bias) = glewGetExtension(\"GL_SGIX_texture_lod_bias\");\n#endif /* GL_SGIX_texture_lod_bias */\n#ifdef GL_SGIX_texture_multi_buffer\n  CONST_CAST(GLEW_SGIX_texture_multi_buffer) = glewGetExtension(\"GL_SGIX_texture_multi_buffer\");\n#endif /* GL_SGIX_texture_multi_buffer */\n#ifdef GL_SGIX_texture_range\n  CONST_CAST(GLEW_SGIX_texture_range) = glewGetExtension(\"GL_SGIX_texture_range\");\n#endif /* GL_SGIX_texture_range */\n#ifdef GL_SGIX_texture_scale_bias\n  CONST_CAST(GLEW_SGIX_texture_scale_bias) = glewGetExtension(\"GL_SGIX_texture_scale_bias\");\n#endif /* GL_SGIX_texture_scale_bias */\n#ifdef GL_SGIX_vertex_preclip\n  CONST_CAST(GLEW_SGIX_vertex_preclip) = glewGetExtension(\"GL_SGIX_vertex_preclip\");\n#endif /* GL_SGIX_vertex_preclip */\n#ifdef GL_SGIX_vertex_preclip_hint\n  CONST_CAST(GLEW_SGIX_vertex_preclip_hint) = glewGetExtension(\"GL_SGIX_vertex_preclip_hint\");\n#endif /* GL_SGIX_vertex_preclip_hint */\n#ifdef GL_SGIX_ycrcb\n  CONST_CAST(GLEW_SGIX_ycrcb) = glewGetExtension(\"GL_SGIX_ycrcb\");\n#endif /* GL_SGIX_ycrcb */\n#ifdef GL_SGI_color_matrix\n  CONST_CAST(GLEW_SGI_color_matrix) = glewGetExtension(\"GL_SGI_color_matrix\");\n#endif /* GL_SGI_color_matrix */\n#ifdef GL_SGI_color_table\n  CONST_CAST(GLEW_SGI_color_table) = glewGetExtension(\"GL_SGI_color_table\");\n  if (glewExperimental || GLEW_SGI_color_table) CONST_CAST(GLEW_SGI_color_table) = !_glewInit_GL_SGI_color_table(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGI_color_table */\n#ifdef GL_SGI_texture_color_table\n  CONST_CAST(GLEW_SGI_texture_color_table) = glewGetExtension(\"GL_SGI_texture_color_table\");\n#endif /* GL_SGI_texture_color_table */\n#ifdef GL_SUNX_constant_data\n  CONST_CAST(GLEW_SUNX_constant_data) = glewGetExtension(\"GL_SUNX_constant_data\");\n  if (glewExperimental || GLEW_SUNX_constant_data) CONST_CAST(GLEW_SUNX_constant_data) = !_glewInit_GL_SUNX_constant_data(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SUNX_constant_data */\n#ifdef GL_SUN_convolution_border_modes\n  CONST_CAST(GLEW_SUN_convolution_border_modes) = glewGetExtension(\"GL_SUN_convolution_border_modes\");\n#endif /* GL_SUN_convolution_border_modes */\n#ifdef GL_SUN_global_alpha\n  CONST_CAST(GLEW_SUN_global_alpha) = glewGetExtension(\"GL_SUN_global_alpha\");\n  if (glewExperimental || GLEW_SUN_global_alpha) CONST_CAST(GLEW_SUN_global_alpha) = !_glewInit_GL_SUN_global_alpha(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SUN_global_alpha */\n#ifdef GL_SUN_mesh_array\n  CONST_CAST(GLEW_SUN_mesh_array) = glewGetExtension(\"GL_SUN_mesh_array\");\n#endif /* GL_SUN_mesh_array */\n#ifdef GL_SUN_read_video_pixels\n  CONST_CAST(GLEW_SUN_read_video_pixels) = glewGetExtension(\"GL_SUN_read_video_pixels\");\n  if (glewExperimental || GLEW_SUN_read_video_pixels) CONST_CAST(GLEW_SUN_read_video_pixels) = !_glewInit_GL_SUN_read_video_pixels(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SUN_read_video_pixels */\n#ifdef GL_SUN_slice_accum\n  CONST_CAST(GLEW_SUN_slice_accum) = glewGetExtension(\"GL_SUN_slice_accum\");\n#endif /* GL_SUN_slice_accum */\n#ifdef GL_SUN_triangle_list\n  CONST_CAST(GLEW_SUN_triangle_list) = glewGetExtension(\"GL_SUN_triangle_list\");\n  if (glewExperimental || GLEW_SUN_triangle_list) CONST_CAST(GLEW_SUN_triangle_list) = !_glewInit_GL_SUN_triangle_list(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SUN_triangle_list */\n#ifdef GL_SUN_vertex\n  CONST_CAST(GLEW_SUN_vertex) = glewGetExtension(\"GL_SUN_vertex\");\n  if (glewExperimental || GLEW_SUN_vertex) CONST_CAST(GLEW_SUN_vertex) = !_glewInit_GL_SUN_vertex(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SUN_vertex */\n#ifdef GL_WIN_phong_shading\n  CONST_CAST(GLEW_WIN_phong_shading) = glewGetExtension(\"GL_WIN_phong_shading\");\n#endif /* GL_WIN_phong_shading */\n#ifdef GL_WIN_specular_fog\n  CONST_CAST(GLEW_WIN_specular_fog) = glewGetExtension(\"GL_WIN_specular_fog\");\n#endif /* GL_WIN_specular_fog */\n#ifdef GL_WIN_swap_hint\n  CONST_CAST(GLEW_WIN_swap_hint) = glewGetExtension(\"GL_WIN_swap_hint\");\n  if (glewExperimental || GLEW_WIN_swap_hint) CONST_CAST(GLEW_WIN_swap_hint) = !_glewInit_GL_WIN_swap_hint(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_WIN_swap_hint */\n\n  return GLEW_OK;\n}\n\n\n#if defined(_WIN32)\n\n#if !defined(GLEW_MX)\n\nPFNWGLSETSTEREOEMITTERSTATE3DLPROC __wglewSetStereoEmitterState3DL = NULL;\n\nPFNWGLCREATEBUFFERREGIONARBPROC __wglewCreateBufferRegionARB = NULL;\nPFNWGLDELETEBUFFERREGIONARBPROC __wglewDeleteBufferRegionARB = NULL;\nPFNWGLRESTOREBUFFERREGIONARBPROC __wglewRestoreBufferRegionARB = NULL;\nPFNWGLSAVEBUFFERREGIONARBPROC __wglewSaveBufferRegionARB = NULL;\n\nPFNWGLCREATECONTEXTATTRIBSARBPROC __wglewCreateContextAttribsARB = NULL;\n\nPFNWGLGETEXTENSIONSSTRINGARBPROC __wglewGetExtensionsStringARB = NULL;\n\nPFNWGLGETCURRENTREADDCARBPROC __wglewGetCurrentReadDCARB = NULL;\nPFNWGLMAKECONTEXTCURRENTARBPROC __wglewMakeContextCurrentARB = NULL;\n\nPFNWGLCREATEPBUFFERARBPROC __wglewCreatePbufferARB = NULL;\nPFNWGLDESTROYPBUFFERARBPROC __wglewDestroyPbufferARB = NULL;\nPFNWGLGETPBUFFERDCARBPROC __wglewGetPbufferDCARB = NULL;\nPFNWGLQUERYPBUFFERARBPROC __wglewQueryPbufferARB = NULL;\nPFNWGLRELEASEPBUFFERDCARBPROC __wglewReleasePbufferDCARB = NULL;\n\nPFNWGLCHOOSEPIXELFORMATARBPROC __wglewChoosePixelFormatARB = NULL;\nPFNWGLGETPIXELFORMATATTRIBFVARBPROC __wglewGetPixelFormatAttribfvARB = NULL;\nPFNWGLGETPIXELFORMATATTRIBIVARBPROC __wglewGetPixelFormatAttribivARB = NULL;\n\nPFNWGLBINDTEXIMAGEARBPROC __wglewBindTexImageARB = NULL;\nPFNWGLRELEASETEXIMAGEARBPROC __wglewReleaseTexImageARB = NULL;\nPFNWGLSETPBUFFERATTRIBARBPROC __wglewSetPbufferAttribARB = NULL;\n\nPFNWGLBINDDISPLAYCOLORTABLEEXTPROC __wglewBindDisplayColorTableEXT = NULL;\nPFNWGLCREATEDISPLAYCOLORTABLEEXTPROC __wglewCreateDisplayColorTableEXT = NULL;\nPFNWGLDESTROYDISPLAYCOLORTABLEEXTPROC __wglewDestroyDisplayColorTableEXT = NULL;\nPFNWGLLOADDISPLAYCOLORTABLEEXTPROC __wglewLoadDisplayColorTableEXT = NULL;\n\nPFNWGLGETEXTENSIONSSTRINGEXTPROC __wglewGetExtensionsStringEXT = NULL;\n\nPFNWGLGETCURRENTREADDCEXTPROC __wglewGetCurrentReadDCEXT = NULL;\nPFNWGLMAKECONTEXTCURRENTEXTPROC __wglewMakeContextCurrentEXT = NULL;\n\nPFNWGLCREATEPBUFFEREXTPROC __wglewCreatePbufferEXT = NULL;\nPFNWGLDESTROYPBUFFEREXTPROC __wglewDestroyPbufferEXT = NULL;\nPFNWGLGETPBUFFERDCEXTPROC __wglewGetPbufferDCEXT = NULL;\nPFNWGLQUERYPBUFFEREXTPROC __wglewQueryPbufferEXT = NULL;\nPFNWGLRELEASEPBUFFERDCEXTPROC __wglewReleasePbufferDCEXT = NULL;\n\nPFNWGLCHOOSEPIXELFORMATEXTPROC __wglewChoosePixelFormatEXT = NULL;\nPFNWGLGETPIXELFORMATATTRIBFVEXTPROC __wglewGetPixelFormatAttribfvEXT = NULL;\nPFNWGLGETPIXELFORMATATTRIBIVEXTPROC __wglewGetPixelFormatAttribivEXT = NULL;\n\nPFNWGLGETSWAPINTERVALEXTPROC __wglewGetSwapIntervalEXT = NULL;\nPFNWGLSWAPINTERVALEXTPROC __wglewSwapIntervalEXT = NULL;\n\nPFNWGLGETDIGITALVIDEOPARAMETERSI3DPROC __wglewGetDigitalVideoParametersI3D = NULL;\nPFNWGLSETDIGITALVIDEOPARAMETERSI3DPROC __wglewSetDigitalVideoParametersI3D = NULL;\n\nPFNWGLGETGAMMATABLEI3DPROC __wglewGetGammaTableI3D = NULL;\nPFNWGLGETGAMMATABLEPARAMETERSI3DPROC __wglewGetGammaTableParametersI3D = NULL;\nPFNWGLSETGAMMATABLEI3DPROC __wglewSetGammaTableI3D = NULL;\nPFNWGLSETGAMMATABLEPARAMETERSI3DPROC __wglewSetGammaTableParametersI3D = NULL;\n\nPFNWGLDISABLEGENLOCKI3DPROC __wglewDisableGenlockI3D = NULL;\nPFNWGLENABLEGENLOCKI3DPROC __wglewEnableGenlockI3D = NULL;\nPFNWGLGENLOCKSAMPLERATEI3DPROC __wglewGenlockSampleRateI3D = NULL;\nPFNWGLGENLOCKSOURCEDELAYI3DPROC __wglewGenlockSourceDelayI3D = NULL;\nPFNWGLGENLOCKSOURCEEDGEI3DPROC __wglewGenlockSourceEdgeI3D = NULL;\nPFNWGLGENLOCKSOURCEI3DPROC __wglewGenlockSourceI3D = NULL;\nPFNWGLGETGENLOCKSAMPLERATEI3DPROC __wglewGetGenlockSampleRateI3D = NULL;\nPFNWGLGETGENLOCKSOURCEDELAYI3DPROC __wglewGetGenlockSourceDelayI3D = NULL;\nPFNWGLGETGENLOCKSOURCEEDGEI3DPROC __wglewGetGenlockSourceEdgeI3D = NULL;\nPFNWGLGETGENLOCKSOURCEI3DPROC __wglewGetGenlockSourceI3D = NULL;\nPFNWGLISENABLEDGENLOCKI3DPROC __wglewIsEnabledGenlockI3D = NULL;\nPFNWGLQUERYGENLOCKMAXSOURCEDELAYI3DPROC __wglewQueryGenlockMaxSourceDelayI3D = NULL;\n\nPFNWGLASSOCIATEIMAGEBUFFEREVENTSI3DPROC __wglewAssociateImageBufferEventsI3D = NULL;\nPFNWGLCREATEIMAGEBUFFERI3DPROC __wglewCreateImageBufferI3D = NULL;\nPFNWGLDESTROYIMAGEBUFFERI3DPROC __wglewDestroyImageBufferI3D = NULL;\nPFNWGLRELEASEIMAGEBUFFEREVENTSI3DPROC __wglewReleaseImageBufferEventsI3D = NULL;\n\nPFNWGLDISABLEFRAMELOCKI3DPROC __wglewDisableFrameLockI3D = NULL;\nPFNWGLENABLEFRAMELOCKI3DPROC __wglewEnableFrameLockI3D = NULL;\nPFNWGLISENABLEDFRAMELOCKI3DPROC __wglewIsEnabledFrameLockI3D = NULL;\nPFNWGLQUERYFRAMELOCKMASTERI3DPROC __wglewQueryFrameLockMasterI3D = NULL;\n\nPFNWGLBEGINFRAMETRACKINGI3DPROC __wglewBeginFrameTrackingI3D = NULL;\nPFNWGLENDFRAMETRACKINGI3DPROC __wglewEndFrameTrackingI3D = NULL;\nPFNWGLGETFRAMEUSAGEI3DPROC __wglewGetFrameUsageI3D = NULL;\nPFNWGLQUERYFRAMETRACKINGI3DPROC __wglewQueryFrameTrackingI3D = NULL;\n\nPFNWGLCREATEAFFINITYDCNVPROC __wglewCreateAffinityDCNV = NULL;\nPFNWGLDELETEDCNVPROC __wglewDeleteDCNV = NULL;\nPFNWGLENUMGPUDEVICESNVPROC __wglewEnumGpuDevicesNV = NULL;\nPFNWGLENUMGPUSFROMAFFINITYDCNVPROC __wglewEnumGpusFromAffinityDCNV = NULL;\nPFNWGLENUMGPUSNVPROC __wglewEnumGpusNV = NULL;\n\nPFNWGLBINDVIDEODEVICENVPROC __wglewBindVideoDeviceNV = NULL;\nPFNWGLENUMERATEVIDEODEVICESNVPROC __wglewEnumerateVideoDevicesNV = NULL;\nPFNWGLQUERYCURRENTCONTEXTNVPROC __wglewQueryCurrentContextNV = NULL;\n\nPFNWGLBINDSWAPBARRIERNVPROC __wglewBindSwapBarrierNV = NULL;\nPFNWGLJOINSWAPGROUPNVPROC __wglewJoinSwapGroupNV = NULL;\nPFNWGLQUERYFRAMECOUNTNVPROC __wglewQueryFrameCountNV = NULL;\nPFNWGLQUERYMAXSWAPGROUPSNVPROC __wglewQueryMaxSwapGroupsNV = NULL;\nPFNWGLQUERYSWAPGROUPNVPROC __wglewQuerySwapGroupNV = NULL;\nPFNWGLRESETFRAMECOUNTNVPROC __wglewResetFrameCountNV = NULL;\n\nPFNWGLALLOCATEMEMORYNVPROC __wglewAllocateMemoryNV = NULL;\nPFNWGLFREEMEMORYNVPROC __wglewFreeMemoryNV = NULL;\n\nPFNWGLBINDVIDEOIMAGENVPROC __wglewBindVideoImageNV = NULL;\nPFNWGLGETVIDEODEVICENVPROC __wglewGetVideoDeviceNV = NULL;\nPFNWGLGETVIDEOINFONVPROC __wglewGetVideoInfoNV = NULL;\nPFNWGLRELEASEVIDEODEVICENVPROC __wglewReleaseVideoDeviceNV = NULL;\nPFNWGLRELEASEVIDEOIMAGENVPROC __wglewReleaseVideoImageNV = NULL;\nPFNWGLSENDPBUFFERTOVIDEONVPROC __wglewSendPbufferToVideoNV = NULL;\n\nPFNWGLGETMSCRATEOMLPROC __wglewGetMscRateOML = NULL;\nPFNWGLGETSYNCVALUESOMLPROC __wglewGetSyncValuesOML = NULL;\nPFNWGLSWAPBUFFERSMSCOMLPROC __wglewSwapBuffersMscOML = NULL;\nPFNWGLSWAPLAYERBUFFERSMSCOMLPROC __wglewSwapLayerBuffersMscOML = NULL;\nPFNWGLWAITFORMSCOMLPROC __wglewWaitForMscOML = NULL;\nPFNWGLWAITFORSBCOMLPROC __wglewWaitForSbcOML = NULL;\nGLboolean __WGLEW_3DFX_multisample = GL_FALSE;\nGLboolean __WGLEW_3DL_stereo_control = GL_FALSE;\nGLboolean __WGLEW_ARB_buffer_region = GL_FALSE;\nGLboolean __WGLEW_ARB_create_context = GL_FALSE;\nGLboolean __WGLEW_ARB_extensions_string = GL_FALSE;\nGLboolean __WGLEW_ARB_framebuffer_sRGB = GL_FALSE;\nGLboolean __WGLEW_ARB_make_current_read = GL_FALSE;\nGLboolean __WGLEW_ARB_multisample = GL_FALSE;\nGLboolean __WGLEW_ARB_pbuffer = GL_FALSE;\nGLboolean __WGLEW_ARB_pixel_format = GL_FALSE;\nGLboolean __WGLEW_ARB_pixel_format_float = GL_FALSE;\nGLboolean __WGLEW_ARB_render_texture = GL_FALSE;\nGLboolean __WGLEW_ATI_pixel_format_float = GL_FALSE;\nGLboolean __WGLEW_ATI_render_texture_rectangle = GL_FALSE;\nGLboolean __WGLEW_EXT_depth_float = GL_FALSE;\nGLboolean __WGLEW_EXT_display_color_table = GL_FALSE;\nGLboolean __WGLEW_EXT_extensions_string = GL_FALSE;\nGLboolean __WGLEW_EXT_framebuffer_sRGB = GL_FALSE;\nGLboolean __WGLEW_EXT_make_current_read = GL_FALSE;\nGLboolean __WGLEW_EXT_multisample = GL_FALSE;\nGLboolean __WGLEW_EXT_pbuffer = GL_FALSE;\nGLboolean __WGLEW_EXT_pixel_format = GL_FALSE;\nGLboolean __WGLEW_EXT_pixel_format_packed_float = GL_FALSE;\nGLboolean __WGLEW_EXT_swap_control = GL_FALSE;\nGLboolean __WGLEW_I3D_digital_video_control = GL_FALSE;\nGLboolean __WGLEW_I3D_gamma = GL_FALSE;\nGLboolean __WGLEW_I3D_genlock = GL_FALSE;\nGLboolean __WGLEW_I3D_image_buffer = GL_FALSE;\nGLboolean __WGLEW_I3D_swap_frame_lock = GL_FALSE;\nGLboolean __WGLEW_I3D_swap_frame_usage = GL_FALSE;\nGLboolean __WGLEW_NV_float_buffer = GL_FALSE;\nGLboolean __WGLEW_NV_gpu_affinity = GL_FALSE;\nGLboolean __WGLEW_NV_present_video = GL_FALSE;\nGLboolean __WGLEW_NV_render_depth_texture = GL_FALSE;\nGLboolean __WGLEW_NV_render_texture_rectangle = GL_FALSE;\nGLboolean __WGLEW_NV_swap_group = GL_FALSE;\nGLboolean __WGLEW_NV_vertex_array_range = GL_FALSE;\nGLboolean __WGLEW_NV_video_output = GL_FALSE;\nGLboolean __WGLEW_OML_sync_control = GL_FALSE;\n\n#endif /* !GLEW_MX */\n\n#ifdef WGL_3DFX_multisample\n\n#endif /* WGL_3DFX_multisample */\n\n#ifdef WGL_3DL_stereo_control\n\nstatic GLboolean _glewInit_WGL_3DL_stereo_control (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglSetStereoEmitterState3DL = (PFNWGLSETSTEREOEMITTERSTATE3DLPROC)glewGetProcAddress((const GLubyte*)\"wglSetStereoEmitterState3DL\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_3DL_stereo_control */\n\n#ifdef WGL_ARB_buffer_region\n\nstatic GLboolean _glewInit_WGL_ARB_buffer_region (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglCreateBufferRegionARB = (PFNWGLCREATEBUFFERREGIONARBPROC)glewGetProcAddress((const GLubyte*)\"wglCreateBufferRegionARB\")) == NULL) || r;\n  r = ((wglDeleteBufferRegionARB = (PFNWGLDELETEBUFFERREGIONARBPROC)glewGetProcAddress((const GLubyte*)\"wglDeleteBufferRegionARB\")) == NULL) || r;\n  r = ((wglRestoreBufferRegionARB = (PFNWGLRESTOREBUFFERREGIONARBPROC)glewGetProcAddress((const GLubyte*)\"wglRestoreBufferRegionARB\")) == NULL) || r;\n  r = ((wglSaveBufferRegionARB = (PFNWGLSAVEBUFFERREGIONARBPROC)glewGetProcAddress((const GLubyte*)\"wglSaveBufferRegionARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_ARB_buffer_region */\n\n#ifdef WGL_ARB_create_context\n\nstatic GLboolean _glewInit_WGL_ARB_create_context (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglCreateContextAttribsARB = (PFNWGLCREATECONTEXTATTRIBSARBPROC)glewGetProcAddress((const GLubyte*)\"wglCreateContextAttribsARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_ARB_create_context */\n\n#ifdef WGL_ARB_extensions_string\n\nstatic GLboolean _glewInit_WGL_ARB_extensions_string (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglGetExtensionsStringARB = (PFNWGLGETEXTENSIONSSTRINGARBPROC)glewGetProcAddress((const GLubyte*)\"wglGetExtensionsStringARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_ARB_extensions_string */\n\n#ifdef WGL_ARB_framebuffer_sRGB\n\n#endif /* WGL_ARB_framebuffer_sRGB */\n\n#ifdef WGL_ARB_make_current_read\n\nstatic GLboolean _glewInit_WGL_ARB_make_current_read (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglGetCurrentReadDCARB = (PFNWGLGETCURRENTREADDCARBPROC)glewGetProcAddress((const GLubyte*)\"wglGetCurrentReadDCARB\")) == NULL) || r;\n  r = ((wglMakeContextCurrentARB = (PFNWGLMAKECONTEXTCURRENTARBPROC)glewGetProcAddress((const GLubyte*)\"wglMakeContextCurrentARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_ARB_make_current_read */\n\n#ifdef WGL_ARB_multisample\n\n#endif /* WGL_ARB_multisample */\n\n#ifdef WGL_ARB_pbuffer\n\nstatic GLboolean _glewInit_WGL_ARB_pbuffer (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglCreatePbufferARB = (PFNWGLCREATEPBUFFERARBPROC)glewGetProcAddress((const GLubyte*)\"wglCreatePbufferARB\")) == NULL) || r;\n  r = ((wglDestroyPbufferARB = (PFNWGLDESTROYPBUFFERARBPROC)glewGetProcAddress((const GLubyte*)\"wglDestroyPbufferARB\")) == NULL) || r;\n  r = ((wglGetPbufferDCARB = (PFNWGLGETPBUFFERDCARBPROC)glewGetProcAddress((const GLubyte*)\"wglGetPbufferDCARB\")) == NULL) || r;\n  r = ((wglQueryPbufferARB = (PFNWGLQUERYPBUFFERARBPROC)glewGetProcAddress((const GLubyte*)\"wglQueryPbufferARB\")) == NULL) || r;\n  r = ((wglReleasePbufferDCARB = (PFNWGLRELEASEPBUFFERDCARBPROC)glewGetProcAddress((const GLubyte*)\"wglReleasePbufferDCARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_ARB_pbuffer */\n\n#ifdef WGL_ARB_pixel_format\n\nstatic GLboolean _glewInit_WGL_ARB_pixel_format (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglChoosePixelFormatARB = (PFNWGLCHOOSEPIXELFORMATARBPROC)glewGetProcAddress((const GLubyte*)\"wglChoosePixelFormatARB\")) == NULL) || r;\n  r = ((wglGetPixelFormatAttribfvARB = (PFNWGLGETPIXELFORMATATTRIBFVARBPROC)glewGetProcAddress((const GLubyte*)\"wglGetPixelFormatAttribfvARB\")) == NULL) || r;\n  r = ((wglGetPixelFormatAttribivARB = (PFNWGLGETPIXELFORMATATTRIBIVARBPROC)glewGetProcAddress((const GLubyte*)\"wglGetPixelFormatAttribivARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_ARB_pixel_format */\n\n#ifdef WGL_ARB_pixel_format_float\n\n#endif /* WGL_ARB_pixel_format_float */\n\n#ifdef WGL_ARB_render_texture\n\nstatic GLboolean _glewInit_WGL_ARB_render_texture (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglBindTexImageARB = (PFNWGLBINDTEXIMAGEARBPROC)glewGetProcAddress((const GLubyte*)\"wglBindTexImageARB\")) == NULL) || r;\n  r = ((wglReleaseTexImageARB = (PFNWGLRELEASETEXIMAGEARBPROC)glewGetProcAddress((const GLubyte*)\"wglReleaseTexImageARB\")) == NULL) || r;\n  r = ((wglSetPbufferAttribARB = (PFNWGLSETPBUFFERATTRIBARBPROC)glewGetProcAddress((const GLubyte*)\"wglSetPbufferAttribARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_ARB_render_texture */\n\n#ifdef WGL_ATI_pixel_format_float\n\n#endif /* WGL_ATI_pixel_format_float */\n\n#ifdef WGL_ATI_render_texture_rectangle\n\n#endif /* WGL_ATI_render_texture_rectangle */\n\n#ifdef WGL_EXT_depth_float\n\n#endif /* WGL_EXT_depth_float */\n\n#ifdef WGL_EXT_display_color_table\n\nstatic GLboolean _glewInit_WGL_EXT_display_color_table (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglBindDisplayColorTableEXT = (PFNWGLBINDDISPLAYCOLORTABLEEXTPROC)glewGetProcAddress((const GLubyte*)\"wglBindDisplayColorTableEXT\")) == NULL) || r;\n  r = ((wglCreateDisplayColorTableEXT = (PFNWGLCREATEDISPLAYCOLORTABLEEXTPROC)glewGetProcAddress((const GLubyte*)\"wglCreateDisplayColorTableEXT\")) == NULL) || r;\n  r = ((wglDestroyDisplayColorTableEXT = (PFNWGLDESTROYDISPLAYCOLORTABLEEXTPROC)glewGetProcAddress((const GLubyte*)\"wglDestroyDisplayColorTableEXT\")) == NULL) || r;\n  r = ((wglLoadDisplayColorTableEXT = (PFNWGLLOADDISPLAYCOLORTABLEEXTPROC)glewGetProcAddress((const GLubyte*)\"wglLoadDisplayColorTableEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_EXT_display_color_table */\n\n#ifdef WGL_EXT_extensions_string\n\nstatic GLboolean _glewInit_WGL_EXT_extensions_string (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglGetExtensionsStringEXT = (PFNWGLGETEXTENSIONSSTRINGEXTPROC)glewGetProcAddress((const GLubyte*)\"wglGetExtensionsStringEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_EXT_extensions_string */\n\n#ifdef WGL_EXT_framebuffer_sRGB\n\n#endif /* WGL_EXT_framebuffer_sRGB */\n\n#ifdef WGL_EXT_make_current_read\n\nstatic GLboolean _glewInit_WGL_EXT_make_current_read (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglGetCurrentReadDCEXT = (PFNWGLGETCURRENTREADDCEXTPROC)glewGetProcAddress((const GLubyte*)\"wglGetCurrentReadDCEXT\")) == NULL) || r;\n  r = ((wglMakeContextCurrentEXT = (PFNWGLMAKECONTEXTCURRENTEXTPROC)glewGetProcAddress((const GLubyte*)\"wglMakeContextCurrentEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_EXT_make_current_read */\n\n#ifdef WGL_EXT_multisample\n\n#endif /* WGL_EXT_multisample */\n\n#ifdef WGL_EXT_pbuffer\n\nstatic GLboolean _glewInit_WGL_EXT_pbuffer (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglCreatePbufferEXT = (PFNWGLCREATEPBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"wglCreatePbufferEXT\")) == NULL) || r;\n  r = ((wglDestroyPbufferEXT = (PFNWGLDESTROYPBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"wglDestroyPbufferEXT\")) == NULL) || r;\n  r = ((wglGetPbufferDCEXT = (PFNWGLGETPBUFFERDCEXTPROC)glewGetProcAddress((const GLubyte*)\"wglGetPbufferDCEXT\")) == NULL) || r;\n  r = ((wglQueryPbufferEXT = (PFNWGLQUERYPBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"wglQueryPbufferEXT\")) == NULL) || r;\n  r = ((wglReleasePbufferDCEXT = (PFNWGLRELEASEPBUFFERDCEXTPROC)glewGetProcAddress((const GLubyte*)\"wglReleasePbufferDCEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_EXT_pbuffer */\n\n#ifdef WGL_EXT_pixel_format\n\nstatic GLboolean _glewInit_WGL_EXT_pixel_format (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglChoosePixelFormatEXT = (PFNWGLCHOOSEPIXELFORMATEXTPROC)glewGetProcAddress((const GLubyte*)\"wglChoosePixelFormatEXT\")) == NULL) || r;\n  r = ((wglGetPixelFormatAttribfvEXT = (PFNWGLGETPIXELFORMATATTRIBFVEXTPROC)glewGetProcAddress((const GLubyte*)\"wglGetPixelFormatAttribfvEXT\")) == NULL) || r;\n  r = ((wglGetPixelFormatAttribivEXT = (PFNWGLGETPIXELFORMATATTRIBIVEXTPROC)glewGetProcAddress((const GLubyte*)\"wglGetPixelFormatAttribivEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_EXT_pixel_format */\n\n#ifdef WGL_EXT_pixel_format_packed_float\n\n#endif /* WGL_EXT_pixel_format_packed_float */\n\n#ifdef WGL_EXT_swap_control\n\nstatic GLboolean _glewInit_WGL_EXT_swap_control (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglGetSwapIntervalEXT = (PFNWGLGETSWAPINTERVALEXTPROC)glewGetProcAddress((const GLubyte*)\"wglGetSwapIntervalEXT\")) == NULL) || r;\n  r = ((wglSwapIntervalEXT = (PFNWGLSWAPINTERVALEXTPROC)glewGetProcAddress((const GLubyte*)\"wglSwapIntervalEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_EXT_swap_control */\n\n#ifdef WGL_I3D_digital_video_control\n\nstatic GLboolean _glewInit_WGL_I3D_digital_video_control (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglGetDigitalVideoParametersI3D = (PFNWGLGETDIGITALVIDEOPARAMETERSI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGetDigitalVideoParametersI3D\")) == NULL) || r;\n  r = ((wglSetDigitalVideoParametersI3D = (PFNWGLSETDIGITALVIDEOPARAMETERSI3DPROC)glewGetProcAddress((const GLubyte*)\"wglSetDigitalVideoParametersI3D\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_I3D_digital_video_control */\n\n#ifdef WGL_I3D_gamma\n\nstatic GLboolean _glewInit_WGL_I3D_gamma (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglGetGammaTableI3D = (PFNWGLGETGAMMATABLEI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGetGammaTableI3D\")) == NULL) || r;\n  r = ((wglGetGammaTableParametersI3D = (PFNWGLGETGAMMATABLEPARAMETERSI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGetGammaTableParametersI3D\")) == NULL) || r;\n  r = ((wglSetGammaTableI3D = (PFNWGLSETGAMMATABLEI3DPROC)glewGetProcAddress((const GLubyte*)\"wglSetGammaTableI3D\")) == NULL) || r;\n  r = ((wglSetGammaTableParametersI3D = (PFNWGLSETGAMMATABLEPARAMETERSI3DPROC)glewGetProcAddress((const GLubyte*)\"wglSetGammaTableParametersI3D\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_I3D_gamma */\n\n#ifdef WGL_I3D_genlock\n\nstatic GLboolean _glewInit_WGL_I3D_genlock (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglDisableGenlockI3D = (PFNWGLDISABLEGENLOCKI3DPROC)glewGetProcAddress((const GLubyte*)\"wglDisableGenlockI3D\")) == NULL) || r;\n  r = ((wglEnableGenlockI3D = (PFNWGLENABLEGENLOCKI3DPROC)glewGetProcAddress((const GLubyte*)\"wglEnableGenlockI3D\")) == NULL) || r;\n  r = ((wglGenlockSampleRateI3D = (PFNWGLGENLOCKSAMPLERATEI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGenlockSampleRateI3D\")) == NULL) || r;\n  r = ((wglGenlockSourceDelayI3D = (PFNWGLGENLOCKSOURCEDELAYI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGenlockSourceDelayI3D\")) == NULL) || r;\n  r = ((wglGenlockSourceEdgeI3D = (PFNWGLGENLOCKSOURCEEDGEI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGenlockSourceEdgeI3D\")) == NULL) || r;\n  r = ((wglGenlockSourceI3D = (PFNWGLGENLOCKSOURCEI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGenlockSourceI3D\")) == NULL) || r;\n  r = ((wglGetGenlockSampleRateI3D = (PFNWGLGETGENLOCKSAMPLERATEI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGetGenlockSampleRateI3D\")) == NULL) || r;\n  r = ((wglGetGenlockSourceDelayI3D = (PFNWGLGETGENLOCKSOURCEDELAYI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGetGenlockSourceDelayI3D\")) == NULL) || r;\n  r = ((wglGetGenlockSourceEdgeI3D = (PFNWGLGETGENLOCKSOURCEEDGEI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGetGenlockSourceEdgeI3D\")) == NULL) || r;\n  r = ((wglGetGenlockSourceI3D = (PFNWGLGETGENLOCKSOURCEI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGetGenlockSourceI3D\")) == NULL) || r;\n  r = ((wglIsEnabledGenlockI3D = (PFNWGLISENABLEDGENLOCKI3DPROC)glewGetProcAddress((const GLubyte*)\"wglIsEnabledGenlockI3D\")) == NULL) || r;\n  r = ((wglQueryGenlockMaxSourceDelayI3D = (PFNWGLQUERYGENLOCKMAXSOURCEDELAYI3DPROC)glewGetProcAddress((const GLubyte*)\"wglQueryGenlockMaxSourceDelayI3D\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_I3D_genlock */\n\n#ifdef WGL_I3D_image_buffer\n\nstatic GLboolean _glewInit_WGL_I3D_image_buffer (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglAssociateImageBufferEventsI3D = (PFNWGLASSOCIATEIMAGEBUFFEREVENTSI3DPROC)glewGetProcAddress((const GLubyte*)\"wglAssociateImageBufferEventsI3D\")) == NULL) || r;\n  r = ((wglCreateImageBufferI3D = (PFNWGLCREATEIMAGEBUFFERI3DPROC)glewGetProcAddress((const GLubyte*)\"wglCreateImageBufferI3D\")) == NULL) || r;\n  r = ((wglDestroyImageBufferI3D = (PFNWGLDESTROYIMAGEBUFFERI3DPROC)glewGetProcAddress((const GLubyte*)\"wglDestroyImageBufferI3D\")) == NULL) || r;\n  r = ((wglReleaseImageBufferEventsI3D = (PFNWGLRELEASEIMAGEBUFFEREVENTSI3DPROC)glewGetProcAddress((const GLubyte*)\"wglReleaseImageBufferEventsI3D\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_I3D_image_buffer */\n\n#ifdef WGL_I3D_swap_frame_lock\n\nstatic GLboolean _glewInit_WGL_I3D_swap_frame_lock (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglDisableFrameLockI3D = (PFNWGLDISABLEFRAMELOCKI3DPROC)glewGetProcAddress((const GLubyte*)\"wglDisableFrameLockI3D\")) == NULL) || r;\n  r = ((wglEnableFrameLockI3D = (PFNWGLENABLEFRAMELOCKI3DPROC)glewGetProcAddress((const GLubyte*)\"wglEnableFrameLockI3D\")) == NULL) || r;\n  r = ((wglIsEnabledFrameLockI3D = (PFNWGLISENABLEDFRAMELOCKI3DPROC)glewGetProcAddress((const GLubyte*)\"wglIsEnabledFrameLockI3D\")) == NULL) || r;\n  r = ((wglQueryFrameLockMasterI3D = (PFNWGLQUERYFRAMELOCKMASTERI3DPROC)glewGetProcAddress((const GLubyte*)\"wglQueryFrameLockMasterI3D\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_I3D_swap_frame_lock */\n\n#ifdef WGL_I3D_swap_frame_usage\n\nstatic GLboolean _glewInit_WGL_I3D_swap_frame_usage (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglBeginFrameTrackingI3D = (PFNWGLBEGINFRAMETRACKINGI3DPROC)glewGetProcAddress((const GLubyte*)\"wglBeginFrameTrackingI3D\")) == NULL) || r;\n  r = ((wglEndFrameTrackingI3D = (PFNWGLENDFRAMETRACKINGI3DPROC)glewGetProcAddress((const GLubyte*)\"wglEndFrameTrackingI3D\")) == NULL) || r;\n  r = ((wglGetFrameUsageI3D = (PFNWGLGETFRAMEUSAGEI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGetFrameUsageI3D\")) == NULL) || r;\n  r = ((wglQueryFrameTrackingI3D = (PFNWGLQUERYFRAMETRACKINGI3DPROC)glewGetProcAddress((const GLubyte*)\"wglQueryFrameTrackingI3D\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_I3D_swap_frame_usage */\n\n#ifdef WGL_NV_float_buffer\n\n#endif /* WGL_NV_float_buffer */\n\n#ifdef WGL_NV_gpu_affinity\n\nstatic GLboolean _glewInit_WGL_NV_gpu_affinity (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglCreateAffinityDCNV = (PFNWGLCREATEAFFINITYDCNVPROC)glewGetProcAddress((const GLubyte*)\"wglCreateAffinityDCNV\")) == NULL) || r;\n  r = ((wglDeleteDCNV = (PFNWGLDELETEDCNVPROC)glewGetProcAddress((const GLubyte*)\"wglDeleteDCNV\")) == NULL) || r;\n  r = ((wglEnumGpuDevicesNV = (PFNWGLENUMGPUDEVICESNVPROC)glewGetProcAddress((const GLubyte*)\"wglEnumGpuDevicesNV\")) == NULL) || r;\n  r = ((wglEnumGpusFromAffinityDCNV = (PFNWGLENUMGPUSFROMAFFINITYDCNVPROC)glewGetProcAddress((const GLubyte*)\"wglEnumGpusFromAffinityDCNV\")) == NULL) || r;\n  r = ((wglEnumGpusNV = (PFNWGLENUMGPUSNVPROC)glewGetProcAddress((const GLubyte*)\"wglEnumGpusNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_NV_gpu_affinity */\n\n#ifdef WGL_NV_present_video\n\nstatic GLboolean _glewInit_WGL_NV_present_video (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglBindVideoDeviceNV = (PFNWGLBINDVIDEODEVICENVPROC)glewGetProcAddress((const GLubyte*)\"wglBindVideoDeviceNV\")) == NULL) || r;\n  r = ((wglEnumerateVideoDevicesNV = (PFNWGLENUMERATEVIDEODEVICESNVPROC)glewGetProcAddress((const GLubyte*)\"wglEnumerateVideoDevicesNV\")) == NULL) || r;\n  r = ((wglQueryCurrentContextNV = (PFNWGLQUERYCURRENTCONTEXTNVPROC)glewGetProcAddress((const GLubyte*)\"wglQueryCurrentContextNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_NV_present_video */\n\n#ifdef WGL_NV_render_depth_texture\n\n#endif /* WGL_NV_render_depth_texture */\n\n#ifdef WGL_NV_render_texture_rectangle\n\n#endif /* WGL_NV_render_texture_rectangle */\n\n#ifdef WGL_NV_swap_group\n\nstatic GLboolean _glewInit_WGL_NV_swap_group (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglBindSwapBarrierNV = (PFNWGLBINDSWAPBARRIERNVPROC)glewGetProcAddress((const GLubyte*)\"wglBindSwapBarrierNV\")) == NULL) || r;\n  r = ((wglJoinSwapGroupNV = (PFNWGLJOINSWAPGROUPNVPROC)glewGetProcAddress((const GLubyte*)\"wglJoinSwapGroupNV\")) == NULL) || r;\n  r = ((wglQueryFrameCountNV = (PFNWGLQUERYFRAMECOUNTNVPROC)glewGetProcAddress((const GLubyte*)\"wglQueryFrameCountNV\")) == NULL) || r;\n  r = ((wglQueryMaxSwapGroupsNV = (PFNWGLQUERYMAXSWAPGROUPSNVPROC)glewGetProcAddress((const GLubyte*)\"wglQueryMaxSwapGroupsNV\")) == NULL) || r;\n  r = ((wglQuerySwapGroupNV = (PFNWGLQUERYSWAPGROUPNVPROC)glewGetProcAddress((const GLubyte*)\"wglQuerySwapGroupNV\")) == NULL) || r;\n  r = ((wglResetFrameCountNV = (PFNWGLRESETFRAMECOUNTNVPROC)glewGetProcAddress((const GLubyte*)\"wglResetFrameCountNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_NV_swap_group */\n\n#ifdef WGL_NV_vertex_array_range\n\nstatic GLboolean _glewInit_WGL_NV_vertex_array_range (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglAllocateMemoryNV = (PFNWGLALLOCATEMEMORYNVPROC)glewGetProcAddress((const GLubyte*)\"wglAllocateMemoryNV\")) == NULL) || r;\n  r = ((wglFreeMemoryNV = (PFNWGLFREEMEMORYNVPROC)glewGetProcAddress((const GLubyte*)\"wglFreeMemoryNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_NV_vertex_array_range */\n\n#ifdef WGL_NV_video_output\n\nstatic GLboolean _glewInit_WGL_NV_video_output (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglBindVideoImageNV = (PFNWGLBINDVIDEOIMAGENVPROC)glewGetProcAddress((const GLubyte*)\"wglBindVideoImageNV\")) == NULL) || r;\n  r = ((wglGetVideoDeviceNV = (PFNWGLGETVIDEODEVICENVPROC)glewGetProcAddress((const GLubyte*)\"wglGetVideoDeviceNV\")) == NULL) || r;\n  r = ((wglGetVideoInfoNV = (PFNWGLGETVIDEOINFONVPROC)glewGetProcAddress((const GLubyte*)\"wglGetVideoInfoNV\")) == NULL) || r;\n  r = ((wglReleaseVideoDeviceNV = (PFNWGLRELEASEVIDEODEVICENVPROC)glewGetProcAddress((const GLubyte*)\"wglReleaseVideoDeviceNV\")) == NULL) || r;\n  r = ((wglReleaseVideoImageNV = (PFNWGLRELEASEVIDEOIMAGENVPROC)glewGetProcAddress((const GLubyte*)\"wglReleaseVideoImageNV\")) == NULL) || r;\n  r = ((wglSendPbufferToVideoNV = (PFNWGLSENDPBUFFERTOVIDEONVPROC)glewGetProcAddress((const GLubyte*)\"wglSendPbufferToVideoNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_NV_video_output */\n\n#ifdef WGL_OML_sync_control\n\nstatic GLboolean _glewInit_WGL_OML_sync_control (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglGetMscRateOML = (PFNWGLGETMSCRATEOMLPROC)glewGetProcAddress((const GLubyte*)\"wglGetMscRateOML\")) == NULL) || r;\n  r = ((wglGetSyncValuesOML = (PFNWGLGETSYNCVALUESOMLPROC)glewGetProcAddress((const GLubyte*)\"wglGetSyncValuesOML\")) == NULL) || r;\n  r = ((wglSwapBuffersMscOML = (PFNWGLSWAPBUFFERSMSCOMLPROC)glewGetProcAddress((const GLubyte*)\"wglSwapBuffersMscOML\")) == NULL) || r;\n  r = ((wglSwapLayerBuffersMscOML = (PFNWGLSWAPLAYERBUFFERSMSCOMLPROC)glewGetProcAddress((const GLubyte*)\"wglSwapLayerBuffersMscOML\")) == NULL) || r;\n  r = ((wglWaitForMscOML = (PFNWGLWAITFORMSCOMLPROC)glewGetProcAddress((const GLubyte*)\"wglWaitForMscOML\")) == NULL) || r;\n  r = ((wglWaitForSbcOML = (PFNWGLWAITFORSBCOMLPROC)glewGetProcAddress((const GLubyte*)\"wglWaitForSbcOML\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_OML_sync_control */\n\n/* ------------------------------------------------------------------------- */\n\nstatic PFNWGLGETEXTENSIONSSTRINGARBPROC _wglewGetExtensionsStringARB = NULL;\nstatic PFNWGLGETEXTENSIONSSTRINGEXTPROC _wglewGetExtensionsStringEXT = NULL;\n\nGLboolean wglewGetExtension (const char* name)\n{\n  GLubyte* p;\n  GLubyte* end;\n  GLuint len = _glewStrLen((const GLubyte*)name);\n  if (_wglewGetExtensionsStringARB == NULL)\n    if (_wglewGetExtensionsStringEXT == NULL)\n      return GL_FALSE;\n    else\n      p = (GLubyte*)_wglewGetExtensionsStringEXT();\n  else\n    p = (GLubyte*)_wglewGetExtensionsStringARB(wglGetCurrentDC());\n  if (0 == p) return GL_FALSE;\n  end = p + _glewStrLen(p);\n  while (p < end)\n  {\n    GLuint n = _glewStrCLen(p, ' ');\n    if (len == n && _glewStrSame((const GLubyte*)name, p, n)) return GL_TRUE;\n    p += n+1;\n  }\n  return GL_FALSE;\n}\n\nGLenum wglewContextInit (WGLEW_CONTEXT_ARG_DEF_LIST)\n{\n  GLboolean crippled;\n  /* find wgl extension string query functions */\n  _wglewGetExtensionsStringARB = (PFNWGLGETEXTENSIONSSTRINGARBPROC)glewGetProcAddress((const GLubyte*)\"wglGetExtensionsStringARB\");\n  _wglewGetExtensionsStringEXT = (PFNWGLGETEXTENSIONSSTRINGEXTPROC)glewGetProcAddress((const GLubyte*)\"wglGetExtensionsStringEXT\");\n  /* initialize extensions */\n  crippled = _wglewGetExtensionsStringARB == NULL && _wglewGetExtensionsStringEXT == NULL;\n#ifdef WGL_3DFX_multisample\n  CONST_CAST(WGLEW_3DFX_multisample) = wglewGetExtension(\"WGL_3DFX_multisample\");\n#endif /* WGL_3DFX_multisample */\n#ifdef WGL_3DL_stereo_control\n  CONST_CAST(WGLEW_3DL_stereo_control) = wglewGetExtension(\"WGL_3DL_stereo_control\");\n  if (glewExperimental || WGLEW_3DL_stereo_control|| crippled) CONST_CAST(WGLEW_3DL_stereo_control)= !_glewInit_WGL_3DL_stereo_control(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_3DL_stereo_control */\n#ifdef WGL_ARB_buffer_region\n  CONST_CAST(WGLEW_ARB_buffer_region) = wglewGetExtension(\"WGL_ARB_buffer_region\");\n  if (glewExperimental || WGLEW_ARB_buffer_region|| crippled) CONST_CAST(WGLEW_ARB_buffer_region)= !_glewInit_WGL_ARB_buffer_region(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_ARB_buffer_region */\n#ifdef WGL_ARB_create_context\n  CONST_CAST(WGLEW_ARB_create_context) = wglewGetExtension(\"WGL_ARB_create_context\");\n  if (glewExperimental || WGLEW_ARB_create_context|| crippled) CONST_CAST(WGLEW_ARB_create_context)= !_glewInit_WGL_ARB_create_context(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_ARB_create_context */\n#ifdef WGL_ARB_extensions_string\n  CONST_CAST(WGLEW_ARB_extensions_string) = wglewGetExtension(\"WGL_ARB_extensions_string\");\n  if (glewExperimental || WGLEW_ARB_extensions_string|| crippled) CONST_CAST(WGLEW_ARB_extensions_string)= !_glewInit_WGL_ARB_extensions_string(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_ARB_extensions_string */\n#ifdef WGL_ARB_framebuffer_sRGB\n  CONST_CAST(WGLEW_ARB_framebuffer_sRGB) = wglewGetExtension(\"WGL_ARB_framebuffer_sRGB\");\n#endif /* WGL_ARB_framebuffer_sRGB */\n#ifdef WGL_ARB_make_current_read\n  CONST_CAST(WGLEW_ARB_make_current_read) = wglewGetExtension(\"WGL_ARB_make_current_read\");\n  if (glewExperimental || WGLEW_ARB_make_current_read|| crippled) CONST_CAST(WGLEW_ARB_make_current_read)= !_glewInit_WGL_ARB_make_current_read(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_ARB_make_current_read */\n#ifdef WGL_ARB_multisample\n  CONST_CAST(WGLEW_ARB_multisample) = wglewGetExtension(\"WGL_ARB_multisample\");\n#endif /* WGL_ARB_multisample */\n#ifdef WGL_ARB_pbuffer\n  CONST_CAST(WGLEW_ARB_pbuffer) = wglewGetExtension(\"WGL_ARB_pbuffer\");\n  if (glewExperimental || WGLEW_ARB_pbuffer|| crippled) CONST_CAST(WGLEW_ARB_pbuffer)= !_glewInit_WGL_ARB_pbuffer(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_ARB_pbuffer */\n#ifdef WGL_ARB_pixel_format\n  CONST_CAST(WGLEW_ARB_pixel_format) = wglewGetExtension(\"WGL_ARB_pixel_format\");\n  if (glewExperimental || WGLEW_ARB_pixel_format|| crippled) CONST_CAST(WGLEW_ARB_pixel_format)= !_glewInit_WGL_ARB_pixel_format(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_ARB_pixel_format */\n#ifdef WGL_ARB_pixel_format_float\n  CONST_CAST(WGLEW_ARB_pixel_format_float) = wglewGetExtension(\"WGL_ARB_pixel_format_float\");\n#endif /* WGL_ARB_pixel_format_float */\n#ifdef WGL_ARB_render_texture\n  CONST_CAST(WGLEW_ARB_render_texture) = wglewGetExtension(\"WGL_ARB_render_texture\");\n  if (glewExperimental || WGLEW_ARB_render_texture|| crippled) CONST_CAST(WGLEW_ARB_render_texture)= !_glewInit_WGL_ARB_render_texture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_ARB_render_texture */\n#ifdef WGL_ATI_pixel_format_float\n  CONST_CAST(WGLEW_ATI_pixel_format_float) = wglewGetExtension(\"WGL_ATI_pixel_format_float\");\n#endif /* WGL_ATI_pixel_format_float */\n#ifdef WGL_ATI_render_texture_rectangle\n  CONST_CAST(WGLEW_ATI_render_texture_rectangle) = wglewGetExtension(\"WGL_ATI_render_texture_rectangle\");\n#endif /* WGL_ATI_render_texture_rectangle */\n#ifdef WGL_EXT_depth_float\n  CONST_CAST(WGLEW_EXT_depth_float) = wglewGetExtension(\"WGL_EXT_depth_float\");\n#endif /* WGL_EXT_depth_float */\n#ifdef WGL_EXT_display_color_table\n  CONST_CAST(WGLEW_EXT_display_color_table) = wglewGetExtension(\"WGL_EXT_display_color_table\");\n  if (glewExperimental || WGLEW_EXT_display_color_table|| crippled) CONST_CAST(WGLEW_EXT_display_color_table)= !_glewInit_WGL_EXT_display_color_table(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_EXT_display_color_table */\n#ifdef WGL_EXT_extensions_string\n  CONST_CAST(WGLEW_EXT_extensions_string) = wglewGetExtension(\"WGL_EXT_extensions_string\");\n  if (glewExperimental || WGLEW_EXT_extensions_string|| crippled) CONST_CAST(WGLEW_EXT_extensions_string)= !_glewInit_WGL_EXT_extensions_string(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_EXT_extensions_string */\n#ifdef WGL_EXT_framebuffer_sRGB\n  CONST_CAST(WGLEW_EXT_framebuffer_sRGB) = wglewGetExtension(\"WGL_EXT_framebuffer_sRGB\");\n#endif /* WGL_EXT_framebuffer_sRGB */\n#ifdef WGL_EXT_make_current_read\n  CONST_CAST(WGLEW_EXT_make_current_read) = wglewGetExtension(\"WGL_EXT_make_current_read\");\n  if (glewExperimental || WGLEW_EXT_make_current_read|| crippled) CONST_CAST(WGLEW_EXT_make_current_read)= !_glewInit_WGL_EXT_make_current_read(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_EXT_make_current_read */\n#ifdef WGL_EXT_multisample\n  CONST_CAST(WGLEW_EXT_multisample) = wglewGetExtension(\"WGL_EXT_multisample\");\n#endif /* WGL_EXT_multisample */\n#ifdef WGL_EXT_pbuffer\n  CONST_CAST(WGLEW_EXT_pbuffer) = wglewGetExtension(\"WGL_EXT_pbuffer\");\n  if (glewExperimental || WGLEW_EXT_pbuffer|| crippled) CONST_CAST(WGLEW_EXT_pbuffer)= !_glewInit_WGL_EXT_pbuffer(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_EXT_pbuffer */\n#ifdef WGL_EXT_pixel_format\n  CONST_CAST(WGLEW_EXT_pixel_format) = wglewGetExtension(\"WGL_EXT_pixel_format\");\n  if (glewExperimental || WGLEW_EXT_pixel_format|| crippled) CONST_CAST(WGLEW_EXT_pixel_format)= !_glewInit_WGL_EXT_pixel_format(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_EXT_pixel_format */\n#ifdef WGL_EXT_pixel_format_packed_float\n  CONST_CAST(WGLEW_EXT_pixel_format_packed_float) = wglewGetExtension(\"WGL_EXT_pixel_format_packed_float\");\n#endif /* WGL_EXT_pixel_format_packed_float */\n#ifdef WGL_EXT_swap_control\n  CONST_CAST(WGLEW_EXT_swap_control) = wglewGetExtension(\"WGL_EXT_swap_control\");\n  if (glewExperimental || WGLEW_EXT_swap_control|| crippled) CONST_CAST(WGLEW_EXT_swap_control)= !_glewInit_WGL_EXT_swap_control(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_EXT_swap_control */\n#ifdef WGL_I3D_digital_video_control\n  CONST_CAST(WGLEW_I3D_digital_video_control) = wglewGetExtension(\"WGL_I3D_digital_video_control\");\n  if (glewExperimental || WGLEW_I3D_digital_video_control|| crippled) CONST_CAST(WGLEW_I3D_digital_video_control)= !_glewInit_WGL_I3D_digital_video_control(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_I3D_digital_video_control */\n#ifdef WGL_I3D_gamma\n  CONST_CAST(WGLEW_I3D_gamma) = wglewGetExtension(\"WGL_I3D_gamma\");\n  if (glewExperimental || WGLEW_I3D_gamma|| crippled) CONST_CAST(WGLEW_I3D_gamma)= !_glewInit_WGL_I3D_gamma(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_I3D_gamma */\n#ifdef WGL_I3D_genlock\n  CONST_CAST(WGLEW_I3D_genlock) = wglewGetExtension(\"WGL_I3D_genlock\");\n  if (glewExperimental || WGLEW_I3D_genlock|| crippled) CONST_CAST(WGLEW_I3D_genlock)= !_glewInit_WGL_I3D_genlock(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_I3D_genlock */\n#ifdef WGL_I3D_image_buffer\n  CONST_CAST(WGLEW_I3D_image_buffer) = wglewGetExtension(\"WGL_I3D_image_buffer\");\n  if (glewExperimental || WGLEW_I3D_image_buffer|| crippled) CONST_CAST(WGLEW_I3D_image_buffer)= !_glewInit_WGL_I3D_image_buffer(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_I3D_image_buffer */\n#ifdef WGL_I3D_swap_frame_lock\n  CONST_CAST(WGLEW_I3D_swap_frame_lock) = wglewGetExtension(\"WGL_I3D_swap_frame_lock\");\n  if (glewExperimental || WGLEW_I3D_swap_frame_lock|| crippled) CONST_CAST(WGLEW_I3D_swap_frame_lock)= !_glewInit_WGL_I3D_swap_frame_lock(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_I3D_swap_frame_lock */\n#ifdef WGL_I3D_swap_frame_usage\n  CONST_CAST(WGLEW_I3D_swap_frame_usage) = wglewGetExtension(\"WGL_I3D_swap_frame_usage\");\n  if (glewExperimental || WGLEW_I3D_swap_frame_usage|| crippled) CONST_CAST(WGLEW_I3D_swap_frame_usage)= !_glewInit_WGL_I3D_swap_frame_usage(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_I3D_swap_frame_usage */\n#ifdef WGL_NV_float_buffer\n  CONST_CAST(WGLEW_NV_float_buffer) = wglewGetExtension(\"WGL_NV_float_buffer\");\n#endif /* WGL_NV_float_buffer */\n#ifdef WGL_NV_gpu_affinity\n  CONST_CAST(WGLEW_NV_gpu_affinity) = wglewGetExtension(\"WGL_NV_gpu_affinity\");\n  if (glewExperimental || WGLEW_NV_gpu_affinity|| crippled) CONST_CAST(WGLEW_NV_gpu_affinity)= !_glewInit_WGL_NV_gpu_affinity(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_NV_gpu_affinity */\n#ifdef WGL_NV_present_video\n  CONST_CAST(WGLEW_NV_present_video) = wglewGetExtension(\"WGL_NV_present_video\");\n  if (glewExperimental || WGLEW_NV_present_video|| crippled) CONST_CAST(WGLEW_NV_present_video)= !_glewInit_WGL_NV_present_video(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_NV_present_video */\n#ifdef WGL_NV_render_depth_texture\n  CONST_CAST(WGLEW_NV_render_depth_texture) = wglewGetExtension(\"WGL_NV_render_depth_texture\");\n#endif /* WGL_NV_render_depth_texture */\n#ifdef WGL_NV_render_texture_rectangle\n  CONST_CAST(WGLEW_NV_render_texture_rectangle) = wglewGetExtension(\"WGL_NV_render_texture_rectangle\");\n#endif /* WGL_NV_render_texture_rectangle */\n#ifdef WGL_NV_swap_group\n  CONST_CAST(WGLEW_NV_swap_group) = wglewGetExtension(\"WGL_NV_swap_group\");\n  if (glewExperimental || WGLEW_NV_swap_group|| crippled) CONST_CAST(WGLEW_NV_swap_group)= !_glewInit_WGL_NV_swap_group(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_NV_swap_group */\n#ifdef WGL_NV_vertex_array_range\n  CONST_CAST(WGLEW_NV_vertex_array_range) = wglewGetExtension(\"WGL_NV_vertex_array_range\");\n  if (glewExperimental || WGLEW_NV_vertex_array_range|| crippled) CONST_CAST(WGLEW_NV_vertex_array_range)= !_glewInit_WGL_NV_vertex_array_range(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_NV_vertex_array_range */\n#ifdef WGL_NV_video_output\n  CONST_CAST(WGLEW_NV_video_output) = wglewGetExtension(\"WGL_NV_video_output\");\n  if (glewExperimental || WGLEW_NV_video_output|| crippled) CONST_CAST(WGLEW_NV_video_output)= !_glewInit_WGL_NV_video_output(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_NV_video_output */\n#ifdef WGL_OML_sync_control\n  CONST_CAST(WGLEW_OML_sync_control) = wglewGetExtension(\"WGL_OML_sync_control\");\n  if (glewExperimental || WGLEW_OML_sync_control|| crippled) CONST_CAST(WGLEW_OML_sync_control)= !_glewInit_WGL_OML_sync_control(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_OML_sync_control */\n\n  return GLEW_OK;\n}\n\n#elif !defined(__APPLE__) || defined(GLEW_APPLE_GLX)\n\nPFNGLXGETCURRENTDISPLAYPROC __glewXGetCurrentDisplay = NULL;\n\nPFNGLXCHOOSEFBCONFIGPROC __glewXChooseFBConfig = NULL;\nPFNGLXCREATENEWCONTEXTPROC __glewXCreateNewContext = NULL;\nPFNGLXCREATEPBUFFERPROC __glewXCreatePbuffer = NULL;\nPFNGLXCREATEPIXMAPPROC __glewXCreatePixmap = NULL;\nPFNGLXCREATEWINDOWPROC __glewXCreateWindow = NULL;\nPFNGLXDESTROYPBUFFERPROC __glewXDestroyPbuffer = NULL;\nPFNGLXDESTROYPIXMAPPROC __glewXDestroyPixmap = NULL;\nPFNGLXDESTROYWINDOWPROC __glewXDestroyWindow = NULL;\nPFNGLXGETCURRENTREADDRAWABLEPROC __glewXGetCurrentReadDrawable = NULL;\nPFNGLXGETFBCONFIGATTRIBPROC __glewXGetFBConfigAttrib = NULL;\nPFNGLXGETFBCONFIGSPROC __glewXGetFBConfigs = NULL;\nPFNGLXGETSELECTEDEVENTPROC __glewXGetSelectedEvent = NULL;\nPFNGLXGETVISUALFROMFBCONFIGPROC __glewXGetVisualFromFBConfig = NULL;\nPFNGLXMAKECONTEXTCURRENTPROC __glewXMakeContextCurrent = NULL;\nPFNGLXQUERYCONTEXTPROC __glewXQueryContext = NULL;\nPFNGLXQUERYDRAWABLEPROC __glewXQueryDrawable = NULL;\nPFNGLXSELECTEVENTPROC __glewXSelectEvent = NULL;\n\nPFNGLXCREATECONTEXTATTRIBSARBPROC __glewXCreateContextAttribsARB = NULL;\n\nPFNGLXBINDTEXIMAGEATIPROC __glewXBindTexImageATI = NULL;\nPFNGLXDRAWABLEATTRIBATIPROC __glewXDrawableAttribATI = NULL;\nPFNGLXRELEASETEXIMAGEATIPROC __glewXReleaseTexImageATI = NULL;\n\nPFNGLXFREECONTEXTEXTPROC __glewXFreeContextEXT = NULL;\nPFNGLXGETCONTEXTIDEXTPROC __glewXGetContextIDEXT = NULL;\nPFNGLXIMPORTCONTEXTEXTPROC __glewXImportContextEXT = NULL;\nPFNGLXQUERYCONTEXTINFOEXTPROC __glewXQueryContextInfoEXT = NULL;\n\nPFNGLXBINDTEXIMAGEEXTPROC __glewXBindTexImageEXT = NULL;\nPFNGLXRELEASETEXIMAGEEXTPROC __glewXReleaseTexImageEXT = NULL;\n\nPFNGLXGETAGPOFFSETMESAPROC __glewXGetAGPOffsetMESA = NULL;\n\nPFNGLXCOPYSUBBUFFERMESAPROC __glewXCopySubBufferMESA = NULL;\n\nPFNGLXCREATEGLXPIXMAPMESAPROC __glewXCreateGLXPixmapMESA = NULL;\n\nPFNGLXRELEASEBUFFERSMESAPROC __glewXReleaseBuffersMESA = NULL;\n\nPFNGLXSET3DFXMODEMESAPROC __glewXSet3DfxModeMESA = NULL;\n\nPFNGLXBINDVIDEODEVICENVPROC __glewXBindVideoDeviceNV = NULL;\nPFNGLXENUMERATEVIDEODEVICESNVPROC __glewXEnumerateVideoDevicesNV = NULL;\n\nPFNGLXBINDSWAPBARRIERNVPROC __glewXBindSwapBarrierNV = NULL;\nPFNGLXJOINSWAPGROUPNVPROC __glewXJoinSwapGroupNV = NULL;\nPFNGLXQUERYFRAMECOUNTNVPROC __glewXQueryFrameCountNV = NULL;\nPFNGLXQUERYMAXSWAPGROUPSNVPROC __glewXQueryMaxSwapGroupsNV = NULL;\nPFNGLXQUERYSWAPGROUPNVPROC __glewXQuerySwapGroupNV = NULL;\nPFNGLXRESETFRAMECOUNTNVPROC __glewXResetFrameCountNV = NULL;\n\nPFNGLXALLOCATEMEMORYNVPROC __glewXAllocateMemoryNV = NULL;\nPFNGLXFREEMEMORYNVPROC __glewXFreeMemoryNV = NULL;\n\nPFNGLXBINDVIDEOIMAGENVPROC __glewXBindVideoImageNV = NULL;\nPFNGLXGETVIDEODEVICENVPROC __glewXGetVideoDeviceNV = NULL;\nPFNGLXGETVIDEOINFONVPROC __glewXGetVideoInfoNV = NULL;\nPFNGLXRELEASEVIDEODEVICENVPROC __glewXReleaseVideoDeviceNV = NULL;\nPFNGLXRELEASEVIDEOIMAGENVPROC __glewXReleaseVideoImageNV = NULL;\nPFNGLXSENDPBUFFERTOVIDEONVPROC __glewXSendPbufferToVideoNV = NULL;\n\n#ifdef GLX_OML_sync_control\nPFNGLXGETMSCRATEOMLPROC __glewXGetMscRateOML = NULL;\nPFNGLXGETSYNCVALUESOMLPROC __glewXGetSyncValuesOML = NULL;\nPFNGLXSWAPBUFFERSMSCOMLPROC __glewXSwapBuffersMscOML = NULL;\nPFNGLXWAITFORMSCOMLPROC __glewXWaitForMscOML = NULL;\nPFNGLXWAITFORSBCOMLPROC __glewXWaitForSbcOML = NULL;\n#endif\n\nPFNGLXCHOOSEFBCONFIGSGIXPROC __glewXChooseFBConfigSGIX = NULL;\nPFNGLXCREATECONTEXTWITHCONFIGSGIXPROC __glewXCreateContextWithConfigSGIX = NULL;\nPFNGLXCREATEGLXPIXMAPWITHCONFIGSGIXPROC __glewXCreateGLXPixmapWithConfigSGIX = NULL;\nPFNGLXGETFBCONFIGATTRIBSGIXPROC __glewXGetFBConfigAttribSGIX = NULL;\nPFNGLXGETFBCONFIGFROMVISUALSGIXPROC __glewXGetFBConfigFromVisualSGIX = NULL;\nPFNGLXGETVISUALFROMFBCONFIGSGIXPROC __glewXGetVisualFromFBConfigSGIX = NULL;\n\nPFNGLXBINDHYPERPIPESGIXPROC __glewXBindHyperpipeSGIX = NULL;\nPFNGLXDESTROYHYPERPIPECONFIGSGIXPROC __glewXDestroyHyperpipeConfigSGIX = NULL;\nPFNGLXHYPERPIPEATTRIBSGIXPROC __glewXHyperpipeAttribSGIX = NULL;\nPFNGLXHYPERPIPECONFIGSGIXPROC __glewXHyperpipeConfigSGIX = NULL;\nPFNGLXQUERYHYPERPIPEATTRIBSGIXPROC __glewXQueryHyperpipeAttribSGIX = NULL;\nPFNGLXQUERYHYPERPIPEBESTATTRIBSGIXPROC __glewXQueryHyperpipeBestAttribSGIX = NULL;\nPFNGLXQUERYHYPERPIPECONFIGSGIXPROC __glewXQueryHyperpipeConfigSGIX = NULL;\nPFNGLXQUERYHYPERPIPENETWORKSGIXPROC __glewXQueryHyperpipeNetworkSGIX = NULL;\n\nPFNGLXCREATEGLXPBUFFERSGIXPROC __glewXCreateGLXPbufferSGIX = NULL;\nPFNGLXDESTROYGLXPBUFFERSGIXPROC __glewXDestroyGLXPbufferSGIX = NULL;\nPFNGLXGETSELECTEDEVENTSGIXPROC __glewXGetSelectedEventSGIX = NULL;\nPFNGLXQUERYGLXPBUFFERSGIXPROC __glewXQueryGLXPbufferSGIX = NULL;\nPFNGLXSELECTEVENTSGIXPROC __glewXSelectEventSGIX = NULL;\n\nPFNGLXBINDSWAPBARRIERSGIXPROC __glewXBindSwapBarrierSGIX = NULL;\nPFNGLXQUERYMAXSWAPBARRIERSSGIXPROC __glewXQueryMaxSwapBarriersSGIX = NULL;\n\nPFNGLXJOINSWAPGROUPSGIXPROC __glewXJoinSwapGroupSGIX = NULL;\n\nPFNGLXBINDCHANNELTOWINDOWSGIXPROC __glewXBindChannelToWindowSGIX = NULL;\nPFNGLXCHANNELRECTSGIXPROC __glewXChannelRectSGIX = NULL;\nPFNGLXCHANNELRECTSYNCSGIXPROC __glewXChannelRectSyncSGIX = NULL;\nPFNGLXQUERYCHANNELDELTASSGIXPROC __glewXQueryChannelDeltasSGIX = NULL;\nPFNGLXQUERYCHANNELRECTSGIXPROC __glewXQueryChannelRectSGIX = NULL;\n\nPFNGLXCUSHIONSGIPROC __glewXCushionSGI = NULL;\n\nPFNGLXGETCURRENTREADDRAWABLESGIPROC __glewXGetCurrentReadDrawableSGI = NULL;\nPFNGLXMAKECURRENTREADSGIPROC __glewXMakeCurrentReadSGI = NULL;\n\nPFNGLXSWAPINTERVALSGIPROC __glewXSwapIntervalSGI = NULL;\n\nPFNGLXGETVIDEOSYNCSGIPROC __glewXGetVideoSyncSGI = NULL;\nPFNGLXWAITVIDEOSYNCSGIPROC __glewXWaitVideoSyncSGI = NULL;\n\nPFNGLXGETTRANSPARENTINDEXSUNPROC __glewXGetTransparentIndexSUN = NULL;\n\nPFNGLXGETVIDEORESIZESUNPROC __glewXGetVideoResizeSUN = NULL;\nPFNGLXVIDEORESIZESUNPROC __glewXVideoResizeSUN = NULL;\n\n#if !defined(GLEW_MX)\n\nGLboolean __GLXEW_VERSION_1_0 = GL_FALSE;\nGLboolean __GLXEW_VERSION_1_1 = GL_FALSE;\nGLboolean __GLXEW_VERSION_1_2 = GL_FALSE;\nGLboolean __GLXEW_VERSION_1_3 = GL_FALSE;\nGLboolean __GLXEW_VERSION_1_4 = GL_FALSE;\nGLboolean __GLXEW_3DFX_multisample = GL_FALSE;\nGLboolean __GLXEW_ARB_create_context = GL_FALSE;\nGLboolean __GLXEW_ARB_fbconfig_float = GL_FALSE;\nGLboolean __GLXEW_ARB_framebuffer_sRGB = GL_FALSE;\nGLboolean __GLXEW_ARB_get_proc_address = GL_FALSE;\nGLboolean __GLXEW_ARB_multisample = GL_FALSE;\nGLboolean __GLXEW_ATI_pixel_format_float = GL_FALSE;\nGLboolean __GLXEW_ATI_render_texture = GL_FALSE;\nGLboolean __GLXEW_EXT_fbconfig_packed_float = GL_FALSE;\nGLboolean __GLXEW_EXT_framebuffer_sRGB = GL_FALSE;\nGLboolean __GLXEW_EXT_import_context = GL_FALSE;\nGLboolean __GLXEW_EXT_scene_marker = GL_FALSE;\nGLboolean __GLXEW_EXT_texture_from_pixmap = GL_FALSE;\nGLboolean __GLXEW_EXT_visual_info = GL_FALSE;\nGLboolean __GLXEW_EXT_visual_rating = GL_FALSE;\nGLboolean __GLXEW_MESA_agp_offset = GL_FALSE;\nGLboolean __GLXEW_MESA_copy_sub_buffer = GL_FALSE;\nGLboolean __GLXEW_MESA_pixmap_colormap = GL_FALSE;\nGLboolean __GLXEW_MESA_release_buffers = GL_FALSE;\nGLboolean __GLXEW_MESA_set_3dfx_mode = GL_FALSE;\nGLboolean __GLXEW_NV_float_buffer = GL_FALSE;\nGLboolean __GLXEW_NV_present_video = GL_FALSE;\nGLboolean __GLXEW_NV_swap_group = GL_FALSE;\nGLboolean __GLXEW_NV_vertex_array_range = GL_FALSE;\nGLboolean __GLXEW_NV_video_output = GL_FALSE;\nGLboolean __GLXEW_OML_swap_method = GL_FALSE;\n#ifdef GLX_OML_sync_control\nGLboolean __GLXEW_OML_sync_control = GL_FALSE;\n#endif\nGLboolean __GLXEW_SGIS_blended_overlay = GL_FALSE;\nGLboolean __GLXEW_SGIS_color_range = GL_FALSE;\nGLboolean __GLXEW_SGIS_multisample = GL_FALSE;\nGLboolean __GLXEW_SGIS_shared_multisample = GL_FALSE;\nGLboolean __GLXEW_SGIX_fbconfig = GL_FALSE;\nGLboolean __GLXEW_SGIX_hyperpipe = GL_FALSE;\nGLboolean __GLXEW_SGIX_pbuffer = GL_FALSE;\nGLboolean __GLXEW_SGIX_swap_barrier = GL_FALSE;\nGLboolean __GLXEW_SGIX_swap_group = GL_FALSE;\nGLboolean __GLXEW_SGIX_video_resize = GL_FALSE;\nGLboolean __GLXEW_SGIX_visual_select_group = GL_FALSE;\nGLboolean __GLXEW_SGI_cushion = GL_FALSE;\nGLboolean __GLXEW_SGI_make_current_read = GL_FALSE;\nGLboolean __GLXEW_SGI_swap_control = GL_FALSE;\nGLboolean __GLXEW_SGI_video_sync = GL_FALSE;\nGLboolean __GLXEW_SUN_get_transparent_index = GL_FALSE;\nGLboolean __GLXEW_SUN_video_resize = GL_FALSE;\n\n#endif /* !GLEW_MX */\n\n#ifdef GLX_VERSION_1_2\n\nstatic GLboolean _glewInit_GLX_VERSION_1_2 (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXGetCurrentDisplay = (PFNGLXGETCURRENTDISPLAYPROC)glewGetProcAddress((const GLubyte*)\"glXGetCurrentDisplay\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_VERSION_1_2 */\n\n#ifdef GLX_VERSION_1_3\n\nstatic GLboolean _glewInit_GLX_VERSION_1_3 (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXChooseFBConfig = (PFNGLXCHOOSEFBCONFIGPROC)glewGetProcAddress((const GLubyte*)\"glXChooseFBConfig\")) == NULL) || r;\n  r = ((glXCreateNewContext = (PFNGLXCREATENEWCONTEXTPROC)glewGetProcAddress((const GLubyte*)\"glXCreateNewContext\")) == NULL) || r;\n  r = ((glXCreatePbuffer = (PFNGLXCREATEPBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glXCreatePbuffer\")) == NULL) || r;\n  r = ((glXCreatePixmap = (PFNGLXCREATEPIXMAPPROC)glewGetProcAddress((const GLubyte*)\"glXCreatePixmap\")) == NULL) || r;\n  r = ((glXCreateWindow = (PFNGLXCREATEWINDOWPROC)glewGetProcAddress((const GLubyte*)\"glXCreateWindow\")) == NULL) || r;\n  r = ((glXDestroyPbuffer = (PFNGLXDESTROYPBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glXDestroyPbuffer\")) == NULL) || r;\n  r = ((glXDestroyPixmap = (PFNGLXDESTROYPIXMAPPROC)glewGetProcAddress((const GLubyte*)\"glXDestroyPixmap\")) == NULL) || r;\n  r = ((glXDestroyWindow = (PFNGLXDESTROYWINDOWPROC)glewGetProcAddress((const GLubyte*)\"glXDestroyWindow\")) == NULL) || r;\n  r = ((glXGetCurrentReadDrawable = (PFNGLXGETCURRENTREADDRAWABLEPROC)glewGetProcAddress((const GLubyte*)\"glXGetCurrentReadDrawable\")) == NULL) || r;\n  r = ((glXGetFBConfigAttrib = (PFNGLXGETFBCONFIGATTRIBPROC)glewGetProcAddress((const GLubyte*)\"glXGetFBConfigAttrib\")) == NULL) || r;\n  r = ((glXGetFBConfigs = (PFNGLXGETFBCONFIGSPROC)glewGetProcAddress((const GLubyte*)\"glXGetFBConfigs\")) == NULL) || r;\n  r = ((glXGetSelectedEvent = (PFNGLXGETSELECTEDEVENTPROC)glewGetProcAddress((const GLubyte*)\"glXGetSelectedEvent\")) == NULL) || r;\n  r = ((glXGetVisualFromFBConfig = (PFNGLXGETVISUALFROMFBCONFIGPROC)glewGetProcAddress((const GLubyte*)\"glXGetVisualFromFBConfig\")) == NULL) || r;\n  r = ((glXMakeContextCurrent = (PFNGLXMAKECONTEXTCURRENTPROC)glewGetProcAddress((const GLubyte*)\"glXMakeContextCurrent\")) == NULL) || r;\n  r = ((glXQueryContext = (PFNGLXQUERYCONTEXTPROC)glewGetProcAddress((const GLubyte*)\"glXQueryContext\")) == NULL) || r;\n  r = ((glXQueryDrawable = (PFNGLXQUERYDRAWABLEPROC)glewGetProcAddress((const GLubyte*)\"glXQueryDrawable\")) == NULL) || r;\n  r = ((glXSelectEvent = (PFNGLXSELECTEVENTPROC)glewGetProcAddress((const GLubyte*)\"glXSelectEvent\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_VERSION_1_3 */\n\n#ifdef GLX_VERSION_1_4\n\n#endif /* GLX_VERSION_1_4 */\n\n#ifdef GLX_3DFX_multisample\n\n#endif /* GLX_3DFX_multisample */\n\n#ifdef GLX_ARB_create_context\n\nstatic GLboolean _glewInit_GLX_ARB_create_context (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXCreateContextAttribsARB = (PFNGLXCREATECONTEXTATTRIBSARBPROC)glewGetProcAddress((const GLubyte*)\"glXCreateContextAttribsARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_ARB_create_context */\n\n#ifdef GLX_ARB_fbconfig_float\n\n#endif /* GLX_ARB_fbconfig_float */\n\n#ifdef GLX_ARB_framebuffer_sRGB\n\n#endif /* GLX_ARB_framebuffer_sRGB */\n\n#ifdef GLX_ARB_get_proc_address\n\n#endif /* GLX_ARB_get_proc_address */\n\n#ifdef GLX_ARB_multisample\n\n#endif /* GLX_ARB_multisample */\n\n#ifdef GLX_ATI_pixel_format_float\n\n#endif /* GLX_ATI_pixel_format_float */\n\n#ifdef GLX_ATI_render_texture\n\nstatic GLboolean _glewInit_GLX_ATI_render_texture (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXBindTexImageATI = (PFNGLXBINDTEXIMAGEATIPROC)glewGetProcAddress((const GLubyte*)\"glXBindTexImageATI\")) == NULL) || r;\n  r = ((glXDrawableAttribATI = (PFNGLXDRAWABLEATTRIBATIPROC)glewGetProcAddress((const GLubyte*)\"glXDrawableAttribATI\")) == NULL) || r;\n  r = ((glXReleaseTexImageATI = (PFNGLXRELEASETEXIMAGEATIPROC)glewGetProcAddress((const GLubyte*)\"glXReleaseTexImageATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_ATI_render_texture */\n\n#ifdef GLX_EXT_fbconfig_packed_float\n\n#endif /* GLX_EXT_fbconfig_packed_float */\n\n#ifdef GLX_EXT_framebuffer_sRGB\n\n#endif /* GLX_EXT_framebuffer_sRGB */\n\n#ifdef GLX_EXT_import_context\n\nstatic GLboolean _glewInit_GLX_EXT_import_context (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXFreeContextEXT = (PFNGLXFREECONTEXTEXTPROC)glewGetProcAddress((const GLubyte*)\"glXFreeContextEXT\")) == NULL) || r;\n  r = ((glXGetContextIDEXT = (PFNGLXGETCONTEXTIDEXTPROC)glewGetProcAddress((const GLubyte*)\"glXGetContextIDEXT\")) == NULL) || r;\n  r = ((glXImportContextEXT = (PFNGLXIMPORTCONTEXTEXTPROC)glewGetProcAddress((const GLubyte*)\"glXImportContextEXT\")) == NULL) || r;\n  r = ((glXQueryContextInfoEXT = (PFNGLXQUERYCONTEXTINFOEXTPROC)glewGetProcAddress((const GLubyte*)\"glXQueryContextInfoEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_EXT_import_context */\n\n#ifdef GLX_EXT_scene_marker\n\n#endif /* GLX_EXT_scene_marker */\n\n#ifdef GLX_EXT_texture_from_pixmap\n\nstatic GLboolean _glewInit_GLX_EXT_texture_from_pixmap (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXBindTexImageEXT = (PFNGLXBINDTEXIMAGEEXTPROC)glewGetProcAddress((const GLubyte*)\"glXBindTexImageEXT\")) == NULL) || r;\n  r = ((glXReleaseTexImageEXT = (PFNGLXRELEASETEXIMAGEEXTPROC)glewGetProcAddress((const GLubyte*)\"glXReleaseTexImageEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_EXT_texture_from_pixmap */\n\n#ifdef GLX_EXT_visual_info\n\n#endif /* GLX_EXT_visual_info */\n\n#ifdef GLX_EXT_visual_rating\n\n#endif /* GLX_EXT_visual_rating */\n\n#ifdef GLX_MESA_agp_offset\n\nstatic GLboolean _glewInit_GLX_MESA_agp_offset (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXGetAGPOffsetMESA = (PFNGLXGETAGPOFFSETMESAPROC)glewGetProcAddress((const GLubyte*)\"glXGetAGPOffsetMESA\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_MESA_agp_offset */\n\n#ifdef GLX_MESA_copy_sub_buffer\n\nstatic GLboolean _glewInit_GLX_MESA_copy_sub_buffer (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXCopySubBufferMESA = (PFNGLXCOPYSUBBUFFERMESAPROC)glewGetProcAddress((const GLubyte*)\"glXCopySubBufferMESA\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_MESA_copy_sub_buffer */\n\n#ifdef GLX_MESA_pixmap_colormap\n\nstatic GLboolean _glewInit_GLX_MESA_pixmap_colormap (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXCreateGLXPixmapMESA = (PFNGLXCREATEGLXPIXMAPMESAPROC)glewGetProcAddress((const GLubyte*)\"glXCreateGLXPixmapMESA\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_MESA_pixmap_colormap */\n\n#ifdef GLX_MESA_release_buffers\n\nstatic GLboolean _glewInit_GLX_MESA_release_buffers (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXReleaseBuffersMESA = (PFNGLXRELEASEBUFFERSMESAPROC)glewGetProcAddress((const GLubyte*)\"glXReleaseBuffersMESA\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_MESA_release_buffers */\n\n#ifdef GLX_MESA_set_3dfx_mode\n\nstatic GLboolean _glewInit_GLX_MESA_set_3dfx_mode (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXSet3DfxModeMESA = (PFNGLXSET3DFXMODEMESAPROC)glewGetProcAddress((const GLubyte*)\"glXSet3DfxModeMESA\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_MESA_set_3dfx_mode */\n\n#ifdef GLX_NV_float_buffer\n\n#endif /* GLX_NV_float_buffer */\n\n#ifdef GLX_NV_present_video\n\nstatic GLboolean _glewInit_GLX_NV_present_video (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXBindVideoDeviceNV = (PFNGLXBINDVIDEODEVICENVPROC)glewGetProcAddress((const GLubyte*)\"glXBindVideoDeviceNV\")) == NULL) || r;\n  r = ((glXEnumerateVideoDevicesNV = (PFNGLXENUMERATEVIDEODEVICESNVPROC)glewGetProcAddress((const GLubyte*)\"glXEnumerateVideoDevicesNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_NV_present_video */\n\n#ifdef GLX_NV_swap_group\n\nstatic GLboolean _glewInit_GLX_NV_swap_group (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXBindSwapBarrierNV = (PFNGLXBINDSWAPBARRIERNVPROC)glewGetProcAddress((const GLubyte*)\"glXBindSwapBarrierNV\")) == NULL) || r;\n  r = ((glXJoinSwapGroupNV = (PFNGLXJOINSWAPGROUPNVPROC)glewGetProcAddress((const GLubyte*)\"glXJoinSwapGroupNV\")) == NULL) || r;\n  r = ((glXQueryFrameCountNV = (PFNGLXQUERYFRAMECOUNTNVPROC)glewGetProcAddress((const GLubyte*)\"glXQueryFrameCountNV\")) == NULL) || r;\n  r = ((glXQueryMaxSwapGroupsNV = (PFNGLXQUERYMAXSWAPGROUPSNVPROC)glewGetProcAddress((const GLubyte*)\"glXQueryMaxSwapGroupsNV\")) == NULL) || r;\n  r = ((glXQuerySwapGroupNV = (PFNGLXQUERYSWAPGROUPNVPROC)glewGetProcAddress((const GLubyte*)\"glXQuerySwapGroupNV\")) == NULL) || r;\n  r = ((glXResetFrameCountNV = (PFNGLXRESETFRAMECOUNTNVPROC)glewGetProcAddress((const GLubyte*)\"glXResetFrameCountNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_NV_swap_group */\n\n#ifdef GLX_NV_vertex_array_range\n\nstatic GLboolean _glewInit_GLX_NV_vertex_array_range (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXAllocateMemoryNV = (PFNGLXALLOCATEMEMORYNVPROC)glewGetProcAddress((const GLubyte*)\"glXAllocateMemoryNV\")) == NULL) || r;\n  r = ((glXFreeMemoryNV = (PFNGLXFREEMEMORYNVPROC)glewGetProcAddress((const GLubyte*)\"glXFreeMemoryNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_NV_vertex_array_range */\n\n#ifdef GLX_NV_video_output\n\nstatic GLboolean _glewInit_GLX_NV_video_output (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXBindVideoImageNV = (PFNGLXBINDVIDEOIMAGENVPROC)glewGetProcAddress((const GLubyte*)\"glXBindVideoImageNV\")) == NULL) || r;\n  r = ((glXGetVideoDeviceNV = (PFNGLXGETVIDEODEVICENVPROC)glewGetProcAddress((const GLubyte*)\"glXGetVideoDeviceNV\")) == NULL) || r;\n  r = ((glXGetVideoInfoNV = (PFNGLXGETVIDEOINFONVPROC)glewGetProcAddress((const GLubyte*)\"glXGetVideoInfoNV\")) == NULL) || r;\n  r = ((glXReleaseVideoDeviceNV = (PFNGLXRELEASEVIDEODEVICENVPROC)glewGetProcAddress((const GLubyte*)\"glXReleaseVideoDeviceNV\")) == NULL) || r;\n  r = ((glXReleaseVideoImageNV = (PFNGLXRELEASEVIDEOIMAGENVPROC)glewGetProcAddress((const GLubyte*)\"glXReleaseVideoImageNV\")) == NULL) || r;\n  r = ((glXSendPbufferToVideoNV = (PFNGLXSENDPBUFFERTOVIDEONVPROC)glewGetProcAddress((const GLubyte*)\"glXSendPbufferToVideoNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_NV_video_output */\n\n#ifdef GLX_OML_swap_method\n\n#endif /* GLX_OML_swap_method */\n\n#if defined(GLX_OML_sync_control) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\n#include <inttypes.h>\n\nstatic GLboolean _glewInit_GLX_OML_sync_control (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXGetMscRateOML = (PFNGLXGETMSCRATEOMLPROC)glewGetProcAddress((const GLubyte*)\"glXGetMscRateOML\")) == NULL) || r;\n  r = ((glXGetSyncValuesOML = (PFNGLXGETSYNCVALUESOMLPROC)glewGetProcAddress((const GLubyte*)\"glXGetSyncValuesOML\")) == NULL) || r;\n  r = ((glXSwapBuffersMscOML = (PFNGLXSWAPBUFFERSMSCOMLPROC)glewGetProcAddress((const GLubyte*)\"glXSwapBuffersMscOML\")) == NULL) || r;\n  r = ((glXWaitForMscOML = (PFNGLXWAITFORMSCOMLPROC)glewGetProcAddress((const GLubyte*)\"glXWaitForMscOML\")) == NULL) || r;\n  r = ((glXWaitForSbcOML = (PFNGLXWAITFORSBCOMLPROC)glewGetProcAddress((const GLubyte*)\"glXWaitForSbcOML\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_OML_sync_control */\n\n#ifdef GLX_SGIS_blended_overlay\n\n#endif /* GLX_SGIS_blended_overlay */\n\n#ifdef GLX_SGIS_color_range\n\n#endif /* GLX_SGIS_color_range */\n\n#ifdef GLX_SGIS_multisample\n\n#endif /* GLX_SGIS_multisample */\n\n#ifdef GLX_SGIS_shared_multisample\n\n#endif /* GLX_SGIS_shared_multisample */\n\n#ifdef GLX_SGIX_fbconfig\n\nstatic GLboolean _glewInit_GLX_SGIX_fbconfig (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXChooseFBConfigSGIX = (PFNGLXCHOOSEFBCONFIGSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXChooseFBConfigSGIX\")) == NULL) || r;\n  r = ((glXCreateContextWithConfigSGIX = (PFNGLXCREATECONTEXTWITHCONFIGSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXCreateContextWithConfigSGIX\")) == NULL) || r;\n  r = ((glXCreateGLXPixmapWithConfigSGIX = (PFNGLXCREATEGLXPIXMAPWITHCONFIGSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXCreateGLXPixmapWithConfigSGIX\")) == NULL) || r;\n  r = ((glXGetFBConfigAttribSGIX = (PFNGLXGETFBCONFIGATTRIBSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXGetFBConfigAttribSGIX\")) == NULL) || r;\n  r = ((glXGetFBConfigFromVisualSGIX = (PFNGLXGETFBCONFIGFROMVISUALSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXGetFBConfigFromVisualSGIX\")) == NULL) || r;\n  r = ((glXGetVisualFromFBConfigSGIX = (PFNGLXGETVISUALFROMFBCONFIGSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXGetVisualFromFBConfigSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SGIX_fbconfig */\n\n#ifdef GLX_SGIX_hyperpipe\n\nstatic GLboolean _glewInit_GLX_SGIX_hyperpipe (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXBindHyperpipeSGIX = (PFNGLXBINDHYPERPIPESGIXPROC)glewGetProcAddress((const GLubyte*)\"glXBindHyperpipeSGIX\")) == NULL) || r;\n  r = ((glXDestroyHyperpipeConfigSGIX = (PFNGLXDESTROYHYPERPIPECONFIGSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXDestroyHyperpipeConfigSGIX\")) == NULL) || r;\n  r = ((glXHyperpipeAttribSGIX = (PFNGLXHYPERPIPEATTRIBSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXHyperpipeAttribSGIX\")) == NULL) || r;\n  r = ((glXHyperpipeConfigSGIX = (PFNGLXHYPERPIPECONFIGSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXHyperpipeConfigSGIX\")) == NULL) || r;\n  r = ((glXQueryHyperpipeAttribSGIX = (PFNGLXQUERYHYPERPIPEATTRIBSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXQueryHyperpipeAttribSGIX\")) == NULL) || r;\n  r = ((glXQueryHyperpipeBestAttribSGIX = (PFNGLXQUERYHYPERPIPEBESTATTRIBSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXQueryHyperpipeBestAttribSGIX\")) == NULL) || r;\n  r = ((glXQueryHyperpipeConfigSGIX = (PFNGLXQUERYHYPERPIPECONFIGSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXQueryHyperpipeConfigSGIX\")) == NULL) || r;\n  r = ((glXQueryHyperpipeNetworkSGIX = (PFNGLXQUERYHYPERPIPENETWORKSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXQueryHyperpipeNetworkSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SGIX_hyperpipe */\n\n#ifdef GLX_SGIX_pbuffer\n\nstatic GLboolean _glewInit_GLX_SGIX_pbuffer (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXCreateGLXPbufferSGIX = (PFNGLXCREATEGLXPBUFFERSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXCreateGLXPbufferSGIX\")) == NULL) || r;\n  r = ((glXDestroyGLXPbufferSGIX = (PFNGLXDESTROYGLXPBUFFERSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXDestroyGLXPbufferSGIX\")) == NULL) || r;\n  r = ((glXGetSelectedEventSGIX = (PFNGLXGETSELECTEDEVENTSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXGetSelectedEventSGIX\")) == NULL) || r;\n  r = ((glXQueryGLXPbufferSGIX = (PFNGLXQUERYGLXPBUFFERSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXQueryGLXPbufferSGIX\")) == NULL) || r;\n  r = ((glXSelectEventSGIX = (PFNGLXSELECTEVENTSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXSelectEventSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SGIX_pbuffer */\n\n#ifdef GLX_SGIX_swap_barrier\n\nstatic GLboolean _glewInit_GLX_SGIX_swap_barrier (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXBindSwapBarrierSGIX = (PFNGLXBINDSWAPBARRIERSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXBindSwapBarrierSGIX\")) == NULL) || r;\n  r = ((glXQueryMaxSwapBarriersSGIX = (PFNGLXQUERYMAXSWAPBARRIERSSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXQueryMaxSwapBarriersSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SGIX_swap_barrier */\n\n#ifdef GLX_SGIX_swap_group\n\nstatic GLboolean _glewInit_GLX_SGIX_swap_group (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXJoinSwapGroupSGIX = (PFNGLXJOINSWAPGROUPSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXJoinSwapGroupSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SGIX_swap_group */\n\n#ifdef GLX_SGIX_video_resize\n\nstatic GLboolean _glewInit_GLX_SGIX_video_resize (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXBindChannelToWindowSGIX = (PFNGLXBINDCHANNELTOWINDOWSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXBindChannelToWindowSGIX\")) == NULL) || r;\n  r = ((glXChannelRectSGIX = (PFNGLXCHANNELRECTSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXChannelRectSGIX\")) == NULL) || r;\n  r = ((glXChannelRectSyncSGIX = (PFNGLXCHANNELRECTSYNCSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXChannelRectSyncSGIX\")) == NULL) || r;\n  r = ((glXQueryChannelDeltasSGIX = (PFNGLXQUERYCHANNELDELTASSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXQueryChannelDeltasSGIX\")) == NULL) || r;\n  r = ((glXQueryChannelRectSGIX = (PFNGLXQUERYCHANNELRECTSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXQueryChannelRectSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SGIX_video_resize */\n\n#ifdef GLX_SGIX_visual_select_group\n\n#endif /* GLX_SGIX_visual_select_group */\n\n#ifdef GLX_SGI_cushion\n\nstatic GLboolean _glewInit_GLX_SGI_cushion (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXCushionSGI = (PFNGLXCUSHIONSGIPROC)glewGetProcAddress((const GLubyte*)\"glXCushionSGI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SGI_cushion */\n\n#ifdef GLX_SGI_make_current_read\n\nstatic GLboolean _glewInit_GLX_SGI_make_current_read (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXGetCurrentReadDrawableSGI = (PFNGLXGETCURRENTREADDRAWABLESGIPROC)glewGetProcAddress((const GLubyte*)\"glXGetCurrentReadDrawableSGI\")) == NULL) || r;\n  r = ((glXMakeCurrentReadSGI = (PFNGLXMAKECURRENTREADSGIPROC)glewGetProcAddress((const GLubyte*)\"glXMakeCurrentReadSGI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SGI_make_current_read */\n\n#ifdef GLX_SGI_swap_control\n\nstatic GLboolean _glewInit_GLX_SGI_swap_control (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXSwapIntervalSGI = (PFNGLXSWAPINTERVALSGIPROC)glewGetProcAddress((const GLubyte*)\"glXSwapIntervalSGI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SGI_swap_control */\n\n#ifdef GLX_SGI_video_sync\n\nstatic GLboolean _glewInit_GLX_SGI_video_sync (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXGetVideoSyncSGI = (PFNGLXGETVIDEOSYNCSGIPROC)glewGetProcAddress((const GLubyte*)\"glXGetVideoSyncSGI\")) == NULL) || r;\n  r = ((glXWaitVideoSyncSGI = (PFNGLXWAITVIDEOSYNCSGIPROC)glewGetProcAddress((const GLubyte*)\"glXWaitVideoSyncSGI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SGI_video_sync */\n\n#ifdef GLX_SUN_get_transparent_index\n\nstatic GLboolean _glewInit_GLX_SUN_get_transparent_index (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXGetTransparentIndexSUN = (PFNGLXGETTRANSPARENTINDEXSUNPROC)glewGetProcAddress((const GLubyte*)\"glXGetTransparentIndexSUN\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SUN_get_transparent_index */\n\n#ifdef GLX_SUN_video_resize\n\nstatic GLboolean _glewInit_GLX_SUN_video_resize (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXGetVideoResizeSUN = (PFNGLXGETVIDEORESIZESUNPROC)glewGetProcAddress((const GLubyte*)\"glXGetVideoResizeSUN\")) == NULL) || r;\n  r = ((glXVideoResizeSUN = (PFNGLXVIDEORESIZESUNPROC)glewGetProcAddress((const GLubyte*)\"glXVideoResizeSUN\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SUN_video_resize */\n\n/* ------------------------------------------------------------------------ */\n\nGLboolean glxewGetExtension (const char* name)\n{\n  GLubyte* p;\n  GLubyte* end;\n  GLuint len = _glewStrLen((const GLubyte*)name);\n/*   if (glXQueryExtensionsString == NULL || glXGetCurrentDisplay == NULL) return GL_FALSE; */\n/*   p = (GLubyte*)glXQueryExtensionsString(glXGetCurrentDisplay(), DefaultScreen(glXGetCurrentDisplay())); */\n  if (glXGetCurrentDisplay == NULL) return GL_FALSE;\n  p = (GLubyte*)glXGetClientString(glXGetCurrentDisplay(), GLX_EXTENSIONS);\n  if (0 == p) return GL_FALSE;\n  end = p + _glewStrLen(p);\n  while (p < end)\n  {\n    GLuint n = _glewStrCLen(p, ' ');\n    if (len == n && _glewStrSame((const GLubyte*)name, p, n)) return GL_TRUE;\n    p += n+1;\n  }\n  return GL_FALSE;\n}\n\nGLenum glxewContextInit (GLXEW_CONTEXT_ARG_DEF_LIST)\n{\n  int major, minor;\n  /* initialize core GLX 1.2 */\n  if (_glewInit_GLX_VERSION_1_2(GLEW_CONTEXT_ARG_VAR_INIT)) return GLEW_ERROR_GLX_VERSION_11_ONLY;\n  /* initialize flags */\n  CONST_CAST(GLXEW_VERSION_1_0) = GL_TRUE;\n  CONST_CAST(GLXEW_VERSION_1_1) = GL_TRUE;\n  CONST_CAST(GLXEW_VERSION_1_2) = GL_TRUE;\n  CONST_CAST(GLXEW_VERSION_1_3) = GL_TRUE;\n  CONST_CAST(GLXEW_VERSION_1_4) = GL_TRUE;\n  /* query GLX version */\n  glXQueryVersion(glXGetCurrentDisplay(), &major, &minor);\n  if (major == 1 && minor <= 3)\n  {\n    switch (minor)\n    {\n      case 3:\n      CONST_CAST(GLXEW_VERSION_1_4) = GL_FALSE;\n      break;\n      case 2:\n      CONST_CAST(GLXEW_VERSION_1_4) = GL_FALSE;\n      CONST_CAST(GLXEW_VERSION_1_3) = GL_FALSE;\n      break;\n      default:\n      return GLEW_ERROR_GLX_VERSION_11_ONLY;\n      break;\n    }\n  }\n  /* initialize extensions */\n#ifdef GLX_VERSION_1_3\n  if (glewExperimental || GLXEW_VERSION_1_3) CONST_CAST(GLXEW_VERSION_1_3) = !_glewInit_GLX_VERSION_1_3(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_VERSION_1_3 */\n#ifdef GLX_3DFX_multisample\n  CONST_CAST(GLXEW_3DFX_multisample) = glxewGetExtension(\"GLX_3DFX_multisample\");\n#endif /* GLX_3DFX_multisample */\n#ifdef GLX_ARB_create_context\n  CONST_CAST(GLXEW_ARB_create_context) = glxewGetExtension(\"GLX_ARB_create_context\");\n  if (glewExperimental || GLXEW_ARB_create_context) CONST_CAST(GLXEW_ARB_create_context) = !_glewInit_GLX_ARB_create_context(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_ARB_create_context */\n#ifdef GLX_ARB_fbconfig_float\n  CONST_CAST(GLXEW_ARB_fbconfig_float) = glxewGetExtension(\"GLX_ARB_fbconfig_float\");\n#endif /* GLX_ARB_fbconfig_float */\n#ifdef GLX_ARB_framebuffer_sRGB\n  CONST_CAST(GLXEW_ARB_framebuffer_sRGB) = glxewGetExtension(\"GLX_ARB_framebuffer_sRGB\");\n#endif /* GLX_ARB_framebuffer_sRGB */\n#ifdef GLX_ARB_get_proc_address\n  CONST_CAST(GLXEW_ARB_get_proc_address) = glxewGetExtension(\"GLX_ARB_get_proc_address\");\n#endif /* GLX_ARB_get_proc_address */\n#ifdef GLX_ARB_multisample\n  CONST_CAST(GLXEW_ARB_multisample) = glxewGetExtension(\"GLX_ARB_multisample\");\n#endif /* GLX_ARB_multisample */\n#ifdef GLX_ATI_pixel_format_float\n  CONST_CAST(GLXEW_ATI_pixel_format_float) = glxewGetExtension(\"GLX_ATI_pixel_format_float\");\n#endif /* GLX_ATI_pixel_format_float */\n#ifdef GLX_ATI_render_texture\n  CONST_CAST(GLXEW_ATI_render_texture) = glxewGetExtension(\"GLX_ATI_render_texture\");\n  if (glewExperimental || GLXEW_ATI_render_texture) CONST_CAST(GLXEW_ATI_render_texture) = !_glewInit_GLX_ATI_render_texture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_ATI_render_texture */\n#ifdef GLX_EXT_fbconfig_packed_float\n  CONST_CAST(GLXEW_EXT_fbconfig_packed_float) = glxewGetExtension(\"GLX_EXT_fbconfig_packed_float\");\n#endif /* GLX_EXT_fbconfig_packed_float */\n#ifdef GLX_EXT_framebuffer_sRGB\n  CONST_CAST(GLXEW_EXT_framebuffer_sRGB) = glxewGetExtension(\"GLX_EXT_framebuffer_sRGB\");\n#endif /* GLX_EXT_framebuffer_sRGB */\n#ifdef GLX_EXT_import_context\n  CONST_CAST(GLXEW_EXT_import_context) = glxewGetExtension(\"GLX_EXT_import_context\");\n  if (glewExperimental || GLXEW_EXT_import_context) CONST_CAST(GLXEW_EXT_import_context) = !_glewInit_GLX_EXT_import_context(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_EXT_import_context */\n#ifdef GLX_EXT_scene_marker\n  CONST_CAST(GLXEW_EXT_scene_marker) = glxewGetExtension(\"GLX_EXT_scene_marker\");\n#endif /* GLX_EXT_scene_marker */\n#ifdef GLX_EXT_texture_from_pixmap\n  CONST_CAST(GLXEW_EXT_texture_from_pixmap) = glxewGetExtension(\"GLX_EXT_texture_from_pixmap\");\n  if (glewExperimental || GLXEW_EXT_texture_from_pixmap) CONST_CAST(GLXEW_EXT_texture_from_pixmap) = !_glewInit_GLX_EXT_texture_from_pixmap(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_EXT_texture_from_pixmap */\n#ifdef GLX_EXT_visual_info\n  CONST_CAST(GLXEW_EXT_visual_info) = glxewGetExtension(\"GLX_EXT_visual_info\");\n#endif /* GLX_EXT_visual_info */\n#ifdef GLX_EXT_visual_rating\n  CONST_CAST(GLXEW_EXT_visual_rating) = glxewGetExtension(\"GLX_EXT_visual_rating\");\n#endif /* GLX_EXT_visual_rating */\n#ifdef GLX_MESA_agp_offset\n  CONST_CAST(GLXEW_MESA_agp_offset) = glxewGetExtension(\"GLX_MESA_agp_offset\");\n  if (glewExperimental || GLXEW_MESA_agp_offset) CONST_CAST(GLXEW_MESA_agp_offset) = !_glewInit_GLX_MESA_agp_offset(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_MESA_agp_offset */\n#ifdef GLX_MESA_copy_sub_buffer\n  CONST_CAST(GLXEW_MESA_copy_sub_buffer) = glxewGetExtension(\"GLX_MESA_copy_sub_buffer\");\n  if (glewExperimental || GLXEW_MESA_copy_sub_buffer) CONST_CAST(GLXEW_MESA_copy_sub_buffer) = !_glewInit_GLX_MESA_copy_sub_buffer(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_MESA_copy_sub_buffer */\n#ifdef GLX_MESA_pixmap_colormap\n  CONST_CAST(GLXEW_MESA_pixmap_colormap) = glxewGetExtension(\"GLX_MESA_pixmap_colormap\");\n  if (glewExperimental || GLXEW_MESA_pixmap_colormap) CONST_CAST(GLXEW_MESA_pixmap_colormap) = !_glewInit_GLX_MESA_pixmap_colormap(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_MESA_pixmap_colormap */\n#ifdef GLX_MESA_release_buffers\n  CONST_CAST(GLXEW_MESA_release_buffers) = glxewGetExtension(\"GLX_MESA_release_buffers\");\n  if (glewExperimental || GLXEW_MESA_release_buffers) CONST_CAST(GLXEW_MESA_release_buffers) = !_glewInit_GLX_MESA_release_buffers(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_MESA_release_buffers */\n#ifdef GLX_MESA_set_3dfx_mode\n  CONST_CAST(GLXEW_MESA_set_3dfx_mode) = glxewGetExtension(\"GLX_MESA_set_3dfx_mode\");\n  if (glewExperimental || GLXEW_MESA_set_3dfx_mode) CONST_CAST(GLXEW_MESA_set_3dfx_mode) = !_glewInit_GLX_MESA_set_3dfx_mode(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_MESA_set_3dfx_mode */\n#ifdef GLX_NV_float_buffer\n  CONST_CAST(GLXEW_NV_float_buffer) = glxewGetExtension(\"GLX_NV_float_buffer\");\n#endif /* GLX_NV_float_buffer */\n#ifdef GLX_NV_present_video\n  CONST_CAST(GLXEW_NV_present_video) = glxewGetExtension(\"GLX_NV_present_video\");\n  if (glewExperimental || GLXEW_NV_present_video) CONST_CAST(GLXEW_NV_present_video) = !_glewInit_GLX_NV_present_video(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_NV_present_video */\n#ifdef GLX_NV_swap_group\n  CONST_CAST(GLXEW_NV_swap_group) = glxewGetExtension(\"GLX_NV_swap_group\");\n  if (glewExperimental || GLXEW_NV_swap_group) CONST_CAST(GLXEW_NV_swap_group) = !_glewInit_GLX_NV_swap_group(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_NV_swap_group */\n#ifdef GLX_NV_vertex_array_range\n  CONST_CAST(GLXEW_NV_vertex_array_range) = glxewGetExtension(\"GLX_NV_vertex_array_range\");\n  if (glewExperimental || GLXEW_NV_vertex_array_range) CONST_CAST(GLXEW_NV_vertex_array_range) = !_glewInit_GLX_NV_vertex_array_range(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_NV_vertex_array_range */\n#ifdef GLX_NV_video_output\n  CONST_CAST(GLXEW_NV_video_output) = glxewGetExtension(\"GLX_NV_video_output\");\n  if (glewExperimental || GLXEW_NV_video_output) CONST_CAST(GLXEW_NV_video_output) = !_glewInit_GLX_NV_video_output(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_NV_video_output */\n#ifdef GLX_OML_swap_method\n  CONST_CAST(GLXEW_OML_swap_method) = glxewGetExtension(\"GLX_OML_swap_method\");\n#endif /* GLX_OML_swap_method */\n#if defined(GLX_OML_sync_control) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\n#include <inttypes.h>\n  CONST_CAST(GLXEW_OML_sync_control) = glxewGetExtension(\"GLX_OML_sync_control\");\n  if (glewExperimental || GLXEW_OML_sync_control) CONST_CAST(GLXEW_OML_sync_control) = !_glewInit_GLX_OML_sync_control(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_OML_sync_control */\n#ifdef GLX_SGIS_blended_overlay\n  CONST_CAST(GLXEW_SGIS_blended_overlay) = glxewGetExtension(\"GLX_SGIS_blended_overlay\");\n#endif /* GLX_SGIS_blended_overlay */\n#ifdef GLX_SGIS_color_range\n  CONST_CAST(GLXEW_SGIS_color_range) = glxewGetExtension(\"GLX_SGIS_color_range\");\n#endif /* GLX_SGIS_color_range */\n#ifdef GLX_SGIS_multisample\n  CONST_CAST(GLXEW_SGIS_multisample) = glxewGetExtension(\"GLX_SGIS_multisample\");\n#endif /* GLX_SGIS_multisample */\n#ifdef GLX_SGIS_shared_multisample\n  CONST_CAST(GLXEW_SGIS_shared_multisample) = glxewGetExtension(\"GLX_SGIS_shared_multisample\");\n#endif /* GLX_SGIS_shared_multisample */\n#ifdef GLX_SGIX_fbconfig\n  CONST_CAST(GLXEW_SGIX_fbconfig) = glxewGetExtension(\"GLX_SGIX_fbconfig\");\n  if (glewExperimental || GLXEW_SGIX_fbconfig) CONST_CAST(GLXEW_SGIX_fbconfig) = !_glewInit_GLX_SGIX_fbconfig(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SGIX_fbconfig */\n#ifdef GLX_SGIX_hyperpipe\n  CONST_CAST(GLXEW_SGIX_hyperpipe) = glxewGetExtension(\"GLX_SGIX_hyperpipe\");\n  if (glewExperimental || GLXEW_SGIX_hyperpipe) CONST_CAST(GLXEW_SGIX_hyperpipe) = !_glewInit_GLX_SGIX_hyperpipe(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SGIX_hyperpipe */\n#ifdef GLX_SGIX_pbuffer\n  CONST_CAST(GLXEW_SGIX_pbuffer) = glxewGetExtension(\"GLX_SGIX_pbuffer\");\n  if (glewExperimental || GLXEW_SGIX_pbuffer) CONST_CAST(GLXEW_SGIX_pbuffer) = !_glewInit_GLX_SGIX_pbuffer(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SGIX_pbuffer */\n#ifdef GLX_SGIX_swap_barrier\n  CONST_CAST(GLXEW_SGIX_swap_barrier) = glxewGetExtension(\"GLX_SGIX_swap_barrier\");\n  if (glewExperimental || GLXEW_SGIX_swap_barrier) CONST_CAST(GLXEW_SGIX_swap_barrier) = !_glewInit_GLX_SGIX_swap_barrier(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SGIX_swap_barrier */\n#ifdef GLX_SGIX_swap_group\n  CONST_CAST(GLXEW_SGIX_swap_group) = glxewGetExtension(\"GLX_SGIX_swap_group\");\n  if (glewExperimental || GLXEW_SGIX_swap_group) CONST_CAST(GLXEW_SGIX_swap_group) = !_glewInit_GLX_SGIX_swap_group(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SGIX_swap_group */\n#ifdef GLX_SGIX_video_resize\n  CONST_CAST(GLXEW_SGIX_video_resize) = glxewGetExtension(\"GLX_SGIX_video_resize\");\n  if (glewExperimental || GLXEW_SGIX_video_resize) CONST_CAST(GLXEW_SGIX_video_resize) = !_glewInit_GLX_SGIX_video_resize(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SGIX_video_resize */\n#ifdef GLX_SGIX_visual_select_group\n  CONST_CAST(GLXEW_SGIX_visual_select_group) = glxewGetExtension(\"GLX_SGIX_visual_select_group\");\n#endif /* GLX_SGIX_visual_select_group */\n#ifdef GLX_SGI_cushion\n  CONST_CAST(GLXEW_SGI_cushion) = glxewGetExtension(\"GLX_SGI_cushion\");\n  if (glewExperimental || GLXEW_SGI_cushion) CONST_CAST(GLXEW_SGI_cushion) = !_glewInit_GLX_SGI_cushion(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SGI_cushion */\n#ifdef GLX_SGI_make_current_read\n  CONST_CAST(GLXEW_SGI_make_current_read) = glxewGetExtension(\"GLX_SGI_make_current_read\");\n  if (glewExperimental || GLXEW_SGI_make_current_read) CONST_CAST(GLXEW_SGI_make_current_read) = !_glewInit_GLX_SGI_make_current_read(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SGI_make_current_read */\n#ifdef GLX_SGI_swap_control\n  CONST_CAST(GLXEW_SGI_swap_control) = glxewGetExtension(\"GLX_SGI_swap_control\");\n  if (glewExperimental || GLXEW_SGI_swap_control) CONST_CAST(GLXEW_SGI_swap_control) = !_glewInit_GLX_SGI_swap_control(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SGI_swap_control */\n#ifdef GLX_SGI_video_sync\n  CONST_CAST(GLXEW_SGI_video_sync) = glxewGetExtension(\"GLX_SGI_video_sync\");\n  if (glewExperimental || GLXEW_SGI_video_sync) CONST_CAST(GLXEW_SGI_video_sync) = !_glewInit_GLX_SGI_video_sync(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SGI_video_sync */\n#ifdef GLX_SUN_get_transparent_index\n  CONST_CAST(GLXEW_SUN_get_transparent_index) = glxewGetExtension(\"GLX_SUN_get_transparent_index\");\n  if (glewExperimental || GLXEW_SUN_get_transparent_index) CONST_CAST(GLXEW_SUN_get_transparent_index) = !_glewInit_GLX_SUN_get_transparent_index(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SUN_get_transparent_index */\n#ifdef GLX_SUN_video_resize\n  CONST_CAST(GLXEW_SUN_video_resize) = glxewGetExtension(\"GLX_SUN_video_resize\");\n  if (glewExperimental || GLXEW_SUN_video_resize) CONST_CAST(GLXEW_SUN_video_resize) = !_glewInit_GLX_SUN_video_resize(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SUN_video_resize */\n\n  return GLEW_OK;\n}\n\n#endif /* !__APPLE__ || GLEW_APPLE_GLX */\n\n/* ------------------------------------------------------------------------ */\n\nconst GLubyte* glewGetErrorString (GLenum error)\n{\n  static const GLubyte* _glewErrorString[] =\n  {\n    (const GLubyte*)\"No error\",\n    (const GLubyte*)\"Missing GL version\",\n    (const GLubyte*)\"GL 1.1 and up are not supported\",\n    (const GLubyte*)\"GLX 1.2 and up are not supported\",\n    (const GLubyte*)\"Unknown error\"\n  };\n  const int max_error = sizeof(_glewErrorString)/sizeof(*_glewErrorString) - 1;\n  return _glewErrorString[(int)error > max_error ? max_error : (int)error];\n}\n\nconst GLubyte* glewGetString (GLenum name)\n{\n  static const GLubyte* _glewString[] =\n  {\n    (const GLubyte*)NULL,\n    (const GLubyte*)\"1.5.1\",\n    (const GLubyte*)\"1\",\n    (const GLubyte*)\"5\",\n    (const GLubyte*)\"1\"\n  };\n  const int max_string = sizeof(_glewString)/sizeof(*_glewString) - 1;\n  return _glewString[(int)name > max_string ? 0 : (int)name];\n}\n\n/* ------------------------------------------------------------------------ */\n\nGLboolean glewExperimental = GL_FALSE;\n\n#if !defined(GLEW_MX)\n\n#if defined(_WIN32)\nextern GLenum wglewContextInit (void);\n#elif !defined(__APPLE__) || defined(GLEW_APPLE_GLX) /* _UNIX */\nextern GLenum glxewContextInit (void);\n#endif /* _WIN32 */\n\nGLenum glewInit ()\n{\n  GLenum r;\n  if ( (r = glewContextInit()) ) return r;\n#if defined(_WIN32)\n  return wglewContextInit();\n#elif !defined(__APPLE__) || defined(GLEW_APPLE_GLX) /* _UNIX */\n  return glxewContextInit();\n#else\n  return r;\n#endif /* _WIN32 */\n}\n\n#endif /* !GLEW_MX */\n#ifdef GLEW_MX\nGLboolean glewContextIsSupported (GLEWContext* ctx, const char* name)\n#else\nGLboolean glewIsSupported (const char* name)\n#endif\n{\n  GLubyte* pos = (GLubyte*)name;\n  GLuint len = _glewStrLen(pos);\n  GLboolean ret = GL_TRUE;\n  while (ret && len > 0)\n  {\n    if (_glewStrSame1(&pos, &len, (const GLubyte*)\"GL_\", 3))\n    {\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"VERSION_\", 8))\n      {\n#ifdef GL_VERSION_1_2\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"1_2\", 3))\n        {\n          ret = GLEW_VERSION_1_2;\n          continue;\n        }\n#endif\n#ifdef GL_VERSION_1_3\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"1_3\", 3))\n        {\n          ret = GLEW_VERSION_1_3;\n          continue;\n        }\n#endif\n#ifdef GL_VERSION_1_4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"1_4\", 3))\n        {\n          ret = GLEW_VERSION_1_4;\n          continue;\n        }\n#endif\n#ifdef GL_VERSION_1_5\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"1_5\", 3))\n        {\n          ret = GLEW_VERSION_1_5;\n          continue;\n        }\n#endif\n#ifdef GL_VERSION_2_0\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"2_0\", 3))\n        {\n          ret = GLEW_VERSION_2_0;\n          continue;\n        }\n#endif\n#ifdef GL_VERSION_2_1\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"2_1\", 3))\n        {\n          ret = GLEW_VERSION_2_1;\n          continue;\n        }\n#endif\n#ifdef GL_VERSION_3_0\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"3_0\", 3))\n        {\n          ret = GLEW_VERSION_3_0;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"3DFX_\", 5))\n      {\n#ifdef GL_3DFX_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample\", 11))\n        {\n          ret = GLEW_3DFX_multisample;\n          continue;\n        }\n#endif\n#ifdef GL_3DFX_tbuffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"tbuffer\", 7))\n        {\n          ret = GLEW_3DFX_tbuffer;\n          continue;\n        }\n#endif\n#ifdef GL_3DFX_texture_compression_FXT1\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_compression_FXT1\", 24))\n        {\n          ret = GLEW_3DFX_texture_compression_FXT1;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"APPLE_\", 6))\n      {\n#ifdef GL_APPLE_client_storage\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"client_storage\", 14))\n        {\n          ret = GLEW_APPLE_client_storage;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_element_array\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"element_array\", 13))\n        {\n          ret = GLEW_APPLE_element_array;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_fence\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fence\", 5))\n        {\n          ret = GLEW_APPLE_fence;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_float_pixels\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"float_pixels\", 12))\n        {\n          ret = GLEW_APPLE_float_pixels;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_flush_buffer_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"flush_buffer_range\", 18))\n        {\n          ret = GLEW_APPLE_flush_buffer_range;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_pixel_buffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_buffer\", 12))\n        {\n          ret = GLEW_APPLE_pixel_buffer;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_specular_vector\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"specular_vector\", 15))\n        {\n          ret = GLEW_APPLE_specular_vector;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_texture_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_range\", 13))\n        {\n          ret = GLEW_APPLE_texture_range;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_transform_hint\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"transform_hint\", 14))\n        {\n          ret = GLEW_APPLE_transform_hint;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_vertex_array_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array_object\", 19))\n        {\n          ret = GLEW_APPLE_vertex_array_object;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_vertex_array_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array_range\", 18))\n        {\n          ret = GLEW_APPLE_vertex_array_range;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_ycbcr_422\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"ycbcr_422\", 9))\n        {\n          ret = GLEW_APPLE_ycbcr_422;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"ARB_\", 4))\n      {\n#ifdef GL_ARB_color_buffer_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"color_buffer_float\", 18))\n        {\n          ret = GLEW_ARB_color_buffer_float;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_depth_buffer_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"depth_buffer_float\", 18))\n        {\n          ret = GLEW_ARB_depth_buffer_float;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_depth_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"depth_texture\", 13))\n        {\n          ret = GLEW_ARB_depth_texture;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_draw_buffers\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"draw_buffers\", 12))\n        {\n          ret = GLEW_ARB_draw_buffers;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_draw_instanced\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"draw_instanced\", 14))\n        {\n          ret = GLEW_ARB_draw_instanced;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_fragment_program\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fragment_program\", 16))\n        {\n          ret = GLEW_ARB_fragment_program;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_fragment_program_shadow\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fragment_program_shadow\", 23))\n        {\n          ret = GLEW_ARB_fragment_program_shadow;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_fragment_shader\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fragment_shader\", 15))\n        {\n          ret = GLEW_ARB_fragment_shader;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_framebuffer_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_object\", 18))\n        {\n          ret = GLEW_ARB_framebuffer_object;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_framebuffer_sRGB\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_sRGB\", 16))\n        {\n          ret = GLEW_ARB_framebuffer_sRGB;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_geometry_shader4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"geometry_shader4\", 16))\n        {\n          ret = GLEW_ARB_geometry_shader4;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_half_float_pixel\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"half_float_pixel\", 16))\n        {\n          ret = GLEW_ARB_half_float_pixel;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_half_float_vertex\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"half_float_vertex\", 17))\n        {\n          ret = GLEW_ARB_half_float_vertex;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_imaging\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"imaging\", 7))\n        {\n          ret = GLEW_ARB_imaging;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_instanced_arrays\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"instanced_arrays\", 16))\n        {\n          ret = GLEW_ARB_instanced_arrays;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_map_buffer_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"map_buffer_range\", 16))\n        {\n          ret = GLEW_ARB_map_buffer_range;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_matrix_palette\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"matrix_palette\", 14))\n        {\n          ret = GLEW_ARB_matrix_palette;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample\", 11))\n        {\n          ret = GLEW_ARB_multisample;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_multitexture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multitexture\", 12))\n        {\n          ret = GLEW_ARB_multitexture;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_occlusion_query\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"occlusion_query\", 15))\n        {\n          ret = GLEW_ARB_occlusion_query;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_pixel_buffer_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_buffer_object\", 19))\n        {\n          ret = GLEW_ARB_pixel_buffer_object;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_point_parameters\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"point_parameters\", 16))\n        {\n          ret = GLEW_ARB_point_parameters;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_point_sprite\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"point_sprite\", 12))\n        {\n          ret = GLEW_ARB_point_sprite;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_shader_objects\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"shader_objects\", 14))\n        {\n          ret = GLEW_ARB_shader_objects;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_shading_language_100\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"shading_language_100\", 20))\n        {\n          ret = GLEW_ARB_shading_language_100;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_shadow\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"shadow\", 6))\n        {\n          ret = GLEW_ARB_shadow;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_shadow_ambient\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"shadow_ambient\", 14))\n        {\n          ret = GLEW_ARB_shadow_ambient;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_border_clamp\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_border_clamp\", 20))\n        {\n          ret = GLEW_ARB_texture_border_clamp;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_buffer_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_buffer_object\", 21))\n        {\n          ret = GLEW_ARB_texture_buffer_object;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_compression\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_compression\", 19))\n        {\n          ret = GLEW_ARB_texture_compression;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_compression_rgtc\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_compression_rgtc\", 24))\n        {\n          ret = GLEW_ARB_texture_compression_rgtc;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_cube_map\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_cube_map\", 16))\n        {\n          ret = GLEW_ARB_texture_cube_map;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_env_add\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_add\", 15))\n        {\n          ret = GLEW_ARB_texture_env_add;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_env_combine\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_combine\", 19))\n        {\n          ret = GLEW_ARB_texture_env_combine;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_env_crossbar\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_crossbar\", 20))\n        {\n          ret = GLEW_ARB_texture_env_crossbar;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_env_dot3\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_dot3\", 16))\n        {\n          ret = GLEW_ARB_texture_env_dot3;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_float\", 13))\n        {\n          ret = GLEW_ARB_texture_float;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_mirrored_repeat\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_mirrored_repeat\", 23))\n        {\n          ret = GLEW_ARB_texture_mirrored_repeat;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_non_power_of_two\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_non_power_of_two\", 24))\n        {\n          ret = GLEW_ARB_texture_non_power_of_two;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_rectangle\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_rectangle\", 17))\n        {\n          ret = GLEW_ARB_texture_rectangle;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_rg\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_rg\", 10))\n        {\n          ret = GLEW_ARB_texture_rg;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_transpose_matrix\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"transpose_matrix\", 16))\n        {\n          ret = GLEW_ARB_transpose_matrix;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_vertex_array_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array_object\", 19))\n        {\n          ret = GLEW_ARB_vertex_array_object;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_vertex_blend\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_blend\", 12))\n        {\n          ret = GLEW_ARB_vertex_blend;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_vertex_buffer_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_buffer_object\", 20))\n        {\n          ret = GLEW_ARB_vertex_buffer_object;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_vertex_program\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_program\", 14))\n        {\n          ret = GLEW_ARB_vertex_program;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_vertex_shader\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_shader\", 13))\n        {\n          ret = GLEW_ARB_vertex_shader;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_window_pos\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"window_pos\", 10))\n        {\n          ret = GLEW_ARB_window_pos;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"ATIX_\", 5))\n      {\n#ifdef GL_ATIX_point_sprites\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"point_sprites\", 13))\n        {\n          ret = GLEW_ATIX_point_sprites;\n          continue;\n        }\n#endif\n#ifdef GL_ATIX_texture_env_combine3\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_combine3\", 20))\n        {\n          ret = GLEW_ATIX_texture_env_combine3;\n          continue;\n        }\n#endif\n#ifdef GL_ATIX_texture_env_route\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_route\", 17))\n        {\n          ret = GLEW_ATIX_texture_env_route;\n          continue;\n        }\n#endif\n#ifdef GL_ATIX_vertex_shader_output_point_size\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_shader_output_point_size\", 31))\n        {\n          ret = GLEW_ATIX_vertex_shader_output_point_size;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"ATI_\", 4))\n      {\n#ifdef GL_ATI_draw_buffers\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"draw_buffers\", 12))\n        {\n          ret = GLEW_ATI_draw_buffers;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_element_array\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"element_array\", 13))\n        {\n          ret = GLEW_ATI_element_array;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_envmap_bumpmap\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"envmap_bumpmap\", 14))\n        {\n          ret = GLEW_ATI_envmap_bumpmap;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_fragment_shader\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fragment_shader\", 15))\n        {\n          ret = GLEW_ATI_fragment_shader;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_map_object_buffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"map_object_buffer\", 17))\n        {\n          ret = GLEW_ATI_map_object_buffer;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_pn_triangles\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pn_triangles\", 12))\n        {\n          ret = GLEW_ATI_pn_triangles;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_separate_stencil\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"separate_stencil\", 16))\n        {\n          ret = GLEW_ATI_separate_stencil;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_shader_texture_lod\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"shader_texture_lod\", 18))\n        {\n          ret = GLEW_ATI_shader_texture_lod;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_text_fragment_shader\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"text_fragment_shader\", 20))\n        {\n          ret = GLEW_ATI_text_fragment_shader;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_texture_compression_3dc\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_compression_3dc\", 23))\n        {\n          ret = GLEW_ATI_texture_compression_3dc;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_texture_env_combine3\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_combine3\", 20))\n        {\n          ret = GLEW_ATI_texture_env_combine3;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_texture_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_float\", 13))\n        {\n          ret = GLEW_ATI_texture_float;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_texture_mirror_once\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_mirror_once\", 19))\n        {\n          ret = GLEW_ATI_texture_mirror_once;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_vertex_array_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array_object\", 19))\n        {\n          ret = GLEW_ATI_vertex_array_object;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_vertex_attrib_array_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_attrib_array_object\", 26))\n        {\n          ret = GLEW_ATI_vertex_attrib_array_object;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_vertex_streams\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_streams\", 14))\n        {\n          ret = GLEW_ATI_vertex_streams;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"EXT_\", 4))\n      {\n#ifdef GL_EXT_422_pixels\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"422_pixels\", 10))\n        {\n          ret = GLEW_EXT_422_pixels;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_Cg_shader\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"Cg_shader\", 9))\n        {\n          ret = GLEW_EXT_Cg_shader;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_abgr\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"abgr\", 4))\n        {\n          ret = GLEW_EXT_abgr;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_bgra\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"bgra\", 4))\n        {\n          ret = GLEW_EXT_bgra;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_bindable_uniform\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"bindable_uniform\", 16))\n        {\n          ret = GLEW_EXT_bindable_uniform;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_blend_color\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"blend_color\", 11))\n        {\n          ret = GLEW_EXT_blend_color;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_blend_equation_separate\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"blend_equation_separate\", 23))\n        {\n          ret = GLEW_EXT_blend_equation_separate;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_blend_func_separate\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"blend_func_separate\", 19))\n        {\n          ret = GLEW_EXT_blend_func_separate;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_blend_logic_op\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"blend_logic_op\", 14))\n        {\n          ret = GLEW_EXT_blend_logic_op;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_blend_minmax\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"blend_minmax\", 12))\n        {\n          ret = GLEW_EXT_blend_minmax;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_blend_subtract\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"blend_subtract\", 14))\n        {\n          ret = GLEW_EXT_blend_subtract;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_clip_volume_hint\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"clip_volume_hint\", 16))\n        {\n          ret = GLEW_EXT_clip_volume_hint;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_cmyka\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"cmyka\", 5))\n        {\n          ret = GLEW_EXT_cmyka;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_color_subtable\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"color_subtable\", 14))\n        {\n          ret = GLEW_EXT_color_subtable;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_compiled_vertex_array\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"compiled_vertex_array\", 21))\n        {\n          ret = GLEW_EXT_compiled_vertex_array;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_convolution\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"convolution\", 11))\n        {\n          ret = GLEW_EXT_convolution;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_coordinate_frame\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"coordinate_frame\", 16))\n        {\n          ret = GLEW_EXT_coordinate_frame;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_copy_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"copy_texture\", 12))\n        {\n          ret = GLEW_EXT_copy_texture;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_cull_vertex\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"cull_vertex\", 11))\n        {\n          ret = GLEW_EXT_cull_vertex;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_depth_bounds_test\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"depth_bounds_test\", 17))\n        {\n          ret = GLEW_EXT_depth_bounds_test;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_direct_state_access\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"direct_state_access\", 19))\n        {\n          ret = GLEW_EXT_direct_state_access;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_draw_buffers2\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"draw_buffers2\", 13))\n        {\n          ret = GLEW_EXT_draw_buffers2;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_draw_instanced\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"draw_instanced\", 14))\n        {\n          ret = GLEW_EXT_draw_instanced;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_draw_range_elements\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"draw_range_elements\", 19))\n        {\n          ret = GLEW_EXT_draw_range_elements;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_fog_coord\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fog_coord\", 9))\n        {\n          ret = GLEW_EXT_fog_coord;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_fragment_lighting\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fragment_lighting\", 17))\n        {\n          ret = GLEW_EXT_fragment_lighting;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_framebuffer_blit\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_blit\", 16))\n        {\n          ret = GLEW_EXT_framebuffer_blit;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_framebuffer_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_multisample\", 23))\n        {\n          ret = GLEW_EXT_framebuffer_multisample;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_framebuffer_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_object\", 18))\n        {\n          ret = GLEW_EXT_framebuffer_object;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_framebuffer_sRGB\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_sRGB\", 16))\n        {\n          ret = GLEW_EXT_framebuffer_sRGB;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_geometry_shader4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"geometry_shader4\", 16))\n        {\n          ret = GLEW_EXT_geometry_shader4;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_gpu_program_parameters\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"gpu_program_parameters\", 22))\n        {\n          ret = GLEW_EXT_gpu_program_parameters;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_gpu_shader4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"gpu_shader4\", 11))\n        {\n          ret = GLEW_EXT_gpu_shader4;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_histogram\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"histogram\", 9))\n        {\n          ret = GLEW_EXT_histogram;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_index_array_formats\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"index_array_formats\", 19))\n        {\n          ret = GLEW_EXT_index_array_formats;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_index_func\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"index_func\", 10))\n        {\n          ret = GLEW_EXT_index_func;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_index_material\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"index_material\", 14))\n        {\n          ret = GLEW_EXT_index_material;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_index_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"index_texture\", 13))\n        {\n          ret = GLEW_EXT_index_texture;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_light_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"light_texture\", 13))\n        {\n          ret = GLEW_EXT_light_texture;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_misc_attribute\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"misc_attribute\", 14))\n        {\n          ret = GLEW_EXT_misc_attribute;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_multi_draw_arrays\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multi_draw_arrays\", 17))\n        {\n          ret = GLEW_EXT_multi_draw_arrays;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample\", 11))\n        {\n          ret = GLEW_EXT_multisample;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_packed_depth_stencil\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"packed_depth_stencil\", 20))\n        {\n          ret = GLEW_EXT_packed_depth_stencil;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_packed_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"packed_float\", 12))\n        {\n          ret = GLEW_EXT_packed_float;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_packed_pixels\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"packed_pixels\", 13))\n        {\n          ret = GLEW_EXT_packed_pixels;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_paletted_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"paletted_texture\", 16))\n        {\n          ret = GLEW_EXT_paletted_texture;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_pixel_buffer_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_buffer_object\", 19))\n        {\n          ret = GLEW_EXT_pixel_buffer_object;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_pixel_transform\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_transform\", 15))\n        {\n          ret = GLEW_EXT_pixel_transform;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_pixel_transform_color_table\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_transform_color_table\", 27))\n        {\n          ret = GLEW_EXT_pixel_transform_color_table;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_point_parameters\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"point_parameters\", 16))\n        {\n          ret = GLEW_EXT_point_parameters;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_polygon_offset\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"polygon_offset\", 14))\n        {\n          ret = GLEW_EXT_polygon_offset;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_rescale_normal\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"rescale_normal\", 14))\n        {\n          ret = GLEW_EXT_rescale_normal;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_scene_marker\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"scene_marker\", 12))\n        {\n          ret = GLEW_EXT_scene_marker;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_secondary_color\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"secondary_color\", 15))\n        {\n          ret = GLEW_EXT_secondary_color;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_separate_specular_color\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"separate_specular_color\", 23))\n        {\n          ret = GLEW_EXT_separate_specular_color;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_shadow_funcs\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"shadow_funcs\", 12))\n        {\n          ret = GLEW_EXT_shadow_funcs;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_shared_texture_palette\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"shared_texture_palette\", 22))\n        {\n          ret = GLEW_EXT_shared_texture_palette;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_stencil_clear_tag\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"stencil_clear_tag\", 17))\n        {\n          ret = GLEW_EXT_stencil_clear_tag;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_stencil_two_side\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"stencil_two_side\", 16))\n        {\n          ret = GLEW_EXT_stencil_two_side;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_stencil_wrap\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"stencil_wrap\", 12))\n        {\n          ret = GLEW_EXT_stencil_wrap;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_subtexture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"subtexture\", 10))\n        {\n          ret = GLEW_EXT_subtexture;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture\", 7))\n        {\n          ret = GLEW_EXT_texture;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture3D\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture3D\", 9))\n        {\n          ret = GLEW_EXT_texture3D;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_array\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_array\", 13))\n        {\n          ret = GLEW_EXT_texture_array;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_buffer_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_buffer_object\", 21))\n        {\n          ret = GLEW_EXT_texture_buffer_object;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_compression_dxt1\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_compression_dxt1\", 24))\n        {\n          ret = GLEW_EXT_texture_compression_dxt1;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_compression_latc\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_compression_latc\", 24))\n        {\n          ret = GLEW_EXT_texture_compression_latc;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_compression_rgtc\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_compression_rgtc\", 24))\n        {\n          ret = GLEW_EXT_texture_compression_rgtc;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_compression_s3tc\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_compression_s3tc\", 24))\n        {\n          ret = GLEW_EXT_texture_compression_s3tc;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_cube_map\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_cube_map\", 16))\n        {\n          ret = GLEW_EXT_texture_cube_map;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_edge_clamp\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_edge_clamp\", 18))\n        {\n          ret = GLEW_EXT_texture_edge_clamp;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_env\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env\", 11))\n        {\n          ret = GLEW_EXT_texture_env;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_env_add\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_add\", 15))\n        {\n          ret = GLEW_EXT_texture_env_add;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_env_combine\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_combine\", 19))\n        {\n          ret = GLEW_EXT_texture_env_combine;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_env_dot3\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_dot3\", 16))\n        {\n          ret = GLEW_EXT_texture_env_dot3;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_filter_anisotropic\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_filter_anisotropic\", 26))\n        {\n          ret = GLEW_EXT_texture_filter_anisotropic;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_integer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_integer\", 15))\n        {\n          ret = GLEW_EXT_texture_integer;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_lod_bias\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_lod_bias\", 16))\n        {\n          ret = GLEW_EXT_texture_lod_bias;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_mirror_clamp\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_mirror_clamp\", 20))\n        {\n          ret = GLEW_EXT_texture_mirror_clamp;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_object\", 14))\n        {\n          ret = GLEW_EXT_texture_object;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_perturb_normal\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_perturb_normal\", 22))\n        {\n          ret = GLEW_EXT_texture_perturb_normal;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_rectangle\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_rectangle\", 17))\n        {\n          ret = GLEW_EXT_texture_rectangle;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_sRGB\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_sRGB\", 12))\n        {\n          ret = GLEW_EXT_texture_sRGB;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_shared_exponent\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_shared_exponent\", 23))\n        {\n          ret = GLEW_EXT_texture_shared_exponent;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_swizzle\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_swizzle\", 15))\n        {\n          ret = GLEW_EXT_texture_swizzle;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_timer_query\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"timer_query\", 11))\n        {\n          ret = GLEW_EXT_timer_query;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_transform_feedback\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"transform_feedback\", 18))\n        {\n          ret = GLEW_EXT_transform_feedback;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_vertex_array\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array\", 12))\n        {\n          ret = GLEW_EXT_vertex_array;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_vertex_array_bgra\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array_bgra\", 17))\n        {\n          ret = GLEW_EXT_vertex_array_bgra;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_vertex_shader\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_shader\", 13))\n        {\n          ret = GLEW_EXT_vertex_shader;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_vertex_weighting\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_weighting\", 16))\n        {\n          ret = GLEW_EXT_vertex_weighting;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"GREMEDY_\", 8))\n      {\n#ifdef GL_GREMEDY_frame_terminator\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"frame_terminator\", 16))\n        {\n          ret = GLEW_GREMEDY_frame_terminator;\n          continue;\n        }\n#endif\n#ifdef GL_GREMEDY_string_marker\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"string_marker\", 13))\n        {\n          ret = GLEW_GREMEDY_string_marker;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"HP_\", 3))\n      {\n#ifdef GL_HP_convolution_border_modes\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"convolution_border_modes\", 24))\n        {\n          ret = GLEW_HP_convolution_border_modes;\n          continue;\n        }\n#endif\n#ifdef GL_HP_image_transform\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"image_transform\", 15))\n        {\n          ret = GLEW_HP_image_transform;\n          continue;\n        }\n#endif\n#ifdef GL_HP_occlusion_test\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"occlusion_test\", 14))\n        {\n          ret = GLEW_HP_occlusion_test;\n          continue;\n        }\n#endif\n#ifdef GL_HP_texture_lighting\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_lighting\", 16))\n        {\n          ret = GLEW_HP_texture_lighting;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"IBM_\", 4))\n      {\n#ifdef GL_IBM_cull_vertex\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"cull_vertex\", 11))\n        {\n          ret = GLEW_IBM_cull_vertex;\n          continue;\n        }\n#endif\n#ifdef GL_IBM_multimode_draw_arrays\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multimode_draw_arrays\", 21))\n        {\n          ret = GLEW_IBM_multimode_draw_arrays;\n          continue;\n        }\n#endif\n#ifdef GL_IBM_rasterpos_clip\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"rasterpos_clip\", 14))\n        {\n          ret = GLEW_IBM_rasterpos_clip;\n          continue;\n        }\n#endif\n#ifdef GL_IBM_static_data\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"static_data\", 11))\n        {\n          ret = GLEW_IBM_static_data;\n          continue;\n        }\n#endif\n#ifdef GL_IBM_texture_mirrored_repeat\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_mirrored_repeat\", 23))\n        {\n          ret = GLEW_IBM_texture_mirrored_repeat;\n          continue;\n        }\n#endif\n#ifdef GL_IBM_vertex_array_lists\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array_lists\", 18))\n        {\n          ret = GLEW_IBM_vertex_array_lists;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"INGR_\", 5))\n      {\n#ifdef GL_INGR_color_clamp\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"color_clamp\", 11))\n        {\n          ret = GLEW_INGR_color_clamp;\n          continue;\n        }\n#endif\n#ifdef GL_INGR_interlace_read\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"interlace_read\", 14))\n        {\n          ret = GLEW_INGR_interlace_read;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"INTEL_\", 6))\n      {\n#ifdef GL_INTEL_parallel_arrays\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"parallel_arrays\", 15))\n        {\n          ret = GLEW_INTEL_parallel_arrays;\n          continue;\n        }\n#endif\n#ifdef GL_INTEL_texture_scissor\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_scissor\", 15))\n        {\n          ret = GLEW_INTEL_texture_scissor;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"KTX_\", 4))\n      {\n#ifdef GL_KTX_buffer_region\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"buffer_region\", 13))\n        {\n          ret = GLEW_KTX_buffer_region;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"MESAX_\", 6))\n      {\n#ifdef GL_MESAX_texture_stack\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_stack\", 13))\n        {\n          ret = GLEW_MESAX_texture_stack;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"MESA_\", 5))\n      {\n#ifdef GL_MESA_pack_invert\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pack_invert\", 11))\n        {\n          ret = GLEW_MESA_pack_invert;\n          continue;\n        }\n#endif\n#ifdef GL_MESA_resize_buffers\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"resize_buffers\", 14))\n        {\n          ret = GLEW_MESA_resize_buffers;\n          continue;\n        }\n#endif\n#ifdef GL_MESA_window_pos\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"window_pos\", 10))\n        {\n          ret = GLEW_MESA_window_pos;\n          continue;\n        }\n#endif\n#ifdef GL_MESA_ycbcr_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"ycbcr_texture\", 13))\n        {\n          ret = GLEW_MESA_ycbcr_texture;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"NV_\", 3))\n      {\n#ifdef GL_NV_blend_square\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"blend_square\", 12))\n        {\n          ret = GLEW_NV_blend_square;\n          continue;\n        }\n#endif\n#ifdef GL_NV_conditional_render\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"conditional_render\", 18))\n        {\n          ret = GLEW_NV_conditional_render;\n          continue;\n        }\n#endif\n#ifdef GL_NV_copy_depth_to_color\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"copy_depth_to_color\", 19))\n        {\n          ret = GLEW_NV_copy_depth_to_color;\n          continue;\n        }\n#endif\n#ifdef GL_NV_depth_buffer_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"depth_buffer_float\", 18))\n        {\n          ret = GLEW_NV_depth_buffer_float;\n          continue;\n        }\n#endif\n#ifdef GL_NV_depth_clamp\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"depth_clamp\", 11))\n        {\n          ret = GLEW_NV_depth_clamp;\n          continue;\n        }\n#endif\n#ifdef GL_NV_depth_range_unclamped\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"depth_range_unclamped\", 21))\n        {\n          ret = GLEW_NV_depth_range_unclamped;\n          continue;\n        }\n#endif\n#ifdef GL_NV_evaluators\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"evaluators\", 10))\n        {\n          ret = GLEW_NV_evaluators;\n          continue;\n        }\n#endif\n#ifdef GL_NV_explicit_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"explicit_multisample\", 20))\n        {\n          ret = GLEW_NV_explicit_multisample;\n          continue;\n        }\n#endif\n#ifdef GL_NV_fence\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fence\", 5))\n        {\n          ret = GLEW_NV_fence;\n          continue;\n        }\n#endif\n#ifdef GL_NV_float_buffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"float_buffer\", 12))\n        {\n          ret = GLEW_NV_float_buffer;\n          continue;\n        }\n#endif\n#ifdef GL_NV_fog_distance\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fog_distance\", 12))\n        {\n          ret = GLEW_NV_fog_distance;\n          continue;\n        }\n#endif\n#ifdef GL_NV_fragment_program\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fragment_program\", 16))\n        {\n          ret = GLEW_NV_fragment_program;\n          continue;\n        }\n#endif\n#ifdef GL_NV_fragment_program2\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fragment_program2\", 17))\n        {\n          ret = GLEW_NV_fragment_program2;\n          continue;\n        }\n#endif\n#ifdef GL_NV_fragment_program4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fragment_program4\", 17))\n        {\n          ret = GLEW_NV_fragment_program4;\n          continue;\n        }\n#endif\n#ifdef GL_NV_fragment_program_option\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fragment_program_option\", 23))\n        {\n          ret = GLEW_NV_fragment_program_option;\n          continue;\n        }\n#endif\n#ifdef GL_NV_framebuffer_multisample_coverage\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_multisample_coverage\", 32))\n        {\n          ret = GLEW_NV_framebuffer_multisample_coverage;\n          continue;\n        }\n#endif\n#ifdef GL_NV_geometry_program4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"geometry_program4\", 17))\n        {\n          ret = GLEW_NV_geometry_program4;\n          continue;\n        }\n#endif\n#ifdef GL_NV_geometry_shader4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"geometry_shader4\", 16))\n        {\n          ret = GLEW_NV_geometry_shader4;\n          continue;\n        }\n#endif\n#ifdef GL_NV_gpu_program4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"gpu_program4\", 12))\n        {\n          ret = GLEW_NV_gpu_program4;\n          continue;\n        }\n#endif\n#ifdef GL_NV_half_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"half_float\", 10))\n        {\n          ret = GLEW_NV_half_float;\n          continue;\n        }\n#endif\n#ifdef GL_NV_light_max_exponent\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"light_max_exponent\", 18))\n        {\n          ret = GLEW_NV_light_max_exponent;\n          continue;\n        }\n#endif\n#ifdef GL_NV_multisample_filter_hint\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample_filter_hint\", 23))\n        {\n          ret = GLEW_NV_multisample_filter_hint;\n          continue;\n        }\n#endif\n#ifdef GL_NV_occlusion_query\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"occlusion_query\", 15))\n        {\n          ret = GLEW_NV_occlusion_query;\n          continue;\n        }\n#endif\n#ifdef GL_NV_packed_depth_stencil\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"packed_depth_stencil\", 20))\n        {\n          ret = GLEW_NV_packed_depth_stencil;\n          continue;\n        }\n#endif\n#ifdef GL_NV_parameter_buffer_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"parameter_buffer_object\", 23))\n        {\n          ret = GLEW_NV_parameter_buffer_object;\n          continue;\n        }\n#endif\n#ifdef GL_NV_pixel_data_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_data_range\", 16))\n        {\n          ret = GLEW_NV_pixel_data_range;\n          continue;\n        }\n#endif\n#ifdef GL_NV_point_sprite\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"point_sprite\", 12))\n        {\n          ret = GLEW_NV_point_sprite;\n          continue;\n        }\n#endif\n#ifdef GL_NV_present_video\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"present_video\", 13))\n        {\n          ret = GLEW_NV_present_video;\n          continue;\n        }\n#endif\n#ifdef GL_NV_primitive_restart\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"primitive_restart\", 17))\n        {\n          ret = GLEW_NV_primitive_restart;\n          continue;\n        }\n#endif\n#ifdef GL_NV_register_combiners\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"register_combiners\", 18))\n        {\n          ret = GLEW_NV_register_combiners;\n          continue;\n        }\n#endif\n#ifdef GL_NV_register_combiners2\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"register_combiners2\", 19))\n        {\n          ret = GLEW_NV_register_combiners2;\n          continue;\n        }\n#endif\n#ifdef GL_NV_texgen_emboss\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texgen_emboss\", 13))\n        {\n          ret = GLEW_NV_texgen_emboss;\n          continue;\n        }\n#endif\n#ifdef GL_NV_texgen_reflection\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texgen_reflection\", 17))\n        {\n          ret = GLEW_NV_texgen_reflection;\n          continue;\n        }\n#endif\n#ifdef GL_NV_texture_compression_vtc\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_compression_vtc\", 23))\n        {\n          ret = GLEW_NV_texture_compression_vtc;\n          continue;\n        }\n#endif\n#ifdef GL_NV_texture_env_combine4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_combine4\", 20))\n        {\n          ret = GLEW_NV_texture_env_combine4;\n          continue;\n        }\n#endif\n#ifdef GL_NV_texture_expand_normal\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_expand_normal\", 21))\n        {\n          ret = GLEW_NV_texture_expand_normal;\n          continue;\n        }\n#endif\n#ifdef GL_NV_texture_rectangle\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_rectangle\", 17))\n        {\n          ret = GLEW_NV_texture_rectangle;\n          continue;\n        }\n#endif\n#ifdef GL_NV_texture_shader\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_shader\", 14))\n        {\n          ret = GLEW_NV_texture_shader;\n          continue;\n        }\n#endif\n#ifdef GL_NV_texture_shader2\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_shader2\", 15))\n        {\n          ret = GLEW_NV_texture_shader2;\n          continue;\n        }\n#endif\n#ifdef GL_NV_texture_shader3\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_shader3\", 15))\n        {\n          ret = GLEW_NV_texture_shader3;\n          continue;\n        }\n#endif\n#ifdef GL_NV_transform_feedback\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"transform_feedback\", 18))\n        {\n          ret = GLEW_NV_transform_feedback;\n          continue;\n        }\n#endif\n#ifdef GL_NV_vertex_array_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array_range\", 18))\n        {\n          ret = GLEW_NV_vertex_array_range;\n          continue;\n        }\n#endif\n#ifdef GL_NV_vertex_array_range2\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array_range2\", 19))\n        {\n          ret = GLEW_NV_vertex_array_range2;\n          continue;\n        }\n#endif\n#ifdef GL_NV_vertex_program\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_program\", 14))\n        {\n          ret = GLEW_NV_vertex_program;\n          continue;\n        }\n#endif\n#ifdef GL_NV_vertex_program1_1\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_program1_1\", 17))\n        {\n          ret = GLEW_NV_vertex_program1_1;\n          continue;\n        }\n#endif\n#ifdef GL_NV_vertex_program2\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_program2\", 15))\n        {\n          ret = GLEW_NV_vertex_program2;\n          continue;\n        }\n#endif\n#ifdef GL_NV_vertex_program2_option\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_program2_option\", 22))\n        {\n          ret = GLEW_NV_vertex_program2_option;\n          continue;\n        }\n#endif\n#ifdef GL_NV_vertex_program3\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_program3\", 15))\n        {\n          ret = GLEW_NV_vertex_program3;\n          continue;\n        }\n#endif\n#ifdef GL_NV_vertex_program4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_program4\", 15))\n        {\n          ret = GLEW_NV_vertex_program4;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"OES_\", 4))\n      {\n#ifdef GL_OES_byte_coordinates\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"byte_coordinates\", 16))\n        {\n          ret = GLEW_OES_byte_coordinates;\n          continue;\n        }\n#endif\n#ifdef GL_OES_compressed_paletted_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"compressed_paletted_texture\", 27))\n        {\n          ret = GLEW_OES_compressed_paletted_texture;\n          continue;\n        }\n#endif\n#ifdef GL_OES_read_format\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"read_format\", 11))\n        {\n          ret = GLEW_OES_read_format;\n          continue;\n        }\n#endif\n#ifdef GL_OES_single_precision\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"single_precision\", 16))\n        {\n          ret = GLEW_OES_single_precision;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"OML_\", 4))\n      {\n#ifdef GL_OML_interlace\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"interlace\", 9))\n        {\n          ret = GLEW_OML_interlace;\n          continue;\n        }\n#endif\n#ifdef GL_OML_resample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"resample\", 8))\n        {\n          ret = GLEW_OML_resample;\n          continue;\n        }\n#endif\n#ifdef GL_OML_subsample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"subsample\", 9))\n        {\n          ret = GLEW_OML_subsample;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"PGI_\", 4))\n      {\n#ifdef GL_PGI_misc_hints\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"misc_hints\", 10))\n        {\n          ret = GLEW_PGI_misc_hints;\n          continue;\n        }\n#endif\n#ifdef GL_PGI_vertex_hints\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_hints\", 12))\n        {\n          ret = GLEW_PGI_vertex_hints;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"REND_\", 5))\n      {\n#ifdef GL_REND_screen_coordinates\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"screen_coordinates\", 18))\n        {\n          ret = GLEW_REND_screen_coordinates;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"S3_\", 3))\n      {\n#ifdef GL_S3_s3tc\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"s3tc\", 4))\n        {\n          ret = GLEW_S3_s3tc;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"SGIS_\", 5))\n      {\n#ifdef GL_SGIS_color_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"color_range\", 11))\n        {\n          ret = GLEW_SGIS_color_range;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_detail_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"detail_texture\", 14))\n        {\n          ret = GLEW_SGIS_detail_texture;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_fog_function\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fog_function\", 12))\n        {\n          ret = GLEW_SGIS_fog_function;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_generate_mipmap\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"generate_mipmap\", 15))\n        {\n          ret = GLEW_SGIS_generate_mipmap;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample\", 11))\n        {\n          ret = GLEW_SGIS_multisample;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_pixel_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_texture\", 13))\n        {\n          ret = GLEW_SGIS_pixel_texture;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_point_line_texgen\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"point_line_texgen\", 17))\n        {\n          ret = GLEW_SGIS_point_line_texgen;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_sharpen_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"sharpen_texture\", 15))\n        {\n          ret = GLEW_SGIS_sharpen_texture;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_texture4D\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture4D\", 9))\n        {\n          ret = GLEW_SGIS_texture4D;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_texture_border_clamp\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_border_clamp\", 20))\n        {\n          ret = GLEW_SGIS_texture_border_clamp;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_texture_edge_clamp\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_edge_clamp\", 18))\n        {\n          ret = GLEW_SGIS_texture_edge_clamp;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_texture_filter4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_filter4\", 15))\n        {\n          ret = GLEW_SGIS_texture_filter4;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_texture_lod\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_lod\", 11))\n        {\n          ret = GLEW_SGIS_texture_lod;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_texture_select\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_select\", 14))\n        {\n          ret = GLEW_SGIS_texture_select;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"SGIX_\", 5))\n      {\n#ifdef GL_SGIX_async\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"async\", 5))\n        {\n          ret = GLEW_SGIX_async;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_async_histogram\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"async_histogram\", 15))\n        {\n          ret = GLEW_SGIX_async_histogram;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_async_pixel\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"async_pixel\", 11))\n        {\n          ret = GLEW_SGIX_async_pixel;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_blend_alpha_minmax\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"blend_alpha_minmax\", 18))\n        {\n          ret = GLEW_SGIX_blend_alpha_minmax;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_clipmap\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"clipmap\", 7))\n        {\n          ret = GLEW_SGIX_clipmap;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_convolution_accuracy\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"convolution_accuracy\", 20))\n        {\n          ret = GLEW_SGIX_convolution_accuracy;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_depth_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"depth_texture\", 13))\n        {\n          ret = GLEW_SGIX_depth_texture;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_flush_raster\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"flush_raster\", 12))\n        {\n          ret = GLEW_SGIX_flush_raster;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_fog_offset\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fog_offset\", 10))\n        {\n          ret = GLEW_SGIX_fog_offset;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_fog_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fog_texture\", 11))\n        {\n          ret = GLEW_SGIX_fog_texture;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_fragment_specular_lighting\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fragment_specular_lighting\", 26))\n        {\n          ret = GLEW_SGIX_fragment_specular_lighting;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_framezoom\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framezoom\", 9))\n        {\n          ret = GLEW_SGIX_framezoom;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_interlace\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"interlace\", 9))\n        {\n          ret = GLEW_SGIX_interlace;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_ir_instrument1\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"ir_instrument1\", 14))\n        {\n          ret = GLEW_SGIX_ir_instrument1;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_list_priority\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"list_priority\", 13))\n        {\n          ret = GLEW_SGIX_list_priority;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_pixel_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_texture\", 13))\n        {\n          ret = GLEW_SGIX_pixel_texture;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_pixel_texture_bits\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_texture_bits\", 18))\n        {\n          ret = GLEW_SGIX_pixel_texture_bits;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_reference_plane\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"reference_plane\", 15))\n        {\n          ret = GLEW_SGIX_reference_plane;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_resample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"resample\", 8))\n        {\n          ret = GLEW_SGIX_resample;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_shadow\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"shadow\", 6))\n        {\n          ret = GLEW_SGIX_shadow;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_shadow_ambient\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"shadow_ambient\", 14))\n        {\n          ret = GLEW_SGIX_shadow_ambient;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_sprite\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"sprite\", 6))\n        {\n          ret = GLEW_SGIX_sprite;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_tag_sample_buffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"tag_sample_buffer\", 17))\n        {\n          ret = GLEW_SGIX_tag_sample_buffer;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_texture_add_env\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_add_env\", 15))\n        {\n          ret = GLEW_SGIX_texture_add_env;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_texture_coordinate_clamp\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_coordinate_clamp\", 24))\n        {\n          ret = GLEW_SGIX_texture_coordinate_clamp;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_texture_lod_bias\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_lod_bias\", 16))\n        {\n          ret = GLEW_SGIX_texture_lod_bias;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_texture_multi_buffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_multi_buffer\", 20))\n        {\n          ret = GLEW_SGIX_texture_multi_buffer;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_texture_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_range\", 13))\n        {\n          ret = GLEW_SGIX_texture_range;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_texture_scale_bias\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_scale_bias\", 18))\n        {\n          ret = GLEW_SGIX_texture_scale_bias;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_vertex_preclip\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_preclip\", 14))\n        {\n          ret = GLEW_SGIX_vertex_preclip;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_vertex_preclip_hint\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_preclip_hint\", 19))\n        {\n          ret = GLEW_SGIX_vertex_preclip_hint;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_ycrcb\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"ycrcb\", 5))\n        {\n          ret = GLEW_SGIX_ycrcb;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"SGI_\", 4))\n      {\n#ifdef GL_SGI_color_matrix\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"color_matrix\", 12))\n        {\n          ret = GLEW_SGI_color_matrix;\n          continue;\n        }\n#endif\n#ifdef GL_SGI_color_table\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"color_table\", 11))\n        {\n          ret = GLEW_SGI_color_table;\n          continue;\n        }\n#endif\n#ifdef GL_SGI_texture_color_table\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_color_table\", 19))\n        {\n          ret = GLEW_SGI_texture_color_table;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"SUNX_\", 5))\n      {\n#ifdef GL_SUNX_constant_data\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"constant_data\", 13))\n        {\n          ret = GLEW_SUNX_constant_data;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"SUN_\", 4))\n      {\n#ifdef GL_SUN_convolution_border_modes\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"convolution_border_modes\", 24))\n        {\n          ret = GLEW_SUN_convolution_border_modes;\n          continue;\n        }\n#endif\n#ifdef GL_SUN_global_alpha\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"global_alpha\", 12))\n        {\n          ret = GLEW_SUN_global_alpha;\n          continue;\n        }\n#endif\n#ifdef GL_SUN_mesh_array\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"mesh_array\", 10))\n        {\n          ret = GLEW_SUN_mesh_array;\n          continue;\n        }\n#endif\n#ifdef GL_SUN_read_video_pixels\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"read_video_pixels\", 17))\n        {\n          ret = GLEW_SUN_read_video_pixels;\n          continue;\n        }\n#endif\n#ifdef GL_SUN_slice_accum\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"slice_accum\", 11))\n        {\n          ret = GLEW_SUN_slice_accum;\n          continue;\n        }\n#endif\n#ifdef GL_SUN_triangle_list\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"triangle_list\", 13))\n        {\n          ret = GLEW_SUN_triangle_list;\n          continue;\n        }\n#endif\n#ifdef GL_SUN_vertex\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex\", 6))\n        {\n          ret = GLEW_SUN_vertex;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"WIN_\", 4))\n      {\n#ifdef GL_WIN_phong_shading\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"phong_shading\", 13))\n        {\n          ret = GLEW_WIN_phong_shading;\n          continue;\n        }\n#endif\n#ifdef GL_WIN_specular_fog\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"specular_fog\", 12))\n        {\n          ret = GLEW_WIN_specular_fog;\n          continue;\n        }\n#endif\n#ifdef GL_WIN_swap_hint\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"swap_hint\", 9))\n        {\n          ret = GLEW_WIN_swap_hint;\n          continue;\n        }\n#endif\n      }\n    }\n    ret = (len == 0);\n  }\n  return ret;\n}\n\n#if defined(_WIN32)\n\n#if defined(GLEW_MX)\nGLboolean wglewContextIsSupported (WGLEWContext* ctx, const char* name)\n#else\nGLboolean wglewIsSupported (const char* name)\n#endif\n{\n  GLubyte* pos = (GLubyte*)name;\n  GLuint len = _glewStrLen(pos);\n  GLboolean ret = GL_TRUE;\n  while (ret && len > 0)\n  {\n    if (_glewStrSame1(&pos, &len, (const GLubyte*)\"WGL_\", 4))\n    {\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"3DFX_\", 5))\n      {\n#ifdef WGL_3DFX_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample\", 11))\n        {\n          ret = WGLEW_3DFX_multisample;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"3DL_\", 4))\n      {\n#ifdef WGL_3DL_stereo_control\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"stereo_control\", 14))\n        {\n          ret = WGLEW_3DL_stereo_control;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"ARB_\", 4))\n      {\n#ifdef WGL_ARB_buffer_region\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"buffer_region\", 13))\n        {\n          ret = WGLEW_ARB_buffer_region;\n          continue;\n        }\n#endif\n#ifdef WGL_ARB_create_context\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"create_context\", 14))\n        {\n          ret = WGLEW_ARB_create_context;\n          continue;\n        }\n#endif\n#ifdef WGL_ARB_extensions_string\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"extensions_string\", 17))\n        {\n          ret = WGLEW_ARB_extensions_string;\n          continue;\n        }\n#endif\n#ifdef WGL_ARB_framebuffer_sRGB\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_sRGB\", 16))\n        {\n          ret = WGLEW_ARB_framebuffer_sRGB;\n          continue;\n        }\n#endif\n#ifdef WGL_ARB_make_current_read\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"make_current_read\", 17))\n        {\n          ret = WGLEW_ARB_make_current_read;\n          continue;\n        }\n#endif\n#ifdef WGL_ARB_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample\", 11))\n        {\n          ret = WGLEW_ARB_multisample;\n          continue;\n        }\n#endif\n#ifdef WGL_ARB_pbuffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pbuffer\", 7))\n        {\n          ret = WGLEW_ARB_pbuffer;\n          continue;\n        }\n#endif\n#ifdef WGL_ARB_pixel_format\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_format\", 12))\n        {\n          ret = WGLEW_ARB_pixel_format;\n          continue;\n        }\n#endif\n#ifdef WGL_ARB_pixel_format_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_format_float\", 18))\n        {\n          ret = WGLEW_ARB_pixel_format_float;\n          continue;\n        }\n#endif\n#ifdef WGL_ARB_render_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"render_texture\", 14))\n        {\n          ret = WGLEW_ARB_render_texture;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"ATI_\", 4))\n      {\n#ifdef WGL_ATI_pixel_format_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_format_float\", 18))\n        {\n          ret = WGLEW_ATI_pixel_format_float;\n          continue;\n        }\n#endif\n#ifdef WGL_ATI_render_texture_rectangle\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"render_texture_rectangle\", 24))\n        {\n          ret = WGLEW_ATI_render_texture_rectangle;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"EXT_\", 4))\n      {\n#ifdef WGL_EXT_depth_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"depth_float\", 11))\n        {\n          ret = WGLEW_EXT_depth_float;\n          continue;\n        }\n#endif\n#ifdef WGL_EXT_display_color_table\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"display_color_table\", 19))\n        {\n          ret = WGLEW_EXT_display_color_table;\n          continue;\n        }\n#endif\n#ifdef WGL_EXT_extensions_string\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"extensions_string\", 17))\n        {\n          ret = WGLEW_EXT_extensions_string;\n          continue;\n        }\n#endif\n#ifdef WGL_EXT_framebuffer_sRGB\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_sRGB\", 16))\n        {\n          ret = WGLEW_EXT_framebuffer_sRGB;\n          continue;\n        }\n#endif\n#ifdef WGL_EXT_make_current_read\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"make_current_read\", 17))\n        {\n          ret = WGLEW_EXT_make_current_read;\n          continue;\n        }\n#endif\n#ifdef WGL_EXT_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample\", 11))\n        {\n          ret = WGLEW_EXT_multisample;\n          continue;\n        }\n#endif\n#ifdef WGL_EXT_pbuffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pbuffer\", 7))\n        {\n          ret = WGLEW_EXT_pbuffer;\n          continue;\n        }\n#endif\n#ifdef WGL_EXT_pixel_format\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_format\", 12))\n        {\n          ret = WGLEW_EXT_pixel_format;\n          continue;\n        }\n#endif\n#ifdef WGL_EXT_pixel_format_packed_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_format_packed_float\", 25))\n        {\n          ret = WGLEW_EXT_pixel_format_packed_float;\n          continue;\n        }\n#endif\n#ifdef WGL_EXT_swap_control\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"swap_control\", 12))\n        {\n          ret = WGLEW_EXT_swap_control;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"I3D_\", 4))\n      {\n#ifdef WGL_I3D_digital_video_control\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"digital_video_control\", 21))\n        {\n          ret = WGLEW_I3D_digital_video_control;\n          continue;\n        }\n#endif\n#ifdef WGL_I3D_gamma\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"gamma\", 5))\n        {\n          ret = WGLEW_I3D_gamma;\n          continue;\n        }\n#endif\n#ifdef WGL_I3D_genlock\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"genlock\", 7))\n        {\n          ret = WGLEW_I3D_genlock;\n          continue;\n        }\n#endif\n#ifdef WGL_I3D_image_buffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"image_buffer\", 12))\n        {\n          ret = WGLEW_I3D_image_buffer;\n          continue;\n        }\n#endif\n#ifdef WGL_I3D_swap_frame_lock\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"swap_frame_lock\", 15))\n        {\n          ret = WGLEW_I3D_swap_frame_lock;\n          continue;\n        }\n#endif\n#ifdef WGL_I3D_swap_frame_usage\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"swap_frame_usage\", 16))\n        {\n          ret = WGLEW_I3D_swap_frame_usage;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"NV_\", 3))\n      {\n#ifdef WGL_NV_float_buffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"float_buffer\", 12))\n        {\n          ret = WGLEW_NV_float_buffer;\n          continue;\n        }\n#endif\n#ifdef WGL_NV_gpu_affinity\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"gpu_affinity\", 12))\n        {\n          ret = WGLEW_NV_gpu_affinity;\n          continue;\n        }\n#endif\n#ifdef WGL_NV_present_video\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"present_video\", 13))\n        {\n          ret = WGLEW_NV_present_video;\n          continue;\n        }\n#endif\n#ifdef WGL_NV_render_depth_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"render_depth_texture\", 20))\n        {\n          ret = WGLEW_NV_render_depth_texture;\n          continue;\n        }\n#endif\n#ifdef WGL_NV_render_texture_rectangle\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"render_texture_rectangle\", 24))\n        {\n          ret = WGLEW_NV_render_texture_rectangle;\n          continue;\n        }\n#endif\n#ifdef WGL_NV_swap_group\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"swap_group\", 10))\n        {\n          ret = WGLEW_NV_swap_group;\n          continue;\n        }\n#endif\n#ifdef WGL_NV_vertex_array_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array_range\", 18))\n        {\n          ret = WGLEW_NV_vertex_array_range;\n          continue;\n        }\n#endif\n#ifdef WGL_NV_video_output\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"video_output\", 12))\n        {\n          ret = WGLEW_NV_video_output;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"OML_\", 4))\n      {\n#ifdef WGL_OML_sync_control\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"sync_control\", 12))\n        {\n          ret = WGLEW_OML_sync_control;\n          continue;\n        }\n#endif\n      }\n    }\n    ret = (len == 0);\n  }\n  return ret;\n}\n\n#elif !defined(__APPLE__) || defined(GLEW_APPLE_GLX)\n\n#if defined(GLEW_MX)\nGLboolean glxewContextIsSupported (GLXEWContext* ctx, const char* name)\n#else\nGLboolean glxewIsSupported (const char* name)\n#endif\n{\n  GLubyte* pos = (GLubyte*)name;\n  GLuint len = _glewStrLen(pos);\n  GLboolean ret = GL_TRUE;\n  while (ret && len > 0)\n  {\n    if(_glewStrSame1(&pos, &len, (const GLubyte*)\"GLX_\", 4))\n    {\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"VERSION_\", 8))\n      {\n#ifdef GLX_VERSION_1_2\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"1_2\", 3))\n        {\n          ret = GLXEW_VERSION_1_2;\n          continue;\n        }\n#endif\n#ifdef GLX_VERSION_1_3\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"1_3\", 3))\n        {\n          ret = GLXEW_VERSION_1_3;\n          continue;\n        }\n#endif\n#ifdef GLX_VERSION_1_4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"1_4\", 3))\n        {\n          ret = GLXEW_VERSION_1_4;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"3DFX_\", 5))\n      {\n#ifdef GLX_3DFX_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample\", 11))\n        {\n          ret = GLXEW_3DFX_multisample;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"ARB_\", 4))\n      {\n#ifdef GLX_ARB_create_context\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"create_context\", 14))\n        {\n          ret = GLXEW_ARB_create_context;\n          continue;\n        }\n#endif\n#ifdef GLX_ARB_fbconfig_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fbconfig_float\", 14))\n        {\n          ret = GLXEW_ARB_fbconfig_float;\n          continue;\n        }\n#endif\n#ifdef GLX_ARB_framebuffer_sRGB\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_sRGB\", 16))\n        {\n          ret = GLXEW_ARB_framebuffer_sRGB;\n          continue;\n        }\n#endif\n#ifdef GLX_ARB_get_proc_address\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"get_proc_address\", 16))\n        {\n          ret = GLXEW_ARB_get_proc_address;\n          continue;\n        }\n#endif\n#ifdef GLX_ARB_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample\", 11))\n        {\n          ret = GLXEW_ARB_multisample;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"ATI_\", 4))\n      {\n#ifdef GLX_ATI_pixel_format_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_format_float\", 18))\n        {\n          ret = GLXEW_ATI_pixel_format_float;\n          continue;\n        }\n#endif\n#ifdef GLX_ATI_render_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"render_texture\", 14))\n        {\n          ret = GLXEW_ATI_render_texture;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"EXT_\", 4))\n      {\n#ifdef GLX_EXT_fbconfig_packed_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fbconfig_packed_float\", 21))\n        {\n          ret = GLXEW_EXT_fbconfig_packed_float;\n          continue;\n        }\n#endif\n#ifdef GLX_EXT_framebuffer_sRGB\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_sRGB\", 16))\n        {\n          ret = GLXEW_EXT_framebuffer_sRGB;\n          continue;\n        }\n#endif\n#ifdef GLX_EXT_import_context\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"import_context\", 14))\n        {\n          ret = GLXEW_EXT_import_context;\n          continue;\n        }\n#endif\n#ifdef GLX_EXT_scene_marker\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"scene_marker\", 12))\n        {\n          ret = GLXEW_EXT_scene_marker;\n          continue;\n        }\n#endif\n#ifdef GLX_EXT_texture_from_pixmap\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_from_pixmap\", 19))\n        {\n          ret = GLXEW_EXT_texture_from_pixmap;\n          continue;\n        }\n#endif\n#ifdef GLX_EXT_visual_info\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"visual_info\", 11))\n        {\n          ret = GLXEW_EXT_visual_info;\n          continue;\n        }\n#endif\n#ifdef GLX_EXT_visual_rating\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"visual_rating\", 13))\n        {\n          ret = GLXEW_EXT_visual_rating;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"MESA_\", 5))\n      {\n#ifdef GLX_MESA_agp_offset\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"agp_offset\", 10))\n        {\n          ret = GLXEW_MESA_agp_offset;\n          continue;\n        }\n#endif\n#ifdef GLX_MESA_copy_sub_buffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"copy_sub_buffer\", 15))\n        {\n          ret = GLXEW_MESA_copy_sub_buffer;\n          continue;\n        }\n#endif\n#ifdef GLX_MESA_pixmap_colormap\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixmap_colormap\", 15))\n        {\n          ret = GLXEW_MESA_pixmap_colormap;\n          continue;\n        }\n#endif\n#ifdef GLX_MESA_release_buffers\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"release_buffers\", 15))\n        {\n          ret = GLXEW_MESA_release_buffers;\n          continue;\n        }\n#endif\n#ifdef GLX_MESA_set_3dfx_mode\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"set_3dfx_mode\", 13))\n        {\n          ret = GLXEW_MESA_set_3dfx_mode;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"NV_\", 3))\n      {\n#ifdef GLX_NV_float_buffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"float_buffer\", 12))\n        {\n          ret = GLXEW_NV_float_buffer;\n          continue;\n        }\n#endif\n#ifdef GLX_NV_present_video\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"present_video\", 13))\n        {\n          ret = GLXEW_NV_present_video;\n          continue;\n        }\n#endif\n#ifdef GLX_NV_swap_group\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"swap_group\", 10))\n        {\n          ret = GLXEW_NV_swap_group;\n          continue;\n        }\n#endif\n#ifdef GLX_NV_vertex_array_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array_range\", 18))\n        {\n          ret = GLXEW_NV_vertex_array_range;\n          continue;\n        }\n#endif\n#ifdef GLX_NV_video_output\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"video_output\", 12))\n        {\n          ret = GLXEW_NV_video_output;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"OML_\", 4))\n      {\n#ifdef GLX_OML_swap_method\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"swap_method\", 11))\n        {\n          ret = GLXEW_OML_swap_method;\n          continue;\n        }\n#endif\n#if defined(GLX_OML_sync_control) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\n#include <inttypes.h>\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"sync_control\", 12))\n        {\n          ret = GLXEW_OML_sync_control;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"SGIS_\", 5))\n      {\n#ifdef GLX_SGIS_blended_overlay\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"blended_overlay\", 15))\n        {\n          ret = GLXEW_SGIS_blended_overlay;\n          continue;\n        }\n#endif\n#ifdef GLX_SGIS_color_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"color_range\", 11))\n        {\n          ret = GLXEW_SGIS_color_range;\n          continue;\n        }\n#endif\n#ifdef GLX_SGIS_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample\", 11))\n        {\n          ret = GLXEW_SGIS_multisample;\n          continue;\n        }\n#endif\n#ifdef GLX_SGIS_shared_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"shared_multisample\", 18))\n        {\n          ret = GLXEW_SGIS_shared_multisample;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"SGIX_\", 5))\n      {\n#ifdef GLX_SGIX_fbconfig\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fbconfig\", 8))\n        {\n          ret = GLXEW_SGIX_fbconfig;\n          continue;\n        }\n#endif\n#ifdef GLX_SGIX_hyperpipe\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"hyperpipe\", 9))\n        {\n          ret = GLXEW_SGIX_hyperpipe;\n          continue;\n        }\n#endif\n#ifdef GLX_SGIX_pbuffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pbuffer\", 7))\n        {\n          ret = GLXEW_SGIX_pbuffer;\n          continue;\n        }\n#endif\n#ifdef GLX_SGIX_swap_barrier\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"swap_barrier\", 12))\n        {\n          ret = GLXEW_SGIX_swap_barrier;\n          continue;\n        }\n#endif\n#ifdef GLX_SGIX_swap_group\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"swap_group\", 10))\n        {\n          ret = GLXEW_SGIX_swap_group;\n          continue;\n        }\n#endif\n#ifdef GLX_SGIX_video_resize\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"video_resize\", 12))\n        {\n          ret = GLXEW_SGIX_video_resize;\n          continue;\n        }\n#endif\n#ifdef GLX_SGIX_visual_select_group\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"visual_select_group\", 19))\n        {\n          ret = GLXEW_SGIX_visual_select_group;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"SGI_\", 4))\n      {\n#ifdef GLX_SGI_cushion\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"cushion\", 7))\n        {\n          ret = GLXEW_SGI_cushion;\n          continue;\n        }\n#endif\n#ifdef GLX_SGI_make_current_read\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"make_current_read\", 17))\n        {\n          ret = GLXEW_SGI_make_current_read;\n          continue;\n        }\n#endif\n#ifdef GLX_SGI_swap_control\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"swap_control\", 12))\n        {\n          ret = GLXEW_SGI_swap_control;\n          continue;\n        }\n#endif\n#ifdef GLX_SGI_video_sync\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"video_sync\", 10))\n        {\n          ret = GLXEW_SGI_video_sync;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"SUN_\", 4))\n      {\n#ifdef GLX_SUN_get_transparent_index\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"get_transparent_index\", 21))\n        {\n          ret = GLXEW_SUN_get_transparent_index;\n          continue;\n        }\n#endif\n#ifdef GLX_SUN_video_resize\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"video_resize\", 12))\n        {\n          ret = GLXEW_SUN_video_resize;\n          continue;\n        }\n#endif\n      }\n    }\n    ret = (len == 0);\n  }\n  return ret;\n}\n\n#endif /* _WIN32 */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/hist/doc/v600/candle.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/hist/doc/v602/violin.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/hist/doc/v528/textoption.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/hist/doc/v528/th2polyUSA.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/hist/doc/v528/hbarmin0.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/hist/doc/v528/th2polyBoxes.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/hist/doc/v528/th2polyEurope.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/hist/doc/v528/th2polyHoneycomb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/hist/doc/v526/gtime.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/hist/doc/v526/surf7.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/hist/doc/v526/gtime2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/hist/doc/v526/graph2derrors.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/hist/doc/v534/mg3d.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/hist/doc/v522/Contour.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/hist/doc/v522/Scan.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/hist/doc/v522/FitPanel.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_save.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_fontselect.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_rename.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/stop.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_AlignTop.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_paste_into.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_cut.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/record.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_compact.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_shutter.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/refresh.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_AlignLeft.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_plus.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/Splash.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/ed_paste.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_stop.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/glow_green.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/ReloadPage.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_redo.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/ed_copy.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_delete.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/ed_execute.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_hbox.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/class.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/member.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/rotate.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_vbox.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/GoForward.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_sortup.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/filter.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/Root6Splash.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/StopLoading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/ed_open.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_edit.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_paste.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/ed_saveas.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/GoBack.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_undo.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/ver_arrow_cursor.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/ed_help.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/GoHome.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/ed_print.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/closetab.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/ed_goto.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_newtab.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_new.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/pause.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/closetab_d.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/ed_delete.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/ed_cut.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_AlignBtm.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/glow_red.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_AlignCenter.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/eve_text.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/speedo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/right_arrow_cursor.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/method.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_crop.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/Root6Icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/replay.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/ed_quit.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_grid.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/ed_save.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/recursor.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_open.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_colorselect.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_AlignRight.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_fontselect.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/ed_interrupt.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/htmlfile.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_exit.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/top_left_cursor.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_rgb.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/RootIcon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/ed_compile.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_copy.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/ed_new.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_edit_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_break.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/bld_removetab.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/top_right_cursor.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/glow_orange.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/hor_arrow_cursor.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/info.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/move_cursor.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/ed_find.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/icons/ed_findnext.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tree/dataframe/test/RSqliteDS_test.sqlite",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tree/doc/v526/perfstats_atlas_flushed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tree/doc/v526/perfstats_atlas_original.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/utils/lit/tests/shtest-encoding.py",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/utils/lit/tests/Inputs/shtest-format/external_shell/write-bad-encoding.sh",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/bindings/python/llvm/tests/test.bc",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/cmake/nsis_logo.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/cmake/nsis_icon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/www/feature-compile1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/www/feature-compile2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/www/feature-memory1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/www/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/www/carbon-compile.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/www/demo/cathead.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/example_use_assert.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/example_null_pointer.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/example_cf_returns_retained.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/scan_build_cmd.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/analyzer_html.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/example_custom_assert.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/analyzer_xcode.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/example_ns_returns_retained.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/example_cf_returns_retained_gc.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/example_attribute_nonnull.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/expandcollapse/ellipses_dark.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/expandcollapse/arrows_light.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/expandcollapse/arrows_dark.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/expandcollapse/ellipses_light.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/tools/scan-view/share/FileRadar.scpt",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/tools/scan-view/share/bugcatcher.ico",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/tools/clang-format-vs/ClangFormat/Resources/Images_32bit.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/tools/clang-format-vs/ClangFormat/Resources/Package.ico",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/tools/scan-build/share/scan-build/sorttable.js",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/docs/DriverArchitecture.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/tools/clang/docs/PCHLayout.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/docs/MCJIT-load.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/docs/ARM-BE-bitcastfail.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/docs/MCJIT-dyld-load.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/docs/MCJIT-engine-builder.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/docs/MCJIT-creation.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/docs/MCJIT-load-object.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/docs/MCJIT-resolve-relocations.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/docs/ARM-BE-ld1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/docs/gcc-loops.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/docs/ARM-BE-bitcastsuccess.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/docs/linpack-pc.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/docs/ARM-BE-ldr.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/docs/tutorial/LangImpl05-cfg.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/docs/_static/lines.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/docs/_themes/llvm-theme/static/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/docs/_themes/llvm-theme/static/contents.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/llvm/src/docs/_themes/llvm-theme/static/navigation.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/cling/test/Prompt/ValuePrinter/Strings.dat",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/cling/www/JupyterScreenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/cling/www/style/graphic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/cling/www/style/link.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/cling/www/style/search.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/cling/www/style/bullet.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/cling/www/style/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/cling/www/style/menu_bg.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/cling/www/docs/talks/CreatingCling.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/cling/www/docs/talks/ImplementingDynamicScopesInCling.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/cling/www/docs/talks/ClingTheLLVM-basedInterpreter.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/cling/www/docs/talks/AxelNaumann-cling-GoogleTech.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/cling/tools/packaging/LLVM.ico",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/interpreter/cling/tools/packaging/LLVM.icns",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/HttpServer/figures/cover.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/minuit2/figures/cover.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/minuit2/figures/fcnbase.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/minuit2/figures/fcngradientbase.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/primer/figures/examplefit.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/primer/figures/TF1_DoubleSlit.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/primer/figures/th2f.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/primer/figures/TH1F_Example.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/primer/figures/graf_with_law.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/primer/figures/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/primer/figures/ROOTPanel_SetParameters.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/primer/figures/poisson.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/primer/figures/fitted2dFunction.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/primer/figures/polar_graph.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/primer/figures/histo_sum.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/primer/figures/TGraphErrors_Example.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/primer/figures/graph_with_expectation.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/primer/figures/ROOTPanel_FitPanel.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/primer/figures/multigraph.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/primer/figures/Cover.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/primer/figures/histo_ratio.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/primer/figures/functions.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/primer/figures/proj_and_prof.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/primer/figures/hstack.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/rootlogo_s.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/notebook.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/rootlogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/mathjax.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_geom_default.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter016.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/gpad_canvas.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter032.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_frame0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter021.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/g3d_brik.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/tgraph2d_delaunay.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter010.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/TFormula_eval.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_ctub_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/hlsimple_nofun.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/gpad_dialogbuttons.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/graf_graphqq2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_calorimeters.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_gtra_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_text.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_arrow_standalone.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum3_deconvolution_image001.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_frame1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_cons_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/TFormula_compile.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter011.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/TSpectrum_Deconvolution2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_tube_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/RooHypatia2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/gpad_slider.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/normal95.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum3_deconvolution_image003.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/RooJohnson_plot.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/uni95.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter007.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter004.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/splot_mass-bkg-sPlot.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_random2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum3_smoothing_image008.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumfit_awmi_image001.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_t_voxelfind.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter028.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/gpad_pad2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_triangleset.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/splot_genfiTOTNIM.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/graf_pavestext.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter040.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/RDF_Graph.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_geom_cms_stereo.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter033.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/base_inspect.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/ttree_friend1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum2fit_stiefel_image002.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/foam_Initialize_schema.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum2transform_enhance_image001.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_browser.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_box_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter020.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_show_extract.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/graf_graphqq1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_3ds.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_eltu_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_hype_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/hlGraph1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/g3d_xtru.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_pcon_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/av_cov.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumtransform_transform_image002.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum2fit_awmi_image002.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_mgr.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_t_node.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/TSpectrum2_Smoothing3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_t_voxtree.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/base_browser.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_t_example.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/TSpectrum2_Smoothing4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/foam_Map2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_box.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_boxset.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_annotation.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum2fit_awmi_image003.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter001.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_ctub_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum3_background_image006.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumtransform_enhance_image001.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum3_background_image003.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_trap_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_alice_esd_split.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter017.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum3_deconvolution_image004.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_cone_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/splot_pdfmesNIM.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/hlHisto3_top.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_pointset.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/g3d_na49.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/R_image1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumfit_constructor_image001.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum2fit_stiefel_image001.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/g3d_trap.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_t_finder.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_track.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_assembly.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter008.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_cons_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/TSpectrum2_Smoothing2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_geom_lhcb.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum2transform_transform_image002.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/wilson95.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/gpad_classtree1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter015.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/image_hist2image.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_hype_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_pcon_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_graf.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/gpad_pad5.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum2fit_awmi_image005.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_histobrowser.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter037.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/base_linestyle.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/gpad_pad3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter038.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/ac95.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_lineset.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumfit_stiefel_image001.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/g3d_axis3d_02.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum3_searching_image001.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter041.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumtransform_transform_image003.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/foam_schema2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter006.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/g3d_pgon.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_quadset.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter035.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_aliceproj.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/tmva_mlp.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_glplot_geom.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_para_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter031.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/g3d_trd1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/g3d_trd2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum2transform_filter_image002.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_glplot.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_boxset_cones.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_torus_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/RF_Landau.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_pack.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_sphe_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_tubs_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_calo_detail.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter019.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/gpad_pad4.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_cmsgeo.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/foam_MapCamel1000.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum3_deconvolution_image006.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum2transform_transform_image003.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_geom_atlas.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/TSpectrum_Background_smooth1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/g3d_polytype.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum2transform_enhance_image002.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_sphe_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter027.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/foam_Map3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/multidimfit_img86.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/cp95.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum3_searching_image003.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_projection_prescale.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/gpad_inspect.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_geom_alice_tpc.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/TSpectrum_Unfolding3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumfit_awmi_image002.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_cone_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/graf_pavelabel.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/g3d_shapes.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter024.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/gpad_controlbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum2fit_awmi_image004.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter005.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter030.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter002.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/TSpectrum2_Smoothing1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum3_background_image005.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/base_tbuffer3d.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumtransform_filter_image001.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/base_hsummenu.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_eltu_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_box_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter039.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/postscript_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_projection.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/g3d_gtra.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/TSpectrum_Deconvolution_wide4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_geom_alice_its.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/g3d_axis3d_01.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter023.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_view3ds.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter036.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/image_galaxy_image.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter018.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/TSpectrum_Deconvolution_wide1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/g3d_tubs.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/R_image2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_compound.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/ttree_treeview.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_tube_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/tchain_friend.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum3_deconvolution_image005.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_hierarchical_scene.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_booltree.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_scaledshape.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter034.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/mlp.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter003.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_alice_vsd.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter012.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum3_background_image007.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_geom_alias.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/gpad_ratioplot.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/ttree_friend2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/TSpectrum_Unfolding3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_pgon_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum2transform_filter_image001.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/gpad_pad1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/g3d_para.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_random1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_alice3d.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter013.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_trd2_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/g3d_cons.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/base_hsumdialog.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_trd1_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/g3d_tshape_classtree.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/RooArgusBG.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/base_tdictionary.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_torus_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter009.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_trd2_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/TSpectrum_Deconvolution_wide3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_tubs_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter025.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/graf_pave.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter022.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/base_classinfo.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_alice_esd.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/g3d_cone.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_checkpoint.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_para_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/R_image3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/hlgerrors2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/tbufferfile_double32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/jeffrey95.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/base_tasks.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/base_object.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/g3d_pcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/TSpectrum_Unfolding2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_trap_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_frameexp.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_geom_cms.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/gpad_classtree2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_trd1_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/TSpectrum_Deconvolution_wide2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/RooBukin.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/hlsimple.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/g3d_ctub.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter014.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/TFormula_analyze.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/g3d_tube.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter026.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum2fit_awmi_image001.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_window_manager.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_pgon_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum2fit_constructor_image001.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/ttree_makeselector_option_examples.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_jetcone.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/tbufferfile_fildir.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_gtra_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrum3_smoothing_image007.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/geom_t_shape.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/eve_csgdemo.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/doxygen/images/spectrumpainter029.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image068.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image086.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image180.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image176.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image216.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image026.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image246.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image078.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image072.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image230.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image114.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image074.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image016.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image090.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/cover.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image196.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image222.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image094.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image040.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image024.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image032.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image174.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image116.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image036.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image064.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image236.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image062.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image200.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image056.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image100.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image030.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image188.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image208.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image096.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image054.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image106.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image014.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image244.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image104.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image060.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image218.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image008.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image052.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image210.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image102.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image028.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image020.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image088.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image048.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image242.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image212.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image178.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image012.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image238.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image198.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image120.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image108.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image098.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image058.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image018.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image010.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image234.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image172.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image214.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image070.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image034.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image240.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image038.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image226.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image118.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image202.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image194.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image220.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image004.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image204.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image050.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image192.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image206.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image224.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image190.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image046.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image066.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image076.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image110.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image042.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image232.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image228.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image006.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/spectrum/figures/image044.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/url.sty",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/hypernat.sty",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/liktransform.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/MLP_SingleNode.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/category_rejBvsS.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/correlationscatter__NoTransform_c1.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/TMVAppFlow.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/PDEFoam-foam_bw.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/MVA-Likelihood.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/deviation_MLP_target_test_c0.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/CorrelationMatrixB.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/Schachbrett_ROC.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/Rarity-Likelihood.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/MLP.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/PDEFoam-foam_kernel_bw.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/CorrelationMatrixS.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/linDep.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/knn_3d_s13_b7_x02.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/knn_3d_s13_b7_x12.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/funcDep.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/category_var4_cat1.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/deviation_LD_target_test_c0.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/VariableTransforms.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/nonFuncDep.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/MVA-MLP.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/MVA-PDERS.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/TMVARegGui.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/pders_gauss.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/variables_c1.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/SVM.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/Schachbrett_both.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/correlationscatter__DecorrTransform_c1.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/Rarity-Fisher.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/MVA-Fisher.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/TMVAGui.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/BDTsketch.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/noDep.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/category_var4_cat2.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/rulefitpath.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/knn_3d_s13_b7_x01.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/TMVAnalysisFlow.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/rejBvsS.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/pders_teepee.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/MVA-BDT.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/multiclass/TMVAMulticlassGui.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/multiclass/TMVAMulticlassRoc1vsAll.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/cv/cv-workflows-ce.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/cv/cv-workflows-split.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/tmva/UsersGuide/plots/cv/cv-workflows-retrain.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/JSROOT/figures/cover.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000EA.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000092.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0200009D.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000DC.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001F4.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000B3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000058.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001A5.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300004E.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0200022C.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000103.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000D5.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000207.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/060001B9.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300022B.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000020.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001A4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/spider1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300020D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300005F.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001EF.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001E3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000F1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000215.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000DB.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000012.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000038.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/para11.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000013.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001E4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001EE.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000039.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000222.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/080001C6.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300005D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0800003F.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000010.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000220.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000016.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000106.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000F5.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000A0.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0200021A.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300003E.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/080001CA.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0200020B.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0200021E.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000E7.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001A7.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300008D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000DA.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000B1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0200020F.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0200009E.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000E8.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000221.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000A9.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000059.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000BE.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300002F.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000CD.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300012D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001E5.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001A1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300003A.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000045.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/bp1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000B4.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001B1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001FE.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000AC.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000B0.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000D6.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/060001C3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000C1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300002A.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000C8.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000223.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000054.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000FC.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000DF.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300004D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001F1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000E0.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/image212.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000005.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001F7.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000FE.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/spider2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001B4.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/060001BB.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000204.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000031.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000028.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/image443.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000216.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/para6.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000E5.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300004B.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001B3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000097.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001A8.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000E1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001A3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300001A.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000DE.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000F6.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000219.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000D9.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/080001CC.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300005C.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300002B.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/para3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000014.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000033.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001F5.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300000C.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000128.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/para9.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000A5.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000D0.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000E3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300000F.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000CF.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001E9.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000C3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000210.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300000D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0200021B.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000070.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000019.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000042.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000C6.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000026.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300009F.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001E2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/080001CF.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/060000C4.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000007.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000202.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000057.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/060001C4.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0200020E.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300001D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000050.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/para12.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001B5.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000208.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000040.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300000E.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/pad_02.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000AF.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001CE.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000C7.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/para2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/060001C2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/080001E7.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000061.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0200009C.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000A6.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/060001C0.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000EF.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000C9.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/080000A3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000025.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/para5.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000BC.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/para10.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000213.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0200003C.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/060001C5.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/060001BF.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000109.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001B2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001EB.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000027.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300000A.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001C9.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/060001B7.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/080001C1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000004.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300021D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000104.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000E9.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300004F.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000052.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000205.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001E1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000CA.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000E6.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/080001BC.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0200021F.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000CC.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/para4.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300004C.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001EC.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300000B.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000032.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000E4.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000DD.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000034.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0200020C.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000017.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000060.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/function-hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000EE.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001F6.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/pad_01.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/mathtext.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/para8.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000F8.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/para13.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300001C.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000105.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000200.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000211.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/para14.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000AB.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001EA.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/060001C7.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000056.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0200022A.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0200009B.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300001B.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000F4.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/Minimization.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000EB.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001F2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000094.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000218.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000A7.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/image145.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/rootlogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001F9.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000CE.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/080001CB.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001FD.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/060001BD.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000F2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000228.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300002D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000C5.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/080001E8.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000041.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000053.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000102.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/060001B8.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/th2poly1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000095.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/080001FF.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0200021C.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000036.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000022.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000F3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/060001BE.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001F8.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000D8.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300001F.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000A8.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001A9.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000224.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000229.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300005E.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000E2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000008.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/080001FA.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000108.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000D1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/para7.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000206.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300005A.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000023.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000049.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000096.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000225.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000ED.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000201.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/080001E6.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000FF.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000006.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000047.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000212.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000035.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001DF.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300003D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000009.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000015.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001A6.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0600002E.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000BD.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/Integration.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000062.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000209.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0600003B.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/060001C8.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000037.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000D3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001DE.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000043.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000018.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000D7.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000227.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000EC.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000217.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000AE.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000203.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300001E.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001E0.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000098.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0200020A.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000FA.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000214.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000024.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000CB.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/080001CD.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000099.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001F3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0300022D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000021.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/0200009A.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000055.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030001FC.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000C2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000011.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001ED.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/para1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000226.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/080001FB.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000B2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000AD.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000D2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000AA.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000030.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/image144.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/03000093.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/02000101.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020001F0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/020000A4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/030000D4.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/documentation/users-guide/pictures/060001B6.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/bindings/r/doc/users-guide/img/simplefit.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/bindings/r/doc/users-guide/img/minimization.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/bindings/r/doc/users-guide/img/logo.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/bindings/r/doc/users-guide/img/interpolation.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/bindings/r/doc/users-guide/img/.DS_Store",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/geom/doc/v522/geom_prev3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/freetype/src/freetype-2.6.1.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/doc/v520/graf2d_02.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/doc/v520/graf2d_01.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/doc/v600/lingrad.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/doc/v600/mathtext.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/doc/v600/ellipses.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/doc/v600/mixgrad.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/doc/v532/detail_view.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/doc/v532/file_contents.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/doc/v532/e5.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/doc/v532/top_level.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/doc/v532/tutorials.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/doc/v532/iospad.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/doc/v532/tut_editor.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/doc/v532/editors.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/doc/v528/markers.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/doc/v528/itbf.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/doc/v528/symbolitalic.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/doc/v526/graphstruct.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/doc/v534/quartz2d.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/doc/v522/graf2d_01.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/exchange.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/star.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/pirate.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/circle.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/crosshair.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/top-right-corner.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/gtk.ico",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/sb-v-double-arrow.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/dotbox.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/xterm.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/right-ptr.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/hand1.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/left-ptr-watch.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/gobbler.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/gumby.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/sb-up-arrow.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/sb-right-arrow.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/color-picker.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/fleur.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/hand2.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/top-left-corner.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/dnd-ask.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/sb-left-arrow.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/spider.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/question-arrow.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/shuttle.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/spraycan.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/dnd-copy.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/dnd-move.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/heart.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/dot.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/left-ptr.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/dnd-link.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/sb-down-arrow.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/Busy.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/X-cursor.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/pencil.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/center-ptr.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/umbrella.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/plus.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/sb-h-double-arrow.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/dnd-none.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf2d/win32gdk/gdk/src/glib/glib.rc",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/roofit/roofit/test/exponentialPdf.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/roofit/doc/v524/roofit_524_convolution.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/roofit/doc/v524/roofit_524_visualerror.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/roofit/doc/v524/roofit_524_derivatives.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/roofit/doc/v524/roofit_524_demo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/roofit/doc/v524/index.html",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/roofit/doc/v530/scan_cls.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/proof/doc/confman/img/sshcertauth-web.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v606/palette_112.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v606/ttree_makeselector_option_examples.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v610/ReverseAxis.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v610/NewBoxOption.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v610/NewMarkers.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_59.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_56.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_94.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_66.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_64.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_104.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_51.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_58.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_70.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_99.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_93.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_111.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_108.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_107.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_110.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_82.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_67.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_79.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_106.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_90.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_73.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_68.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/colz0.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_88.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_78.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_83.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_84.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_91.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_76.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_96.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_65.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_55.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_92.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_100.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_77.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_105.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_52.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_71.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_60.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_86.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/nostackb.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_54.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_69.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_62.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_57.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_75.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_109.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_102.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_63.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_53.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_101.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_87.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_89.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_72.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_98.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_85.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_80.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_97.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_81.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_103.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_61.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_95.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/README/ReleaseNotes/v604/palette_74.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/core/lzma/src/xz-5.2.4.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/core/lzma/src/xz-5.2.4-win32.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/core/doc/v600/pal255.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/core/doc/v530/hpxpyclassic.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/core/doc/v530/hlabmodern-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/core/doc/v530/hpxmodern.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/core/doc/v530/hpxpymodern.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/core/doc/v530/hpxclassic.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/core/doc/v530/hlabclassic-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/core/doc/v530/hlabmodern.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/core/doc/v530/hlabclassic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/math/smatrix/test/kalmam_slc3_ia32_gcc323.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/math/smatrix/test/testOperations_slc3_ia32_gcc323.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/math/unuran/src/unuran-1.8.0-root.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/test/HistFactoryTest.tar",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/test/stressHistFactory_ref.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/test/stressRooStats_ref.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/test/stressRooFit_ref.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/test/periodic/icons/Zr-loc.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/test/periodic/icons/topbar.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/test/RootShower/RootShower.ico",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/test/RootShower/RootShower.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/test/RootShower/Physics.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/test/histviewer/hist6_8.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/test/histviewer/hist4_5.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/symbol.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/cour.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/STIXSiz4Sym.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/courbd.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/comicbd.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/STIXSiz3Sym.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/FreeMonoBoldOblique.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/STIXSiz2Sym.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/verdanaz.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/georgiaz.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/wingding.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/STIXSiz1Sym.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/timesi.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/STIXSiz1SymBol.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/trebuc.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/FreeSansOblique.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/impact.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/STIXGeneralBol.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/couri.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/arial.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/STIXGeneralItalic.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/webdings.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/times.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/timesbd.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/arialbi.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/FreeSans.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/arialbd.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/ariali.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/STIXGeneral.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/courbi.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/georgiai.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/BlackChancery.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/monotype.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/FreeSerifItalic.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/FreeSerifBold.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/FreeSerif.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/verdana.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/STIXSiz4SymBol.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/STIXSiz2SymBol.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/trebucbd.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/STIXSiz3SymBol.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/STIXGeneralBolIta.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/trebucit.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/trebucbi.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/FreeSerifBoldItalic.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/georgiab.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/FreeSansBold.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/FreeMono.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/FreeMonoBold.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/STIXSiz5Sym.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/georgia.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/DroidSansFallback.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/verdanab.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/FreeSansBoldOblique.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/timesbi.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/FreeMonoOblique.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/ariblk.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/comic.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/fonts/verdanai.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/etc/notebook/kernels/root/logo-64x64.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/etc/notebook/custom/root-banner_99x33.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/etc/notebook/custom/root-logo-darkblue_33x33.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/etc/html/shadow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/etc/html/shadowAlpha.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/gallery.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/image/rose512.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/eve/swap.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/eve/nasashuttle.3ds",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/eve/Default.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/spectrum/TSpectrum.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/spectrum/TSpectrum2.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/proof/pythia8.par",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/proof/packtest2.par",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/proof/event.par",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/proof/ntprndm.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/proof/packtest1.par",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/proof/packtest3.par",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/quadp/stock.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/legacy/mlp/mlpHiggs.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/fitsio/sample3.fits",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/fitsio/sample1.fits",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/fitsio/sample5.fits",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/fitsio/sample4.fits",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/fitsio/sample2.fits",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/tmva/tmva_logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/tmva/line-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/tmva/sigmoid-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/tmva/data/toy_sigbkg_categ_offset.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/tmva/data/toy_sigbkg_categ_varoff.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/dataframe/df017_vecOpsHEP.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/doc/v528/mass_spectrum.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/tutorials/gui/worldmap.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/js/img/RootIcon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/js/style/images/ui-icons_444444_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/js/style/images/ui-icons_ffffff_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/js/style/images/ui-icons_cc0000_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/js/style/images/ui-icons_555555_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/js/style/images/ui-icons_777777_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/js/style/images/ui-icons_777620_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/misc/memstat/doc/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/misc/memstat/doc/caution.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/misc/memstat/doc/tip.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/misc/memstat/doc/note.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/misc/memstat/doc/important.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/misc/rootsl/English.lproj/InfoPlist.strings",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/misc/rootsl/English.lproj/schema.strings",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/misc/rootql/English.lproj/InfoPlist.strings",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf3d/doc/v520/graf3d_eve-news-1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf3d/doc/v520/graf3d_eve-news-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf3d/doc/v520/graf3d_eve-news-3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf3d/doc/v530/glvox1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/graf3d/doc/v530/glvox2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/doc/v520/index.html",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/doc/v524/index.html",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/doc/v522/index.html",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/gui/webdisplay/res/openui5.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/gui/doc/v520/gui_availabledrives.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/gui/doc/v520/gui_contextmenu.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/gui/doc/v522/gui_tgrecorder.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/gui/doc/v522/gui_tgpack.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.20.00-kntz22onqbphaims4ymh6yqjtbhzrd4l/spack-src/builtins/pcre/pcre-8.43.tar.bz2"
    ],
    "total_files": 18739
}