{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osg/GLExtensions.cpp": "/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield\n *\n * This library is open source and may be redistributed and/or modified under\n * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or\n * (at your option) any later version.  The full license is in LICENSE file\n * included with this distribution, and on the openscenegraph.org website.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * OpenSceneGraph Public License for more details.\n*/\n#include <osg/GLExtensions>\n#include <osg/GL>\n#include <osg/Notify>\n#include <osg/Math>\n#include <osg/buffered_value>\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <float.h>\n\n#include <string>\n#include <vector>\n#include <set>\n\n#if defined(WIN32)\n    #ifndef WIN32_LEAN_AND_MEAN\n        #define WIN32_LEAN_AND_MEAN\n    #endif // WIN32_LEAN_AND_MEAN\n    #ifndef NOMINMAX\n        #define NOMINMAX\n    #endif // NOMINMAX\n    #include <windows.h>\n#elif defined(__APPLE__)\n    // The NS*Symbol* stuff found in <mach-o/dyld.h> is deprecated.\n    // Since 10.3 (Panther) OS X has provided the dlopen/dlsym/dlclose\n    // family of functions under <dlfcn.h>. Since 10.4 (Tiger), Apple claimed\n    // the dlfcn family was significantly faster than the NS*Symbol* family.\n    // Since 'deprecated' needs to be taken very seriously with the\n    // coming of 10.5 (Leopard), it makes sense to use the dlfcn family when possible.\n    #include <AvailabilityMacros.h>\n    #if !defined(MAC_OS_X_VERSION_10_3) || (MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3)\n        #define USE_APPLE_LEGACY_NSSYMBOL\n        #include <mach-o/dyld.h>\n    #else\n        #include <dlfcn.h>\n    #endif\n#else\n    #include <dlfcn.h>\n#endif\n\ntypedef std::set<std::string>  ExtensionSet;\nstatic osg::buffered_object<ExtensionSet> s_glExtensionSetList;\nstatic osg::buffered_object<std::string> s_glRendererList;\nstatic osg::buffered_value<int> s_glInitializedList;\n\nstatic osg::buffered_object<ExtensionSet> s_gluExtensionSetList;\nstatic osg::buffered_object<std::string> s_gluRendererList;\nstatic osg::buffered_value<int> s_gluInitializedList;\n\nfloat osg::getGLVersionNumber()\n{\n    // needs to be extended to do proper things with subversions like 1.5.1, etc.\n    char *versionstring   = (char*) glGetString( GL_VERSION );\n    if (!versionstring) return 0.0;\n\n    return (findAsciiToFloat(versionstring));\n}\n\nbool osg::isExtensionInExtensionString(const char *extension, const char *extensionString)\n{\n    const char *startOfWord = extensionString;\n    const char *endOfWord;\n    while ((endOfWord = strchr(startOfWord,' ')) != 0)\n    {\n        if (strncmp(extension, startOfWord, endOfWord - startOfWord) == 0)\n            return true;\n        startOfWord = endOfWord+1;\n    }\n    if (*startOfWord && strcmp(extension, startOfWord) == 0)\n        return true;\n\n   return false;\n}\n\nbool osg::isGLExtensionSupported(unsigned int contextID, const char *extension)\n{\n    return osg::isGLExtensionOrVersionSupported(contextID, extension, FLT_MAX);\n}\n\nbool osg::isGLExtensionOrVersionSupported(unsigned int contextID, const char *extension, float requiredGLVersion)\n{\n    ExtensionSet& extensionSet = s_glExtensionSetList[contextID];\n    std::string& rendererString = s_glRendererList[contextID];\n\n    // first check to see if GL version number of recent enough.\n    bool result = requiredGLVersion <= osg::getGLVersionNumber();\n\n    if (!result)\n    {\n        // if not already set up, initialize all the per graphic context values.\n        if (!s_glInitializedList[contextID])\n        {\n            s_glInitializedList[contextID] = 1;\n\n            // set up the renderer\n            const GLubyte* renderer = glGetString(GL_RENDERER);\n            rendererString = renderer ? (const char*)renderer : \"\";\n\n            // get the extension list from OpenGL.\n            GLint numExt = 0;\n            #if !defined(OSG_GLES1_AVAILABLE) && !defined(OSG_GLES2_AVAILABLE)\n            if( osg::getGLVersionNumber() >= 3.0 )\n            {\n                // OpenGL 3.0 adds the concept of indexed strings and\n                // deprecates calls to glGetString( GL_EXTENSIONS ), which\n                // will now generate GL_INVALID_ENUM.\n\n                // Get extensions using new indexed string interface.\n\n                typedef const GLubyte * GL_APIENTRY PFNGLGETSTRINGIPROC( GLenum, GLuint );\n                PFNGLGETSTRINGIPROC* glGetStringi = 0;\n                setGLExtensionFuncPtr( glGetStringi, \"glGetStringi\");\n\n                if( glGetStringi != NULL )\n                {\n                    #  ifndef GL_NUM_EXTENSIONS\n                    #    define GL_NUM_EXTENSIONS 0x821D\n                    #  endif\n                    glGetIntegerv( GL_NUM_EXTENSIONS, &numExt );\n                    int idx;\n                    for( idx=0; idx<numExt; idx++ )\n                    {\n                        extensionSet.insert( std::string( (char*)( glGetStringi( GL_EXTENSIONS, idx ) ) ) );\n                    }\n                }\n                else\n                {\n                    OSG_WARN << \"isGLExtensionOrVersionSupported: Can't obtain glGetStringi function pointer.\" << std::endl;\n                }\n            }\n            #endif\n\n            // No extensions found so far, so try with glGetString\n            if (numExt == 0)\n            {\n                // Get extensions using GL1/2 interface.\n\n                const char* extensions = (const char*)glGetString(GL_EXTENSIONS);\n                if (extensions==NULL) return false;\n\n                // insert the ' ' delimiated extensions words into the extensionSet.\n                const char *startOfWord = extensions;\n                const char *endOfWord;\n                while ((endOfWord = strchr(startOfWord,' '))!=NULL)\n                {\n                    extensionSet.insert(std::string(startOfWord,endOfWord));\n                    startOfWord = endOfWord+1;\n                }\n                if (*startOfWord!=0) extensionSet.insert(std::string(startOfWord));\n            }\n\n    #if defined(WIN32) && (defined(OSG_GL1_AVAILABLE) || defined(OSG_GL2_AVAILABLE) || defined(OSG_GL3_AVAILABLE))\n\n            // add WGL extensions to the list\n\n            typedef const char* WINAPI WGLGETEXTENSIONSSTRINGARB(HDC);\n            WGLGETEXTENSIONSSTRINGARB* wglGetExtensionsStringARB = 0;\n            setGLExtensionFuncPtr(wglGetExtensionsStringARB, \"wglGetExtensionsStringARB\");\n\n            typedef const char* WINAPI WGLGETEXTENSIONSSTRINGEXT();\n            WGLGETEXTENSIONSSTRINGEXT* wglGetExtensionsStringEXT = 0;\n            setGLExtensionFuncPtr(wglGetExtensionsStringEXT, \"wglGetExtensionsStringEXT\");\n\n            const char* wglextensions = 0;\n\n            if (wglGetExtensionsStringARB)\n            {\n                HDC dc = wglGetCurrentDC();\n                wglextensions = wglGetExtensionsStringARB(dc);\n            }\n            else if (wglGetExtensionsStringEXT)\n            {\n                wglextensions = wglGetExtensionsStringEXT();\n            }\n\n            if (wglextensions)\n            {\n                const char* startOfWord = wglextensions;\n                const char* endOfWord;\n                while ((endOfWord = strchr(startOfWord, ' ')))\n                {\n                    extensionSet.insert(std::string(startOfWord, endOfWord));\n                    startOfWord = endOfWord+1;\n                }\n                if (*startOfWord != 0) extensionSet.insert(std::string(startOfWord));\n            }\n\n    #endif\n\n            OSG_NOTIFY(INFO)<<\"OpenGL extensions supported by installed OpenGL drivers are:\"<<std::endl;\n            for(ExtensionSet::iterator itr=extensionSet.begin();\n                itr!=extensionSet.end();\n                ++itr)\n            {\n                OSG_NOTIFY(INFO)<<\"    \"<<*itr<<std::endl;\n            }\n\n        }\n\n        // true if extension found in extensionSet.\n        result = extensionSet.find(extension)!=extensionSet.end();\n    }\n\n    // now see if extension is in the extension disabled list\n    bool extensionDisabled = false;\n    if (result)\n    {\n\n        const std::string& disableString = getGLExtensionDisableString();\n        if (!disableString.empty())\n        {\n\n            std::string::size_type pos=0;\n            while ( pos!=std::string::npos && (pos=disableString.find(extension,pos))!=std::string::npos )\n            {\n                std::string::size_type previousColon = disableString.find_last_of(':',pos);\n                std::string::size_type previousSemiColon = disableString.find_last_of(';',pos);\n\n                std::string renderer = \"\";\n                if (previousColon!=std::string::npos)\n                {\n                    if (previousSemiColon==std::string::npos) renderer = disableString.substr(0,previousColon);\n                    else if (previousSemiColon<previousColon) renderer = disableString.substr(previousSemiColon+1,previousColon-previousSemiColon-1);\n                }\n\n                if (!renderer.empty())\n                {\n\n                    // remove leading spaces if they exist.\n                    std::string::size_type leadingSpaces = renderer.find_first_not_of(' ');\n                    if (leadingSpaces==std::string::npos) renderer = \"\"; // nothing but spaces\n                    else if (leadingSpaces!=0) renderer.erase(0,leadingSpaces);\n\n                    // remove trailing spaces if they exist.\n                    std::string::size_type trailingSpaces = renderer.find_last_not_of(' ');\n                    if (trailingSpaces!=std::string::npos) renderer.erase(trailingSpaces+1,std::string::npos);\n\n                }\n\n                if (renderer.empty())\n                {\n                    extensionDisabled = true;\n                    break;\n                }\n\n                if (rendererString.find(renderer)!=std::string::npos)\n                {\n                    extensionDisabled = true;\n                    break;\n\n                }\n\n                // move the position in the disable string along so that the same extension is found multiple times\n                ++pos;\n            }\n\n        }\n    }\n\n    if (result)\n    {\n        if (!extensionDisabled)\n        {\n            OSG_NOTIFY(INFO)<<\"OpenGL extension '\"<<extension<<\"' is supported.\"<<std::endl;\n        }\n        else\n        {\n            OSG_NOTIFY(INFO)<<\"OpenGL extension '\"<<extension<<\"' is supported by OpenGL\\ndriver but has been disabled by osg::getGLExtensionDisableString().\"<<std::endl;\n        }\n    }\n    else\n    {\n        OSG_NOTIFY(INFO)<<\"OpenGL extension '\"<<extension<<\"' is not supported.\"<<std::endl;\n    }\n\n\n    return result && !extensionDisabled;\n}\n\nvoid osg::setGLExtensionDisableString(const std::string& disableString)\n{\n    getGLExtensionDisableString() = disableString;\n}\n\nstd::string& osg::getGLExtensionDisableString()\n{\n    static const char* envVar = getenv(\"OSG_GL_EXTENSION_DISABLE\");\n    static std::string s_GLExtensionDisableString(envVar?envVar:\"Nothing defined\");\n\n    return s_GLExtensionDisableString;\n}\n\n\n#ifdef OSG_GL_LIBRARY_STATIC\n\n    #include \"GLStaticLibrary.h\"\n\n    void* osg::getGLExtensionFuncPtr(const char *funcName)\n    {\n        return GLStaticLibrary::getProcAddress(funcName);\n    }\n\n#else\n\n    void* osg::getGLExtensionFuncPtr(const char *funcName)\n    {\n        // OSG_NOTICE<<\"osg::getGLExtensionFuncPtr(\"<<funcName<<\")\"<<std::endl;\n    #if defined(ANDROID)\n        #if defined(OSG_GLES1_AVAILABLE)\n            static void *handle = dlopen(\"libGLESv1_CM.so\", RTLD_NOW);\n        #elif defined(OSG_GLES2_AVAILABLE)\n            static void *handle = dlopen(\"libGLESv2.so\", RTLD_NOW);\n        #endif\n        return dlsym(handle, funcName);\n\n    #elif defined(WIN32)\n\n        #if defined(OSG_GLES2_AVAILABLE)\n            static HMODULE hmodule = GetModuleHandle(TEXT(\"libGLESv2.dll\"));\n            return convertPointerType<void*, PROC>(GetProcAddress(hmodule, funcName));\n        #elif defined(OSG_GLES1_AVAILABLE)\n            static HMODULE hmodule = GetModuleHandleA(TEXT(\"libgles_cm.dll\"));\n            return convertPointerType<void*, PROC>(GetProcAddress(hmodule, funcName));\n        #else\n            return convertPointerType<void*, PROC>(wglGetProcAddress(funcName));\n        #endif\n\n    #elif defined(__APPLE__)\n\n        #if defined(USE_APPLE_LEGACY_NSSYMBOL)\n            std::string temp( \"_\" );\n            temp += funcName;    // Mac OS X prepends an underscore on function names\n            if ( NSIsSymbolNameDefined( temp.c_str() ) )\n            {\n                NSSymbol symbol = NSLookupAndBindSymbol( temp.c_str() );\n                return NSAddressOfSymbol( symbol );\n            } else\n                return NULL;\n        #else\n            // I am uncertain of the correct and ideal usage of dlsym here.\n            // On the surface, it would seem that the FreeBSD implementation\n            // would be the ideal one to copy, but ELF and Mach-o are different\n            // and Apple's man page says the following about using RTLD_DEFAULT:\n            // \"This can be a costly search and should be avoided.\"\n            // The documentation mentions nothing about passing in 0 so I must\n            // assume the behavior is undefined.\n            // So I could try copying the Sun method which I think all this\n            // actually originated from.\n\n            // return dlsym( RTLD_DEFAULT, funcName );\n            static void *handle = dlopen((const char *)0L, RTLD_LAZY);\n            return dlsym(handle, funcName);\n        #endif\n\n    #elif defined (__sun)\n\n        static void *handle = dlopen((const char *)0L, RTLD_LAZY);\n        return dlsym(handle, funcName);\n\n    #elif defined (__sgi)\n\n        static void *handle = dlopen((const char *)0L, RTLD_LAZY);\n        return dlsym(handle, funcName);\n\n    #elif defined (__FreeBSD__)\n\n        return dlsym( RTLD_DEFAULT, funcName );\n\n    #elif defined (__linux__)\n\n        typedef void (*__GLXextFuncPtr)(void);\n        typedef __GLXextFuncPtr (*GetProcAddressARBProc)(const char*);\n\n        #if !defined(OSG_GLES1_AVAILABLE) && !defined(OSG_GLES2_AVAILABLE)\n        static GetProcAddressARBProc s_glXGetProcAddressARB = convertPointerType<GetProcAddressARBProc, void*>(dlsym(0, \"glXGetProcAddressARB\"));\n        if (s_glXGetProcAddressARB)\n        {\n            return convertPointerType<void*, __GLXextFuncPtr>((s_glXGetProcAddressARB)(funcName));\n        }\n        #endif\n\n        return dlsym(0, funcName);\n\n    #elif defined (__QNX__)\n\n        return dlsym(RTLD_DEFAULT, funcName);\n\n    #else // all other unixes\n\n        return dlsym(0, funcName);\n\n    #endif\n    }\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgDB/DynamicLibrary.cpp": "/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield\n *\n * This library is open source and may be redistributed and/or modified under\n * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or\n * (at your option) any later version.  The full license is in LICENSE file\n * included with this distribution, and on the openscenegraph.org website.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * OpenSceneGraph Public License for more details.\n*/\n\n//The dlopen calls were not adding to OS X until 10.3\n#ifdef __APPLE__\n#include <AvailabilityMacros.h>\n#if !defined(MAC_OS_X_VERSION_10_3) || (MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3)\n#define APPLE_PRE_10_3\n#endif\n#endif\n\n#if defined(WIN32) && !defined(__CYGWIN__)\n#include <io.h>\n#include <windows.h>\n#include <winbase.h>\n#elif defined(__APPLE__) && defined(APPLE_PRE_10_3)\n#include <mach-o/dyld.h>\n#else // all other unix\n#include <unistd.h>\n#ifdef __hpux\n// Although HP-UX has dlopen() it is broken! We therefore need to stick\n// to shl_load()/shl_unload()/shl_findsym()\n#include <dl.h>\n#include <errno.h>\n#else\n#include <dlfcn.h>\n#endif\n#endif\n\n#include <osg/Notify>\n#include <osg/GLExtensions>\n\n#include <osgDB/DynamicLibrary>\n#include <osgDB/FileUtils>\n#include <osgDB/FileNameUtils>\n#include <osgDB/ConvertUTF>\n\nusing namespace osgDB;\n\nDynamicLibrary::DynamicLibrary(const std::string& name, HANDLE handle)\n{\n    _name = name;\n    _handle = handle;\n    OSG_INFO<<\"Opened DynamicLibrary \"<<_name<<std::endl;\n}\n\nDynamicLibrary::~DynamicLibrary()\n{\n    if (_handle)\n    {\n        OSG_INFO<<\"Closing DynamicLibrary \"<<_name<<std::endl;\n#if defined(WIN32) && !defined(__CYGWIN__)\n        FreeLibrary((HMODULE)_handle);\n#elif defined(__APPLE__) && defined(APPLE_PRE_10_3)\n        NSUnLinkModule(static_cast<NSModule>(_handle), FALSE);\n#elif defined(__hpux)\n        // fortunately, shl_t is a pointer\n        shl_unload (static_cast<shl_t>(_handle));\n#else // other unix\n        dlclose(_handle);\n#endif\n    }\n}\n\nDynamicLibrary* DynamicLibrary::loadLibrary(const std::string& libraryName)\n{\n\n    HANDLE handle = NULL;\n\n    std::string fullLibraryName = osgDB::findLibraryFile(libraryName);\n    if (!fullLibraryName.empty()) handle = getLibraryHandle( fullLibraryName ); // try the lib we have found\n    else handle = getLibraryHandle( libraryName ); // havn't found a lib ourselves, see if the OS can find it simply from the library name.\n\n    if (handle) return new DynamicLibrary(libraryName,handle);\n\n    // else no lib found so report errors.\n    OSG_INFO << \"DynamicLibrary::failed loading \\\"\"<<libraryName<<\"\\\"\"<<std::endl;\n\n    return NULL;\n}\n\nDynamicLibrary::HANDLE DynamicLibrary::getLibraryHandle( const std::string& libraryName)\n{\n    HANDLE handle = NULL;\n\n#if defined(WIN32) && !defined(__CYGWIN__)\n#ifdef OSG_USE_UTF8_FILENAME\n    handle = LoadLibraryW(  convertUTF8toUTF16(libraryName).c_str() );\n#else\n    handle = LoadLibrary( libraryName.c_str() );\n#endif\n#elif defined(__APPLE__) && defined(APPLE_PRE_10_3)\n    NSObjectFileImage image;\n    // NSModule os_handle = NULL;\n    if (NSCreateObjectFileImageFromFile(libraryName.c_str(), &image) == NSObjectFileImageSuccess) {\n        // os_handle = NSLinkModule(image, libraryName.c_str(), TRUE);\n        handle = NSLinkModule(image, libraryName.c_str(), TRUE);\n        NSDestroyObjectFileImage(image);\n    }\n#elif defined(__hpux)\n    // BIND_FIRST is neccessary for some reason\n    handle = shl_load ( libraryName.c_str(), BIND_DEFERRED|BIND_FIRST|BIND_VERBOSE, 0);\n    return handle;\n#else // other unix\n\n    // dlopen will not work with files in the current directory unless\n    // they are prefaced with './'  (DB - Nov 5, 2003).\n    std::string localLibraryName;\n    if( libraryName == osgDB::getSimpleFileName( libraryName ) )\n        localLibraryName = \"./\" + libraryName;\n    else\n        localLibraryName = libraryName;\n\n    handle = dlopen( localLibraryName.c_str(), RTLD_LAZY | RTLD_GLOBAL);\n    if( handle == NULL )\n    {\n        if (fileExists(localLibraryName))\n        {\n            OSG_WARN << \"Warning: dynamic library '\" << libraryName << \"' exists, but an error occurred while trying to open it:\" << std::endl;\n            OSG_WARN << dlerror() << std::endl;\n        }\n        else\n        {\n            OSG_INFO << \"Warning: dynamic library '\" << libraryName << \"' does not exist (or isn't readable):\" << std::endl;\n            OSG_INFO << dlerror() << std::endl;\n        }\n    }\n#endif\n    return handle;\n}\n\nDynamicLibrary::PROC_ADDRESS DynamicLibrary::getProcAddress(const std::string& procName)\n{\n    if (_handle==NULL) return NULL;\n#if defined(WIN32) && !defined(__CYGWIN__)\n    return osg::convertPointerType<DynamicLibrary::PROC_ADDRESS, FARPROC>( GetProcAddress( (HMODULE)_handle, procName.c_str() ) );\n#elif defined(__APPLE__) && defined(APPLE_PRE_10_3)\n    std::string temp(\"_\");\n    NSSymbol symbol;\n    temp += procName;   // Mac OS X prepends an underscore on function names\n    symbol = NSLookupSymbolInModule(static_cast<NSModule>(_handle), temp.c_str());\n    return NSAddressOfSymbol(symbol);\n#elif defined(__hpux)\n    void* result = NULL;\n    if (shl_findsym (reinterpret_cast<shl_t*>(&_handle), procName.c_str(), TYPE_PROCEDURE, result) == 0)\n    {\n        return result;\n    }\n    else\n    {\n        OSG_WARN << \"DynamicLibrary::failed looking up \" << procName << std::endl;\n        OSG_WARN << \"DynamicLibrary::error \" << strerror(errno) << std::endl;\n        return NULL;\n    }\n#else // other unix\n    void* sym = dlsym( _handle,  procName.c_str() );\n    if (!sym) {\n        OSG_WARN << \"DynamicLibrary::failed looking up \" << procName << std::endl;\n        OSG_WARN << \"DynamicLibrary::error \" << dlerror() << std::endl;\n    }\n    return sym;\n#endif\n}\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/AUTHORS.txt",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/applications/osgversion/Contributors.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgViewer/GraphicsWindowWin32.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/bsp/Q3BSPReader.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/bsp/Q3BSPReader.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/LightPointRecords.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/RoadRecords.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/DataInputStream.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/DataInputStream.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/AttrData.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/ReservedRecords.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/RecordInputStream.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/Vertex.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/ControlRecords.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/Types.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/Registry.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/VertexRecords.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/Record.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/AncillaryRecords.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/Record.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/AttrData.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/Pools.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/Vertex.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/Opcodes.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/Pools.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/Registry.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/RecordInputStream.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/OpenFlight/PrimaryRecords.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/txp/license.txt",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/lwo/old_lw.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/lwo/old_lw.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/lwo/README_osg.txt",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/dae/daeRMaterials.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/geo/geoCore.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/geo/geoUnits.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/geo/geoFormat.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/geo/geoVersion.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/geo/geoTypes.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgPlugins/fbx/fbxRLight.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgUtil/tristripper/src/tri_stripper.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgUtil/tristripper/src/connectivity_graph.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgUtil/tristripper/src/policy.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgUtil/tristripper/include/tri_stripper.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgUtil/tristripper/include/public_types.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgUtil/tristripper/include/detail/heap_array.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgUtil/tristripper/include/detail/cache_simulator.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgUtil/tristripper/include/detail/connectivity_graph.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgUtil/tristripper/include/detail/policy.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgUtil/tristripper/include/detail/types.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osgUtil/tristripper/include/detail/graph_array.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osg/dxtctool.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/src/osg/dxtctool.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/examples/osgviewerMFC/res/Toolbar.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/examples/osgviewerMFC/res/MFC_OSG_MDI.ico",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/examples/osgviewerMFC/res/MFC_OSG_MDIDoc.ico",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/examples/osgsimplegl3/osgsimplegl3.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/examples/osgcatch/osgcatch.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/examples/osgAndroidExampleGLES2/res/drawable-ldpi/osg.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/examples/osgAndroidExampleGLES2/res/drawable-mdpi/osg.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/examples/osgAndroidExampleGLES2/res/drawable-hdpi/osg.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/examples/osgAndroidExampleGLES2/res/drawable-hdpi/web_browser.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/examples/osgviewerCocoa/English.lproj/InfoPlist.strings",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/examples/osgviewerCocoa/English.lproj/MainMenu.nib/keyedobjects.nib",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/examples/osgAndroidExampleGLES1/res/drawable-ldpi/osg.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/examples/osgAndroidExampleGLES1/res/drawable-mdpi/osg.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/examples/osgAndroidExampleGLES1/res/drawable-hdpi/osg.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/examples/osgAndroidExampleGLES1/res/drawable-hdpi/web_browser.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/examples/osgparticle/osgparticle.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/PlatformSpecifics/Windows/icons/osg.ico",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/PlatformSpecifics/Windows/icons/src/osg32.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/PlatformSpecifics/Windows/icons/src/osg16-32.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/PlatformSpecifics/Windows/icons/src/osg16.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/PlatformSpecifics/Windows/icons/src/osg32-8.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/PlatformSpecifics/Windows/icons/src/osg16-8.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/PlatformSpecifics/Windows/icons/src/osg48-4.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/PlatformSpecifics/Windows/icons/src/osg.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/PlatformSpecifics/Windows/icons/src/osg48-8.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/PlatformSpecifics/Windows/icons/src/osg48.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/PlatformSpecifics/Windows/icons/src/osg16-4.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/PlatformSpecifics/Windows/icons/src/osg48-32.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/PlatformSpecifics/Windows/icons/src/osg32-4.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/PlatformSpecifics/Windows/icons/src/osg32-32.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.1.5-nw2zpfi3vdpg7dqdvrlalhafva5j2mdj/spack-src/CMakeModules/FindOpenVRML.cmake"
    ],
    "total_files": 2612
}