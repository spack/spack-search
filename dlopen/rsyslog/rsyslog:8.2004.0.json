{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2004.0-ddt2obthz5sijsp3bwmmse3bl5yhm3hx/spack-src/configure.ac": "#                                               -*- Autoconf -*-\n# Process this file with autoconf to produce a configure script.\n\nAC_PREREQ(2.61)\nAC_INIT([rsyslog],[8.2004.0],[rsyslog@lists.adiscon.com])  # UPDATE on release\nAC_DEFINE(VERSION_YEAR, 20, [year part of real rsyslog version])  # UPDATE on release\nAC_DEFINE(VERSION_MONTH,04, [month part of real rsyslog version]) # UPDATE on release\n\nAM_INIT_AUTOMAKE([subdir-objects])\n\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\n\nunamestr=$(uname)\nif test \"$unamestr\" = \"AIX\"; then\n\tAC_ARG_ENABLE(aix64bits,\n\t\t[AS_HELP_STRING([--enable-aix64bits],[Enable compilation of rsyslog using 64 bits @<:@default=no@:>@])],\n\t        [case \"${enableval}\" in\n\t         yes) enable_aix64bits=\"yes\" ;;\n\t          no) enable_aix64bits=\"no\" ;;\n\t           *) AC_MSG_ERROR(bad value ${enableval} for --enable-aix64bits) ;;\n\t         esac],\n\t\t[enable_aix64bits=no]\n\t)\n\n\tCFLAGS=\"$CFLAGS -D_LINUX_SOURCE_COMPAT\"\n\tLDFLAGS=\"-brtl\"\n\tif test \"x$enable_aix64bits\" == \"xyes\"; then\n\t\tCFLAGS=\"$CFLAGS -q64\"\n\t\tLDFLAGS=\"$LDFLAGS -b64\"\n\t\tAR_CFLAGS=\"-X64 $AR_CFLAGS\"\n\t\tNM=\"$(which nm) -X64 rcu\"\n\tfi\nfi\n\nAC_CONFIG_SRCDIR([ChangeLog])\nAC_CONFIG_MACRO_DIR([m4])\nAC_CONFIG_HEADERS([config.h])\n\nAC_USE_SYSTEM_EXTENSIONS\n\n# Checks for programs.\nAC_PROG_LEX\nAC_PROG_YACC\nAC_PROG_CC\nAC_PROG_CC_C99\nAC_DISABLE_STATIC\n# AIXPORT START: enable dlopen\nif test \"$unamestr\" = \"AIX\"; then\n\tAC_LIBTOOL_DLOPEN\nfi\n# AIXPORT end\nAC_PROG_LIBTOOL\nAC_CANONICAL_HOST\n\nif test \"$GCC\" = \"yes\"\nthen\n\tm4_ifdef([AX_IS_RELEASE], [\n\t\tAX_IS_RELEASE([git-directory])\n\t\tm4_ifdef([AX_COMPILER_FLAGS], [\n\t\t\tAX_COMPILER_FLAGS(,,,,[-Wunused-parameter -Wmissing-field-initializers])\n\t\t\t# unfortunately, AX_COMPILER_FLAGS does not provide a way to override\n\t\t\t# the default -Wno-error=warning\" flags. So we do this via sed below.\n\t\t\t# Note: we *really* want to have this error out during CI testing!\n\t\t\t# rgerhards, 2018-05-09\n\t\t\tWARN_CFLAGS=\"$(echo \"$WARN_CFLAGS\" | sed s/-Wno-error=/-W/g)\"\n\t\t], [\n\t\t\tCFLAGS=\"$CFLAGS -W -Wall -Wformat-security -Wshadow -Wcast-align -Wpointer-arith -Wmissing-format-attribute -g\"\n\t\t\tAC_MSG_WARN([missing AX_COMPILER_FLAGS macro, not using it])\n\t\t])\n\t], [\n\t\tCFLAGS=\"$CFLAGS -W -Wall -Wformat-security -Wshadow -Wcast-align -Wpointer-arith -Wmissing-format-attribute -g\"\n\t\tAC_MSG_WARN([missing AX_IS_RELEASE macro, not using AX_COMPILER_FLAGS macro because of this])\n\t])\nelse\n\tAC_MSG_WARN([compiler is not GCC or close compatible, not using ax_compiler_flags because of this (CC=$CC)])\nfi\n\nPKG_PROG_PKG_CONFIG\n\nAC_ARG_VAR(CONF_FILE_PATH, Configuration file path (default : /etc/rsyslog.conf))\nif test \"$ac_cv_env_CONF_FILE_PATH_set\" = \"set\"; then\n\tAC_DEFINE_UNQUOTED(PATH_CONFFILE,  \"${ac_cv_env_CONF_FILE_PATH_value}\", \"Configuration file path (default : /etc/rsyslog.conf)\")\nfi\n\nAC_ARG_VAR(PID_FILE_PATH, Pid file path (default : /var/run/rsyslogd.pid))\nif test \"$ac_cv_env_PID_FILE_PATH_set\" = \"set\"; then\n\tAC_DEFINE_UNQUOTED(PATH_PIDFILE,  \"${ac_cv_env_PID_FILE_PATH_value}\", \"Pid file path (default : /var/run/rsyslogd.pid)\")\nfi\n\n\n# modules we require\nPKG_CHECK_MODULES(LIBESTR, libestr >= 0.1.9)\n\nPKG_CHECK_MODULES([LIBFASTJSON], [libfastjson >= 0.99.8],,)\n\nAC_DEFINE_UNQUOTED([PLATFORM_ID], [\"${host}\"], [platform id for display purposes])\n# we don't mind if we don't have the lsb_release utility. But if we have, it's\n# nice to have the extra information.\nAC_DEFINE_UNQUOTED([PLATFORM_ID_LSB], [\"`lsb_release -d`\"], [platform id for display purposes])\n\necho HOST: ${host}\ncase \"${host}\" in\n  *-*-linux*)\n    AC_DEFINE([OS_LINUX], [1], [Indicator for a Linux OS])\n    os_type=\"linux\"\n  ;;\n  *-*-*darwin*|*-*-dragonfly*|*-*-freebsd*|*-*-netbsd*|*-*-openbsd*)\n    AC_DEFINE([OS_BSD], [1], [Indicator for a BSD OS])\n    os_type=\"bsd\"\n  ;;\n  *-apple-*)\n    AC_DEFINE([OS_APPLE], [1], [Indicator for APPLE OS])\n    os_type=\"apple\"\n  ;;\n  *-*-kfreebsd*)\n    # kernel is FreeBSD, but userspace is glibc - i.e. like linux\n    # do not DEFINE OS_BSD\n    os_type=\"bsd\"\n  ;;\n  *-*-solaris*)\n    os_type=\"solaris\"\n    AC_DEFINE([OS_SOLARIS], [1], [Indicator for a Solaris OS])\n    AC_DEFINE([_POSIX_PTHREAD_SEMANTICS], [1], [Use POSIX pthread semantics])\n    AC_DEFINE([_XOPEN_SOURCE], [600], [Use X/Open CAE Specification])\n    CPPFLAGS=\"-std=c99 $CPPFLAGS\"\n    CFLAGS=\"-std=c99 $CFLAGS\"\n    SOL_LIBS=\"-lsocket -lnsl\"\n    # Solaris libuuid does not ship with a pkgconfig file so override the appropriate\n    # variables (but only if they have not been set by the user).\n    LIBUUID_CFLAGS=${LIBUUID_CFLAGS:= }\n    LIBUUID_LIBS=${LIBUUID_LIBS:=-luuid}\n    AC_SUBST(SOL_LIBS)\n  ;;\n  *-*-aix*)\n    os_type=\"aix\"\n    AC_DEFINE([OS_AIX], [1], [Indicator for a AIX OS])\n  ;;\nesac\nAM_CONDITIONAL(OS_APPLE, test x$os_type == xapple)\nAM_CONDITIONAL(OS_LINUX, test x$os_type == xlinux)\nAM_CONDITIONAL(OS_AIX, test x$os_type == xaix)\n\nAM_PATH_PYTHON(,, [:])\n\n# Running from git source?\nin_git_src=no\nAS_IF([test -d \"$srcdir\"/.git && ! test -f  \"$srcdir\"/.tarball-version], [in_git_src=yes])\n\n\nAC_DEFINE_UNQUOTED([HOSTENV], \"$host\", [the host environment, can be queried via a system variable])\n\n# Checks for libraries.\nsave_LIBS=$LIBS\nLIBS=\nAC_SEARCH_LIBS(clock_gettime, rt)\nRT_LIBS=$LIBS\nAC_SEARCH_LIBS(mq_getattr, rt)\nRT_LIBS=\"$RT_LIBS $LIBS\"\nLIBS=\nAC_SEARCH_LIBS(dlopen, dl)\nDL_LIBS=$LIBS\nLIBS=$save_LIBS\n\nAC_SUBST(RT_LIBS)\nAC_SUBST(DL_LIBS)\n\n# Checks for header files.\nAC_HEADER_RESOLV\nAC_HEADER_STDC\nAC_HEADER_SYS_WAIT\nAC_CHECK_HEADER([arpa/inet.h],[],[],[\n  [#ifdef HAVE_ARPA_INET_H\n     # include <arpa/inet.h>\n     #endif\n  ]\n])\nAC_CHECK_HEADERS([libgen.h],[],[],[\n  [#ifdef HAVE_LIBGEN_H\n     # include <libgen.h>\n     #endif\n  ]\n])\nAC_CHECK_HEADERS([malloc.h],[],[],[\n  [#ifdef HAVE_MALLOC_H\n     # include <malloc.h>\n     #endif\n  ]\n])\nAC_CHECK_HEADERS([fcntl.h locale.h netdb.h netinet/in.h paths.h stddef.h stdlib.h string.h sys/file.h sys/ioctl.h sys/param.h sys/socket.h sys/time.h sys/stat.h unistd.h utmp.h utmpx.h sys/epoll.h sys/prctl.h sys/select.h getopt.h])\n\n# Checks for typedefs, structures, and compiler characteristics.\nAC_C_CONST\nAC_C_INLINE\nAC_TYPE_OFF_T\nAC_TYPE_PID_T\nAC_TYPE_SIZE_T\nAC_TYPE_SSIZE_T\nAC_TYPE_MODE_T\nAC_TYPE_UID_T\nAC_TYPE_UINT8_T\nAC_HEADER_TIME\nAC_STRUCT_TM\nAC_C_VOLATILE\n\nsa_includes=\"\\\n$ac_includes_default\n#if HAVE_SYS_SOCKET_H\n# include <sys/socket.h>\n#endif\n\"\nAC_CHECK_MEMBERS([struct sockaddr.sa_len],,,[$sa_includes])\n\n# Checks for library functions.\nAC_FUNC_CHOWN\nAC_FUNC_FORK\nAC_PROG_GCC_TRADITIONAL\nAC_FUNC_SELECT_ARGTYPES\nAC_TYPE_SIGNAL\nAC_FUNC_STAT\nAC_FUNC_STRERROR_R\nAC_FUNC_VPRINTF\nAC_CHECK_FUNCS([flock recvmmsg basename alarm clock_gettime gethostbyname gethostname gettimeofday localtime_r memset mkdir regcomp select setsid socket strcasecmp strchr strdup strerror strndup strnlen strrchr strstr strtol strtoul uname ttyname_r getline malloc_trim prctl epoll_create epoll_create1 fdatasync syscall lseek64 asprintf])\nAC_CHECK_FUNC([setns], [AC_DEFINE([HAVE_SETNS], [1], [Define if setns exists.])])\nAC_CHECK_TYPES([off64_t])\n\nAC_CHECK_HEADERS([sys/inotify.h], [rsyslog_sysinotify=yes])\nAC_CHECK_FUNCS([inotify_init], [rsyslog_inotify_init=yes])\nAM_CONDITIONAL(ENABLE_INOTIFY, test x$rsyslog_sysinotify = xyes -a x$rsyslog_inotify_init = xyes)\n\n# getifaddrs is in libc (mostly) or in libsocket (eg Solaris 11) or not defined (eg Solaris 10)\nAC_SEARCH_LIBS([getifaddrs], [socket], [AC_DEFINE(HAVE_GETIFADDRS, [1], [set define])])\n\n# the check below is probably ugly. If someone knows how to do it in a better way, please\n# let me know! -- rgerhards, 2010-10-06\nAC_CHECK_DECL([SCM_CREDENTIALS], [AC_DEFINE(HAVE_SCM_CREDENTIALS, [1], [set define])], [], [#include <sys/types.h>\n#include <sys/socket.h>])\nAC_CHECK_DECL([SO_TIMESTAMP], [AC_DEFINE(HAVE_SO_TIMESTAMP, [1], [set define])], [], [#include <sys/types.h>\n#include <sys/socket.h>])\nAC_CHECK_DECL([SYS_gettid], [AC_DEFINE(HAVE_SYS_gettid, [1], [set define])], [], [#include <sys/syscall.h>])\nAC_CHECK_MEMBER([struct sysinfo.uptime], [AC_DEFINE(HAVE_SYSINFO_UPTIME, [1], [set define])], [], [#include <sys/sysinfo.h>])\nAC_CHECK_DECL([GLOB_NOMAGIC], [AC_DEFINE(HAVE_GLOB_NOMAGIC, [1], [set define])], [], [#include <glob.h>])\n\n# Check for MAXHOSTNAMELEN\nAC_MSG_CHECKING(for MAXHOSTNAMELEN)\nAC_TRY_COMPILE([\n\t#include <sys/param.h>\n\t#include <netdb.h>\n\t], [\n\treturn MAXHOSTNAMELEN;\n\t]\n\t,\n\tAC_MSG_RESULT(yes)\n\t,\n\t# note: we use 1024 here, which should be far more than needed by any system. If that's too low, we simply\n\t# life with the need to change it. Most of the code doesn't need it anyways, but there are a few places\n\t# where it actually is needed and it makes no sense to change them.\n\tAC_DEFINE(MAXHOSTNAMELEN, 1024, [Define with a value if your <sys/param.h> does not define MAXHOSTNAMELEN])\n\tAC_MSG_RESULT(no; defined as 64)\n)\n\n# check if GNU's ld is used\n\n# Check for __builtin_expect()\nAC_MSG_CHECKING([for __builtin_expect()])\nAC_LINK_IFELSE([AC_LANG_PROGRAM(, return __builtin_expect(main != 0, 1))],\n               [AC_DEFINE(HAVE_BUILTIN_EXPECT, 1,\n                          Define to 1 if compiler supports __builtin_expect)\n                AC_MSG_RESULT([yes])],\n               [AC_MSG_RESULT([no])])\n\n# check for availability of atomic operations\n# Note: this switch is primarily for the testbench, so that we can try\n# to build w/o automic operations on systems that actually support them.\n# Usually, atomic operations should be used when available as this\n# speeds up processig.\n# note that when automic operations are enabled but not available, they\n# will silently NOT be used!\nAC_ARG_ENABLE(atomic-operations,\n        [AS_HELP_STRING([--enable-atomic-operations],[Enable atomic operation support @<:@default=yes@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_atomic_operations=\"yes\" ;;\n          no) enable_atomic_operations=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-atomic-operations) ;;\n         esac],\n        [enable_atomic_operations=yes]\n)\nif test \"$enable_atomic_operations\" = \"yes\"; then\n\tRS_ATOMIC_OPERATIONS\n\tRS_ATOMIC_OPERATIONS_64BIT\nfi\n\n# fall back to POSIX sems for atomic operations (cpu expensive)\nAC_CHECK_HEADERS([semaphore.h sys/syscall.h])\n\n\n# Additional module directories\nAC_ARG_WITH(moddirs,\n        [AS_HELP_STRING([--with-moddirs=DIRS],[Additional module search paths appended to @<:@$libdir/rsyslog@:>@])],\n        [_save_IFS=$IFS ; IFS=$PATH_SEPARATOR ; moddirs=\"\"\n         for w in ${with_moddirs} ;\n         do\n                 case $w in\n                 \"\") continue ;; */) ;; *)  w=\"${w}/\" ;;\n                 esac\n                 for m in ${moddirs} ;\n                 do\n                         test \"x$w\" = \"x${libdir}/${PACKAGE}/\"   || \\\n                         test \"x$w\" = \"x$m\" || test \"x$w\" = \"x/\" && \\\n                         continue 2\n                 done\n                 case $moddirs in\n                 \"\") moddirs=\"$w\" ;; *) moddirs=\"${moddirs}:${w}\" ;;\n                 esac\n         done ; IFS=$_save_IFS],[moddirs=\"\"]\n)\nAM_CONDITIONAL(WITH_MODDIRS, test x$moddirs != x)\nAC_SUBST(moddirs)\n\n\n# Large file support\n# http://www.gnu.org/software/autoconf/manual/html_node/System-Services.html#index-AC_005fSYS_005fLARGEFILE-1028\nAC_SYS_LARGEFILE\ncase \"${enable_largefile}\" in\n  no) ;;\n  *) enable_largefile=\"yes\" ;;\nesac\n\n# Regular expressions\nAC_ARG_ENABLE(regexp,\n        [AS_HELP_STRING([--enable-regexp],[Enable regular expressions support @<:@default=yes@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_regexp=\"yes\" ;;\n          no) enable_regexp=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-regexp) ;;\n         esac],\n        [enable_regexp=yes]\n)\nAM_CONDITIONAL(ENABLE_REGEXP, test x$enable_regexp = xyes)\nif test \"$enable_regexp\" = \"yes\"; then\n        AC_DEFINE(FEATURE_REGEXP, 1, [Regular expressions support enabled.])\nfi\n\n# zlib support\nPKG_CHECK_MODULES([ZLIB], [zlib], [found_zlib=yes], [found_zlib=no])\nAS_IF([test \"x$found_zlib\" = \"xno\"], [\n        AC_SEARCH_LIBS([inflate], [z], [AC_CHECK_HEADER([zlib.h], [found_zlib=yes])])\n        if test \"x$found_zlib\" = \"xno\" ; then\n                AC_MSG_ERROR([zlib library and headers not found])\n        fi\n        ZLIB_LIBS=\"-lz\"\n        AC_SUBST(ZLIB_LIBS)\n])\n\n\n#hash implementations header checks\nAC_ARG_ENABLE(fmhash,\n\t[AS_HELP_STRING([--enable-fmhash],[Enable fmhash support @<:@default=yes@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_fmhash=\"yes\" ;;\n          no) enable_fmhash=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-fmhash) ;;\n         esac],\n\t[enable_fmhash=yes]\n)\n\nAC_ARG_ENABLE(fmhash-xxhash,\n\t[AS_HELP_STRING([--enable-fmhash-xxhash],[Enable xxhash in fmhash support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_fmhash_xxhash=\"yes\" ;;\n          no) enable_fmhash_xxhash=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-fmhash-xxhash) ;;\n         esac],\n\t[enable_fmhash_xxhash=no]\n)\n\nAM_CONDITIONAL(ENABLE_FMHASH, [test \"x$enable_fmhash\" = \"xyes\" || test \"x$enable_fmhash_xxhash\" = \"xyes\"])\n\nAM_CONDITIONAL(ENABLE_FMHASH_XXHASH, test x$enable_fmhash_xxhash = xyes)\nif test \"$enable_fmhash_xxhash\" = \"yes\"; then\n\tAC_CHECK_LIB([xxhash], [XXH64], [\n\t\tAC_CHECK_HEADER([xxhash.h], [\n\t\t\tAC_DEFINE(USE_HASH_XXHASH, 1,\n\t\t\t\t  [Using XXHASH for hash64.])\n\t\t\tHASH_XXHASH_LIBS=\"-lxxhash\"\n\t\t\tAC_SUBST(HASH_XXHASH_LIBS)],\n\t\t\t[AC_MSG_ERROR([Unable to add XXHASH support for hash64.])])\n\t])\nfi\n\n\n#gssapi\nAC_ARG_ENABLE(gssapi_krb5,\n\t[AS_HELP_STRING([--enable-gssapi-krb5],[Enable GSSAPI Kerberos 5 support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_gssapi_krb5=\"yes\" ;;\n          no) enable_gssapi_krb5=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-gssapi-krb5) ;;\n         esac],\n\t[enable_gssapi_krb5=no]\n)\n\ncase \"${os_type}\" in\nsolaris) GSSLIB=gss ;;\n*)       GSSLIB=gssapi_krb5 ;;\nesac\n\nif test $enable_gssapi_krb5 = yes; then\n\tAC_CHECK_LIB($GSSLIB, gss_acquire_cred, [\n\t\tAC_CHECK_HEADER(gssapi/gssapi.h, [\n\t\t\tAC_DEFINE(USE_GSSAPI,,\n\t\t\t\t  Define if you want to use GSSAPI)\n\t\t\tGSS_LIBS=\"-l$GSSLIB\"\n\t\t\tAC_SUBST(GSS_LIBS)\n\t\t])\n\t])\nfi\nAM_CONDITIONAL(ENABLE_GSSAPI, test x$enable_gssapi_krb5 = xyes)\n\n\n# shall the testbench try to run test that require root permissions?\n# This is uncommon. Test skip if run under non-root, but that pollutes the\n# testbench result. So the default is not to do that.\nAC_ARG_ENABLE(root_tests,\n        [AS_HELP_STRING([--enable-root-tests],[enable root tests in testbench @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_root_tests=\"yes\" ;;\n          no) enable_root_tests=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-root-tests) ;;\n         esac],\n        [enable_root_tests=no]\n)\nAM_CONDITIONAL(ENABLE_ROOT_TESTS, test x$enable_root_tests = xyes)\n\n# multithreading via pthreads\nif test \"$os_type\" != \"solaris\"\nthen\n\tAC_CHECK_HEADERS(\n\t\t[pthread.h],\n\t\t[\n\t\t\tAC_CHECK_LIB(\n\t\t\t\t[pthread],\n\t\t\t\t[pthread_create],\n\t\t\t\t[\n\t\t\t\t\tPTHREADS_LIBS=\"-lpthread\"\n\t\t\t\t\tif test \"$unamestr\" = \"AIX\"; then\n\t\t\t\t\tcase \"${CC}\" in\n\t\t\t\t\t\t*xlc*|*xlC*) PTHREADS_CFLAGS=\"-qthreaded\" ;;\n\t\t\t\t\t\t*) PTHREADS_CFLAGS=\"-lpthreads\" ;;\n\t\t\t\t\tesac\n\t\t\t\t\telse\n\t\t\t\t\t\tPTHREADS_CFLAGS=\"-pthread\"\n\t\t\t\t\tfi\n\t\t\t\t\tAC_SUBST(PTHREADS_LIBS)\n\t\t\t\t\tAC_SUBST(PTHREADS_CFLAGS)\n\t\t\t\t],\n\t\t\t\t[AC_MSG_FAILURE([pthread is missing])],\n\t\t\t\t[-lpthread]\n\t\t\t)\n\t\t],\n\t\t[AC_MSG_FAILURE([pthread is missing])]\n\t)\nfi\n\nAC_CHECK_LIB(\n  [pthread],\n\t[pthread_rwlockattr_setkind_np],\n\t[AC_DEFINE(\n\t   [HAVE_PTHREAD_RWLOCKATTR_SETKIND_NP],\n\t\t [1],\n\t\t [Set-kind available for rwlock attr.])])\n\nAC_CHECK_LIB(\n  [pthread],\n\t[pthread_setname_np],\n\t[AC_DEFINE(\n\t   [HAVE_PTHREAD_SETNAME_NP],\n\t\t [1],\n\t\t [Can set thread-name.])])\n\nAC_SEARCH_LIBS(\n    [pthread_setschedparam],\n    [pthread],\n    [\n      rsyslog_have_pthread_setschedparam=yes\n      AC_DEFINE([HAVE_PTHREAD_SETSCHEDPARAM],\n\t[1],\n\t[Can set thread scheduling parameters])\n    ],\n    [\n      rsyslog_have_pthread_setschedparam=no\n    ]\n)\nAC_CHECK_HEADERS(\n    [sched.h],\n    [\n      rsyslog_have_sched_h=yes\n    ],\n    [\n      rsyslog_have_sched_h=no\n    ]\n)\nif test \"$rsyslog_have_pthread_setschedparam\" = \"yes\" -a \"$rsyslog_have_sched_h\" = \"yes\"; then\n\tsave_LIBS=$LIBS\n\tLIBS=\n\tAC_SEARCH_LIBS(sched_get_priority_max, rt)\n\tif test \"x$ac_cv_search\" != \"xno\"; then\n\t\tAC_CHECK_FUNCS(sched_get_priority_max)\n\tfi\n\tIMUDP_LIBS=$LIBS\n\tAC_SUBST(IMUDP_LIBS)\n\tLIBS=$save_LIBS\nfi\n\nif test \"$unamestr\" = \"AIX\"; then\nenable_klog=\"no\"\nelse\n# klog\nAC_ARG_ENABLE(klog,\n        [AS_HELP_STRING([--enable-klog],[Integrated klog functionality @<:@default=yes@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_klog=\"yes\" ;;\n          no) enable_klog=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-klog) ;;\n         esac],\n        [enable_klog=\"yes\"]\n)\nfi\nAM_CONDITIONAL(ENABLE_IMKLOG, test x$enable_klog = xyes)\nAM_CONDITIONAL(ENABLE_IMKLOG_BSD, test x$os_type = xbsd)\nAM_CONDITIONAL(ENABLE_IMKLOG_LINUX, test x$os_type = xlinux)\nAM_CONDITIONAL(ENABLE_IMKLOG_SOLARIS, test x$os_type = xsolaris)\n\n# kmsg\nAC_ARG_ENABLE(kmsg,\n        [AS_HELP_STRING([--enable-kmsg],[Kmsg structured kernel logs functionality @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_kmsg=\"yes\" ;;\n          no) enable_kmsg=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-kmsg) ;;\n         esac],\n        [enable_kmsg=\"no\"]\n)\nAM_CONDITIONAL(ENABLE_IMKMSG, test x$enable_kmsg = xyes)\n\n# imjournal\nAC_ARG_ENABLE(imjournal,\n        [AS_HELP_STRING([--enable-imjournal],[Systemd journal message import @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_imjournal=\"yes\" ;;\n          no) enable_imjournal=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-imjournal) ;;\n         esac],\n        [enable_imjournal=\"no\"]\n)\nif test \"x$enable_imjournal\" = \"xyes\"; then\n\tPKG_CHECK_MODULES([LIBSYSTEMD_JOURNAL], [libsystemd >= 234] , [AC_DEFINE(NEW_JOURNAL, 1, [new systemd present])] , [\n\t    PKG_CHECK_MODULES([LIBSYSTEMD_JOURNAL], [libsystemd >= 209] , , [\n\t        PKG_CHECK_MODULES([LIBSYSTEMD_JOURNAL], [libsystemd-journal >= 197])\n\t    ])\n\t])\nfi\nAM_CONDITIONAL(ENABLE_IMJOURNAL, test x$enable_imjournal = xyes)\n\n# use libsystemd\nAC_ARG_ENABLE(libsystemd,\n        [AS_HELP_STRING([--enable-libsystemd],[Enable libsystemd mode @<:@default=auto@:>@])],\n        [case \"${enableval}\" in\n          yes) enable_libsystemd=\"yes\" ;;\n           no) enable_libsystemd=\"no\" ;;\n         auto) enable_libsystemd=\"auto\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-libsystemd) ;;\n         esac],\n        [enable_libsystemd=\"auto\"]\n)\nif test \"$enable_libsystemd\" = \"yes\"; then\n\tPKG_CHECK_MODULES([LIBSYSTEMD], [libsystemd],\n\t\t[ AC_DEFINE(HAVE_LIBSYSTEMD, 1, [libsystemd present]) ]\n\t)\nfi\nif test \"$enable_libsystemd\" = \"auto\"; then\n\tPKG_CHECK_MODULES([LIBSYSTEMD], [libsystemd],\n\t\t[ AC_DEFINE(HAVE_LIBSYSTEMD, 1, [libsystemd present])\n\t\t  AC_MSG_NOTICE([--enable-libsystemd in auto mode])\n\t\t  enable_libsystemd=\"yes\"\n\t\t],\n\t\t[ AC_MSG_WARN([libsystemd not present - disabling systemd support])\n\t\t  enable_libsystemd=\"no\"\n\t\t]\n\t)\n\tAC_MSG_NOTICE([--enable-libsystemd in auto mode, enable-libsystemd is set to ${enable_libsystemd}])\nfi\n\n# inet\nAC_ARG_ENABLE(inet,\n        [AS_HELP_STRING([--enable-inet],[Enable networking support @<:@default=yes@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_inet=\"yes\" ;;\n          no) enable_inet=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-inet) ;;\n         esac],\n        [enable_inet=\"yes\"]\n)\nAM_CONDITIONAL(ENABLE_INET, test x$enable_inet = xyes)\nif test \"$enable_inet\" = \"yes\"; then\n        AC_DEFINE(SYSLOG_INET, 1, [network support is integrated.])\nfi\n\n# jemalloc\nAC_ARG_ENABLE(jemalloc,\n        [AS_HELP_STRING([--enable-jemalloc],[Enable jemalloc support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_jemalloc=\"yes\" ;;\n          no) enable_jemalloc=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-jemalloc) ;;\n         esac],\n        [enable_jemalloc=\"no\"]\n)\nAM_CONDITIONAL(ENABLE_JEMALLOC, test x$enable_jemalloc = xyes)\nif test \"$enable_jemalloc\" = \"yes\"; then\n  AC_CHECK_LIB(\n    [jemalloc],\n    [malloc_stats_print],\n    [RT_LIBS=\"$RT_LIBS -ljemalloc\"\n     AC_DEFINE(HAVE_JEMALLOC, 1, [jemalloc support is integrated.])\n    ],\n    [AC_MSG_FAILURE([jemalloc library is missing])],\n    []\n    )\nfi\n\n\n# support for unlimited select() syscall\nAC_ARG_ENABLE(unlimited_select,\n        [AS_HELP_STRING([--enable-unlimited-select],[Enable unlimited select() syscall @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_unlimited_select=\"yes\" ;;\n          no) enable_unlimited_select=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-unlimited-select) ;;\n         esac],\n        [enable_unlimited_select=\"no\"]\n)\nif test \"$enable_unlimited_select\" = \"yes\"; then\n        AC_DEFINE(USE_UNLIMITED_SELECT, 1, [If defined, the select() syscall won't be limited to a particular number of file descriptors.])\nfi\n\n\n# support for systemd unit files\nAC_ARG_WITH([systemdsystemunitdir],\n        AS_HELP_STRING([--with-systemdsystemunitdir=DIR], [Directory for systemd service files]),\n        [], [with_systemdsystemunitdir=$($PKG_CONFIG --variable=systemdsystemunitdir systemd)])\nif test \"x$with_systemdsystemunitdir\" != xno; then\n        AC_SUBST([systemdsystemunitdir], [$with_systemdsystemunitdir])\nfi\nAM_CONDITIONAL(HAVE_SYSTEMD, [test -n \"$with_systemdsystemunitdir\" -a \"x$with_systemdsystemunitdir\" != xno ])\n\n\n# debug\nAC_ARG_ENABLE(debug,\n        [AS_HELP_STRING([--enable-debug],[Enable debug mode @<:@default=auto@:>@])],\n        [case \"${enableval}\" in\n          yes) enable_debug=\"yes\" ;;\n           no) enable_debug=\"no\" ;;\n         auto) enable_debug=\"auto\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-debug) ;;\n         esac],\n        [enable_debug=\"auto\"]\n)\nif test \"$enable_debug\" = \"auto\"; then\n\tif test \"x$in_git_src\" = \"xyes\"; then\n\t\tenable_debug=\"yes\"\n\telse\n\t\tenable_debug=\"no\"\n\tfi\n\tAC_MSG_NOTICE([enable-debug in auto mode, enable-debug is set to ${enable_debug}])\nfi\nif test \"$enable_debug\" = \"yes\"; then\n        AC_DEFINE(DEBUG, 1, [Defined if debug mode is enabled (its easier to check).])\nfi\nif test \"$enable_debug\" = \"no\"; then\n        AC_DEFINE(NDEBUG, 1, [Defined if debug mode is disabled.])\nfi\n\n\n# debug-symbols\nAC_ARG_ENABLE(debug_symbols,\n        [AS_HELP_STRING([--disable-debug-symbols],[Disable debugging symbols @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_debug_symbols=\"yes\" ;;\n          no) enable_debug_symbols=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --disable-debug-symbols) ;;\n         esac],\n        [enable_debug_symbols=\"yes\"]\n)\n\n\n# total debugless: highest performance, but no way at all to enable debug\n# logging\nAC_ARG_ENABLE(debugless,\n        [AS_HELP_STRING([--enable-debugless],[Enable runtime instrumentation mode @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_debugless=\"yes\" ;;\n          no) enable_debugless=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-debugless) ;;\n         esac],\n        [enable_debugless=\"no\"]\n)\nif test \"$enable_debugless\" = \"yes\"; then\n        AC_DEFINE(DEBUGLESS, 1, [Defined if debugless mode is enabled.])\nfi\n\n\n# valgrind\nAC_ARG_ENABLE(valgrind,\n        [AS_HELP_STRING([--enable-valgrind],[Enable somes special code that rsyslog core developers consider useful for testing. Do NOT use if you don't exactly know what you are doing, except if told so by rsyslog developers. NOT to be used by distro maintainers for building regular packages. @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_valgrind=\"yes\" ;;\n          no) enable_valgrind=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-valgrind) ;;\n         esac],\n        [enable_valgrind=\"no\"]\n)\nif test \"$enable_valgrind\" = \"yes\"; then\n        AC_DEFINE(VALGRIND, 1, [Defined if valgrind support settings are to be enabled (e.g. prevents dlclose()).])\nfi\n\n\n# compile diagnostic tools (small helpers usually not needed)\nAC_ARG_ENABLE(diagtools,\n        [AS_HELP_STRING([--enable-diagtools],[Enable diagnostic tools @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_diagtools=\"yes\" ;;\n          no) enable_diagtools=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-diagtools) ;;\n         esac],\n        [enable_diagtools=no]\n)\nAM_CONDITIONAL(ENABLE_DIAGTOOLS, test x$enable_diagtools = xyes)\n\n\n# compile end-user tools\nAC_ARG_ENABLE(usertools,\n        [AS_HELP_STRING([--enable-usertools],[Enable end user tools @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_usertools=\"yes\" ;;\n          no) enable_usertools=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-usertools) ;;\n         esac],\n        [enable_usertools=no]\n)\nAM_CONDITIONAL(ENABLE_USERTOOLS, test x$enable_usertools = xyes)\n\n\n# MySQL support\nAC_ARG_ENABLE(mysql,\n        [AS_HELP_STRING([--enable-mysql],[Enable MySql database support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_mysql=\"yes\" ;;\n          no) enable_mysql=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-mysql) ;;\n         esac],\n        [enable_mysql=no]\n)\nAS_IF([test \"x$enable_mysql\" = \"xyes\"],[\n  PKG_CHECK_MODULES([MYSQL],[mysqlclient],,[\n    AC_CHECK_PROG(\n      [MYSQL_CONFIG],\n      [mysql_config],\n      [mysql_config],\n      [no],,\n    )\n    AS_IF([test \"x${MYSQL_CONFIG}\" = \"xno\"],[\n      AC_MSG_FAILURE([mysql_config not found - usually a package named mysql-dev, libmysql-dev or similar, is missing - install it to fix this issue])\n    ])\n    MYSQL_CFLAGS=`$MYSQL_CONFIG --cflags`\n    MYSQL_LIBS=`$MYSQL_CONFIG --libs`\n  ])\n  AC_MSG_CHECKING(if we have mysql_library_init)\n  save_CFLAGS=\"$CFLAGS\"\n  CFLAGS=\"$CFLAGS $MYSQL_CFLAGS\"\n  save_LIBS=\"$LIBS\"\n  AC_CHECK_LIB(\n    [mysqlclient],\n    [mysql_init],\n    ,\n    [AC_MSG_FAILURE([MySQL library is missing])],\n    [$MYSQL_LIBS]\n  )\n  LIBS=\"$LIBS $MYSQL_LIBS\"\n  AC_TRY_LINK(\n    [#include <mysql.h>\n     #include <stdio.h>],\n    [mysql_library_init(0, NULL, NULL)],\n    [have_mysql_library_init=yes],\n    [have_mysql_library_init=no])\n  CFLAGS=\"$save_CFLAGS\"\n  LIBS=\"$save_LIBS\"\n])\nAM_CONDITIONAL(ENABLE_MYSQL, test x$enable_mysql = xyes)\nif test \"$have_mysql_library_init\" = \"yes\"; then\n  AC_DEFINE([HAVE_MYSQL_LIBRARY_INIT], [1], [mysql_library_init available])\nfi\nAC_SUBST(MYSQL_CFLAGS)\nAC_SUBST(MYSQL_LIBS)\n\n\n# PostgreSQL support\nAC_ARG_ENABLE(pgsql,\n        [AS_HELP_STRING([--enable-pgsql],[Enable PostgreSQL database support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_pgsql=\"yes\" ;;\n          no) enable_pgsql=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-pgsql) ;;\n         esac],\n        [enable_pgsql=no]\n)\nif test \"x$enable_pgsql\" = \"xyes\"; then\n\tPKG_CHECK_MODULES([PGSQL], [libpq],, [\n\t  AC_CHECK_PROG(\n\t    [PG_CONFIG],\n\t    [pg_config],\n\t    [pg_config],\n\t    [no],,,\n\t  )\n\t  if test \"x${PG_CONFIG}\" = \"xno\"; then\n\t    AC_MSG_FAILURE([pg_config not found])\n\t  fi\n\t  AC_CHECK_LIB(\n\t    [pq],\n\t    [PQconnectdb],\n\t    [PGSQL_CFLAGS=\"-I`$PG_CONFIG --includedir`\"\n\t     PGSQL_LIBS=\"-L`$PG_CONFIG --libdir` -lpq\"\n\t    ],\n\t    [AC_MSG_FAILURE([PgSQL library is missing])],\n\t    [-L`$PG_CONFIG --libdir`]\n\t  )\n\t])\nfi\nAM_CONDITIONAL(ENABLE_PGSQL, test x$enable_pgsql = xyes)\nAC_SUBST(PGSQL_CFLAGS)\nAC_SUBST(PGSQL_LIBS)\n\n# libdbi support\nAC_ARG_ENABLE(libdbi,\n        [AS_HELP_STRING([--enable-libdbi],[Enable libdbi database support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_libdbi=\"yes\" ;;\n          no) enable_libdbi=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-libdbi) ;;\n         esac],\n        [enable_libdbi=no]\n)\nif test \"x$enable_libdbi\" = \"xyes\"; then\n  AC_CHECK_HEADERS(\n    [dbi/dbi.h],,\n    [AC_MSG_FAILURE([libdbi is missing])]\n  )\n  AC_CHECK_LIB(\n    [dbi],\n    [dbi_initialize],\n    [LIBDBI_CFLAGS=\"\"\n     LIBDBI_LIBS=\"-ldbi\"\n    ],\n    [AC_MSG_FAILURE([libdbi library is missing])]\n  )\n  AC_CHECK_LIB(\n    [dbi],\n    [dbi_initialize_r],\n    [AC_DEFINE([HAVE_DBI_R], [1], [Define to 1 if libdbi supports the new plugin-safe interface])]\n  )\n  AC_CHECK_LIB(\n    [dbi],\n    [dbi_conn_transaction_begin],\n    [AC_DEFINE([HAVE_DBI_TXSUPP], [1], [Define to 1 if libdbi supports transactions])]\n  )\nfi\nAM_CONDITIONAL(ENABLE_OMLIBDBI, test x$enable_libdbi = xyes)\nAC_SUBST(LIBDBI_CFLAGS)\nAC_SUBST(LIBDBI_LIBS)\n\n# SNMP support\nAC_ARG_ENABLE(snmp,\n        [AS_HELP_STRING([--enable-snmp],[Enable SNMP support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_snmp=\"yes\" ;;\n          no) enable_snmp=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-snmp) ;;\n         esac],\n        [enable_snmp=no]\n)\nif test \"x$enable_snmp\" = \"xyes\"; then\n  AC_CHECK_HEADERS(\n    [net-snmp/net-snmp-config.h],,\n    [AC_MSG_FAILURE([Net-SNMP is missing])]\n  )\n  AC_CHECK_LIB(\n    [netsnmp],\n    [snmp_timeout],\n    [SNMP_CFLAGS=\"\"\n     SNMP_LIBS=\"-lnetsnmp\"\n    ],\n    [AC_MSG_FAILURE([Net-SNMP library is missing])]\n  )\nfi\nAM_CONDITIONAL(ENABLE_SNMP, test x$enable_snmp = xyes)\nAC_SUBST(SNMP_CFLAGS)\nAC_SUBST(SNMP_LIBS)\n\n# SNMP Test Support\nAC_ARG_ENABLE(snmp-tests,\n        [AS_HELP_STRING([--enable-snmp-tests],[Enable omsnmp tests @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_snmp_tests=\"yes\" ;;\n          no) enable_snmp_tests=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-snmp-tests) ;;\n         esac],\n        [enable_snmp_tests=no]\n)\nAM_CONDITIONAL(ENABLE_SNMP_TESTS, test x$enable_snmp_tests = xyes)\n\n# uuid support\nAC_ARG_ENABLE(uuid,\n        [AS_HELP_STRING([--enable-uuid],[Enable support for uuid generation @<:@default=yes@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_uuid=\"yes\" ;;\n          no) enable_uuid=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-uuid) ;;\n         esac],\n        [enable_uuid=yes]\n)\nif test \"x$enable_uuid\" = \"xyes\"; then\n\tPKG_CHECK_MODULES([LIBUUID], [uuid])\n\tAC_DEFINE(USE_LIBUUID, 1, [Define if you want to enable libuuid support])\nfi\nAM_CONDITIONAL(ENABLE_UUID, test x$enable_uuid = xyes)\n\n\n# elasticsearch support\nAC_ARG_ENABLE(elasticsearch,\n        [AS_HELP_STRING([--enable-elasticsearch],[Enable elasticsearch output module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_elasticsearch=\"yes\" ;;\n          no) enable_elasticsearch=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-elasticsearch) ;;\n         esac],\n        [enable_elasticsearch=no]\n)\nif test \"x$enable_elasticsearch\" = \"xyes\"; then\n\tPKG_CHECK_MODULES([CURL], [libcurl])\n\tLT_LIB_M\nfi\nAM_CONDITIONAL(ENABLE_ELASTICSEARCH, test x$enable_elasticsearch = xyes)\n\n\n# clickhouse support\nAC_ARG_ENABLE(clickhouse,\n        [AS_HELP_STRING([--enable-clickhouse],[Enable clickhouse output module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_clickhouse=\"yes\" ;;\n          no) enable_clickhouse=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-clickhouse) ;;\n         esac],\n        [enable_clickhouse=no]\n)\nif test \"x$enable_clickhouse\" = \"xyes\"; then\n\tPKG_CHECK_MODULES([CURL], [libcurl])\n\tLT_LIB_M\nfi\nAM_CONDITIONAL(ENABLE_CLICKHOUSE, test x$enable_clickhouse = xyes)\n\n\n# omhttp support\nAC_ARG_ENABLE(omhttp,\n        [AS_HELP_STRING([--enable-omhttp],[Enable http output module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_omhttp=\"yes\" ;;\n          no) enable_omhttp=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-omhttp) ;;\n         esac],\n        [enable_omhttp=no]\n)\nif test \"x$enable_omhttp\" = \"xyes\"; then\n        PKG_CHECK_MODULES([CURL], [libcurl])\n        LT_LIB_M\nfi\nAM_CONDITIONAL(ENABLE_OMHTTP, test x$enable_omhttp = xyes)\n\n\n# capability to enable elasticsearch testbench tests. This requries that an ES test\n# environment is present on the local (127.0.0.1) machine.\n# we support a \"minimal\" mode to take care of travis where we cannot run all tests\n# due to runtime constraints\nAC_ARG_ENABLE(elasticsearch_tests,\n        [AS_HELP_STRING([--enable-elasticsearch-tests],[enable Elasticsearch specific tests in testbench @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_elasticsearch_tests=\"yes\" ;;\n          no) enable_elasticsearch_tests=\"no\" ;;\n         minimal) enable_elasticsearch_tests=\"minimal\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-elasticsearch-tests) ;;\n         esac],\n        [enable_elasticsearch_tests=no]\n)\nAM_CONDITIONAL(ENABLE_ELASTICSEARCH_TESTS, test x$enable_elasticsearch_tests = xyes)\nAM_CONDITIONAL(ENABLE_ELASTICSEARCH_TESTS_MINIMAL, test x$enable_elasticsearch_tests = xminimal -o x$enable_elasticsearch_tests = xyes)\n\n\n# capability to enable clickhouse testbench tests. This requries that a test\n# environment is present on the local (127.0.0.1) machine.\nAC_ARG_ENABLE(clickhouse_tests,\n        [AS_HELP_STRING([--enable-clickhouse-tests],[enable Elasticsearch specific tests in testbench @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_clickhouse_tests=\"yes\" ;;\n          no) enable_clickhouse_tests=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-clickhouse-tests) ;;\n         esac],\n        [enable_clickhouse_tests=no]\n)\nAM_CONDITIONAL(ENABLE_CLICKHOUSE_TESTS, test x$enable_clickhouse_tests = xyes)\n\n\n# openssl support\nAC_ARG_ENABLE(openssl,\n        [AS_HELP_STRING([--enable-openssl],[Enable openssl support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_openssl=\"yes\" ;;\n          no) enable_openssl=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-openssl) ;;\n         esac],\n        [enable_openssl=no]\n)\nif test \"x$enable_openssl\" = \"xyes\"; then\n\tPKG_CHECK_MODULES(OPENSSL, openssl)\n\tAC_DEFINE([ENABLE_OPENSSL], [1], [Indicator that openssl is present])\n\tsave_libs=$LIBS\nfi\nAM_CONDITIONAL(ENABLE_OPENSSL, test x$enable_openssl = xyes)\n\n\n# GnuTLS support\nAC_ARG_ENABLE(gnutls,\n        [AS_HELP_STRING([--enable-gnutls],[Enable GNU TLS support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_gnutls=\"yes\" ;;\n          no) enable_gnutls=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-gnutls) ;;\n         esac],\n        [enable_gnutls=no]\n)\nif test \"x$enable_gnutls\" = \"xyes\"; then\n\tPKG_CHECK_MODULES(GNUTLS, gnutls >= 1.4.0)\n\tAC_DEFINE([ENABLE_GNUTLS], [1], [Indicator that GnuTLS is present])\n\tsave_libs=$LIBS\n\tLIBS=\"$LIBS $GNUTLS_LIBS\"\n\tAC_CHECK_FUNCS(gnutls_certificate_set_retrieve_function,,)\n\tAC_CHECK_FUNCS(gnutls_certificate_type_set_priority,,)\n\tLIBS=$save_libs\nfi\n\nAM_CONDITIONAL(ENABLE_GNUTLS, test x$enable_gnutls = xyes)\n\nAC_ARG_ENABLE(gnutls-tests,\n        [AS_HELP_STRING([--enable-gnutls-tests],[Enable gnutls tests @<:@default=yes@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_gnutls_tests=\"yes\" ;;\n          no) enable_gnutls_tests=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-gnutls-tests) ;;\n         esac],\n        [if [[ \"$enable_gnutls\" == \"yes\" ]]; then\n\t\tenable_gnutls_tests=yes\n\telse\n\t\tenable_gnutls_tests=no\n\tfi]\n)\nif  [[ \"$enable_gnutls_tests\" == \"yes\" ]] && [[ \"$enable_gnutls\" != \"yes\" ]]; then\n\t\tAC_MSG_WARN([gnutls-tests can not be enabled without gnutls support. Disabling gnutls tests...])\n\t\tenable_gnutls_tests=\"no\"\nfi\n\nAM_CONDITIONAL(ENABLE_GNUTLS_TESTS, test x$enable_gnutls_tests = xyes)\n\n\n# libgcrypt support\nAC_ARG_ENABLE(libgcrypt,\n        [AS_HELP_STRING([--enable-libgcrypt],[Enable log file encryption support (libgcrypt) @<:@default=yes@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_libgcrypt=\"yes\" ;;\n          no) enable_libgcrypt=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-libgcrypt) ;;\n         esac],\n        [enable_libgcrypt=yes]\n)\nif test \"x$enable_libgcrypt\" = \"xyes\"; then\n\tAC_PATH_PROG([LIBGCRYPT_CONFIG],[libgcrypt-config],[no])\n        if test \"x${LIBGCRYPT_CONFIG}\" = \"xno\"; then\n           AC_MSG_FAILURE([libgcrypt-config not found in PATH])\n        fi\n        AC_CHECK_LIB(\n\t\t[gcrypt],\n        \t[gcry_cipher_open],\n        \t[LIBGCRYPT_CFLAGS=\"`${LIBGCRYPT_CONFIG} --cflags`\"\n        \tLIBGCRYPT_LIBS=\"`${LIBGCRYPT_CONFIG} --libs`\"\n        \t],\n        \t[AC_MSG_FAILURE([libgcrypt is missing])],\n        \t[`${LIBGCRYPT_CONFIG} --libs --cflags`]\n        \t)\n\tAC_DEFINE([ENABLE_LIBGCRYPT], [1], [Indicator that LIBGCRYPT is present])\nfi\nAM_CONDITIONAL(ENABLE_LIBGCRYPT, test x$enable_libgcrypt = xyes)\nAC_SUBST(LIBGCRYPT_CFLAGS)\nAC_SUBST(LIBGCRYPT_LIBS)\n\n\n# support for building the rsyslogd runtime\nAC_ARG_ENABLE(rsyslogrt,\n        [AS_HELP_STRING([--enable-rsyslogrt],[Build rsyslogrt @<:@default=yes@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_rsyslogrt=\"yes\" ;;\n          no) enable_rsyslogrt=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-rsyslogrt) ;;\n         esac],\n        [enable_rsyslogrt=yes]\n)\nif test \"x$enable_rsyslogrt\" = \"xyes\"; then\n  RSRT_CFLAGS1=\"-I\\$(top_srcdir)/runtime -I\\$(top_srcdir) -I\\$(top_srcdir)/grammar\"\n  RSRT_LIBS1=\"\\$(top_builddir)/runtime/librsyslog.la\"\nfi\nAM_CONDITIONAL(ENABLE_RSYSLOGRT, test x$enable_rsyslogrt = xyes)\nRSRT_CFLAGS=\"\\$(RSRT_CFLAGS1) \\$(LIBESTR_CFLAGS) \\$(LIBFASTJSON_CFLAGS) \\$(LIBSYSTEMD_CFLAGS)\"\nif test \"$GCC\" = \"yes\"; then\n  RSRT_CFLAGS=\"$RSRT_CFLAGS -W -Wall -Wformat-security -Wshadow -Wcast-align -Wpointer-arith -Wmissing-format-attribute\"\n  if $CC -Werror=implicit-function-declaration -x c -c /dev/null -o /dev/null 2>/dev/null; then\n    RSRT_CFLAGS=\"$RSRT_CFLAGS -Werror=implicit-function-declaration\"\n  elif $CC -Werror-implicit-function-declaration -x c -c /dev/null -o /dev/null 2>/dev/null; then\n    RSRT_CFLAGS=\"$RSRT_CFLAGS -Werror-implicit-function-declaration\"\n  fi\n\n  if test \"x$enable_debug_symbols\" = \"xyes\"; then\n    RSRT_CFLAGS=\"$RSRT_CFLAGS -g\"\n  fi\nfi\nRSRT_CFLAGS=\"$RSRT_CFLAGS $WARN_CFLAGS\"\nRSRT_LIBS=\"\\$(RSRT_LIBS1) \\$(LIBESTR_LIBS) \\$(LIBFASTJSON_LIBS) \\$(LIBSYSTEMD_LIBS)\"\nAC_SUBST(RSRT_CFLAGS1)\nAC_SUBST(RSRT_LIBS1)\nAC_SUBST(RSRT_CFLAGS)\nAC_SUBST(RSRT_LIBS)\n\n\n# support for NOT building rsyslogd (useful for source-based packaging systems)\nAC_ARG_ENABLE(rsyslogd,\n        [AS_HELP_STRING([--enable-rsyslogd],[Build rsyslogd @<:@default=yes@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_rsyslogd=\"yes\" ;;\n          no) enable_rsyslogd=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-rsyslogd) ;;\n         esac],\n        [enable_rsyslogd=yes]\n)\nAM_CONDITIONAL(ENABLE_RSYSLOGD, test x$enable_rsyslogd = xyes)\n\n\n# capability to enable an extended testbench. By default, this is off. The reason\n# for this switch is that some test simply take too long to execute them on a regular\n# basis. So we enable to skip them, while the majority of tests can still be used. The\n# idea is that at least \"make distcheck\" executes the extended testbench, and also\n# developers should explicitely enable it after important changes. -- rgerhards, 2010-04-12\nAC_ARG_ENABLE(extended_tests,\n        [AS_HELP_STRING([--enable-extended-tests],[extended testbench @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_extended_tests=\"yes\" ;;\n          no) enable_extended_tests=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-extended-tests) ;;\n         esac],\n        [enable_extended_tests=no]\n)\nAM_CONDITIONAL(ENABLE_EXTENDED_TESTS, test x$enable_extended_tests = xyes)\n\n\n# capability to enable MySQL testbench tests. This requries that a Syslog database\n# with the default schema has been created on the local (127.0.0.1) MySQL server and\n# a user \"rsyslog\" with password \"testbench\" exists, is able to login with default\n# parameters and has sufficient (read: all) privileges on that database.\n# rgerhards, 2011-03-09\nAC_ARG_ENABLE(mysql_tests,\n        [AS_HELP_STRING([--enable-mysql-tests],[enable MySQL specific tests in testbench @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_mysql_tests=\"yes\" ;;\n          no) enable_mysql_tests=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-mysql-tests) ;;\n         esac],\n        [enable_mysql_tests=no]\n)\nAM_CONDITIONAL(ENABLE_MYSQL_TESTS, test x$enable_mysql_tests = xyes)\n\n\n# capability to enable PostgreSQL testbench tests. This requries that a Syslog database\n# with the default schema (see plugins/ompgsql/createDB.sql) has been created on the\n# local (127.0.0.1) PostgreSQL server and a user \"rsyslog\" with password \"testbench\"\n# exists, is able to login with default parameters and has sufficient (read: all)\n# privileges on that database\nAC_ARG_ENABLE(pgsql_tests,\n        [AS_HELP_STRING([--enable-pgsql-tests],[enable PostgreSQL specific tests in testbench @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_pgsql_tests=\"yes\" ;;\n          no) enable_pgsql_tests=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-pgsql-tests) ;;\n         esac],\n        [enable_pgsql_tests=no]\n)\nAM_CONDITIONAL(ENABLE_PGSQL_TESTS, test x$enable_pgsql_tests = xyes)\n\n\n# Mail support (so far we do not need a library, but we need to turn this on and off)\nAC_ARG_ENABLE(mail,\n        [AS_HELP_STRING([--enable-mail],[Enable mail support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_mail=\"yes\" ;;\n          no) enable_mail=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-mail) ;;\n         esac],\n        [enable_mail=no]\n)\nAM_CONDITIONAL(ENABLE_MAIL, test x$enable_mail = xyes)\n\n\nAC_ARG_ENABLE(fmhttp,\n        [AS_HELP_STRING([--enable-fmhttp],[Enable fmhttp @<:@default=yes@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_fmhttp=\"yes\" ;;\n          no) enable_fmhttp=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-fmhttp) ;;\n         esac],\n        [enable_fmhttp=yes]\n)\nif test \"$enable_fmhttp\" = \"yes\"; then\n        PKG_CHECK_MODULES([CURL], [libcurl])\nfi\nAM_CONDITIONAL(ENABLE_FMHTTP, test x$enable_fmhttp = xyes)\n\n\n# imdiag support\n# This is a core testbench tool. You need to enable it if you want to\n# use not only a small subset of the testbench.\nAC_ARG_ENABLE(imdiag,\n        [AS_HELP_STRING([--enable-imdiag],[Enable imdiag @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_imdiag=\"yes\" ;;\n          no) enable_imdiag=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-imdiag) ;;\n         esac],\n        [enable_imdiag=no]\n)\nif test \"x$enable_imdiag\" = \"xyes\"; then\n\tAC_DEFINE([ENABLE_IMDIAG], [1], [Indicator that IMDIAG is present])\nfi\nAM_CONDITIONAL(ENABLE_IMDIAG, test x$enable_imdiag = xyes)\n\n\n# mmnormalize\nAC_ARG_ENABLE(mmnormalize,\n        [AS_HELP_STRING([--enable-mmnormalize],[Enable building mmnormalize support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_mmnormalize=\"yes\" ;;\n          no) enable_mmnormalize=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-mmnormalize) ;;\n         esac],\n        [enable_mmnormalize=no]\n)\nif test \"x$enable_mmnormalize\" = \"xyes\"; then\n\tPKG_CHECK_MODULES(LIBLOGNORM, lognorm >= 2.0.3)\n\n\tsave_CFLAGS=\"$CFLAGS\"\n\tsave_LIBS=\"$LIBS\"\n\n\tCFLAGS=\"$CFLAGS $LIBLOGNORM_CFLAGS\"\n\tLIBS=\"$LIBS $LIBLOGNORM_LIBS\"\n\n\tAX_CHECK_DEFINED([[#include <lognorm-features.h>]],LOGNORM_REGEX_SUPPORTED,[lognorm_regex_supported=\"yes\"],)\n\n\tCFLAGS=\"$save_CFLAGS\"\n\tLIBS=\"$save_LIBS\"\nfi\nAM_CONDITIONAL(LOGNORM_REGEX_SUPPORTED, test x$lognorm_regex_supported = xyes)\nAM_CONDITIONAL(ENABLE_MMNORMALIZE, test x$enable_mmnormalize = xyes)\n\n# mmnjsonparse\nAC_ARG_ENABLE(mmjsonparse,\n        [AS_HELP_STRING([--enable-mmjsonparse],[Enable building mmjsonparse support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_mmjsonparse=\"yes\" ;;\n          no) enable_mmjsonparse=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-mmjsonparse) ;;\n         esac],\n        [enable_mmjsonparse=no]\n)\nAM_CONDITIONAL(ENABLE_MMJSONPARSE, test x$enable_mmjsonparse = xyes)\n\n# mmgrok\nAC_ARG_ENABLE(mmgrok,\n        [AS_HELP_STRING([--enable-mmgrok],[Enable building mmgrok support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_mmgrok=\"yes\" ;;\n          no) enable_mmgrok=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-mmgrok) ;;\n        esac],\n        [enable_mmgrok=no]\n)\nif test \"x$enable_mmgrok\" = \"xyes\"; then\n        AC_CHECK_HEADERS([grok.h])\n\tGLIB_CFLAGS=\"$(pkg-config --cflags glib-2.0)\"\n\tGLIB_LIBS=\"$(pkg-config --libs glib-2.0)\"\nfi\nAM_CONDITIONAL(ENABLE_MMGROK, test x$enable_mmgrok = xyes)\nAC_SUBST(GLIB_CFLAGS)\nAC_SUBST(GLIB_LIBS)\n\n# mmaudit\nAC_ARG_ENABLE(mmaudit,\n        [AS_HELP_STRING([--enable-mmaudit],[Enable building mmaudit support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_mmaudit=\"yes\" ;;\n          no) enable_mmaudit=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-mmaudit) ;;\n         esac],\n        [enable_mmaudit=no]\n)\nAM_CONDITIONAL(ENABLE_MMAUDIT, test x$enable_mmaudit = xyes)\n\n\n# mmanon\nAC_ARG_ENABLE(mmanon,\n        [AS_HELP_STRING([--enable-mmanon],[Enable building mmanon support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_mmanon=\"yes\" ;;\n          no) enable_mmanon=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-mmanon) ;;\n         esac],\n        [enable_mmanon=no]\n)\nAM_CONDITIONAL(ENABLE_MMANON, test x$enable_mmanon = xyes)\n\n\n# mmrm1stspace\nAC_ARG_ENABLE(mmrm1stspace,\n        [AS_HELP_STRING([--enable-mmrm1stspace],[Enable building mmrm1stspace support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_mmrm1stspace=\"yes\" ;;\n          no) enable_mmrm1stspace=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-mmrm1stspace) ;;\n         esac],\n        [enable_mmrm1stspace=no]\n)\nAM_CONDITIONAL(ENABLE_MMRM1STSPACE, test x$enable_mmrm1stspace = xyes)\n\n\n# mmutf8fix\nAC_ARG_ENABLE(mmutf8fix,\n        [AS_HELP_STRING([--enable-mmutf8fix],[Enable building mmutf8fix support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_mmutf8fix=\"yes\" ;;\n          no) enable_mmutf8fix=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-mmutf8fix) ;;\n         esac],\n        [enable_mmutf8fix=no]\n)\nAM_CONDITIONAL(ENABLE_MMUTF8FIX, test x$enable_mmutf8fix = xyes)\n\n\n# mmcount\nAC_ARG_ENABLE(mmcount,\n        [AS_HELP_STRING([--enable-mmcount],[Enable message counting @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_mmcount=\"yes\" ;;\n          no) enable_mmcount=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-mmcount) ;;\n         esac],\n        [enable_mmcount=no]\n)\nAM_CONDITIONAL(ENABLE_MMCOUNT, test x$enable_mmcount = xyes)\n\n\n# mmsequence\nAC_ARG_ENABLE(mmsequence,\n        [AS_HELP_STRING([--enable-mmsequence],[Enable sequence generator @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_mmsequence=\"yes\" ;;\n          no) enable_mmsequence=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-mmsequence) ;;\n         esac],\n        [enable_mmsequence=no]\n)\nAM_CONDITIONAL(ENABLE_MMSEQUENCE, test x$enable_mmsequence = xyes)\n\n\n\n# mmdblookup\nAC_ARG_ENABLE(mmdblookup,\n        [AS_HELP_STRING([--enable-mmdblookup],[Enable mmdb lookup helper @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_mmdblookup=\"yes\" ;;\n          no) enable_mmdblookup=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-mmdblookup) ;;\n         esac],\n        [enable_mmdblookup=no]\n)\nif test \"x$enable_mmdblookup\"; then\n        #PKG_CHECK_MODULES(LIBMAXMINDDB, libmaxminddb)\n        AC_CHECK_HEADERS([maxminddb.h])\nfi\nAM_CONDITIONAL(ENABLE_MMDBLOOKUP, test x$enable_mmdblookup = xyes)\n\n\n\n# mmdarwin\nAC_ARG_ENABLE(mmdarwin,\n        [AS_HELP_STRING([--enable-mmdarwin],[Enable mmdb lookup helper @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_mmdarwin=\"yes\" ;;\n          no) enable_mmdarwin=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-mmdarwin) ;;\n         esac],\n        [enable_mmdarwin=no]\n)\nif test \"x$enable_mmdarwin\"; then\n        AC_CHECK_HEADERS([protocol.h])\nfi\nAM_CONDITIONAL(ENABLE_MMDARWIN, test x$enable_mmdarwin = xyes)\n\n\n\n\n# mmfields\nAC_ARG_ENABLE(mmfields,\n        [AS_HELP_STRING([--enable-mmfields],[Enable building mmfields support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_mmfields=\"yes\" ;;\n          no) enable_mmfields=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-mmfields) ;;\n         esac],\n        [enable_mmfields=no]\n)\nAM_CONDITIONAL(ENABLE_MMFIELDS, test x$enable_mmfields = xyes)\n\n# mmpstrucdata\nAC_ARG_ENABLE(mmpstrucdata,\n        [AS_HELP_STRING([--enable-mmpstrucdata],[Enable building mmpstrucdata support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_mmpstrucdata=\"yes\" ;;\n          no) enable_mmpstrucdata=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-mmpstrucdata) ;;\n         esac],\n        [enable_mmpstrucdata=no]\n)\nAM_CONDITIONAL(ENABLE_MMPSTRUCDATA, test x$enable_mmpstrucdata = xyes)\n\n\n# mmrfc5424addhmac\nAC_ARG_ENABLE(mmrfc5424addhmac,\n        [AS_HELP_STRING([--enable-mmrfc5424addhmac],[Enable building mmrfc5424addhmac support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_mmrfc5424addhmac=\"yes\" ;;\n          no) enable_mmrfc5424addhmac=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-mmrfc5424addhmac) ;;\n         esac],\n        [enable_mmrfc5424addhmac=no]\n)\nif test \"x$enable_mmrfc5424addhmac\" = \"xyes\"; then\n\tPKG_CHECK_MODULES(OPENSSL, openssl >= 0.9.7)\n#AC_CHECK_LIB([crypto],[CRYPTO_new_ex_data], [], [AC_MSG_ERROR([OpenSSL libraries required])])\n#AC_CHECK_LIB([ssl],[SSL_library_init], [], [AC_MSG_ERROR([OpenSSL libraries required])])\n#AC_CHECK_HEADERS([openssl/crypto.h openssl/x509.h openssl/pem.h openssl/ssl.h openssl/err.h],[],[AC_MSG_ERROR([OpenSSL headers required])])\nfi\nAM_CONDITIONAL(ENABLE_MMRFC5424ADDHMAC, test x$enable_mmrfc5424addhmac = xyes)\n\n\n# experimental omfile-hardened module\nAC_ARG_ENABLE(omfile-hardened,\n        [AS_HELP_STRING([--enable-omfile-hardened],[Enable omfile-hardened support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_omfile_hardened=\"yes\" ;;\n          no) enable_omfile_hardened=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-omfile-hardened) ;;\n         esac],\n        [enable_omfile_hardened=no]\n)\nAM_CONDITIONAL(ENABLE_OMFILE_HARDENED, test x$enable_omfile_hardened = xyes)\n\n\n# RELP support\nAC_ARG_ENABLE(relp,\n        [AS_HELP_STRING([--enable-relp],[Enable RELP support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_relp=\"yes\" ;;\n          no) enable_relp=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-relp) ;;\n         esac],\n        [enable_relp=no]\n)\nif test \"x$enable_relp\" = \"xyes\"; then\n\tPKG_CHECK_MODULES(RELP, relp >= 1.2.14)\n\tAC_DEFINE([ENABLE_RELP], [1], [Indicator that RELP is present])\n        save_CFLAGS=\"$CFLAGS\"\n        save_LIBS=\"$LIBS\"\n\n        CFLAGS=\"$CFLAGS $RELP_CFLAGS\"\n        LIBS=\"$LIBS $RELP_LIBS\"\n\n        AC_CHECK_FUNC([relpSrvSetOversizeMode],\n                      [AC_DEFINE([HAVE_RELPSRVSETOVERSIZEMODE], [1], [Define if relpSrvSetOversizeMode exists.])])\n        AC_CHECK_FUNC([relpSrvSetLstnAddr],\n                      [AC_DEFINE([HAVE_RELPSRVSETLSTNADDR], [1], [Define if relpSrvSetLstnAddr exists.])])\n        AC_CHECK_FUNC([relpEngineSetTLSLibByName],\n                      [AC_DEFINE([HAVE_RELPENGINESETTLSLIBBYNAME], [1], [Define if relpEngineSetTLSLibByName exists.])])\n        AC_CHECK_FUNC([relpSrvSetTlsConfigCmd],\n                      [AC_DEFINE([HAVE_RELPENGINESETTLSCFGCMD], [1], [Define if relpSrvSetTlsConfigCmd exists.])])\n\n        AC_CHECK_FUNC([relpSrvSetTlsConfigCmd],\n                      [HAVE_RELPENGINESETTLSCFGCMD=1])\n\n        CFLAGS=\"$save_CFLAGS\"\n        LIBS=\"$save_LIBS\"\nfi\nAM_CONDITIONAL(ENABLE_RELP, test x$enable_relp = xyes)\nAM_CONDITIONAL([USE_RELPENGINESETTLSCFGCMD], [test \"x$HAVE_RELPENGINESETTLSCFGCMD\" = x1])\n\n# RELP default port\nAC_ARG_ENABLE(omrelp-default-port,\n        [AS_HELP_STRING([--enable-omrelp-default-port],[set omrelp default port @<:@default=514@:>@])],\n\t[ AC_DEFINE_UNQUOTED(RELP_DFLT_PT, \"${enableval}\", [default port for omrelp]) ],\n\t[ AC_DEFINE(RELP_DFLT_PT, \"514\", [default port for omrelp]) ]\n)\n\n\n\n# GuardTime KSI LOGSIG 12 support\nAC_ARG_ENABLE(ksi-ls12,\n        [AS_HELP_STRING([--enable-ksi-ls12],[Enable log file signing support via GuardTime KSI LS12 @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_ksi_ls12=\"yes\" ;;\n          no) enable_ksi_ls12=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-ksi-ls12) ;;\n         esac],\n        [enable_ksi_ls12=no]\n)\nif test \"x$enable_ksi_ls12\" = \"xyes\"; then\n\tPKG_CHECK_MODULES(GT_KSI_LS12, libksi >= 3.19.0)\nfi\nAM_CONDITIONAL(ENABLE_KSI_LS12, test x$enable_ksi_ls12 = xyes)\n\n# liblogging-stdlog support\n# we use liblogging-stdlog inside the testbench, which is why we need to check for it in any case\nPKG_CHECK_MODULES(LIBLOGGING_STDLOG, liblogging-stdlog >= 1.0.3,\n        [AC_DEFINE(HAVE_LIBLOGGING_STDLOG, 1, [Define to 1 if liblogging-stdlog is available.])\n        found_liblogging_stdlog=\"yes\"],\n        [AC_MSG_NOTICE([liblogging-stdlog not found, parts of the testbench will not run])]\n)\n\nAC_ARG_ENABLE(liblogging-stdlog,\n        [AS_HELP_STRING([--enable-liblogging-stdlog],[Enable liblogging-stdlog support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_liblogging_stdlog=\"yes\" ;;\n          no) enable_liblogging_stdlog=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-liblogging-stdlog) ;;\n         esac],\n        [enable_liblogging_stdlog=no]\n)\nif test \"x$enable_liblogging_stdlog\" = \"xyes\" -a \"x$found_liblogging_stdlog\" != \"xyes\"; then\n\tAC_MSG_ERROR(--enable-liblogging-stdlog set but liblogging-stdlog was not found)\nfi\nAM_CONDITIONAL(ENABLE_LIBLOGGING_STDLOG, [test \"x$enable_liblogging_stdlog\" = \"xyes\"])\n\n# RFC 3195 support\nAC_ARG_ENABLE(rfc3195,\n        [AS_HELP_STRING([--enable-rfc3195],[Enable RFC3195 support @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_rfc3195=\"yes\" ;;\n          no) enable_rfc3195=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-rfc3195) ;;\n         esac],\n        [enable_rfc3195=no]\n)\nif test \"x$enable_rfc3195\" = \"xyes\"; then\n\tPKG_CHECK_MODULES(LIBLOGGING, liblogging-rfc3195 >= 1.0.1)\nfi\nAM_CONDITIONAL(ENABLE_RFC3195, test x$enable_rfc3195 = xyes)\n\n\n# enable/disable the testbench (e.g. because some important parts\n# are missing)\nAC_ARG_ENABLE(testbench,\n        [AS_HELP_STRING([--enable-testbench],[testbench enabled @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_testbench=\"yes\" ;;\n          no) enable_testbench=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-testbench) ;;\n         esac],\n        [enable_testbench=no]\n)\n\n# Add a capability to turn off libfaketime tests. Unfortunately, libfaketime\n# becomes more and more problematic in newer versions and causes aborts\n# on some platforms. This provides the ability to turn it off. In the\n# longer term, we should consider writing our own replacement.\nAC_ARG_ENABLE(libfaketime,\n        [AS_HELP_STRING([--enable-libfaketime],[libfaketime enabled @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_libfaketime=\"yes\" ;;\n          no) enable_libfaketime=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-libfaketime) ;;\n         esac],\n        [enable_libfaketime=no]\n)\nAM_CONDITIONAL(ENABLE_LIBFAKETIME, test \"x${enable_libfaketime}\" = \"xyes\")\n\n# this permits to control the \"default tests\" in testbench runs. These\n# are those tests that do not need a special configure option. There are\n# some situations where we really want to turn them of so that we can\n# run tests only for a specific component (e.g. ElasticSearch).\n# This also enables us to do some parallel testing even while the\n# testbench is not yet able to support make -j check\nAC_ARG_ENABLE(default-tests,\n        [AS_HELP_STRING([--enable-default-tests],[default-tests enabled @<:@default=yes@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_default_tests=\"yes\" ;;\n          no) enable_default_tests=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-default-tests) ;;\n         esac],\n        [enable_default_tests=yes]\n)\nAM_CONDITIONAL(ENABLE_DEFAULT_TESTS, test \"x${enable_default_tests}\" = \"xyes\")\n\nAC_CHECK_PROG(IP, [ip], [yes], [no])\nif test \"x${IP}\" = \"xno\"; then\n\tAC_MSG_NOTICE([Will not check network namespace functionality as 'ip' (part of iproute2) is not available.])\nfi\nAM_CONDITIONAL(ENABLE_IP, test \"x${IP}\" = \"xyes\")\n\n\n# valgrind-testbench\nAC_ARG_WITH([valgrind_testbench],\n        [AS_HELP_STRING([--without-valgrind-testbench], [Don't use valgrind in testbench])]\n)\n\nif test \"x$with_valgrind_testbench\" != \"xno\"; then\n        AC_CHECK_PROG(VALGRIND, [valgrind], [valgrind], [no])\n\n        if test \"x$enable_testbench\" = \"xyes\" && test \"x$VALGRIND\" = \"xno\"; then\n                if test \"x$with_valgrind_testbench\" = \"xyes\"; then\n                        AC_MSG_ERROR([valgrind is missing but forced with --with-valgrind-testbench. Either install valgrind or remove the option!])\n                else\n                        AC_MSG_WARN([valgrind is missing -- testbench won't use valgrind!])\n                fi\n        else\n                AC_MSG_NOTICE([testbench will use valgrind])\n        fi\nelse\n\tAC_MSG_NOTICE([testbench won't use valgrind due to set --without-valgrind-testbench option])\nfi\nAM_CONDITIONAL([HAVE_VALGRIND], [test \"x$with_valgrind_testbench\" != \"xno\" && test \"x$VALGRIND\" != \"xno\"])\n\n# ability to disable helgrind tests - we at least need this for\n# clang coverage reports, where we cannot suppress the races\nAC_ARG_ENABLE(helgrind,\n        [AS_HELP_STRING([--enable-helgrind],[valgrind helgrind enabled @<:@default=yes@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_helgrind=\"yes\" ;;\n          no) enable_helgrind=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-helgrind) ;;\n         esac],\n        [enable_helgrind=yes]\n)\nAM_CONDITIONAL(ENABLE_HELGRIND, test x$enable_helgrind = xyes)\n\n# settings for the batch report input module\nAC_ARG_ENABLE(imbatchreport,\n        [AS_HELP_STRING([--enable-imbatchreport],[batch report input module enabled @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_imbatchreport=\"yes\" ;;\n          no) enable_imbatchreport=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-imbatchreport) ;;\n         esac],\n        [enable_imbatchreport=no]\n)\nAM_CONDITIONAL(ENABLE_IMBATCHREPORT, test x$enable_imbatchreport = xyes)\n\n# settings for the db2diag parser module\nAC_ARG_ENABLE(pmdb2diag,\n        [AS_HELP_STRING([--enable-pmdb2diag],[db2diag parser module enabled @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_pmdb2diag=\"yes\" ;;\n          no) enable_pmdb2diag=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-pmdb2diag) ;;\n         esac],\n        [enable_pmdb2diag=no]\n)\nAM_CONDITIONAL(ENABLE_PMDB2DIAG, test x$enable_pmdb2diag = xyes)\n\n# settings for the file input module\nAC_ARG_ENABLE(imfile,\n        [AS_HELP_STRING([--enable-imfile],[file input module enabled @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_imfile=\"yes\" ;;\n          no) enable_imfile=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-imfile) ;;\n         esac],\n        [enable_imfile=no]\n)\nif test \"x$enable_imfile\" = \"xyes\"; then\n\tAC_CHECK_FUNCS(port_create,,)\n\tAC_MSG_CHECKING(for Solaris File Events Notification API support)\n\tAC_TRY_COMPILE([\n\t\t#include <port.h>\n\t\t#include <sys/port.h>\n\t\t], [\n\t\treturn PORT_SOURCE_FILE;\n\t\t]\n\t\t,\n\t\tAC_DEFINE(HAVE_PORT_SOURCE_FILE, 1, [Enable FEN support for imfile])\n\t\tAC_MSG_RESULT(yes)\n\t\t,\n\t\tAC_MSG_RESULT(no)\n\t)\nfi\nAM_CONDITIONAL(ENABLE_IMFILE, test x$enable_imfile = xyes)\n\nAC_ARG_ENABLE(imfile-tests,\n        [AS_HELP_STRING([--enable-imfile-tests],[Enable imfile tests @<:@default=yes@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_imfile_tests=\"yes\" ;;\n          no) enable_imfile_tests=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-imfile-tests) ;;\n         esac],\n        [enable_imfile_tests=yes]\n)\nif  [[ \"$enable_imfile_tests\" == \"yes\" ]] && [[ \"$enable_imfile\" != \"yes\" ]]; then\n\t\tAC_MSG_WARN([imfile-tests can not be enabled without imfile support. Disabling imfile tests...])\n\t\tenable_imfile_tests=\"no\"\nfi\nAM_CONDITIONAL(ENABLE_IMFILE_TESTS, test x$enable_imfile_tests = xyes)\n\n\n# settings for the docker log input module\nAC_ARG_ENABLE(imdocker,\n        [AS_HELP_STRING([--enable-imdocker],[input docker module enabled @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_imdocker=\"yes\" ;;\n          no) enable_imdocker=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-imdocker) ;;\n         esac],\n        [enable_imdocker=no]\n)\nif test \"x$enable_imdocker\" = \"xyes\"; then\n\tAC_CHECK_HEADERS([curl/curl.h])\n\tPKG_CHECK_MODULES([CURL], [libcurl >= 7.40.0])\nfi\nAM_CONDITIONAL(ENABLE_IMDOCKER, test x$enable_imdocker = xyes)\n\nAC_ARG_ENABLE(imdocker-tests,\n        [AS_HELP_STRING([--enable-imdocker-tests],[Enable imdocker tests @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_imdocker_tests=\"yes\" ;;\n          no) enable_imdocker_tests=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-imdocker-tests) ;;\n         esac],\n        [enable_imdocker_tests=no]\n)\n\nAM_CONDITIONAL(ENABLE_IMDOCKER_TESTS, test x$enable_imdocker_tests = xyes)\n\n\n# settings for the tuxedo ULOG input module\nAC_ARG_ENABLE(imtuxedoulog,\n        [AS_HELP_STRING([--enable-imtuxedoulog],[tuxedo ULOG input module enabled @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_imtuxedoulog=\"yes\" ;;\n          no) enable_imtuxedoulog=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-imtuxedoulog) ;;\n         esac],\n        [enable_imtuxedoulog=no]\n)\nAM_CONDITIONAL(ENABLE_IMTUXEDOULOG, test x$enable_imtuxedoulog = xyes)\n\n# settings for the external program input module\nAC_ARG_ENABLE(improg,\n        [AS_HELP_STRING([--enable-improg],[external program input module enabled @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_improg=\"yes\" ;;\n          no) enable_improg=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-improg) ;;\n         esac],\n        [enable_improg=no]\n)\nAM_CONDITIONAL(ENABLE_IMPROG, test x$enable_improg = xyes)\n\n# settings for the door input module (under solaris, thus default off)\nAC_ARG_ENABLE(imsolaris,\n        [AS_HELP_STRING([--enable-imsolaris],[solaris input module enabled @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_imsolaris=\"yes\" ;;\n          no) enable_imsolaris=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-imsolaris) ;;\n         esac],\n        [enable_imsolaris=no]\n)\nAM_CONDITIONAL(ENABLE_IMSOLARIS, test x$enable_imsolaris = xyes)\n\n# settings for the ptcp input module\nAC_ARG_ENABLE(imptcp,\n        [AS_HELP_STRING([--enable-imptcp],[plain tcp input module enabled @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_imptcp=\"yes\" ;;\n          no) enable_imptcp=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-imptcp) ;;\n         esac],\n        [enable_imptcp=no]\n)\nAM_CONDITIONAL(ENABLE_IMPTCP, test x$enable_imptcp = xyes)\n\n\n# settings for the pstats input module\nAC_ARG_ENABLE(impstats,\n        [AS_HELP_STRING([--enable-impstats],[periodic statistics module enabled @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_impstats=\"yes\" ;;\n          no) enable_impstats=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-impstats) ;;\n         esac],\n        [enable_impstats=no]\n)\nAM_CONDITIONAL(ENABLE_IMPSTATS, test x$enable_impstats = xyes)\n\n\n# settings for the omprog output module\nAC_ARG_ENABLE(omprog,\n        [AS_HELP_STRING([--enable-omprog],[Compiles omprog module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_omprog=\"yes\" ;;\n          no) enable_omprog=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-omprog) ;;\n         esac],\n        [enable_omprog=no]\n)\nAM_CONDITIONAL(ENABLE_OMPROG, test x$enable_omprog = xyes)\n\n\n# settings for omudpspoof\nAC_ARG_ENABLE(omudpspoof,\n        [AS_HELP_STRING([--enable-omudpspoof],[Compiles omudpspoof module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_omudpspoof=\"yes\" ;;\n          no) enable_omudpspoof=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-omudpspoof) ;;\n         esac],\n        [enable_omudpspoof=no]\n)\n\nif test \"x$enable_omudpspoof\" = \"xyes\"; then\n  AC_CHECK_HEADERS(\n    [libnet.h],,\n    [AC_MSG_FAILURE([libnet is missing])]\n  )\n  AC_CHECK_LIB(\n    [net],\n    [libnet_init],\n    [UDPSPOOF_CFLAGS=\"\"\n     UDPSPOOF_LIBS=\"-lnet\"\n    ],\n    [AC_MSG_FAILURE([libnet is missing])]\n  )\nfi\nAM_CONDITIONAL(ENABLE_OMUDPSPOOF, test x$enable_omudpspoof = xyes)\nAC_SUBST(UDPSPOOF_CFLAGS)\nAC_SUBST(UDPSPOOF_LIBS)\n\n\n# settings for omstdout\nAC_ARG_ENABLE(omstdout,\n        [AS_HELP_STRING([--enable-omstdout],[Compiles stdout module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_omstdout=\"yes\" ;;\n          no) enable_omstdout=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-omstdout) ;;\n         esac],\n        [enable_omstdout=no]\n)\nAM_CONDITIONAL(ENABLE_OMSTDOUT, test x$enable_omstdout = xyes)\n\nAM_CONDITIONAL(ENABLE_TESTBENCH, test x$enable_testbench = xyes)\nif test \"x$enable_testbench\" = \"xyes\"; then\n\tif test \"x$enable_imdiag\" != \"xyes\"; then\n\t\tAC_MSG_ERROR(\"--enable-testbench requires --enable-imdiag\")\n\tfi\n\tif test \"x$enable_omstdout\" != \"xyes\"; then\n\t\tAC_MSG_ERROR(\"--enable-testbench requires --enable-omstdout\")\n\tfi\nfi\n\n\n# settings for omjournal\nAC_ARG_ENABLE(omjournal,\n        [AS_HELP_STRING([--enable-omjournal],[Compiles omjournal @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_omjournal=\"yes\" ;;\n          no) enable_omjournal=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-omjournal) ;;\n         esac],\n        [enable_omjournal=no]\n)\nif test \"x$enable_omjournal\" = \"xyes\"; then\n\tPKG_CHECK_MODULES([LIBSYSTEMD_JOURNAL], [libsystemd >= 209] ,, [\n\t    PKG_CHECK_MODULES([LIBSYSTEMD_JOURNAL], [libsystemd-journal >= 197])\n\t])\nfi\nAM_CONDITIONAL(ENABLE_OMJOURNAL, test x$enable_omjournal = xyes)\n\n# capability to enable journal testbench tests. They have very special requirements,\n# so it does not make sense to have them run by default.\n# Also note that as of now, they have a pretty high rate of false positives due\n# to bugs in the journal.\n# see also https://github.com/rsyslog/rsyslog/issues/2931#issuecomment-416914707\nAC_ARG_ENABLE(journal_tests,\n        [AS_HELP_STRING([--enable-journal-tests],[enable systemd journal specific tests in testbench @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_journal_tests=\"yes\" ;;\n          no) enable_journal_tests=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-journal-tests) ;;\n         esac],\n        [enable_journal_tests=no]\n)\nAM_CONDITIONAL(ENABLE_JOURNAL_TESTS, test x$enable_journal_tests = xyes)\n\n\n# settings for pmlastmsg\nAC_ARG_ENABLE(pmlastmsg,\n        [AS_HELP_STRING([--enable-pmlastmsg],[Compiles lastmsg parser module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_pmlastmsg=\"yes\" ;;\n          no) enable_pmlastmsg=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-pmlastmsg) ;;\n         esac],\n        [enable_pmlastmsg=no]\n)\nAM_CONDITIONAL(ENABLE_PMLASTMSG, test x$enable_pmlastmsg = xyes)\n\n\n# settings for pmcisconames\nAC_ARG_ENABLE(pmcisconames,\n        [AS_HELP_STRING([--enable-pmcisconames],[Compiles cisconames parser module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_pmcisconames=\"yes\" ;;\n          no) enable_pmcisconames=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-pmcisconames) ;;\n         esac],\n        [enable_pmcisconames=no]\n)\nAM_CONDITIONAL(ENABLE_PMCISCONAMES, test x$enable_pmcisconames = xyes)\n\n\n# settings for pmciscoios\nAC_ARG_ENABLE(pmciscoios,\n        [AS_HELP_STRING([--enable-pmciscoios],[Compiles ciscoios parser module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_pmciscoios=\"yes\" ;;\n          no) enable_pmciscoios=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-pmciscoios) ;;\n         esac],\n        [enable_pmciscoios=no]\n)\nAM_CONDITIONAL(ENABLE_PMCISCOIOS, test x$enable_pmciscoios = xyes)\n\n\n# settings for pmnull\nAC_ARG_ENABLE(pmnull,\n        [AS_HELP_STRING([--enable-pmnull],[Compiles null parser module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_pmnull=\"yes\" ;;\n          no) enable_pmnull=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-pmnull) ;;\n         esac],\n        [enable_pmnull=no]\n)\nAM_CONDITIONAL(ENABLE_PMNULL, test x$enable_pmnull = xyes)\n\n\n# settings for pmnormalize\nAC_ARG_ENABLE(pmnormalize,\n        [AS_HELP_STRING([--enable-pmnormalize],[Compiles normalizer parser module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_pmnormalize=\"yes\" ;;\n          no) enable_pmnormalize=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-pmnormalize) ;;\n         esac],\n        [enable_pmnormalize=no]\n)\nAM_CONDITIONAL(ENABLE_PMNORMALIZE, test x$enable_pmnormalize = xyes)\n\n\n# settings for pmaixforwardedfrom\nAC_ARG_ENABLE(pmaixforwardedfrom,\n        [AS_HELP_STRING([--enable-pmaixforwardedfrom],[Compiles aixforwardedfrom parser module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_pmaixforwardedfrom=\"yes\" ;;\n          no) enable_pmaixforwardedfrom=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-pmaixforwardedfrom) ;;\n         esac],\n        [enable_pmaixforwardedfrom=no]\n)\nAM_CONDITIONAL(ENABLE_PMAIXFORWARDEDFROM, test x$enable_pmaixforwardedfrom = xyes)\n\n\n# settings for pmsnare\nAC_ARG_ENABLE(pmsnare,\n        [AS_HELP_STRING([--enable-pmsnare],[Compiles snare parser module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_pmsnare=\"yes\" ;;\n          no) enable_pmsnare=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-pmsnare) ;;\n         esac],\n        [enable_pmsnare=no]\n)\nAM_CONDITIONAL(ENABLE_PMSNARE, test x$enable_pmsnare = xyes)\n\n\n# settings for pmpanngfw\nAC_ARG_ENABLE(pmpanngfw,\n        [AS_HELP_STRING([--enable-pmpanngfw],[Compiles Palo Alto Networks parser module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_pmpanngfw=\"yes\" ;;\n          no) enable_pmpanngfw=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-pmpanngfw) ;;\n         esac],\n        [enable_pmpanngfw=no]\n)\nAM_CONDITIONAL(ENABLE_PMPANNGFW, test x$enable_pmpanngfw = xyes)\n\n\n# settings for omruleset\nAC_ARG_ENABLE(omruleset,\n        [AS_HELP_STRING([--enable-omruleset],[Compiles ruleset forwarding module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_omruleset=\"yes\" ;;\n          no) enable_omruleset=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-omruleset) ;;\n         esac],\n        [enable_omruleset=no]\n)\nAM_CONDITIONAL(ENABLE_OMRULESET, test x$enable_omruleset = xyes)\n\n\n# settings for omuxsock\nAC_ARG_ENABLE(omuxsock,\n        [AS_HELP_STRING([--enable-omuxsock],[Compiles omuxsock module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_omuxsock=\"yes\" ;;\n          no) enable_omuxsock=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-omuxsock) ;;\n         esac],\n        [enable_omuxsock=no]\n)\nAM_CONDITIONAL(ENABLE_OMUXSOCK, test x$enable_omuxsock = xyes)\n\n\n# settings for mmsnmptrapd message modification module\nAC_ARG_ENABLE(mmsnmptrapd,\n        [AS_HELP_STRING([--enable-mmsnmptrapd],[Compiles mmsnmptrapd module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_mmsnmptrapd=\"yes\" ;;\n          no) enable_mmsnmptrapd=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-mmsnmptrapd) ;;\n         esac],\n        [enable_mmsnmptrapd=no]\n)\nAM_CONDITIONAL(ENABLE_MMSNMPTRAPD, test x$enable_mmsnmptrapd = xyes)\n\n\n# settings for the omhdfs;\nAC_ARG_ENABLE(omhdfs,\n        [AS_HELP_STRING([--enable-omhdfs],[Compiles omhdfs module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_omhdfs=\"yes\" ;;\n          no) enable_omhdfs=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-omhdfs) ;;\n         esac],\n        [enable_omhdfs=no]\n)\nif test \"x$enable_omhdfs\"; then\n\tAC_CHECK_HEADERS([hdfs.h hadoop/hdfs.h])\nfi\nAM_CONDITIONAL(ENABLE_OMHDFS, test x$enable_omhdfs = xyes)\n\n# support for kafka input output\nAC_ARG_ENABLE(omkafka,\n        [AS_HELP_STRING([--enable-omkafka],[Compiles kafka output module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_omkafka=\"yes\" ;;\n          no) enable_omkafka=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-omkafka) ;;\n         esac],\n        [enable_omkafka=no]\n)\nAC_ARG_ENABLE(imkafka,\n        [AS_HELP_STRING([--enable-imkafka],[Compiles kafka input and output module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_imkafka=\"yes\" ;;\n          no) enable_imkafka=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-imkafka) ;;\n         esac],\n        [enable_imkafka=no]\n)\n\nAC_ARG_ENABLE(kafka_tests,\n        [AS_HELP_STRING([--enable-kafka-tests],[Enable Kafka tests, needs Java @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_kafka_tests=\"yes\" ;;\n          no) enable_kafka_tests=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-kafka-tests) ;;\n         esac],\n        [enable_kafka_tests=no]\n)\nAM_CONDITIONAL(ENABLE_KAFKA_TESTS, test x$enable_kafka_tests = xyes)\n\nAC_ARG_ENABLE(kafka_static,\n        [AS_HELP_STRING([--enable-kafka-static],[Enable static library linking for Kafka modules. Removes dependency for rdkafka.so. @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_kafka_static=\"yes\" ;;\n          no) enable_kafka_static=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-kafka-static) ;;\n         esac],\n        [enable_kafka_static=no]\n)\nAM_CONDITIONAL(ENABLE_KAFKA_STATIC, test x$enable_kafka_static = xyes)\n\n# omkafka works with older library\nif test \"x$enable_omkafka\" = \"xyes\"; then\n\tPKG_CHECK_MODULES([LIBRDKAFKA], [rdkafka],, [\n\t\tPKG_CHECK_MODULES([LIBRDKAFKA], [librdkafka],, [\n\t\t\tAC_CHECK_LIB([rdkafka], [rd_kafka_produce], [\n\t\t\t\tAC_MSG_WARN([librdkafka is missing but library present, using -lrdkafka])\n\t\t\t\tLIBRDKAFKA_LIBS=-lrdkafka\n\t\t\t], [\n\t\t\t\tAC_MSG_ERROR([could not find rdkafka library])\n\t\t\t])\n\t\t])\n\t])\n\tAC_CHECK_HEADERS([librdkafka/rdkafka.h])\n\n\t# Add additional dependencies if statically linking rdkafka\n\tif test \"x$enable_kafka_static\" = \"xyes\"; then\n\t\tPKG_CHECK_MODULES([LIBLZ4], [liblz4],, [\n\t\t\tAC_CHECK_LIB([lz4], [LZ4_compress], [\n\t\t\t\tAC_MSG_WARN([liblz4 is missing but library present, using -llz4])\n\t\t\t\tLIBRDKAFKA_LIBS=-llz4\n\t\t\t], [\n\t\t\t\tAC_MSG_ERROR([could not find liblz4 library])\n\t\t\t])\n\t\t])\n\tfi\nfi\n\n# imkafka needs newer library\nif test \"x$enable_imkafka\" = \"xyes\"; then\n\tPKG_CHECK_MODULES([LIBRDKAFKA], [rdkafka >= 0.9.1],, [\n\t\tAC_CHECK_LIB([rdkafka], [rd_kafka_produce], [\n\t\t\tAC_MSG_WARN([librdkafka is missing but library present, using -lrdkafka])\n\t\t\tLIBRDKAFKA_LIBS=-lrdkafka\n\t\t], [\n\t\t\tAC_MSG_ERROR([could not find rdkafka library])\n\t\t])\n\t])\n\tAC_CHECK_HEADERS([librdkafka/rdkafka.h])\n\n\t# Add additional dependencies if statically linking rdkafka\n\tif test \"x$enable_kafka_static\" = \"xyes\"; then\n\t\tPKG_CHECK_MODULES([LIBLZ4], [liblz4],, [\n\t\t\tAC_CHECK_LIB([lz4], [LZ4_compress], [\n\t\t\t\tAC_MSG_WARN([liblz4 is missing but library present, using -llz4])\n\t\t\t\tLIBRDKAFKA_LIBS=-llz4\n\t\t\t], [\n\t\t\t\tAC_MSG_ERROR([could not find liblz4 library])\n\t\t\t])\n\t\t])\n\tfi\nfi\n\nif test \"x$enable_omkafka\" = \"xyes\" && test \"x$enable_imkafka\" = \"xyes\"; then\n\tif test \"x$enable_kafka_tests\" = \"xyes\"; then\n\t\tAX_PROG_JAVAC #we don't need javac, but macro documentation says JAVAC *must* be checked before JAVA\n\t\tAX_PROG_JAVA\n\t\tAC_CHECK_PROG(WGET, [wget], [yes], [no])\n\t\tif test \"x${WGET}\" = \"xno\"; then\n\t\t\tAC_MSG_FAILURE([wget, which is a kafka-tests dependency, not found])\n\t\tfi\n\t\tAC_CHECK_PROG(READLINK, [readlink], [yes], [no])\n\t\tif test \"x${READLINK}\" = \"xno\"; then\n\t\t\tAC_MSG_FAILURE([readlink, which is a kafka-tests dependency, not found])\n\t\tfi\n\tfi\nelse\n\tif test \"x$enable_kafka_tests\" = \"xyes\"; then\n\t\tAC_MSG_WARN([kafka-tests can not be enabled without omkafka and imkafka support. Disabling enable_kafka_tests...])\n\t\tenable_kafka_tests=\"no\"\n\tfi\nfi\nAM_CONDITIONAL(ENABLE_OMKAFKA, test x$enable_omkafka = xyes)\nAM_CONDITIONAL(ENABLE_IMKAFKA, test x$enable_imkafka = xyes)\n\n#MONGODB SUPPORT\n\nAC_ARG_ENABLE(ommongodb,\n        [AS_HELP_STRING([--enable-ommongodb],[Compiles ommongodb module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_ommongodb=\"yes\" ;;\n          no) enable_ommongodb=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-ommongodb) ;;\n         esac],\n        [enable_ommongodb=no]\n)\nif test \"x$enable_ommongodb\" = \"xyes\"; then\n\tPKG_CHECK_MODULES(LIBMONGOC, libmongoc-1.0)\n    AC_CHECK_FUNCS(mongoc_client_set_ssl_opts,,)\n\nfi\nAM_CONDITIONAL(ENABLE_OMMONGODB, test x$enable_ommongodb = xyes)\n# end of mongodb code\n\n\n# BEGIN CZMQ INPUT SUPPORT\nAC_ARG_ENABLE(imczmq,\n        [AS_HELP_STRING([--enable-imczmq],[Compiles imczmq output module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_imczmq=\"yes\" ;;\n          no) enable_imczmq=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-imczmq) ;;\n         esac],\n        [enable_imczmq=no]\n)\nif test \"x$enable_imczmq\" = \"xyes\"; then\n\tPKG_CHECK_MODULES(CZMQ, libczmq >= 3.0.0)\nfi\nAM_CONDITIONAL(ENABLE_IMCZMQ, test x$enable_imczmq = xyes)\n\n# END CZMQ INPUT\n\n\n# BEGIN CZMQ OUTPUT SUPPORT\nAC_ARG_ENABLE(omczmq,\n        [AS_HELP_STRING([--enable-omczmq],[Compiles omczmq output module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_omczmq=\"yes\" ;;\n          no) enable_omczmq=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-omczmq) ;;\n         esac],\n        [enable_omczmq=no]\n)\nif test \"x$enable_omczmq\" = \"xyes\"; then\n   PKG_CHECK_MODULES(CZMQ, libczmq >= 3.0.2)\nfi\nAM_CONDITIONAL(ENABLE_OMCZMQ, test x$enable_omczmq = xyes)\n\n# END CZMQ SUPPORT\n\n\n# BEGIN RABBITMQ OUTPUT SUPPORT\n\nAC_ARG_ENABLE(omrabbitmq,\n        [AS_HELP_STRING([--enable-omrabbitmq],[Compiles omrabbitmq output module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_omrabbitmq=\"yes\" ;;\n          no) enable_omrabbitmq=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-omrabbitmq) ;;\n         esac],\n        [enable_omrabbitmq=no]\n)\nif test \"x$enable_omrabbitmq\" = \"xyes\"; then\n        PKG_CHECK_MODULES(RABBITMQ, librabbitmq >= 0.2.0)\n        AC_SUBST(RABBITMQ_CFLAGS)\n        AC_SUBST(RABBITMQ_LIBS)\nfi\nAM_CONDITIONAL(ENABLE_OMRABBITMQ, test x$enable_omrabbitmq = xyes)\n\n# END RABBITMQ SUPPORT\n\n# HIREDIS SUPPORT\n\nAC_ARG_ENABLE(omhiredis,\n        [AS_HELP_STRING([--enable-omhiredis],[Compiles omhiredis template module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_omhiredis=\"yes\" ;;\n          no) enable_omhiredis=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-omhiredis) ;;\n         esac],\n        [enable_omhiredis=no]\n)\n#\nif test \"x$enable_omhiredis\" = \"xyes\"; then\n    PKG_CHECK_MODULES(HIREDIS, hiredis >= 0.10.1, [],\n        [AC_SEARCH_LIBS(redisConnectWithTimeout, hiredis,\n            [AC_COMPILE_IFELSE(\n                [AC_LANG_PROGRAM(\n                    [[ #include <hiredis/hiredis.h> ]],\n                    [[ #define major 0\n                       #define minor 10\n                       #define patch 1\n                       #if (( HIREDIS_MAJOR > major ) || \\\n                         (( HIREDIS_MAJOR == major ) && ( HIREDIS_MINOR > minor )) || \\\n                         (( HIREDIS_MAJOR == major ) && ( HIREDIS_MINOR == minor ) && ( HIREDIS_PATCH >= patch ))) \\\n                       /* OK */\n                       #else\n                       # error Hiredis version must be >= major.minor.path\n                       #endif\n                    ]]\n                )],\n                [],\n                [AC_MSG_ERROR([hiredis version must be >= 0.10.1])]\n            )],\n            [AC_MSG_ERROR([hiredis not found])]\n        )]\n    )\nfi\nAM_CONDITIONAL(ENABLE_OMHIREDIS, test x$enable_omhiredis = xyes)\n\n# END HIREDIS SUPPORT\n\n\n# HTTPFS SUPPORT\n\nAC_ARG_ENABLE(omhttpfs,\n        [AS_HELP_STRING([--enable-omhttpfs],[Compiles omhttpfs template module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_omhttpfs=\"yes\" ;;\n          no) enable_omhttpfs=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-omhttpfs) ;;\n         esac],\n        [enable_omhttpfs=no]\n)\n\nif test \"x$enable_omhttpfs\" = \"xyes\"; then\n\tAC_CHECK_HEADERS([curl/curl.h])\n\tPKG_CHECK_MODULES([CURL], [libcurl])\n\tLT_LIB_M\n\t#PKG_CHECK_MODULES(HTTPFS, curl >= 7.0.0)\nfi\nAM_CONDITIONAL(ENABLE_OMHTTPFS, test x$enable_omhttpfs = xyes)\n\n# END HTTPFS SUPPORT\n\n# AMQP 1.0 PROTOCOL SUPPORT\n# uses the Proton protocol library\n\nAC_ARG_ENABLE(omamqp1,\n        [AS_HELP_STRING([--enable-omamqp1],[Compiles omamqp1 output module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_omamqp1=\"yes\" ;;\n          no) enable_omamqp1=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-omamqp1) ;;\n         esac],\n        [enable_omamqp1=no]\n)\nif test \"x$enable_omamqp1\" = \"xyes\"; then\n        PKG_CHECK_MODULES(PROTON, libqpid-proton >= 0.9)\n        AC_SUBST(PROTON_CFLAGS)\n        AC_SUBST(PROTON_LIBS)\nfi\nAM_CONDITIONAL(ENABLE_OMAMQP1, test x$enable_omamqp1 = xyes)\n\n# END AMQP 1.0 PROTOCOL SUPPORT\n\n# TCL SUPPORT\n\nAC_ARG_ENABLE(omtcl,\n        [AS_HELP_STRING([--enable-omtcl],[Compiles omtcl output module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_omtcl=\"yes\" ;;\n          no) enable_omtcl=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-omtcl) ;;\n         esac],\n        [enable_omtcl=no]\n)\n\nif test \"x$enable_omtcl\" = \"xyes\"; then\n\tSC_PATH_TCLCONFIG\n\tSC_LOAD_TCLCONFIG\n\tAC_SUBST(TCL_INCLUDE_SPEC)\nfi\nAM_CONDITIONAL(ENABLE_OMTCL, test x$enable_omtcl = xyes)\n\n# END TCL SUPPORT\n\n# mmkubernetes - Kubernetes metadata support\n\nAC_ARG_ENABLE(mmkubernetes,\n        [AS_HELP_STRING([--enable-mmkubernetes],\n            [Enable compilation of the mmkubernetes module @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_mmkubernetes=\"yes\" ;;\n          no) enable_mmkubernetes=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-mmkubernetes) ;;\n         esac],\n        [enable_mmkubernetes=no]\n)\nif test \"x$enable_mmkubernetes\" = \"xyes\"; then\n        PKG_CHECK_MODULES([CURL], [libcurl])\n        PKG_CHECK_MODULES(LIBLOGNORM, lognorm >= 2.0.3)\n\n        save_CFLAGS=\"$CFLAGS\"\n        save_LIBS=\"$LIBS\"\n\n        CFLAGS=\"$CFLAGS $LIBLOGNORM_CFLAGS\"\n        LIBS=\"$LIBS $LIBLOGNORM_LIBS\"\n\n        AC_CHECK_FUNC([ln_loadSamplesFromString],\n                      [AC_DEFINE([HAVE_LOADSAMPLESFROMSTRING], [1], [Define if ln_loadSamplesFromString exists.])],\n                      [AC_DEFINE([NO_LOADSAMPLESFROMSTRING], [1], [Define if ln_loadSamplesFromString does not exist.])])\n\n        CFLAGS=\"$save_CFLAGS\"\n        LIBS=\"$save_LIBS\"\nfi\nAM_CONDITIONAL(ENABLE_MMKUBERNETES, test x$enable_mmkubernetes = xyes)\n\n# END Kubernetes metadata support\n\n\n# mmtaghostname\nAC_ARG_ENABLE(mmtaghostname,\n        [AS_HELP_STRING([--enable-mmtaghostname],[Enable Tag and Hostname messages' modifier @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_mmtaghostname=\"yes\" ;;\n          no) enable_mmtaghostname=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-mmtaghostname) ;;\n         esac],\n        [enable_mmtaghostname=no]\n)\nAM_CONDITIONAL(ENABLE_MMTAGHOSTNAME, test x$enable_mmtaghostname = xyes)\n#END mmtaghostname\n\n# man pages\nhave_to_generate_man_pages=\"no\"\ngit_src_have_to_generate_man_pages=\"yes\" # default to use when building from git source\nAC_ARG_ENABLE(generate-man-pages,\n        [AS_HELP_STRING([--enable-generate-man-pages],[Generate man pages from source @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) have_to_generate_man_pages=\"yes\" ;;\n          no) have_to_generate_man_pages=\"no\" ;\n              git_src_have_to_generate_man_pages=\"no\"\n\t      ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-generate-man-pages) ;;\n         esac],\n        [have_to_generate_man_pages=no]\n)\n\n\n# This provides a work-around to use \"make distcheck\" without\n# running tests (mode used pre 2018-07-02)\nAC_ARG_ENABLE(distcheck-workaround,\n        [AS_HELP_STRING([--enable-distcheck-workaround],[enable to use make distcheck without runing testbench inside it @<:@default=no@:>@])],\n        [case \"${enableval}\" in\n         yes) enable_distcheck_workaround=\"yes\" ;;\n          no) enable_distcheck_workaround=\"no\" ;;\n           *) AC_MSG_ERROR(bad value ${enableval} for --enable-distcheck_workaround) ;;\n         esac],\n        [enable_distcheck_workaround=\"no\"]\n)\nAM_CONDITIONAL(ENABLE_DISTCHECK_WORKAROUND, test x$enable_distcheck_workaround = xyes)\n\n\nif test \"x$in_git_src\" = \"xyes\"; then\n        AC_MSG_NOTICE([Running from git source])\n\n        have_to_generate_man_pages=$git_src_have_to_generate_man_pages\n\n        if test \"x$LEX\" != \"xflex\"; then\n                AC_MSG_ERROR([flex program is needed to build rsyslog, please install flex.])\n        fi\n\n        if test \"x$YACC\" = \"xyacc\"; then\n                # AC_PROG_YACC only checks for yacc replacements, not for yacc itself\n                AC_CHECK_PROG([YACC_FOUND], [yacc], [yes], [no])\n                if test \"x$YACC_FOUND\" = \"xno\"; then\n                        AC_MSG_ERROR([A yacc program is needed to build rsyslog, please install bison.])\n                fi\n        fi\nelse\n        AC_MSG_NOTICE([Not running from git source])\nfi\n\nAM_CONDITIONAL(ENABLE_GENERATE_MAN_PAGES, test x$have_to_generate_man_pages = xyes)\n\n# rst2man\nAC_CHECK_PROGS([RST2MAN], [rst2man rst2man.py], [false])\nif test \"x$have_to_generate_man_pages\" = \"xyes\" && test \"x$RST2MAN\" = \"xfalse\"; then\n        AC_MSG_ERROR([rst2man is required when building from git source or --enable-generate-man-pages option was set, please install python-docutils.])\nfi\n\n\nAC_CONFIG_FILES([Makefile \\\n\t\truntime/Makefile \\\n\t\tcompat/Makefile \\\n\t\tgrammar/Makefile \\\n\t\ttools/Makefile \\\n\t\tplugins/imudp/Makefile \\\n\t\tplugins/imtcp/Makefile \\\n\t\tplugins/im3195/Makefile \\\n\t\tplugins/imgssapi/Makefile \\\n\t\tplugins/imuxsock/Makefile \\\n\t\tplugins/imjournal/Makefile \\\n\t\tplugins/immark/Makefile \\\n\t\tplugins/imklog/Makefile \\\n\t\tplugins/omhdfs/Makefile \\\n\t\tplugins/omkafka/Makefile \\\n\t\tplugins/omprog/Makefile \\\n\t\tplugins/mmexternal/Makefile \\\n\t\tplugins/omstdout/Makefile \\\n\t\tplugins/omjournal/Makefile \\\n\t\tplugins/pmciscoios/Makefile \\\n\t\tplugins/pmnull/Makefile \\\n\t\tplugins/pmnormalize/Makefile \\\n\t\tplugins/omruleset/Makefile \\\n\t\tplugins/omuxsock/Makefile \\\n\t\tplugins/imfile/Makefile \\\n\t\tplugins/imsolaris/Makefile \\\n\t\tplugins/imptcp/Makefile \\\n\t\tplugins/impstats/Makefile \\\n\t\tplugins/imrelp/Makefile \\\n\t\tplugins/imdiag/Makefile \\\n\t\tplugins/imkafka/Makefile \\\n\t\tplugins/omtesting/Makefile \\\n\t\tplugins/omgssapi/Makefile \\\n\t\tplugins/ommysql/Makefile \\\n\t\tplugins/ompgsql/Makefile \\\n\t\tplugins/omrelp/Makefile \\\n\t\tplugins/omlibdbi/Makefile \\\n\t\tplugins/ommail/Makefile \\\n\t\tplugins/fmhttp/Makefile \\\n\t\tplugins/omsnmp/Makefile \\\n\t\tplugins/omudpspoof/Makefile \\\n\t\tplugins/ommongodb/Makefile \\\n\t\tplugins/mmnormalize/Makefile \\\n\t\tplugins/mmjsonparse/Makefile \\\n\t\tplugins/mmaudit/Makefile \\\n\t\tplugins/mmanon/Makefile \\\n\t\tplugins/mmrm1stspace/Makefile \\\n\t\tplugins/mmutf8fix/Makefile \\\n\t\tplugins/mmfields/Makefile \\\n\t\tplugins/mmpstrucdata/Makefile \\\n\t\tplugins/omelasticsearch/Makefile \\\n\t\tplugins/omclickhouse/Makefile \\\n\t\tplugins/mmsnmptrapd/Makefile \\\n\t\tplugins/pmlastmsg/Makefile \\\n\t\tplugins/mmdblookup/Makefile \\\n    contrib/mmdarwin/Makefile \\\n\t\tcontrib/omhttp/Makefile \\\n\t\tcontrib/fmhash/Makefile \\\n\t\tcontrib/pmsnare/Makefile \\\n\t\tcontrib/pmpanngfw/Makefile \\\n\t\tcontrib/pmaixforwardedfrom/Makefile \\\n\t\tcontrib/omhiredis/Makefile \\\n\t\tcontrib/omrabbitmq/Makefile \\\n\t\tcontrib/imkmsg/Makefile \\\n\t\tcontrib/mmgrok/Makefile \\\n\t\tcontrib/mmcount/Makefile \\\n\t\tcontrib/omczmq/Makefile \\\n\t\tcontrib/imczmq/Makefile \\\n\t\tcontrib/mmsequence/Makefile \\\n\t\tcontrib/mmrfc5424addhmac/Makefile \\\n\t\tcontrib/pmcisconames/Makefile \\\n\t\tcontrib/omhttpfs/Makefile \\\n\t\tcontrib/omamqp1/Makefile \\\n\t\tcontrib/omtcl/Makefile \\\n\t\tcontrib/imbatchreport/Makefile \\\n\t\tcontrib/omfile-hardened/Makefile \\\n\t\tcontrib/mmkubernetes/Makefile \\\n\t\tcontrib/imtuxedoulog/Makefile \\\n\t\tcontrib/improg/Makefile \\\n\t\tcontrib/mmtaghostname/Makefile \\\n\t\tcontrib/imdocker/Makefile \\\n\t\tcontrib/pmdb2diag/Makefile \\\n\t\ttests/set-envvars \\\n\t\ttests/Makefile])\nAC_OUTPUT\n\necho \"****************************************************\"\necho \"rsyslog will be compiled with the following settings:\"\necho\necho \"    Large file support enabled:               $enable_largefile\"\necho \"    Networking support enabled:               $enable_inet\"\necho \"    Regular expressions support enabled:      $enable_regexp\"\necho \"    rsyslog runtime will be built:            $enable_rsyslogrt\"\necho \"    rsyslogd will be built:                   $enable_rsyslogd\"\necho \"    have to generate man pages:               $have_to_generate_man_pages\"\necho \"    Unlimited select() support enabled:       $enable_unlimited_select\"\necho \"    uuid support enabled:                     $enable_uuid\"\necho \"    Log file signing support via KSI LS12:    $enable_ksi_ls12\"\necho \"    Log file encryption support:              $enable_libgcrypt\"\necho \"    anonymization support enabled:            $enable_mmanon\"\necho \"    message counting support enabled:         $enable_mmcount\"\necho \"    liblogging-stdlog support enabled:        $enable_liblogging_stdlog\"\necho \"    libsystemd enabled:                       $enable_libsystemd\"\necho \"    kafka static linking enabled:             $enable_kafka_static\"\necho \"    atomic operations enabled:                $enable_atomic_operations\"\necho\necho \"---{ input plugins }---\"\nif test \"$unamestr\" != \"AIX\"; then\necho \"    Klog functionality enabled:               $enable_klog ($os_type)\"\nfi\necho \"    /dev/kmsg functionality enabled:          $enable_kmsg\"\necho \"    plain tcp input module enabled:           $enable_imptcp\"\necho \"    imdiag enabled:                           $enable_imdiag\"\necho \"    file input module enabled:                $enable_imfile\"\necho \"    docker log input module enabled:          $enable_imdocker\"\necho \"    Solaris input module enabled:             $enable_imsolaris\"\necho \"    periodic statistics module enabled:       $enable_impstats\"\necho \"    imczmq input module enabled:              $enable_imczmq\"\necho \"    imjournal input module enabled:           $enable_imjournal\"\necho \"    imbatchreport input module enabled:       $enable_imbatchreport\"\necho \"    imkafka module will be compiled:          $enable_imkafka\"\necho \"    imtuxedoulog module will be compiled:     $enable_imtuxedoulog\"\necho \"    improg input module enabled:              $enable_improg\"\necho\necho \"---{ output plugins }---\"\necho \"    Mail support enabled:                     $enable_mail\"\necho \"    omfile-hardened module will be compiled:  $enable_omfile_hardened\"\necho \"    omprog module will be compiled:           $enable_omprog\"\necho \"    omstdout module will be compiled:         $enable_omstdout\"\necho \"    omjournal module will be compiled:        $enable_omjournal\"\necho \"    omhdfs module will be compiled:           $enable_omhdfs\"\necho \"    omelasticsearch module will be compiled:  $enable_elasticsearch\"\necho \"    omclickhouse module will be compiled:     $enable_clickhouse\"\necho \"    omhttp module will be compiled:           $enable_omhttp\"\necho \"    omruleset module will be compiled:        $enable_omruleset\"\necho \"    omudpspoof module will be compiled:       $enable_omudpspoof\"\necho \"    omuxsock module will be compiled:         $enable_omuxsock\"\necho \"    omczmq module will be compiled:           $enable_omczmq\"\necho \"    omrabbitmq module will be compiled:       $enable_omrabbitmq\"\necho \"    omhttpfs module will be compiled:         $enable_omhttpfs\"\necho \"    omamqp1 module will be compiled:          $enable_omamqp1\"\necho \"    omtcl module will be compiled:            $enable_omtcl\"\necho \"    omkafka module will be compiled:          $enable_omkafka\"\necho\necho \"---{ parser modules }---\"\necho \"    pmlastmsg module will be compiled:        $enable_pmlastmsg\"\necho \"    pmcisconames module will be compiled:     $enable_pmcisconames\"\necho \"    pmciscoios module will be compiled:       $enable_pmciscoios\"\necho \"    pmnull module will be compiled:           $enable_pmnull\"\necho \"    pmnormalize module will be compiled:      $enable_pmnormalize\"\necho \"    pmaixforwardedfrom module w.be compiled:  $enable_pmaixforwardedfrom\"\necho \"    pmsnare module will be compiled:          $enable_pmsnare\"\necho \"    pmdb2diag module will be compiled:        $enable_pmdb2diag\"\necho \"    pmpanngfw module will be compiled:        $enable_pmpanngfw\"\necho\necho \"---{ message modification modules }---\"\necho \"    mmnormalize module will be compiled:      $enable_mmnormalize\"\necho \"    mmjsonparse module will be compiled:      $enable_mmjsonparse\"\necho \"    mmgrok module will be compiled:           $enable_mmgrok\"\necho \"    mmjaduit module will be compiled:         $enable_mmaudit\"\necho \"    mmsnmptrapd module will be compiled:      $enable_mmsnmptrapd\"\necho \"    mmutf8fix enabled:                        $enable_mmutf8fix\"\necho \"    mmrfc5424addhmac enabled:                 $enable_mmrfc5424addhmac\"\necho \"    mmpstrucdata enabled:                     $enable_mmpstrucdata\"\necho \"    mmsequence enabled:                       $enable_mmsequence\"\necho \"    mmdblookup enabled:                       $enable_mmdblookup\"\necho \"    mmdarwin enabled:                         $enable_mmdarwin\"\necho \"    mmfields enabled:                         $enable_mmfields\"\necho \"    mmrm1stspace module enabled:              $enable_mmrm1stspace\"\necho \"    mmkubernetes enabled:                     $enable_mmkubernetes\"\necho \"    mmtaghostname enabled:                    $enable_mmtaghostname\"\necho\necho \"---{ database support }---\"\necho \"    MySql support enabled:                    $enable_mysql\"\necho \"    libdbi support enabled:                   $enable_libdbi\"\necho \"    PostgreSQL support enabled:               $enable_pgsql\"\necho \"    mongodb support enabled:                  $enable_ommongodb\"\necho \"    hiredis support enabled:                  $enable_omhiredis\"\necho\necho \"---{ protocol support }---\"\necho \"    openssl network stream driver enabled:    $enable_openssl\"\necho \"    GnuTLS network stream driver enabled:     $enable_gnutls\"\necho \"    GSSAPI Kerberos 5 support enabled:        $enable_gssapi_krb5\"\necho \"    RELP support enabled:                     $enable_relp\"\necho \"    SNMP support enabled:                     $enable_snmp\"\necho\necho \"---{ function modules }---\"\necho \"    fmhttp enabled:                           $enable_fmhttp\"\necho \"    fmhash enabled:                           $enable_fmhash\"\necho \"    fmhash with xxhash enabled:               $enable_fmhash_xxhash\"\necho\necho \"---{ debugging support }---\"\necho \"    distcheck workaround enabled:             $enable_distcheck_workaround\"\necho \"    Testbench enabled:                        $enable_testbench\"\necho \"    valgrind tests enabled:                   $with_valgrind_testbench\"\necho \"    valgrind helgrind tests enabled:          $enable_helgrind\"\necho \"    Default tests enabled:                    $enable_default_tests\"\necho \"    Testbench libfaketime tests enabled:      $enable_libfaketime\"\necho \"    Extended Testbench enabled:               $enable_extended_tests\"\necho \"    MySQL Tests enabled:                      $enable_mysql_tests\"\necho \"    Elasticsearch Tests:                      $enable_elasticsearch_tests\"\necho \"    ClickHouse Tests:                         $enable_clickhouse_tests\"\necho \"    PostgreSQL Tests enabled:                 $enable_pgsql_tests\"\necho \"    Kafka Tests enabled:                      $enable_kafka_tests\"\necho \"    Imdocker Tests enabled:                   $enable_imdocker_tests\"\necho \"    gnutls tests enabled:                     $enable_gnutls_tests\"\necho \"    imfile tests enabled:                     $enable_imfile_tests\"\necho \"    systemd journal tests enabled:            $enable_journal_tests\"\necho \"    SNMP Tests enabled:                       $enable_snmp_tests\"\necho \"    Debug mode enabled:                       $enable_debug\"\necho \"    (total) debugless mode enabled:           $enable_debugless\"\necho \"    Diagnostic tools enabled:                 $enable_diagtools\"\necho \"    End-User tools enabled:                   $enable_usertools\"\necho \"    Valgrind support settings enabled:        $enable_valgrind\"\necho\n",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2004.0-ddt2obthz5sijsp3bwmmse3bl5yhm3hx/spack-src/tests/known_issues.supp": "{\n   <dlcose-missing-to-enable-debug-symbol-display_NOT_A_LEAK>\n   Memcheck:Leak\n   ...\n   fun:dlopen*\n   ...\n}\n\n{\n   <CentOS 6 GnuTLS memleak - well some older GnuTLS version actually>\n   Memcheck:Leak\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:EC_KEY_new\n   fun:EC_KEY_new_by_curve_name\n   fun:SetAuthMode\n   fun:LstnInit\n   fun:create_tcp_socket\n   fun:tcpsrvConstructFinalize\n   fun:activate\n   fun:initAll\n   fun:main\n}\n\n{\n   <pselect() sometimes reports pointing to unadressable byte when all selectors are empty>\n   Memcheck:Param\n   pselect6(sig)\n   fun:pselect\n   fun:wait_timeout\n   fun:mainloop\n   fun:main\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2004.0-ddt2obthz5sijsp3bwmmse3bl5yhm3hx/spack-src/runtime/modules.c": "/* modules.c\n * This is the implementation of syslogd modules object.\n * This object handles plug-ins and build-in modules of all kind.\n *\n * Modules are reference-counted. Anyone who access a module must call\n * Use() before any function is accessed and Release() when he is done.\n * When the reference count reaches 0, rsyslog unloads the module (that\n * may be changed in the future to cache modules). Rsyslog does NOT\n * unload modules with a reference count > 0, even if the unload\n * method is called!\n *\n * File begun on 2007-07-22 by RGerhards\n *\n * Copyright 2007-2018 Rainer Gerhards and Adiscon GmbH.\n *\n * This file is part of the rsyslog runtime library.\n *\n * The rsyslog runtime library is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * The rsyslog runtime library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with the rsyslog runtime library.  If not, see <http://www.gnu.org/licenses/>.\n *\n * A copy of the GPL can be found in the file \"COPYING\" in this distribution.\n * A copy of the LGPL can be found in the file \"COPYING.LESSER\" in this distribution.\n */\n#include \"config.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <assert.h>\n#include <errno.h>\n#include <pthread.h>\n#ifdef\tOS_BSD\n#\tinclude \"libgen.h\"\n#endif\n\n#include <dlfcn.h> /* TODO: replace this with the libtools equivalent! */\n\n#include <unistd.h>\n#include <sys/file.h>\n\n#ifndef PATH_MAX\n#\tdefine PATH_MAX MAXPATHLEN\n#endif\n\n#include \"rsyslog.h\"\n#include \"rainerscript.h\"\n#include \"cfsysline.h\"\n#include \"rsconf.h\"\n#include \"modules.h\"\n#include \"errmsg.h\"\n#include \"parser.h\"\n#include \"strgen.h\"\n\n/* static data */\nDEFobjStaticHelpers\nDEFobjCurrIf(strgen)\n\nstatic modInfo_t *pLoadedModules = NULL;\t/* list of currently-loaded modules */\nstatic modInfo_t *pLoadedModulesLast = NULL;\t/* tail-pointer */\n\n/* already dlopen()-ed libs */\nstatic struct dlhandle_s *pHandles = NULL;\n\nstatic uchar *pModDir;\t\t/* directory where loadable modules are found */\n\n/* tables for interfacing with the v6 config system */\n/* action (instance) parameters */\nstatic struct cnfparamdescr actpdescr[] = {\n\t{ \"load\", eCmdHdlrGetWord, 1 }\n};\nstatic struct cnfparamblk pblk =\n\t{ CNFPARAMBLK_VERSION,\n\t  sizeof(actpdescr)/sizeof(struct cnfparamdescr),\n\t  actpdescr\n\t};\n\n\ntypedef rsRetVal (*pModInit_t)(int,int*, rsRetVal(**)(), rsRetVal(*)(), modInfo_t*);\n\n/* we provide a set of dummy functions for modules that do not support the\n * some interfaces.\n * On the commit feature: As the modules do not support it, they commit each message they\n * receive, and as such the dummies can always return RS_RET_OK without causing\n * harm. This simplifies things as in action processing we do not need to check\n * if the transactional entry points exist.\n */\nstatic rsRetVal\ndummyBeginTransaction(__attribute__((unused)) void * dummy)\n{\n\treturn RS_RET_OK;\n}\nstatic rsRetVal\ndummyEndTransaction(__attribute__((unused)) void * dummy)\n{\n\treturn RS_RET_OK;\n}\nstatic rsRetVal\ndummyIsCompatibleWithFeature(__attribute__((unused)) syslogFeature eFeat)\n{\n\treturn RS_RET_INCOMPATIBLE;\n}\nstatic rsRetVal\ndummynewActInst(uchar *modName, struct nvlst __attribute__((unused)) *dummy1,\n\t\tvoid __attribute__((unused)) **dummy2, omodStringRequest_t __attribute__((unused)) **dummy3)\n{\n\tLogError(0, RS_RET_CONFOBJ_UNSUPPORTED, \"config objects are not \"\n\t\t\t\"supported by module '%s' -- legacy config options \"\n\t\t\t\"MUST be used instead\", modName);\n\treturn RS_RET_CONFOBJ_UNSUPPORTED;\n}\n\n#ifdef DEBUG\n/* we add some home-grown support to track our users (and detect who does not free us). In\n * the long term, this should probably be migrated into debug.c (TODO). -- rgerhards, 2008-03-11\n */\n\n/* add a user to the current list of users (always at the root) */\nstatic void\nmodUsrAdd(modInfo_t *pThis, const char *pszUsr)\n{\n\tmodUsr_t *pUsr;\n\n\tif((pUsr = calloc(1, sizeof(modUsr_t))) == NULL)\n\t\tgoto finalize_it;\n\n\tif((pUsr->pszFile = strdup(pszUsr)) == NULL) {\n\t\tfree(pUsr);\n\t\tgoto finalize_it;\n\t}\n\n\tif(pThis->pModUsrRoot != NULL) {\n\t\tpUsr->pNext = pThis->pModUsrRoot;\n\t}\n\tpThis->pModUsrRoot = pUsr;\n\nfinalize_it:\n\treturn;\n}\n\n\n/* remove a user from the current user list\n * rgerhards, 2008-03-11\n */\nstatic void\nmodUsrDel(modInfo_t *pThis, const char *pszUsr)\n{\n\tmodUsr_t *pUsr;\n\tmodUsr_t *pPrev = NULL;\n\n\tfor(pUsr = pThis->pModUsrRoot ; pUsr != NULL ; pUsr = pUsr->pNext) {\n\t\tif(!strcmp(pUsr->pszFile, pszUsr))\n\t\t\tbreak;\n\t\telse\n\t\t\tpPrev = pUsr;\n\t}\n\n\tif(pUsr == NULL) {\n\t\tdbgprintf(\"oops - tried to delete user %s from module %s and it wasn't registered as one...\\n\",\n\t\t\t  pszUsr, pThis->pszName);\n\t} else {\n\t\tif(pPrev == NULL) {\n\t\t\t/* This was at the root! */\n\t\t\tpThis->pModUsrRoot = pUsr->pNext;\n\t\t} else {\n\t\t\tpPrev->pNext = pUsr->pNext;\n\t\t}\n\t\t/* free ressources */\n\t\tfree(pUsr->pszFile);\n\t\tfree(pUsr);\n\t\tpUsr = NULL; /* just to make sure... */\n\t}\n}\n\n\n/* print a short list all all source files using the module in question\n * rgerhards, 2008-03-11\n */\nstatic void\nmodUsrPrint(modInfo_t *pThis)\n{\n\tmodUsr_t *pUsr;\n\n\tfor(pUsr = pThis->pModUsrRoot ; pUsr != NULL ; pUsr = pUsr->pNext) {\n\t\tdbgprintf(\"\\tmodule %s is currently in use by file %s\\n\",\n\t\t\t  pThis->pszName, pUsr->pszFile);\n\t}\n}\n\n\n/* print all loaded modules and who is accessing them. This is primarily intended\n * to be called at end of run to detect \"module leaks\" and who is causing them.\n * rgerhards, 2008-03-11\n */\nstatic void\nmodUsrPrintAll(void)\n{\n\tmodInfo_t *pMod;\n\n\tfor(pMod = pLoadedModules ; pMod != NULL ; pMod = pMod->pNext) {\n\t\tdbgprintf(\"printing users of loadable module %s, refcount %u, ptr %p, type %d\\n\",\n\t\tpMod->pszName, pMod->uRefCnt, pMod, pMod->eType);\n\t\tmodUsrPrint(pMod);\n\t}\n}\n\n#endif /* #ifdef DEBUG */\n\n\n/* Construct a new module object\n */\nstatic rsRetVal moduleConstruct(modInfo_t **pThis)\n{\n\tmodInfo_t *pNew;\n\n\tif((pNew = calloc(1, sizeof(modInfo_t))) == NULL)\n\t\treturn RS_RET_OUT_OF_MEMORY;\n\n\t/* OK, we got the element, now initialize members that should\n\t * not be zero-filled.\n\t */\n\n\t*pThis = pNew;\n\treturn RS_RET_OK;\n}\n\n\n/* Destructs a module object. The object must not be linked to the\n * linked list of modules. Please note that all other dependencies on this\n * modules must have been removed before (e.g. CfSysLineHandlers!)\n */\nstatic void moduleDestruct(modInfo_t *pThis)\n{\n\tassert(pThis != NULL);\n\tfree(pThis->pszName);\n\tfree(pThis->cnfName);\n\tif(pThis->pModHdlr != NULL) {\n#\tifdef\tVALGRIND\n\t\tDBGPRINTF(\"moduleDestruct: compiled with valgrind, do \"\n\t\t\t\"not unload module\\n\");\n#\telse\n\t\tif(glblUnloadModules) {\n\t\t\tif(pThis->eKeepType == eMOD_NOKEEP) {\n\t\t\t\tdlclose(pThis->pModHdlr);\n\t\t\t}\n\t\t} else {\n\t\t\tDBGPRINTF(\"moduleDestruct: not unloading module \"\n\t\t\t\t\"due to user configuration\\n\");\n\t\t}\n#\tendif\n\t}\n\n\tfree(pThis);\n}\n\n\n/* This enables a module to query the core for specific features.\n * rgerhards, 2009-04-22\n */\nstatic rsRetVal queryCoreFeatureSupport(int *pBool, unsigned uFeat)\n{\n\tDEFiRet;\n\n\tif(pBool == NULL)\n\t\tABORT_FINALIZE(RS_RET_PARAM_ERROR);\n\n\t*pBool = (uFeat & CORE_FEATURE_BATCHING) ? 1 : 0;\n\nfinalize_it:\n\tRETiRet;\n}\n\n\n/* The following function is the queryEntryPoint for host-based entry points.\n * Modules may call it to get access to core interface functions. Please note\n * that utility functions can be accessed via shared libraries - at least this\n * is my current shool of thinking.\n * Please note that the implementation as a query interface allows to take\n * care of plug-in interface version differences. -- rgerhards, 2007-07-31\n * ... but often it better not to use a new interface. So we now add core\n * functions here that a plugin may request. -- rgerhards, 2009-04-22\n */\nstatic rsRetVal queryHostEtryPt(uchar *name, rsRetVal (**pEtryPoint)())\n{\n\tDEFiRet;\n\n\tif((name == NULL) || (pEtryPoint == NULL))\n\t\tABORT_FINALIZE(RS_RET_PARAM_ERROR);\n\n\tif(!strcmp((char*) name, \"regCfSysLineHdlr\")) {\n\t\t*pEtryPoint = regCfSysLineHdlr;\n\t} else if(!strcmp((char*) name, \"objGetObjInterface\")) {\n\t\t*pEtryPoint = objGetObjInterface;\n\t} else if(!strcmp((char*) name, \"OMSRgetSupportedTplOpts\")) {\n\t\t*pEtryPoint = OMSRgetSupportedTplOpts;\n\t} else if(!strcmp((char*) name, \"queryCoreFeatureSupport\")) {\n\t\t*pEtryPoint = queryCoreFeatureSupport;\n\t} else {\n\t\t*pEtryPoint = NULL; /* to  be on the safe side */\n\t\tABORT_FINALIZE(RS_RET_ENTRY_POINT_NOT_FOUND);\n\t}\n\nfinalize_it:\n\tRETiRet;\n}\n\n\n/* get the name of a module\n */\nuchar *\nmodGetName(modInfo_t *pThis)\n{\n\treturn((pThis->pszName == NULL) ? (uchar*) \"\" : pThis->pszName);\n}\n\n\n/* get the state-name of a module. The state name is its name\n * together with a short description of the module state (which\n * is pulled from the module itself.\n * rgerhards, 2007-07-24\n * TODO: the actual state name is not yet pulled\n */\nstatic uchar *modGetStateName(modInfo_t *pThis)\n{\n\treturn(modGetName(pThis));\n}\n\n\n/* Add a module to the loaded module linked list\n */\nstatic void ATTR_NONNULL()\naddModToGlblList(modInfo_t *const pThis)\n{\n\tassert(pThis != NULL);\n\n\tif(pLoadedModules == NULL) {\n\t\tpLoadedModules = pLoadedModulesLast = pThis;\n\t} else {\n\t\t/* there already exist entries */\n\t\tpThis->pPrev = pLoadedModulesLast;\n\t\tpLoadedModulesLast->pNext = pThis;\n\t\tpLoadedModulesLast = pThis;\n\t}\n}\n\n\n/* ready module for config processing. this includes checking if the module\n * is already in the config, so this function may return errors. Returns a\n * pointer to the last module inthe current config. That pointer needs to\n * be passed to addModToCnfLst() when it is called later in the process.\n */\nrsRetVal\nreadyModForCnf(modInfo_t *pThis, cfgmodules_etry_t **ppNew, cfgmodules_etry_t **ppLast)\n{\n\tcfgmodules_etry_t *pNew = NULL;\n\tcfgmodules_etry_t *pLast;\n\tDEFiRet;\n\tassert(pThis != NULL);\n\n\tif(loadConf == NULL) {\n\t\tFINALIZE; /* we are in an early init state */\n\t}\n\n\t/* check for duplicates and, as a side-activity, identify last node */\n\tpLast = loadConf->modules.root;\n\tif(pLast != NULL) {\n\t\twhile(1) { /* loop broken inside */\n\t\t\tif(pLast->pMod == pThis) {\n\t\t\t\tDBGPRINTF(\"module '%s' already in this config\\n\", modGetName(pThis));\n\t\t\t\tif(strncmp((char*)modGetName(pThis), \"builtin:\", sizeof(\"builtin:\")-1)) {\n\t\t\t\t\tLogError(0, RS_RET_MODULE_ALREADY_IN_CONF,\n\t\t\t\t\t   \"module '%s' already in this config, cannot be added\\n\", modGetName(pThis));\n\t\t\t\t\tABORT_FINALIZE(RS_RET_MODULE_ALREADY_IN_CONF);\n\t\t\t\t}\n\t\t\t\tFINALIZE;\n\t\t\t}\n\t\t\tif(pLast->next == NULL)\n\t\t\t\tbreak;\n\t\t\tpLast = pLast->next;\n\t\t}\n\t}\n\n\t/* if we reach this point, pLast is the tail pointer and this module is new\n\t * inside the currently loaded config. So, iff it is an input module, let's\n\t * pass it a pointer which it can populate with a pointer to its module conf.\n\t */\n\n\tCHKmalloc(pNew = malloc(sizeof(cfgmodules_etry_t)));\n\tpNew->canActivate = 1;\n\tpNew->next = NULL;\n\tpNew->pMod = pThis;\n\n\tif(pThis->beginCnfLoad != NULL) {\n\t\tCHKiRet(pThis->beginCnfLoad(&pNew->modCnf, loadConf));\n\t}\n\n\t*ppLast = pLast;\n\t*ppNew = pNew;\nfinalize_it:\n\tif(iRet != RS_RET_OK) {\n\t\tif(pNew != NULL)\n\t\t\tfree(pNew);\n\t}\n\tRETiRet;\n}\n\n\n/* abort the creation of a module entry without adding it to the\n * module list. Needed to prevent mem leaks.\n */\nstatic inline void\nabortCnfUse(cfgmodules_etry_t **pNew)\n{\n\tif(pNew != NULL) {\n\t\tfree(*pNew);\n\t\t*pNew = NULL;\n\t}\n}\n\n\n/* Add a module to the config module list for current loadConf.\n * Requires last pointer obtained by readyModForCnf().\n * The module pointer is handed over to this function. It is no\n * longer available to caller one we are called.\n */\nrsRetVal ATTR_NONNULL(1)\naddModToCnfList(cfgmodules_etry_t **const pNew, cfgmodules_etry_t *const pLast)\n{\n\tDEFiRet;\n\tassert(*pNew != NULL);\n\n\tif(loadConf == NULL) {\n\t\tabortCnfUse(pNew);\n\t\tFINALIZE; /* we are in an early init state */\n\t}\n\n\tif(pLast == NULL) {\n\t\tloadConf->modules.root = *pNew;\n\t} else {\n\t\t/* there already exist entries */\n\t\tpLast->next = *pNew;\n\t}\n\nfinalize_it:\n\t*pNew = NULL;\n\tRETiRet;\n}\n\n\n/* Get the next module pointer - this is used to traverse the list.\n * The function returns the next pointer or NULL, if there is no next one.\n * The last object must be provided to the function. If NULL is provided,\n * it starts at the root of the list. Even in this case, NULL may be\n * returned - then, the list is empty.\n * rgerhards, 2007-07-23\n */\nstatic modInfo_t *GetNxt(modInfo_t *pThis)\n{\n\tmodInfo_t *pNew;\n\n\tif(pThis == NULL)\n\t\tpNew = pLoadedModules;\n\telse\n\t\tpNew = pThis->pNext;\n\n\treturn(pNew);\n}\n\n\n/* this function is like GetNxt(), but it returns pointers to\n * the configmodules entry, which than can be used to obtain the\n * actual module pointer. Note that it returns those for\n * modules of specific type only. Only modules from the provided\n * config are returned. Note that processing speed could be improved,\n * but this is really not relevant, as config file loading is not really\n * something we are concerned about in regard to runtime.\n */\nstatic cfgmodules_etry_t\n*GetNxtCnfType(rsconf_t *cnf, cfgmodules_etry_t *node, eModType_t rqtdType)\n{\n\tif(node == NULL) { /* start at beginning of module list */\n\t\tnode = cnf->modules.root;\n\t} else {\n\t\tnode = node->next;\n\t}\n\n\tif(rqtdType != eMOD_ANY) { /* if any, we already have the right one! */\n\t\twhile(node != NULL && node->pMod->eType != rqtdType) {\n\t\t\tnode = node->next;\n\t\t}\n\t}\n\n\treturn node;\n}\n\n\n/* Find a module with the given conf name and type. Returns NULL if none\n * can be found, otherwise module found.\n */\nstatic modInfo_t *\nFindWithCnfName(rsconf_t *cnf, uchar *name, eModType_t rqtdType)\n{\n\tcfgmodules_etry_t *node;\n\n\t;\n\tfor(  node = cnf->modules.root\n\t    ; node != NULL\n\t    ; node = node->next) {\n\t\tif(node->pMod->eType != rqtdType || node->pMod->cnfName == NULL)\n\t\t\tcontinue;\n\t\tif(!strcasecmp((char*)node->pMod->cnfName, (char*)name))\n\t\t\tbreak;\n\t}\n\n\treturn node == NULL ? NULL : node->pMod;\n}\n\n\n/* Prepare a module for unloading.\n * This is currently a dummy, to be filled when we have a plug-in\n * interface - rgerhards, 2007-08-09\n * rgerhards, 2007-11-21:\n * When this function is called, all instance-data must already have\n * been destroyed. In the case of output modules, this happens when the\n * rule set is being destroyed. When we implement other module types, we\n * need to think how we handle it there (and if we have any instance data).\n * rgerhards, 2008-03-10: reject unload request if the module has a reference\n * count > 0.\n */\nstatic rsRetVal\nmodPrepareUnload(modInfo_t *pThis)\n{\n\tDEFiRet;\n\tvoid *pModCookie;\n\n\tassert(pThis != NULL);\n\n\tif(pThis->uRefCnt > 0) {\n\t\tdbgprintf(\"rejecting unload of module '%s' because it has a refcount of %d\\n\",\n\t\t\t  pThis->pszName, pThis->uRefCnt);\n\t\tABORT_FINALIZE(RS_RET_MODULE_STILL_REFERENCED);\n\t}\n\n\tCHKiRet(pThis->modGetID(&pModCookie));\n\tpThis->modExit(); /* tell the module to get ready for unload */\n\tCHKiRet(unregCfSysLineHdlrs4Owner(pModCookie));\n\nfinalize_it:\n\tRETiRet;\n}\n\n\n/* Add an already-loaded module to the module linked list. This function does\n * everything needed to fully initialize the module.\n */\nstatic rsRetVal\ndoModInit(pModInit_t modInit, uchar *name, void *pModHdlr, modInfo_t **pNewModule)\n{\n\trsRetVal localRet;\n\tmodInfo_t *pNew = NULL;\n\tuchar *pName;\n\tstrgen_t *pStrgen; /* used for strgen modules */\n\trsRetVal (*GetName)(uchar**);\n\trsRetVal (*modGetType)(eModType_t *pType);\n\trsRetVal (*modGetKeepType)(eModKeepType_t *pKeepType);\n\tstruct dlhandle_s *pHandle = NULL;\n\trsRetVal (*getModCnfName)(uchar **cnfName);\n\tuchar *cnfName;\n\tDEFiRet;\n\n\tassert(modInit != NULL);\n\n\tif((iRet = moduleConstruct(&pNew)) != RS_RET_OK) {\n\t\tpNew = NULL;\n\t\tFINALIZE;\n\t}\n\n\tCHKiRet((*modInit)(CURR_MOD_IF_VERSION, &pNew->iIFVers, &pNew->modQueryEtryPt, queryHostEtryPt, pNew));\n\n\tif(pNew->iIFVers != CURR_MOD_IF_VERSION) {\n\t\tABORT_FINALIZE(RS_RET_MISSING_INTERFACE);\n\t}\n\n\t/* We now poll the module to see what type it is. We do this only once as this\n\t * can never change in the lifetime of an module. -- rgerhards, 2007-12-14\n\t */\n\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"getType\", &modGetType));\n\tCHKiRet((*modGetType)(&pNew->eType));\n\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"getKeepType\", &modGetKeepType));\n\tCHKiRet((*modGetKeepType)(&pNew->eKeepType));\n\tdbgprintf(\"module %s of type %d being loaded (keepType=%d).\\n\", name, pNew->eType, pNew->eKeepType);\n\t\n\t/* OK, we know we can successfully work with the module. So we now fill the\n\t * rest of the data elements. First we load the interfaces common to all\n\t * module types.\n\t */\n\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"modGetID\", &pNew->modGetID));\n\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"modExit\", &pNew->modExit));\n\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"isCompatibleWithFeature\", &pNew->isCompatibleWithFeature);\n\tif(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND)\n\t\tpNew->isCompatibleWithFeature = dummyIsCompatibleWithFeature;\n\telse if(localRet != RS_RET_OK)\n\t\tABORT_FINALIZE(localRet);\n\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"setModCnf\", &pNew->setModCnf);\n\tif(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND)\n\t\tpNew->setModCnf = NULL;\n\telse if(localRet != RS_RET_OK)\n\t\tABORT_FINALIZE(localRet);\n\n\t/* optional calls for new config system */\n\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"getModCnfName\", &getModCnfName);\n\tif(localRet == RS_RET_OK) {\n\t\tif(getModCnfName(&cnfName) == RS_RET_OK)\n\t\t\tpNew->cnfName = (uchar*) strdup((char*)cnfName);\n\t\t\t  /**< we do not care if strdup() fails, we can accept that */\n\t\telse\n\t\t\tpNew->cnfName = NULL;\n\t\tdbgprintf(\"module config name is '%s'\\n\", cnfName);\n\t}\n\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"beginCnfLoad\", &pNew->beginCnfLoad);\n\tif(localRet == RS_RET_OK) {\n\t\tdbgprintf(\"module %s supports rsyslog v6 config interface\\n\", name);\n\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"endCnfLoad\", &pNew->endCnfLoad));\n\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"freeCnf\", &pNew->freeCnf));\n\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"checkCnf\", &pNew->checkCnf));\n\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"activateCnf\", &pNew->activateCnf));\n\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"activateCnfPrePrivDrop\", &pNew->activateCnfPrePrivDrop);\n\t\tif(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND) {\n\t\t\tpNew->activateCnfPrePrivDrop = NULL;\n\t\t} else {\n\t\t\tCHKiRet(localRet);\n\t\t}\n\t} else if(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND) {\n\t\tpNew->beginCnfLoad = NULL; /* flag as non-present */\n\t} else {\n\t\tABORT_FINALIZE(localRet);\n\t}\n\t/* ... and now the module-specific interfaces */\n\tswitch(pNew->eType) {\n\t\tcase eMOD_IN:\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"runInput\", &pNew->mod.im.runInput));\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"willRun\", &pNew->mod.im.willRun));\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"afterRun\", &pNew->mod.im.afterRun));\n\t\t\tpNew->mod.im.bCanRun = 0;\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"newInpInst\", &pNew->mod.im.newInpInst);\n\t\t\tif(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND) {\n\t\t\t\tpNew->mod.im.newInpInst = NULL;\n\t\t\t} else if(localRet != RS_RET_OK) {\n\t\t\t\tABORT_FINALIZE(localRet);\n\t\t\t}\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"doHUP\", &pNew->doHUP);\n\t\t\tif(localRet != RS_RET_OK && localRet != RS_RET_MODULE_ENTRY_POINT_NOT_FOUND)\n\t\t\t\tABORT_FINALIZE(localRet);\n\n\t\t\tbreak;\n\t\tcase eMOD_OUT:\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"freeInstance\", &pNew->freeInstance));\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"dbgPrintInstInfo\", &pNew->dbgPrintInstInfo));\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"parseSelectorAct\", &pNew->mod.om.parseSelectorAct));\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"tryResume\", &pNew->tryResume));\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"createWrkrInstance\",\n\t\t\t\t&pNew->mod.om.createWrkrInstance));\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"freeWrkrInstance\",\n\t\t\t\t&pNew->mod.om.freeWrkrInstance));\n\n\t\t\t/* try load optional interfaces */\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"doHUP\", &pNew->doHUP);\n\t\t\tif(localRet != RS_RET_OK && localRet != RS_RET_MODULE_ENTRY_POINT_NOT_FOUND)\n\t\t\t\tABORT_FINALIZE(localRet);\n\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"doHUPWrkr\", &pNew->doHUPWrkr);\n\t\t\tif(localRet != RS_RET_OK && localRet != RS_RET_MODULE_ENTRY_POINT_NOT_FOUND)\n\t\t\t\tABORT_FINALIZE(localRet);\n\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"SetShutdownImmdtPtr\",\n\t\t\t\t&pNew->mod.om.SetShutdownImmdtPtr);\n\t\t\tif(localRet != RS_RET_OK && localRet != RS_RET_MODULE_ENTRY_POINT_NOT_FOUND)\n\t\t\t\tABORT_FINALIZE(localRet);\n\n\t\t\tpNew->mod.om.supportsTX = 1;\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"beginTransaction\", &pNew->mod.om.beginTransaction);\n\t\t\tif(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND) {\n\t\t\t\tpNew->mod.om.beginTransaction = dummyBeginTransaction;\n\t\t\t\tpNew->mod.om.supportsTX = 0;\n\t\t\t} else if(localRet != RS_RET_OK) {\n\t\t\t\tABORT_FINALIZE(localRet);\n\t\t\t}\n\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"doAction\",\n\t\t\t\t   &pNew->mod.om.doAction);\n\t\t\tif(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND) {\n\t\t\t\tpNew->mod.om.doAction = NULL;\n\t\t\t} else if(localRet != RS_RET_OK) {\n\t\t\t\tABORT_FINALIZE(localRet);\n\t\t\t}\n\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"commitTransaction\",\n\t\t\t\t   &pNew->mod.om.commitTransaction);\n\t\t\tif(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND) {\n\t\t\t\tpNew->mod.om.commitTransaction = NULL;\n\t\t\t} else if(localRet != RS_RET_OK) {\n\t\t\t\tABORT_FINALIZE(localRet);\n\t\t\t}\n\n\t\t\tif(pNew->mod.om.doAction == NULL && pNew->mod.om.commitTransaction == NULL) {\n\t\t\t\tLogError(0, RS_RET_INVLD_OMOD,\n\t\t\t\t\t\"module %s does neither provide doAction() \"\n\t\t\t\t\t\"nor commitTransaction() interface - cannot \"\n\t\t\t\t\t\"load\", name);\n\t\t\t\tABORT_FINALIZE(RS_RET_INVLD_OMOD);\n\t\t\t}\n\n\t\t\tif(pNew->mod.om.commitTransaction != NULL) {\n\t\t\t\tif(pNew->mod.om.doAction != NULL){\n\t\t\t\t\tLogError(0, RS_RET_INVLD_OMOD,\n\t\t\t\t\t\t\"module %s provides both doAction() \"\n\t\t\t\t\t\t\"and commitTransaction() interface, using \"\n\t\t\t\t\t\t\"commitTransaction()\", name);\n\t\t\t\t\tpNew->mod.om.doAction = NULL;\n\t\t\t\t}\n\t\t\t\tif(pNew->mod.om.beginTransaction == NULL){\n\t\t\t\t\tLogError(0, RS_RET_INVLD_OMOD,\n\t\t\t\t\t\t\"module %s provides both commitTransaction() \"\n\t\t\t\t\t\t\"but does not provide beginTransaction() - \"\n\t\t\t\t\t\t\"cannot load\", name);\n\t\t\t\t\tABORT_FINALIZE(RS_RET_INVLD_OMOD);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"endTransaction\",\n\t\t\t\t   &pNew->mod.om.endTransaction);\n\t\t\tif(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND) {\n\t\t\t\tpNew->mod.om.endTransaction = dummyEndTransaction;\n\t\t\t} else if(localRet != RS_RET_OK) {\n\t\t\t\tABORT_FINALIZE(localRet);\n\t\t\t}\n\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"newActInst\", &pNew->mod.om.newActInst);\n\t\t\tif(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND) {\n\t\t\t\tpNew->mod.om.newActInst = dummynewActInst;\n\t\t\t} else if(localRet != RS_RET_OK) {\n\t\t\t\tABORT_FINALIZE(localRet);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase eMOD_LIB:\n\t\t\tbreak;\n\t\tcase eMOD_PARSER:\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"parse2\",\n\t\t\t\t   &pNew->mod.pm.parse2);\n\t\t\tif(localRet == RS_RET_OK) {\n\t\t\t\tpNew->mod.pm.parse = NULL;\n\t\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"newParserInst\",\n\t\t\t\t\t&pNew->mod.pm.newParserInst));\n\t\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"freeParserInst\",\n\t\t\t\t\t&pNew->mod.pm.freeParserInst));\n\t\t\t} else if(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND) {\n\t\t\t\tpNew->mod.pm.parse2 = NULL;\n\t\t\t\tpNew->mod.pm.newParserInst = NULL;\n\t\t\t\tpNew->mod.pm.freeParserInst = NULL;\n\t\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"parse\", &pNew->mod.pm.parse));\n\t\t\t} else {\n\t\t\t\tABORT_FINALIZE(localRet);\n\t\t\t}\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"GetParserName\", &GetName));\n\t\t\tCHKiRet(GetName(&pName));\n\t\t\tCHKiRet(parserConstructViaModAndName(pNew, pName, NULL));\n\t\t\tbreak;\n\t\tcase eMOD_STRGEN:\n\t\t\t/* first, we need to obtain the strgen object. We could not do that during\n\t\t\t * init as that would have caused class bootstrap issues which are not\n\t\t\t * absolutely necessary. Note that we can call objUse() multiple times, it\n\t\t\t * handles that.\n\t\t\t */\n\t\t\tCHKiRet(objUse(strgen, CORE_COMPONENT));\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"strgen\", &pNew->mod.sm.strgen));\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"GetName\", &GetName));\n\t\t\tCHKiRet(GetName(&pName));\n\t\t\tCHKiRet(strgen.Construct(&pStrgen));\n\t\t\tCHKiRet(strgen.SetName(pStrgen, pName));\n\t\t\tCHKiRet(strgen.SetModPtr(pStrgen, pNew));\n\t\t\tCHKiRet(strgen.ConstructFinalize(pStrgen));\n\t\t\tbreak;\n\t\tcase eMOD_FUNCTION:\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"getFunctArray\", &pNew->mod.fm.getFunctArray));\n\t\t\tint version;\n\t\t\tstruct scriptFunct *functArray;\n\t\t\tpNew->mod.fm.getFunctArray(&version, &functArray);\n\t\t\tdbgprintf(\"LLL: %s\\n\", functArray[0].fname);\n\t\t\taddMod2List(version, functArray);\n\t\t\tbreak;\n\t\tcase eMOD_ANY: /* this is mostly to keep the compiler happy! */\n\t\t\tDBGPRINTF(\"PROGRAM ERROR: eMOD_ANY set as module type\\n\");\n\t\t\tassert(0);\n\t\t\tbreak;\n\t}\n\n\tpNew->pszName = (uchar*) strdup((char*)name); /* we do not care if strdup() fails, we can accept that */\n\tpNew->pModHdlr = pModHdlr;\n\tif(pModHdlr == NULL) {\n\t\tpNew->eLinkType = eMOD_LINK_STATIC;\n\t} else {\n\t\tpNew->eLinkType = eMOD_LINK_DYNAMIC_LOADED;\n\n\t\t/* if we need to keep the linked module, save it */\n\t\tif (pNew->eKeepType == eMOD_KEEP) {\n\t\t\t/* see if we have this one already */\n\t\t\tfor (pHandle = pHandles; pHandle; pHandle = pHandle->next) {\n\t\t\t\tif (!strcmp((char *)name, (char *)pHandle->pszName))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* not found, create it */\n\t\t\tif (!pHandle) {\n\t\t\t\tif((pHandle = malloc(sizeof (*pHandle))) == NULL) {\n\t\t\t\t\tABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);\n\t\t\t\t}\n\t\t\t\tif((pHandle->pszName = (uchar*) strdup((char*)name)) == NULL) {\n\t\t\t\t\tfree(pHandle);\n\t\t\t\t\tABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);\n\t\t\t\t}\n\t\t\t\tpHandle->pModHdlr = pModHdlr;\n\t\t\t\tpHandle->next = pHandles;\n\n\t\t\t\tpHandles = pHandle;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* we initialized the structure, now let's add it to the linked list of modules */\n\taddModToGlblList(pNew);\n\t*pNewModule = pNew;\n\nfinalize_it:\n\tif(iRet != RS_RET_OK) {\n\t\tif(pNew != NULL)\n\t\t\tmoduleDestruct(pNew);\n\t\t*pNewModule = NULL;\n\t}\n\n\tRETiRet;\n}\n\n/* Print loaded modules. This is more or less a\n * debug or test aid, but anyhow I think it's worth it...\n * This only works if the dbgprintf() subsystem is initialized.\n * TODO: update for new input modules!\n */\nstatic void modPrintList(void)\n{\n\tmodInfo_t *pMod;\n\n\tpMod = GetNxt(NULL);\n\twhile(pMod != NULL) {\n\t\tdbgprintf(\"Loaded Module: Name='%s', IFVersion=%d, \",\n\t\t\t(char*) modGetName(pMod), pMod->iIFVers);\n\t\tdbgprintf(\"type=\");\n\t\tswitch(pMod->eType) {\n\t\tcase eMOD_OUT:\n\t\t\tdbgprintf(\"output\");\n\t\t\tbreak;\n\t\tcase eMOD_IN:\n\t\t\tdbgprintf(\"input\");\n\t\t\tbreak;\n\t\tcase eMOD_LIB:\n\t\t\tdbgprintf(\"library\");\n\t\t\tbreak;\n\t\tcase eMOD_PARSER:\n\t\t\tdbgprintf(\"parser\");\n\t\t\tbreak;\n\t\tcase eMOD_STRGEN:\n\t\t\tdbgprintf(\"strgen\");\n\t\t\tbreak;\n\t\tcase eMOD_FUNCTION:\n\t\t\tdbgprintf(\"function\");\n\t\t\tbreak;\n\t\tcase eMOD_ANY: /* this is mostly to keep the compiler happy! */\n\t\t\tDBGPRINTF(\"PROGRAM ERROR: eMOD_ANY set as module type\\n\");\n\t\t\tassert(0);\n\t\t\tbreak;\n\t\t}\n\t\tdbgprintf(\" module.\\n\");\n\t\tdbgprintf(\"Entry points:\\n\");\n\t\tdbgprintf(\"\\tqueryEtryPt:        0x%lx\\n\", (unsigned long) pMod->modQueryEtryPt);\n\t\tdbgprintf(\"\\tdbgPrintInstInfo:   0x%lx\\n\", (unsigned long) pMod->dbgPrintInstInfo);\n\t\tdbgprintf(\"\\tfreeInstance:       0x%lx\\n\", (unsigned long) pMod->freeInstance);\n\t\tdbgprintf(\"\\tbeginCnfLoad:       0x%lx\\n\", (unsigned long) pMod->beginCnfLoad);\n\t\tdbgprintf(\"\\tSetModCnf:          0x%lx\\n\", (unsigned long) pMod->setModCnf);\n\t\tdbgprintf(\"\\tcheckCnf:           0x%lx\\n\", (unsigned long) pMod->checkCnf);\n\t\tdbgprintf(\"\\tactivateCnfPrePrivDrop: 0x%lx\\n\", (unsigned long) pMod->activateCnfPrePrivDrop);\n\t\tdbgprintf(\"\\tactivateCnf:        0x%lx\\n\", (unsigned long) pMod->activateCnf);\n\t\tdbgprintf(\"\\tfreeCnf:            0x%lx\\n\", (unsigned long) pMod->freeCnf);\n\t\tswitch(pMod->eType) {\n\t\tcase eMOD_OUT:\n\t\t\tdbgprintf(\"Output Module Entry Points:\\n\");\n\t\t\tdbgprintf(\"\\tdoAction:           %p\\n\", pMod->mod.om.doAction);\n\t\t\tdbgprintf(\"\\tparseSelectorAct:   %p\\n\", pMod->mod.om.parseSelectorAct);\n\t\t\tdbgprintf(\"\\tnewActInst:         %p\\n\", (pMod->mod.om.newActInst == dummynewActInst) ?\n\t\t\t\t\t\tNULL :  pMod->mod.om.newActInst);\n\t\t\tdbgprintf(\"\\ttryResume:          %p\\n\", pMod->tryResume);\n\t\t\tdbgprintf(\"\\tdoHUP:              %p\\n\", pMod->doHUP);\n\t\t\tdbgprintf(\"\\tBeginTransaction:   %p\\n\", ((pMod->mod.om.beginTransaction ==\n\t\t\t\t\t\tdummyBeginTransaction) ? NULL :  pMod->mod.om.beginTransaction));\n\t\t\tdbgprintf(\"\\tEndTransaction:     %p\\n\", ((pMod->mod.om.endTransaction ==\n\t\t\t\t\t\tdummyEndTransaction) ? NULL :  pMod->mod.om.endTransaction));\n\t\t\tbreak;\n\t\tcase eMOD_IN:\n\t\t\tdbgprintf(\"Input Module Entry Points\\n\");\n\t\t\tdbgprintf(\"\\trunInput:           0x%lx\\n\", (unsigned long) pMod->mod.im.runInput);\n\t\t\tdbgprintf(\"\\twillRun:            0x%lx\\n\", (unsigned long) pMod->mod.im.willRun);\n\t\t\tdbgprintf(\"\\tafterRun:           0x%lx\\n\", (unsigned long) pMod->mod.im.afterRun);\n\t\t\tbreak;\n\t\tcase eMOD_LIB:\n\t\t\tbreak;\n\t\tcase eMOD_PARSER:\n\t\t\tdbgprintf(\"Parser Module Entry Points\\n\");\n\t\t\tdbgprintf(\"\\tparse:              0x%lx\\n\", (unsigned long) pMod->mod.pm.parse);\n\t\t\tbreak;\n\t\tcase eMOD_STRGEN:\n\t\t\tdbgprintf(\"Strgen Module Entry Points\\n\");\n\t\t\tdbgprintf(\"\\tstrgen:            0x%lx\\n\", (unsigned long) pMod->mod.sm.strgen);\n\t\t\tbreak;\n\t\tcase eMOD_FUNCTION:\n\t\t\tdbgprintf(\"Function Module Entry Points\\n\");\n\t\t\tdbgprintf(\"\\tgetFunctArray:     0x%lx\\n\", (unsigned long) pMod->mod.fm.getFunctArray);\n\t\t\tbreak;\n\t\tcase eMOD_ANY: /* this is mostly to keep the compiler happy! */\n\t\t\tbreak;\n\t\t}\n\t\tdbgprintf(\"\\n\");\n\t\tpMod = GetNxt(pMod); /* done, go next */\n\t}\n}\n\n\n/* HUP all modules that support it - except for actions, which\n * need (and have) specialised HUP handling.\n */\nvoid\nmodDoHUP(void)\n{\n\tmodInfo_t *pMod;\n\n\tpthread_mutex_lock(&mutObjGlobalOp);\n\tpMod = GetNxt(NULL);\n\twhile(pMod != NULL) {\n\t\tif(pMod->eType != eMOD_OUT && pMod->doHUP != NULL) {\n\t\t\tDBGPRINTF(\"HUPing module %s\\n\", (char*) modGetName(pMod));\n\t\t\tpMod->doHUP(NULL);\n\t\t}\n\t\tpMod = GetNxt(pMod); /* done, go next */\n\t}\n\tpthread_mutex_unlock(&mutObjGlobalOp);\n}\n\n\n/* unlink and destroy a module. The caller must provide a pointer to the module\n * itself as well as one to its immediate predecessor.\n * rgerhards, 2008-02-26\n */\nstatic rsRetVal\nmodUnlinkAndDestroy(modInfo_t **ppThis)\n{\n\tDEFiRet;\n\tmodInfo_t *pThis;\n\n\tassert(ppThis != NULL);\n\tpThis = *ppThis;\n\tassert(pThis != NULL);\n\n\tpthread_mutex_lock(&mutObjGlobalOp);\n\n\t/* first check if we are permitted to unload */\n\tif(pThis->eType == eMOD_LIB) {\n\t\tif(pThis->uRefCnt > 0) {\n\t\t\tdbgprintf(\"module %s NOT unloaded because it still has a refcount of %u\\n\",\n\t\t\t\t  pThis->pszName, pThis->uRefCnt);\n\t\t\tABORT_FINALIZE(RS_RET_MODULE_STILL_REFERENCED);\n\t\t}\n\t}\n\n\t/* we need to unlink the module before we can destruct it -- rgerhards, 2008-02-26 */\n\tif(pThis->pPrev == NULL) {\n\t\t/* module is root, so we need to set a new root */\n\t\tpLoadedModules = pThis->pNext;\n\t} else {\n\t\tpThis->pPrev->pNext = pThis->pNext;\n\t}\n\n\tif(pThis->pNext == NULL) {\n\t\tpLoadedModulesLast = pThis->pPrev;\n\t} else {\n\t\tpThis->pNext->pPrev = pThis->pPrev;\n\t}\n\n\t/* finally, we are ready for the module to go away... */\n\tdbgprintf(\"Unloading module %s\\n\", modGetName(pThis));\n\tCHKiRet(modPrepareUnload(pThis));\n\t*ppThis = pThis->pNext;\n\n\tmoduleDestruct(pThis);\n\nfinalize_it:\n\tpthread_mutex_unlock(&mutObjGlobalOp);\n\tRETiRet;\n}\n\n\n/* unload all loaded modules of a specific type (use eMOD_ALL if you want to\n * unload all module types). The unload happens only if the module is no longer\n * referenced. So some modules may survive this call.\n * rgerhards, 2008-03-11\n */\nstatic rsRetVal\nmodUnloadAndDestructAll(eModLinkType_t modLinkTypesToUnload)\n{\n\tDEFiRet;\n\tmodInfo_t *pModCurr; /* module currently being processed */\n\n\tpModCurr = GetNxt(NULL);\n\twhile(pModCurr != NULL) {\n\t\tif(modLinkTypesToUnload == eMOD_LINK_ALL || pModCurr->eLinkType == modLinkTypesToUnload) {\n\t\t\tif(modUnlinkAndDestroy(&pModCurr) == RS_RET_MODULE_STILL_REFERENCED) {\n\t\t\t\tpModCurr = GetNxt(pModCurr);\n\t\t\t} else {\n\t\t\t\t/* Note: if the module was successfully unloaded, it has updated the\n\t\t\t\t * pModCurr pointer to the next module. However, the unload process may\n\t\t\t\t * still have indirectly referenced the pointer list in a way that the\n\t\t\t\t * unloaded module is not aware of. So we restart the unload process\n\t\t\t\t * to make sure we do not fall into a trap (what we did ;)). The\n\t\t\t\t * performance toll is minimal. -- rgerhards, 2008-04-28\n\t\t\t\t */\n\t\t\t\tpModCurr = GetNxt(NULL);\n\t\t\t}\n\t\t} else {\n\t\t\tpModCurr = GetNxt(pModCurr);\n\t\t}\n\t}\n\n\tRETiRet;\n}\n\n/* find module with given name in global list */\nstatic rsRetVal\nfindModule(uchar *pModName, int iModNameLen, modInfo_t **pMod)\n{\n\tmodInfo_t *pModInfo;\n\tuchar *pModNameCmp;\n\tDEFiRet;\n\n\tpModInfo = GetNxt(NULL);\n\twhile(pModInfo != NULL) {\n\t\tif(!strncmp((char *) pModName, (char *) (pModNameCmp = modGetName(pModInfo)), iModNameLen) &&\n\t\t   (!*(pModNameCmp + iModNameLen) || !strcmp((char *) pModNameCmp + iModNameLen, \".so\"))) {\n\t\t\tdbgprintf(\"Module '%s' found\\n\", pModName);\n\t\t\tbreak;\n\t\t}\n\t\tpModInfo = GetNxt(pModInfo);\n\t}\n\t*pMod = pModInfo;\n\tRETiRet;\n}\n\n\n/* load a module and initialize it, based on doModLoad() from conf.c\n * rgerhards, 2008-03-05\n * varmojfekoj added support for dynamically loadable modules on 2007-08-13\n * rgerhards, 2007-09-25: please note that the non-threadsafe function dlerror() is\n * called below. This is ok because modules are currently only loaded during\n * configuration file processing, which is executed on a single thread. Should we\n * change that design at any stage (what is unlikely), we need to find a\n * replacement.\n * rgerhards, 2011-04-27:\n * Parameter \"bConfLoad\" tells us if the load was triggered by a config handler, in\n * which case we need to tie the loaded module to the current config. If bConfLoad == 0,\n * the system loads a module for internal reasons, this is not directly tied to a\n * configuration. We could also think if it would be useful to add only certain types\n * of modules, but the current implementation at least looks simpler.\n * Note: pvals = NULL means legacy config system\n */\nstatic rsRetVal ATTR_NONNULL(1)\nLoad(uchar *const pModName, const sbool bConfLoad, struct nvlst *const lst)\n{\n\tsize_t iPathLen, iModNameLen;\n\tint bHasExtension;\n\tvoid *pModHdlr;\n\tpModInit_t pModInit;\n\tmodInfo_t *pModInfo;\n\tcfgmodules_etry_t *pNew = NULL;\n\tcfgmodules_etry_t *pLast = NULL;\n\tuchar *pModDirCurr, *pModDirNext;\n\tint iLoadCnt;\n\tstruct dlhandle_s *pHandle = NULL;\n#\tifdef PATH_MAX\n\tuchar pathBuf[PATH_MAX+1];\n#\telse\n\tuchar pathBuf[4096];\n#\tendif\n\tuchar *pPathBuf = pathBuf;\n\tsize_t lenPathBuf = sizeof(pathBuf);\n\trsRetVal localRet;\n\tcstr_t *load_err_msg = NULL;\n\tDEFiRet;\n\n\tassert(pModName != NULL);\n\tDBGPRINTF(\"Requested to load module '%s'\\n\", pModName);\n\n\tiModNameLen = strlen((char*)pModName);\n\t/* overhead for a full path is potentially 1 byte for a slash,\n\t * three bytes for \".so\" and one byte for '\\0'.\n\t */\n#\tdefine PATHBUF_OVERHEAD 1 + iModNameLen + 3 + 1\n\n\tpthread_mutex_lock(&mutObjGlobalOp);\n\n\tif(iModNameLen > 3 && !strcmp((char *) pModName + iModNameLen - 3, \".so\")) {\n\t\tiModNameLen -= 3;\n\t\tbHasExtension = RSTRUE;\n\t} else\n\t\tbHasExtension = RSFALSE;\n\n\tCHKiRet(findModule(pModName, iModNameLen, &pModInfo));\n\tif(pModInfo != NULL) {\n\t\tDBGPRINTF(\"Module '%s' already loaded\\n\", pModName);\n\t\tif(bConfLoad) {\n\t\t\tlocalRet = readyModForCnf(pModInfo, &pNew, &pLast);\n\t\t\tif(pModInfo->setModCnf != NULL && localRet == RS_RET_OK) {\n\t\t\t\tif(!strncmp((char*)pModName, \"builtin:\", sizeof(\"builtin:\")-1)) {\n\t\t\t\t\tif(pModInfo->bSetModCnfCalled) {\n\t\t\t\t\t\tLogError(0, RS_RET_DUP_PARAM,\n\t\t\t\t\t\t    \"parameters for built-in module %s already set - ignored\\n\",\n\t\t\t\t\t\t    pModName);\n\t\t\t\t\t\tABORT_FINALIZE(RS_RET_DUP_PARAM);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* for built-in moules, we need to call setModConf,\n\t\t\t\t\t\t * because there is no way to set parameters at load\n\t\t\t\t\t\t * time for obvious reasons...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif(lst != NULL)\n\t\t\t\t\t\t\tpModInfo->setModCnf(lst);\n\t\t\t\t\t\tpModInfo->bSetModCnfCalled = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* regular modules need to be added to conf list (for\n\t\t\t\t\t * builtins, this happend during initial load).\n\t\t\t\t\t */\n\t\t\t\t\taddModToCnfList(&pNew, pLast);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFINALIZE;\n\t}\n\n\tpModDirCurr = (uchar *)((pModDir == NULL) ? _PATH_MODDIR : (char *)pModDir);\n\tpModDirNext = NULL;\n\tpModHdlr    = NULL;\n\tiLoadCnt    = 0;\n\tdo {\t/* now build our load module name */\n\t\tif(*pModName == '/' || *pModName == '.') {\n\t\t\tif(lenPathBuf < PATHBUF_OVERHEAD) {\n\t\t\t\tif(pPathBuf != pathBuf) /* already malloc()ed memory? */\n\t\t\t\t\tfree(pPathBuf);\n\t\t\t\t/* we always alloc enough memory for everything we potentiall need to add */\n\t\t\t\tlenPathBuf = PATHBUF_OVERHEAD;\n\t\t\t\tCHKmalloc(pPathBuf = malloc(lenPathBuf));\n\t\t\t}\n\t\t\t*pPathBuf = '\\0';\t/* we do not need to append the path - its already in the module name */\n\t\t\tiPathLen = 0;\n\t\t} else {\n\t\t\t*pPathBuf = '\\0';\n\n\t\t\tiPathLen = strlen((char *)pModDirCurr);\n\t\t\tpModDirNext = (uchar *)strchr((char *)pModDirCurr, ':');\n\t\t\tif(pModDirNext)\n\t\t\t\tiPathLen = (size_t)(pModDirNext - pModDirCurr);\n\n\t\t\tif(iPathLen == 0) {\n\t\t\t\tif(pModDirNext) {\n\t\t\t\t\tpModDirCurr = pModDirNext + 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else if(iPathLen > lenPathBuf - PATHBUF_OVERHEAD) {\n\t\t\t\tif(pPathBuf != pathBuf) /* already malloc()ed memory? */\n\t\t\t\t\tfree(pPathBuf);\n\t\t\t\t/* we always alloc enough memory for everything we potentiall need to add */\n\t\t\t\tlenPathBuf = iPathLen + PATHBUF_OVERHEAD;\n\t\t\t\tCHKmalloc(pPathBuf = malloc(lenPathBuf));\n\t\t\t}\n\n\t\t\tmemcpy((char *) pPathBuf, (char *)pModDirCurr, iPathLen);\n\t\t\tif((pPathBuf[iPathLen - 1] != '/')) {\n\t\t\t\t/* we have space, made sure in previous check */\n\t\t\t\tpPathBuf[iPathLen++] = '/';\n\t\t\t}\n\t\t\tpPathBuf[iPathLen] = '\\0';\n\n\t\t\tif(pModDirNext)\n\t\t\t\tpModDirCurr = pModDirNext + 1;\n\t\t}\n\n\t\t/* ... add actual name ... */\n\t\tstrncat((char *) pPathBuf, (char *) pModName, lenPathBuf - iPathLen - 1);\n\n\t\t/* now see if we have an extension and, if not, append \".so\" */\n\t\tif(!bHasExtension) {\n\t\t\t/* we do not have an extension and so need to add \".so\"\n\t\t\t * TODO: I guess this is highly importable, so we should change the\n\t\t\t * algo over time... -- rgerhards, 2008-03-05\n\t\t\t */\n\t\t\tstrncat((char *) pPathBuf, \".so\", lenPathBuf - strlen((char*) pPathBuf) - 1);\n\t\t}\n\n\t\t/* complete load path constructed, so ... GO! */\n\t\tdbgprintf(\"loading module '%s'\\n\", pPathBuf);\n\n\t\t/* see if we have this one already */\n\t\tfor (pHandle = pHandles; pHandle; pHandle = pHandle->next) {\n\t\t\tif (!strcmp((char *)pModName, (char *)pHandle->pszName)) {\n\t\t\t\tpModHdlr = pHandle->pModHdlr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* not found, try to dynamically link it */\n\t\tif (!pModHdlr) {\n\t\t\tpModHdlr = dlopen((char *) pPathBuf, RTLD_NOW);\n\t\t}\n\n\t\tif(pModHdlr == NULL) {\n\t\t\tchar errmsg[4096];\n\t\t\tsnprintf(errmsg, sizeof(errmsg), \"%strying to load module %s: %s\",\n\t\t\t\t(load_err_msg == NULL) ? \"\" : \"  ////////  \",\n\t\t\t\tpPathBuf, dlerror());\n\t\t\tif(load_err_msg == NULL) {\n\t\t\t\trsCStrConstructFromszStr(&load_err_msg, (uchar*)errmsg);\n\t\t\t} else {\n\t\t\t\trsCStrAppendStr(load_err_msg, (uchar*)errmsg);\n\t\t\t}\n\t\t}\n\n\t\tiLoadCnt++;\n\t\n\t} while(pModHdlr == NULL && *pModName != '/' && pModDirNext);\n\n\tif(load_err_msg != NULL) {\n\t\tcstrFinalize(load_err_msg);\n\t}\n\n\tif(!pModHdlr) {\n\t\tLogError(0, RS_RET_MODULE_LOAD_ERR_DLOPEN, \"could not load module '%s', errors: %s\", pModName,\n\t\t\t(load_err_msg == NULL) ? \"NONE SEEN???\" : (const char*) cstrGetSzStrNoNULL(load_err_msg));\n\t\tABORT_FINALIZE(RS_RET_MODULE_LOAD_ERR_DLOPEN);\n\t}\n\tif(!(pModInit = (pModInit_t)dlsym(pModHdlr, \"modInit\"))) {\n\t\tLogError(0, RS_RET_MODULE_LOAD_ERR_NO_INIT,\n\t\t\t \t\"could not load module '%s', dlsym: %s\\n\", pPathBuf, dlerror());\n\t\tdlclose(pModHdlr);\n\t\tABORT_FINALIZE(RS_RET_MODULE_LOAD_ERR_NO_INIT);\n\t}\n\tif((iRet = doModInit(pModInit, (uchar*) pModName, pModHdlr, &pModInfo)) != RS_RET_OK) {\n\t\tLogError(0, RS_RET_MODULE_LOAD_ERR_INIT_FAILED,\n\t\t\t\"could not load module '%s', rsyslog error %d\\n\", pPathBuf, iRet);\n\t\tdlclose(pModHdlr);\n\t\tABORT_FINALIZE(RS_RET_MODULE_LOAD_ERR_INIT_FAILED);\n\t}\n\n\tif(bConfLoad) {\n\t\treadyModForCnf(pModInfo, &pNew, &pLast);\n\t\tif(pModInfo->setModCnf != NULL) {\n\t\t\tif(lst != NULL) {\n\t\t\t\tlocalRet = pModInfo->setModCnf(lst);\n\t\t\t\tif(localRet != RS_RET_OK) {\n\t\t\t\t\tLogError(0, localRet,\n\t\t\t\t\t\t\"module '%s', failed processing config parameters\",\n\t\t\t\t\t\tpPathBuf);\n\t\t\t\t\tABORT_FINALIZE(localRet);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpModInfo->bSetModCnfCalled = 1;\n\t\t}\n\t\taddModToCnfList(&pNew, pLast);\n\t}\n\nfinalize_it:\n\tif(load_err_msg != NULL) {\n\t\tcstrDestruct(&load_err_msg);\n\t}\n\tif(pPathBuf != pathBuf) /* used malloc()ed memory? */\n\t\tfree(pPathBuf);\n\tif(iRet != RS_RET_OK)\n\t\tabortCnfUse(&pNew);\n\tfree(pNew); /* is NULL again if properly consumed, else clean up */\n\tpthread_mutex_unlock(&mutObjGlobalOp);\n\tRETiRet;\n}\n\n\n/* the v6+ way of loading modules: process a \"module(...)\" directive.\n * rgerhards, 2012-06-20\n */\nrsRetVal\nmodulesProcessCnf(struct cnfobj *o)\n{\n\tstruct cnfparamvals *pvals;\n\tuchar *cnfModName = NULL;\n\tint typeIdx;\n\tDEFiRet;\n\n\tpvals = nvlstGetParams(o->nvlst, &pblk, NULL);\n\tif(pvals == NULL) {\n\t\tABORT_FINALIZE(RS_RET_ERR);\n\t}\n\tDBGPRINTF(\"modulesProcessCnf params:\\n\");\n\tcnfparamsPrint(&pblk, pvals);\n\ttypeIdx = cnfparamGetIdx(&pblk, \"load\");\n\tif(pvals[typeIdx].bUsed == 0) {\n\t\tLogError(0, RS_RET_CONF_RQRD_PARAM_MISSING, \"module type missing\");\n\t\tABORT_FINALIZE(RS_RET_CONF_RQRD_PARAM_MISSING);\n\t}\n\n\tcnfModName = (uchar*)es_str2cstr(pvals[typeIdx].val.d.estr, NULL);\n\tiRet = Load(cnfModName, 1, o->nvlst);\n\t\nfinalize_it:\n\tfree(cnfModName);\n\tcnfparamvalsDestruct(pvals, &pblk);\n\tRETiRet;\n}\n\n\n/* set the default module load directory. A NULL value may be provided, in\n * which case any previous value is deleted but no new one set. The caller-provided\n * string is duplicated. If it needs to be freed, that's the caller's duty.\n * rgerhards, 2008-03-07\n */\nstatic rsRetVal\nSetModDir(uchar *pszModDir)\n{\n\tDEFiRet;\n\n\tdbgprintf(\"setting default module load directory '%s'\\n\", pszModDir);\n\tif(pModDir != NULL) {\n\t\tfree(pModDir);\n\t}\n\n\tpModDir = (uchar*) strdup((char*)pszModDir);\n\n\tRETiRet;\n}\n\n\n/* Reference-Counting object access: add 1 to the current reference count. Must be\n * called by anyone interested in using a module. -- rgerhards, 20080-03-10\n */\nstatic rsRetVal\nUse(const char *srcFile, modInfo_t *pThis)\n{\n\tDEFiRet;\n\n\tassert(pThis != NULL);\n\tpThis->uRefCnt++;\n\tdbgprintf(\"source file %s requested reference for module '%s', reference count now %u\\n\",\n\t\t  srcFile, pThis->pszName, pThis->uRefCnt);\n\n#\tifdef DEBUG\n\tmodUsrAdd(pThis, srcFile);\n#\tendif\n\n\tRETiRet;\n\n}\n\n\n/* Reference-Counting object access: subract one from the current refcount. Must\n * by called by anyone who no longer needs a module. If count reaches 0, the\n * module is unloaded. -- rgerhards, 20080-03-10\n */\nstatic rsRetVal\nRelease(const char *srcFile, modInfo_t **ppThis)\n{\n\tDEFiRet;\n\tmodInfo_t *pThis;\n\n\tassert(ppThis != NULL);\n\tpThis = *ppThis;\n\tassert(pThis != NULL);\n\tif(pThis->uRefCnt == 0) {\n\t\t/* oops, we are already at 0? */\n\t\tdbgprintf(\"internal error: module '%s' already has a refcount of 0 (released by %s)!\\n\",\n\t\t\t  pThis->pszName, srcFile);\n\t} else {\n\t\t--pThis->uRefCnt;\n\t\tdbgprintf(\"file %s released module '%s', reference count now %u\\n\",\n\t\t\t  srcFile, pThis->pszName, pThis->uRefCnt);\n#\t\tifdef DEBUG\n\t\tmodUsrDel(pThis, srcFile);\n\t\tmodUsrPrint(pThis);\n#\t\tendif\n\t}\n\n\tif(pThis->uRefCnt == 0) {\n\t\t/* we have a zero refcount, so we must unload the module */\n\t\tdbgprintf(\"module '%s' has zero reference count, unloading...\\n\", pThis->pszName);\n\t\tmodUnlinkAndDestroy(&pThis);\n\t\t/* we must NOT do a *ppThis = NULL, because ppThis now points into freed memory!\n\t\t * If in doubt, see obj.c::ReleaseObj() for how we are called.\n\t\t */\n\t}\n\n\tRETiRet;\n\n}\n\n\n/* exit our class\n * rgerhards, 2008-03-11\n */\nBEGINObjClassExit(module, OBJ_IS_LOADABLE_MODULE) /* CHANGE class also in END MACRO! */\nCODESTARTObjClassExit(module)\n\t/* release objects we no longer need */\n\tfree(pModDir);\n#\tifdef DEBUG\n\tmodUsrPrintAll(); /* debug aid - TODO: integrate with debug.c, at least the settings! */\n#\tendif\nENDObjClassExit(module)\n\n\n/* queryInterface function\n * rgerhards, 2008-03-05\n */\nBEGINobjQueryInterface(module)\nCODESTARTobjQueryInterface(module)\n\tif(pIf->ifVersion != moduleCURR_IF_VERSION) { /* check for current version, increment on each change */\n\t\tABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);\n\t}\n\n\t/* ok, we have the right interface, so let's fill it\n\t * Please note that we may also do some backwards-compatibility\n\t * work here (if we can support an older interface version - that,\n\t * of course, also affects the \"if\" above).\n\t */\n\tpIf->GetNxt = GetNxt;\n\tpIf->GetNxtCnfType = GetNxtCnfType;\n\tpIf->GetName = modGetName;\n\tpIf->GetStateName = modGetStateName;\n\tpIf->PrintList = modPrintList;\n\tpIf->FindWithCnfName = FindWithCnfName;\n\tpIf->UnloadAndDestructAll = modUnloadAndDestructAll;\n\tpIf->doModInit = doModInit;\n\tpIf->SetModDir = SetModDir;\n\tpIf->Load = Load;\n\tpIf->Use = Use;\n\tpIf->Release = Release;\nfinalize_it:\nENDobjQueryInterface(module)\n\n\n/* Initialize our class. Must be called as the very first method\n * before anything else is called inside this class.\n * rgerhards, 2008-03-05\n */\nBEGINAbstractObjClassInit(module, 1, OBJ_IS_CORE_MODULE) /* class, version - CHANGE class also in END MACRO! */\n\tuchar *pModPath;\n\n\t/* use any module load path specified in the environment */\n\tif((pModPath = (uchar*) getenv(\"RSYSLOG_MODDIR\")) != NULL) {\n\t\tSetModDir(pModPath);\n\t}\n\n\t/* now check if another module path was set via the command line (-M)\n\t * if so, that overrides the environment. Please note that we must use\n\t * a global setting here because the command line parser can NOT call\n\t * into the module object, because it is not initialized at that point. So\n\t * instead a global setting is changed and we pick it up as soon as we\n\t * initialize -- rgerhards, 2008-04-04\n\t */\n\tif(glblModPath != NULL) {\n\t\tSetModDir(glblModPath);\n\t}\n\n\t/* request objects we use */\nENDObjClassInit(module)\n\n/* vi:set ai:\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2004.0-ddt2obthz5sijsp3bwmmse3bl5yhm3hx/spack-src/runtime/modules.h": "/* modules.h\n *\n * Definition for build-in and plug-ins module handler. This file is the base\n * for all dynamically loadable module support. In theory, in v3 all modules\n * are dynamically loaded, in practice we currently do have a few build-in\n * once. This may become removed.\n *\n * The loader keeps track of what is loaded. For library modules, it is also\n * used to find objects (libraries) and to obtain the queryInterface function\n * for them. A reference count is maintened for libraries, so that they are\n * unloaded only when nobody still accesses them.\n *\n * File begun on 2007-07-22 by RGerhards\n *\n * Copyright 2007-2018 Rainer Gerhards and Adiscon GmbH.\n *\n * This file is part of the rsyslog runtime library.\n *\n * The rsyslog runtime library is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * The rsyslog runtime library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with the rsyslog runtime library.  If not, see <http://www.gnu.org/licenses/>.\n *\n * A copy of the GPL can be found in the file \"COPYING\" in this distribution.\n * A copy of the LGPL can be found in the file \"COPYING.LESSER\" in this distribution.\n */\n#ifndef\tMODULES_H_INCLUDED\n#define\tMODULES_H_INCLUDED 1\n\n#include \"objomsr.h\"\n#include \"rainerscript.h\"\n\n\n/* the following define defines the current version of the module interface.\n * It can be used by any module which want's to simply prevent version conflicts\n * and does not intend to do specific old-version emulations.\n * rgerhards, 2008-03-04\n * version 3 adds modInfo_t ptr to call of modInit -- rgerhards, 2008-03-10\n * version 4 removes needUDPSocket OM callback -- rgerhards, 2008-03-22\n * version 5 changes the way parsing works for input modules. This is\n *           an important change, parseAndSubmitMessage() goes away. Other\n *           module types are not affected. -- rgerhards, 2008-10-09\n * version 6 introduces scoping support (starting with the output\n *           modules) -- rgerhards, 2010-07-27\n */\n#define CURR_MOD_IF_VERSION 6\n\ntypedef enum eModType_ {\n\teMOD_IN = 0,\t/* input module */\n\teMOD_OUT = 1,\t/* output module */\n\teMOD_LIB = 2,\t/* library module */\n\teMOD_PARSER = 3,/* parser module */\n\teMOD_STRGEN = 4,/* strgen module */\n\teMOD_FUNCTION = 5, /*rscript function module*/\n\teMOD_ANY = 6\t/* meta-name for \"any type of module\" -- to be used in function calls */\n} eModType_t;\n\n\n#ifdef DEBUG\ntypedef struct modUsr_s {\n\tstruct modUsr_s *pNext;\n\tchar *pszFile;\n} modUsr_t;\n#endif\n\n\n/* how is this module linked? */\ntypedef enum eModLinkType_ {\n\teMOD_LINK_STATIC,\n\teMOD_LINK_DYNAMIC_UNLOADED,\t/* dynalink module, currently not loaded */\n\teMOD_LINK_DYNAMIC_LOADED,\t/* dynalink module, currently loaded */\n\teMOD_LINK_ALL\t\t\t/* special: all linkage types, e.g. for unload */\n} eModLinkType_t;\n\n/* remember which shared libs we dlopen()-ed */\nstruct dlhandle_s {\n\tuchar\t*pszName;\n\tvoid\t*pModHdlr;\n\tstruct\tdlhandle_s *next;\n};\n\n/* should this module be kept linked? */\ntypedef enum eModKeepType_ {\n\teMOD_NOKEEP,\n\teMOD_KEEP\n} eModKeepType_t;\n\nstruct modInfo_s {\n\tstruct modInfo_s *pPrev;\t/* support for creating a double linked module list */\n\tstruct modInfo_s *pNext;\t/* support for creating a linked module list */\n\tint\t\tiIFVers;\t/* Interface version of module */\n\teModType_t\teType;\t\t/* type of this module */\n\teModLinkType_t\teLinkType;\n\teModKeepType_t\teKeepType;\t/* keep the module dynamically linked on unload */\n\tuchar*\t\tpszName;\t/* printable module name, e.g. for dbgprintf */\n\tuchar*\t\tcnfName;\t/* name to be used in config statements (e.g. 'name=\"omusrmsg\"') */\n\tunsigned\tuRefCnt;\t/* reference count for this module; 0 -> may be unloaded */\n\tsbool\t\tbSetModCnfCalled;/* is setModCnf already called? Needed for built-in modules */\n\t/* functions supported by all types of modules */\n\trsRetVal (*modInit)(int, int*, rsRetVal(**)(void*));\t\t/* initialize the module */\n\t\t/* be sure to support version handshake! */\n\trsRetVal (*modQueryEtryPt)(uchar *name, rsRetVal (**EtryPoint)()); /* query entry point addresses */\n\trsRetVal (*isCompatibleWithFeature)(syslogFeature);\n\trsRetVal (*freeInstance)(void*);/* called before termination or module unload */\n\trsRetVal (*dbgPrintInstInfo)(void*);/* called before termination or module unload */\n\trsRetVal (*tryResume)(void*);/* called to see if module actin can be resumed now */\n\trsRetVal (*modExit)(void);\t\t/* called before termination or module unload */\n\trsRetVal (*modGetID)(void **);\t\t/* get its unique ID from module */\n\trsRetVal (*doHUP)(void *);\t\t/* HUP handler, action level */\n\trsRetVal (*doHUPWrkr)(void *);\t\t/* HUP handler, wrkr instance level */\n\t/* v2 config system specific */\n\trsRetVal (*beginCnfLoad)(void*newCnf, rsconf_t *pConf);\n\trsRetVal (*setModCnf)(struct nvlst *lst);\n\trsRetVal (*endCnfLoad)(void*Cnf);\n\trsRetVal (*checkCnf)(void*Cnf);\n\trsRetVal (*activateCnfPrePrivDrop)(void*Cnf);\n\trsRetVal (*activateCnf)(void*Cnf);\t/* make provided config the running conf */\n\trsRetVal (*freeCnf)(void*Cnf);\n\t/* end v2 config system specific */\n\tunion\t{\n\t\tstruct {/* data for input modules */\n/* TODO: remove? */rsRetVal (*willRun)(void); \t\t/* check if the current config will be able to run*/\n\t\t\trsRetVal (*runInput)(thrdInfo_t*);\t/* function to gather input and submit to queue */\n\t\t\trsRetVal (*afterRun)(thrdInfo_t*);\t/* function to gather input and submit to queue */\n\t\t\trsRetVal (*newInpInst)(struct nvlst *lst);\n\t\t\tint bCanRun;\t/* cached value of whether willRun() succeeded */\n\t\t} im;\n\t\tstruct {/* data for output modules */\n\t\t\t/* below: perform the configured action\n\t\t\t */\n\t\t\trsRetVal (*beginTransaction)(void*);\n\t\t\trsRetVal (*commitTransaction)(void *const, actWrkrIParams_t *const, const unsigned);\n\t\t\trsRetVal (*doAction)(void** params, void*pWrkrData);\n\t\t\trsRetVal (*endTransaction)(void*);\n\t\t\trsRetVal (*parseSelectorAct)(uchar**, void**,omodStringRequest_t**);\n\t\t\trsRetVal (*newActInst)(uchar *modName, struct nvlst *lst, void **, omodStringRequest_t **);\n\t\t\trsRetVal (*SetShutdownImmdtPtr)(void *pData, void *pPtr);\n\t\t\trsRetVal (*createWrkrInstance)(void*ppWrkrData, void*pData);\n\t\t\trsRetVal (*freeWrkrInstance)(void*pWrkrData);\n\t\t\tsbool supportsTX;\t/* set if the module supports transactions */\n\t\t} om;\n\t\tstruct { /* data for library modules */\n\t\t    \tchar dummy;\n\t\t} lm;\n\t\tstruct { /* data for parser modules */\n\t\t\trsRetVal (*newParserInst)(struct nvlst *lst, void *pinst);\n\t\t\trsRetVal (*freeParserInst)(void *pinst);\n\t\t\trsRetVal (*parse2)(instanceConf_t *const, smsg_t*);\n\t\t\trsRetVal (*parse)(smsg_t*);\n\t\t} pm;\n\t\tstruct { /* data for strgen modules */\n\t\t\trsRetVal (*strgen)(const smsg_t*const, actWrkrIParams_t *const iparam);\n\t\t} sm;\n\t\tstruct { /* data for rscript modules */\n\t\t\trsRetVal (*getFunctArray)(int *const, struct scriptFunct**);\n\t\t} fm;\n\t} mod;\n\tvoid *pModHdlr; /* handler to the dynamic library holding the module */\n#\tifdef DEBUG\n\t/* we add some home-grown support to track our users (and detect who does not free us). */\n\tmodUsr_t *pModUsrRoot;\n#\tendif\n};\n\n\n/* interfaces */\nBEGINinterface(module) /* name must also be changed in ENDinterface macro! */\n\tmodInfo_t *(*GetNxt)(modInfo_t *pThis);\n\tcfgmodules_etry_t *(*GetNxtCnfType)(rsconf_t *cnf, cfgmodules_etry_t *pThis, eModType_t rqtdType);\n\tuchar *(*GetName)(modInfo_t *pThis);\n\tuchar *(*GetStateName)(modInfo_t *pThis);\n\trsRetVal (*Use)(const char *srcFile, modInfo_t *pThis);\n\t/**< must be called before a module is used (ref counting) */\n\trsRetVal (*Release)(const char *srcFile, modInfo_t **ppThis);\t/**< release a module (ref counting) */\n\tvoid (*PrintList)(void);\n\trsRetVal (*UnloadAndDestructAll)(eModLinkType_t modLinkTypesToUnload);\n\trsRetVal (*doModInit)(rsRetVal (*modInit)(), uchar *name, void *pModHdlr, modInfo_t **pNew);\n\trsRetVal (*Load)(uchar *name, sbool bConfLoad, struct nvlst *lst);\n\trsRetVal (*SetModDir)(uchar *name);\n\tmodInfo_t *(*FindWithCnfName)(rsconf_t *cnf, uchar *name, eModType_t rqtdType); /* added v3, 2011-07-19 */\nENDinterface(module)\n#define moduleCURR_IF_VERSION 5 /* increment whenever you change the interface structure! */\n/* Changes:\n * v2\n * - added param bCondLoad to Load call - 2011-04-27\n * - removed GetNxtType, added GetNxtCnfType - 2011-04-27\n * v3 (see above)\n * v4\n * - added third parameter to Load() - 2012-06-20\n */\n\n/* prototypes */\nPROTOTYPEObj(module);\n/* in v6, we go back to in-core static link for core objects, at least those\n * that are not called from plugins.\n * ... and we need to know that none of the module functions are called from plugins!\n * rgerhards, 2012-09-24\n */\nrsRetVal modulesProcessCnf(struct cnfobj *o);\nuchar *modGetName(modInfo_t *pThis);\nrsRetVal ATTR_NONNULL(1) addModToCnfList(cfgmodules_etry_t **pNew, cfgmodules_etry_t *pLast);\nrsRetVal readyModForCnf(modInfo_t *pThis, cfgmodules_etry_t **ppNew, cfgmodules_etry_t **ppLast);\nvoid modDoHUP(void);\n\n#endif /* #ifndef MODULES_H_INCLUDED */\n",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2004.0-ddt2obthz5sijsp3bwmmse3bl5yhm3hx/spack-src/runtime/rsyslog.h": "/* This is the header file for the rsyslog runtime. It must be included\n * if someone intends to use the runtime.\n *\n * Begun 2005-09-15 RGerhards\n *\n * Copyright (C) 2005-2019 by Rainer Gerhards and Adiscon GmbH\n *\n * This file is part of the rsyslog runtime library.\n *\n * The rsyslog runtime library is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * The rsyslog runtime library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with the rsyslog runtime library.  If not, see <http://www.gnu.org/licenses/>.\n *\n * A copy of the GPL can be found in the file \"COPYING\" in this distribution.\n * A copy of the LGPL can be found in the file \"COPYING.LESSER\" in this distribution.\n */\n#ifndef INCLUDED_RSYSLOG_H\n#define INCLUDED_RSYSLOG_H\n#ifdef __GNUC__\n\t#pragma GCC diagnostic ignored \"-Wdeclaration-after-statement\"\n\t#pragma GCC diagnostic ignored \"-Wredundant-decls\" // TODO: remove!\n\t#pragma GCC diagnostic ignored \"-Wstrict-prototypes\" // TODO: remove!\n\t#pragma GCC diagnostic ignored \"-Wswitch-default\" // TODO: remove!\n\t#if __GNUC__ >= 8\n\t\t/* GCC, starting at least with version 8, is now really overdoing with it's\n\t\t * warning messages. We turn those off that either cause an enormous amount\n\t\t * of false positives or flag perfectly legal code as problematic.\n\t\t */\n\t\t/* That one causes warnings when we use variable buffers for error\n\t\t * messages which may be truncated in the very unlikely case of all\n\t\t * vars using max value. If going over the max size, the engine will\n\t\t * most likely truncate due to max message size anyhow. Also, sizing\n\t\t * the buffers for max-max message size is a wast of (stack) memory.\n\t\t */\n\t\t#pragma GCC diagnostic ignored \"-Wformat-truncation\"\n\t\t/* The next one flags variable initializations within out exception handling\n\t\t * (iRet system) as problematic, even though variables are not used in those\n\t\t * cases. This would be a good diagnostic if gcc would actually check that\n\t\t * a variable is used uninitialized. Unfortunately it does not do that. But\n\t\t * the static analyzers we use as part of CI do, so we are covered in any\n\t\t * case.\n\t\t * Unfortunately ignoring this diagnostic leads to two more info lines\n\t\t * being emitted where nobody knows what the mean and why they appear :-(\n\t\t */\n\t\t#pragma GCC diagnostic ignored \"-Wjump-misses-init\"\n\t#endif /* if __GNUC__ >= 8 */\n\n\t/* define a couple of attributes to improve cross-platform builds */\n\t#if __GNUC__ > 6\n\t\t#define CASE_FALLTHROUGH __attribute__((fallthrough));\n\t#else\n\t\t#define CASE_FALLTHROUGH\n\t#endif\n\n\t#define ATTR_NORETURN __attribute__ ((noreturn))\n\t#define ATTR_UNUSED __attribute__((unused))\n\t#define ATTR_NONNULL(...) __attribute__((nonnull(__VA_ARGS__)))\n\n#else /* ifdef __GNUC__ */\n\n\t#define CASE_FALLTHROUGH\n\t#define ATTR_NORETURN\n\t#define ATTR_UNUSED\n\t#define ATTR_NONNULL(...)\n\n#endif /* ifdef __GNUC__ */\n\n#if defined(_AIX)\n#include <sys/select.h>\n/* AIXPORT : start*/\n#define SRC_FD          13\n#define SRCMSG          (sizeof(srcpacket))\n#endif\n/* src end */\n\n#include <pthread.h>\n#include \"typedefs.h\"\n\n#if defined(__GNUC__)\n\t#define PRAGMA_INGORE_Wswitch_enum\t_Pragma(\"GCC diagnostic ignored \\\"-Wswitch-enum\\\"\")\n\t#define PRAGMA_IGNORE_Wempty_body\t_Pragma(\"GCC diagnostic ignored \\\"-Wempty-body\\\"\")\n\t#define PRAGMA_IGNORE_Wsign_compare\t_Pragma(\"GCC diagnostic ignored \\\"-Wsign-compare\\\"\")\n\t#define PRAGMA_IGNORE_Wpragmas\t\t_Pragma(\"GCC diagnostic ignored \\\"-Wpragmas\\\"\")\n\t#define PRAGMA_IGNORE_Wmissing_noreturn _Pragma(\"GCC diagnostic ignored \\\"-Wmissing-noreturn\\\"\")\n\t#define PRAGMA_IGNORE_Wexpansion_to_defined \\\n\t\t\t\t\t\t_Pragma(\"GCC diagnostic ignored \\\"-Wexpansion-to-defined\\\"\")\n\t#define PRAGMA_IGNORE_Wunknown_warning_option \\\n\t\t\t\t\t\t_Pragma(\"GCC diagnostic ignored \\\"-Wunknown-warning-option\\\"\")\n\t#define PRAGMA_IGNORE_Wunknown_attribute \\\n\t\t\t\t\t\t_Pragma(\"GCC diagnostic ignored \\\"-Wunknown-attribute\\\"\")\n\t#define PRAGMA_IGNORE_Wformat_nonliteral \\\n\t\t\t\t\t\t_Pragma(\"GCC diagnostic ignored \\\"-Wformat-nonliteral\\\"\")\n\t#define PRAGMA_IGNORE_Wdeprecated_declarations \\\n\t\t\t\t\t\t_Pragma(\"GCC diagnostic ignored \\\"-Wdeprecated-declarations\\\"\")\n\t#define PRAGMA_DIAGNOSTIC_PUSH\t\t_Pragma(\"GCC diagnostic push\")\n\t#define PRAGMA_DIAGNOSTIC_POP\t\t_Pragma(\"GCC diagnostic pop\")\n#else\n\t#define PRAGMA_INGORE_Wswitch_enum\n\t#define PRAGMA_IGNORE_Wsign_compare\n\t#define PRAGMA_IGNORE_Wformat_nonliteral\n\t#define PRAGMA_IGNORE_Wpragmas\n\t#define PRAGMA_IGNORE_Wmissing_noreturn\n\t#define PRAGMA_IGNORE_Wempty_body\n\t#define PRAGMA_IGNORE_Wdeprecated_declarations\n\t#define PRAGMA_IGNORE_Wexpansion_to_defined\n\t#define PRAGMA_IGNORE_Wunknown_attribute\n\t#define PRAGMA_IGNORE_Wunknown_warning_option\n\t#define PRAGMA_DIAGNOSTIC_PUSH\n\t#define PRAGMA_DIAGNOSTIC_POP\n#endif\n\n/* ############################################################# *\n * #                 Some constant values                      # *\n * ############################################################# */\n#define CONST_LEN_TIMESTAMP_3164 15 \t\t/* number of chars (excluding \\0!) in a RFC3164 timestamp */\n#define CONST_LEN_TIMESTAMP_3339 32 \t\t/* number of chars (excluding \\0!) in a RFC3339 timestamp */\n\n#define CONST_LEN_CEE_COOKIE 5\n#define CONST_CEE_COOKIE \"@cee:\"\n\n/* ############################################################# *\n * #                    Config Settings                        # *\n * ############################################################# */\n#define RS_STRINGBUF_ALLOC_INCREMENT\t128\n/* MAXSIZE are absolute maxima, while BUFSIZE are just values after which\n * processing is more time-intense. The BUFSIZE params currently add their\n * value to the fixed size of the message object.\n */\n#define CONF_TAG_MAXSIZE\t\t512\t/* a value that is deemed far too large for any valid TAG */\n#define CONF_HOSTNAME_MAXSIZE\t\t512\t/* a value that is deemed far too large for any valid HOSTNAME */\n#define CONF_RAWMSG_BUFSIZE\t\t101\n#define CONF_TAG_BUFSIZE\t\t32\n#define CONF_PROGNAME_BUFSIZE\t\t16\n#define CONF_HOSTNAME_BUFSIZE\t\t32\n#define CONF_PROP_BUFSIZE\t\t16\t/* should be close to sizeof(ptr) or lighly above it */\n#define CONF_IPARAMS_BUFSIZE\t\t16\t/* initial size of iparams array in wti (is automatically extended) */\n#define\tCONF_MIN_SIZE_FOR_COMPRESS\t60 \t/* config param: minimum message size to try compression. The smaller\n\t * the message, the less likely is any compression gain. We check for\n\t * gain before we submit the message. But to do so we still need to\n\t * do the (costly) compress() call. The following setting sets a size\n\t * for which no call to compress() is done at all. This may result in\n\t * a few more bytes being transmited but better overall performance.\n\t * Note: I have not yet checked the minimum UDP packet size. It might be\n\t * that we do not save anything by compressing very small messages, because\n\t * UDP might need to pad ;)\n\t * rgerhards, 2006-11-30\n\t */\n\n#define CONF_OMOD_NUMSTRINGS_MAXSIZE\t5\t/* cache for pointers to output module buffer pointers. All\n\t * rsyslog-provided plugins do NOT need more than five buffers. If\n\t * more are needed (future developments, third-parties), rsyslog\n\t * must be recompiled with a larger parameter. Hardcoding this\n\t * saves us some overhead, both in runtime in code complexity. As\n\t * it is doubtful if ever more than 3 parameters are needed, the\n\t * approach taken here is considered appropriate.\n\t * rgerhards, 2010-06-24\n\t */\n#define CONF_NUM_MULTISUB\t\t1024\t/* default number of messages per multisub structure */\n\n/* ############################################################# *\n * #                  End Config Settings                      # *\n * ############################################################# */\n\n/* make sure we uses consistent macros, no matter what the\n * platform gives us.\n */\n#undef LOG_NFACILITIES /* may be system defined, override */\n#define LOG_NFACILITIES 24+1 /* plus one for our special \"invld\" facility! */\n#define LOG_MAXPRI 191\t/* highest supported valid PRI value --> RFC3164, RFC5424 */\n#undef LOG_MAKEPRI\n#define LOG_PRI_INVLD\t(LOG_INVLD|LOG_DEBUG)\n/* PRI is invalid --> special \"invld.=debug\" PRI code (rsyslog-specific) */\n\n#define\tLOG_EMERG\t0\t/* system is unusable */\n#define\tLOG_ALERT\t1\t/* action must be taken immediately */\n#define\tLOG_CRIT\t2\t/* critical conditions */\n#define\tLOG_ERR\t\t3\t/* error conditions */\n#define\tLOG_WARNING\t4\t/* warning conditions */\n#define\tLOG_NOTICE\t5\t/* normal but significant condition */\n#define\tLOG_INFO\t6\t/* informational */\n#define\tLOG_DEBUG\t7\t/* debug-level messages */\n\n#define\tLOG_KERN\t(0<<3)\t/* kernel messages */\n#define\tLOG_USER\t(1<<3)\t/* random user-level messages */\n#define\tLOG_MAIL\t(2<<3)\t/* mail system */\n#define\tLOG_DAEMON\t(3<<3)\t/* system daemons */\n#define\tLOG_AUTH\t(4<<3)\t/* security/authorization messages */\n#define\tLOG_SYSLOG\t(5<<3)\t/* messages generated internally by syslogd */\n#define\tLOG_LPR\t\t(6<<3)\t/* line printer subsystem */\n#define\tLOG_NEWS\t(7<<3)\t/* network news subsystem */\n#define\tLOG_UUCP\t(8<<3)\t/* UUCP subsystem */\n#if !defined(LOG_CRON)\n#define\tLOG_CRON\t(9<<3)\t/* clock daemon */\n#endif\n#define\tLOG_AUTHPRIV\t(10<<3)\t/* security/authorization messages (private) */\n#define\tLOG_FTP\t\t(11<<3)\t/* ftp daemon */\n#if defined(_AIX)\t\t/* AIXPORT : These are necessary for AIX */\n#define\tLOG_ASO\t\t(12<<3) /* Active System Optimizer. Reserved for internal use */\n#define\tLOG_CAA\t\t(15<<3) /* Cluster aware AIX subsystem */\n#endif\n#define\tLOG_LOCAL0\t(16<<3)\t/* reserved for local use */\n#define\tLOG_LOCAL1\t(17<<3)\t/* reserved for local use */\n#define\tLOG_LOCAL2\t(18<<3)\t/* reserved for local use */\n#define\tLOG_LOCAL3\t(19<<3)\t/* reserved for local use */\n#define\tLOG_LOCAL4\t(20<<3)\t/* reserved for local use */\n#define\tLOG_LOCAL5\t(21<<3)\t/* reserved for local use */\n#define\tLOG_LOCAL6\t(22<<3)\t/* reserved for local use */\n#define\tLOG_LOCAL7\t(23<<3)\t/* reserved for local use */\n#define LOG_FAC_INVLD   24\n#define\tLOG_INVLD\t(LOG_FAC_INVLD<<3)\t/* invalid facility/PRI code */\n\n/* we need to evaluate our argument only once, as otherwise we may\n * have side-effects (this was seen in some version).\n * Note: I know that \"static inline\" is not the right thing from a C99\n * PoV, but some environments treat, even in C99 mode, compile\n * non-static inline into the source even if not defined as \"extern\". This\n * obviously results in linker errors. Using \"static inline\" as below together\n * with \"__attribute__((unused))\" works in all cases. Note also that we\n * cannot work around this in pri2fac, as we would otherwise need to evaluate\n * pri more than once.\n */\nstatic inline syslog_pri_t __attribute__((unused))\npri2fac(const syslog_pri_t pri)\n{\n\tunsigned fac = pri >> 3;\n\treturn (fac > 23) ? LOG_FAC_INVLD : fac;\n}\n#define pri2sev(pri) ((pri) & 0x07)\n\n/* the rsyslog core provides information about present feature to plugins\n * asking it. Below are feature-test macros which must be used to query\n * features. Note that this must be powers of two, so that multiple queries\n * can be combined. -- rgerhards, 2009-04-27\n */\n#define CORE_FEATURE_BATCHING\t1\n/*#define CORE_FEATURE_whatever 2 ... and so on ... */\n\n#ifndef _PATH_CONSOLE\n#define _PATH_CONSOLE\t\"/dev/console\"\n#endif\n\n\n/* The error codes below are orginally \"borrowed\" from\n * liblogging. As such, we reserve values up to -2999\n * just in case we need to borrow something more ;)\n*/\nenum rsRetVal_\t\t\t\t/** return value. All methods return this if not specified otherwise */\n{\n\t/* the first two define are for errmsg.logError(), so that we can use the rsRetVal\n\t * as an rsyslog error code. -- rgerhards, 20080-06-27\n\t */\n\tRS_RET_NO_ERRCODE = -1,\t\t/**< RESERVED for NO_ERRCODE errmsg.logError status name */\n\tRS_RET_INCLUDE_ERRNO = 1073741824, /* 2**30  - do NOT use error codes above this! */\n\t/* begin regular error codes */\n\tRS_RET_NOT_IMPLEMENTED = -7,\t/**< implementation is missing (probably internal error or lazyness ;)) */\n\tRS_RET_OUT_OF_MEMORY = -6,\t/**< memory allocation failed */\n\tRS_RET_PROVIDED_BUFFER_TOO_SMALL = -50, /*< the caller provided a buffer, but the called function sees\n\t\t\t\t\t\t  the size of this buffer is too small - operation not carried out */\n\tRS_RET_FILE_TRUNCATED = -51,\t/**< (input) file was truncated, not an error but a status */\n\tRS_RET_TRUE = -3,\t\t/**< to indicate a true state (can be used as TRUE, legacy) */\n\tRS_RET_FALSE = -2,\t\t/**< to indicate a false state (can be used as FALSE, legacy) */\n\tRS_RET_NO_IRET = -8,\t/**< This is a trick for the debuging system - it means no iRet is provided  */\n\tRS_RET_VALIDATION_RUN = -9,\t/**< indicates a (config) validation run, processing not carried out */\n\tRS_RET_ERR = -3000,\t/**< generic failure */\n\tRS_TRUNCAT_TOO_LARGE = -3001, /**< truncation operation where too many chars should be truncated */\n\tRS_RET_FOUND_AT_STRING_END = -3002, /**< some value found, but at the last pos of string */\n\tRS_RET_NOT_FOUND = -3003, /**< some requested value not found */\n\tRS_RET_MISSING_TRAIL_QUOTE = -3004, /**< an expected trailing quote is missing */\n\tRS_RET_NO_DIGIT = -3005,\t/**< an digit was expected, but none found (mostly parsing) */\n\tRS_RET_NO_MORE_DATA = -3006,\t/**< insufficient data, e.g. end of string during parsing */\n\tRS_RET_INVALID_IP = -3007,\t/**< invalid ip found where valid was expected */\n\tRS_RET_OBJ_CREATION_FAILED = - 3008, /**< the creation of an object failed (no details available) */\n\tRS_RET_INOTIFY_INIT_FAILED = - 3009,\n\t/**< the initialization of an inotify instance failed (no details available) */\n\tRS_RET_FEN_INIT_FAILED = - 3010, /**< the initialization of a fen instance failed (no details available) */\n\tRS_RET_PARAM_ERROR = -1000,\t/**< invalid parameter in call to function */\n\tRS_RET_MISSING_INTERFACE = -1001,/**< interface version mismatch, required missing */\n\tRS_RET_INVALID_CORE_INTERFACE = -1002,/**< interface provided by host invalid, can not be used */\n\tRS_RET_ENTRY_POINT_NOT_FOUND = -1003,/**< a requested entry point was not found */\n\tRS_RET_MODULE_ENTRY_POINT_NOT_FOUND = -1004,/**< a entry point requested from a module was not present in it */\n\tRS_RET_OBJ_NOT_AVAILABLE = -1005,\n\t/**< something could not be completed because the required object is not available*/\n\tRS_RET_LOAD_ERROR = -1006,/**< we had an error loading the object/interface and can not continue */\n\tRS_RET_MODULE_STILL_REFERENCED = -1007,\n\t/**< module could not be unloaded because it still is referenced by someone */\n\tRS_RET_OBJ_UNKNOWN = -1008,/**< object is unknown where required */\n\tRS_RET_OBJ_NOT_REGISTERED = -1009,/**< tried to unregister an object that is not registered */\n\t/* return states for config file processing */\n\tRS_RET_NONE = -2000,\t\t/**< some value is not available - not necessarily an error */\n\tRS_RET_CONFLINE_UNPROCESSED = -2001,/**< config line was not processed, pass to other module */\n\tRS_RET_DISCARDMSG = -2002,\t/**< discard message (no error state, processing request!) */\n\tRS_RET_INCOMPATIBLE = -2003,\t/**< function not compatible with requested feature */\n\tRS_RET_NOENTRY = -2004,\t\t/**< do not create an entry for (whatever) - not necessary an error */\n\tRS_RET_NO_SQL_STRING = -2005,\t/**< string is not suitable for use as SQL */\n\tRS_RET_DISABLE_ACTION = -2006,  /**< action requests that it be disabled */\n\tRS_RET_SUSPENDED = -2007,  /**< something was suspended, not neccesarily an error */\n\tRS_RET_RQD_TPLOPT_MISSING = -2008,/**< a required template option is missing */\n\tRS_RET_INVALID_VALUE = -2009,/**< some value is invalid (e.g. user-supplied data) */\n\tRS_RET_INVALID_INT = -2010,/**< invalid integer */\n\tRS_RET_INVALID_CMD = -2011,/**< invalid command */\n\tRS_RET_VAL_OUT_OF_RANGE = -2012, /**< value out of range */\n\tRS_RET_FOPEN_FAILURE = -2013,\t/**< failure during fopen, for example file not found - see errno */\n\tRS_RET_END_OF_LINKEDLIST = -2014,\t/**< end of linked list, not an error, but a status */\n\tRS_RET_CHAIN_NOT_PERMITTED = -2015, /**< chaining (e.g. of config command handlers) not permitted */\n\tRS_RET_INVALID_PARAMS = -2016,/**< supplied parameters are invalid */\n\tRS_RET_EMPTY_LIST = -2017, /**< linked list is empty */\n\tRS_RET_FINISHED = -2018, /**< some opertion is finished, not an error state */\n\tRS_RET_INVALID_SOURCE = -2019, /**< source (address) invalid for some reason */\n\tRS_RET_ADDRESS_UNKNOWN = -2020, /**< an address is unknown - not necessarily an error */\n\tRS_RET_MALICIOUS_ENTITY = -2021, /**< there is an malicious entity involved */\n\tRS_RET_NO_KERNEL_LOGSRC = -2022, /**< no source for kernel logs can be obtained */\n\tRS_RET_TCP_SEND_ERROR = -2023, /**< error during TCP send process */\n\tRS_RET_GSS_SEND_ERROR = -2024, /**< error during GSS (via TCP) send process */\n\tRS_RET_TCP_SOCKCREATE_ERR = -2025, /**< error during creation of TCP socket */\n\tRS_RET_GSS_SENDINIT_ERROR = -2024, /**< error during GSS (via TCP) send initialization process */\n\tRS_RET_EOF = -2026, /**< end of file reached, not necessarily an error */\n\tRS_RET_IO_ERROR = -2027, /**< some kind of IO error happened */\n\tRS_RET_INVALID_OID = -2028, /**< invalid object ID */\n\tRS_RET_INVALID_HEADER = -2029, /**< invalid header */\n\tRS_RET_INVALID_HEADER_VERS = -2030, /**< invalid header version */\n\tRS_RET_INVALID_DELIMITER = -2031, /**< invalid delimiter, e.g. between params */\n\tRS_RET_INVALID_PROPFRAME = -2032, /**< invalid framing in serialized property */\n\tRS_RET_NO_PROPLINE = -2033, /**< line is not a property line */\n\tRS_RET_INVALID_TRAILER = -2034, /**< invalid trailer */\n\tRS_RET_VALUE_TOO_LOW = -2035, /**< a provided value is too low */\n\tRS_RET_FILE_PREFIX_MISSING = -2036, /**< a required file prefix (parameter?) is missing */\n\tRS_RET_INVALID_HEADER_RECTYPE = -2037, /**< invalid record type in header or invalid header */\n\tRS_RET_QTYPE_MISMATCH = -2038, /**< different qType when reading back a property type */\n\tRS_RET_NO_FILE_ACCESS = -2039, /**< covers EACCES error on file open() */\n\tRS_RET_FILE_NOT_FOUND = -2040, /**< file not found */\n\tRS_RET_TIMED_OUT = -2041, /**< timeout occured (not necessarily an error) */\n\tRS_RET_QSIZE_ZERO = -2042, /**< queue size is zero where this is not supported */\n\tRS_RET_ALREADY_STARTING = -2043, /**< something (a thread?) is already starting - not necessarily an error */\n\tRS_RET_NO_MORE_THREADS = -2044, /**< no more threads available, not necessarily an error */\n\tRS_RET_NO_FILEPREFIX = -2045, /**< file prefix is not specified where one is needed */\n\tRS_RET_CONFIG_ERROR = -2046, /**< there is a problem with the user-provided config settigs */\n\tRS_RET_OUT_OF_DESRIPTORS = -2047, /**< a descriptor table's space has been exhausted */\n\tRS_RET_NO_DRIVERS = -2048, /**< a required drivers missing */\n\tRS_RET_NO_DRIVERNAME = -2049, /**< driver name missing where one was required */\n\tRS_RET_EOS = -2050, /**< end of stream (of whatever) */\n\tRS_RET_SYNTAX_ERROR = -2051, /**< syntax error, eg. during parsing */\n\tRS_RET_INVALID_OCTAL_DIGIT = -2052, /**< invalid octal digit during parsing */\n\tRS_RET_INVALID_HEX_DIGIT = -2053, /**< invalid hex digit during parsing */\n\tRS_RET_INTERFACE_NOT_SUPPORTED = -2054, /**< interface not supported */\n\tRS_RET_OUT_OF_STACKSPACE = -2055, /**< a stack data structure is exhausted and can not be grown */\n\tRS_RET_STACK_EMPTY = -2056, /**< a pop was requested on a stack, but the stack was already empty */\n\tRS_RET_INVALID_VMOP = -2057, /**< invalid virtual machine instruction */\n\tRS_RET_INVALID_VAR = -2058, /**< a var or its content is unsuitable, eg. VARTYPE_NONE */\n\tRS_RET_INVALID_NUMBER = -2059, /**< number invalid during parsing */\n\tRS_RET_NOT_A_NUMBER = -2060, /**< e.g. conversion impossible because the string is not a number */\n\tRS_RET_OBJ_ALREADY_REGISTERED = -2061, /**< object (name) is already registered */\n\tRS_RET_OBJ_REGISTRY_OUT_OF_SPACE = -2062, /**< the object registry has run out of space */\n\tRS_RET_HOST_NOT_PERMITTED = -2063, /**< a host is not permitted to perform an action it requested */\n\tRS_RET_MODULE_LOAD_ERR = -2064, /**< module could not be loaded */\n\tRS_RET_MODULE_LOAD_ERR_PATHLEN = -2065, /**< module could not be loaded - path to long */\n\tRS_RET_MODULE_LOAD_ERR_DLOPEN = -2066, /**< module could not be loaded - problem in dlopen() */\n\tRS_RET_MODULE_LOAD_ERR_NO_INIT = -2067, /**< module could not be loaded - init() missing */\n\tRS_RET_MODULE_LOAD_ERR_INIT_FAILED = -2068, /**< module could not be loaded - init() failed */\n\tRS_RET_NO_SOCKET = -2069, /**< socket could not be obtained or was not provided */\n\tRS_RET_SMTP_ERROR = -2070, /**< error during SMTP transation */\n\tRS_RET_MAIL_NO_TO = -2071, /**< recipient for mail destination is missing */\n\tRS_RET_MAIL_NO_FROM = -2072, /**< sender for mail destination is missing */\n\tRS_RET_INVALID_PRI = -2073, /**< PRI value is invalid */\n\tRS_RET_MALICIOUS_HNAME = -2074, /**< remote peer is trying malicious things with its hostname */\n\tRS_RET_INVALID_HNAME = -2075, /**< remote peer's hostname invalid or unobtainable */\n\tRS_RET_INVALID_PORT = -2076, /**< invalid port value */\n\tRS_RET_COULD_NOT_BIND = -2077, /**< could not bind socket, defunct */\n\tRS_RET_GNUTLS_ERR = -2078, /**< (unexpected) error in GnuTLS call */\n\tRS_RET_MAX_SESS_REACHED = -2079, /**< max nbr of sessions reached, can not create more */\n\tRS_RET_MAX_LSTN_REACHED = -2080, /**< max nbr of listeners reached, can not create more */\n\tRS_RET_INVALID_DRVR_MODE = -2081, /**< tried to set mode not supported by driver */\n\tRS_RET_DRVRNAME_TOO_LONG = -2082, /**< driver name too long - should never happen */\n\tRS_RET_TLS_HANDSHAKE_ERR = -2083, /**< TLS handshake failed */\n\tRS_RET_TLS_CERT_ERR = -2084, /**< generic TLS certificate error */\n\tRS_RET_TLS_NO_CERT = -2085, /**< no TLS certificate available where one was expected */\n\tRS_RET_VALUE_NOT_SUPPORTED = -2086, /**< a provided value is not supported */\n\tRS_RET_VALUE_NOT_IN_THIS_MODE = -2087, /**< a provided value is invalid for the curret mode */\n\tRS_RET_INVALID_FINGERPRINT = -2088, /**< a fingerprint is not valid for this use case */\n\tRS_RET_CONNECTION_ABORTREQ = -2089, /**< connection was abort requested due to previous error */\n\tRS_RET_CERT_INVALID = -2090, /**< a x509 certificate failed validation */\n\tRS_RET_CERT_INVALID_DN = -2091, /**< distinguised name in x509 certificate is invalid (e.g. wrong escaping) */\n\tRS_RET_CERT_EXPIRED = -2092, /**< we are past a x.509 cert's expiration time */\n\tRS_RET_CERT_NOT_YET_ACTIVE = -2094, /**< x.509 cert's activation time not yet reached */\n\tRS_RET_SYS_ERR = -2095, /**< system error occured (e.g. time() returned -1, quite unexpected) */\n\tRS_RET_FILE_NO_STAT = -2096, /**< can not stat() a file */\n\tRS_RET_FILE_TOO_LARGE = -2097, /**< a file is larger than permitted */\n\tRS_RET_INVALID_WILDCARD = -2098, /**< a wildcard entry is invalid */\n\tRS_RET_CLOSED = -2099, /**< connection was closed */\n\tRS_RET_RETRY = -2100, /**< call should be retried (e.g. EGAIN on recv) */\n\tRS_RET_GSS_ERR = -2101, /**< generic error occured in GSSAPI subsystem */\n\tRS_RET_CERTLESS = -2102, /**< state: we run without machine cert (this may be OK) */\n\tRS_RET_NO_ACTIONS = -2103, /**< no active actions are configured (no output will be created) */\n\tRS_RET_CONF_FILE_NOT_FOUND = -2104, /**< config file or directory not found */\n\tRS_RET_QUEUE_FULL = -2105, /**< queue is full, operation could not be completed */\n\tRS_RET_ACCEPT_ERR = -2106, /**< error during accept() system call */\n\tRS_RET_INVLD_TIME = -2107, /**< invalid timestamp (e.g. could not be parsed) */\n\tRS_RET_NO_ZIP = -2108, /**< ZIP functionality is not present */\n\tRS_RET_CODE_ERR = -2109, /**< program code (internal) error */\n\tRS_RET_FUNC_NO_LPAREN = -2110, /**< left parenthesis missing after function call (rainerscript) */\n\tRS_RET_FUNC_MISSING_EXPR = -2111, /**< no expression after comma in function call (rainerscript) */\n\tRS_RET_INVLD_NBR_ARGUMENTS = -2112, /**< invalid number of arguments for function call (rainerscript) */\n\tRS_RET_INVLD_FUNC = -2113, /**< invalid function name for function call (rainerscript) */\n\tRS_RET_DUP_FUNC_NAME = -2114, /**< duplicate function name (rainerscript) */\n\tRS_RET_UNKNW_FUNC = -2115, /**< unkown function name (rainerscript) */\n\tRS_RET_ERR_RLIM_NOFILE = -2116, /**< error setting max. nbr open files process limit */\n\tRS_RET_ERR_CREAT_PIPE = -2117, /**< error during pipe creation */\n\tRS_RET_ERR_FORK = -2118, /**< error during fork() */\n\tRS_RET_ERR_WRITE_PIPE = -2119, /**< error writing to pipe */\n\tRS_RET_RSCORE_TOO_OLD = -2120, /**< rsyslog core is too old for ... (eg this plugin) */\n\tRS_RET_DEFER_COMMIT = -2121, /**< output plugin status: not yet committed (an OK state!) */\n\tRS_RET_PREVIOUS_COMMITTED = -2122, /**< output plugin status: previous record was committed (an OK state!) */\n\tRS_RET_ACTION_FAILED = -2123, /**< action failed and is now suspended */\n\tRS_RET_NON_SIZELIMITCMD = -2125, /**< size limit for file defined, but no size limit command given */\n\tRS_RET_SIZELIMITCMD_DIDNT_RESOLVE = -2126, /**< size limit command did not resolve situation */\n\tRS_RET_STREAM_DISABLED = -2127, /**< a file has been disabled (e.g. by size limit restriction) */\n\tRS_RET_FILENAME_INVALID = -2140, /**< filename invalid, not found, no access, ... */\n\tRS_RET_ZLIB_ERR = -2141, /**< error during zlib call */\n\tRS_RET_VAR_NOT_FOUND = -2142, /**< variable not found */\n\tRS_RET_EMPTY_MSG = -2143, /**< provided (raw) MSG is empty */\n\tRS_RET_PEER_CLOSED_CONN = -2144, /**< remote peer closed connection (information, no error) */\n\tRS_RET_ERR_OPEN_KLOG = -2145, /**< error opening or reading the kernel log socket */\n\tRS_RET_ERR_AQ_CONLOG = -2146, /**< error aquiring console log (on solaris) */\n\tRS_RET_ERR_DOOR = -2147, /**< some problems with handling the Solaris door functionality */\n\tRS_RET_NO_SRCNAME_TPL = -2150, /**< sourcename template was not specified where one was needed\n(omudpspoof spoof addr) */\n\tRS_RET_HOST_NOT_SPECIFIED = -2151, /**< (target) host was not specified where it was needed */\n\tRS_RET_ERR_LIBNET_INIT = -2152, /**< error initializing libnet, e.g. because not running as root */\n\tRS_RET_FORCE_TERM = -2153,\t/**< thread was forced to terminate by bShallShutdown, a state, not an error */\n\tRS_RET_RULES_QUEUE_EXISTS = -2154,/**< we were instructed to create a new\n\t\t\t\t\t   ruleset queue, but one already exists */\n\tRS_RET_NO_CURR_RULESET = -2155,/**< no current ruleset exists (but one is required) */\n\tRS_RET_NO_MSG_PASSING = -2156,\n/*< output module interface parameter passing mode \"MSG\" is not available but required */\n\tRS_RET_RULESET_NOT_FOUND = -2157,/**< a required ruleset could not be found */\n\tRS_RET_NO_RULESET= -2158,/**< no ruleset name as specified where one was needed */\n\tRS_RET_PARSER_NOT_FOUND = -2159,/**< parser with the specified name was not found */\n\tRS_RET_COULD_NOT_PARSE = -2160,/**< (this) parser could not parse the message (no error, means try next one) */\n\tRS_RET_EINTR = -2161,\t\t/**< EINTR occured during a system call (not necessarily an error) */\n\tRS_RET_ERR_EPOLL = -2162,\t/**< epoll() returned with an unexpected error code */\n\tRS_RET_ERR_EPOLL_CTL = -2163,\t/**< epol_ctll() returned with an unexpected error code */\n\tRS_RET_TIMEOUT = -2164,\t\t/**< timeout occured during operation */\n\tRS_RET_RCV_ERR = -2165,\t\t/**< error occured during socket rcv operation */\n\tRS_RET_NO_SOCK_CONFIGURED = -2166, /**< no socket (name) was configured where one is required */\n\tRS_RET_CONF_NOT_GLBL = -2167,\t/**< $Begin not in global scope */\n\tRS_RET_CONF_IN_GLBL = -2168,\t/**< $End when in global scope */\n\tRS_RET_CONF_INVLD_END = -2169,\t/**< $End for wrong conf object (probably nesting error) */\n\tRS_RET_CONF_INVLD_SCOPE = -2170,\n/*< config statement not valid in current scope (e.g. global stmt in action block) */\n\tRS_RET_CONF_END_NO_ACT = -2171,\t/**< end of action block, but no actual action specified */\n\tRS_RET_NO_LSTN_DEFINED = -2172, /**< no listener defined (e.g. inside an input module) */\n\tRS_RET_EPOLL_CR_FAILED = -2173, /**< epoll_create() failed */\n\tRS_RET_EPOLL_CTL_FAILED = -2174, /**< epoll_ctl() failed */\n\tRS_RET_INTERNAL_ERROR = -2175, /**< rsyslogd internal error, unexpected code path reached */\n\tRS_RET_ERR_CRE_AFUX = -2176, /**< error creating AF_UNIX socket (and binding it) */\n\tRS_RET_RATE_LIMITED = -2177, /**< some messages discarded due to exceeding a rate limit */\n\tRS_RET_ERR_HDFS_WRITE = -2178, /**< error writing to HDFS */\n\tRS_RET_ERR_HDFS_OPEN = -2179, /**< error during hdfsOpen (e.g. file does not exist) */\n\tRS_RET_FILE_NOT_SPECIFIED = -2180, /**< file name not configured where this was required */\n\tRS_RET_ERR_WRKDIR = -2181, /**< problems with the rsyslog working directory */\n\tRS_RET_WRN_WRKDIR = -2182, /**< correctable problems with the rsyslog working directory */\n\tRS_RET_ERR_QUEUE_EMERGENCY = -2183, /**<  some fatal error caused queue to switch to emergency mode */\n\tRS_RET_OUTDATED_STMT = -2184, /**<  some outdated statement/functionality is being used in conf file */\n\tRS_RET_MISSING_WHITESPACE = -2185, /**<  whitespace is missing in some config construct */\n\tRS_RET_OK_WARN = -2186, /**<  config part: everything was OK, but a warning message was emitted */\n\n\tRS_RET_INVLD_CONF_OBJ= -2200,\t/**< invalid config object (e.g. $Begin conf statement) */\n\t/* UNUSED, WAS; RS_RET_ERR_LIBEE_INIT = -2201,\t< cannot obtain libee ctx */\n\tRS_RET_ERR_LIBLOGNORM_INIT = -2202,/**< cannot obtain liblognorm ctx */\n\tRS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD = -2203,/**< liblognorm sampledb load failed */\n\tRS_RET_CMD_GONE_AWAY = -2204,/**< config directive existed, but no longer supported */\n\tRS_RET_ERR_SCHED_PARAMS = -2205,/**< there is a problem with configured thread scheduling params */\n\tRS_RET_SOCKNAME_MISSING = -2206,/**< no socket name configured where one is required */\n\tRS_RET_CONF_PARSE_ERROR = -2207,/**< (fatal) error parsing config file */\n\tRS_RET_CONF_RQRD_PARAM_MISSING = -2208,/**< required parameter in config object is missing */\n\tRS_RET_MOD_UNKNOWN = -2209,/**< module (config name) is unknown */\n\tRS_RET_CONFOBJ_UNSUPPORTED = -2210,/**< config objects (v6 conf) are not supported here */\n\tRS_RET_MISSING_CNFPARAMS = -2211, /**< missing configuration parameters */\n\tRS_RET_NO_LISTNERS = -2212, /**< module loaded, but no listeners are defined */\n\tRS_RET_INVLD_PROTOCOL = -2213, /**< invalid protocol specified in config file */\n\tRS_RET_CNF_INVLD_FRAMING = -2214, /**< invalid framing specified in config file */\n\tRS_RET_LEGA_ACT_NOT_SUPPORTED = -2215, /**< the module (no longer) supports legacy action syntax */\n\tRS_RET_MAX_OMSR_REACHED = -2216, /**< max nbr of string requests reached, not supported by core */\n\tRS_RET_UID_MISSING = -2217,\t/**< a user id is missing (but e.g. a password provided) */\n\tRS_RET_DATAFAIL = -2218,\t/**< data passed to action caused failure */\n\t/* reserved for pre-v6.5 */\n\tRS_RET_DUP_PARAM = -2220, /**< config parameter is given more than once */\n\tRS_RET_MODULE_ALREADY_IN_CONF = -2221, /**< module already in current configuration */\n\tRS_RET_PARAM_NOT_PERMITTED = -2222, /**< legacy parameter no longer permitted (usally already set by v2) */\n\tRS_RET_NO_JSON_PASSING = -2223, /**< rsyslog core does not support JSON-passing plugin API */\n\tRS_RET_MOD_NO_INPUT_STMT = -2224, /**< (input) module does not support input() statement */\n\tRS_RET_NO_CEE_MSG = -2225, /**< the message being processed is NOT CEE-enhanced */\n\n\t/**** up to 2290 is reserved for v6 use ****/\n\tRS_RET_RELP_ERR = -2291,\t/**<< error in RELP processing */\n\t/**** up to 3000 is reserved for c7 use ****/\n\tRS_RET_JNAME_NO_ROOT = -2301, /**< root element is missing in JSON path */\n\tRS_RET_JNAME_INVALID = -2302, /**< JSON path is invalid */\n\tRS_RET_JSON_PARSE_ERR = -2303, /**< we had a problem parsing JSON (or extra data) */\n\tRS_RET_BSD_BLOCKS_UNSUPPORTED = -2304, /**< BSD-style config blocks are no longer supported */\n\tRS_RET_JNAME_NOTFOUND = -2305, /**< JSON name not found (does not exist) */\n\tRS_RET_INVLD_SETOP = -2305, /**< invalid variable set operation, incompatible type */\n\tRS_RET_RULESET_EXISTS = -2306,/**< ruleset already exists */\n\tRS_RET_DEPRECATED = -2307,/**< deprecated functionality is used */\n\tRS_RET_DS_PROP_SEQ_ERR = -2308,/**< property sequence error deserializing object */\n\tRS_RET_INVLD_PROP = -2309,/**< property name error (unknown name) */\n\tRS_RET_NO_RULEBASE = -2310,/**< mmnormalize: rulebase can not be found or otherwise invalid */\n\tRS_RET_INVLD_MODE = -2311,/**< invalid mode specified in configuration */\n\tRS_RET_INVLD_ANON_BITS = -2312,/**< mmanon: invalid number of bits to anonymize specified */\n\tRS_RET_REPLCHAR_IGNORED = -2313,/**< mmanon: replacementChar parameter is ignored */\n\tRS_RET_SIGPROV_ERR = -2320,/**< error in signature provider */\n\tRS_RET_CRYPROV_ERR = -2321,/**< error in cryptography encryption provider */\n\tRS_RET_EI_OPN_ERR = -2322,/**< error opening an .encinfo file */\n\tRS_RET_EI_NO_EXISTS = -2323,/**< .encinfo file does not exist (status, not necessarily error!)*/\n\tRS_RET_EI_WR_ERR = -2324,/**< error writing an .encinfo file */\n\tRS_RET_EI_INVLD_FILE = -2325,/**< header indicates the file is no .encinfo file */\n\tRS_RET_CRY_INVLD_ALGO = -2326,/**< user specified invalid (unkonwn) crypto algorithm */\n\tRS_RET_CRY_INVLD_MODE = -2327,/**< user specified invalid (unkonwn) crypto mode */\n\tRS_RET_QUEUE_DISK_NO_FN = -2328,/**< disk queue configured, but filename not set */\n\tRS_RET_CA_CERT_MISSING = -2329,/**< a CA cert is missing where one is required (e.g. TLS) */\n\tRS_RET_CERT_MISSING = -2330,/**< a cert is missing where one is required (e.g. TLS) */\n\tRS_RET_CERTKEY_MISSING = -2331,/**< a cert (private) key is missing where one is required (e.g. TLS) */\n\tRS_RET_STRUC_DATA_INVLD = -2349,/**< structured data is malformed */\n\n\t/* up to 2350 reserved for 7.4 */\n\tRS_RET_QUEUE_CRY_DISK_ONLY = -2351,/**< crypto provider only supported for disk-associated queues */\n\tRS_RET_NO_DATA = -2352,/**< file has no data; more a state than a real error */\n\tRS_RET_RELP_AUTH_FAIL = -2353,/**< RELP peer authentication failed */\n\tRS_RET_ERR_UDPSEND = -2354,/**< sending msg via UDP failed */\n\tRS_RET_LAST_ERRREPORT = -2355,/**< module does not emit more error messages as limit is reached */\n\tRS_RET_READ_ERR = -2356,/**< read error occured (file i/o) */\n\tRS_RET_CONF_PARSE_WARNING = -2357,/**< warning parsing config file */\n\tRS_RET_CONF_WRN_FULLDLY_BELOW_HIGHWTR = -2358,/**< warning queue full delay mark below high wtr mark */\n\tRS_RET_RESUMED = -2359,/**< status: action was resumed (used for reporting) */\n\tRS_RET_RELP_NO_TLS = -2360,/**< librel does not support TLS (but TLS requested) */\n\tRS_RET_STATEFILE_WRONG_FNAME  = -2361,/**< state file is for wrong file */\n\tRS_RET_NAME_INVALID = -2362, /**< invalid name (in RainerScript) */\n\n\t/* up to 2400 reserved for 7.5 & 7.6 */\n\tRS_RET_INVLD_OMOD = -2400, /**< invalid output module, does not provide proper interfaces */\n\tRS_RET_INVLD_INTERFACE_INPUT = -2401, /**< invalid value for \"interface.input\" parameter (ext progs) */\n\tRS_RET_PARSER_NAME_EXISTS = -2402, /**< parser name already exists */\n\tRS_RET_MOD_NO_PARSER_STMT = -2403, /**< (parser) module does not support parser() statement */\n\n\t/* up to 2419 reserved for 8.4.x */\n\tRS_RET_IMFILE_WILDCARD = -2420, /**< imfile file name contains wildcard, which may be problematic */\n\tRS_RET_RELP_NO_TLS_AUTH = -2421,/**< librel does not support TLS authentication (but was requested) */\n\tRS_RET_KAFKA_ERROR = -2422,/**< error reported by Apache Kafka subsystem. See message for details. */\n\tRS_RET_KAFKA_NO_VALID_BROKERS = -2423,/**< no valid Kafka brokers configured/available */\n\tRS_RET_KAFKA_PRODUCE_ERR = -2424,/**< error during Kafka produce function */\n\tRS_RET_CONF_PARAM_INVLD = -2425,/**< config parameter is invalid */\n\tRS_RET_KSI_ERR = -2426,/**< error in KSI subsystem */\n\tRS_RET_ERR_LIBLOGNORM = -2427,/**< cannot obtain liblognorm ctx */\n\tRS_RET_CONC_CTRL_ERR = -2428,/**< error in lock/unlock/condition/concurrent-modification operation */\n\tRS_RET_SENDER_GONE_AWAY = -2429,/**< warning: sender not seen for configured amount of time */\n\tRS_RET_SENDER_APPEARED = -2430,/**< info: new sender appeared */\n\tRS_RET_FILE_ALREADY_IN_TABLE = -2431,/**< in imfile: table already contains to be added file */\n\tRS_RET_ERR_DROP_PRIV = -2432,/**< error droping privileges */\n\tRS_RET_FILE_OPEN_ERROR = -2433, /**< error other than \"not found\" occured during open() */\n\tRS_RET_RENAME_TMP_QI_ERROR = -2435, /**< renaming temporary .qi file failed */\n\tRS_RET_ERR_SETENV = -2436, /**< error setting an environment variable */\n\tRS_RET_DIR_CHOWN_ERROR = -2437, /**< error during chown() */\n\tRS_RET_JSON_UNUSABLE = -2438, /**< JSON object is NULL or otherwise unusable */\n\tRS_RET_OPERATION_STATUS = -2439, /**< operational status (info) message, no error */\n\tRS_RET_UDP_MSGSIZE_TOO_LARGE = -2440, /**< a message is too large to be sent via UDP */\n\tRS_RET_NON_JSON_PROP = -2441, /**< a non-json property id is provided where a json one is requried */\n\tRS_RET_NO_TZ_SET = -2442, /**< system env var TZ is not set (status msg) */\n\tRS_RET_FS_ERR = -2443, /**< file-system error */\n\tRS_RET_POLL_ERR = -2444, /**< error in poll() system call */\n\tRS_RET_OVERSIZE_MSG = -2445, /**< message is too long (above configured max) */\n\tRS_RET_TLS_KEY_ERR = -2446, /**< TLS KEY has problems */\n\tRS_RET_RABBITMQ_CONN_ERR = -2447, /**< RabbitMQ Connection error */\n\tRS_RET_RABBITMQ_LOGIN_ERR = -2448, /**< RabbitMQ Login error */\n\tRS_RET_RABBITMQ_CHANNEL_ERR = -2449, /**< RabbitMQ Connection error */\n\tRS_RET_NO_WRKDIR_SET = -2450, /**< working directory not set, but desired by functionality */\n\tRS_RET_ERR_QUEUE_FN_DUP = -2451, /**< duplicate queue file name */\n\n\t/* RainerScript error messages (range 1000.. 1999) */\n\tRS_RET_SYSVAR_NOT_FOUND = 1001, /**< system variable could not be found (maybe misspelled) */\n\tRS_RET_FIELD_NOT_FOUND = 1002, /**< field() function did not find requested field */\n\n\t/* some generic error/status codes */\n\tRS_RET_OK = 0,\t\t\t/**< operation successful */\n\tRS_RET_OK_DELETE_LISTENTRY = 1,\n/*< operation successful, but callee requested the deletion of an entry (special state) */\n\tRS_RET_TERMINATE_NOW = 2,\t/**< operation successful, function is requested to terminate\n\t\t\t\t\t(mostly used with threads) */\n\tRS_RET_NO_RUN = 3,\t\t/**< operation successful, but function does not like to be executed */\n\tRS_RET_IDLE = 4,\t\t/**< operation successful, but callee is idle (e.g. because queue is empty) */\n\tRS_RET_TERMINATE_WHEN_IDLE = 5\t/**< operation successful, function is requested to terminate when idle */\n};\n\n/* some helpful macros to work with srRetVals.\n * Be sure to call the to-be-returned variable always \"iRet\" and\n * the function finalizer always \"finalize_it\".\n */\n#ifdef HAVE_BUILTIN_EXCEPT\n#\tdefine CHKiRet(code) if(__builtin_expect(((iRet = code) != RS_RET_OK), 0)) goto finalize_it\n#\tdefine likely(x)      __builtin_expect(!!(x), 1)\n#\tdefine unlikely(x)    __builtin_expect(!!(x), 0)\n#else\n#\tdefine CHKiRet(code) if((iRet = code) != RS_RET_OK) goto finalize_it\n#\tdefine likely(x)      (x)\n#\tdefine unlikely(x)    (x)\n#endif\n\n# define CHKiConcCtrl(code)  { int tmp_CC; \\\n\tif ((tmp_CC = code) != 0) { \\\n\t\tiRet = RS_RET_CONC_CTRL_ERR; \\\n\t\terrno = tmp_CC; \\\n\t\tgoto finalize_it; \\\n\t} \\\n}\n\n/* macro below is to be used if we need our own handling, eg for cleanup */\n#define CHKiRet_Hdlr(code) if((iRet = code) != RS_RET_OK)\n/* macro below is to handle failing malloc/calloc/strdup... which we almost always handle in the same way... */\n#define CHKmalloc(operation) if((operation) == NULL) ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY)\n/* macro below is used in conjunction with CHKiRet_Hdlr, else use ABORT_FINALIZE */\n#define FINALIZE goto finalize_it;\n#define DEFiRet rsRetVal iRet = RS_RET_OK\n#define RETiRet return iRet\n\n#define ABORT_FINALIZE(errCode)\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tiRet = errCode;\t\t\t\\\n\t\tgoto finalize_it;\t\t\\\n\t} while (0)\n\n/** Object ID. These are for internal checking. Each\n * object is assigned a specific ID. This is contained in\n * all Object structs (just like C++ RTTI). We can use\n * this field to see if we have been passed a correct ID.\n * Other than that, there is currently no other use for\n * the object id.\n */\nenum rsObjectID\n{\n\tOIDrsFreed = -1,\t\t/**< assigned, when an object is freed. If this\n\t\t\t\t *   is seen during a method call, this is an\n\t\t\t\t *   invalid object pointer!\n\t\t\t\t */\n\tOIDrsInvalid = 0,\t/**< value created by calloc(), so do not use ;) */\n\t/* The 0x3412 is a debug aid. It helps us find object IDs in memory\n\t * dumps (on X86, this is 1234 in the dump ;)\n\t * If you are on an embedded device and you would like to save space\n\t * make them 1 byte only.\n\t */\n\tOIDrsCStr = 0x34120001,\n\tOIDrsPars = 0x34120002\n};\ntypedef enum rsObjectID rsObjID;\n\n/* support to set object types */\n#ifdef NDEBUG\n#define rsSETOBJTYPE(pObj, type)\n#define rsCHECKVALIDOBJECT(x, type)\n#else\n#define rsSETOBJTYPE(pObj, type) pObj->OID = type;\n#define rsCHECKVALIDOBJECT(x, type) {assert(x != NULL); assert(x->OID == type);}\n#endif\n\n/**\n * This macro should be used to free objects.\n * It aids in interpreting dumps during debugging.\n */\n#ifdef NDEBUG\n#define RSFREEOBJ(x) free(x)\n#else\n#define RSFREEOBJ(x) {(x)->OID = OIDrsFreed; free(x);}\n#endif\n\nextern pthread_attr_t default_thread_attr;\n#ifdef HAVE_PTHREAD_SETSCHEDPARAM\nextern struct sched_param default_sched_param;\nextern int default_thr_sched_policy;\n#endif\n\n/* The following structure defines immutable parameters which need to\n * be passed as action parameters.\n *\n * Note that output plugins may request multiple templates. Let's say\n * an output requests n templates. Than the overall table must hold\n * n*nbrMsgs records, and each messages begins on a n-boundary. There\n * is a macro defined below to access the proper element.\n *\n * WARNING: THIS STRUCTURE IS PART OF THE ***OUTPUT MODULE INTERFACE***\n * It is passed into the doCommit() function. Do NOT modify it until\n * absolutely necessary - all output plugins need to be changed!\n *\n * If a change is \"just\" for internal working, consider adding a\n * separate parameter outside of this structure. Of course, it is\n * best to avoid this as well ;-)\n * rgerhards, 2013-12-04\n */\nstruct actWrkrIParams {\n\tuchar *param;\n\tuint32_t lenBuf;  /* length of string buffer (if string ptr) */\n\tuint32_t lenStr;  /* length of current string (if string ptr) */\n};\n\n/* macro to access actWrkrIParams base object:\n * param is ptr to base address\n * nActTpls is the number of templates the action has requested\n * iMsg is the message index\n * iTpl is the template index\n * This macro can be used for read and write access.\n */\n#define actParam(param, nActTpls, iMsg, iTpl) (param[(iMsg*nActTpls)+iTpl])\n\n/* for the time being, we do our own portability handling here. It\n * looks like autotools either does not yet support checks for it, or\n * I wasn't smart enough to find them ;) rgerhards, 2007-07-18\n */\n#ifndef __GNUC__\n#  define  __attribute__(x)  /*NOTHING*/\n#endif\n\n#if !defined(O_CLOEXEC) && !defined(_AIX)\n/* of course, this limits the functionality... */\n#  define O_CLOEXEC 0\n#endif\n\n/* some constants */\n#define MUTEX_ALREADY_LOCKED\t0\n#define LOCK_MUTEX\t\t1\n\n\n#include \"debug.h\"\n#include \"obj.h\"\n\n/* the variable below is a trick: before we can init the runtime, the caller\n * may want to set a module load path. We can not do this via the glbl class\n * because it needs an initialized runtime system (and may at some point in time\n * even be loaded itself). So this is a no-go. What we do is use a single global\n * variable which may be provided with a pointer by the caller. This variable\n * resides in rsyslog.c, the main runtime file. We have not seen any realy valule\n * in providing object access functions. If you don't like that, feel free to\n * add them. -- rgerhards, 2008-04-17\n */\nextern uchar *glblModPath; /* module load path */\nextern void (*glblErrLogger)(const int, const int, const uchar*);\n\n/* some runtime prototypes */\nvoid processImInternal(void);\nrsRetVal rsrtInit(const char **ppErrObj, obj_if_t *pObjIF);\nrsRetVal rsrtExit(void);\nint rsrtIsInit(void);\nvoid rsrtSetErrLogger(void (*errLogger)(const int, const int, const uchar*));\n\nvoid dfltErrLogger(const int, const int, const uchar *errMsg);\n\n\n/* this define below is (later) intended to be used to implement empty\n * structs. TODO: check if compilers supports this and, if not, define\n * a dummy variable. This requires review of where in code empty structs\n * are already defined. -- rgerhards, 2010-07-26\n */\n#ifdef OS_SOLARIS\n#define EMPTY_STRUCT  int remove_me_when_first_real_member_is_added;\n#else\n#define EMPTY_STRUCT\n#endif\n\n/* TODO: remove this -- this is only for transition of the config system */\nextern rsconf_t *ourConf; /* defined by syslogd.c, a hack for functions that do not\n\t\t\t     yet receive a copy, so that we can incrementially\n\t\t\t     compile and change... -- rgerhars, 2011-04-19 */\n\n\n/* here we add some stuff from the compatibility layer. A separate include\n * would be cleaner, but would potentially require changes all over the\n * place. So doing it here is better. The respective replacement\n * functions should usually be found under ./compat -- rgerhards, 2015-05-20\n */\n#ifndef HAVE_STRNDUP\nchar * strndup(const char *s, size_t n);\n#endif\n\n#endif /* multi-include protection */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2004.0-ddt2obthz5sijsp3bwmmse3bl5yhm3hx/spack-src/tests/mmutf8fix_no_error.sh",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2004.0-ddt2obthz5sijsp3bwmmse3bl5yhm3hx/spack-src/tests/test.mmdb",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2004.0-ddt2obthz5sijsp3bwmmse3bl5yhm3hx/spack-src/tests/with_space.mmdb",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2004.0-ddt2obthz5sijsp3bwmmse3bl5yhm3hx/spack-src/tests/testsuites/ksi-sample.log.ksisig",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2004.0-ddt2obthz5sijsp3bwmmse3bl5yhm3hx/spack-src/tests/resultdata/lmsig_ksi_ls12_async/mockinput.bin",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2004.0-ddt2obthz5sijsp3bwmmse3bl5yhm3hx/spack-src/tests/resultdata/lmsig_ksi_ls12_async/messages.logsig.parts/blocks.dat",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2004.0-ddt2obthz5sijsp3bwmmse3bl5yhm3hx/spack-src/tests/resultdata/lmsig_ksi_ls12_async/messages.logsig.parts/block-signatures.dat",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2004.0-ddt2obthz5sijsp3bwmmse3bl5yhm3hx/spack-src/plugins/omsnmp/mibs/ADISCON-MIB.txt",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2004.0-ddt2obthz5sijsp3bwmmse3bl5yhm3hx/spack-src/plugins/omsnmp/mibs/ADISCON-MONITORWARE-MIB.txt",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2004.0-ddt2obthz5sijsp3bwmmse3bl5yhm3hx/spack-src/solaris/cddllicense.txt"
    ],
    "total_files": 1583
}