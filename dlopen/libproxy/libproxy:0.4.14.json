{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libproxy-0.4.14-ullw3z3nvdalv3pcmwipirxr2vwyu7lt/spack-src/libmodman/module_manager.cpp": "/*******************************************************************************\n * libmodman - A library for extending applications\n * Copyright (C) 2009 Nathaniel McCallum <nathaniel@natemccallum.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA\n ******************************************************************************/\n\n#include <algorithm>  // For sort()\n#include <sys/stat.h> // For stat()\n#include <iostream>\n#include <typeinfo>\n\n#ifdef WIN32\n#include <windows.h>\n#else\n#include <dlfcn.h>  // For dlopen(), etc...\n#include <dirent.h> // For opendir(), readdir(), closedir()\n#endif\n\n#include \"module_manager.hpp\"\nusing namespace libmodman;\n\n#include <cstdio>\n\n#define _LOAD_FAIL -1\n#define _LOAD_LAZY  0\n#define _LOAD_SUCC  1\n\n#ifdef WIN32\n#define pdlmtype HMODULE\n#define pdlopenl(filename) LoadLibraryEx(filename, NULL, DONT_RESOLVE_DLL_REFERENCES)\n#define pdlclose(module) FreeLibrary((pdlmtype) module)\nstatic void* pdlsym(pdlmtype mod, string sym) {\n\treturn (void *) GetProcAddress(mod, sym.c_str());\n}\n\nstatic pdlmtype pdlreopen(const char* filename, pdlmtype module) {\n\tpdlclose(module);\n\treturn LoadLibrary(filename);\n}\n\nstatic string pdlerror() {\n\tstd::string e;\n\tLPTSTR msg;\n\n\tFormatMessage(\n\t\t\tFORMAT_MESSAGE_ALLOCATE_BUFFER |FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n\t\t\tNULL,\n\t\t\tGetLastError(),\n\t\t\tMAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n\t\t\t(LPTSTR) &msg,\n\t\t\t0,\n\t\t\tNULL);\n\te = std::string((const char*) msg);\n    LocalFree(msg);\n    return e;\n}\n\nstatic bool pdlsymlinked(const char* modn, const char* symb) {\n\treturn (GetProcAddress(GetModuleHandle(modn), symb) != NULL || \\\n\t\t    GetProcAddress(GetModuleHandle(NULL), symb) != NULL);\n}\n\nstatic string prep_type_name(string name) {\n\tstring prefix = \"<class \";\n\tstring suffix = \",\";\n\tif (name.find(prefix) != name.npos)\n\t\tname = name.substr(name.find(prefix) + prefix.size());\n\tif (name.find(suffix) != name.npos)\n\t\tname = name.substr(0, name.find(suffix));\n\treturn name;\n}\n#else\n#define pdlmtype void*\n#define pdlopenl(filename) dlopen(filename, RTLD_LAZY | RTLD_LOCAL)\n#define pdlclose(module) dlclose((pdlmtype) module)\n#define pdlreopen(filename, module) module\nstatic void* pdlsym(pdlmtype mod, string sym) {\n\treturn dlsym(mod, sym.c_str());\n}\n\nstatic string pdlerror() {\n\treturn dlerror();\n}\n\nbool pdlsymlinked(const char* modn, const char* symb) {\n\tvoid* mod = dlopen(NULL, RTLD_LAZY | RTLD_LOCAL);\n\tif (mod) {\n\t\tvoid* sym = dlsym(mod, symb);\n\t\tdlclose(mod);\n\t\treturn sym != NULL;\n\t}\n\treturn false;\n}\n\n#define prep_type_name(name) name\n#endif\n\n#define _str(s) #s\n#define __str(s) _str(s)\n\n#ifndef _MOD_SUFFIX\n#ifdef WIN32\n#define _MOD_SUFFIX \"dll\"\n#define CR \"\"\n#else\n#define _MOD_SUFFIX \"so\"\n#define CR \"\\r\"\n#endif\n#endif\n\nmodule_manager::~module_manager() {\n\t// Free all extensions\n\tfor (map<string, vector<base_extension*> >::iterator i=this->extensions.begin() ; i != this->extensions.end() ; i++) {\n\t\tfor (vector<base_extension*>::iterator j=i->second.begin() ; j != i->second.end() ; j++)\n\t\t\tdelete *j;\n\t\ti->second.clear();\n\t}\n\tthis->extensions.clear();\n\n\t// Free all modules\n\tfor (set<void*>::iterator i=this->modules.begin() ; i != this->modules.end() ; i++)\n\t\tpdlclose(*i);\n\tthis->modules.clear();\n}\n\nstatic int load(map<string, vector<base_extension*> >& extensions,\n                             set<string>&              singletons,\n                             mm_module                *mod,\n                             bool                      lazy,\n                             bool                      symbreq) {\n\tconst char* debug = getenv(\"_MM_DEBUG\");\n\n\tif (!mod || mod->vers != __MM_MODULE_VERSION || !mod->type || !mod->init) {\n\t\tif (debug)\n\t\t\tcerr << \"failed!\" << endl\n\t\t\t     << \"\\tUnable to find basic module info!\" << endl;\n\t\treturn _LOAD_FAIL;\n\t}\n\n\t// Get the module type\n\tstring types = mod->type();\n\n\t// Make sure the type is registered\n\tif (extensions.find(types) == extensions.end()) {\n\t\tif (debug)\n\t\t\tcerr << \"failed!\" << endl\n\t\t\t\t << \"\\tUnknown extension type: \" << prep_type_name(types) << endl;\n\t\treturn _LOAD_FAIL;\n\t}\n\n\t// If this is a singleton and we already have an instance, don't instantiate\n\tif (singletons.find(types) != singletons.end() &&\n\t\textensions[types].size() > 0) {\n\t\tif (debug)\n\t\t\tcerr << \"failed!\" << endl\n\t\t\t     << \"\\tNot loading subsequent singleton for: \" << prep_type_name(types) << endl;\n\t\treturn _LOAD_FAIL;\n\t}\n\n\t// If a symbol is defined, we'll search for it in the main process\n\tif (mod->symb && mod->smod && !pdlsymlinked(mod->smod, mod->symb)) {\n\t\t// If the symbol is not found and the symbol is required, error\n\t\tif (symbreq) {\n\t\t\tif (debug)\n\t\t\t\tcerr << \"failed!\" << endl\n\t\t\t\t\t << \"\\tUnable to find required symbol: \"\n\t\t\t\t\t << mod->symb << endl;\n\t\t\treturn _LOAD_FAIL;\n\t\t}\n\n\t\t// If the symbol is not found and not required, we'll load only\n\t\t// if there are no other modules of this type\n\t\telse if (extensions[types].size() > 0) {\n\t\t\tif (debug)\n\t\t\t\tcerr << \"failed!\" << endl\n\t\t\t\t\t << \"\\tUnable to find required symbol: \"\n\t\t\t\t\t << mod->symb << endl;\n\t\t\treturn _LOAD_FAIL;\n\t\t}\n\t}\n\n\t// We've passed all the tests this far, do it again in non-lazy mode\n\tif (lazy) return _LOAD_LAZY;\n\n\t// If our execution test succeeds, call init()\n\tif ((mod->test && mod->test()) || !mod->test) {\n\t\tbase_extension** exts = mod->init();\n\t\tif (!exts) {\n\t\t\tif (debug)\n\t\t\t\tcerr << \"failed!\" << endl\n\t\t\t\t\t << \"\\tinit() returned no extensions!\" << endl;\n\t\t\treturn _LOAD_FAIL;\n\t\t}\n\n\t\tif (debug)\n\t\t\tcerr << \"success\" << endl;\n\n\t\t// init() returned extensions we need to register\n\t\tfor (unsigned int i=0 ; exts[i] ; i++) {\n\t\t\tif (debug)\n\t\t\t\tcerr << \"\\tRegistering \"\n\t\t\t\t\t << typeid(*exts[i]).name() << \"(\"\n\t\t\t\t\t << prep_type_name(exts[i]->get_base_type()) << \")\" << endl;\n\t\t\textensions[exts[i]->get_base_type()].push_back(exts[i]);\n\t\t}\n\t\tdelete[] exts;\n\t\treturn _LOAD_SUCC;\n\t}\n\n\tif (debug)\n\t\tcerr << \"failed!\" << endl\n\t\t\t << \"\\tTest execution failed.\" << endl;\n\treturn _LOAD_FAIL;\n}\n\nbool module_manager::load_builtin(mm_module *mod) {\n\tconst char* debug = getenv(\"_MM_DEBUG\");\n\tif (debug)\n\t\t\tcerr << \"loading : builtin module \" << mod->name << CR;\n\n\t// Do the load with the specified prefix\n\tint status = load(this->extensions, this->singletons, mod, false, false);\n\treturn status == _LOAD_SUCC;\n}\n\nbool module_manager::load_file(string filename, bool symbreq) {\n\tconst char* debug = getenv(\"_MM_DEBUG\");\n\n\t// Stat the file to make sure it is a file\n\tstruct stat st;\n\tif (stat(filename.c_str(), &st) != 0) return false;\n\tif ((st.st_mode & S_IFMT) != S_IFREG) return false;\n\n\tif (debug)\n\t\tcerr << \"loading : \" << filename << CR;\n\n\t// Open the module\n\tpdlmtype dlobj = pdlopenl(filename.c_str());\n\tif (!dlobj) {\n\t\tif (debug)\n\t\t\tcerr << \"failed!\" << endl\n\t\t\t     << \"\\t\" << pdlerror() << endl;\n\t\treturn false;\n\t}\n\n\t// If we have already loaded this module, return true\n\tif (this->modules.find((void*) dlobj) != this->modules.end()) {\n\t\tif (debug)\n\t\t\tcerr << \"preload\" << endl;\n\t\tpdlclose(dlobj);\n\t\treturn true;\n\t}\n\n\t// Try and finish the load\n\tstruct mm_module *mod_info = (mm_module*) pdlsym(dlobj, __str(__MM_MODULE_VARNAME(info)));\n\tint status = load(this->extensions, this->singletons, mod_info, true, symbreq);\n\tif (status == _LOAD_LAZY) { // Reload the module in non-lazy mode\n\t\tdlobj = pdlreopen(filename.c_str(), dlobj);\n\t\tif (!dlobj) {\n\t\t\tif (debug)\n\t\t\t\tcerr << \"failed!\" << endl\n\t\t\t\t\t << \"\\tUnable to reload module: \" << pdlerror() << endl;\n\t\t\treturn false;\n\t\t}\n\t\tmod_info = (mm_module*) pdlsym(dlobj, __str(__MM_MODULE_VARNAME(info)));\n\t\tstatus = load(this->extensions, this->singletons, mod_info, false, symbreq);\n\t}\n\tif (status == _LOAD_FAIL) {\n\t\tpdlclose(dlobj);\n\t\treturn false;\n\t}\n\n\t// Add the dlobject to our known modules\n\tthis->modules.insert((void*) dlobj);\n\n\t// Yay, we did it!\n\treturn true;\n}\n\nbool module_manager::load_dir(string dirname, bool symbreq) {\n\tvector<string> files;\n\n#ifdef WIN32\n\tWIN32_FIND_DATA fd;\n\tHANDLE search;\n\n\tstring srch = dirname + \"\\\\*.\" + _MOD_SUFFIX;\n\tsearch = FindFirstFile(srch.c_str(), &fd);\n\tif (search != INVALID_HANDLE_VALUE) {\n\t\tdo {\n\t\t\tfiles.push_back(dirname + \"\\\\\" + fd.cFileName);\n\t\t} while (FindNextFile(search, &fd));\n\t\tFindClose(search);\n\t}\n#else\n\tstruct dirent *ent;\n\n\tDIR *moduledir = opendir(dirname.c_str());\n\tif (moduledir) {\n\t\twhile((ent = readdir(moduledir))) {\n\t\t\tstring tmp = ent->d_name;\n\t\t\tif (tmp.find(_MOD_SUFFIX, tmp.size() - string(_MOD_SUFFIX).size()) != tmp.npos)\n\t\t\t\tfiles.push_back(dirname + \"/\" + tmp);\n\t\t}\n\t\tclosedir(moduledir);\n\t}\n#endif\n\n\t// Perform our load alphabetically\n\tsort(files.begin(), files.end());\n\n\t// Try to do the load\n\tbool loaded = false;\n\tfor (vector<string>::iterator it = files.begin() ; it != files.end() ; it++)\n\t\tloaded = this->load_file(*it, symbreq) || loaded;\n\treturn loaded;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-libproxy-0.4.14-ullw3z3nvdalv3pcmwipirxr2vwyu7lt/spack-src/bindings/csharp/libproxy.snk",
        "/tmp/vanessa/spack-stage/spack-stage-libproxy-0.4.14-ullw3z3nvdalv3pcmwipirxr2vwyu7lt/spack-src/doc/libproxy_files.dia"
    ],
    "total_files": 107
}