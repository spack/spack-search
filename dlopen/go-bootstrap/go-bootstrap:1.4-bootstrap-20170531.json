{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/runtime/thunk_solaris_amd64.s": "// Copyright 2014 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// This file exposes various external library functions to Go code in the runtime.\n\n#include \"zasm_GOOS_GOARCH.h\"\n#include \"textflag.h\"\n\nTEXT runtime\u00b7libc_chdir(SB),NOSPLIT,$0\n\tMOVQ\tlibc\u00b7chdir(SB), AX\n\tJMP\tAX\n\nTEXT runtime\u00b7libc_chroot(SB),NOSPLIT,$0\n\tMOVQ\tlibc\u00b7chroot(SB), AX\n\tJMP\tAX\n\nTEXT runtime\u00b7libc_close(SB),NOSPLIT,$0\n\tMOVQ\tlibc\u00b7close(SB), AX\n\tJMP\tAX\n\nTEXT runtime\u00b7libc_dlopen(SB),NOSPLIT,$0\n\tMOVQ\tlibc\u00b7dlopen(SB), AX\n\tJMP\tAX\n\nTEXT runtime\u00b7libc_dlclose(SB),NOSPLIT,$0\n\tMOVQ\tlibc\u00b7dlclose(SB), AX\n\tJMP\tAX\n\nTEXT runtime\u00b7libc_dlsym(SB),NOSPLIT,$0\n\tMOVQ\tlibc\u00b7dlsym(SB), AX\n\tJMP\tAX\n\nTEXT runtime\u00b7libc_execve(SB),NOSPLIT,$0\n\tMOVQ\tlibc\u00b7execve(SB), AX\n\tJMP\tAX\n\nTEXT runtime\u00b7libc_exit(SB),NOSPLIT,$0\n\tMOVQ\tlibc\u00b7exit(SB), AX\n\tJMP\tAX\n\nTEXT runtime\u00b7libc_fcntl(SB),NOSPLIT,$0\n\tMOVQ\tlibc\u00b7fcntl(SB), AX\n\tJMP\tAX\n\nTEXT runtime\u00b7libc_forkx(SB),NOSPLIT,$0\n\tMOVQ\tlibc\u00b7forkx(SB), AX\n\tJMP\tAX\n\nTEXT runtime\u00b7libc_gethostname(SB),NOSPLIT,$0\n\tMOVQ\tlibc\u00b7gethostname(SB), AX\n\tJMP\tAX\n\nTEXT runtime\u00b7libc_ioctl(SB),NOSPLIT,$0\n\tMOVQ\tlibc\u00b7ioctl(SB), AX\n\tJMP\tAX\n\nTEXT runtime\u00b7libc_setgid(SB),NOSPLIT,$0\n\tMOVQ\tlibc\u00b7setgid(SB), AX\n\tJMP\tAX\n\nTEXT runtime\u00b7libc_setgroups(SB),NOSPLIT,$0\n\tMOVQ\tlibc\u00b7setgroups(SB), AX\n\tJMP\tAX\n\nTEXT runtime\u00b7libc_setsid(SB),NOSPLIT,$0\n\tMOVQ\tlibc\u00b7setsid(SB), AX\n\tJMP\tAX\n\nTEXT runtime\u00b7libc_setuid(SB),NOSPLIT,$0\n\tMOVQ\tlibc\u00b7setuid(SB), AX\n\tJMP\tAX\n\nTEXT runtime\u00b7libc_setpgid(SB),NOSPLIT,$0\n\tMOVQ\tlibc\u00b7setpgid(SB), AX\n\tJMP\tAX\n\nTEXT runtime\u00b7libc_syscall(SB),NOSPLIT,$0\n\tMOVQ\tlibc\u00b7syscall(SB), AX\n\tJMP\tAX\n\nTEXT runtime\u00b7libc_wait4(SB),NOSPLIT,$0\n\tMOVQ\tlibc\u00b7wait4(SB), AX\n\tJMP\tAX\n\nTEXT runtime\u00b7libc_write(SB),NOSPLIT,$0\n\tMOVQ\tlibc\u00b7write(SB), AX\n\tJMP\tAX\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/runtime/syscall_solaris.c": "// Copyright 2014 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#pragma dynimport libc\u00b7chdir chdir \"libc.so\"\n#pragma dynimport libc\u00b7chroot chroot \"libc.so\"\n#pragma dynimport libc\u00b7close close \"libc.so\"\n#pragma dynimport libc\u00b7dlclose dlclose \"libc.so\"\n#pragma dynimport libc\u00b7dlopen dlopen \"libc.so\"\n#pragma dynimport libc\u00b7dlsym dlsym \"libc.so\"\n#pragma dynimport libc\u00b7execve execve \"libc.so\"\n#pragma dynimport libc\u00b7fcntl fcntl \"libc.so\"\n#pragma dynimport libc\u00b7gethostname gethostname \"libc.so\"\n#pragma dynimport libc\u00b7ioctl ioctl \"libc.so\"\n#pragma dynimport libc\u00b7pipe pipe \"libc.so\"\n#pragma dynimport libc\u00b7setgid setgid \"libc.so\"\n#pragma dynimport libc\u00b7setgroups setgroups \"libc.so\"\n#pragma dynimport libc\u00b7setsid setsid \"libc.so\"\n#pragma dynimport libc\u00b7setuid setuid \"libc.so\"\n#pragma dynimport libc\u00b7setpgid setsid \"libc.so\"\n#pragma dynimport libc\u00b7syscall syscall \"libc.so\"\n#pragma dynimport libc\u00b7forkx forkx \"libc.so\"\n#pragma dynimport libc\u00b7wait4 wait4 \"libc.so\"\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/runtime/syscall_solaris.go": "// Copyright 2014 The Go Authors.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage runtime\n\nimport \"unsafe\"\n\nvar (\n\tlibc_chdir,\n\tlibc_chroot,\n\tlibc_close,\n\tlibc_dlopen,\n\tlibc_dlclose,\n\tlibc_dlsym,\n\tlibc_execve,\n\tlibc_exit,\n\tlibc_fcntl,\n\tlibc_forkx,\n\tlibc_gethostname,\n\tlibc_ioctl,\n\tlibc_pipe,\n\tlibc_setgid,\n\tlibc_setgroups,\n\tlibc_setsid,\n\tlibc_setuid,\n\tlibc_setpgid,\n\tlibc_syscall,\n\tlibc_wait4,\n\tlibc_write,\n\tpipe1 libcFunc\n)\n\n//go:nosplit\nfunc syscall_sysvicall6(fn, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {\n\tcall := libcall{\n\t\tfn:   fn,\n\t\tn:    nargs,\n\t\targs: uintptr(unsafe.Pointer(&a1)),\n\t}\n\tentersyscallblock()\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\texitsyscall()\n\treturn call.r1, call.r2, call.err\n}\n\n//go:nosplit\nfunc syscall_rawsysvicall6(fn, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {\n\tcall := libcall{\n\t\tfn:   fn,\n\t\tn:    nargs,\n\t\targs: uintptr(unsafe.Pointer(&a1)),\n\t}\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\treturn call.r1, call.r2, call.err\n}\n\n// TODO(aram): Once we remove all instances of C calling sysvicallN, make\n// sysvicallN return errors and replace the body of the following functions\n// with calls to sysvicallN.\n\n//go:nosplit\nfunc syscall_chdir(path uintptr) (err uintptr) {\n\tcall := libcall{\n\t\tfn:   uintptr(unsafe.Pointer(&libc_chdir)),\n\t\tn:    1,\n\t\targs: uintptr(unsafe.Pointer(&path)),\n\t}\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\treturn call.err\n}\n\n//go:nosplit\nfunc syscall_chroot(path uintptr) (err uintptr) {\n\tcall := libcall{\n\t\tfn:   uintptr(unsafe.Pointer(&libc_chroot)),\n\t\tn:    1,\n\t\targs: uintptr(unsafe.Pointer(&path)),\n\t}\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\treturn call.err\n}\n\n// like close, but must not split stack, for forkx.\n//go:nosplit\nfunc syscall_close(fd int32) int32 {\n\treturn int32(sysvicall1(&libc_close, uintptr(fd)))\n}\n\nfunc syscall_dlopen(name *byte, mode uintptr) (handle uintptr, err uintptr) {\n\tcall := libcall{\n\t\tfn:   uintptr(unsafe.Pointer(&libc_dlopen)),\n\t\tn:    2,\n\t\targs: uintptr(unsafe.Pointer(&name)),\n\t}\n\tentersyscallblock()\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\texitsyscall()\n\tif call.r1 == 0 {\n\t\treturn call.r1, call.err\n\t}\n\treturn call.r1, 0\n}\n\nfunc syscall_dlclose(handle uintptr) (err uintptr) {\n\tcall := libcall{\n\t\tfn:   uintptr(unsafe.Pointer(&libc_dlclose)),\n\t\tn:    1,\n\t\targs: uintptr(unsafe.Pointer(&handle)),\n\t}\n\tentersyscallblock()\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\texitsyscall()\n\treturn call.r1\n}\n\nfunc syscall_dlsym(handle uintptr, name *byte) (proc uintptr, err uintptr) {\n\tcall := libcall{\n\t\tfn:   uintptr(unsafe.Pointer(&libc_dlsym)),\n\t\tn:    2,\n\t\targs: uintptr(unsafe.Pointer(&handle)),\n\t}\n\tentersyscallblock()\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\texitsyscall()\n\tif call.r1 == 0 {\n\t\treturn call.r1, call.err\n\t}\n\treturn call.r1, 0\n}\n\n//go:nosplit\nfunc syscall_execve(path, argv, envp uintptr) (err uintptr) {\n\tcall := libcall{\n\t\tfn:   uintptr(unsafe.Pointer(&libc_execve)),\n\t\tn:    3,\n\t\targs: uintptr(unsafe.Pointer(&path)),\n\t}\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\treturn call.err\n}\n\n// like exit, but must not split stack, for forkx.\n//go:nosplit\nfunc syscall_exit(code uintptr) {\n\tsysvicall1(&libc_exit, code)\n}\n\n//go:nosplit\nfunc syscall_fcntl(fd, cmd, arg uintptr) (val, err uintptr) {\n\tcall := libcall{\n\t\tfn:   uintptr(unsafe.Pointer(&libc_fcntl)),\n\t\tn:    3,\n\t\targs: uintptr(unsafe.Pointer(&fd)),\n\t}\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\treturn call.r1, call.err\n}\n\n//go:nosplit\nfunc syscall_forkx(flags uintptr) (pid uintptr, err uintptr) {\n\tcall := libcall{\n\t\tfn:   uintptr(unsafe.Pointer(&libc_forkx)),\n\t\tn:    1,\n\t\targs: uintptr(unsafe.Pointer(&flags)),\n\t}\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\treturn call.r1, call.err\n}\n\nfunc syscall_gethostname() (name string, err uintptr) {\n\tcname := new([_MAXHOSTNAMELEN]byte)\n\tvar args = [2]uintptr{uintptr(unsafe.Pointer(&cname[0])), _MAXHOSTNAMELEN}\n\tcall := libcall{\n\t\tfn:   uintptr(unsafe.Pointer(&libc_gethostname)),\n\t\tn:    2,\n\t\targs: uintptr(unsafe.Pointer(&args[0])),\n\t}\n\tentersyscallblock()\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\texitsyscall()\n\tif call.r1 != 0 {\n\t\treturn \"\", call.err\n\t}\n\tcname[_MAXHOSTNAMELEN-1] = 0\n\treturn gostringnocopy(&cname[0]), 0\n}\n\n//go:nosplit\nfunc syscall_ioctl(fd, req, arg uintptr) (err uintptr) {\n\tcall := libcall{\n\t\tfn:   uintptr(unsafe.Pointer(&libc_ioctl)),\n\t\tn:    3,\n\t\targs: uintptr(unsafe.Pointer(&fd)),\n\t}\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\treturn call.err\n}\n\nfunc syscall_pipe() (r, w, err uintptr) {\n\tcall := libcall{\n\t\tfn:   uintptr(unsafe.Pointer(&pipe1)),\n\t\tn:    0,\n\t\targs: uintptr(unsafe.Pointer(&pipe1)), // it's unused but must be non-nil, otherwise crashes\n\t}\n\tentersyscallblock()\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\texitsyscall()\n\treturn call.r1, call.r2, call.err\n}\n\n// This is syscall.RawSyscall, it exists to satisfy some build dependency,\n// but it doesn't work correctly.\n//\n// DO NOT USE!\n//\n// TODO(aram): make this panic once we stop calling fcntl(2) in net using it.\nfunc syscall_rawsyscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr) {\n\tcall := libcall{\n\t\tfn:   uintptr(unsafe.Pointer(&libc_syscall)),\n\t\tn:    4,\n\t\targs: uintptr(unsafe.Pointer(&trap)),\n\t}\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\treturn call.r1, call.r2, call.err\n}\n\n//go:nosplit\nfunc syscall_setgid(gid uintptr) (err uintptr) {\n\tcall := libcall{\n\t\tfn:   uintptr(unsafe.Pointer(&libc_setgid)),\n\t\tn:    1,\n\t\targs: uintptr(unsafe.Pointer(&gid)),\n\t}\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\treturn call.err\n}\n\n//go:nosplit\nfunc syscall_setgroups(ngid, gid uintptr) (err uintptr) {\n\tcall := libcall{\n\t\tfn:   uintptr(unsafe.Pointer(&libc_setgroups)),\n\t\tn:    2,\n\t\targs: uintptr(unsafe.Pointer(&ngid)),\n\t}\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\treturn call.err\n}\n\n//go:nosplit\nfunc syscall_setsid() (pid, err uintptr) {\n\tcall := libcall{\n\t\tfn:   uintptr(unsafe.Pointer(&libc_setsid)),\n\t\tn:    0,\n\t\targs: uintptr(unsafe.Pointer(&libc_setsid)), // it's unused but must be non-nil, otherwise crashes\n\t}\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\treturn call.r1, call.err\n}\n\n//go:nosplit\nfunc syscall_setuid(uid uintptr) (err uintptr) {\n\tcall := libcall{\n\t\tfn:   uintptr(unsafe.Pointer(&libc_setuid)),\n\t\tn:    1,\n\t\targs: uintptr(unsafe.Pointer(&uid)),\n\t}\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\treturn call.err\n}\n\n//go:nosplit\nfunc syscall_setpgid(pid, pgid uintptr) (err uintptr) {\n\tcall := libcall{\n\t\tfn:   uintptr(unsafe.Pointer(&libc_setpgid)),\n\t\tn:    2,\n\t\targs: uintptr(unsafe.Pointer(&pid)),\n\t}\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\treturn call.err\n}\n\n// This is syscall.Syscall, it exists to satisfy some build dependency,\n// but it doesn't work correctly.\n//\n// DO NOT USE!\n//\n// TODO(aram): make this panic once we stop calling fcntl(2) in net using it.\nfunc syscall_syscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr) {\n\tcall := libcall{\n\t\tfn:   uintptr(unsafe.Pointer(&libc_syscall)),\n\t\tn:    4,\n\t\targs: uintptr(unsafe.Pointer(&trap)),\n\t}\n\tentersyscallblock()\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\texitsyscall()\n\treturn call.r1, call.r2, call.err\n}\n\nfunc syscall_wait4(pid uintptr, wstatus *uint32, options uintptr, rusage unsafe.Pointer) (wpid int, err uintptr) {\n\tcall := libcall{\n\t\tfn:   uintptr(unsafe.Pointer(&libc_wait4)),\n\t\tn:    4,\n\t\targs: uintptr(unsafe.Pointer(&pid)),\n\t}\n\tentersyscallblock()\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\texitsyscall()\n\treturn int(call.r1), call.err\n}\n\n//go:nosplit\nfunc syscall_write(fd, buf, nbyte uintptr) (n, err uintptr) {\n\tcall := libcall{\n\t\tfn:   uintptr(unsafe.Pointer(&libc_write)),\n\t\tn:    3,\n\t\targs: uintptr(unsafe.Pointer(&fd)),\n\t}\n\tasmcgocall(unsafe.Pointer(&asmsysvicall6), unsafe.Pointer(&call))\n\treturn call.r1, call.err\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/runtime/cgo/gcc_openbsd_386.c": "// Copyright 2009 The Go Authors.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <pthread.h>\n#include <signal.h>\n#include <string.h>\n#include \"libcgo.h\"\n\nstatic void* threadentry(void*);\nstatic void (*setg_gcc)(void*);\n\n// TCB_SIZE is sizeof(struct thread_control_block),\n// as defined in /usr/src/lib/librthread/tcb.h\n#define TCB_SIZE (4 * sizeof(void *))\n#define TLS_SIZE (2 * sizeof(void *))\n\nvoid *__get_tcb(void);\nvoid __set_tcb(void *);\n\nstatic int (*sys_pthread_create)(pthread_t *thread, const pthread_attr_t *attr,\n\tvoid *(*start_routine)(void *), void *arg);\n\nstruct thread_args {\n\tvoid *(*func)(void *);\n\tvoid *arg;\n};\n\nstatic void\ntcb_fixup(int mainthread)\n{\n\tvoid *newtcb, *oldtcb;\n\n\t// The OpenBSD ld.so(1) does not currently support PT_TLS. As a result,\n\t// we need to allocate our own TLS space while preserving the existing\n\t// TCB that has been setup via librthread.\n\n\tnewtcb = malloc(TCB_SIZE + TLS_SIZE);\n\tif(newtcb == NULL)\n\t\tabort();\n\n\t// The signal trampoline expects the TLS slots to be zeroed.\n\tbzero(newtcb, TLS_SIZE);\n\n\toldtcb = __get_tcb();\n\tbcopy(oldtcb, newtcb + TLS_SIZE, TCB_SIZE);\n\t__set_tcb(newtcb + TLS_SIZE);\n\n\t// NOTE(jsing, minux): we can't free oldtcb without causing double-free\n\t// problem. so newtcb will be memory leaks. Get rid of this when OpenBSD\n\t// has proper support for PT_TLS.\n}\n\nstatic void *\nthread_start_wrapper(void *arg)\n{\n\tstruct thread_args args = *(struct thread_args *)arg;\n\n\tfree(arg);\n\ttcb_fixup(0);\n\n\treturn args.func(args.arg);\n}\n\nstatic void init_pthread_wrapper(void) {\n\tvoid *handle;\n\n\t// Locate symbol for the system pthread_create function.\n\thandle = dlopen(\"libpthread.so\", RTLD_LAZY);\n\tif(handle == NULL) {\n\t\tfprintf(stderr, \"runtime/cgo: dlopen failed to load libpthread: %s\\n\", dlerror());\n\t\tabort();\n\t}\n\tsys_pthread_create = dlsym(handle, \"pthread_create\");\n\tif(sys_pthread_create == NULL) {\n\t\tfprintf(stderr, \"runtime/cgo: dlsym failed to find pthread_create: %s\\n\", dlerror());\n\t\tabort();\n\t}\n\tdlclose(handle);\n}\n\nstatic pthread_once_t init_pthread_wrapper_once = PTHREAD_ONCE_INIT;\n\nint\npthread_create(pthread_t *thread, const pthread_attr_t *attr,\n\tvoid *(*start_routine)(void *), void *arg)\n{\n\tstruct thread_args *p;\n\n\t// we must initialize our wrapper in pthread_create, because it is valid to call\n\t// pthread_create in a static constructor, and in fact, our test for issue 9456\n\t// does just that.\n\tif(pthread_once(&init_pthread_wrapper_once, init_pthread_wrapper) != 0) {\n\t\tfprintf(stderr, \"runtime/cgo: failed to initialize pthread_create wrapper\\n\");\n\t\tabort();\n\t}\n\n\tp = malloc(sizeof(*p));\n\tif(p == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\tp->func = start_routine;\n\tp->arg = arg;\n\n\treturn sys_pthread_create(thread, attr, thread_start_wrapper, p);\n}\n\nvoid\nx_cgo_init(G *g, void (*setg)(void*))\n{\n\tpthread_attr_t attr;\n\tsize_t size;\n\n\tsetg_gcc = setg;\n\tpthread_attr_init(&attr);\n\tpthread_attr_getstacksize(&attr, &size);\n\tg->stacklo = (uintptr)&attr - size + 4096;\n\tpthread_attr_destroy(&attr);\n\n\tif(pthread_once(&init_pthread_wrapper_once, init_pthread_wrapper) != 0) {\n\t\tfprintf(stderr, \"runtime/cgo: failed to initialize pthread_create wrapper\\n\");\n\t\tabort();\n\t}\n\n\ttcb_fixup(1);\n}\n\n\nvoid\n_cgo_sys_thread_start(ThreadStart *ts)\n{\n\tpthread_attr_t attr;\n\tsigset_t ign, oset;\n\tpthread_t p;\n\tsize_t size;\n\tint err;\n\n\tsigfillset(&ign);\n\tpthread_sigmask(SIG_SETMASK, &ign, &oset);\n\n\tpthread_attr_init(&attr);\n\tpthread_attr_getstacksize(&attr, &size);\n\t// Leave stacklo=0 and set stackhi=size; mstack will do the rest.\n\tts->g->stackhi = size;\n\terr = sys_pthread_create(&p, &attr, threadentry, ts);\n\n\tpthread_sigmask(SIG_SETMASK, &oset, nil);\n\n\tif (err != 0) {\n\t\tfprintf(stderr, \"runtime/cgo: pthread_create failed: %s\\n\", strerror(err));\n\t\tabort();\n\t}\n}\n\nstatic void*\nthreadentry(void *v)\n{\n\tThreadStart ts;\n\n\ttcb_fixup(0);\n\n\tts = *(ThreadStart*)v;\n\tfree(v);\n\n\t/*\n\t * Set specific keys.\n\t */\n\tsetg_gcc((void*)ts.g);\n\n\tcrosscall_386(ts.fn);\n\treturn nil;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/runtime/cgo/gcc_openbsd_amd64.c": "// Copyright 2009 The Go Authors.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <pthread.h>\n#include <signal.h>\n#include <string.h>\n#include \"libcgo.h\"\n\nstatic void* threadentry(void*);\nstatic void (*setg_gcc)(void*);\n\n// TCB_SIZE is sizeof(struct thread_control_block),\n// as defined in /usr/src/lib/librthread/tcb.h\n#define TCB_SIZE (4 * sizeof(void *))\n#define TLS_SIZE (2 * sizeof(void *))\n\nvoid *__get_tcb(void);\nvoid __set_tcb(void *);\n\nstatic int (*sys_pthread_create)(pthread_t *thread, const pthread_attr_t *attr,\n\tvoid *(*start_routine)(void *), void *arg);\n\nstruct thread_args {\n\tvoid *(*func)(void *);\n\tvoid *arg;\n};\n\nstatic void\ntcb_fixup(int mainthread)\n{\n\tvoid *newtcb, *oldtcb;\n\n\t// The OpenBSD ld.so(1) does not currently support PT_TLS. As a result,\n\t// we need to allocate our own TLS space while preserving the existing\n\t// TCB that has been setup via librthread.\n\n\tnewtcb = malloc(TCB_SIZE + TLS_SIZE);\n\tif(newtcb == NULL)\n\t\tabort();\n\n\t// The signal trampoline expects the TLS slots to be zeroed.\n\tbzero(newtcb, TLS_SIZE);\n\n\toldtcb = __get_tcb();\n\tbcopy(oldtcb, newtcb + TLS_SIZE, TCB_SIZE);\n\t__set_tcb(newtcb + TLS_SIZE);\n\n\t// NOTE(jsing, minux): we can't free oldtcb without causing double-free\n\t// problem. so newtcb will be memory leaks. Get rid of this when OpenBSD\n\t// has proper support for PT_TLS.\n}\n\nstatic void *\nthread_start_wrapper(void *arg)\n{\n\tstruct thread_args args = *(struct thread_args *)arg;\n\n\tfree(arg);\n\ttcb_fixup(0);\n\n\treturn args.func(args.arg);\n}\n\nstatic void init_pthread_wrapper(void) {\n\tvoid *handle;\n\n\t// Locate symbol for the system pthread_create function.\n\thandle = dlopen(\"libpthread.so\", RTLD_LAZY);\n\tif(handle == NULL) {\n\t\tfprintf(stderr, \"runtime/cgo: dlopen failed to load libpthread: %s\\n\", dlerror());\n\t\tabort();\n\t}\n\tsys_pthread_create = dlsym(handle, \"pthread_create\");\n\tif(sys_pthread_create == NULL) {\n\t\tfprintf(stderr, \"runtime/cgo: dlsym failed to find pthread_create: %s\\n\", dlerror());\n\t\tabort();\n\t}\n\tdlclose(handle);\n}\n\nstatic pthread_once_t init_pthread_wrapper_once = PTHREAD_ONCE_INIT;\n\nint\npthread_create(pthread_t *thread, const pthread_attr_t *attr,\n\tvoid *(*start_routine)(void *), void *arg)\n{\n\tstruct thread_args *p;\n\n\t// we must initialize our wrapper in pthread_create, because it is valid to call\n\t// pthread_create in a static constructor, and in fact, our test for issue 9456\n\t// does just that.\n\tif(pthread_once(&init_pthread_wrapper_once, init_pthread_wrapper) != 0) {\n\t\tfprintf(stderr, \"runtime/cgo: failed to initialize pthread_create wrapper\\n\");\n\t\tabort();\n\t}\n\n\tp = malloc(sizeof(*p));\n\tif(p == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\tp->func = start_routine;\n\tp->arg = arg;\n\n\treturn sys_pthread_create(thread, attr, thread_start_wrapper, p);\n}\n\nvoid\nx_cgo_init(G *g, void (*setg)(void*))\n{\n\tpthread_attr_t attr;\n\tsize_t size;\n\n\tsetg_gcc = setg;\n\tpthread_attr_init(&attr);\n\tpthread_attr_getstacksize(&attr, &size);\n\tg->stacklo = (uintptr)&attr - size + 4096;\n\tpthread_attr_destroy(&attr);\n\n\tif(pthread_once(&init_pthread_wrapper_once, init_pthread_wrapper) != 0) {\n\t\tfprintf(stderr, \"runtime/cgo: failed to initialize pthread_create wrapper\\n\");\n\t\tabort();\n\t}\n\n\ttcb_fixup(1);\n}\n\n\nvoid\n_cgo_sys_thread_start(ThreadStart *ts)\n{\n\tpthread_attr_t attr;\n\tsigset_t ign, oset;\n\tpthread_t p;\n\tsize_t size;\n\tint err;\n\n\tsigfillset(&ign);\n\tpthread_sigmask(SIG_SETMASK, &ign, &oset);\n\n\tpthread_attr_init(&attr);\n\tpthread_attr_getstacksize(&attr, &size);\n\n\t// Leave stacklo=0 and set stackhi=size; mstack will do the rest.\n\tts->g->stackhi = size;\n\terr = sys_pthread_create(&p, &attr, threadentry, ts);\n\n\tpthread_sigmask(SIG_SETMASK, &oset, nil);\n\n\tif (err != 0) {\n\t\tfprintf(stderr, \"runtime/cgo: pthread_create failed: %s\\n\", strerror(err));\n\t\tabort();\n\t}\n}\n\nstatic void*\nthreadentry(void *v)\n{\n\tThreadStart ts;\n\n\ttcb_fixup(0);\n\n\tts = *(ThreadStart*)v;\n\tfree(v);\n\n\t/*\n\t * Set specific keys.\n\t */\n\tsetg_gcc((void*)ts.g);\n\n\tcrosscall_amd64(ts.fn);\n\treturn nil;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/syscall/asm_solaris_amd64.s": "// Copyright 2014 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include \"textflag.h\"\n\n//\n// System calls for solaris/amd64 are implemented in ../runtime/syscall_solaris.go\n//\n\nTEXT \u00b7sysvicall6(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_sysvicall6(SB)\n\nTEXT \u00b7rawSysvicall6(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_rawsysvicall6(SB)\n\nTEXT \u00b7chdir(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_chdir(SB)\n\nTEXT \u00b7chroot1(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_chroot(SB)\n\nTEXT \u00b7close(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_close(SB)\n\nTEXT \u00b7dlopen(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_dlopen(SB)\n\nTEXT \u00b7dlclose(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_dlclose(SB)\n\nTEXT \u00b7dlsym(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_dlsym(SB)\n\nTEXT \u00b7execve(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_execve(SB)\n\nTEXT \u00b7exit(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_exit(SB)\n\nTEXT \u00b7fcntl1(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_fcntl(SB)\n\nTEXT \u00b7forkx(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_forkx(SB)\n\nTEXT \u00b7gethostname(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_gethostname(SB)\n\nTEXT \u00b7ioctl(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_ioctl(SB)\n\nTEXT \u00b7pipe(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_pipe(SB)\n\nTEXT \u00b7RawSyscall(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_rawsyscall(SB)\n\nTEXT \u00b7setgid(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_setgid(SB)\n\nTEXT \u00b7setgroups1(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_setgroups(SB)\n\nTEXT \u00b7setsid(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_setsid(SB)\n\nTEXT \u00b7setuid(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_setuid(SB)\n\nTEXT \u00b7setpgid(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_setpgid(SB)\n\nTEXT \u00b7Syscall(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_syscall(SB)\n\nTEXT \u00b7wait4(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_wait4(SB)\n\nTEXT \u00b7write1(SB),NOSPLIT,$0\n\tJMP\truntime\u00b7syscall_write(SB)\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/syscall/so_solaris.go": "// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage syscall\n\nimport (\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"unsafe\"\n)\n\n// soError describes reasons for shared library load failures.\ntype soError struct {\n\tErr     error\n\tObjName string\n\tMsg     string\n}\n\nfunc (e *soError) Error() string { return e.Msg }\n\n// Implemented in asm_solaris_amd64.s.\nfunc rawSysvicall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)\nfunc sysvicall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)\nfunc dlclose(handle uintptr) (err Errno)\nfunc dlopen(name *uint8, mode uintptr) (handle uintptr, err Errno)\nfunc dlsym(handle uintptr, name *uint8) (proc uintptr, err Errno)\n\n// A so implements access to a single shared library object.\ntype so struct {\n\tName   string\n\tHandle uintptr\n}\n\n// loadSO loads shared library file into memory.\nfunc loadSO(name string) (*so, error) {\n\tnamep, err := BytePtrFromString(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\th, e := dlopen(namep, 1) // RTLD_LAZY\n\tuse(unsafe.Pointer(namep))\n\tif e != 0 {\n\t\treturn nil, &soError{\n\t\t\tErr:     e,\n\t\t\tObjName: name,\n\t\t\tMsg:     \"Failed to load \" + name + \": \" + e.Error(),\n\t\t}\n\t}\n\td := &so{\n\t\tName:   name,\n\t\tHandle: uintptr(h),\n\t}\n\treturn d, nil\n}\n\n// mustLoadSO is like loadSO but panics if load operation fails.\nfunc mustLoadSO(name string) *so {\n\td, e := loadSO(name)\n\tif e != nil {\n\t\tpanic(e)\n\t}\n\treturn d\n}\n\n// FindProc searches shared library d for procedure named name and returns\n// *proc if found. It returns an error if the search fails.\nfunc (d *so) FindProc(name string) (*proc, error) {\n\tnamep, err := BytePtrFromString(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta, _ := dlsym(uintptr(d.Handle), namep)\n\tuse(unsafe.Pointer(namep))\n\tif a == 0 {\n\t\treturn nil, &soError{\n\t\t\tErr:     ENOSYS,\n\t\t\tObjName: name,\n\t\t\tMsg:     \"Failed to find \" + name + \" procedure in \" + d.Name,\n\t\t}\n\t}\n\tp := &proc{\n\t\tSO:   d,\n\t\tName: name,\n\t\taddr: a,\n\t}\n\treturn p, nil\n}\n\n// MustFindProc is like FindProc but panics if search fails.\nfunc (d *so) MustFindProc(name string) *proc {\n\tp, e := d.FindProc(name)\n\tif e != nil {\n\t\tpanic(e)\n\t}\n\treturn p\n}\n\n// Release unloads shared library d from memory.\nfunc (d *so) Release() (err error) {\n\treturn dlclose(d.Handle)\n}\n\n// A proc implements access to a procedure inside a shared library.\ntype proc struct {\n\tSO   *so\n\tName string\n\taddr uintptr\n}\n\n// Addr returns the address of the procedure represented by p.\n// The return value can be passed to Syscall to run the procedure.\nfunc (p *proc) Addr() uintptr {\n\treturn p.addr\n}\n\n// Call executes procedure p with arguments a. It will panic, if more then\n// 6 arguments are supplied.\n//\n// The returned error is always non-nil, constructed from the result of\n// GetLastError.  Callers must inspect the primary return value to decide\n// whether an error occurred (according to the semantics of the specific\n// function being called) before consulting the error. The error will be\n// guaranteed to contain syscall.Errno.\nfunc (p *proc) Call(a ...uintptr) (r1, r2 uintptr, lastErr error) {\n\tswitch len(a) {\n\tcase 0:\n\t\treturn sysvicall6(p.Addr(), uintptr(len(a)), 0, 0, 0, 0, 0, 0)\n\tcase 1:\n\t\treturn sysvicall6(p.Addr(), uintptr(len(a)), a[0], 0, 0, 0, 0, 0)\n\tcase 2:\n\t\treturn sysvicall6(p.Addr(), uintptr(len(a)), a[0], a[1], 0, 0, 0, 0)\n\tcase 3:\n\t\treturn sysvicall6(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], 0, 0, 0)\n\tcase 4:\n\t\treturn sysvicall6(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], 0, 0)\n\tcase 5:\n\t\treturn sysvicall6(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], 0)\n\tcase 6:\n\t\treturn sysvicall6(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5])\n\tdefault:\n\t\tpanic(\"Call \" + p.Name + \" with too many arguments \" + itoa(len(a)) + \".\")\n\t}\n\treturn\n}\n\n// A lazySO implements access to a single shared library.  It will delay\n// the load of the shared library until the first call to its Handle method\n// or to one of its lazyProc's Addr method.\ntype lazySO struct {\n\tmu   sync.Mutex\n\tso   *so // non nil once SO is loaded\n\tName string\n}\n\n// Load loads single shared file d.Name into memory. It returns an error if\n// fails.  Load will not try to load SO, if it is already loaded into memory.\nfunc (d *lazySO) Load() error {\n\t// Non-racy version of:\n\t// if d.so == nil {\n\tif atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&d.so))) == nil {\n\t\td.mu.Lock()\n\t\tdefer d.mu.Unlock()\n\t\tif d.so == nil {\n\t\t\tso, e := loadSO(d.Name)\n\t\t\tif e != nil {\n\t\t\t\treturn e\n\t\t\t}\n\t\t\t// Non-racy version of:\n\t\t\t// d.so = so\n\t\t\tatomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&d.so)), unsafe.Pointer(so))\n\t\t}\n\t}\n\treturn nil\n}\n\n// mustLoad is like Load but panics if search fails.\nfunc (d *lazySO) mustLoad() {\n\te := d.Load()\n\tif e != nil {\n\t\tpanic(e)\n\t}\n}\n\n// Handle returns d's module handle.\nfunc (d *lazySO) Handle() uintptr {\n\td.mustLoad()\n\treturn uintptr(d.so.Handle)\n}\n\n// NewProc returns a lazyProc for accessing the named procedure in the SO d.\nfunc (d *lazySO) NewProc(name string) *lazyProc {\n\treturn &lazyProc{l: d, Name: name}\n}\n\n// newLazySO creates new lazySO associated with SO file.\nfunc newLazySO(name string) *lazySO {\n\treturn &lazySO{Name: name}\n}\n\n// A lazyProc implements access to a procedure inside a lazySO.\n// It delays the lookup until the Addr method is called.\ntype lazyProc struct {\n\tmu   sync.Mutex\n\tName string\n\tl    *lazySO\n\tproc *proc\n}\n\n// Find searches the shared library for procedure named p.Name. It returns an\n// error if search fails. Find will not search procedure, if it is already\n// found and loaded into memory.\nfunc (p *lazyProc) Find() error {\n\t// Non-racy version of:\n\t// if p.proc == nil {\n\tif atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&p.proc))) == nil {\n\t\tp.mu.Lock()\n\t\tdefer p.mu.Unlock()\n\t\tif p.proc == nil {\n\t\t\te := p.l.Load()\n\t\t\tif e != nil {\n\t\t\t\treturn e\n\t\t\t}\n\t\t\tproc, e := p.l.so.FindProc(p.Name)\n\t\t\tif e != nil {\n\t\t\t\treturn e\n\t\t\t}\n\t\t\t// Non-racy version of:\n\t\t\t// p.proc = proc\n\t\t\tatomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&p.proc)), unsafe.Pointer(proc))\n\t\t}\n\t}\n\treturn nil\n}\n\n// mustFind is like Find but panics if search fails.\nfunc (p *lazyProc) mustFind() {\n\te := p.Find()\n\tif e != nil {\n\t\tpanic(e)\n\t}\n}\n\n// Addr returns the address of the procedure represented by p.\n// The return value can be passed to Syscall to run the procedure.\nfunc (p *lazyProc) Addr() uintptr {\n\tp.mustFind()\n\treturn p.proc.Addr()\n}\n\n// Call executes procedure p with arguments a. It will panic, if more then\n// 6 arguments are supplied.\n//\n// The returned error is always non-nil, constructed from the result of\n// GetLastError.  Callers must inspect the primary return value to decide\n// whether an error occurred (according to the semantics of the specific\n// function being called) before consulting the error. The error will be\n// guaranteed to contain syscall.Errno.\nfunc (p *lazyProc) Call(a ...uintptr) (r1, r2 uintptr, lastErr error) {\n\tp.mustFind()\n\treturn p.proc.Call(a...)\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/cmd/ld/lib.c": "// Derived from Inferno utils/6l/obj.c and utils/6l/span.c\n// http://code.google.com/p/inferno-os/source/browse/utils/6l/obj.c\n// http://code.google.com/p/inferno-os/source/browse/utils/6l/span.c\n//\n//\tCopyright \u00a9 1994-1999 Lucent Technologies Inc.  All rights reserved.\n//\tPortions Copyright \u00a9 1995-1997 C H Forsyth (forsyth@terzarima.net)\n//\tPortions Copyright \u00a9 1997-1999 Vita Nuova Limited\n//\tPortions Copyright \u00a9 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)\n//\tPortions Copyright \u00a9 2004,2006 Bruce Ellis\n//\tPortions Copyright \u00a9 2005-2007 C H Forsyth (forsyth@terzarima.net)\n//\tRevisions Copyright \u00a9 2000-2007 Lucent Technologies Inc. and others\n//\tPortions Copyright \u00a9 2009 The Go Authors.  All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n#include\t\"l.h\"\n#include\t\"lib.h\"\n#include\t\"../ld/elf.h\"\n#include\t\"../ld/dwarf.h\"\n#include\t\"../../runtime/stack.h\"\n#include\t\"../../runtime/funcdata.h\"\n\n#include\t<ar.h>\n#if !(defined(_WIN32) || defined(PLAN9))\n#include\t<sys/stat.h>\n#endif\n\nenum\n{\n\t// Whether to assume that the external linker is \"gold\"\n\t// (http://sourceware.org/ml/binutils/2008-03/msg00162.html).\n\tAssumeGoldLinker = 0,\n};\n\nint iconv(Fmt*);\n\nchar\tsymname[]\t= SYMDEF;\nchar\tpkgname[]\t= \"__.PKGDEF\";\nstatic int\tcout = -1;\n\nextern int\tversion;\n\n// Set if we see an object compiled by the host compiler that is not\n// from a package that is known to support internal linking mode.\nstatic int\texternalobj = 0;\n\nstatic\tvoid\thostlinksetup(void);\n\nchar*\tgoroot;\nchar*\tgoarch;\nchar*\tgoos;\nchar*\ttheline;\n\nvoid\nLflag(char *arg)\n{\n\tchar **p;\n\n\tif(ctxt->nlibdir >= ctxt->maxlibdir) {\n\t\tif (ctxt->maxlibdir == 0)\n\t\t\tctxt->maxlibdir = 8;\n\t\telse\n\t\t\tctxt->maxlibdir *= 2;\n\t\tp = erealloc(ctxt->libdir, ctxt->maxlibdir * sizeof(*p));\n\t\tctxt->libdir = p;\n\t}\n\tctxt->libdir[ctxt->nlibdir++] = arg;\n}\n\n/*\n * Unix doesn't like it when we write to a running (or, sometimes,\n * recently run) binary, so remove the output file before writing it.\n * On Windows 7, remove() can force a subsequent create() to fail.\n * S_ISREG() does not exist on Plan 9.\n */\nstatic void\nmayberemoveoutfile(void) \n{\n#if !(defined(_WIN32) || defined(PLAN9))\n\tstruct stat st;\n\tif(lstat(outfile, &st) == 0 && !S_ISREG(st.st_mode))\n\t\treturn;\n#endif\n\tremove(outfile);\n}\n\nvoid\nlibinit(void)\n{\n\tchar *suffix, *suffixsep;\n\n\tfuncalign = FuncAlign;\n\tfmtinstall('i', iconv);\n\tfmtinstall('Y', Yconv);\n\tfmtinstall('Z', Zconv);\n\tmywhatsys();\t// get goroot, goarch, goos\n\n\t// add goroot to the end of the libdir list.\n\tsuffix = \"\";\n\tsuffixsep = \"\";\n\tif(flag_installsuffix != nil) {\n\t\tsuffixsep = \"_\";\n\t\tsuffix = flag_installsuffix;\n\t} else if(flag_race) {\n\t\tsuffixsep = \"_\";\n\t\tsuffix = \"race\";\n\t}\n\tLflag(smprint(\"%s/pkg/%s_%s%s%s\", goroot, goos, goarch, suffixsep, suffix));\n\n\tmayberemoveoutfile();\n\tcout = create(outfile, 1, 0775);\n\tif(cout < 0) {\n\t\tdiag(\"cannot create %s: %r\", outfile);\n\t\terrorexit();\n\t}\n\n\tif(INITENTRY == nil) {\n\t\tINITENTRY = mal(strlen(goarch)+strlen(goos)+20);\n\t\tif(!flag_shared) {\n\t\t\tsprint(INITENTRY, \"_rt0_%s_%s\", goarch, goos);\n\t\t} else {\n\t\t\tsprint(INITENTRY, \"_rt0_%s_%s_lib\", goarch, goos);\n\t\t}\n\t}\n\tlinklookup(ctxt, INITENTRY, 0)->type = SXREF;\n}\n\nvoid\nerrorexit(void)\n{\n\tif(cout >= 0) {\n\t\t// For rmtemp run at atexit time on Windows.\n\t\tclose(cout);\n\t}\n\tif(nerrors) {\n\t\tif(cout >= 0)\n\t\t\tmayberemoveoutfile();\n\t\texits(\"error\");\n\t}\n\texits(0);\n}\n\nvoid\nloadinternal(char *name)\n{\n\tchar pname[1024];\n\tint i, found;\n\n\tfound = 0;\n\tfor(i=0; i<ctxt->nlibdir; i++) {\n\t\tsnprint(pname, sizeof pname, \"%s/%s.a\", ctxt->libdir[i], name);\n\t\tif(debug['v'])\n\t\t\tBprint(&bso, \"searching for %s.a in %s\\n\", name, pname);\n\t\tif(access(pname, AEXIST) >= 0) {\n\t\t\taddlibpath(ctxt, \"internal\", \"internal\", pname, name);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!found)\n\t\tBprint(&bso, \"warning: unable to find %s.a\\n\", name);\n}\n\nvoid\nloadlib(void)\n{\n\tint i, w, x;\n\tLSym *s, *tlsg;\n\tchar* cgostrsym;\n\n\tif(flag_shared) {\n\t\ts = linklookup(ctxt, \"runtime.islibrary\", 0);\n\t\ts->dupok = 1;\n\t\tadduint8(ctxt, s, 1);\n\t}\n\n\tloadinternal(\"runtime\");\n\tif(thechar == '5')\n\t\tloadinternal(\"math\");\n\tif(flag_race)\n\t\tloadinternal(\"runtime/race\");\n\n\tfor(i=0; i<ctxt->libraryp; i++) {\n\t\tif(debug['v'] > 1)\n\t\t\tBprint(&bso, \"%5.2f autolib: %s (from %s)\\n\", cputime(), ctxt->library[i].file, ctxt->library[i].objref);\n\t\tiscgo |= strcmp(ctxt->library[i].pkg, \"runtime/cgo\") == 0;\n\t\tobjfile(ctxt->library[i].file, ctxt->library[i].pkg);\n\t}\n\t\n\tif(linkmode == LinkExternal && !iscgo) {\n\t\t// This indicates a user requested -linkmode=external.\n\t\t// The startup code uses an import of runtime/cgo to decide\n\t\t// whether to initialize the TLS.  So give it one.  This could\n\t\t// be handled differently but it's an unusual case.\n\t\tloadinternal(\"runtime/cgo\");\n\t\tif(i < ctxt->libraryp)\n\t\t\tobjfile(ctxt->library[i].file, ctxt->library[i].pkg);\n\n\t\t// Pretend that we really imported the package.\n\t\ts = linklookup(ctxt, \"go.importpath.runtime/cgo.\", 0);\n\t\ts->type = SDATA;\n\t\ts->dupok = 1;\n\t\ts->reachable = 1;\n\n\t\t// Provided by the code that imports the package.\n\t\t// Since we are simulating the import, we have to provide this string.\n\t\tcgostrsym = \"go.string.\\\"runtime/cgo\\\"\";\n\t\tif(linkrlookup(ctxt, cgostrsym, 0) == nil) {\n\t\t\ts = linklookup(ctxt, cgostrsym, 0);\n\t\t\ts->type = SRODATA;\n\t\t\ts->reachable = 1;\n\t\t\taddstrdata(cgostrsym, \"runtime/cgo\");\n\t\t}\n\t}\n\n\tif(linkmode == LinkAuto) {\n\t\tif(iscgo && externalobj)\n\t\t\tlinkmode = LinkExternal;\n\t\telse\n\t\t\tlinkmode = LinkInternal;\n\n\t\t// Force external linking for android.\n\t\tif(strcmp(goos, \"android\") == 0)\n\t\t\tlinkmode = LinkExternal;\n\t}\n\n\tif(linkmode == LinkInternal) {\n\t\t// Drop all the cgo_import_static declarations.\n\t\t// Turns out we won't be needing them.\n\t\tfor(s = ctxt->allsym; s != S; s = s->allsym)\n\t\t\tif(s->type == SHOSTOBJ) {\n\t\t\t\t// If a symbol was marked both\n\t\t\t\t// cgo_import_static and cgo_import_dynamic,\n\t\t\t\t// then we want to make it cgo_import_dynamic\n\t\t\t\t// now.\n\t\t\t\tif(s->extname != nil && s->dynimplib != nil && s->cgoexport == 0) {\n\t\t\t\t\ts->type = SDYNIMPORT;\n\t\t\t\t} else\n\t\t\t\t\ts->type = 0;\n\t\t\t}\n\t}\n\t\n\ttlsg = linklookup(ctxt, \"runtime.tlsg\", 0);\n\ttlsg->type = STLSBSS;\n\ttlsg->size = PtrSize;\n\ttlsg->hide = 1;\n\ttlsg->reachable = 1;\n\tctxt->tlsg = tlsg;\n\n\t// Now that we know the link mode, trim the dynexp list.\n\tx = CgoExportDynamic;\n\tif(linkmode == LinkExternal)\n\t\tx = CgoExportStatic;\n\tw = 0;\n\tfor(i=0; i<ndynexp; i++)\n\t\tif(dynexp[i]->cgoexport & x)\n\t\t\tdynexp[w++] = dynexp[i];\n\tndynexp = w;\n\t\n\t// In internal link mode, read the host object files.\n\tif(linkmode == LinkInternal)\n\t\thostobjs();\n\telse\n\t\thostlinksetup();\n\n\t// We've loaded all the code now.\n\t// If there are no dynamic libraries needed, gcc disables dynamic linking.\n\t// Because of this, glibc's dynamic ELF loader occasionally (like in version 2.13)\n\t// assumes that a dynamic binary always refers to at least one dynamic library.\n\t// Rather than be a source of test cases for glibc, disable dynamic linking\n\t// the same way that gcc would.\n\t//\n\t// Exception: on OS X, programs such as Shark only work with dynamic\n\t// binaries, so leave it enabled on OS X (Mach-O) binaries.\n\t// Also leave it enabled on Solaris which doesn't support\n\t// statically linked binaries.\n\tif(!flag_shared && !havedynamic && HEADTYPE != Hdarwin && HEADTYPE != Hsolaris)\n\t\tdebug['d'] = 1;\n\t\n\timportcycles();\n}\n\n/*\n * look for the next file in an archive.\n * adapted from libmach.\n */\nstatic vlong\nnextar(Biobuf *bp, vlong off, struct ar_hdr *a)\n{\n\tint r;\n\tint32 arsize;\n\tchar *buf;\n\n\tif (off&01)\n\t\toff++;\n\tBseek(bp, off, 0);\n\tbuf = Brdline(bp, '\\n');\n\tr = Blinelen(bp);\n\tif(buf == nil) {\n\t\tif(r == 0)\n\t\t\treturn 0;\n\t\treturn -1;\n\t}\n\tif(r != SAR_HDR)\n\t\treturn -1;\n\tmemmove(a, buf, SAR_HDR);\n\tif(strncmp(a->fmag, ARFMAG, sizeof a->fmag))\n\t\treturn -1;\n\tarsize = strtol(a->size, 0, 0);\n\tif (arsize&1)\n\t\tarsize++;\n\treturn arsize + r;\n}\n\nvoid\nobjfile(char *file, char *pkg)\n{\n\tvlong off, l;\n\tBiobuf *f;\n\tchar magbuf[SARMAG];\n\tchar pname[150];\n\tstruct ar_hdr arhdr;\n\n\tpkg = smprint(\"%i\", pkg);\n\n\tif(debug['v'] > 1)\n\t\tBprint(&bso, \"%5.2f ldobj: %s (%s)\\n\", cputime(), file, pkg);\n\tBflush(&bso);\n\tf = Bopen(file, 0);\n\tif(f == nil) {\n\t\tdiag(\"cannot open file: %s\", file);\n\t\terrorexit();\n\t}\n\tl = Bread(f, magbuf, SARMAG);\n\tif(l != SARMAG || strncmp(magbuf, ARMAG, SARMAG)){\n\t\t/* load it as a regular file */\n\t\tl = Bseek(f, 0L, 2);\n\t\tBseek(f, 0L, 0);\n\t\tldobj(f, pkg, l, file, file, FileObj);\n\t\tBterm(f);\n\t\tfree(pkg);\n\t\treturn;\n\t}\n\t\n\t/* skip over optional __.GOSYMDEF and process __.PKGDEF */\n\toff = Boffset(f);\n\tl = nextar(f, off, &arhdr);\n\tif(l <= 0) {\n\t\tdiag(\"%s: short read on archive file symbol header\", file);\n\t\tgoto out;\n\t}\n\tif(strncmp(arhdr.name, symname, strlen(symname)) == 0) {\n\t\toff += l;\n\t\tl = nextar(f, off, &arhdr);\n\t\tif(l <= 0) {\n\t\t\tdiag(\"%s: short read on archive file symbol header\", file);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif(strncmp(arhdr.name, pkgname, strlen(pkgname))) {\n\t\tdiag(\"%s: cannot find package header\", file);\n\t\tgoto out;\n\t}\n\toff += l;\n\n\tif(debug['u'])\n\t\tldpkg(f, pkg, atolwhex(arhdr.size), file, Pkgdef);\n\n\t/*\n\t * load all the object files from the archive now.\n\t * this gives us sequential file access and keeps us\n\t * from needing to come back later to pick up more\n\t * objects.  it breaks the usual C archive model, but\n\t * this is Go, not C.  the common case in Go is that\n\t * we need to load all the objects, and then we throw away\n\t * the individual symbols that are unused.\n\t *\n\t * loading every object will also make it possible to\n\t * load foreign objects not referenced by __.GOSYMDEF.\n\t */\n\tfor(;;) {\n\t\tl = nextar(f, off, &arhdr);\n\t\tif(l == 0)\n\t\t\tbreak;\n\t\tif(l < 0) {\n\t\t\tdiag(\"%s: malformed archive\", file);\n\t\t\tgoto out;\n\t\t}\n\t\toff += l;\n\n\t\tl = SARNAME;\n\t\twhile(l > 0 && arhdr.name[l-1] == ' ')\n\t\t\tl--;\n\t\tsnprint(pname, sizeof pname, \"%s(%.*s)\", file, utfnlen(arhdr.name, l), arhdr.name);\n\t\tl = atolwhex(arhdr.size);\n\t\tldobj(f, pkg, l, pname, file, ArchiveObj);\n\t}\n\nout:\n\tBterm(f);\n\tfree(pkg);\n}\n\nstatic void\ndowrite(int fd, char *p, int n)\n{\n\tint m;\n\t\n\twhile(n > 0) {\n\t\tm = write(fd, p, n);\n\t\tif(m <= 0) {\n\t\t\tctxt->cursym = S;\n\t\t\tdiag(\"write error: %r\");\n\t\t\terrorexit();\n\t\t}\n\t\tn -= m;\n\t\tp += m;\n\t}\n}\n\ntypedef struct Hostobj Hostobj;\n\nstruct Hostobj\n{\n\tvoid (*ld)(Biobuf*, char*, int64, char*);\n\tchar *pkg;\n\tchar *pn;\n\tchar *file;\n\tint64 off;\n\tint64 len;\n};\n\nHostobj *hostobj;\nint nhostobj;\nint mhostobj;\n\n// These packages can use internal linking mode.\n// Others trigger external mode.\nconst char *internalpkg[] = {\n\t\"crypto/x509\",\n\t\"net\",\n\t\"os/user\",\n\t\"runtime/cgo\",\n\t\"runtime/race\"\n};\n\nvoid\nldhostobj(void (*ld)(Biobuf*, char*, int64, char*), Biobuf *f, char *pkg, int64 len, char *pn, char *file)\n{\n\tint i, isinternal;\n\tHostobj *h;\n\n\tisinternal = 0;\n\tfor(i=0; i<nelem(internalpkg); i++) {\n\t\tif(strcmp(pkg, internalpkg[i]) == 0) {\n\t\t\tisinternal = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// DragonFly declares errno with __thread, which results in a symbol\n\t// type of R_386_TLS_GD or R_X86_64_TLSGD. The Go linker does not\n\t// currently know how to handle TLS relocations, hence we have to\n\t// force external linking for any libraries that link in code that\n\t// uses errno. This can be removed if the Go linker ever supports\n\t// these relocation types.\n\tif(HEADTYPE == Hdragonfly)\n\tif(strcmp(pkg, \"net\") == 0 || strcmp(pkg, \"os/user\") == 0)\n\t\tisinternal = 0;\n\n\tif(!isinternal)\n\t\texternalobj = 1;\n\n\tif(nhostobj >= mhostobj) {\n\t\tif(mhostobj == 0)\n\t\t\tmhostobj = 16;\n\t\telse\n\t\t\tmhostobj *= 2;\n\t\thostobj = erealloc(hostobj, mhostobj*sizeof hostobj[0]);\n\t}\n\th = &hostobj[nhostobj++];\n\th->ld = ld;\n\th->pkg = estrdup(pkg);\n\th->pn = estrdup(pn);\n\th->file = estrdup(file);\n\th->off = Boffset(f);\n\th->len = len;\n}\n\nvoid\nhostobjs(void)\n{\n\tint i;\n\tBiobuf *f;\n\tHostobj *h;\n\t\n\tfor(i=0; i<nhostobj; i++) {\n\t\th = &hostobj[i];\n\t\tf = Bopen(h->file, OREAD);\n\t\tif(f == nil) {\n\t\t\tctxt->cursym = S;\n\t\t\tdiag(\"cannot reopen %s: %r\", h->pn);\n\t\t\terrorexit();\n\t\t}\n\t\tBseek(f, h->off, 0);\n\t\th->ld(f, h->pkg, h->len, h->pn);\n\t\tBterm(f);\n\t}\n}\n\n// provided by lib9\nint runcmd(char**);\nchar* mktempdir(void);\nvoid removeall(char*);\n\nstatic void\nrmtemp(void)\n{\n\tremoveall(tmpdir);\n}\n\nstatic void\nhostlinksetup(void)\n{\n\tchar *p;\n\n\tif(linkmode != LinkExternal)\n\t\treturn;\n\n\t// create temporary directory and arrange cleanup\n\tif(tmpdir == nil) {\n\t\ttmpdir = mktempdir();\n\t\tatexit(rmtemp);\n\t}\n\n\t// change our output to temporary object file\n\tclose(cout);\n\tp = smprint(\"%s/go.o\", tmpdir);\n\tcout = create(p, 1, 0775);\n\tif(cout < 0) {\n\t\tdiag(\"cannot create %s: %r\", p);\n\t\terrorexit();\n\t}\n\tfree(p);\n}\n\nvoid\nhostlink(void)\n{\n\tchar *p, **argv;\n\tint c, i, w, n, argc, len;\n\tHostobj *h;\n\tBiobuf *f;\n\tstatic char buf[64<<10];\n\n\tif(linkmode != LinkExternal || nerrors > 0)\n\t\treturn;\n\n\tc = 0;\n\tp = extldflags;\n\twhile(p != nil) {\n\t\twhile(*p == ' ')\n\t\t\tp++;\n\t\tif(*p == '\\0')\n\t\t\tbreak;\n\t\tc++;\n\t\tp = strchr(p + 1, ' ');\n\t}\n\n\targv = malloc((14+nhostobj+nldflag+c)*sizeof argv[0]);\n\targc = 0;\n\tif(extld == nil)\n\t\textld = \"gcc\";\n\targv[argc++] = extld;\n\tswitch(thechar){\n\tcase '8':\n\t\targv[argc++] = \"-m32\";\n\t\tbreak;\n\tcase '6':\n\t\targv[argc++] = \"-m64\";\n\t\tbreak;\n\tcase '5':\n\t\targv[argc++] = \"-marm\";\n\t\tbreak;\n\t}\n\tif(!debug['s'] && !debug_s) {\n\t\targv[argc++] = \"-gdwarf-2\"; \n\t} else {\n\t\targv[argc++] = \"-s\";\n\t}\n\tif(HEADTYPE == Hdarwin)\n\t\targv[argc++] = \"-Wl,-no_pie,-pagezero_size,4000000\";\n\tif(HEADTYPE == Hopenbsd)\n\t\targv[argc++] = \"-Wl,-nopie\";\n\t\n\tif(iself && AssumeGoldLinker)\n\t\targv[argc++] = \"-Wl,--rosegment\";\n\n\tif(flag_shared) {\n\t\targv[argc++] = \"-Wl,-Bsymbolic\";\n\t\targv[argc++] = \"-shared\";\n\t}\n\targv[argc++] = \"-o\";\n\targv[argc++] = outfile;\n\t\n\tif(rpath)\n\t\targv[argc++] = smprint(\"-Wl,-rpath,%s\", rpath);\n\n\t// Force global symbols to be exported for dlopen, etc.\n\tif(iself)\n\t\targv[argc++] = \"-rdynamic\";\n\n\tif(strstr(argv[0], \"clang\") != nil)\n\t\targv[argc++] = \"-Qunused-arguments\";\n\n\t// already wrote main object file\n\t// copy host objects to temporary directory\n\tfor(i=0; i<nhostobj; i++) {\n\t\th = &hostobj[i];\n\t\tf = Bopen(h->file, OREAD);\n\t\tif(f == nil) {\n\t\t\tctxt->cursym = S;\n\t\t\tdiag(\"cannot reopen %s: %r\", h->pn);\n\t\t\terrorexit();\n\t\t}\n\t\tBseek(f, h->off, 0);\n\t\tp = smprint(\"%s/%06d.o\", tmpdir, i);\n\t\targv[argc++] = p;\n\t\tw = create(p, 1, 0775);\n\t\tif(w < 0) {\n\t\t\tctxt->cursym = S;\n\t\t\tdiag(\"cannot create %s: %r\", p);\n\t\t\terrorexit();\n\t\t}\n\t\tlen = h->len;\n\t\twhile(len > 0 && (n = Bread(f, buf, sizeof buf)) > 0){\n\t\t\tif(n > len)\n\t\t\t\tn = len;\n\t\t\tdowrite(w, buf, n);\n\t\t\tlen -= n;\n\t\t}\n\t\tif(close(w) < 0) {\n\t\t\tctxt->cursym = S;\n\t\t\tdiag(\"cannot write %s: %r\", p);\n\t\t\terrorexit();\n\t\t}\n\t\tBterm(f);\n\t}\n\t\n\targv[argc++] = smprint(\"%s/go.o\", tmpdir);\n\tfor(i=0; i<nldflag; i++)\n\t\targv[argc++] = ldflag[i];\n\n\tp = extldflags;\n\twhile(p != nil) {\n\t\twhile(*p == ' ')\n\t\t\t*p++ = '\\0';\n\t\tif(*p == '\\0')\n\t\t\tbreak;\n\t\targv[argc++] = p;\n\n\t\t// clang, unlike GCC, passes -rdynamic to the linker\n\t\t// even when linking with -static, causing a linker\n\t\t// error when using GNU ld.  So take out -rdynamic if\n\t\t// we added it.  We do it in this order, rather than\n\t\t// only adding -rdynamic later, so that -extldflags\n\t\t// can override -rdynamic without using -static.\n\t\tif(iself && strncmp(p, \"-static\", 7) == 0 && (p[7]==' ' || p[7]=='\\0')) {\n\t\t\tfor(i=0; i<argc; i++) {\n\t\t\t\tif(strcmp(argv[i], \"-rdynamic\") == 0)\n\t\t\t\t\targv[i] = \"-static\";\n\t\t\t}\n\t\t}\n\n\t\tp = strchr(p + 1, ' ');\n\t}\n\n\targv[argc] = nil;\n\n\tquotefmtinstall();\n\tif(debug['v']) {\n\t\tBprint(&bso, \"host link:\");\n\t\tfor(i=0; i<argc; i++)\n\t\t\tBprint(&bso, \" %q\", argv[i]);\n\t\tBprint(&bso, \"\\n\");\n\t\tBflush(&bso);\n\t}\n\n\tif(runcmd(argv) < 0) {\n\t\tctxt->cursym = S;\n\t\tdiag(\"%s: running %s failed: %r\", argv0, argv[0]);\n\t\terrorexit();\n\t}\n}\n\nvoid\nldobj(Biobuf *f, char *pkg, int64 len, char *pn, char *file, int whence)\n{\n\tchar *line;\n\tint n, c1, c2, c3, c4;\n\tuint32 magic;\n\tvlong import0, import1, eof;\n\tchar *t;\n\n\teof = Boffset(f) + len;\n\n\tpn = estrdup(pn);\n\n\tc1 = BGETC(f);\n\tc2 = BGETC(f);\n\tc3 = BGETC(f);\n\tc4 = BGETC(f);\n\tBungetc(f);\n\tBungetc(f);\n\tBungetc(f);\n\tBungetc(f);\n\n\tmagic = c1<<24 | c2<<16 | c3<<8 | c4;\n\tif(magic == 0x7f454c46) {\t// \\x7F E L F\n\t\tldhostobj(ldelf, f, pkg, len, pn, file);\n\t\treturn;\n\t}\n\tif((magic&~1) == 0xfeedface || (magic&~0x01000000) == 0xcefaedfe) {\n\t\tldhostobj(ldmacho, f, pkg, len, pn, file);\n\t\treturn;\n\t}\n\tif(c1 == 0x4c && c2 == 0x01 || c1 == 0x64 && c2 == 0x86) {\n\t\tldhostobj(ldpe, f, pkg, len, pn, file);\n\t\treturn;\n\t}\n\n\t/* check the header */\n\tline = Brdline(f, '\\n');\n\tif(line == nil) {\n\t\tif(Blinelen(f) > 0) {\n\t\t\tdiag(\"%s: not an object file\", pn);\n\t\t\treturn;\n\t\t}\n\t\tgoto eof;\n\t}\n\tn = Blinelen(f) - 1;\n\tline[n] = '\\0';\n\tif(strncmp(line, \"go object \", 10) != 0) {\n\t\tif(strlen(pn) > 3 && strcmp(pn+strlen(pn)-3, \".go\") == 0) {\n\t\t\tprint(\"%cl: input %s is not .%c file (use %cg to compile .go files)\\n\", thechar, pn, thechar, thechar);\n\t\t\terrorexit();\n\t\t}\n\t\tif(strcmp(line, thestring) == 0) {\n\t\t\t// old header format: just $GOOS\n\t\t\tdiag(\"%s: stale object file\", pn);\n\t\t\treturn;\n\t\t}\n\t\tdiag(\"%s: not an object file\", pn);\n\t\tfree(pn);\n\t\treturn;\n\t}\n\t\n\t// First, check that the basic goos, goarch, and version match.\n\tt = smprint(\"%s %s %s \", goos, getgoarch(), getgoversion());\n\tline[n] = ' ';\n\tif(strncmp(line+10, t, strlen(t)) != 0 && !debug['f']) {\n\t\tline[n] = '\\0';\n\t\tdiag(\"%s: object is [%s] expected [%s]\", pn, line+10, t);\n\t\tfree(t);\n\t\tfree(pn);\n\t\treturn;\n\t}\n\t\n\t// Second, check that longer lines match each other exactly,\n\t// so that the Go compiler and write additional information\n\t// that must be the same from run to run.\n\tline[n] = '\\0';\n\tif(n-10 > strlen(t)) {\n\t\tif(theline == nil)\n\t\t\ttheline = estrdup(line+10);\n\t\telse if(strcmp(theline, line+10) != 0) {\n\t\t\tline[n] = '\\0';\n\t\t\tdiag(\"%s: object is [%s] expected [%s]\", pn, line+10, theline);\n\t\t\tfree(t);\n\t\t\tfree(pn);\n\t\t\treturn;\n\t\t}\n\t}\n\tfree(t);\n\tline[n] = '\\n';\n\n\t/* skip over exports and other info -- ends with \\n!\\n */\n\timport0 = Boffset(f);\n\tc1 = '\\n';\t// the last line ended in \\n\n\tc2 = BGETC(f);\n\tc3 = BGETC(f);\n\twhile(c1 != '\\n' || c2 != '!' || c3 != '\\n') {\n\t\tc1 = c2;\n\t\tc2 = c3;\n\t\tc3 = BGETC(f);\n\t\tif(c3 == Beof)\n\t\t\tgoto eof;\n\t}\n\timport1 = Boffset(f);\n\n\tBseek(f, import0, 0);\n\tldpkg(f, pkg, import1 - import0 - 2, pn, whence);\t// -2 for !\\n\n\tBseek(f, import1, 0);\n\n\tldobjfile(ctxt, f, pkg, eof - Boffset(f), pn);\n\tfree(pn);\n\treturn;\n\neof:\n\tdiag(\"truncated object file: %s\", pn);\n\tfree(pn);\n}\n\nvoid\nzerosig(char *sp)\n{\n\tLSym *s;\n\n\ts = linklookup(ctxt, sp, 0);\n\ts->sig = 0;\n}\n\nvoid\nmywhatsys(void)\n{\n\tgoroot = getgoroot();\n\tgoos = getgoos();\n\tgoarch = getgoarch();\n\n\tif(strncmp(goarch, thestring, strlen(thestring)) != 0)\n\t\tsysfatal(\"cannot use %cc with GOARCH=%s\", thechar, goarch);\n}\n\nint\npathchar(void)\n{\n\treturn '/';\n}\n\nstatic\tuchar*\thunk;\nstatic\tuint32\tnhunk;\n#define\tNHUNK\t(10UL<<20)\n\nvoid*\nmal(uint32 n)\n{\n\tvoid *v;\n\n\tn = (n+7)&~7;\n\tif(n > NHUNK) {\n\t\tv = malloc(n);\n\t\tif(v == nil) {\n\t\t\tdiag(\"out of memory\");\n\t\t\terrorexit();\n\t\t}\n\t\tmemset(v, 0, n);\n\t\treturn v;\n\t}\n\tif(n > nhunk) {\n\t\thunk = malloc(NHUNK);\n\t\tif(hunk == nil) {\n\t\t\tdiag(\"out of memory\");\n\t\t\terrorexit();\n\t\t}\n\t\tnhunk = NHUNK;\n\t}\n\n\tv = hunk;\n\tnhunk -= n;\n\thunk += n;\n\n\tmemset(v, 0, n);\n\treturn v;\n}\n\nvoid\nunmal(void *v, uint32 n)\n{\n\tn = (n+7)&~7;\n\tif(hunk - n == v) {\n\t\thunk -= n;\n\t\tnhunk += n;\n\t}\n}\n\n// Copied from ../gc/subr.c:/^pathtoprefix; must stay in sync.\n/*\n * Convert raw string to the prefix that will be used in the symbol table.\n * Invalid bytes turn into %xx.\t Right now the only bytes that need\n * escaping are %, ., and \", but we escape all control characters too.\n *\n * If you edit this, edit ../gc/subr.c:/^pathtoprefix too.\n * If you edit this, edit ../../debug/goobj/read.go:/importPathToPrefix too.\n */\nstatic char*\npathtoprefix(char *s)\n{\n\tstatic char hex[] = \"0123456789abcdef\";\n\tchar *p, *r, *w, *l;\n\tint n;\n\n\t// find first character past the last slash, if any.\n\tl = s;\n\tfor(r=s; *r; r++)\n\t\tif(*r == '/')\n\t\t\tl = r+1;\n\n\t// check for chars that need escaping\n\tn = 0;\n\tfor(r=s; *r; r++)\n\t\tif(*r <= ' ' || (*r == '.' && r >= l) || *r == '%' || *r == '\"' || *r >= 0x7f)\n\t\t\tn++;\n\n\t// quick exit\n\tif(n == 0)\n\t\treturn s;\n\n\t// escape\n\tp = mal((r-s)+1+2*n);\n\tfor(r=s, w=p; *r; r++) {\n\t\tif(*r <= ' ' || (*r == '.' && r >= l) || *r == '%' || *r == '\"' || *r >= 0x7f) {\n\t\t\t*w++ = '%';\n\t\t\t*w++ = hex[(*r>>4)&0xF];\n\t\t\t*w++ = hex[*r&0xF];\n\t\t} else\n\t\t\t*w++ = *r;\n\t}\n\t*w = '\\0';\n\treturn p;\n}\n\nint\niconv(Fmt *fp)\n{\n\tchar *p;\n\n\tp = va_arg(fp->args, char*);\n\tif(p == nil) {\n\t\tfmtstrcpy(fp, \"<nil>\");\n\t\treturn 0;\n\t}\n\tp = pathtoprefix(p);\n\tfmtstrcpy(fp, p);\n\treturn 0;\n}\n\nSection*\naddsection(Segment *seg, char *name, int rwx)\n{\n\tSection **l;\n\tSection *sect;\n\t\n\tfor(l=&seg->sect; *l; l=&(*l)->next)\n\t\t;\n\tsect = mal(sizeof *sect);\n\tsect->rwx = rwx;\n\tsect->name = name;\n\tsect->seg = seg;\n\tsect->align = PtrSize; // everything is at least pointer-aligned\n\t*l = sect;\n\treturn sect;\n}\n\nuint16\nle16(uchar *b)\n{\n\treturn b[0] | b[1]<<8;\n}\n\nuint32\nle32(uchar *b)\n{\n\treturn b[0] | b[1]<<8 | b[2]<<16 | (uint32)b[3]<<24;\n}\n\nuint64\nle64(uchar *b)\n{\n\treturn le32(b) | (uint64)le32(b+4)<<32;\n}\n\nuint16\nbe16(uchar *b)\n{\n\treturn b[0]<<8 | b[1];\n}\n\nuint32\nbe32(uchar *b)\n{\n\treturn (uint32)b[0]<<24 | b[1]<<16 | b[2]<<8 | b[3];\n}\n\nuint64\nbe64(uchar *b)\n{\n\treturn (uvlong)be32(b)<<32 | be32(b+4);\n}\n\nEndian be = { be16, be32, be64 };\nEndian le = { le16, le32, le64 };\n\ntypedef struct Chain Chain;\nstruct Chain\n{\n\tLSym *sym;\n\tChain *up;\n\tint limit;  // limit on entry to sym\n};\n\nstatic int stkcheck(Chain*, int);\nstatic void stkprint(Chain*, int);\nstatic void stkbroke(Chain*, int);\nstatic LSym *morestack;\nstatic LSym *newstack;\n\nenum\n{\n\tHasLinkRegister = (thechar == '5'),\n};\n\n// TODO: Record enough information in new object files to\n// allow stack checks here.\n\nstatic int\ncallsize(void)\n{\n\tif(thechar == '5')\n\t\treturn 0;\n\treturn RegSize;\n}\n\nvoid\ndostkcheck(void)\n{\n\tChain ch;\n\tLSym *s;\n\t\n\tmorestack = linklookup(ctxt, \"runtime.morestack\", 0);\n\tnewstack = linklookup(ctxt, \"runtime.newstack\", 0);\n\n\t// Every splitting function ensures that there are at least StackLimit\n\t// bytes available below SP when the splitting prologue finishes.\n\t// If the splitting function calls F, then F begins execution with\n\t// at least StackLimit - callsize() bytes available.\n\t// Check that every function behaves correctly with this amount\n\t// of stack, following direct calls in order to piece together chains\n\t// of non-splitting functions.\n\tch.up = nil;\n\tch.limit = StackLimit - callsize();\n\n\t// Check every function, but do the nosplit functions in a first pass,\n\t// to make the printed failure chains as short as possible.\n\tfor(s = ctxt->textp; s != nil; s = s->next) {\n\t\t// runtime.racesymbolizethunk is called from gcc-compiled C\n\t\t// code running on the operating system thread stack.\n\t\t// It uses more than the usual amount of stack but that's okay.\n\t\tif(strcmp(s->name, \"runtime.racesymbolizethunk\") == 0)\n\t\t\tcontinue;\n\n\t\tif(s->nosplit) {\n\t\tctxt->cursym = s;\n\t\tch.sym = s;\n\t\tstkcheck(&ch, 0);\n\t}\n\t}\n\tfor(s = ctxt->textp; s != nil; s = s->next) {\n\t\tif(!s->nosplit) {\n\t\tctxt->cursym = s;\n\t\tch.sym = s;\n\t\tstkcheck(&ch, 0);\n\t}\n}\n}\n\nstatic int\nstkcheck(Chain *up, int depth)\n{\n\tChain ch, ch1;\n\tLSym *s;\n\tint limit;\n\tReloc *r, *endr;\n\tPciter pcsp;\n\t\n\tlimit = up->limit;\n\ts = up->sym;\n\t\n\t// Don't duplicate work: only need to consider each\n\t// function at top of safe zone once.\n\tif(limit == StackLimit-callsize()) {\n\t\tif(s->stkcheck)\n\t\treturn 0;\n\t\ts->stkcheck = 1;\n\t}\n\t\n\tif(depth > 100) {\n\t\tdiag(\"nosplit stack check too deep\");\n\t\tstkbroke(up, 0);\n\t\treturn -1;\n\t}\n\n\tif(s->external || s->pcln == nil) {\n\t\t// external function.\n\t\t// should never be called directly.\n\t\t// only diagnose the direct caller.\n\t\tif(depth == 1 && s->type != SXREF)\n\t\t\tdiag(\"call to external function %s\", s->name);\n\t\treturn -1;\n\t}\n\n\tif(limit < 0) {\n\t\tstkbroke(up, limit);\n\t\treturn -1;\n\t}\n\n\t// morestack looks like it calls functions,\n\t// but it switches the stack pointer first.\n\tif(s == morestack)\n\t\treturn 0;\n\n\tch.up = up;\n\t\n\t// Walk through sp adjustments in function, consuming relocs.\n\tr = s->r;\n\tendr = r + s->nr;\n\tfor(pciterinit(ctxt, &pcsp, &s->pcln->pcsp); !pcsp.done; pciternext(&pcsp)) {\n\t\t// pcsp.value is in effect for [pcsp.pc, pcsp.nextpc).\n\n\t\t// Check stack size in effect for this span.\n\t\tif(limit - pcsp.value < 0) {\n\t\t\tstkbroke(up, limit - pcsp.value);\n\t\t\treturn -1;\n\t\t}\n\n\t\t// Process calls in this span.\n\t\tfor(; r < endr && r->off < pcsp.nextpc; r++) {\n\t\t\tswitch(r->type) {\n\t\t\tcase R_CALL:\n\t\t\tcase R_CALLARM:\n\t\t\t\t// Direct call.\n\t\t\t\tch.limit = limit - pcsp.value - callsize();\n\t\t\t\tch.sym = r->sym;\n\t\t\t\tif(stkcheck(&ch, depth+1) < 0)\n\t\t\t\t\treturn -1;\n\n\t\t\t\t// If this is a call to morestack, we've just raised our limit back\n\t\t\t\t// to StackLimit beyond the frame size.\n\t\t\t\tif(strncmp(r->sym->name, \"runtime.morestack\", 17) == 0) {\n\t\t\t\t\tlimit = StackLimit + s->locals;\n\t\t\t\t\tif(thechar == '5')\n\t\t\t\t\t\tlimit += 4; // saved LR\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase R_CALLIND:\n\t\t\t\t// Indirect call.  Assume it is a call to a splitting function,\n\t\t\t\t// so we have to make sure it can call morestack.\n\t\t\t\t// Arrange the data structures to report both calls, so that\n\t\t\t\t// if there is an error, stkprint shows all the steps involved.\n\t\t\t\tch.limit = limit - pcsp.value - callsize();\n\t\t\t\tch.sym = nil;\n\t\t\t\tch1.limit = ch.limit - callsize(); // for morestack in called prologue\n\t\t\t\tch1.up = &ch;\n\t\t\t\tch1.sym = morestack;\n\t\t\t\tif(stkcheck(&ch1, depth+2) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t}\n\t\t\n\treturn 0;\n}\n\nstatic void\nstkbroke(Chain *ch, int limit)\n{\n\tdiag(\"nosplit stack overflow\");\n\tstkprint(ch, limit);\n}\n\nstatic void\nstkprint(Chain *ch, int limit)\n{\n\tchar *name;\n\n\tif(ch->sym)\n\t\tname = ch->sym->name;\n\telse\n\t\tname = \"function pointer\";\n\n\tif(ch->up == nil) {\n\t\t// top of chain.  ch->sym != nil.\n\t\tif(ch->sym->nosplit)\n\t\t\tprint(\"\\t%d\\tassumed on entry to %s\\n\", ch->limit, name);\n\t\telse\n\t\t\tprint(\"\\t%d\\tguaranteed after split check in %s\\n\", ch->limit, name);\n\t} else {\n\t\tstkprint(ch->up, ch->limit + (!HasLinkRegister)*PtrSize);\n\t\tif(!HasLinkRegister)\n\t\t\tprint(\"\\t%d\\ton entry to %s\\n\", ch->limit, name);\n\t}\n\tif(ch->limit != limit)\n\t\tprint(\"\\t%d\\tafter %s uses %d\\n\", limit, name, ch->limit - limit);\n}\n\nint\nYconv(Fmt *fp)\n{\n\tLSym *s;\n\tFmt fmt;\n\tint i;\n\tchar *str;\n\n\ts = va_arg(fp->args, LSym*);\n\tif (s == S) {\n\t\tfmtprint(fp, \"<nil>\");\n\t} else {\n\t\tfmtstrinit(&fmt);\n\t\tfmtprint(&fmt, \"%s @0x%08llx [%lld]\", s->name, (vlong)s->value, (vlong)s->size);\n\t\tfor (i = 0; i < s->size; i++) {\n\t\t\tif (!(i%8)) fmtprint(&fmt,  \"\\n\\t0x%04x \", i);\n\t\t\tfmtprint(&fmt, \"%02x \", s->p[i]);\n\t\t}\n\t\tfmtprint(&fmt, \"\\n\");\n\t\tfor (i = 0; i < s->nr; i++) {\n\t\t\tfmtprint(&fmt, \"\\t0x%04x[%x] %d %s[%llx]\\n\",\n\t\t\t      s->r[i].off,\n\t\t\t      s->r[i].siz,\n\t\t\t      s->r[i].type,\n\t\t\t      s->r[i].sym->name,\n\t\t\t      (vlong)s->r[i].add);\n\t\t}\n\t\tstr = fmtstrflush(&fmt);\n\t\tfmtstrcpy(fp, str);\n\t\tfree(str);\n\t}\n\n\treturn 0;\n}\n\nvlong coutpos;\n\nvoid\ncflush(void)\n{\n\tint n;\n\n\tif(cbpmax < cbp)\n\t\tcbpmax = cbp;\n\tn = cbpmax - buf.cbuf;\n\tdowrite(cout, buf.cbuf, n);\n\tcoutpos += n;\n\tcbp = buf.cbuf;\n\tcbc = sizeof(buf.cbuf);\n\tcbpmax = cbp;\n}\n\nvlong\ncpos(void)\n{\n\treturn coutpos + cbp - buf.cbuf;\n}\n\nvoid\ncseek(vlong p)\n{\n\tvlong start;\n\tint delta;\n\n\tif(cbpmax < cbp)\n\t\tcbpmax = cbp;\n\tstart = coutpos;\n\tif(start <= p && p <= start+(cbpmax - buf.cbuf)) {\n//print(\"cseek %lld in [%lld,%lld] (%lld)\\n\", p, start, start+sizeof(buf.cbuf), cpos());\n\t\tdelta = p - (start + cbp - buf.cbuf);\n\t\tcbp += delta;\n\t\tcbc -= delta;\n//print(\"now at %lld\\n\", cpos());\n\t\treturn;\n\t}\n\n\tcflush();\n\tseek(cout, p, 0);\n\tcoutpos = p;\n}\n\nvoid\ncwrite(void *buf, int n)\n{\n\tcflush();\n\tif(n <= 0)\n\t\treturn;\n\tdowrite(cout, buf, n);\n\tcoutpos += n;\n}\n\nvoid\nusage(void)\n{\n\tfprint(2, \"usage: %cl [options] main.%c\\n\", thechar, thechar);\n\tflagprint(2);\n\texits(\"usage\");\n}\n\nvoid\nsetheadtype(char *s)\n{\n\tint h;\n\t\n\th = headtype(s);\n\tif(h < 0) {\n\t\tfprint(2, \"unknown header type -H %s\\n\", s);\n\t\terrorexit();\n\t}\n\theadstring = s;\n\tHEADTYPE = headtype(s);\n}\n\nvoid\nsetinterp(char *s)\n{\n\tdebug['I'] = 1; // denote cmdline interpreter override\n\tinterpreter = s;\n}\n\nvoid\ndoversion(void)\n{\n\tprint(\"%cl version %s\\n\", thechar, getgoversion());\n\terrorexit();\n}\n\nvoid\ngenasmsym(void (*put)(LSym*, char*, int, vlong, vlong, int, LSym*))\n{\n\tAuto *a;\n\tLSym *s;\n\tint32 off;\n\n\t// These symbols won't show up in the first loop below because we\n\t// skip STEXT symbols. Normal STEXT symbols are emitted by walking textp.\n\ts = linklookup(ctxt, \"runtime.text\", 0);\n\tif(s->type == STEXT)\n\t\tput(s, s->name, 'T', s->value, s->size, s->version, 0);\n\ts = linklookup(ctxt, \"runtime.etext\", 0);\n\tif(s->type == STEXT)\n\t\tput(s, s->name, 'T', s->value, s->size, s->version, 0);\n\n\tfor(s=ctxt->allsym; s!=S; s=s->allsym) {\n\t\tif(s->hide || (s->name[0] == '.' && s->version == 0 && strcmp(s->name, \".rathole\") != 0))\n\t\t\tcontinue;\n\t\tswitch(s->type&SMASK) {\n\t\tcase SCONST:\n\t\tcase SRODATA:\n\t\tcase SSYMTAB:\n\t\tcase SPCLNTAB:\n\t\tcase SDATA:\n\t\tcase SNOPTRDATA:\n\t\tcase SELFROSECT:\n\t\tcase SMACHOGOT:\n\t\tcase STYPE:\n\t\tcase SSTRING:\n\t\tcase SGOSTRING:\n\t\tcase SWINDOWS:\n\t\t\tif(!s->reachable)\n\t\t\t\tcontinue;\n\t\t\tput(s, s->name, 'D', symaddr(s), s->size, s->version, s->gotype);\n\t\t\tcontinue;\n\n\t\tcase SBSS:\n\t\tcase SNOPTRBSS:\n\t\t\tif(!s->reachable)\n\t\t\t\tcontinue;\n\t\t\tif(s->np > 0)\n\t\t\t\tdiag(\"%s should not be bss (size=%d type=%d special=%d)\", s->name, (int)s->np, s->type, s->special);\n\t\t\tput(s, s->name, 'B', symaddr(s), s->size, s->version, s->gotype);\n\t\t\tcontinue;\n\n\t\tcase SFILE:\n\t\t\tput(nil, s->name, 'f', s->value, 0, s->version, 0);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tfor(s = ctxt->textp; s != nil; s = s->next) {\n\t\tput(s, s->name, 'T', s->value, s->size, s->version, s->gotype);\n\n\t\t// NOTE(ality): acid can't produce a stack trace without .frame symbols\n\t\tput(nil, \".frame\", 'm', s->locals+PtrSize, 0, 0, 0);\n\n\t\tfor(a=s->autom; a; a=a->link) {\n\t\t\t// Emit a or p according to actual offset, even if label is wrong.\n\t\t\t// This avoids negative offsets, which cannot be encoded.\n\t\t\tif(a->type != A_AUTO && a->type != A_PARAM)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// compute offset relative to FP\n\t\t\tif(a->type == A_PARAM)\n\t\t\t\toff = a->aoffset;\n\t\t\telse\n\t\t\t\toff = a->aoffset - PtrSize;\n\t\t\t\n\t\t\t// FP\n\t\t\tif(off >= 0) {\n\t\t\t\tput(nil, a->asym->name, 'p', off, 0, 0, a->gotype);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// SP\n\t\t\tif(off <= -PtrSize) {\n\t\t\t\tput(nil, a->asym->name, 'a', -(off+PtrSize), 0, 0, a->gotype);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Otherwise, off is addressing the saved program counter.\n\t\t\t// Something underhanded is going on. Say nothing.\n\t\t}\n\t}\n\tif(debug['v'] || debug['n'])\n\t\tBprint(&bso, \"%5.2f symsize = %ud\\n\", cputime(), symsize);\n\tBflush(&bso);\n}\n\nvlong\nsymaddr(LSym *s)\n{\n\tif(!s->reachable)\n\t\tdiag(\"unreachable symbol in symaddr - %s\", s->name);\n\treturn s->value;\n}\n\nvoid\nxdefine(char *p, int t, vlong v)\n{\n\tLSym *s;\n\n\ts = linklookup(ctxt, p, 0);\n\ts->type = t;\n\ts->value = v;\n\ts->reachable = 1;\n\ts->special = 1;\n}\n\nvlong\ndatoff(vlong addr)\n{\n\tif(addr >= segdata.vaddr)\n\t\treturn addr - segdata.vaddr + segdata.fileoff;\n\tif(addr >= segtext.vaddr)\n\t\treturn addr - segtext.vaddr + segtext.fileoff;\n\tdiag(\"datoff %#llx\", addr);\n\treturn 0;\n}\n\nvlong\nentryvalue(void)\n{\n\tchar *a;\n\tLSym *s;\n\n\ta = INITENTRY;\n\tif(*a >= '0' && *a <= '9')\n\t\treturn atolwhex(a);\n\ts = linklookup(ctxt, a, 0);\n\tif(s->type == 0)\n\t\treturn INITTEXT;\n\tif(s->type != STEXT)\n\t\tdiag(\"entry not text: %s\", s->name);\n\treturn s->value;\n}\n\nstatic void\nundefsym(LSym *s)\n{\n\tint i;\n\tReloc *r;\n\n\tctxt->cursym = s;\n\tfor(i=0; i<s->nr; i++) {\n\t\tr = &s->r[i];\n\t\tif(r->sym == nil) // happens for some external ARM relocs\n\t\t\tcontinue;\n\t\tif(r->sym->type == Sxxx || r->sym->type == SXREF)\n\t\t\tdiag(\"undefined: %s\", r->sym->name);\n\t\tif(!r->sym->reachable)\n\t\t\tdiag(\"use of unreachable symbol: %s\", r->sym->name);\n\t}\n}\n\nvoid\nundef(void)\n{\n\tLSym *s;\n\t\n\tfor(s = ctxt->textp; s != nil; s = s->next)\n\t\tundefsym(s);\n\tfor(s = datap; s != nil; s = s->next)\n\t\tundefsym(s);\n\tif(nerrors > 0)\n\t\terrorexit();\n}\n\nvoid\ncallgraph(void)\n{\n\tLSym *s;\n\tReloc *r;\n\tint i;\n\n\tif(!debug['c'])\n\t\treturn;\n\n\tfor(s = ctxt->textp; s != nil; s = s->next) {\n\t\tfor(i=0; i<s->nr; i++) {\n\t\t\tr = &s->r[i];\n\t\t\tif(r->sym == nil)\n\t\t\t\tcontinue;\n\t\t\tif((r->type == R_CALL || r->type == R_CALLARM) && r->sym->type == STEXT)\n\t\t\t\tBprint(&bso, \"%s calls %s\\n\", s->name, r->sym->name);\n\t\t}\n\t}\n}\n\nvoid\ndiag(char *fmt, ...)\n{\n\tchar buf[1024], *tn, *sep;\n\tva_list arg;\n\n\ttn = \"\";\n\tsep = \"\";\n\tif(ctxt->cursym != S) {\n\t\ttn = ctxt->cursym->name;\n\t\tsep = \": \";\n\t}\n\tva_start(arg, fmt);\n\tvseprint(buf, buf+sizeof(buf), fmt, arg);\n\tva_end(arg);\n\tprint(\"%s%s%s\\n\", tn, sep, buf);\n\n\tnerrors++;\n\tif(nerrors > 20) {\n\t\tprint(\"too many errors\\n\");\n\t\terrorexit();\n\t}\n}\n\nvoid\ncheckgo(void)\n{\n\tLSym *s;\n\tReloc *r;\n\tint i;\n\tint changed;\n\t\n\tif(!debug['C'])\n\t\treturn;\n\t\n\t// TODO(rsc,khr): Eventually we want to get to no Go-called C functions at all,\n\t// which would simplify this logic quite a bit.\n\n\t// Mark every Go-called C function with cfunc=2, recursively.\n\tdo {\n\t\tchanged = 0;\n\t\tfor(s = ctxt->textp; s != nil; s = s->next) {\n\t\t\tif(s->cfunc == 0 || (s->cfunc == 2 && s->nosplit)) {\n\t\t\t\tfor(i=0; i<s->nr; i++) {\n\t\t\t\t\tr = &s->r[i];\n\t\t\t\t\tif(r->sym == nil)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif((r->type == R_CALL || r->type == R_CALLARM) && r->sym->type == STEXT) {\n\t\t\t\t\t\tif(r->sym->cfunc == 1) {\n\t\t\t\t\t\t\tchanged = 1;\n\t\t\t\t\t\t\tr->sym->cfunc = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}while(changed);\n\n\t// Complain about Go-called C functions that can split the stack\n\t// (that can be preempted for garbage collection or trigger a stack copy).\n\tfor(s = ctxt->textp; s != nil; s = s->next) {\n\t\tif(s->cfunc == 0 || (s->cfunc == 2 && s->nosplit)) {\n\t\t\tfor(i=0; i<s->nr; i++) {\n\t\t\t\tr = &s->r[i];\n\t\t\t\tif(r->sym == nil)\n\t\t\t\t\tcontinue;\n\t\t\t\tif((r->type == R_CALL || r->type == R_CALLARM) && r->sym->type == STEXT) {\n\t\t\t\t\tif(s->cfunc == 0 && r->sym->cfunc == 2 && !r->sym->nosplit)\n\t\t\t\t\t\tprint(\"Go %s calls C %s\\n\", s->name, r->sym->name);\n\t\t\t\t\telse if(s->cfunc == 2 && s->nosplit && !r->sym->nosplit)\n\t\t\t\t\t\tprint(\"Go calls C %s calls %s\\n\", s->name, r->sym->name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/misc/cgo/test/issue4029.go": "// Copyright 2012 The Go Authors.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// +build !windows\n\npackage cgotest\n\n/*\n#include <dlfcn.h>\n#cgo linux LDFLAGS: -ldl\n*/\nimport \"C\"\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\n//export IMPIsOpaque\nfunc IMPIsOpaque() {\n\tfmt.Println(\"isOpaque\")\n}\n\n//export IMPInitWithFrame\nfunc IMPInitWithFrame() {\n\tfmt.Println(\"IInitWithFrame\")\n}\n\n//export IMPDrawRect\nfunc IMPDrawRect() {\n\tfmt.Println(\"drawRect:\")\n}\n\n//export IMPWindowResize\nfunc IMPWindowResize() {\n\tfmt.Println(\"windowDidResize:\")\n}\n\nfunc test4029(t *testing.T) {\n\tloadThySelf(t, \"IMPWindowResize\")\n\tloadThySelf(t, \"IMPDrawRect\")\n\tloadThySelf(t, \"IMPInitWithFrame\")\n\tloadThySelf(t, \"IMPIsOpaque\")\n}\n\nfunc loadThySelf(t *testing.T, symbol string) {\n\tthis_process := C.dlopen(nil, C.RTLD_NOW)\n\tif this_process == nil {\n\t\tt.Error(\"dlopen:\", C.GoString(C.dlerror()))\n\t\treturn\n\t}\n\tdefer C.dlclose(this_process)\n\n\tsymbol_address := C.dlsym(this_process, C.CString(symbol))\n\tif symbol_address == nil {\n\t\tt.Error(\"dlsym:\", C.GoString(C.dlerror()))\n\t\treturn\n\t}\n\tt.Log(symbol, symbol_address)\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/compress/bzip2/testdata/Mark.Twain-Tom.Sawyer.txt.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/compress/bzip2/testdata/e.txt.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/compress/gzip/testdata/issue6550.gz",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/regexp/testdata/re2-exhaustive.txt.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/encoding/json/testdata/code.json.gz",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-005.gray.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-001.separate.dc.progression.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-005.gray.q50.2x2.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-001.q50.440.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-001.q50.422.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-005.gray.q50.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-001.5bpp.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-005.gray.q50.2x2.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-001.separate.dc.progression.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-005.gray.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-001.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-001.q50.444.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-001.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-005.gray.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-001.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-001.q50.440.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-001.q50.420.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-001.q50.444.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-001.q50.422.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-001.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-005.gray.q50.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-001.q50.420.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/testdata/video-001.interlaced.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/benchPaletted.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/invalid-zlib.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/benchRGB-interlace.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/benchNRGBA-gradient.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/invalid-crc32.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/benchNRGBA-opaque.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/invalid-trunc.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/benchGray.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/benchRGB.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/invalid-noend.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/pngsuite/basn4a16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/pngsuite/basn0g04-31.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/pngsuite/basn2c08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/pngsuite/basn4a08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/pngsuite/basn0g08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/pngsuite/basn3p02.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/pngsuite/basn3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/pngsuite/basn0g02.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/pngsuite/basn0g04.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/pngsuite/basn0g16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/pngsuite/basn0g02-29.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/pngsuite/basn3p08-trns.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/pngsuite/basn3p01.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/pngsuite/basn6a16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/pngsuite/basn3p04-31i.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/pngsuite/basn0g01-30.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/pngsuite/basn3p04.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/pngsuite/basn2c16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/pngsuite/basn6a08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/image/png/testdata/pngsuite/basn0g01.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/runtime/race/race_darwin_amd64.syso",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/runtime/race/race_freebsd_amd64.syso",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/runtime/race/race_windows_amd64.syso",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/runtime/race/race_linux_amd64.syso",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/archive/zip/testdata/test-trailing-junk.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/archive/zip/testdata/symlink.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/archive/zip/testdata/crc32-not-streamed.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/archive/zip/testdata/go-with-datadesc-sig.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/archive/zip/testdata/readme.notzip",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/archive/zip/testdata/test.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/archive/zip/testdata/zip64.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/archive/zip/testdata/gophercolor16x16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/archive/zip/testdata/winxp.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/archive/zip/testdata/unix.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/archive/zip/testdata/go-no-datadesc-sig.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/archive/zip/testdata/dd.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/archive/zip/testdata/zip64-2.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/archive/zip/testdata/readme.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/archive/tar/testdata/writer-big.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/archive/tar/testdata/writer-big-long.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/archive/tar/testdata/v7.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/crypto/rsa/testdata/pss-vect.txt.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/crypto/ecdsa/testdata/SigVer.rsp.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/debug/elf/testdata/go-relocation-test-gcc441-x86.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/debug/elf/testdata/hello-world-core.gz",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/debug/elf/testdata/go-relocation-test-gcc482-aarch64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/debug/elf/testdata/gcc-amd64-openbsd-debug-with-rela.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/debug/elf/testdata/go-relocation-test-gcc441-x86-64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/debug/elf/testdata/go-relocation-test-gcc424-x86-64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/debug/elf/testdata/go-relocation-test-clang-x86.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/debug/dwarf/testdata/typedef.macho",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/debug/dwarf/testdata/typedef.elf",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/src/debug/dwarf/testdata/typedef.elf4",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/lib/time/zoneinfo.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/test/bench/shootout/mandelbrot.txt",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/misc/dashboard/codereview/static/gopherstamp.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/misc/dashboard/codereview/static/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/misc/chrome/gophertool/gopher.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/misc/makerelease/windows/images/gopher.ico",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/misc/makerelease/windows/images/Banner.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/misc/makerelease/windows/images/DialogLeft.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/misc/makerelease/windows/images/Dialog.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/misc/makerelease/darwin/Resources/bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/logo-153x55.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/go-logo-blue.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/go-logo-black.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/go-logo-white.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/share.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/sieve.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/help.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/bumper192x108.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/appenginegophercolor.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/gopherbw.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/project.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/bumper.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/bumper640x360.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/gophercolor.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/gophercolor16x16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/pkg.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/biplane.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/fiveyears.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/talks.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/appenginegopher.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/run.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/bumper480x270.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/doc.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/appenginelogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/frontpage.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/bumper320x180.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/pencil/gopherswrench.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/pencil/gophermega.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/pencil/gopherhat.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/pencil/gopherswim.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/pencil/gopherhelmet.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/gopher/pencil/gopherrunning.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-bootstrap-1.4-bootstrap-20170531-yun4t3iblausuyta5gwvjo6yty4br24r/spack-src/doc/codewalk/popout.png"
    ],
    "total_files": 4257
}