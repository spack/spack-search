{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-mpip-3.5-s4r4bia5kf6aikq7hpu4cuzcak22oovf/spack-src/configure.ac": "dnl Process this file with autoconf to produce a configure script.\ndnl $Id$\n\ndnl These two lines disable the cache.\ndefine([AC_CACHE_LOAD], )\ndefine([AC_CACHE_SAVE], )\n\nAC_INIT([mpiP],[3.5])\nAC_PREREQ(2.61)\nAC_CONFIG_HEADER(mpiPconfig.h)\nAC_CONFIG_AUX_DIR(bin)\n\nAC_CANONICAL_TARGET()\n\nAC_PREFIX_DEFAULT(\".\")\ncross_compiling=yes\nac_tool_warned=yes\necho\necho \"  Note: mpiP sets cross_compiling to yes to keep configure from failing in\"\necho \"        the case where test executables would need to be run as a parallel job.\"\necho\n\n\n#\n#  With specifications\n#\n\nAC_ARG_WITH(cc,\n\tAS_HELP_STRING(--with-cc,Gives the name of the C compiler to use.),\n\tCC=$withval\n)\n\nAC_ARG_WITH(cxx,\n\tAS_HELP_STRING(--with-cxx,Gives the name of the C++ compiler to use.),\n\tCXX=$withval\n)\n\nAC_ARG_WITH(f77,\n\tAS_HELP_STRING(--with-f77,Gives the name of the FORTRAN 77 compiler to use.),\n\tF77=$withval\n)\n\nAC_ARG_WITH(include,\n\tAS_HELP_STRING(--with-include,Specifies include directories (-Idir1 -Idir2).),\n\tCPPFLAGS=$withval\n\techo Using extra include directories: $withval\n)\n\nAC_ARG_WITH(ldflags,\n\tAS_HELP_STRING(--with-ldflags,Specifies ld flags (-L/usr/local/lib).),\n\tLDFLAGS=$withval\n\techo Using ld flags: $withval\n)\nAC_SUBST(LDFLAGS)\n\nAC_SUBST(CFLAGS)\nif test -z \"${FFLAGS}\" ; then\n  FFLAGS=${CFLAGS}\nfi\nAC_SUBST(FFLAGS)\n\nAC_ARG_WITH(libs,\n\tAS_HELP_STRING(--with-libs,Specifies libraries (-llib1 -llib2).),\n\tLIBS=$withval\n\techo Using extra libraries: $withval\n)\n\nAC_ARG_WITH(binutils-dir,\n\tAS_HELP_STRING(--with-binutils-dir,Base directory of binutils installation.),\n\tBINUTILS_DIR=$withval\n\tCPPFLAGS=\"${CPPFLAGS} -I${BINUTILS_DIR}/include\"\n\tLIBS=\"-L${BINUTILS_DIR}/lib ${LIBS}\"\n\techo Using binutils-dir: $withval\n\t,\n\tBINUTILS_DIR=/usr\n)\nAC_SUBST(BINUTILS_DIR)\n\nAC_ARG_WITH(libunwind,\n\tAS_HELP_STRING(--with-libunwind,Specify location of libunwind to merge.),\n\tLIBUNWIND_LOC=$withval\n\techo Using libunwind: $withval\n\t,\n\tLIBUNWIND_LOC=/usr/lib/libunwind.a\n)\nAC_SUBST(LIBUNWIND_LOC)\n\nAC_ARG_WITH(bin-type-flag,\n\tAS_HELP_STRING(--with-bin-type-flag,Binary format for AIX ar operations.),\n\tBIN_TYPE_FLAG=$withval\n\techo Using bin-type-flag: $withval\n\t,\n\tBIN_TYPE_FLAG=\n)\nAC_SUBST(BIN_TYPE_FLAG)\n\n#\n# Timer options\n#\nTIMER_OPTION=no\nAC_ARG_WITH(gettimeofday,\n\tAS_HELP_STRING(--with-gettimeofday,Use gettimeofday for timing.),\n\tAC_DEFINE([USE_GETTIMEOFDAY],[1],[Use gettimeofday for the timer])\n        USE_GETTIMEOFDAY=true\n\tTIMER_OPTION=yes\n\t,\n)\n\nAC_ARG_WITH(wtime,\n\tAS_HELP_STRING(--with-wtime,Use MPI_Wtime for timing.),\n\tAC_DEFINE([USE_WTIME],[1],[Use MPI_Wtime for timer])\n\tTIMER_OPTION=yes\n\t,\n)\n\nAC_ARG_WITH(clock_gettime,\n\tAS_HELP_STRING(--with-clock_gettime,Use clock_gettime for timing.),\n\tAC_DEFINE([USE_CLOCK_GETTIME], [1], [Use clock_gettime for timing])\n\tUSE_CLOCK_GETTIME=yes\n\tTIMER_OPTION=yes\n\t,\n)\n\nAC_ARG_WITH(rts_get_timebase,\n\tAS_HELP_STRING(--with-rts_get_timebase,Use rts_get_timebase for timing on BG/L systems (default for BG/L).),\n\tAC_DEFINE([USE_RTS_GET_TIMEBASE],[1],[Use RTS get timebase])\n\tUSE_RTS_GET_TIMEBASE=yes\n\tTIMER_OPTION=yes\n\t,\n        USE_RTS_TIMEBASE=no\n)\n\nAC_ARG_WITH(read_real_time,\n\tAS_HELP_STRING(--with-read_real_time,Use read_real_time for timing on AIX systems (default for AIX).),\n\tAC_DEFINE([USE_READ_REAL_TIME], [1], [Use read real time])\n\tUSE_READ_REAL_TIME=yes\n\tTIMER_OPTION=yes\n\t,\n        USE_READ_REAL_TIME=no\n)\n\nAC_ARG_WITH(rtc,\n\tAS_HELP_STRING(--with-rtc,Use _rtc for timing on CRAY X1 systems (default for X1).),\n\tAC_DEFINE([USE_RTC], [1], [Use RTC])\n\tUSE_RTC=yes\n\tTIMER_OPTION=yes\n\t,\n        USE_RTC=no\n)\n\nAC_ARG_WITH(dclock,\n\tAS_HELP_STRING(--with-dclock,Use Catamount dclock for timing.),\n\tAC_DEFINE([USE_DCLOCK], [1], [Use dlock])\n\tUSE_DCLOCK=yes\n\tTIMER_OPTION=yes\n\t,\n        USE_DCLOCK=no\n)\n\n\n#\n#  Enable / Disable specifications\n#\n\nDEFAULT_TARGS='${SHARED_C_TARGET}'\nENABLE_API_ONLY=no\nAC_ARG_ENABLE(api-only,\n\tAS_HELP_STRING(--enable-api-only,Only build the API library.),\n\tif test x\"$enableval\" = xyes ; then\n\t\tENABLE_API_ONLY=yes\n\t\techo Configuring for API library only.\n\t\tAC_DEFINE([ENABLE_API_ONLY], [1], [\"Only build API\"])\n\t\tDEFAULT_TARGS=\"API test\"\n\tfi\n\t,\n)\n\n\nif test \"$ENABLE_API_ONLY\" = no ; then\n\nENABLE_MPI_IO=yes\nAC_ARG_ENABLE(mpi-io,\n\tAS_HELP_STRING(--disable-mpi-io,Disable MPI-I/O reporting.),\n\tif test x\"$enableval\" = xno ; then\n\t\tENABLE_MPI_IO=no\n\t\techo Profiling of MPI I/O has been disabled.\n\tfi\n\t,\n)\nAC_SUBST(ENABLE_MPI_IO)\nfi\n\nif test x\"$ENABLE_API_ONLY\" = xno ; then\n\nENABLE_MPI_RMA=yes\nAC_ARG_ENABLE(mpi-rma,\n\tAS_HELP_STRING(--disable-mpi-rma,[Disable MPI RMA reporting.]),\n\tif test x\"$enableval\" = xno ; then\n\t\tENABLE_MPI_RMA=no\n\t\techo Profiling of MPI RMA has been disabled.\n\tfi\n\t,\n)\nAC_SUBST(ENABLE_MPI_RMA)\n\nENABLE_MPI_NONBLOCKINGCOLLECTIVES=yes\nAC_ARG_ENABLE(mpi-nbc,\n\tAS_HELP_STRING(--disable-mpi-nbc,[Disable MPI NONBLOCKINGCOLLECTIVES reporting.]),\n\tif test x\"$enableval\" = xno ; then\n\t\tENABLE_MPI_NONBLOCKINGCOLLECTIVES=no\n\t\techo Profiling of MPI NONBLOCKINGCOLLECTIVES has been disabled.\n\tfi\n\t,\n)\nAC_SUBST(ENABLE_MPI_NONBLOCKINGCOLLECTIVES)\nfi\n\nENABLE_BFD=yes\nAC_ARG_ENABLE(bfd,\n\tAS_HELP_STRING(--disable-bfd,Do not use GNU binutils libbfd for source lookup.),\n\tif test x\"$enableval\" = xno ; then\n\t\techo Use of libbfd has been disabled.\n\t\tENABLE_BFD=no SO_LOOKUP=no\n\tfi\n\t,\n)\n\nDISABLE_LIBUNWIND=no\nAC_ARG_ENABLE(libunwind,\n\tAS_HELP_STRING(--disable-libunwind,Do not use libunwind to generate stack traces.),\n\tif test x\"$enableval\" = xno ; then\n\t\tDISABLE_LIBUNWIND=yes\n\t\techo Use of libunwind has been disabled.\n\tfi\n\t,\n)\n\nDISABLE_SO_LOOKUP=no\nAC_ARG_ENABLE(so-lookup,\n\tAS_HELP_STRING(--disable-so-lookup,Disable functionality to attempt to find source info in shared objects.),\n\tif test x\"$enableval\" = xno ; then\n\t\tDISABLE_SO_LOOKUP=yes\n\t\techo Use of shared object source lookup has been disabled.\n\tfi\n\t,\n)\n\nUSE_SETJMP=no\nAC_ARG_ENABLE(setjmp,\n\tAS_HELP_STRING(--enable-setjmp,Use setjmp instead of glic backtrace() to generate stack traces.),\n\tif test x\"$enableval\" = xyes ; then\n\t\tUSE_SETJMP=yes\n    AC_DEFINE([USE_SETJMP], [1], [Use setjmp])\n\t\techo Setjmp will be used to generate stack traces.\n\tfi\n\t,\n)\n\nAC_ARG_ENABLE(fortranxlate,\n\tAS_HELP_STRING(--disable-fortranxlate,Disable translation of Fortran opaque objects.),\n\tif test \"$enable_fortranxlate\" = \"no\" ; then\n\t\tENABLE_FORTRAN_XLATE=no\n\t\t  echo Translation of FORTRAN opaque objects has been disabled.\n\telse\n\t\tENABLE_FORTRAN_XLATE=yes\n\t\techo Translation of FORTRAN opaque objects has been enabled.\n\tfi\n\t,\n\tENABLE_FORTRAN_XLATE=yes\n)\nAC_SUBST(ENABLE_FORTRAN_XLATE)\n\nENABLE_FORTRAN_WEAK_SYMS=no\nAC_ARG_ENABLE(fortranweak,\n        AS_HELP_STRING(--enable-fortranweak,Generate weak symbols for additional Fortran symbol name styles.),\n        if test \"$enable_fortranweak\" = \"no\" ; then\n                ENABLE_FORTRAN_WEAK_SYMS=no\n                  echo Generation of additional weak FORTRAN symbol names has been disabled.\n        else\n                ENABLE_FORTRAN_WEAK_SYMS=yes\n                AC_DEFINE([ENABLE_FORTRAN_WEAK_SYMS], [1], [Enable weak symbols for FORTRAN])\n                echo Generation of additional weak FORTRAN symbol names has been enabled.\n        fi\n        ,\n        ENABLE_FORTRAN_WEAK_SYMS=no\n)\nAC_SUBST(ENABLE_FORTRAN_WEAK_SYMS)\n\n\n\nAC_ARG_ENABLE(stackdepth,\n\tAS_HELP_STRING([--enable-stackdepth], [Specify maximum report stacktrace depth (default is 8).]),\n\tSTACKDEPTH=$enableval; \n    echo \"Maximum stacktrace depth is $STACKDEPTH\",\n\tSTACKDEPTH=8,\n)\nAC_DEFINE_UNQUOTED([MPIP_CALLSITE_REPORT_STACK_DEPTH_MAX], [$STACKDEPTH], [Stack depth of callsites in report])\nAC_SUBST(MPIP_CALLSITE_REPORT_STACK_DEPTH_MAX)\n\nAC_ARG_ENABLE(internal-stackdepth,\n\tAS_HELP_STRING([--enable-internal-stackdepth], [Specify number of internal stack frames (default is 3).]),\n\tMPIP_INTERNAL_STACK_DEPTH=$enableval; \n    echo \"Internal stacktrace depth is $MPIP_INTERNAL_STACK_DEPTH\",\n\tMPIP_INTERNAL_STACK_DEPTH=3,\n)\nAC_DEFINE_UNQUOTED([MPIP_INTERNAL_STACK_DEPTH], [$MPIP_INTERNAL_STACK_DEPTH], [Number of internal stack frames])\nAC_SUBST(MPIP_INTERNAL_STACK_DEPTH)\n\nAC_DEFINE([MPIP_CALLSITE_STACK_DEPTH_MAX], [(MPIP_CALLSITE_REPORT_STACK_DEPTH_MAX + MPIP_INTERNAL_STACK_DEPTH)], [Recorded stack depth of callsites])\nAC_SUBST(MPIP_CALLSITE_STACK_DEPTH_MAX)\n\nAC_ARG_ENABLE(maxargs,\n    AS_HELP_STRING(--enable-maxargs,Maximum number of command line arguments copied (default is 32).),\n    MPIP_COPIED_ARGS_MAX=$enableval\n    echo Maximum number of command line arguments copied is $MPIP_COPIED_ARGS_MAX\n    ,\n    MPIP_COPIED_ARGS_MAX=32\n)\nAC_DEFINE_UNQUOTED(MPIP_COPIED_ARGS_MAX, [$MPIP_COPIED_ARGS_MAX], [Maximum number of command line arguments copied])\n\nPC_LOOKUP_FILE=pc_lookup.c\nAC_ARG_ENABLE(dwarf,\n\tAS_HELP_STRING(--enable-dwarf,Use DWARF library for source lookup.),\n\tif test x\"$enableval\" = xyes ; then\n\t\techo \"Using DWARF library for symbol lookup; forcing --disable-bfd\"\n\t\tENABLE_BFD=no\n\t\tPC_LOOKUP_FILE=pc_lookup_dwarf.c\n\tfi ;\n\tUSE_LIBDWARF=yes\n\t,\n\tUSE_LIBDWARF=no\n)\nAC_SUBST(USE_LIBDWARF)\nAC_SUBST(PC_LOOKUP_FILE)\n\nUSE_GETARG=false\nAC_ARG_ENABLE(getarg,\n\tAS_HELP_STRING(--enable-getarg,Use getarg to get fortran command line args.),\n\tif test x\"$enableval\" = xyes ; then\n\t\tAC_DEFINE([USE_GETARG], [1], [Use getarg])\n\t\techo Use of getarg has been enabled\n\t\tUSE_GETARG=true\n\tfi\n\t,\n)\nAC_SUBST(USE_GETARG)\n\nAC_ARG_ENABLE(demangling,\n\tAS_HELP_STRING(--enable-demangling,[Specify GNU, IBM, or Compaq demangling support.]),\n\tDO_DEMANGLE=$enableval\n\techo $DO_DEMANGLE demangling enabled\n\t,\n\tDO_DEMANGLE=false\n)\nAC_SUBST(DO_DEMANGLE)\n\nAC_ARG_ENABLE(check-time,\n\tAS_HELP_STRING(--enable-check-time,Enable AIX check for negative time values.),\n\tif test x\"$enableval\" = xyes ; then\n\t\tAC_DEFINE([MPIP_CHECK_TIME], [1], [MPI check time])\n\t\techo AIX negative time value checking has been enabled\n\tfi\n\t,\n)\n\nAC_ARG_ENABLE(collective-report-default,\n\tAS_HELP_STRING(--enable-collective-report-default,Have mpiP default to low-memory-use collective report generation as opposed to collecting all data at a single task (see runtime flags -l and -s).),\n\tif test \"x$enableval\" = xyes ; then\n                AC_DEFINE([COLLECTIVE_REPORT_DEFAULT],[1], [\"Use collective reporting by default\"])\n\t\techo \"Using collective report as default.\"\n\tfi\n\t,\n)\n\nAC_DEFINE([DEFAULT_REPORT_FORMAT], [mpiPi_style_verbose], [Default report style])\nAC_ARG_ENABLE(concise-report-default,\n\tAS_HELP_STRING(--enable-concise-report-default,Have mpiP default to a concise summary report format. (see runtime flags -c and -v).),\n\tif test \"x$enableval\" = xyes ; then\n                AC_DEFINE([DEFAULT_REPORT_FORMAT], [mpiPi_style_concise],[The default format of the report])\n\t\techo \"Using concise report as default.\"\n\tfi\n\t,\n)\n\nAC_PROG_INSTALL\nAC_PROG_RANLIB\nif test \"x$AR\" = \"x\"; then\n   AR=ar\nfi\n\nAC_CHECK_PROG(HAVE_PYTHON,[python],[python],[no])\nif test \"x$HAVE_PYTHON\" == \"xno\" ; then\n  AC_MSG_ERROR([Python is required to build mpiP.])\nfi\n\nTEST_LIST=\n\n#  Test for available compilers\nC_IBM_MPI_WRAPPERS=\"mpixlc\"\nC_INTEL_MPI_WRAPPERS=\"mpiicc\"\nCXX_IBM_MPI_WRAPPERS=\"mpixlC\"\nCXX_INTEL_MPI_WRAPPERS=\"mpiicpc\"\nF77_IBM_MPI_WRAPPERS=\"mpixlf\"\nF77_INTEL_MPI_WRAPPERS=\"mpiifort\"\n\nif test \"$ENABLE_API_ONLY\" = no ; then\n  AC_CHECK_PROGS(CC,  $C_IBM_MPI_WRAPPERS $C_INTEL_MPI_WRAPPERS cmpicc mpcc mpicc gcc cc icc, mpicc)\n  AC_CHECK_PROGS(CXX, $CXX_IBM_MPI_WRAPPERS $CXX_INTEL_MPI_WRAPPERS mpiCC mpicxx cmpic++ c++ g++ CC cxx icc, mpicxx)\n  AC_CHECK_PROGS(F77, $F77_IBM_MPI_WRAPPERS $F77_INTEL_MPI_WRAPPERS mpifort mpif77 cmpifc xlf f77 g77 pgf77 fort ifc, mpifort)\n  AC_CHECK_PROGS(LAUNCH, poe jsrun srun prun mpirun mpiexec, mpirun)\nelse\n  AC_CHECK_PROGS(CC, xlc gcc cc icc, mpicc)\n  AC_CHECK_PROGS(CXX, xlC c++ g++ CC cxx icc, mpiCC)\n  AC_CHECK_PROGS(F77, xlf f77 g77 pgf77 fort ifc, mpif77)\n  LAUNCH=\"\\\\\\\"\\\\\\\"\"\n  TEST_LIST=\"api-test.exp\"\nfi\n\nAC_CHECK_LIB(m,sqrt)\n\nAC_CHECK_SIZEOF(void*)\n\nAC_MSG_CHECKING(PIC flags)\nif `$CC -fpic 2>&1 | grep 'warning' >/dev/null 2>&1` ; then\n  PIC_FLAGS=\"-DPIC\"\nelse\n  PIC_FLAGS=\"-fpic -DPIC\"\nfi\nAC_MSG_RESULT($PIC_FLAGS)\n\n#  Check for MPI, but also define AC_CHECK_DECL macro, since the next use\n#  would be within the bfd tests, making AC_CHECK_DECL undefined if not\n#  checking for bfd.\nAC_CHECK_DECL(MPI_Init,,AC_MSG_ERROR([\"Failed to find declaration for MPI_Init!\"]),[#include \"mpi.h\"])\n\nSOURCE_LOOKUP=none\n\n\nif test \"x$ENABLE_BFD\" = \"xyes\" ; then\n  BFD_AUX_LIBS=\n  AC_SEARCH_LIBS([dlopen], [dl dld]) # newer versions of binutils have a libdl dependency\n  AC_CHECK_LIB(z,inflate, BFD_AUX_LIBS=\"$BFD_AUX_LIBS -lz\")  # newer versions of binutils have a zlib dependency\n  AC_CHECK_LIB(intl,dcgettext__, BFD_AUX_LIBS=\"$BFD_AUX_LIBS -lintl\")  #libintl required only on some platforms, eg AIX\n  AC_CHECK_LIB(iberty,objalloc_create, BFD_AUX_LIBS=\"$BFD_AUX_LIBS -liberty\")\n  AC_CHECK_HEADER(bfd.h,\n    AC_CHECK_LIB(bfd,bfd_openr, LIBS=\"$LIBS -lbfd\", ENABLE_BFD=no, $BFD_AUX_LIBS)\n    AC_CHECK_DECL(bfd_get_section_size, AC_DEFINE([HAVE_BFD_GET_SECTION_SIZE], [1], [BFD get section size]), ,[#include \"bfd.h\"]) \n    AC_CHECK_DECL(bfd_get_section_vma, AC_DEFINE(HAVE_BFD_GET_SECTION_MACROS, [1], [BFD get section macros]), ,[#include \"bfd.h\"])\n    , ENABLE_BFD=no SO_LOOKUP=no\n  )\n  AC_CHECK_TYPE(bfd_boolean, ,AC_DEFINE([HAVE_BFD_BOOLEAN], [1], [BFD booleans]), [#include \"bfd.h\"])\n  if test \"x$ENABLE_BFD\" = \"xyes\" ; then\n    AC_CHECK_HEADER(demangle.h, [AC_DEFINE([HAVE_DEMANGLE_H], [1], [Have demangling]) if test \"x$DO_DEMANGLE\" = xfalse ; then DO_DEMANGLE=GNU ; fi])\n    LIBS=\"$LIBS $BFD_AUX_LIBS\"\n    AC_DEFINE([ENABLE_BFD], [1], [Enable BFD library for the PC to source lookups])\n    SOURCE_LOOKUP=bfd\n  fi\n\nelse\n  if test x$USE_LIBDWARF = xyes ; then\n    AC_CHECK_LIB(elf, elf_begin, \n      LIBELF_FOUND=yes, \n      ELFDWARF_ERR=\"failed to find libelf.\" ; LIBELF_FOUND=no\n      )\n    AC_CHECK_LIB(dwarf, dwarf_init, \n      LIBDWARF_FOUND=yes, \n      ELFDWARF_ERR=\"failed to find libdwarf.\" ; LIBDWARF_FOUND=no, [-lelf]\n      )\n    echo $ECHO_N \"checking for libelf/libdwarf...\" $ECHO_C\n    if test x$LIBELF_FOUND = xyes -a x$LIBDWARF_FOUND = xyes ; then\n      LIBS=\"${LIBS} -ldwarf -lelf\"\n      AC_DEFINE([USE_LIBDWARF], [1], [Use libdwarf])\n      echo \" found libelf/libdwarf\"\n      SOURCE_LOOKUP=libelf/libdwarf\n      SO_LOOKUP=no\n    else\n      echo \" $ELFDWARF_ERR Not using libelf/libdwarf\"\n    fi\n  fi\nfi\n\nif test \"$ENABLE_API_ONLY\" = no ; then\n  AC_CHECK_LIB(mpi,MPIR_ToPointer,AC_DEFINE([HAVE_MPIR_TOPOINTER], [1], [Have MPIR to pointer]),)\n  AC_CHECK_LIB(mpich,MPIR_ToPointer,AC_DEFINE([HAVE_MPIR_TOPOINTER],[1], [Have MPIR to pointer]),)\nfi\n\n#  Check for MPI3\nAC_COMPILE_IFELSE(\n    [AC_LANG_PROGRAM([@%:@include <mpi.h>],\n        [ #if MPI_VERSION < 3\n          # error not using MPI3\n          #endif\n        ])\n    ],\n    AC_DEFINE([USE_MPI3_CONSTS],[1],[Use MPI v3 constructions]))\n\n\n#\n#  Find an appropriate timer function\n#\n\nTIMER_FOUND=no\nTIMER_NAME=none\n\n# use rts_get_timebase (BG/L) by default if it exists\nif test x$TIMER_FOUND = xno && \\\n  (test x$TIMER_OPTION = xno || test x$USE_RTS_GET_TIMEBASE = xyes); then\nAC_CHECK_FUNC(rts_get_timebase, AC_DEFINE([USE_RTS_GET_TIMEBASE], [1], [Use RTS get timebase])\n        USE_RTS_GET_TIMEBASE=yes ; TIMER_FOUND=yes ; TIMER_NAME=\"rts_get_timebase (assuming 700MHz)\" ; AC_SUBST(USE_RTS_GET_TIMEBASE)\n        )\nfi\n\n# use _rtc (Cray X1) by default if it exists\nif test x$TIMER_FOUND = xno && \\\n  (test x$TIMER_OPTION = xno || test x$USE_RTC = xyes); then\nAC_CHECK_DECL(_rtc, AC_DEFINE([USE_RTC], [1], [Use RTC])\n        USE_RTC=yes ; TIMER_FOUND=yes ; TIMER_NAME=_rtc ; AC_SUBST(USE_RTC)\n        , , [#include <intrinsics.h>])\nfi\n\nREAD_REAL_TIME=read_real_time\n## On AIX, prefer monotonic mread_real_time, if available\nif test x$TIMER_FOUND = xno && test x$TIMER_OPTION = xno ; then\n  AC_CHECK_FUNC(mread_real_time, READ_REAL_TIME=mread_real_time TIMER_FOUND=yes)\n  if test x$TIMER_FOUND = xyes; then\n    #  In AIX 5.3, finding mread_real_time in libc, but not in header files.\n    AC_CHECK_DECL(mread_real_time, ,AC_DEFINE([NEED_MREAD_REAL_TIME_DECL], [1], [Need Real-time declaration]),[#include <sys/systemcfg.h>] [#include <sys/time.h>])\n  else\n    AC_CHECK_FUNC(read_real_time, READ_REAL_TIME=read_real_time TIMER_FOUND=yes)\n  fi\n  if test x$TIMER_FOUND = xyes ; then\n    TIMER_NAME=$READ_REAL_TIME\n  fi\nfi\n\n# If specified, try to use clock_gettime\nif test x$TIMER_FOUND = xno && test \"x$USE_CLOCK_GETTIME\" = \"xyes\" ; then\n  AC_CHECK_LIB(rt,clock_gettime, AC_DEFINE([USE_CLOCK_GETTIME],[1] [Use clock_gettime for timing]) USE_CLOCK_GETTIME=true TIMER_FOUND=yes TIMER_NAME=clock_gettime LIBS=\"$LIBS -lrt\"\n  )\nfi\n\n# If specified, use dclock\nif test x$TIMER_FOUND = xno && test \"x$USE_DCLOCK\" = \"xyes\" ; then\n  AC_DEFINE([USE_DCLOCK], [1], [Use dlock]) TIMER_FOUND=yes TIMER_NAME=dclock\nfi\n\n# If no appropriate timers were found, default to MPI_Wtime\nif test x$TIMER_FOUND = xno ; then\n        AC_CHECK_FUNC(MPI_Wtime, AC_DEFINE([USE_WTIME], [1], [Use MPI_Wtime]) TIMER_NAME=MPI_Wtime\n          , echo Failed to find MPI_Wtime.  Trying to use gettimeofday.; AC_DEFINE([USE_GETTIMEOFDAY],[1],[Use gettimofday]) USE_GETTIMEOFDAY=true)\nfi\n\n\nUNWIND_WITH=internal\n\n#  Not using AC_CHECK_LIB for libunwind as libunwnd API uses macros in libunwind.h to\n#  access platform-specific functions.\nHAVE_LIBUNWIND=no\nif test \"x$DISABLE_LIBUNWIND\" = \"xno\" ; then\n\tAC_CHECK_HEADER(libunwind.h, AC_DEFINE([HAVE_LIBUNWIND],[1], [Have libunwind]) LIBS=\"$LIBS -lunwind\" HAVE_LIBUNWIND=yes UNWIND_WITH=libunwind, \n\t[ if test x$build_cpu = xx86_64 ; then\n\t  echo\n\t  echo \"  mpiP on x86_64 platforms requires libunwind.\"\n\t  echo \"  Please install libunwind and, if necessary, configure mpiP with \"\n    echo \"  appropriate CFLAGS and LDFLAGS settings.\"\n\t  echo\n\t  exit 1\n\tfi ]\n\t)\nfi\n\nif test x\"$HAVE_LIBUNWIND\" = xno && test x\"$USE_SETJMP\" = xno ; then \n  AC_CHECK_FUNC(backtrace, AC_DEFINE([USE_BACKTRACE], [1], [Use backtrace]) UNWIND_WITH=glibc-backtrace, USE_SETJMP=yes)\nfi\n\nif test \"$ENABLE_API_ONLY\" = no && test \"$ENABLE_MPI_IO\" = yes ; then\nAC_CHECK_FUNC(MPI_File_open,\n              AC_DEFINE([HAVE_MPI_IO], [1], [Have MPI-IO]) HAVE_MPI_IO=mpi.io.protos.txt,\n\t      AC_CHECK_LIB(mpio,MPI_File_open, \n                AC_DEFINE([HAVE_MPI_IO],[1],[Have MPI-IO]) HAVE_MPI_IO=mpi.io.protos.txt LIBS=\"${LIBS} -lmpio\",\n                AC_MSG_RESULT(MPI I/O symbols not found.  MPI I/O reporting deactivated.)\n                HAVE_MPI_IO=/dev/null\n                ENABLE_MPI_IO=no )\n)\nelse\n  HAVE_MPI_IO=/dev/null\nfi\n\nif test \"x$ENABLE_API_ONLY\" = xno && test \"x$ENABLE_MPI_RMA\" = xyes ; then\nAC_CHECK_FUNC(MPI_Win_allocate,\n              AC_DEFINE([HAVE_MPI_RMA], [1], [Have MPI RMA]) HAVE_MPI_RMA=mpi.rma.protos.txt,\n                AC_MSG_RESULT([MPI RMA symbols not found.  MPI RMA reporting deactivated.])\n                HAVE_MPI_RMA=/dev/null\n                ENABLE_MPI_RMA=no\n)\nelse\n  HAVE_MPI_RMA=/dev/null\nfi\n\nif test \"x$ENABLE_API_ONLY\" = xno && test \"x$ENABLE_MPI_NONBLOCKINGCOLLECTIVES\" = xyes ; then\nAC_CHECK_FUNC(MPI_Ibarrier,\n              AC_DEFINE([HAVE_MPI_NONBLOCKINGCOLLECTIVES],[1],[Have MPI non-blocking collectives]) HAVE_MPI_NONBLOCKINGCOLLECTIVES=mpi.nbc.protos.txt,\n                AC_MSG_RESULT([MPI NONBLOCKINGCOLLECTIVES symbols not found.  MPI NONBLOCKINGCOLLECTIVES reporting deactivated.])\n                HAVE_MPI_NONBLOCKINGCOLLECTIVES=/dev/null\n                ENABLE_MPI_NONBLOCKINGCOLLECTIVES=no\n)\nelse\n  HAVE_MPI_NONBLOCKINGCOLLECTIVES=/dev/null\nfi\n\nif test \"x$DISABLE_SO_LOOKUP\" = \"xno\" && test \"x$ENABLE_BFD\" = xyes; then\n  SO_LOOKUP=no\n  #  Check for /proc/self/maps, can't use AC_CHECK_FILES since cross compiling\n  AC_MSG_CHECKING(/proc/self/maps)\n  if test -r /proc/self/maps ; then\n    AC_MSG_RESULT([yes])\n    SO_LOOKUP=yes\n  else\n    AC_MSG_RESULT([no])\n  fi\n  \n  #  SO lookup code uses getline, assumes ought to be available if we are using libbfd\n  if test \"x$SO_LOOKUP\" = xyes ; then\n    AC_CHECK_FUNC(getline, AC_DEFINE([SO_LOOKUP],[1],[SO lookup]), AC_MSG_RESULT([getline not found so SO lookup is disabled.]))\n  fi\nfi\n\nif test \"$ENABLE_API_ONLY\" = no ; then\n\nif test \"$ENABLE_FORTRAN_XLATE\" = yes ; then\n     AC_MSG_CHECKING(fortran to C conversion)\n     AC_LINK_IFELSE(\n       [ AC_LANG_PROGRAM([[#include \"mpi.h\"]], \n              [[ MPI_Fint mi; MPI_Request ri; ri = MPI_Request_f2c(mi);]] ) ],\n\t      [AC_MSG_RESULT([yes])],\n              (AC_MSG_RESULT(  functions not found  translation deactivated)\n                ENABLE_FORTRAN_XLATE=no) )\nfi\n\n#  Check for ARM LSE\n     AC_MSG_CHECKING(ARM LSE)\n     AC_LINK_IFELSE(\n       [ AC_LANG_PROGRAM([[#include <stdint.h>]], \n                         [[ #if __aarch64__   \n                          int64_t *addr, newval; int64_t ret;\n\n__asm__ __volatile__ (\"swpl %2, %0, [%1]\\n\"\n                      : \"=&r\" (ret)\n                      : \"r\" (addr), \"r\" (newval)\n                      : );\n#else\nfail\n#endif\n]] ) ],\n\t      [AC_MSG_RESULT([yes])] AC_DEFINE(HAVE_ARM_LSE, [1], [Using a processor with LSE]),\n              (AC_MSG_RESULT( no)) )\n#AC_SUBST(HAVE_ARM_LSE)\nfi\n\n#  If using Fortran routines to access command line,\n#  test whether get_command_argument is available, otherwise\n#  use getarg.\nFORTRAN_GETARG=\"\"\nFORTRAN_GETARG_SRC_FILE=mpiP_getarg.f.part\nif test \"$USE_GETARG\" = true ; then\n     AC_LANG_PUSH(Fortran 77)\n     # Force Fortran compiler tests\n     AC_LINK_IFELSE(AC_LANG_PROGRAM(,,), , )\n     AC_MSG_CHECKING(fortran command-line argument functions)\n     AC_LINK_IFELSE(\n       [ AC_LANG_PROGRAM(, \n              [[\n       integer len\n       character*10 val\n       call get_command_argument(0, val, len)]] ) ],\n\t      AC_MSG_RESULT([using get_command_argument]) \n                echo \"       call get_command_argument(idx, buf, len)\" > $FORTRAN_GETARG_SRC_FILE\n                FORTRAN_GETARG=$FORTRAN_GETARG_SRC_FILE,\n              AC_MSG_RESULT(using getarg) \n\t      echo \"       call getarg(idx, buf)\" > $FORTRAN_GETARG_SRC_FILE\n\t      echo \"       len = mpipi_get_strlen(buf)\" >> $FORTRAN_GETARG_SRC_FILE\n\t      FORTRAN_GETARG=$FORTRAN_GETARG_SRC_FILE\n              AC_SUBST_FILE(FORTRAN_GETARG)\n                )\n     AC_LANG_POP(Fortran 77)\nfi\n\n\nif test \"$ENABLE_API_ONLY\" = no ; then\ndnl ========== Find out how FORTRAN symbol names appear in C ==========\n\nAC_MSG_CHECKING(fortran symbols)\n\nif test -n \"$F77\" -a \"$F77\" != no ; then\n  /bin/rm -f ffunc.f flink.c\n  echo \"      subroutine f_fun()\" > ffunc.f\n  echo \"      return\" >> ffunc.f\n  echo \"      end\" >> ffunc.f\n  if ! $F77 $FFLAGS -c ffunc.f 1>/dev/null 2>/dev/null ; then\n    AC_MSG_RESULT(Failed to compile fortran test object. Example error follows:)\n    F77_OBJ_OUT=`$F77 $FFLAGS -c ffunc.f 2>&1`\n    AC_MSG_NOTICE($F77_OBJ_OUT)\n    AC_MSG_ERROR([giving up])\n  fi\n  echo \"main(){ FF(); return 0; }\" > flink.c\n  if $CC -o flink -DFF=f_fun flink.c ffunc.o $LDFLAGS $LIBS 1>/dev/null 2>/dev/null; then\n    AC_MSG_RESULT(same as C)\n    F77_SYMBOLS=symbol\n  elif $CC -o flink -DFF=f_fun_ flink.c ffunc.o $LDFLAGS $LIBS 1>/dev/null 2>/dev/null; then\n    AC_MSG_RESULT(lowercase with underscore)\n    F77_SYMBOLS=symbol_\n  elif $CC -o flink -DFF=f_fun__ flink.c ffunc.o $LDFLAGS $LIBS 1>/dev/null 2>/dev/null; then\n    AC_MSG_RESULT(lowercase with 2 underscores)\n    F77_SYMBOLS=symbol__\n  elif $CC -o flink -DFF=F_FUN flink.c ffunc.o $LDFLAGS $LIBS 1>/dev/null 2>/dev/null; then\n    AC_MSG_RESULT(uppercase)\n    F77_SYMBOLS=SYMBOL\n  elif $CC -o flink -DFF=F_FUN_ flink.c ffunc.o $LDFLAGS $LIBS 1>/dev/null 2>/dev/null; then\n    AC_MSG_RESULT(uppercase with underscore)\n    F77_SYMBOLS=SYMBOL_\n  elif $CC -o flink -DFF=F_FUN_ flink.c ffunc.o $LDFLAGS $LIBS 1>/dev/null 2>/dev/null; then\n    AC_MSG_RESULT(uppercase with 2 underscores)\n    F77_SYMBOLS=SYMBOL__\n  else\n    AC_MSG_RESULT(could not determine F77 symbol names. Example error follows:)\n    CC_F77_SYM_OUT=`$CC -o flink -DFF=f_fun flink.c ffunc.o $LDFLAGS $LIBS 2>&1`\n    AC_MSG_NOTICE($CC_F77_SYM_OUT)\n    AC_MSG_ERROR([giving up])\n  fi\n  /bin/rm -f ffunc.f ffunc.o flink flink.c flink.o ffunc\nelse\n  F77_SYMBOLS=symbol_\n  AC_MSG_RESULT(guessing lowercase with underscore)\nfi\nAC_SUBST(F77_SYMBOLS)\nAC_DEFINE_UNQUOTED([F77_SYMBOLS],[$F77_SYMBOLS], [F77 symbols])\n\n\ndnl ========== Identify F77 ==========\nFORTRAN_GETARG_OBJ_FILE=get_fortran_arg.o\n\nAC_MSG_CHECKING(fortran compiler)\nif $F77 -V 2>&1 | grep -e 'Portland Group' 1> /dev/null 2> /dev/null ; then\n  F77_VENDOR=PGI\n  MPIPFLIB=mpiPpgf\n  FORTRAN_FLAG=-DPGI\n  FORTRAN_TARGET=libmpiPpgf.a\nelif echo $F77 2>&1 | grep 'xlf' 1> /dev/null 2> /dev/null ; then\n  F77_VENDOR=IBM\n  if test \"x$USE_GETARG\" = xtrue ; then\n    MPIPFLIB=mpiPxlf\n    FORTRAN_TARGET=libmpiPxlf.a\n  else\n    MPIPFLIB=mpiP\n  fi\nelif test \"x$G77\" = xyes ; then\n  F77_VENDOR=GNU\n  FORTRAN_FLAG=-DGNU_Fortran\n  FORTRAN_TARGET=libmpiPg77.a\n  MPIPFLIB=mpiPg77\nelif $F77 -v 2>&1 | grep -e gcc 1> /dev/null 2> /dev/null ; then\n  F77_VENDOR=GNU\n  FORTRAN_FLAG=-DGNU_Fortran\n  FORTRAN_TARGET=libmpiPg77.a\n  MPIPFLIB=mpiPg77\nelif $F77 -V 2>&1 | grep -e Intel 1> /dev/null 2> /dev/null ; then\n  F77_VENDOR=Intel\n  FORTRAN_FLAG=\n  FORTRAN_TARGET=\n  MPIPFLIB=\nelif $F77 -V 2>&1 | grep -e Cray 1>/dev/null 2>/dev/null ; then\n  F77_VENDOR=Cray\n  FORTRAN_FLAG=-DCray_Fortran\n  FORTRAN_TARGET=libmpiPftn.a\n  MPIPFLIB=mpiPftn \n  if test \"x$USE_GETARG\" = xtrue ; then\n    FORTRAN_GETARG_OBJ_FILE=get_fortran_arg_pxf.o\n  fi\nelif $F77 -version 2>&1 | grep -e Compaq 1> /dev/null 2> /dev/null ; then\n  F77_VENDOR=Compaq\n  MPIPFLIB=mpiP\n  FORTRAN_FLAG=\n  FORTRAN_TARGET=\nelse\n  F77_VENDOR=Unknown\n  MPIPFLIB=mpiP\n  FORTRAN_FLAG=\n  FORTRAN_TARGET=\nfi\n\nif test x\"$F77_VENDOR\" = x\"IBM\" ; then\n  FORTRAN_STR_DECL=\"character (buf_len) buf\"\nelse\n  FORTRAN_STR_DECL=\"character buf*(*)\"\nfi\n\nfi #if test \"$ENABLE_API_ONLY\" = no ; then\n\nAC_MSG_RESULT($F77_VENDOR)\nAC_SUBST(F77_VENDOR,$F77_VENDOR)\nAC_SUBST(MPIPFLIB,$MPIPFLIB)\nAC_SUBST(FORTRAN_FLAG,$FORTRAN_FLAG)\nAC_SUBST(FORTRAN_TARGET,$FORTRAN_TARGET)\nAC_SUBST(FORTRAN_STR_DECL, $FORTRAN_STR_DECL)\nAC_SUBST(ENABLE_BFD, $ENABLE_BFD)\nAC_SUBST(ENABLE_API_ONLY)\nAC_SUBST(READ_REAL_TIME)\nAC_SUBST(DEFAULT_TARGS)\nAC_SUBST(FORTRAN_GETARG_OBJ_FILE)\nAC_SUBST(TEST_LIST)\nAC_SUBST(USE_BACKTRACE)\nAC_SUBST(USE_SETJMP)\nAC_SUBST(ADD_OBJS)\nAC_SUBST(PIC_FLAGS)\nAC_SUBST(MPIP_COPIED_ARGS_MAX)\nAC_SUBST_FILE(HAVE_MPI_IO)\nAC_SUBST_FILE(HAVE_MPI_RMA)\nAC_SUBST_FILE(HAVE_MPI_NONBLOCKINGCOLLECTIVES)\nAC_SUBST_FILE(FORTRAN_GETARG)\n\nif test \"x${slibdir}\" = x ; then\n  slibdir=$libdir\nfi\nAC_SUBST(slibdir)\n\nAC_CONFIG_FILES([Defs.mak Makefile testing/Makefile Check.mak mpi.protos.txt get_fortran_arg.f mpip_timers/aix_local.h])\nAC_OUTPUT\n\n#  \n#  Print out Summary of configuration\n#\n\necho\necho \"********************************************************************************\"\necho \"  mpiP Configuration Summary\"\necho\necho \"  C compiler               : ${CC}\"\necho \"  C++ compiler             : ${CXX}\"\necho \"  Fortran compiler         : ${F77}\"\necho\necho \"  Timer                    : ${TIMER_NAME}\"\necho \"  Stack Unwinding          : ${UNWIND_WITH}\"\necho \"  Address to Source Lookup : ${SOURCE_LOOKUP}\"\necho\necho \"  MPI-I/O support          : ${ENABLE_MPI_IO}\"\necho \"  MPI-RMA support          : ${ENABLE_MPI_RMA}\"\necho \"  MPI-NBC support          : ${ENABLE_MPI_NONBLOCKINGCOLLECTIVES}\"\necho \"********************************************************************************\"\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-mpip-3.5-s4r4bia5kf6aikq7hpu4cuzcak22oovf/spack-src/doc/UserGuide.pdf"
    ],
    "total_files": 130
}