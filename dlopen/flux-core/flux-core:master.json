{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-i6dcpentpa3wkcp6mwcurdfsjksgyiyg/spack-src/README.md": "[![ci](https://github.com/flux-framework/flux-core/workflows/ci/badge.svg)](https://github.com/flux-framework/flux-core/actions?query=workflow%3A.github%2Fworkflows%2Fmain.yml)\n[![codecov](https://codecov.io/gh/flux-framework/flux-core/branch/master/graph/badge.svg)](https://codecov.io/gh/flux-framework/flux-core)\n\n_NOTE: The interfaces of flux-core are being actively developed\nand are not yet stable._ The github issue tracker is the primary\nway to communicate with the developers.\n\nSee also our [Online Documentation](https://flux-framework.readthedocs.io).\n\n### flux-core\n\nflux-core implements the communication layer and lowest level\nservices and interfaces for the Flux resource manager framework.\nIt consists of a distributed message broker, broker plug-in modules\nthat implement various distributed services, and an API and set\nof utilities to utilize these services.\n\nflux-core is intended to be the first building block used in the\nconstruction of a site-composed Flux resource manager.  Other building\nblocks are also in development under the\n[flux-framework github organization](https://github.com/flux-framework),\nincluding a fully functional workload\n[scheduler](https://github.com/flux-framework/flux-sched).\n\nFramework projects use the C4 development model pioneered in\nthe ZeroMQ project and forked as\n[Flux RFC 1](https://flux-framework.rtfd.io/projects/flux-rfc/en/latest/spec_1.html).\nFlux licensing and collaboration plans are described in\n[Flux RFC 2](https://flux-framework.rtfd.io/projects/flux-rfc/en/latest/spec_2.html).\nProtocols and API's used in Flux will be documented as Flux RFC's.\n\n#### Build Requirements\n\n<!-- A collapsible section with markdown -->\n<details>\n  <summary>Click to expand and see our full dependency table</summary>\n\nflux-core requires the following packages to build:\n\n**redhat**        | **ubuntu**        | **version**       | **note**\n----------        | ----------        | -----------       | --------\nautoconf          | autoconf          |                   |\nautomake          | automake          |                   |\nlibtool           | libtool           |                   |\nmake              | make              |                   |\nlibsodium-devel   | libsodium-dev     | >= 1.0.14         |\nzeromq4-devel     | libzmq3-dev       | >= 4.0.4          |\nczmq-devel        | libczmq-dev       | >= 3.0.1          |\njansson-devel     | libjansson-dev    | >= 2.6            |\nlibuuid-devel     | uuid-dev          |                   |\nlz4-devel         | liblz4-dev        |                   |\nhwloc-devel       | libhwloc-dev      | >= v1.11.1        |\nsqlite-devel      | libsqlite3-dev    | >= 3.0.0          |\nlua               | lua5.1            | >= 5.1, < 5.5     |\nlua-devel         | liblua5.1-dev     | >= 5.1, < 5.5     |\nlua-posix         | lua-posix         |                   | *1*\npython36-devel    | python3-dev       | >= 3.6            |\npython36-cffi     | python3-cffi      | >= 1.1            |\npython36-six      | python3-six       | >= 1.9            |\npython36-yaml     | python3-yaml      | >= 3.10.0         |\npython36-jsonschema | python3-jsonschema | >= 2.3.0       |\nphthon3-sphinx    | python3-sphinx    |                   | *2*\n\n*Note 1 - Due to a long standing [packaging bug](https://bugs.launchpad.net/ubuntu/+source/lua-posix/+bug/1752082) in lua-posix-33.4.0-2 on Ubuntu bionic, you may wish to install lua-posix via luarocks on that distro.\n\n*Note 2 - only needed if optional man pages are to be created.\n\nThe following optional dependencies enable additional testing:\n\n**redhat**        | **ubuntu**        | **version**\n----------        | ----------        | -----------\naspell            | aspell            |\naspell-en         | aspell-en         |\nvalgrind-devel    | valgrind          |\nmpich-devel       | libmpich-dev      |\njq                | jq                |\n</details>\n\n##### Installing RedHat/CentOS Packages\n```\nyum install autoconf automake libtool make libsodium-devel zeromq4-devel czmq-devel libuuid-devel jansson-devel lz4-devel hwloc-devel sqlite-devel lua lua-devel lua-posix python36-devel python36-cffi python36-six python36-yaml python36-jsonschema python3-sphinx aspell aspell-en valgrind-devel mpich-devel jq\n```\n\n##### Installing Ubuntu Packages\n```\napt install autoconf automake libtool make libsodium-dev libzmq3-dev libczmq-dev uuid-dev libjansson-dev liblz4-dev libhwloc-dev libsqlite3-dev lua5.1 liblua5.1-dev lua-posix python3-dev python3-cffi python3-six python3-yaml python3-jsonschema python3-sphinx aspell aspell-en valgrind libmpich-dev jq\n```\n\n##### Building from Source\n```\n./autogen.sh   # skip if building from a release tarball\n./configure\nmake\nmake check\n```\n\n#### Bootstrapping a Flux instance\n\nA Flux instance is composed of a set of `flux-broker` processes\nthat bootstrap via PMI (e.g. under another resource manager), or locally\nvia the `flux start` command.\n\nNo administrator privilege is required to start a Flux instance\nas described below.\n\n##### Single node session\n\nTo start a Flux instance (size = 8) on the local node for testing:\n```\nsrc/cmd/flux start --size 8\n```\nA shell is spawned that has its environment set up so that Flux\ncommands can find the message broker socket.  When the shell exits,\nthe session exits.\n\n##### SLURM session\n\nTo start a Flux instance (size = 64) on a cluster using SLURM,\nfirst ensure that MUNGE is set up on your cluster, then:\n```\nsrun --pty --mpi=none -N64 src/cmd/flux start\n```\nThe srun --pty option is used to connect to the rank 0 shell.\nWhen you exit this shell, the session terminates.\n\n#### Flux commands\n\nWithin a session, the path to the `flux` command associated with the\nsession broker will be prepended to `PATH`, so use of a relative or\nabsolute path is no longer necessary.\n\nTo see a list of commonly used commands run `flux` with no arguments,\n`flux help`, or `flux --help`\n```\n$ flux help\nUsage: flux [OPTIONS] COMMAND ARGS\n  -h, --help             Display this message.\n  -v, --verbose          Be verbose about environment and command search\n\nCommon commands from flux-core:\n   broker             Invoke Flux message broker daemon\n   content            Access instance content storage\n   cron               Schedule tasks on timers and events\n   dmesg              manipulate broker log ring buffer\n   env                Print or run inside a Flux environment\n   event              Send and receive Flux events\n   exec               Execute processes across flux ranks\n   get,set,lsattr     Access, modify, and list broker attributes\n   hwloc              Control/query resource-hwloc service\n   keygen             generate keys for Flux security\n   kvs                Flux key-value store utility\n   logger             create a Flux log entry\n   module             manage Flux extension modules\n   ping               measure round-trip latency to Flux services\n   proxy              Create proxy environment for Flux instance\n   ps                 List subprocesses managed by brokers\n   start              bootstrap a local Flux instance\n   submit             submit job requests to a scheduler\n   user               Flux user database client\n```\n\nMost of these have UNIX manual pages as `flux-<sub-command>(1)`,\nwhich can also be accessed using `./flux help <sub-command>`.\n\n#### A note about PMI\n\nWhen flux is launched, it requires PMI-1 in order to bootstrap.\nIt can use PMI-1 in one of two ways, by inheriting a file descriptor\nvia the `PMI_FD` environment variable, or by dlopening a PMI library.\nThe library name is `libpmi.so`, unless overridden by the `PMI_LIBRARY`\nenvironment variable.  If a PMI library is not found, flux falls back\nto \"singleton\" operation, where each broker is an independent flux instance.\nThe PMI bootstrap may be traced by setting the `FLUX_PMI_DEBUG` environment\nvariable.\n\nWhen flux launches flux or an MPI job, it provides PMI-1 to bootstrap the\nMPI's runtime.  It offers a PMI server and sets the `PMI_FD` environment\nvariable to point to an open file descriptor connected to it.  It also offers\na `libpmi.so` library that can be dlopened.\n\nIf your system process manager uses PMIx, the `libpmi.so` compatibility library\nprovided by the PMIx project should be sufficient to bootstrap flux.\nIf your version of PMIx was not built with the compatibility libraries\ninstalled, you may build libpmix as a separate package to get them installed.\n\n#### Release\n\nSPDX-License-Identifier: LGPL-3.0\n\nLLNL-CODE-76440\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-i6dcpentpa3wkcp6mwcurdfsjksgyiyg/spack-src/NEWS.md": "flux-core version 0.23.1 - 2021-01-27\n-------------------------------------\n\n### Fixes\n\n * flux resource: allow drain, undrain, and status to work on any rank (#3486)\n * job-manager: fix compilation error on gcc-10 (#3485)\n * job-manager: fix uninitialized variable warning in jobtap.c (#3481)\n\nflux-core version 0.23.0 - 2021-01-25\n-------------------------------------\n\nThis release adds a job priority plugin framework, enabling the\nflux-accounting project to set job priorities with a fair share\nalgorithm.\n\nThe scheduler protocol (RFC 27) and libschedutil convenience API\nhave changed, therefore users of flux-sched must upgrade to 0.15.0.\n\n### New features\n\n * jobtap: prototype job-manager plugin support (#3464)\n * flux-mini: add bulk job submission capabilities (#3426, #3478)\n * job-manager: send updated priorities to schedulers (#3442)\n * job-manager: support job hold and expedite (#3428)\n\n### Fixes\n\n * connectors/ssh: forward `LD_LIBRARY_PATH` over ssh when set (#3458)\n * python: fix use of `Flux.reactor_run()` from multiple threads (#3471)\n * python: misc. fixes to docstrings and argument names in bindings (#3451)\n * python: fix circular reference in `check_future_error` decorator (#3437)\n * python: fix ctrl-c, re-throw unhandled exceptions in `reactor_run()` (#3435)\n * shell: fix dropped stdout from shell plugins in task.exec callback (#3446)\n\n### Cleanup/Testing\n\n * ci: limit asan build to unit tests only (#3479)\n * libschedutil: API improvements and priority integration (#3447)\n * configure: add switch to allow flux to be built without python (#3459)\n * testsuite: remove sched-dummy, migrate testing to sched-simple (#3462)\n * testsuite: add debug, workarounds for failures in github actions (#3467)\n * test: fix test for installing poison libflux (#3461)\n * cleanup: update outdated terminology (#3456)\n * Globally standardize spelling of \"canceled\" (#3443)\n * ci: better script portability and other small updates (#3438)\n * testsuite: fix invalid tests, cleanup list-jobs, avoid hard-coding (#3436)\n * fix github actions on tag push (#3430)\n\nflux-core version 0.22.0 - 2020-12-16\n-------------------------------------\n\nThis release resolves an issue introduced in 0.20.0 where Flux would\noccasionally hang during tear-down on RHEL/CentOS 7.  This release\nshould be suitable for use with production workflows on those systems.\n\nSystem instance development and testing at < 256 node scale is on-going.\nThe system limitations of this release are documented in the Flux Admin\nGuide:\n\nhttps://flux-framework.readthedocs.io/en/latest/adminguide.html\n\n### New features\n\n * flux-keygen is no longer necessary before starting Flux (#3409)\n * Add waitstatus and returncode JobID class and flux-jobs (#3414)\n * New `flux resource status` command (#3351)\n * Rename \"administrative priority\" to \"urgency\" (#3394)\n * Prepare for fair share priority plugin (#3371, #3339, #3350, #3402,\n   #3405, #3404, #3410)\n * job-manager: cache jobspec for scheduler, exec (#3393, #3396, #3399)\n * python: add bindings for libflux-idset,hostlist (#3341)\n * resource: support hostnames for drain and exclude (#3318)\n * flux-jobs: Support nodelist in flux-jobs output (#3332)\n * flux-jobs: add flux-jobs --stats,--stats-only options (#3419)\n * flux-job: Add flux job attach --read-only option (#3320)\n * python: add ResourceSet python class (#3406)\n * python: allow future.then() variable and keyword args in callbacks (#3366)\n\n### Fixes\n\n * Fix job shell segfault when jobspec contains JSON null (#3421)\n * job-manager: Fix annotation clear corner case #3418\n * broker: fix intermittent hang during instance tear-down on Centos7 (#3398)\n * job-exec: log early shell/imp errors (#3397)\n * shell: ensure TMPDIR exists for all jobs (#3389)\n * misc cleanups & fixups (#3392)\n * small fixes: resource memory leak, improve errors, check int size (#3388)\n * affinity: use comma separated list format for `CUDA_VISIBLE_DEVICES` (#3376)\n * libjob: repair interoperability with flux-security (#3356)\n * job-exec: fixes for multiuser mode (#3353)\n * shell: fix issues with `CUDA_VISIBLE_DEVICES` value (#3317)\n * job-manager: handle scheduler disconnect (#3304)\n * libjob: always sign owner jobs with the 'none' signing mechanism (#3306)\n * libsubprocess: do not allow ref/unref in hooks (#3303)\n\n### Cleanup/Testing\n\n * doc: autogenerate python binding docs with Sphinx (#3412)\n * testsuite: support level N inception of flux testsuite (#3413)\n * github: fix missing docker tag in matrix builds (#3387)\n * github: fixes for workflow scripts (#3383)\n * ci: move from Travis-CI to GitHub Workflows (#3379)\n * docs: add explicit link to man pages section (#3365)\n * testsuite: replace loop in t2300-sched-simple.t with helper (#3367)\n * docker: install poison flux-core libs, cmds before build and test (#3369)\n * libflux: drop `flux_dmesg()` from public API (#3362)\n * testsuite: fix shed-simple test races (#3358)\n * build: allow Lua 5.4, drop -lutil, and improve sphinx warning (#3357)\n * testsuite: increase resource.monitor-waitup timeout (#3348)\n * broker: update log.dmesg to use rpc streaming (#3307)\n * testsuite: fix core idsets in resource module tests (#3314)\n * t/t2205-hwloc-basic: only use lstopo-no-graphics (#3309)\n\nflux-core version 0.21.0 - 2020-11-04\n-------------------------------------\n\nThis release enables resources to be configured in advance when Flux is\nthe native resource manager for a cluster, in lieu of dynamic discovery.\nFor details, refer to the Flux Admin Guide:\n\nhttps://flux-framework.readthedocs.io/en/latest/adminguide.html\n\n### New features\n\n * optparse: don't sort options/subcommands by default (#3298)\n * flux-job: Output key options for job info (#3210)\n * resource: load resources from config or R, and rework topo discovery (#3265)\n * add internal librlist library and flux-R utility for R version 1 (#3276)\n * job-info: use job manager journal to track job state (#3254)\n * job-manager: support events journal (#3261)\n * shell: support stdio buffering options (default stderr: unbuffered) (#3272)\n * flux-kvs: Add 'flux kvs eventlog wait-event' subcommand (#3200)\n * job-manager: send job annotations to journal instead of publishing (#3236)\n * add hostlist library for encoding/decoding RFC29 hostlists (#3247)\n\n### Fixes\n\n * broker: convert broker [bootstrap] config to use libhostlist (#3283)\n * libflux: Add missing C++ header guards (#3280)\n * cmd: display jobid with flux-mini alloc -v, --verbose (#3279)\n * python: fix signal handler management in threads (#3266)\n * rc1: fix local connector retries (#3301)\n\n### Cleanup\n\n * remove flux-hwloc reload command and aggregator module (#3296)\n * doc: add flux-jobs(1) examples (#3295)\n * job-manager / job-info: misc cleanup (#3246)\n * build: increase minimum version of jansson to 2.10 (#3240)\n * ci: ensure pylint script fails when lint warnings are produced (#3269)\n\n\nflux-core version 0.20.0 - 2020-09-30\n-------------------------------------\n\nThis release features changes to support Flux as the native resource\nmanager on small (<= 256 node) clusters, for testing only.  A draft system\nadministration guide is available at:\n\nhttps://flux-framework.readthedocs.io/en/latest/adminguide.html\n\n### New features\n\n * hwloc: add printing of num GPUs to `flux hwloc info` (#3217)\n * resource: mark nodes down when they are stopped (#3207)\n * broker:  allow late-joining brokers, execute rc1/rc3 on all ranks (#3168)\n * shell/pmi: add improved PMI key exchange mechanism (#3219)\n\n### Fixes\n\n * job-manager: communicate job priority changes to job-info (#3208)\n * job-info: handle annotations race (#3196)\n * python/job: Update `state_single` default header (#3227)\n * libidset: reject idset strings that don't conform to RFC 22 (#3237)\n * job-info: handle job-priority changes (#3208)\n * doc: list sphinx as a doc dependency in README.md (#3225)\n * testsuite: fix race in python SIGINT test (#3224)\n * job-manager: fix segfault changing priority of a running job (#3220)\n * shell: allow multiple resources per level in jobspec (#3175)\n * python: allow Ctrl-C interrupt of `Future.get()` and `wait_for()` (#3215)\n * shell: use F58/alternate encodings in output file template {{id}} (#3206)\n * fallback to ASCII for F58 FLUIDs with `FLUX_F58_FORCE_ASCII` (#3204)\n * rc: load sched-simple only if no other scheduler is loaded (#3177)\n * docker: do not install Sphinx via pip in Centos8 image (#3195)\n * flux-jobs / python bindings: handle empty string conversions (#3183)\n\n### Cleanup\n\n * reduce log noise (#3226)\n * flux-comms: remove obsolete command (#3211)\n\n\nflux-core version 0.19.0 - 2020-08-31\n-------------------------------------\n\nNotable features and improvements in this release include enhanced\nsupport for tools/debuggers (e.g. STAT, LaunchMON and TotalView), a\nnew set of `--env` environment manipulation options for flux-mini(1),\nbetter support for listing jobs through the Python API, and a fix\nfor an annoying usability issue with F58 encoded jobids in non-UTF-8\nlocales.\n\n\n### New features\n\n * switch to utf-8 for subprocess and job io encoding (#3086)\n * improve support for shell plugin developers (#3159, #3132)\n * flux-mini: add environment manipulation options (#3150)\n * flux-mini: add --debug option for tools support (#3130)\n * bash: top level command completions for flux (#2755)\n * add fluxorama system instance docker image sources (#3031, #3128)\n * content-s3: add configuration, support for libs3 variants (#3067, #3115)\n * Use F58 JOBIDs in most user-facing commands (#3111)\n * broker: state machine refactoring (#3107)\n * broker: restore client-side PMI logging (#3105)\n * libflux: add `flux_module_set_running()` (#3104)\n * python: Add JobInfo, JobInfoFormat, and JobList classes (#3174)\n\n### Fixes\n\n * Fix F58 encoding in non-multibyte locales (#3144)\n * job-info,job-shell: allow non-V1 jobspec (#3160)\n * build: fix innocuous configure error (#3129)\n * travis-ci: fix ARGS when `DOCKER_TAG` set (#3125)\n * doc: fix flux-help(1) output and rendering of NODESET.rst (#3119)\n * flux-job: add `totalview_jobid` support and misc. fixes (#3130)\n * small build/test/doc fixes (#3100)\n * fix GitHub project license detection (#3089)\n * shell/lua.d/openmpi: set env vars to force the use of flux plugins (#3099)\n * job-info: do not fail on invalid jobspec / R / eventlog (#3171)\n * flux-module: extend first column of flux-module list output (#3178)\n\n### Cleanup\n\n * python: split flux.job module into multiple files (#3162)\n * python: reformat with latest black formatter, pin black version (#3169)\n * libflux: fix comment in module.h to reference readthedocs (#3138)\n * Update rfc links to RTD site (#3137)\n * remove the simple dynamic string (sds) code from libutil (#3135)\n * Doc Cleanup (#3117)\n * AUTHORS: remove (#3090)\n\nflux-core version 0.18.0 - 2020-07-29\n-------------------------------------\n\nThis release features a more compact default representation for Flux JOBIDs,\nmanual pages converted to ReST format and published on\n[readthedocs.io](https://flux-framework.readthedocs.io/projects/flux-core/),\nand the ability for schedulers to add data to jobs which can be displayed\nwith `flux jobs`.\n\n### New features\n\n * doc: man pages converted to ReST for publication on readthedocs.io\n   (#3033, #3078, #3085)\n * Add support for RFC19 F58 encoded JOBIDs (#3045)\n * Support user and scheduler job annotations (#3065, #3062, #2960)\n * add content-s3, content-files alternate backing stores (#3025, #2992)\n * Python interface to 'mini batch' (#3020)\n\n### Fixes\n\n * shell: fix bug in cpu-affinity=per-task (#3080)\n * flux-hwloc: remove ignore of `HWLOC_OBJ_GROUP` (#3046)\n * cmd: Make label io options consistent (#3068)\n * flux-resource list: Allow null/missing key to designate empty set (#3047)\n * flux-jobs: small functionality and testing updates (#3060)\n * job-manager: avoid segfault on priority change with pending alloc (#3072)\n\n### Cleanup\n\n * doc: adjust dependency table to reflect hwloc v2.0+ support (#3053)\n * Update terminology to use more inclusive words (#3040)\n\n### Testsuite enhancements\n\n * testsuite: remove use of -S option in `run_timeout` (#3079)\n * testsuite: minor valgrind test cleanup (#3077)\n * docker: small updates for testenv images, travis builds (#3058)\n * travis-ci: add python coverage (#3056)\n * travis-ci: Add `--localstatedir=/var` to docker tag builds (#3050)\n * pylint: Update pylint to 2.4.4 (#3035)\n * Fix testsuite for Lua 5.3 on Ubuntu 20.04 (#3028)\n * docker: really actually fix Ubuntu 20.04 (focal) docker tags (#3027)\n * travis-ci: enforce correct configure ARGS for docker tags (#3023)\n * travis: tag a docker image for ubuntu 20.04 (#3022)\n * python: add stdio properties to Jobspec class (#3019)\n * build and test fixes (#3016)\n\n\nflux-core version 0.17.0 - 2020-06-18\n-------------------------------------\n\n*NOTE*: Support has been removed for Python 2.\n\n### New features\n\n * Improved interface for batch jobs: `flux mini batch` and `flux mini alloc`\n   (#2962)\n * Pty support for Flux jobs via `-o pty` shell option (#2894)\n * New resource module for monitoring and control of resources,\n   including ability to exclude and drain/undrain ranks. (#2918, #2949)\n * New `flux resource` utility to drain and list resources. (#2949)\n * Multiple improvements for `flux jobs`: colorize output, add \"status\"\n   and \"exception\" fields, allow jobids as positional arguments, and\n   add a custom conversion type `h` for \"-\" (#2798, #2858, #2902, #2910,\n   #2940, #2926, #2865)\n * Support for hwloc v2.0+ (#2944)\n * Support for MPIR debugging of jobs (#2654)\n * New job-archive module optionally stores job data in sqlite. (#2880)\n * single-broker system instance support, including minimal\n   support for restart (archived job information is saved) (#2783, #2820,\n   #2813, #2809)\n * Add support for multi-user execution (#2822, #2813)\n * Add support for enforcing job time limits (#2995)\n * python: Add bindings for job cancel and kill (#2976)\n * python: Add bindings for watching job eventlog events (#2986)\n\n### Improvements\n\n * support systemctl reload flux (#2879)\n * enhance job throughput (#2777, #2792)\n * sched-simple: schedule cores instead of PUs by default (#2966)\n * broker: send service.disconnect requests on module unload (#2913)\n * broker: add interface for monitoring broker liveness (#2914)\n * broker: add cleanup phase (#2971)\n * broker: only allow userid- services to be registered by guests (#2813)\n * libflux: add `flux_msg_last_json_error(3)` (#2905)\n * flux-job: Use common attrs for list cmds (#2901)\n * doc: add flux job shell API manpages (#2793)\n * job-info: Support \"exception\" and \"success\" list attributes (#2831, #2858)\n * job-info: improve error responses from various list RPCs (#3010)\n * rc: load job-info on rank 0 only (#3009)\n * python: remove support for Python 2 (#2805)\n * python: cache python wrappers in the class (#2878)\n * python: tweaks in preparation for flux-tree-helper (#2804)\n * python: add 'flux_job_list_inactive' Python binding (#2790)\n * python: allow reactor_run() to be interrupted (#2974)\n * config: parse TOML once in broker, share with modules (#2866)\n * config: use config file for access policy (#2871)\n * docker: add default PS1 that includes flux instance size, depth (#2925)\n * docker: start munge in published docker images (#2922)\n\n### Fixes\n\n * Fix compilation under GCC 10.1.0 (#2954)\n * librouter: avoid dropping messages on EPIPE (#2934)\n * README: update documentation link (#2929)\n * README.md: fix required Lua version (#2923)\n * README: add missing dependencies: aspell-en and make (#2889)\n * shell: make registered services secure by default (#2877)\n * cmd/flux-kvs: Fix segfault in dir -R (#2847)\n * job-exec: drop use of broker attrs, use conf file or cmdline instead\n   (#2821)\n * broker: clean shutdown on SIGTERM (#2794)\n * flux-ping: fix problems with route string (#2811)\n * libsubprocess:  don't clobber errno in destructors, handle ENOMEM (#2808)\n * Fix flux-job status for jobs with exceptions before start (#2784)\n * shell: Add missing R member to shell info JSON object (#2989)\n * job-ingest: fix validation of V1 jobspec (duration required) (#2994)\n * doc: fixes and updates for idset manpages (#3012)\n\n### Cleanup\n\n * removed outdated pymod module (#3008)\n * broker and flux-comms cleanup (#2907)\n * cmd/flux-kvs: Remove legacy --json options and json output (#2807)\n * doc: Fix typos in man pages (#2725)\n * libutil: improve out of memory handling, conform to RFC 7 (#2785)\n * content-sqlite, content-cache: cleanup and refactoring (#2786)\n\n### Testsuite enhancements\n\n * Fix skipped tests in t2205-hwloc-basic.t (#2998)\n * t2204-job-info: Split up tests into new files (#2957)\n * t/t2800-jobs-cmd: Fix racy test (#2951)\n * t: add `HAVE_JQ` prereq to tests that use `jq` (#2936)\n * sharness: fix TEST_CHECK_PREREQS for tests using $jq (#2939)\n * job-info: module & test cleanup (#2932)\n * testsuite: add ability to ensure programs are used under appropriate\n   prereqs (#2937)\n * ensure unit tests do not link against installed flux libraries (#2917)\n * t2204-job-info: Fix racy tests (#2862)\n * test rehab: new flexible run_timeout, speeding up asan, and many more\n   timeouts and test repairs (#2849)\n * Mypy: add static type checking for python to travis (#2836)\n * testsuite: minor fixes and slight improvements (#2842)\n * README: update Travis CI badge after transition to travis-ci.com (#2843)\n * tests: timeout in automake harness (#2840)\n * t/t0005-exec: Increase timeout lengths (#2828)\n\n\nflux-core version 0.16.0 - 2020-02-24\n-------------------------------------\n\n## New features\n\n * job-info: fix ordering of pending jobs (#2732)\n * job-info: add list-id service for race-free listing of 1 jobid (#2720)\n * sched-simple: add unlimited alloc mode (#2726)\n * flux-module: add `flux module reload` subcommand (#2736)\n * flux-queue: add `flux queue idle` subcommand (#2712)\n\n## Improvements\n\n * broker: rework shutdown: rc3 no longer under grace-time timeout (#2733)\n * broker: log dropped responses sent down overlay (#2761)\n * libflux: fulfill empty \"wait_all\" futures immediately (#2714)\n * libflux: allow anonymous futures in `flux_future_push(3)` (#2714)\n * shell: report meaningful exit codes for ENOENT, EPERM & EACESS (#2756)\n * flux-jobs: refactor using new JobInfo and OutputFormat classes (#2734)\n * python: accept integer job duration (#2702)\n * python: switch from flags to boolean args in job.submit(), submit_async()\n   (#2719)\n * python: return derived JobListRPC and JobWaitFuture objects from\n   job.job_list and job.wait,wait_async for a better interface (#2753)\n\n## Fixes\n\n * broker: fix bootstrap under openpmix PMI-1 compat library (#2748)\n * broker: mute modules during unload to avoid deadlock (#2710)\n * libflux: block `flux_send()` during handle destruction (#2713)\n * job-ingest: fixes for validation worker management (#2721, #2716)\n * build: fix compilation errors on clang < 6.0 (#2742)\n * testsuite: fix tests when run under Slurm and Flux jobs (#2766)\n * testsuite: fix for hangs in tests using rc3-job (#2744)\n * doc: fix URI format in flux-proxy(1) manpage (#2747)\n\n\nflux-core version 0.15.0 - 2020-02-03\n-------------------------------------\n\n## Summary:\n\nThis release fixes a critical issue (#2676) with `flux module remove` in\nflux-core-0.14.0 that causes rc3 to fail when flux-core is integrated\nwith flux-sched.\n\n### New features\n\n * flux-job: add raiaseall, cancelall, killall (#2678)\n * flux-queue: new command to control job queue (#2659, #2687)\n * flux-jobs: support listing `nnodes` and `ranks` (#2656, #2705)\n\n### Improvements\n\n * shell: expand lua api to improve error handling in shell rc scripts (#2699)\n * shell: improve error messages to users on exec failures (#2675)\n * flux-job: (attach) fetch log messages even when shell init fails (#2691)\n * flux-job: (attach) add `-v` option (adds file,line log messages) (#2691)\n * flux-job: (list) make filtering options match `flux jobs` (#2639)\n * flux-job: (list) make JSON output the default (#2636)\n * flux-job: (drain,undrain) drop subcommands (see flux queue) (#2659)\n * job-info: transition state _after_ retrieving data from KVS (#2655)\n * job-info: add checks in sharness test to avoid racyness (#2666)\n * job-info: rename attributes to ease parsing (#2643)\n * flux-jobs: add --from-stdin option and other small fixes (#2648)\n * python: allow JobspecV1 to accept 0 gpus_per_task (#2701)\n * optparse: always display `--help` usage first in command help output (#2691)\n * libflux: add message cred helpers (#2670)\n * github: check flux-sched@master against submitted flux-core PRs (#2680)\n\n### Fixes\n\n * shell: fix bad exit from mvapich rc script, avoid flux.posix in rcs (#2699)\n * shell: fix race between stdin/out readers and eventlog creation (#2688)\n * shell: install `shell.h`: the public api for shell plugins (#2690)\n * shell: `chdir()` into current working directory (#2682)\n * rc: improve rc3 reliability, add `flux module remove -f` option  (#2676)\n * testsuite: fix unsafe getenv in libpmi tests, /tmp usage in sharness (#2669)\n * job-manager: fix counting problem that leads to scheduler sadness (#2667)\n\n\nflux-core version 0.14.0 - 2020-01-12\n-------------------------------------\n\n## Summary:\n\nThis version of flux-core improves the reliability and performance\nof the new execution system, and fills gaps in the previous release.\nSome highlights are:\n\n * support for jobs reading standard input\n * improved job listing tool - see flux-jobs(1)\n * improved python support for building jobspec and waiting for job completion\n * ability to override job names displayed in listing output\n\n### New features\n\n * Add porcelain `flux jobs` command (#2582)\n * job-info: use basename of arg0 for job-name (#2598)\n * job-info: honor `max_entries` option in job-info.list (#2596)\n * job-info: Support task-count in listing service (#2580)\n * Support job state times in job listing service (#2568)\n * python: add jobspec classes to main bindings (#2534)\n * initial job-name support (#2562)\n * job-manager: add `flux_job_wait()` (#2546)\n * shell: add support for debugger synchronization and `MPIR_proctable` gather\n   (#2542)\n * job-info: Add stats for number of jobs in each state (#2540)\n * job-info: re-load job state from KVS (#2502)\n * libflux: add `flux_get_conf()` (#2501)\n * job-info: Store full job-history, allow users to query pending, running,\n   and inactive jobs (#2471)\n * Initial shell stdin support (#2448)\n\n### Improvements\n\n * libflux/mrpc: drop the mrpc class (#2612)\n * docker: add image and travis tests on CentOS 8 (#2610)\n * mergify: do not auto-merge PRs with invalid commits (#2603)\n * broker: new format for [bootstrap] configuration (#2578)\n * broker/boot_config: use new config file interfaces (#2524)\n * shell: add unpack-style helpers for get_info shell plugin api calls\n   (#2573)\n * testing/asan: enable asan in test framework and travis-ci (#2466)\n * README.md: update build docs for Python 3 (#2565)\n * Update jobspec command key per RFC 14 changes (#2564)\n * replace exec \"running\" event with \"shell.init\" and \"shell.start\" (#2541)\n * shell: improve stdout/stderr performance (#2531)\n * modules/job-manager:  [cleanup] simplify queue listing and refactor\n   internal context (#2536)\n * kvs: improve append performance (#2526)\n * shell: generate job exception on `MPI_Abort` (#2510)\n * `msg_handler`: make `topic_glob` `const char *`, fix fallout (#2496)\n * libflux: fall back to builtin connector search path (#2489)\n * README: minor source cleanup (#2509)\n * shell: implement shell-specific log facility, add support for log events\n   to output eventlog (#2477)\n * flux-mini: improve handling of `--setattr` and `--setopt` (#2495)\n * bindings/python: reinstate python2 support (#2482)\n * bindings/python: change minimum python version to 3.6 (#2452)\n * libutil: replace fdwalk with version that uses getdents64 (#2479)\n * flux-shell: handle jobspec command as bare string (#2484)\n * librouter: factor common code from connector-local, flux-proxy (#2354)\n * mergify: fix rule that prevents merging of \"WIP\" PRs (#2453)\n * buffer: start buffer at 4K and grow to 4M as necessary (#2449)\n * libioencode: make rank parameters strings (#2441)\n * flux-kvs: Add eventlog namespace option (#2439)\n * testsuite: fix LONGTEST and other small improvements (#2444)\n * job-ingest: switch to v1 schema (#2433)\n * libtomlc99: update for TOML v0.5.0 support #2619\n * job-ingest: switch to a py bindings based jobspec validator (#2615)\n\n### Fixes\n\n * flux-job: misc fixes for attach (#2618)\n * fix minor issues found by lgtm scan (#2605)\n * broker: increase nofile limit to avoid assertion failure in `zuuid_new()`\n   (#2602)\n * use libuuid instead of zuuid (#2606)\n * github: enable a workflow to validate commits in a PR (#2586)\n * python: fix circular reference in `Future` class (#2570)\n * have future take a ref on `flux_t` handle (#2569)\n * bindings/python and libev: work around future leak (#2563)\n * kvs: Fix duplicate append corner case (#2555)\n * shell: stdin write to exited task should not cause fatal job exception\n   (#2550)\n * job-manager: fix internal job hash lookup error handling (#2552)\n * shell: fix segfault if logging function is called in or after\n   `shell_finalize()` (#2544)\n * kvs: fix memory use-after-free corner case (#2525)\n * t: fix tests prone to races or timeouts on constrained systems (#2523)\n * job-exec: fix memory errors detected by valgrind (#2521)\n * test: fix random cronodate test failure (#2520)\n * t1004-statwatcher: fix test on Ubuntu 19.10 (#2513)\n * job-ingest: launch `.py` validators with configured python (#2506)\n * doc: `flux_respond_raw` doesn't take an errnum (#2504)\n * Fix infinite recursion when wrapper.Wrapper object initialized with\n   incorrect args (#2485)\n * sched-simple: fix `rlist_alloc_nnodes()` algorithm (#2474)\n * fix crash in `is_intree()` with EACCESS or ENOENT from builddir (#2468)\n * testsuite: extend some testing timeouts  (#2451)\n\n\nflux-core version 0.13.0 - 2019-10-01\n-------------------------------------\n\n## Summary:\n\nThis version of flux-core enhances the new execution system to near full\nfunctionality, including new tools for job submission, better MPI support,\ntask and GPU affinity options, and flexible job output handling including\nredirection to bypass the KVS. A powerful shell plugin infrastructure allows\nexecution features to be selectively enabled by users.\n\nSee flux-mini(1) for more info on the new job submission interface.\n\nSome deficiencies present in this release:\n\n * flux job list doesn't show inactive jobs\n * no per-task output redirection\n * output is space-inefficient in KVS (base64 encoding, one commit per line)\n * no stdin redirection\n * need better shell task cleanup and early task exit detection\n * no debugger support (MPIR)\n\n### New features\n\n * flux-mini: new run/submit interface (#2409, #2390)\n * flux-version: make flux -V,--version an alias, add manpage (#2412, #2426)\n * shell: add gpu affinity support (#2406)\n * shell: add builtin core affinity plugin (#2397)\n * shell: Support stdout/stderr redirect to a file (#2395)\n * shell: add support for plugins and shell initrc (#2376, #2392, #2357, #2335)\n * shell: flush output to KVS on every line (#2366, #2332)\n * shell: limit the number of I/O requests in flight (#2296)\n * shell: use RFC 24 eventlog output (#2308)\n * flux-job attach: add timestamps, --show-exec option (#2388)\n * libioencode: convenience library for encoding io (#2293)\n * libsubprocess: add start/stop for streams (#2271, #2333)\n * libsubprocess: add `flux_subprocess_kill()` (#2297)\n * job-info: development in support of job output (#2341, #2374, #2360,\n   #2303, #2307)\n * flux-in-flux: flux --parent option, add `instance-level`, `jobid`\n   broker attributes (#2326, #2362)\n * flux-in-flux: set `local_uri`, `remote_uri` in enclosing instance KVS (#2322)\n\n### Improvements\n\n * libflux/reactor: add `flux_reactor_active_incref()`, `_decref()` (#2387)\n * libflux/module: add `flux_module_debug_test()` (#2373)\n * libschedutil: export library for use by flux-sched and others (#2380)\n * libschedutil: destroy pending futures on scheduler unload (#2226)\n * libflux/message: drop `flux_msg_sendfd()`, `_recvfd()` from API (#2375)\n * libflux/message: add `flux_msg_incref()` and `_decref()` (#2334)\n * libflux: update message dispatch to support routers (#2367)\n * libflux/buffer: increase efficiency of line buffered I/O (#2294)\n * libsubprocess: cleanup ( #2343, #2286)\n * testsuite improvements (#2404, #2400)\n * build system cleanup (#2407)\n * documentation cleanup (#2327)\n * abstract in-tree detection into libutil (#2351)\n * libjob: `flux_job_kvs_namespace()` (#2315)\n\n### Fixes\n\n * build: bump libflux-core.so version to 2 (#2427)\n * sched-simple: reject requests with unknown resource types (#2425)\n * restore libpmi2 to support MPICH/MVAPICH configured for slurm pmi2 (#2381)\n * broker: avoid accidentally consuming % format characters in initial\n   program args (#2285)\n * connector-local: suppress EPIPE write errors (#2316)\n * libidset: fix `idset_last()` at size=32 (#2340, #2342)\n * connectors/loop: do not accidentally close STDIN (#2339)\n * job-exec: fix exception handling of jobs in transition states (#2309)\n * broker: don't read `FLUX_RCX_PATH` to set rc1,rc3 paths (#2431)\n * job-ingest: validator shebang can pick the wrong python (#2435)\n\n\nflux-core version 0.12.0 - 2019-08-01\n-------------------------------------\n\n## Summary:\n\nThis version of flux-core replaces the old execution prototype, \"wreck\",\nwith a new job submission and execution protocol. The new system does\nnot yet have support for all the features of the prototype, however it\nis capable of running jobs specified in version 1 jobspec format with\nan advanced and performant job submission API.\n\nFor early adopters:\n \n * To generate jobspec, see `flux jobspec`\n * To submit jobspec, see `flux job submit`\n * Instead of `flux wreckrun` try `flux srun`\n * Instead of `flux wreck ls` try `flux job list`\n * Instead of `flux wreck kill/cancel` try `flux job kill/cancel`\n * Job events are recorded detailed eventlog, see `flux job eventlog <id>`\n * Experience job synchronization with `flux job wait-event`\n * Attach to submitted jobs with `flux job attach`\n * Want info about a job? Try `flux job info`\n * Waiting for all jobs to complete? Try `flux job drain`\n\n### New Features:\n\n * new job submit api and `flux job submit` command (#1910, #1918)\n * add job exception and cancellation support (#1976)\n * support validation for submitted jobspec (#1913, #1922)\n * add `flux jobspec` jobspec generation script (#1920, #1964)\n * add a simple default node/core fcfs scheduler, sched-simple\n   (#2038, #2053, #2203)\n * add `flux job info`, `eventlog`, `wait-event`, `attach`\n   (#2071, #2085, #2098, #2112, #2114, #2115, #2137, #2142, #2269, #2084)\n * add `flux job drain` (#2092)\n * add flux-shell, the flux job shell (#2211, #2240, #2246, #2244, #2278)\n * add `flux srun` (#2179, #2227)\n\n### Improvements:\n \n * libsubprocess updates (#2158, #2152, #2167, #2174, #2230, #2254, #2262,\n    #2265)\n * job-manager: add exec and scheduler interfaces, add job state machine:\n    (#2025, #2031, #2067, #2068, #2077, #2146, #2198, #2231)\n * job-manager: add state transition events (#2109)\n * job-manager: other improvements (#2047, #2062)\n * replace resource-hwloc module (#1968)\n * standardize parsing of duration in most tools (#2095, #2216)\n * add guest support to barrier module (#2215)\n * add broker `rundir` attribute (#2121) \n * kvs: remove namespace prefix support (#1943)\n * kvs: support namespace symlinks (#1949)\n * kvs: new kvs namespace command (#1985)\n * python: add futures support (#2023)\n * improve signature of `flux_respond` and `flux_respond_error` (#2120)\n\n### Fixes\n\n * misc build and test system fixes (#1912, #1914, #1915, #1925, #1941,\n    #2004, #2014, #2019, #2022, #2028, #2034, #2037, #2058, #2104, #2133,\n    #2124, #2177, #2221, #2128, #2229)\n * misc flux-broker fixes (#2172, #2178, #2175, #2181, #2194, #2197, \n * misc kvs fixes (#1907, #1936, #1945, #1946, #1966, #1949, #1965, #1969,\n    #1971, #1977, #2011, #2016, #2018, #2056, #2059, #2064, #2126, #2130,\n    #2136, #2138)\n * remove kvs classic library (#2017)\n * misc python fixes (#1934, #1962, #2046, #2218)\n * misc libflux-core fixes (#1939, #1942, #1956, #1982, #2091, #2097, #2099,\n    #2153, #2164)\n * do not version libpmi*.so (#1992)\n * ensure system python path is not pushed to front of PYTHONPATH (#2144)\n * flux-exec fixes: (#1997, #2005, #2248)\n * libpmi fixes (#2185)\n * libidset fixes (#1928, #1975, #1978, #2060)\n * jobspec fixes and updates (#1996, #2081, #2096)\n * other fixes (#1989, #2090, #2151, #2280, #2282)\n\n \nflux-core version 0.11.0 - 2019-01-03\n-------------------------------------\n\n### Fixes\n * flux-module: increase width of size field in list output (#1883)\n * kvs: return errors to callers on asynchronous load/store failures (#1836)\n * flux-start: dispatch orphan brokers, fully clean up temp directories (#1835)\n * flux-exec: ensure stdin is restored to blocking mode on exit (#1814)\n * broker: don't connect to enclosing instance (#1798)\n * flux (command): handle inaccessible build directory, fix PATH issue (#1683)\n * wreck: fix incorrect error handling in job module (#1617)\n * libflux: improve efficiency of asynchronous futures (#1840)\n * libflux: fix composite future implementation (#1791)\n * libflux: improve lookup efficiency of RPC message handlers (#1807)\n * libflux: give all aux set/get interfaces uniform semantics (#1797)\n * update to libev 4.25, ensure valgrind runs clean on i686 (#1898)\n\n### New Features\n * license: re-publish project under LGPLv3 (#1829, #1788, #1901)\n * wreck: use direct stdio transport, unless -okz option (#1875, #1896, #1900)\n * wreck: add new -J, --name=JOBNAME option to flux-wreckrun and submit (#1893)\n * libflux: support queue of future fulfillments (#1610)\n * libflux: support dynamic service registration (#1753, #1856)\n * kvs: replace inefficient KVS watch implementation and outdated API (#1891,\n   #1890, #1882, #1878, #1879, #1873, #1870, #1868, #1863,\n   #1861, #1859, #1850, #1848, #1820, #1643, #1622)\n * job: add job-ingest, job-manager modules, and API (experimental)\n   (#1867, #1774, #1734, #1626)\n * libidset: expand API to replace internal nodeset class (#1862)\n * libflux: add KVS copy and move composite functions (#1828)\n * libflux: access broker, library, command versions (#1817)\n * kvs: restart with existing content sqlite, root reference (#1800, #1812)\n * python: add job & mrpc bindings (#1757, #1892)\n * python: add flux python command to run configured python (#1766)\n * python: add flux-security bindings (#1716)\n * python: Python3 compatibility (#1673)\n * kvs: add RFC 18 eventlog support (#1671)\n * libsubprocess: cleanup and redesign\n   (#1713, #1664, #1659, #1658, #1654, #1645, #1636, #1629)\n * libflux/buffer: Add trimmed peek/read line variants (#1639)\n * build: add library versioning support (#1874)\n * build: add support for asciidoctor as manpage generator (#1650, #1676)\n * travis-ci: run tests under docker (#1688, #1684, #1670)\n\n### Cleanup\n * libflux: drop broker zeromq security functions from public API (#1846)\n * libflux: clean up interface for broker attributes (#1845)\n * libflux: drop reduction code from public API (#1844)\n * libutil: switch from munge to libsodium base64 implementation (#1786)\n * python: python binding is no longer optional (#1772)\n * python: add \"black\" format check, and reformat existing code (#1802)\n * python/lua: avoid deprecated kvs functions (#1748)\n * kvs: misc cleanup, refactoring, and fixes\n   (#1805, #1813, #1773, #1764, #1712, #1696, #1694)\n * broker: drop epgm event distribution (and munge dependency) (#1746)\n * content-sqlite: switch from lzo to lz4 (#1740)\n * libpmi: drop PMIx client support (#1663)\n * libpmi: avoid synchronous RPCs in simple-server kvs (#1615)\n * modules/cron: misc cleanup (#1657)\n * RFC 7: fix various style violations (#1705, #1717, #1706, #1611)\n * gcc8: fix output truncation (#1642)\n * sanitizer: fix memory leaks (#1737, #1736, #1739, #1737, #1735, #1733)\n * build: misc. cleanup and fixes (#1886, #1795, #1824, #1827, #1701, #1678)\n * test: misc. cleanup and fixes (#1644, #1704, #1691, 1640)\n\n\nflux-core version 0.10.0 - 2018-07-26\n-------------------------------------\n\n### Fixes\n * fix python kz binding errors (#1537)\n * fix default socket path and config file parsing for flux-broker (#1577)\n * Lua 5.2 compatibility and other Lua fixes (#1586, #1594)\n * flux PMI server response before closing (#1528)\n\n### New Features\n * support cpu affinity for wreck jobs (#1533, #1603)\n * support for GPU device discovery through hwloc (#1561)\n * set CUDA_VISIBLE_DEVICES for jobs with GPUs (#1599)\n * add ability to bootstrap Flux using pmix (#1580)\n * add `flux wreck sched-params` cmd to tune scheduler at runtime (#1579)\n * support `-o mpi=spectrum` for spectrum MPI launch (#1578, #1588)\n * allow generic JSON values in aggregator (#1535)\n * new --wrap=arg0,arg1 option to flux-start (#1542)\n * allow arbitrary error strings in RPC responses (#1538)\n * support for composite flux_future_t types (#1553)\n * add buffered I/O support to Flux API (#1518, #1547, #1548)\n * remove extra line breaks in Flux log messages (#1530)\n * add Flux Locally Unique ID (FLUID) implementation (#1541)\n\n### Cleanup\n * remove json-c (#1522, #1524, #1525, #1527, #1529)\n * libidset internal cleanup (#1521)\n * libsubprocess cleanup (#1549)\n * drop PMIx heuristic in libpmi (#1575)\n * add missing `#!/bin/bash` to all rc1 scripts (#1597)\n\nflux-core version 0.9.0 - 2018-05-10\n------------------------------------\n\n### Fixes\n * numerous memory leak fixes (#1494, #1322)\n * better support for C++ code (#1225, #1223, #1204)\n * massive scalability improvement for libkz readers (#1411, #1424)\n * increase job submission throughput (#1472, #1389)\n * reduce amount of information collected in resource-hwloc to\n    enhance large instance startup (#1457)\n * i686 portability fixes (#1296)\n * fixes for `flux-kvs dir` and `ls` usage (#1444, #1452)\n * fix for clock_gettime workaround in Lua bindings (#1371)\n * update minimum libhwloc to 1.11.1 to avoid assertion failure (#1478)\n * fix incorrect output from option parsing when invalid short\n    option is grouped with valid options in many commands (#1183)\n * fix thread cancellation in sqlite module (#1196)\n * fix segfault on 32bit systems in cron module (#1178)\n * log errors from event redistribution (#1457)\n * increase number of open files in `wrexecd` (#1450)\n * fix job hangs during final task IO output flush (#1450)\n * fixes for `flux-wreck purge` (#1357)\n * scalability fixes for `flux-wreck` subcommands (#1372)\n * general reduction in log messages at INFO level (#1450)\n * improve valgrind.h detection (#1502)\n * fix pkg-config pc name for liboptparse (#1506)\n * fix flux executable run-from-build-tree auto-detection (#1515)\n\n### New Features\n * support config file boot method for broker (#1320)\n * new `flux-kvs ls` command (#1172, #1444)\n * new kvs transaction API (#1346, #1348, #1351)\n * support for KVS namespaces (#1286, #1299, #1316, #1323, #1320, #1327,\n    #1336, #1390, #1423, #1432, #1436)\n * support for node inclusion,exclusion via flux-wreck command (#1418)\n * initial parser for jobspec (#1201, #1293, #1306)\n * store child instance URI in enclosing instance (#1429)\n * new `flux-wreck uri` command to fetch child instance URIs (#1429)\n * additional states from kvs module (#1310)\n * append support for KVS values (#1265)\n * support multiple blobrefs per valref in kvs (#1227, #1237)\n * add `flux_kvs_lookup_get_raw`(3) (#1218)\n * add `flux_kvs_lookup_get_key`(3) (#1414)\n * add `flux_event_publish`(3) to libflux API (#1512)\n * support for composite futures in libflux (#1188)\n * add `flux_future_reset`(3) to support multi-response RPCs (#1503)\n * new libflux-idset library (#1498)\n * support raw payloads in `flux-event` (#1488)\n * add raw encode/decode to `flux_event_*` API (#1486)\n * introduce `R_lite` format for job allocation description (#1399, #1485)\n * new `flux-hostlist` command for listing hostnames for jobs (#1499)\n * new `flux-wreck` environment manipulation commands (#1405)\n * `flux-wreck ls` returns active jobs first (#1481)\n * `flux-wreck` tools allow filtering on active,inactive jobs (#1481)\n * `flux-wreckrun` will now block until job is scheduled by default, use the\n    new --immediate flag to get old behavior (#1399)\n * add `flux-wreck cancel` command to cancel pending job (#1365, #1367, #1385)\n * add `flux-wreck dumplog` command to dump error log for jobs (#1450)\n * add new `KZ_FLAGS_NOFOLLOW` flag to avoid blocking when no data in a kz\n    file (#1450)\n * add `-n, --no-follow` option to `flux-wreck attach` (#1450)\n * propagate gpu and cores information for `flux-wreckrun` and `submit`\n   (#1399, #1480)\n * use cmb.exec service to launch `wrexecd`, not direct exec (#1508)\n * new `completing` state for jobs (#1513)\n * support job epilog pre-complete and post-complete scripts (#1513)\n * support output to stderr with `flux_log` functions (#1192)\n \n\n### Cleanup\n * kvs: major cleanup (#1154, #1177, #1182, #1190, #1214, #1213, #1233,\n    #1235, #1242, #1243, #1244, #1246, #1248, #1253, #1257, #1262, #1263,\n    #1268, #1269, #1273, #1274, #1276, #1279, #1300, #1301, #1304, #1308,\n    #1309, #1301, #1314, #1315, #1321, #1329, #1339, #1342, #1343, #1347,\n    #1349, #1353, #1383, #1402, #1404, #1440, #1458, #1466, #1477)\n * kvs: improved test coverage (#1291)\n * Add const to message payload accessor functions (#1212)\n * rename `flux_mrpcf`, `flux_mrpc_getf` to `flux_mrpc_pack`,`unpack` (#1338)\n * cleanup bulk message hanglers in libflux (#1277)\n * minor `flux_msg_handler` cleanup (#1171)\n * broker: cleanup to prepare for dynamic service registration (#1189)\n * broker: general cleanup (#1230, #1234, #1241)\n * Change key lwj to jobid in all jsc/wreck messages (#1409)\n * libjsc cleanup (#1374, #1395, #1509)\n * testsuite updates (#1167, #1175, #1313, #1464, #1266)\n * Internal libutil and libflux cleanup (#1319, #1283, #1229, #1231, #1166)\n * build system cleanup (#1163, #1354, #1184, #1200, #1275, #1252)\n * disable pylint by default (#1255, #1258)\n * partial migration from json-c to jansson (#1501, #1508) \n * drop unused `ev_zlist` composite watcher (#1493)\n\n\nflux-core version 0.8.0 - 2017-08-23\n------------------------------------\n\n#### Fixes\n * libflux: remove calls to functions that exit on error (#1060)\n * fix flux_reactor_run() to return active watcher count (#1085)\n * fix flux path detection when install path contains symlinks (#1122)\n * lua: fix refcount bug in kvs bindings (#1116)\n * kvs: oom() fixes (#1124, #1128)\n * kvs: Fix forced dirty bit clear error (#1133)\n * kvs: fix invalid memory read (#1065)\n * kvs: directory walk return error fixes (#1058)\n * kvs_classic: fix kvs(dir)_put_double (#1114)\n * fix memory leaks detected by valgrind (#1076)\n * avoid deadlock when unloading connector-local module (#1027)\n * fix several arm7l portability issues (#1023)\n * optparse: test and allow adjustment of posixly-correct behavior (#1049)\n * Small improvements for systemd unit file and install paths (#1037)\n * fix small leak in flux cmd driver (#1067)\n\n#### New Features\n * add FLUX_MSGFLAG_PRIVATE and allow guests to content load/store (#1032)\n * allow guests to access hwloc topology (#1043)\n * libflux: new flux_future_t API (#1083)\n * libflux: implement RPCs in terms of futures (#1089)\n * kvs: implement transaction objects (#1107)\n * connector-local: Fix compiler warning (#1031)\n * add optional initial program timeout, for test scripts (#1129)\n * libutil: new dirwalk interface (#1072, #1061, #1059)\n * connector-local: add exponential backoff to connect retry count (#1148)\n * support tbon.endpoint and mcast.endpoint attributes (#1030)\n * content: allow hash type to be configured (#1051)\n\n#### Cleanup\n * update many broker attribute names (#1042)\n * consolidate installed libraries and source tree cleanup (#1095)\n * convert broker from json-c to jansson (#1050)\n * libflux: rename jansson pack/unpack-based Flux API functions (#1104)\n * kvs: various code cleanup (#1057, #1073, #1079, #1099, #1119, #1123, #1153)\n * kvs: refactor kvs commit, lookup, and walk logic (#1066, #1105)\n * kvs: drop unused, legacy and deprecated functions (#1100, #1116)\n * kvs: switch from json-c to jansson (#1108, #1153)\n * Misc Cleanup/Minor Fixes from KVS TreeObject Work (#1152)\n * cron: avoid use of json-c and xzmalloc (#1143)\n * Change void * to void ** in flux_msg_get_payload (#1144)\n * python: make bindings compatible with newer versions of pylint (#1113)\n * barrier: cleanup (#1092)\n * tweak watcher structure, add external watcher construction interface\n   (#1082)\n * drop coprocess programming model (#1081)\n * split flux_mrpc() out to its own class (#1080)\n * deprecate some libutil classes (#1047)\n * cleanup of flux_msg_copy(), flux_rpc_aux_set() etc. (#1056)\n\n#### Testing\n * update sharness version to upstream 1.0.0 version (#1035)\n * cleanup kvs tests (#1149)\n * mitigate slow builds in Travis-CI (#1142)\n * fix --chain-lint option in sharness tests (#1125)\n * t2000-wreck.t: fix intermittent failures (#1102, #1109)\n * kvs: Add json_util unit tests (#1106)\n * run valgrind if available as part of make check (#1076, #1098)\n * add FLUX_PMI_SINGLETON env variable to avoid SLURMs libpmi in valgrind\n   test (#1091)\n * other test improvements (#1087)\n * update soak test for recent flux changes (#1072)\n * test/security: Fix test corner case (#1029)\n\n#### Documentation\n * add missing manpages, minor manpage fixes (#1045)\n * improve reactor documentation (#1086)\n * Code comments and documentation cleanup (#1138)\n\nflux-core version 0.7.0 - 2017-04-01\n------------------------------------\n\n#### Fixes\n\n * Improve reliability of module unloading (#1017)\n * Update autotools for `make dist` to support newer arches (#1016)\n * Fix corner cases in resource-hwloc module (#1012)\n * Ensure destructors are called during broker shutdown (#1005)\n * `flux-logger(1)` and `flux_log(3)` can return error (#1000)\n * Fix balancing of Caliper hooks in RPC calls (#991)\n * Fix missed errors in subscribe/unsubscribe on local connector (#994)\n * sanitize log entries before they enter circular buffer (#959)\n * Do not send wreck.state.complete event before job archival (#955) \n * Update embedded libev to 4.24 (#944)\n * Propagate argument quoting properly in `flux-start` and `flux-broker` (#931)\n * Fixes and improvements in liboptparse (#922, #927, #929)\n * Tighten up PMI implementation for OpenMPI (#926)\n\n#### New Features\n\n * Allow user other than instance owner to connect to an instance (#980)\n * Systemd support, default run directory and URI for system instance\n   (#992, #995)\n * New `--bootstrap` option to `flux-start` (#990)\n * New `KVS_NO_MERGE` flag in kvs commit and fence operations (#982)\n * Add `broker.pid` to broker attributes (#954)\n * `flux start` only execs broker if `--size` is not specified (#951)\n * Add pkg-config package for Flux PMI (#921)\n\n#### Cleanup\n\n * Remove live module (#1003)\n * Remove flux-up and flux-topo (#960)\n * Transition away from deprecated czmq classes (#1013)\n * Re-architect and improve many internal and cmd rpc functions (#1002, #1009)\n * Other major and minor cleanup (#919, #928, #941, #940, #942, #954, #969,\n    #976, #981, #978, #986, #990, #1001, #1008)\n * Remove `cmb.` prefix from broker services (#947)\n\n#### Testing\n\n * Expand and improve unit and system tests for greater code coverage\n   (#937, #942, #979, #985, #991, #1004, #1011, #1013, #1014)\n * Fix documentation spellcheck (#1015)\n * Add dependency on \"all\" to top-level `make check` (#970)\n * Add flake8/pylint checks (#816)\n\n#### Documentation\n\n * Improve flux_reactor_create documentation (#970)\n * Update flux_msg_cmp(3) and flux_recv(3) to match flux_match changes (#946)\n * Update flux-submit(1) and flux-wreckrun(1) manpages (#945)\n\n\nflux-core version 0.6.0 - 2016-11-29\n------------------------------------\n\n#### Fixes\n\n * Fixes for ATS testsuite compatibility (#914)\n * python: install kz bindings file (#895)\n * broker: adjust errno response to \"upstream\" request on rank 0 (#913)\n * Fix for possible unconstrained memory growth in modules/libjsc (#891)\n * Fix error message on flux-help failure (#887)\n * Issue fatal error in wrexecd for invalid tasks on node (#901)\n * Fix barrier protocol incompatability with older jansson versions (#889)\n\n#### New Features\n\n * Add a flux content service API (#903)\n * Enhance option parsing library for thread safety and new features\n  (#908, #910, #911)\n * Add flux_rpcf_multi() (#909)\n * Add new \"any\" and \"upstream\" nodeset options (#909)\n * Add HostName key in resource-hwloc `by_rank` directory to allow\n   easy resolution of rank to hostname in a flux session (#892)\n * Add `-d` option to `flux-kvs dir`, `dirat`, and `watchdir` to restrict\n   output to key only. (#896)\n\n#### Cleanup\n\n * `flux-ping` refactor and cleanup (#898, #904)\n * Check expected size of `json_int_t` during configure (#902)\n * Other various cleanup, refactoring and testing updates.\n\n\nflux-core version 0.5.0 - 2016-10-27\n------------------------------------\n\n* barrier module cleanup and debug logging (#885)\n* Various minor cleanup and documentation updates (#886)\n* use jansson >= 2.6 and document JSON payload functions (#884)\n* fix MANPATH for Ubuntu, and tidy up travis dep builder (#877)\n* fixes for minor issues detected by Coverity (#876)\n* build: add --disable-docs configure option (#871)\n* kvs: allow get_double to be called on an int (#872)\n* README.md: Update srun instructions (#867)\n* misc minor fixes (#862)\n* make flux_msg_t a bonafide type, add jansson payload accessors (#857)\n* Fix --rank issues, add NODESET documentation, and minor cleanup (#860)\n* Fix output errors with flux up --comma & --newline, add appropriate tests (#858)\n* Add hierarchical lwj directory support in kvs (#811)\n* doc/man1/flux-start.adoc: Fix example option usage (#852)\n* add dlopen RTLD_DEEPBIND flag (#849)\n* src/broker/broker.c: Fix typo flux_repond -> flux_respond (#851)\n* doc/man1/flux-module.adoc: Fix environment variable error (#850)\n* Pull in json-c, allowing internals to link against alternate json libraries. (#835)\n* Add enhanced flux_rpc functions using libjansson json_pack/unpack functions\n* Update flux_t * references in man pages (#844)\n* Remove pointer from typedef flux_t (#841)\n* Remove JSON typedef, just use json_object * (#832)\n* module: Remove pointer from typedef flux_modlist_t (#831)\n* security: Remove pointer from typedef flux_sec_t (#830)\n* and related functions (#824)\n* experimental aggregator module (#787)\n* kvs: testing, fix use-after-free, streamline python bindings (#823)\n* Fix #821: crash in kvs due to NULL arg in Jget_str() (#822)\n* python: add a check for invalid handle types (#819)\n* Python json and constant rework (#799)\n* Python destructor refactoring and exception safety (#807)\n* libutil/veb: quiet uninitialized variable warning in vebnew (#809)\n* when tagpool is exhausted, grow up to RFC 6 limits (#806)\n* add KVS blobref access functions (#801)\n* Fix missing error checks in Lua bindings, flux-wreckrun, flux-wreck (#804)\n* python: Several fixes for the bindings (#794)\n* Switch lua scripts to use lua interpreter in PATH (#789)\n* restructure kvs commit handling code for correctness (#788)\n* broker/hello: fix leak/error detection in flux_rpc (#786)\n* implement scalable reduction for wireup protocol (#781)\n* wreck: minor enhancements for scale testing (#782)\n* increase KVS commit window (#780)\n* autogen.sh: run libtoolize before autoreconf (#771)\n* clean up LOG_INFO output, log wireup, rc1, rc3 times, add pmi timing. (#769)\n* optparse: remove requirement for option key on long-only options (and other fixes) (#768)\n\n#### Testing\n\n* add test to verify KVS int can be read as double (#878)\n* travis-ci: minor updates (#865)\n* jsc test: Add timed waits to avoid races (#859)\n* t/t0005-exec.t: Fix corner case in test for file not found (#848)\n* Fix make distcheck (#847)\n* t/t2000-wreck.t: Fix invalid compare on per-task affinity test (#837)\n* t/t2000-wreck.t: Fix invalid compare on 'wreckrun: --input=0 works' test (#836)\n* travis.yml:  Fix ANCHOR definition (#767)\n\nflux-core version 0.4.1 - 2016-08-12\n------------------------------------\n\n* python `kvs_watch()` fix (#759)\n\n* include man7 in distribution (#762)\n\n\nflux-core version 0.4.0 - 2016-08-11\n------------------------------------\n\n#### Scalability improvements\n\n* don't store broken-down hwloc topology in the KVS (#716)\n\n* route rank-addressed requests via TBON (#689)\n\n* streamline matchtag handling (#687)\n\n* keep active jobs in a separate KVS namespace from \"archived\" jobs (#609)\n\n#### New features\n\n* implement PMI-1 simple server in wrexecd (#706)\n\n* add skeletal PMI-2 library (based on PMI-1) (#747)\n\n* make libflux-optparse.so available externally (#702)\n\n* asynchronous KVS fence and rewritten fence path in KVS module (#707, #729)\n\n* `flux-cron`, a cron/at-like service (#626)\n\n* `flux-proxy` and `ssh://` connector (#645)\n\n#### Other changes\n\n* Use RFC 5424 log format for internal logging, not ad hoc JSON (#691)\n\n* Add wreck lua.d MPI personalities (#669, #743, #747)\n\n* Improved command line for launching flux from slurm/flux (#658)\n\n* Assorted code cleanup.\n\n* Automatic github release upload on tags (#744)\n\n#### Deprecations\n\n* Sophia content backing store module (#727)\n\n* mrpc KVS based muti-RPC interface (#689)\n\n* ZPL config file (#674)\n\n* Ring overlay network (#689)\n\n#### Testing\n\n* Print backtraces for any core files generated in travis-ci (#703)\n\n* Add cppcheck target to travis-ci (#701)\n\n* configure --enable-sanitizer for AddressSanitizer, ThreadSanitizer (#694)\n\n* caliper based profiling (#741)\n\n* coverage uploaded to CodeCof (#751)\n\n* improved test coverage\n\n\nflux-core version 0.3.0 - 2016-04-26\n------------------------------------\n\n* Add support for launching Intel MPI, OpenMPI using PMIv1.\n  Use the broker circular log buffer for PMI tracing.\n\n* Add flux wreck timing subcommand which prints time from\n  - STARTING: reserved->starting\n  - RUNNING:  starting->running\n  - COMPLETE: running->complete\n  - TOTAL:    starting->complete\n\n* Add three \"run levels\" for Flux jobs:\n  1. run rc1 script on rank 0 to load modules, etc.\n  2. run the user's initial program\n  3. run rc3 script on rank 0 to unload modules, etc.\n\n* Add module status reporting via keepalive messages.\n  `flux module list` now reports live module status:\n  - I = intializing\n  - S = sleeping\n  - X = exited\n  - R = running\n  - F = finalizing\n\n* Conform to RFC 3 change that requires all JSON payloads to use\n  objects as the outermost JSON type (no bare arrays for example).\n\n* Add `flux nodeset` utility so scripts can manipulate nodesets.\n\n* Make `flux env` output suitable for use in bash/zsh eval.\n\n* Drop `flux module --direct` option.  Module load/unload/list is\n  now always direct between flux-module and broker(s).\n  Drop the `modctl` module for distributed module control.\n\n* When a module fails before entering its reactor loop, propagate\n  the error back to `flux module load` so the user knows the\n  load was not successful.\n\n* Address memory leaks and adjust KVS usage to ameliorate increasing\n  broker memory footprint and degrading job throughput when running\n  many small jobs back to back.  Active jobs are now stored under\n  `lwj-active` to avoid creating excessive versions of the larger `lwj`\n  directory as job state is accumulated.\n\n* Bug fixes to `live` (TBON self-healing) module.  The module is no\n  longer loaded by default, pending additional work.  `flux up` will\n  always report all ranks up when `live` is not loaded.\n\n* Send keepalives on the ring network and log idle peers on TBON\n  and ring at `LOG_CRIT` level, where \"idle\" means no messages in >= 3\n  heartbeats.\n\n* Compress large `content-sqlite` blobs with lzo to reduce disk\n  utilization.\n\n* KVS improvements:\n  - `kvs_put()` follows intermediate symlinks\n  - KVS operations bundled within one commit are applied in order\n  - add `kvs_copy()` and `kvs_move()` utility functions.\n\n* Configuration is loaded into broker attribute `config` namespace\n  rather than KVS, and is no longer inherited from the enclosing instance.\n\n* `flux` command driver usability improvements.\n\n* Flux API improvements including dropping deprecated functions\n  and fine tuning some function signatures (users should recompile).\n\n* Build system allows `--with-tcmalloc`, `--with-jemalloc`, and tcmalloc\n  heap profiling.\n\n* Fine tuning of log levels and messages.\n\n* Documentation improvements.\n\n* Test suite improvements/fixes.\n\n\nflux-core version 0.2.0 - 2016-02-16\n------------------------------------\n\n* Avoid putting the Flux libpmi.so in the system ld.so path on systems\n  where Flux is installed to the default system prefix, as this could\n  interfere with MPI runtimes under other resource managers.\n\n* Enable the SQLite backing store for the KVS by default, which\n  addresses unchecked memory growth in the rank 0 broker.\n\n* Stability and usability improvements to the flux-hwloc subcommand,\n  and resource-hwloc comms module.\n\n* Added the flux-version subcommand.\n\n* Build system fixes.\n\n* Test suite fixes.\n\nflux-core version 0.1.0 - 2016-01-27\n------------------------------------\n\nInitial release for build testing only.\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-i6dcpentpa3wkcp6mwcurdfsjksgyiyg/spack-src/config/ax_lua.m4": "# ===========================================================================\n#          https://www.gnu.org/software/autoconf-archive/ax_lua.html\n# ===========================================================================\n#\n# SYNOPSIS\n#\n#   AX_PROG_LUA[([MINIMUM-VERSION], [TOO-BIG-VERSION], [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])]\n#   AX_LUA_HEADERS[([ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])]\n#   AX_LUA_LIBS[([ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])]\n#   AX_LUA_READLINE[([ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])]\n#\n# DESCRIPTION\n#\n#   Detect a Lua interpreter, optionally specifying a minimum and maximum\n#   version number. Set up important Lua paths, such as the directories in\n#   which to install scripts and modules (shared libraries).\n#\n#   Also detect Lua headers and libraries. The Lua version contained in the\n#   header is checked to match the Lua interpreter version exactly. When\n#   searching for Lua libraries, the version number is used as a suffix.\n#   This is done with the goal of supporting multiple Lua installs (5.1,\n#   5.2, and 5.3 side-by-side).\n#\n#   A note on compatibility with previous versions: This file has been\n#   mostly rewritten for serial 18. Most developers should be able to use\n#   these macros without needing to modify configure.ac. Care has been taken\n#   to preserve each macro's behavior, but there are some differences:\n#\n#   1) AX_WITH_LUA is deprecated; it now expands to the exact same thing as\n#   AX_PROG_LUA with no arguments.\n#\n#   2) AX_LUA_HEADERS now checks that the version number defined in lua.h\n#   matches the interpreter version. AX_LUA_HEADERS_VERSION is therefore\n#   unnecessary, so it is deprecated and does not expand to anything.\n#\n#   3) The configure flag --with-lua-suffix no longer exists; the user\n#   should instead specify the LUA precious variable on the command line.\n#   See the AX_PROG_LUA description for details.\n#\n#   Please read the macro descriptions below for more information.\n#\n#   This file was inspired by Andrew Dalke's and James Henstridge's\n#   python.m4 and Tom Payne's, Matthieu Moy's, and Reuben Thomas's ax_lua.m4\n#   (serial 17). Basically, this file is a mash-up of those two files. I\n#   like to think it combines the best of the two!\n#\n#   AX_PROG_LUA: Search for the Lua interpreter, and set up important Lua\n#   paths. Adds precious variable LUA, which may contain the path of the Lua\n#   interpreter. If LUA is blank, the user's path is searched for an\n#   suitable interpreter.\n#\n#   If MINIMUM-VERSION is supplied, then only Lua interpreters with a\n#   version number greater or equal to MINIMUM-VERSION will be accepted. If\n#   TOO-BIG-VERSION is also supplied, then only Lua interpreters with a\n#   version number greater or equal to MINIMUM-VERSION and less than\n#   TOO-BIG-VERSION will be accepted.\n#\n#   The Lua version number, LUA_VERSION, is found from the interpreter, and\n#   substituted. LUA_PLATFORM is also found, but not currently supported (no\n#   standard representation).\n#\n#   Finally, the macro finds four paths:\n#\n#     luadir             Directory to install Lua scripts.\n#     pkgluadir          $luadir/$PACKAGE\n#     luaexecdir         Directory to install Lua modules.\n#     pkgluaexecdir      $luaexecdir/$PACKAGE\n#\n#   These paths are found based on $prefix, $exec_prefix, Lua's\n#   package.path, and package.cpath. The first path of package.path\n#   beginning with $prefix is selected as luadir. The first path of\n#   package.cpath beginning with $exec_prefix is used as luaexecdir. This\n#   should work on all reasonable Lua installations. If a path cannot be\n#   determined, a default path is used. Of course, the user can override\n#   these later when invoking make.\n#\n#     luadir             Default: $prefix/share/lua/$LUA_VERSION\n#     luaexecdir         Default: $exec_prefix/lib/lua/$LUA_VERSION\n#\n#   These directories can be used by Automake as install destinations. The\n#   variable name minus 'dir' needs to be used as a prefix to the\n#   appropriate Automake primary, e.g. lua_SCRIPS or luaexec_LIBRARIES.\n#\n#   If an acceptable Lua interpreter is found, then ACTION-IF-FOUND is\n#   performed, otherwise ACTION-IF-NOT-FOUND is preformed. If ACTION-IF-NOT-\n#   FOUND is blank, then it will default to printing an error. To prevent\n#   the default behavior, give ':' as an action.\n#\n#   AX_LUA_HEADERS: Search for Lua headers. Requires that AX_PROG_LUA be\n#   expanded before this macro. Adds precious variable LUA_INCLUDE, which\n#   may contain Lua specific include flags, e.g. -I/usr/include/lua5.1. If\n#   LUA_INCLUDE is blank, then this macro will attempt to find suitable\n#   flags.\n#\n#   LUA_INCLUDE can be used by Automake to compile Lua modules or\n#   executables with embedded interpreters. The *_CPPFLAGS variables should\n#   be used for this purpose, e.g. myprog_CPPFLAGS = $(LUA_INCLUDE).\n#\n#   This macro searches for the header lua.h (and others). The search is\n#   performed with a combination of CPPFLAGS, CPATH, etc, and LUA_INCLUDE.\n#   If the search is unsuccessful, then some common directories are tried.\n#   If the headers are then found, then LUA_INCLUDE is set accordingly.\n#\n#   The paths automatically searched are:\n#\n#     * /usr/include/luaX.Y\n#     * /usr/include/lua/X.Y\n#     * /usr/include/luaXY\n#     * /usr/local/include/luaX.Y\n#     * /usr/local/include/lua-X.Y\n#     * /usr/local/include/lua/X.Y\n#     * /usr/local/include/luaXY\n#\n#   (Where X.Y is the Lua version number, e.g. 5.1.)\n#\n#   The Lua version number found in the headers is always checked to match\n#   the Lua interpreter's version number. Lua headers with mismatched\n#   version numbers are not accepted.\n#\n#   If headers are found, then ACTION-IF-FOUND is performed, otherwise\n#   ACTION-IF-NOT-FOUND is performed. If ACTION-IF-NOT-FOUND is blank, then\n#   it will default to printing an error. To prevent the default behavior,\n#   set the action to ':'.\n#\n#   AX_LUA_LIBS: Search for Lua libraries. Requires that AX_PROG_LUA be\n#   expanded before this macro. Adds precious variable LUA_LIB, which may\n#   contain Lua specific linker flags, e.g. -llua5.1. If LUA_LIB is blank,\n#   then this macro will attempt to find suitable flags.\n#\n#   LUA_LIB can be used by Automake to link Lua modules or executables with\n#   embedded interpreters. The *_LIBADD and *_LDADD variables should be used\n#   for this purpose, e.g. mymod_LIBADD = $(LUA_LIB).\n#\n#   This macro searches for the Lua library. More technically, it searches\n#   for a library containing the function lua_load. The search is performed\n#   with a combination of LIBS, LIBRARY_PATH, and LUA_LIB.\n#\n#   If the search determines that some linker flags are missing, then those\n#   flags will be added to LUA_LIB.\n#\n#   If libraries are found, then ACTION-IF-FOUND is performed, otherwise\n#   ACTION-IF-NOT-FOUND is performed. If ACTION-IF-NOT-FOUND is blank, then\n#   it will default to printing an error. To prevent the default behavior,\n#   set the action to ':'.\n#\n#   AX_LUA_READLINE: Search for readline headers and libraries. Requires the\n#   AX_LIB_READLINE macro, which is provided by ax_lib_readline.m4 from the\n#   Autoconf Archive.\n#\n#   If a readline compatible library is found, then ACTION-IF-FOUND is\n#   performed, otherwise ACTION-IF-NOT-FOUND is performed.\n#\n# LICENSE\n#\n#   Copyright (c) 2015 Reuben Thomas <rrt@sc3d.org>\n#   Copyright (c) 2014 Tim Perkins <tprk77@gmail.com>\n#\n#   This program is free software: you can redistribute it and/or modify it\n#   under the terms of the GNU General Public License as published by the\n#   Free Software Foundation, either version 3 of the License, or (at your\n#   option) any later version.\n#\n#   This program is distributed in the hope that it will be useful, but\n#   WITHOUT ANY WARRANTY; without even the implied warranty of\n#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\n#   Public License for more details.\n#\n#   You should have received a copy of the GNU General Public License along\n#   with this program. If not, see <https://www.gnu.org/licenses/>.\n#\n#   As a special exception, the respective Autoconf Macro's copyright owner\n#   gives unlimited permission to copy, distribute and modify the configure\n#   scripts that are the output of Autoconf when processing the Macro. You\n#   need not follow the terms of the GNU General Public License when using\n#   or distributing such scripts, even though portions of the text of the\n#   Macro appear in them. The GNU General Public License (GPL) does govern\n#   all other use of the material that constitutes the Autoconf Macro.\n#\n#   This special exception to the GPL applies to versions of the Autoconf\n#   Macro released by the Autoconf Archive. When you make and distribute a\n#   modified version of the Autoconf Macro, you may extend this special\n#   exception to the GPL to apply to your modified version as well.\n\n#serial 40\n\ndnl =========================================================================\ndnl AX_PROG_LUA([MINIMUM-VERSION], [TOO-BIG-VERSION],\ndnl             [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])\ndnl =========================================================================\nAC_DEFUN([AX_PROG_LUA],\n[\n  dnl Check for required tools.\n  AC_REQUIRE([AC_PROG_GREP])\n  AC_REQUIRE([AC_PROG_SED])\n\n  dnl Make LUA a precious variable.\n  AC_ARG_VAR([LUA], [The Lua interpreter, e.g. /usr/bin/lua5.1])\n\n  dnl Find a Lua interpreter.\n  m4_define_default([_AX_LUA_INTERPRETER_LIST],\n    [lua lua5.3 lua53 lua5.2 lua52 lua5.1 lua51 lua50])\n\n  m4_if([$1], [],\n  [ dnl No version check is needed. Find any Lua interpreter.\n    AS_IF([test \"x$LUA\" = 'x'],\n      [AC_PATH_PROGS([LUA], [_AX_LUA_INTERPRETER_LIST], [:])])\n    ax_display_LUA='lua'\n\n    AS_IF([test \"x$LUA\" != 'x:'],\n      [ dnl At least check if this is a Lua interpreter.\n        AC_MSG_CHECKING([if $LUA is a Lua interpreter])\n        _AX_LUA_CHK_IS_INTRP([$LUA],\n          [AC_MSG_RESULT([yes])],\n          [ AC_MSG_RESULT([no])\n            AC_MSG_ERROR([not a Lua interpreter])\n          ])\n      ])\n  ],\n  [ dnl A version check is needed.\n    AS_IF([test \"x$LUA\" != 'x'],\n    [ dnl Check if this is a Lua interpreter.\n      AC_MSG_CHECKING([if $LUA is a Lua interpreter])\n      _AX_LUA_CHK_IS_INTRP([$LUA],\n        [AC_MSG_RESULT([yes])],\n        [ AC_MSG_RESULT([no])\n          AC_MSG_ERROR([not a Lua interpreter])\n        ])\n      dnl Check the version.\n      m4_if([$2], [],\n        [_ax_check_text=\"whether $LUA version >= $1\"],\n        [_ax_check_text=\"whether $LUA version >= $1, < $2\"])\n      AC_MSG_CHECKING([$_ax_check_text])\n      _AX_LUA_CHK_VER([$LUA], [$1], [$2],\n        [AC_MSG_RESULT([yes])],\n        [ AC_MSG_RESULT([no])\n          AC_MSG_ERROR([version is out of range for specified LUA])])\n      ax_display_LUA=$LUA\n    ],\n    [ dnl Try each interpreter until we find one that satisfies VERSION.\n      m4_if([$2], [],\n        [_ax_check_text=\"for a Lua interpreter with version >= $1\"],\n        [_ax_check_text=\"for a Lua interpreter with version >= $1, < $2\"])\n      AC_CACHE_CHECK([$_ax_check_text],\n        [ax_cv_pathless_LUA],\n        [ for ax_cv_pathless_LUA in _AX_LUA_INTERPRETER_LIST none; do\n            test \"x$ax_cv_pathless_LUA\" = 'xnone' && break\n            _AX_LUA_CHK_IS_INTRP([$ax_cv_pathless_LUA], [], [continue])\n            _AX_LUA_CHK_VER([$ax_cv_pathless_LUA], [$1], [$2], [break])\n          done\n        ])\n      dnl Set $LUA to the absolute path of $ax_cv_pathless_LUA.\n      AS_IF([test \"x$ax_cv_pathless_LUA\" = 'xnone'],\n        [LUA=':'],\n        [AC_PATH_PROG([LUA], [$ax_cv_pathless_LUA])])\n      ax_display_LUA=$ax_cv_pathless_LUA\n    ])\n  ])\n\n  AS_IF([test \"x$LUA\" = 'x:'],\n  [ dnl Run any user-specified action, or abort.\n    m4_default([$4], [AC_MSG_ERROR([cannot find suitable Lua interpreter])])\n  ],\n  [ dnl Query Lua for its version number.\n    AC_CACHE_CHECK([for $ax_display_LUA version],\n      [ax_cv_lua_version],\n      [ dnl Get the interpreter version in X.Y format. This should work for\n        dnl interpreters version 5.0 and beyond.\n        ax_cv_lua_version=[`$LUA -e '\n          -- return a version number in X.Y format\n          local _, _, ver = string.find(_VERSION, \"^Lua (%d+%.%d+)\")\n          print(ver)'`]\n      ])\n    AS_IF([test \"x$ax_cv_lua_version\" = 'x'],\n      [AC_MSG_ERROR([invalid Lua version number])])\n    AC_SUBST([LUA_VERSION], [$ax_cv_lua_version])\n    AC_SUBST([LUA_SHORT_VERSION], [`echo \"$LUA_VERSION\" | $SED 's|\\.||'`])\n\n    dnl The following check is not supported:\n    dnl At times (like when building shared libraries) you may want to know\n    dnl which OS platform Lua thinks this is.\n    AC_CACHE_CHECK([for $ax_display_LUA platform],\n      [ax_cv_lua_platform],\n      [ax_cv_lua_platform=[`$LUA -e 'print(\"unknown\")'`]])\n    AC_SUBST([LUA_PLATFORM], [$ax_cv_lua_platform])\n\n    dnl Use the values of $prefix and $exec_prefix for the corresponding\n    dnl values of LUA_PREFIX and LUA_EXEC_PREFIX. These are made distinct\n    dnl variables so they can be overridden if need be. However, the general\n    dnl consensus is that you shouldn't need this ability.\n    AC_SUBST([LUA_PREFIX], ['${prefix}'])\n    AC_SUBST([LUA_EXEC_PREFIX], ['${exec_prefix}'])\n\n    dnl Lua provides no way to query the script directory, and instead\n    dnl provides LUA_PATH. However, we should be able to make a safe educated\n    dnl guess. If the built-in search path contains a directory which is\n    dnl prefixed by $prefix, then we can store scripts there. The first\n    dnl matching path will be used.\n    AC_CACHE_CHECK([for $ax_display_LUA script directory],\n      [ax_cv_lua_luadir],\n      [ AS_IF([test \"x$prefix\" = 'xNONE'],\n          [ax_lua_prefix=$ac_default_prefix],\n          [ax_lua_prefix=$prefix])\n\n        dnl Initialize to the default path.\n        ax_cv_lua_luadir=\"$LUA_PREFIX/share/lua/$LUA_VERSION\"\n\n        dnl Try to find a path with the prefix.\n        _AX_LUA_FND_PRFX_PTH([$LUA], [$ax_lua_prefix], [script])\n        AS_IF([test \"x$ax_lua_prefixed_path\" != 'x'],\n        [ dnl Fix the prefix.\n          _ax_strip_prefix=`echo \"$ax_lua_prefix\" | $SED 's|.|.|g'`\n          ax_cv_lua_luadir=`echo \"$ax_lua_prefixed_path\" | \\\n            $SED \"s|^$_ax_strip_prefix|$LUA_PREFIX|\"`\n        ])\n      ])\n    AC_SUBST([luadir], [$ax_cv_lua_luadir])\n    AC_SUBST([pkgluadir], [\\${luadir}/$PACKAGE])\n\n    dnl Lua provides no way to query the module directory, and instead\n    dnl provides LUA_PATH. However, we should be able to make a safe educated\n    dnl guess. If the built-in search path contains a directory which is\n    dnl prefixed by $exec_prefix, then we can store modules there. The first\n    dnl matching path will be used.\n    AC_CACHE_CHECK([for $ax_display_LUA module directory],\n      [ax_cv_lua_luaexecdir],\n      [ AS_IF([test \"x$exec_prefix\" = 'xNONE'],\n          [ax_lua_exec_prefix=$ax_lua_prefix],\n          [ax_lua_exec_prefix=$exec_prefix])\n\n        dnl Initialize to the default path.\n        ax_cv_lua_luaexecdir=\"$LUA_EXEC_PREFIX/lib/lua/$LUA_VERSION\"\n\n        dnl Try to find a path with the prefix.\n        _AX_LUA_FND_PRFX_PTH([$LUA],\n          [$ax_lua_exec_prefix], [module])\n        AS_IF([test \"x$ax_lua_prefixed_path\" != 'x'],\n        [ dnl Fix the prefix.\n          _ax_strip_prefix=`echo \"$ax_lua_exec_prefix\" | $SED 's|.|.|g'`\n          ax_cv_lua_luaexecdir=`echo \"$ax_lua_prefixed_path\" | \\\n            $SED \"s|^$_ax_strip_prefix|$LUA_EXEC_PREFIX|\"`\n        ])\n      ])\n    AC_SUBST([luaexecdir], [$ax_cv_lua_luaexecdir])\n    AC_SUBST([pkgluaexecdir], [\\${luaexecdir}/$PACKAGE])\n\n    dnl Run any user specified action.\n    $3\n  ])\n])\n\ndnl AX_WITH_LUA is now the same thing as AX_PROG_LUA.\nAC_DEFUN([AX_WITH_LUA],\n[\n  AC_MSG_WARN([[$0 is deprecated, please use AX_PROG_LUA instead]])\n  AX_PROG_LUA\n])\n\n\ndnl =========================================================================\ndnl _AX_LUA_CHK_IS_INTRP(PROG, [ACTION-IF-TRUE], [ACTION-IF-FALSE])\ndnl =========================================================================\nAC_DEFUN([_AX_LUA_CHK_IS_INTRP],\n[\n  dnl A minimal Lua factorial to prove this is an interpreter. This should work\n  dnl for Lua interpreters version 5.0 and beyond.\n  _ax_lua_factorial=[`$1 2>/dev/null -e '\n    -- a simple factorial\n    function fact (n)\n      if n == 0 then\n        return 1\n      else\n        return n * fact(n-1)\n      end\n    end\n    print(\"fact(5) is \" .. fact(5))'`]\n  AS_IF([test \"$_ax_lua_factorial\" = 'fact(5) is 120'],\n    [$2], [$3])\n])\n\n\ndnl =========================================================================\ndnl _AX_LUA_CHK_VER(PROG, MINIMUM-VERSION, [TOO-BIG-VERSION],\ndnl                 [ACTION-IF-TRUE], [ACTION-IF-FALSE])\ndnl =========================================================================\nAC_DEFUN([_AX_LUA_CHK_VER],\n[\n  dnl Check that the Lua version is within the bounds. Only the major and minor\n  dnl version numbers are considered. This should work for Lua interpreters\n  dnl version 5.0 and beyond.\n  _ax_lua_good_version=[`$1 -e '\n    -- a script to compare versions\n    function verstr2num(verstr)\n      local _, _, majorver, minorver = string.find(verstr, \"^(%d+)%.(%d+)\")\n      if majorver and minorver then\n        return tonumber(majorver) * 100 + tonumber(minorver)\n      end\n    end\n    local minver = verstr2num(\"$2\")\n    local _, _, trimver = string.find(_VERSION, \"^Lua (.*)\")\n    local ver = verstr2num(trimver)\n    local maxver = verstr2num(\"$3\") or 1e9\n    if minver <= ver and ver < maxver then\n      print(\"yes\")\n    else\n      print(\"no\")\n    end'`]\n    AS_IF([test \"x$_ax_lua_good_version\" = \"xyes\"],\n      [$4], [$5])\n])\n\n\ndnl =========================================================================\ndnl _AX_LUA_FND_PRFX_PTH(PROG, PREFIX, SCRIPT-OR-MODULE-DIR)\ndnl =========================================================================\nAC_DEFUN([_AX_LUA_FND_PRFX_PTH],\n[\n  dnl Get the script or module directory by querying the Lua interpreter,\n  dnl filtering on the given prefix, and selecting the shallowest path. If no\n  dnl path is found matching the prefix, the result will be an empty string.\n  dnl The third argument determines the type of search, it can be 'script' or\n  dnl 'module'. Supplying 'script' will perform the search with package.path\n  dnl and LUA_PATH, and supplying 'module' will search with package.cpath and\n  dnl LUA_CPATH. This is done for compatibility with Lua 5.0.\n\n  ax_lua_prefixed_path=[`$1 -e '\n    -- get the path based on search type\n    local searchtype = \"$3\"\n    local paths = \"\"\n    if searchtype == \"script\" then\n      paths = (package and package.path) or LUA_PATH\n    elseif searchtype == \"module\" then\n      paths = (package and package.cpath) or LUA_CPATH\n    end\n    -- search for the prefix\n    local prefix = \"'$2'\"\n    local minpath = \"\"\n    local mindepth = 1e9\n    string.gsub(paths, \"(@<:@^;@:>@+)\",\n      function (path)\n        path = string.gsub(path, \"%?.*$\", \"\")\n        path = string.gsub(path, \"/@<:@^/@:>@*$\", \"\")\n        if string.find(path, prefix) then\n          local depth = string.len(string.gsub(path, \"@<:@^/@:>@\", \"\"))\n          if depth < mindepth then\n            minpath = path\n            mindepth = depth\n          end\n        end\n      end)\n    print(minpath)'`]\n])\n\n\ndnl =========================================================================\ndnl AX_LUA_HEADERS([ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])\ndnl =========================================================================\nAC_DEFUN([AX_LUA_HEADERS],\n[\n  dnl Check for LUA_VERSION.\n  AC_MSG_CHECKING([if LUA_VERSION is defined])\n  AS_IF([test \"x$LUA_VERSION\" != 'x'],\n    [AC_MSG_RESULT([yes])],\n    [ AC_MSG_RESULT([no])\n      AC_MSG_ERROR([cannot check Lua headers without knowing LUA_VERSION])\n    ])\n\n  dnl Make LUA_INCLUDE a precious variable.\n  AC_ARG_VAR([LUA_INCLUDE], [The Lua includes, e.g. -I/usr/include/lua5.1])\n\n  dnl Some default directories to search.\n  LUA_SHORT_VERSION=`echo \"$LUA_VERSION\" | $SED 's|\\.||'`\n  m4_define_default([_AX_LUA_INCLUDE_LIST],\n    [ /usr/include/lua$LUA_VERSION \\\n      /usr/include/lua-$LUA_VERSION \\\n      /usr/include/lua/$LUA_VERSION \\\n      /usr/include/lua$LUA_SHORT_VERSION \\\n      /usr/local/include/lua$LUA_VERSION \\\n      /usr/local/include/lua-$LUA_VERSION \\\n      /usr/local/include/lua/$LUA_VERSION \\\n      /usr/local/include/lua$LUA_SHORT_VERSION \\\n    ])\n\n  dnl Try to find the headers.\n  _ax_lua_saved_cppflags=$CPPFLAGS\n  CPPFLAGS=\"$CPPFLAGS $LUA_INCLUDE\"\n  AC_CHECK_HEADERS([lua.h lualib.h lauxlib.h luaconf.h])\n  CPPFLAGS=$_ax_lua_saved_cppflags\n\n  dnl Try some other directories if LUA_INCLUDE was not set.\n  AS_IF([test \"x$LUA_INCLUDE\" = 'x' &&\n         test \"x$ac_cv_header_lua_h\" != 'xyes'],\n    [ dnl Try some common include paths.\n      for _ax_include_path in _AX_LUA_INCLUDE_LIST; do\n        test ! -d \"$_ax_include_path\" && continue\n\n        AC_MSG_CHECKING([for Lua headers in])\n        AC_MSG_RESULT([$_ax_include_path])\n\n        AS_UNSET([ac_cv_header_lua_h])\n        AS_UNSET([ac_cv_header_lualib_h])\n        AS_UNSET([ac_cv_header_lauxlib_h])\n        AS_UNSET([ac_cv_header_luaconf_h])\n\n        _ax_lua_saved_cppflags=$CPPFLAGS\n        CPPFLAGS=\"$CPPFLAGS -I$_ax_include_path\"\n        AC_CHECK_HEADERS([lua.h lualib.h lauxlib.h luaconf.h])\n        CPPFLAGS=$_ax_lua_saved_cppflags\n\n        AS_IF([test \"x$ac_cv_header_lua_h\" = 'xyes'],\n          [ LUA_INCLUDE=\"-I$_ax_include_path\"\n            break\n          ])\n      done\n    ])\n\n  AS_IF([test \"x$ac_cv_header_lua_h\" = 'xyes'],\n    [ dnl Make a program to print LUA_VERSION defined in the header.\n      dnl TODO It would be really nice if we could do this without compiling a\n      dnl program, then it would work when cross compiling. But I'm not sure how\n      dnl to do this reliably. For now, assume versions match when cross compiling.\n\n      AS_IF([test \"x$cross_compiling\" != 'xyes'],\n        [ AC_CACHE_CHECK([for Lua header version],\n            [ax_cv_lua_header_version],\n            [ _ax_lua_saved_cppflags=$CPPFLAGS\n              CPPFLAGS=\"$CPPFLAGS $LUA_INCLUDE\"\n              AC_RUN_IFELSE(\n                [ AC_LANG_SOURCE([[\n#include <lua.h>\n#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char ** argv)\n{\n  if(argc > 1) printf(\"%s\", LUA_VERSION);\n  exit(EXIT_SUCCESS);\n}\n]])\n                ],\n                [ ax_cv_lua_header_version=`./conftest$EXEEXT p | \\\n                    $SED -n \"s|^Lua \\(@<:@0-9@:>@\\{1,\\}\\.@<:@0-9@:>@\\{1,\\}\\).\\{0,\\}|\\1|p\"`\n                ],\n                [ax_cv_lua_header_version='unknown'])\n              CPPFLAGS=$_ax_lua_saved_cppflags\n            ])\n\n          dnl Compare this to the previously found LUA_VERSION.\n          AC_MSG_CHECKING([if Lua header version matches $LUA_VERSION])\n          AS_IF([test \"x$ax_cv_lua_header_version\" = \"x$LUA_VERSION\"],\n            [ AC_MSG_RESULT([yes])\n              ax_header_version_match='yes'\n            ],\n            [ AC_MSG_RESULT([no])\n              ax_header_version_match='no'\n            ])\n        ],\n        [ AC_MSG_WARN([cross compiling so assuming header version number matches])\n          ax_header_version_match='yes'\n        ])\n    ])\n\n  dnl Was LUA_INCLUDE specified?\n  AS_IF([test \"x$ax_header_version_match\" != 'xyes' &&\n         test \"x$LUA_INCLUDE\" != 'x'],\n    [AC_MSG_ERROR([cannot find headers for specified LUA_INCLUDE])])\n\n  dnl Test the final result and run user code.\n  AS_IF([test \"x$ax_header_version_match\" = 'xyes'], [$1],\n    [m4_default([$2], [AC_MSG_ERROR([cannot find Lua includes])])])\n])\n\ndnl AX_LUA_HEADERS_VERSION no longer exists, use AX_LUA_HEADERS.\nAC_DEFUN([AX_LUA_HEADERS_VERSION],\n[\n  AC_MSG_WARN([[$0 is deprecated, please use AX_LUA_HEADERS instead]])\n])\n\n\ndnl =========================================================================\ndnl AX_LUA_LIBS([ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])\ndnl =========================================================================\nAC_DEFUN([AX_LUA_LIBS],\n[\n  dnl TODO Should this macro also check various -L flags?\n\n  dnl Check for LUA_VERSION.\n  AC_MSG_CHECKING([if LUA_VERSION is defined])\n  AS_IF([test \"x$LUA_VERSION\" != 'x'],\n    [AC_MSG_RESULT([yes])],\n    [ AC_MSG_RESULT([no])\n      AC_MSG_ERROR([cannot check Lua libs without knowing LUA_VERSION])\n    ])\n\n  dnl Make LUA_LIB a precious variable.\n  AC_ARG_VAR([LUA_LIB], [The Lua library, e.g. -llua5.1])\n\n  AS_IF([test \"x$LUA_LIB\" != 'x'],\n  [ dnl Check that LUA_LIBS works.\n    _ax_lua_saved_libs=$LIBS\n    LIBS=\"$LIBS $LUA_LIB\"\n    AC_SEARCH_LIBS([lua_load], [],\n      [_ax_found_lua_libs='yes'],\n      [_ax_found_lua_libs='no'])\n    LIBS=$_ax_lua_saved_libs\n\n    dnl Check the result.\n    AS_IF([test \"x$_ax_found_lua_libs\" != 'xyes'],\n      [AC_MSG_ERROR([cannot find libs for specified LUA_LIB])])\n  ],\n  [ dnl First search for extra libs.\n    _ax_lua_extra_libs=''\n\n    _ax_lua_saved_libs=$LIBS\n    LIBS=\"$LIBS $LUA_LIB\"\n    AC_SEARCH_LIBS([exp], [m])\n    AC_SEARCH_LIBS([dlopen], [dl])\n    LIBS=$_ax_lua_saved_libs\n\n    AS_IF([test \"x$ac_cv_search_exp\" != 'xno' &&\n           test \"x$ac_cv_search_exp\" != 'xnone required'],\n      [_ax_lua_extra_libs=\"$_ax_lua_extra_libs $ac_cv_search_exp\"])\n\n    AS_IF([test \"x$ac_cv_search_dlopen\" != 'xno' &&\n           test \"x$ac_cv_search_dlopen\" != 'xnone required'],\n      [_ax_lua_extra_libs=\"$_ax_lua_extra_libs $ac_cv_search_dlopen\"])\n\n    dnl Try to find the Lua libs.\n    _ax_lua_saved_libs=$LIBS\n    LIBS=\"$LIBS $LUA_LIB\"\n    AC_SEARCH_LIBS([lua_load],\n      [ lua$LUA_VERSION \\\n        lua$LUA_SHORT_VERSION \\\n        lua-$LUA_VERSION \\\n        lua-$LUA_SHORT_VERSION \\\n        lua \\\n      ],\n      [_ax_found_lua_libs='yes'],\n      [_ax_found_lua_libs='no'],\n      [$_ax_lua_extra_libs])\n    LIBS=$_ax_lua_saved_libs\n\n    AS_IF([test \"x$ac_cv_search_lua_load\" != 'xno' &&\n           test \"x$ac_cv_search_lua_load\" != 'xnone required'],\n      [LUA_LIB=\"$ac_cv_search_lua_load $_ax_lua_extra_libs\"])\n  ])\n\n  dnl Test the result and run user code.\n  AS_IF([test \"x$_ax_found_lua_libs\" = 'xyes'], [$1],\n    [m4_default([$2], [AC_MSG_ERROR([cannot find Lua libs])])])\n])\n\n\ndnl =========================================================================\ndnl AX_LUA_READLINE([ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])\ndnl =========================================================================\nAC_DEFUN([AX_LUA_READLINE],\n[\n  AX_LIB_READLINE\n  AS_IF([test \"x$ac_cv_header_readline_readline_h\" != 'x' &&\n         test \"x$ac_cv_header_readline_history_h\" != 'x'],\n    [ LUA_LIBS_CFLAGS=\"-DLUA_USE_READLINE $LUA_LIBS_CFLAGS\"\n      $1\n    ],\n    [$2])\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-i6dcpentpa3wkcp6mwcurdfsjksgyiyg/spack-src/src/common/libflux/handle.c": "/************************************************************\\\n * Copyright 2014 Lawrence Livermore National Security, LLC\n * (c.f. AUTHORS, NOTICE.LLNS, COPYING)\n *\n * This file is part of the Flux resource manager framework.\n * For details, see https://github.com/flux-framework.\n *\n * SPDX-License-Identifier: LGPL-3.0\n\\************************************************************/\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <assert.h>\n#include <string.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <dlfcn.h>\n#include <sys/epoll.h>\n#include <poll.h>\n#include <czmq.h>\n#if HAVE_CALIPER\n#include <caliper/cali.h>\n#include <sys/syscall.h>\n#endif\n\n#include \"handle.h\"\n#include \"reactor.h\"\n#include \"connector.h\"\n#include \"message.h\"\n#include \"tagpool.h\"\n#include \"msg_handler.h\" // for flux_sleep_on ()\n#include \"flog.h\"\n#include \"conf.h\"\n\n#include \"src/common/libutil/log.h\"\n#include \"src/common/libutil/msglist.h\"\n#include \"src/common/libutil/dirwalk.h\"\n#include \"src/common/libutil/aux.h\"\n#include \"src/common/libutil/errno_safe.h\"\n\n#if HAVE_CALIPER\nstruct profiling_context {\n    int initialized;\n    cali_id_t msg_type;\n    cali_id_t msg_seq;\n    cali_id_t msg_topic;\n    cali_id_t msg_sender;\n    cali_id_t msg_rpc;\n    cali_id_t msg_rpc_nodeid;\n    cali_id_t msg_rpc_resp_expected;\n    cali_id_t msg_action;\n    cali_id_t msg_match_type;\n    cali_id_t msg_match_tag;\n    cali_id_t msg_match_glob;\n};\n#endif\n\nstruct flux_handle_struct {\n    flux_t          *parent; // if FLUX_O_CLONE, my parent\n    struct aux_item *aux;\n    int             usecount;\n    int             flags;\n\n    /* element below are unused in cloned handles */\n    const struct flux_handle_ops *ops;\n    void            *impl;\n    void            *dso;\n    msglist_t       *queue;\n    int             pollfd;\n\n    struct tagpool  *tagpool;\n    flux_msgcounters_t msgcounters;\n    flux_fatal_f    fatal;\n    void            *fatal_arg;\n    bool            fatality;\n    bool            destroy_in_progress;\n#if HAVE_CALIPER\n    struct profiling_context prof;\n#endif\n};\n\nstatic flux_t *lookup_clone_ancestor (flux_t *h)\n{\n    while ((h->flags & FLUX_O_CLONE))\n        h = h->parent;\n    return h;\n}\n\nvoid tagpool_grow_notify (void *arg, uint32_t old, uint32_t new);\n\n#if HAVE_CALIPER\nvoid profiling_context_init (struct profiling_context* prof)\n{\n    prof->msg_type = cali_create_attribute (\"flux.message.type\",\n                                            CALI_TYPE_STRING,\n                                            CALI_ATTR_DEFAULT | CALI_ATTR_ASVALUE);\n    prof->msg_seq = cali_create_attribute (\"flux.message.seq\",\n                                           CALI_TYPE_INT,\n                                           CALI_ATTR_SKIP_EVENTS);\n    prof->msg_topic = cali_create_attribute (\"flux.message.topic\",\n                                             CALI_TYPE_STRING,\n                                             CALI_ATTR_DEFAULT | CALI_ATTR_ASVALUE);\n    prof->msg_sender = cali_create_attribute (\"flux.message.sender\",\n                                              CALI_TYPE_STRING,\n                                              CALI_ATTR_SKIP_EVENTS);\n    // if flux.message.rpc is set, we're inside an RPC, it will be set to a\n    // type, single or multi\n    prof->msg_rpc = cali_create_attribute (\"flux.message.rpc\",\n                                           CALI_TYPE_STRING,\n                                           CALI_ATTR_SKIP_EVENTS);\n    prof->msg_rpc_nodeid = cali_create_attribute (\"flux.message.rpc.nodeid\",\n                                                  CALI_TYPE_INT,\n                                                  CALI_ATTR_SKIP_EVENTS);\n    prof->msg_rpc_resp_expected =\n        cali_create_attribute (\"flux.message.response_expected\",\n                               CALI_TYPE_INT,\n                               CALI_ATTR_SKIP_EVENTS);\n    prof->msg_action = cali_create_attribute (\"flux.message.action\",\n                                              CALI_TYPE_STRING,\n                                              CALI_ATTR_DEFAULT | CALI_ATTR_ASVALUE);\n    prof->msg_match_type = cali_create_attribute (\"flux.message.match.type\",\n                                                  CALI_TYPE_INT,\n                                                  CALI_ATTR_SKIP_EVENTS);\n    prof->msg_match_tag = cali_create_attribute (\"flux.message.match.tag\",\n                                                 CALI_TYPE_INT,\n                                                 CALI_ATTR_SKIP_EVENTS);\n    prof->msg_match_glob = cali_create_attribute (\"flux.message.match.glob\",\n                                                  CALI_TYPE_STRING,\n                                                  CALI_ATTR_SKIP_EVENTS);\n    prof->initialized=1;\n}\n\nstatic void profiling_msg_snapshot (flux_t *h,\n                          const flux_msg_t *msg,\n                          int flags,\n                          const char *msg_action)\n{\n    h = lookup_clone_ancestor (h);\n    cali_id_t attributes[3];\n    const void * data[3];\n    size_t size[3];\n\n    // This can get called before the handle is really ready\n    if(! h->prof.initialized) return;\n\n    int len = 0;\n\n    if (msg_action) {\n        attributes[len] = h->prof.msg_action;\n        data[len] = msg_action;\n        size[len] = strlen(msg_action);\n        ++len;\n    }\n\n    int type;\n    flux_msg_get_type (msg, &type);\n    const char *msg_type = flux_msg_typestr (type);\n    if (msg_type) {\n        attributes[len] = h->prof.msg_type;\n        data[len] = msg_type;\n        size[len] = strlen(msg_type);\n        ++len;\n    }\n\n    const char *msg_topic;\n    if (type != FLUX_MSGTYPE_KEEPALIVE)\n        flux_msg_get_topic (msg, &msg_topic);\n    else\n        msg_topic = \"NONE\";\n    /* attributes[len] = h->prof.msg_topic; */\n    /* data[len] = msg_topic; */\n    /* size[len] = strlen(msg_topic); */\n    /* ++len; */\n\n    if (type == FLUX_MSGTYPE_EVENT) {\n        uint32_t seq;\n        flux_msg_get_seq (msg, &seq);\n        cali_begin_int (h->prof.msg_seq, seq);\n    }\n    cali_push_snapshot (CALI_SCOPE_PROCESS | CALI_SCOPE_THREAD,\n                        len /* n_entries */,\n                        attributes /* event_attributes */,\n                        data /* event_data */,\n                        size /* event_size */);\n    if (type == FLUX_MSGTYPE_EVENT)\n        cali_end (h->prof.msg_seq);\n}\n\n\n#endif\n\nstatic char *find_file (const char *name, const char *searchpath)\n{\n    char *path;\n    zlist_t *l;\n    if (!(l = dirwalk_find (searchpath, DIRWALK_REALPATH, name, 1, NULL, NULL)))\n        return NULL;\n    path = zlist_pop (l);\n    zlist_destroy (&l);\n    return path;\n}\n\nstatic connector_init_f *find_connector (const char *scheme, void **dsop)\n{\n    char name[PATH_MAX];\n    const char *searchpath = getenv (\"FLUX_CONNECTOR_PATH\");\n    char *path = NULL;\n    void *dso = NULL;\n    connector_init_f *connector_init = NULL;\n\n    if (!searchpath)\n        searchpath = flux_conf_builtin_get (\"connector_path\", FLUX_CONF_AUTO);\n    if (snprintf (name, sizeof (name), \"%s.so\", scheme) >= sizeof (name)) {\n        errno = ENAMETOOLONG;\n        return NULL;\n    }\n    if (!(path = find_file (name, searchpath))) {\n        errno = ENOENT;\n        goto error;\n    }\n    if (!(dso = dlopen (path, RTLD_LAZY | RTLD_LOCAL | FLUX_DEEPBIND))) {\n        errno = EINVAL;\n        goto error;\n    }\n    if (!(connector_init = dlsym (dso, \"connector_init\"))) {\n        errno = EINVAL;\n        goto error_dlopen;\n    }\n    *dsop = dso;\n    free (path);\n    return connector_init;\nerror_dlopen:\n    ERRNO_SAFE_WRAP (dlclose, dso);\nerror:\n    ERRNO_SAFE_WRAP (free, path);\n    return NULL;\n}\n\nstatic char *strtrim (char *s, const char *trim)\n{\n    char *p = s + strlen (s) - 1;\n    while (p >= s && strchr (trim, *p))\n        *p-- = '\\0';\n    return *s ? s : NULL;\n}\n\nflux_t *flux_open (const char *uri, int flags)\n{\n    char *default_uri = NULL;\n    char *path = NULL;\n    char *scheme = NULL;\n    void *dso = NULL;\n    connector_init_f *connector_init = NULL;\n    const char *s;\n    flux_t *h = NULL;\n\n    /* Try to get URI from (in descending precedence):\n     *   argument > environment > builtin\n     */\n    if (!uri)\n        uri = getenv (\"FLUX_URI\");\n    if (!uri) {\n        if (asprintf (&default_uri, \"local://%s/local\",\n                      flux_conf_builtin_get (\"rundir\",\n                                             FLUX_CONF_INSTALLED)) < 0)\n            goto error;\n        uri = default_uri;\n    }\n    if (!(scheme = strdup (uri)))\n        goto error;\n    path = strstr (scheme, \"://\");\n    if (path) {\n        *path = '\\0';\n        path = strtrim (path + 3, \" \\t\");\n    }\n    if (!(connector_init = find_connector (scheme, &dso)))\n        goto error;\n    if (getenv (\"FLUX_HANDLE_TRACE\"))\n        flags |= FLUX_O_TRACE;\n    if (getenv (\"FLUX_HANDLE_MATCHDEBUG\"))\n        flags |= FLUX_O_MATCHDEBUG;\n    if (!(h = connector_init (path, flags))) {\n        ERRNO_SAFE_WRAP (dlclose, dso);\n        goto error;\n    }\n    h->dso = dso;\n#if HAVE_CALIPER\n    profiling_context_init(&h->prof);\n#endif\n    if ((s = getenv (\"FLUX_HANDLE_USERID\"))) {\n        uint32_t userid = strtoul (s, NULL, 10);\n        if (flux_opt_set (h, FLUX_OPT_TESTING_USERID, &userid,\n                                                      sizeof (userid)) < 0)\n            goto error_handle;\n    }\n    if ((s = getenv (\"FLUX_HANDLE_ROLEMASK\"))) {\n        uint32_t rolemask = strtoul (s, NULL, 0);\n        if (flux_opt_set (h, FLUX_OPT_TESTING_ROLEMASK, &rolemask,\n                                                    sizeof (rolemask)) < 0)\n            goto error_handle;\n    }\n    free (scheme);\n    free (default_uri);\n    return h;\nerror_handle:\n    flux_handle_destroy (h);\nerror:\n    ERRNO_SAFE_WRAP (free, scheme);\n    ERRNO_SAFE_WRAP (free, default_uri);\n    return NULL;\n}\n\nvoid flux_close (flux_t *h)\n{\n    flux_handle_destroy (h);\n}\n\nflux_t *flux_handle_create (void *impl, const struct flux_handle_ops *ops, int flags)\n{\n    flux_t *h = malloc (sizeof (*h));\n    if (!h)\n        goto nomem;\n    memset (h, 0, sizeof (*h));\n    h->usecount = 1;\n    h->flags = flags;\n    h->ops = ops;\n    h->impl = impl;\n    if (!(h->tagpool = tagpool_create ()))\n        goto nomem;\n    tagpool_set_grow_cb (h->tagpool, tagpool_grow_notify, h);\n    if (!(h->queue = msglist_create ((msglist_free_f)flux_msg_destroy)))\n        goto nomem;\n    h->pollfd = -1;\n    return h;\nnomem:\n    flux_handle_destroy (h);\n    errno = ENOMEM;\n    return NULL;\n}\n\nflux_t *flux_clone (flux_t *orig)\n{\n    if (!orig) {\n        errno = EINVAL;\n        return NULL;\n    }\n    flux_t *h = calloc (1, sizeof (*h));\n    if (!h)\n        goto nomem;\n    h->parent = flux_incref (orig);\n    h->usecount = 1;\n    h->flags = orig->flags | FLUX_O_CLONE;\n    return h;\nnomem:\n    free (h);\n    errno = ENOMEM;\n    return NULL;\n}\n\nstatic void report_leaked_matchtags (struct tagpool *tp)\n{\n    uint32_t count = tagpool_getattr (tp, TAGPOOL_ATTR_SIZE) -\n                     tagpool_getattr (tp, TAGPOOL_ATTR_AVAIL);\n    if (count > 0)\n        fprintf (stderr,\n                 \"MATCHDEBUG: pool destroy with %d allocated\\n\", count);\n}\n\nvoid flux_handle_destroy (flux_t *h)\n{\n    if (h && --h->usecount == 0) {\n        int saved_errno = errno;\n        if (h->destroy_in_progress)\n            return;\n        h->destroy_in_progress = true;\n        aux_destroy (&h->aux);\n        if ((h->flags & FLUX_O_CLONE)) {\n            flux_handle_destroy (h->parent); // decr usecount\n        }\n        else {\n            if (h->ops->impl_destroy)\n                h->ops->impl_destroy (h->impl);\n            if ((h->flags & FLUX_O_MATCHDEBUG))\n                report_leaked_matchtags (h->tagpool);\n            tagpool_destroy (h->tagpool);\n#ifndef __SANITIZE_ADDRESS__\n            if (h->dso)\n                dlclose (h->dso);\n#endif\n            msglist_destroy (h->queue);\n            if (h->pollfd >= 0)\n                (void)close (h->pollfd);\n        }\n        free (h);\n        errno = saved_errno;\n    }\n}\n\nflux_t *flux_incref (flux_t *h)\n{\n    if (h)\n        h->usecount++;\n    return h;\n}\n\nvoid flux_decref (flux_t *h)\n{\n    flux_handle_destroy (h);\n}\n\nvoid flux_flags_set (flux_t *h, int flags)\n{\n    h->flags |= flags;\n}\n\nvoid flux_flags_unset (flux_t *h, int flags)\n{\n    h->flags &= ~flags;\n}\n\nint flux_flags_get (flux_t *h)\n{\n    return h->flags;\n}\n\nint flux_opt_get (flux_t *h, const char *option, void *val, size_t len)\n{\n    h = lookup_clone_ancestor (h);\n    if (!h->ops->getopt) {\n        errno = EINVAL;\n        return -1;\n    }\n    return h->ops->getopt (h->impl, option, val, len);\n}\n\nint flux_opt_set (flux_t *h, const char *option, const void *val, size_t len)\n{\n    h = lookup_clone_ancestor (h);\n    if (!h->ops->setopt) {\n        errno = EINVAL;\n        return -1;\n    }\n    return h->ops->setopt (h->impl, option, val, len);\n}\n\nvoid *flux_aux_get (flux_t *h, const char *name)\n{\n    if (!h) {\n        errno = EINVAL;\n        return NULL;\n    }\n    return aux_get (h->aux, name);\n}\n\nint flux_aux_set (flux_t *h, const char *name, void *aux, flux_free_f destroy)\n{\n    if (!h) {\n        errno = EINVAL;\n        return -1;\n    }\n    return aux_set (&h->aux, name, aux, destroy);\n}\n\nvoid flux_fatal_set (flux_t *h, flux_fatal_f fun, void *arg)\n{\n    h = lookup_clone_ancestor (h);\n    h->fatal = fun;\n    h->fatal_arg = arg;\n    h->fatality = false;\n}\n\nvoid flux_fatal_error (flux_t *h, const char *fun, const char *msg)\n{\n    h = lookup_clone_ancestor (h);\n    if (!h->fatality) {\n        h->fatality = true;\n        if (h->fatal) {\n            char buf[256];\n            snprintf (buf, sizeof (buf), \"%s: %s\", fun, msg);\n            h->fatal (buf, h->fatal_arg);\n        }\n    }\n}\n\nbool flux_fatality (flux_t *h)\n{\n    h = lookup_clone_ancestor (h);\n    return h->fatality;\n}\n\nvoid flux_get_msgcounters (flux_t *h, flux_msgcounters_t *mcs)\n{\n    h = lookup_clone_ancestor (h);\n    *mcs = h->msgcounters;\n}\n\nvoid flux_clr_msgcounters (flux_t *h)\n{\n    h = lookup_clone_ancestor (h);\n    memset (&h->msgcounters, 0, sizeof (h->msgcounters));\n}\n\nvoid tagpool_grow_notify (void *arg, uint32_t old, uint32_t new)\n{\n    flux_t *h = arg;\n    flux_log (h, LOG_INFO, \"tagpool expanded from %u to %u entries\", old, new);\n}\n\nuint32_t flux_matchtag_alloc (flux_t *h)\n{\n    h = lookup_clone_ancestor (h);\n    uint32_t tag;\n\n    tag = tagpool_alloc (h->tagpool);\n    if (tag == FLUX_MATCHTAG_NONE) {\n        flux_log (h, LOG_ERR, \"tagpool temporarily out of tags\");\n        errno = EBUSY; /* appropriate error? */\n    }\n    return tag;\n}\n\n/* Free matchtag, first deleting any queued matching responses.\n */\nvoid flux_matchtag_free (flux_t *h, uint32_t matchtag)\n{\n    h = lookup_clone_ancestor (h);\n    struct flux_match match = {\n        .typemask = FLUX_MSGTYPE_RESPONSE,\n        .topic_glob = NULL,\n        .matchtag = matchtag,\n    };\n    flux_msg_t *msg = msglist_first (h->queue);\n    while (msg) {\n        if (flux_msg_cmp (msg, match)) {\n            msglist_remove (h->queue, msg);\n            flux_msg_destroy (msg);\n        }\n        msg = msglist_next (h->queue);\n    }\n    tagpool_free (h->tagpool, matchtag);\n}\n\nuint32_t flux_matchtag_avail (flux_t *h)\n{\n    h = lookup_clone_ancestor (h);\n    return tagpool_getattr (h->tagpool, TAGPOOL_ATTR_AVAIL);\n}\n\nstatic void update_tx_stats (flux_t *h, const flux_msg_t *msg)\n{\n    int type;\n    if (flux_msg_get_type (msg, &type) == 0) {\n        switch (type) {\n            case FLUX_MSGTYPE_REQUEST:\n                h->msgcounters.request_tx++;\n                break;\n            case FLUX_MSGTYPE_RESPONSE:\n                h->msgcounters.response_tx++;\n                break;\n            case FLUX_MSGTYPE_EVENT:\n                h->msgcounters.event_tx++;\n                break;\n            case FLUX_MSGTYPE_KEEPALIVE:\n                h->msgcounters.keepalive_tx++;\n                break;\n        }\n    } else\n        errno = 0;\n}\n\nstatic void update_rx_stats (flux_t *h, const flux_msg_t *msg)\n{\n    int type;\n    if (flux_msg_get_type (msg, &type) == 0) {\n        switch (type) {\n            case FLUX_MSGTYPE_REQUEST:\n                h->msgcounters.request_rx++;\n                break;\n            case FLUX_MSGTYPE_RESPONSE:\n                h->msgcounters.response_rx++;\n                break;\n            case FLUX_MSGTYPE_EVENT:\n                h->msgcounters.event_rx++;\n                break;\n        case FLUX_MSGTYPE_KEEPALIVE:\n            h->msgcounters.keepalive_rx++;\n            break;\n        }\n    } else\n        errno = 0;\n}\n\nint flux_send (flux_t *h, const flux_msg_t *msg, int flags)\n{\n    h = lookup_clone_ancestor (h);\n    if (!h->ops->send || h->destroy_in_progress) {\n        errno = ENOSYS;\n        goto fatal;\n    }\n    flags |= h->flags;\n    update_tx_stats (h, msg);\n    if (flags & FLUX_O_TRACE)\n        flux_msg_fprint (stderr, msg);\n    if (h->ops->send (h->impl, msg, flags) < 0)\n        goto fatal;\n#if HAVE_CALIPER\n    profiling_msg_snapshot(h, msg, flags, \"send\");\n#endif\n    return 0;\nfatal:\n    FLUX_FATAL (h);\n    return -1;\n}\n\nstatic int defer_enqueue (zlist_t **l, flux_msg_t *msg)\n{\n    if ((!*l && !(*l = zlist_new ())) || zlist_append (*l, msg) < 0) {\n        errno = ENOMEM;\n        return -1;\n    }\n    return 0;\n}\n\nstatic int defer_requeue (zlist_t **l, flux_t *h)\n{\n    flux_msg_t *msg;\n    if (*l) {\n        while ((msg = zlist_pop (*l))) {\n            int rc = flux_requeue (h, msg, FLUX_RQ_TAIL);\n            flux_msg_destroy (msg);\n            if (rc < 0)\n                return -1;\n        }\n    }\n    return 0;\n}\n\nstatic void defer_destroy (zlist_t **l)\n{\n    flux_msg_t *msg;\n    if (*l) {\n        while ((msg = zlist_pop (*l)))\n            flux_msg_destroy (msg);\n        zlist_destroy (l);\n    }\n}\n\nstatic flux_msg_t *flux_recv_any (flux_t *h, int flags)\n{\n    flux_msg_t *msg = NULL;\n    if (msglist_count (h->queue) > 0)\n        msg = msglist_pop (h->queue);\n    else if (h->ops->recv)\n        msg = h->ops->recv (h->impl, flags);\n    else\n        errno = ENOSYS;\n    return msg;\n}\n\n/* N.B. the do loop below that reads messages and compares them to match\n * criteria may have to read a few non-matching messages before finding\n * a match.  On return, those non-matching messages have to be requeued\n * in the handle, hence the defer_*() helper calls.\n */\nflux_msg_t *flux_recv (flux_t *h, struct flux_match match, int flags)\n{\n    h = lookup_clone_ancestor (h);\n    zlist_t *l = NULL;\n    flux_msg_t *msg = NULL;\n    int saved_errno;\n\n    flags |= h->flags;\n    do {\n        if (!(msg = flux_recv_any (h, flags))) {\n            if (errno != EAGAIN && errno != EWOULDBLOCK)\n                goto fatal;\n            if (defer_requeue (&l, h) < 0)\n                goto fatal;\n            defer_destroy (&l);\n            errno = EWOULDBLOCK;\n            return NULL;\n        }\n        if (!flux_msg_cmp (msg, match)) {\n            if (defer_enqueue (&l, msg) < 0)\n                goto fatal;\n            msg = NULL;\n        }\n    } while (!msg);\n    update_rx_stats (h, msg);\n    if ((flags & FLUX_O_TRACE))\n        flux_msg_fprint (stderr, msg);\n    if (defer_requeue (&l, h) < 0)\n        goto fatal;\n    defer_destroy (&l);\n#if HAVE_CALIPER\n    cali_begin_int (h->prof.msg_match_type, match.typemask);\n    cali_begin_int (h->prof.msg_match_tag, match.matchtag);\n    cali_begin_string (h->prof.msg_match_glob,\n                       match.topic_glob ? match.topic_glob : \"NONE\");\n    char *sender = NULL;\n    flux_msg_get_route_first (msg, &sender);\n    if (sender)\n        cali_begin_string (h->prof.msg_sender, sender);\n    profiling_msg_snapshot (h, msg, flags, \"recv\");\n    if (sender)\n        cali_end (h->prof.msg_sender);\n    cali_end (h->prof.msg_match_type);\n    cali_end (h->prof.msg_match_tag);\n    cali_end (h->prof.msg_match_glob);\n\n    free (sender);\n#endif\n    return msg;\nfatal:\n    saved_errno = errno;\n    FLUX_FATAL (h);\n    if (msg)\n        flux_msg_destroy (msg);\n    defer_destroy (&l);\n    errno = saved_errno;\n    return NULL;\n}\n\n/* FIXME: FLUX_O_TRACE will show these messages being received again\n * So will message counters.\n */\nstatic int requeue (flux_t *h, flux_msg_t *msg, int flags)\n{\n    h = lookup_clone_ancestor (h);\n    int rc;\n\n    if (flags != FLUX_RQ_TAIL && flags != FLUX_RQ_HEAD) {\n        errno = EINVAL;\n        goto fatal;\n    }\n    if (flags == FLUX_RQ_TAIL)\n        rc = msglist_append (h->queue, msg);\n    else\n        rc = msglist_push (h->queue, msg);\n    if (rc < 0)\n        goto fatal;\n    return 0;\nfatal:\n    FLUX_FATAL (h);\n    return -1;\n}\n\nint flux_requeue (flux_t *h, const flux_msg_t *msg, int flags)\n{\n    flux_msg_t *cpy = NULL;\n\n    if (!(cpy = flux_msg_copy (msg, true))) {\n        FLUX_FATAL (h);\n        return -1;\n    }\n\n    if (requeue (h, cpy, flags) < 0) {\n        flux_msg_destroy (cpy);\n        return -1;\n    }\n\n    return 0;\n}\n\nint flux_requeue_nocopy (flux_t *h, flux_msg_t *msg, int flags)\n{\n    if (requeue (h, msg, flags) < 0)\n        return -1;\n\n    return 0;\n}\n\nint flux_event_subscribe (flux_t *h, const char *topic)\n{\n    h = lookup_clone_ancestor (h);\n    if (h->ops->event_subscribe) {\n        if (h->ops->event_subscribe (h->impl, topic) < 0)\n            goto fatal;\n    }\n    return 0;\nfatal:\n    FLUX_FATAL (h);\n    return -1;\n}\n\nint flux_event_unsubscribe (flux_t *h, const char *topic)\n{\n    h = lookup_clone_ancestor (h);\n    if (h->ops->event_unsubscribe) {\n        if (h->ops->event_unsubscribe (h->impl, topic) < 0)\n            goto fatal;\n    }\n    return 0;\nfatal:\n    FLUX_FATAL (h);\n    return -1;\n}\n\nint flux_pollfd (flux_t *h)\n{\n    h = lookup_clone_ancestor (h);\n    if (h->pollfd < 0) {\n        struct epoll_event ev = {\n            .events = EPOLLET | EPOLLIN | EPOLLOUT | EPOLLERR | EPOLLHUP,\n        };\n        if ((h->pollfd = epoll_create1 (EPOLL_CLOEXEC)) < 0)\n            goto fatal;\n        /* add queue pollfd */\n        ev.data.fd = msglist_pollfd (h->queue);\n        if (ev.data.fd < 0)\n            goto fatal;\n        if (epoll_ctl (h->pollfd, EPOLL_CTL_ADD, ev.data.fd, &ev) < 0)\n            goto fatal;\n        /* add connector pollfd (if defined) */\n        if (h->ops->pollfd) {\n            ev.data.fd = h->ops->pollfd (h->impl);\n            if (ev.data.fd < 0)\n                goto fatal;\n            if (epoll_ctl (h->pollfd, EPOLL_CTL_ADD, ev.data.fd, &ev) < 0)\n                goto fatal;\n        }\n    }\n    return h->pollfd;\nfatal:\n    if (h->pollfd >= 0) {\n        (void)close (h->pollfd);\n        h->pollfd = -1;\n    }\n    FLUX_FATAL (h);\n    return -1;\n}\n\nint flux_pollevents (flux_t *h)\n{\n    h = lookup_clone_ancestor (h);\n    int e, events = 0;\n\n    /* wait for handle event */\n    if (h->pollfd >= 0) {\n        struct epoll_event ev;\n        (void)epoll_wait (h->pollfd, &ev, 1, 0);\n    }\n    /* get connector events (if applicable) */\n    if (h->ops->pollevents) {\n        if ((events = h->ops->pollevents (h->impl)) < 0)\n            goto fatal;\n    }\n    /* get queue events */\n    if ((e = msglist_pollevents (h->queue)) < 0)\n        goto fatal;\n    if ((e & POLLIN))\n        events |= FLUX_POLLIN;\n    if ((e & POLLOUT))\n        events |= FLUX_POLLOUT;\n    if ((e & POLLERR))\n        events |= FLUX_POLLERR;\n    return events;\nfatal:\n    FLUX_FATAL (h);\n    return -1;\n}\n\n/*\n * vi:tabstop=4 shiftwidth=4 expandtab\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-i6dcpentpa3wkcp6mwcurdfsjksgyiyg/spack-src/src/common/libflux/module.c": "/************************************************************\\\n * Copyright 2014 Lawrence Livermore National Security, LLC\n * (c.f. AUTHORS, NOTICE.LLNS, COPYING)\n *\n * This file is part of the Flux resource manager framework.\n * For details, see https://github.com/flux-framework.\n *\n * SPDX-License-Identifier: LGPL-3.0\n\\************************************************************/\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <dlfcn.h>\n#include <argz.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <jansson.h>\n\n#include \"module.h\"\n#include \"message.h\"\n#include \"keepalive.h\"\n#include \"rpc.h\"\n\n#include \"src/common/libutil/log.h\"\n#include \"src/common/libutil/dirwalk.h\"\n\nstruct modfind_ctx {\n    const char *modname;\n    flux_moderr_f *cb;\n    void *arg;\n};\n\nchar *flux_modname (const char *path, flux_moderr_f *cb, void *arg)\n{\n    void *dso;\n    const char **np;\n    char *cpy = NULL;\n    int saved_errno;\n\n    if (!path) {\n        errno = EINVAL;\n        return NULL;\n    }\n    if (!(dso = dlopen (path, RTLD_LAZY | RTLD_LOCAL | FLUX_DEEPBIND))) {\n        if (cb)\n            cb (dlerror (), arg);\n        errno = ENOENT;\n        return NULL;\n    }\n    dlerror ();\n    if (!(np = dlsym (dso, \"mod_name\"))) {\n        char *errmsg;\n        if (cb && (errmsg = dlerror ()))\n            cb (errmsg, arg);\n        errno = EINVAL;\n        goto error;\n    }\n    if (!*np) {\n        errno = EINVAL;\n        goto error;\n    }\n    if (!(cpy = strdup (*np)))\n        goto error;\n    dlclose (dso);\n    return cpy;\nerror:\n    saved_errno = errno;\n    dlclose (dso);\n    errno = saved_errno;\n    return NULL;\n}\n\n/* dirwalk_filter_f callback for dirwalk_find()\n * This function should return 1 on match, 0 on no match.\n * dirwalk_find() will stop on first match since its count parameter is 1.\n */\nstatic int mod_find_f (dirwalk_t *d, void *arg)\n{\n    struct modfind_ctx *ctx = arg;\n    const char *path = dirwalk_path (d);\n    char *name;\n    int rc = 0;\n\n    if ((name = flux_modname (path, ctx->cb, ctx->arg))) {\n        if (!strcmp (name, ctx->modname))\n            rc = 1;\n        free (name);\n    }\n    return rc;\n}\n\nchar *flux_modfind (const char *searchpath, const char *modname,\n                    flux_moderr_f *cb, void *arg)\n{\n    char *result = NULL;\n    zlist_t *l;\n    struct modfind_ctx ctx;\n\n    if (!searchpath || !modname) {\n        errno = EINVAL;\n        return NULL;\n    }\n    ctx.modname = modname;\n    ctx.cb = cb;\n    ctx.arg = arg;\n\n    l = dirwalk_find (searchpath, 0, \"*.so\", 1, mod_find_f, &ctx);\n    if (l) {\n        result = zlist_pop (l);\n        zlist_destroy (&l);\n    }\n    if (!result)\n        errno = ENOENT;\n    return result;\n}\n\nbool flux_module_debug_test (flux_t *h, int flag, bool clear)\n{\n    int *flagsp = flux_aux_get (h, \"flux::debug_flags\");\n\n    if (!flagsp || !(*flagsp & flag))\n        return false;\n    if (clear)\n        *flagsp &= ~flag;\n    return true;\n}\n\nint flux_module_set_running (flux_t *h)\n{\n    flux_msg_t *msg;\n    int rc = -1;\n\n    if (!h) {\n        errno = EINVAL;\n        return -1;\n    }\n    if (!(msg = flux_keepalive_encode (0, FLUX_MODSTATE_RUNNING)))\n        return -1;\n    if (flux_send (h, msg, 0) < 0)\n        goto done;\n    rc = 0;\ndone:\n    flux_msg_decref (msg);\n    return rc;\n}\n\n/*\n * vi:tabstop=4 shiftwidth=4 expandtab\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-i6dcpentpa3wkcp6mwcurdfsjksgyiyg/spack-src/src/common/libflux/module.h": "/************************************************************\\\n * Copyright 2014 Lawrence Livermore National Security, LLC\n * (c.f. AUTHORS, NOTICE.LLNS, COPYING)\n *\n * This file is part of the Flux resource manager framework.\n * For details, see https://github.com/flux-framework.\n *\n * SPDX-License-Identifier: LGPL-3.0\n\\************************************************************/\n\n#ifndef _FLUX_CORE_MODULE_H\n#define _FLUX_CORE_MODULE_H\n\n/* Module management messages are constructed according to Flux RFC 5.\n * https://flux-framework.rtfd.io/projects/flux-rfc/en/latest/spec_5.html\n */\n\n#include <stdint.h>\n#include <stdbool.h>\n\n#include \"handle.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Module states, for embedding in keepalive messages (rfc 5)\n */\nenum {\n    FLUX_MODSTATE_INIT           = 0,\n    FLUX_MODSTATE_SLEEPING       = 1,\n    FLUX_MODSTATE_RUNNING        = 2,\n    FLUX_MODSTATE_FINALIZING     = 3,\n    FLUX_MODSTATE_EXITED         = 4,\n};\n\n/* Mandatory symbols for modules\n */\n#define MOD_NAME(x) const char *mod_name = x\ntypedef int (mod_main_f)(flux_t *h, int argc, char *argv[]);\n\ntypedef void (flux_moderr_f)(const char *errmsg, void *arg);\n\n/* Read the value of 'mod_name' from the specified module filename.\n * Caller must free the returned name.  Returns NULL on failure.\n * If 'cb' is non-NULL, any dlopen/dlsym errors are reported via callback.\n */\nchar *flux_modname (const char *filename, flux_moderr_f *cb, void *arg);\n\n/* Search a colon-separated list of directories (recursively) for a .so file\n * with the requested module name and return its path, or NULL on failure.\n * Caller must free the returned path.\n * If 'cb' is non-NULL, any dlopen/dlsym errors are reported via callback.\n */\nchar *flux_modfind (const char *searchpath, const char *modname,\n                    flux_moderr_f *cb, void *arg);\n\n/* Test and optionally clear module debug bit from within a module, as\n * described in RFC 5.  Return true if 'flag' bit is set.  If clear=true,\n * clear the bit after testing.  The flux-module(1) debug subcommand\n * manipulates these bits externally to set up test conditions.\n */\nbool flux_module_debug_test (flux_t *h, int flag, bool clear);\n\n/* Set module state to RUNNING.  This transition occurs automatically when the\n * reactor is entered, but this function can set the state to RUNNING early,\n * e.g. if flux module load must complete before the module enters the reactor.\n * Returns 0 on success, -1 on error with errno set.\n */\nint flux_module_set_running (flux_t *h);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* !FLUX_CORE_MODULE_H */\n\n/*\n * vi:tabstop=4 shiftwidth=4 expandtab\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-i6dcpentpa3wkcp6mwcurdfsjksgyiyg/spack-src/src/common/libflux/plugin.c": "/************************************************************\\\n * Copyright 2019 Lawrence Livermore National Security, LLC\n * (c.f. AUTHORS, NOTICE.LLNS, COPYING)\n *\n * This file is part of the Flux resource manager framework.\n * For details, see https://github.com/flux-framework.\n *\n * SPDX-License-Identifier: LGPL-3.0\n\\************************************************************/\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <errno.h>\n#include <string.h>\n#include <fnmatch.h>\n#include <dlfcn.h>\n#include <stdarg.h>\n#include <jansson.h>\n#include <czmq.h>\n#include <flux/core.h>\n\n#include \"src/common/libutil/aux.h\"\n\n#include \"plugin.h\"\n\nstruct flux_plugin {\n    char *path;\n    char *name;\n    json_t *conf;\n    char *conf_str;\n    struct aux_item *aux;\n    void *dso;\n    zlistx_t *handlers;\n    int flags;\n    char last_error [128];\n};\n\nstruct flux_plugin_arg {\n    json_error_t error;\n    json_t * in;\n    json_t * out;\n};\n\ntypedef const struct flux_plugin_handler *\n        (*find_handler_f) (flux_plugin_t *p, const char *topic);\n\nstatic void flux_plugin_handler_destroy (struct flux_plugin_handler *h)\n{\n    if (h) {\n        free (h->topic);\n        free (h);\n    }\n}\n\nstatic void handler_free (void **item)\n{\n    if (*item) {\n        struct flux_plugin_handler *h = *item;\n        flux_plugin_handler_destroy (h);\n        *item = NULL;\n    }\n}\n\nstatic const struct flux_plugin_handler * find_handler (flux_plugin_t *p,\n                                                        const char *string)\n{\n    struct flux_plugin_handler *h = zlistx_first (p->handlers);\n    while (h) {\n        if (strcmp (h->topic, string) == 0)\n            return h;\n        h = zlistx_next (p->handlers);\n    }\n    return NULL;\n}\n\nstatic const struct flux_plugin_handler * match_handler (flux_plugin_t *p,\n                                                         const char *string)\n{\n    struct flux_plugin_handler *h = zlistx_first (p->handlers);\n    while (h) {\n        if (fnmatch (h->topic, string, 0) == 0)\n            return h;\n        h = zlistx_next (p->handlers);\n    }\n    return NULL;\n}\n\nstatic struct flux_plugin_handler *\nflux_plugin_handler_create (const char *topic, flux_plugin_f cb, void *arg)\n{\n    struct flux_plugin_handler *h = calloc (1, sizeof (*h));\n    if (!h || !(h->topic = strdup (topic)))\n        goto error;\n    h->cb = cb;\n    h->data = arg;\n    return (h);\nerror:\n    flux_plugin_handler_destroy (h);\n    return NULL;\n}\n\nvoid flux_plugin_destroy (flux_plugin_t *p)\n{\n    if (p) {\n        int saved_errno = errno;\n        json_decref (p->conf);\n        zlistx_destroy (&p->handlers);\n        free (p->conf_str);\n        free (p->path);\n        free (p->name);\n        aux_destroy (&p->aux);\n#ifndef __SANITIZE_ADDRESS__\n        if (p->dso)\n            dlclose (p->dso);\n#endif\n        free (p);\n        errno = saved_errno;\n    }\n}\n\nstatic int plugin_seterror (flux_plugin_t *p, int errnum, const char *fmt, ...)\n{\n    if (p && fmt) {\n        va_list ap;\n        va_start (ap, fmt);\n        vsnprintf (p->last_error, sizeof (p->last_error), fmt, ap);\n        va_end (ap);\n    }\n    else if (p) {\n        snprintf (p->last_error,\n                  sizeof (p->last_error),\n                  \"%s\", strerror (errno));\n    }\n    errno = errnum;\n    return -1;\n}\n\nstatic inline void plugin_error_clear (flux_plugin_t *p)\n{\n    if (p)\n        p->last_error [0] = '\\0';\n}\n\nflux_plugin_t *flux_plugin_create (void)\n{\n    flux_plugin_t *p = calloc (1, sizeof (*p));\n    if (!p || !(p->handlers = zlistx_new ())) {\n        flux_plugin_destroy (p);\n        return NULL;\n    }\n    p->flags = FLUX_PLUGIN_RTLD_LAZY;\n    zlistx_set_destructor (p->handlers, handler_free);\n    return p;\n}\n\nstatic int flags_invalid (int flags)\n{\n    const int valid_flags =\n        FLUX_PLUGIN_RTLD_LAZY\n        | FLUX_PLUGIN_RTLD_NOW\n        | FLUX_PLUGIN_RTLD_GLOBAL\n        | FLUX_PLUGIN_RTLD_DEEPBIND;\n    return (flags & ~valid_flags);\n}\n\nint flux_plugin_set_flags (flux_plugin_t *p, int flags)\n{\n    if (!p || flags_invalid (flags)) {\n        errno = EINVAL;\n        return -1;\n    }\n    p->flags = flags;\n    return 0;\n}\n\nint flux_plugin_get_flags (flux_plugin_t *p)\n{\n    if (p) {\n        return p->flags;\n    }\n    return 0;\n}\n\nint flux_plugin_set_name (flux_plugin_t *p, const char *name)\n{\n    char *new = NULL;\n    plugin_error_clear (p);\n    if (!p || !name)\n        return plugin_seterror (p, EINVAL, NULL);\n    if (!(new = strdup (name)))\n        return -1;\n    free (p->name);\n    p->name = new;\n    return 0;\n}\n\nconst char * flux_plugin_get_name (flux_plugin_t *p)\n{\n    plugin_error_clear (p);\n    if (!p) {\n        errno = EINVAL;\n        return NULL;\n    }\n    return p->name;\n}\n\nint flux_plugin_aux_set (flux_plugin_t *p, const char *key,\n                         void *val, aux_free_f free_fn)\n{\n    return aux_set (&p->aux, key, val, free_fn);\n}\n\nvoid *flux_plugin_aux_get (flux_plugin_t *p, const char *key)\n{\n    return aux_get (p->aux, key);\n}\n\nconst char *flux_plugin_strerror (flux_plugin_t *p)\n{\n    return p->last_error;\n}\n\nstatic int open_flags (flux_plugin_t *p)\n{\n    int flags = 0;\n    if ((p->flags & FLUX_PLUGIN_RTLD_LAZY))\n        flags |= RTLD_LAZY;\n    if ((p->flags & FLUX_PLUGIN_RTLD_NOW))\n        flags |= RTLD_NOW;\n    if ((p->flags & FLUX_PLUGIN_RTLD_GLOBAL))\n        flags |= RTLD_GLOBAL;\n    else\n        flags |= RTLD_LOCAL;\n    if ((p->flags & FLUX_PLUGIN_RTLD_DEEPBIND))\n        flags |= FLUX_DEEPBIND;\n    return flags;\n}\n\nint flux_plugin_load_dso (flux_plugin_t *p, const char *path)\n{\n    flux_plugin_init_f init;\n    plugin_error_clear (p);\n    if (!p || !path)\n        return plugin_seterror (p, EINVAL, NULL);\n    if (access (path, R_OK) < 0)\n        return plugin_seterror (p, errno, \"%s: %s\", path, strerror (errno));\n    dlerror ();\n    if (!(p->dso = dlopen (path, open_flags (p))))\n        return plugin_seterror (p, errno, \"dlopen: %s\", dlerror ());\n\n    free (p->path);\n    free (p->name);\n    if (!(p->path = strdup (path)) || !(p->name = strdup (path)))\n        return plugin_seterror (p, ENOMEM, NULL);\n\n    if ((init = dlsym (p->dso, \"flux_plugin_init\")))\n        return (*init) (p);\n    return 0;\n}\n\nint flux_plugin_set_conf (flux_plugin_t *p, const char *json_str)\n{\n    json_error_t err;\n    plugin_error_clear (p);\n    if (!p || !json_str)\n        return plugin_seterror (p, EINVAL, NULL);\n    if (!(p->conf = json_loads (json_str, 0, &err))) {\n        return plugin_seterror (p, errno,\n                                \"parse error: col %d: %s\",\n                                 err.column, err.text);\n    }\n    if (p->conf_str) {\n        free (p->conf_str);\n        p->conf_str = NULL;\n    }\n    return 0;\n}\n\nconst char *flux_plugin_get_conf (flux_plugin_t *p)\n{\n    if (!p) {\n        plugin_seterror (p, EINVAL, NULL);\n        return NULL;\n    }\n    if (!p->conf_str) {\n        if (!p->conf) {\n            plugin_seterror (p, ENOENT, \"No plugin conf set\");\n            return NULL;\n        }\n        p->conf_str = json_dumps (p->conf, JSON_ENCODE_ANY|JSON_COMPACT);\n        if (!p->conf_str) {\n            plugin_seterror (p,\n                             errno,\n                             \"json_dumps failed: %s\",\n                             strerror (errno));\n            return NULL;\n        }\n    }\n    return p->conf_str;\n}\n\nint flux_plugin_conf_unpack (flux_plugin_t *p, const char *fmt, ...)\n{\n    json_error_t err;\n    va_list ap;\n    int rc;\n    plugin_error_clear (p);\n    if (!p || !fmt)\n        return plugin_seterror (p, EINVAL, NULL);\n    if (!p->conf)\n        return plugin_seterror (p, ENOENT, \"No plugin conf set\");\n    va_start (ap, fmt);\n    rc = json_vunpack_ex (p->conf, &err, 0, fmt, ap);\n    va_end (ap);\n    if (rc < 0)\n        return plugin_seterror (p, errno, \"unpack error: %s\", err.text);\n    return rc;\n}\n\nint flux_plugin_remove_handler (flux_plugin_t *p,\n                                const char *topic)\n{\n    plugin_error_clear (p);\n    if (!p || !topic)\n        return plugin_seterror (p, EINVAL, NULL);\n    if (find_handler (p, topic)) {\n        if (zlistx_delete (p->handlers, zlistx_cursor (p->handlers)) < 0)\n            return plugin_seterror (p, errno, NULL);\n    }\n    return 0;\n}\n\nstatic flux_plugin_f get_handler (flux_plugin_t *p,\n                                  const char *topic,\n                                  find_handler_f fn)\n{\n    const struct flux_plugin_handler *h;\n    plugin_error_clear (p);\n    if (!p || !topic) {\n        plugin_seterror (p, EINVAL, NULL);\n        return NULL;\n    }\n    if ((h = (*fn) (p, topic)))\n        return h->cb;\n    return NULL;\n}\n\nflux_plugin_f flux_plugin_get_handler (flux_plugin_t *p, const char *topic)\n{\n    return get_handler (p, topic, find_handler);\n}\n\nflux_plugin_f flux_plugin_match_handler (flux_plugin_t *p, const char *topic)\n{\n    return get_handler (p, topic, match_handler);\n}\n\n\nint flux_plugin_add_handler (flux_plugin_t *p,\n                             const char *topic,\n                             flux_plugin_f cb,\n                             void *arg)\n{\n    struct flux_plugin_handler *h = NULL;\n    plugin_error_clear (p);\n    if (!p || !topic)\n        return plugin_seterror (p, EINVAL, NULL);\n\n    if (!cb)\n        return flux_plugin_remove_handler (p, topic);\n\n    if (!(h = flux_plugin_handler_create (topic, cb, arg)))\n        return plugin_seterror (p, errno, NULL);\n\n    if (!(zlistx_add_end (p->handlers, h))) {\n        flux_plugin_handler_destroy (h);\n        return plugin_seterror (p, errno, NULL);\n    }\n\n    return 0;\n}\n\nint flux_plugin_register (flux_plugin_t *p,\n                          const char *name,\n                          const struct flux_plugin_handler t[])\n{\n    plugin_error_clear (p);\n    if (!p || !t)\n        return plugin_seterror (p, EINVAL, NULL);\n    if (name && flux_plugin_set_name (p, name))\n        return -1;\n    while (t->topic) {\n        if (flux_plugin_add_handler (p, t->topic, t->cb, t->data) < 0)\n            return -1;\n        t++;\n    }\n    return 0;\n}\n\nstatic int arg_seterror (flux_plugin_arg_t *arg, int errnum,\n                         const char *fmt, ...)\n{\n    if (fmt) {\n        va_list ap;\n        va_start (ap, fmt);\n        vsnprintf (arg->error.text, sizeof (arg->error.text), fmt, ap);\n        va_end (ap);\n    } else if (arg) {\n        snprintf (arg->error.text,\n                  sizeof (arg->error.text),\n                  \"%s\", strerror (errno));\n    }\n    errno = errnum;\n    return -1;\n}\n\nstatic inline void arg_clear_error (flux_plugin_arg_t *arg)\n{\n    if (arg)\n        arg->error.text[0] = '\\0';\n}\n\nconst char *flux_plugin_arg_strerror (flux_plugin_arg_t *args)\n{\n    if (!args)\n        return strerror (errno);\n    return args->error.text;\n}\n\nvoid flux_plugin_arg_destroy (flux_plugin_arg_t *args)\n{\n    if (args) {\n        json_decref (args->in);\n        json_decref (args->out);\n        free (args);\n    }\n}\n\nflux_plugin_arg_t *flux_plugin_arg_create (void)\n{\n    flux_plugin_arg_t *args = calloc (1, sizeof (*args));\n    return args;\n}\n\nstatic json_t **arg_get (flux_plugin_arg_t *args, int flags)\n{\n    return ((flags & FLUX_PLUGIN_ARG_OUT) ? &args->out : &args->in);\n}\n\nstatic int arg_set (flux_plugin_arg_t *args, int flags, json_t *o)\n{\n    json_t **dstp;\n    dstp = arg_get (args, flags);\n    if (flags & FLUX_PLUGIN_ARG_UPDATE && *dstp != NULL) {\n        /*  On update, the object 'o' is spiritually inherited by\n         *   args, so decref this object after attempting the update.\n         */\n        int rc = json_object_update (*dstp, o);\n        json_decref (o);\n        return rc;\n    }\n    json_decref (*dstp);\n    *dstp = o;\n    return 0;\n}\n\nint flux_plugin_arg_set (flux_plugin_arg_t *args, int flags,\n                         const char *json_str)\n{\n    json_t *o = NULL;\n    arg_clear_error (args);\n    if (!args)\n        return arg_seterror (args, EINVAL, NULL);\n    if (json_str && !(o = json_loads (json_str, 0, &args->error)))\n        return -1;\n    return arg_set (args, flags, o);\n}\n\nint flux_plugin_arg_get (flux_plugin_arg_t *args, int flags, char **json_str)\n{\n    json_t **op;\n    arg_clear_error (args);\n    if (!args || !json_str)\n        return arg_seterror (args, EINVAL, NULL);\n    op = arg_get (args, flags);\n    if (*op == NULL)\n        return arg_seterror (args, ENOENT, \"No args currently set\");\n    *json_str = json_dumps (*op, JSON_COMPACT);\n    return 0;\n}\n\nint flux_plugin_arg_vpack (flux_plugin_arg_t *args, int flags,\n                           const char *fmt, va_list ap)\n{\n    json_t *o;\n    arg_clear_error (args);\n    if (!args || !fmt)\n        return arg_seterror (args, EINVAL, NULL);\n    if (!(o = json_vpack_ex (&args->error, 0, fmt, ap)))\n        return -1;\n    return arg_set (args, flags, o);\n}\n\nint flux_plugin_arg_pack (flux_plugin_arg_t *args, int flags,\n                          const char *fmt, ...)\n{\n    int rc;\n    va_list ap;\n    va_start (ap, fmt);\n    rc = flux_plugin_arg_vpack (args, flags, fmt, ap);\n    va_end (ap);\n    return rc;\n}\n\nint flux_plugin_arg_vunpack (flux_plugin_arg_t *args, int flags,\n                             const char *fmt, va_list ap)\n{\n    json_t **op;\n    arg_clear_error (args);\n    if (!fmt || !args)\n        return arg_seterror (args, EINVAL, NULL);\n    op = arg_get (args, flags);\n    return json_vunpack_ex (*op, &args->error, 0, fmt, ap);\n}\n\nint flux_plugin_arg_unpack (flux_plugin_arg_t *args, int flags,\n                            const char *fmt, ...)\n{\n    int rc;\n    va_list ap;\n    va_start (ap, fmt);\n    rc = flux_plugin_arg_vunpack (args, flags, fmt, ap);\n    va_end (ap);\n    return rc;\n}\n\nint flux_plugin_call (flux_plugin_t *p, const char *string,\n                      flux_plugin_arg_t *args)\n{\n    const struct flux_plugin_handler *h = NULL;\n    plugin_error_clear (p);\n    if (!p || !string)\n        return plugin_seterror (p, EINVAL, NULL);\n    if (!(h = match_handler (p, string)))\n        return 0;\n    assert (h->cb);\n    if ((*h->cb) (p, string, args, h->data) < 0)\n        return -1;\n    return 1;\n}\n\n\n/*\n * vi:tabstop=4 shiftwidth=4 expandtab\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-i6dcpentpa3wkcp6mwcurdfsjksgyiyg/spack-src/src/common/libflux/test/plugin_bar.c": "/************************************************************\\\n * Copyright 2021 Lawrence Livermore National Security, LLC\n * (c.f. AUTHORS, NOTICE.LLNS, COPYING)\n *\n * This file is part of the Flux resource manager framework.\n * For details, see https://github.com/flux-framework.\n *\n * SPDX-License-Identifier: LGPL-3.0\n\\************************************************************/\n\n#include <flux/core.h>\n\n/*  Invalid global symbol to force dlopen failure\n */\nextern int my_invalid_sym (void);\n\nint flux_plugin_init (flux_plugin_t *p)\n{\n    return my_invalid_sym ();\n}\n\n/* vi: ts=4 sw=4 expandtab\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-i6dcpentpa3wkcp6mwcurdfsjksgyiyg/spack-src/src/common/libflux/test/plugin.c": "/************************************************************\\\n * Copyright 2019 Lawrence Livermore National Security, LLC\n * (c.f. AUTHORS, NOTICE.LLNS, COPYING)\n *\n * This file is part of the Flux resource manager framework.\n * For details, see https://github.com/flux-framework.\n *\n * SPDX-License-Identifier: LGPL-3.0\n\\************************************************************/\n\n#include <string.h>\n#include <errno.h>\n\n#include \"src/common/libflux/plugin.h\"\n#include \"src/common/libtap/tap.h\"\n\n\n/* function prototype for invalid args testing below */\nstatic int foo (flux_plugin_t *p,\n                const char *topic,\n                flux_plugin_arg_t *args,\n                void *data)\n{\n    const char **sp = data;\n    return flux_plugin_arg_pack (args,\n                                 FLUX_PLUGIN_ARG_OUT,\n                                 \"{s:s s:s}\",\n                                 \"fn\", \"foo\",\n                                 \"data\", *sp);\n}\n\nstatic int bar (flux_plugin_t *p,\n                const char *topic,\n                flux_plugin_arg_t *args,\n                void *data)\n{\n    const char **sp = data;\n    return flux_plugin_arg_pack (args,\n                                 FLUX_PLUGIN_ARG_OUT,\n                                 \"{s:s s:s}\",\n                                 \"fn\", \"bar\",\n                                 \"data\", *sp);\n}\n\nstatic char *foodata = \"this is foo\";\nstatic char *bardata = \"this is bar\";\n\nstatic const struct flux_plugin_handler tab[] = {\n    { \"foo.*\", foo,  &foodata },\n    { \"*\",     bar,  &bardata },\n    { NULL,    NULL, NULL }\n};\n\nvoid test_invalid_args ()\n{\n    flux_plugin_t *p;\n    int i;\n\n    lives_ok ({flux_plugin_destroy (NULL);},\n              \"flux_plugin_destroy (NULL) does not crash program\");\n    if (!(p = flux_plugin_create ()))\n        BAIL_OUT (\"flux_plugin_create failed\");\n\n    ok (flux_plugin_set_name (NULL, NULL) < 0 && errno == EINVAL,\n        \"flux_plugin_set_name (NULL, NULL) returns EINVAL\");\n    ok (flux_plugin_set_name (p, NULL) < 0 && errno == EINVAL,\n        \"flux_plugin_set_name (p, NULL) returns EINVAL\");\n\n    ok (flux_plugin_get_name (NULL) == NULL && errno == EINVAL,\n        \"flux_plugin_get_name (NULL) returns EINVAL\");\n\n    ok (flux_plugin_get_flags (NULL) == 0,\n        \"flux_plugin_get_flags (NULL) returns 0\");\n    ok (flux_plugin_set_flags (NULL, 0) < 0 && errno == EINVAL,\n        \"flux_plugin_set_flags (NULL, 0) returns EINVAL\");\n    ok (flux_plugin_set_flags (p, 1024) < 0 && errno == EINVAL,\n        \"flux_plugin_set_flags with invalid flags returns EINVAL\");\n\n    ok (flux_plugin_set_conf (NULL, NULL) < 0 && errno == EINVAL,\n        \"flux_plugin_set_conf (NULL, NULL) returns EINVAL\");\n    ok (flux_plugin_set_conf (p, NULL) < 0 && errno == EINVAL,\n        \"flux_plugin_set_conf (NULL, NULL) returns EINVAL\");\n    ok (flux_plugin_set_conf (p, \"a\") < 0 && errno == EINVAL,\n        \"flux_plugin_set_conf (NULL, NULL) returns EINVAL\");\n    like (flux_plugin_strerror (p), \"^parse error: col 1:.*\",\n        \"flux_plugin_last_error returns error text\");\n\n    ok (flux_plugin_get_conf (NULL) == NULL && errno == EINVAL,\n        \"flux_plugin_get_conf () with NULL arg returns EINVAL\");\n    ok (flux_plugin_get_conf (p) == NULL && errno == ENOENT,\n        \"flux_plugin_get_conf () with no conf returns ENOENT\");\n\n    ok (flux_plugin_conf_unpack (p, \"{s:i}\", \"bar\", &i) < 0 && errno == ENOENT,\n        \"flux_plugin_conf_unpack () with no conf returns ENOENT\");\n\n    ok (flux_plugin_set_conf (p, \"{\\\"foo\\\":1, \\\"bar\\\":\\\"a\\\"}\") == 0,\n        \"flux_plugin_set_conf() works\");\n\n    ok (flux_plugin_conf_unpack (NULL, NULL) < 0 && errno == EINVAL,\n        \"flux_conf_unpack (NULL, NULL) returns EINVAL\");\n    ok (flux_plugin_conf_unpack (p, NULL) < 0 && errno == EINVAL,\n        \"flux_conf_unpack (p, NULL) returns EINVAL\");\n\n    ok (flux_plugin_conf_unpack (p, \"{s:i}\", \"bar\", &i) < 0 && errno == EINVAL,\n        \"flux_conf_unpack with wrong fmt (%s) got EINVAL\",\n        flux_plugin_strerror (p), errno);\n\n    ok (flux_plugin_aux_set (p, NULL, NULL, NULL) < 0 && errno == EINVAL,\n        \"flux_plugin_aux_set (p, NULL, NULL, NULL) returns EINVAL\");\n    ok (flux_plugin_aux_get (p, NULL) == NULL && errno == EINVAL,\n        \"flux_plugin_aux_get (p, NULL) returns EINVAL\");\n    ok (flux_plugin_aux_get (p, \"foo\") == NULL && errno == ENOENT,\n        \"flux_plugin_aux_get (p, 'foo') returns ENOENT\");\n\n    ok (flux_plugin_add_handler (NULL, \"foo.*\", foo, NULL) < 0 && errno == EINVAL,\n        \"flux_plugin_add_handler (NULL, ...) returns EINVAL\");\n    ok (flux_plugin_add_handler (p, NULL, foo, NULL) < 0 && errno == EINVAL,\n        \"flux_plugin_add_handler (p, NULL, foo) returns EINVAL\");\n\n    ok (flux_plugin_remove_handler (NULL, \"foo.*\") < 0 && errno == EINVAL,\n        \"flux_plugin_remove_handler (NULL, ...) returns EINVAL\");\n    ok (flux_plugin_remove_handler (p, NULL) < 0 && errno == EINVAL,\n        \"flux_plugin_remove_handler (p, NULL) returns EINVAL\");\n\n    ok (flux_plugin_register (NULL, NULL, tab) < 0 && errno == EINVAL,\n        \"flux_plugin_add_handlers (NULL, NULL, t) fails with EINVAL\");\n    ok (flux_plugin_register (p, NULL, NULL) < 0 && errno == EINVAL,\n        \"flux_plugin_add_handlers (p, NULL) fails with EINVAL\");\n\n    ok (flux_plugin_get_handler (NULL, NULL) == NULL && errno == EINVAL,\n        \"flux_plugin_get_handler (NULL, NULL) returns EINVAL\");\n    ok (flux_plugin_get_handler (p, NULL) == NULL && errno == EINVAL,\n        \"flux_plugin_get_handler (p, NULL) returns EINVAL\");\n    ok (flux_plugin_get_handler (NULL, \"foo\") == NULL && errno == EINVAL,\n        \"flux_plugin_get_handler (NULL, 'foo') returns EINVAL\");\n\n    ok (flux_plugin_match_handler (NULL, NULL) == NULL && errno == EINVAL,\n        \"flux_plugin_match_handler (NULL, NULL) returns EINVAL\");\n    ok (flux_plugin_match_handler (p, NULL) == NULL && errno == EINVAL,\n        \"flux_plugin_match_handler (p, NULL) returns EINVAL\");\n    ok (flux_plugin_match_handler (NULL, \"foo\") == NULL && errno == EINVAL,\n        \"flux_plugin_match_handler (NULL, 'foo') returns EINVAL\");\n\n    ok (flux_plugin_load_dso (NULL, NULL) < 0 && errno == EINVAL,\n        \"flux_plugin_load_dso (NULL, NULL) returns EINVAL\");\n    ok (flux_plugin_load_dso (p, NULL) < 0 && errno == EINVAL,\n        \"flux_plugin_load_dso (p, NULL) returns EINVAL\");\n\n    flux_plugin_destroy (p);\n}\n\nvoid test_plugin_args ()\n{\n    flux_plugin_arg_t *args = flux_plugin_arg_create ();\n    char *s;\n    int arg;\n\n    if (!args)\n        BAIL_OUT (\"flux_plugin_arg_create failed\");\n\n    errno = EINVAL;\n    is (flux_plugin_arg_strerror (NULL), strerror (errno),\n        \"flux_plugin_arg_strerror (NULL) defaults to strerror\");\n\n    ok (flux_plugin_arg_get (NULL, 0, NULL) < 0 && errno == EINVAL,\n        \"flux_plugin_arg_get with NULL arg returns EINVAL\");\n    ok (flux_plugin_arg_get (args, 0, NULL) < 0 && errno == EINVAL,\n        \"flux_plugin_arg_get with NULL string returns EINVAL\");\n\n    ok (flux_plugin_arg_set (NULL, 0, NULL) < 0 && errno == EINVAL,\n        \"flux_plugin_arg_set with NULL arg returns EINVAL\");\n    ok (flux_plugin_arg_set (args, 0, NULL) == 0,\n        \"flux_plugin_arg_set with NULL string returns success\");\n\n    ok (flux_plugin_arg_get (args, 0, &s) < 0 && errno == ENOENT,\n        \"flux_plugin_arg_get() returns ENOENT with no args set\");\n    ok (flux_plugin_arg_get (args, FLUX_PLUGIN_ARG_OUT, &s) < 0\n        && errno == ENOENT,\n        \"flux_plugin_arg_get() returns ENOENT with no args set\");\n    is (flux_plugin_arg_strerror (args), \"No args currently set\",\n        \"flux_plugin_arg_strerror returns 'No args currently set'\");\n\n    /*  Test set\n     */\n    ok (flux_plugin_arg_set (args, FLUX_PLUGIN_ARG_IN, \"{\\\"a\\\":5}\") == 0,\n        \"flux_plugin_arg_set works\");\n    ok (flux_plugin_arg_unpack (args, FLUX_PLUGIN_ARG_IN,\n                                \"{s:i}\", \"a\", &arg) == 0,\n        \"flux_plugin_arg_unpack worked\");\n    ok (arg == 5,\n        \"flux_plugin_arg_unpack returned valid value for arg\");\n\n    ok (flux_plugin_arg_set (args,\n                             FLUX_PLUGIN_ARG_IN | FLUX_PLUGIN_ARG_UPDATE,\n                             \"{\\\"b\\\":7}\") == 0,\n        \"flux_plugin_arg_set with FLUX_PLUGIN_ARG_UPDATE works\");\n    ok (flux_plugin_arg_unpack (args, FLUX_PLUGIN_ARG_IN,\n                                \"{s:i}\", \"b\", &arg) == 0,\n        \"flux_plugin_arg_unpack worked\");\n    ok (arg == 7,\n        \"flux_plugin_arg_unpack returned valid value for new arg\");\n    ok (flux_plugin_arg_unpack (args, FLUX_PLUGIN_ARG_IN,\n                                \"{s:i}\", \"a\", &arg) == 0,\n        \"flux_plugin_arg_unpack worked\");\n    ok (arg == 5,\n        \"flux_plugin_arg_unpack returned valid value for old arg\");\n\n\n    /* Test update with unset args */\n    flux_plugin_arg_t *new = flux_plugin_arg_create ();\n    if (!new)\n        BAIL_OUT (\"flux_plugin_arg_create failed\");\n    ok (flux_plugin_arg_set (args,\n                             FLUX_PLUGIN_ARG_IN | FLUX_PLUGIN_ARG_UPDATE,\n                            \"{\\\"count\\\": 29}\") == 0,\n        \"flux_plugin_arg_set with ARG_UPDATE works for empty args\");\n    flux_plugin_arg_destroy (new);\n\n    ok (flux_plugin_arg_unpack (args, FLUX_PLUGIN_ARG_IN,\n                                \"{s:i}\", \"count\", &arg) == 0,\n        \"flux_plugin_arg_unpack worked\");\n    ok (arg == 29,\n        \"flux_plugin_arg_unpack returned valid value for arg\");\n\n\n    /*  Test pack\n     */\n    ok (flux_plugin_arg_pack (args, FLUX_PLUGIN_ARG_IN,\n                              \"{s:s s:i}\",\n                              \"string\", \"in\",\n                              \"int\", 7) == 0,\n        \"flux_plugin_arg_pack inargs works\");\n    ok (flux_plugin_arg_get (args, FLUX_PLUGIN_ARG_IN, &s) == 0,\n        \"flux_plugin_arg_get now returns success\");\n    ok (s != NULL,\n        \"flux_plugin_arg_get returned json str: %s\", s);\n    free (s);\n    ok (flux_plugin_arg_unpack (args, FLUX_PLUGIN_ARG_IN,\n                                \"{s:i}\", \"string\", &arg) < 0,\n        \"flux_plugin_arg_unpack detects bad format: errno = %d\", errno);\n    ok (flux_plugin_arg_unpack (args, FLUX_PLUGIN_ARG_IN,\n                                \"{s:i}\", \"int\", &arg) == 0,\n        \"flux_plugin_arg_unpack allows caller to get one arg\");\n    ok (arg == 7,\n        \"returned argument is valid\");\n\n    ok (flux_plugin_arg_pack (args, FLUX_PLUGIN_ARG_OUT,\n                              \"{s:s s:i}\",\n                              \"string\", \"out\",\n                              \"int\", 8) == 0,\n        \"flux_plugin_arg_pack outargs works\");\n    ok (flux_plugin_arg_get (args, FLUX_PLUGIN_ARG_OUT, &s) == 0,\n        \"flux_plugin_arg_get now returns success\");\n    ok (s != NULL,\n        \"flux_plugin_arg_get returned json str: %s\", s);\n    free (s);\n    ok (flux_plugin_arg_unpack (args, FLUX_PLUGIN_ARG_OUT,\n                                \"{s:i}\", \"int\", &arg) == 0,\n        \"flux_plugin_arg_unpack allows caller to get one arg\");\n    ok (arg == 8,\n        \"returned argument is valid\");\n\n    flux_plugin_arg_destroy (args);\n}\n\n/* Accumulate result of \"add\" or \"multiply\" in arg \"a\",\n * result is \"a\" op \"b\".\n */\nint op1 (flux_plugin_t *p, const char *topic,\n         flux_plugin_arg_t *args, void *data)\n{\n    int a, b;\n    if (flux_plugin_arg_unpack (args, 0, \"{s:i s:i}\", \"a\", &a, \"b\", &b) < 0)\n        return -1;\n    if (strcmp (topic, \"op.add\") == 0)\n        a += b;\n    else if (strcmp (topic, \"op.multiply\") == 0)\n        a *= b;\n    else {\n        errno = ENOTSUP;\n        return -1;\n    }\n    if (flux_plugin_arg_pack (args, FLUX_PLUGIN_ARG_OUT, \"{s:i}\", \"a\", a) < 0)\n        return -1;\n    return 0;\n}\n\nvoid test_basic ()\n{\n    int a, b;\n    flux_plugin_t *p = flux_plugin_create ();\n    flux_plugin_arg_t *args = flux_plugin_arg_create ();\n    if (!p || !args)\n        BAIL_OUT (\"flux_plugin_{args_}create failed\");\n\n    ok (flux_plugin_set_name (p, \"op\") == 0,\n        \"flux_plugin_set_name works\");\n    is (flux_plugin_get_name (p), \"op\",\n        \"flux_plugin_get_name() works\");\n\n    ok (flux_plugin_add_handler (p, \"foo.*\", NULL, NULL) == 0,\n        \"flux_plugin_add_handler (p, 'foo.*', NULL) works\");\n    ok (flux_plugin_get_handler (p, \"foo.*\") == NULL,\n        \"flux_plugin_get_handler (p, 'foo.*') returns NULL\");\n\n    ok (flux_plugin_add_handler (p, \"op.*\", op1, NULL) == 0,\n        \"flux_plugin_add_handler() works\");\n    ok (flux_plugin_get_handler (p, \"op.*\") == op1,\n        \"flux_plugin_get_handler (p, 'op.*') returns op1\");\n    ok (flux_plugin_match_handler (p, \"op.add\") == op1,\n        \"flux_plugin_match_handler (p, 'op.add') returns op1\");\n\n    a = 2;\n    b = 4;\n    ok (flux_plugin_arg_pack (args, 0, \"{s:i s:i}\", \"a\", a, \"b\", b) == 0,\n        \"flux_plugin_arg_pack works\");\n    ok (flux_plugin_call (p, \"op.add\", args) >= 0,\n        \"flux_plugin_call op.add works\");\n\n    ok (flux_plugin_arg_unpack (args, FLUX_PLUGIN_ARG_OUT,\n                                \"{s:i}\", \"a\", &a) == 0,\n        \"flux_plugin_arg_unpack worked: %s\", flux_plugin_arg_strerror (args));\n    ok (a == 6,\n        \"callback with topic op.add worked\");\n\n    a = 2;\n    ok (flux_plugin_arg_pack (args, 0, \"{s:i s:i}\", \"a\", a, \"b\", b) == 0,\n        \"flux_plugin_arg_pack works\");\n    ok (flux_plugin_call (p, \"op.multiply\", args) >= 0,\n        \"callback with topic op.multiply worked\");\n    ok (flux_plugin_arg_unpack (args, FLUX_PLUGIN_ARG_OUT,\n                                \"{s:i}\", \"a\", &a) == 0,\n        \"flux_plugin_arg_unpack worked\");\n\n    ok (a == 8,\n        \"callback with topic op.multiply worked\");\n    ok (flux_plugin_call (p, \"op.subtract\", args) < 0 && errno == ENOTSUP,\n        \"callback with topic op.subtract returned ENOTSUP\");\n\n    ok (flux_plugin_call (p, \"foo\", args) == 0,\n        \"callback with no match returns success and does nothing\");\n\n    flux_plugin_arg_destroy (args);\n    flux_plugin_destroy (p);\n}\n\nvoid test_register ()\n{\n    const char *fn;\n    const char *data;\n\n    flux_plugin_t *p = flux_plugin_create ();\n    flux_plugin_arg_t *args = flux_plugin_arg_create ();\n    if (!args)\n        BAIL_OUT (\"flux_plugin_arg_create()\");\n    if (!p)\n        BAIL_OUT (\"flux_plugin_create()\");\n\n    /* Destroy args along with plugin object */\n    flux_plugin_aux_set (p, NULL, args, (flux_free_f) flux_plugin_arg_destroy);\n\n    ok (flux_plugin_register (p, \"test_register\", tab) == 0,\n        \"flux_plugin_register 2 handlers works\");\n    ok (flux_plugin_call (p, \"foo.test\", args) >= 0,\n        \"flux_plugin_call foo.test worked\");\n    ok (flux_plugin_arg_unpack (args, FLUX_PLUGIN_ARG_OUT,\n                                \"{s:s s:s}\",\n                                 \"fn\", &fn,\n                                 \"data\", &data) == 0,\n        \"flux_plugin_args_unpack result worked\");\n    is (fn, \"foo\",\n        \"flux_plugin_call foo.test called handler foo()\");\n    is (data, foodata,\n        \"flux_plugin_call passed correct void *data to foo()\");\n\n    ok (flux_plugin_call (p, \"fallthru\", args) >= 0,\n        \"flux_plugin_call fallthru worked\");\n    ok (flux_plugin_arg_unpack (args, FLUX_PLUGIN_ARG_OUT,\n                                \"{s:s s:s}\",\n                                 \"fn\", &fn,\n                                 \"data\", &data) == 0,\n        \"flux_plugin_args_unpack result worked\");\n    is (fn, \"bar\",\n        \"flux_plugin_call 'fallthru' fell through to handler bar()\");\n    is (data, bardata,\n        \"handler bar() was passed correct void *data\");\n\n    flux_plugin_destroy (p);\n}\n\nvoid test_load ()\n{\n    char *out;\n    const char *result;\n    flux_plugin_t *p = flux_plugin_create ();\n    if (!p)\n        BAIL_OUT (\"flux_plugin_create\");\n\n    ok (flux_plugin_load_dso (p, \"/noexist\") < 0 && errno == ENOENT,\n        \"flux_plugin_load_dso on nonexistent path returns ENOENT\");\n    is (flux_plugin_strerror (p), \"/noexist: No such file or directory\",\n        \"flux_plugin_strerror returns expected result\");\n    ok (flux_plugin_load_dso (p, \"/tmp\") < 0,\n        \"flux_plugin_load_dso on directory fails\");\n    like (flux_plugin_strerror (p), \"^dlopen: .*Is a directory\",\n        \"flux_plugin_strerror returns expected result\");\n\n    ok (flux_plugin_set_conf (p, \"{\\\"foo\\\":\\\"bar\\\"}\") == 0,\n        \"flux_plugin_set_conf (): %s\", flux_plugin_strerror (p));\n    ok ((result = flux_plugin_get_conf (p)) != NULL,\n        \"flux_plugin_get_conf () works\");\n    ok (result != NULL,\n        \"conf = %s\", result);\n\n    ok (flux_plugin_load_dso (p, \"test/.libs/plugin_foo.so\") == 0,\n        \"flux_plugin_load worked\");\n    is (flux_plugin_get_name (p), \"plugin-test\",\n        \"loaded dso registered its own name\");\n\n    flux_plugin_arg_t *args = flux_plugin_arg_create ();\n    if (!args)\n        BAIL_OUT (\"flux_plugin_arg_create failed\");\n    ok (flux_plugin_call (p, \"test.foo\", args) >= 0,\n        \"flux_plugin_call (test.foo) success\");\n    ok (flux_plugin_arg_unpack (args,\n                                FLUX_PLUGIN_ARG_OUT,\n                                \"{s:s}\",\n                                \"result\", &result) == 0,\n        \"flux_plugin_args_unpack result\");\n    is (result, \"foo\",\n        \"call of test.foo set result foo\");\n\n    result = NULL;\n    ok (flux_plugin_arg_get (args, FLUX_PLUGIN_ARG_OUT, &out) == 0,\n        \"flux_plugin_arg_out works\");\n    diag (\"out = %s\", out);\n    free (out);\n    ok (flux_plugin_call (p, \"test.bar\", args) >= 0,\n        \"flux_plugin_call (test.bar) success\");\n    ok (flux_plugin_arg_unpack (args, FLUX_PLUGIN_ARG_OUT,\n                                \"{s:s}\", \"result\", &result) == 0,\n        \"flux_plugin_args_unpack result\");\n    is (result, \"bar\",\n        \"call of test.bar set result bar\");\n\n    flux_plugin_arg_destroy (args);\n    flux_plugin_destroy (p);\n}\n\nvoid test_load_rtld_now ()\n{\n    flux_plugin_t *p = flux_plugin_create ();\n    if (!p)\n        BAIL_OUT (\"flux_plugin_create\");\n\n    ok (flux_plugin_set_flags (p, FLUX_PLUGIN_RTLD_NOW) == 0,\n        \"flux_plugin_set_flags (p, RTLD_NOW) == 0\");\n    ok (flux_plugin_load_dso (p, \"test/.libs/plugin_bar.so\") < 0,\n        \"load of plugin with invalid symbol fails immediately\");\n    like (flux_plugin_strerror (p), \"^dlopen: .*: undefined symbol\",\n        \"got expected error message: %s\", flux_plugin_strerror (p));\n\n    flux_plugin_destroy (p);\n}\n\n\nint main (int argc, char *argv[])\n{\n    plan (NO_PLAN);\n    test_invalid_args ();\n    test_plugin_args ();\n    test_basic ();\n    test_register ();\n    test_load ();\n    test_load_rtld_now ();\n    done_testing();\n    return (0);\n}\n\n/*\n * vi:tabstop=4 shiftwidth=4 expandtab\n */\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-i6dcpentpa3wkcp6mwcurdfsjksgyiyg/spack-src/src/common/libpmi/pmi2.c": "/************************************************************\\\n * Copyright 2016 Lawrence Livermore National Security, LLC\n * (c.f. AUTHORS, NOTICE.LLNS, COPYING)\n *\n * This file is part of the Flux resource manager framework.\n * For details, see https://github.com/flux-framework.\n *\n * SPDX-License-Identifier: LGPL-3.0\n\\************************************************************/\n\n/* pmi2.c - canonical PMI-2 API/ABI for libpmi2.so.0.0.0\n *\n * This is pretty much the minimum needed to bootstrap MPICH and\n * derivatives under Flux, when they are configured with --with-pm=slurm\n * --with-pmi=pmi2.  This configuration forces a dlopen of libpmi2.so.0.0.0,\n * so use LD_LIBRARY_PATH to make it find ours before Slurm's.\n *\n * Caveats:\n * - Only the API functions and attrs needed for bootstrap are implemented.\n * - This is based on pmi_simple_client, which only supports the v1 wire proto.\n * - Although the pmi_simple_client calls return PMI-1 error codes, PMI-2's\n *   error codes are numerically identical so we don't bother converting.\n * - The kvsname is cached in the pmi_simple_client aux cache on first use.\n *   It is needed internally by PMI2_KVS_Put(), PMI2_Info_GetJobAttr(),\n *   and caching it avoids the RTT of fetching it on each use.\n * - This implementation is not thread safe.  Locks should be added so that\n *   the global context can be shared across threads as is seemingly required\n *   by the PMI-2 design documents (see references below).\n * - Even if locks are added, pmi_simple_client does not support the v1 wire\n *   proto split operations, so multiple PMI_KVS_Get() requests could not be\n *   outstanding in multiple threads.\n * - Is providing the 'PMI_process_mapping' attribute sufficient \"clique\"\n *   support to allow MPI to use shmem to communicate on co-located ranks?\n *\n * See also:\n * - https://wiki.mpich.org/mpich/index.php/PMI_v2_API\n * - https://wiki.mpich.org/mpich/index.php/PMI_v2_Wire_Protocol\n * - https://wiki.mpich.org/mpich/index.php/PMI_v2_Design_Thoughts\n *   https://www.mcs.anl.gov/papers/P1760.pdf\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <string.h>\n\n#include \"pmi.h\"\n#include \"pmi2.h\"\n#include \"pmi_strerror.h\"\n#include \"simple_client.h\"\n\nstatic struct pmi_simple_client *pmi_global_ctx;\n\nint PMI2_Init (int *spawned, int *size, int *rank, int *appnum)\n{\n    int result = PMI2_FAIL;\n    struct pmi_simple_client *ctx;\n\n    if (pmi_global_ctx)\n        return PMI2_ERR_INIT;\n\n    ctx = pmi_simple_client_create_fd (getenv (\"PMI_FD\"),\n                                       getenv (\"PMI_RANK\"),\n                                       getenv (\"PMI_SIZE\"),\n                                       getenv (\"PMI_SPAWNED\"));\n    if (!ctx) {\n        if (errno == ENOMEM)\n            return PMI2_ERR_NOMEM;\n        return PMI2_FAIL;\n    }\n\n    result = pmi_simple_client_init (ctx);\n    if (result != PMI2_SUCCESS) {\n        pmi_simple_client_destroy (ctx);\n        return result;\n    }\n    if (appnum) {\n        result = pmi_simple_client_get_appnum (ctx, appnum);\n        if (result != PMI2_SUCCESS) {\n            pmi_simple_client_destroy (ctx);\n            return result;\n        }\n    }\n    if (spawned)\n        *spawned = ctx->spawned;\n    if (size)\n        *size = ctx->size;\n    if (rank)\n        *rank = ctx->rank;\n\n    pmi_global_ctx = ctx;\n    return PMI2_SUCCESS;\n}\n\nint PMI2_Finalize (void)\n{\n    int result;\n\n    result = pmi_simple_client_finalize (pmi_global_ctx);\n    pmi_simple_client_destroy (pmi_global_ctx);\n\n    pmi_global_ctx = NULL;\n    return result;\n}\n\nint PMI2_Initialized (void)\n{\n    if (pmi_global_ctx && pmi_global_ctx->initialized)\n        return 1;\n    return 0;\n}\n\nint PMI2_Abort (int flag, const char msg[])\n{\n    /* pmi_simple_client_abort() only returns on error, in which case\n     * we fall back to printing the msg on stderr and call exit().\n     * (return code not checked because we don't do anything with it)\n     */\n    (void) pmi_simple_client_abort (pmi_global_ctx, 1, msg);\n    fprintf (stderr, \"PMI2_Abort: (%d) %s\\n\",\n             pmi_global_ctx ? pmi_global_ctx->rank : -1,\n             msg ? msg : \"NULL\");\n    exit (1);\n    /*NOTREACHED*/\n    return PMI_SUCCESS;\n}\n\nint PMI2_Job_Spawn (int count, const char * cmds[],\n                    int argcs[], const char ** argvs[],\n                    const int maxprocs[],\n                    const int info_keyval_sizes[],\n                    const struct MPID_Info *info_keyval_vectors[],\n                    int preput_keyval_size,\n                    const struct MPID_Info *preput_keyval_vector[],\n                    char jobId[], int jobIdSize,\n                    int errors[])\n{\n    return PMI_FAIL;\n}\n\n/* Look up kvsname on first request, then cache for subsequent requests.\n */\nstatic int get_cached_kvsname (struct pmi_simple_client *pmi, const char **name)\n{\n    const char *auxkey = \"flux::kvsname\";\n    char *kvsname;\n    int result;\n\n    if (!pmi)\n        return PMI2_ERR_INIT;\n    if ((kvsname = pmi_simple_client_aux_get (pmi, auxkey))) {\n        *name = kvsname;\n        return PMI2_SUCCESS;\n    }\n    if (!(kvsname = calloc (1, pmi->kvsname_max)))\n        return PMI2_ERR_NOMEM;\n    result = pmi_simple_client_kvs_get_my_name (pmi,\n                                                kvsname,\n                                                pmi->kvsname_max);\n    if (result != PMI2_SUCCESS) {\n        free (kvsname);\n        return result;\n    }\n    if (pmi_simple_client_aux_set (pmi, auxkey, kvsname, free) < 0) {\n        free (kvsname);\n        return PMI2_FAIL;\n    }\n    *name = kvsname;\n    return PMI2_SUCCESS;\n}\n\n/* MPICH: treats PMI2_Job_GetId() equivalent to PMI_KVS_Get_my_name().\n */\nint PMI2_Job_GetId (char jobid[], int jobid_size)\n{\n    const char *kvsname;\n    int result;\n\n    result = get_cached_kvsname (pmi_global_ctx, &kvsname);\n    if (result != PMI2_SUCCESS)\n        return result;\n    if (!jobid || jobid_size < (int)strlen (kvsname) + 1)\n        return PMI2_ERR_INVALID_ARGS;\n    strcpy (jobid, kvsname);\n    return PMI2_SUCCESS;\n}\n\nint PMI2_Job_GetRank (int *rank)\n{\n    return PMI2_FAIL;\n}\n\nint PMI2_Job_Connect (const char jobid[], PMI2_Connect_comm_t *conn)\n{\n    return PMI2_FAIL;\n}\n\nint PMI2_Job_Disconnect (const char jobid[])\n{\n    return PMI2_FAIL;\n}\n\nint PMI2_KVS_Put (const char key[], const char value[])\n{\n    const char *kvsname;\n    int result;\n\n    result = get_cached_kvsname (pmi_global_ctx, &kvsname);\n    if (result != PMI2_SUCCESS)\n        return result;\n\n    return pmi_simple_client_kvs_put (pmi_global_ctx, kvsname, key, value);\n}\n\n/* MPICH: treats jobid equivalent to kvsname.\n * We ignore src_pmi_id.\n */\nint PMI2_KVS_Get (const char *jobid,\n                  int src_pmi_id,\n                  const char key[],\n                  char value [],\n                  int maxvalue,\n                  int *vallen)\n{\n    int result;\n\n    result = pmi_simple_client_kvs_get (pmi_global_ctx,\n                                        jobid,\n                                        key,\n                                        value,\n                                        maxvalue);\n    if (vallen)\n        *vallen = (result == PMI2_SUCCESS) ? strlen (value) : 0;\n    return result;\n}\n\nint PMI2_KVS_Fence (void)\n{\n    return pmi_simple_client_barrier (pmi_global_ctx);\n}\n\nint PMI2_Info_GetSize (int *size)\n{\n    return PMI2_FAIL;\n}\n\nint PMI2_Info_GetNodeAttr (const char name[],\n                           char value[], int valuelen, int *found, int waitfor)\n{\n    return PMI2_FAIL;\n}\n\nint PMI2_Info_GetNodeAttrIntArray (const char name[], int array[],\n                                   int arraylen, int *outlen, int *found)\n{\n    return PMI2_FAIL;\n}\n\nint PMI2_Info_PutNodeAttr (const char name[], const char value[])\n{\n    return PMI2_FAIL;\n}\n\n/* MPICH: only fetches PMI_process_mapping and universeSize\n * with PMI2_Info_GetJobAttr().\n */\nint PMI2_Info_GetJobAttr (const char name[],\n                          char value[], int valuelen, int *found)\n{\n    int result;\n\n    if (!name || !value) {\n        result = PMI2_ERR_INVALID_ARG;\n        goto error;\n    }\n    if (!strcmp (name, \"PMI_process_mapping\")) {\n        const char *kvsname;\n\n        result = get_cached_kvsname (pmi_global_ctx, &kvsname);\n        if (result != PMI2_SUCCESS)\n            goto error;\n        result = pmi_simple_client_kvs_get (pmi_global_ctx,\n                                            kvsname,\n                                            name,\n                                            value,\n                                            valuelen);\n        if (result != PMI2_SUCCESS)\n            goto error;\n    }\n    else if (!strcmp (name, \"universeSize\")) {\n        int universe_size;\n\n        result = pmi_simple_client_get_universe_size (pmi_global_ctx,\n                                                      &universe_size);\n        if (result != PMI2_SUCCESS)\n            goto error;\n        if (snprintf (value,\n                      valuelen,\n                      \"%d\",\n                      universe_size) >= valuelen) {\n            result = PMI2_ERR_INVALID_VAL_LENGTH;\n            goto error;\n        }\n    }\n    else {\n        result = PMI2_ERR_INVALID_KEY;\n        goto error;\n    }\n    if (found)\n        *found = 1;\n    return PMI2_SUCCESS;\nerror:\n    if (found)\n        *found = 0;\n    return result;\n}\n\nint PMI2_Info_GetJobAttrIntArray (const char name[], int array[],\n                                  int arraylen, int *outlen, int *found)\n{\n    return PMI2_FAIL;\n}\n\nint PMI2_Nameserv_publish (const char service_name[],\n                           const struct MPID_Info *info_ptr, const char port[])\n{\n    return PMI2_FAIL;\n}\n\nint PMI2_Nameserv_lookup (const char service_name[],\n                          const struct MPID_Info *info_ptr,\n                          char port[], int portLen)\n{\n    return PMI2_FAIL;\n}\n\nint PMI2_Nameserv_unpublish (const char service_name[],\n                             const struct MPID_Info *info_ptr)\n{\n    return PMI2_FAIL;\n}\n\n/*\n * vi:tabstop=4 shiftwidth=4 expandtab\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-i6dcpentpa3wkcp6mwcurdfsjksgyiyg/spack-src/src/common/libpmi/pmi.c": "/************************************************************\\\n * Copyright 2014 Lawrence Livermore National Security, LLC\n * (c.f. AUTHORS, NOTICE.LLNS, COPYING)\n *\n * This file is part of the Flux resource manager framework.\n * For details, see https://github.com/flux-framework.\n *\n * SPDX-License-Identifier: LGPL-3.0\n\\************************************************************/\n\n/* pmi.c - canonical PMI-1 API/ABI for libpmi.so\n *\n * A client (e.g. an MPI runtime) may use PMI in one of three modes:\n * 1) link with this library in the normal way\n * 2) dlopen() this library and use standard ABI\n * 3) Interpret PMI environ variables and bypass the library,\n *    speaking the standard PMI-1 wire protocol directly.\n *\n * This library only talks to the process manager via the standard\n * wire protocol.\n *\n * PMI_Init() will fail if PMI_FD, PMI_RANK, or PMI_SIZE is unset.\n * It is up to the caller to fall back to singleton operation, if desired.\n *\n * See Flux RFC 13 for more detail.\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/types.h>\n\n#include \"pmi.h\"\n#include \"pmi_strerror.h\"\n#include \"simple_client.h\"\n#include \"clique.h\"\n\nstatic struct pmi_simple_client *pmi_global_ctx;\n\nint PMI_Init (int *spawned)\n{\n    int result;\n    struct pmi_simple_client *ctx;\n\n    if (pmi_global_ctx)\n        return PMI_ERR_INIT;\n\n    ctx = pmi_simple_client_create_fd (getenv (\"PMI_FD\"),\n                                       getenv (\"PMI_RANK\"),\n                                       getenv (\"PMI_SIZE\"),\n                                       getenv (\"PMI_SPAWNED\"));\n    if (!ctx) {\n        if (errno == ENOMEM)\n            return PMI_ERR_NOMEM;\n        return PMI_FAIL;\n    }\n\n    result = pmi_simple_client_init (ctx);\n    if (result != PMI_SUCCESS) {\n        pmi_simple_client_destroy (ctx);\n        return result;\n    }\n    pmi_global_ctx = ctx;\n    if (spawned)\n        *spawned = ctx->spawned;\n    return PMI_SUCCESS;\n}\n\nint PMI_Initialized (int *initialized)\n{\n    if (!initialized)\n        return PMI_ERR_INVALID_ARG;\n    *initialized = pmi_global_ctx ? pmi_global_ctx->initialized : 0;\n    return PMI_SUCCESS;\n}\n\nint PMI_Finalize (void)\n{\n    int result;\n\n    if (!pmi_global_ctx)\n        return PMI_ERR_INIT;\n    result = pmi_simple_client_finalize (pmi_global_ctx);\n    pmi_simple_client_destroy (pmi_global_ctx);\n    pmi_global_ctx = NULL;\n    return result;\n}\n\nint PMI_Abort (int exit_code, const char error_msg[])\n{\n    /* pmi_simple_client_abort() only returns on error, in which case\n     * we fall back to printing the message on stderr and call exit()\n     * (return code not checked because we don't do anything with it)\n     */\n    (void) pmi_simple_client_abort (pmi_global_ctx, exit_code, error_msg);\n    fprintf (stderr, \"PMI_Abort: (%d) %s\\n\",\n             pmi_global_ctx ? pmi_global_ctx->rank : -1,\n             error_msg);\n    exit (exit_code);\n    /*NOTREACHED*/\n    return PMI_SUCCESS;\n}\n\nint PMI_Get_size (int *size)\n{\n    if (!pmi_global_ctx)\n        return PMI_ERR_INIT;\n    if (!size)\n        return PMI_ERR_INVALID_ARG;\n    *size = pmi_global_ctx->size;\n    return PMI_SUCCESS;\n}\n\nint PMI_Get_rank (int *rank)\n{\n    if (!pmi_global_ctx)\n        return PMI_ERR_INIT;\n    if (!rank)\n        return PMI_ERR_INVALID_ARG;\n    *rank = pmi_global_ctx->rank;\n    return PMI_SUCCESS;\n}\n\nint PMI_Get_universe_size (int *size)\n{\n    return pmi_simple_client_get_universe_size (pmi_global_ctx, size);\n}\n\nint PMI_Get_appnum (int *appnum)\n{\n    return pmi_simple_client_get_appnum (pmi_global_ctx, appnum);\n}\n\nint PMI_KVS_Get_my_name (char kvsname[], int length)\n{\n    return pmi_simple_client_kvs_get_my_name (pmi_global_ctx,\n                                              kvsname,\n                                              length);\n}\n\nint PMI_KVS_Get_name_length_max (int *length)\n{\n    if (!pmi_global_ctx || !pmi_global_ctx->initialized)\n        return PMI_ERR_INIT;\n    if (!length)\n        return PMI_ERR_INVALID_ARG;\n    *length = pmi_global_ctx->kvsname_max;\n    return PMI_SUCCESS;\n}\n\nint PMI_KVS_Get_key_length_max (int *length)\n{\n    if (!pmi_global_ctx || !pmi_global_ctx->initialized)\n        return PMI_ERR_INIT;\n    if (!length)\n        return PMI_ERR_INVALID_ARG;\n    *length = pmi_global_ctx->keylen_max;\n    return PMI_SUCCESS;\n}\n\nint PMI_KVS_Get_value_length_max (int *length)\n{\n    if (!pmi_global_ctx || !pmi_global_ctx->initialized)\n        return PMI_ERR_INIT;\n    if (!length)\n        return PMI_ERR_INVALID_ARG;\n    *length = pmi_global_ctx->vallen_max;\n    return PMI_SUCCESS;\n}\n\nint PMI_KVS_Put (const char kvsname[], const char key[], const char value[])\n{\n    return pmi_simple_client_kvs_put (pmi_global_ctx, kvsname, key, value);\n}\n\nint PMI_KVS_Get (const char kvsname[], const char key[],\n                 char value[], int length)\n{\n    return pmi_simple_client_kvs_get (pmi_global_ctx,\n                                      kvsname,\n                                      key,\n                                      value,\n                                      length);\n}\n\nint PMI_KVS_Commit (const char kvsname[])\n{\n    if (!pmi_global_ctx || !pmi_global_ctx->initialized)\n        return PMI_ERR_INIT;\n    if (!kvsname)\n        return PMI_ERR_INVALID_ARG;\n    return PMI_SUCCESS; // no-op in this implementation\n}\n\nint PMI_Barrier (void)\n{\n    return pmi_simple_client_barrier (pmi_global_ctx);\n}\n\nint PMI_Publish_name (const char service_name[], const char port[])\n{\n    return PMI_FAIL;\n}\n\nint PMI_Unpublish_name (const char service_name[])\n{\n    return PMI_FAIL;\n}\n\nint PMI_Lookup_name (const char service_name[], char port[])\n{\n    return PMI_FAIL;\n}\n\nint PMI_Spawn_multiple(int count,\n                       const char * cmds[],\n                       const char ** argvs[],\n                       const int maxprocs[],\n                       const int info_keyval_sizesp[],\n                       const PMI_keyval_t * info_keyval_vectors[],\n                       int preput_keyval_size,\n                       const PMI_keyval_t preput_keyval_vector[],\n                       int errors[])\n{\n    return PMI_FAIL;\n}\n\n/* Old API funcs - signatures needed for ABI compliance.\n */\n\nint PMI_Get_clique_ranks (int ranks[], int length)\n{\n    return pmi_simple_client_get_clique_ranks (pmi_global_ctx, ranks, length);\n}\n\nint PMI_Get_clique_size (int *size)\n{\n    return pmi_simple_client_get_clique_size (pmi_global_ctx, size);\n}\n\nint PMI_Get_id_length_max (int *length)\n{\n    return PMI_KVS_Get_name_length_max (length);\n}\n\nint PMI_Get_id (char kvsname[], int length)\n{\n    return PMI_KVS_Get_my_name (kvsname, length);\n}\n\nint PMI_Get_kvs_domain_id (char kvsname[], int length)\n{\n    return PMI_KVS_Get_my_name (kvsname, length);\n}\n\nint PMI_KVS_Create (char kvsname[], int length)\n{\n    return PMI_FAIL;\n}\n\nint PMI_KVS_Destroy (const char kvsname[])\n{\n    return PMI_FAIL;\n}\n\nint PMI_KVS_Iter_first (const char kvsname[], char key[], int key_len,\n                        char val[], int val_len)\n{\n    return PMI_FAIL;\n}\n\nint PMI_KVS_Iter_next (const char kvsname[], char key[], int key_len,\n                       char val[], int val_len)\n{\n    return PMI_FAIL;\n}\n\nint PMI_Parse_option (int num_args, char *args[], int *num_parsed,\n                      PMI_keyval_t **keyvalp, int *size)\n{\n    return PMI_FAIL;\n}\n\nint PMI_Args_to_keyval (int *argcp, char *((*argvp)[]),\n                        PMI_keyval_t **keyvalp, int *size)\n{\n    return PMI_FAIL;\n}\n\nint PMI_Free_keyvals (PMI_keyval_t keyvalp[], int size)\n{\n    return PMI_FAIL;\n}\n\nint PMI_Get_options (char *str, int *length)\n{\n    return PMI_FAIL;\n}\n\n/*\n * vi:tabstop=4 shiftwidth=4 expandtab\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-i6dcpentpa3wkcp6mwcurdfsjksgyiyg/spack-src/src/broker/pmiutil.c": "/************************************************************\\\n * Copyright 2019 Lawrence Livermore National Security, LLC\n * (c.f. AUTHORS, NOTICE.LLNS, COPYING)\n *\n * This file is part of the Flux resource manager framework.\n * For details, see https://github.com/flux-framework.\n *\n * SPDX-License-Identifier: LGPL-3.0\n\\************************************************************/\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <sys/param.h>\n#include <unistd.h>\n#include <dlfcn.h>\n#include <assert.h>\n#include <czmq.h>\n\n#include \"src/common/libutil/log.h\"\n#include \"src/common/libutil/iterators.h\"\n#include \"src/common/libpmi/pmi.h\"\n#include \"src/common/libpmi/pmi_strerror.h\"\n#include \"src/common/libpmi/simple_client.h\"\n\n#include \"pmiutil.h\"\n#include \"liblist.h\"\n\ntypedef enum {\n    PMI_MODE_SINGLETON,\n    PMI_MODE_DLOPEN,\n    PMI_MODE_WIRE1,\n} pmi_mode_t;\n\nstruct pmi_dso {\n    void *dso;\n    int (*init) (int *spawned);\n    int (*finalize) (void);\n    int (*get_size) (int *size);\n    int (*get_rank) (int *rank);\n    int (*barrier) (void);\n    int (*kvs_get_my_name) (char *kvsname, int length);\n    int (*kvs_put) (const char *kvsname, const char *key, const char *value);\n    int (*kvs_commit) (const char *kvsname);\n    int (*kvs_get) (const char *kvsname, const char *key, char *value, int len);\n};\n\nstruct pmi_handle {\n    struct pmi_dso *dso;\n    struct pmi_simple_client *cli;\n    int debug;\n    pmi_mode_t mode;\n    int rank;\n};\n\nstatic void vdebugf (struct pmi_handle *pmi, const char *fmt, va_list ap)\n{\n\n    if (pmi->debug) {\n        char buf[1024];\n        (void)vsnprintf (buf, sizeof (buf), fmt, ap);\n        fprintf (stderr, \"pmi-debug-%s[%d]: %s\\n\",\n                pmi->mode == PMI_MODE_SINGLETON ? \"singleton\" :\n                pmi->mode == PMI_MODE_WIRE1 ? \"wire.1\" :\n                pmi->mode == PMI_MODE_DLOPEN ? \"dlopen\" : \"unknown\",\n                pmi->rank,\n                buf);\n    }\n}\n\nstatic void debugf (struct pmi_handle *pmi, const char *fmt, ...)\n{\n    va_list ap;\n    va_start (ap, fmt);\n    vdebugf (pmi, fmt, ap);\n    va_end (ap);\n}\n\nstatic void broker_pmi_dlclose (struct pmi_dso *dso)\n{\n    if (dso) {\n#ifndef __SANITIZE_ADDRESS__\n        if (dso->dso)\n            dlclose (dso->dso);\n#endif\n        free (dso);\n    }\n}\n\n/* Notes:\n * - Use RTLD_GLOBAL due to issue #432\n */\nstatic struct pmi_dso *broker_pmi_dlopen (const char *pmi_library, int debug)\n{\n    struct pmi_dso *dso;\n    zlist_t *libs = NULL;\n    char *name;\n\n    if (!(dso = calloc (1, sizeof (*dso))))\n        return NULL;\n    if (!pmi_library)\n        pmi_library = \"libpmi.so\";\n    if (!(libs = liblist_create (pmi_library)))\n        goto error;\n    FOREACH_ZLIST (libs, name) {\n        dlerror ();\n        if (!(dso->dso = dlopen (name, RTLD_NOW | RTLD_GLOBAL))) {\n            if (debug) {\n                char *errstr = dlerror ();\n                if (errstr)\n                    log_msg (\"pmi-debug-dlopen: %s\", errstr);\n                else\n                    log_msg (\"pmi-debug-dlopen: dlopen %s failed\", name);\n            }\n        }\n        else if (dlsym (dso->dso, \"flux_pmi_library\")) {\n            if (debug)\n                log_msg (\"pmi-debug-dlopen: skipping %s\", name);\n            dlclose (dso->dso);\n            dso->dso = NULL;\n        }\n        else {\n            if (debug)\n                log_msg (\"pmi-debug-dlopen: library name %s\", name);\n        }\n    }\n    liblist_destroy (libs);\n    libs = NULL;\n    if (!dso->dso)\n        goto error;\n    dso->init = dlsym (dso->dso, \"PMI_Init\");\n    dso->finalize = dlsym (dso->dso, \"PMI_Finalize\");\n    dso->get_size = dlsym (dso->dso, \"PMI_Get_size\");\n    dso->get_rank = dlsym (dso->dso, \"PMI_Get_rank\");\n    dso->barrier = dlsym (dso->dso, \"PMI_Barrier\");\n    dso->kvs_get_my_name = dlsym (dso->dso, \"PMI_KVS_Get_my_name\");\n    dso->kvs_put = dlsym (dso->dso, \"PMI_KVS_Put\");\n    dso->kvs_commit = dlsym (dso->dso, \"PMI_KVS_Commit\");\n    dso->kvs_get = dlsym (dso->dso, \"PMI_KVS_Get\");\n\n    if (!dso->init || !dso->finalize || !dso->get_size || !dso->get_rank\n            || !dso->barrier || !dso->kvs_get_my_name\n            || !dso->kvs_put || !dso->kvs_commit || !dso->kvs_get) {\n        log_msg (\"pmi-debug-dlopen: dlsym: %s is missing required symbols\",\n                 pmi_library);\n        goto error;\n    }\n    return dso;\nerror:\n    broker_pmi_dlclose (dso);\n    if (libs)\n        liblist_destroy (libs);\n    return NULL;\n}\n\nint broker_pmi_kvs_commit (struct pmi_handle *pmi, const char *kvsname)\n{\n    int ret = PMI_SUCCESS;\n\n    switch (pmi->mode) {\n        case PMI_MODE_SINGLETON:\n            break;\n        case PMI_MODE_WIRE1:\n            break;\n        case PMI_MODE_DLOPEN:\n            ret = pmi->dso->kvs_commit (kvsname);\n            break;\n    }\n    debugf (pmi,\n            \"kvs_commit (kvsname=%s) = %s\",\n            kvsname,\n            pmi_strerror (ret));\n    return ret;\n}\n\nint broker_pmi_kvs_put (struct pmi_handle *pmi,\n                        const char *kvsname,\n                        const char *key,\n                        const char *value)\n{\n    int ret = PMI_SUCCESS;\n\n    switch (pmi->mode) {\n        case PMI_MODE_SINGLETON:\n            break;\n        case PMI_MODE_WIRE1:\n            ret = pmi_simple_client_kvs_put (pmi->cli, kvsname, key, value);\n            break;\n        case PMI_MODE_DLOPEN:\n            ret = pmi->dso->kvs_put (kvsname, key, value);\n            break;\n    }\n    debugf (pmi,\n            \"kvs_put (kvsname=%s key=%s value=%s) = %s\",\n            kvsname,\n            key,\n            value,\n            pmi_strerror (ret));\n    return ret;\n}\n\nint broker_pmi_kvs_get (struct pmi_handle *pmi,\n                               const char *kvsname,\n                               const char *key,\n                               char *value,\n                               int len)\n{\n    int ret = PMI_FAIL;\n\n    switch (pmi->mode) {\n        case PMI_MODE_SINGLETON:\n            break;\n        case PMI_MODE_WIRE1:\n            ret = pmi_simple_client_kvs_get (pmi->cli, kvsname, key, value, len);\n            break;\n        case PMI_MODE_DLOPEN:\n            ret = pmi->dso->kvs_get (kvsname, key, value, len);\n            break;\n    }\n    debugf (pmi,\n            \"kvs_get (kvsname=%s key=%s value=%s) = %s\",\n            kvsname,\n            key,\n            ret == PMI_SUCCESS ? value : \"<none>\",\n            pmi_strerror (ret));\n    return ret;\n}\n\nint broker_pmi_barrier (struct pmi_handle *pmi)\n{\n    int ret = PMI_SUCCESS;\n\n    switch (pmi->mode) {\n        case PMI_MODE_SINGLETON:\n            break;\n        case PMI_MODE_WIRE1:\n            ret = pmi_simple_client_barrier (pmi->cli);\n            break;\n        case PMI_MODE_DLOPEN:\n            ret = pmi->dso->barrier();\n            break;\n    }\n    debugf (pmi, \"barrier = %s\", pmi_strerror (ret));\n    return ret;\n}\n\nint broker_pmi_get_params (struct pmi_handle *pmi,\n                           struct pmi_params *params)\n{\n    int ret = PMI_SUCCESS;\n\n    switch (pmi->mode) {\n        case PMI_MODE_SINGLETON:\n            params->rank = 0;\n            params->size = 1;\n            snprintf (params->kvsname, sizeof (params->kvsname), \"singleton\");\n            break;\n        case PMI_MODE_WIRE1:\n            params->rank = pmi->cli->rank;\n            params->size = pmi->cli->size;\n            ret = pmi_simple_client_kvs_get_my_name (pmi->cli,\n                                                     params->kvsname,\n                                                     sizeof (params->kvsname));\n            break;\n        case PMI_MODE_DLOPEN:\n            if ((ret = pmi->dso->get_rank (&params->rank)) != PMI_SUCCESS)\n                break;\n            if ((ret = pmi->dso->get_size (&params->size)) != PMI_SUCCESS)\n                break;\n            ret = pmi->dso->kvs_get_my_name (params->kvsname,\n                                             sizeof (params->kvsname));\n            break;\n    }\n    if (ret == PMI_SUCCESS)\n        pmi->rank = params->rank;\n    debugf (pmi,\n            \"get_params (rank=%d size=%d kvsname=%s) = %s\",\n            ret == PMI_SUCCESS ? params->rank : -1,\n            ret == PMI_SUCCESS ? params->size : -1,\n            ret == PMI_SUCCESS ? params->kvsname: \"<none>\",\n            pmi_strerror (ret));\n    return ret;\n}\n\nint broker_pmi_init (struct pmi_handle *pmi)\n{\n    int spawned;\n    int ret = PMI_SUCCESS;\n\n    switch (pmi->mode) {\n        case PMI_MODE_SINGLETON:\n            break;\n        case PMI_MODE_WIRE1:\n            ret = pmi_simple_client_init (pmi->cli);\n            break;\n        case PMI_MODE_DLOPEN:\n            ret = pmi->dso->init(&spawned);\n            break;\n    }\n    debugf (pmi, \"init = %s\", pmi_strerror (ret));\n    return ret;\n}\n\nint broker_pmi_finalize (struct pmi_handle *pmi)\n{\n    int ret = PMI_SUCCESS;\n\n    switch (pmi->mode) {\n        case PMI_MODE_SINGLETON:\n            break;\n        case PMI_MODE_WIRE1:\n            ret = pmi_simple_client_finalize (pmi->cli);\n            break;\n        case PMI_MODE_DLOPEN:\n            ret = pmi->dso->finalize ();\n            break;\n    }\n    debugf (pmi, \"finalize = %s\", pmi_strerror (ret));\n    return PMI_SUCCESS;\n}\n\nvoid broker_pmi_destroy (struct pmi_handle *pmi)\n{\n    if (pmi) {\n        int saved_errno = errno;\n        switch (pmi->mode) {\n            case PMI_MODE_SINGLETON:\n                break;\n            case PMI_MODE_WIRE1:\n                pmi_simple_client_destroy (pmi->cli);\n                break;\n            case PMI_MODE_DLOPEN:\n                broker_pmi_dlclose (pmi->dso);\n                break;\n        }\n        free (pmi);\n        errno = saved_errno;\n    }\n}\n\n/* Attempt to set up PMI-1 wire protocol client.\n * If that fails, try dlopen.\n * If that fails, singleton will be used.\n */\nstruct pmi_handle *broker_pmi_create (void)\n{\n    const char *pmi_debug;\n    struct pmi_handle *pmi = calloc (1, sizeof (*pmi));\n    if (!pmi)\n        return NULL;\n    pmi->rank = -1;\n    pmi_debug = getenv (\"FLUX_PMI_DEBUG\");\n    if (pmi_debug)\n        pmi->debug = strtol (pmi_debug, NULL, 10);\n    if ((pmi->cli = pmi_simple_client_create_fd (getenv (\"PMI_FD\"),\n                                                 getenv (\"PMI_RANK\"),\n                                                 getenv (\"PMI_SIZE\"),\n                                                 NULL))) {\n        pmi->mode = PMI_MODE_WIRE1;\n    }\n    /* N.B. SLURM boldly installs its libpmi.so into the system libdir,\n     * so it will be found here, even if not running in a SLURM job.\n     * Fortunately it emulates singleton in that case, in lieu of failing.\n     */\n    else if ((pmi->dso = broker_pmi_dlopen (getenv (\"PMI_LIBRARY\"),\n                                            pmi->debug))) {\n        pmi->mode = PMI_MODE_DLOPEN;\n    }\n    /* If neither pmi->cli nor pmi->dso is set, singleton is assumed.\n     */\n    else {\n        pmi->mode = PMI_MODE_SINGLETON;\n    }\n    return pmi;\n}\n\n/*\n * vi:tabstop=4 shiftwidth=4 expandtab\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-i6dcpentpa3wkcp6mwcurdfsjksgyiyg/spack-src/src/broker/module.c": "/************************************************************\\\n * Copyright 2014 Lawrence Livermore National Security, LLC\n * (c.f. AUTHORS, NOTICE.LLNS, COPYING)\n *\n * This file is part of the Flux resource manager framework.\n * For details, see https://github.com/flux-framework.\n *\n * SPDX-License-Identifier: LGPL-3.0\n\\************************************************************/\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <stdbool.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <stdarg.h>\n#include <dlfcn.h>\n#include <inttypes.h>\n#include <argz.h>\n#include <czmq.h>\n#include <uuid.h>\n#include <flux/core.h>\n#include <jansson.h>\n#if HAVE_CALIPER\n#include <caliper/cali.h>\n#include <sys/syscall.h>\n#endif\n\n#include \"src/common/libutil/log.h\"\n#include \"src/common/libutil/iterators.h\"\n\n#include \"heartbeat.h\"\n#include \"module.h\"\n#include \"modservice.h\"\n\n#ifndef UUID_STR_LEN\n#define UUID_STR_LEN 37     // defined in later libuuid headers\n#endif\n\n\n#define MODULE_MAGIC    0xfeefbe01\nstruct broker_module {\n    int magic;\n\n    uint32_t rank;\n    flux_t *broker_h;\n    flux_watcher_t *broker_w;\n\n    int lastseen;\n    heartbeat_t *heartbeat;\n\n    zsock_t *sock;          /* broker end of PAIR socket */\n    struct flux_msg_cred cred; /* cred of connection */\n\n    uuid_t uuid;            /* uuid for unique request sender identity */\n    char uuid_str[UUID_STR_LEN];\n    pthread_t t;            /* module thread */\n    mod_main_f *main;       /* dlopened mod_main() */\n    char *name;\n    void *dso;              /* reference on dlopened module */\n    int size;               /* size of .so file for lsmod */\n    char *digest;           /* digest of .so file for lsmod */\n    size_t argz_len;\n    char *argz;\n    int status;\n    int errnum;\n    bool muted;             /* module is under directive 42, no new messages */\n\n    modpoller_cb_f poller_cb;\n    void *poller_arg;\n    module_status_cb_f status_cb;\n    void *status_arg;\n\n    struct disconnect *disconnect;\n\n    zlist_t *rmmod;\n    flux_msg_t *insmod;\n\n    flux_t *h;               /* module's handle */\n\n    zlist_t *subs;          /* subscription strings */\n};\n\nstruct modhash {\n    zhash_t *zh_byuuid;\n    uint32_t rank;\n    flux_t *broker_h;\n    heartbeat_t *heartbeat;\n};\n\nstatic int setup_module_profiling (module_t *p)\n{\n#if HAVE_CALIPER\n    cali_begin_string_byname (\"flux.type\", \"module\");\n    cali_begin_int_byname (\"flux.tid\", syscall (SYS_gettid));\n    cali_begin_int_byname (\"flux.rank\", p->rank);\n    cali_begin_string_byname (\"flux.name\", p->name);\n#endif\n    return (0);\n}\n\n/*  Synchronize the FINALIZING state with the broker, so the broker\n *   can stop messages to this module until we're fully shutdown.\n */\nstatic int module_finalizing (module_t *p)\n{\n    int rc = -1;\n    flux_msg_t *msg = NULL;\n    struct flux_match match = {\n        .typemask = FLUX_MSGTYPE_KEEPALIVE\n    };\n    /* Notify the broker we're finalizing, which will disable new\n     *  messages\n     */\n    if (!(msg = flux_keepalive_encode (0, FLUX_MODSTATE_FINALIZING))) {\n        flux_log_error (p->h, \"module_finalizing: flux_keepalive_encode\");\n        return -1;\n    }\n    if (flux_send (p->h, msg, 0) < 0) {\n        flux_log_error (p->h, \"module_finalizing: flux_send\");\n        goto done;\n    }\n    flux_msg_destroy (msg);\n\n    /* Synchronize with the broker using a blocking recv for keepalive\n     *  message. This should be the only time the broker sends a keepalive\n     *  to a module.\n     */\n    if (!(msg = flux_recv (p->h, match, 0)))\n        flux_log_error (p->h, \"module_finalizing: flux_recv\");\n    rc = 0;\ndone:\n    flux_msg_destroy (msg);\n    return rc;\n}\n\nstatic void *module_thread (void *arg)\n{\n    module_t *p = arg;\n    assert (p->magic == MODULE_MAGIC);\n    sigset_t signal_set;\n    int errnum;\n    char *uri = NULL;\n    char **av = NULL;\n    char *rankstr = NULL;\n    int ac;\n    int mod_main_errno = 0;\n    flux_msg_t *msg;\n    flux_conf_t *conf;\n\n    setup_module_profiling (p);\n\n    /* Connect to broker socket, enable logging, register built-in services\n     */\n    if (asprintf (&uri, \"shmem://%s\", p->uuid_str) < 0) {\n        log_err (\"asprintf\");\n        goto done;\n    }\n    if (!(p->h = flux_open (uri, 0))) {\n        log_err (\"flux_open %s\", uri);\n        goto done;\n    }\n    if (asprintf (&rankstr, \"%\"PRIu32, p->rank) < 0) {\n        log_err (\"asprintf\");\n        goto done;\n    }\n    if (flux_attr_set_cacheonly (p->h, \"rank\", rankstr) < 0) {\n        log_err (\"%s: error faking rank attribute\", p->name);\n        goto done;\n    }\n    flux_log_set_appname (p->h, p->name);\n    /* Copy the broker's config object so that modules\n     * can call flux_get_conf() and expect it to always succeed.\n     */\n    if (!(conf = flux_conf_copy (flux_get_conf (p->broker_h)))\n            || flux_set_conf (p->h, conf) < 0) {\n        flux_conf_decref (conf);\n        log_err (\"%s: error duplicating config object\", p->name);\n        goto done;\n    }\n    if (modservice_register (p->h, p) < 0) {\n        log_err (\"%s: modservice_register\", p->name);\n        goto done;\n    }\n\n    /* Block all signals\n     */\n    if (sigfillset (&signal_set) < 0) {\n        log_err (\"%s: sigfillset\", p->name);\n        goto done;\n    }\n    if ((errnum = pthread_sigmask (SIG_BLOCK, &signal_set, NULL)) != 0) {\n        log_errn (errnum, \"pthread_sigmask\");\n        goto done;\n    }\n\n    /* Run the module's main().\n     */\n    ac = argz_count (p->argz, p->argz_len);\n    if (!(av = calloc (1, sizeof (av[0]) * (ac + 1)))) {\n        log_errn (ENOMEM, \"calloc\");\n        goto done;\n    }\n    argz_extract (p->argz, p->argz_len, av);\n    if (p->main (p->h, ac, av) < 0) {\n        mod_main_errno = errno;\n        if (mod_main_errno == 0)\n            mod_main_errno = ECONNRESET;\n        flux_log (p->h, LOG_CRIT, \"fatal error: %s\", strerror (errno));\n    }\n\n    /* Before processing unhandled requests, ensure that this module\n     * is \"muted\" in the broker. This ensures the broker won't try to\n     * feed a message to this module after we've closed the handle,\n     * which could cause the broker to block.\n     */\n    if (module_finalizing (p) < 0)\n        flux_log_error (p->h, \"failed to set module state to finalizing\");\n\n    /* If any unhandled requests were received during shutdown,\n     * respond to them now with ENOSYS.\n     */\n    while ((msg = flux_recv (p->h, FLUX_MATCH_REQUEST, FLUX_O_NONBLOCK))) {\n        const char *topic = \"unknown\";\n        (void)flux_msg_get_topic (msg, &topic);\n        flux_log (p->h, LOG_DEBUG, \"responding to post-shutdown %s\", topic);\n        if (flux_respond_error (p->h, msg, ENOSYS, NULL) < 0)\n            flux_log_error (p->h, \"responding to post-shutdown %s\", topic);\n        flux_msg_destroy (msg);\n    }\n    if (!(msg = flux_keepalive_encode (mod_main_errno, FLUX_MODSTATE_EXITED))) {\n        flux_log_error (p->h, \"flux_keepalive_encode\");\n        goto done;\n    }\n    if (flux_send (p->h, msg, 0) < 0)\n        flux_log_error (p->h, \"flux_send\");\n    flux_msg_destroy (msg);\ndone:\n    free (uri);\n    free (rankstr);\n    if (av)\n        free (av);\n    flux_close (p->h);\n    p->h = NULL;\n    return NULL;\n}\n\nconst char *module_get_name (module_t *p)\n{\n    assert (p->magic == MODULE_MAGIC);\n    return p->name;\n}\n\nconst char *module_get_uuid (module_t *p)\n{\n    return p->uuid_str;\n}\n\nstatic int module_get_idle (module_t *p)\n{\n    return heartbeat_get_epoch (p->heartbeat) - p->lastseen;\n}\n\nflux_msg_t *module_recvmsg (module_t *p)\n{\n    flux_msg_t *msg = NULL;\n    int type;\n    struct flux_msg_cred cred;\n\n    assert (p->magic == MODULE_MAGIC);\n\n    if (!(msg = flux_msg_recvzsock (p->sock)))\n        goto error;\n    if (flux_msg_get_type (msg, &type) < 0)\n        goto error;\n    switch (type) {\n        case FLUX_MSGTYPE_RESPONSE:\n            if (flux_msg_pop_route (msg, NULL) < 0)\n                goto error;\n            break;\n        case FLUX_MSGTYPE_REQUEST:\n        case FLUX_MSGTYPE_EVENT:\n            if (flux_msg_push_route (msg, p->uuid_str) < 0)\n                goto error;\n            break;\n        default:\n            break;\n    }\n    /* All shmem:// connections to the broker have FLUX_ROLE_OWNER\n     * and are \"authenticated\" as the instance owner.\n     * Allow modules so endowed to change the userid/rolemask on messages when\n     * sending on behalf of other users.  This is necessary for connectors\n     * implemented as DSOs.\n     */\n    assert ((p->cred.rolemask & FLUX_ROLE_OWNER));\n    if (flux_msg_get_cred (msg, &cred) < 0)\n        goto error;\n    if (cred.userid == FLUX_USERID_UNKNOWN)\n        cred.userid = p->cred.userid;\n    if (cred.rolemask == FLUX_ROLE_NONE)\n        cred.rolemask = p->cred.rolemask;\n    if (flux_msg_set_cred (msg, cred) < 0)\n        goto error;\n    return msg;\nerror:\n    flux_msg_destroy (msg);\n    return NULL;\n}\n\nint module_sendmsg (module_t *p, const flux_msg_t *msg)\n{\n    flux_msg_t *cpy = NULL;\n    int type;\n    int rc = -1;\n\n    if (!msg)\n        return 0;\n    if (flux_msg_get_type (msg, &type) < 0)\n        goto done;\n    if (p->muted && type != FLUX_MSGTYPE_KEEPALIVE) {\n        /* Muted modules only accept keepalive messages */\n        const char *topic;\n        (void) flux_msg_get_topic (msg, &topic);\n        errno = ENOSYS;\n        goto done;\n    }\n    switch (type) {\n        case FLUX_MSGTYPE_REQUEST: { /* simulate DEALER socket */\n            char uuid[16];\n            snprintf (uuid, sizeof (uuid), \"%\"PRIu32, p->rank);\n            if (!(cpy = flux_msg_copy (msg, true)))\n                goto done;\n            if (flux_msg_push_route (cpy, uuid) < 0)\n                goto done;\n            if (flux_msg_sendzsock (p->sock, cpy) < 0)\n                goto done;\n            break;\n        }\n        case FLUX_MSGTYPE_RESPONSE: { /* simulate ROUTER socket */\n            if (!(cpy = flux_msg_copy (msg, true)))\n                goto done;\n            if (flux_msg_pop_route (cpy, NULL) < 0)\n                goto done;\n            if (flux_msg_sendzsock (p->sock, cpy) < 0)\n                goto done;\n            break;\n        }\n        default:\n            if (flux_msg_sendzsock (p->sock, msg) < 0)\n                goto done;\n            break;\n    }\n    rc = 0;\ndone:\n    flux_msg_destroy (cpy);\n    return rc;\n}\n\nint module_response_sendmsg (modhash_t *mh, const flux_msg_t *msg)\n{\n    char *uuid = NULL;\n    int rc = -1;\n    module_t *p;\n\n    if (!msg)\n        return 0;\n    if (flux_msg_get_route_last (msg, &uuid) < 0)\n        goto done;\n    if (!uuid) {\n        errno = EPROTO;\n        goto done;\n    }\n    if (!(p = zhash_lookup (mh->zh_byuuid, uuid))) {\n        errno = ENOSYS;\n        goto done;\n    }\n    rc = module_sendmsg (p, msg);\ndone:\n    if (uuid)\n        free (uuid);\n    return rc;\n}\n\nint module_disconnect_arm (module_t *p,\n                           const flux_msg_t *msg,\n                           disconnect_send_f cb,\n                           void *arg)\n{\n    if (!p->disconnect) {\n        if (!(p->disconnect = disconnect_create (cb, arg)))\n            return -1;\n    }\n    if (disconnect_arm (p->disconnect, msg) < 0)\n        return -1;\n    return 0;\n}\n\nstatic void module_destroy (module_t *p)\n{\n    int e;\n    void *res;\n\n    if (!p)\n        return;\n\n    assert (p->magic == MODULE_MAGIC);\n\n    if (p->t) {\n        if ((e = pthread_join (p->t, &res)) != 0)\n            log_errn_exit (e, \"pthread_cancel\");\n    }\n\n    /* Send disconnect messages to services used by this module.\n     */\n    disconnect_destroy (p->disconnect);\n\n    flux_watcher_stop (p->broker_w);\n    flux_watcher_destroy (p->broker_w);\n    zsock_destroy (&p->sock);\n\n#ifndef __SANITIZE_ADDRESS__\n    dlclose (p->dso);\n#endif\n    free (p->digest);\n    free (p->argz);\n    free (p->name);\n    if (p->rmmod) {\n        flux_msg_t *msg;\n        while ((msg = zlist_pop (p->rmmod)))\n            flux_msg_destroy (msg);\n    }\n    flux_msg_destroy (p->insmod);\n    if (p->subs) {\n        char *s;\n        while ((s = zlist_pop (p->subs)))\n            free (s);\n        zlist_destroy (&p->subs);\n    }\n    zlist_destroy (&p->rmmod);\n    p->magic = ~MODULE_MAGIC;\n    free (p);\n}\n\n/* Send shutdown request, broker to module.\n */\nint module_stop (module_t *p)\n{\n    assert (p->magic == MODULE_MAGIC);\n    char *topic = NULL;\n    flux_future_t *f = NULL;\n    int rc = -1;\n\n    if (asprintf (&topic, \"%s.shutdown\", p->name) < 0)\n        goto done;\n    if (!(f = flux_rpc (p->broker_h, topic, NULL,\n                          FLUX_NODEID_ANY, FLUX_RPC_NORESPONSE)))\n        goto done;\n    rc = 0;\ndone:\n    free (topic);\n    flux_future_destroy (f);\n    return rc;\n}\n\nvoid module_mute (module_t *p)\n{\n    p->muted = true;\n}\n\nstatic void module_cb (flux_reactor_t *r, flux_watcher_t *w,\n                       int revents, void *arg)\n{\n    module_t *p = arg;\n    assert (p->magic == MODULE_MAGIC);\n    p->lastseen = heartbeat_get_epoch (p->heartbeat);\n    if (p->poller_cb)\n        p->poller_cb (p, p->poller_arg);\n}\n\nint module_start (module_t *p)\n{\n    assert (p->magic == MODULE_MAGIC);\n    int errnum;\n    int rc = -1;\n\n    flux_watcher_start (p->broker_w);\n    if ((errnum = pthread_create (&p->t, NULL, module_thread, p))) {\n        errno = errnum;\n        goto done;\n    }\n    rc = 0;\ndone:\n    return rc;\n}\n\nvoid module_set_args (module_t *p, int argc, char * const argv[])\n{\n    int e;\n\n    assert (p->magic == MODULE_MAGIC);\n    if (p->argz) {\n        free (p->argz);\n        p->argz_len = 0;\n    }\n    if (argv && (e = argz_create (argv, &p->argz, &p->argz_len)) != 0)\n        log_errn_exit (e, \"argz_create\");\n}\n\nvoid module_add_arg (module_t *p, const char *arg)\n{\n    int e;\n\n    assert (p->magic == MODULE_MAGIC);\n    if ((e = argz_add (&p->argz, &p->argz_len, arg)) != 0)\n        log_errn_exit (e, \"argz_add\");\n}\n\nvoid module_set_poller_cb (module_t *p, modpoller_cb_f cb, void *arg)\n{\n    assert (p->magic == MODULE_MAGIC);\n    p->poller_cb = cb;\n    p->poller_arg = arg;\n}\n\nvoid module_set_status_cb (module_t *p, module_status_cb_f cb, void *arg)\n{\n    assert (p->magic == MODULE_MAGIC);\n    p->status_cb = cb;\n    p->status_arg = arg;\n}\n\nvoid module_set_status (module_t *p, int new_status)\n{\n    assert (p->magic == MODULE_MAGIC);\n    assert (p->status != new_status);\n    assert (new_status != FLUX_MODSTATE_INIT);  /* illegal state transition */\n    assert (p->status != FLUX_MODSTATE_EXITED); /* illegal state transition */\n    int prev_status = p->status;\n    p->status = new_status;\n    if (p->status_cb)\n        p->status_cb (p, prev_status, p->status_arg);\n}\n\nint module_get_status (module_t *p)\n{\n    assert (p->magic == MODULE_MAGIC);\n    return p->status;\n}\n\nvoid module_set_errnum (module_t *p, int errnum)\n{\n    assert (p->magic == MODULE_MAGIC);\n    p->errnum = errnum;\n}\n\nint module_get_errnum (module_t *p)\n{\n    assert (p->magic == MODULE_MAGIC);\n    return p->errnum;\n}\n\nint module_push_rmmod (module_t *p, const flux_msg_t *msg)\n{\n    flux_msg_t *cpy = flux_msg_copy (msg, false);\n    if (!cpy)\n        return -1;\n    if (zlist_push (p->rmmod, cpy) < 0) {\n        errno = ENOMEM;\n        return -1;\n    }\n    return 0;\n}\n\nflux_msg_t *module_pop_rmmod (module_t *p)\n{\n    assert (p->magic == MODULE_MAGIC);\n    return zlist_pop (p->rmmod);\n}\n\n/* There can be only one.\n */\nint module_push_insmod (module_t *p, const flux_msg_t *msg)\n{\n    flux_msg_t *cpy = flux_msg_copy (msg, false);\n    if (!cpy)\n        return -1;\n    if (p->insmod)\n        flux_msg_destroy (p->insmod);\n    p->insmod = cpy;\n    return 0;\n}\n\nflux_msg_t *module_pop_insmod (module_t *p)\n{\n    assert (p->magic == MODULE_MAGIC);\n    flux_msg_t *msg = p->insmod;\n    p->insmod = NULL;\n    return msg;\n}\n\nmodule_t *module_add (modhash_t *mh, const char *path)\n{\n    module_t *p;\n    void *dso;\n    const char **mod_namep;\n    mod_main_f *mod_main;\n    zfile_t *zf;\n    int rc;\n\n    dlerror ();\n    if (!(dso = dlopen (path, RTLD_NOW | RTLD_GLOBAL | FLUX_DEEPBIND))) {\n        log_msg (\"%s\", dlerror ());\n        errno = ENOENT;\n        return NULL;\n    }\n    mod_main = dlsym (dso, \"mod_main\");\n    mod_namep = dlsym (dso, \"mod_name\");\n    if (!mod_main || !mod_namep || !*mod_namep) {\n        dlclose (dso);\n        errno = ENOENT;\n        return NULL;\n    }\n    if (!(p = calloc (1, sizeof (*p)))) {\n        dlclose (dso);\n        errno = ENOMEM;\n        return NULL;\n    }\n    p->magic = MODULE_MAGIC;\n    p->main = mod_main;\n    p->dso = dso;\n    if (!(p->name = strdup (*mod_namep))) {\n        errno = ENOMEM;\n        goto cleanup;\n    }\n    zf = zfile_new (NULL, path);\n    if (!(p->digest = strdup (zfile_digest (zf)))) {\n        errno = ENOMEM;\n        goto cleanup;\n    }\n    p->size = (int)zfile_cursize (zf);\n    zfile_destroy (&zf);\n    uuid_generate (p->uuid);\n    uuid_unparse (p->uuid, p->uuid_str);\n    if (!(p->rmmod = zlist_new ())) {\n        errno = ENOMEM;\n        goto cleanup;\n    }\n    if (!(p->subs = zlist_new ())) {\n        errno = ENOMEM;\n        goto cleanup;\n    }\n\n    p->rank = mh->rank;\n    p->broker_h = mh->broker_h;\n    p->heartbeat = mh->heartbeat;\n\n    /* Broker end of PAIR socket is opened here.\n     */\n    if (!(p->sock = zsock_new_pair (NULL))) {\n        log_err (\"zsock_new_pair\");\n        goto cleanup;\n    }\n    if (zsock_bind (p->sock, \"inproc://%s\", module_get_uuid (p)) < 0) {\n        log_err (\"zsock_bind inproc://%s\", module_get_uuid (p));\n        goto cleanup;\n    }\n    if (!(p->broker_w = flux_zmq_watcher_create (flux_get_reactor (p->broker_h),\n                                                 p->sock, FLUX_POLLIN,\n                                                 module_cb, p))) {\n        log_err (\"flux_zmq_watcher_create\");\n        goto cleanup;\n    }\n    /* Set creds for connection.\n     * Since this is a point to point connection between broker threads,\n     * credentials are always those of the instance owner.\n     */\n    p->cred.userid = getuid ();\n    p->cred.rolemask = FLUX_ROLE_OWNER;\n\n    /* Update the modhash.\n     */\n    rc = zhash_insert (mh->zh_byuuid, module_get_uuid (p), p);\n    assert (rc == 0); /* uuids are by definition unique */\n    zhash_freefn (mh->zh_byuuid, module_get_uuid (p),\n                  (zhash_free_fn *)module_destroy);\n    return p;\n\ncleanup:\n    module_destroy (p);\n    return NULL;\n}\n\nvoid module_remove (modhash_t *mh, module_t *p)\n{\n    assert (p->magic == MODULE_MAGIC);\n    zhash_delete (mh->zh_byuuid, module_get_uuid (p));\n}\n\nmodhash_t *modhash_create (void)\n{\n    modhash_t *mh = calloc (1, sizeof (*mh));\n    if (!mh) {\n        errno = ENOMEM;\n        return NULL;\n    }\n    if (!(mh->zh_byuuid = zhash_new ())) {\n        modhash_destroy (mh);\n        errno = ENOMEM;\n        return NULL;\n    }\n    return mh;\n}\n\nvoid modhash_destroy (modhash_t *mh)\n{\n    const char *uuid;\n    module_t *p;\n    int e;\n\n    if (mh) {\n        if (mh->zh_byuuid) {\n            FOREACH_ZHASH (mh->zh_byuuid, uuid, p) {\n                if (p->t) {\n                    if ((e = pthread_cancel (p->t)) != 0 && e != ESRCH)\n                        log_errn (e, \"pthread_cancel\");\n                }\n            }\n            zhash_destroy (&mh->zh_byuuid);\n        }\n        free (mh);\n    }\n}\n\nvoid modhash_set_rank (modhash_t *mh, uint32_t rank)\n{\n    mh->rank = rank;\n}\n\nvoid modhash_set_flux (modhash_t *mh, flux_t *h)\n{\n    mh->broker_h = h;\n}\n\nvoid modhash_set_heartbeat (modhash_t *mh, heartbeat_t *hb)\n{\n    mh->heartbeat = hb;\n}\n\njson_t *module_get_modlist (modhash_t *mh, struct service_switch *sw)\n{\n    json_t *mods = NULL;\n    zlist_t *uuids = NULL;\n    char *uuid;\n    module_t *p;\n\n    if (!(mods = json_array()))\n        goto nomem;\n    if (!(uuids = zhash_keys (mh->zh_byuuid)))\n        goto nomem;\n    uuid = zlist_first (uuids);\n    while (uuid) {\n        if ((p = zhash_lookup (mh->zh_byuuid, uuid))) {\n            json_t *svcs;\n            json_t *entry;\n\n            if (!(svcs  = service_list_byuuid (sw, uuid)))\n                goto nomem;\n            if (!(entry = json_pack (\"{s:s s:i s:s s:i s:i s:o}\",\n                                     \"name\", module_get_name (p),\n                                     \"size\", p->size,\n                                     \"digest\", p->digest,\n                                      \"idle\", module_get_idle (p),\n                                      \"status\", p->status,\n                                      \"services\", svcs))) {\n                json_decref (svcs);\n                goto nomem;\n            }\n            if (json_array_append_new (mods, entry) < 0) {\n                json_decref (entry);\n                goto nomem;\n            }\n        }\n        uuid = zlist_next (uuids);\n    }\n    zlist_destroy (&uuids);\n    return mods;\nnomem:\n    zlist_destroy (&uuids);\n    json_decref (mods);\n    errno = ENOMEM;\n    return NULL;\n}\n\nmodule_t *module_lookup (modhash_t *mh, const char *uuid)\n{\n    return zhash_lookup (mh->zh_byuuid, uuid);\n}\n\nmodule_t *module_lookup_byname (modhash_t *mh, const char *name)\n{\n    zlist_t *uuids;\n    char *uuid;\n    module_t *result = NULL;\n\n    if (!(uuids = zhash_keys (mh->zh_byuuid))) {\n        errno = ENOMEM;\n        return NULL;\n    }\n    uuid = zlist_first (uuids);\n    while (uuid) {\n        module_t *p = zhash_lookup (mh->zh_byuuid, uuid);\n        assert (p != NULL);\n        if (!strcmp (module_get_name (p), name)) {\n            result = p;\n            break;\n        }\n        uuid = zlist_next (uuids);\n        p = NULL;\n    }\n    zlist_destroy (&uuids);\n    return result;\n}\n\nint module_subscribe (modhash_t *mh, const char *uuid, const char *topic)\n{\n    module_t *p = zhash_lookup (mh->zh_byuuid, uuid);\n    char *cpy = NULL;\n    int rc = -1;\n\n    if (!p) {\n        errno = ENOENT;\n        goto done;\n    }\n    if (!(cpy = strdup (topic))) {\n        errno = ENOMEM;\n        goto done;\n    }\n    if (zlist_push (p->subs, cpy) < 0) {\n        free (cpy);\n        errno = ENOMEM;\n        goto done;\n    }\n    rc = 0;\ndone:\n    return rc;\n}\n\nint module_unsubscribe (modhash_t *mh, const char *uuid, const char *topic)\n{\n    module_t *p = zhash_lookup (mh->zh_byuuid, uuid);\n    char *s;\n    int rc = -1;\n\n    if (!p) {\n        errno = ENOENT;\n        goto done;\n    }\n    s = zlist_first (p->subs);\n    while (s) {\n        if (!strcmp (topic, s)) {\n            zlist_remove (p->subs, s);\n            free (s);\n            break;\n        }\n        s = zlist_next (p->subs);\n    }\n    rc = 0;\ndone:\n    return rc;\n}\n\nstatic bool match_sub (module_t *p, const char *topic)\n{\n    char *s = zlist_first (p->subs);\n\n    while (s) {\n        if (!strncmp (topic, s, strlen (s)))\n            return true;\n        s = zlist_next (p->subs);\n    }\n    return false;\n}\n\nint module_event_mcast (modhash_t *mh, const flux_msg_t *msg)\n{\n    const char *topic;\n    module_t *p;\n    int rc = -1;\n\n    if (flux_msg_get_topic (msg, &topic) < 0)\n        goto done;\n    p = zhash_first (mh->zh_byuuid);\n    while (p) {\n        if (match_sub (p, topic)) {\n            if (module_sendmsg (p, msg) < 0)\n                goto done;\n        }\n        p = zhash_next (mh->zh_byuuid);\n    }\n    rc = 0;\ndone:\n    return rc;\n}\n\nmodule_t *module_first (modhash_t *mh)\n{\n    return zhash_first (mh->zh_byuuid);\n}\n\nmodule_t *module_next (modhash_t *mh)\n{\n    return zhash_next (mh->zh_byuuid);\n}\n\n/*\n * vi:tabstop=4 shiftwidth=4 expandtab\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-i6dcpentpa3wkcp6mwcurdfsjksgyiyg/spack-src/src/broker/test/pmiutil.c": "/************************************************************\\\n * Copyright 2019 Lawrence Livermore National Security, LLC\n * (c.f. AUTHORS, NOTICE.LLNS, COPYING)\n *\n * This file is part of the Flux resource manager framework.\n * For details, see https://github.com/flux-framework.\n *\n * SPDX-License-Identifier: LGPL-3.0\n\\************************************************************/\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <stdlib.h>\n#include <string.h>\n\n#include \"src/common/libtap/tap.h\"\n#include \"src/common/libpmi/pmi.h\"\n\n#include \"pmiutil.h\"\n\nint main (int argc, char **argv)\n{\n    struct pmi_handle *pmi;\n    int result;\n    struct pmi_params params;\n    char val[64];\n\n    plan (NO_PLAN);\n\n    /* Enable some debug output on stderr.\n     */\n    (void)setenv (\"PMI_DEBUG\", \"1\", 1);\n\n    /* Force singleton (ours) by ensuring pmi_simple_client\n     * and dlopen will fail\n     */\n    (void)unsetenv (\"PMI_FD\");\n    (void)unsetenv (\"PMI_RANK\");\n    (void)unsetenv (\"PMI_FD\");\n    (void)setenv (\"PMI_LIBRARY\", \"/nope.so\", 1);\n\n    pmi = broker_pmi_create ();\n    ok (pmi != NULL,\n        \"broker_pmi_create() works (singleton)\");\n\n    result = broker_pmi_init (pmi);\n    ok (result == PMI_SUCCESS,\n        \"broker_pmi_init() works\");\n\n    memset (&params, 0, sizeof (params));\n    result = broker_pmi_get_params (pmi, &params);\n    ok (result == PMI_SUCCESS,\n        \"broker_pmi_get_params() works\");\n    ok (params.rank == 0 && params.size == 1,\n        \"rank=0 size=1\");\n    ok (strlen (params.kvsname) > 0,\n        \"kvsname is not the empty string\");\n    diag (\"kvsname=%s\", params.kvsname);\n\n    result = broker_pmi_kvs_put (pmi, params.kvsname, \"foo\", \"bar\");\n    ok (result == PMI_SUCCESS,\n        \"broker_pmi_kvs_put %s foo=bar works\", params.kvsname);\n\n    result = broker_pmi_barrier (pmi);\n    ok (result == PMI_SUCCESS,\n        \"broker_pmi_barrier works\");\n\n    result = broker_pmi_kvs_get (pmi, params.kvsname, \"foo\", val, sizeof (val));\n    ok (result != PMI_SUCCESS,\n        \"broker_pmi_kvs_get fails since singleton doesn't implement kvs\");\n    // at least while we can get away without it!\n\n    result = broker_pmi_finalize (pmi);\n    ok (result == PMI_SUCCESS,\n        \"broker_pmi_finalize() works\");\n\n    broker_pmi_destroy (pmi);\n    done_testing ();\n    return 0;\n}\n\n/*\n * vi:ts=4 sw=4 expandtab\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-i6dcpentpa3wkcp6mwcurdfsjksgyiyg/spack-src/t/valgrind/valgrind.supp": "{\n   <socketcall_sendto>\n   Memcheck:Param\n   socketcall.sendto(msg)\n   fun:send\n   ...\n}\n{\n   <socketcall_sendto>\n   Memcheck:Param\n   socketcall.send(msg)\n   fun:send\n   ...\n}\n{\n   <libev_io_start_realloc>\n   Memcheck:Leak\n   fun:malloc\n   fun:realloc\n   fun:ev_realloc\n   fun:fd_change\n   fun:ev_io_start\n   fun:ev_invoke_pending\n   fun:ev_run\n   ...\n}\n{\n   <libltdl_known_leak>\n   Memcheck:Leak\n   fun:malloc\n   fun:lt__malloc\n   fun:lt__zalloc\n   obj:*/libltdl.so.7.3.1\n   fun:lt_dlopenadvise\n   ...\n}\n{\n   <list_node_alloc>\n   Memcheck:Leak\n   fun:malloc\n   fun:list_alloc_aux\n   ...\n   fun:list_node_create\n   ...\n}\n{\n   <ipaddr_getprimary>\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:gaih_inet.constprop.5\n   fun:getaddrinfo\n   fun:ipaddr_getprimary\n   ...\n}\n{\n   <libdl_lookup_symbol_x>\n   Memcheck:Addr8\n   fun:do_lookup_x\n   obj:*\n   fun:_dl_lookup_symbol_x\n}\n{\n   <issue_1897>\n   Memcheck:Addr1\n   fun:ev_run\n   fun:flux_reactor_run\n   ...\n}\n{\n   <issue_2223>\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:malloc\n   fun:dl_open_worker\n   fun:_dl_catch_*\n   fun:_dl_open\n   ...\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-i6dcpentpa3wkcp6mwcurdfsjksgyiyg/spack-src/t/module/parent.c": "/************************************************************\\\n * Copyright 2014 Lawrence Livermore National Security, LLC\n * (c.f. AUTHORS, NOTICE.LLNS, COPYING)\n *\n * This file is part of the Flux resource manager framework.\n * For details, see https://github.com/flux-framework.\n *\n * SPDX-License-Identifier: LGPL-3.0\n\\************************************************************/\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <libgen.h>\n#include <dlfcn.h>\n#include <argz.h>\n#include <flux/core.h>\n#include <czmq.h>\n#include <jansson.h>\n\n#include \"src/common/libutil/xzmalloc.h\"\n#include \"src/common/libutil/log.h\"\n#include \"src/common/libutil/oom.h\"\n\ntypedef struct {\n    char *name;\n    int size;\n    char *digest;\n    int idle;\n    int status;\n    void *dso;\n    mod_main_f *main;\n} module_t;\n\nstatic zhash_t *modules = NULL;\nstatic uint32_t rank;\n\n/* Calculate file digest using zfile() class from czmq.\n * Caller must free.\n */\nchar *digest (const char *path)\n{\n    zfile_t *zf = zfile_new (NULL, path);\n    char *digest = NULL;\n    if (zf)\n        digest = xstrdup (zfile_digest (zf));\n    zfile_destroy (&zf);\n    return digest;\n}\n\nstatic void module_destroy (module_t *m)\n{\n    if (m->name)\n        free (m->name);\n    if (m->digest)\n        free (m->digest);\n    if (m->dso)\n        dlclose (m->dso);\n    free (m);\n}\n\nstatic module_t *module_create (const char *path, char *argz, size_t argz_len)\n{\n    module_t *m = xzmalloc (sizeof (*m));\n    struct stat sb;\n    char **av = NULL;\n\n    if (stat (path, &sb) < 0 || !(m->name = flux_modname (path, NULL, NULL))\n                             || !(m->digest = digest (path))) {\n        module_destroy (m);\n        errno = ESRCH;\n        return NULL;\n    }\n    m->size = sb.st_size;\n    m->dso = dlopen (path, RTLD_NOW | RTLD_LOCAL);\n    if (!m->dso || !(m->main = dlsym (m->dso, \"mod_main\"))) {\n        module_destroy (m);\n        errno = EINVAL;\n        return NULL;\n    }\n    av = xzmalloc (sizeof (av[0]) * (argz_count (argz, argz_len) + 1));\n    argz_extract (argz, argz_len, av);\n    if (m->main (NULL, argz_count (argz, argz_len), av) < 0) {\n        module_destroy (m);\n        errno = EINVAL;\n        return NULL;\n    }\n    if (zhash_lookup (modules, m->name)) {\n        module_destroy (m);\n        errno = EEXIST;\n        return NULL;\n    }\n    zhash_update (modules, m->name, m);\n    zhash_freefn (modules, m->name, (zhash_free_fn *)module_destroy);\n    if (av)\n        free (av);\n    return m;\n}\n\n/* N.B. services is hardwired to test1,test2,testN, where N is the local\n * broker rank.  This is a specific setup for the flux-module test.  This\n * base component does not perform message routing to its extension modules.\n */\nstatic json_t *module_list (void)\n{\n    json_t *mods;\n    zlist_t *keys;\n    module_t *m;\n    char *name;\n    char rankstr[16];\n    int n;\n\n    if (!(mods = json_array ()))\n        oom ();\n    if (!(keys = zhash_keys (modules)))\n        oom ();\n    name = zlist_first (keys);\n    n = snprintf (rankstr, sizeof (rankstr), \"rank%d\", (int)rank);\n    assert (n < sizeof (rankstr));\n    while (name) {\n        json_t *o;\n        m = zhash_lookup (modules, name);\n        if (!(o = json_pack (\"{s:s s:i s:s s:i s:i s:[s,s,s]}\",\n                             \"name\", m->name,\n                             \"size\", m->size,\n                             \"digest\", m->digest,\n                             \"idle\", m->idle,\n                             \"status\", m->status,\n                             \"services\", \"test1\", \"test2\", rankstr)))\n            oom ();\n        if (json_array_append_new (mods, o) < 0)\n            oom ();\n        name = zlist_next (keys);\n    }\n    zlist_destroy (&keys);\n    return mods;\n}\n\nstatic void insmod_request_cb (flux_t *h, flux_msg_handler_t *mh,\n                               const flux_msg_t *msg, void *arg)\n{\n    const char *path;\n    json_t *args;\n    size_t index;\n    json_t *value;\n    char *argz = NULL;\n    size_t argz_len = 0;\n    module_t *m = NULL;\n    error_t e;\n\n    if (flux_request_unpack (msg, NULL, \"{s:s s:o}\", \"path\", &path,\n                                                     \"args\", &args) < 0)\n        goto error;\n    if (!json_is_array (args))\n        goto proto;\n    json_array_foreach (args, index, value) {\n        if (!json_is_string (value))\n            goto proto;\n        if ((e = argz_add (&argz, &argz_len, json_string_value (value)))) {\n            errno = e;\n            goto error;\n        }\n    }\n    if (!(m = module_create (path, argz, argz_len)))\n        goto error;\n    flux_log (h, LOG_DEBUG, \"insmod %s\", m->name);\n    if (flux_respond (h, msg, NULL) < 0)\n        flux_log_error (h, \"%s: flux_respond\", __FUNCTION__);\n    free (argz);\n    return;\nproto:\n    errno = EPROTO;\nerror:\n    if (flux_respond_error (h, msg, errno, NULL) < 0)\n        flux_log_error (h, \"%s: flux_respond_error\", __FUNCTION__);\n    free (argz);\n}\n\nstatic void rmmod_request_cb (flux_t *h, flux_msg_handler_t *mh,\n                              const flux_msg_t *msg, void *arg)\n{\n    const char *name;\n\n    if (flux_request_unpack (msg, NULL, \"{s:s}\", \"name\", &name) < 0)\n        goto error;\n    if (!zhash_lookup (modules, name)) {\n        errno = ENOENT;\n        goto error;\n    }\n    zhash_delete (modules, name);\n    flux_log (h, LOG_DEBUG, \"rmmod %s\", name);\n    if (flux_respond (h, msg, NULL) < 0)\n        flux_log_error (h, \"%s: flux_respond\", __FUNCTION__);\n    return;\nerror:\n    if (flux_respond_error (h, msg, errno, NULL) < 0)\n        flux_log_error (h, \"%s: flux_respond_error\", __FUNCTION__);\n}\n\nstatic void lsmod_request_cb (flux_t *h, flux_msg_handler_t *mh,\n                              const flux_msg_t *msg, void *arg)\n{\n    json_t *mods = NULL;\n\n    if (flux_request_decode (msg, NULL, NULL) < 0)\n        goto error;\n    mods = module_list ();\n    if (flux_respond_pack (h, msg, \"{s:O}\", \"mods\", mods) < 0)\n        flux_log_error (h, \"%s: flux_respond\", __FUNCTION__);\n    json_decref (mods);\n    return;\nerror:\n    if (flux_respond_error (h, msg, errno, NULL) < 0)\n        flux_log_error (h, \"%s: flux_respond_error\", __FUNCTION__);\n}\n\nconst struct flux_msg_handler_spec htab[] = {\n    { FLUX_MSGTYPE_REQUEST, \"parent.insmod\",         insmod_request_cb, 0 },\n    { FLUX_MSGTYPE_REQUEST, \"parent.rmmod\",          rmmod_request_cb, 0 },\n    { FLUX_MSGTYPE_REQUEST, \"parent.lsmod\",          lsmod_request_cb, 0 },\n    FLUX_MSGHANDLER_TABLE_END,\n};\n\nint mod_main (flux_t *h, int argc, char **argv)\n{\n    int saved_errno;\n    flux_msg_handler_t **handlers = NULL;\n\n    if (argc == 1 && !strcmp (argv[0], \"--init-failure\")) {\n        flux_log (h, LOG_INFO, \"aborting during init per test request\");\n        errno = EIO;\n        goto error;\n    }\n    if (!(modules = zhash_new ())) {\n        errno = ENOMEM;\n        goto error;\n    }\n    if (flux_get_rank (h, &rank) < 0)\n        goto error;\n    if (flux_msg_handler_addvec (h, htab, NULL, &handlers) < 0)\n        goto error;\n    if (flux_reactor_run (flux_get_reactor (h), 0) < 0) {\n        flux_log_error (h, \"flux_reactor_run\");\n        goto error;\n    }\n    zhash_destroy (&modules);\n    return 0;\nerror:\n    saved_errno = errno;\n    flux_msg_handler_delvec (handlers);\n    zhash_destroy (&modules);\n    errno = saved_errno;\n    return -1;\n}\n\nMOD_NAME (\"parent\");\n\n/*\n * vi:tabstop=4 shiftwidth=4 expandtab\n */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-i6dcpentpa3wkcp6mwcurdfsjksgyiyg/spack-src/src/broker/doc/states_norm.png",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-i6dcpentpa3wkcp6mwcurdfsjksgyiyg/spack-src/src/broker/doc/states.png",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-i6dcpentpa3wkcp6mwcurdfsjksgyiyg/spack-src/.git/objects/pack/pack-0dd6b93d268efcd9904d232a6dad97a1bce584da.idx",
        "/tmp/vanessa/spack-stage/spack-stage-flux-core-master-i6dcpentpa3wkcp6mwcurdfsjksgyiyg/spack-src/.git/objects/pack/pack-0dd6b93d268efcd9904d232a6dad97a1bce584da.pack"
    ],
    "total_files": 1599
}