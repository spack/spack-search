{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-aspect-2.0.0-aniuibxz3qshx5jcypy7ncvhlztpqfat/spack-src/CMakeLists.txt": "# Copyright (C) 2013 - 2018 by the authors of the ASPECT code.\n#\n# This file is part of ASPECT.\n#\n# ASPECT is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2, or (at your option)\n# any later version.\n#\n# ASPECT is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with ASPECT; see the file doc/COPYING.  If not see\n# <http://www.gnu.org/licenses/>.\n\n\nMESSAGE(STATUS \"====================================================\")\nMESSAGE(STATUS \"============ Configuring ASPECT ====================\")\nMESSAGE(STATUS \"====================================================\")\n\n# Set the name of the project and target:\nSET(TARGET \"aspect\")\n\nFILE(GLOB_RECURSE TARGET_SRC  \"source/*.cc\" \"include/*.h\")\nINCLUDE_DIRECTORIES(include ${CMAKE_BINARY_DIR}/include)\n\nCMAKE_MINIMUM_REQUIRED(VERSION 2.8.8)\n\nLIST(APPEND CMAKE_MODULE_PATH\n  ${CMAKE_SOURCE_DIR}\n  )\n\nFIND_PACKAGE(deal.II 8.5.0 QUIET\n  HINTS ${deal.II_DIR} ${DEAL_II_DIR} ../ ../../ $ENV{DEAL_II_DIR}\n  )\nIF(NOT ${deal.II_FOUND})\n  MESSAGE(FATAL_ERROR \"\\n*** Could not find a suitably recent version of deal.II. ***\\n\"\n    \"You may want to either pass a flag -DDEAL_II_DIR=/path/to/deal.II to cmake \"\n    \"or set an environment variable \\\"DEAL_II_DIR\\\" that contains a path to a \"\n    \"sufficiently recent version of deal.II.\"\n    )\nENDIF()\n\nMESSAGE(STATUS \"Found deal.II version ${DEAL_II_PACKAGE_VERSION} at '${deal.II_DIR}'\")\n\nSET(ASPECT_USE_PETSC OFF CACHE BOOL \"Use PETSc instead of Trilinos if set to 'on'.\")\n\nMESSAGE(STATUS \"Using ASPECT_USE_PETSC = '${ASPECT_USE_PETSC}'\")\n\nSET(_DEALII_GOOD ON)\n\nIF(ASPECT_USE_PETSC AND NOT DEAL_II_WITH_PETSC)\n    MESSAGE(SEND_ERROR\n      \"\\n-- deal.II was built without support for PETSc!\\n\"\n      )\n    SET(_DEALII_GOOD OFF)\nENDIF()\n\nIF(NOT DEAL_II_WITH_P4EST)\n    MESSAGE(SEND_ERROR\n      \"\\n-- deal.II was built without support for p4est!\\n\"\n      )\n    SET(_DEALII_GOOD OFF)\nENDIF()\n\nIF(NOT ASPECT_USE_PETSC AND NOT DEAL_II_WITH_TRILINOS)\n    MESSAGE(SEND_ERROR\n      \"\\n-- deal.II was built without support for Trilinos!\\n\"\n      )\n    SET(_DEALII_GOOD OFF)\nENDIF()\n\nIF (NOT _DEALII_GOOD)\n  MESSAGE(FATAL_ERROR\n    \"\\nASPECT requires a deal.II installation built with support for Trilinos/PETSc and p4est but one or both of these appears to be missing!\\n\"\n    )\nENDIF()\n\nDEAL_II_INITIALIZE_CACHED_VARIABLES()\nPROJECT(${TARGET})\n\nIF (ASPECT_USE_PETSC)\nFOREACH(_source_file ${TARGET_SRC})\n  SET_PROPERTY(SOURCE ${_source_file}\n    APPEND PROPERTY COMPILE_DEFINITIONS ASPECT_USE_PETSC=\"1\")\nENDFOREACH()\nENDIF()\n\n\n# Pass down the source directory to the sources. This can be used\n# to hard-code the location of data files, such as in\n# $ASPECT_SOURCE_DIR/data/velocity-boundary-conditions/gplates/*\nFOREACH(_source_file ${TARGET_SRC})\n  SET_PROPERTY(SOURCE ${_source_file}\n    APPEND PROPERTY COMPILE_DEFINITIONS ASPECT_SOURCE_DIR=\"${CMAKE_SOURCE_DIR}\")\nENDFOREACH()\n\n\n\n# load in version info and export it\nFILE(STRINGS \"${CMAKE_SOURCE_DIR}/VERSION\" ASPECT_PACKAGE_VERSION LIMIT_COUNT 1)\n\nINCLUDE(${CMAKE_SOURCE_DIR}/cmake/macro_aspect_query_git_information.cmake)\nASPECT_QUERY_GIT_INFORMATION(\"ASPECT\")\nCONFIGURE_FILE(${CMAKE_SOURCE_DIR}/include/aspect/revision.h.in ${CMAKE_BINARY_DIR}/include/aspect/revision.h @ONLY)\n\nINCLUDE(CMakePackageConfigHelpers)\nWRITE_BASIC_PACKAGE_VERSION_FILE(\n  \"${CMAKE_BINARY_DIR}/AspectConfigVersion.cmake\"\n  VERSION ${ASPECT_PACKAGE_VERSION}\n  COMPATIBILITY AnyNewerVersion\n)\n\n# Configure a cmake fragment that plugins can use to\n# set up compiler flags, include paths, etc to compile an\n# Aspect plugin.\n# Config for the build dir:\nSET(CONFIG_INCLUDE_DIRS \"${CMAKE_SOURCE_DIR}/include\")\nSET(CONFIG_DIR \"${CMAKE_BINARY_DIR}\")\nCONFIGURE_FILE(\n  ${CMAKE_SOURCE_DIR}/cmake/AspectConfig.cmake.in\n  ${CMAKE_BINARY_DIR}/AspectConfig.cmake\n  @ONLY\n)\n# Config for the install dir:\nSET(CONFIG_INCLUDE_DIRS \"${CMAKE_INSTALL_PREFIX}/include\")\nSET(CONFIG_DIR \"${CMAKE_INSTALL_PREFIX}/bin\")\nCONFIGURE_FILE(\n  ${CMAKE_SOURCE_DIR}/cmake/AspectConfig.cmake.in\n  ${CMAKE_BINARY_DIR}/forinstall/AspectConfig.cmake\n  @ONLY\n)\n\n\n# Next, set up the testsuite\n\nSET(ASPECT_RUN_ALL_TESTS OFF CACHE BOOL \"Set up complete test suite to run.\")\nSET(ASPECT_COMPARE_TEST_RESULTS ON CACHE BOOL \"Compare test results with high accuracy.\")\n\nCONFIGURE_FILE(\n  ${CMAKE_SOURCE_DIR}/tests/cmake/CTestCustom.ctest.in\n  ${CMAKE_BINARY_DIR}/CTestCustom.ctest\n  @ONLY\n)\nCONFIGURE_FILE(\n  ${CMAKE_SOURCE_DIR}/tests/cmake/print_test_info.sh\n  ${CMAKE_BINARY_DIR}/print_test_info.sh\n  @ONLY\n)\n\nADD_CUSTOM_TARGET(setup_tests\n  COMMAND ${CMAKE_COMMAND} -D ASPECT_RUN_ALL_TESTS=ON -D PRINT_TEST_SUMMARY_AS_IMPORTANT=ON . >/dev/null\n  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}\n  COMMENT \"Enabling all tests ...\")\n\nSET(ASPECT_TEST_GENERATOR \"Unix Makefiles\" CACHE STRING \n  \"Generator to use for the test cmake project. Using ninja instead of make is not recommended.\")\n\nIF(EXISTS ${CMAKE_SOURCE_DIR}/tests/CMakeLists.txt)\n  FILE(WRITE ${CMAKE_BINARY_DIR}/CTestTestfile.cmake \"SUBDIRS(tests)\")\n\n  FILE(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/tests)\n\n  SET(aspect_binary ${CMAKE_BINARY_DIR}/aspect)\n\n  MESSAGE(STATUS \"Setting up test project, see tests/setup_tests.log for details.\")\n  EXECUTE_PROCESS(\n    COMMAND ${CMAKE_COMMAND} -G ${ASPECT_TEST_GENERATOR}\n\t-D ASPECT_RUN_ALL_TESTS=${ASPECT_RUN_ALL_TESTS}\n\t-D ASPECT_COMPARE_TEST_RESULTS=${ASPECT_COMPARE_TEST_RESULTS}\n\t-D ASPECT_DIR=${CMAKE_BINARY_DIR}\n\t-D CMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}\n\t-D ASPECT_BINARY=${aspect_binary}\n\t${CMAKE_CURRENT_SOURCE_DIR}/tests\n    OUTPUT_FILE setup_tests.log\n    RESULT_VARIABLE test_cmake_result\n    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/tests\n   )\n  IF(NOT test_cmake_result EQUAL 0)\n    MESSAGE(FATAL_ERROR \"ERROR: Test project could not be configured.\")\n  ENDIF()\n\n\n  IF(POLICY CMP0037)\n    # allow to override \"test\" target\n    CMAKE_POLICY(SET CMP0037 OLD)\n  ENDIF()\n\n  ADD_CUSTOM_TARGET(test\n    COMMAND ${CMAKE_COMMAND} --build . --target test\n    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/tests\n    DEPENDS aspect\n    COMMENT \"Running tests ...\")\n\nENDIF()\n\n\nADD_CUSTOM_TARGET(generate_reference_output\n  COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/cmake/generate_reference_output.sh\n  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})\n\n\n# Provide \"indent\" target for indenting all headers and source files\nADD_CUSTOM_TARGET(indent\n  WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}\n  COMMAND ./doc/indent\n  COMMENT \"Indenting all ASPECT header and source files...\"\n  )\n\n\n# Depending on whether we link statically or allow for shared libs,\n# we can or can not load plugins via external shared libs. Pass this\n# down during compilation so we can disable it in the code\nSET(ASPECT_USE_SHARED_LIBS ON CACHE BOOL \"If ON, we support loading shared plugin files.\")\nIF (DEAL_II_STATIC_EXECUTABLE STREQUAL \"ON\")\n  MESSAGE(STATUS \"Creating a statically linked executable\")\n  SET(ASPECT_USE_SHARED_LIBS OFF CACHE BOOL \"\" FORCE)\nENDIF()\n\nINCLUDE (CheckCXXSourceCompiles)\n\nSET(_backup_libs ${CMAKE_REQUIRED_LIBRARIES})\nLIST(APPEND CMAKE_REQUIRED_LIBRARIES ${CMAKE_DL_LIBS})\nCHECK_CXX_SOURCE_COMPILES(\"\n#include <cstddef>\n#include <dlfcn.h>\n\nint main()\n{\n  void *handle = dlopen (\\\"somelib.so\\\", RTLD_LAZY);\n  return handle == NULL || dlerror();\n}\n\" HAVE_DLOPEN)\nSET(CMAKE_REQUIRED_LIBRARIES ${_backup_libs})\n\nIF (NOT HAVE_DLOPEN)\n  MESSAGE(STATUS \"dlopen() test failed, disabling dynamic plugin loading\")\n  SET(ASPECT_USE_SHARED_LIBS OFF CACHE BOOL \"\" FORCE)\nENDIF()\n\nIF (ASPECT_USE_SHARED_LIBS)\n  MESSAGE(STATUS \"Enabling dynamic loading of plugins from the input file\")\n  FOREACH(_source_file ${TARGET_SRC})\n    SET_PROPERTY(SOURCE ${_source_file}\n      APPEND PROPERTY COMPILE_DEFINITIONS ASPECT_USE_SHARED_LIBS=1)\n  ENDFOREACH()\nELSE()\n  MESSAGE(STATUS \"Disabling dynamic loading of plugins from the input file\")\n  FOREACH(_source_file ${TARGET_SRC})\n    SET_PROPERTY(SOURCE ${_source_file}\n      APPEND PROPERTY COMPILE_DEFINITIONS ASPECT_USE_SHARED_LIBS=0)\n  ENDFOREACH()\nENDIF()\n\n# See whether we can verify that every plugin we load is compiled against\n# the same deal.II library\nSET(ASPECT_HAVE_LINK_H ON CACHE BOOL \"If ON, link.h exists and is usable.\")\nINCLUDE (CheckIncludeFiles)\nCHECK_INCLUDE_FILES (\"link.h\" _HAVE_LINK_H)\nIF (NOT _HAVE_LINK_H)\n  SET(ASPECT_HAVE_LINK_H OFF CACHE BOOL \"\" FORCE)\nENDIF()\nIF (ASPECT_HAVE_LINK_H)\n  MESSAGE(STATUS \"Enabling checking of compatible deal.II library when loading plugins\")\n  FOREACH(_source_file ${TARGET_SRC})\n    SET_PROPERTY(SOURCE ${_source_file}\n      APPEND PROPERTY COMPILE_DEFINITIONS ASPECT_HAVE_LINK_H=1)\n  ENDFOREACH()\nENDIF()\n\n# Check if we want to use cotire to precompile header files and prepare a\n# unity build target. This speeds up compile time, but can fail on some\n# machines, therefore it is disabled by default.\nSET(ASPECT_PRECOMPILE_HEADERS OFF CACHE BOOL \"Precompile external header files using cotire to speedup compile time.\")\n\nIF (ASPECT_PRECOMPILE_HEADERS)\n# For the unity build we need to compile helper_functions.cc before core.cc\n# ensure this by reordering the files\n  FIND_FILE(HELPER_PATH helper_functions.cc HINTS \"${CMAKE_SOURCE_DIR}/source/simulator\")\n  LIST(REMOVE_ITEM TARGET_SRC ${HELPER_PATH})\n  LIST(INSERT TARGET_SRC 0 ${HELPER_PATH})\nENDIF()\n\n\nDEAL_II_INVOKE_AUTOPILOT()\n\n\nIF (ASPECT_USE_SHARED_LIBS)\n  # some systems need to explicitly link to some libraries to use dlopen\n  TARGET_LINK_LIBRARIES(aspect ${CMAKE_DL_LIBS})\nENDIF()\n\n\n\n# Check if we can raise floating point exceptions.\n#\n# Note that some library we link with in ASPECT on some platforms will trigger\n# floating point exceptions when converting -numeric_limits<double>::max to a\n# string. The only thing we can do is a configure check and disable the\n# exceptions. This is done here:\nSET(ASPECT_USE_FP_EXCEPTIONS ON CACHE BOOL \"If ON, floating point exception are raised in debug mode.\")\n\n# Clang 6.0 throws random floating point exceptions, which we could not\n# track down. Disable the exceptions for now.\nIF(\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"Clang\" AND NOT CMAKE_CXX_COMPILER_VERSION VERSION_LESS 6.0.0)\n  SET(ASPECT_USE_FP_EXCEPTIONS OFF CACHE BOOL \"\" FORCE)\nENDIF()\n\nIF (ASPECT_USE_FP_EXCEPTIONS)\n  INCLUDE(${CMAKE_SOURCE_DIR}/cmake/fpe_check.cmake)\n\n  IF (HAVE_FP_EXCEPTIONS)\n    MESSAGE(STATUS \"Runtime floating point checks enabled.\")\n    FOREACH(_source_file ${TARGET_SRC})\n      SET_PROPERTY(SOURCE ${_source_file}\n        APPEND PROPERTY COMPILE_DEFINITIONS ASPECT_USE_FP_EXCEPTIONS=1)\n    ENDFOREACH()\n  ELSE()\n    SET(ASPECT_USE_FP_EXCEPTIONS OFF CACHE BOOL \"\" FORCE)\n    MESSAGE(STATUS \"No support for feenableexcept(), disabling runtime floating point exception checks.\")\n  ENDIF()\nENDIF()\n\nIF (ASPECT_PRECOMPILE_HEADERS)\n  MESSAGE(STATUS \"Enabling cotire to precompile external header files.\")\n  INCLUDE(cmake/cotire)\n\n  # Set some properties that are necessary for the header precompilations \n  # and unity build to pass. We need to exclude some headers that\n  # frequently cause problems, and undefine some macros between source \n  # files that would otherwise interfere with each other.\n  SET_TARGET_PROPERTIES (aspect PROPERTIES\n      COTIRE_PREFIX_HEADER_IGNORE_PATH\n      \"/usr/include/;${CMAKE_SOURCE_DIR};${CMAKE_BINARY_DIR}\")\n  SET_SOURCE_FILES_PROPERTIES (${TARGET_SRC} PROPERTIES\n      COTIRE_UNITY_SOURCE_POST_UNDEFS \"INSTANTIATE\")\n\n  # This line activates the cotire module for the aspect target, \n  # and therefore the whole precompilation\n  cotire(aspect)\nELSE()\n  MESSAGE(STATUS \"Disabling cotire.\")\nENDIF()\n\n# Find the deal.II parameter GUI and install helper script\nFIND_PROGRAM(PARAMETER_GUI_EXECUTABLE\n\tparameter_gui\n\tHINTS $ENV{PARAMETER_GUI_DIR} $ENV{PARAMETER_GUI_DIR}/bin ${PARAMETER_GUI_DIR} ${PARAMETER_GUI_DIR}/bin\n\tPATH bin)\nMARK_AS_ADVANCED(CLEAR PARAMETER_GUI_EXECUTABLE)\n\n# did the user specify something that doesn't exist?\nIF (PARAMETER_GUI_EXECUTABLE \n\tAND\n    (NOT EXISTS ${PARAMETER_GUI_EXECUTABLE} OR IS_DIRECTORY ${PARAMETER_GUI_EXECUTABLE}))\n  MESSAGE(STATUS \"Warning: PARAMETER_GUI_EXECUTABLE '${PARAMETER_GUI_EXECUTABLE}' does not exist\")\n  SET(PARAMETER_GUI_EXECUTABLE \"PARAMETER_GUI_EXECUTABLE-NOTFOUND\" CACHE FILEPATH \"\" FORCE)\nENDIF()\n\nIF (NOT PARAMETER_GUI_EXECUTABLE)\n  MESSAGE(STATUS \"Parameter GUI not found: install and provide a hint using -D PARAMETER_GUI_DIR or set -D PARAMETER_GUI_EXECUTABLE directly.\")\nELSE()\n  MESSAGE(STATUS \"Found parameter GUI at: ${PARAMETER_GUI_EXECUTABLE}\")\n  CONFIGURE_FILE(\n  ${CMAKE_SOURCE_DIR}/doc/aspect-gui\n  ${CMAKE_BINARY_DIR}/aspect-gui\n  @ONLY\n  )\nINSTALL(FILES ${CMAKE_BINARY_DIR}/aspect-gui\n\tDESTINATION bin\n\tPERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ\n\t\tGROUP_READ GROUP_EXECUTE\n\t\tWORLD_READ WORLD_EXECUTE)\nENDIF()\n\n#\n## installation\n#\n# binary:\nINSTALL(TARGETS aspect\n  RUNTIME DESTINATION bin\n  COMPONENT runtime)\n\n# make sure we have the rpath to our dependencies set:\nSET_PROPERTY(TARGET aspect PROPERTY INSTALL_RPATH_USE_LINK_PATH TRUE)\n\n# headers:\nINSTALL(DIRECTORY include/ \n  DESTINATION include\n  COMPONENT includes\n  FILES_MATCHING PATTERN \"*.h\")\n\n# cmake stuff:\nINSTALL(FILES ${CMAKE_BINARY_DIR}/forinstall/AspectConfig.cmake ${CMAKE_BINARY_DIR}/AspectConfigVersion.cmake\n\tDESTINATION \"lib/cmake/Aspect/\")\n\nINSTALL(FILES ${CMAKE_BINARY_DIR}/include/aspect/revision.h DESTINATION \"include/aspect/\")\n\nMESSAGE(STATUS \"Writing config into detailed.log...\")\nINCLUDE(cmake/write_config)\n",
        "/tmp/vanessa/spack-stage/spack-stage-aspect-2.0.0-aniuibxz3qshx5jcypy7ncvhlztpqfat/spack-src/source/main.cc": "/*\n  Copyright (C) 2011 - 2018 by the authors of the ASPECT code.\n\n  This file is part of ASPECT.\n\n  ASPECT is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation; either version 2, or (at your option)\n  any later version.\n\n  ASPECT is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with ASPECT; see the file LICENSE.  If not see\n  <http://www.gnu.org/licenses/>.\n*/\n\n\n#include <aspect/simulator.h>\n#include <aspect/utilities.h>\n\n#include <deal.II/base/utilities.h>\n#include <deal.II/base/mpi.h>\n#include <deal.II/base/multithread_info.h>\n#include <deal.II/base/revision.h>\n#include <csignal>\n#include <string>\n\n#ifdef DEBUG\n#ifdef ASPECT_USE_FP_EXCEPTIONS\n#include <fenv.h>\n#endif\n#endif\n\n#if ASPECT_USE_SHARED_LIBS==1\n#  include <dlfcn.h>\n#  ifdef ASPECT_HAVE_LINK_H\n#    include <link.h>\n#  endif\n#endif\n\n\n\n// get the value of a particular parameter from the contents of the input\n// file. return an empty string if not found\nstd::string\nget_last_value_of_parameter(const std::string &parameters,\n                            const std::string &parameter_name)\n{\n  std::string return_value;\n\n  std::istringstream x_file(parameters);\n  while (x_file)\n    {\n      // get one line and strip spaces at the front and back\n      std::string line;\n      std::getline(x_file, line);\n      while ((line.size() > 0) && (line[0] == ' ' || line[0] == '\\t'))\n        line.erase(0, 1);\n      while ((line.size() > 0)\n             && (line[line.size() - 1] == ' ' || line[line.size() - 1] == '\\t'))\n        line.erase(line.size() - 1, std::string::npos);\n      // now see whether the line starts with 'set' followed by multiple spaces\n      // if not, try next line\n      if (line.size() < 4)\n        continue;\n\n      if ((line[0] != 's') || (line[1] != 'e') || (line[2] != 't')\n          || !(line[3] == ' ' || line[3] == '\\t'))\n        continue;\n\n      // delete the \"set \" and then delete more spaces if present\n      line.erase(0, 4);\n      while ((line.size() > 0) && (line[0] == ' ' || line[0] == '\\t'))\n        line.erase(0, 1);\n      // now see whether the next word is the word we look for\n      if (line.find(parameter_name) != 0)\n        continue;\n\n      line.erase(0, parameter_name.size());\n      while ((line.size() > 0) && (line[0] == ' ' || line[0] == '\\t'))\n        line.erase(0, 1);\n\n      // we'd expect an equals size here\n      if ((line.size() < 1) || (line[0] != '='))\n        continue;\n\n      // remove comment\n      std::string::size_type pos = line.find('#');\n      if (pos != std::string::npos)\n        line.erase (pos);\n\n      // trim the equals sign at the beginning and possibly following spaces\n      // as well as spaces at the end\n      line.erase(0, 1);\n      while ((line.size() > 0) && (line[0] == ' ' || line[0] == '\\t'))\n        line.erase(0, 1);\n      while ((line.size() > 0) && (line[line.size()-1] == ' ' || line[line.size()-1] == '\\t'))\n        line.erase(line.size()-1, std::string::npos);\n\n      // the rest should now be what we were looking for\n      return_value = line;\n    }\n\n  return return_value;\n}\n\n\n// extract the dimension in which to run ASPECT from the\n// the contents of the parameter file. this is something that\n// we need to do before processing the parameter file since we\n// need to know whether to use the dim=2 or dim=3 instantiation\n// of the main classes\nunsigned int\nget_dimension(const std::string &parameters)\n{\n  const std::string dimension = get_last_value_of_parameter(parameters, \"Dimension\");\n  if (dimension.size() > 0)\n    return dealii::Utilities::string_to_int (dimension);\n  else\n    return 2;\n}\n\n\n#if ASPECT_USE_SHARED_LIBS==1\n\n#ifdef ASPECT_HAVE_LINK_H\n// collect the names of the shared libraries linked to by this program. this\n// function is a callback for the dl_iterate_phdr() function we call below\nint get_names_of_shared_libs (struct dl_phdr_info *info,\n                              size_t,\n                              void *data)\n{\n  reinterpret_cast<std::set<std::string>*>(data)->insert (info->dlpi_name);\n  return 0;\n}\n#endif\n\n\n// make sure the list of shared libraries we currently link with\n// has deal.II only once\nvoid validate_shared_lib_list (const bool before_loading_shared_libs)\n{\n#ifdef ASPECT_HAVE_LINK_H\n  // get the list of all shared libs we currently link against\n  std::set<std::string> shared_lib_names;\n  dl_iterate_phdr(get_names_of_shared_libs, &shared_lib_names);\n\n  // find everything that is interesting\n  std::set<std::string> dealii_shared_lib_names;\n  for (std::set<std::string>::const_iterator p = shared_lib_names.begin();\n       p != shared_lib_names.end(); ++p)\n    if (p->find (\"libdeal_II\") != std::string::npos)\n      dealii_shared_lib_names.insert (*p);\n\n  // produce an error if we load deal.II more than once\n  if (dealii_shared_lib_names.size() != 1)\n    {\n      std::ostringstream error;\n      error << \"........................................................\\n\"\n            << \"ASPECT currently links against different versions of the\\n\"\n            << \"deal.II library, namely the ones at these locations:\\n\";\n      for (std::set<std::string>::const_iterator p = dealii_shared_lib_names.begin();\n           p != dealii_shared_lib_names.end(); ++p)\n        error << \"  \" << *p << '\\n';\n      error << \"This can not work.\\n\\n\";\n\n      if (before_loading_shared_libs)\n        error << \"Since this is happening already before opening additional\\n\"\n              << \"shared libraries, this means that something must have gone\\n\"\n              << \"wrong when you configured deal.II and/or ASPECT. Please\\n\"\n              << \"contact the mailing lists for help.\\n\";\n      else\n        error << \"Since this is happening after opening additional shared\\n\"\n              << \"library plugins, this likely means that you have compiled\\n\"\n              << \"ASPECT in release mode and the plugin in debug mode, or the\\n\"\n              << \"other way around. Please re-compile the plugin in the same\\n\"\n              << \"mode as ASPECT.\\n\";\n\n      error << \"........................................................\\n\";\n\n      // if not success, then throw an exception: ExcMessage on processor 0,\n      // QuietException on the others\n      if (dealii::Utilities::MPI::this_mpi_process (MPI_COMM_WORLD) == 0)\n        {\n          AssertThrow (false, dealii::ExcMessage (error.str()));\n        }\n      else\n        throw aspect::QuietException();\n    }\n#else\n  // simply mark the argument as read, to avoid compiler warnings\n  (void)before_loading_shared_libs;\n#endif\n}\n\n\n#endif\n\n\n// retrieve a list of shared libraries from the parameter file and\n// dlopen them so that we can load plugins declared in them\nvoid possibly_load_shared_libs (const std::string &parameters)\n{\n  using namespace dealii;\n\n\n  const std::string shared_libs\n    = get_last_value_of_parameter(parameters,\n                                  \"Additional shared libraries\");\n  if (shared_libs.size() > 0)\n    {\n#if ASPECT_USE_SHARED_LIBS==1\n      // check up front whether the list of shared libraries is internally\n      // consistent or whether we link, for whatever reason, with both the\n      // debug and release versions of deal.II\n      validate_shared_lib_list (true);\n\n      const std::vector<std::string>\n      shared_libs_list = Utilities::split_string_list (shared_libs);\n\n      for (unsigned int i=0; i<shared_libs_list.size(); ++i)\n        {\n          if (Utilities::MPI::this_mpi_process (MPI_COMM_WORLD) == 0)\n            std::cout << \"Loading shared library <\"\n                      << shared_libs_list[i]\n                      << \">\" << std::endl;\n\n          void *handle = dlopen (shared_libs_list[i].c_str(), RTLD_LAZY);\n          AssertThrow (handle != NULL,\n                       ExcMessage (std::string(\"Could not successfully load shared library <\")\n                                   + shared_libs_list[i] + \">. The operating system reports \"\n                                   + \"that the error is this: <\"\n                                   + dlerror() + \">.\"));\n\n          // check again whether the list of shared libraries is\n          // internally consistent or whether we link with both the\n          // debug and release versions of deal.II. this may happen if\n          // the plugin was compiled against the debug version of\n          // deal.II but aspect itself against the release version, or\n          // the other way around\n          validate_shared_lib_list (false);\n\n          // on systems where we can detect that both libdeal_II.so and\n          // libdeal_II.g.so is loaded, the test above function above will\n          // throw an exception and we will terminate. on the other hand, on\n          // systems where we can't detect this we should at least mitigate\n          // some of the ill effects -- in particular, make sure that\n          // deallog is set to use the desired output depth since otherwise\n          // we get lots of output from the linear solvers\n          deallog.depth_console(0);\n        }\n\n      if (Utilities::MPI::this_mpi_process (MPI_COMM_WORLD) == 0)\n        std::cout << std::endl;\n#else\n      if (Utilities::MPI::this_mpi_process (MPI_COMM_WORLD) == 0)\n        {\n          std::cerr << std::endl << std::endl\n                    << \"----------------------------------------------------\"\n                    << std::endl;\n          std::cerr << \"You can not load plugins through additional shared libraries \" << std::endl\n                    << \"on systems where you link ASPECT as a static executable.\"\n                    << std::endl\n                    << \"----------------------------------------------------\"\n                    << std::endl;\n        }\n      std::exit (1);\n#endif\n    }\n}\n\n/*\n * Current implementation for reading from stdin requires use of a std::string,\n * so this function will read until the end of the stream\n */\nstd::string\nread_until_end (std::istream &input)\n{\n  std::string result;\n  while (input)\n    {\n      std::string line;\n      std::getline(input, line);\n\n      result += line + '\\n';\n    }\n  return result;\n}\n\n\n\n/**\n * Takes the name of a parameter file and return all parameters in that file\n * as a string. If @p parameter_file_name is \"--\" read the parameters from\n * std::cin instead.\n */\nstd::string\nread_parameter_file(const std::string &parameter_file_name)\n{\n  using namespace dealii;\n\n  std::string input_as_string;\n  const bool i_am_proc_0 = (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0);\n\n  if (parameter_file_name != \"--\")\n    {\n      std::ifstream parameter_file(parameter_file_name.c_str());\n      if (!parameter_file)\n        {\n          if (i_am_proc_0)\n            AssertThrow(false, ExcMessage (std::string(\"Input parameter file <\")\n                                           + parameter_file_name + \"> not found.\"));\n          return \"\";\n        }\n\n      input_as_string = read_until_end (parameter_file);\n    }\n  else\n    {\n      // As stated in the help string, treat \"--\" as special: as is common\n      // on unix, treat it as a way to read input from stdin.\n      // Unfortunately, if you do\n      //    echo \"abc\" | mpirun -np 4 ./aspect\n      // then only MPI process 0 gets the data. so we have to\n      // read it there, then broadcast it to the other processors\n      if (i_am_proc_0)\n        {\n          input_as_string = read_until_end (std::cin);\n          int size = input_as_string.size()+1;\n          MPI_Bcast (&size,\n                     1,\n                     MPI_INT,\n                     /*root=*/0, MPI_COMM_WORLD);\n          MPI_Bcast (const_cast<char *>(input_as_string.c_str()),\n                     size,\n                     MPI_CHAR,\n                     /*root=*/0, MPI_COMM_WORLD);\n        }\n      else\n        {\n          // on this side, read what processor zero has broadcast about\n          // the size of the input file. then create a buffer to put the\n          // text in, get it from processor 0, and copy it to\n          // input_as_string\n          int size;\n          MPI_Bcast (&size, 1,\n                     MPI_INT,\n                     /*root=*/0, MPI_COMM_WORLD);\n\n          char *p = new char[size];\n          MPI_Bcast (p, size,\n                     MPI_CHAR,\n                     /*root=*/0, MPI_COMM_WORLD);\n          input_as_string = p;\n          delete[] p;\n        }\n    }\n\n  // Replace $ASPECT_SOURCE_DIR in the input so that include statements\n  // like \"include $ASPECT_SOURCE_DIR/tests/bla.prm\" work.\n  input_as_string = aspect::Utilities::expand_ASPECT_SOURCE_DIR(input_as_string);\n\n  return input_as_string;\n}\n\n\n\n/**\n * Let ParameterHandler parse the input file, here given as a string.\n * Since ParameterHandler unconditionally writes to the screen when it\n * finds something it doesn't like, we get massive amounts of output\n * in parallel computations since every processor writes the same\n * stuff to screen. To avoid this, let processor 0 parse the input\n * first and, if necessary, produce its output. Only if this\n * succeeds, also let the other processors read their input.\n *\n * In case of an error, we need to abort all processors without them\n * having read their data. This is done by throwing an exception of the\n * special class aspect::QuietException that we can catch in main() and terminate\n * the program quietly without generating other output.\n */\nvoid\nparse_parameters (const std::string &input_as_string,\n                  dealii::ParameterHandler  &prm)\n{\n  // try reading on processor 0\n  bool success = true;\n  if (dealii::Utilities::MPI::this_mpi_process (MPI_COMM_WORLD) == 0)\n    try\n      {\n        prm.parse_input_from_string(input_as_string.c_str());\n      }\n    catch (const dealii::ExceptionBase &e)\n      {\n        success = false;\n        e.print_info(std::cerr);\n        std::cerr << std::endl;\n      }\n\n\n  // broadcast the result. we'd like to do this with a bool\n  // data type but MPI_C_BOOL is not part of old MPI standards.\n  // so, do the broadcast in integers\n  {\n    int isuccess = (success ? 1 : 0);\n    MPI_Bcast (&isuccess, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    success = (isuccess == 1);\n  }\n\n  // if not success, then throw an exception: ExcMessage on processor 0,\n  // QuietException on the others\n  if (success == false)\n    {\n      if (dealii::Utilities::MPI::this_mpi_process (MPI_COMM_WORLD) == 0)\n        {\n          AssertThrow(false, dealii::ExcMessage (\"Invalid input parameter file.\"));\n        }\n      else\n        throw aspect::QuietException();\n    }\n\n  // otherwise, processor 0 was ok reading the data, so we can expect the\n  // other processors will be ok as well\n  if (dealii::Utilities::MPI::this_mpi_process (MPI_COMM_WORLD) != 0)\n    {\n      prm.parse_input_from_string(input_as_string.c_str());\n    }\n}\n\n\n\n/**\n * Print help text\n */\nvoid print_help()\n{\n  std::cout << \"Usage: ./aspect [args] <parameter_file.prm>   (to read from an input file)\"\n            << std::endl\n            << \"    or ./aspect [args] --                     (to read parameters from stdin)\"\n            << std::endl\n            << std::endl;\n  std::cout << \"    optional arguments [args]:\"\n            << std::endl\n            << \"       -h, --help             (for this usage help)\"\n            << std::endl\n            << \"       -v, --version          (for information about library versions)\"\n            << std::endl\n            << \"       -j, --threads          (to use multi-threading)\"\n            << std::endl\n            << \"       --output-xml           (print parameters in xml format to standard output and exit)\"\n            << std::endl\n            << \"       --output-plugin-graph  (write a representation of all plugins to standard output and exit)\"\n            << std::endl\n            << std::endl;\n}\n\n\n\n// hook into SIGABRT/SIGFPE and kill off the program\nvoid signal_handler(int signal)\n{\n  if (signal == SIGABRT)\n    {\n      std::cerr << \"SIGABRT received\\n\";\n    }\n  else if (signal == SIGFPE)\n    {\n      std::cerr << \"SIGFPE received\\n\";\n    }\n  else\n    {\n      std::cerr << \"Unexpected signal \" << signal << \" received\\n\";\n    }\n#if DEAL_II_USE_CXX11\n  // Kill the program without performing any other cleanup, which is likely to\n  // lead to a deadlock\n  std::_Exit(EXIT_FAILURE);\n#else\n  // Kill the program, or at least try to. The problem when we get here is\n  // that calling std::exit invokes at_exit() functions that may still hang\n  // the MPI system\n  std::exit(1);\n#endif\n}\n\n\n\ntemplate<int dim>\nvoid\nrun_simulator(const std::string &input_as_string,\n              const bool output_xml,\n              const bool output_plugin_graph)\n{\n  using namespace dealii;\n\n  ParameterHandler prm;\n  const bool i_am_proc_0 = (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0);\n  aspect::Simulator<dim>::declare_parameters(prm);\n  parse_parameters (input_as_string, prm);\n\n  if (output_xml)\n    {\n      if (i_am_proc_0)\n        prm.print_parameters(std::cout, ParameterHandler::XML);\n    }\n  else if (output_plugin_graph)\n    {\n      aspect::Simulator<dim> flow_problem(MPI_COMM_WORLD, prm);\n      if (i_am_proc_0)\n        flow_problem.write_plugin_graph (std::cout);\n    }\n  else\n    {\n      aspect::Simulator<dim> flow_problem(MPI_COMM_WORLD, prm);\n      flow_problem.run();\n    }\n}\n\n\n\nint main (int argc, char *argv[])\n{\n  using namespace dealii;\n\n#ifdef DEBUG\n#ifdef ASPECT_USE_FP_EXCEPTIONS\n  // Some implementations seem to not initialize the floating point exception\n  // bits to zero. Make sure we start from a clean state.\n  feclearexcept(FE_DIVBYZERO|FE_INVALID);\n\n  // enable floating point exceptions\n  feenableexcept(FE_DIVBYZERO|FE_INVALID);\n#endif\n#endif\n\n  std::string prm_name = \"\";\n  bool output_xml          = false;\n  bool output_plugin_graph = false;\n  bool output_version      = false;\n  bool output_help         = false;\n  bool use_threads         = false;\n  int current_argument = 1;\n\n  // Loop over all command line arguments. Handle a number of special ones\n  // starting with a dash, and then take the first non-special one as the\n  // name of the input file. We will later check that there are no further\n  // arguments left after that (though there may be with PETSc, see\n  // below).\n  while (current_argument<argc)\n    {\n      const std::string arg = argv[current_argument];\n      ++current_argument;\n      if (arg == \"--output-xml\")\n        {\n          output_xml = true;\n        }\n      else if (arg == \"--output-plugin-graph\")\n        {\n          output_plugin_graph = true;\n        }\n      else if (arg==\"-h\" || arg ==\"--help\")\n        {\n          output_help = true;\n        }\n      else if (arg==\"-v\" || arg ==\"--version\")\n        {\n          output_version = true;\n        }\n      else if (arg==\"-j\" || arg ==\"--threads\")\n        {\n          use_threads = true;\n        }\n      else\n        {\n          // Not a special argument, so we assume that this is the .prm\n          // filename (or \"--\"). We can now break out of this loop because\n          // we are not going to parse arguments passed after the filename.\n          prm_name = arg;\n          break;\n        }\n    }\n\n  try\n    {\n      // Note: we initialize this class inside the try/catch block and not\n      // before, so that the destructor of this instance can react if we are\n      // currently unwinding the stack if an unhandled exception is being\n      // thrown to avoid MPI deadlocks.\n      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, use_threads ? numbers::invalid_unsigned_int : 1);\n\n      deallog.depth_console(0);\n\n      const bool i_am_proc_0 = (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0);\n\n      if (i_am_proc_0)\n        {\n          // Output header, except for a clean output for xml or plugin graph\n          if (!output_xml && !output_plugin_graph)\n            print_aspect_header(std::cout);\n\n          if (output_help)\n            print_help();\n\n          // If only help or version is requested, we are done.\n          if (output_help || output_version)\n            return 0;\n        }\n      else\n        {\n          // We hook into the abort handler on ranks != 0 to avoid an MPI\n          // deadlock. The deal.II library will call std::abort() when an\n          // Assert is triggered, which can lead to a deadlock because it\n          // runs the things that are associated with atexit() which may\n          // itself trigger MPI communication. The same happens for other\n          // signals we may trigger, such as floating point exceptions\n          // (SIGFPE).\n          //\n          // We work around this by immediately calling _Exit in the\n          // signal handler and thus aborting the program without running\n          // cleanup functions set via atexit(). This is only necessary on\n          // rank != 0 for some reason.\n          std::signal(SIGABRT, signal_handler);\n          std::signal(SIGFPE, signal_handler);\n        }\n\n      // If no parameter given or somebody gave additional parameters,\n      // show help and exit. However, this does not work with PETSc because for\n      // PETSc, one may pass any number of flags on the command line.\n      if ((prm_name == \"\")\n#ifndef ASPECT_USE_PETSC\n          || (current_argument < argc)\n#endif\n         )\n        {\n          if (i_am_proc_0)\n            print_help();\n          return 2;\n        }\n\n      // See where to read input from, then do the reading and\n      // put the contents of the input into a string.\n      const std::string input_as_string = read_parameter_file(prm_name);\n\n      // Determine the dimension we want to work in. the default\n      // is 2, but if we find a line of the kind \"set Dimension = ...\"\n      // then the last such line wins.\n      const unsigned int dim = get_dimension(input_as_string);\n\n      // Do the same with lines potentially indicating shared libs to\n      // be loaded. These shared libs could contain additional module\n      // instantiations for geometries, etc, that would then be\n      // available as part of the possible parameters of the input\n      // file, so they need to be loaded before we even start processing\n      // the parameter file.\n      possibly_load_shared_libs (input_as_string);\n\n      // Now switch between the templates that start the model for 2d or 3d.\n      switch (dim)\n        {\n          case 2:\n          {\n            run_simulator<2>(input_as_string,output_xml,output_plugin_graph);\n            break;\n          }\n          case 3:\n          {\n            run_simulator<3>(input_as_string,output_xml,output_plugin_graph);\n            break;\n          }\n          default:\n            AssertThrow((dim >= 2) && (dim <= 3),\n                        ExcMessage (\"ASPECT can only be run in 2d and 3d but a \"\n                                    \"different space dimension is given in the parameter file.\"));\n        }\n    }\n  catch (ExceptionBase &exc)\n    {\n      // report name of the deal.II exception:\n      std::cerr << std::endl << std::endl\n                << \"----------------------------------------------------\"\n                << std::endl;\n      std::cerr << \"Exception '\" << exc.get_exc_name() << \"'\"\n                << \" on rank \" << Utilities::MPI::this_mpi_process(MPI_COMM_WORLD)\n                << \" on processing: \" << std::endl\n                << exc.what() << std::endl\n                << \"Aborting!\" << std::endl\n                << \"----------------------------------------------------\"\n                << std::endl;\n      return 1;\n    }\n  catch (std::exception &exc)\n    {\n      std::cerr << std::endl << std::endl\n                << \"----------------------------------------------------\"\n                << std::endl;\n      std::cerr << \"Exception\"\n                << \" on rank \" << Utilities::MPI::this_mpi_process(MPI_COMM_WORLD)\n                << \" on processing: \" << std::endl\n                << exc.what() << std::endl\n                << \"Aborting!\" << std::endl\n                << \"----------------------------------------------------\"\n                << std::endl;\n      return 1;\n    }\n  catch (aspect::QuietException &)\n    {\n      // Quietly treat an exception used on processors other than\n      // root when we already know that processor 0 will generate\n      // an exception. We do this to avoid creating too much\n      // (duplicate) screen output.\n      return 1;\n    }\n  catch (...)\n    {\n      std::cerr << std::endl << std::endl\n                << \"----------------------------------------------------\"\n                << std::endl;\n      std::cerr << \"Unknown exception!\" << std::endl\n                << \"Aborting!\" << std::endl\n                << \"----------------------------------------------------\"\n                << std::endl;\n      return 1;\n    }\n\n  return 0;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-aspect-2.0.0-aniuibxz3qshx5jcypy7ncvhlztpqfat/spack-src/tests/ascii_data_initial_temperature_3d_chunk/.screen-output.swp",
        "/tmp/vanessa/spack-stage/spack-stage-aspect-2.0.0-aniuibxz3qshx5jcypy7ncvhlztpqfat/spack-src/doc/manual.pdf"
    ],
    "total_files": 1995
}