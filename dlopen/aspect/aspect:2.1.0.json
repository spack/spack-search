{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-aspect-2.1.0-onf27hdmtbgkpk4htrfbnw5memdk3il6/spack-src/CMakeLists.txt": "# Copyright (C) 2013 - 2019 by the authors of the ASPECT code.\n#\n# This file is part of ASPECT.\n#\n# ASPECT is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2, or (at your option)\n# any later version.\n#\n# ASPECT is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with ASPECT; see the file doc/COPYING.  If not see\n# <http://www.gnu.org/licenses/>.\n\nCMAKE_MINIMUM_REQUIRED(VERSION 2.8.12)\n\nMESSAGE(STATUS \"====================================================\")\nMESSAGE(STATUS \"============ Configuring ASPECT ====================\")\nMESSAGE(STATUS \"====================================================\")\n\n# Set the name of the project and target:\nSET(TARGET \"aspect\")\n\nFILE(GLOB_RECURSE TARGET_SRC  \"source/*.cc\" \"unit_tests/*.cc\" \"include/*.h\" \"contrib/catch/catch.hpp\")\nINCLUDE_DIRECTORIES(${CMAKE_BINARY_DIR}/include include  contrib/catch)\n\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n\nLIST(APPEND CMAKE_MODULE_PATH\n  ${CMAKE_SOURCE_DIR}\n  )\n\nFIND_PACKAGE(deal.II 8.5.0 QUIET\n  HINTS ${deal.II_DIR} ${DEAL_II_DIR} ../ ../../ $ENV{DEAL_II_DIR}\n  )\nIF(NOT ${deal.II_FOUND})\n  MESSAGE(FATAL_ERROR \"\\n*** Could not find a suitably recent version of deal.II. ***\\n\"\n    \"You may want to either pass a flag -DDEAL_II_DIR=/path/to/deal.II to cmake \"\n    \"or set an environment variable \\\"DEAL_II_DIR\\\" that contains a path to a \"\n    \"sufficiently recent version of deal.II.\"\n    )\nENDIF()\n\nMESSAGE(STATUS \"Found deal.II version ${DEAL_II_PACKAGE_VERSION} at '${deal.II_DIR}'\")\n\nIF(NOT DEAL_II_WITH_CXX11)\n  MESSAGE(FATAL_ERROR \"\\n*** ASPECT requires C++11 but your version of deal.II is not \"\n    \"configured with it. This likely means that your compiler is too old. Check \"\n    \"DEAL_II_WITH_CXX11 in deal.II.\")\nENDIF()\n\n\nSET(ASPECT_USE_PETSC OFF CACHE BOOL \"Use PETSc instead of Trilinos if set to 'on'.\")\n\nMESSAGE(STATUS \"Using ASPECT_USE_PETSC = '${ASPECT_USE_PETSC}'\")\n\nSET(_DEALII_GOOD ON)\n\nIF(ASPECT_USE_PETSC AND NOT DEAL_II_WITH_PETSC)\n    MESSAGE(SEND_ERROR\n      \"\\n-- deal.II was built without support for PETSc!\\n\"\n      )\n    SET(_DEALII_GOOD OFF)\nENDIF()\n\nIF(NOT DEAL_II_WITH_P4EST)\n    MESSAGE(SEND_ERROR\n      \"\\n-- deal.II was built without support for p4est!\\n\"\n      )\n    SET(_DEALII_GOOD OFF)\nENDIF()\n\nIF(NOT ASPECT_USE_PETSC AND NOT DEAL_II_WITH_TRILINOS)\n    MESSAGE(SEND_ERROR\n      \"\\n-- deal.II was built without support for Trilinos!\\n\"\n      )\n    SET(_DEALII_GOOD OFF)\nENDIF()\n\nIF (NOT _DEALII_GOOD)\n  MESSAGE(FATAL_ERROR\n    \"\\nASPECT requires a deal.II installation built with support for Trilinos/PETSc and p4est but one or both of these appears to be missing!\\n\"\n    )\nENDIF()\n\nDEAL_II_INITIALIZE_CACHED_VARIABLES()\nPROJECT(${TARGET})\n\nIF (ASPECT_USE_PETSC)\nFOREACH(_source_file ${TARGET_SRC})\n  SET_PROPERTY(SOURCE ${_source_file}\n    APPEND PROPERTY COMPILE_DEFINITIONS ASPECT_USE_PETSC=\"1\")\nENDFOREACH()\nENDIF()\n\n\n# Pass down the source directory to the sources. This can be used\n# to hard-code the location of data files, such as in\n# $ASPECT_SOURCE_DIR/data/velocity-boundary-conditions/gplates/*\nFOREACH(_source_file ${TARGET_SRC})\n  SET_PROPERTY(SOURCE ${_source_file}\n    APPEND PROPERTY COMPILE_DEFINITIONS ASPECT_SOURCE_DIR=\"${CMAKE_SOURCE_DIR}\")\nENDFOREACH()\n\n\n\n# load in version info and export it\nFILE(STRINGS \"${CMAKE_SOURCE_DIR}/VERSION\" ASPECT_PACKAGE_VERSION LIMIT_COUNT 1)\n\nINCLUDE(${CMAKE_SOURCE_DIR}/cmake/macro_aspect_query_git_information.cmake)\nASPECT_QUERY_GIT_INFORMATION(\"ASPECT\")\nCONFIGURE_FILE(${CMAKE_SOURCE_DIR}/include/aspect/revision.h.in ${CMAKE_BINARY_DIR}/include/aspect/revision.h @ONLY)\n\nINCLUDE(CMakePackageConfigHelpers)\nWRITE_BASIC_PACKAGE_VERSION_FILE(\n  \"${CMAKE_BINARY_DIR}/AspectConfigVersion.cmake\"\n  VERSION ${ASPECT_PACKAGE_VERSION}\n  COMPATIBILITY AnyNewerVersion\n)\n\n# Configure a cmake fragment that plugins can use to\n# set up compiler flags, include paths, etc to compile an\n# Aspect plugin.\n# Config for the build dir:\nSET(CONFIG_INCLUDE_DIRS \"${CMAKE_SOURCE_DIR}/include\")\nSET(CONFIG_DIR \"${CMAKE_BINARY_DIR}\")\nCONFIGURE_FILE(\n  ${CMAKE_SOURCE_DIR}/cmake/AspectConfig.cmake.in\n  ${CMAKE_BINARY_DIR}/AspectConfig.cmake\n  @ONLY\n)\n# Config for the install dir:\nSET(CONFIG_INCLUDE_DIRS \"${CMAKE_INSTALL_PREFIX}/include\")\nSET(CONFIG_DIR \"${CMAKE_INSTALL_PREFIX}/bin\")\nCONFIGURE_FILE(\n  ${CMAKE_SOURCE_DIR}/cmake/AspectConfig.cmake.in\n  ${CMAKE_BINARY_DIR}/forinstall/AspectConfig.cmake\n  @ONLY\n)\n\n\n# Next, set up the testsuite\n\nSET(ASPECT_RUN_ALL_TESTS OFF CACHE BOOL \"Set up complete test suite to run.\")\nSET(ASPECT_COMPARE_TEST_RESULTS ON CACHE BOOL \"Compare test results with high accuracy.\")\n\nCONFIGURE_FILE(\n  ${CMAKE_SOURCE_DIR}/tests/cmake/CTestCustom.ctest.in\n  ${CMAKE_BINARY_DIR}/CTestCustom.ctest\n  @ONLY\n)\nCONFIGURE_FILE(\n  ${CMAKE_SOURCE_DIR}/tests/cmake/print_test_info.sh\n  ${CMAKE_BINARY_DIR}/print_test_info.sh\n  @ONLY\n)\n\nADD_CUSTOM_TARGET(setup_tests\n  COMMAND ${CMAKE_COMMAND} -D ASPECT_RUN_ALL_TESTS=ON -D PRINT_TEST_SUMMARY_AS_IMPORTANT=ON . >/dev/null\n  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}\n  COMMENT \"Enabling all tests ...\")\n\n# Disable the ability to run all tests in an in-source build:\nIF ((\"${CMAKE_SOURCE_DIR}\" STREQUAL \"${CMAKE_BINARY_DIR}\") AND ASPECT_RUN_ALL_TESTS)\n  SET(ASPECT_RUN_ALL_TESTS OFF CACHE BOOL \"\" FORCE)\n  MESSAGE(FATAL_ERROR \"\\nEnabling all tests is not supported in in-source builds. Please create a separate build directory!\\n\")\nENDIF()\n\n\nSET(ASPECT_TEST_GENERATOR \"Unix Makefiles\" CACHE STRING \n  \"Generator to use for the test cmake project. Using ninja instead of make is not recommended.\")\n\n\n# Allow us to make a global \"test\" target:\nIF(POLICY CMP0037)\n  # allow to override \"test\" target\n  CMAKE_POLICY(SET CMP0037 OLD)\nENDIF()\n\n# This is an empty target but we will make it depend on tests/ and unit_tests/ next:\nADD_CUSTOM_TARGET(test)\n\n# Generate CTestTestfile.cmake in the main build folder that lists all subfolders\n# that contain tests. This way you can call \"ctest\" in the build directory.\nFILE(WRITE ${CMAKE_BINARY_DIR}/CTestTestfile.cmake \"# auto-generated ctest file\\n\")\n\nIF(EXISTS ${CMAKE_SOURCE_DIR}/unit_tests/CMakeLists.txt)\n  # If we have the unit_tests directory, add it so ctest picks it up and configure\n  # the test project in the subfolder:\n  FILE(APPEND ${CMAKE_BINARY_DIR}/CTestTestfile.cmake \"SUBDIRS(unit_tests)\\n\")\n  FILE(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/unit_tests)\n  EXECUTE_PROCESS(\n    COMMAND ${CMAKE_COMMAND}\n        -D CMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}\n        -D ASPECT_BINARY=${CMAKE_BINARY_DIR}/aspect\n        ${CMAKE_CURRENT_SOURCE_DIR}/unit_tests\n    OUTPUT_FILE setup_unit_tests.log\n    RESULT_VARIABLE test_cmake_result\n    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/unit_tests\n   )\n  IF(NOT test_cmake_result EQUAL 0)\n    MESSAGE(FATAL_ERROR \"ERROR: unittest/ project could not be configured.\")\n  ENDIF()\n\n  # Finally hook up that \"make test\" will execute the tests:\n  ADD_CUSTOM_TARGET(run_unit_tests\n    COMMAND ${CMAKE_BINARY_DIR}/aspect --test\n    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/unit_tests\n    DEPENDS aspect\n    COMMENT \"Running unit_tests ...\")\n\n  ADD_DEPENDENCIES(test run_unit_tests)\nENDIF()\n\nIF(EXISTS ${CMAKE_SOURCE_DIR}/tests/CMakeLists.txt)\n  # Hook up the tests:\n  FILE(APPEND ${CMAKE_BINARY_DIR}/CTestTestfile.cmake \"SUBDIRS(tests)\\n\")\n\n  FILE(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/tests)\n\n  SET(aspect_binary ${CMAKE_BINARY_DIR}/aspect)\n\n  MESSAGE(STATUS \"Setting up test project, see tests/setup_tests.log for details.\")\n  EXECUTE_PROCESS(\n    COMMAND ${CMAKE_COMMAND} -G ${ASPECT_TEST_GENERATOR}\n        -D ASPECT_RUN_ALL_TESTS=${ASPECT_RUN_ALL_TESTS}\n        -D ASPECT_COMPARE_TEST_RESULTS=${ASPECT_COMPARE_TEST_RESULTS}\n        -D Aspect_DIR=${CMAKE_BINARY_DIR}\n        -D CMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}\n        -D ASPECT_BINARY=${aspect_binary}\n        ${CMAKE_CURRENT_SOURCE_DIR}/tests\n    OUTPUT_FILE setup_tests.log\n    RESULT_VARIABLE test_cmake_result\n    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/tests\n   )\n  IF(NOT test_cmake_result EQUAL 0)\n    MESSAGE(FATAL_ERROR \"ERROR: tests/ project could not be configured.\")\n  ENDIF()\n\n  # Finally hook up that \"make test\" will execute the tests:\n  ADD_CUSTOM_TARGET(run_tests\n    COMMAND ${CMAKE_COMMAND} --build . --target test\n    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/tests\n    DEPENDS aspect\n    COMMENT \"Running tests ...\")\n\n  ADD_DEPENDENCIES(test run_tests)\nENDIF()\n\n# Provide the \"generate_reference_output\" target:\nADD_CUSTOM_TARGET(generate_reference_output\n  COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/cmake/generate_reference_output.sh\n  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})\n\n\n# Provide \"indent\" target for indenting all headers and source files\nADD_CUSTOM_TARGET(indent\n  WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}\n  COMMAND ./doc/indent\n  COMMENT \"Indenting all ASPECT header and source files...\"\n  )\n\nIF(CMAKE_GENERATOR MATCHES \"Ninja\")\n  SET(_make_command \"$ ninja\")\nELSE()\n  SET(_make_command \" $ make\")\nENDIF()\n\n# Provide \"release\" and \"debug\" targets to switch compile mode\nIF(${DEAL_II_BUILD_TYPE} MATCHES \"DebugRelease\")\nADD_CUSTOM_TARGET(release\n  COMMAND ${CMAKE_COMMAND} -D CMAKE_BUILD_TYPE=Release .\n  COMMAND ${CMAKE_COMMAND} -E echo \"***\"\n  COMMAND ${CMAKE_COMMAND} -E echo \"*** Switched to Release mode. Now recompile with: ${_make_command}\"\n  COMMAND ${CMAKE_COMMAND} -E echo \"***\"\n  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}\n  VERBATIM\n  COMMENT \"switching to RELEASE mode...\"\n  )\nADD_CUSTOM_TARGET(debug\n  COMMAND ${CMAKE_COMMAND} -D CMAKE_BUILD_TYPE=Debug .\n  COMMAND ${CMAKE_COMMAND} -E echo \"***\"\n  COMMAND ${CMAKE_COMMAND} -E echo \"*** Switched to Debug mode. Now recompile with: ${_make_command}\"\n  COMMAND ${CMAKE_COMMAND} -E echo \"***\"\n  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}\n  VERBATIM\n  COMMENT \"switching to DEBUG mode...\"\n  )\nENDIF()\n\n# Provide a \"distclean\" target (like it is done in deal.II):\nADD_CUSTOM_TARGET(distclean\n  COMMAND ${CMAKE_COMMAND} --build ${CMAKE_BINARY_DIR} --target clean\n  COMMAND ${CMAKE_COMMAND} -E remove_directory CMakeFiles\n  COMMAND ${CMAKE_COMMAND} -E remove\n    CMakeCache.txt cmake_install.cmake Makefile\n    build.ninja rules.ninja .ninja_deps .ninja_log\n  COMMENT \"distclean invoked\"\n  )\n\n\n\nFILE(WRITE ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/print_usage.cmake\n\"MESSAGE(\n\\\"###\n#\n#  Project ${TARGET} set up with  ${DEAL_II_PACKAGE_NAME}-${DEAL_II_PACKAGE_VERSION}  found at\n#      ${DEAL_II_PATH}\n#\n#  CMAKE_BUILD_TYPE:          ${CMAKE_BUILD_TYPE}\n#\n#  You can now run\n#      ${_make_command}                - to compile and link ${TARGET}\n#      ${_make_command} debug          - to switch the build type to 'Debug'\n#      ${_make_command} release        - to switch the build type to 'Release'\n#      ${_make_command} clean          - to remove the generated executable as well as\n#                               all intermediate compilation files\n#      ${_make_command} distclean      - to clean the directory from all generated\n#                               files (includes clean, runclean and the removal\n#                               of the generated build system)\n#      ${_make_command} info           - to view this message again\n\\\")\")\n\n# Provide \"info\" target\nADD_CUSTOM_TARGET(info\n  COMMAND ${CMAKE_COMMAND} -P ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/print_usage.cmake\n  )\n\n\n# Depending on whether we link statically or allow for shared libs,\n# we can or can not load plugins via external shared libs. Pass this\n# down during compilation so we can disable it in the code\nSET(ASPECT_USE_SHARED_LIBS ON CACHE BOOL \"If ON, we support loading shared plugin files.\")\nIF (DEAL_II_STATIC_EXECUTABLE STREQUAL \"ON\")\n  MESSAGE(STATUS \"Creating a statically linked executable\")\n  SET(ASPECT_USE_SHARED_LIBS OFF CACHE BOOL \"\" FORCE)\nENDIF()\n\nINCLUDE (CheckCXXSourceCompiles)\n\nSET(_backup_libs ${CMAKE_REQUIRED_LIBRARIES})\nLIST(APPEND CMAKE_REQUIRED_LIBRARIES ${CMAKE_DL_LIBS})\nCHECK_CXX_SOURCE_COMPILES(\"\n#include <cstddef>\n#include <dlfcn.h>\n\nint main()\n{\n  void *handle = dlopen (\\\"somelib.so\\\", RTLD_LAZY);\n  return handle == NULL || dlerror();\n}\n\" HAVE_DLOPEN)\nSET(CMAKE_REQUIRED_LIBRARIES ${_backup_libs})\n\nIF (NOT HAVE_DLOPEN)\n  MESSAGE(STATUS \"dlopen() test failed, disabling dynamic plugin loading\")\n  SET(ASPECT_USE_SHARED_LIBS OFF CACHE BOOL \"\" FORCE)\nENDIF()\n\nIF (ASPECT_USE_SHARED_LIBS)\n  MESSAGE(STATUS \"Enabling dynamic loading of plugins from the input file\")\n  FOREACH(_source_file ${TARGET_SRC})\n    SET_PROPERTY(SOURCE ${_source_file}\n      APPEND PROPERTY COMPILE_DEFINITIONS ASPECT_USE_SHARED_LIBS=1)\n  ENDFOREACH()\nELSE()\n  MESSAGE(STATUS \"Disabling dynamic loading of plugins from the input file\")\n  FOREACH(_source_file ${TARGET_SRC})\n    SET_PROPERTY(SOURCE ${_source_file}\n      APPEND PROPERTY COMPILE_DEFINITIONS ASPECT_USE_SHARED_LIBS=0)\n  ENDFOREACH()\nENDIF()\n\n# See whether we can verify that every plugin we load is compiled against\n# the same deal.II library\nSET(ASPECT_HAVE_LINK_H ON CACHE BOOL \"If ON, link.h exists and is usable.\")\nINCLUDE (CheckIncludeFiles)\nCHECK_INCLUDE_FILES (\"link.h\" _HAVE_LINK_H)\nIF (NOT _HAVE_LINK_H)\n  SET(ASPECT_HAVE_LINK_H OFF CACHE BOOL \"\" FORCE)\nENDIF()\nIF (ASPECT_HAVE_LINK_H)\n  MESSAGE(STATUS \"Enabling checking of compatible deal.II library when loading plugins\")\n  FOREACH(_source_file ${TARGET_SRC})\n    SET_PROPERTY(SOURCE ${_source_file}\n      APPEND PROPERTY COMPILE_DEFINITIONS ASPECT_HAVE_LINK_H=1)\n  ENDFOREACH()\nENDIF()\n\n# Check if we want to use cotire to precompile header files and prepare a\n# unity build target. This speeds up compile time, but can fail on some\n# machines, therefore it is disabled by default. Also cotire currently\n# has issues with cmake generator expressions used in deal.II for cmake\n# version 3.9 and above. Disable cotire for cmake >= 3.9.\nSET(ASPECT_PRECOMPILE_HEADERS OFF CACHE BOOL \"Precompile external header files using cotire to speedup compile time. Currently only supported for cmake versions older than 3.9.\")\nIF (ASPECT_PRECOMPILE_HEADERS)\n  IF(CMAKE_VERSION VERSION_LESS 3.9)\n    # For the unity build we need to compile helper_functions.cc before core.cc\n    # ensure this by reordering the files\n    FIND_FILE(HELPER_PATH helper_functions.cc HINTS \"${CMAKE_SOURCE_DIR}/source/simulator\")\n    LIST(REMOVE_ITEM TARGET_SRC ${HELPER_PATH})\n    LIST(INSERT TARGET_SRC 0 ${HELPER_PATH})\n  ELSE()\n    MESSAGE(FATAL_ERROR \"ASPECT_PRECOMPILE_HEADERS is currently only supported for CMake version 3.8 or less.\")\n  ENDIF()\nENDIF()\n\n# Check whether we can find the WorldBuilder and enable it.\nSET(ASPECT_WITH_WORLD_BUILDER ON CACHE BOOL \"If ON the World Builder is compiled togheter with ASPECT.\")\nIF (NOT EXISTS ${CMAKE_SOURCE_DIR}/contrib/WorldBuilder/VERSION)\n  MESSAGE(\"-- World Builder not found.\")\n  SET(ASPECT_WITH_WORLD_BUILDER OFF CACHE BOOL \"\" FORCE)\nENDIF()\nIF (ASPECT_WITH_WORLD_BUILDER)\n  SET(WORLD_BUILDER_SOURCE_DIR \"${CMAKE_SOURCE_DIR}/contrib/WorldBuilder\")\n  INCLUDE(\"${WORLD_BUILDER_SOURCE_DIR}/cmake/version.cmake\")\n  MESSAGE(\"-- World Builder version ${WORLD_BUILDER_VERSION} found.\")\n\n  # add source and include dirs:\n  FILE(GLOB_RECURSE _files \"contrib/WorldBuilder/source/*.cc\")\n  LIST(APPEND TARGET_SRC ${_files})\n  INCLUDE_DIRECTORIES(\"${WORLD_BUILDER_SOURCE_DIR}/include/\")\n\n  # generate config.cc and include it:\n  CONFIGURE_FILE(\"${WORLD_BUILDER_SOURCE_DIR}/source/config.cc.in\" \"${CMAKE_BINARY_DIR}/world_builder_config.cc\" @ONLY)\n  LIST(INSERT TARGET_SRC 0 \"${CMAKE_BINARY_DIR}/world_builder_config.cc\")\n\n  # set ASPECT_USE_WORLD_BUILDER define for all source files:\n  FOREACH(_source_file ${TARGET_SRC})\n    SET_PROPERTY(SOURCE ${_source_file}\n                 APPEND PROPERTY COMPILE_DEFINITIONS ASPECT_USE_WORLD_BUILDER=1)\n  ENDFOREACH()\nENDIF()\n\nADD_EXECUTABLE(${TARGET} ${TARGET_SRC})\nDEAL_II_SETUP_TARGET(${TARGET})\n\nFIND_PACKAGE(PerpleX QUIET HINTS ./contrib/perplex/install/ ../ ../../ $ENV{PERPLEX_DIR})\nIF(${PerpleX_FOUND})\n  MESSAGE(STATUS \"PerpleX found at ${PerpleX_INCLUDE_DIR}\")\n  INCLUDE_DIRECTORIES(${PerpleX_INCLUDE_DIR})\n  TARGET_LINK_LIBRARIES(${TARGET} ${PerpleX_LIBRARIES})\n  SET(ASPECT_WITH_PERPLEX ON)\n  FOREACH(_source_file ${TARGET_SRC})\n    SET_PROPERTY(SOURCE ${_source_file}\n      APPEND PROPERTY COMPILE_DEFINITIONS ASPECT_WITH_PERPLEX=\"1\")\n  ENDFOREACH()\nELSE()\n  SET(ASPECT_WITH_PERPLEX OFF)\nENDIF()\n\n\n\nIF (ASPECT_USE_SHARED_LIBS)\n  # some systems need to explicitly link to some libraries to use dlopen\n  TARGET_LINK_LIBRARIES(aspect ${CMAKE_DL_LIBS})\nENDIF()\n\n\n\n# Check if we can raise floating point exceptions.\n#\n# Note that some library we link with in ASPECT on some platforms will trigger\n# floating point exceptions when converting -numeric_limits<double>::max to a\n# string. The only thing we can do is a configure check and disable the\n# exceptions. This is done here:\nSET(ASPECT_USE_FP_EXCEPTIONS ON CACHE BOOL \"If ON, floating point exception are raised in debug mode.\")\n\n# Clang 6.0 throws random floating point exceptions, which we could not\n# track down. Disable the exceptions for now.\nIF(\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"Clang\" AND NOT CMAKE_CXX_COMPILER_VERSION VERSION_LESS 6.0.0)\n  SET(ASPECT_USE_FP_EXCEPTIONS OFF CACHE BOOL \"\" FORCE)\nENDIF()\n\nIF (ASPECT_USE_FP_EXCEPTIONS)\n  INCLUDE(${CMAKE_SOURCE_DIR}/cmake/fpe_check.cmake)\n\n  IF (HAVE_FP_EXCEPTIONS)\n    MESSAGE(STATUS \"Runtime floating point checks enabled.\")\n    FOREACH(_source_file ${TARGET_SRC})\n      SET_PROPERTY(SOURCE ${_source_file}\n        APPEND PROPERTY COMPILE_DEFINITIONS ASPECT_USE_FP_EXCEPTIONS=1)\n    ENDFOREACH()\n  ELSE()\n    SET(ASPECT_USE_FP_EXCEPTIONS OFF CACHE BOOL \"\" FORCE)\n    MESSAGE(STATUS \"No support for feenableexcept(), disabling runtime floating point exception checks.\")\n  ENDIF()\nENDIF()\n\nIF (ASPECT_PRECOMPILE_HEADERS)\n  MESSAGE(STATUS \"Enabling cotire to precompile external header files.\")\n  INCLUDE(cmake/cotire)\n\n  # Set some properties that are necessary for the header precompilations \n  # and unity build to pass. We need to exclude some headers that\n  # frequently cause problems, and undefine some macros between source \n  # files that would otherwise interfere with each other.\n  SET_TARGET_PROPERTIES (aspect PROPERTIES\n      COTIRE_PREFIX_HEADER_IGNORE_PATH\n      \"/usr/include/;${CMAKE_SOURCE_DIR};${CMAKE_BINARY_DIR}\")\n  SET_SOURCE_FILES_PROPERTIES (${TARGET_SRC} PROPERTIES\n      COTIRE_UNITY_SOURCE_POST_UNDEFS \"INSTANTIATE\")\n\n  # This line activates the cotire module for the aspect target, \n  # and therefore the whole precompilation\n  cotire(aspect)\nELSE()\n  MESSAGE(STATUS \"Disabling cotire.\")\nENDIF()\n\n# Find the deal.II parameter GUI and install helper script\nFIND_PROGRAM(PARAMETER_GUI_EXECUTABLE\n        parameter_gui\n        HINTS $ENV{PARAMETER_GUI_DIR} $ENV{PARAMETER_GUI_DIR}/bin ${PARAMETER_GUI_DIR} ${PARAMETER_GUI_DIR}/bin\n        PATH bin)\nMARK_AS_ADVANCED(CLEAR PARAMETER_GUI_EXECUTABLE)\n\n# did the user specify something that doesn't exist?\nIF (PARAMETER_GUI_EXECUTABLE \n        AND\n    (NOT EXISTS ${PARAMETER_GUI_EXECUTABLE} OR IS_DIRECTORY ${PARAMETER_GUI_EXECUTABLE}))\n  MESSAGE(STATUS \"Warning: PARAMETER_GUI_EXECUTABLE '${PARAMETER_GUI_EXECUTABLE}' does not exist\")\n  SET(PARAMETER_GUI_EXECUTABLE \"PARAMETER_GUI_EXECUTABLE-NOTFOUND\" CACHE FILEPATH \"\" FORCE)\nENDIF()\n\nIF (NOT PARAMETER_GUI_EXECUTABLE)\n  MESSAGE(STATUS \"Parameter GUI not found: install and provide a hint using -D PARAMETER_GUI_DIR or set -D PARAMETER_GUI_EXECUTABLE directly.\")\nELSE()\n  MESSAGE(STATUS \"Found parameter GUI at: ${PARAMETER_GUI_EXECUTABLE}\")\n  CONFIGURE_FILE(\n  ${CMAKE_SOURCE_DIR}/doc/aspect-gui\n  ${CMAKE_BINARY_DIR}/aspect-gui\n  @ONLY\n  )\nINSTALL(FILES ${CMAKE_BINARY_DIR}/aspect-gui\n        DESTINATION bin\n        PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ\n                GROUP_READ GROUP_EXECUTE\n                WORLD_READ WORLD_EXECUTE)\nENDIF()\n\n#\n## installation\n#\n# binary:\nINSTALL(TARGETS aspect\n  RUNTIME DESTINATION bin\n  COMPONENT runtime)\n\n# make sure we have the rpath to our dependencies set:\nSET_PROPERTY(TARGET aspect PROPERTY INSTALL_RPATH_USE_LINK_PATH TRUE)\n\n# headers:\nINSTALL(DIRECTORY include/ \n  DESTINATION include\n  COMPONENT includes\n  FILES_MATCHING PATTERN \"*.h\")\n\n# cmake stuff:\nINSTALL(FILES ${CMAKE_BINARY_DIR}/forinstall/AspectConfig.cmake ${CMAKE_BINARY_DIR}/AspectConfigVersion.cmake\n        DESTINATION \"lib/cmake/Aspect/\")\n\nINSTALL(FILES ${CMAKE_BINARY_DIR}/include/aspect/revision.h DESTINATION \"include/aspect/\")\n\nMESSAGE(STATUS \"Writing config into detailed.log...\")\nINCLUDE(cmake/write_config)\n\n# print \"info\" if run for the first time:\nIF(NOT USAGE_PRINTED)\n  INCLUDE(${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/print_usage.cmake)\n  SET(USAGE_PRINTED TRUE CACHE INTERNAL \"\")\nELSE()\n  MESSAGE(STATUS \"Run  ${_make_command} info  to print a detailed help message\")\nENDIF()\n",
        "/tmp/vanessa/spack-stage/spack-stage-aspect-2.1.0-onf27hdmtbgkpk4htrfbnw5memdk3il6/spack-src/source/main.cc": "/*\n  Copyright (C) 2011 - 2019 by the authors of the ASPECT code.\n\n  This file is part of ASPECT.\n\n  ASPECT is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation; either version 2, or (at your option)\n  any later version.\n\n  ASPECT is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with ASPECT; see the file LICENSE.  If not see\n  <http://www.gnu.org/licenses/>.\n*/\n\n\n#include <aspect/simulator.h>\n#include <aspect/utilities.h>\n\n#include <deal.II/base/utilities.h>\n#include <deal.II/base/mpi.h>\n#include <deal.II/base/multithread_info.h>\n#include <deal.II/base/revision.h>\n#include <csignal>\n#include <string>\n\n#ifdef DEBUG\n#ifdef ASPECT_USE_FP_EXCEPTIONS\n#include <fenv.h>\n#endif\n#endif\n\n#if ASPECT_USE_SHARED_LIBS==1\n#  include <dlfcn.h>\n#  ifdef ASPECT_HAVE_LINK_H\n#    include <link.h>\n#  endif\n#endif\n\n// This define has to be in exactly one translation unit and sets up the catch testing framework\n#define CATCH_CONFIG_RUNNER\n\n// work-around for clang 6 error:\n// \"error: no member named 'uncaught_exceptions' in namespace 'std'\"\n// see https://github.com/catchorg/Catch2/issues/1201\n#define CATCH_INTERNAL_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS\n#define CATCH_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS\n\n#include <catch.hpp>\n\n\n// get the value of a particular parameter from the contents of the input\n// file. return an empty string if not found\nstd::string\nget_last_value_of_parameter(const std::string &parameters,\n                            const std::string &parameter_name)\n{\n  std::string return_value;\n\n  std::istringstream x_file(parameters);\n  while (x_file)\n    {\n      // get one line and strip spaces at the front and back\n      std::string line;\n      std::getline(x_file, line);\n      while ((line.size() > 0) && (line[0] == ' ' || line[0] == '\\t'))\n        line.erase(0, 1);\n      while ((line.size() > 0)\n             && (line[line.size() - 1] == ' ' || line[line.size() - 1] == '\\t'))\n        line.erase(line.size() - 1, std::string::npos);\n      // now see whether the line starts with 'set' followed by multiple spaces\n      // if not, try next line\n      if (line.size() < 4)\n        continue;\n\n      if ((line[0] != 's') || (line[1] != 'e') || (line[2] != 't')\n          || !(line[3] == ' ' || line[3] == '\\t'))\n        continue;\n\n      // delete the \"set \" and then delete more spaces if present\n      line.erase(0, 4);\n      while ((line.size() > 0) && (line[0] == ' ' || line[0] == '\\t'))\n        line.erase(0, 1);\n      // now see whether the next word is the word we look for\n      if (line.find(parameter_name) != 0)\n        continue;\n\n      line.erase(0, parameter_name.size());\n      while ((line.size() > 0) && (line[0] == ' ' || line[0] == '\\t'))\n        line.erase(0, 1);\n\n      // we'd expect an equals size here\n      if ((line.size() < 1) || (line[0] != '='))\n        continue;\n\n      // remove comment\n      std::string::size_type pos = line.find('#');\n      if (pos != std::string::npos)\n        line.erase (pos);\n\n      // trim the equals sign at the beginning and possibly following spaces\n      // as well as spaces at the end\n      line.erase(0, 1);\n      while ((line.size() > 0) && (line[0] == ' ' || line[0] == '\\t'))\n        line.erase(0, 1);\n      while ((line.size() > 0) && (line[line.size()-1] == ' ' || line[line.size()-1] == '\\t'))\n        line.erase(line.size()-1, std::string::npos);\n\n      // the rest should now be what we were looking for\n      return_value = line;\n    }\n\n  return return_value;\n}\n\n\n// Extract the dimension in which to run ASPECT from the\n// the contents of the parameter file. This is something that\n// we need to do before processing the parameter file since we\n// need to know whether to use the dim=2 or dim=3 instantiation\n// of the main classes.\n//\n// This function is essentially the first part of ASPECT to look at the input\n// file, so if something is wrong with it, this is the place to generate good\n// error messages.\nunsigned int\nget_dimension(const std::string &parameters)\n{\n  const std::string dimension = get_last_value_of_parameter(parameters, \"Dimension\");\n  if (dimension.size() > 0)\n    {\n      // A common problem is that people have .prm files that were generated\n      // on Windows, but then run this on Linux where the line endings are\n      // different. This is pernicious because it means that the conversion\n      // of a string such as \"2\\r\" to an integer fails, but if we print\n      // this string, it comes out completely garbled because it contains\n      // a carriage-return without a newline -- so the error message looks\n      // like this:\n      //\n      //    >.  While reading the dimension from the input file, ASPECT found a string that can not be converted to an integer: <2\n      //\n      // Note how the end of the error message overwrites the beginning\n      // of the line.\n      //\n      // To avoid this kind of error, specifically test up front that the\n      // text in question does not contain '\\r' characters. If we are on\n      // linux, then this kind of character would means that the line endings\n      // are wrong. On the other hand, if we are on windows, then the\n      // getline command we have used in finding 'dimension' would have\n      // filtered it out. So its presence points to a problem.\n\n      AssertThrow (dimension.find('\\r') == std::string::npos,\n                   dealii::ExcMessage (\"It appears that your input file uses Windows-style \"\n                                       \"line endings ('\\\\r\\\\n') but you are running on a system where \"\n                                       \"the C++ run time environment expects input files to have \"\n                                       \"Unix-style line endings ('\\\\n'). You need to convert your \"\n                                       \"input file to use the correct line endings before running \"\n                                       \"ASPECT with it.\"));\n      try\n        {\n          return dealii::Utilities::string_to_int (dimension);\n        }\n      catch (...)\n        {\n          AssertThrow (false,\n                       dealii::ExcMessage(\"While reading the dimension from the input file, \"\n                                          \"ASPECT found a string that can not be converted to \"\n                                          \"an integer: <\" + dimension + \">.\"));\n          return 0; // we should never get here.\n        }\n    }\n  else\n    return 2;\n}\n\n\n\n#if ASPECT_USE_SHARED_LIBS==1\n\n#ifdef ASPECT_HAVE_LINK_H\n// collect the names of the shared libraries linked to by this program. this\n// function is a callback for the dl_iterate_phdr() function we call below\nint get_names_of_shared_libs (struct dl_phdr_info *info,\n                              size_t,\n                              void *data)\n{\n  reinterpret_cast<std::set<std::string>*>(data)->insert (info->dlpi_name);\n  return 0;\n}\n#endif\n\n\n// make sure the list of shared libraries we currently link with\n// has deal.II only once\nvoid validate_shared_lib_list (const bool before_loading_shared_libs)\n{\n#ifdef ASPECT_HAVE_LINK_H\n  // get the list of all shared libs we currently link against\n  std::set<std::string> shared_lib_names;\n  dl_iterate_phdr(get_names_of_shared_libs, &shared_lib_names);\n\n  // find everything that is interesting\n  std::set<std::string> dealii_shared_lib_names;\n  for (std::set<std::string>::const_iterator p = shared_lib_names.begin();\n       p != shared_lib_names.end(); ++p)\n    if (p->find (\"libdeal_II\") != std::string::npos)\n      dealii_shared_lib_names.insert (*p);\n\n  // produce an error if we load deal.II more than once\n  if (dealii_shared_lib_names.size() != 1)\n    {\n      std::ostringstream error;\n      error << \"........................................................\\n\"\n            << \"ASPECT currently links against different versions of the\\n\"\n            << \"deal.II library, namely the ones at these locations:\\n\";\n      for (std::set<std::string>::const_iterator p = dealii_shared_lib_names.begin();\n           p != dealii_shared_lib_names.end(); ++p)\n        error << \"  \" << *p << '\\n';\n      error << \"This can not work.\\n\\n\";\n\n      if (before_loading_shared_libs)\n        error << \"Since this is happening already before opening additional\\n\"\n              << \"shared libraries, this means that something must have gone\\n\"\n              << \"wrong when you configured deal.II and/or ASPECT. Please\\n\"\n              << \"contact the mailing lists for help.\\n\";\n      else\n        error << \"Since this is happening after opening additional shared\\n\"\n              << \"library plugins, this likely means that you have compiled\\n\"\n              << \"ASPECT in release mode and the plugin in debug mode, or the\\n\"\n              << \"other way around. Please re-compile the plugin in the same\\n\"\n              << \"mode as ASPECT.\\n\";\n\n      error << \"........................................................\\n\";\n\n      // if not success, then throw an exception: ExcMessage on processor 0,\n      // QuietException on the others\n      if (dealii::Utilities::MPI::this_mpi_process (MPI_COMM_WORLD) == 0)\n        {\n          AssertThrow (false, dealii::ExcMessage (error.str()));\n        }\n      else\n        throw aspect::QuietException();\n    }\n#else\n  // simply mark the argument as read, to avoid compiler warnings\n  (void)before_loading_shared_libs;\n#endif\n}\n\n\n#endif\n\n\n// retrieve a list of shared libraries from the parameter file and\n// dlopen them so that we can load plugins declared in them\nvoid possibly_load_shared_libs (const std::string &parameters)\n{\n  using namespace dealii;\n\n\n  const std::string shared_libs\n    = get_last_value_of_parameter(parameters,\n                                  \"Additional shared libraries\");\n  if (shared_libs.size() > 0)\n    {\n#if ASPECT_USE_SHARED_LIBS==1\n      // check up front whether the list of shared libraries is internally\n      // consistent or whether we link, for whatever reason, with both the\n      // debug and release versions of deal.II\n      validate_shared_lib_list (true);\n\n      const std::vector<std::string>\n      shared_libs_list = Utilities::split_string_list (shared_libs);\n\n      for (unsigned int i=0; i<shared_libs_list.size(); ++i)\n        {\n          if (Utilities::MPI::this_mpi_process (MPI_COMM_WORLD) == 0)\n            std::cout << \"Loading shared library <\"\n                      << shared_libs_list[i]\n                      << \">\" << std::endl;\n\n          void *handle = dlopen (shared_libs_list[i].c_str(), RTLD_LAZY);\n          AssertThrow (handle != nullptr,\n                       ExcMessage (std::string(\"Could not successfully load shared library <\")\n                                   + shared_libs_list[i] + \">. The operating system reports \"\n                                   + \"that the error is this: <\"\n                                   + dlerror() + \">.\"));\n\n          // check again whether the list of shared libraries is\n          // internally consistent or whether we link with both the\n          // debug and release versions of deal.II. this may happen if\n          // the plugin was compiled against the debug version of\n          // deal.II but aspect itself against the release version, or\n          // the other way around\n          validate_shared_lib_list (false);\n\n          // on systems where we can detect that both libdeal_II.so and\n          // libdeal_II.g.so is loaded, the test above function above will\n          // throw an exception and we will terminate. on the other hand, on\n          // systems where we can't detect this we should at least mitigate\n          // some of the ill effects -- in particular, make sure that\n          // deallog is set to use the desired output depth since otherwise\n          // we get lots of output from the linear solvers\n          deallog.depth_console(0);\n        }\n\n      if (Utilities::MPI::this_mpi_process (MPI_COMM_WORLD) == 0)\n        std::cout << std::endl;\n#else\n      if (Utilities::MPI::this_mpi_process (MPI_COMM_WORLD) == 0)\n        {\n          std::cerr << std::endl << std::endl\n                    << \"----------------------------------------------------\"\n                    << std::endl;\n          std::cerr << \"You can not load plugins through additional shared libraries \" << std::endl\n                    << \"on systems where you link ASPECT as a static executable.\"\n                    << std::endl\n                    << \"----------------------------------------------------\"\n                    << std::endl;\n        }\n      std::exit (1);\n#endif\n    }\n}\n\n/*\n * Current implementation for reading from stdin requires use of a std::string,\n * so this function will read until the end of the stream\n */\nstd::string\nread_until_end (std::istream &input)\n{\n  std::string result;\n  while (input)\n    {\n      std::string line;\n      std::getline(input, line);\n\n      result += line + '\\n';\n    }\n  return result;\n}\n\n\n\n/**\n * Takes the name of a parameter file and return all parameters in that file\n * as a string. If @p parameter_file_name is \"--\" read the parameters from\n * std::cin instead.\n */\nstd::string\nread_parameter_file(const std::string &parameter_file_name)\n{\n  using namespace dealii;\n\n  std::string input_as_string;\n  const bool i_am_proc_0 = (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0);\n\n  if (parameter_file_name != \"--\")\n    {\n      std::ifstream parameter_file(parameter_file_name.c_str());\n      if (!parameter_file)\n        {\n          if (parameter_file_name==\"parameter-file.prm\"\n              || parameter_file_name==\"parameter_file.prm\")\n            {\n              std::cerr << \"***          You should not take everything literally!          ***\\n\"\n                        << \"*** Please pass the name of an existing parameter file instead. ***\" << std::endl;\n              exit(1);\n            }\n\n          if (i_am_proc_0)\n            std::cerr << \"Error: Input parameter file <\" << parameter_file_name << \"> not found.\"\n                      << std::endl;\n          throw aspect::QuietException();\n          return \"\";\n        }\n\n      input_as_string = read_until_end (parameter_file);\n    }\n  else\n    {\n      // As stated in the help string, treat \"--\" as special: as is common\n      // on unix, treat it as a way to read input from stdin.\n      // Unfortunately, if you do\n      //    echo \"abc\" | mpirun -np 4 ./aspect\n      // then only MPI process 0 gets the data. so we have to\n      // read it there, then broadcast it to the other processors\n      if (i_am_proc_0)\n        {\n          input_as_string = read_until_end (std::cin);\n          int size = input_as_string.size()+1;\n          MPI_Bcast (&size,\n                     1,\n                     MPI_INT,\n                     /*root=*/0, MPI_COMM_WORLD);\n          MPI_Bcast (const_cast<char *>(input_as_string.c_str()),\n                     size,\n                     MPI_CHAR,\n                     /*root=*/0, MPI_COMM_WORLD);\n        }\n      else\n        {\n          // on this side, read what processor zero has broadcast about\n          // the size of the input file. then create a buffer to put the\n          // text in, get it from processor 0, and copy it to\n          // input_as_string\n          int size;\n          MPI_Bcast (&size, 1,\n                     MPI_INT,\n                     /*root=*/0, MPI_COMM_WORLD);\n\n          std::vector<char> p (size);\n          MPI_Bcast (p.data(), size,\n                     MPI_CHAR,\n                     /*root=*/0, MPI_COMM_WORLD);\n          input_as_string = p.data();\n        }\n    }\n\n  return input_as_string;\n}\n\n\n\n/**\n * Let ParameterHandler parse the input file, here given as a string.\n * Since ParameterHandler unconditionally writes to the screen when it\n * finds something it doesn't like, we get massive amounts of output\n * in parallel computations since every processor writes the same\n * stuff to screen. To avoid this, let processor 0 parse the input\n * first and, if necessary, produce its output. Only if this\n * succeeds, also let the other processors read their input.\n *\n * In case of an error, we need to abort all processors without them\n * having read their data. This is done by throwing an exception of the\n * special class aspect::QuietException that we can catch in main() and terminate\n * the program quietly without generating other output.\n */\nvoid\nparse_parameters (const std::string &input_as_string,\n                  dealii::ParameterHandler  &prm)\n{\n  // try reading on processor 0\n  bool success = true;\n  if (dealii::Utilities::MPI::this_mpi_process (MPI_COMM_WORLD) == 0)\n    try\n      {\n        prm.parse_input_from_string(input_as_string.c_str());\n      }\n    catch (const dealii::ExceptionBase &e)\n      {\n        success = false;\n        e.print_info(std::cerr);\n        std::cerr << std::endl;\n      }\n\n\n  // broadcast the result. we'd like to do this with a bool\n  // data type but MPI_C_BOOL is not part of old MPI standards.\n  // so, do the broadcast in integers\n  {\n    int isuccess = (success ? 1 : 0);\n    MPI_Bcast (&isuccess, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    success = (isuccess == 1);\n  }\n\n  // if not success, then throw an exception: ExcMessage on processor 0,\n  // QuietException on the others\n  if (success == false)\n    {\n      if (dealii::Utilities::MPI::this_mpi_process (MPI_COMM_WORLD) == 0)\n        {\n          AssertThrow(false, dealii::ExcMessage (\"Invalid input parameter file.\"));\n        }\n      else\n        throw aspect::QuietException();\n    }\n\n  // otherwise, processor 0 was ok reading the data, so we can expect the\n  // other processors will be ok as well\n  if (dealii::Utilities::MPI::this_mpi_process (MPI_COMM_WORLD) != 0)\n    {\n      prm.parse_input_from_string(input_as_string.c_str());\n    }\n}\n\n\n\n/**\n * Print help text\n */\nvoid print_help()\n{\n  std::cout << \"Usage: ./aspect [args] <parameter_file.prm>   (to read from an input file)\\n\"\n            << \"    or ./aspect [args] --                     (to read parameters from stdin)\\n\"\n            << std::endl;\n  std::cout << \"    optional arguments [args]:\\n\"\n            << \"       -h, --help             (for this usage help)\\n\"\n            << \"       -v, --version          (for information about library versions)\\n\"\n            << \"       -j, --threads          (to use multi-threading)\\n\"\n            << \"       --output-xml           (print parameters in xml format to standard output and exit)\\n\"\n            << \"       --output-plugin-graph  (write a representation of all plugins to standard output and exit)\\n\"\n            << \"       --validate             (parse parameter file and exit or report errors)\\n\"\n            << \"       --test                 (run the unit tests from unit_tests/, run --test -h for more info)\\n\"\n            << std::endl;\n}\n\n\n\n// hook into SIGABRT/SIGFPE and kill off the program\nvoid signal_handler(int signal)\n{\n  if (signal == SIGABRT)\n    {\n      std::cerr << \"SIGABRT received\\n\";\n    }\n  else if (signal == SIGFPE)\n    {\n      std::cerr << \"SIGFPE received\\n\";\n    }\n  else\n    {\n      std::cerr << \"Unexpected signal \" << signal << \" received\\n\";\n    }\n#if DEAL_II_USE_CXX11\n  // Kill the program without performing any other cleanup, which is likely to\n  // lead to a deadlock\n  std::_Exit(EXIT_FAILURE);\n#else\n  // Kill the program, or at least try to. The problem when we get here is\n  // that calling std::exit invokes at_exit() functions that may still hang\n  // the MPI system\n  std::exit(1);\n#endif\n}\n\n\n\ntemplate<int dim>\nvoid\nrun_simulator(const std::string &raw_input_as_string,\n              const std::string &input_as_string,\n              const bool output_xml,\n              const bool output_plugin_graph,\n              const bool validate_only)\n{\n  using namespace dealii;\n\n  ParameterHandler prm;\n  const bool i_am_proc_0 = (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0);\n  aspect::Simulator<dim>::declare_parameters(prm);\n\n  if (validate_only)\n    {\n      try\n        {\n          parse_parameters (input_as_string, prm);\n        }\n      catch (...)\n        {\n          throw aspect::QuietException();\n        }\n      if (i_am_proc_0)\n        std::cout << \"The provided parameter file is valid.\"\n                  \"\\n\\n\"\n                  \"Note: This validation only checks parameter file syntax errors, like typos\\n\"\n                  \"in keywords or parameter names, and that each parameter value satisfies a\\n\"\n                  \"basic check by itself. However, it may miss more nuanced errors that\\n\"\n                  \"are only checked when the model actually begins running. In particular,\\n\"\n                  \"checks that involve two or more parameters can not be verified at this\\n\"\n                  \"stage of an ASPECT run. Examples for such errors that can not already\\n\"\n                  \"be reported here are: (i) That every boundary is assigned exactly one type\\n\"\n                  \"of boundary condition; (ii) that parameters that take a list with values for\\n\"\n                  \"each composition field receive a list of the correct size.\"\n                  << std::endl;\n      return;\n    }\n\n  parse_parameters (input_as_string, prm);\n\n  if (output_xml)\n    {\n      if (i_am_proc_0)\n        prm.print_parameters(std::cout, ParameterHandler::XML);\n    }\n  else if (output_plugin_graph)\n    {\n      aspect::Simulator<dim> simulator(MPI_COMM_WORLD, prm);\n      if (i_am_proc_0)\n        simulator.write_plugin_graph (std::cout);\n    }\n  else\n    {\n      aspect::Simulator<dim> simulator(MPI_COMM_WORLD, prm);\n      if (i_am_proc_0)\n        {\n          // write create output/original.prm containing exactly what we got\n          // started with:\n          std::string output_directory = prm.get (\"Output directory\");\n          if (output_directory.size() == 0)\n            output_directory = \"./\";\n          else if (output_directory[output_directory.size()-1] != '/')\n            output_directory += \"/\";\n\n          std::ofstream file(output_directory + \"original.prm\");\n          file << raw_input_as_string;\n        }\n\n      simulator.run();\n    }\n}\n\n\n\nint main (int argc, char *argv[])\n{\n  using namespace dealii;\n\n#ifdef DEBUG\n#ifdef ASPECT_USE_FP_EXCEPTIONS\n  // Some implementations seem to not initialize the floating point exception\n  // bits to zero. Make sure we start from a clean state.\n  feclearexcept(FE_DIVBYZERO|FE_INVALID);\n\n  // enable floating point exceptions\n  feenableexcept(FE_DIVBYZERO|FE_INVALID);\n#endif\n#endif\n\n  std::string prm_name = \"\";\n  bool output_xml          = false;\n  bool output_plugin_graph = false;\n  bool output_version      = false;\n  bool output_help         = false;\n  bool use_threads         = false;\n  bool run_unittests       = false;\n  bool validate_only       = false;\n  int current_argument = 1;\n\n  // Loop over all command line arguments. Handle a number of special ones\n  // starting with a dash, and then take the first non-special one as the\n  // name of the input file. We will later check that there are no further\n  // arguments left after that (though there may be with PETSc, see\n  // below).\n  while (current_argument<argc)\n    {\n      const std::string arg = argv[current_argument];\n      ++current_argument;\n      if (arg == \"--output-xml\")\n        {\n          output_xml = true;\n        }\n      else if (arg == \"--output-plugin-graph\")\n        {\n          output_plugin_graph = true;\n        }\n      else if (arg==\"-h\" || arg ==\"--help\")\n        {\n          output_help = true;\n        }\n      else if (arg==\"-v\" || arg ==\"--version\")\n        {\n          output_version = true;\n        }\n      else if (arg==\"-j\" || arg ==\"--threads\")\n        {\n#ifdef ASPECT_USE_PETSC\n          std::cerr << \"Using multiple threads (using -j) is not supported when using PETSc for linear algebra. Exiting.\" << std::endl;\n          return -1;\n#else\n          use_threads = true;\n#endif\n        }\n      else if (arg == \"--test\")\n        {\n          run_unittests = true;\n          break;\n        }\n      else if (arg == \"--validate\")\n        {\n          validate_only = true;\n        }\n      else\n        {\n          // Not a special argument, so we assume that this is the .prm\n          // filename (or \"--\"). We can now break out of this loop because\n          // we are not going to parse arguments passed after the filename.\n          prm_name = arg;\n          break;\n        }\n    }\n\n  // There might be remaining arguments for PETSc, only hand those over to\n  // the MPI initialization, but not the ones we parsed above.\n  int n_remaining_arguments = argc - current_argument;\n  char **remaining_arguments = (n_remaining_arguments > 0) ? &argv[current_argument] : nullptr;\n\n  try\n    {\n      // Note: we initialize this class inside the try/catch block and not\n      // before, so that the destructor of this instance can react if we are\n      // currently unwinding the stack if an unhandled exception is being\n      // thrown to avoid MPI deadlocks.\n      Utilities::MPI::MPI_InitFinalize mpi_initialization(n_remaining_arguments, remaining_arguments, use_threads ? numbers::invalid_unsigned_int : 1);\n\n      if (run_unittests)\n        {\n          // Construct new_argc, new_argv from argc, argv for catch without\n          // the \"--test\" arg, so we can control catch from the command\n          // line. It turns out catch needs argv[0] to be the executable name\n          // so we can not use remaining_arguments from above.\n          int new_argc = n_remaining_arguments + 1;\n          std::vector<char *> args; // use to construct a new argv of type char **\n          args.emplace_back(argv[0]);\n          for (int i=0; i<n_remaining_arguments; ++i)\n            args.emplace_back(argv[i+current_argument]);\n          char **new_argv = args.data();\n\n          // Finally run catch\n          return Catch::Session().run(new_argc, new_argv);\n        }\n\n\n      deallog.depth_console(0);\n\n      const bool i_am_proc_0 = (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0);\n\n      if (i_am_proc_0)\n        {\n          // Output header, except for a clean output for xml or plugin graph\n          if (!output_xml && !output_plugin_graph && !validate_only)\n            print_aspect_header(std::cout);\n\n          if (output_help)\n            print_help();\n\n          // If only help or version is requested, we are done.\n          if (output_help || output_version)\n            return 0;\n        }\n      else\n        {\n          // We hook into the abort handler on ranks != 0 to avoid an MPI\n          // deadlock. The deal.II library will call std::abort() when an\n          // Assert is triggered, which can lead to a deadlock because it\n          // runs the things that are associated with atexit() which may\n          // itself trigger MPI communication. The same happens for other\n          // signals we may trigger, such as floating point exceptions\n          // (SIGFPE).\n          //\n          // We work around this by immediately calling _Exit in the\n          // signal handler and thus aborting the program without running\n          // cleanup functions set via atexit(). This is only necessary on\n          // rank != 0 for some reason.\n          std::signal(SIGABRT, signal_handler);\n          std::signal(SIGFPE, signal_handler);\n        }\n\n      // If no parameter given or somebody gave additional parameters,\n      // show help and exit. However, this does not work with PETSc because for\n      // PETSc, one may pass any number of flags on the command line.\n      if ((prm_name == \"\")\n#ifndef ASPECT_USE_PETSC\n          || (current_argument < argc)\n#endif\n         )\n        {\n          if (i_am_proc_0)\n            print_help();\n          return 2;\n        }\n\n      // See where to read input from, then do the reading and\n      // put the contents of the input into a string.\n      const std::string raw_input_as_string = read_parameter_file(prm_name);\n\n      // Replace $ASPECT_SOURCE_DIR in the input so that include statements\n      // like \"include $ASPECT_SOURCE_DIR/tests/bla.prm\" work.\n      const std::string input_as_string = aspect::Utilities::expand_ASPECT_SOURCE_DIR(raw_input_as_string);\n\n      // Determine the dimension we want to work in. the default\n      // is 2, but if we find a line of the kind \"set Dimension = ...\"\n      // then the last such line wins.\n      const unsigned int dim = get_dimension(input_as_string);\n\n      // Do the same with lines potentially indicating shared libs to\n      // be loaded. These shared libs could contain additional module\n      // instantiations for geometries, etc, that would then be\n      // available as part of the possible parameters of the input\n      // file, so they need to be loaded before we even start processing\n      // the parameter file.\n      possibly_load_shared_libs (input_as_string);\n\n      // Now switch between the templates that start the model for 2d or 3d.\n      switch (dim)\n        {\n          case 2:\n          {\n            run_simulator<2>(raw_input_as_string,input_as_string,output_xml,output_plugin_graph,validate_only);\n            break;\n          }\n          case 3:\n          {\n            run_simulator<3>(raw_input_as_string,input_as_string,output_xml,output_plugin_graph,validate_only);\n            break;\n          }\n          default:\n            AssertThrow((dim >= 2) && (dim <= 3),\n                        ExcMessage (\"ASPECT can only be run in 2d and 3d but a \"\n                                    \"different space dimension is given in the parameter file.\"));\n        }\n    }\n  catch (ExceptionBase &exc)\n    {\n      // report name of the deal.II exception:\n      std::cerr << std::endl << std::endl\n                << \"----------------------------------------------------\"\n                << std::endl;\n      std::cerr << \"Exception '\" << exc.get_exc_name() << \"'\"\n                << \" on rank \" << Utilities::MPI::this_mpi_process(MPI_COMM_WORLD)\n                << \" on processing: \" << std::endl\n                << exc.what() << std::endl\n                << \"Aborting!\" << std::endl\n                << \"----------------------------------------------------\"\n                << std::endl;\n      return 1;\n    }\n  catch (std::exception &exc)\n    {\n      std::cerr << std::endl << std::endl\n                << \"----------------------------------------------------\"\n                << std::endl;\n      std::cerr << \"Exception\"\n                << \" on rank \" << Utilities::MPI::this_mpi_process(MPI_COMM_WORLD)\n                << \" on processing: \" << std::endl\n                << exc.what() << std::endl\n                << \"Aborting!\" << std::endl\n                << \"----------------------------------------------------\"\n                << std::endl;\n      return 1;\n    }\n  catch (aspect::QuietException &)\n    {\n      // Quietly treat an exception used on processors other than\n      // root when we already know that processor 0 will generate\n      // an exception. We do this to avoid creating too much\n      // (duplicate) screen output.\n      return 1;\n    }\n  catch (...)\n    {\n      std::cerr << std::endl << std::endl\n                << \"----------------------------------------------------\"\n                << std::endl;\n      std::cerr << \"Unknown exception!\" << std::endl\n                << \"Aborting!\" << std::endl\n                << \"----------------------------------------------------\"\n                << std::endl;\n      return 1;\n    }\n\n  return 0;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-aspect-2.1.0-onf27hdmtbgkpk4htrfbnw5memdk3il6/spack-src/tests/ascii_data_initial_temperature_3d_chunk/.screen-output.swp",
        "/tmp/vanessa/spack-stage/spack-stage-aspect-2.1.0-onf27hdmtbgkpk4htrfbnw5memdk3il6/spack-src/benchmarks/king2dcompressible/results.ods",
        "/tmp/vanessa/spack-stage/spack-stage-aspect-2.1.0-onf27hdmtbgkpk4htrfbnw5memdk3il6/spack-src/benchmarks/geoid-spectral-comparison/spectral-comparison.png",
        "/tmp/vanessa/spack-stage/spack-stage-aspect-2.1.0-onf27hdmtbgkpk4htrfbnw5memdk3il6/spack-src/contrib/WorldBuilder/doc/manual/images/simple_subducting_plate_example_segments.png",
        "/tmp/vanessa/spack-stage/spack-stage-aspect-2.1.0-onf27hdmtbgkpk4htrfbnw5memdk3il6/spack-src/contrib/WorldBuilder/doc/manual/images/spherical_approximations_line.png",
        "/tmp/vanessa/spack-stage/spack-stage-aspect-2.1.0-onf27hdmtbgkpk4htrfbnw5memdk3il6/spack-src/contrib/WorldBuilder/doc/manual/images/world_builder_logo_v4.png",
        "/tmp/vanessa/spack-stage/spack-stage-aspect-2.1.0-onf27hdmtbgkpk4htrfbnw5memdk3il6/spack-src/contrib/WorldBuilder/doc/manual/images/simple_subducting_plate_example.png",
        "/tmp/vanessa/spack-stage/spack-stage-aspect-2.1.0-onf27hdmtbgkpk4htrfbnw5memdk3il6/spack-src/contrib/WorldBuilder/doc/manual/images/spherical_approximations_spiral.png",
        "/tmp/vanessa/spack-stage/spack-stage-aspect-2.1.0-onf27hdmtbgkpk4htrfbnw5memdk3il6/spack-src/contrib/WorldBuilder/doc/manual/images/manual_subduction_section_segments_dist_all_v3_small.png",
        "/tmp/vanessa/spack-stage/spack-stage-aspect-2.1.0-onf27hdmtbgkpk4htrfbnw5memdk3il6/spack-src/cookbooks/muparser_temperature_example/temperature_muparser_if.pdf"
    ],
    "total_files": 2564
}