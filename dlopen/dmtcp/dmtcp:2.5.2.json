{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/src/nosyscallsreal.c": "/****************************************************************************\n *   Copyright (C) 2006-2010 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *  This file is part of DMTCP.                                             *\n *                                                                          *\n *  DMTCP is free software: you can redistribute it and/or                  *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP is distributed in the hope that it will be useful,                *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n\n#define _GNU_SOURCE\n#define _XOPEN_SOURCE 500\n// These next two are defined in features.h based on the user macros above.\n// #define GNU_SRC\n// #define __USE_UNIX98\n\n// FIXME:  See comment in syscallwrappers.h about how to remove the need for\n//         this extra declaration.\n#define FOR_SYSCALLSREAL_C\n\n#include <pthread.h>\n// We should not need dlopen/dlsym\n// #include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/syscall.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <syslog.h>\n#include \"constants.h\"\n#include \"syscallwrappers.h\"\n\n// See syscallsreal.c for original model.  In libdmtcp.so, system calls\n//   for XXX() in jalib call a wrapper which modifies it and calls\n//   syscallsreal.c:_real_XXX(), to directly calls kernel.\n// For other functions (dmtcp_launch, dmtcp_restart, etc.),\n//   we want their invocations of jalib to directly call glibc with no wrappers.\n// Jalib has some calls to real_XXX() to avoid going through the wrapper.\n//   Those are defined in syscallsreal.cpp, but this is a simpler interface\n//   that avoids calling on dlsym() and syscallsreal.cpp (by calling this\n//   smaller image, jnosyscallsreal.cpp), in order to keep those\n//   binaries smaller, and to keep the code simpler and more maintainable.\n//   Can add wrapper code for libhijack.so without fear of contaminating\n//   the other DMTCP executables with that wrapper.\n\n// NOTE:  An alternative to this strategy would be to put this in a file,\n//   nosyscallwrappers.h and #define away the real_XXX() calls.\n//   But some files like uniquepid.cpp and connection.cpp could be\n//   linked either to libdmtcp.so or to dmtcp_restart.\n\n/// FIXME:  dmtcpworker.cpp is linked into some ordinary executables.\n///         It should be modified to avoid this, so we don't need gratuitous\n///         extra reall_syscalls here like dmtcp_unsetenv(), dmtcp_lock()\n\n//////////////////////////\n//// DEFINE REAL VERSIONS OF NEEDED FUNCTIONS (based on syscallsreal.cpp)\n//// (Define only functions needed for dmtcp_launch, dmtcp_restart, etc.\n\nstatic pthread_mutex_t theMutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;\n\n#define REAL_FUNC_PASSTHROUGH(name) return name\n\n#define REAL_FUNC_PASSTHROUGH_TYPED(type, name) REAL_FUNC_PASSTHROUGH(name)\n#define REAL_FUNC_PASSTHROUGH_TYPED_DLSYM(type, name) return dlsym(RTLD_NEXT, #name)\n\n#define REAL_FUNC_PASSTHROUGH_PID_T(name) REAL_FUNC_PASSTHROUGH(name)\n\n// No return statement for functions returning void:\n#define REAL_FUNC_PASSTHROUGH_VOID(name) name\n\n#define SYMBOL_NOT_FOUND_ERROR(name) \\\n  fprintf(stderr, \"ERROR: DMTCP internal error.\\n\" \\\n                  \"  Symbol %s not found!\\n\", #name); \\\n  abort(); \\\n  return -1;\n\nvoid _dmtcp_lock() { pthread_mutex_lock (&theMutex); }\nvoid _dmtcp_unlock() { pthread_mutex_unlock (&theMutex); }\n\nvoid initialize_wrappers() {\n  return;\n}\n\nint _real_pthread_mutex_lock(pthread_mutex_t *mutex) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_mutex_lock) (mutex);\n}\n\nint _real_pthread_mutex_trylock(pthread_mutex_t *mutex) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_mutex_trylock) (mutex);\n}\n\nint _real_pthread_mutex_unlock(pthread_mutex_t *mutex) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_mutex_unlock) (mutex);\n}\n\nint _real_pthread_rwlock_unlock(pthread_rwlock_t *rwlock) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_rwlock_unlock) (rwlock);\n}\n\nint _real_pthread_rwlock_rdlock(pthread_rwlock_t *rwlock) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_rwlock_rdlock) (rwlock);\n}\n\nint _real_pthread_rwlock_wrlock(pthread_rwlock_t *rwlock) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_rwlock_wrlock) (rwlock);\n}\n\nssize_t _real_read(int fd, void *buf, size_t count) {\n  REAL_FUNC_PASSTHROUGH (read) (fd,buf,count);\n}\n\nssize_t _real_write(int fd, const void *buf, size_t count) {\n  REAL_FUNC_PASSTHROUGH_TYPED (ssize_t,write) (fd,buf,count);\n}\n\nint _real_select(int nfds, fd_set *readfds, fd_set *writefds,\n                 fd_set *exceptfds, struct timeval *timeout) {\n  REAL_FUNC_PASSTHROUGH (select) (nfds,readfds,writefds,exceptfds,timeout);\n}\n\n/// call the libc version of this function via dlopen/dlsym\nint _real_socket (int domain, int type, int protocol)\n{\n  REAL_FUNC_PASSTHROUGH (socket) (domain,type,protocol);\n}\n\n/// call the libc version of this function via dlopen/dlsym\nint _real_connect (int sockfd,  const  struct sockaddr *serv_addr, socklen_t addrlen)\n{\n  REAL_FUNC_PASSTHROUGH (connect) (sockfd,serv_addr,addrlen);\n}\n\n/// call the libc version of this function via dlopen/dlsym\nint _real_bind (int sockfd,  const struct  sockaddr  *my_addr,  socklen_t addrlen)\n{\n  REAL_FUNC_PASSTHROUGH (bind) (sockfd,my_addr,addrlen);\n}\n\n/// call the libc version of this function via dlopen/dlsym\nint _real_listen (int sockfd, int backlog)\n{\n  REAL_FUNC_PASSTHROUGH (listen) (sockfd,backlog);\n}\n\n/// call the libc version of this function via dlopen/dlsym\nint _real_accept (int sockfd, struct sockaddr *addr, socklen_t *addrlen)\n{\n  REAL_FUNC_PASSTHROUGH (accept) (sockfd,addr,addrlen);\n}\n\n/// call the libc version of this function via dlopen/dlsym\nint _real_setsockopt (int s, int  level,  int  optname,  const  void  *optval,\n                       socklen_t optlen)\n{\n  REAL_FUNC_PASSTHROUGH (setsockopt) (s,level,optname,optval,optlen);\n}\n\nint _real_getsockopt (int s, int  level,  int  optname,  void  *optval,\n                       socklen_t* optlen)\n{\n  REAL_FUNC_PASSTHROUGH (getsockopt) (s,level,optname,optval,optlen);\n}\n\nint _real_execve (const char *filename, char *const argv[],\n                   char *const envp[])\n{\n  REAL_FUNC_PASSTHROUGH (execve) (filename,argv,envp);\n}\n\nint _real_execv (const char *path, char *const argv[])\n{\n  REAL_FUNC_PASSTHROUGH (execv) (path,argv);\n}\n\nint _real_execvp (const char *file, char *const argv[])\n{\n  REAL_FUNC_PASSTHROUGH (execvp) (file,argv);\n}\n\nint _real_system (const char *cmd)\n{\n  REAL_FUNC_PASSTHROUGH (system) (cmd);\n}\n\npid_t _real_fork(void)\n{\n  REAL_FUNC_PASSTHROUGH_PID_T (fork) ();\n}\n\nint _real_close (int fd)\n{\n  REAL_FUNC_PASSTHROUGH (close) (fd);\n}\n\nint _real_fclose (FILE *fp)\n{\n  REAL_FUNC_PASSTHROUGH (fclose) (fp);\n}\n\nint _real_dup (int oldfd)\n{\n  REAL_FUNC_PASSTHROUGH (dup) (oldfd);\n}\n\nint _real_dup2 (int oldfd, int newfd)\n{\n  REAL_FUNC_PASSTHROUGH (dup2) (oldfd, newfd);\n}\n\n//int _real_dup3 (int oldfd, int newfd, int flags)\n//{\n//  REAL_FUNC_PASSTHROUGH (dup3) (oldfd, newfd, flags);\n//}\n\nvoid _real_exit (int status)\n{\n  REAL_FUNC_PASSTHROUGH_VOID (exit) (status);\n}\n\nLIB_PRIVATE\nint _real_fcntl(int fd, int cmd, void *arg)\n{\n  REAL_FUNC_PASSTHROUGH (fcntl) (fd, cmd, arg);\n}\n\nint _real_ptsname_r (int fd, char * buf, size_t buflen)\n{\n  REAL_FUNC_PASSTHROUGH (ptsname_r) (fd, buf, buflen);\n}\n\nint _real_socketpair (int d, int type, int protocol, int sv[2])\n{\n  REAL_FUNC_PASSTHROUGH (socketpair) (d,type,protocol,sv);\n}\n\nvoid _real_openlog (const char *ident, int option, int facility)\n{\n  REAL_FUNC_PASSTHROUGH_VOID (openlog) (ident,option,facility);\n}\n\nvoid _real_closelog (void)\n{\n  REAL_FUNC_PASSTHROUGH_VOID (closelog) ();\n}\n\nint _dmtcp_unsetenv(const char *name) {\n  REAL_FUNC_PASSTHROUGH (unsetenv) (name);\n}\n\noff_t _real_lseek(int fd, off_t offset, int whence) {\n  REAL_FUNC_PASSTHROUGH_TYPED (off_t,lseek) (fd,offset,whence);\n}\n\npid_t _real_getpid(void) {\n  REAL_FUNC_PASSTHROUGH_PID_T (getpid) ();\n}\n\npid_t _real_getppid(void) {\n  REAL_FUNC_PASSTHROUGH_PID_T (getppid) ();\n}\n\nint _real_tcsetpgrp(int fd, pid_t pgrp) {\n  REAL_FUNC_PASSTHROUGH (tcsetpgrp) (fd, pgrp);\n}\n\nint _real_tcgetpgrp(int fd) {\n  REAL_FUNC_PASSTHROUGH (tcgetpgrp) (fd);\n}\n\npid_t _real_getpgrp(void) {\n  REAL_FUNC_PASSTHROUGH_PID_T (getpgrp) ();\n}\n\npid_t _real_setpgrp(void) {\n  REAL_FUNC_PASSTHROUGH_PID_T (setpgrp) ();\n}\n\npid_t _real_getpgid(pid_t pid) {\n  REAL_FUNC_PASSTHROUGH_PID_T (getpgid) (pid);\n}\n\nint   _real_setpgid(pid_t pid, pid_t pgid) {\n  REAL_FUNC_PASSTHROUGH (setpgid) (pid, pgid);\n}\n\npid_t _real_getsid(pid_t pid) {\n  REAL_FUNC_PASSTHROUGH_PID_T (getsid) (pid);\n}\n\npid_t _real_setsid(void) {\n  REAL_FUNC_PASSTHROUGH_PID_T (setsid) ();\n}\n\nint   _real_kill(pid_t pid, int sig) {\n  REAL_FUNC_PASSTHROUGH (kill) (pid, sig);\n}\n\npid_t _real_wait(__WAIT_STATUS stat_loc) {\n  REAL_FUNC_PASSTHROUGH_PID_T (wait) (stat_loc);\n}\n\npid_t _real_waitpid(pid_t pid, int *stat_loc, int options) {\n  REAL_FUNC_PASSTHROUGH_PID_T (waitpid) (pid, stat_loc, options);\n}\n\nint   _real_waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options) {\n  REAL_FUNC_PASSTHROUGH (waitid) (idtype, id, infop, options);\n}\n\npid_t _real_wait3(__WAIT_STATUS status, int options, struct rusage *rusage) {\n  REAL_FUNC_PASSTHROUGH_PID_T (wait3) (status, options, rusage);\n}\n\npid_t _real_wait4(pid_t pid, __WAIT_STATUS status, int options, struct rusage *rusage) {\n  REAL_FUNC_PASSTHROUGH_PID_T (wait4) (pid, status, options, rusage);\n}\n\nint send_sigwinch; /* not used.  Only version in pidwrappers.cpp is used */\nint _real_ioctl(int d, unsigned long int request, ...) {\n  void * arg;\n  va_list ap;\n\n  // Most calls to ioctl take 'void *', 'int' or no extra argument\n  // A few specialized ones take more args, but we don't need to handle those.\n  va_start(ap, request);\n  arg = va_arg(ap, void *);\n  va_end(ap);\n\n  // /usr/include/unistd.h says syscall returns long int (contrary to man page)\n  REAL_FUNC_PASSTHROUGH_TYPED (int, ioctl) (d, request, arg);\n}\n\nLIB_PRIVATE\nvoid *_real_mmap(void *addr, size_t length, int prot, int flags,\n    int fd, off_t offset) {\n  REAL_FUNC_PASSTHROUGH_TYPED (void*, mmap) (addr,length,prot,flags,fd,offset);\n}\n\nLIB_PRIVATE\nint _real_munmap(void *addr, size_t length) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int, munmap) (addr, length);\n}\n\n\n// Needed for _real_gettid, etc.\nlong _real_syscall(long sys_num, ...) {\n  int i;\n  void * arg[7];\n  va_list ap;\n\n  va_start(ap, sys_num);\n  for (i = 0; i < 7; i++)\n    arg[i] = va_arg(ap, void *);\n  va_end(ap);\n\n  // /usr/include/unistd.h says syscall returns long int (contrary to man page)\n  REAL_FUNC_PASSTHROUGH_TYPED (long, syscall) (sys_num, arg[0],\n                                               arg[1], arg[2],\n                                               arg[3], arg[4],\n                                               arg[5], arg[6]);\n}\n\nLIB_PRIVATE pid_t dmtcp_gettid() {\n  return syscall(SYS_gettid);\n}\nLIB_PRIVATE int dmtcp_tkill(int tid, int sig) {\n  return syscall(SYS_tkill, tid, sig);\n}\nLIB_PRIVATE int dmtcp_tgkill(int tgid, int tid, int sig) {\n  return syscall(SYS_tgkill, tgid, tid, sig);\n}\n\nint _real_open (const char *pathname, int flags, ...) {\n  mode_t mode = 0;\n  // Handling the variable number of arguments\n  if (flags & O_CREAT) {\n    va_list arg;\n    va_start (arg, flags);\n    mode = va_arg (arg, int);\n    va_end (arg);\n  }\n  REAL_FUNC_PASSTHROUGH (open) (pathname, flags, mode);\n}\n\nint _real_open64 (const char *pathname, int flags, ...) {\n  mode_t mode = 0;\n  // Handling the variable number of arguments\n  if (flags & O_CREAT) {\n    va_list arg;\n    va_start (arg, flags);\n    mode = va_arg (arg, int);\n    va_end (arg);\n  }\n  REAL_FUNC_PASSTHROUGH (open) (pathname, flags, mode);\n}\n\nFILE * _real_fopen(const char *path, const char *mode) {\n  REAL_FUNC_PASSTHROUGH_TYPED (FILE *, fopen) (path, mode);\n}\n\nFILE * _real_fopen64(const char *path, const char *mode) {\n  REAL_FUNC_PASSTHROUGH_TYPED (FILE *, fopen64) (path, mode);\n}\n\nint _real_shmget (key_t key, size_t size, int shmflg) {\n  REAL_FUNC_PASSTHROUGH (shmget) (key, size, shmflg);\n}\n\nvoid* _real_shmat (int shmid, const void *shmaddr, int shmflg) {\n  REAL_FUNC_PASSTHROUGH_TYPED (void*, shmat) (shmid, shmaddr, shmflg);\n}\n\nint _real_shmdt (const void *shmaddr) {\n  REAL_FUNC_PASSTHROUGH (shmdt) (shmaddr);\n}\n\nint _real_shmctl (int shmid, int cmd, struct shmid_ds *buf) {\n  REAL_FUNC_PASSTHROUGH (shmctl) (shmid, cmd, buf);\n}\n\nLIB_PRIVATE\nint _real_poll(struct pollfd *fds, nfds_t nfds, int timeout) {\n  REAL_FUNC_PASSTHROUGH (poll) (fds, nfds, timeout);\n}\n\nssize_t _real_readlink(const char *path, char *buf, size_t bufsiz) {\n  REAL_FUNC_PASSTHROUGH_TYPED (ssize_t, readlink) (path, buf, bufsiz);\n}\n\n// Used for wrappers for mmap, sbrk\nvoid _dmtcp_setup_trampolines() {}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/src/syscallsreal.c": "/****************************************************************************\n *   Copyright (C) 2006-2010 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *  This file is part of DMTCP.                                             *\n *                                                                          *\n *  DMTCP is free software: you can redistribute it and/or                  *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP is distributed in the hope that it will be useful,                *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#define _GNU_SOURCE\n#define _XOPEN_SOURCE 500\n// These next two are defined in features.h based on the user macros above.\n// #define GNU_SRC\n// #define __USE_UNIX98\n\n// FIXME:  See comment in syscallsreal.h about how to remove the need for\n//         this extra declaration.\n#define FOR_SYSCALLSREAL_C\n\n#include <malloc.h>\n#include <pthread.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <pthread.h>\n#include <poll.h>\n#include <fcntl.h>\n#include \"constants.h\"\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"syscallwrappers.h\"\n#include \"dmtcp_dlsym.h\"\n#include \"trampolines.h\"\n\ntypedef int (*funcptr_t) ();\ntypedef pid_t (*funcptr_pid_t) ();\ntypedef funcptr_t (*signal_funcptr_t) ();\n\nstatic pthread_mutex_t theMutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;\n\n// gettid / tkill / tgkill are not defined in libc.\nLIB_PRIVATE pid_t dmtcp_gettid() {\n  return _real_syscall(SYS_gettid);\n}\nLIB_PRIVATE int dmtcp_tkill(int tid, int sig) {\n  return _real_syscall(SYS_tkill, tid, sig);\n}\nLIB_PRIVATE int dmtcp_tgkill(int tgid, int tid, int sig) {\n  return _real_syscall(SYS_tgkill, tgid, tid, sig);\n}\n\n// FIXME: Are these primitives (_dmtcp_lock, _dmtcp_unlock) required anymore?\nvoid _dmtcp_lock() { _real_pthread_mutex_lock (&theMutex); }\nvoid _dmtcp_unlock() { _real_pthread_mutex_unlock (&theMutex); }\n\nvoid _dmtcp_remutex_on_fork() {\n  pthread_mutexattr_t attr;\n  pthread_mutexattr_init(&attr);\n  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE_NP);\n  pthread_mutex_init (&theMutex, &attr);\n  pthread_mutexattr_destroy(&attr);\n}\n/*\n * DMTCP puts wrappers around several libc (also libpthread, libdl etc.)\n * functions in order to work. In these wrappers, DMTCP has to do some work\n * before and after the real function is called in libc.\n *\n * In order to call the real function in libc, DMTCP calculates the address of\n * the function in libc and calls that address directly. There are several\n * techniques of calculating the address of the libc function. In this\n * document, we briefly discuss the techniques that DMTCP has used in past and\n * how it evolved into the current design.\n *\n * History:\n * 1. dlopen/dlsym: Once upon a time :-), DMTCP used to dlopen \"libc.so\" and\n *    then call dlsym() on the libc handle to find the addresses of the libc\n *    functions wrapped by DMTCP.\n *\n * This worked great for a while until we needed wrappers for\n * malloc/calloc/free, etc. The reason was the fact that dlopen/dlsym/dlerror\n * internally call calloc to allocate a small buffer. As can be seen, dlopen\n * calls calloc which * goes to the DMTCP wrapper for calloc, which in turn\n * needs to call dlopen() to find the address of libc calloc and so this goes\n * into an infinite recursion.\n *\n * 2a. Libc-offsets - take 1: To counter the problems related to malloc/calloc\n *     wrappers, DMTCP was modified to not use dlopen/dlsym. Instead, a new\n *     mechanism was implemented.\n *\n *     While executing dmtcp_launch, for each function wrapped by DMTCP, we\n *     calculated it's offset, in libc, from a known base-function (toupper, a\n *     function not wrapped by DMTCP) in libc, i.e. we do:\n *       open_offset = &open - &toupper;\n *     The offsets were passed along to libdmtcp.so in an environment\n *     variable. To calculate the address of libc function now becomes very\n *     easy -- calculate the address of base-function, and add to it the offset\n *     of the required function i.e.\n *       open_libc_address = &toupper + open_offset;\n *\n *     The environment variable holding the offsets was made available to each\n *     and every new process created via fork/exec.\n *\n * This worked fine until we discovered that some applications put a wrapper\n * around toupper as well :(.\n *\n * 2b. Libc-offsets - take 2:2b. Libc-offsets - take 2: In the next iteration,\n *     we decided to use a heuristic based approach of using a pool of libc\n *     base-functions instead of just one. An average address of base-functions\n *     was calculated and that was used in offset calculations.\n *\n * This approach was fine until we decided to support process migration. If a\n * process is migrated to a different machine with a different version of libc,\n * the offsets that are stored in memory aren't correct anymore and so if the\n * migrated process creates a child process, the offsets won't work.\n *\n * 3. dlsym(RTLD_NEXT, symbol): This is the current approach. In the _real_XYZ\n *    function, we call dlsym(RTLD_NEXT, \"XYZ\") to calculate the address of\n *    function in the libraries that come after the current library in the\n *    search order (see man dlsym for more details).\n *\n * There are three problems with this scheme:\n * a) As with scheme 1 (dlopen/dlsym) -- if there are wrappers around\n *    calloc/free, it goes into an infinite recursion, and\n * b) Even if we don't have wrappers around calloc, there can be a problem if\n *     some application uses the malloc_hooks.\n *     (see http://www.gnu.org/s/hello/manual/libc/Hooks-for-Malloc.html).\n *     One notable example is libopen-pal.so (part of Open MPI) which uses\n *     malloc_hooks and in the malloc hook, it called xstat() which landed in\n *     the DMTCP wrapper for xstat() and hence an infinite recursive loop.\n * c) Certain libpthread symbols are also defined in libc. For example, 'nm\n *    libc.so' reveals that 'pthread_cond_broadcast', 'pthread_cond_signal',\n *    and others are defined in libc.so. Thus, depending on the library load\n *    order, RTLD_NEXT might instead resolve to the libc version, which has\n *    been shown to cause problems (e.g. in the FReD record-replay plugin,\n *    which has wrappers around those functions).\n *\n * The work around to these problems is described in the following section.\n *\n * ***************************************************************************\n *\n * Current Workaround:\n *\n * In order to deal with the situation where we have malloc/calloc wrappers and\n * a potential application with malloc_hooks, we need to do the following:\n *\n * 0. Initialize all wrappers (calculate libc addr) before DMTCP does anything\n *    else i.e. do it at the beginning of the DmtcpWorker constructor.\n * 1. Define a variable dmtcp_wrappers_initializing, which is set to '1' while\n *    it is initializing and '0' after the * initialization has completed.\n * 2. Always have wrappers for malloc/calloc/free.\n * 3. In the wrappers for malloc/calloc/free, make sure that malloc hooks are\n *    never called. One way to do this is to disable malloc_hooks, but since\n *    they are not thread-safe, this is not a desired solution. Also note that\n *    malloc hooks have been deprecated in glibc 2.14 and will be removed in\n *    glibc 2.15.\n *\n *    Another way to avoid malloc hooks is to allocate memory using JALLOC to\n *    avoid calling libc:malloc. But we don't want to do this for all\n *    malloc/calloc calls, and so the call to JALLOC should be made only if\n *    dmtcp_wrappers_initializing is set to '1'.\n *\n *    There is a problem with the JALLOC approach too when using RECORD_REPLAY.\n *    RECORD_REPLAY puts wrappers around mmap() etc. and JALLOC uses mmap() to\n *    allocate memory :-(and as one can guess, it gets into a infinite\n *    recursion.\n * 4. The solution is to use static buffer when dlsym() calls calloc() during\n *    wrapper-initialization. It was noted that, calloc() is called only once\n *    with buf-size of 32, during dlsym() execution and thus it is safe to keep\n *    a small static buffer and pass on its address to the caller. The\n *    subsequent call to free() is ignored.\n *\n * In order to deal with the fact that libc.so contains some definition of\n * several pthread_* functions, we do the following. In initializing the\n * libpthread wrappers, we explicitly call dlopen() on libpthread.so. Then we\n * are guaranteed to resolve the symbol to the correct libpthread symbol.\n *\n * This solution is imperfect: if the user program also defines wrappers for\n * these functions, then using dlopen()/dlsym() explicitly on libpthread will\n * cause the user wrappers to be skipped. We have not yet run into a program\n * which does this, but it may occur in the future.\n *\n * ***************************************************************************\n * ***************************************************************************\n *\n * Update: Using the pthread_getspecific wrapper\n *   dlsym() uses pthread_getspecific to find a thread local buffer. On the\n *   very first call pthread_getspecific() return NULL. The dlsym function then\n *   calls calloc to allocate a buffer, followed by a call to\n *   pthread_setspecific. Any subsequent pthread_getspecific calls would return\n *   the buffer allocated earlier.\n *\n *   We put a wrapper around pthread_getspecific and return a static buffer to\n *   dlsym() on the very first call. This allows us to proceed further without\n *   having to worry about the calloc wrapper.\n *\n * Update: Using dmtcp_dlsym()\n *   The use of dmtcp_dlsym() to resolve symbols for wrappers within DMTCP allows\n *   us to avoid all of the problems and their workarounds as described above.\n *\n */\n\n#if TRACK_DLOPEN_DLSYM_FOR_LOCKS\nLIB_PRIVATE void dmtcp_setThreadPerformingDlopenDlsym();\nLIB_PRIVATE void dmtcp_unsetThreadPerformingDlopenDlsym();\n#endif\n\nstatic void *_real_func_addr[numLibcWrappers];\nstatic int dmtcp_wrappers_initialized = 0;\n\n#define GET_FUNC_ADDR(name) \\\n  _real_func_addr[ENUM(name)] = dmtcp_dlsym(RTLD_NEXT, #name);\n\nstatic void initialize_libc_wrappers()\n{\n  FOREACH_DMTCP_WRAPPER(GET_FUNC_ADDR);\n#ifdef __i386__\n  /* On i386 systems, there are two pthread_create symbols. We want the one\n   * with GLIBC_2.1 version. On 64-bit machines, there is only one\n   * pthread_create symbol (GLIBC_2.2.5), so no worries there.\n   */\n  _real_func_addr[ENUM(pthread_create)] = dmtcp_dlvsym(RTLD_NEXT,\n                                                       \"pthread_create\",\n                                                       \"GLIBC_2.1\");\n#endif\n\n  /* On some arm machines, the newest pthread_create has version GLIBC_2.4 */\n  void *addr = dmtcp_dlvsym(RTLD_NEXT, \"pthread_create\", \"GLIBC_2.4\");\n  if (addr != NULL) {\n    _real_func_addr[ENUM(pthread_create)] = addr;\n  }\n}\n\n#ifdef ENABLE_PTHREAD_COND_WRAPPERS\n# define GET_LIBPTHREAD_FUNC_ADDR(name) \\\n  _real_func_addr[ENUM(name)] = dlvsym(RTLD_NEXT, #name, pthread_sym_ver);\n\n/*\n * WARNING: By using this method to initialize libpthread wrappers (direct\n * dlopen()/dlsym()) we are are overriding any user wrappers for these\n * functions. If this is a problem in the future we need to think of a new way\n * to do this.\n * EDIT: On some ARM machines, the symbol version is 2.4. Try that first and\n *       fallback to 2.3.4 on failure.\n */\nstatic void initialize_libpthread_wrappers()\n{\n  const char *ver_2_4 = \"GLIBC_2.4\";\n  const char *ver_2_3_2 = \"GLIBC_2.3.2\";\n  const char *pthread_sym_ver = NULL;\n\n  void *addr = dmtcp_dlvsym(RTLD_NEXT, \"pthread_cond_signal\", ver_2_4);\n  if (addr != NULL) {\n    pthread_sym_ver = ver_2_4;\n  } else {\n    pthread_sym_ver = ver_2_3_2;\n  }\n\n  FOREACH_LIBPTHREAD_WRAPPERS(GET_LIBPTHREAD_FUNC_ADDR);\n}\n#endif // #ifdef ENABLE_PTHREAD_COND_WRAPPERS\n\nvoid dmtcp_prepare_wrappers(void)\n{\n  if (!dmtcp_wrappers_initialized) {\n    initialize_libc_wrappers();\n    dmtcp_wrappers_initialized = 1;\n#ifdef ENABLE_PTHREAD_COND_WRAPPERS\n    initialize_libpthread_wrappers();\n#endif // #ifdef ENABLE_PTHREAD_COND_WRAPPERS\n  }\n}\n\n//////////////////////////\n//// FIRST DEFINE REAL VERSIONS OF NEEDED FUNCTIONS\n\n#define REAL_FUNC_PASSTHROUGH(name)  REAL_FUNC_PASSTHROUGH_TYPED(int, name)\n\n#define REAL_FUNC_PASSTHROUGH_WORK(name) \\\n  if (fn == NULL) { \\\n    if (_real_func_addr[ENUM(name)] == NULL) dmtcp_initialize(); \\\n    fn = _real_func_addr[ENUM(name)]; \\\n    if (fn == NULL) { \\\n      fprintf(stderr, \"*** DMTCP: Error: lookup failed for %s.\\n\" \\\n                      \"           The symbol wasn't found in current library\" \\\n                      \" loading sequence.\\n\" \\\n                      \"    Aborting.\\n\", #name); \\\n      abort(); \\\n    } \\\n  }\n\n#define REAL_FUNC_PASSTHROUGH_TYPED(type,name) \\\n  static type (*fn)() = NULL;                  \\\n  REAL_FUNC_PASSTHROUGH_WORK(name)             \\\n  return (*fn)\n\n#define REAL_FUNC_PASSTHROUGH_VOID(name) \\\n  static void (*fn)() = NULL;            \\\n  REAL_FUNC_PASSTHROUGH_WORK(name)       \\\n  (*fn)\n\n#define REAL_FUNC_PASSTHROUGH_NORETURN(name)                 \\\n  static void (*fn)() __attribute__ ((__noreturn__)) = NULL; \\\n  REAL_FUNC_PASSTHROUGH_WORK(name)                           \\\n  (*fn)\n\ntypedef void* (*dlsym_fnptr_t) (void *handle, const char *symbol);\nvoid *dmtcp_get_libc_dlsym_addr(void);\n\nLIB_PRIVATE\nvoid *_real_dlsym (void *handle, const char *symbol) {\n  static dlsym_fnptr_t _libc_dlsym_fnptr = NULL;\n  if (_libc_dlsym_fnptr == NULL) {\n    _libc_dlsym_fnptr = dmtcp_dlsym;\n  }\n\n#if TRACK_DLOPEN_DLSYM_FOR_LOCKS\n  // Avoid calling WRAPPER_EXECUTION_DISABLE_CKPT() in calloc() wrapper. See\n  // comment in miscwrappers for more details.\n  // EDIT: Now that we are using pthread_getspecific trick, calloc will not be\n  // called and so we do not need to disable locking for calloc.\n  dmtcp_setThreadPerformingDlopenDlsym();\n#endif\n  void *res = (*_libc_dlsym_fnptr) (handle, symbol);\n#if TRACK_DLOPEN_DLSYM_FOR_LOCKS\n  dmtcp_unsetThreadPerformingDlopenDlsym();\n#endif\n  return res;\n}\n\n/* In libdmtcp.so code always use this function instead of unsetenv.\n * Bash has its own implementation of getenv/setenv/unsetenv and keeps its own\n * environment equivalent to its shell variables. If DMTCP uses the bash\n * unsetenv, bash will unset its internal environment variable but won't remove\n * the process environment variable and yet on the next getenv, bash will\n * return the process environment variable.\n * This is arguably a bug in bash-3.2.\n */\nLIB_PRIVATE\nint _dmtcp_unsetenv(const char *name) {\n  unsetenv (name);\n  // One can fix this by doing a getenv() here and put a '\\0' byte\n  // at the start of the returned value, but that is not correct as if you do\n  // another getenv after this, it would return \"\", which is not the same as\n  // NULL.\n  REAL_FUNC_PASSTHROUGH (unsetenv) (name);\n}\n\nLIB_PRIVATE\nvoid *_real_dlopen(const char *filename, int flag) {\n  REAL_FUNC_PASSTHROUGH_TYPED (void*, dlopen) (filename, flag);\n}\n\nLIB_PRIVATE\nint _real_dlclose(void *handle) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int, dlclose) (handle);\n}\n\nLIB_PRIVATE\nint _real_pthread_mutex_lock(pthread_mutex_t *mutex) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_mutex_lock) (mutex);\n}\n\nLIB_PRIVATE\nint _real_pthread_mutex_trylock(pthread_mutex_t *mutex) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_mutex_trylock) (mutex);\n}\n\nLIB_PRIVATE\nint _real_pthread_mutex_unlock(pthread_mutex_t *mutex) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_mutex_unlock) (mutex);\n}\n\nLIB_PRIVATE\nint _real_pthread_rwlock_unlock(pthread_rwlock_t *rwlock) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_rwlock_unlock) (rwlock);\n}\n\nLIB_PRIVATE\nint _real_pthread_rwlock_rdlock(pthread_rwlock_t *rwlock) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_rwlock_rdlock) (rwlock);\n}\n\nLIB_PRIVATE\nint _real_pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_rwlock_tryrdlock) (rwlock);\n}\n\nLIB_PRIVATE\nint _real_pthread_rwlock_wrlock(pthread_rwlock_t *rwlock) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_rwlock_wrlock) (rwlock);\n}\n\nLIB_PRIVATE\nint _real_pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_rwlock_trywrlock) (rwlock);\n}\n\n#ifdef ENABLE_PTHREAD_COND_WRAPPERS\nLIB_PRIVATE\nint _real_pthread_cond_broadcast(pthread_cond_t *cond)\n{\n#if __aarch64__\n  int result = NEXT_FNC_DEFAULT(pthread_cond_broadcast)(cond);\n  return result;\n#else\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_cond_broadcast) (cond);\n#endif\n}\n\nLIB_PRIVATE\nint _real_pthread_cond_destroy(pthread_cond_t *cond)\n{\n#if __aarch64__\n  int result = NEXT_FNC_DEFAULT(pthread_cond_destroy)(cond);\n  return result;\n#else\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_cond_destroy) (cond);\n#endif\n}\n\nLIB_PRIVATE\nint _real_pthread_cond_init(pthread_cond_t *cond,\n                            const pthread_condattr_t *attr)\n{\n#if __aarch64__\n  int result = NEXT_FNC_DEFAULT(pthread_cond_init)(cond,attr);\n  return result;\n#else\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_cond_init) (cond,attr);\n#endif\n}\n\nLIB_PRIVATE\nint _real_pthread_cond_signal(pthread_cond_t *cond)\n{\n#if __aarch64__\n  int result = NEXT_FNC_DEFAULT(pthread_cond_signal)(cond);\n  return result;\n#else\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_cond_signal) (cond);\n#endif\n}\n\nLIB_PRIVATE\nint _real_pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,\n                                 const struct timespec *abstime)\n{\n#if __aarch64__\n  int result = NEXT_FNC_DEFAULT(pthread_cond_timedwait)(cond, mutex, abstime);\n  return result;\n#else\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_cond_timedwait) (cond,mutex,abstime);\n#endif\n}\n\nLIB_PRIVATE\nint _real_pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)\n{\n#if __aarch64__\n  int result = NEXT_FNC_DEFAULT(pthread_cond_wait)(cond,mutex);\n  return result;\n#else\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_cond_wait) (cond,mutex);\n#endif\n}\n#endif // #ifdef ENABLE_PTHREAD_COND_WRAPPERS\n\nLIB_PRIVATE\nssize_t _real_read(int fd, void *buf, size_t count) {\n  REAL_FUNC_PASSTHROUGH (read) (fd,buf,count);\n}\n\nLIB_PRIVATE\nssize_t _real_write(int fd, const void *buf, size_t count) {\n  REAL_FUNC_PASSTHROUGH_TYPED (ssize_t,write) (fd,buf,count);\n}\n\nLIB_PRIVATE\nint _real_select(int nfds, fd_set *readfds, fd_set *writefds,\n                 fd_set *exceptfds, struct timeval *timeout) {\n  REAL_FUNC_PASSTHROUGH (select) (nfds,readfds,writefds,exceptfds,timeout);\n}\n\nLIB_PRIVATE\nint _real_socket (int domain, int type, int protocol)\n{\n  REAL_FUNC_PASSTHROUGH (socket) (domain,type,protocol);\n}\n\nLIB_PRIVATE\nint _real_connect (int sockfd, const struct sockaddr *serv_addr,\n                    socklen_t addrlen)\n{\n  REAL_FUNC_PASSTHROUGH (connect) (sockfd,serv_addr,addrlen);\n}\n\nLIB_PRIVATE\nint _real_bind (int sockfd, const struct sockaddr *my_addr,\n                 socklen_t addrlen)\n{\n  REAL_FUNC_PASSTHROUGH (bind) (sockfd,my_addr,addrlen);\n}\n\nLIB_PRIVATE\nint _real_listen (int sockfd, int backlog)\n{\n  REAL_FUNC_PASSTHROUGH (listen) (sockfd,backlog);\n}\n\nLIB_PRIVATE\nint _real_accept (int sockfd, struct sockaddr *addr, socklen_t *addrlen)\n{\n  REAL_FUNC_PASSTHROUGH (accept) (sockfd,addr,addrlen);\n}\n\nLIB_PRIVATE\nint _real_accept4 (int sockfd, struct sockaddr *addr, socklen_t *addrlen,\n                    int flags)\n{\n  REAL_FUNC_PASSTHROUGH (accept4) (sockfd,addr,addrlen,flags);\n}\n\nLIB_PRIVATE\nint _real_setsockopt (int s, int level, int optname, const void *optval,\n                       socklen_t optlen)\n{\n  REAL_FUNC_PASSTHROUGH (setsockopt) (s,level,optname,optval,optlen);\n}\n\nLIB_PRIVATE\nint _real_getsockopt (int s, int level, int optname, void *optval,\n                       socklen_t *optlen)\n{\n  REAL_FUNC_PASSTHROUGH (getsockopt) (s,level,optname,optval,optlen);\n}\n\nLIB_PRIVATE\nint _real_fexecve (int fd, char *const argv[], char *const envp[])\n{\n  REAL_FUNC_PASSTHROUGH (fexecve) (fd,argv,envp);\n}\n\nLIB_PRIVATE\nint _real_execve (const char *filename, char *const argv[],\n                   char *const envp[])\n{\n  REAL_FUNC_PASSTHROUGH (execve) (filename,argv,envp);\n}\n\nLIB_PRIVATE\nint _real_execv (const char *path, char *const argv[])\n{\n  REAL_FUNC_PASSTHROUGH (execv) (path,argv);\n}\n\nLIB_PRIVATE\nint _real_execvp (const char *file, char *const argv[])\n{\n  REAL_FUNC_PASSTHROUGH (execvp) (file,argv);\n}\nLIB_PRIVATE\nint _real_execvpe(const char *file, char *const argv[], char *const envp[]) {\n  REAL_FUNC_PASSTHROUGH (execvpe) (file, argv, envp);\n}\n\nLIB_PRIVATE\nint _real_system (const char *cmd)\n{\n  REAL_FUNC_PASSTHROUGH (system) (cmd);\n}\n\nLIB_PRIVATE\nFILE *_real_popen(const char *command, const char *mode) {\n  REAL_FUNC_PASSTHROUGH_TYPED (FILE*, popen) (command, mode);\n}\n\nLIB_PRIVATE\nint _real_pclose(FILE *fp) {\n  REAL_FUNC_PASSTHROUGH(pclose) (fp);\n}\n\nLIB_PRIVATE\npid_t _real_fork(void)\n{\n  REAL_FUNC_PASSTHROUGH_TYPED (pid_t, fork) ();\n}\n\nLIB_PRIVATE\nint _real_close (int fd)\n{\n  REAL_FUNC_PASSTHROUGH (close) (fd);\n}\n\nLIB_PRIVATE\nint _real_fclose (FILE *fp)\n{\n  REAL_FUNC_PASSTHROUGH (fclose) (fp);\n}\n\nLIB_PRIVATE\nint _real_dup (int oldfd)\n{\n  REAL_FUNC_PASSTHROUGH (dup) (oldfd);\n}\n\nLIB_PRIVATE\nint _real_dup2 (int oldfd, int newfd)\n{\n  REAL_FUNC_PASSTHROUGH (dup2) (oldfd, newfd);\n}\n\nLIB_PRIVATE\nint _real_dup3 (int oldfd, int newfd, int flags)\n{\n  REAL_FUNC_PASSTHROUGH (dup3) (oldfd, newfd, flags);\n}\n\nLIB_PRIVATE\nvoid _real_exit (int status)\n{\n  REAL_FUNC_PASSTHROUGH_VOID (exit) (status);\n}\n\nLIB_PRIVATE\nint _real_fcntl(int fd, int cmd, void *arg)\n{\n  REAL_FUNC_PASSTHROUGH (fcntl) (fd, cmd, arg);\n}\n\nLIB_PRIVATE\nint _real_getpt (void)\n{\n  REAL_FUNC_PASSTHROUGH (getpt) ();\n}\n\nLIB_PRIVATE\nint _real_posix_openpt (int flags)\n{\n  REAL_FUNC_PASSTHROUGH (posix_openpt) (flags);\n}\n\nLIB_PRIVATE\nint _real_ptsname_r (int fd, char * buf, size_t buflen)\n{\n  REAL_FUNC_PASSTHROUGH (ptsname_r) (fd, buf, buflen);\n}\n\nint _real_ttyname_r (int fd, char * buf, size_t buflen)\n{\n  REAL_FUNC_PASSTHROUGH (ttyname_r) (fd, buf, buflen);\n}\n\nLIB_PRIVATE\nint _real_socketpair (int d, int type, int protocol, int sv[2])\n{\n  REAL_FUNC_PASSTHROUGH (socketpair) (d,type,protocol,sv);\n}\n\nLIB_PRIVATE\nvoid _real_openlog (const char *ident, int option, int facility)\n{\n  REAL_FUNC_PASSTHROUGH_VOID (openlog) (ident,option,facility);\n}\n\nLIB_PRIVATE\nvoid _real_closelog (void)\n{\n  REAL_FUNC_PASSTHROUGH_VOID (closelog) ();\n}\n\n//set the handler\nLIB_PRIVATE\nsighandler_t _real_signal(int signum, sighandler_t handler) {\n  REAL_FUNC_PASSTHROUGH_TYPED (sighandler_t, signal) (signum, handler);\n}\nLIB_PRIVATE\nint _real_sigaction(int signum, const struct sigaction *act, struct sigaction *oldact) {\n  REAL_FUNC_PASSTHROUGH (sigaction) (signum, act, oldact);\n}\n\n#if !__GLIBC_PREREQ(2,21)\nLIB_PRIVATE\nint _real_sigvec(int signum, const struct sigvec *vec, struct sigvec *ovec) {\n  REAL_FUNC_PASSTHROUGH (sigvec) (signum, vec, ovec);\n}\n#endif\n\n//set the mask\nLIB_PRIVATE\nint _real_sigblock(int mask) {\n  REAL_FUNC_PASSTHROUGH (sigblock) (mask);\n}\nLIB_PRIVATE\nint _real_sigsetmask(int mask) {\n  REAL_FUNC_PASSTHROUGH (sigsetmask) (mask);\n}\nLIB_PRIVATE\nint _real_siggetmask(void) {\n  REAL_FUNC_PASSTHROUGH (siggetmask)();\n}\nLIB_PRIVATE\nint _real_sigprocmask(int how, const sigset_t *a, sigset_t *b) {\n  REAL_FUNC_PASSTHROUGH (sigprocmask) (how, a, b);\n}\nLIB_PRIVATE\nint _real_pthread_sigmask(int how, const sigset_t *a, sigset_t *b) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int, pthread_sigmask) (how, a, b);\n}\n\nLIB_PRIVATE\nvoid *_real_pthread_getspecific(pthread_key_t key)\n{\n  REAL_FUNC_PASSTHROUGH_TYPED(void*, pthread_getspecific)(key);\n}\n\nLIB_PRIVATE\nint _real_sigsuspend(const sigset_t *mask) {\n  REAL_FUNC_PASSTHROUGH (sigsuspend) (mask);\n}\nLIB_PRIVATE\nsighandler_t _real_sigset(int sig, sighandler_t disp)\n{\n  REAL_FUNC_PASSTHROUGH_TYPED (sighandler_t, sigset) (sig, disp);\n}\nLIB_PRIVATE\nint _real_sighold(int sig) {\n  REAL_FUNC_PASSTHROUGH (sighold) (sig);\n}\nLIB_PRIVATE\nint _real_sigignore(int sig) {\n  REAL_FUNC_PASSTHROUGH (sigignore) (sig);\n}\n// See 'man sigpause':  signal.h defines two possible versions for sigpause.\nLIB_PRIVATE\nint _real__sigpause(int __sig_or_mask, int __is_sig) {\n  REAL_FUNC_PASSTHROUGH (__sigpause) (__sig_or_mask, __is_sig);\n}\nLIB_PRIVATE\nint _real_sigpause(int sig) {\n  REAL_FUNC_PASSTHROUGH (sigpause) (sig);\n}\nLIB_PRIVATE\nint _real_sigrelse(int sig) {\n  REAL_FUNC_PASSTHROUGH (sigrelse) (sig);\n}\n\nLIB_PRIVATE\nint _real_sigwait(const sigset_t *set, int *sig) {\n  REAL_FUNC_PASSTHROUGH (sigwait) (set, sig);\n}\nLIB_PRIVATE\nint _real_sigwaitinfo(const sigset_t *set, siginfo_t *info) {\n  REAL_FUNC_PASSTHROUGH (sigwaitinfo) (set, info);\n}\nLIB_PRIVATE\nint _real_sigtimedwait(const sigset_t *set, siginfo_t *info,\n                       const struct timespec *timeout) {\n  REAL_FUNC_PASSTHROUGH (sigtimedwait) (set, info, timeout);\n}\n\nLIB_PRIVATE\nint _real_open(const char *pathname, int flags, ...) {\n  mode_t mode = 0;\n  // Handling the variable number of arguments\n  if (flags & O_CREAT) {\n    va_list arg;\n    va_start (arg, flags);\n    mode = va_arg (arg, int);\n    va_end (arg);\n  }\n  REAL_FUNC_PASSTHROUGH (open) (pathname, flags, mode);\n}\n\nLIB_PRIVATE\nint _real_waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options) {\n  REAL_FUNC_PASSTHROUGH (waitid) (idtype, id, infop, options);\n}\n\nLIB_PRIVATE\npid_t _real_wait4(pid_t pid, __WAIT_STATUS status, int options,\n                  struct rusage *rusage) {\n  REAL_FUNC_PASSTHROUGH_TYPED (pid_t, wait4) (pid, status, options, rusage);\n}\n\nLIB_PRIVATE\nint _real_open64(const char *pathname, int flags, ...) {\n  mode_t mode = 0;\n  // Handling the variable number of arguments\n  if (flags & O_CREAT) {\n    va_list arg;\n    va_start (arg, flags);\n    mode = va_arg (arg, int);\n    va_end (arg);\n  }\n  REAL_FUNC_PASSTHROUGH (open) (pathname, flags, mode);\n}\n\nLIB_PRIVATE\nFILE * _real_fopen(const char *path, const char *mode) {\n  REAL_FUNC_PASSTHROUGH_TYPED (FILE *, fopen) (path, mode);\n}\n\nLIB_PRIVATE\nFILE * _real_fopen64(const char *path, const char *mode) {\n  REAL_FUNC_PASSTHROUGH_TYPED (FILE *, fopen64) (path, mode);\n}\n\nLIB_PRIVATE\nint _real_openat(int dirfd, const char *pathname, int flags, mode_t mode) {\n  REAL_FUNC_PASSTHROUGH (openat) (dirfd, pathname, flags, mode);\n}\n\nLIB_PRIVATE\nint _real_openat64(int dirfd, const char *pathname, int flags, mode_t mode) {\n  REAL_FUNC_PASSTHROUGH (openat64) (dirfd, pathname, flags, mode);\n}\n\nLIB_PRIVATE\nDIR* _real_opendir(const char *name) {\n  REAL_FUNC_PASSTHROUGH_TYPED (DIR*, opendir) (name);\n}\n\nLIB_PRIVATE\nint _real_closedir(DIR *dir) {\n  REAL_FUNC_PASSTHROUGH (closedir) (dir);\n}\n\nLIB_PRIVATE\nint _real_mkstemp(char *template) {\n  REAL_FUNC_PASSTHROUGH (mkstemp) (template);\n}\n\n/* See comments for syscall wrapper */\nLIB_PRIVATE\nlong _real_syscall(long sys_num, ...) {\n  int i;\n  void * arg[7];\n  va_list ap;\n\n  va_start(ap, sys_num);\n  for (i = 0; i < 7; i++)\n    arg[i] = va_arg(ap, void *);\n  va_end(ap);\n\n  // /usr/include/unistd.h says syscall returns long int (contrary to man page)\n  REAL_FUNC_PASSTHROUGH_TYPED (long, syscall) (sys_num, arg[0], arg[1],\n                                               arg[2], arg[3], arg[4],\n                                               arg[5], arg[6]);\n}\n\nLIB_PRIVATE\nint _real_xstat(int vers, const char *path, struct stat *buf) {\n  REAL_FUNC_PASSTHROUGH (__xstat) (vers, path, buf);\n}\n\nLIB_PRIVATE\nint _real_xstat64(int vers, const char *path, struct stat64 *buf) {\n  REAL_FUNC_PASSTHROUGH (__xstat64) (vers, path, buf);\n}\n\nLIB_PRIVATE\nint _real_lxstat(int vers, const char *path, struct stat *buf) {\n  REAL_FUNC_PASSTHROUGH (__lxstat) (vers, path, buf);\n}\n\nLIB_PRIVATE\nint _real_lxstat64(int vers, const char *path, struct stat64 *buf) {\n  REAL_FUNC_PASSTHROUGH (__lxstat64) (vers, path, buf);\n}\n\nLIB_PRIVATE\nssize_t _real_readlink(const char *path, char *buf, size_t bufsiz) {\n  REAL_FUNC_PASSTHROUGH_TYPED (ssize_t, readlink) (path, buf, bufsiz);\n}\n\nLIB_PRIVATE\nint _real_clone (int (*function) (void *), void *child_stack, int flags, void *arg, int *parent_tidptr, struct user_desc *newtls, int *child_tidptr)\n{\n  REAL_FUNC_PASSTHROUGH (__clone) (function, child_stack, flags, arg,\n                                      parent_tidptr, newtls, child_tidptr);\n}\n\nLIB_PRIVATE\nint _real_pthread_tryjoin_np(pthread_t thread, void **retval) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int, pthread_tryjoin_np) (thread, retval);\n}\n\nLIB_PRIVATE\nint _real_pthread_timedjoin_np(pthread_t thread, void **retval,\n                                 const struct timespec *abstime) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int, pthread_timedjoin_np) (thread, retval, abstime);\n}\n\nLIB_PRIVATE\nint _real_pthread_create(pthread_t *thread, const pthread_attr_t *attr,\n                         void *(*start_routine)(void*), void *arg) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int, pthread_create)\n    (thread,attr,start_routine,arg);\n}\n\n//void _real_pthread_exit(void *retval) __attribute__ ((__noreturn__));\nLIB_PRIVATE\nvoid _real_pthread_exit(void *retval) {\n  REAL_FUNC_PASSTHROUGH_NORETURN (pthread_exit) (retval);\n}\n\nLIB_PRIVATE\nint _real_shmget (int key, size_t size, int shmflg) {\n  REAL_FUNC_PASSTHROUGH (shmget) (key, size, shmflg);\n}\n\nLIB_PRIVATE\nvoid* _real_shmat (int shmid, const void *shmaddr, int shmflg) {\n  REAL_FUNC_PASSTHROUGH_TYPED (void*, shmat) (shmid, shmaddr, shmflg);\n}\n\nLIB_PRIVATE\nint _real_shmdt (const void *shmaddr) {\n  REAL_FUNC_PASSTHROUGH (shmdt) (shmaddr);\n}\n\n/* glibc provides two versions of shmctl: 2.0 and 2.2. For some reason, the\n * dlsym(RTLD_NEXT,...) is getting us the 2.0 version causing the wrong\n * function call. For i386 architecture, we need to pass IPC_64 to the system\n * call in order to work properly. Please refer to NOTES section of shmctl\n * manpage.\n */\n#ifndef IPC_64\n// Taken from <linux/ipc.h>\n# define IPC_64  0x0100  /* New version (support 32-bit UIDs, bigger\n                          message sizes, etc. */\n#endif\n#ifdef __i386__\n# define IPC64_FLAG IPC_64\n#else\n# define IPC64_FLAG 0\n#endif\n\nLIB_PRIVATE\nint _real_shmctl (int shmid, int cmd, struct shmid_ds *buf) {\n  REAL_FUNC_PASSTHROUGH (shmctl) (shmid, cmd | IPC64_FLAG, buf);\n}\n\nLIB_PRIVATE\nint _real_semget(key_t key, int nsems, int semflg) {\n  REAL_FUNC_PASSTHROUGH (semget) (key, nsems, semflg);\n}\n\nLIB_PRIVATE\nint _real_semop(int semid, struct sembuf *sops, size_t nsops) {\n  REAL_FUNC_PASSTHROUGH (semop) (semid, sops, nsops);\n}\n\nLIB_PRIVATE\nint _real_semtimedop(int semid, struct sembuf *sops, size_t nsops,\n                     const struct timespec *timeout) {\n  REAL_FUNC_PASSTHROUGH (semtimedop) (semid, sops, nsops, timeout);\n}\n\nLIB_PRIVATE\nint _real_semctl(int semid, int semnum, int cmd, ...) {\n  union semun uarg;\n  va_list arg;\n  va_start (arg, cmd);\n  uarg = va_arg (arg, union semun);\n  va_end (arg);\n  REAL_FUNC_PASSTHROUGH (semctl) (semid, semnum, cmd | IPC64_FLAG, uarg);\n}\n\nLIB_PRIVATE\nint _real_msgget(key_t key, int msgflg) {\n  REAL_FUNC_PASSTHROUGH (msgget) (key, msgflg);\n}\n\nLIB_PRIVATE\nint _real_msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg) {\n  REAL_FUNC_PASSTHROUGH (msgsnd) (msqid, msgp, msgsz, msgflg);\n}\n\nLIB_PRIVATE\nssize_t _real_msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,\n                     int msgflg) {\n  REAL_FUNC_PASSTHROUGH (msgrcv) (msqid, msgp, msgsz, msgtyp, msgflg);\n}\n\nLIB_PRIVATE\nint _real_msgctl(int msqid, int cmd, struct msqid_ds *buf) {\n  REAL_FUNC_PASSTHROUGH (msgctl) (msqid, cmd | IPC64_FLAG, buf);\n}\n\n\nLIB_PRIVATE\nmqd_t _real_mq_open(const char *name, int oflag, mode_t mode,\n                      struct mq_attr *attr) {\n  REAL_FUNC_PASSTHROUGH_TYPED (mqd_t, mq_open) (name, oflag, mode, attr);\n}\n\nLIB_PRIVATE\nint _real_mq_close(mqd_t mqdes) {\n  REAL_FUNC_PASSTHROUGH (mq_close) (mqdes);\n}\n\nLIB_PRIVATE\nint _real_mq_notify(mqd_t mqdes, const struct sigevent *sevp) {\n  REAL_FUNC_PASSTHROUGH (mq_notify) (mqdes, sevp);\n}\n\nLIB_PRIVATE\nssize_t _real_mq_timedreceive(mqd_t mqdes, char *msg_ptr, size_t msg_len,\n                              unsigned int *msg_prio,\n                              const struct timespec *abs_timeout) {\n  REAL_FUNC_PASSTHROUGH_TYPED (ssize_t, mq_timedreceive) (mqdes, msg_ptr,\n                                                          msg_len, msg_prio,\n                                                          abs_timeout);\n}\n\nLIB_PRIVATE\nint _real_mq_timedsend(mqd_t mqdes, const char *msg_ptr, size_t msg_len,\n                       unsigned int msg_prio,\n                       const struct timespec *abs_timeout) {\n  REAL_FUNC_PASSTHROUGH (mq_timedsend) (mqdes, msg_ptr, msg_len, msg_prio,\n                                        abs_timeout);\n}\n\nLIB_PRIVATE\nvoid *_real_mmap(void *addr, size_t length, int prot, int flags,\n    int fd, off_t offset) {\n  REAL_FUNC_PASSTHROUGH_TYPED (void*, mmap) (addr,length,prot,flags,fd,offset);\n}\n\nLIB_PRIVATE\nvoid *_real_mmap64(void *addr, size_t length, int prot, int flags,\n    int fd, __off64_t offset) {\n  REAL_FUNC_PASSTHROUGH_TYPED (void*,mmap64) (addr,length,prot,flags,fd,offset);\n}\n\n#if __GLIBC_PREREQ (2,4)\nLIB_PRIVATE\nvoid *_real_mremap(void *old_address, size_t old_size, size_t new_size,\n    int flags, ... /* void *new_address*/) {\n  if (flags == MREMAP_FIXED) {\n    va_list ap;\n    va_start(ap, flags);\n    void *new_address = va_arg (ap, void *);\n    va_end (ap);\n    REAL_FUNC_PASSTHROUGH_TYPED (void*, mremap)\n      (old_address, old_size, new_size, flags, new_address);\n  } else {\n    REAL_FUNC_PASSTHROUGH_TYPED (void*, mremap)\n      (old_address, old_size, new_size, flags);\n  }\n}\n#else\nLIB_PRIVATE\nvoid *_real_mremap(void *old_address, size_t old_size, size_t new_size,\n    int flags) {\n  REAL_FUNC_PASSTHROUGH_TYPED (void*, mremap)\n    (old_address, old_size, new_size, flags);\n}\n#endif\n\nLIB_PRIVATE\nint _real_munmap(void *addr, size_t length) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int, munmap) (addr, length);\n}\n\nLIB_PRIVATE\nint _real_poll(struct pollfd *fds, nfds_t nfds, int timeout) {\n  REAL_FUNC_PASSTHROUGH (poll) (fds, nfds, timeout);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/src/syscallwrappers.h": "/****************************************************************************\n *   Copyright (C) 2006-2008 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *  This file is part of DMTCP.                                             *\n *                                                                          *\n *  DMTCP is free software: you can redistribute it and/or                  *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP is distributed in the hope that it will be useful,                *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#ifndef SYSCALLWRAPPERS_H\n#define SYSCALLWRAPPERS_H\n\n// FIXME:  Why are we adding all these includes here, if we're declaring\n//         only our own _real_XXX() functions?  Some *wrappers.cpp files\n//         use these includes.  But, then we should split up these includes\n//         among the individual *wrappers.cpp files that actually need them,\n//         and not declare every possible include in one giant .h file.\n#include <features.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <poll.h>\n#include <stdarg.h>\n#include <sys/shm.h>\n#include <sys/sem.h>\n// FIXME:  The SLES 10 (glibc-2.4) declaration for msgctl differs from\n//         our wrapper's declaration, which uses the POSIX declaration.\n//         If for syscallsreal.c, use the local (e.g., SLES 10) decl.\n//         Otherwise, skip declaration, and use decl. in pidwrappers.h\n//         or in syscallwrappers.h.  The correct solution should be to fix\n//         the way that *wrappers.h get their decl. of msgctl().\n#ifdef FOR_SYSCALLSREAL_C\n# include <sys/msg.h>\n#endif\n#ifdef __cplusplus\n# include <sys/stat.h>\n#else\n# ifndef __USE_LARGEFILE64\n#  define __USE_LARGEFILE64_not_defined\n#  define __USE_LARGEFILE64\n#  include <sys/stat.h>\n#  ifdef __USE_LARGEFILE64_not_defined\n#   undef __USE_LARGEFILE64_not_defined\n#   undef __USE_LARGEFILE64\n#  endif\n# endif\n#endif\n#include <sys/mman.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <mqueue.h>\n#ifdef HAVE_SYS_INOTIFY_H\n# include <sys/inotify.h>\n#endif\n\n#include \"constants.h\"\n#include \"dmtcp.h\"\n#include \"mtcp/ldt.h\"\n#include \"config.h\"\n\n#ifdef HAVE_SYS_EPOLL_H\n# include <sys/epoll.h>\n#else\n  /* KEEP THIS IN SYNC WITH connection.h */\n# ifndef _SYS_EPOLL_H\n#  define _SYS_EPOLL_H    1\n   struct epoll_event {int dummy;};\n   /* Valid opcodes (\"op\" parameter) to issue to epoll_ctl().  */\n#  define EPOLL_CTL_ADD 1 /* Add a file descriptor to the interface.  */\n#  define EPOLL_CTL_DEL 2 /* Remove a file descriptor from the interface.  */\n#  define EPOLL_CTL_MOD 3 /* Change file descriptor epoll_event structure.  */\n# endif\n#endif\n\nvoid _dmtcp_setup_trampolines();\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n#if defined(__arm__) || defined(__aarch64__)\n# define DISABLE_PTHREAD_GETSPECIFIC_TRICK\n#endif\n\nLIB_PRIVATE pid_t dmtcp_gettid();\nLIB_PRIVATE int dmtcp_tkill(int tid, int sig);\nLIB_PRIVATE int dmtcp_tgkill(int tgid, int tid, int sig);\n\nextern int dmtcp_wrappers_initializing;\n\nLIB_PRIVATE extern __thread int thread_performing_dlopen_dlsym;\n\n#define FOREACH_GLIBC_MALLOC_FAMILY_WRAPPERS(MACRO)\\\n  MACRO(calloc)                             \\\n  MACRO(malloc)                             \\\n  MACRO(free)                               \\\n  MACRO(__libc_memalign)                    \\\n  MACRO(realloc)                            \\\n  MACRO(mmap)                               \\\n  MACRO(mmap64)                             \\\n  MACRO(mremap)                             \\\n  MACRO(munmap)\n\n#define FOREACH_GLIBC_WRAPPERS(MACRO)       \\\n  MACRO(dlopen)                             \\\n  MACRO(dlclose)                            \\\n  MACRO(getpid)                             \\\n  MACRO(getppid)                            \\\n  MACRO(kill)                               \\\n                                            \\\n  MACRO(tcgetpgrp)                          \\\n  MACRO(tcsetpgrp)                          \\\n  MACRO(getpgrp)                            \\\n  MACRO(setpgrp)                            \\\n                                            \\\n  MACRO(getpgid)                            \\\n  MACRO(setpgid)                            \\\n  MACRO(getsid)                             \\\n  MACRO(setsid)                             \\\n  MACRO(setgid)                             \\\n  MACRO(setuid)                             \\\n                                            \\\n  MACRO(wait)                               \\\n  MACRO(waitpid)                            \\\n  MACRO(waitid)                             \\\n  MACRO(wait3)                              \\\n  MACRO(wait4)                              \\\n  MACRO(ioctl)                              \\\n  MACRO(fcntl)                              \\\n                                            \\\n  MACRO(socket)                             \\\n  MACRO(connect)                            \\\n  MACRO(bind)                               \\\n  MACRO(listen)                             \\\n  MACRO(accept)                             \\\n  MACRO(accept4)                            \\\n  MACRO(setsockopt)                         \\\n  MACRO(getsockopt)                         \\\n  MACRO(socketpair)                         \\\n                                            \\\n  MACRO(fexecve)                            \\\n  MACRO(execve)                             \\\n  MACRO(execv)                              \\\n  MACRO(execvp)                             \\\n  MACRO(execvpe)                            \\\n  MACRO(execl)                              \\\n  MACRO(execlp)                             \\\n  MACRO(execle)                             \\\n  MACRO(system)                             \\\n  MACRO(popen)                              \\\n  MACRO(pclose)                             \\\n                                            \\\n  MACRO(signal)                             \\\n  MACRO(sigaction)                          \\\n  MACRO(sigvec)                             \\\n                                            \\\n  MACRO(sigset)                             \\\n  MACRO(sigblock)                           \\\n  MACRO(sigsetmask)                         \\\n  MACRO(siggetmask)                         \\\n  MACRO(sigprocmask)                        \\\n                                            \\\n  MACRO(sigsuspend)                         \\\n  MACRO(sighold)                            \\\n  MACRO(sigignore)                          \\\n  MACRO(__sigpause)                         \\\n  MACRO(sigpause)                           \\\n  MACRO(sigrelse)                           \\\n                                            \\\n  MACRO(sigwait)                            \\\n  MACRO(sigwaitinfo)                        \\\n  MACRO(sigtimedwait)                       \\\n                                            \\\n  MACRO(fork)                               \\\n  MACRO(__clone)                            \\\n  MACRO(open)                               \\\n  MACRO(open64)                             \\\n  MACRO(fopen)                              \\\n  MACRO(fopen64)                            \\\n  MACRO(openat)                             \\\n  MACRO(openat64)                           \\\n  MACRO(opendir)                            \\\n  MACRO(mkstemp)                            \\\n  MACRO(close)                              \\\n  MACRO(fclose)                             \\\n  MACRO(closedir)                           \\\n  MACRO(dup)                                \\\n  MACRO(dup2)                               \\\n  MACRO(dup3)                               \\\n  MACRO(__xstat)                            \\\n  MACRO(__xstat64)                          \\\n  MACRO(__lxstat)                           \\\n  MACRO(__lxstat64)                         \\\n  MACRO(readlink)                           \\\n  MACRO(exit)                               \\\n  MACRO(syscall)                            \\\n  MACRO(unsetenv)                           \\\n  MACRO(ptsname_r)                          \\\n  MACRO(ttyname_r)                          \\\n  MACRO(getpt)                              \\\n  MACRO(posix_openpt)                       \\\n  MACRO(openlog)                            \\\n  MACRO(closelog)                           \\\n                                            \\\n  MACRO(shmget)                             \\\n  MACRO(shmat)                              \\\n  MACRO(shmdt)                              \\\n  MACRO(shmctl)                             \\\n                                            \\\n  MACRO(semget)                             \\\n  MACRO(semctl)                             \\\n  MACRO(semop)                              \\\n  MACRO(semtimedop)                         \\\n                                            \\\n  MACRO(msgget)                             \\\n  MACRO(msgctl)                             \\\n  MACRO(msgsnd)                             \\\n  MACRO(msgrcv)                             \\\n                                            \\\n  MACRO(mq_open)                            \\\n  MACRO(mq_close)                           \\\n  MACRO(mq_timedsend)                       \\\n  MACRO(mq_timedreceive)                    \\\n  MACRO(mq_notify)                          \\\n                                            \\\n  MACRO(read)                               \\\n  MACRO(write)                              \\\n                                            \\\n  MACRO(select)                             \\\n  MACRO(poll)                               \\\n                                            \\\n  MACRO(pthread_create)                     \\\n  MACRO(pthread_exit)                       \\\n  MACRO(pthread_tryjoin_np)                 \\\n  MACRO(pthread_timedjoin_np)               \\\n  MACRO(pthread_sigmask)                    \\\n  MACRO(pthread_getspecific)                \\\n  MACRO(pthread_mutex_lock)                 \\\n  MACRO(pthread_mutex_trylock)              \\\n  MACRO(pthread_mutex_unlock)               \\\n  MACRO(pthread_rwlock_unlock)              \\\n  MACRO(pthread_rwlock_rdlock)              \\\n  MACRO(pthread_rwlock_tryrdlock)           \\\n  MACRO(pthread_rwlock_wrlock)              \\\n  MACRO(pthread_rwlock_trywrlock)\n\n#define FOREACH_LIBPTHREAD_WRAPPERS(MACRO)  \\\n  MACRO(pthread_cond_broadcast)             \\\n  MACRO(pthread_cond_destroy)               \\\n  MACRO(pthread_cond_init)                  \\\n  MACRO(pthread_cond_signal)                \\\n  MACRO(pthread_cond_timedwait)             \\\n  MACRO(pthread_cond_wait)\n\n#define FOREACH_DMTCP_WRAPPER(MACRO)            \\\n  FOREACH_GLIBC_WRAPPERS(MACRO)                 \\\n  FOREACH_GLIBC_MALLOC_FAMILY_WRAPPERS(MACRO)\n\n# define ENUM(x) enum_ ## x\n# define GEN_ENUM(x) ENUM(x),\n  typedef enum {\n    FOREACH_DMTCP_WRAPPER(GEN_ENUM)\n#ifdef ENABLE_PTHREAD_COND_WRAPPERS\n    FOREACH_LIBPTHREAD_WRAPPERS(GEN_ENUM)\n#endif // #ifdef ENABLE_PTHREAD_COND_WRAPPERS\n    numLibcWrappers\n  } LibcWrapperOffset;\n\n  union semun {\n    int              val;    /* Value for SETVAL */\n    struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */\n    unsigned short  *array;  /* Array for GETALL, SETALL */\n    struct seminfo  *__buf;  /* Buffer for IPC_INFO (Linux-specific) */\n  };\n\n  void _dmtcp_lock();\n  void _dmtcp_unlock();\n\n  void _dmtcp_remutex_on_fork();\n  LIB_PRIVATE void dmtcpResetTid(pid_t tid);\n  LIB_PRIVATE void dmtcpResetPidPpid();\n\n  int _dmtcp_unsetenv(const char *name);\n  void dmtcp_prepare_wrappers();\n\n  int _real_socket (int domain, int type, int protocol);\n  int _real_connect (int sockfd,  const  struct sockaddr *serv_addr,\n                      socklen_t addrlen);\n  int _real_bind (int sockfd,  const struct  sockaddr  *my_addr,\n                   socklen_t addrlen);\n  int _real_listen (int sockfd, int backlog);\n  int _real_accept (int sockfd, struct sockaddr *addr, socklen_t *addrlen);\n  int _real_accept4 (int sockfd, struct sockaddr *addr, socklen_t *addrlen,\n                      int flags);\n  int _real_setsockopt (int s, int level, int optname, const void *optval,\n                         socklen_t optlen);\n  int _real_getsockopt (int s, int level, int optname, void *optval,\n                         socklen_t *optlen);\n\n  int _real_fexecve (int fd, char *const argv[], char *const envp[]);\n  int _real_execve (const char *filename, char *const argv[], char *const envp[]);\n  int _real_execv (const char *path, char *const argv[]);\n  int _real_execvp (const char *file, char *const argv[]);\n  int _real_execvpe(const char *file, char *const argv[], char *const envp[]);\n// int _real_execl(const char *path, const char *arg, ...);\n// int _real_execlp(const char *file, const char *arg, ...);\n// int _real_execle(const char *path, const char *arg, ..., char * const envp[]);\n  int _real_system (const char * cmd);\n  FILE *_real_popen(const char *command, const char *mode);\n  int _real_pclose(FILE *fp);\n\n  pid_t _real_fork();\n  int _real_clone (int (*fn) (void *arg), void *child_stack, int flags, void *arg, int *parent_tidptr, struct user_desc *newtls, int *child_tidptr);\n\n  int _real_open(const char *pathname, int flags, ...);\n  int _real_open64(const char *pathname, int flags, ...);\n  FILE* _real_fopen(const char *path, const char *mode);\n  FILE* _real_fopen64(const char *path, const char *mode);\n  int _real_openat(int dirfd, const char *pathname, int flags, mode_t mode);\n  int _real_openat64(int dirfd, const char *pathname, int flags, mode_t mode);\n  DIR* _real_opendir(const char *name);\n  int _real_mkstemp(char *ttemplate);\n  int _real_close (int fd);\n  int _real_fclose (FILE *fp);\n  int _real_closedir (DIR *dir);\n  void _real_exit (int status);\n  int _real_dup (int oldfd);\n  int _real_dup2 (int oldfd, int newfd);\n  int _real_dup3 (int oldfd, int newfd, int flags);\n  int _real_fcntl(int fd, int cmd, void *arg);\n\n  int _real_ttyname_r (int fd, char *buf, size_t buflen);\n  int _real_ptsname_r (int fd, char * buf, size_t buflen);\n  int _real_getpt (void);\n  int _real_posix_openpt (int flags);\n\n  int _real_socketpair (int d, int type, int protocol, int sv[2]);\n\n  void _real_openlog (const char *ident, int option, int facility);\n  void _real_closelog (void);\n\n  // Despite what 'man signal' says, signal.h already defines sighandler_t\n  // But signal.h defines this only because we define GNU_SOURCE (or __USE_GNU_\n  typedef void (*sighandler_t)(int);  /* POSIX has user define this type */\n\n  //set the handler\n  sighandler_t _real_signal(int signum, sighandler_t handler);\n  int _real_sigaction(int signum, const struct sigaction *act,\n                      struct sigaction *oldact);\n  int _real_rt_sigaction(int signum, const struct sigaction *act,\n                         struct sigaction *oldact);\n#if !__GLIBC_PREREQ(2,21)\n  int _real_sigvec(int sig, const struct sigvec *vec, struct sigvec *ovec);\n#endif\n\n  //set the mask\n  int _real_sigblock(int mask);\n  int _real_sigsetmask(int mask);\n  int _real_siggetmask(void);\n  int _real_sigprocmask(int how, const sigset_t *set, sigset_t *oldset);\n  int _real_rt_sigprocmask(int how, const sigset_t *set, sigset_t *oldset);\n  int _real_pthread_sigmask(int how, const sigset_t *newmask,\n                            sigset_t *oldmask);\n  void *_real_pthread_getspecific(pthread_key_t key);\n\n  int _real_sigsuspend(const sigset_t *mask);\n  int _real_sighold(int sig);\n  int _real_sigignore(int sig);\n  int _real__sigpause(int __sig_or_mask, int __is_sig);\n  int _real_sigpause(int sig);\n  int _real_sigrelse(int sig);\n  sighandler_t _real_sigset(int sig, sighandler_t disp);\n\n  int _real_sigwait(const sigset_t *set, int *sig);\n  int _real_sigwaitinfo(const sigset_t *set, siginfo_t *info);\n  int _real_sigtimedwait(const sigset_t *set, siginfo_t *info,\n                         const struct timespec *timeout);\n\n  long _real_syscall(long sys_num, ...);\n\n  int _real_pthread_create(pthread_t *thread, const pthread_attr_t *attr,\n      void *(*start_routine)(void*), void *arg);\n  void _real_pthread_exit(void *retval) __attribute__ ((__noreturn__));\n  int _real_pthread_tryjoin_np(pthread_t thread, void **retval);\n  int _real_pthread_timedjoin_np(pthread_t thread, void **retval,\n                                 const struct timespec *abstime);\n\n  int _real_xstat(int vers, const char *path, struct stat *buf);\n  int _real_xstat64(int vers, const char *path, struct stat64 *buf);\n  int _real_lxstat(int vers, const char *path, struct stat *buf);\n  int _real_lxstat64(int vers, const char *path, struct stat64 *buf);\n  ssize_t _real_readlink(const char *path, char *buf, size_t bufsiz);\n  void * _real_dlsym (void *handle, const char *symbol);\n\n  void *_real_dlopen(const char *filename, int flag);\n  int _real_dlclose(void *handle);\n\n  void *_real_calloc(size_t nmemb, size_t size);\n  void *_real_malloc(size_t size);\n  void  _real_free(void *ptr);\n  void *_real_realloc(void *ptr, size_t size);\n  void *_real_libc_memalign(size_t boundary, size_t size);\n  void *_real_mmap(void *addr, size_t length, int prot, int flags,\n      int fd, off_t offset);\n  void *_real_mmap64(void *addr, size_t length, int prot, int flags,\n      int fd, __off64_t offset);\n#if __GLIBC_PREREQ (2,4)\n  void *_real_mremap(void *old_address, size_t old_size, size_t new_size,\n      int flags, ... /* void *new_address */);\n#else\n  void *_real_mremap(void *old_address, size_t old_size, size_t new_size,\n      int flags);\n#endif\n  int _real_munmap(void *addr, size_t length);\n\n  ssize_t _real_read(int fd, void *buf, size_t count);\n  ssize_t _real_write(int fd, const void *buf, size_t count);\n  int _real_select(int nfds, fd_set *readfds, fd_set *writefds,\n                   fd_set *exceptfds, struct timeval *timeout);\n  off_t _real_lseek(int fd, off_t offset, int whence);\n  int _real_unlink(const char *pathname);\n\n  int _real_pthread_mutex_lock(pthread_mutex_t *mutex);\n  int _real_pthread_mutex_trylock(pthread_mutex_t *mutex);\n  int _real_pthread_mutex_unlock(pthread_mutex_t *mutex);\n  int _real_pthread_rwlock_unlock(pthread_rwlock_t *rwlock);\n  int _real_pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);\n  int _real_pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);\n  int _real_pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);\n  int _real_pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);\n\n#ifdef ENABLE_PTHREAD_COND_WRAPPERS\n  int _real_pthread_cond_broadcast(pthread_cond_t *cond);\n  int _real_pthread_cond_destroy(pthread_cond_t *cond);\n  int _real_pthread_cond_init(pthread_cond_t *cond,\n                              const pthread_condattr_t *attr);\n  int _real_pthread_cond_signal(pthread_cond_t *cond);\n  int _real_pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,\n                                   const struct timespec *abstime);\n  int _real_pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);\n#endif // #ifdef ENABLE_PTHREAD_COND_WRAPPERS\n\n  int _real_poll(struct pollfd *fds, nfds_t nfds, int timeout);\n\n  int   _real_waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);\n  pid_t _real_wait4(pid_t pid, __WAIT_STATUS status, int options,\n                    struct rusage *rusage);\n\n  int _real_shmget (int key, size_t size, int shmflg);\n  void* _real_shmat (int shmid, const void *shmaddr, int shmflg);\n  int _real_shmdt (const void *shmaddr);\n  int _real_shmctl (int shmid, int cmd, struct shmid_ds *buf);\n  int _real_semget(key_t key, int nsems, int semflg);\n  int _real_semop(int semid, struct sembuf *sops, size_t nsops);\n  int _real_semtimedop(int semid, struct sembuf *sops, size_t nsops,\n                       const struct timespec *timeout);\n  int _real_semctl(int semid, int semnum, int cmd, ...);\n\n  int _real_msgget(key_t key, int msgflg);\n  int _real_msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);\n  ssize_t _real_msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,\n                       int msgflg);\n  int _real_msgctl(int msqid, int cmd, struct msqid_ds *buf);\n\n\n  mqd_t _real_mq_open(const char *name, int oflag, mode_t mode,\n                      struct mq_attr *attr);\n  int _real_mq_close(mqd_t mqdes);\n  int _real_mq_notify(mqd_t mqdes, const struct sigevent *sevp);\n  ssize_t _real_mq_timedreceive(mqd_t mqdes, char *msg_ptr, size_t msg_len,\n                                unsigned int *msg_prio,\n                                const struct timespec *abs_timeout);\n  int _real_mq_timedsend(mqd_t mqdes, const char *msg_ptr, size_t msg_len,\n                         unsigned int msg_prio,\n                         const struct timespec *abs_timeout);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/src/dmtcp_dlsym.cpp": "/****************************************************************************\n *   Copyright (C) 2014 by Gene Cooperman                                   *\n *   gene@ccs.neu.edu                                                       *\n *                                                                          *\n *  This file is part of DMTCP.                                             *\n *                                                                          *\n *  DMTCP is free software: you can redistribute it and/or                  *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP is distributed in the hope that it will be useful,                *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n/* USAGE:\n * #include \"dmtcp_dlsym.h\"\n * ... dmtcp_dlsym(RTLD_NEXT, ...) ...\n */\n\n/* THEORY:  A versioned symbol consists of multiple symbols, one for\n * each version.  Each symbol entry in the dynsym section (which becomes the\n * same as the symtab section when loaded in memory) should have a\n * corresponding entry in the symtab section.  So, the dynsym array values\n * can be viewed as an extra field of the symtab array of structs.\n * The dynsym entry (value) is a version index to the version string\n * for that symbol.  The version string is indicated by an entry in the\n * versym section with the same version index.  (versym is an array of strings)\n *     The dynsym entry can also have the 'hidden' bit (bit 15) set.  For a\n * given * symbol name, there should be exactly one symbol of that name for\n * which the hidden bit is not set.  This is the default version.  The normal\n * \"static linker\" (at load time) should only link to the base version (version\n * given by index 1 or 2 in the versym section).  The \"dynamic linker\"\n * (invoked by dlopen) tries first for a base version, and if not found,\n * then hopes for a unique versioned symbol.  (It seems that in all of\n * the above, the linker will always ignore a hidden symbol for these\n * purposes.  Unfortunately, dlsym doesn't follow the same policy as the\n * static or dynamic linker.  Hence, dmtcp_dlsym tries to replicate\n * that policy of preferring non-hidden symbols always.)\n *     The symbol pthread_cond_broadcast is a good test case.  It seems to\n * have its base version referenced as a hidden symbol, and only a non-base\n * version exists as unhidden.  Unfortunately, dlsym still chooses the\n * hidden base definition.\n *     Is this a bug in dlsym?  Or maybe just a bug in the 'man dlsym'\n * description?  Since versioning is not POSIX, it's difficult to say.\n */\n\n// Uncomment this to see what symbols and versions are chosen.\n// #define VERBOSE\n\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\n#endif\n#include <link.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\n#endif\n#include <dlfcn.h>\n\n#include \"dmtcp_dlsym.h\"\n#include \"jassert.h\"\n#include \"config.h\"\n\n// ***** NOTE:  link.h invokes elf.h, which:\n// *****        expands ElfW(Word)  to  Elf64_Word; and then defines:\n// *****        typedef uint32_t Elf63_Word;\n\n// older sysv standard\nstatic unsigned long elf_hash(const char *name) {\n  unsigned long h = 0, g;\n  while (*name) {\n    h = (h << 4) + *name++;\n    if ((g = h & 0xf0000000)) {\n      h ^= g >> 24;\n    }\n    h &= ~g;\n  }\n  return h;\n}\n\n// For GNU standard, below, see:\n//   https://blogs.oracle.com/ali/entry/gnu_hash_elf_sections\n//   http://deroko.phearless.org/dt_gnu_hash.txt\n//   glibc:elf/dl-lookup.c:do_lookup_x()\n//     See:  dl_setup_hash()  and  Elf32_Word bucket = map->l_gnu_buckets  ...\n\n// GNU standard\n#if 0\nstatic uint32_t elf_gnu_hash(const char *s) {\n  uint32_t h = 5381;\n  unsigned char c;\n  for (c = *s; c != '\\0'; c = *++s)\n    h = h * 33 + c;\n  return h;\n}\n#elif 0\n// From binutils:bfd/elf.c:bfd_elf_gnu_hash()\nunsigned long elf_gnu_hash (const char *namearg)\n{\n  const unsigned char *name = (const unsigned char *) namearg;\n  unsigned long h = 5381;\n  unsigned char ch;\n\n  while ((ch = *name++) != '\\0')\n    h = (h << 5) + h + ch;\n  return h & 0xffffffff;\n}\n#else\n// From glibc-2.19\nstatic uint_fast32_t elf_gnu_hash (const char *s)\n{\n  uint_fast32_t h = 5381;\n  unsigned char c;\n  for (c = *s; c != '\\0'; c = *++s)\n    h = h * 33 + c;\n  return h & 0xffffffff;\n}\n#endif\n\nstatic Elf32_Word hash_first(const char *name, Elf32_Word *hash_table,\n                             int use_gnu_hash) {\n  if (use_gnu_hash) {\n    uint32_t nbuckets = ((uint32_t*)hash_table)[0];\n    // uint32_t symndx = ((uint32_t*)hash_table)[1];\n    uint32_t maskwords = ((uint32_t*)hash_table)[2];\n    uint32_t *buckets = (uint32_t *)\n      ((char *)hash_table + 4*sizeof(uint32_t) + maskwords*sizeof(long unsigned int));\n    // uint32_t *hashval = & buckets[nbuckets];\n    if (buckets[elf_gnu_hash(name) % nbuckets])\n      return buckets[elf_gnu_hash(name) % nbuckets];\n    else\n      return STN_UNDEF;\n  } else {\n    // http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#hash\n    Elf32_Word nbucket = *hash_table++;\n    hash_table++; // Elf32_Word nchain = *hash_table++; // Note: nchain same as n_symtab\n    Elf32_Word *bucket = hash_table;\n    // Elf32_Word *chain = hash_table + nbucket;\n    return bucket[elf_hash(name) % nbucket]; // return index into symbol table\n  }\n}\n\nstatic Elf32_Word hash_next(Elf32_Word index, Elf32_Word *hash_table,\n                            int use_gnu_hash) {\n  if (use_gnu_hash) {\n    JASSERT( index > STN_UNDEF );\n    uint32_t nbuckets = ((uint32_t*)hash_table)[0];\n    uint32_t symndx = ((uint32_t*)hash_table)[1];\n    uint32_t maskwords = ((uint32_t*)hash_table)[2];\n    uint32_t *hashval = (uint32_t *)\n      ((char *)hash_table + 4*sizeof(uint32_t) /* sizeof header */\n       + maskwords*sizeof(long unsigned int) /* sizeof Bloom filter */\n       + nbuckets*sizeof(Elf32_Word) /* sizeof hash buckets */\n      );\n    if (hashval[index - symndx] & 1)\n      return STN_UNDEF;  // end-of-chain indicator\n    else\n      return index+1;\n  } else {\n    Elf32_Word nbucket = *hash_table++;\n    hash_table++; // Elf32_Word nchain = *hash_table++;\n    // Elf32_Word *bucket = hash_table;\n    Elf32_Word *chain = hash_table + nbucket;\n    return chain[index]; // If this returns STN_UNDEF, then it's end of chain\n  }\n}\n\ntypedef struct dt_tag{\n    char *base_addr; /* Base address shared object is loaded at. */\n    // ElfW(Sym) *dynsym; // On disk, dynsym would be dynamic symbols only\n    ElfW(Sym) *symtab; // Same as dynsym, for in-memory symbol table.\n    // ElfW(Word) n_symtab;\n    ElfW(Half) *versym;\n    /* elf.h lies.  DT_VERDEF is offset from base_addr, not addr. */\n    ElfW(Verdef) *verdef;\n    ElfW(Word) verdefnum;\n    // ElfW(Word) first_ext_def;\n    char *strtab;\n    Elf32_Word *hash;\n    Elf32_Word *gnu_hash;\n} dt_tag;\n\nstatic char *symbol_name(int i, dt_tag *tags) {\n  return tags->strtab + tags->symtab[i].st_name;\n}\n\nstatic char *version_name(ElfW(Word) version_ndx, dt_tag *tags) {\n    ElfW(Verdef) *cur, *prev;\n\n    // Remove hidden bit, if it's set.\n    if (version_ndx & (1<<15))\n      version_ndx -= (1<<15);\n    // Walk the list of all versions.\n    for (prev = NULL, cur = tags->verdef;\n         // Could alternatively use verdefnum (DT_VERDEFNUM) here.\n         cur != prev;\n         prev = cur, cur = (ElfW(Verdef)*)(((char *)cur)+cur->vd_next))\n    {\n      JASSERT (cur->vd_version == 1);\n      if (cur->vd_ndx == version_ndx) {\n        ElfW(Verdaux) *first = (ElfW(Verdaux) *)(((char *)cur)+cur->vd_aux);\n        return tags->strtab + first->vda_name;\n      }\n    }\n    return NULL;  // failed to find version name\n}\n\n// Note that the dynamic section is usually also a segment by itself.\n// [ 'readelf -l libXXX.so' to verify. ]\n// So, we don't need the object handle.  Its base address is enough,\n//   and we can then read the program header to get the right segment.\n// Also, the _DYNAMIC symbol in a section should also be a pointer to\n//   the address of the dynamic section.  (See comment in /usr/include/link.h)\nstatic void get_dt_tags(void *handle, dt_tag *tags) {\n    struct link_map *lmap;  // from /usr/include/link.h\n\n    /* The handle we get here is either from an earlier call to\n     * dlopen(), or from a call to dladdr(). In both the cases,\n     * the handle corresponds to a link_map node.\n     */\n    lmap = (link_map *) handle;\n    ElfW(Dyn) * dyn = lmap->l_ld;     // from /usr/include/link.h\n    // http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#dynamic_section\n    /* Base address shared object is loaded at. (from /usr/include/lnik.h) */\n    tags->base_addr = (char *)(lmap->l_addr);\n\n    tags->symtab = NULL;\n    tags->versym = NULL;\n    tags->verdef = NULL;\n    tags->strtab = NULL;\n    tags->hash = NULL;\n    tags->gnu_hash = NULL;\n    tags->verdefnum = 0;\n\n    ElfW(Dyn) *cur_dyn;\n\n/*\n * This code extends dmtcp_dlsym to work on VDSO, while in libc, they have a\n * separate internal vdso_dlsym function for this purpose.\n *\n * For libraries loaded by RTLD, the DT_* entries are patched at load time.\n * Here's an example call trace:\n *   _start()\n *     ...\n *     dl_main()\n *       ...\n *       _dl_map_object()\n *         _dl_map_object_from_fd()\n *           _dl_map_segments()\n *           elf_get_dynamic_info()\n *\n * The elf_get_dynamic_info() function changes the DT_* entries from\n * relative offsets to absolute addresses.\n *\n * For cases where the DSO is *not* loaded by RTLD, like vDSO (with read-only\n * data), we need to manually adjust at access time.\n */\n\n#define ADJUST_DYN_INFO_RO(dst, map, dyn)                   \\\n  if (dyn->d_un.d_ptr > map->l_addr) {                      \\\n    dst = (__typeof(dst))dyn->d_un.d_ptr;                   \\\n  } else {                                                  \\\n    dst = (__typeof(dst))(map->l_addr + dyn->d_un.d_ptr);   \\\n  }\n    // The _DYNAMIC symbol should be pointer to address of the dynamic section.\n    // printf(\"dyn: %p; _DYNAMIC: %p\\n\", dyn, _DYNAMIC);\n    for (cur_dyn = dyn; cur_dyn->d_tag != DT_NULL;  cur_dyn++) {\n      if (cur_dyn->d_tag == DT_VERSYM) {\n        ADJUST_DYN_INFO_RO(tags->versym, lmap, cur_dyn);\n      }\n      if (cur_dyn->d_tag == DT_VERDEF) {\n        ADJUST_DYN_INFO_RO(tags->verdef, lmap, cur_dyn);\n      }\n      if (cur_dyn->d_tag == DT_VERDEFNUM)\n        tags->verdefnum = (ElfW(Word))cur_dyn->d_un.d_val;\n      if (cur_dyn->d_tag == DT_STRTAB && tags->strtab == 0) {\n        ADJUST_DYN_INFO_RO(tags->strtab, lmap, cur_dyn);\n      }\n      // Not DT_DYNSYM, since only dynsym section loaded into RAM; not symtab.??\n      //   So, DT_SYMTAB refers to dynsym section ??\n      if (cur_dyn->d_tag == DT_SYMTAB) {\n        ADJUST_DYN_INFO_RO(tags->symtab, lmap, cur_dyn);\n      }\n      if (cur_dyn->d_tag == DT_HASH) {\n        ADJUST_DYN_INFO_RO(tags->hash, lmap, cur_dyn);\n      }\n#ifdef HAS_GNU_HASH\n      if (cur_dyn->d_tag == DT_GNU_HASH) {\n        ADJUST_DYN_INFO_RO(tags->gnu_hash, lmap, cur_dyn);\n      }\n#endif\n      //if (cur_dyn->d_tag == DT_MIPS_SYMTABNO) // Number of DYNSYM entries\n      //  n_symtab = (ElfW(Word))cur_dyn->d_un.d_val;\n      //if (cur_dyn->d_tag == DT_MIPS_UNREFEXTNO)  // First external DYNSYM\n      //  first_ext_def = (ElfW(Word))cur_dyn->d_un.d_val;  // first dynsym entry??\n    }\n}\n\n// Given a handle for a library (not RTLD_DEFAULT or RTLD_NEXT), retrieves the\n// default symbol for the given symbol if it exists in that library.\n// Also sets the tags and default_symbol_index for usage later\nvoid *dlsym_default_internal_library_handler(void *handle, const char*symbol,\n                                             const char *version,\n                                             dt_tag *tags_p,\n                                             Elf32_Word *default_symbol_index_p)\n{\n  dt_tag tags;\n  Elf32_Word default_symbol_index = 0;\n  Elf32_Word i;\n  uint32_t numNonHiddenSymbols = 0;\n\n  get_dt_tags(handle, &tags);\n  JASSERT(tags.hash != NULL || tags.gnu_hash != NULL);\n  int use_gnu_hash = (tags.hash == NULL);\n  Elf32_Word *hash = (use_gnu_hash ? tags.gnu_hash : tags.hash);\n  for (i = hash_first(symbol, hash, use_gnu_hash); i != STN_UNDEF;\n       i = hash_next(i, hash, use_gnu_hash)) {\n    if (tags.symtab[i].st_name == 0 || tags.symtab[i].st_value == 0)\n      continue;\n    if (strcmp(symbol_name(i, &tags), symbol) != 0) // If different symbol name\n      continue;\n    char *symversion = version_name(tags.versym[i], &tags);\n    if (version && symversion && strcmp(symversion, version) == 0) {\n      default_symbol_index = i;\n      break;\n    }\n    // We have a symbol of the same name.  Let's look at the version number.\n    if ( version == NULL) {\n      if (!(tags.versym[i] & (1<<15)) ) { // If hidden bit is not set.\n        numNonHiddenSymbols++;\n      }\n      // If default symbol not set or if new version later than old one.\n      // Notice that default_symbol_index will be set first to the\n      //  base definition (1 for unversioned symbols; 2 for versioned symbols)\n      if (default_symbol_index && numNonHiddenSymbols > 1) {\n        JWARNING(false)(symbol).Text(\"More than one default symbol version.\");\n      }\n      char *defaultSymVersion = version_name(tags.versym[default_symbol_index],\n                                             &tags);\n      if (default_symbol_index == 0 ||\n          // Could look at version dependencies, but using strcmp instead.\n          (symversion && defaultSymVersion &&\n           strcmp(symversion, defaultSymVersion) > 0)) {\n        default_symbol_index = i;\n      }\n    }\n  }\n  *tags_p = tags;\n  *default_symbol_index_p = default_symbol_index;\n\n  if (default_symbol_index) {\n#if __GLIBC_PREREQ(2, 11)\n    // See https://gcc.gnu.org/onlinedocs/gcc-4.9.2/gcc/Function-Attributes.html\n    if (ELF64_ST_TYPE(tags.symtab[default_symbol_index].st_info) ==\n        STT_GNU_IFUNC) {\n      typedef void* (*fnc)();\n      fnc f =  (fnc)(tags.base_addr +\n                     tags.symtab[default_symbol_index].st_value);\n      return f();\n    }\n#endif\n    return tags.base_addr + tags.symtab[default_symbol_index].st_value;\n  } else {\n    return NULL;\n  }\n}\n\n// Given a pseudo-handle, symbol name, and addr, returns the address of the symbol\n// with the given name of a default version found by the search order of the given\n// handle which is either RTLD_DEFAULT or RTLD_NEXT.\nvoid *dlsym_default_internal_flag_handler(void* handle, const char *libname,\n                                          const char* symbol,\n                                          const char *version,\n                                          void* addr, dt_tag *tags_p,\n                                          Elf32_Word *default_symbol_index_p)\n{\n  Dl_info info;\n  struct link_map* map;\n  void* result = NULL;\n\n  // Retrieve the link_map for the library given by addr\n  int ret = dladdr1(addr, &info, (void**)&map, RTLD_DL_LINKMAP);\n  if (!ret) {\n    JWARNING(false)(symbol)\n            .Text(\"dladdr1 could not find shared object for address\");\n    return NULL;\n  }\n\n\n  // Handle RTLD_DEFAULT starts search at first loaded object\n  if (handle == RTLD_DEFAULT || libname != NULL) {\n    while (map->l_prev) {\n      // Rewinding to search by load order\n      map = map->l_prev;\n    }\n  }\n\n  // Handle RTLD_NEXT starts search after current library\n  if (handle == RTLD_NEXT) {\n    // Skip current library\n    if (!map->l_next) {\n      JTRACE(\"There are no libraries after the current library.\");\n      return NULL;\n    }\n    map = map->l_next;\n  }\n\n  // Search through libraries until end of list is reached or symbol is found.\n  while (map) {\n    // printf(\"l_name: %s\\n\", map->l_name);\n    /* If the caller specified a specific library name, only search through\n     * that.\n     */\n    if (libname == NULL ||\n        (strlen(map->l_name) > 0 && strstr(map->l_name, libname)))  {\n      // Search current library\n      result = dlsym_default_internal_library_handler((void*) map,\n                                                      symbol,\n                                                      version,\n                                                      tags_p,\n                                                      default_symbol_index_p);\n    }\n    if (result) {\n      return result;\n    }\n\n    // Change link map to next library\n    map = map->l_next;\n  }\n  return NULL;\n}\n\n// Produces an error message and hard fails if no default_symbol was found.\nstatic void print_debug_messages(dt_tag tags, Elf32_Word default_symbol_index,\n                                 const char *symbol)\n{\n#ifdef VERBOSE\n  if (default_symbol_index) {\n    JTRACE(\"** st_value: \")\n          (tags.base_addr + tags.symtab[default_symbol_index].st_value);\n    JTRACE(\"** symbol version: \")\n          (version_name(tags.versym[default_symbol_index], &tags));\n  }\n#endif\n  if (!default_symbol_index) {\n    JTRACE(\"ERROR:  No default symbol version found\"\n           \"        Extend code to look for hidden symbols?\")(symbol);\n  }\n}\n\n// Like dlsym but finds the 'default' symbol of a library (the symbol that the\n// dynamic executable automatically links to) rather than the oldest version\n// which is what dlsym finds\n\n/*\n * This implementation tries to mimic the behavior of the linking-loader,\n * as opposed to dlsym().  In particular, if no versioned symbol exists,\n * then the standard symbol is returned.  If more than one versioned symbol\n * exists, and all but one have the hidden bit set, then the version without\n * the hidden bit is returned.  If only one versioned symbol exists, then\n * it is returned whether the hidden bit is set or not.  From examples\n * in various libraries, it seems that when only one versioned symbol\n * exists, it has the hidden bit set.  If two or more versions of the\n * symbol exist, and the hidden bit is set in all cases, then the newest\n * version is returned.  If two or more versions of the symbol exist in\n * which the hidden bit is not set, then the behavior is undefined. [\n * OR DO WE HAVE A FIXED BEHAVIOR HERE? I THINK THIS CASE DOESN'T OCCUR\n * IN THE ACTUAL LIBRARIES. ] If the unversioned symbol and the versioned\n * symbol both exist, then the versioned symbol is preferred. [LET'S CHECK\n * THE CORRECTNESS OF THIS LAST RULE.]  Note that dlsym() in libdl.so seems\n * to follow the unusual rule of ignoring the hidden bit, and choosing a\n * somewhat arbtrary version that is often the oldest version.\n */\n\nEXTERNC void *dmtcp_dlsym(void *handle, const char*symbol) {\n  dt_tag tags;\n  Elf32_Word default_symbol_index = 0;\n\n#ifdef __USE_GNU\n  if (handle == RTLD_NEXT || handle == RTLD_DEFAULT) {\n    // Determine where this function will return\n    void* return_address = __builtin_return_address(0);\n    // Search for symbol using given pseudo-handle order\n    void *result = dlsym_default_internal_flag_handler(handle, NULL, symbol,\n                                                       NULL,\n                                                       return_address, &tags,\n                                                       &default_symbol_index);\n    print_debug_messages(tags, default_symbol_index, symbol);\n    return result;\n  }\n#endif\n\n  void *result = dlsym_default_internal_library_handler(handle, symbol,\n                                                        NULL, &tags,\n                                                        &default_symbol_index);\n  print_debug_messages(tags, default_symbol_index, symbol);\n  return result;\n}\n\nEXTERNC void * dmtcp_dlvsym(void *handle, char *symbol, const char *version)\n{\n  dt_tag tags;\n  Elf32_Word default_symbol_index = 0;\n\n#ifdef __USE_GNU\n  if (handle == RTLD_NEXT || handle == RTLD_DEFAULT) {\n    // Determine where this function will return\n    void* return_address = __builtin_return_address(0);\n    // Search for symbol using given pseudo-handle order\n    void *result = dlsym_default_internal_flag_handler(handle, NULL, symbol,\n                                                       version,\n                                                       return_address, &tags,\n                                                       &default_symbol_index);\n    return result;\n  }\n#endif\n\n  void *result = dlsym_default_internal_library_handler(handle, symbol, version,\n                                                        &tags,\n                                                        &default_symbol_index);\n  return result;\n}\n\nEXTERNC void *\ndmtcp_dlsym_lib(const char *libname, const char *symbol)\n{\n  dt_tag tags;\n  Elf32_Word default_symbol_index = 0;\n\n  // Determine where this function will return\n  void* return_address = __builtin_return_address(0);\n  void *result = dlsym_default_internal_flag_handler(NULL, libname, symbol,\n                                                     NULL,\n                                                     return_address, &tags,\n                                                     &default_symbol_index);\n  return result;\n}\n\n/*\n * Returns the offset of the given function within the given shared library\n * or -1 if the function does not exist in the library\n */\nEXTERNC ptrdiff_t\ndmtcp_dlsym_lib_fnc_offset(const char *libname, const char *symbol)\n{\n  dt_tag tags;\n  ptrdiff_t ret = -1;\n  Elf32_Word default_symbol_index = 0;\n\n  // Determine where this function will return\n  void* return_address = __builtin_return_address(0);\n  void *result = dlsym_default_internal_flag_handler(NULL, libname, symbol,\n                                                     NULL,\n                                                     return_address, &tags,\n                                                     &default_symbol_index);\n  if (result) {\n    ret = (char*)result - tags.base_addr;\n  }\n  return ret;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/src/threadsync.cpp": "/****************************************************************************\n *   Copyright (C) 2006-2013 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *  This file is part of DMTCP.                                             *\n *                                                                          *\n *  DMTCP is free software: you can redistribute it and/or                  *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP is distributed in the hope that it will be useful,                *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <sys/types.h>\n\n#include \"threadsync.h\"\n#include \"dmtcpworker.h\"\n#include \"syscallwrappers.h\"\n#include \"workerstate.h\"\n#include \"jassert.h\"\n\nusing namespace dmtcp;\n\n/*\n * _wrapperExecutionLock is used to make the checkpoint safe by making sure\n *   that no user-thread is executing any DMTCP wrapper code when it receives\n *   the checkpoint signal.\n * Working:\n *   On entering the wrapper in DMTCP, the user-thread acquires the read lock,\n *     and releases it before leaving the wrapper.\n *   When the Checkpoint-thread wants to send the SUSPEND signal to user\n *     threads, it must acquire the write lock. It is blocked until all the\n *     existing read-locks by user threads have been released. NOTE that this\n *     is a WRITER-PREFERRED lock.\n *\n * There is a corner case too -- the newly created thread that has not been\n *   initialized yet; we need to take some extra efforts for that.\n * Here are the steps to handle the newly created uninitialized thread:\n *   A counter (_uninitializedThreadCount) for the number of newly\n *     created uninitialized threads is kept.  The counter is made\n *     thread-safe by using a mutex.\n *   The calling thread (parent) increments the counter before calling clone.\n *   The newly created child thread decrements the counter at the end of\n *     initialization in MTCP/DMTCP.\n *   After acquiring the Write lock, the checkpoint thread waits until the\n *     number of uninitialized threads is zero. At that point, no thread is\n *     executing in the clone wrapper and it is safe to do a checkpoint.\n *\n * XXX: Currently this security is provided only for the clone wrapper; this\n * should be extended to other calls as well.           -- KAPIL\n */\n// NOTE: PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP is not POSIX.\nstatic pthread_rwlock_t\n  _wrapperExecutionLock = PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP;\nstatic pthread_rwlock_t\n  _threadCreationLock = PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP;\nstatic bool _wrapperExecutionLockAcquiredByCkptThread = false;\nstatic bool _threadCreationLockAcquiredByCkptThread = false;\n\nstatic pthread_mutex_t destroyDmtcpWorkerLock = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_mutex_t theCkptCanStart = PTHREAD_MUTEX_INITIALIZER;\nstatic int ckptCanStartCount = 0;\n\nstatic pthread_mutex_t libdlLock = PTHREAD_MUTEX_INITIALIZER;\nstatic pid_t libdlLockOwner = 0;\n\nstatic pthread_mutex_t uninitializedThreadCountLock = PTHREAD_MUTEX_INITIALIZER;\nstatic int _uninitializedThreadCount = 0;\nstatic bool _checkpointThreadInitialized = false;\n\n#define INVALID_USER_THREAD_COUNT 0\nstatic int preResumeThreadCount = INVALID_USER_THREAD_COUNT;\nstatic pthread_mutex_t preResumeThreadCountLock = PTHREAD_MUTEX_INITIALIZER;\n\nstatic __thread int _wrapperExecutionLockLockCount = 0;\nstatic __thread int _threadCreationLockLockCount = 0;\n#if TRACK_DLOPEN_DLSYM_FOR_LOCKS\nstatic __thread bool _threadPerformingDlopenDlsym = false;\n#endif\nstatic __thread bool _sendCkptSignalOnFinalUnlock = false;\nstatic __thread bool _isOkToGrabWrapperExecutionLock = true;\nstatic __thread bool _hasThreadFinishedInitialization = false;\n\n\n/* The following two functions dmtcp_libdlLock{Lock,Unlock} are used by dlopen\n * plugin.\n */\nextern \"C\" int dmtcp_libdlLockLock() {\n  return ThreadSync::libdlLockLock();\n}\n\nextern \"C\" void dmtcp_libdlLockUnlock() {\n  ThreadSync::libdlLockUnlock();\n}\n\nvoid ThreadSync::initThread()\n{\n  // We initialize these thread-local variables here. If not done here,\n  // there can be a race between checkpoint processing and this\n  // thread trying to initialize some thread-local variable.\n  // Here is a possible calltrace:\n  //   pthread_start -> threadFinishedInitialization -> stopthisthread ->\n  //   callbackHoldsAnyLocks -> JASSERT().\n  _wrapperExecutionLockLockCount = 0;\n  _threadCreationLockLockCount = 0;\n#if TRACK_DLOPEN_DLSYM_FOR_LOCKS\n  _threadPerformingDlopenDlsym = false;\n#endif\n  _sendCkptSignalOnFinalUnlock = false;\n  _isOkToGrabWrapperExecutionLock = true;\n  _hasThreadFinishedInitialization = false;\n}\n\nvoid ThreadSync::initMotherOfAll()\n{\n  initThread();\n  _hasThreadFinishedInitialization = true;\n}\n\nvoid ThreadSync::acquireLocks()\n{\n  JASSERT(WorkerState::currentState() == WorkerState::RUNNING);\n  /* TODO: We should introduce the notion of lock ranks/priorities for all\n   * these locks to prevent future deadlocks due to rank violation.\n   */\n\n  JLOG(DMTCP)(\"waiting for dmtcp_lock():\"\n         \" to get synchronized with _runCoordinatorCmd if we use DMTCP API\");\n  _dmtcp_lock();\n\n  JLOG(DMTCP)(\"Waiting for lock(&theCkptCanStart)\");\n  JASSERT(_real_pthread_mutex_lock(&theCkptCanStart) == 0)(JASSERT_ERRNO);\n\n  JLOG(DMTCP)(\"Waiting for libdlLock\");\n  JASSERT(_real_pthread_mutex_lock(&libdlLock) == 0) (JASSERT_ERRNO);\n\n  JLOG(DMTCP)(\"Waiting for threads creation lock\");\n  JASSERT(_real_pthread_rwlock_wrlock(&_threadCreationLock) == 0)\n    (JASSERT_ERRNO);\n  _threadCreationLockAcquiredByCkptThread = true;\n\n  JLOG(DMTCP)(\"Waiting for other threads to exit DMTCP-Wrappers\");\n  JASSERT(_real_pthread_rwlock_wrlock(&_wrapperExecutionLock) == 0)\n    (JASSERT_ERRNO);\n  _wrapperExecutionLockAcquiredByCkptThread = true;\n\n  JLOG(DMTCP)(\"Waiting for newly created threads to finish initialization\")\n    (_uninitializedThreadCount);\n  waitForThreadsToFinishInitialization();\n\n  unsetOkToGrabLock();\n  JLOG(DMTCP)(\"Done acquiring all locks\");\n}\n\nvoid ThreadSync::releaseLocks()\n{\n  JASSERT(WorkerState::currentState() == WorkerState::SUSPENDED);\n\n  JLOG(DMTCP)(\"Releasing ThreadSync locks\");\n  JASSERT(_real_pthread_rwlock_unlock(&_wrapperExecutionLock) == 0)\n    (JASSERT_ERRNO);\n  _wrapperExecutionLockAcquiredByCkptThread = false;\n  JASSERT(_real_pthread_rwlock_unlock(&_threadCreationLock) == 0)\n    (JASSERT_ERRNO);\n  _threadCreationLockAcquiredByCkptThread = false;\n  JASSERT(_real_pthread_mutex_unlock(&libdlLock) == 0) (JASSERT_ERRNO);\n  JASSERT(_real_pthread_mutex_unlock(&theCkptCanStart) == 0) (JASSERT_ERRNO);\n\n  _dmtcp_unlock();\n  setOkToGrabLock();\n}\n\nvoid ThreadSync::resetLocks()\n{\n  pthread_rwlock_t newLock = PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP;\n  _wrapperExecutionLock = newLock;\n  _threadCreationLock = newLock;\n\n  _wrapperExecutionLockLockCount = 0;\n  _threadCreationLockLockCount = 0;\n#if TRACK_DLOPEN_DLSYM_FOR_LOCKS\n  _threadPerformingDlopenDlsym = false;\n#endif\n  _sendCkptSignalOnFinalUnlock = false;\n  _isOkToGrabWrapperExecutionLock = true;\n  _hasThreadFinishedInitialization = true;\n\n  pthread_mutex_t newCountLock = PTHREAD_MUTEX_INITIALIZER;\n  uninitializedThreadCountLock = newCountLock;\n  pthread_mutex_t newPreResumeThreadCountLock = PTHREAD_MUTEX_INITIALIZER;\n  preResumeThreadCountLock = newPreResumeThreadCountLock;\n\n  pthread_mutex_t newDestroyDmtcpWorker = PTHREAD_MUTEX_INITIALIZER;\n  destroyDmtcpWorkerLock = newDestroyDmtcpWorker;\n\n  pthread_mutex_t newLibdlLock = PTHREAD_MUTEX_INITIALIZER;\n  libdlLock = newLibdlLock;\n  libdlLockOwner = 0;\n\n  _checkpointThreadInitialized = false;\n  _wrapperExecutionLockAcquiredByCkptThread = false;\n  _threadCreationLockAcquiredByCkptThread = false;\n}\n\nbool ThreadSync::isThisThreadHoldingAnyLocks()\n{\n  // If the wrapperExec lock has been acquired by the ckpt thread, then we are\n  // certainly not holding it :). It's possible for the count to be still '1',\n  // as it may happen that the thread got suspended after releasing the lock\n  // and before decrementing the lock-count.\n  if (_hasThreadFinishedInitialization == false) {\n    return true;\n  }\n  return (_wrapperExecutionLockAcquiredByCkptThread == false ||\n          _threadCreationLockAcquiredByCkptThread == false) &&\n         (_threadCreationLockLockCount > 0 ||\n          _wrapperExecutionLockLockCount > 0);\n}\n\nbool ThreadSync::isOkToGrabLock()\n{\n  return _isOkToGrabWrapperExecutionLock;\n}\n\nvoid ThreadSync::setOkToGrabLock()\n{\n  _isOkToGrabWrapperExecutionLock = true;\n}\n\nvoid ThreadSync::unsetOkToGrabLock()\n{\n  _isOkToGrabWrapperExecutionLock = false;\n}\n\nvoid ThreadSync::setSendCkptSignalOnFinalUnlock()\n{\n  JASSERT(_sendCkptSignalOnFinalUnlock == false);\n  _sendCkptSignalOnFinalUnlock = true;\n}\n\nvoid ThreadSync::sendCkptSignalOnFinalUnlock()\n{\n  if (_sendCkptSignalOnFinalUnlock && isThisThreadHoldingAnyLocks() == false) {\n    _sendCkptSignalOnFinalUnlock = false;\n    JASSERT(raise(DmtcpWorker::determineCkptSignal()) == 0)\n      (getpid()) (dmtcp_gettid()) (JASSERT_ERRNO);\n  }\n}\n\n#if TRACK_DLOPEN_DLSYM_FOR_LOCKS\nextern \"C\" LIB_PRIVATE\nvoid dmtcp_setThreadPerformingDlopenDlsym()\n{\n  ThreadSync::setThreadPerformingDlopenDlsym();\n}\n\nextern \"C\" LIB_PRIVATE\nvoid dmtcp_unsetThreadPerformingDlopenDlsym()\n{\n  ThreadSync::unsetThreadPerformingDlopenDlsym();\n}\n\nbool ThreadSync::isThreadPerformingDlopenDlsym()\n{\n  return _threadPerformingDlopenDlsym;\n}\n\nvoid ThreadSync::setThreadPerformingDlopenDlsym()\n{\n  _threadPerformingDlopenDlsym = true;\n}\n\nvoid ThreadSync::unsetThreadPerformingDlopenDlsym()\n{\n  _threadPerformingDlopenDlsym = false;\n}\n#endif\n\nvoid ThreadSync::destroyDmtcpWorkerLockLock()\n{\n  JASSERT(_real_pthread_mutex_lock(&destroyDmtcpWorkerLock) == 0)\n    (JASSERT_ERRNO);\n}\n\nint ThreadSync::destroyDmtcpWorkerLockTryLock()\n{\n  return _real_pthread_mutex_trylock(&destroyDmtcpWorkerLock);\n}\n\nvoid ThreadSync::destroyDmtcpWorkerLockUnlock()\n{\n  JASSERT(_real_pthread_mutex_unlock(&destroyDmtcpWorkerLock) == 0)\n    (JASSERT_ERRNO);\n}\n\nvoid ThreadSync::delayCheckpointsLock()\n{\n  if (ckptCanStartCount++ == 0) {\n    JASSERT(_real_pthread_mutex_lock(&theCkptCanStart)==0)(JASSERT_ERRNO);\n  }\n}\n\nvoid ThreadSync::delayCheckpointsUnlock() {\n  if (--ckptCanStartCount == 0) {\n    JASSERT(_real_pthread_mutex_unlock(&theCkptCanStart)==0)(JASSERT_ERRNO);\n  }\n}\n\nstatic void incrementWrapperExecutionLockLockCount()\n{\n  _wrapperExecutionLockLockCount++;\n}\n\nstatic void decrementWrapperExecutionLockLockCount()\n{\n  if (_wrapperExecutionLockLockCount <= 0) {\n    JASSERT(false) (_wrapperExecutionLockLockCount)\n      .Text(\"wrapper-execution lock count can't be negative\");\n  }\n  _wrapperExecutionLockLockCount--;\n  ThreadSync::sendCkptSignalOnFinalUnlock();\n}\n\nstatic void incrementThreadCreationLockLockCount()\n{\n  _threadCreationLockLockCount++;\n}\n\nstatic void decrementThreadCreationLockLockCount()\n{\n  _threadCreationLockLockCount--;\n  ThreadSync::sendCkptSignalOnFinalUnlock();\n}\n\nbool ThreadSync::libdlLockLock()\n{\n  int saved_errno = errno;\n  bool lockAcquired = false;\n  if (WorkerState::currentState() == WorkerState::RUNNING &&\n      libdlLockOwner !=  dmtcp_gettid()) {\n    JASSERT(_real_pthread_mutex_lock(&libdlLock) == 0);\n    libdlLockOwner = dmtcp_gettid();\n    lockAcquired = true;\n  }\n  errno = saved_errno;\n  return lockAcquired;\n}\n\nvoid ThreadSync::libdlLockUnlock()\n{\n  int saved_errno = errno;\n  JASSERT(libdlLockOwner == 0 || libdlLockOwner == dmtcp_gettid())\n    (libdlLockOwner) (dmtcp_gettid());\n  JASSERT (WorkerState::currentState() == WorkerState::RUNNING);\n  libdlLockOwner = 0;\n  JASSERT(_real_pthread_mutex_unlock(&libdlLock) == 0);\n  errno = saved_errno;\n}\n\n// XXX: Handle deadlock error code\n// NOTE: Don't do any fancy stuff in this wrapper which can cause the process\n//       to go into DEADLOCK\nbool ThreadSync::wrapperExecutionLockLock()\n{\n  int saved_errno = errno;\n  bool lockAcquired = false;\n  // Ignore locks if we are about to exit\n  if (DmtcpWorker::exitInProgress()) {\n    return false;\n  }\n  while (1) {\n    if (WorkerState::currentState() == WorkerState::RUNNING &&\n#if TRACK_DLOPEN_DLSYM_FOR_LOCKS\n        isThreadPerformingDlopenDlsym() == false &&\n#endif\n        isOkToGrabLock() == true &&\n        _wrapperExecutionLockLockCount == 0) {\n      incrementWrapperExecutionLockLockCount();\n      int retVal = _real_pthread_rwlock_tryrdlock(&_wrapperExecutionLock);\n      if (retVal != 0 && retVal == EBUSY) {\n        decrementWrapperExecutionLockLockCount();\n        struct timespec sleepTime = {0, 100*1000*1000};\n        nanosleep(&sleepTime, NULL);\n        continue;\n      }\n      if (retVal != 0 && retVal != EDEADLK) {\n        fprintf(stderr, \"ERROR %d at %s:%d %s: Failed to acquire lock\\n\",\n                errno, __FILE__, __LINE__, __PRETTY_FUNCTION__);\n        _exit(DMTCP_FAIL_RC);\n      }\n      // retVal should always be 0 (success) here.\n      lockAcquired = retVal == 0 ? true : false;\n      if (!lockAcquired) {\n        decrementWrapperExecutionLockLockCount();\n      }\n    }\n    break;\n  }\n  errno = saved_errno;\n  return lockAcquired;\n}\n\n/*\n * Execute fork() and exec() wrappers in exclusive mode\n *\n * fork() and exec() wrappers pass on the state/information about the current\n * process/program to the to-be-created process/program.\n *\n * There can be a potential race in the wrappers if this information gets\n * changed between the point where it was acquired and the point where the\n * process/program is created. An example of this situation would be a\n * different thread executing an open() call in parallel creating a\n * file-descriptor, which is not a part of the information/state gathered\n * earlier. This can result in unexpected behavior and can cause the\n * program/process to fail.\n *\n * This patch fixes this by acquiring the Wrapper-protection-lock in exclusive\n * mode (write-lock) when executing these wrappers. This guarantees that no\n * other thread would be executing inside a wrapper that can change the process\n * state/information.\n *\n * NOTE:\n * 1. Currently, we do not have WRAPPER_EXECUTION_LOCK/UNLOCK for socket()\n *    family of wrapper. That would be fixed in a later commit.\n * 2. We need to come up with a strategy for certain blocking system calls\n *    that can change the state of the process (e.g. accept).\n * 3. Using trywrlock() can result in starvation if multiple other threads are\n *    rapidly acquiring releasing the lock. For example thread A acquires the\n *    rdlock for 100 ms. Thread B executes and trywrlock and fails. Thread B\n *    sleeps goes to sleep for some time. While thread B is sleeping, thread A\n *    releases the rdlock and reacquires it or some other thread acquires the\n *    rdlock. This would cause the thread B to starve. This scenario can be\n *    easily observed if thread A calls\n *      epoll_wait(fd, events, max_events, -1).\n *    It is wrapped by the epoll_wait wrapper in IPC plugin, which then makes\n *    repeated calls to _real_epoll_wait with smaller timeout.\n */\nbool ThreadSync::wrapperExecutionLockLockExcl()\n{\n  int saved_errno = errno;\n  bool lockAcquired = false;\n  // Ignore locks if we are about to exit\n  if (DmtcpWorker::exitInProgress()) {\n    return false;\n  }\n  if (WorkerState::currentState() == WorkerState::RUNNING) {\n    incrementWrapperExecutionLockLockCount();\n    int retVal = _real_pthread_rwlock_wrlock(&_wrapperExecutionLock);\n    if (retVal != 0 && retVal != EDEADLK) {\n      fprintf(stderr, \"ERROR %s:%d %s: Failed to acquire lock\\n\",\n              __FILE__, __LINE__, __PRETTY_FUNCTION__);\n      _exit(DMTCP_FAIL_RC);\n    }\n    lockAcquired = retVal == 0 ? true : false;\n    if (!lockAcquired) {\n      decrementWrapperExecutionLockLockCount();\n    }\n  }\n  errno = saved_errno;\n  return lockAcquired;\n}\n\n// NOTE: Don't do any fancy stuff in this wrapper which can cause the process\n// to go into DEADLOCK\nvoid ThreadSync::wrapperExecutionLockUnlock()\n{\n  int saved_errno = errno;\n  // Ignore locks if we are about to exit\n  /*\n   * NOTE: Ideally, this function should never be called from a wrapper if\n   *       exitInProgress is set, but there are two cases when it gets\n   *       called despite the flag being set:\n   *       1) The exitInProgress flag is set, and then an incorrectly\n   *          implemented wrapper calls this function even though the\n   *          lock function returned false. See commit:\n   *          f2d2a7c6feba38ab0b0cb8e09a4ad6cc37d9f330 for an example.\n   *       2) A correctly implemented wrapper calls this but the exitInProgress\n   *          is set after having acquired the wrapperExecution lock. This can\n   *          occur if a user thread called exit while another was\n   *          in the middle of the wrapper.\n   *       The following if clause guards against both the scenarios.\n   * TODO: Add a message that warns the user if any of the above\n   *       two cases are seen.\n   *\n   */\n\n  if (DmtcpWorker::exitInProgress()) {\n    return;\n  }\n  if (_real_pthread_rwlock_unlock(&_wrapperExecutionLock) != 0) {\n    fprintf(stderr, \"ERROR %s:%d %s: Failed to release lock\\n\",\n            __FILE__, __LINE__, __PRETTY_FUNCTION__);\n    _exit(DMTCP_FAIL_RC);\n  } else {\n    decrementWrapperExecutionLockLockCount();\n  }\n  errno = saved_errno;\n}\n\nbool ThreadSync::threadCreationLockLock()\n{\n  int saved_errno = errno;\n  bool lockAcquired = false;\n  while (1) {\n    if (WorkerState::currentState() == WorkerState::RUNNING) {\n      incrementThreadCreationLockLockCount();\n      int retVal = _real_pthread_rwlock_tryrdlock(&_threadCreationLock);\n      if (retVal != 1 && retVal == EBUSY) {\n        decrementThreadCreationLockLockCount();\n        struct timespec sleepTime = {0, 100*1000*1000};\n        nanosleep(&sleepTime, NULL);\n        continue;\n      }\n      if (retVal != 0 && retVal != EDEADLK) {\n        fprintf(stderr, \"ERROR %s:%d %s: Failed to acquire lock\\n\",\n                __FILE__, __LINE__, __PRETTY_FUNCTION__);\n        _exit(DMTCP_FAIL_RC);\n      }\n      // retVal should always be 0 (success) here.\n      lockAcquired = retVal == 0 ? true : false;\n\n      // If for some reason, the lock was not acquired, decrement the count\n      // that we incremented at the start of this block.\n      if (!lockAcquired) {\n        decrementThreadCreationLockLockCount();\n      }\n    }\n    break;\n  }\n  errno = saved_errno;\n  return lockAcquired;\n}\n\nvoid ThreadSync::threadCreationLockUnlock()\n{\n  int saved_errno = errno;\n  if (WorkerState::currentState() != WorkerState::RUNNING) {\n    fprintf(stderr, \"DMTCP INTERNAL ERROR: %s:%d %s:\\n\"\n            \"       This process is not in RUNNING state and yet this thread\\n\"\n            \"       managed to acquire the threadCreationLock.\\n\"\n            \"       This should not be happening, something is wrong.\",\n            __FILE__, __LINE__, __PRETTY_FUNCTION__);\n    _exit(DMTCP_FAIL_RC);\n  }\n  if (_real_pthread_rwlock_unlock(&_threadCreationLock) != 0) {\n    fprintf(stderr, \"ERROR %s:%d %s: Failed to release lock\\n\",\n            __FILE__, __LINE__, __PRETTY_FUNCTION__);\n    _exit(DMTCP_FAIL_RC);\n  } else {\n    decrementThreadCreationLockLockCount();\n  }\n  errno = saved_errno;\n}\n\n// GNU g++ uses __thread.  But the C++0x standard says to use thread_local.\n//   If your compiler fails here, you can: change \"__thread\" to \"thread_local\";\n//   or delete \"__thread\" (but if user code calls these routines from multiple\n//   threads, it will not be thread-safe).\n//   In GCC 4.3 and later, g++ supports -std=c++0x and -std=g++0x.\nextern \"C\"\nint dmtcp_plugin_disable_ckpt()\n{\n  return ThreadSync::wrapperExecutionLockLock();\n}\n\nextern \"C\"\nvoid dmtcp_plugin_enable_ckpt()\n{\n  ThreadSync::wrapperExecutionLockUnlock();\n}\n\n\nvoid ThreadSync::waitForThreadsToFinishInitialization()\n{\n  while (_uninitializedThreadCount != 0) {\n    struct timespec sleepTime = {0, 10*1000*1000};\n    JLOG(DMTCP)(\"sleeping\")(sleepTime.tv_nsec);\n    nanosleep(&sleepTime, NULL);\n  }\n}\n\nvoid ThreadSync::incrementUninitializedThreadCount()\n{\n  int saved_errno = errno;\n  if (WorkerState::currentState() == WorkerState::RUNNING) {\n    JASSERT(_real_pthread_mutex_lock(&uninitializedThreadCountLock) == 0)\n      (JASSERT_ERRNO);\n    _uninitializedThreadCount++;\n    //JLOG(DMTCP)(\":\") (_uninitializedThreadCount);\n    JASSERT(_real_pthread_mutex_unlock(&uninitializedThreadCountLock) == 0)\n      (JASSERT_ERRNO);\n  }\n  errno = saved_errno;\n}\n\nvoid ThreadSync::decrementUninitializedThreadCount()\n{\n  int saved_errno = errno;\n  if (WorkerState::currentState() == WorkerState::RUNNING) {\n    JASSERT(_real_pthread_mutex_lock(&uninitializedThreadCountLock) == 0)\n      (JASSERT_ERRNO);\n    JASSERT(_uninitializedThreadCount > 0) (_uninitializedThreadCount);\n    _uninitializedThreadCount--;\n    //JLOG(DMTCP)(\":\") (_uninitializedThreadCount);\n    JASSERT(_real_pthread_mutex_unlock(&uninitializedThreadCountLock) == 0)\n      (JASSERT_ERRNO);\n  }\n  errno = saved_errno;\n}\n\nvoid ThreadSync::threadFinishedInitialization()\n{\n  // The following line is to make sure the thread-local data is initialized\n  // before any wrapper call is made.\n  _hasThreadFinishedInitialization = false;\n  decrementUninitializedThreadCount();\n  _hasThreadFinishedInitialization = true;\n  ThreadSync::sendCkptSignalOnFinalUnlock();\n}\n\nvoid ThreadSync::incrNumUserThreads()\n{\n  // This routine is called from within stopthisthread so it is not safe to\n  // call JNOTE/JLOG(DMTCP) etc.\n  if (_real_pthread_mutex_lock(&preResumeThreadCountLock) != 0) {\n    JASSERT(false) .Text(\"Failed to acquire preResumeThreadCountLock\");\n  }\n  preResumeThreadCount++;\n  if (_real_pthread_mutex_unlock(&preResumeThreadCountLock) != 0) {\n    JASSERT(false) .Text(\"Failed to release preResumeThreadCountLock\");\n  }\n}\n\nvoid ThreadSync::processPreResumeCB()\n{\n  if (_real_pthread_mutex_lock(&preResumeThreadCountLock) != 0) {\n    JASSERT(false) .Text(\"Failed to acquire preResumeThreadCountLock\");\n  }\n  JASSERT(preResumeThreadCount > 0) (dmtcp_gettid()) (preResumeThreadCount);\n  preResumeThreadCount--;\n  if (_real_pthread_mutex_unlock(&preResumeThreadCountLock) != 0) {\n    JASSERT(false) .Text(\"Failed to release preResumeThreadCountLock\");\n  }\n}\n\nvoid ThreadSync::waitForUserThreadsToFinishPreResumeCB()\n{\n  if (preResumeThreadCount != INVALID_USER_THREAD_COUNT) {\n    while (preResumeThreadCount != 0) {\n      struct timespec sleepTime = {0, 10*1000*1000};\n      nanosleep(&sleepTime, NULL);\n    }\n  }\n  // Now we wait for the lock to make sure that the user threads have released\n  // it.\n  if (_real_pthread_mutex_lock(&preResumeThreadCountLock) != 0) {\n    JASSERT(false) .Text(\"Failed to acquire preResumeThreadCountLock\");\n  }\n  if (_real_pthread_mutex_unlock(&preResumeThreadCountLock) != 0) {\n    JASSERT(false) .Text(\"Failed to release preResumeThreadCountLock\");\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/src/util_exec.cpp": "/****************************************************************************\n *   Copyright (C) 2006-2013 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *  This file is part of DMTCP.                                             *\n *                                                                          *\n *  DMTCP is free software: you can redistribute it and/or                  *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP is distributed in the hope that it will be useful,                *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#include <string.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include  \"util.h\"\n#include  \"syscallwrappers.h\"\n#include  \"uniquepid.h\"\n#include  \"protectedfds.h\"\n#include  \"shareddata.h\"\n#include  \"../jalib/jassert.h\"\n#include  \"../jalib/jfilesystem.h\"\n#include  \"../jalib/jconvert.h\"\n\nusing namespace dmtcp;\n\nstatic int32_t getDlsymOffset();\nstatic int32_t getDlsymOffset_m32();\n\nvoid Util::setVirtualPidEnvVar(pid_t pid, pid_t virtPpid, pid_t realPpid)\n{\n  // We want to use setenv() only once. For all later changes, we manipulate\n  // the buffer in place. This was done to avoid a bug when using Perl. Perl\n  // implements its own setenv by keeping a private copy libc:environ and never\n  // refers to libc:private, thus libc:setenv is outdated and calling setenv()\n  // can cause segfault.\n  char buf1[80];\n  char buf2[80];\n  memset(buf2, '#', sizeof(buf2));\n  buf2[sizeof(buf2) - 1] = '\\0';\n\n  sprintf(buf1, \"%d:%d:%d:\", pid, virtPpid, realPpid);\n\n  if (getenv(ENV_VAR_VIRTUAL_PID) == NULL) {\n    memcpy(buf2, buf1, strlen(buf1));\n    setenv(ENV_VAR_VIRTUAL_PID, buf2, 1);\n  } else {\n    char *envStr = (char*) getenv(ENV_VAR_VIRTUAL_PID);\n    memcpy(envStr, buf1, strlen(buf1));\n  }\n}\n\n// 'screen' requires directory with permissions 0700\nstatic int isdir0700(const char *pathname)\n{\n  struct stat st;\n  stat(pathname, &st);\n  return (S_ISDIR(st.st_mode) == 1\n          && (st.st_mode & 0777) == 0700\n          && st.st_uid == getuid()\n          && access(pathname, R_OK | W_OK | X_OK) == 0\n      );\n}\n\nint Util::safeMkdir(const char *pathname, mode_t mode)\n{\n  // If it exists and we can give it the right permissions, do it.\n  chmod(pathname, 0700);\n  if (isdir0700(pathname))\n    return 0;\n  // else start over\n  unlink(pathname);\n  rmdir(pathname); // Maybe it was an empty directory\n  mkdir(pathname, 0700);\n  return isdir0700(pathname);\n}\n\nint Util::safeSystem(const char *command)\n{\n  char *str = getenv(\"LD_PRELOAD\");\n  string dmtcphjk;\n  if (str != NULL)\n    dmtcphjk = str;\n  unsetenv(\"LD_PRELOAD\");\n  int rc = _real_system(command);\n  if (str != NULL)\n    setenv(\"LD_PRELOAD\", dmtcphjk.c_str(), 1);\n  return rc;\n}\n\nint Util::expandPathname(const char *inpath, char * const outpath,\n                                size_t size)\n{\n  bool success = false;\n  if (*inpath == '/' || strstr(inpath, \"/\") != NULL) {\n    strncpy(outpath, inpath, size);\n    success = true;\n  } else if (strStartsWith(inpath, \"~/\")) {\n    snprintf(outpath, size, \"%s%s\", getenv(\"HOME\"), &inpath[1]);\n    success = true;\n  } else if (strStartsWith(inpath, \"~\")) {\n    snprintf(outpath, size, \"/home/%s\", &inpath[1]);\n    success = true;\n  } else if (strStartsWith(inpath, \".\")) {\n    snprintf(outpath, size, \"%s/%s\", jalib::Filesystem::GetCWD().c_str(),\n                                     inpath);\n    success = true;\n  } else {\n    char *pathVar = getenv(\"PATH\");\n    outpath[0] = '\\0';\n    if (pathVar == NULL) {\n      pathVar = (char*) \":/bin:/usr/bin\";\n    }\n    while (*pathVar != '\\0') {\n      char *nextPtr;\n      nextPtr = strchrnul(pathVar, ':');\n      if (nextPtr == pathVar) {\n        /* Two adjacent colons, or a colon at the beginning or the end\n           of `PATH' means to search the current directory.  */\n        strcpy(outpath, jalib::Filesystem::GetCWD().c_str());\n      } else {\n        strncpy(outpath, pathVar, nextPtr - pathVar);\n        outpath[nextPtr-pathVar] = '\\0';\n      }\n\n      JASSERT(size > strlen(outpath) + strlen(inpath) + 1)\n        (size) (outpath) (strlen(outpath)) (inpath) (strlen(inpath))\n         .Text(\"Pathname too long; Use larger buffer.\");\n\n      strcat(outpath, \"/\");\n      strcat(outpath, inpath);\n\n      if (*nextPtr  == '\\0')\n        pathVar = nextPtr;\n      else // else *nextPtr == ':'\n        pathVar = nextPtr + 1; // prepare for next iteration\n      if (access(outpath, X_OK) == 0) {\n\tsuccess = true;\n\tbreak;\n      }\n    }\n  }\n  return (success ? 0 : -1);\n}\n\nint Util::elfType(const char *pathname, bool *isElf, bool *is32bitElf)\n{\n  const char *magic_elf = \"\\177ELF\"; // Magic number for ELF\n  const char *magic_elf32 = \"\\177ELF\\001\"; // Magic number for ELF 32-bit\n  // Magic number for ELF 64-bit is \"\\177ELF\\002\"\n  const int len = strlen(magic_elf32);\n  char argv_buf[len + 1];\n  char full_path[PATH_MAX];\n  expandPathname(pathname, full_path, sizeof(full_path));\n  int fd = _real_open(full_path, O_RDONLY, 0);\n  if (fd == -1) {\n    return -1;\n  }\n  ssize_t ret = readAll(fd, argv_buf, len);\n  close (fd);\n  if (ret != len) {\n    return -1;\n  }\n  *isElf = (memcmp(magic_elf, argv_buf, strlen(magic_elf)) == 0);\n  *is32bitElf = (memcmp(magic_elf32, argv_buf, strlen(magic_elf32)) == 0);\n  return 0;\n}\n\nstatic string ld_linux_so_path(int version, bool is32bitElf = false)\n{\n  char buf[80];\n#if (defined(__x86_64__) || defined(__aarch64__)) && !defined(CONFIG_M32)\n  if (is32bitElf) {\n    sprintf(buf, \"/lib/ld-linux.so.%d\", version);\n  } else {\n    sprintf(buf, ELF_INTERPRETER);\n  }\n#else\n  sprintf(buf, ELF_INTERPRETER);\n#endif\n\n  string cmd = buf;\n  return cmd;\n}\n\nbool Util::isStaticallyLinked(const char *filename)\n{\n  bool isElf, is32bitElf;\n  char pathname[PATH_MAX];\n  expandPathname(filename, pathname, sizeof(pathname));\n  elfType(pathname, &isElf, &is32bitElf);\n\n  int version = 2;\n  string cmd;\n  do {\n    cmd = ld_linux_so_path(version, is32bitElf);\n    version++;\n  } while (!jalib::Filesystem::FileExists(cmd) && version < 10);\n\n  cmd = cmd + \" --verify \" + pathname + \" > /dev/null\";\n\n  // FIXME:  When tested on dmtcp/test/pty.c, 'ld.so -verify' returns\n  // nonzero status.  Why is this?  It's dynamically linked.\n  if (isElf && safeSystem(cmd.c_str())) {\n    return true;\n  }\n  return false;\n}\n\nbool Util::isScreen(const char *filename)\n{\n  return jalib::Filesystem::BaseName(filename) == \"screen\" &&\n         isSetuid(filename);\n}\n\n//NOTE:  This routine is called only if 'screen' is setuid.\n// In Ubuntu 9.10, an unprivileged 'screen' (no setuid) will ckpt and restart\n// fine if SCREENDIR is set to the file $USER/tmp4 when $USER/tmp4 doesn't exist\n// Arguably this is a bug in screen-4.0.  Should we take advantage of it?\nvoid Util::setScreenDir() {\n  if (getenv(\"SCREENDIR\") == NULL) {\n    // This will flash by, but the user will see it again on exiting screen.\n    JASSERT_STDERR <<\"*** WARNING: Environment variable SCREENDIR is not set!\\n\"\n                   << \"***  Set this to a safe location, and if restarting on\\n\"\n                   << \"***  a new host, copy your SCREENDIR directory there.\\n\"\n                   << \"***  DMTCP will use\"\n                            \" $DMTCP_TMPDIR/dmtcp-USER@HOST/uscreens for now,\\n\"\n                   << \"***  but this directory may not survive a re-boot!\\n\"\n                   << \"***      As of DMTCP-1.2.3, emacs23 not yet supported\\n\"\n                   << \"***  inside screen.  Please use emacs22 for now.  This\\n\"\n                   << \"***  will be fixed in a future version of DMTCP.\\n\\n\";\n    setenv(\"SCREENDIR\", Util::getScreenDir().c_str(), 1);\n  } else {\n    if (access(getenv(\"SCREENDIR\"), R_OK|W_OK|X_OK) != 0)\n      JASSERT_STDERR << \"*** WARNING: Environment variable SCREENDIR is set\\n\"\n                     << \"***  to directory with improper permissions.\\n\"\n                     << \"***  Please use a SCREENDIR with permission 700.\"\n                     << \"  [ SCREENDIR = \" << getenv(\"SCREENDIR\") << \" ]\\n\"\n                     << \"***  Continuing anyway, and hoping for the best.\\n\";\n  }\n\n}\n\nstring Util::getScreenDir()\n{\n  string tmpdir = string(dmtcp_get_tmpdir()) + \"/\" + \"uscreens\";\n  safeMkdir(tmpdir.c_str(), 0700);\n  return tmpdir;\n}\n\nbool Util::isSetuid(const char *filename)\n{\n  char pathname[PATH_MAX];\n  if (expandPathname(filename, pathname, sizeof(pathname)) ==  0) {\n    struct stat buf;\n    if (stat(pathname, &buf) == 0 && (buf.st_mode & S_ISUID ||\n                                      buf.st_mode & S_ISGID)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid Util::patchArgvIfSetuid(const char* filename, char *const origArgv[],\n                             char ***newArgv)\n{\n  if (isSetuid(filename) == false) return;\n\n  char realFilename[PATH_MAX];\n  memset(realFilename, 0, sizeof(realFilename));\n  expandPathname(filename, realFilename, sizeof (realFilename));\n  //char expandedFilename[PATH_MAX];\n//  expandPathname(filename, expandedFilename, sizeof (expandedFilename));\n//  JASSERT(readlink(expandedFilename, realFilename, PATH_MAX - 1) != -1)\n//    (filename) (expandedFilename) (realFilename) (JASSERT_ERRNO);\n\n  size_t newArgc = 0;\n  while (origArgv[newArgc] != NULL) newArgc++;\n  newArgc += 2;\n  size_t newArgvSize = newArgc * sizeof(char*);\n\n  // IS THIS A MEMORY LEAK?  WHEN DO WE FREE buf?  - Gene\n  void *buf = JALLOC_HELPER_MALLOC(newArgvSize + 2 + PATH_MAX);\n  memset(buf, 0, newArgvSize + 2 + PATH_MAX);\n\n  *newArgv = (char**) buf;\n  char *newFilename = (char*)buf + newArgvSize + 1;\n\n#define COPY_BINARY\n#ifdef COPY_BINARY\n  // cp /usr/bin/screen /tmp/dmtcp-USER@HOST/screen\n  char cpCmdBuf[PATH_MAX * 2 + 8];\n\n  snprintf(newFilename, PATH_MAX, \"%s/%s\",\n                                  dmtcp_get_tmpdir(),\n                                  jalib::Filesystem::BaseName(realFilename).c_str());\n\n  snprintf(cpCmdBuf, sizeof(cpCmdBuf),\n           \"/bin/cp %s %s\", realFilename, newFilename);\n\n  // Remove any stale copy, just in case it's not right.\n  JASSERT(unlink(newFilename) == 0 || errno == ENOENT) (newFilename);\n\n  JASSERT(safeSystem(cpCmdBuf) == 0)(cpCmdBuf)\n    .Text(\"call to system(cpCmdBuf) failed\");\n\n  JASSERT(access(newFilename, X_OK) == 0) (newFilename) (JASSERT_ERRNO);\n\n  (*newArgv)[0] = newFilename;\n  int i;\n  for (i = 1; origArgv[i] != NULL; i++)\n    (*newArgv)[i] = (char*)origArgv[i];\n  (*newArgv)[i] = origArgv[i];  // copy final NULL pointer.\n\n  return;\n#else\n  // FIXME : This might fail to compile. Will fix later. -- Kapil\n  // Translate: screen   to: /lib/ld-linux.so /usr/bin/screen\n  // This version is more general, but has a bug on restart:\n  //    memory layout is altered on restart, and so brk() doesn't match.\n  // Switch argvPtr from ptr to input to ptr to output now.\n  *argvPtr = (char **)(cmdBuf + strlen(cmdBuf) + 1); // ... + 1 for '\\0'\n  // Use /lib64 if 64-bit O/S and not 32-bit app:\n\n  char *ldStrPtr = NULL;\n#if (defined(__x86_64__) || defined(__aarch64__)) && !defined(CONFIG_M32)\n  bool isElf, is32bitElf;\n  elfType(cmdBuf, &isElf, &is32bitElf);\n  if (is32bitElf)\n    ldStrPtr = (char *)\"/lib/ld-linux.so.2\";\n  else\n    ldStrPtr = (char *)ELF_INTERPRETER;\n# else\n  ldStrPtr = (char *)ELF_INTERPRETER;\n# endif\n\n  JASSERT(newArgv0Len > strlen(origPath) + 1)\n    (newArgv0Len) (origPath) (strlen(origPath)) .Text(\"Buffer not large enough\");\n\n  strncpy(newArgv0, origPath, newArgv0Len);\n\n  size_t origArgvLen = 0;\n  while (origArgv[origArgvLen] != NULL)\n    origArgvLen++;\n\n  JASSERT(newArgvLen >= origArgvLen + 1) (origArgvLen) (newArgvLen)\n    .Text(\"newArgv not large enough to hold the expanded argv\");\n\n  // ISN'T THIS A BUG?  newArgv WAS DECLARED 'char ***'.\n  newArgv[0] = ldStrPtr;\n  newArgv[1] = newArgv0;\n  for (int i = 1; origArgv[i] != NULL; i++)\n    newArgv[i+1] = origArgv[i];\n  newArgv[i+1] = origArgv[i]; // Copy final NULL pointer.\n#endif\n  return;\n}\n\nvoid Util::freePatchedArgv(char **newArgv)\n{\n  JALLOC_HELPER_FREE(*newArgv);\n}\n\n// FIXME: ENV_VAR_DLSYM_OFFSET should be reset in _real_dlsym and it should be\n// recalculated/reset right before returning from prepareForExec to support\n// process migration (the offset might have changed after the process had\n// migrated to a new machine with different ld.so.\nvoid Util::prepareDlsymWrapper()\n{\n  /* For the sake of dlsym wrapper. We compute the address of _real_dlsym by\n   * adding dlsym_offset to the address of dlopen after the exec into the user\n   * application. */\n  uint32_t offset = SharedData::getDlsymOffset();\n  uint32_t offset_m32 = SharedData::getDlsymOffset_m32();\n\n  if (offset == 0) {\n    offset = getDlsymOffset();\n    offset_m32 = getDlsymOffset_m32();\n    SharedData::updateDlsymOffset(offset, offset_m32);\n  }\n\n  char str[21] = {0};\n  sprintf(str, \"%d\", offset);\n  setenv(ENV_VAR_DLSYM_OFFSET, str, 1);\n  sprintf(str, \"%d\", offset_m32);\n  setenv(ENV_VAR_DLSYM_OFFSET_M32, str, 1);\n}\n\nstatic int32_t getDlsymOffset()\n{\n  void* base_addr = NULL;\n  void* dlsym_addr = NULL;\n  int32_t offset;\n  void* handle = NULL;\n  handle = dlopen(LIBDL_FILENAME, RTLD_NOW);\n  JASSERT(handle != NULL) (dlerror());\n\n  /* Earlier, we used to compute the offset of \"dlsym\" from \"dlerror\" by\n   * computing the address of the two symbols using '&' operator. However, in\n   * some distros (for ex. SLES 9), '&dlsym' might give the address of the\n   * symbol defined in binary's PLT. Thus, to compute the correct offset, we\n   * use dlopen/dlsym.\n   */\n  base_addr = dlsym(handle, LIBDL_BASE_FUNC_STR);\n  dlsym_addr = dlsym(handle, \"dlsym\");\n  dlclose(handle);\n  offset = (char *)dlsym_addr - (char *)base_addr;\n  return offset;\n}\n\nstatic int32_t getDlsymOffset_m32()\n{\n  uint64_t base_addr = 0;\n  uint64_t dlsym_addr = 0;\n  int32_t offset;\n  FILE *fp;\n  char buf[PATH_MAX];\n  string cmd1, cmd2, libdl, libdmtcp32;\n\n  libdmtcp32 = Util::getPath(\"libdmtcp.so\", true);\n  if (libdmtcp32 == \"libdmtcp.so\") return 0;\n\n  cmd1 = \"ldd \" + libdmtcp32 + \" | grep \" + LIBDL_FILENAME\n       + \" | tr '\\t' ' ' | tr -s ' '| cut -d' ' -f4\";\n  fp = popen(cmd1.c_str(), \"r\");\n  JASSERT(fp != NULL);\n  JASSERT(fscanf(fp, \"%s\", (char*) &buf) == 1);\n  pclose(fp);\n  JASSERT(buf[0] == '/');\n\n  libdl = buf;\n\n  cmd2 = \"nm -D -g \" + libdl + \" | grep '\" + LIBDL_BASE_FUNC_STR + \"'\";\n  fp = popen(cmd2.c_str(), \"r\");\n  JASSERT(fp != NULL);\n  // fread returns the total number of bytes read only when 'size' is 1.\n  JASSERT(fread(buf, 1, sizeof(buf), fp) > 0);\n  base_addr = strtoull(buf, NULL, 16);\n  JASSERT(base_addr != 0);\n  pclose(fp);\n\n  cmd2 = \"nm -D -g \" + libdl + \" | grep 'dlsym'\";\n  fp = popen(cmd2.c_str(), \"r\");\n  JASSERT(fp != NULL);\n  JASSERT(fread(buf, 1, sizeof(buf), fp) > 0);\n  dlsym_addr = strtoull(buf, NULL, 16);\n  JASSERT(base_addr != 0);\n  pclose(fp);\n\n  offset = (int32_t) ((char *)dlsym_addr - (char *)base_addr);\n  return offset;\n}\n\nvoid Util::runMtcpRestore(int is32bitElf, const char* path, int fd,\n                                 size_t argvSize, size_t envSize)\n{\n  static string mtcprestart = Util::getPath (\"mtcp_restart\");\n\n  if (is32bitElf) {\n    mtcprestart = Util::getPath(\"mtcp_restart-32\", is32bitElf);\n  }\n\n  // Tell mtcp_restart process to write its debugging information to\n  // PROTECTED_STDERR_FD. This way we prevent it from spitting out garbage onto\n  // FD_STDERR if it is being used by the user process in a special way.\n  char protected_stderr_fd_str[16];\n  sprintf(protected_stderr_fd_str, \"%d\", PROTECTED_STDERR_FD);\n\n  char buf[64];\n  sprintf(buf, \"%d\", fd);\n\n  char* newArgs[] = {\n    (char*) mtcprestart.c_str(),\n    (char*) \"--stderr-fd\",\n    protected_stderr_fd_str,\n    (char*) \"--fd\",\n    buf,\n    NULL\n  };\n  JLOG(DMTCP) (\"launching mtcp_restart --fd\")(fd)(path);\n\n  // Create the placeholder for \"MTCP_OLDPERS\" environment.\n  // setenv(\"MTCP_OLDPERS_DUMMY\", \"XXXXXXXXXXXXXXXX\", 1);\n  // FIXME: Put an explanation of the logic below.   -- Kapil\n#define ENV_PTR(x) ((char*) (getenv(x) - strlen(x) - 1))\n  char* dummyEnviron = NULL;\n  const int pathIndex = 0; // index in newEnv[]\n  const int dummyEnvironIndex = 1; // index in newEnv[]\n  // Eventually, newEnv = {ENV_PTR(\"MTCP_OLDPERS\"), ENV_PTR(\"PATH\"), NULL}\n  // newEnv[2] = NULL; newEnv[3] and newEnv[4] are available so that\n  //    they can easily be used to modify envp inside mtcp_restart.c:main().\n  //    for debugging in GDB.  These appear _after_ final NULL  of newEnv[].\n  char* newEnv[7] = {NULL, NULL, NULL,\n                     const_cast<char *> (\"MTCP_RESTART_PAUSE=1\"),\n                     const_cast<char *> (\"DMTCP_RESTART_PAUSE=1\"),\n                     const_cast<char *> (\"MTCP_RESTART_PAUSE2=1\"),\n                     const_cast<char *> (\"DMTCP_RESTART_PAUSE2=1\")};\n  // Will put ENV_PTR(\"MTCP_OLDPERS\") here.\n  newEnv[dummyEnvironIndex] = (char*) dummyEnviron;\n  newEnv[pathIndex] = (getenv(\"PATH\") ? ENV_PTR(\"PATH\") : NULL);\n\n  size_t newArgsSize = 0;\n  for (int i = 0; newArgs[i] != 0; i++) {\n    newArgsSize += strlen(newArgs[i]) + 1;\n  }\n  size_t newEnvSize = 0;\n  for (int i = 0; newEnv[i] != 0; i++) {\n    newEnvSize += strlen(newEnv[i]) + 1;\n  }\n  size_t originalArgvEnvSize = argvSize + envSize;\n  size_t newArgvEnvSize = newArgsSize + newEnvSize + strlen(newArgs[0]);\n  size_t argvSizeDiff = originalArgvEnvSize - newArgvEnvSize;\n  if (argvSizeDiff > 0) {\n    dummyEnviron = (char*) malloc(argvSizeDiff);\n    memset(dummyEnviron, '0', argvSizeDiff - 1 );\n    strncpy(dummyEnviron,\n            ENV_VAR_DMTCP_DUMMY \"=\",\n            strlen(ENV_VAR_DMTCP_DUMMY \"=\"));\n    dummyEnviron[argvSizeDiff - 1] = '\\0';\n    newEnv[dummyEnvironIndex] = dummyEnviron;\n  }\n\n  JLOG(DMTCP)(\"Args/Env Sizes\")\n    (newArgsSize) (newEnvSize) (argvSize) (envSize) (argvSizeDiff);\n\n  execve (newArgs[0], newArgs, newEnv);\n  JASSERT (false) (newArgs[0]) (newArgs[1]) (JASSERT_ERRNO)\n          .Text (\"exec() failed\");\n}\n\nvoid Util::adjustRlimitStack()\n{\n#ifdef __i386__\n  // This is needed in 32-bit Ubuntu 9.10, to fix bug with test/dmtcp5.c\n  // NOTE:  Setting personality() is cleanest way to force legacy_va_layout,\n  //   but there's currently a bug on restart in the sequence:\n  //   checkpoint -> restart -> checkpoint -> restart\n# if 0\n  { unsigned long oldPersonality = personality(0xffffffffL);\n    if (! (oldPersonality & ADDR_COMPAT_LAYOUT)) {\n      // Force ADDR_COMPAT_LAYOUT for libs in high mem, to avoid vdso conflict\n      personality(oldPersonality & ADDR_COMPAT_LAYOUT);\n      JLOG(DMTCP)(\"setting ADDR_COMPAT_LAYOUT\");\n      setenv(\"DMTCP_ADDR_COMPAT_LAYOUT\", \"temporarily is set\", 1);\n    }\n  }\n# else\n  { struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    if (rlim.rlim_cur != RLIM_INFINITY) {\n      char buf[100];\n      sprintf(buf, \"%lu\", rlim.rlim_cur); // \"%llu\" for BSD/Mac OS\n      JLOG(DMTCP)(\"setting rlim_cur for RLIMIT_STACK\") (rlim.rlim_cur);\n      setenv(\"DMTCP_RLIMIT_STACK\", buf, 1);\n      // Force kernel's internal compat_va_layout to 0; Force libs to high mem.\n      rlim.rlim_cur = rlim.rlim_max;\n      // FIXME: if rlim.rlim_cur != RLIM_INFINITY, then we should warn the user.\n      setrlimit(RLIMIT_STACK, &rlim);\n      // After exec, process will restore DMTCP_RLIMIT_STACK in DmtcpWorker()\n    }\n  }\n# endif\n#endif\n}\n\n// TODO(kapil): rewrite getPath to remove dependency on jalib.\nstring Util::getPath(string cmd, bool is32bit)\n{\n  // search relative to base dir of dmtcp installation.\n  const char *p1[] = {\n    \"/bin/\",\n    \"/lib64/dmtcp/\",\n    \"/lib/dmtcp/\",\n  };\n\n  string suffixFor32Bits;\n#if defined(__x86_64__) || defined(__aarch64__)\n  if (is32bit) {  // if this is a multi-architecture build\n    string basename = jalib::Filesystem::BaseName(cmd);\n    if (cmd == \"mtcp_restart-32\") {\n      suffixFor32Bits = \"32/bin/\";\n    } else {\n      suffixFor32Bits = \"32/lib/dmtcp/\";\n    }\n  }\n#endif\n\n  // Search relative to dir of this command (bin/dmtcp_launch), (using p1).\n  string udir = SharedData::getInstallDir();\n  for (size_t i = 0; i < sizeof(p1) / sizeof(char*); i++) {\n    string pth = udir + p1[i] + suffixFor32Bits + cmd;\n    if (jalib::Filesystem::FileExists(pth)) {\n      return pth;\n    }\n  }\n\n  return cmd;\n}\n\nvoid Util::getDmtcpArgs(vector<string> &dmtcp_args)\n{\n  const char * sigckpt              = getenv (ENV_VAR_SIGCKPT);\n  const char * compression          = getenv (ENV_VAR_COMPRESSION);\n  const char * allocPlugin          = getenv (ENV_VAR_ALLOC_PLUGIN);\n  const char * dlPlugin             = getenv (ENV_VAR_DL_PLUGIN);\n#ifdef HBICT_DELTACOMP\n  const char * deltacompression     = getenv (ENV_VAR_DELTACOMPRESSION);\n#endif\n  const char * ckptOpenFiles        = getenv (ENV_VAR_CKPT_OPEN_FILES);\n  const char * ckptDir              = getenv (ENV_VAR_CHECKPOINT_DIR);\n  const char * tmpDir               = getenv (ENV_VAR_TMPDIR);\n  const char * plugins              = getenv (ENV_VAR_PLUGIN);\n  const char * plugins_32           = getenv (ENV_VAR_PLUGIN_32);\n\n  //modify the command\n  dmtcp_args.clear();\n  dmtcp_args.push_back(\"--coord-host\");\n  dmtcp_args.push_back(SharedData::coordHost());\n  dmtcp_args.push_back(\"--coord-port\");\n  dmtcp_args.push_back(jalib::XToString(SharedData::coordPort()));\n\n  if (jassert_quiet == 1) {\n    dmtcp_args.push_back(\"-q\");\n  } else if (jassert_quiet == 2) {\n    dmtcp_args.push_back(\"-q -q\");\n  }\n\n  if (sigckpt != NULL) {\n    dmtcp_args.push_back(\"--ckpt-signal\");\n    dmtcp_args.push_back(sigckpt);\n  }\n\n  if (ckptDir != NULL) {\n    dmtcp_args.push_back(\"--ckptdir\");\n    dmtcp_args.push_back(ckptDir);\n  }\n\n  if (tmpDir != NULL) {\n    dmtcp_args.push_back(\"--tmpdir\");\n    dmtcp_args.push_back(tmpDir);\n  }\n\n  if (ckptOpenFiles != NULL) {\n    dmtcp_args.push_back(\"--checkpoint-open-files\");\n  }\n\n  if (plugins != NULL) {\n    dmtcp_args.push_back(\"--with-plugin\");\n    dmtcp_args.push_back(plugins);\n  }\n\n  if (plugins_32 != NULL) {\n    dmtcp_args.push_back(\"--with-plugin-32\");\n    dmtcp_args.push_back(plugins_32);\n  }\n\n  if (compression != NULL) {\n    if (strcmp (compression, \"1\") == 0)\n      dmtcp_args.push_back(\"--no-gzip\");\n    else\n      dmtcp_args.push_back(\"--gzip\");\n  }\n\n  if (allocPlugin != NULL && strcmp(allocPlugin, \"0\") == 0) {\n    dmtcp_args.push_back(\"--disable-alloc-plugin\");\n  }\n\n  if (dlPlugin != NULL && strcmp(dlPlugin, \"0\") == 0) {\n    dmtcp_args.push_back(\"--disable-dl-plugin\");\n  }\n\n  if (dmtcp_ptrace_enabled != NULL && dmtcp_ptrace_enabled()) {\n    dmtcp_args.push_back(\"--ptrace\");\n  }\n\n  if (dmtcp_modify_env_enabled != NULL && dmtcp_modify_env_enabled()) {\n    dmtcp_args.push_back(\"--modify-env\");\n  }\n\n  if (dmtcp_infiniband_enabled != NULL && dmtcp_infiniband_enabled()) {\n    dmtcp_args.push_back(\"--infiniband\");\n  }\n\n  if (dmtcp_batch_queue_enabled != NULL && dmtcp_batch_queue_enabled()) {\n    dmtcp_args.push_back(\"--batch-queue\");\n  }\n\n  if (dmtcp_pathvirt_enabled != NULL && dmtcp_pathvirt_enabled()) {\n    dmtcp_args.push_back(\"--pathvirt\");\n  }\n\n#ifdef HBICT_DELTACOMP\n  if (deltacompression != NULL) {\n    if (strcmp(deltacompression, \"0\") == 0)\n      dmtcp_args.push_back(\"--no-hbict\");\n    else\n      dmtcp_args.push_back(\"--hbict\");\n  }\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/src/plugin/ipc/file/filewrappers.h": "/****************************************************************************\n *   Copyright (C) 2006-2010 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *   This file is part of the dmtcp/src module of DMTCP (DMTCP:dmtcp/src).  *\n *                                                                          *\n *  DMTCP:dmtcp/src is free software: you can redistribute it and/or        *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP:dmtcp/src is distributed in the hope that it will be useful,      *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#pragma once\n#ifndef FILE_WRAPPERS_H\n#define FILE_WRAPPERS_H\n\n#include \"dmtcp.h\"\n\n#define _real_open NEXT_FNC(open)\n#define _real_open64 NEXT_FNC(open64)\n#define _real_fopen NEXT_FNC(fopen)\n#define _real_fopen64 NEXT_FNC(fopen64)\n#define _real_freopen NEXT_FNC(freopen)\n#define _real_openat NEXT_FNC(openat)\n#define _real_openat64 NEXT_FNC(openat64)\n#define _real_opendir NEXT_FNC(opendir)\n#define _real_tmpfile NEXT_FNC(tmpfile)\n#define _real_mkstemp NEXT_FNC(mkstemp)\n#define _real_mkostemp NEXT_FNC(mkostemp)\n#define _real_mkstemps NEXT_FNC(mkstemps)\n#define _real_mkostemps NEXT_FNC(mkostemps)\n#define _real_close NEXT_FNC(close)\n#define _real_fclose NEXT_FNC(fclose)\n#define _real_closedir NEXT_FNC(closedir)\n#define _real_lseek NEXT_FNC(lseek)\n#define _real_dup NEXT_FNC(dup)\n#define _real_dup2 NEXT_FNC(dup2)\n#define _real_dup3 NEXT_FNC(dup3)\n#define _real_xstat NEXT_FNC(__xstat)\n#define _real_xstat64 NEXT_FNC(__xstat64)\n#define _real_lxstat NEXT_FNC(__lxstat)\n#define _real_lxstat64 NEXT_FNC(__lxstat64)\n#define _real_readlink NEXT_FNC(readlink)\n#define _real_exit NEXT_FNC(exit)\n#define _real_syscall NEXT_FNC(syscall)\n#define _real_unsetenv NEXT_FNC(unsetenv)\n#define _real_ptsname_r NEXT_FNC(ptsname_r)\n#define _real_ttyname_r NEXT_FNC(ttyname_r)\n#define _real_getpt NEXT_FNC(getpt)\n#define _real_posix_openpt NEXT_FNC(posix_openpt)\n#define _real_openlog NEXT_FNC(openlog)\n#define _real_closelog NEXT_FNC(closelog)\n#define _real_mq_open NEXT_FNC(mq_open)\n#define _real_mq_close NEXT_FNC(mq_close)\n#define _real_mq_send NEXT_FNC(mq_send)\n#define _real_mq_receive NEXT_FNC(mq_receive)\n#define _real_mq_timedsend NEXT_FNC(mq_timedsend)\n#define _real_mq_timedreceive NEXT_FNC(mq_timedreceive)\n#define _real_mq_notify NEXT_FNC(mq_notify)\n#define _real_fcntl NEXT_FNC(fcntl)\n\n#define _real_system NEXT_FNC(system)\n#define _real_mmap NEXT_FNC(mmap)\n#define _real_munmap NEXT_FNC(munmap)\n#define _real_access NEXT_FNC(access)\n#define _real_access NEXT_FNC(access)\n// NOTE:  realpath is a versioned symbol, and we should be using\n//   NEXT_FNC_DEFAULT.  But that interferes with libdl.so (e.g., dlopen).\n//   and other functions that use gettid() -> __tls_get_addr()\n//   for some unknown reason.\n#define _real_realpath NEXT_FNC(realpath)\n\n#endif // FILE_WRAPPERS_H\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/src/plugin/dl/dlwrappers.cpp": "/****************************************************************************\n *   Copyright (C) 2006-2013 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *   This file is part of the dmtcp/src module of DMTCP (DMTCP:dmtcp/src).  *\n *                                                                          *\n *  DMTCP:dmtcp/src is free software: you can redistribute it and/or        *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP:dmtcp/src is distributed in the hope that it will be useful,      *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#include <stdlib.h>\n#include <unistd.h>\n#include \"dmtcp.h\"\n#include \"../jalib/jassert.h\"\n\n#define _real_dlopen  NEXT_FNC(dlopen)\n#define _real_dlclose NEXT_FNC(dlclose)\n\nextern \"C\" int dmtcp_libdlLockLock();\nextern \"C\" void dmtcp_libdlLockUnlock();\n\n/* Reason for using thread_performing_dlopen_dlsym:\n *\n * dlsym/dlopen/dlclose make a call to calloc() internally. We do not want to\n * checkpoint while we are in the midst of dlopen etc. as it can lead to\n * undesired behavior. To do so, we use WRAPPER_EXECUTION_DISABLE_CKPT() at the\n * beginning of the funtion. However, if a checkpoint request is received right\n * after WRAPPER_EXECUTION_DISABLE_CKPT(), the ckpt-thread is queued for wrlock\n * on the pthread-rwlock and any subsequent request for rdlock by other threads\n * will have to wait until the ckpt-thread releases the lock. However, in this\n * scenario, dlopen calls calloc, which then calls\n * WRAPPER_EXECUTION_DISABLE_CKPT() and hence resulting in a deadlock.\n *\n * We set this variable to true, once we are inside the dlopen/dlsym/dlerror\n * wrapper, so that the calling thread won't try to acquire the lock later on.\n *\n * EDIT: Instead of acquiring wrapperExecutionLock, we acquire libdlLock.\n * libdlLock is a higher priority lock than wrapperExectionLock i.e. during\n * checkpointing this lock is acquired before wrapperExecutionLock by the\n * ckpt-thread.\n * Rationale behind not using wrapperExecutionLock and creating an extra lock:\n *   When loading a shared library, dlopen will initialize the static objects\n *   in the shared library by calling their corresponding constructors.\n *   Further, the constructor might call fork/exec to create new\n *   process/program. Finally, fork/exec require the wrapperExecutionLock in\n *   exclusive mode (writer lock). However, if dlopen wrapper acquires the\n *   wrapperExecutionLock, the fork wrapper will deadlock when trying to get\n *   writer lock.\n *\n * EDIT: The dlopen() wrappers causes the problems with the semantics of RPATH\n * associated with the caller library. In future, we can work without this\n * plugin by detecting if we are in the middle of a dlopen by looking up the\n * stack frames.\n */\n\nextern \"C\"\nvoid *dlopen(const char *filename, int flag)\n{\n  bool lockAcquired = dmtcp_libdlLockLock();\n  void *ret = _real_dlopen(filename, flag);\n  if (lockAcquired) {\n    dmtcp_libdlLockUnlock();\n  }\n  JWARNING(ret) (filename) (flag)\n    .Text(\"dlopen failed.  You may also see a message 'ERROR: ld.so:'\\n\"\n    \"from libdl.so.  If this happens only under DMTCP, then consider setting\\n\"\n    \"the environment variable DMTCP_DL_PLUGIN to \\\"0\\\" before 'dmtcp_launch'.\\n\"\n    \"If the problem persists, please write to the DMTCP developers.\\n\");\n  return ret;\n}\n\nextern \"C\"\nint dlclose(void *handle)\n{\n  bool lockAcquired = dmtcp_libdlLockLock();\n  int ret = _real_dlclose(handle);\n  if (lockAcquired) {\n    dmtcp_libdlLockUnlock();\n  }\n  return ret;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/include/trampolines.h": "/****************************************************************************\n *   Copyright (C) 2006-2010 by Tyler Denniston and Kapil Arya              *\n *   tyler@ccs.neu.edu and kapil@ccs.neu.edu                                *\n *                                                                          *\n *   This file is part of the dmtcp/src module of DMTCP (DMTCP:dmtcp/src).  *\n *                                                                          *\n *  DMTCP is free software: you can redistribute it and/or        *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP is distributed in the hope that it will be useful,      *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#ifndef TRAMPOLINES_H\n#define TRAMPOLINES_H\n\n#include <string.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include \"constants.h\"\n\n#ifdef __x86_64__\nstatic unsigned char asm_jump[] = {\n    // mov    $0x1234567812345678,%rax\n    0x48, 0xb8, 0x78, 0x56, 0x34, 0x12, 0x78, 0x56, 0x34, 0x12,\n    // jmpq   *%rax\n    0xff, 0xe0\n};\n// Beginning of address in asm_jump:\n# define ADDR_OFFSET 2\n#else\nstatic unsigned char asm_jump[] = {\n    0xb8, 0x78, 0x56, 0x34, 0x12, // mov    $0x12345678,%eax\n    0xff, 0xe0                    // jmp    *%eax\n};\n// Beginning of address in asm_jump:\n# define ADDR_OFFSET 1\n#endif\n\n#define ASM_JUMP_LEN sizeof(asm_jump)\n\ntypedef struct trampoline_info {\n  void *addr;\n  char jump[ASM_JUMP_LEN];\n  char displaced_instructions[ASM_JUMP_LEN];\n} trampoline_info_t;\n\n\n#define INSTALL_TRAMPOLINE(info) \\\n  memcpy((info).addr, (info).jump, ASM_JUMP_LEN)\n\n#define UNINSTALL_TRAMPOLINE(info) \\\n  memcpy((info).addr, (info).displaced_instructions, ASM_JUMP_LEN)\n\nstatic void dmtcp_setup_trampoline(const char *func_name, void *trampoline_fn,\n                                   trampoline_info_t *info);\n\nstatic void dmtcp_setup_trampoline_by_addr(void *addr, void *trampoline_fn,\n                                           trampoline_info_t *info)\n{\n  unsigned long pagesize = sysconf(_SC_PAGESIZE);\n  unsigned long pagemask = ~(pagesize - 1);\n  void *page_base;\n  info->addr = addr;\n  /* Base address of page where func resides. */\n  page_base = (void*) ((unsigned long)info->addr & pagemask);\n  /* Give that whole page RWX permissions. */\n  int retval = mprotect(page_base, pagesize,\n                        PROT_READ | PROT_WRITE | PROT_EXEC);\n  if (retval == -1) {\n    fprintf(stderr, \"*** %s:%d DMTCP Internal Error: mprotect() failed.\\n\",\n            __FILE__, __LINE__);\n    abort();\n  }\n  /************ Set up trampoline injection code. ***********/\n  /* Trick to get \"free\" conversion of a long value to the\n     character-array representation of that value. Different sizes of\n     long and endian-ness are handled automatically. */\n  union u {\n    void *val;\n    char bytes[sizeof(void*)];\n  } data;\n\n  data.val = trampoline_fn;\n  memcpy(info->jump, asm_jump, ASM_JUMP_LEN);\n  /* Insert real trampoline address into injection code. */\n  memcpy(info->jump + ADDR_OFFSET, data.bytes, sizeof(data.bytes));\n  /* Save displaced instructions for later restoration. */\n  memcpy(info->displaced_instructions, info->addr, ASM_JUMP_LEN);\n  /* Inject trampoline. */\n  INSTALL_TRAMPOLINE(*info);\n\n  (void)dmtcp_setup_trampoline; // Suppress unused function warning.\n}\n\nstatic void dmtcp_setup_trampoline(const char *func_name, void *trampoline_fn,\n                                   trampoline_info_t *info)\n{\n  /* Find libc func\n     We assume that no one is wrapping func yet. */\n  void *handle = dlopen(LIBC_FILENAME, RTLD_NOW);\n  if (handle == NULL) {\n    fprintf(stderr, \"*** %s:%d DMTCP Internal Error: dlopen() failed.\\n\",\n            __FILE__, __LINE__);\n    abort();\n  }\n  void *addr = dlsym(handle, func_name);\n  if (addr == NULL) {\n    fprintf(stderr, \"*** %s:%d DMTCP Internal Error: dlsym() failed.\\n\",\n            __FILE__, __LINE__);\n    abort();\n  }\n  dlclose(handle);\n  dmtcp_setup_trampoline_by_addr(addr, trampoline_fn, info);\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/plugin/batch-queue/rm_torque.cpp": "/****************************************************************************\n *  Copyright (C) 2012-2014 by Artem Y. Polyakov <artpol84@gmail.com>       *\n *                                                                          *\n *  This file is part of the RM plugin for DMTCP                            *\n *                                                                          *\n *  RM plugin is free software: you can redistribute it and/or              *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  RM plugin is distributed in the hope that it will be useful,            *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n/* Update by Kapil Arya to create the Torque DMTCP plugin. */\n\n/* The Torque PBS resource manager supporting code.\n\n   Torque PBS contains the libtorque library, which provides an API for\n   communication with the MOM Node management servers.  The library obtains\n   information about the allocated resources and uses it.  In particular the\n   spawn programs on the remote nodes use tm_spawn.\n\n   To keep track of and control all processes spawned using any method (such as\n   exec, ssh), we also need to wrap the tm_spawn function.\n*/\n\n\n#include <stdlib.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <pthread.h>\n#include <vector>\n#include <list>\n#include <string>\n#include \"util.h\"\n#include \"procmapsarea.h\"\n#include \"jalib.h\"\n#include \"jassert.h\"\n#include \"jconvert.h\"\n#include \"jfilesystem.h\"\n#include \"rm_main.h\"\n#include \"rm_utils.h\"\n#include \"rm_torque.h\"\n\n// -------------------- Torque PBS tm.h definitions -------------------------//\n// Keep in sync with \"tm.h\" file in the libtorque library of the Torque PBS\n//   resource manager.\n#define TM_SUCCESS  0\n#define TM_ESYSTEM  17000\n#define TM_ENOEVENT  17001\n#define TM_ENOTCONNECTED 17002\n#define TM_EUNKNOWNCMD  17003\n#define TM_ENOTIMPLEMENTED 17004\n#define TM_EBADENVIRONMENT 17005\n#define TM_ENOTFOUND  17006\n#define TM_BADINIT  17007\n\nusing namespace dmtcp;\n\ntypedef int tm_node_id;\ntypedef int tm_task_id;\ntypedef int  tm_event_t;\n\nstatic pthread_mutex_t _libtorque_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic void *_libtorque_handle = NULL;\ntypedef int (*tm_spawn_t)(int argc, char **argv, char **envp, tm_node_id where, tm_task_id *tid, tm_event_t *event);\ntm_spawn_t tm_spawn_ptr;\n\nstatic void setup_job();\nstatic string torque_home_nodefile(char *ptr);\nstatic void setup_torque_env();\n\nstatic string &torque_home(){\n  static string inst = \"\"; return inst;\n}\n\nstatic string &torque_jobname(){\n  static string inst = \"\"; return inst;\n}\nunsigned long torque_jobid = 0;\n\n//--------------------- Torque/PBS initialization  -------------//\n\nvoid dmtcp::probeTorque()\n{\n  JTRACE(\"Start\");\n  if( (getenv(\"PBS_ENVIRONMENT\") != NULL) && (NULL != getenv(\"PBS_JOBID\")) ){\n    JTRACE(\"We run under Torque PBS!\");\n    // TODO: Do we need locking here?\n    //JASSERT(_real_pthread_mutex_lock(&global_mutex) == 0);\n    _set_rmgr_type(torque);\n    // Set up the Torque PBS home dir.\n    setup_torque_env();\n    setup_job();\n    // TODO: Do we need locking here?\n    //JASSERT(_real_pthread_mutex_unlock(&global_mutex) == 0);\n  }\n}\n\nstatic int queryPbsConfig(string option, string &pbs_config)\n{\n  int fds[2];\n  const char *pbs_config_path = \"pbs-config\";\n  static const char *pbs_config_args[] = { \"pbs-config\", option.c_str(), NULL };\n  int cpid;\n\n  if( pipe(fds) == -1){\n    // Just go away - we cannot serve this request.\n    JTRACE(\"Cannot create pipe to execute pbs-config to find Torque/PBS library!\");\n    return -1;\n  }\n\n  cpid = _real_fork();\n\n  if( cpid < 0 ){\n    JTRACE( \"ERROR: cannot execute pbs-config. Will not run tm_spawn!\");\n    return -1;\n  }\n  if( cpid == 0 ){\n    JTRACE ( \"child process, will exec into external de-compressor\");\n    fds[1] = _real_dup(_real_dup(_real_dup(fds[1])));\n    close(fds[0]);\n    JASSERT(_real_dup2(fds[1], STDOUT_FILENO) == STDOUT_FILENO);\n    close(fds[1]);\n    _real_execvp(pbs_config_path, (char **)pbs_config_args);\n    /* should not get here */\n    JASSERT(false)(\"ERROR: Failed to exec pbs-config. tm_spawn will fail with TM_BADINIT\")(strerror(errno));\n    exit(0);\n  }\n\n  /* parent process */\n  JTRACE ( \"created child process for pbs-config\")(cpid);\n  int status;\n  if( waitpid(cpid,&status,0) < 0 ){\n    return -1;\n  }\n  if( !( WIFEXITED(status) && WEXITSTATUS(status) == 0 ) ){\n    return -1;\n  }\n\n  // set descriptor as non-blocking\n  // JTRACE ( \"Set pipe fds[0] as non-blocking\");\n  int flags = fcntl(fds[0], F_GETFL);\n  fcntl(fds[0], F_SETFL, flags | O_NONBLOCK);\n\n  //JTRACE ( \"Read pbs-config output from pipe\");\n  pbs_config = \"\";\n  char buf[256];\n  int count = 0;\n  while( (count = read(fds[0], buf, 255)) > 0 ){\n    buf[count] = '\\0';\n    pbs_config += string() + buf;\n  }\n\n  JTRACE ( \"pbs-config output:\")(pbs_config);\n  return 0;\n}\n\nint findLibTorque_pbsconfig(string &libpath)\n{\n  // Config looks like: \"-L<libpath> -l<libname> -Wl,--rpath -Wl,<libpath>\"\n  // We will search for the first libpath and the first libname.\n  string libname, config;\n\n  if( queryPbsConfig(\"--libs\",config) ){\n    // failed to read pbs-config\n    return -1;\n  }\n\n  bool name_found = false, path_found = false;\n  vector<string> params;\n  string delim = \" \\n\\t\";\n  params.clear();\n  libpath = \" \";\n  libname = \" \";\n\n  size_t first = config.find_first_not_of(delim);\n  while( first != string::npos ){\n    size_t last = config.find_first_of(delim,first);\n    if( last != string::npos ){\n      string s(config,first,last-first);\n      params.push_back(s);\n      first = config.find_first_not_of(delim,last);\n    }else{\n      first = string::npos;\n    }\n  }\n\n  // get -L & -l arguments\n  for (size_t i = 0; i < params.size(); i++) {\n    string &s = params[i];\n    if (s[0] == '-') {\n      if (s[1] == 'L') {\n        string tmp(s,2,s.size() - 2);\n        libpath = tmp;\n        path_found = true;\n      } else if (s[1] == 'l') {\n        string tmp(s,2,s.size() - 2);\n        libname = tmp;\n        name_found = true;\n      }\n    }\n  }\n\n  if( name_found && path_found ){\n      // construct full torque library path\n    libpath += \"/lib\" + libname + \".so\";\n    JTRACE(\"Torque PBS libpath\")(libpath);\n    return 0;\n  } else {\n    return -1;\n  }\n}\n\nint findLibTorque(string &libpath)\n{\n  bool found = false;\n  string pattern = \"libtorque\";\n  if( !findLib_byname(pattern, libpath) ){\n    found = true;\n  }else if( !findLibTorque_pbsconfig(libpath) ){\n    found = true;\n  }\n\n  JTRACE(\"Torque PBS libpath\")(libpath);\n  return !found;\n}\n\n// -------------- This functions probably should run with global_mutex locked! -----------------------//\n\nstatic void setup_job()\n{\n  char *ptr;\n  if ((ptr = getenv(\"PBS_JOBID\"))){\n    string str = ptr, digits = \"0123456789\";\n    size_t pos = str.find_first_not_of(digits);\n    char *eptr;\n    str = str.substr(0,pos);\n    torque_jobid = strtoul(str.c_str(),&eptr,10);\n  }\n\n  if ((ptr = getenv(\"PBS_JOBNAME\"))) {\n    torque_jobname() = ptr;\n  }\n  JTRACE(\"Result:\")(torque_jobid)(torque_jobname());\n}\n\n\nstatic string torque_home_nodefile(char *ptr)\n{\n  // Usual nodefile path is: $PBS_HOME/aux/nodefile-name\n  string nodefile = ptr;\n  // clear nodefile path from duplicated slashes\n  _rm_clear_path(nodefile);\n\n  // start of file name entry\n  size_t file_start = nodefile.find_last_of(\"/\\\\\");\n  if( file_start == string::npos || file_start == 0 ){\n    JTRACE(\"No slashes in the nodefile path\");\n    return \"\";\n  }\n  // start of aux entry\n  size_t aux_start = nodefile.find_last_of(\"/\\\\\", file_start-1);\n  if( aux_start == string::npos || aux_start == 0 ){\n    JTRACE(\"Only one slash exist in nodefile path\");\n    return \"\";\n  }\n\n  string aux_name = nodefile.substr(aux_start+1, file_start - (aux_start+1));\n\n  JTRACE(\"Looks like we can grap PBS_HOME from PBS_NODEFILE\")(nodefile)(file_start)(aux_start)(aux_name);\n\n  // Last check: if lowest file directory is \"aux\"\n  if( aux_name != \"aux\" ){\n    JTRACE(\"Wrong aux name\");\n    return \"\";\n  }\n\n  return nodefile.substr(0,aux_start);\n}\n\nstatic void setup_torque_env()\n{\n  char *ptr;\n  if ((ptr = getenv(\"PBS_HOME\"))) {\n    torque_home() = ptr;\n  }else if ((ptr = getenv(\"PBS_SERVER_HOME\"))) {\n    torque_home() = ptr;\n  } else if ((ptr = getenv(\"PBS_NODEFILE\"))) {\n      torque_home() = torque_home_nodefile(ptr);\n  }\n\n  if( torque_home().size() ){\n    _rm_clear_path(torque_home());\n    _rm_del_trailing_slash(torque_home());\n  }\n}\n\n// -------------- (END) This functions probably should run with global_mutex locked! (END) -----------------------//\n\n\nbool dmtcp::isTorqueFile(string relpath, string &path)\n{\n  JTRACE(\"Start\");\n  switch( _get_rmgr_type() ){\n  case Empty:\n    probeTorque();\n    if( _get_rmgr_type() != torque )\n      return false;\n    break;\n  case torque:\n    break;\n  default:\n    return false;\n  }\n\n  if( torque_home().size() == 0 )\n    return false;\n\n  string abspath = torque_home() + \"/\" + relpath;\n  JTRACE(\"Compare path with\")(path)(abspath);\n  if( path.size() < abspath.size() )\n    return false;\n\n  if( path.substr(0,abspath.size()) == abspath )\n    return true;\n\n  return false;\n}\n\nbool dmtcp::isTorqueHomeFile(string &path)\n{\n  // Check if the file is in the home directory.\n  char *ptr;\n  string hpath = \"\";\n\n  if ((ptr = getenv(\"HOME\"))) {\n    hpath = string() + ptr;\n    JTRACE(\"Home directory:\")(hpath)(path);\n  }else{\n    JTRACE(\"Cannot determine user HOME directory!\");\n    return false;\n  }\n\n  if( hpath.size() >= path.size() ){\n    JTRACE(\"Length of path is less than home dir\");\n    return false;\n  }\n\n  if( path.substr(0,hpath.size()) != hpath ){\n    JTRACE(\"prefix of path is not home directory\")(path)(hpath);\n    return false;\n  }\n\n  string suffix1 = \".OU\", suffix2 = \".ER\";\n\n  if( !( (path.substr(path.size() - suffix1.size()) == suffix1) ||\n        (path.substr(path.size() - suffix2.size()) == suffix2) ) ){\n    JTRACE(\"path has no .OU or .ER suffix\")(path);\n    return false;\n  }\n\n  char jobid[256];\n  sprintf(jobid,\"%lu\",torque_jobid);\n  string spool_path = hpath + \"/.pbs_spool/\" + jobid;\n  string home_path = hpath + jobid;\n\n  if( path.substr(0,spool_path.size()) == spool_path ){\n    JTRACE(\"File is located in $HOME/.pbs_spool/. It is Torque/PBS stdio file\")(path);\n    return true;\n  }\n\n  if( path.substr(0,home_path.size()) == home_path ){\n    JTRACE(\"File is located in $HOME/. It is Torque/PBS stdio file\")(path);\n    return true;\n  }\n\n  return false;\n}\n\nbool dmtcp::isTorqueIOFile(string &path)\n{\n  // Check if the file is located in $PBS_HOME/spool\n  // If so, it is the Torque stdio file.\n  if( isTorqueFile(\"spool\", path) )\n    return true;\n\n  if( isTorqueHomeFile(path) ){\n    // Torque can be configured to write directly into a user's home directory.\n    // In this case, we need to check the file pattern:\n  }\n  return false;\n}\n\nbool dmtcp::isTorqueStdout(string &path)\n{\n  if( !isTorqueIOFile(path) )\n    return false;\n\n  string suffix = \".OU\";\n\n  if( (path.substr(path.size() - suffix.size()) == suffix) ){\n    return true;\n  }\n\n  return false;\n}\n\nbool dmtcp::isTorqueStderr(string &path)\n{\n  if( !isTorqueIOFile(path) )\n    return false;\n\n  string suffix = \".ER\";\n\n  if( (path.substr(path.size() - suffix.size()) == suffix) ){\n    return true;\n  }\n\n  return false;\n}\n\nbool dmtcp::isTorqueNodeFile(string &path)\n{\n  // If this file is not located in the $PBS_HOME/aux/ directory,\n  // it can't be node_file.\n  return isTorqueFile(\"aux\", path);\n}\n\n\n//--------------------- Torque/PBS tm_spawn remote exec wrapper -------------//\n\nstatic int libtorque_init()\n{\n  int ret = 0;\n\n  // lock _libtorque_handle\n  JASSERT(_real_pthread_mutex_lock(&_libtorque_mutex) == 0);\n  if( _libtorque_handle == NULL ){\n    // find library using pbs-config\n    string libpath;\n    if( findLibTorque(libpath) ){\n      ret = -1;\n      goto unlock;\n    }\n    // initialize tm_spawn_ptr\n    JTRACE(\"Initialize libtorque dlopen handler\")(libpath);\n    char *error = NULL;\n    _libtorque_handle = _real_dlopen(libpath.c_str(),RTLD_LAZY);\n    if( !_libtorque_handle ){\n      error = dlerror();\n      if( error )\n        JTRACE(\"Cannot open libtorque.so. Will not wrap tm_spawn\")(error);\n      else\n        JTRACE(\"Cannot open libtorque.so. Will not wrap tm_spawn\");\n      ret = -1;\n      goto unlock;\n    }\n\n    dlerror();\n    tm_spawn_ptr = (tm_spawn_t)_real_dlsym(_libtorque_handle, \"tm_spawn\");\n    if( tm_spawn_ptr == NULL ){\n      error = dlerror();\n      if( error )\n        JTRACE(\"Cannot load tm_spawn from libtorque.so. Will not wrap it!\")(error);\n      else\n        JTRACE(\"Cannot load tm_spawn from libtorque.so. Will not wrap it!\");\n      ret = -1;\n      goto unlock;\n    }\n  }\nunlock:\n  JASSERT(_real_pthread_mutex_unlock(&_libtorque_mutex) == 0);\n  return ret;\n}\n\nextern \"C\" int tm_spawn(int argc, char **argv, char **envp, tm_node_id where,\n                        tm_task_id *tid, tm_event_t *event)\n{\n  int ret;\n  JTRACE(\"In tm_spawn wrapper\");\n  if( libtorque_init() )\n    return TM_BADINIT;\n\n  char dmtcpCkptPath[PATH_MAX] = \"\";\n  string ckptCmdPath = Util::getPath(\"dmtcp_launch\");\n  ret = Util::expandPathname(ckptCmdPath.c_str(),\n                                    dmtcpCkptPath, sizeof(dmtcpCkptPath));\n\n  JTRACE(\"Expand dmtcp_launch path\")(dmtcpCkptPath);\n\n  vector<string> dmtcp_args;\n  Util::getDmtcpArgs(dmtcp_args);\n  unsigned int dsize = dmtcp_args.size();\n  const char *new_argv[ argc + (dsize + 1)]; // (dsize+1) args are for DMTCP, including dmtcpCkptPath.\n  string cmdline;\n  size_t i;\n\n  for(i = 0; i < (unsigned) argc; i++){\n      JTRACE(\"arg[i]:\")(i)(argv[i]);\n  }\n\n  new_argv[0] = dmtcpCkptPath;\n  for (i = 0; i < dsize; i++) {\n    new_argv[1 + i] = dmtcp_args[i].c_str();\n  }\n  for (int j = 0; j < argc; j++) {\n    new_argv[(1 + dsize) + j] = argv[j];\n  }\n  for (i = 0; i< dsize + argc + 1; i++ ) {\n    cmdline +=  string() + new_argv[i] + \" \";\n  }\n\n  JTRACE( \"call Torque PBS tm_spawn API to run command on remote host\" )\n        ( argv[0] ) (where);\n  JTRACE(\"CMD:\")(cmdline);\n  ret = tm_spawn_ptr(argc + dsize + 1,(char **)new_argv,envp,where,tid,event);\n\n  return ret;\n}\n\nint dmtcp::torqueShouldCkptFile(const char *path, int *type)\n{\n  string str(path);\n\n  if (isTorqueIOFile(str)) {\n    *type = TORQUE_IO;\n    return 1;\n  } else if (isTorqueNodeFile(str) || *type == TORQUE_NODE) {\n    *type = TORQUE_NODE;\n    return 1;\n  }\n  return 0;\n}\n\n\nint dmtcp::torqueRestoreFile(const char *path, const char *savedFilePath,\n                                     int fcntlFlags, int type)\n{\n  string newpath;\n\n  int tempfd = -1;\n  if (type == TORQUE_NODE) {\n    JTRACE(\"Restore Torque Node file\");\n    char newpath_tmpl[] = \"/tmp/dmtcp_torque_nodefile.XXXXXX\";\n    if (mkstemp(newpath_tmpl) == -1) {\n      strcpy(newpath_tmpl,\"/tmp/dmtcp_torque_nodefile\");\n    }\n    newpath = newpath_tmpl;\n    tempfd = _real_open(newpath.c_str(), O_CREAT | O_WRONLY,\n            (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP) );\n    JASSERT(tempfd != -1) (path)(newpath)(JASSERT_ERRNO) .Text(\"open() failed\");\n  } else if (type == TORQUE_IO) {\n    string str(path);\n    JTRACE(\"Restore Torque IO file\");\n    if (isTorqueStdout(str)) {\n      JTRACE(\"Restore Torque STDOUT file\");\n      tempfd = 1;\n    } else if (isTorqueStderr(str)) {\n      JTRACE(\"Restore Torque STDERR file\");\n      tempfd = 2;\n    } else{\n      return -1;\n    }\n\n    // get new file name\n    string procpath = \"/proc/self/fd/\" + jalib::XToString(tempfd);\n    newpath = jalib::Filesystem::ResolveSymlink(procpath);\n  }\n\n  JTRACE(\"Copying saved Resource Manager file to NEW location\")\n    (savedFilePath) (newpath);\n\n  string command = \"cat \";\n  command.append(savedFilePath).append(\" > \").append(newpath);\n  JASSERT(_real_system(command.c_str()) != -1);\n\n  // Reopen with initial flags\n  if( type == TORQUE_NODE) {\n    _real_close(tempfd);\n    tempfd = _real_open(newpath.c_str(), fcntlFlags);\n    JASSERT(tempfd != -1) (path)(newpath)(JASSERT_ERRNO) .Text(\"open() failed\");\n  }\n\n  return tempfd;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/plugin/batch-queue/rm_utils.cpp": "/****************************************************************************\n *  Copyright (C) 2012-2014 by Artem Y. Polyakov <artpol84@gmail.com>       *\n *                                                                          *\n *  This file is part of the RM plugin for DMTCP                            *\n *                                                                          *\n *  RM plugin is free software: you can redistribute it and/or              *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  RM plugin is distributed in the hope that it will be useful,            *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#include <stdlib.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <pthread.h>\n#include <vector>\n#include <list>\n#include <string>\n#include \"util.h\"\n#include \"procmapsarea.h\"\n#include \"procselfmaps.h\"\n#include \"jalib.h\"\n#include \"jassert.h\"\n#include \"jconvert.h\"\n#include \"jfilesystem.h\"\n#include \"rm_main.h\"\n#include \"rm_utils.h\"\n\nusing namespace dmtcp;\n\nint dmtcp::findLib_byname(string pattern, string &libpath)\n{\n  // /proc/self/maps looks like: \"<start addr>-<end addr> <mode> <offset> <device> <inode> <libpath>\n  // we need to extract libpath\n  ProcMapsArea area;\n  int ret = -1;\n\n  ProcSelfMaps procSelfMaps;\n  while (procSelfMaps.getNextArea(&area)) {\n    libpath = area.name;\n    //JTRACE(\"Inspect new /proc/seft/maps line\")(libpath);\n    if( libpath.size() == 0 ){\n      //JTRACE(\"anonymous region, skip\");\n      continue;\n    }\n\n    if( libpath.find(pattern) != string::npos ){\n      // This is the library path that contains libtorque.  This is what we need.\n      //JTRACE(\"Found libpath\")(pattern)(libpath);\n      ret = 0;\n      break;\n    }else{\n      //JTRACE(\"Libpath not found\")(pattern)(libpath);\n    }\n  }\n\n  return ret;\n}\n\nint dmtcp::findLib_byfunc(string fname, string &libpath)\n{\n  // /proc/self/maps looks like: \"<start addr>-<end addr> <mode> <offset> <device> <inode> <libpath>\n  // We need to extract libpath.\n  ProcMapsArea area;\n  int ret = -1;\n\n  ProcSelfMaps procSelfMaps;\n  while (procSelfMaps.getNextArea(&area)) {\n    libpath = area.name;\n    //JTRACE(\"Inspect new /proc/seft/maps line\")(libpath);\n    if( libpath.size() == 0 ){\n      //JTRACE(\"anonymous region, skip\");\n      continue;\n    }\n\n    if( libpath.find(\"libdmtcp\") != string::npos ){\n      //JTRACE(\"dmtcp plugin, skip\")(libpath);\n      continue;\n    }\n\n    void *handle = _real_dlopen(libpath.c_str(),RTLD_LAZY);\n    if( handle == NULL ){\n      //JTRACE(\"Cannot open libpath, skip\")(libpath);\n      continue;\n    }\n    void *fptr = _real_dlsym(handle,fname.c_str());\n    if( fptr != NULL ){\n      // Able to find the requested symbol.\n      //JTRACE(\"Found libpath by content:\")(fname)(libpath);\n      dlclose(handle);\n      ret = 0;\n      break;\n    }\n    dlclose(handle);\n    //JTRACE(\"Function not found in Libpath\")(fname)(libpath);\n  }\n\n  return ret;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/plugin/batch-queue/rm_pmi.cpp": "/****************************************************************************\n *  Copyright (C) 2012-2014 by Artem Y. Polyakov <artpol84@gmail.com>       *\n *                                                                          *\n *  This file is part of the RM plugin for DMTCP                            *\n *                                                                          *\n *  RM plugin is free software: you can redistribute it and/or              *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  RM plugin is distributed in the hope that it will be useful,            *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#include <stdlib.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <pthread.h>\n#include <vector>\n#include <list>\n#include <string>\n#include \"util.h\"\n#include \"procmapsarea.h\"\n#include \"jalib.h\"\n#include \"jassert.h\"\n#include \"jconvert.h\"\n#include \"jfilesystem.h\"\n#include \"rm_main.h\"\n#include \"rm_utils.h\"\n#include \"rm_pmi.h\"\n\n#define PMI_SUCCESS                  0\n#define PMI_FAIL                    -1\n#define PMI_ERR_INIT                 1\n#define PMI_ERR_NOMEM                2\n#define PMI_ERR_INVALID_ARG          3\n#define PMI_ERR_INVALID_KEY          4\n#define PMI_ERR_INVALID_KEY_LENGTH   5\n#define PMI_ERR_INVALID_VAL          6\n#define PMI_ERR_INVALID_VAL_LENGTH   7\n#define PMI_ERR_INVALID_LENGTH       8\n#define PMI_ERR_INVALID_NUM_ARGS     9\n#define PMI_ERR_INVALID_ARGS        10\n#define PMI_ERR_INVALID_NUM_PARSED  11\n#define PMI_ERR_INVALID_KEYVALP     12\n#define PMI_ERR_INVALID_SIZE        13\n#define PMI_ERR_INVALID_KVS         14\n\nusing namespace dmtcp;\n\nstatic pthread_mutex_t _lock_lib, _lock_flag;\nstatic void do_lock_lib() {\n  JASSERT(pthread_mutex_lock(&_lock_lib) == 0);\n}\nstatic void do_unlock_lib() {\n  JASSERT(pthread_mutex_unlock(&_lock_lib) == 0);\n}\n\nstatic void do_lock_flag() {\n  JASSERT(pthread_mutex_lock(&_lock_flag) == 0);\n}\nstatic void do_unlock_flag() {\n  JASSERT(pthread_mutex_unlock(&_lock_flag) == 0);\n}\n\nstatic void *handle = NULL;\ntypedef int (*_PMI_Init_t)( int *t );\ntypedef int (*_PMI_Fini_t)(  );\ntypedef int (*_PMI_Barrier_t)(  );\ntypedef int PMI_BOOL;\n#define PMI_TRUE     1\n#define PMI_FALSE    0\ntypedef int (*_PMI_Initialized_t)( PMI_BOOL * );\nstatic _PMI_Init_t _real_PMI_Init = NULL;\nstatic _PMI_Fini_t _real_PMI_Fini = NULL;\nstatic _PMI_Barrier_t _real_PMI_Barrier = NULL;\nstatic _PMI_Initialized_t _real_PMI_Initialized = NULL;\n\nstatic bool pmi_is_used = false;\nstatic bool explicit_srun = false;\n\nstatic bool want_pmi_shutdown()\n{\n    return pmi_is_used && (_get_rmgr_type() == slurm && !explicit_srun );\n}\n\nvoid rm_init_pmi(){\n\n    do_lock_lib();\n    if( !handle ){\n      string pattern = \"libpmi\";\n      string libpath;\n      if( findLib_byname(pattern,libpath) != 0 ){\n        JASSERT( findLib_byfunc(\"PMI_Init\",libpath) == 0);\n      }\n      JTRACE(\"\")(libpath);\n      handle = _real_dlopen(libpath.c_str(),RTLD_LAZY);\n      JASSERT( handle != NULL );\n      _real_PMI_Init = (_PMI_Init_t)_real_dlsym(handle,\"PMI_Init\");\n      JASSERT( _real_PMI_Init != NULL );\n      _real_PMI_Fini = (_PMI_Fini_t)_real_dlsym(handle,\"PMI_Finalize\");\n      JASSERT( _real_PMI_Fini != NULL );\n      _real_PMI_Barrier = (_PMI_Barrier_t)_real_dlsym(handle,\"PMI_Barrier\");\n      JASSERT( _real_PMI_Barrier != NULL );\n      _real_PMI_Initialized = (_PMI_Initialized_t)_real_dlsym(handle,\"PMI_Initialized\");\n      if( _real_PMI_Initialized == NULL ){\n        // eventually smpd of MPICH2 and Intel-MPI uses iPMI_Initialized function\n        _real_PMI_Initialized = (_PMI_Initialized_t)_real_dlsym(handle,\"iPMI_Initialized\");\n      }\n      JASSERT( _real_PMI_Initialized != NULL );\n      if (getenv( ENV_VAR_EXPLICIT_SRUN ) != NULL) {\n        explicit_srun = true;\n      }\n    }\n    do_unlock_lib();\n    JTRACE(\"\")(handle);\n}\n\nextern \"C\" int PMI_Init( int *spawned )\n{\n    if( !_real_PMI_Init ){\n      rm_init_pmi();\n    }\n\n    if( ! pmi_is_used ){\n      do_lock_flag();\n      pmi_is_used = true;\n      do_unlock_flag();\n    }\n    int ret = _real_PMI_Init(spawned);\n    JTRACE(\"\")(_real_PMI_Init)(ret);\n    return ret;\n}\n\n// Intel MPI uses dlopen() and dlsym() to find pmi functions.\n// We need to redirect PMI_Init() to our wrapper, so that\n// pmi is correctly initialized.\nextern \"C\" void *dlsym(void *handle, const char *symbol)\n{\n  if (symbol && strcmp(symbol, \"PMI_Init\") == 0) {\n    return (void *)PMI_Init;\n  }\n  return _real_dlsym(handle, symbol);\n}\n\nint rm_shutdown_pmi()\n{\n  int ret = 0;\n\n  JTRACE(\"Start, internal pmi capable\");\n  if( want_pmi_shutdown() ){\n    JTRACE(\"Perform shutdown\");\n\n    PMI_BOOL en;\n    if( !_real_PMI_Fini || ! _real_PMI_Initialized ){\n      rm_init_pmi();\n    }\n    JASSERT( _real_PMI_Initialized(&en) == PMI_SUCCESS );\n    if( en == PMI_TRUE ){\n      JASSERT( _real_PMI_Fini() == PMI_SUCCESS );\n    }\n    JTRACE(\"Shutdown PMI connection before checkpoint:\")(ret);\n  }\n  return ret;\n}\n\n\nint rm_restore_pmi()\n{\n  int ret = 0;\n\n  JTRACE(\"Start, internal pmi capable\");\n  if( want_pmi_shutdown()  ){\n    JTRACE(\"Perform restore\");\n    if( !_real_PMI_Init || ! _real_PMI_Initialized ){\n      rm_init_pmi();\n    }\n    PMI_BOOL en;\n    int spawned;\n    JASSERT( _real_PMI_Initialized(&en) == PMI_SUCCESS );\n    if( en == PMI_FALSE ){\n      JASSERT( _real_PMI_Init(&spawned) == PMI_SUCCESS );\n    }\n    JTRACE(\"Restore PMI connection:\")(ret);\n    JASSERT( _real_PMI_Barrier() == PMI_SUCCESS );\n    JTRACE(\"After PMI_Barrier()\")(ret);\n  }\n  return ret;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/plugin/batch-queue/rm_main.h": "/****************************************************************************\n *  Copyright (C) 2012-2014 by Artem Y. Polyakov <artpol84@gmail.com>       *\n *                                                                          *\n *  This file is part of the RM plugin for DMTCP                            *\n *                                                                          *\n *  RM plugin is free software: you can redistribute it and/or              *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  RM plugin is distributed in the hope that it will be useful,            *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#ifndef RESOURCE_MANAGER_H\n#define RESOURCE_MANAGER_H\n\n#include \"dmtcpalloc.h\"\n#include \"dmtcp.h\"\n\n#define _real_fork NEXT_FNC(fork)\n#define _real_execve NEXT_FNC(execve)\n#define _real_execvp NEXT_FNC(execvp)\n#define _real_execvpe NEXT_FNC(execvpe)\n#define _real_open NEXT_FNC(open)\n#define _real_close NEXT_FNC(close)\n#define _real_dup NEXT_FNC(dup)\n#define _real_dup2 NEXT_FNC(dup2)\n#define _real_fcntl NEXT_FNC(fcntl)\n#define _real_pthread_mutex_lock NEXT_FNC(pthread_mutex_lock)\n#define _real_pthread_mutex_unlock NEXT_FNC(pthread_mutex_unlock)\n#define _real_dlopen NEXT_FNC(dlopen)\n#define _real_dlsym NEXT_FNC(dlsym)\n#define _real_system NEXT_FNC(system)\n\n#define _real_socket NEXT_FNC(socket)\n#define _real_connect NEXT_FNC(connect)\n#define _real_bind NEXT_FNC(bind)\n\nnamespace dmtcp {\n\n// General\nbool runUnderRMgr();\nenum rmgr_type_t { Empty, None, torque, sge, lsf, slurm };\n\nrmgr_type_t _get_rmgr_type();\nvoid _set_rmgr_type(rmgr_type_t nval);\n\nvoid _rm_clear_path(string &path);\nvoid _rm_del_trailing_slash(string &path);\n\nenum ResMgrFileType\n{\n  TORQUE_IO,\n  TORQUE_NODE,\n  SLURM_TMPDIR\n};\n}\n\n#define FWD_TO_DEV_NULL(fd) \\\n{ \\\n  int tmp = open(\"/dev/null\", O_CREAT|O_RDWR|O_TRUNC, 0666); \\\n  if (tmp >= 0 && tmp != fd ) { \\\n  dup2(tmp, fd); \\\n  close(tmp); \\\n  } \\\n}\n\n#define CHECK_FWD_TO_DEV_NULL(fd) \\\n{ \\\n  if( fcntl(fd,F_GETFL) == -1 ){ \\\n    FWD_TO_DEV_NULL(fd) \\\n  } \\\n}\n\n#define DMTCP_SRUN_HELPER_ADDR_ENV \"DMTCP_SRUN_HELPER_ADDR\"\n#define DMTCP_SRUN_HELPER_SYNC_ENV \"DMTCP_SRUN_HELPER_SYNCFILE\"\n\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/plugin/batch-queue/pmi-drafts/hijack.cpp": "#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"pmi_hijack_log.h\"\n#include <fstream>\n\nstatic void *handle = NULL;\nstatic pmi_hijack_log *log;\nstatic int count = 0;\n\nchar fprefix[256] = \"pmidb\";\n\nvoid init_handle(){\n    if( !handle )\n\thandle = dlopen(\"/user/artempol/OpenMPI/pmi_support/lib/libpmi.so\",RTLD_NOW);\n    printf(\"handle=%p\\n\",handle);\n    if( !log )\n        log = new pmi_hijack_log;\n}\n\nint init_fprefix()\n{\n    char *jid = getenv(\"SLURM_JOBID\");\n    char *nid = getenv(\"SLURM_NODEID\");\n    char *lid = getenv(\"SLURM_LOCALID\");\n    sprintf(fprefix,\"%s.%s.%s.%s\",fprefix,jid,nid,lid);\n}\n\n__attribute__((constructor)) void initLib(void) {\n    char *p = getenv(\"LD_PRELOAD\");\n    printf(\"library loaded. LD_PRELOAD=%s\\n\",p);\n    init_fprefix();\n}\n\n\nextern \"C\"{\n\nint PMI_Init( int *length )\n{\n    typedef int (*_PMI_Init_t)( int *t );\n    static _PMI_Init_t _real = NULL;\n    if( !_real ){\n\tinit_handle();\n      _real = (_PMI_Init_t)dlsym(handle,\"PMI_Init\");\n    }\n    int ret = _real(length);\n    printf(\"MYPMI_Init: %p. ret = %d\\n\",_real,ret);\n    return ret;\n}\n\nint PMI_Initialized( int *length )\n{\n    typedef int (*_PMI_Initialized_t)( int *t );\n    static _PMI_Initialized_t _real = NULL;\n    if( !_real ){\n      init_handle();\n      _real = (_PMI_Initialized_t)dlsym(handle,\"PMI_Initialized\");\n    }\n    int ret = _real(length);\n    return ret;\n}\n\nint PMI_Finalize( void )\n{\n    typedef int (*_PMI_Finalize_t)( );\n    static _PMI_Finalize_t _real = NULL;\n    typedef int (*_PMI_KVS_Get_name_length_max_t)( int *t );\n    static _PMI_KVS_Get_name_length_max_t _kvsname_max = NULL;\n    typedef int (*_PMI_KVS_Get_key_length_max_t)( int *t );\n    static _PMI_KVS_Get_key_length_max_t _key_max = NULL;\n    typedef int (*_PMI_KVS_Get_value_length_max_t)( int *t );\n    static _PMI_KVS_Get_value_length_max_t _val_max = NULL;\n\n    if( !_real ){\n\tinit_handle();\n      _real = (_PMI_Finalize_t)dlsym(handle,\"PMI_Finalize\");\n      _kvsname_max = (_PMI_KVS_Get_name_length_max_t)dlsym(handle,\"PMI_KVS_Get_name_length_max\");\n      _key_max = (_PMI_KVS_Get_key_length_max_t)dlsym(handle,\"PMI_KVS_Get_key_length_max\");\n      _val_max = (_PMI_KVS_Get_value_length_max_t)dlsym(handle,\"PMI_KVS_Get_value_length_max\");\n    }\n    /*\n    std::fstream out;\n    out.open(\"pmi_base.ckpt\", std::ios_base::out);\n    int kvsname_max, key_max, val_max;\n    _kvsname_max( &kvsname_max );\n    _key_max( &key_max );\n    _val_max( &val_max );\n    log->serialize(out, kvsname_max, key_max, val_max);\n    */\n    int ret = _real();\n    printf(\"MYPMI_Finalize: %p. ret = %d\\n\",_real,ret);\n    return ret;\n}\n\n\nint PMI_KVS_Put( const char kvsname[], const char key[], const char value[])\n{\n    typedef int (*_PMI_KVS_Put_t)( const char kvsname[], const char key[], const char value[] );\n    static _PMI_KVS_Put_t _real = NULL;\n    if( !_real ){\n      init_handle();\n      _real = (_PMI_KVS_Put_t)dlsym(handle,\"PMI_KVS_Put\");\n    }\n    int ret = _real(kvsname,key,value);\n    ret = ret * !(log->kvs_put(kvsname,key,value));\n    return ret;\n}\n\nint PMI_KVS_Commit(char kvsname[], int length )\n{\n    typedef int (*_PMI_KVS_Commit_t)(char kvsname[] );\n    static _PMI_KVS_Commit_t _real = NULL;\n    if( !_real ){\n\tinit_handle();\n      _real = (_PMI_KVS_Commit_t)dlsym(handle,\"PMI_KVS_Commit\");\n    }\n    int size, rc;\n    log->kvs_commit(kvsname);\n    return _real(kvsname);\n}\n\nint PMI_KVS_Create(char kvsname[], int length )\n{\n    typedef int (*_PMI_KVS_Create_t)(char kvsname[], int length );\n    static _PMI_KVS_Create_t _real = NULL;\n    if( !_real ){\n\tinit_handle();\n      _real = (_PMI_KVS_Create_t)dlsym(handle,\"PMI_KVS_Create\");\n    }\n    int ret;\n    ret = _real(kvsname,length);\n    log->kvs_create(kvsname);\n    return ret;\n}\n\nint PMI_KVS_Destroy( char kvsname[] )\n{\n    typedef int (*_PMI_KVS_Destroy_t)(char kvsname[] );\n    static _PMI_KVS_Destroy_t _real = NULL;\n    if( !_real ){\n\tinit_handle();\n      _real = (_PMI_KVS_Destroy_t)dlsym(handle,\"PMI_Destroy\");\n    }\n    log->kvs_create(kvsname);\n    return _real(kvsname);\n}\n\nint PMI_Barrier( void )\n{\n    typedef int (*_PMI_Barrier_t)(void);\n    static _PMI_Barrier_t _real = NULL;\n    typedef int (*_PMI_KVS_Get_name_length_max_t)( int *t );\n    static _PMI_KVS_Get_name_length_max_t _kvsname_max = NULL;\n    typedef int (*_PMI_KVS_Get_key_length_max_t)( int *t );\n    static _PMI_KVS_Get_key_length_max_t _key_max = NULL;\n    typedef int (*_PMI_KVS_Get_value_length_max_t)( int *t );\n    static _PMI_KVS_Get_value_length_max_t _val_max = NULL;\n\n\n    if( !_real ){\n\tinit_handle();\n      _real = (_PMI_Barrier_t)dlsym(handle,\"PMI_Barrier\");\n      _kvsname_max = (_PMI_KVS_Get_name_length_max_t)dlsym(handle,\"PMI_KVS_Get_name_length_max\");\n      _key_max = (_PMI_KVS_Get_key_length_max_t)dlsym(handle,\"PMI_KVS_Get_key_length_max\");\n      _val_max = (_PMI_KVS_Get_value_length_max_t)dlsym(handle,\"PMI_KVS_Get_value_length_max\");\n    }\n\n    std::fstream out;\n    out.open(fprefix, std::ios_base::out);\n    int kvsname_max, key_max, val_max;\n    _kvsname_max( &kvsname_max );\n    _key_max( &key_max );\n    _val_max( &val_max );\n    log->serialize(out, kvsname_max, key_max, val_max);\n    out.close();\n\n    return _real();\n}\n\n}",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/test/dlopen2.cpp": "/* To compile, use -DLIB3 to create libdlopen-lib3.so, -DLIB4 for\n * libdlopen-lib4.so, and define neither to create executable.\n * To run, do:  LD_LIBRARY_PATH=. ./dlopen2\n */\n\n# include <dlfcn.h>\n# include <unistd.h>\n# include <stdio.h>\n# include <stdio.h>\n# include <stdlib.h>\n# include <assert.h>\n\n#if !defined(LIB3) && !defined(LIB4)\nint (*fnc)(int result[2]);\n\nint main(int argc, char* argv[])\n{\n  int lib = 1;\n  void *handle = NULL;\n  int result[2] = {0, 0};\n  int i, answer;\n  int cnt1 = 0, cnt2 = 0;\n\n  printf(\"0: \"); fflush(stdout);\n  while (1) {\n    if (handle != NULL)\n      dlclose(handle);\n\n    if (lib == 1) {\n      handle = dlopen(\"libdlopen-lib3.so\", RTLD_NOW);\n      if (handle == NULL) {\n        fprintf(stderr, \"dlopen failed: %s\\n\", dlerror());\n        exit(1);\n      }\n      /* See 'man dlopen' for example:  POSIX.1-2002 prefers this workaround */\n      *(void **) (&fnc) = dlsym(handle, \"fnc\");\n    }\n\n    if (lib == 2) {\n      handle = dlopen(\"libdlopen-lib4.so\", RTLD_LAZY);\n      if (handle == NULL) {\n        fprintf(stderr, \"dlopen failed: %s\\n\", dlerror());\n        exit(1);\n      }\n      /* See 'man dlopen' for example:  POSIX.1-2002 prefers this workaround */\n      *(void **) (&fnc) = dlsym(handle, \"fnc\");\n    }\n\n    assert(lib == 1 || lib == 2);\n    for (i = 0; i < 5; i++) {\n      answer = fnc(result);\n      if (answer != result[lib - 1]) {\n        fprintf(stderr, \"lib %d returned wrong answer.\\n\", lib);\n        exit(1);\n      }\n    }\n    if (++cnt1 % 1000 == 0) {\n      cnt2++;\n      cnt1 = 0;\n      printf(\".\"); fflush(stdout);\n      if (cnt2 % 50 == 0)\n        printf(\"\\n%d: \", cnt2 / 50);\n      fflush(stdout);\n    }\n    lib = 3 - lib; /* switch libraries to load */\n\n  }\n  return 0;\n}\n\n#elif defined(LIB3)\nextern \"C\" int fnc(int result[2]) {\n    return ++(result[0]);\n}\n\nextern \"C\" int print_constructor() {\n  int dummy = system(\"echo '    In LIB3::print_constructor'\");\n  if (dummy == -1) {\n    perror(\"system failed.\");\n  }\n  sleep(1);\n  return 0;\n}\n\n#elif defined(LIB4)\nextern \"C\" int fnc(int result[2]) {\n    return ++(result[1]);\n}\n\nextern \"C\" int print_constructor() {\n  int dummy = system(\"echo '    In LIB4::print_constructor'\");\n  if (dummy == -1) {\n    perror(\"system failed.\");\n  }\n  sleep(1);\n  return 0;\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/test/dlopen1.c": "/* To compile, use -DLIB1 to create libdlopen-lib1.so, -DLIB2 for\n *   libdlopen-lib2.so, and define neither to create executable.\n * To run, do:  LD_LIBRARY_PATH=. ./dlopen1\n */\n\n#if !defined(LIB1) && !defined(LIB2)\n# include <dlfcn.h>\n# include <stdio.h>\n# include <stdlib.h>\n# include <assert.h>\n\nint (*fnc)(int result[2]);\n\nint main(int argc, char* argv[])\n{\n  int lib = 1;\n  void *handle = NULL;\n  int result[2] = {0, 0};\n  int i, answer;\n  int cnt1 = 0, cnt2 = 0;\n\n  printf(\"0: \"); fflush(stdout);\n  while (1) {\n    if (handle != NULL)\n      dlclose(handle);\n\n    if (lib == 1) {\n      handle = dlopen(\"libdlopen-lib1.so\", RTLD_NOW);\n      if (handle == NULL) {\n        fprintf(stderr, \"dlopen failed: %s\\n\", dlerror());\n        exit(1);\n      }\n      /* See 'man dlopen' for example:  POSIX.1-2002 prefers this workaround */\n      *(void **) (&fnc) = dlsym(handle, \"fnc\");\n    }\n\n    if (lib == 2) {\n      handle = dlopen(\"libdlopen-lib2.so\", RTLD_LAZY);\n      if (handle == NULL) {\n        fprintf(stderr, \"dlopen failed: %s\\n\", dlerror());\n        exit(1);\n      }\n      /* See 'man dlopen' for example:  POSIX.1-2002 prefers this workaround */\n      *(void **) (&fnc) = dlsym(handle, \"fnc\");\n    }\n\n    assert(lib == 1 || lib == 2);\n    for (i = 0; i < 5; i++) {\n      answer = fnc(result);\n      if (answer != result[lib - 1]) {\n        fprintf(stderr, \"lib %d returned wrong answer.\\n\", lib);\n        exit(1);\n      }\n    }\n    if (++cnt1 % 1000 == 0) {\n      cnt2++;\n      cnt1 = 0;\n      printf(\".\"); fflush(stdout);\n      if (cnt2 % 50 == 0)\n        printf(\"\\n%d: \", cnt2 / 50);\n      fflush(stdout);\n    }\n    lib = 3 - lib; /* switch libraries to load */\n  }\n  return 0;\n}\n\n#elif defined(LIB1)\nint fnc(int result[2]) {\n    return ++(result[0]);\n}\n\n#elif defined(LIB2)\nint fnc(int result[2]) {\n    return ++(result[1]);\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/test/autotest.py": "#!/usr/bin/env python\n\nfrom random import randint\nfrom time   import sleep\nimport subprocess\nimport pty\nimport socket\nimport os\nimport sys\nimport errno\nimport signal\nimport resource\nimport pwd\nimport stat\nimport re\n\n#get testconfig\n# This assumes Makefile.in in main dir, but only Makefile in test dir.\ntry:\n  sys.path += [os.getenv(\"PWD\") + '/test', os.getenv('PWD')]\n  from autotest_config import *\n\nexcept ImportError:\n  print \"\\n*** Error importing autotest_config.py: \"\n  sys.exit()\n\nif USE_TEST_SUITE == \"no\":\n  print \"\\n*** DMTCP test suite is disabled. To re-enable the test suite,\\n\" + \\\n        \"***  re-configure _without_ './configure --disable-test-suite'\\n\"\n  sys.exit()\n\n# Disable ptrace tests for now.\nPTRACE_SUPPORT=\"no\"\n\nsignal.alarm(1800)  # half hour\n\nif sys.version_info[0] != 2 or sys.version_info[0:2] < (2,4):\n  print \"test/autotest.py works only with Python 2.x for 2.x greater than 2.3\"\n  print \"Change the beginning of test/autotest.py if you believe you can run.\"\n  sys.exit(1)\n\nif sys.version_info[0] == 2 and sys.version_info[1] >= 7:\n  uname_m = subprocess.check_output(['uname', '-m'])\n  uname_p = subprocess.check_output(['uname', '-p'])\nelse:\n  uname_m = subprocess.Popen(['uname', '-m'],\n                             stdout=subprocess.PIPE).communicate()[0]\n  uname_p = subprocess.Popen(['uname', '-p'],\n                             stdout=subprocess.PIPE).communicate()[0]\n\n# This assumes Makefile.in in main dir, but only Makefile in test dir.\nos.system(\"test -f Makefile || ./configure\")\nif USE_TEST_SUITE == \"no\":\n  print \"\\n*** DMTCP test suite is disabled. To re-enable the test suite,\\n\" + \\\n          \"***  re-configure _without_ './configure --disable-test-suite'\\n\"\n  sys.exit()\n\n#number of checkpoint/restart cycles\nCYCLES=2\n\n#Number of times to try dmtcp_restart\nRETRIES=2\n\n#Sleep after each program startup (sec)\nDEFAULT_S=0.3\nif uname_p[0:3] == 'arm':\n  DEFAULT_S *= 2\n\n# Sleep before the first ckpt _only_.\nDEFAULT_POST_LAUNCH_SLEEP = 0.0\nPOST_LAUNCH_SLEEP = 0.0\n\nuname_m = uname_m.strip() # strip off any whitespace characters\n#Allow extra time for slower CPUs\nif uname_m in [\"i386\", \"i486\", \"i586\", \"i686\", \"armv7\", \"armv7l\", \"aarch64\"]:\n  DEFAULT_S *= 4\n\nS=DEFAULT_S\n#Appears as S*SLOW in code.  If --slow, then SLOW=5\nSLOW=1\n\n#Max time to wait for ckpt/restart to finish (sec)\nTIMEOUT=10\n# Raise this value when /usr/lib/locale/locale-archive is 100MB.\n# This can happen on Red Hat-derived distros.\nif os.path.exists(\"/usr/lib/locale/locale-archive\") and \\\n   os.path.getsize(\"/usr/lib/locale/locale-archive\") > 10e6:\n  TIMEOUT *= int( os.path.getsize(\"/usr/lib/locale/locale-archive\") / 10e6 )\n\n#Interval between checks for ckpt/restart complete\nINTERVAL=0.1\n\n#Buffers for process i/o\nBUFFER_SIZE=4096*8\n\n#False redirects process stderr\nVERBOSE=False\n\n#Should we retry on a failure?\nRETRY_ONCE=False\n\n#Run (most) tests with user default (usually with gzip enable)\nGZIP=os.getenv('DMTCP_GZIP') or \"1\"\n\n#Warn if can't create a file of size:\nREQUIRE_MB=50\n\n#Binaries\nBIN=\"./bin/\"\n\n#Checkpoint command to send to coordinator\nCKPT_CMD='c'\n\n#parse program args\nargs={}\nfor i in sys.argv:\n  args[i]=True\n  if i==\"-v\" or i==\"--verbose\":\n    VERBOSE=True\n  if i==\"--stress\":\n    CYCLES=100000\n  if i==\"--slow\":\n    SLOW *= 5  # SLOW was initialized to 1 ; --slow --slow => SLOW==25\n    TIMEOUT *= SLOW\n  if i==\"--retry-once\":\n    RETRY_ONCE = True\n  #TODO:  Install SIGSEGV handler with infinite loop, and add to LD_PRELOAD\n  #In test/Makefile, build libcatchsigsegv.so\n  #Add --catchsigsegv  to usage string.\n  # if i==\"--catchsigsegv\":\n  #   if os.getenv('LD_PRELOAD'):\n  #     os.environ['LD_PRELOAD'] += ':libcatchsigsegv.so'\n  #   else:\n  #     os.environ['LD_PRELOAD'] = 'libcatchsigsegv.so'\n  if i==\"-h\" or i==\"--help\":\n    print (\"USAGE \"+sys.argv[0]+\n      \" [-v] [--stress] [--slow] [testname] [testname ...]\")\n    sys.exit(1)\n\nstats = [0, 0]\n\ndef xor(bool1, bool2):\n  return (bool1 or bool2) and (not bool1 or not bool2)\n\ndef replaceChar(string, index, char):\n  return string[0:index] + char + string[index+1:len(string)]\n\ndef splitWithQuotes(string):\n  inSingleQuotes = False\n  inDoubleQuotes = False\n  isOuter = False\n  escapeChar = False\n  for i in range(len(string)):\n    if escapeChar:\n      escapeChar = False\n      continue\n    if string[i] == \"\\\\\":\n      escapeChar = True\n      # Remove one level of escaping if same quoting char as isOuter\n      string = replaceChar(string, i, '#')\n      continue\n    if string[i] == \"'\":\n      inSingleQuotes = not inSingleQuotes\n    if string[i] == '\"':\n      inDoubleQuotes = not inDoubleQuotes\n    # Remove outermost quotes: 'bash -c \"sleep 30\"' => ['bash','-c','sleep 30']\n    if string[i] == \"'\" or string[i] == '\"':\n      # This triggers twice in:  '\"...\"'  (on first ' and second \")\n      if xor(inSingleQuotes, inDoubleQuotes) and not isOuter: # if beg. of quote\n        isOuter = string[i]\n        string = replaceChar(string, i, '#')\n      elif isOuter == string[i]:  # if end of quote\n        isOuter = False\n        string = replaceChar(string, i, '#')\n    if not inSingleQuotes and not inDoubleQuotes and string[i] == ' ':\n      # FIXME (Is there any destructive way to do this?)\n      string = replaceChar(string, i, '%')\n  string = string.replace('#', '')\n  return string.split('%')\n\ndef shouldRunTest(name):\n  # FIXME:  This is a hack.  We should have created var, testNaems and use here\n  if len(sys.argv) <= 1+(VERBOSE==True)+(SLOW!=1)+(CYCLES!=2)+(RETRY_ONCE==True):\n    return True\n  return name in sys.argv\n\n#make sure we are in svn root\nif os.system(\"test -d bin\") != 0:\n  os.chdir(\"..\")\nif USE_M32:\n  assert os.system(\"test -d bin\") == 0, \\\n  \"  bin/dmtcp_launch not found.  Please configure and build the\\n\" + \\\n  \"  default 64-bit mode before configuring with --enable-m32 and re-building\"\nelse:\n  assert os.system(\"test -d bin\") == 0\n\n#make sure dmtcp is built\nif os.system(\"make -s --no-print-directory tests\") != 0:\n  print \"`make all tests` FAILED\"\n  sys.exit(1)\n\n#pad a string and print/flush it\ndef printFixed(str, w=1):\n  # The comma at end of print prevents a \"newline\", but still adds space.\n  if sys.version_info[0] == 2:\n    # Replace \"print str.ljust(w),\"  by version compatible w/ python3:\n    os.write(sys.stdout.fileno(), str.ljust(w).encode(\"ascii\"))\n  sys.stdout.flush()\n\n#exception on failed check\nclass CheckFailed(Exception):\n  def __init__(self, value=\"\"):\n    self.value = value\n\nclass MySubprocess:\n  \"dummy class: same fields as from subprocess module\"\n  def __init__(self, pid):\n    self.pid = pid\n    self.stdin = os.open(os.devnull, os.O_RDONLY)\n    self.stdout = os.open(os.devnull, os.O_WRONLY)\n    self.stderr = os.open(os.devnull, os.O_WRONLY)\n\ndef master_read(fd):\n  os.read(fd, 4096)\n  return ''\n\n#run a child process\n# NOTE:  Can eventually migrate to Python 2.7:  subprocess.check_output\ndevnullFd = os.open(os.devnull, os.O_WRONLY)\ndef runCmd(cmd):\n  global devnullFd\n  global master_read\n  if VERBOSE:\n    print \"Launching... \", cmd\n  cmd = splitWithQuotes(cmd);\n  # Example cmd:  dmtcp_launch screen ...\n  ptyMode = False\n  for str in cmd:\n    # Checkpoint image can be emacs23_x, or whatever emacs is a link to.\n    # vim can be vim.gnome, etc.\n    if re.search(\"(_|/|^)(screen|script|vim.*|emacs.*|pty)(_|$)\", str):\n      ptyMode = True\n  try:\n    os.stat(cmd[0])\n  except:\n    raise CheckFailed(cmd[0] + \" not found\")\n  if ptyMode:\n    # FOR DEBUGGING:  This can mysteriously fail, causing pty.fork() to fail\n    try:\n      (fd1, fd2) = os.openpty()\n    except OSError, e:\n      print \"\\n\\n/dev/ptmx:\"; os.system(\"ls -l /dev/ptmx /dev/pts\")\n      raise e\n    else:\n      os.close(fd1); os.close(fd2)\n    (pid, fd) = pty.fork()\n    if pid == 0:\n      # Close all fds except stdin/stdout/stderr\n      os.closerange(3,1024)\n      signal.alarm(300) # pending alarm inherited across exec, but not a fork\n      # Problem:  pty.spawn invokes fork.  alarm() will have no effect.\n      pty.spawn(cmd, master_read)\n      sys.exit(0)\n    else:\n      return MySubprocess(pid)\n  else:\n    if cmd[0] == BIN+\"dmtcp_coordinator\":\n      childStdout = subprocess.PIPE\n      # Don't mix stderr in with childStdout; need to read stdout\n      if VERBOSE:\n        childStderr = None\n      else:\n        childStderr = devnullFd\n    elif VERBOSE:\n      childStdout=None  # Inherit child stdout from parent\n      childStderr=None  # Inherit child stderr from parent\n    else:\n      childStdout = devnullFd\n      childStderr = subprocess.STDOUT # Mix stderr into stdout file object\n    # NOTE:  This might be replaced by shell=True in call to subprocess.Popen\n    proc = subprocess.Popen(cmd, bufsize=BUFFER_SIZE,\n                 stdin=subprocess.PIPE, stdout=childStdout,\n                 stderr=childStderr, close_fds=True)\n  return proc\n\n#randomize port and dir, so multiple processes works\nckptDir=\"dmtcp-autotest-%d\" % randint(100000000,999999999)\nos.mkdir(ckptDir);\nos.environ['DMTCP_COORD_HOST'] = \"localhost\"\nos.environ['DMTCP_COORD_PORT'] = str(randint(2000,10000))\nos.environ['DMTCP_CHECKPOINT_DIR'] = os.path.abspath(ckptDir)\n#Use default SIGCKPT for test suite.\nos.unsetenv('DMTCP_SIGCKPT')\nos.unsetenv('MTCP_SIGCKPT')\n#No gzip by default.  (Isolate gzip failures from other test failures.)\n#But note that dmtcp3, frisbee and gzip tests below still use gzip.\nif not VERBOSE:\n  os.environ['JALIB_STDERR_PATH'] = os.devnull\nif VERBOSE:\n  print \"coordinator port:  \" + os.environ['DMTCP_COORD_PORT']\n\n# We'll copy ckptdir to DMTCP_TMPDIR in case of error.\ndef dmtcp_tmpdir():\n  tmpdir = os.getenv('DMTCP_TMPDIR') or os.getenv('TMPDIR') or '/tmp'\n  return tmpdir + '/dmtcp-' + os.environ['USER'] + '@' + socket.gethostname()\n\ndef free_diskspace(dir):\n  s = os.statvfs('.')\n  return s.f_bavail * s.f_frsize\n\n# We'll save core dumps in our default directory (usually dmtcp-autotest-*)\n# We can use the lesser of half the free disk space of filesystem or 100 MB.\nif free_diskspace(ckptDir) > 20*1024*1024:\n  oldLimit = resource.getrlimit(resource.RLIMIT_CORE)\n  newLimit = [min(free_diskspace(ckptDir)/2, 100*1024*1024), oldLimit[1]]\n  if oldLimit[1] != resource.RLIM_INFINITY:  # Keep soft limit below hard limit\n    newLimit[0] = min(newLimit[0], oldLimit[1])\n  resource.setrlimit(resource.RLIMIT_CORE, newLimit)\n\n# This can be slow.\nprint(\"Verifying there is enough disk space ...\")\ntmpfile=ckptDir + \"/freeSpaceTest.tmp\"\nif os.system(\"dd if=/dev/zero of=\" + tmpfile + \" bs=1MB count=\" +\n             str(REQUIRE_MB) + \" 2>/dev/null\") != 0:\n  GZIP=\"1\"\n  print '''\n\n!!!WARNING!!!\nFewer than '''+str(REQUIRE_MB)+'''MB are available on the current volume.\nMany of the tests below may fail due to insufficient space.\n!!!WARNING!!!\n\n'''\nos.system(\"rm -f \"+tmpfile)\n\nos.environ['DMTCP_GZIP'] = GZIP\nif os.getenv('LD_LIBRARY_PATH'):\n    os.environ['LD_LIBRARY_PATH'] += ':' + os.getenv(\"PWD\")+\"/lib\"\nelse:\n    os.environ['LD_LIBRARY_PATH'] = os.getenv(\"PWD\")+\"/lib\"\n\n#run the coordinator\ncoordinator = runCmd(BIN+\"dmtcp_coordinator\")\n\n#send a command to the coordinator process\ndef coordinatorCmd(cmd):\n  try:\n    if VERBOSE and cmd != \"s\":\n      print \"COORDINATORCMD(\",cmd,\")\"\n    coordinator.stdin.write(cmd+\"\\n\")\n    coordinator.stdin.flush()\n  except:\n    raise CheckFailed(\"failed to write '%s' to coordinator (pid: %d)\" % \\\n                      (cmd, coordinator.pid))\n\n#clean up after ourselves\ndef SHUTDOWN():\n  try:\n    coordinatorCmd('q')\n    sleep(S*SLOW)\n  except:\n    print \"SHUTDOWN() failed\"\n  os.system(\"kill -9 %d\" % coordinator.pid)\n  os.system(\"rm -rf  %s\" % ckptDir)\n  os.close(devnullFd)\n\n#make sure val is true\ndef CHECK(val, msg):\n  if not val:\n    raise CheckFailed(msg)\n\n#wait TIMEOUT for test() to be true, or throw error\ndef WAITFOR(test, msg):\n  left=TIMEOUT*(S/DEFAULT_S)/INTERVAL\n  while not test():\n    if left <= 0:\n      CHECK(False, msg())\n    left-=1\n    sleep(INTERVAL)\n\n#extract (NUM_PEERS, RUNNING) from coordinator\ndef getStatus():\n  coordinatorCmd('s')\n\n  returncode = coordinator.poll()\n  if returncode:\n    if returncode < 0:\n      print \"Coordinator terminated by signal \", str(-returncode)\n    CHECK(False, \"coordinator died unexpectedly\")\n    return (-1, False)\n\n  while True:\n    try:\n      line=coordinator.stdout.readline().strip()\n      if not line:  # Immediate empty string on stdout means EOF\n        CHECK(False, \"coordinator died unexpectedly\")\n        return (-1, False)\n\n      m = re.search('NUM_PEERS=(\\d+)', line)\n      if m != None:\n        peers = int(m.group(1))\n        continue\n\n      m = re.search('RUNNING=(\\w+)', line)\n      if m != None:\n        running = m.group(1)\n        break\n\n    except IOError, (errno, strerror):\n      if coordinator.poll():\n        if coordinator.poll() < 0:\n          print \"Coordinator terminated by signal \", str(-returncode)\n        CHECK(False, \"coordinator died unexpectedly\")\n        return (-1, False)\n      if errno==4: #Interrupted system call\n        continue\n      raise CheckFailed(\"I/O error(%s): %s\" % (errno, strerror))\n\n  if VERBOSE:\n    print \"STATUS: peers=%d, running=%s\" % (peers,running)\n\n  return (peers, (running==\"yes\"))\n\n#delete all files in ckptDir\ndef clearCkptDir():\n  for TRIES in range(2):  # Try twice in case ckpt_*_dmtcp.temp is renamed.\n    #clear checkpoint dir\n    for root, dirs, files in os.walk(ckptDir, topdown=False):\n      for name in files:\n        try:\n          # if name.endswith(\".dmtcp\") :\n          #   import shutil\n          #   shutil.copy(os.path.join(root, name), \"/home/kapil/dmtcp/ramfs\")\n          # else:\n          #   os.remove(os.path.join(root, name))\n          os.remove(os.path.join(root, name))\n        except OSError, e:\n          if e.errno != errno.ENOENT:  # Maybe ckpt_*_dmtcp.temp was renamed.\n            raise e\n      for name in dirs:\n        os.rmdir(os.path.join(root, name))\n\ndef getNumCkptFiles(dir):\n  return len(filter(lambda f: f.startswith(\"ckpt_\") and f.endswith(\".dmtcp\"),\\\n                              os.listdir(dir)))\n\n\n# Test a given list of commands to see if they checkpoint\n# runTest() sets up a keyboard interrupt handler, and then calls this function.\ndef runTestRaw(name, numProcs, cmds):\n  #the expected/correct running status\n#  if USE_M32:\n#    def forall(fnc, lst):\n#      return reduce(lambda x, y: x and y, map(fnc, lst))\n#    if not forall(lambda x: x.startswith(\"./test/\"), cmds):\n#      return\n  status=(numProcs, True)\n  procs=[]\n\n  def doesStatusSatisfy(newStatus,requiredStatus):\n    if isinstance(requiredStatus[0], int):\n      statRange = [requiredStatus[0]]\n    elif isinstance(requiredStatus[0], list):\n      statRange = requiredStatus[0]\n    else:\n      raise NotImplementedError\n    return newStatus[0] in statRange and newStatus[1] == requiredStatus[1]\n\n  def wfMsg(msg):\n    #return function to generate error message\n    return lambda: msg+\", \"+str(status[0])+ \\\n                   \" expected, %d found, running=%d\" % getStatus()\n\n  def testKill():\n    #kill all processes\n    coordinatorCmd('k')\n    try:\n      WAITFOR(lambda: getStatus()==(0, False),\n              lambda:\"coordinator kill command failed\")\n    except CheckFailed:\n      global coordinator\n      coordinatorCmd('q')\n      os.system(\"kill -9 %d\" % coordinator.pid)\n      print \"Trying to kill old coordinator, and run new one on same port\"\n      coordinator = runCmd(BIN+\"dmtcp_coordinator\")\n    for x in procs:\n      #cleanup proc\n      try:\n        if isinstance(x.stdin,int):\n          os.close(x.stdin)\n        elif x.stdin:\n          x.stdin.close()\n        if isinstance(x.stdout,int):\n          os.close(x.stdout)\n        elif x.stdout:\n          x.stdout.close()\n        if isinstance(x.stderr,int):\n          os.close(x.stderr)\n        elif x.stderr:\n          x.stderr.close()\n      except:\n        None\n      try:\n        os.waitpid(x.pid, os.WNOHANG)\n      except OSError, e:\n        if e.errno != errno.ECHILD:\n          raise e\n      procs.remove(x)\n\n  def testCheckpoint():\n    #start checkpoint\n    coordinatorCmd(CKPT_CMD)\n\n    #wait for files to appear and status to return to original\n    WAITFOR(lambda: getNumCkptFiles(ckptDir)>0 and \\\n                   (CKPT_CMD == 'xc' or doesStatusSatisfy(getStatus(), status)),\n            wfMsg(\"checkpoint error\"))\n    #we now know there was at least one checkpoint file, and the correct number\n    #  of processes have restarted;  but they may fail quickly after restert\n\n    if SLOW > 1:\n      #wait and give the processes time to write all of the checkpoint files\n      sleep(S*SLOW)\n\n    #make sure the right files are there\n    numFiles=getNumCkptFiles(ckptDir) # len(os.listdir(ckptDir))\n    CHECK(doesStatusSatisfy((numFiles,True),status),\n          \"unexpected number of checkpoint files, %s procs, %d files\"\n          % (str(status[0]), numFiles))\n\n    if SLOW > 1:\n      #wait and see if some processes will die shortly after checkpointing\n      sleep(S*SLOW)\n      CHECK(doesStatusSatisfy(getStatus(), status),\n            \"error: processes checkpointed, but died upon resume\")\n\n  def testRestart():\n    #build restart command\n    cmd=BIN+\"dmtcp_restart --quiet\"\n    for i in os.listdir(ckptDir):\n      if i.endswith(\".dmtcp\"):\n        cmd+= \" \"+ckptDir+\"/\"+i\n    #run restart and test if it worked\n    procs.append(runCmd(cmd))\n    WAITFOR(lambda: doesStatusSatisfy(getStatus(), status),\n            wfMsg(\"restart error\"))\n    if SLOW > 1:\n      #wait and see if process will die shortly after restart\n      sleep(S*SLOW)\n      CHECK(doesStatusSatisfy(getStatus(), status),\n            \"error:  processes restarted and then died\")\n    if HBICT_DELTACOMP == \"no\":\n      clearCkptDir()\n\n  try:\n    printFixed(name,15)\n\n    if not shouldRunTest(name):\n      print \"SKIPPED\"\n      return\n\n    stats[1]+=1\n    CHECK(getStatus()==(0, False), \"coordinator initial state\")\n\n    #start user programs\n    for cmd in cmds:\n      procs.append(runCmd(BIN+\"dmtcp_launch \"+cmd))\n\n    #TIMEOUT in WAITFOR has also been multiplied by SLOW\n    WAITFOR(lambda: doesStatusSatisfy(getStatus(), status),\n            wfMsg(\"user program startup error\"))\n\n    # Additional sleep to allow the test to boot.\n    sleep(POST_LAUNCH_SLEEP)\n\n    #Will sleep(S*SLOW) in the following for loop.\n\n    for i in range(CYCLES):\n      if i!=0 and i%2==0:\n        print #newline\n        printFixed(\"\",15)\n      printFixed(\"ckpt:\")\n      # NOTE:  If this faile, it will throw an exception to CheckFailed\n      #  of this function:  testRestart\n      #wait for launched processes to settle down, before we try to checkpoint\n      sleep(S*SLOW)\n      testCheckpoint()\n      printFixed(\"PASSED \")\n      testKill()\n\n      printFixed(\"rstr:\")\n      for j in range(RETRIES):\n        try:\n          testRestart()\n          printFixed(\"PASSED\")\n          break\n        except CheckFailed, e:\n          if j == RETRIES-1:\n            # Save checkpoint images for later diagnosis.\n            if os.path.isdir(dmtcp_tmpdir()) and os.path.isdir(ckptDir):\n              if subprocess.call( (\"cp -pr \" + ckptDir + ' '\n                                   + dmtcp_tmpdir()).split() ) == 0:\n                print \"\\n***** Copied checkpoint images to \" + dmtcp_tmpdir() \\\n                      + \"/\" + ckptDir\n            raise e\n          else:\n            printFixed(\"FAILED \")\n            (oldpid, oldstatus) = os.waitpid(procs[-1].pid, os.WNOHANG)\n            if oldpid == procs[-1].pid:\n              if os.WIFEXITED(oldstatus):\n                printFixed(\"(first process exited: oldstatus \"\n                           + str(os.WEXITSTATUS(oldstatus)) + \")\")\n              if os.WIFSIGNALED(oldstatus):\n                printFixed(\"(first process rec'd signal \"\n                           + str(os.WTERMSIG(oldstatus)) + \")\")\n              if os.WCOREDUMP(oldstatus):\n                coredump = \"core.\" + str(oldpid)\n                if os.path.isdir(dmtcp_tmpdir()) and os.path.isfile(coredump):\n                  if subprocess.call( (\"cp -pr \" + coredump + ' '\n                                   + dmtcp_tmpdir()).split() ) == 0:\n                    printFixed(\" (\" + coredump + \" copied to DMTCP_TMPDIR:\" +\n                               dmtcp_tmpdir() + \"/)\")\n            else:\n              printFixed(\"(first process didn't die)\")\n            printFixed(\" retry:\")\n            testKill()\n      if i != CYCLES - 1:\n        printFixed(\"; \")\n\n    testKill()\n    print #newline\n    stats[0]+=1\n\n  except CheckFailed, e:\n    print \"FAILED\"\n    printFixed(\"\",15)\n    print \"root-pids:\", map(lambda x: x.pid, procs), \"msg:\", e.value\n    try:\n      testKill()\n    except CheckFailed, e:\n      print \"CLEANUP ERROR:\", e.value\n      SHUTDOWN()\n      saveResultsNMI()\n      sys.exit(1)\n    if RETRY_ONCE:\n      clearCkptDir()\n      raise e\n\n  clearCkptDir()\n\ndef getProcessChildren(pid):\n    p = subprocess.Popen(\"ps --no-headers -o pid --ppid %d\" % pid, shell = True,\n                         stdout = subprocess.PIPE, stderr = subprocess.PIPE)\n    stdout, stderr = p.communicate()\n    return [int(pid) for pid in stdout.split()]\n\n# If the user types ^C, then kill all child processes.\ndef runTest(name, numProcs, cmds):\n  for i in range(2):\n    try:\n      runTestRaw(name, numProcs, cmds)\n      break;\n    except KeyboardInterrupt:\n      for pid in getProcessChildren(os.getpid()):\n        try:\n          os.kill(pid, signal.SIGKILL)\n        except OSError: # This happens if pid already died.\n          pass\n    except CheckFailed, e:\n      if not RETRY_ONCE:\n        break\n      if i == 0:\n        stats[1]-=1\n        print \"Trying once again\"\n\ndef saveResultsNMI():\n  if DEBUG == \"yes\":\n    # WARNING:  This can cause a several second delay on some systems.\n    host = socket.getfqdn()\n    if re.search(\"^nmi-.*.cs.wisc.edu$\", host) or \\\n       re.search(\"^nmi-.*.cs.wisconsin.edu$\", host):\n      tmpdir = os.getenv(\"TMPDIR\", \"/tmp\") # if \"TMPDIR\" not set, return \"/tmp\"\n      target = \"./dmtcp-\" + pwd.getpwuid(os.getuid()).pw_name + \\\n               \"@\" + socket.gethostname()\n      cmd = \"mkdir results; cp -pr \" + tmpdir + \"/\" + target + \\\n               \" ./dmtcp/src/libdmtcp.so\" + \\\n               \" ./dmtcp/src/dmtcp_coordinator\" + \\\n               \" ./mtcp/libmtcp.so\" + \\\n               \" results/\"\n      os.system(cmd)\n      cmd = \"tar zcf ../results.tar.gz ./results; rm -rf results\"\n      os.system(cmd)\n      print \"\\n*** results.tar.gz (\"+tmpdir+\"/\"+target+ \\\n                                              \") written to DMTCP_ROOT/.. ***\"\n\nprint \"== Tests ==\"\n\n#tmp port\np0=str(randint(2000,10000))\np1=str(randint(2000,10000))\np2=str(randint(2000,10000))\np3=str(randint(2000,10000))\n\n# Use uniform user shell.  Else apps like script have different subprocesses.\nos.environ[\"SHELL\"]=\"/bin/bash\"\n\nrunTest(\"dmtcp1\",        1, [\"./test/dmtcp1\"])\n\nrunTest(\"dmtcp2\",        1, [\"./test/dmtcp2\"])\n\nrunTest(\"dmtcp3\",        1, [\"./test/dmtcp3\"])\n\nrunTest(\"dmtcp4\",        1, [\"./test/dmtcp4\"])\n\nrunTest(\"alarm\",        1, [\"./test/alarm\"])\n\nrunTest(\"sched_test\",    2, [\"./test/sched_test\"])\n\n# In 32-bit Ubuntu 9.10, the default small stacksize (8 MB) forces\n# legacy_va_layout, which places vdso in low memory.  This collides with text\n# in low memory (0x110000) in the statically linked mtcp_restart executable.\noldLimit = resource.getrlimit(resource.RLIMIT_STACK)\n# oldLimit[1] is old hard limit\nif oldLimit[1] == resource.RLIM_INFINITY:\n  newCurrLimit = 8L*1024*1024\nelse:\n  newCurrLimit = min(8L*1024*1024, oldLimit[1])\nresource.setrlimit(resource.RLIMIT_STACK, [newCurrLimit, oldLimit[1]])\nrunTest(\"dmtcp5\",        2, [\"./test/dmtcp5\"])\nresource.setrlimit(resource.RLIMIT_STACK, oldLimit)\n\n# Test for a bunch of system calls. We want to use the 'xc' mode for\n# checkpointing so that the process is killed right after checkpoint. Otherwise\n# the syscall-tester could fail in the following case:\n#   1. create and open temp file\n#   2. close temp file\n#   3. ckpt\n#   4. unlink temp file\n# If the last step is executed before the process is killed after ckpt-resume,\n# the file would have been deleted from the disk. However, on restart, the test\n# program will try to unlink the file once again, but the unlink operation will\n# fail, causing the test to fail.\nold_ckpt_cmd = CKPT_CMD\nCKPT_CMD = 'xc'\nrunTest(\"syscall-tester\",  1, [\"./test/syscall-tester\"])\nCKPT_CMD = old_ckpt_cmd\n\n# Test for files opened with WRONLY mode and later unlinked.\nrunTest(\"file1\",         1, [\"./test/file1\"])\n\n# Test for files and their directories opened and unlinked\n# PREV. NOTE (now fixed?):\n#   Currently, we re-create deleted subdirectories when file\n#   is mmap'ed, but not yet when file is referenced by open fd.\nS=10*DEFAULT_S\nrunTest(\"file2\",         1, [\"./test/file2\"])\nS=DEFAULT_S\n\n# Test for normal file, /dev/tty, proc file, and illegal pathname\nrunTest(\"stat\",         1, [\"./test/stat\"])\n\nPWD=os.getcwd()\nrunTest(\"plugin-sleep2\", 1, [\"--with-plugin \"+\n                             PWD+\"/test/plugin/sleep1/dmtcp_sleep1hijack.so:\"+\n                             PWD+\"/test/plugin/sleep2/dmtcp_sleep2hijack.so \"+\n                             \"./test/dmtcp1\"])\n\nrunTest(\"plugin-example-db\", 2, [\"--with-plugin \"+\n                            PWD+\"/test/plugin/example-db/dmtcp_example-dbhijack.so \"+\n                             \"env EXAMPLE_DB_KEY=1 EXAMPLE_DB_KEY_OTHER=2 \"+\n                             \"./test/dmtcp1\",\n                                 \"--with-plugin \"+\n                            PWD+\"/test/plugin/example-db/dmtcp_example-dbhijack.so \"+\n                             \"env EXAMPLE_DB_KEY=2 EXAMPLE_DB_KEY_OTHER=1 \"+\n                             \"./test/dmtcp1\"])\n\n# Test special case:  gettimeofday can be handled within VDSO segment.\nrunTest(\"gettimeofday\",  1, [\"./test/gettimeofday\"])\n\nrunTest(\"sigchild\",      1, [\"./test/sigchild\"])\n\nrunTest(\"shared-fd1\",     2, [\"./test/shared-fd1\"])\n\nrunTest(\"shared-fd2\",     2, [\"./test/shared-fd2\"])\n\nrunTest(\"stale-fd\",      2, [\"./test/stale-fd\"])\n\n# Disable procfd1 until we fix readlink\n#runTest(\"procfd1\",       2, [\"./test/procfd1\"])\n\n# popen1 can have more than one processes\nrunTest(\"popen1\",          [1,2], [\"./test/popen1\"])\n\nrunTest(\"poll\",          1, [\"./test/poll\"])\n\nrunTest(\"epoll1\",        2, [\"./test/epoll1\"])\n\nif HAS_EPOLL_CREATE1 == \"yes\":\n  runTest(\"epoll2\",        2, [\"./test/epoll1 --use-epoll-create1\"])\n\nrunTest(\"environ\",       1, [\"./test/environ\"])\n\nrunTest(\"forkexec\",      2, [\"./test/forkexec\"])\n\nrunTest(\"realpath\",      1, [\"./test/realpath\"])\nrunTest(\"pthread1\",      1, [\"./test/pthread1\"])\nrunTest(\"pthread2\",      1, [\"./test/pthread2\"])\nS=10*DEFAULT_S\nrunTest(\"pthread3\",      1, [\"./test/pthread2 80\"])\nS=DEFAULT_S\nrunTest(\"pthread4\",      1, [\"./test/pthread4\"])\nrunTest(\"pthread5\",      1, [\"./test/pthread5\"])\n\nif HAS_MUTEX_WRAPPERS == \"yes\":\n  runTest(\"mutex1\",        1, [\"./test/mutex1\"])\n  runTest(\"mutex2\",        1, [\"./test/mutex2\"])\n  runTest(\"mutex3\",        1, [\"./test/mutex3\"])\n  # Comment out the test until pthread bug is fixed.\n  #runTest(\"mutex4\",        1, [\"./test/mutex4\"])\n\n\n# FIXME:  pthread_atfork doesn't compile on some architectures.\n#         If we add a configure test for pthread_atfork, we can\n#           set a Python variable in autotest_config.py.in\nif uname_m != \"armv7\" and uname_m != \"armv7l\" and uname_m != \"aarch64\":\n  if os.getenv(\"LD_LIBRARY_PATH\"):\n    os.environ[\"LD_LIBRARY_PATH\"] += \":./test\"\n  else:\n    os.environ[\"LD_LIBRARY_PATH\"] = \"./test\"\n  runTest(\"pthread_atfork1\",      2, [\"./test/pthread_atfork1\"])\n  runTest(\"pthread_atfork2\",      2, [\"./test/pthread_atfork2\"])\n  if os.environ[\"LD_LIBRARY_PATH\"] == \"./test\":\n    del os.environ[\"LD_LIBRARY_PATH\"]\n  else:\n    os.environ[\"LD_LIBRARY_PATH\"] = \\\n      os.getenv(\"LD_LIBRARY_PATH\")[:-len(\":./test\")]\nelse:\n  print \"Skipping pthread_atfork test; doesn't build on ARM/aarch64/glibc/Linux\"\n\nif not USE_M32:  # ssh (a 64-bit child process) is forked\n  if HAS_SSH_LOCALHOST == \"yes\":\n    S=5*DEFAULT_S\n    runTest(\"ssh1\",     4, [\"./test/ssh1\"])\n    S=DEFAULT_S\n\nif not USE_M32:  # waitpid forks a 64-bit child process, /bin/sleep\n  S=2*DEFAULT_S\n  runTest(\"waitpid\",      2, [\"./test/waitpid\"])\n  S=DEFAULT_S\n\nrunTest(\"client-server\", 2, [\"./test/client-server\"])\n\n# frisbee creates three processes, each with 14 MB, if no gzip is used\nos.environ['DMTCP_GZIP'] = \"1\"\nPOST_LAUNCH_SLEEP=2\nrunTest(\"frisbee\",       3, [\"./test/frisbee \"+p1+\" localhost \"+p2,\n                             \"./test/frisbee \"+p2+\" localhost \"+p3,\n                             \"./test/frisbee \"+p3+\" localhost \"+p1+\" starter\"])\nPOST_LAUNCH_SLEEP=DEFAULT_POST_LAUNCH_SLEEP\nos.environ['DMTCP_GZIP'] = GZIP\n\n# On an NFS filesystem, a race can manifest late on the second restart,\n# due to a slow coordinator.\nS=10*DEFAULT_S\nrunTest(\"shared-memory1\", 2, [\"./test/shared-memory1\"])\nrunTest(\"shared-memory2\", 2, [\"./test/shared-memory2\"])\nS=DEFAULT_S\n\nrunTest(\"sysv-shm1\",     2, [\"./test/sysv-shm1\"])\nrunTest(\"sysv-shm2\",     2, [\"./test/sysv-shm2\"])\nrunTest(\"sysv-sem\",      2, [\"./test/sysv-sem\"])\nrunTest(\"sysv-msg\",      2, [\"./test/sysv-msg\"])\n\n# Makefile compiles cma only for Linux 3.2 and higher.\nif HAS_CMA == \"yes\":\n  runTest(\"cma\",         2, [\"./test/cma\"])\n\n# ARM glibc 2.16 with Linux kernel 3.0 doesn't support mq_send, etc.\nif uname_p[0:3] == 'arm':\n  print \"Skipping posix-mq1/mq2 tests; ARM/glibc/Linux does not support mq_send\"\nelif TEST_POSIX_MQ == \"yes\":\n  runTest(\"posix-mq1\",     2, [\"./test/posix-mq1\"])\n  runTest(\"posix-mq2\",     2, [\"./test/posix-mq2\"])\n\n#Invoke this test when we drain/restore data in pty at checkpoint time.\n# runTest(\"pty1\",   2, [\"./test/pty1\"])\nrunTest(\"pty2\",   2, [\"./test/pty2\"])\n\n#Invoke this test when support for timers is added to DMTCP.\nrunTest(\"timer1\",   1, [\"./test/timer1\"])\nrunTest(\"timer2\",   1, [\"./test/timer2\"])\nrunTest(\"clock\",   1, [\"./test/clock\"])\n\nold_ld_library_path = os.getenv(\"LD_LIBRARY_PATH\")\nif old_ld_library_path:\n  os.environ['LD_LIBRARY_PATH'] += ':' + os.getenv(\"PWD\") + \\\n                                   \"/test:\" + os.getenv(\"PWD\")\nelse:\n  os.environ['LD_LIBRARY_PATH'] = os.getenv(\"PWD\") + \"/test:\" + os.getenv(\"PWD\")\nrunTest(\"dlopen1\",        1, [\"./test/dlopen1\"])\n# Disable the dlopen2 test until we can figure out a way to handle calls to\n# fork/exec/wait during library intialization with dlopen().\n# This seems to affect Travis CI of github, but not Ubuntu-12.04\n#if not USE_M32:\n#  runTest(\"dlopen2\",        1, [\"./test/dlopen2\"])\nif old_ld_library_path:\n  os.environ['LD_LIBRARY_PATH'] = old_ld_library_path\nelse:\n  del os.environ['LD_LIBRARY_PATH']\n\n# Most of the remaining tests are on 64-bit processes.\nif USE_M32:\n  sys.exit()\n\nos.environ['DMTCP_GZIP'] = \"1\"\nrunTest(\"gzip\",          1, [\"./test/dmtcp1\"])\nos.environ['DMTCP_GZIP'] = GZIP\n\nif HAS_READLINE == \"yes\":\n  runTest(\"readline\",    1,  [\"./test/readline\"])\n\nrunTest(\"perl\",          1, [\"/usr/bin/perl\"])\n\nif HAS_PYTHON == \"yes\":\n  runTest(\"python\",      1, [\"/usr/bin/python\"])\n\nos.environ['DMTCP_GZIP'] = \"1\"\nrunTest(\"bash\",        2, [\"/bin/bash --norc -c 'ls; sleep 30; ls'\"])\nos.environ['DMTCP_GZIP'] = GZIP\n\nif HAS_DASH == \"yes\":\n  os.environ['DMTCP_GZIP'] = \"0\"\n  os.unsetenv('ENV')  # Delete reference to dash initialization file\n  runTest(\"dash\",        2, [\"/bin/dash -c 'ls; sleep 30; ls'\"])\n  os.environ['DMTCP_GZIP'] = GZIP\n\nif HAS_TCSH == \"yes\":\n  os.environ['DMTCP_GZIP'] = \"1\"\n  runTest(\"tcsh\",        2, [\"/bin/tcsh -f -c 'ls; sleep 30; ls'\"])\n  os.environ['DMTCP_GZIP'] = GZIP\n\nif HAS_ZSH == \"yes\":\n  os.environ['DMTCP_GZIP'] = \"0\"\n  S=3*DEFAULT_S\n  runTest(\"zsh\",         2, [\"/bin/zsh -f -c 'ls; sleep 30; ls'\"])\n  S=DEFAULT_S\n  os.environ['DMTCP_GZIP'] = GZIP\n\nif HAS_VIM == \"yes\":\n  # Wait to checkpoint until vim finishes reading its initialization files\n  S=10*DEFAULT_S\n  if sys.version_info[0:2] >= (2,6):\n    # Delete previous vim processes.  Vim behaves poorly with stale processes.\n    vimCommand = VIM + \" /etc/passwd +3\" # +3 makes cmd line unique\n    def killCommand(cmdToKill):\n      if os.getenv('USER') == None or HAS_PS == 'no':\n        return\n      ps = subprocess.Popen(['ps', '-u', os.environ['USER'], '-o',\n                             'pid,command'],\n                            stdout=subprocess.PIPE).communicate()[0]\n      for row in ps.split('\\n')[1:]:\n        cmd = row.split(None, 1) # maxsplit=1\n        if len(cmd) > 1 and cmd[1] == cmdToKill:\n          os.kill(int(cmd[0]), signal.SIGKILL)\n    killCommand(vimCommand)\n    runTest(\"vim\",       1,  [\"env TERM=vt100 \" + vimCommand])\n    killCommand(vimCommand)\n  S=DEFAULT_S\n\nif sys.version_info[0:2] >= (2,6):\n  #On some systems, \"emacs -nw\" runs dbus-daemon processes in\n  #background throwing off the number of processes in the computation. The\n  #test thus fails. The fix is to run emacs-nox, if found. emacs-nox\n  #doesn't run any background processes.\n  S=15*DEFAULT_S\n  if HAS_EMACS_NOX == \"yes\":\n    # Wait to checkpoint until emacs finishes reading its initialization files\n    # Under emacs23, it opens /dev/tty directly in a new fd.\n    # To avoid this, consider using emacs --batch -l EMACS-LISTP-CODE ...\n    # ... or else a better pty wrapper to capture emacs output to /dev/tty.\n    runTest(\"emacs\",     1,  [\"env TERM=vt100 /usr/bin/emacs-nox\" +\n                              \" --no-init-file /etc/passwd\"])\n  elif HAS_EMACS == \"yes\":\n    # Wait to checkpoint until emacs finishes reading its initialization files\n    # Under emacs23, it opens /dev/tty directly in a new fd.\n    # To avoid this, consider using emacs --batch -l EMACS-LISTP-CODE ...\n    # ... or else a better pty wrapper to capture emacs output to /dev/tty.\n    runTest(\"emacs\",     1,  [\"env TERM=vt100 /usr/bin/emacs -nw\" +\n                              \" --no-init-file /etc/passwd\"])\n  S=DEFAULT_S\n\nif HAS_SCRIPT == \"yes\":\n  S=7*DEFAULT_S\n  if sys.version_info[0:2] >= (2,6):\n    # NOTE: If 'script' fails, try raising value of S, above, to larger number.\n    #  Arguably, there is a bug in glibc, in that locale-archive can be 100 MB.\n    #  For example, in Fedora 13 (and other recent Red Hat-derived distros?),\n    #  /usr/lib/locale/locale-archive is 100 MB, and yet 'locale -a |wc' shows\n    #  only 8KB of content in ASCII.  The 100 MB of locale-archive condenses\n    #  to 25 MB _per process_ under gzip, but this can be slow at ckpt time.\n    # On some systems, the script test has two `script` processes, while on some\n    # other systems, there is only a single `script` process.\n    runTest(\"script\",    [3,4],  [\"/usr/bin/script -f\" +\n                              \" -c 'bash -c \\\"ls; sleep 30\\\"'\" +\n                              \" dmtcp-test-typescript.tmp\"])\n  os.system(\"rm -f dmtcp-test-typescript.tmp\")\n  S=DEFAULT_S\n\n# SHOULD HAVE screen RUN SOMETHING LIKE:  bash -c ./test/dmtcp1\n# FIXME: Currently fails on dekaksi due to DMTCP not honoring\n#        \"Async-signal-safe functions\" in signal handlers (see man 7 signal)\n# **** Pty SUPPORT IN 2.5 BRANCH IS FLAKY.\n# **** screen NEEDS PTY; DON'T RUN SCREEN TEST UNTIL PTY FIXED.\nif HAS_SCREEN == \"yes\" and False:\n  S=3*DEFAULT_S\n  if sys.version_info[0:2] >= (2,6):\n    runTest(\"screen\",    3,  [\"env TERM=vt100 \" + SCREEN +\n                                \" -c /dev/null -s /bin/sh\"])\n  S=DEFAULT_S\n\nif PTRACE_SUPPORT == \"yes\" and ARM_HOST == \"no\" and \\\n   sys.version_info[0:2] >= (2,6):\n  if HAS_STRACE == \"yes\":\n    S=10*DEFAULT_S\n    runTest(\"strace\",    2,  [\"--ptrace strace test/dmtcp2\"])\n    S=DEFAULT_S\n\n  if HAS_GDB == \"yes\":\n    if uname_p[0:3] == 'arm':\n      print \"On ARM, there is a known issue with DMTCP for gdb-* test.\" + \\\n            \"  Not running it.\"\n    else:\n      os.system(\"echo 'run' > dmtcp-gdbinit.tmp\")\n      S=10*DEFAULT_S\n      runTest(\"gdb\",          2,\n              [\"--ptrace gdb -n -batch -x dmtcp-gdbinit.tmp test/dmtcp1\"])\n\n      runTest(\"gdb-pthread0\", 2,\n              [\"--ptrace gdb -n -batch -x dmtcp-gdbinit.tmp test/dmtcp3\"])\n\n      # These tests currently fail sometimes (if the computation is checkpointed\n      # while a thread is being created). Re-enable them when this issue has\n      # been fixed in the ptrace plugin.\n      #runTest(\"gdb-pthread1\", 2, [\"gdb -n -batch -x dmtcp-gdbinit.tmp test/pthread1\"])\n      #runTest(\"gdb-pthread2\",2, [\"gdb -n -batch -x dmtcp-gdbinit.tmp test/pthread2\"])\n\n      S=DEFAULT_S\n      os.system(\"rm -f dmtcp-gdbinit.tmp\")\n\nif HAS_JAVAC == \"yes\" and HAS_JAVA == \"yes\":\n  S=10*DEFAULT_S\n  os.environ['CLASSPATH'] = './test'\n  runTest(\"java1\",         1,  [\"java -Xmx5M java1\"])\n  del os.environ['CLASSPATH']\n  S=DEFAULT_S\n\nif HAS_CILK == \"yes\":\n  runTest(\"cilk1\",        1,  [\"./test/cilk1 38\"])\n\n# SHOULD HAVE gcl RUN LARGE FACTORIAL OR SOMETHING.\nif HAS_GCL == \"yes\":\n  S=3*DEFAULT_S\n  runTest(\"gcl\",         1,  [GCL])\n  S=DEFAULT_S\n\nif HAS_OPENMP == \"yes\":\n  runTest(\"openmp-1\",         1,  [\"./test/openmp-1\"])\n  runTest(\"openmp-2\",         1,  [\"./test/openmp-2\"])\n\n# SHOULD HAVE matlab RUN LARGE FACTORIAL OR SOMETHING.\nif HAS_MATLAB == \"yes\" and sys.version_info[0:2] >= (2,6):\n  S=10*DEFAULT_S\n  runTest(\"matlab-nodisplay\", 1,  [MATLAB+\" -nodisplay -nojvm\"])\n  S=DEFAULT_S\n\nif HAS_MPICH == \"yes\":\n  runTest(\"mpd\",         1, [MPICH_MPD])\n\n  runTest(\"hellompich-n1\", 4,\n          [MPICH_MPD, MPICH_MPIEXEC + \" -n 1 ./test/hellompich\"])\n\n  runTest(\"hellompich-n2\", 6,\n          [MPICH_MPD, MPICH_MPIEXEC + \" -n 2 ./test/hellompich\"])\n\n  runTest(\"mpdboot\",     1, [MPICH_MPDBOOT+\" -n 1\"])\n\n  #os.system(MPICH_MPDCLEANUP)\n\n\nif HAS_OPENMPI == \"yes\":\n  # Compute:  USES_OPENMPI_ORTED\n  if os.path.isfile('./test/openmpi') and \\\n     0 == os.system(OPENMPI_MPICC +\n                    \" -o ./test_openmpi test/hellompi.c 2>/dev/null 1>&2\"):\n    os.system(\"rm -f ./uses_openmpi_orted\")\n    # The 'sleep 1' below may not fix the race, creating a runaway test_openmpi.\n    os.system('/bin/sh -c \"$OPENMPI_MPIRUN -np 2 ./test_openmpi' +\n              '   2>/dev/null 1>&2 &'\n              ' sleep 1 &&'\n              ' ps auxw | grep $USER | grep -v grep | grep -q orted &&'\n              ' touch ./uses_openmpi_orted\" 2>/dev/null')\n    os.system(\"/bin/kill -9 `ps -eo pid,args | grep test_openmpi |\" +\n              \" sed -e 's%\\([0-9]\\) .*$%\\1%'` 2>/dev/null\")\n    if os.path.exists('./uses_openmpi_orted'):\n      os.system('rm -f ./uses_openmpi_orted')\n      USES_OPENMPI_ORTED = \"yes\"\n    else:\n      USES_OPENMPI_ORTED = \"no\"\n  else:\n    HAS_OPENMPI = \"no\"\n  os.system('rm -f ./test_openmpi')\n\n#Temporarily disabling Open MPI test as it fails on some distros (OpenSUSE 11.4)\nif HAS_OPENMPI == \"yes\":\n  numProcesses = 5 + int(USES_OPENMPI_ORTED == \"yes\")\n  # FIXME: Replace \"[5,6]\" by numProcesses when bug in configure is fixed.\n  # /usr/bin/openmpi does not work if /usr/bin is not also in user's PATH\n  oldPath = \"\"\n  if not os.environ.has_key('PATH'):\n    oldPath = None\n    os.environ['PATH'] = os.path.dirname(OPENMPI_MPIRUN)\n  elif (not re.search(os.path.dirname(OPENMPI_MPIRUN),\n                     os.environ['PATH'])):\n    oldPath = os.environ['PATH']\n    os.environ['PATH'] += \":\" + os.path.dirname(OPENMPI_MPIRUN)\n  S=3*DEFAULT_S\n  runTest(\"openmpi\", [5,6], [OPENMPI_MPIRUN + \" -np 4\" +\n                             \" ./test/openmpi\"])\n  S=DEFAULT_S\n  if oldPath:\n    os.environ['PATH'] = oldPath\n  if oldPath == None:\n    del os.environ['PATH']\n\n# Test DMTCP utilities:\nrunTest(\"nocheckpoint\",        1, [\"./test/nocheckpoint\"])\n\nprint \"== Summary ==\"\nprint \"%s: %d of %d tests passed\" % (socket.gethostname(), stats[0], stats[1])\n\nsaveResultsNMI()\n\ntry:\n  SHUTDOWN()\nexcept CheckFailed, e:\n  print \"Error in SHUTDOWN():\", e.value\nexcept:\n  print \"Error in SHUTDOWN()\"\n\nsys.exit( stats[1] - stats[0] )  # Return code is number of failing tests.\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/test/Makefile.in": "@SET_MAKE@\nLN_S=@LN_S@\nOPENMP_CFLAGS=@OPENMP_CFLAGS@\nOPENMP_CXXFLAGS=@OPENMP_CXXFLAGS@\nCC = @CC@\nM32=@M32@\n# Unfortunately, there is a name clash for 'DEBUG'.\n# --enable-debug intends to set 'DEBUG' in src, but sets it everywhere.\n# Here in 'test', we use 'DEBUG' for one-off tests.  So, we unset 'DEBUG'.\nCFLAGS = @CFLAGS@ -UDEBUG\nCPPFLAGS = @CPPFLAGS@\nCXX = @CXX@\nCXXFLAGS = @CXXFLAGS@\nHAS_JAVA= @HAS_JAVA@\nHAS_JAVAC= @HAS_JAVAC@\nHAS_CMA= @HAS_CMA@\nLDFLAGS = @LDFLAGS@\nMKDIR_P = @MKDIR_P@\nPACKAGE = @PACKAGE@\nPACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\nPACKAGE_NAME = @PACKAGE_NAME@\nPACKAGE_STRING = @PACKAGE_STRING@\nPACKAGE_TARNAME = @PACKAGE_TARNAME@\nPACKAGE_URL = @PACKAGE_URL@\nPACKAGE_VERSION = @PACKAGE_VERSION@\nprefix=@prefix@\nexec_prefix=@exec_prefix@\ndatarootdir=@datarootdir@\nbindir = @bindir@\ndocdir = @docdir@\nincludedir = @includedir@\ninfodir = @infodir@\nlibdir = @libdir@\npkglibdir = $(libdir)/@PACKAGE@\ntop_builddir = @top_builddir@\ntop_srcdir = @top_srcdir@\nsrcdir = @srcdir@\nVPATH = @srcdir@\ntargetdir = $(top_builddir)\n\nifeq (${shell uname -m},aarch64)\nelse\nifeq (${shell uname -m},armv7)\nelse\nifeq (${shell uname -m},armv7l)\nelse\nDO_PTHREAD_ATFORK = yes\nendif\nendif\nendif\n\nDMTCP_INCLUDE=${top_srcdir}/include\n\nCFLAGS += -I${DMTCP_INCLUDE} -DDMTCP -fPIC -g -std=gnu99\nCXXFLAGS += -I${DMTCP_INCLUDE} -DDMTCP -fPIC -g\n\n\nifeq ($(M32),1)\n  targetdir = $(top_builddir)/lib/$(PACKAGE)/32\n  CFLAGS += -m32 -Wa,--32\n  CXXFLAGS += -m32 -Wa,--32\n  LDFLAGS += -m32 -Wl,-m32 -Wl,-melf_i386 -Wa,--32\nelse\n  HAS_READLINE=@HAS_READLINE@\n  READLINE_LIBS=-lreadline -lhistory -lcurses\n  HAS_MPICH=@HAS_MPICH@\n  MPICH_MPICC=@MPICH_MPICC@\n  HAS_OPENMPI=@HAS_OPENMPI@\n  OPENMPI_MPICC=@OPENMPI_MPICC@\n  HAS_CILK=@HAS_CILK@\n  CILKC=@CILKC@\nendif\n\nPWD=$(shell pwd)\n\nTESTS=${notdir ${basename ${shell ls $(srcdir)/*.c $(srcdir)/*.cpp $(srcdir)/*.cilk | grep -v 'hellompi.c'}}} \\\n\t${addsuffix .class,${notdir ${basename ${shell ls $(srcdir)/java*.java}}}} \\\n\thellompich openmpi\n\ntests: $(TESTS)\n\tcd plugin && ${MAKE}\n\t#${MAKE} -C credentials\n\ntidy:\n\trm -f ckpt_*.dmtcp dmtcp_restart_script* \\\n\t  dmtcp-shared-memory.* dmtcp-test-typescript.tmp core*\n\trm -rf ckpt_*\n\tcd plugin && $(MAKE) tidy > /dev/null\n\nclean: tidy\n\trm -f $(TESTS) *.pyc *.so\n\t#${MAKE} -C credentials clean\n\tcd plugin && $(MAKE) clean\n\ndistclean: clean\n\tcd plugin && $(MAKE) distclean\n\t#${MAKE} -C credentials distclean\n\trm -f Makefile\n\nreadline: readline.c\nifeq ($(HAS_READLINE),yes)\n\t$(CC) -o $@ $< $(CFLAGS) $(READLINE_LIBS)\nelse\n\t#$@: required libraries missing, skipping test\nendif\n\nsyscall-tester: syscall-tester.c\n\t$(CC) -o $@ $< $(CFLAGS) -rdynamic\n\ntimer%: timer%.c\n\t$(CC) -o $@ $< $(CFLAGS) -lrt\n\nclock: clock.c\n\t$(CC) -o $@ $< $(CFLAGS) -lrt\n\n# Assume OpenMP exists only if OPENMP_CFLAGS is set.\nopenmp-%: openmp-%.c\nifneq (${OPENMP_CFLAGS},)\n\t-${CC} ${CFLAGS} ${OPENMP_CFLAGS} -o $@ $<\nelse\n\t#$@: This ${CC} does not support OpenMP, skipping test\nendif\n\n# Assume OpenMP exists for C++ only if OPENMP_CXXFLAGS is set.\nopenmp-%: openmp-%.cpp\nifneq (${OPENMP_CXXFLAGS},)\n\t-${CXX} ${CXXFLAGS} ${OPENMP_CXXFLAGS} -o $@ $<\nelse\n\t#$@: This ${CXX} does not support OpenMP, skipping test\nendif\n\nhellompich: hellompi.c\nifeq ($(HAS_MPICH),yes)\n\t- $(MPICH_MPICC) -o $@ $< $(CFLAGS)\nelse\n\t#$@: required libraries missing, skipping test\nendif\n\nopenmpi: hellompi.c\nifeq ($(HAS_OPENMPI),yes)\n\t- $(OPENMPI_MPICC) -o $@ $< $(CFLAGS)\nelse\n\t#$@: required libraries missing, skipping test\nendif\n\nDMTCPPLUGIN_HEADER=$(DMTCP_INCLUDE)/dmtcp.h\n\ndmtcp3: dmtcp3.c\n\t-$(CC) -o $@ $< $(CFLAGS) -lpthread\n\ndmtcp4: dmtcp4.c\n\t-$(CC) -o $@ $< $(CFLAGS) -lpthread\n\ndmtcp5: dmtcp5.c\n\t-$(CC) -o $@ $< $(CFLAGS) -lpthread\n\npthread%: pthread%.c\n\t-$(CC) -o $@ $< $(CFLAGS) -lpthread\n\nmutex%: mutex%.c\n\t-$(CC) -o $@ $< $(CFLAGS) -lpthread\n\n# FIXME:  We should create a test in configure.ac to see if this compiles.\nifeq (${DO_PTHREAD_ATFORK},yes)\nlibpthread_atfork1.so: pthread_atfork1.c\n\t${CC} ${CFLAGS} -shared -fPIC -DLIB -o $@ $<\npthread_atfork1: pthread_atfork1.c libpthread_atfork1.so\n\t${CC} ${CFLAGS} -o $@ $< -L${PWD} -lpthread_atfork1 -lpthread\n\nlibpthread_atfork2.so: pthread_atfork2.c\n\t${CC} ${CFLAGS} -shared -fPIC -DLIB -o $@ $<\npthread_atfork2: pthread_atfork2.c libpthread_atfork2.so\n\t${CC} ${CFLAGS} -o $@ $< -L${PWD} -lpthread_atfork2 -lpthread\nelse\n# FIXME:  On aarch64, gcc-4.9.2, libcg-2.19, pthread_atfork error:\n#    /usr/bin/ld: pthread_atfork: hidden symbol `pthread_atfork' in ...\n#                                 is referenced by DSO\npthread_atfork1: pthread_atfork1.c\n\t@ echo \"FIXME: pthread_atfork is not being compiled for arm/aarch64\"\npthread_atfork2: pthread_atfork2.c\n\t@ echo \"FIXME: pthread_atfork is not being compiled for arm/aarch64\"\nendif\n\nifeq (${HAS_CMA},yes)\ncma: cma.c\n\t$(CC) -o $@ $< $(CFLAGS)\nelse\ncma: cma.c\n\t@ echo \"#cma: Skipping test for cma.  CMA requires Linux 3.2 or later.\"\nendif\n\nposix-mq%: posix-mq%.c\n\t-$(CC) -o $@ $< $(CFLAGS) -lrt\n\ninotify%: inotify%.c\n\t-$(CC) -o $@ $< $(CFLAGS) -lpthread\n\n# dlopen1 will dlopen/dlclose libdlopen-lib[12].so\nlibdlopen-lib1.so: dlopen1.c\n\t${CC} ${CFLAGS} -shared -fPIC  -DLIB1 -o $@ $<\nlibdlopen-lib2.so: dlopen1.c\n\t${CC} ${CFLAGS} -shared -fPIC  -DLIB2 -o $@ $<\ndlopen1: dlopen1.c libdlopen-lib1.so libdlopen-lib2.so\n\t${CC} $(CFLAGS) -o $@ $< -ldl\n\n# dlopen2 will dlopen/dlclose libdlopen-lib[34].so\nlibdlopen-lib3.so: dlopen2.cpp\n\t${CXX} ${CXXFLAGS} -shared -fPIC -DLIB3 -o $@ $<\nlibdlopen-lib4.so: dlopen2.cpp\n\t${CXX} ${CXXFLAGS} -shared -fPIC -DLIB4 -o $@ $<\ndlopen2: dlopen2.cpp libdlopen-lib3.so libdlopen-lib4.so\n\t${CXX} ${CXXFLAGS} -o $@ $< -ldl\n\n%.class: %.java\nifeq ($(HAS_JAVAC),yes)\n\tjavac $< -d .\nelse\n\t#$@: required 'javac' missing, skipping test\nendif\n\ncilk%: cilk%.cilk\nifeq ($(HAS_CILK),yes)\n\t${CILKC} -o $@ $<\nelse\n\t#$@: required 'cilkc' missing, skipping test\nendif\n\n%: %.c\n\t$(CC) -o $@ $< $(CFLAGS)\n\n%: %.cpp\n\t$(CXX) -o $@ $< $(CXXFLAGS)\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/test/plugin/sleep2/sleep2.c": "#include <stdio.h>\n#include <sys/time.h>\n#include \"dmtcp.h\"\n\nvoid print_time() {\n  struct timeval val;\n  gettimeofday(&val, NULL);\n  printf(\"%ld %ld\", (long)val.tv_sec, (long)val.tv_usec);\n}\n\nunsigned int sleep(unsigned int seconds) {\n  printf(\"(sleep2: \"); print_time(); printf(\" ... \");\n  unsigned int result = NEXT_FNC(sleep)(seconds);\n  print_time(); printf(\") \");\n\n  return result;\n}\n\n/* If your code wants to avoid the wrapper above, call this version */\nunsigned int real_sleep(unsigned int seconds) {\n  static unsigned int (*real_fnc)() = NULL; /* Same type signature as sleep */\n  static void *handle = NULL;\n\n  if (! handle)\n    handle = dlopen(\"libc.so.6\", RTLD_NOW);\n  if (! real_fnc)\n    real_fnc = (__typeof__(real_fnc)) dlsym(handle, \"sleep\");\n  return (*real_fnc)(seconds);\n}\n\nvoid dmtcp_event_hook(DmtcpEvent_t event, DmtcpEventData_t *data)\n{\n  static void (*next_fnc)() = NULL;/* Same type signature as this fnc */\n\n  /* NOTE:  See warning in plugin/README about calls to printf here. */\n  switch (event) {\n  case DMTCP_EVENT_WRITE_CKPT:\n    printf(\"*** The plugin %s is being called before checkpointing. ***\\n\",\n\t   __FILE__);\n    real_sleep(1);\n    printf(\"*** Finished calling real_sleep() for 1 second. ***\\n\");\n    break;\n  case DMTCP_EVENT_RESUME:\n    printf(\"*** The plugin %s has now been checkpointed. ***\\n\", __FILE__);\n    break;\n  default:\n    ;\n  }\n\n  /* Call this next line in order to pass DMTCP events to later plugins. */\n  DMTCP_NEXT_EVENT_HOOK(event, data);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/contrib/infiniband/infinibandwrappers.c": "#define _GNU_SOURCE\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include \"dmtcp.h\"\n\n#include \"ibvctx.h\"\n#include \"debug.h\"\n#include <infiniband/verbs.h>\n\nvoid *dlopen(const char *filename, int flag) {\n  if (filename) {\n    if (strstr(filename, \"libibverbs.so\")) {\n      void *handle = NEXT_FNC(dlopen)(\"libdmtcp_infiniband.so\", flag);\n      if (handle == NULL) {\n        fprintf(stderr,\n                \"\\n*** Please either add $DMTCP_PATH$/lib/dmtcp \"\n                \"to LD_LIBRARY_PATH,\\n\"\n                \"*** or else include an absolute pathname \"\n                \"for libdmtcp_infiniband.so\\n\\n\");\n      }\n      return handle;\n    }\n  }\n  return NEXT_FNC(dlopen)(filename, flag);\n}\n\nint ibv_fork_init(void)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"****** WRAPPER for ibv_fork_init ******\\n\");\n  int rslt = _fork_init();\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return rslt;\n}\n\nstruct ibv_device **ibv_get_device_list(int *num_devices)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"****** WRAPPER for ibv_get_device_list\\n\");\n\n  struct ibv_device ** result = _get_device_list(num_devices);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return result;\n}\n\nconst char *ibv_get_device_name(struct ibv_device * dev)\n{\n//  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"****** WRAPPER for ibv_get_device_name\\n\");\n\n  const char * rslt = _get_device_name(dev);\n\n//  DMTCP_PLUGIN_ENABLE_CKPT();\n  return rslt;\n}\n\nstruct ibv_context *ibv_open_device(struct ibv_device *dev)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"******* WRAPPER for begin of ibv_open_device\\n\");\n\n  struct ibv_context * user_copy = _open_device(dev);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return user_copy;\n}\n\nint ibv_query_device(struct ibv_context *context,\n                     struct ibv_device_attr *device_attr)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"******* WRAPPER for begin of ibv_query_device\\n\");\n\n  int rslt = _query_device(context,device_attr);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return rslt;\n}\n\nint ibv_query_pkey(struct ibv_context *context, uint8_t port_num,\n                   int index, uint16_t *pkey)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"******* WRAPPER for begin of ibv_query_pkey\\n\");\n\n  int rslt = _query_pkey(context,port_num, index, pkey);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return rslt;\n}\n\nint ibv_query_gid(struct ibv_context *context, uint8_t port_num,\n                  int index, union ibv_gid *gid)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"******* WRAPPER for begin of ibv_query_gid\\n\");\n\n  int rslt = _query_gid(context,port_num, index, gid);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return rslt;\n}\n\nuint64_t ibv_get_device_guid(struct ibv_device *device)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"******* WRAPPER for ibv_get_device_guid\\n\");\n\n  uint64_t rslt = _get_device_guid(device);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return rslt;\n}\n\nstruct ibv_comp_channel * ibv_create_comp_channel(struct ibv_context *context)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"******* WRAPPER for ibv_create_comp_channel\\n\");\n\n  struct ibv_comp_channel * rslt = _create_comp_channel(context);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return rslt;\n}\n\nint ibv_destroy_comp_channel(struct ibv_comp_channel * channel)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"****** WRAPPER for ibv_destroy_comp_channel\\n\");\n\n  int rslt = _destroy_comp_channel(channel);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return rslt;\n}\n\nstruct ibv_pd *ibv_alloc_pd(struct ibv_context *context)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"******* WRAPPER FOR ibv_alloc_pd\\n\");\n\n  struct ibv_pd * user_copy = _alloc_pd(context);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return user_copy;\n}\n\nstruct ibv_mr *ibv_reg_mr(struct ibv_pd *pd, void *addr,\n                          size_t length,\n                          int access) //int access)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"******** WRAPPER for ibv_reg_mr\\n\");\n\n  struct ibv_mr * user_copy = _reg_mr(pd, addr, length, access);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return user_copy;\n}\n\nstruct ibv_cq *ibv_create_cq(struct ibv_context *context, int cqe,\n                             void *cq_context,\n                             struct ibv_comp_channel *channel,\n                             int comp_vector)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"******** WRAPPER for ibv_create_cq\\n\");\n\n  struct ibv_cq * user_copy = _create_cq(context, cqe, cq_context,\n                                         channel, comp_vector);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return user_copy;\n}\n\nstruct ibv_srq *ibv_create_srq(struct ibv_pd * pd,\n                               struct ibv_srq_init_attr * srq_init_attr)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"******** WRAPPER for ibv_create_srq\\n\");\n\n  struct ibv_srq * user_copy = _create_srq(pd, srq_init_attr);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return user_copy;\n}\n\nint ibv_modify_srq(struct ibv_srq *srq,\n                   struct ibv_srq_attr *srq_attr,\n                   int srq_attr_mask)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"******** WRAPPER for ibv_modify_srq\\n\");\n  int rslt = _modify_srq(srq, srq_attr, srq_attr_mask);\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return rslt;\n}\n\nint ibv_query_srq(struct ibv_srq *srq, struct ibv_srq_attr *srq_attr)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"******** WRAPPER for ibv_query_srq\\n\");\n  int rslt = _query_srq(srq, srq_attr);\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return rslt;\n}\n\nint ibv_destroy_srq(struct ibv_srq *srq)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"******** WRAPPER for ibv_destroy_srq\\n\");\n  int rslt = _destroy_srq(srq);\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return rslt;\n}\n\nstruct ibv_qp *ibv_create_qp(struct ibv_pd *pd,\n                             struct ibv_qp_init_attr *qp_init_attr)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"******** WRAPPER for ibv_create_qp\\n\");\n\n  struct ibv_qp * user_copy = _create_qp(pd, qp_init_attr);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return user_copy;\n}\n\nint ibv_modify_qp(struct ibv_qp *qp, struct ibv_qp_attr *attr,\n                   int attr_mask) //int attr_mask)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"********* WRAPPER for ibv_modify_qp\\n\");\n\n  int rslt = _modify_qp(qp, attr, attr_mask);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return rslt;\n}\n\nint ibv_get_cq_event(struct ibv_comp_channel *channel, struct ibv_cq **cq,\n                     void **cq_context)\n{\n  PDEBUG(\"******** WRAPPER for ibv_get_cq_event\");\n\n  int rslt = _get_cq_event(channel, cq, cq_context);\n\n  return rslt;\n}\n\nint ibv_query_qp(struct ibv_qp * qp, struct ibv_qp_attr * attr,\n                 int attr_mask, struct ibv_qp_init_attr *init_attr)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"******** WRAPPER FOR ibv_query_qp\\n\");\n\n  int rslt = _query_qp(qp, attr, attr_mask, init_attr);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return rslt;\n}\n\nint ibv_get_async_event(struct ibv_context *context,\n                        struct ibv_async_event *event)\n{\n  PDEBUG(\"******** WRAPPER FOR ibv_get_async_event\\n\");\n\n  int rslt = _get_async_event(context, event);\n\n  return rslt;\n}\n\nvoid ibv_ack_async_event(struct ibv_async_event *event)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"******* WRAPPER FOR ibv_ack_async_event\\n\");\n\n  _ack_async_event(event);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n}\n\nint ibv_resize_cq(struct ibv_cq *cq, int cqe)\n{\n\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"****** WRAPPER for ibv_resize_cq\\n\");\n\n  int rslt = _resize_cq(cq,cqe);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return rslt;\n}\n\nint ibv_destroy_cq(struct ibv_cq *cq)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"****** WRAPPER for ibv_destroy_cq\\n\");\n\n  int rslt = _destroy_cq(cq);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return rslt;\n}\n\nint ibv_destroy_qp(struct ibv_qp *qp)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"****** WRAPPER for ibv_destroy qp\\n\");\n\n  int rslt = _destroy_qp(qp);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return rslt;\n}\n\nint ibv_dereg_mr(struct ibv_mr *mr)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"****** WRAPPER for ibv_dereg_mr\\n\");\n\n  int rslt = _dereg_mr(mr);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return rslt;\n}\n\nint ibv_dealloc_pd(struct ibv_pd *pd)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"****** WRAPPER for ibv_dealloc_pd\\n\");\n\n  int rslt = _dealloc_pd(pd);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return rslt;\n}\n\nint ibv_close_device(struct ibv_context *context)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"***** WRAPPER for ibv_close_device\\n\");\n\n  int rslt = _close_device(context);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return rslt;\n}\n\nvoid ibv_free_device_list(struct ibv_device **list)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"********* WRAPPER for ibv_free_device_list\\n\");\n\n  _free_device_list(list);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n}\n\nvoid ibv_ack_cq_events(struct ibv_cq * cq, unsigned int nevents)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"******** WRAPPER for ibv_ack_cq_events\\n\");\n\n  _ack_cq_events(cq, nevents);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n}\n\nstruct ibv_ah * ibv_create_ah(struct ibv_pd *pd, struct ibv_ah_attr *attr){\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PDEBUG(\"******** WRAPPER for ibv_create_ah\\n\");\n\n  struct ibv_ah *rslt = _create_ah(pd, attr);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return rslt;\n}\n\nint ibv_destroy_ah(struct ibv_ah * ah) {\n  int rslt;\n\n  PDEBUG(\"******** WRAPPER for ibv_destroy_ah\\n\");\n  DMTCP_PLUGIN_DISABLE_CKPT();\n\n  rslt = _destroy_ah(ah);\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n\n  return rslt;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/doc/dmtcp_dlsym.txt": "\t\tA Better dlsym() :  Returning the Default Version\n\nThis is intended as one of a series of informal documents to describe\nand partially document some of the more subtle DMTCP data structures\nand algorithms.  These documents are snapshots in time, and they\nmay become somewhat out-of-date over time (and hopefully also refreshed\nto re-sync them with the code again).\n\nThe GNU extension of the POSIX system call, dlsym(), was designed\nto support the concept of wrapper functions around a library,\nby using the pseudo-handle, RTLD_NEXT.  See 'man 3 dlopen' for details.\nIn summary, something like the following example should work:\n  int fnc() {\n    void *handle = dlopen(RTLD_NEXT, RTLD_LAZY);\n    void *fnc_real = dlsym(handle, \"fnc\");\n    int (*fnc_ptr)() = fnc_real;\n    return (*fnc_ptr)();\n  }\n\nThis does work, except in some situations where symbol versioning\nis used.  Symbol versioning is also a GNU extension.  It includes\na concept of the \"default version\", and libraries that don't specify\na particular version will invoke the default version.  Unfortunately,\nin the code above, dlsym will usually return the oldest version instead\nof the default version.  This behavior is not documented in 'man dlsym',\nbut it is easily seen in tests.\n\nDMTCP has implemented DLSYM_DEFAULT(), a replacement for dlsym(),\nwhich will return the _default version_, which is presumably the\ndesired behavior for most users calling this.\n\nThese notes will help to understand the concepts and background for\nthe implementations of src/dmtcp_dlsym.cpp.\n\nSUGGESTED READING:\n  http://refspecs.linuxfoundation.org/LSB_3.2.0/LSB-Core-generic/LSB-Core-generic/symversion.html#SYMRESOLUTION\n\nEXPLANATION:\nThe \"default version\" doesn't seem to be a concept explicitly defined\nin the standard.  But in practice, references to the \"default version\"\nrefer to the _unique_ symbol version, which is not a hidden symbol.\nSo, we stop to define \"hidden symbol\".\n\nA hidden symbol is a symbol in the lookup table for which the \"hidden\nbit\" is set.  The intention was that only one symbol version (the\ndefault version) should be visible to linkers that don't know about\nsymbol versioning.  All other versions should be hidden.\n\nSo, a software package links to the \"default version\", unless it\nexplicitly asks for a specific hidden version.  The function dlsym()\nunfortunately usually links to the oldest version, instead of the\n\nIt depends on each\nsoftware package to define at most one non-hidden symbol.\n newest version\n(the one on which no other version depends; and the versioning standard\ndefines dependencies among version numbers).\ndefault version.  GNU provides the alternative function, dlvsym,\nwhich will link to a specific version of a symbol.  But then to link\nto the default version, a programmer must first know the name (or\nversion number) of the default version.  There is no GNU extension\nto automatically discover the default version number.  Further,\ndifferent Linux distros may be using different default versions.\nSo, the default version number is not a universally fixed value.\n\n====\nBACKGROUND DETAILS OF THE ELF LINKER:\n\nThe rest of this note explains how the macro DLSYM_DEFAULT()\n(and the function dlsym_default_internal()) find the default symbol.\nThis is done in src/dmtcp_dlsym.cpp.\n\nThe versym ELF section defines the symbol version strings of that file (and it\nstates if a symbol version depends on a different one).  The versym ELF\nsection is an extension of the dynsym (Dynamic Symbol) section.  It is\nthe same length as the dynsym version.  The dynsym section is an array\nof structs and the versym section is an array of \"version indexes\".\nThus it acts as an extra field in the dynsym section.  (This way,\nversioning can stay hidden from linkers that don't know about versioning.)\n\nThe dynsym section is itself a subset of the symbol section, including only\nthose symbols needed for dynamic linking.  That's why \"nm -D\" may\nshow symbols when \"nm -S\" fails (when the object was stripped).\nA stripped object must keep its dynamic symbols or it can never be\nused for dynamic linking.\n\nIf the high order bit (bit number 15) of the version symbol is set, the\nobject cannot be used and the static linker shall ignore the symbol's\npresence in the object.  This bit is sometimes known as a \"hidden bit\",\nbecause an outside object can link to it only if it explicitly requests\nthe specific version string.  Hence, if there is only one version\nof a symbol without a hidden bit, then that version is the default version\nfor that symbol.\n\nIf an unversioned symbol reference is linked with an object that has\nversioned symbols, then it is only allowed to link with the version\nindex 1 (aka \"GLOBAL\", used for unversioned symbols) or version index\n2 (typically defined within an object file as the oldest version string of\nthat file).  These two versions are known as the base definition.  (An\nunversioned symbol will have index 1 for its base definition, while\na versioned symbol will have index 2 for its base definition.)\nThe above are the rules for the \"static linker\" (linking done at load-time).\n\nIn calls to dlopen, the \"dynamic linker\" is called.  If the dynamic linker\ndoes not find a base definition for a symbol, and if only one version\nis defined, it can link to that version.  (I'm not sure if that's allowed\nthen the one defined version has the hidden bit set in the versym entry.\n\n====\nIMPLEMENTATION DETAILS:\n\nStrings can be compared using strcmp.  But one can also use the\nhash ELF section for symbol names.  This entry specifies the hash function\nto use:\n  http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#hash\n\n====\nThe following exist:\n  http://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/elf-generic.html\n  http://refspecs.linuxbase.org/LSB_3.1.1/\n\nBut the prior Sun/Oracle documents are sometimes more readable:\n  http://docs.oracle.com/cd/E19683-01/817-1983/6mhm6r4fj/index.html#chapter6-79797\n\n====\nThe following are very rough notes taken in writing the implementation.\nNo promises about readability:\n\nThe base definition is for the filename (VER_FLG_BASE in vd_flags)!\n\nShould read the version definition (DT_VERDEF) section.\nThat has a series of ElfXX_Verdef structs\nEach one has a vd_cnt of the number of versions in the vd_aux,\n  and a vd_aux entry with\n    vda_name:\n      The string table offset to a null-terminated string, giving the name of the version definition\n    and vda_next for the offset to a dependency of this versioned symbol\n\t(for dependencies of this version definition:  each dependency\n\t will have its own version definition)\n    The first vda definition is the version name for this entry (each verdef\n\tentry may be for a different version of same symbol)\n  and a vd_next pointing to the next ElfXX_Verdef entry\n  and a vd_ndx index that uniquely associates it with a versym entry of the\n\tsame index.  (This just a unique index which matches the _value_\n\tin the versym array.  It is not an array index.  The versym array\n\tis meant to add an extra field into the symtab section (array of\n\tstructs).  The field is a unique index corresponding to vd_ndx for\n\tsome version def.  Since the versym section and symtab section are\n\tthe same length, you can also use the same array index for both.)\n\nThe versym section has a number of symbols the same as in the symbols section.\n  It's an array of ElfXX_Versym half-words.  If it's VER_NDX_GLOBAL (= 1),\n  then it's the base definition (default version); Otherwise, it's a\n  user-defined version definition (for constant greater than 1)\n  (Could it be that number 2 is for default version and number 1 for base?)\n  Maybe user must specify higher integer for each extra version, so that\n  this acts as a kind of numeric index for the version name??\n  And version references start where version definitions leave off.\n\nThis link was also useful for documenting the ELF symbol table.\nhttp://docs.oracle.com/cd/E19683-01/817-1983/6mhm6r4fj/index.html#chapter6-79797\nThe SYMTAB section has a st_name which is an index into the symbol string table.\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/doc/src/plugin-tutorial.tex": "% DMTCP-Internal plugins:  make sure restart/resume operates after event:\n%   RESTART/RESUME/REFILL/REGISTER\\_NAME\\_SERVICE\\_DATA/SEND\\_QUERIES\n% Do we install distro packages to use /usr/include/dmtcp/plugin.h for compatibility?\n% For KVM plugin, change MTCP break issue to be warning (not error)\n% KVM plugin:  QEMU complains about negative value in signalfd\n\n% TODO:  --with-icc\n% TODO:  --vnc  (for dmtcp_launch)\n% TODO:  test suite from Joshua Louie (dlopen prior to main; epoll taking too long)\n\n\\documentclass{article}\n\\usepackage{fullpage}\n\\usepackage[hidelinks]{hyperref}\n\n\\title{Tutorial for DMTCP Plugins}\n\\author{}\n\\date{March, 2015}\n\n\\begin{document}\n\n\\maketitle\n\\tableofcontents\n\n\\section{Introduction}\n\nPlugins enable one to modify the behavior of DMTCP.  Two of the most\ncommon uses of plugins are:\n\\begin{enumerate}\n\\item to execute an additional action at the time of checkpoint, resume,\n\tor restart.\n\\item to add a wrapper function around a call to a library function (including\n\twrappers around system calls).\n\\end{enumerate}\n\nPlugins are used for a variety of purposes. The {\\tt DMTCP\\_ROOT/contrib}\ndirectory contains packages that users and developers have contributed\nto be optionally loaded into DMTCP.\n\n\n% POSSIBLE LIST:\n% Torque, Condor, KVM/QEMU, record-replay, logging, restart on modified\n% filesystem/new host/modified uid/etc., integration w/ Python for\n% Python to call ckpt, ckpt over network to remote file\n\nPlugin code is expressive, while requiring only a modest number of lines\nof code.  The plugins in the contrib directory vary in size from\n400 lines to 3000 lines of code.\n\nBeginning with DMTCP version~2.0, much of DMTCP itself is also now\na plugin.  In this new design, the core DMTCP code is responsible\nprimarily for copying all of user space memory to a checkpoint\nimage file.  The remaining functions of DMTCP are handled by plugins,\nfound in {\\tt DMTCP\\_ROOT/plugin}.  Each plugin abstracts the essentials of a\ndifferent subsystem of the operating system and modifies its behavior\nto accommodate checkpoint and restart.  Some of the subsystems for\nwhich plugins have been written are: virtualization of process\nand thread ids; files(open/close/dup/fopen/fclose/mmap/pty);\nevents (eventfd/epoll/poll/inotify/signalfd);\nSystem~V IPC constructs (shmget/semget/msgget); TCP/IP\nsockets (socket/connect/bind/listen/accept); and timers\n(timer\\_create/clock\\_gettime).  (The indicated system calls are examples\nonly and not all-inclusive.)\n\n\\section{Anatomy of a plugin}\n\nA plugin modifies the behavior of either DMTCP or a target application,\nthrough three primary mechanisms, plus virtualization of ids.\n\\begin{description}\n\\item[Wrapper functions:]  One declares a wrapper function with the same\n\tname as an existing library function (including system calls in\n\tthe run-time library).  The wrapper function can execute some\n\tprolog code, pass control to the ``real'' function,\n\tand then execute some epilog code.  Several plugins can wrap\n\tthe same function in a nested manner.  One can also omit\n\tpassing control to the ``real'' function, in order to shadow\n\tthat function with an alternate behavior.\n\\item[Events:]  It is frequently useful to execute additional code\n\tat the time of checkpoint, or resume, or restart.  Plugins\n\tprovide hook functions\tto be called during these three events\n\tand numerous other important events in the life of a process.\n\\item[Coordinated checkpoint of distributed processes:]  DMTCP transparently\n\tcheckpoints distributed computations across many nodes.\n\tAt the time of checkpoint or restart, it may be necessary to\n\tcoordinate information among the distributed processes.  For example,\n\tat restart time, an internal plugin of DMTCP allows the newly\n\tre-created processes to ``talk'' to their peers to discover the\n\tnew network addresses of their peers.  This is important since\n\ta distributed computation may be restarted on a different cluster\n\tthan its original one.\n\\item[Virtualization of ids:]  Ids (process id, timer id, sysv ipc id, etc.)\n\tare assigned by the kernel, by a peer process, and by remote processes.\n\tUpon restart, the external agent may wish to assign a different\n\tid than the one assigned prior to checkpoint.  Techniques for\n\tvirtualization of ids are described in\n        Section~\\ref{sec:virtualization}.\n\\end{description}\n\n\\section{Writing Plugins}\n\n\\subsection{Invoking a plugin}\n\nPlugins are just dynamic run-time libraries (.so files).\n\\hfill\\break\n\\medskip\\noindent\n  \\hspace{0.3truein} {\\tt gcc -shared -fPIC -IDMTCP\\_ROOT/dmtcp/include\n                         -o PLUGIN1.so PLUGIN1.c}\n\\medskip\n\nThey are invoked at the beginning of a DMTCP computation\nas command-line options:\n\\hfill\\break\n\\medskip\\noindent\n  \\hspace{0.3truein} {\\tt dmtcp\\_launch --with-plugin PLUGIN1.so:PLUGIN2.so\n\t\t\t  myapp}\n\\medskip\n\nNote that one can invoke multiple plugins as a colon-separated list.\nOne should either specify a full path for each plugin (each .so~library),\nor else to define LD\\_LIBRARY\\_PATH to include your own plugin directory.\n\n\\subsection{The plugin mechanisms}\n\nThe mechanisms of plugins are most easily described through examples.\nThis tutorial will rely on the examples in {\\tt DMTCP\\_ROOT/test/plugin}.\nTo get a feeling for the plugins, one can ``cd'' into each of the\nsubdirectories and execute: ``{\\tt make check}''.\n\n\\subsubsection{Plugin events}\n\nFor context, please scan the code of {\\tt DMTCP\\_ROOT/plugin/example/example.c}.\nExecuting ``{\\tt make check}'' will demonstrate the intended behavior.\nPlugin events are handled by including the function {\\tt dmtcp\\_event\\_hook}.\nWhen a DMTCP plugin event occurs, DMTCP will call the\nfunction {\\tt dmtcp\\_event\\_hook} for each plugin.\nThis function is required only if the plugin will handle plugin events.\nSee Appendix~A for further details.\n\n{\\tt\n\\begin{verbatim}\nvoid dmtcp_event_hook(DmtcpEvent_t event, DmtcpEventData_t *data)\n{\n  switch (event) {\n  case DMTCP_EVENT_WRITE_CKPT:\n    printf(\"\\n*** The plugin is being called before checkpointing. ***\\n\");\n    break;\n  case DMTCP_EVENT_RESUME:\n    printf(\"*** Resume: the application has now been checkpointed. ***\\n\");\n    break;\n  case DMTCP_EVENT_RESTART:\n    printf(\"*** The application is now being restarted. ***\\n\");\n    break;\n  ...\n  default:\n    break;\n  }\n  DMTCP_NEXT_EVENT_HOOK(event, data);\n}\n\\end{verbatim}\n}\n\n\n% Plugin events:\n%\n% *** The model for events:  When a DMTCP event occurs, DMTCP calls ROUTINE in\n% each plugin, in the order that the plugins were loaded, offering each plugin\n% a chance to handle the event.  If ROUTINE is not defined in a plugin, DMTCP\n% skips calling that plugin.  When ROUTINE is called, it is given the unique\n% event id, and a switch statement can decide whether to take any special action.\n% If no action is taken, ROUTINE returns XXX, and the next plugin is offered\n% a chance to handle the event.  If a plugin does handle the event, a typical\n% user code fragment will:\n% A.  optionally carry out any pre-processing steps\n% B.  optionally ask DMTCP to invoke the next event handler\n% C.  optionally carry out any post-processing steps\n%\n% If all three steps are invoked, this effectively creates a wrapper function\n% around any later plugins that handle the same event.  If step B is omitted,\n% no further plugins will be offered the opportunity to handle the event.\n\n\\subsubsection{Plugin wrapper functions}\n\\label{sec:wrappers}\n\nIn its simplest form, a wrapper function can be written as follows:\n\n{\\tt\n\\begin{verbatim}\nunsigned int sleep(unsigned int seconds) {\n  static unsigned int (*next_fnc)() = NULL; /* Same type signature as sleep */\n  struct timeval oldtv, tv;\n  gettimeofday(&oldtv, NULL);\n  time_t secs = val.tv_sec;\n  printf(\"sleep1: \"); print_time(); printf(\" ... \");\n  unsigned int result = NEXT_FNC(sleep)(seconds);\n  gettimeofday(&tv, NULL);\n  printf(\"Time elapsed:  %f\\n\",\n          (1e6*(val.tv_sec-oldval.tv_sec) + 1.0*(val.tv_usec-oldval.tv_usec)) / 1e6);\n  print_time(); printf(\"\\n\");\n\n  return result;\n}\n\\end{verbatim}\n}\n\nIn the above example, we could also shadow the standard ``sleep'' function\nby our own implementation, if we omit the call to ``{NEXT\\_FNC}''.\n\n\\noindent\nTo see a related example, try:\n\\hfill\\break\n\\medskip\\noindent\n  \\hspace{0.3truein} {\\tt cd DMTCP\\_ROOT/test/plugin/sleep1; make check}\n\\medskip\n\n\\noindent\nWrapper functions from distinct plugins can be nested.  For a nesting\nof plugin sleep2 around sleep1, do:\n\\hfill\\break\n\\medskip\\noindent\n  \\hspace{0.3truein} {\\tt cd DMTCP\\_ROOT/test/plugin; make; cd sleep2; make check}\n\\medskip\n\nIf one adds a wrapper around a function from a library other than libc.so\n(e.g., libglx.so), it is best to dynamically link to that additional library:\n\\hfill\\break\n\\medskip\\noindent\n  \\hspace{0.3truein} {\\tt gcc ...  -o PLUGIN1.so PLUGIN1.c -lglx.so}\n\\medskip\n\n\\subsubsection{Plugin coordination among multiple or distributed processes}\n\\label{sec:publishSubscribe}\n\nIt is often the case that an external agent will assign a particular\ninitial id to your process, but later assign a different id on restart.\nEach process must re-discover its peers at restart time, without knowing\nthe pre-checkpoint ids.\n\nDMTCP provides a ``Publish/Subscribe'' feature to enable communication among\npeer processes. Two plugin events allow user\nplugins to discover peers and pass information among peers.\nThe two events are:  {\\tt DMTCP\\_EVENT\\_REGISTER\\_NAME\\_SERVICE\\_DATA}\nand {\\tt DMTCP\\_EVENT\\_SEND\\_QUERIES}.  DMTCP guarantees to provide a global\nbarrier between the two events.\n\nAn example of how to use the Publish/Subscribe feature is contained in\n{\\tt DMTCP\\_ROOT/test/plugin/example-db}~.  The explanation below is best\nunderstood in conjunction with reading that example.\n\nA plugin processing {\\tt DMTCP\\_EVENT\\_REGISTER\\_NAME\\_SERVICE\\_DATA} should invoke: \\\\\nint dmtcp\\_send\\_key\\_val\\_pair\\_to\\_coordinator(const void *key,\n                                                   size\\_t key\\_len, \\\n                                                   const void *val, \\\n                                                   size\\_t val\\_len).\n\nA plugin processing {\\tt DMTCP\\_EVENT\\_SEND\\_QUERIES} should invoke: \\\\\nint dmtcp\\_send\\_query\\_to\\_coordinator(const void *key, size\\_t key\\_len,\n                                            void *val, size\\_t *val\\_len).\n\n\\subsubsection{Using plugins to virtualize ids and other names}\n\\label{sec:virtualization}\n\nOften an id or name will change between checkpoint and restart.\nFor example, on restart, the real pid of a process will change\nfrom its pid prior to checkpoint.  Some DMTCP internal plugins\nmaintain a translation table in order to translate\nbetween a virtualized id passed to the user code and a real id\nmaintained inside the kernel.  The ability to maintain this\ntranslation table can also be used within third-party plugins.\nFor an example of adding virtualization to a plugin, see the plugin\nin {\\tt src/plugin/timer}.\n\nIn some less common cases, it can happen that a virtualized id is passed\nto a library function by the target application.  Yet, that same library\nfunction may be passed a real id by a second function from within the\nsame library.  In these cases, it is the responsibility of the\nplugin implementor to choose a scheme that allows the first library\nfunction to distinguish whether its argument is a virtual id (passed\nfrom the target application) or a real id (passed from within the same\nlibrary).\n\n\n% \\section{Caveats}\n%\n% CAVEATS:\n% Does your plugin break normal DMTCP?  to test this, modify DMTCP, and copy your\n% plugin into {\\tt DMTCP\\_ROOT/lib}, and then run 'make check' for DMTCP as usual.\n%\n% SHARED MEMORY REGIONS:\n% If two or more processes share a memory region, then the plugin writer must\n% be clear on whether DMTCP or the plugin has responsibility for restoring\n% the shared memory region.  Currently, EXPLAIN ....\n%\n% Virtualizing long-lived objects:  HOWTO\n%\n% INTERACTION OF MULTIPLE PLUGINS:\n%     For simple plugins, this issue can be ignored.  But if your plugin has\n% tables with long-lived data, other wrappers may create additional\n% instantiations.  % It is reasonable for them to do this for temporary data\n% structures at % the time of checkpoint or at the time of restart.  But\n% normally, such an % object, created when the checkpoint event occurs, should\n% be destroyed before % creating the actual checkpoint image.  Similarly, at\n% restart time, if new % instances are created, they should be destroyed before\n% returning control to the user threads.\n%     It is polite for a plugin to check the above restrictions.  If it is\n% violated, the plugin should print a warning about this.  This will help\n% others, who % accidentally create long-lived objects at checkpoint- or\n% restart-time, without intending to.  If the other plugin intends this unusual\n% behavior, one can add a whitelist feature for other plugings to declare such\n% intentions.\n%     This small effort will provide a well-defined protocol that limits the\n% interaction between distinct plugins.  Your effort helps others to debug their\n% plugins, and a similar effort on their part will help you to debug your own\n% plugin.\n%\n% Putting a printf inside a plugin at the time of checkpoint is dangerous.  This\n% is because printf indirectly invokes a lock to prevent two threads from\n% printing simultaneously.  This causes the checkpoint thread to call a printf.\n% {\\bf See README in test/plugin.}\n%\n% At checkpoint time, the DMTCP user thread will stop on that same lock.  This\n% causes the two threads to deadlock.\n%\n% This use of conflicting locks is a bug in DMTCP as of DMTCP-2.0.  It will\n% be fixed in the future version of DMTCP.\n\n\n\\section{Application-Initiated Checkpoints}\n\nApplication-initiated checkpoints are even simpler than full-featured\nplugins.  In the simplest form, the following code can be executed both\nwith {\\tt dmtcp\\_launch} and without.:\n\n{\\tt\n\\begin{verbatim}\n#include <stdio.h>\n#include \"dmtcp.h\"\nint main() {\n  if (dmtcpCheckpoint() == DMTCP_NOT_PRESENT) {\n    printf(\"dmtcpcheckpoint:  DMTCP not present.  No checkpoint is taken.\\n\");\n  }\n  return 0;\n}\n\\end{verbatim}\n}\n\nFor this program to be aware of DMTCP, it must be compiled with -fPIC and -ldl~:\n\\hfill\\break\n\\medskip\\noindent\n  \\hspace{0.3truein} {\\tt gcc -fPIC -IDMTCP\\_ROOT/dmtcp/include -o myapp\n                      myapp.c -ldl}\n\\medskip\n\nThe most useful functions are:\n\\begin{list}{}{\\leftmargin=3em \\itemindent=-2em}\n\\item\n  {\\tt int dmtcp\\_is\\_enabled()} --- returns 1 when running with DMTCP;\n                                     0 otherwise.\n\\item\n  {\\tt int dmtcp\\_checkpoint()} --- returns DMTCP\\_AFTER\\_CHECKPOINT,\n                                 DMTCP\\_AFTER\\_RESTART, or DMTCP\\_NOT\\_PRESENT.\n\\item\n  {\\tt int dmtcp\\_disable\\_ckpt()} --- DMTCP will block any\n\t\t\t\t checkpoint requests.\n\\item\n  {\\tt int dmtcp\\_enable\\_ckpt()} --- DMTCP will execute any blocked\n                checkpoint requests, and will permit new checkpoint requests.\n\\end{list}\n\nThe last two functions follow the common pattern of returning 0 on success\nand {\\tt DMTCP\\_NOT\\_PRESENT} if DMTCP is not present.\nSee the subdirectories\n{\\tt DMTCP\\_ROOT/test/plugin/applic-initiated-ckpt}\nand\n{\\tt DMTCP\\_ROOT/test/plugin/applic-delayed-ckpt}, where one can execute\n{\\tt make check} for a live demonstration.\n\nFor advanced users, the file {\\tt DMTCP\\_ROOT/dmtcp/include/dmtcp.h}\nalso defines some additional functions not documented here:\\\\\n~~{\\tt dmtcp\\_install\\_hooks}\\\\\n~~{\\tt dmtcp\\_get\\_coordinator\\_status}\\\\\n~~{\\tt dmtcp\\_get\\_local\\_status}\\\\\n~~{\\tt dmtcp\\_get\\_uniquepid\\_str}\\\\\n~~{\\tt dmtcp\\_get\\_ckpt\\_filename}\\\\\nand many others in {\\tt dmtcp.h}.\n\n\\appendix\n\\section{Appendix:  Plugin Manual}\n\\subsection{Plugin events}\n% \\addcontentsline{toc}{chapter}{Appendix A:  Plugin Events}\n\n\\subsubsection{dmtcp\\_event\\_hook}\n\nIn order to handle DMTCP plugin events, a plugin must\ndefine {\\tt dmtcp\\_event\\_hook}.\n\n\\begin{verbatim}\nNAME\n       dmtcp_event_hook - Handle plugin events for this plugin\n\nSYNOPSIS\n       #include \"dmtcp/plugin.h\"\n\n       void dmtcp_event_hook(DmtcpEvent_t event, DmtcpEventData_t *data)\n\nDESCRIPTION\n       When a plugin event occurs, DMTCP will look for the symbol\n       dmtcp_event_hook in each plugin library.  If the symbol is found,\n       that function will be called for the given plugin library.  DMTCP\n       guarantees only to invoke the first such plugin library found in\n       library search order.  Occurrences of dmtcp_event_hook in later\n       plugin libraries will be called only if each previous function\n       had invoked DMTCP_NEXT_EVENT_HOOK.  The argument, <event>, will be\n       bound to the event being declared by DMTCP.  The argument, <data>,\n       is required only for certain events.  See the following section,\n       ``Plugin Events'' for a list of all events.\n\nSEE ALSO\n       DMTCP_NEXT_EVENT_HOOK\n\\end{verbatim}\n\n\\subsubsection{DMTCP\\_NEXT\\_EVENT\\_HOOK}\n\nA typical definition of {\\tt dmtcp\\_event\\_hook} will invoke\n{\\tt DMTCP\\_NEXT\\_EVENT\\_HOOK}.\n\n\\begin{verbatim}\nNAME\n       DMTCP_NEXT_EVENT_HOOK - call dmtcp_event_hook in next plugin library\n\nSYNOPSIS\n       #include \"dmtcp/plugin.h\"\n\n       void DMTCP_NEXT_EVENT_HOOK(event, data)\n\nDESCRIPTION\n       This function must be invoked from within a plugin function library\n       called dmtcp_event_hook.  The arguments <event> and <data> should\n       normally be the same arguments passed to dmtcp_event_hook.\n\n       DMTCP_NEXT_EVENT_HOOK may be called zero or one times.  If invoked zero\n       times, no further plugin libraries will be called to handle events.\n       The behavior is undefined  if DMTCP_NEXT_EVENT_HOOK is invoked more than\n       once.  The typical usage of this function is to create a wrapper around\n       the handling of the same event by later plugins.\n\nSEE ALSO\n       dmtcp_event_hook\n\\end{verbatim}\n\nThere are examples of compiling a plugin in the examples in {\\tt\nDMTCP\\_ROOT/test/plugin}.\n\n\\subsubsection{Event Names}\n\nThe rest of this section defines plugin events.\nThe complete list of plugin events is always contained in\n{\\tt DMTCP\\_ROOT/dmtcp/include/dmtcp.h}~.\n\nDMTCP guarantees to call the dmtcp\\_event\\_hook function of the plugin\nwhen the specified event occurs.\n% If an event is thread-specific, DMTCP guarantees to call\n% dmtcp\\_event\\_hook within the same thread.\n\nPlugins that pass significant data through the data parameter\nare marked with an asterisk: {}$^*$.\nMost plugin events do not pass data through the data parameter.\n\nNote that the events \\\\\n   RESTART / RESUME / REFILL / REGISTER\\_NAME\\_SERVICE\\_DATA / SEND\\_QUERIES \\\\\nshould all be processed after the call to DMTCP\\_NEXT\\_EVENT\\_HOOK() in\norder to guarantee that the internal DMTCP plugins have first restored full\nfunctionality.\n\n\\itemsep0pt\n\\subsubsection*{Checkpoint-Restart}\n\\begin{list}{}{\\leftmargin=3em \\itemindent=-2em}\n\\item\n  DMTCP\\_EVENT\\_WRITE\\_CKPT --- Invoked at final barrier before writing checkpoint\n\\item\n  DMTCP\\_EVENT\\_RESTART --- Invoked at first barrier during restart of new process\n\\item\n  DMTCP\\_EVENT\\_RESUME --- Invoked at first barrier during resume following checkpoint\n\\end{list}\n\n\\subsubsection*{Coordination of Multiple or Distributed Processes during Restart\n\t(see Appendix A.2.~Publish/Subscribe)}\n\\begin{list}{}{\\leftmargin=3em \\itemindent=-2em}\n\\item\n  DMTCP\\_EVENT\\_REGISTER\\_NAME\\_SERVICE\\_DATA$^*$ restart/resume\n\\item\n  DMTCP\\_EVENT\\_SEND\\_QUERIES$^*$ restart/resume\n\\end{list}\n\n\\subsubsection*{WARNING:  EXPERTS ONLY FOR REMAINING EVENTS}\n\\subsubsection*{Init/Fork/Exec/Exit}\n\\begin{list}{}{\\leftmargin=3em \\itemindent=-2em}\n\\item\n  DMTCP\\_EVENT\\_INIT --- Invoked before main (in both the original program\nand any new program called via exec)\n\\item\n  DMTCP\\_EVENT\\_EXIT --- Invoked on call to exit/\\_exit/\\_Exit {\\bf return from main?};\n\\item\n  DMTCP\\_EVENT\\_PRE\\_EXEC --- Invoked prior to call to exec\n\\item\n  DMTCP\\_EVENT\\_POST\\_EXEC --- Invoked before DMTCP\\_EVENT\\_INIT in new program\n\\item\n  DMTCP\\_EVENT\\_ATFORK\\_PREPARE --- Invoked before fork (see POSIX pthread\\_atfork)\n\\item\n  DMTCP\\_EVENT\\_ATFORK\\_PARENT --- Invoked after fork by parent (see POSIX\n    pthread\\_atfork)\n\\item\n  DMTCP\\_EVENT\\_ATFORK\\_CHILD --- Invoked after fork by child (see POSIX\n    pthread\\_atfork) \\\\\n\\end{list}\n\n\\subsubsection*{Barriers (finer-grained control during checkpoint-restart)}\n\\begin{list}{}{\\leftmargin=3em \\itemindent=-2em}\n\\item\n  DMTCP\\_EVENT\\_WAIT\\_FOR\\_SUSPEND\\_MSG --- Invoked at barrier during\ncoordinated checkpoint\n\\item\n  DMTCP\\_EVENT\\_THREADS\\_SUSPEND --- Invoked at barrier during coordinated checkpoint\n\\item\n  DMTCP\\_EVENT\\_LEADER\\_ELECTION --- Invoked at barrier during coordinated checkpoint\n\\item\n  DMTCP\\_EVENT\\_DRAIN --- Invoked at barrier during coordinated checkpoint\n\\item\n  DMTCP\\_EVENT\\_WRITE\\_CKPT --- Invoked at final barrier before writing checkpoint\n\\item\n  DMTCP\\_EVENT\\_REFILL --- Invoked at first barrier during resume/restart of new process\n\\end{list}\n\n\\subsubsection*{Threads}\n\\begin{list}{}{\\leftmargin=3em \\itemindent=-2em}\n\\item\n  DMTCP\\_EVENT\\_THREADS\\_SUSPEND --- Invoked within checkpoint thread\n\twhen all user threads have been suspended\n\\item\n  DMTCP\\_EVENT\\_THREADS\\_RESUME --- Invoked within checkpoint thread before\n\tany user threads are resumed. \\\\\n\tFor debugging, consider calling the following code for this\n        event:  {\\tt static int x = 1; while(x);}\n\\item\n  DMTCP\\_EVENT\\_PRE\\_SUSPEND\\_USER\\_THREAD --- Each user thread invokes this prior\n\tto being suspended for a checkpoint\n\\item\n  DMTCP\\_EVENT\\_RESUME\\_USER\\_THREAD --- Each user thread invokes this immediately\n\tafter a resume or restart ({\\tt isRestart()} available to plugin)\n% \\item\n%   {\\bf should we have separate DMTCP\\_EVENT\\_RESTART\\_USER\\_THREAD?\n%     --- I vote yes.}\n\\item\n  DMTCP\\_EVENT\\_THREAD\\_START --- Invoked before start function given by clone\n\\item\n  DMTCP\\_EVENT\\_THREAD\\_CREATED --- Invoked within parent thread when clone call returns  (like parent for fork)\n\\item\n  DMTCP\\_EVENT\\_PTHREAD\\_START --- Invoked before start function given by pthread\\_created\n\\item\n  DMTCP\\_EVENT\\_PTHREAD\\_EXIT --- Invoked before call to pthread\\_exit\n\\item\n  DMTCP\\_EVENT\\_PTHREAD\\_RETURN --- Invoked in child thread when thread start function of pthread\\_create returns\n\\item\n\\end{list}\n\n\\subsection{Publish/Subscribe}\n% \\addcontentsline({toc}{chapter}{Appendix B:  Publish/Subscribe}\n\nSection~\\ref{sec:publishSubscribe} provides an explanation of the\nPublish/Subscribe feature for coordination among peer processes at resume-\nor restart-time.  An example of how to use the Publish/Subscribe feature\nis contained in {\\tt DMTCP\\_ROOT/test/plugin/example-db}~.\n\nThe primary events and functions used in this feature are:\n\n\\noindent\n{\\tt DMTCP\\_EVENT\\_REGISTER\\_NAME\\_SERVICE\\_DATA} \\\\\n\\hbox{\\ \\ }\nint dmtcp\\_send\\_key\\_val\\_pair\\_to\\_coordinator(const void *key,\n                                                   size\\_t key\\_len,\n                                                   const void *val,\n                                                   size\\_t val\\_len) \\\\\n{\\tt DMTCP\\_EVENT\\_SEND\\_QUERIES} \\\\\n\\hbox{\\ \\ }\nint dmtcp\\_send\\_query\\_to\\_coordinator(const void *key, size\\_t key\\_len,\n                                            void *val, size\\_t *val\\_len)\n\n\\subsection{Wrapper functions}\n% \\addcontentsline{toc}{chapter}{Appendix C:  Wrapper Functions}\n\nFor a description of including wrapper functions in a plugin, see\nSection~\\ref{sec:wrappers}.\n\n\\subsection{Miscellaneous utility functions}\n\nNumerous DMTCP utility functions are provided that can be called from within\ndmtcp\\_event\\_hook().  For a complete list, see\n{\\tt DMTCP\\_ROOT/dmtcp/include/dmtcp/plugin.h}~.\nThe utility functions are still under active development, and may change\nin small ways.  Some of the more commonly used utility functions follow.\nFunctions that return ``char *'' will not allocate memory, but instead will\nreturn a pointer to a canonical string, which should not be changed.\n{\\tt\n\\begin{verbatim}\nvoid dmtcp_get_local_ip_addr(struct in_addr *in);\nconst char* dmtcp_get_tmpdir(); /* given by --tmpdir, or DMTCP_TMPDIR, or TMPDIR */\nconst char* dmtcp_get_ckpt_dir();\n   /* given by --ckptdir, or DMTCP_CHECKPOINT_DIR, or curr dir at ckpt time */\nconst char* dmtcp_get_ckpt_files_subdir();\nint  dmtcp_get_ckpt_signal(); /* given by --ckpt-signal */\nconst char* dmtcp_get_uniquepid_str();\nconst char* dmtcp_get_computation_id_str();\nuint64_t dmtcp_get_coordinator_timestamp();\nuint32_t dmtcp_get_generation(); /* number of ckpt/restart sequences encountered */\nconst char* dmtcp_get_executable_path();\nint dmtcp_get_restart_env(char *name, char *value, int maxvaluelen);\n  /* For 'name' in environment, copy its value into 'value' param, but with\n   * at most length 'maxvaluelen'.\n   * Return 0 for success, and return code for various errors\n   * See contrib/modify-env for an example of its use.\n   */\n\\end{verbatim}\n}\n\n\n\\end{document}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/doc/src/architecture-of-dmtcp.tex": "\\documentclass{article}\n\\usepackage{fullpage}\n\\usepackage{graphicx}\n\\usepackage[noend]{algorithmic}\n\\usepackage{algorithm}\n\n\n\\title{Architecture of DMTCP}\n\\author{Gene Cooperman}\n\\date{March, 2015}\n\n\\begin{document}\n\\maketitle\n\nThis is intended as a gentle introduction to the architecture of DMTCP.\nShorter descriptions are possible.  For a low-level description with\nreferences to code in the implementation, see\n{\\tt doc/restart\\_algorithm.txt}~.  For the general use of plugins,\nsee {\\tt doc/plugin-tutorial.pdf}~.  DMTCP uses plugins internally\nfrom {\\tt DMTCP\\_ROOT/src/plugin}.  DMTCP also offers optional plugins\n(not enabled by default) to end users.  Thes come in two flavors:\n{\\tt DMTCP\\_ROOT/plugin}\n(fully supported) and {\\tt DMTCP\\_ROOT/contrib} (newer plugins,\npossibly contributed by third parties).\n\n\\subsection*{1. Usage of DTMCP:}\n\\begin{algorithmic}[1]\n\\STATE {\\tt dmtcp\\_launch a.out}\n\\STATE {\\tt dmtcp\\_command --checkpoint} \\newline\n\\hbox{\\ \\ \\ \\ } $\\hookrightarrow$ ckpt\\_a.out.*.dmtcp\n\\STATE {\\tt dmtcp\\_restart ckpt\\_a.out.*.dmtcp}\n\\end{algorithmic}\n\n\\bigskip\n\\noindent\nDMTCP offers a {\\tt --help} command line option along with additional options\nboth for {\\tt configure} and for the individual DMTCP commands.\nTo use DMTCP, just prefix your command line with {\\tt dmtcp\\_launch}.\n\n\\subsection*{2. dmtcp\\_launch a.out}\n\nThe command {\\tt dmtcp\\_launch a.out} is roughly equivalent to:\n\n\\begin{algorithmic}[1]\n\\STATE {\\tt dmtcp\\_coordinator --background}  (if not already running)\n\\STATE {\\tt LD\\_PRELOAD=libdmtcp.so a.out} \\\\ ({\\tt LD\\_PRELOAD} causes\n   {\\tt libdmtcp.so} to be loaded first, and initialized before the call to\n   {\\tt main} in {\\tt a.out}.)\n\\end{algorithmic}\n\nThe {\\tt dmtcp\\_launch} command will cause a coordinator process\nto be launched on the local host with the default DMTCP port (if one is\nnot already available).\n\nDMTCP includes a special coordinator process so that DMTCP can also checkpoint\ndistributed computations across many computers.  The user can issue a command\nto the coordinator, which will then relay the command to each of\nthe user processes of the distributed computation.\n\nNote that a {\\em DMTCP computation} is defined to be a coordinator process\nand the set of user processes connected to that coordinator.  Therefore,\none can have more than one DMTCP computation on a single computer,\neach computation having its own unique coordinator.  Each coordinator\nis defined by its unique network address, ``(hostname, port)'', which\ndefaults to ``(localhost, 7779)''.\n\n\\begin{center}\n\\includegraphics[scale=0.5]{coord-client.eps}\n\\end{center}\n\nThe coordinator is {\\em stateless}.  If the computation is ever killed,\none needs only to start an entirely new coordinator, and then restart\nusing the latest checkpoint images for each user process.\n\nLD\\_PRELOAD is a special environment variable known to the loader.\nWhen the loader tries to load a binary (a.out, in this case), the loader\nwill first check if LD\\_PRELOAD is set (see `man ld.so').  If it is\nset, the loader will load the binary (a.out) and then the preload library\n(libdmtcp.so) before running the `main()' routine in a.out.\n(In fact, dmtcp\\_launch may also preload some plugin libraries,\n such as pidvirt.so (starting with DMTCP-2.0) and set some\n environment variables such as DMTCP\\_DLSYM\\_OFFSET.)\n\nWhen the library libdmtcp.so is loaded, any top-level variables\nare initialized, before calling the user main().  If the top-level variable\nis a C++ object, then the C++ constructor is called before the\nuser main.  In DMTCP, the first code to execute is the code\nbelow, inside libdmtcp.so:\n\n{\\tt\ndmtcp::DmtcpWorker dmtcp::DmtcpWorker::theInstance;\n}\n\nThis initializes the global variable, {\\tt theInstance} via a call\nto {\\tt new dmtcp::DmtcpWorker::DmtcpWorker()}.  (Here, {\\tt dmtcp}\nis a C++ namespace, and the first {\\tt DmtcpWorker} is the class name,\nwhile the second {\\tt DmtcpWorker} is the constructor function.  If DMTCP were\nnot using C++, then it would use GNU gcc attributes\nto directly run a constructor function.)\n\nNote that DMTCP is organized in at least two layers.  The lowest layer\nis MTCP (mtcp subdirectory), which handles single-process checkpointing.\nThe higher layer is again called DMTCP (dmtcp subdirectory), and delegates\nto MTCP when it needs to checkpoint one process.  MTCP does not require\na separate DMTCP coordinator.\n\nSo, at startup, we see:\n\n\\begin{algorithmic}[1]\n\\STATE a.out process:\n\\STATE {\\ \\ } primary user thread:\n\\STATE {\\ \\ \\ \\ } new DmtcpWorker():\n\\STATE {\\ \\ \\ \\ \\ \\ } Create a socket to the coordinator\n\\STATE {\\ \\ \\ \\ \\ \\ } Register the signal handler that will be\n\tused for checkpoints. \\newline\n\\hbox{\\ \\ \\ \\ \\ \\ \\ \\ } The signal handler is\n\t\t src/threadlist.cpp:stopthisthread(sig)\\newline\n\\hbox{\\ \\ \\ \\ \\ \\ \\ \\ } The default signal is src/siginfo.cpp:STOPSIGNAL\n\t\t (default: SIGUSR2)\\newline\n\\hbox{\\ \\ \\ \\ \\ \\ \\ \\ } The signal handler for STOPSIGNAL is registered by\n\t {\\tt SigInfo::setupCkptSigHandler(\\&stopthisthread)}\n\\hbox{\\ \\ \\ \\ \\ \\ \\ \\ } in src/threadlist.cpp\n\\STATE {\\ \\ \\ \\ \\ \\ } Create the checkpoint thread: \\newline\n\\hbox{\\ \\ \\ \\ \\ \\ \\ \\ } Call\n\t{\\tt pthread\\_create (\\&checkpointhreadid, NULL, checkpointhread, NULL)}\n\tin src/threadlist.cpp\n\\STATE {\\ \\ \\ \\ \\ \\ } Wait until the checkpoint thread has initialized.\n\\newline\n\\STATE {\\ \\ } checkpoint thread:\n\\STATE {\\ \\ \\ \\ } checkpointhread(dummy):  [from src/threadlist.cpp]\n\\STATE {\\ \\ \\ \\ \\ \\ } Register a.out process with coordinator\n\\STATE {\\ \\ \\ \\ \\ \\ } Tell user thread we're done\n\\STATE {\\ \\ \\ \\ \\ \\ } Call select() on socket to coordinator\n\\newline\n\\STATE {\\ \\ } primary user thread:\n\\STATE {\\ \\ \\ \\ } new DmtcpWorker():  [continued from above invocation]\n\\STATE {\\ \\ \\ \\ \\ \\ } Checkpoint thread is now initialized.  Return.\n\\STATE {\\ \\ \\ \\ } main()  [User code now executes.]\n\\end{algorithmic}\n\n\\bigskip\n\\noindent\nPRINCIPLE:  At any given moment either the user threads are active and\n\tthe checkpoint thread is blocked on {\\tt select()}, or\n\tthe checkpoint thread is active and the user threads are\n\tblocked inside the signal handler, stopthisthread().\n\n\n\n\n\\newpage\n\n\\subsection*{3. Execute a Checkpoint:}\n\n\\begin{center}\n\\includegraphics[scale=0.5]{dmtcp-ckpt.eps}\n\\end{center}\n\n\\begin{algorithmic}[1]\n\\STATE checkpoint thread:\n\\STATE   return from {\\tt DmtcpWorker::waitForCoordinatorMsg()}\n\t   in src/dmtcpworker.cpp\n\\STATE   receive CKPT message\n\\STATE   send STOPSIGNAL (SIGUSR2) to each user thread \\\\\n  See:  {\\tt THREAD\\_TGKILL(motherpid, thread->tid, SigInfo::ckptSignal()}\n                in the section \\\\\n                ~~labeled {\\tt case~ST\\_RUNNING:} in src/threadlist.cpp \\\\\n  See {\\tt Thread\\_UpdateState(curThread, ST\\_SUSPINPROG, ST\\_SIGNALED)} \\\\\n  ~~and {\\tt Thread\\_UpdateState(curThread, ST\\_SUSPENDED, ST\\_SUSPINPROG)}\n\tin src/threadlist.cpp\n\\STATE   Recall that dmtcpWorker created a signal handler,\n            {\\tt stopthisthread()}, for STOPSIGNAL (default: SIGUSR2)\n\\STATE   Each user thread in that signal handler will\n           execute {\\tt sem\\_wait(\\&semWaitForCkptThreadSignal)} and block.\n\\STATE   The checkpoint thread does the checkpoint.\n\\newline\n\\STATE   Release each thread from its mutex\n           by calling {sem\\_post(\\&semWaitForCkptThreadSignal)}\n           inside {\\tt resumeThreads()}.\n\\STATE  Each thread updates its state from {\\tt ST\\_SUSPENDED}\n           to {\\tt ST\\_RUNNING}: \\\\\n       See {\\tt Thread\\_UpdateState(curThread, ST\\_RUNNING, ST\\_SUSPENDED)}\n\tin src/threadlist.cpp\n\\STATE  Call {\\tt DmtcpWorker::waitForCoordinatorMsg()} using the socket\n          to the coordinator and again wait for\n\t  messages from the coordinator.\n\\end{algorithmic}\n\n\\subsection*{4. Checkpoint strategy (overview)}\n\n\\begin{algorithmic}[1]\n\\STATE Quiesce all user threads (using STOPSIGNAL (SIGUSR2), as above)\n\\STATE Drain sockets \\newline\n  \\hbox{\\ \\ } (a) Sender sends a ``cookie'' \\newline\n  \\hbox{\\ \\ } (b) Receiver receives until it sees the ``cookie'' \\newline\n  Note:  Usually all sockets are ``internal'' --- within the current\n    computation.  Heuristics are provided for the case of ``external'' sockets.\n\\STATE Interrogate kernel state (open file descriptors, file descriptor offset, etc.)\n\\STATE Save register values using setcontext (similar to setjmp) in mtcp/mtcp.c\n\\STATE Copy all user-space memory to checkpoint image\n  To find all user-space memory, one can execute: \\newline\n  \\hbox{\\ \\ } {\\tt cat /proc/self/maps}\n\\STATE Unblock all use threads\n\\end{algorithmic}\n\n\\subsection*{5. Restart strategy (overview)}\n\n{\\bf This section will be revised in the future.}\n\nThe key ideas are that {\\tt dmtcp\\_restart} exec's into {\\tt\nmtcp\\_restart}.  The program {\\tt mtcp\\_restart} (source code in\nsrc/mtcp/) is created specially so that the process will consist of a\nsingle relocatable memory segment.  The program relocates itself into\na ``hole'' in memory not occupied by the checkpoint image.  It then\ncalls\\linebreak[4] {\\tt src/mtcp/mtcp\\_restart.c:restorememoryareas()}.\nThis maps the memory areas of the checkpoint image into their original\nmemory addresses.  (``Bits are bits.'')\n\nWhile still in {\\tt restorememoryareas()}, it calls {restore\\_libc()} to\nupdate the information in memory about the different threads.  Finally,\nit calls a function pointer, {\\tt restore\\_info.post\\_restart}, which\nin fact is bound to {\\tt ThreadList::postRestart()} in src/threadlist.cpp.\n\nIt is then the job of {\\tt ThreadList::postRestart()} to create the\nremaining threads and set their state correctly.  Each remaining thread\nfinds itself inside the signal handler again (After all, ``bits are\nbits.''), and the checkpoint thread then releases each thread, as\ndescribed in the previous section.\n\n\n\\subsection*{6. Principle:  DMTCP is contagious}\n\nNew Linux ``tasks'' are created in one of three ways:\n\\begin{enumerate}\n  \\item new thread: created by pthread\\_create() or clone()\n  \\item new process: created by fork()\n  \\item new remote process: typically created by the `system' system call: \\\\\n\t{\\tt system(\"ssh REMOTE\\_HOST a.out\");}\n\\end{enumerate}\n\nDMTCP makes sure to load itself using wrapper functions.\n\n\n\\subsection*{7. Principle:  One DMTCP Coordinator for each DMTCP Computation}\n\nOne may wish to run multiple DMTCP-based computations on a single host.\nThis is easily done by using the {\\tt --host} and {\\tt --port} flags\nof {\\tt dmtcp\\_launch} or of {\\tt dmtcp\\_coordinator}.  If not specified,\nthe default values are localhost and port~7779.  By using {\\tt dmtcp\\_command},\none can communicate a checkpoint or other request to one's\npreferred coordinator (again by specifying host and port, if one is\nnot using the default coordinator).\n\nIn the simplest case, the user invokes only {\\tt dmtcp\\_launch}, with no\nflags.  The {\\tt dmtcp\\_launch} command then looks for an existing\ncoordinator at localhost:7779.  If none is found, {\\tt dmtcp\\_launch}\ninvokes {\\tt dmtcp\\_coordinator} with those default values, localhost:7779.\n\nThus, an occasional issue occurs when two users on the same host each\ninvoke {\\tt dmtcp\\_launch} with default parameters.  They cannot both use\nthe same coordinator.  Similarly, a single user may want to launch two\nindependent computations, and independently checkpoint them.  If the user\ninvokes {\\tt dmtcp\\_launch} (default parameters) for both computation,\nthen there will only be one coordinator.  So, in the view of DMTCP,\nthere will only be a single computation, and a checkpoint command will\ncheckpoint the processes of both computations.\n\n\\subsection*{8. Plugins and other End-User Customizations}\n\nDMTCP offers a rich set of features for customizing the behavior of\nDMTCP.  In this short overview, we will point to examples that can\neasily be modified by an end-user.  See {\\tt doc/plugin-tutorial.pdf}\nfor a more extensive description of plugins.\n\n\\paragraph{DMTCP Plugins.}\n\n{\\em DMTCP plugins\\/} are the most general way to customize DMTCP.  Examples\nare in {\\tt DMTCP\\_ROOT/test/plugin/}.  A dynamic library~({\\tt *.so})\nfile is created to modify the behavior of DMTCP.  The library can\nwrite additional wrapper functions (and even define wrappers around\nprevious wrapper functions).  The library can also register\nto be notified of {\\em DMTCP events}.  In this case, DMTCP will\ncall any plugin functions registered for each event.\nExamples of important events are\n\\hbox{e.g.}~prior to checkpoint, after resume, and after restart\nfrom a checkpoint image.  As of this writing, there is no central\nlist of all DMTCP events, and names of events are still subject to change.\n\nPlugin libraries are preloaded after libdmtcp.so.  As with all\npreloaded libraries, they can initialize themselves before the user's\n``main'' function, and at run-time, plugin wrapper functions will\nbe found in standard Linux library search order prior to ordinary\nlibrary functions in libc.so and elsewhere.\n\nFor example, the sleep2 plugin example uses two plugins.  After building\nthe plugins, it might be called as follows: \\newline\n{\\tt\n\\hbox{\\ \\ }  dmtcp\\_launch --with-plugin $\\backslash$ \\newline\n\\hbox{\\ \\ \\ \\ }\n PATH/sleep1/dmtcp\\_sleep1hijack.so:PATH/sleep2/dmtcp\\_sleep2hijack.so a.out}\n \\newline\nwhere {\\tt PATH} is {\\tt DMTCP\\_ROOT/test/plugin}\n\nIn a more involved example, whenever {\\tt ./configure\n--enable-ptrace-support} is specified, then DMTCP will use the plugin\n{\\tt DMTCP\\_ROOT/plugin/ptrace/ptracehijack.so}.  A new plugin to\nprovide PID/TID virtualization is currently planned.  As with support\nfor ptrace, a more modular structure for PID/TID virtualization will be\neasier to maintain.\n\n\\paragraph{MTCP.}\n\nIn DMTCP-2.1 and earlier, the MTCP component of DMTCP could be compiled\nto run standalone, with opportunities for hook functions using weak symbols.\nMTCP has now been almost entirely re-written, and is now tightly integrated\nwith DMTCP.  {\\em For thos who wished to use the prior MTCP architecture\n(just the checkpoint thread, but no separate coordinator), a plugin\nwith those features is planned for the future.}\n\n\\subsection*{9. Implementation of Plugins}\n\nThe implementation techniques of wrapper functions and pid/tid virtualization\nwe part of the DMTCP implementation not too long after the\ninitial offering of DMTCP.  More recently, this functionality was\nwrapped into a high level abstraction, plugins.  This section emphasizes\nthe implementation of these features.  For information on using plugins,\nand writing your own, see {\\tt doc/plugin-tutorial.pdf}~.\n\n\\subsubsection*{a. Wrapper functions}\n\nWrapper functions are functions around functions.  DMTCP creates\nfunctions around libc.so functions.\nWrapper functions\nare typically created using dlopen/dlsym.  For example, to define\na wrapper around libc:fork(), one defines a function fork()\nin libdmtcp.so (see {\\tt extern \"C\" pid\\_t fork()} in execwrappers.cpp).\n\nContinuing this example, if the user code calls fork(), then we see\nthe following progression.\n\na.out:call to fork() $\\longrightarrow$ libdmtcp.so:fork() $\\longrightarrow$ libc.so:fork()\n\nThe symbol libdmtcp.so:fork appears before libc.so:fork in the\nlibrary search order because libdmtcp.so was loaded before libc.so\n(due to LD\\_PRELOAD).\n\nNext, the wrapper around {\\tt pthread\\_create} remembers the thread id\nof the new thread created.  The wrapper around {\\tt fork} ensures\nthat the environment variable LD\\_PRELOAD is still set to libdmtcp.so.\nIf LD\\_PRELOAD does not currently include libdmtcp.so, then it is\nreset to include libdmtcp.so before the call to fork(), and then\nLD\\_PRELOAD is reset to the original user value after fork().\n\nThe wrapper around {\\tt system} (in the case of creating remote processes)\nis perhaps the most interesting one.  See {\\tt `man system'} for a description\nof the call {\\tt system}.  It looks at an argument, for example\n{\\tt \"ssh REMOTE\\_HOST a.out\"}, and then edits the argument to\n{\\tt \"ssh REMOTE\\_HOST dmtcp\\_launch a.out\"} before calling {\\tt system}.\nOf course, this works only if dmtcp\\_launch is in the user's path\non {\\tt REMOTE\\_HOST}.  This is the responsibility of the user or the\nsystem administrator.\n\n\\subsubsection*{b. PID/TID Virtualization}\n\nAny system calls that refer to a process id (pid) or thread id (tid) requires\na wrapper.  DMTCP then translates between a virtual pid/tid an the\nreal pid/tid.  The user code always sees the virtual pid/tid, while\nthe kernel always sees the real pid/tid.\n\n\\subsubsection*{c. Publish/Subscribe}\n\nPlugins also offer a publish/subscribe service for situations where\na DMTCP computation contains more than one process, and the user\nprocesses must coordinate with each other.  Details are in\n{\\tt doc/plugin-tutorial.pdf}~.\n\n\\end{document}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/include/dmtcpalloc.h",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/test/credentials/conf3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/test/credentials/conf7.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/test/credentials/conf5.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/test/credentials/conf6.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/test/credentials/conf4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/test/credentials/conf2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/contrib/condor/condor-dmtcp-overview.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/doc/architecture-of-dmtcp.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/doc/plugin-tutorial.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/manpages/dmtcp_restart.1.gz",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/manpages/dmtcp_coordinator.1.gz",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/manpages/dmtcp_launch.1.gz",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/manpages/dmtcp.1.gz",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.5.2-5pd67teujeccqojal62uqe2dxxgo62js/spack-src/manpages/dmtcp_command.1.gz"
    ],
    "total_files": 648
}