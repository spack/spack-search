{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-mpi4py-develop-q3si5cimpjfefak4g5hq7sptgxfjsgpd/spack-src/setup.py": "#!/usr/bin/env python\n# Author:  Lisandro Dalcin\n# Contact: dalcinl@gmail.com\n\n__doc__ = \\\n\"\"\"\nPython bindings for MPI\n\"\"\"\n\nimport sys\nimport os\nimport re\n\ntry:\n    import setuptools\nexcept ImportError:\n    setuptools = None\n\npyver = sys.version_info[:2]\nif pyver < (2, 6) or (3, 0) <= pyver <= (3, 2):\n    raise RuntimeError(\"Python version 2.6+ or 3.3+ required\")\nif pyver == (2, 6) or (3, 3) <= pyver <= (3, 4):\n    sys.stderr.write(\n        \"WARNING: Python %d.%d is not supported.\\n\" % pyver)\nif (hasattr(sys, 'pypy_version_info') and\n    sys.pypy_version_info[:2] < (2, 0)):\n    raise RuntimeError(\"PyPy version >= 2.0 required\")\n\ntopdir = os.path.abspath(os.path.dirname(__file__))\nsys.path.insert(0, os.path.join(topdir, 'conf'))\n\n# --------------------------------------------------------------------\n# Metadata\n# --------------------------------------------------------------------\n\ndef name():\n    return 'mpi4py'\n\ndef version():\n    srcdir = os.path.join(topdir, 'src')\n    with open(os.path.join(srcdir, 'mpi4py', '__init__.py')) as f:\n        m = re.search(r\"__version__\\s*=\\s*'(.*)'\", f.read())\n        return m.groups()[0]\n\ndef description():\n    with open(os.path.join(topdir, 'DESCRIPTION.rst')) as f:\n        return f.read()\n\nname    = name()\nversion = version()\n\nurl      = 'https://github.com/mpi4py/%(name)s/' % vars()\ndownload = url + 'releases/download/%(version)s/' % vars()\ndownload = download + '%(name)s-%(version)s.tar.gz' % vars()\n\nclassifiers = \"\"\"\nDevelopment Status :: 5 - Production/Stable\nIntended Audience :: Developers\nIntended Audience :: Science/Research\nLicense :: OSI Approved :: BSD License\nOperating System :: MacOS\nOperating System :: MacOS :: MacOS X\nOperating System :: Microsoft :: Windows\nOperating System :: POSIX\nOperating System :: POSIX :: BSD\nOperating System :: POSIX :: Linux\nOperating System :: Unix\nProgramming Language :: C\nProgramming Language :: Cython\nProgramming Language :: Python\nProgramming Language :: Python :: 2\nProgramming Language :: Python :: 2.7\nProgramming Language :: Python :: 3\nProgramming Language :: Python :: 3.5\nProgramming Language :: Python :: 3.6\nProgramming Language :: Python :: 3.7\nProgramming Language :: Python :: 3.8\nProgramming Language :: Python :: 3.9\nProgramming Language :: Python :: Implementation :: CPython\nProgramming Language :: Python :: Implementation :: PyPy\nTopic :: Scientific/Engineering\nTopic :: Software Development :: Libraries :: Python Modules\nTopic :: System :: Distributed Computing\n\"\"\"\n\nkeywords = \"\"\"\nscientific computing\nparallel computing\nmessage passing interface\nMPI\n\"\"\"\n\nplatforms = \"\"\"\nPOSIX\nLinux\nmacOS\nFreeBSD\nWindows\n\"\"\"\n\nmetadata = {\n    'name'             : name,\n    'version'          : version,\n    'description'      : __doc__.strip(),\n    'long_description' : description(),\n    'url'              : url,\n    'download_url'     : download,\n    'classifiers'      : [c for c in classifiers.split('\\n') if c],\n    'keywords'         : [k for k in keywords.split('\\n')    if k],\n    'platforms'        : [p for p in platforms.split('\\n')   if p],\n    'license'          : 'BSD',\n    'author'           : 'Lisandro Dalcin',\n    'author_email'     : 'dalcinl@gmail.com',\n    'maintainer'       : 'Lisandro Dalcin',\n    'maintainer_email' : 'dalcinl@gmail.com',\n    }\n\nmetadata['provides'] = ['mpi4py']\n\n# --------------------------------------------------------------------\n# Extension modules\n# --------------------------------------------------------------------\n\ndef run_command(exe, args):\n    from distutils.spawn import find_executable\n    from distutils.util  import split_quoted\n    cmd = find_executable(exe)\n    if not cmd: return []\n    if not isinstance(args, str):\n        args = ' '.join(args)\n    try:\n        with os.popen(cmd + ' ' + args) as f:\n            return split_quoted(f.read())\n    except:\n        return []\n\nlinux   = sys.platform.startswith('linux')\nsolaris = sys.platform.startswith('sunos')\ndarwin  = sys.platform.startswith('darwin')\n\nif linux:\n    def whole_archive(compiler, name, library_dirs=[]):\n        return ['-Wl,-whole-archive',\n                '-l' + name,\n                '-Wl,-no-whole-archive',\n                ]\nelif darwin:\n    def darwin_linker_dirs(compiler):\n        from distutils.util import split_quoted\n        linker_cmd = compiler.linker_so + ['-show']\n        linker_cmd = run_command(linker_cmd[0], linker_cmd[1:])\n        library_dirs  = compiler.library_dirs[:]\n        library_dirs += [flag[2:] for flag in linker_cmd\n                         if flag.startswith('-L')]\n        library_dirs += ['/usr/lib']\n        library_dirs += ['/usr/local/lib']\n        return library_dirs\n    def whole_archive(compiler, name, library_dirs=[]):\n        library_dirs = library_dirs[:]\n        library_dirs += darwin_linker_dirs(compiler)\n        for libdir in library_dirs:\n            libpath = os.path.join(libdir, 'lib%s.a' % name)\n            if os.path.isfile(libpath):\n                return ['-force_load', libpath]\n        return ['-l%s' % name]\nelif solaris:\n    def whole_archive(compiler, name, library_dirs=[]):\n        return ['-Wl,-zallextract',\n                '-l' + name,\n                '-Wl,-zdefaultextract',\n                ]\nelse:\n    whole_archive = None\n\ndef configure_dl(ext, config_cmd):\n    from distutils import log\n    log.info(\"checking for dlopen() availability ...\")\n    ok = config_cmd.check_header('dlfcn.h')\n    if ok : ext.define_macros += [('HAVE_DLFCN_H', 1)]\n    ok = config_cmd.check_library('dl')\n    if ok: ext.libraries += ['dl']\n    ok = config_cmd.check_function('dlopen',\n                                   libraries=['dl'],\n                                   decl=1, call=1)\n    if ok: ext.define_macros += [('HAVE_DLOPEN', 1)]\n\ndef configure_mpi(ext, config_cmd):\n    from textwrap import dedent\n    from distutils import log\n    from distutils.errors import DistutilsPlatformError\n    headers = ['stdlib.h', 'mpi.h']\n    #\n    log.info(\"checking for MPI compile and link ...\")\n    ConfigTest = dedent(\"\"\"\\\n    int main(int argc, char **argv)\n    {\n      (void)MPI_Init(&argc, &argv);\n      (void)MPI_Finalize();\n      return 0;\n    }\n    \"\"\")\n    errmsg = \"Cannot %s MPI programs. Check your configuration!!!\"\n    ok = config_cmd.try_compile(ConfigTest, headers=headers)\n    if not ok: raise DistutilsPlatformError(errmsg % \"compile\")\n    ok = config_cmd.try_link(ConfigTest, headers=headers)\n    if not ok: raise DistutilsPlatformError(errmsg % \"link\")\n    #\n    log.info(\"checking for missing MPI functions/symbols ...\")\n    tests  = [\"defined(%s)\" % macro for macro in\n              (\"OPEN_MPI\", \"MSMPI_VER\",)]\n    tests += [\"(defined(MPICH_NAME)&&(MPICH_NAME==3))\"]\n    tests += [\"(defined(MPICH_NAME)&&(MPICH_NAME==2))\"]\n    ConfigTest = dedent(\"\"\"\\\n    #if !(%s)\n    #error \"Unknown MPI implementation\"\n    #endif\n    \"\"\") % \"||\".join(tests)\n    ok = config_cmd.try_compile(ConfigTest, headers=headers)\n    if not ok:\n        from mpidistutils import ConfigureMPI\n        configure = ConfigureMPI(config_cmd)\n        results = configure.run()\n        configure.dump(results)\n        ext.define_macros += [('HAVE_CONFIG_H', 1)]\n    else:\n        for function, arglist in (\n            ('MPI_Type_create_f90_integer',   '0,(MPI_Datatype*)0'),\n            ('MPI_Type_create_f90_real',    '0,0,(MPI_Datatype*)0'),\n            ('MPI_Type_create_f90_complex', '0,0,(MPI_Datatype*)0'),\n            ('MPI_Status_c2f', '(MPI_Status*)0,(MPI_Fint*)0'),\n            ('MPI_Status_f2c', '(MPI_Fint*)0,(MPI_Status*)0'),\n            ):\n            ok = config_cmd.check_function_call(\n                function, arglist, headers=headers)\n            if not ok:\n                macro = 'PyMPI_MISSING_' + function\n                ext.define_macros += [(macro, 1)]\n        for symbol, stype in (\n            ('MPI_LB', 'MPI_Datatype'),\n            ('MPI_UB', 'MPI_Datatype'),\n            ):\n            ok = config_cmd.check_symbol(\n                symbol, type=stype, headers=headers)\n            if not ok:\n                macro = 'PyMPI_MISSING_' + symbol\n                ext.define_macros += [(macro, 1)]\n    #\n    if os.name == 'posix':\n        configure_dl(ext, config_cmd)\n\ndef configure_libmpe(lib, config_cmd):\n    #\n    mpecc = os.environ.get('MPECC') or 'mpecc'\n    command = run_command(mpecc, '-mpilog -show')\n    for arg in command:\n        if arg.startswith('-L'):\n            libdir = arg[2:]\n            lib.library_dirs.append(libdir)\n            lib.runtime_library_dirs.append(libdir)\n    #\n    log_lib  = 'lmpe'\n    dep_libs = ('pthread', 'mpe')\n    ok = config_cmd.check_library(log_lib, lib.library_dirs)\n    if not ok: return\n    libraries = []\n    for libname in dep_libs:\n        if config_cmd.check_library(\n            libname, lib.library_dirs,\n            other_libraries=libraries):\n            libraries.insert(0, libname)\n    if whole_archive:\n        cc = config_cmd.compiler\n        dirs = lib.library_dirs[:]\n        lib.extra_link_args += whole_archive(cc, log_lib, dirs)\n        lib.extra_link_args += ['-l' + libname\n                                for libname in libraries]\n    else:\n        lib.libraries += [log_lib] + libraries\n\ndef configure_libvt(lib, config_cmd):\n    #\n    vtcc = os.environ.get('VTCC') or 'vtcc'\n    command = run_command(vtcc, '-vt:showme')\n    for arg in command:\n        if arg.startswith('-L'):\n            libdir = arg[2:]\n            lib.library_dirs.append(libdir)\n            lib.runtime_library_dirs.append(libdir)\n    # modern VampirTrace\n    if lib.name == 'vt':\n        log_lib = 'vt-mpi'\n    else:\n        log_lib = lib.name\n    ok = config_cmd.check_library(log_lib, lib.library_dirs)\n    if ok: lib.libraries = [log_lib]\n    if ok: return\n    # older VampirTrace, Open MPI <= 1.4\n    if lib.name == 'vt-hyb':\n        log_lib = 'vt.ompi'\n    else:\n        log_lib = 'vt.mpi'\n    dep_libs = ('dl', 'z', 'otf',)\n    ok = config_cmd.check_library(log_lib, lib.library_dirs)\n    if not ok: return\n    libraries = []\n    for libname in dep_libs:\n        if config_cmd.check_library(\n            libname, lib.library_dirs,\n            other_libraries=libraries):\n            libraries.insert(0, libname)\n    if whole_archive:\n        cc = config_cmd.compiler\n        dirs = lib.library_dirs[:]\n        lib.extra_link_args += whole_archive(cc, log_lib, dirs)\n        lib.extra_link_args += ['-l' + libname\n                                for libname in libraries]\n    else:\n        lib.libraries += [log_lib] + libraries\n    lib.define_macros.append(('LIBVT_LEGACY', 1))\n    if lib.name == 'vt-hyb':\n        openmp_flag = '-fopenmp' # GCC, Intel\n        lib.extra_compile_args.append(openmp_flag)\n        lib.extra_link_args.append(openmp_flag)\n\ndef configure_pyexe(exe, config_cmd):\n    from distutils import sysconfig\n    if sys.platform.startswith('win'):\n        return\n    if (sys.platform == 'darwin' and\n        ('Anaconda' in sys.version or\n         'Continuum Analytics' in sys.version)):\n        py_version = sysconfig.get_python_version()\n        py_abiflags = getattr(sys, 'abiflags', '')\n        exe.libraries += ['python' + py_version + py_abiflags]\n        return\n    #\n    from distutils.util import split_quoted\n    cfg_vars = sysconfig.get_config_vars()\n    libraries = []\n    library_dirs = []\n    link_args = []\n    if pyver >= (3, 8) or not cfg_vars.get('Py_ENABLE_SHARED'):\n        py_version = sysconfig.get_python_version()\n        py_abiflags = getattr(sys, 'abiflags', '')\n        libraries = ['python' + py_version + py_abiflags]\n        if hasattr(sys, 'pypy_version_info'):\n            py_tag = py_version[0].replace('2', '')\n            libraries = ['pypy%s-c' % py_tag]\n    if sys.platform == 'darwin':\n        fwkdir = cfg_vars.get('PYTHONFRAMEWORKDIR')\n        if (fwkdir and fwkdir != 'no-framework' and\n            fwkdir in cfg_vars.get('LINKFORSHARED', '')):\n            del libraries[:]\n    for var in ('LIBDIR', 'LIBPL'):\n        library_dirs += split_quoted(cfg_vars.get(var, ''))\n    for var in ('LDFLAGS',\n                'LIBS', 'MODLIBS', 'SYSLIBS',\n                'LDLAST'):\n        link_args += split_quoted(cfg_vars.get(var, ''))\n    exe.libraries += libraries\n    exe.library_dirs += library_dirs\n    exe.extra_link_args += link_args\n\n\ndef ext_modules():\n    modules = []\n    # custom dl extension module\n    dl = dict(\n        name='mpi4py.dl',\n        optional=True,\n        sources=['src/dynload.c'],\n        depends=['src/dynload.h'],\n        configure=configure_dl,\n        )\n    if os.name == 'posix':\n        modules.append(dl)\n    # MPI extension module\n    from glob import glob\n    MPI = dict(\n        name='mpi4py.MPI',\n        sources=['src/MPI.c'],\n        depends=(['src/mpi4py.MPI.c'] +\n                 glob('src/*.h') +\n                 glob('src/lib-mpi/*.h') +\n                 glob('src/lib-mpi/config/*.h') +\n                 glob('src/lib-mpi/compat/*.h')\n                 ),\n        configure=configure_mpi,\n        )\n    modules.append(MPI)\n    #\n    return modules\n\ndef libraries():\n    # MPE logging\n    pmpi_mpe = dict(\n        name='mpe', kind='dylib',\n        optional=True,\n        package='mpi4py',\n        dest_dir='lib-pmpi',\n        sources=['src/lib-pmpi/mpe.c'],\n        configure=configure_libmpe,\n        )\n    # VampirTrace logging\n    pmpi_vt = dict(\n        name='vt', kind='dylib',\n        optional=True,\n        package='mpi4py',\n        dest_dir='lib-pmpi',\n        sources=['src/lib-pmpi/vt.c'],\n        configure=configure_libvt,\n        )\n    pmpi_vt_mpi = dict(\n        name='vt-mpi', kind='dylib',\n        optional=True,\n        package='mpi4py',\n        dest_dir='lib-pmpi',\n        sources=['src/lib-pmpi/vt-mpi.c'],\n        configure=configure_libvt,\n        )\n    pmpi_vt_hyb = dict(\n        name='vt-hyb', kind='dylib',\n        optional=True,\n        package='mpi4py',\n        dest_dir='lib-pmpi',\n        sources=['src/lib-pmpi/vt-hyb.c'],\n        configure=configure_libvt,\n        )\n    #\n    return [\n        pmpi_mpe,\n        pmpi_vt,\n        pmpi_vt_mpi,\n        pmpi_vt_hyb,\n        ]\n\ndef executables():\n    # MPI-enabled Python interpreter\n    pyexe = dict(name='python-mpi',\n                 optional=True,\n                 package='mpi4py',\n                 dest_dir='bin',\n                 sources=['src/python.c'],\n                 configure=configure_pyexe,\n                 )\n    #\n    if hasattr(sys, 'pypy_version_info'):\n        return []\n    return [pyexe]\n\n# --------------------------------------------------------------------\n# Setup\n# --------------------------------------------------------------------\n\nfrom mpidistutils import setup\nfrom mpidistutils import Extension  as Ext\nfrom mpidistutils import Library    as Lib\nfrom mpidistutils import Executable as Exe\n\nCYTHON = '0.27'\n\ndef run_setup():\n    \"\"\"\n    Call setup(*args, **kargs)\n    \"\"\"\n    setup_args = metadata.copy()\n    if setuptools:\n        setup_args['zip_safe'] = False\n        setup_args['setup_requires'] = []\n    if setuptools and pyver < (3, 0):\n        setup_args['setup_requires'] += ['3to2']\n    if setuptools and not os.getenv('CONDA_BUILD'):\n        src = os.path.join('src', 'mpi4py.MPI.c')\n        has_src = os.path.exists(os.path.join(topdir, src))\n        has_git = os.path.isdir(os.path.join(topdir, '.git'))\n        has_hg  = os.path.isdir(os.path.join(topdir, '.hg'))\n        if not has_src or has_git or has_hg:\n            setup_args['setup_requires'] += ['Cython>='+CYTHON]\n    #\n    setup(\n        packages = [\n            'mpi4py',\n            'mpi4py.futures',\n        ],\n        package_data = {\n            'mpi4py' : [\n                '*.pxd',\n                'include/mpi4py/*.h',\n                'include/mpi4py/*.i',\n                'include/mpi4py/*.pxi',\n            ],\n            '' : [\n                'py.typed',\n                '*.pyi',\n            ],\n        },\n        package_dir = {'' : 'src'},\n        ext_modules = [Ext(**ext) for ext in ext_modules()],\n        executables = [Exe(**exe) for exe in executables()],\n        libraries   = [Lib(**lib) for lib in libraries()  ],\n        **setup_args\n    )\n\ndef chk_cython(VERSION):\n    from distutils import log\n    from distutils.version import LooseVersion\n    from distutils.version import StrictVersion\n    warn = lambda msg='': sys.stderr.write(msg+'\\n')\n    #\n    try:\n        import Cython\n    except ImportError:\n        warn(\"*\"*80)\n        warn()\n        warn(\" You need to generate C source files with Cython!!\")\n        warn(\" Download and install Cython <http://www.cython.org>\")\n        warn()\n        warn(\"*\"*80)\n        return False\n    #\n    try:\n        CYTHON_VERSION = Cython.__version__\n    except AttributeError:\n        from Cython.Compiler.Version import version as CYTHON_VERSION\n    REQUIRED = VERSION\n    m = re.match(r\"(\\d+\\.\\d+(?:\\.\\d+)?).*\", CYTHON_VERSION)\n    if m:\n        Version = StrictVersion\n        AVAILABLE = m.groups()[0]\n    else:\n        Version = LooseVersion\n        AVAILABLE = CYTHON_VERSION\n    if (REQUIRED is not None and\n        Version(AVAILABLE) < Version(REQUIRED)):\n        warn(\"*\"*80)\n        warn()\n        warn(\" You need to install Cython %s (you have version %s)\"\n             % (REQUIRED, CYTHON_VERSION))\n        warn(\" Download and install Cython <http://www.cython.org>\")\n        warn()\n        warn(\"*\"*80)\n        return False\n    #\n    log.info(\"using Cython version %s\" % CYTHON_VERSION)\n    return True\n\ndef run_cython(source, target=None,\n               depends=(), includes=(),\n               destdir_c=None, destdir_h=None,\n               wdir=None, force=False, VERSION=None):\n    from glob import glob\n    from distutils import log\n    from distutils import dep_util\n    from distutils.errors import DistutilsError\n    if target is None:\n        target = os.path.splitext(source)[0]+'.c'\n    cwd = os.getcwd()\n    try:\n        if wdir: os.chdir(wdir)\n        alldeps = [source]\n        for dep in depends:\n            alldeps += glob(dep)\n        if not (force or dep_util.newer_group(alldeps, target)):\n            log.debug(\"skipping '%s' -> '%s' (up-to-date)\",\n                      source, target)\n            return\n    finally:\n        os.chdir(cwd)\n    if not chk_cython(VERSION):\n        raise DistutilsError(\"requires Cython>=%s\" % VERSION)\n    log.info(\"cythonizing '%s' -> '%s'\", source, target)\n    from cythonize import cythonize\n    err = cythonize(source, target,\n                    includes=includes,\n                    destdir_c=destdir_c,\n                    destdir_h=destdir_h,\n                    wdir=wdir)\n    if err:\n        raise DistutilsError(\n            \"Cython failure: '%s' -> '%s'\" % (source, target))\n\ndef build_sources(cmd):\n    from distutils.errors import DistutilsError\n    has_src = os.path.exists(os.path.join(\n        topdir, 'src', 'mpi4py.MPI.c'))\n    has_vcs = (os.path.isdir(os.path.join(topdir, '.git')) or\n               os.path.isdir(os.path.join(topdir, '.hg' )))\n    if (has_src and not has_vcs and not cmd.force): return\n    # mpi4py.MPI\n    source = 'mpi4py/MPI.pyx'\n    target = 'mpi4py.MPI.c'\n    depends = ['mpi4py/MPI/*.pyx',\n               'mpi4py/MPI/*.pxd',\n               'mpi4py/MPI/*.pxi',]\n    destdir_h = os.path.join('mpi4py', 'include', 'mpi4py')\n    run_cython(source, target, depends, destdir_h=destdir_h,\n               wdir='src', force=cmd.force, VERSION=CYTHON)\n\nfrom mpidistutils import build_src\nbuild_src.run = build_sources\n\ndef run_testsuite(cmd):\n    from distutils.errors import DistutilsError\n    sys.path.insert(0, 'test')\n    try:\n        from runtests import main\n    finally:\n        del sys.path[0]\n    if cmd.dry_run:\n        return\n    args = cmd.args[:] or []\n    if cmd.verbose < 1:\n        args.insert(0,'-q')\n    if cmd.verbose > 1:\n        args.insert(0,'-v')\n    err = main(args)\n    if err:\n        raise DistutilsError(\"test\")\n\nfrom mpidistutils import test\ntest.run = run_testsuite\n\ndef main():\n    run_setup()\n\nif __name__ == '__main__':\n    main()\n\n# --------------------------------------------------------------------\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-mpi4py-develop-q3si5cimpjfefak4g5hq7sptgxfjsgpd/spack-src/CHANGES.rst": "=======================\nCHANGES: MPI for Python\n=======================\n\n:Author:  Lisandro Dalcin\n:Contact: dalcinl@gmail.com\n\n\nRelease 3.1.0 [2021-XX-XX]\n==========================\n\n* Enhancements:\n\n  + Add pickle-based ``Request.waitsome()`` and ``Request.testsome()``.\n\n  + Add lowercase methods ``Request.get_status()`` and ``Request.cancel()``.\n\n  + Support passing Python GPU arrays compliant with the ``__cuda_array_interface__``\n    standard (`link`_) to uppercase API calls if mpi4py is built against \n    CUDA-aware MPI implementations. This feature is currently experimental \n    and subject to future changes.\n\n  + `mpi4py.futures`: Add support for initializers and canceling futures at shutdown.\n\n  + Add type annotations to Cython code. The first line of the docstring of functions\n    and methods displays a signature including type annotations.\n\n  + Add companion stub files to support type checkers.\n\n.. _link: http://numba.pydata.org/numba-doc/latest/cuda/cuda_array_interface.html\n\n\nRelease 3.0.3 [2019-11-04]\n==========================\n\n* Regenerate Cython wrappers to support Python 3.8.\n\n\nRelease 3.0.2 [2019-06-11]\n==========================\n\n* Bug fixes:\n\n  + Fix handling of readonly buffers in support for Python 2 legacy\n    buffer interface. The issue triggers only when using a buffer-like\n    object that is readonly and does not export the new Python 3\n    buffer interface.\n  + Fix build issues with Open MPI 4.0.x series related to removal of\n    many MPI-1 symbols deprecated in MPI-2 and removed in MPI-3.\n  + Minor documentation fixes.\n\n\nRelease 3.0.1 [2019-02-15]\n==========================\n\n* Bug fixes:\n\n  + Fix ``Comm.scatter()`` and other collectives corrupting input send\n    list. Add safety measures to prevent related issues in global\n    reduction operations.\n  + Fix error-checking code for counts in ``Op.Reduce_local()``.\n\n* Enhancements:\n\n  + Map size-specific Python/NumPy typecodes to MPI datatypes.\n  + Allow partial specification of target list/tuple arguments in the\n    various ``Win`` RMA methods.\n  + Workaround for removal of ``MPI_{LB|UB}`` in Open MPI 4.0.\n  + Support for Microsoft MPI v10.0.\n\n\nRelease 3.0.0 [2017-11-08]\n==========================\n\n* New features:\n\n  + `mpi4py.futures`: Execute computations asynchronously using a pool\n    of MPI processes. This package is based on ``concurrent.futures``\n    from the Python standard library.\n  + `mpi4py.run`: Run Python code and abort execution in case of\n    unhandled exceptions to prevent deadlocks.\n  + `mpi4py.bench`: Run basic MPI benchmarks and tests.\n\n* Enhancements:\n\n  + Lowercase, pickle-based collective communication calls are now\n    thread-safe through the use of fine-grained locking.\n  + The ``MPI`` module now exposes a ``memory`` type which is a\n    lightweight variant of the builtin ``memoryview`` type, but\n    exposes both the legacy Python 2 and the modern Python 3 buffer\n    interface under a Python 2 runtime.\n  + The ``MPI.Comm.Alltoallw()`` method now uses ``count=1`` and\n    ``displ=0`` as defaults, assuming that messages are specified\n    through user-defined datatypes.\n  + The ``Request.Wait[all]()`` methods now return ``True`` to match\n    the interface of ``Request.Test[all]()``.\n  + The ``Win`` class now implements the Python buffer interface.\n\n* Backward-incompatible changes:\n\n  + The ``buf`` argument of the ``MPI.Comm.recv()`` method is\n    deprecated, passing anything but ``None`` emits a warning.\n  + The ``MPI.Win.memory`` property was removed, use the\n    ``MPI.Win.tomemory()`` method instead.\n  + Executing ``python -m mpi4py`` in the command line is now\n    equivalent to ``python -m mpi4py.run``. For the former behavior,\n    use ``python -m mpi4py.bench``.\n  + Python 2.6 and 3.2 are no longer supported. The ``mpi4py.MPI``\n    module may still build and partially work, but other pure-Python\n    modules under the ``mpi4py`` namespace will not.\n  + Windows: Remove support for legacy MPICH2, Open MPI, and DeinoMPI.\n\n\nRelease 2.0.0 [2015-10-18]\n==========================\n\n* Support for MPI-3 features.\n\n  + Matched probes and receives.\n  + Nonblocking collectives.\n  + Neighborhood collectives.\n  + New communicator constructors.\n  + Request-based RMA operations.\n  + New RMA communication and synchronisation calls.\n  + New window constructors.\n  + New datatype constructor.\n  + New C++ boolean and floating complex datatypes.\n\n* Support for MPI-2 features not included in previous releases.\n\n  + Generalized All-to-All collective (``Comm.Alltoallw()``)\n  + User-defined data representations (``Register_datarep()``)\n\n* New scalable implementation of reduction operations for Python\n  objects. This code is based on binomial tree algorithms using\n  point-to-point communication and duplicated communicator\n  contexts. To disable this feature, use\n  ``mpi4py.rc.fast_reduce = False``.\n\n* Backward-incompatible changes:\n\n  + Python 2.4, 2.5, 3.0 and 3.1 are no longer supported.\n  + Default MPI error handling policies are overriden. After import,\n    mpi4py sets the ``ERRORS_RETURN`` error handler in ``COMM_SELF``\n    and ``COMM_WORLD``, as well as any new ``Comm``, ``Win``, or\n    ``File`` instance created through mpi4py, thus effectively\n    ignoring the MPI rules about error handler inheritance.  This way,\n    MPI errors translate to Python exceptions.  To disable this\n    behavior and use the standard MPI error handling rules, use\n    ``mpi4py.rc.errors = 'default'``.\n  + Change signature of all send methods,\n    ``dest`` is a required argument.\n  + Change signature of all receive and probe methods,\n    ``source`` defaults to ``ANY_SOURCE``,\n    ``tag`` defaults to ``ANY_TAG``.\n  + Change signature of send lowercase-spelling methods,\n    ``obj`` arguments are not mandatory.\n  + Change signature of recv lowercase-spelling methods,\n    renamed 'obj' arguments to 'buf'.\n  + Change ``Request.Waitsome()`` and ``Request.Testsome()``\n    to return ``None`` or ``list``.\n  + Change signature of all lowercase-spelling collectives,\n    ``sendobj`` arguments are now mandatory,\n    ``recvobj`` arguments were removed.\n  + Reduction operations ``MAXLOC`` and ``MINLOC`` are no longer\n    special-cased in lowercase-spelling methods ``Comm.[all]reduce()``\n    and ``Comm.[ex]scan()``, the input object must be specified as a\n    tuple ``(obj, location)``.\n  + Change signature of name publishing functions.\n    The new signatures are\n    ``Publish_name(service_name, port_name, info=INFO_NULL)`` and\n    ``Unpublish_name(service_name, port_name, info=INFO_NULL)```.\n  + ``Win`` instances now cache Python objects exposing memory by\n    keeping references instead of using MPI attribute caching.\n  + Change signature of ``Win.Lock()``.\n    The new signature is\n    ``Win.Lock(rank, lock_type=LOCK_EXCLUSIVE, assertion=0)``.\n  + Move ``Cartcomm.Map()`` to ``Intracomm.Cart_map()``.\n  + Move ``Graphcomm.Map()`` to ``Intracomm.Graph_map()``.\n  + Remove the ``mpi4py.MPE`` module.\n  + Rename the Cython definition file for use with ``cimport``\n    statement from ``mpi_c.pxd`` to ``libmpi.pxd``.\n\n\nRelease 1.3.1 [2013-08-07]\n==========================\n\n* Regenerate C wrappers with Cython 0.19.1 to support Python 3.3.\n\n* Install ``*.pxd`` files in ``<site-packages>/mpi4py`` to ease the\n  support for Cython's ``cimport`` statement in code requiring to\n  access mpi4py internals.\n\n* As a side-effect of using Cython 0.19.1, ancient Python 2.3 is no\n  longer supported. If you really need it, you can install an older\n  Cython and run ``python setup.py build_src --force``.\n\n\nRelease 1.3 [2012-01-20]\n========================\n\n* Now ``Comm.recv()`` accept a buffer to receive the message.\n\n* Add ``Comm.irecv()`` and ``Request.{wait|test}[any|all]()``.\n\n* Add ``Intracomm.Spawn_multiple()``.\n\n* Better buffer handling for PEP 3118 and legacy buffer interfaces.\n\n* Add support for attribute attribute caching on communicators,\n  datatypes and windows.\n\n* Install MPI-enabled Python interpreter as\n  ``<path>/mpi4py/bin/python-mpi``.\n\n* Windows: Support for building with Open MPI.\n\n\nRelease 1.2.2 [2010-09-13]\n==========================\n\n* Add ``mpi4py.get_config()`` to retrieve information (compiler\n  wrappers, includes, libraries, etc) about the MPI implementation\n  employed to build mpi4py.\n\n* Workaround Python libraries with missing GILState-related API calls\n  in case of non-threaded Python builds.\n\n* Windows: look for MPICH2, DeinoMPI, Microsoft HPC Pack at their\n  default install locations under %ProgramFiles.\n\n* MPE: fix hacks related to old API's, these hacks are broken when MPE\n  is built with a MPI implementations other than MPICH2.\n\n* HP-MPI: fix for missing Fortran datatypes, use dlopen() to load the\n  MPI shared library before MPI_Init()\n\n* Many distutils-related fixes, cleanup, and enhancements, better\n  logics to find MPI compiler wrappers.\n\n* Support for ``pip install mpi4py``.\n\n\nRelease 1.2.1 [2010-02-26]\n==========================\n\n* Fix declaration in Cython include file. This declaration, while\n  valid for Cython, broke the simple-minded parsing used in\n  conf/mpidistutils.py to implement configure-tests for availability\n  of MPI symbols.\n\n* Update SWIG support and make it compatible with Python 3. Also\n  generate an warning for SWIG < 1.3.28.\n\n* Fix distutils-related issues in Mac OS X. Now ARCHFLAGS environment\n  variable is honored of all Python's ``config/Makefile`` variables.\n\n* Fix issues with Open MPI < 1.4.2 releated to error checking and\n  ``MPI_XXX_NULL`` handles.\n\n\nRelease 1.2 [2009-12-29]\n========================\n\n* Automatic MPI datatype discovery for NumPy arrays and PEP-3118\n  buffers. Now buffer-like objects can be messaged directly, it is no\n  longer required to explicitly pass a 2/3-list/tuple like ``[data,\n  MPI.DOUBLE]``, or ``[data, count, MPI.DOUBLE]``. Only basic types\n  are supported, i.e., all C/C99-native signed/unsigned integral types\n  and single/double precision real/complex floating types. Many thanks\n  to Eilif Muller for the initial feedback.\n\n* Nonblocking send of pickled Python objects. Many thanks to Andreas\n  Kloeckner for the initial patch and enlightening discussion about\n  this enhancement.\n\n* ``Request`` instances now hold a reference to the Python object\n  exposing the buffer involved in point-to-point communication or\n  parallel I/O. Many thanks to Andreas Kloeckner for the initial\n  feedback.\n\n* Support for logging of user-defined states and events using `MPE\n  <http://www.mcs.anl.gov/research/projects/perfvis/>`_. Runtime\n  (i.e., without requiring a recompile!)  activation of logging of all\n  MPI calls is supported in POSIX platforms implementing ``dlopen()``.\n\n* Support for all the new features in MPI-2.2 (new C99 and F90\n  datatypes, distributed graph topology, local reduction operation,\n  and other minor enhancements).\n\n* Fix the annoying issues related to Open MPI and Python dynamic\n  loading of extension modules in platforms supporting ``dlopen()``.\n\n* Fix SLURM dynamic loading issues on SiCortex. Many thanks to Ian\n  Langmore for providing me shell access.\n\n\nRelease 1.1.0 [2009-06-06]\n==========================\n\n* Fix bug in ``Comm.Iprobe()`` that caused segfaults as Python C-API\n  calls were issued with the GIL released (issue #2).\n\n* Add ``Comm.bsend()`` and ``Comm.ssend()`` for buffered and\n  synchronous send semantics when communicating general Python\n  objects.\n\n* Now the call ``Info.Get(key)`` return a *single* value (i.e, instead\n  of a 2-tuple); this value is ``None`` if ``key`` is not in the\n  ``Info`` object, or a string otherwise. Previously, the call\n  redundantly returned ``(None, False)`` for missing key-value pairs;\n  ``None`` is enough to signal a missing entry.\n\n* Add support for parametrized Fortran datatypes.\n\n* Add support for decoding user-defined datatypes.\n\n* Add support for user-defined reduction operations on memory\n  buffers. However, at most 16 user-defined reduction operations\n  can be created. Ask the author for more room if you need it.\n\n\nRelease 1.0.0 [2009-03-20]\n==========================\n\nThis is the fist release of the all-new, Cython-based, implementation\nof *MPI for Python*. Unfortunately, this implementation is not\nbackward-compatible with the previous one. The list below summarizes\nthe more important changes that can impact user codes.\n\n* Some communication calls had *overloaded* functionality. Now there\n  is a clear distinction between communication of general Python\n  object with *pickle*, and (fast, near C-speed) communication of\n  buffer-like objects (e.g., NumPy arrays).\n\n  - for communicating general Python objects, you have to use\n    all-lowercase methods, like ``send()``, ``recv()``, ``bcast()``,\n    etc.\n\n  - for communicating array data, you have to use ``Send()``,\n    ``Recv()``, ``Bcast()``, etc. methods. Buffer arguments to these\n    calls must be explicitly specified by using a 2/3-list/tuple like\n    ``[data, MPI.DOUBLE]``, or ``[data, count, MPI.DOUBLE]`` (the\n    former one uses the byte-size of ``data`` and the extent of the\n    MPI datatype to define the ``count``).\n\n* Indexing a communicator with an integer returned a special object\n  associating the communication with a target rank, alleviating you\n  from specifying source/destination/root arguments in point-to-point\n  and collective communications. This functionality is no longer\n  available, expressions like::\n\n     MPI.COMM_WORLD[0].Send(...)\n     MPI.COMM_WORLD[0].Recv(...)\n     MPI.COMM_WORLD[0].Bcast(...)\n\n  have to be replaced by::\n\n     MPI.COMM_WORLD.Send(..., dest=0)\n     MPI.COMM_WORLD.Recv(..., source=0)\n     MPI.COMM_WORLD.Bcast(..., root=0)\n\n* Automatic MPI initialization (i.e., at import time) requests the\n  maximum level of MPI thread support (i.e., it is done by calling\n  ``MPI_Init_thread()`` and passing ``MPI_THREAD_MULTIPLE``). In case\n  you need to change this behavior, you can tweak the contents of the\n  ``mpi4py.rc`` module.\n\n* In order to obtain the values of predefined attributes attached to\n  the world communicator, now you have to use the ``Get_attr()``\n  method on the ``MPI.COMM_WORLD`` instance::\n\n     tag_ub = MPI.COMM_WORLD.Get_attr(MPI.TAG_UB)\n\n* In the previous implementation, ``MPI.COMM_WORLD`` and\n  ``MPI.COMM_SELF`` were associated to **duplicates** of the (C-level)\n  ``MPI_COMM_WORLD`` and ``MPI_COMM_SELF`` predefined communicator\n  handles. Now this is no longer the case, ``MPI.COMM_WORLD`` and\n  ``MPI.COMM_SELF`` proxies the **actual** ``MPI_COMM_WORLD`` and\n  ``MPI_COMM_SELF`` handles.\n\n* Convenience aliases ``MPI.WORLD`` and ``MPI.SELF`` were removed. Use\n  instead ``MPI.COMM_WORLD`` and ``MPI.COMM_SELF``.\n\n* Convenience constants ``MPI.WORLD_SIZE`` and ``MPI.WORLD_RANK`` were\n  removed. Use instead ``MPI.COMM_WORLD.Get_size()`` and\n  ``MPI.COMM_WORLD.Get_rank()``.\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-mpi4py-develop-q3si5cimpjfefak4g5hq7sptgxfjsgpd/spack-src/demo/wrap-cffi/helloworld.py": "from mpi4py import MPI\nimport cffi\nimport os\n\n_libdir = os.path.dirname(__file__)\n\nffi = cffi.FFI()\nif MPI._sizeof(MPI.Comm) == ffi.sizeof('int'):\n    _mpi_comm_t = 'int'\nelse:\n    _mpi_comm_t = 'void*'\nffi.cdef(\"\"\"\ntypedef %(_mpi_comm_t)s MPI_Comm;\nvoid sayhello(MPI_Comm);\n\"\"\" % vars())\nlib = ffi.dlopen(os.path.join(_libdir, \"libhelloworld.so\"))\n\ndef sayhello(comm):\n    comm_ptr = MPI._addressof(comm)\n    comm_val = ffi.cast('MPI_Comm*', comm_ptr)[0]\n    lib.sayhello(comm_val)\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-mpi4py-develop-q3si5cimpjfefak4g5hq7sptgxfjsgpd/spack-src/src/dynload.c": "/* Author:  Lisandro Dalcin\n * Contact: dalcinl@gmail.com\n */\n\n#include \"Python.h\"\n#include \"dynload.h\"\n\nstatic PyObject *\ndl_dlopen(PyObject *self, PyObject *args)\n{\n  void *handle = NULL;\n  char *filename = NULL;\n  int mode = 0;\n  (void)self; /* unused */\n  if (!PyArg_ParseTuple(args, (char *)\"zi:dlopen\",\n                        &filename, &mode)) return NULL;\n  handle = dlopen(filename, mode);\n  return PyLong_FromVoidPtr(handle);\n}\n\nstatic PyObject *\ndl_dlsym(PyObject *self, PyObject *args)\n{\n  PyObject *arg0 = NULL;\n  void *handle = NULL;\n  char *symbol = NULL;\n  void *symval = NULL;\n  (void)self; /* unused */\n  if (!PyArg_ParseTuple(args, (char *)\"Os:dlsym\",\n                        &arg0, &symbol)) return NULL;\n#ifdef RTLD_DEFAULT\n  handle = (void *)RTLD_DEFAULT;\n#endif\n  if (arg0 != Py_None) {\n    handle = PyLong_AsVoidPtr(arg0);\n    if (PyErr_Occurred()) return NULL;\n  }\n  symval = dlsym(handle, symbol);\n  return PyLong_FromVoidPtr(symval);\n}\n\nstatic PyObject *\ndl_dlclose(PyObject *self, PyObject *arg0)\n{\n  int err = 0;\n  void *handle = NULL;\n  (void)self; /* unused */\n  if (arg0 != Py_None) {\n    handle = PyLong_AsVoidPtr(arg0);\n    if (PyErr_Occurred()) return NULL;\n  }\n  if (handle)\n    err = dlclose(handle);\n  return Py_BuildValue((char *)\"i\", err);\n}\n\nstatic PyObject *\ndl_dlerror(PyObject *self, PyObject *args)\n{\n  char *errmsg = NULL;\n  (void)self; (void)args; /* unused */\n  errmsg = dlerror();\n  return Py_BuildValue((char *)\"z\", errmsg);\n}\n\nstatic PyMethodDef dl_methods[] = {\n  { (char *)\"dlopen\",  dl_dlopen,  METH_VARARGS, NULL },\n  { (char *)\"dlsym\",   dl_dlsym,   METH_VARARGS, NULL },\n  { (char *)\"dlclose\", dl_dlclose, METH_O,       NULL },\n  { (char *)\"dlerror\", dl_dlerror, METH_NOARGS,  NULL },\n  { (char *)NULL,      NULL,       0,            NULL } /* sentinel */\n};\n\nPyDoc_STRVAR(dl_doc,\n\"POSIX dynamic linking loader\");\n\n#if PY_MAJOR_VERSION >= 3\nstatic struct PyModuleDef dl_module = {\n  PyModuleDef_HEAD_INIT, /* m_base     */\n  (char *)\"dl\",          /* m_name     */\n  dl_doc,                /* m_doc      */\n  -1,                    /* m_size     */\n  dl_methods,            /* m_methods  */\n  NULL,                  /* m_reload   */\n  NULL,                  /* m_traverse */\n  NULL,                  /* m_clear    */\n  NULL                   /* m_free     */\n};\n#endif\n\n#if !defined(PyModule_AddIntMacro)\n#define PyModule_AddIntMacro(m, c) \\\n  PyModule_AddIntConstant(m, (char *)#c, c)\n#endif\n\n#define PyModule_AddPtrMacro(m, c) \\\n  PyModule_AddObject(m, (char *)#c, PyLong_FromVoidPtr((void *)c))\n\n\n#if PY_MAJOR_VERSION >= 3\nPyMODINIT_FUNC PyInit_dl(void);\nPyMODINIT_FUNC PyInit_dl(void)\n#else\nPyMODINIT_FUNC initdl(void);\nPyMODINIT_FUNC initdl(void)\n#endif\n{\n  PyObject *m = NULL;\n\n#if PY_MAJOR_VERSION >= 3\n  m = PyModule_Create(&dl_module);\n#else\n  m = Py_InitModule3((char *)\"dl\", dl_methods, (char *)dl_doc);\n#endif\n  if (!m) goto bad;\n\n  if (PyModule_AddIntMacro(m, RTLD_LAZY   ) < 0) goto bad;\n  if (PyModule_AddIntMacro(m, RTLD_NOW    ) < 0) goto bad;\n  if (PyModule_AddIntMacro(m, RTLD_LOCAL  ) < 0) goto bad;\n  if (PyModule_AddIntMacro(m, RTLD_GLOBAL ) < 0) goto bad;\n\n#ifdef RTLD_NOLOAD\n  if (PyModule_AddIntMacro(m, RTLD_NOLOAD   ) < 0) goto bad;\n#endif\n#ifdef RTLD_NODELETE\n  if (PyModule_AddIntMacro(m, RTLD_NODELETE ) < 0) goto bad;\n#endif\n#ifdef RTLD_DEEPBIND\n  if (PyModule_AddIntMacro(m, RTLD_DEEPBIND ) < 0) goto bad;\n#endif\n#ifdef RTLD_FIRST\n  if (PyModule_AddIntMacro(m, RTLD_FIRST    ) < 0) goto bad;\n#endif\n\n#ifdef RTLD_DEFAULT\n  if (PyModule_AddPtrMacro(m, RTLD_DEFAULT)   < 0) goto bad;\n#endif\n#ifdef RTLD_NEXT\n  if (PyModule_AddPtrMacro(m, RTLD_NEXT)      < 0) goto bad;\n#endif\n\n#ifdef RTLD_SELF\n  if (PyModule_AddPtrMacro(m, RTLD_SELF)      < 0) goto bad;\n#endif\n#ifdef RTLD_MAIN_ONLY\n  if (PyModule_AddPtrMacro(m, RTLD_MAIN_ONLY) < 0) goto bad;\n#endif\n\n finally:\n#if PY_MAJOR_VERSION >= 3\n  return m;\n#else\n  return;\n#endif\n\n bad:\n  Py_XDECREF(m);\n  m = NULL;\n  goto finally;\n}\n\n/*\n  Local variables:\n  c-basic-offset: 2\n  indent-tabs-mode: nil\n  End:\n*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-mpi4py-develop-q3si5cimpjfefak4g5hq7sptgxfjsgpd/spack-src/src/dynload.h": "/* Author:  Lisandro Dalcin\n * Contact: dalcinl@gmail.com\n */\n\n#ifndef PyMPI_DYNLOAD_H\n#define PyMPI_DYNLOAD_H\n\n#if HAVE_DLFCN_H\n  #include <dlfcn.h>\n#else\n  #if defined(__linux) || defined(__linux__)\n    #define RTLD_LAZY     0x00001\n    #define RTLD_NOW      0x00002\n    #define RTLD_LOCAL    0x00000\n    #define RTLD_GLOBAL   0x00100\n    #define RTLD_NOLOAD   0x00004\n    #define RTLD_NODELETE 0x01000\n    #define RTLD_DEEPBIND 0x00008\n  #elif defined(__sun) || defined(__sun__)\n    #define RTLD_LAZY     0x00001\n    #define RTLD_NOW      0x00002\n    #define RTLD_LOCAL    0x00000\n    #define RTLD_GLOBAL   0x00100\n    #define RTLD_NOLOAD   0x00004\n    #define RTLD_NODELETE 0x01000\n    #define RTLD_FIRST    0x02000\n  #elif defined(__APPLE__)\n    #define RTLD_LAZY     0x1\n    #define RTLD_NOW      0x2\n    #define RTLD_LOCAL    0x4\n    #define RTLD_GLOBAL   0x8\n    #define RTLD_NOLOAD   0x10\n    #define RTLD_NODELETE 0x80\n    #define RTLD_FIRST    0x100\n  #elif defined(__CYGWIN__)\n    #define RTLD_LAZY     1\n    #define RTLD_NOW      2\n    #define RTLD_LOCAL    0\n    #define RTLD_GLOBAL   4\n  #endif\n  #if defined(__cplusplus)\n  extern \"C\" {\n  #endif\n  extern void *dlopen(const char *, int);\n  extern void *dlsym(void *, const char *);\n  extern int   dlclose(void *);\n  extern char *dlerror(void);\n  #if defined(__cplusplus)\n  }\n  #endif\n#endif\n\n#ifndef RTLD_LAZY\n#define RTLD_LAZY 1\n#endif\n#ifndef RTLD_NOW\n#define RTLD_NOW RTLD_LAZY\n#endif\n#ifndef RTLD_LOCAL\n#define RTLD_LOCAL 0\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL RTLD_LOCAL\n#endif\n\n#endif /* !PyMPI_DYNLOAD_H */\n\n/*\n  Local variables:\n  c-basic-offset: 2\n  indent-tabs-mode: nil\n  End:\n*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-mpi4py-develop-q3si5cimpjfefak4g5hq7sptgxfjsgpd/spack-src/src/lib-mpi/compat/sicortex.h": "#ifndef PyMPI_COMPAT_SICORTEX_H\n#define PyMPI_COMPAT_SICORTEX_H\n\n#include \"../../dynload.h\"\n\nstatic void PyMPI_SCMPI_dlopen_libslurm(void)\n{\n  (void)dlopen(\"libslurm.so\", RTLD_NOW|RTLD_GLOBAL|RTLD_NOLOAD);\n  (void)dlerror();\n}\n\nstatic int PyMPI_SCMPI_MPI_Init(int *argc, char ***argv)\n{\n  PyMPI_SCMPI_dlopen_libslurm();\n  return MPI_Init(argc, argv);\n}\n#undef  MPI_Init\n#define MPI_Init PyMPI_SCMPI_MPI_Init\n\nstatic int PyMPI_SCMPI_MPI_Init_thread(int *argc, char ***argv,\n                                       int required, int *provided)\n{\n  PyMPI_SCMPI_dlopen_libslurm();\n  return MPI_Init_thread(argc, argv, required, provided);\n}\n#undef  MPI_Init_thread\n#define MPI_Init_thread PyMPI_SCMPI_MPI_Init_thread\n\n#endif /* !PyMPI_COMPAT_SICORTEX_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-mpi4py-develop-q3si5cimpjfefak4g5hq7sptgxfjsgpd/spack-src/src/lib-mpi/compat/pcmpi.h": "#ifndef PyMPI_COMPAT_PCMPI_H\n#define PyMPI_COMPAT_PCMPI_H\n\n/* ---------------------------------------------------------------- */\n\nstatic int PyMPI_PCMPI_MPI_Request_get_status(MPI_Request request,\n                                              int *flag,\n                                              MPI_Status *status)\n{\n  MPI_Status sts;\n  if (!status ||\n      status == MPI_STATUS_IGNORE ||\n      status == MPI_STATUSES_IGNORE) status = &sts;\n  return MPI_Request_get_status(request, flag, status);\n}\n#undef  MPI_Request_get_status\n#define MPI_Request_get_status PyMPI_PCMPI_MPI_Request_get_status\n\n/* ---------------------------------------------------------------- */\n\nstatic int PyMPI_PCMPI_MPI_Win_get_attr(MPI_Win win,\n                                        int keyval,\n                                        void *attrval,\n                                        int *flag)\n{\n  int ierr;\n  ierr = MPI_Win_get_attr(win, keyval, attrval, flag);\n  if (ierr == MPI_SUCCESS && keyval == MPI_WIN_BASE && *flag)\n    *((void **)attrval) = **((void ***)attrval);\n  return ierr;\n}\n#undef  MPI_Win_get_attr\n#define MPI_Win_get_attr PyMPI_PCMPI_MPI_Win_get_attr\n\n/* ---------------------------------------------------------------- */\n\n#ifndef PCMPI_DLOPEN_LIBMPI\n#define PCMPI_DLOPEN_LIBMPI 1\n#endif\n\n#if PCMPI_DLOPEN_LIBMPI\n#if HAVE_DLOPEN\n\n#include \"../../dynload.h\"\n\nstatic void PyMPI_PCMPI_dlopen_libmpi(void)\n{\n  void *handle1 = (void *)0;\n  void *handle2 = (void *)0;\n  int mode = RTLD_NOW | RTLD_GLOBAL;\n  #ifdef RTLD_NOLOAD\n  mode |= RTLD_NOLOAD;\n  #endif\n#if defined(__APPLE__)\n  if (!handle1) handle1 = dlopen(\"libmpi.2.dylib\", mode);\n  if (!handle1) handle1 = dlopen(\"libmpi.1.dylib\", mode);\n  if (!handle1) handle1 = dlopen(\"libmpi.dylib\", mode);\n  if (!handle2) handle2 = dlopen(\"libmpio.2.dylib\", mode);\n  if (!handle2) handle2 = dlopen(\"libmpio.1.dylib\", mode);\n  if (!handle2) handle2 = dlopen(\"libmpio.dylib\", mode);\n#else\n  if (!handle1) handle1 = dlopen(\"libmpi.so.2\", mode);\n  if (!handle1) handle1 = dlopen(\"libmpi.so.1\", mode);\n  if (!handle1) handle1 = dlopen(\"libmpi.so\", mode);\n  if (!handle2) handle2 = dlopen(\"libmpio.so.2\", mode);\n  if (!handle2) handle2 = dlopen(\"libmpio.so.1\", mode);\n  if (!handle2) handle2 = dlopen(\"libmpio.so\", mode);\n#endif\n}\n\nstatic int PyMPI_PCMPI_MPI_Init(int *argc, char ***argv)\n{\n  PyMPI_PCMPI_dlopen_libmpi();\n  return MPI_Init(argc, argv);\n}\n#undef  MPI_Init\n#define MPI_Init PyMPI_PCMPI_MPI_Init\n\nstatic int PyMPI_PCMPI_MPI_Init_thread(int *argc, char ***argv,\n                                       int required, int *provided)\n{\n  PyMPI_PCMPI_dlopen_libmpi();\n  return MPI_Init_thread(argc, argv, required, provided);\n}\n#undef  MPI_Init_thread\n#define MPI_Init_thread PyMPI_PCMPI_MPI_Init_thread\n\n#endif /* !HAVE_DLOPEN */\n#endif /* !PCMPI_DLOPEN_LIBMPI */\n\n/* ---------------------------------------------------------------- */\n\n#endif /* !PyMPI_COMPAT_PCMPI_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-mpi4py-develop-q3si5cimpjfefak4g5hq7sptgxfjsgpd/spack-src/src/lib-mpi/compat/openmpi.h": "#ifndef PyMPI_COMPAT_OPENMPI_H\n#define PyMPI_COMPAT_OPENMPI_H\n\n/* ------------------------------------------------------------------------- */\n/* ------------------------------------------------------------------------- */\n\n/*\n * The hackery below redefines the actuall calls to 'MPI_Init()' and\n * 'MPI_Init_thread()' in order to preload the main MPI dynamic\n * library with appropriate flags to 'dlopen()' ensuring global\n * availability of library symbols.\n */\n\n#if !defined(OPENMPI_DLOPEN_LIBMPI) && defined(OMPI_MAJOR_VERSION)\n#if OMPI_MAJOR_VERSION >= 3 && OMPI_MAJOR_VERSION < 10\n#define OPENMPI_DLOPEN_LIBMPI 0\n#endif\n#endif\n\n#ifndef OPENMPI_DLOPEN_LIBMPI\n#define OPENMPI_DLOPEN_LIBMPI 1\n#endif\n\n#if OPENMPI_DLOPEN_LIBMPI\n#if HAVE_DLOPEN\n\n#include \"../../dynload.h\"\n\n/*\nstatic void * my_dlopen(const char *name, int mode) {\n  void *handle;\n  static int called = 0;\n  if (!called) {\n    called = 1;\n    #if HAVE_DLFCN_H\n    printf(\"HAVE_DLFCN_H: yes\\n\");\n    #else\n    printf(\"HAVE_DLFCN_H: no\\n\");\n    #endif\n    printf(\"\\n\");\n    printf(\"RTLD_LAZY:    0x%X\\n\", RTLD_LAZY   );\n    printf(\"RTLD_NOW:     0x%X\\n\", RTLD_NOW    );\n    printf(\"RTLD_LOCAL:   0x%X\\n\", RTLD_LOCAL  );\n    printf(\"RTLD_GLOBAL:  0x%X\\n\", RTLD_GLOBAL );\n    #ifdef RTLD_NOLOAD\n    printf(\"RTLD_NOLOAD:  0x%X\\n\", RTLD_NOLOAD );\n    #endif\n    printf(\"\\n\");\n  }\n  handle = dlopen(name, mode);\n  printf(\"dlopen(\\\"%s\\\",0x%X) -> %p\\n\", name, mode, handle);\n  printf(\"dlerror() -> %s\\n\\n\", dlerror());\n  return handle;\n}\n#define dlopen my_dlopen\n*/\n\nstatic void PyMPI_OPENMPI_dlopen_libmpi(void)\n{\n  void *handle = 0;\n  int mode = RTLD_NOW | RTLD_GLOBAL;\n#if defined(__APPLE__)\n  /* macOS */\n  #ifdef RTLD_NOLOAD\n  mode |= RTLD_NOLOAD;\n  #endif\n  #if defined(OMPI_MAJOR_VERSION)\n  #if OMPI_MAJOR_VERSION == 3\n  if (!handle) handle = dlopen(\"libmpi.40.dylib\", mode);\n  #elif OMPI_MAJOR_VERSION == 2\n  if (!handle) handle = dlopen(\"libmpi.20.dylib\", mode);\n  #elif OMPI_MAJOR_VERSION == 1 && OMPI_MINOR_VERSION >= 10\n  if (!handle) handle = dlopen(\"libmpi.12.dylib\", mode);\n  #elif OMPI_MAJOR_VERSION == 1 && OMPI_MINOR_VERSION >= 6\n  if (!handle) handle = dlopen(\"libmpi.1.dylib\", mode);\n  #elif OMPI_MAJOR_VERSION == 1\n  if (!handle) handle = dlopen(\"libmpi.0.dylib\", mode);\n  #endif\n  #endif\n  if (!handle) handle = dlopen(\"libmpi.dylib\", mode);\n#else\n  /* GNU/Linux and others */\n  #ifdef RTLD_NOLOAD\n  mode |= RTLD_NOLOAD;\n  #endif\n  #if defined(OMPI_MAJOR_VERSION)\n  #if OMPI_MAJOR_VERSION >= 10 /* IBM Spectrum MPI */\n  if (!handle) handle = dlopen(\"libmpi_ibm.so.2\", mode);\n  if (!handle) handle = dlopen(\"libmpi_ibm.so.1\", mode);\n  if (!handle) handle = dlopen(\"libmpi_ibm.so\", mode);\n  #elif OMPI_MAJOR_VERSION == 3\n  if (!handle) handle = dlopen(\"libmpi.so.40\", mode);\n  #elif OMPI_MAJOR_VERSION == 2\n  if (!handle) handle = dlopen(\"libmpi.so.20\", mode);\n  #elif OMPI_MAJOR_VERSION == 1 && OMPI_MINOR_VERSION >= 10\n  if (!handle) handle = dlopen(\"libmpi.so.12\", mode);\n  #elif OMPI_MAJOR_VERSION == 1 && OMPI_MINOR_VERSION >= 6\n  if (!handle) handle = dlopen(\"libmpi.so.1\", mode);\n  #elif OMPI_MAJOR_VERSION == 1\n  if (!handle) handle = dlopen(\"libmpi.so.0\", mode);\n  #endif\n  #endif\n  if (!handle) handle = dlopen(\"libmpi.so\", mode);\n#endif\n}\n\nstatic int PyMPI_OPENMPI_MPI_Init(int *argc, char ***argv)\n{\n  PyMPI_OPENMPI_dlopen_libmpi();\n  return MPI_Init(argc, argv);\n}\n#undef  MPI_Init\n#define MPI_Init PyMPI_OPENMPI_MPI_Init\n\nstatic int PyMPI_OPENMPI_MPI_Init_thread(int *argc, char ***argv,\n                                         int required, int *provided)\n{\n  PyMPI_OPENMPI_dlopen_libmpi();\n  return MPI_Init_thread(argc, argv, required, provided);\n}\n#undef  MPI_Init_thread\n#define MPI_Init_thread PyMPI_OPENMPI_MPI_Init_thread\n\n#endif /* !HAVE_DLOPEN */\n#endif /* !OPENMPI_DLOPEN_LIBMPI */\n\n/* ------------------------------------------------------------------------- */\n/* ------------------------------------------------------------------------- */\n\n\n/* ------------------------------------------------------------------------- */\n\n#if (defined(OMPI_MAJOR_VERSION) && \\\n     defined(OMPI_MINOR_VERSION) && \\\n     defined(OMPI_RELEASE_VERSION))\n#define PyMPI_OPENMPI_VERSION ((OMPI_MAJOR_VERSION   * 10000) + \\\n                               (OMPI_MINOR_VERSION   * 100)   + \\\n                               (OMPI_RELEASE_VERSION * 1))\n#else\n#define PyMPI_OPENMPI_VERSION 10000\n#endif\n\n/* ------------------------------------------------------------------------- */\n\n/*\n * Open MPI < 1.1.3 generates an error when MPI_File_get_errhandler()\n * is called with the predefined error handlers MPI_ERRORS_RETURN and\n * MPI_ERRORS_ARE_FATAL.\n */\n\n#if PyMPI_OPENMPI_VERSION < 10103\n\nstatic int PyMPI_OPENMPI_Errhandler_free(MPI_Errhandler *errhandler)\n{\n  if (errhandler && ((*errhandler == MPI_ERRORS_RETURN) ||\n                     (*errhandler == MPI_ERRORS_ARE_FATAL))) {\n    *errhandler = MPI_ERRHANDLER_NULL;\n    return MPI_SUCCESS;\n  }\n  return MPI_Errhandler_free(errhandler);\n}\n#undef  MPI_Errhandler_free\n#define MPI_Errhandler_free PyMPI_OPENMPI_Errhandler_free\n\n#endif /* !(PyMPI_OPENMPI_VERSION < 10103) */\n\n/* ------------------------------------------------------------------------- */\n\n/*\n * Open MPI 1.1 generates an error when MPI_File_get_errhandler() is\n * called with the MPI_FILE_NULL handle.  The code below try to fix\n * this bug by intercepting the calls to the functions setting and\n * getting the error handlers for MPI_File's.\n */\n\n#if PyMPI_OPENMPI_VERSION < 10200\n\nstatic MPI_Errhandler PyMPI_OPENMPI_FILE_NULL_ERRHANDLER = (MPI_Errhandler)0;\n\nstatic int PyMPI_OPENMPI_File_get_errhandler(MPI_File file,\n                                             MPI_Errhandler *errhandler)\n{\n  if (file == MPI_FILE_NULL) {\n    if (PyMPI_OPENMPI_FILE_NULL_ERRHANDLER == (MPI_Errhandler)0) {\n      PyMPI_OPENMPI_FILE_NULL_ERRHANDLER = MPI_ERRORS_RETURN;\n    }\n    *errhandler = PyMPI_OPENMPI_FILE_NULL_ERRHANDLER;\n    return MPI_SUCCESS;\n  }\n  return MPI_File_get_errhandler(file, errhandler);\n}\n#undef  MPI_File_get_errhandler\n#define MPI_File_get_errhandler PyMPI_OPENMPI_File_get_errhandler\n\nstatic int PyMPI_OPENMPI_File_set_errhandler(MPI_File file,\n                                             MPI_Errhandler errhandler)\n{\n  int ierr = MPI_File_set_errhandler(file, errhandler);\n  if (ierr != MPI_SUCCESS) return ierr;\n  if (file == MPI_FILE_NULL) {\n    PyMPI_OPENMPI_FILE_NULL_ERRHANDLER = errhandler;\n  }\n  return ierr;\n}\n#undef  MPI_File_set_errhandler\n#define MPI_File_set_errhandler PyMPI_OPENMPI_File_set_errhandler\n\n#endif /* !(PyMPI_OPENMPI_VERSION < 10200) */\n\n/* ---------------------------------------------------------------- */\n\n#if PyMPI_OPENMPI_VERSION < 10301\n\nstatic MPI_Fint PyMPI_OPENMPI_File_c2f(MPI_File file)\n{\n  if (file == MPI_FILE_NULL) return (MPI_Fint)0;\n  return MPI_File_c2f(file);\n}\n#define MPI_File_c2f PyMPI_OPENMPI_File_c2f\n\n#endif /* !(PyMPI_OPENMPI_VERSION < 10301) */\n\n/* ------------------------------------------------------------------------- */\n\n#if PyMPI_OPENMPI_VERSION < 10402\n\nstatic int PyMPI_OPENMPI_MPI_Cancel(MPI_Request *request)\n{\n  if (request && *request == MPI_REQUEST_NULL) {\n    MPI_Comm_call_errhandler(MPI_COMM_WORLD, MPI_ERR_REQUEST);\n    return MPI_ERR_REQUEST;\n  }\n  return MPI_Cancel(request);\n}\n#undef  MPI_Cancel\n#define MPI_Cancel PyMPI_OPENMPI_MPI_Cancel\n\nstatic int PyMPI_OPENMPI_MPI_Request_free(MPI_Request *request)\n{\n  if (request && *request == MPI_REQUEST_NULL) {\n    MPI_Comm_call_errhandler(MPI_COMM_WORLD, MPI_ERR_REQUEST);\n    return MPI_ERR_REQUEST;\n  }\n  return MPI_Request_free(request);\n}\n#undef  MPI_Request_free\n#define MPI_Request_free PyMPI_OPENMPI_MPI_Request_free\n\nstatic int PyMPI_OPENMPI_MPI_Win_get_errhandler(MPI_Win win,\n                                                MPI_Errhandler *errhandler)\n{\n  if (win == MPI_WIN_NULL) {\n    MPI_Comm_call_errhandler(MPI_COMM_WORLD, MPI_ERR_WIN);\n    return MPI_ERR_WIN;\n  }\n  return MPI_Win_get_errhandler(win, errhandler);\n}\n#undef  MPI_Win_get_errhandler\n#define MPI_Win_get_errhandler PyMPI_OPENMPI_MPI_Win_get_errhandler\n\nstatic int PyMPI_OPENMPI_MPI_Win_set_errhandler(MPI_Win win,\n                                                MPI_Errhandler errhandler)\n{\n  if (win == MPI_WIN_NULL) {\n    MPI_Comm_call_errhandler(MPI_COMM_WORLD, MPI_ERR_WIN);\n    return MPI_ERR_WIN;\n  }\n  return MPI_Win_set_errhandler(win, errhandler);\n}\n#undef  MPI_Win_set_errhandler\n#define MPI_Win_set_errhandler PyMPI_OPENMPI_MPI_Win_set_errhandler\n\n#endif /* !(PyMPI_OPENMPI_VERSION < 10402) */\n\n/* ------------------------------------------------------------------------- */\n\n/*\n * Open MPI 1.7 tries to set status even in the case of MPI_STATUS_IGNORE.\n */\n\n#if PyMPI_OPENMPI_VERSION >= 10700 && PyMPI_OPENMPI_VERSION < 10800\nstatic int PyMPI_OPENMPI_MPI_Mrecv(void *buf, int count, MPI_Datatype type,\n                                   MPI_Message *message, MPI_Status *status)\n{\n  MPI_Status sts; if (status == MPI_STATUS_IGNORE) status = &sts;\n  return MPI_Mrecv(buf, count, type, message, status);\n}\n#undef  MPI_Mrecv\n#define MPI_Mrecv PyMPI_OPENMPI_MPI_Mrecv\n#endif  /* !(PyMPI_OPENMPI_VERSION > 10700) */\n\n/* ------------------------------------------------------------------------- */\n\n/*\n * Open MPI < 1.10.3 errors with MPI_Get_address(MPI_BOTTOM, &address).\n */\n\n#if PyMPI_OPENMPI_VERSION < 11003\n\nstatic int PyMPI_OPENMPI_Get_address(const void *location, MPI_Aint *address)\n{\n  if (location == MPI_BOTTOM && address) {\n    *address = 0;\n    return MPI_SUCCESS;\n  }\n  return MPI_Get_address(location, address);\n}\n#undef  MPI_Get_address\n#define MPI_Get_address PyMPI_OPENMPI_Get_address\n\n#endif\n\n/* ------------------------------------------------------------------------- */\n\n#endif /* !PyMPI_COMPAT_OPENMPI_H */\n\n/*\n  Local Variables:\n  c-basic-offset: 2\n  indent-tabs-mode: nil\n  End:\n*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-mpi4py-develop-q3si5cimpjfefak4g5hq7sptgxfjsgpd/spack-src/src/mpi4py/__init__.py": "# Author:  Lisandro Dalcin\n# Contact: dalcinl@gmail.com\n\"\"\"\nThis is the **MPI for Python** package.\n\nWhat is *MPI*?\n==============\n\nThe *Message Passing Interface*, is a standardized and portable\nmessage-passing system designed to function on a wide variety of\nparallel computers. The standard defines the syntax and semantics of\nlibrary routines and allows users to write portable programs in the\nmain scientific programming languages (Fortran, C, or C++). Since\nits release, the MPI specification has become the leading standard\nfor message-passing libraries for parallel computers.\n\nWhat is *MPI for Python*?\n=========================\n\n*MPI for Python* provides MPI bindings for the Python programming\nlanguage, allowing any Python program to exploit multiple processors.\nThis package is constructed on top of the MPI-1/2 specifications and\nprovides an object oriented interface which closely follows MPI-2 C++\nbindings.\n\"\"\"\n\n__version__ = '3.1.0a0'\n__author__ = 'Lisandro Dalcin'\n__credits__ = 'MPI Forum, MPICH Team, Open MPI Team'\n\n\n__all__ = ['MPI']\n\n\nclass Rc:\n    \"\"\"Runtime configuration options.\n\n    Attributes\n    ----------\n    initialize : bool\n        Automatic MPI initialization at import (default: True).\n    threads : bool\n        Request for thread support (default: True).\n    thread_level : {'multiple', 'serialized', 'funneled', 'single'}\n        Level of thread support to request (default: 'multiple').\n    finalize : None or bool\n        Automatic MPI finalization at exit (default: None).\n    fast_reduce : bool\n        Use tree-based reductions for objects (default: True).\n    recv_mprobe : bool\n        Use matched probes to receive objects (default: True).\n    errors : {'exception', 'default', 'fatal'}\n        Error handling policy (default: 'exception').\n\n    \"\"\"\n\n    initialize = True\n    threads = True\n    thread_level = 'multiple'\n    finalize = None\n    fast_reduce = True\n    recv_mprobe = True\n    errors = 'exception'\n\n    def __init__(self, **kwargs):\n        self(**kwargs)\n\n    def __call__(self, **kwargs):\n        for key in kwargs:\n            if not hasattr(self, key):\n                raise TypeError(\"unexpected argument '{0}'\".format(key))\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n\n    def __repr__(self):\n        return '<{0}.rc>'.format(__name__)\n\n\nrc = Rc()\n__import__('sys').modules[__name__ + '.rc'] = rc\n\n\ndef get_include():\n    \"\"\"Return the directory in the package that contains header files.\n\n    Extension modules that need to compile against mpi4py should use\n    this function to locate the appropriate include directory. Using\n    Python distutils (or perhaps NumPy distutils)::\n\n      import mpi4py\n      Extension('extension_name', ...\n                include_dirs=[..., mpi4py.get_include()])\n\n    \"\"\"\n    # pylint: disable=import-outside-toplevel\n    from os.path import join, dirname\n    return join(dirname(__file__), 'include')\n\n\ndef get_config():\n    \"\"\"Return a dictionary with information about MPI.\"\"\"\n    # pylint: disable=import-outside-toplevel\n    from os.path import join, dirname\n    from configparser import ConfigParser\n    parser = ConfigParser()\n    parser.read(join(dirname(__file__), 'mpi.cfg'))\n    return dict(parser.items('mpi'))\n\n\ndef profile(name, *, path=None, logfile=None):\n    \"\"\"Support for the MPI profiling interface.\n\n    Parameters\n    ----------\n    name : str\n       Name of the profiler library to load.\n    path : sequence of str, optional\n       Additional paths to search for the profiler.\n    logfile : str, optional\n       Filename prefix for dumping profiler output.\n\n    \"\"\"\n    # pylint: disable=import-outside-toplevel\n    import os\n    import sys\n    from .dl import dlopen, dlerror, RTLD_NOW, RTLD_GLOBAL\n\n    def lookup_dylib(name, path):\n        # pylint: disable=missing-docstring\n        pattern = []\n        if sys.platform.startswith('win'):  # pragma: no cover\n            pattern.append(('', '.dll'))\n        elif sys.platform == 'darwin':  # pragma: no cover\n            pattern.append(('lib', '.dylib'))\n        elif os.name == 'posix':  # pragma: no cover\n            pattern.append(('lib', '.so'))\n        pattern.append(('', ''))\n        for pth in path:\n            for (lib, dso) in pattern:\n                filename = os.path.join(pth, lib + name + dso)\n                if os.path.isfile(filename):\n                    return os.path.abspath(filename)\n        return None\n\n    if logfile:\n        if name in ('mpe',):\n            if 'MPE_LOGFILE_PREFIX' not in os.environ:\n                os.environ['MPE_LOGFILE_PREFIX'] = logfile\n        if name in ('vt', 'vt-mpi', 'vt-hyb'):\n            if 'VT_FILE_PREFIX' not in os.environ:\n                os.environ['VT_FILE_PREFIX'] = logfile\n\n    if path is None:\n        path = []\n    elif isinstance(path, str):\n        path = [path]\n    else:\n        path = list(path)\n    prefix = os.path.dirname(__file__)\n    path.append(os.path.join(prefix, 'lib-pmpi'))\n    filename = lookup_dylib(name, path)\n    if filename is None:\n        raise ValueError(\"profiler '{0}' not found\".format(name))\n\n    handle = dlopen(filename, RTLD_NOW | RTLD_GLOBAL)\n    if handle:\n        registry = vars(profile).setdefault('registry', [])\n        registry.append((name, (handle, filename)))\n    else:\n        from warnings import warn\n        warn(dlerror())\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-mpi4py-develop-q3si5cimpjfefak4g5hq7sptgxfjsgpd/spack-src/src/mpi4py/dl.pyi": "import sys\nfrom typing import Final, Optional\n\nPath = str\nHandle = int\nAddress = int\n\nRTLD_LAZY: Final[int] = ...\nRTLD_NOW: Final[int] = ...\nRTLD_GLOBAL: Final[int] = ...\nRTLD_LOCAL: Final[int] = ...\n\nRTLD_NOLOAD: Final[int] = ...\nRTLD_NODELETE: Final[int] = ...\nif sys.platform == 'linux':\n    RTLD_DEEPBIND: Final[int] = ...\nif sys.platform == 'darwin':\n    RTLD_FIRST: Final[int] = ...\n\nRTLD_DEFAULT: Final[Handle] = ...\nRTLD_NEXT: Final[Handle] = ...\nif sys.platform == 'darwin':\n    RTLD_SELF: Final[Handle] = ...\n    RTLD_MAIN_ONLY: Final[Handle] = ...\n\ndef dlopen(filename: Optional[Path], mode: int) -> Handle: ...\ndef dlclose(handle: Optional[Handle]) -> int: ...\ndef dlsym(handle: Optional[Handle], symbol: str) -> Address: ...\ndef dlerror() -> Optional[str]: ...\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-mpi4py-develop-q3si5cimpjfefak4g5hq7sptgxfjsgpd/spack-src/test/test_dl.py": "import mpiunittest as unittest\nimport sys, os\ntry:\n    from mpi4py import dl\nexcept ImportError:\n    dl = None\n\npypy_lt_510 = (hasattr(sys, 'pypy_version_info') and\n               sys.pypy_version_info < (5, 10))\n\ntry:\n    if pypy_lt_510:\n        ctypes = None\n    else:\n        import ctypes\nexcept ImportError:\n    ctypes = None\n\n@unittest.skipIf(dl is None, 'mpi4py-dl')\nclass TestDL(unittest.TestCase):\n\n    @unittest.skipIf(ctypes is None, 'ctypes')\n    def testDL1(self):\n        from ctypes.util import find_library\n        libm = find_library('m')\n\n        handle = dl.dlopen(libm, dl.RTLD_LOCAL|dl.RTLD_LAZY)\n        self.assertTrue(handle != 0)\n        self.assertTrue(dl.dlerror() is None)\n\n        symbol = dl.dlsym(handle, 'sqrt')\n        self.assertTrue(symbol != 0)\n        self.assertTrue(dl.dlerror() is None)\n\n        symbol = dl.dlsym(handle, 'xxxxx')\n        self.assertTrue(symbol == 0)\n        self.assertTrue(dl.dlerror() is not None)\n\n        ierr = dl.dlclose(handle)\n        self.assertTrue(ierr == 0)\n        self.assertTrue(dl.dlerror() is None)\n\n    @unittest.skipIf(pypy_lt_510 and sys.platform == 'darwin',\n                     'pypy(<5.10)|darwin')\n    def testDL2(self):\n        handle = dl.dlopen(None, dl.RTLD_GLOBAL|dl.RTLD_NOW)\n        self.assertTrue(handle != 0)\n        self.assertTrue(dl.dlerror() is None)\n\n        symbol = dl.dlsym(handle, 'malloc')\n        self.assertTrue(symbol != 0)\n        self.assertTrue(dl.dlerror() is None)\n\n        symbol = dl.dlsym(handle, '!@#$%^&*()')\n        self.assertTrue(symbol == 0)\n        self.assertTrue(dl.dlerror() is not None)\n\n        ierr = dl.dlclose(handle)\n        self.assertTrue(ierr == 0)\n        self.assertTrue(dl.dlerror() is None)\n\n    def testDL3(self):\n        symbol = dl.dlsym(None, 'malloc')\n        self.assertTrue(symbol != 0)\n        self.assertTrue(dl.dlerror() is None)\n\n        symbol = dl.dlsym(None, '!@#$%^&*()')\n        self.assertTrue(symbol == 0)\n        self.assertTrue(dl.dlerror() is not None)\n\n        ierr = dl.dlclose(None)\n        self.assertTrue(ierr == 0)\n        self.assertTrue(dl.dlerror() is None)\n\n    def testDL4(self):\n        handle = dl.dlopen('xxxxx', dl.RTLD_LOCAL|dl.RTLD_LAZY)\n        self.assertTrue(handle == 0)\n        self.assertTrue(dl.dlerror() is not None)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-mpi4py-develop-q3si5cimpjfefak4g5hq7sptgxfjsgpd/spack-src/.git/objects/pack/pack-3cc4b100f70b9cb8fab0e7b52b0247e260e3ae4a.idx",
        "/tmp/vanessa/spack-stage/spack-stage-py-mpi4py-develop-q3si5cimpjfefak4g5hq7sptgxfjsgpd/spack-src/.git/objects/pack/pack-3cc4b100f70b9cb8fab0e7b52b0247e260e3ae4a.pack"
    ],
    "total_files": 393
}