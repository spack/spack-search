{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-mercury-1.0.0-vxt7zf2ov43pvdom4nhfuhtyrngvqgax/spack-src/Testing/driver/kwsys/DynamicLoader.cxx": "/* Distributed under the OSI-approved BSD 3-Clause License.  See accompanying\n   file Copyright.txt or https://cmake.org/licensing#kwsys for details.  */\n#include \"kwsysPrivate.h\"\n#include KWSYS_HEADER(DynamicLoader.hxx)\n\n#include KWSYS_HEADER(Configure.hxx)\n\n// Work-around CMake dependency scanning limitation.  This must\n// duplicate the above list of headers.\n#if 0\n#include \"Configure.hxx.in\"\n#include \"DynamicLoader.hxx.in\"\n#endif\n\n// This file actually contains several different implementations:\n// * NOOP for environments without dynamic libs\n// * HP machines which uses shl_load\n// * Mac OS X 10.2.x and earlier which uses NSLinkModule\n// * Windows which uses LoadLibrary\n// * BeOS / Haiku\n// * FreeMiNT for Atari\n// * Default implementation for *NIX systems (including Mac OS X 10.3 and\n//   later) which use dlopen\n//\n// Each part of the ifdef contains a complete implementation for\n// the static methods of DynamicLoader.\n\n#if !KWSYS_SUPPORTS_SHARED_LIBS\n// Implementation for environments without dynamic libs\n#include <string.h> // for strerror()\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  return 0;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib) {\n    return 0;\n  }\n\n  return 1;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  return 0;\n}\n\nconst char* DynamicLoader::LastError()\n{\n  return \"General error\";\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(__hpux)\n// Implementation for HPUX machines\n#include <dl.h>\n#include <errno.h>\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  return shl_load(libname.c_str(), BIND_DEFERRED | DYNAMIC_PATH, 0L);\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib) {\n    return 0;\n  }\n  return !shl_unload(lib);\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  void* addr;\n  int status;\n\n  /* TYPE_PROCEDURE Look for a function or procedure. (This used to be default)\n   * TYPE_DATA      Look for a symbol in the data segment (for example,\n   * variables).\n   * TYPE_UNDEFINED Look for any symbol.\n   */\n  status = shl_findsym(&lib, sym.c_str(), TYPE_UNDEFINED, &addr);\n  void* result = (status < 0) ? (void*)0 : addr;\n\n  // Hack to cast pointer-to-data to pointer-to-function.\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\nconst char* DynamicLoader::LastError()\n{\n  // TODO: Need implementation with errno/strerror\n  /* If successful, shl_findsym returns an integer (int) value zero. If\n   * shl_findsym cannot find sym, it returns -1 and sets errno to zero.\n   * If any other errors occur, shl_findsym returns -1 and sets errno to one\n   * of these values (defined in <errno.h>):\n   * ENOEXEC\n   * A format error was detected in the specified library.\n   * ENOSYM\n   * A symbol on which sym depends could not be found.\n   * EINVAL\n   * The specified handle is invalid.\n   */\n\n  if (errno == ENOEXEC || errno == ENOSYM || errno == EINVAL) {\n    return strerror(errno);\n  }\n  // else\n  return 0;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(__APPLE__) && (MAC_OS_X_VERSION_MAX_ALLOWED < 1030)\n// Implementation for Mac OS X 10.2.x and earlier\n#include <mach-o/dyld.h>\n#include <string.h> // for strlen\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  NSObjectFileImageReturnCode rc;\n  NSObjectFileImage image = 0;\n\n  rc = NSCreateObjectFileImageFromFile(libname.c_str(), &image);\n  // rc == NSObjectFileImageInappropriateFile when trying to load a dylib file\n  if (rc != NSObjectFileImageSuccess) {\n    return 0;\n  }\n  NSModule handle =\n    NSLinkModule(image, libname.c_str(), NSLINKMODULE_OPTION_BINDNOW |\n                   NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n  NSDestroyObjectFileImage(image);\n  return handle;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  // NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED\n  // With  this  option  the memory for the module is not deallocated\n  // allowing pointers into the module to still be valid.\n  // You should use this option instead if your code experience some problems\n  // reported against Panther 10.3.9 (fixed in Tiger 10.4.2 and up)\n  bool success = NSUnLinkModule(lib, NSUNLINKMODULE_OPTION_NONE);\n  return success;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  void* result = 0;\n  // Need to prepend symbols with '_' on Apple-gcc compilers\n  std::string rsym = '_' + sym;\n\n  NSSymbol symbol = NSLookupSymbolInModule(lib, rsym.c_str());\n  if (symbol) {\n    result = NSAddressOfSymbol(symbol);\n  }\n\n  // Hack to cast pointer-to-data to pointer-to-function.\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\nconst char* DynamicLoader::LastError()\n{\n  return 0;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(_WIN32) && !defined(__CYGWIN__)\n// Implementation for Windows win32 code but not cygwin\n#include <windows.h>\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  DynamicLoader::LibraryHandle lh;\n  int length = MultiByteToWideChar(CP_UTF8, 0, libname.c_str(), -1, NULL, 0);\n  wchar_t* wchars = new wchar_t[length + 1];\n  wchars[0] = '\\0';\n  MultiByteToWideChar(CP_UTF8, 0, libname.c_str(), -1, wchars, length);\n  lh = LoadLibraryW(wchars);\n  delete[] wchars;\n  return lh;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  return (int)FreeLibrary(lib);\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // TODO: The calling convention affects the name of the symbol.  We\n  // should have a tool to help get the symbol with the desired\n  // calling convention.  Currently we assume cdecl.\n  //\n  // Borland:\n  //   __cdecl    = \"_func\" (default)\n  //   __fastcall = \"@_func\"\n  //   __stdcall  = \"func\"\n  //\n  // Watcom:\n  //   __cdecl    = \"_func\"\n  //   __fastcall = \"@_func@X\"\n  //   __stdcall  = \"_func@X\"\n  //   __watcall  = \"func_\" (default)\n  //\n  // MSVC:\n  //   __cdecl    = \"func\" (default)\n  //   __fastcall = \"@_func@X\"\n  //   __stdcall  = \"_func@X\"\n  //\n  // Note that the \"@X\" part of the name above is the total size (in\n  // bytes) of the arguments on the stack.\n  void* result;\n#if defined(__BORLANDC__) || defined(__WATCOMC__)\n  // Need to prepend symbols with '_'\n  std::string ssym = '_' + sym;\n  const char* rsym = ssym.c_str();\n#else\n  const char* rsym = sym.c_str();\n#endif\n  result = (void*)GetProcAddress(lib, rsym);\n// Hack to cast pointer-to-data to pointer-to-function.\n#ifdef __WATCOMC__\n  return *(DynamicLoader::SymbolPointer*)(&result);\n#else\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n#endif\n}\n\nconst char* DynamicLoader::LastError()\n{\n  LPVOID lpMsgBuf = NULL;\n\n  FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,\n                NULL, GetLastError(),\n                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language\n                (LPTSTR)&lpMsgBuf, 0, NULL);\n\n  if (!lpMsgBuf) {\n    return NULL;\n  }\n\n  static char* str = 0;\n  delete[] str;\n  str = strcpy(new char[strlen((char*)lpMsgBuf) + 1], (char*)lpMsgBuf);\n  // Free the buffer.\n  LocalFree(lpMsgBuf);\n  return str;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(__BEOS__)\n// Implementation for BeOS / Haiku\n#include <string.h> // for strerror()\n\n#include <be/kernel/image.h>\n#include <be/support/Errors.h>\n\nnamespace KWSYS_NAMESPACE {\n\nstatic image_id last_dynamic_err = B_OK;\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  // image_id's are integers, errors are negative. Add one just in case we\n  //  get a valid image_id of zero (is that even possible?).\n  image_id rc = load_add_on(libname.c_str());\n  if (rc < 0) {\n    last_dynamic_err = rc;\n    return 0;\n  }\n\n  return rc + 1;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib) {\n    last_dynamic_err = B_BAD_VALUE;\n    return 0;\n  } else {\n    // The function dlclose() returns 0 on success, and non-zero on error.\n    status_t rc = unload_add_on(lib - 1);\n    if (rc != B_OK) {\n      last_dynamic_err = rc;\n      return 0;\n    }\n  }\n\n  return 1;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union\n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n\n  result.psym = NULL;\n\n  if (!lib) {\n    last_dynamic_err = B_BAD_VALUE;\n  } else {\n    // !!! FIXME: BeOS can do function-only lookups...does this ever\n    // !!! FIXME:  actually _want_ a data symbol lookup, or was this union\n    // !!! FIXME:  a leftover of dlsym()? (s/ANY/TEXT for functions only).\n    status_t rc =\n      get_image_symbol(lib - 1, sym.c_str(), B_SYMBOL_TYPE_ANY, &result.pvoid);\n    if (rc != B_OK) {\n      last_dynamic_err = rc;\n      result.psym = NULL;\n    }\n  }\n  return result.psym;\n}\n\nconst char* DynamicLoader::LastError()\n{\n  const char* retval = strerror(last_dynamic_err);\n  last_dynamic_err = B_OK;\n  return retval;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(__MINT__)\n// Implementation for FreeMiNT on Atari\n#define _GNU_SOURCE /* for program_invocation_name */\n#include <dld.h>\n#include <errno.h>\n#include <malloc.h>\n#include <string.h>\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  char* name = (char*)calloc(1, libname.size() + 1);\n  dld_init(program_invocation_name);\n  strncpy(name, libname.c_str(), libname.size());\n  dld_link(libname.c_str());\n  return (void*)name;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  dld_unlink_by_file((char*)lib, 0);\n  free(lib);\n  return 0;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union\n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n  result.pvoid = dld_get_symbol(sym.c_str());\n  return result.psym;\n}\n\nconst char* DynamicLoader::LastError()\n{\n  return dld_strerror(dld_errno);\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#else\n// Default implementation for *NIX systems (including Mac OS X 10.3 and\n// later) which use dlopen\n#include <dlfcn.h>\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  return dlopen(libname.c_str(), RTLD_LAZY);\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (lib) {\n    // The function dlclose() returns 0 on success, and non-zero on error.\n    return !dlclose(lib);\n  }\n  // else\n  return 0;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union\n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n  result.pvoid = dlsym(lib, sym.c_str());\n  return result.psym;\n}\n\nconst char* DynamicLoader::LastError()\n{\n  return dlerror();\n}\n\n} // namespace KWSYS_NAMESPACE\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mercury-1.0.0-vxt7zf2ov43pvdom4nhfuhtyrngvqgax/spack-src/Testing/driver/kwsys/DynamicLoader.hxx.in": "/* Distributed under the OSI-approved BSD 3-Clause License.  See accompanying\n   file Copyright.txt or https://cmake.org/licensing#kwsys for details.  */\n#ifndef @KWSYS_NAMESPACE@_DynamicLoader_hxx\n#define @KWSYS_NAMESPACE@_DynamicLoader_hxx\n\n#include <@KWSYS_NAMESPACE@/Configure.hxx>\n\n#include <string>\n\n#if defined(__hpux)\n#include <dl.h>\n#elif defined(_WIN32) && !defined(__CYGWIN__)\n#include <windows.h>\n#elif defined(__APPLE__)\n#include <AvailabilityMacros.h>\n#if MAC_OS_X_VERSION_MAX_ALLOWED < 1030\n#include <mach-o/dyld.h>\n#endif\n#elif defined(__BEOS__)\n#include <be/kernel/image.h>\n#endif\n\nnamespace @KWSYS_NAMESPACE@ {\n/** \\class DynamicLoader\n * \\brief Portable loading of dynamic libraries or dll's.\n *\n * DynamicLoader provides a portable interface to loading dynamic\n * libraries or dll's into a process.\n *\n * Directory currently works with Windows, Apple, HP-UX and Unix (POSIX)\n * operating systems\n *\n * \\warning dlopen on *nix system works the following way:\n * If filename contains a slash (\"/\"), then it is interpreted as a (relative\n * or absolute) pathname.  Otherwise, the dynamic linker searches for the\n * library as follows : see ld.so(8) for further details):\n * Whereas this distinction does not exist on Win32. Therefore ideally you\n * should be doing full path to guarantee to have a consistent way of dealing\n * with dynamic loading of shared library.\n *\n * \\warning the Cygwin implementation do not use the Win32 HMODULE. Put extra\n * condition so that we can include the correct declaration (POSIX)\n */\n\nclass @KWSYS_NAMESPACE@_EXPORT DynamicLoader\n{\npublic:\n// Ugly stuff for library handles\n// They are different on several different OS's\n#if defined(__hpux)\n  typedef shl_t LibraryHandle;\n#elif defined(_WIN32) && !defined(__CYGWIN__)\n  typedef HMODULE LibraryHandle;\n#elif defined(__APPLE__)\n#if MAC_OS_X_VERSION_MAX_ALLOWED < 1030\n  typedef NSModule LibraryHandle;\n#else\n  typedef void* LibraryHandle;\n#endif\n#elif defined(__BEOS__)\n  typedef image_id LibraryHandle;\n#else // POSIX\n  typedef void* LibraryHandle;\n#endif\n\n  // Return type from DynamicLoader::GetSymbolAddress.\n  typedef void (*SymbolPointer)();\n\n  /** Load a dynamic library into the current process.\n   * The returned LibraryHandle can be used to access the symbols in the\n   * library. */\n  static LibraryHandle OpenLibrary(const std::string&);\n\n  /** Attempt to detach a dynamic library from the\n   * process.  A value of true is returned if it is successful. */\n  static int CloseLibrary(LibraryHandle);\n\n  /** Find the address of the symbol in the given library. */\n  static SymbolPointer GetSymbolAddress(LibraryHandle, const std::string&);\n\n  /** Return the default module prefix for the current platform.  */\n  static const char* LibPrefix() { return \"@KWSYS_DynamicLoader_PREFIX@\"; }\n\n  /** Return the default module suffix for the current platform.  */\n  static const char* LibExtension() { return \"@KWSYS_DynamicLoader_SUFFIX@\"; }\n\n  /** Return the last error produced from a calls made on this class. */\n  static const char* LastError();\n}; // End Class: DynamicLoader\n\n} // namespace @KWSYS_NAMESPACE@\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mercury-1.0.0-vxt7zf2ov43pvdom4nhfuhtyrngvqgax/spack-src/Testing/driver/kwsys/testDynamicLoader.cxx": "/* Distributed under the OSI-approved BSD 3-Clause License.  See accompanying\n   file Copyright.txt or https://cmake.org/licensing#kwsys for details.  */\n#include \"kwsysPrivate.h\"\n\n#include KWSYS_HEADER(DynamicLoader.hxx)\n\n#if defined(__BEOS__) || defined(__HAIKU__)\n#include <be/kernel/OS.h> /* disable_debugger() API. */\n#endif\n\n// Work-around CMake dependency scanning limitation.  This must\n// duplicate the above list of headers.\n#if 0\n#include \"DynamicLoader.hxx.in\"\n#endif\n\n#include <iostream>\n#include <string>\n\n// Include with <> instead of \"\" to avoid getting any in-source copy\n// left on disk.\n#include <testSystemTools.h>\n\nstatic std::string GetLibName(const char* lname)\n{\n  // Construct proper name of lib\n  std::string slname;\n  slname = EXECUTABLE_OUTPUT_PATH;\n#ifdef CMAKE_INTDIR\n  slname += \"/\";\n  slname += CMAKE_INTDIR;\n#endif\n  slname += \"/\";\n  slname += kwsys::DynamicLoader::LibPrefix();\n  slname += lname;\n  slname += kwsys::DynamicLoader::LibExtension();\n\n  return slname;\n}\n\n/* libname = Library name (proper prefix, proper extension)\n * System  = symbol to lookup in libname\n * r1: should OpenLibrary succeed ?\n * r2: should GetSymbolAddress succeed ?\n * r3: should CloseLibrary succeed ?\n */\nstatic int TestDynamicLoader(const char* libname, const char* symbol, int r1,\n                             int r2, int r3)\n{\n  std::cerr << \"Testing: \" << libname << std::endl;\n  kwsys::DynamicLoader::LibraryHandle l =\n    kwsys::DynamicLoader::OpenLibrary(libname);\n  // If result is incompatible with expectation just fails (xor):\n  if ((r1 && !l) || (!r1 && l)) {\n    std::cerr << kwsys::DynamicLoader::LastError() << std::endl;\n    return 1;\n  }\n  kwsys::DynamicLoader::SymbolPointer f =\n    kwsys::DynamicLoader::GetSymbolAddress(l, symbol);\n  if ((r2 && !f) || (!r2 && f)) {\n    std::cerr << kwsys::DynamicLoader::LastError() << std::endl;\n    return 1;\n  }\n#ifndef __APPLE__\n  int s = kwsys::DynamicLoader::CloseLibrary(l);\n  if ((r3 && !s) || (!r3 && s)) {\n    std::cerr << kwsys::DynamicLoader::LastError() << std::endl;\n    return 1;\n  }\n#else\n  (void)r3;\n#endif\n  return 0;\n}\n\nint testDynamicLoader(int argc, char* argv[])\n{\n#if defined(_WIN32)\n  SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);\n#elif defined(__BEOS__) || defined(__HAIKU__)\n  disable_debugger(1);\n#endif\n  int res = 0;\n  if (argc == 3) {\n    // User specify a libname and symbol to check.\n    res = TestDynamicLoader(argv[1], argv[2], 1, 1, 1);\n    return res;\n  }\n\n// dlopen() on Syllable before 11/22/2007 doesn't return 0 on error\n#ifndef __SYLLABLE__\n  // Make sure that inexistent lib is giving correct result\n  res += TestDynamicLoader(\"azerty_\", \"foo_bar\", 0, 0, 0);\n  // Make sure that random binary file cannot be assimilated as dylib\n  res += TestDynamicLoader(TEST_SYSTEMTOOLS_SOURCE_DIR \"/testSystemTools.bin\",\n                           \"wp\", 0, 0, 0);\n#endif\n\n#ifdef __linux__\n  // This one is actually fun to test, since dlopen is by default\n  // loaded...wonder why :)\n  res += TestDynamicLoader(\"foobar.lib\", \"dlopen\", 0, 1, 0);\n  res += TestDynamicLoader(\"libdl.so\", \"dlopen\", 1, 1, 1);\n  res += TestDynamicLoader(\"libdl.so\", \"TestDynamicLoader\", 1, 0, 1);\n#endif\n  // Now try on the generated library\n  std::string libname = GetLibName(KWSYS_NAMESPACE_STRING \"TestDynload\");\n  res += TestDynamicLoader(libname.c_str(), \"dummy\", 1, 0, 1);\n  res += TestDynamicLoader(libname.c_str(), \"TestDynamicLoaderSymbolPointer\",\n                           1, 1, 1);\n  res += TestDynamicLoader(libname.c_str(), \"_TestDynamicLoaderSymbolPointer\",\n                           1, 0, 1);\n  res += TestDynamicLoader(libname.c_str(), \"TestDynamicLoaderData\", 1, 1, 1);\n  res += TestDynamicLoader(libname.c_str(), \"_TestDynamicLoaderData\", 1, 0, 1);\n\n  return res;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-mercury-1.0.0-vxt7zf2ov43pvdom4nhfuhtyrngvqgax/spack-src/Testing/driver/kwsys/testSystemTools.bin"
    ],
    "total_files": 553
}