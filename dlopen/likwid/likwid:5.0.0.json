{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.0-wsmvcyg57s3cluiv7iuyeyprx4ea4ctz/spack-src/src/topology_gpu.c": "/*\n * =======================================================================================\n *\n *      Filename:  topology_gpu.c\n *\n *      Description:  Topology module for GPUs\n *\n *      Version:   5.0\n *      Released:  10.11.2019\n *\n *      Author:   Thomas Gruber (tg), thomas.roehl@googlemail.com\n *      Project:  likwid\n *\n *      Copyright (C) 2019 RRZE, University Erlangen-Nuremberg\n *\n *      This program is free software: you can redistribute it and/or modify it under\n *      the terms of the GNU General Public License as published by the Free Software\n *      Foundation, either version 3 of the License, or (at your option) any later\n *      version.\n *\n *      This program is distributed in the hope that it will be useful, but WITHOUT ANY\n *      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n *      PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n *\n *      You should have received a copy of the GNU General Public License along with\n *      this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * =======================================================================================\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <float.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <ctype.h>\n#include <assert.h>\n\n#include <cupti.h>\n#include <dlfcn.h>\n#include <cuda.h>\n\n#include <error.h>\n#include <likwid.h>\n\n#define CU_CALL( call, handleerror )                                    \\\n    do {                                                                \\\n        CUresult _status = (call);                                      \\\n        if (_status != CUDA_SUCCESS) {                                  \\\n            fprintf(stderr, \"Error: function %s failed with error %d.\\n\", #call, _status); \\\n            handleerror;                                                \\\n        }                                                               \\\n    } while (0)\n\n#define CUAPIWEAK __attribute__( ( weak ) )\n#define DECLARECUFUNC(funcname, funcsig) CUresult CUAPIWEAK funcname funcsig;  CUresult( *funcname##Ptr ) funcsig;\n\n\n#define CUDA_CALL( call, handleerror )                                \\\n    do {                                                                \\\n        cudaError_t _status = (call);                                   \\\n        if (_status != cudaSuccess) {                                   \\\n            fprintf(stderr, \"Error: function %s failed with error %d.\\n\", #call, _status); \\\n            handleerror;                                                \\\n        }                                                               \\\n    } while (0)\n\n#define CUDAAPIWEAK __attribute__( ( weak ) )\n#define DECLARECUDAFUNC(funcname, funcsig) cudaError_t CUDAAPIWEAK funcname funcsig;  cudaError_t( *funcname##Ptr ) funcsig;\n\n/* Copy from PAPI's cuda component (BSD License)\n * @author  Asim YarKhan yarkhan@icl.utk.edu (updated in 2017 to support CUDA metrics)\n * @author  Asim YarKhan yarkhan@icl.utk.edu (updated in 2015 for multiple CUDA contexts/devices)\n * @author  Heike Jagode (First version, in collaboration with Robert Dietrich, TU Dresden) jagode@icl.utk.edu\n */\nvoid (*_dl_non_dynamic_init) (void) __attribute__ ((weak));\n\nstatic void *topo_dl_libcuda = NULL;\nstatic void *topo_dl_libcudart = NULL;\nstatic int topology_gpu_initialized = 0;\nGpuTopology gpuTopology = {0, NULL};\n\n#ifdef LIKWID_WITH_NVMON\n\nDECLARECUFUNC(cuDeviceGet, (CUdevice *, int));\nDECLARECUFUNC(cuDeviceGetCount, (int *));\nDECLARECUFUNC(cuDeviceGetName, (char *, int, CUdevice));\nDECLARECUFUNC(cuInit, (unsigned int));\nDECLARECUFUNC(cuDeviceComputeCapability, (int*, int*, CUdevice));\nDECLARECUFUNC(cuDeviceGetAttribute, (int*, CUdevice_attribute, CUdevice));\nDECLARECUFUNC(cuDeviceGetProperties, (CUdevprop* prop, CUdevice));\nDECLARECUFUNC(cuDeviceTotalMem, (size_t*, CUdevice));\nDECLARECUFUNC(cuDeviceTotalMem_v2, (size_t*, CUdevice));\n\nDECLARECUDAFUNC(cudaDriverGetVersion, (int*));\nDECLARECUDAFUNC(cudaRuntimeGetVersion, (int*))\n\nstatic int\ntopo_link_libraries(void)\n{\n#define DLSYM_AND_CHECK( dllib, name ) dlsym( dllib, name ); if ( dlerror() != NULL ) { return -1; }\n\n    /* Attempt to guess if we were statically linked to libc, if so bail */\n    if(_dl_non_dynamic_init != NULL) {\n        return -1;\n    }\n    /* Need to link in the cuda libraries, if not found disable the component */\n    topo_dl_libcuda = dlopen(\"libcuda.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (!topo_dl_libcuda)\n    {\n        fprintf(stderr, \"CUDA library libcuda.so not found.\\n\");\n        return -1;\n    }\n    topo_dl_libcudart = dlopen(\"libcudart.so\", RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE);\n    if (!topo_dl_libcudart)\n    {\n        fprintf(stderr, \"CUDA runtime library libcudart.so not found.\");\n        return -1;\n    }\n    cuDeviceGetPtr = DLSYM_AND_CHECK(topo_dl_libcuda, \"cuDeviceGet\");\n    cuDeviceGetCountPtr = DLSYM_AND_CHECK(topo_dl_libcuda, \"cuDeviceGetCount\");\n    cuDeviceGetNamePtr = DLSYM_AND_CHECK(topo_dl_libcuda, \"cuDeviceGetName\");\n    cuInitPtr = DLSYM_AND_CHECK(topo_dl_libcuda, \"cuInit\");\n    cuDeviceComputeCapabilityPtr = DLSYM_AND_CHECK(topo_dl_libcuda, \"cuDeviceComputeCapability\");\n    cuDeviceGetAttributePtr = DLSYM_AND_CHECK(topo_dl_libcuda, \"cuDeviceGetAttribute\");\n    cuDeviceGetPropertiesPtr = DLSYM_AND_CHECK(topo_dl_libcuda, \"cuDeviceGetProperties\");\n    cuDeviceTotalMemPtr = DLSYM_AND_CHECK(topo_dl_libcuda, \"cuDeviceTotalMem\");\n    \n    cudaDriverGetVersionPtr = DLSYM_AND_CHECK(topo_dl_libcudart, \"cudaDriverGetVersion\");\n    cudaRuntimeGetVersionPtr = DLSYM_AND_CHECK(topo_dl_libcudart, \"cudaRuntimeGetVersion\");\n    \n#if __CUDA_API_VERSION >= 10000\n    cuDeviceTotalMem_v2Ptr = DLSYM_AND_CHECK(topo_dl_libcuda, \"cuDeviceTotalMem_v2\");\n#endif\n    \n    return 0;\n}\n\nstatic int\ntopo_init_cuda(void)\n{\n    CUresult cuErr = (*cuInitPtr)(0);\n    if (cuErr != CUDA_SUCCESS)\n    {\n        fprintf(stderr, \"CUDA cannot be found and initialized (cuInit failed).\\n\");\n        return -ENODEV;\n    }\n    return 0;\n}\n\nstatic int\ntopo_get_numDevices(void)\n{\n    CUresult cuErr;\n    int count = 0;\n    cuErr = (*cuDeviceGetCountPtr)(&count);\n    if(cuErr == CUDA_ERROR_NOT_INITIALIZED)\n    {\n        int ret = topo_init_cuda();\n        if (ret == 0)\n        {\n            cuErr = (*cuDeviceGetCountPtr)(&count);\n        }\n        else\n        {\n            return ret;\n        }\n    }\n    return count;\n}\n\nstatic int\ntopo_get_numNode(int pci_bus, int pci_dev, int pci_domain)\n{\n    char fname[1024];\n    char buff[100];\n    int ret = snprintf(fname, 1023, \"/sys/bus/pci/devices/0000:%02x:%02x.%1x/numa_node\", pci_bus, pci_dev, pci_domain);\n    if (ret > 0)\n    {\n        fname[ret] = '\\0';\n        FILE* fp = fopen(fname, \"r\");\n        if (fp)\n        {\n            ret = fread(buff, sizeof(char), 99, fp);\n            int numa_node = atoi(buff);\n            fclose(fp);\n            return numa_node;\n        }\n    }\n    return -1;\n}\n\nstatic int topology_gpu_cleanup(int idx, int err)\n{\n    for (int j = idx; j >= 0; j--)\n    {\n        free(gpuTopology.devices[j].name);\n    }\n    return err;\n}\n\nint\ntopology_gpu_init()\n{\n    int i = 0;\n    int ret = 0;\n    int cuda_version = 0;\n    int cudart_version = 0;\n    if (topology_gpu_initialized)\n    {\n        return EXIT_SUCCESS;\n    }\n    ret = topo_link_libraries();\n    if (ret != 0)\n    {\n        ERROR_PLAIN_PRINT(Cannot open CUDA library to fill GPU topology);\n        return EXIT_FAILURE;\n    }\n    int num_devs = topo_get_numDevices();\n    if (num_devs < 0)\n    {\n        ERROR_PLAIN_PRINT(Cannot get number of devices from CUDA library);\n        return EXIT_FAILURE;\n    }\n    CUDA_CALL((*cudaDriverGetVersionPtr)(&cuda_version), ret = -1; goto topology_gpu_init_error;);\n    CUDA_CALL((*cudaRuntimeGetVersionPtr)(&cudart_version), ret = -1; goto topology_gpu_init_error;);\n    if (num_devs > 0)\n    {\n        gpuTopology.devices = malloc(num_devs * sizeof(GpuDevice));\n        if (!gpuTopology.devices)\n        {\n            return -ENOMEM;\n        }\n        for (i = 0; i < num_devs; i++)\n        {\n            CUdevice dev;\n            CU_CALL((*cuDeviceGetPtr)(&dev, i), ret = -ENODEV; goto topology_gpu_init_error;);\n            size_t s = 0;\n#if __CUDA_API_VERSION >= 10000\n            if (cuda_version >= 10000 && cudart_version >= 10000)\n                CU_CALL((*cuDeviceTotalMem_v2Ptr)(&s, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n                if (s == 0)\n                {\n                    CU_CALL((*cuDeviceTotalMemPtr)(&s, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n                }\n            else\n            {\n                CU_CALL((*cuDeviceTotalMemPtr)(&s, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            }\n#else\n            CU_CALL((*cuDeviceTotalMemPtr)(&s, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n#endif\n            gpuTopology.devices[i].mem = (unsigned long long)s;\n            gpuTopology.devices[i].name = malloc(1024 * sizeof(char));\n            if (!gpuTopology.devices[i].name)\n            {\n                ERROR_PRINT(Cannot allocate space for name of GPU %d, i);\n                ret = -ENOMEM;\n                goto topology_gpu_init_error;\n            }\n            CU_CALL((*cuDeviceGetNamePtr)(gpuTopology.devices[i].name, 1023, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            gpuTopology.devices[i].name[1024] = '\\0';\n            gpuTopology.devices[i].devid = i;\n\n            CU_CALL((*cuDeviceComputeCapabilityPtr)(&gpuTopology.devices[i].ccapMajor, &gpuTopology.devices[i].ccapMinor, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CUdevprop props;\n            CU_CALL((*cuDeviceGetPropertiesPtr)(&props, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            gpuTopology.devices[i].maxThreadsPerBlock = props.maxThreadsPerBlock;\n            gpuTopology.devices[i].maxThreadsDim[0] = props.maxThreadsDim[0];\n            gpuTopology.devices[i].maxThreadsDim[1] = props.maxThreadsDim[1];\n            gpuTopology.devices[i].maxThreadsDim[2] = props.maxThreadsDim[2];\n            gpuTopology.devices[i].maxGridSize[0] = props.maxGridSize[0];\n            gpuTopology.devices[i].maxGridSize[1] = props.maxGridSize[1];\n            gpuTopology.devices[i].maxGridSize[2] = props.maxGridSize[2];\n            gpuTopology.devices[i].sharedMemPerBlock = props.sharedMemPerBlock;\n            gpuTopology.devices[i].totalConstantMemory = props.totalConstantMemory;\n            gpuTopology.devices[i].simdWidth = props.SIMDWidth;\n            gpuTopology.devices[i].memPitch = props.memPitch;\n            gpuTopology.devices[i].clockRatekHz = props.clockRate;\n            gpuTopology.devices[i].textureAlign = props.textureAlign;\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].l2Size, CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].memClockRatekHz, CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].memClockRatekHz, CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].pciBus, CU_DEVICE_ATTRIBUTE_PCI_BUS_ID, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].pciDev, CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].pciDom, CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].maxBlockRegs, CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].numMultiProcs, CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].maxThreadPerMultiProc, CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].memBusWidth, CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].unifiedAddrSpace, CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].ecc, CU_DEVICE_ATTRIBUTE_ECC_ENABLED, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].asyncEngines, CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].mapHostMem, CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].integrated, CU_DEVICE_ATTRIBUTE_INTEGRATED, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].surfaceAlign, CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n\n            gpuTopology.devices[i].numaNode = topo_get_numNode(gpuTopology.devices[i].pciBus, gpuTopology.devices[i].pciDev, gpuTopology.devices[i].pciDom);\n        }\n        gpuTopology.numDevices = num_devs;\n    }\n    topology_gpu_initialized = 1;\n    return EXIT_SUCCESS;\ntopology_gpu_init_error:\n    for (int j = 0; j < i; j++)\n    {\n        topology_gpu_cleanup(i-1, 0);\n    }\n    return ret;\n}\n\n\nvoid\ntopology_gpu_finalize(void)\n{\n    if (topology_gpu_initialized)\n    {\n        int ret = topology_gpu_cleanup(gpuTopology.numDevices-1, 0);\n    }\n}\n\nGpuTopology_t\nget_gpuTopology(void)\n{\n    if (topology_gpu_initialized)\n    {\n        return &gpuTopology;\n    }\n}\n\n#endif /* LIKWID_WITH_NVMON */\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.0-wsmvcyg57s3cluiv7iuyeyprx4ea4ctz/spack-src/src/includes/likwid.h": "/*\n * =======================================================================================\n *\n *      Filename:  likwid.h\n *\n *      Description:  Header File of likwid API\n *\n *      Version:   5.0\n *      Released:  10.11.2019\n *\n *      Authors:  Thomas Gruber (tr), thomas.roehl@googlemail.com\n *\n *      Project:  likwid\n *\n *      Copyright (C) 2019 RRZE, University Erlangen-Nuremberg\n *\n *      This program is free software: you can redistribute it and/or modify it under\n *      the terms of the GNU General Public License as published by the Free Software\n *      Foundation, either version 3 of the License, or (at your option) any later\n *      version.\n *\n *      This program is distributed in the hope that it will be useful, but WITHOUT ANY\n *      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n *      PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n *\n *      You should have received a copy of the GNU General Public License along with\n *      this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * =======================================================================================\n */\n#ifndef LIKWID_H\n#define LIKWID_H\n\n#include <stdint.h>\n#include <errno.h>\n#include <string.h>\n\n#include <bstrlib.h>\n\n#define DEBUGLEV_ONLY_ERROR 0\n#define DEBUGLEV_INFO 1\n#define DEBUGLEV_DETAIL 2\n#define DEBUGLEV_DEVELOP 3\n\n#define LIKWID_VERSION \"VERSION.RELEASE.MINORVERSION\"\n#define LIKWID_COMMIT GITCOMMIT\n\nextern int perfmon_verbosity;\nextern int likwid_nvmon_verbosity;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/*\n################################################################################\n# Marker API related functions\n################################################################################\n*/\n/** \\addtogroup MarkerAPI Marker API module\n*  @{\n*/\n/*! \\brief Initialize LIKWID's marker API\n\nMust be called in serial region of the application to set up basic data structures\nof LIKWID.\nReads environment variables:\n- LIKWID_MODE (access mode)\n- LIKWID_MASK (event bitmask)\n- LIKWID_EVENTS (event string)\n- LIKWID_THREADS (cpu list separated by ,)\n- LIKWID_GROUPS (amount of groups)\n*/\nextern void likwid_markerInit(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Initialize LIKWID's marker API for the current thread\n\nMust be called in parallel region of the application to set up basic data structures\nof LIKWID. Before you can call likwid_markerThreadInit() you have to call likwid_markerInit().\n\n*/\nextern void likwid_markerThreadInit(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Select next group to measure\n\nMust be called in parallel region of the application to switch group on every CPU.\n*/\nextern void likwid_markerNextGroup(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Close LIKWID's marker API\n\nMust be called in serial region of the application. It gathers all data of regions and\nwrites them out to a file (filepath in env variable LIKWID_FILEPATH).\n*/\nextern void likwid_markerClose(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Register a measurement region\n\nInitializes the hashTable entry in order to reduce execution time of likwid_markerStartRegion()\n@param regionTag [in] Initialize data using this string\n@return Error code\n*/\nextern int likwid_markerRegisterRegion(const char* regionTag) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Start a measurement region\n\nReads the values of all configured counters and saves the results under the name given\nin regionTag.\n@param regionTag [in] Store data using this string\n@return Error code of start operation\n*/\nextern int likwid_markerStartRegion(const char* regionTag) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Stop a measurement region\n\nReads the values of all configured counters and saves the results under the name given\nin regionTag. The measurement data of the stopped region gets summed up in global region counters.\n@param regionTag [in] Store data using this string\n@return Error code of stop operation\n*/\nextern int likwid_markerStopRegion(const char* regionTag) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Reset a measurement region\n\nReset the values of all configured counters and timers.\n@param regionTag [in] Reset data using this string\n@return Error code of reset operation\n*/\nextern int likwid_markerResetRegion(const char* regionTag) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get accumulated data of a code region\n\nGet the accumulated data of the current thread for the given regionTag.\n@param regionTag [in] Print data using this string\n@param nr_events [in,out] Length of events array\n@param events [out] Events array for the intermediate results\n@param time [out] Accumulated measurement time\n@param count [out] Call count of the code region\n*/\nextern void likwid_markerGetRegion(const char* regionTag, int* nr_events, double* events, double *time, int *count) __attribute__ ((visibility (\"default\") ));\n/* utility routines */\n/*! \\brief Get CPU ID of the current process/thread\n\nReturns the ID of the CPU the current process or thread is running on.\n@return current CPU ID\n*/\nextern int  likwid_getProcessorId() __attribute__ ((visibility (\"default\") ));\n/*! \\brief Pin the current process to given CPU\n\nPin the current process to the given CPU ID. The process cannot be scheduled to\nanother CPU after pinning but the pinning can be changed anytime with this function.\n@param [in] processorId CPU ID to pin the current process to\n@return error code (1 for success, 0 for error)\n*/\nextern int  likwid_pinProcess(int processorId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Pin the current thread to given CPU\n\nPin the current thread to the given CPU ID. The thread cannot be scheduled to\nanother CPU after pinning but the pinning can be changed anytime with this function\n@param [in] processorId CPU ID to pin the current thread to\n@return error code (1 for success, 0 for error)\n*/\nextern int  likwid_pinThread(int processorId) __attribute__ ((visibility (\"default\") ));\n/** @}*/\n\n/*\n################################################################################\n# Access client related functions\n################################################################################\n*/\n/** \\addtogroup Access Access module\n *  @{\n */\n\n/*! \\brief Enum for the access modes\n\nLIKWID supports multiple access modes to the MSR and PCI performance monitoring\nregisters. For direct access the user must have enough priviledges to access the\nMSR and PCI devices. The daemon mode forwards the operations to a daemon with\nhigher priviledges.\n*/\ntypedef enum {\n    ACCESSMODE_PERF = -1, /*!< \\brief Access performance monitoring through perf_event kernel interface */\n    ACCESSMODE_DIRECT = 0, /*!< \\brief Access performance monitoring registers directly */\n    ACCESSMODE_DAEMON = 1 /*!< \\brief Use the access daemon to access the registers */\n} AccessMode;\n\n/*! \\brief Set access mode\n\nSets the mode how the MSR and PCI registers should be accessed. 0 for direct access (propably root priviledges required) and 1 for accesses through the access daemon. It must be called before HPMinit()\n@param [in] mode (0=direct, 1=daemon)\n*/\nextern void HPMmode(int mode) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Initialize access module\n\nInitialize the module internals to either the MSR/PCI files or the access daemon\n@return error code (0 for sccess)\n*/\nextern int HPMinit() __attribute__ ((visibility (\"default\") ));\n/*! \\brief Add CPU to access module\n\nAdd the given CPU to the access module. This opens the commnunication to either the MSR/PCI files or the access daemon.\n@param [in] cpu_id CPU that should be enabled for measurements\n@return error code (0 for success, -ENODEV if access cannot be initialized\n*/\nextern int HPMaddThread(int cpu_id) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Close connections\n\nClose the connections to the MSR/PCI files or the access daemon\n*/\nextern void HPMfinalize() __attribute__ ((visibility (\"default\") ));\n/** @}*/\n\n/*\n################################################################################\n# Config file related functions\n################################################################################\n*/\n/** \\addtogroup Config Config file module\n*  @{\n*/\n/*! \\brief Structure holding values of the configuration file\n\nLIKWID supports the definition of runtime values in a configuration file. The\nmost important configurations in most cases are the path the access daemon and\nthe corresponding access mode. In order to avoid reading in the system topology\nat each start, a path to a topology file can be set. The other values are mostly\nused internally.\n*/\ntypedef struct {\n    char* configFileName; /*!< \\brief Path to the configuration file */\n    char* topologyCfgFileName; /*!< \\brief Path to the topology file */\n    char* daemonPath; /*!< \\brief Path of the access daemon */\n    char* groupPath; /*!< \\brief Path of default performance group directory */\n    AccessMode daemonMode; /*!< \\brief Access mode to the MSR and PCI registers */\n    int maxNumThreads; /*!< \\brief Maximum number of HW threads */\n    int maxNumNodes; /*!< \\brief Maximum number of NUMA nodes */\n} Likwid_Configuration;\n\n/** \\brief Pointer for exporting the Configuration data structure */\ntypedef Likwid_Configuration* Configuration_t;\n/*! \\brief Read the config file of LIKWID, if it exists\n\nSearch for LIKWID config file and read the values in\nCurrently the paths /usr/local/etc/likwid.cfg, /etc/likwid.cfg and the path\ndefined in config.mk are checked.\n@return error code (0 for success, -EFAULT if no file can be found)\n*/\nextern int init_configuration(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Destroy the config structure\n\nDestroys the current config structure and frees all allocated memory for path names\n@return error code (0 for success, -EFAULT if config structure not initialized)\n*/\nextern int destroy_configuration(void) __attribute__ ((visibility (\"default\") ));\n\n\n/*! \\brief Retrieve the config structure\n\nGet the initialized configuration\n\\sa Configuration_t\n@return Configuration_t (pointer to internal Configuration structure)\n*/\nextern Configuration_t get_configuration(void) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Set group path in the config struction\n\nSet group path in the config struction. The path must be a directory.\n@param [in] path\n@return error code (0 for success, -ENOMEM if reallocation failed, -ENOTDIR if no directoy)\n*/\nextern int config_setGroupPath(const char* path) __attribute__ ((visibility (\"default\") ));\n\n/** @}*/\n/*\n################################################################################\n# CPU topology related functions\n################################################################################\n*/\n/** \\addtogroup CPUTopology CPU information module\n*  @{\n*/\n/*! \\brief Structure with general CPU information\n\nGeneral information covers CPU family, model, name and current clock and vendor\nspecific information like the version of Intel's performance monitoring facility.\n*/\ntypedef struct {\n    uint32_t    family; /*!< \\brief CPU family ID*/\n    uint32_t    model; /*!< \\brief CPU model ID */\n    uint32_t    stepping; /*!< \\brief Stepping (version) of the CPU */\n    uint32_t    vendor; /*!< \\brief Vendor of the CPU */\n    uint32_t    part; /*!< \\brief Part number of the CPU */\n    uint64_t    clock; /*!< \\brief Current clock frequency of the executing CPU*/\n    int         turbo; /*!< \\brief Flag if CPU has a turbo mode */\n    char*       osname; /*!< \\brief Name of the CPU reported by OS */\n    char*       name; /*!< \\brief Name of the CPU as identified by LIKWID */\n    char*       short_name; /*!< \\brief Short name of the CPU*/\n    char*       features; /*!< \\brief String with all features supported by the CPU*/\n    int         isIntel; /*!< \\brief Flag if it is an Intel CPU*/\n    char        architecture[20]; /*!< \\brief name of the architecture like x86_64 or ppc64 (comparable with uname -m)*/\n    int         supportUncore; /*!< \\brief Flag if system has Uncore performance monitors */\n    int         supportClientmem; /*!< \\brief Flag if system has mappable memory controllers */\n    uint64_t    featureFlags; /*!< \\brief Mask of all features supported by the CPU*/\n    uint32_t    perf_version; /*!< \\brief Version of Intel's performance monitoring facility */\n    uint32_t    perf_num_ctr; /*!< \\brief Number of general purpose core-local performance monitoring counters */\n    uint32_t    perf_width_ctr; /*!< \\brief Bit width of fixed and general purpose counters */\n    uint32_t    perf_num_fixed_ctr; /*!< \\brief Number of fixed purpose core-local performance monitoring counters */\n} CpuInfo;\n\n/*! \\brief Structure with IDs of a HW thread\n\nFor each HW thread this structure stores the ID of the thread inside a CPU, the\nCPU core ID of the HW thread and the CPU socket ID.\n\\extends CpuTopology\n*/\ntypedef struct {\n    uint32_t threadId; /*!< \\brief ID of HW thread inside the CPU core */\n    uint32_t coreId; /*!< \\brief ID of CPU core that executes the HW thread */\n    uint32_t packageId; /*!< \\brief ID of CPU socket containing the HW thread */\n    uint32_t apicId; /*!< \\brief ID of HW thread retrieved through the Advanced Programmable Interrupt Controller */\n    uint32_t inCpuSet; /*!< \\brief ID of HW thread inside the CPU core */\n} HWThread;\n\n/*! \\brief Enum of possible caches\n\nCPU caches can have different tasks and hold different kind of data. This enum lists all shapes used in all supported CPUs\n\\extends CacheLevel\n*/\ntypedef enum {\n    NOCACHE=0, /*!< \\brief No cache used as undef value */\n    DATACACHE, /*!< \\brief Cache holding data cache lines */\n    INSTRUCTIONCACHE, /*!< \\brief Cache holding instruction cache lines */\n    UNIFIEDCACHE, /*!< \\brief Cache holding both instruction and data cache lines */\n    ITLB, /*!< \\brief Translation Lookaside Buffer cache for instruction pages */\n    DTLB /*!< \\brief Translation Lookaside Buffer cache for data pages */\n} CacheType;\n\n/*! \\brief Structure describing a cache level\n\nCPUs are connected to a cache hierarchy with different amount of caches at each level. The CacheLevel structure holds general information about the cache.\n\\extends CpuTopology\n*/\ntypedef struct {\n    uint32_t level; /*!< \\brief Level of the cache in the hierarchy */\n    CacheType type; /*!< \\brief Type of the cache */\n    uint32_t associativity; /*!< \\brief Amount of cache lines hold by each set */\n    uint32_t sets; /*!< \\brief Amount of sets */\n    uint32_t lineSize; /*!< \\brief Size in bytes of one cache line */\n    uint32_t size; /*!< \\brief Size in bytes of the cache */\n    uint32_t threads; /*!< \\brief Number of HW thread connected to the cache */\n    uint32_t inclusive; /*!< \\brief Flag if cache is inclusive (holds also cache lines available in caches nearer to the CPU) or exclusive */\n} CacheLevel;\n\n/*! \\brief Structure describing the topology of the HW threads in the system\n\nThis structure describes the topology at HW thread level like the amount of HW threads, how they are distributed over the CPU sockets/packages and how the caching hierarchy is assembled.\n*/\ntypedef struct {\n    uint32_t numHWThreads; /*!< \\brief Amount of HW threads in the system and length of \\a threadPool */\n    uint32_t activeHWThreads; /*!< \\brief Amount of HW threads in the system and length of \\a threadPool */\n    uint32_t numSockets; /*!< \\brief Amount of CPU sockets/packages in the system */\n    uint32_t numCoresPerSocket; /*!< \\brief Amount of physical cores in one CPU socket/package */\n    uint32_t numThreadsPerCore; /*!< \\brief Amount of HW threads in one physical CPU core */\n    uint32_t numCacheLevels; /*!< \\brief Amount of caches for each HW thread and length of \\a cacheLevels */\n    HWThread* threadPool; /*!< \\brief List of all HW thread descriptions */\n    CacheLevel*  cacheLevels; /*!< \\brief List of all caches in the hierarchy */\n    struct treeNode* topologyTree; /*!< \\brief Anchor for a tree structure describing the system topology */\n} CpuTopology;\n\n/*! \\brief Variable holding the global cpu information structure */\nextern CpuInfo cpuid_info;\n/*! \\brief Variable holding the global cpu topology structure */\nextern CpuTopology cpuid_topology;\n\n/** \\brief Pointer for exporting the CpuInfo data structure */\ntypedef CpuInfo* CpuInfo_t;\n/** \\brief Pointer for exporting the CpuTopology data structure */\ntypedef CpuTopology* CpuTopology_t;\n/*! \\brief Initialize topology information\n\nCpuInfo_t and CpuTopology_t are initialized by either HWLOC, CPUID/ProcFS or topology file if present. The topology file name can be configured in the configuration file. Furthermore, the paths /etc/likwid_topo.cfg and &lt;PREFIX&gt;/etc/likwid_topo.cfg are checked.\n\\sa CpuInfo_t and CpuTopology_t\n@return always 0\n*/\nextern int topology_init(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Retrieve CPU topology of the current machine\n\n\\sa CpuTopology_t\n@return CpuTopology_t (pointer to internal cpuid_topology structure)\n*/\nextern CpuTopology_t get_cpuTopology(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Retrieve CPU information of the current machine\n\nGet the previously initialized CPU info structure containing number of CPUs/Threads\n\\sa CpuInfo_t\n@return CpuInfo_t (pointer to internal cpuid_info structure)\n*/\nextern CpuInfo_t get_cpuInfo(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Destroy topology structures CpuInfo_t and CpuTopology_t.\n\nRetrieved pointers to the structures are not valid anymore after this function call\n\\sa CpuInfo_t and CpuTopology_t\n*/\nextern void topology_finalize(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Print all supported architectures\n*/\nextern void print_supportedCPUs(void) __attribute__ ((visibility (\"default\") ));\n/** @}*/\n/*\n################################################################################\n# NUMA related functions\n################################################################################\n*/\n/** \\addtogroup NumaTopology NUMA memory topology module\n *  @{\n */\n/*! \\brief CPUs in NUMA node and general information about a NUMA domain\n\nThe NumaNode structure describes the topology and holds general information of a\nNUMA node. The structure is filled by calling numa_init() by either the HWLOC\nlibrary or by evaluating the /proc filesystem.\n\\extends NumaTopology\n*/\ntypedef struct {\n    uint32_t id; /*!< \\brief ID of the NUMA node */\n    uint64_t totalMemory; /*!< \\brief Amount of memory in the NUMA node */\n    uint64_t freeMemory; /*!< \\brief Amount of free memory in the NUMA node */\n    uint32_t numberOfProcessors; /*!< \\brief umber of processors covered by the NUMA node and length of \\a processors */\n    uint32_t*  processors; /*!< \\brief List of HW threads in the NUMA node */\n    uint32_t numberOfDistances; /*!< \\brief Amount of distances to the other NUMA nodes in the system and self  */\n    uint32_t*  distances; /*!< \\brief List of distances to the other NUMA nodes and self */\n} NumaNode;\n\n\n/*! \\brief  The NumaTopology structure describes all NUMA nodes in the current system.\n*/\ntypedef struct {\n    uint32_t numberOfNodes; /*!< \\brief Number of NUMA nodes in the system and length of \\a nodes  */\n    NumaNode* nodes; /*!< \\brief List of NUMA nodes */\n} NumaTopology;\n\n/*! \\brief Variable holding the global NUMA information structure */\nextern NumaTopology numa_info;\n\n/** \\brief Pointer for exporting the NumaTopology data structure */\ntypedef NumaTopology* NumaTopology_t;\n\n/*! \\brief Initialize NUMA information\n\nInitialize NUMA information NumaTopology_t using either HWLOC or CPUID/ProcFS. If\na topology config file is present it is read at topology_init() and fills \\a NumaTopology_t\n\\sa NumaTopology_t\n@return error code (0 for success, -1 if initialization failed)\n*/\nextern int numa_init(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Retrieve NUMA information of the current machine\n\nGet the previously initialized NUMA info structure\n\\sa NumaTopology_t\n@return NumaTopology_t (pointer to internal numa_info structure)\n*/\nextern NumaTopology_t get_numaTopology(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Set memory allocation policy to interleaved\n\nSet the memory allocation policy to interleaved for given list of CPUs\n@param [in] processorList List of processors\n@param [in] numberOfProcessors Length of processor list\n*/\nextern void numa_setInterleaved(const int* processorList, int numberOfProcessors) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Allocate memory from a specific specific NUMA node\n@param [in,out] ptr Start pointer of memory\n@param [in] size Size for the allocation\n@param [in] domainId ID of NUMA node for the allocation\n*/\nextern void numa_membind(void* ptr, size_t size, int domainId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Set memory allocation policy to membind\n\nSet the memory allocation policy to membind for given list of CPUs. This forces\nallocation to be placed in NUMA domains spanning the given processor list.\n@param [in] processorList List of processors\n@param [in] numberOfProcessors Length of processor list\n*/\nextern void numa_setMembind(const int* processorList, int numberOfProcessors) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Destroy NUMA information structure\n\nDestroys the NUMA information structure NumaTopology_t. Retrieved pointers\nto the structures are not valid anymore after this function call\n\\sa NumaTopology_t\n*/\nextern void numa_finalize(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Retrieve the number of NUMA nodes\n\nReturns the number of NUMA nodes of the current machine. Can also be read out of\nNumaTopology_t\n\\sa NumaTopology_t\n@return Number of NUMA nodes\n*/\nextern int likwid_getNumberOfNodes(void) __attribute__ ((visibility (\"default\") ));\n/** @}*/\n/*\n################################################################################\n# Affinity domains related functions\n################################################################################\n*/\n/** \\addtogroup AffinityDomains Thread affinity module\n *  @{\n */\n\n/*! \\brief The AffinityDomain data structure describes a single domain in the current system\n\nThe AffinityDomain data structure describes a single domain in the current system. Example domains are NUMA nodes, CPU sockets/packages or LLC (Last Level Cache) cache domains.\n\\extends AffinityDomains\n*/\ntypedef struct {\n    bstring tag; /*!< \\brief Bstring with the ID for the affinity domain. Currently possible values: N (node), SX (socket/package X), CX (LLC cache domain X) and MX (memory domain X) */\n    uint32_t numberOfProcessors; /*!< \\brief Number of HW threads in the domain and length of \\a processorList */\n    uint32_t numberOfCores; /*!< \\brief Number of CPU cores in the domain */\n    int*  processorList; /*!< \\brief List of HW thread IDs in the domain */\n} AffinityDomain;\n\n/*! \\brief The AffinityDomains data structure holds different count variables describing the\nvarious system layers\n\nAffinity domains are for example the amount of NUMA domains, CPU sockets/packages or LLC\n(Last Level Cache) cache domains of the current machine. Moreover a list of\n\\a domains holds the processor lists for each domain that are used for\nscheduling processes to domain specific HW threads. Some amounts are duplicates\nor derivation of values in \\a CpuInfo, \\a CpuTopology and \\a NumaTopology.\n*/\ntypedef struct {\n    uint32_t numberOfSocketDomains; /*!< \\brief Number of CPU sockets/packages in the system */\n    uint32_t numberOfNumaDomains; /*!< \\brief Number of NUMA nodes in the system */\n    uint32_t numberOfProcessorsPerSocket; /*!< \\brief Number of HW threads per socket/package in the system */\n    uint32_t numberOfCacheDomains; /*!< \\brief Number of LLC caches in the system */\n    uint32_t numberOfCoresPerCache; /*!< \\brief Number of HW threads per LLC cache in the system */\n    uint32_t numberOfProcessorsPerCache; /*!< \\brief Number of CPU cores per LLC cache in the system */\n    uint32_t numberOfAffinityDomains; /*!< \\brief Number of affinity domains in the current system  and length of \\a domains array */\n    AffinityDomain* domains; /*!< \\brief List of all domains in the system */\n} AffinityDomains;\n\n/** \\brief Pointer for exporting the AffinityDomains data structure */\ntypedef AffinityDomains* AffinityDomains_t;\n\n/*! \\brief Initialize affinity information\n\nInitialize affinity information AffinityDomains_t using the data of the structures\n\\a CpuInfo_t, CpuTopology_t and NumaTopology_t\n\\sa AffinityDomains_t\n*/\nextern void affinity_init() __attribute__ ((visibility (\"default\") ));\n/*! \\brief Retrieve affinity structure\n\nGet the previously initialized affinity info structure\n\\sa AffinityDomains_t\n@return AffinityDomains_t (pointer to internal affinityDomains structure)\n*/\nextern AffinityDomains_t get_affinityDomains(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Pin process to a CPU\n\nPin process to a CPU. Duplicate of likwid_pinProcess()\n@param [in] processorId CPU ID for pinning\n*/\nextern void affinity_pinProcess(int processorId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Pin processes to a CPU\n\nPin processes to a CPU. Creates a cpuset with the given processor IDs\n@param [in] cpu_count Number of processors in processorIds\n@param [in] processorIds Array of processor IDs\n*/\nextern void affinity_pinProcesses(int cpu_count, const int* processorIds) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Pin thread to a CPU\n\nPin thread to a CPU. Duplicate of likwid_pinThread()\n@param [in] processorId CPU ID for pinning\n*/\nextern void affinity_pinThread(int processorId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the CPU ID where the current process runs.\n\n@return CPU ID\n*/\nextern int affinity_processGetProcessorId() __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the CPU ID where the current thread runs.\n\n@return CPU ID\n*/\nextern int affinity_threadGetProcessorId() __attribute__ ((visibility (\"default\") ));\n/*! \\brief Destroy affinity information structure\n\nDestroys the affinity information structure AffinityDomains_t. Retrieved pointers\nto the structures are not valid anymore after this function call\n\\sa AffinityDomains_t\n*/\nextern void affinity_finalize() __attribute__ ((visibility (\"default\") ));\n/** @}*/\n\n/*\n################################################################################\n# CPU string parsing related functions\n################################################################################\n*/\n/** \\addtogroup CPUParse CPU string parser module\n *  @{\n */\n\n/*! \\brief Read CPU selection string and resolve to available CPU numbers\n\nReads the CPU selection string and fills the given list with the CPU numbers\ndefined in the selection string. This function is a interface function for the\ndifferent selection modes: scatter, expression, logical and physical.\n@param [in] cpustring Selection string\n@param [in,out] cpulist List of CPUs\n@param [in] length Length of cpulist\n@return error code (>0 on success for the returned list length, -ERRORCODE on failure)\n*/\nextern int cpustr_to_cpulist(const char* cpustring, int* cpulist, int length)  __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read NUMA node selection string and resolve to available NUMA node numbers\n\nReads the NUMA node selection string and fills the given list with the NUMA node numbers\ndefined in the selection string.\n@param [in] nodestr Selection string\n@param [out] nodes List of available NUMA nodes\n@param [in] length Length of NUMA node list\n@return error code (>0 on success for the returned list length, -ERRORCODE on failure)\n*/\nextern int nodestr_to_nodelist(const char* nodestr, int* nodes, int length)  __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read CPU socket selection string and resolve to available CPU socket numbers\n\nReads the CPU socket selection string and fills the given list with the CPU socket numbers\ndefined in the selection string.\n@param [in] sockstr Selection string\n@param [out] sockets List of available CPU sockets\n@param [in] length Length of CPU socket list\n@return error code (>0 on success for the returned list length, -ERRORCODE on failure)\n*/\nextern int sockstr_to_socklist(const char* sockstr, int* sockets, int length)  __attribute__ ((visibility (\"default\") ));\n\n#ifdef LIKWID_WITH_NVMON\n/*! \\brief Read GPU selection string and resolve to available GPUs numbers\n\nReads the GPU selection string and fills the given list with the GPU numbers defined in the selection string.\n@param [in] gpustr Selection string\n@param [out] gpulist List of available GPU\n@param [in] length Length of GPU list\n@return error code (>0 on success for the returned list length, -ERRORCODE on failure)\n*/\nextern int gpustr_to_gpulist(const char* gpustr, int* gpulist, int length)  __attribute__ ((visibility (\"default\") ));\n\n#endif /* LIKWID_WITH_NVMON */\n\n/** @}*/\n\n/*\n################################################################################\n# Performance monitoring related functions\n################################################################################\n*/\n/** \\addtogroup PerfMon Performance monitoring module\n *  @{\n */\n\n/*! \\brief Get all groups\n\nChecks the configured performance group path for the current architecture and\nreturns all found group names\n@return Amount of found performance groups\n*/\nextern int perfmon_getGroups(char*** groups, char*** shortinfos, char*** longinfos) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Free all group information\n\n@param [in] nrgroups Number of groups\n@param [in] groups List of group names\n@param [in] shortinfos List of short information string about group\n@param [in] longinfos List of long information string about group\n*/\nextern void perfmon_returnGroups(int nrgroups, char** groups, char** shortinfos, char** longinfos) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Initialize performance monitoring facility\n\nInitialize the performance monitoring feature by creating basic data structures.\nThe access mode must already be set when calling perfmon_init()\n@param [in] nrThreads Amount of threads\n@param [in] threadsToCpu List of CPUs\n@return error code (0 on success, -ERRORCODE on failure)\n*/\nextern int perfmon_init(int nrThreads, const int* threadsToCpu) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Initialize performance monitoring maps\n\nInitialize the performance monitoring maps for counters, events and Uncore boxes#\nfor the current architecture. topology_init() and numa_init() must be called before calling\nperfmon_init_maps()\n\\sa RegisterMap list, PerfmonEvent list and BoxMap list\n*/\nextern void perfmon_init_maps(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Check the performance monitoring maps whether counters and events are available\n\nChecks each counter and event in the performance monitoring maps for their availibility on\nthe current system. topology_init(), numa_init() and perfmon_init_maps() must be called before calling\nperfmon_check_counter_map().\n\\sa RegisterMap list, PerfmonEvent list and BoxMap list\n*/\nextern void perfmon_check_counter_map(int cpu_id) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Add an event string to LIKWID\n\nA event string looks like Eventname:Countername(:Option1:Option2:...),...\nThe eventname, countername and options are checked if they are available.\n@param [in] eventCString Event string\n@return Returns the ID of the new eventSet\n*/\nextern int perfmon_addEventSet(const char* eventCString) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Setup all performance monitoring counters of an eventSet\n\n@param [in] groupId (returned from perfmon_addEventSet()\n@return error code (-ENOENT if groupId is invalid and -1 if the counters of one CPU cannot be set up)\n*/\nextern int perfmon_setupCounters(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Start performance monitoring counters\n\nStart the counters that have been previously set up by perfmon_setupCounters().\nThe counter registered are zeroed before enabling the counters\n@return 0 on success and -(thread_id+1) for error\n*/\nextern int perfmon_startCounters(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Stop performance monitoring counters\n\nStop the counters that have been previously started by perfmon_startCounters().\nThis function reads the counters, so afterwards the results are availble through\nperfmon_getResult, perfmon_getLastResult, perfmon_getMetric and perfmon_getLastMetric.\n@return 0 on success and -(thread_id+1) for error\n*/\nextern int perfmon_stopCounters(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read the performance monitoring counters on all CPUs\n\nRead the counters that have been previously started by perfmon_startCounters().\nThe counters are stopped directly to avoid interference of LIKWID with the measured\ncode. Before returning, the counters are started again.\n@return 0 on success and -(thread_id+1) for error\n*/\nextern int perfmon_readCounters(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read the performance monitoring counters on one CPU\n\nRead the counters that have been previously started by perfmon_startCounters().\nThe counters are stopped directly to avoid interference of LIKWID with the measured\ncode. Before returning, the counters are started again. Only one CPU is read.\n@param [in] cpu_id CPU ID of the CPU that should be read\n@return 0 on success and -(thread_id+1) for error\n*/\nextern int perfmon_readCountersCpu(int cpu_id) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read the performance monitoring counters of all threads in a group\n\nRead the counters that have been previously started by perfmon_startCounters().\nThe counters are stopped directly to avoid interference of LIKWID with the measured\ncode. Before returning, the counters are started again.\n@param [in] groupId Read the counters for all threads taking part in group\n@return 0 on success and -(thread_id+1) for error\n*/\nextern int perfmon_readGroupCounters(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read the performance monitoring counters of on thread in a group\n\nRead the counters that have been previously started by perfmon_startCounters().\nThe counters are stopped directly to avoid interference of LIKWID with the measured\ncode. Before returning, the counters are started again. Only one thread's CPU is read.\n@param [in] groupId Read the counters defined in group identified with groupId\n@param [in] threadId Read the counters for the thread\n@return 0 on success and -(thread_id+1) for error\n*/\nextern int perfmon_readGroupThreadCounters(int groupId, int threadId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Switch the active eventSet to a new one\n\nStops the currently running counters, switches the eventSet by setting up the\ncounters and start the counters.\n@param [in] new_group ID of group that should be switched to.\n@return 0 on success and -(thread_id+1) for error\n*/\nextern int perfmon_switchActiveGroup(int new_group) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Close the perfomance monitoring facility of LIKWID\n\nDeallocates all internal data that is used during performance monitoring. Also\nthe counter values are not accessible after this function.\n*/\nextern void perfmon_finalize(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the results of the specified group, counter and thread\n\nGet the result of all measurement cycles. The function takes care of happened\noverflows and if the counter values need to be calculated with multipliers.\n@param [in] groupId ID of the group that should be read\n@param [in] eventId ID of the event that should be read\n@param [in] threadId ID of the thread/cpu that should be read\n@return The counter result\n*/\nextern double perfmon_getResult(int groupId, int eventId, int threadId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the last results of the specified group, counter and thread\n\nGet the result of the last measurement cycle. The function takes care of happened\noverflows and if the counter values need to be calculated with multipliers.\n@param [in] groupId ID of the group that should be read\n@param [in] eventId ID of the event that should be read\n@param [in] threadId ID of the thread/cpu that should be read\n@return The counter result\n*/\nextern double perfmon_getLastResult(int groupId, int eventId, int threadId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the metric result of the specified group, counter and thread\n\nGet the metric result of all measurement cycles. It reads all raw results for the given groupId and threadId.\n@param [in] groupId ID of the group that should be read\n@param [in] metricId ID of the metric that should be calculated\n@param [in] threadId ID of the thread/cpu that should be read\n@return The metric result\n*/\nextern double perfmon_getMetric(int groupId, int metricId, int threadId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the last metric result of the specified group, counter and thread\n\nGet the metric result of the last measurement cycle. It reads all raw results for the given groupId and threadId.\n@param [in] groupId ID of the group that should be read\n@param [in] metricId ID of the metric that should be calculated\n@param [in] threadId ID of the thread/cpu that should be read\n@return The metric result\n*/\nextern double perfmon_getLastMetric(int groupId, int metricId, int threadId) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the number of configured event groups\n\n@return Number of groups\n*/\nextern int perfmon_getNumberOfGroups(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of configured eventSets in group\n\n@param [in] groupId ID of group\n@return Number of eventSets\n*/\nextern int perfmon_getNumberOfEvents(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the accumulated measurement time a group\n\n@param [in] groupId ID of group\n@return Time in seconds the event group was measured\n*/\nextern double perfmon_getTimeOfGroup(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the ID of the currently set up event group\n\n@return Number of active group\n*/\nextern int perfmon_getIdOfActiveGroup(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of threads specified at perfmon_init()\n\n@return Number of threads\n*/\nextern int perfmon_getNumberOfThreads(void) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Set verbosity of LIKWID library\n\n*/\nextern void perfmon_setVerbosity(int verbose) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the event name of the specified group and event\n\nGet the metric name as defined in the performance group file\n@param [in] groupId ID of the group that should be read\n@param [in] eventId ID of the event that should be returned\n@return The event name or NULL in case of failure\n*/\nextern char* perfmon_getEventName(int groupId, int eventId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the counter name of the specified group and event\n\nGet the counter name as defined in the performance group file\n@param [in] groupId ID of the group that should be read\n@param [in] eventId ID of the event of which the counter should be returned\n@return The counter name or NULL in case of failure\n*/\nextern char* perfmon_getCounterName(int groupId, int eventId) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the name group\n\nGet the name of group. Either it is the name of the performance group or \"Custom\"\n@param [in] groupId ID of the group that should be read\n@return The group name or NULL in case of failure\n*/\nextern char* perfmon_getGroupName(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the metric name of the specified group and metric\n\nGet the metric name as defined in the performance group file\n@param [in] groupId ID of the group that should be read\n@param [in] metricId ID of the metric that should be calculated\n@return The metric name or NULL in case of failure\n*/\nextern char* perfmon_getMetricName(int groupId, int metricId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the short informational string of the specified group\n\nReturns the short information string as defined by performance groups or \"Custom\"\nin case of custom event sets\n@param [in] groupId ID of the group that should be read\n@return The short information or NULL in case of failure\n*/\nextern char* perfmon_getGroupInfoShort(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the long descriptive string of the specified group\n\nReturns the long descriptive string as defined by performance groups or NULL\nin case of custom event sets\n@param [in] groupId ID of the group that should be read\n@return The long description or NULL in case of failure\n*/\nextern char* perfmon_getGroupInfoLong(int groupId) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the number of configured metrics for group\n\n@param [in] groupId ID of group\n@return Number of metrics\n*/\nextern int perfmon_getNumberOfMetrics(int groupId) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the last measurement time a group\n\n@param [in] groupId ID of group\n@return Time in seconds the event group was measured the last time\n*/\nextern double perfmon_getLastTimeOfGroup(int groupId) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Read the output file of the Marker API\n@param [in] filename Filename with Marker API results\n@return 0 or negative error number\n*/\nextern int perfmon_readMarkerFile(const char* filename) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Free space for read in Marker API file\n*/\nextern void perfmon_destroyMarkerResults() __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of regions listed in Marker API result file\n\n@return Number of regions\n*/\nextern int perfmon_getNumberOfRegions() __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the groupID of a region\n\n@param [in] region ID of region\n@return Group ID of region\n*/\nextern int perfmon_getGroupOfRegion(int region) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the tag of a region\n@param [in] region ID of region\n@return tag of region\n*/\nextern char* perfmon_getTagOfRegion(int region) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of events of a region\n@param [in] region ID of region\n@return Number of events of region\n*/\nextern int perfmon_getEventsOfRegion(int region) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of metrics of a region\n@param [in] region ID of region\n@return Number of metrics of region\n*/\nextern int perfmon_getMetricsOfRegion(int region) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of threads of a region\n@param [in] region ID of region\n@return Number of threads of region\n*/\nextern int perfmon_getThreadsOfRegion(int region) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the cpulist of a region\n@param [in] region ID of region\n@param [in] count Length of cpulist array\n@param [in,out] cpulist cpulist array\n@return Number of threads of region or count, whatever is lower\n*/\nextern int perfmon_getCpulistOfRegion(int region, int count, int* cpulist)  __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the accumulated measurement time of a region for a thread\n@param [in] region ID of region\n@param [in] thread ID of thread\n@return Measurement time of a region for a thread\n*/\nextern double perfmon_getTimeOfRegion(int region, int thread) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the call count of a region for a thread\n@param [in] region ID of region\n@param [in] thread ID of thread\n@return Call count of a region for a thread\n*/\nextern int perfmon_getCountOfRegion(int region, int thread) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the event result of a region for an event and thread\n@param [in] region ID of region\n@param [in] event ID of event\n@param [in] thread ID of thread\n@return Result of a region for an event and thread\n*/\nextern double perfmon_getResultOfRegionThread(int region, int event, int thread) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the metric result of a region for a metric and thread\n@param [in] region ID of region\n@param [in] metricId ID of metric\n@param [in] threadId ID of thread\n@return Metric result of a region for a thread\n*/\nextern double perfmon_getMetricOfRegionThread(int region, int metricId, int threadId) __attribute__ ((visibility (\"default\") ));\n\n/** @}*/\n\n/*\n################################################################################\n# Performance group related functions\n################################################################################\n*/\n\n/** \\addtogroup PerfGroup performance group module\n *  @{\n */\n\n/*! \\brief The groupInfo data structure describes a performance group\n\nGroups can be either be read in from file or be a group with custom event set. For\nperformance groups commonly all values are set. For groups with custom event set,\nthe fields groupname and shortinfo are set to 'Custom', longinfo is NULL and in\ngeneral the nmetrics value is 0.\n*/\ntypedef struct {\n    char* groupname; /*!< \\brief Name of the group: performance group name or 'Custom' */\n    char* shortinfo; /*!< \\brief Short info string for the group or 'Custom' */\n    int nevents; /*!< \\brief Number of event/counter combinations */\n    char** events; /*!< \\brief List of events */\n    char** counters; /*!< \\brief List of counter registers */\n    int nmetrics; /*!< \\brief Number of metrics */\n    char** metricnames; /*!< \\brief Metric names */\n    char** metricformulas; /*!< \\brief Metric formulas */\n    char* longinfo; /*!< \\brief Descriptive text about the group or empty */\n} GroupInfo;\n\n/*! \\brief Initialize values in GroupInfo struct\n\nInitialize values in GroupInfo struct. The function does NOT allocate the GroupInfo struct\n*/\nint perfgroup_new(GroupInfo* ginfo) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Add a counter and event combination to the group\n\nAdd a counter and event combination to the group.\n@param [in] ginfo GroupInfo struct\n@param [in] counter String with counter name\n@param [in] event String with event name\n@return 0 for success, -EINVAL or -ENOMEM in case of error.\n*/\nint perfgroup_addEvent(GroupInfo* ginfo, char* counter, char* event) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Remove a counter and event combination from a group\n\nRemove a counter and event combination from a group\n@param [in] ginfo GroupInfo struct\n@param [in] counter String with counter name\n*/\nvoid perfgroup_removeEvent(GroupInfo* ginfo, char* counter) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Add a metric to the group\n\nAdd a metric to the group\n@param [in] ginfo GroupInfo struct\n@param [in] mname String with metric name/description\n@param [in] mcalc String with metric formula. No spaces in string.\n@return 0 for success, -EINVAL or -ENOMEM in case of error.\n*/\nint perfgroup_addMetric(GroupInfo* ginfo, char* mname, char* mcalc) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Remove a metric from a group\n\nRemove a metric from a group\n@param [in] ginfo GroupInfo struct\n@param [in] mname String with metric name/description\n*/\nvoid perfgroup_removeMetric(GroupInfo* ginfo, char* mname) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the event string of a group needed for perfmon_addEventSet\n\nGet the event string of a group needed for perfmon_addEventSet\n@param [in] ginfo GroupInfo struct\n@return String with eventset or NULL\n*/\nchar* perfgroup_getEventStr(GroupInfo* ginfo) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the eventset string of a group\n\nReturn the event string of a group\n@param [in] eventStr Eventset string\n*/\nvoid perfgroup_returnEventStr(char* eventStr) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the group name of a group\n\nGet the group name of a group\n@param [in] ginfo GroupInfo struct\n@return String with group name or NULL\n*/\nchar* perfgroup_getGroupName(GroupInfo* ginfo) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Set the group name of a group\n\nSet the group name of a group. String must be zero-terminated\n@param [in] ginfo GroupInfo struct\n@param [in] groupName String with group name\n@return 0 for success, -EINVAL or -ENOMEM in case of error.\n*/\nint perfgroup_setGroupName(GroupInfo* ginfo, char* groupName) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the group name string of a group\n\nReturn the group name string of a group\n@param [in] gname Group name string\n*/\nvoid perfgroup_returnGroupName(char* gname) __attribute__ ((visibility (\"default\") ));\n\n\n/*! \\brief Set the short information string of a group\n\nSet the short information string of a group. String must be zero-terminated\n@param [in] ginfo GroupInfo struct\n@param [in] shortInfo String with short information\n@return 0 for success, -EINVAL or -ENOMEM in case of error.\n*/\nint perfgroup_setShortInfo(GroupInfo* ginfo, char* shortInfo) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the short information string of a group\n\nGet the short information string of a group\n@param [in] ginfo GroupInfo struct\n@return String with short information or NULL\n*/\nchar* perfgroup_getShortInfo(GroupInfo* ginfo) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the short information string of a group\n\nReturn the short information string of a group\n@param [in] sinfo Short information string\n*/\nvoid perfgroup_returnShortInfo(char* sinfo) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Set the long information string of a group\n\nSet the long information string of a group. String must be zero-terminated\n@param [in] ginfo GroupInfo struct\n@param [in] longInfo String with long information\n@return 0 for success, -EINVAL or -ENOMEM in case of error.\n*/\nint perfgroup_setLongInfo(GroupInfo* ginfo, char* longInfo) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the long information string of a group\n\nGet the long information string of a group\n@param [in] ginfo GroupInfo struct\n@return String with long information or NULL\n*/\nchar* perfgroup_getLongInfo(GroupInfo* ginfo) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the long information string of a group\n\nReturn the long information string of a group\n@param [in] linfo Long information string\n*/\nvoid perfgroup_returnLongInfo(char* linfo) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Merge two groups\n\nMerge two groups (group2 into group1).\n@param [in,out] grp1 Group1\n@param [in] grp2 Group2\n@return 0 for success, -EINVAL or -ENOMEM in case of error.\n*/\nint perfgroup_mergeGroups(GroupInfo* grp1, GroupInfo* grp2) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Read group from file\n\nRead group from file\n@param [in] grouppath Base path to all groups\n@param [in] architecture Architecture string (e.g. short_info in cpuid_info)\n@param [in] groupname Group name\n@param [in,out] ginfo Group filled with data from file\n@return 0 for success, -EINVAL or -ENOMEM in case of error.\n*/\nint perfgroup_readGroup(const char* grouppath, const char* architecture, const char* groupname, GroupInfo* ginfo) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Create group from event string\n\nCreate group from event string (list of event:counter(:opts)).\n@param [in] eventStr event string\n@param [in,out] ginfo Group filled with data from event string\n@return 0 for success, -EINVAL or -ENOMEM in case of error.\n*/\nint perfgroup_customGroup(const char* eventStr, GroupInfo* ginfo) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Return group\n\nReturn group (frees internal lists)\n@param [in] ginfo Performance group info\n*/\nvoid perfgroup_returnGroup(GroupInfo* ginfo) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get all groups available in the system (base + user home)\n\nGet all groups available in the system (base + user home)\n@param [in] grouppath Base path to all groups\n@param [in] architecture Architecture string (e.g. short_info in cpuid_info)\n@param [out] groupnames List of group names\n@param [out] groupshort List of groups' short information string\n@param [out] grouplong List of groups' long information string\n@return number of groups, -EINVAL or -ENOMEM in case of error.\n*/\nint perfgroup_getGroups( const char* grouppath, const char* architecture, char*** groupnames, char*** groupshort, char*** grouplong) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return list of all groups\n\nReturn list of all groups\n@param [in] groups Number of groups\n@param [in] groupnames List of group names\n@param [in] groupshort List of groups' short information string\n@param [in] grouplong List of groups' long information string\n*/\nvoid perfgroup_returnGroups(int groups, char** groupnames, char** groupshort, char** grouplong) __attribute__ ((visibility (\"default\") ));\n\n\n\n\n/** @}*/\n\n/*\n################################################################################\n# Time measurements related functions\n################################################################################\n*/\n\n/** \\addtogroup TimerMon Time measurement module\n *  @{\n */\n\n/*! \\brief Struct defining the start and stop time of a time interval\n\\extends TimerData\n*/\ntypedef union\n{\n    uint64_t int64; /*!< \\brief Cycle count in 64 bit */\n    struct {uint32_t lo, hi;} int32; /*!< \\brief Cycle count stored in two 32 bit fields */\n} TscCounter;\n\n/*! \\brief Struct defining the start and stop time of a time interval\n*/\ntypedef struct {\n    TscCounter start; /*!< \\brief Cycles at start */\n    TscCounter stop; /*!< \\brief Cycles at stop */\n} TimerData;\n\n/*! \\brief Initialize timer by retrieving baseline frequency and cpu clock\n*/\nextern void timer_init( void ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the measured interval in seconds\n\n@param [in] time Structure holding the cycle count at start and stop\n@return Time in seconds\n*/\nextern double timer_print( const TimerData* time) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the measured interval in cycles\n\n@param [in] time Structure holding the cycle count at start and stop\n@return Time in cycles\n*/\nextern uint64_t timer_printCycles( const TimerData* time) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Reset values in TimerData\n\n@param [in] time Structure holding the cycle count at start and stop\n*/\nextern void timer_reset( TimerData* time ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the CPU clock determined at timer_init\n\n@return CPU clock\n*/\nextern uint64_t timer_getCpuClock( void ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the current CPU clock read from sysfs\n\n@return CPU clock\n*/\nextern uint64_t timer_getCpuClockCurrent( int cpu_id ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the cycles clock determined at timer_init\n\n@return cycle clock\n*/\nextern uint64_t timer_getCycleClock( void ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the baseline CPU clock determined at timer_init\n\n@return Baseline CPU clock\n*/\nextern uint64_t timer_getBaseline( void ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Start time measurement\n\n@param [in,out] time Structure holding the cycle count at start\n*/\nextern void timer_start( TimerData* time ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Stop time measurement\n\n@param [in,out] time Structure holding the cycle count at stop\n*/\nextern void timer_stop ( TimerData* time) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Sleep for specified usecs\n\n@param [in] usec Amount of usecs to sleep\n*/\nextern int timer_sleep(unsigned long usec) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Finalize timer module\n\n*/\nextern void timer_finalize(void) __attribute__ ((visibility (\"default\") ));\n\n/** @}*/\n\n/*\n################################################################################\n# Power measurements related functions\n################################################################################\n*/\n/** \\addtogroup PowerMon Power and Energy monitoring module\n *  @{\n */\n\n/*!\n\\def NUM_POWER_DOMAINS\nAmount of currently supported RAPL domains\n*/\n#define NUM_POWER_DOMAINS 5\n/*! \\brief List of all RAPL domain names\n*/\nextern const char* power_names[NUM_POWER_DOMAINS] __attribute__ ((visibility (\"default\") ));\n\n/*!\n\\def POWER_DOMAIN_SUPPORT_STATUS\nFlag to check in PowerDomain's supportFlag if the status msr registers are available\n*/\n#define POWER_DOMAIN_SUPPORT_STATUS (1ULL<<0)\n/*!\n\\def POWER_DOMAIN_SUPPORT_LIMIT\nFlag to check in PowerDomain's supportFlag if the limit msr registers are available\n*/\n#define POWER_DOMAIN_SUPPORT_LIMIT (1ULL<<1)\n/*!\n\\def POWER_DOMAIN_SUPPORT_POLICY\nFlag to check in PowerDomain's supportFlag if the policy msr registers are available\n*/\n#define POWER_DOMAIN_SUPPORT_POLICY (1ULL<<2)\n/*!\n\\def POWER_DOMAIN_SUPPORT_PERF\nFlag to check in PowerDomain's supportFlag if the perf msr registers are available\n*/\n#define POWER_DOMAIN_SUPPORT_PERF (1ULL<<3)\n/*!\n\\def POWER_DOMAIN_SUPPORT_INFO\nFlag to check in PowerDomain's supportFlag if the info msr registers are available\n*/\n#define POWER_DOMAIN_SUPPORT_INFO (1ULL<<4)\n\n\n/*! \\brief Information structure of CPU's turbo mode\n\\extends PowerInfo\n*/\ntypedef struct {\n    int numSteps; /*!< \\brief Amount of turbo mode steps/frequencies */\n    double* steps; /*!< \\brief List of turbo mode steps */\n} TurboBoost;\n\n/*! \\brief Enum for all supported RAPL domains\n\\extends PowerDomain\n*/\ntypedef enum {\n    PKG = 0, /*!< \\brief PKG domain, mostly one CPU socket/package */\n    PP0 = 1, /*!< \\brief PP0 domain, not clearly defined by Intel */\n    PP1 = 2, /*!< \\brief PP1 domain, not clearly defined by Intel */\n    DRAM = 3, /*!< \\brief DRAM domain, the memory modules */\n    PLATFORM = 4 /*!< \\brief PLATFORM domain, the whole system (if powered through the main board) */\n} PowerType;\n\n/*! \\brief Structure describing an RAPL power domain\n\\extends PowerInfo\n*/\ntypedef struct {\n    PowerType type; /*!< \\brief Identifier which RAPL domain is managed by this struct */\n    uint32_t supportFlags; /*!< \\brief Bitmask which features are supported by the power domain */\n    double energyUnit; /*!< \\brief Multiplier for energy measurements */\n    double tdp; /*!< \\brief Thermal Design Power (maximum amount of heat generated by the CPU) */\n    double minPower; /*!< \\brief Minimal power consumption of the CPU */\n    double maxPower; /*!< \\brief Maximal power consumption of the CPU */\n    double maxTimeWindow; /*!< \\brief Minimal power measurement interval */\n} PowerDomain;\n\n/*! \\brief Information structure of CPU's power measurement facility\n*/\ntypedef struct {\n    double baseFrequency; /*!< \\brief Base frequency of the CPU */\n    double minFrequency; /*!< \\brief Minimal frequency of the CPU */\n    TurboBoost turbo; /*!< \\brief Turbo boost information */\n    int hasRAPL; /*!< \\brief RAPL support flag */\n    double powerUnit; /*!< \\brief Multiplier for power measurements */\n    double timeUnit; /*!< \\brief Multiplier for time information */\n    double uncoreMinFreq; /*!< \\brief Minimal uncore frequency */\n    double uncoreMaxFreq; /*!< \\brief Maximal uncore frequency */\n    uint8_t perfBias; /*!< \\brief Performance energy bias */\n    PowerDomain domains[NUM_POWER_DOMAINS]; /*!< \\brief List of power domains */\n} PowerInfo;\n\n/*! \\brief Power measurement data for start/stop measurements\n*/\ntypedef struct {\n    int domain; /*!< \\brief RAPL domain identifier */\n    uint32_t before; /*!< \\brief Counter state at start */\n    uint32_t after; /*!< \\brief Counter state at stop */\n} PowerData;\n\n/*! \\brief Variable holding the global power information structure */\nextern PowerInfo power_info;\n\n/** \\brief Pointer for exporting the PowerInfo data structure */\ntypedef PowerInfo* PowerInfo_t;\n/** \\brief Pointer for exporting the PowerData data structure */\ntypedef PowerData* PowerData_t;\n\n/*! \\brief Initialize energy measurements on specific CPU\n\nAdditionally, it reads basic information about the energy measurements like\nminimal measurement time.\n@param [in] cpuId Initialize energy facility for this CPU\n@return RAPL status (0=No RAPL, 1=RAPL working)\n*/\nextern int power_init(int cpuId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get a pointer to the energy facility information\n\n@return PowerInfo_t pointer\n\\sa PowerInfo_t\n*/\nextern PowerInfo_t get_powerInfo(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read the current power value\n\n@param [in] cpuId Read energy facility for this CPU\n@param [in] reg Energy register\n@param [out] data Energy data\n*/\nextern int power_read(int cpuId, uint64_t reg, uint32_t *data) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read the current energy value using a specific communication socket\n\n@param [in] socket_fd Communication socket for the read operation\n@param [in] cpuId Read energy facility for this CPU\n@param [in] reg Energy register\n@param [out] data Energy data\n*/\nextern int power_tread(int socket_fd, int cpuId, uint64_t reg, uint32_t *data) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Start energy measurements\n\n@param [in,out] data Data structure holding start and stop values for energy measurements\n@param [in] cpuId Start energy facility for this CPU\n@param [in] type Which type should be measured\n@return error code\n*/\nextern int power_start(PowerData_t data, int cpuId, PowerType type) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Stop energy measurements\n\n@param [in,out] data Data structure holding start and stop values for energy measurements\n@param [in] cpuId Start energy facility for this CPU\n@param [in] type Which type should be measured\n@return error code\n*/\nextern int power_stop(PowerData_t data, int cpuId, PowerType type) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Print energy measurements gathered by power_start() and power_stop()\n\n@param [in] data Data structure holding start and stop values for energy measurements\n@return Consumed energy in Joules\n*/\nextern double power_printEnergy(const PowerData* data) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get energy Unit\n\n@param [in] domain RAPL domain ID\n@return Energy unit of the given RAPL domain\n*/\nextern double power_getEnergyUnit(int domain) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the values of the limit register of a domain\nNOT IMPLEMENTED\n\n@param [in] cpuId CPU ID\n@param [in] domain RAPL domain ID\n@param [out] power Energy limit\n@param [out] time Time limit\n@return error code\n*/\nint power_limitGet(int cpuId, PowerType domain, double* power, double* time) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Set the values of the limit register of a domain\nNOT IMPLEMENTED\n\n@param [in] cpuId CPU ID\n@param [in] domain RAPL domain ID\n@param [in] power Energy limit\n@param [in] time Time limit\n@param [in] doClamping Activate clamping (going below OS-requested power level)\n@return error code\n*/\nint power_limitSet(int cpuId, PowerType domain, double power, double time, int doClamping) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the state of a energy limit, activated or deactivated\nNOT IMPLEMENTED\n\n@param [in] cpuId CPU ID\n@param [in] domain RAPL domain ID\n@return state, 1 for active, 0 for inactive\n*/\nint power_limitState(int cpuId, PowerType domain) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Free space of power_unit\n*/\nextern void power_finalize(void) __attribute__ ((visibility (\"default\") ));\n/** @}*/\n\n/*\n################################################################################\n# Thermal measurements related functions\n################################################################################\n*/\n/** \\addtogroup ThermalMon Thermal monitoring module\n *  @{\n */\n/*! \\brief Initialize thermal measurements on specific CPU\n\n@param [in] cpuId Initialize thermal facility for this CPU\n*/\nextern void thermal_init(int cpuId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read the current thermal value\n\n@param [in] cpuId Read thermal facility for this CPU\n@param [out] data Thermal data\n*/\nextern int thermal_read(int cpuId, uint32_t *data) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read the current thermal value using a specific communication socket\n\n@param [in] socket_fd Communication socket for the read operation\n@param [in] cpuId Read thermal facility for this CPU\n@param [out] data Thermal data\n*/\nextern int thermal_tread(int socket_fd, int cpuId, uint32_t *data) __attribute__ ((visibility (\"default\") ));\n/** @}*/\n\n\n/*\n################################################################################\n# Memory sweeping related functions\n################################################################################\n*/\n/** \\addtogroup MemSweep Memory sweeping module\n *  @{\n */\n/*! \\brief Sweeping the memory of a NUMA node\n\nSweeps (zeros) the memory of NUMA node with ID \\a domainId\n@param [in] domainId NUMA node ID\n*/\nextern void memsweep_domain(int domainId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Sweeping the memory of all NUMA nodes covered by CPU list\n\nSweeps (zeros) the memory of all NUMA nodes containing the CPUs in \\a processorList\n@param [in] processorList List of CPU IDs\n@param [in] numberOfProcessors Number of CPUs in list\n*/\nextern void memsweep_threadGroup(const int* processorList, int numberOfProcessors) __attribute__ ((visibility (\"default\") ));\n/** @}*/\n\n/*\n################################################################################\n# CPU feature related functions\n################################################################################\n*/\n/** \\addtogroup CpuFeatures Retrieval and manipulation of processor features\n *  @{\n */\n/*! \\brief Enumeration of all CPU related features.\n*/\ntypedef enum {\n    FEAT_HW_PREFETCHER=0, /*!< \\brief Hardware prefetcher */\n    FEAT_CL_PREFETCHER, /*!< \\brief Adjacent cache line prefetcher */\n    FEAT_DCU_PREFETCHER, /*!< \\brief DCU L1 data cache prefetcher */\n    FEAT_IP_PREFETCHER, /*!< \\brief IP L1 data cache prefetcher */\n    FEAT_FAST_STRINGS, /*!< \\brief Fast-strings feature */\n    FEAT_THERMAL_CONTROL, /*!< \\brief Automatic Thermal Control Circuit */\n    FEAT_PERF_MON, /*!< \\brief Hardware performance monitoring */\n    FEAT_FERR_MULTIPLEX, /*!< \\brief FERR# Multiplexing, must be 1 for XAPIC interrupt model */\n    FEAT_BRANCH_TRACE_STORAGE, /*!< \\brief Branch Trace Storage */\n    FEAT_XTPR_MESSAGE, /*!< \\brief xTPR Message to set processor priority */\n    FEAT_PEBS, /*!< \\brief Precise Event Based Sampling (PEBS) */\n    FEAT_SPEEDSTEP, /*!< \\brief Enhanced Intel SpeedStep Technology to reduce energy consumption*/\n    FEAT_MONITOR, /*!< \\brief MONITOR/MWAIT feature to monitor write-back stores*/\n    FEAT_SPEEDSTEP_LOCK, /*!< \\brief Enhanced Intel SpeedStep Technology Select Lock */\n    FEAT_CPUID_MAX_VAL, /*!< \\brief Limit CPUID Maxval */\n    FEAT_XD_BIT, /*!< \\brief Execute Disable Bit */\n    FEAT_DYN_ACCEL, /*!< \\brief Intel Dynamic Acceleration */\n    FEAT_TURBO_MODE, /*!< \\brief Intel Turbo Mode */\n    FEAT_TM2, /*!< \\brief Thermal Monitoring 2 */\n    CPUFEATURES_MAX\n} CpuFeature;\n\n/*! \\brief Initialize the internal feature variables for all CPUs\n\nInitialize the internal feature variables for all CPUs\n*/\nextern void cpuFeatures_init() __attribute__ ((visibility (\"default\") ));\n/*! \\brief Print state of all CPU features for a given CPU\n\nPrint state of all CPU features for a given CPU\n@param [in] cpu CPU ID\n*/\nextern void cpuFeatures_print(int cpu) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get state of a CPU feature for a given CPU\n\nGet state of a CPU feature for a given CPU\n@param [in] cpu CPU ID\n@param [in] type CPU feature\n@return State of CPU feature (1=enabled, 0=disabled)\n*/\nextern int cpuFeatures_get(int cpu, CpuFeature type)  __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the name of a CPU feature\n\nGet the name of a CPU feature\n@param [in] type CPU feature\n@return Name of the CPU feature or NULL if feature is not available\n*/\nextern char* cpuFeatures_name(CpuFeature type)  __attribute__ ((visibility (\"default\") ));\n/*! \\brief Enable a CPU feature for a specific CPU\n\nEnable a CPU feature for a specific CPU. Only the state of the prefetchers can be changed, all other features return -EINVAL\n@param [in] cpu CPU ID\n@param [in] type CPU feature\n@param [in] print Print outcome of operation\n@return Status of operation (0=success, all others are erros, either by MSR access or invalid feature)\n*/\nextern int cpuFeatures_enable(int cpu, CpuFeature type, int print) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Disable a CPU feature for a specific CPU\n\nDisable a CPU feature for a specific CPU. Only the state of the prefetchers can be changed, all other features return -EINVAL\n@param [in] cpu CPU ID\n@param [in] type CPU feature\n@param [in] print Print outcome of operation\n@return Status of operation (0=success, all others are erros, either by MSR access or invalid feature)\n*/\nextern int cpuFeatures_disable(int cpu, CpuFeature type, int print) __attribute__ ((visibility (\"default\") ));\n/** @}*/\n\n\n/*\n################################################################################\n# CPU frequency related functions\n################################################################################\n*/\n/** \\addtogroup CpuFreq Retrieval and manipulation of processor clock frequencies\n *  @{\n */\n/*! \\brief Initialize cpu frequency module\n\nInitialize cpu frequency module\n@return returns 0 if successfull and 1 if invalid accessmode\n*/\nextern int freq_init(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the current clock frequency of a core\n\nGet the current clock frequency of a core\n@param [in] cpu_id CPU ID\n@return Frequency or 0 in case of errors\n*/\nextern uint64_t freq_getCpuClockCurrent(const int cpu_id ) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the maximal clock frequency of a core\n\nGet the maximal clock frequency of a core\n@param [in] cpu_id CPU ID\n@return Frequency or 0 in case of errors\n*/\nextern uint64_t freq_getCpuClockMax(const int cpu_id ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the maximal available clock frequency of a core\n\nGet the maximal clock frequency of a core\n@param [in] cpu_id CPU ID\n@return Frequency or 0 in case of errors\n*/\nextern uint64_t freq_getConfCpuClockMax(const int cpu_id) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Set the maximal clock frequency of a core\n\nSet the maximal clock frequency of a core\n@param [in] cpu_id CPU ID\n@param [in] freq Frequency in kHz\n@return Frequency or 0 in case of errors\n*/\nextern uint64_t freq_setCpuClockMax(const int cpu_id, const uint64_t freq) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the minimal clock frequency of a core\n\nGet the minimal clock frequency of a core\n@param [in] cpu_id CPU ID\n@return Frequency or 0 in case of errors\n*/\nextern uint64_t freq_getCpuClockMin(const int cpu_id ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the minimal available clock frequency of a core\n\nGet the minimal clock frequency of a core\n@param [in] cpu_id CPU ID\n@return Frequency or 0 in case of errors\n*/\nextern uint64_t freq_getConfCpuClockMin(const int cpu_id) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Set the minimal clock frequency of a core\n\nSet the minimal clock frequency of a core\n@param [in] cpu_id CPU ID\n@param [in] freq Frequency in kHz\n@return Frequency or 0 in case of errors\n*/\nextern uint64_t freq_setCpuClockMin(const int cpu_id, const uint64_t freq) __attribute__ ((visibility (\"default\") ));\n/*! \\brief De/Activate turbo mode for core\n\nDe/Activate turbo mode for core\n@param [in] cpu_id CPU ID\n@param [in] turbo (0=off, 1=on)\n@return 1 or 0 in case of errors\n*/\nextern int freq_setTurbo(const int cpu_id, int turbo) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get state of turbo mode for core\n\nGet state of  turbo mode for core\n@param [in] cpu_id CPU ID\n@return 1=Turbo active or 0=Turbo inactive\n*/\nextern int freq_getTurbo(const int cpu_id) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the frequency governor of a core\n\nGet the frequency governor of a core. The returned string must be freed by the caller.\n@param [in] cpu_id CPU ID\n@return Governor or NULL in case of errors\n*/\nextern char * freq_getGovernor(const int cpu_id ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Set the frequency governor of a core\n\nSet the frequency governor of a core.\n@param [in] cpu_id CPU ID\n@param [in] gov Governor\n@return 1 or 0 in case of errors\n*/\nextern int freq_setGovernor(const int cpu_id, const char* gov) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the available frequencies of a core\n\nGet the available frequencies of a core. The returned string must be freed by the caller.\n@param [in] cpu_id CPU ID\n@return String with available frequencies or NULL in case of errors\n*/\nextern char * freq_getAvailFreq(const int cpu_id ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the available frequency governors of a core\n\nGet the available frequency governors of a core. The returned string must be freed by the caller.\n@param [in] cpu_id CPU ID\n@return String with available frequency governors or NULL in case of errors\n*/\nextern char * freq_getAvailGovs(const int cpu_id ) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Set the minimal Uncore frequency\n\nSet the minimal Uncore frequency. Since the ranges are not documented, valid frequencies are from minimal CPU clock to maximal Turbo clock. If selecting a frequency at the borders, please check the result with the UNCORE_CLOCK event to be effective.\n@param [in] socket_id ID of socket\n@param [in] freq Frequency in MHz\n@return 0 for success, -ERROR at failure\n*/\nextern int freq_setUncoreFreqMin(const int socket_id, const uint64_t freq) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the minimal Uncore frequency\n\nGet the minimal Uncore frequency.\n@param [in] socket_id ID of socket\n@return frequency in MHz or 0 at failure\n*/\nextern uint64_t freq_getUncoreFreqMin(const int socket_id) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Set the maximal Uncore frequency\n\nSet the maximal Uncore frequency. Since the ranges are not documented, valid frequencies are from minimal CPU clock to maximal Turbo clock. If selecting a frequency at the borders, please check the result with the UNCORE_CLOCK event to be effective.\n@param [in] socket_id ID of socket\n@param [in] freq Frequency in MHz\n@return 0 for success, -ERROR at failure\n*/\nextern int freq_setUncoreFreqMax(const int socket_id, const uint64_t freq) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the maximal Uncore frequency\n\nGet the maximal Uncore frequency.\n@param [in] socket_id ID of socket\n@return frequency in MHz or 0 at failure\n*/\nextern uint64_t freq_getUncoreFreqMax(const int socket_id) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the current Uncore frequency\n\nGet the current Uncore frequency.\n@param [in] socket_id ID of socket\n@return frequency in MHz or 0 at failure\n*/\nextern uint64_t freq_getUncoreFreqCur(const int socket_id) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Finalize cpu frequency module\n\nFinalize cpu frequency module\n*/\nextern void freq_finalize(void) __attribute__ ((visibility (\"default\") ));\n/** @}*/\n\n\n/*\n################################################################################\n# Performance monitoring for NVIDIA GPUs related functions\n################################################################################\n*/\n/** \\addtogroup Nvmon Performance monitoring for NVIDIA GPUs\n *  @{\n */\n\n#if defined(LIKWID_WITH_NVMON) || defined(LIKWID_NVMON)\n/*! \\brief Structure with general GPU information for each device\n\nGeneral information covers GPU devid, name and clock and memory specific information.\nMost information comes from cuDeviceGetProperties() and cuDeviceGetAttribute().\n*/\ntypedef struct {\n    int devid; /*!< \\brief Device ID  */\n    int numaNode; /*!< \\brief Closest NUMA domain to the device */\n    char* name; /*!< \\brief Name of the device */\n    uint64_t mem; /*!< \\brief Total memory of device */\n    int ccapMajor; /*!< \\brief Major number of device's compute capability */\n    int ccapMinor; /*!< \\brief Minor number of device's compute capability */\n    int maxThreadsPerBlock; /*!< \\brief Maximam number of thread per block */\n    int maxThreadsDim[3]; /*!< \\brief Maximum sizes of each dimension of a block */\n    int maxGridSize[3]; /*!< \\brief Maximum sizes of each dimension of a grid */\n    int sharedMemPerBlock; /*!< \\brief Total amount of shared memory available per block */\n    int totalConstantMemory; /*!< \\brief Total amount of constant memory available on the device */\n    int simdWidth; /*!< \\brief SIMD width of arithmetic units = warp size */\n    int memPitch; /*!< \\brief Maximum pitch allowed by the memory copy functions that involve memory regions allocated through cuMemAllocPitch() */\n    int regsPerBlock; /*!< \\brief Total number of registers available per block */\n    int clockRatekHz; /*!< \\brief Clock frequency in kilohertz */\n    int textureAlign; /*!< \\brief Alignment requirement */\n    int surfaceAlign; /*!< \\brief Alignment requirement for surfaces */\n    int l2Size; /*!< \\brief L2 cache in bytes. 0 if the device doesn't have L2 cache */\n    int memClockRatekHz; /*!< \\brief Peak memory clock frequency in kilohertz */\n    int pciBus; /*!< \\brief PCI bus identifier of the device */\n    int pciDev; /*!< \\brief PCI device (also known as slot) identifier of the device */\n    int pciDom; /*!< \\brief PCI domain identifier of the device */\n    int maxBlockRegs; /*!< \\brief Maximum number of 32-bit registers available to a thread block */\n    int numMultiProcs; /*!< \\brief Number of multiprocessors on the device */\n    int maxThreadPerMultiProc; /*!< \\brief Maximum resident threads per multiprocessor */\n    int memBusWidth; /*!< \\brief Global memory bus width in bits */\n    int unifiedAddrSpace; /*!< \\brief 1 if the device shares a unified address space with the host, or 0 if not */\n    int ecc; /*!< \\brief 1 if error correction is enabled on the device, 0 if error correction is disabled or not supported by the device */\n    int asyncEngines; /*!< \\brief Number of asynchronous engines */\n    int mapHostMem; /*!< \\brief 1 if the device can map host memory into the CUDA address space */\n    int integrated; /*!< \\brief 1 if the device is an integrated (motherboard) GPU and 0 if it is a discrete (card) component */\n} GpuDevice;\n\n\n/*! \\brief Structure holding information of all GPUs\n\n*/\ntypedef struct {\n    int numDevices; /*!< \\brief Number of detected devices */\n    GpuDevice* devices; /*!< \\brief List with GPU-specific topology information */\n} GpuTopology;\n\n/*! \\brief Variable holding the global gpu information structure */\nextern GpuTopology gpuTopology;\n/** \\brief Pointer for exporting the GpuTopology data structure */\ntypedef GpuTopology* GpuTopology_t;\n\n\n/*! \\brief Initialize GPU topology information\n\nReads in the topology information from the CUDA library (if found).\n\\sa GpuTopology_t\n@return 0 or -errno in case of error\n*/\nextern int topology_gpu_init(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Destroy GPU topology structure GpuTopology_t\n\nRetrieved pointers to the structures are not valid anymore after this function call\n\\sa GpuTopology_t\n*/\nextern void topology_gpu_finalize(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Retrieve GPU topology of the current machine\n\n\\sa GpuTopology_t\n@return GpuTopology_t (pointer to internal gpuTopology structure)\n*/\nextern GpuTopology_t get_gpuTopology(void) __attribute__ ((visibility (\"default\") ));\n\n\n/*\n################################################################################\n# NvMarker API related functions\n################################################################################\n*/\n/** \\addtogroup NvMarkerAPI Marker API module for GPUs\n*  @{\n*/\n/*! \\brief Initialize NvLIKWID's marker API\n\nMust be called in serial region of the application to set up basic data structures\nof LIKWID.\nReads environment variables:\n- LIKWID_GEVENTS (GPU event string)\n- LIKWID_GPUS (GPU list separated by ,)\n- LIKWID_GPUFILEPATH (Outputpath for NvMarkerAPI file)\n*/\nextern void likwid_gpuMarkerInit(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Select next group to measure\n\nMust be called in parallel region of the application to switch group on every CPU.\n*/\nextern void likwid_gpuMarkerNextGroup(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Close LIKWID's NvMarker API\n\nMust be called in serial region of the application. It gathers all data of regions and\nwrites them out to a file (filepath in env variable LIKWID_FILEPATH).\n*/\nextern void likwid_gpuMarkerClose(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Register a measurement region\n\nInitializes the hashTable entry in order to reduce execution time of likwid_gpuMarkerStartRegion()\n@param regionTag [in] Initialize data using this string\n@return Error code\n*/\nextern int likwid_gpuMarkerRegisterRegion(const char* regionTag) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Start a measurement region\n\nReads the values of all configured counters and saves the results under the name given\nin regionTag.\n@param regionTag [in] Store data using this string\n@return Error code of start operation\n*/\nextern int likwid_gpuMarkerStartRegion(const char* regionTag) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Stop a measurement region\n\nReads the values of all configured counters and saves the results under the name given\nin regionTag. The measurement data of the stopped region gets summed up in global region counters.\n@param regionTag [in] Store data using this string\n@return Error code of stop operation\n*/\nextern int likwid_gpuMarkerStopRegion(const char* regionTag) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Reset a measurement region\n\nReset the values of all configured counters and timers.\n@param regionTag [in] Reset data using this string\n@return Error code of reset operation\n*/\nextern int likwid_gpuMarkerResetRegion(const char* regionTag) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get accumulated data of a code region\n\nGet the accumulated data of the current thread for the given regionTag.\n@param regionTag [in] Print data using this string\n@param nr_gpus [in,out] Length of first dimension of the arrys. Afterwards the actual count of GPUs.\n@param nr_events [in,out] Length of events array\n@param events [out] Events array for the intermediate results\n@param time [out] Accumulated measurement time\n@param count [out] Call count of the code region\n*/\nextern void likwid_gpuMarkerGetRegion(const char* regionTag, int* nr_gpus, int* nr_events, double** events, double **time, int **count) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Read the output file of the NvMarker API\n@param [in] filename Filename with NvMarker API results\n@return 0 or negative error number\n*/\nint nvmon_readMarkerFile(const char* filename) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Free space for read in NvMarker API file\n*/\nvoid nvmon_destroyMarkerResults() __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of regions listed in NvMarker API result file\n\n@return Number of regions\n*/\nint nvmon_getNumberOfRegions() __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of metrics of a region\n@param [in] region ID of region\n@return Number of metrics of region\n*/\nint nvmon_getMetricsOfRegion(int region) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of GPUs of a region\n@param [in] region ID of region\n@return Number of GPUs of region\n*/\nint nvmon_getGpusOfRegion(int region) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the GPU list of a region\n@param [in] region ID of region\n@param [in] count Length of gpulist array\n@param [in,out] gpulist gpulist array\n@return Number of GPUs of region or count, whatever is lower\n*/\nint nvmon_getGpulistOfRegion(int region, int count, int* gpulist) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the accumulated measurement time of a region for a GPU\n@param [in] region ID of region\n@param [in] gpu ID of GPU\n@return Measurement time of a region for a GPU\n*/\ndouble nvmon_getTimeOfRegion(int region, int gpu) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the call count of a region for a GPU\n@param [in] region ID of region\n@param [in] gpu ID of GPU\n@return Call count of a region for a GPU\n*/\nint nvmon_getCountOfRegion(int region, int gpu) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the groupID of a region\n\n@param [in] region ID of region\n@return Group ID of region\n*/\nint nvmon_getGroupOfRegion(int region) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the tag of a region\n@param [in] region ID of region\n@return tag of region\n*/\nchar* nvmon_getTagOfRegion(int region) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of events of a region\n@param [in] region ID of region\n@return Number of events of region\n*/\nint nvmon_getEventsOfRegion(int region) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the event result of a region for an event and GPU\n@param [in] region ID of region\n@param [in] eventId ID of event\n@param [in] gpuId ID of GPU\n@return Result of a region for an event and GPU\n*/\ndouble nvmon_getResultOfRegionGpu(int region, int eventId, int gpuId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the metric result of a region for a metric and GPU\n@param [in] region ID of region\n@param [in] metricId ID of metric\n@param [in] gpuId ID of GPU\n@return Metric result of a region for a GPU\n*/\ndouble nvmon_getMetricOfRegionGpu(int region, int metricId, int gpuId) __attribute__ ((visibility (\"default\") ));\n\n/** @}*/\n\n/*\n################################################################################\n# Nvmon related functions (Nvidia GPU monitoring)\n################################################################################\n*/\n\n/** \\addtogroup Nvmon Nvidia GPU monitoring API module for GPUs\n*  @{\n*/\n\n/*! \\brief Element in the output list from nvmon_getEventsOfGpu\n\nIt holds the name, the description and the limitation string for one event.\n*/\ntypedef struct {\n    char* name; /*! \\brief Name of the event */\n    char* desc; /*! \\brief Description of the event */\n    char* limit; /*! \\brief Limitation string of the event, commonly 'GPU' */\n} NvmonEventListEntry;\n\n/*! \\brief Output list from nvmon_getEventsOfGpu with all supported events\n\nOutput list from nvmon_getEventsOfGpu with all supported events\n*/\ntypedef struct {\n    int numEvents; /*! \\brief Number of events */\n    NvmonEventListEntry *events; /*! \\brief List of events */\n} NvmonEventList;\n/** \\brief Pointer for exporting the NvmonEventList data structure */\ntypedef NvmonEventList* NvmonEventList_t;\n\n\n/*! \\brief Get the list of supported event of a GPU\n\n@param [in] gpuId ID of GPU (from GPU topology)\n@param [out] list List of events\n@return Number of supported events or -errno\n*/\nint nvmon_getEventsOfGpu(int gpuId, NvmonEventList_t* list);\n/*! \\brief Return the list of supported event of a GPU\n\nReturn the list of supported event of a GPU from nvmon_getEventsOfGpu()\n@param [in] list List of events\n*/\nvoid nvmon_returnEventsOfGpu(NvmonEventList_t list);\n\n\n/*! \\brief Initialize the Nvidia GPU performance monitoring facility (Nvmon)\n\nInitialize the Nvidia GPU performance monitoring feature by creating basic data structures.\nThe CUDA and CUPTI library paths need to be in LD_LIBRARY_PATH to be found by dlopen.\n\n@param [in] nrGpus Amount of GPUs\n@param [in] gpuIds List of GPUs\n@return error code (0 on success, -ERRORCODE on failure)\n*/\nint nvmon_init(int nrGpus, const int* gpuIds) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Close the Nvidia GPU perfomance monitoring facility of LIKWID (Nvmon)\n\nDeallocates all internal data that is used during Nvmon performance monitoring. Also\nthe counter values are not accessible anymore after calling this function.\n*/\nvoid nvmon_finalize(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Add an event string to LIKWID Nvmon\n\nA event string looks like Eventname:Countername,...\nThe eventname and countername are checked if they are available.\n\n@param [in] eventCString Event string\n@return Returns the ID of the new eventSet\n*/\nint nvmon_addEventSet(const char* eventCString) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Setup all Nvmon performance monitoring counters of an eventSet\n\n@param [in] gid (returned from perfmon_addEventSet()\n@return error code (-ENOENT if groupId is invalid and -1 if the counters of one CPU cannot be set up)\n*/\nint nvmon_setupCounters(int gid) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Start Nvmon performance monitoring counters\n\nStart the counters that have been previously set up by nvmon_setupCounters().\nThe counter registered are zeroed before enabling the counters\n@return 0 on success and -(gpuid+1) for error\n*/\nint nvmon_startCounters(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Stop Nvmon performance monitoring counters\n\nStop the counters that have been previously started by nvmon_startCounters().\n@return 0 on success and -(gpuid+1) for error\n*/\nint nvmon_stopCounters(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read the Nvmon performance monitoring counters on all GPUs\n\nRead the counters that have been previously started by nvmon_startCounters().\n@return 0 on success and -(gpuid+1) for error\n*/\nint nvmon_readCounters(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Switch the active eventSet to a new one (Nvmon)\n\nStops the currently running counters, switches the eventSet by setting up the\ncounters and start the counters.\n@param [in] new_group ID of group that should be switched to.\n@return 0 on success and -(thread_id+1) for error\n*/\nint nvmon_switchActiveGroup(int new_group) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Set verbosity of LIKWID Nvmon library\n\n*/\nvoid nvmon_setVerbosity(int level) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the results of the specified group, counter and GPU (Nvmon)\n\nGet the result of all measurement cycles.\n@param [in] groupId ID of the group that should be read\n@param [in] eventId ID of the event that should be read\n@param [in] gpuId ID of the GPU that should be read\n@return The counter result\n*/\ndouble nvmon_getResult(int groupId, int eventId, int gpuId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the last results of the specified group, counter and GPU (Nvmon)\n\nGet the result of the last measurement cycle (between start/stop, start/read, read/read or read/top).\n@param [in] groupId ID of the group that should be read\n@param [in] eventId ID of the event that should be read\n@param [in] gpuId ID of the GPU that should be read\n@return The counter result\n*/\ndouble nvmon_getLastResult(int groupId, int eventId, int gpuId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the metric result of the specified group, counter and GPU (Nvmon)\n\nGet the metric result of all measurement cycles. It reads all raw results for the given groupId and gpuId.\n@param [in] groupId ID of the group that should be read\n@param [in] metricId ID of the metric that should be calculated\n@param [in] gpuId ID of the GPU that should be read\n@return The metric result\n*/\ndouble nvmon_getMetric(int groupId, int metricId, int gpuId);\n/*! \\brief Get the last metric result of the specified group, counter and GPU (Nvmon)\n\nGet the metric result of the last measurement cycle. It reads all raw results for the given groupId and gpuId.\n@param [in] groupId ID of the group that should be read\n@param [in] metricId ID of the metric that should be calculated\n@param [in] gpuId ID of the GPU that should be read\n@return The metric result\n*/\ndouble nvmon_getLastMetric(int groupId, int metricId, int gpuId);\n/*! \\brief Get the number of configured event groups (Nvmon)\n\n@return Number of groups\n*/\nint nvmon_getNumberOfGroups(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the ID of the currently set up event group (Nvmon)\n\n@return Number of active group\n*/\nint nvmon_getIdOfActiveGroup(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of GPUs specified at nvmon_init() (Nvmon)\n\n@return Number of GPUs\n*/\nint nvmon_getNumberOfGPUs(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of configured eventSets in group (Nvmon)\n\n@param [in] groupId ID of group\n@return Number of eventSets\n*/\nint nvmon_getNumberOfEvents(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of configured metrics for group (Nvmon)\n\n@param [in] groupId ID of group\n@return Number of metrics\n*/\nint nvmon_getNumberOfMetrics(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the accumulated measurement time a group (Nvmon)\n\n@param [in] groupId ID of group\n@return Time in seconds the event group was measured\n*/\ndouble nvmon_getTimeOfGroup(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the last measurement time a group (Nvmon)\n\n@param [in] groupId ID of group\n@return Time in seconds the event group was measured the last time\n*/\ndouble nvmon_getLastTimeOfGroup(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the event name of the specified group and event (Nvmon)\n\nGet the metric name as defined in the performance group file\n@param [in] groupId ID of the group that should be read\n@param [in] eventId ID of the event that should be returned\n@return The event name or NULL in case of failure\n*/\nchar* nvmon_getEventName(int groupId, int eventId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the counter name of the specified group and event (Nvmon)\n\nGet the counter name as defined in the performance group file\n@param [in] groupId ID of the group that should be read\n@param [in] eventId ID of the event of which the counter should be returned\n@return The counter name or NULL in case of failure\n*/\nchar* nvmon_getCounterName(int groupId, int eventId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the metric name of the specified group and metric (Nvmon)\n\nGet the metric name as defined in the performance group file\n@param [in] groupId ID of the group that should be read\n@param [in] metricId ID of the metric that should be calculated\n@return The metric name or NULL in case of failure\n*/\nchar* nvmon_getMetricName(int groupId, int metricId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the name group (Nvmon)\n\nGet the name of group. Either it is the name of the performance group or \"Custom\"\n@param [in] groupId ID of the group that should be read\n@return The group name or NULL in case of failure\n*/\nchar* nvmon_getGroupName(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the short informational string of the specified group (Nvmon)\n\nReturns the short information string as defined by performance groups or \"Custom\"\nin case of custom event sets\n@param [in] groupId ID of the group that should be read\n@return The short information or NULL in case of failure\n*/\nchar* nvmon_getGroupInfoShort(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the long descriptive string of the specified group (Nvmon)\n\nReturns the long descriptive string as defined by performance groups or NULL\nin case of custom event sets\n@param [in] groupId ID of the group that should be read\n@return The long description or NULL in case of failure\n*/\nchar* nvmon_getGroupInfoLong(int groupId) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get all groups (Nvmon)\n\nChecks the configured performance group path for the current GPU and\nreturns all found group names\n@return Amount of found performance groups\n*/\nint nvmon_getGroups(char*** groups, char*** shortinfos, char*** longinfos) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Free all group information (Nvmon)\n\n@param [in] nrgroups Number of groups\n@param [in] groups List of group names\n@param [in] shortinfos List of short information string about group\n@param [in] longinfos List of long information string about group\n*/\nint nvmon_returnGroups(int nrgroups, char** groups, char** shortinfos, char** longinfos) __attribute__ ((visibility (\"default\") ));\n\n\n\n/** @}*/\n\n#endif /* LIKWID_WITH_NVMON */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /*LIKWID_H*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.0-wsmvcyg57s3cluiv7iuyeyprx4ea4ctz/spack-src/src/includes/nvmon_cupti.h": "/*\n * =======================================================================================\n *\n *      Filename:  nvmon_cupti.h\n *\n *      Description:  Header File of nvmon module (CUPTI backend).\n *\n *      Version:   5.0\n *      Released:  10.11.2019\n *\n *      Author:   Thomas Gruber (tg), thomas.gruber@googlemail.com\n *      Project:  likwid\n *\n *      Copyright (C) 2019 RRZE, University Erlangen-Nuremberg\n *\n *      This program is free software: you can redistribute it and/or modify it under\n *      the terms of the GNU General Public License as published by the Free Software\n *      Foundation, either version 3 of the License, or (at your option) any later\n *      version.\n *\n *      This program is distributed in the hope that it will be useful, but WITHOUT ANY\n *      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n *      PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n *\n *      You should have received a copy of the GNU General Public License along with\n *      this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * =======================================================================================\n */\n\n#ifndef LIKWID_NVMON_CUPTI_H\n#define LIKWID_NVMON_CUPTI_H\n\n\n#include <cuda.h>\n#include <cupti.h>\n\n/* Copy from PAPI's cuda component (BSD License)\n * @author  Asim YarKhan yarkhan@icl.utk.edu (updated in 2017 to support CUDA metrics)\n * @author  Asim YarKhan yarkhan@icl.utk.edu (updated in 2015 for multiple CUDA contexts/devices)\n * @author  Heike Jagode (First version, in collaboration with Robert Dietrich, TU Dresden) jagode@icl.utk.edu\n */\nvoid (*_dl_non_dynamic_init) (void) __attribute__ ((weak));\n\n#define CU_CALL( call, handleerror )                                    \\\n    do {                                                                \\\n        CUresult _status = (call);                                      \\\n        if (_status != CUDA_SUCCESS) {                                  \\\n            fprintf(stderr, \"Error: function %s failed with error %d.\\n\", #call, _status); \\\n            handleerror;                                                \\\n        }                                                               \\\n    } while (0)\n\n#define CUPTI_CALL(call, handleerror)                                 \\\n    do {                                                                \\\n        CUptiResult _status = (call);                                   \\\n        if (_status != CUPTI_SUCCESS) {                                 \\\n            const char *errstr;                                         \\\n            (*cuptiGetResultString)(_status, &errstr);               \\\n            fprintf(stderr, \"Error: function %s failed with error %s.\\n\", #call, errstr); \\\n            handleerror;                                                \\\n        }                                                               \\\n    } while (0)\n\n#define CUDA_CALL( call, handleerror )                                \\\n    do {                                                                \\\n        cudaError_t _status = (call);                                   \\\n        if (_status != cudaSuccess) {                                   \\\n            fprintf(stderr, \"Error: function %s failed with error %d.\\n\", #call, _status); \\\n            handleerror;                                                \\\n        }                                                               \\\n    } while (0)\n\n#define CUAPIWEAK __attribute__( ( weak ) )\n#define DECLARECUFUNC(funcname, funcsig) CUresult CUAPIWEAK funcname funcsig;  CUresult( *funcname##Ptr ) funcsig;\nDECLARECUFUNC(cuCtxGetCurrent, (CUcontext *));\nDECLARECUFUNC(cuCtxSetCurrent, (CUcontext));\nDECLARECUFUNC(cuCtxDestroy, (CUcontext));\nDECLARECUFUNC(cuDeviceGet, (CUdevice *, int));\nDECLARECUFUNC(cuDeviceGetCount, (int *));\nDECLARECUFUNC(cuDeviceGetName, (char *, int, CUdevice));\nDECLARECUFUNC(cuInit, (unsigned int));\nDECLARECUFUNC(cuCtxPopCurrent, (CUcontext * pctx));\nDECLARECUFUNC(cuCtxPushCurrent, (CUcontext pctx));\nDECLARECUFUNC(cuCtxSynchronize, ());\n\n#define CUDAAPIWEAK __attribute__( ( weak ) )\n#define DECLARECUDAFUNC(funcname, funcsig) cudaError_t CUDAAPIWEAK funcname funcsig;  cudaError_t( *funcname##Ptr ) funcsig;\nDECLARECUDAFUNC(cudaGetDevice, (int *));\nDECLARECUDAFUNC(cudaSetDevice, (int));\nDECLARECUDAFUNC(cudaFree, (void *));\n\n#define CUPTIAPIWEAK __attribute__( ( weak ) )\n#define DECLARECUPTIFUNC(funcname, funcsig) CUptiResult CUPTIAPIWEAK funcname funcsig;  CUptiResult( *funcname##Ptr ) funcsig;\nDECLARECUPTIFUNC(cuptiEventGroupGetAttribute, (CUpti_EventGroup eventGroup, CUpti_EventGroupAttribute attrib, size_t * valueSize, void *value));\nDECLARECUPTIFUNC(cuptiDeviceGetEventDomainAttribute, (CUdevice device, CUpti_EventDomainID eventDomain, CUpti_EventDomainAttribute attrib, size_t * valueSize, void *value));\nDECLARECUPTIFUNC(cuptiEventGroupReadEvent, (CUpti_EventGroup eventGroup, CUpti_ReadEventFlags flags, CUpti_EventID event, size_t * eventValueBufferSizeBytes, uint64_t *        eventValueBuffer));\nDECLARECUPTIFUNC(cuptiEventGroupSetAttribute, (CUpti_EventGroup eventGroup, CUpti_EventGroupAttribute attrib, size_t valueSize, void *value));\nDECLARECUPTIFUNC(cuptiEventGroupSetDisable, (CUpti_EventGroupSet * eventGroupSet));\nDECLARECUPTIFUNC(cuptiEventGroupSetEnable, (CUpti_EventGroupSet * eventGroupSet));\nDECLARECUPTIFUNC(cuptiEventGroupSetsCreate, (CUcontext context, size_t eventIdArraySizeBytes, CUpti_EventID * eventIdArray, CUpti_EventGroupSets ** eventGroupPasses));\nDECLARECUPTIFUNC(cuptiEventGroupSetsDestroy, (CUpti_EventGroupSets * eventGroupSets));\nDECLARECUPTIFUNC(cuptiGetTimestamp, (uint64_t * timestamp));\nDECLARECUPTIFUNC(cuptiSetEventCollectionMode, (CUcontext context, CUpti_EventCollectionMode mode));\nDECLARECUPTIFUNC(cuptiDeviceEnumEventDomains, (CUdevice, size_t *, CUpti_EventDomainID *));\nDECLARECUPTIFUNC(cuptiDeviceGetNumEventDomains, (CUdevice, uint32_t *));\nDECLARECUPTIFUNC(cuptiEventDomainEnumEvents, (CUpti_EventDomainID, size_t *, CUpti_EventID *));\nDECLARECUPTIFUNC(cuptiEventDomainGetNumEvents, (CUpti_EventDomainID, uint32_t *));\nDECLARECUPTIFUNC(cuptiEventGetAttribute, (CUpti_EventID, CUpti_EventAttribute, size_t *, void *));\nDECLARECUPTIFUNC(cuptiGetResultString, (CUptiResult result, const char **str));\n\n\nstatic void *dl_libcuda = NULL;\nstatic void *dl_libcudart = NULL;\nstatic void *dl_libcupti = NULL;\n\nstatic int\nlink_cputi_libraries(void)\n{\n#define DLSYM_AND_CHECK( dllib, name ) dlsym( dllib, name ); if ( dlerror() != NULL ) { return -1; }\n\n    /* Attempt to guess if we were statically linked to libc, if so bail */\n    if(_dl_non_dynamic_init != NULL) {\n        return -1;\n    }\n    /* Need to link in the cuda libraries, if not found disable the component */\n    dl_libcuda = dlopen(\"libcuda.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (!dl_libcuda)\n    {\n        fprintf(stderr, \"CUDA library libcuda.so not found.\");\n        return -1;\n    }\n    cuCtxGetCurrentPtr = DLSYM_AND_CHECK(dl_libcuda, \"cuCtxGetCurrent\");\n    cuCtxSetCurrentPtr = DLSYM_AND_CHECK(dl_libcuda, \"cuCtxSetCurrent\");\n    cuDeviceGetPtr = DLSYM_AND_CHECK(dl_libcuda, \"cuDeviceGet\");\n    cuDeviceGetCountPtr = DLSYM_AND_CHECK(dl_libcuda, \"cuDeviceGetCount\");\n    cuDeviceGetNamePtr = DLSYM_AND_CHECK(dl_libcuda, \"cuDeviceGetName\");\n    cuInitPtr = DLSYM_AND_CHECK(dl_libcuda, \"cuInit\");\n    cuCtxPopCurrentPtr = DLSYM_AND_CHECK(dl_libcuda, \"cuCtxPopCurrent\");\n    cuCtxPushCurrentPtr = DLSYM_AND_CHECK(dl_libcuda, \"cuCtxPushCurrent\");\n    cuCtxSynchronizePtr = DLSYM_AND_CHECK(dl_libcuda, \"cuCtxSynchronize\");\n    cuCtxDestroyPtr = DLSYM_AND_CHECK(dl_libcuda, \"cuCtxDestroy\");\n\n    dl_libcudart = dlopen(\"libcudart.so\", RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE);\n    if (!dl_libcudart)\n    {\n        fprintf(stderr, \"CUDA runtime library libcudart.so not found.\");\n        return -1;\n    }\n    cudaGetDevicePtr = DLSYM_AND_CHECK(dl_libcudart, \"cudaGetDevice\");\n    cudaSetDevicePtr = DLSYM_AND_CHECK(dl_libcudart, \"cudaSetDevice\");\n    cudaFreePtr = DLSYM_AND_CHECK(dl_libcudart, \"cudaFree\");\n\n    dl_libcupti = dlopen(\"libcupti.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (!dl_libcupti)\n    {\n        fprintf(stderr, \"CUDA runtime library libcupti.so not found.\");\n        return -1;\n    }\n    cuptiDeviceGetEventDomainAttributePtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiDeviceGetEventDomainAttribute\");\n    cuptiEventGroupGetAttributePtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiEventGroupGetAttribute\");\n    cuptiEventGroupReadEventPtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiEventGroupReadEvent\");\n    cuptiEventGroupSetAttributePtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiEventGroupSetAttribute\");\n    cuptiEventGroupSetDisablePtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiEventGroupSetDisable\");\n    cuptiEventGroupSetEnablePtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiEventGroupSetEnable\");\n    cuptiEventGroupSetsCreatePtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiEventGroupSetsCreate\");\n    cuptiEventGroupSetsDestroyPtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiEventGroupSetsDestroy\");\n    cuptiGetTimestampPtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiGetTimestamp\");\n    cuptiSetEventCollectionModePtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiSetEventCollectionMode\");\n    cuptiDeviceEnumEventDomainsPtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiDeviceEnumEventDomains\");\n    cuptiDeviceGetNumEventDomainsPtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiDeviceGetNumEventDomains\");\n    cuptiEventDomainEnumEventsPtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiEventDomainEnumEvents\");\n    cuptiEventDomainGetNumEventsPtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiEventDomainGetNumEvents\");\n    cuptiEventGetAttributePtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiEventGetAttribute\");\n    cuptiGetResultStringPtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiGetResultString\");\n    return 0;\n}\n\n\nstatic int check_nv_context(NvmonDevice_t device, CUcontext currentContext)\n{\n    int j = 0;\n    int need_pop = 0;\n    GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Current context %ld DevContext %ld, currentContext, device->context);\n    if (!device->context)\n    {\n        int context_of_dev = -1;\n        for (j = 0; j < nvGroupSet->numberOfGPUs; j++)\n        {\n            NvmonDevice_t dev = &nvGroupSet->gpus[j];\n            if (dev->context == currentContext)\n            {\n                context_of_dev = j;\n                break;\n            }\n        }\n        if (context_of_dev < 0 && !device->context)\n        {\n            device->context = currentContext;\n            GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Reuse context %ld for device %d, device->context, device->deviceId);\n        }\n        else\n        {\n            CUDA_CALL((*cudaSetDevicePtr)(device->deviceId), return -EFAULT);\n            CUDA_CALL((*cudaFreePtr)(NULL), return -EFAULT);\n            CU_CALL((*cuCtxGetCurrentPtr)(&device->context), return -EFAULT);\n            GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, New context %ld for device %d, device->context, device->deviceId);\n        }\n    }\n    else if (device->context != currentContext)\n    {\n        GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Use context %ld for device %d, device->context, device->deviceId);\n        CU_CALL((*cuCtxPushCurrentPtr)(device->context), return -EFAULT);\n        need_pop = 1;\n    }\n    else\n    {\n        GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Context %ld fits for device %d, device->context, device->deviceId);\n    }\n    return need_pop;\n}\n\nstatic int\ninit_cuda(void)\n{\n    CUresult cuErr = (*cuInitPtr)(0);\n    if (cuErr != CUDA_SUCCESS)\n    {\n        fprintf(stderr, \"CUDA cannot be found and initialized (cuInit failed).\\n\");\n        return -ENODEV;\n    }\n    return 0;\n}\n\nstatic int\nget_numDevices(void)\n{\n    CUresult cuErr;\n    int count = 0;\n    cuErr = (*cuDeviceGetCountPtr)(&count);\n    if(cuErr == CUDA_ERROR_NOT_INITIALIZED)\n    {\n        int ret = init_cuda();\n        if (ret == 0)\n        {\n            cuErr = (*cuDeviceGetCountPtr)(&count);\n        }\n        else\n        {\n            return ret;\n        }\n    }\n    return count;\n}\n\nvoid nvmon_cupti_freeDevice(NvmonDevice_t dev)\n{\n    int j = 0;\n    GHashTableIter iter;\n    char* name = NULL;\n    uint32_t *id = NULL;\n    NvmonEvent_t event = NULL;\n    if (dev)\n    {\n        if (dev->context)\n        {\n            CU_CALL((*cuCtxDestroyPtr)(dev->context), j++);\n            dev->context = NULL;\n        }\n        if (dev->cuEventSets)\n        {\n            CUPTI_CALL((*cuptiEventGroupSetsDestroyPtr)(dev->cuEventSets), j++);\n            dev->cuEventSets = NULL;\n        }\n\n        // The event objects are freed here\n\n        if (dev->activeEvents)\n        {\n            free(dev->activeEvents);\n            dev->activeEvents = NULL;\n            dev->numActiveEvents = 0;\n        }\n\n        if (dev->nvEventSets)\n        {\n            for (j = 0; j < dev->numNvEventSets; j++)\n            {\n                free(dev->nvEventSets[j].results);\n            }\n            free(dev->nvEventSets);\n            dev->nvEventSets = NULL;\n            dev->numNvEventSets = 0;\n        }\n        if (dev->allevents)\n        {\n            for (j = 0; j < dev->numAllEvents; j++)\n            {\n                if (dev->allevents[j])\n                {\n                    free(dev->allevents[j]);\n                }\n            }\n        }\n        memset(dev, 0, sizeof(NvmonDevice));\n    }\n    return;\n}\n\nint\nnvmon_cupti_createDevice(int id, NvmonDevice *dev)\n{\n    int j = 0, k = 0, c = 0;\n    int numDomains = 0;\n    CUpti_EventDomainID* eventDomainIds = NULL;\n    int eventIdx = 0;\n    uint32_t totalEvents = 0;\n\n\n    dev->deviceId = id;\n    dev->cuEventSets = NULL;\n    dev->context = 0UL;\n    dev->activeEvents = NULL;\n    dev->numActiveEvents = 0;\n    dev->numNvEventSets = 0;\n    dev->nvEventSets = NULL;\n\n    if ((!dl_libcuda) || (!dl_libcudart) || (!dl_libcupti))\n    {\n        int err = link_cputi_libraries();\n        if (err < 0)\n        {\n            return -1;\n        }\n    }\n\n    // Assign device ID and get cuDevice from CUDA\n    CU_CALL((*cuDeviceGetPtr)(&dev->cuDevice, id), return -1);\n\n    // Get the number of event domains of the device\n    CUPTI_CALL((*cuptiDeviceGetNumEventDomainsPtr)(dev->cuDevice, &numDomains), return -1);\n    GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Nvmon: Dev %d Domains %d, id, numDomains);\n\n    // Get the domain IDs for the device\n    size_t domainarraysize = numDomains * sizeof(CUpti_EventDomainID);\n    eventDomainIds = malloc(domainarraysize);\n    if (!eventDomainIds) return -ENOMEM;\n    CUPTI_CALL((*cuptiDeviceEnumEventDomainsPtr)(dev->cuDevice, &domainarraysize, eventDomainIds), return -1);\n\n\n    // Count the events in all domains to allocate the event list\n    dev->numAllEvents = 0;\n    for (j = 0; j < numDomains; j++)\n    {\n        uint32_t domainNumEvents = 0;\n        CUpti_EventDomainID domainID = eventDomainIds[j];\n        CUPTI_CALL((*cuptiEventDomainGetNumEventsPtr)(domainID, &domainNumEvents), return -1);\n        GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Nvmon: Dev %d Domain %d Events %d, id, j, domainNumEvents);\n        totalEvents += domainNumEvents;\n    }\n    // Now we now how many events are provided by the device, so allocate a big enough event list\n    dev->allevents = malloc(totalEvents * sizeof(NvmonEvent_t));\n    if (!dev->allevents)\n    {\n        free(eventDomainIds);\n        return -ENOMEM;\n    }\n\n    // We use hash tables for faster access\n    dev->eventHash = g_hash_table_new(g_str_hash, g_str_equal);\n    dev->evIdHash = g_hash_table_new(g_int64_hash, g_int64_equal);\n\n    for (j = 0; j < numDomains; j++)\n    {\n        uint32_t domainNumEvents = 0;\n        CUpti_EventDomainID domainID = eventDomainIds[j];\n        // How many events are provided by the domain\n        CUPTI_CALL((*cuptiEventDomainGetNumEventsPtr)(domainID, &domainNumEvents), return -1);\n        size_t tmpSize = domainNumEvents * sizeof(CUpti_EventID);\n        // Allocate space for all CUPTI event IDs in the domain\n        CUpti_EventID* cuEventIds = malloc(tmpSize);\n        // Get the CUPTI events\n        CUPTI_CALL((*cuptiEventDomainEnumEventsPtr)(domainID, &tmpSize, cuEventIds), return -1);\n        for (k = 0; k < domainNumEvents; k++)\n        {\n            CUpti_EventID eventId = cuEventIds[k];\n            // Name and description are limited in length\n            size_t tmpSizeBytesName = (NVMON_DEFAULT_STR_LEN-1) * sizeof(char);\n            size_t tmpSizeBytesDesc = (NVMON_DEFAULT_STR_LEN-1) * sizeof(char);\n\n            NvmonEvent_t event = malloc(sizeof(NvmonEvent));\n            if (!event)\n            {\n                free(cuEventIds);\n                free(dev->allevents);\n                free(eventDomainIds);\n                return -ENOMEM;\n            }\n\n            // Get event name and description\n            CUPTI_CALL((*cuptiEventGetAttributePtr)(eventId, CUPTI_EVENT_ATTR_NAME, &tmpSizeBytesName, event->name), return -1);\n            CUPTI_CALL((*cuptiEventGetAttributePtr)(eventId, CUPTI_EVENT_ATTR_LONG_DESCRIPTION, &tmpSizeBytesDesc, event->description), return -1);\n            event->name[tmpSizeBytesName/sizeof(char)] = '\\0';\n            event->description[tmpSizeBytesDesc/sizeof(char)] = '\\0';\n            // LIKWID events are all uppercase, so transform the event names\n            c = 0;\n            while (event->name[c] != '\\0')\n            {\n                event->name[c] = toupper(event->name[c]);\n                c++;\n            }\n            // Save all gathered information in a NvmonEvent object\n\n            event->cuEventId = eventId;\n            event->eventId = dev->numAllEvents;\n            event->cuDomainId = domainID;\n            event->domainId = j;\n            event->type = NVMON_CUPTI_EVENT;\n            event->active = 0;\n            //GPUDEBUG_PRINT(DEBUGLEV_DETAIL, New Event %d CuEvent %d Domain %d CuDomain %d Name %s, event->eventId, (int)event->cuEventId, event->domainId, (int)event->cuDomainId, event->name);\n            // Add the object to the event list\n            dev->allevents[dev->numAllEvents] = event;\n            dev->numAllEvents++;\n            // Add the object to the hash tables\n            char* nameKey = g_strdup(event->name);\n\n            CUpti_EventID* idKey = malloc(sizeof(CUpti_EventID));\n            if (idKey)\n            {\n                *idKey = event->cuEventId;\n                // Key is event name\n                g_hash_table_insert(dev->eventHash, (gpointer)nameKey, (gpointer)event);\n                // Key is CUPTI event ID\n                g_hash_table_insert(dev->evIdHash, (gpointer)idKey, (gpointer)event);\n            }\n        }\n    }\n\n/*    CUDA_CALL((*cudaSetDevicePtr)(dev->deviceId), return -EFAULT);*/\n/*    CUDA_CALL((*cudaFreePtr)(NULL), return -EFAULT);*/\n/*    CU_CALL((*cuCtxGetCurrentPtr)(&dev->context), return -EFAULT);*/\n    return 0;\n}\n\n\n\nint nvmon_cupti_getEventsOfGpu(int gpuId, NvmonEventList_t* list)\n{\n    int ret = 0;\n    NvmonDevice device;\n    int err = nvmon_cupti_createDevice(gpuId, &device);\n    if (!err)\n    {\n        NvmonEventList_t l = malloc(sizeof(NvmonEventList));\n        if (l)\n        {\n            l->events = malloc(sizeof(NvmonEventListEntry) * device.numAllEvents);\n            if (l->events)\n            {\n                for (int i = 0; i < device.numAllEvents; i++)\n                {\n                    NvmonEventListEntry* out = &l->events[i];\n                    NvmonEvent_t event = device.allevents[i];\n                    out->name = malloc(strlen(event->name)+2);\n                    if (out->name)\n                    {\n                        ret = snprintf(out->name, strlen(event->name)+1, \"%s\", event->name);\n                        if (ret > 0)\n                        {\n                            out->name[ret] = '\\0';\n                        }\n                    }\n                    out->desc = malloc(strlen(event->description)+2);\n                    if (out->desc)\n                    {\n                        ret = snprintf(out->desc, strlen(event->description)+1, \"%s\", event->description);\n                        if (ret > 0)\n                        {\n                            out->desc[ret] = '\\0';\n                        }\n                    }\n                    out->limit = malloc(10*sizeof(char));\n                    if (out->limit)\n                    {\n                        switch (event->type)\n                        {\n                            case NVMON_CUPTI_EVENT:\n                                ret = snprintf(out->limit, 9, \"GPU\");\n                                if (ret > 0) out->limit[ret] = '\\0';\n                                break;\n                        }\n                    }\n                }\n                l->numEvents = device.numAllEvents;\n                *list = l;\n            }\n            else\n            {\n                free(l);\n                nvmon_cupti_freeDevice(&device);\n                return -ENOMEM;\n            }\n        }\n    }\n    else\n    {\n        ERROR_PRINT(No such device %d, gpuId);\n    }\n    return 0;\n}\n\n\n\nint\nnvmon_cupti_addEventSets(NvmonDevice_t device, const char* eventString)\n{\n    int i = 0;\n    int err = 0;\n    int curDeviceId = -1;\n    CUcontext curContext;\n    struct bstrList* eventtokens = NULL;\n\n    CUDA_CALL((*cudaGetDevicePtr)(&curDeviceId), return -EFAULT);\n    CUDA_CALL((*cudaFreePtr)(NULL), return -EFAULT);\n    CU_CALL((*cuCtxGetCurrentPtr)(&curContext), return -EFAULT);\n\n    bstring eventBString = bfromcstr(eventString);\n    eventtokens = bsplit(eventBString, ',');\n    bdestroy(eventBString);\n\n    if (curDeviceId != device->deviceId)\n    {\n        CUDA_CALL((*cudaSetDevicePtr)(device->deviceId), return -EFAULT);\n    }\n\n    size_t sizeBytes = (eventtokens->qty) * sizeof(CUpti_EventID);\n\n    int popContext = 0;\n    CUpti_EventGroupSets * cuEventSets = NULL;\n\n    NvmonEventSet* tmpEventSet = realloc(device->nvEventSets, (device->numNvEventSets+1)*sizeof(NvmonEventSet));\n    if (!tmpEventSet)\n    {\n        ERROR_PRINT(Cannot enlarge GPU %d eventSet list, device->deviceId);\n        return -ENOMEM;\n    }\n    device->nvEventSets = tmpEventSet;\n    NvmonEventSet* devEventSet = &device->nvEventSets[device->numNvEventSets];\n\n    devEventSet->nvEvents = (NvmonEvent_t*) malloc(eventtokens->qty * sizeof(NvmonEvent_t));\n    if (devEventSet->nvEvents == NULL)\n    {\n        ERROR_PRINT(Cannot allocate event list for group %d\\n, groupSet->numberOfActiveGroups);\n        return -ENOMEM;\n    }\n    devEventSet->cuEventIDs = (CUpti_EventID*) malloc(eventtokens->qty * sizeof(CUpti_EventID));\n    if (devEventSet->cuEventIDs == NULL)\n    {\n        ERROR_PRINT(Cannot allocate event ID list for group %d\\n, groupSet->numberOfActiveGroups);\n        free(devEventSet->nvEvents);\n        return -ENOMEM;\n    }\n    devEventSet->results = malloc(eventtokens->qty * sizeof(NvmonEventResult));\n    if (devEventSet->cuEventIDs == NULL)\n    {\n        ERROR_PRINT(Cannot allocate result list for group %d\\n, groupSet->numberOfActiveGroups);\n        free(devEventSet->cuEventIDs);\n        free(devEventSet->nvEvents);\n        return -ENOMEM;\n    }\n    memset(devEventSet->results, 0, eventtokens->qty * sizeof(NvmonEventResult));\n    devEventSet->numberOfEvents = 0;\n\n    // If the device has no context, check whether the current context is\n    // used already by another device\n    popContext = check_nv_context(device, curContext);\n\n\n    CUPTI_CALL((*cuptiSetEventCollectionModePtr)(device->context, CUPTI_EVENT_COLLECTION_MODE_KERNEL), return -EFAULT);\n\n    for (i = 0; i < eventtokens->qty; i++)\n    {\n        struct bstrList* evset = bsplit(eventtokens->entry[i], ':');\n        if (evset->qty != 2)\n        {\n            ERROR_PRINT(NVMON: Event %s invalid: Format <event>:<gpucounter>, bdata(eventtokens->entry[i]));\n        }\n        if (blength(evset->entry[0]) == 0 || blength(evset->entry[1]) == 0)\n        {\n            ERROR_PRINT(NVMON: Event %s invalid: Format <event>:<gpucounter>, bdata(eventtokens->entry[i]));\n        }\n        NvmonEvent_t event = g_hash_table_lookup(device->eventHash, (gpointer)bdata(evset->entry[0]));\n        if (!event)\n        {\n            GPUDEBUG_PRINT(DEBUGLEV_INFO, NVMON: Event %s unknown. Skipping..., bdata(evset->entry[0]));\n            continue; //unknown event\n        }\n        else\n        {\n            devEventSet->cuEventIDs[devEventSet->numberOfEvents] = event->cuEventId;\n            devEventSet->nvEvents[devEventSet->numberOfEvents] = event;\n            devEventSet->numberOfEvents++;\n            size_t s = devEventSet->numberOfEvents*sizeof(CUpti_EventID);\n\n            CUPTI_CALL((*cuptiEventGroupSetsCreatePtr)(device->context, s, devEventSet->cuEventIDs, &cuEventSets), devEventSet->numberOfEvents--;);\n            if (cuEventSets->numSets > 1)\n            {\n                ERROR_PRINT(Error adding event %s. Multiple measurement runs are required. skipping event ..., bdata(evset->entry[i]));\n                continue;\n            }\n        }\n    }\n    devEventSet->id = nvGroupSet->numberOfActiveGroups;\n    // Create an eventset with the currently configured and current event\n    if(popContext)\n    {\n        CU_CALL((*cuCtxPopCurrentPtr)(&device->context), return -EFAULT);\n    }\n    device->numNvEventSets++;\n}\n\nint nvmon_cupti_setupCounters(NvmonDevice_t device, NvmonEventSet* eventSet)\n{\n    int err = 0;\n    int popContext = 0;\n    int oldDevId = -1;\n    CUpti_EventGroupSets * cuEventSets = NULL;\n    CUcontext curContext;\n\n    if (eventSet->numberOfEvents == 0)\n    {\n        GPUDEBUG_PRINT(DEBUGLEV_DETAIL, Skipping GPU%d it has no events in group %d, device->deviceId, eventSet->id);\n        return -EINVAL;\n    }\n    // Currently we are on which device?\n    CUDA_CALL((*cudaGetDevicePtr)(&oldDevId), return -EFAULT);\n    // This is a workaround to (eventually create and) get the current context\n    CUDA_CALL((*cudaFreePtr)(NULL), return -EFAULT);\n    CU_CALL((*cuCtxGetCurrentPtr)(&curContext), return -EFAULT);\n\n    popContext = check_nv_context(device, curContext);\n\n\n    size_t grpEventIdsSize = eventSet->numberOfEvents * sizeof(CUpti_EventID);\n    CUPTI_CALL((*cuptiEventGroupSetsCreatePtr)(device->context, grpEventIdsSize, eventSet->cuEventIDs, &cuEventSets), err = -1;);\n    // Allocate temporary array to hold the group event IDs\n    CUpti_EventID *grpEventIds = malloc(grpEventIdsSize);\n    if (!grpEventIds)\n    {\n        return -ENOMEM;\n    }\n    // Delete current activeEvent list\n    if (device->activeEvents)\n    {\n        free(device->activeEvents);\n        device->activeEvents = NULL;\n        device->numActiveEvents = 0;\n    }\n    // Delete current activeCuGroups list\n    if (device->activeCuGroups)\n    {\n        free(device->activeCuGroups);\n        device->activeCuGroups = NULL;\n        device->numActiveCuGroups = 0;\n    }\n\n    // Create a new activeEvent list\n    device->activeEvents = malloc(eventSet->numberOfEvents * sizeof(NvmonActiveEvent));\n    if (!device->activeEvents)\n    {\n        free(grpEventIds);\n        grpEventIds = NULL;\n        return -ENOMEM;\n    }\n    // Create a new activeCuGroups list\n    device->activeCuGroups = malloc(cuEventSets->numSets * sizeof(CUpti_EventGroupSet**));\n    if (!device->activeCuGroups)\n    {\n        free(device->activeEvents);\n        device->activeEvents = NULL;\n        free(grpEventIds);\n        grpEventIds = NULL;\n        return -ENOMEM;\n    }\n\n\n    // Run over eventset and store all information we need for start/stop/reads in NvmonActiveEvent_t\n    CUpti_EventGroup curGroup;\n    uint32_t curNumInstances = 0, curNumTotalInstances = 0;\n    CUpti_EventGroupSet *curEventGroupSet;\n    for (int j = 0; j < cuEventSets->numSets; j++)\n    {\n        size_t sizeofuint32t = sizeof(uint32_t);\n        uint32_t numGEvents = 0, numGInstances = 0, numTotalGInstances = 0;\n        CUpti_EventGroupSet* groupset = &cuEventSets->sets[j];\n\n        for (int k = 0; k < groupset->numEventGroups; k++)\n        {\n            uint32_t one = 1;\n            CUpti_EventGroup group = groupset->eventGroups[k];\n            // Get the number of events in the group\n            CUPTI_CALL((*cuptiEventGroupGetAttributePtr)(group, CUPTI_EVENT_GROUP_ATTR_NUM_EVENTS, &sizeofuint32t, &numGEvents), return -EFAULT);\n            // Get the CUPTI event IDs in the group\n            CUPTI_CALL((*cuptiEventGroupGetAttributePtr)(group, CUPTI_EVENT_GROUP_ATTR_EVENTS, &grpEventIdsSize, grpEventIds), return -EFAULT);\n            // If we don't set this, each event has only a single instance but we want to measure all instances\n            CUPTI_CALL((*cuptiEventGroupSetAttributePtr)(group, CUPTI_EVENT_GROUP_ATTR_PROFILE_ALL_DOMAIN_INSTANCES, sizeof(uint32_t), &one), return -EFAULT);\n            // Get instance count for a group\n            CUPTI_CALL((*cuptiEventGroupGetAttributePtr)(group, CUPTI_EVENT_GROUP_ATTR_INSTANCE_COUNT, &sizeofuint32t, &numGInstances), return -EFAULT);\n\n            for (int l = 0; l < numGEvents; l++)\n            {\n                for (int m = 0; m <  eventSet->numberOfEvents; m++)\n                {\n                    if (eventSet->cuEventIDs[m] == grpEventIds[l])\n                    {\n                        CUpti_EventDomainID did = eventSet->nvEvents[m]->cuDomainId;\n                        // Get total instance count for a group\n                        CUPTI_CALL((*cuptiDeviceGetEventDomainAttributePtr)(device->cuDevice, did, CUPTI_EVENT_DOMAIN_ATTR_TOTAL_INSTANCE_COUNT, &sizeofuint32t, &numTotalGInstances), return -EFAULT);\n                        device->activeEvents[m].eventId = eventSet->nvEvents[m]->eventId;\n                        device->activeEvents[m].idxInSet = m;\n                        device->activeEvents[m].groupId = eventSet->id;\n                        device->activeEvents[m].cuEventId = eventSet->nvEvents[m]->cuEventId;\n                        device->activeEvents[m].cuDomainId = did;\n                        device->activeEvents[m].numTotalInstances = numTotalGInstances;\n                        device->activeEvents[m].cuGroup = group;\n                        device->activeEvents[m].cuGroupSet = groupset;\n                        device->activeEvents[m].numInstances = numGInstances;\n                        device->activeEvents[m].deviceId = device->deviceId;\n\n                        int found = 0;\n                        for (int i = 0; i < device->numActiveCuGroups; i++)\n                        {\n                            if (device->activeCuGroups[i] == groupset)\n                            {\n                                found = 1;\n                            }\n                        }\n                        if (!found)\n                        {\n                            device->activeCuGroups[device->numActiveCuGroups] = groupset;\n                            device->numActiveCuGroups++;\n                        }\n                        // Mark event as active. This is used to avoid measuring the same event on the same device twice\n                        eventSet->nvEvents[m]->active = 1;\n                        GPUDEBUG_PRINT(DEBUGLEV_INFO, Setup event %s (%d) for GPU %d, eventSet->nvEvents[m]->name, device->activeEvents[m].cuEventId, device->deviceId);\n                        device->numActiveEvents++;\n                    }\n                }\n            }\n        }\n    }\n    free(grpEventIds);\n    if(popContext)\n    {\n        CU_CALL((*cuCtxPopCurrentPtr)(&device->context), return -EFAULT);\n    }\n    return 0;\n}\n\nint nvmon_cupti_startCounters(NvmonDevice_t device)\n{\n    int j = 0;\n    CUcontext curContext;\n    int popContext = 0;\n    uint32_t one = 1;\n    uint64_t timestamp = 0;\n    int oldDevId = -1;\n\n    // Currently we are on which device?\n    CUDA_CALL((*cudaGetDevicePtr)(&oldDevId), return -EFAULT);\n    // Take the timestamp, we assign it later for all devices\n    CUPTI_CALL((*cuptiGetTimestampPtr)(&timestamp), return -EFAULT);\n    // This is a workaround to (eventually create and) get the current context\n    CUDA_CALL((*cudaFreePtr)(NULL), return -EFAULT);\n    CU_CALL((*cuCtxGetCurrentPtr)(&curContext), return -EFAULT);\n\n\n    //NvmonDevice_t device = &nvGroupSet->gpus[i];\n    if (device->numActiveCuGroups == 0)\n    {\n        GPUDEBUG_PRINT(DEBUGLEV_DETAIL, Skipping GPU%d it has no events in group %d, device->deviceId, nvGroupSet->activeGroup);\n        return 0;\n    }\n    if (device->deviceId != oldDevId)\n    {\n        GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Change GPU device %d -> %d, oldDevId, device->deviceId);\n        CUDA_CALL((*cudaSetDevicePtr)(device->deviceId), return -EFAULT);\n        CUDA_CALL((*cudaGetDevicePtr)(&oldDevId), return -EFAULT);\n    }\n    CU_CALL((*cuCtxGetCurrentPtr)(&curContext), return -EFAULT);\n    device->timeStart = timestamp;\n    device->timeRead = timestamp;\n\n    // Are we in the proper context?\n    popContext = check_nv_context(device, curContext);\n\n    NvmonEventSet* nvEventSet = &device->nvEventSets[nvGroupSet->activeGroup];\n    for (j = 0; j < nvEventSet->numberOfEvents; j++)\n    {\n        NvmonEventResult* res = &nvEventSet->results[j];\n        res->startValue = 0.0;\n        res->stopValue = 0.0;\n        res->currentValue = 0.0;\n        res->fullValue = 0.0;\n        res->overflows = 0;\n    }\n\n    for (j = 0; j < device->numActiveCuGroups; j++)\n    {\n        GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Enable group %ld on Dev %d, device->activeCuGroups[j], device->deviceId);\n        CUPTI_CALL((*cuptiEventGroupSetEnablePtr)(device->activeCuGroups[j]), return -EFAULT);\n    }\n\n    // If we added the device context to the stack, pop it again\n    if (popContext)\n    {\n        GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Pop Context %ld for device %d, device->context, device->deviceId);\n        CU_CALL((*cuCtxPopCurrentPtr)(&device->context), return -EFAULT);\n    }\n}\n\n\nint nvmon_cupti_stopCounters(NvmonDevice_t device)\n{\n    int i = 0, j = 0, k = 0;\n    int oldDevId = -1;\n    uint64_t timestamp = 0;\n    CUcontext curContext;\n\n\n    CUDA_CALL((*cudaGetDevicePtr)(&oldDevId), return -EFAULT);\n    // Take the timestamp, we assign it later for all devices\n    CUPTI_CALL((*cuptiGetTimestampPtr)(&timestamp), return -EFAULT);\n\n\n    for (i = 0; i < nvGroupSet->numberOfGPUs; i++)\n    {\n        int popContext = 0;\n        uint32_t one = 1;\n        int maxTotalInstances = 0;\n        size_t valuesSize = 0;\n        NvmonDevice_t device = &nvGroupSet->gpus[i];\n        if (device->deviceId != oldDevId)\n        {\n            GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Change GPU device %d -> %d, oldDevId, device->deviceId);\n            CUDA_CALL((*cudaSetDevicePtr)(device->deviceId), return -EFAULT);\n            CUDA_CALL((*cudaGetDevicePtr)(&oldDevId), return -EFAULT);\n        }\n        CU_CALL((*cuCtxGetCurrentPtr)(&curContext), return -EFAULT);\n        NvmonEventSet* nvEventSet = &device->nvEventSets[nvGroupSet->activeGroup];\n        if (device->numActiveCuGroups == 0)\n        {\n            GPUDEBUG_PRINT(DEBUGLEV_DETAIL, Skipping GPU%d it has no events in group %d, device->deviceId, nvGroupSet->activeGroup);\n            continue;\n        }\n        device->timeStop = timestamp;\n\n        // Are we in the proper context?\n        popContext = check_nv_context(device, curContext);\n\n        for (j = 0; j < device->numActiveEvents; j++)\n        {\n            maxTotalInstances = MAX(maxTotalInstances, device->activeEvents[j].numTotalInstances);\n        }\n        uint64_t *tmpValues = (uint64_t *) malloc(maxTotalInstances * sizeof(uint64_t));\n\n        for (j = 0; j < device->numActiveEvents; j++)\n        {\n            NvmonActiveEvent_t event = &device->activeEvents[j];\n            valuesSize = sizeof(uint64_t) * event->numTotalInstances;\n            memset(tmpValues, 0, valuesSize);\n            GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Read Grp %ld Ev %ld for device %d, event->cuGroup, event->cuEventId, device->deviceId);\n            CUPTI_CALL((*cuptiEventGroupReadEventPtr)(event->cuGroup, CUPTI_EVENT_READ_FLAG_NONE, event->cuEventId, &valuesSize, tmpValues), free(tmpValues); return -EFAULT);\n            uint64_t valuesum = 0;\n            for (k = 0; k < event->numInstances; k++)\n            {\n                valuesum += tmpValues[k];\n            }\n            NvmonEventResult* res = &nvEventSet->results[event->idxInSet];\n            res->stopValue = (double)valuesum;\n            res->lastValue = res->currentValue;\n            res->fullValue += res->stopValue - res->startValue;\n            res->lastValue += res->stopValue - res->currentValue;\n            res->currentValue = (double)valuesum;\n        }\n        for (j = 0; j < device->numActiveCuGroups; j++)\n        {\n            GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Disable group %ld, device->activeCuGroups[j]);\n            CUPTI_CALL((*cuptiEventGroupSetDisablePtr)(device->activeCuGroups[j]), return -EFAULT);\n        }\n        // If we added the device context to the stack, pop it again\n        if (popContext)\n        {\n            GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Pop Context %ld for device %d, device->context, device->deviceId);\n            CU_CALL((*cuCtxPopCurrentPtr)(&device->context), return -EFAULT);\n        }\n    }\n}\n\n\nint nvmon_cupti_readCounters(NvmonDevice_t device)\n{\n    int j = 0, k = 0;\n    int oldDevId = -1;\n    uint64_t timestamp = 0;\n    CUcontext curContext;\n    size_t sizeofuint32num = sizeof(uint32_t);\n    int maxTotalInstances = 0;\n\n\n    for (j = 0; j < device->numActiveEvents; j++)\n    {\n        maxTotalInstances = MAX(maxTotalInstances, device->activeEvents[j].numTotalInstances);\n    }\n\n\n    // In this array we collect the instance values of an events (summed up later)\n    size_t valuesSize = sizeof(uint64_t) * maxTotalInstances;\n    uint64_t *tmpValues = (uint64_t *) malloc(valuesSize);\n    if (!tmpValues)\n    {\n        ERROR_PRINT(Not enough memory to allocate space for instance values);\n        return -ENOMEM;\n    }\n\n    // Currently we are on which device?\n    CUDA_CALL((*cudaGetDevicePtr)(&oldDevId), return -EFAULT);\n    // Take the timestamp, we assign it later for all devices\n    CUPTI_CALL((*cuptiGetTimestampPtr)(&timestamp), return -EFAULT);\n/*    // This is a workaround to (eventually create and) get the current context*/\n/*    CUDA_CALL((*cudaFreePtr)(NULL), return -EFAULT);*/\n    CU_CALL((*cuCtxGetCurrentPtr)(&curContext), return -EFAULT);\n\n\n    int popContext = 0;\n    if (device->numActiveEvents == 0)\n    {\n        GPUDEBUG_PRINT(DEBUGLEV_DETAIL, Skipping GPU%d it has no events in group %d, device->deviceId, nvGroupSet->activeGroup);\n        return 0;\n    }\n    if (device->deviceId != oldDevId)\n    {\n        GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Change GPU device %d -> %d, oldDevId, device->deviceId);\n        CUDA_CALL((*cudaSetDevicePtr)(device->deviceId), return -EFAULT);\n        CUDA_CALL((*cudaGetDevicePtr)(&oldDevId), return -EFAULT);\n    }\n    CUDA_CALL((*cudaFreePtr)(NULL), return -EFAULT);\n    CU_CALL((*cuCtxGetCurrentPtr)(&curContext), return -EFAULT);\n    device->timeRead = timestamp;\n\n    // Are we in the proper context?\n    popContext = check_nv_context(device, curContext);\n    // Synchronize devices. I'm not sure whether this is required as each\n    // device measures it's own events\n    CU_CALL((*cuCtxSynchronizePtr)(), return -EFAULT);\n    NvmonEventSet* nvEventSet = &device->nvEventSets[nvGroupSet->activeGroup];\n\n    for (j = 0; j < device->numActiveEvents; j++)\n    {\n        NvmonActiveEvent_t event = &device->activeEvents[j];\n        // Empty space for instance values\n        valuesSize = sizeof(uint64_t) * event->numTotalInstances;\n        memset(tmpValues, 0, valuesSize);\n        // Read all instance values\n        GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Read Grp %ld Ev %ld for device %d, event->cuGroup, event->cuEventId, device->deviceId);\n        CUPTI_CALL((*cuptiEventGroupReadEventPtr)(event->cuGroup, CUPTI_EVENT_READ_FLAG_NONE, event->cuEventId, &valuesSize, tmpValues), return -EFAULT);\n        // Sum all instance values\n        uint64_t valuesum = 0;\n        for (k = 0; k < event->numInstances; k++)\n        {\n            valuesum += tmpValues[k];\n        }\n\n        NvmonEventResult* res = &nvEventSet->results[event->idxInSet];\n        res->lastValue = res->currentValue;\n        res->currentValue = (double)valuesum;\n        res->fullValue += res->currentValue - res->startValue;\n        res->lastValue += res->currentValue - res->lastValue;\n    }\n    if (popContext)\n    {\n        GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Pop Context %ld for device %d, device->context, device->deviceId);\n        CU_CALL((*cuCtxPopCurrentPtr)(&device->context), return -EFAULT);\n    }\n    free(tmpValues);\n    return 0;\n}\n\n\nNvmonFunctions nvmon_cupti_functions = {\n    .freeDevice = nvmon_cupti_freeDevice,\n    .createDevice = nvmon_cupti_createDevice,\n    .getEventList = nvmon_cupti_getEventsOfGpu,\n    .addEvents = nvmon_cupti_addEventSets,\n    .setupCounters = nvmon_cupti_setupCounters,\n    .startCounters = nvmon_cupti_startCounters,\n    .readCounters = nvmon_cupti_readCounters,\n};\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.0-wsmvcyg57s3cluiv7iuyeyprx4ea4ctz/spack-src/src/includes/nvmon_perfworks.h": "/*\n * =======================================================================================\n *\n *      Filename:  nvmon_perfworks.h\n *\n *      Description:  Header File of nvmon module (PerfWorks backend).\n *\n *      Version:   5.0\n *      Released:  10.11.2019\n *\n *      Author:   Thomas Gruber (tg), thomas.gruber@googlemail.com\n *      Project:  likwid\n *\n *      Copyright (C) 2019 RRZE, University Erlangen-Nuremberg\n *\n *      This program is free software: you can redistribute it and/or modify it under\n *      the terms of the GNU General Public License as published by the Free Software\n *      Foundation, either version 3 of the License, or (at your option) any later\n *      version.\n *\n *      This program is distributed in the hope that it will be useful, but WITHOUT ANY\n *      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n *      PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n *\n *      You should have received a copy of the GNU General Public License along with\n *      this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * =======================================================================================\n */\n#ifndef LIKWID_NVMON_PERFWORKS_H\n#define LIKWID_NVMON_PERFWORKS_H\n\n#if __CUDA_API_VERSION >= 10000\n\nstatic void *perfw_dl_libnvperf = NULL;\nstatic void *perfw_dl_libnvperf_t = NULL;\nstatic void *perfw_dl_libcupti = NULL;\nstatic void *perfw_dl_libcuda = NULL;\n#include <cupti_target.h>\n#include <cupti_profiler_target.h>\n#include <cuda_runtime_api.h>\n\n\n#include <nvperf_host.h>\n#include <nvperf_cuda_host.h>\n#include<nvperf_target.h>\n\n#define CUPTI_API_CALL(apiFuncCall)                                            \\\ndo {                                                                           \\\n    CUptiResult _status = apiFuncCall;                                         \\\n    if (_status != CUPTI_SUCCESS) {                                            \\\n        fprintf(stderr, \"%s:%d: error: function %s failed with error %d.\\n\",   \\\n                __FILE__, __LINE__, #apiFuncCall, _status);                    \\\n        exit(-1);                                                              \\\n    }                                                                          \\\n} while (0)\n\n\n\n#define NVPERFAPIWEAK __attribute__( ( weak ) )\n\n#define DECLARENVPERFFUNC(funcname, funcsig) NVPA_Status NVPERFAPIWEAK funcname funcsig;  NVPA_Status( *funcname##Ptr ) funcsig;\n//DECLARENVPERFFUNC(NVPW_MetricsContext_GetMetricNames_Begin, (NVPW_GetSupportedChipNames_Params *));\n\nDECLARENVPERFFUNC(NVPW_CUDA_MetricsContext_Create, (NVPW_CUDA_MetricsContext_Create_Params *));\nDECLARENVPERFFUNC(NVPW_MetricsContext_Destroy, (NVPW_MetricsContext_Destroy_Params*));\nDECLARENVPERFFUNC(NVPW_MetricsContext_GetMetricNames_Begin, (NVPW_MetricsContext_GetMetricNames_Begin_Params*));\nDECLARENVPERFFUNC(NVPW_MetricsContext_GetMetricNames_End, (NVPW_MetricsContext_GetMetricNames_End_Params*));\nDECLARENVPERFFUNC(NVPW_GetSupportedChipNames, (NVPW_GetSupportedChipNames_Params*));\nDECLARENVPERFFUNC(NVPW_Device_GetNames, (NVPW_Device_GetNames_Params*))\n\n#ifndef DECLARECUPTIFUNC\n#define CUPTIAPIWEAK __attribute__( ( weak ) )\n#define DECLARECUPTIFUNC(funcname, funcsig) CUptiResult CUPTIAPIWEAK funcname funcsig;  CUptiResult( *funcname##Ptr ) funcsig;\n#endif\n\nDECLARECUPTIFUNC(cuptiDeviceGetChipName, (CUpti_Device_GetChipName_Params*));\n\n#ifndef DECLARECUFUNC\n#define CUAPIWEAK __attribute__( ( weak ) )\n#define DECLARECUFUNC(funcname, funcsig) CUresult CUAPIWEAK funcname funcsig;  CUresult( *funcname##Ptr ) funcsig;\n#endif\n\nDECLARECUFUNC(cuInit, (unsigned int));\n\n#ifndef DLSYM_AND_CHECK\n#define DLSYM_AND_CHECK( dllib, name ) dlsym( dllib, name ); if ( dlerror() != NULL ) { return -1; }\n#endif\n\nstatic int\nlink_perfworks_libraries(void)\n{\n    if(_dl_non_dynamic_init != NULL) {\n        return -1;\n    }\n    perfw_dl_libcuda = dlopen(\"libcuda.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (!perfw_dl_libcuda)\n    {\n        fprintf(stderr, \"CUDA library libcuda.so not found.\\n\");\n        return -1;\n    }\n    perfw_dl_libnvperf = dlopen(\"libnvperf_host.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (!perfw_dl_libnvperf)\n    {\n        fprintf(stderr, \"CUDA library libnvperf_host.so not found.\\n\");\n        return -1;\n    }\n    perfw_dl_libnvperf_t = dlopen(\"libnvperf_target.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (!perfw_dl_libnvperf_t)\n    {\n        fprintf(stderr, \"CUDA library libnvperf_target.so not found.\\n\");\n        return -1;\n    }\n    perfw_dl_libcupti = dlopen(\"libcupti.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (!perfw_dl_libcupti)\n    {\n        fprintf(stderr, \"CUDA runtime library libcupti.so not found.\\n\");\n        return -1;\n    }\n    cuInitPtr = DLSYM_AND_CHECK(perfw_dl_libcuda, \"cuInit\");\n    cuptiDeviceGetChipNamePtr = DLSYM_AND_CHECK(perfw_dl_libcupti, \"cuptiDeviceGetChipName\");\n    NVPW_CUDA_MetricsContext_CreatePtr = DLSYM_AND_CHECK(perfw_dl_libnvperf, \"NVPW_CUDA_MetricsContext_Create\");\n    //NVPW_GetSupportedChipNamesPtr = DLSYM_AND_CHECK(perfw_dl_libnvperf, \"NVPW_GetSupportedChipNames\");\n    NVPW_Device_GetNamesPtr = DLSYM_AND_CHECK(perfw_dl_libnvperf_t, \"NVPW_Device_GetNames\");\n\n\n    CUresult cuErr = (*cuInitPtr)(0);\n    if (cuErr != CUDA_SUCCESS)\n    {\n        fprintf(stderr, \"CUDA cannot be found and initialized (cuInit failed).\\n\");\n        return -ENODEV;\n    }\n    return 0;\n}\n\nstatic void\nrelease_perfworks_libraries(void)\n{\n    if (perfw_dl_libnvperf)\n    {\n        dlclose(perfw_dl_libnvperf);\n        perfw_dl_libnvperf = NULL;\n    }\n    if (perfw_dl_libcupti)\n    {\n        dlclose(perfw_dl_libcupti);\n        perfw_dl_libcupti = NULL;\n    }\n}\n\nint nvmon_perfworks_getEventsOfGpu(int gpuId, NvmonEventList_t* list)\n{\n    NVPA_Status err = 0;\n    int ret = topology_gpu_init();\n    if (ret != EXIT_SUCCESS)\n    {\n        return -ENODEV;\n    }\n    GpuTopology_t gtopo = get_gpuTopology();\n    ret = link_perfworks_libraries();\n    if (ret < 0)\n    {\n        return ret;\n    }\n\n\n    NVPW_Device_GetNames_Params getNamesParams = {NVPW_Device_GetNames_Params_STRUCT_SIZE};\n    err = (*NVPW_Device_GetNamesPtr)(&getNamesParams);\n    if (err != NVPA_STATUS_SUCCESS)\n    {\n        fprintf(stderr, \"Cannot get name of GPU chip %d\\n\", err);\n        return -ENODEV;\n    }\n    printf(\"GPU name %s\\n\", getNamesParams.pChipName);\n    printf(\"GPU name %s\\n\", getNamesParams.pDeviceName);\n\n/*    */\n/*    CUpti_Device_GetChipName_Params getChipNameParams = { CUpti_Device_GetChipName_Params_STRUCT_SIZE };*/\n/*    getChipNameParams.pPriv = NULL;*/\n/*    getChipNameParams.deviceIndex = 0;*/\n/*    */\n/*    */\n/*    */\n/*    NVPW_CUDA_MetricsContext_Create_Params metricsContextCreateParams = { NVPW_CUDA_MetricsContext_Create_Params_STRUCT_SIZE };*/\n/*    metricsContextCreateParams.pChipName = getChipNameParams.pChipName;*/\n/*    err = (*NVPW_CUDA_MetricsContext_CreatePtr)(&metricsContextCreateParams);*/\n/*    printf(\"Here\\n\");*/\n/*    if (err != NVPA_STATUS_SUCCESS)*/\n/*    {*/\n/*        printf(\"Failed to get event list of device %d\\n\", gpuId);*/\n/*        return -ENODEV;*/\n/*    }*/\n/*    NVPW_MetricsContext_Destroy_Params metricsContextDestroyParams = { NVPW_MetricsContext_Destroy_Params_STRUCT_SIZE };*/\n/*    metricsContextDestroyParams.pMetricsContext = metricsContextCreateParams.pMetricsContext;*/\n/*    err = myNVPW_MetricsContext_Destroy((NVPW_MetricsContext_Destroy_Params *)&metricsContextDestroyParams);*/\n/*    */\n/*    NVPW_MetricsContext_GetMetricNames_Begin_Params getMetricNameBeginParams = { NVPW_MetricsContext_GetMetricNames_Begin_Params_STRUCT_SIZE };*/\n/*    getMetricNameBeginParams.pMetricsContext = metricsContextCreateParams.pMetricsContext;*/\n/*    getMetricNameBeginParams.hidePeakSubMetrics = 0;*/\n/*    getMetricNameBeginParams.hidePerCycleSubMetrics = 0;*/\n/*    getMetricNameBeginParams.hidePctOfPeakSubMetrics = 0;*/\n/*    err = myNVPW_MetricsContext_GetMetricNames_Begin(&getMetricNameBeginParams);*/\n/*    if (err != NVPA_STATUS_SUCCESS)*/\n/*    {*/\n/*        printf(\"Failed to get event list of device %d\\n\", gpuId);*/\n/*        return -ENODEV;*/\n/*    }*/\n/*    NVPW_MetricsContext_GetMetricNames_End_Params getMetricNameEndParams = { NVPW_MetricsContext_GetMetricNames_End_Params_STRUCT_SIZE };*/\n/*    getMetricNameEndParams.pMetricsContext = metricsContextCreateParams.pMetricsContext;*/\n/*    err = myNVPW_MetricsContext_GetMetricNames_End((NVPW_MetricsContext_GetMetricNames_End_Params *)&getMetricNameEndParams);*/\n/*    */\n/*    */\n/*    NvmonEventList_t l = malloc(sizeof(NvmonEventList));*/\n/*    if (l)*/\n/*    {*/\n/*        */\n/*        l->events = malloc(l->numEvents*sizeof(NvmonEventListEntry));*/\n/*        if (l->events)*/\n/*        {*/\n/*            for (int i = 0; i < getMetricNameBeginParams.numMetrics; i++)*/\n/*            {*/\n/*                NvmonEventListEntry* out = &l->events[i];*/\n/*                const char* mname = getMetricNameBeginParams.ppMetricNames[i];*/\n/*                out->name = malloc(strlen(mname)+2);*/\n/*                if (out->name)*/\n/*                {*/\n/*                    ret = snprintf(out->name, strlen(mname)+1, \"%s\", mname);*/\n/*                    if (ret > 0)*/\n/*                    {*/\n/*                        out->name[ret] = '\\0';*/\n/*                    }*/\n/*                }*/\n/*                out->limit = malloc(10*sizeof(char));*/\n/*                if (out->limit)*/\n/*                {*/\n/*                    ret = snprintf(out->limit, 9, \"GPU\");*/\n/*                    if (ret > 0) out->limit[ret] = '\\0';*/\n/*                }*/\n/*            }*/\n/*            l->numEvents = getMetricNameBeginParams.numMetrics;*/\n/*            *list = l;*/\n/*            return 0;*/\n/*        }*/\n/*        free(l);*/\n/*    }*/\n/*    return -ENOMEM;*/\n    return 0;\n}\n\n\n\nNvmonFunctions nvmon_perfworks_functions = {\n    .freeDevice = NULL,\n    .createDevice = NULL,\n    .getEventList = nvmon_perfworks_getEventsOfGpu,\n    .addEvents = NULL,\n    .setupCounters = NULL,\n    .startCounters = NULL,\n    .readCounters = NULL,\n};\n#else\nNvmonFunctions nvmon_perfworks_functions = {\n    .freeDevice = NULL,\n    .createDevice = NULL,\n    .getEventList = NULL,\n    .addEvents = NULL,\n    .setupCounters = NULL,\n    .startCounters = NULL,\n    .readCounters = NULL,\n};\n\n#endif\n\n#endif /* LIKWID_NVMON_PERFWORKS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.0-wsmvcyg57s3cluiv7iuyeyprx4ea4ctz/spack-src/src/pthread-overload/pthread-overload.c": "/*\n * =======================================================================================\n *\n *      Filename:  pthread-overload.c\n *\n *      Description:  Overloaded library for pthread_create call. \n *                    Implements pinning of threads together with likwid-pin.\n *\n *      Version:   5.0\n *      Released:  10.11.2019\n *\n *      Author:  Jan Treibig (jt), jan.treibig@gmail.com\n *      Project:  likwid\n *\n *      Copyright (C) 2019 RRZE, University Erlangen-Nuremberg\n *\n *      This program is free software: you can redistribute it and/or modify it under\n *      the terms of the GNU General Public License as published by the Free Software\n *      Foundation, either version 3 of the License, or (at your option) any later\n *      version.\n *\n *      This program is distributed in the hope that it will be useful, but WITHOUT ANY\n *      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n *      PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n *\n *      You should have received a copy of the GNU General Public License along with\n *      this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * =======================================================================================\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <dlfcn.h>\n#include <sched.h>\n#include <bits/pthreadtypes.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/syscall.h>\n\n#ifdef COLOR\n#include <textcolor.h>\n#endif\n\n#define STRINGIFY(x) #x\n#define TOSTRING(x) STRINGIFY(x)\n#define LLU_CAST  (unsigned long long)\n\n#define gettid() syscall(SYS_gettid)\n\nextern int pthread_setaffinity_np(pthread_t thread, size_t cpusetsize, const cpu_set_t *cpuset);\n\nstatic char * sosearchpaths[] = {\n#ifdef LIBPTHREAD\n    TOSTRING(LIBPTHREAD),\n#endif\n    \"/lib64/tls/libpthread.so.0\",/* sles9 x86_64 */\n    \"libpthread.so.0\",           /* Ubuntu */\n    NULL\n};\n\n\n#ifdef COLOR\n#define color_print(format,...) do { \\\n        color_on(BRIGHT, COLOR); \\\n        printf(format, ##__VA_ARGS__); \\\n        color_reset(); \\\n    } while(0)\n#else\n#define color_print(format,...) do { \\\n        printf(format, ##__VA_ARGS__); \\\n    } while(0)\n#endif\n\nstatic int *pin_ids = NULL;\nstatic int ncpus = 0;\nstatic uint64_t skipMask = 0x0;\nstatic int silent = 0;\nvoid __attribute__((constructor (103))) init_pthread_overload(void)\n{\n    char *str = NULL;\n    char *token = NULL, *saveptr = NULL;\n    char *delimiter = \",\";\n    int i = 0;\n    static long avail_cpus = 0;\n    avail_cpus = sysconf(_SC_NPROCESSORS_CONF);\n    pin_ids = malloc(avail_cpus * sizeof(int));\n    memset(pin_ids, 0, avail_cpus * sizeof(int));\n    str = getenv(\"LIKWID_PIN\");\n    if (str != NULL)\n    {\n        token = str;\n        while (token)\n        {\n            token = strtok_r(str,delimiter,&saveptr);\n            str = NULL;\n            if (token)\n            {\n                ncpus++;\n                pin_ids[i++] = strtoul(token, &token, 10);\n            }\n        }\n    }\n    str = getenv(\"LIKWID_SKIP\");\n    if (str != NULL)\n    {\n        skipMask = strtoul(str, &str, 16);\n    }\n\n    if (getenv(\"LIKWID_SILENT\") != NULL)\n    {\n        silent = 1;\n    }\n}\n\nint __attribute__ ((visibility (\"default\") ))\npthread_create(pthread_t* thread,\n        const pthread_attr_t* attr,\n        void* (*start_routine)(void *),\n        void * arg)\n{\n    void *handle;\n    char *error;\n    int (*rptc) (pthread_t *, const pthread_attr_t *, void* (*start_routine)(void *), void *);\n    int ret;\n    static int reallpthrindex = 0;\n    static int npinned = 0;\n    static int ncalled = 0;\n    static int overflow = 0;\n    static int overflowed = 0;\n    static long online_cpus = 0;\n    static int shepard = 0;\n    online_cpus = sysconf(_SC_NPROCESSORS_ONLN);\n\n    /* On first entry: Get Evironment Variable and initialize pin_ids */\n    if (ncalled == 0 && pin_ids != NULL)\n    {\n        char* str = NULL;\n        cpu_set_t cpuset;\n\n        if (!silent)\n        {\n            color_print(\"[pthread wrapper] \\n\");\n        }\n\n        str = getenv(\"LIKWID_PIN\");\n        if (str != NULL)\n        {\n            CPU_ZERO(&cpuset);\n            CPU_SET(pin_ids[ncpus-1], &cpuset);\n            ret = sched_setaffinity(getpid(), sizeof(cpu_set_t), &cpuset);\n            if (!silent)\n            {\n                color_print(\"[pthread wrapper] MAIN -> %d\\n\",pin_ids[ncpus-1]);\n            }\n            //ncpus--; /* last ID is the first (the process was pinned to) */\n        }\n        else\n        {\n            color_print(\"[pthread wrapper] ERROR: Environment Variabel LIKWID_PIN not set!\\n\");\n        }\n\n        if (!silent)\n        {\n            color_print(\"[pthread wrapper] PIN_MASK: \");\n\n            for (int i=0;i<ncpus-1;i++)\n            {\n                color_print(\"%d->%d  \",i,pin_ids[i]);\n            }\n            color_print(\"\\n[pthread wrapper] SKIP MASK: 0x%llX\\n\",LLU_CAST skipMask);\n        }\n\n        overflow = ncpus-1;\n    }\n    Dl_info info;\n    if (dladdr(start_routine, &info) > 0)\n    {\n        FILE* fpipe;\n        char cmd[512];\n        char buff[512];\n        char file[256];\n        unsigned int ptr = ((void*)start_routine) - info.dli_fbase;\n\n        buff[0] = '\\0';\n        snprintf(file, 255, \"/tmp/likwidpin.%d\", gettid());\n        snprintf(cmd, 511, \"rm -f %s; nm %s 2>/dev/null | grep %x > %s\",\n                 file, info.dli_fname, ptr, file);\n        ret = system(cmd);\n        if (!access(file, R_OK))\n        {\n            fpipe = fopen(file, \"r\");\n            if (!fpipe)\n            {\n                fprintf(stderr, \"Problems reading symbols for shepard thread detection\\n\");\n            }\n            else\n            {\n                char* t = fgets(buff, 512, fpipe);\n                char* tmp = strstr(buff, \"monitor\");\n                if (tmp != NULL)\n                {\n                    shepard = 1;\n                    skipMask |= 1ULL<<(ncalled);\n                }\n                fclose(fpipe);\n                snprintf(cmd, 511, \"rm -f %s 2>/dev/null\", file);\n                ret = system(cmd);\n            }\n        }\n        else\n        {\n            fprintf(stderr, \"Problems reading symbols for shepard thread detection\\n\");\n        }\n    }\n\n    /* Handle dll related stuff */\n    do\n    {\n        handle = dlopen(sosearchpaths[reallpthrindex], RTLD_LAZY);\n        if (handle)\n        {\n            break;\n        }\n        if (sosearchpaths[reallpthrindex] != NULL)\n        {\n            reallpthrindex++;\n        }\n    }\n\n    while (sosearchpaths[reallpthrindex] != NULL);\n\n    if (!handle)\n    {\n        color_print(\"%s\\n\", dlerror());\n        return -1;\n    }\n\n    dlerror();    /* Clear any existing error */\n    rptc = dlsym(handle, \"pthread_create\");\n\n    if ((error = dlerror()) != NULL)\n    {\n        color_print(\"%s\\n\", error);\n        return -2;\n    }\n\n    ret = (*rptc)(thread, attr, start_routine, arg);\n\n    /* After thread creation pin the thread */\n    if (ret == 0)\n    {\n        cpu_set_t cpuset;\n\n        if ((ncalled<64) && (skipMask&(1ULL<<(ncalled))))\n        {\n            CPU_ZERO(&cpuset);\n            for (int i=0; i<online_cpus; i++)\n                CPU_SET(i, &cpuset);\n            pthread_setaffinity_np(*thread, sizeof(cpu_set_t), &cpuset);\n            if (!silent)\n            {\n                if (shepard)\n                    color_print(\"\\tthreadid %lu -> SKIP SHEPHERD\\n\", *thread);\n                else\n                    color_print(\"\\tthreadid %lu -> SKIP \\n\", *thread);\n                shepard = 0;\n            }\n        }\n        else\n        {\n            CPU_ZERO(&cpuset);\n            CPU_SET(pin_ids[npinned%ncpus], &cpuset);\n            pthread_setaffinity_np(*thread, sizeof(cpu_set_t), &cpuset);\n            if ((npinned == overflow) && (!overflowed))\n            {\n                if (!silent)\n                {\n                    color_print(\"Roundrobin placement triggered\\n\\tthreadid %lu -> core %d - OK\", *thread, pin_ids[npinned%ncpus]);\n                }\n                overflowed = 1;\n                npinned = (npinned+1)%ncpus;\n            }\n            else\n            {\n                if (!silent)\n                {\n                    color_print(\"\\tthreadid %lu -> core %d - OK\", *thread, pin_ids[npinned%ncpus]);\n                }\n                npinned++;\n                if ((npinned >= ncpus) && (overflowed))\n                {\n                    npinned = 0;\n                }\n            }\n\n            if (!silent)\n            {\n                color_print(\"\\n\");\n            }\n        }\n    }\n\n    fflush(stdout);\n    ncalled++;\n    dlclose(handle);\n\n    return ret;\n}\n\nvoid __attribute__((destructor (103))) close_pthread_overload(void)\n{\n    free(pin_ids);\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.0-wsmvcyg57s3cluiv7iuyeyprx4ea4ctz/spack-src/ext/GOTCHA/src/gotcha_dl.h": "#ifndef GOTCHA_DL_H\n#define GOTCHA_DL_H\n\n#include \"hash.h\"\n#include \"tool.h\"\n\nvoid handle_libdl();\nextern void update_all_library_gots(hash_table_t *bindings);\nextern int prepare_symbol(struct internal_binding_t *binding);\n\nextern gotcha_wrappee_handle_t orig_dlopen_handle;\nextern gotcha_wrappee_handle_t orig_dlsym_handle;\n\nextern struct gotcha_binding_t dl_binds[];\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.0-wsmvcyg57s3cluiv7iuyeyprx4ea4ctz/spack-src/ext/GOTCHA/src/gotcha_dl.c": "#define _GNU_SOURCE\n#include \"gotcha_dl.h\"\n#include \"tool.h\"\n#include \"libc_wrappers.h\"\n#include \"elf_ops.h\"\n#include <dlfcn.h>\n\nvoid* _dl_sym(void* handle, const char* name, void* where);\n\ngotcha_wrappee_handle_t orig_dlopen_handle;\ngotcha_wrappee_handle_t orig_dlsym_handle;\n\nstatic int per_binding(hash_key_t key, hash_data_t data, void *opaque KNOWN_UNUSED)\n{\n   int result;\n   struct internal_binding_t *binding = (struct internal_binding_t *) data;\n\n   debug_printf(3, \"Trying to re-bind %s from tool %s after dlopen\\n\",\n                binding->user_binding->name, binding->associated_binding_table->tool->tool_name);\n   \n   while (binding->next_binding) {\n      binding = binding->next_binding;\n      debug_printf(3, \"Selecting new innermost version of binding %s from tool %s.\\n\",\n                   binding->user_binding->name, binding->associated_binding_table->tool->tool_name);\n   }\n   \n   result = prepare_symbol(binding);\n   if (result == -1) {\n      debug_printf(3, \"Still could not prepare binding %s after dlopen\\n\", binding->user_binding->name);\n      return 0;\n   }\n\n   removefrom_hashtable(&notfound_binding_table, key);\n   return 0;\n}\n\nstatic void* dlopen_wrapper(const char* filename, int flags) {\n   typeof(&dlopen_wrapper) orig_dlopen = gotcha_get_wrappee(orig_dlopen_handle);\n   void *handle;\n   debug_printf(1, \"User called dlopen(%s, 0x%x)\\n\", filename, (unsigned int) flags);\n   handle = orig_dlopen(filename,flags);\n\n   debug_printf(2, \"Searching new dlopened libraries for previously-not-found exports\\n\");\n   foreach_hash_entry(&notfound_binding_table, NULL, per_binding);\n\n   debug_printf(2, \"Updating GOT entries for new dlopened libraries\\n\");\n   update_all_library_gots(&function_hash_table);\n  \n   return handle;\n}\n\nstatic void* dlsym_wrapper(void* handle, const char* symbol_name){\n  typeof(&dlsym_wrapper) orig_dlsym = gotcha_get_wrappee(orig_dlsym_handle);\n  struct internal_binding_t *binding;\n  int result;\n  \n  if(handle == RTLD_NEXT){\n    return _dl_sym(RTLD_NEXT, symbol_name ,__builtin_return_address(0));\n  }\n  \n  result = lookup_hashtable(&function_hash_table, (hash_key_t) symbol_name, (hash_data_t *) &binding);\n  if (result == -1)\n     return orig_dlsym(handle, symbol_name);\n  else\n     return binding->user_binding->wrapper_pointer;\n}\n\nstruct gotcha_binding_t dl_binds[] = {\n  {\"dlopen\", dlopen_wrapper, &orig_dlopen_handle},\n  {\"dlsym\", dlsym_wrapper, &orig_dlsym_handle}\n};     \nvoid handle_libdl(){\n  gotcha_wrap(dl_binds, 2, \"gotcha\");\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.0-wsmvcyg57s3cluiv7iuyeyprx4ea4ctz/spack-src/ext/GOTCHA/src/hash.c": "/*\nThis file is part of GOTCHA.  For copyright information see the COPYRIGHT\nfile in the top level directory, or at\nhttps://github.com/LLNL/gotcha/blob/master/COPYRIGHT\nThis program is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License (as published by the Free\nSoftware Foundation) version 2.1 dated February 1999.  This program is\ndistributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\nwithout even the IMPLIED WARRANTY OF MERCHANTABILITY or FITNESS FOR A PARTICULAR\nPURPOSE. See the terms and conditions of the GNU Lesser General Public License\nfor more details.  You should have received a copy of the GNU Lesser General\nPublic License along with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n*/\n\n#include \"libc_wrappers.h\"\n#include \"hash.h\"\n\n#define EMPTY 0\n#define TOMBSTONE 1\n#define INUSE 2\n\nstruct hash_entry_t {\n   hash_key_t key;\n   hash_data_t data;\n   hash_hashvalue_t hash_value;\n   struct hash_entry_t *next;\n   struct hash_entry_t *prev;\n   uint32_t status;\n};\n\ntypedef struct hash_entry_t hash_entry_t;\n\nint create_hashtable(hash_table_t *table, size_t initial_size, hash_func_t hashfunc, \n                     hash_cmp_t keycmp)\n{\n   hash_entry_t *newtable;\n   int entries_per_page;\n\n   entries_per_page = gotcha_getpagesize() / sizeof(hash_entry_t);\n   if (initial_size % entries_per_page)\n      initial_size += entries_per_page - (initial_size % entries_per_page);\n\n   newtable = (hash_entry_t *) gotcha_malloc(initial_size * sizeof(hash_entry_t));\n   if (!newtable)\n      return -1;\n   gotcha_memset(newtable, 0, initial_size * sizeof(hash_entry_t));\n\n   table->table_size = initial_size;\n   table->entry_count = 0;\n   table->hashfunc = hashfunc;\n   table->keycmp = keycmp;\n   table->table = newtable;\n   table->head = NULL;\n   \n   return 0;\n}\n\nstatic hash_entry_t *insert(hash_table_t *table, hash_key_t key, hash_data_t data, hash_hashvalue_t value)\n{\n   unsigned long index = (unsigned long)value % table->table_size;\n   unsigned long startindex = index;\n\n   hash_entry_t *entry = NULL;\n   do {\n      entry = table->table + index;\n      if (entry->status == EMPTY || entry->status == TOMBSTONE) {\n         entry->key = key;\n         entry->data = data;\n         entry->hash_value = value;\n         entry->status = INUSE;\n         break;\n      }\n      index++;\n      if (index == table->table_size)\n         index = 0;\n   } while (index != startindex);\n\n   if (!entry)\n      return NULL;\n\n   entry->next = table->head;\n   entry->prev = NULL;\n   if (table->head)\n      table->head->prev = entry;\n   table->head = entry;\n   table->entry_count++;         \n\n   return entry;\n}\n\nint grow_hashtable(hash_table_t *table, size_t new_size)\n{\n   hash_table_t newtable;\n   hash_entry_t *result;\n   size_t i;\n\n   newtable.table_size = new_size;\n   newtable.entry_count = 0;\n   newtable.hashfunc = table->hashfunc;\n   newtable.keycmp = table->keycmp;\n   newtable.table = (hash_entry_t *) gotcha_malloc(new_size * sizeof(hash_entry_t));\n   newtable.head = NULL;\n   gotcha_memset(newtable.table, 0, new_size * sizeof(hash_entry_t));\n\n   for (i = 0; i < table->table_size; i++) {\n      if (table->table[i].status == EMPTY || table->table[i].status == TOMBSTONE)\n         continue;\n      result = insert(&newtable, table->table[i].key, table->table[i].data,\n                      table->table[i].hash_value);\n      if (!result) {\n         return -1;\n      }\n   }\n\n   destroy_hashtable(table);\n   *table = newtable;\n   return 0;\n}\n\nint destroy_hashtable(hash_table_t *table)\n{\n   gotcha_free(table->table);\n   table->table_size = 0;\n   table->entry_count = 0;\n   table->hashfunc = NULL;\n   table->keycmp = NULL;\n   table->table = NULL;\n   table->head = NULL;\n   return 0;\n}\n\nstatic int lookup(hash_table_t *table, hash_key_t key, hash_entry_t **entry)\n{\n   size_t index, startindex;\n   hash_hashvalue_t hashval;\n\n   hashval = table->hashfunc(key);\n   index = hashval % table->table_size;\n   startindex = index;\n   \n   for (;;) {\n      hash_entry_t *cur = table->table + index;\n      if ((cur->status == INUSE) && \n          (cur->hash_value == hashval) && \n          (table->keycmp(cur->key, key) == 0)) {\n         *entry = cur;\n         return 0;\n      }\n\n      if (cur->status == EMPTY)\n         return -1;\n      index++;\n      if (index == table->table_size)\n         index = 0;\n      if (index == startindex)\n         return -1;\n   }\n}\n\nint lookup_hashtable(hash_table_t *table, hash_key_t key, hash_data_t *data)\n{\n   hash_entry_t *entry;\n   int result;\n\n   result = lookup(table, key, &entry);\n   if (result == -1)\n      return -1;\n   *data = entry->data;\n   return 0;\n}\n\nint addto_hashtable(hash_table_t *table, hash_key_t key, hash_data_t data)\n{\n   size_t newsize;\n   int result;\n   hash_hashvalue_t val;\n   hash_entry_t *entry;\n\n   newsize = table->table_size;\n   while (table->entry_count > newsize/2)\n      newsize *= 2;\n   if (newsize != table->table_size) {\n      result = grow_hashtable(table, newsize);\n      if (result == -1)\n         return -1;\n   }\n\n   val = table->hashfunc(key);\n   entry = insert(table, key, data, val);\n   if (!entry)\n      return -1;\n\n   return 0;\n}\n\nint removefrom_hashtable(hash_table_t *table, hash_key_t key)\n{\n   hash_entry_t *entry;\n   int result;\n\n   result = lookup(table, key, &entry);\n   if (result == -1)\n      return -1;\n\n   entry->key = NULL;\n   entry->data = NULL;\n   entry->hash_value = 0;\n   entry->status = TOMBSTONE;\n   if (entry->next)\n      entry->next->prev = entry->prev;\n   if (entry->prev)\n      entry->prev->next = entry->next;\n   if (table->head == entry)\n      table->head = entry->next;\n   //Do not set entry->next to NULL, which would break the iterate & delete\n   //idiom used under dlopen_wrapper.\n   \n   table->entry_count--;\n   return 0;\n}\n\nint foreach_hash_entry(hash_table_t *table, void *opaque, int (*cb)(hash_key_t key, hash_data_t data, void *opaque))\n{\n   int result;\n   struct hash_entry_t *i;\n   for (i = table->head; i != NULL; i = i->next) {\n      result = cb(i->key, i->data, opaque);\n      if (result != 0)\n         return result;\n   }\n   return 0;\n}\n\nhash_hashvalue_t strhash(const char *str)\n{\n   unsigned long hash = 5381;\n   int c;\n\n   while ((c = *str++))\n      hash = hash * 33 + c;\n\n   return (hash_hashvalue_t) hash;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.0-wsmvcyg57s3cluiv7iuyeyprx4ea4ctz/spack-src/ext/GOTCHA/src/gotcha.c": "/*\nThis file is part of GOTCHA.  For copyright information see the COPYRIGHT\nfile in the top level directory, or at\nhttps://github.com/LLNL/gotcha/blob/master/COPYRIGHT\nThis program is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License (as published by the Free\nSoftware Foundation) version 2.1 dated February 1999.  This program is\ndistributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\nwithout even the IMPLIED WARRANTY OF MERCHANTABILITY or FITNESS FOR A PARTICULAR\nPURPOSE. See the terms and conditions of the GNU Lesser General Public License\nfor more details.  You should have received a copy of the GNU Lesser General\nPublic License along with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n*/\n\n#include \"translations.h\"\n#include \"libc_wrappers.h\"\n#include \"gotcha/gotcha.h\"\n#include \"gotcha/gotcha_types.h\"\n#include \"gotcha_utils.h\"\n#include \"gotcha_auxv.h\"\n#include \"gotcha_dl.h\"\n#include \"elf_ops.h\"\n#include \"tool.h\"\n\nstatic void writeAddress(void* write, void* value){\n  *(void**)write = value;\n}\n\nstatic void** getBindingAddressPointer(struct gotcha_binding_t* in){\n  return (void**)in->function_handle;\n}\n\nstatic void setBindingAddressPointer(struct gotcha_binding_t* in, void* value){\n   void **target = getBindingAddressPointer(in);\n   debug_printf(3, \"Updating binding address pointer at %p to %p\\n\", target, value);\n   writeAddress(target, value);\n}\n\nstatic void** getInternalBindingAddressPointer(struct internal_binding_t** in){\n  return (void**)&((*in)->wrappee_pointer);\n}\n\nstatic void setInternalBindingAddressPointer(void** in, void* value){\n  void** target = getInternalBindingAddressPointer((struct internal_binding_t**)in);\n  debug_printf(3, \"Updating binding address pointer at %p to %p\\n\", target, value);\n  writeAddress(target, value);\n}\n\nint prepare_symbol(struct internal_binding_t *binding)\n{\n   int result;\n   struct link_map *lib;\n   struct gotcha_binding_t *user_binding = binding->user_binding;\n\n   debug_printf(2, \"Looking up exported symbols for %s\\n\", user_binding->name);\n   for (lib = _r_debug.r_map; lib != 0; lib = lib->l_next) {\n      struct library_t *int_library = get_library(lib);\n      if (!int_library) {\n         debug_printf(3, \"Creating new library object for %s\\n\", LIB_NAME(lib));\n         int_library = add_library(lib);\n      }\n      \n      if (is_vdso(lib)) {\n         debug_printf(2, \"Skipping VDSO library at 0x%lx with name %s\\n\",\n                      lib->l_addr, LIB_NAME(lib));\n         continue;\n      }\n      debug_printf(2, \"Searching for exported symbols in %s\\n\", LIB_NAME(lib));\n      INIT_DYNAMIC(lib);\n\n      if (!gnu_hash && !elf_hash) {\n         debug_printf(3, \"Library %s does not export or import symbols\\n\", LIB_NAME(lib));\n         continue;\n      }\n      result = -1;\n      if (gnu_hash) {\n         debug_printf(3, \"Checking GNU hash for %s in %s\\n\",\n                      user_binding->name, LIB_NAME(lib));\n         result = lookup_gnu_hash_symbol(user_binding->name, symtab, strtab,\n                                         (struct gnu_hash_header *) gnu_hash);\n      }\n      if (elf_hash && result == -1) {\n         debug_printf(3, \"Checking ELF hash for %s in %s\\n\",\n                      user_binding->name, LIB_NAME(lib));\n         result = lookup_elf_hash_symbol(user_binding->name, symtab, strtab,\n                                         (ElfW(Word) *)elf_hash);\n      }\n      if (result == -1) {\n         debug_printf(3, \"%s not found in %s\\n\",\n                      user_binding->name, LIB_NAME(lib));\n         continue;\n      }\n      if (! GOTCHA_CHECK_VISIBILITY(symtab[result])) {\n         debug_printf(3, \"Symbol %s found but not exported in %s\\n\", \n                      user_binding->name, LIB_NAME(lib));\n         continue;\n      }\n\n      debug_printf(2, \"Symbol %s found in %s at 0x%lx\\n\", \n                   user_binding->name, LIB_NAME(lib),\n                   symtab[result].st_value + lib->l_addr);\n      setInternalBindingAddressPointer(user_binding->function_handle,(void *)(symtab[result].st_value + lib->l_addr));\n      return 0;\n   }\n   debug_printf(1, \"Symbol %s was found in program\\n\", user_binding->name);\n   return -1;\n}\n\nstatic void insert_at_head(struct internal_binding_t *binding, struct internal_binding_t *head)\n{\n   binding->next_binding = head;\n   setInternalBindingAddressPointer(binding->user_binding->function_handle, head->user_binding->wrapper_pointer);\n   removefrom_hashtable(&function_hash_table, (void*) binding->user_binding->name);\n   addto_hashtable(&function_hash_table, (void*)binding->user_binding->name, (void*)binding);\n}\n\nstatic void insert_after_pos(struct internal_binding_t *binding, struct internal_binding_t *pos)\n{\n   setInternalBindingAddressPointer(binding->user_binding->function_handle, pos->wrappee_pointer);\n   setInternalBindingAddressPointer(pos->user_binding->function_handle, binding->user_binding->wrapper_pointer);\n   binding->next_binding = pos->next_binding;\n   pos->next_binding = binding;\n}\n\n#define RWO_NOCHANGE 0\n#define RWO_NEED_LOOKUP (1 << 0)\n#define RWO_NEED_BINDING (1 << 1)\nstatic int rewrite_wrapper_orders(struct internal_binding_t* binding)\n{\n  const char* name = binding->user_binding->name;\n  int insert_priority = get_priority(binding->associated_binding_table->tool);\n  \n  if(gotcha_strcmp(name,\"main\")==0){\n    if(!main_wrapped){\n      debug_printf(2, \"Wrapping main with Gotcha's internal wrappers\");\n      main_wrapped = 1;\n      gotcha_wrap(libc_main_wrappers,1,\"gotcha\");\n      gotcha_wrap(main_wrappers,1,\"gotcha\");\n    }\n  }\n\n  debug_printf(2, \"gotcha_rewrite_wrapper_orders for binding %s in tool %s of priority %d\\n\",\n               name, binding->associated_binding_table->tool->tool_name, insert_priority);\n\n  struct internal_binding_t* head;\n  int hash_result;\n  hash_result = lookup_hashtable(&function_hash_table, (void*)name, (void**)&head);\n  if(hash_result != 0) {\n    debug_printf(2, \"Adding new entry for %s to hash table\\n\", name);\n    addto_hashtable(&function_hash_table, (void *) name, (void *) binding);\n    return (RWO_NEED_LOOKUP | RWO_NEED_BINDING);\n  }\n\n  int head_priority = get_priority(head->associated_binding_table->tool);\n    if (head_priority < insert_priority) {\n     debug_printf(2, \"New binding priority %d is greater than head priority %d, adding to head\\n\",\n                   insert_priority, head_priority);\n     insert_at_head(binding, head);\n     return RWO_NEED_BINDING;\n  }\n\n  struct internal_binding_t* cur;\n  for (cur = head; cur->next_binding; cur = cur->next_binding) {\n     int next_priority = get_priority(cur->next_binding->associated_binding_table->tool);\n     debug_printf(3, \"Comparing binding for new insertion %d to binding for tool %s at %d\\n\",\n                   insert_priority, cur->next_binding->associated_binding_table->tool->tool_name,\n                   next_priority);\n     if (next_priority < insert_priority) {\n        break;\n     }\n     if (cur->user_binding->wrapper_pointer == binding->user_binding->wrapper_pointer) {\n        debug_printf(3, \"Tool is already inserted.  Skipping binding rewrite\\n\");\n        return RWO_NOCHANGE;\n     }\n  }\n  debug_printf(2, \"Inserting binding after tool %s\\n\", cur->associated_binding_table->tool->tool_name);\n  insert_after_pos(binding, cur);\n  return RWO_NOCHANGE;\n}\n\nstatic int update_lib_bindings(ElfW(Sym) * symbol KNOWN_UNUSED, char *name, ElfW(Addr) offset,\n                               struct link_map *lmap, hash_table_t *lookuptable)\n{\n  int result;\n  struct internal_binding_t *internal_binding;\n  void **got_address;\n\n  result = lookup_hashtable(lookuptable, name, (void **) &internal_binding);\n  if (result != 0)\n     return 0;\n  got_address = (void**) (lmap->l_addr + offset);\n  writeAddress(got_address, internal_binding->user_binding->wrapper_pointer);\n  debug_printf(3, \"Remapped call to %s at 0x%lx in %s to wrapper at 0x%p\\n\",\n             name, (lmap->l_addr + offset), LIB_NAME(lmap),\n             internal_binding->user_binding->wrapper_pointer);\n  return 0;\n}\n\n#ifndef MAX\n#define MAX(a,b) (a>b?a:b)\n#endif\n\nstatic int mark_got_writable(struct link_map *lib)\n{\n   static unsigned int page_size = 0;\n   INIT_DYNAMIC(lib);\n   if (!got)\n      return 0;\n\n   if (!page_size)\n      page_size = gotcha_getpagesize();\n\n   size_t protect_size = MAX(rel_size, page_size);\n   if(protect_size % page_size){\n      protect_size += page_size -  ((protect_size) %page_size);\n   }\n   ElfW(Addr) prot_address = BOUNDARY_BEFORE(got,(ElfW(Addr))page_size);\n   debug_printf(3, \"Setting library %s GOT table from %p to +%lu to writeable\\n\",\n                LIB_NAME(lib), (void *) prot_address, protect_size);\n   int res = gotcha_mprotect((void*)prot_address,protect_size,PROT_READ | PROT_WRITE | PROT_EXEC );\n   if(res == -1){ // mprotect returns -1 on an error\n      error_printf(\"GOTCHA attempted to mark the GOT table as writable and was unable to do so, \"\n                   \"calls to wrapped functions may likely fail.\\n\");\n   }\n\n   return 0;\n}\n\nstatic int update_library_got(struct link_map *map, hash_table_t *bindingtable)\n{\n   struct library_t *lib = get_library(map);\n   if (!lib) {\n      debug_printf(3, \"Creating new library object for %s\\n\", LIB_NAME(map));\n      lib = add_library(map);\n   }\n\n   if (!libraryFilterFunc(map)) {\n      debug_printf(3, \"Skipping library %s due to libraryFilterFunc\\n\", LIB_NAME(map));\n      return 0;\n   }\n\n   if (lib->generation == current_generation) {\n      debug_printf(2, \"Library %s is already up-to-date.  Skipping GOT rewriting\\n\", LIB_NAME(map));\n      return 0;\n   }\n   \n   if (!(lib->flags & LIB_GOT_MARKED_WRITEABLE)) {\n      mark_got_writable(map);\n      lib->flags |= LIB_GOT_MARKED_WRITEABLE;\n   }\n\n   FOR_EACH_PLTREL(map, update_lib_bindings, map, bindingtable);\n\n   lib->generation = current_generation;\n   return 0;\n}\n\nvoid update_all_library_gots(hash_table_t *bindings)\n{\n   struct link_map *lib_iter;\n   debug_printf(2, \"Searching all callsites for %lu bindings\\n\", (unsigned long) bindings->entry_count);\n   for (lib_iter = _r_debug.r_map; lib_iter != 0; lib_iter = lib_iter->l_next) {\n      update_library_got(lib_iter, bindings);\n   }   \n}\n\nGOTCHA_EXPORT enum gotcha_error_t gotcha_wrap(struct gotcha_binding_t* user_bindings, int num_actions, const char* tool_name)\n{\n  int i, not_found = 0, new_bindings_count = 0;\n  tool_t *tool;\n  hash_table_t new_bindings;\n\n  gotcha_init();\n\n  debug_printf(1, \"User called gotcha_wrap for tool %s with %d bindings\\n\",\n               tool_name, num_actions);\n  if (debug_level >= 3) {\n    for (i = 0; i < num_actions; i++) {\n       debug_bare_printf(3, \"\\t%d: %s will map to %p\\n\", i, user_bindings[i].name,\n                         user_bindings[i].wrapper_pointer);\n    }\n  }\n  debug_printf(3, \"Initializing %d user binding entries to NULL\\n\", num_actions);\n  for (i = 0; i < num_actions; i++) {\n    setBindingAddressPointer(&user_bindings[i], NULL);\n  }\n\n  if (!tool_name)\n     tool_name = \"[UNSPECIFIED]\";\n  tool = get_tool(tool_name);\n  if (!tool)\n     tool = create_tool(tool_name);\n  if (!tool) {\n     error_printf(\"Failed to create tool %s\\n\", tool_name);\n     return GOTCHA_INTERNAL;\n  }\n\n  current_generation++;\n  debug_printf(2, \"Moved current_generation to %u in gotcha_wrap\\n\", current_generation);\n\n  debug_printf(2, \"Creating internal binding data structures and adding binding to tool\\n\");\n  binding_t *bindings = add_binding_to_tool(tool, user_bindings, num_actions);\n  if (!bindings) {\n     error_printf(\"Failed to create bindings for tool %s\\n\", tool_name);\n     return GOTCHA_INTERNAL;\n  }\n\n  debug_printf(2, \"Processing %d bindings\\n\", num_actions);\n  for (i = 0; i < num_actions; i++) {\n     struct internal_binding_t *binding = bindings->internal_bindings + i;\n\n     int result = rewrite_wrapper_orders(binding);\n     if (result & RWO_NEED_LOOKUP) {\n        debug_printf(2, \"Symbol %s needs lookup operation\\n\", binding->user_binding->name);\n        int presult = prepare_symbol(binding);\n        if (presult == -1) {\n           debug_printf(2, \"Stashing %s in notfound_binding table to re-lookup on dlopens\\n\",\n                        binding->user_binding->name);\n           addto_hashtable(&notfound_binding_table, (hash_key_t) binding->user_binding->name, (hash_data_t) binding);\n           not_found++;\n        }\n     }\n     if (result & RWO_NEED_BINDING) {\n        debug_printf(2, \"Symbol %s needs binding from application\\n\", binding->user_binding->name);\n        if (!new_bindings_count) {\n           create_hashtable(&new_bindings, num_actions*2, (hash_func_t) strhash, (hash_cmp_t) gotcha_strcmp);\n        }\n        addto_hashtable(&new_bindings, (void *) binding->user_binding->name, (void *) binding);\n        new_bindings_count++;\n     }\n  }\n  \n  if (new_bindings_count) {\n     update_all_library_gots(&new_bindings);\n     destroy_hashtable(&new_bindings);\n  }\n\n  if (not_found) {\n     debug_printf(1, \"Could not find bindings for %d / %d functions\\n\", not_found, num_actions);\n     return GOTCHA_FUNCTION_NOT_FOUND;\n  }\n  debug_printf(1, \"Gotcha wrap completed successfully\\n\");\n  return GOTCHA_SUCCESS;\n}\n\nstatic enum gotcha_error_t gotcha_configure_int(const char* tool_name, enum gotcha_config_key_t configuration_key , int value){\n  tool_t * tool = get_tool(tool_name);\n  if(tool==NULL){\n    tool = create_tool(tool_name);\n  }\n  if( configuration_key == GOTCHA_PRIORITY){\n    tool->config.priority = value;\n  }\n  else{\n    error_printf(\"Invalid property being configured on tool %s\\n\", tool_name);\n    return GOTCHA_INTERNAL;\n  }\n  return GOTCHA_SUCCESS;\n}\n\nGOTCHA_EXPORT enum gotcha_error_t gotcha_set_priority(const char* tool_name, int value){\n  gotcha_init();\n  debug_printf(1, \"User called gotcha_set_priority(%s, %d)\\n\", tool_name, value);\n  enum gotcha_error_t error_on_set = gotcha_configure_int(tool_name, GOTCHA_PRIORITY, value);\n  if(error_on_set != GOTCHA_SUCCESS) {\n    return error_on_set;\n  }\n  tool_t* tool_to_place = get_tool(tool_name);\n  if(!tool_to_place){\n     tool_to_place = create_tool(tool_name);\n  }\n  remove_tool_from_list(tool_to_place);\n  reorder_tool(tool_to_place);\n  return GOTCHA_SUCCESS;\n}\n\nGOTCHA_EXPORT enum gotcha_error_t gotcha_get_priority(const char* tool_name, int *priority){\n  gotcha_init();\n  return get_configuration_value(tool_name, GOTCHA_PRIORITY, priority);\n}\n\nGOTCHA_EXPORT void* gotcha_get_wrappee(gotcha_wrappee_handle_t handle){\n  return ((struct internal_binding_t*)handle)->wrappee_pointer;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.0-wsmvcyg57s3cluiv7iuyeyprx4ea4ctz/spack-src/ext/hwloc/include/hwloc/plugins.h": "/*\n * Copyright \u00a9 2013-2019 Inria.  All rights reserved.\n * Copyright \u00a9 2016 Cisco Systems, Inc.  All rights reserved.\n * See COPYING in top-level directory.\n */\n\n#ifndef HWLOC_PLUGINS_H\n#define HWLOC_PLUGINS_H\n\n/** \\file\n * \\brief Public interface for building hwloc plugins.\n */\n\nstruct hwloc_backend;\n\n#include \"hwloc.h\"\n\n#ifdef HWLOC_INSIDE_PLUGIN\n/* needed for hwloc_plugin_check_namespace() */\n#include <ltdl.h>\n#endif\n\n\n\n/** \\defgroup hwlocality_disc_components Components and Plugins: Discovery components\n * @{\n */\n\n/** \\brief Discovery component structure\n *\n * This is the major kind of components, taking care of the discovery.\n * They are registered by generic components, either statically-built or as plugins.\n */\nstruct hwloc_disc_component {\n  /** \\brief Name.\n   * If this component is built as a plugin, this name does not have to match the plugin filename.\n   */\n  const char *name;\n\n  /** \\brief Discovery phases performed by this component.\n   * OR'ed set of ::hwloc_disc_phase_t\n   */\n  unsigned phases;\n\n  /** \\brief Component phases to exclude, as an OR'ed set of ::hwloc_disc_phase_t.\n   *\n   * For a GLOBAL component, this usually includes all other phases (\\c ~UL).\n   *\n   * Other components only exclude types that may bring conflicting\n   * topology information. MISC components should likely not be excluded\n   * since they usually bring non-primary additional information.\n   */\n  unsigned excluded_phases;\n\n  /** \\brief Instantiate callback to create a backend from the component.\n   * Parameters data1, data2, data3 are NULL except for components\n   * that have special enabling routines such as hwloc_topology_set_xml(). */\n  struct hwloc_backend * (*instantiate)(struct hwloc_topology *topology, struct hwloc_disc_component *component, unsigned excluded_phases, const void *data1, const void *data2, const void *data3);\n\n  /** \\brief Component priority.\n   * Used to sort topology->components, higher priority first.\n   * Also used to decide between two components with the same name.\n   *\n   * Usual values are\n   * 50 for native OS (or platform) components,\n   * 45 for x86,\n   * 40 for no-OS fallback,\n   * 30 for global components (xml, synthetic),\n   * 20 for pci,\n   * 10 for other misc components (opencl etc.).\n   */\n  unsigned priority;\n\n  /** \\brief Enabled by default.\n   * If unset, if will be disabled unless explicitly requested.\n   */\n  unsigned enabled_by_default;\n\n  /** \\private Used internally to list components by priority on topology->components\n   * (the component structure is usually read-only,\n   *  the core copies it before using this field for queueing)\n   */\n  struct hwloc_disc_component * next;\n};\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_disc_backends Components and Plugins: Discovery backends\n * @{\n */\n\n/** \\brief Discovery phase */\ntypedef enum hwloc_disc_phase_e {\n  /** \\brief xml or synthetic, platform-specific components such as bgq.\n   * Discovers everything including CPU, memory, I/O and everything else.\n   * A component with a Global phase usually excludes all other phases.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_GLOBAL = (1U<<0),\n\n  /** \\brief CPU discovery.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_CPU = (1U<<1),\n\n  /** \\brief Attach memory to existing CPU objects.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_MEMORY = (1U<<2),\n\n  /** \\brief Attach PCI devices and bridges to existing CPU objects.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_PCI = (1U<<3),\n\n  /** \\brief I/O discovery that requires PCI devices (OS devices such as OpenCL, CUDA, etc.).\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_IO = (1U<<4),\n\n  /** \\brief Misc objects that gets added below anything else.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_MISC = (1U<<5),\n\n  /** \\brief Annotating existing objects, adding distances, etc.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_ANNOTATE = (1U<<6),\n\n  /** \\brief Final tweaks to a ready-to-use topology.\n   * This phase runs once the topology is loaded, before it is returned to the topology.\n   * Hence it may only use the main hwloc API for modifying the topology,\n   * for instance by restricting it, adding info attributes, etc.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_TWEAK = (1U<<7)\n} hwloc_disc_phase_t;\n\n/** \\brief Discovery status flags */\nenum hwloc_disc_status_flag_e {\n  /** \\brief The sets of allowed resources were already retrieved \\hideinitializer */\n  HWLOC_DISC_STATUS_FLAG_GOT_ALLOWED_RESOURCES = (1UL<<1)\n};\n\n/** \\brief Discovery status structure\n *\n * Used by the core and backends to inform about what has been/is being done\n * during the discovery process.\n */\nstruct hwloc_disc_status {\n  /** \\brief The current discovery phase that is performed.\n   * Must match one of the phases in the component phases field.\n   */\n  hwloc_disc_phase_t phase;\n\n  /** \\brief Dynamically excluded phases.\n   * If a component decides during discovery that some phases are no longer needed.\n   */\n  unsigned excluded_phases;\n\n  /** \\brief OR'ed set of hwloc_disc_status_flag_e */\n  unsigned long flags;\n};\n\n/** \\brief Discovery backend structure\n *\n * A backend is the instantiation of a discovery component.\n * When a component gets enabled for a topology,\n * its instantiate() callback creates a backend.\n *\n * hwloc_backend_alloc() initializes all fields to default values\n * that the component may change (except \"component\" and \"next\")\n * before enabling the backend with hwloc_backend_enable().\n *\n * Most backends assume that the topology is_thissystem flag is\n * set because they talk to the underlying operating system.\n * However they may still be used in topologies without the\n * is_thissystem flag for debugging reasons.\n * In practice, they are usually auto-disabled in such cases\n * (excluded by xml or synthetic backends, or by environment\n *  variables when changing the Linux fsroot or the x86 cpuid path).\n */\nstruct hwloc_backend {\n  /** \\private Reserved for the core, set by hwloc_backend_alloc() */\n  struct hwloc_disc_component * component;\n  /** \\private Reserved for the core, set by hwloc_backend_enable() */\n  struct hwloc_topology * topology;\n  /** \\private Reserved for the core. Set to 1 if forced through envvar, 0 otherwise. */\n  int envvar_forced;\n  /** \\private Reserved for the core. Used internally to list backends topology->backends. */\n  struct hwloc_backend * next;\n\n  /** \\brief Discovery phases performed by this component, possibly without some of them if excluded by other components.\n   * OR'ed set of ::hwloc_disc_phase_t\n   */\n  unsigned phases;\n\n  /** \\brief Backend flags, currently always 0. */\n  unsigned long flags;\n\n  /** \\brief Backend-specific 'is_thissystem' property.\n   * Set to 0 if the backend disables the thissystem flag for this topology\n   * (e.g. loading from xml or synthetic string,\n   *  or using a different fsroot on Linux, or a x86 CPUID dump).\n   * Set to -1 if the backend doesn't care (default).\n   */\n  int is_thissystem;\n\n  /** \\brief Backend private data, or NULL if none. */\n  void * private_data;\n  /** \\brief Callback for freeing the private_data.\n   * May be NULL.\n   */\n  void (*disable)(struct hwloc_backend *backend);\n\n  /** \\brief Main discovery callback.\n   * returns -1 on error, either because it couldn't add its objects ot the existing topology,\n   * or because of an actual discovery/gathering failure.\n   * May be NULL.\n   */\n  int (*discover)(struct hwloc_backend *backend, struct hwloc_disc_status *status);\n\n  /** \\brief Callback to retrieve the locality of a PCI object.\n   * Called by the PCI core when attaching PCI hierarchy to CPU objects.\n   * May be NULL.\n   */\n  int (*get_pci_busid_cpuset)(struct hwloc_backend *backend, struct hwloc_pcidev_attr_s *busid, hwloc_bitmap_t cpuset);\n};\n\n/** \\brief Allocate a backend structure, set good default values, initialize backend->component and topology, etc.\n * The caller will then modify whatever needed, and call hwloc_backend_enable().\n */\nHWLOC_DECLSPEC struct hwloc_backend * hwloc_backend_alloc(struct hwloc_topology *topology, struct hwloc_disc_component *component);\n\n/** \\brief Enable a previously allocated and setup backend. */\nHWLOC_DECLSPEC int hwloc_backend_enable(struct hwloc_backend *backend);\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_generic_components Components and Plugins: Generic components\n * @{\n */\n\n/** \\brief Generic component type */\ntypedef enum hwloc_component_type_e {\n  /** \\brief The data field must point to a struct hwloc_disc_component. */\n  HWLOC_COMPONENT_TYPE_DISC,\n\n  /** \\brief The data field must point to a struct hwloc_xml_component. */\n  HWLOC_COMPONENT_TYPE_XML\n} hwloc_component_type_t;\n\n/** \\brief Generic component structure\n *\n * Generic components structure, either statically listed by configure in static-components.h\n * or dynamically loaded as a plugin.\n */\nstruct hwloc_component {\n  /** \\brief Component ABI version, set to ::HWLOC_COMPONENT_ABI */\n  unsigned abi;\n\n  /** \\brief Process-wide component initialization callback.\n   *\n   * This optional callback is called when the component is registered\n   * to the hwloc core (after loading the plugin).\n   *\n   * When the component is built as a plugin, this callback\n   * should call hwloc_check_plugin_namespace()\n   * and return an negative error code on error.\n   *\n   * \\p flags is always 0 for now.\n   *\n   * \\return 0 on success, or a negative code on error.\n   *\n   * \\note If the component uses ltdl for loading its own plugins,\n   * it should load/unload them only in init() and finalize(),\n   * to avoid race conditions with hwloc's use of ltdl.\n   */\n  int (*init)(unsigned long flags);\n\n  /** \\brief Process-wide component termination callback.\n   *\n   * This optional callback is called after unregistering the component\n   * from the hwloc core (before unloading the plugin).\n   *\n   * \\p flags is always 0 for now.\n   *\n   * \\note If the component uses ltdl for loading its own plugins,\n   * it should load/unload them only in init() and finalize(),\n   * to avoid race conditions with hwloc's use of ltdl.\n   */\n  void (*finalize)(unsigned long flags);\n\n  /** \\brief Component type */\n  hwloc_component_type_t type;\n\n  /** \\brief Component flags, unused for now */\n  unsigned long flags;\n\n  /** \\brief Component data, pointing to a struct hwloc_disc_component or struct hwloc_xml_component. */\n  void * data;\n};\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_components_core_funcs Components and Plugins: Core functions to be used by components\n * @{\n */\n\n/** \\brief Add an object to the topology.\n *\n * It is sorted along the tree of other objects according to the inclusion of\n * cpusets, to eventually be added as a child of the smallest object including\n * this object.\n *\n * If the cpuset is empty, the type of the object (and maybe some attributes)\n * must be enough to find where to insert the object. This is especially true\n * for NUMA nodes with memory and no CPUs.\n *\n * The given object should not have children.\n *\n * This shall only be called before levels are built.\n *\n * In case of error, hwloc_report_os_error() is called.\n *\n * The caller should check whether the object type is filtered-out before calling this function.\n *\n * The topology cpuset/nodesets will be enlarged to include the object sets.\n *\n * Returns the object on success.\n * Returns NULL and frees obj on error.\n * Returns another object and frees obj if it was merged with an identical pre-existing object.\n */\nHWLOC_DECLSPEC struct hwloc_obj *hwloc_insert_object_by_cpuset(struct hwloc_topology *topology, hwloc_obj_t obj);\n\n/** \\brief Type of error callbacks during object insertion */\ntypedef void (*hwloc_report_error_t)(const char * msg, int line);\n/** \\brief Report an insertion error from a backend */\nHWLOC_DECLSPEC void hwloc_report_os_error(const char * msg, int line);\n/** \\brief Check whether insertion errors are hidden */\nHWLOC_DECLSPEC int hwloc_hide_errors(void);\n\n/** \\brief Add an object to the topology and specify which error callback to use.\n *\n * This function is similar to hwloc_insert_object_by_cpuset() but it allows specifying\n * where to start insertion from (if \\p root is NULL, the topology root object is used),\n * and specifying the error callback.\n */\nHWLOC_DECLSPEC struct hwloc_obj *hwloc__insert_object_by_cpuset(struct hwloc_topology *topology, hwloc_obj_t root, hwloc_obj_t obj, hwloc_report_error_t report_error);\n\n/** \\brief Insert an object somewhere in the topology.\n *\n * It is added as the last child of the given parent.\n * The cpuset is completely ignored, so strange objects such as I/O devices should\n * preferably be inserted with this.\n *\n * When used for \"normal\" children with cpusets (when importing from XML\n * when duplicating a topology), the caller should make sure that:\n * - children are inserted in order,\n * - children cpusets do not intersect.\n *\n * The given object may have normal, I/O or Misc children, as long as they are in order as well.\n * These children must have valid parent and next_sibling pointers.\n *\n * The caller should check whether the object type is filtered-out before calling this function.\n */\nHWLOC_DECLSPEC void hwloc_insert_object_by_parent(struct hwloc_topology *topology, hwloc_obj_t parent, hwloc_obj_t obj);\n\n/** \\brief Allocate and initialize an object of the given type and physical index.\n *\n * If \\p os_index is unknown or irrelevant, use \\c HWLOC_UNKNOWN_INDEX.\n */\nHWLOC_DECLSPEC hwloc_obj_t hwloc_alloc_setup_object(hwloc_topology_t topology, hwloc_obj_type_t type, unsigned os_index);\n\n/** \\brief Setup object cpusets/nodesets by OR'ing its children.\n *\n * Used when adding an object late in the topology.\n * Will update the new object by OR'ing all its new children sets.\n *\n * Used when PCI backend adds a hostbridge parent, when distances\n * add a new Group, etc.\n */\nHWLOC_DECLSPEC int hwloc_obj_add_children_sets(hwloc_obj_t obj);\n\n/** \\brief Request a reconnection of children and levels in the topology.\n *\n * May be used by backends during discovery if they need arrays or lists\n * of object within levels or children to be fully connected.\n *\n * \\p flags is currently unused, must 0.\n */\nHWLOC_DECLSPEC int hwloc_topology_reconnect(hwloc_topology_t topology, unsigned long flags __hwloc_attribute_unused);\n\n/** \\brief Make sure that plugins can lookup core symbols.\n *\n * This is a sanity check to avoid lazy-lookup failures when libhwloc\n * is loaded within a plugin, and later tries to load its own plugins.\n * This may fail (and abort the program) if libhwloc symbols are in a\n * private namespace.\n *\n * \\return 0 on success.\n * \\return -1 if the plugin cannot be successfully loaded. The caller\n * plugin init() callback should return a negative error code as well.\n *\n * Plugins should call this function in their init() callback to avoid\n * later crashes if lazy symbol resolution is used by the upper layer that\n * loaded hwloc (e.g. OpenCL implementations using dlopen with RTLD_LAZY).\n *\n * \\note The build system must define HWLOC_INSIDE_PLUGIN if and only if\n * building the caller as a plugin.\n *\n * \\note This function should remain inline so plugins can call it even\n * when they cannot find libhwloc symbols.\n */\nstatic __hwloc_inline int\nhwloc_plugin_check_namespace(const char *pluginname __hwloc_attribute_unused, const char *symbol __hwloc_attribute_unused)\n{\n#ifdef HWLOC_INSIDE_PLUGIN\n  lt_dlhandle handle;\n  void *sym;\n  handle = lt_dlopen(NULL);\n  if (!handle)\n    /* cannot check, assume things will work */\n    return 0;\n  sym = lt_dlsym(handle, symbol);\n  lt_dlclose(handle);\n  if (!sym) {\n    static int verboseenv_checked = 0;\n    static int verboseenv_value = 0;\n    if (!verboseenv_checked) {\n      const char *verboseenv = getenv(\"HWLOC_PLUGINS_VERBOSE\");\n      verboseenv_value = verboseenv ? atoi(verboseenv) : 0;\n      verboseenv_checked = 1;\n    }\n    if (verboseenv_value)\n      fprintf(stderr, \"Plugin `%s' disabling itself because it cannot find the `%s' core symbol.\\n\",\n\t      pluginname, symbol);\n    return -1;\n  }\n#endif /* HWLOC_INSIDE_PLUGIN */\n  return 0;\n}\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_components_filtering Components and Plugins: Filtering objects\n * @{\n */\n\n/** \\brief Check whether the given PCI device classid is important.\n *\n * \\return 1 if important, 0 otherwise.\n */\nstatic __hwloc_inline int\nhwloc_filter_check_pcidev_subtype_important(unsigned classid)\n{\n  unsigned baseclass = classid >> 8;\n  return (baseclass == 0x03 /* PCI_BASE_CLASS_DISPLAY */\n\t  || baseclass == 0x02 /* PCI_BASE_CLASS_NETWORK */\n\t  || baseclass == 0x01 /* PCI_BASE_CLASS_STORAGE */\n\t  || baseclass == 0x0b /* PCI_BASE_CLASS_PROCESSOR */\n\t  || classid == 0x0c04 /* PCI_CLASS_SERIAL_FIBER */\n\t  || classid == 0x0c06 /* PCI_CLASS_SERIAL_INFINIBAND */\n\t  || baseclass == 0x12 /* Processing Accelerators */);\n}\n\n/** \\brief Check whether the given OS device subtype is important.\n *\n * \\return 1 if important, 0 otherwise.\n */\nstatic __hwloc_inline int\nhwloc_filter_check_osdev_subtype_important(hwloc_obj_osdev_type_t subtype)\n{\n  return (subtype != HWLOC_OBJ_OSDEV_DMA);\n}\n\n/** \\brief Check whether a non-I/O object type should be filtered-out.\n *\n * Cannot be used for I/O objects.\n *\n * \\return 1 if the object type should be kept, 0 otherwise.\n */\nstatic __hwloc_inline int\nhwloc_filter_check_keep_object_type(hwloc_topology_t topology, hwloc_obj_type_t type)\n{\n  enum hwloc_type_filter_e filter = HWLOC_TYPE_FILTER_KEEP_NONE;\n  hwloc_topology_get_type_filter(topology, type, &filter);\n  assert(filter != HWLOC_TYPE_FILTER_KEEP_IMPORTANT); /* IMPORTANT only used for I/O */\n  return filter == HWLOC_TYPE_FILTER_KEEP_NONE ? 0 : 1;\n}\n\n/** \\brief Check whether the given object should be filtered-out.\n *\n * \\return 1 if the object type should be kept, 0 otherwise.\n */\nstatic __hwloc_inline int\nhwloc_filter_check_keep_object(hwloc_topology_t topology, hwloc_obj_t obj)\n{\n  hwloc_obj_type_t type = obj->type;\n  enum hwloc_type_filter_e filter = HWLOC_TYPE_FILTER_KEEP_NONE;\n  hwloc_topology_get_type_filter(topology, type, &filter);\n  if (filter == HWLOC_TYPE_FILTER_KEEP_NONE)\n    return 0;\n  if (filter == HWLOC_TYPE_FILTER_KEEP_IMPORTANT) {\n    if (type == HWLOC_OBJ_PCI_DEVICE)\n      return hwloc_filter_check_pcidev_subtype_important(obj->attr->pcidev.class_id);\n    if (type == HWLOC_OBJ_OS_DEVICE)\n      return hwloc_filter_check_osdev_subtype_important(obj->attr->osdev.type);\n  }\n  return 1;\n}\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_components_pcidisc Components and Plugins: helpers for PCI discovery\n * @{\n */\n\n/** \\brief Return the offset of the given capability in the PCI config space buffer\n *\n * This function requires a 256-bytes config space. Unknown/unavailable bytes should be set to 0xff.\n */\nHWLOC_DECLSPEC unsigned hwloc_pcidisc_find_cap(const unsigned char *config, unsigned cap);\n\n/** \\brief Fill linkspeed by reading the PCI config space where PCI_CAP_ID_EXP is at position offset.\n *\n * Needs 20 bytes of EXP capability block starting at offset in the config space\n * for registers up to link status.\n */\nHWLOC_DECLSPEC int hwloc_pcidisc_find_linkspeed(const unsigned char *config, unsigned offset, float *linkspeed);\n\n/** \\brief Return the hwloc object type (PCI device or Bridge) for the given class and configuration space.\n *\n * This function requires 16 bytes of common configuration header at the beginning of config.\n */\nHWLOC_DECLSPEC hwloc_obj_type_t hwloc_pcidisc_check_bridge_type(unsigned device_class, const unsigned char *config);\n\n/** \\brief Fills the attributes of the given PCI bridge using the given PCI config space.\n *\n * This function requires 32 bytes of common configuration header at the beginning of config.\n *\n * Returns -1 and destroys /p obj if bridge fields are invalid.\n */\nHWLOC_DECLSPEC int hwloc_pcidisc_find_bridge_buses(unsigned domain, unsigned bus, unsigned dev, unsigned func,\n\t\t\t\t\t\t   unsigned *secondary_busp, unsigned *subordinate_busp,\n\t\t\t\t\t\t   const unsigned char *config);\n\n/** \\brief Insert a PCI object in the given PCI tree by looking at PCI bus IDs.\n *\n * If \\p treep points to \\c NULL, the new object is inserted there.\n */\nHWLOC_DECLSPEC void hwloc_pcidisc_tree_insert_by_busid(struct hwloc_obj **treep, struct hwloc_obj *obj);\n\n/** \\brief Add some hostbridges on top of the given tree of PCI objects and attach them to the topology.\n *\n * Other backends may lookup PCI objects or localities (for instance to attach OS devices)\n * by using hwloc_pcidisc_find_by_busid() or hwloc_pcidisc_find_busid_parent().\n */\nHWLOC_DECLSPEC int hwloc_pcidisc_tree_attach(struct hwloc_topology *topology, struct hwloc_obj *tree);\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_components_pcifind Components and Plugins: finding PCI objects during other discoveries\n * @{\n */\n\n/** \\brief Find the normal parent of a PCI bus ID.\n *\n * Look at PCI affinity to find out where the given PCI bus ID should be attached.\n *\n * This function should be used to attach an I/O device under the corresponding\n * PCI object (if any), or under a normal (non-I/O) object with same locality.\n */\nHWLOC_DECLSPEC struct hwloc_obj * hwloc_pci_find_parent_by_busid(struct hwloc_topology *topology, unsigned domain, unsigned bus, unsigned dev, unsigned func);\n\n/** @} */\n\n\n\n\n#endif /* HWLOC_PLUGINS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.0-wsmvcyg57s3cluiv7iuyeyprx4ea4ctz/spack-src/ext/hwloc/hwloc/components.c": "/*\n * Copyright \u00a9 2009-2019 Inria.  All rights reserved.\n * Copyright \u00a9 2012 Universit\u00e9 Bordeaux\n * See COPYING in top-level directory.\n */\n\n#include \"private/autogen/config.h\"\n#include \"hwloc.h\"\n#include \"private/private.h\"\n#include \"private/xml.h\"\n#include \"private/misc.h\"\n\n#define HWLOC_COMPONENT_STOP_NAME \"stop\"\n#define HWLOC_COMPONENT_EXCLUDE_CHAR '-'\n#define HWLOC_COMPONENT_SEPS \",\"\n#define HWLOC_COMPONENT_PHASESEP_CHAR ':'\n\n/* list of all registered discovery components, sorted by priority, higher priority first.\n * noos is last because its priority is 0.\n * others' priority is 10.\n */\nstatic struct hwloc_disc_component * hwloc_disc_components = NULL;\n\nstatic unsigned hwloc_components_users = 0; /* first one initializes, last ones destroys */\n\nstatic int hwloc_components_verbose = 0;\n#ifdef HWLOC_HAVE_PLUGINS\nstatic int hwloc_plugins_verbose = 0;\nstatic const char * hwloc_plugins_blacklist = NULL;\n#endif\n\n/* hwloc_components_mutex serializes:\n * - loading/unloading plugins, and modifications of the hwloc_plugins list\n * - calls to ltdl, including in hwloc_check_plugin_namespace()\n * - registration of components with hwloc_disc_component_register()\n *   and hwloc_xml_callbacks_register()\n */\n#ifdef HWLOC_WIN_SYS\n/* Basic mutex on top of InterlockedCompareExchange() on windows,\n * Far from perfect, but easy to maintain, and way enough given that this code will never be needed for real. */\n#include <windows.h>\nstatic LONG hwloc_components_mutex = 0;\n#define HWLOC_COMPONENTS_LOCK() do {\t\t\t\t\t\t\\\n  while (InterlockedCompareExchange(&hwloc_components_mutex, 1, 0) != 0)\t\\\n    SwitchToThread();\t\t\t\t\t\t\t\t\\\n} while (0)\n#define HWLOC_COMPONENTS_UNLOCK() do {\t\t\t\t\t\t\\\n  assert(hwloc_components_mutex == 1);\t\t\t\t\t\t\\\n  hwloc_components_mutex = 0;\t\t\t\t\t\t\t\\\n} while (0)\n\n#elif defined HWLOC_HAVE_PTHREAD_MUTEX\n/* pthread mutex if available (except on windows) */\n#include <pthread.h>\nstatic pthread_mutex_t hwloc_components_mutex = PTHREAD_MUTEX_INITIALIZER;\n#define HWLOC_COMPONENTS_LOCK() pthread_mutex_lock(&hwloc_components_mutex)\n#define HWLOC_COMPONENTS_UNLOCK() pthread_mutex_unlock(&hwloc_components_mutex)\n\n#else /* HWLOC_WIN_SYS || HWLOC_HAVE_PTHREAD_MUTEX */\n#error No mutex implementation available\n#endif\n\n\n#ifdef HWLOC_HAVE_PLUGINS\n\n#include <ltdl.h>\n\n/* array of pointers to dynamically loaded plugins */\nstatic struct hwloc__plugin_desc {\n  char *name;\n  struct hwloc_component *component;\n  char *filename;\n  lt_dlhandle handle;\n  struct hwloc__plugin_desc *next;\n} *hwloc_plugins = NULL;\n\nstatic int\nhwloc__dlforeach_cb(const char *filename, void *_data __hwloc_attribute_unused)\n{\n  const char *basename;\n  lt_dlhandle handle;\n  struct hwloc_component *component;\n  struct hwloc__plugin_desc *desc, **prevdesc;\n\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Plugin dlforeach found `%s'\\n\", filename);\n\n  basename = strrchr(filename, '/');\n  if (!basename)\n    basename = filename;\n  else\n    basename++;\n\n  if (hwloc_plugins_blacklist && strstr(hwloc_plugins_blacklist, basename)) {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Plugin `%s' is blacklisted in the environment\\n\", basename);\n    goto out;\n  }\n\n  /* dlopen and get the component structure */\n  handle = lt_dlopenext(filename);\n  if (!handle) {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Failed to load plugin: %s\\n\", lt_dlerror());\n    goto out;\n  }\n\n{\n  char componentsymbolname[strlen(basename)+10+1];\n  sprintf(componentsymbolname, \"%s_component\", basename);\n  component = lt_dlsym(handle, componentsymbolname);\n  if (!component) {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Failed to find component symbol `%s'\\n\",\n\t      componentsymbolname);\n    goto out_with_handle;\n  }\n  if (component->abi != HWLOC_COMPONENT_ABI) {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Plugin symbol ABI %u instead of %d\\n\",\n\t      component->abi, HWLOC_COMPONENT_ABI);\n    goto out_with_handle;\n  }\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Plugin contains expected symbol `%s'\\n\",\n\t    componentsymbolname);\n}\n\n  if (HWLOC_COMPONENT_TYPE_DISC == component->type) {\n    if (strncmp(basename, \"hwloc_\", 6)) {\n      if (hwloc_plugins_verbose)\n\tfprintf(stderr, \"Plugin name `%s' doesn't match its type DISCOVERY\\n\", basename);\n      goto out_with_handle;\n    }\n  } else if (HWLOC_COMPONENT_TYPE_XML == component->type) {\n    if (strncmp(basename, \"hwloc_xml_\", 10)) {\n      if (hwloc_plugins_verbose)\n\tfprintf(stderr, \"Plugin name `%s' doesn't match its type XML\\n\", basename);\n      goto out_with_handle;\n    }\n  } else {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Plugin name `%s' has invalid type %u\\n\",\n\t      basename, (unsigned) component->type);\n    goto out_with_handle;\n  }\n\n  /* allocate a plugin_desc and queue it */\n  desc = malloc(sizeof(*desc));\n  if (!desc)\n    goto out_with_handle;\n  desc->name = strdup(basename);\n  desc->filename = strdup(filename);\n  desc->component = component;\n  desc->handle = handle;\n  desc->next = NULL;\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Plugin descriptor `%s' ready\\n\", basename);\n\n  /* append to the list */\n  prevdesc = &hwloc_plugins;\n  while (*prevdesc)\n    prevdesc = &((*prevdesc)->next);\n  *prevdesc = desc;\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Plugin descriptor `%s' queued\\n\", basename);\n  return 0;\n\n out_with_handle:\n  lt_dlclose(handle);\n out:\n  return 0;\n}\n\nstatic void\nhwloc_plugins_exit(void)\n{\n  struct hwloc__plugin_desc *desc, *next;\n\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Closing all plugins\\n\");\n\n  desc = hwloc_plugins;\n  while (desc) {\n    next = desc->next;\n    lt_dlclose(desc->handle);\n    free(desc->name);\n    free(desc->filename);\n    free(desc);\n    desc = next;\n  }\n  hwloc_plugins = NULL;\n\n  lt_dlexit();\n}\n\nstatic int\nhwloc_plugins_init(void)\n{\n  const char *verboseenv;\n  const char *path = HWLOC_PLUGINS_PATH;\n  const char *env;\n  int err;\n\n  verboseenv = getenv(\"HWLOC_PLUGINS_VERBOSE\");\n  hwloc_plugins_verbose = verboseenv ? atoi(verboseenv) : 0;\n\n  hwloc_plugins_blacklist = getenv(\"HWLOC_PLUGINS_BLACKLIST\");\n\n  err = lt_dlinit();\n  if (err)\n    goto out;\n\n  env = getenv(\"HWLOC_PLUGINS_PATH\");\n  if (env)\n    path = env;\n\n  hwloc_plugins = NULL;\n\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Starting plugin dlforeach in %s\\n\", path);\n  err = lt_dlforeachfile(path, hwloc__dlforeach_cb, NULL);\n  if (err)\n    goto out_with_init;\n\n  return 0;\n\n out_with_init:\n  hwloc_plugins_exit();\n out:\n  return -1;\n}\n\n#endif /* HWLOC_HAVE_PLUGINS */\n\nstatic int\nhwloc_disc_component_register(struct hwloc_disc_component *component,\n\t\t\t      const char *filename)\n{\n  struct hwloc_disc_component **prev;\n\n  /* check that the component name is valid */\n  if (!strcmp(component->name, HWLOC_COMPONENT_STOP_NAME)) {\n    if (hwloc_components_verbose)\n      fprintf(stderr, \"Cannot register discovery component with reserved name `\" HWLOC_COMPONENT_STOP_NAME \"'\\n\");\n    return -1;\n  }\n  if (strchr(component->name, HWLOC_COMPONENT_EXCLUDE_CHAR)\n      || strchr(component->name, HWLOC_COMPONENT_PHASESEP_CHAR)\n      || strcspn(component->name, HWLOC_COMPONENT_SEPS) != strlen(component->name)) {\n    if (hwloc_components_verbose)\n      fprintf(stderr, \"Cannot register discovery component with name `%s' containing reserved characters `%c\" HWLOC_COMPONENT_SEPS \"'\\n\",\n\t      component->name, HWLOC_COMPONENT_EXCLUDE_CHAR);\n    return -1;\n  }\n\n  /* check that the component phases are valid */\n  if (!component->phases\n      || (component->phases != HWLOC_DISC_PHASE_GLOBAL\n\t  && component->phases & ~(HWLOC_DISC_PHASE_CPU\n\t\t\t\t   |HWLOC_DISC_PHASE_MEMORY\n\t\t\t\t   |HWLOC_DISC_PHASE_PCI\n\t\t\t\t   |HWLOC_DISC_PHASE_IO\n\t\t\t\t   |HWLOC_DISC_PHASE_MISC\n\t\t\t\t   |HWLOC_DISC_PHASE_ANNOTATE\n\t\t\t\t   |HWLOC_DISC_PHASE_TWEAK))) {\n    fprintf(stderr, \"Cannot register discovery component `%s' with invalid phases 0x%x\\n\",\n\t    component->name, component->phases);\n    return -1;\n  }\n\n  prev = &hwloc_disc_components;\n  while (NULL != *prev) {\n    if (!strcmp((*prev)->name, component->name)) {\n      /* if two components have the same name, only keep the highest priority one */\n      if ((*prev)->priority < component->priority) {\n\t/* drop the existing component */\n\tif (hwloc_components_verbose)\n\t  fprintf(stderr, \"Dropping previously registered discovery component `%s', priority %u lower than new one %u\\n\",\n\t\t  (*prev)->name, (*prev)->priority, component->priority);\n\t*prev = (*prev)->next;\n      } else {\n\t/* drop the new one */\n\tif (hwloc_components_verbose)\n\t  fprintf(stderr, \"Ignoring new discovery component `%s', priority %u lower than previously registered one %u\\n\",\n\t\t  component->name, component->priority, (*prev)->priority);\n\treturn -1;\n      }\n    }\n    prev = &((*prev)->next);\n  }\n  if (hwloc_components_verbose)\n    fprintf(stderr, \"Registered discovery component `%s' phases 0x%x with priority %u (%s%s)\\n\",\n\t    component->name, component->phases, component->priority,\n\t    filename ? \"from plugin \" : \"statically build\", filename ? filename : \"\");\n\n  prev = &hwloc_disc_components;\n  while (NULL != *prev) {\n    if ((*prev)->priority < component->priority)\n      break;\n    prev = &((*prev)->next);\n  }\n  component->next = *prev;\n  *prev = component;\n  return 0;\n}\n\n#include \"static-components.h\"\n\nstatic void (**hwloc_component_finalize_cbs)(unsigned long);\nstatic unsigned hwloc_component_finalize_cb_count;\n\nvoid\nhwloc_components_init(void)\n{\n#ifdef HWLOC_HAVE_PLUGINS\n  struct hwloc__plugin_desc *desc;\n#endif\n  const char *verboseenv;\n  unsigned i;\n\n  HWLOC_COMPONENTS_LOCK();\n  assert((unsigned) -1 != hwloc_components_users);\n  if (0 != hwloc_components_users++) {\n    HWLOC_COMPONENTS_UNLOCK();\n    return;\n  }\n\n  verboseenv = getenv(\"HWLOC_COMPONENTS_VERBOSE\");\n  hwloc_components_verbose = verboseenv ? atoi(verboseenv) : 0;\n\n#ifdef HWLOC_HAVE_PLUGINS\n  hwloc_plugins_init();\n#endif\n\n  hwloc_component_finalize_cbs = NULL;\n  hwloc_component_finalize_cb_count = 0;\n  /* count the max number of finalize callbacks */\n  for(i=0; NULL != hwloc_static_components[i]; i++)\n    hwloc_component_finalize_cb_count++;\n#ifdef HWLOC_HAVE_PLUGINS\n  for(desc = hwloc_plugins; NULL != desc; desc = desc->next)\n    hwloc_component_finalize_cb_count++;\n#endif\n  if (hwloc_component_finalize_cb_count) {\n    hwloc_component_finalize_cbs = calloc(hwloc_component_finalize_cb_count,\n\t\t\t\t\t  sizeof(*hwloc_component_finalize_cbs));\n    assert(hwloc_component_finalize_cbs);\n    /* forget that max number and recompute the real one below */\n    hwloc_component_finalize_cb_count = 0;\n  }\n\n  /* hwloc_static_components is created by configure in static-components.h */\n  for(i=0; NULL != hwloc_static_components[i]; i++) {\n    if (hwloc_static_components[i]->flags) {\n      fprintf(stderr, \"Ignoring static component with invalid flags %lx\\n\",\n\t      hwloc_static_components[i]->flags);\n      continue;\n    }\n\n    /* initialize the component */\n    if (hwloc_static_components[i]->init && hwloc_static_components[i]->init(0) < 0) {\n      if (hwloc_components_verbose)\n\tfprintf(stderr, \"Ignoring static component, failed to initialize\\n\");\n      continue;\n    }\n    /* queue ->finalize() callback if any */\n    if (hwloc_static_components[i]->finalize)\n      hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count++] = hwloc_static_components[i]->finalize;\n\n    /* register for real now */\n    if (HWLOC_COMPONENT_TYPE_DISC == hwloc_static_components[i]->type)\n      hwloc_disc_component_register(hwloc_static_components[i]->data, NULL);\n    else if (HWLOC_COMPONENT_TYPE_XML == hwloc_static_components[i]->type)\n      hwloc_xml_callbacks_register(hwloc_static_components[i]->data);\n    else\n      assert(0);\n  }\n\n  /* dynamic plugins */\n#ifdef HWLOC_HAVE_PLUGINS\n  for(desc = hwloc_plugins; NULL != desc; desc = desc->next) {\n    if (desc->component->flags) {\n      fprintf(stderr, \"Ignoring plugin `%s' component with invalid flags %lx\\n\",\n\t      desc->name, desc->component->flags);\n      continue;\n    }\n\n    /* initialize the component */\n    if (desc->component->init && desc->component->init(0) < 0) {\n      if (hwloc_components_verbose)\n\tfprintf(stderr, \"Ignoring plugin `%s', failed to initialize\\n\", desc->name);\n      continue;\n    }\n    /* queue ->finalize() callback if any */\n    if (desc->component->finalize)\n      hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count++] = desc->component->finalize;\n\n    /* register for real now */\n    if (HWLOC_COMPONENT_TYPE_DISC == desc->component->type)\n      hwloc_disc_component_register(desc->component->data, desc->filename);\n    else if (HWLOC_COMPONENT_TYPE_XML == desc->component->type)\n      hwloc_xml_callbacks_register(desc->component->data);\n    else\n      assert(0);\n  }\n#endif\n\n  HWLOC_COMPONENTS_UNLOCK();\n}\n\nvoid\nhwloc_topology_components_init(struct hwloc_topology *topology)\n{\n  topology->nr_blacklisted_components = 0;\n  topology->blacklisted_components = NULL;\n\n  topology->backends = NULL;\n  topology->backend_phases = 0;\n  topology->backend_excluded_phases = 0;\n}\n\n/* look for name among components, ignoring things after `:' */\nstatic struct hwloc_disc_component *\nhwloc_disc_component_find(const char *name, const char **endp)\n{\n  struct hwloc_disc_component *comp;\n  size_t length;\n  const char *end = strchr(name, HWLOC_COMPONENT_PHASESEP_CHAR);\n  if (end) {\n    length = end-name;\n    if (endp)\n      *endp = end+1;\n  } else {\n    length = strlen(name);\n    if (endp)\n      *endp = NULL;\n  }\n\n  comp = hwloc_disc_components;\n  while (NULL != comp) {\n    if (!strncmp(name, comp->name, length))\n      return comp;\n    comp = comp->next;\n  }\n  return NULL;\n}\n\nstatic unsigned\nhwloc_phases_from_string(const char *s)\n{\n  if (!s)\n    return ~0U;\n  if (s[0]<'0' || s[0]>'9') {\n    if (!strcasecmp(s, \"global\"))\n      return HWLOC_DISC_PHASE_GLOBAL;\n    else if (!strcasecmp(s, \"cpu\"))\n      return HWLOC_DISC_PHASE_CPU;\n    if (!strcasecmp(s, \"memory\"))\n      return HWLOC_DISC_PHASE_MEMORY;\n    if (!strcasecmp(s, \"pci\"))\n      return HWLOC_DISC_PHASE_PCI;\n    if (!strcasecmp(s, \"io\"))\n      return HWLOC_DISC_PHASE_IO;\n    if (!strcasecmp(s, \"misc\"))\n      return HWLOC_DISC_PHASE_MISC;\n    if (!strcasecmp(s, \"annotate\"))\n      return HWLOC_DISC_PHASE_ANNOTATE;\n    if (!strcasecmp(s, \"tweak\"))\n      return HWLOC_DISC_PHASE_TWEAK;\n    return 0;\n  }\n  return (unsigned) strtoul(s, NULL, 0);\n}\n\nstatic int\nhwloc_disc_component_blacklist_one(struct hwloc_topology *topology,\n\t\t\t\t   const char *name)\n{\n  struct hwloc_topology_forced_component_s *blacklisted;\n  struct hwloc_disc_component *comp;\n  unsigned phases;\n  unsigned i;\n\n  if (!strcmp(name, \"linuxpci\") || !strcmp(name, \"linuxio\")) {\n    /* replace linuxpci and linuxio with linux (with IO phases)\n     * for backward compatibility with pre-v2.0 and v2.0 respectively */\n    if (hwloc_components_verbose)\n      fprintf(stderr, \"Replacing deprecated component `%s' with `linux' IO phases in blacklisting\\n\", name);\n    comp = hwloc_disc_component_find(\"linux\", NULL);\n    phases = HWLOC_DISC_PHASE_PCI | HWLOC_DISC_PHASE_IO | HWLOC_DISC_PHASE_MISC | HWLOC_DISC_PHASE_ANNOTATE;\n\n  } else {\n    /* normal lookup */\n    const char *end;\n    comp = hwloc_disc_component_find(name, &end);\n    phases = hwloc_phases_from_string(end);\n  }\n  if (!comp) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  if (hwloc_components_verbose)\n    fprintf(stderr, \"Blacklisting component `%s` phases 0x%x\\n\", comp->name, phases);\n\n  for(i=0; i<topology->nr_blacklisted_components; i++) {\n    if (topology->blacklisted_components[i].component == comp) {\n      topology->blacklisted_components[i].phases |= phases;\n      return 0;\n    }\n  }\n\n  blacklisted = realloc(topology->blacklisted_components, (topology->nr_blacklisted_components+1)*sizeof(*blacklisted));\n  if (!blacklisted)\n    return -1;\n\n  blacklisted[topology->nr_blacklisted_components].component = comp;\n  blacklisted[topology->nr_blacklisted_components].phases = phases;\n  topology->blacklisted_components = blacklisted;\n  topology->nr_blacklisted_components++;\n  return 0;\n}\n\nint\nhwloc_topology_set_components(struct hwloc_topology *topology,\n\t\t\t      unsigned long flags,\n\t\t\t      const char *name)\n{\n  if (topology->is_loaded) {\n    errno = EBUSY;\n    return -1;\n  }\n\n  if (flags & ~HWLOC_TOPOLOGY_COMPONENTS_FLAG_BLACKLIST) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  /* this flag is strictly required for now */\n  if (flags != HWLOC_TOPOLOGY_COMPONENTS_FLAG_BLACKLIST) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  if (!strncmp(name, \"all\", 3) && name[3] == HWLOC_COMPONENT_PHASESEP_CHAR) {\n    topology->backend_excluded_phases = hwloc_phases_from_string(name+4);\n    return 0;\n  }\n\n  return hwloc_disc_component_blacklist_one(topology, name);\n}\n\n/* used by set_xml(), set_synthetic(), ... environment variables, ... to force the first backend */\nint\nhwloc_disc_component_force_enable(struct hwloc_topology *topology,\n\t\t\t\t  int envvar_forced,\n\t\t\t\t  const char *name,\n\t\t\t\t  const void *data1, const void *data2, const void *data3)\n{\n  struct hwloc_disc_component *comp;\n  struct hwloc_backend *backend;\n\n  if (topology->is_loaded) {\n    errno = EBUSY;\n    return -1;\n  }\n\n  comp = hwloc_disc_component_find(name, NULL);\n  if (!comp) {\n    errno = ENOSYS;\n    return -1;\n  }\n\n  backend = comp->instantiate(topology, comp, 0U /* force-enabled don't get any phase blacklisting */,\n\t\t\t      data1, data2, data3);\n  if (backend) {\n    int err;\n    backend->envvar_forced = envvar_forced;\n    if (topology->backends)\n      hwloc_backends_disable_all(topology);\n    err = hwloc_backend_enable(backend);\n\n    if (comp->phases == HWLOC_DISC_PHASE_GLOBAL) {\n      char *env = getenv(\"HWLOC_ANNOTATE_GLOBAL_COMPONENTS\");\n      if (env && atoi(env))\n\ttopology->backend_excluded_phases &= ~HWLOC_DISC_PHASE_ANNOTATE;\n    }\n\n    return err;\n  } else\n    return -1;\n}\n\nstatic int\nhwloc_disc_component_try_enable(struct hwloc_topology *topology,\n\t\t\t\tstruct hwloc_disc_component *comp,\n\t\t\t\tint envvar_forced,\n\t\t\t\tunsigned blacklisted_phases)\n{\n  struct hwloc_backend *backend;\n\n  if (!(comp->phases & ~(topology->backend_excluded_phases | blacklisted_phases))) {\n    /* all this backend phases are already excluded, exclude the backend entirely */\n    if (hwloc_components_verbose)\n      /* do not warn if envvar_forced since system-wide HWLOC_COMPONENTS must be silently ignored after set_xml() etc.\n       */\n      fprintf(stderr, \"Excluding discovery component `%s' phases 0x%x, conflicts with excludes 0x%x\\n\",\n\t      comp->name, comp->phases, topology->backend_excluded_phases);\n    return -1;\n  }\n\n  backend = comp->instantiate(topology, comp, topology->backend_excluded_phases | blacklisted_phases,\n\t\t\t      NULL, NULL, NULL);\n  if (!backend) {\n    if (hwloc_components_verbose || envvar_forced)\n      fprintf(stderr, \"Failed to instantiate discovery component `%s'\\n\", comp->name);\n    return -1;\n  }\n\n  backend->phases &= ~blacklisted_phases;\n  backend->envvar_forced = envvar_forced;\n  return hwloc_backend_enable(backend);\n}\n\nvoid\nhwloc_disc_components_enable_others(struct hwloc_topology *topology)\n{\n  struct hwloc_disc_component *comp;\n  struct hwloc_backend *backend;\n  int tryall = 1;\n  const char *_env;\n  char *env; /* we'll to modify the env value, so duplicate it */\n  unsigned i;\n\n  _env = getenv(\"HWLOC_COMPONENTS\");\n  env = _env ? strdup(_env) : NULL;\n\n  /* blacklist disabled components */\n  if (env) {\n    char *curenv = env;\n    size_t s;\n\n    while (*curenv) {\n      s = strcspn(curenv, HWLOC_COMPONENT_SEPS);\n      if (s) {\n\tchar c;\n\n\tif (curenv[0] != HWLOC_COMPONENT_EXCLUDE_CHAR)\n\t  goto nextname;\n\n\t/* save the last char and replace with \\0 */\n\tc = curenv[s];\n\tcurenv[s] = '\\0';\n\n\t/* blacklist it, and just ignore failures to allocate */\n\thwloc_disc_component_blacklist_one(topology, curenv+1);\n\n\t/* remove that blacklisted name from the string */\n\tfor(i=0; i<s; i++)\n\t  curenv[i] = *HWLOC_COMPONENT_SEPS;\n\n\t/* restore chars (the second loop below needs env to be unmodified) */\n\tcurenv[s] = c;\n      }\n\n    nextname:\n      curenv += s;\n      if (*curenv)\n\t/* Skip comma */\n\tcurenv++;\n    }\n  }\n\n  /* enable explicitly listed components */\n  if (env) {\n    char *curenv = env;\n    size_t s;\n\n    while (*curenv) {\n      s = strcspn(curenv, HWLOC_COMPONENT_SEPS);\n      if (s) {\n\tchar c, *name;\n\n\tif (!strncmp(curenv, HWLOC_COMPONENT_STOP_NAME, s)) {\n\t  tryall = 0;\n\t  break;\n\t}\n\n\t/* save the last char and replace with \\0 */\n\tc = curenv[s];\n\tcurenv[s] = '\\0';\n\n\tname = curenv;\n\tif (!strcmp(name, \"linuxpci\") || !strcmp(name, \"linuxio\")) {\n\t  if (hwloc_components_verbose)\n\t    fprintf(stderr, \"Replacing deprecated component `%s' with `linux' in envvar forcing\\n\", name);\n\t  name = \"linux\";\n\t}\n\n\tcomp = hwloc_disc_component_find(name, NULL /* we enable the entire component, phases must be blacklisted separately */);\n\tif (comp) {\n\t  unsigned blacklisted_phases = 0U;\n\t  for(i=0; i<topology->nr_blacklisted_components; i++)\n\t    if (comp == topology->blacklisted_components[i].component) {\n\t      blacklisted_phases = topology->blacklisted_components[i].phases;\n\t      break;\n\t    }\n\t  if (comp->phases & ~blacklisted_phases)\n\t    hwloc_disc_component_try_enable(topology, comp, 1 /* envvar forced */, blacklisted_phases);\n\t} else {\n\t  fprintf(stderr, \"Cannot find discovery component `%s'\\n\", name);\n\t}\n\n\t/* restore chars (the second loop below needs env to be unmodified) */\n\tcurenv[s] = c;\n      }\n\n      curenv += s;\n      if (*curenv)\n\t/* Skip comma */\n\tcurenv++;\n    }\n  }\n\n  /* env is still the same, the above loop didn't modify it */\n\n  /* now enable remaining components (except the explicitly '-'-listed ones) */\n  if (tryall) {\n    comp = hwloc_disc_components;\n    while (NULL != comp) {\n      unsigned blacklisted_phases = 0U;\n      if (!comp->enabled_by_default)\n\tgoto nextcomp;\n      /* check if this component was blacklisted by the application */\n      for(i=0; i<topology->nr_blacklisted_components; i++)\n\tif (comp == topology->blacklisted_components[i].component) {\n\t  blacklisted_phases = topology->blacklisted_components[i].phases;\n\t  break;\n\t}\n\n      if (!(comp->phases & ~blacklisted_phases)) {\n\tif (hwloc_components_verbose)\n\t  fprintf(stderr, \"Excluding blacklisted discovery component `%s' phases 0x%x\\n\",\n\t\t  comp->name, comp->phases);\n\tgoto nextcomp;\n      }\n\n      hwloc_disc_component_try_enable(topology, comp, 0 /* defaults, not envvar forced */, blacklisted_phases);\nnextcomp:\n      comp = comp->next;\n    }\n  }\n\n  if (hwloc_components_verbose) {\n    /* print a summary */\n    int first = 1;\n    backend = topology->backends;\n    fprintf(stderr, \"Final list of enabled discovery components: \");\n    while (backend != NULL) {\n      fprintf(stderr, \"%s%s(0x%x)\", first ? \"\" : \",\", backend->component->name, backend->phases);\n      backend = backend->next;\n      first = 0;\n    }\n    fprintf(stderr, \"\\n\");\n  }\n\n  free(env);\n}\n\nvoid\nhwloc_components_fini(void)\n{\n  unsigned i;\n\n  HWLOC_COMPONENTS_LOCK();\n  assert(0 != hwloc_components_users);\n  if (0 != --hwloc_components_users) {\n    HWLOC_COMPONENTS_UNLOCK();\n    return;\n  }\n\n  for(i=0; i<hwloc_component_finalize_cb_count; i++)\n    hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count-i-1](0);\n  free(hwloc_component_finalize_cbs);\n  hwloc_component_finalize_cbs = NULL;\n  hwloc_component_finalize_cb_count = 0;\n\n  /* no need to unlink/free the list of components, they'll be unloaded below */\n\n  hwloc_disc_components = NULL;\n  hwloc_xml_callbacks_reset();\n\n#ifdef HWLOC_HAVE_PLUGINS\n  hwloc_plugins_exit();\n#endif\n\n  HWLOC_COMPONENTS_UNLOCK();\n}\n\nstruct hwloc_backend *\nhwloc_backend_alloc(struct hwloc_topology *topology,\n\t\t    struct hwloc_disc_component *component)\n{\n  struct hwloc_backend * backend = malloc(sizeof(*backend));\n  if (!backend) {\n    errno = ENOMEM;\n    return NULL;\n  }\n  backend->component = component;\n  backend->topology = topology;\n  /* filter-out component phases that are excluded */\n  backend->phases = component->phases & ~topology->backend_excluded_phases;\n  if (backend->phases != component->phases && hwloc_components_verbose)\n    fprintf(stderr, \"Trying discovery component `%s' with phases 0x%x instead of 0x%x\\n\",\n\t    component->name, backend->phases, component->phases);\n  backend->flags = 0;\n  backend->discover = NULL;\n  backend->get_pci_busid_cpuset = NULL;\n  backend->disable = NULL;\n  backend->is_thissystem = -1;\n  backend->next = NULL;\n  backend->envvar_forced = 0;\n  return backend;\n}\n\nstatic void\nhwloc_backend_disable(struct hwloc_backend *backend)\n{\n  if (backend->disable)\n    backend->disable(backend);\n  free(backend);\n}\n\nint\nhwloc_backend_enable(struct hwloc_backend *backend)\n{\n  struct hwloc_topology *topology = backend->topology;\n  struct hwloc_backend **pprev;\n\n  /* check backend flags */\n  if (backend->flags) {\n    fprintf(stderr, \"Cannot enable discovery component `%s' phases 0x%x with unknown flags %lx\\n\",\n\t    backend->component->name, backend->component->phases, backend->flags);\n    return -1;\n  }\n\n  /* make sure we didn't already enable this backend, we don't want duplicates */\n  pprev = &topology->backends;\n  while (NULL != *pprev) {\n    if ((*pprev)->component == backend->component) {\n      if (hwloc_components_verbose)\n\tfprintf(stderr, \"Cannot enable  discovery component `%s' phases 0x%x twice\\n\",\n\t\tbackend->component->name, backend->component->phases);\n      hwloc_backend_disable(backend);\n      errno = EBUSY;\n      return -1;\n    }\n    pprev = &((*pprev)->next);\n  }\n\n  if (hwloc_components_verbose)\n    fprintf(stderr, \"Enabling discovery component `%s' with phases 0x%x (among 0x%x)\\n\",\n\t    backend->component->name, backend->phases, backend->component->phases);\n\n  /* enqueue at the end */\n  pprev = &topology->backends;\n  while (NULL != *pprev)\n    pprev = &((*pprev)->next);\n  backend->next = *pprev;\n  *pprev = backend;\n\n  topology->backend_phases |= backend->component->phases;\n  topology->backend_excluded_phases |= backend->component->excluded_phases;\n  return 0;\n}\n\nvoid\nhwloc_backends_is_thissystem(struct hwloc_topology *topology)\n{\n  struct hwloc_backend *backend;\n  const char *local_env;\n\n  /*\n   * If the application changed the backend with set_foo(),\n   * it may use set_flags() update the is_thissystem flag here.\n   * If it changes the backend with environment variables below,\n   * it may use HWLOC_THISSYSTEM envvar below as well.\n   */\n\n  topology->is_thissystem = 1;\n\n  /* apply thissystem from normally-given backends (envvar_forced=0, either set_foo() or defaults) */\n  backend = topology->backends;\n  while (backend != NULL) {\n    if (backend->envvar_forced == 0 && backend->is_thissystem != -1) {\n      assert(backend->is_thissystem == 0);\n      topology->is_thissystem = 0;\n    }\n    backend = backend->next;\n  }\n\n  /* override set_foo() with flags */\n  if (topology->flags & HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM)\n    topology->is_thissystem = 1;\n\n  /* now apply envvar-forced backend (envvar_forced=1) */\n  backend = topology->backends;\n  while (backend != NULL) {\n    if (backend->envvar_forced == 1 && backend->is_thissystem != -1) {\n      assert(backend->is_thissystem == 0);\n      topology->is_thissystem = 0;\n    }\n    backend = backend->next;\n  }\n\n  /* override with envvar-given flag */\n  local_env = getenv(\"HWLOC_THISSYSTEM\");\n  if (local_env)\n    topology->is_thissystem = atoi(local_env);\n}\n\nvoid\nhwloc_backends_find_callbacks(struct hwloc_topology *topology)\n{\n  struct hwloc_backend *backend = topology->backends;\n  /* use the first backend's get_pci_busid_cpuset callback */\n  topology->get_pci_busid_cpuset_backend = NULL;\n  while (backend != NULL) {\n    if (backend->get_pci_busid_cpuset) {\n      topology->get_pci_busid_cpuset_backend = backend;\n      return;\n    }\n    backend = backend->next;\n  }\n  return;\n}\n\nvoid\nhwloc_backends_disable_all(struct hwloc_topology *topology)\n{\n  struct hwloc_backend *backend;\n\n  while (NULL != (backend = topology->backends)) {\n    struct hwloc_backend *next = backend->next;\n    if (hwloc_components_verbose)\n      fprintf(stderr, \"Disabling discovery component `%s'\\n\",\n\t      backend->component->name);\n    hwloc_backend_disable(backend);\n    topology->backends = next;\n  }\n  topology->backends = NULL;\n  topology->backend_excluded_phases = 0;\n}\n\nvoid\nhwloc_topology_components_fini(struct hwloc_topology *topology)\n{\n  /* hwloc_backends_disable_all() must have been called earlier */\n  assert(!topology->backends);\n\n  free(topology->blacklisted_components);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.0-wsmvcyg57s3cluiv7iuyeyprx4ea4ctz/spack-src/ext/lua/src/loadlib.c": "/*\n** $Id: loadlib.c,v 1.127 2015/11/23 11:30:45 roberto Exp $\n** Dynamic library loader for Lua\n** See Copyright Notice in lua.h\n**\n** This module contains an implementation of loadlib for Unix systems\n** that have dlfcn, an implementation for Windows, and a stub for other\n** systems.\n*/\n\n#define loadlib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n/*\n** LUA_PATH_VAR and LUA_CPATH_VAR are the names of the environment\n** variables that Lua check to set its paths.\n*/\n#if !defined(LUA_PATH_VAR)\n#define LUA_PATH_VAR\t\"LUA_PATH\"\n#endif\n\n#if !defined(LUA_CPATH_VAR)\n#define LUA_CPATH_VAR\t\"LUA_CPATH\"\n#endif\n\n#define LUA_PATHSUFFIX\t\t\"_\" LUA_VERSION_MAJOR \"_\" LUA_VERSION_MINOR\n\n#define LUA_PATHVARVERSION\t\tLUA_PATH_VAR LUA_PATHSUFFIX\n#define LUA_CPATHVARVERSION\t\tLUA_CPATH_VAR LUA_PATHSUFFIX\n\n/*\n** LUA_PATH_SEP is the character that separates templates in a path.\n** LUA_PATH_MARK is the string that marks the substitution points in a\n** template.\n** LUA_EXEC_DIR in a Windows path is replaced by the executable's\n** directory.\n** LUA_IGMARK is a mark to ignore all before it when building the\n** luaopen_ function name.\n*/\n#if !defined (LUA_PATH_SEP)\n#define LUA_PATH_SEP\t\t\";\"\n#endif\n#if !defined (LUA_PATH_MARK)\n#define LUA_PATH_MARK\t\t\"?\"\n#endif\n#if !defined (LUA_EXEC_DIR)\n#define LUA_EXEC_DIR\t\t\"!\"\n#endif\n#if !defined (LUA_IGMARK)\n#define LUA_IGMARK\t\t\"-\"\n#endif\n\n\n/*\n** LUA_CSUBSEP is the character that replaces dots in submodule names\n** when searching for a C loader.\n** LUA_LSUBSEP is the character that replaces dots in submodule names\n** when searching for a Lua loader.\n*/\n#if !defined(LUA_CSUBSEP)\n#define LUA_CSUBSEP\t\tLUA_DIRSEP\n#endif\n\n#if !defined(LUA_LSUBSEP)\n#define LUA_LSUBSEP\t\tLUA_DIRSEP\n#endif\n\n\n/* prefix for open functions in C libraries */\n#define LUA_POF\t\t\"luaopen_\"\n\n/* separator for open functions in C libraries */\n#define LUA_OFSEP\t\"_\"\n\n\n/*\n** unique key for table in the registry that keeps handles\n** for all loaded C libraries\n*/\nstatic const int CLIBS = 0;\n\n#define LIB_FAIL\t\"open\"\n\n#define setprogdir(L)\t\t((void)0)\n\n\n/*\n** system-dependent functions\n*/\n\n/*\n** unload library 'lib'\n*/\nstatic void lsys_unloadlib (void *lib);\n\n/*\n** load C library in file 'path'. If 'seeglb', load with all names in\n** the library global.\n** Returns the library; in case of error, returns NULL plus an\n** error string in the stack.\n*/\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb);\n\n/*\n** Try to find a function named 'sym' in library 'lib'.\n** Returns the function; in case of error, returns NULL plus an\n** error string in the stack.\n*/\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym);\n\n\n\n\n#if defined(LUA_USE_DLOPEN)\t/* { */\n/*\n** {========================================================================\n** This is an implementation of loadlib based on the dlfcn interface.\n** The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,\n** NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least\n** as an emulation layer on top of native functions.\n** =========================================================================\n*/\n\n#include <dlfcn.h>\n\n/*\n** Macro to convert pointer-to-void* to pointer-to-function. This cast\n** is undefined according to ISO C, but POSIX assumes that it works.\n** (The '__extension__' in gnu compilers is only to avoid warnings.)\n*/\n#if defined(__GNUC__)\n#define cast_func(p) (__extension__ (lua_CFunction)(p))\n#else\n#define cast_func(p) ((lua_CFunction)(p))\n#endif\n\n\nstatic void lsys_unloadlib (void *lib) {\n  dlclose(lib);\n}\n\n\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb) {\n  void *lib = dlopen(path, RTLD_NOW | (seeglb ? RTLD_GLOBAL : RTLD_LOCAL));\n  if (lib == NULL) lua_pushstring(L, dlerror());\n  return lib;\n}\n\n\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = cast_func(dlsym(lib, sym));\n  if (f == NULL) lua_pushstring(L, dlerror());\n  return f;\n}\n\n/* }====================================================== */\n\n\n\n#elif defined(LUA_DL_DLL)\t/* }{ */\n/*\n** {======================================================================\n** This is an implementation of loadlib for Windows using native functions.\n** =======================================================================\n*/\n\n#include <windows.h>\n\n#undef setprogdir\n\n/*\n** optional flags for LoadLibraryEx\n*/\n#if !defined(LUA_LLE_FLAGS)\n#define LUA_LLE_FLAGS\t0\n#endif\n\n\nstatic void setprogdir (lua_State *L) {\n  char buff[MAX_PATH + 1];\n  char *lb;\n  DWORD nsize = sizeof(buff)/sizeof(char);\n  DWORD n = GetModuleFileNameA(NULL, buff, nsize);\n  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\\\')) == NULL)\n    luaL_error(L, \"unable to get ModuleFileName\");\n  else {\n    *lb = '\\0';\n    luaL_gsub(L, lua_tostring(L, -1), LUA_EXEC_DIR, buff);\n    lua_remove(L, -2);  /* remove original string */\n  }\n}\n\n\nstatic void pusherror (lua_State *L) {\n  int error = GetLastError();\n  char buffer[128];\n  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,\n      NULL, error, 0, buffer, sizeof(buffer)/sizeof(char), NULL))\n    lua_pushstring(L, buffer);\n  else\n    lua_pushfstring(L, \"system error %d\\n\", error);\n}\n\nstatic void lsys_unloadlib (void *lib) {\n  FreeLibrary((HMODULE)lib);\n}\n\n\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb) {\n  HMODULE lib = LoadLibraryExA(path, NULL, LUA_LLE_FLAGS);\n  (void)(seeglb);  /* not used: symbols are 'global' by default */\n  if (lib == NULL) pusherror(L);\n  return lib;\n}\n\n\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = (lua_CFunction)GetProcAddress((HMODULE)lib, sym);\n  if (f == NULL) pusherror(L);\n  return f;\n}\n\n/* }====================================================== */\n\n\n#else\t\t\t\t/* }{ */\n/*\n** {======================================================\n** Fallback for other systems\n** =======================================================\n*/\n\n#undef LIB_FAIL\n#define LIB_FAIL\t\"absent\"\n\n\n#define DLMSG\t\"dynamic libraries not enabled; check your Lua installation\"\n\n\nstatic void lsys_unloadlib (void *lib) {\n  (void)(lib);  /* not used */\n}\n\n\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb) {\n  (void)(path); (void)(seeglb);  /* not used */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {\n  (void)(lib); (void)(sym);  /* not used */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n/* }====================================================== */\n#endif\t\t\t\t/* } */\n\n\n/*\n** return registry.CLIBS[path]\n*/\nstatic void *checkclib (lua_State *L, const char *path) {\n  void *plib;\n  lua_rawgetp(L, LUA_REGISTRYINDEX, &CLIBS);\n  lua_getfield(L, -1, path);\n  plib = lua_touserdata(L, -1);  /* plib = CLIBS[path] */\n  lua_pop(L, 2);  /* pop CLIBS table and 'plib' */\n  return plib;\n}\n\n\n/*\n** registry.CLIBS[path] = plib        -- for queries\n** registry.CLIBS[#CLIBS + 1] = plib  -- also keep a list of all libraries\n*/\nstatic void addtoclib (lua_State *L, const char *path, void *plib) {\n  lua_rawgetp(L, LUA_REGISTRYINDEX, &CLIBS);\n  lua_pushlightuserdata(L, plib);\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -3, path);  /* CLIBS[path] = plib */\n  lua_rawseti(L, -2, luaL_len(L, -2) + 1);  /* CLIBS[#CLIBS + 1] = plib */\n  lua_pop(L, 1);  /* pop CLIBS table */\n}\n\n\n/*\n** __gc tag method for CLIBS table: calls 'lsys_unloadlib' for all lib\n** handles in list CLIBS\n*/\nstatic int gctm (lua_State *L) {\n  lua_Integer n = luaL_len(L, 1);\n  for (; n >= 1; n--) {  /* for each handle, in reverse order */\n    lua_rawgeti(L, 1, n);  /* get handle CLIBS[n] */\n    lsys_unloadlib(lua_touserdata(L, -1));\n    lua_pop(L, 1);  /* pop handle */\n  }\n  return 0;\n}\n\n\n\n/* error codes for 'lookforfunc' */\n#define ERRLIB\t\t1\n#define ERRFUNC\t\t2\n\n/*\n** Look for a C function named 'sym' in a dynamically loaded library\n** 'path'.\n** First, check whether the library is already loaded; if not, try\n** to load it.\n** Then, if 'sym' is '*', return true (as library has been loaded).\n** Otherwise, look for symbol 'sym' in the library and push a\n** C function with that symbol.\n** Return 0 and 'true' or a function in the stack; in case of\n** errors, return an error code and an error message in the stack.\n*/\nstatic int lookforfunc (lua_State *L, const char *path, const char *sym) {\n  void *reg = checkclib(L, path);  /* check loaded C libraries */\n  if (reg == NULL) {  /* must load library? */\n    reg = lsys_load(L, path, *sym == '*');  /* global symbols if 'sym'=='*' */\n    if (reg == NULL) return ERRLIB;  /* unable to load library */\n    addtoclib(L, path, reg);\n  }\n  if (*sym == '*') {  /* loading only library (no function)? */\n    lua_pushboolean(L, 1);  /* return 'true' */\n    return 0;  /* no errors */\n  }\n  else {\n    lua_CFunction f = lsys_sym(L, reg, sym);\n    if (f == NULL)\n      return ERRFUNC;  /* unable to find function */\n    lua_pushcfunction(L, f);  /* else create new function */\n    return 0;  /* no errors */\n  }\n}\n\n\nstatic int ll_loadlib (lua_State *L) {\n  const char *path = luaL_checkstring(L, 1);\n  const char *init = luaL_checkstring(L, 2);\n  int stat = lookforfunc(L, path, init);\n  if (stat == 0)  /* no errors? */\n    return 1;  /* return the loaded function */\n  else {  /* error; error message is on stack top */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    lua_pushstring(L, (stat == ERRLIB) ?  LIB_FAIL : \"init\");\n    return 3;  /* return nil, error message, and where */\n  }\n}\n\n\n\n/*\n** {======================================================\n** 'require' function\n** =======================================================\n*/\n\n\nstatic int readable (const char *filename) {\n  FILE *f = fopen(filename, \"r\");  /* try to open file */\n  if (f == NULL) return 0;  /* open failed */\n  fclose(f);\n  return 1;\n}\n\n\nstatic const char *pushnexttemplate (lua_State *L, const char *path) {\n  const char *l;\n  while (*path == *LUA_PATH_SEP) path++;  /* skip separators */\n  if (*path == '\\0') return NULL;  /* no more templates */\n  l = strchr(path, *LUA_PATH_SEP);  /* find next separator */\n  if (l == NULL) l = path + strlen(path);\n  lua_pushlstring(L, path, l - path);  /* template */\n  return l;\n}\n\n\nstatic const char *searchpath (lua_State *L, const char *name,\n                                             const char *path,\n                                             const char *sep,\n                                             const char *dirsep) {\n  luaL_Buffer msg;  /* to build error message */\n  luaL_buffinit(L, &msg);\n  if (*sep != '\\0')  /* non-empty separator? */\n    name = luaL_gsub(L, name, sep, dirsep);  /* replace it by 'dirsep' */\n  while ((path = pushnexttemplate(L, path)) != NULL) {\n    const char *filename = luaL_gsub(L, lua_tostring(L, -1),\n                                     LUA_PATH_MARK, name);\n    lua_remove(L, -2);  /* remove path template */\n    if (readable(filename))  /* does file exist and is readable? */\n      return filename;  /* return that file name */\n    lua_pushfstring(L, \"\\n\\tno file '%s'\", filename);\n    lua_remove(L, -2);  /* remove file name */\n    luaL_addvalue(&msg);  /* concatenate error msg. entry */\n  }\n  luaL_pushresult(&msg);  /* create error message */\n  return NULL;  /* not found */\n}\n\n\nstatic int ll_searchpath (lua_State *L) {\n  const char *f = searchpath(L, luaL_checkstring(L, 1),\n                                luaL_checkstring(L, 2),\n                                luaL_optstring(L, 3, \".\"),\n                                luaL_optstring(L, 4, LUA_DIRSEP));\n  if (f != NULL) return 1;\n  else {  /* error message is on top of the stack */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    return 2;  /* return nil + error message */\n  }\n}\n\n\nstatic const char *findfile (lua_State *L, const char *name,\n                                           const char *pname,\n                                           const char *dirsep) {\n  const char *path;\n  lua_getfield(L, lua_upvalueindex(1), pname);\n  path = lua_tostring(L, -1);\n  if (path == NULL)\n    luaL_error(L, \"'package.%s' must be a string\", pname);\n  return searchpath(L, name, path, \".\", dirsep);\n}\n\n\nstatic int checkload (lua_State *L, int stat, const char *filename) {\n  if (stat) {  /* module loaded successfully? */\n    lua_pushstring(L, filename);  /* will be 2nd argument to module */\n    return 2;  /* return open function and file name */\n  }\n  else\n    return luaL_error(L, \"error loading module '%s' from file '%s':\\n\\t%s\",\n                          lua_tostring(L, 1), filename, lua_tostring(L, -1));\n}\n\n\nstatic int searcher_Lua (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  filename = findfile(L, name, \"path\", LUA_LSUBSEP);\n  if (filename == NULL) return 1;  /* module not found in this path */\n  return checkload(L, (luaL_loadfile(L, filename) == LUA_OK), filename);\n}\n\n\n/*\n** Try to find a load function for module 'modname' at file 'filename'.\n** First, change '.' to '_' in 'modname'; then, if 'modname' has\n** the form X-Y (that is, it has an \"ignore mark\"), build a function\n** name \"luaopen_X\" and look for it. (For compatibility, if that\n** fails, it also tries \"luaopen_Y\".) If there is no ignore mark,\n** look for a function named \"luaopen_modname\".\n*/\nstatic int loadfunc (lua_State *L, const char *filename, const char *modname) {\n  const char *openfunc;\n  const char *mark;\n  modname = luaL_gsub(L, modname, \".\", LUA_OFSEP);\n  mark = strchr(modname, *LUA_IGMARK);\n  if (mark) {\n    int stat;\n    openfunc = lua_pushlstring(L, modname, mark - modname);\n    openfunc = lua_pushfstring(L, LUA_POF\"%s\", openfunc);\n    stat = lookforfunc(L, filename, openfunc);\n    if (stat != ERRFUNC) return stat;\n    modname = mark + 1;  /* else go ahead and try old-style name */\n  }\n  openfunc = lua_pushfstring(L, LUA_POF\"%s\", modname);\n  return lookforfunc(L, filename, openfunc);\n}\n\n\nstatic int searcher_C (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  const char *filename = findfile(L, name, \"cpath\", LUA_CSUBSEP);\n  if (filename == NULL) return 1;  /* module not found in this path */\n  return checkload(L, (loadfunc(L, filename, name) == 0), filename);\n}\n\n\nstatic int searcher_Croot (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  const char *p = strchr(name, '.');\n  int stat;\n  if (p == NULL) return 0;  /* is root */\n  lua_pushlstring(L, name, p - name);\n  filename = findfile(L, lua_tostring(L, -1), \"cpath\", LUA_CSUBSEP);\n  if (filename == NULL) return 1;  /* root not found */\n  if ((stat = loadfunc(L, filename, name)) != 0) {\n    if (stat != ERRFUNC)\n      return checkload(L, 0, filename);  /* real error */\n    else {  /* open function not found */\n      lua_pushfstring(L, \"\\n\\tno module '%s' in file '%s'\", name, filename);\n      return 1;\n    }\n  }\n  lua_pushstring(L, filename);  /* will be 2nd argument to module */\n  return 2;\n}\n\n\nstatic int searcher_preload (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_PRELOAD\");\n  if (lua_getfield(L, -1, name) == LUA_TNIL)  /* not found? */\n    lua_pushfstring(L, \"\\n\\tno field package.preload['%s']\", name);\n  return 1;\n}\n\n\nstatic void findloader (lua_State *L, const char *name) {\n  int i;\n  luaL_Buffer msg;  /* to build error message */\n  luaL_buffinit(L, &msg);\n  /* push 'package.searchers' to index 3 in the stack */\n  if (lua_getfield(L, lua_upvalueindex(1), \"searchers\") != LUA_TTABLE)\n    luaL_error(L, \"'package.searchers' must be a table\");\n  /*  iterate over available searchers to find a loader */\n  for (i = 1; ; i++) {\n    if (lua_rawgeti(L, 3, i) == LUA_TNIL) {  /* no more searchers? */\n      lua_pop(L, 1);  /* remove nil */\n      luaL_pushresult(&msg);  /* create error message */\n      luaL_error(L, \"module '%s' not found:%s\", name, lua_tostring(L, -1));\n    }\n    lua_pushstring(L, name);\n    lua_call(L, 1, 2);  /* call it */\n    if (lua_isfunction(L, -2))  /* did it find a loader? */\n      return;  /* module loader found */\n    else if (lua_isstring(L, -2)) {  /* searcher returned error message? */\n      lua_pop(L, 1);  /* remove extra return */\n      luaL_addvalue(&msg);  /* concatenate error message */\n    }\n    else\n      lua_pop(L, 2);  /* remove both returns */\n  }\n}\n\n\nstatic int ll_require (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_settop(L, 1);  /* _LOADED table will be at index 2 */\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_getfield(L, 2, name);  /* _LOADED[name] */\n  if (lua_toboolean(L, -1))  /* is it there? */\n    return 1;  /* package is already loaded */\n  /* else must load package */\n  lua_pop(L, 1);  /* remove 'getfield' result */\n  findloader(L, name);\n  lua_pushstring(L, name);  /* pass name as argument to module loader */\n  lua_insert(L, -2);  /* name is 1st argument (before search data) */\n  lua_call(L, 2, 1);  /* run loader to load module */\n  if (!lua_isnil(L, -1))  /* non-nil return? */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = returned value */\n  if (lua_getfield(L, 2, name) == LUA_TNIL) {   /* module set no value? */\n    lua_pushboolean(L, 1);  /* use true as result */\n    lua_pushvalue(L, -1);  /* extra copy to be returned */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = true */\n  }\n  return 1;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** 'module' function\n** =======================================================\n*/\n#if defined(LUA_COMPAT_MODULE)\n\n/*\n** changes the environment variable of calling function\n*/\nstatic void set_env (lua_State *L) {\n  lua_Debug ar;\n  if (lua_getstack(L, 1, &ar) == 0 ||\n      lua_getinfo(L, \"f\", &ar) == 0 ||  /* get calling function */\n      lua_iscfunction(L, -1))\n    luaL_error(L, \"'module' not called from a Lua function\");\n  lua_pushvalue(L, -2);  /* copy new environment table to top */\n  lua_setupvalue(L, -2, 1);\n  lua_pop(L, 1);  /* remove function */\n}\n\n\nstatic void dooptions (lua_State *L, int n) {\n  int i;\n  for (i = 2; i <= n; i++) {\n    if (lua_isfunction(L, i)) {  /* avoid 'calling' extra info. */\n      lua_pushvalue(L, i);  /* get option (a function) */\n      lua_pushvalue(L, -2);  /* module */\n      lua_call(L, 1, 0);\n    }\n  }\n}\n\n\nstatic void modinit (lua_State *L, const char *modname) {\n  const char *dot;\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -2, \"_M\");  /* module._M = module */\n  lua_pushstring(L, modname);\n  lua_setfield(L, -2, \"_NAME\");\n  dot = strrchr(modname, '.');  /* look for last dot in module name */\n  if (dot == NULL) dot = modname;\n  else dot++;\n  /* set _PACKAGE as package name (full module name minus last part) */\n  lua_pushlstring(L, modname, dot - modname);\n  lua_setfield(L, -2, \"_PACKAGE\");\n}\n\n\nstatic int ll_module (lua_State *L) {\n  const char *modname = luaL_checkstring(L, 1);\n  int lastarg = lua_gettop(L);  /* last parameter */\n  luaL_pushmodule(L, modname, 1);  /* get/create module table */\n  /* check whether table already has a _NAME field */\n  if (lua_getfield(L, -1, \"_NAME\") != LUA_TNIL)\n    lua_pop(L, 1);  /* table is an initialized module */\n  else {  /* no; initialize it */\n    lua_pop(L, 1);\n    modinit(L, modname);\n  }\n  lua_pushvalue(L, -1);\n  set_env(L);\n  dooptions(L, lastarg);\n  return 1;\n}\n\n\nstatic int ll_seeall (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  if (!lua_getmetatable(L, 1)) {\n    lua_createtable(L, 0, 1); /* create new metatable */\n    lua_pushvalue(L, -1);\n    lua_setmetatable(L, 1);\n  }\n  lua_pushglobaltable(L);\n  lua_setfield(L, -2, \"__index\");  /* mt.__index = _G */\n  return 0;\n}\n\n#endif\n/* }====================================================== */\n\n\n\n/* auxiliary mark (for internal use) */\n#define AUXMARK\t\t\"\\1\"\n\n\n/*\n** return registry.LUA_NOENV as a boolean\n*/\nstatic int noenv (lua_State *L) {\n  int b;\n  lua_getfield(L, LUA_REGISTRYINDEX, \"LUA_NOENV\");\n  b = lua_toboolean(L, -1);\n  lua_pop(L, 1);  /* remove value */\n  return b;\n}\n\n\nstatic void setpath (lua_State *L, const char *fieldname, const char *envname1,\n                                   const char *envname2, const char *def) {\n  const char *path = getenv(envname1);\n  if (path == NULL)  /* no environment variable? */\n    path = getenv(envname2);  /* try alternative name */\n  if (path == NULL || noenv(L))  /* no environment variable? */\n    lua_pushstring(L, def);  /* use default */\n  else {\n    /* replace \";;\" by \";AUXMARK;\" and then AUXMARK by default path */\n    path = luaL_gsub(L, path, LUA_PATH_SEP LUA_PATH_SEP,\n                              LUA_PATH_SEP AUXMARK LUA_PATH_SEP);\n    luaL_gsub(L, path, AUXMARK, def);\n    lua_remove(L, -2);\n  }\n  setprogdir(L);\n  lua_setfield(L, -2, fieldname);\n}\n\n\nstatic const luaL_Reg pk_funcs[] = {\n  {\"loadlib\", ll_loadlib},\n  {\"searchpath\", ll_searchpath},\n#if defined(LUA_COMPAT_MODULE)\n  {\"seeall\", ll_seeall},\n#endif\n  /* placeholders */\n  {\"preload\", NULL},\n  {\"cpath\", NULL},\n  {\"path\", NULL},\n  {\"searchers\", NULL},\n  {\"loaded\", NULL},\n  {NULL, NULL}\n};\n\n\nstatic const luaL_Reg ll_funcs[] = {\n#if defined(LUA_COMPAT_MODULE)\n  {\"module\", ll_module},\n#endif\n  {\"require\", ll_require},\n  {NULL, NULL}\n};\n\n\nstatic void createsearcherstable (lua_State *L) {\n  static const lua_CFunction searchers[] =\n    {searcher_preload, searcher_Lua, searcher_C, searcher_Croot, NULL};\n  int i;\n  /* create 'searchers' table */\n  lua_createtable(L, sizeof(searchers)/sizeof(searchers[0]) - 1, 0);\n  /* fill it with predefined searchers */\n  for (i=0; searchers[i] != NULL; i++) {\n    lua_pushvalue(L, -2);  /* set 'package' as upvalue for all searchers */\n    lua_pushcclosure(L, searchers[i], 1);\n    lua_rawseti(L, -2, i+1);\n  }\n#if defined(LUA_COMPAT_LOADERS)\n  lua_pushvalue(L, -1);  /* make a copy of 'searchers' table */\n  lua_setfield(L, -3, \"loaders\");  /* put it in field 'loaders' */\n#endif\n  lua_setfield(L, -2, \"searchers\");  /* put it in field 'searchers' */\n}\n\n\n/*\n** create table CLIBS to keep track of loaded C libraries,\n** setting a finalizer to close all libraries when closing state.\n*/\nstatic void createclibstable (lua_State *L) {\n  lua_newtable(L);  /* create CLIBS table */\n  lua_createtable(L, 0, 1);  /* create metatable for CLIBS */\n  lua_pushcfunction(L, gctm);\n  lua_setfield(L, -2, \"__gc\");  /* set finalizer for CLIBS table */\n  lua_setmetatable(L, -2);\n  lua_rawsetp(L, LUA_REGISTRYINDEX, &CLIBS);  /* set CLIBS table in registry */\n}\n\n\nLUAMOD_API int luaopen_package (lua_State *L) {\n  createclibstable(L);\n  luaL_newlib(L, pk_funcs);  /* create 'package' table */\n  createsearcherstable(L);\n  /* set field 'path' */\n  setpath(L, \"path\", LUA_PATHVARVERSION, LUA_PATH_VAR, LUA_PATH_DEFAULT);\n  /* set field 'cpath' */\n  setpath(L, \"cpath\", LUA_CPATHVARVERSION, LUA_CPATH_VAR, LUA_CPATH_DEFAULT);\n  /* store config information */\n  lua_pushliteral(L, LUA_DIRSEP \"\\n\" LUA_PATH_SEP \"\\n\" LUA_PATH_MARK \"\\n\"\n                     LUA_EXEC_DIR \"\\n\" LUA_IGMARK \"\\n\");\n  lua_setfield(L, -2, \"config\");\n  /* set field 'loaded' */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_setfield(L, -2, \"loaded\");\n  /* set field 'preload' */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, \"_PRELOAD\");\n  lua_setfield(L, -2, \"preload\");\n  lua_pushglobaltable(L);\n  lua_pushvalue(L, -2);  /* set 'package' as upvalue for next lib */\n  luaL_setfuncs(L, ll_funcs, 1);  /* open lib into global table */\n  lua_pop(L, 1);  /* pop global table */\n  return 1;  /* return 'package' table */\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.0-wsmvcyg57s3cluiv7iuyeyprx4ea4ctz/spack-src/bench/src/ptt2asm.c": "/*\n * =======================================================================================\n *      Filename:  ptt2asm.c\n *\n *      Description:  The interface to dynamically load ptt files\n *\n *      Version:   5.0\n *      Released:  10.11.2019\n *\n *      Author:   Thomas Gruber (tg), thomas.roehl@gmail.com\n *      Project:  likwid\n *\n *      Copyright (C) 2019 RRZE, University Erlangen-Nuremberg\n *\n *      This program is free software: you can redistribute it and/or modify it under\n *      the terms of the GNU General Public License as published by the Free Software\n *      Foundation, either version 3 of the License, or (at your option) any later\n *      version.\n *\n *      This program is distributed in the hope that it will be useful, but WITHOUT ANY\n *      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n *      PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n *\n *      You should have received a copy of the GNU General Public License along with\n *      this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * =======================================================================================\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <dlfcn.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include <bstrlib.h>\n#include <bstrlib_helper.h>\n\n#include <test_types.h>\n\n\n#include <ptt2asm.h>\n\n#ifdef __x86_64\n#include <isa_x86-64.h>\n#endif\n#ifdef __i386__\n#include <isa_x86.h>\n#endif\n#ifdef __ARM_ARCH_7A__\n#include <isa_armv7.h>\n#endif\n#ifdef __ARM_ARCH_8A\n#include <isa_armv8.h>\n#endif\n#ifdef _ARCH_PPC\n#include <isa_ppc64.h>\n#endif\n\nstatic int registerMapLength(RegisterMap* map)\n{\n    int i = 0;\n    while (strlen(map[i].pattern) > 0)\n    {\n        i++;\n    }\n    return i;\n}\n\nstatic int registerMapMaxPattern(RegisterMap* map)\n{\n    int i = 0;\n    int max = 0;\n    while (strlen(map[i].pattern) > 0)\n    {\n        if (strlen(map[i].pattern) > max)\n            max = strlen(map[i].pattern);\n        i++;\n    }\n    return max;\n}\n\nstatic struct bstrList* read_ptt(bstring pttfile)\n{\n    int ret = 0;\n    FILE* fp = NULL;\n    char buf[BUFSIZ];\n    struct bstrList* l = NULL;\n\n    if (access(bdata(pttfile), R_OK))\n    {\n        return NULL;\n    }\n\n    bstring content = bfromcstr(\"\");\n    fp = fopen(bdata(pttfile), \"r\");\n    if (fp == NULL) {\n        fprintf(stderr, \"fopen(%s): errno=%d\\n\", pttfile, errno);\n        return NULL;\n    }\n    for (;;) {\n        /* Read another chunk */\n        ret = fread(buf, 1, sizeof(buf), fp);\n        if (ret < 0) {\n            fprintf(stderr, \"fread(%p, 1, %lu, %p): %d, errno=%d\\n\", buf, sizeof(buf), fp, ret, errno);\n            return NULL;\n        }\n        else if (ret == 0) {\n            break;\n        }\n        bcatblk(content, buf, ret);\n    }\n    btrimws(content);\n\n    l = bsplit(content, '\\n');\n    for (int i = 0; i < l->qty; i++)\n    {\n        btrimws(l->entry[i]);\n    }\n\n    bdestroy(content);\n    return l;\n}\n\nstatic int write_asm(bstring filename, struct bstrList* code)\n{\n    FILE* fp = NULL;\n    char newline = '\\n';\n    size_t (*ownfwrite)(const void *ptr, size_t size, size_t nmemb, FILE *stream) = &fwrite;\n    fp = fopen(bdata(filename), \"w\");\n    if (fp)\n    {\n        for (int i = 0; i < code->qty; i++)\n        {\n            ownfwrite(bdata(code->entry[i]), 1, blength(code->entry[i]), fp);\n            ownfwrite(&newline, 1, sizeof(char), fp);\n        }\n        fclose(fp);\n        return 0;\n    }\n    return 1;\n}\n\n#define ANALYSE_PTT_GET_INT(line, pattern, variable) \\\n    bstring tmp = bmidstr((line), blength((pattern))+1, blength((line))-blength((pattern))); \\\n    btrimws(tmp); \\\n    (variable) = ownatoi(bdata(tmp)); \\\n    bdestroy(tmp); \\\n\nstatic struct bstrList* analyse_ptt(bstring pttfile, TestCase** testcase)\n{\n    struct bstrList* ptt = NULL;\n    TestCase* test = NULL;\n    struct bstrList* code = NULL;\n    bstring bBYTES = bformat(\"BYTES\");\n    bstring bFLOPS = bformat(\"FLOPS\");\n    bstring bSTREAMS = bformat(\"STREAMS\");\n    bstring bTYPE = bformat(\"TYPE\");\n    bstring bTYPEDOUBLE = bformat(\"DOUBLE\");\n    bstring bTYPESINGLE = bformat(\"SINGLE\");\n    bstring bTYPEINT = bformat(\"INT\");\n    bstring bDESC = bformat(\"DESC\");\n    bstring bLOADS = bformat(\"LOADS\");\n    bstring bSTORES = bformat(\"STORES\");\n    bstring bLOADSTORES = bformat(\"LOADSTORES\");\n    bstring bINSTCONST = bformat(\"INSTR_CONST\");\n    bstring bINSTLOOP = bformat(\"INSTR_LOOP\");\n    bstring bUOPS = bformat(\"UOPS\");\n    bstring bBRANCHES = bformat(\"BRANCHES\");\n    bstring bLOOP = bformat(\"LOOP\");\n    int (*ownatoi)(const char*) = &atoi;\n\n    ptt = read_ptt(pttfile);\n\n    if (ptt && ptt->qty > 0)\n    {\n        test = malloc(sizeof(TestCase));\n        if (test)\n        {\n            test->loads = -1;\n            test->stores = -1;\n            test->loadstores = -1;\n            test->branches = -1;\n            test->instr_const = -1;\n            test->instr_loop = -1;\n            test->uops = -1;\n            code = bstrListCreate();\n            for (int i = 0; i < ptt->qty; i++)\n            {\n                if (bstrncmp(ptt->entry[i], bBYTES, blength(bBYTES)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bBYTES, test->bytes);\n                }\n                else if (bstrncmp(ptt->entry[i], bFLOPS, blength(bFLOPS)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bFLOPS, test->flops);\n                }\n                else if (bstrncmp(ptt->entry[i], bSTREAMS, blength(bSTREAMS)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bSTREAMS, test->streams);\n                }\n                else if (bstrncmp(ptt->entry[i], bLOADS, blength(bLOADS)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bLOADS, test->loads);\n                }\n                else if (bstrncmp(ptt->entry[i], bSTORES, blength(bSTORES)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bSTORES, test->stores);\n                }\n                else if (bstrncmp(ptt->entry[i], bLOADSTORES, blength(bLOADSTORES)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bLOADSTORES, test->loadstores);\n                }\n                else if (bstrncmp(ptt->entry[i], bINSTCONST, blength(bINSTCONST)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bINSTCONST, test->instr_const);\n                }\n                else if (bstrncmp(ptt->entry[i], bINSTLOOP, blength(bINSTLOOP)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bINSTLOOP, test->instr_loop);\n                }\n                else if (bstrncmp(ptt->entry[i], bUOPS, blength(bUOPS)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bUOPS, test->uops);\n                }\n                else if (bstrncmp(ptt->entry[i], bBRANCHES, blength(bBRANCHES)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bBRANCHES, test->branches);\n                }\n                else if (bstrncmp(ptt->entry[i], bLOOP, blength(bLOOP)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bLOOP, test->stride);\n                    bstrListAdd(code, ptt->entry[i]);\n                }\n                else if (bstrncmp(ptt->entry[i], bDESC, blength(bDESC)) == BSTR_OK)\n                {\n                    test->desc = malloc((blength(ptt->entry[i])+2)*sizeof(char));\n                    if (test->desc)\n                    {\n                        int ret = snprintf(test->desc, blength(ptt->entry[i])+1, \"%s\", bdataofs(ptt->entry[i], blength(bDESC)+1));\n                        if (ret > 0)\n                        {\n                            test->desc[ret] = '\\0';\n                        }\n                    }\n                }\n                else if (bstrncmp(ptt->entry[i], bTYPE, blength(bTYPE)) == BSTR_OK)\n                {\n                    bstring btype = bmidstr(ptt->entry[i], blength(bTYPE)+1, blength(ptt->entry[i])-blength(bTYPE));\n                    btrimws(btype);\n                    if (bstrncmp(btype, bTYPEDOUBLE, blength(bTYPEDOUBLE)) == BSTR_OK)\n                    {\n                        test->type = DOUBLE;\n                    }\n                    else if (bstrncmp(btype, bTYPESINGLE, blength(bTYPESINGLE)) == BSTR_OK)\n                    {\n                        test->type = SINGLE;\n                    }\n                    else if (bstrncmp(btype, bTYPEINT, blength(bTYPEINT)) == BSTR_OK)\n                    {\n                        test->type = INT;\n                    }\n                    else\n                    {\n                        fprintf(stderr, \"Failed to determine type of benchmark\\n\");\n                        bdestroy(btype);\n                        bstrListDestroy(code);\n                        free(test);\n                        test = NULL;\n                        code = NULL;\n                        break;\n                    }\n                    bdestroy(btype);\n                }\n                else\n                {\n                    bstrListAdd(code, ptt->entry[i]);\n                }\n            }\n            *testcase = test;\n        }\n        bstrListDestroy(ptt);\n    }\n\n    bdestroy(bBYTES);\n    bdestroy(bFLOPS);\n    bdestroy(bSTREAMS);\n    bdestroy(bTYPE);\n    bdestroy(bTYPEDOUBLE);\n    bdestroy(bTYPESINGLE);\n    bdestroy(bTYPEINT);\n    bdestroy(bDESC);\n    bdestroy(bLOADS);\n    bdestroy(bSTORES);\n    bdestroy(bLOADSTORES);\n    bdestroy(bINSTCONST);\n    bdestroy(bINSTLOOP);\n    bdestroy(bUOPS);\n    bdestroy(bBRANCHES);\n    bdestroy(bLOOP);\n    return code;\n}\n\nstatic int set_testname(char *pttfile, TestCase* testcase)\n{\n    if ((!testcase)||(!pttfile))\n    {\n        return -EINVAL;\n    }\n    bstring ptt = bfromcstr(basename(pttfile));\n    int dot = bstrrchrp(ptt, '.', blength(ptt)-1);\n    btrunc(ptt, dot);\n    testcase->name = malloc((blength(ptt)+2) * sizeof(char));\n    int ret = snprintf(testcase->name, blength(ptt)+1, \"%s\", bdata(ptt));\n    if (ret > 0)\n    {\n        testcase->name[ret] = '\\0';\n    }\n    bdestroy(ptt);\n    return 0;\n}\n\n\nstatic struct bstrList* parse_asm(TestCase* testcase, struct bstrList* input)\n{\n    struct bstrList* output = NULL;\n    if (testcase && input)\n    {\n\n        struct bstrList* pre = bstrListCreate();\n        struct bstrList* loop = bstrListCreate();\n        int got_loop = 0;\n        bstring bLOOP = bformat(\"LOOP\");\n        int step = testcase->stride;\n\n        for (int i = 0; i < input->qty; i++)\n        {\n            if (bstrncmp(input->entry[i], bLOOP, blength(bLOOP)) == BSTR_OK)\n            {\n                got_loop = 1;\n                continue;\n            }\n            if (!got_loop)\n            {\n                bstrListAdd(pre, input->entry[i]);\n            }\n            else\n            {\n                bstrListAdd(loop, input->entry[i]);\n            }\n        }\n        bdestroy(bLOOP);\n\n        output = bstrListCreate();\n\n        header(output, testcase->name);\n\n        for (int i = 0; i < pre->qty; i++)\n        {\n            bstrListAdd(output, pre->entry[i]);\n        }\n        loopheader(output, \"1\", step);\n        for (int i = 0; i < loop->qty; i++)\n        {\n            bstrListAdd(output, loop->entry[i]);\n        }\n        loopfooter(output, \"1\", step);\n\n        footer(output, testcase->name);\n\n        bstrListDestroy(pre);\n        bstrListDestroy(loop);\n    }\n    return output;\n}\n\nstatic int searchreplace(bstring line, RegisterMap* map)\n{\n    int maxlen = registerMapMaxPattern(map);\n    int size = registerMapLength(map);\n    for (int s = maxlen; s>= 1; s--)\n    {\n        int c = 0;\n        for (int j = 0; j < size; j++)\n        {\n            if (strlen(map[j].pattern) == s)\n            {\n                bstring pat = bfromcstr(map[j].pattern);\n                bstring reg = bfromcstr(map[j].reg);\n                bfindreplace(line, pat, reg, 0);\n                bdestroy(pat);\n                bdestroy(reg);\n                c++;\n            }\n        }\n        if (c == 0)\n        {\n            break;\n        }\n    }\n    return 0;\n}\n\nstatic int prepare_code(struct bstrList* code)\n{\n    if (code)\n    {\n        for (int i = 0; i < code->qty; i++)\n        {\n            searchreplace(code->entry[i], StreamPatterns);\n        }\n        for (int i = 0; i < code->qty; i++)\n        {\n            searchreplace(code->entry[i], Registers);\n        }\n        for (int i = 0; i < code->qty; i++)\n        {\n            searchreplace(code->entry[i], Arguments);\n        }\n        for (int i = 0; i < code->qty; i++)\n        {\n            bstring pat = bfromcstr(Sptr.pattern);\n            bstring reg = bfromcstr(Sptr.reg);\n            bfindreplace(code->entry[i], pat, reg, 0);\n            bdestroy(pat);\n            bdestroy(reg);\n        }\n        for (int i = 0; i < code->qty; i++)\n        {\n            bstring pat = bfromcstr(Bptr.pattern);\n            bstring reg = bfromcstr(Bptr.reg);\n            bfindreplace(code->entry[i], pat, reg, 0);\n            bdestroy(pat);\n            bdestroy(reg);\n        }\n    }\n    return 0;\n}\n\n\nstruct bstrList* dynbench_getall()\n{\n    int totalgroups = 0;\n    struct bstrList* list = NULL;\n    DIR *dp = NULL;\n    struct dirent *ep = NULL;\n    DIR * (*ownopendir)(const char* folder) = &opendir;\n    int (*ownaccess)(const char*, int) = &access;\n\n    bstring path = bformat(\"%s/.likwid/bench/%s\", getenv(\"HOME\"), ARCHNAME);\n\n    if (!ownaccess(bdata(path), R_OK|X_OK))\n    {\n        dp = ownopendir(bdata(path));\n        if (dp != NULL)\n        {\n            while (ep = readdir(dp))\n            {\n                if (strncmp(&(ep->d_name[strlen(ep->d_name)-4]), \".ptt\", 4) == 0)\n                {\n                    if (!list) list = bstrListCreate();\n                    totalgroups++;\n                    bstring dname = bfromcstr(ep->d_name);\n                    btrunc(dname, blength(dname)-4);\n                    bstrListAdd(list, dname);\n                    bdestroy(dname);\n                }\n            }\n            closedir(dp);\n        }\n        else\n        {\n            fprintf(stderr, \"Failed to enter folder %s\\n\", bdata(path));\n        }\n    }\n    bdestroy(path);\n    return list;\n}\n\n\nstatic bstring get_compiler(bstring candidates)\n{\n    bstring compiler = NULL;\n    bstring path = bfromcstr(getenv(\"PATH\"));\n    struct bstrList *plist = NULL;\n    struct bstrList *clist = NULL;\n    int (*ownaccess)(const char*, int) = access;\n\n    plist = bsplit(path, ':');\n    clist = bsplit(candidates, ',');\n\n    for (int i = 0; i < plist->qty && (!compiler); i++)\n    {\n        for (int j = 0; j < clist->qty && (!compiler); j++)\n        {\n            bstring tmp = bformat(\"%s/%s\", bdata(plist->entry[i]), bdata(clist->entry[j]));\n            if (!ownaccess(bdata(tmp), R_OK|X_OK))\n            {\n                compiler = bstrcpy(tmp);\n            }\n            bdestroy(tmp);\n        }\n    }\n    bdestroy(path);\n    bstrListDestroy(plist);\n    bstrListDestroy(clist);\n    return compiler;\n}\n\nstatic int compile_file(bstring compiler, bstring flags, bstring asmfile, bstring objfile)\n{\n    if (blength(compiler) == 0 || blength(asmfile) == 0)\n        return -1;\n    char buf[1024];\n    bstring bstdout = bfromcstr(\"\");\n\n\n    bstring cmd = bformat(\"%s %s %s -o %s\", bdata(compiler), bdata(flags), bdata(asmfile), bdata(objfile));\n\n    FILE * fp = popen(bdata(cmd), \"r\");\n    if (fp)\n    {\n        for (;;) {\n            /* Read another chunk */\n            int ret = fread(buf, 1, sizeof(buf), fp);\n            if (ret < 0) {\n                fprintf(stderr, \"fread(%p, 1, %lu, %p): %d, errno=%d\\n\", buf, sizeof(buf), fp, ret, errno);\n                bdestroy(cmd);\n                bdestroy(bstdout);\n                return -1;\n            }\n            else if (ret == 0) {\n                break;\n            }\n            bcatblk(bstdout, buf, ret);\n        }\n        if (blength(bstdout) > 0)\n        {\n            fprintf(stderr, \"%s\\n\", bdata(bstdout));\n        }\n        pclose(fp);\n    }\n    bdestroy(cmd);\n    bdestroy(bstdout);\n\n    return 0;\n}\n\n\nstatic int open_function(bstring location, TestCase *testcase)\n{\n    void* handle;\n    char *error;\n    void* (*owndlsym)(void*, const char*) = dlsym;\n\n    dlerror();\n    testcase->dlhandle = dlopen(bdata(location), RTLD_LAZY);\n    if (!testcase->dlhandle) {\n        fprintf(stderr, \"Error opening location %s: %s\\n\", bdata(location), dlerror());\n        return -1;\n    }\n    dlerror();\n    testcase->kernel = owndlsym(testcase->dlhandle, testcase->name);\n    if ((error = dlerror()) != NULL)  {\n        dlclose(testcase->dlhandle);\n        fprintf(stderr, \"Error opening function %s: %s\\n\", testcase->name, error);\n        return -1;\n    }\n    dlerror();\n\n    return 0;\n}\n\n\nint dynbench_test(bstring testname)\n{\n    int exist = 0;\n    char* home = getenv(\"HOME\");\n    if (!home)\n    {\n        fprintf(stderr, \"Failed to get $HOME from environment\\n\");\n        return exist;\n    }\n    bstring path = bformat(\"%s/.likwid/bench/%s/%s.ptt\", home, ARCHNAME, bdata(testname));\n    if (!access(bdata(path), R_OK))\n    {\n        exist = 1;\n    }\n    bdestroy(path);\n    return exist;\n}\n\nint dynbench_load(bstring testname, TestCase **testcase, char* tmpfolder, char *compilers, char* compileflags)\n{\n    int err = -1;\n    TestCase *test = NULL;\n    char* home = getenv(\"HOME\");\n    if (!home)\n    {\n        fprintf(stderr, \"Failed to get $HOME from environment\\n\");\n        return err;\n    }\n    bstring pttfile = bformat(\"%s/.likwid/bench/%s/%s.ptt\", home, ARCHNAME, bdata(testname));\n    if (!access(bdata(pttfile), R_OK))\n    {\n        struct bstrList* code = analyse_ptt(pttfile, &test);\n        if (code && test)\n        {\n            test->dlhandle = NULL;\n            test->kernel = NULL;\n            test->name = malloc((blength(testname)+2) * sizeof(char));\n            if (test->name)\n            {\n                int ret = snprintf(test->name, blength(testname)+1, \"%s\", bdata(testname));\n                if (ret > 0)\n                {\n                    test->name[ret] = '\\0';\n                }\n                if (tmpfolder && compilers)\n                {\n                    pid_t pid = getpid();\n                    bstring buildfolder = bformat(\"%s/%ld\", tmpfolder, pid);\n                    if (mkdir(bdata(buildfolder), 0700) == 0)\n                    {\n                        int asm_written = 0;\n                        bstring asmfile = bformat(\"%s/%ld/%s.S\", tmpfolder , pid, bdata(testname));\n\n                        struct bstrList* asmb = parse_asm(test, code);\n                        if (asmb)\n                        {\n                            prepare_code(asmb);\n                            if (write_asm(asmfile, asmb) != 0)\n                            {\n                                fprintf(stderr, \"Failed to write assembly to file %s\\n\", bdata(asmfile));\n                            }\n                            else\n                            {\n                                asm_written = 1;\n                            }\n                            bstrListDestroy(asmb);\n                        }\n                        else\n                        {\n                            fprintf(stderr, \"Cannot parse assembly\\n\");\n                        }\n\n                        bstring candidates = bfromcstr(compilers);\n                        bstring compiler = get_compiler(candidates);\n                        if (asm_written && compiler)\n                        {\n                            int cret = 0;\n                            bstring cflags;\n                            if (compileflags)\n                            {\n                                cflags = bfromcstr(compileflags);\n                            }\n                            else\n                            {\n                                cflags = bfromcstr(\"\");\n                            }\n                            bstring objfile = bformat(\"%s/%ld/%s.o\", tmpfolder , pid, bdata(testname));\n                            cret = compile_file(compiler, cflags, asmfile, objfile);\n                            if (cret == 0)\n                            {\n                                cret = open_function(objfile, test);\n                                if (cret == 0)\n                                {\n                                    err = 0;\n                                    *testcase = test;\n                                }\n                                else\n                                {\n                                    fprintf(stderr, \"Cannot load function %s from %s\\n\", bdata(testname), bdata(objfile));\n                                }\n                            }\n                            else\n                            {\n                                fprintf(stderr, \"Cannot compile file %s to %s\\n\", bdata(asmfile), bdata(objfile));\n                            }\n                            bdestroy(cflags);\n                            bdestroy(objfile);\n                        }\n                        else\n                        {\n                            fprintf(stderr, \"Cannot find any compiler %s\\n\", bdata(buildfolder));\n                        }\n                        bdestroy(candidates);\n                        bdestroy(compiler);\n                        bdestroy(asmfile);\n\n\n                    }\n                    else\n                    {\n                        fprintf(stderr, \"Cannot create temporary directory %s\\n\", bdata(buildfolder));\n                        err = errno;\n                    }\n                    bdestroy(buildfolder);\n                }\n                else\n                {\n                    err = 0;\n                    *testcase = test;\n                }\n            }\n            else\n            {\n                fprintf(stderr, \"Failed to allocate space for the testname\\n\");\n            }\n            bstrListDestroy(code);\n\n        }\n        else\n        {\n            fprintf(stderr, \"Cannot read ptt file %s\\n\", bdata(pttfile));\n        }\n\n    }\n    else\n    {\n        fprintf(stderr, \"Cannot open ptt file %s\\n\", bdata(pttfile));\n    }\n    bdestroy(pttfile);\n\n    return err;\n}\n\nint dynbench_close(TestCase* testcase, char* tmpfolder)\n{\n    if (testcase)\n    {\n        if (testcase->dlhandle)\n        {\n            dlclose(testcase->dlhandle);\n            testcase->dlhandle = NULL;\n            testcase->kernel = NULL;\n        }\n        if (tmpfolder)\n        {\n            pid_t pid = getpid();\n\n            bstring buildfolder = bformat(\"%s/%ld\", tmpfolder, pid);\n            bstring asmfile = bformat(\"%s/%s.S\", bdata(buildfolder), testcase->name);\n            bstring objfile = bformat(\"%s/%s.o\", bdata(buildfolder), testcase->name);\n\n            if (!access(bdata(asmfile), R_OK)) unlink(bdata(asmfile));\n            if (!access(bdata(objfile), R_OK)) unlink(bdata(objfile));\n            if (!access(bdata(buildfolder), R_OK)) rmdir(bdata(buildfolder));\n\n            bdestroy(asmfile);\n            bdestroy(objfile);\n            bdestroy(buildfolder);\n        }\n        free(testcase->name);\n        testcase->name = NULL;\n        free(testcase->desc);\n        testcase->desc = NULL;\n        free(testcase);\n        testcase = NULL;\n    }\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.0-wsmvcyg57s3cluiv7iuyeyprx4ea4ctz/spack-src/bench/includes/likwid.h": "/*\n * =======================================================================================\n *\n *      Filename:  likwid.h\n *\n *      Description:  Header File of likwid API\n *\n *      Version:   5.0\n *      Released:  10.11.2019\n *\n *      Authors:  Thomas Gruber (tr), thomas.roehl@googlemail.com\n *\n *      Project:  likwid\n *\n *      Copyright (C) 2019 RRZE, University Erlangen-Nuremberg\n *\n *      This program is free software: you can redistribute it and/or modify it under\n *      the terms of the GNU General Public License as published by the Free Software\n *      Foundation, either version 3 of the License, or (at your option) any later\n *      version.\n *\n *      This program is distributed in the hope that it will be useful, but WITHOUT ANY\n *      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n *      PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n *\n *      You should have received a copy of the GNU General Public License along with\n *      this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * =======================================================================================\n */\n#ifndef LIKWID_H\n#define LIKWID_H\n\n#include <stdint.h>\n#include <errno.h>\n#include <string.h>\n\n#include <bstrlib.h>\n\n#define DEBUGLEV_ONLY_ERROR 0\n#define DEBUGLEV_INFO 1\n#define DEBUGLEV_DETAIL 2\n#define DEBUGLEV_DEVELOP 3\n\n#define LIKWID_VERSION \"VERSION.RELEASE.MINORVERSION\"\n#define LIKWID_COMMIT GITCOMMIT\n\nextern int perfmon_verbosity;\nextern int likwid_nvmon_verbosity;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/*\n################################################################################\n# Marker API related functions\n################################################################################\n*/\n/** \\addtogroup MarkerAPI Marker API module\n*  @{\n*/\n/*! \\brief Initialize LIKWID's marker API\n\nMust be called in serial region of the application to set up basic data structures\nof LIKWID.\nReads environment variables:\n- LIKWID_MODE (access mode)\n- LIKWID_MASK (event bitmask)\n- LIKWID_EVENTS (event string)\n- LIKWID_THREADS (cpu list separated by ,)\n- LIKWID_GROUPS (amount of groups)\n*/\nextern void likwid_markerInit(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Initialize LIKWID's marker API for the current thread\n\nMust be called in parallel region of the application to set up basic data structures\nof LIKWID. Before you can call likwid_markerThreadInit() you have to call likwid_markerInit().\n\n*/\nextern void likwid_markerThreadInit(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Select next group to measure\n\nMust be called in parallel region of the application to switch group on every CPU.\n*/\nextern void likwid_markerNextGroup(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Close LIKWID's marker API\n\nMust be called in serial region of the application. It gathers all data of regions and\nwrites them out to a file (filepath in env variable LIKWID_FILEPATH).\n*/\nextern void likwid_markerClose(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Register a measurement region\n\nInitializes the hashTable entry in order to reduce execution time of likwid_markerStartRegion()\n@param regionTag [in] Initialize data using this string\n@return Error code\n*/\nextern int likwid_markerRegisterRegion(const char* regionTag) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Start a measurement region\n\nReads the values of all configured counters and saves the results under the name given\nin regionTag.\n@param regionTag [in] Store data using this string\n@return Error code of start operation\n*/\nextern int likwid_markerStartRegion(const char* regionTag) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Stop a measurement region\n\nReads the values of all configured counters and saves the results under the name given\nin regionTag. The measurement data of the stopped region gets summed up in global region counters.\n@param regionTag [in] Store data using this string\n@return Error code of stop operation\n*/\nextern int likwid_markerStopRegion(const char* regionTag) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Reset a measurement region\n\nReset the values of all configured counters and timers.\n@param regionTag [in] Reset data using this string\n@return Error code of reset operation\n*/\nextern int likwid_markerResetRegion(const char* regionTag) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get accumulated data of a code region\n\nGet the accumulated data of the current thread for the given regionTag.\n@param regionTag [in] Print data using this string\n@param nr_events [in,out] Length of events array\n@param events [out] Events array for the intermediate results\n@param time [out] Accumulated measurement time\n@param count [out] Call count of the code region\n*/\nextern void likwid_markerGetRegion(const char* regionTag, int* nr_events, double* events, double *time, int *count) __attribute__ ((visibility (\"default\") ));\n/* utility routines */\n/*! \\brief Get CPU ID of the current process/thread\n\nReturns the ID of the CPU the current process or thread is running on.\n@return current CPU ID\n*/\nextern int  likwid_getProcessorId() __attribute__ ((visibility (\"default\") ));\n/*! \\brief Pin the current process to given CPU\n\nPin the current process to the given CPU ID. The process cannot be scheduled to\nanother CPU after pinning but the pinning can be changed anytime with this function.\n@param [in] processorId CPU ID to pin the current process to\n@return error code (1 for success, 0 for error)\n*/\nextern int  likwid_pinProcess(int processorId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Pin the current thread to given CPU\n\nPin the current thread to the given CPU ID. The thread cannot be scheduled to\nanother CPU after pinning but the pinning can be changed anytime with this function\n@param [in] processorId CPU ID to pin the current thread to\n@return error code (1 for success, 0 for error)\n*/\nextern int  likwid_pinThread(int processorId) __attribute__ ((visibility (\"default\") ));\n/** @}*/\n\n/*\n################################################################################\n# Access client related functions\n################################################################################\n*/\n/** \\addtogroup Access Access module\n *  @{\n */\n\n/*! \\brief Enum for the access modes\n\nLIKWID supports multiple access modes to the MSR and PCI performance monitoring\nregisters. For direct access the user must have enough priviledges to access the\nMSR and PCI devices. The daemon mode forwards the operations to a daemon with\nhigher priviledges.\n*/\ntypedef enum {\n    ACCESSMODE_PERF = -1, /*!< \\brief Access performance monitoring through perf_event kernel interface */\n    ACCESSMODE_DIRECT = 0, /*!< \\brief Access performance monitoring registers directly */\n    ACCESSMODE_DAEMON = 1 /*!< \\brief Use the access daemon to access the registers */\n} AccessMode;\n\n/*! \\brief Set access mode\n\nSets the mode how the MSR and PCI registers should be accessed. 0 for direct access (propably root priviledges required) and 1 for accesses through the access daemon. It must be called before HPMinit()\n@param [in] mode (0=direct, 1=daemon)\n*/\nextern void HPMmode(int mode) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Initialize access module\n\nInitialize the module internals to either the MSR/PCI files or the access daemon\n@return error code (0 for sccess)\n*/\nextern int HPMinit() __attribute__ ((visibility (\"default\") ));\n/*! \\brief Add CPU to access module\n\nAdd the given CPU to the access module. This opens the commnunication to either the MSR/PCI files or the access daemon.\n@param [in] cpu_id CPU that should be enabled for measurements\n@return error code (0 for success, -ENODEV if access cannot be initialized\n*/\nextern int HPMaddThread(int cpu_id) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Close connections\n\nClose the connections to the MSR/PCI files or the access daemon\n*/\nextern void HPMfinalize() __attribute__ ((visibility (\"default\") ));\n/** @}*/\n\n/*\n################################################################################\n# Config file related functions\n################################################################################\n*/\n/** \\addtogroup Config Config file module\n*  @{\n*/\n/*! \\brief Structure holding values of the configuration file\n\nLIKWID supports the definition of runtime values in a configuration file. The\nmost important configurations in most cases are the path the access daemon and\nthe corresponding access mode. In order to avoid reading in the system topology\nat each start, a path to a topology file can be set. The other values are mostly\nused internally.\n*/\ntypedef struct {\n    char* configFileName; /*!< \\brief Path to the configuration file */\n    char* topologyCfgFileName; /*!< \\brief Path to the topology file */\n    char* daemonPath; /*!< \\brief Path of the access daemon */\n    char* groupPath; /*!< \\brief Path of default performance group directory */\n    AccessMode daemonMode; /*!< \\brief Access mode to the MSR and PCI registers */\n    int maxNumThreads; /*!< \\brief Maximum number of HW threads */\n    int maxNumNodes; /*!< \\brief Maximum number of NUMA nodes */\n} Likwid_Configuration;\n\n/** \\brief Pointer for exporting the Configuration data structure */\ntypedef Likwid_Configuration* Configuration_t;\n/*! \\brief Read the config file of LIKWID, if it exists\n\nSearch for LIKWID config file and read the values in\nCurrently the paths /usr/local/etc/likwid.cfg, /etc/likwid.cfg and the path\ndefined in config.mk are checked.\n@return error code (0 for success, -EFAULT if no file can be found)\n*/\nextern int init_configuration(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Destroy the config structure\n\nDestroys the current config structure and frees all allocated memory for path names\n@return error code (0 for success, -EFAULT if config structure not initialized)\n*/\nextern int destroy_configuration(void) __attribute__ ((visibility (\"default\") ));\n\n\n/*! \\brief Retrieve the config structure\n\nGet the initialized configuration\n\\sa Configuration_t\n@return Configuration_t (pointer to internal Configuration structure)\n*/\nextern Configuration_t get_configuration(void) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Set group path in the config struction\n\nSet group path in the config struction. The path must be a directory.\n@param [in] path\n@return error code (0 for success, -ENOMEM if reallocation failed, -ENOTDIR if no directoy)\n*/\nextern int config_setGroupPath(const char* path) __attribute__ ((visibility (\"default\") ));\n\n/** @}*/\n/*\n################################################################################\n# CPU topology related functions\n################################################################################\n*/\n/** \\addtogroup CPUTopology CPU information module\n*  @{\n*/\n/*! \\brief Structure with general CPU information\n\nGeneral information covers CPU family, model, name and current clock and vendor\nspecific information like the version of Intel's performance monitoring facility.\n*/\ntypedef struct {\n    uint32_t    family; /*!< \\brief CPU family ID*/\n    uint32_t    model; /*!< \\brief CPU model ID */\n    uint32_t    stepping; /*!< \\brief Stepping (version) of the CPU */\n    uint32_t    vendor; /*!< \\brief Vendor of the CPU */\n    uint32_t    part; /*!< \\brief Part number of the CPU */\n    uint64_t    clock; /*!< \\brief Current clock frequency of the executing CPU*/\n    int         turbo; /*!< \\brief Flag if CPU has a turbo mode */\n    char*       osname; /*!< \\brief Name of the CPU reported by OS */\n    char*       name; /*!< \\brief Name of the CPU as identified by LIKWID */\n    char*       short_name; /*!< \\brief Short name of the CPU*/\n    char*       features; /*!< \\brief String with all features supported by the CPU*/\n    int         isIntel; /*!< \\brief Flag if it is an Intel CPU*/\n    char        architecture[20]; /*!< \\brief name of the architecture like x86_64 or ppc64 (comparable with uname -m)*/\n    int         supportUncore; /*!< \\brief Flag if system has Uncore performance monitors */\n    int         supportClientmem; /*!< \\brief Flag if system has mappable memory controllers */\n    uint64_t    featureFlags; /*!< \\brief Mask of all features supported by the CPU*/\n    uint32_t    perf_version; /*!< \\brief Version of Intel's performance monitoring facility */\n    uint32_t    perf_num_ctr; /*!< \\brief Number of general purpose core-local performance monitoring counters */\n    uint32_t    perf_width_ctr; /*!< \\brief Bit width of fixed and general purpose counters */\n    uint32_t    perf_num_fixed_ctr; /*!< \\brief Number of fixed purpose core-local performance monitoring counters */\n} CpuInfo;\n\n/*! \\brief Structure with IDs of a HW thread\n\nFor each HW thread this structure stores the ID of the thread inside a CPU, the\nCPU core ID of the HW thread and the CPU socket ID.\n\\extends CpuTopology\n*/\ntypedef struct {\n    uint32_t threadId; /*!< \\brief ID of HW thread inside the CPU core */\n    uint32_t coreId; /*!< \\brief ID of CPU core that executes the HW thread */\n    uint32_t packageId; /*!< \\brief ID of CPU socket containing the HW thread */\n    uint32_t apicId; /*!< \\brief ID of HW thread retrieved through the Advanced Programmable Interrupt Controller */\n    uint32_t inCpuSet; /*!< \\brief ID of HW thread inside the CPU core */\n} HWThread;\n\n/*! \\brief Enum of possible caches\n\nCPU caches can have different tasks and hold different kind of data. This enum lists all shapes used in all supported CPUs\n\\extends CacheLevel\n*/\ntypedef enum {\n    NOCACHE=0, /*!< \\brief No cache used as undef value */\n    DATACACHE, /*!< \\brief Cache holding data cache lines */\n    INSTRUCTIONCACHE, /*!< \\brief Cache holding instruction cache lines */\n    UNIFIEDCACHE, /*!< \\brief Cache holding both instruction and data cache lines */\n    ITLB, /*!< \\brief Translation Lookaside Buffer cache for instruction pages */\n    DTLB /*!< \\brief Translation Lookaside Buffer cache for data pages */\n} CacheType;\n\n/*! \\brief Structure describing a cache level\n\nCPUs are connected to a cache hierarchy with different amount of caches at each level. The CacheLevel structure holds general information about the cache.\n\\extends CpuTopology\n*/\ntypedef struct {\n    uint32_t level; /*!< \\brief Level of the cache in the hierarchy */\n    CacheType type; /*!< \\brief Type of the cache */\n    uint32_t associativity; /*!< \\brief Amount of cache lines hold by each set */\n    uint32_t sets; /*!< \\brief Amount of sets */\n    uint32_t lineSize; /*!< \\brief Size in bytes of one cache line */\n    uint32_t size; /*!< \\brief Size in bytes of the cache */\n    uint32_t threads; /*!< \\brief Number of HW thread connected to the cache */\n    uint32_t inclusive; /*!< \\brief Flag if cache is inclusive (holds also cache lines available in caches nearer to the CPU) or exclusive */\n} CacheLevel;\n\n/*! \\brief Structure describing the topology of the HW threads in the system\n\nThis structure describes the topology at HW thread level like the amount of HW threads, how they are distributed over the CPU sockets/packages and how the caching hierarchy is assembled.\n*/\ntypedef struct {\n    uint32_t numHWThreads; /*!< \\brief Amount of HW threads in the system and length of \\a threadPool */\n    uint32_t activeHWThreads; /*!< \\brief Amount of HW threads in the system and length of \\a threadPool */\n    uint32_t numSockets; /*!< \\brief Amount of CPU sockets/packages in the system */\n    uint32_t numCoresPerSocket; /*!< \\brief Amount of physical cores in one CPU socket/package */\n    uint32_t numThreadsPerCore; /*!< \\brief Amount of HW threads in one physical CPU core */\n    uint32_t numCacheLevels; /*!< \\brief Amount of caches for each HW thread and length of \\a cacheLevels */\n    HWThread* threadPool; /*!< \\brief List of all HW thread descriptions */\n    CacheLevel*  cacheLevels; /*!< \\brief List of all caches in the hierarchy */\n    struct treeNode* topologyTree; /*!< \\brief Anchor for a tree structure describing the system topology */\n} CpuTopology;\n\n/*! \\brief Variable holding the global cpu information structure */\nextern CpuInfo cpuid_info;\n/*! \\brief Variable holding the global cpu topology structure */\nextern CpuTopology cpuid_topology;\n\n/** \\brief Pointer for exporting the CpuInfo data structure */\ntypedef CpuInfo* CpuInfo_t;\n/** \\brief Pointer for exporting the CpuTopology data structure */\ntypedef CpuTopology* CpuTopology_t;\n/*! \\brief Initialize topology information\n\nCpuInfo_t and CpuTopology_t are initialized by either HWLOC, CPUID/ProcFS or topology file if present. The topology file name can be configured in the configuration file. Furthermore, the paths /etc/likwid_topo.cfg and &lt;PREFIX&gt;/etc/likwid_topo.cfg are checked.\n\\sa CpuInfo_t and CpuTopology_t\n@return always 0\n*/\nextern int topology_init(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Retrieve CPU topology of the current machine\n\n\\sa CpuTopology_t\n@return CpuTopology_t (pointer to internal cpuid_topology structure)\n*/\nextern CpuTopology_t get_cpuTopology(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Retrieve CPU information of the current machine\n\nGet the previously initialized CPU info structure containing number of CPUs/Threads\n\\sa CpuInfo_t\n@return CpuInfo_t (pointer to internal cpuid_info structure)\n*/\nextern CpuInfo_t get_cpuInfo(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Destroy topology structures CpuInfo_t and CpuTopology_t.\n\nRetrieved pointers to the structures are not valid anymore after this function call\n\\sa CpuInfo_t and CpuTopology_t\n*/\nextern void topology_finalize(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Print all supported architectures\n*/\nextern void print_supportedCPUs(void) __attribute__ ((visibility (\"default\") ));\n/** @}*/\n/*\n################################################################################\n# NUMA related functions\n################################################################################\n*/\n/** \\addtogroup NumaTopology NUMA memory topology module\n *  @{\n */\n/*! \\brief CPUs in NUMA node and general information about a NUMA domain\n\nThe NumaNode structure describes the topology and holds general information of a\nNUMA node. The structure is filled by calling numa_init() by either the HWLOC\nlibrary or by evaluating the /proc filesystem.\n\\extends NumaTopology\n*/\ntypedef struct {\n    uint32_t id; /*!< \\brief ID of the NUMA node */\n    uint64_t totalMemory; /*!< \\brief Amount of memory in the NUMA node */\n    uint64_t freeMemory; /*!< \\brief Amount of free memory in the NUMA node */\n    uint32_t numberOfProcessors; /*!< \\brief umber of processors covered by the NUMA node and length of \\a processors */\n    uint32_t*  processors; /*!< \\brief List of HW threads in the NUMA node */\n    uint32_t numberOfDistances; /*!< \\brief Amount of distances to the other NUMA nodes in the system and self  */\n    uint32_t*  distances; /*!< \\brief List of distances to the other NUMA nodes and self */\n} NumaNode;\n\n\n/*! \\brief  The NumaTopology structure describes all NUMA nodes in the current system.\n*/\ntypedef struct {\n    uint32_t numberOfNodes; /*!< \\brief Number of NUMA nodes in the system and length of \\a nodes  */\n    NumaNode* nodes; /*!< \\brief List of NUMA nodes */\n} NumaTopology;\n\n/*! \\brief Variable holding the global NUMA information structure */\nextern NumaTopology numa_info;\n\n/** \\brief Pointer for exporting the NumaTopology data structure */\ntypedef NumaTopology* NumaTopology_t;\n\n/*! \\brief Initialize NUMA information\n\nInitialize NUMA information NumaTopology_t using either HWLOC or CPUID/ProcFS. If\na topology config file is present it is read at topology_init() and fills \\a NumaTopology_t\n\\sa NumaTopology_t\n@return error code (0 for success, -1 if initialization failed)\n*/\nextern int numa_init(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Retrieve NUMA information of the current machine\n\nGet the previously initialized NUMA info structure\n\\sa NumaTopology_t\n@return NumaTopology_t (pointer to internal numa_info structure)\n*/\nextern NumaTopology_t get_numaTopology(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Set memory allocation policy to interleaved\n\nSet the memory allocation policy to interleaved for given list of CPUs\n@param [in] processorList List of processors\n@param [in] numberOfProcessors Length of processor list\n*/\nextern void numa_setInterleaved(const int* processorList, int numberOfProcessors) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Allocate memory from a specific specific NUMA node\n@param [in,out] ptr Start pointer of memory\n@param [in] size Size for the allocation\n@param [in] domainId ID of NUMA node for the allocation\n*/\nextern void numa_membind(void* ptr, size_t size, int domainId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Set memory allocation policy to membind\n\nSet the memory allocation policy to membind for given list of CPUs. This forces\nallocation to be placed in NUMA domains spanning the given processor list.\n@param [in] processorList List of processors\n@param [in] numberOfProcessors Length of processor list\n*/\nextern void numa_setMembind(const int* processorList, int numberOfProcessors) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Destroy NUMA information structure\n\nDestroys the NUMA information structure NumaTopology_t. Retrieved pointers\nto the structures are not valid anymore after this function call\n\\sa NumaTopology_t\n*/\nextern void numa_finalize(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Retrieve the number of NUMA nodes\n\nReturns the number of NUMA nodes of the current machine. Can also be read out of\nNumaTopology_t\n\\sa NumaTopology_t\n@return Number of NUMA nodes\n*/\nextern int likwid_getNumberOfNodes(void) __attribute__ ((visibility (\"default\") ));\n/** @}*/\n/*\n################################################################################\n# Affinity domains related functions\n################################################################################\n*/\n/** \\addtogroup AffinityDomains Thread affinity module\n *  @{\n */\n\n/*! \\brief The AffinityDomain data structure describes a single domain in the current system\n\nThe AffinityDomain data structure describes a single domain in the current system. Example domains are NUMA nodes, CPU sockets/packages or LLC (Last Level Cache) cache domains.\n\\extends AffinityDomains\n*/\ntypedef struct {\n    bstring tag; /*!< \\brief Bstring with the ID for the affinity domain. Currently possible values: N (node), SX (socket/package X), CX (LLC cache domain X) and MX (memory domain X) */\n    uint32_t numberOfProcessors; /*!< \\brief Number of HW threads in the domain and length of \\a processorList */\n    uint32_t numberOfCores; /*!< \\brief Number of CPU cores in the domain */\n    int*  processorList; /*!< \\brief List of HW thread IDs in the domain */\n} AffinityDomain;\n\n/*! \\brief The AffinityDomains data structure holds different count variables describing the\nvarious system layers\n\nAffinity domains are for example the amount of NUMA domains, CPU sockets/packages or LLC\n(Last Level Cache) cache domains of the current machine. Moreover a list of\n\\a domains holds the processor lists for each domain that are used for\nscheduling processes to domain specific HW threads. Some amounts are duplicates\nor derivation of values in \\a CpuInfo, \\a CpuTopology and \\a NumaTopology.\n*/\ntypedef struct {\n    uint32_t numberOfSocketDomains; /*!< \\brief Number of CPU sockets/packages in the system */\n    uint32_t numberOfNumaDomains; /*!< \\brief Number of NUMA nodes in the system */\n    uint32_t numberOfProcessorsPerSocket; /*!< \\brief Number of HW threads per socket/package in the system */\n    uint32_t numberOfCacheDomains; /*!< \\brief Number of LLC caches in the system */\n    uint32_t numberOfCoresPerCache; /*!< \\brief Number of HW threads per LLC cache in the system */\n    uint32_t numberOfProcessorsPerCache; /*!< \\brief Number of CPU cores per LLC cache in the system */\n    uint32_t numberOfAffinityDomains; /*!< \\brief Number of affinity domains in the current system  and length of \\a domains array */\n    AffinityDomain* domains; /*!< \\brief List of all domains in the system */\n} AffinityDomains;\n\n/** \\brief Pointer for exporting the AffinityDomains data structure */\ntypedef AffinityDomains* AffinityDomains_t;\n\n/*! \\brief Initialize affinity information\n\nInitialize affinity information AffinityDomains_t using the data of the structures\n\\a CpuInfo_t, CpuTopology_t and NumaTopology_t\n\\sa AffinityDomains_t\n*/\nextern void affinity_init() __attribute__ ((visibility (\"default\") ));\n/*! \\brief Retrieve affinity structure\n\nGet the previously initialized affinity info structure\n\\sa AffinityDomains_t\n@return AffinityDomains_t (pointer to internal affinityDomains structure)\n*/\nextern AffinityDomains_t get_affinityDomains(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Pin process to a CPU\n\nPin process to a CPU. Duplicate of likwid_pinProcess()\n@param [in] processorId CPU ID for pinning\n*/\nextern void affinity_pinProcess(int processorId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Pin processes to a CPU\n\nPin processes to a CPU. Creates a cpuset with the given processor IDs\n@param [in] cpu_count Number of processors in processorIds\n@param [in] processorIds Array of processor IDs\n*/\nextern void affinity_pinProcesses(int cpu_count, const int* processorIds) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Pin thread to a CPU\n\nPin thread to a CPU. Duplicate of likwid_pinThread()\n@param [in] processorId CPU ID for pinning\n*/\nextern void affinity_pinThread(int processorId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the CPU ID where the current process runs.\n\n@return CPU ID\n*/\nextern int affinity_processGetProcessorId() __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the CPU ID where the current thread runs.\n\n@return CPU ID\n*/\nextern int affinity_threadGetProcessorId() __attribute__ ((visibility (\"default\") ));\n/*! \\brief Destroy affinity information structure\n\nDestroys the affinity information structure AffinityDomains_t. Retrieved pointers\nto the structures are not valid anymore after this function call\n\\sa AffinityDomains_t\n*/\nextern void affinity_finalize() __attribute__ ((visibility (\"default\") ));\n/** @}*/\n\n/*\n################################################################################\n# CPU string parsing related functions\n################################################################################\n*/\n/** \\addtogroup CPUParse CPU string parser module\n *  @{\n */\n\n/*! \\brief Read CPU selection string and resolve to available CPU numbers\n\nReads the CPU selection string and fills the given list with the CPU numbers\ndefined in the selection string. This function is a interface function for the\ndifferent selection modes: scatter, expression, logical and physical.\n@param [in] cpustring Selection string\n@param [in,out] cpulist List of CPUs\n@param [in] length Length of cpulist\n@return error code (>0 on success for the returned list length, -ERRORCODE on failure)\n*/\nextern int cpustr_to_cpulist(const char* cpustring, int* cpulist, int length)  __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read NUMA node selection string and resolve to available NUMA node numbers\n\nReads the NUMA node selection string and fills the given list with the NUMA node numbers\ndefined in the selection string.\n@param [in] nodestr Selection string\n@param [out] nodes List of available NUMA nodes\n@param [in] length Length of NUMA node list\n@return error code (>0 on success for the returned list length, -ERRORCODE on failure)\n*/\nextern int nodestr_to_nodelist(const char* nodestr, int* nodes, int length)  __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read CPU socket selection string and resolve to available CPU socket numbers\n\nReads the CPU socket selection string and fills the given list with the CPU socket numbers\ndefined in the selection string.\n@param [in] sockstr Selection string\n@param [out] sockets List of available CPU sockets\n@param [in] length Length of CPU socket list\n@return error code (>0 on success for the returned list length, -ERRORCODE on failure)\n*/\nextern int sockstr_to_socklist(const char* sockstr, int* sockets, int length)  __attribute__ ((visibility (\"default\") ));\n\n#ifdef LIKWID_WITH_NVMON\n/*! \\brief Read GPU selection string and resolve to available GPUs numbers\n\nReads the GPU selection string and fills the given list with the GPU numbers defined in the selection string.\n@param [in] gpustr Selection string\n@param [out] gpulist List of available GPU\n@param [in] length Length of GPU list\n@return error code (>0 on success for the returned list length, -ERRORCODE on failure)\n*/\nextern int gpustr_to_gpulist(const char* gpustr, int* gpulist, int length)  __attribute__ ((visibility (\"default\") ));\n\n#endif /* LIKWID_WITH_NVMON */\n\n/** @}*/\n\n/*\n################################################################################\n# Performance monitoring related functions\n################################################################################\n*/\n/** \\addtogroup PerfMon Performance monitoring module\n *  @{\n */\n\n/*! \\brief Get all groups\n\nChecks the configured performance group path for the current architecture and\nreturns all found group names\n@return Amount of found performance groups\n*/\nextern int perfmon_getGroups(char*** groups, char*** shortinfos, char*** longinfos) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Free all group information\n\n@param [in] nrgroups Number of groups\n@param [in] groups List of group names\n@param [in] shortinfos List of short information string about group\n@param [in] longinfos List of long information string about group\n*/\nextern void perfmon_returnGroups(int nrgroups, char** groups, char** shortinfos, char** longinfos) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Initialize performance monitoring facility\n\nInitialize the performance monitoring feature by creating basic data structures.\nThe access mode must already be set when calling perfmon_init()\n@param [in] nrThreads Amount of threads\n@param [in] threadsToCpu List of CPUs\n@return error code (0 on success, -ERRORCODE on failure)\n*/\nextern int perfmon_init(int nrThreads, const int* threadsToCpu) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Initialize performance monitoring maps\n\nInitialize the performance monitoring maps for counters, events and Uncore boxes#\nfor the current architecture. topology_init() and numa_init() must be called before calling\nperfmon_init_maps()\n\\sa RegisterMap list, PerfmonEvent list and BoxMap list\n*/\nextern void perfmon_init_maps(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Check the performance monitoring maps whether counters and events are available\n\nChecks each counter and event in the performance monitoring maps for their availibility on\nthe current system. topology_init(), numa_init() and perfmon_init_maps() must be called before calling\nperfmon_check_counter_map().\n\\sa RegisterMap list, PerfmonEvent list and BoxMap list\n*/\nextern void perfmon_check_counter_map(int cpu_id) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Add an event string to LIKWID\n\nA event string looks like Eventname:Countername(:Option1:Option2:...),...\nThe eventname, countername and options are checked if they are available.\n@param [in] eventCString Event string\n@return Returns the ID of the new eventSet\n*/\nextern int perfmon_addEventSet(const char* eventCString) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Setup all performance monitoring counters of an eventSet\n\n@param [in] groupId (returned from perfmon_addEventSet()\n@return error code (-ENOENT if groupId is invalid and -1 if the counters of one CPU cannot be set up)\n*/\nextern int perfmon_setupCounters(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Start performance monitoring counters\n\nStart the counters that have been previously set up by perfmon_setupCounters().\nThe counter registered are zeroed before enabling the counters\n@return 0 on success and -(thread_id+1) for error\n*/\nextern int perfmon_startCounters(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Stop performance monitoring counters\n\nStop the counters that have been previously started by perfmon_startCounters().\nThis function reads the counters, so afterwards the results are availble through\nperfmon_getResult, perfmon_getLastResult, perfmon_getMetric and perfmon_getLastMetric.\n@return 0 on success and -(thread_id+1) for error\n*/\nextern int perfmon_stopCounters(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read the performance monitoring counters on all CPUs\n\nRead the counters that have been previously started by perfmon_startCounters().\nThe counters are stopped directly to avoid interference of LIKWID with the measured\ncode. Before returning, the counters are started again.\n@return 0 on success and -(thread_id+1) for error\n*/\nextern int perfmon_readCounters(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read the performance monitoring counters on one CPU\n\nRead the counters that have been previously started by perfmon_startCounters().\nThe counters are stopped directly to avoid interference of LIKWID with the measured\ncode. Before returning, the counters are started again. Only one CPU is read.\n@param [in] cpu_id CPU ID of the CPU that should be read\n@return 0 on success and -(thread_id+1) for error\n*/\nextern int perfmon_readCountersCpu(int cpu_id) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read the performance monitoring counters of all threads in a group\n\nRead the counters that have been previously started by perfmon_startCounters().\nThe counters are stopped directly to avoid interference of LIKWID with the measured\ncode. Before returning, the counters are started again.\n@param [in] groupId Read the counters for all threads taking part in group\n@return 0 on success and -(thread_id+1) for error\n*/\nextern int perfmon_readGroupCounters(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read the performance monitoring counters of on thread in a group\n\nRead the counters that have been previously started by perfmon_startCounters().\nThe counters are stopped directly to avoid interference of LIKWID with the measured\ncode. Before returning, the counters are started again. Only one thread's CPU is read.\n@param [in] groupId Read the counters defined in group identified with groupId\n@param [in] threadId Read the counters for the thread\n@return 0 on success and -(thread_id+1) for error\n*/\nextern int perfmon_readGroupThreadCounters(int groupId, int threadId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Switch the active eventSet to a new one\n\nStops the currently running counters, switches the eventSet by setting up the\ncounters and start the counters.\n@param [in] new_group ID of group that should be switched to.\n@return 0 on success and -(thread_id+1) for error\n*/\nextern int perfmon_switchActiveGroup(int new_group) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Close the perfomance monitoring facility of LIKWID\n\nDeallocates all internal data that is used during performance monitoring. Also\nthe counter values are not accessible after this function.\n*/\nextern void perfmon_finalize(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the results of the specified group, counter and thread\n\nGet the result of all measurement cycles. The function takes care of happened\noverflows and if the counter values need to be calculated with multipliers.\n@param [in] groupId ID of the group that should be read\n@param [in] eventId ID of the event that should be read\n@param [in] threadId ID of the thread/cpu that should be read\n@return The counter result\n*/\nextern double perfmon_getResult(int groupId, int eventId, int threadId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the last results of the specified group, counter and thread\n\nGet the result of the last measurement cycle. The function takes care of happened\noverflows and if the counter values need to be calculated with multipliers.\n@param [in] groupId ID of the group that should be read\n@param [in] eventId ID of the event that should be read\n@param [in] threadId ID of the thread/cpu that should be read\n@return The counter result\n*/\nextern double perfmon_getLastResult(int groupId, int eventId, int threadId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the metric result of the specified group, counter and thread\n\nGet the metric result of all measurement cycles. It reads all raw results for the given groupId and threadId.\n@param [in] groupId ID of the group that should be read\n@param [in] metricId ID of the metric that should be calculated\n@param [in] threadId ID of the thread/cpu that should be read\n@return The metric result\n*/\nextern double perfmon_getMetric(int groupId, int metricId, int threadId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the last metric result of the specified group, counter and thread\n\nGet the metric result of the last measurement cycle. It reads all raw results for the given groupId and threadId.\n@param [in] groupId ID of the group that should be read\n@param [in] metricId ID of the metric that should be calculated\n@param [in] threadId ID of the thread/cpu that should be read\n@return The metric result\n*/\nextern double perfmon_getLastMetric(int groupId, int metricId, int threadId) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the number of configured event groups\n\n@return Number of groups\n*/\nextern int perfmon_getNumberOfGroups(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of configured eventSets in group\n\n@param [in] groupId ID of group\n@return Number of eventSets\n*/\nextern int perfmon_getNumberOfEvents(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the accumulated measurement time a group\n\n@param [in] groupId ID of group\n@return Time in seconds the event group was measured\n*/\nextern double perfmon_getTimeOfGroup(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the ID of the currently set up event group\n\n@return Number of active group\n*/\nextern int perfmon_getIdOfActiveGroup(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of threads specified at perfmon_init()\n\n@return Number of threads\n*/\nextern int perfmon_getNumberOfThreads(void) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Set verbosity of LIKWID library\n\n*/\nextern void perfmon_setVerbosity(int verbose) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the event name of the specified group and event\n\nGet the metric name as defined in the performance group file\n@param [in] groupId ID of the group that should be read\n@param [in] eventId ID of the event that should be returned\n@return The event name or NULL in case of failure\n*/\nextern char* perfmon_getEventName(int groupId, int eventId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the counter name of the specified group and event\n\nGet the counter name as defined in the performance group file\n@param [in] groupId ID of the group that should be read\n@param [in] eventId ID of the event of which the counter should be returned\n@return The counter name or NULL in case of failure\n*/\nextern char* perfmon_getCounterName(int groupId, int eventId) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the name group\n\nGet the name of group. Either it is the name of the performance group or \"Custom\"\n@param [in] groupId ID of the group that should be read\n@return The group name or NULL in case of failure\n*/\nextern char* perfmon_getGroupName(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the metric name of the specified group and metric\n\nGet the metric name as defined in the performance group file\n@param [in] groupId ID of the group that should be read\n@param [in] metricId ID of the metric that should be calculated\n@return The metric name or NULL in case of failure\n*/\nextern char* perfmon_getMetricName(int groupId, int metricId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the short informational string of the specified group\n\nReturns the short information string as defined by performance groups or \"Custom\"\nin case of custom event sets\n@param [in] groupId ID of the group that should be read\n@return The short information or NULL in case of failure\n*/\nextern char* perfmon_getGroupInfoShort(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the long descriptive string of the specified group\n\nReturns the long descriptive string as defined by performance groups or NULL\nin case of custom event sets\n@param [in] groupId ID of the group that should be read\n@return The long description or NULL in case of failure\n*/\nextern char* perfmon_getGroupInfoLong(int groupId) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the number of configured metrics for group\n\n@param [in] groupId ID of group\n@return Number of metrics\n*/\nextern int perfmon_getNumberOfMetrics(int groupId) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the last measurement time a group\n\n@param [in] groupId ID of group\n@return Time in seconds the event group was measured the last time\n*/\nextern double perfmon_getLastTimeOfGroup(int groupId) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Read the output file of the Marker API\n@param [in] filename Filename with Marker API results\n@return 0 or negative error number\n*/\nextern int perfmon_readMarkerFile(const char* filename) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Free space for read in Marker API file\n*/\nextern void perfmon_destroyMarkerResults() __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of regions listed in Marker API result file\n\n@return Number of regions\n*/\nextern int perfmon_getNumberOfRegions() __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the groupID of a region\n\n@param [in] region ID of region\n@return Group ID of region\n*/\nextern int perfmon_getGroupOfRegion(int region) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the tag of a region\n@param [in] region ID of region\n@return tag of region\n*/\nextern char* perfmon_getTagOfRegion(int region) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of events of a region\n@param [in] region ID of region\n@return Number of events of region\n*/\nextern int perfmon_getEventsOfRegion(int region) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of metrics of a region\n@param [in] region ID of region\n@return Number of metrics of region\n*/\nextern int perfmon_getMetricsOfRegion(int region) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of threads of a region\n@param [in] region ID of region\n@return Number of threads of region\n*/\nextern int perfmon_getThreadsOfRegion(int region) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the cpulist of a region\n@param [in] region ID of region\n@param [in] count Length of cpulist array\n@param [in,out] cpulist cpulist array\n@return Number of threads of region or count, whatever is lower\n*/\nextern int perfmon_getCpulistOfRegion(int region, int count, int* cpulist)  __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the accumulated measurement time of a region for a thread\n@param [in] region ID of region\n@param [in] thread ID of thread\n@return Measurement time of a region for a thread\n*/\nextern double perfmon_getTimeOfRegion(int region, int thread) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the call count of a region for a thread\n@param [in] region ID of region\n@param [in] thread ID of thread\n@return Call count of a region for a thread\n*/\nextern int perfmon_getCountOfRegion(int region, int thread) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the event result of a region for an event and thread\n@param [in] region ID of region\n@param [in] event ID of event\n@param [in] thread ID of thread\n@return Result of a region for an event and thread\n*/\nextern double perfmon_getResultOfRegionThread(int region, int event, int thread) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the metric result of a region for a metric and thread\n@param [in] region ID of region\n@param [in] metricId ID of metric\n@param [in] threadId ID of thread\n@return Metric result of a region for a thread\n*/\nextern double perfmon_getMetricOfRegionThread(int region, int metricId, int threadId) __attribute__ ((visibility (\"default\") ));\n\n/** @}*/\n\n/*\n################################################################################\n# Performance group related functions\n################################################################################\n*/\n\n/** \\addtogroup PerfGroup performance group module\n *  @{\n */\n\n/*! \\brief The groupInfo data structure describes a performance group\n\nGroups can be either be read in from file or be a group with custom event set. For\nperformance groups commonly all values are set. For groups with custom event set,\nthe fields groupname and shortinfo are set to 'Custom', longinfo is NULL and in\ngeneral the nmetrics value is 0.\n*/\ntypedef struct {\n    char* groupname; /*!< \\brief Name of the group: performance group name or 'Custom' */\n    char* shortinfo; /*!< \\brief Short info string for the group or 'Custom' */\n    int nevents; /*!< \\brief Number of event/counter combinations */\n    char** events; /*!< \\brief List of events */\n    char** counters; /*!< \\brief List of counter registers */\n    int nmetrics; /*!< \\brief Number of metrics */\n    char** metricnames; /*!< \\brief Metric names */\n    char** metricformulas; /*!< \\brief Metric formulas */\n    char* longinfo; /*!< \\brief Descriptive text about the group or empty */\n} GroupInfo;\n\n/*! \\brief Initialize values in GroupInfo struct\n\nInitialize values in GroupInfo struct. The function does NOT allocate the GroupInfo struct\n*/\nint perfgroup_new(GroupInfo* ginfo) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Add a counter and event combination to the group\n\nAdd a counter and event combination to the group.\n@param [in] ginfo GroupInfo struct\n@param [in] counter String with counter name\n@param [in] event String with event name\n@return 0 for success, -EINVAL or -ENOMEM in case of error.\n*/\nint perfgroup_addEvent(GroupInfo* ginfo, char* counter, char* event) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Remove a counter and event combination from a group\n\nRemove a counter and event combination from a group\n@param [in] ginfo GroupInfo struct\n@param [in] counter String with counter name\n*/\nvoid perfgroup_removeEvent(GroupInfo* ginfo, char* counter) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Add a metric to the group\n\nAdd a metric to the group\n@param [in] ginfo GroupInfo struct\n@param [in] mname String with metric name/description\n@param [in] mcalc String with metric formula. No spaces in string.\n@return 0 for success, -EINVAL or -ENOMEM in case of error.\n*/\nint perfgroup_addMetric(GroupInfo* ginfo, char* mname, char* mcalc) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Remove a metric from a group\n\nRemove a metric from a group\n@param [in] ginfo GroupInfo struct\n@param [in] mname String with metric name/description\n*/\nvoid perfgroup_removeMetric(GroupInfo* ginfo, char* mname) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the event string of a group needed for perfmon_addEventSet\n\nGet the event string of a group needed for perfmon_addEventSet\n@param [in] ginfo GroupInfo struct\n@return String with eventset or NULL\n*/\nchar* perfgroup_getEventStr(GroupInfo* ginfo) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the eventset string of a group\n\nReturn the event string of a group\n@param [in] eventStr Eventset string\n*/\nvoid perfgroup_returnEventStr(char* eventStr) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the group name of a group\n\nGet the group name of a group\n@param [in] ginfo GroupInfo struct\n@return String with group name or NULL\n*/\nchar* perfgroup_getGroupName(GroupInfo* ginfo) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Set the group name of a group\n\nSet the group name of a group. String must be zero-terminated\n@param [in] ginfo GroupInfo struct\n@param [in] groupName String with group name\n@return 0 for success, -EINVAL or -ENOMEM in case of error.\n*/\nint perfgroup_setGroupName(GroupInfo* ginfo, char* groupName) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the group name string of a group\n\nReturn the group name string of a group\n@param [in] gname Group name string\n*/\nvoid perfgroup_returnGroupName(char* gname) __attribute__ ((visibility (\"default\") ));\n\n\n/*! \\brief Set the short information string of a group\n\nSet the short information string of a group. String must be zero-terminated\n@param [in] ginfo GroupInfo struct\n@param [in] shortInfo String with short information\n@return 0 for success, -EINVAL or -ENOMEM in case of error.\n*/\nint perfgroup_setShortInfo(GroupInfo* ginfo, char* shortInfo) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the short information string of a group\n\nGet the short information string of a group\n@param [in] ginfo GroupInfo struct\n@return String with short information or NULL\n*/\nchar* perfgroup_getShortInfo(GroupInfo* ginfo) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the short information string of a group\n\nReturn the short information string of a group\n@param [in] sinfo Short information string\n*/\nvoid perfgroup_returnShortInfo(char* sinfo) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Set the long information string of a group\n\nSet the long information string of a group. String must be zero-terminated\n@param [in] ginfo GroupInfo struct\n@param [in] longInfo String with long information\n@return 0 for success, -EINVAL or -ENOMEM in case of error.\n*/\nint perfgroup_setLongInfo(GroupInfo* ginfo, char* longInfo) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the long information string of a group\n\nGet the long information string of a group\n@param [in] ginfo GroupInfo struct\n@return String with long information or NULL\n*/\nchar* perfgroup_getLongInfo(GroupInfo* ginfo) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the long information string of a group\n\nReturn the long information string of a group\n@param [in] linfo Long information string\n*/\nvoid perfgroup_returnLongInfo(char* linfo) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Merge two groups\n\nMerge two groups (group2 into group1).\n@param [in,out] grp1 Group1\n@param [in] grp2 Group2\n@return 0 for success, -EINVAL or -ENOMEM in case of error.\n*/\nint perfgroup_mergeGroups(GroupInfo* grp1, GroupInfo* grp2) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Read group from file\n\nRead group from file\n@param [in] grouppath Base path to all groups\n@param [in] architecture Architecture string (e.g. short_info in cpuid_info)\n@param [in] groupname Group name\n@param [in,out] ginfo Group filled with data from file\n@return 0 for success, -EINVAL or -ENOMEM in case of error.\n*/\nint perfgroup_readGroup(const char* grouppath, const char* architecture, const char* groupname, GroupInfo* ginfo) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Create group from event string\n\nCreate group from event string (list of event:counter(:opts)).\n@param [in] eventStr event string\n@param [in,out] ginfo Group filled with data from event string\n@return 0 for success, -EINVAL or -ENOMEM in case of error.\n*/\nint perfgroup_customGroup(const char* eventStr, GroupInfo* ginfo) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Return group\n\nReturn group (frees internal lists)\n@param [in] ginfo Performance group info\n*/\nvoid perfgroup_returnGroup(GroupInfo* ginfo) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get all groups available in the system (base + user home)\n\nGet all groups available in the system (base + user home)\n@param [in] grouppath Base path to all groups\n@param [in] architecture Architecture string (e.g. short_info in cpuid_info)\n@param [out] groupnames List of group names\n@param [out] groupshort List of groups' short information string\n@param [out] grouplong List of groups' long information string\n@return number of groups, -EINVAL or -ENOMEM in case of error.\n*/\nint perfgroup_getGroups( const char* grouppath, const char* architecture, char*** groupnames, char*** groupshort, char*** grouplong) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return list of all groups\n\nReturn list of all groups\n@param [in] groups Number of groups\n@param [in] groupnames List of group names\n@param [in] groupshort List of groups' short information string\n@param [in] grouplong List of groups' long information string\n*/\nvoid perfgroup_returnGroups(int groups, char** groupnames, char** groupshort, char** grouplong) __attribute__ ((visibility (\"default\") ));\n\n\n\n\n/** @}*/\n\n/*\n################################################################################\n# Time measurements related functions\n################################################################################\n*/\n\n/** \\addtogroup TimerMon Time measurement module\n *  @{\n */\n\n/*! \\brief Struct defining the start and stop time of a time interval\n\\extends TimerData\n*/\ntypedef union\n{\n    uint64_t int64; /*!< \\brief Cycle count in 64 bit */\n    struct {uint32_t lo, hi;} int32; /*!< \\brief Cycle count stored in two 32 bit fields */\n} TscCounter;\n\n/*! \\brief Struct defining the start and stop time of a time interval\n*/\ntypedef struct {\n    TscCounter start; /*!< \\brief Cycles at start */\n    TscCounter stop; /*!< \\brief Cycles at stop */\n} TimerData;\n\n/*! \\brief Initialize timer by retrieving baseline frequency and cpu clock\n*/\nextern void timer_init( void ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the measured interval in seconds\n\n@param [in] time Structure holding the cycle count at start and stop\n@return Time in seconds\n*/\nextern double timer_print( const TimerData* time) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the measured interval in cycles\n\n@param [in] time Structure holding the cycle count at start and stop\n@return Time in cycles\n*/\nextern uint64_t timer_printCycles( const TimerData* time) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Reset values in TimerData\n\n@param [in] time Structure holding the cycle count at start and stop\n*/\nextern void timer_reset( TimerData* time ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the CPU clock determined at timer_init\n\n@return CPU clock\n*/\nextern uint64_t timer_getCpuClock( void ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the current CPU clock read from sysfs\n\n@return CPU clock\n*/\nextern uint64_t timer_getCpuClockCurrent( int cpu_id ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the cycles clock determined at timer_init\n\n@return cycle clock\n*/\nextern uint64_t timer_getCycleClock( void ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Return the baseline CPU clock determined at timer_init\n\n@return Baseline CPU clock\n*/\nextern uint64_t timer_getBaseline( void ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Start time measurement\n\n@param [in,out] time Structure holding the cycle count at start\n*/\nextern void timer_start( TimerData* time ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Stop time measurement\n\n@param [in,out] time Structure holding the cycle count at stop\n*/\nextern void timer_stop ( TimerData* time) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Sleep for specified usecs\n\n@param [in] usec Amount of usecs to sleep\n*/\nextern int timer_sleep(unsigned long usec) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Finalize timer module\n\n*/\nextern void timer_finalize(void) __attribute__ ((visibility (\"default\") ));\n\n/** @}*/\n\n/*\n################################################################################\n# Power measurements related functions\n################################################################################\n*/\n/** \\addtogroup PowerMon Power and Energy monitoring module\n *  @{\n */\n\n/*!\n\\def NUM_POWER_DOMAINS\nAmount of currently supported RAPL domains\n*/\n#define NUM_POWER_DOMAINS 5\n/*! \\brief List of all RAPL domain names\n*/\nextern const char* power_names[NUM_POWER_DOMAINS] __attribute__ ((visibility (\"default\") ));\n\n/*!\n\\def POWER_DOMAIN_SUPPORT_STATUS\nFlag to check in PowerDomain's supportFlag if the status msr registers are available\n*/\n#define POWER_DOMAIN_SUPPORT_STATUS (1ULL<<0)\n/*!\n\\def POWER_DOMAIN_SUPPORT_LIMIT\nFlag to check in PowerDomain's supportFlag if the limit msr registers are available\n*/\n#define POWER_DOMAIN_SUPPORT_LIMIT (1ULL<<1)\n/*!\n\\def POWER_DOMAIN_SUPPORT_POLICY\nFlag to check in PowerDomain's supportFlag if the policy msr registers are available\n*/\n#define POWER_DOMAIN_SUPPORT_POLICY (1ULL<<2)\n/*!\n\\def POWER_DOMAIN_SUPPORT_PERF\nFlag to check in PowerDomain's supportFlag if the perf msr registers are available\n*/\n#define POWER_DOMAIN_SUPPORT_PERF (1ULL<<3)\n/*!\n\\def POWER_DOMAIN_SUPPORT_INFO\nFlag to check in PowerDomain's supportFlag if the info msr registers are available\n*/\n#define POWER_DOMAIN_SUPPORT_INFO (1ULL<<4)\n\n\n/*! \\brief Information structure of CPU's turbo mode\n\\extends PowerInfo\n*/\ntypedef struct {\n    int numSteps; /*!< \\brief Amount of turbo mode steps/frequencies */\n    double* steps; /*!< \\brief List of turbo mode steps */\n} TurboBoost;\n\n/*! \\brief Enum for all supported RAPL domains\n\\extends PowerDomain\n*/\ntypedef enum {\n    PKG = 0, /*!< \\brief PKG domain, mostly one CPU socket/package */\n    PP0 = 1, /*!< \\brief PP0 domain, not clearly defined by Intel */\n    PP1 = 2, /*!< \\brief PP1 domain, not clearly defined by Intel */\n    DRAM = 3, /*!< \\brief DRAM domain, the memory modules */\n    PLATFORM = 4 /*!< \\brief PLATFORM domain, the whole system (if powered through the main board) */\n} PowerType;\n\n/*! \\brief Structure describing an RAPL power domain\n\\extends PowerInfo\n*/\ntypedef struct {\n    PowerType type; /*!< \\brief Identifier which RAPL domain is managed by this struct */\n    uint32_t supportFlags; /*!< \\brief Bitmask which features are supported by the power domain */\n    double energyUnit; /*!< \\brief Multiplier for energy measurements */\n    double tdp; /*!< \\brief Thermal Design Power (maximum amount of heat generated by the CPU) */\n    double minPower; /*!< \\brief Minimal power consumption of the CPU */\n    double maxPower; /*!< \\brief Maximal power consumption of the CPU */\n    double maxTimeWindow; /*!< \\brief Minimal power measurement interval */\n} PowerDomain;\n\n/*! \\brief Information structure of CPU's power measurement facility\n*/\ntypedef struct {\n    double baseFrequency; /*!< \\brief Base frequency of the CPU */\n    double minFrequency; /*!< \\brief Minimal frequency of the CPU */\n    TurboBoost turbo; /*!< \\brief Turbo boost information */\n    int hasRAPL; /*!< \\brief RAPL support flag */\n    double powerUnit; /*!< \\brief Multiplier for power measurements */\n    double timeUnit; /*!< \\brief Multiplier for time information */\n    double uncoreMinFreq; /*!< \\brief Minimal uncore frequency */\n    double uncoreMaxFreq; /*!< \\brief Maximal uncore frequency */\n    uint8_t perfBias; /*!< \\brief Performance energy bias */\n    PowerDomain domains[NUM_POWER_DOMAINS]; /*!< \\brief List of power domains */\n} PowerInfo;\n\n/*! \\brief Power measurement data for start/stop measurements\n*/\ntypedef struct {\n    int domain; /*!< \\brief RAPL domain identifier */\n    uint32_t before; /*!< \\brief Counter state at start */\n    uint32_t after; /*!< \\brief Counter state at stop */\n} PowerData;\n\n/*! \\brief Variable holding the global power information structure */\nextern PowerInfo power_info;\n\n/** \\brief Pointer for exporting the PowerInfo data structure */\ntypedef PowerInfo* PowerInfo_t;\n/** \\brief Pointer for exporting the PowerData data structure */\ntypedef PowerData* PowerData_t;\n\n/*! \\brief Initialize energy measurements on specific CPU\n\nAdditionally, it reads basic information about the energy measurements like\nminimal measurement time.\n@param [in] cpuId Initialize energy facility for this CPU\n@return RAPL status (0=No RAPL, 1=RAPL working)\n*/\nextern int power_init(int cpuId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get a pointer to the energy facility information\n\n@return PowerInfo_t pointer\n\\sa PowerInfo_t\n*/\nextern PowerInfo_t get_powerInfo(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read the current power value\n\n@param [in] cpuId Read energy facility for this CPU\n@param [in] reg Energy register\n@param [out] data Energy data\n*/\nextern int power_read(int cpuId, uint64_t reg, uint32_t *data) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read the current energy value using a specific communication socket\n\n@param [in] socket_fd Communication socket for the read operation\n@param [in] cpuId Read energy facility for this CPU\n@param [in] reg Energy register\n@param [out] data Energy data\n*/\nextern int power_tread(int socket_fd, int cpuId, uint64_t reg, uint32_t *data) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Start energy measurements\n\n@param [in,out] data Data structure holding start and stop values for energy measurements\n@param [in] cpuId Start energy facility for this CPU\n@param [in] type Which type should be measured\n@return error code\n*/\nextern int power_start(PowerData_t data, int cpuId, PowerType type) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Stop energy measurements\n\n@param [in,out] data Data structure holding start and stop values for energy measurements\n@param [in] cpuId Start energy facility for this CPU\n@param [in] type Which type should be measured\n@return error code\n*/\nextern int power_stop(PowerData_t data, int cpuId, PowerType type) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Print energy measurements gathered by power_start() and power_stop()\n\n@param [in] data Data structure holding start and stop values for energy measurements\n@return Consumed energy in Joules\n*/\nextern double power_printEnergy(const PowerData* data) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get energy Unit\n\n@param [in] domain RAPL domain ID\n@return Energy unit of the given RAPL domain\n*/\nextern double power_getEnergyUnit(int domain) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the values of the limit register of a domain\nNOT IMPLEMENTED\n\n@param [in] cpuId CPU ID\n@param [in] domain RAPL domain ID\n@param [out] power Energy limit\n@param [out] time Time limit\n@return error code\n*/\nint power_limitGet(int cpuId, PowerType domain, double* power, double* time) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Set the values of the limit register of a domain\nNOT IMPLEMENTED\n\n@param [in] cpuId CPU ID\n@param [in] domain RAPL domain ID\n@param [in] power Energy limit\n@param [in] time Time limit\n@param [in] doClamping Activate clamping (going below OS-requested power level)\n@return error code\n*/\nint power_limitSet(int cpuId, PowerType domain, double power, double time, int doClamping) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the state of a energy limit, activated or deactivated\nNOT IMPLEMENTED\n\n@param [in] cpuId CPU ID\n@param [in] domain RAPL domain ID\n@return state, 1 for active, 0 for inactive\n*/\nint power_limitState(int cpuId, PowerType domain) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Free space of power_unit\n*/\nextern void power_finalize(void) __attribute__ ((visibility (\"default\") ));\n/** @}*/\n\n/*\n################################################################################\n# Thermal measurements related functions\n################################################################################\n*/\n/** \\addtogroup ThermalMon Thermal monitoring module\n *  @{\n */\n/*! \\brief Initialize thermal measurements on specific CPU\n\n@param [in] cpuId Initialize thermal facility for this CPU\n*/\nextern void thermal_init(int cpuId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read the current thermal value\n\n@param [in] cpuId Read thermal facility for this CPU\n@param [out] data Thermal data\n*/\nextern int thermal_read(int cpuId, uint32_t *data) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read the current thermal value using a specific communication socket\n\n@param [in] socket_fd Communication socket for the read operation\n@param [in] cpuId Read thermal facility for this CPU\n@param [out] data Thermal data\n*/\nextern int thermal_tread(int socket_fd, int cpuId, uint32_t *data) __attribute__ ((visibility (\"default\") ));\n/** @}*/\n\n\n/*\n################################################################################\n# Memory sweeping related functions\n################################################################################\n*/\n/** \\addtogroup MemSweep Memory sweeping module\n *  @{\n */\n/*! \\brief Sweeping the memory of a NUMA node\n\nSweeps (zeros) the memory of NUMA node with ID \\a domainId\n@param [in] domainId NUMA node ID\n*/\nextern void memsweep_domain(int domainId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Sweeping the memory of all NUMA nodes covered by CPU list\n\nSweeps (zeros) the memory of all NUMA nodes containing the CPUs in \\a processorList\n@param [in] processorList List of CPU IDs\n@param [in] numberOfProcessors Number of CPUs in list\n*/\nextern void memsweep_threadGroup(const int* processorList, int numberOfProcessors) __attribute__ ((visibility (\"default\") ));\n/** @}*/\n\n/*\n################################################################################\n# CPU feature related functions\n################################################################################\n*/\n/** \\addtogroup CpuFeatures Retrieval and manipulation of processor features\n *  @{\n */\n/*! \\brief Enumeration of all CPU related features.\n*/\ntypedef enum {\n    FEAT_HW_PREFETCHER=0, /*!< \\brief Hardware prefetcher */\n    FEAT_CL_PREFETCHER, /*!< \\brief Adjacent cache line prefetcher */\n    FEAT_DCU_PREFETCHER, /*!< \\brief DCU L1 data cache prefetcher */\n    FEAT_IP_PREFETCHER, /*!< \\brief IP L1 data cache prefetcher */\n    FEAT_FAST_STRINGS, /*!< \\brief Fast-strings feature */\n    FEAT_THERMAL_CONTROL, /*!< \\brief Automatic Thermal Control Circuit */\n    FEAT_PERF_MON, /*!< \\brief Hardware performance monitoring */\n    FEAT_FERR_MULTIPLEX, /*!< \\brief FERR# Multiplexing, must be 1 for XAPIC interrupt model */\n    FEAT_BRANCH_TRACE_STORAGE, /*!< \\brief Branch Trace Storage */\n    FEAT_XTPR_MESSAGE, /*!< \\brief xTPR Message to set processor priority */\n    FEAT_PEBS, /*!< \\brief Precise Event Based Sampling (PEBS) */\n    FEAT_SPEEDSTEP, /*!< \\brief Enhanced Intel SpeedStep Technology to reduce energy consumption*/\n    FEAT_MONITOR, /*!< \\brief MONITOR/MWAIT feature to monitor write-back stores*/\n    FEAT_SPEEDSTEP_LOCK, /*!< \\brief Enhanced Intel SpeedStep Technology Select Lock */\n    FEAT_CPUID_MAX_VAL, /*!< \\brief Limit CPUID Maxval */\n    FEAT_XD_BIT, /*!< \\brief Execute Disable Bit */\n    FEAT_DYN_ACCEL, /*!< \\brief Intel Dynamic Acceleration */\n    FEAT_TURBO_MODE, /*!< \\brief Intel Turbo Mode */\n    FEAT_TM2, /*!< \\brief Thermal Monitoring 2 */\n    CPUFEATURES_MAX\n} CpuFeature;\n\n/*! \\brief Initialize the internal feature variables for all CPUs\n\nInitialize the internal feature variables for all CPUs\n*/\nextern void cpuFeatures_init() __attribute__ ((visibility (\"default\") ));\n/*! \\brief Print state of all CPU features for a given CPU\n\nPrint state of all CPU features for a given CPU\n@param [in] cpu CPU ID\n*/\nextern void cpuFeatures_print(int cpu) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get state of a CPU feature for a given CPU\n\nGet state of a CPU feature for a given CPU\n@param [in] cpu CPU ID\n@param [in] type CPU feature\n@return State of CPU feature (1=enabled, 0=disabled)\n*/\nextern int cpuFeatures_get(int cpu, CpuFeature type)  __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the name of a CPU feature\n\nGet the name of a CPU feature\n@param [in] type CPU feature\n@return Name of the CPU feature or NULL if feature is not available\n*/\nextern char* cpuFeatures_name(CpuFeature type)  __attribute__ ((visibility (\"default\") ));\n/*! \\brief Enable a CPU feature for a specific CPU\n\nEnable a CPU feature for a specific CPU. Only the state of the prefetchers can be changed, all other features return -EINVAL\n@param [in] cpu CPU ID\n@param [in] type CPU feature\n@param [in] print Print outcome of operation\n@return Status of operation (0=success, all others are erros, either by MSR access or invalid feature)\n*/\nextern int cpuFeatures_enable(int cpu, CpuFeature type, int print) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Disable a CPU feature for a specific CPU\n\nDisable a CPU feature for a specific CPU. Only the state of the prefetchers can be changed, all other features return -EINVAL\n@param [in] cpu CPU ID\n@param [in] type CPU feature\n@param [in] print Print outcome of operation\n@return Status of operation (0=success, all others are erros, either by MSR access or invalid feature)\n*/\nextern int cpuFeatures_disable(int cpu, CpuFeature type, int print) __attribute__ ((visibility (\"default\") ));\n/** @}*/\n\n\n/*\n################################################################################\n# CPU frequency related functions\n################################################################################\n*/\n/** \\addtogroup CpuFreq Retrieval and manipulation of processor clock frequencies\n *  @{\n */\n/*! \\brief Initialize cpu frequency module\n\nInitialize cpu frequency module\n@return returns 0 if successfull and 1 if invalid accessmode\n*/\nextern int freq_init(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the current clock frequency of a core\n\nGet the current clock frequency of a core\n@param [in] cpu_id CPU ID\n@return Frequency or 0 in case of errors\n*/\nextern uint64_t freq_getCpuClockCurrent(const int cpu_id ) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the maximal clock frequency of a core\n\nGet the maximal clock frequency of a core\n@param [in] cpu_id CPU ID\n@return Frequency or 0 in case of errors\n*/\nextern uint64_t freq_getCpuClockMax(const int cpu_id ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the maximal available clock frequency of a core\n\nGet the maximal clock frequency of a core\n@param [in] cpu_id CPU ID\n@return Frequency or 0 in case of errors\n*/\nextern uint64_t freq_getConfCpuClockMax(const int cpu_id) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Set the maximal clock frequency of a core\n\nSet the maximal clock frequency of a core\n@param [in] cpu_id CPU ID\n@param [in] freq Frequency in kHz\n@return Frequency or 0 in case of errors\n*/\nextern uint64_t freq_setCpuClockMax(const int cpu_id, const uint64_t freq) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the minimal clock frequency of a core\n\nGet the minimal clock frequency of a core\n@param [in] cpu_id CPU ID\n@return Frequency or 0 in case of errors\n*/\nextern uint64_t freq_getCpuClockMin(const int cpu_id ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the minimal available clock frequency of a core\n\nGet the minimal clock frequency of a core\n@param [in] cpu_id CPU ID\n@return Frequency or 0 in case of errors\n*/\nextern uint64_t freq_getConfCpuClockMin(const int cpu_id) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Set the minimal clock frequency of a core\n\nSet the minimal clock frequency of a core\n@param [in] cpu_id CPU ID\n@param [in] freq Frequency in kHz\n@return Frequency or 0 in case of errors\n*/\nextern uint64_t freq_setCpuClockMin(const int cpu_id, const uint64_t freq) __attribute__ ((visibility (\"default\") ));\n/*! \\brief De/Activate turbo mode for core\n\nDe/Activate turbo mode for core\n@param [in] cpu_id CPU ID\n@param [in] turbo (0=off, 1=on)\n@return 1 or 0 in case of errors\n*/\nextern int freq_setTurbo(const int cpu_id, int turbo) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get state of turbo mode for core\n\nGet state of  turbo mode for core\n@param [in] cpu_id CPU ID\n@return 1=Turbo active or 0=Turbo inactive\n*/\nextern int freq_getTurbo(const int cpu_id) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the frequency governor of a core\n\nGet the frequency governor of a core. The returned string must be freed by the caller.\n@param [in] cpu_id CPU ID\n@return Governor or NULL in case of errors\n*/\nextern char * freq_getGovernor(const int cpu_id ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Set the frequency governor of a core\n\nSet the frequency governor of a core.\n@param [in] cpu_id CPU ID\n@param [in] gov Governor\n@return 1 or 0 in case of errors\n*/\nextern int freq_setGovernor(const int cpu_id, const char* gov) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the available frequencies of a core\n\nGet the available frequencies of a core. The returned string must be freed by the caller.\n@param [in] cpu_id CPU ID\n@return String with available frequencies or NULL in case of errors\n*/\nextern char * freq_getAvailFreq(const int cpu_id ) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the available frequency governors of a core\n\nGet the available frequency governors of a core. The returned string must be freed by the caller.\n@param [in] cpu_id CPU ID\n@return String with available frequency governors or NULL in case of errors\n*/\nextern char * freq_getAvailGovs(const int cpu_id ) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Set the minimal Uncore frequency\n\nSet the minimal Uncore frequency. Since the ranges are not documented, valid frequencies are from minimal CPU clock to maximal Turbo clock. If selecting a frequency at the borders, please check the result with the UNCORE_CLOCK event to be effective.\n@param [in] socket_id ID of socket\n@param [in] freq Frequency in MHz\n@return 0 for success, -ERROR at failure\n*/\nextern int freq_setUncoreFreqMin(const int socket_id, const uint64_t freq) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the minimal Uncore frequency\n\nGet the minimal Uncore frequency.\n@param [in] socket_id ID of socket\n@return frequency in MHz or 0 at failure\n*/\nextern uint64_t freq_getUncoreFreqMin(const int socket_id) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Set the maximal Uncore frequency\n\nSet the maximal Uncore frequency. Since the ranges are not documented, valid frequencies are from minimal CPU clock to maximal Turbo clock. If selecting a frequency at the borders, please check the result with the UNCORE_CLOCK event to be effective.\n@param [in] socket_id ID of socket\n@param [in] freq Frequency in MHz\n@return 0 for success, -ERROR at failure\n*/\nextern int freq_setUncoreFreqMax(const int socket_id, const uint64_t freq) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the maximal Uncore frequency\n\nGet the maximal Uncore frequency.\n@param [in] socket_id ID of socket\n@return frequency in MHz or 0 at failure\n*/\nextern uint64_t freq_getUncoreFreqMax(const int socket_id) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the current Uncore frequency\n\nGet the current Uncore frequency.\n@param [in] socket_id ID of socket\n@return frequency in MHz or 0 at failure\n*/\nextern uint64_t freq_getUncoreFreqCur(const int socket_id) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Finalize cpu frequency module\n\nFinalize cpu frequency module\n*/\nextern void freq_finalize(void) __attribute__ ((visibility (\"default\") ));\n/** @}*/\n\n\n/*\n################################################################################\n# Performance monitoring for NVIDIA GPUs related functions\n################################################################################\n*/\n/** \\addtogroup Nvmon Performance monitoring for NVIDIA GPUs\n *  @{\n */\n\n#if defined(LIKWID_WITH_NVMON) || defined(LIKWID_NVMON)\n/*! \\brief Structure with general GPU information for each device\n\nGeneral information covers GPU devid, name and clock and memory specific information.\nMost information comes from cuDeviceGetProperties() and cuDeviceGetAttribute().\n*/\ntypedef struct {\n    int devid; /*!< \\brief Device ID  */\n    int numaNode; /*!< \\brief Closest NUMA domain to the device */\n    char* name; /*!< \\brief Name of the device */\n    uint64_t mem; /*!< \\brief Total memory of device */\n    int ccapMajor; /*!< \\brief Major number of device's compute capability */\n    int ccapMinor; /*!< \\brief Minor number of device's compute capability */\n    int maxThreadsPerBlock; /*!< \\brief Maximam number of thread per block */\n    int maxThreadsDim[3]; /*!< \\brief Maximum sizes of each dimension of a block */\n    int maxGridSize[3]; /*!< \\brief Maximum sizes of each dimension of a grid */\n    int sharedMemPerBlock; /*!< \\brief Total amount of shared memory available per block */\n    int totalConstantMemory; /*!< \\brief Total amount of constant memory available on the device */\n    int simdWidth; /*!< \\brief SIMD width of arithmetic units = warp size */\n    int memPitch; /*!< \\brief Maximum pitch allowed by the memory copy functions that involve memory regions allocated through cuMemAllocPitch() */\n    int regsPerBlock; /*!< \\brief Total number of registers available per block */\n    int clockRatekHz; /*!< \\brief Clock frequency in kilohertz */\n    int textureAlign; /*!< \\brief Alignment requirement */\n    int surfaceAlign; /*!< \\brief Alignment requirement for surfaces */\n    int l2Size; /*!< \\brief L2 cache in bytes. 0 if the device doesn't have L2 cache */\n    int memClockRatekHz; /*!< \\brief Peak memory clock frequency in kilohertz */\n    int pciBus; /*!< \\brief PCI bus identifier of the device */\n    int pciDev; /*!< \\brief PCI device (also known as slot) identifier of the device */\n    int pciDom; /*!< \\brief PCI domain identifier of the device */\n    int maxBlockRegs; /*!< \\brief Maximum number of 32-bit registers available to a thread block */\n    int numMultiProcs; /*!< \\brief Number of multiprocessors on the device */\n    int maxThreadPerMultiProc; /*!< \\brief Maximum resident threads per multiprocessor */\n    int memBusWidth; /*!< \\brief Global memory bus width in bits */\n    int unifiedAddrSpace; /*!< \\brief 1 if the device shares a unified address space with the host, or 0 if not */\n    int ecc; /*!< \\brief 1 if error correction is enabled on the device, 0 if error correction is disabled or not supported by the device */\n    int asyncEngines; /*!< \\brief Number of asynchronous engines */\n    int mapHostMem; /*!< \\brief 1 if the device can map host memory into the CUDA address space */\n    int integrated; /*!< \\brief 1 if the device is an integrated (motherboard) GPU and 0 if it is a discrete (card) component */\n} GpuDevice;\n\n\n/*! \\brief Structure holding information of all GPUs\n\n*/\ntypedef struct {\n    int numDevices; /*!< \\brief Number of detected devices */\n    GpuDevice* devices; /*!< \\brief List with GPU-specific topology information */\n} GpuTopology;\n\n/*! \\brief Variable holding the global gpu information structure */\nextern GpuTopology gpuTopology;\n/** \\brief Pointer for exporting the GpuTopology data structure */\ntypedef GpuTopology* GpuTopology_t;\n\n\n/*! \\brief Initialize GPU topology information\n\nReads in the topology information from the CUDA library (if found).\n\\sa GpuTopology_t\n@return 0 or -errno in case of error\n*/\nextern int topology_gpu_init(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Destroy GPU topology structure GpuTopology_t\n\nRetrieved pointers to the structures are not valid anymore after this function call\n\\sa GpuTopology_t\n*/\nextern void topology_gpu_finalize(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Retrieve GPU topology of the current machine\n\n\\sa GpuTopology_t\n@return GpuTopology_t (pointer to internal gpuTopology structure)\n*/\nextern GpuTopology_t get_gpuTopology(void) __attribute__ ((visibility (\"default\") ));\n\n\n/*\n################################################################################\n# NvMarker API related functions\n################################################################################\n*/\n/** \\addtogroup NvMarkerAPI Marker API module for GPUs\n*  @{\n*/\n/*! \\brief Initialize NvLIKWID's marker API\n\nMust be called in serial region of the application to set up basic data structures\nof LIKWID.\nReads environment variables:\n- LIKWID_GEVENTS (GPU event string)\n- LIKWID_GPUS (GPU list separated by ,)\n- LIKWID_GPUFILEPATH (Outputpath for NvMarkerAPI file)\n*/\nextern void likwid_gpuMarkerInit(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Select next group to measure\n\nMust be called in parallel region of the application to switch group on every CPU.\n*/\nextern void likwid_gpuMarkerNextGroup(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Close LIKWID's NvMarker API\n\nMust be called in serial region of the application. It gathers all data of regions and\nwrites them out to a file (filepath in env variable LIKWID_FILEPATH).\n*/\nextern void likwid_gpuMarkerClose(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Register a measurement region\n\nInitializes the hashTable entry in order to reduce execution time of likwid_gpuMarkerStartRegion()\n@param regionTag [in] Initialize data using this string\n@return Error code\n*/\nextern int likwid_gpuMarkerRegisterRegion(const char* regionTag) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Start a measurement region\n\nReads the values of all configured counters and saves the results under the name given\nin regionTag.\n@param regionTag [in] Store data using this string\n@return Error code of start operation\n*/\nextern int likwid_gpuMarkerStartRegion(const char* regionTag) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Stop a measurement region\n\nReads the values of all configured counters and saves the results under the name given\nin regionTag. The measurement data of the stopped region gets summed up in global region counters.\n@param regionTag [in] Store data using this string\n@return Error code of stop operation\n*/\nextern int likwid_gpuMarkerStopRegion(const char* regionTag) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Reset a measurement region\n\nReset the values of all configured counters and timers.\n@param regionTag [in] Reset data using this string\n@return Error code of reset operation\n*/\nextern int likwid_gpuMarkerResetRegion(const char* regionTag) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get accumulated data of a code region\n\nGet the accumulated data of the current thread for the given regionTag.\n@param regionTag [in] Print data using this string\n@param nr_gpus [in,out] Length of first dimension of the arrys. Afterwards the actual count of GPUs.\n@param nr_events [in,out] Length of events array\n@param events [out] Events array for the intermediate results\n@param time [out] Accumulated measurement time\n@param count [out] Call count of the code region\n*/\nextern void likwid_gpuMarkerGetRegion(const char* regionTag, int* nr_gpus, int* nr_events, double** events, double **time, int **count) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Read the output file of the NvMarker API\n@param [in] filename Filename with NvMarker API results\n@return 0 or negative error number\n*/\nint nvmon_readMarkerFile(const char* filename) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Free space for read in NvMarker API file\n*/\nvoid nvmon_destroyMarkerResults() __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of regions listed in NvMarker API result file\n\n@return Number of regions\n*/\nint nvmon_getNumberOfRegions() __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of metrics of a region\n@param [in] region ID of region\n@return Number of metrics of region\n*/\nint nvmon_getMetricsOfRegion(int region) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of GPUs of a region\n@param [in] region ID of region\n@return Number of GPUs of region\n*/\nint nvmon_getGpusOfRegion(int region) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the GPU list of a region\n@param [in] region ID of region\n@param [in] count Length of gpulist array\n@param [in,out] gpulist gpulist array\n@return Number of GPUs of region or count, whatever is lower\n*/\nint nvmon_getGpulistOfRegion(int region, int count, int* gpulist) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the accumulated measurement time of a region for a GPU\n@param [in] region ID of region\n@param [in] gpu ID of GPU\n@return Measurement time of a region for a GPU\n*/\ndouble nvmon_getTimeOfRegion(int region, int gpu) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the call count of a region for a GPU\n@param [in] region ID of region\n@param [in] gpu ID of GPU\n@return Call count of a region for a GPU\n*/\nint nvmon_getCountOfRegion(int region, int gpu) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the groupID of a region\n\n@param [in] region ID of region\n@return Group ID of region\n*/\nint nvmon_getGroupOfRegion(int region) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the tag of a region\n@param [in] region ID of region\n@return tag of region\n*/\nchar* nvmon_getTagOfRegion(int region) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of events of a region\n@param [in] region ID of region\n@return Number of events of region\n*/\nint nvmon_getEventsOfRegion(int region) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the event result of a region for an event and GPU\n@param [in] region ID of region\n@param [in] eventId ID of event\n@param [in] gpuId ID of GPU\n@return Result of a region for an event and GPU\n*/\ndouble nvmon_getResultOfRegionGpu(int region, int eventId, int gpuId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the metric result of a region for a metric and GPU\n@param [in] region ID of region\n@param [in] metricId ID of metric\n@param [in] gpuId ID of GPU\n@return Metric result of a region for a GPU\n*/\ndouble nvmon_getMetricOfRegionGpu(int region, int metricId, int gpuId) __attribute__ ((visibility (\"default\") ));\n\n/** @}*/\n\n/*\n################################################################################\n# Nvmon related functions (Nvidia GPU monitoring)\n################################################################################\n*/\n\n/** \\addtogroup Nvmon Nvidia GPU monitoring API module for GPUs\n*  @{\n*/\n\n/*! \\brief Element in the output list from nvmon_getEventsOfGpu\n\nIt holds the name, the description and the limitation string for one event.\n*/\ntypedef struct {\n    char* name; /*! \\brief Name of the event */\n    char* desc; /*! \\brief Description of the event */\n    char* limit; /*! \\brief Limitation string of the event, commonly 'GPU' */\n} NvmonEventListEntry;\n\n/*! \\brief Output list from nvmon_getEventsOfGpu with all supported events\n\nOutput list from nvmon_getEventsOfGpu with all supported events\n*/\ntypedef struct {\n    int numEvents; /*! \\brief Number of events */\n    NvmonEventListEntry *events; /*! \\brief List of events */\n} NvmonEventList;\n/** \\brief Pointer for exporting the NvmonEventList data structure */\ntypedef NvmonEventList* NvmonEventList_t;\n\n\n/*! \\brief Get the list of supported event of a GPU\n\n@param [in] gpuId ID of GPU (from GPU topology)\n@param [out] list List of events\n@return Number of supported events or -errno\n*/\nint nvmon_getEventsOfGpu(int gpuId, NvmonEventList_t* list);\n/*! \\brief Return the list of supported event of a GPU\n\nReturn the list of supported event of a GPU from nvmon_getEventsOfGpu()\n@param [in] list List of events\n*/\nvoid nvmon_returnEventsOfGpu(NvmonEventList_t list);\n\n\n/*! \\brief Initialize the Nvidia GPU performance monitoring facility (Nvmon)\n\nInitialize the Nvidia GPU performance monitoring feature by creating basic data structures.\nThe CUDA and CUPTI library paths need to be in LD_LIBRARY_PATH to be found by dlopen.\n\n@param [in] nrGpus Amount of GPUs\n@param [in] gpuIds List of GPUs\n@return error code (0 on success, -ERRORCODE on failure)\n*/\nint nvmon_init(int nrGpus, const int* gpuIds) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Close the Nvidia GPU perfomance monitoring facility of LIKWID (Nvmon)\n\nDeallocates all internal data that is used during Nvmon performance monitoring. Also\nthe counter values are not accessible anymore after calling this function.\n*/\nvoid nvmon_finalize(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Add an event string to LIKWID Nvmon\n\nA event string looks like Eventname:Countername,...\nThe eventname and countername are checked if they are available.\n\n@param [in] eventCString Event string\n@return Returns the ID of the new eventSet\n*/\nint nvmon_addEventSet(const char* eventCString) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Setup all Nvmon performance monitoring counters of an eventSet\n\n@param [in] gid (returned from perfmon_addEventSet()\n@return error code (-ENOENT if groupId is invalid and -1 if the counters of one CPU cannot be set up)\n*/\nint nvmon_setupCounters(int gid) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Start Nvmon performance monitoring counters\n\nStart the counters that have been previously set up by nvmon_setupCounters().\nThe counter registered are zeroed before enabling the counters\n@return 0 on success and -(gpuid+1) for error\n*/\nint nvmon_startCounters(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Stop Nvmon performance monitoring counters\n\nStop the counters that have been previously started by nvmon_startCounters().\n@return 0 on success and -(gpuid+1) for error\n*/\nint nvmon_stopCounters(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Read the Nvmon performance monitoring counters on all GPUs\n\nRead the counters that have been previously started by nvmon_startCounters().\n@return 0 on success and -(gpuid+1) for error\n*/\nint nvmon_readCounters(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Switch the active eventSet to a new one (Nvmon)\n\nStops the currently running counters, switches the eventSet by setting up the\ncounters and start the counters.\n@param [in] new_group ID of group that should be switched to.\n@return 0 on success and -(thread_id+1) for error\n*/\nint nvmon_switchActiveGroup(int new_group) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Set verbosity of LIKWID Nvmon library\n\n*/\nvoid nvmon_setVerbosity(int level) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get the results of the specified group, counter and GPU (Nvmon)\n\nGet the result of all measurement cycles.\n@param [in] groupId ID of the group that should be read\n@param [in] eventId ID of the event that should be read\n@param [in] gpuId ID of the GPU that should be read\n@return The counter result\n*/\ndouble nvmon_getResult(int groupId, int eventId, int gpuId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the last results of the specified group, counter and GPU (Nvmon)\n\nGet the result of the last measurement cycle (between start/stop, start/read, read/read or read/top).\n@param [in] groupId ID of the group that should be read\n@param [in] eventId ID of the event that should be read\n@param [in] gpuId ID of the GPU that should be read\n@return The counter result\n*/\ndouble nvmon_getLastResult(int groupId, int eventId, int gpuId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the metric result of the specified group, counter and GPU (Nvmon)\n\nGet the metric result of all measurement cycles. It reads all raw results for the given groupId and gpuId.\n@param [in] groupId ID of the group that should be read\n@param [in] metricId ID of the metric that should be calculated\n@param [in] gpuId ID of the GPU that should be read\n@return The metric result\n*/\ndouble nvmon_getMetric(int groupId, int metricId, int gpuId);\n/*! \\brief Get the last metric result of the specified group, counter and GPU (Nvmon)\n\nGet the metric result of the last measurement cycle. It reads all raw results for the given groupId and gpuId.\n@param [in] groupId ID of the group that should be read\n@param [in] metricId ID of the metric that should be calculated\n@param [in] gpuId ID of the GPU that should be read\n@return The metric result\n*/\ndouble nvmon_getLastMetric(int groupId, int metricId, int gpuId);\n/*! \\brief Get the number of configured event groups (Nvmon)\n\n@return Number of groups\n*/\nint nvmon_getNumberOfGroups(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the ID of the currently set up event group (Nvmon)\n\n@return Number of active group\n*/\nint nvmon_getIdOfActiveGroup(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of GPUs specified at nvmon_init() (Nvmon)\n\n@return Number of GPUs\n*/\nint nvmon_getNumberOfGPUs(void) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of configured eventSets in group (Nvmon)\n\n@param [in] groupId ID of group\n@return Number of eventSets\n*/\nint nvmon_getNumberOfEvents(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the number of configured metrics for group (Nvmon)\n\n@param [in] groupId ID of group\n@return Number of metrics\n*/\nint nvmon_getNumberOfMetrics(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the accumulated measurement time a group (Nvmon)\n\n@param [in] groupId ID of group\n@return Time in seconds the event group was measured\n*/\ndouble nvmon_getTimeOfGroup(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the last measurement time a group (Nvmon)\n\n@param [in] groupId ID of group\n@return Time in seconds the event group was measured the last time\n*/\ndouble nvmon_getLastTimeOfGroup(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the event name of the specified group and event (Nvmon)\n\nGet the metric name as defined in the performance group file\n@param [in] groupId ID of the group that should be read\n@param [in] eventId ID of the event that should be returned\n@return The event name or NULL in case of failure\n*/\nchar* nvmon_getEventName(int groupId, int eventId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the counter name of the specified group and event (Nvmon)\n\nGet the counter name as defined in the performance group file\n@param [in] groupId ID of the group that should be read\n@param [in] eventId ID of the event of which the counter should be returned\n@return The counter name or NULL in case of failure\n*/\nchar* nvmon_getCounterName(int groupId, int eventId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the metric name of the specified group and metric (Nvmon)\n\nGet the metric name as defined in the performance group file\n@param [in] groupId ID of the group that should be read\n@param [in] metricId ID of the metric that should be calculated\n@return The metric name or NULL in case of failure\n*/\nchar* nvmon_getMetricName(int groupId, int metricId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the name group (Nvmon)\n\nGet the name of group. Either it is the name of the performance group or \"Custom\"\n@param [in] groupId ID of the group that should be read\n@return The group name or NULL in case of failure\n*/\nchar* nvmon_getGroupName(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the short informational string of the specified group (Nvmon)\n\nReturns the short information string as defined by performance groups or \"Custom\"\nin case of custom event sets\n@param [in] groupId ID of the group that should be read\n@return The short information or NULL in case of failure\n*/\nchar* nvmon_getGroupInfoShort(int groupId) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Get the long descriptive string of the specified group (Nvmon)\n\nReturns the long descriptive string as defined by performance groups or NULL\nin case of custom event sets\n@param [in] groupId ID of the group that should be read\n@return The long description or NULL in case of failure\n*/\nchar* nvmon_getGroupInfoLong(int groupId) __attribute__ ((visibility (\"default\") ));\n\n/*! \\brief Get all groups (Nvmon)\n\nChecks the configured performance group path for the current GPU and\nreturns all found group names\n@return Amount of found performance groups\n*/\nint nvmon_getGroups(char*** groups, char*** shortinfos, char*** longinfos) __attribute__ ((visibility (\"default\") ));\n/*! \\brief Free all group information (Nvmon)\n\n@param [in] nrgroups Number of groups\n@param [in] groups List of group names\n@param [in] shortinfos List of short information string about group\n@param [in] longinfos List of long information string about group\n*/\nint nvmon_returnGroups(int nrgroups, char** groups, char** shortinfos, char** longinfos) __attribute__ ((visibility (\"default\") ));\n\n\n\n/** @}*/\n\n#endif /* LIKWID_WITH_NVMON */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /*LIKWID_H*/\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.0-wsmvcyg57s3cluiv7iuyeyprx4ea4ctz/spack-src/doc/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.0-wsmvcyg57s3cluiv7iuyeyprx4ea4ctz/spack-src/doc/likwid-logo-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.0-wsmvcyg57s3cluiv7iuyeyprx4ea4ctz/spack-src/doc/likwid-logo.png"
    ],
    "total_files": 1402
}