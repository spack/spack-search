{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/configure.in": "dnl -*- sh -*-\ndnl the \"configure\" script is made from this by running GNU \"autoconf\"\ndnl\ndnl \"$Id: configure.in 10418 2014-10-30 14:07:58Z AlbrechtS $\"\ndnl\ndnl Configuration script for the Fast Light Tool Kit (FLTK).\ndnl\ndnl Copyright 1998-2014 by Bill Spitzak and others.\ndnl\ndnl This library is free software. Distribution and use rights are outlined in\ndnl the file \"COPYING\" which should have been included with this file.  If this\ndnl file is missing or damaged, see the license at:\ndnl\ndnl     http://www.fltk.org/COPYING.php\ndnl\ndnl Please report all bugs and problems on the following page:\ndnl\ndnl      http://www.fltk.org/str.php\ndnl\n\ndnl We need at least autoconf 2.50...\nAC_PREREQ(2.50)\n\ndnl Required file in package...\nAC_INIT(src/Fl.cxx)\n\nAC_CANONICAL_HOST\n\ndnl Do not automatically add \"-g\" to compiler options...\ndnl This must be _before_ \"Find compiler commands...\"\nARCHFLAGS=\"${ARCHFLAGS:=}\"\nCFLAGS=\"${CFLAGS:=}\"\nCPPFLAGS=\"${CPPFLAGS:=}\"\nCXXFLAGS=\"${CXXFLAGS:=}\"\nDSOFLAGS=\"${DSOFLAGS:=}\"\nLDFLAGS=\"${LDFLAGS:=}\"\nOPTIM=\"${OPTIM:=}\"\n\ndnl Find compiler commands...\nAC_PROG_CC\nAC_PROG_CXX\n\ndnl So --with-archflags option is used during \"checking size of long\"\ncase $host_os in\n    darwin*)\n        if test \"x$with_archflags\" != x ; then\n            CFLAGS=\"$CFLAGS $with_archflags\"\n        fi\n        USEMMFILES=\"Yes\"\n        ;;\n    *)\n        USEMMFILES=\"No\"\n        ;;\nesac\nAC_SUBST(USEMMFILES)\n\ndnl FLTK library versions...\nFL_MAJOR_VERSION=1\nFL_MINOR_VERSION=3\nFL_PATCH_VERSION=3\nFL_API_VERSION=${FL_MAJOR_VERSION}.${FL_MINOR_VERSION}\n\nAC_SUBST(FL_MAJOR_VERSION)\nAC_SUBST(FL_MINOR_VERSION)\nAC_SUBST(FL_PATCH_VERSION)\nAC_SUBST(FL_API_VERSION)\n\nAC_SUBST(ARCHFLAGS)\nAC_SUBST(OPTIM)\n\ndnl OS-specific pre-tests...\ndnl host_os_gui equals $host_os unless we target Cygwin in combination with X11.\nhost_os_gui=$host_os\ncase $host_os in\n    cygwin*)\n        # Handle Cygwin option *first*, before all other tests.\n\tAC_ARG_ENABLE(cygwin, [  --enable-cygwin         use the Cygwin libraries [[default=no]]])\n\tAC_ARG_ENABLE(x11,    [  --enable-x11            use Cygwin with X11 [[default=no]]])\n\tif test x$enable_cygwin = xyes; then\n\t    # we target Cygwin in combination with X11\n\t    if test x$enable_x11 = xyes; then\n\t\thost_os_gui=\"X11$host_os\"\n\t    fi\n\tfi\n\t;;\nesac\n\ndnl Define the libraries and link options we will need.\nLINKFLTK=\"../lib/libfltk.a\"\nLINKFLTKFORMS=\"../lib/libfltk_forms.a\"\nLINKFLTKGL=\"../lib/libfltk_gl.a\"\nLINKFLTKIMG=\"../lib/libfltk_images.a\"\nGLDEMOS=\"gldemos\"\n\nLIBEXT=\".a\"\nLIBNAME=\"../lib/libfltk.a\"\nFLLIBNAME=\"../lib/libfltk_forms.a\"\nGLLIBNAME=\"../lib/libfltk_gl.a\"\nIMGLIBNAME=\"../lib/libfltk_images.a\"\nCAIROLIBNAME=\"../lib/libfltk_cairo.a\"\n\nLIBBASENAME=\"libfltk.a\"\nFLLIBBASENAME=\"libfltk_forms.a\"\nGLLIBBASENAME=\"libfltk_gl.a\"\nIMGLIBBASENAME=\"libfltk_images.a\"\nCAIROLIBBASENAME=\"libfltk_cairo.a\"\n\ndnl Check for Cairo library unless disabled...\nCAIRODIR=\"\"\nCAIROFLAGS=\"\"\nLINKFLTKCAIRO=\"\"\nFLTKCAIROOPTION=\"\"\nCAIROLIBS=\"\"\n\nAC_ARG_ENABLE(cairoext,[  --enable-cairoext       use fltk code instrumentation for cairo extended use [[default=no]]])\nAC_ARG_ENABLE(cairo,   [  --enable-cairo          use lib Cairo [[default=no]]])\n\nif test x$enable_cairoext = xyes; then\n\t  AC_DEFINE(FLTK_USE_CAIRO)\n\t  AC_DEFINE(FLTK_HAVE_CAIRO)\n\t  dnl FIXME This part should be fixed so configure do not depend on\n\t  dnl we do not rely on pkg-config .\n\t  CAIRODIR=\"cairo\"\n          CAIROFLAGS=\"`pkg-config --cflags cairo`\"\n          CAIROLIBS=\"-lcairo -lpixman-1\"\n          CXXFLAGS=\"$CAIROFLAGS $CXXFLAGS\"\n\t  LINKFLTKCAIRO=\"../lib/libfltk_cairo.a\"\n\t  FLTKCAIROOPTION=\"-L ../cairo -lfltk_cairo$SHAREDSUFFIX\"\n\t  LIBS=\"$CAIROLIBS $LIBS\" \n\t  dnl $LINKFLTKCAIRO \n\t  LINKFLTK+=\" $LINKFLTKCAIRO\"\nelse \n    if test x$enable_cairo = xyes; then\n\t  AC_DEFINE(FLTK_HAVE_CAIRO)\n\t  dnl FIXME This part should be fixed so configure do not depend on\n\t  dnl we do not rely on pkg-config .\n\t  CAIRODIR=\"cairo\"\n          CAIROFLAGS=\"`pkg-config --cflags cairo`\"\n          CAIROLIBS=\"-lcairo -lpixman-1\"\n          CXXFLAGS=\"$CAIROFLAGS $CXXFLAGS\"\n\t  LINKFLTKCAIRO=\"../lib/libfltk_cairo.a\"\n\t  FLTKCAIROOPTION=\"-L ../cairo -lfltk_cairo$SHAREDSUFFIX\"\n    fi\nfi\n\nAC_SUBST(CAIRODIR)\nAC_SUBST(CAIROFLAGS)\nAC_SUBST(CAIROLIBS)\nAC_SUBST(LINKFLTKCAIRO)\nAC_SUBST(FLTKCAIROOPTION)\n\n\nAC_SUBST(FLLIBNAME)\nAC_SUBST(GLDEMOS)\nAC_SUBST(GLLIBNAME)\nAC_SUBST(IMGLIBNAME)\nAC_SUBST(CAIROLIBNAME)\nAC_SUBST(LIBEXT)\nAC_SUBST(LIBNAME)\nAC_SUBST(LINKFLTK)\nAC_SUBST(LINKFLTKFORMS)\nAC_SUBST(LINKFLTKGL)\nAC_SUBST(LINKFLTKIMG)\n\nAC_SUBST(LIBBASENAME)\nAC_SUBST(FLLIBBASENAME)\nAC_SUBST(GLLIBBASENAME)\nAC_SUBST(IMGLIBBASENAME)\nAC_SUBST(CAIROLIBBASENAME)\n\ndnl Handle compile-time options...\nAC_ARG_ENABLE(debug, [  --enable-debug          turn on debugging [[default=no]]])\nif test x$enable_debug = xyes; then\n    DEBUGFLAG=\"-g \"\nelse\n    DEBUGFLAG=\"\"\nfi\n\nAC_ARG_ENABLE(cp936, [  --enable-cp936          turn on CP936 [[default=no]]])\nif test x$enable_cp936 = xyes; then\n    CFLAGS=\"$CFLAGS -DCP936\"\nfi\n\n\nAC_ARG_ENABLE(gl, [  --enable-gl             turn on OpenGL support [[default=yes]]])\n\nAC_ARG_ENABLE(shared, [  --enable-shared         turn on shared libraries [[default=no]]])\nif test x$enable_shared = xyes; then\n    PICFLAG=1\n    SHAREDSUFFIX=\"\"\n    FLUID=\"fluid-shared\"\n\n    case $host_os in\n\tdarwin*)\n            DSONAME=\"libfltk.$FL_API_VERSION.dylib\"\n            FLDSONAME=\"libfltk_forms.$FL_API_VERSION.dylib\"\n            GLDSONAME=\"libfltk_gl.$FL_API_VERSION.dylib\"\n            IMGDSONAME=\"libfltk_images.$FL_API_VERSION.dylib\"\n            CAIRODSONAME=\"libfltk_cairo.$FL_API_VERSION.dylib\"\n\t    DSOCOMMAND=\"\\$(CXX) \\$(ARCHFLAGS) \\$(DSOFLAGS) -dynamiclib -lc -o\"\n\t    ;;\n\n\tsolaris*)\n            DSONAME=\"libfltk.so.$FL_API_VERSION\"\n            FLDSONAME=\"libfltk_forms.so.$FL_API_VERSION\"\n            GLDSONAME=\"libfltk_gl.so.$FL_API_VERSION\"\n            IMGDSONAME=\"libfltk_images.so.$FL_API_VERSION\"\n            CAIRODSONAME=\"libfltk_cairo.so.$FL_API_VERSION\"\n\t    DSOCOMMAND=\"\\$(CXX) \\$(DSOFLAGS) -h \\$@ \\$(LDLIBS) -G $DEBUGFLAG -o\"\n\t    if test \"x$libdir\" != \"x/usr/lib\"; then\n\t\t    DSOLINK=\"-R$libdir\"\n            fi\n\t    ;;\n\thpux*)\n            DSONAME=\"libfltk.sl.$FL_API_VERSION\"\n            FLDSONAME=\"libfltk_forms.sl.$FL_API_VERSION\"\n            GLDSONAME=\"libfltk_gl.sl.$FL_API_VERSION\"\n            IMGDSONAME=\"libfltk_images.sl.$FL_API_VERSION\"\n            CAIRODSONAME=\"libfltk_cairo.sl.$FL_API_VERSION\"\n\t    DSOCOMMAND=\"ld \\$(DSOFLAGS) -b -z +h \\$@ $DEBUGFLAG -o\"\n\t    if test \"x$libdir\" != \"x/usr/lib\"; then\n\t\t    DSOLINK=\"-Wl,-rpath,$libdir\"\n            fi\n\t    ;;\n\tirix*)\n            DSONAME=\"libfltk.so.$FL_API_VERSION\"\n            FLDSONAME=\"libfltk_forms.so.$FL_API_VERSION\"\n            GLDSONAME=\"libfltk_gl.so.$FL_API_VERSION\"\n            IMGDSONAME=\"libfltk_images.so.$FL_API_VERSION\"\n            CAIRODSONAME=\"libfltk_cairo.so.$FL_API_VERSION\"\n            DSOCOMMAND=\"\\$(CXX) \\$(DSOFLAGS) -Wl,-soname,\\$@,-set_version,sgi1.1 \\$(LDLIBS) -shared $DEBUGFLAG -o\"\n\t    if test \"x$libdir\" != \"x/usr/lib\" -a \"x$libdir\" != \"x/usr/lib32\" -a \"x$libdir\" != \"x/usr/lib64\"; then\n\t\t    DSOLINK=\"-Wl,-rpath,$libdir\"\n            fi\n\t    ;;\n\tosf*)\n            DSONAME=\"libfltk.so.$FL_API_VERSION\"\n            FLDSONAME=\"libfltk_forms.so.$FL_API_VERSION\"\n            GLDSONAME=\"libfltk_gl.so.$FL_API_VERSION\"\n            IMGDSONAME=\"libfltk_images.so.$FL_API_VERSION\"\n            CAIRODSONAME=\"libfltk_cairo.so.$FL_API_VERSION\"\n            DSOCOMMAND=\"\\$(CXX) \\$(DSOFLAGS) -Wl,-soname,\\$@ \\$(LDLIBS) -shared $DEBUGFLAG -o\"\n\t    if test \"x$libdir\" != \"x/usr/lib\" -a \"x$libdir\" != \"x/usr/lib32\"; then\n\t\t    DSOLINK=\"-Wl,-rpath,$libdir\"\n            fi\n\t    ;;\n\tlinux* | *bsd*)\n            DSONAME=\"libfltk.so.$FL_API_VERSION\"\n            FLDSONAME=\"libfltk_forms.so.$FL_API_VERSION\"\n            GLDSONAME=\"libfltk_gl.so.$FL_API_VERSION\"\n            IMGDSONAME=\"libfltk_images.so.$FL_API_VERSION\"\n            CAIRODSONAME=\"libfltk_cairo.so.$FL_API_VERSION\"\n            DSOCOMMAND=\"\\$(CXX) \\$(DSOFLAGS) -Wl,-soname,\\$@ \\$(LDLIBS) -shared -fPIC $DEBUGFLAG -o\"\n\n            # See if the compiler supports -fvisibility...\n            AC_CACHE_CHECK([if the compiler supports -fvisibility],\n                ac_cv_cxx_fvisibility, [\n                    OLDCXXFLAGS=\"$CXXFLAGS\"\n                    CXXFLAGS=\"$CXXFLAGS -fvisibility=hidden\"\n                    AC_LANG_SAVE\n                    AC_LANG_CPLUSPLUS\n                    AC_TRY_COMPILE(,,\n                        ac_cv_cxx_fvisibility=yes,\n                        ac_cv_cxx_fvisibility=no)\n                    CXXFLAGS=\"$OLDCXXFLAGS\"\n                    AC_LANG_RESTORE\n            ])\n            if test x\"$ac_cv_cxx_fvisibility\" = xyes; then\n                OPTIM=\"$OPTIM -fvisibility=hidden\"\n            fi\n\n            # See if the compiler supports -fvisibility-inlines-hidden...\n            AC_CACHE_CHECK([if the compiler supports -fvisibility-inlines-hidden],\n                ac_cv_cxx_fvisibility_inlines, [\n                    OLDCXXFLAGS=\"$CXXFLAGS\"\n                    CXXFLAGS=\"$CXXFLAGS -fvisibility-inlines-hidden\"\n                    AC_LANG_SAVE\n                    AC_LANG_CPLUSPLUS\n                    AC_TRY_COMPILE(,,\n                        ac_cv_cxx_fvisibility_inlines=yes,\n                        ac_cv_cxx_fvisibility_inlines=no)\n                    CXXFLAGS=\"$OLDCXXFLAGS\"\n                    AC_LANG_RESTORE\n            ])\n            if test x\"$ac_cv_cxx_fvisibility_inlines\" = xyes; then\n                CXXFLAGS=\"$CXXFLAGS -fvisibility-inlines-hidden\"\n            fi\n\n\t    if test \"x$libdir\" != \"x/usr/lib\" -a \"x$libdir\" != \"x/usr/lib64\"; then\n\t\t    DSOLINK=\"-Wl,-rpath,$libdir\"\n            fi\n\t    ;;\n\taix*)\n            DSONAME=\"libfltk_s.a\"\n            FLDSONAME=\"libfltk_forms_s.a\"\n            GLDSONAME=\"libfltk_gl_s.a\"\n            IMGDSONAME=\"libfltk_images_s.a\"\n            CAIRODSONAME=\"libfltk_cairo_s.a\"\n            DSOCOMMAND=\"\\$(CXX) \\$(DSOFLAGS) -Wl,-bexpall,-bM:SRE,-bnoentry -o\"\n            SHAREDSUFFIX=\"_s\"\n            ;;\n        cygwin* | mingw*)\n\t    PICFLAG=0\n\t    if test x$enable_cygwin != xyes; then\n\t\tDSONAME=\"mgwfltknox-$FL_API_VERSION.dll\"\n\t\tFLDSONAME=\"mgwfltknox_forms-$FL_API_VERSION.dll\"\n\t\tGLDSONAME=\"mgwfltknox_gl-$FL_API_VERSION.dll\"\n\t\tIMGDSONAME=\"mgwfltknox_images-$FL_API_VERSION.dll\"\n\t\tCAIRODSONAME=\"mgwfltknox_cairo-$FL_API_VERSION.dll\"\n\t    else\n\t\tif test x$enable_x11 = xyes; then\n\t\t    DSONAME=\"cygfltk-$FL_API_VERSION.dll\"\n\t\t    FLDSONAME=\"cygfltk_forms-$FL_API_VERSION.dll\"\n\t\t    GLDSONAME=\"cygfltk_gl-$FL_API_VERSION.dll\"\n\t\t    IMGDSONAME=\"cygfltk_images-$FL_API_VERSION.dll\"\n\t\t    CAIRODSONAME=\"cygfltk_cairo-$FL_API_VERSION.dll\"\n\t\telse\n\t\t    DSONAME=\"cygfltknox-$FL_API_VERSION.dll\"\n\t\t    FLDSONAME=\"cygfltknox_forms-$FL_API_VERSION.dll\"\n\t\t    GLDSONAME=\"cygfltknox_gl-$FL_API_VERSION.dll\"\n\t\t    IMGDSONAME=\"cygfltknox_images-$FL_API_VERSION.dll\"\n\t\t    CAIRODSONAME=\"cygfltknox_cairo-$FL_API_VERSION.dll\"\n\t\tfi\n\t    fi\n\t    #-----------------------------------------------------------\n\t    # -Wl,--enable-runtime-pseudo-reloc: See str 1585\n\t    # appears to be necessary for older binutils versions < 2.16\n\t    #-----------------------------------------------------------\n            LDFLAGS=\"$LDFLAGS -Wl,--enable-auto-import -Wl,--enable-runtime-pseudo-reloc\"\n\t    DSOCOMMAND=\"\\$(CXX) \\$(DSOFLAGS) -shared \\\n\t    \t-Wl,--whole-archive -Wl,--export-all-symbols \\\n\t\t-Wl,--enable-runtime-pseudo-reloc -Wl,--enable-auto-import \\\n\t\t-Wl,--enable-auto-image-base -o \\$@\"\n\t    ;;\n\t*)\n            AC_MSG_WARN(Shared libraries may not be supported.  Trying -shared option with compiler.)\n            DSONAME=\"libfltk.so.$FL_API_VERSION\"\n            FLDSONAME=\"libfltk_forms.so.$FL_API_VERSION\"\n            GLDSONAME=\"libfltk_gl.so.$FL_API_VERSION\"\n            IMGDSONAME=\"libfltk_images.so.$FL_API_VERSION\"\n            CAIRODSONAME=\"libfltk_cairo.so.$FL_API_VERSION\"\n            DSOCOMMAND=\"\\$(CXX) \\$(DSOFLAGS) -Wl,-soname,\\$@ \\$(LDLIBS) -shared $DEBUGFLAG -o\"\n\t    ;;\n    esac\n\n    LINKSHARED=\"-L../src $FLTKCAIROOPTION -lfltk_images$SHAREDSUFFIX -lfltk_forms$SHAREDSUFFIX -lfltk$SHAREDSUFFIX\"\nelse\n    DSOCOMMAND=\"echo\"\n    DSOLINK=\"\"\n    DSONAME=\"\"\n    FLDSONAME=\"\"\n    GLDSONAME=\"\"\n    IMGDSONAME=\"\"\n    CAIRODSONAME=\"\"\n    PICFLAG=0\n    SHAREDSUFFIX=\"\"\n    FLUID=\"fluid\"\n    LINKSHARED=\"$LINKFLTKCAIRO ../lib/libfltk_images.a ../lib/libfltk_forms.a ../lib/libfltk.a\"\nfi\n\nAC_SUBST(DSOCOMMAND)\nAC_SUBST(DSOFLAGS)\nAC_SUBST(DSOLINK)\nAC_SUBST(DSONAME)\nAC_SUBST(FLDSONAME)\nAC_SUBST(GLDSONAME)\nAC_SUBST(IMGDSONAME)\nAC_SUBST(CAIRODSONAME)\nAC_SUBST(SHAREDSUFFIX)\nAC_SUBST(LINKSHARED)\nAC_SUBST(FLUID)\n\nAC_ARG_ENABLE(threads, [  --enable-threads        enable multi-threading support [[default=yes]]])\n\nAC_ARG_WITH(optim, [  --with-optim=\"flags\"    use custom optimization flags])\n\nAC_ARG_WITH(archflags, [  --with-archflags=\"flags\"\n                          use custom architecture flags \n\t\t\t  (possible Mac OS X values include -arch i386, -arch x86_64, -arch ppc)],\n    ARCHFLAGS=\"$withval\")\ncase $host_os in\n    darwin*)\n# QD is not supported anymore since 1.3\n\tAC_DEFINE(__APPLE_QUARTZ__)\n\t;;\nesac\n\ndnl Find commands...\nAC_PROG_INSTALL\ncase $host_os in\n    osf*)\n\tINSTALL=\"`pwd`/install-sh -c\"\n\t;;\nesac\nif test \"$INSTALL\" = \"$ac_install_sh\"; then\n    # Use full path to install-sh script...\n    INSTALL=\"`pwd`/install-sh -c\"\nfi\nAC_PATH_PROG(NROFF,nroff)\nif test \"x$NROFF\" = \"x:\"; then\n    # Try groff instead of nroff...\n    AC_PATH_PROG(GROFF,groff)\n    if test \"x$GROFF\" = \"x:\"; then\n        NROFF=\"echo\"\n    else\n        NROFF=\"$GROFF -T ascii\"\n    fi\nfi\nAC_PATH_PROG(DOXYDOC,doxygen)\n\ndnl How do we make libraries?\nAC_PROG_RANLIB\nAC_PATH_TOOL(AR, ar)\n\nif test \"x$AR\" = \"x:\"; then\n    AC_MSG_ERROR(Configure could not find the library archiver, aborting.)\nfi\n\nif test \"x$RANLIB\" != \"x:\"; then\n    LIBCOMMAND=\"$AR cr\"\nelse\n    LIBCOMMAND=\"$AR crs\"\nfi\n\nAC_SUBST(LIBCOMMAND)\n\ndnl how to compile (Windows) resource files\ndnl this will only be used to compile resources for Windows .exe files\nAC_PATH_TOOL(RC,windres)\n\ndnl Architecture checks...\nAC_CHECK_SIZEOF(short, 2)\nAC_CHECK_SIZEOF(int, 4)\nAC_CHECK_SIZEOF(long, 4)\nif test $ac_cv_sizeof_short -eq 2; then\n    AC_DEFINE(U16,unsigned short)\nfi\nif test $ac_cv_sizeof_int -eq 4; then\n    AC_DEFINE(U32,unsigned)\nelse\n    if test $ac_cv_sizeof_long -eq 4; then\n        AC_DEFINE(U32,unsigned long)\n    fi\nfi\ncase $host_os in\n    darwin*)\n        ;;\n    *)\n        AC_C_BIGENDIAN\n\n\tif test $ac_cv_sizeof_int -eq 8; then\n\t\tAC_DEFINE(U64,unsigned)\n\telse\n\t\tif test $ac_cv_sizeof_long -eq 8; then\n\t\t\tAC_DEFINE(U64,unsigned long)\n\t\tfi\n\tfi\n        ;;\nesac\n\ndnl Does the C++ compiler support the bool type?\nAC_CACHE_CHECK(whether the compiler recognizes bool as a built-in type,\n    ac_cv_cxx_bool,[\n\tAC_LANG_SAVE\n\tAC_LANG_CPLUSPLUS\n\tAC_TRY_COMPILE([\n\t    int f(int  x){return 1;}\n\t    int f(char x){return 1;}\n\t    int f(bool x){return 1;}\n\t],[\n\t    bool b = true;\n\t    return f(b);\n\t], ac_cv_cxx_bool=yes, ac_cv_cxx_bool=no)\n\tAC_LANG_RESTORE\n    ])\n\nif test \"$ac_cv_cxx_bool\" != yes; then\n    CXXFLAGS=\"-Dbool=char -Dfalse=0 -Dtrue=1 $CXXFLAGS\"\nfi\n\ndnl Standard headers and functions...\nAC_HEADER_DIRENT\nAC_CHECK_HEADER(sys/select.h,AC_DEFINE(HAVE_SYS_SELECT_H))\nAC_CHECK_HEADER(sys/stdtypes.h,AC_DEFINE(HAVE_SYS_SELECT_H))\n\ndnl Do we have the POSIX compatible scandir() prototype?\nAC_CACHE_CHECK([whether we have the POSIX compatible scandir() prototype],\n    ac_cv_cxx_scandir_posix,[\n\tAC_LANG_SAVE\n\tAC_LANG_CPLUSPLUS\n\tAC_TRY_COMPILE([\n\t  #include <dirent.h>\n\t  int func (const char *d, dirent ***list, void *sort) {\n\t    int n = scandir(d, list, 0, (int(*)(const dirent **, const dirent **))sort);\n\t  }\n\t],[\n\t], ac_cv_cxx_scandir_posix=yes, ac_cv_cxx_scandir_posix=no)\n\tAC_LANG_RESTORE\n    ])\n\ndnl Define both HAVE_SCANDIR... macros, if the POSIX compatible function is\ndnl available. Otherwise: check, whether any scandir prototype is available,\ndnl but dont use it on SunOS and QNX because of an incompatibility in pre-Y2K\ndnl SunOS scandir versions. We assume, though, that the POSIX compatible\ndnl version on newer SunOS/Solaris versions works as expected.\nif test \"$ac_cv_cxx_scandir_posix\" = yes; then\n    AC_DEFINE(HAVE_SCANDIR)\n    AC_DEFINE(HAVE_SCANDIR_POSIX)\nelse\n    AC_CHECK_FUNC(scandir,[\n        case $host_os in\n            solaris* | *qnx*)\n                AC_MSG_WARN(Not using $host_os scandir emulation function.)\n                ;;\n            *)\n                AC_DEFINE(HAVE_SCANDIR)\n                ;;\n        esac])\nfi\n\nAC_CHECK_FUNC(vsnprintf,[\n    case $host_os in\n        hpux1020)\n            AC_MSG_WARN(Not using built-in vsnprintf function because you are running HP-UX 10.20.)\n            ;;\n        osf4)\n            AC_MSG_WARN(Not using built-in vsnprintf function because you are running Tru64 4.0.)\n            ;;\n        *)\n            AC_DEFINE(HAVE_VSNPRINTF)\n            ;;\n    esac])\nAC_CHECK_FUNC(snprintf,[\n    case $host_os in\n        hpux1020)\n            AC_MSG_WARN(Not using built-in snprintf function because you are running HP-UX 10.20.)\n            ;;\n        osf4)\n            AC_MSG_WARN(Not using built-in snprintf function because you are running Tru64 4.0.)\n            ;;\n        *)\n            AC_DEFINE(HAVE_SNPRINTF)\n            ;;\n    esac])\nAC_CHECK_HEADER(strings.h, AC_DEFINE(HAVE_STRINGS_H))\nAC_CHECK_FUNCS(strcasecmp strlcat strlcpy)\n\nAC_CHECK_HEADER(locale.h, AC_DEFINE(HAVE_LOCALE_H))\nAC_CHECK_FUNCS(localeconv)\n\ndnl FLTK library uses math library functions...\nAC_SEARCH_LIBS(pow, m)\n\ndnl Check for largefile support...\nAC_SYS_LARGEFILE\n\ndnl Define largefile options as needed...\nLARGEFILE=\"\"\nif test x$enable_largefile != xno; then\n\tLARGEFILE=\"-D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE\"\n\n\tif test x$ac_cv_sys_large_files = x1; then\n\t\tLARGEFILE=\"$LARGEFILE -D_LARGE_FILES\"\n\tfi\n\n\tif test x$ac_cv_sys_file_offset_bits = x64; then\n\t\tLARGEFILE=\"$LARGEFILE -D_FILE_OFFSET_BITS=64\"\n\tfi\nfi\nAC_SUBST(LARGEFILE)\n\ndnl Check for \"long long\" support...\nAC_CACHE_CHECK(for long long int, ac_cv_c_long_long,\n\t[if test \"$GCC\" = yes; then\n\t\tac_cv_c_long_long=yes\n\telse\n\t\tAC_TRY_COMPILE(,[long long int i;],\n\t\t\tac_cv_c_long_long=yes,\n\t\t\tac_cv_c_long_long=no)\n\tfi])\n\nif test $ac_cv_c_long_long = yes; then\n\tAC_DEFINE(HAVE_LONG_LONG)\nfi\n\ndnl Check for dlopen/dlsym...\nAC_SEARCH_LIBS(dlsym, dl, AC_DEFINE(HAVE_DLSYM))\nAC_CHECK_HEADER(dlfcn.h, AC_DEFINE(HAVE_DLFCN_H))\n\ndnl Check for audio libraries...\nAUDIOLIBS=\"\"\n\ncase $host_os in\n    cygwin* | mingw*)\n\tdnl Cygwin environment...\n\tAUDIOLIBS=\"-lwinmm\"\n\t;;\n\n    darwin*)\n\tAUDIOLIBS=\"-framework CoreAudio\"\n\t;;\n\n    *)\n\tAC_CHECK_HEADER(alsa/asoundlib.h,\n\t    AC_DEFINE(HAVE_ALSA_ASOUNDLIB_H)\n\t    AUDIOLIBS=\"-lasound\")\n        ;;\nesac\n\nAC_SUBST(AUDIOLIBS)\n\ndnl Check for image libraries...\nSAVELIBS=\"$LIBS\"\nIMAGELIBS=\"\"\nSTATICIMAGELIBS=\"\"\n\nAC_SUBST(IMAGELIBS)\nAC_SUBST(STATICIMAGELIBS)\n\n# Handle the JPEG lib linking mode (use fltk local or system lib)\n# If --enable-(resp. --disable-)localjpeg parameter is not set by user\n# Then we check the JPEG lib usability, with result in sysjpeglib_ok variable\nAC_ARG_ENABLE(localjpeg, [  --enable-localjpeg      use local JPEG library [[default=auto]]])\n# Check for System lib use if automatic mode or --disable-localjpeg is requested\nsysjpeglib_ok=no\nsysjpeginc_ok=no\nif test x$enable_localjpeg != xyes; then\n    AC_CHECK_LIB(jpeg,jpeg_CreateCompress,\n\t[AC_CHECK_HEADER(jpeglib.h,\n\t    sysjpeginc_ok=yes)\n\t    if test x$sysjpeginc_ok = xyes; then\n\t\tsysjpeglib_ok=yes\n\t\tfi])\nfi\n# Now set the jpeg lib and include flags according to the requested mode and availability \nif test x$enable_localjpeg = xyes -o x$sysjpeglib_ok = xno; then\n    JPEGINC=\"-I../jpeg\"\n    JPEG=\"jpeg\"\n    IMAGELIBS=\"-lfltk_jpeg $IMAGELIBS\"\n    STATICIMAGELIBS=\"\\$libdir/libfltk_jpeg.a $STATICIMAGELIBS\"\n    AC_DEFINE(HAVE_LIBJPEG)\n    #ac_cv_lib_jpeg_jpeg_CreateCompress=no # from ima: should not be necessary\n    # Finally, warn user if system lib was requested but not found\n    if test x$enable_localjpeg = xno; then\n\tAC_MSG_WARN(Cannot find system jpeg lib or header: choosing the local lib mode.)\n    fi\nelse\n    JPEGINC=\"\"\n    JPEG=\"\"\n    IMAGELIBS=\"-ljpeg $IMAGELIBS\"\n    STATICIMAGELIBS=\"-ljpeg $STATICIMAGELIBS\"\n    AC_DEFINE(HAVE_LIBJPEG)\nfi\n\n# Handle the ZLIB lib linking mode (use fltk local or system lib)\n# If --enable-(resp. --disable-)localzlib parameter is not set by user\n# Then we check the ZLIB lib usability, with result in syszlib_ok variable\nAC_ARG_ENABLE(localzlib, [  --enable-localzlib      use local ZLIB library [[default=auto]]])\n# Check for System lib use if automatic mode or --disable-localzlib is requested\nsyszlib_ok=no\nsyszinc_ok=no\nif test x$enable_localzlib != xyes; then\n    AC_CHECK_LIB(z,gzgets,\n\t[AC_CHECK_HEADER(zlib.h, \n\t\tsyszinc_ok=yes)\n\tif test x$syszinc_ok = xyes; then\n\t    syszlib_ok=yes\n\t    fi])\nfi\n# Now set the Z lib and include flags according to the requested mode and availability \nif test x$enable_localzlib = xyes -o x$syszlib_ok = xno ; then\n    ZLIBINC=\"-I../zlib\"\n    ZLIB=\"zlib\"\n    LIBS=\"-lfltk_z $LIBS\"\n    IMAGELIBS=\"-lfltk_z $IMAGELIBS\"\n    STATICIMAGELIBS=\"\\$libdir/libfltk_z.a $STATICIMAGELIBS\"\n    AC_DEFINE(HAVE_LIBZ)\n    ac_cv_lib_z_gzgets=no # fc: is still necessary ?\n    # Finally, warn user if system lib was requested but not found\n    if test x$enable_localzlib = xno; then\n\tAC_MSG_WARN(Cannot find system z lib or header: choosing the local lib mode.)\n    fi\nelse\n    ZLIBINC=\"\"\n    ZLIB=\"\"\n    LIBS=\"-lz $LIBS\"\n    IMAGELIBS=\"-lz $IMAGELIBS\"\n    STATICIMAGELIBS=\"-lz $STATICIMAGELIBS\"\n    AC_DEFINE(HAVE_LIBZ)\nfi\n\n# Handle the PNG lib linking mode (use fltk local or system lib)\n# If --enable-(resp. --disable-)localpng parameter is not set by user\n# Then we check the png lib usability with result in syspng_lib variable\nAC_ARG_ENABLE(localpng, [  --enable-localpng       use local PNG library  [[default=auto]]])\n\n# Now check if system lib is usable, we check Lib AND include availability with inc variant,\n# but only, if the builtin lib is not requested\nsyspnglib_ok=no\nsyspnginc_ok=no\nif test x$enable_localpng != xyes; then\n  AC_CHECK_LIB(png, png_read_info, \n    [AC_CHECK_HEADER(png.h, \n\tAC_DEFINE(HAVE_PNG_H)\n\tsyspnginc_ok=yes)\n    AC_CHECK_HEADER(libpng/png.h, \n\tAC_DEFINE(HAVE_LIBPNG_PNG_H)\n\tsyspnginc_ok=yes)\n    if test x$syspnginc_ok = xyes; then\n\tsyspnglib_ok=yes\n    fi])\nfi\n\n# The following is executed if the lib was not found usable or if local lib is required explicitly\nif test x$enable_localpng = xyes -o x$syspnglib_ok = xno ; then\n    PNGINC=\"-I../png\"\n    PNG=\"png\"\n    IMAGELIBS=\"-lfltk_png $IMAGELIBS\"\n    STATICIMAGELIBS=\"\\$libdir/libfltk_png.a $STATICIMAGELIBS\"\n    AC_DEFINE(HAVE_LIBPNG)\n    AC_DEFINE(HAVE_PNG_H)\n    AC_DEFINE(HAVE_PNG_GET_VALID)\n    AC_DEFINE(HAVE_PNG_SET_TRNS_TO_ALPHA)\n    # Finally, warn user if system lib was requested but not found\n    if test x$enable_localpng = xno; then\n\tAC_MSG_WARN(Cannot find system png lib or header: choosing the local lib mode.)\n    fi\nelse\n    PNGINC=\"\"\n    PNG=\"\"\n    IMAGELIBS=\"-lpng $IMAGELIBS\"\n    STATICIMAGELIBS=\"-lpng $STATICIMAGELIBS\"\n    AC_DEFINE(HAVE_LIBPNG)\n    AC_CHECK_LIB(png,png_get_valid, AC_DEFINE(HAVE_PNG_GET_VALID))\n    AC_CHECK_LIB(png,png_set_tRNS_to_alpha, AC_DEFINE(HAVE_PNG_SET_TRNS_TO_ALPHA))\nfi\n\nAC_SUBST(JPEG)\nAC_SUBST(JPEGINC)\nAC_SUBST(PNG)\nAC_SUBST(PNGINC)\nAC_SUBST(ZLIB)\nAC_SUBST(ZLIBINC)\n\ndnl Restore original LIBS settings...\nLIBS=\"$SAVELIBS\"\n\ndnl See if we need a .exe extension on executables...\nAC_EXEEXT\n\ndnl Check for pthreads for multi-threaded apps...\nhave_pthread=no\nPTHREAD_FLAGS=\"\"\n\ndnl Test whether we want to check for pthreads. We must not do it on Windows\ndnl unless we run under Cygwin with --enable-cygwin, since we always use\ndnl native threads on Windows (even if libpthread is available)\ncheck_pthread=yes\ncase $host_os in\n    mingw*)\n\tcheck_pthread=no\n\t;;\n    cygwin*)\n\tif test \"x$enable_cygwin\" != xyes; then\n\t    check_pthread=no\n\tfi\n\t;;\n    *)\n\t;;\nesac\n\nif test \"x$enable_threads\" != xno -a x$check_pthread = xyes; then\n    AC_CHECK_HEADER(pthread.h, AC_DEFINE(HAVE_PTHREAD_H))\n\n    if test x$ac_cv_header_pthread_h = xyes; then\n\tdnl Check various threading options for the platforms we support\n\tfor flag in -lpthreads -lpthread -pthread; do\n            AC_MSG_CHECKING([for pthread_create using $flag])\n\t    SAVELIBS=\"$LIBS\"\n\t    LIBS=\"$flag $LIBS\"\n            AC_TRY_LINK([#include <pthread.h>],\n\t\t[pthread_create(0, 0, 0, 0);],\n        \thave_pthread=yes,\n\t\tLIBS=\"$SAVELIBS\")\n            AC_MSG_RESULT([$have_pthread])\n\n\t    if test $have_pthread = yes; then\n\t        AC_DEFINE(HAVE_PTHREAD)\n\t\tPTHREAD_FLAGS=\"-D_THREAD_SAFE -D_REENTRANT\"\n\n\t\t# Solaris requires -D_POSIX_PTHREAD_SEMANTICS to\n\t\t# be POSIX-compliant... :(\n\t\tcase $host_os in\n\t\t    solaris*)\n\t\t        PTHREAD_FLAGS=\"$PTHREAD_FLAGS -D_POSIX_PTHREAD_SEMANTICS\"\n\t\t        ;;\n\t\tesac\n\t\tbreak\n\t    fi\n\tdone\n    fi\nfi\n\nAC_SUBST(PTHREAD_FLAGS)\n\ndnl Define OS-specific stuff...\nHLINKS=\nOSX_ONLY=:\nTHREADS=\n\nAC_ARG_WITH(links, [  --with-links            make header links for common misspellings [[default=no]]])\n\nINSTALL_DESKTOP=\"\"\nUNINSTALL_DESKTOP=\"\"\n\ncase $host_os_gui in\n    cygwin* | mingw*)\n\tdnl Cygwin environment, using windows GDI ...\n\t# Recent versions of Cygwin are seriously broken and the size\n\t# checks don't work because the shell puts out \\r\\n instead of\n\t# \\n.  Here we just force U32 to be defined to \"unsigned\"...\n        AC_DEFINE(U32,unsigned)\n\tCFLAGS=\"-mwindows -DWIN32 -DUSE_OPENGL32 $CFLAGS\"\n\tCXXFLAGS=\"-mwindows -DWIN32 -DUSE_OPENGL32 $CXXFLAGS\"\n\tLDFLAGS=\"-mwindows $LDFLAGS\"\n\tDSOFLAGS=\"-mwindows $DSOFLAGS\"\n\tLIBS=\"$LIBS -lole32 -luuid -lcomctl32\"\n\tif test \"x$with_optim\" = x; then\n\t    dnl Avoid -Os optimization on Cygwin/MinGW\n\t    with_optim=\"-O3\"\n\tfi\n\n\tif test x$enable_gl != xno; then\n\t    AC_CHECK_HEADER(GL/gl.h,\n\t        AC_DEFINE(HAVE_GL)\n\t\tGLLIB=\"-lopengl32\")\n\t    AC_CHECK_HEADER(GL/glu.h,\n        \tAC_DEFINE(HAVE_GL_GLU_H)\n\t\tGLLIB=\"-lglu32 $GLLIB\")\n\telse\n\t    LINKFLTKGL=\"\"\n\t    GLLIBNAME=\"\"\n\t    GLDSONAME=\"\"\n\t    GLDEMOS=\"\"\n\tfi\n\n\tif test \"x$enable_threads\" != xno; then\n\t    if test x$have_pthread = xyes; then\n\t\tAC_DEFINE(HAVE_PTHREAD)\n\t    fi\n        fi\n\n\tTHREADS=\"threads$EXEEXT\"\n\n\t# Don't make symlinks since Windows is not case sensitive.\n\tif test \"x$with_links\" != xyes; then\n\t\tHLINKS=\"#\"\n\tfi\n\t;;\n\n    darwin*)\n        # MacOS X uses Cocoa for graphics.\n        LIBS=\"$LIBS -framework Cocoa\"\n\n\tif test x$have_pthread = xyes; then\n\t    AC_DEFINE(HAVE_PTHREAD)\n\t    THREADS=\"threads$EXEEXT\"\n\tfi\n\n\tif test x$enable_gl != xno; then\n            AC_DEFINE(HAVE_GL)\n            AC_DEFINE(HAVE_GL_GLU_H)\n            GLLIB=\"-framework AGL -framework OpenGL -framework ApplicationServices\"\n        else\n\t    LINKFLTKGL=\"\"\n\t    GLLIBNAME=\"\"\n\t    GLDSONAME=\"\"\n\t    GLDEMOS=\"\"\n        fi\n\n\t# Don't make symlinks because HFS+ is not case sensitive...\n\tif test \"x$with_links\" != xyes; then\n\t\tHLINKS=\"#\"\n\tfi\n\n\t# Some steps are only done for OS X package management\n\tOSX_ONLY=\n\n\t# Install/Uninstall FLUID application\n\tINSTALL_DESKTOP=\"install-osx\"\n\tUNINSTALL_DESKTOP=\"uninstall-osx\"\n\t;;\n\n    *)\n\t# All others are UNIX/X11...\n\t# This includes Cygwin target combined with X11\n\tif test x$have_pthread = xyes; then\n\t    AC_DEFINE(HAVE_PTHREAD)\n\t    THREADS=\"threads$EXEEXT\"\n\tfi\n\n\tdnl Check for X11...\n\tAC_PATH_XTRA\n\n\tif test x$no_x = xyes; then\n\t    AC_MSG_ERROR(Configure could not find required X11 libraries, aborting.)\n\tfi\n\n\tif test \"x$X_PRE_LIBS\" != x; then\n\t    AC_MSG_WARN(Ignoring libraries \\\"$X_PRE_LIBS\\\" requested by configure.)\n\tfi\n\n\tLIBS=\"$LIBS -lX11 $X_EXTRA_LIBS\"\n\tCFLAGS=\"$CFLAGS $X_CFLAGS\"\n\tCXXFLAGS=\"$CXXFLAGS $X_CFLAGS\"\n\tLDFLAGS=\"$X_LIBS $LDFLAGS\"\n\tDSOFLAGS=\"$X_LIBS $DSOFLAGS\"\n\tAC_DEFINE(USE_X11)\n\tif test \"x$x_includes\" != x; then\n\t    ac_cpp=\"$ac_cpp -I$x_includes\"\n\tfi\n\n\tdnl Check for OpenGL unless disabled...\n\tGLLIB=\n\n\tif test x$enable_gl != xno; then\n\t    AC_SEARCH_LIBS(dlopen, dl)\n\t    AC_CHECK_HEADER(GL/gl.h,\n\t\tAC_CHECK_LIB(GL, glXMakeCurrent, AC_DEFINE(HAVE_GL) GLLIB=\"-lGL\",\n\t\t    AC_CHECK_LIB(MesaGL,glXMakeCurrent, AC_DEFINE(HAVE_GL) GLLIB=\" -lMesaGL\",,\n\t\t\t-lm),\n\t\t    -lm)\n\t\tAC_CHECK_LIB(GL, glXGetProcAddressARB,\n\t\t             AC_DEFINE(HAVE_GLXGETPROCADDRESSARB),, -lm)\n\t    )\n\t    AC_CHECK_HEADER(GL/glu.h,\n        \tAC_DEFINE(HAVE_GL_GLU_H)\n\t\tif test x$ac_cv_lib_GL_glXMakeCurrent = xyes; then\n\t\t    GLLIB=\"-lGLU $GLLIB\"\n\t\tfi\n\t\tif test x$ac_cv_lib_MesaGL_glXMakeCurrent = xyes; then\n\t\t    GLLIB=\"-lMesaGLU $GLLIB\"\n\t\tfi\n\t    )\n\n\t    if test x$ac_cv_lib_GL_glXMakeCurrent != xyes -a x$ac_cv_lib_MesaGL_glXMakeCurrent != xyes; then\n\t\t    LINKFLTKGL=\"\"\n\t\t    GLLIBNAME=\"\"\n\t\t    GLDSONAME=\"\"\n\t\t    GLDEMOS=\"\"\n\t    fi\n\telse\n\t    LINKFLTKGL=\"\"\n\t    GLLIBNAME=\"\"\n\t    GLDSONAME=\"\"\n\t    GLDEMOS=\"\"\n\tfi\n\n\tdnl Check for Xinerama support unless disabled...\n        AC_ARG_ENABLE(xinerama, [  --enable-xinerama       turn on Xinerama support [[default=yes]]])\n\n\tif test x$enable_xinerama != xno; then\n\t    AC_CHECK_LIB(Xinerama,XineramaIsActive,\n\t\t    AC_DEFINE(HAVE_XINERAMA)\n\t\t    LIBS=\"-lXinerama $LIBS\")\n\tfi\n\n\tdnl Check for the Xft library unless disabled...\n        AC_ARG_ENABLE(xft, [  --enable-xft            turn on Xft support [[default=yes]]])\n\n\tif test x$enable_xft != xno; then\n            AC_PATH_PROG(FTCONFIG,freetype-config)\n\n\t    if test \"x$FTCONFIG\" != x; then\n\t        CPPFLAGS=\"`$FTCONFIG --cflags` $CPPFLAGS\"\n\t        CFLAGS=\"`$FTCONFIG --cflags` $CFLAGS\"\n\t        CXXFLAGS=\"`$FTCONFIG --cflags` $CXXFLAGS\"\n\n\t        AC_CHECK_LIB(fontconfig, FcPatternCreate)\n\t\tAC_CHECK_HEADER(X11/Xft/Xft.h,\n\t\t    AC_CHECK_LIB(Xft, XftDrawCreate,\n\t\t\tAC_DEFINE(USE_XFT)\n\t\t\tLIBS=\"-lXft $LIBS\"))\n\t    fi\n\tfi\n\n\tdnl Check for the Xdbe extension unless disabled...\n        AC_ARG_ENABLE(xdbe, [  --enable-xdbe           turn on Xdbe support [[default=yes]]])\n\n\tif test x$enable_xdbe != xno; then\n\t    AC_CHECK_HEADER(X11/extensions/Xdbe.h, AC_DEFINE(HAVE_XDBE),,\n\t        [#include <X11/Xlib.h>])\n\t    AC_CHECK_LIB(Xext, XdbeQueryExtension,\n\t\tLIBS=\"-lXext $LIBS\")\n\tfi\n\n\tdnl Check for the Xfixes extension unless disabled...\n        AC_ARG_ENABLE(xfixes, [  --enable-xfixes         turn on Xfixes support [[default=yes]]])\n\n\tif test x$enable_xfixes != xno; then\n\t    AC_CHECK_HEADER(X11/extensions/Xfixes.h, AC_DEFINE(HAVE_XFIXES),,\n\t        [#include <X11/Xlib.h>])\n\t    AC_CHECK_LIB(Xfixes, XFixesQueryExtension,\n\t\tLIBS=\"-lXfixes $LIBS\")\n\tfi\n\n\tdnl Check for the Xcursor library unless disabled...\n        AC_ARG_ENABLE(xcursor, [  --enable-xcursor        turn on Xcursor support [[default=yes]]])\n\n\tif test x$enable_xcursor != xno; then\n\t    AC_CHECK_HEADER(X11/Xcursor/Xcursor.h, AC_DEFINE(HAVE_XCURSOR),,\n\t        [#include <X11/Xlib.h>])\n\t    AC_CHECK_LIB(Xcursor, XcursorImageCreate,\n\t\tLIBS=\"-lXcursor $LIBS\")\n\tfi\n\n\tdnl Check for overlay visuals...\n\tAC_PATH_PROG(XPROP, xprop)\n\tAC_CACHE_CHECK(for X overlay visuals, ac_cv_have_overlay,\n\t    if test \"x$XPROP\" != x; then\n\t\tif $XPROP -root 2>/dev/null | grep -c \"SERVER_OVERLAY_VISUALS\" >/dev/null; then\n        \t    ac_cv_have_overlay=yes\n\t\telse\n        \t    ac_cv_have_overlay=no\n\t\tfi\n\t    else\n        \tac_cv_have_overlay=no\n\t    fi)\n\n        if test x$ac_cv_have_overlay = xyes; then\n\t    AC_DEFINE(HAVE_OVERLAY)\n\tfi\n\n\t# Make symlinks since UNIX/Linux is case sensitive,\n\t# but Cygwin in general not.\n\tcase $host_os in\n\t    cygwin*)\n\t\tHLINKS=\"#\"\n\t    ;;\n\t    *)\n\t    ;;\n\tesac\n\t# Make symlinks since UNIX/Linux is case sensitive,\n\t# but only if explicitly configured (default=no)\n\tif test \"x$with_links\" != xyes; then\n\t\tHLINKS=\"#\"\n\tfi\n\n\t# Install/Uninstall FLUID application support files\n\tINSTALL_DESKTOP=\"install-linux\"\n\tUNINSTALL_DESKTOP=\"uninstall-linux\"\n\t;;\nesac\n\nAC_SUBST(GLDEMOS)\nAC_SUBST(GLLIB)\nAC_SUBST(HLINKS)\nAC_SUBST(OSX_ONLY)\nAC_SUBST(THREADS)\n\nAC_SUBST(INSTALL_DESKTOP)\nAC_SUBST(UNINSTALL_DESKTOP)\n\ndnl Figure out the appropriate formatted man page extension...\ncase \"$host_os\" in\n    *bsd* | darwin*)\n\t# *BSD\n\tCAT1EXT=0\n\tCAT3EXT=0\n\tCAT6EXT=0\n\t;;\n    irix*)\n\t# SGI IRIX\n\tCAT1EXT=z\n\tCAT3EXT=z\n\tCAT6EXT=z\n\t;;\n    *)\n\t# All others\n\tCAT1EXT=1\n\tCAT3EXT=3\n\tCAT6EXT=6\n\t;;\nesac\n\nAC_SUBST(CAT1EXT)\nAC_SUBST(CAT3EXT)\nAC_SUBST(CAT6EXT)\n\ndnl Fix \"mandir\" variable...\nif test \"$mandir\" = \"\\${prefix}/man\" -a \"$prefix\" = \"/usr\"; then\n    case \"$host_os\" in\n        *bsd* | darwin* | linux*)\n            # *BSD, Darwin, and Linux\n            mandir=\"\\${prefix}/share/man\"\n            ;;\n        irix*)\n            # SGI IRIX\n            mandir=\"\\${prefix}/share/catman\"\n            ;;\n    esac\nfi\n\ndnl Fix \"libdir\" variable...\nif test \"$prefix\" = NONE; then\n    prefix=/usr/local\nfi\n\nif test \"$exec_prefix\" = NONE; then\n    exec_prefix=\"\\${prefix}\"\nfi\n\ncase $host_os in\n    irix[1-5]*)\n        ;;\n    irix*)\n        if test \"$libdir\" = \"\\${exec_prefix}/lib\" -a \"$exec_prefix\" = \"\\${prefix}\" -a \"$prefix\" = \"/usr\"; then\n            libdir=\"/usr/lib32\"\n        fi\n        ;;\nesac\n\ndnl Define the command used to update the dependencies (this option\ndnl mainly for FLTK core developers - not necessary for users)\nMAKEDEPEND=\"\\$(CXX) -M\"\nAC_SUBST(MAKEDEPEND)\n\ndnl Add warnings to compiler switches:\ndnl do this last so messing with switches does not break tests\n\nif test -n \"$GCC\"; then\n    # Show all standard warnings + unused variables, conversion errors,\n    # and inlining problems when compiling...\n    OPTIM=\"-Wall -Wunused -Wno-format-y2k $OPTIM\"\n\n    # The following additional warnings are useful for tracking down problems...\n    #OPTIM=\"-Wshadow -Wconversion $OPTIM\"\n\n    # We know that Carbon is deprecated on OS X 10.4. To avoid hundreds of warnings\n    # we will temporarily disable 'deprecated' warnings on OS X.\n    case $host_os in\n        darwin[1-7])\n            ;;\n        darwin*)\n            OPTIM=\"-Wno-deprecated-declarations $OPTIM\"\n            ;;\n    esac\n\n    # Set the default compiler optimizations...\n    if test -z \"$DEBUGFLAG\"; then\n    \t#\n\t# Note: Can't use -fomit-frame-pointer - prevents tools like\n\t#       libsafe from working!\n        #\n\t#       Don't use -fforce-mem, -fforce-addr, or -fcaller-saves.\n\t#       They all seem to make either no difference or enlarge\n\t#       the code by a few hundred bytes.\n        #\n\t#       \"-Os\" seems to be the best compromise between speed and\n\t#       code size.  \"-O3\" and higher seem to make no effective\n\t#       difference in the speed of the code, but does bloat the\n\t#       library 10+%.\n\t#\n\n        if test \"x$with_optim\" != x; then\n\t    OPTIM=\"$with_optim $OPTIM\"\n\telse\n            OPTIM=\"-Os $OPTIM\"\n\tfi\n    fi\n\n    # Generate position-independent code when needed...\n    if test $PICFLAG = 1; then\n    \tOPTIM=\"$OPTIM -fPIC\"\n    fi\n\n    # See if GCC supports -fno-exceptions...\n    AC_MSG_CHECKING(if GCC supports -fno-exceptions)\n    OLDCFLAGS=\"$CFLAGS\"\n    CFLAGS=\"$CFLAGS -fno-exceptions\"\n    AC_TRY_COMPILE(,,\n\tOPTIM=\"$OPTIM -fno-exceptions\"\n\tAC_MSG_RESULT(yes),\n\tAC_MSG_RESULT(no))\n    CFLAGS=\"$OLDCFLAGS\"\n\n    # See if GCC supports -fno-strict-aliasing...\n    AC_MSG_CHECKING(if GCC supports -fno-strict-aliasing)\n    OLDCFLAGS=\"$CFLAGS\"\n    CFLAGS=\"$CFLAGS -fno-strict-aliasing\"\n    AC_TRY_COMPILE(,,\n\tOPTIM=\"$OPTIM -fno-strict-aliasing\"\n\tAC_MSG_RESULT(yes),\n\tAC_MSG_RESULT(no))\n    CFLAGS=\"$OLDCFLAGS\"\n\n    # See if ld supports -Bsymbolic-functions...\n    AC_MSG_CHECKING(if ld supports -Bsymbolic-functions)\n    OLDLDFLAGS=\"$LDFLAGS\"\n    LDFLAGS=\"$LDFLAGS -Wl,-Bsymbolic-functions\"\n    AC_TRY_LINK(,,\n        [DSOFLAGS=\"$DSOFLAGS -Wl,-Bsymbolic-functions\"]\n        AC_MSG_RESULT(yes),\n        AC_MSG_RESULT(no))\n    LDFLAGS=\"$OLDLDFLAGS\"\n\n    # See if toolchain supports a sectioned build...\n    AC_MSG_CHECKING(if toolchain supports sections)\n    OLDLDFLAGS=\"$LDFLAGS\"\n    OLDCFLAGS=\"$CFLAGS\"\n    LDFLAGS=\"$LDFLAGS -Wl,-gc-sections\"\n    CFLAGS=\"$CFLAGS -ffunction-sections -fdata-sections\"\n    AC_TRY_LINK(,,\n        [DSOFLAGS=\"$DSOFLAGS -Wl,-gc-sections\"\n        OPTIM=\"$OPTIM -ffunction-sections -fdata-sections\"]\n        AC_MSG_RESULT(yes),\n        AC_MSG_RESULT(no))\n    LDFLAGS=\"$OLDLDFLAGS\"\n    CFLAGS=\"$OLDCFLAGS\"\n\n    # See if we are running Solaris; if so, try the -fpermissive option...\n    # This option is required on some versions of Solaris to work around\n    # bugs in the X headers up through Solaris 7.\n    #\n    # Unlike the other compiler/optimization settings, this one is placed\n    # in CFLAGS and CXXFLAGS so that fltk-config will provide the option\n    # to clients - otherwise client apps will not compile properly...\n    case $host_os in\n        solaris*)\n\t    AC_MSG_CHECKING(if GCC supports -fpermissive)\n\n\t    OLDCFLAGS=\"$CFLAGS\"\n\t    CFLAGS=\"$CFLAGS -fpermissive\"\n\t    AC_TRY_COMPILE(,,\n\t        CXXFLAGS=\"$CXXFLAGS -fpermissive\"\n\t        AC_MSG_RESULT(yes),\n\t        CFLAGS=\"$OLDCFLAGS\"\n\t        AC_MSG_RESULT(no))\n\t    ;;\n    esac\nelse\n    case \"$host_os\" in\n        irix*)\n\t    # Running some flavor of IRIX; see which version and\n\t    # set things up according...\n\t    if test \"$uversion\" -ge 62; then\n\t        # We are running IRIX 6.2 or higher; uncomment the following\n\t\t# lines if you don't have IDO 7.2 or higher:\n\t\t#\n\t\t#     CXX=\"CC -n32 -mips3\"\n\t\t#     CC=\"cc -n32 -mips3\"\n\t\t#     LD=\"ld -n32 -mips3\"\n\t\t#     MAKEDEPEND=\"CC -M\"\n\n\t\tif test \"x`grep abi=n32 /etc/compiler.defaults`\" = x; then\n\t\t\tAC_MSG_WARN(FOR BEST RESULTS BEFORE COMPILING: setenv SGI_ABI \\\"-n32 -mips3\\\")\n\t\tfi\n\n        \tOPTIM=\"-fullwarn $OPTIM\"\n\t    fi\n\t    if test -z \"$DEBUGFLAG\"; then\n        \tif test \"x$with_optim\" != x; then\n\t\t    OPTIM=\"$with_optim $OPTIM\"\n\t\telse\n        \t    OPTIM=\"-O2 $OPTIM\"\n\t\t    if test $uversion -gt 62; then\n        \t        OPTIM=\"-OPT:Olimit=4000 $OPTIM\"\n\t            fi\n\t\tfi\n\t    fi\n\t    ;;\n\thpux*)\n\t    # Running HP-UX; these options should work for the HP compilers.\n\t    if test -z \"$DEBUGFLAG\"; then\n        \tif test \"x$with_optim\" != x; then\n\t\t    OPTIM=\"$with_optim $OPTIM\"\n\t\telse\n        \t    OPTIM=\"+O2 $OPTIM\"\n\t\tfi\n\t    fi\n\n\t    if test $PICFLAG = 1; then\n\t\tOPTIM=\"+z $OPTIM\"\n\t    fi\n\n\t    CXXFLAGS=\"$CXXFLAGS +W336,501,736,740,749,829\"\n\t    ;;\n\tOSF1*)\n\t    # Running Digital/Tru64 UNIX; these options should work for the\n\t    # Digital/Compaq/NewHP compilers.\n\t    if test -z \"$DEBUGFLAG\"; then\n        \tif test \"x$with_optim\" != x; then\n\t\t    OPTIM=\"$with_optim $OPTIM\"\n\t\telse\n        \t    OPTIM=\"-O2 $OPTIM\"\n\t\tfi\n\t    fi\n\t    ;;\n\tsolaris*)\n\t    # Solaris\n\t    if test -z \"$DEBUGFLAG\"; then\n        \tif test \"x$with_optim\" != x; then\n\t\t    OPTIM=\"$with_optim $OPTIM\"\n\t\telse\n        \t    OPTIM=\"-xO3 $OPTIM\"\n\t\tfi\n\t    fi\n\n\t    if test $PICFLAG = 1; then\n\t\tOPTIM=\"-KPIC $OPTIM\"\n\t    fi\n\t    ;;\n\taix*)\n\t    if test -z \"$DEBUGFLAG\"; then\n        \tif test \"x$with_optim\" != x; then\n\t\t    OPTIM=\"$with_optim $OPTIM\"\n\t\telse\n        \t    OPTIM=\"-O2 $OPTIM\"\n\t\tfi\n\t    fi\n\n\t    AC_MSG_WARN(The AIX C and C++ compilers are known not to correctly compile the FLTK library.)\n\t    ;;\n\t*)\n\t    # Running some other operating system; inform the user they\n\t    # should contribute the necessary options via the STR form..\n\t    AC_MSG_WARN(Building FLTK with default compiler optimizations)\n\t    AC_MSG_WARN(Send the FLTK developers your uname and compiler options via http://www.fltk.org/str.php)\n\t    ;;\n    esac\nfi\n\nOPTIM=\"$DEBUGFLAG $OPTIM\"\n\ndnl Take archflags away from CFLAGS (makefiles use ARCHFLAGS explicitly)\ncase $host_os in\n    darwin*)\n        if test \"x$with_archflags\" != x ; then\n            CFLAGS=\"`echo $CFLAGS | sed -e \"s/$with_archflags//g\"`\"\n        fi\n        ;;\nesac\n\ndnl Define the FLTK documentation directory...\ncase $host_os in\n  mingw*)\n     # Determine the path where MSys has /usr installed\n \tmsyspath=`mount | grep '\\/usr ' | cut -d ' ' -f -1 | sed -e 's/\\\\\\/\\// g'`\n     # Then substitute that in the WIN32 path instead of /usr\n \tAC_DEFINE_UNQUOTED(FLTK_DOCDIR, \"$msyspath/local/share/doc/fltk\")\n    ;;\n  *)\n    if test x$prefix = xNONE; then\n\tAC_DEFINE_UNQUOTED(FLTK_DOCDIR, \"/usr/local/share/doc/fltk\")\n    else\n\tAC_DEFINE_UNQUOTED(FLTK_DOCDIR, \"$prefix/share/doc/fltk\")\n    fi\n    ;;\nesac\n\ndnl Define the FLTK data directory...\nif test x$prefix = xNONE; then\n    AC_DEFINE_UNQUOTED(FLTK_DATADIR, \"/usr/local/share/fltk\")\nelse\n    AC_DEFINE_UNQUOTED(FLTK_DATADIR, \"$prefix/share/fltk\")\nfi\n\ndnl Summarize results of configure tests...\necho \"\"\necho \"Configuration Summary\"\necho \"-------------------------------------------------------------------------\"\n\ncase $host_os_gui in\n    cygwin* | mingw*)\n        graphics=\"GDI\"\n\t;;\n    darwin*)\n        graphics=\"Quartz\"\n        ;;\n    *)\n        graphics=\"X11\"\n\tif test x$enable_xft != xno; then\n\t    graphics=\"$graphics+Xft\"\n\tfi\n\tif test x$enable_xdbe != xno; then\n\t    graphics=\"$graphics+Xdbe\"\n\tfi\n\tif test x$enable_xinerama != xno; then\n\t    graphics=\"$graphics+Xinerama\"\n\tfi\n        ;;\nesac\n\necho \"    Directories: prefix=$prefix\"\necho \"                 bindir=$bindir\"\necho \"                 datadir=$datadir\"\necho \"                 datarootdir=$datarootdir\"\necho \"                 exec_prefix=$exec_prefix\"\necho \"                 includedir=$includedir\"\necho \"                 libdir=$libdir\"\necho \"                 mandir=$mandir\"\ncase $host_os in\n  mingw*)\n    echo \"                 MSys docpath=$msyspath/local/share/doc/fltk\"\n  ;;\nesac\necho \"       Graphics: $graphics\"\n\nif test x$JPEG = x; then\n    echo \"Image Libraries: JPEG=System\"\nelse\n    echo \"Image Libraries: JPEG=Builtin\"\nfi\nif test x$PNG = x; then\n    echo \"                 PNG=System\"\nelse\n    echo \"                 PNG=Builtin\"\nfi\nif test x$ZLIB = x; then\n    echo \"                 ZLIB=System\"\nelse\n    echo \"                 ZLIB=Builtin\"\nfi\nif test x$enable_cairo = xyes; then\n    echo \"                 CAIRO=lib\"\nfi\nif test x$enable_cairoext = xyes; then\n    echo \"                 CAIRO=internal_use\"\nfi\n\n\nif test x$enable_largefile != xno; then\n    echo \"    Large Files: YES\"\nelse\n    echo \"    Large Files: NO\"\nfi\n\nif test x$GLDEMOS = x; then\n    echo \"         OpenGL: NO\"\nelse\n    echo \"         OpenGL: YES\"\nfi\n\nif test x$THREADS = x; then\n    echo \"        Threads: NO\"\nelse\n    echo \"        Threads: YES\"\nfi\n\ndnl Write all of the files...\nAC_CONFIG_HEADER(config.h:configh.in)\nAC_OUTPUT(makeinclude fltk.list fltk-config fltk.spec FL/Makefile)\n\ndnl Make sure the fltk-config script is executable...\nchmod +x fltk-config\n\ndnl\ndnl End of \"$Id: configure.in 10418 2014-10-30 14:07:58Z AlbrechtS $\".\ndnl\n",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/src/Fl_Native_File_Chooser_GTK.cxx": "// \"$Id$\"\n//\n// FLTK native file chooser widget wrapper for GTK's GtkFileChooserDialog \n//\n// Copyright 1998-2014 by Bill Spitzak and others.\n// Copyright 2012 IMM\n//\n// This library is free software. Distribution and use rights are outlined in\n// the file \"COPYING\" which should have been included with this file.  If this\n// file is missing or damaged, see the license at:\n//\n//     http://www.fltk.org/COPYING.php\n//\n// Please report all bugs and problems to:\n//\n//     http://www.fltk.org/str.php\n//\n\n#include <FL/x.H>\n#if HAVE_DLSYM && HAVE_DLFCN_H\n#include <dlfcn.h>   // for dlopen et al\n#endif\n#include <locale.h>  // for setlocale\n\n/* --------------------- Type definitions from GLIB and GTK --------------------- */\n/* all of this is from the public gnome API, so unlikely to change */\n#ifndef\tFALSE\n#define\tFALSE\t(0)\n#endif\n#ifndef\tTRUE\n#define\tTRUE\t(!FALSE)\n#endif\ntypedef void* gpointer;\ntypedef int    gint;\ntypedef unsigned int    guint;\ntypedef unsigned long   gulong;\ntypedef gint   gboolean;\ntypedef char   gchar;\ntypedef struct _GSList GSList;\nstruct _GSList\n{\n  gpointer data;\n  GSList *next;\n};\n#define  g_slist_next(slist)\t         ((slist) ? (((GSList *)(slist))->next) : NULL)\ntypedef struct _GtkWidget      GtkWidget;\ntypedef struct _GtkFileChooser      GtkFileChooser;\ntypedef struct _GtkDialog        GtkDialog;\ntypedef struct _GtkWindow          GtkWindow;\ntypedef struct _GdkDrawable           GdkWindow;\ntypedef struct _GtkFileFilter     GtkFileFilter;\ntypedef struct _GtkToggleButton       GtkToggleButton;\ntypedef enum {\n  GTK_FILE_FILTER_FILENAME     = 1 << 0,\n  GTK_FILE_FILTER_URI          = 1 << 1,\n  GTK_FILE_FILTER_DISPLAY_NAME = 1 << 2,\n  GTK_FILE_FILTER_MIME_TYPE    = 1 << 3\n} GtkFileFilterFlags;\nstruct _GtkFileFilterInfo\n{\n  GtkFileFilterFlags contains;\n  \n  const gchar *filename;\n  const gchar *uri;\n  const gchar *display_name;\n  const gchar *mime_type;\n};\ntypedef struct _GtkFileFilterInfo GtkFileFilterInfo;\ntypedef gboolean (*GtkFileFilterFunc) (const GtkFileFilterInfo *filter_info, gpointer data);\ntypedef void (*GDestroyNotify)(gpointer data);\ntypedef enum\n{\n  GTK_FILE_CHOOSER_ACTION_OPEN,\n  GTK_FILE_CHOOSER_ACTION_SAVE,\n  GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER,\n  GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER\n} GtkFileChooserAction;\n#define GTK_STOCK_CANCEL           \"gtk-cancel\"\n#define GTK_STOCK_SAVE             \"gtk-save\"\n#define GTK_STOCK_OPEN             \"gtk-open\"\nconst int   GTK_RESPONSE_NONE = -1;\nconst int   GTK_RESPONSE_ACCEPT = -3;\nconst int   GTK_RESPONSE_DELETE_EVENT = -4;\nconst int   GTK_RESPONSE_CANCEL = -6;\ntypedef void  (*GCallback)(void);\n#define\tG_CALLBACK(f)\t\t\t ((GCallback) (f))\ntypedef int GConnectFlags;\ntypedef struct _GClosure\t\t GClosure;\ntypedef void  (*GClosureNotify)(gpointer data, GClosure\t*closure);\n\n/* --------------------- End of Type definitions from GLIB and GTK --------------------- */\n\nint Fl_GTK_File_Chooser::did_find_GTK_libs = 0;\n\n/* These are the GTK/GLib methods we want to load, but not call by name...! */\n\n// void g_free (gpointer mem);\ntypedef void (*XX_g_free)(gpointer);\nstatic XX_g_free fl_g_free = NULL;\n\n// gpointer g_slist_nth_data (GSList *list, guint n);\ntypedef gpointer (*XX_g_slist_nth_data) (GSList *, guint);\nstatic XX_g_slist_nth_data fl_g_slist_nth_data = NULL;\n\n// guint g_slist_length (GSList *list);\ntypedef guint (*XX_g_slist_length) (GSList *);\nstatic XX_g_slist_length fl_g_slist_length = NULL;\n\n// void g_slist_free (GSList *list);\ntypedef void (*XX_g_slist_free) (GSList *);\nstatic XX_g_slist_free fl_g_slist_free = NULL;\n\n// gboolean gtk_init_check (int *argc, char ***argv);\ntypedef gboolean (*XX_gtk_init_check)(int *, char ***);\nstatic XX_gtk_init_check fl_gtk_init_check = NULL;\n\n// void gtk_widget_destroy (GtkWidget *widget);\ntypedef void (*XX_gtk_widget_destroy) (GtkWidget *);\nstatic XX_gtk_widget_destroy fl_gtk_widget_destroy = NULL;\n\n// void gtk_file_chooser_set_select_multiple(GtkFileChooser *chooser, gboolean select_multiple);\ntypedef void (*XX_gtk_file_chooser_set_select_multiple)(GtkFileChooser *, gboolean);\nstatic XX_gtk_file_chooser_set_select_multiple fl_gtk_file_chooser_set_select_multiple = NULL;\n\n// void gtk_file_chooser_set_do_overwrite_confirmation(GtkFileChooser *chooser, gboolean do_overwrite_confirmation);\ntypedef void (*XX_gtk_file_chooser_set_do_overwrite_confirmation)(GtkFileChooser *, gboolean);\nstatic XX_gtk_file_chooser_set_do_overwrite_confirmation fl_gtk_file_chooser_set_do_overwrite_confirmation = NULL;\n\n// void gtk_file_chooser_set_current_name (GtkFileChooser *chooser, const gchar *name);\ntypedef void (*XX_gtk_file_chooser_set_current_name)(GtkFileChooser *, const gchar *);\nstatic XX_gtk_file_chooser_set_current_name fl_gtk_file_chooser_set_current_name = NULL;\n\n// void gtk_file_chooser_set_current_folder (GtkFileChooser *chooser, const gchar *name);\ntypedef void (*XX_gtk_file_chooser_set_current_folder)(GtkFileChooser *, const gchar *);\nstatic XX_gtk_file_chooser_set_current_folder fl_gtk_file_chooser_set_current_folder = NULL;\n\n// void gtk_file_chooser_set_create_folders (GtkFileChooser *chooser, gboolean create_folders);\ntypedef void (*XX_gtk_file_chooser_set_create_folders) (GtkFileChooser *, gboolean);\nstatic XX_gtk_file_chooser_set_create_folders fl_gtk_file_chooser_set_create_folders = NULL;\n\n// gboolean gtk_file_chooser_get_select_multiple(GtkFileChooser *chooser);\ntypedef gboolean (*XX_gtk_file_chooser_get_select_multiple)(GtkFileChooser *);\nstatic XX_gtk_file_chooser_get_select_multiple fl_gtk_file_chooser_get_select_multiple = NULL;\n\n// void gtk_widget_hide(GtkWidget *widget);\ntypedef void (*XX_gtk_widget_hide)(GtkWidget *);\nstatic XX_gtk_widget_hide fl_gtk_widget_hide = NULL;\n\n// gchar * gtk_file_chooser_get_filename(GtkFileChooser *chooser);\ntypedef gchar* (*XX_gtk_file_chooser_get_filename)(GtkFileChooser *);\nstatic XX_gtk_file_chooser_get_filename fl_gtk_file_chooser_get_filename = NULL;\n\n// GSList * gtk_file_chooser_get_filenames(GtkFileChooser *chooser);\ntypedef GSList* (*XX_gtk_file_chooser_get_filenames)(GtkFileChooser *chooser);\nstatic XX_gtk_file_chooser_get_filenames fl_gtk_file_chooser_get_filenames = NULL;\n\n// gboolean gtk_main_iteration(void);\ntypedef gboolean (*XX_gtk_main_iteration)(void);\nstatic XX_gtk_main_iteration fl_gtk_main_iteration = NULL;\n\n// gboolean gtk_events_pending(void);\ntypedef gboolean (*XX_gtk_events_pending)(void);\nstatic XX_gtk_events_pending fl_gtk_events_pending = NULL;\n\n// GtkWidget * gtk_file_chooser_dialog_new(const gchar *title, GtkWindow *parent, GtkFileChooserAction action, const gchar *first_button_text, ...);\ntypedef GtkWidget* (*XX_gtk_file_chooser_dialog_new)(const gchar *, GtkWindow *, GtkFileChooserAction, const gchar *, ...);\nstatic XX_gtk_file_chooser_dialog_new fl_gtk_file_chooser_dialog_new = NULL;\n\n// void gtk_file_chooser_add_filter(GtkFileChooser*, GtkFileFilter*);\ntypedef void (*XX_gtk_file_chooser_add_filter)(GtkFileChooser*, GtkFileFilter*);\nstatic XX_gtk_file_chooser_add_filter fl_gtk_file_chooser_add_filter = NULL;\n\n// GtkFileFilter* gtk_file_chooser_get_filter(GtkFileChooser*);\ntypedef GtkFileFilter* (*XX_gtk_file_chooser_get_filter)(GtkFileChooser*);\nstatic XX_gtk_file_chooser_get_filter fl_gtk_file_chooser_get_filter = NULL;\n\n// void gtk_file_chooser_set_filter(GtkFileChooser*, GtkFileFilter*);\ntypedef void (*XX_gtk_file_chooser_set_filter)(GtkFileChooser*, GtkFileFilter*);\nstatic XX_gtk_file_chooser_set_filter fl_gtk_file_chooser_set_filter = NULL;\n\n// GtkFileFilter * gtk_file_filter_new();\ntypedef GtkFileFilter* (*XX_gtk_file_filter_new)(void);\nstatic XX_gtk_file_filter_new fl_gtk_file_filter_new = NULL;\n\n// void gtk_file_filter_add_pattern(GtkFileFilter*, const gchar*);\ntypedef void (*XX_gtk_file_filter_add_pattern)(GtkFileFilter*, const gchar*);\nstatic XX_gtk_file_filter_add_pattern fl_gtk_file_filter_add_pattern = NULL;\n\n// void gtk_file_filter_add_custom(GtkFileFilter *filter, GtkFileFilterFlags needed,\n//  GtkFileFilterFunc func, gpointer data, GDestroyNotify notify);\ntypedef void (*XX_gtk_file_filter_add_custom)(GtkFileFilter *filter, GtkFileFilterFlags needed,\n\t\t\t\t\t      GtkFileFilterFunc func, gpointer data, \n\t\t\t\t\t      GDestroyNotify notify);\nstatic XX_gtk_file_filter_add_custom fl_gtk_file_filter_add_custom = NULL;\n\n// void gtk_file_filter_set_name(GtkFileFilter*, const gchar*);\ntypedef void (*XX_gtk_file_filter_set_name)(GtkFileFilter*, const gchar*);\nstatic XX_gtk_file_filter_set_name fl_gtk_file_filter_set_name = NULL;\n\n// const gchar* gtk_file_filter_get_name(GtkFileFilter*);\ntypedef const gchar* (*XX_gtk_file_filter_get_name)(GtkFileFilter*);\nstatic XX_gtk_file_filter_get_name fl_gtk_file_filter_get_name = NULL;\n\n// void gtk_file_chooser_set_extra_widget(GtkFileChooser *, GtkWidget *);\ntypedef void (*XX_gtk_file_chooser_set_extra_widget)(GtkFileChooser *, GtkWidget *);\nstatic XX_gtk_file_chooser_set_extra_widget fl_gtk_file_chooser_set_extra_widget = NULL;\n\n// void gtk_widget_show_now(GtkWidget *);\ntypedef void (*XX_gtk_widget_show_now)(GtkWidget *);\nstatic XX_gtk_widget_show_now fl_gtk_widget_show_now = NULL;\n\n// GdkWindow* gtk_widget_get_window(GtkWidget *);\ntypedef GdkWindow* (*XX_gtk_widget_get_window)(GtkWidget *);\nstatic XX_gtk_widget_get_window fl_gtk_widget_get_window = NULL;\n\n// Window gdk_x11_drawable_get_xid(GdkWindow *);\ntypedef Window (*XX_gdk_x11_drawable_get_xid)(GdkWindow *);\nstatic XX_gdk_x11_drawable_get_xid fl_gdk_x11_drawable_get_xid = NULL;\n\n// GtkWidget *gtk_check_button_new_with_label(const gchar *);\ntypedef GtkWidget* (*XX_gtk_check_button_new_with_label)(const gchar *);\nstatic XX_gtk_check_button_new_with_label fl_gtk_check_button_new_with_label = NULL;\n\n// gulong g_signal_connect_data(gpointer, const gchar *, GCallback, gpointer, GClosureNotify, GConnectFlags);\ntypedef gulong (*XX_g_signal_connect_data)(gpointer, const gchar *, GCallback, gpointer, GClosureNotify, GConnectFlags);\nstatic XX_g_signal_connect_data fl_g_signal_connect_data = NULL;\n\n// gboolean gtk_toggle_button_get_active(GtkToggleButton *);\ntypedef gboolean (*XX_gtk_toggle_button_get_active)(GtkToggleButton*);\nstatic XX_gtk_toggle_button_get_active fl_gtk_toggle_button_get_active = NULL;\n\n// void gtk_file_chooser_set_show_hidden(GtkFileChooser *, gboolean);\ntypedef void (*XX_gtk_file_chooser_set_show_hidden)(GtkFileChooser *, gboolean);\nstatic XX_gtk_file_chooser_set_show_hidden fl_gtk_file_chooser_set_show_hidden = NULL;\n\n// gboolean gtk_file_chooser_get_show_hidden(GtkFileChooser *);\ntypedef gboolean (*XX_gtk_file_chooser_get_show_hidden)(GtkFileChooser *);\nstatic XX_gtk_file_chooser_get_show_hidden fl_gtk_file_chooser_get_show_hidden = NULL;\n\n// void gtk_toggle_button_set_active(GtkToggleButton *, gboolean);\ntypedef void (*XX_gtk_toggle_button_set_active)(GtkToggleButton *, gboolean);\nstatic XX_gtk_toggle_button_set_active fl_gtk_toggle_button_set_active = NULL;\n\n\nFl_GTK_File_Chooser::Fl_GTK_File_Chooser(int val) : Fl_FLTK_File_Chooser(-1)\n{\n  gtkw_ptr   = NULL;    // used to hold a GtkWidget* \n  gtkw_slist = NULL;    // will hold the returned file names in a multi-selection...\n  gtkw_count = 0;       // How many items were selected?\n  gtkw_filename = NULL; // holds the last name we read back in a single file selection...\n  gtkw_title = NULL;    // dialog title\n  _btype = val;\n  previous_filter = NULL;\n}\n\nFl_GTK_File_Chooser::~Fl_GTK_File_Chooser()\n{\n  // Should free up resources taken for...\n  if(gtkw_ptr) { \n    fl_gtk_widget_destroy (gtkw_ptr);\n    gtkw_ptr = NULL;\n  }\n  if(gtkw_filename) {\n    fl_g_free(gtkw_filename);\n    gtkw_filename = NULL;\n  }\n  if(gtkw_slist) {\n    GSList *iter = (GSList *)gtkw_slist;\n    while(iter) {\n      if(iter->data) fl_g_free(iter->data);\n      iter = g_slist_next(iter);\n    }\n    fl_g_slist_free((GSList *)gtkw_slist);\n    gtkw_slist = NULL;\n  }\n  gtkw_count = 0; // assume we have no files selected now\n  gtkw_title = strfree(gtkw_title);\n}\n\nvoid Fl_GTK_File_Chooser::type(int val) {\n  _btype = val;\n}\n\nint Fl_GTK_File_Chooser::count() const {\n  return gtkw_count;\n}\n\nconst char *Fl_GTK_File_Chooser::filename() const\n{\n  if(gtkw_ptr) {\n    if(fl_gtk_file_chooser_get_select_multiple((GtkFileChooser *)gtkw_ptr) == FALSE) {\n      return gtkw_filename;\n    }\n    else {\n      GSList *iter = (GSList *)gtkw_slist;\n      char *nm = (char *)iter->data;\n      return nm;\n    }\n  }\n  return(\"\");\n}\n\nconst char *Fl_GTK_File_Chooser::filename(int i) const\n{\n  if(fl_gtk_file_chooser_get_select_multiple((GtkFileChooser *)gtkw_ptr) == FALSE) {\n    return gtkw_filename;\n  }\n  else {\n    if ((unsigned)i < gtkw_count) {\n      GSList *iter = (GSList *)gtkw_slist;\n      char *nm = (char *)fl_g_slist_nth_data(iter, i);\n      return nm;\n    }\n  }\n  return(\"\");\n}\n\nvoid Fl_GTK_File_Chooser::title(const char *val)\n{\n  strfree(gtkw_title);\n  gtkw_title = strnew(val);\n}\n\nconst char* Fl_GTK_File_Chooser::title() const\n{\n  return gtkw_title;\n}\n\n/* changes the extension of the outfile in the chooser according to newly selected filter */\nvoid Fl_GTK_File_Chooser::changed_output_type(const char *filter)\n{\n  if ( !(options()&Fl_Native_File_Chooser::USE_FILTER_EXT) ) return;\n  if (strchr(filter, '(') || strchr(filter, '{') || strchr(filter+1, '*') || strncmp(filter, \"*.\", 2)) return;\n  const char *p = fl_gtk_file_chooser_get_filename((GtkFileChooser*)gtkw_ptr);\n  if (!p) return;\n  p = fl_filename_name(p);\n  const char *q = strrchr(p, '.');\n  if (!q) q = p + strlen(p);\n  char *r = new char[strlen(p) + strlen(filter)];\n  strcpy(r, p);\n  strcpy(r + (q - p), filter + 1);\n  fl_gtk_file_chooser_set_current_name((GtkFileChooser*)gtkw_ptr, r);\n  delete[] r;\n}\n\n/* Filters files before display in chooser. \n Also used to detect when the filter just changed */\ngboolean Fl_GTK_File_Chooser::custom_gtk_filter_function(const GtkFileFilterInfo *info, Fl_GTK_File_Chooser::pair* p)\n{\n  if (p->running->previous_filter != p->filter) {\n    p->running->changed_output_type(p->filter);\n    p->running->previous_filter = p->filter;\n    }\n  return (gboolean)fl_filename_match(info->filename, p->filter);\n}\n\nvoid Fl_GTK_File_Chooser::free_pair(Fl_GTK_File_Chooser::pair *p)\n{\n  delete p;\n}\n\nstatic void hidden_files_cb(GtkToggleButton *togglebutton, gpointer user_data)\n{\n  gboolean state = fl_gtk_toggle_button_get_active(togglebutton);\n  fl_gtk_file_chooser_set_show_hidden((GtkFileChooser*)user_data, state);\n}\n\nint Fl_GTK_File_Chooser::show()\n{\n  // The point here is that after running a GTK dialog, the calling program's current locale is modified.\n  // To avoid that, we memorize the calling program's current locale, and the locale as modified\n  // by GTK after the first dialog use. We restore the calling program's current locale \n  // before returning, and we set the locale as modified by GTK before subsequent GTK dialog uses.\n  static bool first = true;\n  char *p;\n  char *before = NULL;\n  static char *gtk_wants = NULL;\n  // record in before the calling program's current locale\n  p = setlocale(LC_ALL, NULL);\n  if (p) before = strdup(p);\n  if (gtk_wants) { // set the locale as GTK 'wants it'\n    setlocale(LC_ALL, gtk_wants);\n  }\n  int retval = fl_gtk_chooser_wrapper(); // may change the locale\n  if (first) {\n    first = false;\n    // record in gtk_wants the locale as modified by the GTK dialog\n    p = setlocale(LC_ALL, NULL);\n    if (p) gtk_wants = strdup(p);\n  }\n  if (before) {\n    setlocale(LC_ALL, before); // restore calling program's current locale\n    free(before);\n    }\n  return retval;\n}\n\nstatic char *extract_dir_from_path(const char *path)\n{\n  static char *dir = NULL;\n  if (fl_filename_isdir(path)) {\n    return (char*)path;\n  }\n  if (*path != '/') return NULL;\n  if (dir) free(dir);\n  dir = strdup(path);\n  do {\n    char *p = strrchr(dir, '/');\n    if (p == dir) p++;\n    *p = 0;\n    }\n  while (!fl_filename_isdir(dir));\n  return dir;\n}\n\nstatic void run_response_handler(GtkDialog *dialog, gint response_id, gpointer data)\n{\n  gint *ri = (gint *)data;\n  *ri = response_id;\n}\n\n\nint Fl_GTK_File_Chooser::fl_gtk_chooser_wrapper()\n{\n  int result = 1;\n  static int have_gtk_init = 0;\n  char *p;\n  \n  if(!have_gtk_init) {\n    have_gtk_init = -1;\n    int ac = 0;\n    fl_gtk_init_check(&ac, NULL);\n  }\n  \n  if(gtkw_ptr) { // discard the previous dialog widget\n    fl_gtk_widget_destroy (gtkw_ptr);\n    gtkw_ptr = NULL;\n  }\n  \n  // set the dialog action type\n  GtkFileChooserAction gtw_action_type;\n  switch (_btype) {\n    case Fl_Native_File_Chooser::BROWSE_DIRECTORY:\n    case Fl_Native_File_Chooser::BROWSE_MULTI_DIRECTORY:\n      gtw_action_type = GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER;\n      break;\n      \n    case Fl_Native_File_Chooser::BROWSE_SAVE_FILE:\n      gtw_action_type = GTK_FILE_CHOOSER_ACTION_SAVE;\n      break;\n      \n    case Fl_Native_File_Chooser::BROWSE_SAVE_DIRECTORY:\n      gtw_action_type = GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER;\n      break;\n      \n    case Fl_Native_File_Chooser::BROWSE_MULTI_FILE:\n    case Fl_Native_File_Chooser::BROWSE_FILE:\n    default:\n      gtw_action_type = GTK_FILE_CHOOSER_ACTION_OPEN;\n      break;\n  }\n  // create a new dialog\n  gtkw_ptr = fl_gtk_file_chooser_dialog_new (gtkw_title,\n\t\t\t\t\t     NULL, /* parent_window */\n\t\t\t\t\t     gtw_action_type,\n\t\t\t\t\t     GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,\n\t\t\t\t\t     gtw_action_type == GTK_FILE_CHOOSER_ACTION_SAVE || gtw_action_type == GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER ? \n\t\t\t\t\t     GTK_STOCK_SAVE : GTK_STOCK_OPEN, \n\t\t\t\t\t     GTK_RESPONSE_ACCEPT,\n\t\t\t\t\t     NULL);\n  // did we create a valid dialog widget?\n  if(!gtkw_ptr) {\n    // fail\n    return -1;\n  }\n  \n  // set the dialog properties\n  switch (_btype) {\n    case Fl_Native_File_Chooser::BROWSE_MULTI_DIRECTORY:\n    case Fl_Native_File_Chooser::BROWSE_MULTI_FILE:\n      fl_gtk_file_chooser_set_select_multiple((GtkFileChooser *)gtkw_ptr, TRUE);\n      break;\n      \n    case Fl_Native_File_Chooser::BROWSE_SAVE_FILE:\n      if (_preset_file)fl_gtk_file_chooser_set_current_name ((GtkFileChooser *)gtkw_ptr, fl_filename_name(_preset_file));\n      /* FALLTHROUGH */\n    case Fl_Native_File_Chooser::BROWSE_SAVE_DIRECTORY:\n      fl_gtk_file_chooser_set_create_folders((GtkFileChooser *)gtkw_ptr, TRUE);\n      fl_gtk_file_chooser_set_do_overwrite_confirmation ((GtkFileChooser *)gtkw_ptr, (_options & Fl_Native_File_Chooser::SAVEAS_CONFIRM)?TRUE:FALSE);\n      break;\n      \n    case Fl_Native_File_Chooser::BROWSE_DIRECTORY:\n    case Fl_Native_File_Chooser::BROWSE_FILE:\n    default:\n      break;\n  }\n  \n  if (_directory && _directory[0]) {\n    p = extract_dir_from_path(_directory);\n    if (p) fl_gtk_file_chooser_set_current_folder((GtkFileChooser *)gtkw_ptr, p);\n  }\n  else if (_preset_file) {\n    p = extract_dir_from_path(_preset_file);\n    if (p) fl_gtk_file_chooser_set_current_folder((GtkFileChooser *)gtkw_ptr, p);\n  }\n  \n  GtkFileFilter **filter_tab = NULL;\n  if (_parsedfilt) {\n    filter_tab = new GtkFileFilter*[_nfilters];\n    char *filter = strdup(_parsedfilt);\n    p = strtok(filter, \"\\t\");\n    int count = 0;\n    while (p) {\n      filter_tab[count] = fl_gtk_file_filter_new();\n      fl_gtk_file_filter_set_name(filter_tab[count], p);\n      p = strchr(p, '(') + 1;\n      char *q = strchr(p, ')'); *q = 0;\n      fl_gtk_file_filter_add_custom(filter_tab[count], \n\t\t\t\t    GTK_FILE_FILTER_FILENAME, \n\t\t\t\t    (GtkFileFilterFunc)Fl_GTK_File_Chooser::custom_gtk_filter_function, \n\t\t\t\t    new Fl_GTK_File_Chooser::pair(this, p), \n\t\t\t\t    (GDestroyNotify)Fl_GTK_File_Chooser::free_pair);\n      fl_gtk_file_chooser_add_filter((GtkFileChooser *)gtkw_ptr, filter_tab[count]);\n      p = strtok(NULL, \"\\t\");\n      count++;\n    }\n    free(filter);\n    fl_gtk_file_chooser_set_filter((GtkFileChooser *)gtkw_ptr, filter_tab[_filtvalue < _nfilters?_filtvalue:0]);\n    previous_filter = NULL;\n    if (gtw_action_type == GTK_FILE_CHOOSER_ACTION_OPEN) {\n      GtkFileFilter* gfilter = fl_gtk_file_filter_new();\n      fl_gtk_file_filter_set_name(gfilter, Fl_File_Chooser::all_files_label);\n      fl_gtk_file_filter_add_pattern(gfilter, \"*\");\n      fl_gtk_file_chooser_add_filter((GtkFileChooser *)gtkw_ptr, gfilter);\n    }\n  }\n  \n  GtkWidget *toggle = fl_gtk_check_button_new_with_label(Fl_File_Chooser::hidden_label);\n  fl_gtk_file_chooser_set_extra_widget((GtkFileChooser *)gtkw_ptr, toggle);\n  fl_g_signal_connect_data(toggle, \"toggled\", G_CALLBACK(hidden_files_cb), gtkw_ptr, NULL, (GConnectFlags) 0);\n  Fl_Window* firstw = Fl::first_window();\n  fl_gtk_widget_show_now(gtkw_ptr); // map the GTK window on screen\n  if (firstw) {\n    GdkWindow* gdkw = fl_gtk_widget_get_window(gtkw_ptr);\n    Window xw = fl_gdk_x11_drawable_get_xid(gdkw); // get the X11 ref of the GTK window\n    XSetTransientForHint(fl_display, xw, fl_xid(firstw)); // set the GTK window transient for the last FLTK win\n    }\n  gboolean state = fl_gtk_file_chooser_get_show_hidden((GtkFileChooser *)gtkw_ptr);\n  fl_gtk_toggle_button_set_active((GtkToggleButton *)toggle, state);\n  \n  gint response_id = GTK_RESPONSE_NONE;\n  fl_g_signal_connect_data(gtkw_ptr, \"response\", G_CALLBACK(run_response_handler), &response_id, NULL, (GConnectFlags) 0);\n  while (response_id == GTK_RESPONSE_NONE) { // loop that shows the GTK dialog window\n    fl_gtk_main_iteration(); // one iteration of the GTK event loop\n    while (XEventsQueued(fl_display, QueuedAfterReading)) { // emulate modal dialog\n      XEvent xevent;\n      XNextEvent(fl_display, &xevent);\n      Window xid = xevent.xany.window;\n      if (xevent.type == ConfigureNotify) xid = xevent.xmaprequest.window;\n      if (!fl_find(xid)) continue; // skip events to non-FLTK windows\n      // process Expose and ConfigureNotify events\n      if ( xevent.type == Expose || xevent.type == ConfigureNotify ) fl_handle(xevent); \n    }\n    Fl::flush(); // do the drawings needed after Expose events\n  } \n  \n  if (response_id == GTK_RESPONSE_ACCEPT) {\n    if (_parsedfilt) {\n      GtkFileFilter *gfilter = fl_gtk_file_chooser_get_filter((GtkFileChooser *)gtkw_ptr);\n      for (_filtvalue = 0; _filtvalue < _nfilters; _filtvalue++) {\n\tif (filter_tab[_filtvalue] == gfilter) break;\n      }\n    }\n    \n    // discard any filenames or lists from previous calls\n    if(gtkw_filename) {\n      fl_g_free(gtkw_filename);\n      gtkw_filename = NULL;\n    }\n    if(gtkw_slist) {\n      GSList *iter = (GSList *)gtkw_slist;\n      while(iter) {\n        if(iter->data) fl_g_free(iter->data);\n        iter = g_slist_next(iter);\n      }\n      fl_g_slist_free((GSList *)gtkw_slist);\n      gtkw_slist = NULL;\n    }\n    gtkw_count = 0; // assume we have no files selected now\n    \n    if(fl_gtk_file_chooser_get_select_multiple((GtkFileChooser *)gtkw_ptr) == FALSE) {\n      gtkw_filename = fl_gtk_file_chooser_get_filename ((GtkFileChooser *)gtkw_ptr);\n      if (gtkw_filename) {\n        gtkw_count = 1;\n        result = 0;\n        //printf(\"single: %s\\n\", gtkw_filename);\n      }\n    }\n    else {\n      gtkw_slist = fl_gtk_file_chooser_get_filenames((GtkFileChooser *)gtkw_ptr);\n      gtkw_count = fl_g_slist_length((GSList *)gtkw_slist);\n      if(gtkw_count) result = 0;\n      \n      //      puts(\"multiple\");\n      //      GSList *iter = (GSList *)gtkw_slist;\n      //      printf (\"Selected %d files\\n\", gtkw_count);\n      //      while(iter) {\n      //        char *nm = (char *)iter->data;\n      //        printf(\"%s\\n\", nm);\n      //        iter = g_slist_next(iter);\n      //      }\n    }\n  }\n  delete[] filter_tab;\n  if ( response_id == GTK_RESPONSE_DELETE_EVENT) gtkw_ptr = NULL;\n  else fl_gtk_widget_hide (gtkw_ptr);\n  \n  // I think this is analogus to doing an Fl::check() - we need this here to make sure\n  // the GtkFileChooserDialog is removed from the display correctly\n  while (fl_gtk_events_pending ()) fl_gtk_main_iteration (); \n  \n  return result;\n} // fl_gtk_chooser_wrapper\n\n#if HAVE_DLSYM && HAVE_DLFCN_H\n// macro to help with the symbol loading boilerplate...\n#  define GET_SYM(SSS, LLL) \\\ndlerror();    /* Clear any existing error */  \\\nfl_##SSS = (XX_##SSS)dlsym(LLL, #SSS);        \\\nif ((pc_dl_error = dlerror()) != NULL)  {     \\\nfprintf(stderr, \"%s\\n\", pc_dl_error);       \\\ndid_find_GTK_libs = 0;                      \\\nreturn; }\n\nstatic void* fl_dlopen(const char *filename1, const char *filename2)\n{\n  void *ptr = dlopen(filename1, RTLD_LAZY | RTLD_GLOBAL);\n  if (!ptr) ptr = dlopen(filename2, RTLD_LAZY | RTLD_GLOBAL);\n  return ptr;\n}\n#endif\n\n/* \n * Use dlopen to see if we can load the gtk dynamic libraries that\n * will allow us to create a GtkFileChooserDialog() on the fly,\n * without linking to the GTK libs at compile time.\n */\nvoid Fl_GTK_File_Chooser::probe_for_GTK_libs(void) {\n#if HAVE_DLSYM && HAVE_DLFCN_H\n  void *ptr_glib    = NULL;\n  void *ptr_gtk     = NULL;\n  \n#   ifdef __APPLE_CC__ // allows testing on Darwin + X11\n  ptr_glib    = dlopen(\"/sw/lib/libglib-2.0.dylib\", RTLD_LAZY | RTLD_GLOBAL);\n#   else\n  ptr_glib    = fl_dlopen(\"libglib-2.0.so\", \"libglib-2.0.so.0\");\n#   endif\n  // Try first with GTK2\n#   ifdef __APPLE_CC__ // allows testing on Darwin + X11\n  ptr_gtk     = dlopen(\"/sw/lib/libgtk-x11-2.0.dylib\", RTLD_LAZY | RTLD_GLOBAL);\n#else\n  ptr_gtk     = fl_dlopen(\"libgtk-x11-2.0.so\", \"libgtk-x11-2.0.so.0\");\n#endif\n  if (ptr_gtk && ptr_glib) {\n#ifdef DEBUG\n    puts(\"selected GTK-2\\n\");\n#endif\n  }\n  else {// Try then with GTK3\n    ptr_gtk     = fl_dlopen(\"libgtk-3.so\", \"libgtk-3.so.0\");\n#ifdef DEBUG\n    if (ptr_gtk && ptr_glib) {\n      puts(\"selected GTK-3\\n\");\n    }\n#endif\n  }\n  \n  if((!ptr_glib) || (!ptr_gtk)) {\n#ifdef DEBUG\n    puts(\"Failure to load libglib or libgtk\");\n#endif\n    did_find_GTK_libs = 0;\n    return;\n  }\n  \n  char *pc_dl_error; // used to report errors by the GET_SYM macro...\n  // items we need from GLib\n  GET_SYM(g_free, ptr_glib);\n  GET_SYM(g_slist_nth_data, ptr_glib);\n  GET_SYM(g_slist_length, ptr_glib);\n  GET_SYM(g_slist_free, ptr_glib);\n  // items we need from GTK\n  GET_SYM(gtk_init_check, ptr_gtk);\n  GET_SYM(gtk_widget_destroy, ptr_gtk);\n  GET_SYM(gtk_file_chooser_set_select_multiple, ptr_gtk);\n  GET_SYM(gtk_file_chooser_set_do_overwrite_confirmation, ptr_gtk);\n  GET_SYM(gtk_file_chooser_set_current_name, ptr_gtk);\n  GET_SYM(gtk_file_chooser_set_current_folder, ptr_gtk);\n  GET_SYM(gtk_file_chooser_set_create_folders, ptr_gtk);\n  GET_SYM(gtk_file_chooser_get_select_multiple, ptr_gtk);\n  GET_SYM(gtk_widget_hide, ptr_gtk);\n  GET_SYM(gtk_file_chooser_get_filename, ptr_gtk);\n  GET_SYM(gtk_file_chooser_get_filenames, ptr_gtk);\n  GET_SYM(gtk_main_iteration, ptr_gtk);\n  GET_SYM(gtk_events_pending, ptr_gtk);\n  GET_SYM(gtk_file_chooser_dialog_new, ptr_gtk);\n  GET_SYM(gtk_file_chooser_add_filter, ptr_gtk);\n  GET_SYM(gtk_file_chooser_get_filter, ptr_gtk);\n  GET_SYM(gtk_file_chooser_set_filter, ptr_gtk);\n  GET_SYM(gtk_file_filter_new, ptr_gtk);\n  GET_SYM(gtk_file_filter_add_pattern, ptr_gtk);\n  GET_SYM(gtk_file_filter_add_custom, ptr_gtk);\n  GET_SYM(gtk_file_filter_set_name, ptr_gtk);\n  GET_SYM(gtk_file_filter_get_name, ptr_gtk);\n  GET_SYM(gtk_file_chooser_set_extra_widget, ptr_gtk);\n  GET_SYM(gtk_widget_show_now, ptr_gtk);\n  GET_SYM(gtk_widget_get_window, ptr_gtk);\n  GET_SYM(gdk_x11_drawable_get_xid, ptr_gtk);\n  GET_SYM(gtk_check_button_new_with_label, ptr_gtk);\n  GET_SYM(g_signal_connect_data, ptr_gtk);\n  GET_SYM(gtk_toggle_button_get_active, ptr_gtk);\n  GET_SYM(gtk_file_chooser_set_show_hidden, ptr_gtk);\n  GET_SYM(gtk_file_chooser_get_show_hidden, ptr_gtk);\n  GET_SYM(gtk_toggle_button_set_active, ptr_gtk);\n  \n  did_find_GTK_libs = 1;\n#endif\n} // probe_for_GTK_libs\n\n//\n// End of \"$Id$\".\n//\n",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/src/Fl_Window_shape.cxx": "//\n// \"$Id: Fl_Window_shape.cxx 10348 2014-10-01 16:37:13Z manolo $\"\n//\n// implementation of Fl_Window::shape(Fl_Image*) for the Fast Light Tool Kit (FLTK).\n//\n// Copyright 2010-2014 by Bill Spitzak and others.\n//\n// This library is free software. Distribution and use rights are outlined in\n// the file \"COPYING\" which should have been included with this file.  If this\n// file is missing or damaged, see the license at:\n//\n//     http://www.fltk.org/COPYING.php\n//\n// Please report all bugs and problems to:\n//\n//     http://www.fltk.org/str.php\n//\n\n#include <FL/Fl.H>\n#include <FL/fl_draw.H>\n#include <FL/x.H>\n#include <FL/Fl_Window.H>\n#include <FL/Fl_Bitmap.H>\n#include <FL/Fl_Pixmap.H>\n#include <string.h>\n\n#ifdef WIN32\n# include <malloc.h> // needed for VisualC2010\n#elif !defined(__APPLE__)\n#include <config.h>\n#if HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n#define ShapeBounding\t\t\t0\n#define ShapeSet\t\t\t0\n#endif\n\n\n#if defined(__APPLE__)\n\nstatic void MyProviderReleaseData (void *info, const void *data, size_t size) {\n  delete[] (uchar*)data;\n}\n\n// bitwise inversion of all 4-bit quantities\nstatic const unsigned char swapped[16] = {0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15};\n\nstatic inline uchar swap_byte(const uchar b) {\n  // reverse the order of bits of byte b: 1->8 becomes 8->1\n  return (swapped[b & 0xF] << 4) | swapped[b >> 4];\n}\n\n#elif defined(WIN32)\n\nstatic inline BYTE bit(int x) { return (BYTE)(1 << (x%8)); }\n\nstatic HRGN bitmap2region(Fl_Bitmap* image) {\n  HRGN hRgn = 0;\n  /* Does this need to be dynamically determined, perhaps? */\n  const int ALLOC_UNIT = 100;\n  DWORD maxRects = ALLOC_UNIT;\n  \n  RGNDATA* pData = (RGNDATA*)malloc(sizeof(RGNDATAHEADER)+(sizeof(RECT)*maxRects));\n  pData->rdh.dwSize = sizeof(RGNDATAHEADER);\n  pData->rdh.iType = RDH_RECTANGLES;\n  pData->rdh.nCount = pData->rdh.nRgnSize = 0;\n  SetRect(&pData->rdh.rcBound, MAXLONG, MAXLONG, 0, 0);\n  \n  const int bytesPerLine = (image->w() + 7)/8;\n  BYTE* p, *data = (BYTE*)image->array;\n  for (int y = 0; y < image->h(); y++) {\n    // each row, left to right\n    for (int x = 0; x < image->w(); x++) {\n      int x0 = x;\n      while (x < image->w()) {\n\tp = data + x / 8;\n\tif (!((*p) & bit(x))) break; // transparent pixel\n\tx++;\n      }\n      if (x > x0) {\n\tRECT *pr;\n\t/* Add the pixels (x0, y) to (x, y+1) as a new rectangle\n\t * in the region\n\t */\n\tif (pData->rdh.nCount >= maxRects) {\n\t  maxRects += ALLOC_UNIT;\n\t  pData = (RGNDATA*)realloc(pData, sizeof(RGNDATAHEADER)\n\t\t\t\t    + (sizeof(RECT)*maxRects));\n\t}\n\tpr = (RECT*)&pData->Buffer;\n\tSetRect(&pr[pData->rdh.nCount], x0, y, x, y+1);\n\tif (x0 < pData->rdh.rcBound.left)\n\t  pData->rdh.rcBound.left = x0;\n\tif (y < pData->rdh.rcBound.top)\n\t  pData->rdh.rcBound.top = y;\n\tif (x > pData->rdh.rcBound.right)\n\t  pData->rdh.rcBound.right = x;\n\tif (y+1 > pData->rdh.rcBound.bottom)\n\t  pData->rdh.rcBound.bottom = y+1;\n\tpData->rdh.nCount++;\n\t/* On Windows98, ExtCreateRegion() may fail if the\n\t * number of rectangles is too large (ie: >\n\t * 4000). Therefore, we have to create the region by\n\t * multiple steps.\n\t */\n\tif (pData->rdh.nCount == 2000) {\n\t  HRGN h = ExtCreateRegion(NULL, sizeof(RGNDATAHEADER)\n\t\t\t\t   + (sizeof(RECT)*maxRects), pData);\n\t  if (hRgn) {\n\t    CombineRgn(hRgn, hRgn, h, RGN_OR);\n\t    DeleteObject(h);\n\t  } else \n\t    hRgn = h;\n\t  pData->rdh.nCount = 0;\n\t  SetRect(&pData->rdh.rcBound, MAXLONG, MAXLONG, 0, 0);\n\t}\n      }\n    }\n    /* Go to next row */\n    data += bytesPerLine;\n  }\n  /* Create or extend the region with the remaining rectangles*/\n  HRGN h = ExtCreateRegion(NULL, sizeof(RGNDATAHEADER)\n\t\t\t   + (sizeof(RECT)*maxRects), pData);\n  if (hRgn) {\n    CombineRgn(hRgn, hRgn, h, RGN_OR);\n    DeleteObject(h);\n  } else hRgn = h;\n  free(pData); // I've created the region so I can free this now, right?\n  return hRgn;\n}\n\n#else\n\n#ifndef FL_DOXYGEN\nvoid Fl_Window::combine_mask()\n{\n  typedef void (*XShapeCombineMask_type)(Display*, int, int, int, int, Pixmap, int);\n  static XShapeCombineMask_type XShapeCombineMask_f = NULL;\n  static int beenhere = 0;\n  typedef Bool (*XShapeQueryExtension_type)(Display*, int*, int*);\n  if (!beenhere) {\n    beenhere = 1;\n#if HAVE_DLSYM && HAVE_DLFCN_H\n    fl_open_display();\n    void *handle = dlopen(NULL, RTLD_LAZY); // search symbols in executable\n    XShapeQueryExtension_type XShapeQueryExtension_f = (XShapeQueryExtension_type)dlsym(handle, \"XShapeQueryExtension\");\n    XShapeCombineMask_f = (XShapeCombineMask_type)dlsym(handle, \"XShapeCombineMask\");\n    // make sure that the X server has the SHAPE extension\n    int error_base, shapeEventBase;\n    if ( !( XShapeQueryExtension_f && XShapeCombineMask_f &&\n\t   XShapeQueryExtension_f(fl_display, &shapeEventBase, &error_base) ) ) XShapeCombineMask_f = NULL;\n#endif\n  }\n  if (!XShapeCombineMask_f) return;\n  shape_data_->lw_ = w();\n  shape_data_->lh_ = h();\n  Fl_Bitmap* temp = (Fl_Bitmap*)shape_data_->shape_->copy(shape_data_->lw_, shape_data_->lh_);\n  Pixmap pbitmap = XCreateBitmapFromData(fl_display, fl_xid(this), \n\t\t\t\t\t (const char*)temp->array,\n\t\t\t\t\t temp->w(), temp->h());\n  XShapeCombineMask_f(fl_display, fl_xid(this), ShapeBounding, 0, 0, pbitmap, ShapeSet);\n  if (pbitmap != None) XFreePixmap(fl_display, pbitmap);\n  delete temp;\n}\n#endif // !FL_DOXYGEN\n\n#endif // __APPLE__\n\n\nvoid Fl_Window::shape_bitmap_(Fl_Bitmap* b) {\n  shape_data_->shape_ = b;\n#if defined(__APPLE__)\n  if (b) {\n    // complement mask bits and perform bitwise inversion of all bytes and also reverse top and bottom\n    int bytes_per_row = (b->w() + 7)/8;\n    uchar *from = new uchar[bytes_per_row * b->h()];\n    for (int i = 0; i < b->h(); i++) {\n      uchar *p = (uchar*)b->array + bytes_per_row * i;\n      uchar *last = p + bytes_per_row;\n      uchar *q = from + (b->h() - 1 - i) * bytes_per_row;\n      while (p < last) {\n        *q++ = swap_byte(~*p++);\n      }\n    }\n    CGDataProviderRef provider = CGDataProviderCreateWithData(NULL, from, bytes_per_row * b->h(), MyProviderReleaseData);\n    shape_data_->mask = CGImageMaskCreate(b->w(), b->h(), 1, 1, bytes_per_row, provider, NULL, false);\n    CFRelease(provider);\n  }  \n#endif\n}\n\n\n#if defined(__APPLE__) // on the mac, use an 8-bit mask\n/* the image can be of any depth\n offset gives the byte offset from the pixel start to the byte used to construct the shape\n */\nvoid Fl_Window::shape_alpha_(Fl_RGB_Image* img, int offset) {\n  int i, d = img->d(), w = img->w(), h = img->h();\n  shape_data_->shape_ = img;\n  if (shape_data_->shape_) {\n    // reverse top and bottom and convert to gray scale if img->d() == 3 and complement bits\n    int bytes_per_row = w * d;\n    uchar *from = new uchar[w * h];\n    for ( i = 0; i < h; i++) {\n      uchar *p = (uchar*)img->array + bytes_per_row * i + offset;\n      uchar *last = p + bytes_per_row;\n      uchar *q = from + (h - 1 - i) * w;\n      while (p < last) {\n        if (d == 3) {\n          unsigned u = *p++;\n          u += *p++;\n          u += *p++;\n          *q++ = ~(u/3);\n        }\n        else {\n          *q++ = ~(*p);\n          p += d;\n        }\n      }\n    }\n    CGDataProviderRef provider = CGDataProviderCreateWithData(NULL, from, w * h, MyProviderReleaseData);\n    shape_data_->mask = CGImageMaskCreate(w, h, 8, 8, w, provider, NULL, false);\n    CFRelease(provider);\n  }  \n}\n\n#else\n\n/* the img image can be of any depth\n offset gives the byte offset from the pixel start to the byte used to construct the shape\n */\nvoid Fl_Window::shape_alpha_(Fl_RGB_Image* img, int offset) {\n  int i, j, d = img->d(), w = img->w(), h = img->h(), bytesperrow = (w+7)/8;\n  unsigned u;\n  uchar byte, onebit;\n  // build an Fl_Bitmap covering the non-fully transparent/black part of the image\n  const uchar* bits = new uchar[h*bytesperrow]; // to store the bitmap\n  const uchar* alpha = img->array + offset; // points to alpha value of rgba pixels\n  for (i = 0; i < h; i++) {\n    uchar *p = (uchar*)bits + i * bytesperrow;\n    byte = 0;\n    onebit = 1;\n    for (j = 0; j < w; j++) {\n      if (d == 3) {\n        u = *alpha;\n        u += *(alpha+1);\n        u += *(alpha+2);\n      }\n      else u = *alpha;\n      if (u > 0) { // if the pixel is not fully transparent/black\n        byte |= onebit; // turn on the corresponding bit of the bitmap\n      }\n      onebit = onebit << 1; // move the single set bit one position to the left\n      if (onebit == 0 || j == w-1) {\n        onebit = 1;\n        *p++ = byte; // store in bitmap one pack of bits\n        byte = 0;\n      }\n      alpha += d; // point to alpha value of next pixel\n    }\n  }\n  Fl_Bitmap* bitmap = new Fl_Bitmap(bits, w, h);\n  bitmap->alloc_array = 1;\n  shape_bitmap_(bitmap);\n  shape_data_->todelete_ = bitmap;\n}\n\n#endif\n\n\nvoid Fl_Window::shape_pixmap_(Fl_Pixmap* pixmap) {\n  Fl_RGB_Image* rgba = new Fl_RGB_Image(pixmap);\n  shape_alpha_(rgba, 3);\n  delete rgba;\n}\n\n#if FLTK_ABI_VERSION < 10303 && !defined(FL_DOXYGEN)\nFl_Window::shape_data_type* Fl_Window::shape_data_ = NULL;\n#endif\n\n/** Assigns a non-rectangular shape to the window.\n This function gives an arbitrary shape (not just a rectangular region) to an Fl_Window.\n An Fl_Image of any dimension can be used as mask; it is rescaled to the window's dimension as needed.\n \n The layout and widgets inside are unaware of the mask shape, and most will act as though the window's\n rectangular bounding box is available\n to them. It is up to you to make sure they adhere to the bounds of their masking shape.\n \n The \\p img argument can be an Fl_Bitmap, Fl_Pixmap or Fl_RGB_Image:\n \\li With Fl_Bitmap or Fl_Pixmap, the shaped window covers the image part where bitmap bits equal one,\n or where the pixmap is not fully transparent.\n \\li With an Fl_RGB_Image with an alpha channel (depths 2 or 4), the shaped window covers the image part\n that is not fully transparent.\n \\li With an Fl_RGB_Image of depth 1 (gray-scale) or 3 (RGB), the shaped window covers the non-black image part.\n \n Platform details:\n \\li On the unix/linux platform, the SHAPE extension of the X server is required.\n This function does control the shape of Fl_Gl_Window instances.\n \\li On the MSWindows platform, this function does nothing with class Fl_Gl_Window.\n \\li On the Mac platform, OS version 10.4 or above is required. \n An 8-bit shape-mask is used when \\p img is an Fl_RGB_Image:\n with depths 2 or 4, the image alpha channel becomes the shape mask such that areas with alpha = 0\n are out of the shaped window;\n with depths 1 or 3, white and black are in and out of the\n shaped window, respectively, and other colors give intermediate masking scores.\n This function does nothing with class Fl_Gl_Window.\n\n The window borders and caption created by the window system are turned off by default. They\n can be re-enabled by calling Fl_Window::border(1).\n \n A usage example is found at example/shapedwindow.cxx.\n \n \\version 1.3.3 (and requires compilation with -DFLTK_ABI_VERSION = 10303)\n */\nvoid Fl_Window::shape(const Fl_Image* img) {\n#if FLTK_ABI_VERSION >= 10303\n  if (shape_data_) {\n    if (shape_data_->todelete_) { delete shape_data_->todelete_; }\n#if defined(__APPLE__)\n    if (shape_data_->mask) { CGImageRelease(shape_data_->mask); }\n#endif\n    }\n  else {\n    shape_data_ = new shape_data_type;\n    }\n  memset(shape_data_, 0, sizeof(shape_data_type));\n  border(false);\n  int d = img->d();\n  if (d && img->count() >= 2) shape_pixmap_((Fl_Pixmap*)img);\n  else if (d == 0) shape_bitmap_((Fl_Bitmap*)img);\n  else if (d == 2 || d == 4) shape_alpha_((Fl_RGB_Image*)img, d - 1);\n  else if ((d == 1 || d == 3) && img->count() == 1) shape_alpha_((Fl_RGB_Image*)img, 0);\n#endif\n}\n\nvoid Fl_Window::draw() {\n  if (shape_data_) {\n# if defined(__APPLE__) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_4\n    if (shape_data_->mask && (CGContextClipToMask != NULL)) {\n      CGContextClipToMask(fl_gc, CGRectMake(0,0,w(),h()), shape_data_->mask); // requires Mac OS 10.4\n    }\n    CGContextSaveGState(fl_gc);\n#elif defined(WIN32)\n    if ((shape_data_->lw_ != w() || shape_data_->lh_ != h()) && shape_data_->shape_) {\n      // size of window has changed since last time\n      shape_data_->lw_ = w();\n      shape_data_->lh_ = h();\n      Fl_Bitmap* temp = (Fl_Bitmap*)shape_data_->shape_->copy(shape_data_->lw_, shape_data_->lh_);\n      HRGN region = bitmap2region(temp);\n      SetWindowRgn(fl_xid(this), region, TRUE); // the system deletes the region when it's no longer needed\n      delete temp;\n    }\n#elif !(defined(__APPLE__) || defined(WIN32))\n    if (( shape_data_->lw_ != w() || shape_data_->lh_ != h() ) && shape_data_->shape_) {\n        // size of window has changed since last time\n    combine_mask();\n    }\n# endif\n  }\n  \n  // The following is similar to Fl_Group::draw(), but ...\n  //  - we draw the box with x=0 and y=0 instead of x() and y()\n  //  - we don't draw a label\n  \n  if (damage() & ~FL_DAMAGE_CHILD) {\t // draw the entire thing\n    draw_box(box(),0,0,w(),h(),color()); // draw box with x/y = 0\n  }\n  draw_children();\n  \n#ifdef __APPLE_QUARTZ__\n  // on OS X, windows have no frame. Before OS X 10.7, to resize a window, we drag the lower right\n  // corner. This code draws a little ribbed triangle for dragging.\n  if (fl_mac_os_version < 100700 && fl_gc && !parent() && resizable() &&\n      (!size_range_set || minh!=maxh || minw!=maxw)) {\n    int dx = Fl::box_dw(box())-Fl::box_dx(box());\n    int dy = Fl::box_dh(box())-Fl::box_dy(box());\n    if (dx<=0) dx = 1;\n    if (dy<=0) dy = 1;\n    int x1 = w()-dx-1, x2 = x1, y1 = h()-dx-1, y2 = y1;\n    Fl_Color c[4] = {\n      color(),\n      fl_color_average(color(), FL_WHITE, 0.7f),\n      fl_color_average(color(), FL_BLACK, 0.6f),\n      fl_color_average(color(), FL_BLACK, 0.8f),\n    };\n    int i;\n    for (i=dx; i<12; i++) {\n      fl_color(c[i&3]);\n      fl_line(x1--, y1, x2, y2--);\n    }\n  }\n#endif\n# if defined(__APPLE__) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_4\n  if (shape_data_) CGContextRestoreGState(fl_gc);\n# endif\n  \n# if defined(FLTK_USE_CAIRO)\n  Fl::cairo_make_current(this); // checkout if an update is necessary\n# endif\n}\n\n\n\n//\n// End of \"$Id: Fl_Window_shape.cxx 10348 2014-10-01 16:37:13Z manolo $\".\n//\n",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/src/Fl_x.cxx": "//\n// \"$Id: Fl_x.cxx 10412 2014-10-29 20:25:46Z cand $\"\n//\n// X specific code for the Fast Light Tool Kit (FLTK).\n//\n// Copyright 1998-2012 by Bill Spitzak and others.\n//\n// This library is free software. Distribution and use rights are outlined in\n// the file \"COPYING\" which should have been included with this file.  If this\n// file is missing or damaged, see the license at:\n//\n//     http://www.fltk.org/COPYING.php\n//\n// Please report all bugs and problems on the following page:\n//\n//     http://www.fltk.org/str.php\n//\n\n#ifdef WIN32\n//#  include \"Fl_win32.cxx\"\n#elif defined(__APPLE__)\n//#  include \"Fl_mac.cxx\"\t// now Fl_cocoa.mm\n#elif !defined(FL_DOXYGEN)\n\n#  define CONSOLIDATE_MOTION 1\n/**** Define this if your keyboard lacks a backspace key... ****/\n/* #define BACKSPACE_HACK 1 */\n\n#  include <config.h>\n#  include <FL/Fl.H>\n#  include <FL/x.H>\n#  include <FL/Fl_Window.H>\n#  include <FL/fl_utf8.h>\n#  include <FL/Fl_Tooltip.H>\n#  include <FL/fl_draw.H>\n#  include <FL/Fl_Paged_Device.H>\n#  include <FL/Fl_Shared_Image.H>\n#  include <FL/fl_ask.H>\n#  include <FL/filename.H>\n#  include <stdio.h>\n#  include <stdlib.h>\n#  include \"flstring.h\"\n#  include <unistd.h>\n#  include <time.h>\n#  include <sys/time.h>\n#  include <X11/Xmd.h>\n#  include <X11/Xlocale.h>\n#  include <X11/Xlib.h>\n#  include <X11/keysym.h>\n#  include \"Xutf8.h\"\n#define USE_XRANDR (HAVE_DLSYM && HAVE_DLFCN_H) // means attempt to dynamically load libXrandr.so\n#if USE_XRANDR\n#include <dlfcn.h>\n#define RRScreenChangeNotifyMask  (1L << 0) // from X11/extensions/Xrandr.h\n#define RRScreenChangeNotify\t0           // from X11/extensions/Xrandr.h\ntypedef int (*XRRUpdateConfiguration_type)(XEvent *event);\nstatic XRRUpdateConfiguration_type XRRUpdateConfiguration_f;\nstatic int randrEventBase;                  // base of RandR-defined events\n#endif\n\n#  if HAVE_XFIXES\n#  include <X11/extensions/Xfixes.h>\nstatic int xfixes_event_base = 0;\nstatic bool have_xfixes = false;\n#  endif\n\n#  include <X11/cursorfont.h>\n\n#  if HAVE_XCURSOR\n#    include <X11/Xcursor/Xcursor.h>\n#  endif\nstatic Fl_Xlib_Graphics_Driver fl_xlib_driver;\nstatic Fl_Display_Device fl_xlib_display(&fl_xlib_driver);\nFl_Display_Device *Fl_Display_Device::_display = &fl_xlib_display;// the platform display\n\n////////////////////////////////////////////////////////////////\n// interface to poll/select call:\n\n#  if USE_POLL\n\n#    include <poll.h>\nstatic pollfd *pollfds = 0;\n\n#  else\n#    if HAVE_SYS_SELECT_H\n#      include <sys/select.h>\n#    endif /* HAVE_SYS_SELECT_H */\n\n// The following #define is only needed for HP-UX 9.x and earlier:\n//#define select(a,b,c,d,e) select((a),(int *)(b),(int *)(c),(int *)(d),(e))\n\nstatic fd_set fdsets[3];\nstatic int maxfd;\n#    define POLLIN 1\n#    define POLLOUT 4\n#    define POLLERR 8\n\n#  endif /* USE_POLL */\n\nstatic int nfds = 0;\nstatic int fd_array_size = 0;\nstruct FD {\n#  if !USE_POLL\n  int fd;\n  short events;\n#  endif\n  void (*cb)(int, void*);\n  void* arg;\n};\n\nstatic FD *fd = 0;\n\nvoid Fl::add_fd(int n, int events, void (*cb)(int, void*), void *v) {\n  remove_fd(n,events);\n  int i = nfds++;\n  if (i >= fd_array_size) {\n    FD *temp;\n    fd_array_size = 2*fd_array_size+1;\n\n    if (!fd) temp = (FD*)malloc(fd_array_size*sizeof(FD));\n    else temp = (FD*)realloc(fd, fd_array_size*sizeof(FD));\n\n    if (!temp) return;\n    fd = temp;\n\n#  if USE_POLL\n    pollfd *tpoll;\n\n    if (!pollfds) tpoll = (pollfd*)malloc(fd_array_size*sizeof(pollfd));\n    else tpoll = (pollfd*)realloc(pollfds, fd_array_size*sizeof(pollfd));\n\n    if (!tpoll) return;\n    pollfds = tpoll;\n#  endif\n  }\n  fd[i].cb = cb;\n  fd[i].arg = v;\n#  if USE_POLL\n  pollfds[i].fd = n;\n  pollfds[i].events = events;\n#  else\n  fd[i].fd = n;\n  fd[i].events = events;\n  if (events & POLLIN) FD_SET(n, &fdsets[0]);\n  if (events & POLLOUT) FD_SET(n, &fdsets[1]);\n  if (events & POLLERR) FD_SET(n, &fdsets[2]);\n  if (n > maxfd) maxfd = n;\n#  endif\n}\n\nvoid Fl::add_fd(int n, void (*cb)(int, void*), void* v) {\n  Fl::add_fd(n, POLLIN, cb, v);\n}\n\nvoid Fl::remove_fd(int n, int events) {\n  int i,j;\n# if !USE_POLL\n  maxfd = -1; // recalculate maxfd on the fly\n# endif\n  for (i=j=0; i<nfds; i++) {\n#  if USE_POLL\n    if (pollfds[i].fd == n) {\n      int e = pollfds[i].events & ~events;\n      if (!e) continue; // if no events left, delete this fd\n      pollfds[j].events = e;\n    }\n#  else\n    if (fd[i].fd == n) {\n      int e = fd[i].events & ~events;\n      if (!e) continue; // if no events left, delete this fd\n      fd[i].events = e;\n    }\n    if (fd[i].fd > maxfd) maxfd = fd[i].fd;\n#  endif\n    // move it down in the array if necessary:\n    if (j<i) {\n      fd[j] = fd[i];\n#  if USE_POLL\n      pollfds[j] = pollfds[i];\n#  endif\n    }\n    j++;\n  }\n  nfds = j;\n#  if !USE_POLL\n  if (events & POLLIN) FD_CLR(n, &fdsets[0]);\n  if (events & POLLOUT) FD_CLR(n, &fdsets[1]);\n  if (events & POLLERR) FD_CLR(n, &fdsets[2]);\n#  endif\n}\n\nvoid Fl::remove_fd(int n) {\n  remove_fd(n, -1);\n}\n\nextern int fl_send_system_handlers(void *e);\n\n#if CONSOLIDATE_MOTION\nstatic Fl_Window* send_motion;\nextern Fl_Window* fl_xmousewin;\n#endif\nstatic bool in_a_window; // true if in any of our windows, even destroyed ones\nstatic void do_queued_events() {\n  in_a_window = true;\n  while (XEventsQueued(fl_display,QueuedAfterReading)) {\n    XEvent xevent;\n    XNextEvent(fl_display, &xevent);\n    if (fl_send_system_handlers(&xevent))\n      continue;\n    fl_handle(xevent);\n  }\n  // we send FL_LEAVE only if the mouse did not enter some other window:\n  if (!in_a_window) Fl::handle(FL_LEAVE, 0);\n#if CONSOLIDATE_MOTION\n  else if (send_motion == fl_xmousewin) {\n    send_motion = 0;\n    Fl::handle(FL_MOVE, fl_xmousewin);\n  }\n#endif\n}\n\n// these pointers are set by the Fl::lock() function:\nstatic void nothing() {}\nvoid (*fl_lock_function)() = nothing;\nvoid (*fl_unlock_function)() = nothing;\n\n// This is never called with time_to_wait < 0.0:\n// It should return negative on error, 0 if nothing happens before\n// timeout, and >0 if any callbacks were done.\nint fl_wait(double time_to_wait) {\n\n  // OpenGL and other broken libraries call XEventsQueued\n  // unnecessarily and thus cause the file descriptor to not be ready,\n  // so we must check for already-read events:\n  if (fl_display && XQLength(fl_display)) {do_queued_events(); return 1;}\n\n#  if !USE_POLL\n  fd_set fdt[3];\n  fdt[0] = fdsets[0];\n  fdt[1] = fdsets[1];\n  fdt[2] = fdsets[2];\n#  endif\n  int n;\n\n  fl_unlock_function();\n\n  if (time_to_wait < 2147483.648) {\n#  if USE_POLL\n    n = ::poll(pollfds, nfds, int(time_to_wait*1000 + .5));\n#  else\n    timeval t;\n    t.tv_sec = int(time_to_wait);\n    t.tv_usec = int(1000000 * (time_to_wait-t.tv_sec));\n    n = ::select(maxfd+1,&fdt[0],&fdt[1],&fdt[2],&t);\n#  endif\n  } else {\n#  if USE_POLL\n    n = ::poll(pollfds, nfds, -1);\n#  else\n    n = ::select(maxfd+1,&fdt[0],&fdt[1],&fdt[2],0);\n#  endif\n  }\n\n  fl_lock_function();\n\n  if (n > 0) {\n    for (int i=0; i<nfds; i++) {\n#  if USE_POLL\n      if (pollfds[i].revents) fd[i].cb(pollfds[i].fd, fd[i].arg);\n#  else\n      int f = fd[i].fd;\n      short revents = 0;\n      if (FD_ISSET(f,&fdt[0])) revents |= POLLIN;\n      if (FD_ISSET(f,&fdt[1])) revents |= POLLOUT;\n      if (FD_ISSET(f,&fdt[2])) revents |= POLLERR;\n      if (fd[i].events & revents) fd[i].cb(f, fd[i].arg);\n#  endif\n    }\n  }\n  return n;\n}\n\n// fl_ready() is just like fl_wait(0.0) except no callbacks are done:\nint fl_ready() {\n  if (XQLength(fl_display)) return 1;\n  if (!nfds) return 0; // nothing to select or poll\n#  if USE_POLL\n  return ::poll(pollfds, nfds, 0);\n#  else\n  timeval t;\n  t.tv_sec = 0;\n  t.tv_usec = 0;\n  fd_set fdt[3];\n  fdt[0] = fdsets[0];\n  fdt[1] = fdsets[1];\n  fdt[2] = fdsets[2];\n  return ::select(maxfd+1,&fdt[0],&fdt[1],&fdt[2],&t);\n#  endif\n}\n\n// replace \\r\\n by \\n\nstatic void convert_crlf(unsigned char *string, long& len) {\n  unsigned char *a, *b;\n  a = b = string;\n  while (*a) {\n    if (*a == '\\r' && a[1] == '\\n') { a++; len--; }\n    else *b++ = *a++;\n  }\n  *b = 0;\n}\n\n////////////////////////////////////////////////////////////////\n\nDisplay *fl_display;\nWindow fl_message_window = 0;\nint fl_screen;\nXVisualInfo *fl_visual;\nColormap fl_colormap;\nstatic XIM fl_xim_im = 0;\nXIC fl_xim_ic = 0;\nstatic Window fl_xim_win = 0;\nstatic char fl_is_over_the_spot = 0;\nstatic XRectangle status_area;\n\nstatic Atom WM_DELETE_WINDOW;\nstatic Atom WM_PROTOCOLS;\nstatic Atom fl_MOTIF_WM_HINTS;\nstatic Atom TARGETS;\nstatic Atom CLIPBOARD;\nstatic Atom TIMESTAMP;\nstatic Atom PRIMARY_TIMESTAMP;\nstatic Atom CLIPBOARD_TIMESTAMP;\nAtom fl_XdndAware;\nAtom fl_XdndSelection;\nAtom fl_XdndEnter;\nAtom fl_XdndTypeList;\nAtom fl_XdndPosition;\nAtom fl_XdndLeave;\nAtom fl_XdndDrop;\nAtom fl_XdndStatus;\nAtom fl_XdndActionCopy;\nAtom fl_XdndFinished;\n//Atom fl_XdndProxy;\nAtom fl_XdndURIList;\nstatic Atom fl_Xatextplainutf;\nstatic Atom fl_Xatextplainutf2;\t\t// STR#2930 \nstatic Atom fl_Xatextplain;\nstatic Atom fl_XaText;\nstatic Atom fl_XaCompoundText;\nAtom fl_XaUtf8String;\nstatic Atom fl_XaTextUriList;\nstatic Atom fl_XaImageBmp;\nstatic Atom fl_XaImagePNG;\nstatic Atom fl_INCR;\nstatic Atom fl_NET_WM_NAME;\t\t\t// utf8 aware window label\nstatic Atom fl_NET_WM_ICON_NAME;\t\t// utf8 aware window icon name\nstatic Atom fl_NET_SUPPORTING_WM_CHECK;\nstatic Atom fl_NET_WM_STATE;\nstatic Atom fl_NET_WM_STATE_FULLSCREEN;\nstatic Atom fl_NET_WM_FULLSCREEN_MONITORS;\nstatic Atom fl_NET_WORKAREA;\nstatic Atom fl_NET_WM_ICON;\nstatic Atom fl_NET_ACTIVE_WINDOW;\n\n/*\n  X defines 32-bit-entities to have a format value of max. 32,\n  although sizeof(atom) can be 8 (64 bits) on a 64-bit OS.\n  See also fl_open_display() for sizeof(atom) < 4.\n  Used for XChangeProperty (see STR #2419).\n*/\nstatic int atom_bits = 32;\n\nstatic void fd_callback(int,void *) {\n  do_queued_events();\n}\n\nextern \"C\" {\n  static int io_error_handler(Display*) {\n    Fl::fatal(\"X I/O error\");\n    return 0;\n  }\n\n  static int xerror_handler(Display* d, XErrorEvent* e) {\n    char buf1[128], buf2[128];\n    sprintf(buf1, \"XRequest.%d\", e->request_code);\n    XGetErrorDatabaseText(d,\"\",buf1,buf1,buf2,128);\n    XGetErrorText(d, e->error_code, buf1, 128);\n    Fl::warning(\"%s: %s 0x%lx\", buf2, buf1, e->resourceid);\n    return 0;\n  }\n}\n\nextern char *fl_get_font_xfld(int fnum, int size);\n\nstatic void fl_new_ic()\n{\n  XVaNestedList preedit_attr = NULL;\n  XVaNestedList status_attr = NULL;\n  static XFontSet fs = NULL;\n  char *fnt;\n  char **missing_list = 0;\n  int missing_count = 0;\n  char *def_string;\n  static XRectangle spot;\n  int predit = 0;\n  int sarea = 0;\n  XIMStyles* xim_styles = NULL;\n\n#if USE_XFT\n\n#if defined(__GNUC__)\n// FIXME: warning XFT support here\n#endif /*__GNUC__*/\n\n  if (!fs) {\n    fnt = (char*)\"-misc-fixed-*\";\n    fs = XCreateFontSet(fl_display, fnt, &missing_list,\n                        &missing_count, &def_string);\n  }\n#else\n  if (!fs) {\n    bool must_free_fnt = true;\n    fnt = fl_get_font_xfld(0, 14);\n    if (!fnt) {fnt = (char*)\"-misc-fixed-*\";must_free_fnt=false;}\n    fs = XCreateFontSet(fl_display, fnt, &missing_list,\n                        &missing_count, &def_string);\n    if (must_free_fnt) free(fnt);\n  }\n#endif\n\n  if (missing_list) XFreeStringList(missing_list);\n\n  preedit_attr = XVaCreateNestedList(0,\n                                     XNSpotLocation, &spot,\n                                     XNFontSet, fs, NULL);\n  status_attr = XVaCreateNestedList(0,\n                                    XNAreaNeeded, &status_area,\n                                    XNFontSet, fs, NULL);\n\n  if (!XGetIMValues(fl_xim_im, XNQueryInputStyle,\n                    &xim_styles, NULL, NULL)) {\n    int i;\n    XIMStyle *style;\n    for (i = 0, style = xim_styles->supported_styles;\n         i < xim_styles->count_styles; i++, style++) {\n      if (*style == (XIMPreeditPosition | XIMStatusArea)) {\n        sarea = 1;\n        predit = 1;\n      } else if (*style == (XIMPreeditPosition | XIMStatusNothing)) {\n        predit = 1;\n      }\n    }\n  }\n  XFree(xim_styles);\n\n  if (sarea) {\n    fl_xim_ic = XCreateIC(fl_xim_im,\n                          XNInputStyle, (XIMPreeditPosition | XIMStatusArea),\n                          XNPreeditAttributes, preedit_attr,\n                          XNStatusAttributes, status_attr,\n                          NULL);\n  }\n\n  if (!fl_xim_ic && predit) {\n    fl_xim_ic = XCreateIC(fl_xim_im,\n                          XNInputStyle, (XIMPreeditPosition | XIMStatusNothing),\n                          XNPreeditAttributes, preedit_attr,\n                          NULL);\n  }\n  XFree(preedit_attr);\n  XFree(status_attr);\n  if (!fl_xim_ic) {\n    fl_is_over_the_spot = 0;\n    fl_xim_ic = XCreateIC(fl_xim_im,\n                          XNInputStyle, (XIMPreeditNothing | XIMStatusNothing),\n                          NULL);\n  } else {\n    fl_is_over_the_spot = 1;\n    XVaNestedList status_attr = NULL;\n    status_attr = XVaCreateNestedList(0, XNAreaNeeded, &status_area, NULL);\n\n    XGetICValues(fl_xim_ic, XNStatusAttributes, status_attr, NULL);\n    XFree(status_attr);\n  }\n}\n\n\nstatic XRectangle    spot;\nstatic int spotf = -1;\nstatic int spots = -1;\n\nvoid fl_reset_spot(void)\n{\n  spot.x = -1;\n  spot.y = -1;\n  //if (fl_xim_ic) XUnsetICFocus(fl_xim_ic);\n}\n\nvoid fl_set_spot(int font, int size, int X, int Y, int W, int H, Fl_Window *win)\n{\n  int change = 0;\n  XVaNestedList preedit_attr;\n  static XFontSet fs = NULL;\n  char **missing_list;\n  int missing_count;\n  char *def_string;\n  char *fnt = NULL;\n  bool must_free_fnt =true;\n\n  static XIC ic = NULL;\n\n  if (!fl_xim_ic || !fl_is_over_the_spot) return;\n  //XSetICFocus(fl_xim_ic);\n  if (X != spot.x || Y != spot.y) {\n    spot.x = X;\n    spot.y = Y;\n    spot.height = H;\n    spot.width = W;\n    change = 1;\n  }\n  if (font != spotf || size != spots) {\n    spotf = font;\n    spots = size;\n    change = 1;\n    if (fs) {\n      XFreeFontSet(fl_display, fs);\n    }\n#if USE_XFT\n\n#if defined(__GNUC__)\n// FIXME: warning XFT support here\n#endif /*__GNUC__*/\n\n    fnt = NULL; // fl_get_font_xfld(font, size);\n    if (!fnt) {fnt = (char*)\"-misc-fixed-*\";must_free_fnt=false;}\n    fs = XCreateFontSet(fl_display, fnt, &missing_list,\n                        &missing_count, &def_string);\n#else\n    fnt = fl_get_font_xfld(font, size);\n    if (!fnt) {fnt = (char*)\"-misc-fixed-*\";must_free_fnt=false;}\n    fs = XCreateFontSet(fl_display, fnt, &missing_list,\n                        &missing_count, &def_string);\n#endif\n  }\n  if (fl_xim_ic != ic) {\n    ic = fl_xim_ic;\n    change = 1;\n  }\n\n  if (fnt && must_free_fnt) free(fnt);\n  if (!change) return;\n\n\n  preedit_attr = XVaCreateNestedList(0,\n                                     XNSpotLocation, &spot,\n                                     XNFontSet, fs, NULL);\n  XSetICValues(fl_xim_ic, XNPreeditAttributes, preedit_attr, NULL);\n  XFree(preedit_attr);\n}\n\nvoid fl_set_status(int x, int y, int w, int h)\n{\n  XVaNestedList status_attr;\n  status_area.x = x;\n  status_area.y = y;\n  status_area.width = w;\n  status_area.height = h;\n  if (!fl_xim_ic) return;\n  status_attr = XVaCreateNestedList(0, XNArea, &status_area, NULL);\n\n  XSetICValues(fl_xim_ic, XNStatusAttributes, status_attr, NULL);\n  XFree(status_attr);\n}\n\nstatic void fl_init_xim() {\n  static int xim_warning = 2;\n  if (xim_warning > 0) xim_warning--;\n\n  //XIMStyle *style;\n  XIMStyles *xim_styles;\n  if (!fl_display) return;\n  if (fl_xim_im) return;\n\n  fl_xim_im = XOpenIM(fl_display, NULL, NULL, NULL);\n  xim_styles = NULL;\n  fl_xim_ic = NULL;\n\n  if (fl_xim_im) {\n    XGetIMValues (fl_xim_im, XNQueryInputStyle,\n                  &xim_styles, NULL, NULL);\n  } else {\n    if (xim_warning)\n      Fl::warning(\"XOpenIM() failed\");\n    // if xim_styles is allocated, free it now\n    if (xim_styles) XFree(xim_styles);\n    return;\n  }\n\n  if (xim_styles && xim_styles->count_styles) {\n    fl_new_ic();\n   } else {\n     if (xim_warning)\n       Fl::warning(\"No XIM style found\");\n     XCloseIM(fl_xim_im);\n     fl_xim_im = NULL;\n     // if xim_styles is allocated, free it now\n     if (xim_styles) XFree(xim_styles);\n     return;\n  }\n  if (!fl_xim_ic) {\n    if (xim_warning)\n      Fl::warning(\"XCreateIC() failed\");\n    XCloseIM(fl_xim_im);\n    fl_xim_im = NULL;\n  }\n  // if xim_styles is still allocated, free it now\n  if(xim_styles) XFree(xim_styles);\n}\n\nvoid fl_xim_deactivate(void);\n\nvoid fl_xim_activate(Window xid) {\n  if (!fl_xim_im)\n    return;\n\n  // If the focused window has changed, then use the brute force method\n  // of completely recreating the input context.\n  if (fl_xim_win != xid) {\n    fl_xim_deactivate();\n\n    fl_new_ic();\n    fl_xim_win = xid;\n\n    XSetICValues(fl_xim_ic,\n                 XNFocusWindow, fl_xim_win,\n                 XNClientWindow, fl_xim_win,\n                 NULL);\n  }\n\n  fl_set_spot(spotf, spots, spot.x, spot.y, spot.width, spot.height);\n}\n\nvoid fl_xim_deactivate(void) {\n  if (!fl_xim_ic)\n    return;\n\n  XDestroyIC(fl_xim_ic);\n  fl_xim_ic = NULL;\n\n  fl_xim_win = 0;\n}\n\nvoid Fl::enable_im() {\n  Fl_Window *win;\n\n  win = Fl::first_window();\n  if (win && win->shown()) {\n    fl_xim_activate(fl_xid(win));\n    XSetICFocus(fl_xim_ic);\n  } else {\n    fl_new_ic();\n  }\n}\n\nvoid Fl::disable_im() {\n  fl_xim_deactivate();\n}\n\nvoid fl_open_display() {\n  if (fl_display) return;\n\n  setlocale(LC_CTYPE, \"\");\n  XSetLocaleModifiers(\"\");\n\n  XSetIOErrorHandler(io_error_handler);\n  XSetErrorHandler(xerror_handler);\n\n  Display *d = XOpenDisplay(0);\n  if (!d) Fl::fatal(\"Can't open display: %s\",XDisplayName(0));\n\n  fl_open_display(d);\n}\n\n\nvoid fl_open_display(Display* d) {\n  fl_display = d;\n\n  WM_DELETE_WINDOW      = XInternAtom(d, \"WM_DELETE_WINDOW\",    0);\n  WM_PROTOCOLS          = XInternAtom(d, \"WM_PROTOCOLS\",        0);\n  fl_MOTIF_WM_HINTS     = XInternAtom(d, \"_MOTIF_WM_HINTS\",     0);\n  TARGETS               = XInternAtom(d, \"TARGETS\",             0);\n  CLIPBOARD             = XInternAtom(d, \"CLIPBOARD\",           0);\n  TIMESTAMP             = XInternAtom(d, \"TIMESTAMP\",           0);\n  PRIMARY_TIMESTAMP     = XInternAtom(d, \"PRIMARY_TIMESTAMP\",   0);\n  CLIPBOARD_TIMESTAMP   = XInternAtom(d, \"CLIPBOARD_TIMESTAMP\", 0);\n  fl_XdndAware          = XInternAtom(d, \"XdndAware\",           0);\n  fl_XdndSelection      = XInternAtom(d, \"XdndSelection\",       0);\n  fl_XdndEnter          = XInternAtom(d, \"XdndEnter\",           0);\n  fl_XdndTypeList       = XInternAtom(d, \"XdndTypeList\",        0);\n  fl_XdndPosition       = XInternAtom(d, \"XdndPosition\",        0);\n  fl_XdndLeave          = XInternAtom(d, \"XdndLeave\",           0);\n  fl_XdndDrop           = XInternAtom(d, \"XdndDrop\",            0);\n  fl_XdndStatus         = XInternAtom(d, \"XdndStatus\",          0);\n  fl_XdndActionCopy     = XInternAtom(d, \"XdndActionCopy\",      0);\n  fl_XdndFinished       = XInternAtom(d, \"XdndFinished\",        0);\n  //fl_XdndProxy        = XInternAtom(d, \"XdndProxy\",           0);\n  fl_XdndEnter          = XInternAtom(d, \"XdndEnter\",           0);\n  fl_XdndURIList        = XInternAtom(d, \"text/uri-list\",       0);\n  fl_Xatextplainutf     = XInternAtom(d, \"text/plain;charset=UTF-8\",0);\n  fl_Xatextplainutf2    = XInternAtom(d, \"text/plain;charset=utf-8\",0);\t// Firefox/Thunderbird needs this - See STR#2930\n  fl_Xatextplain        = XInternAtom(d, \"text/plain\",          0);\n  fl_XaText             = XInternAtom(d, \"TEXT\",                0);\n  fl_XaCompoundText     = XInternAtom(d, \"COMPOUND_TEXT\",       0);\n  fl_XaUtf8String       = XInternAtom(d, \"UTF8_STRING\",         0);\n  fl_XaTextUriList      = XInternAtom(d, \"text/uri-list\",       0);\n  fl_XaImageBmp         = XInternAtom(d, \"image/bmp\",           0);\n  fl_XaImagePNG         = XInternAtom(d, \"image/png\",           0);\n  fl_INCR               = XInternAtom(d, \"INCR\",                0);\n  fl_NET_WM_NAME        = XInternAtom(d, \"_NET_WM_NAME\",        0);\n  fl_NET_WM_ICON_NAME   = XInternAtom(d, \"_NET_WM_ICON_NAME\",   0);\n  fl_NET_SUPPORTING_WM_CHECK = XInternAtom(d, \"_NET_SUPPORTING_WM_CHECK\", 0);\n  fl_NET_WM_STATE       = XInternAtom(d, \"_NET_WM_STATE\",       0);\n  fl_NET_WM_STATE_FULLSCREEN = XInternAtom(d, \"_NET_WM_STATE_FULLSCREEN\", 0);\n  fl_NET_WM_FULLSCREEN_MONITORS = XInternAtom(d, \"_NET_WM_FULLSCREEN_MONITORS\", 0);\n  fl_NET_WORKAREA       = XInternAtom(d, \"_NET_WORKAREA\",       0);\n  fl_NET_WM_ICON        = XInternAtom(d, \"_NET_WM_ICON\",        0);\n  fl_NET_ACTIVE_WINDOW  = XInternAtom(d, \"_NET_ACTIVE_WINDOW\",  0);\n\n  if (sizeof(Atom) < 4)\n    atom_bits = sizeof(Atom) * 8;\n\n  Fl::add_fd(ConnectionNumber(d), POLLIN, fd_callback);\n\n  fl_screen = DefaultScreen(d);\n\n  fl_message_window =\n    XCreateSimpleWindow(d, RootWindow(d,fl_screen), 0,0,1,1,0, 0, 0);\n\n// construct an XVisualInfo that matches the default Visual:\n  XVisualInfo templt; int num;\n  templt.visualid = XVisualIDFromVisual(DefaultVisual(d, fl_screen));\n  fl_visual = XGetVisualInfo(d, VisualIDMask, &templt, &num);\n  fl_colormap = DefaultColormap(d, fl_screen);\n  fl_init_xim();\n\n#if !USE_COLORMAP\n  Fl::visual(FL_RGB);\n#endif\n\n#if HAVE_XFIXES\n  int error_base;\n  if (XFixesQueryExtension(fl_display, &xfixes_event_base, &error_base))\n    have_xfixes = true;\n  else\n    have_xfixes = false;\n#endif\n\n#if USE_XRANDR\n  void *libxrandr_addr = dlopen(\"libXrandr.so.2\", RTLD_LAZY);\n  if (!libxrandr_addr)  libxrandr_addr = dlopen(\"libXrandr.so\", RTLD_LAZY);\n  if (libxrandr_addr) {\n    int error_base;\n    typedef Bool (*XRRQueryExtension_type)(Display*, int*, int*);\n    typedef void (*XRRSelectInput_type)(Display*, Window, int);\n    XRRQueryExtension_type XRRQueryExtension_f = (XRRQueryExtension_type)dlsym(libxrandr_addr, \"XRRQueryExtension\");\n    XRRSelectInput_type XRRSelectInput_f = (XRRSelectInput_type)dlsym(libxrandr_addr, \"XRRSelectInput\");\n    XRRUpdateConfiguration_f = (XRRUpdateConfiguration_type)dlsym(libxrandr_addr, \"XRRUpdateConfiguration\");\n    if (XRRQueryExtension_f && XRRSelectInput_f && XRRQueryExtension_f(d, &randrEventBase, &error_base))\n      XRRSelectInput_f(d, RootWindow(d, fl_screen), RRScreenChangeNotifyMask);\n    else XRRUpdateConfiguration_f = NULL;\n    }\n#endif\n\n  // Listen for changes to _NET_WORKAREA\n  XSelectInput(d, RootWindow(d, fl_screen), PropertyChangeMask);\n}\n\nvoid fl_close_display() {\n  Fl::remove_fd(ConnectionNumber(fl_display));\n  XCloseDisplay(fl_display);\n}\n\nstatic int fl_workarea_xywh[4] = { -1, -1, -1, -1 };\n\nstatic void fl_init_workarea() {\n  fl_open_display();\n\n  Atom actual;\n  unsigned long count, remaining;\n  int format;\n  long *xywh = 0;\n\n  /* If there are several screens, the _NET_WORKAREA property \n   does not give the work area of the main screen, but that of all screens together.\n   Therefore, we use this property only when there is a single screen,\n   and fall back to the main screen full area when there are several screens.\n   */\n  if (Fl::screen_count() > 1 || XGetWindowProperty(fl_display, RootWindow(fl_display, fl_screen),\n\t\t\t fl_NET_WORKAREA, 0, 4, False,\n                         XA_CARDINAL, &actual, &format, &count, &remaining,\n                         (unsigned char **)&xywh) || !xywh || !xywh[2] ||\n                         !xywh[3])\n  {\n    Fl::screen_xywh(fl_workarea_xywh[0], \n\t\t    fl_workarea_xywh[1], \n\t\t    fl_workarea_xywh[2], \n\t\t    fl_workarea_xywh[3], 0);\n  }\n  else\n  {\n    fl_workarea_xywh[0] = (int)xywh[0];\n    fl_workarea_xywh[1] = (int)xywh[1];\n    fl_workarea_xywh[2] = (int)xywh[2];\n    fl_workarea_xywh[3] = (int)xywh[3];\n  }\n  if ( xywh ) { XFree(xywh); xywh = 0; }\n}\n\nint Fl::x() {\n  if (fl_workarea_xywh[0] < 0) fl_init_workarea();\n  return fl_workarea_xywh[0];\n}\n\nint Fl::y() {\n  if (fl_workarea_xywh[0] < 0) fl_init_workarea();\n  return fl_workarea_xywh[1];\n}\n\nint Fl::w() {\n  if (fl_workarea_xywh[0] < 0) fl_init_workarea();\n  return fl_workarea_xywh[2];\n}\n\nint Fl::h() {\n  if (fl_workarea_xywh[0] < 0) fl_init_workarea();\n  return fl_workarea_xywh[3];\n}\n\nvoid Fl::get_mouse(int &xx, int &yy) {\n  fl_open_display();\n  Window root = RootWindow(fl_display, fl_screen);\n  Window c; int mx,my,cx,cy; unsigned int mask;\n  XQueryPointer(fl_display,root,&root,&c,&mx,&my,&cx,&cy,&mask);\n  xx = mx;\n  yy = my;\n}\n\n////////////////////////////////////////////////////////////////\n// Code used for paste and DnD into the program:\n\nFl_Widget *fl_selection_requestor;\nchar *fl_selection_buffer[2];\nint fl_selection_length[2];\nconst char * fl_selection_type[2];\nint fl_selection_buffer_length[2];\nchar fl_i_own_selection[2] = {0,0};\n\n// Call this when a \"paste\" operation happens:\nvoid Fl::paste(Fl_Widget &receiver, int clipboard, const char *type) {\n  if (fl_i_own_selection[clipboard]) {\n    // We already have it, do it quickly without window server.\n    // Notice that the text is clobbered if set_selection is\n    // called in response to FL_PASTE!\n    // However, for now, we only paste text in this function\n    if (fl_selection_type[clipboard] != Fl::clipboard_plain_text) return; //TODO: allow copy/paste of image within same app\n    Fl::e_text = fl_selection_buffer[clipboard];\n    Fl::e_length = fl_selection_length[clipboard];\n    if (!Fl::e_text) Fl::e_text = (char *)\"\";\n    receiver.handle(FL_PASTE);\n    return;\n  }\n  // otherwise get the window server to return it:\n  fl_selection_requestor = &receiver;\n  Atom property = clipboard ? CLIPBOARD : XA_PRIMARY;\n  Fl::e_clipboard_type = type;\n  XConvertSelection(fl_display, property, TARGETS, property,\n                    fl_xid(Fl::first_window()), fl_event_time);\n}\n\nint Fl::clipboard_contains(const char *type)\n{\n  XEvent event;\n  Atom actual; int format; unsigned long count, remaining, i = 0;\n  unsigned char* portion = NULL;\n  Fl_Window *win = Fl::first_window();\n  if (!win || !fl_xid(win)) return 0;\n  XConvertSelection(fl_display, CLIPBOARD, TARGETS, CLIPBOARD, fl_xid(win), CurrentTime);\n  XFlush(fl_display);\n  do  { \n    XNextEvent(fl_display, &event); \n    if (event.type == SelectionNotify && event.xselection.property == None) return 0;\n    i++; \n  }\n  while (i < 10 && event.type != SelectionNotify);\n  if (i >= 10) return 0;\n  XGetWindowProperty(fl_display,\n\t\t     event.xselection.requestor,\n\t\t     event.xselection.property,\n\t\t     0, 4000, 0, 0,\n\t\t     &actual, &format, &count, &remaining, &portion);\n  if (actual != XA_ATOM) return 0;\n  Atom t;\n  int retval = 0;\n  if (strcmp(type, Fl::clipboard_plain_text) == 0) {\n    for (i = 0; i<count; i++) { // searching for text data\n      t = ((Atom*)portion)[i];\n      if (t == fl_Xatextplainutf ||\n\t  t == fl_Xatextplainutf2 ||\n\t  t == fl_Xatextplain ||\n\t  t == fl_XaUtf8String) {\n\tretval = 1;\n\tbreak;\n      }\n    }\t\n  }\n  else if (strcmp(type, Fl::clipboard_image) == 0) {\n    for (i = 0; i<count; i++) { // searching for image data\n      t = ((Atom*)portion)[i];\n      if (t == fl_XaImageBmp || t == fl_XaImagePNG) {\n\tretval = 1;\n\tbreak;\n      }\n    }\t\n  }\n  XFree(portion);\n  return retval;\n}\n\nstatic Window fl_dnd_source_window;\nstatic Atom *fl_dnd_source_types; // null-terminated list of data types being supplied\nstatic Atom fl_dnd_type;\nstatic Atom fl_dnd_source_action;\nstatic Atom fl_dnd_action;\n\nvoid fl_sendClientMessage(Window window, Atom message,\n                                 unsigned long d0,\n                                 unsigned long d1=0,\n                                 unsigned long d2=0,\n                                 unsigned long d3=0,\n                                 unsigned long d4=0)\n{\n  XEvent e;\n  e.xany.type = ClientMessage;\n  e.xany.window = window;\n  e.xclient.message_type = message;\n  e.xclient.format = 32;\n  e.xclient.data.l[0] = (long)d0;\n  e.xclient.data.l[1] = (long)d1;\n  e.xclient.data.l[2] = (long)d2;\n  e.xclient.data.l[3] = (long)d3;\n  e.xclient.data.l[4] = (long)d4;\n  XSendEvent(fl_display, window, 0, 0, &e);\n}\n\n\n/*\n   Get window property value (32 bit format)\n   Returns zero on success, -1 on error\n\n   'data' should be freed with XFree() using this pattern:\n\n        unsigned long *data = 0;\n        if (0 == get_xwinprop(....., &nitems, &data) ) { ..success.. }\n        else { ..fail.. }\n        if ( data ) { XFree(data); data=0; }\n\t\n    Note: 'data' can be non-zero, even if the return value is -1 (error) and\n    should hence be XFree'd *after* the if/else statement, as described above.\n*/\nstatic int get_xwinprop(Window wnd, Atom prop, long max_length,\n                        unsigned long *nitems, unsigned long **data) {\n  Atom actual;\n  int format;\n  unsigned long bytes_after;\n  \n  if (Success != XGetWindowProperty(fl_display, wnd, prop, 0, max_length, \n                                    False, AnyPropertyType, &actual, &format, \n                                    nitems, &bytes_after, (unsigned char**)data)) {\n    return -1;\n  }\n\n  if (actual == None || format != 32) {\n    return -1;\n  }\n\n  return 0;\n}\n\n\n////////////////////////////////////////////////////////////////\n// Code for copying to clipboard and DnD out of the program:\n\nvoid Fl::copy(const char *stuff, int len, int clipboard, const char *type) {\n  if (!stuff || len<0) return;\n  if (len+1 > fl_selection_buffer_length[clipboard]) {\n    delete[] fl_selection_buffer[clipboard];\n    fl_selection_buffer[clipboard] = new char[len+100];\n    fl_selection_buffer_length[clipboard] = len+100;\n  }\n  memcpy(fl_selection_buffer[clipboard], stuff, len);\n  fl_selection_buffer[clipboard][len] = 0; // needed for direct paste\n  fl_selection_length[clipboard] = len;\n  fl_i_own_selection[clipboard] = 1;\n  fl_selection_type[clipboard] = Fl::clipboard_plain_text;\n  Atom property = clipboard ? CLIPBOARD : XA_PRIMARY;\n  XSetSelectionOwner(fl_display, property, fl_message_window, fl_event_time);\n}\n\nstatic void write_short(unsigned char **cp,short i){\n  unsigned char *c=*cp;\n  *c++=i&0xFF;i>>=8;\n  *c++=i&0xFF;i>>=8;\n  *cp=c;\n}\n\nstatic void write_int(unsigned char **cp,int i){\n  unsigned char *c=*cp;\n  *c++=i&0xFF;i>>=8;\n  *c++=i&0xFF;i>>=8;\n  *c++=i&0xFF;i>>=8;\n  *c++=i&0xFF;i>>=8;\n  *cp=c;\n}\n\nstatic unsigned char *create_bmp(const unsigned char *data, int W, int H, int *return_size){\n  int R=(3*W+3)/4 * 4; // the number of bytes per row, rounded up to multiple of 4\n  int s=H*R;\n  int fs=14+40+s;\n  unsigned char *b=new unsigned char[fs];\n  unsigned char *c=b;\n  // BMP header\n  *c++='B';\n  *c++='M';\n  write_int(&c,fs);\n  write_int(&c,0);\n  write_int(&c,14+40);\n  // DIB header:\n  write_int(&c,40);\n  write_int(&c,W);\n  write_int(&c,H);\n  write_short(&c,1);\n  write_short(&c,24);//bits ber pixel\n  write_int(&c,0);//RGB\n  write_int(&c,s);\n  write_int(&c,0);// horizontal resolution\n  write_int(&c,0);// vertical resolution\n  write_int(&c,0);//number of colors. 0 -> 1<<bits_per_pixel\n  write_int(&c,0);\n  // Pixel data\n  data+=3*W*H;\n  for (int y=0;y<H;++y){\n    data-=3*W;\n    const unsigned char *s=data;\n    unsigned char *p=c;\n    for (int x=0;x<W;++x){\n      *p++=s[2];\n      *p++=s[1];\n      *p++=s[0];\n      s+=3;\n    }\n    c+=R;\n  }\n  *return_size = fs;\n  return b;\n}\n\nvoid Fl::copy_image(const unsigned char *data, int W, int H, int clipboard){\n  if(!data || W<=0 || H<=0) return;\n  delete[] fl_selection_buffer[clipboard];\n  fl_selection_buffer[clipboard] = (char *) create_bmp(data,W,H,&fl_selection_length[clipboard]);\n  fl_selection_buffer_length[clipboard] = fl_selection_length[clipboard];\n  fl_i_own_selection[clipboard] = 1;\n  fl_selection_type[clipboard] = Fl::clipboard_image;\n\n  Atom property = clipboard ? CLIPBOARD : XA_PRIMARY;\n  XSetSelectionOwner(fl_display, property, fl_message_window, fl_event_time);\n}\n\n////////////////////////////////////////////////////////////////\n// Code for tracking clipboard changes:\n\nstatic Time primary_timestamp = (Time)-1;\nstatic Time clipboard_timestamp = (Time)-1;\n\nextern bool fl_clipboard_notify_empty(void);\nextern void fl_trigger_clipboard_notify(int source);\n\nstatic void poll_clipboard_owner(void) {\n  Window xid;\n\n#if HAVE_XFIXES\n  // No polling needed with Xfixes\n  if (have_xfixes)\n    return;\n#endif\n\n  // No one is interested, so no point polling\n  if (fl_clipboard_notify_empty())\n    return;\n\n  // We need a window for this to work\n  if (!Fl::first_window())\n    return;\n  xid = fl_xid(Fl::first_window());\n  if (!xid)\n    return;\n\n  // Request an update of the selection time for both the primary and\n  // clipboard selections. Magic continues when we get a SelectionNotify.\n  if (!fl_i_own_selection[0])\n    XConvertSelection(fl_display, XA_PRIMARY, TIMESTAMP, PRIMARY_TIMESTAMP,\n                      xid, fl_event_time);\n  if (!fl_i_own_selection[1])\n    XConvertSelection(fl_display, CLIPBOARD, TIMESTAMP, CLIPBOARD_TIMESTAMP,\n                      xid, fl_event_time);\n}\n\nstatic void clipboard_timeout(void *data)\n{\n  // No one is interested, so stop polling\n  if (fl_clipboard_notify_empty())\n    return;\n\n  poll_clipboard_owner();\n\n  Fl::repeat_timeout(0.5, clipboard_timeout);\n}\n\nstatic void handle_clipboard_timestamp(int clipboard, Time time)\n{\n  Time *timestamp;\n\n  timestamp = clipboard ? &clipboard_timestamp : &primary_timestamp;\n\n#if HAVE_XFIXES\n  if (!have_xfixes)\n#endif\n  {\n    // Initial scan, just store the value\n    if (*timestamp == (Time)-1) {\n      *timestamp = time;\n      return;\n    }\n  }\n\n  // Same selection\n  if (time == *timestamp)\n    return;\n\n  *timestamp = time;\n\n  // The clipboard change is the event that caused us to request\n  // the clipboard data, so use that time as the latest event.\n  if (time > fl_event_time)\n    fl_event_time = time;\n\n  // Something happened! Let's tell someone!\n  fl_trigger_clipboard_notify(clipboard);\n}\n\nvoid fl_clipboard_notify_change() {\n  // Reset the timestamps if we've going idle so that you don't\n  // get a bogus immediate trigger next time they're activated.\n  if (fl_clipboard_notify_empty()) {\n    primary_timestamp = (Time)-1;\n    clipboard_timestamp = (Time)-1;\n  } else {\n#if HAVE_XFIXES\n    if (!have_xfixes)\n#endif\n    {\n      poll_clipboard_owner();\n\n      if (!Fl::has_timeout(clipboard_timeout))\n        Fl::add_timeout(0.5, clipboard_timeout);\n    }\n  }\n}\n\n////////////////////////////////////////////////////////////////\n\nconst XEvent* fl_xevent; // the current x event\nulong fl_event_time; // the last timestamp from an x event\n\nchar fl_key_vector[32]; // used by Fl::get_key()\n\n// Record event mouse position and state from an XEvent:\n\nstatic int px, py;\nstatic ulong ptime;\n\nstatic void set_event_xy() {\n#  if CONSOLIDATE_MOTION\n  send_motion = 0;\n#  endif\n  Fl::e_x_root  = fl_xevent->xbutton.x_root;\n  Fl::e_x       = fl_xevent->xbutton.x;\n  Fl::e_y_root  = fl_xevent->xbutton.y_root;\n  Fl::e_y       = fl_xevent->xbutton.y;\n  Fl::e_state   = fl_xevent->xbutton.state << 16;\n  fl_event_time = fl_xevent->xbutton.time;\n#  ifdef __sgi\n  // get the meta key off PC keyboards:\n  if (fl_key_vector[18]&0x18) Fl::e_state |= FL_META;\n#  endif\n  // turn off is_click if enough time or mouse movement has passed:\n  if (abs(Fl::e_x_root-px)+abs(Fl::e_y_root-py) > 3 ||\n      fl_event_time >= ptime+1000)\n    Fl::e_is_click = 0;\n}\n\n// if this is same event as last && is_click, increment click count:\nstatic inline void checkdouble() {\n  if (Fl::e_is_click == Fl::e_keysym)\n    Fl::e_clicks++;\n  else {\n    Fl::e_clicks = 0;\n    Fl::e_is_click = Fl::e_keysym;\n  }\n  px = Fl::e_x_root;\n  py = Fl::e_y_root;\n  ptime = fl_event_time;\n}\n\nstatic Fl_Window* resize_bug_fix;\n\n////////////////////////////////////////////////////////////////\n\nstatic char unknown[] = \"<unknown>\";\nconst int unknown_len = 10;\n\nextern \"C\" {\n\nstatic int xerror = 0;\n\nstatic int ignoreXEvents(Display *display, XErrorEvent *event) {\n  xerror = 1;\n  return 0;\n}\n\nstatic XErrorHandler catchXExceptions() {\n  xerror = 0;\n  return ignoreXEvents;\n}\n\nstatic int wasXExceptionRaised() {\n  return xerror;\n}\n\n}\n\nstatic bool getNextEvent(XEvent *event_return)\n{\n  time_t t = time(NULL);\n  while(!XPending(fl_display))\n  {\n    if(time(NULL) - t > 10.0)\n    {\n      //fprintf(stderr,\"Error: The XNextEvent never came...\\n\");\n      return false; \n    }\n  }\n  XNextEvent(fl_display, event_return);\n  return true;\n}\n\nstatic long getIncrData(uchar* &data, const XSelectionEvent& selevent, long lower_bound)\n{\n//fprintf(stderr,\"Incremental transfer starting due to INCR property\\n\");\n  size_t total = 0;\n  XEvent event;\n  XDeleteProperty(fl_display, selevent.requestor, selevent.property);  \n  data = (uchar*)realloc(data, lower_bound);\n  for (;;)\n  {\n    if (!getNextEvent(&event)) break;\n    if (event.type == PropertyNotify)\n    {\n      if (event.xproperty.state != PropertyNewValue) continue;\n      Atom actual_type;\n      int actual_format;\n      unsigned long nitems;\n      unsigned long bytes_after;\n      unsigned char* prop = 0;\n      long offset = 0;\n      size_t num_bytes;\n      //size_t slice_size = 0;\n      do\n      {\n\tXGetWindowProperty(fl_display, selevent.requestor, selevent.property, offset, 70000, True,\n\t\t\t   AnyPropertyType, &actual_type, &actual_format, &nitems, &bytes_after, &prop);\n\tnum_bytes = nitems * (actual_format / 8);\n\toffset += num_bytes/4;\n\t//slice_size += num_bytes;\n\tif (total + num_bytes > (size_t)lower_bound) data = (uchar*)realloc(data, total + num_bytes);\n\tmemcpy(data + total, prop, num_bytes); total += num_bytes;\n\tif (prop) XFree(prop);\n      } while (bytes_after != 0);\n//fprintf(stderr,\"INCR data size:%ld\\n\", slice_size);\n      if (num_bytes == 0) break;\n    }\n    else break;\n  }\n  XDeleteProperty(fl_display, selevent.requestor, selevent.property);\n  return (long)total;\n}\n\n/* Internal function to reduce \"deprecated\" warnings for XKeycodeToKeysym().\n   This way we get only one warning. The option to use XkbKeycodeToKeysym()\n   instead would not help much - see STR #2913 for more information.\n*/\nstatic KeySym fl_KeycodeToKeysym(Display *d, KeyCode k, unsigned i) {\n  return XKeycodeToKeysym(d, k, i);\n}\n\nint fl_handle(const XEvent& thisevent)\n{\n  XEvent xevent = thisevent;\n  fl_xevent = &thisevent;\n  Window xid = xevent.xany.window;\n\n  if (fl_xim_ic && xevent.type == DestroyNotify &&\n        xid != fl_xim_win && !fl_find(xid))\n  {\n    XIM xim_im;\n    xim_im = XOpenIM(fl_display, NULL, NULL, NULL);\n    if (!xim_im) {\n      /*  XIM server has crashed */\n      XSetLocaleModifiers(\"@im=\");\n      fl_xim_im = NULL;\n      fl_init_xim();\n    } else {\n      XCloseIM(xim_im);\t// see STR 2185 for comment\n    }\n    return 0;\n  }\n\n  if (fl_xim_ic && (xevent.type == FocusIn))\n    fl_xim_activate(xid);\n\n  if (fl_xim_ic && XFilterEvent((XEvent *)&xevent, 0))\n      return(1);\n  \n#if USE_XRANDR  \n  if( XRRUpdateConfiguration_f && xevent.type == randrEventBase + RRScreenChangeNotify) {\n    XRRUpdateConfiguration_f(&xevent);\n    Fl::call_screen_init();\n    fl_init_workarea();\n    Fl::handle(FL_SCREEN_CONFIGURATION_CHANGED, NULL);\n  }\n#endif\n\n  if (xevent.type == PropertyNotify && xevent.xproperty.atom == fl_NET_WORKAREA) {\n    fl_init_workarea();\n  }\n  \n  switch (xevent.type) {\n\n  case KeymapNotify:\n    memcpy(fl_key_vector, xevent.xkeymap.key_vector, 32);\n    return 0;\n\n  case MappingNotify:\n    XRefreshKeyboardMapping((XMappingEvent*)&xevent.xmapping);\n    return 0;\n\n  case SelectionNotify: {\n    static unsigned char* sn_buffer = 0;\n    //static const char *buffer_format = 0;\n    if (sn_buffer) {XFree(sn_buffer); sn_buffer = 0;}\n    long bytesread = 0;\n    if (fl_xevent->xselection.property) for (;;) {\n      // The Xdnd code pastes 64K chunks together, possibly to avoid\n      // bugs in X servers, or maybe to avoid an extra round-trip to\n      // get the property length.  I copy this here:\n      Atom actual; int format; unsigned long count, remaining;\n      unsigned char* portion = NULL;\n      if (XGetWindowProperty(fl_display,\n                             fl_xevent->xselection.requestor,\n                             fl_xevent->xselection.property,\n                             bytesread/4, 65536, 1, AnyPropertyType,\n                             &actual, &format, &count, &remaining,\n                             &portion)) break; // quit on error\n\n      if ((fl_xevent->xselection.property == PRIMARY_TIMESTAMP) ||\n          (fl_xevent->xselection.property == CLIPBOARD_TIMESTAMP)) {\n        if (portion && format == 32 && count == 1) {\n          Time t = *(unsigned int*)portion;\n          if (fl_xevent->xselection.property == CLIPBOARD_TIMESTAMP)\n            handle_clipboard_timestamp(1, t);\n          else\n            handle_clipboard_timestamp(0, t);\n        }\n\tXFree(portion); portion = 0;\n        return true;\n      }\n\n      if (actual == TARGETS || actual == XA_ATOM) {\n/*for (unsigned i = 0; i<count; i++) {\n  fprintf(stderr,\" %s\", XGetAtomName(fl_display, ((Atom*)portion)[i]) );\n  }\nfprintf(stderr,\"\\n\");*/\n\tAtom t, type = XA_STRING;\n\tif (Fl::e_clipboard_type == Fl::clipboard_image) { // searching for image data\n\t  for (unsigned i = 0; i<count; i++) { \n\t    t = ((Atom*)portion)[i];\n\t    if (t == fl_XaImageBmp || t == fl_XaImagePNG) {\n\t      type = t;\n\t      goto found;\n\t    }\n\t  }\n\t  XFree(portion);\n\t  return true;\n\t}\n\tfor (unsigned i = 0; i<count; i++) { // searching for text data\n\t  t = ((Atom*)portion)[i];\n\t  if (t == fl_Xatextplainutf ||\n\t      t == fl_Xatextplainutf2 ||\n\t      t == fl_Xatextplain ||\n\t      t == fl_XaUtf8String) {\n\t    type = t;\n\t    break;\n\t  }\n\t  // rest are only used if no utf-8 available:\n\t  if (t == fl_XaText ||\n\t      t == fl_XaTextUriList ||\n\t      t == fl_XaCompoundText) type = t;\n\t}\n      found:\n\tXFree(portion); portion = 0;\n\tAtom property = xevent.xselection.property;\n\tXConvertSelection(fl_display, property, type, property,\n\t      fl_xid(Fl::first_window()),\n\t      fl_event_time);\n\tif (type == fl_XaImageBmp) {\n\t  Fl::e_clipboard_type = Fl::clipboard_image;\n\t  //buffer_format = \"image/bmp\";\n\t  }\n\telse if (type == fl_XaImagePNG) {\n\t  Fl::e_clipboard_type = Fl::clipboard_image;\n\t  //buffer_format = \"image/png\";\n\t  }\n\telse {\n\t  Fl::e_clipboard_type = Fl::clipboard_plain_text;\n\t  //buffer_format = Fl::clipboard_plain_text;\n\t  }\n//fprintf(stderr,\"used format=%s\\n\", buffer_format);\n\treturn true;\n      }\n\tif (actual == fl_INCR) {\n\t  bytesread = getIncrData(sn_buffer, xevent.xselection, *(long*)portion);\n\t  XFree(portion);\n\t  break;\n\t}\n\t// Make sure we got something sane...\n      if ((portion == NULL) || (format != 8) || (count == 0)) {\n\tif (portion) { XFree(portion); portion = 0; }\n        return true;\n      }\n      sn_buffer = (unsigned char*)realloc(sn_buffer, bytesread+count+remaining+1);\n      memcpy(sn_buffer+bytesread, portion, count);\n      if (portion) { XFree(portion); portion = 0; }\n      bytesread += count;\n      // Cannot trust data to be null terminated\n      sn_buffer[bytesread] = '\\0';\n      if (!remaining) break;\n    }\n    if (sn_buffer && Fl::e_clipboard_type == Fl::clipboard_plain_text) {\n      sn_buffer[bytesread] = 0;\n      convert_crlf(sn_buffer, bytesread);\n    }\n    if (Fl::e_clipboard_type == Fl::clipboard_image) {\n      if (bytesread == 0) return 0;\n      Fl_Image *image = 0;\n      static char tmp_fname[21];\n      static Fl_Shared_Image *shared = 0;\n      strcpy(tmp_fname, \"/tmp/clipboardXXXXXX\");\n      int fd = mkstemp(tmp_fname);\n      if (fd == -1) return 0;\n      uchar *p = sn_buffer; ssize_t towrite = bytesread, written;\n      while (towrite) {\n\twritten = write(fd, p, towrite);\n\tp += written; towrite -= written;\n\t}\n      close(fd);\n      free(sn_buffer); sn_buffer = 0;\n      shared = Fl_Shared_Image::get(tmp_fname);\n      unlink(tmp_fname);\n      if (!shared) return 0;\n      image = shared->copy();\n      shared->release();\n      Fl::e_clipboard_data = (void*)image;\n    }\n    if (!fl_selection_requestor) return 0;\n\n    if (Fl::e_clipboard_type == Fl::clipboard_plain_text) {\n      Fl::e_text = sn_buffer ? (char*)sn_buffer : (char *)\"\";\n      Fl::e_length = bytesread;\n      }\n    int old_event = Fl::e_number;\n    fl_selection_requestor->handle(Fl::e_number = FL_PASTE);\n    Fl::e_number = old_event;\n    // Detect if this paste is due to Xdnd by the property name (I use\n    // XA_SECONDARY for that) and send an XdndFinished message. It is not\n    // clear if this has to be delayed until now or if it can be done\n    // immediately after calling XConvertSelection.\n    if (fl_xevent->xselection.property == XA_SECONDARY &&\n        fl_dnd_source_window) {\n      fl_sendClientMessage(fl_dnd_source_window, fl_XdndFinished,\n                           fl_xevent->xselection.requestor);\n      fl_dnd_source_window = 0; // don't send a second time\n    }\n    return 1;}\n\n  case SelectionClear: {\n    int clipboard = fl_xevent->xselectionclear.selection == CLIPBOARD;\n    fl_i_own_selection[clipboard] = 0;\n    poll_clipboard_owner();\n    return 1;}\n\n  case SelectionRequest: {\n    XSelectionEvent e;\n    e.type = SelectionNotify;\n    e.requestor = fl_xevent->xselectionrequest.requestor;\n    e.selection = fl_xevent->xselectionrequest.selection;\n    int clipboard = e.selection == CLIPBOARD;\n    e.target = fl_xevent->xselectionrequest.target;\n    e.time = fl_xevent->xselectionrequest.time;\n    e.property = fl_xevent->xselectionrequest.property;\n    if (fl_selection_type[clipboard] == Fl::clipboard_plain_text) {\n      if (e.target == TARGETS) {\n\tAtom a[3] = {fl_XaUtf8String, XA_STRING, fl_XaText};\n\tXChangeProperty(fl_display, e.requestor, e.property,\n\t                XA_ATOM, atom_bits, 0, (unsigned char*)a, 3);\n      } else {\n\tif (/*e.target == XA_STRING &&*/ fl_selection_length[clipboard]) {\n\t  if (e.target == fl_XaUtf8String ||\n\t      e.target == XA_STRING ||\n\t      e.target == fl_XaCompoundText ||\n\t      e.target == fl_XaText ||\n\t      e.target == fl_Xatextplain ||\n\t      e.target == fl_Xatextplainutf ||\n\t      e.target == fl_Xatextplainutf2) {\n\t    // clobber the target type, this seems to make some applications\n\t    // behave that insist on asking for XA_TEXT instead of UTF8_STRING\n\t    // Does not change XA_STRING as that breaks xclipboard.\n\t    if (e.target != XA_STRING) e.target = fl_XaUtf8String;\n\t    XChangeProperty(fl_display, e.requestor, e.property,\n\t\t            e.target, 8, 0,\n\t\t            (unsigned char *)fl_selection_buffer[clipboard],\n\t\t            fl_selection_length[clipboard]);\n\t  }\n\t} else {\n\t  //    char* x = XGetAtomName(fl_display,e.target);\n\t  //    fprintf(stderr,\"selection request of %s\\n\",x);\n\t  //    XFree(x);\n\t  e.property = 0;\n\t}\n      }\n    } else { // image in clipboard\n      if (e.target == TARGETS) {\n\tAtom a[1] = {fl_XaImageBmp};\n\tXChangeProperty(fl_display, e.requestor, e.property,\n\t                XA_ATOM, atom_bits, 0, (unsigned char*)a, 1);\n      } else {\n\tif (e.target == fl_XaImageBmp && fl_selection_length[clipboard]) {\n\t    XChangeProperty(fl_display, e.requestor, e.property,\n\t\t            e.target, 8, 0,\n\t\t            (unsigned char *)fl_selection_buffer[clipboard],\n\t\t            fl_selection_length[clipboard]);\n\t} else {\n\t  e.property = 0;\n\t}\n      }\n    }\n    XSendEvent(fl_display, e.requestor, 0, 0, (XEvent *)&e);}\n    return 1;\n\n  // events where interesting window id is in a different place:\n  case CirculateNotify:\n  case CirculateRequest:\n  case ConfigureNotify:\n  case ConfigureRequest:\n  case CreateNotify:\n  case DestroyNotify:\n  case GravityNotify:\n  case MapNotify:\n  case MapRequest:\n  case ReparentNotify:\n  case UnmapNotify:\n    xid = xevent.xmaprequest.window;\n    break;\n  }\n\n  int event = 0;\n  Fl_Window* window = fl_find(xid);\n\n  if (window) switch (xevent.type) {\n\n    case DestroyNotify: { // an X11 window was closed externally from the program\n      Fl::handle(FL_CLOSE, window);\n      Fl_X* X = Fl_X::i(window);\n      if (X) { // indicates the FLTK window was not closed\n\tX->xid = (Window)0; // indicates the X11 window was already destroyed\n\twindow->hide();\n\tint oldx = window->x(), oldy = window->y();\n\twindow->position(0, 0);\n\twindow->position(oldx, oldy);\n\twindow->show(); // recreate the X11 window in support of the FLTK window\n\t}\n      return 1;\n    }\n  case ClientMessage: {\n    Atom message = fl_xevent->xclient.message_type;\n    const long* data = fl_xevent->xclient.data.l;\n    if ((Atom)(data[0]) == WM_DELETE_WINDOW) {\n      event = FL_CLOSE;\n    } else if (message == fl_XdndEnter) {\n      fl_xmousewin = window;\n      in_a_window = true;\n      fl_dnd_source_window = data[0];\n      // version number is data[1]>>24\n//      printf(\"XdndEnter, version %ld\\n\", data[1] >> 24);\n      if (data[1]&1) {\n        // get list of data types:\n        Atom actual; int format; unsigned long count, remaining;\n        unsigned char *cm_buffer = 0;\n        XGetWindowProperty(fl_display, fl_dnd_source_window, fl_XdndTypeList,\n                           0, 0x8000000L, False, XA_ATOM, &actual, &format,\n                           &count, &remaining, &cm_buffer);\n        if (actual != XA_ATOM || format != 32 || count<4 || !cm_buffer) {\n          if ( cm_buffer ) { XFree(cm_buffer); cm_buffer = 0; }\n          goto FAILED;\n\t}\n        delete [] fl_dnd_source_types;\n        fl_dnd_source_types = new Atom[count+1];\n        for (unsigned i = 0; i < count; i++) {\n          fl_dnd_source_types[i] = ((Atom*)cm_buffer)[i];\n        }\n        fl_dnd_source_types[count] = 0;\n        XFree(cm_buffer); cm_buffer = 0;\n      } else {\n      FAILED:\n        // less than four data types, or if the above messes up:\n        if (!fl_dnd_source_types) fl_dnd_source_types = new Atom[4];\n        fl_dnd_source_types[0] = data[2];\n        fl_dnd_source_types[1] = data[3];\n        fl_dnd_source_types[2] = data[4];\n        fl_dnd_source_types[3] = 0;\n      }\n\n      // Loop through the source types and pick the first text type...\n      unsigned i;\n      Atom type = ((Atom*)fl_dnd_source_types)[0];\n      for (i = 0; fl_dnd_source_types[i]; i ++) {\n        Atom t = ((Atom*)fl_dnd_source_types)[i];\n        //printf(\"fl_dnd_source_types[%d]=%ld(%s)\\n\",i,t,XGetAtomName(fl_display,t));\n        if (t == fl_Xatextplainutf ||\t\t// \"text/plain;charset=UTF-8\"\n            t == fl_Xatextplainutf2 ||\t\t// \"text/plain;charset=utf-8\" -- See STR#2930\n            t == fl_Xatextplain ||\t\t// \"text/plain\"\n            t == fl_XaUtf8String) {\t\t// \"UTF8_STRING\"\n          type = t;\n          break;\n\t}\n        // rest are only used if no utf-8 available:\n        if (t == fl_XaText ||\t\t\t// \"TEXT\"\n            t == fl_XaTextUriList ||\t\t// \"text/uri-list\"\n            t == fl_XaCompoundText) type = t;\t// \"COMPOUND_TEXT\"\n      }\n      fl_dnd_type = type;\n\n      event = FL_DND_ENTER;\n      Fl::e_text = unknown;\n      Fl::e_length = unknown_len;\n      break;\n\n    } else if (message == fl_XdndPosition) {\n      fl_xmousewin = window;\n      in_a_window = true;\n      fl_dnd_source_window = data[0];\n      Fl::e_x_root = data[2]>>16;\n      Fl::e_y_root = data[2]&0xFFFF;\n      if (window) {\n        Fl::e_x = Fl::e_x_root-window->x();\n        Fl::e_y = Fl::e_y_root-window->y();\n      }\n      fl_event_time = data[3];\n      fl_dnd_source_action = data[4];\n      fl_dnd_action = fl_XdndActionCopy;\n      Fl::e_text = unknown;\n      Fl::e_length = unknown_len;\n      int accept = Fl::handle(FL_DND_DRAG, window);\n      fl_sendClientMessage(data[0], fl_XdndStatus,\n                           fl_xevent->xclient.window,\n                           accept ? 1 : 0,\n                           0, // used for xy rectangle to not send position inside\n                           0, // used for width+height of rectangle\n                           accept ? fl_dnd_action : None);\n      return 1;\n\n    } else if (message == fl_XdndLeave) {\n      fl_dnd_source_window = 0; // don't send a finished message to it\n      event = FL_DND_LEAVE;\n      Fl::e_text = unknown;\n      Fl::e_length = unknown_len;\n      break;\n\n    } else if (message == fl_XdndDrop) {\n      fl_xmousewin = window;\n      in_a_window = true;\n      fl_dnd_source_window = data[0];\n      fl_event_time = data[2];\n      Window to_window = fl_xevent->xclient.window;\n      Fl::e_text = unknown;\n      Fl::e_length = unknown_len;\n      if (Fl::handle(FL_DND_RELEASE, window)) {\n        fl_selection_requestor = Fl::belowmouse();\n        Fl::e_clipboard_type = Fl::clipboard_plain_text;\n        XConvertSelection(fl_display, fl_XdndSelection,\n                          fl_dnd_type, XA_SECONDARY,\n                          to_window, fl_event_time);\n      } else {\n        // Send the finished message if I refuse the drop.\n        // It is not clear whether I can just send finished always,\n        // or if I have to wait for the SelectionNotify event as the\n        // code is currently doing.\n        fl_sendClientMessage(fl_dnd_source_window, fl_XdndFinished, to_window);\n        fl_dnd_source_window = 0;\n      }\n      return 1;\n\n    }\n    break;}\n\n  case UnmapNotify:\n    event = FL_HIDE;\n    break;\n\n  case Expose:\n    Fl_X::i(window)->wait_for_expose = 0;\n#  if 0\n    // try to keep windows on top even if WM_TRANSIENT_FOR does not work:\n    // opaque move/resize window managers do not like this, so I disabled it.\n    if (Fl::first_window()->non_modal() && window != Fl::first_window())\n      Fl::first_window()->show();\n#  endif\n\n  case GraphicsExpose:\n    window->damage(FL_DAMAGE_EXPOSE, xevent.xexpose.x, xevent.xexpose.y,\n                   xevent.xexpose.width, xevent.xexpose.height);\n    return 1;\n\n  case FocusIn:\n    if (fl_xim_ic) XSetICFocus(fl_xim_ic);\n    event = FL_FOCUS;\n    // If the user has toggled from another application to this one,\n    // then it's a good time to check for clipboard changes.\n    poll_clipboard_owner();\n    break;\n\n  case FocusOut:\n    if (fl_xim_ic) XUnsetICFocus(fl_xim_ic);\n    event = FL_UNFOCUS;\n    break;\n\n  case KeyPress:\n  case KeyRelease: {\n  KEYPRESS:\n    int keycode = xevent.xkey.keycode;\n    fl_key_vector[keycode/8] |= (1 << (keycode%8));\n    static char *kp_buffer = NULL;\n    static int kp_buffer_len = 0;\n    int len=0;\n    KeySym keysym;\n    if (kp_buffer_len == 0) {\n      kp_buffer_len = 4096;\n      kp_buffer = (char*) malloc(kp_buffer_len);\n    }\n    if (xevent.type == KeyPress) {\n      event = FL_KEYDOWN;\n      len = 0;\n\n      if (fl_xim_ic) {\n\tStatus status;\n\tlen = XUtf8LookupString(fl_xim_ic, (XKeyPressedEvent *)&xevent.xkey,\n\t\t\t     kp_buffer, kp_buffer_len, &keysym, &status);\n\n\twhile (status == XBufferOverflow && kp_buffer_len < 50000) {\n\t  kp_buffer_len = kp_buffer_len * 5 + 1;\n\t  kp_buffer = (char*)realloc(kp_buffer, kp_buffer_len);\n\t  len = XUtf8LookupString(fl_xim_ic, (XKeyPressedEvent *)&xevent.xkey,\n\t\t\t     kp_buffer, kp_buffer_len, &keysym, &status);\n\t}\n\tkeysym = fl_KeycodeToKeysym(fl_display, keycode, 0);\n      } else {\n        //static XComposeStatus compose;\n        len = XLookupString((XKeyEvent*)&(xevent.xkey),\n                             kp_buffer, kp_buffer_len, &keysym, 0/*&compose*/);\n        if (keysym && keysym < 0x400) { // a character in latin-1,2,3,4 sets\n          // force it to type a character (not sure if this ever is needed):\n          // if (!len) {kp_buffer[0] = char(keysym); len = 1;}\n          len = fl_utf8encode(XKeysymToUcs(keysym), kp_buffer);\n          if (len < 1) len = 1;\n          // ignore all effects of shift on the keysyms, which makes it a lot\n          // easier to program shortcuts and is Windoze-compatible:\n          keysym = fl_KeycodeToKeysym(fl_display, keycode, 0);\n        }\n      }\n      kp_buffer[len] = 0;\n      Fl::e_text = kp_buffer;\n      Fl::e_length = len;\n    } else {\n      // Stupid X sends fake key-up events when a repeating key is held\n      // down, probably due to some back compatibility problem. Fortunately\n      // we can detect this because the repeating KeyPress event is in\n      // the queue, get it and execute it instead:\n\n      // Bool XkbSetDetectableAutoRepeat ( display, detectable, supported_rtrn )\n      // Display * display ;\n      // Bool detectable ;\n      // Bool * supported_rtrn ;\n      // ...would be the easy way to correct this issue. Unfortunately, this call is also\n      // broken on many Unix distros including Ubuntu and Solaris (as of Dec 2009)\n\n      // Bogus KeyUp events are generated by repeated KeyDown events. One\n      // necessary condition is an identical key event pending right after\n      // the bogus KeyUp.\n      // The new code introduced Dec 2009 differs in that it only checks the very\n      // next event in the queue, not the entire queue of events.\n      // This function wrongly detects a repeat key if a software keyboard\n      // sends a burst of events containing two consecutive equal keys. However,\n      // in every non-gaming situation, this is no problem because both KeyPress\n      // events will cause the expected behavior.\n      XEvent peekevent;\n      if (XPending(fl_display)) {\n        XPeekEvent(fl_display, &peekevent);\n        if (   (peekevent.type == KeyPress) // must be a KeyPress event\n            && (peekevent.xkey.keycode == xevent.xkey.keycode) // must be the same key\n            && (peekevent.xkey.time == xevent.xkey.time) // must be sent at the exact same time\n            ) {\n          XNextEvent(fl_display, &xevent);\n          goto KEYPRESS;\n        }\n      }\n\n      event = FL_KEYUP;\n      fl_key_vector[keycode/8] &= ~(1 << (keycode%8));\n      // keyup events just get the unshifted keysym:\n      keysym = fl_KeycodeToKeysym(fl_display, keycode, 0);\n    }\n#  ifdef __sgi\n    // You can plug a microsoft keyboard into an sgi but the extra shift\n    // keys are not translated.  Make them translate like XFree86 does:\n    if (!keysym) switch(keycode) {\n    case 147: keysym = FL_Meta_L; break;\n    case 148: keysym = FL_Meta_R; break;\n    case 149: keysym = FL_Menu; break;\n    }\n#  endif\n#  if BACKSPACE_HACK\n    // Attempt to fix keyboards that send \"delete\" for the key in the\n    // upper-right corner of the main keyboard.  But it appears that\n    // very few of these remain?\n    static int got_backspace = 0;\n    if (!got_backspace) {\n      if (keysym == FL_Delete) keysym = FL_BackSpace;\n      else if (keysym == FL_BackSpace) got_backspace = 1;\n    }\n#  endif\n    // For the first few years, there wasn't a good consensus on what the\n    // Windows keys should be mapped to for X11. So we need to help out a\n    // bit and map all variants to the same FLTK key...\n    switch (keysym) {\n\tcase XK_Meta_L:\n\tcase XK_Hyper_L:\n\tcase XK_Super_L:\n\t  keysym = FL_Meta_L;\n\t  break;\n\tcase XK_Meta_R:\n\tcase XK_Hyper_R:\n\tcase XK_Super_R:\n\t  keysym = FL_Meta_R;\n\t  break;\n      }\n    // Convert the multimedia keys to safer, portable values\n    switch (keysym) { // XF names come from X11/XF86keysym.h\n      case 0x1008FF11: // XF86XK_AudioLowerVolume:\n\tkeysym = FL_Volume_Down;\n\tbreak;\n      case 0x1008FF12: // XF86XK_AudioMute:\n\tkeysym = FL_Volume_Mute;\n\tbreak;\n      case 0x1008FF13: // XF86XK_AudioRaiseVolume:\n\tkeysym = FL_Volume_Up;\n\tbreak;\n      case 0x1008FF14: // XF86XK_AudioPlay:\n\tkeysym = FL_Media_Play;\n\tbreak;\n      case 0x1008FF15: // XF86XK_AudioStop:\n\tkeysym = FL_Media_Stop;\n\tbreak;\n      case 0x1008FF16: // XF86XK_AudioPrev:\n\tkeysym = FL_Media_Prev;\n\tbreak;\n      case 0x1008FF17: // XF86XK_AudioNext:\n\tkeysym = FL_Media_Next;\n\tbreak;\n      case 0x1008FF18: // XF86XK_HomePage:\n\tkeysym = FL_Home_Page;\n\tbreak;\n      case 0x1008FF19: // XF86XK_Mail:\n\tkeysym = FL_Mail;\n\tbreak;\n      case 0x1008FF1B: // XF86XK_Search:\n\tkeysym = FL_Search;\n\tbreak;\n      case 0x1008FF26: // XF86XK_Back:\n\tkeysym = FL_Back;\n\tbreak;\n      case 0x1008FF27: // XF86XK_Forward:\n\tkeysym = FL_Forward;\n\tbreak;\n      case 0x1008FF28: // XF86XK_Stop:\n\tkeysym = FL_Stop;\n\tbreak;\n      case 0x1008FF29: // XF86XK_Refresh:\n\tkeysym = FL_Refresh;\n\tbreak;\n      case 0x1008FF2F: // XF86XK_Sleep:\n\tkeysym = FL_Sleep;\n\tbreak;\n      case 0x1008FF30: // XF86XK_Favorites:\n\tkeysym = FL_Favorites;\n\tbreak;\n    }\n    // We have to get rid of the XK_KP_function keys, because they are\n    // not produced on Windoze and thus case statements tend not to check\n    // for them.  There are 15 of these in the range 0xff91 ... 0xff9f\n    if (keysym >= 0xff91 && keysym <= 0xff9f) {\n      // Map keypad keysym to character or keysym depending on\n      // numlock state...\n      unsigned long keysym1 = fl_KeycodeToKeysym(fl_display, keycode, 1);\n      if (keysym1 <= 0x7f || (keysym1 > 0xff9f && keysym1 <= FL_KP_Last))\n        Fl::e_original_keysym = (int)(keysym1 | FL_KP);\n      if ((xevent.xkey.state & Mod2Mask) &&\n          (keysym1 <= 0x7f || (keysym1 > 0xff9f && keysym1 <= FL_KP_Last))) {\n        // Store ASCII numeric keypad value...\n        keysym = keysym1 | FL_KP;\n        kp_buffer[0] = char(keysym1) & 0x7F;\n        len = 1;\n      } else {\n        // Map keypad to special key...\n        static const unsigned short table[15] = {\n          FL_F+1, FL_F+2, FL_F+3, FL_F+4,\n          FL_Home, FL_Left, FL_Up, FL_Right,\n          FL_Down, FL_Page_Up, FL_Page_Down, FL_End,\n          0xff0b/*XK_Clear*/, FL_Insert, FL_Delete};\n        keysym = table[keysym-0xff91];\n      }\n    } else {\n      // Store this so we can later know if the KP was used\n      Fl::e_original_keysym = (int)keysym;\n    }\n    Fl::e_keysym = int(keysym);\n\n    // replace XK_ISO_Left_Tab (Shift-TAB) with FL_Tab (modifier flags are set correctly by X11)\n    if (Fl::e_keysym == 0xfe20) Fl::e_keysym = FL_Tab;\n\n    set_event_xy();\n    Fl::e_is_click = 0; }\n    break;\n  \n  case ButtonPress:\n    Fl::e_keysym = FL_Button + xevent.xbutton.button;\n    set_event_xy();\n    Fl::e_dx = Fl::e_dy = 0;\n    if (xevent.xbutton.button == Button4) {\n      Fl::e_dy = -1; // Up\n      event = FL_MOUSEWHEEL;\n    } else if (xevent.xbutton.button == Button5) {\n      Fl::e_dy = +1; // Down\n      event = FL_MOUSEWHEEL;\n    } else if (xevent.xbutton.button == 6) {\n\tFl::e_dx = -1; // Left\n\tevent = FL_MOUSEWHEEL;\n    } else if (xevent.xbutton.button == 7) {\n\tFl::e_dx = +1; // Right\n\tevent = FL_MOUSEWHEEL;\n    } else {\n      Fl::e_state |= (FL_BUTTON1 << (xevent.xbutton.button-1));\n      event = FL_PUSH;\n      checkdouble();\n    }\n\n    fl_xmousewin = window;\n    in_a_window = true;\n    break;\n\n  case PropertyNotify:\n    if (xevent.xproperty.atom == fl_NET_WM_STATE) {\n      int fullscreen_state = 0;\n      if (xevent.xproperty.state != PropertyDelete) {\n        unsigned long nitems;\n        unsigned long *words = 0;\n        if (0 == get_xwinprop(xid, fl_NET_WM_STATE, 64, &nitems, &words) ) { \n          for (unsigned long item = 0; item < nitems; item++) {\n            if (words[item] == fl_NET_WM_STATE_FULLSCREEN) {\n              fullscreen_state = 1;\n            }\n          }\n        }\n\tif ( words ) { XFree(words); words = 0; }\n      }\n      if (window->fullscreen_active() && !fullscreen_state) {\n        window->_clear_fullscreen();\n        event = FL_FULLSCREEN;\n      }\n      if (!window->fullscreen_active() && fullscreen_state) {\n        window->_set_fullscreen();\n        event = FL_FULLSCREEN;\n      }\n    }\n    break;\n\n  case MotionNotify:\n    set_event_xy();\n#  if CONSOLIDATE_MOTION\n    send_motion = fl_xmousewin = window;\n    in_a_window = true;\n    return 0;\n#  else\n    event = FL_MOVE;\n    fl_xmousewin = window;\n    in_a_window = true;\n    break;\n#  endif\n\n  case ButtonRelease:\n    Fl::e_keysym = FL_Button + xevent.xbutton.button;\n    set_event_xy();\n    Fl::e_state &= ~(FL_BUTTON1 << (xevent.xbutton.button-1));\n    if (xevent.xbutton.button == Button4 ||\n        xevent.xbutton.button == Button5) return 0;\n    event = FL_RELEASE;\n\n    fl_xmousewin = window;\n    in_a_window = true;\n    break;\n\n  case EnterNotify:\n    if (xevent.xcrossing.detail == NotifyInferior) break;\n    // XInstallColormap(fl_display, Fl_X::i(window)->colormap);\n    set_event_xy();\n    Fl::e_state = xevent.xcrossing.state << 16;\n    event = FL_ENTER;\n\n    fl_xmousewin = window;\n    in_a_window = true;\n    { XIMStyles *xim_styles = NULL;\n      if(!fl_xim_im || XGetIMValues(fl_xim_im, XNQueryInputStyle, &xim_styles, NULL, NULL)) {\n\tfl_init_xim();\n      }\n      if (xim_styles) XFree(xim_styles);\n    }\n    break;\n\n  case LeaveNotify:\n    if (xevent.xcrossing.detail == NotifyInferior) break;\n    set_event_xy();\n    Fl::e_state = xevent.xcrossing.state << 16;\n    fl_xmousewin = 0;\n    in_a_window = false; // make do_queued_events produce FL_LEAVE event\n    return 0;\n\n  // We cannot rely on the x,y position in the configure notify event.\n  // I now think this is an unavoidable problem with X: it is impossible\n  // for a window manager to prevent the \"real\" notify event from being\n  // sent when it resizes the contents, even though it can send an\n  // artificial event with the correct position afterwards (and some\n  // window managers do not send this fake event anyway)\n  // So anyway, do a round trip to find the correct x,y:\n  case MapNotify:\n    event = FL_SHOW;\n\n  case ConfigureNotify: {\n    if (window->parent()) break; // ignore child windows\n\n    // figure out where OS really put window\n    XWindowAttributes actual;\n    XGetWindowAttributes(fl_display, fl_xid(window), &actual);\n    Window cr; int X, Y, W = actual.width, H = actual.height;\n    XTranslateCoordinates(fl_display, fl_xid(window), actual.root,\n                          0, 0, &X, &Y, &cr);\n\n    // tell Fl_Window about it and set flag to prevent echoing:\n    resize_bug_fix = window;\n    window->resize(X, Y, W, H);\n    break; // allow add_handler to do something too\n    }\n\n  case ReparentNotify: {\n    int xpos, ypos;\n    Window junk;\n\n    // on some systems, the ReparentNotify event is not handled as we would expect.\n    XErrorHandler oldHandler = XSetErrorHandler(catchXExceptions());\n\n    //ReparentNotify gives the new position of the window relative to\n    //the new parent. FLTK cares about the position on the root window.\n    XTranslateCoordinates(fl_display, xevent.xreparent.parent,\n                          XRootWindow(fl_display, fl_screen),\n                          xevent.xreparent.x, xevent.xreparent.y,\n                          &xpos, &ypos, &junk);\n    XSetErrorHandler(oldHandler);\n\n    // tell Fl_Window about it and set flag to prevent echoing:\n    if ( !wasXExceptionRaised() ) {\n      resize_bug_fix = window;\n      window->position(xpos, ypos);\n    }\n    break;\n    }\n  }\n\n#if HAVE_XFIXES\n  switch (xevent.type - xfixes_event_base) {\n  case XFixesSelectionNotify: {\n    // Someone feeding us bogus events?\n    if (!have_xfixes)\n      return true;\n\n    XFixesSelectionNotifyEvent *selection_notify = (XFixesSelectionNotifyEvent *)&xevent;\n\n    if ((selection_notify->selection == XA_PRIMARY) && !fl_i_own_selection[0])\n      handle_clipboard_timestamp(0, selection_notify->selection_timestamp);\n    else if ((selection_notify->selection == CLIPBOARD) && !fl_i_own_selection[1])\n      handle_clipboard_timestamp(1, selection_notify->selection_timestamp);\n\n    return true;\n    }\n  }\n#endif\n\n  return Fl::handle(event, window);\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid Fl_Window::resize(int X,int Y,int W,int H) {\n  int is_a_move = (X != x() || Y != y());\n  int is_a_resize = (W != w() || H != h());\n  int resize_from_program = (this != resize_bug_fix);\n  if (!resize_from_program) resize_bug_fix = 0;\n  if (is_a_move && resize_from_program) set_flag(FORCE_POSITION);\n  else if (!is_a_resize && !is_a_move) return;\n  if (is_a_resize) {\n    Fl_Group::resize(X,Y,W,H);\n    if (shown()) {redraw();}\n  } else {\n    x(X); y(Y);\n  }\n\n  if (resize_from_program && is_a_resize && !resizable()) {\n    size_range(w(), h(), w(), h());\n  }\n\n  if (resize_from_program && shown()) {\n    if (is_a_resize) {\n      if (!resizable()) size_range(w(),h(),w(),h());\n      if (is_a_move) {\n        XMoveResizeWindow(fl_display, i->xid, X, Y, W>0 ? W : 1, H>0 ? H : 1);\n      } else {\n        XResizeWindow(fl_display, i->xid, W>0 ? W : 1, H>0 ? H : 1);\n      }\n    } else\n      XMoveWindow(fl_display, i->xid, X, Y);\n  }\n}\n\n////////////////////////////////////////////////////////////////\n\n#define _NET_WM_STATE_REMOVE        0  /* remove/unset property */\n#define _NET_WM_STATE_ADD           1  /* add/set property */\n#define _NET_WM_STATE_TOGGLE        2  /* toggle property  */\n\nstatic void send_wm_event(Window wnd, Atom message,\n                          unsigned long d0, unsigned long d1=0,\n                          unsigned long d2=0, unsigned long d3=0,\n                          unsigned long d4=0) {\n  XEvent e;\n  e.xany.type = ClientMessage;\n  e.xany.window = wnd;\n  e.xclient.message_type = message;\n  e.xclient.format = 32;\n  e.xclient.data.l[0] = d0;\n  e.xclient.data.l[1] = d1;\n  e.xclient.data.l[2] = d2;\n  e.xclient.data.l[3] = d3;\n  e.xclient.data.l[4] = d4;\n  XSendEvent(fl_display, RootWindow(fl_display, fl_screen),\n             0, SubstructureNotifyMask | SubstructureRedirectMask,\n             &e);\n}\n\nstatic void send_wm_state_event(Window wnd, int add, Atom prop) {\n  send_wm_event(wnd, fl_NET_WM_STATE,\n                add ? _NET_WM_STATE_ADD : _NET_WM_STATE_REMOVE, prop);\n}\n\nint Fl_X::ewmh_supported() {\n  static int result = -1;\n\n  if (result == -1) {\n    result = 0;\n    unsigned long nitems;\n    unsigned long *words = 0;\n    if (0 == get_xwinprop(XRootWindow(fl_display, fl_screen), fl_NET_SUPPORTING_WM_CHECK, 64,\n                          &nitems, &words) && nitems == 1) {\n      Window child = words[0];\n      if ( words ) { XFree(words); words = 0; }\n      if (0 == get_xwinprop(child, fl_NET_SUPPORTING_WM_CHECK, 64,\n                           &nitems, &words) ) {\n        if ( nitems == 1) result = (child == words[0]);\n      }\n    }\n    if ( words ) { XFree(words); words = 0; }\n  }\n\n  return result;\n}\n\nextern Fl_Window *fl_xfocus;\n\nvoid Fl_X::activate_window(Window w) {\n  if (!ewmh_supported())\n    return;\n\n  Window prev = 0;\n\n  if (fl_xfocus) {\n    Fl_X *x = Fl_X::i(fl_xfocus);\n    if (!x)\n      return;\n    prev = x->xid;\n  }\n\n  send_wm_event(w, fl_NET_ACTIVE_WINDOW, 1 /* application */,\n                0 /* timestamp */, prev /* previously active window */);\n}\n\n/* Change an existing window to fullscreen */\nvoid Fl_Window::fullscreen_x() {\n  if (Fl_X::ewmh_supported()) {\n    int top, bottom, left, right;\n\n    top = fullscreen_screen_top;\n    bottom = fullscreen_screen_bottom;\n    left = fullscreen_screen_left;\n    right = fullscreen_screen_right;\n\n    if ((top < 0) || (bottom < 0) || (left < 0) || (right < 0)) {\n      top = Fl::screen_num(x(), y(), w(), h());\n      bottom = top;\n      left = top;\n      right = top;\n    }\n\n    send_wm_event(fl_xid(this), fl_NET_WM_FULLSCREEN_MONITORS,\n                  top, bottom, left, right);\n    send_wm_state_event(fl_xid(this), 1, fl_NET_WM_STATE_FULLSCREEN);\n  } else {\n    _set_fullscreen();\n    hide();\n    show();\n    /* We want to grab the window, not a widget, so we cannot use Fl::grab */\n    XGrabKeyboard(fl_display, fl_xid(this), 1, GrabModeAsync, GrabModeAsync, fl_event_time);\n    Fl::handle(FL_FULLSCREEN, this);\n  }\n}\n\nvoid Fl_Window::fullscreen_off_x(int X, int Y, int W, int H) {\n  if (Fl_X::ewmh_supported()) {\n    send_wm_state_event(fl_xid(this), 0, fl_NET_WM_STATE_FULLSCREEN);\n  } else {\n    _clear_fullscreen();\n    /* The grab will be lost when the window is destroyed */\n    hide();\n    resize(X,Y,W,H);\n    show();\n    Fl::handle(FL_FULLSCREEN, this);\n  }\n}\n\n////////////////////////////////////////////////////////////////\n\n// A subclass of Fl_Window may call this to associate an X window it\n// creates with the Fl_Window:\n\nvoid fl_fix_focus(); // in Fl.cxx\n\nFl_X* Fl_X::set_xid(Fl_Window* win, Window winxid) {\n  Fl_X* xp = new Fl_X;\n  xp->xid = winxid;\n  xp->other_xid = 0;\n  xp->setwindow(win);\n  xp->next = Fl_X::first;\n  xp->region = 0;\n  xp->wait_for_expose = 1;\n  xp->backbuffer_bad = 1;\n  Fl_X::first = xp;\n  if (win->modal()) {Fl::modal_ = win; fl_fix_focus();}\n  return xp;\n}\n\n// More commonly a subclass calls this, because it hides the really\n// ugly parts of X and sets all the stuff for a window that is set\n// normally.  The global variables like fl_show_iconic are so that\n// subclasses of *that* class may change the behavior...\n\nchar fl_show_iconic;    // hack for iconize()\nint fl_background_pixel = -1; // hack to speed up bg box drawing\nint fl_disable_transient_for; // secret method of removing TRANSIENT_FOR\n\nstatic const int childEventMask = ExposureMask;\n\nstatic const int XEventMask =\nExposureMask|StructureNotifyMask\n|KeyPressMask|KeyReleaseMask|KeymapStateMask|FocusChangeMask\n|ButtonPressMask|ButtonReleaseMask\n|EnterWindowMask|LeaveWindowMask\n|PropertyChangeMask\n|PointerMotionMask;\n\nvoid Fl_X::make_xid(Fl_Window* win, XVisualInfo *visual, Colormap colormap)\n{\n  Fl_Group::current(0); // get rid of very common user bug: forgot end()\n\n  int X = win->x();\n  int Y = win->y();\n  int W = win->w();\n  if (W <= 0) W = 1; // X don't like zero...\n  int H = win->h();\n  if (H <= 0) H = 1; // X don't like zero...\n  if (!win->parent() && !Fl::grab()) {\n    // center windows in case window manager does not do anything:\n#ifdef FL_CENTER_WINDOWS\n    if (!win->force_position()) {\n      win->x(X = scr_x+(scr_w-W)/2);\n      win->y(Y = scr_y+(scr_h-H)/2);\n    }\n#endif // FL_CENTER_WINDOWS\n\n    // force the window to be on-screen.  Usually the X window manager\n    // does this, but a few don't, so we do it here for consistency:\n    int scr_x, scr_y, scr_w, scr_h;\n    Fl::screen_xywh(scr_x, scr_y, scr_w, scr_h, X, Y, W, H);\n\n    if (win->border()) {\n      // ensure border is on screen:\n      // (assume extremely minimal dimensions for this border)\n      const int top = 20;\n      const int left = 1;\n      const int right = 1;\n      const int bottom = 1;\n      if (X+W+right > scr_x+scr_w) X = scr_x+scr_w-right-W;\n      if (X-left < scr_x) X = scr_x+left;\n      if (Y+H+bottom > scr_y+scr_h) Y = scr_y+scr_h-bottom-H;\n      if (Y-top < scr_y) Y = scr_y+top;\n    }\n    // now insure contents are on-screen (more important than border):\n    if (X+W > scr_x+scr_w) X = scr_x+scr_w-W;\n    if (X < scr_x) X = scr_x;\n    if (Y+H > scr_y+scr_h) Y = scr_y+scr_h-H;\n    if (Y < scr_y) Y = scr_y;\n  }\n\n  // if the window is a subwindow and our parent is not mapped yet, we\n  // mark this window visible, so that mapping the parent at a later\n  // point in time will call this function again to finally map the subwindow.\n  if (win->parent() && !Fl_X::i(win->window())) {\n    win->set_visible();\n    return;\n  }\n\n  // Compute which screen(s) we should be on if we want to go fullscreen\n  int fullscreen_top, fullscreen_bottom, fullscreen_left, fullscreen_right;\n\n  fullscreen_top = win->fullscreen_screen_top;\n  fullscreen_bottom = win->fullscreen_screen_bottom;\n  fullscreen_left = win->fullscreen_screen_left;\n  fullscreen_right = win->fullscreen_screen_right;\n\n  if ((fullscreen_top < 0) || (fullscreen_bottom < 0) ||\n      (fullscreen_left < 0) || (fullscreen_right < 0)) {\n    fullscreen_top = Fl::screen_num(X, Y, W, H);\n    fullscreen_bottom = fullscreen_top;\n    fullscreen_left = fullscreen_top;\n    fullscreen_right = fullscreen_top;\n  }\n\n\n  ulong root = win->parent() ?\n    fl_xid(win->window()) : RootWindow(fl_display, fl_screen);\n\n  XSetWindowAttributes attr;\n  int mask = CWBorderPixel|CWColormap|CWEventMask|CWBitGravity;\n  attr.event_mask = win->parent() ? childEventMask : XEventMask;\n  attr.colormap = colormap;\n  attr.border_pixel = 0;\n  attr.bit_gravity = 0; // StaticGravity;\n  if (win->override()) {\n    attr.override_redirect = 1;\n    attr.save_under = 1;\n    mask |= CWOverrideRedirect | CWSaveUnder;\n  } else attr.override_redirect = 0;\n  if (Fl::grab()) {\n    attr.save_under = 1; mask |= CWSaveUnder;\n    if (!win->border()) {attr.override_redirect = 1; mask |= CWOverrideRedirect;}\n  }\n  // For the non-EWMH fullscreen case, we cannot use the code above,\n  // since we do not want save_under, do not want to turn off the\n  // border, and cannot grab without an existing window. Besides, \n  // there is no clear_override(). \n  if (win->fullscreen_active() && !Fl_X::ewmh_supported()) {\n    int sx, sy, sw, sh;\n    attr.override_redirect = 1;\n    mask |= CWOverrideRedirect;\n    Fl::screen_xywh(sx, sy, sw, sh, fullscreen_left);\n    X = sx;\n    Fl::screen_xywh(sx, sy, sw, sh, fullscreen_right);\n    W = sx + sw - X;\n    Fl::screen_xywh(sx, sy, sw, sh, fullscreen_top);\n    Y = sy;\n    Fl::screen_xywh(sx, sy, sw, sh, fullscreen_bottom);\n    H = sy + sh - Y;\n  }\n\n  if (fl_background_pixel >= 0) {\n    attr.background_pixel = fl_background_pixel;\n    fl_background_pixel = -1;\n    mask |= CWBackPixel;\n  }\n\n  Fl_X* xp =\n    set_xid(win, XCreateWindow(fl_display,\n                               root,\n                               X, Y, W, H,\n                               0, // borderwidth\n                               visual->depth,\n                               InputOutput,\n                               visual->visual,\n                               mask, &attr));\n  int showit = 1;\n\n  if (!win->parent() && !attr.override_redirect) {\n    // Communicate all kinds 'o junk to the X Window Manager:\n\n    win->label(win->label(), win->iconlabel());\n\n    XChangeProperty(fl_display, xp->xid, WM_PROTOCOLS,\n                    XA_ATOM, 32, 0, (uchar*)&WM_DELETE_WINDOW, 1);\n\n    // send size limits and border:\n    xp->sendxjunk();\n\n    // set the class property, which controls the icon used:\n    if (win->xclass()) {\n      char buffer[1024];\n      const char *xclass = win->xclass();\n      const int len = strlen(xclass);\n      // duplicate the xclass string for use as XA_WM_CLASS\n      strcpy(buffer, xclass);\n      strcpy(buffer + len + 1, xclass);\n      // create the capitalized version:\n      buffer[len + 1] = toupper(buffer[len + 1]);\n      if (buffer[len + 1] == 'X')\n        buffer[len + 2] = toupper(buffer[len + 2]);\n      XChangeProperty(fl_display, xp->xid, XA_WM_CLASS, XA_STRING, 8, 0,\n                      (unsigned char *)buffer, len * 2 + 2);\n    }\n\n    if (win->non_modal() && xp->next && !fl_disable_transient_for) {\n      // find some other window to be \"transient for\":\n      Fl_Window* wp = xp->next->w;\n      while (wp->parent()) wp = wp->window();\n      XSetTransientForHint(fl_display, xp->xid, fl_xid(wp));\n      if (!wp->visible()) showit = 0; // guess that wm will not show it\n      if (win->modal()) {\n        Atom net_wm_state = XInternAtom (fl_display, \"_NET_WM_STATE\", 0);\n        Atom net_wm_state_skip_taskbar = XInternAtom (fl_display, \"_NET_WM_STATE_MODAL\", 0);\n        XChangeProperty (fl_display, xp->xid, net_wm_state, XA_ATOM, 32,\n            PropModeAppend, (unsigned char*) &net_wm_state_skip_taskbar, 1);\n      }\n    }\n\n    // Make sure that borderless windows do not show in the task bar\n    if (!win->border()) {\n      Atom net_wm_state = XInternAtom (fl_display, \"_NET_WM_STATE\", 0);\n      Atom net_wm_state_skip_taskbar = XInternAtom (fl_display, \"_NET_WM_STATE_SKIP_TASKBAR\", 0);\n      XChangeProperty (fl_display, xp->xid, net_wm_state, XA_ATOM, 32,\n          PropModeAppend, (unsigned char*) &net_wm_state_skip_taskbar, 1);\n    }\n\n    // If asked for, create fullscreen\n    if (win->fullscreen_active() && Fl_X::ewmh_supported()) {\n      unsigned long data[4];\n      data[0] = fullscreen_top;\n      data[1] = fullscreen_bottom;\n      data[2] = fullscreen_left;\n      data[3] = fullscreen_right;\n      XChangeProperty (fl_display, xp->xid, fl_NET_WM_FULLSCREEN_MONITORS, XA_ATOM, 32,\n                       PropModeReplace, (unsigned char*) data, 4);\n      XChangeProperty (fl_display, xp->xid, fl_NET_WM_STATE, XA_ATOM, 32,\n                       PropModeAppend, (unsigned char*) &fl_NET_WM_STATE_FULLSCREEN, 1);\n    }\n\n    // Make it receptive to DnD:\n    long version = 4;\n    XChangeProperty(fl_display, xp->xid, fl_XdndAware,\n                    XA_ATOM, sizeof(int)*8, 0, (unsigned char*)&version, 1);\n\n    XWMHints *hints = XAllocWMHints();\n    hints->input = True;\n    hints->flags = InputHint;\n    if (fl_show_iconic) {\n      hints->flags |= StateHint;\n      hints->initial_state = IconicState;\n      fl_show_iconic = 0;\n      showit = 0;\n    }\n    if (win->icon_->legacy_icon) {\n      hints->icon_pixmap = (Pixmap)win->icon_->legacy_icon;\n      hints->flags       |= IconPixmapHint;\n    }\n    XSetWMHints(fl_display, xp->xid, hints);\n    XFree(hints);\n\n    xp->set_icons();\n  }\n\n  // set the window type for menu and tooltip windows to avoid animations (compiz)\n  if (win->menu_window() || win->tooltip_window()) {\n    Atom net_wm_type = XInternAtom(fl_display, \"_NET_WM_WINDOW_TYPE\", False);\n    Atom net_wm_type_kind = XInternAtom(fl_display, \"_NET_WM_WINDOW_TYPE_MENU\", False);\n    XChangeProperty(fl_display, xp->xid, net_wm_type, XA_ATOM, 32, PropModeReplace, (unsigned char*)&net_wm_type_kind, 1);\n  }\n\n#if HAVE_XFIXES\n  // register for clipboard change notifications\n  if (have_xfixes && !win->parent()) {\n    XFixesSelectSelectionInput(fl_display, xp->xid, XA_PRIMARY,\n                               XFixesSetSelectionOwnerNotifyMask);\n    XFixesSelectSelectionInput(fl_display, xp->xid, CLIPBOARD,\n                               XFixesSetSelectionOwnerNotifyMask);\n  }\n#endif\n\n  if (win->shape_data_) {\n    win->combine_mask();\n    }\n  XMapWindow(fl_display, xp->xid);\n  if (showit) {\n    win->set_visible();\n    int old_event = Fl::e_number;\n    win->handle(Fl::e_number = FL_SHOW); // get child windows to appear\n    Fl::e_number = old_event;\n    win->redraw();\n  }\n\n  // non-EWMH fullscreen case, need grab\n  if (win->fullscreen_active() && !Fl_X::ewmh_supported()) {\n    XGrabKeyboard(fl_display, xp->xid, 1, GrabModeAsync, GrabModeAsync, fl_event_time);\n  }\n\n}\n\n////////////////////////////////////////////////////////////////\n// Send X window stuff that can be changed over time:\n\nvoid Fl_X::sendxjunk() {\n  if (w->parent() || w->override()) return; // it's not a window manager window!\n\n  if (!w->size_range_set) { // default size_range based on resizable():\n    if (w->resizable()) {\n      Fl_Widget *o = w->resizable();\n      int minw = o->w(); if (minw > 100) minw = 100;\n      int minh = o->h(); if (minh > 100) minh = 100;\n      w->size_range(w->w() - o->w() + minw, w->h() - o->h() + minh, 0, 0);\n    } else {\n      w->size_range(w->w(), w->h(), w->w(), w->h());\n    }\n    return; // because this recursively called here\n  }\n\n  XSizeHints *hints = XAllocSizeHints();\n  // memset(&hints, 0, sizeof(hints)); jreiser suggestion to fix purify?\n  hints->min_width = w->minw;\n  hints->min_height = w->minh;\n  hints->max_width = w->maxw;\n  hints->max_height = w->maxh;\n  hints->width_inc = w->dw;\n  hints->height_inc = w->dh;\n  hints->win_gravity = StaticGravity;\n\n  // see the file /usr/include/X11/Xm/MwmUtil.h:\n  // fill all fields to avoid bugs in kwm and perhaps other window managers:\n  // 0, MWM_FUNC_ALL, MWM_DECOR_ALL\n  long prop[5] = {0, 1, 1, 0, 0};\n\n  if (hints->min_width != hints->max_width ||\n      hints->min_height != hints->max_height) { // resizable\n    hints->flags = PMinSize|PWinGravity;\n    if (hints->max_width >= hints->min_width ||\n        hints->max_height >= hints->min_height) {\n      hints->flags = PMinSize|PMaxSize|PWinGravity;\n      // unfortunately we can't set just one maximum size.  Guess a\n      // value for the other one.  Some window managers will make the\n      // window fit on screen when maximized, others will put it off screen:\n      if (hints->max_width < hints->min_width) hints->max_width = Fl::w();\n      if (hints->max_height < hints->min_height) hints->max_height = Fl::h();\n    }\n    if (hints->width_inc && hints->height_inc) hints->flags |= PResizeInc;\n    if (w->aspect) {\n      // stupid X!  It could insist that the corner go on the\n      // straight line between min and max...\n      hints->min_aspect.x = hints->max_aspect.x = hints->min_width;\n      hints->min_aspect.y = hints->max_aspect.y = hints->min_height;\n      hints->flags |= PAspect;\n    }\n  } else { // not resizable:\n    hints->flags = PMinSize|PMaxSize|PWinGravity;\n    prop[0] = 1; // MWM_HINTS_FUNCTIONS\n    prop[1] = 1|2|16; // MWM_FUNC_ALL | MWM_FUNC_RESIZE | MWM_FUNC_MAXIMIZE\n  }\n\n  if (w->force_position()) {\n    hints->flags |= USPosition;\n    hints->x = w->x();\n    hints->y = w->y();\n  }\n\n  if (!w->border()) {\n    prop[0] |= 2; // MWM_HINTS_DECORATIONS\n    prop[2] = 0; // no decorations\n  }\n\n  XSetWMNormalHints(fl_display, xid, hints);\n  XChangeProperty(fl_display, xid,\n                  fl_MOTIF_WM_HINTS, fl_MOTIF_WM_HINTS,\n                  32, 0, (unsigned char *)prop, 5);\n  XFree(hints);\n}\n\nvoid Fl_Window::size_range_() {\n  size_range_set = 1;\n  if (shown()) i->sendxjunk();\n}\n\n////////////////////////////////////////////////////////////////\n\nstatic unsigned long *default_net_wm_icons = 0L;\nstatic size_t default_net_wm_icons_size = 0;\n\nstatic void icons_to_property(const Fl_RGB_Image *icons[], int count,\n                              unsigned long **property, size_t *len) {\n  size_t sz;\n  unsigned long *data;\n\n  sz = 0;\n  for (int i = 0;i < count;i++)\n    sz += 2 + icons[i]->w() * icons[i]->h();\n\n  // FIXME: Might want to sort the icons\n\n  *property = data = new unsigned long[sz];\n  *len = sz;\n\n  for (int i = 0;i < count;i++) {\n    const Fl_RGB_Image *image;\n\n    image = icons[i];\n\n    data[0] = image->w();\n    data[1] = image->h();\n    data += 2;\n\n    const uchar *in = (const uchar*)*image->data();\n    for (int y = 0;y < image->h();y++) {\n      for (int x = 0;x < image->w();x++) {\n        switch (image->d()) {\n        case 1:\n          *data = ( 0xff<<24) | (in[0]<<16) | (in[0]<<8) | in[0];\n          break;\n        case 2:\n          *data = (in[1]<<24) | (in[0]<<16) | (in[0]<<8) | in[0];\n          break;\n        case 3:\n          *data = ( 0xff<<24) | (in[0]<<16) | (in[1]<<8) | in[2];\n          break;\n        case 4:\n          *data = (in[3]<<24) | (in[0]<<16) | (in[1]<<8) | in[2];\n          break;\n        }\n        in += image->d();\n        data++;\n      }\n      in += image->ld();\n    }\n  }\n}\n\nvoid Fl_X::set_default_icons(const Fl_RGB_Image *icons[], int count) {\n  if (default_net_wm_icons) {\n    delete [] default_net_wm_icons;\n    default_net_wm_icons = 0L;\n    default_net_wm_icons_size = 0;\n  }\n\n  if (count > 0)\n    icons_to_property(icons, count,\n                      &default_net_wm_icons, &default_net_wm_icons_size);\n}\n\nvoid Fl_X::set_icons() {\n  unsigned long *net_wm_icons;\n  size_t net_wm_icons_size;\n\n  if (w->icon_->count) {\n    icons_to_property((const Fl_RGB_Image **)w->icon_->icons, w->icon_->count,\n                      &net_wm_icons, &net_wm_icons_size);\n  } else {\n    net_wm_icons = default_net_wm_icons;\n    net_wm_icons_size = default_net_wm_icons_size;\n  }\n\n  XChangeProperty (fl_display, xid, fl_NET_WM_ICON, XA_CARDINAL, 32,\n      PropModeReplace, (unsigned char*) net_wm_icons, net_wm_icons_size);\n\n  if (w->icon_->count) {\n    delete [] net_wm_icons;\n    net_wm_icons = 0L;\n    net_wm_icons_size = 0;\n  }\n}\n\n////////////////////////////////////////////////////////////////\n\nint Fl_X::set_cursor(Fl_Cursor c) {\n\n  /* The cursors are cached, because creating one takes 0.5ms including\n     opening, reading, and closing theme files. They are kept until program\n     exit by design, which valgrind will note as reachable. */\n  static Cursor xc_arrow = None;\n  static Cursor xc_cross = None;\n  static Cursor xc_wait = None;\n  static Cursor xc_insert = None;\n  static Cursor xc_hand = None;\n  static Cursor xc_help = None;\n  static Cursor xc_move = None;\n  static Cursor xc_ns = None;\n  static Cursor xc_we = None;\n  static Cursor xc_ne = None;\n  static Cursor xc_n = None;\n  static Cursor xc_nw = None;\n  static Cursor xc_e = None;\n  static Cursor xc_w = None;\n  static Cursor xc_se = None;\n  static Cursor xc_s = None;\n  static Cursor xc_sw = None;\n\n  Cursor xc;\n\n#define cache_cursor(name, var) if (var == None) { \\\n                                  var = XCreateFontCursor(fl_display, name); \\\n                                } \\\n                                xc = var\n\n  switch (c) {\n  case FL_CURSOR_ARROW:   cache_cursor(XC_left_ptr, xc_arrow); break;\n  case FL_CURSOR_CROSS:   cache_cursor(XC_tcross, xc_cross); break;\n  case FL_CURSOR_WAIT:    cache_cursor(XC_watch, xc_wait); break;\n  case FL_CURSOR_INSERT:  cache_cursor(XC_xterm, xc_insert); break;\n  case FL_CURSOR_HAND:    cache_cursor(XC_hand2, xc_hand); break;\n  case FL_CURSOR_HELP:    cache_cursor(XC_question_arrow, xc_help); break;\n  case FL_CURSOR_MOVE:    cache_cursor(XC_fleur, xc_move); break;\n  case FL_CURSOR_NS:      cache_cursor(XC_sb_v_double_arrow, xc_ns); break;\n  case FL_CURSOR_WE:      cache_cursor(XC_sb_h_double_arrow, xc_we); break;\n  case FL_CURSOR_NE:      cache_cursor(XC_top_right_corner, xc_ne); break;\n  case FL_CURSOR_N:       cache_cursor(XC_top_side, xc_n); break;\n  case FL_CURSOR_NW:      cache_cursor(XC_top_left_corner, xc_nw); break;\n  case FL_CURSOR_E:       cache_cursor(XC_right_side, xc_e); break;\n  case FL_CURSOR_W:       cache_cursor(XC_left_side, xc_w); break;\n  case FL_CURSOR_SE:      cache_cursor(XC_bottom_right_corner, xc_se); break;\n  case FL_CURSOR_S:       cache_cursor(XC_bottom_side, xc_s); break;\n  case FL_CURSOR_SW:      cache_cursor(XC_bottom_left_corner, xc_sw); break;\n  default:\n    return 0;\n  }\n\n#undef cache_cursor\n\n  XDefineCursor(fl_display, xid, xc);\n\n  return 1;\n}\n\nint Fl_X::set_cursor(const Fl_RGB_Image *image, int hotx, int hoty) {\n#if ! HAVE_XCURSOR\n  return 0;\n#else\n  XcursorImage *cursor;\n  Cursor xc;\n\n  if ((hotx < 0) || (hotx >= image->w()))\n    return 0;\n  if ((hoty < 0) || (hoty >= image->h()))\n    return 0;\n\n  cursor = XcursorImageCreate(image->w(), image->h());\n  if (!cursor)\n    return 0;\n\n  const uchar *i = (const uchar*)*image->data();\n  XcursorPixel *o = cursor->pixels;\n  for (int y = 0;y < image->h();y++) {\n    for (int x = 0;x < image->w();x++) {\n      switch (image->d()) {\n      case 1:\n        *o = (0xff<<24) | (i[0]<<16) | (i[0]<<8) | i[0];\n        break;\n      case 2:\n        *o = (i[1]<<24) | (i[0]<<16) | (i[0]<<8) | i[0];\n        break;\n      case 3:\n        *o = (0xff<<24) | (i[0]<<16) | (i[1]<<8) | i[2];\n        break;\n      case 4:\n        *o = (i[3]<<24) | (i[0]<<16) | (i[1]<<8) | i[2];\n        break;\n      }\n      i += image->d();\n      o++;\n    }\n    i += image->ld();\n  }\n\n  cursor->xhot = hotx;\n  cursor->yhot = hoty;\n\n  xc = XcursorImageLoadCursor(fl_display, cursor);\n  XDefineCursor(fl_display, xid, xc);\n  XFreeCursor(fl_display, xc);\n\n  XcursorImageDestroy(cursor);\n\n  return 1;\n#endif\n}\n\n////////////////////////////////////////////////////////////////\n\n// returns pointer to the filename, or null if name ends with '/'\nconst char *fl_filename_name(const char *name) {\n  const char *p,*q;\n  if (!name) return (0);\n  for (p=q=name; *p;) if (*p++ == '/') q = p;\n  return q;\n}\n\nvoid Fl_Window::label(const char *name,const char *iname) {\n  Fl_Widget::label(name);\n  iconlabel_ = iname;\n  if (shown() && !parent()) {\n    if (!name) name = \"\";\n    int namelen = strlen(name);\n    if (!iname) iname = fl_filename_name(name);\n    int inamelen = strlen(iname);\n    XChangeProperty(fl_display, i->xid, fl_NET_WM_NAME,      fl_XaUtf8String, 8, 0, (uchar*)name,  namelen);\t// utf8\n    XChangeProperty(fl_display, i->xid, XA_WM_NAME,          XA_STRING,       8, 0, (uchar*)name,  namelen);\t// non-utf8\n    XChangeProperty(fl_display, i->xid, fl_NET_WM_ICON_NAME, fl_XaUtf8String, 8, 0, (uchar*)iname, inamelen);\t// utf8\n    XChangeProperty(fl_display, i->xid, XA_WM_ICON_NAME,     XA_STRING,       8, 0, (uchar*)iname, inamelen);\t// non-utf8\n  }\n}\n\n////////////////////////////////////////////////////////////////\n// Implement the virtual functions for the base Fl_Window class:\n\n// If the box is a filled rectangle, we can make the redisplay *look*\n// faster by using X's background pixel erasing.  We can make it\n// actually *be* faster by drawing the frame only, this is done by\n// setting fl_boxcheat, which is seen by code in fl_drawbox.cxx:\n//\n// On XFree86 (and prehaps all X's) this has a problem if the window\n// is resized while a save-behind window is atop it.  The previous\n// contents are restored to the area, but this assumes the area\n// is cleared to background color.  So this is disabled in this version.\n// Fl_Window *fl_boxcheat;\nstatic inline int can_boxcheat(uchar b) {return (b==1 || ((b&2) && b<=15));}\n\nvoid Fl_Window::show() {\n  image(Fl::scheme_bg_);\n  if (Fl::scheme_bg_) {\n    labeltype(FL_NORMAL_LABEL);\n    align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE | FL_ALIGN_CLIP);\n  } else {\n    labeltype(FL_NO_LABEL);\n  }\n  Fl_Tooltip::exit(this);\n  if (!shown()) {\n    fl_open_display();\n    // Don't set background pixel for double-buffered windows...\n    if (type() != FL_DOUBLE_WINDOW && can_boxcheat(box())) {\n      fl_background_pixel = int(fl_xpixel(color()));\n    }\n    Fl_X::make_xid(this);\n  } else {\n    XMapRaised(fl_display, i->xid);\n  }\n#ifdef USE_PRINT_BUTTON\nvoid preparePrintFront(void);\npreparePrintFront();\n#endif\n}\n\nWindow fl_window;\nFl_Window *Fl_Window::current_;\nGC fl_gc;\n\n// make X drawing go into this window (called by subclass flush() impl.)\nvoid Fl_Window::make_current() {\n  static GC gc; // the GC used by all X windows\n  if (!shown()) {\n    fl_alert(\"Fl_Window::make_current(), but window is not shown().\");\n    Fl::fatal(\"Fl_Window::make_current(), but window is not shown().\");\n  }\n  if (!gc) gc = XCreateGC(fl_display, i->xid, 0, 0);\n  fl_window = i->xid;\n  fl_gc = gc;\n  current_ = this;\n  fl_clip_region(0);\n\n#ifdef FLTK_USE_CAIRO\n  // update the cairo_t context\n  if (Fl::cairo_autolink_context()) Fl::cairo_make_current(this);\n#endif\n}\n\nFL_EXPORT Window fl_xid_(const Fl_Window *w) {\n  Fl_X *temp = Fl_X::i(w);\n  return temp ? temp->xid : 0;\n}\n\nstatic void decorated_win_size(Fl_Window *win, int &w, int &h)\n{\n  w = win->w();\n  h = win->h();\n  if (!win->shown() || win->parent() || !win->border() || !win->visible()) return;\n  Window root, parent, *children;\n  unsigned n = 0;\n  Status status = XQueryTree(fl_display, Fl_X::i(win)->xid, &root, &parent, &children, &n); \n  if (status != 0 && n) XFree(children);\n  // when compiz is used, root and parent are the same window \n  // and I don't know where to find the window decoration\n  if (status == 0 || root == parent) return; \n  XWindowAttributes attributes;\n  XGetWindowAttributes(fl_display, parent, &attributes);\n  w = attributes.width;\n  h = attributes.height;\n}\n\nint Fl_Window::decorated_h()\n{\n  int w, h;\n  decorated_win_size(this, w, h);\n  return h;\n}\n\nint Fl_Window::decorated_w()\n{\n  int w, h;\n  decorated_win_size(this, w, h);\n  return w;\n}\n\nvoid Fl_Paged_Device::print_window(Fl_Window *win, int x_offset, int y_offset)\n{\n  if (!win->shown() || win->parent() || !win->border() || !win->visible()) {\n    this->print_widget(win, x_offset, y_offset);\n    return;\n  }\n  Fl_Display_Device::display_device()->set_current();\n  win->show();\n  Fl::check();\n  win->make_current();\n  Window root, parent, *children, child_win, from;\n  unsigned n = 0;\n  int bx, bt, do_it;\n  from = fl_window;\n  do_it = (XQueryTree(fl_display, fl_window, &root, &parent, &children, &n) != 0 && \n\t   XTranslateCoordinates(fl_display, fl_window, parent, 0, 0, &bx, &bt, &child_win) == True);\n  if (n) XFree(children);\n  // hack to bypass STR #2648: when compiz is used, root and parent are the same window \n  // and I don't know where to find the window decoration\n  if (do_it && root == parent) do_it = 0; \n  if (!do_it) {\n    this->set_current();\n    this->print_widget(win, x_offset, y_offset);\n    return;\n  }\n  fl_window = parent;\n  uchar *top_image = 0, *left_image = 0, *right_image = 0, *bottom_image = 0;\n  top_image = fl_read_image(NULL, 0, 0, - (win->w() + 2 * bx), bt);\n  if (bx) {\n    left_image = fl_read_image(NULL, 0, bt, -bx, win->h() + bx);\n    right_image = fl_read_image(NULL, win->w() + bx, bt, -bx, win->h() + bx);\n    bottom_image = fl_read_image(NULL, 0, bt + win->h(), -(win->w() + 2*bx), bx);\n  }\n  fl_window = from;\n  this->set_current();\n  if (top_image) {\n    fl_draw_image(top_image, x_offset, y_offset, win->w() + 2 * bx, bt, 3);\n    delete[] top_image;\n  }\n  if (bx) {\n    if (left_image) fl_draw_image(left_image, x_offset, y_offset + bt, bx, win->h() + bx, 3);\n    if (right_image) fl_draw_image(right_image, x_offset + win->w() + bx, y_offset + bt, bx, win->h() + bx, 3);\n    if (bottom_image) fl_draw_image(bottom_image, x_offset, y_offset + bt + win->h(), win->w() + 2*bx, bx, 3);\n    if (left_image) delete[] left_image;\n    if (right_image) delete[] right_image;\n    if (bottom_image) delete[] bottom_image;\n  }\n  this->print_widget( win, x_offset + bx, y_offset + bt );\n}\n\n#ifdef USE_PRINT_BUTTON\n// to test the Fl_Printer class creating a \"Print front window\" button in a separate window\n// contains also preparePrintFront call above\n#include <FL/Fl_Printer.H>\n#include <FL/Fl_Button.H>\nvoid printFront(Fl_Widget *o, void *data)\n{\n  Fl_Printer printer;\n  o->window()->hide();\n  Fl_Window *win = Fl::first_window();\n  if(!win) return;\n  int w, h;\n  if( printer.start_job(1) ) { o->window()->show(); return; }\n  if( printer.start_page() ) { o->window()->show(); return; }\n  printer.printable_rect(&w,&h);\n  // scale the printer device so that the window fits on the page\n  float scale = 1;\n  int ww = win->decorated_w();\n  int wh = win->decorated_h();\n  if (ww > w || wh > h) {\n    scale = (float)w/ww;\n    if ((float)h/wh < scale) scale = (float)h/wh;\n    printer.scale(scale, scale);\n  }\n\n// #define ROTATE 20.0\n#ifdef ROTATE\n  printer.scale(scale * 0.8, scale * 0.8);\n  printer.printable_rect(&w, &h);\n  printer.origin(w/2, h/2 );\n  printer.rotate(ROTATE);\n  printer.print_widget( win, - win->w()/2, - win->h()/2 );\n  //printer.print_window_part( win, 0,0, win->w(), win->h(), - win->w()/2, - win->h()/2 );\n#else  \n  printer.print_window(win);\n#endif\n\n  printer.end_page();\n  printer.end_job();\n  o->window()->show();\n}\n\nvoid preparePrintFront(void)\n{\n  static int first=1;\n  if(!first) return;\n  first=0;\n  static Fl_Window w(0,0,150,30);\n  static Fl_Button b(0,0,w.w(),w.h(), \"Print front window\");\n  b.callback(printFront);\n  w.end();\n  w.show();\n}\n#endif // USE_PRINT_BUTTON\n\n#endif\n\n//\n// End of \"$Id: Fl_x.cxx 10412 2014-10-29 20:25:46Z cand $\".\n//\n",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/src/glut_compatability.cxx": "//\n// \"$Id: glut_compatability.cxx 9697 2012-10-08 10:32:05Z manolo $\"\n//\n// GLUT emulation routines for the Fast Light Tool Kit (FLTK).\n//\n// Copyright 1998-2010 by Bill Spitzak and others.\n//\n// This library is free software. Distribution and use rights are outlined in\n// the file \"COPYING\" which should have been included with this file.  If this\n// file is missing or damaged, see the license at:\n//\n//     http://www.fltk.org/COPYING.php\n//\n// Please report all bugs and problems on the following page:\n//\n//     http://www.fltk.org/str.php\n//\n\n// Emulation of Glut using fltk.\n\n// GLUT is Copyright (c) Mark J. Kilgard, 1994, 1995, 1996.\n// \"This program is freely distributable without licensing fees  and is\n// provided without guarantee or warrantee expressed or  implied. This\n// program is -not- in the public domain.\"\n\n// Although I have copied the GLUT API, none of my code is based on\n// any Glut implementation details and is therefore covered by the LGPL.\n\n#include \"flstring.h\"\n#if HAVE_GL\n\n#  include <FL/glut.H>\n#  ifdef HAVE_GLXGETPROCADDRESSARB\n#    define GLX_GLXEXT_LEGACY\n#    include <GL/glx.h>\n#  endif // HAVE_GLXGETPROCADDRESSARB\n#  ifdef HAVE_DLFCN_H\n#    include <dlfcn.h>\n#  endif // HAVE_DLFCN_H\n#  define MAXWINDOWS 32\nstatic Fl_Glut_Window *windows[MAXWINDOWS+1];\n\nstatic void (*glut_idle_func)() = 0; // global glut idle function\n\nFl_Glut_Window *glut_window;\nint glut_menu;\nvoid (*glut_menustate_function)(int);\nvoid (*glut_menustatus_function)(int,int,int);\n\nstatic void default_reshape(int w, int h) {glViewport(0,0,w,h);}\nstatic void default_display() {}\n\nvoid Fl_Glut_Window::make_current() {\n  glut_window = this;\n  if (shown()) Fl_Gl_Window::make_current();\n}\n\nstatic int indraw;\nvoid Fl_Glut_Window::draw() {\n  glut_window = this;\n  indraw = 1;\n  if (!valid()) {reshape(w(),h()); valid(1);}\n  display();\n  indraw = 0;\n}\n\nvoid glutSwapBuffers() {\n  if (!indraw) glut_window->swap_buffers();\n}\n\nvoid Fl_Glut_Window::draw_overlay() {\n  glut_window = this;\n  if (!valid()) {reshape(w(),h()); valid(1);}\n  overlaydisplay();\n}\n\nstatic void domenu(int, int, int);\n\nint Fl_Glut_Window::handle(int event) {\n  make_current();\n  int ex = Fl::event_x();\n  int ey = Fl::event_y();\n  int button;\n  switch (event) {\n\n  case FL_PUSH:\n    if (keyboard || special) Fl::focus(this);\n    button = Fl::event_button()-1;\n    if (button<0) button = 0;\n    if (button>2) button = 2;\n    if (menu[button]) {domenu(menu[button],ex,ey); return 1;}\n    mouse_down |= 1<<button;\n    if (mouse) {mouse(button,GLUT_DOWN,ex,ey); return 1;}\n    if (motion) return 1;\n    break;\n\n  case FL_MOUSEWHEEL:\n    button = Fl::event_dy();\n    while (button < 0) {if (mouse) mouse(3,GLUT_DOWN,ex,ey); ++button;}\n    while (button > 0) {if (mouse) mouse(4,GLUT_DOWN,ex,ey); --button;}\n    return 1;\n\n  case FL_RELEASE:\n    for (button = 0; button < 3; button++) if (mouse_down & (1<<button)) {\n      if (mouse) mouse(button,GLUT_UP,ex,ey);\n    }\n    mouse_down = 0;\n    return 1;\n\n  case FL_ENTER:\n    if (entry) {entry(GLUT_ENTERED); return 1;}\n    if (passivemotion) return 1;\n    break;\n\n  case FL_LEAVE:\n    if (entry) {entry(GLUT_LEFT); return 1;}\n    if (passivemotion) return 1;\n    break;\n\n  case FL_DRAG:\n    if (motion) {motion(ex, ey); return 1;}\n    break;\n\n  case FL_MOVE:\n    if (passivemotion) {passivemotion(ex, ey); return 1;}\n    break;\n\n  case FL_FOCUS:\n    if (keyboard || special) return 1;\n    break;\n\n  case FL_SHORTCUT:\n    if (!keyboard && !special) break;\n\n  case FL_KEYBOARD:\n    if (Fl::event_text()[0]) {\n      if (keyboard) {keyboard(Fl::event_text()[0],ex,ey); return 1;}\n      break;\n    } else {\n      if (special) {\n\tint k = Fl::event_key();\n\tif (k > FL_F && k <= FL_F_Last) k -= FL_F;\n\tspecial(k,ex,ey);\n\treturn 1;\n      }\n      break;\n    }\n\n  case FL_HIDE:\n    if (visibility) visibility(GLUT_NOT_VISIBLE);\n    break;\n\n  case FL_SHOW:\n    if (visibility) visibility(GLUT_VISIBLE);\n    break;\n  }\n\n  return Fl_Gl_Window::handle(event);\n}\n\nstatic int glut_mode = GLUT_RGB | GLUT_SINGLE | GLUT_DEPTH;\n\nvoid Fl_Glut_Window::_init() {\n  for (number=1; number<MAXWINDOWS; number++) if (!windows[number]) break;\n  windows[number] = this;\n  menu[0] = menu[1] = menu[2] = 0;\n  reshape = default_reshape;\n  display = default_display;\n  overlaydisplay = default_display;\n  keyboard = 0;\n  mouse = 0;\n  motion = 0;\n  passivemotion = 0;\n  entry = 0;\n  visibility = 0;\n  special = 0;\n  mouse_down = 0;\n  mode(glut_mode);\n}\n\n/** Creates a glut window, registers to the glut windows list.*/\nFl_Glut_Window::Fl_Glut_Window(int W, int H, const char *t) :\n  Fl_Gl_Window(W,H,t) {_init();}\n\n/** Creates a glut window, registers to the glut windows list.*/\nFl_Glut_Window::Fl_Glut_Window(int X,int Y,int W,int H, const char *t) :\n  Fl_Gl_Window(X,Y,W,H,t) {_init();}\n\nstatic int initargc;\nstatic char **initargv;\n\nvoid glutInit(int *argc, char **argv) {\n  initargc = *argc;\n  initargv = new char*[*argc+1];\n  int i,j;\n  for (i=0; i<=*argc; i++) initargv[i] = argv[i];\n  for (i=j=1; i<*argc; ) {\n    if (Fl::arg(*argc,argv,i));\n    else argv[j++] = argv[i++];\n  }\n  argv[j] = 0;\n  *argc = j;\n}\n\nvoid glutInitDisplayMode(unsigned int mode) {\n  glut_mode = mode;\n}\n\nvoid glutMainLoop() {Fl::run();}\n\n////////////////////////////////////////////////////////////////\n\nstatic int initx=0, inity=0, initw=300, inith=300, initpos=0;\n\nvoid glutInitWindowPosition(int x, int y) {\n  initx = x; inity = y; initpos = 1;\n}\n\nvoid glutInitWindowSize(int w, int h) {\n  initw = w; inith = h;\n}\n\nint glutCreateWindow(char *title) {\n  return glutCreateWindow((const char*)title);\n}\n\nint glutCreateWindow(const char *title) {\n  Fl_Glut_Window *W;\n  if (initpos) {\n    W = new Fl_Glut_Window(initx,inity,initw,inith,title);\n    initpos = 0;\n  } else {\n    W = new Fl_Glut_Window(initw,inith,title);\n  }\n  W->resizable(W);\n  if (initargc) {\n    W->show(initargc,initargv);\n    initargc = 0;\n  } else {\n    W->show();\n  }\n  W->valid(0);\n  W->context_valid(0);\n  W->make_current();\n  return W->number;\n}\n\nint glutCreateSubWindow(int win, int x, int y, int w, int h) {\n  Fl_Glut_Window *W = new Fl_Glut_Window(x,y,w,h,0);\n  windows[win]->add(W);\n  if (windows[win]->shown()) W->show();\n  W->make_current();\n  return W->number;\n}\n/** Destroys the glut window, first unregister it from the glut windows list */\nFl_Glut_Window::~Fl_Glut_Window() {\n  if (glut_window == this) glut_window = 0;\n  windows[number] = 0;\n}\n\nvoid glutDestroyWindow(int win) {\n  // should destroy children!!!\n  delete windows[win];\n}\n\nvoid glutPostWindowRedisplay(int win) {\n  windows[win]->redraw();\n}\n\nvoid glutSetWindow(int win) {\n  windows[win]->make_current();\n}\n\n////////////////////////////////////////////////////////////////\n#include <FL/Fl_Menu_Item.H>\n\nstruct menu {\n  void (*cb)(int);\n  Fl_Menu_Item *m;\n  int size;\n  int alloc;\n};\n\n#define MAXMENUS 32\nstatic menu menus[MAXMENUS+1];\n\nstatic void domenu(int n, int ex, int ey) {\n  glut_menu = n;\n  menu *m = &menus[n];\n  if (glut_menustate_function) glut_menustate_function(1);\n  if (glut_menustatus_function) glut_menustatus_function(1,ex,ey);\n  const Fl_Menu_Item* g = m->m->popup(Fl::event_x(), Fl::event_y(), 0);\n  if (g && g->callback_) ((void (*)(int))(g->callback_))(int(g->argument()));\n  if (glut_menustatus_function) glut_menustatus_function(0,ex,ey);\n  if (glut_menustate_function) glut_menustate_function(0);\n}\n\nint glutCreateMenu(void (*cb)(int)) {\n  int i;\n  for (i=1; i<MAXMENUS; i++) if (!menus[i].cb) break;\n  menu *m = &menus[i];\n  m->cb = cb;\n  return glut_menu = i;\n}\n\nvoid glutDestroyMenu(int n) {\n  menu *m = &menus[n];\n  delete[] m->m;\n  m->m = 0;\n  m->cb = 0;\n  m->size = m->alloc = 0;\n}\n\nstatic Fl_Menu_Item* additem(menu *m) {\n  if (m->size+1 >= m->alloc) {\n    m->alloc = m->size*2+10;\n    Fl_Menu_Item* nm = new Fl_Menu_Item[m->alloc];\n    for (int i=0; i<m->size; i++) nm[i] = m->m[i];\n    delete[] m->m;\n    m->m = nm;\n  }\n  int n = m->size++;\n  m->m[n+1].text = 0;\n  Fl_Menu_Item* i = &(m->m[n]);\n  i->shortcut_ = 0;\n  i->flags = 0;\n  i->labeltype_ = i->labelfont_ = i->labelsize_ = i->labelcolor_ = 0;\n  return i;\n}\n\nvoid glutAddMenuEntry(char *label, int value) {\n  menu *m = &menus[glut_menu];\n  Fl_Menu_Item* i = additem(m);\n  i->text = label;\n  i->callback_ = (Fl_Callback*)(m->cb);\n  i->argument(value);\n}\n\nvoid glutAddSubMenu(char *label, int submenu) {\n  menu *m = &menus[glut_menu];\n  Fl_Menu_Item* i = additem(m);\n  i->text = label;\n  i->callback_ = 0;\n  i->user_data_ = (void *)(menus[submenu].m);\n  i->flags = FL_PUP_SUBMENU;\n}\n\nvoid glutChangeToMenuEntry(int item, char *label, int value) {\n  menu *m = &menus[glut_menu];\n  Fl_Menu_Item* i = &m->m[item-1];\n  i->text = label;\n  i->callback_ = (Fl_Callback*)(m->cb);\n  i->argument(value);\n  i->flags = 0;\n}\n\nvoid glutChangeToSubMenu(int item, char *label, int submenu) {\n  menu *m = &menus[glut_menu];\n  Fl_Menu_Item* i = &m->m[item-1];\n  i->text = label;\n  i->callback_ = 0;\n  i->user_data_ = (void *)(menus[submenu].m);\n  i->flags = FL_PUP_SUBMENU;\n}\n\nvoid glutRemoveMenuItem(int item) {\n  menu *m = &menus[glut_menu];\n  if (item > m->size || item < 1) return;\n  for (int i = item-1; i <= m->size; i++) m->m[i] = m->m[i+1];\n  m->size--;\n}\n\n////////////////////////////////////////////////////////////////\n\nint glutGet(GLenum type) {\n  switch (type) {\n  case GLUT_RETURN_ZERO: return 0;\n  case GLUT_WINDOW_X: return glut_window->x();\n  case GLUT_WINDOW_Y: return glut_window->y();\n  case GLUT_WINDOW_WIDTH: return glut_window->w();\n  case GLUT_WINDOW_HEIGHT: return glut_window->h();\n  case GLUT_WINDOW_PARENT:\n    if (glut_window->parent())\n      return ((Fl_Glut_Window *)(glut_window->parent()))->number;\n    else\n      return 0;\n//case GLUT_WINDOW_NUM_CHILDREN:\n//case GLUT_WINDOW_CURSOR: return \n  case GLUT_SCREEN_WIDTH: return Fl::w();\n  case GLUT_SCREEN_HEIGHT: return Fl::h();\n//case GLUT_SCREEN_WIDTH_MM:\n//case GLUT_SCREEN_HEIGHT_MM:\n  case GLUT_MENU_NUM_ITEMS: return menus[glut_menu].size;\n  case GLUT_DISPLAY_MODE_POSSIBLE: return Fl_Gl_Window::can_do(glut_mode);\n  case GLUT_INIT_WINDOW_X: return initx;\n  case GLUT_INIT_WINDOW_Y: return inity;\n  case GLUT_INIT_WINDOW_WIDTH: return initw;\n  case GLUT_INIT_WINDOW_HEIGHT: return inith;\n  case GLUT_INIT_DISPLAY_MODE: return glut_mode;\n//case GLUT_ELAPSED_TIME:\n  case GLUT_WINDOW_BUFFER_SIZE:\n    if (glutGet(GLUT_WINDOW_RGBA))\n      return glutGet(GLUT_WINDOW_RED_SIZE)+\n\tglutGet(GLUT_WINDOW_GREEN_SIZE)+\n\tglutGet(GLUT_WINDOW_BLUE_SIZE)+\n\tglutGet(GLUT_WINDOW_ALPHA_SIZE);\n    else\n      return glutGet(GLUT_WINDOW_COLORMAP_SIZE);\n  case GLUT_VERSION: return 20400;\n  default: {GLint p; glGetIntegerv(type, &p); return p;}\n  }\n}\n\nint glutLayerGet(GLenum type) {\n  switch (type) {\n  case GLUT_OVERLAY_POSSIBLE: return glut_window->can_do_overlay();\n//case GLUT_LAYER_IN_USE:\n//case GLUT_HAS_OVERLAY:\n  case GLUT_TRANSPARENT_INDEX: return 0; // true for SGI\n  case GLUT_NORMAL_DAMAGED: return glut_window->damage();\n  case GLUT_OVERLAY_DAMAGED: return 1; // kind of works...\n  default: return 0;\n  }\n}\n\nint glutDeviceGet(GLenum type) {\n  switch (type) {\n    case GLUT_HAS_KEYBOARD : return 1;\n    case GLUT_HAS_MOUSE : return 1;\n    case GLUT_NUM_MOUSE_BUTTONS : return 3;\n    default : return 0;\n  }\n}\n\n// Get extension function address...\nGLUTproc glutGetProcAddress(const char *procName) {\n#  ifdef WIN32\n  return (GLUTproc)wglGetProcAddress((LPCSTR)procName);\n\n#  elif defined(HAVE_DLSYM) && defined(HAVE_DLFCN_H)\n  char symbol[1024];\n\n  snprintf(symbol, sizeof(symbol), \"_%s\", procName);\n\n#    ifdef RTLD_DEFAULT\n  return (GLUTproc)dlsym(RTLD_DEFAULT, symbol);\n\n#    else // No RTLD_DEFAULT support, so open the current a.out symbols...\n  static void *rtld_default = 0;\n\n  if (!rtld_default) rtld_default = dlopen(0, RTLD_LAZY);\n\n  if (rtld_default) return (GLUTproc)dlsym(rtld_default, symbol);\n  else return 0;\n\n#    endif // RTLD_DEFAULT\n\n#  elif defined(HAVE_GLXGETPROCADDRESSARB)\n  return (GLUTproc)glXGetProcAddressARB((const GLubyte *)procName);\n\n#  else\n  return (GLUTproc)0;\n#  endif // WIN32\n}\n\n// Parse the GL_EXTENSIONS string to see if the named extension is\n// supported.\n//\n// This code was copied from FreeGLUT 2.4.0 which carries the\n// following notice:\n//\n//     Copyright (c) 1999-2000 Pawel W. Olszta. All Rights Reserved.\nint glutExtensionSupported( const char* extension )\n{\n  if (!extension || strchr(extension, ' ')) return 0;\n\n  const char *extensions, *start;\n  const int len = strlen( extension );\n  \n  start = extensions = (const char *) glGetString(GL_EXTENSIONS);\n\n  if (!extensions) return 0;\n\n  for (;;) {\n    const char *p = strstr(extensions, extension);\n    if (!p) return 0;  /* not found */\n    /* check that the match isn't a super string */\n    if ((p == start || p[-1] == ' ') &&\n        (p[len] == ' ' || p[len] == 0)) return 1;\n    /* skip the false match and continue */\n    extensions = p + len;\n  }\n}\n\n// Add a mechanism to handle adding/removing the glut idle function\n// without depending on the (deprecated) set_idle method.\nvoid glutIdleFunc(void (*f)())\n{\n  // no change\n  if(glut_idle_func == f) return;\n  // remove current idle\n  if(glut_idle_func) Fl::remove_idle((void (*)(void *))glut_idle_func);\n  // install new idle func - if one was passed\n  if(f) Fl::add_idle((void (*)(void *))f);\n  // record new idle func - even if it is NULL\n  glut_idle_func = f;\n} // glutIdleFunc\n\n#endif // HAVE_GL\n\n//\n// End of \"$Id: glut_compatability.cxx 9697 2012-10-08 10:32:05Z manolo $\".\n//\n",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/src/Fl_Preferences.cxx": "//\n// \"$Id: Fl_Preferences.cxx 10378 2014-10-14 12:10:18Z ianmacarthur $\"\n//\n// Preferences methods for the Fast Light Tool Kit (FLTK).\n//\n// Copyright 2002-2010 by Matthias Melcher.\n//\n// This library is free software. Distribution and use rights are outlined in\n// the file \"COPYING\" which should have been included with this file.  If this\n// file is missing or damaged, see the license at:\n//\n//     http://www.fltk.org/COPYING.php\n//\n// Please report all bugs and problems on the following page:\n//\n//     http://www.fltk.org/str.php\n//\n\n#include <FL/Fl.H>\n#include <FL/Fl_Preferences.H>\n#include <FL/Fl_Plugin.H>\n#include <FL/filename.H>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <FL/fl_utf8.h>\n#include \"flstring.h\"\n#include <sys/stat.h>\n#include <time.h>\n\n#if defined(WIN32) && !defined(__CYGWIN__)\n#  include <windows.h>\n#  include <direct.h>\n#  include <io.h>\n// Visual C++ 2005 incorrectly displays a warning about the use of POSIX APIs\n// on Windows, which is supposed to be POSIX compliant...\n#  define access _access\n#  define mkdir _mkdir\n#elif defined (__APPLE__)\n#  include <ApplicationServices/ApplicationServices.h>\n#  include <unistd.h>\n#  include <config.h>\n#  include <dlfcn.h>\n#else\n#  include <unistd.h>\n#  include <config.h>\n#  if HAVE_DLFCN_H\n#    include <dlfcn.h>\n#  endif\n#endif\n\n#ifdef WIN32\n#  include <windows.h>\n#  include <rpc.h>\n// function pointer for the UuidCreate Function\n// RPC_STATUS RPC_ENTRY UuidCreate(UUID __RPC_FAR *Uuid);\ntypedef RPC_STATUS (WINAPI* uuid_func)(UUID __RPC_FAR *Uuid);\n#else\n#  include <sys/time.h>\n#endif // WIN32\n\n#ifdef __CYGWIN__\n#  include <wchar.h>\n#endif\n\nchar Fl_Preferences::nameBuffer[128];\nchar Fl_Preferences::uuidBuffer[40];\nFl_Preferences *Fl_Preferences::runtimePrefs = 0;\n\n/**\n * Returns a UUID as generated by the system.\n *\n * A UUID is a \"universally unique identifier\" which is commonly used in\n * configuration files to create identities. A UUID in ASCII looks like this:\n * <tt>937C4900-51AA-4C11-8DD3-7AB59944F03E</tt>. It has always 36 bytes plus\n * a trailing zero.\n *\n * \\return a pointer to a static buffer containing the new UUID in ASCII format.\n *         The buffer is overwritten during every call to this function!\n */\nconst char *Fl_Preferences::newUUID() {\n#ifdef __APPLE__\n  CFUUIDRef theUUID = CFUUIDCreate(NULL);\n  CFUUIDBytes b = CFUUIDGetUUIDBytes(theUUID);\n  sprintf(uuidBuffer, \"%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X\",\n          b.byte0, b.byte1, b.byte2, b.byte3, b.byte4, b.byte5, b.byte6, b.byte7,\n          b.byte8, b.byte9, b.byte10, b.byte11, b.byte12, b.byte13, b.byte14, b.byte15);\n  CFRelease(theUUID);\n#elif defined (WIN32)\n  // First try and use the win API function UuidCreate(), but if that is not\n  // available, fall back to making something up from scratch.\n  // We do not want to link against the Rpcrt4.dll, as we will rarely use it,\n  // so we load the DLL dynamically, if it is available, and work from there.\n  static HMODULE hMod = NULL;\n  UUID ud;\n  UUID *pu = &ud;\n  int got_uuid = 0;\n\n  if (!hMod) {\t\t// first time in?\n    hMod = LoadLibrary(\"Rpcrt4.dll\");\n  }\n\n  if (hMod) {\t\t// do we have a usable handle to Rpcrt4.dll?\n    uuid_func uuid_crt = (uuid_func)GetProcAddress(hMod, \"UuidCreate\");\n    if (uuid_crt != NULL) {\n      RPC_STATUS rpc_res = uuid_crt(pu);\n      if ( // is the return status OK for our needs?\n          (rpc_res == RPC_S_OK) ||\t\t// all is well\n          (rpc_res == RPC_S_UUID_LOCAL_ONLY) || // only unique to this machine\n          (rpc_res == RPC_S_UUID_NO_ADDRESS)\t// probably only locally unique\n        ) {\n        got_uuid = -1;\n        sprintf(uuidBuffer, \"%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\",\n            pu->Data1, pu->Data2, pu->Data3, pu->Data4[0], pu->Data4[1],\n            pu->Data4[2], pu->Data4[3], pu->Data4[4],\n            pu->Data4[5], pu->Data4[6], pu->Data4[7]);\n      }\n    }\n  }\n  if (got_uuid == 0) {\t\t// did not make a UUID - use fallback logic\n    unsigned char b[16];\n    time_t t = time(0);\t\t// first 4 byte\n    b[0] = (unsigned char)t;\n    b[1] = (unsigned char)(t>>8);\n    b[2] = (unsigned char)(t>>16);\n    b[3] = (unsigned char)(t>>24);\n    int r = rand();\t\t// four more bytes\n    b[4] = (unsigned char)r;\n    b[5] = (unsigned char)(r>>8);\n    b[6] = (unsigned char)(r>>16);\n    b[7] = (unsigned char)(r>>24);\n    // Now we try to find 4 more \"random\" bytes. We extract the\n    // lower 4 bytes from the address of t - it is created on the\n    // stack so *might* be in a different place each time...\n    // This is now done via a union to make it compile OK on 64-bit systems.\n    union { void *pv; unsigned char a[sizeof(void*)]; } v;\n    v.pv = (void *)(&t);\n    // NOTE: This assume that all WinXX systems are little-endian\n    b[8] = v.a[0];\n    b[9] = v.a[1];\n    b[10] = v.a[2];\n    b[11] = v.a[3];\n    TCHAR name[MAX_COMPUTERNAME_LENGTH + 1]; // only used to make last four bytes\n    DWORD nSize = MAX_COMPUTERNAME_LENGTH + 1;\n    // GetComputerName() does not depend on any extra libs, and returns something\n    // analogous to gethostname()\n    GetComputerName(name, &nSize);\n    //  use the first 4 TCHAR's of the name to create the last 4 bytes of our UUID\n    for (int ii = 0; ii < 4; ii++) {\n      b[12 + ii] = (unsigned char)name[ii];\n    }\n    sprintf(uuidBuffer, \"%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X\",\n            b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7],\n            b[8], b[9], b[10], b[11], b[12], b[13], b[14], b[15]);\n  }\n#else\n  // warning Unix implementation of Fl_Preferences::newUUID() incomplete!\n  // #include <uuid/uuid.h>\n  // void uuid_generate(uuid_t out);\n  unsigned char b[16];\n  time_t t = time(0);\t\t\t// first 4 byte\n  b[0] = (unsigned char)t;\n  b[1] = (unsigned char)(t>>8);\n  b[2] = (unsigned char)(t>>16);\n  b[3] = (unsigned char)(t>>24);\n  int r = rand(); \t\t\t// four more bytes\n  b[4] = (unsigned char)r;\n  b[5] = (unsigned char)(r>>8);\n  b[6] = (unsigned char)(r>>16);\n  b[7] = (unsigned char)(r>>24);\n  unsigned long a = (unsigned long)&t;\t// four more bytes\n  b[8] = (unsigned char)a;\n  b[9] = (unsigned char)(a>>8);\n  b[10] = (unsigned char)(a>>16);\n  b[11] = (unsigned char)(a>>24);\n  // Now we try to find 4 more \"random\" bytes. We extract the\n  // lower 4 bytes from the address of t - it is created on the\n  // stack so *might* be in a different place each time...\n  // This is now done via a union to make it compile OK on 64-bit systems.\n  union { void *pv; unsigned char a[sizeof(void*)]; } v;\n  v.pv = (void *)(&t);\n  // NOTE: May need to handle big- or little-endian systems here\n# if WORDS_BIGENDIAN\n  b[8] = v.a[sizeof(void*) - 1];\n  b[9] = v.a[sizeof(void*) - 2];\n  b[10] = v.a[sizeof(void*) - 3];\n  b[11] = v.a[sizeof(void*) - 4];\n# else /* data ordered for a little-endian system */\n  b[8] = v.a[0];\n  b[9] = v.a[1];\n  b[10] = v.a[2];\n  b[11] = v.a[3];\n# endif\n  char name[80];\t\t\t// last four bytes\n  gethostname(name, 79);\n  memcpy(b+12, name, 4);\n  sprintf(uuidBuffer, \"%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X\",\n          b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7],\n          b[8], b[9], b[10], b[11], b[12], b[13], b[14], b[15]);\n#endif\n\n  return uuidBuffer;\n}\n\n/**\n   The constructor creates a group that manages name/value pairs and\n   child groups. Groups are ready for reading and writing at any time.\n   The root argument is either Fl_Preferences::USER\n   or Fl_Preferences::SYSTEM.\n\n   This constructor creates the <i>base</i> instance for all\n   following entries and reads existing databases into memory. The\n   vendor argument is a unique text string identifying the\n   development team or vendor of an application.  A domain name or\n   an EMail address are great unique names, e.g.\n   \"researchATmatthiasm.com\" or \"fltk.org\". The\n   application argument can be the working title or final\n   name of your application. Both vendor and\n   application must be valid relative UNIX pathnames and\n   may contain '/'s to create deeper file structures.\n\n   A set of Preferences marked \"run-time\" exists exactly one per application and\n   only as long as the application runs. It can be used as a database for\n   volatile information. FLTK uses it to register plugins at run-time.\n\n   \\param[in] root can be \\c USER or \\c SYSTEM for user specific or system wide\n              preferences\n   \\param[in] vendor unique text describing the company or author of this file\n   \\param[in] application unique text describing the application\n*/\nFl_Preferences::Fl_Preferences( Root root, const char *vendor, const char *application ) {\n  node = new Node( \".\" );\n  rootNode = new RootNode( this, root, vendor, application );\n  node->setRoot(rootNode);\n}\n\n/**\n   \\brief Use this constructor to create or read a preferences file at an\n   arbitrary position in the file system.\n\n   The file name is generated in the form\n   <tt><i>path</i>/<i>application</i>.prefs</tt>. If \\p application\n   is \\c NULL, \\p path must contain the full file name.\n\n   \\param[in] path path to the directory that contains the preferences file\n   \\param[in] vendor unique text describing the company or author of this file\n   \\param[in] application unique text describing the application\n */\nFl_Preferences::Fl_Preferences( const char *path, const char *vendor, const char *application ) {\n  node = new Node( \".\" );\n  rootNode = new RootNode( this, path, vendor, application );\n  node->setRoot(rootNode);\n}\n\n/**\n   \\brief Generate or read a new group of entries within another group.\n\n   Use the \\p group argument to name the group that you would like to access.\n   \\p Group can also contain a path to a group further down the hierarchy by\n   separating group names with a forward slash '/'.\n\n   \\param[in] parent reference object for the new group\n   \\param[in] group name of the group to access (may contain '/'s)\n */\nFl_Preferences::Fl_Preferences( Fl_Preferences &parent, const char *group ) {\n  rootNode = parent.rootNode;\n  node = parent.node->addChild( group );\n}\n\n/**\n   \\brief Create or access a group of preferences using a name.\n   \\param[in] parent the parameter parent is a pointer to the parent group.\n              \\p Parent may be \\p NULL. It then refers to an application internal\n              database which exists only once, and remains in RAM only until the\n              application quits. This database is used to manage plugins and other\n              data indexes by strings.\n   \\param[in] group a group name that is used as a key into the database\n   \\see Fl_Preferences( Fl_Preferences&, const char *group )\n */\nFl_Preferences::Fl_Preferences( Fl_Preferences *parent, const char *group ) {\n  if (parent==0) {\n    if (!runtimePrefs) {\n      runtimePrefs = new Fl_Preferences();\n      runtimePrefs->node = new Node( \".\" );\n      runtimePrefs->rootNode = new RootNode( runtimePrefs );\n      runtimePrefs->node->setRoot(rootNode);\n    }\n    parent = runtimePrefs;\n  }\n  rootNode = parent->rootNode;\n  node = parent->node->addChild( group );\n}\n\n/**\n \\brief Open a child group using a given index.\n\n Use the \\p groupIndex argument to find the group that you would like to access.\n If the given index is invalid (negative or too high), a new group is created\n with a UUID as a name.\n\n The index needs to be fixed. It is currently backward. Index 0 points\n to the last member in the 'list' of preferences.\n\n \\param[in] parent reference object for the new group\n \\param[in] groupIndex zero based index into child groups\n */\nFl_Preferences::Fl_Preferences( Fl_Preferences &parent, int groupIndex ) {\n  rootNode = parent.rootNode;\n  if (groupIndex<0 || groupIndex>=parent.groups()) {\n    node = parent.node->addChild( newUUID() );\n  } else {\n    node = parent.node->childNode( groupIndex );\n  }\n}\n\n/**\n \\see Fl_Preferences( Fl_Preferences&, int groupIndex )\n */\nFl_Preferences::Fl_Preferences( Fl_Preferences *parent, int groupIndex ) {\n  rootNode = parent->rootNode;\n  if (groupIndex<0 || groupIndex>=parent->groups()) {\n    node = parent->node->addChild( newUUID() );\n  } else {\n    node = parent->node->childNode( groupIndex );\n  }\n}\n\n/**\n Create a new dataset access point using a dataset ID.\n\n ID's are a great way to remember shortcuts to database entries that are deeply\n nested in a preferences database, as long as the database root is not deleted.\n An ID can be retrieved from any Fl_Preferences dataset, and can then be used\n to create multiple new references to the same dataset.\n\n ID's can be very helpful when put into the <tt>user_data()</tt> field of\n widget callbacks.\n */\nFl_Preferences::Fl_Preferences( Fl_Preferences::ID id ) {\n  node = (Node*)id;\n  rootNode = node->findRoot();\n}\n\n/**\n Create another reference to a Preferences group.\n */\nFl_Preferences::Fl_Preferences(const Fl_Preferences &rhs)\n: node(rhs.node),\n  rootNode(rhs.rootNode)\n{ }\n\n/**\n Assign another reference to a Preference group.\n */\nFl_Preferences &Fl_Preferences::operator=(const Fl_Preferences &rhs) {\n  if (&rhs != this) {\n    node = rhs.node;\n    rootNode = rhs.rootNode;\n  }\n  return *this;\n}\n\n/**\n   The destructor removes allocated resources. When used on the\n   \\em base preferences group, the destructor flushes all\n   changes to the preferences file and deletes all internal\n   databases.\n\n   The destructor does not remove any data from the database. It merely\n   deletes your reference to the database.\n */\nFl_Preferences::~Fl_Preferences() {\n  if (node && !node->parent()) delete rootNode;\n  // DO NOT delete nodes! The root node will do that after writing the preferences\n  // zero all pointer to avoid memory errors, even though\n  // Valgrind does not complain (Cygwin does though)\n  node = 0L;\n  rootNode = 0L;\n}\n\n/**\n   Returns the number of groups that are contained within a group.\n\n   \\return 0 for no groups at all\n */\nint Fl_Preferences::groups() {\n  return node->nChildren();\n}\n\n/**\n   Returns the name of the Nth (\\p num_group) group.\n   There is no guaranteed order of group names. The index must\n   be within the range given by groups().\n\n   \\param[in] num_group number indexing the requested group\n   \\return 'C' string pointer to the group name\n */\nconst char *Fl_Preferences::group( int num_group ) {\n  return node->child( num_group );\n}\n\n/**\n   Returns non-zero if a group with this name exists.\n   Group names are relative to the Preferences node and can contain a path.\n   \".\" describes the current node, \"./\" describes the topmost node.\n   By preceding a groupname with a \"./\", its path becomes relative to the topmost node.\n\n   \\param[in] key name of group that is searched for\n   \\return 0 if no group by that name was found\n */\nchar Fl_Preferences::groupExists( const char *key ) {\n  return node->search( key ) ? 1 : 0 ;\n}\n\n/**\n   Deletes a group.\n\n   Removes a group and all keys and groups within that group\n   from the database.\n\n   \\param[in] group name of the group to delete\n   \\return 0 if call failed\n */\nchar Fl_Preferences::deleteGroup( const char *group ) {\n  Node *nd = node->search( group );\n  if ( nd ) return nd->remove();\n  return 0;\n}\n\n/**\n Delete all groups.\n */\nchar Fl_Preferences::deleteAllGroups() {\n  node->deleteAllChildren();\n  return 1;\n}\n\n/**\n   Returns the number of entries (name/value pairs) in a group.\n\n   \\return number of entries\n */\nint Fl_Preferences::entries() {\n  return node->nEntry();\n}\n\n/**\n   Returns the name of an entry. There is no guaranteed order of\n   entry names. The index must be within the range given by\n   entries().\n\n   \\param[in] index number indexing the requested entry\n   \\return pointer to value cstring\n */\nconst char *Fl_Preferences::entry( int index ) {\n  return node->entry(index).name;\n}\n\n/**\n   Returns non-zero if an entry with this name exists.\n\n   \\param[in] key name of entry that is searched for\n   \\return 0 if entry was not found\n */\nchar Fl_Preferences::entryExists( const char *key ) {\n  return node->getEntry( key )>=0 ? 1 : 0 ;\n}\n\n/**\n   Deletes a single name/value pair.\n\n   This function removes the entry \\p key from the database.\n\n   \\param[in] key name of entry to delete\n   \\return 0 if deleting the entry failed\n */\nchar Fl_Preferences::deleteEntry( const char *key ) {\n  return node->deleteEntry( key );\n}\n\n/**\n Delete all entries.\n */\nchar Fl_Preferences::deleteAllEntries() {\n  node->deleteAllEntries();\n  return 1;\n}\n\n/**\n Delete all groups and all entries.\n */\nchar Fl_Preferences::clear() {\n  char ret1 = deleteAllGroups();\n  char ret2 = deleteAllEntries();\n  return ret1 & ret2;\n}\n\n/**\n Reads an entry from the group. A default value must be\n supplied. The return value indicates if the value was available\n (non-zero) or the default was used (0).\n\n \\param[in] key name of entry\n \\param[out] value returned from preferences or default value if none was set\n \\param[in] defaultValue default value to be used if no preference was set\n \\return 0 if the default value was used\n */\nchar Fl_Preferences::get( const char *key, int &value, int defaultValue ) {\n  const char *v = node->get( key );\n  value = v ? atoi( v ) : defaultValue;\n  return ( v != 0 );\n}\n\n/**\n Sets an entry (name/value pair). The return value indicates if there\n was a problem storing the data in memory. However it does not\n reflect if the value was actually stored in the preferences\n file.\n\n \\param[in] key name of entry\n \\param[in] value set this entry to \\p value\n \\return 0 if setting the value failed\n */\nchar Fl_Preferences::set( const char *key, int value ) {\n  sprintf( nameBuffer, \"%d\", value );\n  node->set( key, nameBuffer );\n  return 1;\n}\n\n/**\n Reads an entry from the group. A default value must be\n supplied. The return value indicates if the value was available\n (non-zero) or the default was used (0).\n\n \\param[in] key name of entry\n \\param[out] value returned from preferences or default value if none was set\n \\param[in] defaultValue default value to be used if no preference was set\n \\return 0 if the default value was used\n */\nchar Fl_Preferences::get( const char *key, float &value, float defaultValue ) {\n  const char *v = node->get( key );\n  value = v ? (float)atof( v ) : defaultValue;\n  return ( v != 0 );\n}\n\n/**\n Sets an entry (name/value pair). The return value indicates if there\n was a problem storing the data in memory. However it does not\n reflect if the value was actually stored in the preferences\n file.\n\n \\param[in] key name of entry\n \\param[in] value set this entry to \\p value\n \\return 0 if setting the value failed\n */\nchar Fl_Preferences::set( const char *key, float value ) {\n  sprintf( nameBuffer, \"%g\", value );\n  node->set( key, nameBuffer );\n  return 1;\n}\n\n/**\n Sets an entry (name/value pair). The return value indicates if there\n was a problem storing the data in memory. However it does not\n reflect if the value was actually stored in the preferences\n file.\n\n \\param[in] key name of entry\n \\param[in] value set this entry to \\p value\n \\param[in] precision number of decimal digits to represent value\n \\return 0 if setting the value failed\n */\nchar Fl_Preferences::set( const char *key, float value, int precision ) {\n  sprintf( nameBuffer, \"%.*g\", precision, value );\n  node->set( key, nameBuffer );\n  return 1;\n}\n\n/**\n Reads an entry from the group. A default value must be\n supplied. The return value indicates if the value was available\n (non-zero) or the default was used (0).\n\n \\param[in] key name of entry\n \\param[out] value returned from preferences or default value if none was set\n \\param[in] defaultValue default value to be used if no preference was set\n \\return 0 if the default value was used\n */\nchar Fl_Preferences::get( const char *key, double &value, double defaultValue ) {\n  const char *v = node->get( key );\n  value = v ? atof( v ) : defaultValue;\n  return ( v != 0 );\n}\n\n/**\n Sets an entry (name/value pair). The return value indicates if there\n was a problem storing the data in memory. However it does not\n reflect if the value was actually stored in the preferences\n file.\n\n \\param[in] key name of entry\n \\param[in] value set this entry to \\p value\n \\return 0 if setting the value failed\n */\nchar Fl_Preferences::set( const char *key, double value ) {\n  sprintf( nameBuffer, \"%g\", value );\n  node->set( key, nameBuffer );\n  return 1;\n}\n\n/**\n Sets an entry (name/value pair). The return value indicates if there\n was a problem storing the data in memory. However it does not\n reflect if the value was actually stored in the preferences\n file.\n\n \\param[in] key name of entry\n \\param[in] value set this entry to \\p value\n \\param[in] precision number of decimal digits to represent value\n \\return 0 if setting the value failed\n */\nchar Fl_Preferences::set( const char *key, double value, int precision ) {\n  sprintf( nameBuffer, \"%.*g\", precision, value );\n  node->set( key, nameBuffer );\n  return 1;\n}\n\n// remove control sequences from a string\nstatic char *decodeText( const char *src ) {\n  int len = 0;\n  const char *s = src;\n  for ( ; *s; s++, len++ ) {\n    if ( *s == '\\\\' ) {\n      if ( isdigit( s[1] ) ) {\n        s+=3; \n      } else { \n        s+=1;\n      }\n    }\n  }\n  char *dst = (char*)malloc( len+1 ), *d = dst;\n  for ( s = src; *s; s++ ) {\n    char c = *s;\n    if ( c == '\\\\' ) {\n      if ( s[1] == '\\\\' ) { *d++ = c; s++; }\n      else if ( s[1] == 'n' ) { *d++ = '\\n'; s++; }\n      else if ( s[1] == 'r' ) { *d++ = '\\r'; s++; }\n      else if ( isdigit( s[1] ) ) { *d++ = ((s[1]-'0')<<6) + ((s[2]-'0')<<3) + (s[3]-'0'); s+=3; }\n      else s++; // error\n    }\n    else\n      *d++ = c;\n  }\n  *d = 0;\n  return dst;\n}\n\n/**\n Reads an entry from the group. A default value must be\n supplied. The return value indicates if the value was available\n (non-zero) or the default was used (0).\n 'maxSize' is the maximum length of text that will be read.\n The text buffer must allow for one additional byte for a trailing zero.\n\n \\param[in] key name of entry\n \\param[out] text returned from preferences or default value if none was set\n \\param[in] defaultValue default value to be used if no preference was set\n \\param[in] maxSize maximum length of value plus one byte for a trailing zero\n \\return 0 if the default value was used\n */\nchar Fl_Preferences::get( const char *key, char *text, const char *defaultValue, int maxSize ) {\n  const char *v = node->get( key );\n  if ( v && strchr( v, '\\\\' ) ) {\n    char *w = decodeText( v );\n    strlcpy(text, w, maxSize);\n    free( w );\n    return 1;\n  }\n  if ( !v ) v = defaultValue;\n  if ( v ) strlcpy(text, v, maxSize);\n  else text = 0;\n  return ( v != defaultValue );\n}\n\n/**\n Reads an entry from the group. A default value must be\n supplied. The return value indicates if the value was available\n (non-zero) or the default was used (0). get() allocates memory of\n sufficient size to hold the value. The buffer must be free'd by\n the developer using 'free(value)'.\n\n \\param[in] key name of entry\n \\param[out] text returned from preferences or default value if none was set\n \\param[in] defaultValue default value to be used if no preference was set\n \\return 0 if the default value was used\n */\nchar Fl_Preferences::get( const char *key, char *&text, const char *defaultValue ) {\n  const char *v = node->get( key );\n  if ( v && strchr( v, '\\\\' ) ) {\n    text = decodeText( v );\n    return 1;\n  }\n  if ( !v ) v = defaultValue;\n  if ( v )\n    text = strdup( v );\n  else\n    text = 0;\n  return ( v != defaultValue );\n}\n\n/**\n Sets an entry (name/value pair). The return value indicates if there\n was a problem storing the data in memory. However it does not\n reflect if the value was actually stored in the preferences\n file.\n\n \\param[in] key name of entry\n \\param[in] text set this entry to \\p value\n \\return 0 if setting the value failed\n */\nchar Fl_Preferences::set( const char *key, const char *text ) {\n  const char *s = text ? text : \"\";\n  int n=0, ns=0;\n  for ( ; *s; s++ ) { n++; if ( *s<32 || *s=='\\\\' || *s==0x7f ) ns+=4; }\n  if ( ns ) {\n    char *buffer = (char*)malloc( n+ns+1 ), *d = buffer;\n    for ( s=text; *s; ) {\n      char c = *s;\n      if ( c=='\\\\' ) { *d++ = '\\\\'; *d++ = '\\\\'; s++; }\n      else if ( c=='\\n' ) { *d++ = '\\\\'; *d++ = 'n'; s++; }\n      else if ( c=='\\r' ) { *d++ = '\\\\'; *d++ = 'r'; s++; }\n      else if ( c<32 || c==0x7f )\n\t{ *d++ = '\\\\'; *d++ = '0'+((c>>6)&3); *d++ = '0'+((c>>3)&7); *d++ = '0'+(c&7);  s++; }\n      else *d++ = *s++;\n    }\n    *d = 0;\n    node->set( key, buffer );\n    free( buffer );\n  }\n  else\n    node->set( key, text );\n  return 1;\n}\n\n// convert a hex string to binary data\nstatic void *decodeHex( const char *src, int &size ) {\n  size = (int) strlen( src )/2;\n  unsigned char *data = (unsigned char*)malloc( size ), *d = data;\n  const char *s = src;\n  for ( int i=size; i>0; i-- ) {\n    int v;\n    char x = tolower(*s++);\n    if ( x >= 'a' ) v = x-'a'+10; else v = x-'0';\n    v = v<<4;\n    x = tolower(*s++);\n    if ( x >= 'a' ) v += x-'a'+10; else v += x-'0';\n    *d++ = (uchar)v;\n  }\n  return (void*)data;\n}\n\n/**\n Reads an entry from the group. A default value must be\n supplied. The return value indicates if the value was available\n (non-zero) or the default was used (0).\n 'maxSize' is the maximum length of text that will be read.\n\n \\param[in] key name of entry\n \\param[out] data value returned from preferences or default value if none was set\n \\param[in] defaultValue default value to be used if no preference was set\n \\param[in] defaultSize size of default value array\n \\param[in] maxSize maximum length of value\n \\return 0 if the default value was used\n\n \\todo maxSize should receive the number of bytes that were read.\n */\nchar Fl_Preferences::get( const char *key, void *data, const void *defaultValue, int defaultSize, int maxSize ) {\n  const char *v = node->get( key );\n  if ( v ) {\n    int dsize;\n    void *w = decodeHex( v, dsize );\n    memmove( data, w, dsize>maxSize?maxSize:dsize );\n    free( w );\n    return 1;\n  }\n  if ( defaultValue )\n    memmove( data, defaultValue, defaultSize>maxSize?maxSize:defaultSize );\n  return 0;\n}\n\n/**\n Reads an entry from the group. A default value must be\n supplied. The return value indicates if the value was available\n (non-zero) or the default was used (0). get() allocates memory of\n sufficient size to hold the value. The buffer must be free'd by\n the developer using 'free(value)'.\n\n \\param[in] key name of entry\n \\param[out] data returned from preferences or default value if none was set\n \\param[in] defaultValue default value to be used if no preference was set\n \\param[in] defaultSize size of default value array\n \\return 0 if the default value was used\n */\nchar Fl_Preferences::get( const char *key, void *&data, const void *defaultValue, int defaultSize ) {\n  const char *v = node->get( key );\n  if ( v ) {\n    int dsize;\n    data = decodeHex( v, dsize );\n    return 1;\n  }\n  if ( defaultValue ) {\n    data = (void*)malloc( defaultSize );\n    memmove( data, defaultValue, defaultSize );\n  }\n  else\n    data = 0;\n  return 0;\n}\n\n/**\n Sets an entry (name/value pair). The return value indicates if there\n was a problem storing the data in memory. However it does not\n reflect if the value was actually stored in the preferences\n file.\n\n \\param[in] key name of entry\n \\param[in] data set this entry to \\p value\n \\param[in] dsize size of data array\n \\return 0 if setting the value failed\n */\nchar Fl_Preferences::set( const char *key, const void *data, int dsize ) {\n  char *buffer = (char*)malloc( dsize*2+1 ), *d = buffer;;\n  unsigned char *s = (unsigned char*)data;\n  for ( ; dsize>0; dsize-- ) {\n    static char lu[] = \"0123456789abcdef\";\n    unsigned char v = *s++;\n    *d++ = lu[v>>4];\n    *d++ = lu[v&0xf];\n  }\n  *d = 0;\n  node->set( key, buffer );\n  free( buffer );\n  return 1;\n}\n\n/**\n Returns the size of the value part of an entry.\n\n \\param[in] key name of entry\n \\return size of value\n */\nint Fl_Preferences::size( const char *key ) {\n  const char *v = node->get( key );\n  return (int) (v ? strlen( v ) : 0);\n}\n\n/**\n \\brief Creates a path that is related to the preferences file and\n that is usable for additional application data.\n\n This function creates a directory that is named after the preferences\n database without the \\c .prefs extension and located in the same directory.\n It then fills the given buffer with the complete path name.\n\n Exmaple:\n \\code\n Fl_Preferences prefs( USER, \"matthiasm.com\", \"test\" );\n char path[FL_PATH_MAX];\n prefs.getUserdataPath( path );\n \\endcode\n creates the preferences database in (MS Windows):\n \\code\n c:/Documents and Settings/matt/Application Data/matthiasm.com/test.prefs\n \\endcode\n and returns the userdata path:\n \\code\n c:/Documents and Settings/matt/Application Data/matthiasm.com/test/\n \\endcode\n\n \\param[out] path buffer for user data path\n \\param[in] pathlen size of path buffer (should be at least \\c FL_PATH_MAX)\n \\return 0 if path was not created or pathname can't fit into buffer\n */\nchar Fl_Preferences::getUserdataPath( char *path, int pathlen ) {\n  if ( rootNode )\n    return rootNode->getPath( path, pathlen );\n  return 0;\n}\n\n/**\n Writes all preferences to disk. This function works only with\n the base preferences group. This function is rarely used as\n deleting the base preferences flushes automatically.\n */\nvoid Fl_Preferences::flush() {\n  if ( rootNode && node->dirty() )\n    rootNode->write();\n}\n\n//-----------------------------------------------------------------------------\n// helper class to create dynamic group and entry names on the fly\n//\n\n/**\n   Creates a group name or entry name on the fly.\n\n   This version creates a simple unsigned integer as an entry name.\n\n   \\code\n     int n, i;\n     Fl_Preferences prev( appPrefs, \"PreviousFiles\" );\n     prev.get( \"n\", 0 );\n     for ( i=0; i<n; i++ )\n       prev.get( Fl_Preferences::Name(i), prevFile[i], \"\" );\n   \\endcode\n */\nFl_Preferences::Name::Name( unsigned int n ) {\n  data_ = (char*)malloc(20);\n  sprintf(data_, \"%u\", n);\n}\n\n/**\n   Creates a group name or entry name on the fly.\n\n   This version creates entry names as in 'printf'.\n\n   \\code\n     int n, i;\n     Fl_Preferences prefs( USER, \"matthiasm.com\", \"test\" );\n     prev.get( \"nFiles\", 0 );\n     for ( i=0; i<n; i++ )\n       prev.get( Fl_Preferences::Name( \"File%d\", i ), prevFile[i], \"\" );\n    \\endcode\n */\nFl_Preferences::Name::Name( const char *format, ... ) {\n  data_ = (char*)malloc(1024);\n  va_list args;\n  va_start(args, format);\n  vsnprintf(data_, 1024, format, args);\n  va_end(args);\n}\n\n// delete the name\nFl_Preferences::Name::~Name() {\n  if (data_) {\n    free(data_);\n    data_ = 0L;\n  }\n}\n\n//-----------------------------------------------------------------------------\n// internal methods, do not modify or use as they will change without notice\n//\n\nint Fl_Preferences::Node::lastEntrySet = -1;\n\n// recursively create a path in the file system\nstatic char makePath( const char *path ) {\n  if (access(path, 0)) {\n    const char *s = strrchr( path, '/' );\n    if ( !s ) return 0;\n    size_t len = s-path;\n    char *p = (char*)malloc( len+1 );\n    memcpy( p, path, len );\n    p[len] = 0;\n    makePath( p );\n    free( p );\n#if defined(WIN32) && !defined(__CYGWIN__)\n    return ( mkdir( path ) == 0 );\n#else\n    return ( mkdir( path, 0777 ) == 0 );\n#endif // WIN32 && !__CYGWIN__\n  }\n  return 1;\n}\n\n#if 0\n// strip the filename and create a path\nstatic void makePathForFile( const char *path ) {\n  const char *s = strrchr( path, '/' );\n  if ( !s ) return;\n  int len = s-path;\n  char *p = (char*)malloc( len+1 );\n  memcpy( p, path, len );\n  p[len] = 0;\n  makePath( p );\n  free( p );\n}\n#endif\n\n// create the root node\n// - construct the name of the file that will hold our preferences\nFl_Preferences::RootNode::RootNode( Fl_Preferences *prefs, Root root, const char *vendor, const char *application )\n: prefs_(prefs),\n  filename_(0L),\n  vendor_(0L),\n  application_(0L) {\n\n  char filename[ FL_PATH_MAX ]; filename[0] = 0;\n#ifdef WIN32\n#  define FLPREFS_RESOURCE\t\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\"\n#  define FLPREFS_RESOURCEW\tL\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\"\n  size_t appDataLen = strlen(vendor) + strlen(application) + 8;\n  DWORD type, nn;\n  LONG err;\n  HKEY key;\n\n  switch (root) {\n    case SYSTEM:\n      err = RegOpenKeyW( HKEY_LOCAL_MACHINE, FLPREFS_RESOURCEW, &key );\n      if (err == ERROR_SUCCESS) {\n        nn = (DWORD) (FL_PATH_MAX - appDataLen); \n        err = RegQueryValueExW( key, L\"Common AppData\", 0L, &type,\n                                (BYTE*)filename, &nn ); \n        if ( ( err != ERROR_SUCCESS ) && ( type == REG_SZ ) ) {\n          filename[0] = 0;\n          filename[1] = 0;\n        }\n        RegCloseKey(key);\n      }\n      break;\n    case USER:\n      err = RegOpenKeyW( HKEY_CURRENT_USER, FLPREFS_RESOURCEW, &key );\n      if (err == ERROR_SUCCESS) {\n        nn = (DWORD) (FL_PATH_MAX - appDataLen);\n        err = RegQueryValueExW( key, L\"AppData\", 0L, &type,\n                                (BYTE*)filename, &nn ); \n        if ( ( err != ERROR_SUCCESS ) && ( type == REG_SZ ) ) {\n          filename[0] = 0;\n          filename[1] = 0;\n\t}\n        RegCloseKey(key);\n      }\n      break;\n  } \n  if (!filename[1] && !filename[0]) {\n    strcpy(filename, \"C:\\\\FLTK\");\n  } else {\n#if 0\n    xchar *b = (xchar*)_wcsdup((xchar *)filename);\n#else\n    // cygwin does not come with _wcsdup. Use malloc +  wcscpy.\n    // For implementation of wcsdup functionality See\n    // - http://linenum.info/p/glibc/2.7/wcsmbs/wcsdup.c\n    xchar *b = (xchar*) malloc((wcslen((xchar *) filename) + 1) * sizeof(xchar));\n    wcscpy(b, (xchar *) filename);\n#endif\n    //  filename[fl_unicode2utf(b, wcslen((xchar*)b), filename)] = 0;\n    unsigned len = fl_utf8fromwc(filename, (FL_PATH_MAX-1), b, (unsigned) wcslen(b));\n    filename[len] = 0;\n    free(b);\n  }\n  snprintf(filename + strlen(filename), sizeof(filename) - strlen(filename),\n           \"/%s/%s.prefs\", vendor, application);\n  for (char *s = filename; *s; s++) if (*s == '\\\\') *s = '/';\n#elif defined ( __APPLE__ )\n  // TODO: verify that this is the Apple sanctioned way of finding these folders\n  // (On MSWindows, this frequently leads to issues with internationalized systems)\n  // Carbon: err = FindFolder( kLocalDomain, kPreferencesFolderType, 1, &spec.vRefNum, &spec.parID );\n  switch (root) {\n    case SYSTEM:\n      strcpy(filename, \"/Library/Preferences\");\n      break;\n    case USER:\n      sprintf(filename, \"%s/Library/Preferences\", fl_getenv(\"HOME\"));\n      break;\n  }\n  snprintf(filename + strlen(filename), sizeof(filename) - strlen(filename),\n           \"/%s/%s.prefs\", vendor, application );\n#else\n  const char *e;\n  switch (root) {\n    case USER:\n      if ((e = fl_getenv(\"HOME\")) != NULL) {\n\tstrlcpy(filename, e, sizeof(filename));\n\n\tif (filename[strlen(filename)-1] != '/') {\n\t  strlcat(filename, \"/.fltk/\", sizeof(filename));\n\t} else {\n\t  strlcat(filename, \".fltk/\", sizeof(filename));\n\t}\n\tbreak;\n      } \n    case SYSTEM:\n      strcpy(filename, \"/etc/fltk/\");\n      break;\n  } \n  snprintf(filename + strlen(filename), sizeof(filename) - strlen(filename),\n           \"%s/%s.prefs\", vendor, application);\n#endif \n  filename_    = strdup(filename);\n  vendor_      = strdup(vendor);\n  application_ = strdup(application); \n  read();\n}\n\n// create the root node\n// - construct the name of the file that will hold our preferences\nFl_Preferences::RootNode::RootNode( Fl_Preferences *prefs, const char *path, const char *vendor, const char *application )\n: prefs_(prefs),\n  filename_(0L),\n  vendor_(0L),\n  application_(0L) {\n\n  if (!vendor)\n    vendor = \"unknown\";\n  if (!application) {\n    application = \"unknown\";\n    filename_ = strdup(path);\n  } else {\n    char filename[ FL_PATH_MAX ]; filename[0] = 0;\n    snprintf(filename, sizeof(filename), \"%s/%s.prefs\", path, application);\n    filename_  = strdup(filename);\n  }\n  vendor_      = strdup(vendor);\n  application_ = strdup(application); \n  read();\n}\n\n// create a root node that exists only on RAM and can not be read or written to\n// a file\nFl_Preferences::RootNode::RootNode( Fl_Preferences *prefs )\n: prefs_(prefs),\n  filename_(0L),\n  vendor_(0L),\n  application_(0L) {\n}\n\n// destroy the root node and all depending nodes\nFl_Preferences::RootNode::~RootNode() {\n  if ( prefs_->node->dirty() )\n    write();\n  if ( filename_ ) {\n    free( filename_ );\n    filename_ = 0L;\n  }\n  if ( vendor_ ) {\n    free( vendor_ );\n    vendor_ = 0L;\n  }\n  if ( application_ ) {\n    free( application_ );\n    application_ = 0L;\n  }\n  delete prefs_->node;\n  prefs_->node = 0L;\n}\n\n// read a preferences file and construct the group tree and with all entry leafs\nint Fl_Preferences::RootNode::read() {\n  if (!filename_)   // RUNTIME preferences\n    return -1; \n  char buf[1024];\n  FILE *f = fl_fopen( filename_, \"rb\" );\n  if ( !f )\n    return -1; \n  if (fgets( buf, 1024, f )==0) { /* ignore */ }\n  if (fgets( buf, 1024, f )==0) { /* ignore */ }\n  if (fgets( buf, 1024, f )==0) { /* ignore */ }\n  Node *nd = prefs_->node;\n  for (;;) {\n    if ( !fgets( buf, 1024, f ) ) break;\t// EOF or Error\n    if ( buf[0]=='[' ) {\t\t\t// read a new group\n      size_t end = strcspn( buf+1, \"]\\n\\r\" );\n      buf[ end+1 ] = 0;\n      nd = prefs_->node->find( buf+1 );\n    } else if ( buf[0]=='+' ) {\t\t\t// value of previous name/value pair spans multiple lines\n      size_t end = strcspn( buf+1, \"\\n\\r\" );\n      if ( end != 0 ) {\t\t\t\t// if entry is not empty\n\tbuf[ end+1 ] = 0;\n\tnd->add( buf+1 );\n      }\n    } else {\t\t\t\t\t // read a name/value pair\n      size_t end = strcspn( buf, \"\\n\\r\" );\n      if ( end != 0 ) {\t\t\t\t// if entry is not empty\n\tbuf[ end ] = 0;\n\tnd->set( buf );\n      }\n    }\n  }\n  fclose( f );\n  return 0;\n}\n\n// write the group tree and all entry leafs\nint Fl_Preferences::RootNode::write() {\n  if (!filename_)   // RUNTIME preferences\n    return -1; \n  fl_make_path_for_file(filename_);\n  FILE *f = fl_fopen( filename_, \"wb\" );\n  if ( !f )\n    return -1; \n  fprintf( f, \"; FLTK preferences file format 1.0\\n\" );\n  fprintf( f, \"; vendor: %s\\n\", vendor_ );\n  fprintf( f, \"; application: %s\\n\", application_ );\n  prefs_->node->write( f );\n  fclose( f );\n#if !(defined(__APPLE__) || defined(WIN32))\n  // unix: make sure that system prefs are user-readable\n  if (strncmp(filename_, \"/etc/fltk/\", 10) == 0) {\n    char *p;\n    p = filename_ + 9;\n    do {\t\t\t // for each directory to the pref file\n      *p = 0;\n      fl_chmod(filename_, 0755); // rwxr-xr-x\n      *p = '/';\n      p = strchr(p+1, '/');\n    } while (p);\n    fl_chmod(filename_, 0644);   // rw-r--r--\n  }\n#endif\n  return 0;\n}\n\n// get the path to the preferences directory\nchar Fl_Preferences::RootNode::getPath( char *path, int pathlen ) {\n  if (!filename_)   // RUNTIME preferences\n    return 1; // return 1 (not -1) to be consistent with fl_make_path()\n  strlcpy( path, filename_, pathlen); \n\n  char *s;\n  for ( s = path; *s; s++ ) if ( *s == '\\\\' ) *s = '/';\n  s = strrchr( path, '.' );\n  if ( !s ) return 0;\n  *s = 0;\n  char ret = fl_make_path( path );\n#if !(defined(__APPLE__) || defined(WIN32))\n  // unix: make sure that system prefs dir. is user-readable\n  if (strncmp(path, \"/etc/fltk/\", 10) == 0) {\n    fl_chmod(path, 0755); // rwxr-xr-x\n  }\n#endif\n  strcpy( s, \"/\" );\n  return ret;\n}\n\n// create a node that represents a group\n// - path must be a single word, prferable alnum(), dot and underscore only. Space is ok.\nFl_Preferences::Node::Node( const char *path ) {\n  if ( path ) path_ = strdup( path ); else path_ = 0;\n  child_ = 0; next_ = 0; parent_ = 0;\n  entry_ = 0;\n  nEntry_ = NEntry_ = 0;\n  dirty_ = 0;\n  top_ = 0;\n  indexed_ = 0;\n  index_ = 0;\n  nIndex_ = NIndex_ = 0;\n}\n\nvoid Fl_Preferences::Node::deleteAllChildren() {\n  Node *nx;\n  for ( Node *nd = child_; nd; nd = nx ) {\n    nx = nd->next_;\n    delete nd;\n  }\n  child_ = 0L;\n  dirty_ = 1;\n  updateIndex();\n}\n\nvoid Fl_Preferences::Node::deleteAllEntries() {\n  if ( entry_ ) {\n    for ( int i = 0; i < nEntry_; i++ ) {\n      if ( entry_[i].name ) {\n\tfree( entry_[i].name );\n\tentry_[i].name = 0L;\n      }\n      if ( entry_[i].value ) {\n\tfree( entry_[i].value );\n\tentry_[i].value = 0L;\n      }\n    }\n    free( entry_ );\n    entry_ = 0L;\n    nEntry_ = 0;\n    NEntry_ = 0;\n  }\n  dirty_ = 1;\n}\n\n// delete this and all depending nodes\nFl_Preferences::Node::~Node() {\n  deleteAllChildren();\n  deleteAllEntries();\n  deleteIndex();\n  if ( path_ ) {\n    free( path_ );\n    path_ = 0L;\n  }\n  next_ = 0L;\n  parent_ = 0L;\n}\n\n// recursively check if any entry is dirty (was changed after loading a fresh prefs file)\nchar Fl_Preferences::Node::dirty() {\n  if ( dirty_ ) return 1;\n  if ( next_ && next_->dirty() ) return 1;\n  if ( child_ && child_->dirty() ) return 1;\n  return 0;\n}\n\n// write this node (recursively from the last neighbor back to this)\n// write all entries\n// write all children\nint Fl_Preferences::Node::write( FILE *f ) {\n  if ( next_ ) next_->write( f );\n  fprintf( f, \"\\n[%s]\\n\\n\", path_ );\n  for ( int i = 0; i < nEntry_; i++ ) {\n    char *src = entry_[i].value;\n    if ( src ) {\t\t// hack it into smaller pieces if needed\n      fprintf( f, \"%s:\", entry_[i].name );\n      size_t cnt, written = 0;\n      for ( cnt = 0; cnt < 60; cnt++ )\n\tif ( src[cnt]==0 ) break;\n      written += fwrite( src, cnt, 1, f );\n      fprintf( f, \"\\n\" );\n      src += cnt;\n      for (;*src;) {\n\tfor ( cnt = 0; cnt < 80; cnt++ )\n\t  if ( src[cnt]==0 ) break;\n        fputc( '+', f );\n\twritten = fwrite( src, cnt, 1, f );\n        fputc( '\\n', f );\n\tsrc += cnt;\n      }\n    }\n    else\n      fprintf( f, \"%s\\n\", entry_[i].name );\n  }\n  if ( child_ ) child_->write( f );\n  dirty_ = 0;\n  return 0;\n}\n\n// set the parent node and create the full path\nvoid Fl_Preferences::Node::setParent( Node *pn ) {\n  parent_ = pn;\n  next_ = pn->child_;\n  pn->child_ = this;\n  sprintf( nameBuffer, \"%s/%s\", pn->path_, path_ );\n  free( path_ );\n  path_ = strdup( nameBuffer );\n}\n\n// find the corresponding root node\nFl_Preferences::RootNode *Fl_Preferences::Node::findRoot() {\n  Node *n = this;\n  do {\n    if (n->top_)\n      return n->root_;\n    n = n->parent();\n  } while (n);\n  return 0L;\n}\n\n// add a child to this node and set its path (try to find it first...)\nFl_Preferences::Node *Fl_Preferences::Node::addChild( const char *path ) {\n  sprintf( nameBuffer, \"%s/%s\", path_, path );\n  char *name = strdup( nameBuffer );\n  Node *nd = find( name );\n  free( name );\n  dirty_ = 1;\n  updateIndex();\n  return nd;\n}\n\n// create and set, or change an entry within this node\nvoid Fl_Preferences::Node::set( const char *name, const char *value )\n{\n  for ( int i=0; i<nEntry_; i++ ) {\n    if ( strcmp( name, entry_[i].name ) == 0 ) {\n      if ( !value ) return; // annotation\n      if ( strcmp( value, entry_[i].value ) != 0 ) {\n\tif ( entry_[i].value )\n\t  free( entry_[i].value );\n\tentry_[i].value = strdup( value );\n\tdirty_ = 1;\n      }\n      lastEntrySet = i;\n      return;\n    }\n  }\n  if ( NEntry_==nEntry_ ) {\n    NEntry_ = NEntry_ ? NEntry_*2 : 10;\n    entry_ = (Entry*)realloc( entry_, NEntry_ * sizeof(Entry) );\n  }\n  entry_[ nEntry_ ].name = strdup( name );\n  entry_[ nEntry_ ].value = value?strdup( value ):0;\n  lastEntrySet = nEntry_;\n  nEntry_++;\n  dirty_ = 1;\n}\n\n// create or set a value (or annotation) from a single line in the file buffer\nvoid Fl_Preferences::Node::set( const char *line ) {\n  // hmm. If we assume that we always read this file in the beginning,\n  // we can handle the dirty flag 'quick and dirty'\n  char dirt = dirty_;\n  if ( line[0]==';' || line[0]==0 || line[0]=='#' ) {\n    set( line, 0 );\n  } else {\n    const char *c = strchr( line, ':' );\n    if ( c ) {\n      size_t len = c-line+1;\n      if ( len >= sizeof( nameBuffer ) )\n        len = sizeof( nameBuffer );\n      strlcpy( nameBuffer, line, len );\n      set( nameBuffer, c+1 );\n    } else {\n      set( line, \"\" );\n    }\n  }\n  dirty_ = dirt;\n}\n\n// add more data to an existing entry\nvoid Fl_Preferences::Node::add( const char *line ) {\n  if ( lastEntrySet<0 || lastEntrySet>=nEntry_ ) return;\n  char *&dst = entry_[ lastEntrySet ].value;\n  size_t a = strlen( dst );\n  size_t b = strlen( line );\n  dst = (char*)realloc( dst, a+b+1 );\n  memcpy( dst+a, line, b+1 );\n  dirty_ = 1;\n}\n\n// get the value for a name, returns 0 if no such name\nconst char *Fl_Preferences::Node::get( const char *name ) {\n  int i = getEntry( name );\n  return i>=0 ? entry_[i].value : 0 ;\n}\n\n// find the index of an entry, returns -1 if no such entry\nint Fl_Preferences::Node::getEntry( const char *name ) {\n  for ( int i=0; i<nEntry_; i++ ) {\n    if ( strcmp( name, entry_[i].name ) == 0 ) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n// remove one entry form this group\nchar Fl_Preferences::Node::deleteEntry( const char *name ) {\n  int ix = getEntry( name );\n  if ( ix == -1 ) return 0;\n  memmove( entry_+ix, entry_+ix+1, (nEntry_-ix-1) * sizeof(Entry) );\n  nEntry_--;\n  dirty_ = 1;\n  return 1;\n}\n\n// find a group somewhere in the tree starting here\n// - this method will always return a valid node (except for memory allocation problems)\n// - if the node was not found, 'find' will create the required branch\nFl_Preferences::Node *Fl_Preferences::Node::find( const char *path ) {\n  int len = (int) strlen( path_ );\n  if ( strncmp( path, path_, len ) == 0 ) {\n    if ( path[ len ] == 0 )\n      return this;\n    if ( path[ len ] == '/' ) {\n      Node *nd;\n      for ( nd = child_; nd; nd = nd->next_ ) {\n\tNode *nn = nd->find( path );\n\tif ( nn ) return nn;\n      }\n      const char *s = path+len+1;\n      const char *e = strchr( s, '/' );\n      if (e) strlcpy( nameBuffer, s, e-s+1 );\n      else strlcpy( nameBuffer, s, sizeof(nameBuffer));\n      nd = new Node( nameBuffer );\n      nd->setParent( this );\n      return nd->find( path );\n    }\n  }\n  return 0;\n}\n\n// find a group somewhere in the tree starting here\n// caller must not set 'offset' argument\n// - if the node does not exist, 'search' returns NULL\n// - if the pathname is \".\" (current node) return this node\n// - if the pathname is \"./\" (root node) return the topmost node\n// - if the pathname starts with \"./\", start the search at the root node instead\nFl_Preferences::Node *Fl_Preferences::Node::search( const char *path, int offset ) { \n  if ( offset == 0 ) {\n    if ( path[0] == '.' ) {\n      if ( path[1] == 0 ) {\n\treturn this; // user was searching for current node\n      } else if ( path[1] == '/' ) {\n\tNode *nn = this;\n\twhile ( nn->parent() ) nn = nn->parent();\n\tif ( path[2]==0 ) {\t\t// user is searching for root ( \"./\" )\n\t  return nn;\n\t}\n\treturn nn->search( path+2, 2 ); // do a relative search on the root node\n      }\n    }\n    offset = (int) strlen( path_ ) + 1;\n  }\n  int len = (int) strlen( path_ );\n  if ( len < offset-1 ) return 0;\n  len -= offset;\n  if ( ( len <= 0 ) || ( strncmp( path, path_+offset, len ) == 0 ) ) {\n    if ( len > 0 && path[ len ] == 0 )\n      return this;\n    if ( len <= 0 || path[ len ] == '/' ) {\n      for ( Node *nd = child_; nd; nd = nd->next_ ) {\n\tNode *nn = nd->search( path, offset );\n\tif ( nn ) return nn;\n      }\n      return 0;\n    }\n  }\n  return 0;\n}\n\n// return the number of child nodes (groups)\nint Fl_Preferences::Node::nChildren() {\n  if (indexed_) {\n    return nIndex_;\n  } else {\n    int cnt = 0;\n    for ( Node *nd = child_; nd; nd = nd->next_ )\n      cnt++;\n    return cnt;\n  }\n}\n\n// return the node name\nconst char *Fl_Preferences::Node::name() {\n  if ( path_ ) {\n    char *r = strrchr( path_, '/' );\n    return r ? r+1 : path_ ;\n  } else {\n    return 0L ;\n  }\n}\n\n// return the n'th child node's name\nconst char *Fl_Preferences::Node::child( int ix ) {\n  Node *nd = childNode( ix );\n  if ( nd )\n    return nd->name();\n  else\n    return 0L ;\n}\n\n// return the n'th child node\nFl_Preferences::Node *Fl_Preferences::Node::childNode( int ix ) {\n  createIndex();\n  if (indexed_) {\n    // usually faster access in correct order, but needing more memory\n    return index_[ix];\n  } else {\n    // slow access and reverse order\n    int n = nChildren();\n    ix = n - ix -1;\n    Node *nd;\n    for ( nd = child_; nd; nd = nd->next_ ) {\n      if ( !ix-- ) break;\n      if ( !nd ) break;\n    }\n    return nd;\n  }\n}\n\n// remove myself from the list and delete me (and all children)\nchar Fl_Preferences::Node::remove() {\n  Node *nd = 0, *np;\n  if ( parent() ) {\n    nd = parent()->child_; np = 0L;\n    for ( ; nd; np = nd, nd = nd->next_ ) {\n      if ( nd == this ) {\n\tif ( np )\n\t  np->next_ = nd->next_;\n\telse\n\t  parent()->child_ = nd->next_;\n\tbreak;\n      }\n    }\n    parent()->dirty_ = 1;\n    parent()->updateIndex();\n  }\n  delete this;\n  return ( nd != 0 );\n}\n\nvoid Fl_Preferences::Node::createIndex() {\n  if (indexed_) return;\n  int n = nChildren();\n  if (n>NIndex_) {\n    NIndex_ = n + 16;\n    index_ = (Node**)realloc(index_, NIndex_*sizeof(Node**));\n  }\n  Node *nd;\n  int i = 0;\n  for (nd = child_; nd; nd = nd->next_, i++) {\n    index_[n-i-1] = nd;\n  }\n  nIndex_ = n;\n  indexed_ = 1;\n}\n\nvoid Fl_Preferences::Node::updateIndex() {\n  indexed_ = 0;\n}\n\nvoid Fl_Preferences::Node::deleteIndex() {\n  if (index_) free(index_);\n  NIndex_ = nIndex_ = 0;\n  index_ = 0;\n  indexed_ = 0;\n}\n\n/**\n * \\brief Create a plugin.\n *\n * \\param[in] klass plugins are grouped in classes\n * \\param[in] name every plugin should have a unique name\n */\nFl_Plugin::Fl_Plugin(const char *klass, const char *name)\n: id(0) {\n#ifdef FL_PLUGIN_VERBOSE\n  printf(\"Fl_Plugin: creating a plugin, class \\\"%s\\\", name \\\"%s\\\"\\n\",\n         klass, name);\n#endif\n  Fl_Plugin_Manager pm(klass);\n  id = pm.addPlugin(name, this);\n}\n\n/**\n * \\brief Clear the plugin and remove it from the database.\n */\nFl_Plugin::~Fl_Plugin() {\n#ifdef FL_PLUGIN_VERBOSE\n  printf(\"Fl_Plugin: deleting a plugin\\n\");\n#endif\n  if (id)\n    Fl_Plugin_Manager::remove(id);\n}\n\n/**\n * \\brief Manage all plugins belonging to one class.\n */\nFl_Plugin_Manager::Fl_Plugin_Manager(const char *klass)\n: Fl_Preferences(0, Fl_Preferences::Name(\"%s/%s\", \"plugins\", klass)) {\n#ifdef FL_PLUGIN_VERBOSE\n  printf(\"Fl_Plugin: creating a plugin manager for class \\\"%s\\\"\\n\", klass);\n#endif\n}\n\n/**\n * \\brief Remove the plugin manager.\n *\n * Calling this does not remove the database itself or any plugins. It just\n * removes the reference to the database.\n */\nFl_Plugin_Manager::~Fl_Plugin_Manager() {\n#ifdef FL_PLUGIN_VERBOSE\n  printf(\"Fl_Plugin: deleting a plugin manager\\n\");\n#endif\n}\n\nstatic unsigned char x2i(char hi, char lo) {\n  return ((hi-'A')<<4) | (lo-'A');\n}\n\nstatic void i2x(unsigned char v, char *d) {\n  d[0] = ((v>>4)&0x0f)+'A'; d[1] = (v&0x0f)+'A';\n}\n\nstatic void *a2p(const char *s) {\n  union { void *ret; unsigned char d[sizeof(void*)]; } v;\n  v.ret = 0L;\n  int i=0, n=sizeof(void*);\n  for (i=0; i<n; i++) {\n    v.d[i] = x2i(s[2*i], s[2*i+1]);\n  }\n  return v.ret;\n}\n\nstatic void p2a(void *vp, char *d) {\n  union { void *vp; unsigned char s[sizeof(void*)]; } v;\n  v.vp = vp;\n  int i=0, n=sizeof(void*);\n  for (i=0; i<n; i++) {\n    i2x(v.s[i], d+i*2);\n  }\n  d[2*i] = 0;\n}\n\n/**\n * \\brief Return the address of a plugin by index.\n */\nFl_Plugin *Fl_Plugin_Manager::plugin(int index) {\n  char buf[34];\n  Fl_Plugin *ret = 0;\n  Fl_Preferences pin(this, index);\n  pin.get(\"address\", buf, \"\", 34);\n  if (buf[0]=='@') ret = (Fl_Plugin*)a2p(buf+1);\n#ifdef FL_PLUGIN_VERBOSE\n  printf(\"Fl_Plugin: returning plugin at index %d: (%s) %p\\n\", index, buf, ret);\n#endif\n  return ret;\n}\n\n/**\n * \\brief Return the address of a plugin by name.\n */\nFl_Plugin *Fl_Plugin_Manager::plugin(const char *name) {\n  char buf[34];\n  Fl_Plugin *ret = 0;\n  if (groupExists(name)) {\n    Fl_Preferences pin(this, name);\n    pin.get(\"address\", buf, \"\", 34);\n    if (buf[0]=='@') ret = (Fl_Plugin*)a2p(buf+1);\n#ifdef FL_PLUGIN_VERBOSE\n    printf(\"Fl_Plugin: returning plugin named \\\"%s\\\": (%s) %p\\n\", name, buf, ret);\n#endif\n    return ret;\n  } else {\n#ifdef FL_PLUGIN_VERBOSE\n    printf(\"Fl_Plugin: no plugin found named \\\"%s\\\"\\n\", name);\n#endif\n    return 0L;\n  }\n}\n\n/**\n * \\brief This function adds a new plugin to the database.\n *\n * There is no need to call this function explicitly. Every Fl_Plugin constructor\n * will call this function at initialization time.\n */\nFl_Preferences::ID Fl_Plugin_Manager::addPlugin(const char *name, Fl_Plugin *plugin) {\n  char buf[34];\n#ifdef FL_PLUGIN_VERBOSE\n  printf(\"Fl_Plugin: adding plugin named \\\"%s\\\" at 0x%p\\n\", name, plugin);\n#endif\n  Fl_Preferences pin(this, name);\n  buf[0] = '@'; p2a(plugin, buf+1);\n  pin.set(\"address\", buf);\n  return pin.id();\n}\n\n/**\n * \\brief Remove any plugin.\n *\n * There is no need to call this function explicitly. Every Fl_Plugin destructor\n * will call this function at destruction time.\n */\nvoid Fl_Plugin_Manager::removePlugin(Fl_Preferences::ID id) {\n  Fl_Preferences::remove(id);\n}\n\n/**\n * \\brief Load a module from disk.\n *\n * A module must be a dynamically linkable file for the given operating system.\n * When loading a module, its +init function will be called which in turn calls\n * the constructor of all statically initialized Fl_Plugin classes and adds\n * them to the database.\n */\nint Fl_Plugin_Manager::load(const char *filename) {\n  // the functions below will autmaticaly load plugins that are defined:\n  // Fl_My_Plugin plugin();\n#if defined(WIN32) && !defined(__CYGWIN__)\n  HMODULE dl = LoadLibrary(filename);\n#else\n  void * dl = NULL;\n# if HAVE_DLSYM\n    dl = dlopen(filename, RTLD_LAZY);\n# endif\n#endif\n  // There is no way of unloading a plugin!\n  return (dl!=0) ? 0 : -1;\n}\n\n/**\n * \\brief Use this function to load a whole directory full of modules.\n */\nint Fl_Plugin_Manager::loadAll(const char *filepath, const char *pattern) {\n  struct dirent **dir;\n  int i, n = fl_filename_list(filepath, &dir);\n  for (i=0; i<n; i++) {\n    struct dirent *e = dir[i];\n    if (pattern==0 || fl_filename_match(e->d_name, pattern)) {\n      load(Fl_Preferences::Name(\"%s%s\", filepath, e->d_name));\n    }\n    free(e);\n  }\n  free(dir);\n  return 0;\n}\n\n//\n// End of \"$Id: Fl_Preferences.cxx 10378 2014-10-14 12:10:18Z ianmacarthur $\".\n//\n",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/src/Fl_cocoa.mm": "//\n// \"$Id: Fl_cocoa.mm 10427 2014-11-02 21:06:07Z manolo $\"\n//\n// MacOS-Cocoa specific code for the Fast Light Tool Kit (FLTK).\n//\n// Copyright 1998-2014 by Bill Spitzak and others.\n//\n// This library is free software. Distribution and use rights are outlined in\n// the file \"COPYING\" which should have been included with this file.  If this\n// file is missing or damaged, see the license at:\n//\n//     http://www.fltk.org/COPYING.php\n//\n// Please report all bugs and problems on the following page:\n//\n//     http://www.fltk.org/str.php\n//\n\n//// From the inner edge of a MetroWerks CodeWarrior CD:\n// (without permission)\n//\n// \"Three Compiles for 68Ks under the sky,\n// Seven Compiles for PPCs in their fragments of code,\n// Nine Compiles for Mortal Carbon doomed to die,\n// One Compile for Mach-O Cocoa on its Mach-O throne,\n// in the Land of MacOS X where the Drop-Shadows lie.\n// \n// One Compile to link them all, One Compile to merge them,\n// One Compile to copy them all and in the bundle bind them,\n// in the Land of MacOS X where the Drop-Shadows lie.\"\n\n#ifdef __APPLE__\n\n#define CONSOLIDATE_MOTION 0\nextern \"C\" {\n#include <pthread.h>\n}\n\n\n#include <FL/Fl.H>\n#include <FL/x.H>\n#include <FL/Fl_Window.H>\n#include <FL/Fl_Tooltip.H>\n#include <FL/Fl_Printer.H>\n#include <FL/Fl_Input_.H>\n#include <FL/Fl_Text_Display.H>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"flstring.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <math.h>\n#include <limits.h>\n#include <dlfcn.h>\n\n#import <Cocoa/Cocoa.h>\n\n#ifndef NSINTEGER_DEFINED // appears with 10.5 in NSObjCRuntime.h\n#if defined(__LP64__) && __LP64__\ntypedef long NSInteger;\ntypedef unsigned long NSUInteger;\n#else\ntypedef long NSInteger;\ntypedef unsigned int NSUInteger;\n#endif\n#endif\n\n\n// #define DEBUG_SELECT\t\t// UNCOMMENT FOR SELECT()/THREAD DEBUGGING\n#ifdef DEBUG_SELECT\n#include <stdio.h>\t\t// testing\n#define DEBUGMSG(msg)\t\tif ( msg ) fprintf(stderr, msg);\n#define DEBUGPERRORMSG(msg)\tif ( msg ) perror(msg)\n#define DEBUGTEXT(txt)\t\ttxt\n#else\n#define DEBUGMSG(msg)\n#define DEBUGPERRORMSG(msg)\n#define DEBUGTEXT(txt)\t\tNULL\n#endif /*DEBUG_SELECT*/\n\n// external functions\nextern void fl_fix_focus();\nextern unsigned short *fl_compute_macKeyLookUp();\nextern int fl_send_system_handlers(void *e);\n\n// forward definition of functions in this file\n// converting cr lf converter function\nstatic void convert_crlf(char * string, size_t len);\nstatic void createAppleMenu(void);\nstatic Fl_Region MacRegionMinusRect(Fl_Region r, int x,int y,int w,int h);\nstatic void cocoaMouseHandler(NSEvent *theEvent);\nstatic int calc_mac_os_version();\nstatic void clipboard_check(void);\nstatic NSString *calc_utf8_format(void);\nstatic void im_update(void);\nstatic unsigned make_current_counts = 0; // if > 0, then Fl_Window::make_current() can be called only once\nstatic Fl_X *fl_x_to_redraw = NULL; // set by Fl_X::flush() to the Fl_X object of the window to be redrawn\n\nFl_Display_Device *Fl_Display_Device::_display = new Fl_Display_Device(new Fl_Quartz_Graphics_Driver); // the platform display\n\n// public variables\nCGContextRef fl_gc = 0;\nvoid *fl_capture = 0;\t\t\t// (NSWindow*) we need this to compensate for a missing(?) mouse capture\nbool fl_show_iconic;                    // true if called from iconize() - shows the next created window in collapsed state\n//int fl_disable_transient_for;           // secret method of removing TRANSIENT_FOR\nWindow fl_window;\nFl_Window *Fl_Window::current_;\nint fl_mac_os_version = calc_mac_os_version();\t\t// the version number of the running Mac OS X (e.g., 100604 for 10.6.4)\nstatic SEL inputContextSEL = (fl_mac_os_version >= 100600 ? @selector(inputContext) : @selector(FLinputContext));\nFl_Fontdesc* fl_fonts = Fl_X::calc_fl_fonts();\nstatic NSString *utf8_format = calc_utf8_format();\n\n// forward declarations of variables in this file\nstatic int got_events = 0;\nstatic Fl_Window* resize_from_system;\nstatic int main_screen_height; // height of menubar-containing screen used to convert between Cocoa and FLTK global screen coordinates\n// through_drawRect = YES means the drawRect: message was sent to the view, \n// thus the graphics context was prepared by the system\nstatic BOOL through_drawRect = NO; \nstatic int im_enabled = -1;\n\n#if CONSOLIDATE_MOTION\nstatic Fl_Window* send_motion;\nextern Fl_Window* fl_xmousewin;\n#endif\n\nenum { FLTKTimerEvent = 1, FLTKDataReadyEvent };\n\n// Carbon functions and definitions\n\ntypedef void *TSMDocumentID;\n\nextern \"C\" enum {\n kTSMDocumentEnabledInputSourcesPropertyTag = 'enis' //  from Carbon/TextServices.h\n};\n\n// Undocumented voodoo. Taken from Mozilla.\nstatic const int smEnableRomanKybdsOnly = -23;\n\ntypedef TSMDocumentID (*TSMGetActiveDocument_type)(void);\nstatic TSMGetActiveDocument_type TSMGetActiveDocument;\ntypedef OSStatus (*TSMSetDocumentProperty_type)(TSMDocumentID, OSType, UInt32, void*);\nstatic TSMSetDocumentProperty_type TSMSetDocumentProperty;\ntypedef OSStatus (*TSMRemoveDocumentProperty_type)(TSMDocumentID, OSType);\nstatic TSMRemoveDocumentProperty_type TSMRemoveDocumentProperty;\ntypedef CFArrayRef (*TISCreateASCIICapableInputSourceList_type)(void);\nstatic TISCreateASCIICapableInputSourceList_type TISCreateASCIICapableInputSourceList;\n\ntypedef void (*KeyScript_type)(short);\nstatic KeyScript_type KeyScript;\n\n\n/* fltk-utf8 placekeepers */\nvoid fl_reset_spot()\n{\n}\n\nvoid fl_set_spot(int font, int size, int X, int Y, int W, int H, Fl_Window *win)\n{\n}\n\nvoid fl_set_status(int x, int y, int w, int h)\n{\n}\n\n/*\n * Mac keyboard lookup table\n */\nstatic unsigned short* macKeyLookUp = fl_compute_macKeyLookUp();\n\n/*\n * convert the current mouse chord into the FLTK modifier state\n */\nstatic unsigned int mods_to_e_state( NSUInteger mods )\n{\n  long state = 0;\n  if ( mods & NSCommandKeyMask ) state |= FL_META;\n  if ( mods & NSAlternateKeyMask ) state |= FL_ALT;\n  if ( mods & NSControlKeyMask ) state |= FL_CTRL;\n  if ( mods & NSShiftKeyMask ) state |= FL_SHIFT;\n  if ( mods & NSAlphaShiftKeyMask ) state |= FL_CAPS_LOCK;\n  unsigned int ret = ( Fl::e_state & 0xff000000 ) | state;\n  Fl::e_state = ret;\n  //printf( \"State 0x%08x (%04x)\\n\", Fl::e_state, mods );\n  return ret;\n}\n\n// these pointers are set by the Fl::lock() function:\nstatic void nothing() {}\nvoid (*fl_lock_function)() = nothing;\nvoid (*fl_unlock_function)() = nothing;\n\n//\n// Select interface -- how it's implemented:\n//     When the user app configures one or more file descriptors to monitor\n//     with Fl::add_fd(), we start a separate thread to select() the  data,\n//     sending a custom OSX 'FLTK data ready event' to the parent  thread's\n//     RunApplicationLoop(), so that it triggers the data  ready  callbacks\n//     in the parent thread.                               -erco 04/04/04\n//     \n#define POLLIN  1\n#define POLLOUT 4\n#define POLLERR 8\n\n// Class to handle select() 'data ready'\nclass DataReady\n{\n  struct FD\n  {\n    int fd;\n    short events;\n    void (*cb)(int, void*);\n    void* arg;\n  };\n  int nfds, fd_array_size;\n  FD *fds;\n  pthread_t tid;\t\t// select()'s thread id\n  \n  // Data that needs to be locked (all start with '_')\n  pthread_mutex_t _datalock;\t// data lock\n  fd_set _fdsets[3];\t\t// r/w/x sets user wants to monitor\n  int _maxfd;\t\t\t// max fd count to monitor\n  int _cancelpipe[2];\t\t// pipe used to help cancel thread\n  \npublic:\n  DataReady()\n  {\n    nfds = 0;\n    fd_array_size = 0;\n    fds = 0;\n    tid = 0;\n    \n    pthread_mutex_init(&_datalock, NULL);\n    FD_ZERO(&_fdsets[0]); FD_ZERO(&_fdsets[1]); FD_ZERO(&_fdsets[2]);\n    _cancelpipe[0] = _cancelpipe[1] = 0;\n    _maxfd = -1;\n  }\n  \n  ~DataReady()\n  {\n    CancelThread(DEBUGTEXT(\"DESTRUCTOR\\n\"));\n    if (fds) { free(fds); fds = 0; }\n    nfds = 0;\n  }\n  \n  // Locks\n  //    The convention for locks: volatile vars start with '_',\n  //    and must be locked before use. Locked code is prefixed \n  //    with /*LOCK*/ to make painfully obvious esp. in debuggers. -erco\n  //\n  void DataLock() { pthread_mutex_lock(&_datalock); }\n  void DataUnlock() { pthread_mutex_unlock(&_datalock); }\n  \n  // Accessors\n  int IsThreadRunning() { return(tid ? 1 : 0); }\n  int GetNfds() { return(nfds); }\n  int GetCancelPipe(int ix) { return(_cancelpipe[ix]); }\n  fd_set GetFdset(int ix) { return(_fdsets[ix]); }\n  \n  // Methods\n  void AddFD(int n, int events, void (*cb)(int, void*), void *v);\n  void RemoveFD(int n, int events);\n  int CheckData(fd_set& r, fd_set& w, fd_set& x);\n  void HandleData(fd_set& r, fd_set& w, fd_set& x);\n  static void* DataReadyThread(void *self);\n  void StartThread(void);\n  void CancelThread(const char *reason);\n};\n\nstatic DataReady dataready;\n\nvoid DataReady::AddFD(int n, int events, void (*cb)(int, void*), void *v)\n{\n  RemoveFD(n, events);\n  int i = nfds++;\n  if (i >= fd_array_size) \n  {\n    fl_open_display(); // necessary for NSApp to be defined and the event loop to work\n    FD *temp;\n    fd_array_size = 2*fd_array_size+1;\n    if (!fds) { temp = (FD*)malloc(fd_array_size*sizeof(FD)); }\n    else { temp = (FD*)realloc(fds, fd_array_size*sizeof(FD)); }\n    if (!temp) return;\n    fds = temp;\n  }\n  fds[i].cb  = cb;\n  fds[i].arg = v;\n  fds[i].fd  = n;\n  fds[i].events = events;\n  DataLock();\n  /*LOCK*/  if (events & POLLIN)  FD_SET(n, &_fdsets[0]);\n  /*LOCK*/  if (events & POLLOUT) FD_SET(n, &_fdsets[1]);\n  /*LOCK*/  if (events & POLLERR) FD_SET(n, &_fdsets[2]);\n  /*LOCK*/  if (n > _maxfd) _maxfd = n;\n  DataUnlock();\n}\n\n// Remove an FD from the array\nvoid DataReady::RemoveFD(int n, int events)\n{\n  int i,j;\n  _maxfd = -1; // recalculate maxfd on the fly\n  for (i=j=0; i<nfds; i++) {\n    if (fds[i].fd == n) {\n      int e = fds[i].events & ~events;\n      if (!e) continue; // if no events left, delete this fd\n      fds[i].events = e;\n    }\n    if (fds[i].fd > _maxfd) _maxfd = fds[i].fd;\n    // move it down in the array if necessary:\n    if (j<i) {\n      fds[j] = fds[i];\n    }\n    j++;\n  }\n  nfds = j;\n  DataLock();\n  /*LOCK*/  if (events & POLLIN)  FD_CLR(n, &_fdsets[0]);\n  /*LOCK*/  if (events & POLLOUT) FD_CLR(n, &_fdsets[1]);\n  /*LOCK*/  if (events & POLLERR) FD_CLR(n, &_fdsets[2]);\n  DataUnlock();\n}\n\n// CHECK IF USER DATA READY, RETURNS r/w/x INDICATING WHICH IF ANY\nint DataReady::CheckData(fd_set& r, fd_set& w, fd_set& x)\n{\n  int ret;\n  DataLock();\n  /*LOCK*/  timeval t = { 0, 1 };\t\t// quick check\n  /*LOCK*/  r = _fdsets[0], w = _fdsets[1], x = _fdsets[2];\n  /*LOCK*/  ret = ::select(_maxfd+1, &r, &w, &x, &t);\n  DataUnlock();\n  if ( ret == -1 ) {\n    DEBUGPERRORMSG(\"CheckData(): select()\");\n  }\n  return(ret);\n}\n\n// HANDLE DATA READY CALLBACKS\nvoid DataReady::HandleData(fd_set& r, fd_set& w, fd_set& x)\n{\n  for (int i=0; i<nfds; i++) {\n    int f = fds[i].fd;\n    short revents = 0;\n    if (FD_ISSET(f, &r)) revents |= POLLIN;\n    if (FD_ISSET(f, &w)) revents |= POLLOUT;\n    if (FD_ISSET(f, &x)) revents |= POLLERR;\n    if (fds[i].events & revents) {\n      DEBUGMSG(\"DOING CALLBACK: \");\n      fds[i].cb(f, fds[i].arg);\n      DEBUGMSG(\"DONE\\n\");\n    }\n  }\n}\n\n// DATA READY THREAD\n//    This thread watches for changes in user's file descriptors.\n//    Sends a 'data ready event' to the main thread if any change.\n//\nvoid* DataReady::DataReadyThread(void *o)\n{\n  DataReady *self = (DataReady*)o;\n  while ( 1 ) {\t\t\t\t\t// loop until thread cancel or error\n    // Thread safe local copies of data before each select()\n    self->DataLock();\n    /*LOCK*/  int maxfd = self->_maxfd;\n    /*LOCK*/  fd_set r = self->GetFdset(0);\n    /*LOCK*/  fd_set w = self->GetFdset(1);\n    /*LOCK*/  fd_set x = self->GetFdset(2);\n    /*LOCK*/  int cancelpipe = self->GetCancelPipe(0);\n    /*LOCK*/  if ( cancelpipe > maxfd ) maxfd = cancelpipe;\n    /*LOCK*/  FD_SET(cancelpipe, &r);\t\t// add cancelpipe to fd's to watch\n    /*LOCK*/  FD_SET(cancelpipe, &x);\n    self->DataUnlock();\n    // timeval t = { 1000, 0 };\t// 1000 seconds;\n    timeval t = { 2, 0 };\t// HACK: 2 secs prevents 'hanging' problem\n    int ret = ::select(maxfd+1, &r, &w, &x, &t);\n    pthread_testcancel();\t// OSX 10.0.4 and older: needed for parent to cancel\n    switch ( ret ) {\n      case 0:\t// NO DATA\n        continue;\n      case -1:\t// ERROR\n      {\n        DEBUGPERRORMSG(\"CHILD THREAD: select() failed\");\n        return(NULL);\t\t// error? exit thread\n      }\n      default:\t// DATA READY\n      {\n        if (FD_ISSET(cancelpipe, &r) || FD_ISSET(cancelpipe, &x)) \t// cancel?\n\t  { return(NULL); }\t\t\t\t\t\t// just exit\n        DEBUGMSG(\"CHILD THREAD: DATA IS READY\\n\");\n        NSPoint pt={0,0};\n\tNSAutoreleasePool *localPool = [[NSAutoreleasePool alloc] init]; \n        NSEvent *event = [NSEvent otherEventWithType:NSApplicationDefined location:pt \n\t\t\t\t       modifierFlags:0\n                                           timestamp:0\n                                        windowNumber:0 context:NULL \n\t\t\t\t\t     subtype:FLTKDataReadyEvent data1:0 data2:0];\n        [NSApp postEvent:event atStart:NO];\n\t[localPool release];\n        return(NULL);\t\t// done with thread\n      }\n    }\n  }\n}\n\n// START 'DATA READY' THREAD RUNNING, CREATE INTER-THREAD PIPE\nvoid DataReady::StartThread(void)\n{\n  CancelThread(DEBUGTEXT(\"STARTING NEW THREAD\\n\"));\n  DataLock();\n  /*LOCK*/  pipe(_cancelpipe);\t// pipe for sending cancel msg to thread\n  DataUnlock();\n  DEBUGMSG(\"*** START THREAD\\n\");\n  pthread_create(&tid, NULL, DataReadyThread, (void*)this);\n}\n\n// CANCEL 'DATA READY' THREAD, CLOSE PIPE\nvoid DataReady::CancelThread(const char *reason)\n{\n  if ( tid ) {\n    DEBUGMSG(\"*** CANCEL THREAD: \");\n    DEBUGMSG(reason);\n    if ( pthread_cancel(tid) == 0 ) {\t\t// cancel first\n      DataLock();\n      /*LOCK*/  write(_cancelpipe[1], \"x\", 1);\t// wake thread from select\n      DataUnlock();\n      pthread_join(tid, NULL);\t\t\t// wait for thread to finish\n    }\n    tid = 0;\n    DEBUGMSG(\"(JOINED) OK\\n\");\n  }\n  // Close pipe if open\n  DataLock();\n  /*LOCK*/  if ( _cancelpipe[0] ) { close(_cancelpipe[0]); _cancelpipe[0] = 0; }\n  /*LOCK*/  if ( _cancelpipe[1] ) { close(_cancelpipe[1]); _cancelpipe[1] = 0; }\n  DataUnlock();\n}\n\nvoid Fl::add_fd( int n, int events, void (*cb)(int, void*), void *v )\n{\n  dataready.AddFD(n, events, cb, v);\n}\n\nvoid Fl::add_fd(int fd, void (*cb)(int, void*), void* v)\n{\n  dataready.AddFD(fd, POLLIN, cb, v);\n}\n\nvoid Fl::remove_fd(int n, int events)\n{\n  dataready.RemoveFD(n, events);\n}\n\nvoid Fl::remove_fd(int n)\n{\n  dataready.RemoveFD(n, -1);\n}\n\n/*\n * Check if there is actually a message pending\n */\nint fl_ready()\n{\n  NSEvent *retval = [NSApp nextEventMatchingMask:NSAnyEventMask untilDate:[NSDate dateWithTimeIntervalSinceNow:0]\n\t\t\t\t    inMode:NSDefaultRunLoopMode dequeue:NO];\n  return retval != nil;\n}\n\n\nstatic void processFLTKEvent(void) {\n  fl_lock_function();\n  dataready.CancelThread(DEBUGTEXT(\"DATA READY EVENT\\n\"));\n  \n  // CHILD THREAD TELLS US DATA READY\n  //     Check to see what's ready, and invoke user's cb's\n  //\n  fd_set r,w,x;\n  switch(dataready.CheckData(r,w,x)) {\n    case 0:\t// NO DATA\n      break;\n    case -1:\t// ERROR\n      break;\n    default:\t// DATA READY\n      dataready.HandleData(r,w,x);\n      break;\n  }\n  fl_unlock_function();\n  return;\n}\n\n\n/*\n * break the current event loop\n */\nstatic void breakMacEventLoop()\n{  \n  NSPoint pt={0,0};\n  NSEvent *event = [NSEvent otherEventWithType:NSApplicationDefined location:pt \n\t\t\t\t modifierFlags:0\n                                     timestamp:0\n                                  windowNumber:0 context:NULL \n\t\t\t\t       subtype:FLTKTimerEvent data1:0 data2:0];\n  [NSApp postEvent:event atStart:NO];\n}\n\n//\n// MacOS X timers\n//\n\nstruct MacTimeout {\n  Fl_Timeout_Handler callback;\n  void* data;\n  CFRunLoopTimerRef timer;\n  char pending; \n  CFAbsoluteTime next_timeout; // scheduled time for this timer\n};\nstatic MacTimeout* mac_timers;\nstatic int mac_timer_alloc;\nstatic int mac_timer_used;\nstatic MacTimeout* current_timer;  // the timer that triggered its callback function, or NULL\n\nstatic void realloc_timers()\n{\n  if (mac_timer_alloc == 0) {\n    mac_timer_alloc = 8;\n    fl_open_display(); // needed because the timer creates an event\n  }\n  mac_timer_alloc *= 2;\n  MacTimeout* new_timers = new MacTimeout[mac_timer_alloc];\n  memset(new_timers, 0, sizeof(MacTimeout)*mac_timer_alloc);\n  memcpy(new_timers, mac_timers, sizeof(MacTimeout) * mac_timer_used);\n  MacTimeout* delete_me = mac_timers;\n  mac_timers = new_timers;\n  delete [] delete_me;\n}\n\nstatic void delete_timer(MacTimeout& t)\n{\n  if (t.timer) {\n    CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),\n\t\t      t.timer,\n\t\t      kCFRunLoopDefaultMode);\n    CFRelease(t.timer);\n    memset(&t, 0, sizeof(MacTimeout));\n    if (&t == current_timer) current_timer = NULL;\n  }\n}\n\nstatic void do_timer(CFRunLoopTimerRef timer, void* data)\n{\n  fl_lock_function();\n  current_timer = (MacTimeout*)data;\n  current_timer->pending = 0;\n  (current_timer->callback)(current_timer->data);\n  if (current_timer && current_timer->pending == 0)\n    delete_timer(*current_timer);\n  current_timer = NULL;\n\n  breakMacEventLoop();\n  fl_unlock_function();\n}\n\nvoid Fl::add_timeout(double time, Fl_Timeout_Handler cb, void* data)\n{\n  // check, if this timer slot exists already\n  for (int i = 0; i < mac_timer_used; ++i) {\n    MacTimeout& t = mac_timers[i];\n    // if so, simply change the fire interval\n    if (t.callback == cb  &&  t.data == data) {\n      t.next_timeout = CFAbsoluteTimeGetCurrent() + time;\n      CFRunLoopTimerSetNextFireDate(t.timer, t.next_timeout );\n      t.pending = 1;\n      return;\n    }\n  }\n  // no existing timer to use. Create a new one:\n  int timer_id = -1;\n  // find an empty slot in the timer array\n  for (int i = 0; i < mac_timer_used; ++i) {\n    if ( !mac_timers[i].timer ) {\n      timer_id = i;\n      break;\n    }\n  }\n  // if there was no empty slot, append a new timer\n  if (timer_id == -1) {\n    // make space if needed\n    if (mac_timer_used == mac_timer_alloc) {\n      realloc_timers();\n    }\n    timer_id = mac_timer_used++;\n  }\n  // now install a brand new timer\n  MacTimeout& t = mac_timers[timer_id];\n  CFRunLoopTimerContext context = {0, &t, NULL,NULL,NULL};\n  CFRunLoopTimerRef timerRef = CFRunLoopTimerCreate(kCFAllocatorDefault, \n\t\t\t\t\t\t    CFAbsoluteTimeGetCurrent() + time,\n\t\t\t\t\t\t    1E30,  \n\t\t\t\t\t\t    0,\n\t\t\t\t\t\t    0,\n\t\t\t\t\t\t    do_timer,\n\t\t\t\t\t\t    &context\n\t\t\t\t\t\t    );\n  if (timerRef) {\n    CFRunLoopAddTimer(CFRunLoopGetCurrent(),\n\t\t      timerRef,\n\t\t      kCFRunLoopDefaultMode);\n    t.callback = cb;\n    t.data     = data;\n    t.timer    = timerRef;\n    t.pending  = 1;\n    t.next_timeout = CFRunLoopTimerGetNextFireDate(timerRef);\n  }\n}\n\nvoid Fl::repeat_timeout(double time, Fl_Timeout_Handler cb, void* data)\n{\n  if (current_timer) {\n    // k = how many times 'time' seconds after the last scheduled timeout until the future\n    double k = ceil( (CFAbsoluteTimeGetCurrent() - current_timer->next_timeout) / time);\n    if (k < 1) k = 1;\n    current_timer->next_timeout += k * time;\n    CFRunLoopTimerSetNextFireDate(current_timer->timer, current_timer->next_timeout );\n    current_timer->callback = cb;\n    current_timer->data = data;\n    current_timer->pending = 1;\n    return;\n  }\n  add_timeout(time, cb, data);\n}\n\nint Fl::has_timeout(Fl_Timeout_Handler cb, void* data)\n{\n  for (int i = 0; i < mac_timer_used; ++i) {\n    MacTimeout& t = mac_timers[i];\n    if (t.callback == cb  &&  t.data == data && t.pending) {\n      return 1;\n    }\n  }\n  return 0;\n}\n\nvoid Fl::remove_timeout(Fl_Timeout_Handler cb, void* data)\n{\n  for (int i = 0; i < mac_timer_used; ++i) {\n    MacTimeout& t = mac_timers[i];\n    if (t.callback == cb  && ( t.data == data || data == NULL)) {\n      delete_timer(t);\n    }\n  }\n}\n\n@interface FLWindow : NSWindow {\n  Fl_Window *w;\n  BOOL containsGLsubwindow;\n}\n- (FLWindow*)initWithFl_W:(Fl_Window *)flw \n\t      contentRect:(NSRect)rect \n\t\tstyleMask:(NSUInteger)windowStyle;\n- (Fl_Window *)getFl_Window;\n/* These two functions allow to check if a window contains OpenGL-subwindows.\n   This is useful only for Mac OS < 10.7 to repair a problem apparent with the \"cube\" test program:\n   if the cube window is moved around rapidly (with OS < 10.7), the GL pixels leak away from where they should be.\n   The repair is performed by [FLWindowDelegate windowDidMove:], only if OS < 10.7.\n */\n- (BOOL)containsGLsubwindow;\n- (void)containsGLsubwindow:(BOOL)contains;\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7\n- (NSPoint)convertBaseToScreen:(NSPoint)aPoint;\n#endif\n@end\n\n@implementation FLWindow\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7\n- (NSPoint)convertBaseToScreen:(NSPoint)aPoint\n{\n  if (fl_mac_os_version >= 100700) {\n    NSRect r = [self convertRectToScreen:NSMakeRect(aPoint.x, aPoint.y, 0, 0)];\n    return r.origin;\n    }\n  else {\n    // replaces return [super convertBaseToScreen:aPoint] that may trigger a compiler warning\n    typedef NSPoint (*convertIMP)(id, SEL, NSPoint);\n    convertIMP addr = (convertIMP)[NSWindow instanceMethodForSelector:@selector(convertBaseToScreen:)];\n    return addr(self, @selector(convertBaseToScreen:), aPoint);\n    }\n}\n#endif\n\n- (FLWindow*)initWithFl_W:(Fl_Window *)flw \n\t      contentRect:(NSRect)rect \n\t\tstyleMask:(NSUInteger)windowStyle \n{\n  self = [super initWithContentRect:rect styleMask:windowStyle backing:NSBackingStoreBuffered defer:NO];\n  if (self) {\n    w = flw;\n    containsGLsubwindow = NO;\n    if (fl_mac_os_version >= 100700) {\n      // replaces [self setRestorable:NO] that may trigger a compiler warning\n      typedef void (*setIMP)(id, SEL, BOOL);\n      setIMP addr = (setIMP)[self methodForSelector:@selector(setRestorable:)];\n      addr(self, @selector(setRestorable:), NO);\n      }\n  }\n  return self;\n}\n- (Fl_Window *)getFl_Window;\n{\n  return w;\n}\n- (BOOL)containsGLsubwindow\n{\n  return containsGLsubwindow;\n}\n- (void)containsGLsubwindow:(BOOL)contains\n{\n  containsGLsubwindow = contains;\n}\n\n- (BOOL)canBecomeKeyWindow\n{\n  if (Fl::modal_ && (Fl::modal_ != w))\n    return NO;\t// prevent the caption to be redrawn as active on click\n\t\t//  when another modal window is currently the key win\n\n  return !(w->tooltip_window() || w->menu_window());\n}\n\n- (BOOL)canBecomeMainWindow\n{\n  if (Fl::modal_ && (Fl::modal_ != w))\n    return NO;\t// prevent the caption to be redrawn as active on click\n\t\t//  when another modal window is currently the key win\n\n  return !(w->tooltip_window() || w->menu_window());\n}\n\n@end\n\n@interface FLApplication : NSObject\n{\n}\n+ (void)sendEvent:(NSEvent *)theEvent;\n@end\n\n/*\n * This function is the central event handler.\n * It reads events from the event queue using the given maximum time\n * Funny enough, it returns the same time that it got as the argument. \n */\nstatic double do_queued_events( double time = 0.0 ) \n{\n  got_events = 0;\n  \n  // Check for re-entrant condition\n  if ( dataready.IsThreadRunning() ) {\n    dataready.CancelThread(DEBUGTEXT(\"AVOID REENTRY\\n\"));\n  }\n  \n  // Start thread to watch for data ready\n  if ( dataready.GetNfds() ) {\n    dataready.StartThread();\n  }\n  \n  fl_unlock_function();\n  NSEvent *event = [NSApp nextEventMatchingMask:NSAnyEventMask \n                                      untilDate:[NSDate dateWithTimeIntervalSinceNow:time] \n                                         inMode:NSDefaultRunLoopMode dequeue:YES];  \n  if (event != nil) {\n    got_events = 1;\n    [FLApplication sendEvent:event]; // will then call [NSApplication sendevent:]\n  }\n  fl_lock_function();\n  \n#if CONSOLIDATE_MOTION\n  if (send_motion && send_motion == fl_xmousewin) {\n    send_motion = 0;\n    Fl::handle(FL_MOVE, fl_xmousewin);\n  }\n#endif\n  \n  return time;\n}\n\n\n/*\n * This public function handles all events. It wait a maximum of \n * 'time' seconds for an event. This version returns 1 if events\n * other than the timeout timer were processed.\n *\n * \\todo there is no socket handling in this code whatsoever\n */\nint fl_wait( double time ) \n{\n  do_queued_events( time );\n  return (got_events);\n}\n\ndouble fl_mac_flush_and_wait(double time_to_wait) {\n  static int in_idle = 0;\n  NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n  if (Fl::idle) {\n    if (!in_idle) {\n      in_idle = 1;\n      Fl::idle();\n      in_idle = 0;\n    }\n    // the idle function may turn off idle, we can then wait:\n    if (Fl::idle) time_to_wait = 0.0;\n  }\n  Fl::flush();\n  if (Fl::idle && !in_idle) // 'idle' may have been set within flush()\n    time_to_wait = 0.0;\n  double retval = fl_wait(time_to_wait);\n  if (fl_gc) {\n    CGContextFlush(fl_gc);\n    fl_gc = 0;\n    }  \n  [pool release];\n  return retval;\n}\n\n\nstatic NSInteger max_normal_window_level(void)\n{\n  Fl_X *x;\n  NSInteger max_level;\n\n  max_level = 0;\n\n  for (x = Fl_X::first;x;x = x->next) {\n    NSInteger level;\n    FLWindow *cw = x->xid;\n    Fl_Window *win = x->w;\n    if (!win || !cw || ![cw isVisible])\n      continue;\n    if (win->modal() || win->non_modal())\n      continue;\n    level = [cw level];\n    if (level >= max_level)\n      max_level = level;\n  }\n\n  return max_level;\n}\n\n// appropriate window level for modal windows\nstatic NSInteger modal_window_level(void)\n{\n  NSInteger level;\n\n  level = max_normal_window_level();\n  if (level < NSModalPanelWindowLevel)\n    return NSModalPanelWindowLevel;\n\n  // Need some room for non-modal windows\n  level += 2;\n\n  // We cannot exceed this\n  if (level > CGShieldingWindowLevel())\n    return CGShieldingWindowLevel();\n\n  return level;\n}\n\n// appropriate window level for non-modal windows\nstatic NSInteger non_modal_window_level(void)\n{\n  NSInteger level;\n\n  level = max_normal_window_level();\n  if (level < NSFloatingWindowLevel)\n    return NSFloatingWindowLevel;\n\n  level += 1;\n\n  if (level > CGShieldingWindowLevel())\n    return CGShieldingWindowLevel();\n\n  return level;\n}\n\n// makes sure modal and non-modal windows stay on top\nstatic void fixup_window_levels(void)\n{\n  NSInteger modal_level, non_modal_level;\n\n  Fl_X *x;\n  FLWindow *prev_modal, *prev_non_modal;\n\n  modal_level = modal_window_level();\n  non_modal_level = non_modal_window_level();\n\n  prev_modal = NULL;\n  prev_non_modal = NULL;\n\n  for (x = Fl_X::first;x;x = x->next) {\n    FLWindow *cw = x->xid;\n    Fl_Window *win = x->w;\n    if (!win || !cw || ![cw isVisible])\n      continue;\n    if (win->modal()) {\n      if ([cw level] != modal_level) {\n        [cw setLevel:modal_level];\n        // changing level puts then in front, so make sure the\n        // stacking isn't messed up\n        if (prev_modal != NULL)\n          [cw orderWindow:NSWindowBelow\n              relativeTo:[prev_modal windowNumber]];\n      }\n      prev_modal = cw;\n    } else if (win->non_modal()) {\n      if ([cw level] != non_modal_level) {\n        [cw setLevel:non_modal_level];\n        if (prev_non_modal != NULL)\n          [cw orderWindow:NSWindowBelow\n              relativeTo:[prev_non_modal windowNumber]];\n      }\n      prev_non_modal = cw;\n    }\n  }\n}\n\n\n// updates Fl::e_x, Fl::e_y, Fl::e_x_root, and Fl::e_y_root\nstatic void update_e_xy_and_e_xy_root(NSWindow *nsw)\n{\n  NSPoint pt;\n  pt = [nsw mouseLocationOutsideOfEventStream];\n  Fl::e_x = int(pt.x);\n  Fl::e_y = int([[nsw contentView] frame].size.height - pt.y);\n  pt = [NSEvent mouseLocation];\n  Fl::e_x_root = int(pt.x);\n  Fl::e_y_root = int(main_screen_height - pt.y);\n}\n\n/*\n * Cocoa Mousewheel handler\n */\nstatic void cocoaMouseWheelHandler(NSEvent *theEvent)\n{\n  // Handle the new \"MightyMouse\" mouse wheel events. Please, someone explain\n  // to me why Apple changed the API on this even though the current API\n  // supports two wheels just fine. Matthias,\n  fl_lock_function();\n  \n  Fl_Window *window = (Fl_Window*)[(FLWindow*)[theEvent window] getFl_Window];\n  if ( !window->shown() ) {\n    fl_unlock_function();\n    return;\n  }\n  Fl::first_window(window);\n  \n  // Under OSX, single mousewheel increments are 0.1,\n  // so make sure they show up as at least 1..\n  //\n  float dx = [theEvent deltaX]; if ( fabs(dx) < 1.0 ) dx = (dx > 0) ? 1.0 : -1.0;\n  float dy = [theEvent deltaY]; if ( fabs(dy) < 1.0 ) dy = (dy > 0) ? 1.0 : -1.0;\n  if ([theEvent deltaX] != 0) {\n    Fl::e_dx = (int)-dx;\n    Fl::e_dy = 0;\n    if ( Fl::e_dx) Fl::handle( FL_MOUSEWHEEL, window );\n  } else if ([theEvent deltaY] != 0) {\n    Fl::e_dx = 0;\n    Fl::e_dy = (int)-dy;\n    if ( Fl::e_dy) Fl::handle( FL_MOUSEWHEEL, window );\n  } else {\n    fl_unlock_function();\n    return;\n  }\n  \n  fl_unlock_function();\n  \n  //  return noErr;\n}\n\n/*\n * Cocoa Mouse Button Handler\n */\nstatic void cocoaMouseHandler(NSEvent *theEvent)\n{\n  static int keysym[] = { 0, FL_Button+1, FL_Button+3, FL_Button+2 };\n  static int px, py;\n  static char suppressed = 0;\n  \n  fl_lock_function();\n  \n  Fl_Window *window = (Fl_Window*)[(FLWindow*)[theEvent window] getFl_Window];\n  if ( !window->shown() ) {\n    fl_unlock_function();\n    return;\n  }\n  Fl_Window *first = Fl::first_window();\n  if (first != window && !(first->modal() || first->non_modal())) Fl::first_window(window);\n  NSPoint pos = [theEvent locationInWindow];\n  pos.y = window->h() - pos.y;\n  NSInteger btn = [theEvent buttonNumber]  + 1;\n  NSUInteger mods = [theEvent modifierFlags];  \n  int sendEvent = 0;\n  \n  NSEventType etype = [theEvent type];\n  if (etype == NSLeftMouseDown || etype == NSRightMouseDown || etype == NSOtherMouseDown) {\n    if (btn == 1) Fl::e_state |= FL_BUTTON1;\n    else if (btn == 3) Fl::e_state |= FL_BUTTON2;\n    else if (btn == 2) Fl::e_state |= FL_BUTTON3;\n  }\n  else if (etype == NSLeftMouseUp || etype == NSRightMouseUp || etype == NSOtherMouseUp) {\n    if (btn == 1) Fl::e_state &= ~FL_BUTTON1;\n    else if (btn == 3) Fl::e_state &= ~FL_BUTTON2;\n    else if (btn == 2) Fl::e_state &= ~FL_BUTTON3;\n    }\n    \n  switch ( etype ) {\n    case NSLeftMouseDown:\n    case NSRightMouseDown:\n    case NSOtherMouseDown:\n      suppressed = 0;\n      sendEvent = FL_PUSH;\n      Fl::e_is_click = 1; \n      px = (int)pos.x; py = (int)pos.y;\n      if ([theEvent clickCount] > 1) \n        Fl::e_clicks++;\n      else\n        Fl::e_clicks = 0;\n      // fall through\n    case NSLeftMouseUp:\n    case NSRightMouseUp:\n    case NSOtherMouseUp:\n      if (suppressed) {\n        suppressed = 0;\n        break;\n      }\n      if ( !window ) break;\n      if ( !sendEvent ) {\n        sendEvent = FL_RELEASE; \n      }\n      Fl::e_keysym = keysym[ btn ];\n      // fall through\n    case NSMouseMoved:\n      suppressed = 0;\n      if ( !sendEvent ) { \n        sendEvent = FL_MOVE; \n      }\n      // fall through\n    case NSLeftMouseDragged:\n    case NSRightMouseDragged:\n    case NSOtherMouseDragged: {\n      if (suppressed) break;\n      if ( !sendEvent ) {\n        sendEvent = FL_MOVE; // Fl::handle will convert into FL_DRAG\n        if (fabs(pos.x-px)>5 || fabs(pos.y-py)>5) \n          Fl::e_is_click = 0;\n      }\n      mods_to_e_state( mods );\n      update_e_xy_and_e_xy_root([theEvent window]);\n      Fl::handle( sendEvent, window );\n      }\n      break;\n    default:\n      break;\n  }\n  \n  fl_unlock_function();\n  \n  return;\n}\n\n@interface FLTextView : NSTextView // this subclass is only needed under OS X < 10.6 \n{\n  BOOL isActive;\n}\n- (void)insertText:(id)aString;\n- (void)doCommandBySelector:(SEL)aSelector;\n- (void)setActive:(BOOL)a;\n@end\n@implementation FLTextView\n- (void)insertText:(id)aString\n{\n  if (isActive) [[[NSApp keyWindow] contentView] insertText:aString];\n}\n- (void)doCommandBySelector:(SEL)aSelector\n{\n  [[[NSApp keyWindow] contentView] doCommandBySelector:aSelector];\n}\n- (void)setActive:(BOOL)a\n{\n  isActive = a;\n}\n@end\n\n\n@interface FLWindowDelegate : NSObject \n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6\n<NSWindowDelegate>\n#endif\n+ (FLWindowDelegate*)createOnce;\n- (void)windowDidMove:(NSNotification *)notif;\n- (void)windowDidResize:(NSNotification *)notif;\n- (void)windowDidResignKey:(NSNotification *)notif;\n- (void)windowDidBecomeKey:(NSNotification *)notif;\n- (void)windowDidBecomeMain:(NSNotification *)notif;\n- (void)windowDidDeminiaturize:(NSNotification *)notif;\n- (void)windowDidMiniaturize:(NSNotification *)notif;\n- (BOOL)windowShouldClose:(id)fl;\n- (id)windowWillReturnFieldEditor:(NSWindow *)sender toObject:(id)client;\n- (void)anyWindowWillClose:(NSNotification *)notif;\n@end\n@implementation FLWindowDelegate\n+ (FLWindowDelegate*)createOnce\n{\n  static FLWindowDelegate* delegate = nil;\n  if (!delegate) {\n    delegate = [[FLWindowDelegate alloc] init];\n    }\n  return delegate;\n}\n- (void)windowDidMove:(NSNotification *)notif\n{\n  fl_lock_function();\n  FLWindow *nsw = (FLWindow*)[notif object];\n  Fl_Window *window = [nsw getFl_Window];\n  NSPoint pt, pt2; \n  pt.x = 0;\n  pt.y = [[nsw contentView] frame].size.height;\n  pt2 = [nsw convertBaseToScreen:pt];\n  update_e_xy_and_e_xy_root(nsw);\n  resize_from_system = window;\n  window->position((int)pt2.x, (int)(main_screen_height - pt2.y));\n  if ([nsw containsGLsubwindow] && fl_mac_os_version < 100700) {\n    [nsw display];// with OS < 10.7, redraw window after moving if it contains OpenGL subwindows\n  }\n  fl_unlock_function();\n}\n- (void)windowDidResize:(NSNotification *)notif\n{\n  fl_lock_function();\n  FLWindow *nsw = (FLWindow*)[notif object];\n  Fl_Window *window = [nsw getFl_Window];\n  NSRect r = [[nsw contentView] frame];\n  NSPoint pt, pt2; \n  pt.x = 0;\n  pt.y = [[nsw contentView] frame].size.height;\n  pt2 = [nsw convertBaseToScreen:pt];\n  resize_from_system = window;\n  update_e_xy_and_e_xy_root(nsw);\n  window->resize((int)pt2.x, \n                 (int)(main_screen_height - pt2.y),\n\t\t (int)r.size.width,\n\t\t (int)r.size.height);\n  fl_unlock_function();\n}\n- (void)windowDidResignKey:(NSNotification *)notif\n{\n  fl_lock_function();\n  FLWindow *nsw = (FLWindow*)[notif object];\n  Fl_Window *window = [nsw getFl_Window];\n  /* Fullscreen windows obscure all other windows so we need to return\n   to a \"normal\" level when the user switches to another window */\n  if (window->fullscreen_active()) {\n    [nsw setLevel:NSNormalWindowLevel];\n    fixup_window_levels();\n  }\n  Fl::handle( FL_UNFOCUS, window);\n  fl_unlock_function();\n}\n- (void)windowDidBecomeKey:(NSNotification *)notif\n{\n  fl_lock_function();\n  FLWindow *nsw = (FLWindow*)[notif object];\n  Fl_Window *w = [nsw getFl_Window];\n  /* Restore previous fullscreen level */\n  if (w->fullscreen_active()) {\n    [nsw setLevel:NSStatusWindowLevel];\n    fixup_window_levels();\n  }\n  if ( w->border() || (!w->modal() && !w->tooltip_window()) ) Fl::handle( FL_FOCUS, w);\n  fl_unlock_function();\n}\n- (void)windowDidBecomeMain:(NSNotification *)notif\n{\n  fl_lock_function();\n  FLWindow *nsw = (FLWindow*)[notif object];\n  Fl_Window *window = [nsw getFl_Window];\n  Fl::first_window(window);\n  update_e_xy_and_e_xy_root(nsw);\n  fl_unlock_function();\n}\n- (void)windowDidDeminiaturize:(NSNotification *)notif\n{\n  fl_lock_function();\n  FLWindow *nsw = (FLWindow*)[notif object];\n  Fl_Window *window = [nsw getFl_Window];\n  Fl::handle(FL_SHOW, window);\n  update_e_xy_and_e_xy_root(nsw);\n  fl_unlock_function();\n}\n- (void)windowDidMiniaturize:(NSNotification *)notif\n{\n  fl_lock_function();\n  FLWindow *nsw = (FLWindow*)[notif object];\n  Fl_Window *window = [nsw getFl_Window];\n  Fl::handle(FL_HIDE, window);\n  fl_unlock_function();\n}\n- (BOOL)windowShouldClose:(id)fl\n{\n  fl_lock_function();\n  Fl::handle( FL_CLOSE, [(FLWindow *)fl getFl_Window] ); // this might or might not close the window\n  fl_unlock_function();\n  // the system doesn't need to send [fl close] because FLTK does it when needed\n  return NO; \n}\n- (id)windowWillReturnFieldEditor:(NSWindow *)sender toObject:(id)client\n{\n  if (fl_mac_os_version < 100600) {\n    static FLTextView *view = nil;\n    if (!view) {\n      NSRect rect={{0,0},{20,20}};\n      view = [[FLTextView alloc] initWithFrame:rect];\n    }\n    return view;\n  }\n  return nil;\n}\n- (void)anyWindowWillClose:(NSNotification *)notif\n{\n  fl_lock_function();\n  if ([[notif object] isKeyWindow]) {\n    // If the closing window is the key window,\n    // find a bordered top-level window to become the new key window\n    Fl_Window *w = Fl::first_window();\n    while (w && (w->parent() || !w->border() || !w->visible())) {\n      w = Fl::next_window(w);\n    }\n    if (w) {\n      [Fl_X::i(w)->xid makeKeyWindow];\n    }\n  }\n  fl_unlock_function();\n}\n@end\n\n@interface FLAppDelegate : NSObject \n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6\n<NSApplicationDelegate>\n#endif\n{\n  void (*open_cb)(const char*);\n  TSMDocumentID currentDoc;\n}\n- (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication*)sender;\n- (void)applicationDidBecomeActive:(NSNotification *)notify;\n- (void)applicationDidChangeScreenParameters:(NSNotification *)aNotification;\n- (void)applicationDidUpdate:(NSNotification *)aNotification;\n- (void)applicationWillResignActive:(NSNotification *)notify;\n- (void)applicationWillHide:(NSNotification *)notify;\n- (void)applicationWillUnhide:(NSNotification *)notify;\n- (BOOL)application:(NSApplication *)theApplication openFile:(NSString *)filename;\n- (void)open_cb:(void (*)(const char*))cb;\n@end\n@implementation FLAppDelegate\n- (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication*)sender\n{\n  fl_lock_function();\n  NSApplicationTerminateReply reply = NSTerminateNow;\n  while ( Fl_X::first ) {\n    Fl_X *x = Fl_X::first;\n    Fl::handle( FL_CLOSE, x->w );\n    Fl::do_widget_deletion();\n    if ( Fl_X::first == x ) {\n      reply = NSTerminateCancel; // FLTK has not closed all windows, so we return to the main program now\n      break;\n    }\n  }\n  fl_unlock_function();\n  return reply;\n}\n- (void)applicationDidBecomeActive:(NSNotification *)notify\n{\n  fl_lock_function();\n\n  // update clipboard status\n  clipboard_check();\n\n  /**\n   * Cocoa organizes the Z depth of windows on a global priority. FLTK however\n   * expects the window manager to organize Z level by application. The trickery\n   * below will change Z order during activation and deactivation.\n   */\n  fixup_window_levels();\n\n  fl_unlock_function();\n}\n- (void)applicationDidChangeScreenParameters:(NSNotification *)unused\n{ // react to changes in screen numbers and positions\n  fl_lock_function();\n  main_screen_height = [[[NSScreen screens] objectAtIndex:0] frame].size.height;\n  Fl::call_screen_init();\n  // FLTK windows have already been notified they were moved,\n  // but they had the old main_screen_height, so they must be notified again.\n  NSArray *windows = [NSApp windows];\n  int count = [windows count];\n  for (int i = 0; i < count; i++) {\n    NSWindow *win = [windows objectAtIndex:i];\n    if ([win isKindOfClass:[FLWindow class]]) {\n      [[NSNotificationCenter defaultCenter] postNotificationName:NSWindowDidMoveNotification object:win];\n      }\n    }\n  Fl::handle(FL_SCREEN_CONFIGURATION_CHANGED, NULL);\n  fl_unlock_function();\n}\n- (void)applicationDidUpdate:(NSNotification *)aNotification\n{\n  if ((fl_mac_os_version >= 100500) && (im_enabled != -1) &&\n      (TSMGetActiveDocument != NULL)) {\n    TSMDocumentID newDoc;\n    // It is extremely unclear when Cocoa decides to create/update\n    // the input context, but debugging reveals that it is done\n    // by NSApplication:updateWindows. So check if the input context\n    // has shifted after each such run so that we can update our\n    // input methods status.\n    newDoc = TSMGetActiveDocument();\n    if (newDoc != currentDoc) {\n        im_update();\n        currentDoc = newDoc;\n    }\n  }\n}\n- (void)applicationWillResignActive:(NSNotification *)notify\n{\n  fl_lock_function();\n  Fl_X *x;\n  FLWindow *top = 0;\n  // sort in all regular windows\n  for (x = Fl_X::first;x;x = x->next) {\n    FLWindow *cw = x->xid;\n    Fl_Window *win = x->w;\n    if (win && cw) {\n      if (win->modal()) {\n      } else if (win->non_modal()) {\n      } else {\n        if (!top) top = cw;\n      }\n    }\n  }\n  // now sort in all modals\n  for (x = Fl_X::first;x;x = x->next) {\n    FLWindow *cw = x->xid;\n    Fl_Window *win = x->w;\n    if (win && cw && [cw isVisible]) {\n      if (win->modal()) {\n        [cw setLevel:NSNormalWindowLevel];\n        if (top) [cw orderWindow:NSWindowAbove relativeTo:[top windowNumber]];\n      }\n    }\n  }\n  // finally all non-modals\n  for (x = Fl_X::first;x;x = x->next) {\n    FLWindow *cw = x->xid;\n    Fl_Window *win = x->w;\n    if (win && cw && [cw isVisible]) {\n      if (win->non_modal()) {\n        [cw setLevel:NSNormalWindowLevel];\n        if (top) [cw orderWindow:NSWindowAbove relativeTo:[top windowNumber]];\n      }\n    }\n  }\n  fl_unlock_function();\n}\n- (void)applicationWillHide:(NSNotification *)notify\n{\n  fl_lock_function();\n  Fl_X *x;\n  for (x = Fl_X::first;x;x = x->next) {\n    Fl_Window *window = x->w;\n    if ( !window->parent() ) Fl::handle( FL_HIDE, window);\n    }\n  fl_unlock_function();\n}\n- (void)applicationWillUnhide:(NSNotification *)notify\n{\n  fl_lock_function();\n  Fl_X *x;\n  for (x = Fl_X::first;x;x = x->next) {\n    Fl_Window *w = x->w;\n    if ( !w->parent() && ![x->xid isMiniaturized]) {\n      Fl::handle( FL_SHOW, w);\n      }\n  }\n  fl_unlock_function();\n}\n- (BOOL)application:(NSApplication *)theApplication openFile:(NSString *)filename\n{\n  // without the next statement, the opening of the 1st window is delayed by several seconds\n  // under Mac OS \u2265 10.8 when a file is dragged on the application icon\n  [[theApplication mainWindow] orderFront:self];\n  if (open_cb) {\n    fl_lock_function();\n    (*open_cb)([filename UTF8String]);\n    fl_unlock_function();\n    return YES;\n  }\n  return NO;\n}\n- (void)open_cb:(void (*)(const char*))cb\n{\n  open_cb = cb;\n}\n@end\n\n/*\n * Install an open documents event handler...\n */\nvoid fl_open_callback(void (*cb)(const char *)) {\n  fl_open_display();\n  [(FLAppDelegate*)[NSApp delegate] open_cb:cb];\n}\n\n@implementation FLApplication\n+ (void)sendEvent:(NSEvent *)theEvent\n{\n  if (fl_send_system_handlers(theEvent))\n    return;\n\n  NSEventType type = [theEvent type];  \n  if (type == NSLeftMouseDown) {\n    fl_lock_function();\n    Fl_Window *grab = Fl::grab();\n    if (grab) {\n      FLWindow *win = (FLWindow *)[theEvent window];\n      if ( [win isKindOfClass:[FLWindow class]] && grab != [win getFl_Window]) {\n\t// a click event out of a menu window, so we should close this menu\n\t// done here to catch also clicks on window title bar/resize box \n\tcocoaMouseHandler(theEvent);\n      }\n    }\n    fl_unlock_function();\n  } else if (type == NSApplicationDefined) {\n    if ([theEvent subtype] == FLTKDataReadyEvent) {\n      processFLTKEvent();\n    }\n    return;\n  } else if (type == NSKeyUp) {\n    // The default sendEvent turns key downs into performKeyEquivalent when\n    // modifiers are down, but swallows the key up if the modifiers include\n    // command.  This one makes all modifiers consistent by always sending key ups.\n    // FLView treats performKeyEquivalent to keyDown, but performKeyEquivalent is\n    // still needed for the system menu.\n    [[NSApp keyWindow] sendEvent:theEvent];\n    return;\n    }\n  [NSApp sendEvent:theEvent]; \n}\n@end\n\n/* Prototype of undocumented function needed to support Mac OS 10.2 or earlier\n extern \"C\" {\n  OSErr CPSEnableForegroundOperation(ProcessSerialNumber*, UInt32, UInt32, UInt32, UInt32);\n}\n*/\n\nvoid fl_open_display() {\n  static char beenHereDoneThat = 0;\n  if ( !beenHereDoneThat ) {\n    beenHereDoneThat = 1;\n\n    TSMGetActiveDocument = (TSMGetActiveDocument_type)Fl_X::get_carbon_function(\"TSMGetActiveDocument\");\n    TSMSetDocumentProperty = (TSMSetDocumentProperty_type)Fl_X::get_carbon_function(\"TSMSetDocumentProperty\");\n    TSMRemoveDocumentProperty = (TSMRemoveDocumentProperty_type)Fl_X::get_carbon_function(\"TSMRemoveDocumentProperty\");\n    TISCreateASCIICapableInputSourceList = (TISCreateASCIICapableInputSourceList_type)Fl_X::get_carbon_function(\"TISCreateASCIICapableInputSourceList\");\n\n    KeyScript = (KeyScript_type)Fl_X::get_carbon_function(\"KeyScript\");\n    \n    BOOL need_new_nsapp = (NSApp == nil);\n    if (need_new_nsapp) [NSApplication sharedApplication];\n    NSAutoreleasePool *localPool;\n    localPool = [[NSAutoreleasePool alloc] init]; // never released\n    [(NSApplication*)NSApp setDelegate:[[FLAppDelegate alloc] init]];\n    if (need_new_nsapp) [NSApp finishLaunching];\n\n    // empty the event queue but keep system events for drag&drop of files at launch\n    NSEvent *ign_event;\n    do ign_event = [NSApp nextEventMatchingMask:(NSAnyEventMask & ~NSSystemDefinedMask)\n\t\t\t\t\tuntilDate:[NSDate dateWithTimeIntervalSinceNow:0] \n\t\t\t\t\t   inMode:NSDefaultRunLoopMode \n\t\t\t\t\t  dequeue:YES];\n    while (ign_event);\n    \n    // bring the application into foreground without a 'CARB' resource\n    bool i_am_in_front;\n    ProcessSerialNumber cur_psn = { 0, kCurrentProcess };\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6\n    if (fl_mac_os_version >= 100600) {\n      i_am_in_front = [[NSRunningApplication currentApplication] isActive];\n    }\n    else\n#endif\n    {\n      Boolean same_psn;\n      ProcessSerialNumber front_psn;\n      //avoid compilation warnings triggered by GetFrontProcess() and SameProcess()\n      void* h = dlopen(NULL, RTLD_LAZY);\n      typedef OSErr (*GetFrontProcess_type)(ProcessSerialNumber*);\n      GetFrontProcess_type  GetFrontProcess_ = (GetFrontProcess_type)dlsym(h, \"GetFrontProcess\");\n      typedef OSErr (*SameProcess_type)(ProcessSerialNumber*, ProcessSerialNumber*, Boolean*);\n      SameProcess_type  SameProcess_ = (SameProcess_type)dlsym(h, \"SameProcess\");\n      i_am_in_front = (!GetFrontProcess_( &front_psn ) &&\n                       !SameProcess_( &front_psn, &cur_psn, &same_psn ) && same_psn );\n    }\n    if (!i_am_in_front) {\n      // only transform the application type for unbundled apps\n      NSBundle *bundle = [NSBundle mainBundle];\n      if (bundle) {\n        NSString *exe = [[bundle executablePath] stringByStandardizingPath];\n        NSString *bpath = [bundle bundlePath];\n        NSString *exe_dir = [exe stringByDeletingLastPathComponent];\n        if ([bpath isEqualToString:exe] || [bpath isEqualToString:exe_dir]) bundle = nil;\n      }\n      \n      if ( !bundle ) {\n        TransformProcessType(&cur_psn, kProcessTransformToForegroundApplication); // needs Mac OS 10.3\n        /* support of Mac OS 10.2 or earlier used this undocumented call instead\n         err = CPSEnableForegroundOperation(&cur_psn, 0x03, 0x3C, 0x2C, 0x1103);\n         */\n        [NSApp activateIgnoringOtherApps:YES];\n      }\n    }\n    if (![NSApp servicesMenu]) createAppleMenu();\n    main_screen_height = [[[NSScreen screens] objectAtIndex:0] frame].size.height;\n    [[NSNotificationCenter defaultCenter] addObserver:[FLWindowDelegate createOnce] \n\t\t\t\t\t     selector:@selector(anyWindowWillClose:) \n\t\t\t\t\t\t name:NSWindowWillCloseNotification \n\t\t\t\t\t       object:nil];\n    // necessary for secondary pthreads to be allowed to use cocoa, \n    // especially to create an NSAutoreleasePool.\n    [NSThread detachNewThreadSelector:nil toTarget:nil withObject:nil];\n  }\n}\n\n\n/*\n * get rid of allocated resources\n */\nvoid fl_close_display() {\n}\n\n// Force a \"Roman\" or \"ASCII\" keyboard, which both the Mozilla and\n// Safari people seem to think implies turning off advanced IME stuff\n// (see nsTSMManager::SyncKeyScript in Mozilla and enableSecureTextInput\n// in Safari/Webcore). Should be good enough for us then...\n\nstatic void im_update(void) {\n  if (fl_mac_os_version >= 100500) {\n    TSMDocumentID doc;\n\n    if ((TSMGetActiveDocument == NULL) ||\n        (TSMSetDocumentProperty == NULL) ||\n        (TSMRemoveDocumentProperty == NULL) ||\n        (TISCreateASCIICapableInputSourceList == NULL))\n      return;\n\n    doc = TSMGetActiveDocument();\n\n    if (im_enabled)\n      TSMRemoveDocumentProperty(doc, kTSMDocumentEnabledInputSourcesPropertyTag);\n    else {\n      CFArrayRef inputSources;\n\n      inputSources = TISCreateASCIICapableInputSourceList();\n      TSMSetDocumentProperty(doc, kTSMDocumentEnabledInputSourcesPropertyTag,\n                             sizeof(CFArrayRef), &inputSources);\n      CFRelease(inputSources);\n    }\n  } else {\n    if (KeyScript == NULL)\n      return;\n\n    if (im_enabled)\n      KeyScript(smKeyEnableKybds);\n    else\n      KeyScript(smEnableRomanKybdsOnly);\n  }\n}\n\nvoid Fl::enable_im() {\n  fl_open_display();\n\n  im_enabled = 1;\n\n  if (fl_mac_os_version >= 100500)\n    [NSApp updateWindows];\n  else\n    im_update();\n}\n\nvoid Fl::disable_im() {\n  fl_open_display();\n\n  im_enabled = 0;\n\n  if (fl_mac_os_version >= 100500)\n    [NSApp updateWindows];\n  else\n    im_update();\n}\n\n\n// Gets the border sizes and the titlebar size\nstatic void get_window_frame_sizes(int &bx, int &by, int &bt) {\n  static bool first = true;\n  static int top, left, bottom;\n  if (first) {\n    first = false;\n    if (NSApp == nil) fl_open_display();\n    NSRect inside = { {20,20}, {100,100} };\n    NSRect outside = [NSWindow  frameRectForContentRect:inside styleMask:NSTitledWindowMask];\n    left = int(outside.origin.x - inside.origin.x);\n    bottom = int(outside.origin.y - inside.origin.y);\n    top = int(outside.size.height - inside.size.height) - bottom;\n    }\n  bx = left;\n  by = bottom;\n  bt = top;\n}\n\n/*\n * smallest x coordinate in screen space of work area of menubar-containing display\n */\nint Fl::x() {\n  return int([[[NSScreen screens] objectAtIndex:0] visibleFrame].origin.x);\n}\n\n\n/*\n * smallest y coordinate in screen space of work area of menubar-containing display\n */\nint Fl::y() {\n  fl_open_display();\n  NSRect visible = [[[NSScreen screens] objectAtIndex:0] visibleFrame];\n  return int(main_screen_height - (visible.origin.y + visible.size.height));\n}\n\n\n/*\n * width of work area of menubar-containing display\n */\nint Fl::w() {\n  return int([[[NSScreen screens] objectAtIndex:0] visibleFrame].size.width);\n}\n\n\n/*\n * height of work area of menubar-containing display\n */\nint Fl::h() {\n  return int([[[NSScreen screens] objectAtIndex:0] visibleFrame].size.height);\n}\n\n// computes the work area of the nth screen (screen #0 has the menubar)\nvoid Fl_X::screen_work_area(int &X, int &Y, int &W, int &H, int n)\n{\n  fl_open_display();\n  NSRect r = [[[NSScreen screens] objectAtIndex:n] visibleFrame];\n  X   = int(r.origin.x);\n  Y   = main_screen_height - int(r.origin.y + r.size.height);\n  W   = int(r.size.width);\n  H   = int(r.size.height);\n}\n\n/*\n * get the current mouse pointer world coordinates\n */\nvoid Fl::get_mouse(int &x, int &y) \n{\n  fl_open_display();\n  NSPoint pt = [NSEvent mouseLocation];\n  x = int(pt.x);\n  y = int(main_screen_height - pt.y);\n}\n\n\n/*\n * Gets called when a window is created, resized, or deminiaturized\n */    \nstatic void handleUpdateEvent( Fl_Window *window ) \n{\n  if ( !window ) return;\n  Fl_X *i = Fl_X::i( window );\n  i->wait_for_expose = 0;\n\n  if ( i->region ) {\n    XDestroyRegion(i->region);\n    i->region = 0;\n  }\n  \n  for ( Fl_X *cx = i->xidChildren; cx; cx = cx->xidNext ) {\n    if ( cx->region ) {\n      XDestroyRegion(cx->region);\n      cx->region = 0;\n    }\n    cx->w->clear_damage(FL_DAMAGE_ALL);\n    CGContextRef gc = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];\n    CGContextSaveGState(gc); // save original context\n    cx->flush();\n    CGContextRestoreGState(gc); // restore original context\n    cx->w->clear_damage();\n  }\n  window->clear_damage(FL_DAMAGE_ALL);\n  i->flush();\n  window->clear_damage();\n}     \n\n\nint Fl_X::fake_X_wm(const Fl_Window* w,int &X,int &Y, int &bt,int &bx, int &by) {\n  int W, H, xoff, yoff, dx, dy;\n  int ret = bx = by = bt = 0;\n  if (w->border() && !w->parent()) {\n    if (w->maxw != w->minw || w->maxh != w->minh) {\n      ret = 2;\n    } else {\n      ret = 1;\n    }\n    get_window_frame_sizes(bx, by, bt);\n  }\n  // The coordinates of the whole window, including non-client area\n  xoff = bx;\n  yoff = by + bt;\n  dx = 2*bx;\n  dy = 2*by + bt;\n  X = w->x()-xoff;\n  Y = w->y()-yoff;\n  W = w->w()+dx;\n  H = w->h()+dy;\n  \n  // Proceed to positioning the window fully inside the screen, if possible\n  \n  // let's get a little elaborate here. Mac OS X puts a lot of stuff on the desk\n  // that we want to avoid when positioning our window, namely the Dock and the\n  // top menu bar (and even more stuff in 10.4 Tiger). So we will go through the\n  // list of all available screens and find the one that this window is most\n  // likely to go to, and then reposition it to fit withing the 'good' area.\n  //  Rect r;\n  // find the screen, that the center of this window will fall into\n  int R = X+W, B = Y+H; // right and bottom\n  int cx = (X+R)/2, cy = (Y+B)/2; // center of window;\n  NSScreen *gd = NULL;\n  NSArray *a = [NSScreen screens]; int count = (int)[a count]; NSRect r; int i;\n  for( i = 0; i < count; i++) {\n    r = [[a objectAtIndex:i] frame];\n    r.origin.y = main_screen_height - (r.origin.y + r.size.height); // use FLTK's multiscreen coordinates\n    if (   cx >= r.origin.x && cx <= r.origin.x + r.size.width\n        && cy >= r.origin.y && cy <= r.origin.y + r.size.height)\n      break;\n  }\n  if (i < count) gd = [a objectAtIndex:i];\n  \n  // if the center doesn't fall on a screen, try the top left\n  if (!gd) {\n    for( i = 0; i < count; i++) {\n      r = [[a objectAtIndex:i] frame];\n      r.origin.y = main_screen_height - (r.origin.y + r.size.height); // use FLTK's multiscreen coordinates\n      if (    X >= r.origin.x && X <= r.origin.x + r.size.width\n          && Y >= r.origin.y  && Y <= r.origin.y + r.size.height)\n        break;\n    }\n    if (i < count) gd = [a objectAtIndex:i];\n  }\n  // if that doesn't fall on a screen, try the top right\n  if (!gd) {\n    for( i = 0; i < count; i++) {\n      r = [[a objectAtIndex:i] frame];\n      r.origin.y = main_screen_height - (r.origin.y + r.size.height); // use FLTK's multiscreen coordinates\n      if (    R >= r.origin.x && R <= r.origin.x + r.size.width\n          && Y >= r.origin.y  && Y <= r.origin.y + r.size.height)\n        break;\n    }\n    if (i < count) gd = [a objectAtIndex:i];\n  }\n  // if that doesn't fall on a screen, try the bottom left\n  if (!gd) {\n    for( i = 0; i < count; i++) {\n      r = [[a objectAtIndex:i] frame];\n      r.origin.y = main_screen_height - (r.origin.y + r.size.height); // use FLTK's multiscreen coordinates\n      if (    X >= r.origin.x && X <= r.origin.x + r.size.width\n          && Y+H >= r.origin.y  && Y+H <= r.origin.y + r.size.height)\n        break;\n    }\n    if (i < count) gd = [a objectAtIndex:i];\n  }\n  // last resort, try the bottom right\n  if (!gd) {\n    for( i = 0; i < count; i++) {\n      r = [[a objectAtIndex:i] frame];\n      r.origin.y = main_screen_height - (r.origin.y + r.size.height); // use FLTK's multiscreen coordinates\n      if (    R >= r.origin.x && R <= r.origin.x + r.size.width\n          && Y+H >= r.origin.y  && Y+H <= r.origin.y + r.size.height)\n        break;\n    }\n    if (i < count) gd = [a objectAtIndex:i];\n  }\n  // if we still have not found a screen, we will use the main\n  // screen, the one that has the application menu bar.\n  if (!gd) gd = [a objectAtIndex:0];\n  if (gd) {\n    r = [gd visibleFrame];\n    r.origin.y = main_screen_height - (r.origin.y + r.size.height); // use FLTK's multiscreen coordinates\n    if ( R > r.origin.x + r.size.width ) X -= int(R - (r.origin.x + r.size.width));\n    if ( B > r.size.height + r.origin.y ) Y -= int(B - (r.size.height + r.origin.y));\n    if ( X < r.origin.x ) X = int(r.origin.x);\n    if ( Y < r.origin.y ) Y = int(r.origin.y);\n  }\n  \n  // Return the client area's top left corner in (X,Y)\n  X+=xoff;\n  Y+=yoff;\n  \n  return ret;\n}\n\n\nFl_Window *fl_dnd_target_window = 0;\n\nstatic void  q_set_window_title(NSWindow *nsw, const char * name, const char *mininame) {\n  CFStringRef title = CFStringCreateWithCString(NULL, (name ? name : \"\"), kCFStringEncodingUTF8);\n  if(!title) { // fallback when name contains malformed UTF-8\n    int l = strlen(name);\n    unsigned short* utf16 = new unsigned short[l + 1];\n    l = fl_utf8toUtf16(name, l, utf16, l + 1);\n    title = CFStringCreateWithCharacters(NULL, utf16, l);\n    delete[] utf16;\n    }\n  [nsw setTitle:(NSString*)title];\n  CFRelease(title);\n  if (mininame && strlen(mininame)) {\n    CFStringRef minititle = CFStringCreateWithCString(NULL, mininame, kCFStringEncodingUTF8);\n    if (minititle) {\n      [nsw setMiniwindowTitle:(NSString*)minititle];\n      CFRelease(minititle);\n    }\n  }\n}\n\n/**                 How FLTK handles Mac OS text input\n \n Let myview be the instance of the FLView class that has the keyboard focus. FLView is an FLTK-defined NSView subclass\n that implements the NSTextInputClient protocol to properly handle text input. It also implements the old NSTextInput\n protocol to run with OS <= 10.4. The few NSTextInput protocol methods that differ in signature from the NSTextInputClient \n protocol transmit the received message to the corresponding NSTextInputClient method.\n\n Keyboard input sends keyDown: and performKeyEquivalent: messages to myview. The latter occurs for keys such as\n ForwardDelete, arrows and F1, and when the Ctrl or Cmd modifiers are used. Other key presses send keyDown: messages.\n The keyDown: method calls [[myview inputContext] handleEvent:theEvent] that triggers system \n processing of keyboard events. The performKeyEquivalent: method directly calls Fl::handle(FL_KEYBOARD, focus-window) \n when the Ctrl or Cmd modifiers are used. If not, it also calls [[myview inputContext] handleEvent:theEvent].\n The performKeyEquivalent: method returns YES when the keystroke has been handled and NO otherwise, which allows \n shortcuts of the system menu to be processed. Three sorts of messages are then sent back by the system to myview: \n doCommandBySelector:, setMarkedText: and insertText:. All 3 messages eventually produce Fl::handle(FL_KEYBOARD, win) calls.\n The doCommandBySelector: message allows to process events such as new-line, forward and backward delete, arrows, \n escape, tab, F1. The message setMarkedText: is sent when marked text, that is, temporary text that gets replaced later \n by some other text, is inserted. This happens when a dead key is pressed, and also \n when entering complex scripts (e.g., Chinese). Fl_X::next_marked_length gives the byte\n length of marked text before the FL_KEYBOARD event is processed. Fl::compose_state gives this length after this processing.\n Message insertText: is sent to enter text in the focused widget. If there's marked text, Fl::compose_state is > 0, and this\n marked text gets replaced by the inserted text. If there's no marked text, the new text is inserted at the insertion point. \n When the character palette is used to enter text, the system sends an insertText: message to myview. \n The in_key_event field of the FLView class allows to differentiate keyboard from palette inputs.\n \n During processing of the handleEvent message, inserted and marked strings are concatenated in a single string\n inserted in a single FL_KEYBOARD event after return from handleEvent. The need_handle member variable of FLView allows \n to determine when setMarkedText or insertText strings have been sent during handleEvent processing and must trigger \n an FL_KEYBOARD event. Concatenating two insertText operations or an insertText followed by a setMarkedText is possible. \n In contrast, setMarkedText followed by insertText or by another setMarkedText isn't correct if concatenated in a single \n string. Thus, in such case, the setMarkedText and the next operation produce each an FL_KEYBOARD event. \n \n OS >= 10.7 contains a feature where pressing and holding certain keys opens a menu window that shows a list \n of possible accented variants of this key. The selectedRange field of the FLView class and the selectedRange, insertText:\n and setMarkedText: methods of the NSTextInputClient protocol are used to support this feature.\n The notion of selected text (!= marked text) is monitored by the selectedRange field. \n The -(NSRange)[FLView selectedRange] method is used to control whether an FLTK widget opens accented character windows \n by returning .location = NSNotFound to disable that, or returning the value of the selectedRange field to enable the feature.\n When selectedRange.location >= 0, the value of selectedRange.length is meaningful. 0 means no text is currently selected, \n > 0 means this number of characters before the insertion point are selected. The insertText: method does\n selectedRange = NSMakeRange(100, 0); to indicate no text is selected. The setMarkedText: method does   \n selectedRange = NSMakeRange(100, newSelection.length); to indicate that this length of text is selected.\n\n With OS <= 10.5, the crucial call [[myview inputContext] handleEvent:theEvent] is not possible because neither the \n inputContext nor the handleEvent: methods are implemented. This call is re-written:\n    static SEL inputContextSEL = (fl_mac_os_version >= 100600 ? @selector(inputContext) : @selector(FLinputContext));\n    [[myview performSelector:inputContextSEL] handleEvent:theEvent];\n that replaces the 10.6 inputContext message by the FLinputContext message. This message and two FLTK-defined classes, \n FLTextInputContext and FLTextView, are used to emulate with OS <= 10.5 what's possible with OS >= 10.6. \n Method -(FLTextInputContext*)[FLView FLinputContext] returns an instance of class FLTextInputContext that possesses \n a handleEvent: method. FLView's FLinputContext method also calls [[self window] fieldEditor:YES forObject:nil] which \n returns the so-called view's \"field editor\". This editor is an instance of the FLTextView class allocated by the \n -(id)[FLWindowDelegate windowWillReturnFieldEditor: toObject:] method.\n The -(BOOL)[FLTextInputContext handleEvent:] method emulates the missing 10.6 -(BOOL)[NSTextInputContext handleEvent:]\n by sending the interpretKeyEvents: message to the FLTextView object. The system sends back doCommandBySelector: and\n insertText: messages to the FLTextView object that are transmitted unchanged to myview to be processed as with OS >= 10.6. \n The system also sends setMarkedText: messages directly to myview.\n   \n There is furthermore an oddity of dead key processing with OS <= 10.5. It occurs when a dead key followed by a non-accented  \n key are pressed. Say, for example, that keys '^' followed by 'p' are pressed on a French or German keyboard. Resulting \n messages are: [myview setMarkedText:@\"^\"], [myview insertText:@\"^\"], [myview insertText:@\"p\"], [FLTextView insertText:@\"^p\"]. \n The 2nd '^' replaces the marked 1st one, followed by p^p. The resulting text in the widget is \"^p^p\" instead of the \n desired \"^p\". To avoid that, the FLTextView object is deactivated by the insertText: message and reactivated after \n the handleEvent: message has been processed.\n\n NSEvent's during a character composition sequence:\n - keyDown with deadkey -> [[theEvent characters] length] is 0\n - keyUp -> [theEvent characters] contains the deadkey\n - keyDown with next key -> [theEvent characters] contains the composed character\n - keyUp -> [theEvent characters] contains the standard character\n */\n\nstatic void cocoaKeyboardHandler(NSEvent *theEvent)\n{\n  NSUInteger mods;\n  // get the modifiers\n  mods = [theEvent modifierFlags];\n  // get the key code\n  UInt32 keyCode = 0, maskedKeyCode = 0;\n  unsigned short sym = 0;\n  keyCode = [theEvent keyCode];\n  // extended keyboards can also send sequences on key-up to generate Kanji etc. codes.\n  // Some observed prefixes are 0x81 to 0x83, followed by an 8 bit keycode.\n  // In this mode, there seem to be no key-down codes\n  // printf(\"%08x %08x %08x\\n\", keyCode, mods, key);\n  maskedKeyCode = keyCode & 0x7f;\n  mods_to_e_state( mods ); // process modifier keys\n  sym = macKeyLookUp[maskedKeyCode];\n  if (sym < 0xff00) { // a \"simple\" key\n    // find the result of this key without modifier\n    NSString *sim = [theEvent charactersIgnoringModifiers];\n    UniChar one;\n    CFStringGetCharacters((CFStringRef)sim, CFRangeMake(0, 1), &one);\n    // charactersIgnoringModifiers doesn't ignore shift, remove it when it's on\n    if(one >= 'A' && one <= 'Z') one += 32;\n    if (one > 0 && one <= 0x7f && (sym<'0' || sym>'9') ) sym = one;\n  }\n  Fl::e_keysym = Fl::e_original_keysym = sym;\n  /*NSLog(@\"cocoaKeyboardHandler: keycode=%08x keysym=%08x mods=%08x symbol=%@ (%@)\",\n   keyCode, sym, mods, [theEvent characters], [theEvent charactersIgnoringModifiers]);*/\n  // If there is text associated with this key, it will be filled in later.\n  Fl::e_length = 0;\n  Fl::e_text = (char*)\"\";\n}\n\n@interface FLTextInputContext : NSObject { // \"emulates\" NSTextInputContext before OS 10.6\n@public\n  FLTextView *edit;\n}\n-(BOOL)handleEvent:(NSEvent*)theEvent;\n@end\n@implementation FLTextInputContext\n-(BOOL)handleEvent:(NSEvent*)theEvent {\n  [self->edit setActive:YES];\n  [self->edit interpretKeyEvents:[NSArray arrayWithObject:theEvent]];\n  [self->edit setActive:YES];\n  return YES;\n}\n@end\n\n@interface FLView : NSView <NSTextInput\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5\n, NSTextInputClient\n#endif\n> {\n  BOOL in_key_event; // YES means keypress is being processed by handleEvent\n  BOOL need_handle; // YES means Fl::handle(FL_KEYBOARD,) is needed after handleEvent processing\n  NSInteger identifier;\n  NSRange selectedRange;\n}\n+ (void)prepareEtext:(NSString*)aString;\n+ (void)concatEtext:(NSString*)aString;\n- (id)init;\n- (void)drawRect:(NSRect)rect;\n- (BOOL)acceptsFirstResponder;\n- (BOOL)acceptsFirstMouse:(NSEvent*)theEvent;\n- (void)resetCursorRects;\n- (BOOL)performKeyEquivalent:(NSEvent*)theEvent;\n- (void)mouseUp:(NSEvent *)theEvent;\n- (void)rightMouseUp:(NSEvent *)theEvent;\n- (void)otherMouseUp:(NSEvent *)theEvent;\n- (void)mouseDown:(NSEvent *)theEvent;\n- (void)rightMouseDown:(NSEvent *)theEvent;\n- (void)otherMouseDown:(NSEvent *)theEvent;\n- (void)mouseMoved:(NSEvent *)theEvent;\n- (void)mouseDragged:(NSEvent *)theEvent;\n- (void)rightMouseDragged:(NSEvent *)theEvent;\n- (void)otherMouseDragged:(NSEvent *)theEvent;\n- (void)scrollWheel:(NSEvent *)theEvent;\n- (void)keyDown:(NSEvent *)theEvent;\n- (void)keyUp:(NSEvent *)theEvent;\n- (void)flagsChanged:(NSEvent *)theEvent;\n- (NSDragOperation)draggingEntered:(id < NSDraggingInfo >)sender;\n- (NSDragOperation)draggingUpdated:(id < NSDraggingInfo >)sender;\n- (BOOL)performDragOperation:(id <NSDraggingInfo>)sender;\n- (void)draggingExited:(id < NSDraggingInfo >)sender;\n- (NSDragOperation)draggingSourceOperationMaskForLocal:(BOOL)isLocal;\n- (FLTextInputContext*)FLinputContext;\n#if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_5\n- (void)insertText:(id)aString replacementRange:(NSRange)replacementRange;\n- (void)setMarkedText:(id)aString selectedRange:(NSRange)newSelection replacementRange:(NSRange)replacementRange;\n- (NSAttributedString *)attributedSubstringForProposedRange:(NSRange)aRange actualRange:(NSRangePointer)actualRange;\n- (NSRect)firstRectForCharacterRange:(NSRange)aRange actualRange:(NSRangePointer)actualRange;\n- (NSInteger)windowLevel;\n#endif\n@end\n\n@implementation FLView\n- (id)init\n{\n  static NSInteger counter = 0;\n  self = [super init];\n  if (self) {\n    in_key_event = NO;\n    identifier = ++counter;\n    }\n  return self;\n}\n- (void)drawRect:(NSRect)rect\n{\n  fl_lock_function();\n  through_drawRect = YES;\n  FLWindow *cw = (FLWindow*)[self window];\n  Fl_Window *w = [cw getFl_Window];\n  if (fl_x_to_redraw) fl_x_to_redraw->flush();\n  else handleUpdateEvent(w);\n  through_drawRect = NO;\n  fl_unlock_function();\n}\n\n- (BOOL)acceptsFirstResponder\n{   \n  return YES;\n}\n- (BOOL)performKeyEquivalent:(NSEvent*)theEvent\n{   \n  //NSLog(@\"performKeyEquivalent:\");\n  fl_lock_function();\n  cocoaKeyboardHandler(theEvent);\n  BOOL handled;\n  NSUInteger mods = [theEvent modifierFlags];\n  if ( (mods & NSControlKeyMask) || (mods & NSCommandKeyMask) ) {\n    NSString *s = [theEvent characters];\n    if ( (mods & NSShiftKeyMask) && (mods & NSCommandKeyMask) ) {\n      s = [s uppercaseString]; // US keyboards return lowercase letter in s if cmd-shift-key is hit\n      }\n    [FLView prepareEtext:s];\n    Fl::compose_state = 0;\n    handled = Fl::handle(FL_KEYBOARD, [(FLWindow*)[theEvent window] getFl_Window]);\n  }\n  else {\n    in_key_event = YES;\n    need_handle = NO;\n    handled = [[self performSelector:inputContextSEL] handleEvent:theEvent];\n    if (need_handle) handled = Fl::handle(FL_KEYBOARD, [(FLWindow*)[theEvent window] getFl_Window]);\n    in_key_event = NO;\n    }\n  fl_unlock_function();\n  return handled;\n}\n- (BOOL)acceptsFirstMouse:(NSEvent*)theEvent\n{   \n  Fl_Window *w = [(FLWindow*)[theEvent window] getFl_Window];\n  Fl_Window *first = Fl::first_window();\n  return (first == w || !first->modal());\n}\n- (void)resetCursorRects {\n  Fl_Window *w = [(FLWindow*)[self window] getFl_Window];\n  Fl_X *i = Fl_X::i(w);\n  if (!i) return;  // fix for STR #3128\n  // We have to have at least one cursor rect for invalidateCursorRectsForView\n  // to work, hence the \"else\" clause.\n  if (i->cursor)\n    [self addCursorRect:[self visibleRect] cursor:(NSCursor*)i->cursor];\n  else\n    [self addCursorRect:[self visibleRect] cursor:[NSCursor arrowCursor]];\n}\n- (void)mouseUp:(NSEvent *)theEvent {\n  cocoaMouseHandler(theEvent);\n}\n- (void)rightMouseUp:(NSEvent *)theEvent {\n  cocoaMouseHandler(theEvent);\n}\n- (void)otherMouseUp:(NSEvent *)theEvent {\n  cocoaMouseHandler(theEvent);\n}\n- (void)mouseDown:(NSEvent *)theEvent {\n  cocoaMouseHandler(theEvent);\n}\n- (void)rightMouseDown:(NSEvent *)theEvent {\n  cocoaMouseHandler(theEvent);\n}\n- (void)otherMouseDown:(NSEvent *)theEvent {\n  cocoaMouseHandler(theEvent);\n}\n- (void)mouseMoved:(NSEvent *)theEvent {\n  cocoaMouseHandler(theEvent);\n}\n- (void)mouseDragged:(NSEvent *)theEvent {\n  cocoaMouseHandler(theEvent);\n}\n- (void)rightMouseDragged:(NSEvent *)theEvent {\n  cocoaMouseHandler(theEvent);\n}\n- (void)otherMouseDragged:(NSEvent *)theEvent {\n  cocoaMouseHandler(theEvent);\n}\n- (void)scrollWheel:(NSEvent *)theEvent {\n  cocoaMouseWheelHandler(theEvent);\n}\n- (void)keyDown:(NSEvent *)theEvent {\n  //NSLog(@\"keyDown:%@\",[theEvent characters]);\n  fl_lock_function();\n  Fl_Window *window = [(FLWindow*)[theEvent window] getFl_Window];\n  Fl::first_window(window);\n  cocoaKeyboardHandler(theEvent);\n  in_key_event = YES;\n  need_handle = NO;\n  [[self performSelector:inputContextSEL] handleEvent:theEvent];\n  if (need_handle) Fl::handle(FL_KEYBOARD, window);\n  in_key_event = NO;\n  fl_unlock_function();\n}\n- (void)keyUp:(NSEvent *)theEvent {\n  //NSLog(@\"keyUp:%@\",[theEvent characters]);\n  fl_lock_function();\n  Fl_Window *window = (Fl_Window*)[(FLWindow*)[theEvent window] getFl_Window];\n  Fl::first_window(window);\n  cocoaKeyboardHandler(theEvent);\n  NSString *s = [theEvent characters];\n  if ([s length] >= 1) [FLView prepareEtext:[s substringToIndex:1]];\n  Fl::handle(FL_KEYUP,window);\n  fl_unlock_function();\n}\n- (void)flagsChanged:(NSEvent *)theEvent {\n  //NSLog(@\"flagsChanged: \");\n  fl_lock_function();\n  static UInt32 prevMods = 0;\n  NSUInteger mods = [theEvent modifierFlags];\n  Fl_Window *window = (Fl_Window*)[(FLWindow*)[theEvent window] getFl_Window];\n  UInt32 tMods = prevMods ^ mods;\n  int sendEvent = 0;\n  if ( tMods )\n  {\n    unsigned short keycode = [theEvent keyCode];\n    Fl::e_keysym = Fl::e_original_keysym = macKeyLookUp[keycode & 0x7f];\n    if ( Fl::e_keysym ) \n      sendEvent = ( prevMods<mods ) ? FL_KEYBOARD : FL_KEYUP;\n    Fl::e_length = 0;\n    Fl::e_text = (char*)\"\";\n    prevMods = mods;\n  }\n  mods_to_e_state( mods );\n  while (window->parent()) window = window->window();\n  if (sendEvent) Fl::handle(sendEvent,window);\n  fl_unlock_function();\n}\n- (NSDragOperation)draggingEntered:(id < NSDraggingInfo >)sender\n{\n  fl_lock_function();\n  Fl_Window *target = [(FLWindow*)[self window] getFl_Window];\n  update_e_xy_and_e_xy_root([self window]);\n  fl_dnd_target_window = target;\n  int ret = Fl::handle( FL_DND_ENTER, target );\n  breakMacEventLoop();\n  fl_unlock_function();\n  Fl::flush();\n  return ret ? NSDragOperationCopy : NSDragOperationNone;\n}\n- (NSDragOperation)draggingUpdated:(id < NSDraggingInfo >)sender\n{\n  fl_lock_function();\n  Fl_Window *target = [(FLWindow*)[self window] getFl_Window];\n  update_e_xy_and_e_xy_root([self window]);\n  fl_dnd_target_window = target;\n  int ret = Fl::handle( FL_DND_DRAG, target );\n  breakMacEventLoop();\n  fl_unlock_function();\n  // if the DND started in the same application, Fl::dnd() will not return until \n  // the the DND operation is finished. The call below causes the drop indicator\n  // to be draw correctly (a full event handling would be better...)\n  Fl::flush();\n  return ret ? NSDragOperationCopy : NSDragOperationNone;\n}\n- (BOOL)performDragOperation:(id <NSDraggingInfo>)sender \n{\n  static char *DragData = NULL;\n  fl_lock_function();\n  Fl_Window *target = [(FLWindow*)[self window] getFl_Window];\n  if ( !Fl::handle( FL_DND_RELEASE, target ) ) { \n    breakMacEventLoop();\n    fl_unlock_function();\n    return NO;\n  }\n  NSPasteboard *pboard;\n  // NSDragOperation sourceDragMask;\n  // sourceDragMask = [sender draggingSourceOperationMask];\n  pboard = [sender draggingPasteboard];\n  update_e_xy_and_e_xy_root([self window]);\n  if (DragData) { free(DragData); DragData = NULL; }\n  if ( [[pboard types] containsObject:NSFilenamesPboardType] ) {\n    CFArrayRef files = (CFArrayRef)[pboard propertyListForType:NSFilenamesPboardType];\n    CFStringRef all = CFStringCreateByCombiningStrings(NULL, files, CFSTR(\"\\n\"));\n    int l = CFStringGetMaximumSizeForEncoding(CFStringGetLength(all), kCFStringEncodingUTF8);\n    DragData = (char *)malloc(l + 1);\n    CFStringGetCString(all, DragData, l + 1, kCFStringEncodingUTF8);\n    CFRelease(all);\n  }\n  else if ( [[pboard types] containsObject:utf8_format] ) {\n    NSData *data = [pboard dataForType:utf8_format];\n    DragData = (char *)malloc([data length] + 1);\n    [data getBytes:DragData];\n    DragData[[data length]] = 0;\n    convert_crlf(DragData, strlen(DragData));\n  }\n  else {\n    breakMacEventLoop();\n    fl_unlock_function();\n    return NO;\n  }\n  Fl::e_text = DragData;\n  Fl::e_length = strlen(DragData);\n  int old_event = Fl::e_number;\n  Fl::belowmouse()->handle(Fl::e_number = FL_PASTE);\n  Fl::e_number = old_event;\n  if (DragData) { free(DragData); DragData = NULL; }\n  Fl::e_text = NULL;\n  Fl::e_length = 0;\n  fl_dnd_target_window = NULL;\n  breakMacEventLoop();\n  fl_unlock_function();\n  return YES;\n}\n- (void)draggingExited:(id < NSDraggingInfo >)sender\n{\n  fl_lock_function();\n  if ( fl_dnd_target_window ) {\n    Fl::handle( FL_DND_LEAVE, fl_dnd_target_window );\n    fl_dnd_target_window = 0;\n  }\n  fl_unlock_function();\n}\n- (NSDragOperation)draggingSourceOperationMaskForLocal:(BOOL)isLocal\n{\n  return NSDragOperationGeneric;\n}\n\n- (FLTextInputContext*)FLinputContext { // used only if OS < 10.6 to replace [NSView inputContext]\n  static FLTextInputContext *context = NULL;\n  if (!context) {\n    context = [[FLTextInputContext alloc] init];\n    }\n  context->edit = (FLTextView*)[[self window] fieldEditor:YES forObject:nil];\n  return context;\n}\n\n+ (void)prepareEtext:(NSString*)aString {\n  // fills Fl::e_text with UTF-8 encoded aString using an adequate memory allocation\n  static char *received_utf8 = NULL;\n  static int lreceived = 0;\n  char *p = (char*)[aString UTF8String];\n  int l = strlen(p);\n  if (l > 0) {\n    if (lreceived == 0) {\n      received_utf8 = (char*)malloc(l + 1);\n      lreceived = l;\n    }\n    else if (l > lreceived) {\n      received_utf8 = (char*)realloc(received_utf8, l + 1);\n      lreceived = l;\n    }\n    strcpy(received_utf8, p);\n    Fl::e_text = received_utf8;\n  }\n  Fl::e_length = l;\n}\n\n+ (void)concatEtext:(NSString*)aString {\n  // extends Fl::e_text with aString\n  NSString *newstring = [[NSString stringWithUTF8String:Fl::e_text] stringByAppendingString:aString];\n  [FLView prepareEtext:newstring];\n}\n\n- (void)doCommandBySelector:(SEL)aSelector {\n  NSString *s = [[NSApp currentEvent] characters];\n  //NSLog(@\"doCommandBySelector:%s text='%@'\",sel_getName(aSelector), s);\n  s = [s substringFromIndex:[s length] - 1];\n  [FLView prepareEtext:s]; // use the last character of the event; necessary for deadkey + Tab\n  Fl_Window *target = [(FLWindow*)[self window] getFl_Window];\n  Fl::handle(FL_KEYBOARD, target);\n}\n\n- (void)insertText:(id)aString {\n  [self insertText:aString replacementRange:NSMakeRange(NSNotFound, 0)];\n}\n\n- (void)insertText:(id)aString replacementRange:(NSRange)replacementRange {\n  NSString *received;\n  if ([aString isKindOfClass:[NSAttributedString class]]) {\n    received = [(NSAttributedString*)aString string];\n  } else {\n    received = (NSString*)aString;\n  }\n  /*NSLog(@\"insertText='%@' l=%d Fl::compose_state=%d range=%d,%d\",\n\treceived,strlen([received UTF8String]),Fl::compose_state,replacementRange.location,replacementRange.length);*/\n  fl_lock_function();\n  Fl_Window *target = [(FLWindow*)[self window] getFl_Window];\n  while (replacementRange.length--) { // delete replacementRange.length characters before insertion point\n    int saved_keysym = Fl::e_keysym;\n    Fl::e_keysym = FL_BackSpace;\n    Fl::handle(FL_KEYBOARD, target);\n    Fl::e_keysym = saved_keysym;\n    }\n  if (in_key_event && Fl_X::next_marked_length && Fl::e_length) {\n    // if setMarkedText + insertText is sent during handleEvent, text cannot be concatenated in single FL_KEYBOARD event\n    Fl::handle(FL_KEYBOARD, target);\n    Fl::e_length = 0;\n    }\n  if (in_key_event && Fl::e_length) [FLView concatEtext:received];\n  else [FLView prepareEtext:received];\n  Fl_X::next_marked_length = 0;\n  // We can get called outside of key events (e.g., from the character palette, from CJK text input). \n  BOOL palette = !(in_key_event || Fl::compose_state);\n  if (palette) Fl::e_keysym = 0;\n  // YES if key has text attached\n  BOOL has_text_key = Fl::e_keysym <= '~' || Fl::e_keysym == FL_Iso_Key ||\n                      (Fl::e_keysym >= FL_KP && Fl::e_keysym <= FL_KP_Last && Fl::e_keysym != FL_KP_Enter);\n  // insertText sent during handleEvent of a key without text cannot be processed in a single FL_KEYBOARD event.\n  // Occurs with deadkey followed by non-text key\n  if (!in_key_event || !has_text_key) {\n    Fl::handle(FL_KEYBOARD, target);\n    Fl::e_length = 0;\n    }\n  else need_handle = YES;\n  selectedRange = NSMakeRange(100, 0); // 100 is an arbitrary value\n  // for some reason, with the palette, the window does not redraw until the next mouse move or button push\n  // sending a 'redraw()' or 'awake()' does not solve the issue!\n  if (palette) Fl::flush();\n  if (fl_mac_os_version < 100600) [(FLTextView*)[[self window] fieldEditor:YES forObject:nil] setActive:NO];\n  fl_unlock_function();\n}\n\n- (void)setMarkedText:(id)aString selectedRange:(NSRange)newSelection  {\n  [self setMarkedText:aString selectedRange:newSelection replacementRange:NSMakeRange(NSNotFound, 0)];\n}\n\n- (void)setMarkedText:(id)aString selectedRange:(NSRange)newSelection replacementRange:(NSRange)replacementRange {\n  NSString *received;\n  if ([aString isKindOfClass:[NSAttributedString class]]) {\n    received = [(NSAttributedString*)aString string];\n  } else {\n    received = (NSString*)aString;\n  }\n  fl_lock_function();\n  /*NSLog(@\"setMarkedText:%@ l=%d newSelection=%d,%d Fl::compose_state=%d replacement=%d,%d\", \n\treceived, strlen([received UTF8String]), newSelection.location, newSelection.length, Fl::compose_state,\n\treplacementRange.location, replacementRange.length);*/\n  Fl_Window *target = [(FLWindow*)[self window] getFl_Window];\n  while (replacementRange.length--) { // delete replacementRange.length characters before insertion point\n    Fl::e_keysym = FL_BackSpace;\n    Fl::compose_state = 0;\n    Fl_X::next_marked_length = 0;\n    Fl::handle(FL_KEYBOARD, target);\n    Fl::e_keysym = 'a'; // pretend a letter key was hit\n  }\n  if (in_key_event && Fl_X::next_marked_length && Fl::e_length) {\n    // if setMarkedText + setMarkedText is sent during handleEvent, text cannot be concatenated in single FL_KEYBOARD event\n    Fl::handle(FL_KEYBOARD, target);\n    Fl::e_length = 0;\n  }\n  if (in_key_event && Fl::e_length) [FLView concatEtext:received];\n  else [FLView prepareEtext:received];\n  Fl_X::next_marked_length = strlen([received UTF8String]);\n  if (!in_key_event) Fl::handle( FL_KEYBOARD, target);\n  else need_handle = YES;\n  selectedRange = NSMakeRange(100, newSelection.length);\n  fl_unlock_function();\n}\n\n- (void)unmarkText {\n  fl_lock_function();\n  Fl::reset_marked_text();\n  fl_unlock_function();\n  //NSLog(@\"unmarkText\");\n}\n\n- (NSRange)selectedRange {\n  Fl_Widget *w = Fl::focus();\n  if (w && w->use_accents_menu()) return selectedRange;\n  return NSMakeRange(NSNotFound, 0);\n}\n\n- (NSRange)markedRange {\n  //NSLog(@\"markedRange=%d %d\", Fl::compose_state > 0?0:NSNotFound, Fl::compose_state);\n  return NSMakeRange(Fl::compose_state > 0?0:NSNotFound, Fl::compose_state);\n}\n\n- (BOOL)hasMarkedText {\n  //NSLog(@\"hasMarkedText %s\", Fl::compose_state > 0?\"YES\":\"NO\");\n  return (Fl::compose_state > 0);\n}\n\n- (NSAttributedString *)attributedSubstringFromRange:(NSRange)aRange {\n  return [self attributedSubstringForProposedRange:aRange actualRange:NULL];\n}\n- (NSAttributedString *)attributedSubstringForProposedRange:(NSRange)aRange actualRange:(NSRangePointer)actualRange {\n  //NSLog(@\"attributedSubstringFromRange: %d %d\",aRange.location,aRange.length);\n  return nil;\n}\n\n- (NSArray *)validAttributesForMarkedText {\n  return nil;\n}\n\n- (NSRect)firstRectForCharacterRange:(NSRange)aRange {\n  return [self firstRectForCharacterRange:aRange actualRange:NULL];\n}\n- (NSRect)firstRectForCharacterRange:(NSRange)aRange actualRange:(NSRangePointer)actualRange {\n  //NSLog(@\"firstRectForCharacterRange %d %d actualRange=%p\",aRange.location, aRange.length,actualRange);\n  NSRect glyphRect;\n  fl_lock_function();\n  Fl_Widget *focus = Fl::focus();\n  Fl_Window *wfocus = [(FLWindow*)[self window] getFl_Window];\n  if (!focus) focus = wfocus;\n  glyphRect.size.width = 0;\n  \n  int x, y, height;\n  if (Fl_X::insertion_point_location(&x, &y, &height)) {\n    glyphRect.origin.x = (CGFloat)x;\n    glyphRect.origin.y = (CGFloat)y;\n  } else {\n    if (focus->as_window()) {\n      glyphRect.origin.x = 0;\n      glyphRect.origin.y = focus->h();\n      }\n    else {\n      glyphRect.origin.x = focus->x();\n      glyphRect.origin.y = focus->y() + focus->h();\n      }\n    height = 12;\n  }\n  glyphRect.size.height = height;\n  Fl_Window *win = focus->as_window();\n  if (!win) win = focus->window();\n  while (win != NULL && win != wfocus) {\n    glyphRect.origin.x += win->x();\n    glyphRect.origin.y += win->y();\n    win = win->window();\n  }\n  // Convert the rect to screen coordinates\n  glyphRect.origin.y = wfocus->h() - glyphRect.origin.y;\n  glyphRect.origin = [(FLWindow*)[self window] convertBaseToScreen:glyphRect.origin];\n  if (actualRange) *actualRange = aRange;\n  fl_unlock_function();\n  return glyphRect;\n}\n\n- (NSUInteger)characterIndexForPoint:(NSPoint)aPoint {\n  return 0;\n}\n\n- (NSInteger)windowLevel {\n  return [[self window] level];\n}\n\n- (NSInteger)conversationIdentifier {\n  return identifier;\n}\n\n@end\n\nvoid Fl_Window::fullscreen_x() {\n  _set_fullscreen();\n  /* On OS X < 10.6, it is necessary to recreate the window. This is done\n     with hide+show. */\n  hide();\n  show();\n  Fl::handle(FL_FULLSCREEN, this);\n}\n\nvoid Fl_Window::fullscreen_off_x(int X, int Y, int W, int H) {\n  _clear_fullscreen();\n  hide();\n  resize(X, Y, W, H);\n  show();\n  Fl::handle(FL_FULLSCREEN, this);\n}\n\n/*\n * Initialize the given port for redraw and call the window's flush() to actually draw the content\n */ \nvoid Fl_X::flush()\n{\n  if (through_drawRect || w->as_gl_window()) {\n    make_current_counts = 1;\n    w->flush();\n    make_current_counts = 0;\n    Fl_X::q_release_context();\n    return;\n  }\n  // have Cocoa immediately redraw the window's view\n  FLView *view = (FLView*)[fl_xid(w) contentView];\n  fl_x_to_redraw = this;\n  [view setNeedsDisplay:YES];\n  // will send the drawRect: message to the window's view after having prepared the adequate NSGraphicsContext\n  [view displayIfNeededIgnoringOpacity]; \n  fl_x_to_redraw = NULL;\n}\n\n//bool Fl_X::make_shaped = false;\n\n/*\n * go ahead, create that (sub)window\n */\nvoid Fl_X::make(Fl_Window* w)\n{\n  if ( w->parent() ) {\t\t// create a subwindow\n    Fl_Group::current(0);\n    // our subwindow needs this structure to know about its clipping. \n    Fl_X* x = new Fl_X;\n    x->subwindow = true;\n    x->other_xid = 0;\n    x->region = 0;\n    x->subRegion = 0;\n    x->cursor = NULL;\n    x->gc = 0;\t\t\t// stay 0 for Quickdraw; fill with CGContext for Quartz\n    w->set_visible();\n    Fl_Window *win = w->window();\n    Fl_X *xo = Fl_X::i(win);\n    if (xo) {\n      x->xidNext = xo->xidChildren;\n      x->xidChildren = 0L;\n      xo->xidChildren = x;\n      x->xid = win->i->xid;\n      x->w = w; w->i = x;\n      x->wait_for_expose = 0;\n      {\n\tFl_X *z = xo->next;\t// we don't want a subwindow in Fl_X::first\n\txo->next = x;\n\tx->next = z;\n      }\n      int old_event = Fl::e_number;\n      w->handle(Fl::e_number = FL_SHOW);\n      Fl::e_number = old_event;\n      w->redraw();\t\t// force draw to happen\n    }\n    if (w->as_gl_window()) { // if creating a sub-GL-window\n      while (win->window()) win = win->window();\n      [Fl_X::i(win)->xid containsGLsubwindow:YES];\n    }\n    fl_show_iconic = 0;\n  }\n  else {\t\t\t// create a desktop window\n    Fl_Group::current(0);\n    fl_open_display();\n    NSInteger winlevel = NSNormalWindowLevel;\n    NSUInteger winstyle;\n    if (w->border()) winstyle = NSTitledWindowMask | NSClosableWindowMask | NSMiniaturizableWindowMask;\n    else winstyle = NSBorderlessWindowMask;\n    int xp = w->x();\n    int yp = w->y();\n    int wp = w->w();\n    int hp = w->h();\n    if (w->size_range_set) {\n      if ( w->minh != w->maxh || w->minw != w->maxw) {\n        if (w->border()) winstyle |= NSResizableWindowMask;\n      }\n    } else {\n      if (w->resizable()) {\n        Fl_Widget *o = w->resizable();\n        int minw = o->w(); if (minw > 100) minw = 100;\n        int minh = o->h(); if (minh > 100) minh = 100;\n        w->size_range(w->w() - o->w() + minw, w->h() - o->h() + minh, 0, 0);\n\tif (w->border()) winstyle |= NSResizableWindowMask;\n      } else {\n        w->size_range(w->w(), w->h(), w->w(), w->h());\n      }\n    }\n    int xwm = xp, ywm = yp, bt, bx, by;\n    \n    if (!fake_X_wm(w, xwm, ywm, bt, bx, by)) {\n      // menu windows and tooltips\n      if (w->modal()||w->tooltip_window()) {\n        winlevel = modal_window_level();\n      }\n      //winstyle = NSBorderlessWindowMask;\n    } \n    if (w->modal()) {\n      winstyle &= ~NSMiniaturizableWindowMask;\n      // winstyle &= ~(NSResizableWindowMask | NSMiniaturizableWindowMask);\n      winlevel = modal_window_level();\n    }\n    else if (w->non_modal()) {\n      winlevel = non_modal_window_level();\n    }\n    \n    if (by+bt) {\n      wp += 2*bx;\n      hp += 2*by+bt;\n    }\n    if (w->force_position()) {\n      if (!Fl::grab()) {\n        xp = xwm; yp = ywm;\n        w->x(xp);w->y(yp);\n      }\n      xp -= bx;\n      yp -= by+bt;\n    }\n    \n    if (w->non_modal() && Fl_X::first /*&& !fl_disable_transient_for*/) {\n      // find some other window to be \"transient for\":\n      Fl_Window* w = Fl_X::first->w;\n      while (w->parent()) w = w->window(); // todo: this code does not make any sense! (w!=w??)\n    }\n        \n    Fl_X* x = new Fl_X;\n    x->subwindow = false;\n    x->other_xid = 0; // room for doublebuffering image map. On OS X this is only used by overlay windows\n    x->region = 0;\n    x->subRegion = 0;\n    x->cursor = NULL;\n    x->xidChildren = 0;\n    x->xidNext = 0;\n    x->gc = 0;\n\t  \n    NSRect crect;\n    if (w->fullscreen_active()) {\n      int top, bottom, left, right;\n      int sx, sy, sw, sh, X, Y, W, H;\n\n      top = w->fullscreen_screen_top;\n      bottom = w->fullscreen_screen_bottom;\n      left = w->fullscreen_screen_left;\n      right = w->fullscreen_screen_right;\n\n      if ((top < 0) || (bottom < 0) || (left < 0) || (right < 0)) {\n        top = Fl::screen_num(w->x(), w->y(), w->w(), w->h());\n        bottom = top;\n        left = top;\n        right = top;\n      }\n\n      Fl::screen_xywh(sx, sy, sw, sh, top);\n      Y = sy;\n      Fl::screen_xywh(sx, sy, sw, sh, bottom);\n      H = sy + sh - Y;\n      Fl::screen_xywh(sx, sy, sw, sh, left);\n      X = sx;\n      Fl::screen_xywh(sx, sy, sw, sh, right);\n      W = sx + sw - X;\n\n      w->resize(X, Y, W, H);\n\n      winstyle = NSBorderlessWindowMask;\n      winlevel = NSStatusWindowLevel;\n    }\n    crect.origin.x = w->x(); \n    crect.origin.y = main_screen_height - (w->y() + w->h());\n    crect.size.width=w->w(); \n    crect.size.height=w->h();\n    FLWindow *cw = [[FLWindow alloc] initWithFl_W:w \n\t\t\t\t      contentRect:crect  \n\t\t\t\t\tstyleMask:winstyle];\n    [cw setFrameOrigin:crect.origin];\n    [cw setHasShadow:YES];\n    [cw setAcceptsMouseMovedEvents:YES];\n    if (w->shape_data_) {\n      [cw setOpaque:NO]; // shaped windows must be non opaque\n      [cw setBackgroundColor:[NSColor clearColor]]; // and with transparent background color\n      }\n    x->xid = cw;\n    x->w = w; w->i = x;\n    x->wait_for_expose = 1;\n    x->next = Fl_X::first;\n    Fl_X::first = x;\n    FLView *myview = [[FLView alloc] init];\n    [cw setContentView:myview];\n    [myview release];\n    [cw setLevel:winlevel];\n    \n    q_set_window_title(cw, w->label(), w->iconlabel());\n    if (!w->force_position()) {\n      if (w->modal()) {\n        [cw center];\n      } else if (w->non_modal()) {\n        [cw center];\n      } else {\n        static NSPoint delta = NSZeroPoint;\n        delta = [cw cascadeTopLeftFromPoint:delta];\n      }\n    }\n    if(w->menu_window()) { // make menu windows slightly transparent\n      [cw setAlphaValue:0.97];\n    }\n    // Install DnD handlers \n    [myview registerForDraggedTypes:[NSArray arrayWithObjects:utf8_format,  NSFilenamesPboardType, nil]];\n    if ( ! Fl_X::first->next ) {\t\n      // if this is the first window, we need to bring the application to the front\n      [NSApp activateIgnoringOtherApps:YES];\n    }\n    \n    if (w->size_range_set) w->size_range_();\n    \n    if ( w->border() || (!w->modal() && !w->tooltip_window()) ) {\n      Fl_Tooltip::enter(0);\n    }\n\n    if (w->modal()) Fl::modal_ = w; \n\n    w->set_visible();\n    if ( w->border() || (!w->modal() && !w->tooltip_window()) ) Fl::handle(FL_FOCUS, w);\n    Fl::first_window(w);\n    [cw setDelegate:[FLWindowDelegate createOnce]];\n    if (fl_show_iconic) { \n      fl_show_iconic = 0;\n      [cw miniaturize:nil];\n    } else {\n      [cw makeKeyAndOrderFront:nil];\n    }\n    \n    crect = [[cw contentView] frame];\n    w->w(int(crect.size.width));\n    w->h(int(crect.size.height));\n    crect = [cw frame];\n    w->x(int(crect.origin.x));\n    w->y(int(main_screen_height - (crect.origin.y + w->h())));\n    \n    int old_event = Fl::e_number;\n    w->handle(Fl::e_number = FL_SHOW);\n    Fl::e_number = old_event;\n    \n    // if (w->modal()) { Fl::modal_ = w; fl_fix_focus(); }\n  }\n}\n\n\n/*\n * Tell the OS what window sizes we want to allow\n */\nvoid Fl_Window::size_range_() {\n  int bx, by, bt;\n  get_window_frame_sizes(bx, by, bt);\n  size_range_set = 1;\n  NSSize minSize = { minw, minh + bt };\n  NSSize maxSize = { maxw?maxw:32000, maxh?maxh + bt:32000 };\n  if (i && i->xid) {\n    [i->xid setMinSize:minSize];\n    [i->xid setMaxSize:maxSize];\n  }\n}\n\n\n/*\n * returns pointer to the filename, or null if name ends with ':'\n */\nconst char *fl_filename_name( const char *name ) \n{\n  const char *p, *q;\n  if (!name) return (0);\n  for ( p = q = name ; *p ; ) {\n    if ( ( p[0] == ':' ) && ( p[1] == ':' ) ) {\n      q = p+2;\n      p++;\n    }\n    else if (p[0] == '/') {\n      q = p + 1;\n    }\n    p++;\n  }\n  return q;\n}\n\n\n/*\n * set the window title bar name\n */\nvoid Fl_Window::label(const char *name, const char *mininame) {\n  Fl_Widget::label(name);\n  iconlabel_ = mininame;\n  if (shown() || i) {\n    q_set_window_title(i->xid, name, mininame);\n  }\n}\n\n\n/*\n * make a window visible\n */\nvoid Fl_Window::show() {\n  image(Fl::scheme_bg_);\n  if (Fl::scheme_bg_) {\n    labeltype(FL_NORMAL_LABEL);\n    align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE | FL_ALIGN_CLIP);\n  } else {\n    labeltype(FL_NO_LABEL);\n  }\n  Fl_Tooltip::exit(this);\n  if (!shown()) {\n    Fl_X::make(this);\n  } else {\n    if ( !parent() ) {\n      if ([i->xid isMiniaturized]) {\n\ti->w->redraw();\n\t[i->xid deminiaturize:nil];\n      }\n      if (!fl_capture) {\n\t[i->xid makeKeyAndOrderFront:nil];\n      }\n    }\n  }\n}\n\n\n/*\n * resize a window\n */\nvoid Fl_Window::resize(int X,int Y,int W,int H) {\n  if (W<=0) W = 1; // OS X does not like zero width windows\n  if (H<=0) H = 1;\n  int is_a_resize = (W != w() || H != h());\n  //  printf(\"Fl_Window::resize(X=%d, Y=%d, W=%d, H=%d), is_a_resize=%d, resize_from_system=%p, this=%p\\n\",\n  //         X, Y, W, H, is_a_resize, resize_from_system, this);\n  if (X != x() || Y != y()) set_flag(FORCE_POSITION);\n  else if (!is_a_resize) {\n    resize_from_system = 0;\n    return;\n    }\n  if ( (resize_from_system!=this) && (!parent()) && shown()) {\n    if (is_a_resize) {\n      if (resizable()) {\n        if (W<minw) minw = W; // user request for resize takes priority\n        if (maxw && W>maxw) maxw = W; // over a previously set size_range\n        if (H<minh) minh = H;\n        if (maxh && H>maxh) maxh = H;\n        size_range(minw, minh, maxw, maxh);\n      } else {\n        size_range(W, H, W, H);\n      }\n      int bx, by, bt;\n      if ( ! this->border() ) bt = 0;\n      else get_window_frame_sizes(bx, by, bt);\n      NSRect dim;\n      dim.origin.x = X;\n      dim.origin.y = main_screen_height - (Y + H);\n      dim.size.width = W;\n      dim.size.height = H + bt;\n      [i->xid setFrame:dim display:YES]; // calls windowDidResize\n    } else {\n      NSPoint pt; \n      pt.x = X; \n      pt.y = main_screen_height - (Y + h());\n      [i->xid setFrameOrigin:pt]; // calls windowDidMove\n    }\n    return;\n  }\n  resize_from_system = 0;\n  if (is_a_resize) {\n    Fl_Group::resize(X,Y,W,H);\n    if (shown()) { \n      redraw(); \n    }\n  } else {\n    x(X); y(Y); \n  }\n}\n\n\n/*\n * make all drawing go into this window (called by subclass flush() impl.)\n \n This can be called in 3 different instances:\n \n 1) When a window is created, resized, or deminiaturized. \n The system sends the drawRect: message to the window's view after having prepared the current graphics context \n to draw to this view. Variable through_drawRect is YES, and fl_x_to_redraw is NULL. Processing of drawRect: calls \n handleUpdateEvent() that calls Fl_X::flush() for the window and its subwindows. Fl_X::flush() calls \n Fl_Window::flush() that calls Fl_Window::make_current() that only needs to identify the graphics port of the \n current graphics context. The window's draw() function is then executed.\n \n 2) At each round of the FLTK event loop.\n Fl::flush() is called, that calls Fl_X::flush() on each window that needs drawing. Fl_X::flush() sets \n fl_x_to_redraw to this and sends the displayIfNeededIgnoringOpacity message to the window's view. \n This message makes the system prepare the current graphics context adequately for drawing to this view, and \n send it the drawRect: message which sets through_drawRect to YES. Processing of the drawRect: message calls \n Fl_X::flush() for the window which proceeds as in 1) above.\n \n 3) An FLTK application can call Fl_Window::make_current() at any time before it draws to a window.\n This occurs for instance in the idle callback function of the mandelbrot test program. Variable through_drawRect is NO,\n so Fl_Window::make_current() creates a new graphics context adequate for the window. \n Subsequent drawing requests go to this window. CAUTION: it's not possible to call Fl::wait(), Fl::check()\n nor Fl::ready() while in the draw() function of a widget. Use an idle callback instead.\n \n */\nvoid Fl_Window::make_current() \n{\n  if (make_current_counts > 1) return;\n  if (make_current_counts) make_current_counts++;\n  Fl_X::q_release_context();\n  fl_window = i->xid;\n  current_ = this;\n  \n  int xp = 0, yp = 0;\n  Fl_Window *win = this;\n  while ( win ) {\n    if ( !win->window() )\n      break;\n    xp += win->x();\n    yp += win->y();\n    win = (Fl_Window*)win->window();\n  }\n  NSGraphicsContext *nsgc = through_drawRect ? [NSGraphicsContext currentContext] : \n\t\t\t\t\t       [NSGraphicsContext graphicsContextWithWindow:fl_window];\n  i->gc = (CGContextRef)[nsgc graphicsPort];\n  fl_gc = i->gc;\n  Fl_Region fl_window_region = XRectangleRegion(0,0,w(),h());\n  if ( ! this->window() ) {\n    for ( Fl_X *cx = i->xidChildren; cx; cx = cx->xidNext ) {\t// clip-out all sub-windows\n      Fl_Window *cw = cx->w;\n      Fl_Region from = fl_window_region;\n      fl_window_region = MacRegionMinusRect(from, cw->x(), cw->y(), cw->w(), cw->h() );\n      XDestroyRegion(from);\n    }\n  }\n  \n  // antialiasing must be deactivated because it applies to rectangles too\n  // and escapes even clipping!!!\n  // it gets activated when needed (e.g., draw text)\n  CGContextSetShouldAntialias(fl_gc, false);  \n  CGFloat hgt = [[fl_window contentView] frame].size.height;\n  CGContextTranslateCTM(fl_gc, 0.5, hgt-0.5f);\n  CGContextScaleCTM(fl_gc, 1.0f, -1.0f); // now 0,0 is top-left point of the window\n  win = this;\n  while(win && win->window()) { // translate to subwindow origin if this is a subwindow context\n    CGContextTranslateCTM(fl_gc, win->x(), win->y());\n    win = win->window();\n  }\n  //apply window's clip\n  CGContextClipToRects(fl_gc, fl_window_region->rects, fl_window_region->count );\n  XDestroyRegion(fl_window_region);\n// this is the context with origin at top left of (sub)window clipped out of its subwindows if any\n  CGContextSaveGState(fl_gc); \n#if defined(FLTK_USE_CAIRO)\n  if (Fl::cairo_autolink_context()) Fl::cairo_make_current(this); // capture gc changes automatically to update the cairo context adequately\n#endif\n  fl_clip_region( 0 );\n  \n#if defined(FLTK_USE_CAIRO)\n  // update the cairo_t context\n  if (Fl::cairo_autolink_context()) Fl::cairo_make_current(this);\n#endif\n}\n\n// helper function to manage the current CGContext fl_gc\nextern void fl_quartz_restore_line_style_();\n\n// FLTK has only one global graphics state. This function copies the FLTK state into the\n// current Quartz context\nvoid Fl_X::q_fill_context() {\n  if (!fl_gc) return;\n  if ( ! fl_window) { // a bitmap context\n    size_t hgt = CGBitmapContextGetHeight(fl_gc);\n    CGContextTranslateCTM(fl_gc, 0.5, hgt-0.5f);\n    CGContextScaleCTM(fl_gc, 1.0f, -1.0f); // now 0,0 is top-left point of the context\n    }\n  fl_color(fl_graphics_driver->color());\n  fl_quartz_restore_line_style_();\n}\n\n// The only way to reset clipping to its original state is to pop the current graphics\n// state and restore the global state.\nvoid Fl_X::q_clear_clipping() {\n  if (!fl_gc) return;\n  CGContextRestoreGState(fl_gc);\n  CGContextSaveGState(fl_gc);\n}\n\n// Give the Quartz context back to the system\nvoid Fl_X::q_release_context(Fl_X *x) {\n  if (x && x->gc!=fl_gc) return;\n  if (!fl_gc) return;\n  CGContextRestoreGState(fl_gc); // KEEP IT: matches the CGContextSaveGState of make_current\n  CGContextFlush(fl_gc);\n  fl_gc = 0;\n#if defined(FLTK_USE_CAIRO)\n  if (Fl::cairo_autolink_context()) Fl::cairo_make_current((Fl_Window*) 0); // capture gc changes automatically to update the cairo context adequately\n#endif\n}\n\nvoid Fl_X::q_begin_image(CGRect &rect, int cx, int cy, int w, int h) {\n  CGContextSaveGState(fl_gc);\n  CGRect r2 = rect;\n  r2.origin.x -= 0.5f;\n  r2.origin.y -= 0.5f;\n  CGContextClipToRect(fl_gc, r2);\n  // move graphics context to origin of vertically reversed image \n  CGContextTranslateCTM(fl_gc, rect.origin.x - cx - 0.5, rect.origin.y - cy + h - 0.5);\n  CGContextScaleCTM(fl_gc, 1, -1);\n  rect.origin.x = rect.origin.y = 0;\n  rect.size.width = w;\n  rect.size.height = h;\n}\n\nvoid Fl_X::q_end_image() {\n  CGContextRestoreGState(fl_gc);\n}\n\n\n////////////////////////////////////////////////////////////////\n// Copy & Paste fltk implementation.\n////////////////////////////////////////////////////////////////\n\nstatic void convert_crlf(char * s, size_t len)\n{\n  // turn all \\r characters into \\n:\n  for (size_t x = 0; x < len; x++) if (s[x] == '\\r') s[x] = '\\n';\n}\n\n// fltk 1.3 clipboard support constant definitions:\nstatic NSString *calc_utf8_format(void)\n{\n#if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_6\n#define NSPasteboardTypeString @\"public.utf8-plain-text\"\n#endif\n  if (fl_mac_os_version >= 100600) return NSPasteboardTypeString;\n  return NSStringPboardType;\n}\n\n// clipboard variables definitions :\nchar *fl_selection_buffer[2] = {NULL, NULL};\nint fl_selection_length[2] = {0, 0};\nstatic int fl_selection_buffer_length[2];\n\nstatic PasteboardRef allocatePasteboard(void) \n{\n  PasteboardRef clip;\n  PasteboardCreate(kPasteboardClipboard, &clip); // requires Mac OS 10.3\n  return clip;\n}\nstatic PasteboardRef myPasteboard = allocatePasteboard();\n\nextern void fl_trigger_clipboard_notify(int source);\n\nvoid fl_clipboard_notify_change() {\n  // No need to do anything here...\n}\n\nstatic void clipboard_check(void)\n{\n  PasteboardSyncFlags flags;\n  \n  flags = PasteboardSynchronize(myPasteboard); // requires Mac OS 10.3\n\n  if (!(flags & kPasteboardModified))\n    return;\n  if (flags & kPasteboardClientIsOwner)\n    return;\n\n  fl_trigger_clipboard_notify(1);\n}\n\n/*\n * create a selection\n * stuff: pointer to selected data\n * len: size of selected data\n * type: always \"plain/text\" for now\n */\nvoid Fl::copy(const char *stuff, int len, int clipboard, const char *type) {\n  if (!stuff || len<0) return;\n  if (len+1 > fl_selection_buffer_length[clipboard]) {\n    delete[] fl_selection_buffer[clipboard];\n    fl_selection_buffer[clipboard] = new char[len+100];\n    fl_selection_buffer_length[clipboard] = len+100;\n  }\n  memcpy(fl_selection_buffer[clipboard], stuff, len);\n  fl_selection_buffer[clipboard][len] = 0; // needed for direct paste\n  fl_selection_length[clipboard] = len;\n  if (clipboard) {\n    CFDataRef text = CFDataCreate(kCFAllocatorDefault, (UInt8*)fl_selection_buffer[1], len);\n    if (text==NULL) return; // there was a pb creating the object, abort.\n    NSPasteboard *clip = [NSPasteboard generalPasteboard];\n    [clip declareTypes:[NSArray arrayWithObject:utf8_format] owner:nil];\n    [clip setData:(NSData*)text forType:utf8_format];\n    CFRelease(text);\n  }\n}\n\nstatic int get_plain_text_from_clipboard(char **buffer, int previous_length)\n{\n  NSInteger length = 0;\n  NSPasteboard *clip = [NSPasteboard generalPasteboard];\n  NSString *found = [clip availableTypeFromArray:[NSArray arrayWithObjects:utf8_format, @\"public.utf16-plain-text\", @\"com.apple.traditional-mac-plain-text\", nil]];\n  if (found) {\n    NSData *data = [clip dataForType:found];\n    if (data) {\n      NSInteger len;\n      char *aux_c = NULL;\n      if (![found isEqualToString:utf8_format]) {\n\tNSString *auxstring;\n\tauxstring = (NSString *)CFStringCreateWithBytes(NULL, \n\t\t\t\t\t\t\t(const UInt8*)[data bytes], \n\t\t\t\t\t\t\t[data length],\n\t\t\t\t\t\t\t[found isEqualToString:@\"public.utf16-plain-text\"] ? kCFStringEncodingUnicode : kCFStringEncodingMacRoman,\n\t\t\t\t\t\t\tfalse);\n\taux_c = strdup([auxstring UTF8String]);\n\t[auxstring release];\n\tlen = strlen(aux_c) + 1;\n      }\n      else len = [data length] + 1;\n      if ( len >= previous_length ) {\n\tlength = len;\n\tdelete[] *buffer;\n\t*buffer = new char[len];\n      }\n      if (![found isEqualToString:utf8_format]) {\n\tstrcpy(*buffer, aux_c);\n\tfree(aux_c);\n      }\n      else {\n\t[data getBytes:*buffer];\n      }\n      (*buffer)[len - 1] = 0;\n      length = len - 1;\n      convert_crlf(*buffer, len - 1); // turn all \\r characters into \\n:\n      Fl::e_clipboard_type = Fl::clipboard_plain_text;\n    }\n  }    \n  return length;\n}\n\nstatic Fl_Image* get_image_from_clipboard()\n{\n  Fl_RGB_Image *image = NULL;\n  uchar *imagedata;\n  NSBitmapImageRep *bitmap;\n  NSPasteboard *clip = [NSPasteboard generalPasteboard];\n  NSArray *present = [clip types]; // types in pasteboard in order of decreasing preference\n  NSArray  *possible = [NSArray arrayWithObjects:@\"com.adobe.pdf\", @\"public.tiff\", @\"com.apple.pict\", nil];\n  NSString *found = nil;\n  NSUInteger rank;\n  for (rank = 0; rank < [present count]; rank++) { // find first of possible types present in pasteboard\n    for (NSUInteger i = 0; i < [possible count]; i++) {\n      if ([[present objectAtIndex:rank] isEqualToString:[possible objectAtIndex:i]]) {\n\tfound = [present objectAtIndex:rank];\n\tgoto after_loop;\n      }\n    }\n  }\nafter_loop: \n  if (found) {\n    NSData *data = [clip dataForType:found];\n    if (data) {\n      if ([found isEqualToString:@\"public.tiff\"]) {\n\tbitmap = [NSBitmapImageRep imageRepWithData:data];\n\tint bpp = [bitmap bytesPerPlane];\n\tint bpr = [bitmap bytesPerRow];\n\tint depth = [bitmap samplesPerPixel], w = bpr/depth, h = bpp/bpr;\n\timagedata = new uchar[w * h * depth];\n\tmemcpy(imagedata, [bitmap bitmapData], w * h * depth);\n\timage = new Fl_RGB_Image(imagedata, w, h, depth);\n\timage->alloc_array = 1;\n      }\n      else if ([found isEqualToString:@\"com.adobe.pdf\"] || [found isEqualToString:@\"com.apple.pict\"]) {\n\tNSRect rect;\n\tNSImageRep *vectorial;\n\tNSAffineTransform *dilate = [NSAffineTransform transform];\n\tif ([found isEqualToString:@\"com.adobe.pdf\"] ) {\n\t  vectorial = [NSPDFImageRep imageRepWithData:data];\n\t  rect = [(NSPDFImageRep*)vectorial bounds]; // in points =  1/72 inch\n\t  Fl_Window *win = Fl::first_window();\n\t  int screen_num = win ? Fl::screen_num(win->x(), win->y(), win->w(), win->h()) : 0;\n\t  float hr, vr;\n\t  Fl::screen_dpi(hr, vr, screen_num); // 1 inch = hr pixels = 72 points -> hr/72 pixel/point\t  \n\t  CGFloat scale = hr/72;\n\t  [dilate scaleBy:scale];\n\t  rect.size.width *= scale;\n\t  rect.size.height *= scale;\n\t  rect = NSIntegralRect(rect);\n\t  }\n\telse {\n\t  vectorial = [NSPICTImageRep imageRepWithData:data];\n\t  rect = [(NSPICTImageRep*)vectorial boundingBox]; // in pixel, no scaling required\n\t  }\n\timagedata = new uchar[(int)(rect.size.width * rect.size.height) * 4];\n\tmemset(imagedata, -1, (int)(rect.size.width * rect.size.height) * 4);\n\tbitmap = [[NSBitmapImageRep alloc]  initWithBitmapDataPlanes:&imagedata\n\t\t\t\t\t\t\t  pixelsWide:rect.size.width\n\t\t\t\t\t\t\t  pixelsHigh:rect.size.height\n\t\t\t\t\t\t       bitsPerSample:8\n\t\t\t\t\t\t     samplesPerPixel:3\n\t\t\t\t\t\t\t    hasAlpha:NO\n\t\t\t\t\t\t\t    isPlanar:NO\n\t\t\t\t\t\t      colorSpaceName:NSDeviceRGBColorSpace\n\t\t\t\t\t\t\t bytesPerRow:rect.size.width*4\n\t\t\t\t\t\t\tbitsPerPixel:32];\n\tNSDictionary *dict = [NSDictionary dictionaryWithObject:bitmap \n\t\t\t\t\t\t\t forKey:NSGraphicsContextDestinationAttributeName];\n\tNSGraphicsContext *oldgc = [NSGraphicsContext currentContext];\n\t[NSGraphicsContext setCurrentContext:[NSGraphicsContext graphicsContextWithAttributes:dict]];\n\t[dilate concat];\n\t[vectorial draw];\n\t[NSGraphicsContext setCurrentContext:oldgc];\n\t[bitmap release];\n\timage = new Fl_RGB_Image(imagedata, rect.size.width, rect.size.height, 4);\n\timage->alloc_array = 1;\n      }\n      Fl::e_clipboard_type = Fl::clipboard_image;\n    }\n  }\n  return image;\n}\n\n// Call this when a \"paste\" operation happens:\nvoid Fl::paste(Fl_Widget &receiver, int clipboard, const char *type) {\n  if (type[0] == 0) type = Fl::clipboard_plain_text;\n  if (clipboard) {\n    Fl::e_clipboard_type = \"\";\n   if (strcmp(type, Fl::clipboard_plain_text) == 0) {\n      fl_selection_length[1] = get_plain_text_from_clipboard( &fl_selection_buffer[1],  fl_selection_length[1]);   \n      }\n    else if (strcmp(type, Fl::clipboard_image) == 0) {\n      Fl::e_clipboard_data = get_image_from_clipboard( );\n      if (Fl::e_clipboard_data) {\n\tint done = receiver.handle(FL_PASTE);\n\tFl::e_clipboard_type = \"\";\n\tif (done == 0) {\n\t  delete (Fl_Image*)Fl::e_clipboard_data;\n\t  Fl::e_clipboard_data = NULL;\n\t}\n      }\n      return;\n      }\n    else\n      fl_selection_length[1] = 0;\n  }\n  Fl::e_text = fl_selection_buffer[clipboard];\n  Fl::e_length = fl_selection_length[clipboard];\n  if (!Fl::e_length) Fl::e_text = (char *)\"\";\n  receiver.handle(FL_PASTE);\n}\n\nint Fl::clipboard_contains(const char *type) {\n  NSString *found = nil;\n  if (strcmp(type, Fl::clipboard_plain_text) == 0) {\n    found = [[NSPasteboard generalPasteboard] availableTypeFromArray:[NSArray arrayWithObjects:utf8_format, @\"public.utf16-plain-text\", @\"com.apple.traditional-mac-plain-text\", nil]];\n    }\n  else if (strcmp(type, Fl::clipboard_image) == 0) {\n    found = [[NSPasteboard generalPasteboard] availableTypeFromArray:[NSArray arrayWithObjects:@\"public.tiff\", @\"com.adobe.pdf\", @\"com.apple.pict\", nil]];\n    }\n  return found != nil;\n}\n\nint Fl_X::unlink(Fl_X *start) {\n  if (start) {\n    Fl_X *pc = start;\n    while (pc) {\n      if (pc->xidNext == this) {\n        pc->xidNext = xidNext;\n        return 1;\n      }\n      if (pc->xidChildren) {\n        if (pc->xidChildren == this) {\n          pc->xidChildren = xidNext;\n          return 1;\n        }\n        if (unlink(pc->xidChildren))\n          return 1;\n      }\n      pc = pc->xidNext;\n    }\n  } else {\n    for ( Fl_X *pc = Fl_X::first; pc; pc = pc->next ) {\n      if (unlink(pc))\n        return 1;\n    }\n  }  \n  return 0;\n}\n\nvoid Fl_X::relink(Fl_Window *w, Fl_Window *wp) {\n  Fl_X *x = Fl_X::i(w);\n  Fl_X *p = Fl_X::i(wp);\n  if (!x || !p) return;\n  // first, check if 'x' is already registered as a child of 'p'\n  for (Fl_X *i = p->xidChildren; i; i=i->xidNext) {\n    if (i == x) return;\n  }\n  // now add 'x' as the first child of 'p'\n  x->xidNext = p->xidChildren;\n  p->xidChildren = x;\n}\n\nvoid Fl_X::destroy() {\n  // subwindows share their xid with their parent window, so should not close it\n  if (!subwindow && w && !w->parent() && xid) {\n    [xid close];\n  }\n}\n\nvoid Fl_X::map() {\n  if (w && xid) {\n    [xid orderFront:nil];\n  }\n  //+ link to window list\n  if (w && w->parent()) {\n    Fl_X::relink(w, w->window() );\n    w->redraw();\n  }\n  if (cursor) {\n    [(NSCursor*)cursor release];\n    cursor = NULL;\n  }\n}\n\nvoid Fl_X::unmap() {\n  if (w && !w->parent() && xid) {\n    [xid orderOut:nil];\n  }\n  if (w && Fl_X::i(w)) \n    Fl_X::i(w)->unlink();\n}\n\n\n// removes x,y,w,h rectangle from region r and returns result as a new Fl_Region\nstatic Fl_Region MacRegionMinusRect(Fl_Region r, int x,int y,int w,int h)\n{\n  Fl_Region outr = (Fl_Region)malloc(sizeof(*outr));\n  outr->rects = (CGRect*)malloc(4 * r->count * sizeof(CGRect));\n  outr->count = 0;\n  CGRect rect = fl_cgrectmake_cocoa(x, y, w, h);\n  for( int i = 0; i < r->count; i++) {\n    CGRect A = r->rects[i];\n    CGRect test = CGRectIntersection(A, rect);\n    if (CGRectIsEmpty(test)) {\n      outr->rects[(outr->count)++] = A;\n    }\n    else {\n      const CGFloat verylarge = 100000.;\n      CGRect side = CGRectMake(0,0,rect.origin.x,verylarge);// W side\n      test = CGRectIntersection(A, side);\n      if ( ! CGRectIsEmpty(test)) {\n        outr->rects[(outr->count)++] = test;\n      }\n      side = CGRectMake(0,rect.origin.y + rect.size.height,verylarge,verylarge);// N side\n      test = CGRectIntersection(A, side);\n      if ( ! CGRectIsEmpty(test)) {\n        outr->rects[(outr->count)++] = test;\n      }\n      side = CGRectMake(rect.origin.x + rect.size.width, 0, verylarge, verylarge);// E side\n      test = CGRectIntersection(A, side);\n      if ( ! CGRectIsEmpty(test)) {\n        outr->rects[(outr->count)++] = test;\n      }\n      side = CGRectMake(0, 0, verylarge, rect.origin.y);// S side\n      test = CGRectIntersection(A, side);\n      if ( ! CGRectIsEmpty(test)) {\n        outr->rects[(outr->count)++] = test;\n      }\n    }\n  }\n  if (outr->count == 0) {\n    free(outr->rects);\n    free(outr);\n    outr = XRectangleRegion(0,0,0,0);\n  }\n  else outr->rects = (CGRect*)realloc(outr->rects, outr->count * sizeof(CGRect));\n  return outr;\n}\n\n// intersects current and x,y,w,h rectangle and returns result as a new Fl_Region\nFl_Region Fl_X::intersect_region_and_rect(Fl_Region current, int x,int y,int w, int h)\n{\n  if (current == NULL) return XRectangleRegion(x,y,w,h);\n  CGRect r = fl_cgrectmake_cocoa(x, y, w, h);\n  Fl_Region outr = (Fl_Region)malloc(sizeof(*outr));\n  outr->count = current->count;\n  outr->rects =(CGRect*)malloc(outr->count * sizeof(CGRect));\n  int j = 0;\n  for(int i = 0; i < current->count; i++) {\n    CGRect test = CGRectIntersection(current->rects[i], r);\n    if (!CGRectIsEmpty(test)) outr->rects[j++] = test;\n  }\n  if (j) {\n    outr->count = j;\n    outr->rects = (CGRect*)realloc(outr->rects, outr->count * sizeof(CGRect));\n  }\n  else {\n    XDestroyRegion(outr);\n    outr = XRectangleRegion(0,0,0,0);\n  }\n  return outr;\n}\n\nvoid Fl_X::collapse() {\n  [xid miniaturize:nil];\n}\n\nstatic NSImage *CGBitmapContextToNSImage(CGContextRef c)\n// the returned NSImage is autoreleased\n{\n  NSImage* image;\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6\n  if (fl_mac_os_version >= 100600) {\n    CGImageRef cgimg = CGBitmapContextCreateImage(c);  // requires 10.4\n    image = [[NSImage alloc] initWithCGImage:cgimg size:NSZeroSize]; // requires 10.6\n    CFRelease(cgimg);\n  }\n  else \n#endif\n    {\n      unsigned char *pdata = (unsigned char *)CGBitmapContextGetData(c);\n      NSBitmapImageRep *imagerep = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:&pdata\n\t\t\t\t\t\t\t\t\t   pixelsWide:CGBitmapContextGetWidth(c)\n\t\t\t\t\t\t\t\t\t   pixelsHigh:CGBitmapContextGetHeight(c)\n\t\t\t\t\t\t\t\t\tbitsPerSample:8\n\t\t\t\t\t\t\t\t      samplesPerPixel:4\n\t\t\t\t\t\t\t\t\t     hasAlpha:YES\n\t\t\t\t\t\t\t\t\t     isPlanar:NO\n\t\t\t\t\t\t\t\t       colorSpaceName:NSDeviceRGBColorSpace\n\t\t\t\t\t\t\t\t\t  bytesPerRow:CGBitmapContextGetBytesPerRow(c)\n\t\t\t\t\t\t\t\t\t bitsPerPixel:CGBitmapContextGetBitsPerPixel(c)];\n      image = [[NSImage alloc] initWithData: [imagerep TIFFRepresentation]];\n      [imagerep release];\n    }\n  return [image autorelease];\n}\n\n\nCFDataRef Fl_X::CGBitmapContextToTIFF(CGContextRef c)\n{ // the returned value is autoreleased\n  unsigned char *pdata = (unsigned char *)CGBitmapContextGetData(c);\n  NSBitmapImageRep *imagerep = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:&pdata\n\t\t\t\t\t\t\t\t       pixelsWide:CGBitmapContextGetWidth(c)\n\t\t\t\t\t\t\t\t       pixelsHigh:CGBitmapContextGetHeight(c)\n\t\t\t\t\t\t\t\t    bitsPerSample:8\n\t\t\t\t\t\t\t\t  samplesPerPixel:3\n\t\t\t\t\t\t\t\t\t hasAlpha:NO\n\t\t\t\t\t\t\t\t\t isPlanar:NO\n\t\t\t\t\t\t\t\t   colorSpaceName:NSDeviceRGBColorSpace\n\t\t\t\t\t\t\t\t      bytesPerRow:CGBitmapContextGetBytesPerRow(c)\n\t\t\t\t\t\t\t\t     bitsPerPixel:CGBitmapContextGetBitsPerPixel(c)];\n  NSData* tiff = [imagerep TIFFRepresentation];\n  [imagerep release];\n  return (CFDataRef)tiff;\n}\n\nint Fl_X::set_cursor(Fl_Cursor c)\n{\n  if (cursor) {\n    [(NSCursor*)cursor release];\n    cursor = NULL;\n  }\n\n  switch (c) {\n  case FL_CURSOR_ARROW:   cursor = [NSCursor arrowCursor]; break;\n  case FL_CURSOR_CROSS:   cursor = [NSCursor crosshairCursor]; break;\n  case FL_CURSOR_INSERT:  cursor = [NSCursor IBeamCursor]; break;\n  case FL_CURSOR_HAND:    cursor = [NSCursor pointingHandCursor]; break;\n  case FL_CURSOR_MOVE:    cursor = [NSCursor openHandCursor]; break;\n  case FL_CURSOR_NS:      cursor = [NSCursor resizeUpDownCursor]; break;\n  case FL_CURSOR_WE:      cursor = [NSCursor resizeLeftRightCursor]; break;\n  case FL_CURSOR_N:       cursor = [NSCursor resizeUpCursor]; break;\n  case FL_CURSOR_E:       cursor = [NSCursor resizeRightCursor]; break;\n  case FL_CURSOR_W:       cursor = [NSCursor resizeLeftCursor]; break;\n  case FL_CURSOR_S:       cursor = [NSCursor resizeDownCursor]; break;\n  default:\n    return 0;\n  }\n\n  [(NSCursor*)cursor retain];\n\n  [(NSWindow*)xid invalidateCursorRectsForView:[(NSWindow*)xid contentView]];\n\n  return 1;\n}\n\nint Fl_X::set_cursor(const Fl_RGB_Image *image, int hotx, int hoty) {\n  if (cursor) {\n    [(NSCursor*)cursor release];\n    cursor = NULL;\n  }\n\n  if ((hotx < 0) || (hotx >= image->w()))\n    return 0;\n  if ((hoty < 0) || (hoty >= image->h()))\n    return 0;\n\n  // OS X >= 10.6 can create a NSImage from a CGImage, but we need to\n  // support older versions, hence this pesky handling.\n\n  NSBitmapImageRep *bitmap = [[NSBitmapImageRep alloc]\n                              initWithBitmapDataPlanes:NULL\n                              pixelsWide:image->w()\n                              pixelsHigh:image->h()\n                              bitsPerSample:8\n                              samplesPerPixel:image->d()\n                              hasAlpha:!(image->d() & 1)\n                              isPlanar:NO\n                              colorSpaceName:(image->d()<=2) ? NSDeviceWhiteColorSpace : NSDeviceRGBColorSpace\n                              bytesPerRow:(image->w() * image->d())\n                              bitsPerPixel:(image->d()*8)];\n\n  // Alpha needs to be premultiplied for this format\n\n  const uchar *i = (const uchar*)*image->data();\n  unsigned char *o = [bitmap bitmapData];\n  for (int y = 0;y < image->h();y++) {\n    if (!(image->d() & 1)) {\n      for (int x = 0;x < image->w();x++) {\n        unsigned int alpha;\n        if (image->d() == 4) {\n          alpha = i[3];\n          *o++ = (unsigned char)((unsigned int)*i++ * alpha / 255);\n          *o++ = (unsigned char)((unsigned int)*i++ * alpha / 255);\n        }\n\n        alpha = i[1];\n        *o++ = (unsigned char)((unsigned int)*i++ * alpha / 255);\n        *o++ = alpha;\n        i++;\n  }\n    } else {\n      // No alpha, so we can just copy everything directly.\n      int len = image->w() * image->d();\n      memcpy(o, i, len);\n      o += len;\n      i += len;\n    }\n    i += image->ld();\n  }\n\n  NSImage *nsimage = [[NSImage alloc]\n                      initWithSize:NSMakeSize(image->w(), image->h())];\n\n  [nsimage addRepresentation:bitmap];\n\n  cursor = [[NSCursor alloc]\n            initWithImage:nsimage\n            hotSpot:NSMakePoint(hotx, hoty)];\n\n  [(NSWindow*)xid invalidateCursorRectsForView:[(NSWindow*)xid contentView]];\n\n  [bitmap release];\n  [nsimage release];\n\n  return 1;\n}\n\n@interface FLaboutItemTarget : NSObject \n{\n}\n- (void)showPanel;\n- (void)printPanel;\n@end\n@implementation FLaboutItemTarget\n- (void)showPanel\n{\n    NSDictionary *options;\n    options = [NSDictionary dictionaryWithObjectsAndKeys:\n\t       [[[NSAttributedString alloc] \n\t\tinitWithString:[NSString stringWithFormat:@\" GUI with FLTK %d.%d\", \n\t\tFL_MAJOR_VERSION, FL_MINOR_VERSION ]] autorelease], @\"Credits\",\n                \t     nil];\n    [NSApp orderFrontStandardAboutPanelWithOptions:options];\n}\n//#include <FL/Fl_PostScript.H>\n- (void)printPanel\n{  \n  Fl_Printer printer;\n  //Fl_PostScript_File_Device printer;\n  int w, h, ww, wh;\n  Fl_Window *win = Fl::first_window();\n  if(!win) return;\n  if( printer.start_job(1) ) return;\n  if( printer.start_page() ) return;\n  fl_lock_function();\n  // scale the printer device so that the window fits on the page\n  float scale = 1;\n  printer.printable_rect(&w, &h);\n  ww = win->decorated_w();\n  wh = win->decorated_h();\n  if (ww>w || wh>h) {\n    scale = (float)w/win->w();\n    if ((float)h/wh < scale) scale = (float)h/wh;\n    printer.scale(scale);\n    printer.printable_rect(&w, &h);\n  }\n//#define ROTATE 1\n#ifdef ROTATE\n  printer.scale(scale * 0.8, scale * 0.8);\n  printer.printable_rect(&w, &h);\n  printer.origin(w/2, h/2 );\n  printer.rotate(20.);\n#else\n  printer.origin(w/2, h/2);\n#endif\n  printer.print_window(win, -ww/2, -wh/2);\n  printer.end_page();\n  printer.end_job();\n  fl_unlock_function();\n}\n@end\n\nstatic void createAppleMenu(void)\n{\n  static BOOL donethat = NO;\n  if (donethat) return;\n  donethat = YES;\n  NSMenu *mainmenu, *services = nil, *appleMenu;\n  NSMenuItem *menuItem;\n  NSString *title;\n  \n  SEL infodictSEL = (fl_mac_os_version >= 100200 ? @selector(localizedInfoDictionary) : @selector(infoDictionary));\n  NSString *nsappname = [[[NSBundle mainBundle] performSelector:infodictSEL] objectForKey:@\"CFBundleName\"];  \n  if (nsappname == nil)\n    nsappname = [[NSProcessInfo processInfo] processName];\n  appleMenu = [[NSMenu alloc] initWithTitle:@\"\"];\n  /* Add menu items */\n  title = [NSString stringWithFormat:NSLocalizedString([NSString stringWithUTF8String:Fl_Mac_App_Menu::about],nil), nsappname];\n  menuItem = [appleMenu addItemWithTitle:title action:@selector(showPanel) keyEquivalent:@\"\"];\n  FLaboutItemTarget *about = [[FLaboutItemTarget alloc] init];\n  [menuItem setTarget:about];\n  [appleMenu addItem:[NSMenuItem separatorItem]];\n  // Print front window\n  title = NSLocalizedString([NSString stringWithUTF8String:Fl_Mac_App_Menu::print], nil);\n  if ([title length] > 0) {\n    menuItem = [appleMenu \n\t\taddItemWithTitle:title\n\t\taction:@selector(printPanel) \n\t\tkeyEquivalent:@\"\"];\n    [menuItem setTarget:about];\n    [appleMenu setAutoenablesItems:NO];\n    [menuItem setEnabled:YES];\n    [appleMenu addItem:[NSMenuItem separatorItem]];\n    }\n  if (fl_mac_os_version >= 100400) { // services+hide+quit already in menu in OS 10.3\n    // Services Menu\n    services = [[NSMenu alloc] init];\n    menuItem = [appleMenu \n\t\taddItemWithTitle:NSLocalizedString([NSString stringWithUTF8String:Fl_Mac_App_Menu::services], nil)\n\t\taction:nil \n\t\tkeyEquivalent:@\"\"];\n    [appleMenu setSubmenu:services forItem:menuItem];\n    [appleMenu addItem:[NSMenuItem separatorItem]];\n    // Hide AppName\n    title = [NSString stringWithFormat:NSLocalizedString([NSString stringWithUTF8String:Fl_Mac_App_Menu::hide],nil), nsappname];\n    [appleMenu addItemWithTitle:title \n\t\t\t action:@selector(hide:) \n\t\t  keyEquivalent:@\"h\"];\n    // Hide Others\n    menuItem = [appleMenu \n\t\taddItemWithTitle:NSLocalizedString([NSString stringWithUTF8String:Fl_Mac_App_Menu::hide_others] , nil)\n\t\taction:@selector(hideOtherApplications:) \n\t\tkeyEquivalent:@\"h\"];\n    [menuItem setKeyEquivalentModifierMask:(NSAlternateKeyMask|NSCommandKeyMask)];\n    // Show All\n    [appleMenu addItemWithTitle:NSLocalizedString([NSString stringWithUTF8String:Fl_Mac_App_Menu::show] , nil)\n\t\t\t action:@selector(unhideAllApplications:) keyEquivalent:@\"\"];\n    [appleMenu addItem:[NSMenuItem separatorItem]];\n    // Quit AppName\n    title = [NSString stringWithFormat:NSLocalizedString([NSString stringWithUTF8String:Fl_Mac_App_Menu::quit] , nil),\n\t     nsappname];\n    [appleMenu addItemWithTitle:title \n\t\t\t action:@selector(terminate:) \n\t\t  keyEquivalent:@\"q\"];\n    }\n  /* Put menu into the menubar */\n  menuItem = [[NSMenuItem alloc] initWithTitle:@\"\" action:nil keyEquivalent:@\"\"];\n  [menuItem setSubmenu:appleMenu];\n  mainmenu = [[NSMenu alloc] initWithTitle:@\"\"];\n  [mainmenu addItem:menuItem];\n  if (fl_mac_os_version < 100600) {\n    //\t[NSApp setAppleMenu:appleMenu];\n    //\tto avoid compiler warning raised by use of undocumented setAppleMenu\t:\n    [NSApp performSelector:@selector(setAppleMenu:) withObject:appleMenu];\n  }\n  [NSApp setMainMenu:mainmenu];\n  if (services) {\n    [NSApp setServicesMenu:services];\n    [services release];\n    }\n  [mainmenu release];\n  [appleMenu release];\n  [menuItem release];\n}\n\n\nvoid Fl_X::set_key_window()\n{\n  [xid makeKeyWindow];\n}\n\nstatic NSImage *imageFromText(const char *text, int *pwidth, int *pheight)\n{\n  const char *p, *q;\n  int width = 0, height, w2, ltext = strlen(text);\n  fl_font(FL_HELVETICA, 10);\n  p = text;\n  int nl = 0;\n  while(nl < 100 && (q=strchr(p, '\\n')) != NULL) { \n    nl++; \n    w2 = int(fl_width(p, q - p));\n    if (w2 > width) width = w2;\n    p = q + 1; \n  }\n  if (text[ ltext - 1] != '\\n') {\n    nl++;\n    w2 = int(fl_width(p));\n    if (w2 > width) width = w2;\n  }\n  height = nl * fl_height() + 3;\n  width += 6;\n  Fl_Offscreen off = Fl_Quartz_Graphics_Driver::create_offscreen_with_alpha(width, height);\n  fl_begin_offscreen(off);\n  CGContextSetRGBFillColor( (CGContextRef)off, 0,0,0,0);\n  fl_rectf(0,0,width,height);\n  fl_color(FL_BLACK);\n  p = text;\n  int y = fl_height();\n  while(TRUE) {\n    q = strchr(p, '\\n');\n    if (q) {\n      fl_draw(p, q - p, 3, y);\n    } else {\n      fl_draw(p, 3, y);\n      break;\n    }\n    y += fl_height();\n    p = q + 1;\n  }\n  fl_end_offscreen();\n  NSImage* image = CGBitmapContextToNSImage( (CGContextRef)off );\n  fl_delete_offscreen( off );\n  *pwidth = width;\n  *pheight = height;\n  return image;\n}\n\nstatic NSImage *defaultDragImage(int *pwidth, int *pheight)\n{\n  const int version_threshold = 100700;\n  int width, height;\n  if (fl_mac_os_version >= version_threshold) {\n    width = 50; height = 40;\n    }\n  else {\n    width = 16; height = 16;\n    }\n  Fl_Offscreen off = Fl_Quartz_Graphics_Driver::create_offscreen_with_alpha(width, height);\n  fl_begin_offscreen(off);\n  if (fl_mac_os_version >= version_threshold) {\n    fl_font(FL_HELVETICA, 20);\n    fl_color(FL_BLACK);\n    char str[4];\n    int l = fl_utf8encode(0x1F69A, str); // the \"Delivery truck\" Unicode character from \"Apple Color Emoji\" font\n    fl_draw(str, l, 1, 16);\n    }\n  else { // draw two squares\n    CGContextSetRGBFillColor( (CGContextRef)off, 0,0,0,0);\n    fl_rectf(0,0,width,height);\n    CGContextSetRGBStrokeColor( (CGContextRef)off, 0,0,0,0.6);\n    fl_rect(0,0,width,height);\n    fl_rect(2,2,width-4,height-4);\n  }\n  fl_end_offscreen();\n  NSImage* image = CGBitmapContextToNSImage( (CGContextRef)off );\n  fl_delete_offscreen( off );\n  *pwidth = width;\n  *pheight = height;\n  return image;\n}\n\nint Fl::dnd(void)\n{\n  CFDataRef text = CFDataCreate(kCFAllocatorDefault, (UInt8*)fl_selection_buffer[0], fl_selection_length[0]);\n  if (text==NULL) return false;\n  NSAutoreleasePool *localPool;\n  localPool = [[NSAutoreleasePool alloc] init]; \n  NSPasteboard *mypasteboard = [NSPasteboard pasteboardWithName:NSDragPboard];\n  [mypasteboard declareTypes:[NSArray arrayWithObject:utf8_format] owner:nil];\n  [mypasteboard setData:(NSData*)text forType:utf8_format];\n  CFRelease(text);\n  Fl_Widget *w = Fl::pushed();\n  Fl_Window *win = w->top_window();\n  NSView *myview = [Fl_X::i(win)->xid contentView];\n  NSEvent *theEvent = [NSApp currentEvent];\n  \n  int width, height;\n  NSImage *image;\n  if ( dynamic_cast<Fl_Input_*>(w) != NULL ||  dynamic_cast<Fl_Text_Display*>(w) != NULL) {\n    fl_selection_buffer[0][ fl_selection_length[0] ] = 0;\n    image = imageFromText(fl_selection_buffer[0], &width, &height);\n  } else {\n    image = defaultDragImage(&width, &height);\n  }\n  \n  static NSSize offset={0,0};\n  NSPoint pt = [theEvent locationInWindow];\n  pt.x -= width/2;\n  pt.y -= height/2;\n  [myview dragImage:image  at:pt  offset:offset \n              event:theEvent  pasteboard:mypasteboard  \n             source:myview  slideBack:YES];\n  if ( w ) {\n    int old_event = Fl::e_number;\n    w->handle(Fl::e_number = FL_RELEASE);\n    Fl::e_number = old_event;\n    Fl::pushed( 0 );\n  }\n  [localPool release];\n  return true;\n}\n\nstatic NSBitmapImageRep* rect_to_NSBitmapImageRep(Fl_Window *win, int x, int y, int w, int h)\n// the returned value is autoreleased\n{\n  NSRect rect;\n  NSView *winview = nil;\n  while (win->window()) {\n    x += win->x();\n    y += win->y();\n    win = win->window();\n  }\n  if ( through_drawRect ) {\n    CGFloat epsilon = 0;\n    if (fl_mac_os_version >= 100600) epsilon = 0.5; // STR #2887\n    rect = NSMakeRect(x - epsilon, y - epsilon, w, h);\n    }\n  else {\n    rect = NSMakeRect(x, win->h()-(y+h), w, h);\n    // lock focus to win's view\n    winview = [fl_xid(win) contentView];\n    [winview lockFocus];\n    }\n  NSBitmapImageRep *bitmap = [[[NSBitmapImageRep alloc] initWithFocusedViewRect:rect] autorelease];\n  if ( !through_drawRect ) [winview unlockFocus];\n  return bitmap;\n}\n\nunsigned char *Fl_X::bitmap_from_window_rect(Fl_Window *win, int x, int y, int w, int h, int *bytesPerPixel)\n/* Returns a capture of a rectangle of a mapped window as a pre-multiplied RGBA array of bytes.\n Alpha values are always 1 (except for the angles of a window title bar)\n so pre-multiplication can be ignored. \n *bytesPerPixel is always set to the value 4 upon return.\n delete[] the returned pointer after use\n */\n{\n  NSBitmapImageRep *bitmap = rect_to_NSBitmapImageRep(win, x, y, w, h);\n  if (bitmap == nil) return NULL;\n  *bytesPerPixel = [bitmap bitsPerPixel]/8;\n  int bpp = (int)[bitmap bytesPerPlane];\n  int bpr = (int)[bitmap bytesPerRow];\n  int hh = bpp/bpr; // sometimes hh = h-1 for unclear reason, and hh = 2*h with retina\n  int ww = bpr/(*bytesPerPixel); // sometimes ww = w-1, and ww = 2*w with retina\n  unsigned char *data;\n  if (ww > w) { // with a retina display\n    Fl_RGB_Image *rgb = new Fl_RGB_Image([bitmap bitmapData], ww, hh, 4);\n    Fl_RGB_Scaling save_scaling = Fl_Image::RGB_scaling();\n    Fl_Image::RGB_scaling(FL_RGB_SCALING_BILINEAR);\n    Fl_RGB_Image *rgb2 = (Fl_RGB_Image*)rgb->copy(w, h);\n    Fl_Image::RGB_scaling(save_scaling);\n    delete rgb;\n    rgb2->alloc_array = 0;\n    data = (uchar*)rgb2->array;\n    delete rgb2;\n  }\n  else {\n    data = new unsigned char[w * h *  *bytesPerPixel];\n    if (w == ww) {\n      memcpy(data, [bitmap bitmapData], w * hh *  *bytesPerPixel);\n    } else {\n      unsigned char *p = [bitmap bitmapData];\n      unsigned char *q = data;\n      for(int i = 0;i < hh; i++) {\n        memcpy(q, p, *bytesPerPixel * ww);\n        p += bpr;\n        q += w * *bytesPerPixel;\n      }\n    }\n  }\n  return data;\n}\n\nstatic void imgProviderReleaseData (void *info, const void *data, size_t size)\n{\n  delete[] (unsigned char *)data;\n}\n\nCGImageRef Fl_X::CGImage_from_window_rect(Fl_Window *win, int x, int y, int w, int h)\n// CFRelease the returned CGImageRef after use\n{\n  CGImageRef img;\n  if (fl_mac_os_version >= 100500) {\n    NSBitmapImageRep *bitmap = rect_to_NSBitmapImageRep(win, x, y, w, h);\n    img = (CGImageRef)[bitmap performSelector:@selector(CGImage)]; // requires Mac OS 10.5\n    CGImageRetain(img);\n    }\n  else {\n    int bpp;\n    unsigned char *bitmap = bitmap_from_window_rect(win, x, y, w, h, &bpp);\n    if (!bitmap) return NULL;\n    CGColorSpaceRef lut = CGColorSpaceCreateDeviceRGB();\n    CGDataProviderRef provider = CGDataProviderCreateWithData(NULL, bitmap, w*h*bpp, imgProviderReleaseData);\n    img = CGImageCreate(w, h, 8, 8*bpp, w*bpp, lut,\n\t\t\tbpp == 3 ? kCGImageAlphaNone : kCGImageAlphaPremultipliedLast,\n\t\t\tprovider, NULL, false, kCGRenderingIntentDefault);\n    CGColorSpaceRelease(lut);\n    CGDataProviderRelease(provider);\n   }\n  return img;\n}\n\nWindowRef Fl_X::window_ref()\n{\n  return (WindowRef)[xid windowRef];\n}\n\n// so a CGRect matches exactly what is denoted x,y,w,h for clipping purposes\nCGRect fl_cgrectmake_cocoa(int x, int y, int w, int h) {\n  return CGRectMake(x - 0.5, y - 0.5, w, h);\n}\n\nWindow fl_xid(const Fl_Window* w)\n{\n  Fl_X *temp = Fl_X::i(w);\n  return temp ? temp->xid : 0;\n}\n\nint Fl_Window::decorated_w()\n{\n  if (!shown() || parent() || !border() || !visible()) return w();\n  int bx, by, bt;\n  get_window_frame_sizes(bx, by, bt);\n  return w() + 2 * bx;\n}\n\nint Fl_Window::decorated_h()\n{\n  if (!shown() || parent() || !border() || !visible()) return h();\n  int bx, by, bt;\n  get_window_frame_sizes(bx, by, bt);\n  return h() + bt + by;\n}\n\nvoid Fl_Paged_Device::print_window(Fl_Window *win, int x_offset, int y_offset)\n{\n  NSButton *close = nil, *miniaturize = nil, *zoom = nil;\n  if (!win->shown() || win->parent() || !win->border() || !win->visible()) {\n    this->print_widget(win, x_offset, y_offset);\n    return;\n  }\n  int bx, by, bt, bpp;\n  get_window_frame_sizes(bx, by, bt);\n  Fl_Display_Device::display_device()->set_current(); // send win to front and make it current\n  const char *title = win->label();\n  win->label(\"\"); // temporarily set a void window title\n  win->show();\n  if (fl_mac_os_version >= 101000) {\n    // if linked for OS 10.10, capture of title bar does not capture the title bar buttons\n    // so we draw them in FLTK\n    NSWindow *xid = fl_xid(win);\n    close = [xid standardWindowButton:NSWindowCloseButton]; // 10.2\n    miniaturize = [xid standardWindowButton:NSWindowMiniaturizeButton];\n    zoom = [xid standardWindowButton:NSWindowZoomButton];\n    [close setHidden:YES]; // 10.3\n    [miniaturize setHidden:YES];\n    [zoom setHidden:YES];\n  }\n  fl_gc = NULL;\n  Fl::check();\n  BOOL to_quartz = dynamic_cast<Fl_Printer*>(this) != NULL;\n  // capture the window title bar with no title\n  CGImageRef img = NULL;\n  unsigned char *bitmap = NULL;\n  if (to_quartz)\n    img = Fl_X::CGImage_from_window_rect(win, 0, -bt, win->w(), bt);\n  else\n    bitmap = Fl_X::bitmap_from_window_rect(win, 0, -bt, win->w(), bt, &bpp);\n  win->label(title); // put back the window title\n  this->set_current(); // back to the Fl_Paged_Device\n  if (img && to_quartz) { // print the title bar\n    CGRect rect = { { x_offset, y_offset }, { win->w(), bt } };\n    Fl_X::q_begin_image(rect, 0, 0, win->w(), bt);\n    CGContextDrawImage(fl_gc, rect, img);\n    Fl_X::q_end_image();\n    CFRelease(img);\n  }\n  else if(!to_quartz) {\n    Fl_RGB_Image *rgb = new Fl_RGB_Image(bitmap, win->w(), bt, bpp);\n    rgb->draw(x_offset, y_offset);\n    delete rgb;\n    delete[] bitmap;\n  }\n  if (fl_mac_os_version >= 101000) { // print the title bar buttons\n    Fl_Color inactive = fl_rgb_color((uchar)0xCE, (uchar)0xCE, (uchar)0xCE); // inactive button color\n    Fl_Color redish, yellowish, greenish;\n    if ([[NSUserDefaults standardUserDefaults] integerForKey:@\"AppleAquaColorVariant\"] == 6) { // graphite appearance\n      redish = yellowish = greenish = fl_rgb_color((uchar)0x8C, (uchar)0x8C, (uchar)0x8C);\n    }\n    else {\n      redish = fl_rgb_color((uchar)0xFF, (uchar)0x63, (uchar)0x5A);\n      yellowish = fl_rgb_color((uchar)0xFF, (uchar)0xC6, (uchar)0x42);\n      greenish = fl_rgb_color((uchar)0x29, (uchar)0xD6, (uchar)0x52);\n    }\n    \n    if (![close isEnabled]) fl_color(inactive); else fl_color(redish);\n    fl_pie(x_offset+8, y_offset+5, 12, 12, 0, 360);\n    if (![miniaturize isEnabled]) fl_color(inactive); else fl_color(yellowish);\n    fl_pie(x_offset+28, y_offset+5, 12, 12, 0, 360);\n    if (![zoom isEnabled]) fl_color(inactive); else fl_color(greenish);\n    fl_pie(x_offset+48, y_offset+5, 12, 12, 0, 360);\n    \n    [close setHidden:NO]; // 10.3\n    [miniaturize setHidden:NO];\n    [zoom setHidden:NO];\n  }\n  if (title) { // print the window title\n    const int skip = 65; // approx width of the zone of the 3 window control buttons\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_4\n    if (fl_mac_os_version >= 100400 && to_quartz) { // use Cocoa string drawing with exact title bar font\n      // the exact font is LucidaGrande 13 pts (and HelveticaNeueDeskInterface-Regular with 10.10)\n      NSGraphicsContext *current = [NSGraphicsContext currentContext];\n      [NSGraphicsContext setCurrentContext:[NSGraphicsContext graphicsContextWithGraphicsPort:fl_gc flipped:YES]];//10.4\n      NSDictionary *attr = [NSDictionary dictionaryWithObject:[NSFont titleBarFontOfSize:0] \n\t\t\t\t\t\t       forKey:NSFontAttributeName];\n      NSString *title_s = [fl_xid(win) title];\n      NSSize size = [title_s sizeWithAttributes:attr];\n      int x = x_offset + win->w()/2 - size.width/2;\n      if (x < x_offset+skip) x = x_offset+skip;\n      NSRect r = {{x, y_offset+bt/2+4}, {win->w() - skip, bt}};\n      [[NSGraphicsContext currentContext] setShouldAntialias:YES];\n      [title_s drawWithRect:r options:(NSStringDrawingOptions)0 attributes:attr]; // 10.4\n      [[NSGraphicsContext currentContext] setShouldAntialias:NO];\n      [NSGraphicsContext setCurrentContext:current];\n    }\n    else\n#endif\n    {\n      fl_font(FL_HELVETICA, 14);\n      fl_color(FL_BLACK);\n      int x = x_offset + win->w()/2 - fl_width(title)/2;\n      if (x < x_offset+skip) x = x_offset+skip;\n      fl_push_clip(x_offset, y_offset, win->w(), bt);\n      fl_draw(title, x, y_offset+bt/2+4);\n      fl_pop_clip();\n    }\n  }\n  this->print_widget(win, x_offset, y_offset + bt); // print the window inner part\n}\n\n\n/* Returns the address of a Carbon function after dynamically loading the Carbon library if needed.\n Supports old Mac OS X versions that may use a couple of Carbon calls:\n GetKeys used by OS X 10.3 or before (in Fl::get_key())\n PMSessionPageSetupDialog and PMSessionPrintDialog used by 10.4 or before (in Fl_Printer::start_job())\n GetWindowPort used by 10.4 or before (in Fl_Gl_Choice.cxx)\n */\nvoid *Fl_X::get_carbon_function(const char *function_name) {\n  static void *carbon = NULL;\n  void *f = NULL;\n  if (!carbon) {\n    carbon = dlopen(\"/System/Library/Frameworks/Carbon.framework/Carbon\", RTLD_LAZY);\n  }\n  if (carbon) {\n    f = dlsym(carbon, function_name);\n  }\n  return f;\n}\n  \n/* Returns the version of the running Mac OS as an int such as 100802 for 10.8.2\n */\nstatic int calc_mac_os_version() {\n  int M, m, b = 0;\n  NSAutoreleasePool *localPool = [[NSAutoreleasePool alloc] init];\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_10\n  if ([NSProcessInfo instancesRespondToSelector:@selector(operatingSystemVersion)]) {\n    NSOperatingSystemVersion version = [[NSProcessInfo processInfo] operatingSystemVersion];\n    M = version.majorVersion;\n    m = version.minorVersion;\n    b = version.patchVersion;\n  }\n  else\n#endif\n  {\n    NSDictionary * sv = [NSDictionary dictionaryWithContentsOfFile:@\"/System/Library/CoreServices/SystemVersion.plist\"];\n    const char *s = [[sv objectForKey:@\"ProductVersion\"] UTF8String];\n    sscanf(s, \"%d.%d.%d\", &M, &m, &b);\n  }\n  [localPool release];\n  return M*10000 + m*100 + b;\n}\n\n#endif // __APPLE__\n\n//\n// End of \"$Id: Fl_cocoa.mm 10427 2014-11-02 21:06:07Z manolo $\".\n//\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/src/xutf8/test.c",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/src/xutf8/test2.c",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fluid_widget_gui.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fluid_widget_cxx.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/resizebox1.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fluid-gettext.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/counter.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fluid_prefs.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/FL200.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/tabs_default.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fl_input.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/Fl_Value_Output.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fluid4.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/FL.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/tree-simple.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/table-simple.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/hello_cxx.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/Fl_Tree_Item-dimensions.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/Fl_Scroll.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fl_show_colormap.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/resizebox2.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/scrollbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/editor-replace.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/positioner.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/value_slider.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/Fl_Tile.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/tabs_uniform.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/tree-dimensions.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/clock.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fluid-org.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/Fl_Check_Button.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/buttons.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/Fl_Value_Input.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/tabs.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fluid-catgets.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/valuators.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/Fl_Light_Button.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/menubar.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fl_color_chooser.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fl_ask.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/table-as-container.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/cubeview.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/choice.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fluid3-style.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/symbols.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/dial.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/round_clock.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fltk-colormap.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/Fl_Round_Button.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/tiny.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/editor.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/editor-linenumbers.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/Fl_Return_Button.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/Fl_Roller.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/Fl_File_Input.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/tree-elements.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/Fl_Native_File_Chooser.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/slider.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fl_choice.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/Fl_File_Chooser.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fluid3-cxx.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fluid2.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/input_choice.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/menu_button.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fl_message.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/tooltip-options.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fl_password.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/Fl_Spinner.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fl_alert.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fluid_widget_style.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fluid1.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/boxtypes.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/Fl_Help_Dialog.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/text.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/tabs_selection.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/table-dimensions.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/adjuster1.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/fluid3-gui.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/documentation/src/charts.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/fluid/icons/fluid-16i.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/fluid/icons/fluid.ico",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/fluid/icons/fluid-32.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/fluid/icons/fluid-256.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/fluid/icons/fluid-64.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/fluid/icons/fluid-16.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/fluid/icons/fluid.xcf.gz",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/fluid/icons/fluid-128.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/fluid/icons/fluid-48.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/fluid/icons/fluid-32i.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/fluid/fluid.app/Contents/Resources/fluid.icns",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/test/sudoku.ico",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/test/blocks.app/Contents/Resources/blocks.icns",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/test/desktop/blocks-128.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/test/desktop/blocks-32.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/test/desktop/checkers-128.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/test/desktop/sudoku-32.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/test/desktop/sudoku-128.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/test/desktop/checkers-32.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/test/sudoku.app/Contents/Resources/sudoku.icns",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/test/checkers.app/Contents/Resources/checkers.icns",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/test/pixmaps/block.xcf.gz",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/ide/Xcode4/icons/fluid.icns",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/ide/Xcode3/icons/fluid.icns",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/misc/cp1252.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/misc/cp1252.txt",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/misc/MacRoman_utf-8.png",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/misc/iso-8859-1.txt",
        "/tmp/vanessa/spack-stage/spack-stage-fltk-1.3.3-v3tpft3ofcut4gwuxnq5n7fhr3yh6btl/spack-src/misc/cp1252.html"
    ],
    "total_files": 1482
}