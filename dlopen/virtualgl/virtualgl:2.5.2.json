{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/ChangeLog.md": "2.5.2\n=====\n\n### Significant changes relative to 2.5.1:\n\n1. Previously, the VirtualGL faker opened a connection to the 3D X server\nwhenever an application called XOpenDisplay().  The faker now waits until the\n3D X server is actually needed before opening the connection.  This prevents\nnon-OpenGL X11 applications from opening unnecessary connections to the 3D X\nserver, which could exhaust the X server's limit of 256 connections if many\nusers are sharing the system.\n\n2. Fixed a regression caused by 2.4.1[6] whereby applications launched with\nVirtualGL on nVidia GPUs would fail to obtain a visual if `VGL_SAMPLES` was\ngreater than 0.  Multisampling cannot be used with Pixmap rendering, and\nbecause nVidia's drivers export different FB configs for `GLX_PBUFFER_BIT` and\n`GLX_PBUFFER_BIT|GLX_PIXMAP_BIT`, it is necessary to specify `GLX_PBUFFER_BIT`\nto obtain an FB config that supports multisampling.\n\n3. Fixed a regression caused by 2.4 beta1[2] whereby 32-bit Linux builds of\nVirtualGL built with recent compilers would sometimes crash when exiting\ncertain 3D applications (reported to be the case with Steam) or behave in other\nunpredictable ways.\n\n4. Fixed an issue whereby VirtualGL, when used with applications that load\nOpenGL functions via dlopen()/dlsym(), would fail to load the \"real\" GLX/OpenGL\nfunctions from libGL if libvglfaker.so was built with GCC 4.6 or later.\n\n5. Fixed various build issues with Clang.\n\n6. The interposed `dlopen()` function in the Linux version of libdlfaker.so\nwill now nullify the `RTLD_DEEPBIND` flag, if an application passes that flag\nto `dlopen()`.  This prevents an issue whereby an application could call\n`dlopen(..., *|RTLD_DEEPBIND)` to load a shared library that uses OpenGL or\nX11, thus causing the \"real\" OpenGL/GLX/X11 functions loaded by that shared\nlibrary to supercede VirtualGL's interposed functions, effectively disabling\nVirtualGL.\n\n7. Fixed an issue whereby VirtualGL would crash with a GLXBadContextState error\nif the 3D application set the render mode to something other than `GL_RENDER`\nprior to calling `glXSwapBuffers()`.\n\n\n2.5.1\n=====\n\n### Significant changes relative to 2.5:\n\n1. VirtualGL will no longer report the presence of the `GLX_EXT_swap_control`,\n`GLX_EXT_texture_from_pixmap`, or `GLX_SGI_swap_control` extensions to\napplications unless the underlying OpenGL library exports the necessary\nfunctions to support those extensions.  This fixes a regression introduced in\nVGL 2.4 that caused WINE to crash when running on a system whose OpenGL\nimplementation lacked the `glXSwapIntervalSGI()` and `glXSwapIntervalEXT()`\nfunctions.  Furthermore, VirtualGL will now report the presence of the\n`GLX_EXT_import_context` and `GLX_NV_swap_group` extensions to applications if\nthe underlying OpenGL library exports the necessary functions to support those\nextensions.\n\n2. Fixed compilation errors when building with GCC v6.\n\n3. vglserver_config is now SELinux-aware and will set up the proper file\ncontexts to allow vglgenkey to run within the GDM startup scripts.  This has\nbeen verified with Red Hat Enterprise Linux and work-alike systems (CentOS,\netc.), but unfortunately the version of GDM that ships in Fedora 22-24 does not\nexecute the GDM startup scripts at all.  At the moment, the only workaround for\nthose recent Fedora releases is to use LightDM.\n\n4. Fixed a deadlock that occurred when exiting ANSYS HFSS 2014.  This fix was\nan extension of 2.3.3[2], necessitated by the fact that MainWin calls X11\nfunctions from the destructor of one of its shared libraries, which is executed\nafter the VGL faker has shut down.  Because VGL 2.5.x enables the XCB\ninterposer by default, we have to ensure that any X11 and XCB functions hand\noff immediately to the underlying libraries after the faker has been shut down,\nbecause even if an X11 function is not interposed by VGL, some of the XCB\nfunctions it calls might be.  This issue was also known to affect ANSYS Maxwell\nand may have affected other applications that use MainWin.\n\n\n2.5\n===\n\n### Significant changes relative to 2.5 beta1:\n\n1. OS X 10.11 \"El Capitan\" no longer allows packages to install files under\n/usr/bin, and this was preventing the VirtualGL binary package for OS X from\ninstalling on that platform.  The symlinks to vglclient and vglconnect that the\nOS X package previously installed under /usr/bin have thus been removed in this\nversion of VirtualGL.  It will therefore be necessary to invoke vglconnect and\nvglclient using the full pathname (/opt/VirtualGL/bin/vglconnect or\n/opt/VirtualGL/bin/vglclient) or to add /opt/VirtualGL/bin to the PATH.\n\n2. Fixed a regression introduced by 2.5 beta1[13] that caused certain system\ncommands (such as uname, hostname, etc.) to crash when running those commands\nusing vglrun on current Arch Linux spins (glibc 2.22, GCC 5.2.)  This possibly\naffected other non-OpenGL, non-X11 applications on other bleeding-edge Linux\ndistributions as well.\n\n3. vglserver_config should now work properly with MDM (MATE Display Manager),\nif its config files are installed in the standard location (/etc/mdm).\n\n4. Fixed a regression introduced in 2.4 that caused vglrun to abort with\n`VGL_ISACTIVE=1: is not an identifier` when running on Solaris 10 (or other\nsystems in which /bin/sh doesn't support `export VAR=value` syntax.)\n\n5. Fixed a regression introduced by 2.5 beta1[3] whereby the VirtualGL faker\nwould segfault on Solaris if the 3D application called one of the GLX/OpenGL\nfunctions that VirtualGL interposes and the underlying OpenGL library (libGL)\ndid not implement that function.\n\n\n2.4.90 (2.5 beta1)\n==================\n\n### Significant changes relative to 2.4.1:\n\n1. librrfaker.so has been renamed to libvglfaker.so.  The \"rr\" designation\ndates from before VirtualGL was called \"VirtualGL\" (i.e. before it became an\nopen source project), and it is no longer relevant.\n\n2. The symlinks that VirtualGL previously installed for Chromium (the\nlong-obsolete parallel rendering package, not the web browser) are no longer\nincluded in this release.\n\n3. The mechanism by which VirtualGL loads \"real\" GLX, OpenGL, X11, and XCB\nfunctions from the respective system libraries has been refactored.  This has\nthe following ramifications:\n\n    - The \"real\" version of an interposed GLX/OpenGL/X11/XCB function will\nnever be loaded until the interposed function is called.\n    - `glXProcAddress[ARB]()` is now used to load all \"real\" GLX/OpenGL\nfunctions from libGL (except for the `glXProcAddress[ARB]()` function itself.)\nThis maintains the fixes implemented in 2.4[9] as well as the previous\nwork-arounds for certain buggy libGL implementations that do not export the\n`glXBindTexImageEXT()` and `glXReleaseTexImageEXT()` functions in the libGL\nsymbol table (the latter was specifically known to be an issue with certain\nversions of the ATI driver under Ubuntu.)\n    - If `-nodl` is passed to vglrun, then libGL will not be loaded into the\napplication process until/unless the application actually calls a GLX/OpenGL\nfunction.\n    - Because XCB functions are now loaded only when needed, the XCB interposer\nis no longer distribution-specific.  Therefore, it is now included in the\nofficial VirtualGL binaries.  Furthermore, since the loading and interposing of\nXCB symbols is now less intrusive, the XCB interposer is enabled by default (it\ncan be disabled with `vglrun -xcb`.)\n    - Reverted 2.1.3[8], since that fallback mechanism is no longer necessary\nwith modern versions of the nVidia driver.  The issue in question can still be\nworked around by explicitly setting `VGL_GLLIB` and `VGL_X11LIB`.\n\n4. Support for color index rendering emulation has been retired in this version\nof VirtualGL.  That feature will continue to be maintained in the 2.4.x branch\non a break/fix basis only.  Even when color index emulation was implemented in\nVGL 10 years ago, the applications that needed it were already extremely rare.\nSince then, color index rendering has been officially obsoleted in the OpenGL\nspec (as of version 3.1 in 2009), and modern Un*x graphics drivers no longer\nsupport it, nor do they generally support PseudoColor X visuals (nVidia still\nsupports these, but only with transparent overlays.)  Since there is generally\nno reasonable way to run color index OpenGL applications without using legacy\nhardware or software, it does not make sense to continue supporting these\napplications in this version of VirtualGL, particularly given that color index\nemulation adds a certain amount of overhead to some OpenGL calls.\n\n5. Added support for DirectColor rendering (DirectColor is similar to\nPseudoColor, except that the colormap indices for red, green, and blue can be\nspecified separately.)  GLXspheres now includes a DirectColor mode, replacing\nits previous color index mode.\n\n6. VirtualGL can now be disabled on a display-by-display basis by specifying a\nlist of X displays to exclude (see the documentation for the `VGL_EXCLUDE`\nenvironment variable.)  This is useful with multi-GPU systems on which a single\napplication may want to access the GPUs directly for parallel rendering\npurposes but use VirtualGL to display the final result.\n\n7. The vglconnect script now accepts an argument of `-e {command}`, which can\nbe used to specify a remote command to run.  This is useful for situations in\nwhich it is necessary to start a remote process non-interactively with\nvglconnect when using the `-s` or `-x` options.\n\n8. The `glXCreateWindow()` function no longer fails when passed the handle of\nan X window that was created in a different process or using XCB.  This\nspecifically fixes issues encountered when attempting to run VLC in VirtualGL,\nbut other applications may have been affected as well.\n\n9. Fixed a typo in /etc/udev/rules.d/99-virtualgl-dri.rules, which is created\nby vglserver_config.  More specifically, the typo caused incorrect group\npermissions to be assigned to the framebuffer device when not using the\nvglusers group.\n\n10. Certain applications (known to be the case with recent versions of Firefox\nwith off-main-thread compositing enabled) would crash with the following error\nwhen running in VirtualGL:\n\n        [VGL] ERROR: in readPixels--\n        [VGL]    XXX: VirtualDrawable instance has not been fully initialized\n\n    This was due to the application creating a GLX Pixmap and then calling\n`XCopyArea()` with the Pixmap prior to performing any OpenGL rendering with it.\nIn these cases, VirtualGL now treats the Pixmap as a 2D Pixmap until the\napplication has performed OpenGL rendering with it.\n\n11. glxinfo has been extended to report whether a particular GLX FB config\nsupports `GLX_BIND_TO_TEXTURE_RGB_EXT` and `GLX_BIND_TO_TEXTURE_RGBA_EXT`, i.e.\nwhether the FB config can be used with `GLX_EXT_texture_from_pixmap`.\n\n12. vglserver_config should now work properly with SDDM, if its scripts are\ninstalled in the standard location (/usr/share/sddm/scripts).\n\n13. Fixed a deadlock that occurred with applications that use MainWin, or any\nother OpenGL applications that load a shared library whose global constructor\ncalls one of the functions VirtualGL interposes.  This was known to affect\nMATLAB and ANSYS DesignModeler v16.1 and later, but it may have affected other\napplications as well.\n\n14. Fixed another deadlock that occurred when running ANSYS DesignModeler v16.1\nand later, or when running VirtualGL in a Parallels Desktop guest, when\nVirtualGL was built with `VGL_FAKEXCB=1` (which is the default.)\n\n15. Fixed a thread safety issue with PBO readback.  The PBO handle and other\nvariables related to PBO readback were being stored in static variables that\nwere shared among all OpenGL windows, contexts, and threads, and this was\nsuspected-- but not yet confirmed-- to have caused a \"Could not set PBO size\"\nerror with MetaPost.  This issue may have affected other multi-threaded\napplications as well.\n\n\n2.4.1\n=====\n\n### Significant changes relative to 2.4:\n\n1. When an application doesn't explicitly specify its visual requirements by\ncalling `glXChooseVisual()`/`glXChooseFBConfig()`, the default GLX framebuffer\nconfig that VirtualGL assigns to it now contains a stencil buffer.  This\neliminates the need to specify `VGL_DEFAULTFBCONFIG=GLX_STENCIL_SIZE,8` with\ncertain applications (previously necessary when running Abaqus v6 and MAGMA5.)\n\n2. VirtualGL will no longer advertise that it supports the\n`GLX_ARB_create_context` and `GLX_ARB_create_context_profile` extensions unless\nthe underlying OpenGL library exports the `glXCreateContextAttribsARB()`\nfunction.\n\n3. Fixed \"Invalid MIT-MAGIC-COOKIE-1\" errors that would prevent VirtualGL from\nworking when vglconnect was used to connect to a VirtualGL server from a client\nrunning Cygwin/X.\n\n4. If a 3D application is rendering to the front buffer and one of the\nend-of-frame trigger functions (`glFlush()`/`glFinish()`/`glXWaitGL()`) is\ncalled, VirtualGL will no longer read back the framebuffer unless the render\nmode is `GL_RENDER`.  Reading back the front buffer when the render mode is\n`GL_SELECT` or `GL_FEEDBACK` is not only unnecessary, but it was known to cause\na GLXBadContextState error with newer nVidia drivers (340.xx and later) in\ncertain cases.\n\n5. Fixed a deadlock that occurred in the multi-threaded rendering test of\nfakerut when it was run with the XCB interposer enabled.  This was due to\nVirtualGL attempting to handle XCB events when Xlib owned the event queue.  It\nis possible that this issue affected or would have affected real-world\napplications as well.\n\n6. Fixed an issue that caused certain 3D applications (observed with\nCAESES/FFW, although others were possibly affected as well) to abort with\n`ERROR: in TempContext-- Could not bind OpenGL context to window (window may\nhave disappeared)`.  When the 3D application called `glXChooseVisual()`,\nVirtualGL was choosing a corresponding FB config with\n`GLX_DRAWABLE_TYPE=GLX_PBUFFER_BIT` (assuming that `VGL_DRAWABLE=pbuffer`,\nwhich is the default.)  This is incorrect, however, because regardless of the\nvalue of `VGL_DRAWABLE`, VirtualGL still uses Pixmaps on the 3D X server to\nrepresent GLX Pixmaps (necessary in order to make `GLX_EXT_texture_from_pixmap`\nwork properly.)  Thus, VGL now chooses an FB config that supports both Pbuffers\nand Pixmaps.  This was generally only a problem with nVidia drivers, because\nthey export different FB configs for `GLX_PBUFFER_BIT` and\n`GLX_PBUFFER_BIT|GLX_PIXMAP_BIT`.\n\n\n2.4\n===\n\n### Significant changes relative to 2.4 beta1:\n\n1. Fixed an issue that prevented recent versions of Google Chrome/Chromium from\nrunning properly in VirtualGL.\n\n2. `VGL_SYNC` now affects `glFlush()`.  Although this does not strictly conform\nto the OpenGL spec (`glFlush()` is supposed to be an asynchronous command), it\nwas necessary in order to make certain features of Cadence Allegro work\nproperly.  Since virtually no applications require `VGL_SYNC`, it is believed\nthat this change is innocuous.\n\n3. Fixed a regression in vglconnect (introduced in VirtualGL 2.3) that\nprevented `vglconnect -x` from working properly if the user did not have access\nto the current directory (vglconnect was erroneously creating a temporary file\nin the current directory instead of in /tmp.)\n\n4. GLXspheres now warns if the specified polygon count would exceed the limit\nof 57600 polygons per sphere imposed by GLU and prints the actual polygon count\nwith this limit taken into account.  Also, a new option (`-n`) has been\nintroduced to increase the sphere count.\n\n5. VirtualGL will now only enable color index rendering emulation if a color\nindex context is current.  This specifically fixes an interaction issue with\nMSC Mentat, which occasionally calls `glIndexi()` when an RGBA context is\ncurrent, but the fix may affect other applications as well.\n\n6. VirtualGL can now interpose enough of the XCB API to make Qt 5 work\nproperly.  Qt 5 does not use XCB to perform 3D rendering (there is no suitable\nXCB replacement for GLX yet), but it does use XCB to detect whether the GLX\nextension is available and to handle the application's event queue(s).  Thus,\nwhen attempting to run Qt 5 applications in VirtualGL, previously the OpenGL\nportion of the window would fail to resize when the window was resized, or the\napplication would complain that OpenGL was not available and fail to start, or\nthe application would fall back to non-OpenGL rendering.\n\n    Currently, enabling XCB support in VirtualGL requires building VirtualGL\nfrom source and adding `-DVGL_FAKEXCB=1` to the CMake command line.  The XCB\ninterposer is also disabled by default at run time.  It must be enabled by\nsetting the `VGL_FAKEXCB` environment variable to `1` or passing `+xcb` to\nvglrun.\n\n7. Fixed a deadlock that occurred when running compiz 0.9.11 (and possibly\nother versions as well) with VirtualGL.  The issue occurred when compiz called\n`XGrabServer()`, followed by `glXCreatePixmap()` and `glXDestroyPixmap()`.  In\nVirtualGL, a GLX pixmap resides on the 3D X server, but the corresponding X11\npixmap resides on the 2D X server.  Thus, VirtualGL has to synchronize pixels\nbetween the two pixmaps in response to certain operations, such as\n`XCopyArea()` and `XGetImage()`, or when the GLX pixmap is destroyed.\nVirtualGL was previously opening a new connection to the 2D X server in order\nto perform this synchronization, and because the 2D X server was grabbed,\ncompiz locked up when VirtualGL called `XCloseDisplay()` on the new display\nconnection.  In fact, however, the new display connection was unnecessary,\nsince the GLX/X11 pixmap synchronization occurs within the 3D rendering thread.\nThus, VirtualGL now simply reuses the same display connection that was passed\nto `glXCreate[GLX]Pixmap()`.\n\n8. NetTest and TCBench for Windows are now supplied in a package called\nVirtualGL-Utils, which can be built from the VirtualGL source.  When the\nVirtualGL Client for Exceed was discontinued, these utilities ceased to have a\nhome, but they are still useful tools to have, irrespective of the thin client\nsolution that is being used.  The Windows build of TCBench was temporarily\nmoved into the Windows TurboVNC Viewer packages, but it proved to be a pain to\nkeep the source code synchronized between the two projects.\n\n    The VirtualGL-Utils package additionally contains a WGL version of\nGLXspheres, which is a useful tool to have when benchmarking Windows virtual\nmachines that are running in a VirtualGL environment.\n\n9. Worked around an issue in recent versions of SPECviewperf and FEMFAT\nvisualizer that caused them to segfault when used with VirtualGL.  Those\napplications apparently use a dynamic loading mechanism for OpenGL extension\nfunctions, and this mechanism defines symbols such as \"glGenBuffers\" at file\nscope.  Any symbol exported by an application will override a symbol of the\nsame name exported by a shared library, so when VirtualGL tried to call\n`glGenBuffers()`, `glBindBuffer()`, etc., it was picking up the symbols from\nthe application, not from libGL (and those symbols from the application were\nnot necessarily defined.)  VirtualGL now obtains the function pointers it needs\nfor PBO readback directly from libGL using `glXProcAddress()`, rather than\nrelying on the dynamic linker to resolve them.  Note that this issue could be\nworked around in previous versions of VirtualGL by setting `VGL_READBACK=sync`.\n\n\n2.3.90 (2.4 beta1)\n==================\n\n### Significant changes relative to 2.3.3:\n\n1. The VirtualGL Client for Exceed has been retired.  It will continue to be\nmaintained in the 2.3.x branch on a break/fix basis only.  Cygwin/X has matured\nto the point that it now provides an adequate solution for using the VirtualGL\nClient on Windows, with the only major limitation being lack of quad-buffered\nstereo support.  That feature alone is insufficient to justify a code base\nthat is basically twice as complex as it otherwise would be.  Furthermore, we\nare now maintaining our own Cygwin repository for the VirtualGL Client, which\nmakes it relatively easy to install on that platform.\n\n    The VirtualGL Client for Exceed reflects VirtualGL's origins as an add-on\ntechnology for existing remote X environments.  These days, most people use\nVirtualGL with some sort of X proxy instead.  There have been no significant\nchanges to vglclient since version 2.2.1, as most of the efforts of The\nVirtualGL Project in recent years have focused on the server-side components\nand TurboVNC.  In the early days of the project, there were performance\nadvantages to the VGL Transport, but that is no longer the case.  In fact,\nTurboVNC will generally do a better and faster job of compressing the image\nstream, since it uses a hybrid compression scheme rather than pure JPEG.\n\n    The native Windows version of TCBench, which previously shipped with the\nVirtualGL Client for Exceed, has been moved into the Windows TurboVNC Viewer\npackage.\n\n2. The VirtualGL source code has been extensively refactored to use more modern\nvariable, class, and method naming conventions, and automated test scripts for\nthe utility libraries and the faker have been added.\n\n3. `glXChooseFBConfig()` now properly handles the `GLX_FBCONFIG_ID` attribute.\nThe improper handling of this attribute was known to cause an error\n(`Could not find GLX 1.3 config from peer info`) when running the LWJGL\n(Lightweight Java Game Library) on AMD GPUs, but it may have affected other\napps as well.\n\n4. The performance of PBO readback on ATI FirePro adapters has been improved\ndramatically (close to an order of magnitude.)\n\n5. vglserver_config will now set DRI device permissions properly on systems\nthat lack an xorg.conf file but have an xorg.conf.d directory.\n\n6. vglserver_config should now work with recent Debian releases.\n\n7. Fixed an issue whereby VirtualGL would not always resize the Pbuffer\ncorresponding to an Xt or Motif OpenGL widget whenever the widget was resized.\n\n8. The Mac packaging system now uses pkgbuild and productbuild rather than\nPackageMaker (which is obsolete and no longer supported.)  This means that\nOS X 10.6 \"Snow Leopard\" or later must be used when packaging VirtualGL,\nalthough the packages produced can be installed on OS X 10.5 \"Leopard\" or\nlater.  OS X 10.4 \"Tiger\" is no longer supported.\n\n9. The \"Uninstall VirtualGL\" app should once again work on OS X 10.5.\n\n10. Fixed an infinite drawing loop that occurred when running Altair HyperBeam\nwith VirtualGL.  Since 2.1.3, VirtualGL has been setting the `WM_DELETE_WINDOW`\nproperty on any OpenGL window so that it (VGL) can be notified if the window\nmanager deletes the window (thus preventing VGL from trying to draw to the\nwindow after it disappears.)  This was originally done within the body of\n`XCreate[Simple]Window()`, but Java did not like us overriding the property for\n2D windows (refer to 2.3.1[9].)  Thus, the setting of `WM_DELETE_WINDOW` was\nmoved into the body of `glXMake[Context]Current()` so that it would affect only\nOpenGL windows.  However, VGL was incorrectly replacing the list of WM\nprotocols rather than simply adding `WM_DELETE_WINDOW` to the existing list.\nVGL was also not checking whether `WM_DELETE_WINDOW` already existed in the\nlist before adding it.  For reasons that are not well understood, this caused\nHyperBeam to get into an infinite loop, because calling `XSetWMProtocols()`\nwithin the body of `glXMakeCurrent()` seemed to cause the application to call\n`glXMakeCurrent()` again.  This issue may have affected other applications as\nwell.\n\n11. Fixed an issue whereby the RPMs generated by VirtualGL's packaging system\n(including the official RPMs for VGL 2.3.2 and 2.3.3) could not be installed on\nlater Fedora releases.\n\n12. Fixed an issue whereby `glXSwapBuffers()` would not work properly unless\nthe drawable passed to that function was current.  This specifically fixes a\nrendering issue with voreen, but it may have affected other apps as well.\n\n13. Fixed an issue that prevented vglgenkey from working properly on Red Hat\nEnterprise Linux 7.\n\n14. Fixed an issue that prevented vglserver_config from working properly on\nUbuntu 14.04.\n\n\n2.3.3\n=====\n\n### Significant changes relative to 2.3.2:\n\n1. VirtualGL will no longer throw an exception if a 3D application calls\ncertain X11 and GLX functions with a NULL argument.  It will instead allow the\nunderlying X11 or GLX library to handle the error.  This specifically works\naround an issue with Fiji.\n\n2. Worked around an issue whereby, when ANSYS Workbench 14.5 was run with\nVirtualGL, subprocesses (such as the geometry editor) launched from within the\nWorkbench environment would not exit properly (and thus would become zombies.)\nThis issue also affected ANSYS HFSS, which would either lock up when exiting or\nprint an error message:\n`terminate called after throwing an instance of 'rrerror'`.\n\n3. Worked around an issue whereby, when using MAGMA5 with VirtualGL, the second\nand subsequent perspectives opened within the application would not always\ndisplay correctly.\n\n4. Added support for the `GLX_EXT_texture_from_pixmap` extension.\n\n5. Added support for the `GLX_EXT_swap_control` and `GLX_SGI_swap_control`\nextensions and a new configuration variable (`VGL_REFRESHRATE`) that can be\nused to control them.  See the User's Guide for more information.\n\n6. Added support for depth=32 visuals and FB configs.\n\n7. Added a new \"window manager\" mode that disables certain features in\nVirtualGL that interfere with 3D window managers such as compiz.  This,\ncombined with [6] and [4] above, should allow compiz to run properly with this\nversion of VirtualGL, provided that the 2D X Server has support for the X\nComposite extension.  See the User's Guide for more information.\n\n8. Fixed a BadDrawable X11 error that occurred when running the Steam client in\nVirtualGL.\n\n9. Improved the accuracy of TCBench and CPUstat.\n\n10. Streamlined VirtualGL's behavior when it is installed from source:\n\n    - vglrun now works regardless of where the faker libraries have been\ninstalled.  The build system hard-codes the value of the `VGL_LIBDIR` CMake\nvariable into a script that vglrun invokes so that it can add this directory to\n`LD_LIBRARY_PATH`.   If the faker libraries are installed into a system library\ndirectory, then packagers can choose to omit the new script, and vglrun will\ncontinue to work as it always has.\n    - Whenever a 64-bit build is installed, glxspheres is now renamed\nglxspheres64, per the convention of the official packages.  This makes it\npossible to install a 32-bit and a 64-bit version of VirtualGL into the same\ndirectory.\n    - If the install prefix is set to the default (/opt/VirtualGL), then the\nbuild system defaults to installing faker libraries from a 32-bit build into\n/opt/VirtualGL/lib32 and faker libraries from a 64-bit build into\n/opt/VirtualGL/lib64.\n    - Similarly, if the install prefix is set to the default (/opt/VirtualGL),\nthen the build system defaults to installing the 32-bit libGL symlink for\nChromium into /opt/VirtualGL/fakelib32 and the 64-bit libGL symlink for\nChromium into /opt/VirtualGL/fakelib64.\n\n11. PBO readback mode is now enabled by default.  Further research has shown\nthat professional-grade GPUs always benefit from PBOs being enabled (quite\ndramatically, in the case of AMD FirePro adapters.)  With consumer-grade AMD\nadapters, PBOs generally do no harm, and with consumer-grade nVidia (GeForce)\nadapters, the results are mixed.  The GeForce drivers will fall back to\nblocking readbacks if the pixel format requested in `glReadPixels()` doesn't\nmatch the pixel format of the Pbuffer, so PBOs will generally be slower in\nthose cases.  Thus, VirtualGL now falls back to synchronous readback mode if it\ndetects that PBOs are not behaving asynchronously.\n\n    Furthermore, `VGL_FORCEALPHA` is no longer enabled by default when PBOs are\nenabled.  This option was introduced because of the GeForce behavior mentioned\nabove, but the option has no effect whatsoever with the professional-grade GPUs\nthat are recommended for use with VirtualGL.  Instead, VGL will now detect\nsituations in which `VGL_FORCEALPHA` might be beneficial and suggest enabling\nor disabling it (if `VGL_VERBOSE=1`.)\n\n12. This version of VirtualGL provides a binary package and full support for\nCygwin64.\n\n\n2.3.2\n=====\n\n### Significant changes relative to 2.3.1:\n\n1. Added new stereo options, including green/magenta and blue/yellow anaglyphic\nas well as three half-resolution passive stereo options that can be used to\ndrive 3D TV's.\n\n2. The 32-bit supplementary package for amd64 Debian systems should now work\nproperly on MultiArch-compatible systems (such as Ubuntu 11 and later.)\n\n3. vglserver_config should now work properly with LightDM.\n\n4. VirtualGL was not advertising that it supported the\n`GLX_ARB_create_context_profile` extension, even though it does.  This has been\nfixed.\n\n5. VirtualGL now uses a separate OpenGL context to perform pixel readback.\nThis fixes several issues, including an error\n(`GL_ARB_pixel_buffer_object extension not available`) when trying to enable\nPBO readback with applications that use a 3.x or later OpenGL core profile, and\nincorrect rendering in JPCSP and other applications that modify certain pixel\nstore parameters (such as `GL_PACK_SWAP_BYTES` or `GL_PACK_ROW_LENGTH`) that\nVirtualGL wasn't properly handling.\n\n6. `VGL_FORCEALPHA=1` now works properly if the 3D application specifies visual\nattributes of `GLX_RED_SIZE`=`GLX_GREEN_SIZE`=`GLX_BLUE_SIZE`=`1`.\n\n7. `glXUseXFont()` has been extended to work with Pbuffers.  Due to an\noversight, VirtualGL would previously abort with an error message if the 3D\napplication attempted to render text to a Pbuffer that it created.\n\n8. Fixed an issue whereby, when displaying to a 2D X server that lacked the\nMIT-SHM extension, the X11 Transport would sometimes fail to resize its\ninternal Pixmap (used for double buffering) whenever the X window was resized.\nThis specifically caused OpendTect to display only a portion of its 3D view\nwhenever it resized its 3D window after a \"Restore\" operation, but the issue\nmay have affected other applications as well.\n\n9. Previously, 3D applications running in VirtualGL could not successfully use\n`XGetImage()` to obtain the rendered 3D pixels from a GLX pixmap.  This has\nbeen fixed.\n\n10. vglrun now automatically sets an environment variable that disables the\nexecution of the VBoxTestOGL program in VirtualBox 4.2 and later.  Since\n`LD_PRELOAD` is not propagated down to VBoxTestOGL whenever VirtualBox launches\nit (because VirtualBox is a setuid-root executable), VBoxTestOGL always fails\nin a VirtualGL environment, which makes VirtualBox believe that the system has\nno 3D support.  With version 4.1.10, VirtualBox began running VBoxTestOGL every\ntime a VM was launched, which effectively prevented VBox from being used with\nVirtualGL unless the user hacked their system by symlinking /bin/true to\n/usr/lib/virtualbox/VBoxTestOGL.\n\n\n2.3.1\n=====\n\n### Significant changes relative to 2.3:\n\n1. Worked around a segfault that occurred when running CoreBreach.\n\n2. VirtualGL now properly handles implicit deletion of windows/subwindows via\n`XCloseDisplay()`, implicit deletion of subwindows via `XDestroyWindow()`, and\nexplicit deletion of subwindows via `XDestroySubwindows()`.  This specifically\naddresses BadDrawable errors that occurred when running certain applications\nin WINE 1.3.34 and later.\n\n3. Fixed a crash in `glXCreateGLXPbufferSGIX()` that occurred when a NULL\nattribute list pointer was passed to it.\n\n4. VirtualGL should now build and run properly on FreeBSD.\n\n5. VirtualGL now works properly with applications that dynamically load libX11.\nThis specifically fixes several issues that occurred when running SDL-based\napplications against a version of libSDL that was configured with\n`--enable-x11-shared`.\n\n6. Changed the Debian package names to lowercase (\"virtualgl\" and\n\"virtualgl32\") to avoid an issue whereby the package was always being\ninstalled, even if the installed version was up to date.\n\n7. vglserver_config now works properly with KDM on RHEL/CentOS 5 systems.\n\n8. Added a new option (`VGL_GLFLUSHTRIGGER`) that, when set to `0`, will cause\nVirtualGL to ignore `glFlush()` commands from the 3D application.  This is\nintended for rare applications that do front buffer rendering and use\n`glFlush()` as an \"intermediate\" synchronization command but then subsequently\ncall `glFinish()` to indicate the end of the frame.\n\n9. Fixed an issue whereby drag & drop operations in certain Java applications\nwould cause VNC servers (any VNC server, not just TurboVNC) to hang whenever\nthe Java application was run using VirtualGL.\n\n\n2.3\n===\n\n### Significant changes relative to 2.3 beta1:\n\n1. Fixed a regression whereby GLXSpheres would ignore the first argument after\n`-fs`.\n\n2. `glXChooseFBConfig()` and `glXChooseFBConfigSGIX()` were erroneously\nreturning an error when a NULL attribute list pointer was passed to them.  They\nnow behave correctly.\n\n3. Fixed a regression whereby VirtualGL would deadlock when using the X11\nTransport with a remote X connection.\n\n4. Fixed a `GL_INVALID_OPERATION` error that would occur after a call to\n`glXSwapBuffers()`, when a context with the OpenGL Core Profile was being used.\n\n5. Fixed an issue whereby VirtualGL, when compiled with GCC 4.6, would abort\nwith `terminate called after throwing an instance of 'rrerror'` whenever a 3D\napplication running in VirtualGL exited.\n\n6. Added a new configuration option (`VGL_DEFAULTFBCONFIG`) that can be used\nto manually specify the rendering attributes of the default FB config that\nVirtualGL uses whenever a 3D application does not specify a desired set of\nvisual attributes (which it would normally do by calling `glXChooseVisual()`.)\nRefer to the User's Guide for more information.\n\n7. Worked around an issue whereby using very large fonts with `glXUseXFont()`\nwould cause Pixmap allocation failures with certain X servers.\n\n\n2.2.90 (2.3 beta1)\n==================\n\n### Significant changes relative to 2.2.1:\n\n1. Re-fixed issue that caused MainWin-based applications to hang.  This was\ninitially fixed in VGL 2.1 final, but it was re-broken by the rewrite of the\nglobal faker configuration routines in VGL 2.2.\n\n2. Overhauled the way in which VirtualGL handles Pixmap rendering, mainly to\nfix interaction issues with Mathematica.\n\n3. Added an option (`VGL_ALLOWINDIRECT`) that, when enabled, will cause\nVirtualGL to honor an application's request to create an indirect OpenGL\ncontext.  Normally VirtualGL forces all contexts to be direct for performance\nreasons, but this causes problems with certain applications (notably\nMathematica 7.)\n\n4. Added two new command-line options to GLXSpheres that allow the window size\nto be changed and the total number of frames to be specified (the application\nwill abort after the total number of frames has been rendered.)\n\n5. VirtualGL will no longer die if `glXGetConfig()` or `glXGetFBConfigAttrib()`\nis passed a NULL argument.\n\n6. Fixed a BadMatch X11 error that occurred when an application attempted to\napply a new OpenGL rendering context to a drawable and the FB config of the new\nOpenGL context differed from that of a context that was previously applied to\nthe same drawable.  This specifically was known to affect D3D applications\nrunning in WINE.\n\n7. CMake-based build and packaging system\n\n8. TCBench now takes 100 samples/second by default instead of 50.\n\n9. Added support for the `GLX_ARB_create_context` extension.\n\n\n2.2.1\n=====\n\n### Significant changes relative to 2.2:\n\n1. A 64-bit version of the VirtualGL Client for Exceed is now fully supported.\n\n2. Fixed a severe readback performance problem that occurred whenever an\napplication set the render mode to `GL_SELECT` and called `glFlush()` while\ndoing front buffer rendering.\n\n3. vglserver\\_config will now work properly whenever vglgenkey is installed in\na directory other than /usr/bin or /opt/VirtualGL/bin, as long as vglgenkey is\ninstalled in the same directory as vglserver_config.\n\n4. vglconnect now allows the user to specify the directory in which VirtualGL\nbinaries are installed on the server, rather than always assuming that they are\ninstalled in /opt/VirtualGL/bin.\n\n5. Fixed issues with vglconnect.bat that occurred when it was installed under\nc:\\Program Files (x86) on 64-bit Windows systems and invoked with the `-x` or\n`-s` options.\n\n6. Clarified the documentation of the `VGL_DISPLAY` option and documented how\nto use VirtualGL with multiple graphics cards.\n\n7. VirtualGL will no longer die if `glXDestroyContext()` is passed a NULL\nargument.\n\n8. Fixed a BadWindow error that would occur whenever a 3D application attempted\nto call `glXSwapIntervalSGI()` (specifically, this was observed when running\nDirect3D applications using WINE 1.3.11 or later.)  The nVidia GLX\nimplementation requires that a window be current (not a Pbuffer) when calling\n`glXSwapIntervalSGI()`, so VirtualGL now interposes that function and makes it\na no-op.\n\n9. Fixed an issue whereby, if a 3D application set\n`GL_(RED|GREEN|BLUE|ALPHA)_SCALE` or `GL_(RED|GREEN|BLUE|ALPHA)_BIAS` to\nnon-default values, the colors would appear wrong when running the application\nin VirtualGL, and the readback performance would be very slow.\n\n10. Fixed an issue whereby 3D applications that requested an overlay visual\nwould fail with BadRequest or other X11 errors if the 2D X server lacked GLX\nsupport (as is the case with TurboVNC.)  This was caused by the fact that\nVirtualGL passes through `glXChooseVisual()` and related calls to the 2D X\nserver if it detects that an overlay visual is being requested.  Now, VirtualGL\nwill first check that the 2D X server supports GLX before passing through those\ncalls.\n\n11. `vglclient -kill` and `vglclient -killall` now work (again) in the Exceed\nclient.\n\n\n2.2\n===\n\n### Significant changes relative to 2.2 beta1:\n\n1. Added an environment variable (`VGL_SPOILLAST`) which, when set to `0`, will\nchange the frame spoiling algorithm used for frames triggered by `glFlush()`\ncalls.  This is necessary to make Ansoft HFSS render properly.\n\n2. Added a compatibility mode to allow NetTest to communicate with older\nversions of itself (from VGL 2.1.x and prior.)\n\n3. Fixed a race condition in vglclient that would frequently cause an\n\"incorrect checksum for freed object\" error when the client was shut down via\nCTRL-C.  This problem was reported only on OS X but could have existed on other\nplatforms as well.\n\n\n2.1.90 (2.2 beta1)\n==================\n\n### Significant changes relative to 2.1.4:\n\n1. Added an option (`VGL_LOGO`) that, when enabled, will cause VirtualGL to\ndisplay a logo in the bottom right-hand corner of the 3D window.  This is meant\nas a debugging tool to allow users to determine whether or not VirtualGL is\nactive.\n\n2. Support for encrypting the VGL Transport with OpenSSL has been removed from\nthe official VirtualGL packages.  It was only a marginally useful feature,\nbecause VirtualGL also has the ability to tunnel the VGL Transport through SSH.\nIt was necessary to maintain our own static OpenSSL libraries on Linux in\norder to provide a version of VirtualGL that was compatible across all Linux\nplatforms, and this required us to keep abreast of the latest OpenSSL security\nfixes, etc.  OpenSSL support can easily be re-added by building VirtualGL from\nsource (see [BUILDING.md](BUILDING.md).)\n\n3. Added a framework for creating generic image transport plugins.  See\n[server/rrtransport.h](server/rrtransport.h) for a description of the API.\n\n4. Removed support for the proprietary Sun Ray plugin, since that plugin is no\nlonger available from Sun.\n\n5. For Linux, Mac/Intel, Solaris/x86, and Windows systems, the default build of\nVirtualGL no longer uses TurboJPEG/IPP (which was based on the proprietary\nIntel Performance Primitives) or Sun mediaLib.  Instead, VirtualGL now uses\nlibjpeg-turbo, a fully open source SIMD-accelerated JPEG codec developed in\nconjunction with the TigerVNC Project (and based on libjpeg/SIMD.)\n\n    As a result of this, it is no longer necessary to install a separate\nTurboJPEG package on Linux systems.\n\n6. Added a universal 32/64-bit VirtualGL Client binary for OS X.  The 32-bit\nfork works on 10.4 \"Tiger\" or later, and the 64-bit fork works on 10.5\n\"Leopard\" or later.\n\n7. Added support for encoding 3D images as I420 YUV and displaying them through\nX Video.  The images can either be displayed directly to the 2D X server or\nsent through the VGL transport for display using vglclient.  See the User's\nGuide for more details.\n\n8. Renamed /etc/modprobe.d/virtualgl to /etc/modprobe.d/virtualgl.conf to\ncomply with the Ubuntu standard.\n\n9. Added an environment variable (`VGL_SAMPLES`) and command-line switch\n(`vglrun -ms`) to force VirtualGL to select a multisampled visual or override\nthe level of multisampling selected by the 3D application.\n\n10. The uninstall script in the Mac binary package should now work on OS X\n10.6.\n\n11. VirtualGL can now use pixel buffer objects (PBO's) to accelerate the\nreadback of the rendered 3D pixels.  This particularly helps when multiple\nusers are sharing the GPU.  See the \"Advanced Configuration\" section of the\nUser's Guide for more information.\n\n12. On Linux systems, this version of VirtualGL works around the interaction\nissues between libdlfaker.so and VirtualBox, thus eliminating the need to\nspecify `CR_SYSTEM_GL_PATH` or to run the VirtualBox application using\n`vglrun -nodl`.\n\n13. This version of VirtualGL provides a binary package, documentation, and\nfull support for Cygwin/X.\n\n14. Fixed an error (`free(): invalid pointer`) that occurred whenever an\napplication called `XCloseDisplay()` and the `VGL_XVENDOR` environment variable\nwas set.\n\n15. VirtualGL should now work properly when used with applications that render\nto framebuffer objects (FBO's.)\n\n16. vglconnect.bat should now work properly on 64-bit Windows systems.\nPreviously, it would fail if it was installed under the \"Program Files (x86)\"\ndirectory.\n\n17. Added a `-gid` option to vglserver_config to allow the group ID of the\nvglusers group to be specified, if that group must be created.\n\n18. TCBench should now work properly on OS X.\n\n\n2.1.4\n=====\n\n### Significant changes relative to 2.1.3:\n\n1. Fixed a regression in vglserver_config that caused a \"binary operator\nexpected\" error when restricting framebuffer device access to the vglusers\ngroup.\n\n2. Fixed an issue in vglserver_config whereby the device permissions were not\nbeing set correctly on SuSE Linux Enterprise Desktop 11.\n\n3. VGL should now properly ignore `GLX_BUFFER_SIZE` if an application attempts\nto specify it when requesting a true color visual.  Specifically, this allows\nthe Second Life SnowGlobe client to run properly in VGL and WINE.\n\n4. vglserver_config should now work even if /sbin and /usr/sbin are not in the\nPATH.\n\n5. The Solaris 10/x86 version of VirtualGL should now work properly with the\nnVidia 18x.xx series drivers.\n\n6. Fixed a memory leak that occurred when running VirtualGL in quad-buffered\nstereo mode.\n\n7. The DRI device permissions in RHEL 5 were being overridden whenever a user\nlogged in, because RHEL 5 uses a file in /etc/security/console.perms.d to\nspecify the default DRI permissions rather than using\n/etc/security/console.perms.  vglserver_config has been modified to handle\nthis.\n\n8. Added an option to vglconnect on Linux/Unix to allow it to use gsissh from\nthe Globus Toolkit instead of the regular ssh program.\n\n\n2.1.3\n=====\n\n### Significant changes relative to 2.1.2:\n\n1. VirtualGL 2.1.2 printed numerous \"Cannot obtain a Pbuffer-enabled 24-bit FB\nconfig ...\" error messages when starting Google Earth.  This has been fixed,\nand the message has been changed to a warning and clarified.  These error\nmessages were printed whenever Google Earth called VirtualGL's interposed\nversion of `glXChooseVisual()` and that function subsequently failed to obtain\nan appropriate visual for performing 3D rendering.  However, this is not\nnecessarily an error, because applications will sometimes call\n`glXChooseVisual()` multiple times until they find a visual with desired\nattributes.\n\n2. Changed the matching criteria in VirtualGL's interposed version of\n`dlopen()`.  In previous versions of VirtualGL, any calls to\n`dlopen(\"*libGL*\", ...)` would be replaced with a call to\n`dlopen(\"librrfaker.so\", ...)`.  This caused problems with VisIt, which has a\nlibrary named \"libGLabelPlot.so\" that was being interposed by mistake.  The\nmatching criteria has been changed such that `dlopen()` only overrides calls to\n`dlopen(\"libGL\\.*\", ...)` or `dlopen(\"*/libGL\\.*\", ...)`.\n\n3. vglserver_config should now work properly with DRI-compatible graphics\ndrivers (including ATI.)\n\n4. VirtualGL's interposed version of `dlopen()` will now modify calls to\n`dlopen(\"libdl*\", ...)` as well as `dlopen(\"libGL*\", ...)`.  This is to work\naround an interaction issue with v180.xx of the nVidia accelerated 3D drivers\nand WINE.\n\n5. Fixed an interaction issue with QT4 in which VirtualGL would not properly\nhandle window resize events under certain circumstances.\n\n6. Moved `dlopen()` back into a separate faker library (libdlfaker.so.)\nlibdlfaker.so is loaded by default, which should maintain the behavior of VGL\n2.1.2.  However, it can be disabled by passing an argument of `-nodl` to\nvglrun.  The latter is necessary to make VirtualBox 2.2.x work with VirtualGL.\n\n7. vglserver_config should now work properly on Ubuntu 9.04 when using gdm or\nkdm.  It should also (mostly) work on Fedora 11 (disabling XTEST does not work\non Fedora 11 when using gdm.)\n\n8. Added fallback logic to VirtualGL's symbol loader, which will now try to\ndirectly load the GLX/OpenGL symbols from libGL.so.1 and the X11 symbols from\nlibX11.so.6 if loading those symbols using `dlsym(RTLD_NEXT, ...)` fails.  This\nis to work around an issue with version 18x.xx of the nVidia Linux Display\nDriver.\n\n9. If an application window was destroyed by the window manager, and the\napplication did not explicitly monitor and handle the `WM_DELETE` protocol\nmessage, then previous versions of VirtualGL would, when using the X11 Image\nTransport, generally abort with an X11 BadDrawable error.  This occurred\nbecause the window was basically being ripped out from underneath VirtualGL's\nblitter thread without warning.  This version of VirtualGL has been modified\nsuch that it monitors `WM_DELETE` messages, so VirtualGL can now bow out\ngracefully if the 3D application window is closed by the window manager but the\napplication does not handle `WM_DELETE`.\n\n10. Worked around an interaction issue with IDL whereby the application was\ncalling `XGetGeometry()` with the same pointer for every argument, and this was\ncausing VirtualGL to lose the width and height data returned from the \"real\"\n`XGetGeometry()` function.  Subsequently, the Pbuffer corresponding to the main\nIDL window would become improperly sized, and the rendering area would not\nappear to update.\n\n11. Added an option (`VGL_TRAPX11`) that will cause VirtualGL to gracefully\ntrap X11 errors, print a warning message when these occur, and allow the\n3D application to continue running.\n\n\n2.1.2\n=====\n\n### Significant changes relative to 2.1.1:\n\n1. Fixed a buffer overrun in TurboJPEG/mediaLib that may have caused problems\non Solaris/x86 VirtualGL servers.\n\n2. Integrated libdlfaker.so into librrfaker.so to eliminate the need for\ninvoking `vglrun -dl`.\n\n3. Developed a proper uninstaller app for the Mac OS X VirtualGL package.\n\n4. Modified `MAXINST` variable in the SUNWvgl Solaris package, to prevent\nmultiple instances of this package from being installed simultaneously.\n\n\n2.1.1\n=====\n\nThis release was historically part of the Sun Shared Visualization v1.1.1\nproduct.\n\n### Significant changes relative to 2.1:\n\n1. Fixed issues that occurred when displaying to the second or subsequent\nscreens on a multi-screen X server.\n\n2. Updated to the wxWindows Library License v3.1.\n\n3. Added an uncompressed YUV encoding option to the Sun Ray plugin.  This\nprovides significantly better performance than DPCM on Sun Ray 1 clients, and\nit provides significantly better image quality in all cases.  YUV encoding will\ngenerally use about 50% more network bandwidth than DPCM, all else being equal.\n\n4. Further optimized the Huffman encoder in the mediaLib implementation of\nTurboJPEG.  This should decrease the CPU usage when running VirtualGL on\nSolaris VirtualGL servers, particularly Solaris/x86 servers running 32-bit\napplications.\n\n5. vglconnect now works properly with Cygwin.\n\n6. Fixed a regression that caused VirtualGL to remove any part of the\n`VGL_XVENDOR` string following the first whitespace.\n\n7. vglserver_config now works properly with OpenSolaris systems.\n\n8. `glXUseXFont()` now works if a Pixmap is the current drawable.\n\n9. vglserver_config now works properly with Debian Linux systems.\n\n10. Fixed a typo in vglconnect that caused it to leave temporary files lying\nabout.\n\n11. Removed the libXm (Motif) dependency in the Solaris/x86 version of\nVirtualGL.  This mainly affected OpenSolaris systems, on which Motif is not\navailable.  The libXm dependency was introduced in VirtualGL 2.0.x, because\nthat version of VirtualGL used libXt (X Intrinsics) to generate its popup\nconfiguration dialog.  Java requires that libXm be loaded ahead of libXt, so it\nwas necessary to explicitly link the VirtualGL faker library with libXm to\nguarantee that the libraries were loaded in the correct order.  Since VirtualGL\n2.1.x and later no longer use libXt, the binding to libXm could be safely\nremoved on x86 systems.  Note, however, that the libXm binding still has to be\nincluded on SPARC systems, because libGL on SPARC depends on libXmu, which\ndepends on libXt.\n\n12. Fixed an issue with GeomView whereby attempting to resize the oldest window\nin a multi-window view would cause the Exceed version of vglclient to crash.\n\n13. When used to configure a Solaris server for GLX mode with open access (all\nusers being able to access the 3D X server, not just members of the vglusers\ngroup), vglserver_config was incorrectly placing xhost commands at the top of\n/etc/dt/config/Xsetup instead of at the bottom.  This could have led to\nproblems, since xhost is not guaranteed to be in the PATH until the bottom of\nthat script.\n\n14. VirtualGL should now build and run cleanly on Ubuntu systems (and possibly\nother Debian derivatives, although only Ubuntu has been tested.)\n\n15. Certain applications call `glFlush()` thousands of times in rapid\nsuccession when rendering to the front buffer, even if no part of the 3D scene\nhas changed.  Without going into the gorey details, this caused the VirtualGL\npipeline to become overloaded in certain cases, particularly on systems with\nfast pixel readback.  On such systems, every one of the `glFlush()` commands\nresulted in VirtualGL drawing or sending a frame, even if the pixels in the\nframe were identical to those in the previous frame.  This resulted in\napplication delays of up to several minutes.  This version of VGL includes a\nmechanism that ensures that no more than 100 `glFlush()` commands per second\nwill actually result in an image being drawn or sent, and thus strings of\nrapid-fire `glFlush()` commands can no longer overload the pipeline.\n\n16. vglserver_config should now work with openSUSE systems.\n\n17. It was discovered that `xhost +LOCAL:` is a better method of enabling 3D X\nserver access to all users of the VirtualGL server.  This method works even if\nTCP connections are disabled in the X server (which is the case on recent\nSolaris and Linux distributions.)  vglserver\\_config has thus been modified to\nuse this method rather than `xhost +localhost`.  Also, since it is no longer\nnecessary to set `DisallowTCP=false` in the GDM configuration file,\nvglserver_config now comments out this line if it exists.\n\n18. Fixed a deadlock that occurred when using the VirtualGL Sun Ray plugin and\nParaView to render multi-context datasets.\n\n19. Fixed an issue with Mac X11 2.1.x on OS X 10.5 \"Leopard\" whereby vglconnect\nwould abort with `Could not open log file.`  X11 2.1.x uses a `DISPLAY`\nenvironment of the form /tmp/launch-*/:0, so it was necessary to remove\neverything up to the last slash before using this variable to build a unique\nvglclient log file path.\n\n20. Included libgefaker.so in the Solaris VirtualGL packages (oops.)\n\n21. Added an interposed version of `XSolarisGetVisualGamma()` on SPARC servers,\nso applications that require gamma-corrected visuals can be fooled into\nthinking that a gamma-corrected visual is available, when in fact VirtualGL's\nsoftware gamma correction mechanism is being used instead.\n\n22. Fixed a bug in the color conversion routines of TurboJPEG/mediaLib that\ncaused the Solaris VirtualGL Client to display incorrect pixels along the\nright-most edge of the window when 2X or 4X subsampling was used.\n\n\n2.1\n===\n\nThis release was historically part of the Sun Shared Visualization v1.1\nproduct.\n\n### Significant changes relative to 2.1 beta1:\n\n1. Windows applications now link statically with OpenSSL, to avoid a dependency\non msvcr71.dll that was introduced in the Win32 OpenSSL 0.9.8e DLLs.\nlibeay32.dll and ssleay32.dll have been removed from the Windows package, since\nthey are no longer needed.\n\n2. Implemented a new interposer library (libgefaker.so) which, when active,\nwill interpose on `getenv()` and return NULL whenever an application queries\nthe value of the `LD_PRELOAD` environment variable (and, on Solaris, the\n`LD_PRELOAD_32` and `LD_PRELOAD_64` environment variables.)  This fools an\napplication into thinking that no preloading is occurring.  This feature is\ncurrently undocumented and is subject to change, but it can be activated in\nthis release by passing an argument of `-ge` to vglrun.\n\n3. Extended `VGL_SYNC` functionality to include `glXSwapBuffers()` as well.\nThis works around a couple of interaction issues between VirtualGL and\nAutoForm.  The User's Guide has been updated to explain this new functionality,\nto include an app recipe for AutoForm, and to include a warning about the\nperformance consequences of using `VGL_SYNC` on a remote X connection.\n\n4. Included a short paragraph in the Chromium section of the User's Guide\nthat explains how to use VirtualGL on the render nodes to redirect 3D rendering\nfrom a window to a Pbuffer.\n\n5. Documented the patch revision necessary to make Exceed 2008 work properly\nwith VirtualGL.  Removed dire warnings.\n\n6. Added full-screen rendering mode to GLXspheres.\n\n7. Fixed a regression (uninitialized variable) introduced by 2.1 beta1[7].\n\n8. Fixed a logic error that caused vglclient to fail when using OpenGL drawing\nand talking to a legacy (VGL 2.0 or earlier) server.\n\n9. Fixed a regression that would cause VGL to deadlock when the user closed the\n3D application window while using the X11 Image Transport.\n\n10. Fixed an issue whereby vglserver_config would fail to detect the presence\nof GLP because nm was not in the default PATH.\n\n11. When running VirtualGL on Enterprise Linux 5 using the 100 series nVidia\ndrivers, a normal exit from a 3D application will result in\n`glXChannelRectSyncSGIX()` being called after the VirtualGL hashes have already\nbeen destructed.  `glXChannelRectSyncSGIX()` calls `XFree()` (an interposed\nfunction), and under certain circumstances, the interposed version of `XFree()`\nwas trying (and failing) to access one of the previously destructed VirtualGL\nhashes.  This has been fixed.\n\n12. `vglclient -kill` now works properly on Solaris systems.\n\n13. Fixed a timing snafu in-- and raised the run priority of-- the Windows\nversion of TCBench.  This improves the accuracy of TCBench on Windows in\nhigh-client-CPU-usage scenarios.\n\n14. Fixed an issue in the interactive mode of GLXSpheres whereby it would use\n100% of the CPU when sitting idle.  Added an option to GLXSpheres to adjust the\npolygon count of the scene.\n\n15. Added app recipes for ANSYS and Cedega to the User's Guide.  Added notes\ndescribing the ANSYS and Pro/E duplicate `glFlush()` issue and workarounds.\n\n16. Changed the default value for `VGL_NPROCS` to `1` (the performance study\nindicates that there is no longer any measurable advantage to multi-threaded\ncompression on modern hardware with VGL 2.1.)\n\n17. Added a `-bench` option to nettest to allow it to measure actual usage on a\ngiven Solaris or Linux network device.  This was necessitated by accuracy\nissues with other open source network monitoring solutions.\n\n18. Changed the way global hash tables are allocated in VGL, in order to fix an\ninteraction issue with applications that are built with MainWin.\n\n19. `vglclient -kill` now works properly on Mac systems.\n\n20. The VirtualGL Configuration dialog now pops up properly when Caps Lock is\nactive.\n\n21. If a previously destroyed GLX context is passed as an argument to\n`glXMake[Context]Current()`, the function now returns False instead of throwing\na fatal exception.  This was necessary to make a couple of different commercial\napplications work properly.\n\n22. There was some inconsistency regarding the interface for enabling lossless\ncompression in the Sun Ray Image Transport.  The User's Guide listed the\ninterface as `VGL_COMPRESS=srrgb`, whereas the output of vglrun listed the\ninterface as `-c srlossless`.  VirtualGL 2.1rc only responded to the latter.\nThis version of VirtualGL now responds to both interfaces, but\n`VGL_COMPRESS=srrgb` is the correct and documented interface.  Any errant\nreferences to \"srlossless\" have been changed.\n\n\n2.1 beta1\n=========\n\n### Significant changes relative to 2.0.1:\n\n1. The VirtualGL Configuration dialog is now implemented using FLTK instead of\nX Intrinsics.  The dialog is also now handled by a separate process\n(vglconfig), to avoid application interaction issues.  VirtualGL and vglconfig\ncommunicate changes to the configuration through shared memory.\n\n    Note that this renders both the `VGL_GUI_XTTHREADINIT` configuration option\nand the corresponding application recipe for VisConcept unnecessary, and thus\nboth have been removed.\n\n2. Added two new scripts (vglconnect and vgllogin) to automate the process of\nconnecting to a VirtualGL server and using the VGL Image Transport (formerly\n\"Direct Mode.\")  vglconnect wraps both vglclient and ssh.  Through the use of\ncommand-line arguments, vglconnect can be configured to forward either the X11\ntraffic or the 3D image traffic (or none or both) over the SSH connection.\nvglconnect invokes vgllogin on the server, which configures the server\nenvironment with the proper `VGL_CLIENT` and `VGL_PORT` values so that, once\nconnected, no further action is required other than to launch a 3D application\nwith vglrun.  See the User's Guide for more information.\n\n3. vglclient includes many changes to support vglconnect.  Rather than listen\njust on ports 4242 and 4243, the default behavior of vglclient is now to find a\nfree listening port in the range of 4200-4299 (it tries 4242 and 4243 first,\nto maintain backward compatibility.)  vglclient records its listening port in\nan X property that is later read by the VGL faker.  This feature allows more\nthan one instance of vglclient to run on the same machine.  The client can also\ndetach completely from the console and run as a background daemon, exiting only\nwhen the X server resets or when vglclient is explicitly killed.\n\n    Previous versions of VirtualGL required one instance of vglclient to talk\nto all X displays on the client machine, but this created problems in\nmulti-user environments.  Thus, VirtualGL 2.1 runs a separate instance of\nvglclient for each unique X display.  This eliminates the need (as well as the\nability) to run vglclient as a root daemon or as a Windows service, and thus\nthose features have been removed.\n\n    Since vglclient is intended to be launched from vglconnect, Start Menu\nlinks to the VirtualGL Client are no longer included in the Windows package.\n\n    See the User's Guide for more information about the changes to vglclient.\n\n4. The Windows VirtualGL package now includes an optimized version of PuTTY\n0.60, which is used by the Windows version of vglconnect.  When tunneling the\n3D image stream, this version of PuTTY provides significantly better\nperformance than the stock version of PuTTY 0.60.\n\n5. Added a new script (vglserver_config) to automate the process of configuring\nthe VirtualGL server's X display (the 3D X server) to allow connections from\nVirtualGL.  This script can also be used to configure GLP, for machines that\nsupport it.  See the User's Guide for more information.\n\n6. The VirtualGL Unix packages now include a benchmark called \"GLXSpheres\",\nwhich is an open source look-alike of the old nVidia SphereMark demo.  This\nprogram is meant to provide an alternative to GLXGears, since the images\ngenerated by the latter program contain too much solid color to be a good test\nof VirtualGL's image pipeline.  GLXSpheres also includes modes that can be used\nto test VirtualGL's support of advanced OpenGL features, such as stereo,\noverlays, and color index rendering.\n\n7. VirtualGL now works properly with multi-process OpenGL applications that use\none process to handle X events and another process to handle 3D rendering.  In\nparticular, this eliminates window resize issues with Abaqus/CAE and with the\nChromium readback SPU.\n\n8. Added an additional subsampling option to enable grayscale JPEG encoding.\nThis provides additional bandwidth savings over and above chrominance\nsubsampling, since grayscale throws away all chrominance components.  It is\npotentially useful when working with applications that already render grayscale\nimages (medical imaging, etc.)\n\n9. VirtualGL can now encode images as uncompressed RGB and send those\nuncompressed images through the VGL Image Transport.  This has two benefits:\n\n     - It eliminates the need to use the X11 Image Transport (AKA \"Raw Mode\")\nover a network, and\n     - It provides the ability to send lossless stereo image pairs to a\nstereo-enabled client.\n\n    A gigabit or faster network is recommended when using RGB encoding.\n\n10. Anaglyphic stereo support.  When VirtualGL detects that an application has\nrendered something in stereo, its default behavior is to try using quad-\nbuffered stereo.  However, if the client or the image transport do not support\nquad-buffered stereo, then VirtualGL will fall back to using anaglyphic\n(red/cyan) stereo.  This provides a quick & dirty way to visualize stereo data\non clients that do not support \"real\" stereo rendering.\n\n    VirtualGL 2.1 can also be configured to send only the left eye or right eye\nimages from a stereo application.\n\n11. Changed the way VirtualGL spoils frames.  Previous versions would throw out\nany new frames if the queue was already busy compressing or sending a previous\nframe.  In this release, VirtualGL instead throws out any undisplayed frames in\nthe queue and promotes every new frame to the head of the queue.  This\nensures that the last frame in a rendering sequence will always be displayed.\n\n12. Better integration with the Sun Ray plugin.  In particular, many of the Sun\nRay plugin's configuration options can now be configured through the VirtualGL\nConfiguration dialog.\n\n13. The Mac client is now fully documented.\n\n14. Included mediaLib Huffman encoding optimizations contributed by Sun.  This\nboosts the performance of VirtualGL on Solaris systems by as much as 30%.\\\nThis, in combination with mediaLib 2.5, should allow the Solaris/x86 version of\nVirtualGL to perform as well as the Linux version, all else being equal.\n\n15. Lighting did not work properly for color index applications in prior\nversions of VGL.  This has been fixed.\n\n16. Fixed an interaction issue with the 100 series nVidia drivers, whereby\napplications that requested a single-buffered RGB visual would sometimes fail\nto obtain it through VirtualGL.  The newer nVidia drivers don't always return\nan RGB 8/8/8 framebuffer config as the first in the list, so it was necessary\nfor VirtualGL to specify `GLX_RED_SIZE`, `GLX_GREEN_SIZE`, and `GLX_BLUE_SIZE`\nwhen obtaining a framebuffer config on the VirtualGL server's X display.\n\n17. Interframe comparison now works properly with stereo image pairs, and\ninterframe comparison can now be disabled by using the `VGL_INTERFRAME` option.\n\n\n2.0.1\n=====\n\nThis release was historically part of the Sun Shared Visualization v1.0.1\nproduct.\n\n### Significant changes relative to 2.0:\n\n1. The Linux and Solaris versions of VirtualGL are now statically linked with\nOpenSSL.  This fixes an issue whereby a 3D application that uses OpenSSL could\noverride VirtualGL's SSL bindings, thus causing VirtualGL to crash if SSL was\nenabled (`VGL_SSL=1` or `vglrun +s`) and if the application's version of\nOpenSSL was incompatible with VirtualGL's.\n\n    This, combined with [5] below, has the added benefit of allowing a single\nVirtualGL RPM to be used across multiple Linux platforms.  It is no longer\nnecessary to use a separate RPM for different versions of Enterprise Linux,\nSuSE, etc.\n\n2. librrfaker.so and libturbojpeg.so are now being linked with map files (AKA\n\"anonymous version scripts\" on Linux.)  This is mainly a preventative measure,\nbecause it hides any non-global symbols in the shared objects, thus preventing\nthose symbols from accidentally interposing on a symbol in an application or in\nanother shared object.  However, this was also necessary to prevent [1] from\ncausing the opposite problem from the one it was intended to fix (without [2],\nVirtualGL could interpose on an application's SSL bindings rather than vice\nversa.)\n\n    Linux users will need to upgrade to TurboJPEG 1.04.2 (or later) to get this\nfix.  For other platforms, the fix is included in the VGL 2.0.1 packages.\n\n3. librr.so, rr.h, and the rrglxgears.c sample application have been removed\nfrom the distribution packages.  These demonstrated a strawman API for creating\na VGL movie player.  The API was somewhat ill-conceived and broken, and it\nneeds to be revisited.\n\n4. VirtualGL's custom version of glxinfo is now included in the distribution\npackages, under /opt/SUNWvgl/bin or /opt/VirtualGL/bin.  This version of\nglxinfo supports GLP on SPARC servers and also has the ability to query GLX FB\nConfigs as well as X visuals.\n\n5. VGL now uses direct linking to link against libCrun on Solaris and static\nlinking to link against libstdc++ on Linux.  This is to prevent a problem\nsimilar to [1], in which an application that overrides the default C++ `new`\nand `delete` operators could force VGL to use its custom `new` and `delete`\noperators rather than the default operators provided in libCrun/libstdc++.\nSpecifically, this addresses an issue whereby Pro/E would spuriously crash on\nmulti-processor Solaris/SPARC machines.\n\n    libstdc++ is statically linked on Linux because Linux has no equivalent of\nDirect linking, but static linking against libstdc++ has the added benefit of\nallowing one VirtualGL RPM to be used across multiple Linux platforms.\n\n6. Eliminated the use of the X DOUBLE-BUFFER extension in Raw Mode and replaced\nit instead with X Pixmap drawing.  Previously, VGL would try to use the MIT-SHM\nextension to draw images in Raw Mode, then it would fall back to using the X\nDOUBLE-BUFFER extension if MIT-SHM was not available or could not be used (such\nas on a remote X connection), then it would fall back to single-buffered\ndrawing if DOUBLE-BUFFER could not be used.  However, the DOUBLE-BUFFER\nextension crashes on some Sun Ray configurations (specifically Xinerama\nconfigurations), so VGL 2.0 disabled the use of DOUBLE-BUFFER on all Sun Ray\nconfigurations to work around this issue.  [6] replaces that hack with a more\nsolid fix that ensures that Raw Mode is always double-buffered, even if the X\nDOUBLE-BUFFER extension is not available or is not working.  Pixmap drawing\nhas the same performance as DOUBLE-BUFFER.\n\n    This generally only affects cases in which Raw Mode is used to transmit\nimages over a network.  When Raw Mode is used to transmit images to an X server\non the same machine, it is almost always able to use the MIT-SHM X extension.\n\n7. Numerous doc changes, including:\n\n     - Restructuring the User's Guide to create a more clear delineation\nbetween what needs to be done on the server and what needs to be done on the\nclient.\n     - (Re-)added instructions for how to use VGL with a direct X11 connection,\nsince it has become apparent that that configuration is necessary in some\ncases.\n     - Changed procedure for doing Direct Mode SSH tunneling.  The previous\nprocedure would not have worked if multiple users were trying to tunnel Direct\nMode from the same server.  The new procedure requires running a program (see\n[8] below) that prints out an available TCP port, and using that port on the\nserver end of the SSH tunnel.\n     - Added app recipe for ANSA 12.1.0.\n     - Added procedures for using VGL with TurboVNC and for using TurboVNC in\ngeneral.\n     - Added information for using VGL with GLP (which, unbelievably, was never\nreally included in the User's Guide.  Major oversight on our part.)\n\n8. Modified the nettest program such that it finds a free TCP port number and\nprints out the port number to the console when you pass an argument of\n`-findport` to the program.\n\n9. Fixed `glXGetProcAddressARB()` and `glXGetProcAddress()` on SPARC platforms.\nDue to an erroneous `#ifdef` statement, these interposed functions were not\ngetting compiled into VirtualGL when VirtualGL was built with Sun OpenGL on\nSPARC platforms.\n\n    This, combined with [16], allows Java 2D apps running in VirtualGL on SPARC\nplatforms to successfully use the OpenGL pipeline to perform Java 2D rendering.\n\n10. Sun OpenGL 120812-15 (and later) now includes a `SwapBuffers()` command for\nGLP, which VirtualGL will now use if available.  Some applications that use\nfront buffer drawing (Pro/E and UGS/NX v4, specifically) did not work properly\nwith VirtualGL 2.0 in GLP mode, because the back buffer in the double-buffered\nPbuffer was not being swapped.\n\n11. Some applications call `XListExtensions()` rather than `XQueryExtension()`\nto probe for the existence of the GLX extension.  Such applications, when\ndisplaying to VNC or another X server that lacks the GLX extension, would fail.\n VirtualGL now interposes on `XListExtensions()` and makes sure that the GLX\nextension is always reported as present.  This fixes a specific issue with\nUGS/NX v4 whereby NX, if run with VirtualGL and TurboVNC, would refuse to use\nOpenGL to perform its 3D rendering.\n\n12. VGL will now print a warning if the GLX context it obtains on the server's\ndisplay is indirect.  This will occur on Solaris if the framebuffer device\npermissions do not allow read/write access for the current user.\n\n13. Normally, if X11 drawing is the default in the VGL client (which is the\ncase on non-SPARC systems, on SPARC systems with 2D framebuffers, or on any\nsystem if vglclient is invoked with the `-x` argument), then the VGL client\nwill only use OpenGL for drawing stereo frames.  This fixes a bug whereby the\nVGL client would not switch back to X11 drawing (if X11 drawing was the\ndefault) after the app ceased rendering in stereo.\n\n14. You can now specify a listen port number of 0 to make the VGL client pick\nan available port.  This is of only marginal use at the moment, since there is\nno way to make the server automatically connect to that port, but we got this\nfor free as a result of [8].\n\n15. Fixed an issue that was causing the multi-threaded tests in rrfakerut to\ncrash some of the nVidia 7xxx series drivers.  rrfakerut should now run cleanly\non the 7xxx series, but the multi-threaded tests still cause the 8xxx series\ndrivers to crash & burn, and they cause the 9xxx series drivers to generate\nincorrect pixels.  Further investigation is needed.\n\n16. Fixed two issues that were preventing Java 2D on Solaris/SPARC from\nproperly detecting that OpenGL is available:\n\n    - `glXChooseFBConfig()` now ignores the `GLX_VISUAL_ID` attribute.  That\nattribute doesn't really have any meaning in VGL, and passing it through to the\nserver's X display was causing Java 2D apps to fail.\n    - `glXGetFBConfigAttrib(..., GLX_DRAWABLE_TYPE, ...)` now always returns\n`GLX_PIXMAP_BIT|GLX_PBUFFER_BIT|GLX_WINDOW_BIT`, so that Java 2D apps will\nproperly detect that window rendering is available in VirtualGL.\n\n17. vglrun will now print usage information if you fail to provide an\napplication command to run.\n\n18. Upgraded the OpenSSL DLL included with the Windows VirtualGL client to\nOpenSSL 0.9.8d (previously 0.9.8c.)\n\n19. VirtualGL now buffers the output from the profiler class so that the\nprofiling output from multiple compression threads doesn't intermingle when\nredirected to a log file.\n\n20. If the `DISPLAY` environment variable is unset on the VirtualGL server,\nvglrun will now set it automatically to `{ssh_client}:0.0` (where\n`{ssh_client}` = the IP address of the SSH client.)  If `DISPLAY` is set to\n`localhost:{n}.0` or `{server_hostname}:{n}.0`, VGL assumes that SSH X11\nforwarding is in use and sets `VGL_CLIENT={ssh_client}:0.0` instead (without\nmodifying `DISPLAY`.)  vglrun prints a warning that it is doing this.  You must\nstill explicitly set `VGL_CLIENT` or `DISPLAY` if you are doing something\nexotic, such as tunneling VGL's client/server connection through SSH or\ndisplaying to an X server with a display number other than 0.  But this fix\nshould eliminate the need to set `VGL_CLIENT` and `DISPLAY` in most cases.\nNote that the Sun Ray plugin also reads the `VGL_CLIENT` environment variable,\nso if you are connecting to the VirtualGL server from a Sun Ray server using\nSSH X11 forwarding, this eliminates the need to explicitly set `VGL_CLIENT` in\nthat case as well.\n\n21. Implemented the \"spoil last frame\" algorithm in the Sun Ray plugin whenever\nVGL reads back/compresses/sends the framebuffer in response to a `glFlush()`.\nThis fixes issues with slow model regeneration and zoom operations in Pro/E\nwhen using the Sun Ray plugin.\n\n    Normally, the Sun Ray plugin uses the \"spoil first frame\" algorithm, which\ncauses the frames in the queue to be discarded whenever a new frame is\nreceived.  However, this algorithm requires that the framebuffer be read back\nevery time a frame is rendered, even if that frame is ultimately going to be\nspoiled.  This causes problems with applications (Pro/E, specifically) that\ncall `glFlush()` frequently when doing front buffer drawing.  Each of these\n`glFlush()` calls triggers a framebuffer readback in VirtualGL, which can cause\nsignificant interaction delays in the application.  The \"spoil last frame\"\nalgorithm discards the newest frame if the queue is currently busy, so when\nthis algorithm is used, most of the duplicate frames triggered by the repeated\n`glFlush()` events are discarded with no framebuffer readback (and thus very\nlittle overhead.)\n\n    This fix does not affect Direct Mode and Raw Mode, since those modes\nalready use the \"spoil last frame\" algorithm in all cases.\n\n22. Added an option (`VGL_INTERFRAME`), which, when set to `0`, will disable\ninterframe image comparison in Direct Mode.  This was necessary to work around\nan interaction issue between VGL and Pro/E Wildfire v3 that led to slow\nperformance when zooming in or out on the Pro/E model.\n\n23. Added an option (`VGL_LOG`), which can be used to redirect the console\noutput from the VGL faker to a file instead of stderr.\n\n24. The mediaLib implementation of TurboJPEG and the mediaLib-accelerated gamma\ncorrection code have been modified slightly, to avoid calls to mediaLib\nfunctions that wrap `memalign()` and `free()`.  This works around an\ninteraction issue with Pro/E v3 (and potentially with other applications that\nuse their own custom memory allocators.)\n\n\n2.0\n===\n\nThis release was historically part of the Sun Shared Visualization v1.0\nproduct.\n\n### Significant changes relative to 2.0 beta3:\n\n1. Included libturbojpeg.dylib in Mac package (so that installing the TurboJPEG\npackage is no longer necessary unless you want to rebuild VGL from source.)\n\n2. Included TCBench and NetTest in the Mac package.\n\n3. Added an internal gamma correction system.  This was a last-minute feature\naddition to address the fact that there was no way to gamma-correct\napplications that were remotely displayed to non-SPARC clients.  SPARC users\nare accustomed to OpenGL applications being gamma-corrected by default, so\nVirtualGL now mimics this behavior whenever it is running on a SPARC server,\neven if the client machine is not a SPARC machine.\n\n    The behavior of the `VGL_GAMMA` environment variable has changed as\nfollows:\n\n     - `VGL_GAMMA=1` (or `vglrun +g`):\n\n        Enable gamma correction using the best available method.  If displaying\nto a SPARC X server that has gamma-corrected visuals, try to use those\ngamma-corrected visuals.  Otherwise, enable VGL's internal gamma correction\nsystem with a gamma correction factor of 2.22.\n\n        This is the default when running applications on SPARC VirtualGL\nservers.\n\n     - `VGL_GAMMA=0` (or `vglrun -g`):\n\n        Do not use gamma-corrected visuals (even if available on the X server),\nand do not use VGL's internal gamma correction system.\n\n        This is the default when running applications on non-SPARC VirtualGL\nservers.\n\n     - `VGL_GAMMA={f}` (or `vglrun -gamma {f}`):\n\n        Do not use gamma-corrected visuals (even if available on the client),\nbut enable VGL's internal gamma correction system with a gamma correction\nfactor of {f}.\n\n    Enabling the internal gamma correction system increases CPU usage by a few\npercent, but this has not been shown to affect the overall performance of VGL\nby a measurable amount.\n\n    See the \"VGL_GAMMA\" entry in Chapter 18 of the User's Guide for more info.\n\n4. Increased the size of the TurboJPEG compression holding buffer to account\nfor rare cases in which compressing very-high-frequency image tiles\n(specifically parts of the 3D Studio MAX Viewperf test) with high quality\nlevels (specifically Q99 or above) would produce JPEG images that are larger\nthan the uncompressed input.\n\n    Linux users will need to upgrade to TurboJPEG 1.04 (or later) to get this\nfix.  For other platforms, the fix is included in the VGL 2.0 packages.\n\n5. Minor documentation changes, including a change to the recommended OpenGL\npatches for SPARC VGL servers and an application recipe for SDRC I-DEAS Master\nSeries.\n\n6. Check for exceptions in the `new` operator to prevent VGL from dying\nungracefully in out-of-memory situations.\n\n7. Fixed a bug in the multi-threaded compression code whereby it would use too\nmuch memory to hold the image tiles for the second and subsequent compression\nthreads.  This led to memory exhaustion if the tile size was set to a low value\n(such as 16x16 or 32x32.)\n\n\n2.0 beta3\n=========\n\n### Significant changes relative to 2.0 beta2:\n\n1. Solaris packages now include the OpenSSL shared libraries (libssl and\nlibcrypto), thus eliminating the need to install Blastwave OpenSSL on Solaris 9\nand prior.\n\n2. Packages now include a convenience script (vglgenkey) that will generate an\nxauth key for the server's X display.  This provides a more secure way of\ngranting access to the server's X display than using `xhost +localhost`.\n\n3. Built and packaged the VirtualGL client for Mac OS/X (Intel only.)  This\npackage is currently undocumented and includes only the VGL client (no server\ncomponents), but its usage should be self-explanatory for those familiar with\nVGL on other platforms (it should work very similarly to the Linux version.)\n\n4. Normally, when running in Raw Mode, VirtualGL will try to use the MIT-SHM X\nextension to draw images.  If MIT-SHM is not available or doesn't work (which\nwould be the case if the X connection is remote), then VGL will try to use the\nX DOUBLE-BUFFER extension.  Failing that, it will fall back to single-buffered\ndrawing.  In a Sun Ray environment, the X DOUBLE-BUFFER extension is unstable\nwhen Xinerama is used.  DOUBLE-BUFFER doesn't really double-buffer in a Sun Ray\nenvironment anyhow, so this release of VirtualGL disables the use of\nDOUBLE-BUFFER if it detects that it is running in a Sun Ray environment.\n\n5. Reformatted User's Guide using [Deplate](http://deplate.sourceforge.net).\nNumerous other doc changes as well.\n\n6. Extended VGL to support the full GLX 1.4 spec (this involved simply creating\na function stub for `glXGetProcAddress()`, but it was necessary to make J2D\nwork under Java 6.)\n\n7. Changed the key sequence for the popup configuration dialog (again) to\nCTRL-SHIFT-F9 to avoid a conflict with Solaris Common Desktop Environment.\n\n8. VGL no longer tries to switch to Direct Mode automatically whenever a stereo\nframe is rendered.  Instead, if running in Raw Mode, it warns that stereo\ndoesn't work in Raw Mode and proceeds to send only the left eye buffer.\n\n\n2.0 beta2\n=========\n\n### Significant changes relative to 2.0 beta1:\n\n1. Added a `-dl` option to vglrun, which inserts a new libdlfaker.so interposer\nahead of VirtualGL in the link order.  libdlfaker.so intercepts `dlopen()`\ncalls from an application and, if the application is trying to use `dlopen()`\nto open libGL, librrfaker.so (VirtualGL) is opened instead.  This allows\nVirtualGL to be used seamlessly with applications that do not dynamically link\nagainst libGL and do not provide any sort of override mechanism.  See the\nUser's Guide for a list of known applications that require the `-dl` option.\n\n2. Bug fixed:  Lazy loading of OpenSSL on Solaris now works properly, so\nOpenSSL doesn't have to be installed unless VirtualGL is being used in SSL\nmode.\n\n3. Added \"application recipes\" section to User's Guide.\n\n4. Tweaked FBX library to improve performance of VGL when used with NX and\nFreeNX.\n\n5. Bug fixed:  TurboJPEG for Solaris did not properly handle 4:2:0\ndecompression if no pixel format conversion was required.\n\n6. Bug fixed:  Minor (and somewhat esoteric) visual matching bug in GLP mode\n\n7. Bug fixed:  In GLX mode, VGL did not properly handle FB configs that had no\nassociated X Visual type.\n\n8. Stereo now works on Solaris/SPARC servers using kfb framebuffers in both GLP\nand GLX modes.  Sun OpenGL patch 120812-12 (or later) and KFB driver patch\n120928-10 (or later) are required.\n\n9. Bug fixed:  In GLX mode, some of the \"real\" GLX functions that VirtualGL\ncalls on the server will in turn call `glXGetClientString()`,\n`glXQueryExtensions()`, etc. to list extensions available on the server's X\ndisplay.  VirtualGL interposes on these functions and returns its own extension\nstrings rather than the \"real\" strings from the server's X display, and this\ncaused problems under certain circumstances.  These interposed functions will\nnow detect whether they are being called from within another GLX function and\nwill return the \"real\" extension strings for the server's X display if so.\n\n10. Generally friendlier error messages\n\n11. Bug fixed:  Destroying an overlay window would cause VGL to seg fault.\n\n12. Changed configuration dialog popup key sequence to CTRL-SHIFT-F12 to avoid\nconflict with KDE.\n\n13. Added `VGL_GUI_XTHREADINIT` environment variable to optionally disable\nVGL's use of `XtToolkitThreadInitialize()`.  Rarely, a multi-threaded Motif\napplication relies on its own locking mechanisms and will deadlock if Motif's\nbuilt-in application and process locks are enabled.  Thus far, the only known\napplication that this affects is VisConcept.  Set `VGL_GUI_XTHREADINIT` to `0`\nto prevent VisConcept from deadlocking when the VGL config dialog is activated.\n\n14. VirtualGL will no longer allow a non-TrueColor stereo visual to be\nselected, because such visuals won't work with the VGL client.  Color index\n(PseudoColor) rendering requires Raw Mode, but stereo requires Direct Mode, so\nVirtualGL cannot transmit PseudoColor images in stereo.\n\n15. VirtualGL will now automatically select Raw Mode if it detects that it is\nrunning on a \"local\" display (i.e. \":{n}.0\", \"unix:{n}.0\", etc., but not\n\"localhost:{n}.0\".)  This allows users of X proxies such as Sun Ray, TurboVNC,\nNX, etc. to run VirtualGL without having to pass an argument of `-c 0` to\nvglrun.  \"localhost:{n}.0\" is not considered a \"local\" display, and neither is\n\"{server_hostname}:{n}.0\", because display connections tunneled through SSH\nwill have a display name that takes on one of those forms.\n\n16. The VirtualGL client for Solaris/SPARC will now automatically detect if it\nis running on a framebuffer that uses software OpenGL and will default to using\nX11 drawing in that case.  Otherwise, if hardware-accelerated OpenGL is\navailable, then the VGL client for Solaris/SPARC will try to use OpenGL as the\ndefault drawing method.  This improves performance on the XVR-100 and similar\nframebuffers as well as working around a bug in the OGL implementation on\nXVR-100 (see CR 6408535.)  Non-SPARC clients still use X11 drawing by default,\nexcept when drawing stereo frames.\n\n17. Worked around some issues in Sun OpenGL that manifested themselves in\ninstability of the SPARC VirtualGL client when drawing large numbers of\nsimultaneous frames from different servers.\n\n18. Expanded N1 GridEngine hooks in vglrun so that the `VGL_CLIENT`,\n`VGL_COMPRESS`, `VGL_PORT`, `VGL_SSL`, `VGL_GLLIB`, and `VGL_X11LIB`\nenvironment variables will be automatically passed to vglrun by N1GE.  All\nother variables must be explicitly passed by using the `-v` option to qsub.\n\n19. Bug fixed:  Lazy loading of OpenGL now works properly on Solaris clients,\nso vglclient can be run on machines that don't have OpenGL installed.\n\n20. For some reason, popping up the VGL configuration dialog when running Java\napps caused VGL's Xt resource string to be ignored, which would cause the\nwidgets to be displayed incorrectly.  Thus, VirtualGL now explicitly specifies\nthe resources when creating each widget and doesn't rely on the use of a\nresource string.\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/CMakeLists.txt": "###############################################################################\n# SETUP\n###############################################################################\n\ncmake_minimum_required(VERSION 2.8.11)\n# Shut up CMake 3.1 and later\nif(POLICY CMP0053)\n\tcmake_policy(SET CMP0053 OLD)\nendif()\n\nif(WIN32)\n\tproject(VirtualGL-Utils)\nelse()\n\tproject(VirtualGL)\nendif()\nstring(TOLOWER ${CMAKE_PROJECT_NAME} CMAKE_PROJECT_NAME_LC)\nset(VERSION 2.5.2)\n\nmacro(boolean_number var)\n\tif(${var})\n\t\tset(${var} 1)\n\telse()\n\t\tset(${var} 0)\n\tendif()\nendmacro()\n\nmacro(report_option var desc)\n\tif(${var})\n\t\tmessage(STATUS \"${desc} enabled (${var} = ${${var}})\")\n\telse()\n\t\tmessage(STATUS \"${desc} disabled (${var} = ${${var}})\")\n\tendif()\nendmacro()\n\nif(UNIX AND NOT APPLE AND NOT CYGWIN)\n\toption(VGL_BUILDSERVER \"Build ${CMAKE_PROJECT_NAME} server components\" TRUE)\n\tboolean_number(VGL_BUILDSERVER)\n\treport_option(VGL_BUILDSERVER \"VirtualGL server components\")\nendif()\n\nif(NOT CMAKE_BUILD_TYPE)\n\tset(CMAKE_BUILD_TYPE Release)\nendif()\n\nmessage(STATUS \"CMAKE_BUILD_TYPE = ${CMAKE_BUILD_TYPE}\")\n\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)\nset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)\n\nstring(TIMESTAMP DEFAULT_BUILD \"%Y%m%d\")\nset(BUILD ${DEFAULT_BUILD} CACHE STRING \"Build string (default: ${DEFAULT_BUILD})\")\n\nmessage(STATUS \"VERSION = ${VERSION}, BUILD = ${BUILD}\")\nadd_definitions(-D__VERSION=\"${VERSION}\" -D__BUILD=\"${BUILD}\"\n\t-D__APPNAME=\"${CMAKE_PROJECT_NAME}\")\n\n# Detect CPU type and word size\nmath(EXPR BITS \"${CMAKE_SIZEOF_VOID_P} * 8\")\nstring(TOLOWER ${CMAKE_SYSTEM_PROCESSOR} CMAKE_SYSTEM_PROCESSOR_LC)\nif(CMAKE_SYSTEM_PROCESSOR_LC MATCHES \"x86_64\" OR\n\tCMAKE_SYSTEM_PROCESSOR_LC MATCHES \"amd64\" OR\n\tCMAKE_SYSTEM_PROCESSOR_LC MATCHES \"i[0-9]86\" OR\n\tCMAKE_SYSTEM_PROCESSOR_LC MATCHES \"x86\" OR\n\tCMAKE_SYSTEM_PROCESSOR_LC MATCHES \"ia32\")\n\tif(BITS EQUAL 64)\n\t\tset(CPU_TYPE x86_64)\n\telse()\n\t\tset(CPU_TYPE i386)\n\tendif()\n\tif(NOT CMAKE_SYSTEM_PROCESSOR STREQUAL ${CPU_TYPE})\n\t\tset(CMAKE_SYSTEM_PROCESSOR ${CPU_TYPE})\n\tendif()\nelse()\n\tset(CPU_TYPE ${CMAKE_SYSTEM_PROCESSOR_LC})\nendif()\nmessage(STATUS \"${BITS}-bit build (${CPU_TYPE})\")\n\nif(UNIX)\n\tset(CMAKE_INSTALL_DEFAULT_PREFIX /opt/${CMAKE_PROJECT_NAME})\n\tif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n\t\tset(CMAKE_INSTALL_PREFIX \"${CMAKE_INSTALL_DEFAULT_PREFIX}\" CACHE PATH\n\t\t\t\"Directory into which to install ${CMAKE_PROJECT_NAME} (default: ${CMAKE_INSTALL_DEFAULT_PREFIX})\"\n\t\t\tFORCE)\n\tendif()\nendif()\nmessage(STATUS \"CMAKE_INSTALL_PREFIX = ${CMAKE_INSTALL_PREFIX}\")\n\nif(CMAKE_COMPILER_IS_GNUCC OR CMAKE_C_COMPILER_ID STREQUAL \"Clang\")\n\tset(GNUCC 1)\nelse()\n\tset(GNUCC 0)\nendif()\nif(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n\tset(GNUCXX 1)\nelse()\n\tset(GNUCXX 0)\nendif()\n\n# When the prefix is /opt/${CMAKE_PROJECT_NAME}, we assume that an \"official\"\n# build is being created, and thus we install things into specific locations.\n\nif((UNIX AND CMAKE_INSTALL_PREFIX STREQUAL \"${CMAKE_INSTALL_DEFAULT_PREFIX}\")\n\tOR WIN32)\n\tset(CMAKE_INSTALL_DEFAULT_DATAROOTDIR \"\")\n\tset(CMAKE_INSTALL_DEFAULT_DOCDIR \"<CMAKE_INSTALL_DATAROOTDIR>/doc\")\n\tif(UNIX)\n\t\tset(CMAKE_INSTALL_DEFAULT_LIBDIR \"lib${BITS}\")\n\tendif()\nendif()\nif(WIN32)\n\tset(CMAKE_INSTALL_DEFAULT_BINDIR \".\")\n\tset(CMAKE_INSTALL_DEFAULT_DOCDIR \".\")\nendif()\n\ninclude(cmakescripts/GNUInstallDirs.cmake)\n\nmacro(report_directory var)\n\tif(CMAKE_INSTALL_${var} STREQUAL CMAKE_INSTALL_FULL_${var})\n\t\tmessage(STATUS \"CMAKE_INSTALL_${var} = ${CMAKE_INSTALL_${var}}\")\n\telse()\n\t\tmessage(STATUS \"CMAKE_INSTALL_${var} = ${CMAKE_INSTALL_${var}} (${CMAKE_INSTALL_FULL_${var}})\")\n\tendif()\n\tmark_as_advanced(CLEAR CMAKE_INSTALL_${var})\nendmacro()\n\nset(DIRLIST \"BINDIR;DATAROOTDIR;DOCDIR\")\nif(VGL_BUILDSERVER)\n\tlist(APPEND DIRLIST \"INCLUDEDIR;LIBDIR\")\nendif()\nforeach(dir ${DIRLIST})\n\treport_directory(${dir})\nendforeach()\n\ninclude_directories(${CMAKE_SOURCE_DIR}/include)\n\nif(MSVC)\n\t# Use the static C library for all build types\n\tforeach(var CMAKE_C_FLAGS CMAKE_C_FLAGS_DEBUG CMAKE_C_FLAGS_RELEASE\n\t\tCMAKE_C_FLAGS_MINSIZEREL CMAKE_C_FLAGS_RELWITHDEBINFO\n\t\tCMAKE_CXX_FLAGS CMAKE_CXX_FLAGS_DEBUG CMAKE_CXX_FLAGS_RELEASE\n\t\tCMAKE_CXX_FLAGS_MINSIZEREL CMAKE_CXX_FLAGS_RELWITHDEBINFO)\n\t\tif(${var} MATCHES \"/MD\")\n\t\t\tstring(REGEX REPLACE \"/MD\" \"/MT\" ${var} \"${${var}}\")\n\t\tendif()\n\tendforeach()\n\n\tadd_definitions(-wd4996 -D_CRT_SECURE_NO_DEPRECATE)\n\n\t# Don't auto-generate manifests\n\tset(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} /MANIFEST:NO\")\n\n  # Avoid linker warning when doing Debug build if dependent libraries are\n  # linked with the Release version of the static C library.\n  set(CMAKE_EXE_LINKER_FLAGS_DEBUG \"${CMAKE_EXE_LINKER_FLAGS_DEBUG} /NODEFAULTLIB:LIBCMT\")\nendif()\n\n# This ensures that we don't depend on libstdc++ or libgcc\nif(GNUCXX AND NOT APPLE AND NOT CYGWIN)\n\tset(DEFAULT_VGL_BUILDSTATIC 1)\n\toption(VGL_BUILDSTATIC\n\t\t\"Link statically against libgcc and libstdc++, if possible\"\n\t\t${DEFAULT_VGL_BUILDSTATIC})\n\tif(VGL_BUILDSTATIC)\n\t\t# For some reason, simply passing ${CMAKE_CXX_FLAGS} to the compiler in\n\t\t# execute_process() doesn't work.  Grrr...\n\t\texecute_process(COMMAND ${CMAKE_CXX_COMPILER} -m${BITS}\n\t\t\t--print-file-name=libstdc++.a OUTPUT_VARIABLE LIBSTDCPLUSPLUS\n\t\t\tRESULT_VARIABLE RESULT)\n\t\tstring(REGEX REPLACE \"\\n\" \"\" LIBSTDCPLUSPLUS ${LIBSTDCPLUSPLUS})\n\t\tif(RESULT MATCHES 0 AND LIBSTDCPLUSPLUS)\n\t\t\tmessage(STATUS \"Linking with static libstdc++:\\n   ${LIBSTDCPLUSPLUS}\")\n\t\t\tfile(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/staticlib)\n\t\t\texecute_process(COMMAND ${CMAKE_COMMAND} -E remove\n\t\t\t\t${CMAKE_BINARY_DIR}/staticlib/libstdc++.a)\n\t\t\texecute_process(COMMAND ${CMAKE_COMMAND} -E create_symlink\n\t\t\t\t${LIBSTDCPLUSPLUS} ${CMAKE_BINARY_DIR}/staticlib/libstdc++.a)\n\t\t\tset(CMAKE_EXE_LINKER_FLAGS\n\t\t\t\t\"${CMAKE_EXE_LINKER_FLAGS} -L${CMAKE_BINARY_DIR}/staticlib\")\n\t\t\tset(CMAKE_SHARED_LINKER_FLAGS\n\t\t\t\t\"${CMAKE_SHARED_LINKER_FLAGS} -L${CMAKE_BINARY_DIR}/staticlib\")\n\t\telse()\n\t\t\tmessage(WARNING \"Cannot find static libstdc++.  VirtualGL will depend on dynamic libstdc++.\")\n\t\tendif()\n\t\tif(CMAKE_COMPILER_IS_GNUCXX)\n\t\t\tadd_definitions(-static-libgcc)\n\t\tendif()\n\t\tset(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -static-libgcc\")\n\t\tset(CMAKE_SHARED_LINKER_FLAGS\n\t\t\t\"${CMAKE_SHARED_LINKER_FLAGS} -static-libgcc\")\n\tendif()\nendif()\n\n# Don't build RPATH into libraries generated in the build directory\nset(CMAKE_SKIP_BUILD_RPATH 1)\n\nif(GNUCC)\n\tadd_definitions(-D_GNU_SOURCE)\n\tif(NOT APPLE)\n\t\tset(MAPFLAG \"-Wl,--version-script,\")\n\tendif()\n\t# Use the maximum optimization level for release builds\n\tforeach(var CMAKE_C_FLAGS_RELEASE CMAKE_C_FLAGS_RELWITHDEBINFO\n\t\tCMAKE_CXX_FLAGS_RELEASE CMAKE_CXX_FLAGS_RELWITHDEBINFO)\n\t\tif(${var} MATCHES \"-O2\")\n\t\t\tstring(REGEX REPLACE \"-O2\" \"-O3\" ${var} \"${${var}}\")\n\t\tendif()\n\tendforeach()\n\tset(MINUSZ \"-Wl,-z,\")\nendif()\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n\tadd_definitions(-D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64)\nendif()\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"SunOS\")\n\tset(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -lc\")\n\tset(MAPFLAG \"-Wl,-M,\")\n\tif(\"${CMAKE_C_COMPILER_ID} ${CMAKE_CXX_COMPILER_ID}\" MATCHES SunPro)\n\t\tadd_definitions(-mt -norunpath)\n\t\tset(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -mt\")\n\t\tset(CMAKE_SHARED_LINKER_FLAGS\n\t\t\t\"-z direct -lCrun -z nodirect -mt ${CMAKE_SHARED_LINKER_FLAGS}\")\n\t\tset(MAPFLAG \"-M\")\n\t\tset(MINUSZ \"-z\")\n\n\t\t# Use the maximum optimization level for release builds\n\t\tforeach(var CMAKE_C_FLAGS_RELEASE CMAKE_C_FLAGS_RELWITHDEBINFO\n\t\t\tCMAKE_CXX_FLAGS_RELEASE CMAKE_CXX_FLAGS_RELWITHDEBINFO)\n\t\t\tif(${var} MATCHES \"-xO3\")\n\t\t\t\tstring(REGEX REPLACE \"-xO3\" \"-xO5\" ${var} \"${${var}}\")\n\t\t\tendif()\n\t\t\tif(${var} MATCHES \"-xO2\")\n\t\t\t\tstring(REGEX REPLACE \"-xO2\" \"-xO5\" ${var} \"${${var}}\")\n\t\t\tendif()\n\t\tendforeach()\n\tendif()\nendif()\n\noption(VGL_USESSL\n\t\"Enable SSL (Secure Sockets Layer) encryption feature in the VGL Transport\"\n\tOFF)\nboolean_number(VGL_USESSL)\nreport_option(VGL_USESSL \"SSL (Secure Sockets Layer) encryption\")\nif(VGL_USESSL)\n\tinclude(FindOpenSSL)\n\tif(NOT OPENSSL_FOUND)\n\t\tmessage(STATUS \"OpenSSL not found.  Disabling SSL support.\")\n\telse()\n\t\tadd_definitions(-DUSESSL)\n\t\tinclude_directories(${OPENSSL_INCLUDE_DIR})\n\tendif()\nendif()\n\nif(WIN32)\n\nset(VGL_USEXV 0)\nadd_subdirectory(util)\nadd_subdirectory(wgldemos)\nadd_subdirectory(diags)\n\nelse()\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n\tset(CMAKE_LIBRARY_PATH /usr/lib/${CPU_TYPE}-linux-gnu;/usr/lib${BITS};/usr/lib)\nendif()\ninclude(FindX11)\ninclude(FindOpenGL)\n\n# Ensure that we build and link against the X11 version of OpenGL on OS X\nif(APPLE)\n\toption(VGL_OSXOGLFIX \"Adds Linker arguments needed to correctly select the X11 OpenGL Library\" TRUE)\n\tif(VGL_OSXOGLFIX)\n\t\tset(CMAKE_EXE_LINKER_FLAGS\n\t\t\t\"${CMAKE_EXE_LINKER_FLAGS} -Wl,-dylib_file,/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib:/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib\")\n\t\tset(CMAKE_SHARED_LINKER_FLAGS\n\t\t\t\"${CMAKE_SHARED_LINKER_FLAGS} -Wl,-dylib_file,/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib:/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib\")\n\tendif()\n\tset(X11_X11_INCLUDE_PATH /usr/X11R6/include)\n\tset(OPENGL_gl_LIBRARY /usr/X11R6/lib/libGL.dylib)\n\tset(OPENGL_glu_LIBRARY /usr/X11R6/lib/libGLU.dylib)\nendif()\n\n# Not all OpenGL installations include all of the prototypes and constants in\n# glx.h and glxext.h that are necessary to build VirtualGL.  If you know that\n# yours does, then you can set VGL_SYSTEMGLX.\nset(VGL_DEFAULTSYSTEMGLX 0)\noption(VGL_SYSTEMGLX\n\t\"Compile against system-supplied versions of glx.h and glxext.h instead of the in-tree versions.\"\n\t${VGL_DEFAULTSYSTEMGLX})\nif(VGL_SYSTEMGLX)\n\tadd_definitions(-DSYSGLXHEADERS)\nendif()\n\ninclude_directories(${X11_X11_INCLUDE_PATH})\n\noption(VGL_USEXV \"Enable X Video support\" TRUE)\nboolean_number(VGL_USEXV)\n\nif(NOT X11_Xv_INCLUDE_PATH OR NOT X11_Xv_LIB)\n\tset(VGL_USEXV 0)\nendif()\nreport_option(VGL_USEXV \"X Video support\")\n\nif(VGL_USEXV)\n\tadd_definitions(-DUSEXV)\n\tinclude_directories(${X11_Xv_INCLUDE_PATH})\nendif()\n\nif(NOT WIN32)\n\tinclude(cmakescripts/FindTurboJPEG.cmake)\nendif()\n\nif(NOT CMAKE_SYSTEM_NAME MATCHES \"FreeBSD\")\n\tset(LIBDL dl)\nendif()\n\nendif() # WIN32\n\nstring(TOUPPER ${CMAKE_BUILD_TYPE} CMAKE_BUILD_TYPE_UC)\n\nset(EFFECTIVE_C_FLAGS \"${CMAKE_C_FLAGS} ${CMAKE_C_FLAGS_${CMAKE_BUILD_TYPE_UC}}\")\nmessage(STATUS \"Compiler flags = ${EFFECTIVE_C_FLAGS}\")\n\nset(EFFECTIVE_LD_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} ${CMAKE_EXE_LINKER_FLAGS_${CMAKE_BUILD_TYPE_UC}}\")\nmessage(STATUS \"Linker flags = ${EFFECTIVE_LD_FLAGS}\")\n\n\n###############################################################################\n# TARGETS\n###############################################################################\n\nif(NOT WIN32)\n\nif(VGL_BUILDSERVER)\n\tset(DEFAULT_VGL_FAKER_NAME vglfaker)\n\tset(VGL_FAKER_NAME ${DEFAULT_VGL_FAKER_NAME} CACHE STRING\n\t\t\"Base name for VirtualGL's GLX/OpenGL/X11 interposer library (default: ${DEFAULT_VGL_FAKER_NAME})\")\n\n\tset(DEFAULT_VGL_DLFAKER_NAME dlfaker)\n\tset(VGL_DLFAKER_NAME ${DEFAULT_VGL_DLFAKER_NAME} CACHE STRING\n\t\t\"Base name for VirtualGL's dlopen() interposer library (default: ${DEFAULT_VGL_DLFAKER_NAME})\")\n\n\tset(DEFAULT_VGL_GEFAKER_NAME gefaker)\n\tset(VGL_GEFAKER_NAME ${DEFAULT_VGL_GEFAKER_NAME} CACHE STRING\n\t\t\"Base name for VirtualGL's getenv() interposer library (default: ${DEFAULT_VGL_GEFAKER_NAME})\")\n\n\tset(CMAKE_POSITION_INDEPENDENT_CODE 1)\nendif()\n\nset(FBXLIB fbx)\nif(VGL_USEXV)\n\tset(FBXLIB ${FBXLIB};fbxv)\nendif()\n\nadd_subdirectory(util)\nadd_subdirectory(common)\nif(VGL_BUILDSERVER)\n\tadd_subdirectory(server)\nendif()\nadd_subdirectory(client)\nadd_subdirectory(glxdemos)\nadd_subdirectory(diags)\nadd_subdirectory(doc)\n\nelse()\n\ninstall(FILES LICENSE.txt LGPL.txt DESTINATION ${CMAKE_INSTALL_DOCDIR})\n\nendif() # WIN32\n\n\n###############################################################################\n# INSTALLATION AND PACKAGING\n###############################################################################\n\ninclude(cmakescripts/BuildPackages.cmake)\n\nconfigure_file(\"${CMAKE_SOURCE_DIR}/cmakescripts/cmake_uninstall.cmake.in\"\n  \"cmake_uninstall.cmake\" IMMEDIATE @ONLY)\n\nadd_custom_target(uninstall COMMAND ${CMAKE_COMMAND} -P cmake_uninstall.cmake)\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/server/vglrun.in": "#!/bin/sh\n\n# Copyright (C)2004 Landmark Graphics Corporation\n# Copyright (C)2005 Sun Microsystems, Inc.\n# Copyright (C)2009-2016 D. R. Commander\n#\n# This library is free software and may be redistributed and/or modified under\n# the terms of the wxWindows Library License, Version 3.1 or (at your option)\n# any later version.  The full license is in the LICENSE.txt file included\n# with this distribution.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# wxWindows Library License for more details.\n\n# The interpreter to use (if this script is submitted to N1 Grid Engine):\n#$ -S /bin/sh\n#\n# This allocates a graphics device and passes it in the VGL_DISPLAY\n# environment:\n#$ -l gfx=1\n#\n# Specify other environment variables that N1GE should pass to this script:\n#$ -v DISPLAY\n#$ -v SSH_CLIENT\n#$ -v VGL_CLIENT\n#$ -v VGL_COMPRESS\n#$ -v VGL_PORT\n#$ -v VGL_SSL\n#$ -v VGL_GLLIB\n#$ -v VGL_X11LIB\n#$ -v VGL_GAMMA\n#$ -v VGL_PROGRESSIVE\n#$ -v VGL_NPROCS\n\nusage()\n{\n\techo\n\techo \"Usage: `basename $0` [options] [--] <OpenGL app> [OpenGL app arguments]\"\n\techo\n\techo \"VirtualGL options (see documentation for a more comprehensive list)\"\n\techo\n\techo \"-c <c>    : proxy = Send 3D images uncompressed using X11 Transport\"\n\techo \"                    [default for local X connections]\"\n\techo \"            jpeg = Compress 3D images using JPEG/send using VGL Transport\"\n\techo \"                   [default for remote X connections]\"\n\techo \"            rgb = Encode 3D images as RGB/send using VGL Transport\"\n\techo \"            xv = Encode 3D images as YUV420P/send using XV Transport\"\n\techo \"            yuv = Encode 3D images as YUV420P/send using the VGL Transport\"\n\techo \"                  and display on the client using X Video\"\n\techo \"            [If an image transport plugin is being used, then <c> can be any\"\n\techo \"             number >= 0 (default=0).]\"\n\techo\n\techo \"-nodl     : Don't interpose the dlopen() function.  dlopen() is normally\"\n\techo \"            interposed to force applications that use dlopen() to load libGL\"\n\techo \"            to load VirtualGL instead.  For the more common case of\"\n\techo \"            applications that link directly with libGL, disabling the dlopen()\"\n\techo \"            interposer makes VirtualGL less intrusive, since it will no longer\"\n\techo \"            load libGL until the application actually uses that library.\"\n\techo\n\techo \"-d <d>    : <d> = the X Display to use for 3D rendering [default = :0.0]\"\n\techo\n\techo \"-fps <f>  : Limit client/server frame rate to <f> frames/sec\"\n\techo\n\techo \"-gamma <g>: Set gamma correction factor to <g> (see docs)\"\n\techo\n\techo \"-ge       : Fool application into thinking that LD_PRELOAD is unset\"\n\techo\n\techo \"-ms <s>   : Force VirtualGL to use OpenGL multisampling with <s>\"\n\techo \"            samples (<s> = 0 forces multisampling to be disabled)\"\n\techo\n\techo \"-np <n>   : Use <n> CPUs to perform image compression [default = 1]\"\n\techo\n\techo \"+/-pr     : Enable/disable performance profiling output [default = disabled]\"\n\techo\n\techo \"-q <q>    : Compression quality [1 <= <q> <= 100]\"\n\techo \"            [default = 95 for JPEG/VGL Transport.  Has no effect with\"\n\techo \"             X11 Transport]\"\n\techo\n\techo \"-samp <s> : Chrominance subsampling factor\"\n\techo \"            <s> = gray, 1x, 2x, 4x\"\n\techo \"            [default = 1x for JPEG/VGL Transport.  Has no effect with\"\n\techo \"             X11 Transport or RGB encoding]\"\n\techo\n\techo \"+/-s      : Enable/disable SSL encryption of VGL Transport or custom\"\n\techo \"            image transport, if applicable.\"\n\techo \"            [default = disabled.  Has no effect on the VGL Transport unless\"\n\techo \"             VirtualGL was built with OpenSSL support]\"\n\techo\n\techo \"+/-sp     : Turn on/off frame spoiling [default = enabled]\"\n\techo\n\techo \"-st <s>   : left = Send only left eye buffer of stereo application\"\n\techo \"            right = Send only right eye buffer of stereo application\"\n\techo \"            quad = Use quad-buffered stereo if available, otherwise use\"\n\techo \"                   red/cyan (anaglyphic) stereo [default]\"\n\techo \"            rc = Always use red/cyan (anaglyphic) stereo\"\n\techo \"            gm = Always use green/magenta (anaglyphic) stereo\"\n\techo \"            by = Always use blue/yellow (anaglyphic) stereo\"\n\techo \"            i = Always use interleaved (passive) stereo\"\n\techo \"            tb = Always use top/bottom (passive) stereo\"\n\techo \"            ss = Always use side-by-side (passive) stereo\"\n\techo\n\techo \"+/-sync   : Enable/disable strict 2D/3D synchronization [default = disabled]\"\n\techo\n\techo \"+/-tr     : Enable/disable function call tracing (generates a lot of output)\"\n\techo \"            [default = disabled]\"\n\techo\n\techo \"-trans <t>: Use transport plugin contained in library libvgltrans_<t>.so\"\n\techo\n\techo \"+/-v      : Enable/disable verbose VirtualGL messages [default = disabled]\"\n\techo\n\techo \"+xcb/-xcb : Enable/disable XCB interposer [default = enabled]\"\n\techo\n\techo \"+wm/-wm   : Enable/disable window manager mode (for running compiz, etc.)\"\n\techo\n\techo \"-64       : (Solaris only) Preload VirtualGL only into 64-bit apps\"\n\techo \"-32       : (Solaris only) Preload VirtualGL only into 32-bit apps\"\n\techo\n\texit $1\n}\n\nGEOPROBE_USEGLX=1\nexport GEOPROBE_USEGLX\nPROMAGIC_USEGLX=1\nexport PROMAGIC_USEGLX\nVBOX_CROGL_FORCE_SUPPORTED=1\nexport VBOX_CROGL_FORCE_SUPPORTED\n\n__VGL_DL=1\n__VGL_GE=0\nVGL_LIBRARY_PATH=\nMYPATH=`dirname $0`\n\nwhile [ $# -gt 0 ]\ndo\n\tcase \"$1\" in\n\t+sy*)       VGL_SYNC=1        ; export VGL_SYNC     ;;\n\t-sy*)       VGL_SYNC=0        ; export VGL_SYNC     ;;\n\t-st*)       VGL_STEREO=$2     ; export VGL_STEREO   ; shift     ;;\n\t+sp*)       VGL_SPOIL=1       ; export VGL_SPOIL    ;;\n\t-sp*)       VGL_SPOIL=0       ; export VGL_SPOIL    ;;\n\t-sa*)       VGL_SUBSAMP=$2    ; export VGL_SUBSAMP  ; shift     ;;\n\t-s*)        VGL_SSL=0         ; export VGL_SSL      ;;\n\t+s*)        VGL_SSL=1         ; export VGL_SSL      ;;\n\t-prog*)     VGL_PROGRESSIVE=0 ; export VGL_PROGRESSIVE  ;;\n\t+prog*)     VGL_PROGRESSIVE=1 ; export VGL_PROGRESSIVE  ;;\n\t-pr*)       VGL_PROFILE=0     ; export VGL_PROFILE  ;;\n\t+pr*)       VGL_PROFILE=1     ; export VGL_PROFILE  ;;\n\t-q*)        VGL_QUAL=$2       ; export VGL_QUAL     ; shift     ;;\n\t+de*)       VGL_DEBUG=1       ; export VGL_DEBUG    ;;\n\t-de*)       VGL_DEBUG=0       ; export VGL_DEBUG    ;;\n\t-nodl)      __VGL_DL=0        ;;\n\t-trans*)    VGL_TRANSPORT=$2  ; export VGL_TRANSPORT; shift     ;;\n\t+tr*)       VGL_TRACE=1       ; export VGL_TRACE    ;;\n\t-tr*)       VGL_TRACE=0       ; export VGL_TRACE    ;;\n\t-d*)        VGL_DISPLAY=$2    ; export VGL_DISPLAY  ; shift     ;;\n\t-cl*)       VGL_CLIENT=$2     ; export VGL_CLIENT   ; shift     ;;\n\t-p*)        VGL_PORT=$2       ; export VGL_PORT     ; shift     ;;\n\t-c*)        VGL_COMPRESS=$2   ; export VGL_COMPRESS ; shift     ;;\n\t-np*)       VGL_NPROCS=$2     ; export VGL_NPROCS   ; shift     ;;\n\t-gamma)     VGL_GAMMA=$2      ; export VGL_GAMMA    ; shift     ;;\n\t-ge)        __VGL_GE=1        ;;\n\t-g*)        VGL_GAMMA=0       ; export VGL_GAMMA    ;;\n\t+g*)        VGL_GAMMA=1       ; export VGL_GAMMA    ;;\n\t-v*)        VGL_VERBOSE=0     ; export VGL_VERBOSE  ;;\n\t+v*)        VGL_VERBOSE=1     ; export VGL_VERBOSE  ;;\n\t-fps)       VGL_FPS=$2        ; export VGL_FPS      ; shift     ;;\n\t-ms)        VGL_SAMPLES=$2    ; export VGL_SAMPLES  ; shift     ;;\n\t+wm)        VGL_WM=1          ; export VGL_WM       ;;\n\t-wm)        VGL_WM=0          ; export VGL_WM       ;;\n\t+xcb)       VGL_FAKEXCB=1     ; export VGL_FAKEXCB  ;;\n\t-xcb)       VGL_FAKEXCB=0     ; export VGL_FAKEXCB  ;;\n\t-ld)        VGL_LIBRARY_PATH=$2 ; shift ;;\n\t-h)         usage 0 ;;\n\t--help)     usage 0 ;;\n\t--)         shift   ; break ;;\n\t-*)         usage 1 ;;\n\t*)          break   ;;\n\tesac\n\tshift\ndone\nif [ $# -eq 0 ]\nthen\n\tusage 0\nfi\n\nif [ -r /etc/opt/VirtualGL/vgl_xauth_key ]; then\n\tXAUTH=xauth\n\tif [ -x /usr/X11R6/bin/xauth ]; then\n\t\tXAUTH=/usr/X11R6/bin/xauth\n\tfi\n\tif [ -x /usr/openwin/bin/xauth ]; then\n\t\tXAUTH=/usr/openwin/bin/xauth\n\tfi\n\t$XAUTH merge /etc/opt/VirtualGL/vgl_xauth_key\nfi\n\nSSH_IP=`echo $SSH_CLIENT | cut -d' ' -f1 | cut -d: -f4`\nif [ -z \"$DISPLAY\" ]; then\n\tif [ ! -z \"$SSH_IP\" ]; then\n\t\tDISPLAY=$SSH_IP:0.0\n\t\texport DISPLAY\n\t\techo \"[VGL] NOTICE: Automatically setting the DISPLAY environment variable to\"\n\t\techo \"[VGL]    $DISPLAY, based on the IP address of your SSH client.\"\n\tfi\nelse\n\tDISPLAYHOST=`echo $DISPLAY | cut -d: -f1`\n\tif [ \"$DISPLAYHOST\" = \"localhost\" -o \"$DISPLAYHOST\" = \"`hostname`\" ]; then\n\t\tif [ ! -z \"$SSH_IP\" -a -z \"$VGL_CLIENT\" -a -z \"$RRCLIENT\" ]; then\n\t\t\tVGL_CLIENT=$SSH_IP:0.0\n\t\t\texport VGL_CLIENT\n\t\t\techo \"[VGL] NOTICE: Automatically setting VGL_CLIENT environment variable to\"\n\t\t\techo \"[VGL]    $SSH_IP, the IP address of your SSH client.\"\n\t\tfi\n\tfi\nfi\n\n# This is so we can launch both 32-bit and 64-bit executables using the same\n# script.\nif [ -x \"$MYPATH/.vglrun.vars64\" ]; then\n\t. \"$MYPATH/.vglrun.vars64\"\nfi\nif [ -x \"$MYPATH/.vglrun.vars32\" ]; then\n\t. \"$MYPATH/.vglrun.vars32\"\nfi\nif [ ! -z \"$VGL_LIBRARY_PATH\" ]; then\n\tLD_LIBRARY_PATH=$VGL_LIBRARY_PATH:$LD_LIBRARY_PATH\n\texport LD_LIBRARY_PATH\n\tif [ ! -z \"$VGL_VERBOSE\" ]; then\n\t\tif [ $VGL_VERBOSE -eq 1 ]; then\n\t\t\techo [VGL] NOTICE: Added $VGL_LIBRARY_PATH to LD_LIBRARY_PATH\n\t\tfi\n\tfi\nfi\n\n# This allows scripts to detect whether they are being launched with vglrun.\nVGL_ISACTIVE=1\nexport VGL_ISACTIVE\n\nSUFFIX=\nif [ $__VGL_DL -eq 0 ]; then\n\tSUFFIX=-nodl\nfi\nif [ -z \"$LD_PRELOAD\" ]; then\n\tLD_PRELOAD=lib@VGL_FAKER_NAME@$SUFFIX.so\nelse\n\tLD_PRELOAD=lib@VGL_FAKER_NAME@$SUFFIX.so:$LD_PRELOAD\nfi\nif [ $__VGL_DL -eq 1 ]; then\n\tLD_PRELOAD=lib@VGL_DLFAKER_NAME@.so:$LD_PRELOAD\nfi\nif [ $__VGL_GE -eq 1 ]; then\n\tLD_PRELOAD=lib@VGL_GEFAKER_NAME@.so:$LD_PRELOAD\nfi\nexport LD_PRELOAD\nexec ${1+\"$@\"}\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/server/TransPlugin.cpp": "/* Copyright (C)2009-2011, 2014 D. R. Commander\n *\n * This library is free software and may be redistributed and/or modified under\n * the terms of the wxWindows Library License, Version 3.1 or (at your option)\n * any later version.  The full license is in the LICENSE.txt file included\n * with this distribution.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * wxWindows Library License for more details.\n */\n\n#include \"TransPlugin.h\"\n#include \"fakerconfig.h\"\n#include <dlfcn.h>\n#include <string.h>\n#include \"Error.h\"\n\nusing namespace vglutil;\nusing namespace vglserver;\n\n\n#undef _throw\n#define _throw(m) throw(Error(\"transport plugin\", m, -1))\n\n\nstatic void *loadsym(void *dllhnd, const char *symbol)\n{\n\tvoid *sym=NULL;  const char *err=NULL;\n\tsym=dlsym(dllhnd, (char *)symbol);\n\tif(!sym)\n\t{\n\t\terr=dlerror();\n\t\tif(err) _throw(err);\n\t\telse _throw(\"Could not load symbol\");\n\t}\n\treturn sym;\n}\n\n\nTransPlugin::TransPlugin(Display *dpy, Window win, char *name)\n{\n\tif(!name || strlen(name)<1) _throw(\"Transport name is empty or NULL!\");\n\tconst char *err=NULL;\n\tCriticalSection::SafeLock l(mutex);\n\tdlerror();  // Clear error state\n\tchar filename[MAXSTR];\n\tsnprintf(filename, MAXSTR-1, \"libvgltrans_%s.so\", name);\n\tdllhnd=dlopen(filename, RTLD_NOW);\n\tif(!dllhnd)\n\t{\n\t\terr=dlerror();\n\t\tif(err) _throw(err);\n\t\telse _throw(\"Could not open transport plugin\");\n\t}\n\t_RRTransInit=(_RRTransInitType)loadsym(dllhnd, \"RRTransInit\");\n\t_RRTransConnect=(_RRTransConnectType)loadsym(dllhnd, \"RRTransConnect\");\n\t_RRTransGetFrame=(_RRTransGetFrameType)loadsym(dllhnd, \"RRTransGetFrame\");\n\t_RRTransReady=(_RRTransReadyType)loadsym(dllhnd, \"RRTransReady\");\n\t_RRTransSynchronize=(_RRTransSynchronizeType)loadsym(dllhnd, \"RRTransSynchronize\");\n\t_RRTransSendFrame=(_RRTransSendFrameType)loadsym(dllhnd, \"RRTransSendFrame\");\n\t_RRTransDestroy=(_RRTransDestroyType)loadsym(dllhnd, \"RRTransDestroy\");\n\t_RRTransGetError=(_RRTransGetErrorType)loadsym(dllhnd, \"RRTransGetError\");\n\tif(!(handle=_RRTransInit(dpy, win, &fconfig))) _throw(_RRTransGetError());\n}\n\n\nTransPlugin::~TransPlugin(void)\n{\n\tCriticalSection::SafeLock l(mutex);\n\tdestroy();\n\tif(dllhnd) dlclose(dllhnd);\n}\n\n\nvoid TransPlugin::connect(char *receiverName, int port)\n{\n\tCriticalSection::SafeLock l(mutex);\n\tint ret=_RRTransConnect(handle, receiverName, port);\n\tif(ret<0) _throw(_RRTransGetError());\n}\n\n\nvoid TransPlugin::destroy(void)\n{\n\tCriticalSection::SafeLock l(mutex);\n\tint ret=_RRTransDestroy(handle);\n\tif(ret<0) _throw(_RRTransGetError());\n}\n\n\nint TransPlugin::ready(void)\n{\n\tCriticalSection::SafeLock l(mutex);\n\tint ret=_RRTransReady(handle);\n\tif(ret<0) _throw(_RRTransGetError());\n\treturn ret;\n}\n\n\nvoid TransPlugin::synchronize(void)\n{\n\tCriticalSection::SafeLock l(mutex);\n\tint ret=_RRTransSynchronize(handle);\n\tif(ret<0) _throw(_RRTransGetError());\n}\n\n\nRRFrame *TransPlugin::getFrame(int width, int height, int format, bool stereo)\n{\n\tCriticalSection::SafeLock l(mutex);\n\tRRFrame *ret=_RRTransGetFrame(handle, width, height, format, stereo);\n\tif(!ret) _throw(_RRTransGetError());\n\treturn ret;\n}\n\n\nvoid TransPlugin::sendFrame(RRFrame *frame, bool sync)\n{\n\tCriticalSection::SafeLock l(mutex);\n\tint ret=_RRTransSendFrame(handle, frame, sync);\n\tif(ret<0) _throw(_RRTransGetError());\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/server/faker-sym.h": "/* Copyright (C)2004 Landmark Graphics Corporation\n * Copyright (C)2005, 2006 Sun Microsystems, Inc.\n * Copyright (C)2009, 2011, 2013-2016 D. R. Commander\n *\n * This library is free software and may be redistributed and/or modified under\n * the terms of the wxWindows Library License, Version 3.1 or (at your option)\n * any later version.  The full license is in the LICENSE.txt file included\n * with this distribution.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * wxWindows Library License for more details.\n */\n\n#ifndef __FAKER_SYM_H__\n#define __FAKER_SYM_H__\n\n#include <stdio.h>\n#define GL_GLEXT_PROTOTYPES\n#define GLX_GLXEXT_PROTOTYPES\n#include \"glx.h\"\n#include \"Log.h\"\n#include \"GlobalCriticalSection.h\"\n#ifdef FAKEXCB\nextern \"C\" {\n#ifdef SYSXCBHEADERS\n#include <xcb/xcb.h>\n#include <xcb/xcbext.h>\n#include <xcb/xcb_keysyms.h>\n#include <xcb/glx.h>\n#include <X11/Xlib-xcb.h>\n#else\n#include \"xcb_headers/xcb.h\"\n#include \"xcb_headers/xcbext.h\"\n#include \"xcb_headers/xcb_keysyms.h\"\n#include \"xcb_headers/glx.h\"\n#include \"xcb_headers/Xlib-xcb.h\"\n#endif\n}\n#endif\n\n\nnamespace vglfaker\n{\n\textern void safeExit(int);\n\textern void init(void);\n\textern long getFakerLevel(void);\n\textern void setFakerLevel(long level);\n\n\tvoid *loadSymbol(const char *name, bool optional=false);\n\tvoid unloadSymbols(void);\n}\n\n\n#define CHECKSYM_NONFATAL(s) {  \\\n\tif(!__##s) {  \\\n\t\tvglfaker::init();  \\\n\t\tvglfaker::GlobalCriticalSection::SafeLock l(globalMutex);  \\\n\t\tif(!__##s) __##s=(_##s##Type)vglfaker::loadSymbol(#s, true);  \\\n\t}  \\\n}\n\n#define CHECKSYM(s, fake_s) {  \\\n\tif(!__##s) {  \\\n\t\tvglfaker::init();  \\\n\t\tvglfaker::GlobalCriticalSection::SafeLock l(globalMutex);  \\\n\t\tif(!__##s) __##s=(_##s##Type)vglfaker::loadSymbol(#s);  \\\n\t}  \\\n\tif(!__##s) vglfaker::safeExit(1);  \\\n\tif(__##s==fake_s) {  \\\n\t\tvglout.print(\"[VGL] ERROR: VirtualGL attempted to load the real\\n\");  \\\n\t\tvglout.print(\"[VGL]   \" #s \" function and got the fake one instead.\\n\");  \\\n\t\tvglout.print(\"[VGL]   Something is terribly wrong.  Aborting before chaos ensues.\\n\");  \\\n\t\tvglfaker::safeExit(1);  \\\n\t}  \\\n}\n\n#ifdef __LOCALSYM__\n#define SYMDEF(f) _##f##Type __##f=NULL\n#else\n#define SYMDEF(f) extern _##f##Type __##f\n#endif\n\n\n#define DISABLE_FAKER() vglfaker::setFakerLevel(vglfaker::getFakerLevel()+1);\n#define ENABLE_FAKER()  vglfaker::setFakerLevel(vglfaker::getFakerLevel()-1);\n\n\n#define FUNCDEF0(RetType, f, fake_f) \\\n\ttypedef RetType (*_##f##Type)(void); \\\n\tSYMDEF(f); \\\n\tstatic inline RetType _##f(void) { \\\n\t\tRetType retval; \\\n\t\tCHECKSYM(f, fake_f); \\\n\t\tDISABLE_FAKER(); \\\n\t\tretval=__##f(); \\\n\t\tENABLE_FAKER(); \\\n\t\treturn retval; \\\n\t}\n\n#define VFUNCDEF0(f, fake_f) \\\n\ttypedef void (*_##f##Type)(void); \\\n\tSYMDEF(f); \\\n\tstatic inline void _##f(void) { \\\n\t\tCHECKSYM(f, fake_f); \\\n\t\tDISABLE_FAKER(); \\\n\t\t__##f(); \\\n\t\tENABLE_FAKER(); \\\n\t}\n\n#define FUNCDEF1(RetType, f, at1, a1, fake_f) \\\n\ttypedef RetType (*_##f##Type)(at1); \\\n\tSYMDEF(f); \\\n\tstatic inline RetType _##f(at1 a1) { \\\n\t\tRetType retval; \\\n\t\tCHECKSYM(f, fake_f); \\\n\t\tDISABLE_FAKER(); \\\n\t\tretval=__##f(a1); \\\n\t\tENABLE_FAKER(); \\\n\t\treturn retval; \\\n\t}\n\n#define VFUNCDEF1(f, at1, a1, fake_f) \\\n\ttypedef void (*_##f##Type)(at1); \\\n\tSYMDEF(f); \\\n\tstatic inline void _##f(at1 a1) { \\\n\t\tCHECKSYM(f, fake_f); \\\n\t\tDISABLE_FAKER(); \\\n\t\t__##f(a1); \\\n\t\tENABLE_FAKER(); \\\n\t}\n\n#define FUNCDEF2(RetType, f, at1, a1, at2, a2, fake_f) \\\n\ttypedef RetType (*_##f##Type)(at1, at2); \\\n\tSYMDEF(f); \\\n\tstatic inline RetType _##f(at1 a1, at2 a2) { \\\n\t\tRetType retval; \\\n\t\tCHECKSYM(f, fake_f); \\\n\t\tDISABLE_FAKER(); \\\n\t\tretval=__##f(a1, a2); \\\n\t\tENABLE_FAKER(); \\\n\t\treturn retval; \\\n\t}\n\n#define VFUNCDEF2(f, at1, a1, at2, a2, fake_f) \\\n\ttypedef void (*_##f##Type)(at1, at2); \\\n\tSYMDEF(f); \\\n\tstatic inline void _##f(at1 a1, at2 a2) { \\\n\t\tCHECKSYM(f, fake_f); \\\n\t\tDISABLE_FAKER(); \\\n\t\t__##f(a1, a2); \\\n\t\tENABLE_FAKER(); \\\n\t}\n\n#define FUNCDEF3(RetType, f, at1, a1, at2, a2, at3, a3, fake_f) \\\n\ttypedef RetType (*_##f##Type)(at1, at2, at3); \\\n\tSYMDEF(f); \\\n\tstatic inline RetType _##f(at1 a1, at2 a2, at3 a3) { \\\n\t\tRetType retval; \\\n\t\tCHECKSYM(f, fake_f); \\\n\t\tDISABLE_FAKER(); \\\n\t\tretval=__##f(a1, a2, a3); \\\n\t\tENABLE_FAKER(); \\\n\t\treturn retval; \\\n\t}\n\n#define VFUNCDEF3(f, at1, a1, at2, a2, at3, a3, fake_f) \\\n\ttypedef void (*_##f##Type)(at1, at2, at3); \\\n\tSYMDEF(f); \\\n\tstatic inline void _##f(at1 a1, at2 a2, at3 a3) { \\\n\t\tCHECKSYM(f, fake_f); \\\n\t\tDISABLE_FAKER(); \\\n\t\t__##f(a1, a2, a3); \\\n\t\tENABLE_FAKER(); \\\n\t}\n\n#define FUNCDEF4(RetType, f, at1, a1, at2, a2, at3, a3, at4, a4, fake_f) \\\n\ttypedef RetType (*_##f##Type)(at1, at2, at3, at4); \\\n\tSYMDEF(f); \\\n\tstatic inline RetType _##f(at1 a1, at2 a2, at3 a3, at4 a4) { \\\n\t\tRetType retval; \\\n\t\tCHECKSYM(f, fake_f); \\\n\t\tDISABLE_FAKER(); \\\n\t\tretval=__##f(a1, a2, a3, a4); \\\n\t\tENABLE_FAKER(); \\\n\t\treturn retval; \\\n\t}\n\n#define VFUNCDEF4(f, at1, a1, at2, a2, at3, a3, at4, a4, fake_f) \\\n\ttypedef void (*_##f##Type)(at1, at2, at3, at4); \\\n\tSYMDEF(f); \\\n\tstatic inline void _##f(at1 a1, at2 a2, at3 a3, at4 a4) { \\\n\t\tCHECKSYM(f, fake_f); \\\n\t\tDISABLE_FAKER(); \\\n\t\t__##f(a1, a2, a3, a4); \\\n\t\tENABLE_FAKER(); \\\n\t}\n\n#define FUNCDEF5(RetType, f, at1, a1, at2, a2, at3, a3, at4, a4, at5, a5, \\\n\tfake_f) \\\n\ttypedef RetType (*_##f##Type)(at1, at2, at3, at4, at5); \\\n\tSYMDEF(f); \\\n\tstatic inline RetType _##f(at1 a1, at2 a2, at3 a3, at4 a4, at5 a5) { \\\n\t\tRetType retval; \\\n\t\tCHECKSYM(f, fake_f); \\\n\t\tDISABLE_FAKER(); \\\n\t\tretval=__##f(a1, a2, a3, a4, a5); \\\n\t\tENABLE_FAKER(); \\\n\t\treturn retval; \\\n\t}\n\n#define VFUNCDEF5(f, at1, a1, at2, a2, at3, a3, at4, a4, at5, a5, fake_f) \\\n\ttypedef void (*_##f##Type)(at1, at2, at3, at4, at5); \\\n\tSYMDEF(f); \\\n\tstatic inline void _##f(at1 a1, at2 a2, at3 a3, at4 a4, at5 a5) { \\\n\t\tCHECKSYM(f, fake_f); \\\n\t\tDISABLE_FAKER(); \\\n\t\t__##f(a1, a2, a3, a4, a5); \\\n\t\tENABLE_FAKER(); \\\n\t}\n\n#define VFUNCDEF6(f, at1, a1, at2, a2, at3, a3, at4, a4, at5, a5, at6, a6, \\\n\tfake_f) \\\n\ttypedef void (*_##f##Type)(at1, at2, at3, at4, at5, at6); \\\n\tSYMDEF(f); \\\n\tstatic inline void _##f(at1 a1, at2 a2, at3 a3, at4 a4, at5 a5, at6 a6) { \\\n\t\tCHECKSYM(f, fake_f); \\\n\t\tDISABLE_FAKER(); \\\n\t\t__##f(a1, a2, a3, a4, a5, a6); \\\n\t\tENABLE_FAKER(); \\\n\t}\n\n#define FUNCDEF6(RetType, f, at1, a1, at2, a2, at3, a3, at4, a4, at5, a5, \\\n\tat6, a6, fake_f) \\\n\ttypedef RetType (*_##f##Type)(at1, at2, at3, at4, at5, at6); \\\n\tSYMDEF(f); \\\n\tstatic inline RetType _##f(at1 a1, at2 a2, at3 a3, at4 a4, at5 a5, \\\n\t\tat6 a6) { \\\n\t\tRetType retval; \\\n\t\tCHECKSYM(f, fake_f); \\\n\t\tDISABLE_FAKER(); \\\n\t\tretval=__##f(a1, a2, a3, a4, a5, a6); \\\n\t\tENABLE_FAKER(); \\\n\t\treturn retval; \\\n\t}\n\n#define VFUNCDEF7(f, at1, a1, at2, a2, at3, a3, at4, a4, at5, at, at6, a6, \\\n\tat7, a7, fake_f) \\\n\ttypedef void (*_##f##Type)(at1, at2, at3, at4, at5, at6, at7); \\\n\tSYMDEF(f); \\\n\tstatic inline void _##f(at1 a1, at2 a2, at3 a3, at4 a4, at5 a5, at6 a6, \\\n\t\tat7 a7) { \\\n\t\tCHECKSYM(f, fake_f); \\\n\t\tDISABLE_FAKER(); \\\n\t\t__##f(a1, a2, a3, a4, a5, a6, a7); \\\n\t\tENABLE_FAKER(); \\\n\t}\n\n#define FUNCDEF8(RetType, f, at1, a1, at2, a2, at3, a3, at4, a4, at5, a5, \\\n\tat6, a6, at7, a7, at8, a8, fake_f) \\\n\ttypedef RetType (*_##f##Type)(at1, at2, at3, at4, at5, at6, at7, at8); \\\n\tSYMDEF(f); \\\n\tstatic inline RetType _##f(at1 a1, at2 a2, at3 a3, at4 a4, at5 a5, at6 a6, \\\n\t\tat7 a7, at8 a8) { \\\n\t\tRetType retval; \\\n\t\tCHECKSYM(f, fake_f); \\\n\t\tDISABLE_FAKER(); \\\n\t\tretval=__##f(a1, a2, a3, a4, a5, a6, a7, a8); \\\n\t\tENABLE_FAKER(); \\\n\t\treturn retval; \\\n\t}\n\n#define FUNCDEF9(RetType, f, at1, a1, at2, a2, at3, a3, at4, a4, at5, a5, \\\n\tat6, a6, at7, a7, at8, a8, at9, a9, fake_f) \\\n\ttypedef RetType (*_##f##Type)(at1, at2, at3, at4, at5, at6, at7, at8, at9); \\\n\tSYMDEF(f); \\\n\tstatic inline RetType _##f(at1 a1, at2 a2, at3 a3, at4 a4, at5 a5, at6 a6, \\\n\t\tat7 a7, at8 a8, at9 a9) { \\\n\t\tRetType retval; \\\n\t\tCHECKSYM(f, fake_f); \\\n\t\tDISABLE_FAKER(); \\\n\t\tretval=__##f(a1, a2, a3, a4, a5, a6, a7, a8, a9); \\\n\t\tENABLE_FAKER(); \\\n\t\treturn retval; \\\n\t}\n\n#define FUNCDEF10(RetType, f, at1, a1, at2, a2, at3, a3, at4, a4, at5, a5, \\\n\tat6, a6, at7, a7, at8, a8, at9, a9, at10, a10, fake_f) \\\n\ttypedef RetType (*_##f##Type)(at1, at2, at3, at4, at5, at6, at7, at8, at9, \\\n\t\tat10); \\\n\tSYMDEF(f); \\\n\tstatic inline RetType _##f(at1 a1, at2 a2, at3 a3, at4 a4, at5 a5, at6 a6, \\\n\t\tat7 a7, at8 a8, at9 a9, at10 a10) { \\\n\t\tRetType retval; \\\n\t\tCHECKSYM(f, fake_f); \\\n\t\tDISABLE_FAKER(); \\\n\t\tretval=__##f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); \\\n\t\tENABLE_FAKER(); \\\n\t\treturn retval; \\\n\t}\n\n#define FUNCDEF12(RetType, f, at1, a1, at2, a2, at3, a3, at4, a4, at5, a5, \\\n\tat6, a6, at7, a7, at8, a8, at9, a9, at10, a10, at11, a11, at12, a12, \\\n\tfake_f) \\\n\ttypedef RetType (*_##f##Type)(at1, at2, at3, at4, at5, at6, at7, at8, at9, \\\n\t\tat10, at11, at12); \\\n\tSYMDEF(f); \\\n\tstatic inline RetType _##f(at1 a1, at2 a2, at3 a3, at4 a4, at5 a5, at6 a6, \\\n\t\tat7 a7, at8 a8, at9 a9, at10 a10, at11 a11, at12 a12) { \\\n\t\tRetType retval; \\\n\t\tCHECKSYM(f, fake_f); \\\n\t\tDISABLE_FAKER(); \\\n\t\tretval=__##f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); \\\n\t\tENABLE_FAKER(); \\\n\t\treturn retval; \\\n\t}\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n// GLX 1.0 functions\n\nFUNCDEF3(XVisualInfo*, glXChooseVisual, Display *, dpy, int, screen,\n\tint *, attrib_list, glXChooseVisual);\n\nVFUNCDEF4(glXCopyContext, Display *, dpy, GLXContext, src, GLXContext, dst,\n\tunsigned long, mask, glXCopyContext);\n\nFUNCDEF4(GLXContext, glXCreateContext, Display *, dpy, XVisualInfo *, vis,\n\tGLXContext, share_list, Bool, direct, glXCreateContext);\n\nFUNCDEF3(GLXPixmap, glXCreateGLXPixmap, Display *, dpy, XVisualInfo *, vis,\n\tPixmap, pixmap, glXCreateGLXPixmap);\n\nVFUNCDEF2(glXDestroyContext, Display *, dpy, GLXContext, ctx,\n\tglXDestroyContext);\n\nVFUNCDEF2(glXDestroyGLXPixmap, Display *, dpy, GLXPixmap, pix,\n\tglXDestroyGLXPixmap);\n\nFUNCDEF4(int, glXGetConfig, Display *, dpy, XVisualInfo *, vis, int, attrib,\n\tint *, value, glXGetConfig);\n\nFUNCDEF0(GLXDrawable, glXGetCurrentDrawable, glXGetCurrentDrawable);\n\nFUNCDEF2(Bool, glXIsDirect, Display *, dpy, GLXContext, ctx, glXIsDirect);\n\nFUNCDEF3(Bool, glXMakeCurrent, Display *, dpy, GLXDrawable, drawable,\n\tGLXContext, ctx, glXMakeCurrent);\n\nFUNCDEF3(Bool, glXQueryExtension, Display *, dpy, int *, error_base,\n\tint *, event_base, glXQueryExtension);\n\nFUNCDEF3(Bool, glXQueryVersion, Display *, dpy, int *, major, int *, minor,\n\tglXQueryVersion);\n\nVFUNCDEF2(glXSwapBuffers, Display *, dpy, GLXDrawable, drawable,\n\tglXSwapBuffers);\n\nVFUNCDEF4(glXUseXFont, Font, font, int, first, int, count, int, list_base,\n\tglXUseXFont);\n\nVFUNCDEF0(glXWaitGL, glXWaitGL);\n\n\n// GLX 1.1 functions\n\nFUNCDEF2(const char *, glXGetClientString, Display *, dpy, int, name,\n\tglXGetClientString);\n\nFUNCDEF3(const char *, glXQueryServerString, Display *, dpy, int, screen, int,\n\tname, glXQueryServerString);\n\nFUNCDEF2(const char *, glXQueryExtensionsString, Display *, dpy, int, screen,\n\tglXQueryExtensionsString);\n\n\n// GLX 1.2 functions\n\nFUNCDEF0(Display*, glXGetCurrentDisplay, glXGetCurrentDisplay);\n\n\n// GLX 1.3 functions\n\nFUNCDEF4(GLXFBConfig *, glXChooseFBConfig, Display *, dpy, int, screen,\n\tconst int *, attrib_list, int *, nelements, glXChooseFBConfig);\n\nFUNCDEF5(GLXContext, glXCreateNewContext, Display *, dpy, GLXFBConfig, config,\n\tint, render_type, GLXContext, share_list, Bool, direct, glXCreateNewContext);\n\nFUNCDEF3(GLXPbuffer, glXCreatePbuffer, Display *, dpy, GLXFBConfig, config,\n\tconst int *, attrib_list, glXCreatePbuffer);\n\nFUNCDEF4(GLXPixmap, glXCreatePixmap, Display *, dpy, GLXFBConfig, config,\n\tPixmap, pixmap, const int *, attrib_list, glXCreatePixmap);\n\nFUNCDEF4(GLXWindow, glXCreateWindow, Display *, dpy, GLXFBConfig, config,\n\tWindow, win, const int *, attrib_list, glXCreateWindow);\n\nVFUNCDEF2(glXDestroyPbuffer, Display *, dpy, GLXPbuffer, pbuf,\n\tglXDestroyPbuffer);\n\nVFUNCDEF2(glXDestroyPixmap, Display *, dpy, GLXPixmap, pixmap,\n\tglXDestroyPixmap);\n\nVFUNCDEF2(glXDestroyWindow, Display *, dpy, GLXWindow, win, glXDestroyWindow);\n\nFUNCDEF0(GLXDrawable, glXGetCurrentReadDrawable, glXGetCurrentReadDrawable);\n\nFUNCDEF4(int, glXGetFBConfigAttrib, Display *, dpy, GLXFBConfig, config,\n\tint, attribute, int *, value, glXGetFBConfigAttrib);\n\nFUNCDEF3(GLXFBConfig *, glXGetFBConfigs, Display *, dpy, int, screen,\n\tint *, nelements, glXGetFBConfigs);\n\nVFUNCDEF3(glXGetSelectedEvent, Display *, dpy, GLXDrawable, draw,\n\tunsigned long *, event_mask, glXGetSelectedEvent);\n\nFUNCDEF2(XVisualInfo *, glXGetVisualFromFBConfig, Display *, dpy,\n\tGLXFBConfig, config, glXGetVisualFromFBConfig);\n\nFUNCDEF4(Bool, glXMakeContextCurrent, Display *, display, GLXDrawable, draw,\n\tGLXDrawable, read, GLXContext, ctx, glXMakeContextCurrent);\n\nFUNCDEF4(int, glXQueryContext, Display *, dpy, GLXContext, ctx,\n\tint, attribute, int *, value, glXQueryContext);\n\nVFUNCDEF4(glXQueryDrawable, Display *, dpy, GLXDrawable, draw, int, attribute,\n\tunsigned int *, value, glXQueryDrawable);\n\nVFUNCDEF3(glXSelectEvent, Display *, dpy, GLXDrawable, draw,\n\tunsigned long, event_mask, glXSelectEvent);\n\n\n// GLX 1.4 functions\n\ntypedef void (*(*_glXGetProcAddressType)(const GLubyte*))(void);\nSYMDEF(glXGetProcAddress);\nstatic inline void (*_glXGetProcAddress(const GLubyte *procName))(void)\n{\n\tCHECKSYM(glXGetProcAddress, glXGetProcAddress);\n\treturn __glXGetProcAddress(procName);\n}\n\n\n// GLX_ARB_create_context\n\nFUNCDEF5(GLXContext, glXCreateContextAttribsARB, Display *, dpy, GLXFBConfig,\n\tconfig, GLXContext, share_context, Bool, direct, const int *, attribs,\n\tglXCreateContextAttribsARB);\n\n\n// GLX_ARB_get_proc_address\n\ntypedef void (*(*_glXGetProcAddressARBType)(const GLubyte*))(void);\nSYMDEF(glXGetProcAddressARB);\nstatic inline void (*_glXGetProcAddressARB(const GLubyte *procName))(void)\n{\n\tCHECKSYM(glXGetProcAddressARB, glXGetProcAddressARB);\n\treturn __glXGetProcAddressARB(procName);\n}\n\n\n// GLX_EXT_import_context\n\nVFUNCDEF2(glXFreeContextEXT, Display *, dpy, GLXContext, ctx,\n\tglXFreeContextEXT);\n\nFUNCDEF2(GLXContext, glXImportContextEXT, Display *, dpy,\n\tGLXContextID, contextID, glXImportContextEXT);\n\nFUNCDEF4(int, glXQueryContextInfoEXT, Display *, dpy, GLXContext, ctx,\n\tint, attribute, int *, value, glXQueryContextInfoEXT);\n\n\n// GLX_EXT_swap_control\n\nVFUNCDEF3(glXSwapIntervalEXT, Display *, dpy, GLXDrawable, drawable, int,\n\tinterval, glXSwapIntervalEXT);\n\n\n// GLX_EXT_texture_from_pixmap\n\nVFUNCDEF4(glXBindTexImageEXT, Display *, dpy, GLXDrawable, drawable,\n\tint, buffer, const int *, attrib_list, glXBindTexImageEXT);\n\nVFUNCDEF3(glXReleaseTexImageEXT, Display *, dpy, GLXDrawable, drawable,\n\tint, buffer, glXReleaseTexImageEXT)\n\n\n// GLX_NV_swap_group\n\nFUNCDEF3(Bool, glXJoinSwapGroupNV, Display *, dpy, GLXDrawable, drawable,\n\tGLuint, group, glXJoinSwapGroupNV);\n\nFUNCDEF3(Bool, glXBindSwapBarrierNV, Display *, dpy, GLuint, group,\n\tGLuint, barrier, glXBindSwapBarrierNV);\n\nFUNCDEF4(Bool, glXQuerySwapGroupNV, Display *, dpy, GLXDrawable, drawable,\n\tGLuint *, group, GLuint *, barrier, glXQuerySwapGroupNV);\n\nFUNCDEF4(Bool, glXQueryMaxSwapGroupsNV, Display *, dpy, int, screen,\n\tGLuint *, maxGroups, GLuint *, maxBarriers, glXQueryMaxSwapGroupsNV);\n\nFUNCDEF3(Bool, glXQueryFrameCountNV, Display *, dpy, int, screen,\n\tGLuint *, count, glXQueryFrameCountNV);\n\nFUNCDEF2(Bool, glXResetFrameCountNV, Display *, dpy, int, screen,\n\tglXResetFrameCountNV);\n\n\n// GLX_SGI_swap_control\n\nFUNCDEF1(int, glXSwapIntervalSGI, int, interval, glXSwapIntervalSGI);\n\n\n// GLX_SGIX_fbconfig\n\nFUNCDEF2(GLXFBConfigSGIX, glXGetFBConfigFromVisualSGIX, Display *, dpy,\n\tXVisualInfo *, vis, glXGetFBConfigFromVisualSGIX);\n\n\n// GLX_SUN_get_transparent_index\n\nFUNCDEF4(int, glXGetTransparentIndexSUN, Display *, dpy, Window, overlay,\n\tWindow, underlay, long *, transparentIndex, glXGetTransparentIndexSUN);\n\n\n// GL functions\n\nVFUNCDEF0(glFinish, glFinish);\n\nVFUNCDEF0(glFlush, glFlush);\n\nVFUNCDEF4(glViewport, GLint, x, GLint, y, GLsizei, width, GLsizei, height,\n\tglViewport);\n\nVFUNCDEF1(glDrawBuffer, GLenum, drawbuf, glDrawBuffer);\n\nVFUNCDEF0(glPopAttrib, glPopAttrib);\n\n\n// X11 functions\n\nFUNCDEF3(Bool, XCheckMaskEvent, Display *, dpy, long, event_mask,\n\tXEvent *, xe, XCheckMaskEvent);\n\nFUNCDEF3(Bool, XCheckTypedEvent, Display *, dpy, int, event_type,\n\tXEvent *, xe, XCheckTypedEvent);\n\nFUNCDEF4(Bool, XCheckTypedWindowEvent, Display *, dpy, Window, win,\n\tint, event_type, XEvent *, xe, XCheckTypedWindowEvent);\n\nFUNCDEF4(Bool, XCheckWindowEvent, Display *, dpy, Window, win, long,\n\tevent_mask, XEvent *, xe, XCheckWindowEvent);\n\nFUNCDEF1(int, XCloseDisplay, Display *, dpy, XCloseDisplay);\n\nFUNCDEF4(int, XConfigureWindow, Display *, dpy, Window, win,\n\tunsigned int, value_mask, XWindowChanges *, values, XConfigureWindow);\n\nFUNCDEF10(int, XCopyArea, Display *, dpy, Drawable, src, Drawable, dst, GC, gc,\n\tint, src_x, int, src_y, unsigned int, w, unsigned int, h, int, dest_x,\n\tint, dest_y, XCopyArea);\n\nFUNCDEF9(Window, XCreateSimpleWindow, Display *, dpy, Window, parent, int, x,\n\tint, y, unsigned int, width, unsigned int, height, unsigned int,\n\tborder_width, unsigned long, border, unsigned long, background,\n\tXCreateSimpleWindow);\n\nFUNCDEF12(Window, XCreateWindow, Display *, dpy, Window, parent, int, x, int,\n\ty, unsigned int, width, unsigned int, height, unsigned int, border_width,\n\tint, depth, unsigned int, c_class, Visual *, visual, unsigned long,\n\tvalue_mask, XSetWindowAttributes *, attributes, XCreateWindow);\n\nFUNCDEF2(int, XDestroySubwindows, Display *, dpy, Window, win,\n\tXDestroySubwindows);\n\nFUNCDEF2(int, XDestroyWindow, Display *, dpy, Window, win, XDestroyWindow);\n\nFUNCDEF1(int, XFree, void *, data, XFree);\n\nFUNCDEF9(Status, XGetGeometry, Display *, display, Drawable, d, Window *,\n\troot, int *, x, int *, y, unsigned int *, width, unsigned int *, height,\n\tunsigned int *, border_width, unsigned int *, depth, XGetGeometry);\n\nFUNCDEF8(XImage *, XGetImage, Display *, display, Drawable, d, int, x, int, y,\n\tunsigned int, width, unsigned int, height, unsigned long, plane_mask, int,\n\tformat, XGetImage);\n\nFUNCDEF2(char **, XListExtensions, Display *, dpy, int *, next,\n\tXListExtensions);\n\nFUNCDEF3(int, XMaskEvent, Display *, dpy, long, event_mask, XEvent *, xe,\n\tXMaskEvent);\n\nFUNCDEF6(int, XMoveResizeWindow, Display *, dpy, Window, win, int, x, int, y,\n\tunsigned int, width, unsigned int, height, XMoveResizeWindow);\n\nFUNCDEF2(int, XNextEvent, Display *, dpy, XEvent *, xe, XNextEvent);\n\nFUNCDEF1(Display *, XOpenDisplay, _Xconst char*, name, XOpenDisplay);\n\nFUNCDEF5(Bool, XQueryExtension, Display *, dpy, _Xconst char*, name, int *,\n\tmajor_opcode, int *, first_event, int *, first_error, XQueryExtension);\n\nFUNCDEF4(int, XResizeWindow, Display *, dpy, Window, win, unsigned int, width,\n\tunsigned int, height, XResizeWindow);\n\nFUNCDEF1(char *, XServerVendor, Display *, dpy, XServerVendor);\n\nFUNCDEF4(int, XWindowEvent, Display *, dpy, Window, win, long, event_mask,\n\tXEvent *, xe, XWindowEvent);\n\n\n// From dlfaker\n\ntypedef\tvoid* (*_dlopenType)(const char *, int);\nvoid *_vgl_dlopen(const char *, int);\nSYMDEF(dlopen);\n\n\n#ifdef FAKEXCB\n\n// XCB functions\n\nFUNCDEF2(const xcb_query_extension_reply_t *, xcb_get_extension_data,\n\txcb_connection_t *, conn, xcb_extension_t *, ext, xcb_get_extension_data);\n\nFUNCDEF3(xcb_glx_query_version_cookie_t, xcb_glx_query_version,\n\txcb_connection_t *, conn, uint32_t, major_version, uint32_t, minor_version,\n\txcb_glx_query_version);\n\nFUNCDEF3(xcb_glx_query_version_reply_t *, xcb_glx_query_version_reply,\n\txcb_connection_t *, conn, xcb_glx_query_version_cookie_t, cookie,\n\txcb_generic_error_t **, error, xcb_glx_query_version_reply);\n\nFUNCDEF1(xcb_generic_event_t *, xcb_poll_for_event, xcb_connection_t *, conn,\n\txcb_poll_for_event);\n\nFUNCDEF1(xcb_generic_event_t *, xcb_poll_for_queued_event, xcb_connection_t *,\n\tconn, xcb_poll_for_queued_event);\n\nFUNCDEF1(xcb_generic_event_t *, xcb_wait_for_event, xcb_connection_t *, conn,\n\txcb_wait_for_event);\n\n#endif\n\n\n// Functions used by the faker (but not interposed.)  We load the GLX/OpenGL\n// functions dynamically to prevent the 3D application from overriding them, as\n// well as to ensure that, with 'vglrun -nodl', libGL is not loaded into the\n// process until the 3D application actually uses it.\n\nVFUNCDEF2(glBindBuffer, GLenum, target, GLuint, buffer, NULL);\n\nVFUNCDEF7(glBitmap, GLsizei, width, GLsizei, height, GLfloat, xorig,\n\tGLfloat, yorig, GLfloat, xmove, GLfloat, ymove, const GLubyte *, bitmap,\n\tNULL);\n\nVFUNCDEF4(glBufferData, GLenum, target, GLsizeiptr, size, const GLvoid *, data,\n\tGLenum, usage, NULL);\n\nVFUNCDEF1(glClear, GLbitfield, mask, NULL);\n\nVFUNCDEF4(glClearColor, GLclampf, red, GLclampf, green, GLclampf, blue,\n\tGLclampf, alpha, NULL);\n\nVFUNCDEF5(glCopyPixels, GLint, x, GLint, y, GLsizei, width, GLsizei, height,\n\tGLenum, type, NULL);\n\nVFUNCDEF0(glEndList, NULL);\n\nVFUNCDEF2(glGenBuffers, GLsizei, n, GLuint *, buffers, NULL);\n\nVFUNCDEF3(glGetBufferParameteriv, GLenum, target, GLenum, value, GLint *,\n\tdata, NULL);\n\nFUNCDEF0(GLenum, glGetError, NULL);\n\nVFUNCDEF2(glGetFloatv, GLenum, pname, GLfloat *, params, NULL);\n\nVFUNCDEF2(glGetIntegerv, GLenum, pname, GLint *, params, NULL);\n\nFUNCDEF1(const GLubyte *, glGetString, GLenum, name, NULL);\n\nVFUNCDEF0(glLoadIdentity, NULL);\n\nFUNCDEF2(void *, glMapBuffer, GLenum, target, GLenum, access, NULL);\n\nVFUNCDEF1(glMatrixMode, GLenum, mode, NULL);\n\nVFUNCDEF2(glNewList, GLuint, list, GLenum, mode, NULL);\n\nVFUNCDEF6(glOrtho, GLdouble, left, GLdouble, right, GLdouble, bottom,\n\tGLdouble, top, GLdouble, near_val, GLdouble, far_val, NULL);\n\nVFUNCDEF2(glPixelStorei, GLenum, pname, GLint, param, NULL);\n\nVFUNCDEF0(glPopMatrix, NULL);\n\nVFUNCDEF0(glPushMatrix, NULL);\n\nVFUNCDEF2(glRasterPos2i, GLint, x, GLint, y, NULL);\n\nVFUNCDEF1(glReadBuffer, GLenum, mode, NULL);\n\nVFUNCDEF7(glReadPixels, GLint, x, GLint, y, GLsizei, width, GLsizei, height,\n\tGLenum, format, GLenum, type, GLvoid*, pixels, NULL);\n\nFUNCDEF1(GLboolean, glUnmapBuffer, GLenum, target, NULL);\n\nFUNCDEF0(GLXContext, glXGetCurrentContext, NULL);\n\n// We load all XCB functions dynamically, so that the same VirtualGL binary\n// can be used to support systems with and without XCB libraries.\n\n#ifdef FAKEXCB\n\nFUNCDEF1(xcb_connection_t *, XGetXCBConnection, Display *, dpy, NULL);\n\nVFUNCDEF2(XSetEventQueueOwner, Display *, dpy, enum XEventQueueOwner, owner,\n\tXSetEventQueueOwner);\n\ntypedef xcb_extension_t* _xcb_glx_idType;\nSYMDEF(xcb_glx_id);\nstatic inline xcb_extension_t *_xcb_glx_id(void)\n{\n\tCHECKSYM(xcb_glx_id, NULL);\n\treturn __xcb_glx_id;\n}\n\nFUNCDEF4(xcb_intern_atom_cookie_t, xcb_intern_atom, xcb_connection_t *, conn,\n\tuint8_t, only_if_exists, uint16_t, name_len, const char *, name, NULL);\n\nFUNCDEF3(xcb_intern_atom_reply_t *, xcb_intern_atom_reply, xcb_connection_t *,\n\tconn, xcb_intern_atom_cookie_t, cookie, xcb_generic_error_t **, e, NULL);\n\nFUNCDEF1(xcb_key_symbols_t *, xcb_key_symbols_alloc, xcb_connection_t *, c,\n\tNULL);\n\nVFUNCDEF1(xcb_key_symbols_free, xcb_key_symbols_t *, syms, NULL);\n\nFUNCDEF3(xcb_keysym_t, xcb_key_symbols_get_keysym, xcb_key_symbols_t *, syms,\n\txcb_keycode_t, keycode, int, col, NULL);\n\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/server/faker.cpp": "/* Copyright (C)2004 Landmark Graphics Corporation\n * Copyright (C)2005, 2006 Sun Microsystems, Inc.\n * Copyright (C)2009, 2011, 2013-2016 D. R. Commander\n *\n * This library is free software and may be redistributed and/or modified under\n * the terms of the wxWindows Library License, Version 3.1 or (at your option)\n * any later version.  The full license is in the LICENSE.txt file included\n * with this distribution.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * wxWindows Library License for more details.\n */\n\n#include <unistd.h>\n#include \"Mutex.h\"\n#include \"ConfigHash.h\"\n#include \"ContextHash.h\"\n#include \"DisplayHash.h\"\n#include \"GLXDrawableHash.h\"\n#include \"GlobalCriticalSection.h\"\n#include \"PixmapHash.h\"\n#include \"ReverseConfigHash.h\"\n#include \"VisualHash.h\"\n#include \"WindowHash.h\"\n#include \"fakerconfig.h\"\n#include \"threadlocal.h\"\n#include <dlfcn.h>\n\n\nusing namespace vglutil;\nusing namespace vglserver;\n\n\nnamespace vglfaker\n{\n\nDisplay *dpy3D=NULL;\nbool deadYet=false;\nVGL_THREAD_LOCAL(TraceLevel, long, 0)\nVGL_THREAD_LOCAL(FakerLevel, long, 0)\nVGL_THREAD_LOCAL(ExcludeCurrent, bool, false)\n\n\nstatic void cleanup(void)\n{\n\tif(PixmapHash::isAlloc()) pmhash.kill();\n\tif(VisualHash::isAlloc()) vishash.kill();\n\tif(ConfigHash::isAlloc()) cfghash.kill();\n\tif(ReverseConfigHash::isAlloc()) rcfghash.kill();\n\tif(ContextHash::isAlloc()) ctxhash.kill();\n\tif(GLXDrawableHash::isAlloc()) glxdhash.kill();\n\tif(WindowHash::isAlloc()) winhash.kill();\n\tif(DisplayHash::isAlloc()) dpyhash.kill();\n\tunloadSymbols();\n}\n\n\nvoid safeExit(int retcode)\n{\n\tbool shutdown;\n\n\tglobalMutex.lock(false);\n\tshutdown=deadYet;\n\tif(!deadYet)\n\t{\n\t\tdeadYet=true;\n\t\tcleanup();\n\t\tfconfig_deleteinstance();\n\t}\n\tglobalMutex.unlock(false);\n\tif(!shutdown) exit(retcode);\n\telse pthread_exit(0);\n}\n\n\nclass GlobalCleanup\n{\n\tpublic:\n\n\t\t~GlobalCleanup()\n\t\t{\n\t\t\tvglfaker::GlobalCriticalSection *gcs=\n\t\t\t\tvglfaker::GlobalCriticalSection::getInstance(false);\n\t\t\tif(gcs) gcs->lock(false);\n\t\t\tfconfig_deleteinstance();\n\t\t\tdeadYet=true;\n\t\t\tif(gcs) gcs->unlock(false);\n\t\t}\n};\nGlobalCleanup globalCleanup;\n\n\n// Used when VGL_TRAPX11=1\n\nint xhandler(Display *dpy, XErrorEvent *xe)\n{\n\tchar temps[256];\n\n\ttemps[0]=0;\n\tXGetErrorText(dpy, xe->error_code, temps, 255);\n\tvglout.PRINT(\"[VGL] WARNING: X11 error trapped\\n[VGL]    Error:  %s\\n[VGL]    XID:    0x%.8x\\n\",\n\t\ttemps, xe->resourceid);\n\treturn 0;\n}\n\n\n// Called from XOpenDisplay(), unless a GLX function is called first\n\nvoid init(void)\n{\n\tstatic int init=0;\n\n\tif(init) return;\n\tGlobalCriticalSection::SafeLock l(globalMutex);\n\tif(init) return;\n\tinit=1;\n\n\tfconfig_reloadenv();\n\tif(strlen(fconfig.log)>0) vglout.logTo(fconfig.log);\n\n\tif(fconfig.verbose)\n\t\tvglout.println(\"[VGL] %s v%s %d-bit (Build %s)\",\n\t\t\t__APPNAME, __VERSION, (int)sizeof(size_t)*8, __BUILD);\n\n\tif(getenv(\"VGL_DEBUG\"))\n\t{\n\t\tvglout.print(\"[VGL] Attach debugger to process %d ...\\n\", getpid());\n\t\tfgetc(stdin);\n\t}\n\tif(fconfig.trapx11) XSetErrorHandler(xhandler);\n}\n\n\nDisplay *init3D(void)\n{\n\tinit();\n\n\tif(!dpy3D)\n\t{\n\t\tGlobalCriticalSection::SafeLock l(globalMutex);\n\t\tif(!dpy3D)\n\t\t{\n\t\t\tif(fconfig.verbose)\n\t\t\t\tvglout.println(\"[VGL] Opening connection to 3D X server %s\",\n\t\t\t\t\tstrlen(fconfig.localdpystring)>0? fconfig.localdpystring:\"(default)\");\n\t\t\tif((dpy3D=_XOpenDisplay(fconfig.localdpystring))==NULL)\n\t\t\t{\n\t\t\t\tvglout.print(\"[VGL] ERROR: Could not open display %s.\\n\",\n\t\t\t\t\tfconfig.localdpystring);\n\t\t\t\tsafeExit(1);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dpy3D;\n}\n\n\nbool excludeDisplay(char *name)\n{\n\tfconfig_reloadenv();\n\n\tchar *dpyList=strdup(fconfig.excludeddpys);\n\tchar *excluded=strtok(dpyList, \" \\t,\");\n\twhile(excluded)\n\t{\n\t\tif(!strcasecmp(name, excluded))\n\t\t{\n\t\t\tfree(dpyList);  return true;\n\t\t}\n\t\texcluded=strtok(NULL, \" \\t,\");\n\t}\n\tfree(dpyList);\n\treturn false;\n}\n\n}  // namespace\n\n\nextern \"C\" {\n\n// This is the \"real\" version of dlopen(), which is called by the interposed\n// version of dlopen() in libdlfaker.  Can't recall why this is here and not\n// in dlfaker, but it seems like there was a good reason.\n\nvoid *_vgl_dlopen(const char *file, int mode)\n{\n\tif(!__dlopen)\n\t{\n\t\tvglfaker::GlobalCriticalSection::SafeLock l(globalMutex);\n\t\tif(!__dlopen)\n\t\t{\n\t\t\tdlerror();  // Clear error state\n\t\t\t__dlopen=(_dlopenType)dlsym(RTLD_NEXT, \"dlopen\");\n\t\t\tchar *err=dlerror();\n\t\t\tif(!__dlopen)\n\t\t\t{\n\t\t\t\tvglout.print(\"[VGL] ERROR: Could not load function \\\"dlopen\\\"\\n\");\n\t\t\t\tif(err) vglout.print(\"[VGL]    %s\\n\", err);\n\t\t\t\tvglfaker::safeExit(1);\n\t\t\t}\n\t\t}\n\t}\n\treturn __dlopen(file, mode);\n}\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/server/dlfakerut.c": "/* Copyright (C)2006 Sun Microsystems, Inc.\n * Copyright (C)2009, 2014-2015, 2017 D. R. Commander\n *\n * This library is free software and may be redistributed and/or modified under\n * the terms of the wxWindows Library License, Version 3.1 or (at your option)\n * any later version.  The full license is in the LICENSE.txt file included\n * with this distribution.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * wxWindows Library License for more details.\n */\n\n#include <GL/glx.h>\n#include <X11/Xlib.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n\n#define _throw(m) { fprintf(stderr, \"ERROR: %s\\n\", m);  goto bailout; }\n\n\ntypedef XVisualInfo* (*_glXChooseVisualType)(Display *, int, int *);\n_glXChooseVisualType _glXChooseVisual=NULL;\n\ntypedef GLXContext (*_glXCreateContextType)(Display *, XVisualInfo *,\n\tGLXContext, Bool);\n_glXCreateContextType _glXCreateContext=NULL;\n\ntypedef GLXContext (*_glXDestroyContextType)(Display *, GLXContext);\n_glXDestroyContextType _glXDestroyContext=NULL;\n\ntypedef void (*(*_glXGetProcAddressARBType)(const GLubyte*))(void);\n_glXGetProcAddressARBType _glXGetProcAddressARB=NULL;\n\ntypedef Bool (*_glXMakeCurrentType)(Display *, GLXDrawable, GLXContext);\n_glXMakeCurrentType _glXMakeCurrent=NULL;\n\ntypedef void (*_glXSwapBuffersType)(Display *, GLXDrawable);\n_glXSwapBuffersType _glXSwapBuffers=NULL;\n\ntypedef void (*_glClearType)(GLbitfield);\n_glClearType _glClear=NULL;\n\ntypedef void (*_glClearColorType)(GLclampf, GLclampf, GLclampf, GLclampf);\n_glClearColorType _glClearColor=NULL;\n\nvoid *gldllhnd=NULL;\n\n#define LSYM(s)  \\\n\tdlerror();  \\\n\t_##s=(_##s##Type)dlsym(gldllhnd, #s);  \\\n\terr=dlerror();  \\\n\tif(err) _throw(err)  \\\n\telse if(!_##s) _throw(\"Could not load symbol \"#s)\n\nvoid loadSymbols1(char *prefix)\n{\n\tconst char *err=NULL;\n\tif(prefix)\n\t{\n\t\tchar temps[256];\n\t\tsnprintf(temps, 255, \"%s/libGL.so\", prefix);\n\t\tgldllhnd=dlopen(temps, RTLD_NOW);\n\t}\n\telse gldllhnd=dlopen(\"libGL.so\", RTLD_NOW);\n\terr=dlerror();\n\tif(err) _throw(err)\n\telse if(!gldllhnd) _throw(\"Could not open libGL\")\n\n\tLSYM(glXChooseVisual);\n\tLSYM(glXCreateContext);\n\tLSYM(glXDestroyContext);\n\tLSYM(glXMakeCurrent);\n\tLSYM(glXSwapBuffers);\n\tLSYM(glClear);\n\tLSYM(glClearColor);\n\treturn;\n\n\tbailout:\n\texit(1);\n}\n\nvoid unloadSymbols1(void)\n{\n\tif(gldllhnd) dlclose(gldllhnd);\n}\n\n\n#define LSYM2(s)  \\\n\t_##s=(_##s##Type)_glXGetProcAddressARB((const GLubyte *)#s);  \\\n\tif(!_##s) _throw(\"Could not load symbol \"#s)\n\nvoid loadSymbols2(void)\n{\n\tconst char *err=NULL;\n\n\tLSYM(glXGetProcAddressARB);\n\tLSYM2(glXChooseVisual);\n\tLSYM2(glXCreateContext);\n\tLSYM2(glXDestroyContext);\n\tLSYM2(glXMakeCurrent);\n\tLSYM2(glXSwapBuffers);\n\tLSYM2(glClear);\n\tLSYM2(glClearColor);\n\treturn;\n\n\tbailout:\n\texit(1);\n}\n\n\n/* Test whether libvglfaker's version of dlopen() is discriminating enough.\n   This will fail on VGL 2.1.2 and prior */\n\ntypedef void (*_myTestFunctionType)(void);\n_myTestFunctionType _myTestFunction=NULL;\n\nvoid nameMatchTest(void)\n{\n\tconst char *err=NULL;\n\n\tfprintf(stderr, \"dlopen() name matching test:\\n\");\n\tgldllhnd=dlopen(\"libGLdlfakerut.so\", RTLD_NOW);\n\terr=dlerror();\n\tif(err) _throw(err)\n\telse if(!gldllhnd) _throw(\"Could not open libGLdlfakerut\")\n\n\tLSYM(myTestFunction);\n\t_myTestFunction();\n\tdlclose(gldllhnd);\n\tgldllhnd=NULL;\n\treturn;\n\n\tbailout:\n\texit(1);\n}\n\n\n#include \"dlfakerut-test.c\"\n\n\n#ifdef RTLD_DEEPBIND\n/* Test whether libdlfaker.so properly circumvents RTLD_DEEPBIND */\n\ntypedef void (*_testType)(const char *);\n_testType _test=NULL;\n\nvoid deepBindTest(void)\n{\n\tconst char *err=NULL;\n\n\tgldllhnd=dlopen(\"libdeepbindtest.so\", RTLD_NOW|RTLD_DEEPBIND);\n\terr=dlerror();\n\tif(err) _throw(err)\n\telse if(!gldllhnd) _throw(\"Could not open libdlfakerut\")\n\n\tLSYM(test);\n\t_test(\"RTLD_DEEPBIND test\");\n\tdlclose(gldllhnd);\n\tgldllhnd=NULL;\n\treturn;\n\n\tbailout:\n\texit(1);\n}\n#endif\n\n\nint main(int argc, char **argv)\n{\n\tchar *env, *prefix=NULL;\n\n\tif(argc>2 && !strcasecmp(argv[1], \"--prefix\"))\n\t{\n\t\tprefix=argv[2];\n\t\tfprintf(stderr, \"prefix = %s\\n\", prefix);\n\t}\n\n\tif(putenv((char *)\"VGL_AUTOTEST=1\")==-1\n\t\t|| putenv((char *)\"VGL_SPOIL=0\")==-1)\n\t\t_throw(\"putenv() failed!\\n\");\n\n\tenv=getenv(\"LD_PRELOAD\");\n\tfprintf(stderr, \"LD_PRELOAD = %s\\n\", env? env:\"(NULL)\");\n\t#ifdef sun\n\tenv=getenv(\"LD_PRELOAD_32\");\n\tfprintf(stderr, \"LD_PRELOAD_32 = %s\\n\", env? env:\"(NULL)\");\n\tenv=getenv(\"LD_PRELOAD_64\");\n\tfprintf(stderr, \"LD_PRELOAD_64 = %s\\n\", env? env:\"(NULL)\");\n\t#endif\n\n\tfprintf(stderr, \"\\n\");\n\tnameMatchTest();\n\n\tloadSymbols1(prefix);\n\ttest(\"dlopen() test\");\n\n\tloadSymbols2();\n\ttest(\"glXGetProcAddressARB() test\");\n\n\tunloadSymbols1();\n\n\t#ifdef RTLD_DEEPBIND\n\tdeepBindTest();\n\t#endif\n\n\tbailout:\n\treturn 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/server/servertest.in": "#!/bin/bash\nset -e\nset -u\ntrap onexit INT\ntrap onexit TERM\ntrap onexit EXIT\n\nSUCCESS=0\nVGLCLIENTPID=-1\nPID=-1\n\nonexit()\n{\n\tif [ $SUCCESS -eq 1 ]; then\n\t\techo GREAT SUCCESS!\n\telse\n\t\techo Some errors were encountered.\n\tfi\n\tif [ $PID -ne -1 ]; then\n\t\tkill -0 $PID >/dev/null 2>&1 && kill $PID\n\tfi\n\tif [ $VGLCLIENTPID -ne -1 ]; then\n\t\tkill -0 $VGLCLIENTPID >/dev/null 2>&1 && kill $VGLCLIENTPID\n\tfi\n}\n\nBIN=@CMAKE_RUNTIME_OUTPUT_DIRECTORY@\nLIB=@CMAKE_LIBRARY_OUTPUT_DIRECTORY@\nSSL=@VGL_USESSL@\n\nNODL=\nNOSTEREO=\nwhile [ $# -gt 0 ]; do\n\tcase \"$1\" in\n\t-nodl)\n\t\techo \"Testing without dlopen() interposer\"\n\t\tNODL=-nodl\n\t\t;;\n\t-nostereo)\n\t\tNOSTEREO=-nostereo\n\t\t;;\n\tesac\n\tshift\ndone\n\nwhich Xvfb >/dev/null 2>&1 || (\n\techo Xvfb not found!\n\texit 1\n)\nXvfb :42 -screen 0 1920x1200x24 >/dev/null 2>&1 & PID=$!\necho Xvfb started as process $PID\nsleep 2\n\n# VGL Transport\nDISPLAY=:42 $BIN/vglclient >vglclient.log 2>&1 & VGLCLIENTPID=$!\nDISPLAY=:42 LD_LIBRARY_PATH=$LIB $BIN/vglrun $NODL -c jpeg $BIN/fakerut $NOSTEREO\nif [ \"$SSL\" = \"1\" ]; then\n\tDISPLAY=:42 LD_LIBRARY_PATH=$LIB $BIN/vglrun $NODL -c jpeg +s $BIN/fakerut $NOSTEREO\nfi\nDISPLAY=:42 LD_LIBRARY_PATH=$LIB VGL_READBACK=sync $BIN/vglrun $NODL -np 2 -c rgb $BIN/fakerut $NOSTEREO\n# (we can't test stereo here, because the transport plugin assumes\n# quad-buffered, which isn't available with an X proxy.)\nDISPLAY=:42 LD_LIBRARY_PATH=$LIB $BIN/vglrun $NODL -trans test $BIN/fakerut -nostereo\nkill $VGLCLIENTPID\nVGLCLIENTPID=-1\n\n# X11 Transport\nDISPLAY=:42 LD_LIBRARY_PATH=$LIB $BIN/vglrun $NODL -c proxy $BIN/fakerut $NOSTEREO\nDISPLAY=:42 LD_LIBRARY_PATH=$LIB $BIN/vglrun $NODL -trans test2 $BIN/fakerut $NOSTEREO\n\nkill $PID\nPID=-1\n\nSUCCESS=1\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/server/dlfaker.c": "/* Copyright (C)2006 Sun Microsystems, Inc.\n * Copyright (C)2009, 2012, 2015, 2017 D. R. Commander\n *\n * This library is free software and may be redistributed and/or modified under\n * the terms of the wxWindows Library License, Version 3.1 or (at your option)\n * any later version.  The full license is in the LICENSE.txt file included\n * with this distribution.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * wxWindows Library License for more details.\n */\n\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include \"vendor.h\"\n\n\nextern void *_vgl_dlopen(const char *, int);\n\n\n/* If an application uses dlopen()/dlsym() to load functions from libGL or\n   libX11, this bypasses the LD_PRELOAD mechanism.  Thus, VirtualGL has to\n   intercept dlopen() and return a handle to itself rather than a handle to\n   libGL or libX11.\n\n   NOTE: If the application tries to use dlopen() to obtain a handle to libdl,\n   we similarly replace the handle with a handle to libdlfaker.  This works\n   around an interaction issue between 180.xx of the nVidia drivers and WINE.\n*/\n\nvoid *dlopen(const char *filename, int flag)\n{\n\tchar *env=NULL, *env2=NULL;  const char *envname=\"FAKERLIB32\";\n\tint verbose=0, trace=0;\n\tvoid *retval=NULL;\n\n\tif(sizeof(long)==8) envname=\"FAKERLIB\";\n\tif((env2=getenv(\"VGL_VERBOSE\"))!=NULL && strlen(env2)>0\n\t\t&& !strncmp(env2, \"1\", 1)) verbose=1;\n\tif((env2=getenv(\"VGL_TRACE\"))!=NULL && strlen(env2)>0\n\t\t&& !strncmp(env2, \"1\", 1)) trace=1;\n\n\tif(trace)\n\t{\n\t\tfprintf(stderr, \"[VGL] dlopen (filename=%s flag=%d\",\n\t\t\tfilename? filename:\"NULL\", flag);\n\t}\n\n\t#ifdef RTLD_DEEPBIND\n\tflag&=(~RTLD_DEEPBIND);\n\t#endif\n\n\tif((env=getenv(envname))==NULL || strlen(env)<1)\n\t\tenv=\"lib\"VGL_FAKER_NAME\".so\";\n\tif(filename &&\n\t\t(!strncmp(filename, \"libGL.\", 6) || strstr(filename, \"/libGL.\")\n\t\t\t|| !strncmp(filename, \"libX11.\", 7) || strstr(filename, \"/libX11.\")\n\t\t\t|| (flag&RTLD_LAZY\n\t\t\t\t\t&& (!strncmp(filename, \"libopengl.\", 10)\n\t\t\t\t\t\t\t|| strstr(filename, \"/libopengl.\")))))\n\t{\n\t\tif(verbose)\n\t\t\tfprintf(stderr,\n\t\t\t\t\"[VGL] NOTICE: Replacing dlopen(\\\"%s\\\") with dlopen(\\\"%s\\\")\\n\",\n\t\t\t\tfilename? filename:\"NULL\", env? env:\"NULL\");\n\t\tretval=_vgl_dlopen(env, flag);\n\t}\n\telse if(filename && (!strncmp(filename, \"libdl.\", 6)\n\t\t|| strstr(filename, \"/libdl.\")))\n\t{\n\t\tif(verbose)\n\t\t\tfprintf(stderr, \"[VGL] NOTICE: Replacing dlopen(\\\"%s\\\") with dlopen(\\\"lib\"VGL_DLFAKER_NAME\".so\\\")\\n\",\n\t\t\t\tfilename? filename:\"NULL\");\n\t\tretval=_vgl_dlopen(\"lib\"VGL_DLFAKER_NAME\".so\", flag);\n\t}\n\telse retval=_vgl_dlopen(filename, flag);\n\n\tif(!retval && filename && !strncmp(filename, \"VBoxOGL\", 7))\n\t{\n\t\tchar temps[256];\n\t\tsnprintf(temps, 255, \"/usr/lib/virtualbox/%s\", filename);\n\t\tif(verbose)\n\t\t{\n\t\t\tfprintf(stderr, \"[VGL] NOTICE: dlopen(\\\"%s\\\") failed.\\n\", filename);\n\t\t\tfprintf(stderr, \"[VGL]    Trying dlopen(\\\"%s\\\")\\n\", temps);\n\t\t}\n\t\tretval=_vgl_dlopen(temps, flag);\n\t}\n\n\tif(trace)\n\t{\n\t\tfprintf(stderr, \" retval=0x%.8lx)\\n\", (long)retval);\n\t}\n\n\treturn retval;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/server/faker-sym.cpp": "/* Copyright (C)2004 Landmark Graphics Corporation\n * Copyright (C)2005, 2006 Sun Microsystems, Inc.\n * Copyright (C)2009, 2011, 2013-2016 D. R. Commander\n *\n * This library is free software and may be redistributed and/or modified under\n * the terms of the wxWindows Library License, Version 3.1 or (at your option)\n * any later version.  The full license is in the LICENSE.txt file included\n * with this distribution.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * wxWindows Library License for more details.\n */\n\n#define __LOCALSYM__\n#include \"faker-sym.h\"\n#include <dlfcn.h>\n#include <string.h>\n#include \"fakerconfig.h\"\n\n\nstatic void *gldllhnd=NULL;\nstatic void *loadGLSymbol(const char *, bool);\nstatic void *x11dllhnd=NULL;\nstatic void *loadX11Symbol(const char *, bool);\n#ifdef FAKEXCB\nstatic void *xcbdllhnd=NULL;\nstatic void *loadXCBSymbol(const char *, bool);\nstatic void *xcbglxdllhnd=NULL;\nstatic void *loadXCBGLXSymbol(const char *, bool);\nstatic void *xcbkeysymsdllhnd=NULL;\nstatic void *loadXCBKeysymsSymbol(const char *, bool);\nstatic void *xcbx11dllhnd=NULL;\nstatic void *loadXCBX11Symbol(const char *, bool);\n#endif\n\n\n// Attempt to load the glXGetProcAddress[ARB]() function.  This also checks\n// whether dlsym() is returning our interposed version of\n// glXGetProcAddress[ARB]() instead of the \"real\" function from libGL.  If so,\n// then it's probably because another DSO in the process is interposing dlsym()\n// (I'm looking at you, Steam.)\n#define FIND_GLXGETPROCADDRESS(f) {  \\\n\t__glXGetProcAddress=(_##f##Type)dlsym(gldllhnd, #f);  \\\n\tif(__glXGetProcAddress==f) {  \\\n\t\tvglout.print(\"[VGL] ERROR: VirtualGL attempted to load the real \" #f \" function\\n\");  \\\n\t\tvglout.print(\"[VGL]   and got the fake one instead.  Something is terribly wrong.  Aborting\\n\");  \\\n\t\tvglout.print(\"[VGL]   before chaos ensues.\\n\");  \\\n\t\tvglfaker::safeExit(1);  \\\n\t}  \\\n}\n\n\nnamespace vglfaker\n{\n\nvoid *loadSymbol(const char *name, bool optional)\n{\n\tif(!name)\n\t{\n\t\tvglout.print(\"[VGL] ERROR: Invalid argument in loadSymbol()\\n\");\n\t\tsafeExit(1);\n\t}\n\tif(!strncmp(name, \"gl\", 2))\n\t\treturn loadGLSymbol(name, optional);\n\t#ifdef FAKEXCB\n\telse if(!strcmp(name, \"XGetXCBConnection\")\n\t\t|| !strcmp(name, \"XSetEventQueueOwner\"))\n\t\treturn loadXCBX11Symbol(name, optional);\n\t#endif\n\telse if(!strncmp(name, \"X\", 1))\n\t\treturn loadX11Symbol(name, optional);\n\t#ifdef FAKEXCB\n\telse if(!strncmp(name, \"xcb_glx\", 7))\n\t\treturn loadXCBGLXSymbol(name, optional);\n\telse if(!strncmp(name, \"xcb_key\", 7))\n\t\treturn loadXCBKeysymsSymbol(name, optional);\n\telse if(!strncmp(name, \"xcb_\", 4))\n\t\treturn loadXCBSymbol(name, optional);\n\t#endif\n\telse\n\t{\n\t\tvglout.print(\"[VGL] ERROR: don't know how to load symbol \\\"%s\\\"\\n\", name);\n\t\treturn NULL;\n\t}\n}\n\n} // namespace\n\n\nstatic void *loadGLSymbol(const char *name, bool optional)\n{\n\tchar *err=NULL;\n\n\tif(!__glXGetProcAddress)\n\t{\n\t\tif(strlen(fconfig.gllib)>0)\n\t\t{\n\t\t\tdlerror();  // Clear error state\n\t\t\tvoid *dllhnd=_vgl_dlopen(fconfig.gllib, RTLD_LAZY);\n\t\t\terr=dlerror();\n\t\t\tif(!dllhnd)\n\t\t\t{\n\t\t\t\tvglout.print(\"[VGL] ERROR: Could not open %s\\n\", fconfig.gllib);\n\t\t\t\tif(err) vglout.print(\"[VGL]    %s\\n\", err);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgldllhnd=dllhnd;\n\t\t}\n\t\telse gldllhnd=RTLD_NEXT;\n\n\t\tdlerror();  // Clear error state\n\t\tFIND_GLXGETPROCADDRESS(glXGetProcAddress)\n\t\tif(!__glXGetProcAddress)\n\t\t\tFIND_GLXGETPROCADDRESS(glXGetProcAddressARB)\n\t\terr=dlerror();\n\n\t\tif(!__glXGetProcAddress)\n\t\t{\n\t\t\tvglout.print(\"[VGL] ERROR: Could not load GLX/OpenGL functions\");\n\t\t\tif(strlen(fconfig.gllib)>0)\n\t\t\t\tvglout.print(\" from %s\", fconfig.gllib);\n\t\t\tvglout.print(\"\\n\");\n\t\t\tif(err) vglout.print(\"[VGL]    %s\\n\", err);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tvoid *sym=NULL;\n\tif(!strcmp(name, \"glXGetProcAddress\") ||\n\t\t!strcmp(name, \"glXGetProcAddressARB\"))\n\t\tsym=(void *)__glXGetProcAddress;\n\telse\n\t{\n\t\t// For whatever reason, on Solaris, if a function doesn't exist in libGL,\n\t\t// glXGetProcAddress() will return the address of VGL's interposed\n\t\t// version, which causes an infinite loop until the program blows its stack\n\t\t// and segfaults.  Thus, we use the old reliable dlsym() method by default.\n\t\t// On Linux and FreeBSD, we use glXGetProcAddress[ARB]() by default, to\n\t\t// work around issues with certain drivers, but because Steam's\n\t\t// gameoverlayrenderer.so interposer causes a similar problem to the\n\t\t// aforementioned issue on Solaris, we allow the GL symbol loading method\n\t\t// to be controlled at run time using an environment variable (VGL_DLSYM).\n\t\tif(fconfig.dlsymloader)\n\t\t{\n\t\t\tdlerror();  // Clear error state\n\t\t\tsym=dlsym(gldllhnd, (char *)name);\n\t\t\terr=dlerror();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsym=(void *)__glXGetProcAddress((const GLubyte *)name);\n\t\t}\n\t}\n\n\tif(!sym && (fconfig.verbose || !optional))\n \t{\n\t \tvglout.print(\"[VGL] %s: Could not load function \\\"%s\\\"\",\n\t\t \toptional? \"WARNING\":\"ERROR\", name);\n\t\tif(strlen(fconfig.gllib)>0)\n\t\t\tvglout.print(\" from %s\", fconfig.gllib);\n\t\tvglout.print(\"\\n\");\n\t}\n\treturn sym;\n}\n\n\nstatic void *loadX11Symbol(const char *name, bool optional)\n{\n\tchar *err=NULL;\n\n\tif(!x11dllhnd)\n\t{\n\t\tif(strlen(fconfig.x11lib)>0)\n\t\t{\n\t\t\tdlerror();  // Clear error state\n\t\t\tvoid *dllhnd=_vgl_dlopen(fconfig.x11lib, RTLD_LAZY);\n\t\t\terr=dlerror();\n\t\t\tif(!dllhnd)\n\t\t\t{\n\t\t\t\tvglout.print(\"[VGL] ERROR: Could not open %s\\n\", fconfig.x11lib);\n\t\t\t\tif(err) vglout.print(\"[VGL]    %s\\n\", err);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tx11dllhnd=dllhnd;\n\t\t}\n\t\telse x11dllhnd=RTLD_NEXT;\n\t}\n\n\tdlerror();  // Clear error state\n\tvoid *sym=dlsym(x11dllhnd, (char *)name);\n\terr=dlerror();\n\n\tif(!sym && (fconfig.verbose || !optional))\n\t{\n\t\tvglout.print(\"[VGL] %s: Could not load function \\\"%s\\\"\",\n\t\t\toptional? \"WARNING\":\"ERROR\", name);\n\t\tif(strlen(fconfig.x11lib)>0)\n\t\t\tvglout.print(\" from %s\", fconfig.x11lib);\n\t\tvglout.print(\"\\n\");\n\t\tif(err) vglout.print(\"[VGL]    %s\\n\", err);\n\t}\n\treturn sym;\n}\n\n\n#ifdef FAKEXCB\n\n#define LOAD_XCB_SYMBOL(ID, id, libid, minrev, maxrev)  \\\nstatic void *load##ID##Symbol(const char *name, bool optional)  \\\n{  \\\n\tchar *err=NULL;  \\\n  \\\n\tif(!id##dllhnd)  \\\n\t{  \\\n\t\tif(strlen(fconfig.id##lib)>0)  \\\n\t\t{  \\\n\t\t\tdlerror();  \\\n\t\t\tvoid *dllhnd=_vgl_dlopen(fconfig.id##lib, RTLD_LAZY);  \\\n\t\t\terr=dlerror();  \\\n\t\t\tif(!dllhnd)  \\\n\t\t\t{  \\\n\t\t\t\tif(fconfig.verbose || !optional)  \\\n\t\t\t\t{  \\\n\t\t\t\t\tvglout.print(\"[VGL] %s: Could not open %s\\n\",  \\\n\t\t\t\t\t\toptional? \"WARNING\":\"ERROR\", fconfig.id##lib);  \\\n\t\t\t\t\tif(err) vglout.print(\"[VGL]    %s\\n\", err);  \\\n\t\t\t\t}  \\\n\t\t\t\treturn NULL;  \\\n\t\t\t}  \\\n\t\t\tid##dllhnd=dllhnd;  \\\n\t\t}  \\\n\t\telse  \\\n\t\t{  \\\n\t\t\tvoid *dllhnd=NULL;  \\\n\t\t\tfor(int i=minrev; i<=maxrev; i++)  \\\n\t\t\t{  \\\n\t\t\t\tchar libName[MAXSTR];  \\\n\t\t\t\tsnprintf(libName, MAXSTR, \"lib%s.so.%d\", #libid, i);  \\\n\t\t\t\tdlerror();  \\\n\t\t\t\tdllhnd=_vgl_dlopen(libName, RTLD_LAZY);  \\\n\t\t\t\terr=dlerror();  \\\n\t\t\t\tif(dllhnd) break;  \\\n\t\t\t}  \\\n\t\t\tif(!dllhnd)  \\\n\t\t\t{  \\\n\t\t\t\tif(fconfig.verbose || !optional)  \\\n\t\t\t\t{  \\\n\t\t\t\t\tvglout.print(\"[VGL] %s: Could not open lib%s\\n\",  \\\n\t\t\t\t\t\toptional? \"WARNING\":\"ERROR\", #libid);  \\\n\t\t\t\t\tif(err) vglout.print(\"[VGL]    %s\\n\", err);  \\\n\t\t\t\t}  \\\n\t\t\t\treturn NULL;  \\\n\t\t\t}  \\\n\t\t\tid##dllhnd=dllhnd;  \\\n\t\t}  \\\n\t}  \\\n  \\\n\tdlerror();  \\\n\tvoid *sym=dlsym(id##dllhnd, (char *)name);  \\\n\terr=dlerror();  \\\n  \\\n\tif(!sym && (fconfig.verbose || !optional))  \\\n\t{  \\\n\t\tvglout.print(\"[VGL] %s: Could not load symbol \\\"%s\\\"\",  \\\n\t\t\toptional? \"WARNING\":\"ERROR\", name);  \\\n\t\tif(strlen(fconfig.id##lib)>0)  \\\n\t\t\tvglout.print(\" from %s\", fconfig.id##lib);  \\\n\t\tvglout.print(\"\\n\");  \\\n\t\tif(err) vglout.print(\"[VGL]    %s\\n\", err);  \\\n\t}  \\\n\treturn sym;  \\\n}\n\nLOAD_XCB_SYMBOL(XCB, xcb, xcb, 1, 1)\nLOAD_XCB_SYMBOL(XCBGLX, xcbglx, xcb-glx, 0, 0);\nLOAD_XCB_SYMBOL(XCBKeysyms, xcbkeysyms, xcb-keysyms, 0, 1)\nLOAD_XCB_SYMBOL(XCBX11, xcbx11, X11-xcb, 1, 1)\n\n#endif\n\n\nnamespace vglfaker {\n\nvoid unloadSymbols(void)\n{\n\tif(gldllhnd && gldllhnd!=RTLD_NEXT) dlclose(gldllhnd);\n\tif(x11dllhnd && x11dllhnd!=RTLD_NEXT) dlclose(x11dllhnd);\n\t#ifdef FAKEXCB\n\tif(xcbdllhnd) dlclose(xcbdllhnd);\n\tif(xcbglxdllhnd) dlclose(xcbglxdllhnd);\n\tif(xcbkeysymsdllhnd) dlclose(xcbkeysymsdllhnd);\n\tif(xcbx11dllhnd) dlclose(xcbx11dllhnd);\n\t#endif\n}\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/server/CMakeLists.txt": "###############################################################################\n# SERVER\n###############################################################################\n\nset(VGL_DEFAULTSYSTEMFLTK 0)\noption(VGL_SYSTEMFLTK\n\t\"Link against a system-supplied version of FLTK instead of the in-tree version.\"\n\t${VGL_DEFAULTSYSTEMFLTK})\nif(VGL_SYSTEMFLTK)\n\tfind_package(FLTK)\nelse()\n\tmessage(STATUS \"Using in-tree version of FLTK\")\n\tadd_subdirectory(fltk)\n\tset(FLTK_INCLUDE_DIR fltk)\n\tset(FLTK_BASE_LIBRARY fltk_static)\nendif()\n\nconfigure_file(fakerconfig.h.in fakerconfig.h)\nconfigure_file(vendor.h.in vendor.h)\n\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_CURRENT_SOURCE_DIR}\n\t../common)\n\nset(FBXFAKERLIB fbx-faker)\nif(VGL_USEXV)\n\tset(FBXFAKERLIB ${FBXFAKERLIB};fbxv)\nendif()\n\noption(VGL_FAKEXCB \"Interpose enough of the XCB API to make Qt 5 work\" ON)\nif(VGL_FAKEXCB)\n\tadd_definitions(-DFAKEXCB)\n\tset(FAKER_XCB_SOURCES faker-xcb.cpp XCBConnHash.cpp)\n\tset(VGL_DEFAULTSYSTEMXCB 0)\n\toption(VGL_SYSTEMXCB\n\t\t\"Compile against system-supplied versions of the XCB headers instead of the in-tree versions.\"\n\t\t\t${VGL_DEFAULTSYSTEMXCB})\n\tif(VGL_SYSTEMXCB)\n\t\tadd_definitions(-DSYSXCBHEADERS)\n\tendif()\nendif()\n\nget_directory_property(DEFS_PROP COMPILE_DEFINITIONS)\nforeach(def ${DEFS_PROP})\n\tset(DEFINES ${DEFINES};-D${def})\nendforeach()\nadd_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/faker-mapfile\n\tCOMMAND ${CMAKE_C_COMPILER} ${DEFINES} -E\n\t\t${CMAKE_CURRENT_SOURCE_DIR}/faker-mapfile.c\n\t\t> ${CMAKE_CURRENT_BINARY_DIR}/faker-mapfile\n\tDEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/faker-mapfile.c)\n\nset(FAKER_SOURCES\n\tConfigHash.cpp\n\tContextHash.cpp\n\tDisplayHash.cpp\n\tfaker.cpp\n\tfaker-gl.cpp\n\tfaker-glx.cpp\n\tfaker-sym.cpp\n\tfaker-x11.cpp\n\t${FAKER_XCB_SOURCES}\n\tfakerconfig.cpp\n\tGlobalCriticalSection.cpp\n\tGLXDrawableHash.cpp\n\tglxvisual.cpp\n\tPixmapHash.cpp\n\tReverseConfigHash.cpp\n\tTransPlugin.cpp\n\tVirtualDrawable.cpp\n\tVirtualPixmap.cpp\n\tVirtualWin.cpp\n\tVisualHash.cpp\n\tWindowHash.cpp\n\tX11Trans.cpp\n\tvglconfigLauncher.cpp\n\tVGLTrans.cpp)\nif(VGL_USEXV)\n\tset(FAKER_SOURCES ${FAKER_SOURCES};XVTrans.cpp)\nendif()\n\nforeach(fakerlib ${VGL_FAKER_NAME} ${VGL_FAKER_NAME}-nodl)\n\tadd_library(${fakerlib} SHARED ${FAKER_SOURCES})\n\tif(${fakerlib} STREQUAL ${VGL_FAKER_NAME} AND\n\t\tCMAKE_SYSTEM_NAME MATCHES \"Linux\")\n\t\t# GCC 4.6 and later on Linux apparently passes --as-needed to the linker,\n\t\t# and since libvglfaker.so loads OpenGL/GLX functions indirectly (with\n\t\t# dlopen()/dlsym()), --as-needed prevents the linker from adding a\n\t\t# DT_NEEDED tag for libGL to libvglfaker.so.  Without the following fix,\n\t\t# when attempting to vglrun applications that themselves indirectly load\n\t\t# OpenGL functions, libGL would not be loaded into the process, and VGL's\n\t\t# calls to dlsym(RTLD_NEXT, ...) would fail.\n\t\tset(NOASNEEDED \"-Wl,--no-as-needed\")\n\tendif()\n\tif(MAPFLAG)\n\t\tset_source_files_properties(faker-sym.cpp PROPERTIES\n\t\t\tOBJECT_DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/faker-mapfile)\n\t\tset_target_properties(${fakerlib} PROPERTIES\n\t\t\tLINK_FLAGS \"${MINUSZ}defs ${MAPFLAG}${CMAKE_CURRENT_BINARY_DIR}/faker-mapfile ${NOASNEEDED}\")\n\telse()\n\t\tset_target_properties(${fakerlib} PROPERTIES LINK_FLAGS \"${MINUSZ}defs ${NOASNEEDED}\")\n\tendif()\n\ttarget_link_libraries(${fakerlib} vglcommon ${FBXFAKERLIB} vglsocket m\n\t\t${LIBDL})\n\tif(${fakerlib} STREQUAL ${VGL_FAKER_NAME})\n\t\ttarget_link_libraries(${fakerlib} ${OPENGL_gl_LIBRARY})\n\tendif()\n\tif(CMAKE_SYSTEM_NAME STREQUAL \"SunOS\" AND GNUCXX)\n\t\t# For some reason, on SunOS/GCC CMake tries to use the C compiler to link\n\t\t# C++ shared libs.  Grrr...  (NOTE: This was fixed in CMake v3.4, so we\n\t\t# can remove this if we ever require a version later than that.)\n\t\ttarget_link_libraries(${fakerlib} stdc++)\n\tendif()\n\tinstall(TARGETS ${fakerlib} DESTINATION ${CMAKE_INSTALL_LIBDIR})\nendforeach()\n\nadd_library(${VGL_DLFAKER_NAME} SHARED dlfaker.c)\ntarget_link_libraries(${VGL_DLFAKER_NAME} ${LIBDL})\ninstall(TARGETS ${VGL_DLFAKER_NAME} DESTINATION ${CMAKE_INSTALL_LIBDIR})\n\nadd_library(${VGL_GEFAKER_NAME} SHARED gefaker.c)\nset_target_properties(${VGL_GEFAKER_NAME} PROPERTIES LINK_FLAGS \"${MINUSZ}defs\")\ntarget_link_libraries(${VGL_GEFAKER_NAME} ${LIBDL})\ninstall(TARGETS ${VGL_GEFAKER_NAME} DESTINATION ${CMAKE_INSTALL_LIBDIR})\n\nset(HEADERS ../common/rr.h rrtransport.h)\ninstall(FILES ${HEADERS} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n\ninclude_directories(${FLTK_INCLUDE_DIR})\nadd_executable(vglconfig vglconfig.cpp fakerconfig.cpp)\ntarget_link_libraries(vglconfig ${X11_X11_LIB} ${FLTK_BASE_LIBRARY} vglutil)\nif(VGL_USEXV)\n\ttarget_link_libraries(vglconfig ${X11_Xv_LIB})\nendif()\ninstall(TARGETS vglconfig DESTINATION ${CMAKE_INSTALL_BINDIR})\n\ninstall(PROGRAMS vglgenkey vgllogin vglserver_config DESTINATION\n\t${CMAKE_INSTALL_BINDIR})\n\nconfigure_file(vglrun.in ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/vglrun @ONLY)\nexecute_process(COMMAND chmod +x vglrun\n\tWORKING_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY})\ninstall(PROGRAMS ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/vglrun\n\tDESTINATION ${CMAKE_INSTALL_BINDIR})\nconfigure_file(vglrun.vars.in\n\t${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/.vglrun.vars${BITS} @ONLY)\nexecute_process(COMMAND chmod +x .vglrun.vars${BITS}\n\tWORKING_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY})\ninstall(PROGRAMS ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/.vglrun.vars${BITS}\n\tDESTINATION ${CMAKE_INSTALL_BINDIR})\n\n\n###############################################################################\n# UNIT TESTS\n###############################################################################\n\nadd_executable(x11transut x11transut.cpp fakerconfig.cpp X11Trans.cpp)\ntarget_link_libraries(x11transut vglcommon ${FBXLIB} ${TJPEG_LIBRARY})\n\nadd_executable(vgltransut vgltransut.cpp VGLTrans.cpp\n\tfakerconfig.cpp)\ntarget_link_libraries(vgltransut vglcommon ${FBXLIB} vglsocket\n\t${TJPEG_LIBRARY})\n\nadd_executable(dlfakerut dlfakerut.c)\ntarget_link_libraries(dlfakerut ${X11_X11_LIB} ${LIBDL})\n\nadd_library(GLdlfakerut SHARED libGLdlfakerut.c)\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n\tadd_library(deepbindtest SHARED libdeepbindtest.c)\n\ttarget_link_libraries(deepbindtest ${X11_X11_LIB} ${OPENGL_gl_LIBRARY})\n\tset_target_properties(deepbindtest PROPERTIES LINK_FLAGS \"${MINUSZ}defs\")\nendif()\n\nadd_executable(fakerut fakerut.cpp fakerut-supplement.c)\ntarget_link_libraries(fakerut \"${MINUSZ}now ${OPENGL_gl_LIBRARY}\"\n\t${OPENGL_glu_LIBRARY} \"${MINUSZ}now ${X11_X11_LIB}\" ${LIBDL} vglutil)\n\nadd_library(vgltrans_test SHARED testplugin.cpp VGLTrans.cpp)\nif(VGL_USESSL AND CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n\t# Work around this issue:\n\t# http://rt.openssl.org/Ticket/Display.html?user=guest&pass=guest&id=1521\n\tset_target_properties(vgltrans_test PROPERTIES LINK_FLAGS \"-Wl,-Bsymbolic\")\nendif()\ntarget_link_libraries(vgltrans_test vglcommon ${FBXFAKERLIB} ${TJPEG_LIBRARY}\n\tvglsocket)\nif(CMAKE_SYSTEM_NAME STREQUAL \"SunOS\" AND GNUCXX)\n\ttarget_link_libraries(vgltrans_test stdc++)\nendif()\n\nadd_library(vgltrans_test2 SHARED testplugin2.cpp X11Trans.cpp)\ntarget_link_libraries(vgltrans_test2 vglcommon ${FBXFAKERLIB} ${TJPEG_LIBRARY})\nif(CMAKE_SYSTEM_NAME STREQUAL \"SunOS\" AND GNUCXX)\n\ttarget_link_libraries(vgltrans_test2 stdc++)\nendif()\n\nconfigure_file(servertest.in ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/servertest)\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/server/faker-mapfile.c": "{\n\tglobal:\n\t\t/* GLX 1.0 */\n\t\tglXChooseVisual;\n\t\tglXCopyContext;\n\t\tglXCreateContext;\n\t\tglXCreateGLXPixmap;\n\t\tglXDestroyContext;\n\t\tglXDestroyGLXPixmap;\n\t\tglXGetConfig;\n\t\tglXGetCurrentDrawable;\n\t\tglXIsDirect;\n\t\tglXMakeCurrent;\n\t\tglXQueryExtension;\n\t\tglXQueryVersion;\n\t\tglXSwapBuffers;\n\t\tglXUseXFont;\n\t\tglXWaitGL;\n\n\t\t/* GLX 1.1 */\n\t\tglXGetClientString;\n\t\tglXQueryServerString;\n\t\tglXQueryExtensionsString;\n\n\t\t/* GLX 1.2 */\n\t\tglXGetCurrentDisplay;\n\n\t\t/* GLX 1.3 */\n\t\tglXChooseFBConfig;\n\t\tglXCreateNewContext;\n\t\tglXCreatePbuffer;\n\t\tglXCreatePixmap;\n\t\tglXCreateWindow;\n\t\tglXDestroyPbuffer;\n\t\tglXDestroyPixmap;\n\t\tglXDestroyWindow;\n\t\tglXGetCurrentReadDrawable;\n\t\tglXGetFBConfigAttrib;\n\t\tglXGetFBConfigs;\n\t\tglXGetSelectedEvent;\n\t\tglXGetVisualFromFBConfig;\n\t\tglXMakeContextCurrent;\n\t\tglXQueryContext;\n\t\tglXQueryDrawable;\n\t\tglXSelectEvent;\n\n\t\t/* GLX 1.4 */\n\t\tglXGetProcAddress;\n\n\t\t/* GLX_ARB_create_context */\n\t\tglXCreateContextAttribsARB;\n\n\t\t/* GLX_ARB_get_proc_address */\n\t\tglXGetProcAddressARB;\n\n\t\t/* GLX_EXT_import_context */\n\t\tglXFreeContextEXT;\n\t\tglXImportContextEXT;\n\t\tglXQueryContextInfoEXT;\n\n\t\t/* GLX_EXT_swap_control */\n\t\tglXSwapIntervalEXT;\n\n\t\t/* GLX_EXT_texture_from_pixmap */\n\t\tglXBindTexImageEXT;\n\t\tglXReleaseTexImageEXT;\n\n\t\t/* GLX_NV_swap_group */\n\t\tglXBindSwapBarrierNV;\n\t\tglXJoinSwapGroupNV;\n\t\tglXQueryFrameCountNV;\n\t\tglXQueryMaxSwapGroupsNV;\n\t\tglXQuerySwapGroupNV;\n\t\tglXResetFrameCountNV;\n\n\t\t/* GLX_SGI_make_current_read */\n\t\tglXGetCurrentReadDrawableSGI;\n\t\tglXMakeCurrentReadSGI;\n\n\t\t/* GLX_SGI_swap_control */\n\t\tglXSwapIntervalSGI;\n\n\t\t/* GLX_SGIX_fbconfig */\n\t\tglXChooseFBConfigSGIX;\n\t\tglXCreateContextWithConfigSGIX;\n\t\tglXCreateGLXPixmapWithConfigSGIX;\n\t\tglXGetFBConfigAttribSGIX;\n\t\tglXGetFBConfigFromVisualSGIX;\n\t\tglXGetVisualFromFBConfigSGIX;\n\n\t\t/* GLX_SGIX_pbuffer */\n\t\tglXCreateGLXPbufferSGIX;\n\t\tglXDestroyGLXPbufferSGIX;\n\t\tglXGetSelectedEventSGIX;\n\t\tglXQueryGLXPbufferSGIX;\n\t\tglXSelectEventSGIX;\n\n\t\t/* GLX_SUN_get_transparent_index */\n\t\tglXGetTransparentIndexSUN;\n\n\t\t/* OpenGL */\n\t\tglFinish;\n\t\tglFlush;\n\t\tglViewport;\n\t\tglDrawBuffer;\n\t\tglPopAttrib;\n\n\t\t/* X11 */\n\t\tXCheckMaskEvent;\n\t\tXCheckTypedEvent;\n\t\tXCheckTypedWindowEvent;\n\t\tXCheckWindowEvent;\n\t\tXCloseDisplay;\n\t\tXConfigureWindow;\n\t\tXCopyArea;\n\t\tXCreateWindow;\n\t\tXCreateSimpleWindow;\n\t\tXDestroySubwindows;\n\t\tXDestroyWindow;\n\t\tXFree;\n\t\tXGetGeometry;\n\t\tXGetImage;\n\t\tXListExtensions;\n\t\tXMaskEvent;\n\t\tXMoveResizeWindow;\n\t\tXNextEvent;\n\t\tXOpenDisplay;\n\t\tXQueryExtension;\n\t\tXResizeWindow;\n\t\tXServerVendor;\n\t\t#ifdef FAKEXCB\n\t\tXSetEventQueueOwner;\n\t\t#endif\n\t\tXWindowEvent;\n\n\t\tXCopyArea_FBX;\n\n\t\t_vgl_dlopen;\n\n\t\t/* XCB */\n\t\t#ifdef FAKEXCB\n\t\txcb_get_extension_data;\n\t\txcb_glx_query_version;\n\t\txcb_glx_query_version_reply;\n\t\txcb_poll_for_event;\n\t\txcb_poll_for_queued_event;\n\t\txcb_wait_for_event;\n\t\t#endif\n\n\tlocal:\n\t\t*;\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/doc/apprecipes.txt": "* Other Application Recipes\n{anchor: Application_Recipes}\n\n|| Application || Versions Known to Require Recipe || Platform || Recipe || Notes ||\n| Abaqus | v6 | Linux \\\n\t| It is necessary to add \\\n\t\t{nl}{nl} \\\n\t\t''import os''{nl} \\\n\t\t''os.environ['ABAQUS_EMULATE_OVERLAYS'] = \"1\"'' \\\n\t\t{nl}{nl} \\\n\t\tto ''/{abaqus_install_dir}/{abaqus_version}/site/abaqus_v6.env'' to make \\\n\t\tAbaqus v6 work properly with VirtualGL if the 2D X server does not \\\n\t\tsupport transparent overlays.  If this is not done, then the application \\\n\t\tmay fail to launch, fail to display the 3D pixels, or the 3D pixels may \\\n\t\tbecome corrupted whenever other windows obscure them. \\\n\t| VirtualGL does not redirect the rendering of transparent overlays, since \\\n\t\tthose cannot be rendered in a Pbuffer.  Thus, in order to use transparent \\\n\t\toverlays, the 2D X server must be able to render them, which is rarely \\\n\t\tthe case for X proxies (see {ref prefix=\"Section \": overlays} for more \\\n\t\tdetails.)  Setting ''ABAQUS_EMULATE_OVERLAYS'' to ''1'' causes \\\n\t\tthe application to emulate overlay rendering instead of using actual \\\n\t\ttransparent overlays.  This workaround is known to be necessary when \\\n\t\trunning Abaqus 6.9 and 6.10 in VNC. \\\n\t|\n| Abaqus | v6 | Linux \\\n\t| ''vglrun -nodl {abaqus_path}/abaqus'' \\\n\t| User reports indicate that Abaqus 6.9 will not work properly if \\\n\t\t''libdlfaker.so'' from VirtualGL is preloaded into it.  This may be true \\\n\t\tfor other versions of Abaqus as well. \\\n\t|\n| Cadence Allegro | v16.5 | Linux \\\n\t| ''vglrun +sync allegro''  \\\n\t| Allegro relies on mixed X11/OpenGL rendering, and thus certain features \\\n\t\t(specifically the ''pcb_cursor_infinite'' cursor style) do not work \\\n\t\tproperly unless ''VGL_SYNC'' is enabled.  If ''VGL_SYNC'' is not enabled, \\\n\t\tthen the crosshairs may remain on the screen.  Since ''VGL_SYNC'' \\\n\t\tautomatically enables the X11 transport and disables frame spoiling, it \\\n\t\tis highly recommended that you use an X proxy when ''VGL_SYNC'' is enabled. \\\n\t\tSee {ref prefix=\"Section \": VGL_SYNC} for further information. \\\n\t|\n| Animator | v4 | Linux \\\n\t| Comment out the line that reads \\\n\t\t{nl}{nl} \\\n\t\t''unsetenv LD_PRELOAD'' \\\n\t\t{nl}{nl} \\\n\t\tin the ''a4'' script, then launch Animator 4 using \\\n\t\t{nl}{nl} \\\n\t\t''vglrun -ge a4'' \\\n\t\t{nl}{nl} \\\n\t| When the ''a4'' script unsets ''LD_PRELOAD'', this prevents VirtualGL \\\n\t\tfrom being loaded into the application.  Animator 4 additionally checks \\\n\t\tthe value of ''LD_PRELOAD'' and attempts to unset it from inside \\\n\t\tthe application.  Using ''vglrun -ge'' to launch the application fools \\\n\t\tAnimator 4 into thinking that ''LD_PRELOAD'' is unset. \\\n\t|\n| ANSA | v12.1.0 | Linux \\\n\t| Add \\\n\t\t{nl}{nl} \\\n\t\t''LD_PRELOAD_SAVE=$LD_PRELOAD''{nl} \\\n\t\t''export LD_PRELOAD='' \\\n\t\t{nl}{nl} \\\n\t\tto the top of the ''ansa.sh'' script, then add \\\n\t\t{nl}{nl} \\\n\t\t''export LD_PRELOAD=$LD_PRELOAD_SAVE'' \\\n\t\t{nl}{nl} \\\n\t\tjust prior to the ''${ANSA_EXEC_DIR}bin/ansa_linux${ext2}'' line. \\\n\t| The ANSA startup script directly invokes ''/lib/libc.so.6'' to query \\\n\t\tthe glibc version.  Since the VirtualGL faker depends on libc, preloading \\\n\t\tVirtualGL when directly invoking ''libc.so.6'' creates an infinite loop. \\\n\t\tThus, it is necessary to disable the preloading of VirtualGL in the \\\n\t\tapplication script and then re-enable it prior to launching the actual \\\n\t\tapplication. \\\n\t|\n| ANSYS HFSS, ANSYS ICEM CFD, Roxar RMS | All | Linux \\\n\t| Set the ''VGL_SPOILLAST'' environment variable to ''0'' prior to \\\n\t\tlaunching the application with ''vglrun'' \\\n\t| These applications draw node highlighting and/or rubber banding directly to the \\\n\t\tfront buffer.  In order for these front buffer operations to be displayed \\\n\t\tproperly, it is necessary to use the \"spoil first\" frame spoiling \\\n\t\talgorithm whenever the application calls ''glFlush()''.  See \\\n\t\t{ref prefix=\"Section \": VGL_SPOILLAST} for further information. \\\n\t|\n| AutoForm | v4.0x | All \\\n\t| ''vglrun +sync xaf_''__''{version}''__ \\\n\t| AutoForm relies on mixed X11/OpenGL rendering, and thus certain features \\\n\t\t(particularly the \"Dynamic Section\" dialog and \"Export Image\" feature) do \\\n\t\tnot work properly unless ''VGL_SYNC'' is enabled.  Since ''VGL_SYNC'' \\\n\t\tautomatically enables the X11 transport and disables frame spoiling, it \\\n\t\tis highly recommended that you use an X proxy when ''VGL_SYNC'' is enabled. \\\n\t\tSee {ref prefix=\"Section \": VGL_SYNC} for further information. \\\n\t|\n| Cedega | v6.0.x | Linux \\\n\t| Add \\\n\t\t{nl}{nl} \\\n\t\t''export LD_PRELOAD=libvglfaker.so'' \\\n\t\t{nl}{nl} \\\n\t\tto the top of ''~/.cedega/.winex_ver/winex-{version}/bin/winex3'', then \\\n\t\trun Cedega as you would normally (without ''vglrun''.)  Since ''vglrun'' \\\n\t\tis not being used, it is necessary to use environment variables or the \\\n\t\tVirtualGL Configuration dialog to modify VirtualGL's configuration. \\\n\t| The actual binary (WineX) that uses OpenGL is buried beneath several \\\n\t\tlayers of Python and shell scripts.  The ''LD_PRELOAD'' variable does not \\\n\t\tget propagated down from the initial shell that invoked ''vglrun''. \\\n\t|\n| Google Chrome/Chromium | v31 and later | Linux \\\n\t| ''vglrun google-chrome --disable-gpu-sandbox''{nl} \\\n\t\tor{nl} \\\n\t\t''vglrun chromium --disable-gpu-sandbox'' \\\n\t| By default, Chrome/Chromium uses a separate process to perform 3D \\\n\t\trendering (WebGL), and for reasons that are not yet fully understood, \\\n\t\tthis breaks VirtualGL.  The ''--disable-gpu-sandbox'' option causes 3D \\\n\t\trendering to be performed within the browser process. \\\n\t|\n| Compiz | All | Linux \\\n\t| Set the ''VGL_WM'' environment variable to ''1'' prior to launching the \\\n\t\twindow manager with ''vglrun'', or pass an argument of ''+wm'' to \\\n\t\t''vglrun''. \\\n\t| See {ref prefix=\"Section \": VGL_WM} for further information. \\\n\t|\n| Heretic II | All | Linux \\\n\t| ''vglrun heretic2 +set vid_ref glx'' \\\n\t| {:} \\\n\t|\n| Intel OpenCL ICD | All | Linux \\\n\t| ''vglrun -ld {path_to_Intel_OpenCL_libs} {application}'' \\\n\t| The Intel OpenCL installable client driver (ICD) is linked with a \\\n\t\trun-time library search path (rpath) of ''$ORIGIN'', which would normally \\\n\t\thave the same effect as adding the directory in which the ICD is \\\n\t\tinstalled (default: ''/opt/intel/opencl/lib64'' on 64-bit systems) to \\\n\t\t''LD_LIBRARY_PATH''.  However, when VirtualGL is interposing the \\\n\t\t''dlopen()'' function (which it does by default), this causes the actual \\\n\t\t''dlopen()'' system calls to come from ''libdlfaker.so'', so ''$ORIGIN'' \\\n\t\twill resolve to the directory in which the VirtualGL faker libraries are \\\n\t\tinstalled.  This causes the ''dlopen()'' calls within the Intel ICD to \\\n\t\tfail, and because the ICD apparently does not check the return value of \\\n\t\tthose calls, a segfault occurs.  The workaround is simply to add the \\\n\t\tIntel ICD library path to ''LD_LIBRARY_PATH'', which is most easily \\\n\t\taccomplished with ''vglrun -ld''. \\\n\t|\n| Mathematica | v7 | Linux \\\n\t| Set the ''VGL_ALLOWINDIRECT'' environment variable to ''1'' prior to \\\n\t\tlaunching the application with ''vglrun'' \\\n\t| Mathematica 7 will not draw the axis numbers on 3D charts correctly \\\n\t\tunless it is allowed to create an indirect OpenGL context.  See \\\n\t\t{ref prefix=\"Section \": VGL_ALLOWINDIRECT} for further information. \\\n\t|\n| MATLAB | All | Linux \\\n\t| ''vglrun /usr/local/MATLAB/{version}/bin/matlab -nosoftwareopengl'' \\\n\t| MATLAB will automatically use its built-in (unaccelerated) OpenGL \\\n\t\timplementation if it detects that it is running in a remote display \\\n\t\tenvironment.  More specifically, it will always enable software OpenGL \\\n\t\tif the X server has an X extension called ''VNC-EXTENSION'', which is \\\n\t\tthe case with TurboVNC, TigerVNC, and RealVNC. \\\n\t|\n| Tecplot 360 | 2011 and earlier | Linux \\\n\t| Set the ''VGL_GLFLUSHTRIGGER'' environment variable to ''0'' prior to \\\n\t\tlaunching the application with ''vglrun'' \\\n\t| When running in TurboVNC (using VirtualGL), flashing artifacts will be \\\n\t\tproduced when the user zooms/pans/rotates the scene in Tecplot 360, \\\n\t\tunless VirtualGL is instructed not to use ''glFlush()'' as an \\\n\t\tend-of-frame trigger.  This has been fixed in Tecplot 2012 and later. \\\n\t\tSee {ref prefix=\"Section \": VGL_GLFLUSHTRIGGER} for further information. \\\n\t|\n",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/doc/index.html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html lang=\"en\">\n<head>\n<meta http-equiv=\"content-type\" content=\"text/html; charset=ISO-8859-1\">\n<meta name=\"language\" content=\"en\">\n<meta name=\"date\" content=\"2016-11-03T13:20:18\">\n<meta name=\"generator\" content=\"deplate.rb 0.8.5\">\n<title>User&rsquo;s Guide for VirtualGL 2.5.2</title>\n<link rel=\"start\" href=\"index.html\" title=\"Frontpage\">\n<link rel=\"chapter\" href=\"index.html#hd001\" title=\"1 Legal Information\">\n<link rel=\"chapter\" href=\"index.html#hd002\" title=\"2 Conventions Used in This Document\">\n<link rel=\"chapter\" href=\"index.html#hd003\" title=\"3 Overview\">\n<link rel=\"chapter\" href=\"index.html#hd004\" title=\"4 System Requirements\">\n<link rel=\"chapter\" href=\"index.html#hd005\" title=\"5 Obtaining and Installing VirtualGL\">\n<link rel=\"chapter\" href=\"index.html#hd006\" title=\"6 Configuring a Linux or Unix Machine as a VirtualGL Server\">\n<link rel=\"chapter\" href=\"index.html#hd007\" title=\"7 Configuring a Windows Machine as a VGL Transport Client\">\n<link rel=\"chapter\" href=\"index.html#hd008\" title=\"8 Using VirtualGL with the VGL Transport\">\n<link rel=\"chapter\" href=\"index.html#hd009\" title=\"9 Using VirtualGL with X Proxies Such as VNC\">\n<link rel=\"chapter\" href=\"index.html#hd0010\" title=\"10 Support for the X Video Extension\">\n<link rel=\"chapter\" href=\"index.html#hd0011\" title=\"11 Transport Plugins\">\n<link rel=\"chapter\" href=\"index.html#hd0012\" title=\"12 Using VirtualGL with setuid/setgid Executables\">\n<link rel=\"chapter\" href=\"index.html#hd0013\" title=\"13 Using VirtualGL with VirtualBox\">\n<link rel=\"chapter\" href=\"index.html#hd0014\" title=\"14 Using VirtualGL with VMWare Workstation\">\n<link rel=\"chapter\" href=\"index.html#hd0015\" title=\"15 Other Application Recipes\">\n<link rel=\"chapter\" href=\"index.html#hd0016\" title=\"16 Advanced OpenGL Features\">\n<link rel=\"chapter\" href=\"index.html#hd0017\" title=\"17 Performance Measurement\">\n<link rel=\"chapter\" href=\"index.html#hd0018\" title=\"18 The VirtualGL Configuration Dialog\">\n<link rel=\"chapter\" href=\"index.html#hd0019\" title=\"19 Advanced Configuration\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"virtualgl.css\" title=\"virtualgl\">\n</head>\n<body >\n<a name=\"#pagetop\"></a>\n<div class=\"title\">\n<p class=\"title\">User&rsquo;s Guide for VirtualGL 2.5.2</p>\n</div>\n<a name=\"file000\"></a>\n<p><em>Intended audience:</em> System Administrators, Graphics Programmers, \nResearchers, and others with knowledge of Linux or Unix operating \nsystems, OpenGL and GLX, and X windows.</p>\n\n<div id=\"hd\">\n<div id=\"hdBlock\" class=\"hd\">\n<ul class=\"hd\">\n    <li class=\"Itemize-1 hd\">\n        <a href=\"#hd001\" class=\"hd\">1 Legal Information</a>\n    </li>\n    <li class=\"Itemize-1 hd\">\n        <a href=\"#hd002\" class=\"hd\">2 Conventions Used in This Document</a>\n    </li>\n    <li class=\"Itemize-1 hd\">\n        <a href=\"#hd003\" class=\"hd\">3 Overview</a>\n    </li>\n    <li class=\"Itemize-1 hd\">\n        <a href=\"#hd004\" class=\"hd\">4 System Requirements</a>\n        <ul class=\"hd\">\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd004001\" class=\"hd\">4.1 Linux/x86 and Other x86 Un*x \n                Operating Systems</a>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd004002\" class=\"hd\">4.2 Mac/x86</a>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd004003\" class=\"hd\">4.3 Windows</a>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd004004\" class=\"hd\">4.4 Additional Requirements for \n                Stereographic Rendering</a>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd004005\" class=\"hd\">4.5 Additional Requirements for \n                Transparent Overlays</a>\n            </li>\n        </ul>\n    </li>\n    <li class=\"Itemize-1 hd\">\n        <a href=\"#hd005\" class=\"hd\">5 Obtaining and Installing VirtualGL</a>\n        <ul class=\"hd\">\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd005001\" class=\"hd\">5.1 Installing VirtualGL on Linux</a>\n                <ul class=\"hd\">\n                    <li class=\"Itemize-5 hd\">\n                        <a href=\"#hd005001001\" class=\"hd\">5.1.1 Installing a 32-bit VirtualGL \n                        Package on x86-64 Linux Distributions</a>\n                    </li>\n                </ul>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd005002\" class=\"hd\">5.2 Installing the VirtualGL Client on OS \n                X</a>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd005003\" class=\"hd\">5.3 Installing the VirtualGL Client on \n                Windows (Cygwin)</a>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd005004\" class=\"hd\">5.4 Installing VirtualGL from Source</a>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd005005\" class=\"hd\">5.5 Uninstalling VirtualGL</a>\n            </li>\n        </ul>\n    </li>\n    <li class=\"Itemize-1 hd\">\n        <a href=\"#hd006\" class=\"hd\">6 Configuring a Linux or Unix Machine as a \n        VirtualGL Server</a>\n        <ul class=\"hd\">\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd006001\" class=\"hd\">6.1 Granting Access to the 3D X Server</a>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd006002\" class=\"hd\">6.2 Using VirtualGL with Multiple GPUs</a>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd006003\" class=\"hd\">6.3 SSH Server Configuration</a>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd006004\" class=\"hd\">6.4 Un-Configuring the Server</a>\n            </li>\n        </ul>\n    </li>\n    <li class=\"Itemize-1 hd\">\n        <a href=\"#hd007\" class=\"hd\">7 Configuring a Windows Machine as a VGL \n        Transport Client</a>\n    </li>\n    <li class=\"Itemize-1 hd\">\n        <a href=\"#hd008\" class=\"hd\">8 Using VirtualGL with the VGL Transport</a>\n        <ul class=\"hd\">\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd008001\" class=\"hd\">8.1 VGL Transport with X11 Forwarding</a>\n                <ul class=\"hd\">\n                    <li class=\"Itemize-5 hd\">\n                        <a href=\"#hd008001001\" class=\"hd\">8.1.1 Procedure</a>\n                    </li>\n                </ul>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd008002\" class=\"hd\">8.2 VGL Transport with a Direct X11 \n                Connection</a>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd008003\" class=\"hd\">8.3 VGL Transport with X11 Forwarding and \n                SSH Tunneling</a>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd008004\" class=\"hd\">8.4 VGL Transport over Gigabit \n                Networks</a>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd008005\" class=\"hd\">8.5 VGL Transport with XDMCP</a>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd008006\" class=\"hd\">8.6 The VirtualGL Client Application: \n                Nuts and Bolts</a>\n                <ul class=\"hd\">\n                    <li class=\"Itemize-5 hd\">\n                        <a href=\"#hd008006001\" class=\"hd\">8.6.1 The VirtualGL Client and \n                        Firewalls</a>\n                    </li>\n                </ul>\n            </li>\n        </ul>\n    </li>\n    <li class=\"Itemize-1 hd\">\n        <a href=\"#hd009\" class=\"hd\">9 Using VirtualGL with X Proxies Such as \n        VNC</a>\n        <ul class=\"hd\">\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd009001\" class=\"hd\">9.1 Using VirtualGL with an X Proxy on \n                the Same Server</a>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd009002\" class=\"hd\">9.2 Using VirtualGL with an X Proxy on a \n                Different Machine</a>\n            </li>\n        </ul>\n    </li>\n    <li class=\"Itemize-1 hd\">\n        <a href=\"#hd0010\" class=\"hd\">10 Support for the X Video Extension</a>\n        <ul class=\"hd\">\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd0010001\" class=\"hd\">10.1 The VGL Transport with YUV \n                Encoding</a>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd0010002\" class=\"hd\">10.2 The XV Transport</a>\n            </li>\n        </ul>\n    </li>\n    <li class=\"Itemize-1 hd\">\n        <a href=\"#hd0011\" class=\"hd\">11 Transport Plugins</a>\n    </li>\n    <li class=\"Itemize-1 hd\">\n        <a href=\"#hd0012\" class=\"hd\">12 Using VirtualGL with setuid/setgid \n        Executables</a>\n    </li>\n    <li class=\"Itemize-1 hd\">\n        <a href=\"#hd0013\" class=\"hd\">13 Using VirtualGL with VirtualBox</a>\n    </li>\n    <li class=\"Itemize-1 hd\">\n        <a href=\"#hd0014\" class=\"hd\">14 Using VirtualGL with VMWare \n        Workstation</a>\n    </li>\n    <li class=\"Itemize-1 hd\">\n        <a href=\"#hd0015\" class=\"hd\">15 Other Application Recipes</a>\n    </li>\n    <li class=\"Itemize-1 hd\">\n        <a href=\"#hd0016\" class=\"hd\">16 Advanced OpenGL Features</a>\n        <ul class=\"hd\">\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd0016001\" class=\"hd\">16.1 Stereographic Rendering</a>\n                <ul class=\"hd\">\n                    <li class=\"Itemize-5 hd\">\n                        <a href=\"#hd0016001001\" class=\"hd\">16.1.1 Quad-Buffered Stereo</a>\n                    </li>\n                    <li class=\"Itemize-5 hd\">\n                        <a href=\"#hd0016001002\" class=\"hd\">16.1.2 Anaglyphic Stereo</a>\n                    </li>\n                    <li class=\"Itemize-5 hd\">\n                        <a href=\"#hd0016001003\" class=\"hd\">16.1.3 Passive Stereo</a>\n                    </li>\n                    <li class=\"Itemize-5 hd\">\n                        <a href=\"#hd0016001004\" class=\"hd\">16.1.4 Selecting a Stereo Mode</a>\n                    </li>\n                </ul>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd0016002\" class=\"hd\">16.2 Transparent Overlays</a>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd0016003\" class=\"hd\">16.3 Troubleshooting</a>\n            </li>\n        </ul>\n    </li>\n    <li class=\"Itemize-1 hd\">\n        <a href=\"#hd0017\" class=\"hd\">17 Performance Measurement</a>\n        <ul class=\"hd\">\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd0017001\" class=\"hd\">17.1 VirtualGL&rsquo;s Built-In \n                Profiling System</a>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd0017002\" class=\"hd\">17.2 Frame Spoiling</a>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd0017003\" class=\"hd\">17.3 VirtualGL Diagnostic Tools</a>\n            </li>\n        </ul>\n    </li>\n    <li class=\"Itemize-1 hd\">\n        <a href=\"#hd0018\" class=\"hd\">18 The VirtualGL Configuration Dialog</a>\n    </li>\n    <li class=\"Itemize-1 hd\">\n        <a href=\"#hd0019\" class=\"hd\">19 Advanced Configuration</a>\n        <ul class=\"hd\">\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd0019001\" class=\"hd\">19.1 Server Settings</a>\n            </li>\n            <li class=\"Itemize-3 hd\">\n                <a href=\"#hd0019002\" class=\"hd\">19.2 Client Settings</a>\n            </li>\n        </ul>\n    </li>\n</ul>\n</div></div>\n<p><br /></p>\n\n<hr class=\"break\" />\n\n\n<h1 id=\"hd001\"><a name=\"file001\"></a>1&nbsp;Legal Information</h1>\n\n<p><img src=\"somerights20.png\" alt=\"somerights20\" class=\"inline\" id=\"imgid_0\" name=\"imgid_0\"/></p>\n\n<p>This document and all associated illustrations are licensed under the \n<span class=\"remote\"><a href=\"http://creativecommons.org/licenses/by/2.5/\" class=\"remote\">Creative \nCommons Attribution 2.5 License</a></span><a name=\"idx001\"></a>.  Any \nworks that contain material derived from this document must cite The \nVirtualGL Project as the source of the material and list the current URL \nfor the VirtualGL web site.</p>\n\n<p>The official VirtualGL binaries contain libjpeg-turbo, which is based in \npart on the work of the Independent JPEG Group.</p>\n\n<p>The VirtualGL server components include software developed by the \n<span class=\"remote\"><a href=\"http://www.fltk.org/\" class=\"remote\">FLTK \nProject</a></span><a name=\"idx002\"></a> and distributed under the terms \nof the <a href=\"LICENSE-FLTK.txt\">FLTK License</a><a name=\"idx003\"></a>.</p>\n\n<p>VirtualGL is licensed under the <a href=\"LICENSE.txt\">wxWindows Library \nLicense, v3.1</a><a name=\"idx004\"></a>, a derivative of the \n<a href=\"LGPL.txt\">GNU Lesser General Public License (LGPL), \nv2.1</a><a name=\"idx005\"></a>.</p>\n\n<p><br /></p>\n\n<hr class=\"break\" />\n\n\n\n<h1 id=\"hd002\"><a name=\"file002\"></a>2&nbsp;Conventions Used in This Document</h1>\n\n<p>This document assumes that VirtualGL will be installed in the default \ndirectory (<code>/opt/VirtualGL</code>).  If your installation of \nVirtualGL resides in a different directory, then adjust the instructions \naccordingly.</p>\n\n<p><br /></p>\n\n<hr class=\"break\" />\n\n\n\n<h1 id=\"hd003\"><a name=\"file003\"></a>3&nbsp;Overview</h1>\n\n<p><a name=\"Overview\"></a></p>\n\n<p>VirtualGL is an open source toolkit that gives any Unix or Linux remote \ndisplay software the ability to run OpenGL applications with full 3D \nhardware acceleration.  Some remote display solutions cannot be used \nwith OpenGL applications at all.  Others force OpenGL applications to \nuse a slow, software-only renderer, to the detriment of performance as \nwell as compatibility.  The traditional method of displaying OpenGL \napplications to a remote X server (indirect rendering) supports 3D \nhardware acceleration, but this approach causes all of the OpenGL \ncommands and 3D data to be sent over the network to be rendered on the \nclient machine.  This is not a tenable proposition unless the data is \nrelatively small and static, unless the network is very fast, and unless \nthe OpenGL application is specifically tuned for a remote X-Windows \nenvironment.</p>\n\n<p>With VirtualGL, the OpenGL commands and 3D data are instead redirected \nto a 3D graphics accelerator (AKA &ldquo;graphics processing unit&rdquo; \nor &ldquo;GPU&rdquo;) in the application server, and only the rendered \n3D images are sent to the client machine.  VirtualGL thus \n&ldquo;virtualizes&rdquo; 3D graphics hardware, allowing it to be \nco-located in the &ldquo;cold room&rdquo; with compute and storage \nresources.  VirtualGL also allows GPUs to be shared among multiple \nusers, and it provides &ldquo;workstation-like&rdquo; levels of \nperformance on even the most modest of networks. This makes it possible \nfor large, noisy, hot 3D workstations to be replaced with laptops or \neven thinner clients.  More importantly, however, VirtualGL eliminates \nthe workstation and the network as barriers to data size.  Users can now \nvisualize huge amounts of data in real time without needing to copy any \nof the data over the network or sit in front of the machine that is \nrendering the data.</p>\n\n<p>Normally, a Unix OpenGL application would send all of its drawing \ncommands and data, both 2D and 3D, to an X-Windows server, which may be \nlocated across the network from the application server.  VirtualGL, \nhowever, employs a technique called &ldquo;split rendering&rdquo; to \nforce the 3D commands and data from the application to go to a GPU in \nthe application server.  VGL accomplishes this by pre-loading a dynamic \nshared object (DSO) into the OpenGL application at run time.  This DSO \nintercepts a handful of GLX, OpenGL, and X11 commands necessary to \nperform split rendering.  When the application attempts to use an X \nwindow for OpenGL rendering, VirtualGL intercepts the request, creates a \ncorresponding 3D pixel buffer (&ldquo;Pbuffer&rdquo;) in video memory on \nthe application server, and uses the Pbuffer for OpenGL rendering \ninstead.  When the application swaps the OpenGL drawing buffers or \nflushes the OpenGL command buffer to indicate that it has finished \nrendering a frame, VirtualGL reads back the pixels from the Pbuffer and \nsends them to the client.</p>\n\n<p>The beauty of this approach is its non-intrusiveness.  VirtualGL \nmonitors a few X11 commands and events to determine when windows have \nbeen resized, etc., but it does not interfere in any way with the \ndelivery of 2D X11 commands to the X server.  For the most part, VGL \ndoes not interfere with the delivery of OpenGL commands to the GPU, \neither.  VGL merely forces the OpenGL commands to be delivered to a GPU \nthat is attached to a different X server (the &ldquo;3D X server&rdquo;) \nthan the X server to which the 2D drawing commands are delivered (the \n&ldquo;2D X server.&rdquo;)  Once the OpenGL rendering has been \nredirected to a Pbuffer, everything (including esoteric OpenGL \nextensions, fragment/vertex programs, etc.) should &ldquo;just \nwork.&rdquo;  If an application runs locally on a 3D server/workstation, \nthen that same application should run remotely from that same machine \nusing VirtualGL.</p>\n\n<p>VirtualGL has two built-in &ldquo;image transports&rdquo; that can be \nused to send rendered 3D images to the client machine:</p>\n\n<p><a name=\"VGL_Transport\"></a></p>\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">1. VGL Transport</dt>\n    <dd class=\"Description-1 Description\">\n        The VGL Transport is most often used whenever the 2D X server (the X \n        server used to draw the application&rsquo;s GUI and transmit keyboard \n        and mouse events back to the application server) is located across the \n        network from the application server, for instance if the 2D X server is \n        running on the user&rsquo;s desktop machine.  VirtualGL uses its own \n        protocol on a dedicated TCP socket to send the rendered 3D images to the \n        client machine, and the VirtualGL Client application decodes the images \n        and composites them into the appropriate X window.  The VGL Transport \n        can either deliver uncompressed images (RGB-encoded), or it can compress \n        images in real time using a high-speed JPEG codec.  It also supports the \n        delivery of stereo image pairs, which can be reconstructed into a stereo \n        image by the VirtualGL Client.\n    </dd>\n</dl>\n\n<a name=\"fig003001\"></a>\n<div class=\"figure\">\n<p class=\"caption\">Figure 3.1: The VGL Transport with a Remote 2D X Server</p>\n<img src=\"vgltransport.png\" alt=\"vgltransport\" class=\"figure\" id=\"imgid_5\" name=\"imgid_5\"/>\n</div>\n\n<p><a name=\"X11_Transport\"></a></p>\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">2. X11 Transport</dt>\n    <dd class=\"Description-1 Description\">\n        The X11 Transport simply draws the rendered 3D images into the \n        appropriate X window using <code>XPutImage()</code> and similar \n        X-Windows commands.  This is most useful in conjunction with an &ldquo;X \n        proxy&rdquo;, which can be one of any number of Unix remote display \n        applications, such as VNC.  These X proxies are essentially \n        &ldquo;virtual&rdquo; X servers.  They appear to the application as a \n        normal X server, but they perform X11 rendering to a virtual framebuffer \n        in main memory rather than to a real framebuffer (video memory.)  This \n        allows the X proxy to send only images to the client machine rather than \n        fine-grained X-Windows rendering commands.  When using the X11 \n        Transport, VirtualGL does not perform any image compression or encoding \n        itself.  It instead relies upon an X proxy to encode and deliver the \n        images to the client(s).  Since the use of an X proxy eliminates the \n        need to send X-Windows commands over the network, this is the best means \n        of using VirtualGL over high-latency or low-bandwidth networks.\n    </dd>\n</dl>\n\n<a name=\"fig003002\"></a>\n<div class=\"figure\">\n<p class=\"caption\">Figure 3.2: The X11 Transport with an X Proxy</p>\n<img src=\"x11transport.png\" alt=\"x11transport\" class=\"figure\" id=\"imgid_6\" name=\"imgid_6\"/>\n</div>\n\n<p>VirtualGL also provides an API that can be used to develop custom image \ntransport plugins.</p>\n\n<p><br /></p>\n\n<hr class=\"break\" />\n\n\n\n<h1 id=\"hd004\"><a name=\"file004\"></a>4&nbsp;System Requirements</h1>\n\n\n<h2 id=\"hd004001\">4.1&nbsp;Linux/x86 and Other x86 Un*x Operating Systems</h2>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <thead class=\"standard\">\n  <tr class=\"head \">\n    <th class=\"head standard\"></th>\n    <th class=\"head standard\">Server (x86)</th>\n    <th class=\"head standard\">Server (x86-64)</th>\n    <th class=\"head standard\">Client</th>\n  </tr>\n  </thead>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Recommended CPU</td>\n    <td class=\"standard\"><ul class=\"Itemize\"><li class=\"Itemize-0\">\n    For optimal performance, the CPU should support SSE2 extensions.\n</li>\n<li class=\"Itemize-0\">\n    Dual processors or dual cores recommended\n</li></ul></td>\n    <td class=\"standard\">Dual processors or dual cores recommended</td>\n    <td class=\"standard\">For optimal performance, the CPU should support SSE2 extensions.</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Graphics</td>\n    <td class=\"standard\" colspan=\"2\">AMD or nVidia GPU <ul class=\"Itemize\"><li class=\"Itemize-0\">\n    For optimal performance, particularly with multiple simultaneous users, \n    a professional-grade GPU such as the AMD FirePro or nVidia Quadro is \n    recommended.\n</li>\n<li class=\"Itemize-0\">\n    Install the AMD or nVidia proprietary drivers.  Open source drivers for \n    these GPUs do not generally provide full 3D acceleration, and some of \n    those drivers do not provide Pbuffer support.\n</li></ul></td>\n    <td class=\"standard\">Any graphics adapter with decent 2D performance <ul class=\"Itemize\"><li class=\"Itemize-0\">\n    If using a 3D graphics adapter, install the vendor drivers for that 3D \n    graphics adapter.\n</li></ul></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">O/S</td>\n    <td class=\"standard\" colspan=\"3\">VirtualGL should work with a variety of Linux distributions, <span class=\"remote\"><a href=\"http://www.freebsd.org\" class=\"remote\">FreeBSD</a></span><a name=\"idx006\"></a>, and <span class=\"remote\"><a href=\"http://www.oracle.com/us/products/servers-storage/solaris\" class=\"remote\">Solaris</a></span><a name=\"idx007\"></a>, but currently-supported versions of <span class=\"remote\"><a href=\"http://www.redhat.com/products/enterprise-linux/\" class=\"remote\">Red Hat Enterprise Linux</a></span><a name=\"idx008\"></a> (and its work-alikes, including <span class=\"remote\"><a href=\"http://www.centos.org\" class=\"remote\">CentOS</a></span><a name=\"idx009\"></a>, <span class=\"remote\"><a href=\"http://www.oracle.com/us/technologies/linux\" class=\"remote\">Oracle Linux</a></span><a name=\"idx0010\"></a>, and <span class=\"remote\"><a href=\"https://www.scientificlinux.org\" class=\"remote\">Scientific Linux</a></span><a name=\"idx0011\"></a>), <span class=\"remote\"><a href=\"http://www.ubuntu.com\" class=\"remote\">Ubuntu</a></span><a name=\"idx0012\"></a> LTS, and <span class=\"remote\"><a href=\"http://www.suse.com\" class=\"remote\">SuSE</a></span><a name=\"idx0013\"></a> Linux Enterprise tend to receive the most attention from the VirtualGL community.</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Other Software</td>\n    <td class=\"standard\" colspan=\"3\">X server configured to export True Color (24-bit or 32-bit) visuals</td>\n  </tr>\n</table>\n</div>\n\n\n\n\n<h2 id=\"hd004002\">4.2&nbsp;Mac/x86</h2>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <thead class=\"standard\">\n  <tr class=\"head \">\n    <th class=\"head standard\"></th>\n    <th class=\"head standard\">Client</th>\n  </tr>\n  </thead>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Recommended CPU</td>\n    <td class=\"standard\">Any Intel-based Mac</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">O/S</td>\n    <td class=\"standard\">OS X 10.5 (&ldquo;Leopard&rdquo;) or later</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Other Software</td>\n    <td class=\"standard\"><ul class=\"Itemize\"><li class=\"Itemize-0\">\n    <em>VGL Transport Only</em>: Mac X11 application (in the &ldquo;Optional \n    Installs&rdquo; package on the OS X 10.7 and earlier install discs) or \n    <span class=\"remote\"><a href=\"http://xquartz.macosforge.org\" class=\"remote\">XQuartz</a></span><a name=\"idx0014\"></a>\n</li></ul></td>\n  </tr>\n</table>\n</div>\n\n\n\n\n<h2 id=\"hd004003\">4.3&nbsp;Windows</h2>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <thead class=\"standard\">\n  <tr class=\"head \">\n    <th class=\"head standard\"></th>\n    <th class=\"head standard\">Client</th>\n  </tr>\n  </thead>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Recommended CPU</td>\n    <td class=\"standard\">For optimal performance, the CPU should support SSE2 extensions.</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Graphics</td>\n    <td class=\"standard\">Any graphics adapter with decent 2D performance</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Other Software</td>\n    <td class=\"standard\"><ul class=\"Itemize\"><li class=\"Itemize-0\">\n    <em>VGL Transport Only</em>: \n    <span class=\"remote\"><a href=\"http://x.cygwin.com\" class=\"remote\">Cygwin/X</a></span><a name=\"idx0015\"></a>\n</li>\n<li class=\"Itemize-0\">\n    Client display must have a 24-bit or 32-bit color depth (True Color.)\n</li></ul></td>\n  </tr>\n</table>\n</div>\n\n\n\n\n<h2 id=\"hd004004\">4.4&nbsp;Additional Requirements for Stereographic Rendering</h2>\n\n<p><a name=\"Stereo_Requirements\"></a></p>\n\n<div class=\"important\"><p class=\"important\">\nThe client requirements do not apply to anaglyphic stereo.  See Chapter <a href=\"#Advanced_OpenGL\" class=\"ref\">16</a> for more details.\n</p></div>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <thead class=\"standard\">\n  <tr class=\"head \">\n    <th class=\"head standard\"></th>\n    <th class=\"head standard\">Server</th>\n    <th class=\"head standard\">Client</th>\n  </tr>\n  </thead>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Linux/Unix</td>\n    <td class=\"standard\"><ul class=\"Itemize\"><li class=\"Itemize-0\">\n    AMD or nVidia GPU that supports stereo (examples: AMD FirePro W Series, \n    nVidia Quadro)\n</li>\n<li class=\"Itemize-0\">\n    The 3D X server should be configured to export stereo visuals.\n</li></ul></td>\n    <td class=\"standard\"><ul class=\"Itemize\"><li class=\"Itemize-0\">\n    GPU that supports stereo\n</li>\n<li class=\"Itemize-0\">\n    The 2D X server should be configured to export stereo visuals.\n</li></ul></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Mac/x86</td>\n    <td class=\"standard\">N/A</td>\n    <td class=\"standard\">GPU that supports stereo (example: nVidia Quadro)</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Windows</td>\n    <td class=\"standard\">N/A</td>\n    <td class=\"standard\">This version of VirtualGL does not support remote quad-buffered stereo with Windows clients.</td>\n  </tr>\n</table>\n</div>\n\n\n\n\n<h2 id=\"hd004005\">4.5&nbsp;Additional Requirements for Transparent Overlays</h2>\n\n<p><a name=\"Overlay_Requirements\"></a></p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <thead class=\"standard\">\n  <tr class=\"head \">\n    <th class=\"head standard\"></th>\n    <th class=\"head standard\">Client</th>\n  </tr>\n  </thead>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Linux/Unix</td>\n    <td class=\"standard\" rowspan=\"2\">GPU that supports transparent overlays.  The 2D X server should be configured to export overlay visuals.</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Mac/x86</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Windows</td>\n    <td class=\"standard\">This version of VirtualGL does not support transparent overlays with Windows clients.</td>\n  </tr>\n</table>\n</div>\n\n\n<p><br /></p>\n\n<hr class=\"break\" />\n\n\n\n<h1 id=\"hd005\"><a name=\"file005\"></a>5&nbsp;Obtaining and Installing VirtualGL</h1>\n\n<div class=\"important\"><p class=\"important\">\nVirtualGL must be installed on any machine that will act as a VirtualGL server or as a client for the <a href=\"#VGL_Transport\">VGL Transport</a><a name=\"idx0016\"></a>. It is not necessary to install VirtualGL on the client machine if using VNC or another type of X proxy.\n</p></div>\n\n\n<h2 id=\"hd005001\">5.1&nbsp;Installing VirtualGL on Linux</h2>\n\n<ol class=\"Ordered numeric\">\n    <li class=\"Ordered-1 Ordered\" value=\"1\">\n        Download the appropriate VirtualGL binary package(s) for your system \n        from the \n        <span class=\"remote\"><a href=\"http://sourceforge.net/projects/virtualgl/files\" class=\"remote\">Files \n        area</a></span><a name=\"idx0017\"></a> of the \n        <span class=\"remote\"><a href=\"http://sourceforge.net/projects/virtualgl\" class=\"remote\">VirtualGL \n        SourceForge project page</a></span><a name=\"idx0018\"></a>. Packages are \n        provided for RPM-based and Debian-based Linux distributions that contain \n        GLIBC 2.5 or later (including \n        <span class=\"remote\"><a href=\"http://fedoraproject.org\" class=\"remote\">Fedora</a></span><a name=\"idx0019\"></a> \n        6 or later, \n        <span class=\"remote\"><a href=\"http://www.redhat.com/products/enterprise-linux\" class=\"remote\">Red \n        Hat Enterprise \n        Linux</a></span><a name=\"idx0020\"></a>/<span class=\"remote\"><a href=\"http://www.centos.org/\" class=\"remote\">CentOS</a></span><a name=\"idx0021\"></a> \n        5 or later, \n        <span class=\"remote\"><a href=\"http://www.suse.com\" class=\"remote\">SuSE</a></span><a name=\"idx0022\"></a> \n        Linux \n        Enterprise/<span class=\"remote\"><a href=\"http://www.opensuse.org\" class=\"remote\">openSUSE</a></span><a name=\"idx0023\"></a> \n        11 or later, and \n        <span class=\"remote\"><a href=\"http://www.ubuntu.com\" class=\"remote\">Ubuntu</a></span><a name=\"idx0024\"></a> \n        8.04 or later.) <br />\n        <div class=\"important\"><p class=\"important\">\n        If you want to run both 32-bit and 64-bit OpenGL applications using VirtualGL on 64-bit Linux systems, then you will need to install both the i386 and x86_64 VirtualGL RPMs or both the &ldquo;virtualgl&rdquo; and &ldquo;virtualgl32&rdquo; amd64 DEBs.  (The virtualgl32 DEB is a supplementary package that contains only the 32-bit server components.)\n        </p></div>\n    </li>\n    <li class=\"Ordered-1 Ordered\" value=\"2\">\n        cd to the directory where you downloaded the binary package(s), and \n        issue the following commands as root:\n        <dl class=\"Description\">\n            <dt class=\"Description-3 Description\">RPM-based systems using YUM</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\nrpm&nbsp;-e&nbsp;VirtualGL&nbsp;--allmatches\nyum&nbsp;install&nbsp;VirtualGL*.rpm\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">RPM-based systems using DNF</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\nrpm&nbsp;-e&nbsp;VirtualGL&nbsp;--allmatches\ndnf&nbsp;install&nbsp;VirtualGL*.rpm\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">RPM-based systems using YaST2</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\nrpm&nbsp;-e&nbsp;VirtualGL&nbsp;--allmatches\nyast2&nbsp;--install&nbsp;VirtualGL*.rpm\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">Other RPM-based systems (dependencies will not be installed automatically)</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\nrpm&nbsp;-e&nbsp;VirtualGL&nbsp;--allmatches\nrpm&nbsp;-i&nbsp;VirtualGL*.rpm\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">Debian-based systems (dependencies will not be installed automatically)</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\ndpkg&nbsp;-i&nbsp;virtualgl*.deb\n</pre>\n\n            </dd>\n        </dl>\n    </li>\n</ol>\n\n\n<h3 id=\"hd005001001\">5.1.1&nbsp;Installing a 32-bit VirtualGL Package on x86-64 Linux Distributions</h3>\n\n<p>In order to run 32-bit OpenGL applications in VirtualGL, it is necessary \nto install the 32-bit VirtualGL server components, which depend on a few \n32-bit system libraries.  Recent x86-64 Linux distributions do not \ninclude 32-bit libraries by default, so it will be necessary to perform \na few additional steps prior to installing a 32-bit VirtualGL package on \nsome of those distributions.</p>\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Red Hat Enterprise Linux 6+ (and work-alikes), Recent Fedora Releases, SuSE/openSUSE</dt>\n    <dd class=\"Description-1 Description\">\n        <br class=\"itempara\" />No additional steps are necessary. <code>yum&nbsp;install</code> / \n        <code>dnf&nbsp;install</code> / <code>yast2&nbsp;--install</code> takes \n        care of all of the dependencies for both the 64-bit and 32-bit RPMs.\n    </dd>\n    <dt class=\"Description-1 Description\">Ubuntu 12 and later</dt>\n    <dd class=\"Description-1 Description\">\n        <br class=\"itempara\" />Run the following command as root prior to installing the virtualgl32 \n        package:\n<pre class=\"verbatim\">\napt-get&nbsp;install&nbsp;libxv1:i386&nbsp;libglu1-mesa:i386\n</pre>\n\n    </dd>\n</dl>\n\n\n\n<h2 id=\"hd005002\">5.2&nbsp;Installing the VirtualGL Client on OS X</h2>\n\n<ol class=\"Ordered numeric\">\n    <li class=\"Ordered-1 Ordered\">\n        Download the VirtualGL Mac disk image \n        (<code>VirtualGL-</code><em><code>{version}</code></em><code>.dmg</code>) \n        from the \n        <span class=\"remote\"><a href=\"http://sourceforge.net/projects/virtualgl/files\" class=\"remote\">Files \n        area</a></span><a name=\"idx0025\"></a> of the \n        <span class=\"remote\"><a href=\"http://sourceforge.net/projects/virtualgl\" class=\"remote\">VirtualGL \n        SourceForge project page</a></span><a name=\"idx0026\"></a>.\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        Open the disk image, then open \n        <code>VirtualGL-</code><em><code>{version}</code></em><code>.pkg</code> \n        inside the disk image.  Follow the instructions to install the Mac \n        client.\n    </li>\n</ol>\n\n\n\n<h2 id=\"hd005003\">5.3&nbsp;Installing the VirtualGL Client on Windows (Cygwin)</h2>\n\n<p>Refer to \n<span class=\"remote\"><a href=\"http://www.virtualgl.org/Documentation/Cygwin\" class=\"remote\">http://www.virtualgl.org/Documentation/Cygwin</a></span><a name=\"idx0027\"></a>.</p>\n\n\n\n<h2 id=\"hd005004\">5.4&nbsp;Installing VirtualGL from Source</h2>\n\n<p>If you are using a platform for which there is not a pre-built VirtualGL \nbinary package available, then download the VirtualGL source tarball \n(<code>VirtualGL-</code><em><code>{version}</code></em><code>.tar.gz</code>) \nfrom the \n<span class=\"remote\"><a href=\"http://sourceforge.net/projects/virtualgl/files\" class=\"remote\">Files \narea</a></span><a name=\"idx0028\"></a> of the \n<span class=\"remote\"><a href=\"http://sourceforge.net/projects/virtualgl\" class=\"remote\">VirtualGL \nSourceForge project page</a></span><a name=\"idx0029\"></a>, uncompress \nit, <code>cd&nbsp;VirtualGL-</code><em><code>{version}</code></em>, and \nread the contents of <code>BUILDING.txt</code> for further instructions \non how to build and install VirtualGL from source.</p>\n\n\n\n<h2 id=\"hd005005\">5.5&nbsp;Uninstalling VirtualGL</h2>\n\n\n<h3 id=\"hd005005001\">Linux</h3>\n\n<p>As root, issue one of the following commands:</p>\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">RPM-based systems</dt>\n    <dd class=\"Description-1 Description\">\n<pre class=\"verbatim\">\nrpm&nbsp;-e&nbsp;VirtualGL\n</pre>\n\n        <div class=\"important\"><p class=\"important\">\n        You may need to add <code>--all-matches</code> to the RPM command line if you have installed both the 32-bit and 64-bit VirtualGL RPMs.\n        </p></div>\n    </dd>\n    <dt class=\"Description-1 Description\">Debian-based systems</dt>\n    <dd class=\"Description-1 Description\">\n<pre class=\"verbatim\">\ndpkg&nbsp;-r&nbsp;virtualgl\n</pre>\n\n        If you have also installed the 32-bit supplementary package:\n<pre class=\"verbatim\">\ndpkg&nbsp;-r&nbsp;virtualgl32\n</pre>\n\n    </dd>\n</dl>\n\n\n\n<h3 id=\"hd005005002\">OS X</h3>\n\n<p>Use the &ldquo;Uninstall VirtualGL&rdquo; application provided in the \nVirtualGL disk image, or issue the following command from the Terminal:</p>\n\n<pre class=\"verbatim\">\nsudo&nbsp;/opt/VirtualGL/bin/uninstall\n</pre>\n\n\n\n<h3 id=\"hd005005003\">Windows (Cygwin)</h3>\n\n<p>Refer to \n<span class=\"remote\"><a href=\"http://www.virtualgl.org/Documentation/Cygwin\" class=\"remote\">http://www.virtualgl.org/Documentation/Cygwin</a></span><a name=\"idx0030\"></a>.</p>\n\n<p><br /></p>\n\n<hr class=\"break\" />\n\n\n\n<h1 id=\"hd006\"><a name=\"file006\"></a>6&nbsp;Configuring a Linux or Unix Machine as a VirtualGL Server</h1>\n\n<p><a name=\"Unix_Config\"></a></p>\n\n\n<h2 id=\"hd006001\">6.1&nbsp;Granting Access to the 3D X Server</h2>\n\n<p>VirtualGL requires access to a GPU in the application server so that it \ncan create off-screen pixel buffers (Pbuffers) and redirect the 3D \nrendering from X windows into these Pbuffers.  Unfortunately, accessing \na GPU on Linux and Unix systems requires going through an X server.  On \nsuch systems, the only way to share the application server&rsquo;s \nGPU(s) among multiple users is to grant those users access to the 3D X \nserver (the X server attached to the GPU(s).  Refer to the figures in \nChapter <a href=\"#Overview\" class=\"ref\">3</a>.)</p>\n\n<p>It is important to understand the security risks associated with this.  \nOnce a user has access to the 3D X server, there is nothing that would \nprevent the user from logging keystrokes or reading back images from \nthat X server. Using <code>xauth</code>, one can obtain \n&ldquo;untrusted&rdquo; X authentication keys that prevent such \nexploits, but unfortunately, those untrusted keys also disallow access \nto the 3D hardware.  Thus, it is necessary to grant full, trusted access \nto the 3D X server for any users that will need to run VirtualGL.  \nUnless you fully trust the users to whom you are granting this access, \nthen you should avoid logging in locally to the 3D X server \n(particularly as root) unless absolutely necessary.</p>\n\n<p>This section will explain how to configure a VirtualGL server such that \nselected users can run VirtualGL, even if the server is sitting at the \nlogin prompt.</p>\n\n<ol class=\"Ordered numeric\">\n    <li class=\"Ordered-1 Ordered\">\n        Shut down the display manager:\n        <dl class=\"Description\">\n            <dt class=\"Description-3 Description\">Ubuntu Linux servers running GDM</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\n/etc/init.d/gdm&nbsp;stop\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">Ubuntu Linux servers running LightDM</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\nservice&nbsp;lightdm&nbsp;stop\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">SuSE Linux servers</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\n/etc/init.d/xdm&nbsp;stop\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">Red Hat/Fedora Linux servers with SysV init</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\ninit&nbsp;3\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">Red Hat/Fedora Linux servers with systemd</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\nsystemctl&nbsp;stop&nbsp;gdm.service\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">Linux servers running MDM</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\n/etc/init.d/mdm&nbsp;stop\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">Solaris 10 servers running GDM</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\nsvcadm&nbsp;disable&nbsp;gdm2-login\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">Solaris 11/OpenSolaris servers running GDM</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\nsvcadm&nbsp;disable&nbsp;gdm\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">Solaris servers running dtlogin</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\n/etc/init.d/dtlogin&nbsp;stop\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">FreeBSD servers running GDM</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\n/usr/local/etc/rc.d/gdm&nbsp;stop\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">FreeBSD servers running KDM</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\n/usr/local/kde4/etc/rc.d/kdm4&nbsp;stop\n</pre>\n\n            </dd>\n        </dl>\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        Log in as root from the text console (or remotely using SSH.)\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        Run\n<pre class=\"verbatim\">\n/opt/VirtualGL/bin/vglserver_config\n</pre>\n\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        Select option 1 \n        (<code>Configure&nbsp;server&nbsp;for&nbsp;use&nbsp;with&nbsp;VirtualGL&nbsp;in&nbsp;GLX&nbsp;mode</code>.)\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n\n<pre class=\"verbatim\">\nRestrict&nbsp;3D&nbsp;X&nbsp;server&nbsp;access&nbsp;to&nbsp;vglusers&nbsp;group&nbsp;(recommended)?\n[Y/n]\n</pre>\n\n        <dl class=\"Description\">\n            <dt class=\"Description-3 Description\">Yes</dt>\n            <dd class=\"Description-3 Description\">\n                Only users in the <code>vglusers</code> group can use VirtualGL (the \n                configuration script will create the <code>vglusers</code> group if it \n                doesn&rsquo;t already exist.)  This is the most secure option, since it \n                prevents any users outside of the <code>vglusers</code> group from \n                accessing (and thus exploiting) the 3D X server.\n            </dd>\n            <dt class=\"Description-3 Description\">No</dt>\n            <dd class=\"Description-3 Description\">\n                VirtualGL can be used by any user that successfully logs into the \n                VirtualGL server.  The 3D X server can also be accessed (and potentially \n                exploited) by any user who is logged into the VirtualGL server.  If you \n                choose this option, it is recommended that you also disable the XTEST \n                extension (see below.)\n            </dd>\n        </dl>\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n\n<pre class=\"verbatim\">\nRestrict&nbsp;framebuffer&nbsp;device&nbsp;access&nbsp;to&nbsp;vglusers&nbsp;group&nbsp;(recommended)?\n[Y/n]\n</pre>\n\n        <dl class=\"Description\">\n            <dt class=\"Description-3 Description\">Yes</dt>\n            <dd class=\"Description-3 Description\">\n                Only users in the <code>vglusers</code> group can run OpenGL \n                applications on the VirtualGL server (the configuration script will \n                create the <code>vglusers</code> group if it doesn&rsquo;t already \n                exist.)  This limits the possibility that an unauthorized user could \n                snoop the 3D framebuffer device(s) and thus see (or alter) the output of \n                a 3D application that is being used with VirtualGL.\n            </dd>\n            <dt class=\"Description-3 Description\">No</dt>\n            <dd class=\"Description-3 Description\">\n                Any authenticated user can run OpenGL applications on the VirtualGL \n                server.  If it is necessary for users outside of the \n                <code>vglusers</code> group to log in locally to this server and run \n                OpenGL applications, then this option must be selected.\n            </dd>\n        </dl>\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n\n<pre class=\"verbatim\">\nDisable&nbsp;XTEST&nbsp;extension&nbsp;(recommended)?\n[Y/n]\n</pre>\n\n        <dl class=\"Description\">\n            <dt class=\"Description-3 Description\">Yes</dt>\n            <dd class=\"Description-3 Description\">\n                Disabling XTEST will not prevent a user from logging keystrokes or \n                reading images from the 3D X server, but if a user has access to the 3D \n                X server, disabling XTEST will prevent them from inserting keystrokes or \n                mouse events and thus hijacking local X sessions on that X server.\n                <div class=\"important\"><p class=\"important\">\n                If you are using GDM 2.14 through 2.20, it will be necessary to run <code>gdmsetup</code> and manually add an argument of <code>-tst</code> to the X server command line to disable XTEST for the first time.  After this, <code>vglserver_config</code> should be able to disable and enable XTEST properly.\n                </p></div>\n                <div class=\"important\"><p class=\"important\">\n                GDM 2.22 and later no longer provide a means of editing the X server command line, so disabling XTEST will not work.  The only known alternative as of this writing is to use a different display manager.\n                </p></div>\n            </dd>\n            <dt class=\"Description-3 Description\">No</dt>\n            <dd class=\"Description-3 Description\">\n                <code>x11vnc</code> and <code>x0vncserver</code> both require XTEST, so \n                if you need to attach a VNC server to the 3D X server, then it is \n                necessary to answer &ldquo;No&rdquo; (and thus leave XTEST enabled.)\n            </dd>\n        </dl>\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        If you chose to restrict X server or framebuffer device access to the \n        <code>vglusers</code> group, then edit <code>/etc/group</code> and add \n        <code>root</code> to the <code>vglusers</code> group.  If you choose, \n        you can also add additional users to the group at this time.  Note that \n        any user you add to <code>vglusers</code>\tmust log out and back in again \n        before their new group permissions will take effect.\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        Restart the display manager:\n        <dl class=\"Description\">\n            <dt class=\"Description-3 Description\">Ubuntu Linux servers running GDM</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\n/etc/init.d/gdm&nbsp;start\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">Ubuntu Linux servers running LightDM</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\nservice&nbsp;lightdm&nbsp;start\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">SuSE Linux servers</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\n/etc/init.d/xdm&nbsp;start\n</pre>\n\n        Red Hat/Fedora Linux servers with SysV init:: \n<pre class=\"verbatim\">\ninit&nbsp;5\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">Red Hat/Fedora Linux servers with systemd</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\nsystemctl&nbsp;start&nbsp;gdm.service\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">Linux servers running MDM</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\n/etc/init.d/mdm&nbsp;start\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">Solaris 10 servers running GDM</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\nsvcadm&nbsp;enable&nbsp;gdm2-login\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">Solaris 11/OpenSolaris servers running GDM</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\nsvcadm&nbsp;enable&nbsp;gdm\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">Solaris servers running dtlogin</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\n/etc/init.d/dtlogin&nbsp;start\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">FreeBSD servers running GDM</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\n/usr/local/etc/rc.d/gdm&nbsp;start\n</pre>\n\n            </dd>\n            <dt class=\"Description-3 Description\">FreeBSD servers running KDM</dt>\n            <dd class=\"Description-3 Description\">\n<pre class=\"verbatim\">\n/usr/local/kde4/etc/rc.d/kdm4&nbsp;start\n</pre>\n\n            </dd>\n        </dl>\n    </li>\n</ol>\n\n\n<h3 id=\"hd006001001\">Sanity Check</h3>\n\n<p>To verify that the application server is ready to run VirtualGL, log out \nof the server, log back into the server using SSH, and execute the \nfollowing commands in the SSH session:</p>\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">If you restricted 3D X server access to <code>vglusers</code></dt>\n    <dd class=\"Description-1 Description\">\n<pre class=\"verbatim\">\nxauth&nbsp;merge&nbsp;/etc/opt/VirtualGL/vgl_xauth_key\nxdpyinfo&nbsp;-display&nbsp;:0\n/opt/VirtualGL/bin/glxinfo&nbsp;-display&nbsp;:0&nbsp;-c\n</pre>\n\n        <div class=\"important\"><p class=\"important\">\n        NOTE: <code>xauth</code> and <code>xdpyinfo</code> are in <code>/usr/openwin/bin</code> on Solaris systems.\n        </p></div>\n    </dd>\n    <dt class=\"Description-1 Description\">If you did not restrict 3D X server access</dt>\n    <dd class=\"Description-1 Description\">\n<pre class=\"verbatim\">\nxdpyinfo&nbsp;-display&nbsp;:0\n/opt/VirtualGL/bin/glxinfo&nbsp;-display&nbsp;:0&nbsp;-c\n</pre>\n\n    </dd>\n</dl>\n\n<p>Both commands should output a list of visuals and should complete with \nno errors.  If you chose to disable the XTEST extension, then check the \noutput of <code>xdpyinfo</code> to verify that <code>XTEST</code> does \nnot show up in the list of extensions.</p>\n\n<p>You should also examine the output of <code>glxinfo</code> to ensure \nthat at least one of the visuals is 24-bit or 32-bit TrueColor and has \nPbuffer support (the latter is indicated by a &ldquo;P&rdquo; in the \nlast column.)  Example:</p>\n\n<pre class=\"verbatim\">\n&nbsp;&nbsp;&nbsp;&nbsp;visual&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;bf&nbsp;lv&nbsp;rg&nbsp;d&nbsp;st&nbsp;&nbsp;colorbuffer&nbsp;&nbsp;ax&nbsp;dp&nbsp;st&nbsp;accumbuffer&nbsp;&nbsp;ms&nbsp;&nbsp;cav&nbsp;&nbsp;drw\n&nbsp;&nbsp;id&nbsp;dep&nbsp;cl&nbsp;sp&nbsp;&nbsp;sz&nbsp;l&nbsp;&nbsp;ci&nbsp;b&nbsp;ro&nbsp;&nbsp;r&nbsp;&nbsp;g&nbsp;&nbsp;b&nbsp;&nbsp;a&nbsp;F&nbsp;bf&nbsp;th&nbsp;cl&nbsp;&nbsp;r&nbsp;&nbsp;g&nbsp;&nbsp;b&nbsp;&nbsp;a&nbsp;ns&nbsp;b&nbsp;eat&nbsp;&nbsp;typ\n------------------------------------------------------------------------------\n0x151&nbsp;24&nbsp;tc&nbsp;&nbsp;0&nbsp;&nbsp;32&nbsp;&nbsp;0&nbsp;r&nbsp;&nbsp;y&nbsp;&nbsp;.&nbsp;&nbsp;8&nbsp;&nbsp;8&nbsp;&nbsp;8&nbsp;&nbsp;0&nbsp;.&nbsp;&nbsp;4&nbsp;24&nbsp;&nbsp;8&nbsp;16&nbsp;16&nbsp;16&nbsp;16&nbsp;&nbsp;0&nbsp;0&nbsp;None&nbsp;PXW\n</pre>\n\n<p>If none of the visuals has Pbuffer support, then this is most likely \nbecause there is no 3D acceleration, which is most likely because the \ncorrect 3D drivers are not installed (or are misconfigured.)  Lack of 3D \nacceleration is also typically indicated by the word &ldquo;Mesa&rdquo; \nin the client GLX vendor string and/or the OpenGL vendor string, and the \nwords &ldquo;Software Rasterizer&rdquo; in the OpenGL renderer string.</p>\n\n\n\n<h2 id=\"hd006002\">6.2&nbsp;Using VirtualGL with Multiple GPUs</h2>\n\n<p>VirtualGL can redirect the OpenGL commands from a 3D application to any \nGPU in the server machine.  In order for this to work, however, all of \nthe GPUs must be attached to different screens on the same X server or \nto different X servers.  Attaching them to different screens is the \neasiest and most common approach, and this allows the GPUs to be \nindividually addressed by setting <code>VGL_DISPLAY</code> to (or \ninvoking <code>vglrun&nbsp;-d</code> with) <code>:0.0</code>, \n<code>:0.1</code>, <code>:0.2</code>, etc.  If the GPUs are attached to \ndifferent X servers, then they can be individually addressed by setting \n<code>VGL_DISPLAY</code> to (or invoking <code>vglrun&nbsp;-d</code> \nwith) <code>:0.0</code>, <code>:1.0</code>, <code>:2.0</code>, etc.</p>\n\n\n\n<h2 id=\"hd006003\">6.3&nbsp;SSH Server Configuration</h2>\n\n<p>The application server&rsquo;s SSH daemon should have the \n<code>X11Forwarding</code> option enabled and the <code>UseLogin</code> \noption disabled.  This is configured in <code>sshd_config</code>, which \nis usually located under <code>/etc/ssh</code>.</p>\n\n\n\n<h2 id=\"hd006004\">6.4&nbsp;Un-Configuring the Server</h2>\n\n<p>You can use the <code>vglserver_config</code> script to restore the \nsecurity settings that were in place before VirtualGL was installed.  \nOption 2 \n(<code>Unconfigure&nbsp;server&nbsp;for&nbsp;use&nbsp;with&nbsp;VirtualGL&nbsp;in&nbsp;GLX&nbsp;mode</code>) \nwill remove any shared access to the 3D X server and thus prevent \nVirtualGL from accessing the 3D hardware in that manner.  Additionally, \nthis option will re-enable the XTEST extension on the 3D X server and \nwill restore the framebuffer device permissions to their default (by \ndefault, only root or the user that is currently logged into the \napplication server locally can access the framebuffer devices.)</p>\n\n<div class=\"important\"><p class=\"important\">\nNOTE: Unconfiguring the server does not remove the <code>vglusers</code> group.\n</p></div>\n\n<p>After selecting Option 2, you must restart the display manager before \nthe changes will take effect.</p>\n\n<p><br /></p>\n\n<hr class=\"break\" />\n\n\n\n<h1 id=\"hd007\"><a name=\"file007\"></a>7&nbsp;Configuring a Windows Machine as a VGL Transport Client</h1>\n\n<p>VirtualGL has the ability to take advantage of the MIT-SHM extension in \nCygwin/X to accelerate image drawing on Windows.  This can significantly \nimprove the overall performance of the VirtualGL pipeline when running \nover a local-area network.</p>\n\n<p>To enable MIT-SHM in Cygwin/X:</p>\n\n<ol class=\"Ordered numeric\">\n    <li class=\"Ordered-1 Ordered\">\n        Open a Cygwin Bash shell\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        Run <code>cygserver-config</code>\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        Answer &ldquo;yes&rdquo; when asked &ldquo;Do you want to install \n        cygserver as service?&rdquo;\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        From a Windows (not Cygwin) command prompt, run \n        <code>net&nbsp;start&nbsp;cygserver</code>\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        Add <code>server</code> to the <code>CYGWIN</code> system environment \n        variable (create this environment variable if it doesn&rsquo;t already \n        exist)\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        Start or re-start Cygwin/X\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        Run <code>xdpyinfo</code> and verify that <code>MIT-SHM</code> appears \n        in the list of  X extensions\n    </li>\n</ol>\n\n<p><br /></p>\n\n<hr class=\"break\" />\n\n\n\n<h1 id=\"hd008\"><a name=\"file008\"></a>8&nbsp;Using VirtualGL with the VGL Transport</h1>\n\n<p><a name=\"VGL_Transport_Usage\"></a></p>\n\n\n<h3 id=\"hd008000001\">Advantages of the VGL Transport</h3>\n\n<ul class=\"Itemize\">\n    <li class=\"Itemize-1 Itemize asterisk\">\n        Seamless windows; every application window appears as a separate window \n        on the user&rsquo;s desktop\n    </li>\n    <li class=\"Itemize-1 Itemize asterisk\">\n        Supports stereographic rendering (see requirements in Sections \n        <a href=\"#Stereo_Requirements\" class=\"ref\">4.4</a> and \n        <a href=\"#Overlay_Requirements\" class=\"ref\">4.5</a>)\n    </li>\n    <li class=\"Itemize-1 Itemize asterisk\">\n        Consumes less memory and CPU time on the server, since the 2D (X11) \n        rendering occurs on the client machine\n    </li>\n</ul>\n\n\n\n<h3 id=\"hd008000002\">Disadvantages of the VGL Transport</h3>\n\n<ul class=\"Itemize\">\n    <li class=\"Itemize-1 Itemize asterisk\">\n        The VGL Transport is designed to be used with remote X servers, and thus \n        it relies on the chatty remote X11 protocol to send the 2D elements of \n        the application&rsquo;s GUI to the user&rsquo;s desktop.  As a result, \n        the VGL Transport is not recommended for use on high-latency or \n        low-bandwidth networks\n    </li>\n    <li class=\"Itemize-1 Itemize asterisk\">\n        No collaboration features\n    </li>\n    <li class=\"Itemize-1 Itemize asterisk\">\n        The client is not stateless.  As with any remote X11 environment, if the \n        network connection drops, then the application will exit\n    </li>\n</ul>\n\n\n\n<h2 id=\"hd008001\">8.1&nbsp;VGL Transport with X11 Forwarding</h2>\n\n<p><a name=\"X11_Forwarding\"></a></p>\n\n<p>This mode is recommended for use only on secure local-area networks.  \nThe X11 traffic is encrypted, but the VGL Transport is left unencrypted \nto maximize performance.</p>\n\n\n<h3 id=\"hd008001001\">8.1.1&nbsp;Procedure</h3>\n\n<ol class=\"Ordered numeric\">\n    <li class=\"Ordered-1 Ordered\">\n        Start the X server if it isn&rsquo;t started already.<br /> <em>Mac \n        clients:</em> start the Mac X11 application or XQuartz.<br /> <em>Cygwin \n        clients:</em> start Cygwin/X.\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        Open a new terminal window.<br /> <em>Mac clients:</em> in the X11 \n        application, start a new xterm [Command-N] if one isn&rsquo;t already \n        started.<br /> <em>Cygwin clients:</em> start a new xterm if one \n        isn&rsquo;t already started (right-click on the Cygwin/X taskbar icon, \n        then select <em>Applications&ndash;&gt;xterm</em>.)\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        In the same terminal/xterm window, open a Secure Shell (SSH) session \n        into the VirtualGL server:\n<pre class=\"verbatim\">\n/opt/VirtualGL/bin/vglconnect&nbsp;{user}@{server}\n</pre>\n\n        Replace <em><code>{user}</code></em> with your username on the VirtualGL \n        server and <em><code>{server}</code></em> with the hostname or IP \n        address of that server.\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        In the SSH session, start a 3D application using VirtualGL:\n<pre class=\"verbatim\">\n/opt/VirtualGL/bin/vglrun&nbsp;[vglrun&nbsp;options]&nbsp;{application_executable_or_script}&nbsp;{arguments}\n</pre>\n\n        Consult Chapter <a href=\"#Advanced_Configuration\" class=\"ref\">19</a> for \n        more information on <code>vglrun</code> command-line options.\n    </li>\n</ol>\n\n\n\n<h2 id=\"hd008002\">8.2&nbsp;VGL Transport with a Direct X11 Connection</h2>\n\n<p><a name=\"Direct_X11_Connection\"></a></p>\n\n<p>As with the previous mode, this mode performs optimally on local-area \nnetworks.  However, it is less secure, since both the X11 traffic and \nthe VGL Transport are unencrypted.  This mode is primarily useful in \ngrid environments, in which you may not know ahead of time which server \nwill execute a VirtualGL job.  It is assumed that the &ldquo;submit \nhost&rdquo; (the machine into which you connect with SSH) and the \n&ldquo;execute hosts&rdquo; (the machines that will run VirtualGL jobs) \nshare the same home directories and reside in the same domain.</p>\n\n<div class=\"important\"><p class=\"important\">\nMost newer Linux and Unix distributions ship with default settings that do not allow TCP connections into the X server.  Such systems cannot be used as clients with this procedure unless they are reconfigured to allow X11 TCP connections.\n</p></div>\n\n\n<h3 id=\"hd008002001\">Procedure</h3>\n\n<p>The procedure for this mode is identical to the procedure for the \n<a href=\"#X11_Forwarding\">VGL Transport with X11 \nforwarding</a><a name=\"idx0031\"></a>, except that you should pass a \n<code>-x</code> argument to <code>vglconnect</code> when connecting to \nthe server:</p>\n\n<pre class=\"verbatim\">\n/opt/VirtualGL/bin/vglconnect&nbsp;-x&nbsp;{user}@{server}\n</pre>\n\n\n\n<h2 id=\"hd008003\">8.3&nbsp;VGL Transport with X11 Forwarding and SSH Tunneling</h2>\n\n<p><a name=\"SSH_Tunneling\"></a></p>\n\n<p>Both the VGL Transport and the X11 traffic are tunneled through SSH when \nusing this mode, and thus it provides a completely secure solution.  It \nis also useful when either the VirtualGL server or the client machine \nare behind restrictive firewalls and only SSH connections are allowed \nthrough.  Using SSH tunneling on wide-area networks should not affect \nperformance significantly.  However, using SSH tunneling on a local-area \nnetwork can reduce the end-to-end performance of the VGL Transport by \nanywhere from 20-40%.</p>\n\n\n<h3 id=\"hd008003001\">Procedure</h3>\n\n<p>The procedure for this mode is identical to the procedure for the \n<a href=\"#X11_Forwarding\">VGL Transport with X11 \nforwarding</a><a name=\"idx0032\"></a>, except that you should pass a \n<code>-s</code> argument to <code>vglconnect</code> when connecting to \nthe server:</p>\n\n<pre class=\"verbatim\">\n/opt/VirtualGL/bin/vglconnect&nbsp;-s&nbsp;{user}@{server}\n</pre>\n\n<p><code>vglconnect</code> will make two SSH connections into the server, \nthe first to find an open port on the server and the second to create \nthe SSH tunnel for the VGL Transport and open the secure shell.  If you \nare not using an SSH agent to create password-less logins, then this \nmode will require you to enter your password twice.</p>\n\n<p><code>vglconnect&nbsp;-s</code> can be used to create multi-layered SSH \ntunnels.  For instance, if the VirtualGL server is not directly \naccessible from the Internet, then you can run \n<code>vglconnect&nbsp;-s</code> on the client machine to connect to an \nSSH gateway server, then you can run <code>vglconnect&nbsp;-s</code> \nagain on the gateway server to connect to the VirtualGL server \n(application server.)  Both the X11 traffic and the VGL Transport will \nbe forwarded from the VirtualGL server through the gateway and to the \nclient.</p>\n\n<div class=\"figure\">\n<img src=\"sshtunnel.png\" alt=\"sshtunnel\" class=\"figure\" id=\"imgid_7\" name=\"imgid_7\"/>\n</div>\n\n\n\n<h2 id=\"hd008004\">8.4&nbsp;VGL Transport over Gigabit Networks</h2>\n\n<p>When using the VGL Transport over Gigabit Ethernet or faster networks, \nit may be desirable to disable image compression.  This can be \naccomplished by passing an argument of <code>-c&nbsp;rgb</code> to \n<code>vglrun</code> or setting the <code>VGL_COMPRESS</code> environment \nvariable to <code>rgb</code> on the VirtualGL server.  Disabling image \ncompression will reduce VirtualGL&rsquo;s server and client CPU usage by \n50% or more, but the tradeoff is that it will also increase \nVirtualGL&rsquo;s network usage by a factor of 10 or more.  Thus, \ndisabling image compression is not recommended unless you are using \nswitched Gigabit Ethernet (or faster) infrastructure and have plenty of \nbandwidth to spare.</p>\n\n\n\n<h2 id=\"hd008005\">8.5&nbsp;VGL Transport with XDMCP</h2>\n\n<div class=\"important\"><p class=\"important\">\nXDMCP is very insecure and is not recommended as a means of running VirtualGL, in general.  This section is provided mainly for completeness and should not be construed as an endorsement of XDMCP.  In general, using an X proxy is a much better approach for accessing a remote desktop session on the 3D application server.\n</p></div>\n\n<p>Using the VGL Transport with XDMCP is conceptually similar to using the \nVGL Transport with a <a href=\"#Direct_X11_Connection\">direct X11 \nconnection</a><a name=\"idx0033\"></a>.  The major difference is that, \nrather than remotely displaying individual X windows to the 2D X server, \nXDMCP remotely displays a complete desktop session from the application \nserver. X11 applications are launched inside of this remote desktop \nsession rather than in a separate shell, so <code>vglconnect</code> \ncannot be used in this case.  Instead, it is necessary to start \n<code>vglclient</code> manually on the client machine.</p>\n\n\n<h3 id=\"hd008005001\">Procedure</h3>\n\n<ol class=\"Ordered numeric\">\n    <li class=\"Ordered-1 Ordered\">\n        Configure the server machine to accept XDMCP connections.  This may \n        require opening specific ports in its firewall.\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        Configure the client machine to make XDMCP connections.  This may \n        require enabling X11 TCP connections and opening specific ports in its \n        firewall.\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        Once you have established an XDMCP connection from the client to the \n        server, open a terminal inside the XDMCP session and type:\n<pre class=\"verbatim\">\nxhost&nbsp;+LOCAL:\n</pre>\n\n        <div class=\"important\"><p class=\"important\">\n        This grants access to the 2D X server for any user that is currently logged into the client machine.  This is not very secure, but neither is using XDMCP.  If you are concerned, then see below for a discussion of how to use <code>xauth</code> to provide 2D X server access in a slightly more secure manner.\n        </p></div>\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        If you are using a Mac or Windows client, or if you are using a nested X \n        server (such as Xephyr or XNest) on a Linux/Unix client to make the \n        XDMCP connection, then the next step is easy.  Simply open a new \n        terminal/command prompt on the client machine, set the \n        <code>DISPLAY</code> environment variable to the display name of the X \n        server that is running the XDMCP session (usually <code>:0</code> or \n        <code>:1</code>), and type:\n<pre class=\"verbatim\">\nvglclient&nbsp;-detach\n</pre>\n\n        You can now close the terminal/command prompt, if you wish.\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        If you are running a full-screen XDMCP session on a Linux/Unix client \n        (for instance, using GDM Chooser), then starting <code>vglclient</code> \n        is a bit trickier.  In this case, you can&rsquo;t open up a separate \n        terminal window on the client machine for the purposes of running \n        <code>vglclient</code>.  However, from inside of the XDMCP session, you \n        can open an SSH session back into the client machine.  In this SSH \n        session, set the <code>DISPLAY</code> environment variable to the \n        display name of the X server that is running the XDMCP session (usually \n        <code>:0</code> or <code>:1</code>), and type:\n<pre class=\"verbatim\">\nvglclient&nbsp;-detach\n</pre>\n\n        You can now close the SSH session, if you wish.\n    </li>\n</ol>\n\n\n\n<h3 id=\"hd008005002\">Security</h3>\n\n<p>Typing <code>xhost&nbsp;+LOCAL:</code> in step 3 above opens the 2D X \nserver to all current users of the client machine.  This shouldn&rsquo;t \npose any significant risk if the client is a Windows or a Mac machine.  \nHowever, Linux/Unix clients might have multiple simultaneous users, so \nin these cases, it may be desirable to use a more secure method of \ngranting access to the 2D X server.</p>\n\n<p>Instead of typing <code>xhost&nbsp;+LOCAL:</code>, you can type the \nfollowing:</p>\n\n<pre class=\"verbatim\">\nxauth&nbsp;nextract&nbsp;-&nbsp;$DISPLAY&nbsp;|&nbsp;sed&nbsp;&quot;s/.*[&nbsp;]//g&quot;&nbsp;|&nbsp;xargs&nbsp;ssh&nbsp;{client}&nbsp;xauth&nbsp;add&nbsp;{display}&nbsp;.\n</pre>\n\n<p>where <em><code>{client}</code></em> is the hostname or IP address of \nthe client machine and <em><code>{display}</code></em> is the display \nname of the 2D X server, from the point of view of the client machine \n(usually <code>:0</code> or <code>:1</code>).</p>\n\n<p>This extracts the XAuth key for the 2D X server, then remotely adds it \nto the XAuth keyring on the client machine.</p>\n\n\n\n<h2 id=\"hd008006\">8.6&nbsp;The VirtualGL Client Application: Nuts and Bolts</h2>\n\n<p>The VirtualGL Client application (<code>vglclient</code>) receives \nencoded and/or compressed images on a dedicated TCP socket, decodes \nand/or decompresses the images, and draws the images into the \nappropriate X window.  The <code>vglconnect</code> script wraps both \n<code>vglclient</code> and SSH to greatly simplify the process of \ncreating VGL Transport connections.</p>\n\n<p><code>vglconnect</code> invokes <code>vglclient</code> with an argument \nof <code>-detach</code>, which causes <code>vglclient</code> to \ncompletely detach from the console and run as a background daemon.  It \nwill remain running silently in the background, accepting VGL Transport \nconnections for the X server on which it was started, until that X \nserver is reset or until the <code>vglclient</code> process is \nexplicitly killed.  Logging out of the X server will reset the X server \nand thus kill all <code>vglclient</code> instances that are attached to \nit.  You can also explicitly kill all instances of \n<code>vglclient</code> running under your user account by invoking</p>\n\n<pre class=\"verbatim\">\nvglclient&nbsp;-kill\n</pre>\n\n<p>(<code>vglclient</code> is installed in <code>/opt/VirtualGL/bin</code> \nby default.)</p>\n\n<p><code>vglconnect</code> instructs <code>vglclient</code> to redirect all \nof its console output to a log file named \n<em><code>{home}</code></em><code>/.vgl/vglconnect-</code><em><code>{hostname}</code></em><code>-</code><em><code>{display}</code></em><code>.log</code>, \nwhere <em><code>{home}</code></em> is the path of the current \nuser&rsquo;s home directory, <em><code>{hostname}</code></em> is the \nname of the computer running <code>vglconnect</code>, and \n<em><code>{display}</code></em> is the name of the current X display \n(read from the <code>DISPLAY</code> environment or passed to \n<code>vglconnect</code> using the <code>-display</code> argument.)  In \nthe event that something goes wrong, this log file is the first place to \ncheck.</p>\n\n<p>When <code>vglclient</code> successfully starts on a given X display, it \nstores its listener port number in a root window property on the X \ndisplay.  If other <code>vglclient</code> instances attempt to start on \nthe same X display, they read the X window property, determine that \nanother <code>vglclient</code> instance is already running, and exit to \nallow the first instance to retain control. <code>vglclient</code> will \nclean up the X property under most circumstances, even if it is \nexplicitly killed.  However, under rare circumstances (if sent a SIGKILL \nsignal on Unix, for instance), a <code>vglclient</code> instance may \nexit uncleanly and leave the X property set.  In these cases, it may be \nnecessary to add an argument of <code>-force</code> to \n<code>vglconnect</code> the next time you use it. This tells \n<code>vglconnect</code> to start a new <code>vglclient</code> instance, \nregardless of whether <code>vglclient</code> thinks that there is \nalready an instance running on this X display.  Alternately, you can \nsimply reset your X server to clear the orphaned X window property.</p>\n\n\n<h3 id=\"hd008006001\">8.6.1&nbsp;The VirtualGL Client and Firewalls</h3>\n\n<p>To retain compatibility with previous versions of VirtualGL, the first \n<code>vglclient</code> instance on a given machine will attempt to \nlisten on port 4242 for unencrypted connections and 4243 for SSL \nconnections (if VirtualGL was built with OpenSSL support.)  If it fails \nto obtain one of those ports, because another application or another \n<code>vglclient</code> instance is already using them, then \n<code>vglclient</code> will try to obtain a free port in the range of \n4200-4299. Failing that, it will request a free port from the operating \nsystem.</p>\n\n<p>In a nutshell: if you only ever plan to run one X server at a time on \nyour client machine, which means that you&rsquo;ll only ever need one \ninstance of <code>vglclient</code> at a time, then it is sufficient to \nopen inbound port 4242 (and 4243 if you plan to use SSL) in your client \nmachine&rsquo;s firewall.  If you plan to run multiple X servers on your \nclient machine, which means that you will need to run multiple \n<code>vglclient</code> instances, then you may wish to open ports \n4200-4299.  Similarly, if you are running <code>vglclient</code> on a \nmulti-user X proxy server that has a firewall, then you may wish to open \nports 4200-4299 in the server&rsquo;s firewall.  Opening ports 4200-4299 \nwill accommodate up to 100 separate <code>vglclient</code> instances (50 \nif OpenSSL support is enabled.)  More instances than that cannot be \naccommodated on a firewalled machine, unless the firewall is able to \ncreate rules based on application executables instead of listening ports.</p>\n\n<p>Note that it is not necessary to open any inbound ports in the firewall \nto use the VGL Transport with <a href=\"#SSH_Tunneling\">SSH \nTunneling</a><a name=\"idx0034\"></a>.</p>\n\n<p><br /></p>\n\n<hr class=\"break\" />\n\n\n\n<h1 id=\"hd009\"><a name=\"file009\"></a>9&nbsp;Using VirtualGL with X Proxies Such as VNC</h1>\n\n<p><a name=\"X11_Proxy_Usage\"></a></p>\n\n<p>The VGL Transport is a good solution for using VirtualGL over a fast \nnetwork.  However, the VGL Transport is not generally suitable for \nhigh-latency or low-bandwidth networks, due to its reliance on the X11 \nprotocol to send the non-3D elements of the 3D application&rsquo;s GUI.  \nThe VGL Transport also requires an X server to be running on the client \nmachine, which makes it generally more difficult to deploy and use on \nWindows clients. VirtualGL can be used with an &ldquo;X proxy&rdquo; to \novercome these limitations.  An X proxy acts as a virtual X server, \nreceiving X11 commands from the application (and from VirtualGL), \nrendering the X11 commands into images, compressing the resulting \nimages, and sending the compressed images over the network to a client \nor clients.  X proxies perform well on all types of networks, including \nhigh-latency and low-bandwidth networks.  They often provide rudimentary \ncollaboration capabilities, allowing multiple clients to simultaneously \nview the same X session and pass around control of the keyboard and \nmouse.  X proxies are also stateless, meaning that the client can \ndisconnect and reconnect at will from any machine on the network, and \nthe 3D application will remain running on the server.</p>\n\n<p>Since VirtualGL is sending rendered 3D images to the X proxy at a very \nfast rate, the proxy must be able to compress the images very quickly in \norder to keep up.  Unfortunately, however, most X proxies can&rsquo;t.  \nThey simply aren&rsquo;t designed to compress, with any degree of \nperformance, the large and complex images generated by 3D applications.  \nTherefore, the VirtualGL Project provides an optimized X proxy called \n&ldquo;TurboVNC&rdquo;, a variant of \n<span class=\"remote\"><a href=\"http://www.tightvnc.com\" class=\"remote\">TightVNC</a></span><a name=\"idx0035\"></a> \nthat is designed specifically to achieve high levels of performance with \n3D applications running in VirtualGL.  More information about TurboVNC, \nincluding instructions for using it with VirtualGL, can be found in the \nTurboVNC User&rsquo;s Guide.</p>\n\n<p>Many other X proxy solutions work well with VirtualGL, and some of these \nsolutions provide compelling features (seamless windows, for instance, \nor session management), but none of these X proxies matches the \nperformance of TurboVNC, as of this writing.</p>\n\n\n<h2 id=\"hd009001\">9.1&nbsp;Using VirtualGL with an X Proxy on the Same Server</h2>\n\n<p><a name=\"X11_Proxy_Usage_Local\"></a></p>\n\n<p>The most common (and optimal) way to use VirtualGL with an X proxy is to \nset up both on the same server.  This allows VirtualGL to send its \nrendered 3D images to the X proxy through shared memory rather than \nsending them over a network.</p>\n\n<div class=\"figure\">\n<img src=\"x11transport.png\" alt=\"x11transport\" class=\"figure\" id=\"imgid_8\" name=\"imgid_8\"/>\n</div>\n\n<p>With this configuration, you can usually invoke</p>\n\n<pre class=\"verbatim\">\n/opt/VirtualGL/bin/vglrun&nbsp;{application_executable_or_script}\n</pre>\n\n<p>from a terminal inside of the X proxy session, and it will &ldquo;just \nwork.&rdquo; VirtualGL reads the value of the <code>DISPLAY</code> \nenvironment variable to determine whether to enable the X11 Transport by \ndefault.  If <code>DISPLAY</code> begins with a colon \n(&ldquo;<code>:</code>&rdquo;) or with &ldquo;<code>unix:</code>&rdquo;, \nthen VirtualGL will assume that the X connection is local and will \nenable the X11 Transport as the default.  In some cases, however, the \n<code>DISPLAY</code> environment variable in the X proxy session may not \nbegin with a colon or &ldquo;<code>unix:</code>&rdquo;.  In these cases, \nit is necessary to manually enable the X11 Transport by setting the \n<code>VGL_COMPRESS</code> environment variable to <code>proxy</code> or \nby passing an argument of <code>-c&nbsp;proxy</code> to \n<code>vglrun</code>.</p>\n\n\n\n<h2 id=\"hd009002\">9.2&nbsp;Using VirtualGL with an X Proxy on a Different Machine</h2>\n\n<p><a name=\"X11_Proxy_Usage_Remote\"></a></p>\n\n<div class=\"figure\">\n<img src=\"vgltransportservernetwork.png\" alt=\"vgltransportservernetwork\" class=\"figure\" id=\"imgid_9\" name=\"imgid_9\"/>\n</div>\n\n<p>If the X proxy and VirtualGL are running on different servers, then it \nis desirable to use the VGL Transport to send images from the VirtualGL \nserver to the X proxy.  It is also desirable to disable image \ncompression in the VGL Transport.  Otherwise, the images would have to \nbe compressed by the VirtualGL server, decompressed by the VirtualGL \nClient, then recompressed by the X proxy, which is a waste of CPU \nresources.  However, sending images uncompressed over a network requires \na fast network (generally, Gigabit Ethernet or faster), so there needs \nto be a fast link between the VirtualGL server and the X proxy server \nfor this procedure to perform well.</p>\n\n<p>The procedure for using the VGL Transport to display 3D applications \nfrom a VirtualGL server to a remote X proxy is the same as the \n<a href=\"#X11_Forwarding\">procedure</a><a name=\"idx0036\"></a> for using \nthe VGL Transport to display 3D applications from a VirtualGL server to \na remote 2D X server, with the following exceptions:</p>\n\n<ol class=\"Ordered numeric\">\n    <li class=\"Ordered-1 Ordered\">\n        The &ldquo;client&rdquo; in this case is really the X proxy server.\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        The &ldquo;X server&rdquo; is really the X proxy.\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        It is recommended that you disable image compression in the VGL \n        Transport by either setting the <code>VGL_COMPRESS</code> environment \n        variable to <code>rgb</code> or passing an argument of \n        <code>-c&nbsp;rgb</code> to <code>vglrun</code> when launching \n        VirtualGL. Otherwise, VirtualGL will detect that the connection to the X \n        server is remote, and it will automatically try to enable JPEG \n        compression.\n    </li>\n</ol>\n\n<p><br /></p>\n\n<hr class=\"break\" />\n\n\n\n<h1 id=\"hd0010\"><a name=\"file010\"></a>10&nbsp;Support for the X Video Extension</h1>\n\n<p><a name=\"X_Video_Support\"></a></p>\n\n<p>The X Video extension allows applications to pre-encode or pre-compress \nimages and send them through the X server to the graphics adapter, which \npresumably has on-board video decoding capabilities.  This approach \ngreatly reduces the amount of CPU resources used by the X server, which \ncan be beneficial if the X server is running on a different machine than \nthe application.</p>\n\n<p>In the case of VirtualGL, what this means is that the VirtualGL client \nmachine no longer has to decode or decompress images from the 3D \napplication server. It can simply pass the images along to the graphics \nadapter for decoding.</p>\n\n<p>VirtualGL supports the X Video extension in two ways:</p>\n\n\n<h2 id=\"hd0010001\">10.1&nbsp;The VGL Transport with YUV Encoding</h2>\n\n<p>Setting the <code>VGL_COMPRESS</code> environment variable to \n<code>yuv</code> or passing an argument of <code>-c&nbsp;yuv</code> to \n<code>vglrun</code> enables the VGL Transport with YUV encoding.  When \nthis mode is enabled, VirtualGL encodes images as YUV420P (a form of YUV \nencoding that uses 4X chrominance subsampling and separates Y, U, and V \npixel components into separate image planes) instead of RGB or JPEG.  \nThe YUV420P images are sent to the VirtualGL Client, which draws them \nusing the X Video extension.</p>\n\n<p>On a per-frame basis, YUV encoding uses about half the server CPU time \nas JPEG compression and only slightly more server CPU time than RGB \nencoding.  On a per-frame basis, YUV encoding uses about 1/3 the client \nCPU time as JPEG compression and about half the client CPU time as RGB \nencoding.  YUV encoding also uses about half the network bandwidth (per \nframe) as RGB.</p>\n\n<p>However, since YUV encoding uses 4X chrominance subsampling, the \nresulting images may contain some visible artifacts.  In particular, \nnarrow, aliased lines and other sharp features may appear \n&ldquo;soft&rdquo;.</p>\n\n\n\n<h2 id=\"hd0010002\">10.2&nbsp;The XV Transport</h2>\n\n<p>Setting the <code>VGL_COMPRESS</code> environment variable to \n<code>xv</code> or passing an argument of <code>-c&nbsp;xv</code> to \n<code>vglrun</code> enables the XV Transport.  The XV Transport is a \nspecial version of the X11 Transport that encodes images as YUV420P and \ndraws them directly to the 2D X server using the X Video extension.  \nThis is mainly useful in conjunction with X proxies that support the X \nVideo extension.  The idea is that, if the X proxy is going to have to \ntranscode the image to YUV anyhow, VirtualGL may be faster at doing \nthis, since it has a SIMD-accelerated YUV encoder.</p>\n\n<p><br /></p>\n\n<hr class=\"break\" />\n\n\n\n<h1 id=\"hd0011\"><a name=\"file011\"></a>11&nbsp;Transport Plugins</h1>\n\n<p><a name=\"Transport_Plugins\"></a></p>\n\n<p>VirtualGL 2.2 (and later) includes an API that allows you to write your \nown image transports.  Thus, you can use VirtualGL for doing split \nrendering and pixel readback but then use your own library for \ndelivering the pixels to the client.</p>\n\n<p>When the <code>VGL_TRANSPORT</code> environment variable (or the \n<code>-trans</code> option to <code>vglrun</code>) is set to \n<em><code>{t}</code></em>, then VirtualGL will look for a DSO (dynamic \nshared object) with the name \n<code>libtransvgl_</code><em><code>{t}</code></em><code>.so</code> in \nthe dynamic linker path and will attempt to access a set of API \nfunctions from this library.  The functions that the plugin library must \nexport are defined in <code>/opt/VirtualGL/include/rrtransport.h</code>, \nand an example of their usage can be found in \n<code>server/testplugin.cpp</code> and \n<code>server/testplugin2.cpp</code> in the VirtualGL source \ndistribution.  The former wraps the VGL Transport as an image transport \nplugin, and the latter does the same for the X11 Transport.</p>\n\n<p><br /></p>\n\n<hr class=\"break\" />\n\n\n\n<h1 id=\"hd0012\"><a name=\"file012\"></a>12&nbsp;Using VirtualGL with setuid/setgid Executables</h1>\n\n<p><code>vglrun</code> can be used to launch either binary executables or \nshell scripts, but there are a few things to keep in mind when using \n<code>vglrun</code> to launch a shell script.  When you launch a shell \nscript with <code>vglrun</code>, the VirtualGL faker library will be \npreloaded into every executable that the script launches. Normally this \nis innocuous, but if the script calls any executables that have the \nsetuid and/or setgid permission bits set, then the dynamic linker will \nrefuse to preload the VirtualGL faker library into those executables.  \nOne of the following warnings will be printed for each setuid/setgid \nexecutable that the script tries to launch:</p>\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Linux</dt>\n    <dd class=\"Description-1 Description\">\n    </dd>\n</dl>\n\n<pre class=\"verbatim\">\nERROR:&nbsp;ld.so:&nbsp;object&nbsp;'libvglfaker.so'&nbsp;from&nbsp;LD_PRELOAD&nbsp;cannot&nbsp;be&nbsp;preloaded:&nbsp;ignored.\n</pre>\n\n<pre class=\"verbatim\">\nERROR:&nbsp;ld.so:&nbsp;object&nbsp;'libdlfaker.so'&nbsp;from&nbsp;LD_PRELOAD&nbsp;cannot&nbsp;be&nbsp;preloaded:&nbsp;ignored.\n</pre>\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Solaris</dt>\n    <dd class=\"Description-1 Description\">\n    </dd>\n</dl>\n\n<pre class=\"verbatim\">\nld.so.1:&nbsp;warning:&nbsp;libvglfaker.so:&nbsp;open&nbsp;failed:&nbsp;No&nbsp;such&nbsp;file&nbsp;in&nbsp;secure&nbsp;directories\n</pre>\n\n<pre class=\"verbatim\">\nld.so.1:&nbsp;warning:&nbsp;libdlfaker.so:&nbsp;open&nbsp;failed:&nbsp;No&nbsp;such&nbsp;file&nbsp;in&nbsp;secure&nbsp;directories\n</pre>\n\n<p>These are just warnings, and the setuid/setgid executables will continue \nto run (without VirtualGL preloaded into them.)  However, if you want to \nget rid of the warnings, an easy way to do so is to simply edit the \napplication script and make it store the value of the \n<code>LD_PRELOAD</code> environment variable until right before the \napplication executable is launched.  For instance, consider the \nfollowing application script:</p>\n\n<p>Initial contents of <code>application.sh</code>:</p>\n\n<pre class=\"verbatim\">\n#!/bin/sh\nsome_setuid_executable\nsome_3D_application_executable\n</pre>\n\n<p>You could modify the script as follows:</p>\n\n<pre class=\"verbatim\">\n#!/bin/sh\nLD_PRELOAD_SAVE=$LD_PRELOAD\nLD_PRELOAD=\nexport&nbsp;LD_PRELOAD\n\nsome_setuid_executable\n\nLD_PRELOAD=$LD_PRELOAD_SAVE\nexport&nbsp;LD_PRELOAD\n\nsome_3D_application_executable\n</pre>\n\n<p>This procedure may be necessary to work around certain other interaction \nissues between VirtualGL and the launch scripts of specific \napplications.  See <a href=\"#Application_Recipes\">Application \nRecipes</a><a name=\"idx0037\"></a> for more details.</p>\n\n<p>If the 3D application that you are intending to run in VirtualGL is \nitself a setuid/setgid executable, then further steps are required.  \nOtherwise, the 3D application will launch without VirtualGL preloaded \ninto it.  Forcing VirtualGL to be preloaded into setuid/setgid \nexecutables has security ramifications, so please be aware of these \nbefore you do it.  By applying one of the following workarounds, you are \nessentially telling the operating system that you trust the security and \nstability of VirtualGL as much as you trust the security and stability \nof the operating system.  While we&rsquo;re flattered, we&rsquo;re not \nsure that we&rsquo;re necessarily deserving of that accolade, so if you \nare in a security-critical environment, apply the appropriate level of \nparanoia here.</p>\n\n<p><a name=\"setuid_linux\"></a> To force VirtualGL to be preloaded into \nsetuid/setgid executables on Linux, you have to first make sure that the \nfaker libraries (<code>libvglfaker.so</code> and \n<code>libdlfaker.so</code>) are installed in the &ldquo;system&rdquo; \nlibrary path (usually <code>/usr/lib</code>, <code>/usr/lib64</code>, \n<code>/usr/lib32</code>, or <code>/usr/lib/i386-linux-gnu</code>). Next, \nmake <code>libvglfaker.so</code> and <code>libdlfaker.so</code> setuid \nexecutables.  To do this, run the following commands as root:</p>\n\n<pre class=\"verbatim\">\nchmod&nbsp;u+s&nbsp;/usr/{lib}/libvglfaker.so\nchmod&nbsp;u+s&nbsp;/usr/{lib}/libdlfaker.so\n</pre>\n\n<p>where <em><code>{lib}</code></em> is <code>lib</code>, \n<code>lib64</code>, <code>lib32</code>, or \n<code>lib/i386-linux-gnu</code>, depending on your system.</p>\n\n<p>On Solaris, you can force VirtualGL to be preloaded into setuid/setgid \nexecutables by adding the VirtualGL library directories to the Solaris \n&ldquo;secure path.&rdquo;  Solaris keeps a tight lid on what goes into \n<code>/usr/lib</code> and <code>/lib</code>, and by default, it will \nonly allow libraries in those paths to be preloaded into an executable \nthat is setuid and/or setgid.  Generally, 3rd party packages are \nforbidden from installing anything into <code>/usr/lib</code> or \n<code>/lib</code>, but you can use the <code>crle</code> utility to add \nother directories to the operating system&rsquo;s list of secure paths.  \nIn the case of VirtualGL, you would execute one of the following \ncommands (as root):</p>\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">32-bit VirtualGL:</dt>\n    <dd class=\"Description-1 Description\">\n<pre class=\"verbatim\">\ncrle&nbsp;-u&nbsp;-s&nbsp;/opt/VirtualGL/lib32\n</pre>\n\n    </dd>\n    <dt class=\"Description-1 Description\">64-bit VirtualGL:</dt>\n    <dd class=\"Description-1 Description\">\n<pre class=\"verbatim\">\ncrle&nbsp;-64&nbsp;-u&nbsp;-s&nbsp;/opt/VirtualGL/lib64\n</pre>\n\n    </dd>\n</dl>\n\n<p><br /></p>\n\n<hr class=\"break\" />\n\n\n\n<h1 id=\"hd0013\"><a name=\"file013\"></a>13&nbsp;Using VirtualGL with VirtualBox</h1>\n\n<p>VirtualBox is an enterprise-class, open source virtualization solution \nprovided by Oracle.  Since version 2.1.0, VirtualBox has provided \nsupport for hardware-accelerated OpenGL in Windows and Linux guests \nrunning on Windows, Mac/Intel, Linux, and Solaris/x86 hosts. 3D \nacceleration in VirtualBox is accomplished by installing a special \ndriver in the guest that uses a subset of Chromium to transmit OpenGL \ncalls through a local connection to the VirtualBox process running on \nthe host.  When used in conjunction with VirtualGL on a Linux or \nSolaris/x86 host, this solution provides a means of displaying Windows \n3D applications remotely.</p>\n\n<p>To use VirtualGL with VirtualBox, perform the following procedures:</p>\n\n\n<h3 id=\"hd0013000001\">Configuring the System</h3>\n\n<ol class=\"Ordered numeric\">\n    <li class=\"Ordered-1 Ordered\">\n        Launch VirtualBox and use the VirtualBox GUI to create and test your \n        virtual machine.\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        Follow the procedures outlined in the VirtualBox User&rsquo;s Manual to \n        enable 3D acceleration in the virtual machine.  Verify that 3D \n        acceleration works <em>without</em> VirtualGL before adding VirtualGL to \n        the mix.\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        Follow the procedure described in Chapter \n        <a href=\"#setuid_linux\" class=\"ref\">12</a> to make \n        <code>libvglfaker.so</code> and <code>libdlfaker.so</code> setuid \n        executables (Linux) or to add the VirtualGL library directory to the \n        list of secure paths (Solaris).\n    </li>\n</ol>\n\n\n\n<h3 id=\"hd0013000002\">Launching VirtualBox</h3>\n\n<pre class=\"verbatim\">\nvglrun&nbsp;VirtualBox&nbsp;-startvm&nbsp;{VM&nbsp;name&nbsp;or&nbsp;UUID}\n</pre>\n\n<p>This should work on most systems.  It is known to work with VirtualBox \n4.1.8 and prior and with VirtualBox 4.2 and later on Linux.</p>\n\n<div class=\"important\"><p class=\"important\">\nWith VirtualBox 4.1.10 and later 4.1.x versions, it is necessary to rename <code>/usr/lib/virtualbox/VBoxTestOGL</code> and execute <code>ln&nbsp;-fs&nbsp;/bin/true&nbsp;/usr/lib/virtualbox/VBoxTestOGL</code> in order to use those versions of VirtualBox with VirtualGL.\n</p></div>\n\n\n\n<h3 id=\"hd0013000003\">NOTES</h3>\n\n<ul class=\"Itemize\">\n    <li class=\"Itemize-1 Itemize asterisk\">\n        You might want to temporarily enable profiling (add an argument of \n        <code>+pr</code> to <code>vglrun</code> above) or set the \n        <code>VGL_LOGO</code> environment variable to <code>1</code> in order to \n        verify that VirtualGL is loaded and working.\n    </li>\n    <li class=\"Itemize-1 Itemize asterisk\">\n        It is necessary to start the virtual machine directly as described \n        above. Simply executing <code>vglrun&nbsp;VirtualBox</code> and using \n        the GUI to launch the VM does not work.  VirtualBox forks a separate \n        process for each VM, and the value of the <code>LD_PRELOAD</code> \n        environment variable from <code>vglrun</code> does not get propagated to \n        the VM process unless you start it directly.\n    </li>\n    <li class=\"Itemize-1 Itemize asterisk\">\n        VirtualBox sends mainly uncompressed image updates to the X display, so \n        the 2D elements of the virtual machine&rsquo;s display will not perform \n        well over a remote X11 connection unless gigabit Ethernet (or faster) \n        and a <a href=\"#Direct_X11_Connection\">direct X11 \n        connection</a><a name=\"idx0038\"></a> (<code>vglconnect&nbsp;-x</code>) \n        are used.  Using a high-performance X proxy (such as TurboVNC) is \n        generally preferred when remotely displaying VirtualBox using VirtualGL, \n        particularly on 100 Megabit and slower networks.\n    </li>\n</ul>\n\n<p><br /></p>\n\n<hr class=\"break\" />\n\n\n\n<h1 id=\"hd0014\"><a name=\"file014\"></a>14&nbsp;Using VirtualGL with VMWare Workstation</h1>\n\n<p>VirtualGL can also be used with VMWare Workstation, and the concept is \nbasically the same as that of VirtualBox.  As with VirtualBox, VMWare \nuses a special driver in the guest O/S to intercept the OpenGL commands \nand marshal them to the host O/S, where VirtualGL picks them up.</p>\n\n<p>To use VirtualGL with VMWare Workstation, perform the following \nprocedures:</p>\n\n\n<h3 id=\"hd0014000001\">Configuring the System</h3>\n\n<ol class=\"Ordered numeric\">\n    <li class=\"Ordered-1 Ordered\">\n        Launch VMWare and use the VMWare GUI to create and test your virtual \n        machine.\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        Follow the procedures outlined in the VMWare User&rsquo;s Manual to \n        enable 3D acceleration in the virtual machine.  Verify that 3D \n        acceleration works <em>without</em> VirtualGL before adding VirtualGL to \n        the mix.\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        Follow the procedure described in Chapter \n        <a href=\"#setuid_linux\" class=\"ref\">12</a> to make \n        <code>libvglfaker.so</code> and <code>libdlfaker.so</code> setuid \n        executables.\n    </li>\n</ol>\n\n\n\n<h3 id=\"hd0014000002\">Launching VMWare</h3>\n\n<p>This has been tested with VMWare Workstation 9.</p>\n\n<pre class=\"verbatim\">\nvglrun&nbsp;vmware&nbsp;-X&nbsp;{VM&nbsp;path}/{VM&nbsp;name}.vmx\n</pre>\n\n\n\n<h3 id=\"hd0014000003\">NOTES</h3>\n\n<p>The notes from the previous chapter apply to VMWare Workstation as well.</p>\n\n<p><br /></p>\n\n<hr class=\"break\" />\n\n\n\n<h1 id=\"hd0015\"><a name=\"file015\"></a>15&nbsp;Other Application Recipes</h1>\n\n<p><a name=\"Application_Recipes\"></a></p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <thead class=\"standard\">\n  <tr class=\"head \">\n    <th class=\"head standard\">Application</th>\n    <th class=\"head standard\">Versions Known to Require Recipe</th>\n    <th class=\"head standard\">Platform</th>\n    <th class=\"head standard\">Recipe</th>\n    <th class=\"head standard\">Notes</th>\n  </tr>\n  </thead>\n  <tr class=\"standard\">\n    <td class=\"standard\">Abaqus</td>\n    <td class=\"standard\">v6</td>\n    <td class=\"standard\">Linux</td>\n    <td class=\"standard\">It is necessary to add <br /><br /> <code>import&nbsp;os</code><br /> <code>os.environ['ABAQUS_EMULATE_OVERLAYS']&nbsp;=&nbsp;&quot;1&quot;</code> <br /><br /> to <code>/{abaqus_install_dir}/{abaqus_version}/site/abaqus_v6.env</code> to make Abaqus v6 work properly with VirtualGL if the 2D X server does not support transparent overlays.  If this is not done, then the application may fail to launch, fail to display the 3D pixels, or the 3D pixels may become corrupted whenever other windows obscure them.</td>\n    <td class=\"standard\">VirtualGL does not redirect the rendering of transparent overlays, since those cannot be rendered in a Pbuffer.  Thus, in order to use transparent overlays, the 2D X server must be able to render them, which is rarely the case for X proxies (see Section <a href=\"#overlays\" class=\"ref\">16.2</a> for more details.)  Setting <code>ABAQUS_EMULATE_OVERLAYS</code> to <code>1</code> causes the application to emulate overlay rendering instead of using actual transparent overlays.  This workaround is known to be necessary when running Abaqus 6.9 and 6.10 in VNC.</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"standard\">Abaqus</td>\n    <td class=\"standard\">v6</td>\n    <td class=\"standard\">Linux</td>\n    <td class=\"standard\"><code>vglrun&nbsp;-nodl&nbsp;{abaqus_path}/abaqus</code></td>\n    <td class=\"standard\">User reports indicate that Abaqus 6.9 will not work properly if <code>libdlfaker.so</code> from VirtualGL is preloaded into it.  This may be true for other versions of Abaqus as well.</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"standard\">Cadence Allegro</td>\n    <td class=\"standard\">v16.5</td>\n    <td class=\"standard\">Linux</td>\n    <td class=\"standard\"><code>vglrun&nbsp;+sync&nbsp;allegro</code></td>\n    <td class=\"standard\">Allegro relies on mixed X11/OpenGL rendering, and thus certain features (specifically the <code>pcb_cursor_infinite</code> cursor style) do not work properly unless <code>VGL_SYNC</code> is enabled.  If <code>VGL_SYNC</code> is not enabled, then the crosshairs may remain on the screen.  Since <code>VGL_SYNC</code> automatically enables the X11 transport and disables frame spoiling, it is highly recommended that you use an X proxy when <code>VGL_SYNC</code> is enabled. See Section <a href=\"#VGL_SYNC\" class=\"ref\">19.1</a> for further information.</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"standard\">Animator</td>\n    <td class=\"standard\">v4</td>\n    <td class=\"standard\">Linux</td>\n    <td class=\"standard\">Comment out the line that reads <br /><br /> <code>unsetenv&nbsp;LD_PRELOAD</code> <br /><br /> in the <code>a4</code> script, then launch Animator 4 using <br /><br /> <code>vglrun&nbsp;-ge&nbsp;a4</code> <br /><br /></td>\n    <td class=\"standard\">When the <code>a4</code> script unsets <code>LD_PRELOAD</code>, this prevents VirtualGL from being loaded into the application.  Animator 4 additionally checks the value of <code>LD_PRELOAD</code> and attempts to unset it from inside the application.  Using <code>vglrun&nbsp;-ge</code> to launch the application fools Animator 4 into thinking that <code>LD_PRELOAD</code> is unset.</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"standard\">ANSA</td>\n    <td class=\"standard\">v12.1.0</td>\n    <td class=\"standard\">Linux</td>\n    <td class=\"standard\">Add <br /><br /> <code>LD_PRELOAD_SAVE=$LD_PRELOAD</code><br /> <code>export&nbsp;LD_PRELOAD=</code> <br /><br /> to the top of the <code>ansa.sh</code> script, then add <br /><br /> <code>export&nbsp;LD_PRELOAD=$LD_PRELOAD_SAVE</code> <br /><br /> just prior to the <code>${ANSA_EXEC_DIR}bin/ansa_linux${ext2}</code> line.</td>\n    <td class=\"standard\">The ANSA startup script directly invokes <code>/lib/libc.so.6</code> to query the glibc version.  Since the VirtualGL faker depends on libc, preloading VirtualGL when directly invoking <code>libc.so.6</code> creates an infinite loop. Thus, it is necessary to disable the preloading of VirtualGL in the application script and then re-enable it prior to launching the actual application.</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"standard\">ANSYS HFSS, ANSYS ICEM CFD, Roxar RMS</td>\n    <td class=\"standard\">All</td>\n    <td class=\"standard\">Linux</td>\n    <td class=\"standard\">Set the <code>VGL_SPOILLAST</code> environment variable to <code>0</code> prior to launching the application with <code>vglrun</code></td>\n    <td class=\"standard\">These applications draw node highlighting and/or rubber banding directly to the front buffer.  In order for these front buffer operations to be displayed properly, it is necessary to use the &ldquo;spoil first&rdquo; frame spoiling algorithm whenever the application calls <code>glFlush()</code>.  See Section <a href=\"#VGL_SPOILLAST\" class=\"ref\">19.1</a> for further information.</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"standard\">AutoForm</td>\n    <td class=\"standard\">v4.0x</td>\n    <td class=\"standard\">All</td>\n    <td class=\"standard\"><code>vglrun&nbsp;+sync&nbsp;xaf_</code><em><code>{version}</code></em></td>\n    <td class=\"standard\">AutoForm relies on mixed X11/OpenGL rendering, and thus certain features (particularly the &ldquo;Dynamic Section&rdquo; dialog and &ldquo;Export Image&rdquo; feature) do not work properly unless <code>VGL_SYNC</code> is enabled.  Since <code>VGL_SYNC</code> automatically enables the X11 transport and disables frame spoiling, it is highly recommended that you use an X proxy when <code>VGL_SYNC</code> is enabled. See Section <a href=\"#VGL_SYNC\" class=\"ref\">19.1</a> for further information.</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"standard\">Cedega</td>\n    <td class=\"standard\">v6.0.x</td>\n    <td class=\"standard\">Linux</td>\n    <td class=\"standard\">Add <br /><br /> <code>export&nbsp;LD_PRELOAD=libvglfaker.so</code> <br /><br /> to the top of <code>~/.cedega/.winex_ver/winex-{version}/bin/winex3</code>, then run Cedega as you would normally (without <code>vglrun</code>.)  Since <code>vglrun</code> is not being used, it is necessary to use environment variables or the VirtualGL Configuration dialog to modify VirtualGL&rsquo;s configuration.</td>\n    <td class=\"standard\">The actual binary (WineX) that uses OpenGL is buried beneath several layers of Python and shell scripts.  The <code>LD_PRELOAD</code> variable does not get propagated down from the initial shell that invoked <code>vglrun</code>.</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"standard\">Google Chrome/Chromium</td>\n    <td class=\"standard\">v31 and later</td>\n    <td class=\"standard\">Linux</td>\n    <td class=\"standard\"><code>vglrun&nbsp;google-chrome&nbsp;--disable-gpu-sandbox</code><br /> or<br /> <code>vglrun&nbsp;chromium&nbsp;--disable-gpu-sandbox</code></td>\n    <td class=\"standard\">By default, Chrome/Chromium uses a separate process to perform 3D rendering (WebGL), and for reasons that are not yet fully understood, this breaks VirtualGL.  The <code>--disable-gpu-sandbox</code> option causes 3D rendering to be performed within the browser process.</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"standard\">Compiz</td>\n    <td class=\"standard\">All</td>\n    <td class=\"standard\">Linux</td>\n    <td class=\"standard\">Set the <code>VGL_WM</code> environment variable to <code>1</code> prior to launching the window manager with <code>vglrun</code>, or pass an argument of <code>+wm</code> to <code>vglrun</code>.</td>\n    <td class=\"standard\">See Section <a href=\"#VGL_WM\" class=\"ref\">19.1</a> for further information.</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"standard\">Heretic II</td>\n    <td class=\"standard\">All</td>\n    <td class=\"standard\">Linux</td>\n    <td class=\"standard\"><code>vglrun&nbsp;heretic2&nbsp;+set&nbsp;vid_ref&nbsp;glx</code></td>\n    <td class=\"standard\"></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"standard\">Intel OpenCL ICD</td>\n    <td class=\"standard\">All</td>\n    <td class=\"standard\">Linux</td>\n    <td class=\"standard\"><code>vglrun&nbsp;-ld&nbsp;{path_to_Intel_OpenCL_libs}&nbsp;{application}</code></td>\n    <td class=\"standard\">The Intel OpenCL installable client driver (ICD) is linked with a run-time library search path (rpath) of <code>$ORIGIN</code>, which would normally have the same effect as adding the directory in which the ICD is installed (default: <code>/opt/intel/opencl/lib64</code> on 64-bit systems) to <code>LD_LIBRARY_PATH</code>.  However, when VirtualGL is interposing the <code>dlopen()</code> function (which it does by default), this causes the actual <code>dlopen()</code> system calls to come from <code>libdlfaker.so</code>, so <code>$ORIGIN</code> will resolve to the directory in which the VirtualGL faker libraries are installed.  This causes the <code>dlopen()</code> calls within the Intel ICD to fail, and because the ICD apparently does not check the return value of those calls, a segfault occurs.  The workaround is simply to add the Intel ICD library path to <code>LD_LIBRARY_PATH</code>, which is most easily accomplished with <code>vglrun&nbsp;-ld</code>.</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"standard\">Mathematica</td>\n    <td class=\"standard\">v7</td>\n    <td class=\"standard\">Linux</td>\n    <td class=\"standard\">Set the <code>VGL_ALLOWINDIRECT</code> environment variable to <code>1</code> prior to launching the application with <code>vglrun</code></td>\n    <td class=\"standard\">Mathematica 7 will not draw the axis numbers on 3D charts correctly unless it is allowed to create an indirect OpenGL context.  See Section <a href=\"#VGL_ALLOWINDIRECT\" class=\"ref\">19.1</a> for further information.</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"standard\">MATLAB</td>\n    <td class=\"standard\">All</td>\n    <td class=\"standard\">Linux</td>\n    <td class=\"standard\"><code>vglrun&nbsp;/usr/local/MATLAB/{version}/bin/matlab&nbsp;-nosoftwareopengl</code></td>\n    <td class=\"standard\">MATLAB will automatically use its built-in (unaccelerated) OpenGL implementation if it detects that it is running in a remote display environment.  More specifically, it will always enable software OpenGL if the X server has an X extension called <code>VNC-EXTENSION</code>, which is the case with TurboVNC, TigerVNC, and RealVNC.</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"standard\">Tecplot 360</td>\n    <td class=\"standard\">2011 and earlier</td>\n    <td class=\"standard\">Linux</td>\n    <td class=\"standard\">Set the <code>VGL_GLFLUSHTRIGGER</code> environment variable to <code>0</code> prior to launching the application with <code>vglrun</code></td>\n    <td class=\"standard\">When running in TurboVNC (using VirtualGL), flashing artifacts will be produced when the user zooms/pans/rotates the scene in Tecplot 360, unless VirtualGL is instructed not to use <code>glFlush()</code> as an end-of-frame trigger.  This has been fixed in Tecplot 2012 and later. See Section <a href=\"#VGL_GLFLUSHTRIGGER\" class=\"ref\">19.1</a> for further information.</td>\n  </tr>\n</table>\n</div>\n\n\n<p><br /></p>\n\n<hr class=\"break\" />\n\n\n\n<h1 id=\"hd0016\"><a name=\"file016\"></a>16&nbsp;Advanced OpenGL Features</h1>\n\n<p><a name=\"Advanced_OpenGL\"></a></p>\n\n\n<h2 id=\"hd0016001\">16.1&nbsp;Stereographic Rendering</h2>\n\n<p>Stereographic rendering is a feature of OpenGL that creates separate \nrendering buffers for the left and right eyes and allows the application \nto render a different image into each buffer.  How the stereo images are \nsubsequently displayed depends on the particulars of the 3D hardware and \nthe user&rsquo;s environment.  VirtualGL can support stereographic \napplications in one of two ways: (1) by sending the stereo image pairs \nto the client to be displayed in stereo by the client&rsquo;s GPU, or \n(2) by combining each stereo image pair into a single image that can be \nviewed with traditional anaglyphic 3D glasses or a passive stereo \nsystem, such as a 3D TV.</p>\n\n\n<h3 id=\"hd0016001001\">16.1.1&nbsp;Quad-Buffered Stereo</h3>\n\n<p>The name &ldquo;quad-buffered&rdquo; stereo refers to the fact that \nOpenGL uses four buffers (left front, right front, left back, and right \nback) to support stereographic rendering with double buffering.  GPUs \nwith quad-buffered stereo capabilities generally provide some sort of \nsynchronization signal that can be used to control various types of \nactive stereo 3D glasses.  Some also support &ldquo;passive \nstereo&rdquo;, which requires displaying the left and right eye buffers \nto different monitor outputs.  VirtualGL supports quad-buffered stereo \nby rendering the stereo images on the server and sending the image pairs \nacross the network to be displayed on the client.</p>\n\n<p>In most cases, VirtualGL does not require that a GPU be present in the \nclient machine.  However, a GPU is required to display stereo image \npairs, so one must be present in any client machine that will use \nVirtualGL&rsquo;s quad-buffered stereo feature.  Since the GPU is only \nbeing used to draw images, it need not necessarily be a high-end GPU.  \nGenerally, the least expensive GPU that has stereo capabilities will \nwork fine in a VirtualGL client machine.  The VirtualGL server must also \nhave a GPU that supports stereo, since this is the only way that \nVirtualGL can obtain a stereo Pbuffer.</p>\n\n<p>When an application tries to render something in stereo, VirtualGL will \ndefault to using quad-buffered stereo rendering if the 2D X server \nsupports OpenGL and has stereo visuals available (not currently \nsupported in Cygwin/X.) Otherwise, VirtualGL will fall back to using \nanaglyphic stereo (see below.) It is usually necessary to explicitly \nenable stereo in the graphics driver configuration for both the client \nand server machines.  The \n<a href=\"#Troubleshooting\">Troubleshooting</a><a name=\"idx0039\"></a> \nsection below lists a way to verify that both the 3D X server and the 2D \nX server have stereo visuals available.</p>\n\n<p>In quad-buffered mode, VirtualGL reads back both the left and right eye \nbuffers on the server and sends the contents as a pair of compressed \nimages to the VirtualGL Client.  The VirtualGL Client then decompresses \nboth images and draws them as a single stereo frame to the client \nmachine&rsquo;s X display using <code>glDrawPixels()</code>.  It should \nthus be no surprise that enabling quad-buffered stereo in VirtualGL \ndecreases performance by 50% or more and uses twice the network \nbandwidth to maintain the same frame rate as mono.</p>\n\n<p>Quad-buffered stereo requires the VGL Transport.  Attempting to enable \nit with any other image transport will cause VGL to fall back to \nanaglyphic stereo mode.</p>\n\n\n\n<h3 id=\"hd0016001002\">16.1.2&nbsp;Anaglyphic Stereo</h3>\n\n<p>Anaglyphic stereo is the type of stereographic display used by old 3D \nmovies. It typically relies on a set of 3D glasses consisting of red \ntransparency film over the left eye and cyan transparency film over the \nright eye, although green/magenta and blue/yellow schemes can be used as \nwell.  To generate a 3D anaglyph, one color channel from the left eye \nbuffer is combined with the other two color channels from the right eye \nbuffer, thus allowing a single monographic image to contain stereo data.  \nFor instance, in the case of red/cyan, the red channel is taken from the \nleft eye buffer, and the green and blue channels are taken from the \nright eye buffer.  From the point of view of VirtualGL, an anaglyphic \nimage is the same as a monographic image, so anaglyphic stereo images \ncan be sent using any image transport to any type of client, regardless \nof the client&rsquo;s capabilities.</p>\n\n<p>VirtualGL uses anaglyphic stereo if it detects that an application has \nrendered something in stereo but quad-buffered stereo is not available, \neither because the client doesn&rsquo;t support it or because a \ntransport other than the VGL Transport is being used.  Anaglyphic stereo \nprovides a cheap and easy way to view stereographic applications in X \nproxies and on clients that do not support quad-buffered stereo.  \nAdditionally, anaglyphic stereo performs much faster than quad-buffered \nstereo, since it does not require sending twice the data to the client.</p>\n\n<p>As with quad-buffered stereo, anaglyphic stereo requires that the \nVirtualGL server have stereo rendering capabilities.  However, \nanaglyphic stereo does not require any 3D rendering capabilities (stereo \nor otherwise) on the client machine.</p>\n\n\n\n<h3 id=\"hd0016001003\">16.1.3&nbsp;Passive Stereo</h3>\n\n<p>As with anaglyphic stereo, passive stereo combines a stereographic image \npair into a single image (a &ldquo;stereogram&rdquo;), and thus it can \nbe used with any image transport.  However, unlike anaglyphic stereo, \npassive stereo must be used with specific display hardware, such as a 3D \nTV or monitor, that decodes the left and right eye images from the \nstereogram and sends them separately to a pair of 3D glasses (typically, \nthis is accomplished by way of polarization.)</p>\n\n<p>VirtualGL supports three methods of encoding stereograms:</p>\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Interleaved</dt>\n    <dd class=\"Description-1 Description\">\n        The even rows of the stereogram are taken from the left eye image, and \n        the odd rows are taken from the right eye image.\n    </dd>\n    <dt class=\"Description-1 Description\">Top/Bottom</dt>\n    <dd class=\"Description-1 Description\">\n        The top half of the stereogram is taken from the left eye image, and the \n        bottom half is taken from the right eye image.  Both halves are \n        subsampled 2X vertically.\n    </dd>\n    <dt class=\"Description-1 Description\">Side-by-Side</dt>\n    <dd class=\"Description-1 Description\">\n        The left half of the stereogram is taken from the left eye image, and \n        the right half is taken from the right eye image.  Both halves are \n        subsampled 2X horizontally.\n    </dd>\n</dl>\n\n<p>Most 3D TVs/monitors can be configured to decode at least one of these \ntypes of stereograms.  In order for this to work, however, the 3D \ndrawing area must be full-screen.</p>\n\n\n\n<h3 id=\"hd0016001004\">16.1.4&nbsp;Selecting a Stereo Mode</h3>\n\n<p>A particular stereo mode can be selected by setting the \n<code>VGL_STEREO</code> environment variable or by using the \n<code>-st</code> argument to <code>vglrun</code>.  See Section \n<a href=\"#VGL_STEREO\" class=\"ref\">19.1</a> for more details.</p>\n\n\n\n<h2 id=\"hd0016002\">16.2&nbsp;Transparent Overlays</h2>\n\n<p><a name=\"overlays\"></a></p>\n\n<p>In the case of transparent overlays, VirtualGL completely bypasses its \nown GLX faker and uses indirect OpenGL rendering to draw to the \ntransparent overlay using the 2D X server.  The underlay is still \nrendered on the 3D X server, read back, and sent to the 2D X server, as \nalways.  Using indirect rendering to render the overlay is unfortunately \nnecessary, because there is no reliable way to draw to an overlay using \n2D (X11) functions, there are severe performance issues (on some cards) \nwith using <code>glDrawPixels()</code> to draw to the overlay, and there \nis no reasonable way to composite the overlay and underlay in a Pbuffer \non the VirtualGL server.</p>\n\n<p>The use of overlays is becoming more and more infrequent, and when they \nare used, it is generally only for drawing small, simple, static shapes \nand text. We have found that it is often faster to ship the overlay \ngeometry over to the 2D X server rather than to render it as an image \nand send the image.  Thus, even if it were possible to implement \noverlays without using indirect rendering, it is likely that indirect \nrendering of overlays would still be the fastest approach for most \napplications.</p>\n\n<p>As with quad-buffered stereo, overlays must be explicitly enabled in the \ngraphics driver and X server configurations.  In the case of overlays, \nhowever, they need only be supported and enabled on the client machine \nand in the 2D X server.  Some graphics drivers are known to disallow \nusing both quad-buffered stereo and overlays at the same time.  \nTransparent overlays are not currently supported in Cygwin/X.</p>\n\n<p>Indexed color (8-bit) overlays have been tested and are known to work \nwith VirtualGL.  True color (24-bit) overlays work, in theory, but have \nnot been tested.  Use <code>glxinfo</code> (see \n<a href=\"#Troubleshooting\">Troubleshooting</a><a name=\"idx0040\"></a> \nbelow) to verify whether your client&rsquo;s X display supports overlays \nand whether they are enabled.</p>\n\n\n\n<h2 id=\"hd0016003\">16.3&nbsp;Troubleshooting</h2>\n\n<p><a name=\"Troubleshooting\"></a></p>\n\n<p>VirtualGL includes a modified version of <code>glxinfo</code> that can \nbe used to determine whether or not the 2D and 3D X servers have stereo \nor overlay visuals enabled.</p>\n\n<p>Run the following command sequence on the VirtualGL server to determine \nwhether the 3D X server has a suitable visual for stereographic \nrendering:</p>\n\n<pre class=\"verbatim\">\nxauth&nbsp;merge&nbsp;/etc/opt/VirtualGL/vgl_xauth_key\n/opt/VirtualGL/bin/glxinfo&nbsp;-display&nbsp;:{n}&nbsp;-c&nbsp;-v\n</pre>\n\n<p>(where <code>{n}</code> is the display number of the 3D X server.)  One \nor more of the visuals should say &ldquo;stereo=1&rdquo; and should list \n&ldquo;Pbuffer&rdquo; as one of the &ldquo;Drawable Types.&rdquo;</p>\n\n<p>Run the following command sequence on the VirtualGL server to determine \nwhether the 2D X server has a suitable visual for stereographic \nrendering or transparent overlays.</p>\n\n<pre class=\"verbatim\">\n/opt/VirtualGL/bin/glxinfo&nbsp;-v\n</pre>\n\n<p>In order to use stereo, one or more of the visuals should say \n&ldquo;stereo=1&rdquo;. In order to use transparent overlays, one or \nmore of the visuals should say &ldquo;level=1&rdquo;, should list a \n&ldquo;Transparent Index&rdquo; (non-transparent visuals will say \n&ldquo;Opaque&rdquo; instead), and should have a class of \n&ldquo;PseudoColor.&rdquo;</p>\n\n<p><br /></p>\n\n<hr class=\"break\" />\n\n\n\n<h1 id=\"hd0017\"><a name=\"file017\"></a>17&nbsp;Performance Measurement</h1>\n\n<p><a name=\"Perf_Measurement\"></a></p>\n\n\n<h2 id=\"hd0017001\">17.1&nbsp;VirtualGL&rsquo;s Built-In Profiling System</h2>\n\n<p>The easiest way to uncover bottlenecks in VirtualGL&rsquo;s image \npipeline is to set the <code>VGL_PROFILE</code> environment variable to \n<code>1</code> on both server and client (passing an argument of \n<code>+pr</code> to <code>vglrun</code> on the server has the same \neffect.)  This will cause VirtualGL to measure and report the throughput \nof various stages in the pipeline.  For example, here are some \nmeasurements from a dual Pentium 4 server communicating with a Pentium \nIII client on a 100 Megabit LAN:</p>\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Server</dt>\n    <dd class=\"Description-1 Description\">\n<pre class=\"verbatim\">\nReadback&nbsp;&nbsp;&nbsp;-&nbsp;43.27&nbsp;Mpixels/sec&nbsp;-&nbsp;34.60&nbsp;fps\nCompress&nbsp;0&nbsp;-&nbsp;33.56&nbsp;Mpixels/sec&nbsp;-&nbsp;26.84&nbsp;fps\nTotal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;8.02&nbsp;Mpixels/sec&nbsp;-&nbsp;&nbsp;6.41&nbsp;fps&nbsp;-&nbsp;10.19&nbsp;Mbits/sec&nbsp;(18.9:1)\n</pre>\n\n    </dd>\n    <dt class=\"Description-1 Description\">Client</dt>\n    <dd class=\"Description-1 Description\">\n<pre class=\"verbatim\">\nDecompress&nbsp;-&nbsp;10.35&nbsp;Mpixels/sec&nbsp;-&nbsp;&nbsp;8.28&nbsp;fps\nBlit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;35.75&nbsp;Mpixels/sec&nbsp;-&nbsp;28.59&nbsp;fps\nTotal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;8.00&nbsp;Mpixels/sec&nbsp;-&nbsp;&nbsp;6.40&nbsp;fps&nbsp;-&nbsp;10.18&nbsp;Mbits/sec&nbsp;(18.9:1)\n</pre>\n\n    </dd>\n</dl>\n\n<p>The total throughput of the pipeline is 8.0 Megapixels/sec, or 6.4 \nframes/sec, indicating that our frame is 8.0 / 6.4 = 1.25 Megapixels in \nsize (a little less than 1280 x 1024 pixels.)  The readback and compress \nstages, which occur in parallel on the server, are obviously not slowing \nthings down, and we&rsquo;re only using 1/10 of our available network \nbandwidth.  Looking at the client, however, we discover that its slow \ndecompression speed (10.35 Megapixels/second) is the primary bottleneck.  \nDecompression and blitting on the client cannot be done in parallel, so \nthe aggregate performance is the harmonic mean of the decompression and \nblitting rates:  <em>[1/ (1/10.35 + 1/35.75)] = 8.0 Mpixels/sec</em>. In \nthis case, we could improve the performance of the whole system by \nsimply using a client with a faster CPU.</p>\n\n<div class=\"important\"><p class=\"important\">\nThis example is meant to demonstrate how the client can sometimes be the primary impediment to VirtualGL&rsquo;s end-to-end performance.  Using &ldquo;modern&rdquo; hardware on both ends of the connection, VirtualGL can easily stream 50+ Megapixels/sec across a LAN, as of this writing.\n</p></div>\n\n\n\n<h2 id=\"hd0017002\">17.2&nbsp;Frame Spoiling</h2>\n\n<p><a name=\"Frame_Spoiling\"></a></p>\n\n<p>By default, VirtualGL will only send a frame to the client if the client \nis ready to receive it.  If VirtualGL detects that the application has \nfinished rendering a new frame but there are already frames waiting in \nthe queue to be processed, then those unprocessed frames are dropped \n(&ldquo;spoiled&rdquo;) and the new frame is promoted to the head of the \nqueue.  This prevents a backlog of frames on the server, which would \ncause a perceptible delay in the responsiveness of interactive \napplications.  However, when running non-interactive applications, \nparticularly benchmarks, frame spoiling should always be disabled.   \nWith frame spoiling disabled, the server will render frames only as \nquickly as VirtualGL can send those frames to the client, which will \nconserve server resources as well as allow OpenGL benchmarks to \naccurately measure the end-to-end performance of VirtualGL (assuming \nthat the VGL Transport is used.)  With frame spoiling enabled, OpenGL \nbenchmarks will report meaningless data, since the rate at which the \nserver can render frames is decoupled from the rate at which VirtualGL \ncan send those frames to the client.</p>\n\n<p>In most X proxies (including VNC), there is effectively another layer of \nframe spoiling, since the rate at which the X proxy can send frames to \nthe client is decoupled from the rate at which VirtualGL can draw images \ninto the X proxy. Thus, even if frame spoiling is disabled in VirtualGL, \nOpenGL benchmarks will still report inaccurate data if they are run in \nsuch X proxies.  TCBench, described below, provides a limited solution \nto this problem.</p>\n\n<p>To disable frame spoiling, set the <code>VGL_SPOIL</code> environment \nvariable to <code>0</code> on the VirtualGL server or pass an argument \nof <code>-sp</code> to <code>vglrun</code>.  See Section \n<a href=\"#VGL_SPOIL\" class=\"ref\">19.1</a> for further information.</p>\n\n\n\n<h2 id=\"hd0017003\">17.3&nbsp;VirtualGL Diagnostic Tools</h2>\n\n<p>VirtualGL includes several tools that can be useful in diagnosing \nperformance problems with the system.</p>\n\n\n<h3 id=\"hd0017003001\">NetTest</h3>\n\n<p>NetTest is a network benchmark that uses the same network I/O classes as \nVirtualGL.  It can be used to test the latency and throughput of any \nTCP/IP connection, with or without SSL encryption.  <code>nettest</code> \nis installed in <code>/opt/VirtualGL/bin</code> by default.  For Windows \nusers, a native Windows version of NetTest is included in the \n&ldquo;VirtualGL-Utils&rdquo; package, which is distributed alongside \nVirtualGL.</p>\n\n<p>To use NetTest, first start up the NetTest server on one end of the \nconnection:</p>\n\n<pre class=\"verbatim\">\nnettest&nbsp;-server&nbsp;[-ssl]\n</pre>\n\n<p>(Use <code>-ssl</code> if you want to test the performance of SSL \nencryption over this particular connection.  VirtualGL must have been \ncompiled with OpenSSL support for this option to be available.)</p>\n\n<p>Next, start the client on the other end of the connection:</p>\n\n<pre class=\"verbatim\">\nnettest&nbsp;-client&nbsp;{server}&nbsp;[-ssl]\n</pre>\n\n<p>Replace <em><code>{server}</code></em> with the hostname or IP address \nof the machine on which the NetTest server is running.  (Use \n<code>-ssl</code> if the NetTest server is running in SSL mode.  \nVirtualGL must have been compiled with OpenSSL support for this option \nto be available.)</p>\n\n<p>The NetTest client will produce output similar to the following:</p>\n\n<pre class=\"verbatim\">\nTCP&nbsp;transfer&nbsp;performance&nbsp;between&nbsp;localhost&nbsp;and&nbsp;{server}:\n\nTransfer&nbsp;size&nbsp;&nbsp;1/2&nbsp;Round-Trip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Throughput&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Throughput\n(bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(msec)&nbsp;&nbsp;&nbsp;&nbsp;(MBytes/sec)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Mbits/sec)\n1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.093402&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.010210&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.085651\n2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.087308&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.021846&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.183259\n4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.087504&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.043594&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.365697\n8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.088105&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.086595&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.726409\n16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.090090&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.169373&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.420804\n32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.093893&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.325026&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.726514\n64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.102289&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.596693&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.005424\n128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.118493&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.030190&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.641863\n256&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.146603&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.665318&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.969704\n512&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.205092&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.380790&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19.971514\n1024&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.325896&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.996542&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25.136815\n2048&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.476611&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.097946&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;34.376065\n4096&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.639502&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.108265&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;51.239840\n8192&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.033596&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.558565&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;63.405839\n16384&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.706110&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.158259&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;76.825049\n32768&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.089896&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.113608&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;84.839091\n65536&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.909509&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.576174&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;88.719379\n131072&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.453894&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.913319&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;91.547558\n262144&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;22.616389&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.053931&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;92.727094\n524288&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;44.882406&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.140223&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;93.450962\n1048576&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;89.440702&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.180592&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;93.789603\n2097152&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;178.536997&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.202160&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;93.970529\n4194304&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;356.754396&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.212195&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;94.054712\n</pre>\n\n<p>We can see that the throughput peaks at about 94 megabits/sec, which is \npretty good for a 100 Megabit connection.  We can also see that, for \nsmall transfer sizes, the round-trip time is dominated by latency.  The \n&ldquo;latency&rdquo; is the same thing as the one-way (1/2 round-trip) \ntransit time for a zero-byte packet, which is about 93 microseconds in \nthis case.</p>\n\n\n\n<h3 id=\"hd0017003002\">CPUstat</h3>\n\n<p>CPUstat is available only for Linux and is installed in the same place \nas NetTest (<code>/opt/VirtualGL/bin</code> by default.)  It measures \nthe average, minimum, and peak CPU usage for all processors combined and \nfor each processor individually.  On Windows, this same functionality is \nprovided in the Windows Performance Monitor, which is part of the \noperating system.  On Solaris, the same data can be obtained through \n<code>vmstat</code>.</p>\n\n<p>CPUstat measures the CPU usage over a given sample period (a few \nseconds) and continuously reports how much the CPU was utilized since \nthe last sample period.  Output for a particular sample looks something \nlike this:</p>\n\n<pre class=\"verbatim\">\nALL&nbsp;:&nbsp;&nbsp;51.0&nbsp;(Usr=&nbsp;47.5&nbsp;Nice=&nbsp;&nbsp;0.0&nbsp;Sys=&nbsp;&nbsp;3.5)&nbsp;/&nbsp;Min=&nbsp;47.4&nbsp;Max=&nbsp;52.8&nbsp;Avg=&nbsp;50.8\ncpu0:&nbsp;&nbsp;20.5&nbsp;(Usr=&nbsp;19.5&nbsp;Nice=&nbsp;&nbsp;0.0&nbsp;Sys=&nbsp;&nbsp;1.0)&nbsp;/&nbsp;Min=&nbsp;19.4&nbsp;Max=&nbsp;88.6&nbsp;Avg=&nbsp;45.7\ncpu1:&nbsp;&nbsp;81.5&nbsp;(Usr=&nbsp;75.5&nbsp;Nice=&nbsp;&nbsp;0.0&nbsp;Sys=&nbsp;&nbsp;6.0)&nbsp;/&nbsp;Min=&nbsp;16.6&nbsp;Max=&nbsp;83.5&nbsp;Avg=&nbsp;56.3\n</pre>\n\n<p>The first column indicates what percentage of time the CPU was active \nsince the last sample period (this is then broken down into what \npercentage of time the CPU spent running user, nice, and system/kernel \ncode.)  &ldquo;ALL&rdquo; indicates the average utilization across all \nCPUs since the last sample period.  &ldquo;Min&rdquo;, \n&ldquo;Max&rdquo;, and &ldquo;Avg&rdquo; indicate a running minimum, \nmaximum, and average of all samples since CPUstat was started.</p>\n\n<p>Generally, if an application&rsquo;s CPU usage is fairly steady, you can \nrun CPUstat for a bit and wait for the Max. and Avg. for the \n&ldquo;ALL&rdquo; category to stabilize, then that will tell you what \nthe application&rsquo;s peak and average % CPU utilization is.</p>\n\n\n\n<h3 id=\"hd0017003003\">TCBench</h3>\n\n<p>TCBench was born out of the need to compare VirtualGL&rsquo;s \nperformance to that of other thin client software, some of which had \nframe spoiling features that could not be disabled.  TCBench measures \nthe frame rate of a thin client system as seen from the client&rsquo;s \npoint of view.  It does this by attaching to one of the client windows \nand continuously reading back a small area at the center of the window.  \nWhile this may seem to be a somewhat non-rigorous test, experiments have \nshown that, if care is taken to ensure that the application is updating \nthe center of the window on every frame (such as in a spin animation), \nTCBench can produce quite accurate results.  It has been sanity checked \nwith VirtualGL&rsquo;s internal profiling mechanism and with a variety \nof system-specific techniques, such as monitoring redraw events on the \nclient&rsquo;s windowing system.</p>\n\n<p>TCBench is installed in <code>/opt/VirtualGL/bin</code> by default.  For \nWindows users, a native Windows version of TCBench is included in the \n&ldquo;VirtualGL-Utils&rdquo; package, which is distributed alongside \nVirtualGL.  Run <code>tcbench</code> from the command line, and it will \nprompt you to click in the window you want to benchmark.   That window \nshould already have an automated animation of some sort running before \nyou launch TCBench.  Note that GLXSpheres (see below) is an ideal \nbenchmark to use with TCBench, since GLXSpheres draws a new sphere to \nthe center of its window on every frame.</p>\n\n<pre class=\"verbatim\">\ntcbench&nbsp;-?\n</pre>\n\n<p>lists the relevant command-line arguments, which can be used to adjust \nthe benchmark time, the sampling rate, and the x and y offset of the \nsampling area within the window.</p>\n\n\n\n<h3 id=\"hd0017003004\">GLXSpheres</h3>\n\n<p>GLXSpheres is a benchmark that produces very similar images to \nnVidia&rsquo;s (long-discontinued) SphereMark benchmark.  Back in the \nearly days of VirtualGL&rsquo;s existence, it was discovered (quite by \naccident) that SphereMark was a pretty good test of VirtualGL&rsquo;s \nend-to-end performance, because that benchmark generated images with \nabout the same proportion of solid color and similar frequency \ncomponents to the images generated by volume visualization applications.</p>\n\n<p>Thus, the goal of GLXSpheres was to create an open source Unix version \nof SphereMark (the original SphereMark was for Windows only) completely \nfrom scratch.  GLXSpheres does not use any code from the original \nbenchmark, but it does attempt to mimic the visual output of the \noriginal as closely as possible.  GLXSpheres lacks some of the advanced \nrendering features of the original, such as the ability to use vertex \narrays, but since GLXspheres was primarily designed as a benchmark for \nVirtualGL, display lists are more than fast enough for that purpose.</p>\n\n<p>GLXSpheres has some additional modes that its predecessor lacked, modes \nthat are designed specifically to test the performance of various \nVirtualGL features:</p>\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Stereographic rendering (<code>glxspheres&nbsp;-s</code>)</dt>\n    <dd class=\"Description-1 Description\">\n    </dd>\n    <dt class=\"Description-1 Description\">Overlay rendering (<code>glxspheres&nbsp;-o</code>)</dt>\n    <dd class=\"Description-1 Description\">\n        This renders text, a moving crosshair cursor, and a block of pixels to \n        an 8-bit transparent overlay while animating the spheres on the \n        underlay.  The color map of the overlay is changed periodically.\n    </dd>\n    <dt class=\"Description-1 Description\">Immediate mode rendering (<code>glxspheres&nbsp;-m</code>)</dt>\n    <dd class=\"Description-1 Description\">\n        Want to really see the benefit of VirtualGL?  Run \n        <code>glxspheres&nbsp;-m</code> over a remote X connection, then run \n        <code>vglrun&nbsp;-sp&nbsp;glxspheres&nbsp;-m</code> over the same \n        connection and compare. Immediate mode does not use display lists, so \n        when immediate mode OpenGL is rendered indirectly (over a remote X \n        connection), this causes every OpenGL command to be sent as a separate \n        network request to the X server &hellip; with every frame.  Many \n        applications do not use display lists (because the geometry they are \n        rendering is dynamic, or for other reasons), so this test models how \n        such applications might perform when displayed remotely without \n        VirtualGL.\n    </dd>\n    <dt class=\"Description-1 Description\">Interactive mode (<code>glxspheres&nbsp;-i</code>)</dt>\n    <dd class=\"Description-1 Description\">\n        In interactive mode, GLXSpheres will wait to draw a frame until it \n        receives a mouse event.  Continuously dragging the mouse in the window \n        should produce a steady frame rate, and this frame rate is a reasonable \n        model of the frame rate that you can achieve when running interactive \n        applications in VirtualGL.  Comparing this interactive frame rate \n        (<code>vglrun&nbsp;glxspheres&nbsp;-i</code>) with the non-interactive \n        frame rate (<code>vglrun&nbsp;-sp&nbsp;glxspheres</code>) allows you to \n        quantify the effect of X latency on the performance of interactive \n        applications in a VirtualGL environment.\n    </dd>\n</dl>\n\n<p>GLXSpheres is installed in <code>/opt/VirtualGL/bin</code> by default.  \n64-bit VirtualGL builds name this program <code>glxspheres64</code> so \nas to allow both a 64-bit and a 32-bit version of GLXSpheres to be \ninstalled on the same system.</p>\n\n<p><br /></p>\n\n<hr class=\"break\" />\n\n\n\n<h1 id=\"hd0018\"><a name=\"file018\"></a>18&nbsp;The VirtualGL Configuration Dialog</h1>\n\n<p><a name=\"Config_Dialog\"></a></p>\n\n<p>Several of VirtualGL&rsquo;s configuration parameters can be changed on \nthe fly once a 3D application has been started.  This is accomplished by \nusing the VirtualGL Configuration dialog, which can be popped up by \nholding down the <code>CTRL</code> and <code>SHIFT</code> keys and \npressing the <code>F9</code> key while any one of the 3D \napplication&rsquo;s windows is active.  This displays the following \ndialog box:</p>\n\n<p><img src=\"configdialog.gif\" alt=\"configdialog\" class=\"inline\" id=\"imgid_1\" name=\"imgid_1\"/></p>\n\n<p>You can use this dialog to adjust various image compression and display \nparameters in VirtualGL.  Changes are communicated immediately to \nVirtualGL.</p>\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Image Compression (Transport)</dt>\n    <dd class=\"Description-1 Description\">\n        This is a drop-down menu with the following options: <br /><br /> \n        <em>None (X11 Transport)</em> : equivalent to setting \n        <code>VGL_COMPRESS=proxy</code>. This option can be activated at any \n        time, regardless of which transport was active when VirtualGL started. \n        <br /><br /> <em>JPEG (VGL Transport)</em> : equivalent to setting \n        <code>VGL_COMPRESS=jpeg</code>.  This option is only available if the \n        VGL Transport was active when VirtualGL started. <br /><br /> <em>RGB \n        (VGL Transport)</em> : equivalent to setting \n        <code>VGL_COMPRESS=rgb</code>.  This option is only available if the VGL \n        Transport was active when VirtualGL started. <br /><br /> <em>YUV (XV \n        Transport)</em> : equivalent to setting <code>VGL_COMPRESS=xv</code>.  \n        This option is only available if the 2D X server has the X Video \n        extension and the X Video implementation supports the YUV420P (AKA \n        &ldquo;I420&rdquo;) pixel format. <br /><br /> <em>YUV (VGL \n        Transport)</em> : equivalent to setting <code>VGL_COMPRESS=yuv</code>.  \n        This option is only available if the 2D X server has the X Video \n        extension, the X Video implementation supports the YUV420P (AKA \n        &ldquo;I420&rdquo;) pixel format, and the VGL Transport was active when \n        VirtualGL started. <br /><br /> See Section \n        <a href=\"#VGL_COMPRESS\" class=\"ref\">19.1</a> for more information about \n        the <code>VGL_COMPRESS</code> configuration option.\n        <div class=\"important\"><p class=\"important\">\n        If an image transport plugin is loaded, then this menu&rsquo;s name changes to &ldquo;Image Compression&rdquo;, and it has options &ldquo;0&rdquo; through &ldquo;10&rdquo;.\n        </p></div>\n    </dd>\n    <dt class=\"Description-1 Description\">Chrominance Subsampling</dt>\n    <dd class=\"Description-1 Description\">\n        This drop-down menu is active only when using JPEG compression or an \n        image transport plugin.  It has the following options: <br /><br /> \n        <em>Grayscale</em> : equivalent to setting <code>VGL_SUBSAMP=gray</code> \n        <br /><br /> <em>1X</em> : equivalent to setting \n        <code>VGL_SUBSAMP=1x</code> <br /><br /> <em>2X</em> : equivalent to \n        setting <code>VGL_SUBSAMP=2x</code> <br /><br /> <em>4X</em> : \n        equivalent to setting <code>VGL_SUBSAMP=4x</code> <br /><br /> See \n        Section <a href=\"#VGL_SUBSAMP\" class=\"ref\">19.1</a> for more information \n        about the <code>VGL_SUBSAMP</code> configuration option.\n        <div class=\"important\"><p class=\"important\">\n        If an image transport plugin is loaded, then this menu has two additional options, &ldquo;8X&rdquo; and &ldquo;16X&rdquo;.\n        </p></div>\n    </dd>\n    <dt class=\"Description-1 Description\">JPEG Image Quality</dt>\n    <dd class=\"Description-1 Description\">\n        This slider gadget is active only when using JPEG compression or an \n        image transport plugin.  It is the equivalent of setting \n        <code>VGL_QUAL</code>.  See Section \n        <a href=\"#VGL_QUAL\" class=\"ref\">19.1</a> for more information about the \n        <code>VGL_QUAL</code> configuration option.\n        <div class=\"important\"><p class=\"important\">\n        If an image transport plugin is loaded, then this gadget&rsquo;s name changes to &ldquo;Image Quality&rdquo;.\n        </p></div>\n    </dd>\n    <dt class=\"Description-1 Description\">Connection Profile</dt>\n    <dd class=\"Description-1 Description\">\n        This drop-down menu is active only if the VGL Transport was active when \n        VirtualGL started.  It has the following options: <br /><br /> <em>Low \n        Qual (Low-Bandwidth Network)</em> : Sets the image compression type to \n        JPEG (VGL Transport), sets the Chrominance Subsampling to 4X, and sets \n        the JPEG Image Quality to 30. <br /><br /> <em>Medium Qual</em> : Sets \n        the image compression type to JPEG\t(VGL Transport), sets the Chrominance \n        Subsampling to 2X, and sets the JPEG Image Quality to 80. <br /><br /> \n        <em>High Qual (High-Bandwidth Network)</em> : Sets the image compression \n        type to JPEG (VGL Transport), sets the Chrominance Subsampling to 1X, \n        and sets the JPEG Image Quality to 95.\n    </dd>\n    <dt class=\"Description-1 Description\">Gamma Correction Factor</dt>\n    <dd class=\"Description-1 Description\">\n        This floating point input gadget is the equivalent of setting \n        <code>VGL_GAMMA</code>.  This enables VirtualGL&rsquo;s internal gamma \n        correction system with the specified gamma correction factor.  See \n        Section <a href=\"#VGL_GAMMA\" class=\"ref\">19.1</a> for more information \n        about the <code>VGL_GAMMA</code> configuration option.\n    </dd>\n    <dt class=\"Description-1 Description\">Frame Spoiling</dt>\n    <dd class=\"Description-1 Description\">\n        This toggle button is the equivalent of setting <code>VGL_SPOIL</code>.  \n        See Section <a href=\"#Frame_Spoiling\" class=\"ref\">17.2</a> and Section \n        <a href=\"#VGL_SPOIL\" class=\"ref\">19.1</a> for more information about the \n        <code>VGL_SPOIL</code> configuration option.\n    </dd>\n    <dt class=\"Description-1 Description\">Interframe Comparison</dt>\n    <dd class=\"Description-1 Description\">\n        This toggle button is the equivalent of setting \n        <code>VGL_INTERFRAME</code>.  See Section \n        <a href=\"#VGL_INTERFRAME\" class=\"ref\">19.1</a> for more information \n        about the <code>VGL_INTERFRAME</code> configuration option.\n    </dd>\n    <dt class=\"Description-1 Description\">Stereographic Rendering Method</dt>\n    <dd class=\"Description-1 Description\">\n        This drop-down menu has the following options: <br /><br /> <em>Send \n        Left Eye Only</em> : equivalent to setting <code>VGL_STEREO=left</code>. \n        <br /><br /> <em>Send Right Eye Only</em> : equivalent to setting \n        <code>VGL_STEREO=right</code> <br /><br /> <em>Quad-Buffered (if \n        available)</em> : equivalent to setting <code>VGL_STEREO=quad</code> \n        <br /><br /> <em>Anaglyphic (Red/Cyan)</em> : equivalent to setting \n        <code>VGL_STEREO=rc</code> <br /><br /> <em>Anaglyphic \n        (Green/Magenta)</em> : equivalent to setting <code>VGL_STEREO=gm</code> \n        <br /><br /> <em>Anaglyphic (Blue/Yellow)</em> : equivalent to setting \n        <code>VGL_STEREO=by</code> <br /><br /> <em>Passive (Interleaved)</em> : \n        equivalent to setting <code>VGL_STEREO=i</code> <br /><br /> <em>Passive \n        (Top/Bottom)</em> : equivalent to setting <code>VGL_STEREO=tb</code> \n        <br /><br /> <em>Passive (Side-by-Side)</em> : equivalent to setting \n        <code>VGL_STEREO=ss</code> <br /><br /> See Section \n        <a href=\"#VGL_STEREO\" class=\"ref\">19.1</a> for more information about \n        the <code>VGL_STEREO</code> configuration option.\n    </dd>\n    <dt class=\"Description-1 Description\">Limit Frames/second</dt>\n    <dd class=\"Description-1 Description\">\n        This floating point input gadget is the equivalent of setting \n        <code>VGL_FPS</code>.  See Section \n        <a href=\"#VGL_FPS\" class=\"ref\">19.1</a> for more information about the \n        <code>VGL_FPS</code> configuration option.\n    </dd>\n</dl>\n\n<p>You can set the <code>VGL_GUI</code> environment variable to change the \nkey sequence used to pop up the VirtualGL Configuration dialog.  If the \ndefault of <code>CTRL-SHIFT-F9</code> is not suitable, then set \n<code>VGL_GUI</code> to any combination of <code>ctrl</code>, \n<code>shift</code>, <code>alt</code>, and one of \n<code>f1,&nbsp;f2,...,&nbsp;f12</code> (these are not case sensitive.)  \nFor example:</p>\n\n<pre class=\"verbatim\">\nexport&nbsp;VGL_GUI=CTRL-F9\n</pre>\n\n<p>will cause the dialog box to pop up whenever <code>CTRL-F9</code> is \npressed.</p>\n\n<p>To disable the VirtualGL dialog altogether, set <code>VGL_GUI</code> to \n<code>none</code>.</p>\n\n<div class=\"important\"><p class=\"important\">\nVirtualGL monitors the application&rsquo;s X event loop to determine whenever a particular key sequence has been pressed.  If an application is not monitoring key press events in its X event loop, then the VirtualGL Configuration dialog might not pop up at all.  There is unfortunately no workaround for this, but it should be a rare occurrence.\n</p></div>\n\n<p><br /></p>\n\n<hr class=\"break\" />\n\n\n\n<h1 id=\"hd0019\"><a name=\"file019\"></a>19&nbsp;Advanced Configuration</h1>\n\n<p><a name=\"Advanced_Configuration\"></a></p>\n\n\n<h2 id=\"hd0019001\">19.1&nbsp;Server Settings</h2>\n\n<p>You can control the operation of the VirtualGL faker in four different \nways. Each method of configuration takes precedence over the previous \nmethod:</p>\n\n<ol class=\"Ordered numeric\">\n    <li class=\"Ordered-1 Ordered\">\n        Setting a configuration environment variable globally (for instance, in \n        <code>/etc/profile</code>)\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        Setting a configuration environment variable on a per-user basis (for \n        instance, in <code>~/.bashrc</code>)\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        Setting a configuration environment variable only for the current shell \n        session (for instance, <code>export&nbsp;VGL_XXX={whatever}</code>)\n    </li>\n    <li class=\"Ordered-1 Ordered\">\n        Passing a configuration option as an argument to <code>vglrun</code>.  \n        This effectively overrides any previous environment variable setting \n        corresponding to that configuration option.\n    </li>\n</ol>\n\n<p></p>\n\n<div class=\"important\"><p class=\"important\">\nIf &ldquo;Custom (if supported)&rdquo; is listed as one of the available Image Transports, then this means that image transport plugins are free to handle or ignore the configuration option as they see fit.\n</p></div>\n\n<p><a name=\"VGL_ALLOWINDIRECT\"></a></p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_ALLOWINDIRECT&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Allow applications to request an indirect OpenGL context</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">0 (all OpenGL contexts use direct rendering, unless rendering to a <a href=\"#overlays\">transparent overlay</a><a name=\"idx0041\"></a>)</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        Normally, when VirtualGL maps a Pbuffer to a window and establishes an \n        OpenGL rendering context with the Pbuffer, it forces direct rendering to \n        be used with this context.  Some 3D applications erroneously try to \n        create indirect OpenGL contexts because they detect that the X display \n        is remote and assume that the 3D rendering commands will be sent over \n        the network.  Thus, VirtualGL normally forces all contexts to be direct \n        in order to prevent severe readback performance degradation with such \n        apps (even on modern 3D adapters, and even when the connection to the 3D \n        X server is local, <code>glReadPixels()</code> can perform very slowly \n        if an indirect OpenGL context is used.) <br /><br /> However, some \n        applications intentionally try to create indirect contexts so that these \n        contexts can be shared, and those apps may not work properly when the \n        contexts are forced to be direct.  For such apps, setting \n        <code>VGL_ALLOWINDIRECT</code> to <code>1</code> will cause VirtualGL to \n        honor the application&rsquo;s request for an indirect OpenGL context.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_CLIENT&nbsp;=&nbsp;</code><em><code>{c}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglrun</code> argument</td>\n    <td class=\"standard\"><code>-cl&nbsp;</code><em><code>{c}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\"><em><code>{c}</code></em> = the hostname or IP address of the VirtualGL client</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">VGL, Custom (if supported)</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Automatically set by <code>vglconnect</code> or <code>vglrun</code></td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        When using the VGL Transport, <code>VGL_CLIENT</code> should be set to \n        the hostname or IP address of the machine on which \n        <code>vglclient</code> is running. Normally, <code>VGL_CLIENT</code> is \n        set automatically when executing <code>vglconnect</code> or \n        <code>vglrun</code>, so don&rsquo;t override it unless you know what \n        you&rsquo;re doing.\n    </dd>\n</dl>\n\n<p><a name=\"VGL_COMPRESS\"></a></p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_COMPRESS&nbsp;=&nbsp;</code><em><code>proxy&nbsp;|&nbsp;jpeg&nbsp;|&nbsp;rgb&nbsp;|&nbsp;xv&nbsp;|&nbsp;yuv</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglrun</code> argument</td>\n    <td class=\"standard\"><code>-c&nbsp;</code><em><code>proxy&nbsp;|&nbsp;jpeg&nbsp;|&nbsp;rgb&nbsp;|&nbsp;xv&nbsp;|&nbsp;yuv</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Set image transport and image compression type</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">(See description)</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n         <em>proxy</em> = Send images uncompressed using the X11 Transport.  \n         This is useful when displaying to a local 2D X server or X proxy (see \n         Section <a href=\"#X11_Proxy_Usage_Local\" class=\"ref\">9.1</a>.) \n         <br /><br /> <em>jpeg</em> = Compress images using JPEG and send using \n         the VGL Transport.  This is useful when displaying to a remote 2D X \n         server (see Chapter <a href=\"#VGL_Transport_Usage\" class=\"ref\">8</a>.) \n         <br /><br /> <em>rgb</em> = Encode images as uncompressed RGB and send \n         using the VGL Transport. This is useful when displaying to a remote 2D \n         X server or X proxy across a very fast network (see Section \n         <a href=\"#X11_Proxy_Usage_Remote\" class=\"ref\">9.2</a>.) <br /><br /> \n         <em>xv</em> = Encode images as YUV420P (planar YUV with 4X chrominance \n         subsampling) and display them to the 2D X server using the XV \n         Transport. This transport is designed for use with X proxies that \n         support the X Video extension (see Chapter \n         <a href=\"#X_Video_Support\" class=\"ref\">10</a>.) <br /><br /> \n         <em>yuv</em> = Encode images as YUV420P, send using the VGL Transport, \n         and display on the client machine using the X Video extension.  This \n         greatly reduces the CPU usage on both server and client and uses only \n         about half the network bandwidth as RGB, but the use of 4X chrominance \n         subsampling does produce some visible artifacts (see Chapter \n         <a href=\"#X_Video_Support\" class=\"ref\">10</a>.) <br /><br /> If \n         <code>VGL_COMPRESS</code> is not specified, then the default is set as \n         follows: <br /><br /> If the <code>DISPLAY</code> environment variable \n         begins with <code>:</code> or <code>unix:</code>, then VirtualGL \n         assumes that the X display connection is local and will default to \n         using <em>proxy</em> compression. <br /><br /> If VirtualGL detects \n         that the 2D X server is remote, then it will default to using \n         <em>jpeg</em> compression.\n        <div class=\"important\"><p class=\"important\">\n        If an image transport plugin is being used, then you can set <code>VGL_COMPRESS</code> to any numeric value &gt;= 0 (Default value = 0.)  The plugin can choose to respond to this value as it sees fit.\n        </p></div>\n    </dd>\n</dl>\n\n<p><a name=\"VGL_DEFAULTFBCONFIG\"></a></p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_DEFAULTFBCONFIG&nbsp;=&nbsp;</code><em><code>{attrib_list}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\"><em><code>{attrib_list}</code></em> = Attributes of the default GLX framebuffer config, which VirtualGL uses if a 3D application does not call <code>glXChooseVisual()</code> to specify the visual attributes it desires</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">None</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        Normally, a Unix OpenGL application would call the \n        <code>glXChooseVisual()</code> function to obtain an X11 visual with a \n        desired set of OpenGL attributes (such as a specific Z buffer depth, \n        etc.)  The application would then use that X visual when creating an X \n        window for OpenGL rendering.  VirtualGL&rsquo;s fundamental purpose is \n        to redirect OpenGL rendering from a window on one X server (the 2D X \n        server) to a Pbuffer on another X server (the 3D X server.)  Thus, for \n        every OpenGL-enabled X visual that the application tries to obtain, \n        VirtualGL needs to obtain an equivalent &ldquo;GLX FB config&rdquo;, \n        which is like an X visual for Pbuffers.  VirtualGL does this by \n        intercepting <code>glXChooseVisual()</code> and using the attributes \n        passed to that function to build an attribute list for \n        <code>glXChooseFBConfig()</code>, which is called on the 3D X server.  \n        The FB config returned from <code>glXChooseFBConfig()</code> is mapped \n        internally to an X visual on the 2D X server, and that visual is \n        returned from <code>glXChooseVisual()</code>.  The FB config is later \n        used when creating the Pbuffer that backs a 3D application window. \n        <br /><br /> In rare cases, an application may choose to implement its \n        own visual selection mechanism rather than call \n        <code>glXChooseVisual()</code>.  Such applications will iterate through \n        the list of X visuals and examine the OpenGL attributes of each using \n        <code>glXGetConfig()</code>.  The problem is this:  whereas in a \n        &ldquo;normal&rdquo; GLX environment, there would be a 1:1 \n        correspondence between X visuals and GLX FB configs, in \n        VirtualGL&rsquo;s split rendering environment, X visuals are on the 2D X \n        server and GLX FB configs are on the 3D X server. Thus, if an \n        application calls <code>glXGetConfig()</code> before calling \n        <code>glXChooseVisual()</code>, VirtualGL has not yet mapped the X \n        visual in question to a GLX FB config, and furthermore, VirtualGL has no \n        idea what type of visual the application is looking for.  In such cases, \n        VGL has to map the visual to a default FB config.  Since this default FB \n        config is very basic, if the application is hunting for a visual with a \n        particular OpenGL attribute (such as an alpha channel or a stencil \n        buffer), then it may fail to find one. <br /><br /> \n        <code>VGL_DEFAULTFBCONFIG</code> allows the user to specify the \n        attributes of VirtualGL&rsquo;s default FB config.  This may be \n        necessary to make certain applications work, if those applications do \n        not use <code>glXChooseVisual()</code> to obtain a visual.  The \n        attribute list is specified in the same way that you would specify an \n        attribute list for <code>glXChooseFBConfig()</code>.  Example: \n        <code>VGL_DEFAULTFBCONFIG&nbsp;=&nbsp;GLX_ALPHA_SIZE,8,GLX_STENCIL_SIZE,8</code>.  \n        See <a href=\"#Application_Recipes\">Application \n        Recipes</a><a name=\"idx0042\"></a> for a list of applications that are \n        known to require the use of this configuration option.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_DISPLAY&nbsp;=&nbsp;</code><em><code>{d}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglrun</code> argument</td>\n    <td class=\"standard\"><code>-d&nbsp;</code><em><code>{d}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\"><em><code>{d}</code></em> = the X display to use for 3D rendering</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">:0</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        If the VirtualGL server has multiple GPUs, each attached to a separate X \n        screen or a separate X server, then you can use this option to specify \n        which GPU should be used for 3D rendering.  For instance, setting \n        <code>VGL_DISPLAY</code> to (or invoking <code>vglrun&nbsp;-d</code> \n        with) <code>:0.1</code> would cause VirtualGL to redirect all of the 3D \n        rendering from the application to a GPU attached to Screen 1 on X \n        display :0.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_EXCLUDE&nbsp;=&nbsp;</code><em><code>{d1[,d2,d3,...]}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\"><em><code>{d1[,d2,d3,...]}</code></em> = A comma-separated list of X displays for which the VirtualGL interposer should be bypassed</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">None</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        In certain parallel rendering applications, it may be desirable to \n        directly access multiple GPUs from within worker threads and to disable \n        VirtualGL for those threads while leaving VirtualGL enabled for the main \n        thread, which displays the final rendered result from all of the \n        workers. <br /><br /> The <code>VGL_EXCLUDE</code> environment variable \n        specifies a list of X display names (for instance, &ldquo;:0.1&rdquo;) \n        for which VirtualGL should not interpose any X11, GLX, OpenGL, or XCB \n        calls.  In other words, VirtualGL treats these displays as 3D X servers \n        instead of 2D X servers and does not attempt to redirect 3D rendering \n        away from them.  When an X display connection is opened using \n        <code>XOpenDisplay()</code>, VirtualGL checks if the display name \n        appears in the exclude list, and if so, all subsequent X11, GLX, OpenGL, \n        and XCB calls intended for that display are allowed to pass through \n        unimpeded.  This variable is re-checked every time \n        <code>XOpenDisplay()</code> is called, so it can be set dynamically from \n        within an application.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_FAKEXCB&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglrun</code> argument</td>\n    <td class=\"standard\"><code>-xcb</code> / <code>+xcb</code></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Disable/enable XCB interposer</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Enabled</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        Qt 5 uses XCB instead of Xlib to perform all non-OpenGL X11-related \n        operations.  Thus, in order to support Qt 5 applications, VirtualGL has \n        to interpose enough of the XCB API to allow it to intercept window \n        resize events and to make Qt 5 believe that a GLX extension is present, \n        even when the 2D X server doesn&rsquo;t support GLX.  The XCB interposer \n        in this release of VirtualGL should be non-intrusive, and thus it is \n        enabled by default, and this option is provided only for troubleshooting \n        purposes. You shouldn&rsquo;t need to disable the XCB interposer unless \n        unforeseen problems are encountered.\n    </dd>\n</dl>\n\n<p><a name=\"VGL_FORCEALPHA\"></a></p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_FORCEALPHA&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Force the Pbuffers used for 3D rendering to have an 8-bit alpha channel</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\"><code>VGL_FORCEALPHA=1</code> if PBO readback mode is used, <code>VGL_FORCEALPHA=0</code> otherwise</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        Normally, VirtualGL will create Pbuffers whose attributes match those of \n        the visuals requested by the 3D application.  Setting \n        <code>VGL_FORCEALPHA</code> to <code>1</code> causes VirtualGL to always \n        create Pbuffers with alpha channels.  This means that a 32-bit-per-pixel \n        (BGRA) Pbuffer will be created if the application requests a \n        24-bit-per-pixel visual. <br /><br /> The primary purpose of this option \n        is to work around a limitation of certain consumer-grade GPUs, whereby \n        the pixel format requested by the pixel readback operation must match \n        the pixel format of the Pbuffer in order for pixel buffer objects (PBOs) \n        to behave correctly.  Since displaying to an X proxy typically requires \n        VirtualGL to read back pixels in the BGRA format, enabling \n        <code>VGL_FORCEALPHA</code> might be necessary in order to use PBO \n        readback mode with the afore-mentioned GPUs (as of this writing, nVidia \n        GeForce adapters are known to require this.)  See the \n        <a href=\"#VGL_READBACK\"><code>VGL_READBACK</code></a><a name=\"idx0043\"></a> \n        option for further information.\n        <div class=\"important\"><p class=\"important\">\n        <code>VGL_FORCEALPHA</code> overrides the application&rsquo;s choice of visuals.  It has no effect if the application is not explicitly choosing a visual.  In that case, use <a href=\"#VGL_DEFAULTFBCONFIG\"><code>VGL_DEFAULTFBCONFIG</code></a><a name=\"idx0044\"></a> instead.\n        </p></div>\n    </dd>\n</dl>\n\n<p><a name=\"VGL_FPS\"></a></p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_FPS&nbsp;=&nbsp;</code><em><code>{f}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglrun</code> argument</td>\n    <td class=\"standard\"><code>-fps&nbsp;</code><em><code>{f}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Limit the end-to-end frame rate to <em><code>{f}</code></em> frames/second, where <em><code>{f}</code></em> is a floating point number &gt; 0.0</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">VGL, X11, XV, Custom (if supported)</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">0.0 (No limit)</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        This option prevents VirtualGL from sending frames at a rate faster than \n        the specified limit.  It can be used, for instance, as a crude way to \n        control network bandwidth or CPU usage in multi-user environments in \n        which those resources are constrained. <br /><br /> If frame spoiling is \n        disabled, then setting <code>VGL_FPS</code> effectively limits the \n        server&rsquo;s 3D rendering frame rate as well.\n    </dd>\n</dl>\n\n<p><a name=\"VGL_GAMMA\"></a></p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_GAMMA&nbsp;=&nbsp;</code><em><code>{g}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglrun</code> argument</td>\n    <td class=\"standard\"><code>-gamma&nbsp;</code><em><code>{g}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Specify gamma correction factor</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">1.00 (no gamma correction)</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        &ldquo;Gamma&rdquo; refers to the relationship between the intensity of \n        light that your computer&rsquo;s monitor is instructed to display and \n        the intensity that it actually displays.  The curve is an exponential \n        curve of the form <em>Y = X<sup>G</sup></em>, where X is between 0 and \n        1.  G is called the &ldquo;gamma&rdquo; of the monitor.  PC monitors and \n        TVs usually have a gamma of around 2.2. <br /><br /> Some of the math \n        involved in 3D rendering assumes a linear gamma (G = 1.0), so \n        technically speaking, 3D applications will not display with mathematical \n        correctness unless the pixels are &ldquo;gamma corrected&rdquo; to \n        counterbalance the non-linear response curve of the monitor.  However, \n        some systems do not have any form of built-in gamma correction, so the \n        applications developed for such systems have usually been designed to \n        display properly without gamma correction.  Gamma correction involves \n        passing pixels through a function of the form <em>X = \n        W<sup>1/G</sup></em>, where G is the &ldquo;gamma correction \n        factor&rdquo; and should be equal to the gamma of the monitor.  So, the \n        final output is <em>Y = X<sup>G</sup> = (W<sup>1/G</sup>)<sup>G</sup> = \n        W</em>, which describes a linear relationship between the intensity of \n        the pixels drawn by the application and the intensity of the pixels \n        displayed by the monitor. <br /><br /> If <code>VGL_GAMMA</code> is set \n        to an arbitrary floating point value, then VirtualGL will perform gamma \n        correction on all of the rendered 3D images from the application, using \n        the specified value as the gamma correction factor.  You can also \n        specify a negative value to apply a &ldquo;de-gamma&rdquo; function.  \n        Specifying a gamma correction factor of G (where G &lt; 0) is equivalent \n        to specifying a gamma correction factor of -1/G.\n    </dd>\n</dl>\n\n<p><a name=\"VGL_GLFLUSHTRIGGER\"></a></p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_GLFLUSHTRIGGER&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Disable/enable reading back and sending the front buffer contents whenever the 3D application calls <code>glFlush()</code> while rendering to the front buffer</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Enabled</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        <code>glFlush()</code> is a sort of &ldquo;asynchronous \n        synchronization&rdquo; command.  It flushes the OpenGL command buffers, \n        which generally has the effect of ensuring that the commands have been \n        delivered to the GPU. However, unlike <code>glFinish()</code>, \n        <code>glFlush()</code> does not wait until the commands have been \n        rendered before it returns. <br /><br /> The use of \n        <code>glFlush()</code> can vary widely from application to application. \n        When doing front buffer rendering, some applications call \n        <code>glFlush()</code> after each object is rendered.  Some call it only \n        at the end of the frame.  Others call <code>glFlush()</code> much more \n        often, even as frequently as every time a few primitives are rendered.  \n        This creates problems for VirtualGL, since it has to guess what the \n        application is intending to do.  Not all applications that use front \n        buffer rendering call <code>glFinish()</code> to signal the end of a \n        frame, so VirtualGL cannot usually get away with ignoring \n        <code>glFlush()</code>.  However, some applications call \n        <code>glFlush()</code> so often that VirtualGL cannot get away with \n        reading back/sending a frame every time <code>glFlush()</code> is \n        called, either (see \n        <a href=\"#VGL_SPOILLAST\">VGL_SPOILLAST</a><a name=\"idx0045\"></a> for \n        more information on how VirtualGL tries to handle this, under normal \n        circumstances.) <br /><br /> Some 3D applications use \n        <code>glFlush()</code> very liberally and intend for it to be an \n        intermediate rather than a final synchronization command.  Such \n        applications will call <code>glFinish()</code> after a sequence of \n        <code>glFlush()</code> calls, so for those applications, reading back \n        and sending the rendered 3D image in response to <code>glFlush()</code> \n        calls is a waste of resources and can sometimes create visual artifacts \n        (for instance, if the application clears the front buffer with a \n        particular color, calls <code>glFlush()</code>, then clears it again \n        with another color.  We wouldn&rsquo;t mention it if it hadn&rsquo;t \n        happened before.)  For such applications, setting \n        <code>VGL_GLFLUSHTRIGGER</code> to <code>0</code> should make them \n        display properly in VirtualGL.  See \n        <a href=\"#Application_Recipes\">Application \n        Recipes</a><a name=\"idx0046\"></a> for a list of applications that are \n        known to require this.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_GLLIB&nbsp;=&nbsp;</code><em><code>{l}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\"><em><code>{l}</code></em> = the location of an alternate OpenGL library</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        Normally VirtualGL will call the <code>glXGetProcAddress()</code> or \n        <code>glXGetProcAddressARB()</code> function in the OpenGL library \n        against which it or the 3D application was linked (usually \n        <code>libGL.so.1</code>, in the system library path), and VGL will use \n        that function to load any\tother &ldquo;real&rdquo; OpenGL or GLX \n        functions that it needs to call (&ldquo;real&rdquo; as opposed to the \n        &ldquo;fake&rdquo;, or &ldquo;interposed&rdquo;, versions of those \n        functions that VirtualGL provides, which often modify the arguments or \n        perform other operations before calling the &ldquo;real&rdquo; \n        functions.)  You can use the <code>VGL_GLLIB</code> environment variable \n        to specify the path of a dynamic library from which VirtualGL should \n        load &ldquo;real&rdquo; GLX and OpenGL functions. <br /><br /> You \n        shouldn&rsquo;t need to change this unless something doesn&rsquo;t work.  \n        However, setting this environment variable is potentially useful if one \n        wishes to insert another OpenGL interposer between VirtualGL and the \n        system&rsquo;s OpenGL library.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_GUI&nbsp;=&nbsp;</code><em><code>{k}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\"><em><code>{k}</code></em> = the key sequence used to pop up the VirtualGL Configuration dialog, or <code>none</code> to disable the dialog</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">shift-ctrl-f9</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        VirtualGL will normally monitor an application&rsquo;s X event queue and \n        pop up the VirtualGL Configuration dialog whenever \n        <code>CTRL-SHIFT-F9</code> is pressed.  In the event that this \n        interferes with a key sequence that the application is already using, \n        then you can redefine the key sequence used to pop up the VirtualGL \n        Configuration dialog by setting <code>VGL_GUI</code> to some combination \n        of <code>shift</code>, <code>ctrl</code>, <code>alt</code>, and one of \n        <code>f1,&nbsp;f2,&nbsp;...,&nbsp;f12</code>. You can also set \n        <code>VGL_GUI</code> to <code>none</code> to disable the configuration \n        dialog altogether.  See Chapter \n        <a href=\"#Config_Dialog\" class=\"ref\">18</a> for more details.\n    </dd>\n</dl>\n\n<p><a name=\"VGL_INTERFRAME\"></a></p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_INTERFRAME&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Enable or disable interframe image comparison</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">VGL (JPEG, RGB), Custom (if supported)</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Enabled</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        The VGL Transport will normally compare each frame with the previous \n        frame and send only the portions of the image that have changed. Setting \n        <code>VGL_INTERFRAME</code> to <code>0</code> disables this behavior. \n        <br /><br /> This setting was introduced in order to work around a \n        specific application interaction issue, but since a proper fix for that \n        issue was introduced in VirtualGL 2.1.1, this option isn&rsquo;t really \n        useful anymore.\n        <div class=\"important\"><p class=\"important\">\n        When using the VGL Transport, interframe comparison is affected by the <a href=\"#VGL_TILESIZE\"><code>VGL_TILESIZE</code></a><a name=\"idx0047\"></a> option\n        </p></div>\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_LOG&nbsp;=&nbsp;</code><em><code>{l}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Redirect all messages from VirtualGL to a log file specified by <em><code>{l}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Print all messages to stderr</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        Setting this environment variable to the pathname of a log file on the \n        VirtualGL server will cause VirtualGL to redirect all of its messages \n        (including profiling and trace output) to the specified log file rather \n        than to stderr.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_LOGO&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Enable or disable the display of a VGL logo in the 3D window(s)</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Disabled</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        Setting <code>VGL_LOGO</code> to <code>1</code> will cause VirtualGL to \n        display a small logo in the bottom right-hand corner of all of the \n        application&rsquo;s 3D windows.  This is meant as a debugging tool to \n        allow users to determine whether or not VirtualGL is active.\n    </dd>\n</dl>\n\n<p><a name=\"VGL_NPROCS\"></a></p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_NPROCS&nbsp;=&nbsp;</code><em><code>{n}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglrun</code> argument</td>\n    <td class=\"standard\"><code>-np&nbsp;</code><em><code>{n}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\"><em><code>{n}</code></em> = the number of CPUs to use for multi-threaded compression</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">VGL (JPEG, RGB), Custom (if supported)</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">1</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        The VGL Transport can divide the task of compressing each frame among \n        multiple server CPUs.  This might speed up the overall throughput in \n        rare circumstances in which the server CPUs are significantly slower \n        than the client CPUs. <br /><br /> VirtualGL will not allow more than 4 \n        CPUs total to be used for compression, nor will it allow you to set this \n        parameter to a value greater than the number of CPUs in the system.\n        <div class=\"important\"><p class=\"important\">\n        When using the VGL Transport, multi-threaded compression is affected by the <a href=\"#VGL_TILESIZE\"><code>VGL_TILESIZE</code></a><a name=\"idx0048\"></a> option\n        </p></div>\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_PORT&nbsp;=&nbsp;</code><em><code>{p}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglrun</code> argument</td>\n    <td class=\"standard\"><code>-p&nbsp;</code><em><code>{p}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\"><em><code>{p}</code></em> = the TCP port to use when connecting to the VirtualGL Client</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">VGL, Custom (if supported)</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Read from X property stored by VirtualGL Client</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        The connection port for the VGL Transport is normally determined by \n        reading an X property that <code>vglclient</code> stores on the 2D X \n        server, so don&rsquo;t override this unless you know what you&rsquo;re \n        doing.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_PROFILE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglrun</code> argument</td>\n    <td class=\"standard\"><code>-pr</code> / <code>+pr</code></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Disable/enable profiling output</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">VGL, X11, XV, Custom (if supported)</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Disabled</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        If profiling output is enabled, then VirtualGL will continuously \n        benchmark itself and periodically print out the throughput of various \n        stages in its image pipeline. <br /><br /> See Chapter \n        <a href=\"#Perf_Measurement\" class=\"ref\">17</a> for more details.\n    </dd>\n</dl>\n\n<p><a name=\"VGL_QUAL\"></a></p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_QUAL&nbsp;=&nbsp;</code><em><code>{q}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglrun</code> argument</td>\n    <td class=\"standard\"><code>-q&nbsp;</code><em><code>{q}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\"><em><code>{q}</code></em> = the JPEG compression quality, 1 &lt;= <em><code>{q}</code></em> &lt;= 100</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">VGL (JPEG), Custom (if supported)</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">95</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        In digital images, &ldquo;frequency&rdquo; refers to how quickly the \n        color changes between light and dark as you move either horizontally or \n        vertically in the image.  Images with very sharp, bright features on a \n        dark background, for instance, consist of both low-frequency and \n        high-frequency components, whereas images with smooth transitions \n        between neighboring pixels contain only low-frequency components.  JPEG \n        compression works by breaking down the image into its constituent \n        frequencies and then throwing out the highest of these frequencies.  The \n        JPEG image &ldquo;quality&rdquo; determines which frequencies are thrown \n        out.  A JPEG quality of 1 throws out all but the lowest frequencies and \n        thus produces a very impressionistic, but generally not very useful, \n        compressed image.  A JPEG quality of 100 retains all frequencies in the \n        original image (but, due to roundoff errors, the compressed image is \n        still not completely lossless.) <br /><br /> Because the human eye \n        usually cannot detect the highest frequencies in the image, and often \n        because the image lacks those high-frequency elements to begin with, a \n        sufficiently high JPEG quality setting can produce a &ldquo;perceptually \n        lossless&rdquo; image.  A &ldquo;perceptually lossless&rdquo; image \n        contains a small amount of mathematical error when compared to the \n        original image, but this error is so small that, under normal \n        circumstances, human vision cannot detect it.  The threshold quality \n        level at which JPEG compression becomes perceptually lossless is \n        different for each image, but experiments with various visual difference \n        benchmarks (such as \n        <span class=\"remote\"><a href=\"http://www.mpi-inf.mpg.de/resources/hdr/vdp/\" class=\"remote\">HDR-VDP</a></span><a name=\"idx0049\"></a>) \n        suggest that\ta JPEG quality of 95 is sufficient to guarantee perceptual \n        losslessness for the types of applications (volume visualization apps, \n        in particular) in which image quality is critical.  As with any \n        benchmarks, Your Mileage May Vary. Those who are particularly paranoid \n        about image quality can set the JPEG quality to 100 or use RGB encoding, \n        but a fast network is required for both. <br />\n        <div class=\"important\"><p class=\"important\">\n        If using an image transport plugin, then this setting need not necessarily correspond to JPEG image quality.  The plugin can choose to respond to the <code>VGL_QUAL</code> option as it sees fit.\n        </p></div>\n    </dd>\n</dl>\n\n<p><a name=\"VGL_READBACK\"></a></p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_READBACK&nbsp;=&nbsp;</code><em><code>none&nbsp;|&nbsp;pbo&nbsp;|&nbsp;sync</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Specify the method used by VirtualGL to read back the 3D pixels from the 3D graphics adapter</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">pbo</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n    </dd>\n</dl>\n<ul class=\"Itemize\">\n    <li class=\"Itemize-1 Itemize asterisk\">\n        <em>none</em> = Do not read back the 3D pixels at all.  On rare \n        occasions, it might be desirable to have VirtualGL redirect OpenGL \n        rendering from an application&rsquo;s window into a Pbuffer but not \n        automatically read back and send the rendered pixels.  Some applications \n        have their own mechanisms for reading back the rendered pixels, so \n        setting <code>VGL_READBACK=none</code> disables VirtualGL&rsquo;s \n        readback mechanism and prevents duplication of effort. <br /><br /> This \n        option was developed initially to support running \n        <span class=\"remote\"><a href=\"http://www.paraview.org/\" class=\"remote\">ParaView</a></span><a name=\"idx0050\"></a> \n        in parallel using MPI.  ParaView/MPI normally uses MPI Processes 1 \n        through N as rendering servers, each rendering a portion of the geometry \n        into a separate window on a separate X display. ParaView reads back \n        these server windows and composites the pixels into the main application \n        window, which is controlled by MPI Process 0.  By creating a script that \n        passes a different value of <code>VGL_DISPLAY</code> and \n        <code>VGL_READBACK</code> to each MPI process, it is possible to make \n        all of the ParaView server processes render to off-screen buffers on \n        different GPUs while preventing VirtualGL from displaying any pixels \n        except those generated by Process 0. <br /><br />\n    </li>\n    <li class=\"Itemize-1 Itemize asterisk\">\n        <em>pbo</em> = PBO readback mode.  Attempt to use pixel buffer objects \n        (PBOs) to read back the 3D pixels from the GPU.  A PBO is an opaque \n        memory buffer managed by OpenGL, so it can be locked down for direct DMA \n        transfers.  This improves readback performance as well as makes the \n        readback operation non-blocking.  Because PBOs are managed buffers, \n        VirtualGL has to perform an additional memory copy to transfer the \n        pixels out of the PBO and into the image transport&rsquo;s buffer.  \n        However, on high-end GPUs, PBO readback mode will still generally \n        perform better than synchronous readback mode, even with this additional \n        memory copy.  Further, since the non-blocking nature of PBO readback \n        reduces the load on the GPU, PBOs can improve performance dramatically \n        when multiple simultaneous users are sharing a professional-grade GPU. \n        <br /><br /> As of this writing, some nVidia GeForce adapters will fall \n        back to using blocking readbacks if the pixel format requested in the \n        pixel read operation does not match the pixel format of the Pbuffer.  If \n        VirtualGL detects that this is occurring&ndash; that is, if PBOs are no \n        longer behaving asynchronously&ndash; then VGL will fall back to \n        synchronous readback mode until the next time the compression  type is \n        changed.  If you are using an X proxy, then this situation could occur \n        because the X proxy&rsquo;s virtual framebuffer is BGRA but, unless the \n        application has requested an alpha channel, its Pbuffer is likely BGR.  \n        In this specific case, setting the \n        <a href=\"#VGL_FORCEALPHA\"><code>VGL_FORCEALPHA</code></a><a name=\"idx0051\"></a> \n        option to <code>1</code> could alleviate the issue. <br /><br />\n    </li>\n    <li class=\"Itemize-1 Itemize asterisk\">\n        <em>sync</em> = Synchronous readback mode.  This disables the use of \n        PBOs altogether, which causes VirtualGL to always use blocking pixel \n        readback operations. <br /><br /> Setting <code>VGL_VERBOSE=1</code> \n        will cause VirtualGL to print the current readback mode being used, as \n        well as the pixel format requested by the readback operation and the \n        pixel format of the Pbuffer.  Additionally, a notification will be \n        printed if VirtualGL falls back from PBO readback mode to synchronous \n        readback mode.\n    </li>\n</ul>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_REFRESHRATE&nbsp;=&nbsp;</code><em><code>{r}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\"><em><code>{r}</code></em> = the &ldquo;virtual&rdquo; refresh rate, in Hz, for the GLX_EXT_swap_control and GLX_SGI_swap_control extensions</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">60.0</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        The GLX_EXT_swap_control and GLX_SGI_swap_control extensions allow \n        applications to specify that buffer swaps should be synchronized with \n        the refresh rate of the monitor.  When one of these extensions is used, \n        <code>glXSwapBuffers()</code> will not return until a specified number \n        of refreshes (the &ldquo;swap interval&rdquo;) has occurred.  Although \n        refresh rate has no meaning when rendering into an off-screen buffer, \n        VirtualGL still emulates the swap control extensions so that \n        applications can control their own frame rate (this is often used by \n        games, for instance, in which maintaining a constant frame rate is \n        important.)  VirtualGL uses an internal timer to emulate the refresh \n        rate, and setting <code>VGL_REFRESHRATE</code> changes the interval of \n        that timer.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_SAMPLES&nbsp;=&nbsp;</code><em><code>{s}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglrun</code> argument</td>\n    <td class=\"standard\"><code>-ms&nbsp;</code><em><code>{s}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Force OpenGL multisampling to be enabled with <em><code>{s}</code></em> samples.  <em><code>{s}</code></em> = 0 to force OpenGL multisampling to be disabled.</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Allow the 3D application to determine the level of multisampling</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        This option was added primarily because certain vendor-specific methods \n        of enabling full-scene antialiasing at a global level (such as \n        nVidia&rsquo;s <code>__GL_FSAA_MODE</code> environment variable) do not \n        work with Pbuffers and, subsequently, do not work with VirtualGL.  If \n        <code>VGL_SAMPLES</code> is &gt; 0, then VirtualGL will attempt to \n        create Pbuffers with the specified number (or a greater number) of \n        samples.  This effectively forces the 3D application to render with the \n        specified multisampling level, as if the application had explicitly \n        passed attributes of <code>GLX_SAMPLES</code>, <em><code>{s}</code></em> \n        to <code>glXChooseVisual()</code>.  If <code>VGL_SAMPLES</code> is \n        <code>0</code>, then VirtualGL forces multisampling to be disabled, even \n        if the 3D application explicitly tries to enable it.\n        <div class=\"important\"><p class=\"important\">\n        <code>VGL_SAMPLES</code> overrides the application&rsquo;s choice of visuals.  It has no effect if the application is not explicitly choosing a visual.  In that case, use <a href=\"#VGL_DEFAULTFBCONFIG\"><code>VGL_DEFAULTFBCONFIG</code></a><a name=\"idx0052\"></a> instead.\n        </p></div>\n        <div class=\"important\"><p class=\"important\">\n        Multisampling cannot be used with Pixmap rendering.  Any application that uses Pixmap rendering will fail if <code>VGL_SAMPLES</code> is set to a value other than 0.\n        </p></div>\n    </dd>\n</dl>\n\n<p><a name=\"VGL_SPOIL\"></a></p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_SPOIL&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglrun</code> argument</td>\n    <td class=\"standard\"><code>-sp</code> / <code>+sp</code></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Disable/enable frame spoiling</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">VGL, X11, XV, Custom (if supported)</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Enabled</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        In remote display environments, the mouse movement is generally sampled \n        at least 40 and sometimes 60 times per second.  Therefore, unless \n        VirtualGL is able to deliver at least that number of frames per second, \n        the movement of a 3D scene will appear to lag behind the mouse motion.  \n        This is because the server is trying to render a new frame for every \n        mouse motion event, but if the image transport and (if applicable) the \n        client cannot process the frames fast enough, the server&rsquo;s TCP \n        buffers quickly fill up, causing increased delay in the delivery of each \n        frame. VirtualGL&rsquo;s default behavior is to compensate for this by \n        dropping (spoiling) each frame that the transport isn&rsquo;t ready to \n        receive.  This ensures that the movement of the 3D scene will appear to \n        &ldquo;keep up&rdquo; with the mouse, even though not all rendered \n        frames are actually being delivered. <br /><br /> Frame spoiling is \n        usually necessary with interactive applications, but it should be turned \n        off when running benchmarks or other non-interactive applications.  \n        Turning off frame spoiling will force every frame rendered on the server \n        to be delivered through the image transport, and thus the frame rate \n        reported by OpenGL benchmarks will accurately reflect the end-to-end \n        performance of VirtualGL (though, in X proxy environments, this may \n        still not accurately reflect the frame rate seen by the user.  See \n        Section <a href=\"#Frame_Spoiling\" class=\"ref\">17.2</a>.)  Disabling \n        frame spoiling also prevents non-interactive applications from wasting \n        graphics resources by rendering frames that will never be seen.\n    </dd>\n</dl>\n\n<p><a name=\"VGL_SPOILLAST\"></a></p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_SPOILLAST&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Disable/enable &ldquo;spoil last&rdquo; frame spoiling algorithm for frames triggered by <code>glFlush()</code></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">VGL, X11, XV, Custom (if supported)</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Enabled</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        VirtualGL will normally read back a rendered 3D image if the 3D \n        application calls <code>glXSwapBuffers()</code> while rendering to the \n        back buffer or if the 3D application calls <code>glFinish()</code>, \n        <code>glFlush()</code>, or <code>glXWaitGL()</code> while rendering to \n        the front buffer.  When frame spoiling is enabled and the image \n        transport is busy compressing/sending a frame, the newly-rendered frame \n        is normally promoted to the head of the queue, and the rest of the \n        frames in the queue are &ldquo;spoiled&rdquo; (discarded.)  This \n        algorithm, called &ldquo;spoil first&rdquo;, ensures that when a frame \n        is actually delivered through the image transport (rather than spoiled), \n        the delivered frame will be the most recently rendered frame.  However, \n        this algorithm requires that VirtualGL read back every frame that the \n        application renders, even if the frame is ultimately discarded. \n        <br /><br /> Some applications call <code>glFlush()</code> many \n        thousands of times per frame while rendering to the front buffer.  Thus, \n        VirtualGL&rsquo;s default behavior is to use a different spoiling \n        algorithm, &ldquo;spoil last&rdquo;, to process frames triggered by \n        <code>glFlush()</code> calls.  &ldquo;Spoil last&rdquo; discards the \n        most recently rendered frame if the image transport is busy.  Thus, the \n        only frames that are read back from the Pbuffer are the frames that are \n        actually delivered through the image transport.  However, there is no \n        guarantee in this case that the delivered frame will be the most \n        recently rendered frame, so applications that perform front buffer \n        rendering and call <code>glFlush()</code> in response to an interactive \n        operation may not display properly.  For such applications, setting the \n        <code>VGL_SPOILLAST</code> environment variable to <code>0</code> prior \n        to launching the application with <code>vglrun</code> will cause the \n        &ldquo;spoil first&rdquo; algorithm to be used for all frame triggers, \n        including <code>glFlush()</code>.  This should fix the display problem, \n        at the expense of increased load on the GPU (because VirtualGL is now \n        reading back the rendered 3D image every time <code>glFlush()</code> is \n        called.)  See <a href=\"#Application_Recipes\">Application \n        Recipes</a><a name=\"idx0053\"></a> for a list of applications that are \n        known to require this.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_SSL&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglrun</code> argument</td>\n    <td class=\"standard\"><code>-s</code> / <code>+s</code></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Disable/enable SSL encryption of the image transport</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">VGL, Custom (if supported)</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Disabled</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        Enabling this option causes the VGL Transport to be tunneled through a \n        secure socket layer (SSL.)\n        <div class=\"important\"><p class=\"important\">\n        This option has no effect unless both the VirtualGL server and client were built with OpenSSL support.\n        </p></div>\n    </dd>\n</dl>\n\n<p><a name=\"VGL_STEREO\"></a></p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_STEREO&nbsp;=&nbsp;</code><em><code>left&nbsp;|&nbsp;right&nbsp;|&nbsp;quad&nbsp;|&nbsp;rc&nbsp;|&nbsp;gm&nbsp;|&nbsp;by&nbsp;|&nbsp;i&nbsp;|&nbsp;tb&nbsp;|&nbsp;ss</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglrun</code> argument</td>\n    <td class=\"standard\"><code>-st&nbsp;</code><em><code>left&nbsp;|&nbsp;right&nbsp;|&nbsp;quad&nbsp;|&nbsp;rc&nbsp;|&nbsp;gm&nbsp;|&nbsp;by&nbsp;|&nbsp;i&nbsp;|&nbsp;tb&nbsp;|&nbsp;ss</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Specify the delivery method for stereo images</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">quad</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n         <em>left</em> = When an application renders a stereo frame, send only \n         the left eye buffer <br /><br /> <em>right</em> = When an application \n         renders a stereo frame, send only the right eye buffer <br /><br /> \n         <em>quad</em> = Attempt to use quad-buffered stereo, which will result \n         in a pair of images being sent to the VirtualGL Client for every frame.  \n         Using quad-buffered stereo requires the VGL Transport (or a transport \n         plugin that can handle stereo image pairs.)  Using quad-buffered stereo \n         with the VGL Transport also requires that the 2D X server support \n         OpenGL and be connected to a GPU that supports stereo rendering.  The \n         2D X server should additionally be configured to export stereo visuals.  \n         Quad-buffered stereo is not supported when using the VGL Transport with \n         YUV encoding.  If quad-buffered stereo is requested but the transport \n         or the client does not support it, then VirtualGL will fall back to \n         using anaglyphic stereo. <br /><br /> <em>rc</em> = Use Red/Cyan \n         (anaglyphic) stereo, even if quad-buffered is available <br /><br /> \n         <em>gm</em> = Use Green/Magenta (anaglyphic) stereo, even if \n         quad-buffered is available <br /><br /> <em>by</em> = Use Blue/Yellow \n         (anaglyphic) stereo, even if quad-buffered is available <br /><br /> \n         <em>i</em> = Use Interleaved (passive) stereo, even if quad-buffered is \n         available <br /><br /> <em>tb</em> = Use Top/Bottom (passive) stereo, \n         even if quad-buffered is available <br /><br /> <em>ss</em> = Use \n         Side-by-Side (passive) stereo, even if quad-buffered is available \n         <br /><br /> See Chapter <a href=\"#Advanced_OpenGL\" class=\"ref\">16</a> \n         for more details.\n    </dd>\n</dl>\n\n<p><a name=\"VGL_SUBSAMP\"></a></p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_SUBSAMP&nbsp;=&nbsp;</code><em><code>gray&nbsp;|&nbsp;1x&nbsp;|&nbsp;2x&nbsp;|&nbsp;4x&nbsp;|&nbsp;8x&nbsp;|&nbsp;16x</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglrun</code> argument</td>\n    <td class=\"standard\"><code>-samp&nbsp;</code><em><code>gray&nbsp;|&nbsp;1x&nbsp;|&nbsp;2x&nbsp;|&nbsp;4x&nbsp;|&nbsp;8x&nbsp;|&nbsp;16x</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Specify the level of chrominance subsampling in the JPEG image compressor</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">VGL (JPEG), Custom (if supported)</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">1x</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        When an image is compressed using JPEG, each pixel in the image is first \n        converted from RGB (Red/Green/Blue) to YCbCr.  An RGB pixel has three \n        values that specify the amounts of red, green, and blue that make up the \n        pixel&rsquo;s color.  A YCbCr pixel has three values that specify the \n        overall brightness of the pixel (Y, or &ldquo;luminance&rdquo;) and the \n        overall color of the pixel (Cb and Cr, or &ldquo;chrominance&rdquo;.)\n        <div class=\"important\"><p class=\"important\">\n        NOTE: in the digital world, the terms &ldquo;YCbCr&rdquo; and &ldquo;YUV&rdquo; are often used interchangeably.  Per the convention of the image processing and digital video communities, we use &ldquo;YCbCr&rdquo; when discussing JPEG compression and &ldquo;YUV&rdquo; when discussing video formats, but they are really the same thing.\n        </p></div>\n        Since the human eye is less sensitive to changes in color than it is to \n        changes in brightness, the chrominance components for some of the pixels \n        can be discarded without much noticeable loss in image quality.  This \n        technique, called &ldquo;chrominance subsampling&rdquo;, significantly \n        reduces the size of the compressed image. <br /><br /> <em>1x</em> = no \n        chrominance subsampling <br /><br /> <em>2x</em> = discard the \n        chrominance components for every other pixel along the image&rsquo;s X \n        direction (this is also known as &ldquo;4:2:2&rdquo; or \n        &ldquo;2:1&rdquo; subsampling.) All else being equal, 2x subsampling \n        generally reduces the image size by about 20-25% when compared to no \n        subsampling.<br /> <br /> <em>4x</em> = discard the chrominance \n        components for every other pixel along both the X and Y directions of \n        the image (this is also known as &ldquo;4:2:0&rdquo; or \n        &ldquo;2:2&rdquo; subsampling.)   All else being equal, 4x subsampling \n        generally reduces the image size by about 35-40% when compared to no \n        subsampling. <br /><br /> <em>8x</em> = discard the chrominance \n        components for 3 out of every 4 pixels along the image&rsquo;s X \n        direction and half the pixels along the image&rsquo;s Y direction (this \n        is also known as &ldquo;4:1:0&rdquo; or &ldquo;4:2&rdquo; subsampling.)  \n        <em>This option is available only when using an image transport plugin \n        that supports it.</em> <br /><br /> <em>16x</em> = discard the \n        chrominance components for 3 out of every 4 pixels along both the X and \n        Y directions of the image (this is also known as &ldquo;4:4&rdquo; \n        subsampling.)  <em>This option is available only when using an image \n        transport plugin that supports it.</em> <br /><br /> <em>gray</em> = \n        discard all chrominance components.  This is useful when running \n        applications (such as medical visualization applications) that are \n        already generating grayscale images. <br /><br /> Subsampling artifacts \n        are less noticeable with volume data, since it usually only contains 256 \n        colors to begin with, but narrow, aliased lines and other sharp features \n        on a black background will tend to produce very noticeable artifacts \n        when subsampling is enabled. <br /><br /> The axis indicator from a \n        popular visualization app displayed with 1x, 2x, and 4x chrominance \n        subsampling (respectively):<br /> \n        <img src=\"444.gif\" alt=\"444\" class=\"inline\" id=\"imgid_2\" name=\"imgid_2\"/><img src=\"422.gif\" alt=\"422\" class=\"inline\" id=\"imgid_3\" name=\"imgid_3\"/><img src=\"411.gif\" alt=\"411\" class=\"inline\" id=\"imgid_4\" name=\"imgid_4\"/> \n        <br />\n        <div class=\"important\"><p class=\"important\">\n        If using an image transport plugin, then this setting need not necessarily correspond to JPEG chrominance subsampling.  How the plugin responds to the <code>VGL_SUBSAMP</code> option is implementation-specific.\n        </p></div>\n    </dd>\n</dl>\n\n<p><a name=\"VGL_SYNC\"></a></p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_SYNC&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglrun</code> argument</td>\n    <td class=\"standard\"><code>-sync</code> / <code>+sync</code></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Disable/enable strict 2D/3D synchronization</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">VGL, X11, XV, Custom (if supported)</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Disabled</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        Normally, VirtualGL&rsquo;s operation is asynchronous from the point of \n        view of the application.  The application swaps the buffers or calls \n        <code>glFinish()</code> or <code>glFlush()</code> or \n        <code>glXWaitGL()</code>, and VirtualGL will read back the Pbuffer and \n        deliver the pixels to the 2D X server &hellip; eventually. This is fine \n        for the vast majority of applications, but it does not strictly conform \n        to the GLX spec.  Technically speaking, when an application calls \n        <code>glXWaitGL()</code> or <code>glFinish()</code>, it is well within \n        its rights to expect the 3D image to be immediately available in the X \n        window. Fortunately, very few applications actually do expect this, but \n        on rare occasions, an application may try to use \n        <code>XGetImage()</code> or other X11 functions to obtain a bitmap of \n        the pixels that were rendered by OpenGL. Enabling <code>VGL_SYNC</code> \n        is a somewhat extreme measure that may be needed to make such \n        applications display properly with VirtualGL.  It was developed \n        initially as a way to pass the GLX conformance suite \n        (<code>conformx</code>, specifically), but at least one commercial \n        application is known to require it as well (see \n        <a href=\"#Application_Recipes\">Application \n        Recipes</a><a name=\"idx0054\"></a>.)<br /><br />When \n        <code>VGL_SYNC</code> is enabled, every call to <code>glFinish()</code>, \n        <code>glXWaitGL()</code>, and <code>glXSwapBuffers()</code> (and \n        <code>glFlush()</code>, if \n        <a href=\"#VGL_GLFLUSHTRIGGER\">VGL_GLFLUSHTRIGGER</a><a name=\"idx0055\"></a> \n        is enabled) will cause the contents of the Pbuffer to be read back and \n        <em>synchronously</em> drawn into the application&rsquo;s window \n        <em>using the X11 Transport and no frame spoiling</em>.  The call to \n        <code>glFinish()</code>, <code>glXWaitGL()</code>, \n        <code>glFlush()</code>, or <code>glXSwapBuffers()</code> will not return \n        until VirtualGL has verified that the pixels have been delivered into \n        the application&rsquo;s window.  As such, this mode can have potentially \n        dire effects on performance when used with a remote 2D X server.  It is \n        strongly recommended that <code>VGL_SYNC</code> be used only in \n        conjunction with an X proxy running on the same server as VirtualGL.\n        <div class=\"important\"><p class=\"important\">\n        If an image transport plugin is being used, then VirtualGL does not automatically enable the X11 Transport or disable frame spoiling when <code>VGL_SYNC</code> is set.  This allows the plugin to handle synchronous image delivery as it sees fit (or to simply ignore this option.)\n        </p></div>\n    </dd>\n</dl>\n\n<p><a name=\"VGL_TILESIZE\"></a></p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_TILESIZE&nbsp;=&nbsp;</code><em><code>{t}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\"><em><code>{t}</code></em> = the image tile size (<em><code>{t}</code></em> x <em><code>{t}</code></em> pixels) to use for multi-threaded compression and interframe comparison (8 &lt;= <em><code>{t}</code></em> &lt;= 1024)</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">VGL (JPEG, RGB), Custom (if supported)</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">256</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        Normally, the VGL Transport will divide an OpenGL window into \n        equal-sized square tiles, compare each tile vs. the same tile in the \n        previous frame, then compress and send only the tiles that have changed \n        (assuming <a href=\"#VGL_INTERFRAME\">interframe \n        comparison</a><a name=\"idx0056\"></a> is enabled.)  The VGL Transport \n        will also divide up the task of compressing these tiles among the \n        available CPUs in a round robin fashion, if multi-threaded compression \n        is enabled (see \n        <a href=\"#VGL_NPROCS\">VGL_NPROCS</a><a name=\"idx0057\"></a>.) \n        <br /><br /> There are several tradeoffs that must be considered when \n        choosing a tile size: <br /><br /> <em>Parallel scalability:</em> \n        <ul class=\"Itemize\"><li class=\"Itemize-0\">\n            Smaller tiles can more easily be divided up among multiple CPUs. If \n            the \n            tile size if too large, then there may not be enough tiles to go \n            around.\n        </li></ul> <br /> <em>Compression efficiency:</em> \n        <ul class=\"Itemize\"><li class=\"Itemize-0\">\n            There is a certain amount of fixed CPU overhead required when \n            compressing images, so compressing larger tiles makes more efficient \n            use \n            of the CPUs and increases the aggregate throughput of the compressor.\n        </li></ul> <br /> <em>Inter-frame optimization:</em> \n        <ul class=\"Itemize\"><li class=\"Itemize-0\">\n            When using smaller tiles, there is more of a chance that a given \n            tile \n            will remain unchanged from frame to frame and thus not need to be \n            re-transmitted to the client.\n        </li></ul> <br /> <em>Network efficiency:</em> \n        <ul class=\"Itemize\"><li class=\"Itemize-0\">\n            Each tile has a certain amount of fixed overhead required to \n            represent \n            it on the network.  Thus, using smaller tiles will increase the \n            total \n            number of tiles per frame, which will increase the total network \n            usage.\n        </li></ul> <br /> 256x256 was chosen as the default because, in \n        experiments, it provided the best balance between scalability and \n        efficiency on the platforms that VirtualGL supports.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_TRACE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglrun</code> argument</td>\n    <td class=\"standard\"><code>-tr</code> / <code>+tr</code></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Disable/enable tracing</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Disabled</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        When tracing is enabled, VirtualGL will log all calls to the GLX and X11 \n        functions it is intercepting, as well as the arguments, return values, \n        and execution times for those functions.  This is useful when diagnosing \n        interaction problems between VirtualGL and a particular OpenGL \n        application.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_TRANSPORT&nbsp;=&nbsp;</code><em><code>{t}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglrun</code> argument</td>\n    <td class=\"standard\"><code>-trans&nbsp;</code><em><code>{t}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Use an image transport plugin</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">None</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        If this option is specified, then VirtualGL will attempt to load an \n        image transport plugin contained in a dynamic library named \n        <code>libtransvgl_</code><em><code>{t}</code></em><code>.so</code> \n        located in the dynamic linker path.  See Chapter \n        <a href=\"#Transport_Plugins\" class=\"ref\">11</a> for more information.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_TRAPX11&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Disable/enable VirtualGL&rsquo;s X11 error handler</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Disabled</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        If an application does not install its own X11 error handler, then the \n        default X11 error handler is used, thus causing the application to exit \n        if an X11 error occurs.  Enabling the <code>VGL_TRAPX11</code> option \n        will cause VirtualGL to install its own X11 error handler, which prints \n        a warning message but allows the application to continue running.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_VERBOSE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglrun</code> argument</td>\n    <td class=\"standard\"><code>-v</code> / <code>+v</code></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Disable/enable verbose VirtualGL messages</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Disabled</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        When verbose mode is enabled, VirtualGL will reveal some of the \n        decisions it is making behind the scenes, such as which type of X11 \n        drawing it is using, etc.  This can be helpful when diagnosing \n        performance problems.\n    </dd>\n</dl>\n\n<p><a name=\"VGL_WM\"></a></p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_WM&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglrun</code> argument</td>\n    <td class=\"standard\"><code>-wm</code> / <code>+wm</code></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Disable/enable window manager mode</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Disabled</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        When window manager mode is enabled, VirtualGL will disable some of its \n        internal features that interfere with the correct operation of 3D window \n        managers such as compiz.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_X11LIB&nbsp;=&nbsp;</code><em><code>{l}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\"><em><code>{l}</code></em> = the location of an alternate X11 library</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        Normally VirtualGL will use the X11 library against which it was linked \n        (usually <code>libX11.so.6</code>, in the system library path) to load \n        any\t&ldquo;real&rdquo; X11 functions that it needs to call \n        (&ldquo;real&rdquo; as opposed to the &ldquo;fake&rdquo;, or \n        &ldquo;interposed&rdquo;, versions of those functions that VirtualGL \n        provides, which often modify the arguments or perform other operations \n        before calling the &ldquo;real&rdquo; functions.)  You can use the \n        <code>VGL_X11LIB</code> environment variable to specify the path of a \n        dynamic library from which VirtualGL should load &ldquo;real&rdquo; X11 \n        functions. <br /><br /> You shouldn&rsquo;t need to muck with this \n        unless something doesn&rsquo;t work.  However, it is potentially useful \n        if one wishes to insert another X11 interposer between VirtualGL and the \n        system&rsquo;s X11 library.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_XCBLIB&nbsp;=&nbsp;</code><em><code>{l}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\"><em><code>{l}</code></em> = the location of an alternate XCB library</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\"><code>libxcb.so.1</code> in the system library path</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        Specifies the path of a dynamic library from which VirtualGL should load \n        &ldquo;real&rdquo; XCB functions.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_XCBATOMLIB&nbsp;=&nbsp;</code><em><code>{l}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\"><em><code>{l}</code></em> = the location of an alternate xcb-atom library</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\"><code>libxcb-atom.so.0</code> or <code>libxcb-atom.so.1</code> in the system library path</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        Specifies the path of a dynamic library from which VirtualGL should load \n        &ldquo;real&rdquo; XCB atom functions.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_XCBGLXLIB&nbsp;=&nbsp;</code><em><code>{l}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\"><em><code>{l}</code></em> = the location of an alternate xcb-glx library</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\"><code>libxcb-glx.so.0</code> in the system library path</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        Specifies the path of a dynamic library from which VirtualGL should load \n        &ldquo;real&rdquo; XCB GLX functions.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_XCBKEYSYMSLIB&nbsp;=&nbsp;</code><em><code>{l}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\"><em><code>{l}</code></em> = the location of an alternate xcb-keysyms library</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\"><code>libxcb-keysyms.so.0</code> or <code>libxcb-keysyms.so.1</code> in the system library path</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        Specifies the path of a dynamic library from which VirtualGL should load \n        &ldquo;real&rdquo; XCB keysyms functions.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_XCBX11LIB&nbsp;=&nbsp;</code><em><code>{l}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\"><em><code>{l}</code></em> = the location of an alternate X11-xcb library</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\"><code>libX11-xcb.so.1</code> in the system library path</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        Specifies the path of a dynamic library from which VirtualGL should load \n        &ldquo;real&rdquo; X11 XCB functions.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_XVENDOR&nbsp;=&nbsp;</code><em><code>{v}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\"><em><code>{v}</code></em> = a fake X11 vendor string to return when the application calls <code>XServerVendor()</code> or <code>ServerVendor()</code></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Image Transports</td>\n    <td class=\"standard\">All</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        Some applications expect the X11 vendor string to contain a particular \n        value, which the application (sometimes erroneously) uses to figure out \n        whether it is being displayed to a local or a remote X server. This \n        setting allows you to fool such applications into thinking that they are \n        being\tdisplayed to a &ldquo;local&rdquo; X server rather than a remote \n        one.\n    </dd>\n</dl>\n\n\n\n<h2 id=\"hd0019002\">19.2&nbsp;Client Settings</h2>\n\n<p>These settings control the VirtualGL Client, which is used only with the \nVGL Transport.  <code>vglclient</code> is normally launched \nautomatically from <code>vglconnect</code> and should not require any \nfurther configuration except in exotic circumstances.  These settings \nare meant only for advanced users or those wishing to build additional \ninfrastructure around VirtualGL.</p>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGLCLIENT_DRAWMODE&nbsp;=&nbsp;</code><em><code>ogl&nbsp;|&nbsp;x11</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglclient</code> argument</td>\n    <td class=\"standard\"><code>-gl</code> / <code>-x</code></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Specify the method used to draw pixels into the application window</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\"><code>x11</code></td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        If the client machine has a GPU, then it may be faster in some rare \n        instances to draw pixels using OpenGL rather than using 2D (X11) \n        commands.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGLCLIENT_LISTEN&nbsp;=&nbsp;</code><em><code>sslonly&nbsp;|&nbsp;nossl</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglclient</code> argument</td>\n    <td class=\"standard\"><code>-sslonly</code> / <code>-nossl</code></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Accept only unencrypted or only SSL connections from the VirtualGL server</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Accept both SSL and unencrypted connections</td>\n  </tr>\n</table>\n</div>\n\n\n<div class=\"important\"><p class=\"important\">\nThis option is available only if the VirtualGL client was built with OpenSSL support.\n</p></div>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGLCLIENT_PORT&nbsp;=&nbsp;</code><em><code>{p}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglclient</code> argument</td>\n    <td class=\"standard\"><code>-port&nbsp;</code><em><code>{p}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\"><em><code>{p}</code></em> = TCP port on which to listen for unencrypted connections from the VirtualGL server</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Automatically select a free port</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        The default behavior for <code>vglclient</code> is to first try \n        listening for unencrypted connections on port 4242, to maintain backward \n        compatibility with VirtualGL v2.0.x.  If port 4242 is not available, \n        then <code>vglclient</code> will try to find a free port in the range of \n        4200-4299.  If none of those ports is available, then \n        <code>vglclient</code> will request a free port from the operating \n        system. <br /><br /> Setting this option circumvents the automatic \n        behavior described above and causes <code>vglclient</code> to listen \n        only on the specified TCP port.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_PROFILE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Disable/enable profiling output</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Disabled</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        If profiling output is enabled, then VirtualGL will continuously \n        benchmark itself and periodically print out the throughput of various \n        stages in its image pipelines. <br /><br /> See Chapter \n        <a href=\"#Perf_Measurement\" class=\"ref\">17</a> for more details.\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGLCLIENT_SSLPORT&nbsp;=&nbsp;</code><em><code>{p}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\"><code>vglclient</code> argument</td>\n    <td class=\"standard\"><code>-sslport&nbsp;</code><em><code>{p}</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\"><em><code>{p}</code></em> = TCP port on which to listen for SSL connections from the VirtualGL server</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Automatically select a free port</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        The default behavior for <code>vglclient</code> is to first try \n        listening for SSL connections on port 4243, to maintain backward \n        compatibility with VirtualGL v2.0.x.  If port 4243 is not available, \n        then <code>vglclient</code> will try to find a free port in the range of \n        4200-4299.  If none of those ports is available, then \n        <code>vglclient</code> will request a free port from the operating \n        system. <br /><br /> Setting this option circumvents the automatic \n        behavior described above and causes <code>vglclient</code> to listen \n        only on the specified TCP port.\n        <div class=\"important\"><p class=\"important\">\n        This option is available only if the VirtualGL client was built with OpenSSL support.\n        </p></div>\n    </dd>\n</dl>\n\n<div class=\"table\">\n<table class=\"standard\">\n  <tr class=\"standard\">\n    <td class=\"high standard\">Environment Variable</td>\n    <td class=\"standard\"><code>VGL_VERBOSE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Summary</td>\n    <td class=\"standard\">Disable/enable verbose VirtualGL messages</td>\n  </tr>\n  <tr class=\"standard\">\n    <td class=\"high standard\">Default Value</td>\n    <td class=\"standard\">Disabled</td>\n  </tr>\n</table>\n</div>\n\n\n<dl class=\"Description\">\n    <dt class=\"Description-1 Description\">Description</dt>\n    <dd class=\"Description-1 Description\">\n        When verbose mode is enabled, VirtualGL will reveal some of the \n        decisions it is making behind the scenes, such as which type of X11 \n        drawing it is using, etc.  This can be helpful when diagnosing \n        performance problems.\n    </dd>\n</dl>\n\n<p><br /></p>\n\n\n</body>\n</html>\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/server/fltk/FL/mac.r",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/doc/444.gif",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/doc/vgltransportservernetwork.odg",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/doc/sshtunnel.png",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/doc/vgltransport.png",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/doc/configdialog.gif",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/doc/411.gif",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/doc/x11transport.odg",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/doc/somerights20.png",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/doc/vgltransport.odg",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/doc/x11transport.png",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/doc/422.gif",
        "/tmp/vanessa/spack-stage/spack-stage-virtualgl-2.5.2-gjh543qte74ceavtaexuwipu4g2e7utp/spack-src/doc/vgltransportservernetwork.png"
    ],
    "total_files": 497
}