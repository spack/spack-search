{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-pandaseq-2.10-vdv4q7tnoeivvr56dmee5rd5hzcceeos/spack-src/module.c": "/* PANDAseq -- Assemble paired FASTQ Illumina reads and strip the region between amplification primers.\n     Copyright (C) 2011-2012  Andre Masella\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n */\n#include \"config.h\"\n#include <libgen.h>\n#include <ltdl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef HAVE_PTHREAD\n#        include <pthread.h>\n#endif\n#include \"pandaseq.h\"\n#include \"assembler.h\"\n#include \"buffer.h\"\n\n#define STR0(x) #x\n#define STR(x) STR0(x)\n#define LOGV(code, fmt, ...) snprintf(static_buffer(), BUFFER_SIZE, fmt, __VA_ARGS__); panda_log_proxy_write(assembler->logger, (code), assembler, NULL, static_buffer());\n\nstatic const char path_sep_string[] = { LT_PATHSEP_CHAR, '\\0' };\n\nstatic volatile int ltdl_count = 0;\n#ifdef HAVE_PTHREAD\n/* All modules share a single mutex to control reference counts */\nstatic pthread_mutex_t ref_lock = PTHREAD_MUTEX_INITIALIZER;\n#endif\n\nstatic bool ref_ltdl(\n\tvoid) {\n#ifdef HAVE_PTHREAD\n\tpthread_mutex_lock(&ref_lock);\n#endif\n\tif (ltdl_count == 0) {\n\t\tconst char *path;\n\t\tif (lt_dlinit() != 0) {\n#ifdef HAVE_PTHREAD\n\t\t\tpthread_mutex_unlock(&ref_lock);\n#endif\n\t\t\treturn false;\n\t\t}\n\t\tpath = lt_dlgetsearchpath();\n\t\tif (path == NULL || strstr(path, STR(PKGLIBDIR)) == NULL) {\n\t\t\tif (lt_dladdsearchdir(STR(PKGLIBDIR)) != 0) {\n\t\t\t\t(void) lt_dlexit();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tltdl_count++;\n#ifdef HAVE_PTHREAD\n\tpthread_mutex_unlock(&ref_lock);\n#endif\n\treturn true;\n}\n\nstatic void unref_ltdl(\n\tvoid) {\n#ifdef HAVE_PTHREAD\n\tpthread_mutex_lock(&ref_lock);\n#endif\n\tif (--ltdl_count == 0) {\n\t\tlt_dlexit();\n\t}\n#ifdef HAVE_PTHREAD\n\tpthread_mutex_unlock(&ref_lock);\n#endif\n}\n\nstruct panda_module {\n\tvolatile size_t refcnt;\n\n\tPandaCheck check;\n\tPandaPreCheck precheck;\n\tPandaDestroy destroy;\n\tvoid *user_data;\n\n\tlt_dlhandle handle;\n\tchar *name;\n\n\tint api;\n\tchar **version;\n};\n\nvoid module_destroy(\n\tPandaAssembler assembler) {\n\tsize_t it;\n\tif (assembler->rejected)\n\t\tfree(assembler->rejected);\n\tfor (it = 0; it < assembler->modules_length; it++) {\n\t\tpanda_module_unref(assembler->modules[it]);\n\t}\n\tassembler->modules_length = 0;\n\tfree(assembler->modules);\n}\n\nvoid module_init(\n\tPandaAssembler assembler) {\n\tsize_t it;\n\tfor (it = 0; it < assembler->modules_length; it++) {\n\t\tPandaModule module = assembler->modules[it];\n\t\tif (module->handle != NULL) {\n\t\t\tconst lt_dlinfo *info = lt_dlgetinfo(module->handle);\n\t\t\tLOGV(PANDA_CODE_MOD_INFO, \"%s(%s:%d)\", info == NULL ? \"unknown\" : info->name, module->version == NULL ? \"?\" : *(module->version), module->api);\n\t\t\tassembler->rejected[it] = 0;\n\t\t}\n\t}\n}\n\nbool module_checkseq(\n\tPandaAssembler assembler,\n\tpanda_result_seq *sequence) {\n\tsize_t it;\n\tfor (it = 0; it < assembler->modules_length; it++) {\n\t\tPandaModule module = assembler->modules[it];\n\t\tif (module->check != NULL && !module->check(assembler->logger, sequence, module->user_data)) {\n\t\t\tassembler->rejected[it]++;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool module_precheckseq(\n\tPandaAssembler assembler,\n\tpanda_seq_identifier *id,\n\tconst panda_qual *forward,\n\tsize_t forward_length,\n\tconst panda_qual *reverse,\n\tsize_t reverse_length) {\n\tsize_t it;\n\tfor (it = 0; it < assembler->modules_length; it++) {\n\t\tPandaModule module = assembler->modules[it];\n\t\tif (module->precheck != NULL && !module->precheck(assembler->logger, id, forward, forward_length, reverse, reverse_length, module->user_data)) {\n\t\t\tassembler->rejected[it]++;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool panda_assembler_add_module(\n\tPandaAssembler assembler,\n\tPandaModule module) {\n\tif (module == NULL) {\n\t\treturn false;\n\t}\n#ifdef HAVE_PTHREAD\n\tpthread_mutex_lock(&assembler->mutex);\n#endif\n\tif (assembler->modules_length == assembler->modules_size) {\n\t\tif (assembler->modules_size == 0) {\n\t\t\tassembler->modules_size = 8;\n\t\t} else {\n\t\t\tassembler->modules_size *= 2;\n\t\t}\n\t\tassembler->modules = realloc(assembler->modules, assembler->modules_size * sizeof(PandaModule));\n\t\tassembler->rejected = realloc(assembler->rejected, assembler->modules_size * sizeof(size_t));\n\t}\n\tassembler->rejected[assembler->modules_length] = 0;\n\tassembler->modules[assembler->modules_length++] = panda_module_ref(module);\n#ifdef HAVE_PTHREAD\n\tpthread_mutex_unlock(&assembler->mutex);\n#endif\n\treturn true;\n}\n\nsize_t panda_assembler_add_modules(\n\tPandaAssembler assembler,\n\tPandaModule *modules,\n\tsize_t modules_length) {\n\tsize_t it;\n\tfor (it = 0; it < modules_length; it++) {\n\t\tif (!panda_assembler_add_module(assembler, modules[it])) {\n\t\t\treturn it;\n\t\t}\n\t}\n\treturn it;\n}\n\nbool panda_assembler_foreach_module(\n\tPandaAssembler assembler,\n\tPandaModuleCallback callback,\n\tvoid *data) {\n\tsize_t it;\n\tfor (it = 0; it < assembler->modules_length; it++) {\n\t\tif (!callback(assembler, assembler->modules[it], assembler->rejected[it], data)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid panda_assembler_module_stats(\n\tPandaAssembler assembler) {\n\tsize_t it;\n\tfor (it = 0; it < assembler->modules_length; it++) {\n\t\tif (assembler->rejected[it] > 0) {\n\t\t\tLOGV(PANDA_CODE_REJECT_STAT, \"%s\\t%zu\", assembler->modules[it]->name, assembler->rejected[it]);\n\t\t}\n\t}\n}\n\ntypedef bool (\n\t*PandaPluginOpen) (\n\tPandaLogProxy logger,\n\tconst char *args,\n\tPandaPreCheck *precheck,\n\tPandaCheck *check,\n\tvoid **user_data,\n\tPandaDestroy *destroy);\n\nPandaModule panda_module_load(\n\tPandaLogProxy logger,\n\tconst char *path) {\n\tPandaModule m;\n\tlt_dlhandle handle;\n\tunion {\n\t\tPandaPluginOpen func;\n\t\tvoid *ptr;\n\t} opener;\n\tPandaCheck check = NULL;\n\tPandaPreCheck precheck = NULL;\n\tvoid *user_data;\n\tPandaDestroy destroy;\n\tsize_t name_length;\n\tint *api;\n\tchar *name;\n\n\tname_length = strcspn(path, path_sep_string);\n\tname = malloc(name_length + 1);\n\tmemcpy(name, path, name_length);\n\tname[name_length] = '\\0';\n\n\tif (!ref_ltdl()) {\n\t\tfree(name);\n\t\treturn NULL;\n\t}\n\n\thandle = lt_dlopenext(name);\n\tif (handle == NULL) {\n\t\tfprintf(stderr, \"Could not open module %s: %s\\n\", name, lt_dlerror());\n\t\tfree(name);\n\t\tunref_ltdl();\n\t\treturn NULL;\n\t}\n\n\tapi = lt_dlsym(handle, \"api\");\n\tif (api == NULL || *api != PANDA_API) {\n\t\tfprintf(stderr, \"Invalid API in %s (%d != %d). Are you sure this module was compiled for this version of PANDAseq?\\n\", name, api == NULL ? -1 : *api, PANDA_API);\n\t\tlt_dlclose(handle);\n\t\tfree(name);\n\t\tunref_ltdl();\n\t\treturn NULL;\n\t}\n\n\topener.ptr = lt_dlsym(handle, \"opener\");\n\tif (opener.ptr == NULL) {\n\t\tlt_dlclose(handle);\n\t\tfprintf(stderr, \"Could not find opener function in %s\\n\", name);\n\t\tfree(name);\n\t\tunref_ltdl();\n\t\treturn NULL;\n\t}\n\n\tif ((*opener.func) (logger, (path[name_length] == LT_PATHSEP_CHAR) ? (path + name_length + 1) : NULL, &precheck, &check, &user_data, &destroy) && (precheck != NULL || check != NULL)) {\n\t\tm = malloc(sizeof(struct panda_module));\n\t\tm->api = *api;\n\t\tm->check = check;\n\t\tm->precheck = precheck;\n\t\tm->handle = handle;\n\t\tm->name = name;\n\t\tm->refcnt = 1;\n\t\tm->user_data = user_data;\n\t\tm->destroy = destroy;\n\t\tm->version = lt_dlsym(handle, \"version\");\n\n\t\treturn m;\n\t} else {\n\t\tfree(name);\n\t\tunref_ltdl();\n\t\treturn NULL;\n\t}\n}\n\nPandaModule panda_module_new(\n\tconst char *name,\n\tPandaCheck check,\n\tPandaPreCheck precheck,\n\tvoid *user_data,\n\tPandaDestroy cleanup) {\n\tPandaModule m;\n\tif (check == NULL && precheck == NULL)\n\t\treturn NULL;\n\tm = malloc(sizeof(struct panda_module));\n\tm->api = PANDA_API;\n\tm->check = check;\n\tm->destroy = cleanup;\n\tm->handle = NULL;\n\tm->name = malloc(strlen(name) + 1);\n\tmemcpy(m->name, name, strlen(name) + 1);\n\tm->precheck = precheck;\n\tm->refcnt = 1;\n\tm->user_data = user_data;\n\tm->version = NULL;\n\treturn m;\n}\n\nPandaModule panda_module_ref(\n\tPandaModule module) {\n#ifdef HAVE_PTHREAD\n\tpthread_mutex_lock(&ref_lock);\n#endif\n\tmodule->refcnt++;\n#ifdef HAVE_PTHREAD\n\tpthread_mutex_unlock(&ref_lock);\n#endif\n\treturn module;\n}\n\nvoid panda_module_unref(\n\tPandaModule module) {\n\tsize_t count;\n\tif (module == NULL)\n\t\treturn;\n#ifdef HAVE_PTHREAD\n\tpthread_mutex_lock(&ref_lock);\n#endif\n\tcount = --(module->refcnt);\n#ifdef HAVE_PTHREAD\n\tpthread_mutex_unlock(&ref_lock);\n#endif\n\tif (count == 0) {\n\t\tif (module->destroy != NULL)\n\t\t\tmodule->destroy(module->user_data);\n\t\tif (module->name != NULL)\n\t\t\tfree(module->name);\n\t\tif (module->handle != NULL) {\n\t\t\tlt_dlclose(module->handle);\n\t\t\tunref_ltdl();\n\t\t}\n\t\tfree(module);\n\t}\n}\n\nint panda_module_get_api(\n\tPandaModule module) {\n\treturn module->api;\n}\n\nconst char *panda_module_get_description(\n\tPandaModule module) {\n\tchar **val;\n\t//const lt_dlinfo *info;\n\tif (module->handle == NULL)\n\t\treturn NULL;\n\t//info = lt_dlgetinfo(module->handle);\n\tval = lt_dlsym(module->handle, \"desc\");\n\treturn val == NULL ? NULL : *val;\n}\n\nconst char *panda_module_get_name(\n\tPandaModule module) {\n\treturn module->name;\n}\n\nconst char *panda_module_get_version(\n\tPandaModule module) {\n\treturn module->version == NULL ? NULL : *module->version;\n}\n\nconst char *panda_module_get_usage(\n\tPandaModule module) {\n\tchar **val;\n\tif (module->handle == NULL)\n\t\treturn NULL;\n\tval = lt_dlsym(module->handle, \"usage\");\n\treturn val == NULL ? NULL : *val;\n}\n\nstatic int show_module(\n\tconst char *filename,\n\tvoid *data) {\n\n\tint *api;\n\tchar buffer[2048];\n\tchar *base_filename;\n\tconst char **description;\n\tlt_dlhandle handle;\n\tconst char **usage;\n\tconst char **version;\n\n\t(void) data;\n\thandle = lt_dlopenext(filename);\n\tif (handle == NULL) {\n\t\treturn 0;\n\t}\n\n\tstrncpy(buffer, filename, sizeof(buffer));\n\tbuffer[sizeof(buffer) - 1] = '\\0';\n\tbase_filename = basename(buffer);\n\n\tapi = lt_dlsym(handle, \"api\");\n\tif (api == NULL || *api != PANDA_API) {\n\t\tfprintf(stderr, \"Invalid API in %s (%d != %d).\\n\", base_filename, api == NULL ? -1 : *api, PANDA_API);\n\t\tlt_dlclose(handle);\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr, \"%s\", base_filename);\n\tversion = lt_dlsym(handle, \"version\");\n\tif (version != NULL && *version != NULL) {\n\t\tfprintf(stderr, \"(%s)\", *version);\n\t}\n\tdescription = lt_dlsym(handle, \"description\");\n\tif (description != NULL && *description != NULL) {\n\t\tfprintf(stderr, \": %s\\n\", *description);\n\t} else {\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\n\tusage = lt_dlsym(handle, \"usage\");\n\tif (usage != NULL && *usage != NULL) {\n\t\tfprintf(stderr, \"\\tUsage: %s\\n\", *usage);\n\t}\n\n\tlt_dlclose(handle);\n\treturn 0;\n}\n\nvoid module_show_all(\n\t) {\n\tif (!ref_ltdl()) {\n\t\treturn;\n\t}\n\tfprintf(stderr, \"\\nKnown modules:\\n\");\n\tlt_dlforeachfile(STR(PKGLIBDIR), show_module, NULL);\n\tunref_ltdl();\n}\n"
    },
    "skipped": [],
    "total_files": 115
}