{
    "matches": {
        "/var/tmp/sochat1/spack-stage/spack-stage-libblastrampoline-2.2.0-grgevrb2cpp25m4pafbmzuk5pnnhtea6/spack-src/src/Make.inc": "# ARCH detection in Make, used to pick out which trampoline assembly syntax we're gonna use\nARCH := $(shell $(CC) -dumpmachine | sed \"s/\\([^-]*\\).*$$/\\1/\")\n\n# Normalize ppc64le to powerpc64le\nifeq ($(ARCH),ppc64le)\n  ARCH := powerpc64le\nendif\n# We map amd64 to x86_64 for compatibility with systems that identify 64-bit systems as such\nifeq ($(ARCH),amd64)\n  ARCH := x86_64\nendif\n# We map arm64 (Apple spelling) to aarch64 to avoid having to deal with both spellings everywhere\nifeq ($(ARCH),arm64)\n  ARCH := aarch64\nendif\n\n# Figure out OS and architecture (used to set `shlib_ext`)\nOS := $(shell uname)\nifneq (,$(findstring MINGW,$(OS))$(findstring MSYS,$(OS))$(findstring CYGWIN,$(OS)))\n  OS := WINNT\nendif\n\nifeq ($(OS), WINNT)\n  SHLIB_EXT := dll\n  EXE := .exe\n  binlib := bin\nelse ifeq ($(OS), Darwin)\n  SHLIB_EXT := dylib\n  binlib := lib\nelse\n  SHLIB_EXT := so\n  binlib := lib\nendif\n\nCFLAGS := -g -O2 -std=c99 -fPIC -DLIBRARY_EXPORTS -D_GNU_SOURCE $(CFLAGS_add)\nLDFLAGS := -shared\n\n# On linux, we need to link `libdl` to get `dlopen`\nifeq ($(OS),Linux)\nLDFLAGS += -ldl\nendif\n\n# On windows, we need to enable unicode mode\nifeq ($(OS),WINNT)\nCFLAGS += -municode\nendif\n\n# On windows, we must generate import libraries\nifeq ($(OS),WINNT)\ndefine IMPLIB_FLAGS\n  -Wl,--out-implib,$(1).a\nendef\nelse\ndefine IMPLIB_FLAGS\nendef\nendif\n\n# If we're on x86_64 or i686, we may need to convert back f2c-style bindings (such as Apple's Accelerate)\n# from returning doubles to instead return float's.  We enable automatic F2C detection on those platforms.\nF2C_AUTODETECTION := 0\nifeq ($(ARCH),x86_64)\n  CFLAGS += -DF2C_AUTODETECTION\n  F2C_AUTODETECTION := 1\nendif\n\n\nifeq ($(VERBOSE),0)\nENDCOLOR := \"\\033[0m\"\nCCCOLOR := \"\\033[34m\"\nSRCCOLOR:=\"\\033[33m\"\n\nPRINT_CC = printf '%b %b\\n' $(CCCOLOR)CC$(ENDCOLOR) $(SRCCOLOR)$@$(ENDCOLOR); $(1)\nelse\nPRINT_CC = echo $(1); $(1)\nendif\n\n# Default installation location; we expect you to be overriding this\nprefix ?= prefix\nbuilddir ?= build\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-libblastrampoline-2.2.0-grgevrb2cpp25m4pafbmzuk5pnnhtea6/spack-src/src/dl_utils.c": "#include \"libblastrampoline_internal.h\"\n\nvoid throw_dl_error(const char * path) {\n    fprintf(stderr, \"ERROR: Unable to load dependent library %s\\n\", path);\n#if defined(_OS_WINDOWS_)\n    LPWSTR wmsg = TEXT(\"\");\n    FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                    FORMAT_MESSAGE_FROM_SYSTEM |\n                    FORMAT_MESSAGE_IGNORE_INSERTS |\n                    FORMAT_MESSAGE_MAX_WIDTH_MASK,\n                    NULL, GetLastError(),\n                    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),\n                    (LPWSTR)&wmsg, 0, NULL);\n    char err[256] = {0};\n    wchar_to_utf8(wmsg, err, 255);        \n#else\n    const char * err = dlerror();\n#endif\n    fprintf(stderr, \"Message: %s\\n\", err);\n}\n\n\n/*\n * Load the given `path`, using `RTLD_NOW | RTLD_LOCAL` and `RTLD_DEEPBIND`, if available\n */\nvoid * load_library(const char * path) {\n    void * new_handle = NULL;\n\n#if defined(_OS_WINDOWS_)\n    wchar_t wpath[2*PATH_MAX + 1] = {0};\n    if (!utf8_to_wchar(path, wpath, 2*PATH_MAX)) {\n        fprintf(stderr, \"ERROR: Unable to convert path %s to wide string!\\n\", path);\n        exit(1);\n    }\n    new_handle = (void *)LoadLibraryExW(wpath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n#else\n    // If we have `RTLD_DEEPBIND`, use it!\n#if defined(RTLD_DEEPBIND)\n    new_handle = dlopen(path, RTLD_NOW | RTLD_LOCAL | RTLD_DEEPBIND);\n#else\n    new_handle = dlopen(path, RTLD_NOW | RTLD_LOCAL);\n#endif\n#endif\n    if (new_handle == NULL) {\n        throw_dl_error(path);\n    }\n    return new_handle;\n}\n\n/*\n * Close the given library handle\n */\nvoid close_library(void * handle) {\n#if defined(_OS_WINDOWS_)\n    FreeLibrary((HMODULE)handle);\n#else\n    dlclose(handle);\n#endif\n}\n\n/*\n * Look up the given symbol within the given library denoted by `handle`.\n */\nvoid * lookup_symbol(const void * handle, const char * symbol_name) {\n#if defined(_OS_WINDOWS_)\n    return GetProcAddress((HMODULE) handle, symbol_name);\n#else\n    return dlsym((void *)handle, symbol_name);\n#endif\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-libblastrampoline-2.2.0-grgevrb2cpp25m4pafbmzuk5pnnhtea6/spack-src/src/libblastrampoline.c": "#include \"libblastrampoline_internal.h\"\n#include \"libblastrampoline_trampdata.h\"\n\n#ifdef F2C_AUTODETECTION\n#include \"libblastrampoline_f2cdata.h\"\n#endif\n\n// Sentinel to tell us if we've got a deepbindless workaround active or not\n#define DEEPBINDLESS_INTERFACE_LP64_LOADED    0x01\n#define DEEPBINDLESS_INTERFACE_ILP64_LOADED   0x02\nuint8_t deepbindless_interfaces_loaded      = 0x00;\n\n\nint32_t find_symbol_idx(const char * name) {\n    for (int32_t symbol_idx=0; exported_func_names[symbol_idx] != NULL; ++symbol_idx) {\n        if (strcmp(exported_func_names[symbol_idx], name) == 0) {\n            return symbol_idx;\n        }\n    }\n    return -1;\n}\n\n\nLBT_DLLEXPORT void lbt_default_func_print_error() {\n    fprintf(stderr, \"Error: no BLAS/LAPACK library loaded!\\n\");\n}\nconst void * default_func = (const void *)&lbt_default_func_print_error;\nLBT_DLLEXPORT const void * lbt_get_default_func() {\n    return default_func;\n}\n\nLBT_DLLEXPORT void lbt_set_default_func(const void * addr) {\n    default_func = addr;\n}\n\n/*\n * Force a forward to a particular value.\n */\nint32_t set_forward_by_index(int32_t symbol_idx, const void * addr, int32_t interface, int32_t f2c, int32_t verbose) {\n    // Quit out immediately if this is not a interface setting\n    if (interface != LBT_INTERFACE_LP64 && interface != LBT_INTERFACE_ILP64) {\n        return -1;\n    }\n\n    // NULL is a special value that means our \"default address\"... which may itself be `NULL`!\n    if (addr == NULL) {\n        addr = default_func;\n    }\n\n    if (interface == LBT_INTERFACE_LP64) {\n        (*exported_func32_addrs[symbol_idx]) = addr;\n    } else {\n        (*exported_func64_addrs[symbol_idx]) = addr;\n\n        // If we're on an RTLD_DEEPBINDless system and our workaround is activated,\n        // we take over our own 32-bit symbols as well.\n        if (deepbindless_interfaces_loaded & DEEPBINDLESS_INTERFACE_ILP64_LOADED) {\n            (*exported_func32_addrs[symbol_idx]) = addr;\n        }\n    }\n\n#ifdef F2C_AUTODETECTION\n    if (f2c == LBT_F2C_REQUIRED) {\n        // Check to see if this symbol is one of the f2c functions\n        int f2c_symbol_idx = 0;\n        for (f2c_symbol_idx=0; f2c_func_idxs[f2c_symbol_idx] != -1; ++f2c_symbol_idx) {\n            // Jump through the f2c_func_idxs layer of indirection to find the `exported_func*_addrs` offsets\n            // Skip any symbols that aren't ours\n            if (f2c_func_idxs[f2c_symbol_idx] != symbol_idx)\n                continue;\n\n            if (verbose) {\n                char exported_name[MAX_SYMBOL_LEN];\n                sprintf(exported_name, \"%s%s\", exported_func_names[symbol_idx], interface == LBT_INTERFACE_ILP64 ? \"64_\" : \"\");\n                printf(\" - [%04d] f2c(%s)\\n\", symbol_idx, exported_name);\n            }\n\n            // Override these addresses with our f2c wrappers\n            if (interface == LBT_INTERFACE_LP64) {\n                // Save \"true\" symbol address in `f2c_$(name)_addr`, then set our exported `$(name)` symbol\n                // to call `f2c_$(name)`, which will bounce into the true symbol, but fix the return value.\n                (*f2c_func32_addrs[f2c_symbol_idx]) = (*exported_func32_addrs[symbol_idx]);\n                (*exported_func32_addrs[symbol_idx]) = f2c_func32_wrappers[f2c_symbol_idx];\n            } else {\n                (*f2c_func64_addrs[f2c_symbol_idx]) = (*exported_func64_addrs[symbol_idx]);\n                (*exported_func64_addrs[symbol_idx]) = f2c_func64_wrappers[f2c_symbol_idx];\n            }\n        }\n    }\n#endif // F2C_AUTODETECTION\n    return 0;\n}\n\nLBT_DLLEXPORT const void * lbt_get_forward(const char * symbol_name, int32_t interface, int32_t f2c) {\n    // Search symbol list for `symbol_name`, then sub off to `set_forward_by_index()`\n    int32_t symbol_idx = find_symbol_idx(symbol_name);\n    if (symbol_idx == -1)\n        return (const void *)-1;\n    \n#ifdef F2C_AUTODETECTION\n    if (f2c == LBT_F2C_REQUIRED) {\n        // Check to see if this symbol is one of the f2c functions\n        int f2c_symbol_idx = 0;\n        for (f2c_symbol_idx=0; f2c_func_idxs[f2c_symbol_idx] != -1; ++f2c_symbol_idx) {\n            // Skip any symbols that aren't ours\n            if (f2c_func_idxs[f2c_symbol_idx] != symbol_idx)\n                continue;\n\n            // If we find it, return the \"true\" address, but only if the currently-exported\n            // address is actually our f2c wrapper; if it's not then do nothing.\n            if (interface == LBT_INTERFACE_LP64) {\n                if (*exported_func32_addrs[symbol_idx] == f2c_func32_wrappers[f2c_symbol_idx]) {\n                    return (const void *)(*f2c_func32_addrs[f2c_symbol_idx]);\n                }\n            } else {\n                if (*exported_func64_addrs[symbol_idx] == f2c_func64_wrappers[f2c_symbol_idx]) {\n                    return (const void *)(*f2c_func64_addrs[f2c_symbol_idx]);\n                }\n            }\n        }\n    }\n#endif\n\n    // If we're not in f2c-hell, we can just return our interface's address directly.\n    if (interface == LBT_INTERFACE_LP64) {\n        return (const void *)(*exported_func32_addrs[symbol_idx]);\n    } else {\n        return (const void *)(*exported_func64_addrs[symbol_idx]);\n    }\n}\n\nLBT_DLLEXPORT int32_t lbt_set_forward(const char * symbol_name, const void * addr, int32_t interface, int32_t f2c, int32_t verbose) {\n    // Search symbol list for `symbol_name`, then sub off to `set_forward_by_index()`\n    int32_t symbol_idx = find_symbol_idx(symbol_name);\n    if (symbol_idx == -1)\n        return -1;\n\n    return set_forward_by_index(symbol_idx, addr, interface, f2c, verbose);\n}\n\n/*\n * Load `libname`, clearing previous mappings if `clear` is set.\n */\nLBT_DLLEXPORT int32_t lbt_forward(const char * libname, int32_t clear, int32_t verbose) {\n    if (verbose) {\n        printf(\"Generating forwards to %s\\n\", libname);\n    }\n\n    // Load the library, throwing an error if we can't actually load it\n    void * handle = load_library(libname);\n    if (handle == NULL) {\n        fprintf(stderr, \"Unable to load \\\"%s\\\"\\n\", libname);\n        return 0;\n    }\n\n    // Once we have the BLAS/LAPACK library loaded, we need to autodetect a few things about it.\n    // First, we are going to figure out its name-mangling suffix:\n    const char * lib_suffix = autodetect_symbol_suffix(handle);\n    if (lib_suffix == NULL) {\n        fprintf(stderr, \"Unable to autodetect symbol suffix of \\\"%s\\\"\\n\", libname);\n        return 0;\n    }\n    if (verbose) {\n        printf(\" -> Autodetected symbol suffix \\\"%s\\\"\\n\", lib_suffix);\n    }\n\n    // Next, we need to figure out if it's a 32-bit or 64-bit BLAS library;\n    // we'll do that by calling `autodetect_interface()`:\n    int interface = autodetect_interface(handle, lib_suffix);\n    if (interface == LBT_INTERFACE_UNKNOWN) {\n        fprintf(stderr, \"Unable to autodetect interface type of \\\"%s\\\"\\n\", libname);\n        return 0;\n    }\n    if (verbose) {\n        if (interface == LBT_INTERFACE_ILP64) {\n            printf(\" -> Autodetected interface ILP64 (64-bit)\\n\");\n        }\n        if (interface == LBT_INTERFACE_LP64) {\n            printf(\" -> Autodetected interface LP64 (32-bit)\\n\");\n        }\n    }\n\n    int f2c = LBT_F2C_PLAIN;\n#ifdef F2C_AUTODETECTION\n    // Next, we need to probe to see if this is an f2c-style calling convention library\n    // The only major example of this that we know of is Accelerate on macOS\n    f2c = autodetect_f2c(handle, lib_suffix);\n    if (f2c == LBT_F2C_UNKNOWN) {\n        fprintf(stderr, \"Unable to autodetect calling convention of \\\"%s\\\"\\n\", libname);\n        return 0;\n    }\n    if (verbose) {\n        if (f2c == LBT_F2C_REQUIRED) {\n            printf(\" -> Autodetected f2c-style calling convention\\n\");\n        }\n        if (f2c == LBT_F2C_PLAIN) {\n            printf(\" -> Autodetected gfortran calling convention\\n\");\n        }\n    }\n#endif\n\n    /*\n     * Now, if we are opening a 64-bit library with 32-bit names (e.g. suffix == \"\"),\n     * we can handle that... as long as we're on a system where we can tell a library\n     * to look up its own symbols before consulting the global symbol table.  This is\n     * important so that when e.g. ILP64 `dgemm_` in this library wants to look up\n     * `foo_`, it needs to find its own `foo_` but it will find the `foo_` trampoline\n     * in this library unless we have `RTLD_DEEPBIND` semantics.  These semantics are\n     * the default on MacOS and Windows, and on glibc Linux we enable it with the\n     * dlopen flag `RTLD_DEEPBIND`, but on musl and FreeBSD we don't have access to\n     * this flag, so we warn the user that they will be unable to load both LP64 and\n     * ILP64 libraries on this system.  I hear support for this is coming in FreeBSD\n     * 13.0, so some day this may be possible, but I sincerely hope that this\n     * capability is not something being designed into new applications.\n     *\n     * If you are on a system without the ability for `RTLD_DEEPBIND` semantics no\n     * sweat, this should work just fine as long as you either (a) only use one\n     * BLAS library at a time, or (b) use two that have properly namespaced their\n     * symbols with a different suffix.  But if you use two different BLAS libraries\n     * with the same suffix, this library will complain.  Loudly.\n     *\n     * We track this by setting flags in `deepbindless_interfaces_loaded` to show\n     * which interfaces have been loaded with an empty suffix; if the user\n     * attempts to load another one without setting the `clear` flag, we refuse to\n     * load it on a deepbindless system, printing out to `stderr` if we're verbose.\n     */\n#if defined(LBT_DEEPBINDLESS)\n    // If `clear` is set, we clear our tracking\n    if (clear) {\n        deepbindless_interfaces_loaded = 0x00;\n    }\n\n    // If we ever load an LP64 BLAS, we mark that interface as being loaded since\n    // we bind to the suffix-\"\" names, so even if the names of that library\n    // internally are suffixed to something else, we ourselves will interfere with\n    // a future suffix-\"\" ILP64 BLAS.\n    if (interface == LBT_INTERFACE_LP64) {\n        deepbindless_interfaces_loaded |= DEEPBINDLESS_INTERFACE_LP64_LOADED;\n    }\n\n    // We only mark a loaded ILP64 BLAS if it is a suffix-\"\" BLAS, since that is\n    // the only case in which it will interfere with our LP64 BLAS symbols.\n    if (lib_suffix[0] == '\\0' && interface == LBT_INTERFACE_ILP64) {\n        deepbindless_interfaces_loaded |= DEEPBINDLESS_INTERFACE_ILP64_LOADED;\n    }\n\n    // If more than one flag is set, complain.\n    if (deepbindless_interfaces_loaded == (DEEPBINDLESS_INTERFACE_ILP64_LOADED | DEEPBINDLESS_INTERFACE_LP64_LOADED)) {\n        if (verbose) {\n            fprintf(stderr, \"ERROR: Cannot load both LP64 and ILP64 BLAS libraries without proper namespacing on an RTLD_DEEPBIND-less system!\\n\");\n        }\n        return 0;\n    }\n#endif\n\n    // If `clear` is set, drop all information about previously-loaded libraries\n    if (clear) {\n        clear_loaded_libraries();\n    }\n\n    // Finally, re-export its symbols:\n    int32_t nforwards = 0;\n    int32_t symbol_idx = 0;\n    char symbol_name[MAX_SYMBOL_LEN];\n    for (symbol_idx=0; exported_func_names[symbol_idx] != NULL; ++symbol_idx) {\n        // If `clear` is set, zero out all symbols that may have been set so far\n        if (clear) {\n            (*exported_func32_addrs[symbol_idx]) = default_func;\n            (*exported_func64_addrs[symbol_idx]) = default_func;\n        }\n\n        // Look up this symbol in the given library, if it is a valid symbol, set it!\n        sprintf(symbol_name, \"%s%s\", exported_func_names[symbol_idx], lib_suffix);\n        void *addr = lookup_symbol(handle, symbol_name);\n        if (addr != NULL) {\n            set_forward_by_index(symbol_idx,  addr, interface, f2c, verbose);\n            nforwards++;\n        }\n    }\n\n    record_library_load(libname, handle, lib_suffix, interface, f2c);\n    if (verbose) {\n        printf(\"Processed %d symbols; forwarded %d symbols with %d-bit interface and mangling to a suffix of \\\"%s\\\"\\n\", symbol_idx, nforwards, interface, lib_suffix);\n    }\n\n    return nforwards;\n}\n\n\n__attribute__((constructor)) void init(void) {\n    // Initialize config structures\n    init_config();\n\n    // If LBT_VERBOSE == \"1\", the startup invocation should be verbose\n    int verbose = 0;\n    const char * verbose_str = getenv(\"LBT_VERBOSE\");\n    if (verbose_str != NULL && strcmp(verbose_str, \"1\") == 0) {\n        verbose = 1;\n        printf(\"libblastrampoline initializing\\n\");\n    }\n\n    // LBT_DEFAULT_LIBS is a semicolon-separated list of paths that should be loaded as BLAS libraries\n    const char * default_libs = getenv(\"LBT_DEFAULT_LIBS\");\n    if (default_libs != NULL) {\n        const char * curr_lib_start = default_libs;\n        int clear = 1;\n        char curr_lib[PATH_MAX];\n        while (curr_lib_start[0] != '\\0') {\n            // Find the end of this current library name\n            const char * end = curr_lib_start;\n            while (*end != ';' && *end != '\\0')\n                end++;\n\n            // Copy it into a temporary location\n            int len = end - curr_lib_start;\n            memcpy(curr_lib, curr_lib_start, len);\n            curr_lib[len] = '\\0';\n            curr_lib_start = end;\n            while (curr_lib_start[0] == ';')\n                curr_lib_start++;\n\n            // Load functions from this library, clearing only the first time.\n            lbt_forward(curr_lib, clear, verbose);\n            clear = 0;\n        }\n    }\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-libblastrampoline-2.2.0-grgevrb2cpp25m4pafbmzuk5pnnhtea6/spack-src/test/runtests.jl": "using OpenBLAS_jll, OpenBLAS32_jll, MKL_jll, CompilerSupportLibraries_jll\nusing Pkg, Artifacts, Base.BinaryPlatforms, Libdl, Test\n\ninclude(\"utils.jl\")\n\n# Compile `dgemm_test.c` and `sgesv_test.c` against the given BLAS/LAPACK\nfunction run_test((test_name, test_expected_outputs), libblas_name, libdirs, interface, backing_libs)\n    # We need to configure this C build a bit\n    cflags = String[\n        \"-g\",\n    ]\n    if interface == :ILP64\n        push!(cflags, \"-DILP64\")\n    end\n\n   # If our GCC is 64-bit but Julia is 32-bit, pass -m32\n   if needs_m32()\n       push!(cflags, \"-m32\")\n   end\n    \n    ldflags = String[\n        # Teach it to find that libblas and its dependencies at build time\n        (\"-L$(pathesc(libdir))\" for libdir in libdirs)...,\n        \"-l$(libblas_name)\",\n    ]\n\n    if !Sys.iswindows()\n        # Teach it to find that libblas and its dependencies at run time\n        append!(ldflags, (\"-Wl,-rpath,$(pathesc(libdir))\" for libdir in libdirs))\n    end\n\n    mktempdir() do dir\n        @info(\"Compiling `$(test_name)` against $(libblas_name) ($(backing_libs)) in $(dir)\")\n        srcdir = joinpath(@__DIR__, test_name)\n        make_cmd = `$(make) -sC $(pathesc(srcdir)) prefix=$(pathesc(dir)) CFLAGS=\"$(join(cflags, \" \"))\" LDFLAGS=\"$(join(ldflags, \" \"))\"`\n        p = run(ignorestatus(make_cmd))\n        if !success(p)\n            @error(\"compilation failed\", srcdir, prefix=dir, cflags=join(cflags, \" \"), ldflags=join(ldflags, \" \"))\n        end\n        @test success(p)\n    \n        env = Dict(\n            # We need to tell it how to find CSL at run-time\n            LIBPATH_env => append_libpath(libdirs),\n            \"LBT_DEFAULT_LIBS\" => backing_libs,\n        )\n        cmd = `$(dir)/$(test_name)`\n        output = capture_output(addenv(cmd, env))\n\n        # Test to make sure the test ran properly\n        has_expected_output = all(occursin(expected, output) for expected in test_expected_outputs)\n        if !has_expected_output\n            # Uh-oh, we didn't get what we expected.  Time to debug!\n            @error(\"Test failed, got output:\")\n            println(output)\n\n            # If we're not on CI, launch `gdb`\n            if isempty(get(ENV, \"CI\", \"\"))\n                debugger = Sys.isbsd() ? \"lldb\" : \"gdb\"\n                @warn(\"Launching $debugger\")\n                cmd = `$(debugger) $(cmd)`\n                env[\"LBT_VERBOSE\"] = \"1\"\n                run(addenv(cmd, env))\n            end\n        end\n        @test has_expected_output\n    end\nend\n\n# our tests\ndgemm = (\"dgemm_test\", (\"||C||^2 is:  24.3384\",))\nsgesv = (\"sgesv_test\", (\"||b||^2 is:   3.0000\",))\nsdot  = (\"sdot_test\",  (\"C is:   1.9900\"))\n\n# Build version that links against vanilla OpenBLAS\nopenblas_interface = :LP64\nif Sys.WORD_SIZE == 64 && Sys.ARCH != :aarch64\n    openblas_interface = :ILP64\nend\nopenblas_jll_libname = splitext(basename(OpenBLAS_jll.libopenblas_path)[4:end])[1]\n@testset \"Vanilla OpenBLAS_jll ($(openblas_interface))\" begin\n    run_test(dgemm, openblas_jll_libname, OpenBLAS_jll.LIBPATH_list, openblas_interface, \"\")\n    run_test(sgesv, openblas_jll_libname, OpenBLAS_jll.LIBPATH_list, openblas_interface, \"\")\n    run_test(sdot,  openblas_jll_libname, OpenBLAS_jll.LIBPATH_list, openblas_interface, \"\")\nend\n\n# Build version that links against vanilla OpenBLAS32\n@testset \"Vanilla OpenBLAS32_jll (LP64)\" begin\n    run_test(dgemm, \"openblas\", OpenBLAS32_jll.LIBPATH_list, :LP64, \"\")\n    run_test(sgesv, \"openblas\", OpenBLAS32_jll.LIBPATH_list, :LP64, \"\")\n    run_test(sdot,  \"openblas\", OpenBLAS32_jll.LIBPATH_list, :LP64, \"\")\nend\n\n# Next, build a version that links against `libblastrampoline`, and tell\n# the trampoline to forwards calls to `OpenBLAS_jll`\nlbt_dir = joinpath(get_blastrampoline_dir(), binlib)\n\n@testset \"LBT -> OpenBLAS_jll ($(openblas_interface))\" begin\n    libdirs = unique(vcat(OpenBLAS_jll.LIBPATH_list..., CompilerSupportLibraries_jll.LIBPATH_list..., lbt_dir))\n    run_test(dgemm, \"blastrampoline\", libdirs, openblas_interface, OpenBLAS_jll.libopenblas_path)\n    run_test(sgesv, \"blastrampoline\", libdirs, openblas_interface, OpenBLAS_jll.libopenblas_path)\n    run_test(sdot,  \"blastrampoline\", libdirs, openblas_interface, OpenBLAS_jll.libopenblas_path)\nend\n\n# And again, but this time with OpenBLAS32_jll\n@testset \"LBT -> OpenBLAS32_jll (LP64)\" begin\n    libdirs = unique(vcat(OpenBLAS32_jll.LIBPATH_list..., CompilerSupportLibraries_jll.LIBPATH_list..., lbt_dir))\n    run_test(dgemm, \"blastrampoline\", libdirs, :LP64, OpenBLAS32_jll.libopenblas_path)\n    run_test(sgesv, \"blastrampoline\", libdirs, :LP64, OpenBLAS32_jll.libopenblas_path)\n    run_test(sdot,  \"blastrampoline\", libdirs, :LP64, OpenBLAS32_jll.libopenblas_path)\nend\n\n# Test against MKL_jll using `libmkl_rt`, which is :LP64 by default\nif MKL_jll.is_available()\n    @testset \"LBT -> MKL_jll (LP64)\" begin\n        libdirs = unique(vcat(MKL_jll.LIBPATH_list..., CompilerSupportLibraries_jll.LIBPATH_list..., lbt_dir))\n        run_test(dgemm, \"blastrampoline\", libdirs, :LP64, MKL_jll.libmkl_rt_path)\n        run_test(sgesv, \"blastrampoline\", libdirs, :LP64, MKL_jll.libmkl_rt_path)\n        run_test(sdot,  \"blastrampoline\", libdirs, :LP64, MKL_jll.libmkl_rt_path)\n    end\n\n    # Test that we can set MKL's interface via an environment variable to select ILP64, and LBT detects it properly\n    if Sys.WORD_SIZE == 64\n        @testset \"LBT -> MKL_jll (ILP64, via env)\" begin\n            withenv(\"MKL_INTERFACE_LAYER\" => \"ILP64\") do\n                libdirs = unique(vcat(MKL_jll.LIBPATH_list..., CompilerSupportLibraries_jll.LIBPATH_list..., lbt_dir))\n                run_test(dgemm, \"blastrampoline\", libdirs, :ILP64, MKL_jll.libmkl_rt_path)\n                run_test(sgesv, \"blastrampoline\", libdirs, :ILP64, MKL_jll.libmkl_rt_path)\n                run_test(sdot,  \"blastrampoline\", libdirs, :ILP64, MKL_jll.libmkl_rt_path)\n            end\n        end\n    end\nend\n\n# Do we have Accelerate available?\nveclib_blas_path = \"/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/libBLAS.dylib\"\nif isfile(veclib_blas_path)\n    @testset \"LBT -> vecLib/libBLAS\" begin\n        run_test(dgemm, \"blastrampoline\", [lbt_dir], :LP64, veclib_blas_path)\n        run_test(sdot,  \"blastrampoline\", [lbt_dir], :LP64, veclib_blas_path)\n    end\n\n    veclib_lapack_path = \"/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/libLAPACK.dylib\"\n    @testset \"LBT -> vecLib/libLAPACK\" begin\n        run_test(dgemm, \"blastrampoline\", [lbt_dir], :LP64, string(veclib_blas_path, \";\", veclib_lapack_path))\n        run_test(sgesv, \"blastrampoline\", [lbt_dir], :LP64, string(veclib_blas_path, \";\", veclib_lapack_path))\n        run_test(sdot,  \"blastrampoline\", [lbt_dir], :LP64, string(veclib_blas_path, \";\", veclib_lapack_path))\n    end\nend\n\n\n# Do we have a `blas64.so` somewhere?  If so, test with that for fun\nblas64 = dlopen(\"libblas64\", throw_error=false)\nif blas64 !== nothing\n    @testset \"LBT -> libblas64 (ILP64, BLAS)\" begin\n        run_test(dgemm, \"blastrampoline\", [lbt_dir], :ILP64, dlpath(blas64))\n        run_test(sdot,  \"blastrampoline\", [lbt_dir], :ILP64, dlpath(blas64))\n        # Can't run `sgesv` here as we don't have LAPACK symbols in `libblas64.so`\n    end\n\n    # Check if we have a `liblapack` and if we do, run again, this time including `sgesv`\n    lapack = dlopen(\"liblapack64\", throw_error=false)\n    if lapack !== nothing\n        @testset \"LBT -> libblas64 + liblapack64 (ILP64, BLAS+LAPACK)\" begin\n            run_test(dgemm, \"blastrampoline\", [lbt_dir], :ILP64, \"$(dlpath(blas64));$(dlpath(lapack))\")\n            run_test(sgesv, \"blastrampoline\", [lbt_dir], :ILP64, \"$(dlpath(blas64));$(dlpath(lapack))\")\n            run_test(sdot,  \"blastrampoline\", [lbt_dir], :ILP64, \"$(dlpath(blas64));$(dlpath(lapack))\")\n        end\n    end\nend\n\n# Finally the super-crazy test: build a binary that links against BOTH sets of symbols!\nif openblas_interface == :ILP64\n    inconsolable = (\"inconsolable_test\", (\"||C||^2 is:  24.3384\", \"||b||^2 is:   3.0000\"))\n    @testset \"LBT -> OpenBLAS 32 + 64 (LP64 + ILP64)\" begin\n        libdirs = unique(vcat(OpenBLAS32_jll.LIBPATH_list..., OpenBLAS_jll.LIBPATH_list..., CompilerSupportLibraries_jll.LIBPATH_list..., lbt_dir))\n        run_test(inconsolable, \"blastrampoline\", libdirs, :wild_sobbing, \"$(OpenBLAS32_jll.libopenblas_path);$(OpenBLAS_jll.libopenblas_path)\")\n    end\nend\n\n# Run our \"direct\" tests within Julia\ninclude(\"direct.jl\")\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-libblastrampoline-2.2.0-grgevrb2cpp25m4pafbmzuk5pnnhtea6/spack-src/test/direct.jl": "using Libdl, Test, OpenBLAS_jll, OpenBLAS32_jll\n\ninclude(\"utils.jl\")\n\nfunction unpack_loaded_libraries(config::lbt_config_t)\n    libs = LBTLibraryInfo[]\n    idx = 1\n    lib_ptr = unsafe_load(config.loaded_libs, idx)\n    while lib_ptr != C_NULL\n        push!(libs, LBTLibraryInfo(unsafe_load(lib_ptr)))\n\n        idx += 1\n        lib_ptr = unsafe_load(config.loaded_libs, idx)\n    end\n    return libs\nend\n\nlbt_prefix = get_blastrampoline_dir()\nlbt_handle = dlopen(\"$(lbt_prefix)/$(binlib)/libblastrampoline.$(shlib_ext)\", RTLD_GLOBAL | RTLD_DEEPBIND)\n\n@testset \"Config\" begin\n    @test lbt_handle != C_NULL\n\n    # Get immediate config, ensure that nothing is loaded\n    config = lbt_get_config(lbt_handle)\n    @test isempty(unpack_loaded_libraries(config))\n\n    # Load OpenBLAS and OpenBLAS32_jll and then OpenBLAS_jll again\n    lbt_forward(lbt_handle, OpenBLAS_jll.libopenblas_path; clear=true)\n    lbt_forward(lbt_handle, OpenBLAS32_jll.libopenblas_path)\n    lbt_forward(lbt_handle, OpenBLAS_jll.libopenblas_path)\n\n    # Get config\n    config = lbt_get_config(lbt_handle)\n\n    # If we're x86_64, ensure LBT thinks it's f2c-adapter capable\n    if Sys.ARCH == :x86_64\n        @test (config.build_flags & LBT_BUILDFLAGS_F2C_CAPABLE) != 0\n    end\n\n    # Walk the libraries and check we have two\n    libs = unpack_loaded_libraries(config)\n    @test length(libs) == 2\n\n    # First check OpenBLAS_jll which may or may not be ILP64\n    @test libs[1].libname == OpenBLAS_jll.libopenblas_path\n    if Sys.WORD_SIZE == 64 && Sys.ARCH != :aarch64\n        @test libs[1].suffix == \"64_\"\n        @test libs[1].interface == LBT_INTERFACE_ILP64\n    else\n        @test libs[1].suffix == \"\"\n        @test libs[1].interface == LBT_INTERFACE_LP64\n    end\n    @test libs[1].f2c == LBT_F2C_PLAIN\n\n    # Next check OpenBLAS32_jll which is always LP64\n    @test libs[2].libname == OpenBLAS32_jll.libopenblas_path\n    @test libs[2].suffix == \"\"\n    @test libs[2].interface == LBT_INTERFACE_LP64\n    @test libs[2].f2c == LBT_F2C_PLAIN\n\n    # Load OpenBLAS32_jll again, but this time clearing it and ensure the config gets cleared too\n    lbt_forward(lbt_handle, OpenBLAS32_jll.libopenblas_path; clear=true)\n    config = lbt_get_config(lbt_handle)\n    libs = unpack_loaded_libraries(config)\n    @test length(libs) == 1\n    @test libs[1].libname == OpenBLAS32_jll.libopenblas_path\n    @test libs[1].suffix == \"\"\n    @test libs[1].interface == LBT_INTERFACE_LP64\n    @test libs[1].f2c == LBT_F2C_PLAIN\n\nend\n\n@testset \"get/set threads\" begin\n    lbt_forward(lbt_handle, OpenBLAS32_jll.libopenblas_path; clear=true)\n\n    # get/set threads\n    nthreads = ccall(dlsym(OpenBLAS32_jll.libopenblas_handle, :openblas_get_num_threads), Cint, ())\n    @test lbt_get_num_threads(lbt_handle) == nthreads\n    nthreads = div(nthreads, 2)\n    lbt_set_num_threads(lbt_handle, nthreads)\n    @test ccall(dlsym(OpenBLAS32_jll.libopenblas_handle, :openblas_get_num_threads), Cint, ()) == nthreads\n    @test lbt_get_num_threads(lbt_handle) == nthreads\n\n    # If we're on a 64-bit system, load OpenBLAS_jll in and cause a mismatch in the threading\n    if Sys.WORD_SIZE == 64 && Sys.ARCH != :aarch64\n        lbt_forward(lbt_handle, OpenBLAS_jll.libopenblas_path)\n\n        lbt_set_num_threads(lbt_handle, 1)\n        @test lbt_get_num_threads(lbt_handle) == 1\n        @test ccall(dlsym(OpenBLAS32_jll.libopenblas_handle, :openblas_get_num_threads), Cint, ()) == 1\n\n        ccall(dlsym(OpenBLAS32_jll.libopenblas_handle, :openblas_set_num_threads), Cvoid, (Cint,), 2)\n        @test lbt_get_num_threads(lbt_handle) == 2\n        lbt_set_num_threads(lbt_handle, 1)\n        @test lbt_get_num_threads(lbt_handle) == 1\n    end\nend\n\nslamch_args = []\nfunction record_slamch_args(str::Cstring)\n    push!(slamch_args, unsafe_string(str))\n    return 13.37f0\nend\n\n# This \"default function\" will keep track of everyone who tries to call an uninitialized BLAS function\nstacktraces = []\nfunction default_capture_stacktrace()\n    push!(stacktraces, stacktrace(true))\n    return nothing\nend\n\n@testset \"footgun API\" begin\n    # Load OpenBLAS32\n    lbt_forward(lbt_handle, OpenBLAS32_jll.libopenblas_path; clear=true)\n\n    # Test that we can get the `dgemm_` symbol address, and that it is what we expect\n    slamch_32 = dlsym(OpenBLAS32_jll.libopenblas_handle, :slamch_)\n    @test slamch_32 != C_NULL\n    @test lbt_get_forward(lbt_handle, \"slamch_\", LBT_INTERFACE_LP64) == slamch_32\n\n    # Now, test that we can muck this up\n    my_slamch = @cfunction(record_slamch_args, Float32, (Cstring,))\n    @test lbt_set_forward(lbt_handle, \"slamch_\", my_slamch, LBT_INTERFACE_LP64) == 0\n    @test lbt_get_forward(lbt_handle, \"slamch_\", LBT_INTERFACE_LP64) == my_slamch\n\n    # Ensure that we actually overrode the symbol\n    @test ccall(dlsym(lbt_handle, \"slamch_\"), Float32, (Cstring,), \"test\") == 13.37f0\n    @test slamch_args == [\"test\"]\n\n    # Override the default function to keep track of people who try to call uninitialized BLAS functions\n    @test lbt_get_default_func(lbt_handle) != C_NULL\n    my_default_func = @cfunction(default_capture_stacktrace, Cvoid, ())\n    lbt_set_default_func(lbt_handle, my_default_func)\n    @test lbt_get_default_func(lbt_handle) == my_default_func\n\n    # Now, set `slamch_64_` to it\n    @test lbt_set_forward(lbt_handle, \"slamch_\", C_NULL, LBT_INTERFACE_ILP64) == 0\n    ccall(dlsym(lbt_handle, \"slamch_64_\"), Float32, (Cstring,), \"this will call the default function\")\n    @test length(stacktraces) == 1\n    self_traces = filter(entry -> string(entry.file) == @__FILE__, stacktraces[1])\n    @test length(self_traces) == 3\nend\n"
    },
    "skipped": [],
    "total_files": 272
}