{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-collectd-5.10.0-icicefkrlae7wizwnsjlpgrx3lkx7h7i/spack-src/configure.ac": "dnl Process this file with autoconf to produce a configure script.\nAC_PREREQ([2.60])\nAC_INIT([collectd],[m4_esyscmd(./version-gen.sh)])\nAC_CONFIG_SRCDIR(src/target_set.c)\nAC_CONFIG_HEADERS(src/config.h)\nAC_CONFIG_AUX_DIR([build-aux])\nAC_CONFIG_MACRO_DIR([m4])\n\ndnl older automake's default of ARFLAGS=cru is noisy on newer binutils;\ndnl we don't really need the 'u' even in older toolchains.  Then there is\ndnl older libtool, which spelled it AR_FLAGS\nm4_divert_text([DEFAULTS], [: \"${ARFLAGS=cr} ${AR_FLAGS=cr}\"])\n\nLT_INIT([dlopen disable-static])\n\nAM_INIT_AUTOMAKE([subdir-objects tar-pax dist-bzip2 no-dist-gzip foreign])\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\nAC_LANG(C)\n\nAC_PREFIX_DEFAULT(\"/opt/collectd\")\n\nAC_SYS_LARGEFILE\n\n#\n# Checks for programs.\n#\nAC_PROG_CC_C99([],\n  [AC_MSG_ERROR([No compiler found that supports C99])]\n)\n\nAX_COMPILER_VENDOR\n\nAC_PROG_CXX\nAC_PROG_CPP\nAC_PROG_EGREP\nAC_PROG_INSTALL\nAC_PROG_LN_S\nAC_PROG_MAKE_SET\nAM_PROG_CC_C_O\n\nAC_PROG_LEX\nAC_PROG_YACC\n\nAC_PATH_PROG([VALGRIND], [valgrind])\n\n# Warn when pkg.m4 is missing\nm4_pattern_forbid([^_?PKG_[A-Z_]+$],[*** pkg.m4 missing, please install pkg-config])\n\nPKG_PROG_PKG_CONFIG\n\nAC_CACHE_CHECK([if Bison is the parser generator],\n  [collectd_cv_prog_bison],\n  [\n    AS_IF([$YACC --version 2>/dev/null | $EGREP -q '^bison '],\n      [collectd_cv_prog_bison=yes],\n      [collectd_cv_prog_bison=no]\n    )\n  ]\n)\n\nif test \"x$collectd_cv_prog_bison\" = \"xno\" && test ! -f \"${srcdir}/src/liboconfig/parser.c\"; then\n  AC_MSG_ERROR([bison is missing and you do not have ${srcdir}/src/liboconfig/parser.c. Please install bison])\nfi\n\nif test \"x$lt_cv_dlopen\" = \"xno\"; then\n  AC_MSG_ERROR([Your system does not support dlopen])\nfi\n\nAC_SUBST([DLOPEN_LIBS], [$lt_cv_dlopen_libs])\n\n\nAC_MSG_CHECKING([for kernel type ($host_os)])\ncase $host_os in\n  *aix*)\n    AC_DEFINE([KERNEL_AIX], [1], [True if program is to be compiled for a AIX kernel])\n    ac_system=\"AIX\"\n    ;;\n  *darwin*)\n    AC_DEFINE([KERNEL_DARWIN], [1], [True if program is to be compiled for a Darwin kernel])\n    ac_system=\"Darwin\"\n    ;;\n  *freebsd*)\n    AC_DEFINE([KERNEL_FREEBSD], [1], [True if program is to be compiled for a FreeBSD kernel])\n    ac_system=\"FreeBSD\"\n    ;;\n  *linux*)\n    AC_DEFINE([KERNEL_LINUX], [1], [True if program is to be compiled for a Linux kernel])\n    ac_system=\"Linux\"\n    ;;\n  *netbsd*)\n    AC_DEFINE([KERNEL_NETBSD], [1], [True if program is to be compiled for a NetBSD kernel])\n    ac_system=\"NetBSD\"\n    ;;\n  *openbsd*)\n    AC_DEFINE([KERNEL_OPENBSD], [1], [True if program is to be compiled for an OpenBSD kernel])\n    ac_system=\"OpenBSD\"\n    ;;\n  *solaris*)\n    AC_DEFINE([KERNEL_SOLARIS], [1], [True if program is to be compiled for a Solaris kernel])\n    ac_system=\"Solaris\"\n    ;;\n  *mingw32*)\n    AC_DEFINE([KERNEL_WIN32], [1], [True if program is to be compiled for a Windows kernel])\n    ac_system=\"Windows\"\n    ;;\n  *)\n    ac_system=\"unknown\"\n    ;;\nesac\nAC_MSG_RESULT([$ac_system])\n\nAM_CONDITIONAL([BUILD_AIX], [test \"x$ac_system\" = \"xAIX\"])\nAM_CONDITIONAL([BUILD_DARWIN], [test \"x$ac_system\" = \"xDarwin\"])\nAM_CONDITIONAL([BUILD_FREEBSD], [test \"x$ac_system\" = \"xFreeBSD\"])\nAM_CONDITIONAL([BUILD_LINUX], [test \"x$ac_system\" = \"xLinux\"])\nAM_CONDITIONAL([BUILD_OPENBSD], [test \"x$ac_system\" = \"xOpenBSD\"])\nAM_CONDITIONAL([BUILD_SOLARIS], [test \"x$ac_system\" = \"xSolaris\"])\nAM_CONDITIONAL([BUILD_WIN32], [test \"x$ac_system\" = \"xWindows\"])\n\nif test \"x$ac_system\" = \"xSolaris\"; then\n  AC_DEFINE([_POSIX_PTHREAD_SEMANTICS], [1], [Define to enforce POSIX thread semantics under Solaris.])\n  AC_DEFINE([_REENTRANT], [1], [Define to enable reentrancy interfaces.])\n\n  AC_MSG_CHECKING([whether compiler builds 64bit binaries])\n  AC_COMPILE_IFELSE(\n    [\n      AC_LANG_PROGRAM(\n        [\n          #ifndef _LP64\n          # error \"Compiler not in 64bit mode.\"\n          #endif\n        ]\n      )\n    ],\n    [AC_MSG_RESULT([yes])],\n    [\n      AC_MSG_RESULT([no])\n      AC_MSG_NOTICE([Solaris detected. Please consider building a 64-bit binary.])\n    ]\n  )\nfi\n\nif test \"x$ac_system\" = \"xAIX\"; then\n  AC_DEFINE([_THREAD_SAFE_ERRNO], [1], [Define to use the thread-safe version of errno under AIX.])\nfi\n\n# Where to install .pc files.\npkgconfigdir=\"${libdir}/pkgconfig\"\nAC_SUBST([pkgconfigdir])\n\n#\n# Checks for header files.\n#\nAC_HEADER_SYS_WAIT\nAC_HEADER_DIRENT\n\nAC_CHECK_HEADERS_ONCE([ \\\n  arpa/inet.h \\\n  endian.h \\\n  fcntl.h \\\n  fnmatch.h \\\n  fs_info.h \\\n  fshelp.h \\\n  grp.h \\\n  kstat.h \\\n  kvm.h \\\n  libgen.h \\\n  locale.h \\\n  mntent.h \\\n  mnttab.h \\\n  netdb.h \\\n  paths.h \\\n  poll.h \\\n  pthread_np.h \\\n  pwd.h \\\n  regex.h \\\n  sys/endian.h \\\n  sys/fs_types.h \\\n  sys/fstyp.h \\\n  sys/ioctl.h \\\n  sys/isa_defs.h \\\n  sys/mntent.h \\\n  sys/mnttab.h \\\n  sys/param.h \\\n  sys/resource.h \\\n  sys/select.h \\\n  sys/socket.h \\\n  sys/statfs.h \\\n  sys/statvfs.h \\\n  sys/types.h \\\n  sys/un.h \\\n  sys/vfs.h \\\n  sys/vfstab.h \\\n  sys/vmmeter.h \\\n  syslog.h \\\n  wordexp.h\n])\n\nif test \"x$ac_system\" = \"xNetBSD\"; then\n  # For entropy plugin on newer NetBSD\n  AC_CHECK_HEADERS([sys/rndio.h], [], [],\n    [[\n      #if HAVE_SYS_TYPES_H\n      # include <sys/types.h>\n      #endif\n      #if HAVE_SYS_IOCTL_H\n      # include <sys/ioctl.h>\n      #endif\n      #if HAVE_SYS_PARAM_H\n      # include <sys/param.h>\n      #endif\n    ]]\n  )\nfi\n\n# For ping library\nAC_CHECK_HEADERS([netinet/in_systm.h], [], [],\n  [[\n    #include <stdint.h>\n    #if HAVE_SYS_TYPES_H\n    # include <sys/types.h>\n    #endif\n  ]]\n)\n\nAC_CHECK_HEADERS([netinet/in.h], [], [],\n  [[\n    #include <stdint.h>\n    #if HAVE_SYS_TYPES_H\n    # include <sys/types.h>\n    #endif\n    #if HAVE_NETINET_IN_SYSTM_H\n    # include <netinet/in_systm.h>\n    #endif\n  ]]\n)\n\nAC_CHECK_HEADERS([netinet/ip.h], [], [],\n  [[\n    #include <stdint.h>\n    #if HAVE_SYS_TYPES_H\n    # include <sys/types.h>\n    #endif\n    #if HAVE_NETINET_IN_SYSTM_H\n    # include <netinet/in_systm.h>\n    #endif\n    #if HAVE_NETINET_IN_H\n    # include <netinet/in.h>\n    #endif\n  ]]\n)\n\nAC_CHECK_HEADERS([netinet/ip_icmp.h], [], [],\n  [[\n    #include <stdint.h>\n    #if HAVE_SYS_TYPES_H\n    # include <sys/types.h>\n    #endif\n    #if HAVE_NETINET_IN_SYSTM_H\n    # include <netinet/in_systm.h>\n    #endif\n    #if HAVE_NETINET_IN_H\n    # include <netinet/in.h>\n    #endif\n    #if HAVE_NETINET_IP_H\n    # include <netinet/ip.h>\n    #endif\n  ]]\n)\n\nAC_CHECK_HEADERS([netinet/ip_var.h], [], [],\n  [[\n    #include <stdint.h>\n    #if HAVE_SYS_TYPES_H\n    # include <sys/types.h>\n    #endif\n    #if HAVE_NETINET_IN_SYSTM_H\n    # include <netinet/in_systm.h>\n    #endif\n    #if HAVE_NETINET_IN_H\n    # include <netinet/in.h>\n    #endif\n    #if HAVE_NETINET_IP_H\n    # include <netinet/ip.h>\n    #endif\n  ]]\n)\n\nAC_CHECK_HEADERS([netinet/ip6.h], [], [],\n  [[\n    #include <stdint.h>\n    #if HAVE_SYS_TYPES_H\n    # include <sys/types.h>\n    #endif\n    #if HAVE_NETINET_IN_SYSTM_H\n    # include <netinet/in_systm.h>\n    #endif\n    #if HAVE_NETINET_IN_H\n    # include <netinet/in.h>\n    #endif\n  ]]\n)\n\nAC_CHECK_HEADERS([netinet/icmp6.h], [], [],\n  [[\n    #include <stdint.h>\n    #if HAVE_SYS_TYPES_H\n    # include <sys/types.h>\n    #endif\n    #if HAVE_NETINET_IN_SYSTM_H\n    # include <netinet/in_systm.h>\n    #endif\n    #if HAVE_NETINET_IN_H\n    # include <netinet/in.h>\n    #endif\n    #if HAVE_NETINET_IP6_H\n    # include <netinet/ip6.h>\n    #endif\n  ]]\n)\n\nAC_CHECK_HEADERS([netinet/tcp.h], [], [],\n  [[\n    #include <stdint.h>\n    #if HAVE_SYS_TYPES_H\n    # include <sys/types.h>\n    #endif\n    #if HAVE_NETINET_IN_SYSTM_H\n    # include <netinet/in_systm.h>\n    #endif\n    #if HAVE_NETINET_IN_H\n    # include <netinet/in.h>\n    #endif\n    #if HAVE_NETINET_IP_H\n    # include <netinet/ip.h>\n    #endif\n  ]]\n)\n\nAC_CHECK_HEADERS([netinet/udp.h], [], [],\n  [[\n    #include <stdint.h>\n    #if HAVE_SYS_TYPES_H\n    # include <sys/types.h>\n    #endif\n    #if HAVE_NETINET_IN_SYSTM_H\n    # include <netinet/in_systm.h>\n    #endif\n    #if HAVE_NETINET_IN_H\n    # include <netinet/in.h>\n    #endif\n    #if HAVE_NETINET_IP_H\n    # include <netinet/ip.h>\n    #endif\n  ]]\n)\n\n# For cpu modules\nAC_CHECK_HEADERS([sys/dkstat.h])\nif test \"x$ac_system\" = \"xDarwin\"; then\n  AC_CHECK_HEADERS(\n    [ \\\n      mach/mach_init.h \\\n      mach/host_priv.h \\\n      mach/mach_error.h \\\n      mach/mach_host.h \\\n      mach/mach_port.h \\\n      mach/mach_types.h \\\n      mach/message.h \\\n      mach/processor_set.h \\\n      mach/processor.h \\\n      mach/processor_info.h \\\n      mach/task.h \\\n      mach/thread_act.h \\\n      mach/vm_region.h \\\n      mach/vm_map.h \\\n      mach/vm_prot.h \\\n      mach/vm_statistics.h \\\n      mach/kern_return.h \\\n      CoreFoundation/CoreFoundation.h \\\n      IOKit/IOKitLib.h \\\n      IOKit/IOTypes.h \\\n      IOKit/ps/IOPSKeys.h \\\n      IOKit/IOBSD.h \\\n      IOKit/storage/IOBlockStorageDriver.h\n    ]\n  )\n\n  # For the battery plugin\n  AC_CHECK_HEADERS([IOKit/ps/IOPowerSources.h], [], [],\n    [[\n      #if HAVE_IOKIT_IOKITLIB_H\n      #  include <IOKit/IOKitLib.h>\n      #endif\n      #if HAVE_IOKIT_IOTYPES_H\n      #  include <IOKit/IOTypes.h>\n      #endif\n    ]]\n  )\nfi\n\nAC_CHECK_HEADERS([sys/sysctl.h], [], [],\n  [[\n    #if HAVE_SYS_TYPES_H\n    #  include <sys/types.h>\n    #endif\n    #if HAVE_SYS_PARAM_H\n    # include <sys/param.h>\n    #endif\n  ]]\n)\n\n# For interface plugin\nAC_CHECK_HEADERS([ifaddrs.h])\nAC_CHECK_HEADERS([net/if.h], [], [],\n  [[\n    #if HAVE_SYS_TYPES_H\n    #  include <sys/types.h>\n    #endif\n    #if HAVE_SYS_SOCKET_H\n    #  include <sys/socket.h>\n    #endif\n  ]]\n)\n\nif test \"x$ac_system\" = \"xLinux\"; then\n  # For hddtemp module\n  AC_CHECK_HEADERS([linux/major.h])\n\n  # For md module (Linux only)\n  AC_CHECK_HEADERS([linux/raid/md_u.h],\n    [have_linux_raid_md_u_h=\"yes\"],\n    [have_linux_raid_md_u_h=\"no\"],\n    [[\n      #include <sys/ioctl.h>\n      #include <linux/major.h>\n      #include <linux/types.h>\n    ]]\n  )\n  AC_CHECK_HEADERS([sys/sysmacros.h])\n\n  AC_CHECK_HEADERS([linux/wireless.h],\n    [have_linux_wireless_h=\"yes\"],\n    [have_linux_wireless_h=\"no\"],\n    [[\n      #include <dirent.h>\n      #include <sys/ioctl.h>\n      #include <sys/socket.h>\n    ]]\n  )\n\n  AC_CHECK_HEADERS([linux/if.h], [], [],\n    [[\n      #if HAVE_SYS_TYPES_H\n      #  include <sys/types.h>\n      #endif\n      #if HAVE_SYS_SOCKET_H\n      #  include <sys/socket.h>\n      #endif\n    ]]\n  )\n\n  AC_CHECK_HEADERS([linux/inet_diag.h], [], [],\n    [[\n      #if HAVE_SYS_TYPES_H\n      #  include <sys/types.h>\n      #endif\n      #if HAVE_SYS_SOCKET_H\n      #  include <sys/socket.h>\n      #endif\n    ]]\n  )\n\n  AC_CHECK_HEADERS([linux/netdevice.h], [], [],\n    [[\n      #if HAVE_SYS_TYPES_H\n      #  include <sys/types.h>\n      #endif\n      #if HAVE_SYS_SOCKET_H\n      #  include <sys/socket.h>\n      #endif\n      #if HAVE_LINUX_IF_H\n      # include <linux/if.h>\n      #endif\n    ]]\n  )\n\n  # For ethstat module\n  AC_CHECK_HEADERS([linux/sockios.h],\n    [have_linux_sockios_h=\"yes\"],\n    [have_linux_sockios_h=\"no\"],\n    [[\n      #if HAVE_SYS_IOCTL_H\n      # include <sys/ioctl.h>\n      #endif\n      #if HAVE_NET_IF_H\n      # include <net/if.h>\n      #endif\n    ]]\n  )\n\n  AC_CHECK_HEADERS([linux/ethtool.h],\n    [have_linux_ethtool_h=\"yes\"],\n    [have_linux_ethtool_h=\"no\"],\n    [[\n      #if HAVE_SYS_IOCTL_H\n      # include <sys/ioctl.h>\n      #endif\n      #if HAVE_NET_IF_H\n      # include <net/if.h>\n      #endif\n      #if HAVE_LINUX_SOCKIOS_H\n      # include <linux/sockios.h>\n      #endif\n    ]]\n  )\n\n  # For ipvs module\n  AC_CHECK_HEADERS_ONCE([linux/ip_vs.h])\n\n  # For the email plugin\n  AC_CHECK_HEADERS([linux/un.h], [], [],\n    [[\n      #if HAVE_SYS_SOCKET_H\n      #  include <sys/socket.h>\n      #endif\n    ]]\n  )\n  # For the turbostat plugin\n  AC_CHECK_HEADERS([cpuid.h],\n    [have_cpuid_h=\"yes\"],\n    [have_cpuid_h=\"no (cpuid.h not found)\"]\n  )\n\n  AC_CHECK_HEADERS([sys/capability.h],\n    [have_capability=\"yes\"],\n    [have_capability=\"no (<sys/capability.h> not found)\"]\n  )\n\n  if test \"x$have_capability\" = \"xyes\"; then\n    AC_CHECK_LIB([cap], [cap_get_proc],\n      [have_capability=\"yes\"],\n      [have_capability=\"no (cap_get_proc() not found)\"]\n    )\n  fi\n\n  if test \"x$have_capability\" = \"xyes\"; then\n    AC_CHECK_DECL([CAP_IS_SUPPORTED],\n      [have_capability=\"yes\"],\n      [have_capability=\"no (CAP_IS_SUPPORTED not found)\"],\n      [[#include <sys/capability.h>]]\n    )\n  fi\n\n  if test \"x$have_capability\" = \"xyes\"; then\n    AC_DEFINE([HAVE_CAPABILITY], [1], [Define to 1 if you have cap_get_proc() (-lcap).])\n  fi\n\n  # For pcie_errors plugin\n  AC_CHECK_HEADERS([linux/pci_regs.h],\n    [have_pci_regs_h=\"yes\"],\n    [have_pci_regs_h=\"no (linux/pci_regs.h not found)\"]\n  )\n\nelse\n  have_linux_raid_md_u_h=\"no\"\n  have_linux_wireless_h=\"no\"\nfi\n\nAM_CONDITIONAL([BUILD_WITH_CAPABILITY], [test \"x$have_capability\" = \"xyes\"])\n\n# For the swap module\nhave_sys_swap_h=\"yes\"\nAC_CHECK_HEADERS([sys/swap.h vm/anon.h],\n  [],\n  [have_sys_swap_h=\"no\"],\n  [[\n    #undef _FILE_OFFSET_BITS\n    #undef _LARGEFILE64_SOURCE\n    #if HAVE_SYS_TYPES_H\n    #  include <sys/types.h>\n    #endif\n    #if HAVE_SYS_PARAM_H\n    # include <sys/param.h>\n    #endif\n  ]]\n)\n\n# For load module\n# For the processes plugin\n# For users module\nAC_CHECK_HEADERS([sys/loadavg.h linux/config.h utmp.h utmpx.h])\n\n# For quota module\nAC_CHECK_HEADERS([sys/ucred.h], [], [],\n  [[\n    #if HAVE_SYS_TYPES_H\n    #  include <sys/types.h>\n    #endif\n    #if HAVE_SYS_PARAM_H\n    # include <sys/param.h>\n    #endif\n  ]]\n)\n\n# For mount interface\nAC_CHECK_HEADERS([sys/mount.h], [], [],\n  [[\n    #if HAVE_SYS_TYPES_H\n    #  include <sys/types.h>\n    #endif\n    #if HAVE_SYS_PARAM_H\n    # include <sys/param.h>\n    #endif\n  ]]\n)\n\n# --enable-xfs {{{\nAC_ARG_ENABLE([xfs],\n  [AS_HELP_STRING([--enable-xfs], [xfs support in df plugin @<:@default=yes@:>@])],\n  [],\n  [enable_xfs=\"auto\"]\n)\n\nif test \"x$enable_xfs\" != \"xno\"; then\n  AC_CHECK_HEADERS([xfs/xqm.h],\n    [],\n    [\n      if test \"x$enable_xfs\" = \"xyes\"; then\n        AC_MSG_ERROR([xfs/xqm.h not found])\n      fi\n    ],\n    [[#define _GNU_SOURCE]]\n  )\nfi\n\n# }}}\n\nAC_CHECK_HEADERS([net/if_arp.h], [], [],\n  [[\n    #if HAVE_SYS_SOCKET_H\n    # include <sys/socket.h>\n    #endif\n  ]]\n)\n\nAC_CHECK_HEADERS([net/ppp_defs.h])\nAC_CHECK_HEADERS([net/if_ppp.h], [], [],\n  [[\n    #if HAVE_NET_PPP_DEFS_H\n    # include <net/ppp_defs.h>\n    #endif\n  ]]\n)\n\nAC_CHECK_HEADERS([netinet/if_ether.h], [], [],\n  [[\n    #include <stdint.h>\n    #if HAVE_SYS_TYPES_H\n    # include <sys/types.h>\n    #endif\n    #if HAVE_SYS_SOCKET_H\n    # include <sys/socket.h>\n    #endif\n    #if HAVE_NET_IF_H\n    # include <net/if.h>\n    #endif\n    #if HAVE_NETINET_IN_H\n    # include <netinet/in.h>\n    #endif\n  ]]\n)\n\nAC_CHECK_HEADERS([net/pfvar.h],\n  [have_net_pfvar_h=\"yes\"],\n  [have_net_pfvar_h=\"no\"],\n  [[\n    #if HAVE_SYS_IOCTL_H\n    # include <sys/ioctl.h>\n    #endif\n    #if HAVE_SYS_SOCKET_H\n    # include <sys/socket.h>\n    #endif\n    #if HAVE_NET_IF_H\n    # include <net/if.h>\n    #endif\n    #if HAVE_NETINET_IN_H\n    # include <netinet/in.h>\n    #endif\n  ]]\n)\n\n# For the multimeter plugin\nAC_CHECK_HEADERS([termios.h],\n  [have_termios_h=\"yes\"],\n  [have_termios_h=\"no\"]\n)\n\n# For cpusleep plugin\nAC_CACHE_CHECK([whether clock_boottime and clock_monotonic are supported],\n  [c_cv_have_clock_boottime_monotonic],\n  [\n    AC_COMPILE_IFELSE(\n      [AC_LANG_PROGRAM(\n        [[#include <time.h>]],\n        [[\n          struct timespec b, m;\n          clock_gettime(CLOCK_BOOTTIME, &b );\n          clock_gettime(CLOCK_MONOTONIC, &m );\n        ]]\n      )\n      ],\n      [c_cv_have_clock_boottime_monotonic=\"yes\"],\n      [c_cv_have_clock_boottime_monotonic=\"no\"]\n    )\n  ]\n)\n\n\n#\n# Checks for typedefs, structures, and compiler characteristics.\n#\nAC_C_CONST\nAC_TYPE_PID_T\nAC_TYPE_SIZE_T\nAC_TYPE_UID_T\nAC_HEADER_TIME\n\ntest_cxx_flags() {\n  AC_LANG_PUSH([C++])\n  AC_LANG_CONFTEST(\n    [AC_LANG_SOURCE([[int main(void){}]]) ]\n  )\n  $CXX -c conftest.cpp $CXXFLAGS $@ > /dev/null 2> /dev/null\n  ret=$?\n  rm -f conftest.o\n  AC_LANG_POP([C++])\n  return $ret\n}\n\n#\n# Checks for library functions.\n#\nAC_CHECK_FUNCS_ONCE([ \\\n    asprintf \\\n    getpwnam \\\n    getpwnam_r \\\n    if_indextoname \\\n    setenv \\\n    setgroups \\\n    setlocale\n  ]\n)\n\nAC_FUNC_STRERROR_R\n\nif test \"x$GCC\" = \"xyes\"; then\n  SAVE_CFLAGS=\"$CFLAGS\"\n  CFLAGS=\"$CFLAGS -Wall -Werror\"\nfi\nSAVE_LDFLAGS=\"$LDFLAGS\"\nLDFLAGS=\"\"\nif test \"x$ac_system\" = \"xWindows\"; then\n  # This is exported from build.sh\n  LDFLAGS=\"$LDFLAGS -L${GNULIB_DIR}\"\nfi\n\nAC_CACHE_CHECK([for strtok_r],\n  [c_cv_have_strtok_r_default],\n  [\n    AC_LINK_IFELSE(\n      [\n        AC_LANG_PROGRAM(\n          [[\n            #include <stdlib.h>\n            #include <stdio.h>\n            #include <string.h>\n          ]],\n          [[\n            char buffer[] = \"foo,bar,baz\";\n            char *token;\n            char *dummy;\n            char *saveptr;\n\n            dummy = buffer;\n            saveptr = NULL;\n            while ((token = strtok_r (dummy, \",\", &saveptr)) != NULL)\n            {\n              dummy = NULL;\n              printf (\"token = %s;\\n\", token);\n            }\n          ]]\n        )\n      ],\n      [c_cv_have_strtok_r_default=\"yes\"],\n      [c_cv_have_strtok_r_default=\"no\"]\n    )\n  ]\n)\n\nif test \"x$c_cv_have_strtok_r_default\" = \"xno\"; then\n  CFLAGS=\"$CFLAGS -D_REENTRANT=1\"\n\n  AC_CACHE_CHECK([if strtok_r needs _REENTRANT],\n    [c_cv_have_strtok_r_reentrant],\n    [\n      AC_LINK_IFELSE(\n        [\n          AC_LANG_PROGRAM(\n            [[\n              #include <stdlib.h>\n              #include <stdio.h>\n              #include <string.h>\n            ]],\n            [[\n              char buffer[] = \"foo,bar,baz\";\n              char *token;\n              char *dummy;\n              char *saveptr;\n\n              dummy = buffer;\n              saveptr = NULL;\n              while ((token = strtok_r (dummy, \",\", &saveptr)) != NULL)\n              {\n                dummy = NULL;\n                printf (\"token = %s;\\n\", token);\n              }\n            ]]\n          )\n        ],\n        [c_cv_have_strtok_r_reentrant=\"yes\"],\n        [AC_MSG_FAILURE([strtok_r is not available. Please file a bugreport!])]\n      )\n    ]\n  )\nfi\n\nCFLAGS=\"$SAVE_CFLAGS\"\nLDFLAGS=\"$SAVE_LDFLAGS\"\nif test \"x$c_cv_have_strtok_r_reentrant\" = \"xyes\"; then\n  CFLAGS=\"$CFLAGS -D_REENTRANT=1\"\nfi\n\nAC_CHECK_FUNCS([socket],\n  [],\n  [\n    AC_CHECK_LIB([socket], [socket],\n      [socket_needs_socket=\"yes\"],\n      [\n        AC_CHECK_LIB([gnu], [rpl_socket],\n          [socket_needs_gnulib=\"yes\"],\n          [AC_MSG_ERROR([cannot find socket() in libsocket])]\n        )\n      ]\n    )\n  ]\n)\nAM_CONDITIONAL([BUILD_WITH_LIBSOCKET], [test \"x$socket_needs_socket\" = \"xyes\"])\nAM_CONDITIONAL([BUILD_WITH_GNULIB], [test \"x$socket_needs_gnulib\" = \"xyes\"])\n\nAC_CHECK_FUNCS([inet_ntop],\n  [],\n  [\n    AC_CHECK_LIB([nsl], [inet_ntop],\n      [inet_ntop_needs_nsl=\"yes\"],\n      [AC_MSG_ERROR([cannot find inet_ntop() in libnsl])]\n    )\n  ]\n)\nAM_CONDITIONAL([BUILD_WITH_LIBNSL], [test \"x$inet_ntop_needs_nsl\" = \"xyes\"])\n\nclock_gettime_needs_posix4=\"no\"\nAC_CHECK_FUNCS([clock_gettime],\n  [have_clock_gettime=\"yes\"],\n  [have_clock_gettime=\"no\"]\n)\n\nif test \"x$have_clock_gettime\" = \"xno\"; then\n  AC_CHECK_LIB([rt], [clock_gettime],\n    [\n      clock_gettime_needs_rt=\"yes\"\n      have_clock_gettime=\"yes\"\n    ]\n  )\nfi\n\nif test \"x$have_clock_gettime\" = \"xno\"; then\n  AC_CHECK_LIB([posix4], [clock_gettime],\n    [\n      clock_gettime_needs_posix4=\"yes\"\n      have_clock_gettime=\"yes\"\n    ]\n  )\nfi\n\nif test \"x$have_clock_gettime\" = \"xyes\"; then\n  AC_DEFINE([HAVE_CLOCK_GETTIME], [1], [Define if the clock_gettime(2) function is available.])\nfi\n\nAC_CHECK_FUNCS([nanosleep], [],\n  AC_CHECK_LIB([rt], [nanosleep],\n    [nanosleep_needs_rt=\"yes\"],\n    [\n      AC_CHECK_LIB([posix4], [nanosleep],\n        [nanosleep_needs_posix4=\"yes\"],\n        [AC_MSG_ERROR([cannot find nanosleep])]\n      )\n    ]\n  )\n)\n\nAM_CONDITIONAL([BUILD_WITH_LIBRT], [test \"x$clock_gettime_needs_rt\" = \"xyes\" || test \"x$nanosleep_needs_rt\" = \"xyes\"])\nAM_CONDITIONAL([BUILD_WITH_LIBPOSIX4], [test \"x$clock_gettime_needs_posix4\" = \"xyes\" || test \"x$nanosleep_needs_posix4\" = \"xyes\"])\n\nAC_CHECK_FUNCS([getifaddrs], [have_getifaddrs=\"yes\"], [have_getifaddrs=\"no\"])\nAC_CHECK_FUNCS([getloadavg], [have_getloadavg=\"yes\"], [have_getloadavg=\"no\"])\nAC_CHECK_FUNCS([getutent], [have_getutent=\"yes\"], [have_getutent=\"no\"])\nAC_CHECK_FUNCS([getutxent], [have_getutxent=\"yes\"], [have_getutxent=\"no\"])\nAC_CHECK_FUNCS([host_statistics], [have_host_statistics=\"yes\"], [have_host_statistics=\"no\"])\nAC_CHECK_FUNCS([processor_info], [have_processor_info=\"yes\"], [have_processor_info=\"no\"])\nAC_CHECK_FUNCS([statfs], [have_statfs=\"yes\"], [have_statfs=\"no\"])\nAC_CHECK_FUNCS([statvfs], [have_statvfs=\"yes\"], [have_statvfs=\"no\"])\nAC_CHECK_FUNCS([sysctl], [have_sysctl=\"yes\"], [have_sysctl=\"no\"])\nAC_CHECK_FUNCS([sysctlbyname], [have_sysctlbyname=\"yes\"], [have_sysctlbyname=\"no\"])\nAC_CHECK_FUNCS([syslog], [have_syslog=\"yes\"], [have_syslog=\"no\"])\nAC_CHECK_FUNCS([thread_info], [have_thread_info=\"yes\"], [have_thread_info=\"no\"])\n\n# Check for strptime {{{\nif test \"x$GCC\" = \"xyes\"; then\n  SAVE_CFLAGS=\"$CFLAGS\"\n  CFLAGS=\"$CFLAGS -Wall -Wextra -Werror\"\nfi\n\nAC_CHECK_FUNCS([strptime], [have_strptime=\"yes\"], [have_strptime=\"no\"])\nif test \"x$have_strptime\" = \"xyes\"; then\n  AC_CACHE_CHECK([whether strptime is exported by default],\n    [c_cv_have_strptime_default],\n    [\n      AC_COMPILE_IFELSE(\n        [\n          AC_LANG_PROGRAM(\n            [[#include <time.h>]],\n            [[\n              struct tm stm;\n              (void)strptime (\"2010-12-30%13:42:42\", \"%Y-%m-%dT%T\", &stm);\n            ]]\n          )\n        ],\n        [c_cv_have_strptime_default=\"yes\"],\n        [c_cv_have_strptime_default=\"no\"])\n    ]\n  )\nfi\n\nif test \"x$have_strptime\" = \"xyes\" && test \"x$c_cv_have_strptime_default\" = \"xno\"; then\n  AC_CACHE_CHECK([whether strptime needs standards mode],\n    [c_cv_have_strptime_standards],\n    [\n      AC_COMPILE_IFELSE(\n        [\n          AC_LANG_PROGRAM(\n            [[\n              #ifndef _ISOC99_SOURCE\n              # define _ISOC99_SOURCE 1\n              #endif\n              #ifndef _POSIX_C_SOURCE\n              # define _POSIX_C_SOURCE 200112L\n              #endif\n              #ifndef _XOPEN_SOURCE\n              # define _XOPEN_SOURCE 500\n              #endif\n              #include <time.h>\n            ]],\n            [[\n              struct tm stm;\n              (void)strptime (\"2010-12-30%13:42:42\", \"%Y-%m-%dT%T\", &stm);\n            ]]\n          )\n        ],\n        [c_cv_have_strptime_standards=\"yes\"],\n        [c_cv_have_strptime_standards=\"no\"]\n      )\n    ]\n  )\n\n  if test \"x$c_cv_have_strptime_standards\" = \"xyes\"; then\n    AC_DEFINE([STRPTIME_NEEDS_STANDARDS], [1],\n      [Set to true if strptime is only exported in X/Open mode (GNU libc).]\n    )\n  else\n    have_strptime=\"no\"\n  fi\nfi\n\nif test \"x$GCC\" = \"xyes\"; then\n  CFLAGS=\"$SAVE_CFLAGS\"\nfi\n# }}} Check for strptime\n\n# Check for timegm {{{\n\n# These checks need -Werror because implicit function declarations are only a\n# warning ...\nSAVE_CFLAGS=\"$CFLAGS\"\nCFLAGS=\"$CFLAGS -Werror\"\n\nAC_CACHE_CHECK([for timegm],\n  [c_cv_have_timegm],\n  AC_LINK_IFELSE(\n    [AC_LANG_PROGRAM(\n[[[\n#if STRPTIME_NEEDS_STANDARDS\n# ifndef _ISOC99_SOURCE\n#  define _ISOC99_SOURCE 1\n# endif\n# ifndef _POSIX_C_SOURCE\n#  define _POSIX_C_SOURCE 200112L\n# endif\n# ifndef _XOPEN_SOURCE\n#  define _XOPEN_SOURCE 500\n# endif\n#endif\n#include <time.h>\n]]],\n[[[\n time_t t = timegm(&(struct tm){0});\n if (t == ((time_t) -1)) {\n   return 1;\n }\n]]]\n    )],\n    [c_cv_have_timegm=\"yes\"],\n    [c_cv_have_timegm=\"no\"]\n  )\n)\n\nif test \"x$c_cv_have_timegm\" != \"xyes\"\nthen\n  AC_CACHE_CHECK([for timegm with _BSD_SOURCE],\n    [c_cv_have_timegm_bsd],\n    AC_LINK_IFELSE(\n      [AC_LANG_PROGRAM(\n[[[\n#if STRPTIME_NEEDS_STANDARDS\n# ifndef _ISOC99_SOURCE\n#  define _ISOC99_SOURCE 1\n# endif\n# ifndef _POSIX_C_SOURCE\n#  define _POSIX_C_SOURCE 200112L\n# endif\n# ifndef _XOPEN_SOURCE\n#  define _XOPEN_SOURCE 500\n# endif\n#endif\n#ifndef _BSD_SOURCE\n# define _BSD_SOURCE 1\n#endif\n#include <time.h>\n]]],\n[[[\n time_t t = timegm(&(struct tm){0});\n if (t == ((time_t) -1)) {\n   return 1;\n }\n]]]\n      )],\n      [c_cv_have_timegm_bsd=\"yes\"\n       c_cv_have_timegm=\"yes\"],\n      [c_cv_have_timegm_bsd=\"no\"]\n    )\n  )\nfi\n\nif test \"x$c_cv_have_timegm\" = \"xyes\"\nthen\n  AC_DEFINE(HAVE_TIMEGM, 1, [Define if the timegm(3) function is available.])\n  if test \"x$c_cv_have_timegm_bsd\" = \"xyes\"\n  then\n    AC_DEFINE(TIMEGM_NEEDS_BSD, 1, [Set to true if timegm is only exported in BSD mode.])\n  fi\nfi\n\nCFLAGS=\"$SAVE_CFLAGS\"\n# }}} Check for timegm\n\nAC_MSG_CHECKING([for sysctl kern.cp_times])\nif test -x /sbin/sysctl; then\n  /sbin/sysctl kern.cp_times >/dev/null 2>&1\n  if test $? -eq 0; then\n    AC_MSG_RESULT([yes])\n    AC_DEFINE([HAVE_SYSCTL_KERN_CP_TIMES], [1], [Define if sysctl supports kern.cp_times])\n  else\n    AC_MSG_RESULT([no])\n  fi\nelse\n  AC_MSG_RESULT([no])\nfi\n\nAC_MSG_CHECKING([for sysctl kern.cp_time])\nif test -x /sbin/sysctl; then\n  /sbin/sysctl kern.cp_time >/dev/null 2>&1\n  if test $? -eq 0\n  then\n    AC_MSG_RESULT([yes])\n    AC_DEFINE([HAVE_SYSCTL_KERN_CP_TIME], [1], [Define if sysctl supports kern.cp_time])\n  else\n    AC_MSG_RESULT([no])\n  fi\nelse\n  AC_MSG_RESULT([no])\nfi\n\nAC_CHECK_FUNCS([swapctl], [have_swapctl=\"yes\"], [have_swapctl=\"no\"])\nif test \"x$have_swapctl\" = \"xyes\"; then\n  AC_CACHE_CHECK([whether swapctl takes two arguments],\n    [c_cv_have_swapctl_two_args],\n    [\n      AC_COMPILE_IFELSE(\n        [\n          AC_LANG_PROGRAM(\n            [[\n              #if HAVE_SYS_SWAP_H && !defined(_LP64) && _FILE_OFFSET_BITS == 64\n              #  undef _FILE_OFFSET_BITS\n              #  undef _LARGEFILE64_SOURCE\n              #endif\n              #include <sys/stat.h>\n              #include <sys/param.h>\n              #include <sys/swap.h>\n              #include <unistd.h>\n            ]],\n            [[int num = swapctl(0, NULL);]]\n          )\n        ],\n        [c_cv_have_swapctl_two_args=\"yes\"],\n        [c_cv_have_swapctl_two_args=\"no\"]\n      )\n    ]\n  )\n\n  AC_CACHE_CHECK([whether swapctl takes three arguments],\n    [c_cv_have_swapctl_three_args],\n    [\n      AC_COMPILE_IFELSE(\n        [\n          AC_LANG_PROGRAM(\n            [[\n              #if HAVE_SYS_SWAP_H && !defined(_LP64) && _FILE_OFFSET_BITS == 64\n              #  undef _FILE_OFFSET_BITS\n              #  undef _LARGEFILE64_SOURCE\n              #endif\n              #include <sys/stat.h>\n              #include <sys/param.h>\n              #include <sys/swap.h>\n              #include <unistd.h>\n            ]],\n            [[int num = swapctl(0, NULL, 0);]]\n          )\n        ],\n        [c_cv_have_swapctl_three_args=\"yes\"],\n        [c_cv_have_swapctl_three_args=\"no\"]\n      )\n    ]\n  )\nfi\n\n# Check for different versions of `swapctl' here..\nif test \"x$have_swapctl\" = \"xyes\"; then\n  if test \"x$c_cv_have_swapctl_two_args\" = \"xyes\"; then\n    AC_DEFINE([HAVE_SWAPCTL_TWO_ARGS], [1], [Define if the function swapctl exists and takes two arguments.])\n  fi\n\n  if test \"x$c_cv_have_swapctl_three_args\" = \"xyes\"; then\n    AC_DEFINE([HAVE_SWAPCTL_THREE_ARGS], [1], [Define if the function swapctl exists and takes three arguments.])\n  fi\nfi\n\n# Check for NAN\nAC_ARG_WITH([nan-emulation],\n  [AS_HELP_STRING([--with-nan-emulation], [use emulated NAN. For crosscompiling only.])],\n  [\n    if test \"x$withval\" = \"xno\"; then\n      nan_type=\"none\"\n    else if test \"x$withval\" = \"xyes\"; then\n      nan_type=\"zero\"\n    else\n      nan_type=\"$withval\"\n    fi; fi\n  ],\n  [nan_type=\"none\"]\n)\n\nif test \"x$nan_type\" = \"xnone\"; then\n  AC_CACHE_CHECK([whether NAN is defined by default],\n    [c_cv_have_nan_default],\n    [\n      AC_COMPILE_IFELSE(\n        [\n          AC_LANG_PROGRAM(\n            [[\n              #include <stdlib.h>\n              #include <math.h>\n              static double foo = NAN;\n            ]],\n            [[\n              if (isnan (foo))\n                return 0;\n              return 1;\n            ]]\n          )\n        ],\n        [c_cv_have_nan_default=\"yes\"],\n        [c_cv_have_nan_default=\"no\"]\n      )\n    ]\n  )\nfi\n\nif test \"x$c_cv_have_nan_default\" = \"xyes\"; then\n  nan_type=\"default\"\nfi\n\nif test \"x$nan_type\" = \"xnone\"; then\n  AC_CACHE_CHECK([whether NAN is defined by __USE_ISOC99],\n    [c_cv_have_nan_isoc],\n    [\n      AC_COMPILE_IFELSE(\n        [\n          AC_LANG_PROGRAM(\n            [[\n              #include <stdlib.h>\n              #define __USE_ISOC99 1\n              #include <math.h>\n              static double foo = NAN;\n            ]],\n            [[\n              if (isnan (foo))\n                return 0;\n              return 1;\n            ]]\n          )\n        ],\n        [c_cv_have_nan_isoc=\"yes\"],\n        [c_cv_have_nan_isoc=\"no\"]\n      )\n    ]\n  )\nfi\n\nif test \"x$c_cv_have_nan_isoc\" = \"xyes\"; then\n  nan_type=\"isoc99\"\nfi\n\nif test \"x$nan_type\" = \"xnone\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS -lm\"\n  AC_CACHE_CHECK([whether NAN can be defined by 0/0],\n    [c_cv_have_nan_zero],\n    [\n      AC_RUN_IFELSE(\n        [\n          AC_LANG_PROGRAM(\n            [[\n              #include <stdlib.h>\n              #include <math.h>\n              #ifdef NAN\n              # undef NAN\n              #endif\n              #define NAN (0.0 / 0.0)\n              #ifndef isnan\n              # define isnan(f) ((f) != (f))\n              #endif\n              static double foo = NAN;\n            ]],\n            [[\n              if (isnan (foo))\n                return 0;\n              return 1;\n            ]]\n          )\n        ],\n        [c_cv_have_nan_zero=\"yes\"],\n        [c_cv_have_nan_zero=\"no\"]\n      )\n    ]\n  )\n  LDFLAGS=$SAVE_LDFLAGS\nfi\n\nif test \"x$c_cv_have_nan_zero\" = \"xyes\"; then\n  nan_type=\"zero\"\nfi\n\nif test \"x$nan_type\" = \"xdefault\"; then\n  AC_DEFINE([NAN_STATIC_DEFAULT], [1],\n    [Define if NAN is defined by default and can initialize static variables.]\n  )\nelse if test \"x$nan_type\" = \"xisoc99\"; then\n  AC_DEFINE([NAN_STATIC_ISOC], [1],\n    [Define if NAN is defined by __USE_ISOC99 and can initialize static variables.]\n  )\nelse if test \"x$nan_type\" = \"xzero\"; then\n  AC_DEFINE([NAN_ZERO_ZERO], [1],\n    [Define if NAN can be defined as (0.0 / 0.0)]\n  )\nelse\n  AC_MSG_ERROR([Didn't find out how to statically initialize variables to NAN. Sorry.])\nfi; fi; fi\n\nAC_ARG_WITH([fp-layout],\n  [\n    AS_HELP_STRING([--with-fp-layout],\n      [set the memory layout of doubles. For crosscompiling only.]\n    )\n  ],\n  [\n    if test \"x$withval\" = \"xnothing\"; then\n      fp_layout_type=\"nothing\"\n    else if test \"x$withval\" = \"xendianflip\"; then\n      fp_layout_type=\"endianflip\"\n    else if test \"x$withval\" = \"xintswap\"; then\n      fp_layout_type=\"intswap\"\n    else\n      AC_MSG_ERROR([Invalid argument for --with-fp-layout. Valid arguments are: nothing, endianflip, intswap]);\n    fi; fi; fi\n  ],\n  [fp_layout_type=\"unknown\"]\n)\n\nif test \"x$fp_layout_type\" = \"xunknown\"; then\n  AC_CACHE_CHECK([if doubles are stored in x86 representation],\n    [c_cv_fp_layout_need_nothing],\n    [\n      AC_RUN_IFELSE(\n        [\n          AC_LANG_PROGRAM(\n            [[\n              #include <stdlib.h>\n              #include <stdio.h>\n              #include <string.h>\n              #include <stdint.h>\n              #include <inttypes.h>\n              #include <stdbool.h>\n            ]],\n            [[\n              uint64_t i0;\n              uint64_t i1;\n              uint8_t c[8];\n              double d;\n\n              d = 8.642135e130;\n              memcpy ((void *) &i0, (void *) &d, 8);\n\n              i1 = i0;\n              memcpy ((void *) c, (void *) &i1, 8);\n\n              if ((c[0] == 0x2f) && (c[1] == 0x25)\n                  && (c[2] == 0xc0) && (c[3] == 0xc7)\n                  && (c[4] == 0x43) && (c[5] == 0x2b)\n                  && (c[6] == 0x1f) && (c[7] == 0x5b))\n                return 0;\n              return 1;\n            ]]\n          )\n        ],\n        [c_cv_fp_layout_need_nothing=\"yes\"],\n        [c_cv_fp_layout_need_nothing=\"no\"]\n      )\n    ]\n  )\nfi\n\nif test \"x$c_cv_fp_layout_need_nothing\" = \"xyes\"; then\n  fp_layout_type=\"nothing\"\nfi\n\nif test \"x$fp_layout_type\" = \"xunknown\"; then\n  AC_CACHE_CHECK([if endianflip converts to x86 representation],\n    [c_cv_fp_layout_need_endianflip],\n    [\n      AC_RUN_IFELSE(\n        [\n          AC_LANG_PROGRAM(\n            [[\n              #include <stdlib.h>\n              #include <stdio.h>\n              #include <string.h>\n              #include <stdint.h>\n              #include <inttypes.h>\n              #include <stdbool.h>\n              #define endianflip(A) ((((uint64_t)(A) & 0xff00000000000000LL) >> 56) | \\\n                                     (((uint64_t)(A) & 0x00ff000000000000LL) >> 40) | \\\n                                     (((uint64_t)(A) & 0x0000ff0000000000LL) >> 24) | \\\n                                     (((uint64_t)(A) & 0x000000ff00000000LL) >> 8)  | \\\n                                     (((uint64_t)(A) & 0x00000000ff000000LL) << 8)  | \\\n                                     (((uint64_t)(A) & 0x0000000000ff0000LL) << 24) | \\\n                                     (((uint64_t)(A) & 0x000000000000ff00LL) << 40) | \\\n                                     (((uint64_t)(A) & 0x00000000000000ffLL) << 56))\n            ]],\n            [[\n              uint64_t i0;\n              uint64_t i1;\n              uint8_t c[8];\n              double d;\n\n              d = 8.642135e130;\n              memcpy ((void *) &i0, (void *) &d, 8);\n\n              i1 = endianflip (i0);\n              memcpy ((void *) c, (void *) &i1, 8);\n\n              if ((c[0] == 0x2f) && (c[1] == 0x25)\n                  && (c[2] == 0xc0) && (c[3] == 0xc7)\n                  && (c[4] == 0x43) && (c[5] == 0x2b)\n                  && (c[6] == 0x1f) && (c[7] == 0x5b))\n                return 0;\n              return 1;\n            ]]\n          )\n        ],\n        [c_cv_fp_layout_need_endianflip=\"yes\"],\n        [c_cv_fp_layout_need_endianflip=\"no\"]\n      ]\n    )\n  )\nfi\n\nif test \"x$c_cv_fp_layout_need_endianflip\" = \"xyes\"; then\n  fp_layout_type=\"endianflip\"\nfi\n\nif test \"x$fp_layout_type\" = \"xunknown\"; then\n  AC_CACHE_CHECK([if intswap converts to x86 representation],\n    [c_cv_fp_layout_need_intswap],\n    [\n      AC_RUN_IFELSE(\n        [\n          AC_LANG_PROGRAM(\n            [[\n              #include <stdlib.h>\n              #include <stdio.h>\n              #include <string.h>\n              #include <stdint.h>\n              #include <inttypes.h>\n              #include <stdbool.h>\n              #define intswap(A)    ((((uint64_t)(A) & 0xffffffff00000000LL) >> 32) | \\\n                                     (((uint64_t)(A) & 0x00000000ffffffffLL) << 32))\n            ]],\n            [[\n              uint64_t i0;\n              uint64_t i1;\n              uint8_t c[8];\n              double d;\n\n              d = 8.642135e130;\n              memcpy ((void *) &i0, (void *) &d, 8);\n\n              i1 = intswap (i0);\n              memcpy ((void *) c, (void *) &i1, 8);\n\n              if ((c[0] == 0x2f) && (c[1] == 0x25)\n                  && (c[2] == 0xc0) && (c[3] == 0xc7)\n                  && (c[4] == 0x43) && (c[5] == 0x2b)\n                  && (c[6] == 0x1f) && (c[7] == 0x5b))\n                return 0;\n              return 1;\n            ]]\n          )\n        ],\n        [c_cv_fp_layout_need_intswap=\"yes\"],\n        [c_cv_fp_layout_need_intswap=\"no\"]\n      )\n    ]\n  )\nfi\n\nif test \"x$c_cv_fp_layout_need_intswap\" = \"xyes\"; then\n  fp_layout_type=\"intswap\"\nfi\n\nif test \"x$fp_layout_type\" = \"xnothing\"; then\n  AC_DEFINE([FP_LAYOUT_NEED_NOTHING], [1],\n    [Define if doubles are stored in x86 representation.]\n  )\nelse if test \"x$fp_layout_type\" = \"xendianflip\"; then\n  AC_DEFINE([FP_LAYOUT_NEED_ENDIANFLIP], [1],\n    [Define if endianflip is needed to convert to x86 representation.]\n  )\nelse if test \"x$fp_layout_type\" = \"xintswap\"; then\n  AC_DEFINE([FP_LAYOUT_NEED_INTSWAP], [1],\n    [Define if intswap is needed to convert to x86 representation.]\n  )\nelse\n  AC_MSG_ERROR([Didn't find out how doubles are stored in memory. Sorry.])\nfi; fi; fi\n\n# For cpusleep plugin\nAC_CACHE_CHECK([whether clock_boottime and clock_monotonic are supported],\n  [c_cv_have_clock_boottime_monotonic],\n  [\n    AC_COMPILE_IFELSE(\n      [AC_LANG_PROGRAM(\n        [[#include <time.h>]],\n        [[\n          struct timespec b, m;\n          clock_gettime(CLOCK_BOOTTIME, &b );\n          clock_gettime(CLOCK_MONOTONIC, &m );\n        ]]\n      )\n      ],\n      [c_cv_have_clock_boottime_monotonic=\"yes\"],\n      [c_cv_have_clock_boottime_monotonic=\"no\"]\n    )\n  ]\n)\n\n# --with-useragent {{{\nAC_ARG_WITH([useragent],\n  [AS_HELP_STRING([--with-useragent@<:@=AGENT@:>@], [User agent to use on http requests])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      AC_DEFINE_UNQUOTED([COLLECTD_USERAGENT], [\"$withval\"], [User agent for http requests])\n    fi\n  ]\n)\n\n# }}}\n\n# --with-data-max-name-len {{{\nAC_ARG_WITH([data-max-name-len],\n  [AS_HELP_STRING([--with-data-max-name-len@<:@=VALUE@:>@], [Maximum length of data buffers])],\n  [\n    if test \"x$withval\" != \"x\" && test $withval -gt 0; then\n      AC_DEFINE_UNQUOTED([DATA_MAX_NAME_LEN], [$withval], [Maximum length of data buffers])\n    else\n      AC_MSG_ERROR([DATA_MAX_NAME_LEN must be a positive integer -- $withval given])\n    fi\n  ],\n  [AC_DEFINE([DATA_MAX_NAME_LEN], [128], [Maximum length of data buffers])]\n)\n# }}}\n\nAC_CHECK_FUNCS([getfsstat], [have_getfsstat=\"yes\"], [have_getfsstat=\"no\"])\nAC_CHECK_FUNCS(getvfsstat, [have_getvfsstat=\"yes\"], [have_getvfsstat=\"no\"])\nAC_CHECK_FUNCS(listmntent, [have_listmntent=\"yes\"], [have_listmntent=\"no\"])\nAC_CHECK_FUNCS(getmntent_r, [have_getmntent_r=\"yes\"], [have_getmntent_r=\"no\"])\n\nAC_CHECK_FUNCS(getmntent, [have_getmntent=\"libc\"], [have_getmntent=\"no\"])\nif test \"x$have_getmntent\" = \"xno\"; then\n  AC_CHECK_LIB([sun], [getmntent],\n    [have_getmntent=\"sun\"],\n    [have_gemntent=\"no\"]\n  )\nfi\n\nif test \"x$have_getmntent\" = \"xno\"; then\n  AC_CHECK_LIB([seq], [getmntent],\n    [have_getmntent=\"seq\"],\n    [have_getmntent=\"no\"]\n  )\nfi\n\nif test \"x$have_getmntent\" = \"xno\"; then\n  AC_CHECK_LIB([gen], [getmntent],\n    [have_getmntent=\"gen\"],\n    [have_getmntent=\"no\"]\n  )\nfi\n\nif test \"x$have_getmntent\" = \"xlibc\"; then\n  AC_CACHE_CHECK([whether getmntent takes one argument],\n    [c_cv_have_one_getmntent],\n    [\n      AC_COMPILE_IFELSE(\n        [\n          AC_LANG_PROGRAM(\n            [[#include \"$srcdir/src/utils/mount/mount.h\"]],\n            [[\n              FILE *fh;\n              struct mntent *me;\n              fh = setmntent (\"/etc/mtab\", \"r\");\n              me = getmntent (fh);\n              return me->mnt_passno;\n            ]]\n          )\n        ],\n        [c_cv_have_one_getmntent=\"yes\"],\n        [c_cv_have_one_getmntent=\"no\"]\n      )\n    ]\n  )\n\n  AC_CACHE_CHECK([whether getmntent takes two arguments],\n    [c_cv_have_two_getmntent],\n    [\n      AC_COMPILE_IFELSE(\n        [\n          AC_LANG_PROGRAM(\n            [[#include \"$srcdir/src/utils/mount/mount.h\"]],\n            [[\n              FILE *fh;\n              struct mnttab mt;\n              int status;\n              fh = fopen (\"/etc/mnttab\", \"r\");\n              status = getmntent (fh, &mt);\n              return status;\n            ]]\n          )\n        ],\n        [c_cv_have_two_getmntent=\"yes\"],\n        [c_cv_have_two_getmntent=\"no\"]\n      )\n    ]\n  )\nfi\n\n# Check for different versions of `getmntent' here..\n\nif test \"x$have_getmntent\" = \"xlibc\"; then\n  if test \"x$c_cv_have_one_getmntent\" = \"xyes\"; then\n    AC_DEFINE([HAVE_ONE_GETMNTENT], [1],\n      [Define if the function getmntent exists and takes one argument.]\n    )\n  fi\n\n  if test \"x$c_cv_have_two_getmntent\" = \"xyes\"; then\n    AC_DEFINE([HAVE_TWO_GETMNTENT], [1],\n      [Define if the function getmntent exists and takes two arguments.]\n    )\n  fi\nfi\n\nif test \"x$have_getmntent\" = \"xsun\"; then\n  AC_DEFINE([HAVE_SUN_GETMNTENT], [1],\n    [Define if the function getmntent exists. It is the version from libsun.]\n  )\nfi\n\nif test \"x$have_getmntent\" = \"xgen\"; then\n  AC_DEFINE([HAVE_GEN_GETMNTENT], [1],\n    [Define if the function getmntent exists. It is the version from libgen.]\n  )\nfi\n\n# Check for htonll\nAC_CACHE_CHECK([whether htonll is defined],\n  [c_cv_have_htonll],\n  [\n    AC_LINK_IFELSE(\n      [\n        AC_LANG_PROGRAM(\n          [[\n            #include <inttypes.h>\n            #include <sys/types.h>\n            #include <netinet/in.h>\n          ]],\n          [[return htonll(0);]]\n        )\n      ],\n      [c_cv_have_htonll=\"yes\"],\n      [c_cv_have_htonll=\"no\"]\n    )\n  ]\n)\n\nif test \"x$c_cv_have_htonll\" = \"xyes\"; then\n  AC_DEFINE([HAVE_HTONLL], [1], [Define if the function htonll exists.])\nfi\n\n# Check for structures\nAC_CHECK_MEMBERS([struct if_data.ifi_ibytes, struct if_data.ifi_opackets, struct if_data.ifi_ierrors],\n  [AC_DEFINE([HAVE_STRUCT_IF_DATA], [1], [Define if struct if_data exists and is usable.])],\n  [],\n  [[\n    #include <sys/types.h>\n    #include <sys/socket.h>\n    #include <net/if.h>\n  ]]\n)\n\nAC_CHECK_MEMBERS([struct net_device_stats.rx_bytes, struct net_device_stats.tx_packets, struct net_device_stats.rx_errors],\n  [AC_DEFINE([HAVE_STRUCT_NET_DEVICE_STATS], [1], [Define if struct net_device_stats exists and is usable.])],\n  [],\n  [[\n    #include <sys/types.h>\n    #include <sys/socket.h>\n    #include <linux/if.h>\n    #include <linux/netdevice.h>\n  ]]\n)\n\nAC_CHECK_MEMBERS([struct inet_diag_req.id, struct inet_diag_req.idiag_states],\n  [AC_DEFINE([HAVE_STRUCT_LINUX_INET_DIAG_REQ], [1], [Define if struct inet_diag_req exists and is usable.])],\n  [],\n  [[#include <linux/inet_diag.h>]]\n)\n\nAC_CHECK_MEMBERS([struct ip_mreqn.imr_ifindex], [],\n  [],\n  [[\n    #include <netinet/in.h>\n    #include <net/if.h>\n  ]]\n)\n\nAC_CHECK_MEMBERS([struct kinfo_proc.ki_pid, struct kinfo_proc.ki_rssize, struct kinfo_proc.ki_rusage],\n  [\n    AC_DEFINE([HAVE_STRUCT_KINFO_PROC_FREEBSD], [1], [Define if struct kinfo_proc exists in the FreeBSD variant.])\n    have_struct_kinfo_proc_freebsd=\"yes\"\n  ],\n  [],\n  [[\n    #include <kvm.h>\n    #include <sys/param.h>\n    #include <sys/sysctl.h>\n    #include <sys/user.h>\n  ]]\n)\n\nAC_CHECK_MEMBERS([struct kinfo_proc.p_pid, struct kinfo_proc.p_vm_rssize],\n  [\n    AC_DEFINE([HAVE_STRUCT_KINFO_PROC_OPENBSD], [1], [Define if struct kinfo_proc exists in the OpenBSD variant.])\n    have_struct_kinfo_proc_openbsd=\"yes\"\n  ],\n  [],\n  [[\n    #include <sys/param.h>\n    #include <sys/sysctl.h>\n    #include <kvm.h>\n  ]]\n)\n\nAC_CHECK_MEMBERS([struct kinfo_proc2.p_pid, struct kinfo_proc2.p_uru_maxrss],\n  [\n    AC_DEFINE([HAVE_STRUCT_KINFO_PROC2_NETBSD], [1], [Define if struct kinfo_proc2 exists in the NetBSD variant.])\n    have_struct_kinfo_proc2_netbsd=\"yes\"\n  ],\n  [],\n  [[\n    #include <sys/param.h>\n    #include <sys/sysctl.h>\n    #include <kvm.h>\n  ]]\n)\n\nAC_CHECK_MEMBERS([struct udphdr.uh_dport, struct udphdr.uh_sport],\n  [],\n  [],\n  [[\n    #define _BSD_SOURCE\n    #define _DEFAULT_SOURCE\n    #include <stdint.h>\n    #if HAVE_SYS_TYPES_H\n    # include <sys/types.h>\n    #endif\n    #if HAVE_NETINET_IN_SYSTM_H\n    # include <netinet/in_systm.h>\n    #endif\n    #if HAVE_NETINET_IN_H\n    # include <netinet/in.h>\n    #endif\n    #if HAVE_NETINET_IP_H\n    # include <netinet/ip.h>\n    #endif\n    #if HAVE_NETINET_UDP_H\n    # include <netinet/udp.h>\n    #endif\n  ]]\n)\n\nAC_CHECK_MEMBERS([struct udphdr.dest, struct udphdr.source],\n  [],\n  [],\n  [[\n    #define _BSD_SOURCE\n    #define _DEFAULT_SOURCE\n    #include <stdint.h>\n    #if HAVE_SYS_TYPES_H\n    # include <sys/types.h>\n    #endif\n    #if HAVE_NETINET_IN_SYSTM_H\n    # include <netinet/in_systm.h>\n    #endif\n    #if HAVE_NETINET_IN_H\n    # include <netinet/in.h>\n    #endif\n    #if HAVE_NETINET_IP_H\n    # include <netinet/ip.h>\n    #endif\n    #if HAVE_NETINET_UDP_H\n    # include <netinet/udp.h>\n    #endif\n  ]]\n)\n\nAC_CHECK_MEMBERS([kstat_io_t.nwritten, kstat_io_t.writes, kstat_io_t.nwrites, kstat_io_t.wtime],\n  [],\n  [],\n  [[# include <kstat.h>]]\n)\n\n# check for pthread_setname_np\nSAVE_LDFLAGS=\"$LDFLAGS\"\nLDFLAGS=\"$LDFLAGS -lpthread\"\n\nAC_MSG_CHECKING([for pthread_setname_np])\nhave_pthread_setname_np=\"no\"\nAC_LINK_IFELSE(\n  [\n    AC_LANG_PROGRAM(\n      [[\n        #define _GNU_SOURCE\n        #include <pthread.h>\n      ]],\n      [[pthread_setname_np((pthread_t) {0}, \"conftest\");]]\n    )\n  ],\n  [\n    have_pthread_setname_np=\"yes\"\n    AC_DEFINE(HAVE_PTHREAD_SETNAME_NP, 1, [pthread_setname_np() is available.])\n  ]\n)\n\nAC_MSG_RESULT([$have_pthread_setname_np])\n\n# check for pthread_set_name_np(3) (FreeBSD)\nAC_MSG_CHECKING([for pthread_set_name_np])\nhave_pthread_set_name_np=\"no\"\nAC_LINK_IFELSE(\n  [\n    AC_LANG_PROGRAM(\n      [[#include <pthread_np.h>]],\n      [[pthread_set_name_np((pthread_t) {0}, \"conftest\");]]\n    )\n   ],\n  [\n    have_pthread_set_name_np=\"yes\"\n    AC_DEFINE(HAVE_PTHREAD_SET_NAME_NP, 1, [pthread_set_name_np() is available.])\n  ]\n)\nAC_MSG_RESULT([$have_pthread_set_name_np])\n\nLDFLAGS=\"$SAVE_LDFLAGS\"\n\nAC_CHECK_TYPES([struct ip6_ext],\n  [have_ip6_ext=\"yes\"],\n  [have_ip6_ext=\"no\"],\n  [[\n    #include <stdint.h>\n    #if HAVE_SYS_TYPES_H\n    # include <sys/types.h>\n    #endif\n    #if HAVE_NETINET_IN_SYSTM_H\n    # include <netinet/in_systm.h>\n    #endif\n    #if HAVE_NETINET_IN_H\n    # include <netinet/in.h>\n    #endif\n    #if HAVE_NETINET_IP6_H\n    # include <netinet/ip6.h>\n    #endif\n  ]]\n)\n\nif test \"x$have_ip6_ext\" = \"xno\"; then\n  SAVE_CFLAGS=\"$CFLAGS\"\n  CFLAGS=\"$CFLAGS -DSOLARIS2=8\"\n  AC_CHECK_TYPES([struct ip6_ext],\n    [have_ip6_ext=\"yes, with -DSOLARIS2=8\"],\n    [have_ip6_ext=\"no\"],\n    [[\n      #include <stdint.h>\n      #if HAVE_SYS_TYPES_H\n      # include <sys/types.h>\n      #endif\n      #if HAVE_NETINET_IN_SYSTM_H\n      # include <netinet/in_systm.h>\n      #endif\n      #if HAVE_NETINET_IN_H\n      # include <netinet/in.h>\n      #endif\n      #if HAVE_NETINET_IP6_H\n      # include <netinet/ip6.h>\n      #endif\n    ]]\n  )\n  if test \"x$have_ip6_ext\" = \"xno\"; then\n    CFLAGS=\"$SAVE_CFLAGS\"\n  fi\nfi\n\n# libi2c-dev\nif test \"x$ac_system\" = \"xLinux\"; then\n  with_libi2c_libs=\"\"\n  AC_CHECK_HEADERS([i2c/smbus.h],\n    [with_libi2c_libs=\"-li2c\"]\n  )\n  AC_CHECK_DECL([i2c_smbus_read_i2c_block_data],\n    [with_libi2c=\"yes\"],\n    [with_libi2c=\"no (symbol i2c_smbus_read_i2c_block_data not found - have you installed libi2c-dev ?)\"],\n    [[\n      #include <stdlib.h>\n      #include <linux/i2c-dev.h>\n      #if HAVE_I2C_SMBUS_H\n      # include <i2c/smbus.h>\n      #endif\n    ]]\n  )\n  BUILD_WITH_LIBI2C_LIBS=\"$with_libi2c_libs\"\n  AC_SUBST([BUILD_WITH_LIBI2C_LIBS])\nelse\n  with_libi2c=\"no (Linux only)\"\nfi\n\n#\n# Checks for libraries begin here\n#\n\n# Check for libpthread\nSAVE_LIBS=\"$LIBS\"\nAC_CHECK_LIB([pthread],\n  [pthread_create],\n  [],\n  [AC_MSG_ERROR([Symbol 'pthread_create' not found in libpthread])],\n  []\n)\nPTHREAD_LIBS=\"$LIBS\"\nLIBS=\"$SAVE_LIBS\"\nAC_SUBST([PTHREAD_LIBS])\n\nAC_CHECK_HEADERS([pthread.h],\n  [],\n  [AC_MSG_ERROR([pthread.h not found])]\n)\n\nm4_divert_once([HELP_WITH], [\nCollectd additional packages:])\n\nif test \"x$ac_system\" = \"xAIX\"; then\n  with_perfstat=\"yes\"\n  with_procinfo=\"yes\"\nelse\n  with_perfstat=\"no (AIX only)\"\n  with_procinfo=\"no (AIX only)\"\nfi\n\nif test \"x$with_perfstat\" = \"xyes\"; then\n  AC_CHECK_LIB([perfstat], [perfstat_reset],\n    [with_perfstat=\"yes\"],\n    [with_perfstat=\"no (perfstat not found)\"]\n  )\nfi\n\nif test \"x$with_perfstat\" = \"xyes\"; then\n  AC_DEFINE([HAVE_PERFSTAT], [1], [Define to 1 if you have the 'perfstat' library (-lperfstat)])\n  # struct members pertaining to donation have been added to libperfstat somewhere between AIX5.3ML5 and AIX5.3ML9\n  AC_CHECK_MEMBER([perfstat_partition_type_t.b.donate_enabled],\n    [],\n    [],\n    [[#include <libperfstat.h]]\n  )\n  if test \"x$av_cv_member_perfstat_partition_type_t_b_donate_enabled\" = \"xyes\"; then\n    AC_DEFINE([PERFSTAT_SUPPORTS_DONATION], [1], [Define to 1 if your version of the 'perfstat' library supports donation])\n  fi\nfi\nAM_CONDITIONAL([BUILD_WITH_PERFSTAT], [test \"x$with_perfstat\" = \"xyes\"])\n\n# Processes plugin under AIX.\nif test \"x$with_procinfo\" = \"xyes\"; then\n  AC_CHECK_HEADERS([procinfo.h],\n    [AC_DEFINE([HAVE_PROCINFO_H], [1], [Define to 1 if you have the procinfo.h])],\n    [with_procinfo=\"no (procinfo.h not found)\"]\n  )\nfi\n\nif test \"x$ac_system\" = \"xSolaris\"; then\n  with_kstat=\"yes\"\n  with_devinfo=\"yes\"\nelse\n  with_kstat=\"no (Solaris only)\"\n  with_devinfo=\"no (Solaris only)\"\nfi\n\nif test \"x$with_kstat\" = \"xyes\"; then\n  AC_CHECK_LIB([kstat], [kstat_open],\n    [with_kstat=\"yes\"],\n    [with_kstat=\"no (libkstat not found)\"]\n  )\nfi\n\nif test \"x$with_kstat\" = \"xyes\"; then\n  AC_CHECK_LIB([devinfo], [di_init],\n    [with_devinfo=\"yes\"],\n    [with_devinfo=\"no (not found)\"]\n  )\n  AC_CHECK_HEADERS([kstat.h],\n    [AC_DEFINE(HAVE_LIBKSTAT, [1], [Define to 1 if you have the 'kstat' library (-lkstat)])],\n    [with_kstat=\"no (kstat.h not found)\"]\n  )\nfi\n\nAM_CONDITIONAL([BUILD_WITH_LIBDEVINFO], [test \"x$with_devinfo\" = \"xyes\"])\nAM_CONDITIONAL([BUILD_WITH_LIBKSTAT], [test \"x$with_kstat\" = \"xyes\"])\n\nif test \"x$ac_system\" = \"xDarwin\"; then\n  with_libiokit=\"yes\"\nelse\n  with_libiokit=\"no\"\nfi\nAM_CONDITIONAL([BUILD_WITH_LIBIOKIT], [test \"x$with_libiokit\" = \"xyes\"])\n\nwith_libkvm=\"no\"\nAC_CHECK_LIB([kvm], [kvm_getprocs],\n  [with_kvm_getprocs=\"yes\"],\n  [with_kvm_getprocs=\"no\"]\n)\n\nif test \"x$with_kvm_getprocs\" = \"xyes\"; then\n  AC_DEFINE([HAVE_LIBKVM_GETPROCS], [1],\n    [Define to 1 if you have the 'kvm' library with the 'kvm_getprocs' symbol (-lkvm)]\n  )\n  with_libkvm=\"yes\"\nfi\n\nAM_CONDITIONAL([BUILD_WITH_LIBKVM_GETPROCS], [test \"x$with_kvm_getprocs\" = \"xyes\"])\n\nAC_CHECK_LIB([kvm], [kvm_getswapinfo],\n  [with_kvm_getswapinfo=\"yes\"],\n  [with_kvm_getswapinfo=\"no\"]\n)\n\nif test \"x$with_kvm_getswapinfo\" = \"xyes\"; then\n  AC_DEFINE([HAVE_LIBKVM_GETSWAPINFO], [1],\n    [Define to 1 if you have the 'kvm' library with the 'kvm_getswapinfo' symbol (-lkvm)]\n  )\n  with_libkvm=\"yes\"\nfi\n\nAM_CONDITIONAL([BUILD_WITH_LIBKVM_GETSWAPINFO], [test \"x$with_kvm_getswapinfo\" = \"xyes\"])\n\nAC_CHECK_LIB([kvm], [kvm_nlist],\n  [with_kvm_nlist=\"yes\"],\n  [with_kvm_nlist=\"no\"]\n)\n\nif test \"x$with_kvm_nlist\" = \"xyes\"; then\n  AC_CHECK_HEADERS([bsd/nlist.h nlist.h])\n  AC_DEFINE([HAVE_LIBKVM_NLIST], [1],\n    [Define to 1 if you have the 'kvm' library with the 'kvm_nlist' symbol (-lkvm)]\n  )\n  with_libkvm=\"yes\"\nfi\n\nAM_CONDITIONAL([BUILD_WITH_LIBKVM_NLIST], [test \"x$with_kvm_nlist\" = \"xyes\"])\n\nAC_CHECK_LIB([kvm], [kvm_openfiles],\n  [with_kvm_openfiles=\"yes\"],\n  [with_kvm_openfiles=\"no\"]\n)\n\nif test \"x$with_kvm_openfiles\" = \"xyes\"; then\n  AC_DEFINE([HAVE_LIBKVM_NLIST], [1],\n    [Define to 1 if you have the 'kvm' library with the 'kvm_openfiles' symbol (-lkvm)]\n  )\n  with_libkvm=\"yes\"\nfi\n\n# --with-cuda {{{\nAC_ARG_WITH([cuda],\n  [AS_HELP_STRING([--with-cuda@<:@=PREFIX@:>@], [Path to cuda.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_cuda_cppflags=\"-I$withval/include\"\n      with_cuda_ldflags=\"-I$withval/lib\"\n      with_cuda=\"yes\"\n    else\n      with_cuda=\"$withval\"\n    fi\n  ],\n  [with_cuda=\"no\"]\n)\n\nif test \"x$with_cuda\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_cuda_cppflags\"\n\n  AC_CHECK_HEADERS([nvml.h],\n    [with_cuda=\"yes\"],\n    [with_cuda=\"no (nvml.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_cuda\" = \"xyes\"; then\n  BUILD_WITH_CUDA_CPPFLAGS=\"$with_cuda_cppflags\"\n  BUILD_WITH_CUDA_LDFLAGS=\"$with_cuda_ldflags\"\n  BUILD_WITH_CUDA_LIBS=\"-lnvidia-ml\"\nfi\n\nAC_SUBST([BUILD_WITH_CUDA_CPPFLAGS])\nAC_SUBST([BUILD_WITH_CUDA_LDFLAGS])\nAC_SUBST([BUILD_WITH_CUDA_LIBS])\n\n# }}}\n\n# --with-libaquaero5 {{{\nAC_ARG_WITH([libaquaero5],\n  [AS_HELP_STRING([--with-libaquaero5@<:@=PREFIX@:>@], [Path to aquatools-ng source code.])],\n  [\n    if test \"x$withval\" = \"xyes\"; then\n      with_libaquaero5=\"yes\"\n    else if test \"x$withval\" = \"xno\"; then\n      with_libaquaero5=\"no\"\n    else\n      with_libaquaero5=\"yes\"\n      LIBAQUAERO5_CFLAGS=\"$LIBAQUAERO5_CFLAGS -I$withval/src\"\n      LIBAQUAERO5_LDFLAGS=\"$LIBAQUAERO5_LDFLAGS -L$withval/obj\"\n    fi; fi\n  ],\n  [with_libaquaero5=\"yes\"]\n)\n\nSAVE_CPPFLAGS=\"$CPPFLAGS\"\nSAVE_LDFLAGS=\"$LDFLAGS\"\nCPPFLAGS=\"$CPPFLAGS $LIBAQUAERO5_CFLAGS\"\nLDFLAGS=\"$LDFLAGS $LIBAQUAERO5_LDFLAGS\"\n\nif test \"x$with_libaquaero5\" = \"xyes\"; then\n  AC_CHECK_HEADERS([libaquaero5.h],\n    [with_libaquaero5=\"yes\"],\n    [with_libaquaero5=\"no (libaquaero5.h not found)\"]\n  )\nfi\n\nif test \"x$with_libaquaero5\" = \"xyes\"; then\n  AC_CHECK_LIB([aquaero5], libaquaero5_poll,\n    [with_libaquaero5=\"yes\"],\n    [with_libaquaero5=\"no (symbol 'libaquaero5_poll' not found)\"]\n  )\nfi\n\nCPPFLAGS=\"$SAVE_CPPFLAGS\"\nLDFLAGS=\"$SAVE_LDFLAGS\"\n\nif test \"x$with_libaquaero5\" = \"xyes\"; then\n  BUILD_WITH_LIBAQUAERO5_CFLAGS=\"$LIBAQUAERO5_CFLAGS\"\n  BUILD_WITH_LIBAQUAERO5_LDFLAGS=\"$LIBAQUAERO5_LDFLAGS\"\nfi\nAC_SUBST([BUILD_WITH_LIBAQUAERO5_CFLAGS])\nAC_SUBST([BUILD_WITH_LIBAQUAERO5_LDFLAGS])\n# }}}\n\n# --with-libhiredis {{{\nAC_ARG_WITH([libhiredis],\n  [AS_HELP_STRING([--with-libhiredis@<:@=PREFIX@:>@], [Path to libhiredis.])],\n  [\n    if test \"x$withval\" = \"xyes\"; then\n      with_libhiredis=\"yes\"\n    else if test \"x$withval\" = \"xno\"; then\n      with_libhiredis=\"no\"\n    else\n      with_libhiredis=\"yes\"\n      LIBHIREDIS_CPPFLAGS=\"$LIBHIREDIS_CPPFLAGS -I$withval/include\"\n      LIBHIREDIS_LDFLAGS=\"$LIBHIREDIS_LDFLAGS -L$withval/lib\"\n    fi; fi\n  ],\n  [with_libhiredis=\"yes\"]\n)\n\nSAVE_CPPFLAGS=\"$CPPFLAGS\"\nSAVE_LDFLAGS=\"$LDFLAGS\"\nCPPFLAGS=\"$CPPFLAGS $LIBHIREDIS_CPPFLAGS\"\nLDFLAGS=\"$LDFLAGS $LIBHIREDIS_LDFLAGS\"\n\nif test \"x$with_libhiredis\" = \"xyes\"; then\n  AC_CHECK_HEADERS([hiredis/hiredis.h],\n    [with_libhiredis=\"yes\"],\n    [with_libhiredis=\"no (hiredis.h not found)\"]\n  )\nfi\n\nif test \"x$with_libhiredis\" = \"xyes\"; then\n  AC_CHECK_LIB([hiredis], [redisCommand],\n    [with_libhiredis=\"yes\"],\n    [with_libhiredis=\"no (symbol 'redisCommand' not found)\"]\n  )\nfi\n\nCPPFLAGS=\"$SAVE_CPPFLAGS\"\nLDFLAGS=\"$SAVE_LDFLAGS\"\n\nif test \"x$with_libhiredis\" = \"xyes\"; then\n  BUILD_WITH_LIBHIREDIS_CPPFLAGS=\"$LIBHIREDIS_CPPFLAGS\"\n  BUILD_WITH_LIBHIREDIS_LDFLAGS=\"$LIBHIREDIS_LDFLAGS\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBHIREDIS_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBHIREDIS_LDFLAGS])\n# }}}\n\n# --with-libcurl {{{\nwith_curl_config=\"curl-config\"\nwith_curl_cflags=\"\"\nwith_curl_libs=\"\"\nAC_ARG_WITH(libcurl,\n  [AS_HELP_STRING([--with-libcurl@<:@=PREFIX@:>@], [Path to libcurl.])],\n  [\n    if test \"x$withval\" = \"xno\"; then\n      with_libcurl=\"no\"\n    else if test \"x$withval\" = \"xyes\"; then\n      with_libcurl=\"yes\"\n    else\n      if test -f \"$withval\" && test -x \"$withval\"; then\n        with_curl_config=\"$withval\"\n        with_libcurl=\"yes\"\n      else if test -x \"$withval/bin/curl-config\"; then\n        with_curl_config=\"$withval/bin/curl-config\"\n        with_libcurl=\"yes\"\n      fi; fi\n      with_libcurl=\"yes\"\n    fi; fi\n  ],\n  [with_libcurl=\"yes\"]\n)\n\nif test \"x$with_libcurl\" = \"xyes\"; then\n  with_curl_cflags=`$with_curl_config --cflags 2>/dev/null`\n  curl_config_status=$?\n\n  if test $curl_config_status -ne 0; then\n    with_libcurl=\"no ($with_curl_config failed)\"\n  else\n    SAVE_CPPFLAGS=\"$CPPFLAGS\"\n    CPPFLAGS=\"$CPPFLAGS $with_curl_cflags\"\n\n    AC_CHECK_HEADERS([curl/curl.h],\n      [with_libcurl=\"yes\"],\n      [with_libcurl=\"no (curl/curl.h not found)\"]\n    )\n\n    CPPFLAGS=\"$SAVE_CPPFLAGS\"\n  fi\nfi\n\nif test \"x$with_libcurl\" = \"xyes\"; then\n  with_curl_libs=`$with_curl_config --libs 2>/dev/null`\n  curl_config_status=$?\n\n  if test $curl_config_status -ne 0; then\n    with_libcurl=\"no ($with_curl_config failed)\"\n  else\n    AC_CHECK_LIB([curl], [curl_easy_init],\n      [with_libcurl=\"yes\"],\n      [with_libcurl=\"no (symbol 'curl_easy_init' not found)\"],\n      [$with_curl_libs]\n    )\n\n    AC_CHECK_DECL([CURLOPT_USERNAME],\n      [have_curlopt_username=\"yes\"],\n      [have_curlopt_username=\"no\"],\n      [[#include <curl/curl.h>]]\n    )\n\n    AC_CHECK_DECL(CURLOPT_TIMEOUT_MS,\n      [have_curlopt_timeout=\"yes\"],\n      [have_curlopt_timeout=\"no\"],\n      [[#include <curl/curl.h>]]\n    )\n  fi\nfi\n\nif test \"x$with_libcurl\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_curl_cflags\"\n  LDFLAGS=\"$LDFLAGS $with_curl_libs\"\n  AC_CACHE_CHECK([for CURLINFO_APPCONNECT_TIME],\n    [c_cv_have_curlinfo_appconnect_time],\n    [\n      AC_LINK_IFELSE(\n        [\n          AC_LANG_PROGRAM(\n            [[#include <curl/curl.h>]],\n            [[\n              int val = CURLINFO_APPCONNECT_TIME;\n              return val;\n            ]]\n          )\n        ],\n        [c_cv_have_curlinfo_appconnect_time=\"yes\"],\n        [c_cv_have_curlinfo_appconnect_time=\"no\"]\n      )\n    ]\n  )\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$c_cv_have_curlinfo_appconnect_time\" = \"xyes\"; then\n  AC_DEFINE([HAVE_CURLINFO_APPCONNECT_TIME], [1],\n    [Define if curl.h defines CURLINFO_APPCONNECT_TIME.]\n  )\nfi\n\nif test \"x$with_libcurl\" = \"xyes\"; then\n  BUILD_WITH_LIBCURL_CFLAGS=\"$with_curl_cflags\"\n  BUILD_WITH_LIBCURL_LIBS=\"$with_curl_libs\"\n\n  if test \"x$have_curlopt_username\" = \"xyes\"; then\n    AC_DEFINE([HAVE_CURLOPT_USERNAME], [1],\n      [Define if libcurl supports CURLOPT_USERNAME option.]\n    )\n  fi\n\n  if test \"x$have_curlopt_timeout\" = \"xyes\"; then\n    AC_DEFINE([HAVE_CURLOPT_TIMEOUT_MS], [1],\n      [Define if libcurl supports CURLOPT_TIMEOUT_MS option.]\n    )\n  fi\nfi\n\nAC_SUBST(BUILD_WITH_LIBCURL_CFLAGS)\nAC_SUBST(BUILD_WITH_LIBCURL_LIBS)\n\nAM_CONDITIONAL([BUILD_WITH_LIBCURL], [test \"x$with_libcurl\" = \"xyes\"])\n# }}}\n\n# --with-libdbi {{{\nAC_ARG_WITH([libdbi],\n  [AS_HELP_STRING([--with-libdbi@<:@=PREFIX@:>@], [Path to libdbi.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_libdbi_cppflags=\"-I$withval/include\"\n      with_libdbi_ldflags=\"-L$withval/lib\"\n      with_libdbi=\"yes\"\n    else\n      with_libdbi=\"$withval\"\n    fi\n  ],\n  [with_libdbi=\"yes\"]\n)\n\nif test \"x$with_libdbi\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libdbi_cppflags\"\n\n  AC_CHECK_HEADERS([dbi/dbi.h],\n    [with_libdbi=\"yes\"],\n    [with_libdbi=\"no (dbi/dbi.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libdbi\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libdbi_ldflags\"\n\n  AC_CHECK_LIB([dbi], [dbi_initialize],\n    [with_libdbi=\"yes\"],\n    [with_libdbi=\"no (Symbol 'dbi_initialize' not found)\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nBUILD_WITH_LIBDBI_CPPFLAGS=\"$with_libdbi_cppflags\"\nBUILD_WITH_LIBDBI_LDFLAGS=\"$with_libdbi_ldflags\"\nBUILD_WITH_LIBDBI_LIBS=\"-ldbi\"\nAC_SUBST(BUILD_WITH_LIBDBI_CPPFLAGS)\nAC_SUBST(BUILD_WITH_LIBDBI_LDFLAGS)\nAC_SUBST(BUILD_WITH_LIBDBI_LIBS)\n# }}}\n\n# --with-libdpdk {{{\nAC_ARG_VAR([LIBDPDK_CPPFLAGS], [Preprocessor flags for libdpdk])\nAC_ARG_VAR([LIBDPDK_CFLAGS], [Compiler flags for libdpdk])\nAC_ARG_VAR([LIBDPDK_LDFLAGS], [Linker flags for libdpdk])\nAC_ARG_VAR([LIBDPDK_LIBS], [Libraries to link for libdpdk])\n\nAC_ARG_WITH([libdpdk],\n  [AS_HELP_STRING([--without-libdpdk], [Disable libdpdk.])],\n  [with_libdpdk=\"$withval\"],\n  [with_libdpdk=\"yes\"]\n)\n\nif test \"x$with_libdpdk\" != \"xno\"; then\n  PKG_CHECK_MODULES([DPDK], [libdpdk], [],\n    [AC_MSG_NOTICE([no DPDK pkg-config, using defaults])])\n  if test \"x$LIBDPDK_CPPFLAGS\" = \"x\"; then\n    LIBDPDK_CPPFLAGS=\"-I/usr/include/dpdk\"\n  fi\n  if test \"x$LIBDPDK_CFLAGS\" = \"x\"; then\n    LIBDPDK_CFLAGS=\"$DPDK_CFLAGS\"\n    LIBDPDK_CPPFLAGS=\"$LIBDPDK_CPPFLAGS $DPDK_CFLAGS\"\n  fi\n  if test \"x$LIBDPDK_LIBS\" = \"x\"; then\n    if test \"x$DPDK_LIBS\" != \"x\"; then\n      LIBDPDK_LIBS=\"$DPDK_LIBS\"\n    else\n      LIBDPDK_LIBS=\"-ldpdk\"\n    fi\n  fi\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$LIBDPDK_CPPFLAGS $CPPFLAGS\"\n  SAVE_CFLAGS=\"$CFLAGS\"\n  CFLAGS=\"$LIBDPDK_CFLAGS $CFLAGS\"\n  AC_CHECK_HEADERS([rte_config.h],\n    [\n      with_libdpdk=\"yes\"\n      AC_PREPROC_IFELSE(\n        [\n          AC_LANG_SOURCE(\n            [[\n              #include <rte_version.h>\n              #if RTE_VERSION < RTE_VERSION_NUM(16,7,0,0)\n              #error \"required DPDK >= 16.07\"\n              #endif\n            ]]\n          )\n        ],\n        [dpdk_keepalive=\"yes\"],\n        [dpdk_keepalive=\"no (DPDK version < 16.07)\"]\n      )\n    ],\n    [with_libdpdk=\"no (rte_config.h not found)\"]\n  )\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\n  CFLAGS=\"$SAVE_CFLAGS\"\nfi\n\nif test \"x$with_libdpdk\" = \"xyes\"; then\n  SAVE_LIBS=\"$LIBS\"\n  LIBS=\"$LIBDPDK_LIBS $LIBS\"\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LIBDPDK_LDFLAGS $LDFLAGS\"\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$LIBDPDK_CPPFLAGS $CPPFLAGS\"\n  SAVE_CFLAGS=\"$CFLAGS\"\n  CFLAGS=\"$LIBDPDK_CFLAGS $CFLAGS\"\n  AC_LINK_IFELSE(\n    [\n      AC_LANG_PROGRAM(\n        [[\n          #include <rte_eal.h>\n        ]],\n        [[return rte_eal_init(0, NULL);]]\n      )\n    ],\n    [with_libdpdk=\"yes\"],\n    [with_libdpdk=\"no (symbol 'rte_eal_init' not found)\"]\n  )\n  LIBS=\"$SAVE_LIBS\"\n  LDFLAGS=\"$SAVE_LDFLAGS\"\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\n  CFLAGS=\"$SAVE_CFLAGS\"\nfi\n\n# }}}\n\n# --with-libesmtp {{{\nAC_ARG_WITH([libesmtp],\n  [AS_HELP_STRING([--with-libesmtp@<:@=PREFIX@:>@], [Path to libesmtp.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_libesmtp_cppflags=\"-I$withval/include\"\n      with_libesmtp_ldflags=\"-L$withval/lib\"\n      with_libesmtp=\"yes\"\n    else\n      with_libesmtp=\"$withval\"\n    fi\n  ],\n  [with_libesmtp=\"yes\"]\n)\n\nif test \"x$with_libesmtp\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libesmtp_cppflags\"\n\n  AC_CHECK_HEADERS([libesmtp.h],\n    [with_libesmtp=\"yes\"],\n    [with_libesmtp=\"no (libesmtp.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libesmtp\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_esmtp_ldflags\"\n\n  AC_CHECK_LIB([esmtp], [smtp_create_session],\n    [with_libesmtp=\"yes\"],\n    [with_libesmtp=\"no (Symbol 'smtp_create_session' not found)\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nBUILD_WITH_LIBESMTP_CPPFLAGS=\"$with_libesmtp_cppflags\"\nBUILD_WITH_LIBESMTP_LDFLAGS=\"$with_libesmtp_ldflags\"\nBUILD_WITH_LIBESMTP_LIBS=\"-lesmtp\"\nAC_SUBST(BUILD_WITH_LIBESMTP_CPPFLAGS)\nAC_SUBST(BUILD_WITH_LIBESMTP_LDFLAGS)\nAC_SUBST(BUILD_WITH_LIBESMTP_LIBS)\n# }}}\n\n# --with-libganglia {{{\nAC_ARG_WITH([libganglia],\n  [AS_HELP_STRING([--with-libganglia@<:@=PREFIX@:>@], [Path to libganglia.])],\n  [\n    if test -f \"$withval\" && test -x \"$withval\"; then\n      with_libganglia_config=\"$withval\"\n      with_libganglia=\"yes\"\n    else if test -f \"$withval/bin/ganglia-config\" && test -x \"$withval/bin/ganglia-config\"; then\n      with_libganglia_config=\"$withval/bin/ganglia-config\"\n      with_libganglia=\"yes\"\n    else if test -d \"$withval\"; then\n      GANGLIA_CPPFLAGS=\"-I$withval/include\"\n      GANGLIA_LDFLAGS=\"-L$withval/lib\"\n      with_libganglia=\"yes\"\n    else\n      with_libganglia=\"$withval\"\n    fi; fi; fi\n  ],\n  [with_libganglia=\"yes\"]\n)\n\nif test \"x$with_libganglia\" = \"xyes\"; then\n  if test \"x$with_libganglia_config\" != \"x\"; then\n    if test \"x$GANGLIA_CPPFLAGS\" = \"x\"; then\n      GANGLIA_CPPFLAGS=`\"$with_libganglia_config\" --cflags 2>/dev/null`\n    fi\n\n    if test \"x$GANGLIA_LDFLAGS\" = \"x\"; then\n      GANGLIA_LDFLAGS=`\"$with_libganglia_config\" --ldflags 2>/dev/null`\n    fi\n\n    if test \"x$GANGLIA_LIBS\" = \"x\"; then\n      GANGLIA_LIBS=`\"$with_libganglia_config\" --libs 2>/dev/null`\n    fi\n  else\n    GANGLIA_LIBS=\"-lganglia\"\n  fi\nfi\n\nSAVE_CPPFLAGS=\"$CPPFLAGS\"\nSAVE_LDFLAGS=\"$LDFLAGS\"\nCPPFLAGS=\"$CPPFLAGS $GANGLIA_CPPFLAGS\"\nLDFLAGS=\"$LDFLAGS $GANGLIA_LDFLAGS\"\n\nif test \"x$with_libganglia\" = \"xyes\"; then\n  AC_CHECK_HEADERS([gm_protocol.h],\n    [with_libganglia=\"yes\"],\n    [with_libganglia=\"no (gm_protocol.h not found)\"]\n  )\nfi\n\nif test \"x$with_libganglia\" = \"xyes\"; then\n  AC_CHECK_LIB([ganglia], [xdr_Ganglia_value_msg],\n    [with_libganglia=\"yes\"],\n    [with_libganglia=\"no (symbol xdr_Ganglia_value_msg not found)\"]\n  )\nfi\n\nCPPFLAGS=\"$SAVE_CPPFLAGS\"\nLDFLAGS=\"$SAVE_LDFLAGS\"\n\nAC_SUBST(GANGLIA_CPPFLAGS)\nAC_SUBST(GANGLIA_LDFLAGS)\nAC_SUBST(GANGLIA_LIBS)\n# }}}\n\n# --with-libgcrypt {{{\nGCRYPT_CPPFLAGS=\"$GCRYPT_CPPFLAGS\"\nGCRYPT_LDFLAGS=\"$GCRYPT_LDFLAGS\"\nGCRYPT_LIBS=\"$GCRYPT_LIBS\"\nAC_ARG_WITH([libgcrypt],\n  [AS_HELP_STRING([--with-libgcrypt@<:@=PREFIX@:>@], [Path to libgcrypt.])],\n  [\n    if test -f \"$withval\" && test -x \"$withval\"; then\n      with_libgcrypt_config=\"$withval\"\n      with_libgcrypt=\"yes\"\n    else if test -f \"$withval/bin/gcrypt-config\" && test -x \"$withval/bin/gcrypt-config\"; then\n      with_libgcrypt_config=\"$withval/bin/gcrypt-config\"\n      with_libgcrypt=\"yes\"\n    else if test -d \"$withval\"; then\n      GCRYPT_CPPFLAGS=\"$GCRYPT_CPPFLAGS -I$withval/include\"\n      GCRYPT_LDFLAGS=\"$GCRYPT_LDFLAGS -L$withval/lib\"\n      with_libgcrypt=\"yes\"\n    else\n      with_libgcrypt_config=\"gcrypt-config\"\n      with_libgcrypt=\"$withval\"\n    fi; fi; fi\n  ],\n  [\n    with_libgcrypt_config=\"libgcrypt-config\"\n    with_libgcrypt=\"yes\"\n  ]\n)\n\nif test \"x$with_libgcrypt\" = \"xyes\" && test \"x$with_libgcrypt_config\" != \"x\"; then\n  if test \"x$GCRYPT_CPPFLAGS\" = \"x\"; then\n    GCRYPT_CPPFLAGS=`\"$with_libgcrypt_config\" --cflags 2>/dev/null`\n  fi\n\n  if test \"x$GCRYPT_LIBS\" = \"x\"; then\n    GCRYPT_LIBS=`\"$with_libgcrypt_config\" --libs 2>/dev/null`\n  fi\nfi\n\nSAVE_CPPFLAGS=\"$CPPFLAGS\"\nSAVE_LDFLAGS=\"$LDFLAGS\"\nSAVE_LIBS=\"$LIBS\"\nCPPFLAGS=\"$CPPFLAGS $GCRYPT_CPPFLAGS\"\nLDFLAGS=\"$LDFLAGS $GCRYPT_LDFLAGS\"\nLIBS=\"$LIBS $GCRYPT_LIBS\"\n\nif test \"x$with_libgcrypt\" = \"xyes\"; then\n  AC_CHECK_HEADERS([gcrypt.h],\n    [with_libgcrypt=\"yes\"],\n    [with_libgcrypt=\"no (gcrypt.h not found)\"]\n  )\nfi\n\nif test \"x$with_libgcrypt\" = \"xyes\"; then\n  AC_CHECK_LIB(gcrypt, gcry_md_hash_buffer,\n    [with_libgcrypt=\"yes\"],\n    [with_libgcrypt=\"no (symbol gcry_md_hash_buffer not found)\"]\n  )\nfi\n\nCPPFLAGS=\"$SAVE_CPPFLAGS\"\nLDFLAGS=\"$SAVE_LDFLAGS\"\nLIBS=\"$SAVE_LIBS\"\n\nAC_SUBST([GCRYPT_CPPFLAGS])\nAC_SUBST([GCRYPT_LDFLAGS])\nAC_SUBST([GCRYPT_LIBS])\nAM_CONDITIONAL([BUILD_WITH_LIBGCRYPT], [test \"x$with_libgcrypt\" = \"xyes\"])\n# }}}\n\n# --with-libgps {{{\nAC_ARG_WITH([libgps],\n  [AS_HELP_STRING([--with-libgps@<:@=PREFIX@:>@], [Path to libgps.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_libgps_cflags=\"-I$withval/include\"\n      with_libgps_ldflags=\"-L$withval/lib\"\n      with_libgps=\"yes\"\n    else\n      with_libgps=\"$withval\"\n    fi\n  ],\n  [with_libgps=\"yes\"]\n)\n\nif test \"x$with_libgps\" = \"xyes\"; then\n  SAVE_CFLAGS=\"$CFLAGS\"\n  CFLAGS=\"$CFLAGS $with_libgps_cflags\"\n\n  AC_CHECK_HEADERS([gps.h],\n    [with_libgps=\"yes\"],\n    [with_libgps=\"no (gps.h not found)\"]\n  )\n\n  CFLAGS=\"$SAVE_CFLAGS\"\nfi\n\nif test \"x$with_libgps\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libgps_ldflags\"\n\n  AC_CHECK_LIB([gps], [gps_open],\n    [with_libgps=\"yes\"],\n    [with_libgps=\"no (symbol gps_open not found)\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libgps\" = \"xyes\"; then\n  BUILD_WITH_LIBGPS_CFLAGS=\"$with_libgps_cflags\"\n  BUILD_WITH_LIBGPS_LDFLAGS=\"$with_libgps_ldflags\"\n  BUILD_WITH_LIBGPS_LIBS=\"-lgps\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBGPS_CFLAGS])\nAC_SUBST([BUILD_WITH_LIBGPS_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBGPS_LIBS])\n\n# }}}\n\n# --with-libgrpc++ {{{\nAC_ARG_WITH([libgrpc++],\n  [AS_HELP_STRING([--with-libgrpc++@<:@=PREFIX@:>@], [Path to libgrpc++.])],\n  [\n    with_grpcpp=\"$withval\"\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_libgrpcpp_cppflags=\"-I$withval/include\"\n      with_libgrpcpp_ldflags=\"-L$withval/lib\"\n      with_libgrpcpp_bin=\"$withval/bin\"\n      with_libgrpcpp=\"yes\"\n    fi\n    if test \"x$withval\" = \"xno\"; then\n      with_libgrpcpp=\"no (disabled on command line)\"\n    fi\n  ],\n  [withval=\"yes\"]\n)\nif test \"x$withval\" = \"xyes\"; then\nPKG_CHECK_MODULES([GRPCPP], [grpc++],\n  [with_libgrpcpp=\"yes\"],\n  [with_libgrpcpp=\"no (pkg-config could not find libgrpc++)\"]\n)\nfi\n\nif test \"x$withval\" != \"xno\"; then\n  AC_MSG_CHECKING([whether $CXX accepts -std=c++11])\n  if test_cxx_flags -std=c++11; then\n    AC_MSG_RESULT([yes])\n  else\n    AC_MSG_RESULT([no])\n    with_libgrpcpp=\"no (requires C++11 support)\"\n  fi\nfi\n\nif test \"x$with_libgrpcpp\" = \"xyes\"; then\n  AC_LANG_PUSH(C++)\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"-std=c++11 $with_libgrpcpp_cppflags $GRPCPP_CFLAGS $CPPFLAGS\"\n  AC_CHECK_HEADERS([grpc++/grpc++.h],\n    [with_libgrpcpp=\"yes\"],\n    [with_libgrpcpp=\"no (<grpc++/grpc++.h> not found)\"]\n  )\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\n  AC_LANG_POP(C++)\nfi\n\nif test \"x$with_libgrpcpp\" = \"xyes\"; then\n  AC_LANG_PUSH(C++)\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  SAVE_LIBS=\"$LIBS\"\n  CPPFLAGS=\"-std=c++11 $with_libgrpcpp_cppflags $GRPCPP_CFLAGS $CPPFLAGS\"\n  LDFLAGS=\"$with_libgrpcpp_ldflags\"\n  if test \"x$GRPCPP_LIBS\" = \"x\"; then\n    LIBS=\"-lgrpc++\"\n  else\n    LIBS=\"$GRPCPP_LIBS\"\n  fi\n  AC_LINK_IFELSE(\n    [\n      AC_LANG_PROGRAM(\n        [[#include <grpc++/grpc++.h>]],\n        [[grpc::ServerBuilder sb;]]\n      )\n    ],\n    [\n      with_libgrpcpp=\"yes\"\n      if test \"x$GRPCPP_LIBS\" = \"x\"; then\n        GRPCPP_LIBS=\"-lgrpc++\"\n      fi\n    ],\n    [with_libgrpcpp=\"no (libgrpc++ not found)\"]\n  )\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\n  LDFLAGS=\"$SAVE_LDFLAGS\"\n  LIBS=\"$SAVE_LIBS\"\n  AC_LANG_POP(C++)\nfi\n\nBUILD_WITH_LIBGRPCPP_CPPFLAGS=\"-std=c++11 $with_libgrpcpp_cppflags $GRPCPP_CFLAGS\"\nBUILD_WITH_LIBGRPCPP_LDFLAGS=\"$with_libgrpcpp_ldflags\"\nBUILD_WITH_LIBGRPCPP_LIBS=\"$GRPCPP_LIBS\"\nAC_SUBST([BUILD_WITH_LIBGRPCPP_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBGRPCPP_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBGRPCPP_LIBS])\n# }}}\n\nAC_ARG_VAR([GRPC_CPP_PLUGIN], [path to the grpc_cpp_plugin binary])\nif test \"x$with_libgrpcpp_bin\" = \"x\"; then\n  AC_PATH_PROG([GRPC_CPP_PLUGIN], [grpc_cpp_plugin])\nelse\n  AC_PATH_PROG([GRPC_CPP_PLUGIN], [grpc_cpp_plugin], [], \"$with_libgrpcpp_bin:$PATH\")\nfi\nAM_CONDITIONAL([HAVE_GRPC_CPP], [test \"x$GRPC_CPP_PLUGIN\" != \"x\"])\n\n# --with-libiptc {{{\nAC_ARG_WITH([libiptc],\n  [AS_HELP_STRING([--with-libiptc@<:@=PREFIX@:>@], [Path to libiptc.])],\n  [\n    if test \"x$withval\" = \"xyes\"; then\n      with_libiptc=\"pkgconfig\"\n    else if test \"x$withval\" = \"xno\"; then\n      with_libiptc=\"no\"\n    else\n      with_libiptc=\"yes\"\n      with_libiptc_cflags=\"-I$withval/include\"\n      with_libiptc_libs=\"-L$withval/lib\"\n    fi; fi\n  ],\n  [\n    if test \"x$ac_system\" = \"xLinux\"; then\n      with_libiptc=\"pkgconfig\"\n    else\n      with_libiptc=\"no (Linux only)\"\n    fi\n  ]\n)\n\nif test \"x$with_libiptc\" = \"xpkgconfig\"; then\n  $PKG_CONFIG --exists 'libiptc' 2>/dev/null\n  if test $? -ne 0; then\n    with_libiptc=\"no (pkg-config doesn't know libiptc)\"\n  fi\nfi\n\nif test \"x$with_libiptc\" = \"xpkgconfig\"; then\n  with_libiptc_cflags=\"`$PKG_CONFIG --cflags 'libiptc'`\"\n  if test $? -ne 0; then\n    with_libiptc=\"no ($PKG_CONFIG failed)\"\n  fi\n\n  with_libiptc_libs=\"`$PKG_CONFIG --libs 'libiptc'`\"\n  if test $? -ne 0; then\n    with_libiptc=\"no ($PKG_CONFIG failed)\"\n  fi\nfi\n\nSAVE_CPPFLAGS=\"$CPPFLAGS\"\nCPPFLAGS=\"$CPPFLAGS $with_libiptc_cflags\"\n\n# check whether the header file for libiptc is available.\nif test \"x$with_libiptc\" = \"xpkgconfig\"; then\n  AC_CHECK_HEADERS([libiptc/libiptc.h libiptc/libip6tc.h],\n    [],\n    [with_libiptc=\"no (header file missing)\"]\n  )\nfi\n\n# If the header file is available, check for the required type declaractions.\n# They may be missing in old versions of libiptc. In that case, they will be\n# declared in the iptables plugin.\nif test \"x$with_libiptc\" = \"xpkgconfig\"; then\n  AC_CHECK_TYPES([iptc_handle_t, ip6tc_handle_t], [], [])\nfi\n\n# Check for the iptc_init symbol in the library.\n# This could be in iptc or ip4tc\nif test \"x$with_libiptc\" = \"xpkgconfig\"; then\n  SAVE_LIBS=\"$LIBS\"\n  AC_SEARCH_LIBS([iptc_init], [iptc ip4tc],\n    [with_libiptc=\"pkgconfig\"],\n    [with_libiptc=\"no\"],\n    [$with_libiptc_libs]\n  )\n  LIBS=\"$SAVE_LIBS\"\nfi\n\nif test \"x$with_libiptc\" = \"xpkgconfig\"; then\n  with_libiptc=\"yes\"\nfi\n\nCPPFLAGS=\"$SAVE_CPPFLAGS\"\n\nif test \"x$with_libiptc\" = \"xyes\"; then\n  BUILD_WITH_LIBIPTC_CPPFLAGS=\"$with_libiptc_cflags\"\n  BUILD_WITH_LIBIPTC_LDFLAGS=\"$with_libiptc_libs\"\nfi\nAC_SUBST([BUILD_WITH_LIBIPTC_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBIPTC_LDFLAGS])\n# }}}\n\n# --with-java {{{\nwith_java_home=\"$JAVA_HOME\"\nif test \"x$with_java_home\" = \"x\"; then\n  with_java_home=\"/usr/lib/jvm\"\nfi\n\nJAVAC=\"$JAVAC\"\nJAR=\"$JAR\"\nAC_ARG_WITH([java],\n  [AS_HELP_STRING([--with-java@<:@=PREFIX@:>@], [Path to Java home.])],\n  [\n    if test \"x$withval\" = \"xno\"; then\n      with_java=\"no\"\n    else if test \"x$withval\" = \"xyes\"; then\n      with_java=\"yes\"\n    else\n      with_java_home=\"$withval\"\n      with_java=\"yes\"\n    fi; fi\n  ],\n  [with_java=\"yes\"]\n)\n\nAX_COMPARE_VERSION([$am__api_version],[lt],[1.12],\n  [JAVA_TIMESTAMP_FILE=\"classdist_noinst.stamp\"],\n  [JAVA_TIMESTAMP_FILE=\"classnoinst.stamp\"])\nif test \"x$with_java\" = \"xyes\"; then\n  if test -d \"$with_java_home\"; then\n    AC_MSG_CHECKING([for jni.h])\n    TMPVAR=`find -L \"$with_java_home\" -name jni.h -type f -exec 'dirname' '{}' ';' 2>/dev/null | LC_ALL=C sort | head -n 1`\n    if test \"x$TMPVAR\" != \"x\"; then\n      AC_MSG_RESULT([found in $TMPVAR])\n      JAVA_CPPFLAGS=\"$JAVA_CPPFLAGS -I$TMPVAR\"\n    else\n      AC_MSG_RESULT([not found])\n    fi\n\n    AC_MSG_CHECKING([for jni_md.h])\n    TMPVAR=`find -L \"$with_java_home\" -name jni_md.h -type f -exec 'dirname' '{}' ';' 2>/dev/null | LC_ALL=C sort | head -n 1`\n    if test \"x$TMPVAR\" != \"x\"; then\n      AC_MSG_RESULT([found in $TMPVAR])\n      JAVA_CPPFLAGS=\"$JAVA_CPPFLAGS -I$TMPVAR\"\n    else\n      AC_MSG_RESULT([not found])\n    fi\n\n    AC_MSG_CHECKING([for libjvm.so])\n    TMPVAR=`find -L \"$with_java_home\" -type f \\( -name libjvm.so -o -name libjvm.dylib \\) -exec 'dirname' '{}' ';' 2>/dev/null | LC_ALL=C sort | head -n 1`\n    if test \"x$TMPVAR\" != \"x\"; then\n      AC_MSG_RESULT([found in $TMPVAR])\n      JAVA_LDFLAGS=\"$JAVA_LDFLAGS -L$TMPVAR -Wl,-rpath -Wl,$TMPVAR\"\n    else\n      AC_MSG_RESULT([not found])\n    fi\n\n    if test \"x$JAVAC\" = \"x\"; then\n      AC_MSG_CHECKING([for javac])\n      TMPVAR=`find -L \"$with_java_home\" -name javac -type f 2>/dev/null | LC_ALL=C sort | head -n 1`\n      if test \"x$TMPVAR\" != \"x\"; then\n        JAVAC=\"$TMPVAR\"\n        AC_MSG_RESULT([$JAVAC])\n      else\n        AC_MSG_RESULT([not found])\n      fi\n    fi\n\n    if test \"x$JAR\" = \"x\"; then\n      AC_MSG_CHECKING([for jar])\n      TMPVAR=`find -L \"$with_java_home\" -name jar -type f 2>/dev/null | LC_ALL=C sort | head -n 1`\n      if test \"x$TMPVAR\" != \"x\"; then\n        JAR=\"$TMPVAR\"\n        AC_MSG_RESULT([$JAR])\n      else\n        AC_MSG_RESULT([not found])\n      fi\n    fi\n  else if test \"x$with_java_home\" != \"x\"; then\n    AC_MSG_WARN([JAVA_HOME: No such directory: $with_java_home])\n  fi; fi\nfi\n\nif test \"x$JAVAC\" = \"x\"; then\n  with_javac_path=\"$PATH\"\n  if test \"x$with_java_home\" != \"x\"; then\n    with_javac_path=\"$with_java_home:with_javac_path\"\n    if test -d \"$with_java_home/bin\"; then\n      with_javac_path=\"$with_java_home/bin:with_javac_path\"\n    fi\n  fi\n\n  AC_PATH_PROG([JAVAC], [javac], [], \"$with_javac_path\")\nfi\n\nif test \"x$JAVAC\" = \"x\"; then\n  with_java=\"no (javac not found)\"\nfi\n\nif test \"x$JAR\" = \"x\"; then\n  with_jar_path=\"$PATH\"\n  if test \"x$with_java_home\" != \"x\"; then\n    with_jar_path=\"$with_java_home:$with_jar_path\"\n    if test -d \"$with_java_home/bin\"; then\n      with_jar_path=\"$with_java_home/bin:$with_jar_path\"\n    fi\n  fi\n\n  AC_PATH_PROG([JAR], [jar], [], \"$with_jar_path\")\nfi\n\nif test \"x$JAR\" = \"x\"; then\n  with_java=\"no (jar not found)\"\nfi\n\nSAVE_CPPFLAGS=\"$CPPFLAGS\"\nSAVE_CFLAGS=\"$CFLAGS\"\nSAVE_LDFLAGS=\"$LDFLAGS\"\nSAVE_LIBS=\"$LIBS\"\nCPPFLAGS=\"$CPPFLAGS $JAVA_CPPFLAGS\"\nCFLAGS=\"$CFLAGS $JAVA_CFLAGS\"\nLDFLAGS=\"$LDFLAGS $JAVA_LDFLAGS\"\nLIBS=\"$LIBS $JAVA_LIBS\"\n\nif test \"x$with_java\" = \"xyes\"; then\n  AC_CHECK_HEADERS([jni.h],\n    [with_jave=\"yes\"],\n    [with_java=\"no (jni.h not found)\"])\nfi\n\nif test \"x$with_java\" = \"xyes\"; then\n  AC_CHECK_LIB([jvm], [JNI_CreateJavaVM],\n    [with_java=\"yes\"],\n    [with_java=\"no (Symbol 'JNI_CreateJavaVM' not found)\"],\n    [$JAVA_LIBS $PTHREAD_LIBS]\n  )\nfi\n\nif test \"x$with_java\" = \"xyes\"; then\n  JAVA_LIBS=\"$JAVA_LIBS -ljvm\"\nfi\n\nCPPFLAGS=\"$SAVE_CPPFLAGS\"\nCFLAGS=\"$SAVE_CFLAGS\"\nLDFLAGS=\"$SAVE_LDFLAGS\"\nLIBS=\"$SAVE_LIBS\"\n\nAC_SUBST([JAVA_CPPFLAGS])\nAC_SUBST([JAVA_CFLAGS])\nAC_SUBST([JAVA_LDFLAGS])\nAC_SUBST([JAVA_LIBS])\nAC_SUBST([JAVA_TIMESTAMP_FILE])\nAM_CONDITIONAL([BUILD_WITH_JAVA], [test \"x$with_java\" = \"xyes\"])\n# }}}\n\n# --with-libldap {{{\nAC_ARG_WITH([libldap],\n  [AS_HELP_STRING([--with-libldap@<:@=PREFIX@:>@], [Path to libldap.])],\n  [\n    if test \"x$withval\" = \"xyes\"; then\n      with_libldap=\"yes\"\n    else if test \"x$withval\" = \"xno\"; then\n      with_libldap=\"no\"\n    else\n      with_libldap=\"yes\"\n      LIBLDAP_CPPFLAGS=\"$LIBLDAP_CPPFLAGS -I$withval/include\"\n      LIBLDAP_LDFLAGS=\"$LIBLDAP_LDFLAGS -L$withval/lib\"\n    fi; fi\n  ],\n  [with_libldap=\"yes\"]\n)\n\nSAVE_CPPFLAGS=\"$CPPFLAGS\"\nSAVE_LDFLAGS=\"$LDFLAGS\"\n\nCPPFLAGS=\"$CPPFLAGS $LIBLDAP_CPPFLAGS\"\nLDFLAGS=\"$LDFLAGS $LIBLDAP_LDFLAGS\"\n\nif test \"x$with_libldap\" = \"xyes\"; then\n  AC_CHECK_HEADERS([ldap.h],\n    [with_libldap=\"yes\"],\n    [with_libldap=\"no ('ldap.h' not found)\"]\n  )\nfi\n\nif test \"x$with_libldap\" = \"xyes\"; then\n  AC_CHECK_LIB([ldap], [ldap_initialize],\n    [with_libldap=\"yes\"],\n    [with_libldap=\"no (symbol 'ldap_initialize' not found)\"]\n  )\nfi\n\nCPPFLAGS=\"$SAVE_CPPFLAGS\"\nLDFLAGS=\"$SAVE_LDFLAGS\"\n\nif test \"x$with_libldap\" = \"xyes\"\nthen\n  BUILD_WITH_LIBLDAP_CPPFLAGS=\"$LIBLDAP_CPPFLAGS\"\n  BUILD_WITH_LIBLDAP_LDFLAGS=\"$LIBLDAP_LDFLAGS\"\nfi\nAC_SUBST([BUILD_WITH_LIBLDAP_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBLDAP_LDFLAGS])\n# }}}\n\n# --with-liblua {{{\nAC_ARG_VAR([LIBLUA_PKG_CONFIG_NAME], [Name of liblua used by pkg-config])\nif test \"x$LIBLUA_PKG_CONFIG_NAME\" != \"x\"\nthen\n  PKG_CHECK_MODULES([LUA], [$LIBLUA_PKG_CONFIG_NAME],\n    [with_liblua=\"yes\"],\n    [with_liblua=\"no\"]\n  )\nelse\n  PKG_CHECK_MODULES([LUA], [lua],\n    [with_liblua=\"yes\"],\n    [\n      PKG_CHECK_MODULES([LUA], [lua-5.3],\n        [with_liblua=\"yes\"],\n        [\n          PKG_CHECK_MODULES([LUA], [lua5.3],\n            [with_liblua=\"yes\"],\n            [\n              PKG_CHECK_MODULES([LUA], [lua53],\n                [with_liblua=\"yes\"],\n                [\n                  PKG_CHECK_MODULES([LUA], [lua-5.2],\n                    [with_liblua=\"yes\"],\n                    [\n                      PKG_CHECK_MODULES([LUA], [lua5.2],\n                        [with_liblua=\"yes\"],\n                        [\n                          PKG_CHECK_MODULES([LUA], [lua52],\n                            [with_liblua=\"yes\"],\n                            [\n                              PKG_CHECK_MODULES([LUA], [lua-5.1],\n                                [with_liblua=\"yes\"],\n                                [\n                                  PKG_CHECK_MODULES([LUA], [lua5.1],\n                                    [with_liblua=\"yes\"],\n                                    [\n                                      PKG_CHECK_MODULES([LUA], [lua51],\n                                        [with_liblua=\"yes\"],\n                                        [with_liblua=\"no (pkg-config cannot find liblua)\"]\n                                      )\n                                    ]\n                                  )\n                                ]\n                              )\n                            ]\n                          )\n                        ]\n                      )\n                    ]\n                  )\n                ]\n              )\n            ]\n          )\n        ]\n      )\n    ]\n  )\nfi\n\nif test \"x$with_liblua\" = \"xyes\"\nthen\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $LUA_CFLAGS\"\n\n  AC_CHECK_HEADERS([lua.h lauxlib.h lualib.h],\n    [with_liblua=\"yes\"],\n    [with_liblua=\"no (header not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_liblua\" = \"xyes\"\nthen\n  SAVE_LIBS=\"$LIBS\"\n  LIBS=\"$LIBS $LUA_LIBS\"\n\n  AC_CHECK_FUNC([lua_settop],\n    [with_liblua=\"yes\"],\n    [with_liblua=\"no (symbol 'lua_settop' not found)\"]\n  )\n\n  LIBS=\"$SAVE_LIBS\"\nfi\n\nif test \"x$with_liblua\" = \"xyes\"\nthen\n    BUILD_WITH_LIBLUA_CFLAGS=\"$LUA_CFLAGS\"\n    BUILD_WITH_LIBLUA_LIBS=\"$LUA_LIBS\"\nfi\nAC_SUBST(BUILD_WITH_LIBLUA_CFLAGS)\nAC_SUBST(BUILD_WITH_LIBLUA_LIBS)\n# }}}\n\n# --with-liblvm2app {{{\nAC_ARG_WITH([liblvm2app],\n  [AS_HELP_STRING([--with-liblvm2app@<:@=PREFIX@:>@], [Path to liblvm2app.])],\n  [\n    if test \"x$withval\" = \"xno\"; then\n      with_liblvm2app=\"no\"\n    else\n      with_liblvm2app=\"yes\"\n      if test \"x$withval\" != \"xyes\"; then\n        with_liblvm2app_cppflags=\"-I$withval/include\"\n        with_liblvm2app_ldflags=\"-L$withval/lib\"\n      fi\n    fi\n  ],\n  [\n    if test \"x$ac_system\" = \"xLinux\"; then\n      with_liblvm2app=\"yes\"\n    else\n      with_liblvm2app=\"no (Linux only library)\"\n    fi\n  ]\n)\n\nif test \"x$with_liblvm2app\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_liblvm2app_cppflags\"\n\n  AC_CHECK_HEADERS([lvm2app.h],\n    [with_liblvm2app=\"yes\"],\n    [with_liblvm2app=\"no (lvm2app.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_liblvm2app\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_liblvm2app_cppflags\"\n  LDFLAGS=\"$LDFLAGS $with_liblvm2app_ldflags\"\n\n  AC_CHECK_LIB([lvm2app], [lvm_lv_get_property],\n    [with_liblvm2app=\"yes\"],\n    [with_liblvm2app=\"no (Symbol 'lvm_lv_get_property' not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_liblvm2app\" = \"xyes\"; then\n  BUILD_WITH_LIBLVM2APP_CPPFLAGS=\"$with_liblvm2app_cppflags\"\n  BUILD_WITH_LIBLVM2APP_LDFLAGS=\"$with_liblvm2app_ldflags\"\n  BUILD_WITH_LIBLVM2APP_LIBS=\"-llvm2app\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBLVM2APP_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBLVM2APP_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBLVM2APP_LIBS])\n# }}}\n\n# --with-libmemcached {{{\nAC_ARG_WITH([libmemcached],\n  [AS_HELP_STRING([--with-libmemcached@<:@=PREFIX@:>@], [Path to libmemcached.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_libmemcached_cppflags=\"-I$withval/include\"\n      with_libmemcached_ldflags=\"-L$withval/lib\"\n      with_libmemcached=\"yes\"\n    else\n      with_libmemcached=\"$withval\"\n    fi\n  ],\n  [with_libmemcached=\"yes\"]\n)\n\nif test \"x$with_libmemcached\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libmemcached_cppflags\"\n\n  AC_CHECK_HEADERS([libmemcached/memcached.h],\n    [with_libmemcached=\"yes\"],\n    [with_libmemcached=\"no (libmemcached/memcached.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libmemcached\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libmemcached_cppflags\"\n  LDFLAGS=\"$LDFLAGS $with_libmemcached_ldflags\"\n\n  AC_CHECK_LIB([memcached], [memcached_create],\n    [with_libmemcached=\"yes\"],\n    [with_libmemcached=\"no (Symbol 'memcached_create' not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libmemcached\" = \"xyes\"; then\n  BUILD_WITH_LIBMEMCACHED_CPPFLAGS=\"$with_libmemcached_cppflags\"\n  BUILD_WITH_LIBMEMCACHED_LDFLAGS=\"$with_libmemcached_ldflags\"\n  BUILD_WITH_LIBMEMCACHED_LIBS=\"-lmemcached\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBMEMCACHED_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBMEMCACHED_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBMEMCACHED_LIBS])\n# }}}\n\n# --with-libmicrohttpd {{{\nwith_libmicrohttpd_cppflags=\"\"\nwith_libmicrohttpd_ldflags=\"\"\nAC_ARG_WITH([libmicrohttpd], [AS_HELP_STRING([--with-libmicrohttpd@<:@=PREFIX@:>@], [Path to libmicrohttpd.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_libmicrohttpd_cppflags=\"-I$withval/include\"\n      with_libmicrohttpd_ldflags=\"-L$withval/lib\"\n      with_libmicrohttpd=\"yes\"\n    fi\n    if test \"x$withval\" = \"xno\"; then\n      with_libmicrohttpd=\"no (disabled on command line)\"\n    fi\n  ],\n  [withval=\"yes\"]\n)\nif test \"x$withval\" = \"xyes\"; then\n  PKG_CHECK_MODULES([MICROHTTPD], [libmicrohttpd],\n    [with_libmicrohttpd=\"yes\"],\n    [with_libmicrohttpd=\"no (pkg-config could not find libmicrohttpd)\"]\n  )\nfi\n\nif test \"x$MICROHTTPD_LIBS\" = \"x\"; then\n  MICROHTTPD_LIBS=\"-lmicrohttpd\"\nfi\n\nSAVE_CPPFLAGS=\"$CPPFLAGS\"\nSAVE_LDFLAGS=\"$LDFLAGS\"\nSAVE_LIBS=\"$LIBS\"\nCPPFLAGS=\"$with_libmicrohttpd_cppflags $MICROHTTPD_CFLAGS\"\nLDFLAGS=\"$with_libmicrohttpd_ldflags $LDFLAGS\"\nLIBS=\"$LIBS $MICROHTTPD_LIBS\"\n\nif test \"x$with_libmicrohttpd\" = \"xyes\"; then\n  AC_CHECK_HEADERS([microhttpd.h],\n   [with_libmicrohttpd=\"yes\"],\n   [with_libmicrohttpd=\"no (<microhttpd.h> not found)\"]\n  )\nfi\n\nif test \"x$with_libmicrohttpd\" = \"xyes\"; then\n  AC_CHECK_LIB([microhttpd], [MHD_start_daemon],\n    [with_libmicrohttpd=\"yes\"],\n    [with_libmicrohttpd=\"no (libmicrohttpd not found)\"]\n  )\nfi\n\nCPPFLAGS=\"$SAVE_CPPFLAGS\"\nLDFLAGS=\"$SAVE_LDFLAGS\"\nLIBS=\"$SAVE_LIBS\"\n\nBUILD_WITH_LIBMICROHTTPD_CPPFLAGS=\"$with_libmicrohttpd_cppflags $MICROHTTPD_CFLAGS\"\nBUILD_WITH_LIBMICROHTTPD_LDFLAGS=\"$with_libmicrohttpd_ldflags\"\nBUILD_WITH_LIBMICROHTTPD_LIBS=\"$MICROHTTPD_LIBS\"\nAC_SUBST([BUILD_WITH_LIBMICROHTTPD_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBMICROHTTPD_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBMICROHTTPD_LIBS])\n# }}}\n\n# --with-libmodbus {{{\nAC_ARG_WITH([libmodbus],\n  [AS_HELP_STRING([--with-libmodbus@<:@=PREFIX@:>@], [Path to the modbus library.])],\n  [\n    if test \"x$withval\" = \"xno\"; then\n      with_libmodbus=\"no\"\n    else if test \"x$withval\" = \"xyes\"; then\n      with_libmodbus=\"use_pkgconfig\"\n    else if test -d \"$with_libmodbus/lib\"; then\n      AC_MSG_NOTICE([Not checking for libmodbus: Manually configured])\n      with_libmodbus_cflags=\"-I$withval/include\"\n      with_libmodbus_libs=\"-L$withval/lib -lmodbus\"\n      with_libmodbus=\"yes\"\n    fi; fi; fi\n  ],\n  [with_libmodbus=\"use_pkgconfig\"]\n)\n\n# configure using pkg-config\nif test \"x$with_libmodbus\" = \"xuse_pkgconfig\"; then\n  $PKG_CONFIG --exists 'libmodbus' 2>/dev/null\n  if test $? -ne 0; then\n    with_libmodbus=\"no (pkg-config doesn't know libmodbus)\"\n  fi\nfi\n\nif test \"x$with_libmodbus\" = \"xuse_pkgconfig\"; then\n  with_libmodbus_cflags=\"`$PKG_CONFIG --cflags 'libmodbus'`\"\n  if test $? -ne 0; then\n    with_libmodbus=\"no ($PKG_CONFIG failed)\"\n  fi\n\n  with_libmodbus_libs=\"`$PKG_CONFIG --libs 'libmodbus'`\"\n  if test $? -ne 0; then\n    with_libmodbus=\"no ($PKG_CONFIG failed)\"\n  fi\nfi\n\nif test \"x$with_libmodbus\" = \"xuse_pkgconfig\"; then\n  with_libmodbus=\"yes\"\nfi\n\nif test \"x$with_libmodbus\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libmodbus_cflags\"\n\n  AC_CHECK_HEADERS([modbus.h],\n    [with_libmodbus=\"yes\"],\n    [with_libmodbus=\"no (modbus.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libmodbus\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libmodbus_libs\"\n\n  AC_CHECK_LIB([modbus], [modbus_connect],\n    [with_libmodbus=\"yes\"],\n    [with_libmodbus=\"no (symbol modbus_connect not found)\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libmodbus\" = \"xyes\"; then\n  BUILD_WITH_LIBMODBUS_CFLAGS=\"$with_libmodbus_cflags\"\n  BUILD_WITH_LIBMODBUS_LIBS=\"$with_libmodbus_libs\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBMODBUS_CFLAGS])\nAC_SUBST([BUILD_WITH_LIBMODBUS_LIBS])\n# }}}\n\n# --with-libmongoc {{{\nAC_ARG_WITH([libmongoc],\n  [AS_HELP_STRING([--with-libmongoc@<:@=PREFIX@:>@], [Path to libmongoc.])],\n  [\n    if test \"x$withval\" = \"xyes\"; then\n      with_libmongoc=\"yes\"\n    else if test \"x$withval\" = \"xno\"; then\n      with_libmongoc=\"no\"\n    else\n      with_libmongoc=\"no\"\n    fi; fi\n  ],\n  [with_libmongoc=\"yes\"]\n)\n\nif test \"x$with_libmongoc\" = \"xyes\"; then\n  PKG_CHECK_MODULES([LIBMONGOC], [libmongoc-1.0],\n    [with_libmongoc=\"yes\"],\n    [with_libmongoc=\"no (pkg-config could not find libmongoc)\"]\n  )\nfi\n\nif test \"x$with_libmongoc\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n\n  CPPFLAGS=\"$CPPFLAGS $LIBMONGOC_CFLAGS\"\n\n  AC_CHECK_HEADERS([mongoc.h],\n    [with_libmongoc=\"yes\"],\n    [with_libmongoc=\"no ('mongoc.h' not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libmongoc\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n\n  CPPFLAGS=\"$CPPFLAGS $LIBMONGOC_CFLAGS\"\n  LDFLAGS=\"$LDFLAGS $LIBMONGOC_LDFLAGS\"\n\n  AC_CHECK_LIB([mongoc-1.0], [mongoc_init],\n    [with_libmongoc=\"yes\"],\n    [with_libmongoc=\"no (symbol 'mongoc_init' not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libmongoc\" = \"xyes\"; then\n  BUILD_WITH_LIBMONGOC_CFLAGS=\"$LIBMONGOC_CFLAGS\"\n  BUILD_WITH_LIBMONGOC_LDFLAGS=\"$LIBMONGOC_LDFLAGS\"\n  BUILD_WITH_LIBMONGOC_LIBS=\"$LIBMONGOC_LIBS\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBMONGOC_CFLAGS])\nAC_SUBST([BUILD_WITH_LIBMONGOC_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBMONGOC_LIBS])\n# }}}\n\n# --with-libmosquitto {{{\nAC_ARG_WITH([libmosquitto],\n  [AS_HELP_STRING([--with-libmosquitto@<:@=PREFIX@:>@], [Path to libmosquitto.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_libmosquitto_cppflags=\"-I$withval/include\"\n      with_libmosquitto_ldflags=\"-L$withval/lib\"\n      with_libmosquitto=\"yes\"\n    else\n      with_libmosquitto=\"$withval\"\n    fi\n  ],\n  [with_libmosquitto=\"yes\"]\n)\n\nif test \"x$with_libmosquitto\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libmosquitto_cppflags\"\n\n  AC_CHECK_HEADERS([mosquitto.h],\n    [with_libmosquitto=\"yes\"],\n    [with_libmosquitto=\"no (mosquitto.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libmosquitto\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libmosquitto_ldflags\"\n\n  AC_CHECK_LIB([mosquitto], [mosquitto_connect],\n    [with_libmosquitto=\"yes\"],\n    [with_libmosquitto=\"no (libmosquitto not found)\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libmosquitto\" = \"xyes\"; then\n  BUILD_WITH_LIBMOSQUITTO_CPPFLAGS=\"$with_libmosquitto_cppflags\"\n  BUILD_WITH_LIBMOSQUITTO_LDFLAGS=\"$with_libmosquitto_ldflags\"\n  BUILD_WITH_LIBMOSQUITTO_LIBS=\"-lmosquitto\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBMOSQUITTO_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBMOSQUITTO_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBMOSQUITTO_LIBS])\n# }}}\n\n# --with-libmysql {{{\nwith_mysql_config=\"mysql_config\"\nAC_ARG_WITH([libmysql],\n  [AS_HELP_STRING([--with-libmysql@<:@=PREFIX@:>@], [Path to libmysql.])],\n  [\n    if test \"x$withval\" = \"xno\"; then\n      with_libmysql=\"no\"\n    else if test \"x$withval\" = \"xyes\"; then\n      with_libmysql=\"yes\"\n    else\n      if test -f \"$withval\" && test -x \"$withval\"; then\n        with_mysql_config=\"$withval\"\n      else if test -x \"$withval/bin/mysql_config\"; then\n        with_mysql_config=\"$withval/bin/mysql_config\"\n      fi; fi\n      with_libmysql=\"yes\"\n    fi; fi\n  ],\n  [with_libmysql=\"yes\"]\n)\n\nif test \"x$with_libmysql\" = \"xyes\"; then\n  with_mysql_cflags=`$with_mysql_config --include 2>/dev/null`\n  if test $? -ne 0; then\n    with_libmysql=\"no ($with_mysql_config failed)\"\n  else\n    SAVE_CPPFLAGS=\"$CPPFLAGS\"\n    CPPFLAGS=\"$CPPFLAGS $with_mysql_cflags\"\n\n    AC_CHECK_HEADERS([mysql.h],\n      [have_mysql_h=\"yes\"],\n      [have_mysql_h=\"no\"]\n    )\n\n    if test \"x$have_mysql_h\" != \"xyes\"; then\n      AC_CHECK_HEADERS([mysql/mysql.h],\n        [have_mysql_mysql_h=\"yes\"],\n        [],\n      )\n    fi\n\n    if test \"x$have_mysql_h\" != \"xyes\" && test \"x$have_mysql_mysql_h\" != \"xyes\"; then\n      with_libmysql=\"no (mysql.h not found)\"\n    fi\n\n    CPPFLAGS=\"$SAVE_CPPFLAGS\"\n  fi\nfi\n\nif test \"x$with_libmysql\" = \"xyes\"; then\n  with_mysql_libs=`$with_mysql_config --libs_r 2>/dev/null`\n  if test $? -ne 0; then\n    with_libmysql=\"no ($with_mysql_config failed)\"\n  else\n    SAVE_LIBS=\"$LIBS\"\n    LIBS=\"$with_mysql_libs\"\n\n    AC_SEARCH_LIBS([mysql_get_server_version],\n      [],\n      [with_libmysql=\"yes\"],\n      [with_libmysql=\"no (symbol 'mysql_get_server_version' not found in ${LIBS})\"],\n      []\n    )\n    LIBS=\"$SAVE_LIBS\"\n  fi\nfi\n\nif test \"x$with_libmysql\" = \"xyes\"; then\n  BUILD_WITH_LIBMYSQL_CFLAGS=\"$with_mysql_cflags\"\n  BUILD_WITH_LIBMYSQL_LIBS=\"$with_mysql_libs\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBMYSQL_CFLAGS])\nAC_SUBST([BUILD_WITH_LIBMYSQL_LIBS])\n# }}}\n\n# --with-libmnl {{{\nAC_ARG_WITH([libmnl],\n  [AS_HELP_STRING([--with-libmnl@<:@=PREFIX@:>@], [Path to libmnl.])],\n  [\n    if test \"x$withval\" = \"xyes\"; then\n      with_libmnl=\"yes\"\n     else if test \"x$withval\" = \"xno\"; then\n       with_libmnl=\"no\"\n     else\n       if test -d \"$withval/include\"; then\n         with_libmnl_cflags=\"-I$withval/include\"\n         with_libmnl_libs=\"-L$withval/lib -lmnl\"\n         with_libmnl=\"yes\"\n       else\n         AC_MSG_ERROR(\"no such directory: $withval/include\")\n       fi\n     fi; fi\n  ],\n  [\n    if test \"x$ac_system\" = \"xLinux\"; then\n      with_libmnl=\"yes\"\n    else\n      with_libmnl=\"no (Linux only library)\"\n    fi\n  ]\n)\n\nif test \"x$with_libmnl\" = \"xyes\"; then\n  if $PKG_CONFIG --exists libmnl 2>/dev/null; then\n    with_libmnl_cflags=\"$with_libmnl_ldflags `$PKG_CONFIG --cflags libmnl`\"\n    with_libmnl_libs=\"$with_libmnl_libs `$PKG_CONFIG --libs libmnl`\"\n  fi\n\n  AC_CHECK_HEADERS([libmnl.h libmnl/libmnl.h],\n    [\n      with_libmnl=\"yes\"\n      break\n    ],\n    [],\n    [[\n      #include <stdio.h>\n      #include <sys/types.h>\n      #include <asm/types.h>\n      #include <sys/socket.h>\n      #include <linux/netlink.h>\n      #include <linux/rtnetlink.h>]]\n  )\n\n  AC_CHECK_HEADERS([linux/gen_stats.h linux/pkt_sched.h],\n    [],\n    [],\n    [[\n      #include <stdio.h>\n      #include <sys/types.h>\n      #include <asm/types.h>\n      #include <sys/socket.h>\n    ]]\n  )\n\n  AC_COMPILE_IFELSE(\n    [\n      AC_LANG_PROGRAM(\n        [[\n          #include <stdio.h>\n          #include <sys/types.h>\n          #include <asm/types.h>\n          #include <sys/socket.h>\n          #include <linux/netlink.h>\n          #include <linux/rtnetlink.h>\n        ]],\n        [[\n          int retval = TCA_STATS2;\n          return retval;\n        ]]\n      )\n    ],\n    [AC_DEFINE([HAVE_TCA_STATS2], [1], [True if the enum-member TCA_STATS2 exists])]\n  )\n\n  AC_COMPILE_IFELSE(\n    [\n      AC_LANG_PROGRAM(\n        [[\n          #include <stdio.h>\n          #include <sys/types.h>\n          #include <asm/types.h>\n          #include <sys/socket.h>\n          #include <linux/netlink.h>\n          #include <linux/rtnetlink.h>\n        ]],\n        [[\n          int retval = TCA_STATS;\n          return retval;\n        ]]\n      )\n    ],\n    [AC_DEFINE([HAVE_TCA_STATS], 1, [True if the enum-member TCA_STATS exists])]\n  )\n\n  AC_CHECK_MEMBERS([struct rtnl_link_stats64.tx_window_errors],\n    [AC_DEFINE(HAVE_RTNL_LINK_STATS64, 1, [Define if struct rtnl_link_stats64 exists and is usable.])],\n    [],\n    [[#include <linux/if_link.h>]]\n  )\n\n  AC_CHECK_MEMBERS([struct rtnl_link_stats.rx_nohandler],\n    [],\n    [],\n    [[#include <linux/if_link.h>]]\n  )\n\n  AC_CHECK_MEMBERS([struct rtnl_link_stats64.rx_nohandler],\n    [],\n    [],\n    [[#include <linux/if_link.h>]]\n  )\n\n  AC_CHECK_LIB([mnl], [mnl_nlmsg_get_payload],\n    [with_libmnl=\"yes\"],\n    [with_libmnl=\"no (symbol 'mnl_nlmsg_get_payload' not found)\"],\n    [$with_libmnl_libs]\n  )\nfi\n\nif test \"x$with_libmnl\" = \"xyes\"; then\n  BUILD_WITH_LIBMNL_CFLAGS=\"$with_libmnl_cflags\"\n  BUILD_WITH_LIBMNL_LIBS=\"$with_libmnl_libs\"\nfi\nAC_SUBST([BUILD_WITH_LIBMNL_CFLAGS])\nAC_SUBST([BUILD_WITH_LIBMNL_LIBS])\nAM_CONDITIONAL([HAVE_LIBMNL], [test \"x$with_libmnl\" = \"xyes\"])\n# }}}\n\n# --with-libnetapp {{{\nAC_ARG_VAR([LIBNETAPP_CPPFLAGS], [C preprocessor flags required to build with libnetapp])\nAC_ARG_VAR([LIBNETAPP_LDFLAGS],  [Linker flags required to build with libnetapp])\nAC_ARG_VAR([LIBNETAPP_LIBS],     [Other libraries required to link against libnetapp])\nAC_ARG_WITH([libnetapp],\n  [AS_HELP_STRING([--with-libnetapp@<:@=PREFIX@:>@], [Path to libnetapp.])],\n  [\n   if test -d \"$withval\"; then\n     LIBNETAPP_CPPFLAGS=\"$LIBNETAPP_CPPFLAGS -I$withval/include\"\n     LIBNETAPP_LDFLAGS=\"$LIBNETAPP_LDFLAGS -L$withval/lib\"\n     with_libnetapp=\"yes\"\n   else\n     with_libnetapp=\"$withval\"\n   fi\n  ],\n  [with_libnetapp=\"yes\"]\n)\n\nSAVE_CPPFLAGS=\"$CPPFLAGS\"\nSAVE_LDFLAGS=\"$LDFLAGS\"\nCPPFLAGS=\"$CPPFLAGS $LIBNETAPP_CPPFLAGS\"\nLDFLAGS=\"$LDFLAGS $LIBNETAPP_LDFLAGS\"\n\nif test \"x$with_libnetapp\" = \"xyes\"; then\n  AC_CHECK_HEADERS([netapp_api.h],\n    [with_libnetapp=\"yes\"],\n    [with_libnetapp=\"no (netapp_api.h not found)\"]\n  )\nfi\n\nif test \"x$with_libnetapp\" = \"xyes\"; then\n  if test \"x$LIBNETAPP_LIBS\" = \"x\"; then\n    LIBNETAPP_LIBS=\"$PTHREAD_LIBS -lxml -ladt -lssl -lm -lcrypto -lz\"\n  fi\n\n  AC_CHECK_LIB([netapp], [na_server_invoke_elem],\n    [with_libnetapp=\"yes\"],\n    [with_libnetapp=\"no (symbol na_server_invoke_elem not found)\"],\n    [$LIBNETAPP_LIBS]\n  )\n\n  LIBNETAPP_LIBS=\"-lnetapp $LIBNETAPP_LIBS\"\nfi\n\nCPPFLAGS=\"$SAVE_CPPFLAGS\"\nLDFLAGS=\"$SAVE_LDFLAGS\"\n\nAC_SUBST([LIBNETAPP_CPPFLAGS])\nAC_SUBST([LIBNETAPP_LDFLAGS])\nAC_SUBST([LIBNETAPP_LIBS])\n# }}}\n\n# --with-libnetsnmp {{{\nAC_ARG_WITH([libnetsnmp],\n  [AS_HELP_STRING([--with-libnetsnmp@<:@=PREFIX@:>@], [Path to libnetsnmp.])],\n  [\n    if test \"x$withval\" = \"xno\"; then\n     with_libnetsnmp=\"no\"\n    else if test \"x$withval\" = \"xyes\"; then\n     with_libnetsnmp=\"yes\"\n    else\n      with_libnetsnmp_cppflags=\"-I$withval/include\"\n      with_libnetsnmp_ldflags=\"-I$withval/lib\"\n      with_libnetsnmp=\"yes\"\n    fi; fi\n  ],\n  [with_libnetsnmp=\"yes\"]\n)\n\nif test \"x$with_libnetsnmp\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libnetsnmp_cppflags\"\n\n  AC_CHECK_HEADERS([net-snmp/net-snmp-config.h],\n    [with_libnetsnmp=\"yes\"],\n    [with_libnetsnmp=\"no (net-snmp/net-snmp-config.h not found)\"]\n  )\n\n  AC_CHECK_HEADERS([net-snmp/net-snmp-includes.h],\n    [with_libnetsnmp=\"yes\"],\n    [with_libnetsnmp=\"no (net-snmp/net-snmp-includes.h not found)\"],\n    [[\n      #if HAVE_NET_SNMP_NET_SNMP_CONFIG_H\n      # include <net-snmp/net-snmp-config.h>\n      #endif\n    ]]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libnetsnmp\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libnetsnmp_ldflags\"\n\n  AC_CHECK_LIB([netsnmp], [init_snmp],\n    [with_libnetsnmp=\"yes\"],\n    [with_libnetsnmp=\"no (libnetsnmp not found)\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libnetsnmp\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libnetsnmp_ldflags\"\n\n  AC_CHECK_LIB([netsnmp], [netsnmp_get_version],\n    [with_libnetsnmp=\"yes\"],\n    [with_libnetsnmp=\"no (couldn't get libnetsnmp version)\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libnetsnmp\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  SAVE_LIBS=\"$LIBS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libnetsnmp_cppflags\"\n  if test \"x$GCC\" = \"xyes\"; then\n    CPPFLAGS=\"$CPPFLAGS -Wall -Werror\"\n  fi\n  LDFLAGS=\"$LDFLAGS $with_libnetsnmp_ldflags\"\n  LIBS=\"$LIBS -lnetsnmp\"\n\n  AC_CACHE_CHECK([whether netsnmp library has old API],\n    [c_cv_have_netsnmp_old_api],\n    [\n      AC_LINK_IFELSE(\n        [\n          AC_LANG_PROGRAM(\n            [[\n              #include <net-snmp/net-snmp-config.h>\n              #include <net-snmp/net-snmp-includes.h>\n            ]],\n            [[\n              netsnmp_variable_list *key = SNMP_MALLOC_TYPEDEF(netsnmp_variable_list);;\n              int val;\n              u_char type = ASN_INTEGER;\n              snmp_set_var_value(key, &val, sizeof(val));\n              snmp_set_var_typed_value(key, type, &val, sizeof(val));\n              return 0;\n            ]]\n          )\n        ],\n        [c_cv_have_netsnmp_old_api=\"no\"],\n        [c_cv_have_netsnmp_old_api=\"yes\"]\n      )\n    ]\n  )\n\n  if test \"x$c_cv_have_netsnmp_old_api\" = \"xyes\"; then\n    AC_DEFINE([HAVE_NETSNMP_OLD_API], [1],\n              [\"Define 1 if you have old netsnmp API]\")\n  fi\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\n  LDFLAGS=\"$SAVE_LDFLAGS\"\n  LIBS=\"$SAVE_LIBS\"\nfi\n\nif test \"x$with_libnetsnmp\" = \"xyes\"; then\n  BUILD_WITH_LIBNETSNMP_CPPFLAGS=\"$with_libnetsnmp_cppflags\"\n  BUILD_WITH_LIBNETSNMP_LDFLAGS=\"$with_libnetsnmp_ldflags\"\n  BUILD_WITH_LIBNETSNMP_LIBS=\"-lnetsnmp\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBNETSNMP_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBNETSNMP_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBNETSNMP_LIBS])\n# }}}\n\n# --with-libnetsnmpagent {{{\nAC_ARG_WITH([libnetsnmpagent],\n  [AS_HELP_STRING([--with-libnetsnmpagent@<:@=PREFIX@:>@], [Path to libnetsnmpagent.])],\n  [\n    if test \"x$withval\" = \"xno\"; then\n      with_libnetsnmpagent=\"no\"\n    else if test \"x$withval\" = \"xyes\"; then\n      with_libnetsnmpagent=\"yes\"\n    else\n      with_libnetsnmpagent_cppflags=\"-I$withval/include\"\n      with_libnetsnmpagent_ldflags=\"-I$withval/lib\"\n      with_libnetsnmpagent=\"yes\"\n    fi; fi\n  ],\n  [with_libnetsnmpagent=\"yes\"]\n)\n\nif test \"x$with_libnetsnmpagent\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libnetsnmpagent_cppflags\"\n\n  AC_CHECK_HEADERS([net-snmp/agent/net-snmp-agent-includes.h],\n    [],\n    [with_libnetsnmpagent=\"no (net-snmp/agent/net-snmp-agent-includes.h not found)\"],\n    [[\n      #if HAVE_NET_SNMP_NET_SNMP_CONFIG_H\n      # include <net-snmp/net-snmp-config.h>\n      #endif\n      #if HAVE_NET_SNMP_NET_SNMP_INCLUDES_H\n      # include <net-snmp/net-snmp-includes.h>\n      #endif\n    ]]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libnetsnmpagent\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libnetsnmpagent_ldflags\"\n\n  # older versions of libnetsnmpagent fail to link\n  # against the helpers library, so do that explicitly\n  AC_CHECK_LIB([netsnmphelpers], [netsnmp_init_helpers],\n    [libnetsnmphelpers=\"-lnetsnmphelpers\"],\n    [libnetsnmphelpers=\"\"]\n  )\n\n  AC_CHECK_LIB([netsnmpagent], [init_agent],\n    [\n      # libnetsnmp can be built without mib loading support\n      AC_CHECK_LIB([netsnmp], [get_tree],\n        [with_libnetsnmpagent=\"yes\"],\n        [with_libnetsnmpagent=\"no (libnetsnmp doesn't support mib loading)\"]\n      )\n    ],\n    [with_libnetsnmpagent=\"no (libnetsnmpagent not found)\"],\n    [$libnetsnmphelpers]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libnetsnmpagent\" = \"xyes\"; then\n  BUILD_WITH_LIBNETSNMPAGENT_CPPFLAGS=\"$with_libnetsnmpagent_cppflags\"\n  BUILD_WITH_LIBNETSNMPAGENT_LDFLAGS=\"$with_libnetsnmpagent_ldflags\"\n  BUILD_WITH_LIBNETSNMPAGENT_LIBS=\"-lnetsnmpagent $libnetsnmphelpers\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBNETSNMPAGENT_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBNETSNMPAGENT_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBNETSNMPAGENT_LIBS])\n# }}}\n\n# --with-liboping {{{\nAC_ARG_WITH([liboping],\n  [AS_HELP_STRING([--with-liboping@<:@=PREFIX@:>@], [Path to liboping.])],\n  [\n    if test \"x$withval\" = \"xyes\"; then\n      with_liboping=\"yes\"\n    else if test \"x$withval\" = \"xno\"; then\n      with_liboping=\"no\"\n    else\n      with_liboping=\"yes\"\n      LIBOPING_CPPFLAGS=\"-I$withval/include\"\n      LIBOPING_LDFLAGS=\"-L$withval/lib\"\n    fi; fi\n  ],\n  [with_liboping=\"yes\"]\n)\n\nSAVE_CPPFLAGS=\"$CPPFLAGS\"\nSAVE_LDFLAGS=\"$LDFLAGS\"\nCPPFLAGS=\"$CPPFLAGS $LIBOPING_CPPFLAGS\"\nLDFLAGS=\"$LDFLAGS $LIBOPING_LDFLAGS\"\n\nif test \"x$with_liboping\" = \"xyes\"; then\n  AC_CHECK_HEADERS([oping.h],\n    [with_liboping=\"yes\"],\n    [with_liboping=\"no (oping.h not found)\"]\n  )\nfi\n\nif test \"x$with_liboping\" = \"xyes\"; then\n  AC_CHECK_LIB([oping], [ping_construct],\n    [with_liboping=\"yes\"],\n    [with_liboping=\"no (symbol 'ping_construct' not found)\"]\n  )\nfi\n\nCPPFLAGS=\"$SAVE_CPPFLAGS\"\nLDFLAGS=\"$SAVE_LDFLAGS\"\n\nif test \"x$with_liboping\" = \"xyes\"; then\n  BUILD_WITH_LIBOPING_CPPFLAGS=\"$LIBOPING_CPPFLAGS\"\n  BUILD_WITH_LIBOPING_LDFLAGS=\"$LIBOPING_LDFLAGS\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBOPING_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBOPING_LDFLAGS])\n# }}}\n\n# --with-oracle {{{\nAC_ARG_WITH([oracle],\n  [AS_HELP_STRING([--with-oracle@<:@=ORACLE_HOME@:>@], [Path to Oracle.])],\n  [\n    if test \"x$withval\" = \"xyes\"; then\n      if test \"x$ORACLE_HOME\" = \"x\"; then\n        AC_MSG_WARN([Use of the Oracle library has been forced, but the environment variable ORACLE_HOME is not set.])\n      fi\n      with_oracle=\"yes\"\n    else if test \"x$withval\" = \"xno\"; then\n      with_oracle=\"no\"\n    else\n      with_oracle=\"yes\"\n      ORACLE_HOME=\"$withval\"\n    fi; fi\n  ],\n  [\n    if test \"x$ORACLE_HOME\" = \"x\"; then\n      with_oracle=\"no (ORACLE_HOME is not set)\"\n    else\n      with_oracle=\"yes\"\n    fi\n  ]\n)\n\nif test \"x$ORACLE_HOME\" != \"x\"; then\n  with_oracle_cppflags=\"-I$ORACLE_HOME/rdbms/public\"\n  if test -e \"$ORACLE_HOME/lib/ldflags\"; then\n    with_oracle_libs=`cat \"$ORACLE_HOME/lib/ldflags\"`\n  fi\n  with_oracle_libs=\"-L$ORACLE_HOME/lib -lclntsh\"\nfi\n\nif test \"x$with_oracle\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_oracle_cppflags\"\n\n  AC_CHECK_HEADERS([oci.h],\n    [with_oracle=\"yes\"],\n    [with_oracle=\"no (oci.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_oracle\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  SAVE_LIBS=\"$LIBS\"\n  CPPFLAGS=\"$CPPFLAGS $with_oracle_cppflags\"\n  LIBS=\"$LIBS $with_oracle_libs\"\n\n  AC_CHECK_FUNC([OCIEnvCreate],\n    [with_oracle=\"yes\"],\n    [with_oracle=\"no (Symbol 'OCIEnvCreate' not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\n  LIBS=\"$SAVE_LIBS\"\nfi\n\nif test \"x$with_oracle\" = \"xyes\"; then\n  BUILD_WITH_ORACLE_CPPFLAGS=\"$with_oracle_cppflags\"\n  BUILD_WITH_ORACLE_LIBS=\"$with_oracle_libs\"\nfi\n\nAC_SUBST([BUILD_WITH_ORACLE_CPPFLAGS])\nAC_SUBST([BUILD_WITH_ORACLE_LIBS])\n# }}}\n\n# --with-libowcapi {{{\nAC_ARG_WITH([libowcapi],\n  [AS_HELP_STRING([--with-libowcapi@<:@=PREFIX@:>@], [Path to libowcapi.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_libowcapi_cppflags=\"-I$withval/include\"\n      with_libowcapi_ldflags=\"-L$withval/lib\"\n      with_libowcapi=\"yes\"\n    else\n      with_libowcapi=\"$withval\"\n    fi\n  ],\n  [with_libowcapi=\"yes\"]\n)\n\nif test \"x$with_libowcapi\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libowcapi_cppflags\"\n\n  AC_CHECK_HEADERS([owcapi.h],\n    [with_libowcapi=\"yes\"],\n    [with_libowcapi=\"no (owcapi.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libowcapi\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libowcapi_ldflags\"\n\n  AC_CHECK_LIB([owcapi], [OW_get],\n    [with_libowcapi=\"yes\"],\n    [with_libowcapi=\"no (libowcapi not found)\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libowcapi\" = \"xyes\"; then\n  BUILD_WITH_LIBOWCAPI_CPPFLAGS=\"$with_libowcapi_cppflags\"\n  BUILD_WITH_LIBOWCAPI_LDFLAGS=\"$with_libowcapi_ldflags\"\n  BUILD_WITH_LIBOWCAPI_LIBS=\"-lowcapi\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBOWCAPI_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBOWCAPI_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBOWCAPI_LIBS])\n# }}}\n\n# --with-libpcap {{{\nAC_ARG_WITH([libpcap],\n  [AS_HELP_STRING([--with-libpcap@<:@=PREFIX@:>@], [Path to libpcap.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_libpcap_cppflags=\"-I$withval/include\"\n      with_libpcap_ldflags=\"$LDFLAGS -L$withval/lib\"\n      with_libpcap=\"yes\"\n    else\n      with_libpcap=\"$withval\"\n    fi\n  ],\n  [with_libpcap=\"yes\"]\n)\n\nif test \"x$with_libpcap\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libpcap_cppflags\"\n\n  AC_CHECK_HEADERS([pcap.h],\n    [with_libpcap=\"yes\"],\n    [with_libpcap=\"no (pcap.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libpcap\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libpcap_ldflags\"\n\n  AC_CHECK_LIB([pcap], [pcap_open_live],\n    [with_libpcap=\"yes\"],\n    [with_libpcap=\"no (libpcap not found)\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libpcap\" = \"xyes\"; then\n  AC_CACHE_CHECK([whether libpcap has PCAP_ERROR_IFACE_NOT_UP],\n    [c_cv_libpcap_have_pcap_error_iface_not_up],\n    [\n      AC_COMPILE_IFELSE(\n        [\n          AC_LANG_PROGRAM(\n            [[#include <pcap.h>]],\n            [[\n              int val = PCAP_ERROR_IFACE_NOT_UP;\n              return val;\n            ]]\n          )\n        ],\n        [c_cv_libpcap_have_pcap_error_iface_not_up=\"yes\"],\n        [c_cv_libpcap_have_pcap_error_iface_not_up=\"no\"]\n      )\n    ]\n  )\nfi\n\nif test \"x$c_cv_libpcap_have_pcap_error_iface_not_up\" != \"xyes\"; then\n  with_libpcap=\"no (pcap.h misses PCAP_ERROR_IFACE_NOT_UP)\"\nfi\n\nif test \"x$with_libpcap\" = \"xyes\"; then\n  BUILD_WITH_LIBPCAP_CPPFLAGS=\"$with_libpcap_cppflags\"\n  BUILD_WITH_LIBPCAP_LDFLAGS=\"$with_libpcap_ldflags\"\n  BUILD_WITH_LIBPCAP_LIBS=\"-lpcap\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBPCAP_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBPCAP_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBPCAP_LIBS])\n# }}}\n\n# --with-libperl {{{\nAC_ARG_WITH([libperl],\n  [AS_HELP_STRING([--with-libperl@<:@=PREFIX@:>@], [Path to libperl.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      LDFLAGS=\"$LDFLAGS -L$withval/lib\"\n      CPPFLAGS=\"$CPPFLAGS -I$withval/include\"\n      with_libperl=\"yes\"\n    else\n      with_libperl=\"$withval\"\n    fi\n  ],\n  [with_libperl=\"yes\"]\n)\n\nAC_ARG_VAR([PERL], [path to Perl interpreter])\nAC_PATH_PROG([PERL], [perl])\n\nif test \"x$PERL\" = \"x\"; then\n  with_libperl=\"no (no Perl interpreter found)\"\nfi\n\nif test \"x$with_libperl\" = \"xyes\"; then\n  SAVE_CFLAGS=\"$CFLAGS\"\n  SAVE_LIBS=\"$LIBS\"\n  dnl ARCHFLAGS=\"\" -> disable multi -arch on OSX (see Config_heavy.pl:fetch_string)\n  PERL_CFLAGS=`ARCHFLAGS=\"\" $PERL -MExtUtils::Embed -e perl_inc`\n  PERL_LIBS=`ARCHFLAGS=\"\" $PERL -MExtUtils::Embed -e ldopts`\n  CFLAGS=\"$CFLAGS $PERL_CFLAGS\"\n  LIBS=\"$LIBS $PERL_LIBS\"\n\n  AC_CACHE_CHECK([for libperl],\n    [c_cv_have_libperl],\n    [\n      AC_LINK_IFELSE(\n        [\n          AC_LANG_PROGRAM(\n            [[\n              #define PERL_NO_GET_CONTEXT\n              #include <EXTERN.h>\n              #include <perl.h>\n              #include <XSUB.h>\n            ]],\n            [[\n              dTHX;\n              load_module (PERL_LOADMOD_NOIMPORT,\n                newSVpv (\"Collectd::Plugin::FooBar\", 24),\n                Nullsv);\n            ]]\n          )\n        ],\n        [c_cv_have_libperl=\"yes\"],\n        [c_cv_have_libperl=\"no\"]\n      )\n    ]\n  )\n\n  CFLAGS=\"$SAVE_CFLAGS\"\n  LIBS=\"$SAVE_LIBS\"\n\n  if test \"x$c_cv_have_libperl\" = \"xno\"; then\n    with_libperl=\"no\"\n  fi\nfi\n\nif test \"x$with_libperl\" = \"xyes\"; then\n  SAVE_CFLAGS=\"$CFLAGS\"\n  SAVE_LIBS=\"$LIBS\"\n  CFLAGS=\"$CFLAGS $PERL_CFLAGS\"\n  LIBS=\"$LIBS $PERL_LIBS\"\n\n  AC_CACHE_CHECK([if Perl supports ithreads],\n    [c_cv_have_perl_ithreads],\n    [\n      AC_LINK_IFELSE(\n        [\n          AC_LANG_PROGRAM(\n            [[\n              #include <EXTERN.h>\n              #include <perl.h>\n              #include <XSUB.h>\n\n              #if !defined(USE_ITHREADS)\n              # error \"Perl does not support ithreads!\"\n              #endif /* !defined(USE_ITHREADS) */\n            ]],\n            []\n          )\n        ],\n        [c_cv_have_perl_ithreads=\"yes\"],\n        [c_cv_have_perl_ithreads=\"no\"]\n      )\n    ]\n  )\n\n  CFLAGS=\"$SAVE_CFLAGS\"\n  LIBS=\"$SAVE_LIBS\"\nfi\n\nif test \"x$with_libperl\" = \"xyes\"; then\n  # trigger an error if Perl_load_module*() uses __attribute__nonnull__(3)\n  # (see issues #41 and #42)\n  SAVE_CFLAGS=\"$CFLAGS\"\n  SAVE_LIBS=\"$LIBS\"\n  CFLAGS=\"$CFLAGS $PERL_CFLAGS\"\n  if test \"x$GCC\" = \"xyes\"; then\n    CFLAGS=\"$CFLAGS -Wall -Werror\"\n  fi\n  LIBS=\"$LIBS $PERL_LIBS\"\n\n  AC_CACHE_CHECK([for broken Perl_load_module()],\n    [c_cv_have_broken_perl_load_module],\n    [\n      AC_LINK_IFELSE(\n        [\n          AC_LANG_PROGRAM(\n            [[\n              #define PERL_NO_GET_CONTEXT\n              #include <EXTERN.h>\n              #include <perl.h>\n              #include <XSUB.h>\n            ]],\n            [[\n              dTHX;\n              load_module (PERL_LOADMOD_NOIMPORT,\n                newSVpv (\"Collectd::Plugin::FooBar\", 24),\n                Nullsv);\n            ]]\n          )\n        ],\n        [c_cv_have_broken_perl_load_module=\"no\"],\n        [c_cv_have_broken_perl_load_module=\"yes\"]\n      )\n    ]\n  )\n\n  CFLAGS=\"$SAVE_CFLAGS\"\n  LIBS=\"$SAVE_LIBS\"\nfi\n\nif test \"x$c_cv_have_broken_perl_load_module\" = \"xyes\"; then\n  PERL_CFLAGS=\"$PERL_CFLAGS -Wno-nonnull\"\nfi\n\nif test \"x$with_libperl\" = \"xyes\"; then\n  SAVE_CFLAGS=\"$CFLAGS\"\n  SAVE_LIBS=\"$LIBS\"\n  CFLAGS=\"$CFLAGS $PERL_CFLAGS\"\n  LIBS=\"$LIBS $PERL_LIBS\"\n\n  AC_CHECK_MEMBER(\n    [struct mgvtbl.svt_local],\n    [have_struct_mgvtbl_svt_local=\"yes\"],\n    [have_struct_mgvtbl_svt_local=\"no\"],\n    [[\n      #include <EXTERN.h>\n      #include <perl.h>\n      #include <XSUB.h>\n    ]]\n  )\n\n  if test \"x$have_struct_mgvtbl_svt_local\" = \"xyes\"; then\n    AC_DEFINE([HAVE_PERL_STRUCT_MGVTBL_SVT_LOCAL], [1], [Define if Perls struct mgvtbl has member svt_local.])\n  fi\n\n  CFLAGS=\"$SAVE_CFLAGS\"\n  LIBS=\"$SAVE_LIBS\"\nfi\nAC_SUBST([PERL_CFLAGS])\nAC_SUBST([PERL_LIBS])\n\n# }}}\n\n# --with-libpq {{{\nwith_pg_config=\"pg_config\"\nAC_ARG_WITH([libpq],\n  [AS_HELP_STRING([--with-libpq@<:@=PREFIX@:>@], [Path to libpq.])],\n  [\n    if test \"x$withval\" = \"xno\" || test \"x$withval\" = \"xyes\"; then\n      with_libpq=\"$withval\"\n    else\n      if test -f \"$withval\" && test -x \"$withval\"; then\n        with_pg_config=\"$withval\"\n      else if test -x \"$withval/bin/pg_config\"; then\n        with_pg_config=\"$withval/bin/pg_config\"\n      fi; fi\n      with_libpq=\"yes\"\n    fi\n  ],\n  [with_libpq=\"yes\"]\n)\n\nif test \"x$with_libpq\" = \"xyes\"; then\n  with_libpq_includedir=`$with_pg_config --includedir 2> /dev/null`\n  pg_config_status=$?\n\n  if test $pg_config_status -eq 0; then\n    if test -n \"$with_libpq_includedir\"; then\n      for dir in $with_libpq_includedir; do\n        with_libpq_cppflags=\"$with_libpq_cppflags -I$dir\"\n      done\n    fi\n  else\n    AC_MSG_WARN([$with_pg_config returned with status $pg_config_status])\n  fi\n\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libpq_cppflags\"\n\n  AC_CHECK_HEADERS([libpq-fe.h],\n    [with_libpq=\"yes\"],\n    [with_libpq=\"no (libpq-fe.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libpq\" = \"xyes\"; then\n  with_libpq_libdir=`$with_pg_config --libdir 2> /dev/null`\n  pg_config_status=$?\n\n  if test $pg_config_status -eq 0\n  then\n    if test -n \"$with_libpq_libdir\"; then\n      for dir in $with_libpq_libdir; do\n        with_libpq_ldflags=\"$with_libpq_ldflags -L$dir\"\n      done\n    fi\n  else\n    AC_MSG_WARN([$with_pg_config returned with status $pg_config_status])\n  fi\n\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libpq_ldflags\"\n\n  AC_CHECK_LIB([pq], [PQserverVersion],\n    [with_libpq=\"yes\"],\n    [with_libpq=\"no (symbol 'PQserverVersion' not found)\"])\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libpq\" = \"xyes\"; then\n  BUILD_WITH_LIBPQ_CPPFLAGS=\"$with_libpq_cppflags\"\n  BUILD_WITH_LIBPQ_LDFLAGS=\"$with_libpq_ldflags\"\n  BUILD_WITH_LIBPQ_LIBS=\"-lpq\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBPQ_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBPQ_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBPQ_LIBS])\n# }}}\n\n# --with-libpqos {{{\nAC_ARG_WITH([libpqos],\n  [AS_HELP_STRING([--with-libpqos@<:@=PREFIX@:>@], [Path to libpqos.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_libpqos_cppflags=\"-I$withval/include\"\n      with_libpqos_ldflags=\"-L$withval/lib\"\n      with_libpqos=\"yes\"\n    else\n      with_libpqos=\"$withval\"\n    fi\n  ],\n  [with_libpqos=\"yes\"]\n)\n\nif test \"x$with_libpqos\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libpqos_cppflags\"\n\n  AC_CHECK_HEADERS([pqos.h],\n    [with_libpqos=\"yes\"],\n    [with_libpqos=\"no (pqos.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libpqos\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libpqos_ldflags\"\n\n  AC_CHECK_LIB([pqos], [pqos_init],\n    [with_libpqos=\"yes\"],\n    [with_libpqos=\"no (Can't find libpqos)\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libpqos\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libpqos_cppflags\"\n  AC_PREPROC_IFELSE(\n    [\n      AC_LANG_SOURCE(\n        [[\n          #include <pqos.h>\n          #if PQOS_VERSION < 106\n          #error \"required PQOS version >= 1.06\"\n          #endif\n        ]]\n      )\n    ],\n    [with_libpqos=\"yes\"],\n    [with_libpqos=\"no (pqos library version 1.06 or higher is required)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libpqos\" = \"xyes\"; then\n  BUILD_WITH_LIBPQOS_CPPFLAGS=\"$with_libpqos_cppflags\"\n  BUILD_WITH_LIBPQOS_LDFLAGS=\"$with_libpqos_ldflags\"\n  BUILD_WITH_LIBPQOS_LIBS=\"-lpqos\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBPQOS_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBPQOS_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBPQOS_LIBS])\n# }}}\n\n# --with-libjevents {{{\nwith_libjevents_cppflags=\"\"\nwith_libjevents_ldflags=\"\"\nAC_ARG_WITH([libjevents],\n  [AS_HELP_STRING([--with-libjevents@<:@=PREFIX@:>@], [Path to libjevents.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_libjevents_cppflags=\"-I$withval/include\"\n      with_libjevents_ldflags=\"-L$withval/lib\"\n      with_libjevents=\"yes\"\n    else\n      with_libjevents=\"$withval\"\n    fi\n  ],\n  [with_libjevents=\"yes\"]\n)\n\nif test \"x$with_libjevents\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libjevents_cppflags\"\n\n  AC_CHECK_HEADERS([jevents.h], [with_libjevents=\"yes\"], [with_libjevents=\"no (jevents.h not found)\"])\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\nif test \"x$with_libjevents\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libjevents_ldflags\"\n\n  AC_CHECK_LIB([jevents], [json_events], [with_libjevents=\"yes\"], [with_libjevents=\"no (Can't find libjevents)\"])\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\nif test \"x$with_libjevents\" = \"xyes\"; then\n  BUILD_WITH_LIBJEVENTS_CPPFLAGS=\"$with_libjevents_cppflags\"\n  BUILD_WITH_LIBJEVENTS_LDFLAGS=\"$with_libjevents_ldflags\"\n  BUILD_WITH_LIBJEVENTS_LIBS=\"-ljevents\"\nfi\nAC_SUBST([BUILD_WITH_LIBJEVENTS_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBJEVENTS_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBJEVENTS_LIBS])\n# }}}\n\n# --with-libprotobuf {{{\nwith_libprotobuf_cppflags=\"\"\nwith_libprotobuf_ldflags=\"\"\nAC_ARG_WITH([libprotobuf],\n  [AS_HELP_STRING([--with-libprotobuf@<:@=PREFIX@:>@], [Path to libprotobuf.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_libprotobuf_cppflags=\"-I$withval/include\"\n      with_libprotobuf_ldflags=\"-L$withval/lib\"\n      with_libprotobuf=\"yes\"\n    fi\n    if test \"x$withval\" = \"xno\"; then\n      with_libprotobuf=\"no (disabled on command line)\"\n    fi\n  ],\n  [withval=\"yes\"]\n)\n\nif test \"x$withval\" = \"xyes\"; then\n  PKG_CHECK_MODULES([PROTOBUF], [protobuf],\n    [with_libprotobuf=\"yes\"],\n    [with_libprotobuf=\"no (pkg-config could not find libprotobuf)\"]\n  )\nfi\n\nif test \"x$withval\" != \"xno\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  SAVE_LIBS=\"$LIBS\"\n  LDFLAGS=\"$with_libprotobuf_ldflags\"\n  LIBS=\"$PROTOBUF_LIBS $LIBS\"\n  AC_LANG_PUSH([C++])\n  AC_CHECK_LIB([protobuf], [main],\n    [\n      SAVE_CPPFLAGS=\"$CPPFLAGS\"\n      CPPFLAGS=\"$with_libprotobuf_cppflags $PROTOBUF_CFLAGS\"\n      if test \"x$PROTOBUF_LIBS\" = \"x\"\n      then\n        PROTOBUF_LIBS=\"-lprotobuf\"\n      fi\n      AC_CHECK_HEADERS([google/protobuf/util/time_util.h],\n        [with_libprotobuf=\"yes\"],\n        [with_libprotobuf=\"no (<google/protobuf/util/time_util.h> not found)\"]\n      )\n      CPPFLAGS=\"$SAVE_CPPFLAGS\"\n    ],\n    [with_libprotobuf=\"no (libprotobuf not found)\"]\n  )\n  AC_LANG_POP([C++])\n  LDFLAGS=\"$SAVE_LDFLAGS\"\n  LIBS=\"$SAVE_LIBS\"\nfi\n\nBUILD_WITH_LIBPROTOBUF_CPPFLAGS=\"$with_libprotobuf_cppflags $PROTOBUF_CFLAGS\"\nBUILD_WITH_LIBPROTOBUF_LDFLAGS=\"$with_libprotobuf_ldflags\"\nBUILD_WITH_LIBPROTOBUF_LIBS=\"$PROTOBUF_LIBS\"\nAC_SUBST([BUILD_WITH_LIBPROTOBUF_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBPROTOBUF_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBPROTOBUF_LIBS])\n# }}}\n\nAC_ARG_VAR([PROTOC], [path to the protoc binary])\nAC_PATH_PROG([PROTOC], [protoc])\nhave_protoc3=\"no\"\nif test \"x$PROTOC\" != \"x\"; then\n  AC_MSG_CHECKING([for protoc 3.0.0+])\n  if $PROTOC --version | $EGREP libprotoc.3 >/dev/null; then\n    protoc3=\"yes (`$PROTOC --version`)\"\n    have_protoc3=\"yes\"\n  else\n    protoc3=\"no (`$PROTOC --version`)\"\n  fi\n  AC_MSG_RESULT([$protoc3])\nfi\nAM_CONDITIONAL([HAVE_PROTOC3], [test \"x$have_protoc3\" = \"xyes\"])\n\n# --with-libprotobuf-c {{{\nAC_ARG_WITH([libprotobuf-c],\n  [AS_HELP_STRING([--with-libprotobuf-c@<:@=PREFIX@:>@], [Path to libprotobuf-c.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_libprotobuf_c_cppflags=\"-I$withval/include\"\n      with_libprotobuf_c_ldflags=\"-L$withval/lib\"\n      with_libprotobuf_c=\"yes\"\n    fi\n\n    if test \"x$withval\" = \"xno\"; then\n      with_libprotobuf_c=\"no (disabled on command line)\"\n    fi\n  ],\n  [withval=\"yes\"]\n)\n\nif test \"x$withval\" = \"xyes\"; then\n  PKG_CHECK_MODULES([PROTOBUF_C], [libprotobuf-c],\n    [with_libprotobuf_c=\"yes\"],\n    [with_libprotobuf_c=\"no (pkg-config could not find libprotobuf-c)\"]\n  )\nfi\n\nif test \"x$withval\" != \"xno\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  SAVE_LIBS=\"$LIBS\"\n  LDFLAGS=\"$with_libprotobuf_c_ldflags\"\n  LIBS=\"$PROTOBUF_C_LIBS $LIBS\"\n  AC_CHECK_LIB([protobuf-c], [protobuf_c_message_pack],\n    [\n      SAVE_CPPFLAGS=\"$CPPFLAGS\"\n      CPPFLAGS=\"$with_libprotobuf_c_cppflags $PROTOBUF_C_CFLAGS\"\n      if test \"x$PROTOBUF_C_LIBS\" = \"x\"; then\n        PROTOBUF_C_LIBS=\"-lprotobuf-c\"\n      fi\n\n      AC_CHECK_HEADERS([protobuf-c/protobuf-c.h google/protobuf-c/protobuf-c.h],\n        [\n          with_libprotobuf_c=\"yes\"\n          break\n        ],\n        [with_libprotobuf_c=\"no (<protobuf-c.h> not found)\"]\n      )\n\n      CPPFLAGS=\"$SAVE_CPPFLAGS\"\n    ],\n    [with_libprotobuf_c=\"no (libprotobuf-c not found)\"]\n  )\n  LDFLAGS=\"$SAVE_LDFLAGS\"\n  LIBS=\"$SAVE_LIBS\"\nfi\n\nBUILD_WITH_LIBPROTOBUF_C_CPPFLAGS=\"$with_libprotobuf_c_cppflags $PROTOBUF_C_CFLAGS\"\nBUILD_WITH_LIBPROTOBUF_C_LDFLAGS=\"$with_libprotobuf_c_ldflags\"\nBUILD_WITH_LIBPROTOBUF_C_LIBS=\"$PROTOBUF_C_LIBS\"\nAC_SUBST([BUILD_WITH_LIBPROTOBUF_C_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBPROTOBUF_C_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBPROTOBUF_C_LIBS])\n# }}}\n\nAC_ARG_VAR([PROTOC_C], [path to the protoc-c binary])\nAC_PATH_PROG([PROTOC_C], [protoc-c])\nif test \"x$PROTOC_C\" = \"x\"\nthen\n  have_protoc_c=\"no (protoc-c compiler not found)\"\nelse\n  have_protoc_c=\"yes\"\nfi\n\n# --with-libpython {{{\nAC_ARG_VAR([LIBPYTHON_CPPFLAGS], [Preprocessor flags for libpython])\nAC_ARG_VAR([LIBPYTHON_LDFLAGS], [Linker flags for libpython])\nAC_ARG_VAR([LIBPYTHON_LIBS], [Libraries for libpython])\n\nAC_ARG_WITH([libpython],\n  [AS_HELP_STRING([--with-libpython], [if we should build with libpython @<:@default=yes@:>@])],\n  [with_libpython=\"$withval\"],\n  [with_libpython=\"check\"]\n)\n\nif test \"$with_libpython\" != \"no\"; then\n  if test \"$LIBPYTHON_CPPFLAGS\" = \"\" && test \"$LIBPYTHON_LDFLAGS\" = \"\"; then\n    AC_ARG_VAR([PYTHON_CONFIG], [path to python-config])\n    AC_PATH_PROGS([PYTHON_CONFIG],\n      [python3-config python2-config python-config]\n    )\n    if test \"$PYTHON_CONFIG\" = \"\"; then\n      if test \"$with_libpython\" = \"yes\"; then\n        AC_MSG_ERROR([Unable to find python-config])\n      fi\n      with_libpython=\"no\"\n    fi\n  fi\nfi\n\nif test \"$PYTHON_CONFIG\" != \"\"; then\n  LIBPYTHON_CPPFLAGS=\"`${PYTHON_CONFIG} --includes`\"\n  if test $? -ne 0; then\n    with_libpython=\"no\"\n  fi\n  LIBPYTHON_LDFLAGS=\"`${PYTHON_CONFIG} --ldflags`\"\n  if test $? -ne 0; then\n    with_libpython=\"no\"\n  fi\n  LIBPYTHON_LIBS=\"`${PYTHON_CONFIG} --libs --embed`\" || LIBPYTHON_LIBS=\"`${PYTHON_CONFIG} --libs`\"\n  if test $? -ne 0; then\n    with_libpython=\"no\"\n  fi\nfi\n\nif test \"$with_libpython\" != \"xno\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  SAVE_LIBS=\"$LIBS\"\n  CPPFLAGS=\"$LIBPYTHON_CPPFLAGS $CPPFLAGS\"\n  LDFLAGS=\"$LIBPYTHON_LDFLAGS $LDFLAGS\"\n  LIBS=\"$LIBPYTHON_LIBS $LIBS\"\n\n  AC_CHECK_HEADERS([Python.h],\n    [\n      AC_MSG_CHECKING([for libpython])\n      AC_LINK_IFELSE([AC_LANG_PROGRAM(\n          [[#include <Python.h>]],\n          [[Py_Initialize();]])\n        ],\n        [with_libpython=\"yes\"],\n        [with_libpython=\"no\"]\n      )\n      AC_MSG_RESULT([$with_libpython])\n    ],\n    [with_libpython=\"no\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\n  LDFLAGS=\"$SAVE_LDFLAGS\"\n  LIBS=\"$SAVE_LIBS\"\nfi\n# }}} --with-libpython\n\n# --with-libqpid_proton {{{\nAC_ARG_WITH([libqpid_proton],\n  [AS_HELP_STRING([--with-libqpid_proton@<:@=PREFIX@:>@], [Path to libqpid_proton.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_libqpid_proton_cppflags=\"-I$withval/include\"\n      with_libqpid_proton_ldflags=\"-L$withval/lib\"\n      with_libqpid_proton=\"yes\"\n    else\n      with_libqpid_proton=\"$withval\"\n    fi\n  ],\n  [with_libqpid_proton=\"yes\"]\n)\n\nif test \"x$with_libqpid_proton\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libqpid_proton_cppflags\"\n\n  AC_CHECK_HEADERS([proton/proactor.h],\n    [with_libqpid_proton=\"yes\"],\n    [with_libqpid_proton=\"no (proton/proactor.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libqpid_proton\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libqpid_proton_ldflags\"\n\n  AC_CHECK_LIB([qpid-proton], [pn_connection],\n    [with_libqpid_proton=\"yes\"],\n    [with_libqpid_proton=\"no (Symbol 'pn_connection' not found)\"])\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libqpid_proton\" = \"xyes\"; then\n  BUILD_WITH_LIBQPIDPROTON_CPPFLAGS=\"$with_libqpid_proton_cppflags\"\n  BUILD_WITH_LIBQPIDPROTON_LDFLAGS=\"$with_libqpid_proton_ldflags\"\n  BUILD_WITH_LIBQPIDPROTON_LIBS=\"-lqpid-proton\"\nfi\n\nAC_SUBST(BUILD_WITH_LIBQPIDPROTON_CPPFLAGS)\nAC_SUBST(BUILD_WITH_LIBQPIDPROTON_LDFLAGS)\nAC_SUBST(BUILD_WITH_LIBQPIDPROTON_LIBS)\n\n# }}}\n\n# --with-librabbitmq {{{\nAC_ARG_WITH([librabbitmq],\n  [AS_HELP_STRING([--with-librabbitmq@<:@=PREFIX@:>@], [Path to librabbitmq.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_librabbitmq_cppflags=\"-I$withval/include\"\n      with_librabbitmq_ldflags=\"-L$withval/lib\"\n      with_librabbitmq=\"yes\"\n    else\n      with_librabbitmq=\"$withval\"\n    fi\n  ],\n  [with_librabbitmq=\"yes\"]\n)\n\nif test \"x$with_librabbitmq\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_librabbitmq_cppflags\"\n\n  AC_CHECK_HEADERS([amqp.h],\n    [with_librabbitmq=\"yes\"],\n    [with_librabbitmq=\"no (amqp.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_librabbitmq\" = \"xyes\"; then\n  # librabbitmq up to version 0.9.1 provides \"library_errno\", later\n  # versions use \"library_error\". The library does not provide a version\n  # macro :(.\n\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_librabbitmq_cppflags\"\n\n  AC_CHECK_MEMBERS([amqp_rpc_reply_t.library_errno],\n    [],\n    [],\n    [[\n      #include <stdlib.h>\n      #include <stdio.h>\n      #include <stdint.h>\n      #include <inttypes.h>\n      #include <amqp.h>\n    ]]\n  )\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\n\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_librabbitmq_ldflags\"\n\n  AC_CHECK_LIB([rabbitmq], [amqp_basic_publish],\n    [with_librabbitmq=\"yes\"],\n    [with_librabbitmq=\"no (Symbol 'amqp_basic_publish' not found)\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_librabbitmq\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  SAVE_LIBS=\"$LIBS\"\n  CPPFLAGS=\"$CPPFLAGS $with_librabbitmq_cppflags\"\n  LDFLAGS=\"$LDFLAGS $with_librabbitmq_ldflags\"\n  LIBS=\"-lrabbitmq\"\n\n  AC_CHECK_HEADERS([amqp_tcp_socket.h amqp_socket.h])\n  AC_CHECK_FUNC([amqp_tcp_socket_new],\n    [\n      AC_DEFINE([HAVE_AMQP_TCP_SOCKET], [1],\n        [Define if librabbitmq provides the new TCP socket interface.])\n    ]\n  )\n\n  AC_CHECK_DECLS([amqp_socket_close],\n    [],\n    [],\n    [[\n      #include <amqp.h>\n      #ifdef HAVE_AMQP_TCP_SOCKET_H\n      # include <amqp_tcp_socket.h>\n      #endif\n      #ifdef HAVE_AMQP_SOCKET_H\n      # include <amqp_socket.h>\n      #endif\n    ]]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\n  LDFLAGS=\"$SAVE_LDFLAGS\"\n  LIBS=\"$SAVE_LIBS\"\nfi\n\nif test \"x$with_librabbitmq\" = \"xyes\"; then\n  BUILD_WITH_LIBRABBITMQ_CPPFLAGS=\"$with_librabbitmq_cppflags\"\n  BUILD_WITH_LIBRABBITMQ_LDFLAGS=\"$with_librabbitmq_ldflags\"\n  BUILD_WITH_LIBRABBITMQ_LIBS=\"-lrabbitmq\"\nfi\n\nAC_SUBST(BUILD_WITH_LIBRABBITMQ_CPPFLAGS)\nAC_SUBST(BUILD_WITH_LIBRABBITMQ_LDFLAGS)\nAC_SUBST(BUILD_WITH_LIBRABBITMQ_LIBS)\n\n# }}}\n\n# --with-librdkafka {{{\nAC_ARG_WITH([librdkafka],\n  [AS_HELP_STRING([--with-librdkafka@<:@=PREFIX@:>@], [Path to librdkafka.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_librdkafka_cppflags=\"-I$withval/include\"\n      with_librdkafka_ldflags=\"-L$withval/lib\"\n      with_librdkafka_rpath=\"$withval/lib\"\n      with_librdkafka=\"yes\"\n    else\n      with_librdkafka=\"$withval\"\n    fi\n  ],\n  [with_librdkafka=\"yes\"]\n)\n\nif test \"x$with_librdkafka\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_librdkafka_cppflags\"\n\n  AC_CHECK_HEADERS([librdkafka/rdkafka.h],\n    [with_librdkafka=\"yes\"],\n    [with_librdkafka=\"no (librdkafka/rdkafka.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_librdkafka\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_librdkafka_ldflags\"\n\n  AC_CHECK_LIB([rdkafka], [rd_kafka_new],\n    [with_librdkafka=\"yes\"],\n    [with_librdkafka=\"no (Symbol 'rd_kafka_new' not found)\"])\n\n  AC_CHECK_LIB([rdkafka], [rd_kafka_conf_set_log_cb],\n    [with_librdkafka_log_cb=\"yes\"],\n    [with_librdkafka_log_cb=\"no\"])\n\n  AC_CHECK_LIB([rdkafka], [rd_kafka_set_logger],\n    [with_librdkafka_logger=\"yes\"],\n    [with_librdkafka_logger=\"no\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_librdkafka\" = \"xyes\"; then\n  BUILD_WITH_LIBRDKAFKA_CPPFLAGS=\"$with_librdkafka_cppflags\"\n  BUILD_WITH_LIBRDKAFKA_LDFLAGS=\"$with_librdkafka_ldflags\"\n\n  if test \"x$with_librdkafka_rpath\" != \"x\"; then\n    BUILD_WITH_LIBRDKAFKA_LIBS=\"-Wl,-rpath,$with_librdkafka_rpath -lrdkafka\"\n  else\n    BUILD_WITH_LIBRDKAFKA_LIBS=\"-lrdkafka\"\n  fi\n\n  if test \"x$with_librdkafka_log_cb\" = \"xyes\"; then\n    AC_DEFINE(HAVE_LIBRDKAFKA_LOG_CB, 1, [Define if librdkafka log facility is present and usable.])\n  else if test \"x$with_librdkafka_logger\" = \"xyes\"; then\n    AC_DEFINE(HAVE_LIBRDKAFKA_LOGGER, 1, [Define if librdkafka log facility is present and usable.])\n  fi; fi\nfi\n\nAC_SUBST([BUILD_WITH_LIBRDKAFKA_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBRDKAFKA_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBRDKAFKA_LIBS])\n# }}}\n\n# --with-librouteros {{{\nAC_ARG_WITH([librouteros],\n  [AS_HELP_STRING([--with-librouteros@<:@=PREFIX@:>@], [Path to librouteros.])],\n  [\n    if test \"x$withval\" = \"xyes\" || test \"x$withval\" = \"xno\"; then\n      with_librouteros=\"$witval\"\n    else\n      with_librouteros_cppflags=\"-I$withval/include\"\n      with_librouteros_ldflags=\"-L$withval/lib\"\n      with_librouteros=\"yes\"\n   fi\n  ],\n  [with_librouteros=\"yes\"]\n)\n\nif test \"x$with_librouteros\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_librouteros_cppflags\"\n\n  AC_CHECK_HEADERS([routeros_api.h],\n    [with_librouteros=\"yes\"],\n    [with_librouteros=\"no (routeros_api.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_librouteros\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_librouteros_ldflags\"\n\n  AC_CHECK_LIB([routeros], [ros_interface],\n    [with_librouteros=\"yes\"],\n    [with_librouteros=\"no (symbol 'ros_interface' not found)\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_librouteros\" = \"xyes\"; then\n  BUILD_WITH_LIBROUTEROS_CPPFLAGS=\"$with_librouteros_cppflags\"\n  BUILD_WITH_LIBROUTEROS_LDFLAGS=\"$with_librouteros_ldflags\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBROUTEROS_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBROUTEROS_LDFLAGS])\n# }}}\n\n# --with-librrd {{{\nlibrrd_threadsafe=\"no\"\nlibrrd_rrdc_update=\"no\"\nAC_ARG_WITH([librrd],\n  [AS_HELP_STRING([--with-librrd@<:@=PREFIX@:>@], [Path to rrdtool.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      librrd_cflags=\"-I$withval/include\"\n      librrd_ldflags=\"-L$withval/lib\"\n      with_librrd=\"yes\"\n    else\n      with_librrd=\"$withval\"\n    fi\n  ],\n  [with_librrd=\"yes\"]\n)\n\nif test \"x$with_librrd\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $librrd_ldflags\"\n  PKG_CHECK_MODULES([RRD], [librrd >= 1.6.0],\n    [\n      AC_CHECK_LIB([rrd], [rrd_update_r],\n        [librrd_threadsafe=\"yes\"],\n        [:]\n      )\n      AC_CHECK_LIB([rrd], [rrdc_update],\n        [librrd_rrdc_update=\"yes\"],\n        [:]\n      )\n    ],[:]\n  )\n  LDFLAGS=\"$SAVE_LDFLAGS\"\n\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $RRD_CFLAGS $librrd_cflags\"\n\n  AC_CHECK_HEADERS([rrd.h],, [with_librrd=\"no (rrd.h not found)\"])\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_librrd\" = \"xyes\" && test \"x$librrd_threadsafe\" = \"xno\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $librrd_ldflags\"\n\n  AC_CHECK_LIB([rrd_th], [rrd_update_r],\n    [\n      librrd_ldflags=\"$librrd_ldflags -lrrd_th\"\n      librrd_threadsafe=\"yes\"\n      AC_CHECK_LIB([rrd_th], [rrdc_update],\n        [librrd_rrdc_update=\"yes\"],\n        [:],\n      )\n    ],\n    [:]\n  )\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_librrd\" = \"xyes\" && test \"x$librrd_threadsafe\" = \"xno\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $librrd_ldflags\"\n\n  AC_CHECK_LIB([rrd], [rrd_update],\n    [\n      librrd_ldflags=\"$librrd_ldflags -lrrd\"\n      AC_CHECK_LIB([rrd], [rrdc_update],\n        [librrd_rrdc_update=\"yes\"],\n        [:]\n      )\n    ],\n    [with_librrd=\"no (symbol 'rrd_update' not found)\"]\n  )\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_librrd\" = \"xyes\"; then\n  BUILD_WITH_LIBRRD_CFLAGS=\"$RRD_CFLAGS $librrd_cflags\"\n  BUILD_WITH_LIBRRD_LDFLAGS=\"$librrd_ldflags\"\n  BUILD_WITH_LIBRRD_LIBS=\"$RRD_LIBS\"\nfi\n\nif test \"x$librrd_threadsafe\" = \"xyes\"; then\n  AC_DEFINE([HAVE_THREADSAFE_LIBRRD], [1],\n    [Define to 1 if the rrd library is thread-safe]\n  )\nfi\n\nAC_SUBST([BUILD_WITH_LIBRRD_CFLAGS])\nAC_SUBST([BUILD_WITH_LIBRRD_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBRRD_LIBS])\n# }}}\n\n# --with-libsensors {{{\nAC_ARG_WITH([libsensors],\n  [AS_HELP_STRING([--with-libsensors@<:@=PREFIX@:>@], [Path to lm_sensors.])],\n  [\n    if test \"x$withval\" = \"xno\" || test \"x$withval\" = \"xyes\"; then\n      with_libsensors=\"$withval\"\n    else\n      with_sensors_cppflags=\"-I$withval/include\"\n      with_sensors_ldflags=\"-L$withval/lib\"\n      with_libsensors=\"yes\"\n    fi\n  ],\n  [\n    if test \"x$ac_system\" = \"xLinux\"; then\n      with_libsensors=\"yes\"\n    else\n      with_libsensors=\"no (Linux only library)\"\n    fi\n  ]\n)\n\nif test \"x$with_libsensors\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_sensors_cppflags\"\n\n  AC_CHECK_HEADERS([sensors/sensors.h],\n    [with_libsensors=\"yes\"],\n    [with_libsensors=\"no (sensors/sensors.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libsensors\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_sensors_ldflags\"\n\n  AC_CHECK_LIB([sensors], [sensors_init],\n    [with_libsensors=\"yes\"],\n    [with_libsensors=\"no (libsensors not found)\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libsensors\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_sensors_cppflags\"\n  AC_PREPROC_IFELSE(\n    [\n      AC_LANG_SOURCE(\n        [[\n          #include <sensors/sensors.h>\n          #if SENSORS_API_VERSION < 0x400\n          #error \"required libsensors version >= 3.0\"\n          #endif\n        ]]\n      )\n    ],\n    [with_libsensors=\"yes\"],\n    [with_libsensors=\"no (sensors library version 3.0.0 or higher is required)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libsensors\" = \"xyes\"; then\n  BUILD_WITH_LIBSENSORS_CPPFLAGS=\"$with_sensors_cppflags\"\n  BUILD_WITH_LIBSENSORS_LDFLAGS=\"$with_sensors_ldflags\"\n  BUILD_WITH_LIBSENSORS_LIBS=\"-lsensors\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBSENSORS_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBSENSORS_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBSENSORS_LIBS])\n\n# }}}\n\n# libsigrok {{{\nAC_SUBST([LIBSIGROK_CFLAGS])\nAC_SUBST([LIBSIGROK_LIBS])\nPKG_CHECK_MODULES([LIBSIGROK], [libsigrok < 0.4],\n  [with_libsigrok=\"yes\"],\n  [with_libsigrok=\"no (pkg-config could not find libsigrok)\"]\n)\n# }}}\n\n# --with-libssl {{{\nwith_libssl_cflags=\"\"\nwith_libssl_ldflags=\"\"\nAC_ARG_WITH([libssl], [AS_HELP_STRING([--with-libssl@<:@=PREFIX@:>@], [Path to libssl.])],\n[\n\tif test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n\t\twith_libssl_cppflags=\"-I$withval/include\"\n\t\twith_libssl_ldflags=\"-L$withval/lib\"\n\t\twith_libssl=\"yes\"\n\telse\n\t\twith_libssl=\"$withval\"\n\tfi\n],\n[\n\twith_libssl=\"yes\"\n])\nif test \"x$with_libssl\" = \"xyes\"; then\n\tSAVE_CPPFLAGS=\"$CPPFLAGS\"\n\tCPPFLAGS=\"$CPPFLAGS $with_libssl_cppflags\"\n\n  AC_CHECK_HEADERS([openssl/sha.h openssl/blowfish.h openssl/rand.h],\n    [with_libssl=\"yes\"],\n    [with_libssl=\"no (ssl header not found)\"])\n\n\tCPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\nif test \"x$with_libssl\" = \"xyes\"; then\n\tSAVE_CPPFLAGS=\"$CPPFLAGS\"\n\tSAVE_LDFLAGS=\"$LDFLAGS\"\n\tCPPFLAGS=\"$CPPFLAGS $with_libssl_cppflags\"\n\tLDFLAGS=\"$LDFLAGS $with_libssl_ldflags\"\n\n\tAC_CHECK_LIB([ssl], [OPENSSL_init_ssl], [with_libssl=\"yes\"], [with_libssl=\"no (Symbol 'SSL_library_init' not found)\"])\n\n\tCPPFLAGS=\"$SAVE_CPPFLAGS\"\n\tLDFLAGS=\"$SAVE_LDFLAGS\"\nfi\nif test \"x$with_libssl\" = \"xyes\"; then\n\tBUILD_WITH_LIBSSL_CFLAGS=\"$with_libssl_cflags\"\n\tBUILD_WITH_LIBSSL_LDFLAGS=\"$with_libssl_ldflags\"\n\tBUILD_WITH_LIBSSL_LIBS=\"-lssl -lcrypto\"\n\tAC_SUBST([BUILD_WITH_LIBSSL_CFLAGS])\n\tAC_SUBST([BUILD_WITH_LIBSSL_LDFLAGS])\n\tAC_SUBST([BUILD_WITH_LIBSSL_LIBS])\n\tAC_DEFINE([HAVE_LIBSSL], [1], [Define if libssl is present and usable.])\nfi\nAM_CONDITIONAL(BUILD_WITH_LIBSSL, test \"x$with_libssl\" = \"xyes\")\n# }}}\n\n# --with-libstatgrab {{{\nAC_ARG_WITH([libstatgrab],\n  [AS_HELP_STRING([--with-libstatgrab@<:@=PREFIX@:>@], [Path to libstatgrab.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_libstatgrab_cflags=\"-I$withval/include\"\n      with_libstatgrab_ldflags=\"-L$withval/lib -lstatgrab\"\n      with_libstatgrab=\"yes\"\n      with_libstatgrab_pkg_config=\"no\"\n    else\n      with_libstatgrab=\"$withval\"\n      with_libstatgrab_pkg_config=\"yes\"\n    fi\n  ],\n  [\n    with_libstatgrab=\"yes\"\n    with_libstatgrab_pkg_config=\"yes\"\n  ])\n\nif test \"x$with_libstatgrab\" = \"xyes\" && test \"x$with_libstatgrab_pkg_config\" = \"xyes\"; then\n  AC_MSG_CHECKING([pkg-config for libstatgrab])\n  temp_result=\"found\"\n  $PKG_CONFIG --exists libstatgrab 2>/dev/null\n  if test \"$?\" != \"0\"; then\n    with_libstatgrab_pkg_config=\"no\"\n    with_libstatgrab=\"no (pkg-config doesn't know libstatgrab)\"\n    temp_result=\"not found\"\n  fi\n  AC_MSG_RESULT([$temp_result])\nfi\n\nif test \"x$with_libstatgrab\" = \"xyes\" && test \"x$with_libstatgrab_pkg_config\" = \"xyes\" && test \"x$with_libstatgrab_cflags\" = \"x\"; then\n  AC_MSG_CHECKING([for libstatgrab CFLAGS])\n  temp_result=\"`$PKG_CONFIG --cflags libstatgrab`\"\n  if test \"$?\" = \"0\"; then\n    with_libstatgrab_cflags=\"$temp_result\"\n  else\n    with_libstatgrab=\"no ($PKG_CONFIG --cflags libstatgrab failed)\"\n    temp_result=\"$PKG_CONFIG --cflags libstatgrab failed\"\n  fi\n  AC_MSG_RESULT([$temp_result])\nfi\n\nif test \"x$with_libstatgrab\" = \"xyes\" && test \"x$with_libstatgrab_pkg_config\" = \"xyes\" && test \"x$with_libstatgrab_ldflags\" = \"x\"; then\n  AC_MSG_CHECKING([for libstatgrab LDFLAGS])\n  temp_result=\"`$PKG_CONFIG --libs libstatgrab`\"\n  if test \"$?\" = \"0\"\n  then\n    with_libstatgrab_ldflags=\"$temp_result\"\n  else\n    with_libstatgrab=\"no ($PKG_CONFIG --libs libstatgrab failed)\"\n    temp_result=\"$PKG_CONFIG --libs libstatgrab failed\"\n  fi\n  AC_MSG_RESULT([$temp_result])\nfi\n\nif test \"x$with_libstatgrab\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libstatgrab_cflags\"\n\n  AC_CHECK_HEADERS([statgrab.h],\n    [with_libstatgrab=\"yes\"],\n    [with_libstatgrab=\"no (statgrab.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libstatgrab\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libstatgrab_ldflags\"\n\n  AC_CHECK_LIB([statgrab], [sg_init],\n    [with_libstatgrab=\"yes\"],\n    [with_libstatgrab=\"no (symbol sg_init not found)\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libstatgrab\" = \"xyes\"; then\n  SAVE_CFLAGS=\"$CFLAGS\"\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  SAVE_LIBS=\"$LIBS\"\n\n  CFLAGS=\"$CFLAGS $with_libstatgrab_cflags\"\n  LDFLAGS=\"$LDFLAGS $with_libstatgrab_ldflags\"\n  LIBS=\"-lstatgrab $LIBS\"\n\n  AC_CACHE_CHECK([if libstatgrab >= 0.90],\n    [c_cv_have_libstatgrab_0_90],\n    [\n      AC_LINK_IFELSE(\n        [\n          AC_LANG_PROGRAM(\n            [[\n              #include <stdio.h>\n              #include <statgrab.h>\n            ]],\n            [[\n              if (sg_init()) return 0;\n            ]]\n          )\n        ],\n        [c_cv_have_libstatgrab_0_90=\"no\"],\n        [c_cv_have_libstatgrab_0_90=\"yes\"]\n      )\n    ]\n  )\n\n  CFLAGS=\"$SAVE_CFLAGS\"\n  LDFLAGS=\"$SAVE_LDFLAGS\"\n  LIBS=\"$SAVE_LIBS\"\nfi\n\nAM_CONDITIONAL([BUILD_WITH_LIBSTATGRAB], [test \"x$with_libstatgrab\" = \"xyes\"])\n\nif test \"x$with_libstatgrab\" = \"xyes\"; then\n  AC_DEFINE([HAVE_LIBSTATGRAB], [1],\n    [Define to 1 if you have the 'statgrab' library (-lstatgrab)]\n  )\n\n  if test \"x$c_cv_have_libstatgrab_0_90\" = \"xyes\"; then\n    AC_DEFINE([HAVE_LIBSTATGRAB_0_90], [1],\n      [Define to 1 if libstatgrab version >= 0.90]\n    )\n  fi\n\n  BUILD_WITH_LIBSTATGRAB_CFLAGS=\"$with_libstatgrab_cflags\"\n  BUILD_WITH_LIBSTATGRAB_LDFLAGS=\"$with_libstatgrab_ldflags\"\n\nfi\n\nAC_SUBST([BUILD_WITH_LIBSTATGRAB_CFLAGS])\nAC_SUBST([BUILD_WITH_LIBSTATGRAB_LDFLAGS])\n# }}}\n\n# --with-libtokyotyrant {{{\nAC_ARG_WITH([libtokyotyrant],\n  [AS_HELP_STRING([--with-libtokyotyrant@<:@=PREFIX@:>@], [Path to libtokyotyrant.])],\n  [\n    if test \"x$withval\" = \"xno\" || test \"x$withval\" = \"xyes\"; then\n      with_libtokyotyrant=\"$withval\"\n    else\n      with_libtokyotyrant_cppflags=\"-I$withval/include\"\n      with_libtokyotyrant_ldflags=\"-L$withval/include\"\n      with_libtokyotyrant_libs=\"-ltokyotyrant\"\n      with_libtokyotyrant=\"yes\"\n    fi\n  ],\n  [with_libtokyotyrant=\"yes\"]\n)\n\nif test \"x$with_libtokyotyrant\" = \"xyes\"; then\n  if $PKG_CONFIG --exists tokyotyrant; then\n    with_libtokyotyrant_cppflags=\"$with_libtokyotyrant_cppflags `$PKG_CONFIG --cflags tokyotyrant`\"\n    with_libtokyotyrant_ldflags=\"$with_libtokyotyrant_ldflags `$PKG_CONFIG --libs-only-L tokyotyrant`\"\n    with_libtokyotyrant_libs=\"$with_libtokyotyrant_libs `$PKG_CONFIG --libs-only-l tokyotyrant`\"\n  fi\nfi\n\nif test \"x$with_libtokyotyrant\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libtokyotyrant_cppflags\"\n\n  AC_CHECK_HEADERS([tcrdb.h],\n    [with_libtokyotyrant=\"yes\"],\n    [with_libtokyotyrant=\"no (tcrdb.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libtokyotyrant\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libtokyotyrant_ldflags\"\n\n  AC_CHECK_LIB([tokyotyrant], [tcrdbrnum],\n    [with_libtokyotyrant=\"yes\"],\n    [with_libtokyotyrant=\"no (symbol tcrdbrnum not found)\"],\n    [$with_libtokyotyrant_libs]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libtokyotyrant\" = \"xyes\"; then\n  BUILD_WITH_LIBTOKYOTYRANT_CPPFLAGS=\"$with_libtokyotyrant_cppflags\"\n  BUILD_WITH_LIBTOKYOTYRANT_LDFLAGS=\"$with_libtokyotyrant_ldflags\"\n  BUILD_WITH_LIBTOKYOTYRANT_LIBS=\"$with_libtokyotyrant_libs\"\nfi\nAC_SUBST([BUILD_WITH_LIBTOKYOTYRANT_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBTOKYOTYRANT_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBTOKYOTYRANT_LIBS])\n# }}}\n\n# --with-libudev {{{\nAC_ARG_WITH([libudev],\n  [AS_HELP_STRING([--with-libudev@<:@=PREFIX@:>@], [Path to libudev.])],\n  [\n    if test \"x$withval\" = \"xno\" || test \"x$withval\" = \"xyes\"; then\n      with_libudev=\"$withval\"\n    else\n      with_libudev_cppflags=\"-I$withval/include\"\n      with_libudev_ldflags=\"-L$withval/lib\"\n      with_libudev=\"yes\"\n    fi\n  ],\n  [\n    if test \"x$ac_system\" = \"xLinux\"; then\n      with_libudev=\"yes\"\n    else\n      with_libudev=\"no (Linux only library)\"\n    fi\n  ]\n)\n\nif test \"x$with_libudev\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libudev_cppflags\"\n\n  AC_CHECK_HEADERS([libudev.h],\n    [with_libudev=\"yes\"],\n    [with_libudev=\"no (libudev.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libudev\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libudev_ldflags\"\n\n  AC_CHECK_LIB([udev], [udev_new],\n    [with_libudev=\"yes\"],\n    [with_libudev=\"no (libudev not found)\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libudev\" = \"xyes\"; then\n  BUILD_WITH_LIBUDEV_CPPFLAGS=\"$with_libudev_cppflags\"\n  BUILD_WITH_LIBUDEV_LDFLAGS=\"$with_libudev_ldflags\"\n  BUILD_WITH_LIBUDEV_LIBS=\"-ludev\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBUDEV_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBUDEV_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBUDEV_LIBS])\n\nAM_CONDITIONAL([BUILD_WITH_LIBUDEV], [test \"x$with_libudev\" = \"xyes\"])\n# }}}\n\n# --with-libupsclient {{{\nwith_libupsclient_config=\"\"\nAC_ARG_WITH([libupsclient],\n  [AS_HELP_STRING([--with-libupsclient@<:@=PREFIX@:>@], [Path to the upsclient library.])],\n  [\n    if test \"x$withval\" = \"xno\"; then\n      with_libupsclient=\"no\"\n    else if test \"x$withval\" = \"xyes\"; then\n      with_libupsclient=\"use_pkgconfig\"\n    else\n      if test -x \"$withval\"; then\n        with_libupsclient_config=\"$withval\"\n        with_libupsclient=\"use_libupsclient_config\"\n      else if test -x \"$withval/bin/libupsclient-config\"; then\n        with_libupsclient_config=\"$withval/bin/libupsclient-config\"\n        with_libupsclient=\"use_libupsclient_config\"\n      else\n        AC_MSG_NOTICE([Not checking for libupsclient: Manually configured])\n        with_libupsclient_cflags=\"-I$withval/include\"\n        with_libupsclient_libs=\"-L$withval/lib -lupsclient\"\n        with_libupsclient=\"yes\"\n      fi; fi\n    fi; fi\n  ],\n  [with_libupsclient=\"use_pkgconfig\"]\n)\n\n# configure using libupsclient-config\nif test \"x$with_libupsclient\" = \"xuse_libupsclient_config\"; then\n  with_libupsclient_cflags=\"`$with_libupsclient_config --cflags`\"\n  if test $? -ne 0; then\n    with_libupsclient=\"no ($with_libupsclient_config failed)\"\n  fi\n  with_libupsclient_libs=\"`$with_libupsclient_config --libs`\"\n  if test $? -ne 0; then\n    with_libupsclient=\"no ($with_libupsclient_config failed)\"\n  fi\nfi\n\nif test \"x$with_libupsclient\" = \"xuse_libupsclient_config\"; then\n  with_libupsclient=\"yes\"\nfi\n\n# configure using pkg-config\nif test \"x$with_libupsclient\" = \"xuse_pkgconfig\"; then\n  $PKG_CONFIG --exists 'libupsclient' 2>/dev/null\n  if test $? -ne 0; then\n    with_libupsclient=\"no (pkg-config doesn't know libupsclient)\"\n  fi\nfi\n\nif test \"x$with_libupsclient\" = \"xuse_pkgconfig\"; then\n  with_libupsclient_cflags=\"`$PKG_CONFIG --cflags 'libupsclient'`\"\n  if test $? -ne 0; then\n    with_libupsclient=\"no ($PKG_CONFIG failed)\"\n  fi\n\n  with_libupsclient_libs=\"`$PKG_CONFIG --libs 'libupsclient'`\"\n  if test $? -ne 0; then\n    with_libupsclient=\"no ($PKG_CONFIG failed)\"\n  fi\nfi\n\nif test \"x$with_libupsclient\" = \"xuse_pkgconfig\"; then\n  with_libupsclient=\"yes\"\nfi\n\nif test \"x$with_libupsclient\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libupsclient_cflags\"\n\n  AC_CHECK_HEADERS([upsclient.h],\n    [with_libupsclient=\"yes\"],\n    [with_libupsclient=\"no (upsclient.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libupsclient\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libupsclient_libs\"\n\n  AC_CHECK_LIB([upsclient], [upscli_connect],\n    [with_libupsclient=\"yes\"],\n    [with_libupsclient=\"no (symbol upscli_connect not found)\"]\n  )\n\n  AC_CHECK_LIB([upsclient], [upscli_init],\n    [AC_DEFINE([HAVE_UPSCLI_INIT], [1], [Define when upscli_init() (since version 2-7) is available.])]\n  )\n\n  AC_CHECK_LIB([upsclient], [upscli_tryconnect],\n    [AC_DEFINE([HAVE_UPSCLI_TRYCONNECT], [1], [Define when upscli_tryconnect() (since version 2.6.2) is available.])]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libupsclient\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libupsclient_cflags\"\n\n  AC_CHECK_TYPES([UPSCONN_t, UPSCONN],\n    [],\n    [],\n    [[\n      #include <stdlib.h>\n      #include <stdio.h>\n      #include <upsclient.h>\n    ]]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libupsclient\" = \"xyes\"; then\n  BUILD_WITH_LIBUPSCLIENT_CFLAGS=\"$with_libupsclient_cflags\"\n  BUILD_WITH_LIBUPSCLIENT_LIBS=\"$with_libupsclient_libs\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBUPSCLIENT_CFLAGS])\nAC_SUBST([BUILD_WITH_LIBUPSCLIENT_LIBS])\n# }}}\n\n# --with-libxenctrl {{{\nAC_ARG_WITH([libxenctrl],\n  [AS_HELP_STRING([--with-libxenctrl@<:@=PREFIX@:>@], [Path to libxenctrl.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_libxenctrl_cppflags=\"-I$withval/include\"\n      with_libxenctrl_ldflags=\"-L$withval/lib\"\n      with_libxenctrl=\"yes\"\n    else\n      with_libxenctrl=\"$withval\"\n    fi\n  ],\n  [with_libxenctrl=\"yes\"]\n)\n\nif test \"x$with_libxenctrl\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libxenctrl_cppflags\"\n\n  AC_CHECK_HEADERS([xenctrl.h],\n    [with_libxenctrl=\"yes\"],\n    [with_libxenctrl=\"no (xenctrl.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libxenctrl\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libxenctrl_ldflags\"\n\n  #Xen versions older than 3.4 has no xc_getcpuinfo()\n  AC_CHECK_LIB([xenctrl], [xc_getcpuinfo],\n    [with_libxenctrl=\"yes\"],\n    [with_libxenctrl=\"no (symbol 'xc_getcpuinfo' not found)\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nLIBXENCTL_CPPFLAGS=\"$with_libxenctl_cppflags\"\nLIBXENCTL_LDFLAGS=\"$with_libxenctl_ldflags\"\nAC_SUBST([LIBXENCTL_CPPFLAGS])\nAC_SUBST([LIBXENCTL_LDFLAGS])\n# }}}\n\n# --with-libxmms {{{\nwith_xmms_config=\"xmms-config\"\nAC_ARG_WITH([libxmms],\n  [AS_HELP_STRING([--with-libxmms@<:@=PREFIX@:>@], [Path to libxmms.])],\n  [\n    if test \"x$withval\" = \"xno\" || test \"x$withval\" = \"xyes\"; then\n      with_libxmms=\"$withval\"\n    else\n      if test -f \"$withval\" && test -x \"$withval\"; then\n        with_xmms_config=\"$withval\"\n      else if test -x \"$withval/bin/xmms-config\"; then\n        with_xmms_config=\"$withval/bin/xmms-config\"\n      fi; fi\n      with_libxmms=\"yes\"\n    fi\n  ],\n  [with_libxmms=\"yes\"]\n)\n\nif test \"x$with_libxmms\" = \"xyes\"; then\n  with_xmms_cflags=`$with_xmms_config --cflags 2>/dev/null`\n  if test $? -ne 0; then\n    with_libxmms=\"no\"\n  fi\nfi\n\nif test \"x$with_libxmms\" = \"xyes\"; then\n  with_xmms_libs=`$with_xmms_config --libs 2>/dev/null`\n  if test $? -ne 0; then\n    with_libxmms=\"no\"\n  fi\nfi\n\nif test \"x$with_libxmms\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$with_xmms_cflags\"\n\n  AC_CHECK_HEADER([xmmsctrl.h],\n    [with_libxmms=\"yes\"],\n    [with_libxmms=\"no\"],\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libxmms\" = \"xyes\"; then\n  SAVE_LIBS=\"$LIBS\"\n  LIBS=\"$with_xmms_libs\"\n\n  AC_CHECK_LIB([xmms], [xmms_remote_get_info],\n    [with_libxmss=\"yes\"],\n    [with_libxmms=\"no\"],\n    [$with_xmms_libs]\n\n  )\n\n  LIBS=\"$SAVE_LIBS\"\nfi\n\nBUILD_WITH_LIBXMMS_CFLAGS=\"$with_xmms_cflags\"\nBUILD_WITH_LIBXMMS_LIBS=\"$with_xmms_libs\"\n\nAC_SUBST([BUILD_WITH_LIBXMMS_CFLAGS])\nAC_SUBST([BUILD_WITH_LIBXMMS_LIBS])\n# }}}\n\n# --with-libyajl {{{\nAC_ARG_WITH([libyajl],\n  [AS_HELP_STRING([--with-libyajl@<:@=PREFIX@:>@], [Path to libyajl.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_libyajl_cppflags=\"-I$withval/include\"\n      with_libyajl_ldflags=\"-L$withval/lib\"\n      with_libyajl=\"yes\"\n    else\n      with_libyajl=\"$withval\"\n    fi\n  ],\n  [with_libyajl=\"yes\"]\n)\n\nif test \"x$with_libyajl\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libyajl_cppflags\"\n\n  AC_CHECK_HEADERS([yajl/yajl_parse.h],\n    [with_libyajl=\"yes\"],\n    [with_libyajl=\"no (yajl/yajl_parse.h not found)\"]\n  )\n\n  AC_CHECK_HEADERS([yajl/yajl_tree.h],\n    [with_libyajl2=\"yes\"],\n    [with_libyajl2=\"no (yajl/yajl_tree.h not found)\"]\n  )\n\n  AC_CHECK_HEADERS([yajl/yajl_version.h])\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libyajl\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libyajl_ldflags\"\n\n  AC_CHECK_LIB([yajl], [yajl_alloc],\n    [with_libyajl=\"yes\"],\n    [with_libyajl=\"no (Symbol 'yajl_alloc' not found)\"]\n  )\n\n  AC_CHECK_LIB([yajl], [yajl_tree_parse],\n    [with_libyajl2=\"yes\"],\n    [with_libyajl2=\"no (Symbol 'yajl_tree_parse' not found)\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libyajl\" = \"xyes\"; then\n  BUILD_WITH_LIBYAJL_CPPFLAGS=\"$with_libyajl_cppflags\"\n  BUILD_WITH_LIBYAJL_LDFLAGS=\"$with_libyajl_ldflags\"\n  BUILD_WITH_LIBYAJL_LIBS=\"-lyajl\"\n  AC_DEFINE([HAVE_LIBYAJL], [1], [Define if libyajl is present and usable.])\nfi\n\nAC_SUBST([BUILD_WITH_LIBYAJL_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBYAJL_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBYAJL_LIBS])\n\nAM_CONDITIONAL([BUILD_WITH_LIBYAJL], [test \"x$with_libyajl\" = \"xyes\"])\nAM_CONDITIONAL([BUILD_WITH_LIBYAJL2], [test \"x$with_libyajl$with_libyajl2\" = \"xyesyes\"])\n# }}}\n\n# --with-mic {{{\nwith_mic_cppflags=\"-I/opt/intel/mic/sysmgmt/sdk/include\"\nwith_mic_ldflags=\"-L/opt/intel/mic/sysmgmt/sdk/lib/Linux\"\nwith_mic_libs=\"-lMicAccessSDK -scif\"\nAC_ARG_WITH([mic],\n  [AS_HELP_STRING([--with-mic@<:@=PREFIX@:>@], [Path to Intel MIC Access API.])],\n  [\n    if test \"x$withval\" = \"xno\" || test \"x$withval\" = \"xyes\"; then\n      with_mic=\"$withval\"\n    else if test -d \"$with_mic/lib\"; then\n      with_mic_cppflags=\"-I$withval/include\"\n      with_mic_ldflags=\"-L$withval/lib/Linux\"\n      with_mic=\"yes\"\n    fi; fi\n  ],\n  [with_mic=\"yes\"]\n)\n\nif test \"x$with_mic\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_mic_cppflags\"\n\n  AC_CHECK_HEADERS([MicAccessApi.h],\n    [with_mic=\"yes\"],\n    [with_mic=\"no (MicAccessApi not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_mic\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_mic_ldflags\"\n\n  AC_CHECK_LIB([MicAccessSDK], [MicInitAPI],\n    [with_mic=\"yes\"],\n    [with_mic=\"no (symbol MicInitAPI not found)\"],\n    [$PTHREAD_LIBS -lscif]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_mic\" = \"xyes\"; then\n  BUILD_WITH_MIC_CPPFLAGS=\"$with_mic_cppflags\"\n  BUILD_WITH_MIC_LDFLAGS=\"$with_mic_ldflags\"\n  BUILD_WITH_MIC_LIBS=\"$with_mic_libs\"\nfi\nAC_SUBST([BUILD_WITH_MIC_CPPFLAGS])\nAC_SUBST([BUILD_WITH_MIC_LDFLAGS])\nAC_SUBST([BUILD_WITH_MIC_LIBS])\n#}}}\n\n# --with-libvarnish {{{\nAC_ARG_WITH([libvarnish],\n  [AS_HELP_STRING([--with-libvarnish@<:@=PREFIX@:>@], [Path to libvarnish.])],\n  [\n    if test \"x$withval\" = \"xno\"; then\n      with_libvarnish=\"no\"\n    else if test \"x$withval\" = \"xyes\"; then\n      with_libvarnish=\"use_pkgconfig\"\n    else if test -d \"$with_libvarnish/lib\"; then\n      with_libvarnish_cflags=\"-I$withval/include\"\n      with_libvarnish_libs=\"-L$withval/lib -lvarnishapi\"\n      with_libvarnish=\"yes\"\n    fi; fi; fi\n  ],\n  [with_libvarnish=\"use_pkgconfig\"]\n)\n\n# configure using pkg-config\nif test \"x$with_libvarnish\" = \"xuse_pkgconfig\"; then\n  $PKG_CONFIG --exists 'varnishapi' 2>/dev/null\n  if test $? -ne 0; then\n    with_libvarnish=\"no (pkg-config doesn't know varnishapi)\"\n  fi\nfi\n\nif test \"x$with_libvarnish\" = \"xuse_pkgconfig\"; then\n  with_libvarnish_cflags=\"`$PKG_CONFIG --cflags 'varnishapi'`\"\n  if test $? -ne 0; then\n    with_libvarnish=\"no ($PKG_CONFIG failed)\"\n  fi\n\n  with_libvarnish_libs=\"`$PKG_CONFIG --libs 'varnishapi'`\"\n  if test $? -ne 0; then\n    with_libvarnish=\"no ($PKG_CONFIG failed)\"\n  fi\nfi\nif test \"x$with_libvarnish\" = \"xuse_pkgconfig\"; then\n  with_libvarnish=\"yes\"\nfi\n\nif test \"x$with_libvarnish\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libvarnish_cflags\"\n\n  $PKG_CONFIG --atleast-version=5.2 'varnishapi' 2>/dev/null\n  if test $? -eq 0; then\n    AC_DEFINE([HAVE_VARNISH_V5], [1], [Varnish 5 API support])\n  else\n    AC_CHECK_HEADERS([vapi/vsc.h],\n      [AC_DEFINE([HAVE_VARNISH_V4], [1], [Varnish 4 API support])],\n      [\n        AC_CHECK_HEADERS([vsc.h],\n          [AC_DEFINE([HAVE_VARNISH_V3], [1], [Varnish 3 API support]) ],\n          [\n            AC_CHECK_HEADERS([varnishapi.h],\n              [AC_DEFINE([HAVE_VARNISH_V2], [1], [Varnish 2 API support])],\n              [with_libvarnish=\"no (found none of the varnish header files)\"]\n            )\n          ]\n        )\n      ]\n    )\n  fi\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libvarnish\" = \"xyes\"; then\n  BUILD_WITH_LIBVARNISH_CFLAGS=\"$with_libvarnish_cflags\"\n  BUILD_WITH_LIBVARNISH_LIBS=\"$with_libvarnish_libs\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBVARNISH_CFLAGS])\nAC_SUBST([BUILD_WITH_LIBVARNISH_LIBS])\n# }}}\n\n# --with-libxml2 {{{\nAC_ARG_WITH(libxml2,\n  [AS_HELP_STRING([--with-libxml2@<:@=PREFIX@:>@], [Path to libxml2.])],\n  [\n    if test \"x$withval\" = \"xno\"; then\n      with_libxml2=\"no\"\n    else if test \"x$withval\" = \"xyes\"; then\n      $PKG_CONFIG --exists 'libxml-2.0' 2>/dev/null\n      if test $? -eq 0; then\n        with_libxml2=\"yes\"\n        with_libxml2_cflags=\"`$PKG_CONFIG --cflags libxml-2.0`\"\n        with_libxml2_ldflags=\"`$PKG_CONFIG --libs libxml-2.0`\"\n      else\n        with_libxml2=\"no (pkg-config doesn't know libxml-2.0)\"\n      fi\n    else\n      with_libxml2=\"yes\"\n      with_libxml2_cflags=\"-I$withval/include\"\n      with_libxml2_ldflags=\"-L$withval/lib\"\n    fi; fi\n  ],\n  dnl  if no argument --with-libxml2 was passed, find the library locations\n  dnl  with pkg-config just like above, when --with-libxml2=yes.\n  [\n    with_libxml2=\"yes\"\n    $PKG_CONFIG --exists 'libxml-2.0' 2>/dev/null\n    if test $? -eq 0; then\n      with_libxml2=\"yes\"\n      with_libxml2_cflags=\"`$PKG_CONFIG --cflags libxml-2.0`\"\n      with_libxml2_ldflags=\"`$PKG_CONFIG --libs libxml-2.0`\"\n    else\n      with_libxml2=\"no (pkg-config doesn't know libxml-2.0)\"\n    fi\n  ]\n)\n\nif test \"x$with_libxml2\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libxml2_cflags\"\n\n  AC_CHECK_HEADERS([libxml/parser.h],\n    [with_libxml2=\"yes\"],\n    [with_libxml2=\"no (libxml/parser.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libxml2\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libxml2_ldflags\"\n\n  AC_CHECK_LIB([xml2], [xmlXPathEval],\n    [with_libxml2=\"yes\"],\n    [with_libxml2=\"no (symbol xmlXPathEval not found)\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libxml2\" = \"xyes\"; then\n  BUILD_WITH_LIBXML2_CFLAGS=\"$with_libxml2_cflags\"\n  BUILD_WITH_LIBXML2_LIBS=\"$with_libxml2_ldflags\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBXML2_CFLAGS])\nAC_SUBST([BUILD_WITH_LIBXML2_LIBS])\n# }}}\n\n# pkg-config --exists libvirt {{{\n$PKG_CONFIG --exists libvirt 2>/dev/null\nif test $? = 0; then\n  with_libvirt=\"yes\"\nelse\n  with_libvirt=\"no (pkg-config doesn't know libvirt)\"\nfi\n\nif test \"x$with_libvirt\" = \"xyes\"; then\n  with_libvirt_cflags=\"`$PKG_CONFIG --cflags libvirt`\"\n  if test $? -ne 0; then\n    with_libvirt=\"no\"\n  fi\n\n  with_libvirt_ldflags=\"`$PKG_CONFIG --libs libvirt`\"\n  if test $? -ne 0; then\n    with_libvirt=\"no\"\n  fi\nfi\n\nif test \"x$with_libvirt\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libvirt_cflags\"\n\n  AC_CHECK_HEADERS([libvirt/libvirt.h],\n    [with_libvirt=\"yes\"],\n    [with_libvirt=\"no (libvirt/libvirt.h not found)\"]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libvirt\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libvirt_ldflags\"\n\n  AC_CHECK_LIB([virt], [virDomainBlockStats],\n    [with_libvirt=\"yes\"],\n    [with_libvirt=\"no (symbol virDomainBlockStats not found)\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libvirt\" = \"xyes\"; then\n  BUILD_WITH_LIBVIRT_CFLAGS=\"$with_libvirt_cflags\"\n  BUILD_WITH_LIBVIRT_LIBS=\"$with_libvirt_ldflags\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBVIRT_CFLAGS])\nAC_SUBST([BUILD_WITH_LIBVIRT_LIBS])\n# }}}\n\n# $PKG_CONFIG --exists OpenIPMIpthread {{{\nwith_libopenipmipthread=\"yes\"\nAC_MSG_CHECKING([for libOpenIPMIpthread])\n$PKG_CONFIG --exists OpenIPMIpthread 2>/dev/null\nif test $? -ne 0; then\n  with_libopenipmipthread=\"no (pkg-config doesn't know OpenIPMIpthread)\"\nfi\nAC_MSG_RESULT([$with_libopenipmipthread])\n\nif test \"x$with_libopenipmipthread\" = \"xyes\"; then\n  AC_MSG_CHECKING([for libOpenIPMIpthread CFLAGS])\n  temp_result=\"`$PKG_CONFIG --cflags OpenIPMIpthread`\"\n  if test $? -eq 0; then\n    with_libopenipmipthread_cflags=\"$temp_result\"\n  else\n    with_libopenipmipthread=\"no ($PKG_CONFIG --cflags OpenIPMIpthread failed)\"\n    temp_result=\"$PKG_CONFIG --cflags OpenIPMIpthread failed\"\n  fi\n  AC_MSG_RESULT([$temp_result])\nfi\n\nif test \"x$with_libopenipmipthread\" = \"xyes\"; then\n  AC_MSG_CHECKING([for libOpenIPMIpthread LDFLAGS])\n  temp_result=\"`$PKG_CONFIG --libs OpenIPMIpthread`\"\n  if test $? -eq 0; then\n    with_libopenipmipthread_ldflags=\"$temp_result\"\n  else\n    with_libopenipmipthread=\"no ($PKG_CONFIG --libs OpenIPMIpthread failed)\"\n    temp_result=\"$PKG_CONFIG --libs OpenIPMIpthread failed\"\n  fi\n  AC_MSG_RESULT([$temp_result])\nfi\n\nif test \"x$with_libopenipmipthread\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libopenipmipthread_cflags\"\n\n  AC_CHECK_HEADERS([OpenIPMI/ipmi_smi.h],\n    [with_libopenipmipthread=\"yes\"],\n    [with_libopenipmipthread=\"no (OpenIPMI/ipmi_smi.h not found)\"],\n    [[\n      #include <OpenIPMI/ipmiif.h>\n      #include <OpenIPMI/ipmi_err.h>\n      #include <OpenIPMI/ipmi_posix.h>\n      #include <OpenIPMI/ipmi_conn.h>\n    ]]\n  )\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libopenipmipthread\" = \"xyes\"; then\n  BUILD_WITH_OPENIPMI_CFLAGS=\"$with_libopenipmipthread_cflags\"\n  BUILD_WITH_OPENIPMI_LIBS=\"$with_libopenipmipthread_ldflags\"\nfi\n\nAC_SUBST([BUILD_WITH_OPENIPMI_CFLAGS])\nAC_SUBST([BUILD_WITH_OPENIPMI_LIBS])\n# }}}\n\n# --with-libatasmart {{{\nAC_ARG_WITH([libatasmart],\n  [AS_HELP_STRING([--with-libatasmart@<:@=PREFIX@:>@], [Path to libatasmart.])],\n  [\n    if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n      with_libatasmart_cppflags=\"-I$withval/include\"\n      with_libatasmart_ldflags=\"-L$withval/lib\"\n      with_libatasmart=\"yes\"\n    else\n      with_libatasmart=\"$withval\"\n    fi\n  ],\n  [\n    if test \"x$ac_system\" = \"xLinux\"; then\n      with_libatasmart=\"yes\"\n    else\n      with_libatasmart=\"no (Linux only library)\"\n    fi\n  ]\n)\n\nif test \"x$with_libatasmart\" = \"xyes\"; then\n  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n  CPPFLAGS=\"$CPPFLAGS $with_libatasmart_cppflags\"\n\n  AC_CHECK_HEADERS([atasmart.h],\n    [with_libatasmart=\"yes\"],\n    [with_libatasmart=\"no (atasmart.h not found)\"])\n\n  CPPFLAGS=\"$SAVE_CPPFLAGS\"\nfi\n\nif test \"x$with_libatasmart\" = \"xyes\"; then\n  SAVE_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $with_libatasmart_ldflags\"\n\n  AC_CHECK_LIB([atasmart], [sk_disk_open],\n    [with_libatasmart=\"yes\"],\n    [with_libatasmart=\"no (Symbol 'sk_disk_open' not found)\"]\n  )\n\n  LDFLAGS=\"$SAVE_LDFLAGS\"\nfi\n\nif test \"x$with_libatasmart\" = \"xyes\"; then\n  BUILD_WITH_LIBATASMART_CPPFLAGS=\"$with_libatasmart_cppflags\"\n  BUILD_WITH_LIBATASMART_LDFLAGS=\"$with_libatasmart_ldflags\"\n  BUILD_WITH_LIBATASMART_LIBS=\"-latasmart\"\nfi\n\nAC_SUBST([BUILD_WITH_LIBATASMART_CPPFLAGS])\nAC_SUBST([BUILD_WITH_LIBATASMART_LDFLAGS])\nAC_SUBST([BUILD_WITH_LIBATASMART_LIBS])\n# }}}\n\nPKG_CHECK_MODULES([LIBNOTIFY], [libnotify],\n  [with_libnotify=\"yes\"],\n  [with_libnotify=\"no (pkg-config doesn't know libnotify)\"]\n)\n\nPKG_CHECK_MODULES([LIBRIEMANN_CLIENT], [riemann-client >= 1.6.0],\n [with_libriemann_client=\"yes\"],\n [with_libriemann_client=\"no (pkg-config doesn't know libriemann-client)\"]\n)\n\n# Check for enabled/disabled features\n#\n\n# AC_COLLECTD(name, enable/disable, info-text, feature/module)\n# ------------------------------------------------------------\ndnl\nm4_define([my_toupper],[m4_translit([$1], m4_defn([m4_cr_letters]), m4_defn([m4_cr_LETTERS]))])\ndnl\nAC_DEFUN(\n  [AC_COLLECTD],\n  [\n  m4_if([$1], [], [AC_FATAL([AC_COLLECTD([$1], [$2], [$3], [$4]): 1st argument must not be empty])])dnl\n  m4_if(\n    [$2],\n    [enable],\n    [dnl\n    m4_define([EnDis],[disabled])dnl\n    m4_define([YesNo],[no])dnl\n    ],dnl\n    [m4_if(\n      [$2],\n      [disable],\n      [dnl\n      m4_define([EnDis],[enabled])dnl\n      m4_define([YesNo],[yes])dnl\n      ],\n      [dnl\n      AC_FATAL([AC_COLLECTD([$1], [$2], [$3], [$4]): 2nd argument must be either enable or disable])dnl\n      ]dnl\n    )]dnl\n  )dnl\n  m4_if([$3], [feature], [],\n    [m4_if(\n      [$3], [module], [],\n      [dnl\n      AC_FATAL([AC_COLLECTD([$1], [$2], [$3], [$4]): 3rd argument must be either feature or disable])dnl\n      ]dnl\n    )]dnl\n  )dnl\n  AC_ARG_ENABLE(\n    [$1],\n    AS_HELP_STRING([--$2-$1], [$2 $4 (EnDis by def)]),\n    [],\n    enable_$1='[YesNo]'dnl\n  )# AC_ARG_ENABLE\n  if test \"x$enable_$1\" = \"xno\"; then\n    collectd_$1=0\n  else\n    if test \"x$enable_$1\" = \"xyes\"; then\n      collectd_$1=1\n    else\n      AC_MSG_NOTICE([please specify either --enable-$1 or --disable-$1; enabling $1.])\n      collectd_$1=1\n      enable_$1='yes'\n    fi\n  fi\n  AC_DEFINE_UNQUOTED([COLLECT_]my_toupper([$1]), [$collectd_$1], [whether or not to enable $3 $4])\n  AM_CONDITIONAL([BUILD_]my_toupper([$3])[_]my_toupper([$1]), [test \"x$enable_$1\" = \"xyes\"])dnl\n  ]dnl\n)# AC_COLLECTD(name, enable/disable, info-text, feature/module)\n\n# AC_PLUGIN(name, default, info)\n# ------------------------------------------------------------\ndnl\nAC_DEFUN(\n  [AC_PLUGIN],\n  [\n    enable_plugin=\"no\"\n    force=\"no\"\n    AC_ARG_ENABLE([$1],\n      [AS_HELP_STRING([--enable-$1],[$3])],\n      [\n        if test \"x$enableval\" = \"xyes\"; then\n          enable_plugin=\"yes\"\n        else if test \"x$enableval\" = \"xforce\"; then\n          enable_plugin=\"yes\"\n          force=\"yes\"\n        else\n          enable_plugin=\"no (disabled on command line)\"\n        fi; fi\n      ],\n      [\n        if test \"x$enable_all_plugins\" = \"xauto\"; then\n          if test \"x$2\" = \"xyes\"; then\n            enable_plugin=\"yes\"\n          else\n            enable_plugin=\"$2\"\n          fi\n        else\n          enable_plugin=\"$enable_all_plugins\"\n        fi\n      ]\n    )\n    if test \"x$enable_plugin\" = \"xyes\"; then\n      if test \"x$2\" = \"xyes\" || test \"x$force\" = \"xyes\"; then\n        AC_DEFINE([HAVE_PLUGIN_]my_toupper([$1]), 1, [Define to 1 if the $1 plugin is enabled.])\n        if test \"x$2\" != \"xyes\"; then\n          dependency_warning=\"yes\"\n        fi\n      else # User passed \"yes\" but dependency checking yielded \"no\" => Dependency problem.\n        dependency_error=\"yes\"\n        enable_plugin=\"$2 (dependency error)\"\n      fi\n    fi\n    AM_CONDITIONAL([BUILD_PLUGIN_]my_toupper([$1]), [test \"x$enable_plugin\" = \"xyes\"])\n    enable_$1=\"$enable_plugin\"\n  ]\n)# AC_PLUGIN(name, default, info)\n\nm4_divert_once([HELP_ENABLE], [\ncollectd features:])\n# FIXME: Remove these calls to `AC_COLLECTD' and then remove that macro.\nAC_COLLECTD([debug],     [enable],  [feature], [debugging])\nAC_COLLECTD([daemon],    [disable], [feature], [daemon mode])\nAC_COLLECTD([getifaddrs],[enable],  [feature], [getifaddrs under Linux])\nAC_COLLECTD([werror],    [disable], [feature], [building with -Werror])\n\ndependency_warning=\"no\"\ndependency_error=\"no\"\n\nplugin_ascent=\"no\"\nplugin_barometer=\"no\"\nplugin_battery=\"no\"\nplugin_bind=\"no\"\nplugin_ceph=\"no\"\nplugin_cgroups=\"no\"\nplugin_connectivity=\"no\"\nplugin_conntrack=\"no\"\nplugin_contextswitch=\"no\"\nplugin_cpu=\"no\"\nplugin_cpufreq=\"no\"\nplugin_cpusleep=\"no\"\nplugin_curl_json=\"no\"\nplugin_curl_xml=\"no\"\nplugin_df=\"no\"\nplugin_disk=\"no\"\nplugin_drbd=\"no\"\nplugin_dpdkevents=\"no\"\nplugin_dpdkstat=\"no\"\nplugin_entropy=\"no\"\nplugin_ethstat=\"no\"\nplugin_fhcount=\"no\"\nplugin_fscache=\"no\"\nplugin_gps=\"no\"\nplugin_gpu_nvidia=\"no\"\nplugin_grpc=\"no\"\nplugin_hugepages=\"no\"\nplugin_intel_pmu=\"no\"\nplugin_intel_rdt=\"no\"\nplugin_interface=\"no\"\nplugin_ipc=\"no\"\nplugin_ipmi=\"no\"\nplugin_ipvs=\"no\"\nplugin_irq=\"no\"\nplugin_load=\"no\"\nplugin_log_logstash=\"no\"\nplugin_mcelog=\"no\"\nplugin_memory=\"no\"\nplugin_multimeter=\"no\"\nplugin_nfs=\"no\"\nplugin_numa=\"no\"\nplugin_ovs_events=\"no\"\nplugin_ovs_stats=\"no\"\nplugin_pcie_errors=\"no\"\nplugin_perl=\"no\"\nplugin_pinba=\"no\"\nplugin_processes=\"no\"\nplugin_procevent=\"no\"\nplugin_protocols=\"no\"\nplugin_python=\"no\"\nplugin_serial=\"no\"\nplugin_smart=\"no\"\nplugin_swap=\"no\"\nplugin_synproxy=\"no\"\nplugin_sysevent=\"no\"\nplugin_tape=\"no\"\nplugin_tcpconns=\"no\"\nplugin_ted=\"no\"\nplugin_thermal=\"no\"\nplugin_turbostat=\"no\"\nplugin_uptime=\"no\"\nplugin_users=\"no\"\nplugin_virt=\"no\"\nplugin_vmem=\"no\"\nplugin_vserver=\"no\"\nplugin_wireless=\"no\"\nplugin_write_prometheus=\"no\"\nplugin_write_stackdriver=\"no\"\nplugin_xencpu=\"no\"\nplugin_zfs_arc=\"no\"\nplugin_zone=\"no\"\nplugin_zookeeper=\"no\"\n\n# Linux\nif test \"x$ac_system\" = \"xLinux\"; then\n  plugin_battery=\"yes\"\n  plugin_cgroups=\"yes\"\n  plugin_conntrack=\"yes\"\n  plugin_contextswitch=\"yes\"\n  plugin_cpu=\"yes\"\n  plugin_cpufreq=\"yes\"\n  plugin_disk=\"yes\"\n  plugin_drbd=\"yes\"\n  plugin_entropy=\"yes\"\n  plugin_fhcount=\"yes\"\n  plugin_fscache=\"yes\"\n  plugin_hugepages=\"yes\"\n  plugin_interface=\"yes\"\n  plugin_ipc=\"yes\"\n  plugin_irq=\"yes\"\n  plugin_load=\"yes\"\n  plugin_lvm=\"yes\"\n  plugin_mcelog=\"yes\"\n  plugin_memory=\"yes\"\n  plugin_nfs=\"yes\"\n  plugin_numa=\"yes\"\n  plugin_processes=\"yes\"\n  plugin_protocols=\"yes\"\n  plugin_serial=\"yes\"\n  plugin_swap=\"yes\"\n  plugin_synproxy=\"yes\"\n  plugin_tcpconns=\"yes\"\n  plugin_thermal=\"yes\"\n  plugin_uptime=\"yes\"\n  plugin_vmem=\"yes\"\n  plugin_vserver=\"yes\"\n  plugin_wireless=\"yes\"\n  plugin_zfs_arc=\"yes\"\n\n  if test \"x$ac_cv_header_linux_ip_vs_h\" = \"xyes\"; then\n    plugin_ipvs=\"yes\"\n  fi\n\n  if test \"x$have_cpuid_h\" = \"xyes\"; then\n    plugin_turbostat=\"yes\"\n  fi\n\n  if test \"x$c_cv_have_clock_boottime_monotonic\" = \"xyes\"; then\n    plugin_cpusleep=\"yes\"\n  fi\n\n  if test \"x$with_libyajl\" = \"xyes\" && test \"x$with_libyajl2\" = \"xyes\"; then\n    plugin_ovs_events=\"yes\"\n    plugin_ovs_stats=\"yes\"\n    plugin_procevent=\"yes\"\n\n    if test \"x$with_libmnl\" = \"xyes\"; then\n      plugin_connectivity=\"yes\"\n    fi\n  fi\n\n  if test \"x$have_pci_regs_h\" = \"xyes\"; then\n    plugin_pcie_errors=\"yes\"\n  fi\nfi\n\nif test \"x$ac_system\" = \"xOpenBSD\"; then\n  plugin_tcpconns=\"yes\"\nfi\n\nif test \"x$ac_system\" = \"xNetBSD\"; then\n  plugin_disk=\"yes\"\n  plugin_entropy=\"yes\"\n  plugin_irq=\"yes\"\n  plugin_processes=\"yes\"\nfi\n\n# Mac OS X devices\nif test \"x$with_libiokit\" = \"xyes\"; then\n  plugin_battery=\"yes\"\n  plugin_disk=\"yes\"\nfi\n\n# AIX\n\nif test \"x$ac_system\" = \"xAIX\"; then\n  plugin_ipc=\"yes\"\n  plugin_tcpconns=\"yes\"\nfi\n\n# FreeBSD\n\nif test \"x$ac_system\" = \"xFreeBSD\"; then\n  plugin_cpufreq=\"yes\"\n  plugin_disk=\"yes\"\n  plugin_zfs_arc=\"yes\"\nfi\n\n\nif test \"x$with_perfstat\" = \"xyes\"; then\n  plugin_contextswitch=\"yes\"\n  plugin_cpu=\"yes\"\n  plugin_disk=\"yes\"\n  plugin_interface=\"yes\"\n  plugin_load=\"yes\"\n  plugin_memory=\"yes\"\n  plugin_swap=\"yes\"\n  plugin_uptime=\"yes\"\nfi\n\nif test \"x$with_procinfo\" = \"xyes\"; then\n  plugin_processes=\"yes\"\nfi\n\n# Solaris\nif test \"x$with_kstat\" = \"xyes\"; then\n  plugin_nfs=\"yes\"\n  plugin_processes=\"yes\"\n  plugin_uptime=\"yes\"\n  plugin_zfs_arc=\"yes\"\n  plugin_zone=\"yes\"\nfi\n\nif test \"x$with_devinfo\" = \"xyes\" && test \"x$with_kstat\" = \"xyes\"; then\n  plugin_cpu=\"yes\"\n  plugin_disk=\"yes\"\n  plugin_interface=\"yes\"\n  plugin_memory=\"yes\"\n  plugin_tape=\"yes\"\nfi\n\nif test \"x$with_libi2c\" = \"xyes\"; then\n  plugin_barometer=\"yes\"\nfi\n\n\n# libstatgrab\nif test \"x$with_libstatgrab\" = \"xyes\"; then\n  plugin_cpu=\"yes\"\n  plugin_disk=\"yes\"\n  plugin_interface=\"yes\"\n  plugin_load=\"yes\"\n  plugin_memory=\"yes\"\n  plugin_swap=\"yes\"\n  plugin_users=\"yes\"\nfi\n\nif test \"x$with_libcurl\" = \"xyes\" && test \"x$with_libxml2\" = \"xyes\"; then\n  plugin_ascent=\"yes\"\n  if test \"x$have_strptime\" = \"xyes\"; then\n    plugin_bind=\"yes\"\n  fi\nfi\n\nif test \"x$with_libopenipmipthread\" = \"xyes\"; then\n  plugin_ipmi=\"yes\"\nfi\n\nif test \"x$with_libcurl\" = \"xyes\" && test \"x$with_libyajl\" = \"xyes\"; then\n  plugin_curl_json=\"yes\"\nfi\n\nif test \"x$with_libcurl\" = \"xyes\" && test \"x$with_libssl\" = \"xyes\" && test \"x$with_libyajl\" = \"xyes\" && test \"x$with_libyajl2\" = \"xyes\"; then\n  plugin_write_stackdriver=\"yes\"\nfi\n\nif test \"x$with_libcurl\" = \"xyes\" && test \"x$with_libxml2\" = \"xyes\"; then\n  plugin_curl_xml=\"yes\"\nfi\n\nif test \"x$with_libyajl\" = \"xyes\"; then\n  plugin_ceph=\"yes\"\n  plugin_sysevent=\"yes\"\nfi\n\nif test \"x$have_processor_info\" = \"xyes\"; then\n  plugin_cpu=\"yes\"\nfi\n\nif test \"x$have_sysctl\" = \"xyes\"; then\n  plugin_cpu=\"yes\"\n  plugin_memory=\"yes\"\n  plugin_uptime=\"yes\"\n  if test \"x$ac_system\" = \"xDarwin\"; then\n    plugin_swap=\"yes\"\n  fi\nfi\n\nif test \"x$have_sysctlbyname\" = \"xyes\"; then\n  plugin_contextswitch=\"yes\"\n  plugin_cpu=\"yes\"\n  plugin_memory=\"yes\"\n  plugin_tcpconns=\"yes\"\nfi\n\nif test \"x$have_getvfsstat\" = \"xyes\" || test \"x$have_getfsstat\" = \"xyes\"; then\n  plugin_df=\"yes\"\nfi\n\nif test \"x$c_cv_have_two_getmntent\" = \"xyes\" || test \"x$have_getmntent\" = \"xgen\" || test \"x$have_getmntent\" = \"xsun\"; then\n  plugin_df=\"yes\"\nfi\n\nif test \"x$c_cv_have_one_getmntent\" = \"xyes\"; then\n  plugin_df=\"yes\"\nfi\n\nif test \"x$have_getmntent_r\" = \"xyes\"; then\n  plugin_df=\"yes\"\nfi\n\nif test \"x$plugin_df\" = \"xyes\"; then\n  plugin_df=\"no\"\n  if test \"x$have_statfs\" = \"xyes\"; then\n    plugin_df=\"yes\"\n  fi\n\n  if test \"x$have_statvfs\" = \"xyes\"; then\n    plugin_df=\"yes\"\n  fi\nfi\n\nif test \"x$have_linux_sockios_h\" = \"xyes\" && test \"x$have_linux_ethtool_h\" = \"xyes\"; then\n  plugin_ethstat=\"yes\"\nfi\n\nif test \"x$with_libgps\" = \"xyes\"; then\n  plugin_gps=\"yes\"\nfi\n\nplugin_grpc=\"yes\"\nif test \"x$GRPC_CPP_PLUGIN\" = \"x\"; then\n  plugin_grpc=\"no (grpc_cpp_plugin not found)\"\nfi\nif test \"x$have_protoc3\" != \"xyes\"; then\n  plugin_grpc=\"no (protoc3 not found)\"\nfi\nif test \"x$with_libprotobuf\" != \"xyes\"; then\n  plugin_grpc=\"no (libprotobuf not found)\"\nfi\nif test \"x$with_libgrpcpp\" != \"xyes\"; then\n  plugin_grpc=\"no (libgrpc++ not found)\"\nfi\n\nif test \"x$have_getifaddrs\" = \"xyes\"; then\n  plugin_interface=\"yes\"\nfi\n\nif test \"x$have_getloadavg\" = \"xyes\"; then\n  plugin_load=\"yes\"\nfi\n\nif test \"x$with_libyajl\" = \"xyes\"; then\n  plugin_log_logstash=\"yes\"\nfi\n\nif test \"x$with_libperl\" = \"xyes\" && test \"x$c_cv_have_perl_ithreads\" = \"xyes\"; then\n  plugin_perl=\"yes\"\nfi\n\nif test \"x$have_protoc_c\" = \"xyes\" && test \"x$with_libprotobuf_c\" = \"xyes\"; then\n  plugin_pinba=\"yes\"\n  if test \"x$with_libmicrohttpd\" = \"xyes\"; then\n    plugin_write_prometheus=\"yes\"\n  fi\nfi\n\n# Mac OS X memory interface\nif test \"x$have_host_statistics\" = \"xyes\"; then\n  plugin_memory=\"yes\"\nfi\n\nif test \"x$have_termios_h\" = \"xyes\"; then\n  if test \"x$ac_system\" != \"xAIX\"; then\n    plugin_multimeter=\"yes\"\n  fi\n  plugin_ted=\"yes\"\nfi\n\nif test \"x$have_thread_info\" = \"xyes\"; then\n  plugin_processes=\"yes\"\nfi\n\nif test \"x$with_kvm_getprocs\" = \"xyes\" && test \"x$have_struct_kinfo_proc_freebsd\" = \"xyes\"; then\n  plugin_processes=\"yes\"\nfi\n\nif test \"x$with_kvm_getprocs\" = \"xyes\" && test \"x$have_struct_kinfo_proc_openbsd\" = \"xyes\"; then\n  plugin_processes=\"yes\"\nfi\n\nif test \"x$with_libpython\" != \"xno\"; then\n  plugin_python=\"yes\"\nfi\n\nif test \"x$with_libatasmart\" = \"xyes\" && test \"x$with_libudev\" = \"xyes\"; then\n  plugin_smart=\"yes\"\nfi\n\nif test \"x$with_kvm_getswapinfo\" = \"xyes\"; then\n  plugin_swap=\"yes\"\nfi\n\nif test \"x$have_swapctl\" = \"xyes\" && test \"x$c_cv_have_swapctl_two_args\" = \"xyes\"; then\n  plugin_swap=\"yes\"\nfi\n\nif test \"x$have_swapctl\" = \"xyes\" && test \"x$c_cv_have_swapctl_three_args\" = \"xyes\"; then\n  plugin_swap=\"yes\"\nfi\n\nif test \"x$with_kvm_openfiles = \"xyes\" && $with_kvm_nlist\" = \"xyes\"; then\n  plugin_tcpconns=\"yes\"\nfi\n\nif test \"x$have_getutent\" = \"xyes\"; then\n  plugin_users=\"yes\"\nfi\n\nif test \"x$have_getutxent\" = \"xyes\"; then\n  plugin_users=\"yes\"\nfi\n\nif test \"x$with_libxml2\" = \"xyes\" && test \"x$with_libvirt\" = \"xyes\"; then\n  plugin_virt=\"yes\"\nfi\n\nif test \"x$with_libxenctrl\" = \"xyes\"; then\n  plugin_xencpu=\"yes\"\nfi\n\nif test \"x$with_libdpdk\" = \"xyes\"; then\n  plugin_dpdkevents=\"$dpdk_keepalive\"\n  plugin_dpdkstat=\"yes\"\nfi\n\nm4_divert_once([HELP_ENABLE], [\ncollectd plugins:])\n\nAC_ARG_ENABLE([all-plugins],\n  [AS_HELP_STRING([--enable-all-plugins], [enable all plugins @<:@default=yes@:>@])],\n  [\n     if test \"x$enableval\" = \"xyes\"; then\n       enable_all_plugins=\"yes\"\n     else if test \"x$enableval\" = \"xauto\"; then\n       enable_all_plugins=\"auto\"\n     else\n       enable_all_plugins=\"no\"\n     fi; fi\n  ],\n  [enable_all_plugins=\"auto\"]\n)\n\nm4_divert_once([HELP_ENABLE], [])\n\nAC_PLUGIN([aggregation],         [yes],                       [Aggregation plugin])\nAC_PLUGIN([amqp],                [$with_librabbitmq],         [AMQP output plugin])\nAC_PLUGIN([amqp1],               [$with_libqpid_proton],      [AMQP 1.0 output plugin])\nAC_PLUGIN([apache],              [$with_libcurl],             [Apache httpd statistics])\nAC_PLUGIN([apcups],              [yes],                       [Statistics of UPSes by APC])\nAC_PLUGIN([apple_sensors],       [$with_libiokit],            [Apple hardware sensors])\nAC_PLUGIN([aquaero],             [$with_libaquaero5],         [Aquaero hardware sensors])\nAC_PLUGIN([ascent],              [$plugin_ascent],            [AscentEmu player statistics])\nAC_PLUGIN([barometer],           [$plugin_barometer],         [Barometer sensor on I2C])\nAC_PLUGIN([battery],             [$plugin_battery],           [Battery statistics])\nAC_PLUGIN([bind],                [$plugin_bind],              [ISC Bind nameserver statistics])\nAC_PLUGIN([ceph],                [$plugin_ceph],              [Ceph daemon statistics])\nAC_PLUGIN([cgroups],             [$plugin_cgroups],           [CGroups CPU usage accounting])\nAC_PLUGIN([chrony],              [yes],                       [Chrony statistics])\nAC_PLUGIN([check_uptime],        [yes],                       [Notify about uptime reset])\nAC_PLUGIN([connectivity],        [$plugin_connectivity],      [Network interface up/down events])\nAC_PLUGIN([conntrack],           [$plugin_conntrack],         [nf_conntrack statistics])\nAC_PLUGIN([contextswitch],       [$plugin_contextswitch],     [context switch statistics])\nAC_PLUGIN([cpu],                 [$plugin_cpu],               [CPU usage statistics])\nAC_PLUGIN([cpufreq],             [$plugin_cpufreq],           [CPU frequency statistics])\nAC_PLUGIN([cpusleep],            [$plugin_cpusleep],          [CPU sleep statistics])\nAC_PLUGIN([csv],                 [yes],                       [CSV output plugin])\nAC_PLUGIN([curl],                [$with_libcurl],             [CURL generic web statistics])\nAC_PLUGIN([curl_json],           [$plugin_curl_json],         [CouchDB statistics])\nAC_PLUGIN([curl_xml],            [$plugin_curl_xml],          [CURL generic xml statistics])\nAC_PLUGIN([dbi],                 [$with_libdbi],              [General database statistics])\nAC_PLUGIN([df],                  [$plugin_df],                [Filesystem usage statistics])\nAC_PLUGIN([disk],                [$plugin_disk],              [Disk usage statistics])\nAC_PLUGIN([dns],                 [$with_libpcap],             [DNS traffic analysis])\nAC_PLUGIN([dpdkevents],          [$plugin_dpdkevents],        [Events from DPDK])\nAC_PLUGIN([dpdkstat],            [$plugin_dpdkstat],          [Stats from DPDK])\nAC_PLUGIN([drbd],                [$plugin_drbd],              [DRBD statistics])\nAC_PLUGIN([email],               [yes],                       [EMail statistics])\nAC_PLUGIN([entropy],             [$plugin_entropy],           [Entropy statistics])\nAC_PLUGIN([ethstat],             [$plugin_ethstat],           [Stats from NIC driver])\nAC_PLUGIN([exec],                [yes],                       [Execution of external programs])\nAC_PLUGIN([fhcount],             [$plugin_fhcount],           [File handles statistics])\nAC_PLUGIN([filecount],           [yes],                       [Count files in directories])\nAC_PLUGIN([fscache],             [$plugin_fscache],           [fscache statistics])\nAC_PLUGIN([gmond],               [$with_libganglia],          [Ganglia plugin])\nAC_PLUGIN([gps],                 [$plugin_gps],               [GPS plugin])\nAC_PLUGIN([gpu_nvidia],          [$with_cuda],                [NVIDIA GPU plugin])\nAC_PLUGIN([grpc],                [$plugin_grpc],              [gRPC plugin])\nAC_PLUGIN([hddtemp],             [yes],                       [Query hddtempd])\nAC_PLUGIN([hugepages],           [$plugin_hugepages],         [Hugepages statistics])\nAC_PLUGIN([intel_pmu],           [$with_libjevents],          [Intel performance monitor plugin])\nAC_PLUGIN([intel_rdt],           [$with_libpqos],             [Intel RDT monitor plugin])\nAC_PLUGIN([interface],           [$plugin_interface],         [Interface traffic statistics])\nAC_PLUGIN([ipc],                 [$plugin_ipc],               [IPC statistics])\nAC_PLUGIN([ipmi],                [$plugin_ipmi],              [IPMI sensor statistics])\nAC_PLUGIN([iptables],            [$with_libiptc],             [IPTables rule counters])\nAC_PLUGIN([ipvs],                [$plugin_ipvs],              [IPVS connection statistics])\nAC_PLUGIN([irq],                 [$plugin_irq],               [IRQ statistics])\nAC_PLUGIN([java],                [$with_java],                [Embed the Java Virtual Machine])\nAC_PLUGIN([load],                [$plugin_load],              [System load])\nAC_PLUGIN([log_logstash],        [$plugin_log_logstash],      [Logstash json_event compatible logging])\nAC_PLUGIN([logfile],             [yes],                       [File logging plugin])\nAC_PLUGIN([lpar],                [$with_perfstat],            [AIX logical partitions statistics])\nAC_PLUGIN([lua],                 [$with_liblua],              [Lua plugin])\nAC_PLUGIN([lvm],                 [$with_liblvm2app],          [LVM statistics])\nAC_PLUGIN([madwifi],             [$have_linux_wireless_h],    [Madwifi wireless statistics])\nAC_PLUGIN([match_empty_counter], [yes],                       [The empty counter match])\nAC_PLUGIN([match_hashed],        [yes],                       [The hashed match])\nAC_PLUGIN([match_regex],         [yes],                       [The regex match])\nAC_PLUGIN([match_timediff],      [yes],                       [The timediff match])\nAC_PLUGIN([match_value],         [yes],                       [The value match])\nAC_PLUGIN([mbmon],               [yes],                       [Query mbmond])\nAC_PLUGIN([mcelog],              [$plugin_mcelog],            [Machine Check Exceptions notifications])\nAC_PLUGIN([md],                  [$have_linux_raid_md_u_h],   [md (Linux software RAID) devices])\nAC_PLUGIN([memcachec],           [$with_libmemcached],        [memcachec statistics])\nAC_PLUGIN([memcached],           [yes],                       [memcached statistics])\nAC_PLUGIN([memory],              [$plugin_memory],            [Memory usage])\nAC_PLUGIN([mic],                 [$with_mic],                 [Intel Many Integrated Core stats])\nAC_PLUGIN([modbus],              [$with_libmodbus],           [Modbus plugin])\nAC_PLUGIN([mqtt],                [$with_libmosquitto],        [MQTT output plugin])\nAC_PLUGIN([multimeter],          [$plugin_multimeter],        [Read multimeter values])\nAC_PLUGIN([mysql],               [$with_libmysql],            [MySQL statistics])\nAC_PLUGIN([netapp],              [$with_libnetapp],           [NetApp plugin])\nAC_PLUGIN([netlink],             [$with_libmnl],              [Enhanced Linux network statistics])\nAC_PLUGIN([network],             [yes],                       [Network communication plugin])\nAC_PLUGIN([nfs],                 [$plugin_nfs],               [NFS statistics])\nAC_PLUGIN([nginx],               [$with_libcurl],             [nginx statistics])\nAC_PLUGIN([notify_desktop],      [$with_libnotify],           [Desktop notifications])\nAC_PLUGIN([notify_email],        [$with_libesmtp],            [Email notifier])\nAC_PLUGIN([notify_nagios],       [yes],                       [Nagios notification plugin])\nAC_PLUGIN([ntpd],                [yes],                       [NTPd statistics])\nAC_PLUGIN([numa],                [$plugin_numa],              [NUMA virtual memory statistics])\nAC_PLUGIN([nut],                 [$with_libupsclient],        [Network UPS tools statistics])\nAC_PLUGIN([olsrd],               [yes],                       [olsrd statistics])\nAC_PLUGIN([onewire],             [$with_libowcapi],           [OneWire sensor statistics])\nAC_PLUGIN([openldap],            [$with_libldap],             [OpenLDAP statistics])\nAC_PLUGIN([openvpn],             [yes],                       [OpenVPN client statistics])\nAC_PLUGIN([oracle],              [$with_oracle],              [Oracle plugin])\nAC_PLUGIN([ovs_events],          [$plugin_ovs_events],        [OVS events plugin])\nAC_PLUGIN([ovs_stats],           [$plugin_ovs_stats],         [OVS statistics plugin])\nAC_PLUGIN([pcie_errors],         [$plugin_pcie_errors],       [PCIe errors plugin])\nAC_PLUGIN([perl],                [$plugin_perl],              [Embed a Perl interpreter])\nAC_PLUGIN([pf],                  [$have_net_pfvar_h],         [BSD packet filter (PF) statistics])\n# FIXME: Check for libevent, too.\nAC_PLUGIN([pinba],               [$plugin_pinba],             [Pinba statistics])\nAC_PLUGIN([ping],                [$with_liboping],            [Network latency statistics])\nAC_PLUGIN([postgresql],          [$with_libpq],               [PostgreSQL database statistics])\nAC_PLUGIN([powerdns],            [yes],                       [PowerDNS statistics])\nAC_PLUGIN([processes],           [$plugin_processes],         [Process statistics])\nAC_PLUGIN([procevent],           [$plugin_procevent],         [Process event (start, stop) statistics])\nAC_PLUGIN([protocols],           [$plugin_protocols],         [Protocol (IP, TCP, ...) statistics])\nAC_PLUGIN([python],              [$plugin_python],            [Embed a Python interpreter])\nAC_PLUGIN([redis],               [$with_libhiredis],          [Redis plugin])\nAC_PLUGIN([routeros],            [$with_librouteros],         [RouterOS plugin])\nAC_PLUGIN([rrdcached],           [$librrd_rrdc_update],       [RRDTool output plugin])\nAC_PLUGIN([rrdtool],             [$with_librrd],              [RRDTool output plugin])\nAC_PLUGIN([sensors],             [$with_libsensors],          [lm_sensors statistics])\nAC_PLUGIN([serial],              [$plugin_serial],            [serial port traffic])\nAC_PLUGIN([sigrok],              [$with_libsigrok],           [sigrok acquisition sources])\nAC_PLUGIN([smart],               [$plugin_smart],             [SMART statistics])\nAC_PLUGIN([snmp],                [$with_libnetsnmp],          [SNMP querying plugin])\nAC_PLUGIN([snmp_agent],          [$with_libnetsnmpagent],     [SNMP agent plugin])\nAC_PLUGIN([statsd],              [yes],                       [StatsD plugin])\nAC_PLUGIN([swap],                [$plugin_swap],              [Swap usage statistics])\nAC_PLUGIN([synproxy],            [$plugin_synproxy],          [Synproxy stats plugin])\nAC_PLUGIN([sysevent],            [$plugin_sysevent],          [rsyslog events])\nAC_PLUGIN([syslog],              [$have_syslog],              [Syslog logging plugin])\nAC_PLUGIN([table],               [yes],                       [Parsing of tabular data])\nAC_PLUGIN([tail],                [yes],                       [Parsing of logfiles])\nAC_PLUGIN([tail_csv],            [yes],                       [Parsing of CSV files])\nAC_PLUGIN([tape],                [$plugin_tape],              [Tape drive statistics])\nAC_PLUGIN([target_notification], [yes],                       [The notification target])\nAC_PLUGIN([target_replace],      [yes],                       [The replace target])\nAC_PLUGIN([target_scale],        [yes],                       [The scale target])\nAC_PLUGIN([target_set],          [yes],                       [The set target])\nAC_PLUGIN([target_v5upgrade],    [yes],                       [The v5upgrade target])\nAC_PLUGIN([tcpconns],            [$plugin_tcpconns],          [TCP connection statistics])\nAC_PLUGIN([teamspeak2],          [yes],                       [TeamSpeak2 server statistics])\nAC_PLUGIN([ted],                 [$plugin_ted],               [Read The Energy Detective values])\nAC_PLUGIN([thermal],             [$plugin_thermal],           [Linux ACPI thermal zone statistics])\nAC_PLUGIN([threshold],           [yes],                       [Threshold checking plugin])\nAC_PLUGIN([tokyotyrant],         [$with_libtokyotyrant],      [TokyoTyrant database statistics])\nAC_PLUGIN([turbostat],           [$plugin_turbostat],         [Advanced statistic on Intel cpu states])\nAC_PLUGIN([unixsock],            [yes],                       [Unixsock communication plugin])\nAC_PLUGIN([uptime],              [$plugin_uptime],            [Uptime statistics])\nAC_PLUGIN([users],               [$plugin_users],             [User statistics])\nAC_PLUGIN([uuid],                [yes],                       [UUID as hostname plugin])\nAC_PLUGIN([varnish],             [$with_libvarnish],          [Varnish cache statistics])\nAC_PLUGIN([virt],                [$plugin_virt],              [Virtual machine statistics])\nAC_PLUGIN([vmem],                [$plugin_vmem],              [Virtual memory statistics])\nAC_PLUGIN([vserver],             [$plugin_vserver],           [Linux VServer statistics])\nAC_PLUGIN([wireless],            [$plugin_wireless],          [Wireless statistics])\nAC_PLUGIN([write_graphite],      [yes],                       [Graphite / Carbon output plugin])\nAC_PLUGIN([write_http],          [$with_libcurl],             [HTTP output plugin])\nAC_PLUGIN([write_kafka],         [$with_librdkafka],          [Kafka output plugin])\nAC_PLUGIN([write_log],           [yes],                       [Log output plugin])\nAC_PLUGIN([write_mongodb],       [$with_libmongoc],           [MongoDB output plugin])\nAC_PLUGIN([write_prometheus],    [$plugin_write_prometheus],  [Prometheus write plugin])\nAC_PLUGIN([write_redis],         [$with_libhiredis],          [Redis output plugin])\nAC_PLUGIN([write_riemann],       [$with_libriemann_client],   [Riemann output plugin])\nAC_PLUGIN([write_sensu],         [yes],                       [Sensu output plugin])\nAC_PLUGIN([write_stackdriver],   [$plugin_write_stackdriver], [Google Stackdriver Monitoring output plugin])\nAC_PLUGIN([write_syslog],        [yes],                       [Syslog output plugin])\nAC_PLUGIN([write_tsdb],          [yes],                       [TSDB output plugin])\nAC_PLUGIN([xencpu],              [$plugin_xencpu],            [Xen Host CPU usage])\nAC_PLUGIN([xmms],                [$with_libxmms],             [XMMS statistics])\nAC_PLUGIN([zfs_arc],             [$plugin_zfs_arc],           [ZFS ARC statistics])\nAC_PLUGIN([zone],                [$plugin_zone],              [Solaris container statistics])\nAC_PLUGIN([zookeeper],           [yes],                       [Zookeeper statistics])\n\ndnl Default configuration file\n# Load either syslog or logfile\nLOAD_PLUGIN_SYSLOG=\"\"\nLOAD_PLUGIN_LOGFILE=\"\"\nLOAD_PLUGIN_LOG_LOGSTASH=\"\"\n\nAC_MSG_CHECKING([which default log plugin to load])\ndefault_log_plugin=\"none\"\nif test \"x$enable_syslog\" = \"xyes\"; then\n  default_log_plugin=\"syslog\"\nelse\n  LOAD_PLUGIN_SYSLOG=\"##\"\nfi\n\nif test \"x$enable_logfile\" = \"xyes\"; then\n  if test \"x$default_log_plugin\" = \"xnone\"; then\n    default_log_plugin=\"logfile\"\n  else\n    LOAD_PLUGIN_LOGFILE=\"#\"\n  fi\nelse\n  LOAD_PLUGIN_LOGFILE=\"##\"\nfi\n\nif test \"x$enable_log_logstash\" = \"xyes\"; then\n  LOAD_PLUGIN_LOG_LOGSTASH=\"#\"\nelse\n  LOAD_PLUGIN_LOG_LOGSTASH=\"##\"\nfi\n\nAC_MSG_RESULT([$default_log_plugin])\n\nAC_SUBST([LOAD_PLUGIN_SYSLOG])\nAC_SUBST([LOAD_PLUGIN_LOGFILE])\nAC_SUBST([LOAD_PLUGIN_LOG_LOGSTASH])\n\nif test \"x$enable_debug\" = \"xyes\"; then\n  DEFAULT_LOG_LEVEL=\"debug\"\nelse\n  DEFAULT_LOG_LEVEL=\"info\"\nfi\nAC_SUBST([DEFAULT_LOG_LEVEL])\n\n# Load only one of rrdtool, network, csv in the default config.\nLOAD_PLUGIN_RRDTOOL=\"\"\nLOAD_PLUGIN_NETWORK=\"\"\nLOAD_PLUGIN_CSV=\"\"\n\nAC_MSG_CHECKING([which default write plugin to load])\ndefault_write_plugin=\"none\"\nif test \"x$enable_rrdtool\" = \"xyes\"; then\n  default_write_plugin=\"rrdtool\"\nelse\n  LOAD_PLUGIN_RRDTOOL=\"##\"\nfi\n\nif test \"x$enable_network\" = \"xyes\"; then\n  if test \"x$default_write_plugin\" = \"xnone\"; then\n    default_write_plugin=\"network\"\n  else\n    LOAD_PLUGIN_NETWORK=\"#\"\n  fi\nelse\n  LOAD_PLUGIN_NETWORK=\"##\"\nfi\n\nif test \"x$enable_csv\" = \"xyes\"; then\n  if test \"x$default_write_plugin\" = \"xnone\"; then\n    default_write_plugin=\"csv\"\n  else\n    LOAD_PLUGIN_CSV=\"#\"\n  fi\nelse\n  LOAD_PLUGIN_CSV=\"##\"\nfi\nAC_MSG_RESULT([$default_write_plugin])\n\nAC_SUBST([LOAD_PLUGIN_RRDTOOL])\nAC_SUBST([LOAD_PLUGIN_NETWORK])\nAC_SUBST([LOAD_PLUGIN_CSV])\n\ndnl Perl bindings\nPERL_BINDINGS_OPTIONS=\"PREFIX=${prefix}\"\nAC_ARG_WITH(perl-bindings, [AS_HELP_STRING([--with-perl-bindings@<:@=OPTIONS@:>@], [Options passed to \"perl Makefile.PL\".])],\n[\n  if test \"x$withval\" != \"xno\" && test \"x$withval\" != \"xyes\"; then\n    PERL_BINDINGS_OPTIONS=\"$withval\"\n    with_perl_bindings=\"yes\"\n  else\n    with_perl_bindings=\"$withval\"\n  fi\n],\n[\n  if test \"x$PERL\" != \"x\"; then\n    with_perl_bindings=\"yes\"\n  else\n    with_perl_bindings=\"no (no perl interpreter found)\"\n  fi\n])\n\nif test \"x$with_perl_bindings\" = \"xyes\"; then\n  AC_MSG_CHECKING([for the ExtUtils::MakeMaker module])\n  if $PERL -MExtUtils::MakeMaker -e '' 2>/dev/null; then\n    AC_MSG_RESULT([yes])\n  else\n    AC_MSG_RESULT([no])\n    with_perl_bindings=\"no (ExtUtils::MakeMaker not found)\"\n  fi\nfi\n\nif test \"x$with_perl_bindings\" = \"xyes\"; then\n  PERL_BINDINGS=\"perl\"\nelse\n  PERL_BINDINGS=\"\"\nfi\n\nAC_SUBST([PERL_BINDINGS])\nAC_SUBST([PERL_BINDINGS_OPTIONS])\n\ndnl libcollectdclient\nLCC_VERSION_MAJOR=`echo $PACKAGE_VERSION | cut -d'.' -f1`\nLCC_VERSION_MINOR=`echo $PACKAGE_VERSION | cut -d'.' -f2`\nLCC_VERSION_PATCH=`echo $PACKAGE_VERSION | cut -d'.' -f3`\n\nLCC_VERSION_EXTRA=`echo $PACKAGE_VERSION | cut -d'.' -f4-`\n\nLCC_VERSION_STRING=\"$LCC_VERSION_MAJOR.$LCC_VERSION_MINOR.$LCC_VERSION_PATCH\"\n\nAC_SUBST([LCC_VERSION_MAJOR])\nAC_SUBST([LCC_VERSION_MINOR])\nAC_SUBST([LCC_VERSION_PATCH])\nAC_SUBST([LCC_VERSION_EXTRA])\nAC_SUBST([LCC_VERSION_STRING])\n\nAC_CONFIG_FILES([src/libcollectdclient/collectd/lcc_features.h])\n\nif test \"x$GCC\" = \"xyes\"; then\n  AM_CFLAGS=\"-Wall\"\n  AM_CXXFLAGS=\"-Wall\"\n  if test \"x$enable_werror\" != \"xno\"; then\n    AM_CFLAGS=\"$AM_CFLAGS -Werror\"\n    AM_CXXFLAGS=\"$AM_CXXFLAGS -Werror\"\n  fi\nfi\n\nAC_SUBST([AM_CFLAGS])\nAC_SUBST([AM_CXXFLAGS])\n\nAC_CONFIG_FILES([ \\\n  Makefile \\\n  src/collectd.conf \\\n  src/libcollectdclient/libcollectdclient.pc \\\n])\n\nAC_OUTPUT\n\nif test \"x$with_librrd\" = \"xyes\" && test \"x$librrd_threadsafe\" != \"xyes\"; then\n  with_librrd=\"yes (warning: librrd is not thread-safe)\"\nfi\n\nif test \"x$with_libperl\" = \"xyes\"; then\n  with_libperl=\"yes (version `$PERL -MConfig -e 'print $Config{version};'`)\"\nelse\n  enable_perl=\"no (needs libperl)\"\nfi\n\nif test \"x$enable_perl\" = \"xno\" && test \"x$c_cv_have_perl_ithreads\" = \"xno\"; then\n  enable_perl=\"no (libperl doesn't support ithreads)\"\nfi\n\nif test \"x$with_perl_bindings\" = \"xyes\" && test \"x$PERL_BINDINGS_OPTIONS\" != \"x\"; then\n  with_perl_bindings=\"yes ($PERL_BINDINGS_OPTIONS)\"\nfi\n\nAC_MSG_RESULT()\nAC_MSG_RESULT([Configuration:])\nAC_MSG_RESULT([  Build:])\nAC_MSG_RESULT([    Platform  . . . . . . $ac_system])\nAC_MSG_RESULT([    Compiler vendor . . . $ax_cv_c_compiler_vendor])\nAC_MSG_RESULT([    CC  . . . . . . . . . $CC])\nAC_MSG_RESULT([    CFLAGS  . . . . . . . $AM_CFLAGS $CFLAGS])\nAC_MSG_RESULT([    CXXFLAGS  . . . . . . $AM_CXXFLAGS $CXXFLAGS])\nAC_MSG_RESULT([    CPP . . . . . . . . . $CPP])\nAC_MSG_RESULT([    CPPFLAGS  . . . . . . $CPPFLAGS])\nAC_MSG_RESULT([    GRPC_CPP_PLUGIN . . . $GRPC_CPP_PLUGIN])\nAC_MSG_RESULT([    LD  . . . . . . . . . $LD])\nAC_MSG_RESULT([    LDFLAGS . . . . . . . $LDFLAGS])\nAC_MSG_RESULT([    PROTOC  . . . . . . . $PROTOC])\nAC_MSG_RESULT([    YACC  . . . . . . . . $YACC])\nAC_MSG_RESULT([    YFLAGS  . . . . . . . $YFLAGS])\nAC_MSG_RESULT()\nAC_MSG_RESULT([  Libraries:])\nAC_MSG_RESULT([    intel mic . . . . . . $with_mic])\nAC_MSG_RESULT([    libaquaero5 . . . . . $with_libaquaero5])\nAC_MSG_RESULT([    libatasmart . . . . . $with_libatasmart])\nAC_MSG_RESULT([    libcurl . . . . . . . $with_libcurl])\nAC_MSG_RESULT([    libdbi  . . . . . . . $with_libdbi])\nAC_MSG_RESULT([    libdpdk . . . . . . . $with_libdpdk])\nAC_MSG_RESULT([    libesmtp  . . . . . . $with_libesmtp])\nAC_MSG_RESULT([    libganglia  . . . . . $with_libganglia])\nAC_MSG_RESULT([    libgcrypt . . . . . . $with_libgcrypt])\nAC_MSG_RESULT([    libgps  . . . . . . . $with_libgps])\nAC_MSG_RESULT([    libgrpc++ . . . . . . $with_libgrpcpp])\nAC_MSG_RESULT([    libhiredis  . . . . . $with_libhiredis])\nAC_MSG_RESULT([    libi2c-dev  . . . . . $with_libi2c])\nAC_MSG_RESULT([    libiokit  . . . . . . $with_libiokit])\nAC_MSG_RESULT([    libiptc . . . . . . . $with_libiptc])\nAC_MSG_RESULT([    libjevents  . . . . . $with_libjevents])\nAC_MSG_RESULT([    libjvm  . . . . . . . $with_java])\nAC_MSG_RESULT([    libkstat  . . . . . . $with_kstat])\nAC_MSG_RESULT([    libkvm  . . . . . . . $with_libkvm])\nAC_MSG_RESULT([    libldap . . . . . . . $with_libldap])\nAC_MSG_RESULT([    liblua  . . . . . . . $with_liblua])\nAC_MSG_RESULT([    liblvm2app  . . . . . $with_liblvm2app])\nAC_MSG_RESULT([    libmemcached  . . . . $with_libmemcached])\nAC_MSG_RESULT([    libmicrohttpd . . . . $with_libmicrohttpd])\nAC_MSG_RESULT([    libmnl  . . . . . . . $with_libmnl])\nAC_MSG_RESULT([    libmodbus . . . . . . $with_libmodbus])\nAC_MSG_RESULT([    libmongoc . . . . . . $with_libmongoc])\nAC_MSG_RESULT([    libmosquitto  . . . . $with_libmosquitto])\nAC_MSG_RESULT([    libmysql  . . . . . . $with_libmysql])\nAC_MSG_RESULT([    libnetapp . . . . . . $with_libnetapp])\nAC_MSG_RESULT([    libnetsnmp  . . . . . $with_libnetsnmp])\nAC_MSG_RESULT([    libnetsnmpagent . . . $with_libnetsnmpagent])\nAC_MSG_RESULT([    libnotify . . . . . . $with_libnotify])\nAC_MSG_RESULT([    libnvidia-ml  . . . . $with_cuda])\nAC_MSG_RESULT([    libopenipmi . . . . . $with_libopenipmipthread])\nAC_MSG_RESULT([    liboping  . . . . . . $with_liboping])\nAC_MSG_RESULT([    libowcapi . . . . . . $with_libowcapi])\nAC_MSG_RESULT([    libpcap . . . . . . . $with_libpcap])\nAC_MSG_RESULT([    libperfstat . . . . . $with_perfstat])\nAC_MSG_RESULT([    libperl . . . . . . . $with_libperl])\nAC_MSG_RESULT([    libpq . . . . . . . . $with_libpq])\nAC_MSG_RESULT([    libpqos . . . . . . . $with_libpqos])\nAC_MSG_RESULT([    libprotobuf . . . . . $with_libprotobuf])\nAC_MSG_RESULT([    libprotobuf-c . . . . $with_libprotobuf_c])\nAC_MSG_RESULT([    libpython . . . . . . $with_libpython])\nAC_MSG_RESULT([    libqpid-proton .  . . $with_libqpid_proton])\nAC_MSG_RESULT([    librabbitmq . . . . . $with_librabbitmq])\nAC_MSG_RESULT([    libriemann-client . . $with_libriemann_client])\nAC_MSG_RESULT([    librdkafka  . . . . . $with_librdkafka])\nAC_MSG_RESULT([    librouteros . . . . . $with_librouteros])\nAC_MSG_RESULT([    librrd  . . . . . . . $with_librrd])\nAC_MSG_RESULT([    libsensors  . . . . . $with_libsensors])\nAC_MSG_RESULT([    libsigrok   . . . . . $with_libsigrok])\nAC_MSG_RESULT([    libssl  . . . . . . . $with_libssl])\nAC_MSG_RESULT([    libstatgrab . . . . . $with_libstatgrab])\nAC_MSG_RESULT([    libtokyotyrant  . . . $with_libtokyotyrant])\nAC_MSG_RESULT([    libudev . . . . . . . $with_libudev])\nAC_MSG_RESULT([    libupsclient  . . . . $with_libupsclient])\nAC_MSG_RESULT([    libvarnish  . . . . . $with_libvarnish])\nAC_MSG_RESULT([    libvirt . . . . . . . $with_libvirt])\nAC_MSG_RESULT([    libxenctrl  . . . . . $with_libxenctrl])\nAC_MSG_RESULT([    libxml2 . . . . . . . $with_libxml2])\nAC_MSG_RESULT([    libxmms . . . . . . . $with_libxmms])\nAC_MSG_RESULT([    libyajl . . . . . . . $with_libyajl])\nAC_MSG_RESULT([    oracle  . . . . . . . $with_oracle])\nAC_MSG_RESULT([    protobuf-c  . . . . . $have_protoc_c])\nAC_MSG_RESULT([    protoc 3  . . . . . . $have_protoc3])\nAC_MSG_RESULT()\nAC_MSG_RESULT([  Features:])\nAC_MSG_RESULT([    daemon mode . . . . . $enable_daemon])\nAC_MSG_RESULT([    debug . . . . . . . . $enable_debug])\nAC_MSG_RESULT()\nAC_MSG_RESULT([  Bindings:])\nAC_MSG_RESULT([    perl  . . . . . . . . $with_perl_bindings])\nAC_MSG_RESULT()\nAC_MSG_RESULT([  Modules:])\nAC_MSG_RESULT([    aggregation . . . . . $enable_aggregation])\nAC_MSG_RESULT([    amqp    . . . . . . . $enable_amqp])\nAC_MSG_RESULT([    amqp1   . . . . . . . $enable_amqp1])\nAC_MSG_RESULT([    apache  . . . . . . . $enable_apache])\nAC_MSG_RESULT([    apcups  . . . . . . . $enable_apcups])\nAC_MSG_RESULT([    apple_sensors . . . . $enable_apple_sensors])\nAC_MSG_RESULT([    aquaero . . . . . . . $enable_aquaero])\nAC_MSG_RESULT([    ascent  . . . . . . . $enable_ascent])\nAC_MSG_RESULT([    barometer . . . . . . $enable_barometer])\nAC_MSG_RESULT([    battery . . . . . . . $enable_battery])\nAC_MSG_RESULT([    bind  . . . . . . . . $enable_bind])\nAC_MSG_RESULT([    ceph  . . . . . . . . $enable_ceph])\nAC_MSG_RESULT([    cgroups . . . . . . . $enable_cgroups])\nAC_MSG_RESULT([    chrony. . . . . . . . $enable_chrony])\nAC_MSG_RESULT([    check_uptime. . . . . $enable_check_uptime])\nAC_MSG_RESULT([    connectivity. . . . . $enable_connectivity])\nAC_MSG_RESULT([    conntrack . . . . . . $enable_conntrack])\nAC_MSG_RESULT([    contextswitch . . . . $enable_contextswitch])\nAC_MSG_RESULT([    cpu . . . . . . . . . $enable_cpu])\nAC_MSG_RESULT([    cpufreq . . . . . . . $enable_cpufreq])\nAC_MSG_RESULT([    cpusleep  . . . . . . $enable_cpusleep])\nAC_MSG_RESULT([    csv . . . . . . . . . $enable_csv])\nAC_MSG_RESULT([    curl  . . . . . . . . $enable_curl])\nAC_MSG_RESULT([    curl_json . . . . . . $enable_curl_json])\nAC_MSG_RESULT([    curl_xml  . . . . . . $enable_curl_xml])\nAC_MSG_RESULT([    dbi . . . . . . . . . $enable_dbi])\nAC_MSG_RESULT([    df  . . . . . . . . . $enable_df])\nAC_MSG_RESULT([    disk  . . . . . . . . $enable_disk])\nAC_MSG_RESULT([    dns . . . . . . . . . $enable_dns])\nAC_MSG_RESULT([    dpdkevents. . . . . . $enable_dpdkevents])\nAC_MSG_RESULT([    dpdkstat  . . . . . . $enable_dpdkstat])\nAC_MSG_RESULT([    drbd  . . . . . . . . $enable_drbd])\nAC_MSG_RESULT([    email . . . . . . . . $enable_email])\nAC_MSG_RESULT([    entropy . . . . . . . $enable_entropy])\nAC_MSG_RESULT([    ethstat . . . . . . . $enable_ethstat])\nAC_MSG_RESULT([    exec  . . . . . . . . $enable_exec])\nAC_MSG_RESULT([    fhcount . . . . . . . $enable_fhcount])\nAC_MSG_RESULT([    filecount . . . . . . $enable_filecount])\nAC_MSG_RESULT([    fscache . . . . . . . $enable_fscache])\nAC_MSG_RESULT([    gmond . . . . . . . . $enable_gmond])\nAC_MSG_RESULT([    gps . . . . . . . . . $enable_gps])\nAC_MSG_RESULT([    gpu_nvidia  . . . . . $enable_gpu_nvidia])\nAC_MSG_RESULT([    grpc  . . . . . . . . $enable_grpc])\nAC_MSG_RESULT([    hddtemp . . . . . . . $enable_hddtemp])\nAC_MSG_RESULT([    hugepages . . . . . . $enable_hugepages])\nAC_MSG_RESULT([    intel_pmu . . . . . . $enable_intel_pmu])\nAC_MSG_RESULT([    intel_rdt . . . . . . $enable_intel_rdt])\nAC_MSG_RESULT([    interface . . . . . . $enable_interface])\nAC_MSG_RESULT([    ipc . . . . . . . . . $enable_ipc])\nAC_MSG_RESULT([    ipmi  . . . . . . . . $enable_ipmi])\nAC_MSG_RESULT([    iptables  . . . . . . $enable_iptables])\nAC_MSG_RESULT([    ipvs  . . . . . . . . $enable_ipvs])\nAC_MSG_RESULT([    irq . . . . . . . . . $enable_irq])\nAC_MSG_RESULT([    java  . . . . . . . . $enable_java])\nAC_MSG_RESULT([    load  . . . . . . . . $enable_load])\nAC_MSG_RESULT([    logfile . . . . . . . $enable_logfile])\nAC_MSG_RESULT([    log_logstash  . . . . $enable_log_logstash])\nAC_MSG_RESULT([    lpar  . . . . . . . . $enable_lpar])\nAC_MSG_RESULT([    lua . . . . . . . . . $enable_lua])\nAC_MSG_RESULT([    lvm . . . . . . . . . $enable_lvm])\nAC_MSG_RESULT([    madwifi . . . . . . . $enable_madwifi])\nAC_MSG_RESULT([    match_empty_counter . $enable_match_empty_counter])\nAC_MSG_RESULT([    match_hashed  . . . . $enable_match_hashed])\nAC_MSG_RESULT([    match_regex . . . . . $enable_match_regex])\nAC_MSG_RESULT([    match_timediff  . . . $enable_match_timediff])\nAC_MSG_RESULT([    match_value . . . . . $enable_match_value])\nAC_MSG_RESULT([    mbmon . . . . . . . . $enable_mbmon])\nAC_MSG_RESULT([    mcelog  . . . . . . . $enable_mcelog])\nAC_MSG_RESULT([    md  . . . . . . . . . $enable_md])\nAC_MSG_RESULT([    memcachec . . . . . . $enable_memcachec])\nAC_MSG_RESULT([    memcached . . . . . . $enable_memcached])\nAC_MSG_RESULT([    memory  . . . . . . . $enable_memory])\nAC_MSG_RESULT([    mic . . . . . . . . . $enable_mic])\nAC_MSG_RESULT([    modbus  . . . . . . . $enable_modbus])\nAC_MSG_RESULT([    mqtt  . . . . . . . . $enable_mqtt])\nAC_MSG_RESULT([    multimeter  . . . . . $enable_multimeter])\nAC_MSG_RESULT([    mysql . . . . . . . . $enable_mysql])\nAC_MSG_RESULT([    netapp  . . . . . . . $enable_netapp])\nAC_MSG_RESULT([    netlink . . . . . . . $enable_netlink])\nAC_MSG_RESULT([    network . . . . . . . $enable_network])\nAC_MSG_RESULT([    nfs . . . . . . . . . $enable_nfs])\nAC_MSG_RESULT([    nginx . . . . . . . . $enable_nginx])\nAC_MSG_RESULT([    notify_desktop  . . . $enable_notify_desktop])\nAC_MSG_RESULT([    notify_email  . . . . $enable_notify_email])\nAC_MSG_RESULT([    notify_nagios . . . . $enable_notify_nagios])\nAC_MSG_RESULT([    ntpd  . . . . . . . . $enable_ntpd])\nAC_MSG_RESULT([    numa  . . . . . . . . $enable_numa])\nAC_MSG_RESULT([    nut . . . . . . . . . $enable_nut])\nAC_MSG_RESULT([    olsrd . . . . . . . . $enable_olsrd])\nAC_MSG_RESULT([    onewire . . . . . . . $enable_onewire])\nAC_MSG_RESULT([    openldap  . . . . . . $enable_openldap])\nAC_MSG_RESULT([    openvpn . . . . . . . $enable_openvpn])\nAC_MSG_RESULT([    oracle  . . . . . . . $enable_oracle])\nAC_MSG_RESULT([    ovs_events  . . . . . $enable_ovs_events])\nAC_MSG_RESULT([    ovs_stats . . . . . . $enable_ovs_stats])\nAC_MSG_RESULT([    pcie_errors . . . . . $enable_pcie_errors])\nAC_MSG_RESULT([    perl  . . . . . . . . $enable_perl])\nAC_MSG_RESULT([    pf  . . . . . . . . . $enable_pf])\nAC_MSG_RESULT([    pinba . . . . . . . . $enable_pinba])\nAC_MSG_RESULT([    ping  . . . . . . . . $enable_ping])\nAC_MSG_RESULT([    postgresql  . . . . . $enable_postgresql])\nAC_MSG_RESULT([    powerdns  . . . . . . $enable_powerdns])\nAC_MSG_RESULT([    processes . . . . . . $enable_processes])\nAC_MSG_RESULT([    procevent . . . . . . $enable_procevent])\nAC_MSG_RESULT([    protocols . . . . . . $enable_protocols])\nAC_MSG_RESULT([    python  . . . . . . . $enable_python])\nAC_MSG_RESULT([    redis . . . . . . . . $enable_redis])\nAC_MSG_RESULT([    routeros  . . . . . . $enable_routeros])\nAC_MSG_RESULT([    rrdcached . . . . . . $enable_rrdcached])\nAC_MSG_RESULT([    rrdtool . . . . . . . $enable_rrdtool])\nAC_MSG_RESULT([    sensors . . . . . . . $enable_sensors])\nAC_MSG_RESULT([    serial  . . . . . . . $enable_serial])\nAC_MSG_RESULT([    sigrok  . . . . . . . $enable_sigrok])\nAC_MSG_RESULT([    smart . . . . . . . . $enable_smart])\nAC_MSG_RESULT([    snmp  . . . . . . . . $enable_snmp])\nAC_MSG_RESULT([    snmp_agent  . . . . . $enable_snmp_agent])\nAC_MSG_RESULT([    statsd  . . . . . . . $enable_statsd])\nAC_MSG_RESULT([    swap  . . . . . . . . $enable_swap])\nAC_MSG_RESULT([    synproxy  . . . . . . $enable_synproxy])\nAC_MSG_RESULT([    sysevent. . . . . . . $enable_sysevent])\nAC_MSG_RESULT([    syslog  . . . . . . . $enable_syslog])\nAC_MSG_RESULT([    table . . . . . . . . $enable_table])\nAC_MSG_RESULT([    tail_csv  . . . . . . $enable_tail_csv])\nAC_MSG_RESULT([    tail  . . . . . . . . $enable_tail])\nAC_MSG_RESULT([    tape  . . . . . . . . $enable_tape])\nAC_MSG_RESULT([    target_notification . $enable_target_notification])\nAC_MSG_RESULT([    target_replace  . . . $enable_target_replace])\nAC_MSG_RESULT([    target_scale  . . . . $enable_target_scale])\nAC_MSG_RESULT([    target_set  . . . . . $enable_target_set])\nAC_MSG_RESULT([    target_v5upgrade  . . $enable_target_v5upgrade])\nAC_MSG_RESULT([    tcpconns  . . . . . . $enable_tcpconns])\nAC_MSG_RESULT([    teamspeak2  . . . . . $enable_teamspeak2])\nAC_MSG_RESULT([    ted . . . . . . . . . $enable_ted])\nAC_MSG_RESULT([    thermal . . . . . . . $enable_thermal])\nAC_MSG_RESULT([    threshold . . . . . . $enable_threshold])\nAC_MSG_RESULT([    tokyotyrant . . . . . $enable_tokyotyrant])\nAC_MSG_RESULT([    turbostat . . . . . . $enable_turbostat])\nAC_MSG_RESULT([    unixsock  . . . . . . $enable_unixsock])\nAC_MSG_RESULT([    uptime  . . . . . . . $enable_uptime])\nAC_MSG_RESULT([    users . . . . . . . . $enable_users])\nAC_MSG_RESULT([    uuid  . . . . . . . . $enable_uuid])\nAC_MSG_RESULT([    varnish . . . . . . . $enable_varnish])\nAC_MSG_RESULT([    virt  . . . . . . . . $enable_virt])\nAC_MSG_RESULT([    vmem  . . . . . . . . $enable_vmem])\nAC_MSG_RESULT([    vserver . . . . . . . $enable_vserver])\nAC_MSG_RESULT([    wireless  . . . . . . $enable_wireless])\nAC_MSG_RESULT([    write_graphite  . . . $enable_write_graphite])\nAC_MSG_RESULT([    write_http  . . . . . $enable_write_http])\nAC_MSG_RESULT([    write_kafka . . . . . $enable_write_kafka])\nAC_MSG_RESULT([    write_log . . . . . . $enable_write_log])\nAC_MSG_RESULT([    write_mongodb . . . . $enable_write_mongodb])\nAC_MSG_RESULT([    write_prometheus. . . $enable_write_prometheus])\nAC_MSG_RESULT([    write_redis . . . . . $enable_write_redis])\nAC_MSG_RESULT([    write_riemann . . . . $enable_write_riemann])\nAC_MSG_RESULT([    write_sensu . . . . . $enable_write_sensu])\nAC_MSG_RESULT([    write_stackdriver . . $enable_write_stackdriver])\nAC_MSG_RESULT([    write_syslog . .  . . $enable_write_syslog])\nAC_MSG_RESULT([    write_tsdb  . . . . . $enable_write_tsdb])\nAC_MSG_RESULT([    xencpu  . . . . . . . $enable_xencpu])\nAC_MSG_RESULT([    xmms  . . . . . . . . $enable_xmms])\nAC_MSG_RESULT([    zfs_arc . . . . . . . $enable_zfs_arc])\nAC_MSG_RESULT([    zone  . . . . . . . . $enable_zone])\nAC_MSG_RESULT([    zookeeper . . . . . . $enable_zookeeper])\nAC_MSG_RESULT()\n\nif test \"x$dependency_error\" = \"xyes\"; then\n  AC_MSG_ERROR(\"Some plugins are missing dependencies - see the summary above for details\")\nfi\n\nif test \"x$dependency_warning\" = \"xyes\"; then\n  AC_MSG_WARN(\"Some plugins seem to have missing dependencies but have been enabled forcibly - see the summary above for details\")\nfi\n\n# vim: set fdm=marker sw=2 sts=2 ts=2 et :\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-collectd-5.10.0-icicefkrlae7wizwnsjlpgrx3lkx7h7i/spack-src/src/daemon/plugin.c": "/**\n * collectd - src/plugin.c\n * Copyright (C) 2005-2014  Florian octo Forster\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Authors:\n *   Florian octo Forster <octo at collectd.org>\n *   Sebastian Harl <sh at tokkee.org>\n **/\n\n/* _GNU_SOURCE is needed in Linux to use pthread_setname_np */\n#define _GNU_SOURCE\n\n#include \"collectd.h\"\n\n#include \"configfile.h\"\n#include \"filter_chain.h\"\n#include \"plugin.h\"\n#include \"utils/avltree/avltree.h\"\n#include \"utils/common/common.h\"\n#include \"utils/heap/heap.h\"\n#include \"utils_cache.h\"\n#include \"utils_complain.h\"\n#include \"utils_llist.h\"\n#include \"utils_random.h\"\n#include \"utils_time.h\"\n\n#ifdef WIN32\n#define EXPORT __declspec(dllexport)\n#include <sys/stat.h>\n#include <unistd.h>\n#else\n#define EXPORT\n#endif\n\n#if HAVE_PTHREAD_NP_H\n#include <pthread_np.h> /* for pthread_set_name_np(3) */\n#endif\n\n#include <dlfcn.h>\n\n/*\n * Private structures\n */\nstruct callback_func_s {\n  void *cf_callback;\n  user_data_t cf_udata;\n  plugin_ctx_t cf_ctx;\n};\ntypedef struct callback_func_s callback_func_t;\n\n#define RF_SIMPLE 0\n#define RF_COMPLEX 1\n#define RF_REMOVE 65535\nstruct read_func_s {\n/* `read_func_t' \"inherits\" from `callback_func_t'.\n * The `rf_super' member MUST be the first one in this structure! */\n#define rf_callback rf_super.cf_callback\n#define rf_udata rf_super.cf_udata\n#define rf_ctx rf_super.cf_ctx\n  callback_func_t rf_super;\n  char rf_group[DATA_MAX_NAME_LEN];\n  char *rf_name;\n  int rf_type;\n  cdtime_t rf_interval;\n  cdtime_t rf_effective_interval;\n  cdtime_t rf_next_read;\n};\ntypedef struct read_func_s read_func_t;\n\nstruct cache_event_func_s {\n  plugin_cache_event_cb callback;\n  char *name;\n  user_data_t user_data;\n  plugin_ctx_t plugin_ctx;\n};\ntypedef struct cache_event_func_s cache_event_func_t;\n\nstruct write_queue_s;\ntypedef struct write_queue_s write_queue_t;\nstruct write_queue_s {\n  value_list_t *vl;\n  plugin_ctx_t ctx;\n  write_queue_t *next;\n};\n\nstruct flush_callback_s {\n  char *name;\n  cdtime_t timeout;\n};\ntypedef struct flush_callback_s flush_callback_t;\n\n/*\n * Private variables\n */\nstatic c_avl_tree_t *plugins_loaded;\n\nstatic llist_t *list_init;\nstatic llist_t *list_write;\nstatic llist_t *list_flush;\nstatic llist_t *list_missing;\nstatic llist_t *list_shutdown;\nstatic llist_t *list_log;\nstatic llist_t *list_notification;\n\nstatic size_t list_cache_event_num;\nstatic cache_event_func_t list_cache_event[32];\n\nstatic fc_chain_t *pre_cache_chain;\nstatic fc_chain_t *post_cache_chain;\n\nstatic c_avl_tree_t *data_sets;\n\nstatic char *plugindir;\n\n#ifndef DEFAULT_MAX_READ_INTERVAL\n#define DEFAULT_MAX_READ_INTERVAL TIME_T_TO_CDTIME_T_STATIC(86400)\n#endif\nstatic c_heap_t *read_heap;\nstatic llist_t *read_list;\nstatic int read_loop = 1;\nstatic pthread_mutex_t read_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t read_cond = PTHREAD_COND_INITIALIZER;\nstatic pthread_t *read_threads;\nstatic size_t read_threads_num;\nstatic cdtime_t max_read_interval = DEFAULT_MAX_READ_INTERVAL;\n\nstatic write_queue_t *write_queue_head;\nstatic write_queue_t *write_queue_tail;\nstatic long write_queue_length;\nstatic bool write_loop = true;\nstatic pthread_mutex_t write_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t write_cond = PTHREAD_COND_INITIALIZER;\nstatic pthread_t *write_threads;\nstatic size_t write_threads_num;\n\nstatic pthread_key_t plugin_ctx_key;\nstatic bool plugin_ctx_key_initialized;\n\nstatic long write_limit_high;\nstatic long write_limit_low;\n\nstatic pthread_mutex_t statistics_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic derive_t stats_values_dropped;\nstatic bool record_statistics;\n\n/*\n * Static functions\n */\nstatic int plugin_dispatch_values_internal(value_list_t *vl);\n\nstatic const char *plugin_get_dir(void) {\n  if (plugindir == NULL)\n    return PLUGINDIR;\n  else\n    return plugindir;\n}\n\nstatic int plugin_update_internal_statistics(void) { /* {{{ */\n  gauge_t copy_write_queue_length = (gauge_t)write_queue_length;\n\n  /* Initialize `vl' */\n  value_list_t vl = VALUE_LIST_INIT;\n  sstrncpy(vl.plugin, \"collectd\", sizeof(vl.plugin));\n  vl.interval = plugin_get_interval();\n\n  /* Write queue */\n  sstrncpy(vl.plugin_instance, \"write_queue\", sizeof(vl.plugin_instance));\n\n  /* Write queue : queue length */\n  vl.values = &(value_t){.gauge = copy_write_queue_length};\n  vl.values_len = 1;\n  sstrncpy(vl.type, \"queue_length\", sizeof(vl.type));\n  vl.type_instance[0] = 0;\n  plugin_dispatch_values(&vl);\n\n  /* Write queue : Values dropped (queue length > low limit) */\n  vl.values = &(value_t){.gauge = (gauge_t)stats_values_dropped};\n  vl.values_len = 1;\n  sstrncpy(vl.type, \"derive\", sizeof(vl.type));\n  sstrncpy(vl.type_instance, \"dropped\", sizeof(vl.type_instance));\n  plugin_dispatch_values(&vl);\n\n  /* Cache */\n  sstrncpy(vl.plugin_instance, \"cache\", sizeof(vl.plugin_instance));\n\n  /* Cache : Nb entry in cache tree */\n  vl.values = &(value_t){.gauge = (gauge_t)uc_get_size()};\n  vl.values_len = 1;\n  sstrncpy(vl.type, \"cache_size\", sizeof(vl.type));\n  vl.type_instance[0] = 0;\n  plugin_dispatch_values(&vl);\n\n  return 0;\n} /* }}} int plugin_update_internal_statistics */\n\nstatic void free_userdata(user_data_t const *ud) /* {{{ */\n{\n  if (ud == NULL)\n    return;\n\n  if ((ud->data != NULL) && (ud->free_func != NULL)) {\n    ud->free_func(ud->data);\n  }\n} /* }}} void free_userdata */\n\nstatic void destroy_callback(callback_func_t *cf) /* {{{ */\n{\n  if (cf == NULL)\n    return;\n  free_userdata(&cf->cf_udata);\n  sfree(cf);\n} /* }}} void destroy_callback */\n\nstatic void destroy_all_callbacks(llist_t **list) /* {{{ */\n{\n  llentry_t *le;\n\n  if (*list == NULL)\n    return;\n\n  le = llist_head(*list);\n  while (le != NULL) {\n    llentry_t *le_next;\n\n    le_next = le->next;\n\n    sfree(le->key);\n    destroy_callback(le->value);\n    le->value = NULL;\n\n    le = le_next;\n  }\n\n  llist_destroy(*list);\n  *list = NULL;\n} /* }}} void destroy_all_callbacks */\n\nstatic void destroy_read_heap(void) /* {{{ */\n{\n  if (read_heap == NULL)\n    return;\n\n  while (42) {\n    read_func_t *rf;\n\n    rf = c_heap_get_root(read_heap);\n    if (rf == NULL)\n      break;\n    sfree(rf->rf_name);\n    destroy_callback((callback_func_t *)rf);\n  }\n\n  c_heap_destroy(read_heap);\n  read_heap = NULL;\n} /* }}} void destroy_read_heap */\n\nstatic int register_callback(llist_t **list, /* {{{ */\n                             const char *name, callback_func_t *cf) {\n\n  if (*list == NULL) {\n    *list = llist_create();\n    if (*list == NULL) {\n      ERROR(\"plugin: register_callback: \"\n            \"llist_create failed.\");\n      destroy_callback(cf);\n      return -1;\n    }\n  }\n\n  char *key = strdup(name);\n  if (key == NULL) {\n    ERROR(\"plugin: register_callback: strdup failed.\");\n    destroy_callback(cf);\n    return -1;\n  }\n\n  llentry_t *le = llist_search(*list, name);\n  if (le == NULL) {\n    le = llentry_create(key, cf);\n    if (le == NULL) {\n      ERROR(\"plugin: register_callback: \"\n            \"llentry_create failed.\");\n      sfree(key);\n      destroy_callback(cf);\n      return -1;\n    }\n\n    llist_append(*list, le);\n  } else {\n    callback_func_t *old_cf = le->value;\n    le->value = cf;\n\n    P_WARNING(\"register_callback: \"\n              \"a callback named `%s' already exists - \"\n              \"overwriting the old entry!\",\n              name);\n\n    destroy_callback(old_cf);\n    sfree(key);\n  }\n\n  return 0;\n} /* }}} int register_callback */\n\nstatic void log_list_callbacks(llist_t **list, /* {{{ */\n                               const char *comment) {\n  char *str;\n  int len;\n  int i;\n  llentry_t *le;\n  int n;\n\n  n = llist_size(*list);\n  if (n == 0) {\n    INFO(\"%s: [none]\", comment);\n    return;\n  }\n\n  char **keys = calloc(n, sizeof(*keys));\n  if (keys == NULL) {\n    ERROR(\"%s: failed to allocate memory for list of callbacks\", comment);\n    return;\n  }\n\n  for (le = llist_head(*list), i = 0, len = 0; le != NULL; le = le->next, i++) {\n    keys[i] = le->key;\n    len += strlen(le->key) + 6;\n  }\n  str = malloc(len + 10);\n  if (str == NULL) {\n    ERROR(\"%s: failed to allocate memory for list of callbacks\", comment);\n  } else {\n    *str = '\\0';\n    strjoin(str, len, keys, n, \"', '\");\n    INFO(\"%s ['%s']\", comment, str);\n    sfree(str);\n  }\n  sfree(keys);\n} /* }}} void log_list_callbacks */\n\nstatic int create_register_callback(llist_t **list, /* {{{ */\n                                    const char *name, void *callback,\n                                    user_data_t const *ud) {\n\n  if (name == NULL || callback == NULL)\n    return EINVAL;\n\n  callback_func_t *cf = calloc(1, sizeof(*cf));\n  if (cf == NULL) {\n    free_userdata(ud);\n    ERROR(\"plugin: create_register_callback: calloc failed.\");\n    return ENOMEM;\n  }\n\n  cf->cf_callback = callback;\n  if (ud == NULL) {\n    cf->cf_udata = (user_data_t){\n        .data = NULL,\n        .free_func = NULL,\n    };\n  } else {\n    cf->cf_udata = *ud;\n  }\n\n  cf->cf_ctx = plugin_get_ctx();\n\n  return register_callback(list, name, cf);\n} /* }}} int create_register_callback */\n\nstatic int plugin_unregister(llist_t *list, const char *name) /* {{{ */\n{\n  llentry_t *e;\n\n  if (list == NULL)\n    return -1;\n\n  e = llist_search(list, name);\n  if (e == NULL)\n    return -1;\n\n  llist_remove(list, e);\n\n  sfree(e->key);\n  destroy_callback(e->value);\n\n  llentry_destroy(e);\n\n  return 0;\n} /* }}} int plugin_unregister */\n\n/* plugin_load_file loads the shared object \"file\" and calls its\n * \"module_register\" function. Returns zero on success, non-zero otherwise. */\nstatic int plugin_load_file(char const *file, bool global) {\n  int flags = RTLD_NOW;\n  if (global)\n    flags |= RTLD_GLOBAL;\n\n  void *dlh = dlopen(file, flags);\n  if (dlh == NULL) {\n    char errbuf[1024] = \"\";\n\n    snprintf(errbuf, sizeof(errbuf),\n             \"dlopen(\\\"%s\\\") failed: %s. \"\n             \"The most common cause for this problem is missing dependencies. \"\n             \"Use ldd(1) to check the dependencies of the plugin / shared \"\n             \"object.\",\n             file, dlerror());\n\n    /* This error is printed to STDERR unconditionally. If list_log is NULL,\n     * plugin_log() will also print to STDERR. We avoid duplicate output by\n     * checking that the list of log handlers, list_log, is not NULL. */\n    fprintf(stderr, \"ERROR: %s\\n\", errbuf);\n    if (list_log != NULL) {\n      ERROR(\"%s\", errbuf);\n    }\n\n    return ENOENT;\n  }\n\n  void (*reg_handle)(void) = dlsym(dlh, \"module_register\");\n  if (reg_handle == NULL) {\n    ERROR(\"Couldn't find symbol \\\"module_register\\\" in \\\"%s\\\": %s\\n\", file,\n          dlerror());\n    dlclose(dlh);\n    return ENOENT;\n  }\n\n  (*reg_handle)();\n  return 0;\n}\n\nstatic void *plugin_read_thread(void __attribute__((unused)) * args) {\n  while (read_loop != 0) {\n    read_func_t *rf;\n    plugin_ctx_t old_ctx;\n    cdtime_t start;\n    cdtime_t now;\n    cdtime_t elapsed;\n    int status;\n    int rf_type;\n    int rc;\n\n    /* Get the read function that needs to be read next.\n     * We don't need to hold \"read_lock\" for the heap, but we need\n     * to call c_heap_get_root() and pthread_cond_wait() in the\n     * same protected block. */\n    pthread_mutex_lock(&read_lock);\n    rf = c_heap_get_root(read_heap);\n    if (rf == NULL) {\n      pthread_cond_wait(&read_cond, &read_lock);\n      pthread_mutex_unlock(&read_lock);\n      continue;\n    }\n    pthread_mutex_unlock(&read_lock);\n\n    if (rf->rf_interval == 0) {\n      /* this should not happen, because the interval is set\n       * for each plugin when loading it\n       * XXX: issue a warning? */\n      rf->rf_interval = plugin_get_interval();\n      rf->rf_effective_interval = rf->rf_interval;\n\n      rf->rf_next_read = cdtime();\n    }\n\n    /* sleep until this entry is due,\n     * using pthread_cond_timedwait */\n    pthread_mutex_lock(&read_lock);\n    /* In pthread_cond_timedwait, spurious wakeups are possible\n     * (and really happen, at least on NetBSD with > 1 CPU), thus\n     * we need to re-evaluate the condition every time\n     * pthread_cond_timedwait returns. */\n    rc = 0;\n    while ((read_loop != 0) && (cdtime() < rf->rf_next_read) && rc == 0) {\n      rc = pthread_cond_timedwait(&read_cond, &read_lock,\n                                  &CDTIME_T_TO_TIMESPEC(rf->rf_next_read));\n    }\n\n    /* Must hold `read_lock' when accessing `rf->rf_type'. */\n    rf_type = rf->rf_type;\n    pthread_mutex_unlock(&read_lock);\n\n    /* Check if we're supposed to stop.. This may have interrupted\n     * the sleep, too. */\n    if (read_loop == 0) {\n      /* Insert `rf' again, so it can be free'd correctly */\n      c_heap_insert(read_heap, rf);\n      break;\n    }\n\n    /* The entry has been marked for deletion. The linked list\n     * entry has already been removed by `plugin_unregister_read'.\n     * All we have to do here is free the `read_func_t' and\n     * continue. */\n    if (rf_type == RF_REMOVE) {\n      DEBUG(\"plugin_read_thread: Destroying the `%s' \"\n            \"callback.\",\n            rf->rf_name);\n      sfree(rf->rf_name);\n      destroy_callback((callback_func_t *)rf);\n      rf = NULL;\n      continue;\n    }\n\n    DEBUG(\"plugin_read_thread: Handling `%s'.\", rf->rf_name);\n\n    start = cdtime();\n\n    old_ctx = plugin_set_ctx(rf->rf_ctx);\n\n    if (rf_type == RF_SIMPLE) {\n      int (*callback)(void);\n\n      callback = rf->rf_callback;\n      status = (*callback)();\n    } else {\n      plugin_read_cb callback;\n\n      assert(rf_type == RF_COMPLEX);\n\n      callback = rf->rf_callback;\n      status = (*callback)(&rf->rf_udata);\n    }\n\n    plugin_set_ctx(old_ctx);\n\n    /* If the function signals failure, we will increase the\n     * intervals in which it will be called. */\n    if (status != 0) {\n      rf->rf_effective_interval *= 2;\n      if (rf->rf_effective_interval > max_read_interval)\n        rf->rf_effective_interval = max_read_interval;\n\n      NOTICE(\"read-function of plugin `%s' failed. \"\n             \"Will suspend it for %.3f seconds.\",\n             rf->rf_name, CDTIME_T_TO_DOUBLE(rf->rf_effective_interval));\n    } else {\n      /* Success: Restore the interval, if it was changed. */\n      rf->rf_effective_interval = rf->rf_interval;\n    }\n\n    /* update the ``next read due'' field */\n    now = cdtime();\n\n    /* calculate the time spent in the read function */\n    elapsed = (now - start);\n\n    if (elapsed > rf->rf_effective_interval)\n      WARNING(\n          \"plugin_read_thread: read-function of the `%s' plugin took %.3f \"\n          \"seconds, which is above its read interval (%.3f seconds). You might \"\n          \"want to adjust the `Interval' or `ReadThreads' settings.\",\n          rf->rf_name, CDTIME_T_TO_DOUBLE(elapsed),\n          CDTIME_T_TO_DOUBLE(rf->rf_effective_interval));\n\n    DEBUG(\"plugin_read_thread: read-function of the `%s' plugin took \"\n          \"%.6f seconds.\",\n          rf->rf_name, CDTIME_T_TO_DOUBLE(elapsed));\n\n    DEBUG(\"plugin_read_thread: Effective interval of the \"\n          \"`%s' plugin is %.3f seconds.\",\n          rf->rf_name, CDTIME_T_TO_DOUBLE(rf->rf_effective_interval));\n\n    /* Calculate the next (absolute) time at which this function\n     * should be called. */\n    rf->rf_next_read += rf->rf_effective_interval;\n\n    /* Check, if `rf_next_read' is in the past. */\n    if (rf->rf_next_read < now) {\n      /* `rf_next_read' is in the past. Insert `now'\n       * so this value doesn't trail off into the\n       * past too much. */\n      rf->rf_next_read = now;\n    }\n\n    DEBUG(\"plugin_read_thread: Next read of the `%s' plugin at %.3f.\",\n          rf->rf_name, CDTIME_T_TO_DOUBLE(rf->rf_next_read));\n\n    /* Re-insert this read function into the heap again. */\n    c_heap_insert(read_heap, rf);\n  } /* while (read_loop) */\n\n  pthread_exit(NULL);\n  return (void *)0;\n} /* void *plugin_read_thread */\n\n#ifdef PTHREAD_MAX_NAMELEN_NP\n#define THREAD_NAME_MAX PTHREAD_MAX_NAMELEN_NP\n#else\n#define THREAD_NAME_MAX 16\n#endif\n\nstatic void set_thread_name(pthread_t tid, char const *name) {\n#if defined(HAVE_PTHREAD_SETNAME_NP) || defined(HAVE_PTHREAD_SET_NAME_NP)\n\n  /* glibc limits the length of the name and fails if the passed string\n   * is too long, so we truncate it here. */\n  char n[THREAD_NAME_MAX];\n  if (strlen(name) >= THREAD_NAME_MAX)\n    WARNING(\"set_thread_name(\\\"%s\\\"): name too long\", name);\n  sstrncpy(n, name, sizeof(n));\n\n#if defined(HAVE_PTHREAD_SETNAME_NP)\n  int status = pthread_setname_np(tid, n);\n  if (status != 0) {\n    ERROR(\"set_thread_name(\\\"%s\\\"): %s\", n, STRERROR(status));\n  }\n#else /* if defined(HAVE_PTHREAD_SET_NAME_NP) */\n  pthread_set_name_np(tid, n);\n#endif\n\n#endif\n}\n\nstatic void start_read_threads(size_t num) /* {{{ */\n{\n  if (read_threads != NULL)\n    return;\n\n  read_threads = calloc(num, sizeof(*read_threads));\n  if (read_threads == NULL) {\n    ERROR(\"plugin: start_read_threads: calloc failed.\");\n    return;\n  }\n\n  read_threads_num = 0;\n  for (size_t i = 0; i < num; i++) {\n    int status = pthread_create(read_threads + read_threads_num,\n                                /* attr = */ NULL, plugin_read_thread,\n                                /* arg = */ NULL);\n    if (status != 0) {\n      ERROR(\"plugin: start_read_threads: pthread_create failed with status %i \"\n            \"(%s).\",\n            status, STRERROR(status));\n      return;\n    }\n\n    char name[THREAD_NAME_MAX];\n    ssnprintf(name, sizeof(name), \"reader#%\" PRIu64,\n              (uint64_t)read_threads_num);\n    set_thread_name(read_threads[read_threads_num], name);\n\n    read_threads_num++;\n  } /* for (i) */\n} /* }}} void start_read_threads */\n\nstatic void stop_read_threads(void) {\n  if (read_threads == NULL)\n    return;\n\n  INFO(\"collectd: Stopping %\" PRIsz \" read threads.\", read_threads_num);\n\n  pthread_mutex_lock(&read_lock);\n  read_loop = 0;\n  DEBUG(\"plugin: stop_read_threads: Signalling `read_cond'\");\n  pthread_cond_broadcast(&read_cond);\n  pthread_mutex_unlock(&read_lock);\n\n  for (size_t i = 0; i < read_threads_num; i++) {\n    if (pthread_join(read_threads[i], NULL) != 0) {\n      ERROR(\"plugin: stop_read_threads: pthread_join failed.\");\n    }\n    read_threads[i] = (pthread_t)0;\n  }\n  sfree(read_threads);\n  read_threads_num = 0;\n} /* void stop_read_threads */\n\nstatic void plugin_value_list_free(value_list_t *vl) /* {{{ */\n{\n  if (vl == NULL)\n    return;\n\n  meta_data_destroy(vl->meta);\n  sfree(vl->values);\n  sfree(vl);\n} /* }}} void plugin_value_list_free */\n\nstatic value_list_t *\nplugin_value_list_clone(value_list_t const *vl_orig) /* {{{ */\n{\n  value_list_t *vl;\n\n  if (vl_orig == NULL)\n    return NULL;\n\n  vl = malloc(sizeof(*vl));\n  if (vl == NULL)\n    return NULL;\n  memcpy(vl, vl_orig, sizeof(*vl));\n\n  if (vl->host[0] == 0)\n    sstrncpy(vl->host, hostname_g, sizeof(vl->host));\n\n  vl->values = calloc(vl_orig->values_len, sizeof(*vl->values));\n  if (vl->values == NULL) {\n    plugin_value_list_free(vl);\n    return NULL;\n  }\n  memcpy(vl->values, vl_orig->values,\n         vl_orig->values_len * sizeof(*vl->values));\n\n  vl->meta = meta_data_clone(vl->meta);\n  if ((vl_orig->meta != NULL) && (vl->meta == NULL)) {\n    plugin_value_list_free(vl);\n    return NULL;\n  }\n\n  if (vl->time == 0)\n    vl->time = cdtime();\n\n  /* Fill in the interval from the thread context, if it is zero. */\n  if (vl->interval == 0)\n    vl->interval = plugin_get_interval();\n\n  return vl;\n} /* }}} value_list_t *plugin_value_list_clone */\n\nstatic int plugin_write_enqueue(value_list_t const *vl) /* {{{ */\n{\n  write_queue_t *q;\n\n  q = malloc(sizeof(*q));\n  if (q == NULL)\n    return ENOMEM;\n  q->next = NULL;\n\n  q->vl = plugin_value_list_clone(vl);\n  if (q->vl == NULL) {\n    sfree(q);\n    return ENOMEM;\n  }\n\n  /* Store context of caller (read plugin); otherwise, it would not be\n   * available to the write plugins when actually dispatching the\n   * value-list later on. */\n  q->ctx = plugin_get_ctx();\n\n  pthread_mutex_lock(&write_lock);\n\n  if (write_queue_tail == NULL) {\n    write_queue_head = q;\n    write_queue_tail = q;\n    write_queue_length = 1;\n  } else {\n    write_queue_tail->next = q;\n    write_queue_tail = q;\n    write_queue_length += 1;\n  }\n\n  pthread_cond_signal(&write_cond);\n  pthread_mutex_unlock(&write_lock);\n\n  return 0;\n} /* }}} int plugin_write_enqueue */\n\nstatic value_list_t *plugin_write_dequeue(void) /* {{{ */\n{\n  write_queue_t *q;\n  value_list_t *vl;\n\n  pthread_mutex_lock(&write_lock);\n\n  while (write_loop && (write_queue_head == NULL))\n    pthread_cond_wait(&write_cond, &write_lock);\n\n  if (write_queue_head == NULL) {\n    pthread_mutex_unlock(&write_lock);\n    return NULL;\n  }\n\n  q = write_queue_head;\n  write_queue_head = q->next;\n  write_queue_length -= 1;\n  if (write_queue_head == NULL) {\n    write_queue_tail = NULL;\n    assert(0 == write_queue_length);\n  }\n\n  pthread_mutex_unlock(&write_lock);\n\n  (void)plugin_set_ctx(q->ctx);\n\n  vl = q->vl;\n  sfree(q);\n  return vl;\n} /* }}} value_list_t *plugin_write_dequeue */\n\nstatic void *plugin_write_thread(void __attribute__((unused)) * args) /* {{{ */\n{\n  while (write_loop) {\n    value_list_t *vl = plugin_write_dequeue();\n    if (vl == NULL)\n      continue;\n\n    plugin_dispatch_values_internal(vl);\n\n    plugin_value_list_free(vl);\n  }\n\n  pthread_exit(NULL);\n  return (void *)0;\n} /* }}} void *plugin_write_thread */\n\nstatic void start_write_threads(size_t num) /* {{{ */\n{\n  if (write_threads != NULL)\n    return;\n\n  write_threads = calloc(num, sizeof(*write_threads));\n  if (write_threads == NULL) {\n    ERROR(\"plugin: start_write_threads: calloc failed.\");\n    return;\n  }\n\n  write_threads_num = 0;\n  for (size_t i = 0; i < num; i++) {\n    int status = pthread_create(write_threads + write_threads_num,\n                                /* attr = */ NULL, plugin_write_thread,\n                                /* arg = */ NULL);\n    if (status != 0) {\n      ERROR(\"plugin: start_write_threads: pthread_create failed with status %i \"\n            \"(%s).\",\n            status, STRERROR(status));\n      return;\n    }\n\n    char name[THREAD_NAME_MAX];\n    ssnprintf(name, sizeof(name), \"writer#%\" PRIu64,\n              (uint64_t)write_threads_num);\n    set_thread_name(write_threads[write_threads_num], name);\n\n    write_threads_num++;\n  } /* for (i) */\n} /* }}} void start_write_threads */\n\nstatic void stop_write_threads(void) /* {{{ */\n{\n  write_queue_t *q;\n  size_t i;\n\n  if (write_threads == NULL)\n    return;\n\n  INFO(\"collectd: Stopping %\" PRIsz \" write threads.\", write_threads_num);\n\n  pthread_mutex_lock(&write_lock);\n  write_loop = false;\n  DEBUG(\"plugin: stop_write_threads: Signalling `write_cond'\");\n  pthread_cond_broadcast(&write_cond);\n  pthread_mutex_unlock(&write_lock);\n\n  for (i = 0; i < write_threads_num; i++) {\n    if (pthread_join(write_threads[i], NULL) != 0) {\n      ERROR(\"plugin: stop_write_threads: pthread_join failed.\");\n    }\n    write_threads[i] = (pthread_t)0;\n  }\n  sfree(write_threads);\n  write_threads_num = 0;\n\n  pthread_mutex_lock(&write_lock);\n  i = 0;\n  for (q = write_queue_head; q != NULL;) {\n    write_queue_t *q1 = q;\n    plugin_value_list_free(q->vl);\n    q = q->next;\n    sfree(q1);\n    i++;\n  }\n  write_queue_head = NULL;\n  write_queue_tail = NULL;\n  write_queue_length = 0;\n  pthread_mutex_unlock(&write_lock);\n\n  if (i > 0) {\n    WARNING(\"plugin: %\" PRIsz \" value list%s left after shutting down \"\n            \"the write threads.\",\n            i, (i == 1) ? \" was\" : \"s were\");\n  }\n} /* }}} void stop_write_threads */\n\n/*\n * Public functions\n */\nvoid plugin_set_dir(const char *dir) {\n  sfree(plugindir);\n\n  if (dir == NULL) {\n    plugindir = NULL;\n    return;\n  }\n\n  plugindir = strdup(dir);\n  if (plugindir == NULL)\n    ERROR(\"plugin_set_dir: strdup(\\\"%s\\\") failed\", dir);\n}\n\nbool plugin_is_loaded(char const *name) {\n  if (plugins_loaded == NULL)\n    plugins_loaded =\n        c_avl_create((int (*)(const void *, const void *))strcasecmp);\n  assert(plugins_loaded != NULL);\n\n  int status = c_avl_get(plugins_loaded, name, /* ret_value = */ NULL);\n  return status == 0;\n}\n\nstatic int plugin_mark_loaded(char const *name) {\n  char *name_copy;\n  int status;\n\n  name_copy = strdup(name);\n  if (name_copy == NULL)\n    return ENOMEM;\n\n  status = c_avl_insert(plugins_loaded,\n                        /* key = */ name_copy, /* value = */ NULL);\n  return status;\n}\n\nstatic void plugin_free_loaded(void) {\n  void *key;\n  void *value;\n\n  if (plugins_loaded == NULL)\n    return;\n\n  while (c_avl_pick(plugins_loaded, &key, &value) == 0) {\n    sfree(key);\n    assert(value == NULL);\n  }\n\n  c_avl_destroy(plugins_loaded);\n  plugins_loaded = NULL;\n}\n\n#define BUFSIZE 512\n#ifdef WIN32\n#define SHLIB_SUFFIX \".dll\"\n#else\n#define SHLIB_SUFFIX \".so\"\n#endif\nint plugin_load(char const *plugin_name, bool global) {\n  DIR *dh;\n  const char *dir;\n  char filename[BUFSIZE] = \"\";\n  char typename[BUFSIZE];\n  int ret;\n  struct stat statbuf;\n  struct dirent *de;\n  int status;\n\n  if (plugin_name == NULL)\n    return EINVAL;\n\n  /* Check if plugin is already loaded and don't do anything in this\n   * case. */\n  if (plugin_is_loaded(plugin_name))\n    return 0;\n\n  dir = plugin_get_dir();\n  ret = 1;\n\n  /*\n   * XXX: Magic at work:\n   *\n   * Some of the language bindings, for example the Python and Perl\n   * plugins, need to be able to export symbols to the scripts they run.\n   * For this to happen, the \"Globals\" flag needs to be set.\n   * Unfortunately, this technical detail is hard to explain to the\n   * average user and she shouldn't have to worry about this, ideally.\n   * So in order to save everyone's sanity use a different default for a\n   * handful of special plugins. --octo\n   */\n  if ((strcasecmp(\"perl\", plugin_name) == 0) ||\n      (strcasecmp(\"python\", plugin_name) == 0))\n    global = true;\n\n  /* `cpu' should not match `cpufreq'. To solve this we add SHLIB_SUFFIX to the\n   * type when matching the filename */\n  status = snprintf(typename, sizeof(typename), \"%s\" SHLIB_SUFFIX, plugin_name);\n  if ((status < 0) || ((size_t)status >= sizeof(typename))) {\n    WARNING(\"plugin_load: Filename too long: \\\"%s\" SHLIB_SUFFIX \"\\\"\",\n            plugin_name);\n    return -1;\n  }\n\n  if ((dh = opendir(dir)) == NULL) {\n    ERROR(\"plugin_load: opendir (%s) failed: %s\", dir, STRERRNO);\n    return -1;\n  }\n\n  while ((de = readdir(dh)) != NULL) {\n    if (strcasecmp(de->d_name, typename))\n      continue;\n\n    status = snprintf(filename, sizeof(filename), \"%s/%s\", dir, de->d_name);\n    if ((status < 0) || ((size_t)status >= sizeof(filename))) {\n      WARNING(\"plugin_load: Filename too long: \\\"%s/%s\\\"\", dir, de->d_name);\n      continue;\n    }\n\n    if (lstat(filename, &statbuf) == -1) {\n      WARNING(\"plugin_load: stat (\\\"%s\\\") failed: %s\", filename, STRERRNO);\n      continue;\n    } else if (!S_ISREG(statbuf.st_mode)) {\n      /* don't follow symlinks */\n      WARNING(\"plugin_load: %s is not a regular file.\", filename);\n      continue;\n    }\n\n    status = plugin_load_file(filename, global);\n    if (status == 0) {\n      /* success */\n      plugin_mark_loaded(plugin_name);\n      ret = 0;\n      INFO(\"plugin_load: plugin \\\"%s\\\" successfully loaded.\", plugin_name);\n      break;\n    } else {\n      ERROR(\"plugin_load: Load plugin \\\"%s\\\" failed with \"\n            \"status %i.\",\n            plugin_name, status);\n    }\n  }\n\n  closedir(dh);\n\n  if (filename[0] == 0)\n    ERROR(\"plugin_load: Could not find plugin \\\"%s\\\" in %s\", plugin_name, dir);\n\n  return ret;\n}\n\n/*\n * The `register_*' functions follow\n */\nEXPORT int plugin_register_config(const char *name,\n                                  int (*callback)(const char *key,\n                                                  const char *val),\n                                  const char **keys, int keys_num) {\n  cf_register(name, callback, keys, keys_num);\n  return 0;\n} /* int plugin_register_config */\n\nEXPORT int plugin_register_complex_config(const char *type,\n                                          int (*callback)(oconfig_item_t *)) {\n  return cf_register_complex(type, callback);\n} /* int plugin_register_complex_config */\n\nEXPORT int plugin_register_init(const char *name, int (*callback)(void)) {\n  return create_register_callback(&list_init, name, (void *)callback, NULL);\n} /* plugin_register_init */\n\nstatic int plugin_compare_read_func(const void *arg0, const void *arg1) {\n  const read_func_t *rf0;\n  const read_func_t *rf1;\n\n  rf0 = arg0;\n  rf1 = arg1;\n\n  if (rf0->rf_next_read < rf1->rf_next_read)\n    return -1;\n  else if (rf0->rf_next_read > rf1->rf_next_read)\n    return 1;\n  else\n    return 0;\n} /* int plugin_compare_read_func */\n\n/* Add a read function to both, the heap and a linked list. The linked list if\n * used to look-up read functions, especially for the remove function. The heap\n * is used to determine which plugin to read next. */\nstatic int plugin_insert_read(read_func_t *rf) {\n  int status;\n  llentry_t *le;\n\n  rf->rf_next_read = cdtime();\n  rf->rf_effective_interval = rf->rf_interval;\n\n  pthread_mutex_lock(&read_lock);\n\n  if (read_list == NULL) {\n    read_list = llist_create();\n    if (read_list == NULL) {\n      pthread_mutex_unlock(&read_lock);\n      ERROR(\"plugin_insert_read: read_list failed.\");\n      return -1;\n    }\n  }\n\n  if (read_heap == NULL) {\n    read_heap = c_heap_create(plugin_compare_read_func);\n    if (read_heap == NULL) {\n      pthread_mutex_unlock(&read_lock);\n      ERROR(\"plugin_insert_read: c_heap_create failed.\");\n      return -1;\n    }\n  }\n\n  le = llist_search(read_list, rf->rf_name);\n  if (le != NULL) {\n    pthread_mutex_unlock(&read_lock);\n    P_WARNING(\"The read function \\\"%s\\\" is already registered. \"\n              \"Check for duplicates in your configuration!\",\n              rf->rf_name);\n    return EINVAL;\n  }\n\n  le = llentry_create(rf->rf_name, rf);\n  if (le == NULL) {\n    pthread_mutex_unlock(&read_lock);\n    ERROR(\"plugin_insert_read: llentry_create failed.\");\n    return -1;\n  }\n\n  status = c_heap_insert(read_heap, rf);\n  if (status != 0) {\n    pthread_mutex_unlock(&read_lock);\n    ERROR(\"plugin_insert_read: c_heap_insert failed.\");\n    llentry_destroy(le);\n    return -1;\n  }\n\n  /* This does not fail. */\n  llist_append(read_list, le);\n\n  /* Wake up all the read threads. */\n  pthread_cond_broadcast(&read_cond);\n  pthread_mutex_unlock(&read_lock);\n  return 0;\n} /* int plugin_insert_read */\n\nEXPORT int plugin_register_read(const char *name, int (*callback)(void)) {\n  read_func_t *rf;\n  int status;\n\n  rf = calloc(1, sizeof(*rf));\n  if (rf == NULL) {\n    ERROR(\"plugin_register_read: calloc failed.\");\n    return ENOMEM;\n  }\n\n  rf->rf_callback = (void *)callback;\n  rf->rf_udata.data = NULL;\n  rf->rf_udata.free_func = NULL;\n  rf->rf_ctx = plugin_get_ctx();\n  rf->rf_group[0] = '\\0';\n  rf->rf_name = strdup(name);\n  rf->rf_type = RF_SIMPLE;\n  rf->rf_interval = plugin_get_interval();\n  rf->rf_ctx.interval = rf->rf_interval;\n\n  status = plugin_insert_read(rf);\n  if (status != 0) {\n    sfree(rf->rf_name);\n    sfree(rf);\n  }\n\n  return status;\n} /* int plugin_register_read */\n\nEXPORT int plugin_register_complex_read(const char *group, const char *name,\n                                        plugin_read_cb callback,\n                                        cdtime_t interval,\n                                        user_data_t const *user_data) {\n  read_func_t *rf;\n  int status;\n\n  rf = calloc(1, sizeof(*rf));\n  if (rf == NULL) {\n    free_userdata(user_data);\n    ERROR(\"plugin_register_complex_read: calloc failed.\");\n    return ENOMEM;\n  }\n\n  rf->rf_callback = (void *)callback;\n  if (group != NULL)\n    sstrncpy(rf->rf_group, group, sizeof(rf->rf_group));\n  else\n    rf->rf_group[0] = '\\0';\n  rf->rf_name = strdup(name);\n  rf->rf_type = RF_COMPLEX;\n  rf->rf_interval = (interval != 0) ? interval : plugin_get_interval();\n\n  /* Set user data */\n  if (user_data == NULL) {\n    rf->rf_udata.data = NULL;\n    rf->rf_udata.free_func = NULL;\n  } else {\n    rf->rf_udata = *user_data;\n  }\n\n  rf->rf_ctx = plugin_get_ctx();\n  rf->rf_ctx.interval = rf->rf_interval;\n\n  status = plugin_insert_read(rf);\n  if (status != 0) {\n    free_userdata(&rf->rf_udata);\n    sfree(rf->rf_name);\n    sfree(rf);\n  }\n\n  return status;\n} /* int plugin_register_complex_read */\n\nEXPORT int plugin_register_write(const char *name, plugin_write_cb callback,\n                                 user_data_t const *ud) {\n  return create_register_callback(&list_write, name, (void *)callback, ud);\n} /* int plugin_register_write */\n\nstatic int plugin_flush_timeout_callback(user_data_t *ud) {\n  flush_callback_t *cb = ud->data;\n\n  return plugin_flush(cb->name, cb->timeout, NULL);\n} /* static int plugin_flush_callback */\n\nstatic void plugin_flush_timeout_callback_free(void *data) {\n  flush_callback_t *cb = data;\n\n  if (cb == NULL)\n    return;\n\n  sfree(cb->name);\n  sfree(cb);\n} /* static void plugin_flush_callback_free */\n\nstatic char *plugin_flush_callback_name(const char *name) {\n  const char *flush_prefix = \"flush/\";\n  size_t prefix_size;\n  char *flush_name;\n  size_t name_size;\n\n  prefix_size = strlen(flush_prefix);\n  name_size = strlen(name);\n\n  flush_name = malloc(name_size + prefix_size + 1);\n  if (flush_name == NULL) {\n    ERROR(\"plugin_flush_callback_name: malloc failed.\");\n    return NULL;\n  }\n\n  sstrncpy(flush_name, flush_prefix, prefix_size + 1);\n  sstrncpy(flush_name + prefix_size, name, name_size + 1);\n\n  return flush_name;\n} /* static char *plugin_flush_callback_name */\n\nEXPORT int plugin_register_flush(const char *name, plugin_flush_cb callback,\n                                 user_data_t const *ud) {\n  int status;\n  plugin_ctx_t ctx = plugin_get_ctx();\n\n  status = create_register_callback(&list_flush, name, (void *)callback, ud);\n  if (status != 0)\n    return status;\n\n  if (ctx.flush_interval != 0) {\n    char *flush_name;\n    flush_callback_t *cb;\n\n    flush_name = plugin_flush_callback_name(name);\n    if (flush_name == NULL)\n      return -1;\n\n    cb = malloc(sizeof(*cb));\n    if (cb == NULL) {\n      ERROR(\"plugin_register_flush: malloc failed.\");\n      sfree(flush_name);\n      return -1;\n    }\n\n    cb->name = strdup(name);\n    if (cb->name == NULL) {\n      ERROR(\"plugin_register_flush: strdup failed.\");\n      sfree(cb);\n      sfree(flush_name);\n      return -1;\n    }\n    cb->timeout = ctx.flush_timeout;\n\n    status = plugin_register_complex_read(\n        /* group     = */ \"flush\",\n        /* name      = */ flush_name,\n        /* callback  = */ plugin_flush_timeout_callback,\n        /* interval  = */ ctx.flush_interval,\n        /* user data = */\n        &(user_data_t){\n            .data = cb,\n            .free_func = plugin_flush_timeout_callback_free,\n        });\n\n    sfree(flush_name);\n    return status;\n  }\n\n  return 0;\n} /* int plugin_register_flush */\n\nEXPORT int plugin_register_missing(const char *name, plugin_missing_cb callback,\n                                   user_data_t const *ud) {\n  return create_register_callback(&list_missing, name, (void *)callback, ud);\n} /* int plugin_register_missing */\n\nEXPORT int plugin_register_cache_event(const char *name,\n                                       plugin_cache_event_cb callback,\n                                       user_data_t const *ud) {\n\n  if (name == NULL || callback == NULL)\n    return EINVAL;\n\n  char *name_copy = strdup(name);\n  if (name_copy == NULL) {\n    P_ERROR(\"plugin_register_cache_event: strdup failed.\");\n    free_userdata(ud);\n    return ENOMEM;\n  }\n\n  if (list_cache_event_num >= 32) {\n    P_ERROR(\"plugin_register_cache_event: Too much cache event callbacks tried \"\n            \"to be registered.\");\n    free_userdata(ud);\n    return ENOMEM;\n  }\n\n  for (size_t i = 0; i < list_cache_event_num; i++) {\n    cache_event_func_t *cef = &list_cache_event[i];\n    if (!cef->callback)\n      continue;\n\n    if (strcmp(name, cef->name) == 0) {\n      P_ERROR(\"plugin_register_cache_event: a callback named `%s' already \"\n              \"registered!\",\n              name);\n      free_userdata(ud);\n      return -1;\n    }\n  }\n\n  user_data_t user_data;\n  if (ud == NULL) {\n    user_data = (user_data_t){\n        .data = NULL, .free_func = NULL,\n    };\n  } else {\n    user_data = *ud;\n  }\n\n  list_cache_event[list_cache_event_num] =\n      (cache_event_func_t){.callback = callback,\n                           .name = name_copy,\n                           .user_data = user_data,\n                           .plugin_ctx = plugin_get_ctx()};\n  list_cache_event_num++;\n\n  return 0;\n} /* int plugin_register_cache_event */\n\nEXPORT int plugin_register_shutdown(const char *name, int (*callback)(void)) {\n  return create_register_callback(&list_shutdown, name, (void *)callback, NULL);\n} /* int plugin_register_shutdown */\n\nstatic void plugin_free_data_sets(void) {\n  void *key;\n  void *value;\n\n  if (data_sets == NULL)\n    return;\n\n  while (c_avl_pick(data_sets, &key, &value) == 0) {\n    data_set_t *ds = value;\n    /* key is a pointer to ds->type */\n\n    sfree(ds->ds);\n    sfree(ds);\n  }\n\n  c_avl_destroy(data_sets);\n  data_sets = NULL;\n} /* void plugin_free_data_sets */\n\nEXPORT int plugin_register_data_set(const data_set_t *ds) {\n  data_set_t *ds_copy;\n\n  if ((data_sets != NULL) && (c_avl_get(data_sets, ds->type, NULL) == 0)) {\n    NOTICE(\"Replacing DS `%s' with another version.\", ds->type);\n    plugin_unregister_data_set(ds->type);\n  } else if (data_sets == NULL) {\n    data_sets = c_avl_create((int (*)(const void *, const void *))strcmp);\n    if (data_sets == NULL)\n      return -1;\n  }\n\n  ds_copy = malloc(sizeof(*ds_copy));\n  if (ds_copy == NULL)\n    return -1;\n  memcpy(ds_copy, ds, sizeof(data_set_t));\n\n  ds_copy->ds = malloc(sizeof(*ds_copy->ds) * ds->ds_num);\n  if (ds_copy->ds == NULL) {\n    sfree(ds_copy);\n    return -1;\n  }\n\n  for (size_t i = 0; i < ds->ds_num; i++)\n    memcpy(ds_copy->ds + i, ds->ds + i, sizeof(data_source_t));\n\n  return c_avl_insert(data_sets, (void *)ds_copy->type, (void *)ds_copy);\n} /* int plugin_register_data_set */\n\nEXPORT int plugin_register_log(const char *name, plugin_log_cb callback,\n                               user_data_t const *ud) {\n  return create_register_callback(&list_log, name, (void *)callback, ud);\n} /* int plugin_register_log */\n\nEXPORT int plugin_register_notification(const char *name,\n                                        plugin_notification_cb callback,\n                                        user_data_t const *ud) {\n  return create_register_callback(&list_notification, name, (void *)callback,\n                                  ud);\n} /* int plugin_register_log */\n\nEXPORT int plugin_unregister_config(const char *name) {\n  cf_unregister(name);\n  return 0;\n} /* int plugin_unregister_config */\n\nEXPORT int plugin_unregister_complex_config(const char *name) {\n  cf_unregister_complex(name);\n  return 0;\n} /* int plugin_unregister_complex_config */\n\nEXPORT int plugin_unregister_init(const char *name) {\n  return plugin_unregister(list_init, name);\n}\n\nEXPORT int plugin_unregister_read(const char *name) /* {{{ */\n{\n  llentry_t *le;\n  read_func_t *rf;\n\n  if (name == NULL)\n    return -ENOENT;\n\n  pthread_mutex_lock(&read_lock);\n\n  if (read_list == NULL) {\n    pthread_mutex_unlock(&read_lock);\n    return -ENOENT;\n  }\n\n  le = llist_search(read_list, name);\n  if (le == NULL) {\n    pthread_mutex_unlock(&read_lock);\n    WARNING(\"plugin_unregister_read: No such read function: %s\", name);\n    return -ENOENT;\n  }\n\n  llist_remove(read_list, le);\n\n  rf = le->value;\n  assert(rf != NULL);\n  rf->rf_type = RF_REMOVE;\n\n  pthread_mutex_unlock(&read_lock);\n\n  llentry_destroy(le);\n\n  DEBUG(\"plugin_unregister_read: Marked `%s' for removal.\", name);\n\n  return 0;\n} /* }}} int plugin_unregister_read */\n\nEXPORT void plugin_log_available_writers(void) {\n  log_list_callbacks(&list_write, \"Available write targets:\");\n}\n\nstatic int compare_read_func_group(llentry_t *e, void *ud) /* {{{ */\n{\n  read_func_t *rf = e->value;\n  char *group = ud;\n\n  return strcmp(rf->rf_group, (const char *)group);\n} /* }}} int compare_read_func_group */\n\nEXPORT int plugin_unregister_read_group(const char *group) /* {{{ */\n{\n  llentry_t *le;\n  read_func_t *rf;\n\n  int found = 0;\n\n  if (group == NULL)\n    return -ENOENT;\n\n  pthread_mutex_lock(&read_lock);\n\n  if (read_list == NULL) {\n    pthread_mutex_unlock(&read_lock);\n    return -ENOENT;\n  }\n\n  while (42) {\n    le = llist_search_custom(read_list, compare_read_func_group, (void *)group);\n\n    if (le == NULL)\n      break;\n\n    ++found;\n\n    llist_remove(read_list, le);\n\n    rf = le->value;\n    assert(rf != NULL);\n    rf->rf_type = RF_REMOVE;\n\n    llentry_destroy(le);\n\n    DEBUG(\"plugin_unregister_read_group: \"\n          \"Marked `%s' (group `%s') for removal.\",\n          rf->rf_name, group);\n  }\n\n  pthread_mutex_unlock(&read_lock);\n\n  if (found == 0) {\n    WARNING(\"plugin_unregister_read_group: No such \"\n            \"group of read function: %s\",\n            group);\n    return -ENOENT;\n  }\n\n  return 0;\n} /* }}} int plugin_unregister_read_group */\n\nEXPORT int plugin_unregister_write(const char *name) {\n  return plugin_unregister(list_write, name);\n}\n\nEXPORT int plugin_unregister_flush(const char *name) {\n  plugin_ctx_t ctx = plugin_get_ctx();\n\n  if (ctx.flush_interval != 0) {\n    char *flush_name;\n\n    flush_name = plugin_flush_callback_name(name);\n    if (flush_name != NULL) {\n      plugin_unregister_read(flush_name);\n      sfree(flush_name);\n    }\n  }\n\n  return plugin_unregister(list_flush, name);\n}\n\nEXPORT int plugin_unregister_missing(const char *name) {\n  return plugin_unregister(list_missing, name);\n}\n\nEXPORT int plugin_unregister_cache_event(const char *name) {\n  for (size_t i = 0; i < list_cache_event_num; i++) {\n    cache_event_func_t *cef = &list_cache_event[i];\n    if (!cef->callback)\n      continue;\n    if (strcmp(name, cef->name) == 0) {\n      /* Mark callback as inactive, so mask in cache entries remains actual */\n      cef->callback = NULL;\n      sfree(cef->name);\n      free_userdata(&cef->user_data);\n    }\n  }\n  return 0;\n}\n\nstatic void destroy_cache_event_callbacks() {\n  for (size_t i = 0; i < list_cache_event_num; i++) {\n    cache_event_func_t *cef = &list_cache_event[i];\n    if (!cef->callback)\n      continue;\n    cef->callback = NULL;\n    sfree(cef->name);\n    free_userdata(&cef->user_data);\n  }\n}\n\nEXPORT int plugin_unregister_shutdown(const char *name) {\n  return plugin_unregister(list_shutdown, name);\n}\n\nEXPORT int plugin_unregister_data_set(const char *name) {\n  data_set_t *ds;\n\n  if (data_sets == NULL)\n    return -1;\n\n  if (c_avl_remove(data_sets, name, NULL, (void *)&ds) != 0)\n    return -1;\n\n  sfree(ds->ds);\n  sfree(ds);\n\n  return 0;\n} /* int plugin_unregister_data_set */\n\nEXPORT int plugin_unregister_log(const char *name) {\n  return plugin_unregister(list_log, name);\n}\n\nEXPORT int plugin_unregister_notification(const char *name) {\n  return plugin_unregister(list_notification, name);\n}\n\nEXPORT int plugin_init_all(void) {\n  char const *chain_name;\n  llentry_t *le;\n  int status;\n  int ret = 0;\n\n  /* Init the value cache */\n  uc_init();\n\n  if (IS_TRUE(global_option_get(\"CollectInternalStats\"))) {\n    record_statistics = true;\n    plugin_register_read(\"collectd\", plugin_update_internal_statistics);\n  }\n\n  chain_name = global_option_get(\"PreCacheChain\");\n  pre_cache_chain = fc_chain_get_by_name(chain_name);\n\n  chain_name = global_option_get(\"PostCacheChain\");\n  post_cache_chain = fc_chain_get_by_name(chain_name);\n\n  write_limit_high = global_option_get_long(\"WriteQueueLimitHigh\",\n                                            /* default = */ 0);\n  if (write_limit_high < 0) {\n    ERROR(\"WriteQueueLimitHigh must be positive or zero.\");\n    write_limit_high = 0;\n  }\n\n  write_limit_low =\n      global_option_get_long(\"WriteQueueLimitLow\",\n                             /* default = */ write_limit_high / 2);\n  if (write_limit_low < 0) {\n    ERROR(\"WriteQueueLimitLow must be positive or zero.\");\n    write_limit_low = write_limit_high / 2;\n  } else if (write_limit_low > write_limit_high) {\n    ERROR(\"WriteQueueLimitLow must not be larger than \"\n          \"WriteQueueLimitHigh.\");\n    write_limit_low = write_limit_high;\n  }\n\n  write_threads_num = global_option_get_long(\"WriteThreads\",\n                                             /* default = */ 5);\n  if (write_threads_num < 1) {\n    ERROR(\"WriteThreads must be positive.\");\n    write_threads_num = 5;\n  }\n\n  if ((list_init == NULL) && (read_heap == NULL))\n    return ret;\n\n  /* Calling all init callbacks before checking if read callbacks\n   * are available allows the init callbacks to register the read\n   * callback. */\n  le = llist_head(list_init);\n  while (le != NULL) {\n    callback_func_t *cf;\n    plugin_init_cb callback;\n    plugin_ctx_t old_ctx;\n\n    cf = le->value;\n    old_ctx = plugin_set_ctx(cf->cf_ctx);\n    callback = cf->cf_callback;\n    status = (*callback)();\n    plugin_set_ctx(old_ctx);\n\n    if (status != 0) {\n      ERROR(\"Initialization of plugin `%s' \"\n            \"failed with status %i. \"\n            \"Plugin will be unloaded.\",\n            le->key, status);\n      /* Plugins that register read callbacks from the init\n       * callback should take care of appropriate error\n       * handling themselves. */\n      /* FIXME: Unload _all_ functions */\n      plugin_unregister_read(le->key);\n      ret = -1;\n    }\n\n    le = le->next;\n  }\n\n  start_write_threads((size_t)write_threads_num);\n\n  max_read_interval =\n      global_option_get_time(\"MaxReadInterval\", DEFAULT_MAX_READ_INTERVAL);\n\n  /* Start read-threads */\n  if (read_heap != NULL) {\n    const char *rt;\n    int num;\n\n    rt = global_option_get(\"ReadThreads\");\n    num = atoi(rt);\n    if (num != -1)\n      start_read_threads((num > 0) ? ((size_t)num) : 5);\n  }\n  return ret;\n} /* void plugin_init_all */\n\n/* TODO: Rename this function. */\nEXPORT void plugin_read_all(void) {\n  uc_check_timeout();\n\n  return;\n} /* void plugin_read_all */\n\n/* Read function called when the `-T' command line argument is given. */\nEXPORT int plugin_read_all_once(void) {\n  int status;\n  int return_status = 0;\n\n  if (read_heap == NULL) {\n    NOTICE(\"No read-functions are registered.\");\n    return 0;\n  }\n\n  while (42) {\n    read_func_t *rf;\n    plugin_ctx_t old_ctx;\n\n    rf = c_heap_get_root(read_heap);\n    if (rf == NULL)\n      break;\n\n    old_ctx = plugin_set_ctx(rf->rf_ctx);\n\n    if (rf->rf_type == RF_SIMPLE) {\n      int (*callback)(void);\n\n      callback = rf->rf_callback;\n      status = (*callback)();\n    } else {\n      plugin_read_cb callback;\n\n      callback = rf->rf_callback;\n      status = (*callback)(&rf->rf_udata);\n    }\n\n    plugin_set_ctx(old_ctx);\n\n    if (status != 0) {\n      NOTICE(\"read-function of plugin `%s' failed.\", rf->rf_name);\n      return_status = -1;\n    }\n\n    sfree(rf->rf_name);\n    destroy_callback((void *)rf);\n  }\n\n  return return_status;\n} /* int plugin_read_all_once */\n\nEXPORT int plugin_write(const char *plugin, /* {{{ */\n                        const data_set_t *ds, const value_list_t *vl) {\n  llentry_t *le;\n  int status;\n\n  if (vl == NULL)\n    return EINVAL;\n\n  if (list_write == NULL)\n    return ENOENT;\n\n  if (ds == NULL) {\n    ds = plugin_get_ds(vl->type);\n    if (ds == NULL) {\n      ERROR(\"plugin_write: Unable to lookup type `%s'.\", vl->type);\n      return ENOENT;\n    }\n  }\n\n  if (plugin == NULL) {\n    int success = 0;\n    int failure = 0;\n\n    le = llist_head(list_write);\n    while (le != NULL) {\n      callback_func_t *cf = le->value;\n      plugin_write_cb callback;\n\n      /* Keep the read plugin's interval and flush information but update the\n       * plugin name. */\n      plugin_ctx_t old_ctx = plugin_get_ctx();\n      plugin_ctx_t ctx = old_ctx;\n      ctx.name = cf->cf_ctx.name;\n      plugin_set_ctx(ctx);\n\n      DEBUG(\"plugin: plugin_write: Writing values via %s.\", le->key);\n      callback = cf->cf_callback;\n      status = (*callback)(ds, vl, &cf->cf_udata);\n      if (status != 0)\n        failure++;\n      else\n        success++;\n\n      plugin_set_ctx(old_ctx);\n      le = le->next;\n    }\n\n    if ((success == 0) && (failure != 0))\n      status = -1;\n    else\n      status = 0;\n  } else /* plugin != NULL */\n  {\n    callback_func_t *cf;\n    plugin_write_cb callback;\n\n    le = llist_head(list_write);\n    while (le != NULL) {\n      if (strcasecmp(plugin, le->key) == 0)\n        break;\n\n      le = le->next;\n    }\n\n    if (le == NULL)\n      return ENOENT;\n\n    cf = le->value;\n\n    /* do not switch plugin context; rather keep the context (interval)\n     * information of the calling read plugin */\n\n    DEBUG(\"plugin: plugin_write: Writing values via %s.\", le->key);\n    callback = cf->cf_callback;\n    status = (*callback)(ds, vl, &cf->cf_udata);\n  }\n\n  return status;\n} /* }}} int plugin_write */\n\nEXPORT int plugin_flush(const char *plugin, cdtime_t timeout,\n                        const char *identifier) {\n  llentry_t *le;\n\n  if (list_flush == NULL)\n    return 0;\n\n  le = llist_head(list_flush);\n  while (le != NULL) {\n    callback_func_t *cf;\n    plugin_flush_cb callback;\n    plugin_ctx_t old_ctx;\n\n    if ((plugin != NULL) && (strcmp(plugin, le->key) != 0)) {\n      le = le->next;\n      continue;\n    }\n\n    cf = le->value;\n    old_ctx = plugin_set_ctx(cf->cf_ctx);\n    callback = cf->cf_callback;\n\n    (*callback)(timeout, identifier, &cf->cf_udata);\n\n    plugin_set_ctx(old_ctx);\n\n    le = le->next;\n  }\n  return 0;\n} /* int plugin_flush */\n\nEXPORT int plugin_shutdown_all(void) {\n  llentry_t *le;\n  int ret = 0; // Assume success.\n\n  destroy_all_callbacks(&list_init);\n\n  stop_read_threads();\n\n  pthread_mutex_lock(&read_lock);\n  llist_destroy(read_list);\n  read_list = NULL;\n  pthread_mutex_unlock(&read_lock);\n\n  destroy_read_heap();\n\n  /* blocks until all write threads have shut down. */\n  stop_write_threads();\n\n  /* ask all plugins to write out the state they kept. */\n  plugin_flush(/* plugin = */ NULL,\n               /* timeout = */ 0,\n               /* identifier = */ NULL);\n\n  le = NULL;\n  if (list_shutdown != NULL)\n    le = llist_head(list_shutdown);\n\n  while (le != NULL) {\n    callback_func_t *cf;\n    plugin_shutdown_cb callback;\n    plugin_ctx_t old_ctx;\n\n    cf = le->value;\n    old_ctx = plugin_set_ctx(cf->cf_ctx);\n    callback = cf->cf_callback;\n\n    /* Advance the pointer before calling the callback allows\n     * shutdown functions to unregister themselves. If done the\n     * other way around the memory `le' points to will be freed\n     * after callback returns. */\n    le = le->next;\n\n    if ((*callback)() != 0)\n      ret = -1;\n\n    plugin_set_ctx(old_ctx);\n  }\n\n  /* Write plugins which use the `user_data' pointer usually need the\n   * same data available to the flush callback. If this is the case, set\n   * the free_function to NULL when registering the flush callback and to\n   * the real free function when registering the write callback. This way\n   * the data isn't freed twice. */\n  destroy_all_callbacks(&list_flush);\n  destroy_all_callbacks(&list_missing);\n  destroy_cache_event_callbacks();\n  destroy_all_callbacks(&list_write);\n\n  destroy_all_callbacks(&list_notification);\n  destroy_all_callbacks(&list_shutdown);\n  destroy_all_callbacks(&list_log);\n\n  plugin_free_loaded();\n  plugin_free_data_sets();\n  return ret;\n} /* void plugin_shutdown_all */\n\nEXPORT int plugin_dispatch_missing(const value_list_t *vl) /* {{{ */\n{\n  if (list_missing == NULL)\n    return 0;\n\n  llentry_t *le = llist_head(list_missing);\n  while (le != NULL) {\n    callback_func_t *cf = le->value;\n    plugin_ctx_t old_ctx = plugin_set_ctx(cf->cf_ctx);\n    plugin_missing_cb callback = cf->cf_callback;\n\n    int status = (*callback)(vl, &cf->cf_udata);\n    plugin_set_ctx(old_ctx);\n    if (status != 0) {\n      if (status < 0) {\n        ERROR(\"plugin_dispatch_missing: Callback function \\\"%s\\\" \"\n              \"failed with status %i.\",\n              le->key, status);\n        return status;\n      } else {\n        return 0;\n      }\n    }\n\n    le = le->next;\n  }\n  return 0;\n} /* int }}} plugin_dispatch_missing */\n\nvoid plugin_dispatch_cache_event(enum cache_event_type_e event_type,\n                                 unsigned long callbacks_mask, const char *name,\n                                 const value_list_t *vl) {\n  switch (event_type) {\n  case CE_VALUE_NEW:\n    callbacks_mask = 0;\n    for (size_t i = 0; i < list_cache_event_num; i++) {\n      cache_event_func_t *cef = &list_cache_event[i];\n      plugin_cache_event_cb callback = cef->callback;\n\n      if (!callback)\n        continue;\n\n      cache_event_t event = (cache_event_t){.type = event_type,\n                                            .value_list = vl,\n                                            .value_list_name = name,\n                                            .ret = 0};\n\n      plugin_ctx_t old_ctx = plugin_set_ctx(cef->plugin_ctx);\n      int status = (*callback)(&event, &cef->user_data);\n      plugin_set_ctx(old_ctx);\n\n      if (status != 0) {\n        ERROR(\"plugin_dispatch_cache_event: Callback \\\"%s\\\" failed with status \"\n              \"%i for event NEW.\",\n              cef->name, status);\n      } else {\n        if (event.ret) {\n          DEBUG(\n              \"plugin_dispatch_cache_event: Callback \\\"%s\\\" subscribed to %s.\",\n              cef->name, name);\n          callbacks_mask |= (1 << (i));\n        } else {\n          DEBUG(\"plugin_dispatch_cache_event: Callback \\\"%s\\\" ignores %s.\",\n                cef->name, name);\n        }\n      }\n    }\n\n    if (callbacks_mask)\n      uc_set_callbacks_mask(name, callbacks_mask);\n\n    break;\n  case CE_VALUE_UPDATE:\n  case CE_VALUE_EXPIRED:\n    for (size_t i = 0; i < list_cache_event_num; i++) {\n      cache_event_func_t *cef = &list_cache_event[i];\n      plugin_cache_event_cb callback = cef->callback;\n\n      if (!callback)\n        continue;\n\n      if (callbacks_mask && (1 << (i)) == 0)\n        continue;\n\n      cache_event_t event = (cache_event_t){.type = event_type,\n                                            .value_list = vl,\n                                            .value_list_name = name,\n                                            .ret = 0};\n\n      plugin_ctx_t old_ctx = plugin_set_ctx(cef->plugin_ctx);\n      int status = (*callback)(&event, &cef->user_data);\n      plugin_set_ctx(old_ctx);\n\n      if (status != 0) {\n        ERROR(\"plugin_dispatch_cache_event: Callback \\\"%s\\\" failed with status \"\n              \"%i for event %s.\",\n              cef->name, status,\n              ((event_type == CE_VALUE_UPDATE) ? \"UPDATE\" : \"EXPIRED\"));\n      }\n    }\n    break;\n  }\n  return;\n}\n\nstatic int plugin_dispatch_values_internal(value_list_t *vl) {\n  int status;\n  static c_complain_t no_write_complaint = C_COMPLAIN_INIT_STATIC;\n\n  bool free_meta_data = false;\n\n  assert(vl != NULL);\n\n  /* These fields are initialized by plugin_value_list_clone() if needed: */\n  assert(vl->host[0] != 0);\n  assert(vl->time != 0); /* The time is determined at _enqueue_ time. */\n  assert(vl->interval != 0);\n\n  if (vl->type[0] == 0 || vl->values == NULL || vl->values_len < 1) {\n    ERROR(\"plugin_dispatch_values: Invalid value list \"\n          \"from plugin %s.\",\n          vl->plugin);\n    return -1;\n  }\n\n  /* Free meta data only if the calling function didn't specify any. In\n   * this case matches and targets may add some and the calling function\n   * may not expect (and therefore free) that data. */\n  if (vl->meta == NULL)\n    free_meta_data = true;\n\n  if (list_write == NULL)\n    c_complain_once(LOG_WARNING, &no_write_complaint,\n                    \"plugin_dispatch_values: No write callback has been \"\n                    \"registered. Please load at least one output plugin, \"\n                    \"if you want the collected data to be stored.\");\n\n  if (data_sets == NULL) {\n    ERROR(\"plugin_dispatch_values: No data sets registered. \"\n          \"Could the types database be read? Check \"\n          \"your `TypesDB' setting!\");\n    return -1;\n  }\n\n  data_set_t *ds = NULL;\n  if (c_avl_get(data_sets, vl->type, (void *)&ds) != 0) {\n    char ident[6 * DATA_MAX_NAME_LEN];\n\n    FORMAT_VL(ident, sizeof(ident), vl);\n    INFO(\"plugin_dispatch_values: Dataset not found: %s \"\n         \"(from \\\"%s\\\"), check your types.db!\",\n         vl->type, ident);\n    return -1;\n  }\n\n  DEBUG(\"plugin_dispatch_values: time = %.3f; interval = %.3f; \"\n        \"host = %s; \"\n        \"plugin = %s; plugin_instance = %s; \"\n        \"type = %s; type_instance = %s;\",\n        CDTIME_T_TO_DOUBLE(vl->time), CDTIME_T_TO_DOUBLE(vl->interval),\n        vl->host, vl->plugin, vl->plugin_instance, vl->type, vl->type_instance);\n\n#if COLLECT_DEBUG\n  assert(0 == strcmp(ds->type, vl->type));\n#else\n  if (0 != strcmp(ds->type, vl->type))\n    WARNING(\"plugin_dispatch_values: (ds->type = %s) != (vl->type = %s)\",\n            ds->type, vl->type);\n#endif\n\n#if COLLECT_DEBUG\n  assert(ds->ds_num == vl->values_len);\n#else\n  if (ds->ds_num != vl->values_len) {\n    ERROR(\"plugin_dispatch_values: ds->type = %s: \"\n          \"(ds->ds_num = %\" PRIsz \") != \"\n          \"(vl->values_len = %\" PRIsz \")\",\n          ds->type, ds->ds_num, vl->values_len);\n    return -1;\n  }\n#endif\n\n  escape_slashes(vl->host, sizeof(vl->host));\n  escape_slashes(vl->plugin, sizeof(vl->plugin));\n  escape_slashes(vl->plugin_instance, sizeof(vl->plugin_instance));\n  escape_slashes(vl->type, sizeof(vl->type));\n  escape_slashes(vl->type_instance, sizeof(vl->type_instance));\n\n  if (pre_cache_chain != NULL) {\n    status = fc_process_chain(ds, vl, pre_cache_chain);\n    if (status < 0) {\n      WARNING(\"plugin_dispatch_values: Running the \"\n              \"pre-cache chain failed with \"\n              \"status %i (%#x).\",\n              status, status);\n    } else if (status == FC_TARGET_STOP)\n      return 0;\n  }\n\n  /* Update the value cache */\n  uc_update(ds, vl);\n\n  if (post_cache_chain != NULL) {\n    status = fc_process_chain(ds, vl, post_cache_chain);\n    if (status < 0) {\n      WARNING(\"plugin_dispatch_values: Running the \"\n              \"post-cache chain failed with \"\n              \"status %i (%#x).\",\n              status, status);\n    }\n  } else\n    fc_default_action(ds, vl);\n\n  if ((free_meta_data == true) && (vl->meta != NULL)) {\n    meta_data_destroy(vl->meta);\n    vl->meta = NULL;\n  }\n\n  return 0;\n} /* int plugin_dispatch_values_internal */\n\nstatic double get_drop_probability(void) /* {{{ */\n{\n  long pos;\n  long size;\n  long wql;\n\n  pthread_mutex_lock(&write_lock);\n  wql = write_queue_length;\n  pthread_mutex_unlock(&write_lock);\n\n  if (wql < write_limit_low)\n    return 0.0;\n  if (wql >= write_limit_high)\n    return 1.0;\n\n  pos = 1 + wql - write_limit_low;\n  size = 1 + write_limit_high - write_limit_low;\n\n  return (double)pos / (double)size;\n} /* }}} double get_drop_probability */\n\nstatic bool check_drop_value(void) /* {{{ */\n{\n  static cdtime_t last_message_time;\n  static pthread_mutex_t last_message_lock = PTHREAD_MUTEX_INITIALIZER;\n\n  double p;\n  double q;\n  int status;\n\n  if (write_limit_high == 0)\n    return false;\n\n  p = get_drop_probability();\n  if (p == 0.0)\n    return false;\n\n  status = pthread_mutex_trylock(&last_message_lock);\n  if (status == 0) {\n    cdtime_t now;\n\n    now = cdtime();\n    if ((now - last_message_time) > TIME_T_TO_CDTIME_T(1)) {\n      last_message_time = now;\n      ERROR(\"plugin_dispatch_values: Low water mark \"\n            \"reached. Dropping %.0f%% of metrics.\",\n            100.0 * p);\n    }\n    pthread_mutex_unlock(&last_message_lock);\n  }\n\n  if (p == 1.0)\n    return true;\n\n  q = cdrand_d();\n  if (q > p)\n    return true;\n  else\n    return false;\n} /* }}} bool check_drop_value */\n\nEXPORT int plugin_dispatch_values(value_list_t const *vl) {\n  int status;\n\n  if (check_drop_value()) {\n    if (record_statistics) {\n      pthread_mutex_lock(&statistics_lock);\n      stats_values_dropped++;\n      pthread_mutex_unlock(&statistics_lock);\n    }\n    return 0;\n  }\n\n  status = plugin_write_enqueue(vl);\n  if (status != 0) {\n    ERROR(\"plugin_dispatch_values: plugin_write_enqueue failed with status %i \"\n          \"(%s).\",\n          status, STRERROR(status));\n    return status;\n  }\n\n  return 0;\n}\n\n__attribute__((sentinel)) int\nplugin_dispatch_multivalue(value_list_t const *template, /* {{{ */\n                           bool store_percentage, int store_type, ...) {\n  value_list_t *vl;\n  int failed = 0;\n  gauge_t sum = 0.0;\n  va_list ap;\n\n  if (check_drop_value()) {\n    if (record_statistics) {\n      pthread_mutex_lock(&statistics_lock);\n      stats_values_dropped++;\n      pthread_mutex_unlock(&statistics_lock);\n    }\n    return 0;\n  }\n\n  assert(template->values_len == 1);\n\n  /* Calculate sum for Gauge to calculate percent if needed */\n  if (DS_TYPE_GAUGE == store_type) {\n    va_start(ap, store_type);\n    while (42) {\n      char const *name;\n      gauge_t value;\n\n      name = va_arg(ap, char const *);\n      if (name == NULL)\n        break;\n\n      value = va_arg(ap, gauge_t);\n      if (!isnan(value))\n        sum += value;\n    }\n    va_end(ap);\n  }\n\n  vl = plugin_value_list_clone(template);\n  /* plugin_value_list_clone makes sure vl->time is set to non-zero. */\n  if (store_percentage)\n    sstrncpy(vl->type, \"percent\", sizeof(vl->type));\n\n  va_start(ap, store_type);\n  while (42) {\n    char const *name;\n    int status;\n\n    /* Set the type instance. */\n    name = va_arg(ap, char const *);\n    if (name == NULL)\n      break;\n    sstrncpy(vl->type_instance, name, sizeof(vl->type_instance));\n\n    /* Set the value. */\n    switch (store_type) {\n    case DS_TYPE_GAUGE:\n      vl->values[0].gauge = va_arg(ap, gauge_t);\n      if (store_percentage)\n        vl->values[0].gauge *= sum ? (100.0 / sum) : NAN;\n      break;\n    case DS_TYPE_ABSOLUTE:\n      vl->values[0].absolute = va_arg(ap, absolute_t);\n      break;\n    case DS_TYPE_COUNTER:\n      vl->values[0].counter = va_arg(ap, counter_t);\n      break;\n    case DS_TYPE_DERIVE:\n      vl->values[0].derive = va_arg(ap, derive_t);\n      break;\n    default:\n      ERROR(\"plugin_dispatch_multivalue: given store_type is incorrect.\");\n      failed++;\n    }\n\n    status = plugin_write_enqueue(vl);\n    if (status != 0)\n      failed++;\n  }\n  va_end(ap);\n\n  plugin_value_list_free(vl);\n  return failed;\n} /* }}} int plugin_dispatch_multivalue */\n\nEXPORT int plugin_dispatch_notification(const notification_t *notif) {\n  llentry_t *le;\n  /* Possible TODO: Add flap detection here */\n\n  DEBUG(\"plugin_dispatch_notification: severity = %i; message = %s; \"\n        \"time = %.3f; host = %s;\",\n        notif->severity, notif->message, CDTIME_T_TO_DOUBLE(notif->time),\n        notif->host);\n\n  /* Nobody cares for notifications */\n  if (list_notification == NULL)\n    return -1;\n\n  le = llist_head(list_notification);\n  while (le != NULL) {\n    callback_func_t *cf;\n    plugin_notification_cb callback;\n    int status;\n\n    /* do not switch plugin context; rather keep the context\n     * (interval) information of the calling plugin */\n\n    cf = le->value;\n    callback = cf->cf_callback;\n    status = (*callback)(notif, &cf->cf_udata);\n    if (status != 0) {\n      WARNING(\"plugin_dispatch_notification: Notification \"\n              \"callback %s returned %i.\",\n              le->key, status);\n    }\n\n    le = le->next;\n  }\n\n  return 0;\n} /* int plugin_dispatch_notification */\n\nEXPORT void plugin_log(int level, const char *format, ...) {\n  char msg[1024];\n  va_list ap;\n  llentry_t *le;\n\n#if !COLLECT_DEBUG\n  if (level >= LOG_DEBUG)\n    return;\n#endif\n\n  va_start(ap, format);\n  vsnprintf(msg, sizeof(msg), format, ap);\n  msg[sizeof(msg) - 1] = '\\0';\n  va_end(ap);\n\n  if (list_log == NULL) {\n    fprintf(stderr, \"%s\\n\", msg);\n    return;\n  }\n\n  le = llist_head(list_log);\n  while (le != NULL) {\n    callback_func_t *cf;\n    plugin_log_cb callback;\n\n    cf = le->value;\n    callback = cf->cf_callback;\n\n    /* do not switch plugin context; rather keep the context\n     * (interval) information of the calling plugin */\n\n    (*callback)(level, msg, &cf->cf_udata);\n\n    le = le->next;\n  }\n} /* void plugin_log */\n\nvoid daemon_log(int level, const char *format, ...) {\n  char msg[1024] = \"\"; // Size inherits from plugin_log()\n\n  char const *name = plugin_get_ctx().name;\n  if (name == NULL)\n    name = \"UNKNOWN\";\n\n  va_list ap;\n  va_start(ap, format);\n  vsnprintf(msg, sizeof(msg), format, ap);\n  va_end(ap);\n\n  plugin_log(level, \"%s plugin: %s\", name, msg);\n} /* void daemon_log */\n\nint parse_log_severity(const char *severity) {\n  int log_level = -1;\n\n  if ((0 == strcasecmp(severity, \"emerg\")) ||\n      (0 == strcasecmp(severity, \"alert\")) ||\n      (0 == strcasecmp(severity, \"crit\")) || (0 == strcasecmp(severity, \"err\")))\n    log_level = LOG_ERR;\n  else if (0 == strcasecmp(severity, \"warning\"))\n    log_level = LOG_WARNING;\n  else if (0 == strcasecmp(severity, \"notice\"))\n    log_level = LOG_NOTICE;\n  else if (0 == strcasecmp(severity, \"info\"))\n    log_level = LOG_INFO;\n#if COLLECT_DEBUG\n  else if (0 == strcasecmp(severity, \"debug\"))\n    log_level = LOG_DEBUG;\n#endif /* COLLECT_DEBUG */\n\n  return log_level;\n} /* int parse_log_severity */\n\nEXPORT int parse_notif_severity(const char *severity) {\n  int notif_severity = -1;\n\n  if (strcasecmp(severity, \"FAILURE\") == 0)\n    notif_severity = NOTIF_FAILURE;\n  else if (strcmp(severity, \"OKAY\") == 0)\n    notif_severity = NOTIF_OKAY;\n  else if ((strcmp(severity, \"WARNING\") == 0) ||\n           (strcmp(severity, \"WARN\") == 0))\n    notif_severity = NOTIF_WARNING;\n\n  return notif_severity;\n} /* int parse_notif_severity */\n\nEXPORT const data_set_t *plugin_get_ds(const char *name) {\n  data_set_t *ds;\n\n  if (data_sets == NULL) {\n    P_ERROR(\"plugin_get_ds: No data sets are defined yet.\");\n    return NULL;\n  }\n\n  if (c_avl_get(data_sets, name, (void *)&ds) != 0) {\n    DEBUG(\"No such dataset registered: %s\", name);\n    return NULL;\n  }\n\n  return ds;\n} /* data_set_t *plugin_get_ds */\n\nstatic int plugin_notification_meta_add(notification_t *n, const char *name,\n                                        enum notification_meta_type_e type,\n                                        const void *value) {\n  notification_meta_t *meta;\n  notification_meta_t *tail;\n\n  if ((n == NULL) || (name == NULL) || (value == NULL)) {\n    ERROR(\"plugin_notification_meta_add: A pointer is NULL!\");\n    return -1;\n  }\n\n  meta = calloc(1, sizeof(*meta));\n  if (meta == NULL) {\n    ERROR(\"plugin_notification_meta_add: calloc failed.\");\n    return -1;\n  }\n\n  sstrncpy(meta->name, name, sizeof(meta->name));\n  meta->type = type;\n\n  switch (type) {\n  case NM_TYPE_STRING: {\n    meta->nm_value.nm_string = strdup((const char *)value);\n    if (meta->nm_value.nm_string == NULL) {\n      ERROR(\"plugin_notification_meta_add: strdup failed.\");\n      sfree(meta);\n      return -1;\n    }\n    break;\n  }\n  case NM_TYPE_SIGNED_INT: {\n    meta->nm_value.nm_signed_int = *((int64_t *)value);\n    break;\n  }\n  case NM_TYPE_UNSIGNED_INT: {\n    meta->nm_value.nm_unsigned_int = *((uint64_t *)value);\n    break;\n  }\n  case NM_TYPE_DOUBLE: {\n    meta->nm_value.nm_double = *((double *)value);\n    break;\n  }\n  case NM_TYPE_BOOLEAN: {\n    meta->nm_value.nm_boolean = *((bool *)value);\n    break;\n  }\n  default: {\n    ERROR(\"plugin_notification_meta_add: Unknown type: %i\", type);\n    sfree(meta);\n    return -1;\n  }\n  } /* switch (type) */\n\n  meta->next = NULL;\n  tail = n->meta;\n  while ((tail != NULL) && (tail->next != NULL))\n    tail = tail->next;\n\n  if (tail == NULL)\n    n->meta = meta;\n  else\n    tail->next = meta;\n\n  return 0;\n} /* int plugin_notification_meta_add */\n\nint plugin_notification_meta_add_string(notification_t *n, const char *name,\n                                        const char *value) {\n  return plugin_notification_meta_add(n, name, NM_TYPE_STRING, value);\n}\n\nint plugin_notification_meta_add_signed_int(notification_t *n, const char *name,\n                                            int64_t value) {\n  return plugin_notification_meta_add(n, name, NM_TYPE_SIGNED_INT, &value);\n}\n\nint plugin_notification_meta_add_unsigned_int(notification_t *n,\n                                              const char *name,\n                                              uint64_t value) {\n  return plugin_notification_meta_add(n, name, NM_TYPE_UNSIGNED_INT, &value);\n}\n\nint plugin_notification_meta_add_double(notification_t *n, const char *name,\n                                        double value) {\n  return plugin_notification_meta_add(n, name, NM_TYPE_DOUBLE, &value);\n}\n\nint plugin_notification_meta_add_boolean(notification_t *n, const char *name,\n                                         bool value) {\n  return plugin_notification_meta_add(n, name, NM_TYPE_BOOLEAN, &value);\n}\n\nint plugin_notification_meta_copy(notification_t *dst,\n                                  const notification_t *src) {\n  assert(dst != NULL);\n  assert(src != NULL);\n  assert(dst != src);\n  assert((src->meta == NULL) || (src->meta != dst->meta));\n\n  for (notification_meta_t *meta = src->meta; meta != NULL; meta = meta->next) {\n    if (meta->type == NM_TYPE_STRING)\n      plugin_notification_meta_add_string(dst, meta->name,\n                                          meta->nm_value.nm_string);\n    else if (meta->type == NM_TYPE_SIGNED_INT)\n      plugin_notification_meta_add_signed_int(dst, meta->name,\n                                              meta->nm_value.nm_signed_int);\n    else if (meta->type == NM_TYPE_UNSIGNED_INT)\n      plugin_notification_meta_add_unsigned_int(dst, meta->name,\n                                                meta->nm_value.nm_unsigned_int);\n    else if (meta->type == NM_TYPE_DOUBLE)\n      plugin_notification_meta_add_double(dst, meta->name,\n                                          meta->nm_value.nm_double);\n    else if (meta->type == NM_TYPE_BOOLEAN)\n      plugin_notification_meta_add_boolean(dst, meta->name,\n                                           meta->nm_value.nm_boolean);\n  }\n\n  return 0;\n} /* int plugin_notification_meta_copy */\n\nint plugin_notification_meta_free(notification_meta_t *n) {\n  notification_meta_t *this;\n  notification_meta_t *next;\n\n  if (n == NULL) {\n    ERROR(\"plugin_notification_meta_free: n == NULL!\");\n    return -1;\n  }\n\n  this = n;\n  while (this != NULL) {\n    next = this->next;\n\n    if (this->type == NM_TYPE_STRING) {\n      /* Assign to a temporary variable to work around nm_string's const\n       * modifier. */\n      void *tmp = (void *)this->nm_value.nm_string;\n\n      sfree(tmp);\n      this->nm_value.nm_string = NULL;\n    }\n    sfree(this);\n\n    this = next;\n  }\n\n  return 0;\n} /* int plugin_notification_meta_free */\n\nstatic void plugin_ctx_destructor(void *ctx) {\n  sfree(ctx);\n} /* void plugin_ctx_destructor */\n\nstatic plugin_ctx_t ctx_init = {/* interval = */ 0};\n\nstatic plugin_ctx_t *plugin_ctx_create(void) {\n  plugin_ctx_t *ctx;\n\n  ctx = malloc(sizeof(*ctx));\n  if (ctx == NULL) {\n    ERROR(\"Failed to allocate plugin context: %s\", STRERRNO);\n    return NULL;\n  }\n\n  *ctx = ctx_init;\n  assert(plugin_ctx_key_initialized);\n  pthread_setspecific(plugin_ctx_key, ctx);\n  DEBUG(\"Created new plugin context.\");\n  return ctx;\n} /* int plugin_ctx_create */\n\nEXPORT void plugin_init_ctx(void) {\n  pthread_key_create(&plugin_ctx_key, plugin_ctx_destructor);\n  plugin_ctx_key_initialized = true;\n} /* void plugin_init_ctx */\n\nEXPORT plugin_ctx_t plugin_get_ctx(void) {\n  plugin_ctx_t *ctx;\n\n  assert(plugin_ctx_key_initialized);\n  ctx = pthread_getspecific(plugin_ctx_key);\n\n  if (ctx == NULL) {\n    ctx = plugin_ctx_create();\n    /* this must no happen -- exit() instead? */\n    if (ctx == NULL)\n      return ctx_init;\n  }\n\n  return *ctx;\n} /* plugin_ctx_t plugin_get_ctx */\n\nEXPORT plugin_ctx_t plugin_set_ctx(plugin_ctx_t ctx) {\n  plugin_ctx_t *c;\n  plugin_ctx_t old;\n\n  assert(plugin_ctx_key_initialized);\n  c = pthread_getspecific(plugin_ctx_key);\n\n  if (c == NULL) {\n    c = plugin_ctx_create();\n    /* this must no happen -- exit() instead? */\n    if (c == NULL)\n      return ctx_init;\n  }\n\n  old = *c;\n  *c = ctx;\n\n  return old;\n} /* void plugin_set_ctx */\n\nEXPORT cdtime_t plugin_get_interval(void) {\n  cdtime_t interval;\n\n  interval = plugin_get_ctx().interval;\n  if (interval > 0)\n    return interval;\n\n  P_ERROR(\"plugin_get_interval: Unable to determine Interval from context.\");\n\n  return cf_get_default_interval();\n} /* cdtime_t plugin_get_interval */\n\ntypedef struct {\n  plugin_ctx_t ctx;\n  void *(*start_routine)(void *);\n  void *arg;\n} plugin_thread_t;\n\nstatic void *plugin_thread_start(void *arg) {\n  plugin_thread_t *plugin_thread = arg;\n\n  void *(*start_routine)(void *) = plugin_thread->start_routine;\n  void *plugin_arg = plugin_thread->arg;\n\n  plugin_set_ctx(plugin_thread->ctx);\n\n  sfree(plugin_thread);\n\n  return start_routine(plugin_arg);\n} /* void *plugin_thread_start */\n\nint plugin_thread_create(pthread_t *thread, const pthread_attr_t *attr,\n                         void *(*start_routine)(void *), void *arg,\n                         char const *name) {\n  plugin_thread_t *plugin_thread;\n\n  plugin_thread = malloc(sizeof(*plugin_thread));\n  if (plugin_thread == NULL)\n    return ENOMEM;\n\n  plugin_thread->ctx = plugin_get_ctx();\n  plugin_thread->start_routine = start_routine;\n  plugin_thread->arg = arg;\n\n  int ret = pthread_create(thread, attr, plugin_thread_start, plugin_thread);\n  if (ret != 0) {\n    sfree(plugin_thread);\n    return ret;\n  }\n\n  if (name != NULL)\n    set_thread_name(*thread, name);\n\n  return 0;\n} /* int plugin_thread_create */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-collectd-5.10.0-icicefkrlae7wizwnsjlpgrx3lkx7h7i/spack-src/src/collectdctl.pod",
        "/tmp/vanessa/spack-stage/spack-stage-collectd-5.10.0-icicefkrlae7wizwnsjlpgrx3lkx7h7i/spack-src/src/collectdctl.c",
        "/tmp/vanessa/spack-stage/spack-stage-collectd-5.10.0-icicefkrlae7wizwnsjlpgrx3lkx7h7i/spack-src/src/hddtemp.c",
        "/tmp/vanessa/spack-stage/spack-stage-collectd-5.10.0-icicefkrlae7wizwnsjlpgrx3lkx7h7i/spack-src/contrib/collectd2html.pl",
        "/tmp/vanessa/spack-stage/spack-stage-collectd-5.10.0-icicefkrlae7wizwnsjlpgrx3lkx7h7i/spack-src/contrib/collection3/share/shortcut-icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-collectd-5.10.0-icicefkrlae7wizwnsjlpgrx3lkx7h7i/spack-src/docs/review_comments_example.png"
    ],
    "total_files": 489
}