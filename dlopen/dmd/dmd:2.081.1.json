{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-dmd-2.081.1-vqq6jjlqlkf6xkxhau7opmwbvotgmaut/spack-src/src/dmd/link.d": "/**\n * Compiler implementation of the\n * $(LINK2 http://www.dlang.org, D programming language).\n *\n * Copyright:   Copyright (C) 1999-2018 by The D Language Foundation, All Rights Reserved\n * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/link.d, _link.d)\n * Documentation:  https://dlang.org/phobos/dmd_link.html\n * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/link.d\n */\n\nmodule dmd.link;\n\nimport core.stdc.ctype;\nimport core.stdc.stdio;\nimport core.stdc.string;\nimport core.sys.posix.stdio;\nimport core.sys.posix.stdlib;\nimport core.sys.posix.unistd;\nimport core.sys.windows.windows;\nimport dmd.errors;\nimport dmd.globals;\nimport dmd.root.file;\nimport dmd.root.filename;\nimport dmd.root.outbuffer;\nimport dmd.root.rmem;\nimport dmd.utils;\n\nversion (Posix) extern (C) int pipe(int*);\nversion (Windows) extern (C) int putenv(const char*);\nversion (Windows) extern (C) int spawnlp(int, const char*, const char*, const char*, const char*);\nversion (Windows) extern (C) int spawnl(int, const char*, const char*, const char*, const char*);\nversion (Windows) extern (C) int spawnv(int, const char*, const char**);\nversion (CRuntime_Microsoft)\n{\n  // until the new windows bindings are available when building dmd.\n  static if(!is(STARTUPINFOA))\n  {\n    alias STARTUPINFOA = STARTUPINFO;\n\n    // dwCreationFlags for CreateProcess() and CreateProcessAsUser()\n    enum : DWORD {\n      DEBUG_PROCESS               = 0x00000001,\n      DEBUG_ONLY_THIS_PROCESS     = 0x00000002,\n      CREATE_SUSPENDED            = 0x00000004,\n      DETACHED_PROCESS            = 0x00000008,\n      CREATE_NEW_CONSOLE          = 0x00000010,\n      NORMAL_PRIORITY_CLASS       = 0x00000020,\n      IDLE_PRIORITY_CLASS         = 0x00000040,\n      HIGH_PRIORITY_CLASS         = 0x00000080,\n      REALTIME_PRIORITY_CLASS     = 0x00000100,\n      CREATE_NEW_PROCESS_GROUP    = 0x00000200,\n      CREATE_UNICODE_ENVIRONMENT  = 0x00000400,\n      CREATE_SEPARATE_WOW_VDM     = 0x00000800,\n      CREATE_SHARED_WOW_VDM       = 0x00001000,\n      CREATE_FORCEDOS             = 0x00002000,\n      BELOW_NORMAL_PRIORITY_CLASS = 0x00004000,\n      ABOVE_NORMAL_PRIORITY_CLASS = 0x00008000,\n      CREATE_BREAKAWAY_FROM_JOB   = 0x01000000,\n      CREATE_WITH_USERPROFILE     = 0x02000000,\n      CREATE_DEFAULT_ERROR_MODE   = 0x04000000,\n      CREATE_NO_WINDOW            = 0x08000000,\n      PROFILE_USER                = 0x10000000,\n      PROFILE_KERNEL              = 0x20000000,\n      PROFILE_SERVER              = 0x40000000\n    }\n  }\n}\n\n/****************************************\n * Write filename to cmdbuf, quoting if necessary.\n */\nprivate void writeFilename(OutBuffer* buf, const(char)* filename, size_t len)\n{\n    /* Loop and see if we need to quote\n     */\n    for (size_t i = 0; i < len; i++)\n    {\n        char c = filename[i];\n        if (isalnum(c) || c == '_')\n            continue;\n        /* Need to quote\n         */\n        buf.writeByte('\"');\n        buf.write(filename, len);\n        buf.writeByte('\"');\n        return;\n    }\n    /* No quoting necessary\n     */\n    buf.write(filename, len);\n}\n\nprivate void writeFilename(OutBuffer* buf, const(char)* filename)\n{\n    writeFilename(buf, filename, strlen(filename));\n}\n\nversion (Posix)\n{\n    /*****************************\n     * As it forwards the linker error message to stderr, checks for the presence\n     * of an error indicating lack of a main function (NME_ERR_MSG).\n     *\n     * Returns:\n     *      1 if there is a no main error\n     *     -1 if there is an IO error\n     *      0 otherwise\n     */\n    private int findNoMainError(int fd)\n    {\n        version (OSX)\n        {\n            static __gshared const(char)* nmeErrorMessage = \"`__Dmain`, referenced from:\";\n        }\n        else\n        {\n            static __gshared const(char)* nmeErrorMessage = \"undefined reference to `_Dmain`\";\n        }\n        FILE* stream = fdopen(fd, \"r\");\n        if (stream is null)\n            return -1;\n        const(size_t) len = 64 * 1024 - 1;\n        char[len + 1] buffer; // + '\\0'\n        size_t beg = 0, end = len;\n        bool nmeFound = false;\n        for (;;)\n        {\n            // read linker output\n            const(size_t) n = fread(&buffer[beg], 1, len - beg, stream);\n            if (beg + n < len && ferror(stream))\n                return -1;\n            buffer[(end = beg + n)] = '\\0';\n            // search error message, stop at last complete line\n            const(char)* lastSep = strrchr(buffer.ptr, '\\n');\n            if (lastSep)\n                buffer[(end = lastSep - &buffer[0])] = '\\0';\n            if (strstr(&buffer[0], nmeErrorMessage))\n                nmeFound = true;\n            if (lastSep)\n                buffer[end++] = '\\n';\n            if (fwrite(&buffer[0], 1, end, stderr) < end)\n                return -1;\n            if (beg + n < len && feof(stream))\n                break;\n            // copy over truncated last line\n            memcpy(&buffer[0], &buffer[end], (beg = len - end));\n        }\n        return nmeFound ? 1 : 0;\n    }\n}\n\n/*****************************\n * Run the linker.  Return status of execution.\n */\npublic int runLINK()\n{\n    version (Windows)\n    {\n        if (global.params.mscoff)\n        {\n            OutBuffer cmdbuf;\n            cmdbuf.writestring(\"/NOLOGO\");\n            for (size_t i = 0; i < global.params.objfiles.dim; i++)\n            {\n                cmdbuf.writeByte(' ');\n                const(char)* p = global.params.objfiles[i];\n                writeFilename(&cmdbuf, p);\n            }\n            if (global.params.resfile)\n            {\n                cmdbuf.writeByte(' ');\n                writeFilename(&cmdbuf, global.params.resfile);\n            }\n            cmdbuf.writeByte(' ');\n            if (global.params.exefile)\n            {\n                cmdbuf.writestring(\"/OUT:\");\n                writeFilename(&cmdbuf, global.params.exefile);\n            }\n            else\n            {\n                /* Generate exe file name from first obj name.\n                 * No need to add it to cmdbuf because the linker will default to it.\n                 */\n                const(char)* n = global.params.objfiles[0];\n                n = FileName.name(n);\n                global.params.exefile = cast(char*)FileName.forceExt(n, \"exe\");\n            }\n            // Make sure path to exe file exists\n            ensurePathToNameExists(Loc.initial, global.params.exefile);\n            cmdbuf.writeByte(' ');\n            if (global.params.mapfile)\n            {\n                cmdbuf.writestring(\"/MAP:\");\n                writeFilename(&cmdbuf, global.params.mapfile);\n            }\n            else if (global.params.map)\n            {\n                const(char)* fn = FileName.forceExt(global.params.exefile, \"map\");\n                const(char)* path = FileName.path(global.params.exefile);\n                const(char)* p;\n                if (path[0] == '\\0')\n                    p = FileName.combine(global.params.objdir, fn);\n                else\n                    p = fn;\n                cmdbuf.writestring(\"/MAP:\");\n                writeFilename(&cmdbuf, p);\n            }\n            for (size_t i = 0; i < global.params.libfiles.dim; i++)\n            {\n                cmdbuf.writeByte(' ');\n                cmdbuf.writestring(\"/DEFAULTLIB:\");\n                writeFilename(&cmdbuf, global.params.libfiles[i]);\n            }\n            if (global.params.deffile)\n            {\n                cmdbuf.writeByte(' ');\n                cmdbuf.writestring(\"/DEF:\");\n                writeFilename(&cmdbuf, global.params.deffile);\n            }\n            if (global.params.symdebug)\n            {\n                cmdbuf.writeByte(' ');\n                cmdbuf.writestring(\"/DEBUG\");\n                // in release mode we need to reactivate /OPT:REF after /DEBUG\n                if (global.params.release)\n                    cmdbuf.writestring(\" /OPT:REF\");\n            }\n            if (global.params.dll)\n            {\n                cmdbuf.writeByte(' ');\n                cmdbuf.writestring(\"/DLL\");\n            }\n            for (size_t i = 0; i < global.params.linkswitches.dim; i++)\n            {\n                cmdbuf.writeByte(' ');\n                cmdbuf.writestring(global.params.linkswitches[i]);\n            }\n\n            VSOptions vsopt;\n            vsopt.initialize();\n            const(char)* lflags = vsopt.linkOptions(global.params.is64bit);\n            if (lflags)\n            {\n                cmdbuf.writeByte(' ');\n                cmdbuf.writestring(lflags);\n            }\n            char* p = cmdbuf.peekString();\n            const(char)* lnkfilename = null;\n            size_t plen = strlen(p);\n            if (plen > 7000)\n            {\n                lnkfilename = FileName.forceExt(global.params.exefile, \"lnk\");\n                auto flnk = File(lnkfilename);\n                flnk.setbuffer(p, plen);\n                flnk._ref = 1;\n                if (flnk.write())\n                    error(Loc.initial, \"error writing file %s\", lnkfilename);\n                if (strlen(lnkfilename) < plen)\n                    sprintf(p, \"@%s\", lnkfilename);\n            }\n            const(char)* linkcmd = getenv(global.params.is64bit ? \"LINKCMD64\" : \"LINKCMD\");\n            if (!linkcmd)\n                linkcmd = getenv(\"LINKCMD\"); // backward compatible\n            if (!linkcmd)\n                linkcmd = vsopt.linkerPath(global.params.is64bit);\n\n            int status = executecmd(linkcmd, p);\n            if (lnkfilename)\n            {\n                remove(lnkfilename);\n                FileName.free(lnkfilename);\n            }\n            return status;\n        }\n        else\n        {\n            OutBuffer cmdbuf;\n            global.params.libfiles.push(\"user32\");\n            global.params.libfiles.push(\"kernel32\");\n            for (size_t i = 0; i < global.params.objfiles.dim; i++)\n            {\n                if (i)\n                    cmdbuf.writeByte('+');\n                const(char)* p = global.params.objfiles[i];\n                const(char)* basename = FileName.removeExt(FileName.name(p));\n                const(char)* ext = FileName.ext(p);\n                if (ext && !strchr(basename, '.'))\n                {\n                    // Write name sans extension (but not if a double extension)\n                    writeFilename(&cmdbuf, p, ext - p - 1);\n                }\n                else\n                    writeFilename(&cmdbuf, p);\n                FileName.free(basename);\n            }\n            cmdbuf.writeByte(',');\n            if (global.params.exefile)\n                writeFilename(&cmdbuf, global.params.exefile);\n            else\n            {\n                /* Generate exe file name from first obj name.\n                 * No need to add it to cmdbuf because the linker will default to it.\n                 */\n                const(char)* n = global.params.objfiles[0];\n                n = FileName.name(n);\n                global.params.exefile = cast(char*)FileName.forceExt(n, \"exe\");\n            }\n            // Make sure path to exe file exists\n            ensurePathToNameExists(Loc.initial, global.params.exefile);\n            cmdbuf.writeByte(',');\n            if (global.params.mapfile)\n                writeFilename(&cmdbuf, global.params.mapfile);\n            else if (global.params.map)\n            {\n                const(char)* fn = FileName.forceExt(global.params.exefile, \"map\");\n                const(char)* path = FileName.path(global.params.exefile);\n                const(char)* p;\n                if (path[0] == '\\0')\n                    p = FileName.combine(global.params.objdir, fn);\n                else\n                    p = fn;\n                writeFilename(&cmdbuf, p);\n            }\n            else\n                cmdbuf.writestring(\"nul\");\n            cmdbuf.writeByte(',');\n            for (size_t i = 0; i < global.params.libfiles.dim; i++)\n            {\n                if (i)\n                    cmdbuf.writeByte('+');\n                writeFilename(&cmdbuf, global.params.libfiles[i]);\n            }\n            if (global.params.deffile)\n            {\n                cmdbuf.writeByte(',');\n                writeFilename(&cmdbuf, global.params.deffile);\n            }\n            /* Eliminate unnecessary trailing commas    */\n            while (1)\n            {\n                size_t i = cmdbuf.offset;\n                if (!i || cmdbuf.data[i - 1] != ',')\n                    break;\n                cmdbuf.offset--;\n            }\n            if (global.params.resfile)\n            {\n                cmdbuf.writestring(\"/RC:\");\n                writeFilename(&cmdbuf, global.params.resfile);\n            }\n            if (global.params.map || global.params.mapfile)\n                cmdbuf.writestring(\"/m\");\n            version (none)\n            {\n                if (debuginfo)\n                    cmdbuf.writestring(\"/li\");\n                if (codeview)\n                {\n                    cmdbuf.writestring(\"/co\");\n                    if (codeview3)\n                        cmdbuf.writestring(\":3\");\n                }\n            }\n            else\n            {\n                if (global.params.symdebug)\n                    cmdbuf.writestring(\"/co\");\n            }\n            cmdbuf.writestring(\"/noi\");\n            for (size_t i = 0; i < global.params.linkswitches.dim; i++)\n            {\n                cmdbuf.writestring(global.params.linkswitches[i]);\n            }\n            cmdbuf.writeByte(';');\n            char* p = cmdbuf.peekString();\n            const(char)* lnkfilename = null;\n            size_t plen = strlen(p);\n            if (plen > 7000)\n            {\n                lnkfilename = FileName.forceExt(global.params.exefile, \"lnk\");\n                auto flnk = File(lnkfilename);\n                flnk.setbuffer(p, plen);\n                flnk._ref = 1;\n                if (flnk.write())\n                    error(Loc.initial, \"error writing file %s\", lnkfilename);\n                if (strlen(lnkfilename) < plen)\n                    sprintf(p, \"@%s\", lnkfilename);\n            }\n            const(char)* linkcmd = getenv(\"LINKCMD\");\n            if (!linkcmd)\n                linkcmd = \"link\";\n            int status = executecmd(linkcmd, p);\n            if (lnkfilename)\n            {\n                remove(lnkfilename);\n                FileName.free(lnkfilename);\n            }\n            return status;\n        }\n    }\n    else version (Posix)\n    {\n        pid_t childpid;\n        int status;\n        // Build argv[]\n        Strings argv;\n        const(char)* cc = getenv(\"CC\");\n        if (!cc)\n        {\n            argv.push(\"cc\");\n        }\n        else\n        {\n            // Split CC command to support link driver arguments such as -fpie or -flto.\n            char *arg = strdup(cc);\n            const(char)* tok = strtok(arg, \" \");\n            while (tok)\n            {\n                argv.push(mem.xstrdup(tok));\n                tok = strtok(null, \" \");\n            }\n            free(arg);\n        }\n        argv.append(&global.params.objfiles);\n        version (OSX)\n        {\n            // If we are on Mac OS X and linking a dynamic library,\n            // add the \"-dynamiclib\" flag\n            if (global.params.dll)\n                argv.push(\"-dynamiclib\");\n        }\n        else version (Posix)\n        {\n            if (global.params.dll)\n                argv.push(\"-shared\");\n        }\n        // None of that a.out stuff. Use explicit exe file name, or\n        // generate one from name of first source file.\n        argv.push(\"-o\");\n        if (global.params.exefile)\n        {\n            argv.push(global.params.exefile);\n        }\n        else if (global.params.run)\n        {\n            version (all)\n            {\n                char[L_tmpnam + 14 + 1] name;\n                strcpy(name.ptr, P_tmpdir);\n                strcat(name.ptr, \"/dmd_runXXXXXX\");\n                int fd = mkstemp(name.ptr);\n                if (fd == -1)\n                {\n                    error(Loc.initial, \"error creating temporary file\");\n                    return 1;\n                }\n                else\n                    close(fd);\n                global.params.exefile = mem.xstrdup(name.ptr);\n                argv.push(global.params.exefile);\n            }\n            else\n            {\n                /* The use of tmpnam raises the issue of \"is this a security hole\"?\n                 * The hole is that after tmpnam and before the file is opened,\n                 * the attacker modifies the file system to get control of the\n                 * file with that name. I do not know if this is an issue in\n                 * this context.\n                 * We cannot just replace it with mkstemp, because this name is\n                 * passed to the linker that actually opens the file and writes to it.\n                 */\n                char[L_tmpnam + 1] s;\n                char* n = tmpnam(s.ptr);\n                global.params.exefile = mem.xstrdup(n);\n                argv.push(global.params.exefile);\n            }\n        }\n        else\n        {\n            // Generate exe file name from first obj name\n            const(char)* n = global.params.objfiles[0];\n            char* ex;\n            n = FileName.name(n);\n            const(char)* e = FileName.ext(n);\n            if (e)\n            {\n                e--; // back up over '.'\n                ex = cast(char*)mem.xmalloc(e - n + 1);\n                memcpy(ex, n, e - n);\n                ex[e - n] = 0;\n                // If generating dll then force dll extension\n                if (global.params.dll)\n                    ex = cast(char*)FileName.forceExt(ex, global.dll_ext);\n            }\n            else\n                ex = cast(char*)\"a.out\"; // no extension, so give up\n            argv.push(ex);\n            global.params.exefile = ex;\n        }\n        // Make sure path to exe file exists\n        ensurePathToNameExists(Loc.initial, global.params.exefile);\n        if (global.params.symdebug)\n            argv.push(\"-g\");\n        if (global.params.is64bit)\n            argv.push(\"-m64\");\n        else\n            argv.push(\"-m32\");\n        version (OSX)\n        {\n            /* Without this switch, ld generates messages of the form:\n             * ld: warning: could not create compact unwind for __Dmain: offset of saved registers too far to encode\n             * meaning they are further than 255 bytes from the frame register.\n             * ld reverts to the old method instead.\n             * See: https://ghc.haskell.org/trac/ghc/ticket/5019\n             * which gives this tidbit:\n             * \"When a C++ (or x86_64 Objective-C) exception is thrown, the runtime must unwind the\n             *  stack looking for some function to catch the exception.  Traditionally, the unwind\n             *  information is stored in the __TEXT/__eh_frame section of each executable as Dwarf\n             *  CFI (call frame information).  Beginning in Mac OS X 10.6, the unwind information is\n             *  also encoded in the __TEXT/__unwind_info section using a two-level lookup table of\n             *  compact unwind encodings.\n             *  The unwinddump tool displays the content of the __TEXT/__unwind_info section.\"\n             *\n             * A better fix would be to save the registers next to the frame pointer.\n             */\n            argv.push(\"-Xlinker\");\n            argv.push(\"-no_compact_unwind\");\n        }\n        if (global.params.map || global.params.mapfile)\n        {\n            argv.push(\"-Xlinker\");\n            version (OSX)\n            {\n                argv.push(\"-map\");\n            }\n            else\n            {\n                argv.push(\"-Map\");\n            }\n            if (!global.params.mapfile)\n            {\n                const(char)* fn = FileName.forceExt(global.params.exefile, \"map\");\n                const(char)* path = FileName.path(global.params.exefile);\n                const(char)* p;\n                if (path[0] == '\\0')\n                    p = FileName.combine(global.params.objdir, fn);\n                else\n                    p = fn;\n                global.params.mapfile = cast(char*)p;\n            }\n            argv.push(\"-Xlinker\");\n            argv.push(global.params.mapfile);\n        }\n        if (0 && global.params.exefile)\n        {\n            /* This switch enables what is known as 'smart linking'\n             * in the Windows world, where unreferenced sections\n             * are removed from the executable. It eliminates unreferenced\n             * functions, essentially making a 'library' out of a module.\n             * Although it is documented to work with ld version 2.13,\n             * in practice it does not, but just seems to be ignored.\n             * Thomas Kuehne has verified that it works with ld 2.16.1.\n             * BUG: disabled because it causes exception handling to fail\n             * because EH sections are \"unreferenced\" and elided\n             */\n            argv.push(\"-Xlinker\");\n            argv.push(\"--gc-sections\");\n        }\n        /* Add each library, prefixing it with \"-l\".\n         * The order of libraries passed is:\n         *  1. any libraries passed with -L command line switch\n         *  2. libraries specified on the command line\n         *  3. libraries specified by pragma(lib), which were appended\n         *     to global.params.libfiles.\n         *  4. link switches, that may also contain -l libraries\n         *  5. standard libraries.\n         */\n        for (size_t i = 0; i < global.params.libfiles.dim; i++)\n        {\n            const(char)* p = global.params.libfiles[i];\n            size_t plen = strlen(p);\n            if (plen > 2 && p[plen - 2] == '.' && p[plen - 1] == 'a')\n                argv.push(p);\n            else\n            {\n                char* s = cast(char*)mem.xmalloc(plen + 3);\n                s[0] = '-';\n                s[1] = 'l';\n                memcpy(s + 2, p, plen + 1);\n                argv.push(s);\n            }\n        }\n        for (size_t i = 0; i < global.params.dllfiles.dim; i++)\n        {\n            const(char)* p = global.params.dllfiles[i];\n            argv.push(p);\n        }\n        for (size_t i = 0; i < global.params.linkswitches.dim; i++)\n        {\n            const(char)* p = global.params.linkswitches[i];\n            if (!p || !p[0] || !(p[0] == '-' && (p[1] == 'l' || p[1] == 'L')))\n            {\n                // Don't need -Xlinker if switch starts with -l or -L.\n                // Eliding -Xlinker is significant for -L since it allows our paths\n                // to take precedence over gcc defaults.\n                argv.push(\"-Xlinker\");\n            }\n            argv.push(p);\n        }\n        /* D runtime libraries must go after user specified libraries\n         * passed with -l.\n         */\n        const(char)* libname = global.params.symdebug ? global.params.debuglibname : global.params.defaultlibname;\n        size_t slen = libname ? strlen(libname) : 0;\n        if (!global.params.betterC && slen)\n        {\n            char* buf = cast(char*)malloc(3 + slen + 1);\n            strcpy(buf, \"-l\");\n\n            if (slen > 3 + 2 && memcmp(libname, \"lib\".ptr, 3) == 0)\n            {\n                if (memcmp(libname + slen - 2, \".a\".ptr, 2) == 0)\n                {\n                    argv.push(\"-Xlinker\");\n                    argv.push(\"-Bstatic\");\n                    strncat(buf, libname + 3, slen - 3 - 2);\n                    argv.push(buf);\n                    argv.push(\"-Xlinker\");\n                    argv.push(\"-Bdynamic\");\n                }\n                else if (memcmp(libname + slen - 3, \".so\".ptr, 3) == 0)\n                {\n                    strncat(buf, libname + 3, slen - 3 - 3);\n                    argv.push(buf);\n                }\n                else\n                {\n                    strcat(buf, libname);\n                    argv.push(buf);\n                }\n            }\n            else\n            {\n                strcat(buf, libname);\n                argv.push(buf);\n            }\n        }\n        //argv.push(\"-ldruntime\");\n        argv.push(\"-lpthread\");\n        argv.push(\"-lm\");\n        version (linux)\n        {\n            // Changes in ld for Ubuntu 11.10 require this to appear after phobos2\n            argv.push(\"-lrt\");\n            // Link against libdl for phobos usage of dlopen\n            argv.push(\"-ldl\");\n        }\n        if (global.params.verbose)\n        {\n            // Print it\n            OutBuffer buf;\n            for (size_t i = 0; i < argv.dim; i++)\n            {\n                buf.writestring(argv[i]);\n                buf.writeByte(' ');\n            }\n            message(buf.peekString());\n        }\n        argv.push(null);\n        // set up pipes\n        int[2] fds;\n        if (pipe(fds.ptr) == -1)\n        {\n            perror(\"unable to create pipe to linker\");\n            return -1;\n        }\n        childpid = fork();\n        if (childpid == 0)\n        {\n            // pipe linker stderr to fds[0]\n            dup2(fds[1], STDERR_FILENO);\n            close(fds[0]);\n            execvp(argv[0], cast(char**)argv.tdata());\n            perror(argv[0]); // failed to execute\n            return -1;\n        }\n        else if (childpid == -1)\n        {\n            perror(\"unable to fork\");\n            return -1;\n        }\n        close(fds[1]);\n        const(int) nme = findNoMainError(fds[0]);\n        waitpid(childpid, &status, 0);\n        if (WIFEXITED(status))\n        {\n            status = WEXITSTATUS(status);\n            if (status)\n            {\n                if (nme == -1)\n                {\n                    perror(\"error with the linker pipe\");\n                    return -1;\n                }\n                else\n                {\n                    error(Loc.initial, \"linker exited with status %d\", status);\n                    if (nme == 1)\n                        error(Loc.initial, \"no main function specified\");\n                }\n            }\n        }\n        else if (WIFSIGNALED(status))\n        {\n            error(Loc.initial, \"linker killed by signal %d\", WTERMSIG(status));\n            status = 1;\n        }\n        return status;\n    }\n    else\n    {\n        error(Loc.initial, \"linking is not yet supported for this version of DMD.\");\n        return -1;\n    }\n}\n\n\n/******************************\n * Execute a rule.  Return the status.\n *      cmd     program to run\n *      args    arguments to cmd, as a string\n */\nversion (Windows)\n{\n    private int executecmd(const(char)* cmd, const(char)* args)\n    {\n        int status;\n        size_t len;\n        if (global.params.verbose)\n            message(\"%s %s\", cmd, args);\n        if (!global.params.mscoff)\n        {\n            if ((len = strlen(args)) > 255)\n            {\n                char* q = cast(char*)alloca(8 + len + 1);\n                sprintf(q, \"_CMDLINE=%s\", args);\n                status = putenv(q);\n                if (status == 0)\n                {\n                    args = \"@_CMDLINE\";\n                }\n                else\n                {\n                    error(Loc.initial, \"command line length of %d is too long\", len);\n                }\n            }\n        }\n        // Normalize executable path separators\n        // https://issues.dlang.org/show_bug.cgi?id=9330\n        cmd = toWinPath(cmd);\n        version (CRuntime_Microsoft)\n        {\n            // Open scope so dmd doesn't complain about alloca + exception handling\n            {\n                // Use process spawning through the WinAPI to avoid issues with executearg0 and spawnlp\n                OutBuffer cmdbuf;\n                cmdbuf.writestring(\"\\\"\");\n                cmdbuf.writestring(cmd);\n                cmdbuf.writestring(\"\\\" \");\n                cmdbuf.writestring(args);\n\n                STARTUPINFOA startInf;\n                startInf.dwFlags = STARTF_USESTDHANDLES;\n                startInf.hStdInput = GetStdHandle(STD_INPUT_HANDLE);\n                startInf.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);\n                startInf.hStdError = GetStdHandle(STD_ERROR_HANDLE);\n                PROCESS_INFORMATION procInf;\n\n                BOOL b = CreateProcessA(null, cmdbuf.peekString(), null, null, 1, NORMAL_PRIORITY_CLASS, null, null, &startInf, &procInf);\n                if (b)\n                {\n                    WaitForSingleObject(procInf.hProcess, INFINITE);\n                    DWORD returnCode;\n                    GetExitCodeProcess(procInf.hProcess, &returnCode);\n                    status = returnCode;\n                    CloseHandle(procInf.hProcess);\n                }\n                else\n                {\n                    status = -1;\n                }\n            }\n        }\n        else\n        {\n            status = executearg0(cmd, args);\n            if (status == -1)\n            {\n                status = spawnlp(0, cmd, cmd, args, null);\n            }\n        }\n        if (status)\n        {\n            if (status == -1)\n                error(Loc.initial, \"can't run '%s', check PATH\", cmd);\n            else\n                error(Loc.initial, \"linker exited with status %d\", status);\n        }\n        return status;\n    }\n}\n\n/**************************************\n * Attempt to find command to execute by first looking in the directory\n * where DMD was run from.\n * Returns:\n *      -1      did not find command there\n *      !=-1    exit status from command\n */\nversion (Windows)\n{\n    private int executearg0(const(char)* cmd, const(char)* args)\n    {\n        const(char)* file;\n        const(char)* argv0 = global.params.argv0;\n        //printf(\"argv0='%s', cmd='%s', args='%s'\\n\",argv0,cmd,args);\n        // If cmd is fully qualified, we don't do this\n        if (FileName.absolute(cmd))\n            return -1;\n        file = FileName.replaceName(argv0, cmd);\n        //printf(\"spawning '%s'\\n\",file);\n        // spawnlp returns intptr_t in some systems, not int\n        return spawnl(0, file, file, args, null);\n    }\n}\n\n/***************************************\n * Run the compiled program.\n * Return exit status.\n */\npublic int runProgram()\n{\n    //printf(\"runProgram()\\n\");\n    if (global.params.verbose)\n    {\n        OutBuffer buf;\n        buf.writestring(global.params.exefile);\n        for (size_t i = 0; i < global.params.runargs.dim; ++i)\n        {\n            buf.writeByte(' ');\n            buf.writestring(global.params.runargs[i]);\n        }\n        message(buf.peekString());\n    }\n    // Build argv[]\n    Strings argv;\n    argv.push(global.params.exefile);\n    for (size_t i = 0; i < global.params.runargs.dim; ++i)\n    {\n        const(char)* a = global.params.runargs[i];\n        version (Windows)\n        {\n            // BUG: what about \" appearing in the string?\n            if (strchr(a, ' '))\n            {\n                char* b = cast(char*)mem.xmalloc(3 + strlen(a));\n                sprintf(b, \"\\\"%s\\\"\", a);\n                a = b;\n            }\n        }\n        argv.push(a);\n    }\n    argv.push(null);\n    version (Windows)\n    {\n        const(char)* ex = FileName.name(global.params.exefile);\n        if (ex == global.params.exefile)\n            ex = FileName.combine(\".\", ex);\n        else\n            ex = global.params.exefile;\n        // spawnlp returns intptr_t in some systems, not int\n        return spawnv(0, ex, argv.tdata());\n    }\n    else version (Posix)\n    {\n        pid_t childpid;\n        int status;\n        childpid = fork();\n        if (childpid == 0)\n        {\n            const(char)* fn = argv[0];\n            if (!FileName.absolute(fn))\n            {\n                // Make it \"./fn\"\n                fn = FileName.combine(\".\", fn);\n            }\n            execv(fn, cast(char**)argv.tdata());\n            perror(fn); // failed to execute\n            return -1;\n        }\n        waitpid(childpid, &status, 0);\n        if (WIFEXITED(status))\n        {\n            status = WEXITSTATUS(status);\n            //printf(\"--- errorlevel %d\\n\", status);\n        }\n        else if (WIFSIGNALED(status))\n        {\n            error(Loc.initial, \"program killed by signal %d\", WTERMSIG(status));\n            status = 1;\n        }\n        return status;\n    }\n    else\n    {\n        assert(0);\n    }\n}\n\nversion (Windows)\n{\n    struct VSOptions\n    {\n        // evaluated once at startup, reflecting the result of vcvarsall.bat\n        //  from the current environment or the latest Visual Studio installation\n        const(char)* WindowsSdkDir;\n        const(char)* WindowsSdkVersion;\n        const(char)* UCRTSdkDir;\n        const(char)* UCRTVersion;\n        const(char)* VSInstallDir;\n        const(char)* VisualStudioVersion;\n        const(char)* VCInstallDir;\n        const(char)* VCToolsInstallDir; // used by VS 2017\n\n        /**\n         * fill member variables from environment or registry\n         */\n        void initialize()\n        {\n            detectWindowsSDK();\n            detectUCRT();\n            detectVSInstallDir();\n            detectVCInstallDir();\n            detectVCToolsInstallDir();\n        }\n\n        /**\n         * retrieve the name of the default C runtime library\n         * Params:\n         *   x64 = target architecture (x86 if false)\n         * Returns:\n         *   name of the default C runtime library\n         */\n        const(char)* defaultRuntimeLibrary(bool x64)\n        {\n            if (VCInstallDir is null)\n            {\n                detectVCInstallDir();\n                detectVCToolsInstallDir();\n            }\n            if (getVCLibDir(x64))\n                return \"libcmt\";\n            else\n                return \"msvcrt100\"; // mingw replacement\n        }\n\n        /**\n         * retrieve options to be passed to the Microsoft linker\n         * Params:\n         *   x64 = target architecture (x86 if false)\n         * Returns:\n         *   allocated string of options to add to the linker command line\n         */\n        const(char)* linkOptions(bool x64)\n        {\n            OutBuffer cmdbuf;\n            if (auto vclibdir = getVCLibDir(x64))\n            {\n                cmdbuf.writestring(\" /LIBPATH:\\\"\");\n                cmdbuf.writestring(vclibdir);\n                cmdbuf.writeByte('\\\"');\n\n                if (FileName.exists(FileName.combine(vclibdir, \"legacy_stdio_definitions.lib\")))\n                {\n                    // VS2015 or later use UCRT\n                    cmdbuf.writestring(\" legacy_stdio_definitions.lib\");\n                    if (auto p = getUCRTLibPath(x64))\n                    {\n                        cmdbuf.writestring(\" /LIBPATH:\\\"\");\n                        cmdbuf.writestring(p);\n                        cmdbuf.writeByte('\\\"');\n                    }\n                }\n            }\n            if (auto p = getSDKLibPath(x64))\n            {\n                cmdbuf.writestring(\" /LIBPATH:\\\"\");\n                cmdbuf.writestring(p);\n                cmdbuf.writeByte('\\\"');\n            }\n            if (auto p = getenv(\"DXSDK_DIR\"))\n            {\n                // support for old DX SDK installations\n                cmdbuf.writestring(\" /LIBPATH:\\\"\");\n                cmdbuf.writestring(p);\n                cmdbuf.writestring(x64 ? `\\Lib\\x64\"` : `\\Lib\\x86\"`);\n            }\n            return cmdbuf.extractString();\n        }\n\n        /**\n         * retrieve path to the Microsoft linker executable\n         * also modifies PATH environment variable if necessary to find conditionally loaded DLLs\n         * Params:\n         *   x64 = target architecture (x86 if false)\n         * Returns:\n         *   absolute path to link.exe, just \"link.exe\" if not found\n         */\n        const(char)* linkerPath(bool x64)\n        {\n            const(char)* addpath;\n            if (auto p = getVCBinDir(x64, addpath))\n            {\n                OutBuffer cmdbuf;\n                cmdbuf.writestring(p);\n                cmdbuf.writestring(r\"\\link.exe\");\n                if (addpath)\n                {\n                    // debug info needs DLLs from $(VSInstallDir)\\Common7\\IDE for most linker versions\n                    //  so prepend it too the PATH environment variable\n                    const char* path = getenv(\"PATH\");\n                    const pathlen = strlen(path);\n                    const addpathlen = strlen(addpath);\n\n                    char* npath = cast(char*)mem.xmalloc(5 + pathlen + 1 + addpathlen + 1);\n                    memcpy(npath, \"PATH=\".ptr, 5);\n                    memcpy(npath + 5, addpath, addpathlen);\n                    npath[5 + addpathlen] = ';';\n                    memcpy(npath + 5 + addpathlen + 1, path, pathlen + 1);\n                    putenv(npath);\n                }\n                return cmdbuf.extractString();\n            }\n\n            // try lld-link.exe alongside dmd.exe\n            char[MAX_PATH + 1] dmdpath = void;\n            if (GetModuleFileNameA(null, dmdpath.ptr, dmdpath.length) <= MAX_PATH)\n            {\n                auto lldpath = FileName.replaceName(dmdpath.ptr, \"lld-link.exe\");\n                if (FileName.exists(lldpath))\n                    return lldpath;\n            }\n\n            // search PATH to avoid createProcess preferring \"link.exe\" from the dmd folder\n            Strings* paths = FileName.splitPath(getenv(\"PATH\"));\n            if (auto p = FileName.searchPath(paths, \"link.exe\", false))\n                return p;\n            return \"link.exe\";\n        }\n\n    private:\n        /**\n         * detect WindowsSdkDir and WindowsSDKVersion from environment or registry\n         */\n        void detectWindowsSDK()\n        {\n            if (WindowsSdkDir is null)\n                WindowsSdkDir = getenv(\"WindowsSdkDir\");\n\n            if (WindowsSdkDir is null)\n            {\n                WindowsSdkDir = GetRegistryString(r\"Microsoft\\Windows Kits\\Installed Roots\", \"KitsRoot10\");\n                if (WindowsSdkDir && !findLatestSDKDir(FileName.combine(WindowsSdkDir, \"Include\"), r\"um\\windows.h\"))\n                    WindowsSdkDir = null;\n            }\n            if (WindowsSdkDir is null)\n            {\n                WindowsSdkDir = GetRegistryString(r\"Microsoft\\Microsoft SDKs\\Windows\\v8.1\", \"InstallationFolder\");\n                if (WindowsSdkDir && !FileName.exists(FileName.combine(WindowsSdkDir, \"Lib\")))\n                    WindowsSdkDir = null;\n            }\n            if (WindowsSdkDir is null)\n            {\n                WindowsSdkDir = GetRegistryString(r\"Microsoft\\Microsoft SDKs\\Windows\\v8.0\", \"InstallationFolder\");\n                if (WindowsSdkDir && !FileName.exists(FileName.combine(WindowsSdkDir, \"Lib\")))\n                    WindowsSdkDir = null;\n            }\n            if (WindowsSdkDir is null)\n            {\n                WindowsSdkDir = GetRegistryString(r\"Microsoft\\Microsoft SDKs\\Windows\", \"CurrentInstallationFolder\");\n                if (WindowsSdkDir && !FileName.exists(FileName.combine(WindowsSdkDir, \"Lib\")))\n                    WindowsSdkDir = null;\n            }\n\n            if (WindowsSdkVersion is null)\n                WindowsSdkVersion = getenv(\"WindowsSdkVersion\");\n\n            if (WindowsSdkVersion is null && WindowsSdkDir !is null)\n            {\n                const(char)* rootsDir = FileName.combine(WindowsSdkDir, \"Include\");\n                WindowsSdkVersion = findLatestSDKDir(rootsDir, r\"um\\windows.h\");\n            }\n        }\n\n        /**\n         * detect UCRTSdkDir and UCRTVersion from environment or registry\n         */\n        void detectUCRT()\n        {\n            if (UCRTSdkDir is null)\n                UCRTSdkDir = getenv(\"UniversalCRTSdkDir\");\n\n            if (UCRTSdkDir is null)\n                UCRTSdkDir = GetRegistryString(r\"Microsoft\\Windows Kits\\Installed Roots\", \"KitsRoot10\");\n\n            if (UCRTVersion is null)\n                UCRTVersion = getenv(\"UCRTVersion\");\n\n            if (UCRTVersion is null && UCRTSdkDir !is null)\n            {\n                const(char)* rootsDir = FileName.combine(UCRTSdkDir, \"Lib\");\n                UCRTVersion = findLatestSDKDir(rootsDir, r\"ucrt\\x86\\libucrt.lib\");\n            }\n        }\n\n        /**\n         * detect VSInstallDir and VisualStudioVersion from environment or registry\n         */\n        void detectVSInstallDir()\n        {\n            if (VSInstallDir is null)\n                VSInstallDir = getenv(\"VSINSTALLDIR\");\n\n            if (VisualStudioVersion is null)\n                VisualStudioVersion = getenv(\"VisualStudioVersion\");\n\n            if (VSInstallDir is null)\n            {\n                // VS2017\n                VSInstallDir = GetRegistryString(r\"Microsoft\\VisualStudio\\SxS\\VS7\", \"15.0\");\n                if (VSInstallDir)\n                    VisualStudioVersion = \"15.0\";\n            }\n\n            if (VSInstallDir is null)\n                foreach (const(char)* ver; [\"14.0\".ptr, \"12.0\", \"11.0\", \"10.0\", \"9.0\"])\n                {\n                    VSInstallDir = GetRegistryString(FileName.combine(r\"Microsoft\\VisualStudio\", ver), \"InstallDir\");\n                    if (VSInstallDir)\n                    {\n                        VisualStudioVersion = ver;\n                        break;\n                    }\n                }\n        }\n\n        /**\n         * detect VCInstallDir from environment or registry\n         */\n        void detectVCInstallDir()\n        {\n            if (VCInstallDir is null)\n                VCInstallDir = getenv(\"VCINSTALLDIR\");\n\n            if (VCInstallDir is null)\n                if (VSInstallDir && FileName.exists(FileName.combine(VSInstallDir, \"VC\")))\n                    VCInstallDir = FileName.combine(VSInstallDir, \"VC\");\n\n            // detect from registry (build tools?)\n            if (VCInstallDir is null)\n                foreach (const(char)* ver; [\"14.0\".ptr, \"12.0\", \"11.0\", \"10.0\", \"9.0\"])\n                {\n                    auto regPath = FileName.buildPath(r\"Microsoft\\VisualStudio\", ver, r\"Setup\\VC\");\n                    VCInstallDir = GetRegistryString(regPath, \"ProductDir\");\n                    if (VCInstallDir)\n                        break;\n                }\n        }\n\n        /**\n         * detect VCToolsInstallDir from environment or registry (only used by VC 2017)\n         */\n        void detectVCToolsInstallDir()\n        {\n            if (VCToolsInstallDir is null)\n                VCToolsInstallDir = getenv(\"VCTOOLSINSTALLDIR\");\n\n            if (VCToolsInstallDir is null && VCInstallDir)\n            {\n                const(char)* defverFile = FileName.combine(VCInstallDir, r\"Auxiliary\\Build\\Microsoft.VCToolsVersion.default.txt\");\n                if (FileName.exists(defverFile))\n                {\n                    // VS 2017\n                    File f = File(defverFile);\n                    if (!f.read()) // returns true on error (!), adds sentinel 0 at end of file\n                    {\n                        auto ver = cast(char*)f.buffer;\n                        // trim version number\n                        while (*ver && isspace(*ver))\n                            ver++;\n                        auto p = ver;\n                        while (*p == '.' || (*p >= '0' && *p <= '9'))\n                            p++;\n                        *p = 0;\n\n                        if (ver && *ver)\n                            VCToolsInstallDir = FileName.buildPath(VCInstallDir, r\"Tools\\MSVC\", ver);\n                    }\n                }\n            }\n        }\n\n        /**\n         * get Visual C bin folder\n         * Params:\n         *   x64 = target architecture (x86 if false)\n         *   addpath = [out] path that needs to be added to the PATH environment variable\n         * Returns:\n         *   folder containing the VC executables\n         *\n         * Selects the binary path according to the host and target OS, but verifies\n         * that link.exe exists in that folder and falls back to 32-bit host/target if\n         * missing\n         * Note: differences for the linker binaries are small, they all\n         * allow cross compilation\n         */\n        const(char)* getVCBinDir(bool x64, out const(char)* addpath)\n        {\n            static const(char)* linkExists(const(char)* p)\n            {\n                auto lp = FileName.combine(p, \"link.exe\");\n                return FileName.exists(lp) ? p : null;\n            }\n\n            bool isHost64 = isWin64Host();\n            if (VCToolsInstallDir !is null)\n            {\n                if (isHost64)\n                {\n                    if (x64)\n                    {\n                        if (auto p = linkExists(FileName.combine(VCToolsInstallDir, r\"bin\\HostX64\\x64\")))\n                            return p;\n                        // in case of missing linker, prefer other host binaries over other target architecture\n                    }\n                    else\n                    {\n                        if (auto p = linkExists(FileName.combine(VCToolsInstallDir, r\"bin\\HostX64\\x86\")))\n                        {\n                            addpath = FileName.combine(VCToolsInstallDir, r\"bin\\HostX64\\x64\");\n                            return p;\n                        }\n                    }\n                }\n                if (x64)\n                {\n                    if (auto p = linkExists(FileName.combine(VCToolsInstallDir, r\"bin\\HostX86\\x64\")))\n                    {\n                        addpath = FileName.combine(VCToolsInstallDir, r\"bin\\HostX86\\x86\");\n                        return p;\n                    }\n                }\n                if (auto p = linkExists(FileName.combine(VCToolsInstallDir, r\"bin\\HostX86\\x86\")))\n                    return p;\n            }\n            if (VCInstallDir !is null)\n            {\n                if (isHost64)\n                {\n                    if (x64)\n                    {\n                        if (auto p = linkExists(FileName.combine(VCInstallDir, r\"bin\\amd64\")))\n                            return p;\n                        // in case of missing linker, prefer other host binaries over other target architecture\n                    }\n                    else\n                    {\n                        if (auto p = linkExists(FileName.combine(VCInstallDir, r\"bin\\amd64_x86\")))\n                        {\n                            addpath = FileName.combine(VCInstallDir, r\"bin\\amd64\");\n                            return p;\n                        }\n                    }\n                }\n\n                if (VSInstallDir)\n                    addpath = FileName.combine(VSInstallDir, r\"Common7\\IDE\");\n                else\n                    addpath = FileName.combine(VCInstallDir, r\"bin\");\n\n                if (x64)\n                    if (auto p = linkExists(FileName.combine(VCInstallDir, r\"x86_amd64\")))\n                        return p;\n\n                if (auto p = linkExists(FileName.combine(VCInstallDir, r\"bin\\HostX86\\x86\")))\n                    return p;\n            }\n            return null;\n        }\n\n        /**\n        * get Visual C Library folder\n        * Params:\n        *   x64 = target architecture (x86 if false)\n        * Returns:\n        *   folder containing the the VC runtime libraries\n        */\n        const(char)* getVCLibDir(bool x64)\n        {\n            if (VCToolsInstallDir !is null)\n                return FileName.combine(VCToolsInstallDir, x64 ? r\"lib\\x64\" : r\"lib\\x86\");\n            if (VCInstallDir !is null)\n                return FileName.combine(VCInstallDir, x64 ? r\"lib\\amd64\" : \"lib\");\n            return null;\n        }\n\n        /**\n         * get the path to the universal CRT libraries\n         * Params:\n         *   x64 = target architecture (x86 if false)\n         * Returns:\n         *   folder containing the universal CRT libraries\n         */\n        const(char)* getUCRTLibPath(bool x64)\n        {\n            if (UCRTSdkDir && UCRTVersion)\n               return FileName.buildPath(UCRTSdkDir, \"Lib\", UCRTVersion, x64 ? r\"ucrt\\x64\" : r\"ucrt\\x86\");\n            return null;\n        }\n\n        /**\n         * get the path to the Windows SDK CRT libraries\n         * Params:\n         *   x64 = target architecture (x86 if false)\n         * Returns:\n         *   folder containing the Windows SDK libraries\n         */\n        const(char)* getSDKLibPath(bool x64)\n        {\n            if (WindowsSdkDir)\n            {\n                const(char)* arch = x64 ? \"x64\" : \"x86\";\n                auto sdk = FileName.combine(WindowsSdkDir, \"lib\");\n                if (WindowsSdkVersion &&\n                    FileName.exists(FileName.buildPath(sdk, WindowsSdkVersion, \"um\", arch, \"kernel32.lib\"))) // SDK 10.0\n                    return FileName.buildPath(sdk, WindowsSdkVersion, \"um\", arch);\n                else if (FileName.exists(FileName.buildPath(sdk, r\"win8\\um\", arch, \"kernel32.lib\"))) // SDK 8.0\n                    return FileName.buildPath(sdk, r\"win8\\um\", arch);\n                else if (FileName.exists(FileName.buildPath(sdk, r\"winv6.3\\um\", arch, \"kernel32.lib\"))) // SDK 8.1\n                    return FileName.buildPath(sdk, r\"winv6.3\\um\", arch);\n                else if (x64 && FileName.exists(FileName.buildPath(sdk, arch, \"kernel32.lib\"))) // SDK 7.1 or earlier\n                    return FileName.buildPath(sdk, arch);\n                else if (!x64 && FileName.exists(FileName.buildPath(sdk, \"kernel32.lib\"))) // SDK 7.1 or earlier\n                    return sdk;\n            }\n\n            // try mingw fallback relative to phobos library folder that's part of LIB\n            Strings* libpaths = FileName.splitPath(getenv(\"LIB\"));\n            if (auto p = FileName.searchPath(libpaths, r\"mingw\\kernel32.lib\", false))\n                return FileName.path(p);\n\n            return null;\n        }\n\n        // iterate through subdirectories named by SDK version in baseDir and return the\n        //  one with the largest version that also contains the test file\n        static const(char)* findLatestSDKDir(const(char)* baseDir, const(char)* testfile)\n        {\n            auto allfiles = FileName.combine(baseDir, \"*\");\n            static if (!is(WIN32_FIND_DATAA)) alias WIN32_FIND_DATAA = WIN32_FIND_DATA; // support dmd 2.068\n            WIN32_FIND_DATAA fileinfo;\n            HANDLE h = FindFirstFileA(allfiles, &fileinfo);\n            if (h == INVALID_HANDLE_VALUE)\n                return null;\n\n            char* res = null;\n            do\n            {\n                if (fileinfo.cFileName[0] >= '1' && fileinfo.cFileName[0] <= '9')\n                    if (res is null || strcmp(res, fileinfo.cFileName.ptr) < 0)\n                        if (FileName.exists(FileName.buildPath(baseDir, fileinfo.cFileName.ptr, testfile)))\n                        {\n                            const len = strlen(fileinfo.cFileName.ptr) + 1;\n                            res = cast(char*) memcpy(mem.xrealloc(res, len), fileinfo.cFileName.ptr, len);\n                        }\n            }\n            while(FindNextFileA(h, &fileinfo));\n\n            if (!FindClose(h))\n                res = null;\n            return res;\n        }\n\n        pragma(lib, \"advapi32.lib\");\n\n        /**\n         * read a string from the 32-bit registry\n         * Params:\n         *  softwareKeyPath = path below HKLM\\SOFTWARE\n         *  valueName       = name of the value to read\n         * Returns:\n         *  the registry value if it exists and has string type\n         */\n        const(char)* GetRegistryString(const(char)* softwareKeyPath, const(char)* valueName)\n        {\n            enum x64hive = false; // VS registry entries always in 32-bit hive\n\n            version(Win64)\n                enum prefix = x64hive ? r\"SOFTWARE\\\" : r\"SOFTWARE\\WOW6432Node\\\";\n            else\n                enum prefix = r\"SOFTWARE\\\";\n\n            char[260] regPath = void;\n            const len = strlen(softwareKeyPath);\n            assert(len + prefix.length < regPath.length);\n\n            memcpy(regPath.ptr, prefix.ptr, prefix.length);\n            memcpy(regPath.ptr + prefix.length, softwareKeyPath, len + 1);\n\n            enum KEY_WOW64_64KEY = 0x000100; // not defined in core.sys.windows.winnt due to restrictive version\n            enum KEY_WOW64_32KEY = 0x000200;\n            HKEY key;\n            LONG lRes = RegOpenKeyExA(HKEY_LOCAL_MACHINE, regPath.ptr, (x64hive ? KEY_WOW64_64KEY : KEY_WOW64_32KEY), KEY_READ, &key);\n            if (FAILED(lRes))\n                return null;\n            scope(exit) RegCloseKey(key);\n\n            char[260] buf = void;\n            DWORD cnt = buf.length * char.sizeof;\n            DWORD type;\n            int hr = RegQueryValueExA(key, valueName, null, &type, cast(ubyte*) buf.ptr, &cnt);\n            if (hr == 0 && cnt > 0)\n                return buf.dup.ptr;\n            if (hr != ERROR_MORE_DATA || type != REG_SZ)\n                return null;\n\n            scope char[] pbuf = new char[cnt + 1];\n            RegQueryValueExA(key, valueName, null, &type, cast(ubyte*) pbuf.ptr, &cnt);\n            return pbuf.ptr;\n        }\n\n        /***\n         * get architecture of host OS\n         */\n        static bool isWin64Host()\n        {\n            version (Win64)\n            {\n                return true;\n            }\n            else\n            {\n                // running as a 32-bit process on a 64-bit host?\n                alias fnIsWow64Process = extern(Windows) BOOL function(HANDLE, PBOOL);\n                static fnIsWow64Process pIsWow64Process;\n\n                if (!pIsWow64Process)\n                {\n                    //IsWow64Process is not available on all supported versions of Windows.\n                    pIsWow64Process = cast(fnIsWow64Process) GetProcAddress(GetModuleHandleA(\"kernel32\"), \"IsWow64Process\");\n                    if (!pIsWow64Process)\n                        return false;\n                }\n                BOOL bIsWow64 = FALSE;\n                if (!pIsWow64Process(GetCurrentProcess(), &bIsWow64))\n                    return false;\n\n                return bIsWow64 != 0;\n            }\n        }\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmd-2.081.1-vqq6jjlqlkf6xkxhau7opmwbvotgmaut/spack-src/phobos/std/net/curl.d": "// Written in the D programming language.\n\n/**\nNetworking client functionality as provided by $(HTTP curl.haxx.se/libcurl,\nlibcurl). The libcurl library must be installed on the system in order to use\nthis module.\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions)\n)\n$(TR $(TDNW High level) $(TD $(MYREF download) $(MYREF upload) $(MYREF get)\n$(MYREF post) $(MYREF put) $(MYREF del) $(MYREF options) $(MYREF trace)\n$(MYREF connect) $(MYREF byLine) $(MYREF byChunk)\n$(MYREF byLineAsync) $(MYREF byChunkAsync) )\n)\n$(TR $(TDNW Low level) $(TD $(MYREF HTTP) $(MYREF FTP) $(MYREF\nSMTP) )\n)\n)\n)\n\nNote:\nYou may need to link to the $(B curl) library, e.g. by adding $(D \"libs\": [\"curl\"])\nto your $(B dub.json) file if you are using $(LINK2 http://code.dlang.org, DUB).\n\nWindows x86 note:\nA DMD compatible libcurl static library can be downloaded from the dlang.org\n$(LINK2 http://downloads.dlang.org/other/index.html, download archive page).\n\nCompared to using libcurl directly this module allows simpler client code for\ncommon uses, requires no unsafe operations, and integrates better with the rest\nof the language. Futhermore it provides $(MREF_ALTTEXT range, std,range)\naccess to protocols supported by libcurl both synchronously and asynchronously.\n\nA high level and a low level API are available. The high level API is built\nentirely on top of the low level one.\n\nThe high level API is for commonly used functionality such as HTTP/FTP get. The\n$(LREF byLineAsync) and $(LREF byChunkAsync) provides asynchronous\n$(MREF_ALTTEXT range, std,range) that performs the request in another\nthread while handling a line/chunk in the current thread.\n\nThe low level API allows for streaming and other advanced features.\n\n$(BOOKTABLE Cheat Sheet,\n$(TR $(TH Function Name) $(TH Description)\n)\n$(LEADINGROW High level)\n$(TR $(TDNW $(LREF download)) $(TD $(D\ndownload(\"ftp.digitalmars.com/sieve.ds\", \"/tmp/downloaded-ftp-file\"))\ndownloads file from URL to file system.)\n)\n$(TR $(TDNW $(LREF upload)) $(TD $(D\nupload(\"/tmp/downloaded-ftp-file\", \"ftp.digitalmars.com/sieve.ds\");)\nuploads file from file system to URL.)\n)\n$(TR $(TDNW $(LREF get)) $(TD $(D\nget(\"dlang.org\")) returns a char[] containing the dlang.org web page.)\n)\n$(TR $(TDNW $(LREF put)) $(TD $(D\nput(\"dlang.org\", \"Hi\")) returns a char[] containing\nthe dlang.org web page. after a HTTP PUT of \"hi\")\n)\n$(TR $(TDNW $(LREF post)) $(TD $(D\npost(\"dlang.org\", \"Hi\")) returns a char[] containing\nthe dlang.org web page. after a HTTP POST of \"hi\")\n)\n$(TR $(TDNW $(LREF byLine)) $(TD $(D\nbyLine(\"dlang.org\")) returns a range of char[] containing the\ndlang.org web page.)\n)\n$(TR $(TDNW $(LREF byChunk)) $(TD $(D\nbyChunk(\"dlang.org\", 10)) returns a range of ubyte[10] containing the\ndlang.org web page.)\n)\n$(TR $(TDNW $(LREF byLineAsync)) $(TD $(D\nbyLineAsync(\"dlang.org\")) returns a range of char[] containing the dlang.org web\n page asynchronously.)\n)\n$(TR $(TDNW $(LREF byChunkAsync)) $(TD $(D\nbyChunkAsync(\"dlang.org\", 10)) returns a range of ubyte[10] containing the\ndlang.org web page asynchronously.)\n)\n$(LEADINGROW Low level\n)\n$(TR $(TDNW $(LREF HTTP)) $(TD `HTTP` struct for advanced usage))\n$(TR $(TDNW $(LREF FTP)) $(TD `FTP` struct for advanced usage))\n$(TR $(TDNW $(LREF SMTP)) $(TD `SMTP` struct for advanced usage))\n)\n\n\nExample:\n---\nimport std.net.curl, std.stdio;\n\n// Return a char[] containing the content specified by a URL\nauto content = get(\"dlang.org\");\n\n// Post data and return a char[] containing the content specified by a URL\nauto content = post(\"mydomain.com/here.cgi\", [\"name1\" : \"value1\", \"name2\" : \"value2\"]);\n\n// Get content of file from ftp server\nauto content = get(\"ftp.digitalmars.com/sieve.ds\");\n\n// Post and print out content line by line. The request is done in another thread.\nforeach (line; byLineAsync(\"dlang.org\", \"Post data\"))\n    writeln(line);\n\n// Get using a line range and proxy settings\nauto client = HTTP();\nclient.proxy = \"1.2.3.4\";\nforeach (line; byLine(\"dlang.org\", client))\n    writeln(line);\n---\n\nFor more control than the high level functions provide, use the low level API:\n\nExample:\n---\nimport std.net.curl, std.stdio;\n\n// GET with custom data receivers\nauto http = HTTP(\"dlang.org\");\nhttp.onReceiveHeader =\n    (in char[] key, in char[] value) { writeln(key, \": \", value); };\nhttp.onReceive = (ubyte[] data) { /+ drop +/ return data.length; };\nhttp.perform();\n---\n\nFirst, an instance of the reference-counted HTTP struct is created. Then the\ncustom delegates are set. These will be called whenever the HTTP instance\nreceives a header and a data buffer, respectively. In this simple example, the\nheaders are written to stdout and the data is ignored. If the request should be\nstopped before it has finished then return something less than data.length from\nthe onReceive callback. See $(LREF onReceiveHeader)/$(LREF onReceive) for more\ninformation. Finally the HTTP request is effected by calling perform(), which is\nsynchronous.\n\nSource: $(PHOBOSSRC std/net/curl.d)\n\nCopyright: Copyright Jonas Drewsen 2011-2012\nLicense: $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors: Jonas Drewsen. Some of the SMTP code contributed by Jimmy Cao.\n\nCredits: The functionally is based on $(HTTP curl.haxx.se/libcurl, libcurl).\n         LibCurl is licensed under an MIT/X derivative license.\n*/\n/*\n         Copyright Jonas Drewsen 2011 - 2012.\nDistributed under the Boost Software License, Version 1.0.\n   (See accompanying file LICENSE_1_0.txt or copy at\n         http://www.boost.org/LICENSE_1_0.txt)\n*/\nmodule std.net.curl;\n\npublic import etc.c.curl : CurlOption;\nimport core.time : dur;\nimport etc.c.curl : CURLcode;\nimport std.range.primitives;\nimport std.encoding : EncodingScheme;\nimport std.traits : isSomeChar;\nimport std.typecons : Flag, Yes, No, Tuple;\n\n// Curl tests for FreeBSD 32-bit are temporarily disabled.\n// https://github.com/braddr/d-tester/issues/70\n// https://issues.dlang.org/show_bug.cgi?id=18519\nversion(unittest)\nversion(FreeBSD)\nversion(X86)\n    version = DisableCurlTests;\n\nversion(DisableCurlTests) {} else:\n\nversion(unittest)\n{\n    import std.socket : Socket;\n\n    private struct TestServer\n    {\n        import std.concurrency : Tid;\n\n        import std.socket : Socket, TcpSocket;\n\n        string addr() { return _addr; }\n\n        void handle(void function(Socket s) dg)\n        {\n            import std.concurrency : send;\n            tid.send(dg);\n        }\n\n    private:\n        string _addr;\n        Tid tid;\n        TcpSocket sock;\n\n        static void loop(shared TcpSocket listener)\n        {\n            import std.concurrency : OwnerTerminated, receiveOnly;\n            import std.stdio : stderr;\n\n            try while (true)\n            {\n                void function(Socket) handler = void;\n                try\n                    handler = receiveOnly!(typeof(handler));\n                catch (OwnerTerminated)\n                    return;\n                handler((cast() listener).accept);\n            }\n            catch (Throwable e)\n            {\n                import core.stdc.stdlib : exit, EXIT_FAILURE;\n                stderr.writeln(e);\n                exit(EXIT_FAILURE); // Bugzilla 7018\n            }\n        }\n    }\n\n    private TestServer startServer()\n    {\n        import std.concurrency : spawn;\n        import std.socket : INADDR_LOOPBACK, InternetAddress, TcpSocket;\n\n        tlsInit = true;\n        auto sock = new TcpSocket;\n        sock.bind(new InternetAddress(INADDR_LOOPBACK, InternetAddress.PORT_ANY));\n        sock.listen(1);\n        auto addr = sock.localAddress.toString();\n        auto tid = spawn(&TestServer.loop, cast(shared) sock);\n        return TestServer(addr, tid, sock);\n    }\n\n    __gshared TestServer server;\n    bool tlsInit;\n\n    private ref TestServer testServer()\n    {\n        import std.concurrency : initOnce;\n        return initOnce!server(startServer());\n    }\n\n    static ~this()\n    {\n        // terminate server from a thread local dtor of the thread that started it,\n        //  because thread_joinall is called before shared module dtors\n        if (tlsInit && server.sock)\n            server.sock.close();\n    }\n\n    private struct Request(T)\n    {\n        string hdrs;\n        immutable(T)[] bdy;\n    }\n\n    private Request!T recvReq(T=char)(Socket s)\n    {\n        import std.algorithm.comparison : min;\n        import std.algorithm.searching : find, canFind;\n        import std.conv : to;\n        import std.regex : ctRegex, matchFirst;\n\n        ubyte[1024] tmp=void;\n        ubyte[] buf;\n\n        while (true)\n        {\n            auto nbytes = s.receive(tmp[]);\n            assert(nbytes >= 0);\n\n            immutable beg = buf.length > 3 ? buf.length - 3 : 0;\n            buf ~= tmp[0 .. nbytes];\n            auto bdy = buf[beg .. $].find(cast(ubyte[])\"\\r\\n\\r\\n\");\n            if (bdy.empty)\n                continue;\n\n            auto hdrs = cast(string) buf[0 .. $ - bdy.length];\n            bdy.popFrontN(4);\n            // no support for chunked transfer-encoding\n            if (auto m = hdrs.matchFirst(ctRegex!(`Content-Length: ([0-9]+)`, \"i\")))\n            {\n                import std.uni : asUpperCase;\n                if (hdrs.asUpperCase.canFind(\"EXPECT: 100-CONTINUE\"))\n                    s.send(httpContinue);\n\n                size_t remain = m.captures[1].to!size_t - bdy.length;\n                while (remain)\n                {\n                    nbytes = s.receive(tmp[0 .. min(remain, $)]);\n                    assert(nbytes >= 0);\n                    buf ~= tmp[0 .. nbytes];\n                    remain -= nbytes;\n                }\n            }\n            else\n            {\n                assert(bdy.empty);\n            }\n            bdy = buf[hdrs.length + 4 .. $];\n            return typeof(return)(hdrs, cast(immutable(T)[])bdy);\n        }\n    }\n\n    private string httpOK(string msg)\n    {\n        import std.conv : to;\n\n        return \"HTTP/1.1 200 OK\\r\\n\"~\n            \"Content-Type: text/plain\\r\\n\"~\n            \"Content-Length: \"~msg.length.to!string~\"\\r\\n\"~\n            \"\\r\\n\"~\n            msg;\n    }\n\n    private string httpOK()\n    {\n        return \"HTTP/1.1 200 OK\\r\\n\"~\n            \"Content-Length: 0\\r\\n\"~\n            \"\\r\\n\";\n    }\n\n    private string httpNotFound()\n    {\n        return \"HTTP/1.1 404 Not Found\\r\\n\"~\n            \"Content-Length: 0\\r\\n\"~\n            \"\\r\\n\";\n    }\n\n    private enum httpContinue = \"HTTP/1.1 100 Continue\\r\\n\\r\\n\";\n}\nversion(StdDdoc) import std.stdio;\n\n// Default data timeout for Protocols\nprivate enum _defaultDataTimeout = dur!\"minutes\"(2);\n\n/**\nMacros:\n\nCALLBACK_PARAMS = $(TABLE ,\n    $(DDOC_PARAM_ROW\n        $(DDOC_PARAM_ID $(DDOC_PARAM dlTotal))\n        $(DDOC_PARAM_DESC total bytes to download)\n        )\n    $(DDOC_PARAM_ROW\n        $(DDOC_PARAM_ID $(DDOC_PARAM dlNow))\n        $(DDOC_PARAM_DESC currently downloaded bytes)\n        )\n    $(DDOC_PARAM_ROW\n        $(DDOC_PARAM_ID $(DDOC_PARAM ulTotal))\n        $(DDOC_PARAM_DESC total bytes to upload)\n        )\n    $(DDOC_PARAM_ROW\n        $(DDOC_PARAM_ID $(DDOC_PARAM ulNow))\n        $(DDOC_PARAM_DESC currently uploaded bytes)\n        )\n)\n*/\n\n/** Connection type used when the URL should be used to auto detect the protocol.\n  *\n  * This struct is used as placeholder for the connection parameter when calling\n  * the high level API and the connection type (HTTP/FTP) should be guessed by\n  * inspecting the URL parameter.\n  *\n  * The rules for guessing the protocol are:\n  * 1, if URL starts with ftp://, ftps:// or ftp. then FTP connection is assumed.\n  * 2, HTTP connection otherwise.\n  *\n  * Example:\n  * ---\n  * import std.net.curl;\n  * // Two requests below will do the same.\n  * char[] content;\n  *\n  * // Explicit connection provided\n  * content = get!HTTP(\"dlang.org\");\n  *\n  * // Guess connection type by looking at the URL\n  * content = get!AutoProtocol(\"ftp://foo.com/file\");\n  * // and since AutoProtocol is default this is the same as\n  * content = get(\"ftp://foo.com/file\");\n  * // and will end up detecting FTP from the url and be the same as\n  * content = get!FTP(\"ftp://foo.com/file\");\n  * ---\n  */\nstruct AutoProtocol { }\n\n// Returns true if the url points to an FTP resource\nprivate bool isFTPUrl(const(char)[] url)\n{\n    import std.algorithm.searching : startsWith;\n    import std.uni : toLower;\n\n    return startsWith(url.toLower(), \"ftp://\", \"ftps://\", \"ftp.\") != 0;\n}\n\n// Is true if the Conn type is a valid Curl Connection type.\nprivate template isCurlConn(Conn)\n{\n    enum auto isCurlConn = is(Conn : HTTP) ||\n        is(Conn : FTP) || is(Conn : AutoProtocol);\n}\n\n/** HTTP/FTP download to local file system.\n *\n * Params:\n * url = resource to download\n * saveToPath = path to store the downloaded content on local disk\n * conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n *        guess connection type and create a new instance for this call only.\n *\n * Example:\n * ----\n * import std.net.curl;\n * download(\"https://httpbin.org/get\", \"/tmp/downloaded-http-file\");\n * ----\n */\nvoid download(Conn = AutoProtocol)(const(char)[] url, string saveToPath, Conn conn = Conn())\nif (isCurlConn!Conn)\n{\n    static if (is(Conn : HTTP) || is(Conn : FTP))\n    {\n        import std.stdio : File;\n        conn.url = url;\n        auto f = File(saveToPath, \"wb\");\n        conn.onReceive = (ubyte[] data) { f.rawWrite(data); return data.length; };\n        conn.perform();\n    }\n    else\n    {\n        if (isFTPUrl(url))\n            return download!FTP(url, saveToPath, FTP());\n        else\n            return download!HTTP(url, saveToPath, HTTP());\n    }\n}\n\n@system unittest\n{\n    import std.algorithm.searching : canFind;\n    static import std.file;\n\n    foreach (host; [testServer.addr, \"http://\"~testServer.addr])\n    {\n        testServer.handle((s) {\n            assert(s.recvReq.hdrs.canFind(\"GET /\"));\n            s.send(httpOK(\"Hello world\"));\n        });\n        auto fn = std.file.deleteme;\n        scope (exit) std.file.remove(fn);\n        download(host, fn);\n        assert(std.file.readText(fn) == \"Hello world\");\n    }\n}\n\n/** Upload file from local files system using the HTTP or FTP protocol.\n *\n * Params:\n * loadFromPath = path load data from local disk.\n * url = resource to upload to\n * conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n *        guess connection type and create a new instance for this call only.\n *\n * Example:\n * ----\n * import std.net.curl;\n * upload(\"/tmp/downloaded-ftp-file\", \"ftp.digitalmars.com/sieve.ds\");\n * upload(\"/tmp/downloaded-http-file\", \"https://httpbin.org/post\");\n * ----\n */\nvoid upload(Conn = AutoProtocol)(string loadFromPath, const(char)[] url, Conn conn = Conn())\nif (isCurlConn!Conn)\n{\n    static if (is(Conn : HTTP))\n    {\n        conn.url = url;\n        conn.method = HTTP.Method.put;\n    }\n    else static if (is(Conn : FTP))\n    {\n        conn.url = url;\n        conn.handle.set(CurlOption.upload, 1L);\n    }\n    else\n    {\n        if (isFTPUrl(url))\n            return upload!FTP(loadFromPath, url, FTP());\n        else\n            return upload!HTTP(loadFromPath, url, HTTP());\n    }\n\n    static if (is(Conn : HTTP) || is(Conn : FTP))\n    {\n        import std.stdio : File;\n        auto f = File(loadFromPath, \"rb\");\n        conn.onSend = buf => f.rawRead(buf).length;\n        immutable sz = f.size;\n        if (sz != ulong.max)\n            conn.contentLength = sz;\n        conn.perform();\n    }\n}\n\n@system unittest\n{\n    import std.algorithm.searching : canFind;\n    static import std.file;\n\n    foreach (host; [testServer.addr, \"http://\"~testServer.addr])\n    {\n        auto fn = std.file.deleteme;\n        scope (exit) std.file.remove(fn);\n        std.file.write(fn, \"upload data\\n\");\n        testServer.handle((s) {\n            auto req = s.recvReq;\n            assert(req.hdrs.canFind(\"PUT /path\"));\n            assert(req.bdy.canFind(\"upload data\"));\n            s.send(httpOK());\n        });\n        upload(fn, host ~ \"/path\");\n    }\n}\n\n/** HTTP/FTP get content.\n *\n * Params:\n * url = resource to get\n * conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n *        guess connection type and create a new instance for this call only.\n *\n * The template parameter `T` specifies the type to return. Possible values\n * are `char` and `ubyte` to return `char[]` or `ubyte[]`. If asking\n * for `char`, content will be converted from the connection character set\n * (specified in HTTP response headers or FTP connection properties, both ISO-8859-1\n * by default) to UTF-8.\n *\n * Example:\n * ----\n * import std.net.curl;\n * auto content = get(\"https://httpbin.org/get\");\n * ----\n *\n * Returns:\n * A T[] range containing the content of the resource pointed to by the URL.\n *\n * Throws:\n *\n * `CurlException` on error.\n *\n * See_Also: $(LREF HTTP.Method)\n */\nT[] get(Conn = AutoProtocol, T = char)(const(char)[] url, Conn conn = Conn())\nif ( isCurlConn!Conn && (is(T == char) || is(T == ubyte)) )\n{\n    static if (is(Conn : HTTP))\n    {\n        conn.method = HTTP.Method.get;\n        return _basicHTTP!(T)(url, \"\", conn);\n\n    }\n    else static if (is(Conn : FTP))\n    {\n        return _basicFTP!(T)(url, \"\", conn);\n    }\n    else\n    {\n        if (isFTPUrl(url))\n            return get!(FTP,T)(url, FTP());\n        else\n            return get!(HTTP,T)(url, HTTP());\n    }\n}\n\n@system unittest\n{\n    import std.algorithm.searching : canFind;\n\n    foreach (host; [testServer.addr, \"http://\"~testServer.addr])\n    {\n        testServer.handle((s) {\n            assert(s.recvReq.hdrs.canFind(\"GET /path\"));\n            s.send(httpOK(\"GETRESPONSE\"));\n        });\n        auto res = get(host ~ \"/path\");\n        assert(res == \"GETRESPONSE\");\n    }\n}\n\n\n/** HTTP post content.\n *\n * Params:\n *     url = resource to post to\n *     postDict = data to send as the body of the request. An associative array\n *                of `string` is accepted and will be encoded using\n *                www-form-urlencoding\n *     postData = data to send as the body of the request. An array\n *                of an arbitrary type is accepted and will be cast to ubyte[]\n *                before sending it.\n *     conn = HTTP connection to use\n *     T    = The template parameter `T` specifies the type to return. Possible values\n *            are `char` and `ubyte` to return `char[]` or `ubyte[]`. If asking\n *            for `char`, content will be converted from the connection character set\n *            (specified in HTTP response headers or FTP connection properties, both ISO-8859-1\n *            by default) to UTF-8.\n *\n * Examples:\n * ----\n * import std.net.curl;\n *\n * auto content1 = post(\"https://httpbin.org/post\", [\"name1\" : \"value1\", \"name2\" : \"value2\"]);\n * auto content2 = post(\"https://httpbin.org/post\", [1,2,3,4]);\n * ----\n *\n * Returns:\n * A T[] range containing the content of the resource pointed to by the URL.\n *\n * See_Also: $(LREF HTTP.Method)\n */\nT[] post(T = char, PostUnit)(const(char)[] url, const(PostUnit)[] postData, HTTP conn = HTTP())\nif (is(T == char) || is(T == ubyte))\n{\n    conn.method = HTTP.Method.post;\n    return _basicHTTP!(T)(url, postData, conn);\n}\n\n@system unittest\n{\n    import std.algorithm.searching : canFind;\n\n    foreach (host; [testServer.addr, \"http://\"~testServer.addr])\n    {\n        testServer.handle((s) {\n            auto req = s.recvReq;\n            assert(req.hdrs.canFind(\"POST /path\"));\n            assert(req.bdy.canFind(\"POSTBODY\"));\n            s.send(httpOK(\"POSTRESPONSE\"));\n        });\n        auto res = post(host ~ \"/path\", \"POSTBODY\");\n        assert(res == \"POSTRESPONSE\");\n    }\n}\n\n@system unittest\n{\n    import std.algorithm.searching : canFind;\n\n    auto data = new ubyte[](256);\n    foreach (i, ref ub; data)\n        ub = cast(ubyte) i;\n\n    testServer.handle((s) {\n        auto req = s.recvReq!ubyte;\n        assert(req.bdy.canFind(cast(ubyte[])[0, 1, 2, 3, 4]));\n        assert(req.bdy.canFind(cast(ubyte[])[253, 254, 255]));\n        s.send(httpOK(cast(ubyte[])[17, 27, 35, 41]));\n    });\n    auto res = post!ubyte(testServer.addr, data);\n    assert(res == cast(ubyte[])[17, 27, 35, 41]);\n}\n\n/// ditto\nT[] post(T = char)(const(char)[] url, string[string] postDict, HTTP conn = HTTP())\nif (is(T == char) || is(T == ubyte))\n{\n    import std.uri : urlEncode;\n\n    return post(url, urlEncode(postDict), conn);\n}\n\n@system unittest\n{\n    foreach (host; [testServer.addr, \"http://\" ~ testServer.addr])\n    {\n        testServer.handle((s) {\n            auto req = s.recvReq!char;\n            s.send(httpOK(req.bdy));\n        });\n        auto res = post(host ~ \"/path\", [\"name1\" : \"value1\", \"name2\" : \"value2\"]);\n        assert(res == \"name1=value1&name2=value2\");\n    }\n}\n\n/** HTTP/FTP put content.\n *\n * Params:\n * url = resource to put\n * putData = data to send as the body of the request. An array\n *           of an arbitrary type is accepted and will be cast to ubyte[]\n *           before sending it.\n * conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n *        guess connection type and create a new instance for this call only.\n *\n * The template parameter `T` specifies the type to return. Possible values\n * are `char` and `ubyte` to return `char[]` or `ubyte[]`. If asking\n * for `char`, content will be converted from the connection character set\n * (specified in HTTP response headers or FTP connection properties, both ISO-8859-1\n * by default) to UTF-8.\n *\n * Example:\n * ----\n * import std.net.curl;\n * auto content = put(\"https://httpbin.org/put\",\n *                      \"Putting this data\");\n * ----\n *\n * Returns:\n * A T[] range containing the content of the resource pointed to by the URL.\n *\n * See_Also: $(LREF HTTP.Method)\n */\nT[] put(Conn = AutoProtocol, T = char, PutUnit)(const(char)[] url, const(PutUnit)[] putData,\n                                                  Conn conn = Conn())\nif ( isCurlConn!Conn && (is(T == char) || is(T == ubyte)) )\n{\n    static if (is(Conn : HTTP))\n    {\n        conn.method = HTTP.Method.put;\n        return _basicHTTP!(T)(url, putData, conn);\n    }\n    else static if (is(Conn : FTP))\n    {\n        return _basicFTP!(T)(url, putData, conn);\n    }\n    else\n    {\n        if (isFTPUrl(url))\n            return put!(FTP,T)(url, putData, FTP());\n        else\n            return put!(HTTP,T)(url, putData, HTTP());\n    }\n}\n\n@system unittest\n{\n    import std.algorithm.searching : canFind;\n\n    foreach (host; [testServer.addr, \"http://\"~testServer.addr])\n    {\n        testServer.handle((s) {\n            auto req = s.recvReq;\n            assert(req.hdrs.canFind(\"PUT /path\"));\n            assert(req.bdy.canFind(\"PUTBODY\"));\n            s.send(httpOK(\"PUTRESPONSE\"));\n        });\n        auto res = put(host ~ \"/path\", \"PUTBODY\");\n        assert(res == \"PUTRESPONSE\");\n    }\n}\n\n\n/** HTTP/FTP delete content.\n *\n * Params:\n * url = resource to delete\n * conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n *        guess connection type and create a new instance for this call only.\n *\n * Example:\n * ----\n * import std.net.curl;\n * del(\"https://httpbin.org/delete\");\n * ----\n *\n * See_Also: $(LREF HTTP.Method)\n */\nvoid del(Conn = AutoProtocol)(const(char)[] url, Conn conn = Conn())\nif (isCurlConn!Conn)\n{\n    static if (is(Conn : HTTP))\n    {\n        conn.method = HTTP.Method.del;\n        _basicHTTP!char(url, cast(void[]) null, conn);\n    }\n    else static if (is(Conn : FTP))\n    {\n        import std.algorithm.searching : findSplitAfter;\n        import std.conv : text;\n        import std.exception : enforce;\n\n        auto trimmed = url.findSplitAfter(\"ftp://\")[1];\n        auto t = trimmed.findSplitAfter(\"/\");\n        enum minDomainNameLength = 3;\n        enforce!CurlException(t[0].length > minDomainNameLength,\n                                text(\"Invalid FTP URL for delete \", url));\n        conn.url = t[0];\n\n        enforce!CurlException(!t[1].empty,\n                                text(\"No filename specified to delete for URL \", url));\n        conn.addCommand(\"DELE \" ~ t[1]);\n        conn.perform();\n    }\n    else\n    {\n        if (isFTPUrl(url))\n            return del!FTP(url, FTP());\n        else\n            return del!HTTP(url, HTTP());\n    }\n}\n\n@system unittest\n{\n    import std.algorithm.searching : canFind;\n\n    foreach (host; [testServer.addr, \"http://\"~testServer.addr])\n    {\n        testServer.handle((s) {\n            auto req = s.recvReq;\n            assert(req.hdrs.canFind(\"DELETE /path\"));\n            s.send(httpOK());\n        });\n        del(host ~ \"/path\");\n    }\n}\n\n\n/** HTTP options request.\n *\n * Params:\n * url = resource make a option call to\n * conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n *        guess connection type and create a new instance for this call only.\n *\n * The template parameter `T` specifies the type to return. Possible values\n * are `char` and `ubyte` to return `char[]` or `ubyte[]`.\n *\n * Example:\n * ----\n * import std.net.curl;\n * auto http = HTTP();\n * options(\"https://httpbin.org/headers\", http);\n * writeln(\"Allow set to \" ~ http.responseHeaders[\"Allow\"]);\n * ----\n *\n * Returns:\n * A T[] range containing the options of the resource pointed to by the URL.\n *\n * See_Also: $(LREF HTTP.Method)\n */\nT[] options(T = char)(const(char)[] url, HTTP conn = HTTP())\nif (is(T == char) || is(T == ubyte))\n{\n    conn.method = HTTP.Method.options;\n    return _basicHTTP!(T)(url, null, conn);\n}\n\n@system unittest\n{\n    import std.algorithm.searching : canFind;\n\n    testServer.handle((s) {\n        auto req = s.recvReq;\n        assert(req.hdrs.canFind(\"OPTIONS /path\"));\n        s.send(httpOK(\"OPTIONSRESPONSE\"));\n    });\n    auto res = options(testServer.addr ~ \"/path\");\n    assert(res == \"OPTIONSRESPONSE\");\n}\n\n\n/** HTTP trace request.\n *\n * Params:\n * url = resource make a trace call to\n * conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n *        guess connection type and create a new instance for this call only.\n *\n * The template parameter `T` specifies the type to return. Possible values\n * are `char` and `ubyte` to return `char[]` or `ubyte[]`.\n *\n * Example:\n * ----\n * import std.net.curl;\n * trace(\"https://httpbin.org/headers\");\n * ----\n *\n * Returns:\n * A T[] range containing the trace info of the resource pointed to by the URL.\n *\n * See_Also: $(LREF HTTP.Method)\n */\nT[] trace(T = char)(const(char)[] url, HTTP conn = HTTP())\nif (is(T == char) || is(T == ubyte))\n{\n    conn.method = HTTP.Method.trace;\n    return _basicHTTP!(T)(url, cast(void[]) null, conn);\n}\n\n@system unittest\n{\n    import std.algorithm.searching : canFind;\n\n    testServer.handle((s) {\n        auto req = s.recvReq;\n        assert(req.hdrs.canFind(\"TRACE /path\"));\n        s.send(httpOK(\"TRACERESPONSE\"));\n    });\n    auto res = trace(testServer.addr ~ \"/path\");\n    assert(res == \"TRACERESPONSE\");\n}\n\n\n/** HTTP connect request.\n *\n * Params:\n * url = resource make a connect to\n * conn = HTTP connection to use\n *\n * The template parameter `T` specifies the type to return. Possible values\n * are `char` and `ubyte` to return `char[]` or `ubyte[]`.\n *\n * Example:\n * ----\n * import std.net.curl;\n * connect(\"https://httpbin.org/headers\");\n * ----\n *\n * Returns:\n * A T[] range containing the connect info of the resource pointed to by the URL.\n *\n * See_Also: $(LREF HTTP.Method)\n */\nT[] connect(T = char)(const(char)[] url, HTTP conn = HTTP())\nif (is(T == char) || is(T == ubyte))\n{\n    conn.method = HTTP.Method.connect;\n    return _basicHTTP!(T)(url, cast(void[]) null, conn);\n}\n\n@system unittest\n{\n    import std.algorithm.searching : canFind;\n\n    testServer.handle((s) {\n        auto req = s.recvReq;\n        assert(req.hdrs.canFind(\"CONNECT /path\"));\n        s.send(httpOK(\"CONNECTRESPONSE\"));\n    });\n    auto res = connect(testServer.addr ~ \"/path\");\n    assert(res == \"CONNECTRESPONSE\");\n}\n\n\n/** HTTP patch content.\n *\n * Params:\n * url = resource to patch\n * patchData = data to send as the body of the request. An array\n *           of an arbitrary type is accepted and will be cast to ubyte[]\n *           before sending it.\n * conn = HTTP connection to use\n *\n * The template parameter `T` specifies the type to return. Possible values\n * are `char` and `ubyte` to return `char[]` or `ubyte[]`.\n *\n * Example:\n * ----\n * auto http = HTTP();\n * http.addRequestHeader(\"Content-Type\", \"application/json\");\n * auto content = patch(\"https://httpbin.org/patch\", `{\"title\": \"Patched Title\"}`, http);\n * ----\n *\n * Returns:\n * A T[] range containing the content of the resource pointed to by the URL.\n *\n * See_Also: $(LREF HTTP.Method)\n */\nT[] patch(T = char, PatchUnit)(const(char)[] url, const(PatchUnit)[] patchData,\n                               HTTP conn = HTTP())\nif (is(T == char) || is(T == ubyte))\n{\n    conn.method = HTTP.Method.patch;\n    return _basicHTTP!(T)(url, patchData, conn);\n}\n\n@system unittest\n{\n    import std.algorithm.searching : canFind;\n\n    testServer.handle((s) {\n        auto req = s.recvReq;\n        assert(req.hdrs.canFind(\"PATCH /path\"));\n        assert(req.bdy.canFind(\"PATCHBODY\"));\n        s.send(httpOK(\"PATCHRESPONSE\"));\n    });\n    auto res = patch(testServer.addr ~ \"/path\", \"PATCHBODY\");\n    assert(res == \"PATCHRESPONSE\");\n}\n\n\n/*\n * Helper function for the high level interface.\n *\n * It performs an HTTP request using the client which must have\n * been setup correctly before calling this function.\n */\nprivate auto _basicHTTP(T)(const(char)[] url, const(void)[] sendData, HTTP client)\n{\n    import std.algorithm.comparison : min;\n    import std.format : format;\n    import std.exception : enforce;\n    import etc.c.curl : CurlSeek, CurlSeekPos;\n\n    immutable doSend = sendData !is null &&\n        (client.method == HTTP.Method.post ||\n         client.method == HTTP.Method.put ||\n         client.method == HTTP.Method.patch);\n\n    scope (exit)\n    {\n        client.onReceiveHeader = null;\n        client.onReceiveStatusLine = null;\n        client.onReceive = null;\n\n        if (doSend)\n        {\n            client.onSend = null;\n            client.handle.onSeek = null;\n            client.contentLength = 0;\n        }\n    }\n    client.url = url;\n    HTTP.StatusLine statusLine;\n    import std.array : appender;\n    auto content = appender!(ubyte[])();\n    client.onReceive = (ubyte[] data)\n    {\n        content ~= data;\n        return data.length;\n    };\n\n    if (doSend)\n    {\n        client.contentLength = sendData.length;\n        auto remainingData = sendData;\n        client.onSend = delegate size_t(void[] buf)\n        {\n            size_t minLen = min(buf.length, remainingData.length);\n            if (minLen == 0) return 0;\n            buf[0 .. minLen] = remainingData[0 .. minLen];\n            remainingData = remainingData[minLen..$];\n            return minLen;\n        };\n        client.handle.onSeek = delegate(long offset, CurlSeekPos mode)\n        {\n            switch (mode)\n            {\n                case CurlSeekPos.set:\n                    remainingData = sendData[cast(size_t) offset..$];\n                    return CurlSeek.ok;\n                default:\n                    // As of curl 7.18.0, libcurl will not pass\n                    // anything other than CurlSeekPos.set.\n                    return CurlSeek.cantseek;\n            }\n        };\n    }\n\n    client.onReceiveHeader = (in char[] key,\n                              in char[] value)\n    {\n        if (key == \"content-length\")\n        {\n            import std.conv : to;\n            content.reserve(value.to!size_t);\n        }\n    };\n    client.onReceiveStatusLine = (HTTP.StatusLine l) { statusLine = l; };\n    client.perform();\n    enforce(statusLine.code / 100 == 2, new HTTPStatusException(statusLine.code,\n            format(\"HTTP request returned status code %d (%s)\", statusLine.code, statusLine.reason)));\n\n    return _decodeContent!T(content.data, client.p.charset);\n}\n\n@system unittest\n{\n    import std.algorithm.searching : canFind;\n    import std.exception : collectException;\n\n    testServer.handle((s) {\n        auto req = s.recvReq;\n        assert(req.hdrs.canFind(\"GET /path\"));\n        s.send(httpNotFound());\n    });\n    auto e = collectException!HTTPStatusException(get(testServer.addr ~ \"/path\"));\n    assert(e.msg == \"HTTP request returned status code 404 (Not Found)\");\n    assert(e.status == 404);\n}\n\n// Bugzilla 14760 - content length must be reset after post\n@system unittest\n{\n    import std.algorithm.searching : canFind;\n\n    testServer.handle((s) {\n        auto req = s.recvReq;\n        assert(req.hdrs.canFind(\"POST /\"));\n        assert(req.bdy.canFind(\"POSTBODY\"));\n        s.send(httpOK(\"POSTRESPONSE\"));\n\n        req = s.recvReq;\n        assert(req.hdrs.canFind(\"TRACE /\"));\n        assert(req.bdy.empty);\n        s.blocking = false;\n        ubyte[6] buf = void;\n        assert(s.receive(buf[]) < 0);\n        s.send(httpOK(\"TRACERESPONSE\"));\n    });\n    auto http = HTTP();\n    auto res = post(testServer.addr, \"POSTBODY\", http);\n    assert(res == \"POSTRESPONSE\");\n    res = trace(testServer.addr, http);\n    assert(res == \"TRACERESPONSE\");\n}\n\n@system unittest // charset detection and transcoding to T\n{\n    testServer.handle((s) {\n        s.send(\"HTTP/1.1 200 OK\\r\\n\"~\n        \"Content-Length: 4\\r\\n\"~\n        \"Content-Type: text/plain; charset=utf-8\\r\\n\" ~\n        \"\\r\\n\" ~\n        \"\u00e4bc\");\n    });\n    auto client = HTTP();\n    auto result = _basicHTTP!char(testServer.addr, \"\", client);\n    assert(result == \"\u00e4bc\");\n\n    testServer.handle((s) {\n        s.send(\"HTTP/1.1 200 OK\\r\\n\"~\n        \"Content-Length: 3\\r\\n\"~\n        \"Content-Type: text/plain; charset=iso-8859-1\\r\\n\" ~\n        \"\\r\\n\" ~\n        0xE4 ~ \"bc\");\n    });\n    client = HTTP();\n    result = _basicHTTP!char(testServer.addr, \"\", client);\n    assert(result == \"\u00e4bc\");\n}\n\n/*\n * Helper function for the high level interface.\n *\n * It performs an FTP request using the client which must have\n * been setup correctly before calling this function.\n */\nprivate auto _basicFTP(T)(const(char)[] url, const(void)[] sendData, FTP client)\n{\n    import std.algorithm.comparison : min;\n\n    scope (exit)\n    {\n        client.onReceive = null;\n        if (!sendData.empty)\n            client.onSend = null;\n    }\n\n    ubyte[] content;\n\n    if (client.encoding.empty)\n        client.encoding = \"ISO-8859-1\";\n\n    client.url = url;\n    client.onReceive = (ubyte[] data)\n    {\n        content ~= data;\n        return data.length;\n    };\n\n    if (!sendData.empty)\n    {\n        client.handle.set(CurlOption.upload, 1L);\n        client.onSend = delegate size_t(void[] buf)\n        {\n            size_t minLen = min(buf.length, sendData.length);\n            if (minLen == 0) return 0;\n            buf[0 .. minLen] = sendData[0 .. minLen];\n            sendData = sendData[minLen..$];\n            return minLen;\n        };\n    }\n\n    client.perform();\n\n    return _decodeContent!T(content, client.encoding);\n}\n\n/* Used by _basicHTTP() and _basicFTP() to decode ubyte[] to\n * correct string format\n */\nprivate auto _decodeContent(T)(ubyte[] content, string encoding)\n{\n    static if (is(T == ubyte))\n    {\n        return content;\n    }\n    else\n    {\n        import std.exception : enforce;\n        import std.format : format;\n\n        // Optimally just return the utf8 encoded content\n        if (encoding == \"UTF-8\")\n            return cast(char[])(content);\n\n        // The content has to be re-encoded to utf8\n        auto scheme = EncodingScheme.create(encoding);\n        enforce!CurlException(scheme !is null,\n                                format(\"Unknown encoding '%s'\", encoding));\n\n        auto strInfo = decodeString(content, scheme);\n        enforce!CurlException(strInfo[0] != size_t.max,\n                                format(\"Invalid encoding sequence for encoding '%s'\",\n                                       encoding));\n\n        return strInfo[1];\n    }\n}\n\nalias KeepTerminator = Flag!\"keepTerminator\";\n/+\nstruct ByLineBuffer(Char)\n{\n    bool linePresent;\n    bool EOF;\n    Char[] buffer;\n    ubyte[] decodeRemainder;\n\n    bool append(const(ubyte)[] data)\n    {\n        byLineBuffer ~= data;\n    }\n\n    @property bool linePresent()\n    {\n        return byLinePresent;\n    }\n\n    Char[] get()\n    {\n        if (!linePresent)\n        {\n            // Decode ubyte[] into Char[] until a Terminator is found.\n            // If not Terminator is found and EOF is false then raise an\n            // exception.\n        }\n        return byLineBuffer;\n    }\n\n}\n++/\n/** HTTP/FTP fetch content as a range of lines.\n *\n * A range of lines is returned when the request is complete. If the method or\n * other request properties is to be customized then set the `conn` parameter\n * with a HTTP/FTP instance that has these properties set.\n *\n * Example:\n * ----\n * import std.net.curl, std.stdio;\n * foreach (line; byLine(\"dlang.org\"))\n *     writeln(line);\n * ----\n *\n * Params:\n * url = The url to receive content from\n * keepTerminator = `Yes.keepTerminator` signals that the line terminator should be\n *                  returned as part of the lines in the range.\n * terminator = The character that terminates a line\n * conn = The connection to use e.g. HTTP or FTP.\n *\n * Returns:\n * A range of Char[] with the content of the resource pointer to by the URL\n */\nauto byLine(Conn = AutoProtocol, Terminator = char, Char = char)\n           (const(char)[] url, KeepTerminator keepTerminator = No.keepTerminator,\n            Terminator terminator = '\\n', Conn conn = Conn())\nif (isCurlConn!Conn && isSomeChar!Char && isSomeChar!Terminator)\n{\n    static struct SyncLineInputRange\n    {\n\n        private Char[] lines;\n        private Char[] current;\n        private bool currentValid;\n        private bool keepTerminator;\n        private Terminator terminator;\n\n        this(Char[] lines, bool kt, Terminator terminator)\n        {\n            this.lines = lines;\n            this.keepTerminator = kt;\n            this.terminator = terminator;\n            currentValid = true;\n            popFront();\n        }\n\n        @property @safe bool empty()\n        {\n            return !currentValid;\n        }\n\n        @property @safe Char[] front()\n        {\n            import std.exception : enforce;\n            enforce!CurlException(currentValid, \"Cannot call front() on empty range\");\n            return current;\n        }\n\n        void popFront()\n        {\n            import std.algorithm.searching : findSplitAfter, findSplit;\n            import std.exception : enforce;\n\n            enforce!CurlException(currentValid, \"Cannot call popFront() on empty range\");\n            if (lines.empty)\n            {\n                currentValid = false;\n                return;\n            }\n\n            if (keepTerminator)\n            {\n                auto r = findSplitAfter(lines, [ terminator ]);\n                if (r[0].empty)\n                {\n                    current = r[1];\n                    lines = r[0];\n                }\n                else\n                {\n                    current = r[0];\n                    lines = r[1];\n                }\n            }\n            else\n            {\n                auto r = findSplit(lines, [ terminator ]);\n                current = r[0];\n                lines = r[2];\n            }\n        }\n    }\n\n    auto result = _getForRange!Char(url, conn);\n    return SyncLineInputRange(result, keepTerminator == Yes.keepTerminator, terminator);\n}\n\n@system unittest\n{\n    import std.algorithm.comparison : equal;\n\n    foreach (host; [testServer.addr, \"http://\"~testServer.addr])\n    {\n        testServer.handle((s) {\n            auto req = s.recvReq;\n            s.send(httpOK(\"Line1\\nLine2\\nLine3\"));\n        });\n        assert(byLine(host).equal([\"Line1\", \"Line2\", \"Line3\"]));\n    }\n}\n\n/** HTTP/FTP fetch content as a range of chunks.\n *\n * A range of chunks is returned when the request is complete. If the method or\n * other request properties is to be customized then set the `conn` parameter\n * with a HTTP/FTP instance that has these properties set.\n *\n * Example:\n * ----\n * import std.net.curl, std.stdio;\n * foreach (chunk; byChunk(\"dlang.org\", 100))\n *     writeln(chunk); // chunk is ubyte[100]\n * ----\n *\n * Params:\n * url = The url to receive content from\n * chunkSize = The size of each chunk\n * conn = The connection to use e.g. HTTP or FTP.\n *\n * Returns:\n * A range of ubyte[chunkSize] with the content of the resource pointer to by the URL\n */\nauto byChunk(Conn = AutoProtocol)\n            (const(char)[] url, size_t chunkSize = 1024, Conn conn = Conn())\nif (isCurlConn!(Conn))\n{\n    static struct SyncChunkInputRange\n    {\n        private size_t chunkSize;\n        private ubyte[] _bytes;\n        private size_t offset;\n\n        this(ubyte[] bytes, size_t chunkSize)\n        {\n            this._bytes = bytes;\n            this.chunkSize = chunkSize;\n        }\n\n        @property @safe auto empty()\n        {\n            return offset == _bytes.length;\n        }\n\n        @property ubyte[] front()\n        {\n            size_t nextOffset = offset + chunkSize;\n            if (nextOffset > _bytes.length) nextOffset = _bytes.length;\n            return _bytes[offset .. nextOffset];\n        }\n\n        @safe void popFront()\n        {\n            offset += chunkSize;\n            if (offset > _bytes.length) offset = _bytes.length;\n        }\n    }\n\n    auto result = _getForRange!ubyte(url, conn);\n    return SyncChunkInputRange(result, chunkSize);\n}\n\n@system unittest\n{\n    import std.algorithm.comparison : equal;\n\n    foreach (host; [testServer.addr, \"http://\"~testServer.addr])\n    {\n        testServer.handle((s) {\n            auto req = s.recvReq;\n            s.send(httpOK(cast(ubyte[])[0, 1, 2, 3, 4, 5]));\n        });\n        assert(byChunk(host, 2).equal([[0, 1], [2, 3], [4, 5]]));\n    }\n}\n\nprivate T[] _getForRange(T,Conn)(const(char)[] url, Conn conn)\n{\n    static if (is(Conn : HTTP))\n    {\n        conn.method = conn.method == HTTP.Method.undefined ? HTTP.Method.get : conn.method;\n        return _basicHTTP!(T)(url, null, conn);\n    }\n    else static if (is(Conn : FTP))\n    {\n        return _basicFTP!(T)(url, null, conn);\n    }\n    else\n    {\n        if (isFTPUrl(url))\n            return get!(FTP,T)(url, FTP());\n        else\n            return get!(HTTP,T)(url, HTTP());\n    }\n}\n\n/*\n  Main thread part of the message passing protocol used for all async\n  curl protocols.\n */\nprivate mixin template WorkerThreadProtocol(Unit, alias units)\n{\n    import core.time : Duration;\n\n    @property bool empty()\n    {\n        tryEnsureUnits();\n        return state == State.done;\n    }\n\n    @property Unit[] front()\n    {\n        import std.format : format;\n        tryEnsureUnits();\n        assert(state == State.gotUnits,\n               format(\"Expected %s but got $s\",\n                      State.gotUnits, state));\n        return units;\n    }\n\n    void popFront()\n    {\n        import std.concurrency : send;\n        import std.format : format;\n\n        tryEnsureUnits();\n        assert(state == State.gotUnits,\n               format(\"Expected %s but got $s\",\n                      State.gotUnits, state));\n        state = State.needUnits;\n        // Send to worker thread for buffer reuse\n        workerTid.send(cast(immutable(Unit)[]) units);\n        units = null;\n    }\n\n    /** Wait for duration or until data is available and return true if data is\n         available\n    */\n    bool wait(Duration d)\n    {\n        import core.time : dur;\n        import std.datetime.stopwatch : StopWatch;\n        import std.concurrency : receiveTimeout;\n\n        if (state == State.gotUnits)\n            return true;\n\n        enum noDur = dur!\"hnsecs\"(0);\n        StopWatch sw;\n        sw.start();\n        while (state != State.gotUnits && d > noDur)\n        {\n            final switch (state)\n            {\n            case State.needUnits:\n                receiveTimeout(d,\n                        (Tid origin, CurlMessage!(immutable(Unit)[]) _data)\n                        {\n                            if (origin != workerTid)\n                                return false;\n                            units = cast(Unit[]) _data.data;\n                            state = State.gotUnits;\n                            return true;\n                        },\n                        (Tid origin, CurlMessage!bool f)\n                        {\n                            if (origin != workerTid)\n                                return false;\n                            state = state.done;\n                            return true;\n                        }\n                        );\n                break;\n            case State.gotUnits: return true;\n            case State.done:\n                return false;\n            }\n            d -= sw.peek();\n            sw.reset();\n        }\n        return state == State.gotUnits;\n    }\n\n    enum State\n    {\n        needUnits,\n        gotUnits,\n        done\n    }\n    State state;\n\n    void tryEnsureUnits()\n    {\n        import std.concurrency : receive;\n        while (true)\n        {\n            final switch (state)\n            {\n            case State.needUnits:\n                receive(\n                        (Tid origin, CurlMessage!(immutable(Unit)[]) _data)\n                        {\n                            if (origin != workerTid)\n                                return false;\n                            units = cast(Unit[]) _data.data;\n                            state = State.gotUnits;\n                            return true;\n                        },\n                        (Tid origin, CurlMessage!bool f)\n                        {\n                            if (origin != workerTid)\n                                return false;\n                            state = state.done;\n                            return true;\n                        }\n                        );\n                break;\n            case State.gotUnits: return;\n            case State.done:\n                return;\n            }\n        }\n    }\n}\n\n/** HTTP/FTP fetch content as a range of lines asynchronously.\n *\n * A range of lines is returned immediately and the request that fetches the\n * lines is performed in another thread. If the method or other request\n * properties is to be customized then set the `conn` parameter with a\n * HTTP/FTP instance that has these properties set.\n *\n * If `postData` is non-_null the method will be set to `post` for HTTP\n * requests.\n *\n * The background thread will buffer up to transmitBuffers number of lines\n * before it stops receiving data from network. When the main thread reads the\n * lines from the range it frees up buffers and allows for the background thread\n * to receive more data from the network.\n *\n * If no data is available and the main thread accesses the range it will block\n * until data becomes available. An exception to this is the `wait(Duration)` method on\n * the $(LREF LineInputRange). This method will wait at maximum for the\n * specified duration and return true if data is available.\n *\n * Example:\n * ----\n * import std.net.curl, std.stdio;\n * // Get some pages in the background\n * auto range1 = byLineAsync(\"www.google.com\");\n * auto range2 = byLineAsync(\"www.wikipedia.org\");\n * foreach (line; byLineAsync(\"dlang.org\"))\n *     writeln(line);\n *\n * // Lines already fetched in the background and ready\n * foreach (line; range1) writeln(line);\n * foreach (line; range2) writeln(line);\n * ----\n *\n * ----\n * import std.net.curl, std.stdio;\n * // Get a line in a background thread and wait in\n * // main thread for 2 seconds for it to arrive.\n * auto range3 = byLineAsync(\"dlang.com\");\n * if (range3.wait(dur!\"seconds\"(2)))\n *     writeln(range3.front);\n * else\n *     writeln(\"No line received after 2 seconds!\");\n * ----\n *\n * Params:\n * url = The url to receive content from\n * postData = Data to HTTP Post\n * keepTerminator = `Yes.keepTerminator` signals that the line terminator should be\n *                  returned as part of the lines in the range.\n * terminator = The character that terminates a line\n * transmitBuffers = The number of lines buffered asynchronously\n * conn = The connection to use e.g. HTTP or FTP.\n *\n * Returns:\n * A range of Char[] with the content of the resource pointer to by the\n * URL.\n */\nauto byLineAsync(Conn = AutoProtocol, Terminator = char, Char = char, PostUnit)\n            (const(char)[] url, const(PostUnit)[] postData,\n             KeepTerminator keepTerminator = No.keepTerminator,\n             Terminator terminator = '\\n',\n             size_t transmitBuffers = 10, Conn conn = Conn())\nif (isCurlConn!Conn && isSomeChar!Char && isSomeChar!Terminator)\n{\n    static if (is(Conn : AutoProtocol))\n    {\n        if (isFTPUrl(url))\n            return byLineAsync(url, postData, keepTerminator,\n                               terminator, transmitBuffers, FTP());\n        else\n            return byLineAsync(url, postData, keepTerminator,\n                               terminator, transmitBuffers, HTTP());\n    }\n    else\n    {\n        import std.concurrency : OnCrowding, send, setMaxMailboxSize, spawn, thisTid, Tid;\n        // 50 is just an arbitrary number for now\n        setMaxMailboxSize(thisTid, 50, OnCrowding.block);\n        auto tid = spawn(&_async!().spawn!(Conn, Char, Terminator));\n        tid.send(thisTid);\n        tid.send(terminator);\n        tid.send(keepTerminator == Yes.keepTerminator);\n\n        _async!().duplicateConnection(url, conn, postData, tid);\n\n        return _async!().LineInputRange!Char(tid, transmitBuffers,\n                                             Conn.defaultAsyncStringBufferSize);\n    }\n}\n\n/// ditto\nauto byLineAsync(Conn = AutoProtocol, Terminator = char, Char = char)\n            (const(char)[] url, KeepTerminator keepTerminator = No.keepTerminator,\n             Terminator terminator = '\\n',\n             size_t transmitBuffers = 10, Conn conn = Conn())\n{\n    static if (is(Conn : AutoProtocol))\n    {\n        if (isFTPUrl(url))\n            return byLineAsync(url, cast(void[]) null, keepTerminator,\n                               terminator, transmitBuffers, FTP());\n        else\n            return byLineAsync(url, cast(void[]) null, keepTerminator,\n                               terminator, transmitBuffers, HTTP());\n    }\n    else\n    {\n        return byLineAsync(url, cast(void[]) null, keepTerminator,\n                           terminator, transmitBuffers, conn);\n    }\n}\n\n@system unittest\n{\n    import std.algorithm.comparison : equal;\n\n    foreach (host; [testServer.addr, \"http://\"~testServer.addr])\n    {\n        testServer.handle((s) {\n            auto req = s.recvReq;\n            s.send(httpOK(\"Line1\\nLine2\\nLine3\"));\n        });\n        assert(byLineAsync(host).equal([\"Line1\", \"Line2\", \"Line3\"]));\n    }\n}\n\n/** HTTP/FTP fetch content as a range of chunks asynchronously.\n *\n * A range of chunks is returned immediately and the request that fetches the\n * chunks is performed in another thread. If the method or other request\n * properties is to be customized then set the `conn` parameter with a\n * HTTP/FTP instance that has these properties set.\n *\n * If `postData` is non-_null the method will be set to `post` for HTTP\n * requests.\n *\n * The background thread will buffer up to transmitBuffers number of chunks\n * before is stops receiving data from network. When the main thread reads the\n * chunks from the range it frees up buffers and allows for the background\n * thread to receive more data from the network.\n *\n * If no data is available and the main thread access the range it will block\n * until data becomes available. An exception to this is the `wait(Duration)`\n * method on the $(LREF ChunkInputRange). This method will wait at maximum for the specified\n * duration and return true if data is available.\n *\n * Example:\n * ----\n * import std.net.curl, std.stdio;\n * // Get some pages in the background\n * auto range1 = byChunkAsync(\"www.google.com\", 100);\n * auto range2 = byChunkAsync(\"www.wikipedia.org\");\n * foreach (chunk; byChunkAsync(\"dlang.org\"))\n *     writeln(chunk); // chunk is ubyte[100]\n *\n * // Chunks already fetched in the background and ready\n * foreach (chunk; range1) writeln(chunk);\n * foreach (chunk; range2) writeln(chunk);\n * ----\n *\n * ----\n * import std.net.curl, std.stdio;\n * // Get a line in a background thread and wait in\n * // main thread for 2 seconds for it to arrive.\n * auto range3 = byChunkAsync(\"dlang.com\", 10);\n * if (range3.wait(dur!\"seconds\"(2)))\n *     writeln(range3.front);\n * else\n *     writeln(\"No chunk received after 2 seconds!\");\n * ----\n *\n * Params:\n * url = The url to receive content from\n * postData = Data to HTTP Post\n * chunkSize = The size of the chunks\n * transmitBuffers = The number of chunks buffered asynchronously\n * conn = The connection to use e.g. HTTP or FTP.\n *\n * Returns:\n * A range of ubyte[chunkSize] with the content of the resource pointer to by\n * the URL.\n */\nauto byChunkAsync(Conn = AutoProtocol, PostUnit)\n           (const(char)[] url, const(PostUnit)[] postData,\n            size_t chunkSize = 1024, size_t transmitBuffers = 10,\n            Conn conn = Conn())\nif (isCurlConn!(Conn))\n{\n    static if (is(Conn : AutoProtocol))\n    {\n        if (isFTPUrl(url))\n            return byChunkAsync(url, postData, chunkSize,\n                                transmitBuffers, FTP());\n        else\n            return byChunkAsync(url, postData, chunkSize,\n                                transmitBuffers, HTTP());\n    }\n    else\n    {\n        import std.concurrency : OnCrowding, send, setMaxMailboxSize, spawn, thisTid, Tid;\n        // 50 is just an arbitrary number for now\n        setMaxMailboxSize(thisTid, 50, OnCrowding.block);\n        auto tid = spawn(&_async!().spawn!(Conn, ubyte));\n        tid.send(thisTid);\n\n        _async!().duplicateConnection(url, conn, postData, tid);\n\n        return _async!().ChunkInputRange(tid, transmitBuffers, chunkSize);\n    }\n}\n\n/// ditto\nauto byChunkAsync(Conn = AutoProtocol)\n           (const(char)[] url,\n            size_t chunkSize = 1024, size_t transmitBuffers = 10,\n            Conn conn = Conn())\nif (isCurlConn!(Conn))\n{\n    static if (is(Conn : AutoProtocol))\n    {\n        if (isFTPUrl(url))\n            return byChunkAsync(url, cast(void[]) null, chunkSize,\n                                transmitBuffers, FTP());\n        else\n            return byChunkAsync(url, cast(void[]) null, chunkSize,\n                                transmitBuffers, HTTP());\n    }\n    else\n    {\n        return byChunkAsync(url, cast(void[]) null, chunkSize,\n                            transmitBuffers, conn);\n    }\n}\n\n@system unittest\n{\n    import std.algorithm.comparison : equal;\n\n    foreach (host; [testServer.addr, \"http://\"~testServer.addr])\n    {\n        testServer.handle((s) {\n            auto req = s.recvReq;\n            s.send(httpOK(cast(ubyte[])[0, 1, 2, 3, 4, 5]));\n        });\n        assert(byChunkAsync(host, 2).equal([[0, 1], [2, 3], [4, 5]]));\n    }\n}\n\n\n/*\n  Mixin template for all supported curl protocols. This is the commom\n  functionallity such as timeouts and network interface settings. This should\n  really be in the HTTP/FTP/SMTP structs but the documentation tool does not\n  support a mixin to put its doc strings where a mixin is done. Therefore docs\n  in this template is copied into each of HTTP/FTP/SMTP below.\n*/\nprivate mixin template Protocol()\n{\n    import etc.c.curl : CurlReadFunc, RawCurlProxy = CurlProxy;\n    import core.time : Duration;\n    import std.socket : InternetAddress;\n\n    /// Value to return from `onSend`/`onReceive` delegates in order to\n    /// pause a request\n    alias requestPause = CurlReadFunc.pause;\n\n    /// Value to return from onSend delegate in order to abort a request\n    alias requestAbort = CurlReadFunc.abort;\n\n    static uint defaultAsyncStringBufferSize = 100;\n\n    /**\n       The curl handle used by this connection.\n    */\n    @property ref Curl handle() return\n    {\n        return p.curl;\n    }\n\n    /**\n       True if the instance is stopped. A stopped instance is not usable.\n    */\n    @property bool isStopped()\n    {\n        return p.curl.stopped;\n    }\n\n    /// Stop and invalidate this instance.\n    void shutdown()\n    {\n        p.curl.shutdown();\n    }\n\n    /** Set verbose.\n        This will print request information to stderr.\n     */\n    @property void verbose(bool on)\n    {\n        p.curl.set(CurlOption.verbose, on ? 1L : 0L);\n    }\n\n    // Connection settings\n\n    /// Set timeout for activity on connection.\n    @property void dataTimeout(Duration d)\n    {\n        p.curl.set(CurlOption.low_speed_limit, 1);\n        p.curl.set(CurlOption.low_speed_time, d.total!\"seconds\");\n    }\n\n    /** Set maximum time an operation is allowed to take.\n        This includes dns resolution, connecting, data transfer, etc.\n     */\n    @property void operationTimeout(Duration d)\n    {\n        p.curl.set(CurlOption.timeout_ms, d.total!\"msecs\");\n    }\n\n    /// Set timeout for connecting.\n    @property void connectTimeout(Duration d)\n    {\n        p.curl.set(CurlOption.connecttimeout_ms, d.total!\"msecs\");\n    }\n\n    // Network settings\n\n    /** Proxy\n     *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy)\n     */\n    @property void proxy(const(char)[] host)\n    {\n        p.curl.set(CurlOption.proxy, host);\n    }\n\n    /** Proxy port\n     *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXYPORT, _proxy_port)\n     */\n    @property void proxyPort(ushort port)\n    {\n        p.curl.set(CurlOption.proxyport, cast(long) port);\n    }\n\n    /// Type of proxy\n    alias CurlProxy = RawCurlProxy;\n\n    /** Proxy type\n     *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy_type)\n     */\n    @property void proxyType(CurlProxy type)\n    {\n        p.curl.set(CurlOption.proxytype, cast(long) type);\n    }\n\n    /// DNS lookup timeout.\n    @property void dnsTimeout(Duration d)\n    {\n        p.curl.set(CurlOption.dns_cache_timeout, d.total!\"msecs\");\n    }\n\n    /**\n     * The network interface to use in form of the the IP of the interface.\n     *\n     * Example:\n     * ----\n     * theprotocol.netInterface = \"192.168.1.32\";\n     * theprotocol.netInterface = [ 192, 168, 1, 32 ];\n     * ----\n     *\n     * See: $(REF InternetAddress, std,socket)\n     */\n    @property void netInterface(const(char)[] i)\n    {\n        p.curl.set(CurlOption.intrface, i);\n    }\n\n    /// ditto\n    @property void netInterface(const(ubyte)[4] i)\n    {\n        import std.format : format;\n        const str = format(\"%d.%d.%d.%d\", i[0], i[1], i[2], i[3]);\n        netInterface = str;\n    }\n\n    /// ditto\n    @property void netInterface(InternetAddress i)\n    {\n        netInterface = i.toAddrString();\n    }\n\n    /**\n       Set the local outgoing port to use.\n       Params:\n       port = the first outgoing port number to try and use\n    */\n    @property void localPort(ushort port)\n    {\n        p.curl.set(CurlOption.localport, cast(long) port);\n    }\n\n    /**\n       Set the no proxy flag for the specified host names.\n       Params:\n       test = a list of comma host names that do not require\n              proxy to get reached\n    */\n    void setNoProxy(string hosts)\n    {\n        p.curl.set(CurlOption.noproxy, hosts);\n    }\n\n    /**\n       Set the local outgoing port range to use.\n       This can be used together with the localPort property.\n       Params:\n       range = if the first port is occupied then try this many\n               port number forwards\n    */\n    @property void localPortRange(ushort range)\n    {\n        p.curl.set(CurlOption.localportrange, cast(long) range);\n    }\n\n    /** Set the tcp no-delay socket option on or off.\n        See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTTCPNODELAY, nodelay)\n    */\n    @property void tcpNoDelay(bool on)\n    {\n        p.curl.set(CurlOption.tcp_nodelay, cast(long) (on ? 1 : 0) );\n    }\n\n    /** Sets whether SSL peer certificates should be verified.\n        See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTSSLVERIFYPEER, verifypeer)\n    */\n    @property void verifyPeer(bool on)\n    {\n      p.curl.set(CurlOption.ssl_verifypeer, on ? 1 : 0);\n    }\n\n    /** Sets whether the host within an SSL certificate should be verified.\n        See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTSSLVERIFYHOST, verifypeer)\n    */\n    @property void verifyHost(bool on)\n    {\n      p.curl.set(CurlOption.ssl_verifyhost, on ? 2 : 0);\n    }\n\n    // Authentication settings\n\n    /**\n       Set the user name, password and optionally domain for authentication\n       purposes.\n\n       Some protocols may need authentication in some cases. Use this\n       function to provide credentials.\n\n       Params:\n       username = the username\n       password = the password\n       domain = used for NTLM authentication only and is set to the NTLM domain\n                name\n    */\n    void setAuthentication(const(char)[] username, const(char)[] password,\n                           const(char)[] domain = \"\")\n    {\n        import std.format : format;\n        if (!domain.empty)\n            username = format(\"%s/%s\", domain, username);\n        p.curl.set(CurlOption.userpwd, format(\"%s:%s\", username, password));\n    }\n\n    @system unittest\n    {\n        import std.algorithm.searching : canFind;\n\n        testServer.handle((s) {\n            auto req = s.recvReq;\n            assert(req.hdrs.canFind(\"GET /\"));\n            assert(req.hdrs.canFind(\"Basic dXNlcjpwYXNz\"));\n            s.send(httpOK());\n        });\n\n        auto http = HTTP(testServer.addr);\n        http.onReceive = (ubyte[] data) { return data.length; };\n        http.setAuthentication(\"user\", \"pass\");\n        http.perform();\n\n        // Bugzilla 17540\n        http.setNoProxy(\"www.example.com\");\n    }\n\n    /**\n       Set the user name and password for proxy authentication.\n\n       Params:\n       username = the username\n       password = the password\n    */\n    void setProxyAuthentication(const(char)[] username, const(char)[] password)\n    {\n        import std.array : replace;\n        import std.format : format;\n\n        p.curl.set(CurlOption.proxyuserpwd,\n            format(\"%s:%s\",\n                username.replace(\":\", \"%3A\"),\n                password.replace(\":\", \"%3A\"))\n        );\n    }\n\n    /**\n     * The event handler that gets called when data is needed for sending. The\n     * length of the `void[]` specifies the maximum number of bytes that can\n     * be sent.\n     *\n     * Returns:\n     * The callback returns the number of elements in the buffer that have been\n     * filled and are ready to send.\n     * The special value `.abortRequest` can be returned in order to abort the\n     * current request.\n     * The special value `.pauseRequest` can be returned in order to pause the\n     * current request.\n     *\n     * Example:\n     * ----\n     * import std.net.curl;\n     * string msg = \"Hello world\";\n     * auto client = HTTP(\"dlang.org\");\n     * client.onSend = delegate size_t(void[] data)\n     * {\n     *     auto m = cast(void[]) msg;\n     *     size_t length = m.length > data.length ? data.length : m.length;\n     *     if (length == 0) return 0;\n     *     data[0 .. length] = m[0 .. length];\n     *     msg = msg[length..$];\n     *     return length;\n     * };\n     * client.perform();\n     * ----\n     */\n    @property void onSend(size_t delegate(void[]) callback)\n    {\n        p.curl.clear(CurlOption.postfields); // cannot specify data when using callback\n        p.curl.onSend = callback;\n    }\n\n    /**\n      * The event handler that receives incoming data. Be sure to copy the\n      * incoming ubyte[] since it is not guaranteed to be valid after the\n      * callback returns.\n      *\n      * Returns:\n      * The callback returns the number of incoming bytes read. If the entire array is\n      * not read the request will abort.\n      * The special value .pauseRequest can be returned in order to pause the\n      * current request.\n      *\n      * Example:\n      * ----\n      * import std.net.curl, std.stdio;\n      * auto client = HTTP(\"dlang.org\");\n      * client.onReceive = (ubyte[] data)\n      * {\n      *     writeln(\"Got data\", to!(const(char)[])(data));\n      *     return data.length;\n      * };\n      * client.perform();\n      * ----\n      */\n    @property void onReceive(size_t delegate(ubyte[]) callback)\n    {\n        p.curl.onReceive = callback;\n    }\n\n    /**\n      * The event handler that gets called to inform of upload/download progress.\n      *\n      * Params:\n      * dlTotal = total bytes to download\n      * dlNow = currently downloaded bytes\n      * ulTotal = total bytes to upload\n      * ulNow = currently uploaded bytes\n      *\n      * Returns:\n      * Return 0 from the callback to signal success, return non-zero to abort\n      *          transfer\n      *\n      * Example:\n      * ----\n      * import std.net.curl, std.stdio;\n      * auto client = HTTP(\"dlang.org\");\n      * client.onProgress = delegate int(size_t dl, size_t dln, size_t ul, size_t ult)\n      * {\n      *     writeln(\"Progress: downloaded \", dln, \" of \", dl);\n      *     writeln(\"Progress: uploaded \", uln, \" of \", ul);\n      * };\n      * client.perform();\n      * ----\n      */\n    @property void onProgress(int delegate(size_t dlTotal, size_t dlNow,\n                                           size_t ulTotal, size_t ulNow) callback)\n    {\n        p.curl.onProgress = callback;\n    }\n}\n\n/*\n  Decode `ubyte[]` array using the provided EncodingScheme up to maxChars\n  Returns: Tuple of ubytes read and the `Char[]` characters decoded.\n           Not all ubytes are guaranteed to be read in case of decoding error.\n*/\nprivate Tuple!(size_t,Char[])\ndecodeString(Char = char)(const(ubyte)[] data,\n                          EncodingScheme scheme,\n                          size_t maxChars = size_t.max)\n{\n    import std.encoding : INVALID_SEQUENCE;\n    Char[] res;\n    immutable startLen = data.length;\n    size_t charsDecoded = 0;\n    while (data.length && charsDecoded < maxChars)\n    {\n        immutable dchar dc = scheme.safeDecode(data);\n        if (dc == INVALID_SEQUENCE)\n        {\n            return typeof(return)(size_t.max, cast(Char[]) null);\n        }\n        charsDecoded++;\n        res ~= dc;\n    }\n    return typeof(return)(startLen-data.length, res);\n}\n\n/*\n  Decode `ubyte[]` array using the provided `EncodingScheme` until a the\n  line terminator specified is found. The basesrc parameter is effectively\n  prepended to src as the first thing.\n\n  This function is used for decoding as much of the src buffer as\n  possible until either the terminator is found or decoding fails. If\n  it fails as the last data in the src it may mean that the src buffer\n  were missing some bytes in order to represent a correct code\n  point. Upon the next call to this function more bytes have been\n  received from net and the failing bytes should be given as the\n  basesrc parameter. It is done this way to minimize data copying.\n\n  Returns: true if a terminator was found\n           Not all ubytes are guaranteed to be read in case of decoding error.\n           any decoded chars will be inserted into dst.\n*/\nprivate bool decodeLineInto(Terminator, Char = char)(ref const(ubyte)[] basesrc,\n                                                     ref const(ubyte)[] src,\n                                                     ref Char[] dst,\n                                                     EncodingScheme scheme,\n                                                     Terminator terminator)\n{\n    import std.algorithm.searching : endsWith;\n    import std.encoding : INVALID_SEQUENCE;\n    import std.exception : enforce;\n\n    // if there is anything in the basesrc then try to decode that\n    // first.\n    if (basesrc.length != 0)\n    {\n        // Try to ensure 4 entries in the basesrc by copying from src.\n        immutable blen = basesrc.length;\n        immutable len = (basesrc.length + src.length) >= 4 ?\n                     4 : basesrc.length + src.length;\n        basesrc.length = len;\n\n        immutable dchar dc = scheme.safeDecode(basesrc);\n        if (dc == INVALID_SEQUENCE)\n        {\n            enforce!CurlException(len != 4, \"Invalid code sequence\");\n            return false;\n        }\n        dst ~= dc;\n        src = src[len-basesrc.length-blen .. $]; // remove used ubytes from src\n        basesrc.length = 0;\n    }\n\n    while (src.length)\n    {\n        const lsrc = src;\n        dchar dc = scheme.safeDecode(src);\n        if (dc == INVALID_SEQUENCE)\n        {\n            if (src.empty)\n            {\n                // The invalid sequence was in the end of the src.  Maybe there\n                // just need to be more bytes available so these last bytes are\n                // put back to src for later use.\n                src = lsrc;\n                return false;\n            }\n            dc = '?';\n        }\n        dst ~= dc;\n\n        if (dst.endsWith(terminator))\n            return true;\n    }\n    return false; // no terminator found\n}\n\n/**\n  * HTTP client functionality.\n  *\n  * Example:\n  * ---\n  * import std.net.curl, std.stdio;\n  *\n  * // Get with custom data receivers\n  * auto http = HTTP(\"dlang.org\");\n  * http.onReceiveHeader =\n  *     (in char[] key, in char[] value) { writeln(key ~ \": \" ~ value); };\n  * http.onReceive = (ubyte[] data) { /+ drop +/ return data.length; };\n  * http.perform();\n  *\n  * // Put with data senders\n  * auto msg = \"Hello world\";\n  * http.contentLength = msg.length;\n  * http.onSend = (void[] data)\n  * {\n  *     auto m = cast(void[]) msg;\n  *     size_t len = m.length > data.length ? data.length : m.length;\n  *     if (len == 0) return len;\n  *     data[0 .. len] = m[0 .. len];\n  *     msg = msg[len..$];\n  *     return len;\n  * };\n  * http.perform();\n  *\n  * // Track progress\n  * http.method = HTTP.Method.get;\n  * http.url = \"http://upload.wikimedia.org/wikipedia/commons/\"\n  *            \"5/53/Wikipedia-logo-en-big.png\";\n  * http.onReceive = (ubyte[] data) { return data.length; };\n  * http.onProgress = (size_t dltotal, size_t dlnow,\n  *                    size_t ultotal, size_t ulnow)\n  * {\n  *     writeln(\"Progress \", dltotal, \", \", dlnow, \", \", ultotal, \", \", ulnow);\n  *     return 0;\n  * };\n  * http.perform();\n  * ---\n  *\n  * See_Also: $(LINK2 http://www.ietf.org/rfc/rfc2616.txt, RFC2616)\n  *\n  */\nstruct HTTP\n{\n    mixin Protocol;\n\n    import std.datetime.systime : SysTime;\n    import std.typecons : RefCounted;\n    import etc.c.curl : CurlAuth, CurlInfo, curl_slist, CURLVERSION_NOW, curl_off_t;\n\n    /// Authentication method equal to $(REF CurlAuth, etc,c,curl)\n    alias AuthMethod = CurlAuth;\n\n    static private uint defaultMaxRedirects = 10;\n\n    private struct Impl\n    {\n        ~this()\n        {\n            if (headersOut !is null)\n                Curl.curl.slist_free_all(headersOut);\n            if (curl.handle !is null) // work around RefCounted/emplace bug\n                curl.shutdown();\n        }\n        Curl curl;\n        curl_slist* headersOut;\n        string[string] headersIn;\n        string charset;\n\n        /// The status line of the final sub-request in a request.\n        StatusLine status;\n        private void delegate(StatusLine) onReceiveStatusLine;\n\n        /// The HTTP method to use.\n        Method method = Method.undefined;\n\n        @system @property void onReceiveHeader(void delegate(in char[] key,\n                                                     in char[] value) callback)\n        {\n            import std.algorithm.searching : startsWith;\n            import std.conv : to;\n            import std.regex : regex, match;\n            import std.uni : toLower;\n\n            // Wrap incoming callback in order to separate http status line from\n            // http headers.  On redirected requests there may be several such\n            // status lines. The last one is the one recorded.\n            auto dg = (in char[] header)\n            {\n                import std.utf : UTFException;\n                try\n                {\n                    if (header.empty)\n                    {\n                        // header delimiter\n                        return;\n                    }\n                    if (header.startsWith(\"HTTP/\"))\n                    {\n                        headersIn.clear();\n\n                        const m = match(header, regex(r\"^HTTP/(\\d+)\\.(\\d+) (\\d+) (.*)$\"));\n                        if (m.empty)\n                        {\n                            // Invalid status line\n                        }\n                        else\n                        {\n                            status.majorVersion = to!ushort(m.captures[1]);\n                            status.minorVersion = to!ushort(m.captures[2]);\n                            status.code = to!ushort(m.captures[3]);\n                            status.reason = m.captures[4].idup;\n                            if (onReceiveStatusLine != null)\n                                onReceiveStatusLine(status);\n                        }\n                        return;\n                    }\n\n                    // Normal http header\n                    auto m = match(cast(char[]) header, regex(\"(.*?): (.*)$\"));\n\n                    auto fieldName = m.captures[1].toLower().idup;\n                    if (fieldName == \"content-type\")\n                    {\n                        auto mct = match(cast(char[]) m.captures[2],\n                                         regex(\"charset=([^;]*)\", \"i\"));\n                        if (!mct.empty && mct.captures.length > 1)\n                            charset = mct.captures[1].idup;\n                    }\n\n                    if (!m.empty && callback !is null)\n                        callback(fieldName, m.captures[2]);\n                    headersIn[fieldName] = m.captures[2].idup;\n                }\n                catch (UTFException e)\n                {\n                    //munch it - a header should be all ASCII, any \"wrong UTF\" is broken header\n                }\n            };\n\n            curl.onReceiveHeader = dg;\n        }\n    }\n\n    private RefCounted!Impl p;\n    import etc.c.curl : CurlTimeCond;\n\n    /** Time condition enumeration as an alias of $(REF CurlTimeCond, etc,c,curl)\n\n        $(HTTP www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.25, _RFC2616 Section 14.25)\n    */\n    alias TimeCond = CurlTimeCond;\n\n    /**\n       Constructor taking the url as parameter.\n    */\n    static HTTP opCall(const(char)[] url)\n    {\n        HTTP http;\n        http.initialize();\n        http.url = url;\n        return http;\n    }\n\n    ///\n    static HTTP opCall()\n    {\n        HTTP http;\n        http.initialize();\n        return http;\n    }\n\n    ///\n    HTTP dup()\n    {\n        HTTP copy;\n        copy.initialize();\n        copy.p.method = p.method;\n        curl_slist* cur = p.headersOut;\n        curl_slist* newlist = null;\n        while (cur)\n        {\n            newlist = Curl.curl.slist_append(newlist, cur.data);\n            cur = cur.next;\n        }\n        copy.p.headersOut = newlist;\n        copy.p.curl.set(CurlOption.httpheader, copy.p.headersOut);\n        copy.p.curl = p.curl.dup();\n        copy.dataTimeout = _defaultDataTimeout;\n        copy.onReceiveHeader = null;\n        return copy;\n    }\n\n    private void initialize()\n    {\n        p.curl.initialize();\n        maxRedirects = HTTP.defaultMaxRedirects;\n        p.charset = \"ISO-8859-1\"; // Default charset defined in HTTP RFC\n        p.method = Method.undefined;\n        setUserAgent(HTTP.defaultUserAgent);\n        dataTimeout = _defaultDataTimeout;\n        onReceiveHeader = null;\n        verifyPeer = true;\n        verifyHost = true;\n    }\n\n    /**\n       Perform a http request.\n\n       After the HTTP client has been setup and possibly assigned callbacks the\n       `perform()` method will start performing the request towards the\n       specified server.\n\n       Params:\n       throwOnError = whether to throw an exception or return a CurlCode on error\n    */\n    CurlCode perform(ThrowOnError throwOnError = Yes.throwOnError)\n    {\n        p.status.reset();\n\n        CurlOption opt;\n        final switch (p.method)\n        {\n        case Method.head:\n            p.curl.set(CurlOption.nobody, 1L);\n            opt = CurlOption.nobody;\n            break;\n        case Method.undefined:\n        case Method.get:\n            p.curl.set(CurlOption.httpget, 1L);\n            opt = CurlOption.httpget;\n            break;\n        case Method.post:\n            p.curl.set(CurlOption.post, 1L);\n            opt = CurlOption.post;\n            break;\n        case Method.put:\n            p.curl.set(CurlOption.upload, 1L);\n            opt = CurlOption.upload;\n            break;\n        case Method.del:\n            p.curl.set(CurlOption.customrequest, \"DELETE\");\n            opt = CurlOption.customrequest;\n            break;\n        case Method.options:\n            p.curl.set(CurlOption.customrequest, \"OPTIONS\");\n            opt = CurlOption.customrequest;\n            break;\n        case Method.trace:\n            p.curl.set(CurlOption.customrequest, \"TRACE\");\n            opt = CurlOption.customrequest;\n            break;\n        case Method.connect:\n            p.curl.set(CurlOption.customrequest, \"CONNECT\");\n            opt = CurlOption.customrequest;\n            break;\n        case Method.patch:\n            p.curl.set(CurlOption.customrequest, \"PATCH\");\n            opt = CurlOption.customrequest;\n            break;\n        }\n\n        scope (exit) p.curl.clear(opt);\n        return p.curl.perform(throwOnError);\n    }\n\n    /// The URL to specify the location of the resource.\n    @property void url(const(char)[] url)\n    {\n        import std.algorithm.searching : startsWith;\n        import std.uni : toLower;\n        if (!startsWith(url.toLower(), \"http://\", \"https://\"))\n            url = \"http://\" ~ url;\n        p.curl.set(CurlOption.url, url);\n    }\n\n    /// Set the CA certificate bundle file to use for SSL peer verification\n    @property void caInfo(const(char)[] caFile)\n    {\n        p.curl.set(CurlOption.cainfo, caFile);\n    }\n\n    // This is a workaround for mixed in content not having its\n    // docs mixed in.\n    version (StdDdoc)\n    {\n        static import etc.c.curl;\n\n        /// Value to return from `onSend`/`onReceive` delegates in order to\n        /// pause a request\n        alias requestPause = CurlReadFunc.pause;\n\n        /// Value to return from onSend delegate in order to abort a request\n        alias requestAbort = CurlReadFunc.abort;\n\n        /**\n           True if the instance is stopped. A stopped instance is not usable.\n        */\n        @property bool isStopped();\n\n        /// Stop and invalidate this instance.\n        void shutdown();\n\n        /** Set verbose.\n            This will print request information to stderr.\n        */\n        @property void verbose(bool on);\n\n        // Connection settings\n\n        /// Set timeout for activity on connection.\n        @property void dataTimeout(Duration d);\n\n        /** Set maximum time an operation is allowed to take.\n            This includes dns resolution, connecting, data transfer, etc.\n          */\n        @property void operationTimeout(Duration d);\n\n        /// Set timeout for connecting.\n        @property void connectTimeout(Duration d);\n\n        // Network settings\n\n        /** Proxy\n         *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy)\n         */\n        @property void proxy(const(char)[] host);\n\n        /** Proxy port\n         *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXYPORT, _proxy_port)\n         */\n        @property void proxyPort(ushort port);\n\n        /// Type of proxy\n        alias CurlProxy = etc.c.curl.CurlProxy;\n\n        /** Proxy type\n         *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy_type)\n         */\n        @property void proxyType(CurlProxy type);\n\n        /// DNS lookup timeout.\n        @property void dnsTimeout(Duration d);\n\n        /**\n         * The network interface to use in form of the the IP of the interface.\n         *\n         * Example:\n         * ----\n         * theprotocol.netInterface = \"192.168.1.32\";\n         * theprotocol.netInterface = [ 192, 168, 1, 32 ];\n         * ----\n         *\n         * See: $(REF InternetAddress, std,socket)\n         */\n        @property void netInterface(const(char)[] i);\n\n        /// ditto\n        @property void netInterface(const(ubyte)[4] i);\n\n        /// ditto\n        @property void netInterface(InternetAddress i);\n\n        /**\n           Set the local outgoing port to use.\n           Params:\n           port = the first outgoing port number to try and use\n        */\n        @property void localPort(ushort port);\n\n        /**\n           Set the local outgoing port range to use.\n           This can be used together with the localPort property.\n           Params:\n           range = if the first port is occupied then try this many\n           port number forwards\n        */\n        @property void localPortRange(ushort range);\n\n        /** Set the tcp no-delay socket option on or off.\n            See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTTCPNODELAY, nodelay)\n        */\n        @property void tcpNoDelay(bool on);\n\n        // Authentication settings\n\n        /**\n           Set the user name, password and optionally domain for authentication\n           purposes.\n\n           Some protocols may need authentication in some cases. Use this\n           function to provide credentials.\n\n           Params:\n           username = the username\n           password = the password\n           domain = used for NTLM authentication only and is set to the NTLM domain\n           name\n        */\n        void setAuthentication(const(char)[] username, const(char)[] password,\n                               const(char)[] domain = \"\");\n\n        /**\n           Set the user name and password for proxy authentication.\n\n           Params:\n           username = the username\n           password = the password\n        */\n        void setProxyAuthentication(const(char)[] username, const(char)[] password);\n\n        /**\n         * The event handler that gets called when data is needed for sending. The\n         * length of the `void[]` specifies the maximum number of bytes that can\n         * be sent.\n         *\n         * Returns:\n         * The callback returns the number of elements in the buffer that have been\n         * filled and are ready to send.\n         * The special value `.abortRequest` can be returned in order to abort the\n         * current request.\n         * The special value `.pauseRequest` can be returned in order to pause the\n         * current request.\n         *\n         * Example:\n         * ----\n         * import std.net.curl;\n         * string msg = \"Hello world\";\n         * auto client = HTTP(\"dlang.org\");\n         * client.onSend = delegate size_t(void[] data)\n         * {\n         *     auto m = cast(void[]) msg;\n         *     size_t length = m.length > data.length ? data.length : m.length;\n         *     if (length == 0) return 0;\n         *     data[0 .. length] = m[0 .. length];\n         *     msg = msg[length..$];\n         *     return length;\n         * };\n         * client.perform();\n         * ----\n         */\n        @property void onSend(size_t delegate(void[]) callback);\n\n        /**\n         * The event handler that receives incoming data. Be sure to copy the\n         * incoming ubyte[] since it is not guaranteed to be valid after the\n         * callback returns.\n         *\n         * Returns:\n         * The callback returns the incoming bytes read. If not the entire array is\n         * the request will abort.\n         * The special value .pauseRequest can be returned in order to pause the\n         * current request.\n         *\n         * Example:\n         * ----\n         * import std.net.curl, std.stdio;\n         * auto client = HTTP(\"dlang.org\");\n         * client.onReceive = (ubyte[] data)\n         * {\n         *     writeln(\"Got data\", to!(const(char)[])(data));\n         *     return data.length;\n         * };\n         * client.perform();\n         * ----\n         */\n        @property void onReceive(size_t delegate(ubyte[]) callback);\n\n        /**\n         * Register an event handler that gets called to inform of\n         * upload/download progress.\n         *\n         * Callback_parameters:\n         * $(CALLBACK_PARAMS)\n         *\n         * Callback_returns: Return 0 to signal success, return non-zero to\n         * abort transfer.\n         *\n         * Example:\n         * ----\n         * import std.net.curl, std.stdio;\n         * auto client = HTTP(\"dlang.org\");\n         * client.onProgress = delegate int(size_t dl, size_t dln, size_t ul, size_t ult)\n         * {\n         *     writeln(\"Progress: downloaded \", dln, \" of \", dl);\n         *     writeln(\"Progress: uploaded \", uln, \" of \", ul);\n         * };\n         * client.perform();\n         * ----\n         */\n        @property void onProgress(int delegate(size_t dlTotal, size_t dlNow,\n                                               size_t ulTotal, size_t ulNow) callback);\n    }\n\n    /** Clear all outgoing headers.\n    */\n    void clearRequestHeaders()\n    {\n        if (p.headersOut !is null)\n            Curl.curl.slist_free_all(p.headersOut);\n        p.headersOut = null;\n        p.curl.clear(CurlOption.httpheader);\n    }\n\n    /** Add a header e.g. \"X-CustomField: Something is fishy\".\n     *\n     * There is no remove header functionality. Do a $(LREF clearRequestHeaders)\n     * and set the needed headers instead.\n     *\n     * Example:\n     * ---\n     * import std.net.curl;\n     * auto client = HTTP();\n     * client.addRequestHeader(\"X-Custom-ABC\", \"This is the custom value\");\n     * auto content = get(\"dlang.org\", client);\n     * ---\n     */\n    void addRequestHeader(const(char)[] name, const(char)[] value)\n    {\n        import std.format : format;\n        import std.internal.cstring : tempCString;\n        import std.uni : icmp;\n\n        if (icmp(name, \"User-Agent\") == 0)\n            return setUserAgent(value);\n        string nv = format(\"%s: %s\", name, value);\n        p.headersOut = Curl.curl.slist_append(p.headersOut,\n                                              nv.tempCString().buffPtr);\n        p.curl.set(CurlOption.httpheader, p.headersOut);\n    }\n\n    /**\n     * The default \"User-Agent\" value send with a request.\n     * It has the form \"Phobos-std.net.curl/$(I PHOBOS_VERSION) (libcurl/$(I CURL_VERSION))\"\n     */\n    static string defaultUserAgent() @property\n    {\n        import std.compiler : version_major, version_minor;\n        import std.format : format, sformat;\n\n        // http://curl.haxx.se/docs/versions.html\n        enum fmt = \"Phobos-std.net.curl/%d.%03d (libcurl/%d.%d.%d)\";\n        enum maxLen = fmt.length - \"%d%03d%d%d%d\".length + 10 + 10 + 3 + 3 + 3;\n\n        static char[maxLen] buf = void;\n        static string userAgent;\n\n        if (!userAgent.length)\n        {\n            auto curlVer = Curl.curl.version_info(CURLVERSION_NOW).version_num;\n            userAgent = cast(immutable) sformat(\n                buf, fmt, version_major, version_minor,\n                curlVer >> 16 & 0xFF, curlVer >> 8 & 0xFF, curlVer & 0xFF);\n        }\n        return userAgent;\n    }\n\n    /** Set the value of the user agent request header field.\n     *\n     * By default a request has it's \"User-Agent\" field set to $(LREF\n     * defaultUserAgent) even if `setUserAgent` was never called.  Pass\n     * an empty string to suppress the \"User-Agent\" field altogether.\n     */\n    void setUserAgent(const(char)[] userAgent)\n    {\n        p.curl.set(CurlOption.useragent, userAgent);\n    }\n\n    /**\n     * Get various timings defined in $(REF CurlInfo, etc, c, curl).\n     * The value is usable only if the return value is equal to `etc.c.curl.CurlError.ok`.\n     *\n     * Params:\n     *      timing = one of the timings defined in $(REF CurlInfo, etc, c, curl).\n     *               The values are:\n     *               `etc.c.curl.CurlInfo.namelookup_time`,\n     *               `etc.c.curl.CurlInfo.connect_time`,\n     *               `etc.c.curl.CurlInfo.pretransfer_time`,\n     *               `etc.c.curl.CurlInfo.starttransfer_time`,\n     *               `etc.c.curl.CurlInfo.redirect_time`,\n     *               `etc.c.curl.CurlInfo.appconnect_time`,\n     *               `etc.c.curl.CurlInfo.total_time`.\n     *      val    = the actual value of the inquired timing.\n     *\n     * Returns:\n     *      The return code of the operation. The value stored in val\n     *      should be used only if the return value is `etc.c.curl.CurlInfo.ok`.\n     *\n     * Example:\n     * ---\n     * import std.net.curl;\n     * import etc.c.curl : CurlError, CurlInfo;\n     *\n     * auto client = HTTP(\"dlang.org\");\n     * client.perform();\n     *\n     * double val;\n     * CurlCode code;\n     *\n     * code = client.getTiming(CurlInfo.namelookup_time, val);\n     * assert(code == CurlError.ok);\n     * ---\n     */\n    CurlCode getTiming(CurlInfo timing, ref double val)\n    {\n        return p.curl.getTiming(timing, val);\n    }\n\n    /** The headers read from a successful response.\n     *\n     */\n    @property string[string] responseHeaders()\n    {\n        return p.headersIn;\n    }\n\n    /// HTTP method used.\n    @property void method(Method m)\n    {\n        p.method = m;\n    }\n\n    /// ditto\n    @property Method method()\n    {\n        return p.method;\n    }\n\n    /**\n       HTTP status line of last response. One call to perform may\n       result in several requests because of redirection.\n    */\n    @property StatusLine statusLine()\n    {\n        return p.status;\n    }\n\n    /// Set the active cookie string e.g. \"name1=value1;name2=value2\"\n    void setCookie(const(char)[] cookie)\n    {\n        p.curl.set(CurlOption.cookie, cookie);\n    }\n\n    /// Set a file path to where a cookie jar should be read/stored.\n    void setCookieJar(const(char)[] path)\n    {\n        p.curl.set(CurlOption.cookiefile, path);\n        if (path.length)\n            p.curl.set(CurlOption.cookiejar, path);\n    }\n\n    /// Flush cookie jar to disk.\n    void flushCookieJar()\n    {\n        p.curl.set(CurlOption.cookielist, \"FLUSH\");\n    }\n\n    /// Clear session cookies.\n    void clearSessionCookies()\n    {\n        p.curl.set(CurlOption.cookielist, \"SESS\");\n    }\n\n    /// Clear all cookies.\n    void clearAllCookies()\n    {\n        p.curl.set(CurlOption.cookielist, \"ALL\");\n    }\n\n    /**\n       Set time condition on the request.\n\n       Params:\n       cond =  `CurlTimeCond.{none,ifmodsince,ifunmodsince,lastmod}`\n       timestamp = Timestamp for the condition\n\n       $(HTTP www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.25, _RFC2616 Section 14.25)\n    */\n    void setTimeCondition(HTTP.TimeCond cond, SysTime timestamp)\n    {\n        p.curl.set(CurlOption.timecondition, cond);\n        p.curl.set(CurlOption.timevalue, timestamp.toUnixTime());\n    }\n\n    /** Specifying data to post when not using the onSend callback.\n      *\n      * The data is NOT copied by the library.  Content-Type will default to\n      * application/octet-stream.  Data is not converted or encoded by this\n      * method.\n      *\n      * Example:\n      * ----\n      * import std.net.curl, std.stdio;\n      * auto http = HTTP(\"http://www.mydomain.com\");\n      * http.onReceive = (ubyte[] data) { writeln(to!(const(char)[])(data)); return data.length; };\n      * http.postData = [1,2,3,4,5];\n      * http.perform();\n      * ----\n      */\n    @property void postData(const(void)[] data)\n    {\n        setPostData(data, \"application/octet-stream\");\n    }\n\n    /** Specifying data to post when not using the onSend callback.\n      *\n      * The data is NOT copied by the library.  Content-Type will default to\n      * text/plain.  Data is not converted or encoded by this method.\n      *\n      * Example:\n      * ----\n      * import std.net.curl, std.stdio;\n      * auto http = HTTP(\"http://www.mydomain.com\");\n      * http.onReceive = (ubyte[] data) { writeln(to!(const(char)[])(data)); return data.length; };\n      * http.postData = \"The quick....\";\n      * http.perform();\n      * ----\n      */\n    @property void postData(const(char)[] data)\n    {\n        setPostData(data, \"text/plain\");\n    }\n\n    /**\n     * Specify data to post when not using the onSend callback, with\n     * user-specified Content-Type.\n     * Params:\n     *  data = Data to post.\n     *  contentType = MIME type of the data, for example, \"text/plain\" or\n     *      \"application/octet-stream\". See also:\n     *      $(LINK2 http://en.wikipedia.org/wiki/Internet_media_type,\n     *      Internet media type) on Wikipedia.\n     * -----\n     * import std.net.curl;\n     * auto http = HTTP(\"http://onlineform.example.com\");\n     * auto data = \"app=login&username=bob&password=s00perS3kret\";\n     * http.setPostData(data, \"application/x-www-form-urlencoded\");\n     * http.onReceive = (ubyte[] data) { return data.length; };\n     * http.perform();\n     * -----\n     */\n    void setPostData(const(void)[] data, string contentType)\n    {\n        // cannot use callback when specifying data directly so it is disabled here.\n        p.curl.clear(CurlOption.readfunction);\n        addRequestHeader(\"Content-Type\", contentType);\n        p.curl.set(CurlOption.postfields, cast(void*) data.ptr);\n        p.curl.set(CurlOption.postfieldsize, data.length);\n        if (method == Method.undefined)\n            method = Method.post;\n    }\n\n    @system unittest\n    {\n        import std.algorithm.searching : canFind;\n\n        testServer.handle((s) {\n            auto req = s.recvReq!ubyte;\n            assert(req.hdrs.canFind(\"POST /path\"));\n            assert(req.bdy.canFind(cast(ubyte[])[0, 1, 2, 3, 4]));\n            assert(req.bdy.canFind(cast(ubyte[])[253, 254, 255]));\n            s.send(httpOK(cast(ubyte[])[17, 27, 35, 41]));\n        });\n        auto data = new ubyte[](256);\n        foreach (i, ref ub; data)\n            ub = cast(ubyte) i;\n\n        auto http = HTTP(testServer.addr~\"/path\");\n        http.postData = data;\n        ubyte[] res;\n        http.onReceive = (data) { res ~= data; return data.length; };\n        http.perform();\n        assert(res == cast(ubyte[])[17, 27, 35, 41]);\n    }\n\n    /**\n      * Set the event handler that receives incoming headers.\n      *\n      * The callback will receive a header field key, value as parameter. The\n      * `const(char)[]` arrays are not valid after the delegate has returned.\n      *\n      * Example:\n      * ----\n      * import std.net.curl, std.stdio;\n      * auto http = HTTP(\"dlang.org\");\n      * http.onReceive = (ubyte[] data) { writeln(to!(const(char)[])(data)); return data.length; };\n      * http.onReceiveHeader = (in char[] key, in char[] value) { writeln(key, \" = \", value); };\n      * http.perform();\n      * ----\n      */\n    @property void onReceiveHeader(void delegate(in char[] key,\n                                                 in char[] value) callback)\n    {\n        p.onReceiveHeader = callback;\n    }\n\n    /**\n       Callback for each received StatusLine.\n\n       Notice that several callbacks can be done for each call to\n       `perform()` due to redirections.\n\n       See_Also: $(LREF StatusLine)\n     */\n    @property void onReceiveStatusLine(void delegate(StatusLine) callback)\n    {\n        p.onReceiveStatusLine = callback;\n    }\n\n    /**\n       The content length in bytes when using request that has content\n       e.g. POST/PUT and not using chunked transfer. Is set as the\n       \"Content-Length\" header.  Set to ulong.max to reset to chunked transfer.\n    */\n    @property void contentLength(ulong len)\n    {\n        import std.conv : to;\n\n        CurlOption lenOpt;\n\n        // Force post if necessary\n        if (p.method != Method.put && p.method != Method.post &&\n            p.method != Method.patch)\n            p.method = Method.post;\n\n        if (p.method == Method.post || p.method == Method.patch)\n            lenOpt = CurlOption.postfieldsize_large;\n        else\n            lenOpt = CurlOption.infilesize_large;\n\n        if (size_t.max != ulong.max && len == size_t.max)\n            len = ulong.max; // check size_t.max for backwards compat, turn into error\n\n        if (len == ulong.max)\n        {\n            // HTTP 1.1 supports requests with no length header set.\n            addRequestHeader(\"Transfer-Encoding\", \"chunked\");\n            addRequestHeader(\"Expect\", \"100-continue\");\n        }\n        else\n        {\n            p.curl.set(lenOpt, to!curl_off_t(len));\n        }\n    }\n\n    /**\n       Authentication method as specified in $(LREF AuthMethod).\n    */\n    @property void authenticationMethod(AuthMethod authMethod)\n    {\n        p.curl.set(CurlOption.httpauth, cast(long) authMethod);\n    }\n\n    /**\n       Set max allowed redirections using the location header.\n       uint.max for infinite.\n    */\n    @property void maxRedirects(uint maxRedirs)\n    {\n        if (maxRedirs == uint.max)\n        {\n            // Disable\n            p.curl.set(CurlOption.followlocation, 0);\n        }\n        else\n        {\n            p.curl.set(CurlOption.followlocation, 1);\n            p.curl.set(CurlOption.maxredirs, maxRedirs);\n        }\n    }\n\n    /** <a name=\"HTTP.Method\"/>The standard HTTP methods :\n     *  $(HTTP www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1, _RFC2616 Section 5.1.1)\n     */\n    enum Method\n    {\n        undefined,\n        head, ///\n        get,  ///\n        post, ///\n        put,  ///\n        del,  ///\n        options, ///\n        trace,   ///\n        connect,  ///\n        patch, ///\n    }\n\n    /**\n       HTTP status line ie. the first line returned in an HTTP response.\n\n       If authentication or redirections are done then the status will be for\n       the last response received.\n    */\n    struct StatusLine\n    {\n        ushort majorVersion; /// Major HTTP version ie. 1 in HTTP/1.0.\n        ushort minorVersion; /// Minor HTTP version ie. 0 in HTTP/1.0.\n        ushort code;         /// HTTP status line code e.g. 200.\n        string reason;       /// HTTP status line reason string.\n\n        /// Reset this status line\n        @safe void reset()\n        {\n            majorVersion = 0;\n            minorVersion = 0;\n            code = 0;\n            reason = \"\";\n        }\n\n        ///\n        string toString() const\n        {\n            import std.format : format;\n            return format(\"%s %s (%s.%s)\",\n                          code, reason, majorVersion, minorVersion);\n        }\n    }\n\n} // HTTP\n\n@system unittest // charset/Charset/CHARSET/...\n{\n    import etc.c.curl;\n\n    static foreach (c; [\"charset\", \"Charset\", \"CHARSET\", \"CharSet\", \"charSet\",\n        \"ChArSeT\", \"cHaRsEt\"])\n    {{\n        testServer.handle((s) {\n            s.send(\"HTTP/1.1 200 OK\\r\\n\"~\n                \"Content-Length: 0\\r\\n\"~\n                \"Content-Type: text/plain; \" ~ c ~ \"=foo\\r\\n\" ~\n                \"\\r\\n\");\n        });\n\n        auto http = HTTP(testServer.addr);\n        http.perform();\n        assert(http.p.charset == \"foo\");\n\n        // Bugzilla 16736\n        double val;\n        CurlCode code;\n\n        code = http.getTiming(CurlInfo.total_time, val);\n        assert(code == CurlError.ok);\n        code = http.getTiming(CurlInfo.namelookup_time, val);\n        assert(code == CurlError.ok);\n        code = http.getTiming(CurlInfo.connect_time, val);\n        assert(code == CurlError.ok);\n        code = http.getTiming(CurlInfo.pretransfer_time, val);\n        assert(code == CurlError.ok);\n        code = http.getTiming(CurlInfo.starttransfer_time, val);\n        assert(code == CurlError.ok);\n        code = http.getTiming(CurlInfo.redirect_time, val);\n        assert(code == CurlError.ok);\n        code = http.getTiming(CurlInfo.appconnect_time, val);\n        assert(code == CurlError.ok);\n    }}\n}\n\n/**\n   FTP client functionality.\n\n   See_Also: $(HTTP tools.ietf.org/html/rfc959, RFC959)\n*/\nstruct FTP\n{\n\n    mixin Protocol;\n\n    import std.typecons : RefCounted;\n    import etc.c.curl : CurlError, CurlInfo, curl_off_t, curl_slist;\n\n    private struct Impl\n    {\n        ~this()\n        {\n            if (commands !is null)\n                Curl.curl.slist_free_all(commands);\n            if (curl.handle !is null) // work around RefCounted/emplace bug\n                curl.shutdown();\n        }\n        curl_slist* commands;\n        Curl curl;\n        string encoding;\n    }\n\n    private RefCounted!Impl p;\n\n    /**\n       FTP access to the specified url.\n    */\n    static FTP opCall(const(char)[] url)\n    {\n        FTP ftp;\n        ftp.initialize();\n        ftp.url = url;\n        return ftp;\n    }\n\n    ///\n    static FTP opCall()\n    {\n        FTP ftp;\n        ftp.initialize();\n        return ftp;\n    }\n\n    ///\n    FTP dup()\n    {\n        FTP copy = FTP();\n        copy.initialize();\n        copy.p.encoding = p.encoding;\n        copy.p.curl = p.curl.dup();\n        curl_slist* cur = p.commands;\n        curl_slist* newlist = null;\n        while (cur)\n        {\n            newlist = Curl.curl.slist_append(newlist, cur.data);\n            cur = cur.next;\n        }\n        copy.p.commands = newlist;\n        copy.p.curl.set(CurlOption.postquote, copy.p.commands);\n        copy.dataTimeout = _defaultDataTimeout;\n        return copy;\n    }\n\n    private void initialize()\n    {\n        p.curl.initialize();\n        p.encoding = \"ISO-8859-1\";\n        dataTimeout = _defaultDataTimeout;\n    }\n\n    /**\n       Performs the ftp request as it has been configured.\n\n       After a FTP client has been setup and possibly assigned callbacks the $(D\n       perform()) method will start performing the actual communication with the\n       server.\n\n       Params:\n       throwOnError = whether to throw an exception or return a CurlCode on error\n    */\n    CurlCode perform(ThrowOnError throwOnError = Yes.throwOnError)\n    {\n        return p.curl.perform(throwOnError);\n    }\n\n    /// The URL to specify the location of the resource.\n    @property void url(const(char)[] url)\n    {\n        import std.algorithm.searching : startsWith;\n        import std.uni : toLower;\n\n        if (!startsWith(url.toLower(), \"ftp://\", \"ftps://\"))\n            url = \"ftp://\" ~ url;\n        p.curl.set(CurlOption.url, url);\n    }\n\n    // This is a workaround for mixed in content not having its\n    // docs mixed in.\n    version (StdDdoc)\n    {\n        static import etc.c.curl;\n\n        /// Value to return from `onSend`/`onReceive` delegates in order to\n        /// pause a request\n        alias requestPause = CurlReadFunc.pause;\n\n        /// Value to return from onSend delegate in order to abort a request\n        alias requestAbort = CurlReadFunc.abort;\n\n        /**\n           True if the instance is stopped. A stopped instance is not usable.\n        */\n        @property bool isStopped();\n\n        /// Stop and invalidate this instance.\n        void shutdown();\n\n        /** Set verbose.\n            This will print request information to stderr.\n        */\n        @property void verbose(bool on);\n\n        // Connection settings\n\n        /// Set timeout for activity on connection.\n        @property void dataTimeout(Duration d);\n\n        /** Set maximum time an operation is allowed to take.\n            This includes dns resolution, connecting, data transfer, etc.\n          */\n        @property void operationTimeout(Duration d);\n\n        /// Set timeout for connecting.\n        @property void connectTimeout(Duration d);\n\n        // Network settings\n\n        /** Proxy\n         *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy)\n         */\n        @property void proxy(const(char)[] host);\n\n        /** Proxy port\n         *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXYPORT, _proxy_port)\n         */\n        @property void proxyPort(ushort port);\n\n        /// Type of proxy\n        alias CurlProxy = etc.c.curl.CurlProxy;\n\n        /** Proxy type\n         *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy_type)\n         */\n        @property void proxyType(CurlProxy type);\n\n        /// DNS lookup timeout.\n        @property void dnsTimeout(Duration d);\n\n        /**\n         * The network interface to use in form of the the IP of the interface.\n         *\n         * Example:\n         * ----\n         * theprotocol.netInterface = \"192.168.1.32\";\n         * theprotocol.netInterface = [ 192, 168, 1, 32 ];\n         * ----\n         *\n         * See: $(REF InternetAddress, std,socket)\n         */\n        @property void netInterface(const(char)[] i);\n\n        /// ditto\n        @property void netInterface(const(ubyte)[4] i);\n\n        /// ditto\n        @property void netInterface(InternetAddress i);\n\n        /**\n           Set the local outgoing port to use.\n           Params:\n           port = the first outgoing port number to try and use\n        */\n        @property void localPort(ushort port);\n\n        /**\n           Set the local outgoing port range to use.\n           This can be used together with the localPort property.\n           Params:\n           range = if the first port is occupied then try this many\n           port number forwards\n        */\n        @property void localPortRange(ushort range);\n\n        /** Set the tcp no-delay socket option on or off.\n            See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTTCPNODELAY, nodelay)\n        */\n        @property void tcpNoDelay(bool on);\n\n        // Authentication settings\n\n        /**\n           Set the user name, password and optionally domain for authentication\n           purposes.\n\n           Some protocols may need authentication in some cases. Use this\n           function to provide credentials.\n\n           Params:\n           username = the username\n           password = the password\n           domain = used for NTLM authentication only and is set to the NTLM domain\n           name\n        */\n        void setAuthentication(const(char)[] username, const(char)[] password,\n                               const(char)[] domain = \"\");\n\n        /**\n           Set the user name and password for proxy authentication.\n\n           Params:\n           username = the username\n           password = the password\n        */\n        void setProxyAuthentication(const(char)[] username, const(char)[] password);\n\n        /**\n         * The event handler that gets called when data is needed for sending. The\n         * length of the `void[]` specifies the maximum number of bytes that can\n         * be sent.\n         *\n         * Returns:\n         * The callback returns the number of elements in the buffer that have been\n         * filled and are ready to send.\n         * The special value `.abortRequest` can be returned in order to abort the\n         * current request.\n         * The special value `.pauseRequest` can be returned in order to pause the\n         * current request.\n         *\n         */\n        @property void onSend(size_t delegate(void[]) callback);\n\n        /**\n         * The event handler that receives incoming data. Be sure to copy the\n         * incoming ubyte[] since it is not guaranteed to be valid after the\n         * callback returns.\n         *\n         * Returns:\n         * The callback returns the incoming bytes read. If not the entire array is\n         * the request will abort.\n         * The special value .pauseRequest can be returned in order to pause the\n         * current request.\n         *\n         */\n        @property void onReceive(size_t delegate(ubyte[]) callback);\n\n        /**\n         * The event handler that gets called to inform of upload/download progress.\n         *\n         * Callback_parameters:\n         * $(CALLBACK_PARAMS)\n         *\n         * Callback_returns:\n         * Return 0 from the callback to signal success, return non-zero to\n         * abort transfer.\n         */\n        @property void onProgress(int delegate(size_t dlTotal, size_t dlNow,\n                                               size_t ulTotal, size_t ulNow) callback);\n    }\n\n    /** Clear all commands send to ftp server.\n    */\n    void clearCommands()\n    {\n        if (p.commands !is null)\n            Curl.curl.slist_free_all(p.commands);\n        p.commands = null;\n        p.curl.clear(CurlOption.postquote);\n    }\n\n    /** Add a command to send to ftp server.\n     *\n     * There is no remove command functionality. Do a $(LREF clearCommands) and\n     * set the needed commands instead.\n     *\n     * Example:\n     * ---\n     * import std.net.curl;\n     * auto client = FTP();\n     * client.addCommand(\"RNFR my_file.txt\");\n     * client.addCommand(\"RNTO my_renamed_file.txt\");\n     * upload(\"my_file.txt\", \"ftp.digitalmars.com\", client);\n     * ---\n     */\n    void addCommand(const(char)[] command)\n    {\n        import std.internal.cstring : tempCString;\n        p.commands = Curl.curl.slist_append(p.commands,\n                                            command.tempCString().buffPtr);\n        p.curl.set(CurlOption.postquote, p.commands);\n    }\n\n    /// Connection encoding. Defaults to ISO-8859-1.\n    @property void encoding(string name)\n    {\n        p.encoding = name;\n    }\n\n    /// ditto\n    @property string encoding()\n    {\n        return p.encoding;\n    }\n\n    /**\n       The content length in bytes of the ftp data.\n    */\n    @property void contentLength(ulong len)\n    {\n        import std.conv : to;\n        p.curl.set(CurlOption.infilesize_large, to!curl_off_t(len));\n    }\n\n    /**\n     * Get various timings defined in $(REF CurlInfo, etc, c, curl).\n     * The value is usable only if the return value is equal to `etc.c.curl.CurlError.ok`.\n     *\n     * Params:\n     *      timing = one of the timings defined in $(REF CurlInfo, etc, c, curl).\n     *               The values are:\n     *               `etc.c.curl.CurlInfo.namelookup_time`,\n     *               `etc.c.curl.CurlInfo.connect_time`,\n     *               `etc.c.curl.CurlInfo.pretransfer_time`,\n     *               `etc.c.curl.CurlInfo.starttransfer_time`,\n     *               `etc.c.curl.CurlInfo.redirect_time`,\n     *               `etc.c.curl.CurlInfo.appconnect_time`,\n     *               `etc.c.curl.CurlInfo.total_time`.\n     *      val    = the actual value of the inquired timing.\n     *\n     * Returns:\n     *      The return code of the operation. The value stored in val\n     *      should be used only if the return value is `etc.c.curl.CurlInfo.ok`.\n     *\n     * Example:\n     * ---\n     * import std.net.curl;\n     * import etc.c.curl : CurlError, CurlInfo;\n     *\n     * auto client = FTP();\n     * client.addCommand(\"RNFR my_file.txt\");\n     * client.addCommand(\"RNTO my_renamed_file.txt\");\n     * upload(\"my_file.txt\", \"ftp.digitalmars.com\", client);\n     *\n     * double val;\n     * CurlCode code;\n     *\n     * code = client.getTiming(CurlInfo.namelookup_time, val);\n     * assert(code == CurlError.ok);\n     * ---\n     */\n    CurlCode getTiming(CurlInfo timing, ref double val)\n    {\n        return p.curl.getTiming(timing, val);\n    }\n\n    @system unittest\n    {\n        auto client = FTP();\n\n        double val;\n        CurlCode code;\n\n        code = client.getTiming(CurlInfo.total_time, val);\n        assert(code == CurlError.ok);\n        code = client.getTiming(CurlInfo.namelookup_time, val);\n        assert(code == CurlError.ok);\n        code = client.getTiming(CurlInfo.connect_time, val);\n        assert(code == CurlError.ok);\n        code = client.getTiming(CurlInfo.pretransfer_time, val);\n        assert(code == CurlError.ok);\n        code = client.getTiming(CurlInfo.starttransfer_time, val);\n        assert(code == CurlError.ok);\n        code = client.getTiming(CurlInfo.redirect_time, val);\n        assert(code == CurlError.ok);\n        code = client.getTiming(CurlInfo.appconnect_time, val);\n        assert(code == CurlError.ok);\n    }\n}\n\n/**\n  * Basic SMTP protocol support.\n  *\n  * Example:\n  * ---\n  * import std.net.curl;\n  *\n  * // Send an email with SMTPS\n  * auto smtp = SMTP(\"smtps://smtp.gmail.com\");\n  * smtp.setAuthentication(\"from.addr@gmail.com\", \"password\");\n  * smtp.mailTo = [\"<to.addr@gmail.com>\"];\n  * smtp.mailFrom = \"<from.addr@gmail.com>\";\n  * smtp.message = \"Example Message\";\n  * smtp.perform();\n  * ---\n  *\n  * See_Also: $(HTTP www.ietf.org/rfc/rfc2821.txt, RFC2821)\n  */\nstruct SMTP\n{\n    mixin Protocol;\n    import std.typecons : RefCounted;\n    import etc.c.curl : CurlUseSSL, curl_slist;\n\n    private struct Impl\n    {\n        ~this()\n        {\n            if (curl.handle !is null) // work around RefCounted/emplace bug\n                curl.shutdown();\n        }\n        Curl curl;\n\n        @property void message(string msg)\n        {\n            import std.algorithm.comparison : min;\n\n            auto _message = msg;\n            /**\n                This delegate reads the message text and copies it.\n            */\n            curl.onSend = delegate size_t(void[] data)\n            {\n                if (!msg.length) return 0;\n                size_t to_copy = min(data.length, _message.length);\n                data[0 .. to_copy] = (cast(void[])_message)[0 .. to_copy];\n                _message = _message[to_copy..$];\n                return to_copy;\n            };\n        }\n    }\n\n    private RefCounted!Impl p;\n\n    /**\n        Sets to the URL of the SMTP server.\n    */\n    static SMTP opCall(const(char)[] url)\n    {\n        SMTP smtp;\n        smtp.initialize();\n        smtp.url = url;\n        return smtp;\n    }\n\n    ///\n    static SMTP opCall()\n    {\n        SMTP smtp;\n        smtp.initialize();\n        return smtp;\n    }\n\n    /+ TODO: The other structs have this function.\n    SMTP dup()\n    {\n        SMTP copy = SMTP();\n        copy.initialize();\n        copy.p.encoding = p.encoding;\n        copy.p.curl = p.curl.dup();\n        curl_slist* cur = p.commands;\n        curl_slist* newlist = null;\n        while (cur)\n        {\n            newlist = Curl.curl.slist_append(newlist, cur.data);\n            cur = cur.next;\n        }\n        copy.p.commands = newlist;\n        copy.p.curl.set(CurlOption.postquote, copy.p.commands);\n        copy.dataTimeout = _defaultDataTimeout;\n        return copy;\n    }\n    +/\n\n    /**\n        Performs the request as configured.\n        Params:\n        throwOnError = whether to throw an exception or return a CurlCode on error\n    */\n    CurlCode perform(ThrowOnError throwOnError = Yes.throwOnError)\n    {\n        return p.curl.perform(throwOnError);\n    }\n\n    /// The URL to specify the location of the resource.\n    @property void url(const(char)[] url)\n    {\n        import std.algorithm.searching : startsWith;\n        import std.exception : enforce;\n        import std.uni : toLower;\n\n        auto lowered = url.toLower();\n\n        if (lowered.startsWith(\"smtps://\"))\n        {\n            p.curl.set(CurlOption.use_ssl, CurlUseSSL.all);\n        }\n        else\n        {\n            enforce!CurlException(lowered.startsWith(\"smtp://\"),\n                                    \"The url must be for the smtp protocol.\");\n        }\n        p.curl.set(CurlOption.url, url);\n    }\n\n    private void initialize()\n    {\n        p.curl.initialize();\n        p.curl.set(CurlOption.upload, 1L);\n        dataTimeout = _defaultDataTimeout;\n        verifyPeer = true;\n        verifyHost = true;\n    }\n\n    // This is a workaround for mixed in content not having its\n    // docs mixed in.\n    version (StdDdoc)\n    {\n        static import etc.c.curl;\n\n        /// Value to return from `onSend`/`onReceive` delegates in order to\n        /// pause a request\n        alias requestPause = CurlReadFunc.pause;\n\n        /// Value to return from onSend delegate in order to abort a request\n        alias requestAbort = CurlReadFunc.abort;\n\n        /**\n           True if the instance is stopped. A stopped instance is not usable.\n        */\n        @property bool isStopped();\n\n        /// Stop and invalidate this instance.\n        void shutdown();\n\n        /** Set verbose.\n            This will print request information to stderr.\n        */\n        @property void verbose(bool on);\n\n        // Connection settings\n\n        /// Set timeout for activity on connection.\n        @property void dataTimeout(Duration d);\n\n        /** Set maximum time an operation is allowed to take.\n            This includes dns resolution, connecting, data transfer, etc.\n          */\n        @property void operationTimeout(Duration d);\n\n        /// Set timeout for connecting.\n        @property void connectTimeout(Duration d);\n\n        // Network settings\n\n        /** Proxy\n         *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy)\n         */\n        @property void proxy(const(char)[] host);\n\n        /** Proxy port\n         *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXYPORT, _proxy_port)\n         */\n        @property void proxyPort(ushort port);\n\n        /// Type of proxy\n        alias CurlProxy = etc.c.curl.CurlProxy;\n\n        /** Proxy type\n         *  See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy_type)\n         */\n        @property void proxyType(CurlProxy type);\n\n        /// DNS lookup timeout.\n        @property void dnsTimeout(Duration d);\n\n        /**\n         * The network interface to use in form of the the IP of the interface.\n         *\n         * Example:\n         * ----\n         * theprotocol.netInterface = \"192.168.1.32\";\n         * theprotocol.netInterface = [ 192, 168, 1, 32 ];\n         * ----\n         *\n         * See: $(REF InternetAddress, std,socket)\n         */\n        @property void netInterface(const(char)[] i);\n\n        /// ditto\n        @property void netInterface(const(ubyte)[4] i);\n\n        /// ditto\n        @property void netInterface(InternetAddress i);\n\n        /**\n           Set the local outgoing port to use.\n           Params:\n           port = the first outgoing port number to try and use\n        */\n        @property void localPort(ushort port);\n\n        /**\n           Set the local outgoing port range to use.\n           This can be used together with the localPort property.\n           Params:\n           range = if the first port is occupied then try this many\n           port number forwards\n        */\n        @property void localPortRange(ushort range);\n\n        /** Set the tcp no-delay socket option on or off.\n            See: $(HTTP curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTTCPNODELAY, nodelay)\n        */\n        @property void tcpNoDelay(bool on);\n\n        // Authentication settings\n\n        /**\n           Set the user name, password and optionally domain for authentication\n           purposes.\n\n           Some protocols may need authentication in some cases. Use this\n           function to provide credentials.\n\n           Params:\n           username = the username\n           password = the password\n           domain = used for NTLM authentication only and is set to the NTLM domain\n           name\n        */\n        void setAuthentication(const(char)[] username, const(char)[] password,\n                               const(char)[] domain = \"\");\n\n        /**\n           Set the user name and password for proxy authentication.\n\n           Params:\n           username = the username\n           password = the password\n        */\n        void setProxyAuthentication(const(char)[] username, const(char)[] password);\n\n        /**\n         * The event handler that gets called when data is needed for sending. The\n         * length of the `void[]` specifies the maximum number of bytes that can\n         * be sent.\n         *\n         * Returns:\n         * The callback returns the number of elements in the buffer that have been\n         * filled and are ready to send.\n         * The special value `.abortRequest` can be returned in order to abort the\n         * current request.\n         * The special value `.pauseRequest` can be returned in order to pause the\n         * current request.\n         */\n        @property void onSend(size_t delegate(void[]) callback);\n\n        /**\n         * The event handler that receives incoming data. Be sure to copy the\n         * incoming ubyte[] since it is not guaranteed to be valid after the\n         * callback returns.\n         *\n         * Returns:\n         * The callback returns the incoming bytes read. If not the entire array is\n         * the request will abort.\n         * The special value .pauseRequest can be returned in order to pause the\n         * current request.\n         */\n        @property void onReceive(size_t delegate(ubyte[]) callback);\n\n        /**\n         * The event handler that gets called to inform of upload/download progress.\n         *\n         * Callback_parameters:\n         * $(CALLBACK_PARAMS)\n         *\n         * Callback_returns:\n         * Return 0 from the callback to signal success, return non-zero to\n         * abort transfer.\n         */\n        @property void onProgress(int delegate(size_t dlTotal, size_t dlNow,\n                                               size_t ulTotal, size_t ulNow) callback);\n    }\n\n    /**\n        Setter for the sender's email address.\n    */\n    @property void mailFrom()(const(char)[] sender)\n    {\n        assert(!sender.empty, \"Sender must not be empty\");\n        p.curl.set(CurlOption.mail_from, sender);\n    }\n\n    /**\n        Setter for the recipient email addresses.\n    */\n    void mailTo()(const(char)[][] recipients...)\n    {\n        import std.internal.cstring : tempCString;\n        assert(!recipients.empty, \"Recipient must not be empty\");\n        curl_slist* recipients_list = null;\n        foreach (recipient; recipients)\n        {\n            recipients_list =\n                Curl.curl.slist_append(recipients_list,\n                                  recipient.tempCString().buffPtr);\n        }\n        p.curl.set(CurlOption.mail_rcpt, recipients_list);\n    }\n\n    /**\n        Sets the message body text.\n    */\n\n    @property void message(string msg)\n    {\n        p.message = msg;\n    }\n}\n\n@system unittest\n{\n    import std.net.curl;\n\n    // Send an email with SMTPS\n    auto smtp = SMTP(\"smtps://smtp.gmail.com\");\n    smtp.setAuthentication(\"from.addr@gmail.com\", \"password\");\n    smtp.mailTo = [\"<to.addr@gmail.com>\"];\n    smtp.mailFrom = \"<from.addr@gmail.com>\";\n    smtp.message = \"Example Message\";\n    //smtp.perform();\n}\n\n\n/++\n    Exception thrown on errors in std.net.curl functions.\n+/\nclass CurlException : Exception\n{\n    /++\n        Params:\n            msg  = The message for the exception.\n            file = The file where the exception occurred.\n            line = The line number where the exception occurred.\n            next = The previous exception in the chain of exceptions, if any.\n      +/\n    @safe pure nothrow\n    this(string msg,\n         string file = __FILE__,\n         size_t line = __LINE__,\n         Throwable next = null)\n    {\n        super(msg, file, line, next);\n    }\n}\n\n/++\n    Exception thrown on timeout errors in std.net.curl functions.\n+/\nclass CurlTimeoutException : CurlException\n{\n    /++\n        Params:\n            msg  = The message for the exception.\n            file = The file where the exception occurred.\n            line = The line number where the exception occurred.\n            next = The previous exception in the chain of exceptions, if any.\n      +/\n    @safe pure nothrow\n    this(string msg,\n         string file = __FILE__,\n         size_t line = __LINE__,\n         Throwable next = null)\n    {\n        super(msg, file, line, next);\n    }\n}\n\n/++\n    Exception thrown on HTTP request failures, e.g. 404 Not Found.\n+/\nclass HTTPStatusException : CurlException\n{\n    /++\n        Params:\n            status = The HTTP status code.\n            msg  = The message for the exception.\n            file = The file where the exception occurred.\n            line = The line number where the exception occurred.\n            next = The previous exception in the chain of exceptions, if any.\n      +/\n    @safe pure nothrow\n    this(int status,\n         string msg,\n         string file = __FILE__,\n         size_t line = __LINE__,\n         Throwable next = null)\n    {\n        super(msg, file, line, next);\n        this.status = status;\n    }\n\n    immutable int status; /// The HTTP status code\n}\n\n/// Equal to $(REF CURLcode, etc,c,curl)\nalias CurlCode = CURLcode;\n\n/// Flag to specify whether or not an exception is thrown on error.\nalias ThrowOnError = Flag!\"throwOnError\";\n\nprivate struct CurlAPI\n{\n    import etc.c.curl : CurlGlobal;\n    static struct API\n    {\n    import etc.c.curl : curl_version_info, curl_version_info_data,\n                        CURL, CURLcode, CURLINFO, CURLoption, CURLversion, curl_slist;\n    extern(C):\n        import core.stdc.config : c_long;\n        CURLcode function(c_long flags) global_init;\n        void function() global_cleanup;\n        curl_version_info_data * function(CURLversion) version_info;\n        CURL* function() easy_init;\n        CURLcode function(CURL *curl, CURLoption option,...) easy_setopt;\n        CURLcode function(CURL *curl) easy_perform;\n        CURLcode function(CURL *curl, CURLINFO info,...) easy_getinfo;\n        CURL* function(CURL *curl) easy_duphandle;\n        char* function(CURLcode) easy_strerror;\n        CURLcode function(CURL *handle, int bitmask) easy_pause;\n        void function(CURL *curl) easy_cleanup;\n        curl_slist* function(curl_slist *, char *) slist_append;\n        void function(curl_slist *) slist_free_all;\n    }\n    __gshared API _api;\n    __gshared void* _handle;\n\n    static ref API instance() @property\n    {\n        import std.concurrency : initOnce;\n        initOnce!_handle(loadAPI());\n        return _api;\n    }\n\n    static void* loadAPI()\n    {\n        import std.exception : enforce;\n\n        version (Posix)\n        {\n            import core.sys.posix.dlfcn : dlsym, dlopen, dlclose, RTLD_LAZY;\n            alias loadSym = dlsym;\n        }\n        else version (Windows)\n        {\n            import core.sys.windows.windows : GetProcAddress, GetModuleHandleA,\n                LoadLibraryA;\n            alias loadSym = GetProcAddress;\n        }\n        else\n            static assert(0, \"unimplemented\");\n\n        void* handle;\n        version (Posix)\n            handle = dlopen(null, RTLD_LAZY);\n        else version (Windows)\n            handle = GetModuleHandleA(null);\n        assert(handle !is null);\n\n        // try to load curl from the executable to allow static linking\n        if (loadSym(handle, \"curl_global_init\") is null)\n        {\n            import std.format : format;\n            version (Posix)\n                dlclose(handle);\n\n            version (OSX)\n                static immutable names = [\"libcurl.4.dylib\"];\n            else version (Posix)\n            {\n                static immutable names = [\"libcurl.so\", \"libcurl.so.4\",\n                \"libcurl-gnutls.so.4\", \"libcurl-nss.so.4\", \"libcurl.so.3\"];\n            }\n            else version (Windows)\n                static immutable names = [\"libcurl.dll\", \"curl.dll\"];\n\n            foreach (name; names)\n            {\n                version (Posix)\n                    handle = dlopen(name.ptr, RTLD_LAZY);\n                else version (Windows)\n                    handle = LoadLibraryA(name.ptr);\n                if (handle !is null) break;\n            }\n\n            enforce!CurlException(handle !is null, \"Failed to load curl, tried %(%s, %).\".format(names));\n        }\n\n        foreach (i, FP; typeof(API.tupleof))\n        {\n            enum name = __traits(identifier, _api.tupleof[i]);\n            auto p = enforce!CurlException(loadSym(handle, \"curl_\"~name),\n                                           \"Couldn't load curl_\"~name~\" from libcurl.\");\n            _api.tupleof[i] = cast(FP) p;\n        }\n\n        enforce!CurlException(!_api.global_init(CurlGlobal.all),\n                              \"Failed to initialize libcurl\");\n\n        static extern(C) void cleanup()\n        {\n            if (_handle is null) return;\n            _api.global_cleanup();\n            version (Posix)\n            {\n                import core.sys.posix.dlfcn : dlclose;\n                dlclose(_handle);\n            }\n            else version (Windows)\n            {\n                import core.sys.windows.windows : FreeLibrary;\n                FreeLibrary(_handle);\n            }\n            else\n                static assert(0, \"unimplemented\");\n            _api = API.init;\n            _handle = null;\n        }\n\n        import core.stdc.stdlib : atexit;\n        atexit(&cleanup);\n\n        return handle;\n    }\n}\n\n/**\n  Wrapper to provide a better interface to libcurl than using the plain C API.\n  It is recommended to use the `HTTP`/`FTP` etc. structs instead unless\n  raw access to libcurl is needed.\n\n  Warning: This struct uses interior pointers for callbacks. Only allocate it\n  on the stack if you never move or copy it. This also means passing by reference\n  when passing Curl to other functions. Otherwise always allocate on\n  the heap.\n*/\nstruct Curl\n{\n    import etc.c.curl : CURL, CurlError, CurlPause, CurlSeek, CurlSeekPos,\n                        curl_socket_t, CurlSockType,\n                        CurlReadFunc, CurlInfo, curlsocktype, curl_off_t,\n                        LIBCURL_VERSION_MAJOR, LIBCURL_VERSION_MINOR, LIBCURL_VERSION_PATCH;\n\n    alias OutData = void[];\n    alias InData = ubyte[];\n    private bool _stopped;\n\n    private static auto ref curl() @property { return CurlAPI.instance; }\n\n    // A handle should not be used by two threads simultaneously\n    private CURL* handle;\n\n    // May also return `CURL_READFUNC_ABORT` or `CURL_READFUNC_PAUSE`\n    private size_t delegate(OutData) _onSend;\n    private size_t delegate(InData) _onReceive;\n    private void delegate(in char[]) _onReceiveHeader;\n    private CurlSeek delegate(long,CurlSeekPos) _onSeek;\n    private int delegate(curl_socket_t,CurlSockType) _onSocketOption;\n    private int delegate(size_t dltotal, size_t dlnow,\n                         size_t ultotal, size_t ulnow) _onProgress;\n\n    alias requestPause = CurlReadFunc.pause;\n    alias requestAbort = CurlReadFunc.abort;\n\n    /**\n       Initialize the instance by creating a working curl handle.\n    */\n    void initialize()\n    {\n        import std.exception : enforce;\n        enforce!CurlException(!handle, \"Curl instance already initialized\");\n        handle = curl.easy_init();\n        enforce!CurlException(handle, \"Curl instance couldn't be initialized\");\n        _stopped = false;\n        set(CurlOption.nosignal, 1);\n    }\n\n    ///\n    @property bool stopped() const\n    {\n        return _stopped;\n    }\n\n    /**\n       Duplicate this handle.\n\n       The new handle will have all options set as the one it was duplicated\n       from. An exception to this is that all options that cannot be shared\n       across threads are reset thereby making it safe to use the duplicate\n       in a new thread.\n    */\n    Curl dup()\n    {\n        import std.meta : AliasSeq;\n        Curl copy;\n        copy.handle = curl.easy_duphandle(handle);\n        copy._stopped = false;\n\n        with (CurlOption) {\n            auto tt = AliasSeq!(file, writefunction, writeheader,\n                headerfunction, infile, readfunction, ioctldata, ioctlfunction,\n                seekdata, seekfunction, sockoptdata, sockoptfunction,\n                opensocketdata, opensocketfunction, progressdata,\n                progressfunction, debugdata, debugfunction, interleavedata,\n                interleavefunction, chunk_data, chunk_bgn_function,\n                chunk_end_function, fnmatch_data, fnmatch_function, cookiejar, postfields);\n\n            foreach (option; tt)\n                copy.clear(option);\n        }\n\n        // The options are only supported by libcurl when it has been built\n        // against certain versions of OpenSSL - if your libcurl uses an old\n        // OpenSSL, or uses an entirely different SSL engine, attempting to\n        // clear these normally will raise an exception\n        copy.clearIfSupported(CurlOption.ssl_ctx_function);\n        copy.clearIfSupported(CurlOption.ssh_keydata);\n\n        // Enable for curl version > 7.21.7\n        static if (LIBCURL_VERSION_MAJOR >= 7 &&\n                   LIBCURL_VERSION_MINOR >= 21 &&\n                   LIBCURL_VERSION_PATCH >= 7)\n        {\n            copy.clear(CurlOption.closesocketdata);\n            copy.clear(CurlOption.closesocketfunction);\n        }\n\n        copy.set(CurlOption.nosignal, 1);\n\n        // copy.clear(CurlOption.ssl_ctx_data); Let ssl function be shared\n        // copy.clear(CurlOption.ssh_keyfunction); Let key function be shared\n\n        /*\n          Allow sharing of conv functions\n          copy.clear(CurlOption.conv_to_network_function);\n          copy.clear(CurlOption.conv_from_network_function);\n          copy.clear(CurlOption.conv_from_utf8_function);\n        */\n\n        return copy;\n    }\n\n    private void _check(CurlCode code)\n    {\n        import std.exception : enforce;\n        enforce!CurlTimeoutException(code != CurlError.operation_timedout,\n                                       errorString(code));\n\n        enforce!CurlException(code == CurlError.ok,\n                                errorString(code));\n    }\n\n    private string errorString(CurlCode code)\n    {\n        import core.stdc.string : strlen;\n        import std.format : format;\n\n        auto msgZ = curl.easy_strerror(code);\n        // doing the following (instead of just using std.conv.to!string) avoids 1 allocation\n        return format(\"%s on handle %s\", msgZ[0 .. strlen(msgZ)], handle);\n    }\n\n    private void throwOnStopped(string message = null)\n    {\n        import std.exception : enforce;\n        auto def = \"Curl instance called after being cleaned up\";\n        enforce!CurlException(!stopped,\n                                message == null ? def : message);\n    }\n\n    /**\n        Stop and invalidate this curl instance.\n        Warning: Do not call this from inside a callback handler e.g. `onReceive`.\n    */\n    void shutdown()\n    {\n        throwOnStopped();\n        _stopped = true;\n        curl.easy_cleanup(this.handle);\n        this.handle = null;\n    }\n\n    /**\n       Pausing and continuing transfers.\n    */\n    void pause(bool sendingPaused, bool receivingPaused)\n    {\n        throwOnStopped();\n        _check(curl.easy_pause(this.handle,\n                               (sendingPaused ? CurlPause.send_cont : CurlPause.send) |\n                               (receivingPaused ? CurlPause.recv_cont : CurlPause.recv)));\n    }\n\n    /**\n       Set a string curl option.\n       Params:\n       option = A $(REF CurlOption, etc,c,curl) as found in the curl documentation\n       value = The string\n    */\n    void set(CurlOption option, const(char)[] value)\n    {\n        import std.internal.cstring : tempCString;\n        throwOnStopped();\n        _check(curl.easy_setopt(this.handle, option, value.tempCString().buffPtr));\n    }\n\n    /**\n       Set a long curl option.\n       Params:\n       option = A $(REF CurlOption, etc,c,curl) as found in the curl documentation\n       value = The long\n    */\n    void set(CurlOption option, long value)\n    {\n        throwOnStopped();\n        _check(curl.easy_setopt(this.handle, option, value));\n    }\n\n    /**\n       Set a void* curl option.\n       Params:\n       option = A $(REF CurlOption, etc,c,curl) as found in the curl documentation\n       value = The pointer\n    */\n    void set(CurlOption option, void* value)\n    {\n        throwOnStopped();\n        _check(curl.easy_setopt(this.handle, option, value));\n    }\n\n    /**\n       Clear a pointer option.\n       Params:\n       option = A $(REF CurlOption, etc,c,curl) as found in the curl documentation\n    */\n    void clear(CurlOption option)\n    {\n        throwOnStopped();\n        _check(curl.easy_setopt(this.handle, option, null));\n    }\n\n    /**\n       Clear a pointer option. Does not raise an exception if the underlying\n       libcurl does not support the option. Use sparingly.\n       Params:\n       option = A $(REF CurlOption, etc,c,curl) as found in the curl documentation\n    */\n    void clearIfSupported(CurlOption option)\n    {\n        throwOnStopped();\n        auto rval = curl.easy_setopt(this.handle, option, null);\n        if (rval != CurlError.unknown_option && rval != CurlError.not_built_in)\n            _check(rval);\n    }\n\n    /**\n       perform the curl request by doing the HTTP,FTP etc. as it has\n       been setup beforehand.\n\n       Params:\n       throwOnError = whether to throw an exception or return a CurlCode on error\n    */\n    CurlCode perform(ThrowOnError throwOnError = Yes.throwOnError)\n    {\n        throwOnStopped();\n        CurlCode code = curl.easy_perform(this.handle);\n        if (throwOnError)\n            _check(code);\n        return code;\n    }\n\n    /**\n       Get the various timings like name lookup time, total time, connect time etc.\n       The timed category is passed through the timing parameter while the timing\n       value is stored at val. The value is usable only if res is equal to\n       `etc.c.curl.CurlError.ok`.\n    */\n    CurlCode getTiming(CurlInfo timing, ref double val)\n    {\n        CurlCode code;\n        code = curl.easy_getinfo(handle, timing, &val);\n        return code;\n    }\n\n    /**\n      * The event handler that receives incoming data.\n      *\n      * Params:\n      * callback = the callback that receives the `ubyte[]` data.\n      * Be sure to copy the incoming data and not store\n      * a slice.\n      *\n      * Returns:\n      * The callback returns the incoming bytes read. If not the entire array is\n      * the request will abort.\n      * The special value HTTP.pauseRequest can be returned in order to pause the\n      * current request.\n      *\n      * Example:\n      * ----\n      * import std.net.curl, std.stdio;\n      * Curl curl;\n      * curl.initialize();\n      * curl.set(CurlOption.url, \"http://dlang.org\");\n      * curl.onReceive = (ubyte[] data) { writeln(\"Got data\", to!(const(char)[])(data)); return data.length;};\n      * curl.perform();\n      * ----\n      */\n    @property void onReceive(size_t delegate(InData) callback)\n    {\n        _onReceive = (InData id)\n        {\n            throwOnStopped(\"Receive callback called on cleaned up Curl instance\");\n            return callback(id);\n        };\n        set(CurlOption.file, cast(void*) &this);\n        set(CurlOption.writefunction, cast(void*) &Curl._receiveCallback);\n    }\n\n    /**\n      * The event handler that receives incoming headers for protocols\n      * that uses headers.\n      *\n      * Params:\n      * callback = the callback that receives the header string.\n      * Make sure the callback copies the incoming params if\n      * it needs to store it because they are references into\n      * the backend and may very likely change.\n      *\n      * Example:\n      * ----\n      * import std.net.curl, std.stdio;\n      * Curl curl;\n      * curl.initialize();\n      * curl.set(CurlOption.url, \"http://dlang.org\");\n      * curl.onReceiveHeader = (in char[] header) { writeln(header); };\n      * curl.perform();\n      * ----\n      */\n    @property void onReceiveHeader(void delegate(in char[]) callback)\n    {\n        _onReceiveHeader = (in char[] od)\n        {\n            throwOnStopped(\"Receive header callback called on \"~\n                           \"cleaned up Curl instance\");\n            callback(od);\n        };\n        set(CurlOption.writeheader, cast(void*) &this);\n        set(CurlOption.headerfunction,\n            cast(void*) &Curl._receiveHeaderCallback);\n    }\n\n    /**\n      * The event handler that gets called when data is needed for sending.\n      *\n      * Params:\n      * callback = the callback that has a `void[]` buffer to be filled\n      *\n      * Returns:\n      * The callback returns the number of elements in the buffer that have been\n      * filled and are ready to send.\n      * The special value `Curl.abortRequest` can be returned in\n      * order to abort the current request.\n      * The special value `Curl.pauseRequest` can be returned in order to\n      * pause the current request.\n      *\n      * Example:\n      * ----\n      * import std.net.curl;\n      * Curl curl;\n      * curl.initialize();\n      * curl.set(CurlOption.url, \"http://dlang.org\");\n      *\n      * string msg = \"Hello world\";\n      * curl.onSend = (void[] data)\n      * {\n      *     auto m = cast(void[]) msg;\n      *     size_t length = m.length > data.length ? data.length : m.length;\n      *     if (length == 0) return 0;\n      *     data[0 .. length] = m[0 .. length];\n      *     msg = msg[length..$];\n      *     return length;\n      * };\n      * curl.perform();\n      * ----\n      */\n    @property void onSend(size_t delegate(OutData) callback)\n    {\n        _onSend = (OutData od)\n        {\n            throwOnStopped(\"Send callback called on cleaned up Curl instance\");\n            return callback(od);\n        };\n        set(CurlOption.infile, cast(void*) &this);\n        set(CurlOption.readfunction, cast(void*) &Curl._sendCallback);\n    }\n\n    /**\n      * The event handler that gets called when the curl backend needs to seek\n      * the data to be sent.\n      *\n      * Params:\n      * callback = the callback that receives a seek offset and a seek position\n      *            $(REF CurlSeekPos, etc,c,curl)\n      *\n      * Returns:\n      * The callback returns the success state of the seeking\n      * $(REF CurlSeek, etc,c,curl)\n      *\n      * Example:\n      * ----\n      * import std.net.curl;\n      * Curl curl;\n      * curl.initialize();\n      * curl.set(CurlOption.url, \"http://dlang.org\");\n      * curl.onSeek = (long p, CurlSeekPos sp)\n      * {\n      *     return CurlSeek.cantseek;\n      * };\n      * curl.perform();\n      * ----\n      */\n    @property void onSeek(CurlSeek delegate(long, CurlSeekPos) callback)\n    {\n        _onSeek = (long ofs, CurlSeekPos sp)\n        {\n            throwOnStopped(\"Seek callback called on cleaned up Curl instance\");\n            return callback(ofs, sp);\n        };\n        set(CurlOption.seekdata, cast(void*) &this);\n        set(CurlOption.seekfunction, cast(void*) &Curl._seekCallback);\n    }\n\n    /**\n      * The event handler that gets called when the net socket has been created\n      * but a `connect()` call has not yet been done. This makes it possible to set\n      * misc. socket options.\n      *\n      * Params:\n      * callback = the callback that receives the socket and socket type\n      * $(REF CurlSockType, etc,c,curl)\n      *\n      * Returns:\n      * Return 0 from the callback to signal success, return 1 to signal error\n      * and make curl close the socket\n      *\n      * Example:\n      * ----\n      * import std.net.curl;\n      * Curl curl;\n      * curl.initialize();\n      * curl.set(CurlOption.url, \"http://dlang.org\");\n      * curl.onSocketOption = delegate int(curl_socket_t s, CurlSockType t) { /+ do stuff +/ };\n      * curl.perform();\n      * ----\n      */\n    @property void onSocketOption(int delegate(curl_socket_t,\n                                               CurlSockType) callback)\n    {\n        _onSocketOption = (curl_socket_t sock, CurlSockType st)\n        {\n            throwOnStopped(\"Socket option callback called on \"~\n                           \"cleaned up Curl instance\");\n            return callback(sock, st);\n        };\n        set(CurlOption.sockoptdata, cast(void*) &this);\n        set(CurlOption.sockoptfunction,\n            cast(void*) &Curl._socketOptionCallback);\n    }\n\n    /**\n      * The event handler that gets called to inform of upload/download progress.\n      *\n      * Params:\n      * callback = the callback that receives the (total bytes to download,\n      * currently downloaded bytes, total bytes to upload, currently uploaded\n      * bytes).\n      *\n      * Returns:\n      * Return 0 from the callback to signal success, return non-zero to abort\n      * transfer\n      *\n      * Example:\n      * ----\n      * import std.net.curl;\n      * Curl curl;\n      * curl.initialize();\n      * curl.set(CurlOption.url, \"http://dlang.org\");\n      * curl.onProgress = delegate int(size_t dltotal, size_t dlnow, size_t ultotal, size_t uln)\n      * {\n      *     writeln(\"Progress: downloaded bytes \", dlnow, \" of \", dltotal);\n      *     writeln(\"Progress: uploaded bytes \", ulnow, \" of \", ultotal);\n      *     curl.perform();\n      * };\n      * ----\n      */\n    @property void onProgress(int delegate(size_t dlTotal,\n                                           size_t dlNow,\n                                           size_t ulTotal,\n                                           size_t ulNow) callback)\n    {\n        _onProgress = (size_t dlt, size_t dln, size_t ult, size_t uln)\n        {\n            throwOnStopped(\"Progress callback called on cleaned \"~\n                           \"up Curl instance\");\n            return callback(dlt, dln, ult, uln);\n        };\n        set(CurlOption.noprogress, 0);\n        set(CurlOption.progressdata, cast(void*) &this);\n        set(CurlOption.progressfunction, cast(void*) &Curl._progressCallback);\n    }\n\n    // Internal C callbacks to register with libcurl\n    extern (C) private static\n    size_t _receiveCallback(const char* str,\n                            size_t size, size_t nmemb, void* ptr)\n    {\n        auto b = cast(Curl*) ptr;\n        if (b._onReceive != null)\n            return b._onReceive(cast(InData)(str[0 .. size*nmemb]));\n        return size*nmemb;\n    }\n\n    extern (C) private static\n    size_t _receiveHeaderCallback(const char* str,\n                                  size_t size, size_t nmemb, void* ptr)\n    {\n        import std.string : chomp;\n\n        auto b = cast(Curl*) ptr;\n        auto s = str[0 .. size*nmemb].chomp();\n        if (b._onReceiveHeader != null)\n            b._onReceiveHeader(s);\n\n        return size*nmemb;\n    }\n\n    extern (C) private static\n    size_t _sendCallback(char *str, size_t size, size_t nmemb, void *ptr)\n    {\n        Curl* b = cast(Curl*) ptr;\n        auto a = cast(void[]) str[0 .. size*nmemb];\n        if (b._onSend == null)\n            return 0;\n        return b._onSend(a);\n    }\n\n    extern (C) private static\n    int _seekCallback(void *ptr, curl_off_t offset, int origin)\n    {\n        auto b = cast(Curl*) ptr;\n        if (b._onSeek == null)\n            return CurlSeek.cantseek;\n\n        // origin: CurlSeekPos.set/current/end\n        // return: CurlSeek.ok/fail/cantseek\n        return b._onSeek(cast(long) offset, cast(CurlSeekPos) origin);\n    }\n\n    extern (C) private static\n    int _socketOptionCallback(void *ptr,\n                              curl_socket_t curlfd, curlsocktype purpose)\n    {\n        auto b = cast(Curl*) ptr;\n        if (b._onSocketOption == null)\n            return 0;\n\n        // return: 0 ok, 1 fail\n        return b._onSocketOption(curlfd, cast(CurlSockType) purpose);\n    }\n\n    extern (C) private static\n    int _progressCallback(void *ptr,\n                          double dltotal, double dlnow,\n                          double ultotal, double ulnow)\n    {\n        auto b = cast(Curl*) ptr;\n        if (b._onProgress == null)\n            return 0;\n\n        // return: 0 ok, 1 fail\n        return b._onProgress(cast(size_t) dltotal, cast(size_t) dlnow,\n                             cast(size_t) ultotal, cast(size_t) ulnow);\n    }\n\n}\n\n// Internal messages send between threads.\n// The data is wrapped in this struct in order to ensure that\n// other std.concurrency.receive calls does not pick up our messages\n// by accident.\nprivate struct CurlMessage(T)\n{\n    public T data;\n}\n\nprivate static CurlMessage!T curlMessage(T)(T data)\n{\n    return CurlMessage!T(data);\n}\n\n// Pool of to be used for reusing buffers\nprivate struct Pool(Data)\n{\n    private struct Entry\n    {\n        Data data;\n        Entry* next;\n    }\n    private Entry*  root;\n    private Entry* freeList;\n\n    @safe @property bool empty()\n    {\n        return root == null;\n    }\n\n    @safe nothrow void push(Data d)\n    {\n        if (freeList == null)\n        {\n            // Allocate new Entry since there is no one\n            // available in the freeList\n            freeList = new Entry;\n        }\n        freeList.data = d;\n        Entry* oldroot = root;\n        root = freeList;\n        freeList = freeList.next;\n        root.next = oldroot;\n    }\n\n    @safe Data pop()\n    {\n        import std.exception : enforce;\n        enforce!Exception(root != null, \"pop() called on empty pool\");\n        auto d = root.data;\n        auto n = root.next;\n        root.next = freeList;\n        freeList = root;\n        root = n;\n        return d;\n    }\n}\n\n// Lazily-instantiated namespace to avoid importing std.concurrency until needed.\nprivate struct _async()\n{\nstatic:\n    // @@@@BUG 15831@@@@\n    // this should be inside byLineAsync\n    // Range that reads one chunk at a time asynchronously.\n    private struct ChunkInputRange\n    {\n        import std.concurrency : Tid, send;\n\n        private ubyte[] chunk;\n        mixin WorkerThreadProtocol!(ubyte, chunk);\n\n        private Tid workerTid;\n        private State running;\n\n        private this(Tid tid, size_t transmitBuffers, size_t chunkSize)\n        {\n            workerTid = tid;\n            state = State.needUnits;\n\n            // Send buffers to other thread for it to use.  Since no mechanism is in\n            // place for moving ownership a cast to shared is done here and a cast\n            // back to non-shared in the receiving end.\n            foreach (i ; 0 .. transmitBuffers)\n            {\n                ubyte[] arr = new ubyte[](chunkSize);\n                workerTid.send(cast(immutable(ubyte[]))arr);\n            }\n        }\n    }\n\n    // @@@@BUG 15831@@@@\n    // this should be inside byLineAsync\n    // Range that reads one line at a time asynchronously.\n    private static struct LineInputRange(Char)\n    {\n        private Char[] line;\n        mixin WorkerThreadProtocol!(Char, line);\n\n        private Tid workerTid;\n        private State running;\n\n        private this(Tid tid, size_t transmitBuffers, size_t bufferSize)\n        {\n            import std.concurrency : send;\n\n            workerTid = tid;\n            state = State.needUnits;\n\n            // Send buffers to other thread for it to use.  Since no mechanism is in\n            // place for moving ownership a cast to shared is done here and casted\n            // back to non-shared in the receiving end.\n            foreach (i ; 0 .. transmitBuffers)\n            {\n                auto arr = new Char[](bufferSize);\n                workerTid.send(cast(immutable(Char[]))arr);\n            }\n        }\n    }\n\n    import std.concurrency : Tid;\n\n    // Shared function for reading incoming chunks of data and\n    // sending the to a parent thread\n    private size_t receiveChunks(ubyte[] data, ref ubyte[] outdata,\n                                 Pool!(ubyte[]) freeBuffers,\n                                 ref ubyte[] buffer, Tid fromTid,\n                                 ref bool aborted)\n    {\n        import std.concurrency : receive, send, thisTid;\n\n        immutable datalen = data.length;\n\n        // Copy data to fill active buffer\n        while (!data.empty)\n        {\n\n            // Make sure a buffer is present\n            while ( outdata.empty && freeBuffers.empty)\n            {\n                // Active buffer is invalid and there are no\n                // available buffers in the pool. Wait for buffers\n                // to return from main thread in order to reuse\n                // them.\n                receive((immutable(ubyte)[] buf)\n                        {\n                            buffer = cast(ubyte[]) buf;\n                            outdata = buffer[];\n                        },\n                        (bool flag) { aborted = true; }\n                        );\n                if (aborted) return cast(size_t) 0;\n            }\n            if (outdata.empty)\n            {\n                buffer = freeBuffers.pop();\n                outdata = buffer[];\n            }\n\n            // Copy data\n            auto copyBytes = outdata.length < data.length ?\n                outdata.length : data.length;\n\n            outdata[0 .. copyBytes] = data[0 .. copyBytes];\n            outdata = outdata[copyBytes..$];\n            data = data[copyBytes..$];\n\n            if (outdata.empty)\n                fromTid.send(thisTid, curlMessage(cast(immutable(ubyte)[])buffer));\n        }\n\n        return datalen;\n    }\n\n    // ditto\n    private void finalizeChunks(ubyte[] outdata, ref ubyte[] buffer,\n                                Tid fromTid)\n    {\n        import std.concurrency : send, thisTid;\n        if (!outdata.empty)\n        {\n            // Resize the last buffer\n            buffer.length = buffer.length - outdata.length;\n            fromTid.send(thisTid, curlMessage(cast(immutable(ubyte)[])buffer));\n        }\n    }\n\n\n    // Shared function for reading incoming lines of data and sending the to a\n    // parent thread\n    private static size_t receiveLines(Terminator, Unit)\n        (const(ubyte)[] data, ref EncodingScheme encodingScheme,\n         bool keepTerminator, Terminator terminator,\n         ref const(ubyte)[] leftOverBytes, ref bool bufferValid,\n         ref Pool!(Unit[]) freeBuffers, ref Unit[] buffer,\n         Tid fromTid, ref bool aborted)\n    {\n        import std.concurrency : prioritySend, receive, send, thisTid;\n        import std.exception : enforce;\n        import std.format : format;\n        import std.traits : isArray;\n\n        immutable datalen = data.length;\n\n        // Terminator is specified and buffers should be resized as determined by\n        // the terminator\n\n        // Copy data to active buffer until terminator is found.\n\n        // Decode as many lines as possible\n        while (true)\n        {\n\n            // Make sure a buffer is present\n            while (!bufferValid && freeBuffers.empty)\n            {\n                // Active buffer is invalid and there are no available buffers in\n                // the pool. Wait for buffers to return from main thread in order to\n                // reuse them.\n                receive((immutable(Unit)[] buf)\n                        {\n                            buffer = cast(Unit[]) buf;\n                            buffer.length = 0;\n                            buffer.assumeSafeAppend();\n                            bufferValid = true;\n                        },\n                        (bool flag) { aborted = true; }\n                        );\n                if (aborted) return cast(size_t) 0;\n            }\n            if (!bufferValid)\n            {\n                buffer = freeBuffers.pop();\n                bufferValid = true;\n            }\n\n            // Try to read a line from left over bytes from last onReceive plus the\n            // newly received bytes.\n            try\n            {\n                if (decodeLineInto(leftOverBytes, data, buffer,\n                                   encodingScheme, terminator))\n                {\n                    if (keepTerminator)\n                    {\n                        fromTid.send(thisTid,\n                                     curlMessage(cast(immutable(Unit)[])buffer));\n                    }\n                    else\n                    {\n                        static if (isArray!Terminator)\n                            fromTid.send(thisTid,\n                                         curlMessage(cast(immutable(Unit)[])\n                                                 buffer[0..$-terminator.length]));\n                        else\n                            fromTid.send(thisTid,\n                                         curlMessage(cast(immutable(Unit)[])\n                                                 buffer[0..$-1]));\n                    }\n                    bufferValid = false;\n                }\n                else\n                {\n                    // Could not decode an entire line. Save\n                    // bytes left in data for next call to\n                    // onReceive. Can be up to a max of 4 bytes.\n                    enforce!CurlException(data.length <= 4,\n                                            format(\n                                            \"Too many bytes left not decoded %s\"~\n                                            \" > 4. Maybe the charset specified in\"~\n                                            \" headers does not match \"~\n                                            \"the actual content downloaded?\",\n                                            data.length));\n                    leftOverBytes ~= data;\n                    break;\n                }\n            }\n            catch (CurlException ex)\n            {\n                prioritySend(fromTid, cast(immutable(CurlException))ex);\n                return cast(size_t) 0;\n            }\n        }\n        return datalen;\n    }\n\n    // ditto\n    private static\n    void finalizeLines(Unit)(bool bufferValid, Unit[] buffer, Tid fromTid)\n    {\n        import std.concurrency : send, thisTid;\n        if (bufferValid && buffer.length != 0)\n            fromTid.send(thisTid, curlMessage(cast(immutable(Unit)[])buffer[0..$]));\n    }\n\n    /* Used by byLineAsync/byChunkAsync to duplicate an existing connection\n     * that can be used exclusively in a spawned thread.\n     */\n    private void duplicateConnection(Conn, PostData)\n        (const(char)[] url, Conn conn, PostData postData, Tid tid)\n    {\n        import std.concurrency : send;\n        import std.exception : enforce;\n\n        // no move semantic available in std.concurrency ie. must use casting.\n        auto connDup = conn.dup();\n        connDup.url = url;\n\n        static if ( is(Conn : HTTP) )\n        {\n            connDup.p.headersOut = null;\n            connDup.method = conn.method == HTTP.Method.undefined ?\n                HTTP.Method.get : conn.method;\n            if (postData !is null)\n            {\n                if (connDup.method == HTTP.Method.put)\n                {\n                    connDup.handle.set(CurlOption.infilesize_large,\n                                       postData.length);\n                }\n                else\n                {\n                    // post\n                    connDup.method = HTTP.Method.post;\n                    connDup.handle.set(CurlOption.postfieldsize_large,\n                                       postData.length);\n                }\n                connDup.handle.set(CurlOption.copypostfields,\n                                   cast(void*) postData.ptr);\n            }\n            tid.send(cast(ulong) connDup.handle.handle);\n            tid.send(connDup.method);\n        }\n        else\n        {\n            enforce!CurlException(postData is null,\n                                    \"Cannot put ftp data using byLineAsync()\");\n            tid.send(cast(ulong) connDup.handle.handle);\n            tid.send(HTTP.Method.undefined);\n        }\n        connDup.p.curl.handle = null; // make sure handle is not freed\n    }\n\n    // Spawn a thread for handling the reading of incoming data in the\n    // background while the delegate is executing.  This will optimize\n    // throughput by allowing simultaneous input (this struct) and\n    // output (e.g. AsyncHTTPLineOutputRange).\n    private static void spawn(Conn, Unit, Terminator = void)()\n    {\n        import std.concurrency : Tid, prioritySend, receiveOnly, send, thisTid;\n        import etc.c.curl : CURL, CurlError;\n        Tid fromTid = receiveOnly!Tid();\n\n        // Get buffer to read into\n        Pool!(Unit[]) freeBuffers;  // Free list of buffer objects\n\n        // Number of bytes filled into active buffer\n        Unit[] buffer;\n        bool aborted = false;\n\n        EncodingScheme encodingScheme;\n        static if ( !is(Terminator == void))\n        {\n            // Only lines reading will receive a terminator\n            const terminator = receiveOnly!Terminator();\n            const keepTerminator = receiveOnly!bool();\n\n            // max number of bytes to carry over from an onReceive\n            // callback. This is 4 because it is the max code units to\n            // decode a code point in the supported encodings.\n            auto leftOverBytes =  new const(ubyte)[4];\n            leftOverBytes.length = 0;\n            auto bufferValid = false;\n        }\n        else\n        {\n            Unit[] outdata;\n        }\n\n        // no move semantic available in std.concurrency ie. must use casting.\n        auto connDup = cast(CURL*) receiveOnly!ulong();\n        auto client = Conn();\n        client.p.curl.handle = connDup;\n\n        // receive a method for both ftp and http but just use it for http\n        auto method = receiveOnly!(HTTP.Method)();\n\n        client.onReceive = (ubyte[] data)\n        {\n            // If no terminator is specified the chunk size is fixed.\n            static if ( is(Terminator == void) )\n                return receiveChunks(data, outdata, freeBuffers, buffer,\n                                     fromTid, aborted);\n            else\n                return receiveLines(data, encodingScheme,\n                                    keepTerminator, terminator, leftOverBytes,\n                                    bufferValid, freeBuffers, buffer,\n                                    fromTid, aborted);\n        };\n\n        static if ( is(Conn == HTTP) )\n        {\n            client.method = method;\n            // register dummy header handler\n            client.onReceiveHeader = (in char[] key, in char[] value)\n            {\n                if (key == \"content-type\")\n                    encodingScheme = EncodingScheme.create(client.p.charset);\n            };\n        }\n        else\n        {\n            encodingScheme = EncodingScheme.create(client.encoding);\n        }\n\n        // Start the request\n        CurlCode code;\n        try\n        {\n            code = client.perform(No.throwOnError);\n        }\n        catch (Exception ex)\n        {\n            prioritySend(fromTid, cast(immutable(Exception)) ex);\n            fromTid.send(thisTid, curlMessage(true)); // signal done\n            return;\n        }\n\n        if (code != CurlError.ok)\n        {\n            if (aborted && (code == CurlError.aborted_by_callback ||\n                            code == CurlError.write_error))\n            {\n                fromTid.send(thisTid, curlMessage(true)); // signal done\n                return;\n            }\n            prioritySend(fromTid, cast(immutable(CurlException))\n                         new CurlException(client.p.curl.errorString(code)));\n\n            fromTid.send(thisTid, curlMessage(true)); // signal done\n            return;\n        }\n\n        // Send remaining data that is not a full chunk size\n        static if ( is(Terminator == void) )\n            finalizeChunks(outdata, buffer, fromTid);\n        else\n            finalizeLines(bufferValid, buffer, fromTid);\n\n        fromTid.send(thisTid, curlMessage(true)); // signal done\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmd-2.081.1-vqq6jjlqlkf6xkxhau7opmwbvotgmaut/spack-src/druntime/src/rt/sections_elf_shared.d": "/**\n * Written in the D programming language.\n * This module provides ELF-specific support for sections with shared libraries.\n *\n * Copyright: Copyright Martin Nowak 2012-2013.\n * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n * Authors:   Martin Nowak\n * Source: $(DRUNTIMESRC rt/_sections_linux.d)\n */\n\nmodule rt.sections_elf_shared;\n\nversion (CRuntime_Glibc) enum SharedELF = true;\nelse version (CRuntime_Musl) enum SharedELF = true;\nelse version (FreeBSD) enum SharedELF = true;\nelse version (NetBSD) enum SharedELF = true;\nelse version (DragonFlyBSD) enum SharedELF = true;\nelse version (CRuntime_UClibc) enum SharedELF = true;\nelse enum SharedELF = false;\nstatic if (SharedELF):\n\n// debug = PRINTF;\nimport core.memory;\nimport core.stdc.stdio;\nimport core.stdc.stdlib : calloc, exit, free, malloc, EXIT_FAILURE;\nimport core.stdc.string : strlen;\nversion (linux)\n{\n    import core.sys.linux.dlfcn;\n    import core.sys.linux.elf;\n    import core.sys.linux.link;\n}\nelse version (FreeBSD)\n{\n    import core.sys.freebsd.dlfcn;\n    import core.sys.freebsd.sys.elf;\n    import core.sys.freebsd.sys.link_elf;\n}\nelse version (NetBSD)\n{\n    import core.sys.netbsd.dlfcn;\n    import core.sys.netbsd.sys.elf;\n    import core.sys.netbsd.sys.link_elf;\n}\nelse version (DragonFlyBSD)\n{\n    import core.sys.dragonflybsd.dlfcn;\n    import core.sys.dragonflybsd.sys.elf;\n    import core.sys.dragonflybsd.sys.link_elf;\n}\nelse\n{\n    static assert(0, \"unimplemented\");\n}\nimport core.sys.posix.pthread;\nimport rt.deh;\nimport rt.dmain2;\nimport rt.minfo;\nimport rt.util.container.array;\nimport rt.util.container.hashtab;\n\nalias DSO SectionGroup;\nstruct DSO\n{\n    static int opApply(scope int delegate(ref DSO) dg)\n    {\n        foreach (dso; _loadedDSOs)\n        {\n            if (auto res = dg(*dso))\n                return res;\n        }\n        return 0;\n    }\n\n    static int opApplyReverse(scope int delegate(ref DSO) dg)\n    {\n        foreach_reverse (dso; _loadedDSOs)\n        {\n            if (auto res = dg(*dso))\n                return res;\n        }\n        return 0;\n    }\n\n    @property immutable(ModuleInfo*)[] modules() const nothrow @nogc\n    {\n        return _moduleGroup.modules;\n    }\n\n    @property ref inout(ModuleGroup) moduleGroup() inout nothrow @nogc\n    {\n        return _moduleGroup;\n    }\n\n    @property immutable(FuncTable)[] ehTables() const nothrow @nogc\n    {\n        return null;\n    }\n\n    @property inout(void[])[] gcRanges() inout nothrow @nogc\n    {\n        return _gcRanges[];\n    }\n\nprivate:\n\n    invariant()\n    {\n        assert(_moduleGroup.modules.length);\n        version (CRuntime_UClibc) {} else\n        assert(_tlsMod || !_tlsSize);\n    }\n\n    ModuleGroup _moduleGroup;\n    Array!(void[]) _gcRanges;\n    size_t _tlsMod;\n    size_t _tlsSize;\n\n    version (Shared)\n    {\n        Array!(void[]) _codeSegments; // array of code segments\n        Array!(DSO*) _deps; // D libraries needed by this DSO\n        void* _handle; // corresponding handle\n    }\n}\n\n/****\n * Boolean flag set to true while the runtime is initialized.\n */\n__gshared bool _isRuntimeInitialized;\n\n\nversion (FreeBSD) private __gshared void* dummy_ref;\nversion (DragonFlyBSD) private __gshared void* dummy_ref;\nversion (NetBSD) private __gshared void* dummy_ref;\n\n/****\n * Gets called on program startup just before GC is initialized.\n */\nvoid initSections() nothrow @nogc\n{\n    _isRuntimeInitialized = true;\n    // reference symbol to support weak linkage\n    version (FreeBSD) dummy_ref = &_d_dso_registry;\n    version (DragonFlyBSD) dummy_ref = &_d_dso_registry;\n    version (NetBSD) dummy_ref = &_d_dso_registry;\n}\n\n\n/***\n * Gets called on program shutdown just after GC is terminated.\n */\nvoid finiSections() nothrow @nogc\n{\n    _isRuntimeInitialized = false;\n}\n\nalias ScanDG = void delegate(void* pbeg, void* pend) nothrow;\n\nversion (Shared)\n{\n    /***\n     * Called once per thread; returns array of thread local storage ranges\n     */\n    Array!(ThreadDSO)* initTLSRanges() @nogc nothrow\n    {\n        return &_loadedDSOs;\n    }\n\n    void finiTLSRanges(Array!(ThreadDSO)* tdsos) @nogc nothrow\n    {\n        // Nothing to do here. tdsos used to point to the _loadedDSOs instance\n        // in the dying thread's TLS segment and as such is not valid anymore.\n        // The memory for the array contents was already reclaimed in\n        // cleanupLoadedLibraries().\n    }\n\n    void scanTLSRanges(Array!(ThreadDSO)* tdsos, scope ScanDG dg) nothrow\n    {\n        foreach (ref tdso; *tdsos)\n            dg(tdso._tlsRange.ptr, tdso._tlsRange.ptr + tdso._tlsRange.length);\n    }\n\n    // interface for core.thread to inherit loaded libraries\n    void* pinLoadedLibraries() nothrow @nogc\n    {\n        auto res = cast(Array!(ThreadDSO)*)calloc(1, Array!(ThreadDSO).sizeof);\n        res.length = _loadedDSOs.length;\n        foreach (i, ref tdso; _loadedDSOs)\n        {\n            (*res)[i] = tdso;\n            if (tdso._addCnt)\n            {\n                // Increment the dlopen ref for explicitly loaded libraries to pin them.\n                .dlopen(linkMapForHandle(tdso._pdso._handle).l_name, RTLD_LAZY) !is null || assert(0);\n                (*res)[i]._addCnt = 1; // new array takes over the additional ref count\n            }\n        }\n        return res;\n    }\n\n    void unpinLoadedLibraries(void* p) nothrow @nogc\n    {\n        auto pary = cast(Array!(ThreadDSO)*)p;\n        // In case something failed we need to undo the pinning.\n        foreach (ref tdso; *pary)\n        {\n            if (tdso._addCnt)\n            {\n                auto handle = tdso._pdso._handle;\n                handle !is null || assert(0);\n                .dlclose(handle);\n            }\n        }\n        pary.reset();\n        .free(pary);\n    }\n\n    // Called before TLS ctors are ran, copy over the loaded libraries\n    // of the parent thread.\n    void inheritLoadedLibraries(void* p) nothrow @nogc\n    {\n        assert(_loadedDSOs.empty);\n        _loadedDSOs.swap(*cast(Array!(ThreadDSO)*)p);\n        .free(p);\n        foreach (ref dso; _loadedDSOs)\n        {\n            // the copied _tlsRange corresponds to parent thread\n            dso.updateTLSRange();\n        }\n    }\n\n    // Called after all TLS dtors ran, decrements all remaining dlopen refs.\n    void cleanupLoadedLibraries() nothrow @nogc\n    {\n        foreach (ref tdso; _loadedDSOs)\n        {\n            if (tdso._addCnt == 0) continue;\n\n            auto handle = tdso._pdso._handle;\n            handle !is null || assert(0);\n            for (; tdso._addCnt > 0; --tdso._addCnt)\n                .dlclose(handle);\n        }\n\n        // Free the memory for the array contents.\n        _loadedDSOs.reset();\n    }\n}\nelse\n{\n    /***\n     * Called once per thread; returns array of thread local storage ranges\n     */\n    Array!(void[])* initTLSRanges() nothrow @nogc\n    {\n        return &_tlsRanges;\n    }\n\n    void finiTLSRanges(Array!(void[])* rngs) nothrow @nogc\n    {\n        rngs.reset();\n    }\n\n    void scanTLSRanges(Array!(void[])* rngs, scope ScanDG dg) nothrow\n    {\n        foreach (rng; *rngs)\n            dg(rng.ptr, rng.ptr + rng.length);\n    }\n}\n\nprivate:\n\n// start of linked list for ModuleInfo references\nversion (FreeBSD) deprecated extern (C) __gshared void* _Dmodule_ref;\nversion (DragonFlyBSD) deprecated extern (C) __gshared void* _Dmodule_ref;\nversion (NetBSD) deprecated extern (C) __gshared void* _Dmodule_ref;\n\nversion (Shared)\n{\n    /*\n     * Array of thread local DSO metadata for all libraries loaded and\n     * initialized in this thread.\n     *\n     * Note:\n     *     A newly spawned thread will inherit these libraries.\n     * Note:\n     *     We use an array here to preserve the order of\n     *     initialization.  If that became a performance issue, we\n     *     could use a hash table and enumerate the DSOs during\n     *     loading so that the hash table values could be sorted when\n     *     necessary.\n     */\n    struct ThreadDSO\n    {\n        DSO* _pdso;\n        static if (_pdso.sizeof == 8) uint _refCnt, _addCnt;\n        else static if (_pdso.sizeof == 4) ushort _refCnt, _addCnt;\n        else static assert(0, \"unimplemented\");\n        void[] _tlsRange;\n        alias _pdso this;\n        // update the _tlsRange for the executing thread\n        void updateTLSRange() nothrow @nogc\n        {\n            _tlsRange = getTLSRange(_pdso._tlsMod, _pdso._tlsSize);\n        }\n    }\n    Array!(ThreadDSO) _loadedDSOs;\n\n    /*\n     * Set to true during rt_loadLibrary/rt_unloadLibrary calls.\n     */\n    bool _rtLoading;\n\n    /*\n     * Hash table to map link_map* to corresponding DSO*.\n     * The hash table is protected by a Mutex.\n     */\n    __gshared pthread_mutex_t _handleToDSOMutex;\n    __gshared HashTab!(void*, DSO*) _handleToDSO;\n\n    /*\n     * Section in executable that contains copy relocations.\n     * Might be null when druntime is dynamically loaded by a C host.\n     */\n    __gshared const(void)[] _copyRelocSection;\n}\nelse\n{\n    /*\n     * Static DSOs loaded by the runtime linker. This includes the\n     * executable. These can't be unloaded.\n     */\n    __gshared Array!(DSO*) _loadedDSOs;\n\n    /*\n     * Thread local array that contains TLS memory ranges for each\n     * library initialized in this thread.\n     */\n    Array!(void[]) _tlsRanges;\n\n    enum _rtLoading = false;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Compiler to runtime interface.\n///////////////////////////////////////////////////////////////////////////////\n\n\n/*\n * This data structure is generated by the compiler, and then passed to\n * _d_dso_registry().\n */\nstruct CompilerDSOData\n{\n    size_t _version;                                       // currently 1\n    void** _slot;                                          // can be used to store runtime data\n    immutable(object.ModuleInfo*)* _minfo_beg, _minfo_end; // array of modules in this object file\n}\n\nT[] toRange(T)(T* beg, T* end) { return beg[0 .. end - beg]; }\n\n/* For each shared library and executable, the compiler generates code that\n * sets up CompilerDSOData and calls _d_dso_registry().\n * A pointer to that code is inserted into both the .ctors and .dtors\n * segment so it gets called by the loader on startup and shutdown.\n */\nextern(C) void _d_dso_registry(CompilerDSOData* data)\n{\n    // only one supported currently\n    data._version >= 1 || assert(0, \"corrupt DSO data version\");\n\n    // no backlink => register\n    if (*data._slot is null)\n    {\n        immutable firstDSO = _loadedDSOs.empty;\n        if (firstDSO) initLocks();\n\n        DSO* pdso = cast(DSO*).calloc(1, DSO.sizeof);\n        assert(typeid(DSO).initializer().ptr is null);\n        *data._slot = pdso; // store backlink in library record\n\n        pdso._moduleGroup = ModuleGroup(toRange(data._minfo_beg, data._minfo_end));\n\n        dl_phdr_info info = void;\n        findDSOInfoForAddr(data._slot, &info) || assert(0);\n\n        scanSegments(info, pdso);\n\n        version (Shared)\n        {\n            auto handle = handleForAddr(data._slot);\n\n            getDependencies(info, pdso._deps);\n            pdso._handle = handle;\n            setDSOForHandle(pdso, pdso._handle);\n\n            if (!_rtLoading)\n            {\n                /* This DSO was not loaded by rt_loadLibrary which\n                 * happens for all dependencies of an executable or\n                 * the first dlopen call from a C program.\n                 * In this case we add the DSO to the _loadedDSOs of this\n                 * thread with a refCnt of 1 and call the TlsCtors.\n                 */\n                immutable ushort refCnt = 1, addCnt = 0;\n                auto tlsRng = getTLSRange(pdso._tlsMod, pdso._tlsSize);\n                _loadedDSOs.insertBack(ThreadDSO(pdso, refCnt, addCnt, tlsRng));\n            }\n        }\n        else\n        {\n            foreach (p; _loadedDSOs) assert(p !is pdso);\n            _loadedDSOs.insertBack(pdso);\n            _tlsRanges.insertBack(getTLSRange(pdso._tlsMod, pdso._tlsSize));\n        }\n\n        // don't initialize modules before rt_init was called (see Bugzilla 11378)\n        if (_isRuntimeInitialized)\n        {\n            registerGCRanges(pdso);\n            // rt_loadLibrary will run tls ctors, so do this only for dlopen\n            immutable runTlsCtors = !_rtLoading;\n            runModuleConstructors(pdso, runTlsCtors);\n        }\n    }\n    // has backlink => unregister\n    else\n    {\n        DSO* pdso = cast(DSO*)*data._slot;\n        *data._slot = null;\n\n        // don't finalizes modules after rt_term was called (see Bugzilla 11378)\n        if (_isRuntimeInitialized)\n        {\n            // rt_unloadLibrary already ran tls dtors, so do this only for dlclose\n            immutable runTlsDtors = !_rtLoading;\n            runModuleDestructors(pdso, runTlsDtors);\n            unregisterGCRanges(pdso);\n            // run finalizers after module dtors (same order as in rt_term)\n            version (Shared) runFinalizers(pdso);\n        }\n\n        version (Shared)\n        {\n            if (!_rtLoading)\n            {\n                /* This DSO was not unloaded by rt_unloadLibrary so we\n                 * have to remove it from _loadedDSOs here.\n                 */\n                foreach (i, ref tdso; _loadedDSOs)\n                {\n                    if (tdso._pdso == pdso)\n                    {\n                        _loadedDSOs.remove(i);\n                        break;\n                    }\n                }\n            }\n\n            unsetDSOForHandle(pdso, pdso._handle);\n        }\n        else\n        {\n            // static DSOs are unloaded in reverse order\n            assert(pdso == _loadedDSOs.back);\n            _loadedDSOs.popBack();\n        }\n\n        freeDSO(pdso);\n\n        // last DSO being unloaded => shutdown registry\n        if (_loadedDSOs.empty)\n        {\n            version (Shared)\n            {\n                assert(_handleToDSO.empty);\n                _handleToDSO.reset();\n            }\n            finiLocks();\n        }\n    }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// dynamic loading\n///////////////////////////////////////////////////////////////////////////////\n\n// Shared D libraries are only supported when linking against a shared druntime library.\n\nversion (Shared)\n{\n    ThreadDSO* findThreadDSO(DSO* pdso) nothrow @nogc\n    {\n        foreach (ref tdata; _loadedDSOs)\n            if (tdata._pdso == pdso) return &tdata;\n        return null;\n    }\n\n    void incThreadRef(DSO* pdso, bool incAdd)\n    {\n        if (auto tdata = findThreadDSO(pdso)) // already initialized\n        {\n            if (incAdd && ++tdata._addCnt > 1) return;\n            ++tdata._refCnt;\n        }\n        else\n        {\n            foreach (dep; pdso._deps)\n                incThreadRef(dep, false);\n            immutable ushort refCnt = 1, addCnt = incAdd ? 1 : 0;\n            auto tlsRng = getTLSRange(pdso._tlsMod, pdso._tlsSize);\n            _loadedDSOs.insertBack(ThreadDSO(pdso, refCnt, addCnt, tlsRng));\n            pdso._moduleGroup.runTlsCtors();\n        }\n    }\n\n    void decThreadRef(DSO* pdso, bool decAdd)\n    {\n        auto tdata = findThreadDSO(pdso);\n        tdata !is null || assert(0);\n        !decAdd || tdata._addCnt > 0 || assert(0, \"Mismatching rt_unloadLibrary call.\");\n\n        if (decAdd && --tdata._addCnt > 0) return;\n        if (--tdata._refCnt > 0) return;\n\n        pdso._moduleGroup.runTlsDtors();\n        foreach (i, ref td; _loadedDSOs)\n            if (td._pdso == pdso) _loadedDSOs.remove(i);\n        foreach (dep; pdso._deps)\n            decThreadRef(dep, false);\n    }\n\n    extern(C) void* rt_loadLibrary(const char* name)\n    {\n        immutable save = _rtLoading;\n        _rtLoading = true;\n        scope (exit) _rtLoading = save;\n\n        auto handle = .dlopen(name, RTLD_LAZY);\n        if (handle is null) return null;\n\n        // if it's a D library\n        if (auto pdso = dsoForHandle(handle))\n            incThreadRef(pdso, true);\n        return handle;\n    }\n\n    extern(C) int rt_unloadLibrary(void* handle)\n    {\n        if (handle is null) return false;\n\n        immutable save = _rtLoading;\n        _rtLoading = true;\n        scope (exit) _rtLoading = save;\n\n        // if it's a D library\n        if (auto pdso = dsoForHandle(handle))\n            decThreadRef(pdso, true);\n        return .dlclose(handle) == 0;\n    }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// helper functions\n///////////////////////////////////////////////////////////////////////////////\n\nvoid initLocks() nothrow @nogc\n{\n    version (Shared)\n        !pthread_mutex_init(&_handleToDSOMutex, null) || assert(0);\n}\n\nvoid finiLocks() nothrow @nogc\n{\n    version (Shared)\n        !pthread_mutex_destroy(&_handleToDSOMutex) || assert(0);\n}\n\nvoid runModuleConstructors(DSO* pdso, bool runTlsCtors)\n{\n    pdso._moduleGroup.sortCtors();\n    pdso._moduleGroup.runCtors();\n    if (runTlsCtors) pdso._moduleGroup.runTlsCtors();\n}\n\nvoid runModuleDestructors(DSO* pdso, bool runTlsDtors)\n{\n    if (runTlsDtors) pdso._moduleGroup.runTlsDtors();\n    pdso._moduleGroup.runDtors();\n}\n\nvoid registerGCRanges(DSO* pdso) nothrow @nogc\n{\n    foreach (rng; pdso._gcRanges)\n        GC.addRange(rng.ptr, rng.length);\n}\n\nvoid unregisterGCRanges(DSO* pdso) nothrow @nogc\n{\n    foreach (rng; pdso._gcRanges)\n        GC.removeRange(rng.ptr);\n}\n\nversion (Shared) void runFinalizers(DSO* pdso)\n{\n    foreach (seg; pdso._codeSegments)\n        GC.runFinalizers(seg);\n}\n\nvoid freeDSO(DSO* pdso) nothrow @nogc\n{\n    pdso._gcRanges.reset();\n    version (Shared)\n    {\n        pdso._codeSegments.reset();\n        pdso._deps.reset();\n        pdso._handle = null;\n    }\n    .free(pdso);\n}\n\nversion (Shared)\n{\n@nogc nothrow:\n    link_map* linkMapForHandle(void* handle) nothrow @nogc\n    {\n        link_map* map;\n        dlinfo(handle, RTLD_DI_LINKMAP, &map) == 0 || assert(0);\n        return map;\n    }\n\n     link_map* exeLinkMap(link_map* map) nothrow @nogc\n     {\n         assert(map);\n         while (map.l_prev !is null)\n             map = map.l_prev;\n         return map;\n     }\n\n    DSO* dsoForHandle(void* handle) nothrow @nogc\n    {\n        DSO* pdso;\n        !pthread_mutex_lock(&_handleToDSOMutex) || assert(0);\n        if (auto ppdso = handle in _handleToDSO)\n            pdso = *ppdso;\n        !pthread_mutex_unlock(&_handleToDSOMutex) || assert(0);\n        return pdso;\n    }\n\n    void setDSOForHandle(DSO* pdso, void* handle) nothrow @nogc\n    {\n        !pthread_mutex_lock(&_handleToDSOMutex) || assert(0);\n        assert(handle !in _handleToDSO);\n        _handleToDSO[handle] = pdso;\n        !pthread_mutex_unlock(&_handleToDSOMutex) || assert(0);\n    }\n\n    void unsetDSOForHandle(DSO* pdso, void* handle) nothrow @nogc\n    {\n        !pthread_mutex_lock(&_handleToDSOMutex) || assert(0);\n        assert(_handleToDSO[handle] == pdso);\n        _handleToDSO.remove(handle);\n        !pthread_mutex_unlock(&_handleToDSOMutex) || assert(0);\n    }\n\n    void getDependencies(in ref dl_phdr_info info, ref Array!(DSO*) deps) nothrow @nogc\n    {\n        // get the entries of the .dynamic section\n        ElfW!\"Dyn\"[] dyns;\n        foreach (ref phdr; info.dlpi_phdr[0 .. info.dlpi_phnum])\n        {\n            if (phdr.p_type == PT_DYNAMIC)\n            {\n                auto p = cast(ElfW!\"Dyn\"*)(info.dlpi_addr + phdr.p_vaddr);\n                dyns = p[0 .. phdr.p_memsz / ElfW!\"Dyn\".sizeof];\n                break;\n            }\n        }\n        // find the string table which contains the sonames\n        const(char)* strtab;\n        foreach (dyn; dyns)\n        {\n            if (dyn.d_tag == DT_STRTAB)\n            {\n                version (CRuntime_Musl)\n                    strtab = cast(const(char)*)(info.dlpi_addr + dyn.d_un.d_ptr); // relocate\n                else version (linux)\n                    strtab = cast(const(char)*)dyn.d_un.d_ptr;\n                else version (FreeBSD)\n                    strtab = cast(const(char)*)(info.dlpi_addr + dyn.d_un.d_ptr); // relocate\n                else version (NetBSD)\n                    strtab = cast(const(char)*)(info.dlpi_addr + dyn.d_un.d_ptr); // relocate\n                else version (DragonFlyBSD)\n                    strtab = cast(const(char)*)(info.dlpi_addr + dyn.d_un.d_ptr); // relocate\n                else\n                    static assert(0, \"unimplemented\");\n                break;\n            }\n        }\n        foreach (dyn; dyns)\n        {\n            immutable tag = dyn.d_tag;\n            if (!(tag == DT_NEEDED || tag == DT_AUXILIARY || tag == DT_FILTER))\n                continue;\n\n            // soname of the dependency\n            auto name = strtab + dyn.d_un.d_val;\n            // get handle without loading the library\n            auto handle = handleForName(name);\n            // the runtime linker has already loaded all dependencies\n            if (handle is null) assert(0);\n            // if it's a D library\n            if (auto pdso = dsoForHandle(handle))\n                deps.insertBack(pdso); // append it to the dependencies\n        }\n    }\n\n    void* handleForName(const char* name) nothrow @nogc\n    {\n        auto handle = .dlopen(name, RTLD_NOLOAD | RTLD_LAZY);\n        if (handle !is null) .dlclose(handle); // drop reference count\n        return handle;\n    }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Elf program header iteration\n///////////////////////////////////////////////////////////////////////////////\n\n/************\n * Scan segments in Linux dl_phdr_info struct and store\n * the TLS and writeable data segments in *pdso.\n */\nvoid scanSegments(in ref dl_phdr_info info, DSO* pdso) nothrow @nogc\n{\n    foreach (ref phdr; info.dlpi_phdr[0 .. info.dlpi_phnum])\n    {\n        switch (phdr.p_type)\n        {\n        case PT_LOAD:\n            if (phdr.p_flags & PF_W) // writeable data segment\n            {\n                auto beg = cast(void*)(info.dlpi_addr + phdr.p_vaddr);\n                pdso._gcRanges.insertBack(beg[0 .. phdr.p_memsz]);\n            }\n            version (Shared) if (phdr.p_flags & PF_X) // code segment\n            {\n                auto beg = cast(void*)(info.dlpi_addr + phdr.p_vaddr);\n                pdso._codeSegments.insertBack(beg[0 .. phdr.p_memsz]);\n            }\n            break;\n\n        case PT_TLS: // TLS segment\n            assert(!pdso._tlsSize); // is unique per DSO\n            version (CRuntime_UClibc)\n            {\n                // uClibc doesn't provide a 'dlpi_tls_modid' definition\n            }\n            else\n                pdso._tlsMod = info.dlpi_tls_modid;\n            pdso._tlsSize = phdr.p_memsz;\n            break;\n\n        default:\n            break;\n        }\n    }\n}\n\n/**************************\n * Input:\n *      result  where the output is to be written; dl_phdr_info is a Linux struct\n * Returns:\n *      true if found, and *result is filled in\n * References:\n *      http://linux.die.net/man/3/dl_iterate_phdr\n */\nversion (linux) bool findDSOInfoForAddr(in void* addr, dl_phdr_info* result=null) nothrow @nogc\n{\n    static struct DG { const(void)* addr; dl_phdr_info* result; }\n\n    extern(C) int callback(dl_phdr_info* info, size_t sz, void* arg) nothrow @nogc\n    {\n        auto p = cast(DG*)arg;\n        if (findSegmentForAddr(*info, p.addr))\n        {\n            if (p.result !is null) *p.result = *info;\n            return 1; // break;\n        }\n        return 0; // continue iteration\n    }\n\n    auto dg = DG(addr, result);\n\n    /* Linux function that walks through the list of an application's shared objects and\n     * calls 'callback' once for each object, until either all shared objects\n     * have been processed or 'callback' returns a nonzero value.\n     */\n    return dl_iterate_phdr(&callback, &dg) != 0;\n}\nelse version (FreeBSD) bool findDSOInfoForAddr(in void* addr, dl_phdr_info* result=null) nothrow @nogc\n{\n    return !!_rtld_addr_phdr(addr, result);\n}\nelse version (NetBSD) bool findDSOInfoForAddr(in void* addr, dl_phdr_info* result=null) nothrow @nogc\n{\n    static struct DG { const(void)* addr; dl_phdr_info* result; }\n\n    extern(C) int callback(dl_phdr_info* info, size_t sz, void* arg) nothrow @nogc\n    {\n        auto p = cast(DG*)arg;\n        if (findSegmentForAddr(*info, p.addr))\n        {\n            if (p.result !is null) *p.result = *info;\n            return 1; // break;\n        }\n        return 0; // continue iteration\n    }\n    auto dg = DG(addr, result);\n    return dl_iterate_phdr(&callback, &dg) != 0;\n}\nelse version (DragonFlyBSD) bool findDSOInfoForAddr(in void* addr, dl_phdr_info* result=null) nothrow @nogc\n{\n    return !!_rtld_addr_phdr(addr, result);\n}\n\n/*********************************\n * Determine if 'addr' lies within shared object 'info'.\n * If so, return true and fill in 'result' with the corresponding ELF program header.\n */\nbool findSegmentForAddr(in ref dl_phdr_info info, in void* addr, ElfW!\"Phdr\"* result=null) nothrow @nogc\n{\n    if (addr < cast(void*)info.dlpi_addr) // less than base address of object means quick reject\n        return false;\n\n    foreach (ref phdr; info.dlpi_phdr[0 .. info.dlpi_phnum])\n    {\n        auto beg = cast(void*)(info.dlpi_addr + phdr.p_vaddr);\n        if (cast(size_t)(addr - beg) < phdr.p_memsz)\n        {\n            if (result !is null) *result = phdr;\n            return true;\n        }\n    }\n    return false;\n}\n\nversion (linux) import core.sys.linux.errno : program_invocation_name;\n// should be in core.sys.freebsd.stdlib\nversion (FreeBSD) extern(C) const(char)* getprogname() nothrow @nogc;\nversion (DragonFlyBSD) extern(C) const(char)* getprogname() nothrow @nogc;\nversion (NetBSD) extern(C) const(char)* getprogname() nothrow @nogc;\n\n@property const(char)* progname() nothrow @nogc\n{\n    version (linux) return program_invocation_name;\n    version (FreeBSD) return getprogname();\n    version (DragonFlyBSD) return getprogname();\n    version (NetBSD) return getprogname();\n}\n\nconst(char)[] dsoName(const char* dlpi_name) nothrow @nogc\n{\n    // the main executable doesn't have a name in its dlpi_name field\n    const char* p = dlpi_name[0] != 0 ? dlpi_name : progname;\n    return p[0 .. strlen(p)];\n}\n\n/**************************\n * Input:\n *      addr  an internal address of a DSO\n * Returns:\n *      the dlopen handle for that DSO or null if addr is not within a loaded DSO\n */\nversion (Shared) void* handleForAddr(void* addr) nothrow @nogc\n{\n    Dl_info info = void;\n    if (dladdr(addr, &info) != 0)\n        return handleForName(info.dli_fname);\n    return null;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// TLS module helper\n///////////////////////////////////////////////////////////////////////////////\n\n\n/*\n * Returns: the TLS memory range for a given module and the calling\n * thread or null if that module has no TLS.\n *\n * Note: This will cause the TLS memory to be eagerly allocated.\n */\nstruct tls_index\n{\n    size_t ti_module;\n    size_t ti_offset;\n}\n\nextern(C) void* __tls_get_addr(tls_index* ti) nothrow @nogc;\n\n/* The dynamic thread vector (DTV) pointers may point 0x8000 past the start of\n * each TLS block. This is at least true for PowerPC and Mips platforms.\n * See: https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/powerpc/dl-tls.h;h=f7cf6f96ebfb505abfd2f02be0ad0e833107c0cd;hb=HEAD#l34\n *      https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/mips/dl-tls.h;h=93a6dc050cb144b9f68b96fb3199c60f5b1fcd18;hb=HEAD#l32\n */\nversion(X86)\n    enum TLS_DTV_OFFSET = 0x;\nelse version(X86_64)\n    enum TLS_DTV_OFFSET = 0x;\nelse version(ARM)\n    enum TLS_DTV_OFFSET = 0x;\nelse version(AArch64)\n    enum TLS_DTV_OFFSET = 0x;\nelse version(SPARC)\n    enum TLS_DTV_OFFSET = 0x;\nelse version(SPARC64)\n    enum TLS_DTV_OFFSET = 0x;\nelse version(PPC)\n    enum TLS_DTV_OFFSET = 0x8000;\nelse version(PPC64)\n    enum TLS_DTV_OFFSET = 0x8000;\nelse version(MIPS32)\n    enum TLS_DTV_OFFSET = 0x8000;\nelse version(MIPS64)\n    enum TLS_DTV_OFFSET = 0x8000;\nelse\n    static assert( false, \"Platform not supported.\" );\n\nvoid[] getTLSRange(size_t mod, size_t sz) nothrow @nogc\n{\n    if (mod == 0)\n        return null;\n\n    // base offset\n    auto ti = tls_index(mod, 0);\n    return (__tls_get_addr(&ti)-TLS_DTV_OFFSET)[0 .. sz];\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmd-2.081.1-vqq6jjlqlkf6xkxhau7opmwbvotgmaut/spack-src/druntime/src/core/sys/posix/dlfcn.d": "/**\n * D header file for POSIX.\n *\n * Copyright: Copyright Sean Kelly 2005 - 2009.\n * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n * Authors:   Sean Kelly, Alex R\u00f8nne Petersen\n * Standards: The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition\n */\n\n/*          Copyright Sean Kelly 2005 - 2009.\n * Distributed under the Boost Software License, Version 1.0.\n *    (See accompanying file LICENSE or copy at\n *          http://www.boost.org/LICENSE_1_0.txt)\n */\nmodule core.sys.posix.dlfcn;\n\nprivate import core.sys.posix.config;\n\nversion (OSX)\n    version = Darwin;\nelse version (iOS)\n    version = Darwin;\nelse version (TVOS)\n    version = Darwin;\nelse version (WatchOS)\n    version = Darwin;\n\nversion (Posix):\nextern (C):\nnothrow:\n@nogc:\n\n//\n// XOpen (XSI)\n//\n/*\nRTLD_LAZY\nRTLD_NOW\nRTLD_GLOBAL\nRTLD_LOCAL\n\nint   dlclose(void*);\nchar* dlerror();\nvoid* dlopen(in char*, int);\nvoid* dlsym(void*, in char*);\n*/\n\nversion( CRuntime_Glibc )\n{\n    version (X86)\n    {\n        enum RTLD_LAZY      = 0x00001;\n        enum RTLD_NOW       = 0x00002;\n        enum RTLD_GLOBAL    = 0x00100;\n        enum RTLD_LOCAL     = 0x00000;\n    }\n    else version (X86_64)\n    {\n        enum RTLD_LAZY      = 0x00001;\n        enum RTLD_NOW       = 0x00002;\n        enum RTLD_GLOBAL    = 0x00100;\n        enum RTLD_LOCAL     = 0x00000;\n    }\n    else version (MIPS32)\n    {\n        enum RTLD_LAZY      = 0x0001;\n        enum RTLD_NOW       = 0x0002;\n        enum RTLD_GLOBAL    = 0x0004;\n        enum RTLD_LOCAL     = 0;\n    }\n    else version (MIPS64)\n    {\n        enum RTLD_LAZY      = 0x0001;\n        enum RTLD_NOW       = 0x0002;\n        enum RTLD_GLOBAL    = 0x0004;\n        enum RTLD_LOCAL     = 0;\n    }\n    else version (PPC)\n    {\n        enum RTLD_LAZY      = 0x00001;\n        enum RTLD_NOW       = 0x00002;\n        enum RTLD_GLOBAL    = 0x00100;\n        enum RTLD_LOCAL     = 0;\n    }\n    else version (PPC64)\n    {\n        enum RTLD_LAZY      = 0x00001;\n        enum RTLD_NOW       = 0x00002;\n        enum RTLD_GLOBAL    = 0x00100;\n        enum RTLD_LOCAL     = 0;\n    }\n    else version (ARM)\n    {\n        enum RTLD_LAZY      = 0x00001;\n        enum RTLD_NOW       = 0x00002;\n        enum RTLD_GLOBAL    = 0x00100;\n        enum RTLD_LOCAL     = 0;\n    }\n    else version (AArch64)\n    {\n        enum RTLD_LAZY      = 0x00001;\n        enum RTLD_NOW       = 0x00002;\n        enum RTLD_GLOBAL    = 0x00100;\n        enum RTLD_LOCAL     = 0;\n    }\n    else version (SPARC64)\n    {\n        enum RTLD_LAZY      = 0x00001;\n        enum RTLD_NOW       = 0x00002;\n        enum RTLD_GLOBAL    = 0x00100;\n        enum RTLD_LOCAL     = 0;\n    }\n    else version (SystemZ)\n    {\n        enum RTLD_LAZY      = 0x00001;\n        enum RTLD_NOW       = 0x00002;\n        enum RTLD_GLOBAL    = 0x00100;\n        enum RTLD_LOCAL     = 0;\n    }\n    else\n        static assert(0, \"unimplemented\");\n\n    int   dlclose(void*);\n    char* dlerror();\n    void* dlopen(in char*, int);\n    void* dlsym(void*, in char*);\n\n    deprecated(\"Please use core.sys.linux.dlfcn for non-POSIX extensions\")\n    {\n        int   dladdr(in void* addr, Dl_info* info);\n        void* dlvsym(void* handle, in char* symbol, in char* version_);\n\n        struct Dl_info\n        {\n            const(char)* dli_fname;\n            void*        dli_fbase;\n            const(char)* dli_sname;\n            void*        dli_saddr;\n        }\n    }\n}\nelse version( Darwin )\n{\n    enum RTLD_LAZY      = 0x00001;\n    enum RTLD_NOW       = 0x00002;\n    enum RTLD_GLOBAL    = 0x00100;\n    enum RTLD_LOCAL     = 0x00000;\n\n    int   dlclose(void*);\n    char* dlerror();\n    void* dlopen(in char*, int);\n    void* dlsym(void*, in char*);\n    int   dladdr(void* addr, Dl_info* info);\n\n    struct Dl_info\n    {\n        const(char)* dli_fname;\n        void*        dli_fbase;\n        const(char)* dli_sname;\n        void*        dli_saddr;\n    }\n}\nelse version( FreeBSD )\n{\n    enum RTLD_LAZY      = 1;\n    enum RTLD_NOW       = 2;\n    enum RTLD_GLOBAL    = 0x100;\n    enum RTLD_LOCAL     = 0;\n\n    int   dlclose(void*);\n    char* dlerror();\n    void* dlopen(in char*, int);\n    void* dlsym(void*, in char*);\n    int   dladdr(const(void)* addr, Dl_info* info);\n\n    struct Dl_info\n    {\n        const(char)* dli_fname;\n        void*        dli_fbase;\n        const(char)* dli_sname;\n        void*        dli_saddr;\n    }\n}\nelse version(NetBSD)\n{\n    enum RTLD_LAZY      = 1;\n    enum RTLD_NOW       = 2;\n    enum RTLD_GLOBAL    = 0x100;\n    enum RTLD_LOCAL     = 0x200;\n    enum RTLD_NODELETE  = 0x01000;         /* Do not remove members. */\n    enum RTLD_NOLOAD    = 0x02000;\n\n    int   dlclose(void*);\n    char* dlerror();\n    void* dlopen(in char*, int);\n    void* dlsym(void*, in char*);\n    int   dladdr(const(void)* addr, Dl_info* info);\n\n    struct Dl_info\n    {\n        const(char)* dli_fname;\n        void*        dli_fbase;\n        const(char)* dli_sname;\n        void*        dli_saddr;\n    }\n}\nelse version( OpenBSD )\n{\n    enum RTLD_LAZY      = 1;\n    enum RTLD_NOW       = 2;\n    enum RTLD_GLOBAL    = 0x100;\n    enum RTLD_LOCAL     = 0;\n\n    int   dlclose(void*);\n    char* dlerror();\n    void* dlopen(in char*, int);\n    void* dlsym(void*, in char*);\n    int   dladdr(const(void)* addr, Dl_info* info);\n\n    struct Dl_info\n    {\n        const(char)* dli_fname;\n        void*        dli_fbase;\n        const(char)* dli_sname;\n        void*        dli_saddr;\n    }\n}\nelse version( DragonFlyBSD )\n{\n    enum RTLD_LAZY      = 1;\n    enum RTLD_NOW       = 2;\n    enum RTLD_GLOBAL    = 0x100;\n    enum RTLD_LOCAL     = 0;\n\n    int   dlclose(void*);\n    char* dlerror();\n    void* dlopen(in char*, int);\n    void* dlsym(void*, in char*);\n    int   dladdr(const(void)* addr, Dl_info* info);\n\n    struct Dl_info\n    {\n        const(char)* dli_fname;\n        void*        dli_fbase;\n        const(char)* dli_sname;\n        void*        dli_saddr;\n    }\n}\nelse version( Solaris )\n{\n    enum RTLD_LAZY      = 1;\n    enum RTLD_NOW       = 2;\n    enum RTLD_GLOBAL    = 0x100;\n    enum RTLD_LOCAL     = 0;\n\n    int   dlclose(void*);\n    char* dlerror();\n    void* dlopen(in char*, int);\n    void* dlsym(void*, in char*);\n    int   dladdr(const(void)* addr, Dl_info* info);\n\n    struct Dl_info\n    {\n        const(char)* dli_fname;\n        void*        dli_fbase;\n        const(char)* dli_sname;\n        void*        dli_saddr;\n    }\n}\nelse version( CRuntime_Bionic )\n{\n    enum\n    {\n        RTLD_NOW    = 0,\n        RTLD_LAZY   = 1,\n        RTLD_LOCAL  = 0,\n        RTLD_GLOBAL = 2\n    }\n\n    int          dladdr(in void*, Dl_info*);\n    int          dlclose(void*);\n    const(char)* dlerror();\n    void*        dlopen(in char*, int);\n    void*        dlsym(void*, in char*);\n\n    struct Dl_info\n    {\n        const(char)* dli_fname;\n        void*        dli_fbase;\n        const(char)* dli_sname;\n        void*        dli_saddr;\n    }\n}\nelse version( CRuntime_Musl )\n{\n    enum {\n        RTLD_LAZY     = 1,\n        RTLD_NOW      = 2,\n        RTLD_NOLOAD   = 4,\n        RTLD_NODELETE = 4096,\n        RTLD_GLOBAL   = 256,\n        RTLD_LOCAL    = 0,\n    }\n    int          dlclose(void*);\n    const(char)* dlerror();\n    void*        dlopen(in char*, int);\n    void*        dlsym(void*, in char*);\n}\nelse version( CRuntime_UClibc )\n{\n    version (X86_64)\n    {\n        enum RTLD_LAZY              = 0x0001;\n        enum RTLD_NOW               = 0x0002;\n        enum RTLD_BINDING_MASK      = 0x3;\n        enum RTLD_NOLOAD            = 0x00004;\n        enum RTLD_GLOBAL            = 0x00100;\n        enum RTLD_LOCAL             = 0;\n        enum RTLD_NODELETE          = 0x01000;\n    }\n    else version (MIPS32)\n    {\n        enum RTLD_LAZY              = 0x0001;\n        enum RTLD_NOW               = 0x0002;\n        enum RTLD_BINDING_MASK      = 0x3;\n        enum RTLD_NOLOAD            = 0x00008;\n        enum RTLD_GLOBAL            = 0x0004;\n        enum RTLD_LOCAL             = 0;\n        enum RTLD_NODELETE          = 0x01000;\n    }\n    else version (ARM)\n    {\n        enum RTLD_LAZY              = 0x0001;\n        enum RTLD_NOW               = 0x0002;\n        enum RTLD_BINDING_MASK      = 0x3;\n        enum RTLD_NOLOAD            = 0x00004;\n        enum RTLD_GLOBAL            = 0x00100;\n        enum RTLD_LOCAL             = 0;\n        enum RTLD_NODELETE          = 0x01000;\n    }\n    else\n        static assert(0, \"unimplemented\");\n\n    int   dlclose(void*);\n    char* dlerror();\n    void* dlopen(in char*, int);\n    void* dlsym(void*, in char*);\n}",
        "/tmp/vanessa/spack-stage/spack-stage-dmd-2.081.1-vqq6jjlqlkf6xkxhau7opmwbvotgmaut/spack-src/druntime/src/core/sys/linux/dlfcn.d": "/**\n * D header file for GNU/Linux\n *\n * $(LINK2 http://sourceware.org/git/?p=glibc.git;a=blob;f=dlfcn/dlfcn.h, glibc dlfcn/dlfcn.h)\n */\nmodule core.sys.linux.dlfcn;\n\nversion (linux):\nextern (C):\nnothrow:\n@nogc:\n\npublic import core.sys.posix.dlfcn;\nimport core.sys.linux.config;\n\n// <bits/dlfcn.h>\nversion (X86)\n{\n    // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n    // enum RTLD_LAZY = 0x00001; // POSIX\n    // enum RTLD_NOW = 0x00002; // POSIX\n    enum RTLD_BINDING_MASK = 0x3;\n    enum RTLD_NOLOAD = 0x00004;\n    enum RTLD_DEEPBIND = 0x00008;\n\n    // enum RTLD_GLOBAL = 0x00100; // POSIX\n    // enum RTLD_LOCAL = 0; // POSIX\n    enum RTLD_NODELETE = 0x01000;\n\n    static if (__USE_GNU)\n    {\n        RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n        {\n            _dl_mcount_wrapper_check(cast(void*)fctp);\n            return fctp(args);\n        }\n\n        void _dl_mcount_wrapper_check(void* __selfpc);\n    }\n}\nelse version (X86_64)\n{\n    // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n    // enum RTLD_LAZY = 0x00001; // POSIX\n    // enum RTLD_NOW = 0x00002; // POSIX\n    enum RTLD_BINDING_MASK = 0x3;\n    enum RTLD_NOLOAD = 0x00004;\n    enum RTLD_DEEPBIND = 0x00008;\n\n    // enum RTLD_GLOBAL = 0x00100; // POSIX\n    // enum RTLD_LOCAL = 0; // POSIX\n    enum RTLD_NODELETE = 0x01000;\n\n    static if (__USE_GNU)\n    {\n        RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n        {\n            _dl_mcount_wrapper_check(cast(void*)fctp);\n            return fctp(args);\n        }\n\n        void _dl_mcount_wrapper_check(void* __selfpc);\n    }\n}\nelse version (MIPS32)\n{\n    // http://sourceware.org/git/?p=glibc.git;a=blob;f=ports/sysdeps/mips/bits/dlfcn.h\n    // enum RTLD_LAZY = 0x0001; // POSIX\n    // enum RTLD_NOW = 0x0002; // POSIX\n    enum RTLD_BINDING_MASK = 0x3;\n    enum RTLD_NOLOAD = 0x00008;\n    enum RTLD_DEEPBIND = 0x00010;\n\n    // enum RTLD_GLOBAL = 0x0004; // POSIX\n    // enum RTLD_LOCAL = 0; // POSIX\n    enum RTLD_NODELETE = 0x01000;\n\n    static if (__USE_GNU)\n    {\n        RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n        {\n            _dl_mcount_wrapper_check(cast(void*)fctp);\n            return fctp(args);\n        }\n\n        void _dl_mcount_wrapper_check(void* __selfpc);\n    }\n}\nelse version (MIPS64)\n{\n    // http://sourceware.org/git/?p=glibc.git;a=blob;f=ports/sysdeps/mips/bits/dlfcn.h\n    // enum RTLD_LAZY = 0x0001; // POSIX\n    // enum RTLD_NOW = 0x0002; // POSIX\n    enum RTLD_BINDING_MASK = 0x3;\n    enum RTLD_NOLOAD = 0x00008;\n    enum RTLD_DEEPBIND = 0x00010;\n\n    // enum RTLD_GLOBAL = 0x0004; // POSIX\n    // enum RTLD_LOCAL = 0; // POSIX\n    enum RTLD_NODELETE = 0x01000;\n\n    static if (__USE_GNU)\n    {\n        RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n        {\n            _dl_mcount_wrapper_check(cast(void*)fctp);\n            return fctp(args);\n        }\n\n        void _dl_mcount_wrapper_check(void* __selfpc);\n    }\n}\nelse version (PPC)\n{\n    // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n    // enum RTLD_LAZY = 0x0001; // POSIX\n    // enum RTLD_NOW = 0x0002; // POSIX\n    enum RTLD_BINDING_MASK = 0x3;\n    enum RTLD_NOLOAD = 0x00004;\n    enum RTLD_DEEPBIND = 0x00008;\n\n    // enum RTLD_GLOBAL = 0x00100; // POSIX\n    // enum RTLD_LOCAL = 0; // POSIX\n    enum RTLD_NODELETE = 0x01000;\n\n    static if (__USE_GNU)\n    {\n        RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n        {\n            _dl_mcount_wrapper_check(cast(void*)fctp);\n            return fctp(args);\n        }\n\n        void _dl_mcount_wrapper_check(void* __selfpc);\n    }\n}\nelse version (PPC64)\n{\n    // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n    // enum RTLD_LAZY = 0x0001; // POSIX\n    // enum RTLD_NOW = 0x0002; // POSIX\n    enum RTLD_BINDING_MASK = 0x3;\n    enum RTLD_NOLOAD = 0x00004;\n    enum RTLD_DEEPBIND = 0x00008;\n\n    // enum RTLD_GLOBAL = 0x00100; // POSIX\n    // enum RTLD_LOCAL = 0; // POSIX\n    enum RTLD_NODELETE = 0x01000;\n\n    static if (__USE_GNU)\n    {\n        RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n        {\n            _dl_mcount_wrapper_check(cast(void*)fctp);\n            return fctp(args);\n        }\n\n        void _dl_mcount_wrapper_check(void* __selfpc);\n    }\n}\nelse version (ARM)\n{\n    // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n    // enum RTLD_LAZY = 0x0001; // POSIX\n    // enum RTLD_NOW = 0x0002; // POSIX\n    enum RTLD_BINDING_MASK = 0x3;\n    enum RTLD_NOLOAD = 0x00004;\n    enum RTLD_DEEPBIND = 0x00008;\n\n    // enum RTLD_GLOBAL = 0x00100; // POSIX\n    // enum RTLD_LOCAL = 0; // POSIX\n    enum RTLD_NODELETE = 0x01000;\n\n    static if (__USE_GNU)\n    {\n        RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n        {\n            _dl_mcount_wrapper_check(cast(void*)fctp);\n            return fctp(args);\n        }\n\n        void _dl_mcount_wrapper_check(void* __selfpc);\n    }\n}\nelse version (AArch64)\n{\n    // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n    // enum RTLD_LAZY = 0x0001; // POSIX\n    // enum RTLD_NOW = 0x0002; // POSIX\n    enum RTLD_BINDING_MASK = 0x3;\n    enum RTLD_NOLOAD = 0x00004;\n    enum RTLD_DEEPBIND = 0x00008;\n\n    // enum RTLD_GLOBAL = 0x00100; // POSIX\n    // enum RTLD_LOCAL = 0; // POSIX\n    enum RTLD_NODELETE = 0x01000;\n\n    static if (__USE_GNU)\n    {\n        RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n        {\n            _dl_mcount_wrapper_check(cast(void*)fctp);\n            return fctp(args);\n        }\n\n        void _dl_mcount_wrapper_check(void* __selfpc);\n    }\n}\nelse version (SPARC64)\n{\n    // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n    // enum RTLD_LAZY = 0x0001; // POSIX\n    // enum RTLD_NOW = 0x0002; // POSIX\n    enum RTLD_BINDING_MASK = 0x3;\n    enum RTLD_NOLOAD = 0x00004;\n    enum RTLD_DEEPBIND = 0x00008;\n\n    // enum RTLD_GLOBAL = 0x00100; // POSIX\n    // enum RTLD_LOCAL = 0; // POSIX\n    enum RTLD_NODELETE = 0x01000;\n\n    static if (__USE_GNU)\n    {\n        RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n        {\n            _dl_mcount_wrapper_check(cast(void*)fctp);\n            return fctp(args);\n        }\n\n        void _dl_mcount_wrapper_check(void* __selfpc);\n    }\n}\nelse version (SystemZ)\n{\n    // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n    // enum RTLD_LAZY = 0x0001; // POSIX\n    // enum RTLD_NOW = 0x0002; // POSIX\n    enum RTLD_BINDING_MASK = 0x3;\n    enum RTLD_NOLOAD = 0x00004;\n    enum RTLD_DEEPBIND = 0x00008;\n\n    // enum RTLD_GLOBAL = 0x00100; // POSIX\n    // enum RTLD_LOCAL = 0; // POSIX\n    enum RTLD_NODELETE = 0x01000;\n\n    static if (__USE_GNU)\n    {\n        RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n        {\n            _dl_mcount_wrapper_check(cast(void*)fctp);\n            return fctp(args);\n        }\n\n        void _dl_mcount_wrapper_check(void* __selfpc);\n    }\n}\nelse\n    static assert(0, \"unimplemented\");\n\n// <bits/dlfcn.h>\n\nstatic if (__USE_GNU)\n{\n    enum RTLD_NEXT = cast(void *)-1L;\n    enum RTLD_DEFAULT = cast(void *)0;\n    alias c_long Lmid_t;\n    enum LM_ID_BASE = 0;\n    enum LM_ID_NEWLM = -1;\n}\n\n// void* dlopen(in char* __file, int __mode); // POSIX\n// int dlclose(void* __handle); // POSIX\n// void* dlsym(void* __handle, in char* __name); // POSIX\n\nstatic if (__USE_GNU)\n{\n    void* dlmopen(Lmid_t __nsid, in char* __file, int __mode);\n    void* dlvsym(void* __handle, in char* __name, in char* __version);\n}\n\n// char* dlerror(); // POSIX\n\nstatic if (__USE_GNU)\n{\n    struct Dl_info\n    {\n        const(char)* dli_fname;\n        void* dli_fbase;\n        const(char)* dli_sname;\n        void* dli_saddr;\n    }\n\n    int dladdr(in void* __address, Dl_info* __info);\n    int dladdr1(void* __address, Dl_info* __info, void** __extra_info, int __flags);\n\n    enum\n    {\n        RTLD_DL_SYMENT = 1,\n        RTLD_DL_LINKMAP = 2,\n    }\n\n    int dlinfo(void* __handle, int __request, void* __arg);\n\n    enum\n    {\n        RTLD_DI_LMID = 1,\n        RTLD_DI_LINKMAP = 2,\n        RTLD_DI_CONFIGADDR = 3,\n        RTLD_DI_SERINFO = 4,\n        RTLD_DI_SERINFOSIZE = 5,\n        RTLD_DI_ORIGIN = 6,\n        RTLD_DI_PROFILENAME = 7,\n        RTLD_DI_PROFILEOUT = 8,\n        RTLD_DI_TLS_MODID = 9,\n        RTLD_DI_TLS_DATA = 10,\n        RTLD_DI_MAX = 10,\n    }\n\n    struct Dl_serpath\n    {\n        char* dls_name;\n        uint dls_flags;\n    }\n\n    struct Dl_serinfo\n    {\n        size_t dls_size;\n        uint dls_cnt;\n        Dl_serpath[1] dls_serpath;\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmd-2.081.1-vqq6jjlqlkf6xkxhau7opmwbvotgmaut/spack-src/druntime/src/core/sys/dragonflybsd/dlfcn.d": "/**\n * D header file for DragonFlyBSD\n *\n * Copyright: Copyright Martin Nowak 2012.\n * License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n * Authors: Martin Nowak,Diederik de Groot(port:DragonFlyBSD)\n * Copied:  From core/sys/freebsd/sys\n */\nmodule core.sys.dragonflybsd.dlfcn;\n\nversion (DragonFlyBSD):\n\npublic import core.sys.posix.dlfcn;\n\nextern (C) nothrow @nogc @system:\n\n/*\n * Modes and flags for dlopen().\n */\nstatic assert(RTLD_LAZY   == 1);\nstatic assert(RTLD_NOW    == 2);\nenum RTLD_MODEMASK        =  0x3;\nstatic assert(RTLD_GLOBAL == 0x100);\nstatic assert(RTLD_LOCAL  == 0);\nenum RTLD_TRACE           =  0x200;\nenum RTLD_NODELETE        =  0x01000;\nenum RTLD_NOLOAD          =  0x02000;\n\n/*\n * Request arguments for dlinfo().\n */\nenum RTLD_DI_LINKMAP     = 2;    /* Obtain link map. */\nenum RTLD_DI_SERINFO     = 4;    /* Obtain search path info. */\nenum RTLD_DI_SERINFOSIZE = 5;    /*  ... query for required space. */\nenum RTLD_DI_ORIGIN      = 6;    /* Obtain object origin */\nenum RTLD_DI_MAX         = RTLD_DI_ORIGIN;\n\n/*\n * Special handle arguments for dlsym()/dlinfo().\n */\nenum RTLD_NEXT    = cast(void *)-1;    /* Search subsequent objects. */\nenum RTLD_DEFAULT = cast(void *)-2;    /* Use default search algorithm. */\nenum RTLD_SELF    = cast(void *)-3;    /* Search the caller itself. */\n\n/*\n * Structure filled in by dladdr().\n */\nstruct Dl_info {\n    const(char)     *dli_fname;     /* Pathname of shared object. */\n    void            *dli_fbase;     /* Base address of shared object. */\n    const(char)     *dli_sname;     /* Name of nearest symbol. */\n    void            *dli_saddr;     /* Address of nearest symbol. */\n};\n\n\n/*\n * Structures, returned by the RTLD_DI_SERINFO dlinfo() request.\n */\nstruct Dl_serpath {\n    char *          dls_name;       /* single search path entry */\n    uint            dls_flags;      /* path information */\n};\n\nstruct Dl_serinfo {\n    size_t          dls_size;       /* total buffer size */\n    uint            dls_cnt;        /* number of path entries */\n    Dl_serpath[1]   dls_serpath;    /* there may be more than one */\n};\n\n/*-\n * The actual type declared by this typedef is immaterial, provided that\n * it is a function pointer.  Its purpose is to provide a return type for\n * dlfunc() which can be cast to a function pointer type without depending\n * on behavior undefined by the C standard, which might trigger a compiler\n * diagnostic.  We intentionally declare a unique type signature to force\n * a diagnostic should the application not cast the return value of dlfunc()\n * appropriately.\n */\nstruct __dlfunc_arg {\n    int     __dlfunc_dummy;\n};\n\nalias dlfunc_t = void function(__dlfunc_arg);\n\nprivate template __externC(RT, P...)\n{\n    alias __externC = extern(C) RT function(P) nothrow @nogc @system;\n}\n\n/* XSI functions first. */\nstatic assert(is(typeof(&dlclose) == __externC!(int, void*)));\nstatic assert(is(typeof(&dlerror) == __externC!(char*)));\nstatic assert(is(typeof(&dlopen)  == __externC!(void*, const char*, int)));\nstatic assert(is(typeof(&dlsym)   == __externC!(void*, void*, const char*)));\n\nvoid*    fdlopen(int, int);\nint      dladdr(const(void)*, Dl_info*);\ndlfunc_t dlfunc(void*, const(char)*);\nint      dlinfo(void*, int, void*);\n/*void     dllockinit(void* _context,\n    void* function(void* _context) _lock_create,\n    void  function(void* _lock)    _rlock_acquire,\n    void  function(void* _lock)    _wlock_acquire,\n    void  function(void* _lock)    _lock_release,\n    void  function(void* _lock)    _lock_destroy,\n    void  function(void* _context) _context_destroy);*/\nvoid*    dlvsym(void*, const(char)*, const(char)*);\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmd-2.081.1-vqq6jjlqlkf6xkxhau7opmwbvotgmaut/spack-src/druntime/src/core/sys/freebsd/dlfcn.d": "/**\n * D header file for FreeBSD.\n *\n * Copyright: Copyright Martin Nowak 2012.\n * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n * Authors:   Martin Nowak\n */\nmodule core.sys.freebsd.dlfcn;\n\npublic import core.sys.posix.dlfcn;\n\nversion (FreeBSD):\nextern (C):\nnothrow:\n@nogc:\n\nenum __BSD_VISIBLE = true;\n\n/*\n * Modes and flags for dlopen().\n */\nstatic assert(RTLD_LAZY   == 1);\nstatic assert(RTLD_NOW    == 2);\nenum RTLD_MODEMASK        =  0x3;\nstatic assert(RTLD_GLOBAL == 0x100);\nstatic assert(RTLD_LOCAL  == 0);\nenum RTLD_TRACE           =  0x200;\nenum RTLD_NODELETE        =  0x01000;\nenum RTLD_NOLOAD          =  0x02000;\n\n/*\n * Request arguments for dlinfo().\n */\nenum RTLD_DI_LINKMAP     = 2;    /* Obtain link map. */\nenum RTLD_DI_SERINFO     = 4;    /* Obtain search path info. */\nenum RTLD_DI_SERINFOSIZE = 5;    /*  ... query for required space. */\nenum RTLD_DI_ORIGIN      = 6;    /* Obtain object origin */\nenum RTLD_DI_MAX         = RTLD_DI_ORIGIN;\n\n/*\n * Special handle arguments for dlsym()/dlinfo().\n */\nenum RTLD_NEXT    = cast(void *)-1;    /* Search subsequent objects. */\nenum RTLD_DEFAULT = cast(void *)-2;    /* Use default search algorithm. */\nenum RTLD_SELF    = cast(void *)-3;    /* Search the caller itself. */\n\nstatic if (__BSD_VISIBLE)\n{\n    /*\n     * Structure filled in by dladdr().\n     */\n    struct Dl_info {\n        const(char)     *dli_fname;     /* Pathname of shared object. */\n        void            *dli_fbase;     /* Base address of shared object. */\n        const(char)     *dli_sname;     /* Name of nearest symbol. */\n        void            *dli_saddr;     /* Address of nearest symbol. */\n    };\n\n    /*-\n     * The actual type declared by this typedef is immaterial, provided that\n     * it is a function pointer.  Its purpose is to provide a return type for\n     * dlfunc() which can be cast to a function pointer type without depending\n     * on behavior undefined by the C standard, which might trigger a compiler\n     * diagnostic.  We intentionally declare a unique type signature to force\n     * a diagnostic should the application not cast the return value of dlfunc()\n     * appropriately.\n     */\n    struct __dlfunc_arg {\n        int     __dlfunc_dummy;\n    };\n\n    alias dlfunc_t = void function(__dlfunc_arg);\n\n    /*\n     * Structures, returned by the RTLD_DI_SERINFO dlinfo() request.\n     */\n    struct Dl_serpath {\n        char *          dls_name;       /* single search path entry */\n        uint            dls_flags;      /* path information */\n    };\n\n    struct Dl_serinfo {\n        size_t          dls_size;       /* total buffer size */\n        uint            dls_cnt;        /* number of path entries */\n        Dl_serpath[1]   dls_serpath;    /* there may be more than one */\n    };\n}\n\nprivate template __externC(RT, P...)\n{\n    alias __externC = extern(C) RT function(P) nothrow @nogc;\n}\n\n/* XSI functions first. */\nstatic assert(is(typeof(&dlclose) == __externC!(int, void*)));\nstatic assert(is(typeof(&dlerror) == __externC!(char*)));\nstatic assert(is(typeof(&dlopen)  == __externC!(void*, const char*, int)));\nstatic assert(is(typeof(&dlsym)   == __externC!(void*, void*, const char*)));\n\nstatic if (__BSD_VISIBLE)\n{\n    void*    fdlopen(int, int);\n    int      dladdr(const(void)*, Dl_info*);\n    dlfunc_t dlfunc(void*, const(char)*);\n    int      dlinfo(void*, int, void*);\n    void     dllockinit(void* _context,\n        void* function(void* _context) _lock_create,\n        void  function(void* _lock)    _rlock_acquire,\n        void  function(void* _lock)    _wlock_acquire,\n        void  function(void* _lock)    _lock_release,\n        void  function(void* _lock)    _lock_destroy,\n        void  function(void* _context) _context_destroy);\n    void*    dlvsym(void*, const(char)*, const(char)*);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmd-2.081.1-vqq6jjlqlkf6xkxhau7opmwbvotgmaut/spack-src/druntime/src/core/sys/netbsd/dlfcn.d": "/**\n * D header file for NetBSD.\n *\n * Copyright: Copyright Martin Nowak 2012.\n * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n * Authors:   Martin Nowak\n *\n * http://cvsweb.netbsd.org/bsdweb.cgi/~checkout~/src/include/dlfcn.h\n */\nmodule core.sys.netbsd.dlfcn;\n\npublic import core.sys.posix.dlfcn;\n\nversion (NetBSD):\nextern (C):\nnothrow:\n@nogc:\n\nenum __BSD_VISIBLE = true;\n\n/*\n * Modes and flags for dlopen().\n */\nstatic assert(RTLD_LAZY   == 1);\nstatic assert(RTLD_NOW    == 2);\nstatic assert(RTLD_GLOBAL == 0x100);\nstatic assert(RTLD_LOCAL  == 0x200);\n//enum RTLD_TRACE           =  0x200;\nenum RTLD_NODELETE        =  0x01000;\nenum RTLD_NOLOAD          =  0x02000;\n\n/*\n * Request arguments for dlinfo().\n */\nenum RTLD_DI_LINKMAP     = 3;    /* Obtain link map. */\nenum RTLD_DI_SERINFO     = 5;    /* Obtain search path info. */\nenum RTLD_DI_SERINFOSIZE = 6;    /*  ... query for required space. */\nenum RTLD_DI_ORIGIN      = 7;    /* Obtain object origin */\nenum RTLD_DI_MAX         = RTLD_DI_ORIGIN;\n\n/*\n * Special handle arguments for dlsym()/dlinfo().\n */\nenum RTLD_NEXT    = cast(void *)-1;    /* Search subsequent objects. */\nenum RTLD_DEFAULT = cast(void *)-2;    /* Use default search algorithm. */\nenum RTLD_SELF    = cast(void *)-3;    /* Search the caller itself. */\n\nstatic if (__BSD_VISIBLE)\n{\n    /*\n     * Structure filled in by dladdr().\n     */\n    struct Dl_info {\n        const(char)     *dli_fname;     /* Pathname of shared object. */\n        void            *dli_fbase;     /* Base address of shared object. */\n        const(char)     *dli_sname;     /* Name of nearest symbol. */\n        void            *dli_saddr;     /* Address of nearest symbol. */\n    };\n\n    /*-\n     * The actual type declared by this typedef is immaterial, provided that\n     * it is a function pointer.  Its purpose is to provide a return type for\n     * dlfunc() which can be cast to a function pointer type without depending\n     * on behavior undefined by the C standard, which might trigger a compiler\n     * diagnostic.  We intentionally declare a unique type signature to force\n     * a diagnostic should the application not cast the return value of dlfunc()\n     * appropriately.\n     */\n    struct __dlfunc_arg {\n        int     __dlfunc_dummy;\n    };\n\n    alias dlfunc_t = void function(__dlfunc_arg);\n\n    /*\n     * Structures, returned by the RTLD_DI_SERINFO dlinfo() request.\n     */\n    struct Dl_serpath {\n        char *          dls_name;       /* single search path entry */\n        uint            dls_flags;      /* path information */\n    };\n\n    struct Dl_serinfo {\n        size_t          dls_size;       /* total buffer size */\n        uint            dls_cnt;        /* number of path entries */\n        Dl_serpath[1]   dls_serpath;    /* there may be more than one */\n    };\n}\n\nprivate template __externC(RT, P...)\n{\n    alias __externC = extern(C) RT function(P) nothrow @nogc;\n}\n\n/* XSI functions first. */\nstatic assert(is(typeof(&dlclose) == __externC!(int, void*)));\nstatic assert(is(typeof(&dlerror) == __externC!(char*)));\nstatic assert(is(typeof(&dlopen)  == __externC!(void*, const char*, int)));\nstatic assert(is(typeof(&dlsym)   == __externC!(void*, void*, const char*)));\n\nstatic if (__BSD_VISIBLE)\n{\n    //void*    fdlopen(int, int);\n    int      dladdr(const(void)*, Dl_info*);\n    //dlfunc_t dlfunc(void*, const(char)*);\n    //int      dlinfo(void*, int, void*);\n    /+void     dllockinit(void* _context,\n        void* function(void* _context) _lock_create,\n        void  function(void* _lock)    _rlock_acquire,\n        void  function(void* _lock)    _wlock_acquire,\n        void  function(void* _lock)    _lock_release,\n        void  function(void* _lock)    _lock_destroy,\n        void  function(void* _context) _context_destroy);+/\n    void*    dlvsym(void*, const(char)*, const(char)*);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmd-2.081.1-vqq6jjlqlkf6xkxhau7opmwbvotgmaut/spack-src/druntime/test/shared/src/loadDR.c": "#include <stdlib.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <assert.h>\n\nint main(int argc, char* argv[])\n{\n    if (argc != 2)\n        return EXIT_FAILURE;\n    void *h = dlopen(argv[1], RTLD_LAZY); // load druntime\n    assert(h != NULL);\n\n    int (*rt_init)(void) = dlsym(h, \"rt_init\");\n    int (*rt_term)(void) = dlsym(h, \"rt_term\");\n    void* (*rt_loadLibrary)(const char*) = dlsym(h, \"rt_loadLibrary\");\n    int (*rt_unloadLibrary)(void*) = dlsym(h, \"rt_unloadLibrary\");\n\n    int res = EXIT_FAILURE;\n    if (!rt_init()) goto Lexit;\n\n    const size_t pathlen = strrchr(argv[0], '/') - argv[0] + 1;\n    char *name = malloc(pathlen + sizeof(\"lib.so\"));\n    memcpy(name, argv[0], pathlen);\n    memcpy(name+pathlen, \"lib.so\", sizeof(\"lib.so\"));\n\n    void *dlib = rt_loadLibrary(name);\n    free(name);\n    assert(dlib);\n\n    int (*runTests)(void) = dlsym(dlib, \"runTests\");\n    assert(runTests());\n    assert(rt_unloadLibrary(dlib));\n\n    if (rt_term()) res = EXIT_SUCCESS;\n\nLexit:\n    assert(dlclose(h) == 0);\n    return res;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmd-2.081.1-vqq6jjlqlkf6xkxhau7opmwbvotgmaut/spack-src/druntime/test/shared/src/host.c": "#include <stdlib.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <assert.h>\n\nint main(int argc, char* argv[])\n{\n#if defined(__FreeBSD__)\n    // workaround for Bugzilla 14824\n    void *druntime = dlopen(argv[1], RTLD_LAZY); // load druntime\n    assert(druntime);\n#endif\n#if defined(__DragonFly__)\n    // workaround for Bugzilla 14824\n    void *druntime = dlopen(argv[1], RTLD_LAZY); // load druntime\n    assert(druntime);\n#endif\n\n    const size_t pathlen = strrchr(argv[0], '/') - argv[0] + 1;\n    char *name = malloc(pathlen + sizeof(\"plugin1.so\"));\n    memcpy(name, argv[0], pathlen);\n    memcpy(name+pathlen, \"plugin1.so\", sizeof(\"plugin1.so\"));\n\n    void* plugin1 = dlopen(name, RTLD_LAZY);\n    name[pathlen + sizeof(\"plugin1.so\") - 5] = '2';\n    void* plugin2 = dlopen(name, RTLD_LAZY);\n\n    int (*plugin1_init)() = dlsym(plugin1, \"plugin_init\");\n    int (*plugin1_term)() = dlsym(plugin1, \"plugin_term\");\n    int (*runTests1)() = dlsym(plugin1, \"runTests\");\n    int (*plugin2_init)() = dlsym(plugin2, \"plugin_init\");\n    int (*plugin2_term)() = dlsym(plugin2, \"plugin_term\");\n    int (*runTests2)() = dlsym(plugin2, \"runTests\");\n    assert(plugin1_init());\n    assert(runTests1());\n    assert(plugin2_init());\n    assert(runTests2());\n\n    assert(plugin1_term());\n    assert(dlclose(plugin1) == 0);\n    assert(runTests2());\n\n    name[pathlen + sizeof(\"plugin1.so\") - 5] = '1';\n    plugin1 = dlopen(name, RTLD_LAZY);\n    plugin1_init = dlsym(plugin1, \"plugin_init\");\n    plugin1_term = dlsym(plugin1, \"plugin_term\");\n    runTests1 = dlsym(plugin1, \"runTests\");\n    assert(plugin1_init());\n    assert(runTests1());\n    assert(runTests2());\n\n    assert(plugin2_term());\n    assert(dlclose(plugin2) == 0);\n    assert(runTests1());\n\n    assert(plugin1_term());\n    assert(dlclose(plugin1) == 0);\n\n    free(name);\n\n#if defined(__FreeBSD__)\n    dlclose(druntime);\n#endif\n#if defined(__DragonFly__)\n    dlclose(druntime);\n#endif\n    return EXIT_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmd-2.081.1-vqq6jjlqlkf6xkxhau7opmwbvotgmaut/spack-src/druntime/test/shared/src/load.d": "import core.runtime;\nimport core.stdc.stdio;\nimport core.stdc.string;\nimport core.thread;\n\nversion (linux) import core.sys.linux.dlfcn;\nelse version (FreeBSD) import core.sys.freebsd.dlfcn;\nelse version (DragonFlyBSD) import core.sys.dragonflybsd.dlfcn;\nelse version (NetBSD) import core.sys.netbsd.dlfcn;\nelse static assert(0, \"unimplemented\");\n\nvoid loadSym(T)(void* handle, ref T val, const char* mangle)\n{\n    val = cast(T).dlsym(handle, mangle);\n}\n\nvoid* openLib(string s)\n{\n    auto h = Runtime.loadLibrary(s);\n    assert(h !is null);\n\n    loadSym(h, libThrowException, \"_D3lib14throwExceptionFZv\");\n    loadSym(h, libCollectException, \"_D3lib16collectExceptionFDFZvZC9Exception\");\n\n    loadSym(h, libAlloc, \"_D3lib5allocFZv\");\n    loadSym(h, libTlsAlloc, \"_D3lib9tls_allocFZv\");\n    loadSym(h, libAccess, \"_D3lib6accessFZv\");\n    loadSym(h, libTlsAccess, \"_D3lib10tls_accessFZv\");\n    loadSym(h, libFree, \"_D3lib4freeFZv\");\n    loadSym(h, libTlsFree, \"_D3lib8tls_freeFZv\");\n\n    loadSym(h, libSharedStaticCtor, \"_D3lib18shared_static_ctorOk\");\n    loadSym(h, libSharedStaticDtor, \"_D3lib18shared_static_dtorOk\");\n    loadSym(h, libStaticCtor, \"_D3lib11static_ctorOk\");\n    loadSym(h, libStaticDtor, \"_D3lib11static_dtorOk\");\n\n    return h;\n}\n\nvoid closeLib(void* h)\n{\n    Runtime.unloadLibrary(h);\n}\n\n__gshared\n{\n    void function() libThrowException;\n    Exception function(void delegate()) libCollectException;\n\n    void function() libAlloc;\n    void function() libTlsAlloc;\n    void function() libAccess;\n    void function() libTlsAccess;\n    void function() libFree;\n    void function() libTlsFree;\n\n    shared uint* libSharedStaticCtor;\n    shared uint* libSharedStaticDtor;\n    shared uint* libStaticCtor;\n    shared uint* libStaticDtor;\n}\n\nvoid testEH()\n{\n    bool passed;\n    try\n        libThrowException();\n    catch (Exception e)\n        passed = true;\n    assert(passed); passed = false;\n\n    assert(libCollectException({throw new Exception(null);}) !is null);\n    assert(libCollectException({libThrowException();}) !is null);\n}\n\nvoid testGC()\n{\n    import core.memory;\n    libAlloc();\n    libTlsAlloc();\n    libAccess();\n    libTlsAccess();\n    GC.collect();\n    libTlsAccess();\n    libAccess();\n    libTlsFree();\n    libFree();\n}\n\nvoid testInit()\n{\n\n    assert(*libStaticCtor == 1);\n    assert(*libStaticDtor == 0);\n    static void run()\n    {\n        assert(*libSharedStaticCtor == 1);\n        assert(*libSharedStaticDtor == 0);\n        assert(*libStaticCtor == 2);\n        assert(*libStaticDtor == 0);\n    }\n    auto thr = new Thread(&run);\n    thr.start();\n    thr.join();\n    assert(*libSharedStaticCtor == 1);\n    assert(*libSharedStaticDtor == 0);\n    assert(*libStaticCtor == 2);\n    assert(*libStaticDtor == 1);\n}\n\nconst(ModuleInfo)* findModuleInfo(string name)\n{\n    foreach (m; ModuleInfo)\n        if (m.name == name) return m;\n    return null;\n}\n\nvoid runTests(string libName)\n{\n    assert(findModuleInfo(\"lib\") is null);\n    auto handle = openLib(libName);\n    assert(findModuleInfo(\"lib\") !is null);\n\n    testEH();\n    testGC();\n    testInit();\n\n    closeLib(handle);\n    assert(findModuleInfo(\"lib\") is null);\n}\n\nvoid main(string[] args)\n{\n    auto name = args[0] ~ '\\0';\n    const pathlen = strrchr(name.ptr, '/') - name.ptr + 1;\n    name = name[0 .. pathlen] ~ \"lib.so\";\n\n    runTests(name);\n\n    // lib is no longer resident\n    name ~= '\\0';\n    assert(.dlopen(name.ptr, RTLD_LAZY | RTLD_NOLOAD) is null);\n    name = name[0 .. $-1];\n\n    auto thr = new Thread({runTests(name);});\n    thr.start();\n    thr.join();\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-dmd-2.081.1-vqq6jjlqlkf6xkxhau7opmwbvotgmaut/spack-src/druntime/src/rt/minit.obj",
        "/tmp/vanessa/spack-stage/spack-stage-dmd-2.081.1-vqq6jjlqlkf6xkxhau7opmwbvotgmaut/spack-src/test/runnable/helloUTF16.d",
        "/tmp/vanessa/spack-stage/spack-stage-dmd-2.081.1-vqq6jjlqlkf6xkxhau7opmwbvotgmaut/spack-src/test/runnable/testUTF32.d",
        "/tmp/vanessa/spack-stage/spack-stage-dmd-2.081.1-vqq6jjlqlkf6xkxhau7opmwbvotgmaut/spack-src/test/runnable/helloUTF16BE.d",
        "/tmp/vanessa/spack-stage/spack-stage-dmd-2.081.1-vqq6jjlqlkf6xkxhau7opmwbvotgmaut/spack-src/test/compilable/test13512.d",
        "/tmp/vanessa/spack-stage/spack-stage-dmd-2.081.1-vqq6jjlqlkf6xkxhau7opmwbvotgmaut/spack-src/test/fail_compilation/fail6458.d"
    ],
    "total_files": 4009
}