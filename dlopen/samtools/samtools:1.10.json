{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/hfile.c": "/*  hfile.c -- buffered low-level input/output streams.\n\n    Copyright (C) 2013-2019 Genome Research Ltd.\n\n    Author: John Marshall <jm18@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <string.h>\n#include <errno.h>\n#include <limits.h>\n\n#include <pthread.h>\n\n#ifdef ENABLE_PLUGINS\n#if defined(_WIN32) || defined(__CYGWIN__) || defined(__MSYS__)\n#define USING_WINDOWS_PLUGIN_DLLS\n#include <dlfcn.h>\n#endif\n#endif\n\n#include \"htslib/hfile.h\"\n#include \"hfile_internal.h\"\n#include \"htslib/kstring.h\"\n\n#ifndef ENOTSUP\n#define ENOTSUP EINVAL\n#endif\n#ifndef EOVERFLOW\n#define EOVERFLOW ERANGE\n#endif\n#ifndef EPROTONOSUPPORT\n#define EPROTONOSUPPORT ENOSYS\n#endif\n\n#ifndef SSIZE_MAX /* SSIZE_MAX is POSIX 1 */\n#define SSIZE_MAX LONG_MAX\n#endif\n\n/* hFILE fields are used as follows:\n\n   char *buffer;     // Pointer to the start of the I/O buffer\n   char *begin;      // First not-yet-read character / unused position\n   char *end;        // First unfilled/unfillable position\n   char *limit;      // Pointer to the first position past the buffer\n\n   const hFILE_backend *backend;  // Methods to refill/flush I/O buffer\n\n   off_t offset;     // Offset within the stream of buffer position 0\n   unsigned at_eof:1;// For reading, whether EOF has been seen\n   unsigned mobile:1;// Buffer is a mobile window or fixed full contents\n   unsigned readonly:1;// Whether opened as \"r\" rather than \"r+\"/\"w\"/\"a\"\n   int has_errno;    // Error number from the last failure on this stream\n\nFor reading, begin is the first unread character in the buffer and end is the\nfirst unfilled position:\n\n   -----------ABCDEFGHIJKLMNO---------------\n   ^buffer    ^begin         ^end           ^limit\n\nFor writing, begin is the first unused position and end is unused so remains\nequal to buffer:\n\n   ABCDEFGHIJKLMNOPQRSTUVWXYZ---------------\n   ^buffer                   ^begin         ^limit\n   ^end\n\nThus if begin > end then there is a non-empty write buffer, if begin < end\nthen there is a non-empty read buffer, and if begin == end then both buffers\nare empty.  In all cases, the stream's file position indicator corresponds\nto the position pointed to by begin.\n\nThe above is the normal scenario of a mobile window.  For in-memory\nstreams (eg via hfile_init_fixed) the buffer can be used as the full\ncontents without any separate backend behind it.  These always have at_eof\nset, offset set to 0, need no read() method, and should just return EINVAL\nfor seek():\n\n   abcdefghijkLMNOPQRSTUVWXYZ------\n   ^buffer    ^begin         ^end  ^limit\n*/\nHTSLIB_EXPORT\nhFILE *hfile_init(size_t struct_size, const char *mode, size_t capacity)\n{\n    hFILE *fp = (hFILE *) malloc(struct_size);\n    if (fp == NULL) goto error;\n\n    if (capacity == 0) capacity = 32768;\n    // FIXME For now, clamp input buffer sizes so mpileup doesn't eat memory\n    if (strchr(mode, 'r') && capacity > 32768) capacity = 32768;\n\n    fp->buffer = (char *) malloc(capacity);\n    if (fp->buffer == NULL) goto error;\n\n    fp->begin = fp->end = fp->buffer;\n    fp->limit = &fp->buffer[capacity];\n\n    fp->offset = 0;\n    fp->at_eof = 0;\n    fp->mobile = 1;\n    fp->readonly = (strchr(mode, 'r') && ! strchr(mode, '+'));\n    fp->has_errno = 0;\n    return fp;\n\nerror:\n    hfile_destroy(fp);\n    return NULL;\n}\n\nhFILE *hfile_init_fixed(size_t struct_size, const char *mode,\n                        char *buffer, size_t buf_filled, size_t buf_size)\n{\n    hFILE *fp = (hFILE *) malloc(struct_size);\n    if (fp == NULL) return NULL;\n\n    fp->buffer = fp->begin = buffer;\n    fp->end = &fp->buffer[buf_filled];\n    fp->limit = &fp->buffer[buf_size];\n\n    fp->offset = 0;\n    fp->at_eof = 1;\n    fp->mobile = 0;\n    fp->readonly = (strchr(mode, 'r') && ! strchr(mode, '+'));\n    fp->has_errno = 0;\n    return fp;\n}\n\nstatic const struct hFILE_backend mem_backend;\n\nHTSLIB_EXPORT\nvoid hfile_destroy(hFILE *fp)\n{\n    int save = errno;\n    if (fp) free(fp->buffer);\n    free(fp);\n    errno = save;\n}\n\nstatic inline int writebuffer_is_nonempty(hFILE *fp)\n{\n    return fp->begin > fp->end;\n}\n\n/* Refills the read buffer from the backend (once, so may only partially\n   fill the buffer), returning the number of additional characters read\n   (which might be 0), or negative when an error occurred.  */\nstatic ssize_t refill_buffer(hFILE *fp)\n{\n    ssize_t n;\n\n    // Move any unread characters to the start of the buffer\n    if (fp->mobile && fp->begin > fp->buffer) {\n        fp->offset += fp->begin - fp->buffer;\n        memmove(fp->buffer, fp->begin, fp->end - fp->begin);\n        fp->end = &fp->buffer[fp->end - fp->begin];\n        fp->begin = fp->buffer;\n    }\n\n    // Read into the available buffer space at fp->[end,limit)\n    if (fp->at_eof || fp->end == fp->limit) n = 0;\n    else {\n        n = fp->backend->read(fp, fp->end, fp->limit - fp->end);\n        if (n < 0) { fp->has_errno = errno; return n; }\n        else if (n == 0) fp->at_eof = 1;\n    }\n\n    fp->end += n;\n    return n;\n}\n\n/*\n * Changes the buffer size for an hFILE.  Ideally this is done\n * immediately after opening.  If performed later, this function may\n * fail if we are reducing the buffer size and the current offset into\n * the buffer is beyond the new capacity.\n *\n * Returns 0 on success;\n *        -1 on failure.\n */\nHTSLIB_EXPORT\nint hfile_set_blksize(hFILE *fp, size_t bufsiz) {\n    char *buffer;\n    ptrdiff_t curr_used;\n    if (!fp) return -1;\n    curr_used = (fp->begin > fp->end ? fp->begin : fp->end) - fp->buffer;\n    if (bufsiz == 0) bufsiz = 32768;\n\n    // Ensure buffer resize will not erase live data\n    if (bufsiz < curr_used)\n        return -1;\n\n    if (!(buffer = (char *) realloc(fp->buffer, bufsiz))) return -1;\n\n    fp->begin  = buffer + (fp->begin - fp->buffer);\n    fp->end    = buffer + (fp->end   - fp->buffer);\n    fp->buffer = buffer;\n    fp->limit  = &fp->buffer[bufsiz];\n\n    return 0;\n}\n\n/* Called only from hgetc(), when our buffer is empty.  */\nHTSLIB_EXPORT\nint hgetc2(hFILE *fp)\n{\n    return (refill_buffer(fp) > 0)? (unsigned char) *(fp->begin++) : EOF;\n}\n\nssize_t hgetdelim(char *buffer, size_t size, int delim, hFILE *fp)\n{\n    char *found;\n    size_t n, copied = 0;\n    ssize_t got;\n\n    if (size < 1 || size > SSIZE_MAX) {\n        fp->has_errno = errno = EINVAL;\n        return -1;\n    }\n    if (writebuffer_is_nonempty(fp)) {\n        fp->has_errno = errno = EBADF;\n        return -1;\n    }\n\n    --size; /* to allow space for the NUL terminator */\n\n    do {\n        n = fp->end - fp->begin;\n        if (n > size - copied) n = size - copied;\n\n        /* Look in the hFILE buffer for the delimiter */\n        found = memchr(fp->begin, delim, n);\n        if (found != NULL) {\n            n = found - fp->begin + 1;\n            memcpy(buffer + copied, fp->begin, n);\n            buffer[n + copied] = '\\0';\n            fp->begin += n;\n            return n + copied;\n        }\n\n        /* No delimiter yet, copy as much as we can and refill if necessary */\n        memcpy(buffer + copied, fp->begin, n);\n        fp->begin += n;\n        copied += n;\n\n        if (copied == size) { /* Output buffer full */\n            buffer[copied] = '\\0';\n            return copied;\n        }\n\n        got = refill_buffer(fp);\n    } while (got > 0);\n\n    if (got < 0) return -1; /* Error on refill. */\n\n    buffer[copied] = '\\0';  /* EOF, return anything that was copied. */\n    return copied;\n}\n\nchar *hgets(char *buffer, int size, hFILE *fp)\n{\n    if (size < 1) {\n        fp->has_errno = errno = EINVAL;\n        return NULL;\n    }\n    return hgetln(buffer, size, fp) > 0 ? buffer : NULL;\n}\n\nssize_t hpeek(hFILE *fp, void *buffer, size_t nbytes)\n{\n    size_t n = fp->end - fp->begin;\n    while (n < nbytes) {\n        ssize_t ret = refill_buffer(fp);\n        if (ret < 0) return ret;\n        else if (ret == 0) break;\n        else n += ret;\n    }\n\n    if (n > nbytes) n = nbytes;\n    memcpy(buffer, fp->begin, n);\n    return n;\n}\n\n/* Called only from hread(); when called, our buffer is empty and nread bytes\n   have already been placed in the destination buffer.  */\nHTSLIB_EXPORT\nssize_t hread2(hFILE *fp, void *destv, size_t nbytes, size_t nread)\n{\n    const size_t capacity = fp->limit - fp->buffer;\n    int buffer_invalidated = 0;\n    char *dest = (char *) destv;\n    dest += nread, nbytes -= nread;\n\n    // Read large requests directly into the destination buffer\n    while (nbytes * 2 >= capacity && !fp->at_eof) {\n        ssize_t n = fp->backend->read(fp, dest, nbytes);\n        if (n < 0) { fp->has_errno = errno; return n; }\n        else if (n == 0) fp->at_eof = 1;\n        else buffer_invalidated = 1;\n        fp->offset += n;\n        dest += n, nbytes -= n;\n        nread += n;\n    }\n\n    if (buffer_invalidated) {\n        // Our unread buffer is empty, so begin == end, but our already-read\n        // buffer [buffer,begin) is likely non-empty and is no longer valid as\n        // its contents are no longer adjacent to the file position indicator.\n        // Discard it so that hseek() can't try to take advantage of it.\n        fp->offset += fp->begin - fp->buffer;\n        fp->begin = fp->end = fp->buffer;\n    }\n\n    while (nbytes > 0 && !fp->at_eof) {\n        size_t n;\n        ssize_t ret = refill_buffer(fp);\n        if (ret < 0) return ret;\n\n        n = fp->end - fp->begin;\n        if (n > nbytes) n = nbytes;\n        memcpy(dest, fp->begin, n);\n        fp->begin += n;\n        dest += n, nbytes -= n;\n        nread += n;\n    }\n\n    return nread;\n}\n\n/* Flushes the write buffer, fp->[buffer,begin), out through the backend\n   returning 0 on success or negative if an error occurred.  */\nstatic ssize_t flush_buffer(hFILE *fp)\n{\n    const char *buffer = fp->buffer;\n    while (buffer < fp->begin) {\n        ssize_t n = fp->backend->write(fp, buffer, fp->begin - buffer);\n        if (n < 0) { fp->has_errno = errno; return n; }\n        buffer += n;\n        fp->offset += n;\n    }\n\n    fp->begin = fp->buffer;  // Leave the buffer empty\n    return 0;\n}\n\nint hflush(hFILE *fp)\n{\n    if (flush_buffer(fp) < 0) return EOF;\n    if (fp->backend->flush) {\n        if (fp->backend->flush(fp) < 0) { fp->has_errno = errno; return EOF; }\n    }\n    return 0;\n}\n\n/* Called only from hputc(), when our buffer is already full.  */\nHTSLIB_EXPORT\nint hputc2(int c, hFILE *fp)\n{\n    if (flush_buffer(fp) < 0) return EOF;\n    *(fp->begin++) = c;\n    return c;\n}\n\n/* Called only from hwrite() and hputs2(); when called, our buffer is either\n   full and ncopied bytes from the source have already been copied to our\n   buffer; or completely empty, ncopied is zero and totalbytes is greater than\n   the buffer size.  */\nHTSLIB_EXPORT\nssize_t hwrite2(hFILE *fp, const void *srcv, size_t totalbytes, size_t ncopied)\n{\n    const char *src = (const char *) srcv;\n    ssize_t ret;\n    const size_t capacity = fp->limit - fp->buffer;\n    size_t remaining = totalbytes - ncopied;\n    src += ncopied;\n\n    ret = flush_buffer(fp);\n    if (ret < 0) return ret;\n\n    // Write large blocks out directly from the source buffer\n    while (remaining * 2 >= capacity) {\n        ssize_t n = fp->backend->write(fp, src, remaining);\n        if (n < 0) { fp->has_errno = errno; return n; }\n        fp->offset += n;\n        src += n, remaining -= n;\n    }\n\n    // Just buffer any remaining characters\n    memcpy(fp->begin, src, remaining);\n    fp->begin += remaining;\n\n    return totalbytes;\n}\n\n/* Called only from hputs(), when our buffer is already full.  */\nHTSLIB_EXPORT\nint hputs2(const char *text, size_t totalbytes, size_t ncopied, hFILE *fp)\n{\n    return (hwrite2(fp, text, totalbytes, ncopied) >= 0)? 0 : EOF;\n}\n\noff_t hseek(hFILE *fp, off_t offset, int whence)\n{\n    off_t curpos, pos;\n\n    if (writebuffer_is_nonempty(fp) && fp->mobile) {\n        int ret = flush_buffer(fp);\n        if (ret < 0) return ret;\n    }\n\n    curpos = htell(fp);\n\n    // Relative offsets are given relative to the hFILE's stream position,\n    // which may differ from the backend's physical position due to buffering\n    // read-ahead.  Correct for this by converting to an absolute position.\n    if (whence == SEEK_CUR) {\n        if (curpos + offset < 0) {\n            // Either a negative offset resulted in a position before the\n            // start of the file, or we overflowed when given a positive offset\n            fp->has_errno = errno = (offset < 0)? EINVAL : EOVERFLOW;\n            return -1;\n        }\n\n        whence = SEEK_SET;\n        offset = curpos + offset;\n    }\n    // For fixed immobile buffers, convert everything else to SEEK_SET too\n    // so that seeking can be avoided for all (within range) requests.\n    else if (! fp->mobile && whence == SEEK_END) {\n        size_t length = fp->end - fp->buffer;\n        if (offset > 0 || -offset > length) {\n            fp->has_errno = errno = EINVAL;\n            return -1;\n        }\n\n        whence = SEEK_SET;\n        offset = length + offset;\n    }\n\n    // Avoid seeking if the desired position is within our read buffer.\n    // (But not when the next operation may be a write on a mobile buffer.)\n    if (whence == SEEK_SET && (! fp->mobile || fp->readonly) &&\n        offset >= fp->offset && offset - fp->offset <= fp->end - fp->buffer) {\n        fp->begin = &fp->buffer[offset - fp->offset];\n        return offset;\n    }\n\n    pos = fp->backend->seek(fp, offset, whence);\n    if (pos < 0) { fp->has_errno = errno; return pos; }\n\n    // Seeking succeeded, so discard any non-empty read buffer\n    fp->begin = fp->end = fp->buffer;\n    fp->at_eof = 0;\n\n    fp->offset = pos;\n    return pos;\n}\n\nint hclose(hFILE *fp)\n{\n    int err = fp->has_errno;\n\n    if (writebuffer_is_nonempty(fp) && hflush(fp) < 0) err = fp->has_errno;\n    if (fp->backend->close(fp) < 0) err = errno;\n    hfile_destroy(fp);\n\n    if (err) {\n        errno = err;\n        return EOF;\n    }\n    else return 0;\n}\n\nvoid hclose_abruptly(hFILE *fp)\n{\n    int save = errno;\n    if (fp->backend->close(fp) < 0) { /* Ignore subsequent errors */ }\n    hfile_destroy(fp);\n    errno = save;\n}\n\n\n/***************************\n * File descriptor backend *\n ***************************/\n\n#ifndef _WIN32\n#include <sys/socket.h>\n#include <sys/stat.h>\n#define HAVE_STRUCT_STAT_ST_BLKSIZE\n#else\n#include <winsock2.h>\n#define HAVE_CLOSESOCKET\n#define HAVE_SETMODE\n#endif\n#include <fcntl.h>\n#include <unistd.h>\n\n/* For Unix, it doesn't matter whether a file descriptor is a socket.\n   However Windows insists on send()/recv() and its own closesocket()\n   being used when fd happens to be a socket.  */\n\ntypedef struct {\n    hFILE base;\n    int fd;\n    unsigned is_socket:1;\n} hFILE_fd;\n\nstatic ssize_t fd_read(hFILE *fpv, void *buffer, size_t nbytes)\n{\n    hFILE_fd *fp = (hFILE_fd *) fpv;\n    ssize_t n;\n    do {\n        n = fp->is_socket? recv(fp->fd, buffer, nbytes, 0)\n                         : read(fp->fd, buffer, nbytes);\n    } while (n < 0 && errno == EINTR);\n    return n;\n}\n\nstatic ssize_t fd_write(hFILE *fpv, const void *buffer, size_t nbytes)\n{\n    hFILE_fd *fp = (hFILE_fd *) fpv;\n    ssize_t n;\n    do {\n        n = fp->is_socket?  send(fp->fd, buffer, nbytes, 0)\n                         : write(fp->fd, buffer, nbytes);\n    } while (n < 0 && errno == EINTR);\n#ifdef _WIN32\n        // On windows we have no SIGPIPE.  Instead write returns\n        // EINVAL.  We check for this and our fd being a pipe.\n        // If so, we raise SIGTERM instead of SIGPIPE.  It's not\n        // ideal, but I think the only alternative is extra checking\n        // in every single piece of code.\n        if (n < 0 && errno == EINVAL &&\n            GetLastError() == ERROR_NO_DATA &&\n            GetFileType((HANDLE)_get_osfhandle(fp->fd)) == FILE_TYPE_PIPE) {\n            raise(SIGTERM);\n        }\n#endif\n    return n;\n}\n\nstatic off_t fd_seek(hFILE *fpv, off_t offset, int whence)\n{\n    hFILE_fd *fp = (hFILE_fd *) fpv;\n    return lseek(fp->fd, offset, whence);\n}\n\nstatic int fd_flush(hFILE *fpv)\n{\n    int ret = 0;\n    do {\n#ifdef HAVE_FDATASYNC\n        hFILE_fd *fp = (hFILE_fd *) fpv;\n        ret = fdatasync(fp->fd);\n#elif defined(HAVE_FSYNC)\n        hFILE_fd *fp = (hFILE_fd *) fpv;\n        ret = fsync(fp->fd);\n#endif\n        // Ignore invalid-for-fsync(2) errors due to being, e.g., a pipe,\n        // and operation-not-supported errors (Mac OS X)\n        if (ret < 0 && (errno == EINVAL || errno == ENOTSUP)) ret = 0;\n    } while (ret < 0 && errno == EINTR);\n    return ret;\n}\n\nstatic int fd_close(hFILE *fpv)\n{\n    hFILE_fd *fp = (hFILE_fd *) fpv;\n    int ret;\n    do {\n#ifdef HAVE_CLOSESOCKET\n        ret = fp->is_socket? closesocket(fp->fd) : close(fp->fd);\n#else\n        ret = close(fp->fd);\n#endif\n    } while (ret < 0 && errno == EINTR);\n    return ret;\n}\n\nstatic const struct hFILE_backend fd_backend =\n{\n    fd_read, fd_write, fd_seek, fd_flush, fd_close\n};\n\nstatic size_t blksize(int fd)\n{\n#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE\n    struct stat sbuf;\n    if (fstat(fd, &sbuf) != 0) return 0;\n    return sbuf.st_blksize;\n#else\n    return 0;\n#endif\n}\n\nstatic hFILE *hopen_fd(const char *filename, const char *mode)\n{\n    hFILE_fd *fp = NULL;\n    int fd = open(filename, hfile_oflags(mode), 0666);\n    if (fd < 0) goto error;\n\n    fp = (hFILE_fd *) hfile_init(sizeof (hFILE_fd), mode, blksize(fd));\n    if (fp == NULL) goto error;\n\n    fp->fd = fd;\n    fp->is_socket = 0;\n    fp->base.backend = &fd_backend;\n    return &fp->base;\n\nerror:\n    if (fd >= 0) { int save = errno; (void) close(fd); errno = save; }\n    hfile_destroy((hFILE *) fp);\n    return NULL;\n}\n\n// Loads the contents of filename to produced a read-only, in memory,\n// immobile hfile.  fp is the already opened file.  We always close this\n// input fp, irrespective of whether we error or whether we return a new\n// immobile hfile.\nstatic hFILE *hpreload(hFILE *fp) {\n    hFILE *mem_fp;\n    char *buf = NULL;\n    off_t buf_sz = 0, buf_a = 0, buf_inc = 8192, len;\n\n    for (;;) {\n        if (buf_a - buf_sz < 5000) {\n            buf_a += buf_inc;\n            char *t = realloc(buf, buf_a);\n            if (!t) goto err;\n            buf = t;\n            if (buf_inc < 1000000) buf_inc *= 1.3;\n        }\n        len = hread(fp, buf+buf_sz, buf_a-buf_sz);\n        if (len > 0)\n            buf_sz += len;\n        else\n            break;\n    }\n\n    if (len < 0) goto err;\n    mem_fp = hfile_init_fixed(sizeof(hFILE), \"r\", buf, buf_sz, buf_a);\n    if (!mem_fp) goto err;\n    mem_fp->backend = &mem_backend;\n\n    if (hclose(fp) < 0) {\n        hclose_abruptly(mem_fp);\n        goto err;\n    }\n    return mem_fp;\n\n err:\n    free(buf);\n    hclose_abruptly(fp);\n    return NULL;\n}\n\nstatic int is_preload_url_remote(const char *url){\n    return hisremote(url + 8); // len(\"preload:\") = 8\n}\n\nstatic hFILE *hopen_preload(const char *url, const char *mode){\n    hFILE* fp = hopen(url + 8, mode);\n    return hpreload(fp);\n}\n\nhFILE *hdopen(int fd, const char *mode)\n{\n    hFILE_fd *fp = (hFILE_fd*) hfile_init(sizeof (hFILE_fd), mode, blksize(fd));\n    if (fp == NULL) return NULL;\n\n    fp->fd = fd;\n    fp->is_socket = (strchr(mode, 's') != NULL);\n    fp->base.backend = &fd_backend;\n    return &fp->base;\n}\n\nstatic hFILE *hopen_fd_fileuri(const char *url, const char *mode)\n{\n    if (strncmp(url, \"file://localhost/\", 17) == 0) url += 16;\n    else if (strncmp(url, \"file:///\", 8) == 0) url += 7;\n    else { errno = EPROTONOSUPPORT; return NULL; }\n\n#if defined(_WIN32) || defined(__MSYS__)\n    // For cases like C:/foo\n    if (url[0] == '/' && url[1] && url[2] == ':' && url[3] == '/') url++;\n#endif\n\n    return hopen_fd(url, mode);\n}\n\nstatic hFILE *hopen_fd_stdinout(const char *mode)\n{\n    int fd = (strchr(mode, 'r') != NULL)? STDIN_FILENO : STDOUT_FILENO;\n#if defined HAVE_SETMODE && defined O_BINARY\n    if (setmode(fd, O_BINARY) < 0) return NULL;\n#endif\n    return hdopen(fd, mode);\n}\n\nHTSLIB_EXPORT\nint hfile_oflags(const char *mode)\n{\n    int rdwr = 0, flags = 0;\n    const char *s;\n    for (s = mode; *s; s++)\n        switch (*s) {\n        case 'r': rdwr = O_RDONLY;  break;\n        case 'w': rdwr = O_WRONLY; flags |= O_CREAT | O_TRUNC;  break;\n        case 'a': rdwr = O_WRONLY; flags |= O_CREAT | O_APPEND;  break;\n        case '+': rdwr = O_RDWR;  break;\n#ifdef O_CLOEXEC\n        case 'e': flags |= O_CLOEXEC;  break;\n#endif\n#ifdef O_EXCL\n        case 'x': flags |= O_EXCL;  break;\n#endif\n        default:  break;\n        }\n\n#ifdef O_BINARY\n    flags |= O_BINARY;\n#endif\n\n    return rdwr | flags;\n}\n\n\n/*********************\n * In-memory backend *\n *********************/\n\n#include \"hts_internal.h\"\n\ntypedef struct {\n    hFILE base;\n} hFILE_mem;\n\nstatic off_t mem_seek(hFILE *fpv, off_t offset, int whence)\n{\n    errno = EINVAL;\n    return -1;\n}\n\nstatic int mem_close(hFILE *fpv)\n{\n    return 0;\n}\n\nstatic const struct hFILE_backend mem_backend =\n{\n    NULL, NULL, mem_seek, NULL, mem_close\n};\n\nstatic int cmp_prefix(const char *key, const char *s)\n{\n    while (*key)\n        if (tolower_c(*s) != *key) return +1;\n        else s++, key++;\n\n    return 0;\n}\n\nstatic hFILE *create_hfile_mem(char* buffer, const char* mode, size_t buf_filled, size_t buf_size)\n{\n    hFILE_mem *fp = (hFILE_mem *) hfile_init_fixed(sizeof(hFILE_mem), mode, buffer, buf_filled, buf_size);\n    if (fp == NULL)\n        return NULL;\n\n    fp->base.backend = &mem_backend;\n    return &fp->base;\n}\n\nstatic hFILE *hopen_mem(const char *url, const char *mode)\n{\n    size_t length, size;\n    char *buffer;\n    const char *data, *comma = strchr(url, ',');\n    if (comma == NULL) { errno = EINVAL; return NULL; }\n    data = comma+1;\n\n    // TODO Implement write modes\n    if (strchr(mode, 'r') == NULL) { errno = EROFS; return NULL; }\n\n    if (comma - url >= 7 && cmp_prefix(\";base64\", &comma[-7]) == 0) {\n        size = hts_base64_decoded_length(strlen(data));\n        buffer = malloc(size);\n        if (buffer == NULL) return NULL;\n        hts_decode_base64(buffer, &length, data);\n    }\n    else {\n        size = strlen(data) + 1;\n        buffer = malloc(size);\n        if (buffer == NULL) return NULL;\n        hts_decode_percent(buffer, &length, data);\n    }\n    hFILE* hf;\n\n    if(!(hf = create_hfile_mem(buffer, mode, length, size))){\n        free(buffer);\n        return NULL;\n    }\n\n    return hf;\n}\n\nstatic hFILE *hopenv_mem(const char *filename, const char *mode, va_list args)\n{\n    char* buffer = va_arg(args, char*);\n    size_t sz = va_arg(args, size_t);\n    va_end(args);\n\n    hFILE* hf;\n\n    if(!(hf = create_hfile_mem(buffer, mode, sz, sz))){\n        free(buffer);\n        return NULL;\n    }\n\n    return hf;\n}\n\nchar *hfile_mem_get_buffer(hFILE *file, size_t *length) {\n    if (file->backend != &mem_backend) {\n        errno = EINVAL;\n        return NULL;\n    }\n\n    if (length)\n        *length = file->buffer - file->limit;\n\n    return file->buffer;\n}\n\nchar *hfile_mem_steal_buffer(hFILE *file, size_t *length) {\n    char *buf = hfile_mem_get_buffer(file, length);\n    if (buf)\n        file->buffer = NULL;\n    return buf;\n}\n\nint hfile_plugin_init_mem(struct hFILE_plugin *self)\n{\n    // mem files are declared remote so they work with a tabix index\n    static const struct hFILE_scheme_handler handler =\n            {NULL, hfile_always_remote, \"mem\", 2000 + 50, hopenv_mem};\n    self->name = \"mem\";\n    hfile_add_scheme_handler(\"mem\", &handler);\n    return 0;\n}\n\n\n/*****************************************\n * Plugin and hopen() backend dispatcher *\n *****************************************/\n\n#include \"htslib/khash.h\"\n\nKHASH_MAP_INIT_STR(scheme_string, const struct hFILE_scheme_handler *)\nstatic khash_t(scheme_string) *schemes = NULL;\n\nstruct hFILE_plugin_list {\n    struct hFILE_plugin plugin;\n    struct hFILE_plugin_list *next;\n};\n\nstatic struct hFILE_plugin_list *plugins = NULL;\nstatic pthread_mutex_t plugins_lock = PTHREAD_MUTEX_INITIALIZER;\n\nstatic void hfile_exit()\n{\n    pthread_mutex_lock(&plugins_lock);\n\n    kh_destroy(scheme_string, schemes);\n\n    while (plugins != NULL) {\n        struct hFILE_plugin_list *p = plugins;\n        if (p->plugin.destroy) p->plugin.destroy();\n#ifdef ENABLE_PLUGINS\n        if (p->plugin.obj) close_plugin(p->plugin.obj);\n#endif\n        plugins = p->next;\n        free(p);\n    }\n\n    pthread_mutex_unlock(&plugins_lock);\n    pthread_mutex_destroy(&plugins_lock);\n}\n\nstatic inline int priority(const struct hFILE_scheme_handler *handler)\n{\n    return handler->priority % 1000;\n}\n\n#ifdef USING_WINDOWS_PLUGIN_DLLS\n/*\n * Work-around for Windows plug-in dlls where the plug-in could be\n * using a different HTSlib library to the executable (for example\n * because the latter was build against a static libhts.a).  When this\n * happens, the plug-in can call the wrong copy of hfile_add_scheme_handler().\n * If this is detected, it calls this function which attempts to fix the\n * problem by redirecting to the hfile_add_scheme_handler() in the main\n * executable.\n */\nstatic int try_exe_add_scheme_handler(const char *scheme,\n                                      const struct hFILE_scheme_handler *handler)\n{\n    static void (*add_scheme_handler)(const char *scheme,\n                                      const struct hFILE_scheme_handler *handler);\n    if (!add_scheme_handler) {\n        // dlopen the main executable and resolve hfile_add_scheme_handler\n        void *exe_handle = dlopen(NULL, RTLD_LAZY);\n        if (!exe_handle) return -1;\n        *(void **) (&add_scheme_handler) = dlsym(exe_handle, \"hfile_add_scheme_handler\");\n        dlclose(exe_handle);\n    }\n    // Check that the symbol was obtained and isn't the one in this copy\n    // of the library (to avoid infinite recursion)\n    if (!add_scheme_handler || add_scheme_handler == hfile_add_scheme_handler)\n        return -1;\n    add_scheme_handler(scheme, handler);\n    return 0;\n}\n#else\nstatic int try_exe_add_scheme_handler(const char *scheme,\n                                      const struct hFILE_scheme_handler *handler)\n{\n    return -1;\n}\n#endif\n\nHTSLIB_EXPORT\nvoid hfile_add_scheme_handler(const char *scheme,\n                              const struct hFILE_scheme_handler *handler)\n{\n    int absent;\n    if (!schemes) {\n        if (try_exe_add_scheme_handler(scheme, handler) != 0) {\n            hts_log_warning(\"Couldn't register scheme handler for %s\", scheme);\n        }\n        return;\n    }\n    khint_t k = kh_put(scheme_string, schemes, scheme, &absent);\n    if (absent || priority(handler) > priority(kh_value(schemes, k))) {\n        kh_value(schemes, k) = handler;\n    }\n}\n\nstatic int init_add_plugin(void *obj, int (*init)(struct hFILE_plugin *),\n                           const char *pluginname)\n{\n    struct hFILE_plugin_list *p = malloc (sizeof (struct hFILE_plugin_list));\n    if (p == NULL) abort();\n\n    p->plugin.api_version = 1;\n    p->plugin.obj = obj;\n    p->plugin.name = NULL;\n    p->plugin.destroy = NULL;\n\n    int ret = (*init)(&p->plugin);\n\n    if (ret != 0) {\n        hts_log_debug(\"Initialisation failed for plugin \\\"%s\\\": %d\", pluginname, ret);\n        free(p);\n        return ret;\n    }\n\n    hts_log_debug(\"Loaded \\\"%s\\\"\", pluginname);\n\n    p->next = plugins, plugins = p;\n    return 0;\n}\n\nstatic void load_hfile_plugins()\n{\n    static const struct hFILE_scheme_handler\n        data = { hopen_mem, hfile_always_local, \"built-in\", 80 },\n        file = { hopen_fd_fileuri, hfile_always_local, \"built-in\", 80 },\n        preload = { hopen_preload, is_preload_url_remote, \"built-in\", 80 };\n\n    schemes = kh_init(scheme_string);\n    if (schemes == NULL) abort();\n\n    hfile_add_scheme_handler(\"data\", &data);\n    hfile_add_scheme_handler(\"file\", &file);\n    hfile_add_scheme_handler(\"preload\", &preload);\n    init_add_plugin(NULL, hfile_plugin_init_net, \"knetfile\");\n    init_add_plugin(NULL, hfile_plugin_init_mem, \"mem\");\n\n#ifdef ENABLE_PLUGINS\n    struct hts_path_itr path;\n    const char *pluginname;\n    hts_path_itr_setup(&path, NULL, NULL, \"hfile_\", 6, NULL, 0);\n    while ((pluginname = hts_path_itr_next(&path)) != NULL) {\n        void *obj;\n        int (*init)(struct hFILE_plugin *) = (int (*)(struct hFILE_plugin *))\n            load_plugin(&obj, pluginname, \"hfile_plugin_init\");\n\n        if (init) {\n            if (init_add_plugin(obj, init, pluginname) != 0)\n                close_plugin(obj);\n        }\n    }\n#else\n\n#ifdef HAVE_LIBCURL\n    init_add_plugin(NULL, hfile_plugin_init_libcurl, \"libcurl\");\n#endif\n#ifdef ENABLE_GCS\n    init_add_plugin(NULL, hfile_plugin_init_gcs, \"gcs\");\n#endif\n#ifdef ENABLE_S3\n    init_add_plugin(NULL, hfile_plugin_init_s3, \"s3\");\n    init_add_plugin(NULL, hfile_plugin_init_s3_write, \"s3w\");\n#endif\n\n#endif\n\n    // In the unlikely event atexit() fails, it's better to succeed here and\n    // carry on; then eventually when the program exits, we'll merely close\n    // down the plugins uncleanly, as if we had aborted.\n    (void) atexit(hfile_exit);\n}\n\n/* A filename like \"foo:bar\" in which we don't recognise the scheme is\n   either an ordinary file or an indication of a missing or broken plugin.\n   Try to open it as an ordinary file; but if there's no such file, set\n   errno distinctively to make the plugin issue apparent.  */\nstatic hFILE *hopen_unknown_scheme(const char *fname, const char *mode)\n{\n    hFILE *fp = hopen_fd(fname, mode);\n    if (fp == NULL && errno == ENOENT) errno = EPROTONOSUPPORT;\n    return fp;\n}\n\n/* Returns the appropriate handler, or NULL if the string isn't an URL.  */\nstatic const struct hFILE_scheme_handler *find_scheme_handler(const char *s)\n{\n    static const struct hFILE_scheme_handler unknown_scheme =\n        { hopen_unknown_scheme, hfile_always_local, \"built-in\", 0 };\n\n    char scheme[12];\n    int i;\n\n    for (i = 0; i < sizeof scheme; i++)\n        if (isalnum_c(s[i]) || s[i] == '+' || s[i] == '-' || s[i] == '.')\n            scheme[i] = tolower_c(s[i]);\n        else if (s[i] == ':') break;\n        else return NULL;\n\n    // 1 byte schemes are likely windows C:/foo pathnames\n    if (i <= 1 || i >= sizeof scheme) return NULL;\n    scheme[i] = '\\0';\n\n    pthread_mutex_lock(&plugins_lock);\n    if (! schemes) load_hfile_plugins();\n    pthread_mutex_unlock(&plugins_lock);\n\n    khint_t k = kh_get(scheme_string, schemes, scheme);\n    return (k != kh_end(schemes))? kh_value(schemes, k) : &unknown_scheme;\n}\n\nhFILE *hopen(const char *fname, const char *mode, ...)\n{\n    const struct hFILE_scheme_handler *handler = find_scheme_handler(fname);\n    if (handler) {\n        if (strchr(mode, ':') == NULL\n            || handler->priority < 2000\n            || handler->vopen == NULL) {\n            return handler->open(fname, mode);\n        }\n        else {\n            hFILE *fp;\n            va_list arg;\n            va_start(arg, mode);\n            fp = handler->vopen(fname, mode, arg);\n            va_end(arg);\n            return fp;\n        }\n    }\n    else if (strcmp(fname, \"-\") == 0) return hopen_fd_stdinout(mode);\n    else return hopen_fd(fname, mode);\n}\n\nHTSLIB_EXPORT\nint hfile_always_local (const char *fname) { return 0; }\n\nHTSLIB_EXPORT\nint hfile_always_remote(const char *fname) { return 1; }\n\nint hisremote(const char *fname)\n{\n    const struct hFILE_scheme_handler *handler = find_scheme_handler(fname);\n    return handler? handler->isremote(fname) : 0;\n}\n\n// Remove an extension, if any, from the basename part of [start,limit).\n// Note: Doesn't notice percent-encoded '.' and '/' characters. Don't do that.\nstatic const char *strip_extension(const char *start, const char *limit)\n{\n    const char *s = limit;\n    while (s > start) {\n        --s;\n        if (*s == '.') return s;\n        else if (*s == '/') break;\n    }\n    return limit;\n}\n\nchar *haddextension(struct kstring_t *buffer, const char *filename,\n                    int replace, const char *new_extension)\n{\n    const char *trailing, *end;\n\n    if (find_scheme_handler(filename)) {\n        // URL, so alter extensions before any trailing query or fragment parts\n        // Allow # symbols in s3 URLs\n        trailing = filename + ((strncmp(filename, \"s3://\", 5) && strncmp(filename, \"s3+http://\", 10) && strncmp(filename, \"s3+https://\", 11))  ? strcspn(filename, \"?#\") : strcspn(filename, \"?\"));\n    }\n    else {\n        // Local path, so alter extensions at the end of the filename\n        trailing = strchr(filename, '\\0');\n    }\n\n    end = replace? strip_extension(filename, trailing) : trailing;\n\n    buffer->l = 0;\n    if (kputsn(filename, end - filename, buffer) >= 0 &&\n        kputs(new_extension, buffer) >= 0 &&\n        kputs(trailing, buffer) >= 0) return buffer->s;\n    else return NULL;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/configure.ac": "# Configure script for htslib, a C library for high-throughput sequencing data.\n#\n#    Copyright (C) 2015-2018 Genome Research Ltd.\n#\n#    Author: John Marshall <jm18@sanger.ac.uk>\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n# DEALINGS IN THE SOFTWARE.\n\ndnl Process this file with autoconf to produce a configure script\nAC_INIT([HTSlib], m4_esyscmd_s([./version.sh 2>/dev/null]),\n        [samtools-help@lists.sourceforge.net], [], [http://www.htslib.org/])\nAC_PREREQ(2.63)  dnl This version introduced 4-argument AC_CHECK_HEADER\nAC_CONFIG_SRCDIR(hts.c)\nAC_CONFIG_HEADERS(config.h)\n\nm4_include([m4/hts_prog_cc_warnings.m4])\nm4_include([m4/hts_hide_dynamic_syms.m4])\n\ndnl Copyright notice to be copied into the generated configure script\nAC_COPYRIGHT([Portions copyright (C) 2018 Genome Research Ltd.\n\nThis configure script is free software: you are free to change and\nredistribute it.  There is NO WARRANTY, to the extent permitted by law.])\n\ndnl Notes to be copied (by autoheader) into the generated config.h.in\nAH_TOP([/* If you use configure, this file provides @%:@defines reflecting your\n   configuration choices.  If you have not run configure, suitable\n   conservative defaults will be used.\n\n   Autoheader adds a number of items to this template file that are not\n   used by HTSlib: STDC_HEADERS and most HAVE_*_H header file defines\n   are immaterial, as we assume standard ISO C headers and facilities;\n   the PACKAGE_* defines are unused and are overridden by the more\n   accurate PACKAGE_VERSION as computed by the Makefile.  */])\n\ndnl Variant of AC_MSG_ERROR that ensures subsequent make(1) invocations fail\ndnl until the configuration error is resolved and configure is run again.\nAC_DEFUN([MSG_ERROR],\n  [cat > config.mk <<'EOF'\nifneq ($(MAKECMDGOALS),distclean)\n$(error Resolve configure error first)\nendif\nEOF\n   AC_MSG_ERROR([$1], [$2])])\n\nAC_PROG_CC\nAC_PROG_RANLIB\n\ndnl Turn on compiler warnings, if possible\nHTS_PROG_CC_WARNINGS\ndnl Flags to treat warnings as errors.  These need to be applied to CFLAGS\ndnl later as they can interfere with some of the tests (notably AC_SEARCH_LIBS)\nHTS_PROG_CC_WERROR(hts_late_cflags)\n\ndnl Avoid chicken-and-egg problem where pkg-config supplies the\ndnl PKG_PROG_PKG_CONFIG macro, but we want to use it to check\ndnl for pkg-config...\nm4_ifdef([PKG_PROG_PKG_CONFIG], [PKG_PROG_PKG_CONFIG], [PKG_CONFIG=\"\"])\n\nneed_crypto=no\npc_requires=\nstatic_LDFLAGS=$LDFLAGS\nstatic_LIBS='-lpthread -lz -lm'\nprivate_LIBS=$LDFLAGS\n\nAC_ARG_ENABLE([bz2],\n  [AS_HELP_STRING([--disable-bz2],\n                  [omit support for BZ2-compressed CRAM files])],\n  [], [enable_bz2=yes])\n\nAC_ARG_ENABLE([gcs],\n  [AS_HELP_STRING([--enable-gcs],\n                  [support Google Cloud Storage URLs])],\n  [], [enable_gcs=check])\n\nAC_SYS_LARGEFILE\n\nAC_ARG_ENABLE([libcurl],\n  [AS_HELP_STRING([--enable-libcurl],\n                  [enable libcurl-based support for http/https/etc URLs])],\n  [], [enable_libcurl=check])\n\nAC_ARG_ENABLE([lzma],\n  [AS_HELP_STRING([--disable-lzma],\n                  [omit support for LZMA-compressed CRAM files])],\n  [], [enable_lzma=yes])\n\nAC_ARG_ENABLE([plugins],\n  [AS_HELP_STRING([--enable-plugins],\n                  [enable separately-compiled plugins for file access])],\n  [], [enable_plugins=no])\nAC_SUBST(enable_plugins)\n\nAC_ARG_WITH([libdeflate],\n  [AS_HELP_STRING([--with-libdeflate],\n                  [use libdeflate for faster crc and deflate algorithms])],\n  [], [with_libdeflate=check])\n\nAC_ARG_WITH([plugin-dir],\n  [AS_HELP_STRING([--with-plugin-dir=DIR],\n                  [plugin installation location [LIBEXECDIR/htslib]])],\n  [case $withval in\n     yes|no) MSG_ERROR([no directory specified for --with-plugin-dir]) ;;\n   esac],\n   [with_plugin_dir='$(libexecdir)/htslib'])\nAC_SUBST([plugindir], $with_plugin_dir)\n\nAC_ARG_WITH([plugin-path],\n  [AS_HELP_STRING([--with-plugin-path=PATH],\n                  [default HTS_PATH plugin search path [PLUGINDIR]])],\n  [case $withval in\n     yes) MSG_ERROR([no path specified for --with-plugin-path]) ;;\n     no)  with_plugin_path= ;;\n   esac],\n  [with_plugin_path=$with_plugin_dir])\nAC_SUBST([pluginpath], $with_plugin_path)\n\nAC_ARG_ENABLE([s3],\n  [AS_HELP_STRING([--enable-s3],\n                  [support Amazon AWS S3 URLs])],\n  [], [enable_s3=check])\n\ntest -n \"$host_alias\" || host_alias=unknown-`uname -s`\nAC_MSG_CHECKING([shared library type for $host_alias])\ncase $host_alias in\n  *-cygwin* | *-CYGWIN*)\n    host_result=\"Cygwin DLL\"\n    PLATFORM=CYGWIN\n    PLUGIN_EXT=.cygdll\n    ;;\n  *-darwin* | *-Darwin*)\n    host_result=\"Darwin dylib\"\n    PLATFORM=Darwin\n    PLUGIN_EXT=.bundle\n    ;;\n  *-msys* | *-MSYS* | *-mingw* | *-MINGW*)\n    host_result=\"MSYS dll\"\n    PLATFORM=MSYS\n    PLUGIN_EXT=.dll\n    # This also sets __USE_MINGW_ANSI_STDIO which in turn makes PRId64,\n    # %lld and %z printf formats work.  It also enforces the snprintf to\n    # be C99 compliant so it returns the correct values (in kstring.c).\n    CPPFLAGS=\"$CPPCFLAGS -D_XOPEN_SOURCE=600\"\n    ;;\n  *)\n    host_result=\"plain .so\"\n    PLATFORM=default\n    PLUGIN_EXT=.so\n    ;;\nesac\nAC_MSG_RESULT([$host_result])\nAC_SUBST([PLATFORM])\n\ndnl Try to get more control over which symbols are exported in the shared\ndnl library.\nHTS_HIDE_DYNAMIC_SYMBOLS\n\ndnl FIXME This pulls in dozens of standard header checks\nAC_FUNC_MMAP\nAC_CHECK_FUNCS([gmtime_r fsync drand48])\n\n# Darwin has a dubious fdatasync() symbol, but no declaration in <unistd.h>\nAC_CHECK_DECL([fdatasync(int)], [AC_CHECK_FUNCS(fdatasync)])\n\nif test $enable_plugins != no; then\n  AC_SEARCH_LIBS([dlopen], [dl], [],\n    [MSG_ERROR([dlopen() not found\n\nPlugin support requires dynamic linking facilities from the operating system.\nEither configure with --disable-plugins or resolve this error to build HTSlib.])])\n  # Check if the compiler understands -rdynamic \n  # TODO Test whether this is required and/or needs tweaking per-platform\n  HTS_TEST_CC_C_LD_FLAG([-rdynamic],[rdynamic_flag])\n  AS_IF([test x\"$rdynamic_flag\" != \"xno\"],\n    [LDFLAGS=\"$LDFLAGS $rdynamic_flag\"\n     static_LDFLAGS=\"$static_LDFLAGS $rdynamic_flag\"])\n  case \"$ac_cv_search_dlopen\" in\n    -l*) static_LIBS=\"$static_LIBS $ac_cv_search_dlopen\" ;;\n  esac\n  AC_DEFINE([ENABLE_PLUGINS], 1, [Define if HTSlib should enable plugins.])\n  AC_SUBST([PLUGIN_EXT])\n  AC_DEFINE_UNQUOTED([PLUGIN_EXT], [\"$PLUGIN_EXT\"],\n                     [Platform-dependent plugin filename extension.])\nfi\n\nAC_SEARCH_LIBS([log], [m], [],\n  [MSG_ERROR([log() not found\n\nHTSLIB requires a working floating-point math library.\nFAILED.  This error must be resolved in order to build HTSlib successfully.])])\n\nzlib_devel=ok\ndnl Set a trivial non-empty INCLUDES to avoid excess default includes tests\nAC_CHECK_HEADER([zlib.h], [], [zlib_devel=missing], [;])\nAC_CHECK_LIB(z, inflate,  [], [zlib_devel=missing])\n\nif test $zlib_devel != ok; then\n  MSG_ERROR([zlib development files not found\n\nHTSlib uses compression routines from the zlib library <http://zlib.net>.\nBuilding HTSlib requires zlib development files to be installed on the build\nmachine; you may need to ensure a package such as zlib1g-dev (on Debian or\nUbuntu Linux) or zlib-devel (on RPM-based Linux distributions or Cygwin)\nis installed.\n\nFAILED.  This error must be resolved in order to build HTSlib successfully.])\nfi\n\ndnl connect() etc. fns are in libc on linux, but libsocket on illumos/Solaris\nAC_SEARCH_LIBS([recv], [socket ws2_32], [\nif test \"$ac_cv_search_recv\" != \"none required\"\nthen\n  static_LIBS=\"$static_LIBS $ac_cv_search_recv\"\nfi], [MSG_ERROR([unable to find the recv() function])])\n\nif test \"$enable_bz2\" != no; then\n  bz2_devel=ok\n  AC_CHECK_HEADER([bzlib.h], [], [bz2_devel=missing], [;])\n  AC_CHECK_LIB([bz2], [BZ2_bzBuffToBuffCompress], [], [bz2_devel=missing])\n  if test $bz2_devel != ok; then\n    MSG_ERROR([libbzip2 development files not found\n\nThe CRAM format may use bzip2 compression, which is implemented in HTSlib\nby using compression routines from libbzip2 <http://www.bzip.org/>.\n\nBuilding HTSlib requires libbzip2 development files to be installed on the\nbuild machine; you may need to ensure a package such as libbz2-dev (on Debian\nor Ubuntu Linux) or bzip2-devel (on RPM-based Linux distributions or Cygwin)\nis installed.\n\nEither configure with --disable-bz2 (which will make some CRAM files\nproduced elsewhere unreadable) or resolve this error to build HTSlib.])\n  fi\ndnl Unfortunately the 'bzip2' package-cfg module is not standard.\ndnl Redhat/Fedora has it; Debian/Ubuntu does not.\n  if test -n \"$PKG_CONFIG\" && \"$PKG_CONFIG\" --exists bzip2; then\n     pc_requires=\"$pc_requires bzip2\"\n  else\n     private_LIBS=\"$private_LIBS -lbz2\"\n  fi\n  static_LIBS=\"$static_LIBS -lbz2\"\nfi\n\nif test \"$enable_lzma\" != no; then\n  lzma_devel=ok\n  AC_CHECK_HEADERS([lzma.h], [], [lzma_devel=header-missing], [;])\n  AC_CHECK_LIB([lzma], [lzma_easy_buffer_encode], [], [lzma_devel=missing])\n  if test $lzma_devel = missing; then\n    MSG_ERROR([liblzma development files not found\n\nThe CRAM format may use LZMA2 compression, which is implemented in HTSlib\nby using compression routines from liblzma <http://tukaani.org/xz/>.\n\nBuilding HTSlib requires liblzma development files to be installed on the\nbuild machine; you may need to ensure a package such as liblzma-dev (on Debian\nor Ubuntu Linux), xz-devel (on RPM-based Linux distributions or Cygwin), or\nxz (via Homebrew on macOS) is installed; or build XZ Utils from source.\n\nEither configure with --disable-lzma (which will make some CRAM files\nproduced elsewhere unreadable) or resolve this error to build HTSlib.])\n  fi\n  pc_requires=\"$pc_requires liblzma\"\n  static_LIBS=\"$static_LIBS -llzma\"\nfi\n\nAS_IF([test \"x$with_libdeflate\" != \"xno\"],\n  [libdeflate=ok\n   AC_CHECK_HEADER([libdeflate.h],[],[libdeflate='missing header'],[;])\n   AC_CHECK_LIB([deflate], [libdeflate_deflate_compress],[:],[libdeflate='missing library'])\n   AS_IF([test \"$libdeflate\" = \"ok\"],\n    [AC_DEFINE([HAVE_LIBDEFLATE], 1, [Define if libdeflate is available.])\n     LIBS=\"-ldeflate $LIBS\"\n     private_LIBS=\"$private_LIBS -ldeflate\"\n     static_LIBS=\"$static_LIBS -ldeflate\"],\n    [AS_IF([test \"x$with_libdeflate\" != \"xcheck\"],\n       [MSG_ERROR([libdeflate development files not found: $libdeflate\n\nYou requested libdeflate, but do not have the required header / library\nfiles.  The source for libdeflate is available from\n<https://github.com/ebiggers/libdeflate>.  You may have to adjust\nsearch paths in CPPFLAGS and/or LDFLAGS if the header and library\nare not currently on them.\n\nEither configure with --without-libdeflate or resolve this error to build\nHTSlib.])])])])\n\nlibcurl=disabled\nif test \"$enable_libcurl\" != no; then\n  AC_CHECK_LIB([curl], [curl_easy_pause],\n    [AC_DEFINE([HAVE_LIBCURL], 1, [Define if libcurl file access is enabled.])\n     libcurl=enabled],\n    [AC_CHECK_LIB([curl], [curl_easy_init],\n       [message=\"library is too old (7.18+ required)\"],\n       [message=\"library not found\"])\n     case \"$enable_libcurl\" in\n       check) AC_MSG_WARN([libcurl not enabled: $message]) ;;\n       *) MSG_ERROR([libcurl $message\n\nSupport for HTTPS and other SSL-based URLs requires routines from the libcurl\nlibrary <http://curl.haxx.se/libcurl/>.  Building HTSlib with libcurl enabled\nrequires libcurl development files to be installed on the build machine; you\nmay need to ensure a package such as libcurl4-{gnutls,nss,openssl}-dev (on\nDebian or Ubuntu Linux) or libcurl-devel (on RPM-based Linux distributions\nor Cygwin) is installed.\n\nEither configure with --disable-libcurl or resolve this error to build HTSlib.])\n       ;;\n     esac])\ndnl -lcurl is only needed for static linking if hfile_libcurl is not a plugin\n  if test \"$libcurl\" = enabled ; then\n    if test \"$enable_plugins\" != yes ; then\n      static_LIBS=\"$static_LIBS -lcurl\"\n    fi\n  fi\nfi\nAC_SUBST([libcurl])\n\ngcs=disabled\nif test \"$enable_gcs\" != no; then\n  if test $libcurl = enabled; then\n    AC_DEFINE([ENABLE_GCS], 1, [Define if HTSlib should enable GCS support.])\n    gcs=enabled\n  else\n    case \"$enable_gcs\" in\n      check) AC_MSG_WARN([GCS support not enabled: requires libcurl support]) ;;\n      *) MSG_ERROR([GCS support not enabled\n\nSupport for Google Cloud Storage URLs requires libcurl support to be enabled\nin HTSlib.  Configure with --enable-libcurl in order to use GCS URLs.])\n      ;;\n    esac\n  fi\nfi\nAC_SUBST([gcs])\n\ns3=disabled\nif test \"$enable_s3\" != no; then\n  if test $libcurl = enabled; then\n    s3=enabled\n    need_crypto=\"$enable_s3\"\n  else\n    case \"$enable_s3\" in\n      check) AC_MSG_WARN([S3 support not enabled: requires libcurl support]) ;;\n      *) MSG_ERROR([S3 support not enabled\n\nSupport for Amazon AWS S3 URLs requires libcurl support to be enabled\nin HTSlib.  Configure with --enable-libcurl in order to use S3 URLs.])\n      ;;\n    esac\n  fi\nfi\n\nCRYPTO_LIBS=\nif test $need_crypto != no; then\n  AC_CHECK_FUNC([CCHmac],\n    [AC_DEFINE([HAVE_COMMONCRYPTO], 1,\n               [Define if you have the Common Crypto library.])],\n    [save_LIBS=$LIBS\n     AC_SEARCH_LIBS([HMAC], [crypto],\n       [AC_DEFINE([HAVE_HMAC], 1, [Define if you have libcrypto-style HMAC().])\n        case \"$ac_cv_search_HMAC\" in\n          -l*) CRYPTO_LIBS=$ac_cv_search_HMAC ;;\n        esac],\n     [case \"$need_crypto\" in\n     check) AC_MSG_WARN([S3 support not enabled: requires SSL development files])\n         s3=disabled ;;\n     *) MSG_ERROR([SSL development files not found\n\nSupport for AWS S3 URLs requires routines from an SSL library.  Building\nHTSlib with libcurl enabled requires SSL development files to be installed\non the build machine; you may need to ensure a package such as libgnutls-dev,\nlibnss3-dev, or libssl-dev (on Debian or Ubuntu Linux, corresponding to the\nlibcurl4-*-dev package installed), or openssl-devel (on RPM-based Linux\ndistributions or Cygwin) is installed.\n\nEither configure with --disable-s3 or resolve this error to build HTSlib.]) ;;\n       esac])\n     LIBS=$save_LIBS])\ndnl Only need to add to static_LIBS if not building as a plugin\n  if test \"$enable_plugins\" != yes ; then\n     static_LIBS=\"$static_LIBS $CRYPTO_LIBS\"\n  fi\nfi\n\ndnl Look for PTHREAD_MUTEX_RECURSIVE.\ndnl This is normally in pthread.h except on some broken glibc implementations.\nAC_CHECK_DECL(PTHREAD_MUTEX_RECURSIVE, [], [AC_DEFINE([_XOPEN_SOURCE],[600], [Needed for PTHREAD_MUTEX_RECURSIVE])], [[#include <pthread.h>]])\n\nif test \"$s3\" = enabled ; then\n   AC_DEFINE([ENABLE_S3], 1, [Define if HTSlib should enable S3 support.])\nfi\n\ndnl Apply value from HTS_PROG_CC_WERROR (if set)\nAS_IF([test \"x$hts_late_cflags\" != x],[CFLAGS=\"$CFLAGS $hts_late_cflags\"])\n\nAC_SUBST([s3])\nAC_SUBST([CRYPTO_LIBS])\n\nAC_SUBST([pc_requires])\nAC_SUBST([private_LIBS])\nAC_SUBST([static_LDFLAGS])\nAC_SUBST([static_LIBS])\n\nAC_CONFIG_FILES([config.mk htslib.pc.tmp:htslib.pc.in])\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/plugin.c": "/*  plugin.c -- low-level path parsing and plugin functions.\n\n    Copyright (C) 2015-2016 Genome Research Ltd.\n\n    Author: John Marshall <jm18@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include <dirent.h>\n#include <dlfcn.h>\n\n#include \"hts_internal.h\"\n#include \"htslib/kstring.h\"\n\n#ifndef PLUGINPATH\n#define PLUGINPATH \"\"\n#endif\n\nstatic DIR *open_nextdir(struct hts_path_itr *itr)\n{\n    DIR *dir;\n\n    while (1) {\n        const char *colon = strchr(itr->pathdir, HTS_PATH_SEPARATOR_CHAR);\n        if (colon == NULL) return NULL;\n\n        itr->entry.l = 0;\n        kputsn(itr->pathdir, colon - itr->pathdir, &itr->entry);\n        itr->pathdir = &colon[1];\n        if (itr->entry.l == 0) continue;\n\n        dir = opendir(itr->entry.s);\n        if (dir) break;\n\n        if (hts_verbose >= 4)\n            fprintf(stderr,\n                    \"[W::hts_path_itr] can't scan directory \\\"%s\\\": %s\\n\",\n                    itr->entry.s, strerror(errno));\n    }\n\n    if (itr->entry.s[itr->entry.l-1] != '/') kputc('/', &itr->entry);\n    itr->entry_dir_l = itr->entry.l;\n    return dir;\n}\n\nvoid hts_path_itr_setup(struct hts_path_itr *itr, const char *path,\n        const char *builtin_path, const char *prefix, size_t prefix_len,\n        const char *suffix, size_t suffix_len)\n{\n    itr->prefix = prefix;\n    itr->prefix_len = prefix_len;\n\n    if (suffix) itr->suffix = suffix, itr->suffix_len = suffix_len;\n    else itr->suffix = PLUGIN_EXT, itr->suffix_len = strlen(PLUGIN_EXT);\n\n    itr->path.l = itr->path.m = 0; itr->path.s = NULL;\n    itr->entry.l = itr->entry.m = 0; itr->entry.s = NULL;\n\n    if (! builtin_path) builtin_path = PLUGINPATH;\n    if (! path) {\n        path = getenv(\"HTS_PATH\");\n        if (! path) path = \"\";\n    }\n\n    while (1) {\n        size_t len = strcspn(path, HTS_PATH_SEPARATOR_STR);\n        if (len == 0) kputs(builtin_path, &itr->path);\n        else kputsn(path, len, &itr->path);\n        kputc(HTS_PATH_SEPARATOR_CHAR, &itr->path);\n\n        path += len;\n        if (*path == HTS_PATH_SEPARATOR_CHAR) path++;\n        else break;\n    }\n\n    // Note that ':' now terminates entries rather than separates them\n    itr->pathdir = itr->path.s;\n    itr->dirv = open_nextdir(itr);\n}\n\nconst char *hts_path_itr_next(struct hts_path_itr *itr)\n{\n    while (itr->dirv) {\n        struct dirent *e;\n        while ((e = readdir((DIR *) itr->dirv)) != NULL) {\n            size_t d_name_len = strlen(e->d_name);\n            if (strncmp(e->d_name, itr->prefix, itr->prefix_len) == 0 &&\n                d_name_len >= itr->suffix_len &&\n                strncmp(e->d_name + d_name_len - itr->suffix_len, itr->suffix,\n                        itr->suffix_len) == 0) {\n                itr->entry.l = itr->entry_dir_l;\n                kputs(e->d_name, &itr->entry);\n                return itr->entry.s;\n            }\n        }\n\n        closedir((DIR *) itr->dirv);\n        itr->dirv = open_nextdir(itr);\n    }\n\n    itr->pathdir = NULL;\n    free(itr->path.s); itr->path.s = NULL;\n    free(itr->entry.s); itr->entry.s = NULL;\n    return NULL;\n}\n\n\n#ifndef RTLD_NOLOAD\n#define RTLD_NOLOAD 0\n#endif\n\nvoid *load_plugin(void **pluginp, const char *filename, const char *symbol)\n{\n    void *lib = dlopen(filename, RTLD_NOW | RTLD_LOCAL);\n    if (lib == NULL) goto error;\n\n    void *sym = dlsym(lib, symbol);\n    if (sym == NULL) {\n        // Reopen the plugin with RTLD_GLOBAL and check for uniquified symbol\n        void *libg = dlopen(filename, RTLD_NOLOAD | RTLD_NOW | RTLD_GLOBAL);\n        if (libg == NULL) goto error;\n        dlclose(lib);\n        lib = libg;\n\n        kstring_t symbolg = { 0, 0, NULL };\n        kputs(symbol, &symbolg);\n        kputc('_', &symbolg);\n        const char *slash = strrchr(filename, '/');\n        const char *basename = slash? slash+1 : filename;\n        kputsn(basename, strcspn(basename, \".-+\"), &symbolg);\n\n        sym = dlsym(lib, symbolg.s);\n        free(symbolg.s);\n        if (sym == NULL) goto error;\n    }\n\n    *pluginp = lib;\n    return sym;\n\nerror:\n    if (hts_verbose >= 4)\n        fprintf(stderr, \"[W::%s] can't load plugin \\\"%s\\\": %s\\n\",\n                __func__, filename, dlerror());\n    if (lib) dlclose(lib);\n    return NULL;\n}\n\nvoid *plugin_sym(void *plugin, const char *name, const char **errmsg)\n{\n    void *sym = dlsym(plugin, name);\n    if (sym == NULL) *errmsg = dlerror();\n    return sym;\n}\n\nvoid close_plugin(void *plugin)\n{\n    if (dlclose(plugin) != 0) {\n        if (hts_verbose >= 4)\n            fprintf(stderr, \"[W::%s] dlclose() failed: %s\\n\",\n                    __func__, dlerror());\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/hfile_internal.h": "/*  hfile_internal.h -- internal parts of low-level input/output streams.\n\n    Copyright (C) 2013-2016, 2019 Genome Research Ltd.\n\n    Author: John Marshall <jm18@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#ifndef HFILE_INTERNAL_H\n#define HFILE_INTERNAL_H\n\n#include <stdarg.h>\n\n#include \"htslib/hts_defs.h\"\n#include \"htslib/hfile.h\"\n\n#include \"textutils_internal.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*!\n  @abstract  Resizes the buffer within an hFILE.\n\n  @notes  Changes the buffer size for an hFILE.  Ideally this is done\n  immediately after opening.  If performed later, this function may\n  fail if we are reducing the buffer size and the current offset into\n  the buffer is beyond the new capacity.\n\n  @param fp        The file stream\n  @param bufsiz    The size of the new buffer\n\n  @return Returns 0 on success, -1 on failure.\n */\nint hfile_set_blksize(hFILE *fp, size_t bufsiz);\n\nstruct BGZF;\n/*!\n  @abstract Return the hFILE connected to a BGZF\n */\nstruct hFILE *bgzf_hfile(struct BGZF *fp);\n\nstruct hFILE_backend {\n    /* As per read(2), returning the number of bytes read (possibly 0) or\n       negative (and setting errno) on errors.  Front-end code will call this\n       repeatedly if necessary to attempt to get the desired byte count.  */\n    ssize_t (*read)(hFILE *fp, void *buffer, size_t nbytes) HTS_RESULT_USED;\n\n    /* As per write(2), returning the number of bytes written or negative (and\n       setting errno) on errors.  Front-end code will call this repeatedly if\n       necessary until the desired block is written or an error occurs.  */\n    ssize_t (*write)(hFILE *fp, const void *buffer, size_t nbytes)\n        HTS_RESULT_USED;\n\n    /* As per lseek(2), returning the resulting offset within the stream or\n       negative (and setting errno) on errors.  */\n    off_t (*seek)(hFILE *fp, off_t offset, int whence) HTS_RESULT_USED;\n\n    /* Performs low-level flushing, if any, e.g., fsync(2); for writing streams\n       only.  Returns 0 for success or negative (and sets errno) on errors. */\n    int (*flush)(hFILE *fp) HTS_RESULT_USED;\n\n    /* Closes the underlying stream (for output streams, the buffer will\n       already have been flushed), returning 0 for success or negative (and\n       setting errno) on errors, as per close(2).  */\n    int (*close)(hFILE *fp) HTS_RESULT_USED;\n};\n\n/* May be called by hopen_*() functions to decode a fopen()-style mode into\n   open(2)-style flags.  */\nint hfile_oflags(const char *mode);\n\n/* Must be called by hopen_*() functions to allocate the hFILE struct and set\n   up its base.  Capacity is a suggested buffer size (e.g., via fstat(2))\n   or 0 for a default-sized buffer.  */\nhFILE *hfile_init(size_t struct_size, const char *mode, size_t capacity);\n\n/* Alternative to hfile_init() for in-memory backends for which the base\n   buffer is the only storage.  Buffer is already allocated via malloc(2)\n   of size buf_size and with buf_filled bytes already filled.  Ownership\n   of the buffer is transferred to the resulting hFILE.  */\nhFILE *hfile_init_fixed(size_t struct_size, const char *mode,\n                        char *buffer, size_t buf_filled, size_t buf_size);\n\n/* May be called by hopen_*() functions to undo the effects of hfile_init()\n   in the event opening the stream subsequently fails.  (This is safe to use\n   even if fp is NULL.  This takes care to preserve errno.)  */\nvoid hfile_destroy(hFILE *fp);\n\n\nstruct hFILE_scheme_handler {\n    /* Opens a stream when dispatched by hopen(); should call hfile_init()\n       to malloc a struct \"derived\" from hFILE and initialise it appropriately,\n       including setting base.backend to its own backend vector.  */\n    hFILE *(*open)(const char *filename, const char *mode) HTS_RESULT_USED;\n\n    /* Returns whether the URL denotes remote storage when dispatched by\n       hisremote().  For simple cases, use one of hfile_always_*() below.  */\n    int (*isremote)(const char *filename) HTS_RESULT_USED;\n\n    /* The name of the plugin or other code providing this handler.  */\n    const char *provider;\n\n    /* If multiple handlers are registered for the same scheme, the one with\n       the highest priority is used; range is 0 (lowest) to 100 (highest).\n       This field is used modulo 1000 as a priority; thousands indicate\n       later revisions to this structure, as noted below.  */\n    int priority;\n\n    /* Fields below are present when priority >= 2000.  */\n\n    /* Same as the open() method, used when extra arguments have been given\n       to hopen().  */\n    hFILE *(*vopen)(const char *filename, const char *mode, va_list args)\n        HTS_RESULT_USED;\n};\n\n/* May be used as an isremote() function in simple cases.  */\nextern int hfile_always_local (const char *fname);\nextern int hfile_always_remote(const char *fname);\n\n/* Should be called by plugins for each URL scheme they wish to handle.  */\nvoid hfile_add_scheme_handler(const char *scheme,\n                              const struct hFILE_scheme_handler *handler);\n\nstruct hFILE_plugin {\n    /* On entry, HTSlib's plugin API version (currently 1).  */\n    int api_version;\n\n    /* On entry, the plugin's handle as returned by dlopen() etc.  */\n    void *obj;\n\n    /* The plugin should fill this in with its (human-readable) name.  */\n    const char *name;\n\n    /* The plugin may wish to fill in a function to be called on closing.  */\n    void (*destroy)(void);\n};\n\n#ifdef ENABLE_PLUGINS\n#define PLUGIN_GLOBAL(identifier,suffix) identifier\n\n/* Plugins must define an entry point with this signature.  */\nHTSLIB_EXPORT\nextern int hfile_plugin_init(struct hFILE_plugin *self);\n\n#else\n#define PLUGIN_GLOBAL(identifier,suffix) identifier##suffix\n\n/* Only plugins distributed within the HTSlib source that might be built\n   even with --disable-plugins need to use PLUGIN_GLOBAL and be listed here;\n   others can simply define hfile_plugin_init().  */\n\nextern int hfile_plugin_init_gcs(struct hFILE_plugin *self);\nextern int hfile_plugin_init_libcurl(struct hFILE_plugin *self);\nextern int hfile_plugin_init_s3(struct hFILE_plugin *self);\nextern int hfile_plugin_init_s3_write(struct hFILE_plugin *self);\n#endif\n\n/* This one is never built as a separate plugin.  */\nextern int hfile_plugin_init_net(struct hFILE_plugin *self);\n\n// Callback to allow headers to be set in http connections.  Currently used\n// to allow s3 to renew tokens when seeking.  Kept internal for now,\n// although we may consider exposing it in the API later.\ntypedef int (* hts_httphdr_callback) (void *cb_data, char ***hdrs);\n\n/** Callback for handling 3xx redirect responses from http connections.\n\n    @param data       is passed to the callback\n    @param response   http response code (e.g. 301)\n    @param headers    http response headers\n    @param new_url    the callback should write the url to switch to in here\n\n    Currently used by s3 to handle switching region endpoints.\n*/\ntypedef int (*redirect_callback) (void *data, long response,\n                                  kstring_t *headers, kstring_t *new_url);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/index.bam.csi",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/xx#large_aux_java.cram",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/range.cram",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/index.cram.crai",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/range.bam.bai",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/range.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/auxf#values_java.cram",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/no_hdr_sq_1.bam.csi",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/bgziptest.txt.gz.gzi",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/range.cram.crai",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/index.bcf.csi",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/index.sam.gz.bai",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/ce#5b_java.cram",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/index.vcf.gz.tbi",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/index.vcf.gz.csi",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/colons.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/colons.bam.bai",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/no_hdr_sq_1.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/bgziptest.txt.gz",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/index.sam.gz.csi",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/index.bam.bai",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/htslib-1.10/test/mpileup/small.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/stat/11_target.bam.bai",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/stat/12_overlaps.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/stat/11_target.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/dat/test_input_1_a.cram",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/dat/test_input_1_b.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/dat/test_input_1_a.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/dat/test_input_1_c.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/dat/test_input_1_a.bam.bai.expected",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/bedcov/bedcov.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/bedcov/bedcov.bam.bai",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/mpileup.1.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/ce#unmap2.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/xx#minimal.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/ce#5b.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/1read.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/ce#5b.cram.crai",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/mpileup.1.bam.bai",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/ce#unmap.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/xx#triplet.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/mpileup.2.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/mpileup.3.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/ce#5b.cram",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/c1#pad1.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/ce#5b.bam.bai",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/overlapIllumina.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/ce#unmap1.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/overlap.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/ce#large_seq.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/c1#pad3.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/c1#pad2.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/mpileup-E.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/c1#clip.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/mpileup/expected/1.out.f3-6.gz",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/quickcheck/5.quickcheck.scramble30.truncated.cram",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/quickcheck/2.quickcheck.badheader.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/quickcheck/9.quickcheck.cram30.truncated.cram",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/quickcheck/4.quickcheck.ok.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/quickcheck/1.quickcheck.badeof.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/quickcheck/6.quickcheck.cram21.ok.cram",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/quickcheck/8.quickcheck.cram21.truncated.cram",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/quickcheck/10.quickcheck.notargets.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/quickcheck/3.quickcheck.ok.bam",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/test/quickcheck/7.quickcheck.cram30.ok.cram",
        "/tmp/vanessa/spack-stage/spack-stage-samtools-1.10-amv62bsyvbjgxc3qcuo3mehfy7vbops3/spack-src/examples/ex1.sam.gz"
    ],
    "total_files": 886
}