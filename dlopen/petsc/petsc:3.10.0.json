{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/config/PETSc/Configure.py": "import config.base\n\nimport os\nimport sys\nimport re\nimport cPickle\nimport string\n\n# The sorted() builtin is not available with python-2.3\ntry: sorted\nexcept NameError:\n  def sorted(lst):\n    lst.sort()\n    return lst\n\nclass Configure(config.base.Configure):\n  def __init__(self, framework):\n    config.base.Configure.__init__(self, framework)\n    self.headerPrefix = 'PETSC'\n    self.substPrefix  = 'PETSC'\n    self.installed = 0 # 1 indicates that Configure itself has already compiled and installed PETSc\n    return\n\n  def __str2__(self):\n    desc = []\n    if not self.installed:\n      desc.append('xxx=========================================================================xxx')\n      if self.make.getMakeMacro('MAKE_IS_GNUMAKE'):\n        build_type = 'gnumake build'\n      elif self.getMakeMacro('PETSC_BUILD_USING_CMAKE'):\n        build_type = 'cmake build'\n      else:\n        build_type = 'legacy build'\n      desc.append(' Configure stage complete. Now build PETSc libraries with (%s):' % build_type)\n      desc.append('   make PETSC_DIR='+self.petscdir.dir+' PETSC_ARCH='+self.arch.arch+' all')\n      desc.append('xxx=========================================================================xxx')\n    else:\n      desc.append('xxx=========================================================================xxx')\n      desc.append(' Installation complete. You do not need to run make to compile or install the software')\n      desc.append('xxx=========================================================================xxx')\n    return '\\n'.join(desc)+'\\n'\n\n  def setupHelp(self, help):\n    import nargs\n    help.addArgument('PETSc',  '-prefix=<dir>',                   nargs.Arg(None, '', 'Specifiy location to install PETSc (eg. /usr/local)'))\n    help.addArgument('PETSc',  '-with-prefetch=<bool>',           nargs.ArgBool(None, 1,'Enable checking for prefetch instructions'))\n    help.addArgument('Windows','-with-windows-graphics=<bool>',   nargs.ArgBool(None, 1,'Enable check for Windows Graphics'))\n    help.addArgument('PETSc', '-with-default-arch=<bool>',        nargs.ArgBool(None, 1, 'Allow using the last configured arch without setting PETSC_ARCH'))\n    help.addArgument('PETSc','-with-single-library=<bool>',       nargs.ArgBool(None, 1,'Put all PETSc code into the single -lpetsc library'))\n    help.addArgument('PETSc','-with-fortran-bindings=<bool>',     nargs.ArgBool(None, 1,'Build PETSc fortran bindings in the library and corresponding module files'))\n    help.addArgument('PETSc', '-with-ios=<bool>',              nargs.ArgBool(None, 0, 'Build an iPhone/iPad version of PETSc library'))\n    help.addArgument('PETSc', '-with-xsdk-defaults', nargs.ArgBool(None, 0, 'Set the following as defaults for the xSDK standard: --enable-debug=1, --enable-shared=1, --with-precision=double, --with-index-size=32, locate blas/lapack automatically'))\n    help.addArgument('PETSc', '-known-has-attribute-aligned=<bool>',nargs.ArgBool(None, None, 'Indicates __attribute((aligned(16)) directive works (the usual test will be skipped)'))\n    help.addArgument('PETSc', '-with-display=<x11display>',       nargs.Arg(None, '', 'Specifiy DISPLAY env variable for use with matlab test)'))\n    return\n\n  def registerPythonFile(self,filename,directory):\n    ''' Add a python file to the framework and registers its headerprefix, ... externalpackagedir\n        directory is the directory where the file relative to the BuildSystem or config path in python notation with . '''\n    (utilityName, ext) = os.path.splitext(filename)\n    if not utilityName.startswith('.') and not utilityName.startswith('#') and ext == '.py' and not utilityName == '__init__':\n      if directory: directory = directory+'.'\n      utilityObj                             = self.framework.require(directory+utilityName, self)\n      utilityObj.headerPrefix                = self.headerPrefix\n      utilityObj.archProvider                = self.arch\n      utilityObj.languageProvider            = self.languages\n      utilityObj.installDirProvider          = self.installdir\n      utilityObj.externalPackagesDirProvider = self.externalpackagesdir\n      utilityObj.precisionProvider           = self.scalartypes\n      utilityObj.indexProvider               = self.indexTypes\n      setattr(self, utilityName.lower(), utilityObj)\n      return utilityObj\n    return None\n\n  def setupDependencies(self, framework):\n    config.base.Configure.setupDependencies(self, framework)\n    self.programs      = framework.require('config.programs',           self)\n    self.setCompilers  = framework.require('config.setCompilers',       self)\n    self.compilers     = framework.require('config.compilers',          self)\n    self.arch          = framework.require('PETSc.options.arch',        self.setCompilers)\n    self.petscdir      = framework.require('PETSc.options.petscdir',    self.arch)\n    self.installdir    = framework.require('PETSc.options.installDir',  self)\n    self.scalartypes   = framework.require('PETSc.options.scalarTypes', self)\n    self.indexTypes    = framework.require('PETSc.options.indexTypes',  self)\n    self.languages     = framework.require('PETSc.options.languages',   self.setCompilers)\n    self.indexTypes    = framework.require('PETSc.options.indexTypes',  self.compilers)\n    self.compilers     = framework.require('config.compilers',          self)\n    self.types         = framework.require('config.types',              self)\n    self.headers       = framework.require('config.headers',            self)\n    self.functions     = framework.require('config.functions',          self)\n    self.libraries     = framework.require('config.libraries',          self)\n    self.atomics       = framework.require('config.atomics',            self)\n    self.make          = framework.require('config.packages.make',      self)\n    self.blasLapack    = framework.require('config.packages.BlasLapack',self)\n    self.cmake         = framework.require('config.packages.cmake',self)\n    self.externalpackagesdir = framework.require('PETSc.options.externalpackagesdir',self)\n    self.mpi           = framework.require('config.packages.MPI',self)\n\n    for utility in sorted(os.listdir(os.path.join('config','PETSc','options'))):\n      self.registerPythonFile(utility,'PETSc.options')\n\n    for utility in sorted(os.listdir(os.path.join('config','BuildSystem','config','utilities'))):\n      self.registerPythonFile(utility,'config.utilities')\n\n    for package in sorted(os.listdir(os.path.join('config', 'BuildSystem', 'config', 'packages'))):\n      obj = self.registerPythonFile(package,'config.packages')\n      if obj:\n        obj.archProvider                = self.framework.requireModule(obj.archProvider, obj)\n        obj.languageProvider            = self.framework.requireModule(obj.languageProvider, obj)\n        obj.installDirProvider          = self.framework.requireModule(obj.installDirProvider, obj)\n        obj.externalPackagesDirProvider = self.framework.requireModule(obj.externalPackagesDirProvider, obj)\n        obj.precisionProvider           = self.framework.requireModule(obj.precisionProvider, obj)\n        obj.indexProvider               = self.framework.requireModule(obj.indexProvider, obj)\n\n    # Force blaslapack and opencl to depend on scalarType so precision is set before BlasLapack is built\n    framework.require('PETSc.options.scalarTypes', self.f2cblaslapack)\n    framework.require('PETSc.options.scalarTypes', self.fblaslapack)\n    framework.require('PETSc.options.scalarTypes', self.blaslapack)\n    framework.require('PETSc.options.scalarTypes', self.opencl)\n\n    self.programs.headerPrefix   = self.headerPrefix\n    self.compilers.headerPrefix  = self.headerPrefix\n    self.types.headerPrefix      = self.headerPrefix\n    self.headers.headerPrefix    = self.headerPrefix\n    self.functions.headerPrefix  = self.headerPrefix\n    self.libraries.headerPrefix  = self.headerPrefix\n\n    # Look for any user provided --download-xxx=directory packages\n    for arg in sys.argv:\n      if arg.startswith('--download-') and arg.find('=') > -1:\n        pname = arg[11:arg.find('=')]\n        if not hasattr(self,pname):\n          dname = os.path.dirname(arg[arg.find('=')+1:])\n          if os.path.isdir(dname) and not os.path.isfile(os.path.join(dname,pname+'.py')):\n            self.framework.logPrint('User is registering a new package: '+arg)\n            sys.path.append(dname)\n            self.registerPythonFile(pname+'.py','')\n\n    # test for a variety of basic headers and functions\n    headersC = map(lambda name: name+'.h', ['setjmp','dos', 'endian', 'fcntl', 'float', 'io', 'limits', 'malloc', 'pwd', 'search', 'strings',\n                                            'unistd', 'sys/sysinfo', 'machine/endian', 'sys/param', 'sys/procfs', 'sys/resource',\n                                            'sys/systeminfo', 'sys/times', 'sys/utsname','string', 'stdlib',\n                                            'sys/socket','sys/wait','netinet/in','netdb','Direct','time','Ws2tcpip','sys/types',\n                                            'WindowsX', 'cxxabi','float','ieeefp','stdint','sched','pthread','inttypes','immintrin','zmmintrin'])\n    functions = ['access', '_access', 'clock', 'drand48', 'getcwd', '_getcwd', 'getdomainname', 'gethostname',\n                 'gettimeofday', 'getwd', 'memalign', 'mkstemp', 'popen', 'PXFGETARG', 'rand', 'getpagesize',\n                 'readlink', 'realpath',  'sigaction', 'signal', 'sigset', 'usleep', 'sleep', '_sleep', 'socket',\n                 'times', 'gethostbyname', 'uname','snprintf','_snprintf','lseek','_lseek','time','fork','stricmp',\n                 'strcasecmp', 'bzero', 'dlopen', 'dlsym', 'dlclose', 'dlerror','get_nprocs','sysctlbyname',\n                 '_set_output_format','_mkdir']\n    libraries1 = [(['socket', 'nsl'], 'socket'), (['fpe'], 'handle_sigfpes')]\n    self.headers.headers.extend(headersC)\n    self.functions.functions.extend(functions)\n    self.libraries.libraries.extend(libraries1)\n\n    return\n\n  def DumpPkgconfig(self):\n    ''' Create a pkg-config file '''\n    if not os.path.exists(os.path.join(self.petscdir.dir,self.arch.arch,'lib','pkgconfig')):\n      os.makedirs(os.path.join(self.petscdir.dir,self.arch.arch,'lib','pkgconfig'))\n    fd = open(os.path.join(self.petscdir.dir,self.arch.arch,'lib','pkgconfig','PETSc.pc'),'w')\n    cflags_inc = ['-I${includedir}']\n    if self.framework.argDB['prefix']:\n      fd.write('prefix='+self.installdir.dir+'\\n')\n    else:\n      fd.write('prefix='+self.petscdir.dir+'\\n')\n      cflags_inc.append('-I' + os.path.join('${prefix}', self.arch.arch, 'include'))\n    fd.write('exec_prefix=${prefix}\\n')\n    fd.write('includedir=${prefix}/include\\n')\n    fd.write('libdir=${prefix}/lib\\n')\n\n    self.setCompilers.pushLanguage('C')\n    fd.write('ccompiler='+self.setCompilers.getCompiler()+'\\n')\n    fd.write('cflags_extra='+self.setCompilers.getCompilerFlags().strip()+'\\n')\n    fd.write('cflags_dep='+self.compilers.dependenciesGenerationFlag.get('C','')+'\\n')\n    fd.write('ldflag_rpath='+self.setCompilers.CSharedLinkerFlag+'\\n')\n    self.setCompilers.popLanguage()\n    if hasattr(self.compilers, 'C++'):\n      self.setCompilers.pushLanguage('C++')\n      fd.write('cxxcompiler='+self.setCompilers.getCompiler()+'\\n')\n      fd.write('cxxflags_extra='+self.setCompilers.getCompilerFlags().strip()+'\\n')\n      self.setCompilers.popLanguage()\n    if hasattr(self.compilers, 'FC'):\n      self.setCompilers.pushLanguage('FC')\n      fd.write('fcompiler='+self.setCompilers.getCompiler()+'\\n')\n      fd.write('fflags_extra='+self.setCompilers.getCompilerFlags().strip()+'\\n')\n      self.setCompilers.popLanguage()\n\n    fd.write('\\n')\n    fd.write('Name: PETSc\\n')\n    fd.write('Description: Library to solve ODEs and algebraic equations\\n')\n    fd.write('Version: %s\\n' % self.petscdir.version)\n    fd.write('Cflags: ' + ' '.join([self.setCompilers.CPPFLAGS] + cflags_inc) + '\\n')\n    fd.write('Libs: '+self.libraries.toStringNoDupes(['-L${libdir}', self.petsclib], with_rpath=False)+'\\n')\n    # Remove RPATH flags from library list.  User can add them using\n    # pkg-config --variable=ldflag_rpath and pkg-config --libs-only-L\n    fd.write('Libs.private: '+self.libraries.toStringNoDupes([f for f in self.packagelibs+self.complibs if not f.startswith(self.setCompilers.CSharedLinkerFlag)], with_rpath=False)+'\\n')\n\n    fd.close()\n    return\n\n  def DumpModule(self):\n    ''' Create a module file '''\n    if not os.path.exists(os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','modules')):\n      os.makedirs(os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','modules'))\n    if not os.path.exists(os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','modules','petsc')):\n      os.makedirs(os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','modules','petsc'))\n    if self.framework.argDB['prefix']:\n      installdir  = self.installdir.dir\n      installarch = ''\n      installpath = os.path.join(installdir,'bin')\n    else:\n      installdir  = self.petscdir.dir\n      installarch = self.arch.arch\n      installpath = os.path.join(installdir,installarch,'bin')+':'+os.path.join(installdir,'bin')\n    fd = open(os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','modules','petsc',self.petscdir.version),'w')\n    fd.write('''\\\n#%%Module\n\nproc ModulesHelp { } {\n    puts stderr \"This module sets the path and environment variables for petsc-%s\"\n    puts stderr \"     see http://www.mcs.anl.gov/petsc/ for more information      \"\n    puts stderr \"\"\n}\nmodule-whatis \"PETSc - Portable, Extensible Toolkit for Scientific Computation\"\n\nset petsc_dir   \"%s\"\nset petsc_arch  \"%s\"\n\nsetenv PETSC_ARCH \"$petsc_arch\"\nsetenv PETSC_DIR \"$petsc_dir\"\nprepend-path PATH \"%s\"\n''' % (self.petscdir.version, installdir, installarch, installpath))\n    fd.close()\n    return\n\n  def Dump(self):\n    ''' Actually put the values into the configuration files '''\n    # eventually everything between -- should be gone\n    if self.mpi.usingMPIUni:\n      #\n      # Remove any MPI/MPICH include files that may have been put here by previous runs of ./configure\n      self.executeShellCommand('rm -rf  '+os.path.join(self.petscdir.dir,self.arch.arch,'include','mpi*')+' '+os.path.join(self.petscdir.dir,self.arch.arch,'include','opa*'), log = self.log)\n\n    self.setCompilers.pushLanguage('C')\n    compiler = self.setCompilers.getCompiler()\n    if compiler.endswith('mpicc') or compiler.endswith('mpiicc'):\n      try:\n        output   = self.executeShellCommand(compiler + ' -show', log = self.log)[0]\n        compiler = output.split(' ')[0]\n        self.addDefine('MPICC_SHOW','\"'+output.strip().replace('\\n','\\\\\\\\n')+'\"')\n      except:\n        self.addDefine('MPICC_SHOW','\"Unavailable\"')\n    else:\n      self.addDefine('MPICC_SHOW','\"Unavailable\"')\n    self.setCompilers.popLanguage()\n#-----------------------------------------------------------------------------------------------------\n\n    # Sometimes we need C compiler, even if built with C++\n    self.setCompilers.pushLanguage('C')\n    self.addMakeMacro('CC_FLAGS',self.setCompilers.getCompilerFlags())\n    self.setCompilers.popLanguage()\n\n    # And sometimes we need a C++ compiler even when PETSc is built with C\n    if hasattr(self.compilers, 'CXX'):\n      self.setCompilers.pushLanguage('Cxx')\n      self.addDefine('HAVE_CXX','1')\n      self.addMakeMacro('CXX_FLAGS',self.setCompilers.getCompilerFlags())\n      cxx_linker = self.setCompilers.getLinker()\n      self.addMakeMacro('CXX_LINKER',cxx_linker)\n      self.addMakeMacro('CXX_LINKER_FLAGS',self.setCompilers.getLinkerFlags())\n      self.setCompilers.popLanguage()\n\n    # C preprocessor values\n    self.addMakeMacro('CPP_FLAGS',self.setCompilers.CPPFLAGS)\n\n    # compiler values\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    self.addMakeMacro('PCC',self.setCompilers.getCompiler())\n    self.addMakeMacro('PCC_FLAGS',self.setCompilers.getCompilerFlags())\n    self.setCompilers.popLanguage()\n    # .o or .obj\n    self.addMakeMacro('CC_SUFFIX','o')\n\n    # executable linker values\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    pcc_linker = self.setCompilers.getLinker()\n    self.addMakeMacro('PCC_LINKER',pcc_linker)\n    self.addMakeMacro('PCC_LINKER_FLAGS',self.setCompilers.getLinkerFlags())\n    self.setCompilers.popLanguage()\n    # '' for Unix, .exe for Windows\n    self.addMakeMacro('CC_LINKER_SUFFIX','')\n\n    if hasattr(self.compilers, 'FC'):\n      if self.framework.argDB['with-fortran-bindings']:\n        self.addDefine('HAVE_FORTRAN','1')\n      self.setCompilers.pushLanguage('FC')\n      # need FPPFLAGS in config/setCompilers\n      self.addMakeMacro('FPP_FLAGS',self.setCompilers.CPPFLAGS)\n\n      # compiler values\n      self.addMakeMacro('FC_FLAGS',self.setCompilers.getCompilerFlags())\n      self.setCompilers.popLanguage()\n      # .o or .obj\n      self.addMakeMacro('FC_SUFFIX','o')\n\n      # executable linker values\n      self.setCompilers.pushLanguage('FC')\n      # Cannot have NAG f90 as the linker - so use pcc_linker as fc_linker\n      fc_linker = self.setCompilers.getLinker()\n      if config.setCompilers.Configure.isNAG(fc_linker, self.log):\n        self.addMakeMacro('FC_LINKER',pcc_linker)\n      else:\n        self.addMakeMacro('FC_LINKER',fc_linker)\n      self.addMakeMacro('FC_LINKER_FLAGS',self.setCompilers.getLinkerFlags())\n      # apple requires this shared library linker flag on SOME versions of the os\n      if self.setCompilers.getLinkerFlags().find('-Wl,-commons,use_dylibs') > -1:\n        self.addMakeMacro('DARWIN_COMMONS_USE_DYLIBS',' -Wl,-commons,use_dylibs ')\n      self.setCompilers.popLanguage()\n\n      # F90 Modules\n      if self.setCompilers.fortranModuleIncludeFlag:\n        self.addMakeMacro('FC_MODULE_FLAG', self.setCompilers.fortranModuleIncludeFlag)\n      else: # for non-f90 compilers like g77\n        self.addMakeMacro('FC_MODULE_FLAG', '-I')\n      if self.setCompilers.fortranModuleIncludeFlag:\n        self.addMakeMacro('FC_MODULE_OUTPUT_FLAG', self.setCompilers.fortranModuleOutputFlag)\n    else:\n      self.addMakeMacro('FC','')\n\n    if hasattr(self.compilers, 'CUDAC'):\n      self.setCompilers.pushLanguage('CUDA')\n      self.addMakeMacro('CUDAC_FLAGS',self.setCompilers.getCompilerFlags())\n      self.setCompilers.popLanguage()\n\n    # shared library linker values\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    # need to fix BuildSystem to collect these separately\n    self.addMakeMacro('SL_LINKER',self.setCompilers.getLinker())\n    self.addMakeMacro('SL_LINKER_FLAGS','${PCC_LINKER_FLAGS}')\n    self.setCompilers.popLanguage()\n    # One of 'a', 'so', 'lib', 'dll', 'dylib' (perhaps others also?) depending on the library generator and architecture\n    # Note: . is not included in this macro, consistent with AR_LIB_SUFFIX\n    if self.setCompilers.sharedLibraryExt == self.setCompilers.AR_LIB_SUFFIX:\n      self.addMakeMacro('SL_LINKER_SUFFIX', '')\n      self.addDefine('SLSUFFIX','\"\"')\n    else:\n      self.addMakeMacro('SL_LINKER_SUFFIX', self.setCompilers.sharedLibraryExt)\n      self.addDefine('SLSUFFIX','\"'+self.setCompilers.sharedLibraryExt+'\"')\n\n    self.addMakeMacro('SL_LINKER_LIBS','${PETSC_EXTERNAL_LIB_BASIC}')\n\n#-----------------------------------------------------------------------------------------------------\n\n    # CONLY or CPP. We should change the PETSc makefiles to do this better\n    if self.languages.clanguage == 'C': lang = 'CONLY'\n    else: lang = 'CXXONLY'\n    self.addMakeMacro('PETSC_LANGUAGE',lang)\n\n    # real or complex\n    self.addMakeMacro('PETSC_SCALAR',self.scalartypes.scalartype)\n    # double or float\n    self.addMakeMacro('PETSC_PRECISION',self.scalartypes.precision)\n\n    if self.framework.argDB['with-batch']:\n      self.addMakeMacro('PETSC_WITH_BATCH','1')\n\n    # Test for compiler-specific macros that need to be defined.\n    if self.setCompilers.isCrayVector('CC', self.log):\n      self.addDefine('HAVE_CRAY_VECTOR','1')\n\n#-----------------------------------------------------------------------------------------------------\n    if self.functions.haveFunction('gethostbyname') and self.functions.haveFunction('socket') and self.headers.haveHeader('netinet/in.h'):\n      self.addDefine('USE_SOCKET_VIEWER','1')\n      if self.checkCompile('#include <sys/socket.h>','setsockopt(0,SOL_SOCKET,SO_REUSEADDR,0,0)'):\n        self.addDefine('HAVE_SO_REUSEADDR','1')\n\n#-----------------------------------------------------------------------------------------------------\n    # print include and lib for makefiles\n    self.framework.packages.reverse()\n    petscincludes = [os.path.join(self.petscdir.dir,'include'),os.path.join(self.petscdir.dir,self.arch.arch,'include')]\n    petscincludes_install = [os.path.join(self.installdir.dir, 'include')] if self.framework.argDB['prefix'] else petscincludes\n    includes = []\n    self.packagelibs = []\n    for i in self.framework.packages:\n      if i.useddirectly:\n        self.addDefine('HAVE_'+i.PACKAGE.replace('-','_'), 1)  # ONLY list package if it is used directly by PETSc (and not only by another package)\n      if not isinstance(i.lib, list):\n        i.lib = [i.lib]\n      if i.linkedbypetsc: self.packagelibs.extend(i.lib)\n      self.addMakeMacro(i.PACKAGE.replace('-','_')+'_LIB', self.libraries.toStringNoDupes(i.lib))\n      if hasattr(i,'include'):\n        if not isinstance(i.include,list):\n          i.include = [i.include]\n        includes.extend(i.include)\n        self.addMakeMacro(i.PACKAGE.replace('-','_')+'_INCLUDE',self.headers.toStringNoDupes(i.include))\n    if self.framework.argDB['with-single-library']:\n      self.petsclib = '-lpetsc'\n    else:\n      self.petsclib = '-lpetscts -lpetscsnes -lpetscksp -lpetscdm -lpetscmat -lpetscvec -lpetscsys'\n    self.complibs = self.compilers.flibs+self.compilers.cxxlibs+self.compilers.LIBS.split()\n    self.PETSC_WITH_EXTERNAL_LIB = self.libraries.toStringNoDupes(['-L${PETSC_DIR}/${PETSC_ARCH}/lib', self.petsclib]+self.packagelibs+self.complibs)\n    self.PETSC_EXTERNAL_LIB_BASIC = self.libraries.toStringNoDupes(self.packagelibs+self.complibs)\n    if self.framework.argDB['prefix'] and self.setCompilers.CSharedLinkerFlag not in ['-L']:\n      string.replace(self.PETSC_EXTERNAL_LIB_BASIC,self.setCompilers.CSharedLinkerFlag+os.path.join(self.petscdir.dir,self.arch.arch,'lib'),self.setCompilers.CSharedLinkerFlag+os.path.join(self.installdir.dir,'lib'))\n\n    self.addMakeMacro('PETSC_EXTERNAL_LIB_BASIC',self.PETSC_EXTERNAL_LIB_BASIC)\n    allincludes = petscincludes + includes\n    allincludes_install = petscincludes_install + includes\n    self.PETSC_CC_INCLUDES = self.headers.toStringNoDupes(allincludes)\n    self.PETSC_CC_INCLUDES_INSTALL = self.headers.toStringNoDupes(allincludes_install)\n    self.addMakeMacro('PETSC_CC_INCLUDES',self.PETSC_CC_INCLUDES)\n    self.addMakeMacro('PETSC_CC_INCLUDES_INSTALL', self.PETSC_CC_INCLUDES_INSTALL)\n    if hasattr(self.compilers, 'FC'):\n      def modinc(includes):\n        return includes if self.compilers.fortranIsF90 else []\n      self.addMakeMacro('PETSC_FC_INCLUDES',self.headers.toStringNoDupes(allincludes,modinc(allincludes)))\n      self.addMakeMacro('PETSC_FC_INCLUDES_INSTALL',self.headers.toStringNoDupes(allincludes_install,modinc(allincludes_install)))\n\n    self.addDefine('LIB_DIR','\"'+os.path.join(self.installdir.dir,'lib')+'\"')\n\n    if self.framework.argDB['with-single-library']:\n      # overrides the values set in conf/variables\n      self.addMakeMacro('LIBNAME','${INSTALL_LIB_DIR}/libpetsc.${AR_LIB_SUFFIX}')\n      self.addMakeMacro('SHLIBS','libpetsc')\n      self.addMakeMacro('PETSC_LIB_BASIC','-lpetsc')\n      self.addMakeMacro('PETSC_KSP_LIB_BASIC','-lpetsc')\n      self.addMakeMacro('PETSC_TS_LIB_BASIC','-lpetsc')\n      self.addMakeMacro('PETSC_TAO_LIB_BASIC','-lpetsc')\n      self.addMakeMacro('PETSC_WITH_EXTERNAL_LIB',self.PETSC_WITH_EXTERNAL_LIB)\n      self.addDefine('USE_SINGLE_LIBRARY', '1')\n      if self.sharedlibraries.useShared:\n        self.addMakeMacro('PETSC_SYS_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_VEC_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_MAT_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_DM_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_KSP_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_SNES_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_TS_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_TAO_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_CHARACTERISTIC_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_CONTRIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n      else:\n        self.addMakeMacro('PETSC_SYS_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_VEC_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_MAT_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_DM_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_KSP_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_SNES_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_TS_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_TAO_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_CHARACTERISTIC_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_CONTRIB','${PETSC_WITH_EXTERNAL_LIB}')\n\n    if not os.path.exists(os.path.join(self.petscdir.dir,self.arch.arch,'lib')):\n      os.makedirs(os.path.join(self.petscdir.dir,self.arch.arch,'lib'))\n\n# add a makefile endtry for display\n    if self.framework.argDB['with-display']:\n      self.addMakeMacro('DISPLAY',self.framework.argDB['with-display'])\n\n    # add a makefile entry for configure options\n    self.addMakeMacro('CONFIGURE_OPTIONS', self.framework.getOptionsString(['configModules', 'optionsModule']).replace('\\\"','\\\\\"'))\n    return\n\n  def dumpConfigInfo(self):\n    import time\n    fd = file(os.path.join(self.arch.arch,'include','petscconfiginfo.h'),'w')\n    fd.write('static const char *petscconfigureoptions = \"'+self.framework.getOptionsString(['configModules', 'optionsModule']).replace('\\\"','\\\\\"')+'\";\\n')\n    fd.close()\n    return\n\n  def dumpMachineInfo(self):\n    import platform\n    import datetime\n    import time\n    import script\n    def escape(s):\n      return s.replace('\"',r'\\\"').replace(r'\\ ',r'\\\\ ')\n    fd = file(os.path.join(self.arch.arch,'include','petscmachineinfo.h'),'w')\n    fd.write('static const char *petscmachineinfo = \\\"\\\\n\\\"\\n')\n    fd.write('\\\"-----------------------------------------\\\\n\\\"\\n')\n    buildhost = platform.node()\n    if os.environ.get('SOURCE_DATE_EPOCH'):\n      buildhost = \"reproducible\"\n    buildtime = datetime.datetime.utcfromtimestamp(int(os.environ.get('SOURCE_DATE_EPOCH', time.time())))\n    fd.write('\\\"Libraries compiled on %s on %s \\\\n\\\"\\n' % (buildtime, buildhost))\n    fd.write('\\\"Machine characteristics: %s\\\\n\\\"\\n' % (platform.platform()))\n    fd.write('\\\"Using PETSc directory: %s\\\\n\\\"\\n' % (escape(self.installdir.petscDir)))\n    fd.write('\\\"Using PETSc arch: %s\\\\n\\\"\\n' % (escape(self.installdir.petscArch)))\n    fd.write('\\\"-----------------------------------------\\\\n\\\";\\n')\n    fd.write('static const char *petsccompilerinfo = \\\"\\\\n\\\"\\n')\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    fd.write('\\\"Using C compiler: %s %s \\\\n\\\"\\n' % (escape(self.setCompilers.getCompiler()), escape(self.setCompilers.getCompilerFlags())))\n    self.setCompilers.popLanguage()\n    if hasattr(self.compilers, 'FC'):\n      self.setCompilers.pushLanguage('FC')\n      fd.write('\\\"Using Fortran compiler: %s %s  %s\\\\n\\\"\\n' % (escape(self.setCompilers.getCompiler()), escape(self.setCompilers.getCompilerFlags()), escape(self.setCompilers.CPPFLAGS)))\n      self.setCompilers.popLanguage()\n    fd.write('\\\"-----------------------------------------\\\\n\\\";\\n')\n    fd.write('static const char *petsccompilerflagsinfo = \\\"\\\\n\\\"\\n')\n    fd.write('\\\"Using include paths: %s\\\\n\\\"\\n' % (escape(self.PETSC_CC_INCLUDES_INSTALL.replace('${PETSC_DIR}', self.installdir.petscDir))))\n    fd.write('\\\"-----------------------------------------\\\\n\\\";\\n')\n    fd.write('static const char *petsclinkerinfo = \\\"\\\\n\\\"\\n')\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    fd.write('\\\"Using C linker: %s\\\\n\\\"\\n' % (escape(self.setCompilers.getLinker())))\n    self.setCompilers.popLanguage()\n    if hasattr(self.compilers, 'FC'):\n      self.setCompilers.pushLanguage('FC')\n      fd.write('\\\"Using Fortran linker: %s\\\\n\\\"\\n' % (escape(self.setCompilers.getLinker())))\n      self.setCompilers.popLanguage()\n    fd.write('\\\"Using libraries: %s%s -L%s %s %s\\\\n\\\"\\n' % (escape(self.setCompilers.CSharedLinkerFlag), escape(os.path.join(self.installdir.petscDir, self.installdir.petscArch, 'lib')), escape(os.path.join(self.installdir.petscDir, self.installdir.petscArch, 'lib')), escape(self.petsclib), escape(self.PETSC_EXTERNAL_LIB_BASIC)))\n    fd.write('\\\"-----------------------------------------\\\\n\\\";\\n')\n    fd.close()\n    return\n\n  def dumpCMakeConfig(self):\n    '''\n    Writes configuration-specific values to ${PETSC_ARCH}/lib/petsc/conf/PETScBuildInternal.cmake.\n    This file is private to PETSc and should not be included by third parties\n    (a suitable file can be produced later by CMake, but this is not it).\n    '''\n    def cmakeset(fd,key,val=True):\n      if val == True: val = 'YES'\n      if val == False: val = 'NO'\n      fd.write('set (' + key + ' ' + val + ')\\n')\n    def ensurelist(a):\n      if isinstance(a,list):\n        return a\n      else:\n        return [a]\n    def libpath(lib):\n      'Returns a search path if that is what this item provides, else \"\" which will be cleaned out later'\n      if not isinstance(lib,str): return ''\n      if lib.startswith('-L'): return lib[2:]\n      if lib.startswith('-R'): return lib[2:]\n      if lib.startswith('-Wl,-rpath,'):\n        # This case occurs when an external package needs a specific system library that is normally provided by the compiler.\n        # In other words, the -L path is builtin to the wrapper or compiler, here we provide it so that CMake can locate the\n        # corresponding library.\n        return lib[len('-Wl,-rpath,'):]\n      if lib.startswith('-'): return ''\n      return os.path.dirname(lib)\n    def cleanlib(lib):\n      'Returns a library name if that is what this item provides, else \"\" which will be cleaned out later'\n      if not isinstance(lib,str): return ''\n      if lib.startswith('-l'):  return lib[2:]\n      if lib.startswith('-Wl') or lib.startswith('-L'): return ''\n      lib = os.path.splitext(os.path.basename(lib))[0]\n      if lib.startswith('lib'): return lib[3:]\n      return lib\n    def nub(lst):\n      'Return a list containing the first occurrence of each unique element'\n      unique = []\n      for elem in lst:\n        if elem not in unique and elem != '':\n          unique.append(elem)\n      return unique\n    try: reversed # reversed was added in Python-2.4\n    except NameError:\n      def reversed(lst): return lst[::-1]\n    def nublast(lst):\n      'Return a list containing the last occurrence of each unique entry in a list'\n      return reversed(nub(reversed(lst)))\n    def cmakeexpand(varname):\n      return r'\"${' + varname + r'}\"'\n    def uniqextend(lst,new):\n      for x in ensurelist(new):\n        if x not in lst:\n          lst.append(x)\n    def notstandardinclude(path):\n      return path not in '/usr/include'.split() # /usr/local/include is not automatically included on FreeBSD\n    def writeMacroDefinitions(fd):\n      if self.mpi.usingMPIUni:\n        cmakeset(fd,'PETSC_HAVE_MPIUNI')\n      for pkg in self.framework.packages:\n        if pkg.useddirectly:\n          cmakeset(fd,'PETSC_HAVE_' + pkg.PACKAGE.replace('-','_'))\n        for pair in pkg.defines.items():\n          if pair[0].startswith('HAVE_') and pair[1]:\n            cmakeset(fd, self.framework.getFullDefineName(pkg, pair[0]), pair[1])\n      for name,val in self.functions.defines.items():\n        cmakeset(fd,'PETSC_'+name,val)\n      for dct in [self.defines, self.libraryoptions.defines]:\n        for k,v in dct.items():\n          if k.startswith('USE_'):\n            cmakeset(fd,'PETSC_' + k, v)\n      cmakeset(fd,'PETSC_USE_COMPLEX', self.scalartypes.scalartype == 'complex')\n      cmakeset(fd,'PETSC_USE_REAL_' + self.scalartypes.precision.upper())\n      cmakeset(fd,'PETSC_CLANGUAGE_'+self.languages.clanguage)\n      if hasattr(self.compilers, 'FC'):\n        cmakeset(fd,'PETSC_HAVE_FORTRAN')\n        if self.compilers.fortranIsF90:\n          cmakeset(fd,'PETSC_USING_F90')\n        if self.compilers.fortranIsF2003:\n          cmakeset(fd,'PETSC_USING_F2003')\n      if hasattr(self.compilers, 'CXX'):\n        cmakeset(fd,'PETSC_HAVE_CXX')\n      if self.sharedlibraries.useShared:\n        cmakeset(fd,'BUILD_SHARED_LIBS')\n    def writeBuildFlags(fd):\n      def extendby(lib):\n        libs = ensurelist(lib)\n        lib_paths.extend(map(libpath,libs))\n        lib_libs.extend(map(cleanlib,libs))\n      lib_paths = []\n      lib_libs  = []\n      includes  = []\n      libvars   = []\n      for pkg in self.framework.packages:\n        if pkg.linkedbypetsc:\n          extendby(pkg.lib)\n          uniqextend(includes,pkg.include)\n      extendby(self.libraries.math)\n      extendby(self.libraries.rt)\n      extendby(self.compilers.flibs)\n      extendby(self.compilers.cxxlibs)\n      extendby(self.compilers.LIBS.split())\n      for libname in nublast(lib_libs):\n        libvar = 'PETSC_' + libname.upper() + '_LIB'\n        addpath = ''\n        for lpath in nublast(lib_paths):\n          addpath += '\"' + str(lpath) + '\" '\n        fd.write('find_library (' + libvar + ' ' + libname + ' HINTS ' + addpath + ')\\n')\n        libvars.append(libvar)\n      fd.write('mark_as_advanced (' + ' '.join(libvars) + ')\\n')\n      fd.write('set (PETSC_PACKAGE_LIBS ' + ' '.join(map(cmakeexpand,libvars)) + ')\\n')\n      includes = filter(notstandardinclude,includes)\n      fd.write('set (PETSC_PACKAGE_INCLUDES ' + ' '.join(map(lambda i: '\"'+i+'\"',includes)) + ')\\n')\n    fd = open(os.path.join(self.arch.arch,'lib','petsc','conf','PETScBuildInternal.cmake'), 'w')\n    writeMacroDefinitions(fd)\n    writeBuildFlags(fd)\n    fd.close()\n    return\n\n  def dumpCMakeLists(self):\n    import sys\n    if sys.version_info >= (2,4):\n      import cmakegen\n      try:\n        cmakegen.main(self.petscdir.dir, log=self.framework.log)\n      except (OSError) as e:\n        self.framework.logPrint('Generating CMakeLists.txt failed:\\n' + str(e))\n    else:\n      self.framework.logPrint('Skipping cmakegen due to old python version: ' +str(sys.version_info) )\n\n  def cmakeBoot(self):\n    import sys\n    self.cmakeboot_success = False\n    if sys.version_info >= (2,4) and hasattr(self.cmake,'cmake'):\n      oldRead = self.argDB.readonly\n      self.argDB.readonly = True\n      try:\n        import cmakeboot\n        self.cmakeboot_success = cmakeboot.main(petscdir=self.petscdir.dir,petscarch=self.arch.arch,argDB=self.argDB,framework=self.framework,log=self.framework.log)\n      except (OSError) as e:\n        self.framework.logPrint('Booting CMake in PETSC_ARCH failed:\\n' + str(e))\n      except (ImportError, KeyError) as e:\n        self.framework.logPrint('Importing cmakeboot failed:\\n' + str(e))\n      self.argDB.readonly = oldRead\n      if self.cmakeboot_success:\n        if hasattr(self.compilers, 'FC') and self.compilers.fortranIsF90 and not self.setCompilers.fortranModuleOutputFlag:\n          self.framework.logPrint('CMake configured successfully, but could not be used by default because of missing fortranModuleOutputFlag\\n')\n        else:\n          self.framework.logPrint('CMake configured successfully, using as default build\\n')\n          self.addMakeMacro('PETSC_BUILD_USING_CMAKE',1)\n      else:\n        self.framework.logPrint('CMake configuration was unsuccessful\\n')\n    else:\n      self.framework.logPrint('Skipping cmakeboot due to old python version: ' +str(sys.version_info) )\n    return\n\n  def configurePrefetch(self):\n    '''Sees if there are any prefetch functions supported'''\n    if config.setCompilers.Configure.isSolaris(self.log) or self.framework.argDB['with-ios'] or not self.framework.argDB['with-prefetch']:\n      self.addDefine('Prefetch(a,b,c)', ' ')\n      return\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkLink('#include <xmmintrin.h>', 'void *v = 0;_mm_prefetch((const char*)v,_MM_HINT_NTA);\\n'):\n      # The Intel Intrinsics manual [1] specifies the prototype\n      #\n      #   void _mm_prefetch(char const *a, int sel);\n      #\n      # but other vendors seem to insist on using subtly different\n      # prototypes, including void* for the pointer, and an enum for\n      # sel.  These are both reasonable changes, but negatively impact\n      # portability.\n      #\n      # [1] http://software.intel.com/file/6373\n      self.addDefine('HAVE_XMMINTRIN_H', 1)\n      self.addDefine('Prefetch(a,b,c)', '_mm_prefetch((const char*)(a),(c))')\n      self.addDefine('PREFETCH_HINT_NTA', '_MM_HINT_NTA')\n      self.addDefine('PREFETCH_HINT_T0',  '_MM_HINT_T0')\n      self.addDefine('PREFETCH_HINT_T1',  '_MM_HINT_T1')\n      self.addDefine('PREFETCH_HINT_T2',  '_MM_HINT_T2')\n    elif self.checkLink('#include <xmmintrin.h>', 'void *v = 0;_mm_prefetch(v,_MM_HINT_NTA);\\n'):\n      self.addDefine('HAVE_XMMINTRIN_H', 1)\n      self.addDefine('Prefetch(a,b,c)', '_mm_prefetch((const void*)(a),(c))')\n      self.addDefine('PREFETCH_HINT_NTA', '_MM_HINT_NTA')\n      self.addDefine('PREFETCH_HINT_T0',  '_MM_HINT_T0')\n      self.addDefine('PREFETCH_HINT_T1',  '_MM_HINT_T1')\n      self.addDefine('PREFETCH_HINT_T2',  '_MM_HINT_T2')\n    elif self.checkLink('', 'void *v = 0;__builtin_prefetch(v,0,0);\\n'):\n      # From GCC docs: void __builtin_prefetch(const void *addr,int rw,int locality)\n      #\n      #   The value of rw is a compile-time constant one or zero; one\n      #   means that the prefetch is preparing for a write to the memory\n      #   address and zero, the default, means that the prefetch is\n      #   preparing for a read. The value locality must be a compile-time\n      #   constant integer between zero and three. A value of zero means\n      #   that the data has no temporal locality, so it need not be left\n      #   in the cache after the access. A value of three means that the\n      #   data has a high degree of temporal locality and should be left\n      #   in all levels of cache possible. Values of one and two mean,\n      #   respectively, a low or moderate degree of temporal locality.\n      #\n      # Here we adopt Intel's x86/x86-64 naming scheme for the locality\n      # hints.  Using macros for these values in necessary since some\n      # compilers require an enum.\n      self.addDefine('Prefetch(a,b,c)', '__builtin_prefetch((a),(b),(c))')\n      self.addDefine('PREFETCH_HINT_NTA', '0')\n      self.addDefine('PREFETCH_HINT_T0',  '3')\n      self.addDefine('PREFETCH_HINT_T1',  '2')\n      self.addDefine('PREFETCH_HINT_T2',  '1')\n    else:\n      self.addDefine('Prefetch(a,b,c)', ' ')\n    self.popLanguage()\n\n  def configureAtoll(self):\n    '''Checks if atoll exists'''\n    if self.checkLink('#define _POSIX_C_SOURCE 200112L\\n#include <stdlib.h>','long v = atoll(\"25\")') or self.checkLink ('#include <stdlib.h>','long v = atoll(\"25\")'):\n       self.addDefine('HAVE_ATOLL', '1')\n\n  def configureUnused(self):\n    '''Sees if __attribute((unused)) is supported'''\n    if self.framework.argDB['with-ios']:\n      self.addDefine('UNUSED', ' ')\n      return\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkLink('__attribute((unused)) static int myfunc(__attribute((unused)) void *name){ return 1;}', 'int i = 0;\\nint j = myfunc(&i);\\ntypedef void* atype;\\n__attribute((unused))  atype a;\\n'):\n      self.addDefine('UNUSED', '__attribute((unused))')\n    else:\n      self.addDefine('UNUSED', ' ')\n    self.popLanguage()\n\n  def configureIsatty(self):\n    '''Check if the Unix C function isatty() works correctly\n       Actually just assumes it does not work correctly on batch systems'''\n    if not self.framework.argDB['with-batch']:\n      self.addDefine('USE_ISATTY',1)\n\n  def configureDeprecated(self):\n    '''Check if __attribute((deprecated)) is supported'''\n    self.pushLanguage(self.languages.clanguage)\n    ## Recent versions of gcc and clang support __attribute((deprecated(\"string argument\"))), which is very useful, but\n    ## Intel has conspired to make a supremely environment-sensitive compiler.  The Intel compiler looks at the gcc\n    ## executable in the environment to determine the language compatibility that it should attempt to emulate.  Some\n    ## important Cray installations have built PETSc using the Intel compiler, but with a newer gcc module loaded (e.g.,\n    ## 4.7).  Thus at PETSc configure time, the Intel compiler decides to support the string argument, but the gcc\n    ## found in the default user environment is older and does not support the argument.  If GCC and Intel were cool\n    ## like Clang and supported __has_attribute, we could avoid configure tests entirely, but they don't.  And that is\n    ## why we can't have nice things.\n    #\n    # if self.checkCompile(\"\"\"__attribute((deprecated(\"Why you shouldn't use myfunc\"))) static int myfunc(void) { return 1;}\"\"\", ''):\n    #   self.addDefine('DEPRECATED(why)', '__attribute((deprecated(why)))')\n    if self.checkCompile(\"\"\"__attribute((deprecated)) static int myfunc(void) { return 1;}\"\"\", ''):\n      self.addDefine('DEPRECATED(why)', '__attribute((deprecated))')\n    else:\n      self.addDefine('DEPRECATED(why)', ' ')\n    self.popLanguage()\n\n  def configureAlign(self):\n    '''Check if __attribute(align) is supported'''\n    filename = 'conftestalign'\n    includes = '''\n#include <sys/types.h>\n#if STDC_HEADERS\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#endif\\n'''\n    body     = '''\nstruct mystruct {int myint;} __attribute((aligned(16)));\nFILE *f = fopen(\"'''+filename+'''\", \"w\");\nif (!f) exit(1);\nfprintf(f, \"%lu\\\\n\", (unsigned long)sizeof(struct mystruct));\n'''\n    if 'known-has-attribute-aligned' in self.argDB:\n      if self.argDB['known-has-attribute-aligned']:\n        size = 16\n      else:\n        size = -3\n    elif not self.argDB['with-batch']:\n      self.pushLanguage(self.languages.clanguage)\n      try:\n        if self.checkRun(includes, body) and os.path.exists(filename):\n          f    = file(filename)\n          size = int(f.read())\n          f.close()\n          os.remove(filename)\n        else:\n          size = -4\n      except:\n        size = -1\n        self.framework.logPrint('Error checking attribute(aligned)')\n      self.popLanguage()\n    else:\n      self.framework.addBatchInclude(['#include <stdlib.h>', '#include <stdio.h>', '#include <sys/types.h>','struct mystruct {int myint;} __attribute((aligned(16)));'])\n      self.framework.addBatchBody('fprintf(output, \"  \\'--known-has-attribute-aligned=%d\\',\\\\n\", sizeof(struct mystruct)==16);')\n      size = -2\n    if size == 16:\n      self.addDefine('ATTRIBUTEALIGNED(size)', '__attribute((aligned (size)))')\n      self.addDefine('HAVE_ATTRIBUTEALIGNED', 1)\n    else:\n      self.framework.logPrint('incorrect alignment. Found alignment:'+ str(size))\n      self.addDefine('ATTRIBUTEALIGNED(size)', ' ')\n    return\n\n  def configureExpect(self):\n    '''Sees if the __builtin_expect directive is supported'''\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkLink('', 'if (__builtin_expect(0,1)) return 1;'):\n      self.addDefine('HAVE_BUILTIN_EXPECT', 1)\n    self.popLanguage()\n\n  def configureFunctionName(self):\n    '''Sees if the compiler supports __func__ or a variant.'''\n    def getFunctionName(lang):\n      name = '\"unknown\"'\n      self.pushLanguage(lang)\n      for fname in ['__func__','__FUNCTION__','__extension__ __func__']:\n        code = \"if (\"+fname+\"[0] != 'm') return 1;\"\n        if self.checkCompile('',code) and self.checkLink('',code):\n          name = fname\n          break\n      self.popLanguage()\n      return name\n    langs = []\n\n    self.addDefine('FUNCTION_NAME_C', getFunctionName('C'))\n    if hasattr(self.compilers, 'CXX'):\n      self.addDefine('FUNCTION_NAME_CXX', getFunctionName('Cxx'))\n\n  def configureIntptrt(self):\n    '''Determine what to use for uintptr_t'''\n    def staticAssertSizeMatchesVoidStar(inc,typename):\n      # The declaration is an error if either array size is negative.\n      # It should be okay to use an int that is too large, but it would be very unlikely for this to be the case\n      return self.checkCompile(inc, ('#define STATIC_ASSERT(cond) char negative_length_if_false[2*(!!(cond))-1]\\n'\n                                     + 'STATIC_ASSERT(sizeof(void*) == sizeof(%s));'%typename))\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkCompile('#include <stdint.h>', 'int x; uintptr_t i = (uintptr_t)&x;'):\n      self.addDefine('UINTPTR_T', 'uintptr_t')\n    elif staticAssertSizeMatchesVoidStar('','unsigned long long'):\n      self.addDefine('UINTPTR_T', 'unsigned long long')\n    elif staticAssertSizeMatchesVoidStar('#include <stdlib.h>','size_t') or staticAssertSizeMatchesVoidStar('#include <string.h>', 'size_t'):\n      self.addDefine('UINTPTR_T', 'size_t')\n    elif staticAssertSizeMatchesVoidStar('','unsigned long'):\n      self.addDefine('UINTPTR_T', 'unsigned long')\n    elif staticAssertSizeMatchesVoidStar('','unsigned'):\n      self.addDefine('UINTPTR_T', 'unsigned')\n    else:\n      raise RuntimeError('Could not find any unsigned integer type matching void*')\n    self.popLanguage()\n\n  def configureRTLDDefault(self):\n    if self.checkCompile('#include <dlfcn.h>\\n void *ptr =  RTLD_DEFAULT;'):\n      self.addDefine('RTLD_DEFAULT','1')\n    return\n\n  def configureSolaris(self):\n    '''Solaris specific stuff'''\n    if os.path.isdir(os.path.join('/usr','ucblib')):\n      try:\n        flag = getattr(self.setCompilers, self.language[-1]+'SharedLinkerFlag')\n      except AttributeError:\n        flag = None\n      if flag is None:\n        self.compilers.LIBS += ' -L/usr/ucblib'\n      else:\n        self.compilers.LIBS += ' '+flag+'/usr/ucblib'\n    return\n\n  def configureLinux(self):\n    '''Linux specific stuff'''\n    # TODO: Test for this by mallocing an odd number of floats and checking the address\n    self.addDefine('HAVE_DOUBLE_ALIGN_MALLOC', 1)\n    return\n\n  def configureWin32(self):\n    '''Win32 non-cygwin specific stuff'''\n    kernel32=0\n    if self.libraries.add('Kernel32.lib','GetComputerName',prototype='#include <Windows.h>', call='GetComputerName(NULL,NULL);'):\n      self.addDefine('HAVE_WINDOWS_H',1)\n      self.addDefine('HAVE_GETCOMPUTERNAME',1)\n      kernel32=1\n    elif self.libraries.add('kernel32','GetComputerName',prototype='#include <Windows.h>', call='GetComputerName(NULL,NULL);'):\n      self.addDefine('HAVE_WINDOWS_H',1)\n      self.addDefine('HAVE_GETCOMPUTERNAME',1)\n      kernel32=1\n    if kernel32:\n      if self.framework.argDB['with-windows-graphics']:\n        self.addDefine('USE_WINDOWS_GRAPHICS',1)\n      if self.checkLink('#include <Windows.h>','LoadLibrary(0)'):\n        self.addDefine('HAVE_LOADLIBRARY',1)\n      if self.checkLink('#include <Windows.h>','GetProcAddress(0,0)'):\n        self.addDefine('HAVE_GETPROCADDRESS',1)\n      if self.checkLink('#include <Windows.h>','FreeLibrary(0)'):\n        self.addDefine('HAVE_FREELIBRARY',1)\n      if self.checkLink('#include <Windows.h>','GetLastError()'):\n        self.addDefine('HAVE_GETLASTERROR',1)\n      if self.checkLink('#include <Windows.h>','SetLastError(0)'):\n        self.addDefine('HAVE_SETLASTERROR',1)\n      if self.checkLink('#include <Windows.h>\\n','QueryPerformanceCounter(0);\\n'):\n        self.addDefine('USE_MICROSOFT_TIME',1)\n    if self.libraries.add('Advapi32.lib','GetUserName',prototype='#include <Windows.h>', call='GetUserName(NULL,NULL);'):\n      self.addDefine('HAVE_GET_USER_NAME',1)\n    elif self.libraries.add('advapi32','GetUserName',prototype='#include <Windows.h>', call='GetUserName(NULL,NULL);'):\n      self.addDefine('HAVE_GET_USER_NAME',1)\n\n    if not self.libraries.add('User32.lib','GetDC',prototype='#include <Windows.h>',call='GetDC(0);'):\n      self.libraries.add('user32','GetDC',prototype='#include <Windows.h>',call='GetDC(0);')\n    if not self.libraries.add('Gdi32.lib','CreateCompatibleDC',prototype='#include <Windows.h>',call='CreateCompatibleDC(0);'):\n      self.libraries.add('gdi32','CreateCompatibleDC',prototype='#include <Windows.h>',call='CreateCompatibleDC(0);')\n\n    self.types.check('int32_t', 'int')\n    if not self.checkCompile('#include <sys/types.h>\\n','uid_t u;\\n'):\n      self.addTypedef('int', 'uid_t')\n      self.addTypedef('int', 'gid_t')\n    if not self.checkLink('#if defined(PETSC_HAVE_UNISTD_H)\\n#include <unistd.h>\\n#endif\\n','int a=R_OK;\\n'):\n      self.framework.addDefine('R_OK', '04')\n      self.framework.addDefine('W_OK', '02')\n      self.framework.addDefine('X_OK', '01')\n    if not self.checkLink('#include <sys/stat.h>\\n','int a=0;\\nif (S_ISDIR(a)){}\\n'):\n      self.framework.addDefine('S_ISREG(a)', '(((a)&_S_IFMT) == _S_IFREG)')\n      self.framework.addDefine('S_ISDIR(a)', '(((a)&_S_IFMT) == _S_IFDIR)')\n    if self.checkCompile('#include <Windows.h>\\n','LARGE_INTEGER a;\\nDWORD b=a.u.HighPart;\\n'):\n      self.addDefine('HAVE_LARGE_INTEGER_U',1)\n\n    # Windows requires a Binary file creation flag when creating/opening binary files.  Is a better test in order?\n    if self.checkCompile('#include <Windows.h>\\n#include <fcntl.h>\\n', 'int flags = O_BINARY;'):\n      self.addDefine('HAVE_O_BINARY',1)\n\n    if self.compilers.CC.find('win32fe') >= 0:\n      self.addDefine('HAVE_WINDOWS_COMPILERS',1)\n      self.addDefine('PATH_SEPARATOR','\\';\\'')\n      self.addDefine('DIR_SEPARATOR','\\'\\\\\\\\\\'')\n      self.addDefine('REPLACE_DIR_SEPARATOR','\\'/\\'')\n      self.addDefine('CANNOT_START_DEBUGGER',1)\n      (petscdir,error,status) = self.executeShellCommand('cygpath -w '+self.installdir.petscDir, log = self.log)\n      self.addDefine('DIR','\"'+petscdir.replace('\\\\','\\\\\\\\')+'\"')\n      (petscdir,error,status) = self.executeShellCommand('cygpath -m '+self.installdir.petscDir, log = self.log)\n      self.addMakeMacro('wPETSC_DIR',petscdir)\n    else:\n      self.addDefine('PATH_SEPARATOR','\\':\\'')\n      self.addDefine('REPLACE_DIR_SEPARATOR','\\'\\\\\\\\\\'')\n      self.addDefine('DIR_SEPARATOR','\\'/\\'')\n      self.addDefine('DIR','\"'+self.installdir.petscDir+'\"')\n      self.addMakeMacro('wPETSC_DIR',self.installdir.petscDir)\n    self.addDefine('ARCH','\"'+self.installdir.petscArch+'\"')\n    return\n\n#-----------------------------------------------------------------------------------------------------\n  def configureCygwinBrokenPipe(self):\n    '''Cygwin version <= 1.7.18 had issues with pipes and long commands invoked from gnu-make\n    http://cygwin.com/ml/cygwin/2013-05/msg00340.html '''\n    if config.setCompilers.Configure.isCygwin(self.log):\n      import platform\n      import re\n      r=re.compile(\"([0-9]+).([0-9]+).([0-9]+)\")\n      m=r.match(platform.release())\n      major=int(m.group(1))\n      minor=int(m.group(2))\n      subminor=int(m.group(3))\n      if ((major < 1) or (major == 1 and minor < 7) or (major == 1 and minor == 7 and subminor <= 18)):\n        self.addMakeMacro('PETSC_CYGWIN_BROKEN_PIPE','1')\n    return\n\n#-----------------------------------------------------------------------------------------------------\n  def configureDefaultArch(self):\n    conffile = os.path.join('lib','petsc','conf', 'petscvariables')\n    if self.framework.argDB['with-default-arch']:\n      fd = file(conffile, 'w')\n      fd.write('PETSC_ARCH='+self.arch.arch+'\\n')\n      fd.write('PETSC_DIR='+self.petscdir.dir+'\\n')\n      fd.write('include '+os.path.join('$(PETSC_DIR)','$(PETSC_ARCH)','lib','petsc','conf','petscvariables')+'\\n')\n      fd.close()\n      self.framework.actions.addArgument('PETSc', 'Build', 'Set default architecture to '+self.arch.arch+' in '+conffile)\n    elif os.path.isfile(conffile):\n      try:\n        os.unlink(conffile)\n      except:\n        raise RuntimeError('Unable to remove file '+conffile+'. Did a different user create it?')\n    return\n\n#-----------------------------------------------------------------------------------------------------\n  def configureScript(self):\n    '''Output a script in the conf directory which will reproduce the configuration'''\n    import nargs\n    import sys\n    scriptName = os.path.join(self.arch.arch,'lib','petsc','conf', 'reconfigure-'+self.arch.arch+'.py')\n    args = dict([(nargs.Arg.parseArgument(arg)[0], arg) for arg in self.framework.clArgs])\n    if 'with-clean' in args:\n      del args['with-clean']\n    if 'configModules' in args:\n      if nargs.Arg.parseArgument(args['configModules'])[1] == 'PETSc.Configure':\n        del args['configModules']\n    if 'optionsModule' in args:\n      if nargs.Arg.parseArgument(args['optionsModule'])[1] == 'config.compilerOptions':\n        del args['optionsModule']\n    if not 'PETSC_ARCH' in args:\n      args['PETSC_ARCH'] = 'PETSC_ARCH='+str(self.arch.arch)\n    f = file(scriptName, 'w')\n    f.write('#!'+sys.executable+'\\n')\n    f.write('if __name__ == \\'__main__\\':\\n')\n    f.write('  import sys\\n')\n    f.write('  import os\\n')\n    f.write('  sys.path.insert(0, os.path.abspath(\\'config\\'))\\n')\n    f.write('  import configure\\n')\n    # pretty print repr(args.values())\n    f.write('  configure_options = [\\n')\n    for itm in sorted(args.values()):\n      f.write('    \\''+str(itm)+'\\',\\n')\n    f.write('  ]\\n')\n    f.write('  configure.petsc_configure(configure_options)\\n')\n    f.close()\n    try:\n      os.chmod(scriptName, 0o775)\n    except OSError as e:\n      self.framework.logPrint('Unable to make reconfigure script executable:\\n'+str(e))\n    self.framework.actions.addArgument('PETSc', 'File creation', 'Created '+scriptName+' for automatic reconfiguration')\n    return\n\n  def configureInstall(self):\n    '''Setup the directories for installation'''\n    if self.framework.argDB['prefix']:\n      self.addMakeRule('shared_install','',['-@echo \"Now to install the libraries do:\"',\\\n                                              '-@echo \"'+self.installdir.installSudo+'make PETSC_DIR=${PETSC_DIR} PETSC_ARCH=${PETSC_ARCH} install\"',\\\n                                              '-@echo \"=========================================\"'])\n    else:\n      self.addMakeRule('shared_install','',['-@echo \"Now to check if the libraries are working do:\"',\\\n                                              '-@echo \"make PETSC_DIR=${PETSC_DIR} PETSC_ARCH=${PETSC_ARCH} check\"',\\\n                                              '-@echo \"=========================================\"'])\n      return\n\n  def configureGCOV(self):\n    if self.framework.argDB['with-gcov']:\n      self.addDefine('USE_GCOV','1')\n    return\n\n  def postProcessPackages(self):\n    postPackages=[]\n    for i in self.framework.packages:\n      if hasattr(i,'postProcess'): postPackages.append(i)\n    if postPackages:\n      # ctetgen needs petsc conf files. so attempt to create them early\n      self.framework.dumpConfFiles()\n      # tacky fix for dependency of Aluimia on Pflotran; requested via petsc-dev Matt provide a correct fix\n      for i in postPackages:\n        if i.name.upper() in ['PFLOTRAN']:\n          i.postProcess()\n          postPackages.remove(i)\n      for i in postPackages: i.postProcess()\n      for i in postPackages:\n        if i.installedpetsc:\n          self.installed = 1\n          break\n    return\n\n  def configure(self):\n    if not os.path.samefile(self.petscdir.dir, os.getcwd()):\n      raise RuntimeError('Wrong PETSC_DIR option specified: '+str(self.petscdir.dir) + '\\n  Configure invoked in: '+os.path.realpath(os.getcwd()))\n    if self.framework.argDB['prefix'] and os.path.isdir(self.framework.argDB['prefix']) and os.path.samefile(self.framework.argDB['prefix'],self.petscdir.dir):\n      raise RuntimeError('Incorrect option --prefix='+self.framework.argDB['prefix']+' specified. It cannot be same as PETSC_DIR!')\n    if self.framework.argDB['prefix'] and self.framework.argDB['prefix'].find(' ') > -1:\n      raise RuntimeError('Your --prefix '+self.framework.argDB['prefix']+' has spaces in it; this is not allowed.\\n Use a --prefix that does not have spaces in it')\n    if self.framework.argDB['prefix'] and os.path.isdir(self.framework.argDB['prefix']) and os.path.samefile(self.framework.argDB['prefix'],os.path.join(self.petscdir.dir,self.arch.arch)):\n      raise RuntimeError('Incorrect option --prefix='+self.framework.argDB['prefix']+' specified. It cannot be same as PETSC_DIR/PETSC_ARCH!')\n    self.framework.header          = os.path.join(self.arch.arch,'include','petscconf.h')\n    self.framework.cHeader         = os.path.join(self.arch.arch,'include','petscfix.h')\n    self.framework.makeMacroHeader = os.path.join(self.arch.arch,'lib','petsc','conf','petscvariables')\n    self.framework.makeRuleHeader  = os.path.join(self.arch.arch,'lib','petsc','conf','petscrules')\n    if self.libraries.math is None:\n      raise RuntimeError('PETSc requires a functional math library. Please send configure.log to petsc-maint@mcs.anl.gov.')\n    if self.languages.clanguage == 'Cxx' and not hasattr(self.compilers, 'CXX'):\n      raise RuntimeError('Cannot set C language to C++ without a functional C++ compiler.')\n    self.executeTest(self.configureRTLDDefault)\n    self.executeTest(self.configurePrefetch)\n    self.executeTest(self.configureUnused)\n    self.executeTest(self.configureDeprecated)\n    self.executeTest(self.configureIsatty)\n    self.executeTest(self.configureExpect);\n    self.executeTest(self.configureAlign);\n    self.executeTest(self.configureFunctionName);\n    self.executeTest(self.configureIntptrt);\n    self.executeTest(self.configureSolaris)\n    self.executeTest(self.configureLinux)\n    self.executeTest(self.configureWin32)\n    self.executeTest(self.configureCygwinBrokenPipe)\n    self.executeTest(self.configureDefaultArch)\n    self.executeTest(self.configureScript)\n    self.executeTest(self.configureInstall)\n    self.executeTest(self.configureGCOV)\n    self.executeTest(self.configureAtoll)\n\n    self.Dump()\n    self.dumpConfigInfo()\n    self.dumpMachineInfo()\n    self.dumpCMakeConfig()\n    self.dumpCMakeLists()\n    # need to save the current state of BuildSystem so that postProcess() packages can read it in and perhaps run make install\n    self.framework.storeSubstitutions(self.framework.argDB)\n    self.framework.argDB['configureCache'] = cPickle.dumps(self.framework)\n    self.framework.argDB.save(force = True)\n    self.cmakeBoot()\n    self.DumpPkgconfig()\n    self.DumpModule()\n    self.postProcessPackages()\n    self.framework.log.write('================================================================================\\n')\n    self.logClear()\n    return\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/config/BuildSystem/config/compilers.py": "import config.base\n\nimport re\nimport os\nimport shutil\n\nclass MissingProcessor(RuntimeError):\n  pass\n\nclass Configure(config.base.Configure):\n  def __init__(self, framework):\n    config.base.Configure.__init__(self, framework)\n    self.headerPrefix = ''\n    self.substPrefix  = ''\n    self.fortranMangling = 'unchanged'\n    self.fincs = []\n    self.flibs = []\n    self.fmainlibs = []\n    self.clibs = []\n    self.cxxlibs = []\n    self.cRestrict = ' '\n    self.cxxRestrict = ' '\n    self.cxxdialect = ''\n    self.c99flag = None\n    self.f90Guess = None\n    return\n\n  def __str__(self):\n    if self.f90Guess:\n      return 'F90 Interface: ' + self.f90Guess+'\\n'\n    else:\n      return ''\n\n  def setupHelp(self, help):\n    import nargs\n\n    help.addArgument('Compilers', '-with-clib-autodetect=<bool>',           nargs.ArgBool(None, 1, 'Autodetect C compiler libraries'))\n    help.addArgument('Compilers', '-with-fortranlib-autodetect=<bool>',     nargs.ArgBool(None, 1, 'Autodetect Fortran compiler libraries'))\n    help.addArgument('Compilers', '-with-cxxlib-autodetect=<bool>',         nargs.ArgBool(None, 1, 'Autodetect C++ compiler libraries'))\n    help.addArgument('Compilers', '-with-dependencies=<bool>',              nargs.ArgBool(None, 1, 'Compile with -MMD or equivalent flag if possible'))\n    help.addArgument('Compilers', '-with-cxx-dialect=<dialect>',            nargs.Arg(None, '', 'Dialect under which to compile C++ sources (e.g., C++11)'))\n    help.addArgument('Compilers', '-with-fortran-type-initialize=<bool>',   nargs.ArgBool(None, 1, 'Initialize PETSc objects in Fortran'))\n\n    return\n\n  def getDispatchNames(self):\n    '''Return all the attributes which are dispatched from config.setCompilers'''\n    names = {}\n    names['CC'] = 'No C compiler found.'\n    names['CPP'] = 'No C preprocessor found.'\n    names['CUDAC'] = 'No CUDA compiler found.'\n    names['CUDAPP'] = 'No CUDA preprocessor found.'\n    names['CXX'] = 'No C++ compiler found.'\n    names['CXXCPP'] = 'No C++ preprocessor found.'\n    names['FC'] = 'No Fortran compiler found.'\n    names['AR'] = 'No archiver found.'\n    names['RANLIB'] = 'No ranlib found.'\n    names['LD_SHARED'] = 'No shared linker found.'\n    names['CC_LD'] = 'No C linker found.'\n    names['dynamicLinker'] = 'No dynamic linker found.'\n    for language in ['C', 'CUDA', 'Cxx', 'FC']:\n      self.pushLanguage(language)\n      key = self.getCompilerFlagsName(language)\n      names[key] = 'No '+language+' compiler flags found.'\n      key = self.getCompilerFlagsName(language, 1)\n      names[key] = 'No '+language+' compiler flags found.'\n      key = self.getLinkerFlagsName(language)\n      names[key] = 'No '+language+' linker flags found.'\n      self.popLanguage()\n    names['CPPFLAGS'] = 'No preprocessor flags found.'\n    names['CUDAPPFLAGS'] = 'No CUDA preprocessor flags found.'\n    names['CXXCPPFLAGS'] = 'No C++ preprocessor flags found.'\n    names['AR_FLAGS'] = 'No archiver flags found.'\n    names['AR_LIB_SUFFIX'] = 'No static library suffix found.'\n    names['LIBS'] = 'No extra libraries found.'\n    return names\n\n  def setupDependencies(self, framework):\n    config.base.Configure.setupDependencies(self, framework)\n    self.setCompilers = framework.require('config.setCompilers', self)\n    self.compilerFlags = framework.require('config.compilerFlags', self)\n    self.libraries = framework.require('config.libraries', None)\n    self.dispatchNames = self.getDispatchNames()\n    return\n\n  def __getattr__(self, name):\n    if 'dispatchNames' in self.__dict__:\n      if name in self.dispatchNames:\n        if not hasattr(self.setCompilers, name):\n          raise MissingProcessor(self.dispatchNames[name])\n        return getattr(self.setCompilers, name)\n      if name in ['CC_LINKER_FLAGS', 'FC_LINKER_FLAGS', 'CXX_LINKER_FLAGS', 'CUDAC_LINKER_FLAGS','sharedLibraryFlags', 'dynamicLibraryFlags']:\n        flags = getattr(self.setCompilers, name)\n        if not isinstance(flags, list): flags = [flags]\n        return ' '.join(flags)\n    raise AttributeError('Configure attribute not found: '+name)\n\n  def __setattr__(self, name, value):\n    if 'dispatchNames' in self.__dict__:\n      if name in self.dispatchNames:\n        return setattr(self.setCompilers, name, value)\n    config.base.Configure.__setattr__(self, name, value)\n    return\n\n  # THIS SHOULD BE REWRITTEN AS checkDeclModifier()\n  # checkCInline & checkCxxInline are pretty much the same code right now.\n  # but they could be different (later) - and they also check/set different flags - hence\n  # code duplication.\n  def checkCInline(self):\n    '''Check for C inline keyword'''\n    self.cInlineKeyword = ' '\n    self.pushLanguage('C')\n    for kw in ['inline', '__inline', '__inline__']:\n      if self.checkCompile('static %s int foo(int a) {return a;}' % kw, 'foo(1);'):\n        self.cInlineKeyword = kw\n        self.logPrint('Set C Inline keyword to '+self.cInlineKeyword , 4, 'compilers')\n        break\n    self.popLanguage()\n    if self.cInlineKeyword == ' ':\n      self.logPrint('No C Inline keyword. Using static function', 4, 'compilers')\n    self.addDefine('C_INLINE', self.cInlineKeyword)\n    return\n\n  def checkCxxInline(self):\n    '''Check for C++ inline keyword'''\n    self.cxxInlineKeyword = ' '\n    self.pushLanguage('C++')\n    for kw in ['inline', '__inline', '__inline__']:\n      if self.checkCompile('static %s int foo(int a) {return a;}' % kw, 'foo(1);'):\n        self.cxxInlineKeyword = kw\n        self.logPrint('Set Cxx Inline keyword to '+self.cxxInlineKeyword , 4, 'compilers')\n        break\n    self.popLanguage()\n    if self.cxxInlineKeyword == ' ':\n      self.logPrint('No Cxx Inline keyword. Using static function', 4, 'compilers')\n    self.addDefine('CXX_INLINE', self.cxxInlineKeyword)\n    return\n\n  def checkRestrict(self,language):\n    '''Check for the C/CXX restrict keyword'''\n    # Try keywords equivalent to C99 restrict.  Note that many C\n    # compilers require special cflags, such as -std=c99 or -restrict to\n    # recognize the \"restrict\" keyword and it is not always practical to\n    # expect that every user provides matching options.  Meanwhile,\n    # compilers like Intel and MSVC (reportedly) support __restrict\n    # without special options.  Glibc uses __restrict, presumably for\n    # this reason.  Note that __restrict is not standardized while\n    # \"restrict\" is, but implementation realities favor __restrict.\n    if config.setCompilers.Configure.isPGI(self.setCompilers.CC, self.log):\n      self.addDefine(language.upper()+'_RESTRICT', ' ')\n      self.logPrint('PGI restrict word is broken cannot handle [restrict] '+str(language)+' restrict keyword', 4, 'compilers')\n      return\n    self.pushLanguage(language)\n    for kw in ['__restrict', ' __restrict__', 'restrict']:\n      if self.checkCompile('', 'float * '+kw+' x;'):\n        if language.lower() == 'c':\n          self.cRestrict = kw\n        elif language.lower() == 'cxx':\n          self.cxxRestrict = kw\n        else:\n          raise RuntimeError('Unknown Language :' + str(language))\n        self.logPrint('Set '+str(language)+' restrict keyword to '+kw, 4, 'compilers')\n        # Define to equivalent of C99 restrict keyword, or to nothing if this is not supported.\n        self.addDefine(language.upper()+'_RESTRICT', kw)\n        self.popLanguage()\n        return\n    # did not find restrict\n    self.addDefine(language.upper()+'_RESTRICT', ' ')\n    self.logPrint('No '+str(language)+' restrict keyword', 4, 'compilers')\n    self.popLanguage()\n    return\n\n  def checkCrossLink(self, func1, func2, language1 = 'C', language2='FC',extraObjs = []):\n    '''Compiles C/C++ and Fortran code and tries to link them together; the C and Fortran code are independent so no name mangling is needed\n       language1 is used to compile the first code, language2 compiles the second and links them togetether'''\n    obj1 = os.path.join(self.tmpDir, 'confc.o')\n    found = 0\n    # Compile the C test object\n    self.pushLanguage(language1)\n    if not self.checkCompile(func1, None, cleanup = 0):\n      self.logPrint('Cannot compile C function: '+func1, 3, 'compilers')\n      self.popLanguage()\n      return found\n    if not os.path.isfile(self.compilerObj):\n      self.logPrint('Cannot locate object file: '+os.path.abspath(self.compilerObj), 3, 'compilers')\n      self.popLanguage()\n      return found\n    os.rename(self.compilerObj, obj1)\n    self.popLanguage()\n    # Link the test object against a Fortran driver\n    self.pushLanguage(language2)\n    oldLIBS = self.setCompilers.LIBS\n    self.setCompilers.LIBS = obj1+' '+self.setCompilers.LIBS\n    if extraObjs:\n      self.setCompilers.LIBS = ' '.join(extraObjs)+' '+' '.join([self.libraries.getLibArgument(lib) for lib in self.clibs])+' '+self.setCompilers.LIBS\n    found = self.checkLink(\"\", func2,codeBegin = \" \", codeEnd = \" \")\n    self.setCompilers.LIBS = oldLIBS\n    self.popLanguage()\n    if os.path.isfile(obj1):\n      os.remove(obj1)\n    return found\n\n  def checkCLibraries(self):\n    '''Determines the libraries needed to link with C compiled code'''\n    skipclibraries = 1\n    if hasattr(self.setCompilers, 'FC'):\n      self.setCompilers.saveLog()\n      try:\n        if self.checkCrossLink('#include <stdio.h>\\nvoid asub(void)\\n{char s[16];printf(\"testing %s\",s);}\\n',\"     program main\\n      print*,'testing'\\n      stop\\n      end\\n\",language1='C',language2='FC'):\n          self.logWrite(self.setCompilers.restoreLog())\n          self.logPrint('C libraries are not needed when using Fortran linker')\n        else:\n          self.logWrite(self.setCompilers.restoreLog())\n          self.logPrint('C code cannot directly be linked with Fortran linker, therefor will determine needed C libraries')\n          skipclibraries = 0\n      except RuntimeError as e:\n        self.logWrite(self.setCompilers.restoreLog())\n        self.logPrint('Error message from compiling {'+str(e)+'}', 4, 'compilers')\n        self.logPrint('C code cannot directly be linked with Fortran linker, therefor will determine needed C libraries')\n        skipclibraries = 0\n    if hasattr(self.setCompilers, 'CXX'):\n      self.setCompilers.saveLog()\n      try:\n        if self.checkCrossLink('#include <stdio.h>\\nvoid asub(void)\\n{char s[16];printf(\"testing %s\",s);}\\n',\"int main(int argc,char **args)\\n{return 0;}\\n\",language1='C',language2='C++'):\n          self.logWrite(self.setCompilers.restoreLog())\n          self.logPrint('C libraries are not needed when using C++ linker')\n        else:\n          self.logWrite(self.setCompilers.restoreLog())\n          self.logPrint('C code cannot directly be linked with C++ linker, therefor will determine needed C libraries')\n          skipclibraries = 0\n      except RuntimeError as e:\n        self.logWrite(self.setCompilers.restoreLog())\n        self.logPrint('Error message from compiling {'+str(e)+'}', 4, 'compilers')\n        self.logPrint('C code cannot directly be linked with C++ linker, therefor will determine needed C libraries')\n        skipclibraries = 0\n    if skipclibraries == 1: return\n\n    oldFlags = self.setCompilers.LDFLAGS\n    self.setCompilers.LDFLAGS += ' -v'\n    self.pushLanguage('C')\n    (output, returnCode) = self.outputLink('', '')\n    self.setCompilers.LDFLAGS = oldFlags\n    self.popLanguage()\n\n    # PGI: kill anything enclosed in single quotes\n    if output.find('\\'') >= 0:\n      # Cray has crazy non-matching single quotes so skip the removal\n      if not output.count('\\'')%2:\n        while output.find('\\'') >= 0:\n          start = output.index('\\'')\n          end   = output.index('\\'', start+1)+1\n          output = output.replace(output[start:end], '')\n\n    # The easiest thing to do for xlc output is to replace all the commas\n    # with spaces.  Try to only do that if the output is really from xlc,\n    # since doing that causes problems on other systems.\n    if output.find('XL_CONFIG') >= 0:\n      output = output.replace(',', ' ')\n\n    # Parse output\n    argIter = iter(output.split())\n    clibs = []\n    lflags  = []\n    rpathflags = []\n    try:\n      while 1:\n        arg = next(argIter)\n        self.logPrint( 'Checking arg '+arg, 4, 'compilers')\n\n        # Intel compiler sometimes puts \" \" around an option like \"-lsomething\"\n        if arg.startswith('\"') and arg.endswith('\"'):\n          arg = arg[1:-1]\n        # Intel also puts several options together inside a \" \" so the last one\n        # has a stray \" at the end\n        if arg.endswith('\"') and arg[:-1].find('\"') == -1:\n          arg = arg[:-1]\n        # Intel 11 has a bogus -long_double option\n        if arg == '-long_double':\n          continue\n        # if options of type -L foobar\n        if arg == '-lto_library':\n          lib = next(argIter)\n          self.logPrint('Skipping Apple LLVM linker option -lto_library '+lib)\n          continue\n        if arg == '-L':\n          lib = next(argIter)\n          self.logPrint('Found -L '+lib, 4, 'compilers')\n          clibs.append('-L'+lib)\n          continue\n        # Check for full library name\n        m = re.match(r'^/.*\\.a$', arg)\n        if m:\n          if not arg in lflags:\n            lflags.append(arg)\n            self.logPrint('Found full library spec: '+arg, 4, 'compilers')\n            clibs.append(arg)\n          else:\n            self.logPrint('Skipping, already in lflags: '+arg, 4, 'compilers')\n          continue\n        # Check for full dylib library name\n        m = re.match(r'^/.*\\.dylib$', arg)\n        if m:\n          if not arg in lflags:\n            lflags.append(arg)\n            self.logPrint('Found full library spec: '+arg, 4, 'compilers')\n            clibs.append(arg)\n          else:\n            self.logPrint('already in lflags: '+arg, 4, 'compilers')\n          continue\n        # Check for system libraries\n        m = re.match(r'^-l(ang.*|crt[0-9].o|crtbegin.o|c|gcc|gcc_ext(.[0-9]+)*|System|cygwin|crt[0-9].[0-9][0-9].[0-9].o)$', arg)\n        if m:\n          self.logPrint('Skipping system library: '+arg, 4, 'compilers')\n          continue\n        # Check for special library arguments\n        m = re.match(r'^-l.*$', arg)\n        if m:\n          if not arg in lflags:\n            if arg == '-lkernel32':\n              continue\n            else:\n              lflags.append(arg)\n            self.logPrint('Found library : '+arg, 4, 'compilers')\n            clibs.append(arg)\n          continue\n        m = re.match(r'^-L.*$', arg)\n        if m:\n          arg = '-L'+os.path.abspath(arg[2:])\n          if arg in ['-L/usr/lib','-L/lib','-L/usr/lib64','-L/lib64']: continue\n          lflags.append(arg)\n          self.logPrint('Found library directory: '+arg, 4, 'compilers')\n          clibs.append(arg)\n          continue\n        # Check for '-rpath /sharedlibpath/ or -R /sharedlibpath/'\n        if arg == '-rpath' or arg == '-R':\n          lib = next(argIter)\n          if lib.startswith('-'): continue # perhaps the path was striped due to quotes?\n          if lib.startswith('\"') and lib.endswith('\"') and lib.find(' ') == -1: lib = lib[1:-1]\n          lib = os.path.abspath(lib)\n          if lib in ['/usr/lib','/lib','/usr/lib64','/lib64']: continue\n          if not lib in rpathflags:\n            rpathflags.append(lib)\n            self.logPrint('Found '+arg+' library: '+lib, 4, 'compilers')\n            clibs.append(self.setCompilers.CSharedLinkerFlag+lib)\n          else:\n            self.logPrint('Already in rpathflags, skipping'+arg, 4, 'compilers')\n          continue\n        # Check for '-R/sharedlibpath/'\n        m = re.match(r'^-R.*$', arg)\n        if m:\n          lib = os.path.abspath(arg[2:])\n          if not lib in rpathflags:\n            rpathflags.append(lib)\n            self.logPrint('Found -R library: '+lib, 4, 'compilers')\n            clibs.append(self.setCompilers.CSharedLinkerFlag+lib)\n          else:\n            self.logPrint('Already in rpathflags, skipping'+arg, 4, 'compilers')\n          continue\n        self.logPrint('Unknown arg '+arg, 4, 'compilers')\n    except StopIteration:\n      pass\n\n    self.clibs = []\n    for lib in clibs:\n      if not self.setCompilers.staticLibraries and lib.startswith('-L') and not self.setCompilers.CSharedLinkerFlag == '-L':\n        self.clibs.append(self.setCompilers.CSharedLinkerFlag+lib[2:])\n      self.clibs.append(lib)\n\n    self.logPrint('Libraries needed to link C code with another linker: '+str(self.clibs), 3, 'compilers')\n\n    if hasattr(self.setCompilers, 'FC') or hasattr(self.setCompilers, 'CXX'):\n      self.logPrint('Check that C libraries can be used from Fortran', 4, 'compilers')\n      oldLibs = self.setCompilers.LIBS\n      self.setCompilers.LIBS = ' '.join([self.libraries.getLibArgument(lib) for lib in self.clibs])+' '+self.setCompilers.LIBS\n    if hasattr(self.setCompilers, 'FC'):\n      self.setCompilers.saveLog()\n      try:\n        self.setCompilers.checkCompiler('FC')\n      except RuntimeError as e:\n        self.setCompilers.LIBS = oldLibs\n        self.logWrite(self.setCompilers.restoreLog())\n        self.logPrint('Error message from compiling {'+str(e)+'}', 4, 'compilers')\n        raise RuntimeError('C libraries cannot directly be used from Fortran')\n      except OSError as e:\n        self.setCompilers.LIBS = oldLibs\n        self.logWrite(self.setCompilers.restoreLog())\n        raise e\n      self.logWrite(self.setCompilers.restoreLog())\n    return\n\n  def checkCFormatting(self):\n    '''Activate format string checking if using the GNU compilers'''\n    '''No checking because we use additional formating conventions'''\n    if self.isGCC and 0:\n      self.gccFormatChecking = ('PRINTF_FORMAT_CHECK(A,B)', '__attribute__((format (printf, A, B)))')\n      self.logPrint('Added gcc printf format checking', 4, 'compilers')\n      self.addDefine(self.gccFormatChecking[0], self.gccFormatChecking[1])\n    else:\n      self.gccFormatChecking = None\n    return\n\n  def checkDynamicLoadFlag(self):\n    '''Checks that dlopen() takes RTLD_XXX, and defines PETSC_HAVE_RTLD_XXX if it does'''\n    if self.setCompilers.dynamicLibraries:\n      if self.checkLink('#include <dlfcn.h>\\nchar *libname;\\n', 'dlopen(libname, RTLD_LAZY);\\n'):\n        self.addDefine('HAVE_RTLD_LAZY', 1)\n      if self.checkLink('#include <dlfcn.h>\\nchar *libname;\\n', 'dlopen(libname, RTLD_NOW);\\n'):\n        self.addDefine('HAVE_RTLD_NOW', 1)\n      if self.checkLink('#include <dlfcn.h>\\nchar *libname;\\n', 'dlopen(libname, RTLD_LOCAL);\\n'):\n        self.addDefine('HAVE_RTLD_LOCAL', 1)\n      if self.checkLink('#include <dlfcn.h>\\nchar *libname;\\n', 'dlopen(libname, RTLD_GLOBAL);\\n'):\n        self.addDefine('HAVE_RTLD_GLOBAL', 1)\n    return\n\n  def checkCxxOptionalExtensions(self):\n    '''Check whether the C++ compiler (IBM xlC, OSF5) need special flag for .c files which contain C++'''\n    self.setCompilers.saveLog()\n    self.setCompilers.pushLanguage('Cxx')\n    cxxObj = self.framework.getCompilerObject('Cxx')\n    oldExt = cxxObj.sourceExtension\n    cxxObj.sourceExtension = self.framework.getCompilerObject('C').sourceExtension\n    success=0\n    for flag in ['', '-+', '-x cxx -tlocal', '-Kc++']:\n      try:\n        self.setCompilers.addCompilerFlag(flag, body = 'class somename { int i; };')\n        success=1\n        break\n      except RuntimeError:\n        pass\n    if success==0:\n      for flag in ['-TP','-P']:\n        try:\n          self.setCompilers.addCompilerFlag(flag, body = 'class somename { int i; };', compilerOnly = 1)\n          break\n        except RuntimeError:\n          pass\n    cxxObj.sourceExtension = oldExt\n    self.setCompilers.popLanguage()\n    self.logWrite(self.setCompilers.restoreLog())\n    return\n\n  def checkCxxNamespace(self):\n    '''Checks that C++ compiler supports namespaces, and if it does defines HAVE_CXX_NAMESPACE'''\n    self.pushLanguage('C++')\n    self.cxxNamespace = 0\n    if self.checkCompile('namespace petsc {int dummy;}'):\n      if self.checkCompile('template <class dummy> struct a {};\\nnamespace trouble{\\ntemplate <class dummy> struct a : public ::a<dummy> {};\\n}\\ntrouble::a<int> uugh;\\n'):\n        self.cxxNamespace = 1\n    self.popLanguage()\n    if self.cxxNamespace:\n      self.logPrint('C++ has namespaces', 4, 'compilers')\n      self.addDefine('HAVE_CXX_NAMESPACE', 1)\n    else:\n      self.logPrint('C++ does not have namespaces', 4, 'compilers')\n    return\n\n  def checkCxx11(self):\n    \"\"\"Determine the option needed to support the C++11 dialect\n\n    We auto-detect C++11 if the compiler supports it without options,\n    otherwise we require with-cxx-dialect=C++11 to try adding flags to\n    support it.\n    \"\"\"\n    # Test borrowed from Jack Poulson (Elemental)\n    includes = \"\"\"\n          #include <random>\n          template<typename T> constexpr T Cubed( T x ) { return x*x*x; }\n          \"\"\"\n    body = \"\"\"\n          std::random_device rd;\n          std::mt19937 mt(rd());\n          std::normal_distribution<double> dist(0,1);\n          const double x = dist(mt);\n          \"\"\"\n    self.setCompilers.saveLog()\n    self.setCompilers.pushLanguage('Cxx')\n    cxxdialect = self.argDB.get('with-cxx-dialect','').upper().replace('X','+')\n    flags_to_try = ['']\n    if cxxdialect == 'C++11':\n      flags_to_try += ['-std=c++11','-std=c++0x']\n    for flag in flags_to_try:\n      if self.setCompilers.checkCompilerFlag(flag, includes, body):\n        self.setCompilers.CXXCPPFLAGS += ' ' + flag\n        self.cxxdialect = 'C++11'\n        break\n    if cxxdialect == 'C++11':\n      if self.cxxdialect != 'C++11':\n        self.logWrite(self.setCompilers.restoreLog())\n        raise RuntimeError('Could not determine compiler flag for with-cxx-dialect=%s,\\nIf you know the flag for turning on C++11 features set it with the CXXFLAGS variables\\n for example, --with-cxx-dialect=C++11 CXXFLAGS=\"-std=c++0x\"' % (self.argDB['with-cxx-dialect']))\n    elif cxxdialect in ['C++98', 'C++03', '']:\n      self.cxxdialect = cxxdialect\n      pass                    # The user can set CXXFLAGS if they want to be strict\n    else:\n      self.logWrite(self.setCompilers.restoreLog())\n      raise RuntimeError('Unknown C++ dialect: with-cxx-dialect=%s' % (self.argDB['with-cxx-dialect']))\n    self.setCompilers.popLanguage()\n    self.logWrite(self.setCompilers.restoreLog())\n    return\n\n  def checkCxxLibraries(self):\n    '''Determines the libraries needed to link with C++'''\n    skipcxxlibraries = 1\n    self.setCompilers.saveLog()\n    body   = '''#include <iostream>\\n#include <vector>\\nvoid asub(void)\\n{std::vector<int> v;\\ntry  { throw 20;  }  catch (int e)  { std::cout << \"An exception occurred\";  }}'''\n    try:\n      if self.checkCrossLink(body,\"int main(int argc,char **args)\\n{return 0;}\\n\",language1='C++',language2='C'):\n        self.logWrite(self.setCompilers.restoreLog())\n        self.logPrint('C++ libraries are not needed when using C linker')\n      else:\n        self.logWrite(self.setCompilers.restoreLog())\n        oldLibs = self.setCompilers.LIBS\n        self.setCompilers.LIBS = '-lstdc++ '+self.setCompilers.LIBS\n        if self.checkCrossLink(body,\"int main(int argc,char **args)\\n{return 0;}\\n\",language1='C++',language2='C'):\n          self.logPrint('C++ requires -lstdc++ to link with C compiler', 3, 'compilers')\n        else:\n          self.setCompilers.LIBS = oldLibs\n          self.logPrint('C++ code cannot directly be linked with C linker, therefor will determine needed C++ libraries')\n          skipcxxlibraries = 0\n    except RuntimeError as e:\n      self.logWrite(self.setCompilers.restoreLog())\n      self.logPrint('Error message from compiling {'+str(e)+'}', 4, 'compilers')\n      self.logPrint('C++ code cannot directly be linked with C linker, therefor will determine needed C++ libraries')\n      skipcxxlibraries = 0\n    if hasattr(self.setCompilers, 'FC'):\n      self.setCompilers.saveLog()\n      try:\n        if self.checkCrossLink(body,\"     program main\\n      print*,'testing'\\n      stop\\n      end\\n\",language1='C++',language2='FC'):\n          self.logWrite(self.setCompilers.restoreLog())\n          self.logPrint('C++ libraries are not needed when using FC linker')\n        else:\n          self.logWrite(self.setCompilers.restoreLog())\n          oldLibs = self.setCompilers.LIBS\n          self.setCompilers.LIBS = '-lstdc++ '+self.setCompilers.LIBS\n          if self.checkCrossLink(body,\"     program main\\n      print*,'testing'\\n      stop\\n      end\\n\",language1='C++',language2='FC'):\n            self.logPrint('C++ requires -lstdc++ to link with FC compiler', 3, 'compilers')\n          else:\n            self.setCompilers.LIBS = oldLibs\n            self.logPrint('C++ code cannot directly be linked with FC linker, therefor will determine needed C++ libraries')\n            skipcxxlibraries = 0\n      except RuntimeError as e:\n        self.logWrite(self.setCompilers.restoreLog())\n        self.logPrint('Error message from compiling {'+str(e)+'}', 4, 'compilers')\n        self.logPrint('C++ code cannot directly be linked with FC linker, therefor will determine needed C++ libraries')\n        skipcxxlibraries = 0\n\n    if skipcxxlibraries: return\n\n    oldFlags = self.setCompilers.LDFLAGS\n    self.setCompilers.LDFLAGS += ' -v'\n    self.pushLanguage('Cxx')\n    (output, returnCode) = self.outputLink('', '')\n    self.setCompilers.LDFLAGS = oldFlags\n    self.popLanguage()\n\n    # PGI: kill anything enclosed in single quotes\n    if output.find('\\'') >= 0:\n      if output.count('\\'')%2: raise RuntimeError('Mismatched single quotes in C library string')\n      while output.find('\\'') >= 0:\n        start = output.index('\\'')\n        end   = output.index('\\'', start+1)+1\n        output = output.replace(output[start:end], '')\n\n    # The easiest thing to do for xlc output is to replace all the commas\n    # with spaces.  Try to only do that if the output is really from xlc,\n    # since doing that causes problems on other systems.\n    if output.find('XL_CONFIG') >= 0:\n      output = output.replace(',', ' ')\n\n    # Parse output\n    argIter = iter(output.split())\n    cxxlibs = []\n    lflags  = []\n    rpathflags = []\n    try:\n      while 1:\n        arg = next(argIter)\n        self.logPrint( 'Checking arg '+arg, 4, 'compilers')\n\n        # Intel compiler sometimes puts \" \" around an option like \"-lsomething\"\n        if arg.startswith('\"') and arg.endswith('\"'):\n          arg = arg[1:-1]\n        # Intel also puts several options together inside a \" \" so the last one\n        # has a stray \" at the end\n        if arg.endswith('\"') and arg[:-1].find('\"') == -1:\n          arg = arg[:-1]\n        # Intel 11 has a bogus -long_double option\n        if arg == '-long_double':\n          continue\n\n        # if options of type -L foobar\n        if arg == '-L':\n          lib = next(argIter)\n          self.logPrint('Found -L '+lib, 4, 'compilers')\n          cxxlibs.append('-L'+lib)\n          continue\n        if arg == '-lto_library':\n          lib = next(argIter)\n          self.logPrint('Skipping Apple LLVM linker option -lto_library '+lib)\n          continue\n        # Check for full library name\n        m = re.match(r'^/.*\\.a$', arg)\n        if m:\n          if not arg in lflags:\n            lflags.append(arg)\n            self.logPrint('Found full library spec: '+arg, 4, 'compilers')\n            cxxlibs.append(arg)\n          else:\n            self.logPrint('Already in lflags: '+arg, 4, 'compilers')\n          continue\n        # Check for full dylib library name\n        m = re.match(r'^/.*\\.dylib$', arg)\n        if m:\n          if not arg in lflags and not arg.endswith('LTO.dylib'):\n            lflags.append(arg)\n            self.logPrint('Found full library spec: '+arg, 4, 'compilers')\n            cxxlibs.append(arg)\n          else:\n            self.logPrint('already in lflags: '+arg, 4, 'compilers')\n          continue\n        # Check for system libraries\n        m = re.match(r'^-l(ang.*|crt[0-9].o|crtbegin.o|c|gcc|gcc_ext(.[0-9]+)*|System|cygwin|crt[0-9].[0-9][0-9].[0-9].o)$', arg)\n        if m:\n          self.logPrint('Skipping system library: '+arg, 4, 'compilers')\n          continue\n        # Check for special library arguments\n        m = re.match(r'^-l.*$', arg)\n        if m:\n          if not arg in lflags:\n            if arg == '-lkernel32':\n              continue\n            elif arg == '-lLTO' and self.setCompilers.isDarwin(self.log):\n              self.logPrint('Skipping -lTO')\n            else:\n              lflags.append(arg)\n            self.logPrint('Found library: '+arg, 4, 'compilers')\n            if (arg == '-lLTO' and self.setCompilers.isDarwin(self.log)) or arg in self.clibs:\n              self.logPrint('Library already in C list so skipping in C++')\n            else:\n              cxxlibs.append(arg)\n          continue\n        m = re.match(r'^-L.*$', arg)\n        if m:\n          arg = '-L'+os.path.abspath(arg[2:])\n          if arg in ['-L/usr/lib','-L/lib','-L/usr/lib64','-L/lib64']: continue\n          if not arg in lflags:\n            lflags.append(arg)\n            self.logPrint('Found library directory: '+arg, 4, 'compilers')\n            cxxlibs.append(arg)\n          continue\n        # Check for '-rpath /sharedlibpath/ or -R /sharedlibpath/'\n        if arg == '-rpath' or arg == '-R':\n          lib = next(argIter)\n          if lib.startswith('-'): continue # perhaps the path was striped due to quotes?\n          if lib.startswith('\"') and lib.endswith('\"') and lib.find(' ') == -1: lib = lib[1:-1]\n          lib = os.path.abspath(lib)\n          if lib in ['/usr/lib','/lib','/usr/lib64','/lib64']: continue\n          if not lib in rpathflags:\n            rpathflags.append(lib)\n            self.logPrint('Found '+arg+' library: '+lib, 4, 'compilers')\n            cxxlibs.append(self.setCompilers.CSharedLinkerFlag+lib)\n          else:\n            self.logPrint('Already in rpathflags, skipping:'+arg, 4, 'compilers')\n          continue\n        # Check for '-R/sharedlibpath/'\n        m = re.match(r'^-R.*$', arg)\n        if m:\n          lib = os.path.abspath(arg[2:])\n          if not lib in rpathflags:\n            rpathflags.append(lib)\n            self.logPrint('Found -R library: '+lib, 4, 'compilers')\n            cxxlibs.append(self.setCompilers.CSharedLinkerFlag+lib)\n          else:\n            self.logPrint('Already in rpathflags, skipping:'+arg, 4, 'compilers')\n          continue\n        self.logPrint('Unknown arg '+arg, 4, 'compilers')\n    except StopIteration:\n      pass\n\n    self.cxxlibs = []\n    for lib in cxxlibs:\n      if not self.setCompilers.staticLibraries and lib.startswith('-L') and not self.setCompilers.CSharedLinkerFlag == '-L':\n        self.cxxlibs.append(self.setCompilers.CSharedLinkerFlag+lib[2:])\n      self.cxxlibs.append(lib)\n\n    self.logPrint('Libraries needed to link Cxx code with another linker: '+str(self.cxxlibs), 3, 'compilers')\n\n    self.logPrint('Check that Cxx libraries can be used from C', 4, 'compilers')\n    oldLibs = self.setCompilers.LIBS\n    self.setCompilers.LIBS = ' '.join([self.libraries.getLibArgument(lib) for lib in self.cxxlibs])+' '+self.setCompilers.LIBS\n    self.setCompilers.saveLog()\n    try:\n      self.setCompilers.checkCompiler('C')\n    except RuntimeError as e:\n      self.logPrint('Cxx libraries cannot directly be used from C', 4, 'compilers')\n      self.logPrint('Error message from compiling {'+str(e)+'}', 4, 'compilers')\n    self.setCompilers.LIBS = oldLibs\n    self.logWrite(self.setCompilers.restoreLog())\n\n    if hasattr(self.setCompilers, 'FC'):\n      self.logPrint('Check that Cxx libraries can be used from Fortran', 4, 'compilers')\n      oldLibs = self.setCompilers.LIBS\n      self.setCompilers.LIBS = ' '.join([self.libraries.getLibArgument(lib) for lib in self.cxxlibs])+' '+self.setCompilers.LIBS\n      self.setCompilers.saveLog()\n      try:\n        self.setCompilers.checkCompiler('FC')\n      except RuntimeError as e:\n        self.logPrint('Cxx libraries cannot directly be used from Fortran', 4, 'compilers')\n        self.logPrint('Error message from compiling {'+str(e)+'}', 4, 'compilers')\n      self.setCompilers.LIBS = oldLibs\n      self.logWrite(self.setCompilers.restoreLog())\n    return\n\n  def checkFortranTypeSizes(self):\n    '''Check whether real*8 is supported and suggest flags which will allow support'''\n    self.pushLanguage('FC')\n    # Check whether the compiler (ifc) bitches about real*8, if so try using -w90 -w to eliminate bitch\n    (output, error, returnCode) = self.outputCompile('', '      real*8 variable', 1)\n    if (output+error).find('Type size specifiers are an extension to standard Fortran 95') >= 0:\n      oldFlags = self.setCompilers.FFLAGS\n      self.setCompilers.FFLAGS += ' -w90 -w'\n      (output, error, returnCode) = self.outputCompile('', '      real*8 variable', 1)\n      if returnCode or (output+error).find('Type size specifiers are an extension to standard Fortran 95') >= 0:\n        self.setCompilers.FFLAGS = oldFlags\n      else:\n        self.logPrint('Looks like ifc compiler, adding -w90 -w flags to avoid warnings about real*8 etc', 4, 'compilers')\n    self.popLanguage()\n    return\n\n\n  def mangleFortranFunction(self, name):\n    if self.fortranMangling == 'underscore':\n      if self.fortranManglingDoubleUnderscore and name.find('_') >= 0:\n        return name.lower()+'__'\n      else:\n        return name.lower()+'_'\n    elif self.fortranMangling == 'unchanged':\n      return name.lower()\n    elif self.fortranMangling == 'caps':\n      return name.upper()\n    elif self.fortranMangling == 'stdcall':\n      return name.upper()\n    raise RuntimeError('Unknown Fortran name mangling: '+self.fortranMangling)\n\n  def testMangling(self, cfunc, ffunc, clanguage = 'C', extraObjs = []):\n    '''Test a certain name mangling'''\n    cobj = os.path.join(self.tmpDir, 'confc.o')\n    found = 0\n    # Compile the C test object\n    self.pushLanguage(clanguage)\n    if not self.checkCompile(cfunc, None, cleanup = 0):\n      self.logPrint('Cannot compile C function: '+cfunc, 3, 'compilers')\n      self.popLanguage()\n      return found\n    if not os.path.isfile(self.compilerObj):\n      self.logPrint('Cannot locate object file: '+os.path.abspath(self.compilerObj), 3, 'compilers')\n      self.popLanguage()\n      return found\n    os.rename(self.compilerObj, cobj)\n    self.popLanguage()\n    # Link the test object against a Fortran driver\n    self.pushLanguage('FC')\n    oldLIBS = self.setCompilers.LIBS\n    self.setCompilers.LIBS = cobj+' '+' '.join([self.libraries.getLibArgument(lib) for lib in self.clibs])+' '+self.setCompilers.LIBS\n    if extraObjs:\n      self.setCompilers.LIBS = ' '.join(extraObjs)+' '+' '.join([self.libraries.getLibArgument(lib) for lib in self.clibs])+' '+self.setCompilers.LIBS\n    found = self.checkLink(None, ffunc)\n    self.setCompilers.LIBS = oldLIBS\n    self.popLanguage()\n    if os.path.isfile(cobj):\n      os.remove(cobj)\n    return found\n\n  def checkFortranNameMangling(self):\n    '''Checks Fortran name mangling, and defines HAVE_FORTRAN_UNDERSCORE, HAVE_FORTRAN_NOUNDERSCORE, HAVE_FORTRAN_CAPS, or HAVE_FORTRAN_STDCALL'''\n    self.manglerFuncs = {'underscore': ('void d1chk_(void);', 'void d1chk_(void){return;}\\n', '       call d1chk()\\n'),\n                         'unchanged': ('void d1chk(void);', 'void d1chk(void){return;}\\n', '       call d1chk()\\n'),\n                         'caps': ('void D1CHK(void);', 'void D1CHK(void){return;}\\n', '       call d1chk()\\n'),\n                         'stdcall': ('void __stdcall D1CHK(void);', 'void __stdcall D1CHK(void){return;}\\n', '       call d1chk()\\n'),\n                         'double': ('void d1_chk__(void)', 'void d1_chk__(void){return;}\\n', '       call d1_chk()\\n')}\n    #some compilers silently ignore '__stdcall' directive, so do stdcall test last\n    # double test is not done here, so its not listed\n    key_list = ['underscore','unchanged','caps','stdcall']\n    for mangler in key_list:\n      cfunc = self.manglerFuncs[mangler][1]\n      ffunc = self.manglerFuncs[mangler][2]\n      self.logWrite('Testing Fortran mangling type '+mangler+' with code '+cfunc)\n      if self.testMangling(cfunc, ffunc):\n        self.fortranMangling = mangler\n        break\n    else:\n      if self.setCompilers.isDarwin(self.log):\n        mess = '  See http://www.mcs.anl.gov/petsc/documentation/faq.html#gfortran'\n      else:\n        mess = ''\n      raise RuntimeError('Unknown Fortran name mangling: Are you sure the C and Fortran compilers are compatible?\\n  Perhaps one is 64 bit and one is 32 bit?\\n'+mess)\n    self.logPrint('Fortran name mangling is '+self.fortranMangling, 4, 'compilers')\n    if self.fortranMangling == 'underscore':\n      self.addDefine('HAVE_FORTRAN_UNDERSCORE', 1)\n    elif self.fortranMangling == 'unchanged':\n      self.addDefine('HAVE_FORTRAN_NOUNDERSCORE', 1)\n    elif self.fortranMangling == 'caps':\n      self.addDefine('HAVE_FORTRAN_CAPS', 1)\n    elif self.fortranMangling == 'stdcall':\n      self.addDefine('HAVE_FORTRAN_STDCALL', 1)\n      self.addDefine('STDCALL', '__stdcall')\n      self.addDefine('HAVE_FORTRAN_CAPS', 1)\n      self.addDefine('HAVE_FORTRAN_MIXED_STR_ARG', 1)\n    if config.setCompilers.Configure.isGfortran8plus(self.getCompiler('FC'), self.log):\n      self.addDefine('FORTRAN_CHARLEN_T', 'size_t')\n    else:\n      self.addDefine('FORTRAN_CHARLEN_T', 'int')\n    return\n\n  def checkFortranNameManglingDouble(self):\n    '''Checks if symbols containing an underscore append an extra underscore, and defines HAVE_FORTRAN_UNDERSCORE_UNDERSCORE if necessary'''\n    if self.testMangling(self.manglerFuncs['double'][1], self.manglerFuncs['double'][2]):\n      self.logPrint('Fortran appends an extra underscore to names containing underscores', 4, 'compilers')\n      self.fortranManglingDoubleUnderscore = 1\n      self.addDefine('HAVE_FORTRAN_UNDERSCORE_UNDERSCORE',1)\n    else:\n      self.fortranManglingDoubleUnderscore = 0\n    return\n\n  def checkFortranPreprocessor(self):\n    '''Determine if Fortran handles preprocessing properly'''\n    self.setCompilers.saveLog()\n    self.setCompilers.pushLanguage('FC')\n    # Does Fortran compiler need special flag for using CPP\n    for flag in ['', '-cpp', '-xpp=cpp', '-F', '-Cpp', '-fpp', '-fpp:-m']:\n      try:\n        flagsArg = self.setCompilers.getCompilerFlagsArg()\n        oldFlags = getattr(self.setCompilers, flagsArg)\n        self.setCompilers.addCompilerFlag(flag, body = '#define dummy \\n           dummy\\n#ifndef dummy\\n       fooey\\n#endif')\n        setattr(self.setCompilers, flagsArg, oldFlags+' '+flag)\n        self.fortranPreprocess = 1\n        self.setCompilers.popLanguage()\n        self.logPrint('Fortran uses CPP preprocessor', 3, 'compilers')\n        self.logWrite(self.setCompilers.restoreLog())\n        return\n      except RuntimeError:\n        setattr(self.setCompilers, flagsArg, oldFlags)\n    self.setCompilers.popLanguage()\n    self.fortranPreprocess = 0\n    self.logPrint('Fortran does NOT use CPP preprocessor', 3, 'compilers')\n    self.logWrite(self.setCompilers.restoreLog())\n    return\n\n  def checkFortranDefineCompilerOption(self):\n    '''Check if -WF,-Dfoobar or -Dfoobar is the compiler option to define a macro'''\n    self.FortranDefineCompilerOption = 0\n    if not self.fortranPreprocess:\n      return\n    self.setCompilers.saveLog()\n    self.setCompilers.pushLanguage('FC')\n    for flag in ['-D', '-WF,-D']:\n      if self.setCompilers.checkCompilerFlag(flag+'Testing', body = '#define dummy \\n           dummy\\n#ifndef Testing\\n       fooey\\n#endif'):\n        self.FortranDefineCompilerOption = flag\n        self.framework.addMakeMacro('FC_DEFINE_FLAG',self.FortranDefineCompilerOption)\n        self.setCompilers.popLanguage()\n        self.logPrint('Fortran uses '+flag+' for defining macro', 3, 'compilers')\n        self.logWrite(self.setCompilers.restoreLog())\n        return\n    self.setCompilers.popLanguage()\n    self.logPrint('Fortran does not support defining macro', 3, 'compilers')\n    self.logWrite(self.setCompilers.restoreLog())\n    return\n\n  def checkFortranLibraries(self):\n    '''Substitutes for FLIBS the libraries needed to link with Fortran\n\n    This macro is intended to be used in those situations when it is\n    necessary to mix, e.g. C++ and Fortran 77, source code into a single\n    program or shared library.\n\n    For example, if object files from a C++ and Fortran 77 compiler must\n    be linked together, then the C++ compiler/linker must be used for\n    linking (since special C++-ish things need to happen at link time\n    like calling global constructors, instantiating templates, enabling\n    exception support, etc.).\n\n    However, the Fortran 77 intrinsic and run-time libraries must be\n    linked in as well, but the C++ compiler/linker does not know how to\n    add these Fortran 77 libraries.\n\n    This code was translated from the autoconf macro which was packaged in\n    its current form by Matthew D. Langston <langston@SLAC.Stanford.EDU>.\n    However, nearly all of this macro came from the OCTAVE_FLIBS macro in\n    octave-2.0.13/aclocal.m4, and full credit should go to John W. Eaton\n    for writing this extremely useful macro.'''\n    if not hasattr(self.setCompilers, 'CC') or not hasattr(self.setCompilers, 'FC'):\n      return\n    skipfortranlibraries = 1\n    self.setCompilers.saveLog()\n    cbody = \"int main(int argc,char **args)\\n{return 0;}\\n\";\n    self.pushLanguage('FC')\n    if self.checkLink(includes='#include <mpif.h>',body='      call MPI_Allreduce()\\n'):\n      fbody = \"subroutine asub()\\n      print*,'testing'\\n      call MPI_Allreduce()\\n      return\\n      end\\n\"\n    else:\n      fbody = \"subroutine asub()\\n      print*,'testing'\\n      return\\n      end\\n\"\n    self.popLanguage()\n    try:\n      if self.checkCrossLink(fbody,cbody,language1='FC',language2='C'):\n        self.logWrite(self.setCompilers.restoreLog())\n        self.logPrint('Fortran libraries are not needed when using C linker')\n      else:\n        self.logWrite(self.setCompilers.restoreLog())\n        self.logPrint('Fortran code cannot directly be linked with C linker, therefor will determine needed Fortran libraries')\n        skipfortranlibraries = 0\n    except RuntimeError as e:\n      self.logWrite(self.setCompilers.restoreLog())\n      self.logPrint('Error message from compiling {'+str(e)+'}', 4, 'compilers')\n      self.logPrint('Fortran code cannot directly be linked with C linker, therefor will determine needed Fortran libraries')\n      skipfortranlibraries = 0\n    if hasattr(self.setCompilers, 'CXX'):\n      self.setCompilers.saveLog()\n      try:\n        if self.checkCrossLink(fbody,cbody,language1='FC',language2='C++'):\n          self.logWrite(self.setCompilers.restoreLog())\n          self.logPrint('Fortran libraries are not needed when using C++ linker')\n        else:\n          self.logWrite(self.setCompilers.restoreLog())\n          self.logPrint('Fortran code cannot directly be linked with C++ linker, therefor will determine needed Fortran libraries')\n          skipfortranlibraries = 0\n      except RuntimeError as e:\n        self.logWrite(self.setCompilers.restoreLog())\n        self.logPrint('Error message from compiling {'+str(e)+'}', 4, 'compilers')\n        self.logPrint('Fortran code cannot directly be linked with CXX linker, therefor will determine needed Fortran libraries')\n        skipfortranlibraries = 0\n\n    if skipfortranlibraries == 1: return\n\n    self.pushLanguage('FC')\n    oldFlags = self.setCompilers.LDFLAGS\n    if config.setCompilers.Configure.isNAG(self.getCompiler(), self.log):\n      self.setCompilers.LDFLAGS += ' --verbose'\n    else:\n      self.setCompilers.LDFLAGS += ' -v'\n    (output, returnCode) = self.outputLink('', '')\n    self.setCompilers.LDFLAGS = oldFlags\n    self.popLanguage()\n\n    # replace \\CR that ifc puts in each line of output\n    output = output.replace('\\\\\\n', '')\n\n    if output.lower().find('absoft') >= 0:\n      loc = output.find(' -lf90math')\n      if loc == -1: loc = output.find(' -lf77math')\n      if loc >= -1:\n        output = output[0:loc]+' -lU77 -lV77 '+output[loc:]\n\n    # PGI/Windows: to properly resolve symbols, we need to list the fortran runtime libraries before -lpgf90\n    if output.find(' -lpgf90') >= 0 and output.find(' -lkernel32') >= 0:\n      loc  = output.find(' -lpgf90')\n      loc2 = output.find(' -lpgf90rtl -lpgftnrtl')\n      if loc2 >= -1:\n        output = output[0:loc] + ' -lpgf90rtl -lpgftnrtl' + output[loc:]\n    elif output.find(' -lpgf90rtl -lpgftnrtl') >= 0:\n      # somehow doing this hacky thing appears to get rid of error with undefined __hpf_exit\n      self.logPrint('Adding -lpgftnrtl before -lpgf90rtl in librarylist')\n      output = output.replace(' -lpgf90rtl -lpgftnrtl',' -lpgftnrtl -lpgf90rtl -lpgftnrtl')\n\n    # PGI: kill anything enclosed in single quotes\n    if output.find('\\'') >= 0:\n      if output.count('\\'')%2: raise RuntimeError('Mismatched single quotes in Fortran library string')\n      while output.find('\\'') >= 0:\n        start = output.index('\\'')\n        end   = output.index('\\'', start+1)+1\n        output = output.replace(output[start:end], '')\n\n    # The easiest thing to do for xlf output is to replace all the commas\n    # with spaces.  Try to only do that if the output is really from xlf,\n    # since doing that causes problems on other systems.\n    if output.find('XL_CONFIG') >= 0:\n      output = output.replace(',', ' ')\n    # We are only supposed to find LD_RUN_PATH on Solaris systems\n    # and the run path should be absolute\n    ldRunPath = re.findall(r'^.*LD_RUN_PATH *= *([^ ]*).*', output)\n    if ldRunPath: ldRunPath = ldRunPath[0]\n    if ldRunPath and ldRunPath[0] == '/':\n      if self.isGCC:\n        ldRunPath = ['-Xlinker -R -Xlinker '+ldRunPath]\n      else:\n        ldRunPath = ['-R '+ldRunPath]\n    else:\n      ldRunPath = []\n\n    # Parse output\n    argIter = iter(output.split())\n    fincs   = []\n    flibs   = []\n    fmainlibs = []\n    lflags  = []\n    rpathflags = []\n    try:\n      while 1:\n        arg = next(argIter)\n        self.logPrint( 'Checking arg '+arg, 4, 'compilers')\n        # Intel compiler sometimes puts \" \" around an option like \"-lsomething\"\n        if arg.startswith('\"') and arg.endswith('\"'):\n          arg = arg[1:-1]\n        # Intel also puts several options together inside a \" \" so the last one\n        # has a stray \" at the end\n        if arg.endswith('\"') and arg[:-1].find('\"') == -1:\n          arg = arg[:-1]\n\n        if arg == '-lto_library':\n          lib = next(argIter)\n          self.logPrint('Skipping Apple LLVM linker option -lto_library '+lib)\n          continue\n        # Check for full library name\n        m = re.match(r'^/.*\\.a$', arg)\n        if m:\n          if not arg in lflags:\n            lflags.append(arg)\n            self.logPrint('Found full library spec: '+arg, 4, 'compilers')\n            flibs.append(arg)\n          else:\n            self.logPrint('already in lflags: '+arg, 4, 'compilers')\n          continue\n        # Check for full dylib library name\n        m = re.match(r'^/.*\\.dylib$', arg)\n        if m:\n          if not arg.endwith('LTO.dylib') and not arg in lflags:\n            lflags.append(arg)\n            self.logPrint('Found full library spec: '+arg, 4, 'compilers')\n            flibs.append(arg)\n          else:\n            self.logPrint('already in lflags: '+arg, 4, 'compilers')\n          continue\n        # prevent false positives for include with pathscalr\n        if re.match(r'^-INTERNAL.*$', arg): continue\n        # Check for special include argument\n        # AIX does this for MPI and perhaps other things\n        m = re.match(r'^-I.*$', arg)\n        if m:\n          inc = arg.replace('-I','',1)\n          self.logPrint('Found include directory: '+inc, 4, 'compilers')\n          fincs.append(inc)\n          continue\n        # Check for ???\n        m = re.match(r'^-bI:.*$', arg)\n        if m:\n          if not arg in lflags:\n            if self.isGCC:\n              lflags.append('-Xlinker')\n            lflags.append(arg)\n            self.logPrint('Found binary include: '+arg, 4, 'compilers')\n            flibs.append(arg)\n          else:\n            self.logPrint('Already in lflags so skipping: '+arg, 4, 'compilers')\n          continue\n        # Check for system libraries\n        m = re.match(r'^-l(ang.*|crt[0-9].o|crtbegin.o|c|gcc|gcc_ext(.[0-9]+)*|System|cygwin|crt[0-9].[0-9][0-9].[0-9].o)$', arg)\n        if m:\n          self.logPrint('Found system library therefor skipping: '+arg, 4, 'compilers')\n          continue\n        # Check for canonical library argument\n        m = re.match(r'^-[lL]$', arg)\n        if m:\n          lib = arg+next(argIter)\n          self.logPrint('Found canonical library: '+lib, 4, 'compilers')\n          if not lib == '-LLTO' or not self.setCompilers.isDarwin(self.log):\n            flibs.append(lib)\n          continue\n        # intel windows compilers can use -libpath argument\n        if arg.find('-libpath:')>=0:\n          self.logPrint('Skipping win32 ifort option: '+arg)\n          continue\n        # Check for special library arguments\n        m = re.match(r'^-l.*$', arg)\n        if m:\n          # HP Fortran prints these libraries in a very strange way\n          if arg == '-l:libU77.a':  arg = '-lU77'\n          if arg == '-l:libF90.a':  arg = '-lF90'\n          if arg == '-l:libIO77.a': arg = '-lIO77'\n          if not arg in lflags:\n            if arg == '-lkernel32':\n              continue\n            elif arg == '-lgfortranbegin':\n              fmainlibs.append(arg)\n              continue\n            elif arg == '-lfrtbegin' and not config.setCompilers.Configure.isCygwin(self.log):\n              fmainlibs.append(arg)\n              continue\n            elif not arg == '-lLTO' or not config.setCompilers.Configure.isDarwin(self.log):\n              lflags.append(arg)\n            self.logPrint('Found library: '+arg, 4, 'compilers')\n            if arg in self.clibs:\n              self.logPrint('Library already in C list so skipping in Fortran')\n            elif not arg == '-lLTO' or not config.setCompilers.Configure.isDarwin(self.log):\n              flibs.append(arg)\n          else:\n            self.logPrint('Already in lflags: '+arg, 4, 'compilers')\n          continue\n        m = re.match(r'^-L.*$', arg)\n        if m:\n          arg = '-L'+os.path.abspath(arg[2:])\n          if arg in ['-L/usr/lib','-L/lib','-L/usr/lib64','-L/lib64']: continue\n          if not arg in lflags:\n            lflags.append(arg)\n            self.logPrint('Found library directory: '+arg, 4, 'compilers')\n            flibs.append(arg)\n          else:\n            self.logPrint('Already in lflags so skipping: '+arg, 4, 'compilers')\n          continue\n        # Check for '-rpath /sharedlibpath/ or -R /sharedlibpath/'\n        if arg == '-rpath' or arg == '-R':\n          lib = next(argIter)\n          if lib == '\\\\': lib = next(argIter)\n          if lib.startswith('-'): continue # perhaps the path was striped due to quotes?\n          if lib.startswith('\"') and lib.endswith('\"') and lib.find(' ') == -1: lib = lib[1:-1]\n          lib = os.path.abspath(lib)\n          if lib in ['/usr/lib','/lib','/usr/lib64','/lib64']: continue\n          if not lib in rpathflags:\n            rpathflags.append(lib)\n            self.logPrint('Found '+arg+' library: '+lib, 4, 'compilers')\n            flibs.append(self.setCompilers.CSharedLinkerFlag+lib)\n          else:\n            self.logPrint('Already in rpathflags so skipping: '+arg, 4, 'compilers')\n          continue\n        # Check for '-R/sharedlibpath/'\n        m = re.match(r'^-R.*$', arg)\n        if m:\n          lib = os.path.abspath(arg[2:])\n          if not lib in rpathflags:\n            rpathflags.append(lib)\n            self.logPrint('Found -R library: '+lib, 4, 'compilers')\n            flibs.append(self.setCompilers.CSharedLinkerFlag+lib)\n          else:\n            self.logPrint('Already in rpathflags so skipping: '+arg, 4, 'compilers')\n          continue\n        if arg.startswith('-zallextract') or arg.startswith('-zdefaultextract') or arg.startswith('-zweakextract'):\n          self.logWrite( 'Found Solaris -z option: '+arg+'\\n')\n          flibs.append(arg)\n          continue\n        # Check for ???\n        # Should probably try to ensure unique directory options here too.\n        # This probably only applies to Solaris systems, and then will only\n        # work with gcc...\n        if arg == '-Y':\n          libs = next(argIter)\n          if libs.startswith('\"') and libs.endswith('\"'):\n            libs = libs[1:-1]\n          for lib in libs.split(':'):\n            #solaris gnu g77 has this extra P, here, not sure why it means\n            if lib.startswith('P,'):lib = lib[2:]\n            self.logPrint('Handling -Y option: '+lib, 4, 'compilers')\n            lib1 = '-L'+os.path.abspath(lib)\n            if lib1 in ['-L/usr/lib','-L/lib','-L/usr/lib64','-L/lib64']: continue\n            flibs.append(lib1)\n          continue\n        if arg.startswith('COMPILER_PATH=') or arg.startswith('LIBRARY_PATH='):\n          self.logPrint('Skipping arg '+arg, 4, 'compilers')\n          continue\n        # HPUX lists a bunch of library directories separated by :\n        if arg.find(':') >=0:\n          founddir = 0\n          for l in arg.split(':'):\n            if os.path.isdir(l):\n              lib1 = '-L'+os.path.abspath(l)\n              if lib1 in ['-L/usr/lib','-L/lib','-L/usr/lib64','-L/lib64']: continue\n              if not arg in lflags:\n                flibs.append(lib1)\n                lflags.append(lib1)\n                self.logPrint('Handling HPUX list of directories: '+l, 4, 'compilers')\n                founddir = 1\n          if founddir:\n            continue\n        if arg.find('quickfit.o')>=0:\n          flibs.append(arg)\n          self.logPrint('Found quickfit.o in argument, adding it')\n          continue\n        # gcc+pgf90 might require pgi.dl\n        if arg.find('pgi.ld')>=0:\n          flibs.append(arg)\n          self.logPrint('Found strange PGI file ending with .ld, adding it')\n          continue\n        self.logPrint('Unknown arg '+arg, 4, 'compilers')\n    except StopIteration:\n      pass\n\n    self.fincs = fincs\n    self.flibs = []\n    for lib in flibs:\n      if not self.setCompilers.staticLibraries and lib.startswith('-L') and not self.setCompilers.FCSharedLinkerFlag == '-L':\n        self.flibs.append(self.setCompilers.FCSharedLinkerFlag+lib[2:])\n      self.flibs.append(lib)\n    self.fmainlibs = fmainlibs\n    # Append run path\n    self.flibs = ldRunPath+self.flibs\n\n    # on OS X, mixing g77 3.4 with gcc-3.3 requires using -lcc_dynamic\n    for l in self.flibs:\n      if l.find('-L/sw/lib/gcc/powerpc-apple-darwin') >= 0:\n        self.logWrite('Detected Apple Mac Fink libraries')\n        appleLib = 'libcc_dynamic.so'\n        self.libraries.saveLog()\n        if self.libraries.check(appleLib, 'foo'):\n          self.flibs.append(self.libraries.getLibArgument(appleLib))\n          self.logWrite('Adding '+self.libraries.getLibArgument(appleLib)+' so that Fortran can work with C++')\n        self.logWrite(self.libraries.restoreLog())\n        break\n\n    self.logPrint('Libraries needed to link Fortran code with the C linker: '+str(self.flibs), 3, 'compilers')\n    self.logPrint('Libraries needed to link Fortran main with the C linker: '+str(self.fmainlibs), 3, 'compilers')\n    # check that these monster libraries can be used from C\n    self.logPrint('Check that Fortran libraries can be used from C', 4, 'compilers')\n    oldLibs = self.setCompilers.LIBS\n    self.setCompilers.LIBS = ' '.join([self.libraries.getLibArgument(lib) for lib in self.flibs])+' '+self.setCompilers.LIBS\n    self.setCompilers.saveLog()\n    try:\n      self.setCompilers.checkCompiler('C')\n    except RuntimeError as e:\n      self.logPrint('Fortran libraries cannot directly be used from C, try without -lcrt2.o', 4, 'compilers')\n      self.logPrint('Error message from compiling {'+str(e)+'}', 4, 'compilers')\n      # try removing this one\n      if '-lcrt2.o' in self.flibs: self.flibs.remove('-lcrt2.o')\n      self.setCompilers.LIBS = oldLibs+' '+' '.join([self.libraries.getLibArgument(lib) for lib in self.flibs])\n      try:\n        self.setCompilers.checkCompiler('C')\n      except RuntimeError as e:\n        self.logPrint('Fortran libraries still cannot directly be used from C, try without pgi.ld files', 4, 'compilers')\n        self.logPrint('Error message from compiling {'+str(e)+'}', 4, 'compilers')\n        tmpflibs = self.flibs\n        for lib in tmpflibs:\n          if lib.find('pgi.ld')>=0:\n            self.flibs.remove(lib)\n        self.setCompilers.LIBS = oldLibs+' '+' '.join([self.libraries.getLibArgument(lib) for lib in self.flibs])\n        try:\n          self.setCompilers.checkCompiler('C')\n        except:\n          self.logPrint(str(e), 4, 'compilers')\n          self.logWrite(self.setCompilers.restoreLog())\n          raise RuntimeError('Fortran libraries cannot be used with C compiler')\n    self.logWrite(self.setCompilers.restoreLog())\n\n    # check these monster libraries work from C++\n    if hasattr(self.setCompilers, 'CXX'):\n      self.logPrint('Check that Fortran libraries can be used from C++', 4, 'compilers')\n      self.setCompilers.LIBS = ' '.join([self.libraries.getLibArgument(lib) for lib in self.flibs])+' '+oldLibs\n      self.setCompilers.saveLog()\n      try:\n        self.setCompilers.checkCompiler('Cxx')\n        self.logPrint('Fortran libraries can be used from C++', 4, 'compilers')\n      except RuntimeError as e:\n        self.logPrint(str(e), 4, 'compilers')\n        # try removing this one causes grief with gnu g++ and Intel Fortran\n        if '-lintrins' in self.flibs: self.flibs.remove('-lintrins')\n        self.setCompilers.LIBS = oldLibs+' '+' '.join([self.libraries.getLibArgument(lib) for lib in self.flibs])\n        try:\n          self.setCompilers.checkCompiler('Cxx')\n        except RuntimeError as e:\n          self.logPrint(str(e), 4, 'compilers')\n          if str(e).find('INTELf90_dclock') >= 0:\n            self.logPrint('Intel 7.1 Fortran compiler cannot be used with g++ 3.2!', 2, 'compilers')\n        self.logWrite(self.setCompilers.restoreLog())\n        raise RuntimeError('Fortran libraries cannot be used with C++ compiler.\\n Run with --with-fc=0 or --with-cxx=0')\n      self.logWrite(self.setCompilers.restoreLog())\n\n    self.setCompilers.LIBS = oldLibs\n    return\n\n  def checkFortranLinkingCxx(self):\n    '''Check that Fortran can be linked against C++'''\n    link = 0\n    cinc, cfunc, ffunc = self.manglerFuncs[self.fortranMangling]\n    cinc = 'extern \"C\" '+cinc+'\\n'\n\n    cxxCode = 'void foo(void){'+self.mangleFortranFunction('d1chk')+'();}'\n    cxxobj  = os.path.join(self.tmpDir, 'cxxobj.o')\n    self.pushLanguage('Cxx')\n    if not self.checkCompile(cinc+cxxCode, None, cleanup = 0):\n      self.logPrint('Cannot compile Cxx function: '+cfunc, 3, 'compilers')\n      raise RuntimeError('Fortran could not successfully link C++ objects')\n    if not os.path.isfile(self.compilerObj):\n      self.logPrint('Cannot locate object file: '+os.path.abspath(self.compilerObj), 3, 'compilers')\n      raise RuntimeError('Fortran could not successfully link C++ objects')\n    os.rename(self.compilerObj, cxxobj)\n    self.popLanguage()\n\n    if self.testMangling(cinc+cfunc, ffunc, 'Cxx', extraObjs = [cxxobj]):\n      self.logPrint('Fortran can link C++ functions', 3, 'compilers')\n      link = 1\n    else:\n      oldLibs = self.setCompilers.LIBS\n      self.setCompilers.LIBS = ' '.join([self.libraries.getLibArgument(lib) for lib in self.cxxlibs])+' '+self.setCompilers.LIBS\n      if self.testMangling(cinc+cfunc, ffunc, 'Cxx', extraObjs = [cxxobj]):\n        self.logPrint('Fortran can link C++ functions using the C++ compiler libraries', 3, 'compilers')\n        link = 1\n      else:\n        self.setCompilers.LIBS = oldLibs\n    if os.path.isfile(cxxobj):\n      os.remove(cxxobj)\n    if not link:\n      raise RuntimeError('Fortran could not successfully link C++ objects')\n    return\n\n  def configureFortranFlush(self):\n    self.pushLanguage('FC')\n    for baseName in ['flush','flush_']:\n      if self.checkLink(body='      call '+baseName+'(6)'):\n        self.addDefine('HAVE_FORTRAN_'+baseName.upper(), 1)\n        break\n    self.popLanguage()\n    return\n\n  def checkFortranTypeInitialize(self):\n    '''Determines if PETSc objects in Fortran are initialized by default (doesn't work with common blocks)'''\n    if self.argDB['with-fortran-type-initialize']:\n      self.addDefine('HAVE_FORTRAN_TYPE_INITIALIZE', -2)\n      self.addDefine('FORTRAN_TYPE_INITIALIZE', ' = -2')\n      self.logPrint('Initializing Fortran objects')\n    else:\n      self.addDefine('FORTRAN_TYPE_INITIALIZE', ' ')\n      self.logPrint('Not initializing Fortran objects')\n    return\n\n  def checkFortranTypeStar(self):\n    '''Determine whether the Fortran compiler handles type(*)'''\n    self.pushLanguage('FC')\n    if self.checkCompile(body = '      interface\\n      subroutine a(b)\\n      type(*) :: b(:)\\n      end subroutine\\n      end interface\\n'):\n      self.addDefine('HAVE_FORTRAN_TYPE_STAR', 1)\n      self.logPrint('Fortran compiler supports type(*)')\n    else:\n      self.logPrint('Fortran compiler does not support type(*)')\n    self.popLanguage()\n    return\n\n  def checkFortran90(self):\n    '''Determine whether the Fortran compiler handles F90'''\n    self.pushLanguage('FC')\n    if self.checkLink(body = '      INTEGER, PARAMETER :: int = SELECTED_INT_KIND(8)\\n      INTEGER (KIND=int) :: ierr\\n\\n      ierr = 1'):\n      self.addDefine('USING_F90', 1)\n      self.fortranIsF90 = 1\n      self.logPrint('Fortran compiler supports F90')\n    else:\n      self.fortranIsF90 = 0\n      self.logPrint('Fortran compiler does not support F90')\n    self.popLanguage()\n    return\n\n  def checkFortran90FreeForm(self):\n    '''Determine whether the Fortran compiler handles F90FreeForm\n       We also require that the compiler handles lines longer than 132 characters'''\n    self.pushLanguage('FC')\n    if self.checkLink(body = '      INTEGER, PARAMETER ::        int = SELECTED_INT_KIND(8);              INTEGER (KIND=int) :: ierr;       ierr                            =                                                                                                               1'):\n      self.addDefine('USING_F90FREEFORM', 1)\n      self.fortranIsF90FreeForm = 1\n      self.logPrint('Fortran compiler supports F90FreeForm')\n    else:\n      self.fortranIsF90FreeForm = 0\n      self.logPrint('Fortran compiler does not support F90FreeForm')\n    self.popLanguage()\n    return\n\n  def checkFortran2003(self):\n    '''Determine whether the Fortran compiler handles F2003'''\n    self.pushLanguage('FC')\n    if self.fortranIsF90 and self.checkLink(codeBegin = '''\n      module Base_module\n        type, public :: base_type\n           integer :: A\n         contains\n           procedure, public :: Print => BasePrint\n        end type base_type\n      contains\n        subroutine BasePrint(this)\n          class(base_type) :: this\n        end subroutine BasePrint\n      end module Base_module\n\n      program main''',body = '''\n      use,intrinsic :: iso_c_binding\n      Type(C_Ptr),Dimension(:),Pointer :: CArray\n      character(kind=c_char),pointer   :: nullc => null()\n      character(kind=c_char,len=5),dimension(:),pointer::list1\n\n      allocate(list1(5))\n      CArray = (/(c_loc(list1(i)),i=1,5),c_loc(nullc)/)'''):\n      self.addDefine('USING_F2003', 1)\n      self.fortranIsF2003 = 1\n      self.logPrint('Fortran compiler supports F2003')\n    else:\n      self.fortranIsF2003 = 0\n      self.logPrint('Fortran compiler does not support F2003')\n    self.popLanguage()\n    for f in [os.path.abspath('base_module.mod'), os.path.abspath('BASE_MODULE.mod'), os.path.join(os.path.dirname(self.compilerObj),'base_module.mod'), os.path.join(os.path.dirname(self.compilerObj),'BASE_MODULE.mod')]:\n      if os.path.isfile(f): os.remove(f)\n    return\n\n  def checkFortran90Array(self):\n    '''Check for F90 array interfaces'''\n    if not self.fortranIsF90:\n      self.logPrint('Not a Fortran90 compiler - hence skipping f90-array test')\n      return\n    # do an apporximate test when batch mode is used, as we cannot run the proper test..\n    if self.argDB['with-batch']:\n      if config.setCompilers.Configure.isPGI(self.setCompilers.FC, self.log):\n        self.addDefine('HAVE_F90_2PTR_ARG', 1)\n        self.logPrint('PGI F90 compiler detected & using --with-batch, so use two arguments for array pointers', 3, 'compilers')\n      else:\n        self.logPrint('Using --with-batch, so guess that F90 uses a single argument for array pointers', 3, 'compilers')\n      return\n    # do not check on windows - as it pops up the annoying debugger\n    if config.setCompilers.Configure.isCygwin(self.log):\n      self.logPrint('Cygwin detected: ignoring HAVE_F90_2PTR_ARG test')\n      return\n\n    # Compile the C test object\n    cinc  = '#include<stdio.h>\\n#include <stdlib.h>\\n'\n    ccode = 'void '+self.mangleFortranFunction('f90arraytest')+'''(void* a1, void* a2,void* a3, void* i)\n{\n  printf(\"arrays [%p %p %p]\\\\n\",a1,a2,a3);\n  fflush(stdout);\n  return;\n}\n''' + 'void '+self.mangleFortranFunction('f90ptrtest')+'''(void* a1, void* a2,void* a3, void* i, void* p1 ,void* p2, void* p3)\n{\n  printf(\"arrays [%p %p %p]\\\\n\",a1,a2,a3);\n  if ((p1 == p3) && (p1 != p2)) {\n    printf(\"pointers match! [%p %p] [%p]\\\\n\",p1,p3,p2);\n    fflush(stdout);\n  } else {\n    printf(\"pointers do not match! [%p %p] [%p]\\\\n\",p1,p3,p2);\n    fflush(stdout);\n    exit(111);\n  }\n  return;\n}\\n'''\n    cobj = os.path.join(self.tmpDir, 'fooobj.o')\n    self.pushLanguage('C')\n    if not self.checkCompile(cinc+ccode, None, cleanup = 0):\n      self.logPrint('Cannot compile C function: f90ptrtest', 3, 'compilers')\n      raise RuntimeError('Could not check Fortran pointer arguments')\n    if not os.path.isfile(self.compilerObj):\n      self.logPrint('Cannot locate object file: '+os.path.abspath(self.compilerObj), 3, 'compilers')\n      raise RuntimeError('Could not check Fortran pointer arguments')\n    os.rename(self.compilerObj, cobj)\n    self.popLanguage()\n    # Link the test object against a Fortran driver\n    self.pushLanguage('FC')\n    oldLIBS = self.setCompilers.LIBS\n    self.setCompilers.LIBS = cobj+' '+self.setCompilers.LIBS\n    fcode = '''\\\n      Interface\n         Subroutine f90ptrtest(p1,p2,p3,i)\n         integer, pointer :: p1(:,:)\n         integer, pointer :: p2(:,:)\n         integer, pointer :: p3(:,:)\n         integer i\n         End Subroutine\n      End Interface\n\n      integer, pointer :: ptr1(:,:),ptr2(:,:)\n      integer, target  :: array(6:8,9:21)\n      integer  in\n\n      in   = 25\n      ptr1 => array\n      ptr2 => array\n\n      call f90arraytest(ptr1,ptr2,ptr1,in)\n      call f90ptrtest(ptr1,ptr2,ptr1,in)\\n'''\n\n    found = self.checkRun(None, fcode, defaultArg = 'f90-2ptr-arg')\n    self.setCompilers.LIBS = oldLIBS\n    self.popLanguage()\n    # Cleanup\n    if os.path.isfile(cobj):\n      os.remove(cobj)\n    if found:\n      self.addDefine('HAVE_F90_2PTR_ARG', 1)\n      self.logPrint('F90 compiler uses two arguments for array pointers', 3, 'compilers')\n    else:\n      self.logPrint('F90 uses a single argument for array pointers', 3, 'compilers')\n    return\n\n  def checkFortranModuleInclude(self):\n    '''Figures out what flag is used to specify the include path for Fortran modules'''\n    self.setCompilers.fortranModuleIncludeFlag = None\n    if not self.fortranIsF90:\n      self.logPrint('Not a Fortran90 compiler - hence skipping module include test')\n      return\n    found   = False\n    testdir = os.path.join(self.tmpDir, 'confdir')\n    modobj  = os.path.join(self.tmpDir, 'configtest.o')\n    modcode = '''\\\n      module configtest\n      integer testint\n      parameter (testint = 42)\n      end module configtest\\n'''\n    # Compile the Fortran test module\n    self.pushLanguage('FC')\n    if not self.checkCompile(modcode, None, cleanup = 0):\n      self.logPrint('Cannot compile Fortran module', 3, 'compilers')\n      self.popLanguage()\n      raise RuntimeError('Cannot determine Fortran module include flag')\n    if not os.path.isfile(self.compilerObj):\n      self.logPrint('Cannot locate object file: '+os.path.abspath(self.compilerObj), 3, 'compilers')\n      self.popLanguage()\n      raise RuntimeError('Cannot determine Fortran module include flag')\n    if not os.path.isdir(testdir):\n      os.mkdir(testdir)\n    os.rename(self.compilerObj, modobj)\n    foundModule = 0\n    for f in [os.path.abspath('configtest.mod'), os.path.abspath('CONFIGTEST.mod'), os.path.join(os.path.dirname(self.compilerObj),'configtest.mod'), os.path.join(os.path.dirname(self.compilerObj),'CONFIGTEST.mod')]:\n      if os.path.isfile(f):\n        modname     = f\n        foundModule = 1\n        break\n    if not foundModule:\n      d = os.path.dirname(os.path.abspath('configtest.mod'))\n      self.logPrint('Directory '+d+' contents:\\n'+str(os.listdir(d)))\n      raise RuntimeError('Fortran module was not created during the compile. %s/CONFIGTEST.mod not found' % os.path.abspath('configtest.mod'))\n    shutil.move(modname, os.path.join(testdir, os.path.basename(modname)))\n    fcode = '''\\\n      use configtest\n\n      write(*,*) testint\\n'''\n    self.pushLanguage('FC')\n    oldFLAGS = self.setCompilers.FFLAGS\n    oldLIBS  = self.setCompilers.LIBS\n    for flag in ['-I', '-p', '-M']:\n      self.setCompilers.FFLAGS = flag+testdir+' '+self.setCompilers.FFLAGS\n      self.setCompilers.LIBS   = modobj+' '+self.setCompilers.LIBS\n      if not self.checkLink(None, fcode):\n        self.logPrint('Fortran module include flag '+flag+' failed', 3, 'compilers')\n      else:\n        self.logPrint('Fortran module include flag '+flag+' found', 3, 'compilers')\n        self.setCompilers.fortranModuleIncludeFlag = flag\n        found = 1\n      self.setCompilers.LIBS   = oldLIBS\n      self.setCompilers.FFLAGS = oldFLAGS\n      if found: break\n    self.popLanguage()\n    if os.path.isfile(modobj):\n      os.remove(modobj)\n    os.remove(os.path.join(testdir, os.path.basename(modname)))\n    os.rmdir(testdir)\n    if not found:\n      raise RuntimeError('Cannot determine Fortran module include flag')\n    return\n\n  def checkFortranModuleOutput(self):\n    '''Figures out what flag is used to specify the include path for Fortran modules'''\n    self.setCompilers.fortranModuleOutputFlag = None\n    if not self.fortranIsF90:\n      self.logPrint('Not a Fortran90 compiler - hence skipping module include test')\n      return\n    found   = False\n    testdir = os.path.join(self.tmpDir, 'confdir')\n    modobj  = os.path.join(self.tmpDir, 'configtest.o')\n    modcode = '''\\\n      module configtest\n      integer testint\n      parameter (testint = 42)\n      end module configtest\\n'''\n    modname = None\n    # Compile the Fortran test module\n    if not os.path.isdir(testdir):\n      os.mkdir(testdir)\n    self.pushLanguage('FC')\n    oldFLAGS = self.setCompilers.FFLAGS\n    oldLIBS  = self.setCompilers.LIBS\n    for flag in ['-module ', '-module:', '-fmod=', '-J', '-M', '-p', '-qmoddir=', '-moddir=']:\n      self.setCompilers.FFLAGS = flag+testdir+' '+self.setCompilers.FFLAGS\n      self.setCompilers.LIBS   = modobj+' '+self.setCompilers.LIBS\n      if not self.checkCompile(modcode, None, cleanup = 0):\n        self.logPrint('Fortran module output flag '+flag+' compile failed', 3, 'compilers')\n      elif os.path.isfile(os.path.join(testdir, 'configtest.mod')) or os.path.isfile(os.path.join(testdir, 'CONFIGTEST.mod')):\n        if os.path.isfile(os.path.join(testdir, 'configtest.mod')): modname = 'configtest.mod'\n        if os.path.isfile(os.path.join(testdir, 'CONFIGTEST.mod')): modname = 'CONFIGTEST.mod'\n        self.logPrint('Fortran module output flag '+flag+' found', 3, 'compilers')\n        self.setCompilers.fortranModuleOutputFlag = flag\n        found = 1\n      else:\n        self.logPrint('Fortran module output flag '+flag+' failed', 3, 'compilers')\n      self.setCompilers.LIBS   = oldLIBS\n      self.setCompilers.FFLAGS = oldFLAGS\n      if found: break\n    self.popLanguage()\n    if modname: os.remove(os.path.join(testdir, modname))\n    os.rmdir(testdir)\n    # Flag not used by PETSc - do do not flag a runtime error\n    #if not found:\n    #  raise RuntimeError('Cannot determine Fortran module output flag')\n    return\n\n  def checkDependencyGenerationFlag(self):\n    '''Check if -MMD works for dependency generation, and add it if it does'''\n    self.generateDependencies       = {}\n    self.dependenciesGenerationFlag = {}\n    if not self.argDB['with-dependencies'] :\n      self.logPrint(\"Skip checking dependency compiler options on user request\")\n      return\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    if hasattr(self, 'FC'):\n      languages.append('FC')\n    if hasattr(self, 'CUDAC'):\n      languages.append('CUDA')\n    for language in languages:\n      self.generateDependencies[language] = 0\n      self.setCompilers.saveLog()\n      self.setCompilers.pushLanguage(language)\n      for testFlag in ['-MMD -MP', # GCC, Intel, Clang, Pathscale\n                       '-MMD',     # PGI\n                       '-xMMD',    # Sun\n                       '-qmakedep=gcc', # xlc\n                       '-MD',\n                       # Cray only supports -M, which writes to stdout\n                     ]:\n        try:\n          self.logPrint('Trying '+language+' compiler flag '+testFlag)\n          if self.setCompilers.checkCompilerFlag(testFlag, compilerOnly = 1):\n            depFilename = os.path.splitext(self.setCompilers.compilerObj)[0]+'.d'\n            if os.path.isfile(depFilename):\n              os.remove(depFilename)\n              #self.setCompilers.insertCompilerFlag(testFlag, compilerOnly = 1)\n              self.framework.addMakeMacro(language.upper()+'_DEPFLAGS',testFlag)\n              self.dependenciesGenerationFlag[language] = testFlag\n              self.generateDependencies[language]       = 1\n              break\n            else:\n              self.logPrint('Rejected '+language+' compiler flag '+testFlag+' because no dependency file ('+depFilename+') was generated')\n          else:\n            self.logPrint('Rejected '+language+' compiler flag '+testFlag)\n        except RuntimeError:\n          self.logPrint('Rejected '+language+' compiler flag '+testFlag)\n      self.setCompilers.popLanguage()\n      self.logWrite(self.setCompilers.restoreLog())\n    return\n\n  def checkC99Flag(self):\n    '''Check for -std=c99 or equivalent flag'''\n    includes = \"#include <float.h>\"\n    body = \"\"\"\n    float x[2],y;\n    y = FLT_ROUNDS;\n    // c++ comment\n    int j = 2;\n    for (int i=0; i<2; i++){\n      x[i] = i*j*y;\n    }\n    \"\"\"\n    self.setCompilers.saveLog()\n    self.setCompilers.pushLanguage('C')\n    restoredlog = 0\n    flags_to_try = ['','-std=c99','-std=gnu99','-std=c11''-std=gnu11','-c99']\n    for flag in flags_to_try:\n      if self.setCompilers.checkCompilerFlag(flag, includes, body):\n        self.c99flag = flag\n        self.logWrite(self.setCompilers.restoreLog())\n        restoredlog = 1\n        self.framework.logPrint('Accepted C99 compile flag: '+flag)\n        break\n    if self.c99flag == '': self.addDefine('HAVE_C99', 1)\n    self.setCompilers.popLanguage()\n    if not restoredlog:\n      self.logWrite(self.setCompilers.restoreLog())\n    return\n\n  def configure(self):\n    import config.setCompilers\n    if hasattr(self.setCompilers, 'CC'):\n      self.isGCC = config.setCompilers.Configure.isGNU(self.setCompilers.CC, self.log)\n      self.executeTest(self.checkRestrict,['C'])\n      self.executeTest(self.checkCFormatting)\n      self.executeTest(self.checkCInline)\n      self.executeTest(self.checkDynamicLoadFlag)\n      if self.argDB['with-clib-autodetect']:\n        self.executeTest(self.checkCLibraries)\n      self.executeTest(self.checkDependencyGenerationFlag)\n      self.executeTest(self.checkC99Flag)\n    else:\n      self.isGCC = 0\n    if hasattr(self.setCompilers, 'CXX'):\n      self.isGCXX = config.setCompilers.Configure.isGNU(self.setCompilers.CXX, self.log)\n      self.executeTest(self.checkRestrict,['Cxx'])\n      self.executeTest(self.checkCxxNamespace)\n      self.executeTest(self.checkCxxOptionalExtensions)\n      self.executeTest(self.checkCxxInline)\n      if self.argDB['with-cxxlib-autodetect']:\n        self.executeTest(self.checkCxxLibraries)\n      self.executeTest(self.checkCxx11)\n    else:\n      self.isGCXX = 0\n    if hasattr(self.setCompilers, 'FC'):\n      self.executeTest(self.checkFortranTypeSizes)\n      self.executeTest(self.checkFortranNameMangling)\n      self.executeTest(self.checkFortranNameManglingDouble)\n      self.executeTest(self.checkFortranPreprocessor)\n      self.executeTest(self.checkFortranDefineCompilerOption)\n      if self.argDB['with-fortranlib-autodetect']:\n        self.executeTest(self.checkFortranLibraries)\n      if hasattr(self.setCompilers, 'CXX'):\n        self.executeTest(self.checkFortranLinkingCxx)\n      self.executeTest(self.checkFortran90)\n      self.executeTest(self.checkFortran90FreeForm)\n      self.executeTest(self.checkFortran2003)\n      self.executeTest(self.checkFortran90Array)\n      self.executeTest(self.checkFortranModuleInclude)\n      self.executeTest(self.checkFortranModuleOutput)\n      self.executeTest(self.checkFortranTypeStar)\n      self.executeTest(self.checkFortranTypeInitialize)\n      self.executeTest(self.configureFortranFlush)\n    self.no_configure()\n    return\n\n  def setupFrameworkCompilers(self):\n    if self.framework.compilers is None:\n      self.logPrint('Setting framework compilers to this module', 2, 'compilers')\n      self.framework.compilers = self\n    return\n\n  def no_configure(self):\n    self.executeTest(self.setupFrameworkCompilers)\n    return\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/config/BuildSystem/config/libraries.py": "import config.base\n\nimport os\nimport re\n\ntry:\n  enumerate([0, 1])\nexcept NameError:\n  def enumerate(l):\n    return zip(range(len(l)), l)\n\nclass Configure(config.base.Configure):\n  def __init__(self, framework, libraries = []):\n    config.base.Configure.__init__(self, framework)\n    self.headerPrefix = ''\n    self.substPrefix  = ''\n    self.libraries    = libraries\n    return\n\n  def setupDependencies(self, framework):\n    config.base.Configure.setupDependencies(self, framework)\n    self.setCompilers = framework.require('config.setCompilers', self)\n    self.compilers    = framework.require('config.compilers',    self)\n    self.headers      = framework.require('config.headers',      self)\n    return\n\n  def getLibArgumentList(self, library, with_rpath=True):\n    '''Return the proper link line argument for the given filename library as a list of options\n      - If the path is empty, return it unchanged\n      - If starts with - then return unchanged\n      - If the path ends in \".lib\" return it unchanged\n      - If the path is absolute and the filename is \"lib\"<name>, return -L<dir> -l<name> (optionally including rpath flag)\n      - If the filename is \"lib\"<name>, return -l<name>\n      - If the path ends in \".so\" return it unchanged\n      - If the path is absolute, return it unchanged\n      - Otherwise return -l<library>'''\n    if not library:\n      return []\n    if library.startswith('${CC_LINKER_SLFLAG}'):\n      return [library] if with_rpath else []\n    if library.startswith('${FC_LINKER_SLFLAG}'):\n      return [library] if with_rpath else []\n    if library.lstrip()[0] == '-':\n      return [library]\n    if len(library) > 3 and library[-4:] == '.lib':\n      return [library.replace('\\\\ ',' ').replace(' ', '\\\\ ').replace('\\\\(','(').replace('(', '\\\\(').replace('\\\\)',')').replace(')', '\\\\)')]\n    if os.path.basename(library).startswith('lib'):\n      name = self.getLibName(library)\n      if ((len(library) > 2 and library[1] == ':') or os.path.isabs(library)):\n        flagName  = self.language[-1]+'SharedLinkerFlag'\n        flagSubst = self.language[-1].upper()+'_LINKER_SLFLAG'\n        dirname   = os.path.dirname(library).replace('\\\\ ',' ').replace(' ', '\\\\ ').replace('\\\\(','(').replace('(', '\\\\(').replace('\\\\)',')').replace(')', '\\\\)')\n        if with_rpath:\n          if hasattr(self.setCompilers, flagName) and not getattr(self.setCompilers, flagName) is None:\n            return [getattr(self.setCompilers, flagName)+dirname,'-L'+dirname,'-l'+name]\n          if flagSubst in self.argDB:\n            return [self.argDB[flagSubst]+dirname,'-L'+dirname,'-l'+name]\n        return ['-L'+dirname,'-l'+name]\n      else:\n        return ['-l'+name]\n    if os.path.splitext(library)[1] == '.so':\n      return [library]\n    if os.path.isabs(library):\n      return [library]\n    return ['-l'+library]\n\n  def getLibArgument(self, library):\n    '''Same as getLibArgumentList - except it returns a string instead of list.'''\n    return  ' '.join(self.getLibArgumentList(library))\n\n  def getLibName(library):\n    if os.path.basename(library).startswith('lib'):\n      return os.path.splitext(os.path.basename(library))[0][3:]\n    return library\n  getLibName = staticmethod(getLibName)\n\n  def getDefineName(self, library):\n    return 'HAVE_LIB'+self.getLibName(library).upper().replace('-','_').replace('=','_').replace('+','_').replace('.', '_').replace('/','_')\n\n  def getDefineNameFunc(self, funcName):\n    return 'HAVE_'+ funcName.upper()\n\n  def haveLib(self, library):\n    return self.getDefineName(library) in self.defines\n\n  def add(self, libName, funcs, libDir = None, otherLibs = [], prototype = '', call = '', fortranMangle = 0):\n    '''Checks that the library \"libName\" contains \"funcs\", and if it does defines HAVE_LIB\"libName AND adds it to $LIBS\"\n       - libDir may be a list of directories\n       - libName may be a list of library names'''\n    if not isinstance(libName, list): libName = [libName]\n    if self.check(libName, funcs, libDir, otherLibs, prototype, call, fortranMangle):\n      self.logPrint('Adding '+str(libName)+' to LIBS')\n      # Note: this MUST be setCompilers since it can happen before dispatch names is made\n      self.setCompilers.LIBS = self.toString(libName)+' '+self.setCompilers.LIBS\n      return 1\n    return 0\n\n  def toString(self,libs):\n    '''Converts a list of libraries to a string suitable for a linker'''\n    newlibs = []\n    frame = 0\n    for lib in libs:\n      if frame:\n        newlibs += [lib]\n        frame   = 0\n      elif lib == '-framework':\n        newlibs += [lib]\n        frame = 1\n      else:\n        newlibs += self.getLibArgumentList(lib)\n    return ' '.join(newlibs)\n\n  def toStringNoDupes(self,libs,with_rpath=True):\n    '''Converts a list of libraries to a string suitable for a linker, removes duplicates'''\n    newlibs = []\n    frame = 0\n    for lib in libs:\n      if frame:\n        newlibs += [lib]\n        frame   = 0\n      elif lib == '-framework':\n        newlibs += [lib]\n        frame = 1\n      else:\n        newlibs += self.getLibArgumentList(lib, with_rpath)\n    libs = newlibs\n    newldflags = []\n    newlibs = []\n    frame = 0\n    dupflags = ['-L']\n    flagName  = self.language[-1]+'SharedLinkerFlag'\n    if hasattr(self.setCompilers, flagName) and not getattr(self.setCompilers, flagName) is None:\n      dupflags.append(getattr(self.setCompilers, flagName))\n    for j in libs:\n      # remove duplicate -L, -Wl,-rpath options - and only consecutive -l optipons\n      if j in newldflags and any([j.startswith(flg) for flg in dupflags]): continue\n      if newlibs and j == newlibs[-1]: continue\n      if j.startswith('-l'):\n        newlibs.append(j)\n      else:\n        newldflags.append(j)\n    return ' '.join(newldflags + newlibs)\n\n  def getShortLibName(self,lib):\n    '''returns the short name for the library. Valid names are foo -lfoo or libfoo.[a,so,lib]'''\n    if lib.startswith('-l'):\n      libname = lib[2:]\n      return libname\n    if lib.startswith('-'): # must be some compiler options - not a library\n      return ''\n    if lib.endswith('.a') or lib.endswith('.so') or lib.endswith('.lib'):\n      libname = os.path.splitext(os.path.basename(lib))[0]\n      if lib.startswith('lib'): libname = libname[3:]\n      return libname\n    # no match - assuming the given name is already in short notation\n    return lib\n\n  def check(self, libName, funcs, libDir = None, otherLibs = [], prototype = '', call = '', fortranMangle = 0, cxxMangle = 0, cxxLink = 0, functionDefine = 0, examineOutput=lambda ret,out,err:None):\n    '''Checks that the library \"libName\" contains \"funcs\", and if it does defines HAVE_LIB\"libName\"\n       - libDir may be a list of directories\n       - libName may be a list of library names'''\n    if not isinstance(funcs,list): funcs = [funcs]\n    if not isinstance(libName, list): libName = [libName]\n    def genPreamble(f, funcName):\n      # Construct prototype\n      if self.language[-1] == 'FC':\n        return ''\n      if prototype:\n        if isinstance(prototype, str):\n          pre = prototype\n        else:\n          pre = prototype[f]\n      else:\n        # We use char because int might match the return type of a gcc2 builtin and its argument prototype would still apply.\n        pre = 'char '+funcName+'();'\n      # Capture the function call in a static function so that any local variables are isolated from\n      # calls to other library functions.\n      return pre + '\\nstatic void _check_%s() { %s }' % (funcName, genCall(f, funcName, pre=True))\n    def genCall(f, funcName, pre=False):\n      if self.language[-1] != 'FC' and not pre:\n        return '_check_' + fname + '();'\n      # Construct function call\n      if call:\n        if isinstance(call, str):\n          body = call\n        else:\n          body = call[f]\n      else:\n        body = funcName+'()'\n      if self.language[-1] != 'FC':\n        body += ';'\n      return body\n    # Handle Fortran mangling\n    if fortranMangle:\n      funcs = map(self.compilers.mangleFortranFunction, funcs)\n    if not funcs:\n      self.logPrint('No functions to check for in library '+str(libName)+' '+str(otherLibs))\n      return True\n    self.logPrint('Checking for functions ['+' '.join(funcs)+'] in library '+str(libName)+' '+str(otherLibs))\n    if self.language[-1] == 'FC':\n      includes = ''\n    else:\n      includes = '/* Override any gcc2 internal prototype to avoid an error. */\\n'\n    # Handle C++ mangling\n    if self.language[-1] == 'Cxx' and not cxxMangle:\n      includes += '''\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n'''\n    includes += '\\n'.join([genPreamble(f, fname) for f, fname in enumerate(funcs)])\n    # Handle C++ mangling\n    if self.language[-1] == 'Cxx' and not cxxMangle:\n      includes += '''\n#ifdef __cplusplus\n}\n#endif\n'''\n    body = '\\n'.join([genCall(f, fname) for f, fname in enumerate(funcs)])\n    # Setup link line\n    oldLibs = self.setCompilers.LIBS\n    if libDir:\n      if not isinstance(libDir, list): libDir = [libDir]\n      for dir in libDir:\n        self.setCompilers.LIBS += ' -L'+dir\n    # new libs may/will depend on system libs so list new libs first!\n    # Matt, do not change this without talking to me\n    if libName and otherLibs:\n      self.setCompilers.LIBS = ' '+self.toString(libName+otherLibs) +' '+ self.setCompilers.LIBS\n    elif otherLibs:\n      self.setCompilers.LIBS = ' '+self.toString(otherLibs) +' '+ self.setCompilers.LIBS\n    elif libName:\n      self.setCompilers.LIBS = ' '+self.toString(libName) +' '+ self.setCompilers.LIBS\n    if cxxMangle: compileLang = 'Cxx'\n    else:         compileLang = self.language[-1]\n    if cxxLink: linklang = 'Cxx'\n    else: linklang = self.language[-1]\n    self.pushLanguage(compileLang)\n    found = 0\n    if self.checkLink(includes, body, linkLanguage=linklang, examineOutput=examineOutput):\n      found = 1\n      # define the symbol as found\n      if functionDefine: self.addDefine(self.getDefineNameFunc(fname), 1)\n      # add to list of found libraries\n      elif libName:\n        for lib in libName:\n          shortlib = self.getShortLibName(lib)\n          if shortlib: self.addDefine(self.getDefineName(shortlib), 1)\n    self.setCompilers.LIBS = oldLibs\n    self.popLanguage()\n    return found\n\n  def checkClassify(self, libName, funcs, libDir=None, otherLibs=[], prototype='', call='', fortranMangle=0, cxxMangle=0, cxxLink=0):\n    '''Recursive decompose to rapidly classify functions as found or missing'''\n    import config\n    def functional(funcs):\n      named = config.NamedInStderr(funcs)\n      if self.check(libName, funcs, libDir, otherLibs, prototype, call, fortranMangle, cxxMangle, cxxLink):\n        return True\n      else:\n        return named.named\n    found, missing = config.classify(funcs, functional)\n    return found, missing\n\n  def checkMath(self):\n    '''Check for sin() in libm, the math library'''\n    self.math = None\n    funcs = ['sin', 'floor', 'log10', 'pow']\n    prototypes = ['#include <stdio.h>\\ndouble sin(double);',\n                  '#include <stdio.h>\\ndouble floor(double);',\n                  '#include <stdio.h>\\ndouble log10(double);',\n                  '#include <stdio.h>\\ndouble pow(double, double);']\n    calls = ['double x,y; scanf(\"%lf\",&x); y = sin(x); printf(\"%f\",y);\\n',\n             'double x,y; scanf(\"%lf\",&x); y = floor(x); printf(\"%f\",y);\\n',\n             'double x,y; scanf(\"%lf\",&x); y = log10(x); printf(\"%f\",y);\\n',\n             'double x,y; scanf(\"%lf\",&x); y = pow(x,x); printf(\"%f\",y);\\n']\n    if self.check('', funcs, prototype = prototypes, call = calls):\n      self.math = []\n    elif self.check('m', funcs, prototype = prototypes, call = calls):\n      self.math = ['libm.a']\n    self.logPrint('CheckMath: using math library '+str(self.math))\n    return\n\n  def checkMathErf(self):\n    '''Check for erf() in libm, the math library'''\n    if not self.math is None and self.check(self.math, ['erf'], prototype = ['#include <math.h>'], call = ['double (*checkErf)(double) = erf;double x = 0,y; y = (*checkErf)(x)']):\n      self.logPrint('erf() found')\n      self.addDefine('HAVE_ERF', 1)\n    else:\n      self.logPrint('Warning: erf() not found')\n    return\n\n  def checkMathTgamma(self):\n    '''Check for tgamma() in libm, the math library'''\n    if not self.math is None and self.check(self.math, ['tgamma'], prototype = ['#include <math.h>'], call = ['double (*checkTgamma)(double) = tgamma;double x = 0,y; y = (*checkTgamma)(x)']):\n      self.logPrint('tgamma() found')\n      self.addDefine('HAVE_TGAMMA', 1)\n    else:\n      self.logPrint('Warning: tgamma() not found')\n    return\n\n  def checkMathFenv(self):\n    '''Checks if <fenv.h> can be used with FE_DFL_ENV'''\n    if not self.math is None and self.check(self.math, ['fesetenv'], prototype = ['#include <fenv.h>'], call = ['fesetenv(FE_DFL_ENV);']):\n      self.addDefine('HAVE_FENV_H', 1)\n    else:\n      self.logPrint('Warning: <fenv.h> with FE_DFL_ENV not found')\n    return\n\n  def checkMathLog2(self):\n    '''Check for log2() in libm, the math library'''\n    if not self.math is None and self.check(self.math, ['log2'], prototype = ['#include <math.h>'], call = ['double (*checkLog2)(double) = log2; double x = 2.5, y = (*checkLog2)(x)']):\n      self.logPrint('log2() found')\n      self.addDefine('HAVE_LOG2', 1)\n    else:\n      self.logPrint('Warning: log2() not found')\n    return\n\n  def checkRealtime(self):\n    '''Check for presence of clock_gettime() in realtime library (POSIX Realtime extensions)'''\n    self.rt = None\n    funcs = ['clock_gettime']\n    prototypes = ['#include <time.h>']\n    calls = ['struct timespec tp; clock_gettime(CLOCK_REALTIME,&tp);']\n    if self.check('', funcs, prototype=prototypes, call=calls):\n      self.logPrint('realtime functions are linked in by default')\n      self.rt = []\n    elif self.check('rt', funcs, prototype=prototypes, call=calls):\n      self.logPrint('Using librt for the realtime library')\n      self.rt = ['librt.a']\n    else:\n      self.logPrint('Warning: No realtime library found')\n    return\n\n  def checkDynamic(self):\n    '''Check for the header and libraries necessary for dynamic library manipulation'''\n    if 'with-dynamic-loading' in self.argDB and not self.argDB['with-dynamic-loading']: return\n    self.check(['dl'], 'dlopen')\n    self.headers.check('dlfcn.h')\n    return\n\n  def checkShared(self, includes, initFunction, checkFunction, finiFunction = None, checkLink = None, libraries = [], initArgs = '&argc, &argv', boolType = 'int', noCheckArg = 0, defaultArg = '', executor = None):\n    '''Determine whether a library is shared\n       - initFunction(int *argc, char *argv[]) is called to initialize some static data\n       - checkFunction(int *check) is called to verify that the static data wer set properly\n       - finiFunction() is called to finalize the data, and may be omitted\n       - checkLink may be given as ana alternative to the one in base.Configure'''\n    isShared = 0\n    if checkLink is None:\n      checkLink = self.checkLink\n      configObj = self\n    else:\n      if hasattr(checkLink, 'im_self'):\n        configObj = checkLink.__self__\n      else:\n        configObj = self\n\n    # Fix these flags\n    oldFlags = self.setCompilers.LIBS\n    self.setCompilers.LIBS = ' '+self.toString(libraries)+' '+self.setCompilers.LIBS\n\n    # Make a library which calls initFunction(), and returns checkFunction()\n    lib1Name = os.path.join(self.tmpDir, 'lib1.'+self.setCompilers.sharedLibraryExt)\n    if noCheckArg:\n      checkCode = 'isInitialized = '+checkFunction+'();'\n    else:\n      checkCode = checkFunction+'(&isInitialized);'\n    codeBegin = '''\n#ifdef __cplusplus\nextern \"C\"\n#endif\nint init(int argc,  char *argv[]) {\n'''\n    body      = '''\n  %s isInitialized;\n\n  %s(%s);\n  %s\n  return (int) isInitialized;\n''' % (boolType, initFunction, initArgs, checkCode)\n    codeEnd   = '\\n}\\n'\n    if not checkLink(includes, body, cleanup = 0, codeBegin = codeBegin, codeEnd = codeEnd, shared = 1):\n      if os.path.isfile(configObj.compilerObj): os.remove(configObj.compilerObj)\n      self.setCompilers.LIBS = oldFlags\n      raise RuntimeError('Could not complete shared library check')\n    if os.path.isfile(configObj.compilerObj): os.remove(configObj.compilerObj)\n    os.rename(configObj.linkerObj, lib1Name)\n\n    # Make a library which calls checkFunction()\n    lib2Name = os.path.join(self.tmpDir, 'lib2.'+self.setCompilers.sharedLibraryExt)\n    codeBegin = '''\n#ifdef __cplusplus\nextern \"C\"\n#endif\nint checkInit(void) {\n'''\n    body      = '''\n  %s isInitialized;\n\n  %s\n''' % (boolType, checkCode)\n    if finiFunction:\n      body += '  if (isInitialized) '+finiFunction+'();\\n'\n    body += '  return (int) isInitialized;\\n'\n    codeEnd   = '\\n}\\n'\n    if not checkLink(includes, body, cleanup = 0, codeBegin = codeBegin, codeEnd = codeEnd, shared = 1):\n      if os.path.isfile(configObj.compilerObj): os.remove(configObj.compilerObj)\n      self.setCompilers.LIBS = oldFlags\n      raise RuntimeError('Could not complete shared library check')\n      return 0\n    if os.path.isfile(configObj.compilerObj): os.remove(configObj.compilerObj)\n    os.rename(configObj.linkerObj, lib2Name)\n\n    self.setCompilers.LIBS = oldFlags\n\n    # Make an executable that dynamically loads and calls both libraries\n    #   If the check returns true in the second library, the static data was shared\n    guard = self.headers.getDefineName('dlfcn.h')\n    if self.headers.headerPrefix:\n      guard = self.headers.headerPrefix+'_'+guard\n    defaultIncludes = '''\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef %s\n#include <dlfcn.h>\n#endif\n    ''' % guard\n    body = '''\n  int   argc    = 1;\n  char *argv[2] = {(char *) \"conftest\", NULL};\n  void *lib;\n  int (*init)(int, char **);\n  int (*checkInit)(void);\n\n  lib = dlopen(\"'''+lib1Name+'''\", RTLD_LAZY);\n  if (!lib) {\n    fprintf(stderr, \"Could not open lib1.so: %s\\\\n\", dlerror());\n    exit(1);\n  }\n  init = (int (*)(int, char **)) dlsym(lib, \"init\");\n  if (!init) {\n    fprintf(stderr, \"Could not find initialization function\\\\n\");\n    exit(1);\n  }\n  if (!(*init)(argc, argv)) {\n    fprintf(stderr, \"Could not initialize library\\\\n\");\n    exit(1);\n  }\n  lib = dlopen(\"'''+lib2Name+'''\", RTLD_LAZY);\n  if (!lib) {\n    fprintf(stderr, \"Could not open lib2.so: %s\\\\n\", dlerror());\n    exit(1);\n  }\n  checkInit = (int (*)(void)) dlsym(lib, \"checkInit\");\n  if (!checkInit) {\n    fprintf(stderr, \"Could not find initialization check function\\\\n\");\n    exit(1);\n  }\n  if (!(*checkInit)()) {\n    fprintf(stderr, \"Did not link with shared library\\\\n\");\n    exit(2);\n  }\n  '''\n    oldLibs = self.setCompilers.LIBS\n    if self.haveLib('dl'):\n      self.setCompilers.LIBS += ' -ldl'\n    if self.checkRun(defaultIncludes, body, defaultArg = defaultArg, executor = executor):\n      isShared = 1\n    self.setCompilers.LIBS = oldLibs\n    if os.path.isfile(lib1Name) and self.framework.doCleanup: os.remove(lib1Name)\n    if os.path.isfile(lib2Name) and self.framework.doCleanup: os.remove(lib2Name)\n    if isShared:\n      self.logPrint('Library was shared')\n    else:\n      self.logPrint('Library was not shared')\n    return isShared\n\n  def isBGL(self):\n    '''Returns true if compiler is IBM cross compiler for BGL'''\n    if not hasattr(self, '_isBGL'):\n      self.logPrint('**********Checking if running on BGL/IBM detected')\n      if (self.check('', 'bgl_perfctr_void') or self.check('','ADIOI_BGL_Open')) and self.check('', '_xlqadd'):\n        self.logPrint('*********BGL/IBM detected')\n        self._isBGL = 1\n      else:\n        self.logPrint('*********BGL/IBM test failure')\n        self._isBGL = 0\n    return self._isBGL\n\n  def configure(self):\n    map(lambda args: self.executeTest(self.check, list(args)), self.libraries)\n    self.executeTest(self.checkMath)\n    self.executeTest(self.checkMathErf)\n    self.executeTest(self.checkMathTgamma)\n    self.executeTest(self.checkMathFenv)\n    self.executeTest(self.checkMathLog2)\n    self.executeTest(self.checkRealtime)\n    self.executeTest(self.checkDynamic)\n    return\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/config/BuildSystem/config/setCompilers.py": "from __future__ import generators\nimport config.base\nimport config\n\nimport os\nfrom functools import reduce\n\n# not sure how to handle this with 'self' so its outside the class\ndef noCheck(command, status, output, error):\n  return\n\ntry:\n  any\nexcept NameError:\n  def any(lst):\n    return reduce(lambda x,y:x or y,lst,False)\n\ndef _picTestIncludes(export=''):\n  return '\\n'.join(['#include <stdio.h>',\n                    'int (*fprintf_ptr)(FILE*,const char*,...) = fprintf;',\n                    'void '+export+' foo(void){',\n                    '  fprintf_ptr(stdout,\"hello\");',\n                    '  return;',\n                    '}',\n                    'void bar(void){foo();}\\n'])\n\nclass Configure(config.base.Configure):\n  def __init__(self, framework):\n    config.base.Configure.__init__(self, framework)\n    self.headerPrefix = ''\n    self.substPrefix  = ''\n    self.usedMPICompilers = 0\n    self.mainLanguage = 'C'\n    return\n\n  def __str__(self):\n    desc = ['Compilers:']\n    if hasattr(self, 'CC'):\n      self.pushLanguage('C')\n      desc.append('  C Compiler:         '+self.getCompiler()+' '+self.getCompilerFlags())\n      if not self.getLinker() == self.getCompiler(): desc.append('  C Linker:           '+self.getLinker()+' '+self.getLinkerFlags())\n      self.popLanguage()\n    if hasattr(self, 'CUDAC'):\n      self.pushLanguage('CUDA')\n      desc.append('  CUDA Compiler:      '+self.getCompiler()+' '+self.getCompilerFlags())\n      if not self.getLinker() == self.getCompiler(): desc.append('  CUDA Linker:        '+self.getLinker()+' '+self.getLinkerFlags())\n      self.popLanguage()\n    if hasattr(self, 'CXX'):\n      self.pushLanguage('Cxx')\n      desc.append('  C++ Compiler:       '+self.getCompiler()+' '+self.getCompilerFlags())\n      if not self.getLinker() == self.getCompiler(): desc.append('  C++ Linker:         '+self.getLinker()+' '+self.getLinkerFlags())\n      self.popLanguage()\n    if hasattr(self, 'FC'):\n      self.pushLanguage('FC')\n      desc.append('  Fortran Compiler:   '+self.getCompiler()+' '+self.getCompilerFlags())\n      if not self.getLinker() == self.getCompiler(): desc.append('  Fortran Linker:     '+self.getLinker()+' '+self.getLinkerFlags())\n      self.popLanguage()\n    desc.append('Linkers:')\n    if hasattr(self, 'staticLinker'):\n      desc.append('  Static linker:   '+self.getSharedLinker()+' '+self.AR_FLAGS)\n    elif hasattr(self, 'sharedLinker'):\n      desc.append('  Shared linker:   '+self.getSharedLinker()+' '+self.getSharedLinkerFlags())\n    if hasattr(self, 'dynamicLinker'):\n      desc.append('  Dynamic linker:   '+self.getDynamicLinker()+' '+self.getDynamicLinkerFlags())\n    return '\\n'.join(desc)+'\\n'\n\n  def setupHelp(self, help):\n    import nargs\n\n    help.addArgument('Compilers', '-with-cpp=<prog>', nargs.Arg(None, None, 'Specify the C preprocessor'))\n    help.addArgument('Compilers', '-CPP=<prog>',            nargs.Arg(None, None, 'Specify the C preprocessor'))\n    help.addArgument('Compilers', '-CPPFLAGS=<string>',     nargs.Arg(None, None, 'Specify the C preprocessor options'))\n    help.addArgument('Compilers', '-with-cc=<prog>',  nargs.Arg(None, None, 'Specify the C compiler'))\n    help.addArgument('Compilers', '-CC=<prog>',             nargs.Arg(None, None, 'Specify the C compiler'))\n    help.addArgument('Compilers', '-CFLAGS=<string>',       nargs.Arg(None, None, 'Specify the C compiler options'))\n    help.addArgument('Compilers', '-CC_LINKER_FLAGS=<string>',        nargs.Arg(None, [], 'Specify the C linker flags'))\n\n    help.addArgument('Compilers', '-CXXCPP=<prog>',          nargs.Arg(None, None, 'Specify the C++ preprocessor'))\n    help.addArgument('Compilers', '-CXXCPPFLAGS=<string>',  nargs.Arg(None, None, 'Specify the C++ preprocessor options'))\n    help.addArgument('Compilers', '-with-cxx=<prog>', nargs.Arg(None, None, 'Specify the C++ compiler'))\n    help.addArgument('Compilers', '-CXX=<prog>',            nargs.Arg(None, None, 'Specify the C++ compiler'))\n    help.addArgument('Compilers', '-CXXFLAGS=<string>',     nargs.Arg(None, None, 'Specify the C++ compiler options, also passed to linker'))\n    help.addArgument('Compilers', '-CXX_CXXFLAGS=<string>', nargs.Arg(None, '',   'Specify the C++ compiler-only options, not passed to linker'))\n    help.addArgument('Compilers', '-CXX_LINKER_FLAGS=<string>',       nargs.Arg(None, [], 'Specify the C++ linker flags'))\n\n    help.addArgument('Compilers', '-with-fc=<prog>',  nargs.Arg(None, None, 'Specify the Fortran compiler'))\n    help.addArgument('Compilers', '-FC=<prog>',             nargs.Arg(None, None, 'Specify the Fortran compiler'))\n    help.addArgument('Compilers', '-FFLAGS=<string>',       nargs.Arg(None, None, 'Specify the Fortran compiler options'))\n    help.addArgument('Compilers', '-FC_LINKER_FLAGS=<string>',        nargs.Arg(None, [], 'Specify the FC linker flags'))\n\n    help.addArgument('Compilers', '-with-gnu-compilers=<bool>',      nargs.ArgBool(None, 1, 'Try to use GNU compilers'))\n    help.addArgument('Compilers', '-with-vendor-compilers=<vendor as string>', nargs.Arg(None, '', 'Try to use vendor compilers (no argument all vendors, 0 no vendors)'))\n\n    help.addArgument('Compilers', '-with-large-file-io=<bool>', nargs.ArgBool(None, 0, 'Allow IO with files greater then 2 GB'))\n\n    help.addArgument('Compilers', '-CUDAPP=<prog>',        nargs.Arg(None, None, 'Specify the CUDA preprocessor'))\n    help.addArgument('Compilers', '-CUDAPPFLAGS=<string>', nargs.Arg(None, '-Wno-deprecated-gpu-targets', 'Specify the CUDA preprocessor options'))\n    help.addArgument('Compilers', '-CUDAC=<prog>',         nargs.Arg(None, None, 'Specify the CUDA compiler'))\n    help.addArgument('Compilers', '-CUDAFLAGS=<string>',   nargs.Arg(None, None, 'Specify the CUDA compiler options'))\n    help.addArgument('Compilers', '-CUDAC_LINKER_FLAGS=<string>',        nargs.Arg(None, [], 'Specify the CUDA linker flags'))\n\n##    help.addArgument('Compilers', '-LD=<prog>',              nargs.Arg(None, None, 'Specify the executable linker'))\n##    help.addArgument('Compilers', '-CC_LD=<prog>',           nargs.Arg(None, None, 'Specify the linker for C only'))\n##    help.addArgument('Compilers', '-CXX_LD=<prog>',          nargs.Arg(None, None, 'Specify the linker for C++ only'))\n##    help.addArgument('Compilers', '-FC_LD=<prog>',           nargs.Arg(None, None, 'Specify the linker for Fortran only'))\n    help.addArgument('Compilers', '-with-shared-ld=<prog>',  nargs.Arg(None, None, 'Specify the shared linker'))\n    help.addArgument('Compilers', '-LD_SHARED=<prog>',       nargs.Arg(None, None, 'Specify the shared linker'))\n    help.addArgument('Compilers', '-LDFLAGS=<string>',       nargs.Arg(None, '',   'Specify the linker options'))\n    help.addArgument('Compilers', '-with-ar=<prog>',                nargs.Arg(None, None,   'Specify the archiver'))\n    help.addArgument('Compilers', '-AR=<prog>',                     nargs.Arg(None, None,   'Specify the archiver flags'))\n    help.addArgument('Compilers', '-AR_FLAGS=<string>',               nargs.Arg(None, None,   'Specify the archiver flags'))\n    help.addArgument('Compilers', '-with-ranlib=<prog>',            nargs.Arg(None, None,   'Specify ranlib'))\n    help.addArgument('Compilers', '-with-pic=<bool>',               nargs.ArgBool(None, 0, 'Compile with -fPIC or equivalent flag if possible'))\n    help.addArgument('Compilers', '-sharedLibraryFlags=<string>',     nargs.Arg(None, [], 'Specify the shared library flags'))\n    help.addArgument('Compilers', '-dynamicLibraryFlags=<string>',    nargs.Arg(None, [], 'Specify the dynamic library flags'))\n    help.addArgument('Compilers', '-LIBS=<string>',          nargs.Arg(None, None, 'Specify extra libraries for all links'))\n    help.addArgument('Compilers', '-with-environment-variables=<bool>',nargs.ArgBool(None, 0, 'Use compiler variables found in environment'))\n    return\n\n  def setupDependencies(self, framework):\n    config.base.Configure.setupDependencies(self, framework)\n    self.headers = framework.require('config.headers', None)\n    self.libraries = framework.require('config.libraries', None)\n    return\n\n  def isNAG(compiler, log):\n    '''Returns true if the compiler is a NAG F90 compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -V',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find('NAGWare Fortran') >= 0 or output.find('The Numerical Algorithms Group Ltd') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isNAG = staticmethod(isNAG)\n\n  def isGNU(compiler, log):\n    '''Returns true if the compiler is a GNU compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help', log = log)\n      output = output + error\n      return (any([s in output for s in ['www.gnu.org',\n                                         'bugzilla.redhat.com',\n                                         'gcc.gnu.org',\n                                         'gcc version',\n                                         '-print-libgcc-file-name',\n                                         'passed on to the various sub-processes invoked by gcc',\n                                         'passed on to the various sub-processes invoked by cc',\n                                         'passed on to the various sub-processes invoked by gfortran',\n                                         'passed on to the various sub-processes invoked by g++',\n                                         'passed on to the various sub-processes invoked by c++',\n                                         ]])\n              and not any([s in output for s in ['Intel(R)',\n                                                 'Unrecognised option --help passed to ld', # NAG f95 compiler\n                                                 ]]))\n    except RuntimeError:\n      pass\n    return 0\n  isGNU = staticmethod(config.memoize(isGNU))\n\n  def isClang(compiler, log):\n    '''Returns true if the compiler is a Clang/LLVM compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help', log = log)\n      output = output + error\n      return any([s in output for s in ['Emit Clang AST']])\n    except RuntimeError:\n      pass\n    return 0\n  isClang = staticmethod(isClang)\n\n  def isGfortran45x(compiler, log):\n    '''returns true if the compiler is gfortran-4.5.x'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --version', log = log)\n      output = output +  error\n      import re\n      if re.match(r'GNU Fortran \\(.*\\) (4.5.\\d+|4.6.0 20100703)', output):\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isGfortran45x = staticmethod(isGfortran45x)\n\n  def isGfortran46plus(compiler, log):\n    '''returns true if the compiler is gfortran-4.6.x or later'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --version', log = log)\n      output = output +  error\n      import re\n      strmatch = re.match('GNU Fortran\\s+\\(.*\\)\\s+(\\d+)\\.(\\d+)',output)\n      if strmatch:\n        VMAJOR,VMINOR = strmatch.groups()\n        if (int(VMAJOR),int(VMINOR)) >= (4,6):\n          return 1\n    except RuntimeError:\n      pass\n    return 0\n  isGfortran46plus = staticmethod(isGfortran46plus)\n\n  def isGfortran47plus(compiler, log):\n    '''returns true if the compiler is gfortran-4.7.x or later'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --version', log = log)\n      output = output +  error\n      import re\n      strmatch = re.match('GNU Fortran\\s+\\(.*\\)\\s+(\\d+)\\.(\\d+)',output)\n      if strmatch:\n        VMAJOR,VMINOR = strmatch.groups()\n        if (int(VMAJOR),int(VMINOR)) >= (4,7):\n          return 1\n    except RuntimeError:\n      pass\n    return 0\n  isGfortran47plus = staticmethod(isGfortran47plus)\n\n\n  def isGfortran8plus(compiler, log):\n    '''returns true if the compiler is gfortran-8 or later'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --version', log = log)\n      output = output +  error\n      import re\n      strmatch = re.match('GNU Fortran\\s+\\(.*\\)\\s+(\\d+)\\.(\\d+)',output)\n      if strmatch:\n        VMAJOR,VMINOR = strmatch.groups()\n        if (int(VMAJOR),int(VMINOR)) >= (8,0):\n          return 1\n    except RuntimeError:\n      pass\n    return 0\n  isGfortran8plus = staticmethod(isGfortran8plus)\n\n  def isG95(compiler, log):\n    '''Returns true if the compiler is g95'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help', log = log)\n      output = output + error\n      if output.find('Unrecognised option --help passed to ld') >=0:    # NAG f95 compiler\n        return 0\n      if output.find('http://www.g95.org') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isG95 = staticmethod(isG95)\n\n  def isCompaqF90(compiler, log):\n    '''Returns true if the compiler is Compaq f90'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help', log = log)\n      output = output + error\n      if output.find('Unrecognised option --help passed to ld') >=0:    # NAG f95 compiler\n        return 0\n      if output.find('Compaq Visual Fortran') >= 0 or output.find('Digital Visual Fortran') >=0 :\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isCompaqF90 = staticmethod(isCompaqF90)\n\n  def isSun(compiler, log):\n    '''Returns true if the compiler is a Sun/Oracle compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -V',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find(' Sun ') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isSun = staticmethod(isSun)\n\n  def isIBM(compiler, log):\n    '''Returns true if the compiler is a IBM compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -qversion', log = log)\n      output = output + error\n      if 'IBM XL' in output:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isIBM = staticmethod(isIBM)\n\n  def isIntel(compiler, log):\n    '''Returns true if the compiler is a Intel compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help', log = log)\n      output = output + error\n      if output.find('Intel Corporation') >= 0 :\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isIntel = staticmethod(isIntel)\n\n  def isCray(compiler, log):\n    '''Returns true if the compiler is a Cray compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -V', log = log)\n      output = output + error\n      if output.find('Cray Standard C') >= 0 or output.find('Cray C++') >= 0 or output.find('Cray Fortran') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isCray = staticmethod(isCray)\n\n  def isCrayVector(compiler, log):\n    '''Returns true if the compiler is a Cray compiler for a Cray Vector system'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -VV', log = log)\n      output = output + error\n      if not status and output.find('x86') >= 0:\n        return 0\n      elif not status:\n        return 1\n      else:\n        return 0\n    except RuntimeError:\n      pass\n    return 0\n  isCrayVector = staticmethod(isCrayVector)\n\n\n  def isPGI(compiler, log):\n    '''Returns true if the compiler is a PGI compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -V',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find('The Portland Group') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isPGI = staticmethod(isPGI)\n\n  def isSolarisAR(ar, log):\n    '''Returns true AR is solaris'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(ar + ' -V',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find('Software Generation Utilities') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isSolarisAR = staticmethod(isSolarisAR)\n\n  def isAIXAR(ar, log):\n    '''Returns true AR is AIX'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(ar + ' -V',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find('[-X{32|64|32_64|d64|any}]') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isAIXAR = staticmethod(isAIXAR)\n\n\n  def isLinux(log):\n    '''Returns true if system is linux'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s', log = log)\n    if not status and output.lower().strip().find('linux') >= 0:\n      return 1\n    else:\n      return 0\n  isLinux = staticmethod(isLinux)\n\n  def isCygwin(log):\n    '''Returns true if system is cygwin'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s', log = log)\n    if not status and output.lower().strip().find('cygwin') >= 0:\n      return 1\n    else:\n      return 0\n  isCygwin = staticmethod(isCygwin)\n\n  def isSolaris(log):\n    '''Returns true if system is solaris'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s', log = log)\n    if not status and output.lower().strip().find('sunos') >= 0:\n      return 1\n    else:\n      return 0\n  isSolaris = staticmethod(isSolaris)\n\n  def isDarwin(log):\n    '''Returns true if system is Darwin/MacOSX'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s', log = log)\n    if not status:\n      return output.lower().strip() == 'darwin'\n    return 0\n  isDarwin = staticmethod(isDarwin)\n\n  def isFreeBSD(log):\n    '''Returns true if system is FreeBSD'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s', log = log)\n    if not status:\n      return output.lower().strip() == 'freebsd'\n    return 0\n  isFreeBSD = staticmethod(isFreeBSD)\n\n  def isWindows(compiler, log):\n    '''Returns true if the compiler is a Windows compiler'''\n    if compiler in ['icl', 'cl', 'bcc32', 'ifl', 'df']:\n      return 1\n    if compiler in ['ifort','f90'] and Configure.isCygwin(log):\n      return 1\n    if compiler in ['lib', 'tlib']:\n      return 1\n    return 0\n  isWindows = staticmethod(isWindows)\n\n  def addLdPath(path):\n    import os\n    if 'LD_LIBRARY_PATH' in os.environ:\n      ldPath=os.environ['LD_LIBRARY_PATH']\n    else:\n      ldPath=''\n    if ldPath == '': ldPath = path\n    else: ldPath += ':' + path\n    os.environ['LD_LIBRARY_PATH'] = ldPath\n    return\n  addLdPath = staticmethod(addLdPath)\n\n  def useMPICompilers(self):\n    if ('with-cc' in self.argDB and self.argDB['with-cc'] != '0') or 'CC' in self.argDB:\n      return 0\n    if ('with-cxx' in self.argDB and self.argDB['with-cxx'] != '0') or 'CXX' in self.argDB:\n      return 0\n    if ('with-fc' in self.argDB and self.argDB['with-fc'] != '0') or 'FC' in self.argDB:\n      return 0\n    if self.argDB['download-mpich'] or self.argDB['download-openmpi']:\n      return 0\n    if 'with-mpi' in self.argDB and self.argDB['with-mpi'] and self.argDB['with-mpi-compilers']:\n      return 1\n    return 0\n\n  def checkVendor(self):\n    '''Determine the compiler vendor'''\n    self.vendor = self.argDB['with-vendor-compilers']\n    if self.argDB['with-vendor-compilers'] == 'no' or self.argDB['with-vendor-compilers'] == 'false':\n      self.vendor = None\n    if self.argDB['with-vendor-compilers'] == '1' or self.argDB['with-vendor-compilers'] == 'yes' or self.argDB['with-vendor-compilers'] == 'true':\n      self.vendor = ''\n    self.logPrint('Compiler vendor is \"'+str(self.vendor)+'\"')\n    return\n\n  def checkInitialFlags(self):\n    '''Initialize the compiler and linker flags'''\n    for language in ['C', 'CUDA', 'Cxx', 'FC']:\n      self.pushLanguage(language)\n      for flagsArg in [self.getCompilerFlagsName(language), self.getCompilerFlagsName(language, 1), self.getLinkerFlagsName(language)]:\n        if flagsArg in self.argDB: setattr(self, flagsArg, self.argDB[flagsArg])\n        else: setattr(self, flagsArg, '')\n        self.logPrint('Initialized '+flagsArg+' to '+str(getattr(self, flagsArg)))\n      self.popLanguage()\n    for flagsArg in ['CPPFLAGS', 'CUDAPPFLAGS', 'CXXCPPFLAGS', 'CC_LINKER_FLAGS', 'CXX_LINKER_FLAGS', 'FC_LINKER_FLAGS', 'CUDAC_LINKER_FLAGS','sharedLibraryFlags', 'dynamicLibraryFlags']:\n      if flagsArg in self.argDB: setattr(self, flagsArg, self.argDB[flagsArg])\n      else: setattr(self, flagsArg, '')\n      self.logPrint('Initialized '+flagsArg+' to '+str(getattr(self, flagsArg)))\n    if 'LIBS' in self.argDB:\n      self.LIBS = self.argDB['LIBS']\n    else:\n      self.LIBS = ''\n    return\n\n  def checkCompiler(self, language, linkLanguage=None,includes = '', body = '', cleanup = 1, codeBegin = None, codeEnd = None):\n    '''Check that the given compiler is functional, and if not raise an exception'''\n    self.pushLanguage(language)\n    if not self.checkCompile(includes, body, cleanup, codeBegin, codeEnd):\n      msg = 'Cannot compile '+language+' with '+self.getCompiler()+'.'\n      self.popLanguage()\n      raise RuntimeError(msg)\n    if language == 'CUDA': # do not check CUDA linker since it is never used (and is broken on Mac with -m64)\n      self.popLanguage()\n      return\n    if not self.checkLink(linkLanguage=linkLanguage,includes=includes,body=body):\n      msg = 'Cannot compile/link '+language+' with '+self.getCompiler()+'.'\n      self.popLanguage()\n      raise RuntimeError(msg)\n    oldlibs = self.LIBS\n    self.LIBS += ' -lpetsc-ufod4vtr9mqHvKIQiVAm'\n    if self.checkLink(linkLanguage=linkLanguage):\n      msg = language + ' compiler ' + self.getCompiler()+ ''' is broken! It is returning a zero error when the linking failed! Either\n 1) switch to another compiler suite or\n 2) report this entire error message to your compiler/linker suite vendor and ask for fix for this issue.'''\n      self.popLanguage()\n      self.LIBS = oldlibs\n      raise RuntimeError(msg)\n    self.LIBS = oldlibs\n    if not self.argDB['with-batch']:\n      if not self.checkRun(linkLanguage=linkLanguage):\n        msg = 'Cannot run executables created with '+language+'. If this machine uses a batch system \\nto submit jobs you will need to configure using ./configure with the additional option  --with-batch.\\n Otherwise there is problem with the compilers. Can you compile and run code with your compiler \\''+ self.getCompiler()+'\\'?\\n'\n        if self.isIntel(self.getCompiler(), self.log):\n          msg = msg + 'See http://www.mcs.anl.gov/petsc/documentation/faq.html#libimf'\n        self.popLanguage()\n        raise OSError(msg)\n    self.popLanguage()\n    return\n\n  def generateCCompilerGuesses(self):\n    '''Determine the C compiler using CC, then --with-cc, then MPI, then GNU, then vendors\n       - Any given category can be excluded'''\n    if hasattr(self, 'CC'):\n      yield self.CC\n    elif 'with-cc' in self.argDB:\n      if self.isWindows(self.argDB['with-cc'], self.log):\n        yield 'win32fe '+self.argDB['with-cc']\n      else:\n        yield self.argDB['with-cc']\n      raise RuntimeError('C compiler you provided with -with-cc='+self.argDB['with-cc']+' does not work.'+'\\n'+self.mesg)\n    elif 'CC' in self.argDB:\n      if self.isWindows(self.argDB['CC'], self.log):\n        yield 'win32fe '+self.argDB['CC']\n      else:\n        yield self.argDB['CC']\n      raise RuntimeError('C compiler you provided with -CC='+self.argDB['CC']+' does not work.'+'\\n'+self.mesg)\n    elif self.useMPICompilers() and 'with-mpi-dir' in self.argDB and os.path.isdir(os.path.join(self.argDB['with-mpi-dir'], 'bin')):\n      self.usedMPICompilers = 1\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpicc')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpcc')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'hcc')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpcc_r')\n      self.usedMPICompilers = 0\n      raise RuntimeError('MPI compiler wrappers in '+self.argDB['with-mpi-dir']+'/bin do not work. See http://www.mcs.anl.gov/petsc/documentation/faq.html#mpi-compilers')\n    else:\n      if self.useMPICompilers() and 'with-mpi-dir' in self.argDB:\n      # if it gets here these means that self.argDB['with-mpi-dir']/bin does not exist so we should not search for MPI compilers\n      # that is we are turning off the self.useMPICompilers()\n        self.logPrintBox('***** WARNING: '+os.path.join(self.argDB['with-mpi-dir'], 'bin')+ ' dir does not exist!\\n Skipping check for MPI compilers due to potentially incorrect --with-mpi-dir option.\\n Suggest using --with-cc=/path/to/mpicc option instead ******')\n\n        self.argDB['with-mpi-compilers'] = 0\n      if self.useMPICompilers():\n        self.usedMPICompilers = 1\n        if Configure.isGNU('mpicc', self.log) and self.argDB['with-gnu-compilers']:\n          yield 'mpicc'\n        if Configure.isGNU('hcc', self.log) and self.argDB['with-gnu-compilers']:\n          yield 'hcc'\n        if not Configure.isGNU('mpicc', self.log) and (not self.vendor is None):\n          yield 'mpicc'\n        if not Configure.isGNU('hcc', self.log) and (not self.vendor is None):\n          yield 'hcc'\n        if not self.vendor is None:\n          yield 'mpcc_r'\n          yield 'mpcc'\n          yield 'mpxlc'\n        self.usedMPICompilers = 0\n      vendor = self.vendor\n      if (not vendor) and self.argDB['with-gnu-compilers']:\n        yield 'gcc'\n        if Configure.isGNU('cc', self.log):\n          yield 'cc'\n      if not self.vendor is None:\n        if not vendor and not Configure.isGNU('cc', self.log):\n          yield 'cc'\n        if vendor == 'borland' or not vendor:\n          yield 'win32fe bcc32'\n        if vendor == 'kai' or not vendor:\n          yield 'kcc'\n        if vendor == 'ibm' or not vendor:\n          yield 'xlc'\n        if vendor == 'intel' or not vendor:\n          yield 'icc'\n          yield 'ecc'\n          yield 'win32fe icl'\n        if vendor == 'microsoft' or not vendor:\n          yield 'win32fe cl'\n        if vendor == 'portland' or not vendor:\n          yield 'pgcc'\n        if vendor == 'solaris' or not vendor:\n          if not Configure.isGNU('cc', self.log):\n            yield 'cc'\n      # duplicate code\n      if self.argDB['with-gnu-compilers']:\n        yield 'gcc'\n        if Configure.isGNU('cc', self.log):\n          yield 'cc'\n    return\n\n  def checkCCompiler(self):\n    '''Locate a functional C compiler'''\n    if 'with-cc' in self.argDB and self.argDB['with-cc'] == '0':\n      raise RuntimeError('A functional C compiler is necessary for configure, cannot use --with-cc=0')\n    self.mesg = ''\n    for compiler in self.generateCCompilerGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CC'):\n          self.checkCompiler('C')\n          break\n      except RuntimeError as e:\n        import os\n        self.mesg = str(e)\n        self.logPrint('Error testing C compiler: '+str(e))\n        if os.path.basename(self.CC) == 'mpicc':\n          self.logPrint(' MPI installation '+str(self.CC)+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI.')\n        self.delMakeMacro('CC')\n        del self.CC\n    if not hasattr(self, 'CC'):\n      raise RuntimeError('Could not locate a functional C compiler')\n    return\n\n  def generateCPreprocessorGuesses(self):\n    '''Determines the C preprocessor from CPP, then --with-cpp, then the C compiler'''\n    if 'with-cpp' in self.argDB:\n      yield self.argDB['with-cpp']\n    elif 'CPP' in self.argDB:\n      yield self.argDB['CPP']\n    else:\n      yield self.CC+' -E'\n      yield self.CC+' --use cpp32'\n    return\n\n  def checkCPreprocessor(self):\n    '''Locate a functional C preprocessor'''\n    for compiler in self.generateCPreprocessorGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CPP'):\n          self.pushLanguage('C')\n          if not self.checkPreprocess('#include <stdlib.h>\\n'):\n            raise RuntimeError('Cannot preprocess C with '+self.CPP+'.')\n          self.popLanguage()\n          return\n      except RuntimeError as e:\n        self.popLanguage()\n    raise RuntimeError('Cannot find a C preprocessor')\n    return\n\n  def generateCUDACompilerGuesses(self):\n    import os\n    '''Determine the CUDA compiler using CUDAC, then --with-cudac, then vendors\n       - Any given category can be excluded'''\n    if hasattr(self, 'CUDAC'):\n      yield self.CUDAC\n    elif 'with-cudac' in self.argDB:\n      yield self.argDB['with-cudac']\n      raise RuntimeError('CUDA compiler you provided with -with-cudac='+self.argDB['with-cudac']+' does not work.'+'\\n'+self.mesg)\n    elif 'CUDAC' in self.argDB:\n      yield self.argDB['CUDAC']\n      raise RuntimeError('CUDA compiler you provided with -CUDAC='+self.argDB['CUDAC']+' does not work.'+'\\n'+self.mesg)\n    elif 'with-cuda-dir' in self.argDB:\n      import os\n      nvccPath = os.path.join(self.argDB['with-cuda-dir'], 'bin','nvcc')\n      yield nvccPath\n    else:\n      vendor = self.vendor\n      if not self.vendor is None:\n        if vendor == 'nvidia' or not vendor:\n          yield 'nvcc'\n      yield 'nvcc'\n      yield os.path.join('/Developer','NVIDIA','CUDA-6.5','bin','nvcc')\n      yield os.path.join('/usr','local','cuda','bin','nvcc')\n    return\n\n  def checkCUDACompiler(self):\n    '''Locate a functional CUDA compiler'''\n    if ('with-cuda' not in self.framework.clArgDB and 'with-cuda-dir' not in self.framework.clArgDB) or self.argDB['with-cuda'] == '0':\n      if 'CUDAC' in self.argDB:\n        del self.argDB['CUDAC']\n      return\n    self.mesg = ''\n    for compiler in self.generateCUDACompilerGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CUDAC'):\n          self.checkCompiler('CUDA')\n          # Put version info into the log\n          compilerVersion = self.executeShellCommand(self.CUDAC+' --version', log = self.log)\n          compilerVersion = compilerVersion[0]\n          compilerVersion = compilerVersion.split()\n          i = 0\n          for word in compilerVersion:\n            i = i+1\n            if word == 'release':\n              break\n          self.compilerVersionCUDA = compilerVersion[i].strip(',')\n          break\n      except RuntimeError as e:\n        self.mesg = str(e)\n        self.logPrint('Error testing CUDA compiler: '+str(e))\n        self.delMakeMacro('CUDAC')\n        del self.CUDAC\n    return\n\n  def generateCUDAPreprocessorGuesses(self):\n    '''Determines the CUDA preprocessor from --with-cudacpp, then CUDAPP, then the CUDA compiler'''\n    if 'with-cudacpp' in self.argDB:\n      yield self.argDB['with-cudacpp']\n    elif 'CUDAPP' in self.argDB:\n      yield self.argDB['CUDAPP']\n    else:\n      if hasattr(self, 'CUDAC'):\n        yield self.CUDAC+' -E'\n    return\n\n  def checkCUDAPreprocessor(self):\n    '''Locate a functional CUDA preprocessor'''\n    for compiler in self.generateCUDAPreprocessorGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CUDAPP'):\n          self.pushLanguage('CUDA')\n          if not self.checkPreprocess('#include <stdlib.h>\\n__global__ void testFunction() {return;};'):\n            raise RuntimeError('Cannot preprocess CUDA with '+self.CUDAPP+'.')\n          self.popLanguage()\n          return\n      except RuntimeError as e:\n        self.popLanguage()\n    return\n\n  def generateCxxCompilerGuesses(self):\n    '''Determine the Cxx compiler using CXX, then --with-cxx, then MPI, then GNU, then vendors\n       - Any given category can be excluded'''\n    import os\n\n    if hasattr(self, 'CXX'):\n      yield self.CXX\n    elif 'with-c++' in self.argDB:\n      raise RuntimeError('Keyword --with-c++ is WRONG, use --with-cxx')\n    if 'with-CC' in self.argDB:\n      raise RuntimeError('Keyword --with-CC is WRONG, use --with-cxx')\n\n    if 'with-cxx' in self.argDB:\n      if self.argDB['with-cxx'] == 'gcc': raise RuntimeError('Cannot use C compiler gcc as the C++ compiler passed in with --with-cxx')\n      if self.isWindows(self.argDB['with-cxx'], self.log):\n        yield 'win32fe '+self.argDB['with-cxx']\n      else:\n        yield self.argDB['with-cxx']\n      raise RuntimeError('C++ compiler you provided with -with-cxx='+self.argDB['with-cxx']+' does not work.'+'\\n'+self.mesg)\n    elif 'CXX' in self.argDB:\n      if self.isWindows(self.argDB['CXX'], self.log):\n        yield 'win32fe '+self.argDB['CXX']\n      else:\n        yield self.argDB['CXX']\n      raise RuntimeError('C++ compiler you provided with -CXX='+self.argDB['CXX']+' does not work.'+'\\n'+self.mesg)\n    elif self.useMPICompilers() and 'with-mpi-dir' in self.argDB and os.path.isdir(os.path.join(self.argDB['with-mpi-dir'], 'bin')):\n      self.usedMPICompilers = 1\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpicxx')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'hcp')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpic++')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpiCC')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpCC_r')\n      self.usedMPICompilers = 0\n      raise RuntimeError('bin/<mpiCC,mpicxx,hcp,mpCC_r> you provided with -with-mpi-dir='+self.argDB['with-mpi-dir']+' does not work. See http://www.mcs.anl.gov/petsc/documentation/faq.html#mpi-compilers')\n    else:\n      if self.useMPICompilers():\n        self.usedMPICompilers = 1\n        if Configure.isGNU('mpicxx', self.log) and self.argDB['with-gnu-compilers']:\n          yield 'mpicxx'\n        if not Configure.isGNU('mpicxx', self.log) and (not self.vendor is None):\n          yield 'mpicxx'\n        if Configure.isGNU('mpiCC', self.log) and self.argDB['with-gnu-compilers']:\n          yield 'mpiCC'\n        if not Configure.isGNU('mpiCC', self.log) and (not self.vendor is None):\n          yield 'mpiCC'\n        if Configure.isGNU('mpic++', self.log) and self.argDB['with-gnu-compilers']:\n          yield 'mpic++'\n        if not Configure.isGNU('mpic++', self.log) and (not self.vendor is None):\n          yield 'mpic++'\n        if not self.vendor is None:\n          yield 'mpCC_r'\n          yield 'mpCC'\n        self.usedMPICompilers = 0\n      #attempt to match c++ compiler with c compiler\n      if self.CC.find('win32fe cl') >= 0:\n        yield 'win32fe cl'\n      elif self.CC.find('win32fe icl') >= 0:\n        yield 'win32fe icl'\n      elif self.CC == 'clang':\n        yield 'clang++'\n      elif self.CC == 'icc':\n        yield 'icpc'\n      vendor = self.vendor\n      if (not vendor) and self.argDB['with-gnu-compilers']:\n        yield 'g++'\n        if Configure.isGNU('c++', self.log):\n          yield 'c++'\n      if not self.vendor is None:\n        if not vendor:\n          if not Configure.isGNU('c++', self.log):\n            yield 'c++'\n          if not Configure.isGNU('CC', self.log):\n            yield 'CC'\n          yield 'cxx'\n          yield 'cc++'\n        if vendor == 'borland' or not vendor:\n          yield 'win32fe bcc32'\n        if vendor == 'ibm' or not vendor:\n          yield 'xlC'\n        if vendor == 'intel' or not vendor:\n          yield 'icpc'\n          yield 'ccpc'\n          yield 'icc'\n          yield 'ecc'\n          yield 'win32fe icl'\n        if vendor == 'microsoft' or not vendor:\n          yield 'win32fe cl'\n        if vendor == 'portland' or not vendor:\n          yield 'pgCC'\n        if vendor == 'solaris':\n          yield 'CC'\n      #duplicate code\n      if self.argDB['with-gnu-compilers']:\n        yield 'g++'\n        if Configure.isGNU('c++', self.log):\n          yield 'c++'\n    return\n\n  def checkCxxCompiler(self):\n    '''Locate a functional Cxx compiler'''\n    if 'with-cxx' in self.argDB and self.argDB['with-cxx'] == '0':\n      if 'CXX' in self.argDB:\n        del self.argDB['CXX']\n      return\n    self.mesg = ''\n    for compiler in self.generateCxxCompilerGuesses():\n      # Determine an acceptable extensions for the C++ compiler\n      for ext in ['.cc', '.cpp', '.C']:\n        self.framework.getCompilerObject('Cxx').sourceExtension = ext\n        try:\n          if self.getExecutable(compiler, resultName = 'CXX'):\n            self.checkCompiler('Cxx')\n            break\n        except RuntimeError as e:\n          import os\n          self.mesg = str(e)\n          self.logPrint('Error testing C++ compiler: '+str(e))\n          if os.path.basename(self.CXX) in ['mpicxx', 'mpiCC']:\n            self.logPrint('  MPI installation '+str(self.CXX)+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI.')\n          self.delMakeMacro('CXX')\n          del self.CXX\n      if hasattr(self, 'CXX'):\n        break\n    return\n\n  def generateCxxPreprocessorGuesses(self):\n    '''Determines the Cxx preprocessor from CXXCPP, then --with-cxxcpp, then the Cxx compiler'''\n    if 'with-cxxcpp' in self.argDB:\n      yield self.argDB['with-cxxcpp']\n    elif 'CXXCPP' in self.argDB:\n      yield self.argDB['CXXCPP']\n    else:\n      yield self.CXX+' -E'\n      yield self.CXX+' --use cpp32'\n    return\n\n  def checkCxxPreprocessor(self):\n    '''Locate a functional Cxx preprocessor'''\n    if not hasattr(self, 'CXX'):\n      return\n    for compiler in self.generateCxxPreprocessorGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CXXCPP'):\n          self.pushLanguage('Cxx')\n          if not self.checkPreprocess('#include <cstdlib>\\n'):\n            raise RuntimeError('Cannot preprocess Cxx with '+self.CXXCPP+'.')\n          self.popLanguage()\n          break\n      except RuntimeError as e:\n        import os\n\n        if os.path.basename(self.CXXCPP) in ['mpicxx', 'mpiCC']:\n          self.logPrint('MPI installation '+self.getCompiler()+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI')\n        self.popLanguage()\n        self.delMakeMacro('CCCPP')\n        del self.CXXCPP\n    return\n\n  def generateFortranCompilerGuesses(self):\n    '''Determine the Fortran compiler using FC, then --with-fc, then MPI, then GNU, then vendors\n       - Any given category can be excluded'''\n    import os\n\n    if hasattr(self, 'FC'):\n      yield self.FC\n    elif 'with-fc' in self.argDB:\n      if self.isWindows(self.argDB['with-fc'], self.log):\n        yield 'win32fe '+self.argDB['with-fc']\n      else:\n        yield self.argDB['with-fc']\n      raise RuntimeError('Fortran compiler you provided with --with-fc='+self.argDB['with-fc']+' does not work.'+'\\n'+self.mesg)\n    elif 'FC' in self.argDB:\n      if self.isWindows(self.argDB['FC'], self.log):\n        yield 'win32fe '+self.argDB['FC']\n      else:\n        yield self.argDB['FC']\n      yield self.argDB['FC']\n      raise RuntimeError('Fortran compiler you provided with -FC='+self.argDB['FC']+' does not work.'+'\\n'+self.mesg)\n    elif self.useMPICompilers() and 'with-mpi-dir' in self.argDB and os.path.isdir(os.path.join(self.argDB['with-mpi-dir'], 'bin')):\n      self.usedMPICompilers = 1\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpif90')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpif77')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpxlf95_r')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpxlf90_r')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpxlf_r')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpf90')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpf77')\n      self.usedMPICompilers = 0\n      if os.path.isfile(os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpif90')) or os.path.isfile((os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpif77'))):\n        raise RuntimeError('bin/mpif90[f77] you provided with --with-mpi-dir='+self.argDB['with-mpi-dir']+' does not work.\\nRun with --with-fc=0 if you wish to use this MPI and disable Fortran. See http://www.mcs.anl.gov/petsc/documentation/faq.html#mpi-compilers')\n    else:\n      if self.useMPICompilers():\n        self.usedMPICompilers = 1\n        if Configure.isGNU('mpif90', self.log) and self.argDB['with-gnu-compilers']:\n          yield 'mpif90'\n        if not Configure.isGNU('mpif90', self.log) and (not self.vendor is None):\n          yield 'mpif90'\n        if Configure.isGNU('mpif77', self.log) and self.argDB['with-gnu-compilers']:\n          yield 'mpif77'\n        if not Configure.isGNU('mpif77', self.log) and (not self.vendor is None):\n          yield 'mpif77'\n        if not self.vendor is None:\n          yield 'mpxlf_r'\n          yield 'mpxlf'\n          yield 'mpf90'\n          yield 'mpf77'\n        self.usedMPICompilers = 0\n      #attempt to match fortran compiler with c compiler\n      if self.CC.find('win32fe cl') >= 0:\n        yield 'win32fe f90'\n        yield 'win32fe ifc'\n      elif self.CC.find('win32fe icl') >= 0:\n        yield 'win32fe ifc'\n      elif self.CC == 'icc':\n        yield 'ifort'\n      vendor = self.vendor\n      if (not vendor) and self.argDB['with-gnu-compilers']:\n        yield 'gfortran'\n        yield 'g95'\n        yield 'g77'\n        if Configure.isGNU('f77', self.log):\n          yield 'f77'\n      if not self.vendor is None:\n        if vendor == 'ibm' or not vendor:\n          yield 'xlf'\n          yield 'xlf90'\n        if not vendor or vendor in ['absoft', 'cray', 'dec', 'hp', 'sgi']:\n          yield 'f90'\n        if vendor == 'lahaye' or not vendor:\n          yield 'lf95'\n        if vendor == 'intel' or not vendor:\n          yield 'win32fe ifort'\n          yield 'win32fe ifl'\n          yield 'ifort'\n          yield 'ifc'\n          yield 'efc'\n        if vendor == 'portland' or not vendor:\n          yield 'pgf90'\n          yield 'pgf77'\n        if vendor == 'solaris' or not vendor:\n          yield 'f95'\n          yield 'f90'\n          if not Configure.isGNU('f77', self.log):\n            yield 'f77'\n      #duplicate code\n      if self.argDB['with-gnu-compilers']:\n        yield 'gfortran'\n        yield 'g95'\n        yield 'g77'\n        if Configure.isGNU('f77', self.log):\n          yield 'f77'\n    return\n\n  def checkFortranCompiler(self):\n    '''Locate a functional Fortran compiler'''\n    if 'with-fc' in self.argDB and self.argDB['with-fc'] == '0':\n      if 'FC' in self.argDB:\n        del self.argDB['FC']\n      return\n    self.mesg = ''\n    for compiler in self.generateFortranCompilerGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'FC'):\n          self.checkCompiler('FC')\n          break\n      except RuntimeError as e:\n        self.mesg = str(e)\n        self.logPrint('Error testing Fortran compiler: '+str(e))\n        if os.path.basename(self.FC) in ['mpif90', 'mpif77']:\n          self.logPrint(' MPI installation '+str(self.FC)+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI.')\n        self.delMakeMacro('FC')\n        del self.FC\n    return\n\n  def checkFortranComments(self):\n    '''Make sure fortran comment \"!\" works'''\n    self.pushLanguage('FC')\n    if not self.checkCompile('! comment'):\n      raise RuntimeError(self.getCompiler()+' cannot process fortran comments.')\n    self.logPrint('Fortran comments can use ! in column 1')\n    self.popLanguage()\n    return\n\n  def containsInvalidFlag(self, output):\n    '''If the output contains evidence that an invalid flag was used, return True'''\n    if (output.find('Unrecognized command line option') >= 0 or output.find('Unrecognised command line option') >= 0 or\n        output.find('unrecognized command line option') >= 0 or output.find('unrecognized option') >= 0 or output.find('unrecognised option') >= 0 or\n        output.find('not recognized') >= 0 or output.find('not recognised') >= 0 or\n        output.find('unknown option') >= 0 or output.find('unknown flag') >= 0 or output.find('Unknown switch') >= 0 or\n        output.find('ignoring option') >= 0 or output.find('ignored') >= 0 or\n        output.find('argument unused') >= 0 or\n        # When checking for the existence of 'attribute'\n        output.find('is unsupported and will be skipped') >= 0 or\n        output.find('illegal option') >= 0 or output.find('Invalid option') >= 0 or\n        (output.find('bad ') >= 0 and output.find(' option') >= 0) or\n        output.find('linker input file unused because linking not done') >= 0 or\n        output.find('PETSc Error') >= 0 or\n        output.find('Unbekannte Option') >= 0 or\n        output.find('warning: // comments are not allowed in this language') >= 0 or\n        output.find('no se reconoce la opci') >= 0) or output.find('non reconnue') >= 0:\n      return 1\n    return 0\n\n  def checkCompilerFlag(self, flag, includes = '', body = '', compilerOnly = 0):\n    '''Determine whether the compiler accepts the given flag'''\n    flagsArg = self.getCompilerFlagsArg(compilerOnly)\n    oldFlags = getattr(self, flagsArg)\n    setattr(self, flagsArg, oldFlags+' '+flag)\n    (output, error, status) = self.outputCompile(includes, body)\n    output += error\n    valid   = 1\n    # Please comment each entry and provide an example line\n    if status:\n      valid = 0\n      self.logPrint('Rejecting compiler flag '+flag+' due to nonzero status from link')\n    # Lahaye F95\n    if output.find('Invalid suboption') >= 0:\n      valid = 0\n    if self.containsInvalidFlag(output):\n      valid = 0\n      self.logPrint('Rejecting compiler flag '+flag+' due to \\n'+output)\n    setattr(self, flagsArg, oldFlags)\n    return valid\n\n  def insertCompilerFlag(self, flag, compilerOnly):\n    '''DANGEROUS: Put in the compiler flag without checking'''\n    flagsArg = self.getCompilerFlagsArg(compilerOnly)\n    setattr(self, flagsArg, getattr(self, flagsArg)+' '+flag)\n    self.log.write('Added '+self.language[-1]+' compiler flag '+flag+'\\n')\n    return\n\n  def addCompilerFlag(self, flag, includes = '', body = '', extraflags = '', compilerOnly = 0):\n    '''Determine whether the compiler accepts the given flag, and add it if valid, otherwise throw an exception'''\n    if self.checkCompilerFlag(flag+' '+extraflags, includes, body, compilerOnly):\n      self.insertCompilerFlag(flag, compilerOnly)\n      return\n    raise RuntimeError('Bad compiler flag: '+flag)\n\n  def generatePICGuesses(self):\n    yield ''\n    if self.language[-1] == 'CUDA':\n      yield '-Xcompiler -fPIC'\n    elif config.setCompilers.Configure.isGNU(self.getCompiler(), self.log):\n      yield '-fPIC'\n    else:\n      yield '-PIC'\n      yield '-fPIC'\n      yield '-KPIC'\n      yield '-qpic'\n    return\n\n  def checkPIC(self):\n    '''Determine the PIC option for each compiler'''\n    self.usePIC = 0\n    useSharedLibraries = 'with-shared-libraries' in self.argDB and self.argDB['with-shared-libraries']\n    myLanguage = self.language[-1]\n    if not self.argDB['with-pic'] and not useSharedLibraries:\n      self.logPrint(\"Skip checking PIC options on user request\")\n      return\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    if hasattr(self, 'FC'):\n      languages.append('FC')\n    if hasattr(self, 'CUDAC'):\n      languages.append('CUDA')\n    for language in languages:\n      self.pushLanguage(language)\n      if language in ['C','Cxx','CUDA']:\n        includeLine = _picTestIncludes()\n      else:\n        includeLine = '      function foo(a)\\n      real:: a,x,bar\\n      common /xx/ x\\n      x=a\\n      foo = bar(x)\\n      end\\n'\n      compilerFlagsArg = self.getCompilerFlagsArg(1) # compiler only\n      oldCompilerFlags = getattr(self, compilerFlagsArg)\n      for testFlag in self.generatePICGuesses():\n        self.logPrint('Trying '+language+' compiler flag '+testFlag)\n        acceptedPIC = 1\n        try:\n          self.addCompilerFlag(testFlag, compilerOnly = 1)\n          acceptedPIC = self.checkLink(includes = includeLine, body = None, codeBegin = '', codeEnd = '', cleanup = 1, shared = 1, linkLanguage = myLanguage)\n        except RuntimeError:\n          acceptedPIC = 0\n        if not acceptedPIC:\n          self.logPrint('Rejected '+language+' compiler flag '+testFlag+' because shared linker cannot handle it')\n          setattr(self, compilerFlagsArg, oldCompilerFlags)\n          continue\n        self.logPrint('Accepted '+language+' compiler flag '+testFlag)\n        self.isPIC = 1\n        break\n      self.popLanguage()\n    return\n\n  def checkLargeFileIO(self):\n    # check for large file support with 64bit offset\n    if not self.argDB['with-large-file-io']:\n      return\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    for language in languages:\n      self.pushLanguage(language)\n      if self.checkCompile('#include <unistd.h>','#ifndef _LFS64_LARGEFILE \\n#error no largefile defines \\n#endif'):\n        try:\n          self.addCompilerFlag('-D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64',compilerOnly=1)\n        except RuntimeError as e:\n          self.logPrint('Error adding ' +language+ ' flags -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64')\n      else:\n        self.logPrint('Rejected ' +language+ ' flags -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64')\n      self.popLanguage()\n    return\n\n  def getArchiverFlags(self, archiver):\n    prog = os.path.basename(archiver).split(' ')[0]\n    flag = ''\n    if 'AR_FLAGS' in self.argDB:\n      flag = self.argDB['AR_FLAGS']\n    elif prog.endswith('ar'):\n      flag = 'cr'\n    elif prog == 'win32fe':\n      args = os.path.basename(archiver).split(' ')\n      if 'lib' in args:\n        flag = '-a'\n      elif 'tlib' in args:\n        flag = '-a -P512'\n    if prog.endswith('ar') and not (self.isSolarisAR(prog, self.log) or self.isAIXAR(prog, self.log)):\n      self.FAST_AR_FLAGS = 'Scq'\n    else:\n      self.FAST_AR_FLAGS = flag\n    self.framework.addMakeMacro('FAST_AR_FLAGS',self.FAST_AR_FLAGS )\n    return flag\n\n  def generateArchiverGuesses(self):\n    defaultAr = None\n    if 'with-ar' in self.argDB:\n      if self.isWindows(self.argDB['with-ar'], self.log):\n        defaultAr = 'win32fe '+self.argDB['with-ar']\n      else:\n        defaultAr = self.argDB['with-ar']\n    envAr = None\n    if 'AR' in self.argDB:\n      if self.isWindows(self.argDB['AR'], self.log):\n        envAr = 'win32fe '+self.argDB['AR']\n      else:\n        envAr = self.argDB['AR']\n    defaultRanlib = None\n    if 'with-ranlib' in self.argDB:\n      defaultRanlib = self.argDB['with-ranlib']\n    envRanlib = None\n    if 'RANLIB' in self.argDB:\n      envRanlib = self.argDB['RANLIB']\n    if defaultAr and defaultRanlib:\n      yield(defaultAr,self.getArchiverFlags(defaultAr),defaultRanlib)\n      raise RuntimeError('The archiver set --with-ar=\"'+defaultAr+'\" is incompatible with the ranlib set --with-ranlib=\"'+defaultRanlib+'\".')\n    if defaultAr and envRanlib:\n      yield(defaultAr,self.getArchiverFlags(defaultAr),envRanlib)\n      raise RuntimeError('The archiver set --with-ar=\"'+defaultAr+'\" is incompatible with the ranlib set (perhaps in your environment) -RANLIB=\"'+envRanlib+'\".')\n    if envAr and defaultRanlib:\n      yield(envAr,self.getArchiverFlags(envAr),defaultRanlib)\n      raise RuntimeError('The archiver set --AR=\"'+envAr+'\" is incompatible with the ranlib set --with-ranlib=\"'+defaultRanlib+'\".')\n    if envAr and envRanlib:\n      yield(envAr,self.getArchiverFlags(envAr),envRanlib)\n      raise RuntimeError('The archiver set --AR=\"'+envAr+'\" is incompatible with the ranlib set (perhaps in your environment) -RANLIB=\"'+envRanlib+'\".')\n    if defaultAr:\n      yield (defaultAr,self.getArchiverFlags(defaultAr),'ranlib')\n      yield (defaultAr,self.getArchiverFlags(defaultAr),'true')\n      raise RuntimeError('You set a value for --with-ar='+defaultAr+'\", but '+defaultAr+' cannot be used\\n')\n    if envAr:\n      yield (envAr,self.getArchiverFlags(envAr),'ranlib')\n      yield (envAr,self.getArchiverFlags(envAr),'true')\n      raise RuntimeError('You set a value for -AR=\"'+envAr+'\" (perhaps in your environment), but '+envAr+' cannot be used\\n')\n    if defaultRanlib:\n      yield ('ar',self.getArchiverFlags('ar'),defaultRanlib)\n      yield ('win32fe tlib',self.getArchiverFlags('win32fe tlib'),defaultRanlib)\n      yield ('win32fe lib',self.getArchiverFlags('win32fe lib'),defaultRanlib)\n      raise RuntimeError('You set --with-ranlib=\"'+defaultRanlib+'\", but '+defaultRanlib+' cannot be used\\n')\n    if envRanlib:\n      yield ('ar',self.getArchiverFlags('ar'),envRanlib)\n      yield ('win32fe tlib',self.getArchiverFlags('win32fe tlib'),envRanlib)\n      yield ('win32fe lib',self.getArchiverFlags('win32fe lib'),envRanlib)\n      raise RuntimeError('You set -RANLIB=\"'+envRanlib+'\" (perhaps in your environment), but '+defaultRanlib+' cannot be used\\n')\n    yield ('ar',self.getArchiverFlags('ar'),'ranlib -c')\n    yield ('ar',self.getArchiverFlags('ar'),'ranlib')\n    yield ('ar',self.getArchiverFlags('ar'),'true')\n    # IBM with 64 bit pointers\n    yield ('ar','-X64 '+self.getArchiverFlags('ar'),'ranlib -c')\n    yield ('ar','-X64 '+self.getArchiverFlags('ar'),'ranlib')\n    yield ('ar','-X64 '+self.getArchiverFlags('ar'),'true')\n    yield ('win32fe tlib',self.getArchiverFlags('win32fe tlib'),'true')\n    yield ('win32fe lib',self.getArchiverFlags('win32fe lib'),'true')\n    return\n\n  def checkArchiver(self):\n    '''Check that the archiver exists and can make a library usable by the compiler'''\n    objName    = os.path.join(self.tmpDir, 'conf1.o')\n    arcUnix    = os.path.join(self.tmpDir, 'libconf1.a')\n    arcWindows = os.path.join(self.tmpDir, 'libconf1.lib')\n    def checkArchive(command, status, output, error):\n      if error or status:\n        self.logError('archiver', status, output, error)\n        if os.path.isfile(objName):\n          os.remove(objName)\n        raise RuntimeError('Archiver is not functional')\n      return\n    def checkRanlib(command, status, output, error):\n      if error or status:\n        self.logError('ranlib', status, output, error)\n        if os.path.isfile(arcUnix):\n          os.remove(arcUnix)\n        raise RuntimeError('Ranlib is not functional with your archiver.  Try --with-ranlib=true if ranlib is unnecessary.')\n      return\n    oldLibs = self.LIBS\n    self.pushLanguage('C')\n    for (archiver, arflags, ranlib) in self.generateArchiverGuesses():\n      if not self.checkCompile('', 'int foo(int a) {\\n  return a+1;\\n}\\n\\n', cleanup = 0, codeBegin = '', codeEnd = ''):\n        raise RuntimeError('Compiler is not functional')\n      if os.path.isfile(objName):\n        os.remove(objName)\n      os.rename(self.compilerObj, objName)\n      if self.getExecutable(archiver, getFullPath = 1, resultName = 'AR'):\n        if self.getExecutable(ranlib, getFullPath = 1, resultName = 'RANLIB'):\n          arext = 'a'\n          try:\n            (output, error, status) = config.base.Configure.executeShellCommand(self.AR+' '+arflags+' '+arcUnix+' '+objName, checkCommand = checkArchive, log = self.log)\n            (output, error, status) = config.base.Configure.executeShellCommand(self.RANLIB+' '+arcUnix, checkCommand = checkRanlib, log = self.log)\n          except RuntimeError as e:\n            self.logPrint(str(e))\n            continue\n          self.LIBS = '-L'+self.tmpDir+' -lconf1 ' + oldLibs\n          success =  self.checkLink('extern int foo(int);', '  int b = foo(1);  if (b);\\n')\n          os.rename(arcUnix, arcWindows)\n          if not success:\n            arext = 'lib'\n            success = self.checkLink('extern int foo(int);', '  int b = foo(1);  if (b);\\n')\n            os.remove(arcWindows)\n            if success:\n              break\n          else:\n            os.remove(arcWindows)\n            break\n    else:\n      if os.path.isfile(objName):\n        os.remove(objName)\n      self.LIBS = oldLibs\n      self.popLanguage()\n      raise RuntimeError('Could not find a suitable archiver.  Use --with-ar to specify an archiver.')\n    self.AR_FLAGS      = arflags\n    self.AR_LIB_SUFFIX = arext\n    self.framework.addMakeMacro('AR_FLAGS', self.AR_FLAGS)\n    self.addMakeMacro('AR_LIB_SUFFIX', self.AR_LIB_SUFFIX)\n    os.remove(objName)\n    self.LIBS = oldLibs\n    self.popLanguage()\n    return\n\n  def setStaticLinker(self):\n    language = self.language[-1]\n    return self.framework.setSharedLinkerObject(language, self.framework.getLanguageModule(language).StaticLinker(self.argDB))\n\n  def generateSharedLinkerGuesses(self):\n    if not self.argDB['with-shared-libraries']:\n      self.setStaticLinker()\n      self.staticLinker = self.AR\n      self.staticLibraries = 1\n      self.LDFLAGS = ''\n      yield (self.AR, [], self.AR_LIB_SUFFIX)\n      raise RuntimeError('Archiver failed static link check')\n    if 'with-shared-ld' in self.argDB:\n      yield (self.argDB['with-shared-ld'], [], 'so')\n    if 'LD_SHARED' in self.argDB:\n      yield (self.argDB['LD_SHARED'], [], 'so')\n    if Configure.isDarwin(self.log):\n      if 'with-shared-ld' in self.argDB:\n        yield (self.argDB['with-dynamic-ld'], ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], '-no_compact_unwind', 'dylib')\n      if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n        yield (self.CXX, ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress', '-no_compact_unwind'], 'dylib')\n      yield (self.CC, ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress', '-no_compact_unwind'], 'dylib')\n    if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n      # C++ compiler default\n      yield (self.CXX, ['-shared'], 'so')\n      yield (self.CXX, ['-dynamic'], 'so')\n    # C compiler default\n    yield (self.CC, ['-shared'], 'so')\n    yield (self.CC, ['-dynamic'], 'so')\n    yield (self.CC, ['-qmkshrobj'], 'so')\n    yield (self.CC, ['-shared'], 'dll')\n    # Windows default\n    if self.CC.find('win32fe') >=0:\n      if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n        yield (self.CXX, ['-LD'], 'dll')\n      yield (self.CC, ['-LD'], 'dll')\n    # Solaris default\n    if Configure.isSolaris(self.log):\n      if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n        yield (self.CXX, ['-G'], 'so')\n      yield (self.CC, ['-G'], 'so')\n    # If user does not explicitly enable shared-libraries - disable shared libraries and default to static linker\n    if not 'with-shared-libraries' in self.framework.clArgDB:\n      self.argDB['with-shared-libraries'] = 0\n      self.setStaticLinker()\n      self.staticLinker = self.AR\n      self.staticLibraries = 1\n      self.LDFLAGS = ''\n      yield (self.AR, [], self.AR_LIB_SUFFIX)\n    raise RuntimeError('Exhausted all shared linker guesses. Could not determine how to create a shared library!')\n\n  def checkSharedLinker(self):\n    '''Check that the linker can produce shared libraries'''\n    self.sharedLibraries = 0\n    self.staticLibraries = 0\n    for linker, flags, ext in self.generateSharedLinkerGuesses():\n      self.logPrint('Checking shared linker '+linker+' using flags '+str(flags))\n      if self.getExecutable(linker, resultName = 'LD_SHARED'):\n        for picFlag in self.generatePICGuesses():\n          self.logPrint('Trying '+self.language[-1]+' compiler flag '+picFlag)\n          compilerFlagsArg = self.getCompilerFlagsArg(1) # compiler only\n          oldCompilerFlags = getattr(self, compilerFlagsArg)\n          accepted = 1\n          try:\n            self.addCompilerFlag(picFlag,compilerOnly=1)\n          except RuntimeError:\n            accepted = 0\n          if accepted:\n            goodFlags = filter(self.checkLinkerFlag, flags)\n            self.sharedLinker = self.LD_SHARED\n            self.sharedLibraryFlags = goodFlags\n            self.sharedLibraryExt = ext\n            if ext == 'dll':\n              dllexport = '__declspec(dllexport) '\n              dllimport = '__declspec(dllimport) '\n            else:\n              dllexport = ''\n              dllimport = ''\n            # using printf appears to correctly identify non-pic code on X86_64\n            if self.checkLink(includes = _picTestIncludes(dllexport), codeBegin = '', codeEnd = '', cleanup = 0, shared = 1):\n              oldLib  = self.linkerObj\n              oldLibs = self.LIBS\n              self.LIBS += ' -L'+self.tmpDir+' -lconftest'\n              accepted = self.checkLink(includes = dllimport+'int foo(void);', body = 'int ret = foo();\\nif (ret) {}\\n')\n              os.remove(oldLib)\n              self.LIBS = oldLibs\n              if accepted:\n                self.sharedLibraries = 1\n                self.logPrint('Using shared linker '+self.sharedLinker+' with flags '+str(self.sharedLibraryFlags)+' and library extension '+self.sharedLibraryExt)\n                break\n          self.logPrint('Rejected '+self.language[-1]+' compiler flag '+picFlag+' because it was not compatible with shared linker '+linker+' using flags '+str(flags))\n          setattr(self, compilerFlagsArg, oldCompilerFlags)\n        if os.path.isfile(self.linkerObj): os.remove(self.linkerObj)\n        if self.sharedLibraries: break\n        self.delMakeMacro('LD_SHARED')\n        del self.LD_SHARED\n        del self.sharedLinker\n    return\n\n  def checkLinkerFlag(self, flag):\n    '''Determine whether the linker accepts the given flag'''\n    flagsArg = self.getLinkerFlagsArg()\n    oldFlags = getattr(self, flagsArg)\n    setattr(self, flagsArg, oldFlags+' '+flag)\n    (output, status) = self.outputLink('', '')\n    valid = 1\n    if status:\n      valid = 0\n      self.logPrint('Rejecting linker flag '+flag+' due to nonzero status from link')\n    if self.containsInvalidFlag(output):\n      valid = 0\n      self.logPrint('Rejecting '+self.language[-1]+' linker flag '+flag+' due to \\n'+output)\n    if valid:\n      self.logPrint('Valid '+self.language[-1]+' linker flag '+flag)\n    setattr(self, flagsArg, oldFlags)\n    return valid\n\n  def addLinkerFlag(self, flag):\n    '''Determine whether the linker accepts the given flag, and add it if valid, otherwise throw an exception'''\n    if self.checkLinkerFlag(flag):\n      flagsArg = self.getLinkerFlagsArg()\n      setattr(self, flagsArg, getattr(self, flagsArg)+' '+flag)\n      return\n    raise RuntimeError('Bad linker flag: '+flag)\n\n  def checkLinkerMac(self):\n    '''Tests some Apple Mac specific linker flags'''\n    langMap = {'C':'CC','FC':'FC','Cxx':'CXX','CUDA':'CUDAC'}\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    if hasattr(self, 'FC'):\n      languages.append('FC')\n    for language in languages:\n      self.pushLanguage(language)\n      for testFlag in ['-Wl,-multiply_defined,suppress', '-Wl,-multiply_defined -Wl,suppress', '-Wl,-commons,use_dylibs', '-Wl,-search_paths_first', '-Wl,-no_compact_unwind']:\n        if self.checkLinkerFlag(testFlag):\n          # expand to CC_LINKER_FLAGS or CXX_LINKER_FLAGS or FC_LINKER_FLAGS\n\t  linker_flag_var = langMap[language]+'_LINKER_FLAGS'\n          val = getattr(self,linker_flag_var)\n\t  val.append(testFlag)\n\t  setattr(self,linker_flag_var,val)\n      self.popLanguage()\n    return\n\n  def checkSharedLinkerPaths(self):\n    '''Determine the shared linker path options\n       - IRIX: -rpath\n       - Linux, OSF: -Wl,-rpath,\n       - Solaris: -R\n       - FreeBSD: -Wl,-R,'''\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    if hasattr(self, 'FC'):\n      languages.append('FC')\n    if hasattr(self, 'CUDAC'):\n      languages.append('CUDA')\n    for language in languages:\n      flag = '-L'\n      self.pushLanguage(language)\n      # test '-R' before '-rpath' as sun compilers [c,fortran] don't give proper errors with wrong options.\n      if not Configure.isDarwin(self.log):\n        testFlags = ['-Wl,-rpath,', '-R','-rpath ' , '-Wl,-R,']\n      else:\n        testFlags = ['-Wl,-rpath,']\n      # test '-R' before '-Wl,-rpath' for SUN compilers [as cc on linux accepts -Wl,-rpath, but  f90 & CC do not.\n      if self.isSun(self.framework.getCompiler(), self.log):\n        testFlags.insert(0,'-R')\n      for testFlag in testFlags:\n        self.logPrint('Trying '+language+' linker flag '+testFlag)\n        if self.checkLinkerFlag(testFlag+os.path.abspath(os.getcwd())):\n          flag = testFlag\n          break\n        else:\n          self.logPrint('Rejected '+language+' linker flag '+testFlag)\n      self.popLanguage()\n      setattr(self, language+'SharedLinkerFlag', flag)\n    return\n\n  def checkLibC(self):\n    '''Test whether we need to explicitly include libc in shared linking\n       - Mac OSX requires an explicit reference to libc for shared linking'''\n    self.explicitLibc = None\n    if self.staticLibraries:\n      return\n    tmpCompilerDefines   = self.compilerDefines\n    self.compilerDefines = ''\n    code = '#include <stdlib.h> \\nint foo(void) {void *chunk = malloc(31); free(chunk); return 0;}\\n'\n    if self.checkLink(includes = code, codeBegin = '', codeEnd = '', shared = 1):\n      self.logPrint('Shared linking does not require an explicit libc reference')\n      self.compilerDefines = tmpCompilerDefines\n      return\n    oldLibs = self.LIBS\n    self.LIBS += '-lc '\n    if self.checkLink(includes = code, codeBegin = '', codeEnd = '', shared = 1):\n      self.logPrint('Shared linking requires an explicit libc reference')\n      self.compilerDefines = tmpCompilerDefines\n      self.explicitLibc = ['libc.so']\n      return\n    self.LIBS = oldLibs\n    self.compilerDefines = tmpCompilerDefines\n    self.logPrint('*** WARNING *** Shared linking may not function on this architecture')\n    self.staticLibrary=1\n    self.sharedLibrary=0\n\n  def generateDynamicLinkerGuesses(self):\n    if 'with-dynamic-ld' in self.argDB:\n      yield (self.argDB['with-dynamic-ld'], [], 'so')\n    # Mac OSX\n    if Configure.isDarwin(self.log):\n      if 'with-dynamic-ld' in self.argDB:\n        yield (self.argDB['with-dynamic-ld'], ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], 'dylib')\n      #yield ('libtool', ['-noprebind','-dynamic','-single_module','-flat_namespace -undefined warning','-multiply_defined suppress'], 'dylib')\n      if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n#        yield (\"g++\", ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], 'dylib')\n        yield (self.CXX, ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], 'dylib')\n#      yield (\"gcc\", ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], 'dylib')\n      yield (self.CC, ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], 'dylib')\n    # Shared default\n    if hasattr(self, 'sharedLinker'):\n      yield (self.sharedLinker, self.sharedLibraryFlags, 'so')\n    # C++ Compiler default\n    if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n      yield (self.CXX, ['-shared'], 'so')\n    # C Compiler default\n    yield (self.CC, ['-shared'], 'so')\n    self.logPrint('Unable to find working dynamic linker')\n\n  def checkDynamicLinker(self):\n    '''Check that the linker can dynamicaly load shared libraries'''\n    self.dynamicLibraries = 0\n    self.headers.saveLog()\n    if not self.headers.check('dlfcn.h'):\n      self.logWrite(self.headers.restoreLog())\n      self.logPrint('Dynamic loading disabled since dlfcn.h was missing')\n      return\n    self.logWrite(self.headers.restoreLog())\n    self.libraries.saveLog()\n    if not self.libraries.add('dl', ['dlopen', 'dlsym', 'dlclose']):\n      if not self.libraries.check('', ['dlopen', 'dlsym', 'dlclose']):\n        self.logWrite(self.libraries.restoreLog())\n        self.logPrint('Dynamic linking disabled since functions dlopen(), dlsym(), and dlclose() were not found')\n        return\n    self.logWrite(self.libraries.restoreLog())\n    for linker, flags, ext in self.generateDynamicLinkerGuesses():\n      self.logPrint('Checking dynamic linker '+linker+' using flags '+str(flags))\n      if self.getExecutable(linker, resultName = 'dynamicLinker'):\n        flagsArg = self.getLinkerFlagsArg()\n        goodFlags = filter(self.checkLinkerFlag, flags)\n        self.dynamicLibraryFlags = goodFlags\n        self.dynamicLibraryExt = ext\n        testMethod = 'foo'\n        if self.checkLink(includes = '#include <stdio.h>\\nint '+testMethod+'(void) {printf(\"test\");return 0;}\\n', codeBegin = '', codeEnd = '', cleanup = 0, shared = 'dynamic'):\n          oldLib  = self.linkerObj\n          code = '''\nvoid *handle = dlopen(\"%s\", 0);\nint (*foo)(void) = (int (*)(void)) dlsym(handle, \"foo\");\n\nif (!foo) {\n  printf(\"Could not load symbol\\\\n\");\n  return -1;\n}\nif ((*foo)()) {\n  printf(\"Invalid return from foo()\\\\n\");\n  return -1;\n}\nif (dlclose(handle)) {\n  printf(\"Could not close library\\\\n\");\n  return -1;\n}\n''' % oldLib\n          if self.checkLink(includes = '#include<dlfcn.h>', body = code):\n            os.remove(oldLib)\n            self.dynamicLibraries = 1\n            self.logPrint('Using dynamic linker '+self.dynamicLinker+' with flags '+str(self.dynamicLibraryFlags)+' and library extension '+self.dynamicLibraryExt)\n            break\n        if os.path.isfile(self.linkerObj): os.remove(self.linkerObj)\n        del self.dynamicLinker\n    return\n\n  def output(self):\n    '''Output module data as defines and substitutions'''\n    if hasattr(self, 'CC'):\n      self.addSubstitution('CC', self.CC)\n      self.addSubstitution('CFLAGS', self.CFLAGS)\n      self.addMakeMacro('CC_LINKER_SLFLAG', self.CSharedLinkerFlag)\n    if hasattr(self, 'CPP'):\n      self.addSubstitution('CPP', self.CPP)\n      self.addSubstitution('CPPFLAGS', self.CPPFLAGS)\n    if hasattr(self, 'CUDAC'):\n      self.addSubstitution('CUDAC', self.CUDAC)\n      self.addSubstitution('CUDAFLAGS', self.CUDAFLAGS)\n    if hasattr(self, 'CUDAPP'):\n      self.addSubstitution('CUDAPP', self.CUDAPP)\n      self.addSubstitution('CUDAPPFLAGS', self.CUDAPPFLAGS)\n    if hasattr(self, 'CXX'):\n      self.addSubstitution('CXX', self.CXX)\n      self.addSubstitution('CXX_CXXFLAGS', self.CXX_CXXFLAGS)\n      self.addSubstitution('CXXFLAGS', self.CXXFLAGS)\n      self.addSubstitution('CXX_LINKER_SLFLAG', self.CxxSharedLinkerFlag)\n    else:\n      self.addSubstitution('CXX', '')\n    if hasattr(self, 'CXXCPP'):\n      self.addSubstitution('CXXCPP', self.CXXCPP)\n      self.addSubstitution('CXXCPPFLAGS', self.CXXCPPFLAGS)\n    if hasattr(self, 'FC'):\n      self.addSubstitution('FC', self.FC)\n      self.addSubstitution('FFLAGS', self.FFLAGS)\n      self.addMakeMacro('FC_LINKER_SLFLAG', self.FCSharedLinkerFlag)\n    else:\n      self.addSubstitution('FC', '')\n    self.addSubstitution('LDFLAGS', self.LDFLAGS)\n    self.addSubstitution('LIBS', self.LIBS)\n    if hasattr(self, 'sharedLibraryFlags'):\n      self.addSubstitution('SHARED_LIBRARY_FLAG', ' '.join(self.sharedLibraryFlags))\n    else:\n      self.addSubstitution('SHARED_LIBRARY_FLAG','')\n    return\n\n  def updateMPICompilers(self, mpicc, mpicxx, mpifc):\n    '''Reset compilers by an external module aka MPI'''\n    self.CC = mpicc\n    self.delMakeMacro(\"CC\")\n\n    if hasattr(self, 'CXX'):\n      self.CXX = mpicxx\n      self.delMakeMacro(\"CXX\")\n\n    if hasattr(self, 'FC'):\n      self.FC = mpifc\n      self.delMakeMacro(\"FC\")\n\n    self.configure()\n    self.usedMPICompilers=1\n    return\n\n  def checkMPICompilerOverride(self):\n    '''Check if --with-mpi-dir is used along with CC CXX or FC compiler options.\n    This usually prevents mpi compilers from being used - so issue a warning'''\n\n    if 'with-mpi-dir' in self.argDB and self.argDB['with-mpi-compilers']:\n      optcplrs = [(['with-cc','CC'],['mpicc','mpcc','hcc','mpcc_r']),\n              (['with-fc','FC'],['mpif90','mpif77','mpxlf95_r','mpxlf90_r','mpxlf_r','mpf90','mpf77']),\n              (['with-cxx','CXX'],['mpicxx','hcp','mpic++','mpiCC','mpCC_r'])]\n      for opts,cplrs in optcplrs:\n        for opt in opts:\n          if (opt in self.argDB  and self.argDB[opt] != '0'):\n            # check if corresponding mpi wrapper exists\n            for cplr in cplrs:\n              mpicplr = os.path.join(self.argDB['with-mpi-dir'], 'bin', cplr)\n              if os.path.exists(mpicplr):\n                msg = '--'+opt+'='+self.argDB[opt]+' is specified with --with-mpi-dir='+self.argDB['with-mpi-dir']+'. However '+mpicplr+' exists and should be the preferred compiler! Suggest not specifying --'+opt+' option so that configure can use '+ mpicplr +' instead.'\n                raise RuntimeError(msg)\n    return\n\n  def requireMpiLdPath(self):\n    '''OpenMPI wrappers require LD_LIBRARY_PATH set'''\n    if 'with-mpi-dir' in self.argDB:\n      libdir = os.path.join(self.argDB['with-mpi-dir'], 'lib')\n      if os.path.exists(os.path.join(libdir,'libopen-rte.so')):\n        Configure.addLdPath(libdir)\n        self.logPrint('Adding to LD_LIBRARY_PATH '+libdir)\n    return\n\n  def printEnvVariables(self):\n    buf = '**** printenv ****'\n    for key,val in os.environ.iteritems():\n      buf += '\\n'+str(key)+'='+str(val)\n    self.logPrint(buf)\n    return\n\n  def resetEnvCompilers(self):\n    ignoreEnvCompilers = ['CC','CXX','FC','F77','F90']\n    for envVal in ignoreEnvCompilers:\n      if envVal in os.environ:\n        if envVal in self.framework.clArgDB or 'with-'+envVal.lower() in self.framework.clArgDB:\n          self.logPrint(envVal+' (set to '+os.environ[envVal]+') found in environment variables - ignoring since also set on command line')\n          del os.environ[envVal]\n        elif self.argDB['with-environment-variables']:\n          self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - using it \\n use ./configure --disable-environment-variables to NOT use the environmental variables ******')\n        elif self.framework.argDB['with-xsdk-defaults'] and 'with-environment-variables' not in self.framework.clArgDB:\n          self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - using it \\n because --with-xsdk-defaults was selected. Add --disable-environment-variables \\n to NOT use the environmental variables ******')\n\n        else:\n          self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - ignoring \\n use ./configure '+envVal+'=$'+envVal+' if you really want to use that value ******')\n          del os.environ[envVal]\n\n    ignoreEnv = ['CFLAGS','CXXFLAGS','FCFLAGS','FFLAGS','F90FLAGS','CPP','CPPFLAGS','CXXCPP','CXXCPPFLAGS','LDFLAGS','LIBS','MPI_DIR','RM','MAKEFLAGS','AR']\n    for envVal in ignoreEnv:\n      if envVal in os.environ:\n        if envVal in self.framework.clArgDB:\n          self.logPrint(envVal+' (set to '+os.environ[envVal]+') found in environment variables - ignoring since also set on command line')\n          del os.environ[envVal]\n        elif self.argDB['with-environment-variables']:\n          self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - using it \\n use ./configure --disable-environment-variables to NOT use the environmental variables******')\n        else:\n          self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - ignoring \\n use ./configure '+envVal+'=$'+envVal+' if you really want to use that value ******')\n          del os.environ[envVal]\n    return\n\n\n  def checkEnvCompilers(self):\n    if 'with-environment-variables' in self.framework.clArgDB or 'with-xsdk-defaults' in self.framework.clArgDB:\n      envVarChecklist = ['CC','CFLAGS','CXX','CXXFLAGS','FC','FCFLAGS','F77','FFLAGS','F90','F90FLAGS','CPP','CPPFLAGS','CXXCPP','CXXCPPFLAGS','LDFLAGS','LIBS','MPI_DIR','RM','MAKEFLAGS','AR']\n      for ev in envVarChecklist:\n        if ev in os.environ:\n          self.argDB[ev] = os.environ[ev]\n\n    # abort if FCFLAGS and FFLAGS both set, but to different values\n    if 'FFLAGS' in self.argDB and 'FCFLAGS' in self.argDB:\n      if self.argDB['FCFLAGS'] != self.argDB['FFLAGS']:\n        raise RuntimeError('FCFLAGS and FFLAGS are both set, but with different values (FCFLAGS=%s, FFLAGS=%s)'%(self.argDB['FCFLAGS'],self.argDB['FFLAGS']))\n    return\n\n  def checkIntoShared(self,symbol,lib):\n    '''Check that a given library can be linked into a shared library'''\n    import sys\n    if not self.checkCompile(includes = 'char *'+symbol+'(void);\\n',body = 'return '+symbol+'();\\n', cleanup = 0, codeBegin = 'char* testroutine(void){', codeEnd = '}'):\n      raise RuntimeError('Unable to compile test file with symbol: '+symbol)\n    oldLibs = self.LIBS\n    self.LIBS = self.libraries.toStringNoDupes(lib) + ' '+self.LIBS\n    ret = self.checkLink(includes = 'char *'+symbol+'(void);\\n',body = 'return '+symbol+'();\\n', cleanup = 0, codeBegin = 'char* testroutine(void){', codeEnd = '}',shared =1)\n    self.LIBS = oldLibs\n    return ret\n\n  def configure(self):\n    self.executeTest(self.printEnvVariables)\n    self.executeTest(self.resetEnvCompilers)\n    self.executeTest(self.checkEnvCompilers)\n    self.executeTest(self.checkMPICompilerOverride)\n    self.executeTest(self.requireMpiLdPath)\n    self.executeTest(self.checkVendor)\n    self.executeTest(self.checkInitialFlags)\n    self.executeTest(self.checkCCompiler)\n    self.executeTest(self.checkCPreprocessor)\n    self.executeTest(self.checkCUDACompiler)\n    self.executeTest(self.checkCUDAPreprocessor)\n    self.executeTest(self.checkCxxCompiler)\n    if hasattr(self, 'CXX'):\n      self.executeTest(self.checkCxxPreprocessor)\n    self.executeTest(self.checkFortranCompiler)\n    if hasattr(self, 'FC'):\n      self.executeTest(self.checkFortranComments)\n    self.executeTest(self.checkLargeFileIO)\n    self.executeTest(self.checkArchiver)\n    self.executeTest(self.checkSharedLinker)\n    if Configure.isDarwin(self.log):\n      self.executeTest(self.checkLinkerMac)\n    self.executeTest(self.checkPIC)\n    self.executeTest(self.checkSharedLinkerPaths)\n    self.executeTest(self.checkLibC)\n    self.executeTest(self.checkDynamicLinker)\n    self.executeTest(self.output)\n    return\n\n  def no_configure(self):\n    if self.staticLibraries:\n      self.setStaticLinker()\n    return\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/src/sys/dll/dlimpl.c.html": "<center><a href=\"dlimpl.c\">Actual source code: dlimpl.c</a></center><br>\n\n<html>\n<head> <link rel=\"canonical\" href=\"http://www.mcs.anl.gov/petsc/petsc-current/src/sys/dll/dlimpl.c.html\" />\n<title></title>\n<meta name=\"generator\" content=\"c2html 0.9.4\">\n<meta name=\"date\" content=\"2018-09-12T13:30:02+00:00\">\n</head>\n\n<body bgcolor=\"#FFFFFF\">\n   <div id=\"version\" align=right><b>petsc-3.10.0 2018-09-12</b></div>\n   <div id=\"bugreport\" align=right><a href=\"mailto:petsc-maint@mcs.anl.gov?subject=Typo or Error in Documentation &body=Please describe the typo or error in the documentation: petsc-3.10.0 v3.10 src/sys/dll/dlimpl.c.html \"><small>Report Typos and Errors</small></a></div>\n<pre width=\"80\">\n\n<a name=\"line2\">  2: </a><font color=\"#B22222\">/*</font>\n<a name=\"line3\">  3: </a><font color=\"#B22222\">   Low-level routines for managing dynamic link libraries (DLLs).</font>\n<a name=\"line4\">  4: </a><font color=\"#B22222\">*/</font>\n\n<a name=\"line6\">  6: </a> #include <A href=\"../../../include/petsc/private/petscimpl.h.html\">&lt;petsc/private/petscimpl.h&gt;</A>\n<a name=\"line7\">  7: </a> #include <A href=\"../../../include/petscvalgrind.h.html\">&lt;petscvalgrind.h&gt;</A>\n\n<a name=\"line9\">  9: </a><font color=\"#B22222\">/* XXX Should be done better !!!*/</font>\n<a name=\"line10\"> 10: </a><font color=\"#A020F0\">#if !defined(PETSC_HAVE_DYNAMIC_LIBRARIES)</font>\n<a name=\"line11\"> 11: </a><strong><font color=\"#228B22\">#undef PETSC_HAVE_WINDOWS_H</font></strong>\n<a name=\"line12\"> 12: </a><strong><font color=\"#228B22\">#undef PETSC_HAVE_DLFCN_H</font></strong>\n<a name=\"line13\"> 13: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line15\"> 15: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_WINDOWS_H)</font>\n<a name=\"line16\"> 16: </a><font color=\"#A020F0\">#include &lt;windows.h&gt;</font>\n<a name=\"line17\"> 17: </a><font color=\"#A020F0\">#elif defined(PETSC_HAVE_DLFCN_H)</font>\n<a name=\"line18\"> 18: </a><font color=\"#A020F0\">#include &lt;dlfcn.h&gt;</font>\n<a name=\"line19\"> 19: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line21\"> 21: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_WINDOWS_H)</font>\n<a name=\"line22\"> 22: </a><font color=\"#4169E1\">typedef HMODULE dlhandle_t;</font>\n<a name=\"line23\"> 23: </a><font color=\"#4169E1\">typedef FARPROC dlsymbol_t;</font>\n<a name=\"line24\"> 24: </a><font color=\"#A020F0\">#elif defined(PETSC_HAVE_DLFCN_H)</font>\n<a name=\"line25\"> 25: </a><font color=\"#4169E1\">typedef void* dlhandle_t;</font>\n<a name=\"line26\"> 26: </a><font color=\"#4169E1\">typedef void* dlsymbol_t;</font>\n<a name=\"line27\"> 27: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line28\"> 28: </a><font color=\"#4169E1\">typedef void* dlhandle_t;</font>\n<a name=\"line29\"> 29: </a><font color=\"#4169E1\">typedef void* dlsymbol_t;</font>\n<a name=\"line30\"> 30: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line32\"> 32: </a><font color=\"#B22222\">/*@C</font>\n<a name=\"line33\"> 33: </a><font color=\"#B22222\">   <a href=\"../../../docs/manualpages/Sys/PetscDLOpen.html#PetscDLOpen\">PetscDLOpen</a> - opens dynamic library</font>\n\n<a name=\"line35\"> 35: </a><font color=\"#B22222\">   Not Collective</font>\n\n<a name=\"line37\"> 37: </a><font color=\"#B22222\">   Input Parameters:</font>\n<a name=\"line38\"> 38: </a><font color=\"#B22222\">+    name - name of library</font>\n<a name=\"line39\"> 39: </a><font color=\"#B22222\">-    mode - options on how to open library</font>\n\n<a name=\"line41\"> 41: </a><font color=\"#B22222\">   Output Parameter:</font>\n<a name=\"line42\"> 42: </a><font color=\"#B22222\">.    handle</font>\n\n<a name=\"line44\"> 44: </a><font color=\"#B22222\">   Level: developer</font>\n\n<a name=\"line46\"> 46: </a><font color=\"#B22222\">@*/</font>\n<a name=\"line47\"> 47: </a><strong><font color=\"#4169E1\"><a name=\"PetscDLOpen\"></a><a href=\"../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a>  <a href=\"../../../docs/manualpages/Sys/PetscDLOpen.html#PetscDLOpen\">PetscDLOpen</a>(const char name[],PetscDLMode mode,PetscDLHandle *handle)</font></strong>\n<a name=\"line48\"> 48: </a>{\n<a name=\"line49\"> 49: </a>  PETSC_UNUSED int dlflags1,dlflags2; <font color=\"#B22222\">/* There are some preprocessor paths where these variables are set, but not used */</font>\n<a name=\"line50\"> 50: </a>  dlhandle_t       dlhandle;\n\n\n<a name=\"line56\"> 56: </a>  dlflags1 = 0;\n<a name=\"line57\"> 57: </a>  dlflags2 = 0;\n<a name=\"line58\"> 58: </a>  dlhandle = (dlhandle_t) 0;\n<a name=\"line59\"> 59: </a>  *handle  = (PetscDLHandle) 0;\n\n<a name=\"line61\"> 61: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line62\"> 62: </a><font color=\"#B22222\">     --- LoadLibrary ---</font>\n<a name=\"line63\"> 63: </a><font color=\"#B22222\">  */</font>\n<a name=\"line64\"> 64: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_WINDOWS_H) &amp;&amp; defined(PETSC_HAVE_LOADLIBRARY)</font>\n<a name=\"line65\"> 65: </a>  dlhandle = LoadLibrary(name);\n<a name=\"line66\"> 66: </a>  <font color=\"#4169E1\">if</font> (!dlhandle) {\n<a name=\"line67\"> 67: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_GETLASTERROR)</font>\n<a name=\"line69\"> 69: </a>    DWORD          erc;\n<a name=\"line70\"> 70: </a>    char           *buff = NULL;\n<a name=\"line71\"> 71: </a>    erc = GetLastError();\n<a name=\"line72\"> 72: </a>    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,\n<a name=\"line73\"> 73: </a>                  NULL,erc,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),(LPSTR)&amp;buff,0,NULL);\n<a name=\"line74\"> 74: </a>    <a href=\"../../../docs/manualpages/Sys/PetscError.html#PetscError\">PetscError</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>,__LINE__,PETSC_FUNCTION_NAME,__FILE__,PETSC_ERR_FILE_OPEN,<a href=\"../../../docs/manualpages/Sys/PetscErrorType.html#PetscErrorType\">PETSC_ERROR_REPEAT</a>,\n<a name=\"line75\"> 75: </a>                      <font color=\"#666666\">\"Unable to open dynamic library:\\n  %s\\n  Error message from LoadLibrary() %s\\n\"</font>,name,buff);\n<a name=\"line76\"> 76: </a>    LocalFree(buff);\n<a name=\"line77\"> 77: </a>    <a href=\"../../../docs/manualpages/Sys/PetscFunctionReturn.html#PetscFunctionReturn\">PetscFunctionReturn</a>(ierr);\n<a name=\"line78\"> 78: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line79\"> 79: </a>    <a href=\"../../../docs/manualpages/Sys/SETERRQ2.html#SETERRQ2\">SETERRQ2</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>,PETSC_ERR_FILE_OPEN,<font color=\"#666666\">\"Unable to open dynamic library:\\n  %s\\n  Error message from LoadLibrary() %s\\n\"</font>,name,<font color=\"#666666\">\"unavailable\"</font>);\n<a name=\"line80\"> 80: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line81\"> 81: </a>  }\n\n<a name=\"line83\"> 83: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line84\"> 84: </a><font color=\"#B22222\">     --- dlopen ---</font>\n<a name=\"line85\"> 85: </a><font color=\"#B22222\">  */</font>\n<a name=\"line86\"> 86: </a><font color=\"#A020F0\">#elif defined(PETSC_HAVE_DLFCN_H) &amp;&amp; defined(PETSC_HAVE_DLOPEN)</font>\n<a name=\"line87\"> 87: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line88\"> 88: </a><font color=\"#B22222\">      Mode indicates symbols required by symbol loaded with dlsym()</font>\n<a name=\"line89\"> 89: </a><font color=\"#B22222\">     are only loaded when required (not all together) also indicates</font>\n<a name=\"line90\"> 90: </a><font color=\"#B22222\">     symbols required can be contained in other libraries also opened</font>\n<a name=\"line91\"> 91: </a><font color=\"#B22222\">     with dlopen()</font>\n<a name=\"line92\"> 92: </a><font color=\"#B22222\">  */</font>\n<a name=\"line93\"> 93: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_LAZY)</font>\n<a name=\"line94\"> 94: </a>  dlflags1 = RTLD_LAZY;\n<a name=\"line95\"> 95: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line96\"> 96: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_NOW)</font>\n<a name=\"line97\"> 97: </a>  <font color=\"#4169E1\">if</font> (mode &amp; PETSC_DL_NOW) dlflags1 = RTLD_NOW;\n<a name=\"line98\"> 98: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line99\"> 99: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_GLOBAL)</font>\n<a name=\"line100\">100: </a>  dlflags2 = RTLD_GLOBAL;\n<a name=\"line101\">101: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line102\">102: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_LOCAL)</font>\n<a name=\"line103\">103: </a>  <font color=\"#4169E1\">if</font> (mode &amp; PETSC_DL_LOCAL) dlflags2 = RTLD_LOCAL;\n<a name=\"line104\">104: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line105\">105: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line106\">106: </a>  dlerror(); <font color=\"#B22222\">/* clear any previous error */</font>\n<a name=\"line107\">107: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line108\">108: </a>  dlhandle = dlopen(name,dlflags1|dlflags2);\n<a name=\"line109\">109: </a>  <font color=\"#4169E1\">if</font> (!dlhandle) {\n<a name=\"line110\">110: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line111\">111: </a>    const char *errmsg = dlerror();\n<a name=\"line112\">112: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line113\">113: </a>    const char *errmsg = <font color=\"#666666\">\"unavailable\"</font>;\n<a name=\"line114\">114: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line115\">115: </a>    <a href=\"../../../docs/manualpages/Sys/SETERRQ2.html#SETERRQ2\">SETERRQ2</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>,PETSC_ERR_FILE_OPEN,<font color=\"#666666\">\"Unable to open dynamic library:\\n  %s\\n  Error message from dlopen() %s\\n\"</font>,name,errmsg);\n<a name=\"line116\">116: </a>  }\n\n<a name=\"line118\">118: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line119\">119: </a><font color=\"#B22222\">     --- unimplemented ---</font>\n<a name=\"line120\">120: </a><font color=\"#B22222\">  */</font>\n<a name=\"line121\">121: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line122\">122: </a>  <a href=\"../../../docs/manualpages/Sys/SETERRQ.html#SETERRQ\">SETERRQ</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>,PETSC_ERR_SUP_SYS, <font color=\"#666666\">\"Cannot use dynamic libraries on this platform\"</font>);\n<a name=\"line123\">123: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line125\">125: </a>  *handle = (PetscDLHandle) dlhandle;\n<a name=\"line126\">126: </a>  <font color=\"#4169E1\">return</font>(0);\n<a name=\"line127\">127: </a>}\n\n\n<a name=\"line130\">130: </a><font color=\"#B22222\">/*@C</font>\n<a name=\"line131\">131: </a><font color=\"#B22222\">   <a href=\"../../../docs/manualpages/Sys/PetscDLClose.html#PetscDLClose\">PetscDLClose</a> -  closes a dynamic library</font>\n\n<a name=\"line133\">133: </a><font color=\"#B22222\">   Not Collective</font>\n\n<a name=\"line135\">135: </a><font color=\"#B22222\">  Input Parameter:</font>\n<a name=\"line136\">136: </a><font color=\"#B22222\">.   handle - the handle for the library obtained with <a href=\"../../../docs/manualpages/Sys/PetscDLOpen.html#PetscDLOpen\">PetscDLOpen</a>()</font>\n\n<a name=\"line138\">138: </a><font color=\"#B22222\">  Level: developer</font>\n<a name=\"line139\">139: </a><font color=\"#B22222\">@*/</font>\n<a name=\"line140\">140: </a><strong><font color=\"#4169E1\"><a name=\"PetscDLClose\"></a><a href=\"../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a>  <a href=\"../../../docs/manualpages/Sys/PetscDLClose.html#PetscDLClose\">PetscDLClose</a>(PetscDLHandle *handle)</font></strong>\n<a name=\"line141\">141: </a>{\n\n\n<a name=\"line146\">146: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line147\">147: </a><font color=\"#B22222\">     --- FreeLibrary ---</font>\n<a name=\"line148\">148: </a><font color=\"#B22222\">  */</font>\n<a name=\"line149\">149: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_WINDOWS_H)</font>\n<a name=\"line150\">150: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_FREELIBRARY)</font>\n<a name=\"line151\">151: </a>  <font color=\"#4169E1\">if</font> (FreeLibrary((dlhandle_t)*handle) == 0) {\n<a name=\"line152\">152: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_GETLASTERROR)</font>\n<a name=\"line153\">153: </a>    char  *buff = NULL;\n<a name=\"line154\">154: </a>    DWORD erc   = GetLastError();\n<a name=\"line155\">155: </a>    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,NULL,erc,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),(LPSTR)&amp;buff,0,NULL);\n<a name=\"line156\">156: </a>    <a href=\"../../../docs/manualpages/Sys/PetscErrorPrintf.html#PetscErrorPrintf\">PetscErrorPrintf</a>(<font color=\"#666666\">\"Error closing dynamic library:\\n  Error message from FreeLibrary() %s\\n\"</font>,buff);\n<a name=\"line157\">157: </a>    LocalFree(buff);\n<a name=\"line158\">158: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line159\">159: </a>    <a href=\"../../../docs/manualpages/Sys/PetscErrorPrintf.html#PetscErrorPrintf\">PetscErrorPrintf</a>(<font color=\"#666666\">\"Error closing dynamic library:\\n  Error message from FreeLibrary() %s\\n\"</font>,<font color=\"#666666\">\"unavailable\"</font>);\n<a name=\"line160\">160: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line161\">161: </a>  }\n<a name=\"line162\">162: </a><font color=\"#A020F0\">#endif </font><font color=\"#B22222\">/* !PETSC_HAVE_FREELIBRARY */</font><font color=\"#A020F0\"></font>\n\n<a name=\"line164\">164: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line165\">165: </a><font color=\"#B22222\">     --- dclose ---</font>\n<a name=\"line166\">166: </a><font color=\"#B22222\">  */</font>\n<a name=\"line167\">167: </a><font color=\"#A020F0\">#elif defined(PETSC_HAVE_DLFCN_H)</font>\n<a name=\"line168\">168: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLCLOSE)</font>\n<a name=\"line169\">169: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line170\">170: </a>  dlerror(); <font color=\"#B22222\">/* clear any previous error */</font>\n<a name=\"line171\">171: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line172\">172: </a>  <font color=\"#4169E1\">if</font> (dlclose((dlhandle_t)*handle) &lt; 0) {\n<a name=\"line173\">173: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line174\">174: </a>    const char *errmsg = dlerror();\n<a name=\"line175\">175: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line176\">176: </a>    const char *errmsg = <font color=\"#666666\">\"unavailable\"</font>;\n<a name=\"line177\">177: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line178\">178: </a>    <a href=\"../../../docs/manualpages/Sys/PetscErrorPrintf.html#PetscErrorPrintf\">PetscErrorPrintf</a>(<font color=\"#666666\">\"Error closing dynamic library:\\n  Error message from dlclose() %s\\n\"</font>, errmsg);\n<a name=\"line179\">179: </a>  }\n<a name=\"line180\">180: </a><font color=\"#A020F0\">#endif </font><font color=\"#B22222\">/* !PETSC_HAVE_DLCLOSE */</font><font color=\"#A020F0\"></font>\n\n<a name=\"line182\">182: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line183\">183: </a><font color=\"#B22222\">     --- unimplemented ---</font>\n<a name=\"line184\">184: </a><font color=\"#B22222\">  */</font>\n<a name=\"line185\">185: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line186\">186: </a>  <a href=\"../../../docs/manualpages/Sys/SETERRQ.html#SETERRQ\">SETERRQ</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>,PETSC_ERR_SUP_SYS, <font color=\"#666666\">\"Cannot use dynamic libraries on this platform\"</font>);\n<a name=\"line187\">187: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line189\">189: </a>  *handle = NULL;\n<a name=\"line190\">190: </a>  <font color=\"#4169E1\">return</font>(0);\n<a name=\"line191\">191: </a>}\n\n<a name=\"line193\">193: </a><font color=\"#B22222\">/*@C</font>\n<a name=\"line194\">194: </a><font color=\"#B22222\">   <a href=\"../../../docs/manualpages/Sys/PetscDLSym.html#PetscDLSym\">PetscDLSym</a> - finds a symbol in a dynamic library</font>\n\n<a name=\"line196\">196: </a><font color=\"#B22222\">   Not Collective</font>\n\n<a name=\"line198\">198: </a><font color=\"#B22222\">   Input Parameters:</font>\n<a name=\"line199\">199: </a><font color=\"#B22222\">+   handle - obtained with <a href=\"../../../docs/manualpages/Sys/PetscDLOpen.html#PetscDLOpen\">PetscDLOpen</a>() or NULL</font>\n<a name=\"line200\">200: </a><font color=\"#B22222\">-   symbol - name of symbol</font>\n\n<a name=\"line202\">202: </a><font color=\"#B22222\">   Output Parameter:</font>\n<a name=\"line203\">203: </a><font color=\"#B22222\">.   value - pointer to the function, NULL if not found</font>\n\n<a name=\"line205\">205: </a><font color=\"#B22222\">   Level: developer</font>\n\n<a name=\"line207\">207: </a><font color=\"#B22222\">  Notes:</font>\n<a name=\"line208\">208: </a><font color=\"#B22222\">   If handle is NULL, the symbol is looked for in the main executable's dynamic symbol table.</font>\n<a name=\"line209\">209: </a><font color=\"#B22222\">   In order to be dynamically loadable, the symbol has to be exported as such.  On many UNIX-like</font>\n<a name=\"line210\">210: </a><font color=\"#B22222\">   systems this requires platform-specific linker flags.</font>\n\n<a name=\"line212\">212: </a><font color=\"#B22222\">@*/</font>\n<a name=\"line213\">213: </a><strong><font color=\"#4169E1\"><a name=\"PetscDLSym\"></a><a href=\"../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a>  <a href=\"../../../docs/manualpages/Sys/PetscDLSym.html#PetscDLSym\">PetscDLSym</a>(PetscDLHandle handle,const char symbol[],void **value)</font></strong>\n<a name=\"line214\">214: </a>{\n<a name=\"line215\">215: </a>  PETSC_UNUSED dlhandle_t dlhandle;\n<a name=\"line216\">216: </a>  dlsymbol_t              dlsymbol;\n\n\n<a name=\"line221\">221: </a>  dlhandle = (dlhandle_t) 0;\n<a name=\"line222\">222: </a>  dlsymbol = (dlsymbol_t) 0;\n<a name=\"line223\">223: </a>  *value   = (void*) 0;\n\n<a name=\"line225\">225: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line226\">226: </a><font color=\"#B22222\">     --- GetProcAddress ---</font>\n<a name=\"line227\">227: </a><font color=\"#B22222\">  */</font>\n<a name=\"line228\">228: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_WINDOWS_H)</font>\n<a name=\"line229\">229: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_GETPROCADDRESS)</font>\n<a name=\"line230\">230: </a>  <font color=\"#4169E1\">if</font> (handle) dlhandle = (dlhandle_t) handle;\n<a name=\"line231\">231: </a>  <font color=\"#4169E1\">else</font> dlhandle = (dlhandle_t) GetCurrentProcess();\n<a name=\"line232\">232: </a>  dlsymbol = (dlsymbol_t) GetProcAddress(dlhandle,symbol);\n<a name=\"line233\">233: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_SETLASTERROR)</font>\n<a name=\"line234\">234: </a>  SetLastError((DWORD)0); <font color=\"#B22222\">/* clear any previous error */</font>\n<a name=\"line235\">235: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line236\">236: </a><font color=\"#A020F0\">#endif </font><font color=\"#B22222\">/* !PETSC_HAVE_GETPROCADDRESS */</font><font color=\"#A020F0\"></font>\n\n<a name=\"line238\">238: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line239\">239: </a><font color=\"#B22222\">     --- dlsym ---</font>\n<a name=\"line240\">240: </a><font color=\"#B22222\">  */</font>\n<a name=\"line241\">241: </a><font color=\"#A020F0\">#elif defined(PETSC_HAVE_DLFCN_H)</font>\n<a name=\"line242\">242: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLSYM)</font>\n<a name=\"line243\">243: </a>  <font color=\"#4169E1\">if</font> (handle) dlhandle = (dlhandle_t) handle;\n<a name=\"line244\">244: </a>  <font color=\"#4169E1\">else</font> {\n\n<a name=\"line246\">246: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLOPEN) &amp;&amp; defined(PETSC_HAVE_DYNAMIC_LIBRARIES)</font>\n<a name=\"line247\">247: </a>    <font color=\"#B22222\">/* Attempt to retrieve the main executable's dlhandle. */</font>\n<a name=\"line248\">248: </a>    { int dlflags1 = 0, dlflags2 = 0;\n<a name=\"line249\">249: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_LAZY)</font>\n<a name=\"line250\">250: </a>      dlflags1 = RTLD_LAZY;\n<a name=\"line251\">251: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line252\">252: </a>      <font color=\"#4169E1\">if</font> (!dlflags1) {\n<a name=\"line253\">253: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_NOW)</font>\n<a name=\"line254\">254: </a>        dlflags1 = RTLD_NOW;\n<a name=\"line255\">255: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line256\">256: </a>      }\n<a name=\"line257\">257: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_LOCAL)</font>\n<a name=\"line258\">258: </a>      dlflags2 = RTLD_LOCAL;\n<a name=\"line259\">259: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line260\">260: </a>      <font color=\"#4169E1\">if</font> (!dlflags2) {\n<a name=\"line261\">261: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_GLOBAL)</font>\n<a name=\"line262\">262: </a>        dlflags2 = RTLD_GLOBAL;\n<a name=\"line263\">263: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line264\">264: </a>      }\n<a name=\"line265\">265: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line266\">266: </a>      <font color=\"#4169E1\">if</font> (!(PETSC_RUNNING_ON_VALGRIND)) {\n<a name=\"line267\">267: </a>        dlerror(); <font color=\"#B22222\">/* clear any previous error; valgrind does not like this */</font>\n<a name=\"line268\">268: </a>      }\n<a name=\"line269\">269: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line270\">270: </a>      <font color=\"#B22222\">/* Attempt to open the main executable as a dynamic library. */</font>\n<a name=\"line271\">271: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTDL_DEFAULT)</font>\n<a name=\"line272\">272: </a>      dlhandle = RTLD_DEFAULT;\n<a name=\"line273\">273: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line274\">274: </a>      dlhandle = dlopen(0, dlflags1|dlflags2);\n<a name=\"line275\">275: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line276\">276: </a>      { const char *e = (const char*) dlerror();\n<a name=\"line277\">277: </a>        <font color=\"#4169E1\">if</font> (e) <a href=\"../../../docs/manualpages/Sys/SETERRQ1.html#SETERRQ1\">SETERRQ1</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>, PETSC_ERR_ARG_WRONG, <font color=\"#666666\">\"Error opening main executable as a dynamic library:\\n  Error message from dlopen(): '%s'\\n\"</font>, e);\n<a name=\"line278\">278: </a>      }\n<a name=\"line279\">279: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line280\">280: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line281\">281: </a>    }\n<a name=\"line282\">282: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line283\">283: </a><font color=\"#A020F0\">#endif </font><font color=\"#B22222\">/* PETSC_HAVE_DLOPEN &amp;&amp; PETSC_HAVE_DYNAMIC_LIBRARIES */</font><font color=\"#A020F0\"></font>\n<a name=\"line284\">284: </a>  }\n<a name=\"line285\">285: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line286\">286: </a>  dlerror(); <font color=\"#B22222\">/* clear any previous error */</font>\n<a name=\"line287\">287: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line288\">288: </a>  dlsymbol = (dlsymbol_t) dlsym(dlhandle,symbol);\n<a name=\"line289\">289: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line290\">290: </a><font color=\"#B22222\">     --- unimplemented ---</font>\n<a name=\"line291\">291: </a><font color=\"#B22222\">  */</font>\n<a name=\"line292\">292: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line293\">293: </a>  <a href=\"../../../docs/manualpages/Sys/SETERRQ.html#SETERRQ\">SETERRQ</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>,PETSC_ERR_SUP_SYS, <font color=\"#666666\">\"Cannot use dynamic libraries on this platform\"</font>);\n<a name=\"line294\">294: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line296\">296: </a>  *value = *((void**)&amp;dlsymbol);\n\n<a name=\"line298\">298: </a><font color=\"#A020F0\">#if defined(PETSC_SERIALIZE_FUNCTIONS)</font>\n<a name=\"line299\">299: </a>  <font color=\"#4169E1\">if</font> (*value) {\n<a name=\"line301\">301: </a>    PetscFPTAdd(*value,symbol);\n<a name=\"line302\">302: </a>  }\n<a name=\"line303\">303: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line304\">304: </a>  <font color=\"#4169E1\">return</font>(0);\n<a name=\"line305\">305: </a>}\n</pre>\n</body>\n\n</html>\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/src/sys/dll/dlimpl.c": "\n/*\n   Low-level routines for managing dynamic link libraries (DLLs).\n*/\n\n#include <petsc/private/petscimpl.h>\n#include <petscvalgrind.h>\n\n/* XXX Should be done better !!!*/\n#if !defined(PETSC_HAVE_DYNAMIC_LIBRARIES)\n#undef PETSC_HAVE_WINDOWS_H\n#undef PETSC_HAVE_DLFCN_H\n#endif\n\n#if defined(PETSC_HAVE_WINDOWS_H)\n#include <windows.h>\n#elif defined(PETSC_HAVE_DLFCN_H)\n#include <dlfcn.h>\n#endif\n\n#if defined(PETSC_HAVE_WINDOWS_H)\ntypedef HMODULE dlhandle_t;\ntypedef FARPROC dlsymbol_t;\n#elif defined(PETSC_HAVE_DLFCN_H)\ntypedef void* dlhandle_t;\ntypedef void* dlsymbol_t;\n#else\ntypedef void* dlhandle_t;\ntypedef void* dlsymbol_t;\n#endif\n\n/*@C\n   PetscDLOpen - opens dynamic library\n\n   Not Collective\n\n   Input Parameters:\n+    name - name of library\n-    mode - options on how to open library\n\n   Output Parameter:\n.    handle\n\n   Level: developer\n\n@*/\nPetscErrorCode  PetscDLOpen(const char name[],PetscDLMode mode,PetscDLHandle *handle)\n{\n  PETSC_UNUSED int dlflags1,dlflags2; /* There are some preprocessor paths where these variables are set, but not used */\n  dlhandle_t       dlhandle;\n\n  PetscFunctionBegin;\n  PetscValidCharPointer(name,1);\n  PetscValidPointer(handle,3);\n\n  dlflags1 = 0;\n  dlflags2 = 0;\n  dlhandle = (dlhandle_t) 0;\n  *handle  = (PetscDLHandle) 0;\n\n  /*\n     --- LoadLibrary ---\n  */\n#if defined(PETSC_HAVE_WINDOWS_H) && defined(PETSC_HAVE_LOADLIBRARY)\n  dlhandle = LoadLibrary(name);\n  if (!dlhandle) {\n#if defined(PETSC_HAVE_GETLASTERROR)\n    PetscErrorCode ierr;\n    DWORD          erc;\n    char           *buff = NULL;\n    erc = GetLastError();\n    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,\n                  NULL,erc,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),(LPSTR)&buff,0,NULL);\n    ierr = PetscError(PETSC_COMM_SELF,__LINE__,PETSC_FUNCTION_NAME,__FILE__,PETSC_ERR_FILE_OPEN,PETSC_ERROR_REPEAT,\n                      \"Unable to open dynamic library:\\n  %s\\n  Error message from LoadLibrary() %s\\n\",name,buff);\n    LocalFree(buff);\n    PetscFunctionReturn(ierr);\n#else\n    SETERRQ2(PETSC_COMM_SELF,PETSC_ERR_FILE_OPEN,\"Unable to open dynamic library:\\n  %s\\n  Error message from LoadLibrary() %s\\n\",name,\"unavailable\");\n#endif\n  }\n\n  /*\n     --- dlopen ---\n  */\n#elif defined(PETSC_HAVE_DLFCN_H) && defined(PETSC_HAVE_DLOPEN)\n  /*\n      Mode indicates symbols required by symbol loaded with dlsym()\n     are only loaded when required (not all together) also indicates\n     symbols required can be contained in other libraries also opened\n     with dlopen()\n  */\n#if defined(PETSC_HAVE_RTLD_LAZY)\n  dlflags1 = RTLD_LAZY;\n#endif\n#if defined(PETSC_HAVE_RTLD_NOW)\n  if (mode & PETSC_DL_NOW) dlflags1 = RTLD_NOW;\n#endif\n#if defined(PETSC_HAVE_RTLD_GLOBAL)\n  dlflags2 = RTLD_GLOBAL;\n#endif\n#if defined(PETSC_HAVE_RTLD_LOCAL)\n  if (mode & PETSC_DL_LOCAL) dlflags2 = RTLD_LOCAL;\n#endif\n#if defined(PETSC_HAVE_DLERROR)\n  dlerror(); /* clear any previous error */\n#endif\n  dlhandle = dlopen(name,dlflags1|dlflags2);\n  if (!dlhandle) {\n#if defined(PETSC_HAVE_DLERROR)\n    const char *errmsg = dlerror();\n#else\n    const char *errmsg = \"unavailable\";\n#endif\n    SETERRQ2(PETSC_COMM_SELF,PETSC_ERR_FILE_OPEN,\"Unable to open dynamic library:\\n  %s\\n  Error message from dlopen() %s\\n\",name,errmsg);\n  }\n\n  /*\n     --- unimplemented ---\n  */\n#else\n  SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP_SYS, \"Cannot use dynamic libraries on this platform\");\n#endif\n\n  *handle = (PetscDLHandle) dlhandle;\n  PetscFunctionReturn(0);\n}\n\n\n/*@C\n   PetscDLClose -  closes a dynamic library\n\n   Not Collective\n\n  Input Parameter:\n.   handle - the handle for the library obtained with PetscDLOpen()\n\n  Level: developer\n@*/\nPetscErrorCode  PetscDLClose(PetscDLHandle *handle)\n{\n\n  PetscFunctionBegin;\n  PetscValidPointer(handle,1);\n\n  /*\n     --- FreeLibrary ---\n  */\n#if defined(PETSC_HAVE_WINDOWS_H)\n#if defined(PETSC_HAVE_FREELIBRARY)\n  if (FreeLibrary((dlhandle_t)*handle) == 0) {\n#if defined(PETSC_HAVE_GETLASTERROR)\n    char  *buff = NULL;\n    DWORD erc   = GetLastError();\n    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,NULL,erc,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),(LPSTR)&buff,0,NULL);\n    PetscErrorPrintf(\"Error closing dynamic library:\\n  Error message from FreeLibrary() %s\\n\",buff);\n    LocalFree(buff);\n#else\n    PetscErrorPrintf(\"Error closing dynamic library:\\n  Error message from FreeLibrary() %s\\n\",\"unavailable\");\n#endif\n  }\n#endif /* !PETSC_HAVE_FREELIBRARY */\n\n  /*\n     --- dclose ---\n  */\n#elif defined(PETSC_HAVE_DLFCN_H)\n#if defined(PETSC_HAVE_DLCLOSE)\n#if defined(PETSC_HAVE_DLERROR)\n  dlerror(); /* clear any previous error */\n#endif\n  if (dlclose((dlhandle_t)*handle) < 0) {\n#if defined(PETSC_HAVE_DLERROR)\n    const char *errmsg = dlerror();\n#else\n    const char *errmsg = \"unavailable\";\n#endif\n    PetscErrorPrintf(\"Error closing dynamic library:\\n  Error message from dlclose() %s\\n\", errmsg);\n  }\n#endif /* !PETSC_HAVE_DLCLOSE */\n\n  /*\n     --- unimplemented ---\n  */\n#else\n  SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP_SYS, \"Cannot use dynamic libraries on this platform\");\n#endif\n\n  *handle = NULL;\n  PetscFunctionReturn(0);\n}\n\n/*@C\n   PetscDLSym - finds a symbol in a dynamic library\n\n   Not Collective\n\n   Input Parameters:\n+   handle - obtained with PetscDLOpen() or NULL\n-   symbol - name of symbol\n\n   Output Parameter:\n.   value - pointer to the function, NULL if not found\n\n   Level: developer\n\n  Notes:\n   If handle is NULL, the symbol is looked for in the main executable's dynamic symbol table.\n   In order to be dynamically loadable, the symbol has to be exported as such.  On many UNIX-like\n   systems this requires platform-specific linker flags.\n\n@*/\nPetscErrorCode  PetscDLSym(PetscDLHandle handle,const char symbol[],void **value)\n{\n  PETSC_UNUSED dlhandle_t dlhandle;\n  dlsymbol_t              dlsymbol;\n\n  PetscValidCharPointer(symbol,2);\n  PetscValidPointer(value,3);\n\n  dlhandle = (dlhandle_t) 0;\n  dlsymbol = (dlsymbol_t) 0;\n  *value   = (void*) 0;\n\n  /*\n     --- GetProcAddress ---\n  */\n#if defined(PETSC_HAVE_WINDOWS_H)\n#if defined(PETSC_HAVE_GETPROCADDRESS)\n  if (handle) dlhandle = (dlhandle_t) handle;\n  else dlhandle = (dlhandle_t) GetCurrentProcess();\n  dlsymbol = (dlsymbol_t) GetProcAddress(dlhandle,symbol);\n#if defined(PETSC_HAVE_SETLASTERROR)\n  SetLastError((DWORD)0); /* clear any previous error */\n#endif\n#endif /* !PETSC_HAVE_GETPROCADDRESS */\n\n  /*\n     --- dlsym ---\n  */\n#elif defined(PETSC_HAVE_DLFCN_H)\n#if defined(PETSC_HAVE_DLSYM)\n  if (handle) dlhandle = (dlhandle_t) handle;\n  else {\n\n#if defined(PETSC_HAVE_DLOPEN) && defined(PETSC_HAVE_DYNAMIC_LIBRARIES)\n    /* Attempt to retrieve the main executable's dlhandle. */\n    { int dlflags1 = 0, dlflags2 = 0;\n#if defined(PETSC_HAVE_RTLD_LAZY)\n      dlflags1 = RTLD_LAZY;\n#endif\n      if (!dlflags1) {\n#if defined(PETSC_HAVE_RTLD_NOW)\n        dlflags1 = RTLD_NOW;\n#endif\n      }\n#if defined(PETSC_HAVE_RTLD_LOCAL)\n      dlflags2 = RTLD_LOCAL;\n#endif\n      if (!dlflags2) {\n#if defined(PETSC_HAVE_RTLD_GLOBAL)\n        dlflags2 = RTLD_GLOBAL;\n#endif\n      }\n#if defined(PETSC_HAVE_DLERROR)\n      if (!(PETSC_RUNNING_ON_VALGRIND)) {\n        dlerror(); /* clear any previous error; valgrind does not like this */\n      }\n#endif\n      /* Attempt to open the main executable as a dynamic library. */\n#if defined(PETSC_HAVE_RTDL_DEFAULT)\n      dlhandle = RTLD_DEFAULT;\n#else\n      dlhandle = dlopen(0, dlflags1|dlflags2);\n#if defined(PETSC_HAVE_DLERROR)\n      { const char *e = (const char*) dlerror();\n        if (e) SETERRQ1(PETSC_COMM_SELF, PETSC_ERR_ARG_WRONG, \"Error opening main executable as a dynamic library:\\n  Error message from dlopen(): '%s'\\n\", e);\n      }\n#endif\n#endif\n    }\n#endif\n#endif /* PETSC_HAVE_DLOPEN && PETSC_HAVE_DYNAMIC_LIBRARIES */\n  }\n#if defined(PETSC_HAVE_DLERROR)\n  dlerror(); /* clear any previous error */\n#endif\n  dlsymbol = (dlsymbol_t) dlsym(dlhandle,symbol);\n  /*\n     --- unimplemented ---\n  */\n#else\n  SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP_SYS, \"Cannot use dynamic libraries on this platform\");\n#endif\n\n  *value = *((void**)&dlsymbol);\n\n#if defined(PETSC_SERIALIZE_FUNCTIONS)\n  if (*value) {\n    PetscErrorCode ierr;\n    ierr = PetscFPTAdd(*value,symbol);CHKERRQ(ierr);\n  }\n#endif\n  return(0);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/systems/Apple/iOS/examples/Basic/Default-568h@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/src/ksp/ksp/examples/tutorials/data/ex35_mesh.h5m",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/src/tao/bound/impls/bncg/bncg.c.html",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/src/sys/objects/pinit.c.html",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/src/dm/impls/moab/dmmbfem.cxx.html",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/src/dm/impls/moab/examples/tests/input/ex3_in.h5m",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/src/ts/examples/tutorials/chem_meth_ethanol.inp",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/src/ts/examples/tutorials/power_grid/PDF_eqs_power_grid.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/src/ts/examples/tutorials/power_grid/stability_9bus/Ybus.bin",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/src/ts/examples/tutorials/power_grid/stability_9bus/X.bin",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/lib/petsc/bin/win32fe/win32fe.exe",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/lib/petsc/bin/win32fe/win32feutils.dll",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/saws/images/transition.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/saws/images/arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/surfacesphere_bin.msh",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/square_bin.msh",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/square.med",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/FourSquareT-large.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/FourBrickTet-large.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/2Dgrd.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/square_bin_physnames.msh",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/simpleblock-100.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/TwoQuads.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/grid_c.cgns",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/Rect-tri3.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/FourSquareQ-large.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/square_periodic_bin.msh",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/tut21.cgns",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/horse.ply.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/sevenside.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/sevenside-quad-15.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/annulus-20.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/cube_periodic_bin.msh",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/FourBrickHex-large.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/sevenside-quad.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/FourSquareH-large.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/squaremotor-30.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/blockcylinder-50.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/cylinder.med",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/blockcylinder-50.h5",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/share/petsc/datafiles/meshes/cube_5tets.cas",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/docs/manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/docs/developers.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.10.0-455cs66acqzk334wl2ym364ljfa2eu7a/spack-src/docs/tao_manual.pdf"
    ],
    "total_files": 14638
}