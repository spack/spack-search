{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-ipcalc-0.2.2-xmotg7vdyn5efldk4iwaua6hy6mmcf77/spack-src/ipcalc-geoip.c": "/*\n * Copyright (c) 2015 Red Hat, Inc. All rights reserved.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2,\n * as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * Authors:\n *   Nikos Mavrogiannopoulos <nmav@redhat.com>\n */\n\n#define _GNU_SOURCE\t\t/* asprintf */\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <stdarg.h>\n#include \"ipcalc.h\"\n\n#ifdef USE_GEOIP\n\n# include <GeoIP.h>\n# include <GeoIPCity.h>\n\n# ifdef USE_DYN_GEOIP\n#  include <dlfcn.h>\n\ntypedef void (*_GeoIP_setup_dbfilename_func)(void);\ntypedef GeoIP * (*GeoIP_open_type_func)(int type, int flags);\ntypedef const char * (*GeoIP_country_name_by_id_func)(GeoIP * gi, int id);\ntypedef void (*GeoIP_delete_func)(GeoIP * gi);\ntypedef GeoIPRecord * (*GeoIP_record_by_ipnum_func)(GeoIP * gi, unsigned long ipnum);\ntypedef int (*GeoIP_id_by_ipnum_func)(GeoIP * gi, unsigned long ipnum);\ntypedef int (*GeoIP_id_by_ipnum_v6_func)(GeoIP * gi, geoipv6_t ipnum);\ntypedef GeoIPRecord *(*GeoIP_record_by_ipnum_v6_func)(GeoIP * gi, geoipv6_t ipnum);\ntypedef const char *(*GeoIP_code_by_id_func)(int id);\n\nstatic _GeoIP_setup_dbfilename_func p_GeoIP_setup_dbfilename;\nstatic GeoIP_open_type_func pGeoIP_open_type;\nstatic GeoIP_country_name_by_id_func pGeoIP_country_name_by_id;\nstatic GeoIP_code_by_id_func pGeoIP_code_by_id;\nstatic GeoIP_delete_func pGeoIP_delete;\nstatic GeoIP_record_by_ipnum_func pGeoIP_record_by_ipnum;\nstatic GeoIP_id_by_ipnum_func pGeoIP_id_by_ipnum;\nstatic GeoIP_id_by_ipnum_v6_func pGeoIP_id_by_ipnum_v6;\nstatic GeoIP_record_by_ipnum_v6_func pGeoIP_record_by_ipnum_v6;\n\n#define LIBNAME LIBPATH\"/libGeoIP.so.1\"\n\nstatic int __attribute__((__format__(printf, 2, 3)))\nsafe_asprintf(char **strp, const char *fmt, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tret = vasprintf(&(*strp), fmt, args);\n\tva_end(args);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Memory allocation failure\\n\");\n\t\texit(1);\n\t}\n\treturn ret;\n}\n\nint geo_setup(void)\n{\n\tstatic void *ld = NULL;\n\tstatic int ret = 0;\n\tstatic char err[256] = {0};\n\n\tif (ld != NULL || ret != 0) {\n\t    \tif (!beSilent && err[0] != 0) {\n\t    \t\tfprintf(stderr, \"%s\", err);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tld = dlopen(LIBNAME, RTLD_LAZY);\n\tif (ld == NULL) {\n\t\tsnprintf(err, sizeof(err), \"ipcalc: could not open %s\\n\", LIBNAME);\n\t\tret = -1;\n\t\tgoto exit;\n\t}\n\n\tp_GeoIP_setup_dbfilename = dlsym(ld, \"_GeoIP_setup_dbfilename\");\n\n\tpGeoIP_open_type = dlsym(ld, \"GeoIP_open_type\");\n\tpGeoIP_country_name_by_id = dlsym(ld, \"GeoIP_country_name_by_id\");\n\tpGeoIP_delete = dlsym(ld, \"GeoIP_delete\");\n\tpGeoIP_record_by_ipnum = dlsym(ld, \"GeoIP_record_by_ipnum\");\n\tpGeoIP_id_by_ipnum = dlsym(ld, \"GeoIP_id_by_ipnum\");\n\tpGeoIP_id_by_ipnum_v6 = dlsym(ld, \"GeoIP_id_by_ipnum_v6\");\n\tpGeoIP_record_by_ipnum_v6 = dlsym(ld, \"GeoIP_record_by_ipnum_v6\");\n\tpGeoIP_code_by_id = dlsym(ld, \"GeoIP_code_by_id\");\n\n\tif (pGeoIP_open_type == NULL || pGeoIP_country_name_by_id == NULL ||\n\t    pGeoIP_delete == NULL || pGeoIP_record_by_ipnum == NULL ||\n\t    pGeoIP_id_by_ipnum == NULL || pGeoIP_id_by_ipnum_v6 == NULL ||\n\t    pGeoIP_record_by_ipnum_v6 == NULL) {\n\t\tsnprintf(err, sizeof(err), \"ipcalc: could not find symbols in libGeoIP\\n\");\n\t    \tret = -1;\n\t    \tgoto exit;\n\t}\n\n\tret = 0;\n exit:\n\treturn ret;\n}\n\n# else\n\nextern void _GeoIP_setup_dbfilename(void);\n#  define p_GeoIP_setup_dbfilename _GeoIP_setup_dbfilename\n#  define pGeoIP_open_type GeoIP_open_type\n#  define pGeoIP_country_name_by_id GeoIP_country_name_by_id\n#  define pGeoIP_delete GeoIP_delete\n#  define pGeoIP_record_by_ipnum GeoIP_record_by_ipnum\n#  define pGeoIP_id_by_ipnum GeoIP_id_by_ipnum\n#  define pGeoIP_id_by_ipnum_v6 GeoIP_id_by_ipnum_v6\n#  define pGeoIP_record_by_ipnum_v6 GeoIP_record_by_ipnum_v6\n#  define pGeoIP_code_by_id GeoIP_code_by_id\n# endif\n\nvoid geo_ipv4_lookup(struct in_addr ip, char **country, char **ccode, char **city, char **coord)\n{\n\tGeoIP *gi;\n\tGeoIPRecord *gir;\n\tint country_id;\n\tconst char *p;\n\n\tif (geo_setup() != 0)\n\t\treturn;\n\n\tip.s_addr = ntohl(ip.s_addr);\n\n\tp_GeoIP_setup_dbfilename();\n\n\tgi = pGeoIP_open_type(GEOIP_COUNTRY_EDITION, GEOIP_STANDARD | GEOIP_SILENCE);\n\tif (gi != NULL) {\n\t\tgi->charset = GEOIP_CHARSET_UTF8;\n\n\t\tcountry_id = pGeoIP_id_by_ipnum(gi, ip.s_addr);\n\t\tif (country_id < 0) {\n\t\t\treturn;\n\t\t}\n\t\tp = pGeoIP_country_name_by_id(gi, country_id);\n\t\tif (p)\n\t\t\t*country = safe_strdup(p);\n\n\t\tp = pGeoIP_code_by_id(country_id);\n\t\tif (p)\n\t\t\t*ccode = safe_strdup(p);\n\n\t\tpGeoIP_delete(gi);\n\t}\n\n\tgi = pGeoIP_open_type(GEOIP_CITY_EDITION_REV1, GEOIP_STANDARD | GEOIP_SILENCE);\n\tif (gi != NULL) {\n\t\tgi->charset = GEOIP_CHARSET_UTF8;\n\n\t\tgir = pGeoIP_record_by_ipnum(gi, ip.s_addr);\n\n\t\tif (gir && gir->city)\n\t\t\t*city = safe_strdup(gir->city);\n\n\t\tif (gir && gir->longitude != 0 && gir->longitude != 0)\n\t\t\tsafe_asprintf(coord, \"%f,%f\", gir->latitude, gir->longitude);\n\n\t\tpGeoIP_delete(gi);\n\t} else {\n\t\tgi = pGeoIP_open_type(GEOIP_CITY_EDITION_REV0, GEOIP_STANDARD | GEOIP_SILENCE);\n\t\tif (gi != NULL) {\n\t\t\tgi->charset = GEOIP_CHARSET_UTF8;\n\n\t\t\tgir = pGeoIP_record_by_ipnum(gi, ip.s_addr);\n\n\t\t\tif (gir && gir->city)\n\t\t\t\t*city = safe_strdup(gir->city);\n\n\t\t\tif (gir && gir->longitude != 0 && gir->longitude != 0)\n\t\t\t\tsafe_asprintf(coord, \"%f,%f\", gir->latitude, gir->longitude);\n\n\t\t\tpGeoIP_delete(gi);\n\t\t}\n\t}\n\n\treturn;\n}\n\nvoid geo_ipv6_lookup(struct in6_addr *ip, char **country, char **ccode, char **city, char **coord)\n{\n\tGeoIP *gi;\n\tGeoIPRecord *gir;\n\tint country_id;\n\tconst char *p;\n\n\tif (geo_setup() != 0)\n\t\treturn;\n\n\tp_GeoIP_setup_dbfilename();\n\n\tgi = pGeoIP_open_type(GEOIP_COUNTRY_EDITION_V6, GEOIP_STANDARD | GEOIP_SILENCE);\n\tif (gi != NULL) {\n\t\tgi->charset = GEOIP_CHARSET_UTF8;\n\n\t\tcountry_id = pGeoIP_id_by_ipnum_v6(gi, (geoipv6_t)*ip);\n\t\tif (country_id < 0) {\n\t\t\treturn;\n\t\t}\n\t\tp = pGeoIP_country_name_by_id(gi, country_id);\n\t\tif (p)\n\t\t\t*country = safe_strdup(p);\n\n\t\tp = pGeoIP_code_by_id(country_id);\n\t\tif (p)\n\t\t\t*ccode = safe_strdup(p);\n\n\t\tpGeoIP_delete(gi);\n\t}\n\n\tgi = pGeoIP_open_type(GEOIP_CITY_EDITION_REV1_V6, GEOIP_STANDARD | GEOIP_SILENCE);\n\tif (gi != NULL) {\n\t\tgi->charset = GEOIP_CHARSET_UTF8;\n\n\t\tgir = pGeoIP_record_by_ipnum_v6(gi, (geoipv6_t)*ip);\n\n\t\tif (gir && gir->city)\n\t\t\t*city = safe_strdup(gir->city);\n\n\t\tif (gir && gir->longitude != 0 && gir->longitude != 0)\n\t\t\tsafe_asprintf(coord, \"%f,%f\", gir->latitude, gir->longitude);\n\n\t\tpGeoIP_delete(gi);\n\t} else {\n\t\tgi = pGeoIP_open_type(GEOIP_CITY_EDITION_REV0_V6, GEOIP_STANDARD | GEOIP_SILENCE);\n\t\tif (gi != NULL) {\n\t\t\tgi->charset = GEOIP_CHARSET_UTF8;\n\n\t\t\tgir = pGeoIP_record_by_ipnum_v6(gi, (geoipv6_t)*ip);\n\n\t\t\tif (gir && gir->city)\n\t\t\t\t*city = safe_strdup(gir->city);\n\n\t\t\tif (gir && gir->longitude != 0 && gir->longitude != 0)\n\t\t\t\tsafe_asprintf(coord, \"%f,%f\", gir->latitude, gir->longitude);\n\n\t\t\tpGeoIP_delete(gi);\n\t\t}\n\t}\n\n\treturn;\n}\n\n#endif\n"
    },
    "skipped": [],
    "total_files": 30
}