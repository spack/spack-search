{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/src/libexpr/primops.cc": "#include \"archive.hh\"\n#include \"derivations.hh\"\n#include \"download.hh\"\n#include \"eval-inline.hh\"\n#include \"eval.hh\"\n#include \"globals.hh\"\n#include \"json-to-value.hh\"\n#include \"names.hh\"\n#include \"store-api.hh\"\n#include \"util.hh\"\n#include \"json.hh\"\n#include \"value-to-json.hh\"\n#include \"value-to-xml.hh\"\n#include \"primops.hh\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include <algorithm>\n#include <cstring>\n#include <regex>\n#include <dlfcn.h>\n\n\nnamespace nix {\n\n\n/*************************************************************\n * Miscellaneous\n *************************************************************/\n\n\n/* Decode a context string \u2018!<name>!<path>\u2019 into a pair <path,\n   name>. */\nstd::pair<string, string> decodeContext(const string & s)\n{\n    if (s.at(0) == '!') {\n        size_t index = s.find(\"!\", 1);\n        return std::pair<string, string>(string(s, index + 1), string(s, 1, index - 1));\n    } else\n        return std::pair<string, string>(s.at(0) == '/' ? s : string(s, 1), \"\");\n}\n\n\nInvalidPathError::InvalidPathError(const Path & path) :\n    EvalError(format(\"path '%1%' is not valid\") % path), path(path) {}\n\nvoid EvalState::realiseContext(const PathSet & context)\n{\n    PathSet drvs;\n\n    for (auto & i : context) {\n        std::pair<string, string> decoded = decodeContext(i);\n        Path ctx = decoded.first;\n        assert(store->isStorePath(ctx));\n        if (!store->isValidPath(ctx))\n            throw InvalidPathError(ctx);\n        if (!decoded.second.empty() && nix::isDerivation(ctx)) {\n            drvs.insert(decoded.first + \"!\" + decoded.second);\n\n            /* Add the output of this derivation to the allowed\n               paths. */\n            if (allowedPaths) {\n                auto drv = store->derivationFromPath(decoded.first);\n                DerivationOutputs::iterator i = drv.outputs.find(decoded.second);\n                if (i == drv.outputs.end())\n                    throw Error(\"derivation '%s' does not have an output named '%s'\", decoded.first, decoded.second);\n                allowedPaths->insert(i->second.path);\n            }\n        }\n    }\n\n    if (drvs.empty()) return;\n\n    if (!settings.enableImportFromDerivation)\n        throw EvalError(format(\"attempted to realize '%1%' during evaluation but 'allow-import-from-derivation' is false\") % *(drvs.begin()));\n\n    /* For performance, prefetch all substitute info. */\n    PathSet willBuild, willSubstitute, unknown;\n    unsigned long long downloadSize, narSize;\n    store->queryMissing(drvs, willBuild, willSubstitute, unknown, downloadSize, narSize);\n    store->buildPaths(drvs);\n}\n\n\n/* Load and evaluate an expression from path specified by the\n   argument. */\nstatic void prim_scopedImport(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    Path path = state.coerceToPath(pos, *args[1], context);\n\n    try {\n        state.realiseContext(context);\n    } catch (InvalidPathError & e) {\n        throw EvalError(format(\"cannot import '%1%', since path '%2%' is not valid, at %3%\")\n            % path % e.path % pos);\n    }\n\n    Path realPath = state.checkSourcePath(state.toRealPath(path, context));\n\n    if (state.store->isStorePath(path) && state.store->isValidPath(path) && isDerivation(path)) {\n        Derivation drv = readDerivation(realPath);\n        Value & w = *state.allocValue();\n        state.mkAttrs(w, 3 + drv.outputs.size());\n        Value * v2 = state.allocAttr(w, state.sDrvPath);\n        mkString(*v2, path, {\"=\" + path});\n        v2 = state.allocAttr(w, state.sName);\n        mkString(*v2, drv.env[\"name\"]);\n        Value * outputsVal =\n            state.allocAttr(w, state.symbols.create(\"outputs\"));\n        state.mkList(*outputsVal, drv.outputs.size());\n        unsigned int outputs_index = 0;\n\n        for (const auto & o : drv.outputs) {\n            v2 = state.allocAttr(w, state.symbols.create(o.first));\n            mkString(*v2, o.second.path, {\"!\" + o.first + \"!\" + path});\n            outputsVal->listElems()[outputs_index] = state.allocValue();\n            mkString(*(outputsVal->listElems()[outputs_index++]), o.first);\n        }\n        w.attrs->sort();\n        Value fun;\n        state.evalFile(settings.nixDataDir + \"/nix/corepkgs/imported-drv-to-derivation.nix\", fun);\n        state.forceFunction(fun, pos);\n        mkApp(v, fun, w);\n        state.forceAttrs(v, pos);\n    } else {\n        state.forceAttrs(*args[0]);\n        if (args[0]->attrs->empty())\n            state.evalFile(realPath, v);\n        else {\n            Env * env = &state.allocEnv(args[0]->attrs->size());\n            env->up = &state.baseEnv;\n\n            StaticEnv staticEnv(false, &state.staticBaseEnv);\n\n            unsigned int displ = 0;\n            for (auto & attr : *args[0]->attrs) {\n                staticEnv.vars[attr.name] = displ;\n                env->values[displ++] = attr.value;\n            }\n\n            printTalkative(\"evaluating file '%1%'\", realPath);\n            Expr * e = state.parseExprFromFile(resolveExprPath(realPath), staticEnv);\n\n            e->eval(state, *env, v);\n        }\n    }\n}\n\n\n/* Want reasonable symbol names, so extern C */\n/* !!! Should we pass the Pos or the file name too? */\nextern \"C\" typedef void (*ValueInitializer)(EvalState & state, Value & v);\n\n/* Load a ValueInitializer from a DSO and return whatever it initializes */\nvoid prim_importNative(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    Path path = state.coerceToPath(pos, *args[0], context);\n\n    try {\n        state.realiseContext(context);\n    } catch (InvalidPathError & e) {\n        throw EvalError(format(\"cannot import '%1%', since path '%2%' is not valid, at %3%\")\n            % path % e.path % pos);\n    }\n\n    path = state.checkSourcePath(path);\n\n    string sym = state.forceStringNoCtx(*args[1], pos);\n\n    void *handle = dlopen(path.c_str(), RTLD_LAZY | RTLD_LOCAL);\n    if (!handle)\n        throw EvalError(format(\"could not open '%1%': %2%\") % path % dlerror());\n\n    dlerror();\n    ValueInitializer func = (ValueInitializer) dlsym(handle, sym.c_str());\n    if(!func) {\n        char *message = dlerror();\n        if (message)\n            throw EvalError(format(\"could not load symbol '%1%' from '%2%': %3%\") % sym % path % message);\n        else\n            throw EvalError(format(\"symbol '%1%' from '%2%' resolved to NULL when a function pointer was expected\")\n                    % sym % path);\n    }\n\n    (func)(state, v);\n\n    /* We don't dlclose because v may be a primop referencing a function in the shared object file */\n}\n\n\n/* Execute a program and parse its output */\nvoid prim_exec(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceList(*args[0], pos);\n    auto elems = args[0]->listElems();\n    auto count = args[0]->listSize();\n    if (count == 0) {\n        throw EvalError(format(\"at least one argument to 'exec' required, at %1%\") % pos);\n    }\n    PathSet context;\n    auto program = state.coerceToString(pos, *elems[0], context, false, false);\n    Strings commandArgs;\n    for (unsigned int i = 1; i < args[0]->listSize(); ++i) {\n        commandArgs.emplace_back(state.coerceToString(pos, *elems[i], context, false, false));\n    }\n    try {\n        state.realiseContext(context);\n    } catch (InvalidPathError & e) {\n        throw EvalError(format(\"cannot execute '%1%', since path '%2%' is not valid, at %3%\")\n            % program % e.path % pos);\n    }\n\n    auto output = runProgram(program, true, commandArgs);\n    Expr * parsed;\n    try {\n        parsed = state.parseExprFromString(output, pos.file);\n    } catch (Error & e) {\n        e.addPrefix(format(\"While parsing the output from '%1%', at %2%\\n\") % program % pos);\n        throw;\n    }\n    try {\n        state.eval(parsed, v);\n    } catch (Error & e) {\n        e.addPrefix(format(\"While evaluating the output from '%1%', at %2%\\n\") % program % pos);\n        throw;\n    }\n}\n\n\n/* Return a string representing the type of the expression. */\nstatic void prim_typeOf(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    string t;\n    switch (args[0]->type) {\n        case tInt: t = \"int\"; break;\n        case tBool: t = \"bool\"; break;\n        case tString: t = \"string\"; break;\n        case tPath: t = \"path\"; break;\n        case tNull: t = \"null\"; break;\n        case tAttrs: t = \"set\"; break;\n        case tList1: case tList2: case tListN: t = \"list\"; break;\n        case tLambda:\n        case tPrimOp:\n        case tPrimOpApp:\n            t = \"lambda\";\n            break;\n        case tExternal:\n            t = args[0]->external->typeOf();\n            break;\n        case tFloat: t = \"float\"; break;\n        default: abort();\n    }\n    mkString(v, state.symbols.create(t));\n}\n\n\n/* Determine whether the argument is the null value. */\nstatic void prim_isNull(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    mkBool(v, args[0]->type == tNull);\n}\n\n\n/* Determine whether the argument is a function. */\nstatic void prim_isFunction(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    mkBool(v, args[0]->type == tLambda);\n}\n\n\n/* Determine whether the argument is an integer. */\nstatic void prim_isInt(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    mkBool(v, args[0]->type == tInt);\n}\n\n/* Determine whether the argument is a float. */\nstatic void prim_isFloat(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    mkBool(v, args[0]->type == tFloat);\n}\n\n/* Determine whether the argument is a string. */\nstatic void prim_isString(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    mkBool(v, args[0]->type == tString);\n}\n\n\n/* Determine whether the argument is a Boolean. */\nstatic void prim_isBool(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    mkBool(v, args[0]->type == tBool);\n}\n\n\nstruct CompareValues\n{\n    bool operator () (const Value * v1, const Value * v2) const\n    {\n        if (v1->type == tFloat && v2->type == tInt)\n            return v1->fpoint < v2->integer;\n        if (v1->type == tInt && v2->type == tFloat)\n            return v1->integer < v2->fpoint;\n        if (v1->type != v2->type)\n            throw EvalError(format(\"cannot compare %1% with %2%\") % showType(*v1) % showType(*v2));\n        switch (v1->type) {\n            case tInt:\n                return v1->integer < v2->integer;\n            case tFloat:\n                return v1->fpoint < v2->fpoint;\n            case tString:\n                return strcmp(v1->string.s, v2->string.s) < 0;\n            case tPath:\n                return strcmp(v1->path, v2->path) < 0;\n            default:\n                throw EvalError(format(\"cannot compare %1% with %2%\") % showType(*v1) % showType(*v2));\n        }\n    }\n};\n\n\n#if HAVE_BOEHMGC\ntypedef list<Value *, gc_allocator<Value *> > ValueList;\n#else\ntypedef list<Value *> ValueList;\n#endif\n\n\nstatic void prim_genericClosure(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceAttrs(*args[0], pos);\n\n    /* Get the start set. */\n    Bindings::iterator startSet =\n        args[0]->attrs->find(state.symbols.create(\"startSet\"));\n    if (startSet == args[0]->attrs->end())\n        throw EvalError(format(\"attribute 'startSet' required, at %1%\") % pos);\n    state.forceList(*startSet->value, pos);\n\n    ValueList workSet;\n    for (unsigned int n = 0; n < startSet->value->listSize(); ++n)\n        workSet.push_back(startSet->value->listElems()[n]);\n\n    /* Get the operator. */\n    Bindings::iterator op =\n        args[0]->attrs->find(state.symbols.create(\"operator\"));\n    if (op == args[0]->attrs->end())\n        throw EvalError(format(\"attribute 'operator' required, at %1%\") % pos);\n    state.forceValue(*op->value);\n\n    /* Construct the closure by applying the operator to element of\n       `workSet', adding the result to `workSet', continuing until\n       no new elements are found. */\n    ValueList res;\n    // `doneKeys' doesn't need to be a GC root, because its values are\n    // reachable from res.\n    set<Value *, CompareValues> doneKeys;\n    while (!workSet.empty()) {\n        Value * e = *(workSet.begin());\n        workSet.pop_front();\n\n        state.forceAttrs(*e, pos);\n\n        Bindings::iterator key =\n            e->attrs->find(state.symbols.create(\"key\"));\n        if (key == e->attrs->end())\n            throw EvalError(format(\"attribute 'key' required, at %1%\") % pos);\n        state.forceValue(*key->value);\n\n        if (doneKeys.find(key->value) != doneKeys.end()) continue;\n        doneKeys.insert(key->value);\n        res.push_back(e);\n\n        /* Call the `operator' function with `e' as argument. */\n        Value call;\n        mkApp(call, *op->value, *e);\n        state.forceList(call, pos);\n\n        /* Add the values returned by the operator to the work set. */\n        for (unsigned int n = 0; n < call.listSize(); ++n) {\n            state.forceValue(*call.listElems()[n]);\n            workSet.push_back(call.listElems()[n]);\n        }\n    }\n\n    /* Create the result list. */\n    state.mkList(v, res.size());\n    unsigned int n = 0;\n    for (auto & i : res)\n        v.listElems()[n++] = i;\n}\n\n\nstatic void prim_abort(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    string s = state.coerceToString(pos, *args[0], context);\n    throw Abort(format(\"evaluation aborted with the following error message: '%1%'\") % s);\n}\n\n\nstatic void prim_throw(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    string s = state.coerceToString(pos, *args[0], context);\n    throw ThrownError(s);\n}\n\n\nstatic void prim_addErrorContext(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    try {\n        state.forceValue(*args[1]);\n        v = *args[1];\n    } catch (Error & e) {\n        PathSet context;\n        e.addPrefix(format(\"%1%\\n\") % state.coerceToString(pos, *args[0], context));\n        throw;\n    }\n}\n\n\n/* Try evaluating the argument. Success => {success=true; value=something;},\n * else => {success=false; value=false;} */\nstatic void prim_tryEval(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.mkAttrs(v, 2);\n    try {\n        state.forceValue(*args[0]);\n        v.attrs->push_back(Attr(state.sValue, args[0]));\n        mkBool(*state.allocAttr(v, state.symbols.create(\"success\")), true);\n    } catch (AssertionError & e) {\n        mkBool(*state.allocAttr(v, state.sValue), false);\n        mkBool(*state.allocAttr(v, state.symbols.create(\"success\")), false);\n    }\n    v.attrs->sort();\n}\n\n\n/* Return an environment variable.  Use with care. */\nstatic void prim_getEnv(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    string name = state.forceStringNoCtx(*args[0], pos);\n    mkString(v, settings.restrictEval || settings.pureEval ? \"\" : getEnv(name));\n}\n\n\n/* Evaluate the first argument, then return the second argument. */\nstatic void prim_seq(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    state.forceValue(*args[1]);\n    v = *args[1];\n}\n\n\n/* Evaluate the first argument deeply (i.e. recursing into lists and\n   attrsets), then return the second argument. */\nstatic void prim_deepSeq(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValueDeep(*args[0]);\n    state.forceValue(*args[1]);\n    v = *args[1];\n}\n\n\n/* Evaluate the first expression and print it on standard error.  Then\n   return the second expression.  Useful for debugging. */\nstatic void prim_trace(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    if (args[0]->type == tString)\n        printError(format(\"trace: %1%\") % args[0]->string.s);\n    else\n        printError(format(\"trace: %1%\") % *args[0]);\n    state.forceValue(*args[1]);\n    v = *args[1];\n}\n\n\nvoid prim_valueSize(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    /* We're not forcing the argument on purpose. */\n    mkInt(v, valueSize(*args[0]));\n}\n\n\n/*************************************************************\n * Derivations\n *************************************************************/\n\n\n/* Construct (as a unobservable side effect) a Nix derivation\n   expression that performs the derivation described by the argument\n   set.  Returns the original set extended with the following\n   attributes: `outPath' containing the primary output path of the\n   derivation; `drvPath' containing the path of the Nix expression;\n   and `type' set to `derivation' to indicate that this is a\n   derivation. */\nstatic void prim_derivationStrict(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceAttrs(*args[0], pos);\n\n    /* Figure out the name first (for stack backtraces). */\n    Bindings::iterator attr = args[0]->attrs->find(state.sName);\n    if (attr == args[0]->attrs->end())\n        throw EvalError(format(\"required attribute 'name' missing, at %1%\") % pos);\n    string drvName;\n    Pos & posDrvName(*attr->pos);\n    try {\n        drvName = state.forceStringNoCtx(*attr->value, pos);\n    } catch (Error & e) {\n        e.addPrefix(format(\"while evaluating the derivation attribute 'name' at %1%:\\n\") % posDrvName);\n        throw;\n    }\n\n    /* Check whether attributes should be passed as a JSON file. */\n    std::ostringstream jsonBuf;\n    std::unique_ptr<JSONObject> jsonObject;\n    attr = args[0]->attrs->find(state.sStructuredAttrs);\n    if (attr != args[0]->attrs->end() && state.forceBool(*attr->value, pos))\n        jsonObject = std::make_unique<JSONObject>(jsonBuf);\n\n    /* Check whether null attributes should be ignored. */\n    bool ignoreNulls = false;\n    attr = args[0]->attrs->find(state.sIgnoreNulls);\n    if (attr != args[0]->attrs->end())\n        ignoreNulls = state.forceBool(*attr->value, pos);\n\n    /* Build the derivation expression by processing the attributes. */\n    Derivation drv;\n\n    PathSet context;\n\n    std::experimental::optional<std::string> outputHash;\n    std::string outputHashAlgo;\n    bool outputHashRecursive = false;\n\n    StringSet outputs;\n    outputs.insert(\"out\");\n\n    for (auto & i : args[0]->attrs->lexicographicOrder()) {\n        if (i->name == state.sIgnoreNulls) continue;\n        const string & key = i->name;\n        vomit(\"processing attribute '%1%'\", key);\n\n        auto handleHashMode = [&](const std::string & s) {\n            if (s == \"recursive\") outputHashRecursive = true;\n            else if (s == \"flat\") outputHashRecursive = false;\n            else throw EvalError(\"invalid value '%s' for 'outputHashMode' attribute, at %s\", s, posDrvName);\n        };\n\n        auto handleOutputs = [&](const Strings & ss) {\n            outputs.clear();\n            for (auto & j : ss) {\n                if (outputs.find(j) != outputs.end())\n                    throw EvalError(format(\"duplicate derivation output '%1%', at %2%\") % j % posDrvName);\n                /* !!! Check whether j is a valid attribute\n                   name. */\n                /* Derivations cannot be named \u2018drv\u2019, because\n                   then we'd have an attribute \u2018drvPath\u2019 in\n                   the resulting set. */\n                if (j == \"drv\")\n                    throw EvalError(format(\"invalid derivation output name 'drv', at %1%\") % posDrvName);\n                outputs.insert(j);\n            }\n            if (outputs.empty())\n                throw EvalError(format(\"derivation cannot have an empty set of outputs, at %1%\") % posDrvName);\n        };\n\n        try {\n\n            if (ignoreNulls) {\n                state.forceValue(*i->value);\n                if (i->value->type == tNull) continue;\n            }\n\n            /* The `args' attribute is special: it supplies the\n               command-line arguments to the builder. */\n            if (i->name == state.sArgs) {\n                state.forceList(*i->value, pos);\n                for (unsigned int n = 0; n < i->value->listSize(); ++n) {\n                    string s = state.coerceToString(posDrvName, *i->value->listElems()[n], context, true);\n                    drv.args.push_back(s);\n                }\n            }\n\n            /* All other attributes are passed to the builder through\n               the environment. */\n            else {\n\n                if (jsonObject) {\n\n                    if (i->name == state.sStructuredAttrs) continue;\n\n                    auto placeholder(jsonObject->placeholder(key));\n                    printValueAsJSON(state, true, *i->value, placeholder, context);\n\n                    if (i->name == state.sBuilder)\n                        drv.builder = state.forceString(*i->value, context, posDrvName);\n                    else if (i->name == state.sSystem)\n                        drv.platform = state.forceStringNoCtx(*i->value, posDrvName);\n                    else if (i->name == state.sOutputHash)\n                        outputHash = state.forceStringNoCtx(*i->value, posDrvName);\n                    else if (i->name == state.sOutputHashAlgo)\n                        outputHashAlgo = state.forceStringNoCtx(*i->value, posDrvName);\n                    else if (i->name == state.sOutputHashMode)\n                        handleHashMode(state.forceStringNoCtx(*i->value, posDrvName));\n                    else if (i->name == state.sOutputs) {\n                        /* Require \u2018outputs\u2019 to be a list of strings. */\n                        state.forceList(*i->value, posDrvName);\n                        Strings ss;\n                        for (unsigned int n = 0; n < i->value->listSize(); ++n)\n                            ss.emplace_back(state.forceStringNoCtx(*i->value->listElems()[n], posDrvName));\n                        handleOutputs(ss);\n                    }\n\n                } else {\n                    auto s = state.coerceToString(posDrvName, *i->value, context, true);\n                    drv.env.emplace(key, s);\n                    if (i->name == state.sBuilder) drv.builder = s;\n                    else if (i->name == state.sSystem) drv.platform = s;\n                    else if (i->name == state.sOutputHash) outputHash = s;\n                    else if (i->name == state.sOutputHashAlgo) outputHashAlgo = s;\n                    else if (i->name == state.sOutputHashMode) handleHashMode(s);\n                    else if (i->name == state.sOutputs)\n                        handleOutputs(tokenizeString<Strings>(s));\n                }\n\n            }\n\n        } catch (Error & e) {\n            e.addPrefix(format(\"while evaluating the attribute '%1%' of the derivation '%2%' at %3%:\\n\")\n                % key % drvName % posDrvName);\n            throw;\n        }\n    }\n\n    if (jsonObject) {\n        jsonObject.reset();\n        drv.env.emplace(\"__json\", jsonBuf.str());\n    }\n\n    /* Everything in the context of the strings in the derivation\n       attributes should be added as dependencies of the resulting\n       derivation. */\n    for (auto & path : context) {\n\n        /* Paths marked with `=' denote that the path of a derivation\n           is explicitly passed to the builder.  Since that allows the\n           builder to gain access to every path in the dependency\n           graph of the derivation (including all outputs), all paths\n           in the graph must be added to this derivation's list of\n           inputs to ensure that they are available when the builder\n           runs. */\n        if (path.at(0) == '=') {\n            /* !!! This doesn't work if readOnlyMode is set. */\n            PathSet refs;\n            state.store->computeFSClosure(string(path, 1), refs);\n            for (auto & j : refs) {\n                drv.inputSrcs.insert(j);\n                if (isDerivation(j))\n                    drv.inputDrvs[j] = state.store->queryDerivationOutputNames(j);\n            }\n        }\n\n        /* See prim_unsafeDiscardOutputDependency. */\n        else if (path.at(0) == '~')\n            drv.inputSrcs.insert(string(path, 1));\n\n        /* Handle derivation outputs of the form \u2018!<name>!<path>\u2019. */\n        else if (path.at(0) == '!') {\n            std::pair<string, string> ctx = decodeContext(path);\n            drv.inputDrvs[ctx.first].insert(ctx.second);\n        }\n\n        /* Handle derivation contexts returned by\n           \u2018builtins.storePath\u2019. */\n        else if (isDerivation(path))\n            drv.inputDrvs[path] = state.store->queryDerivationOutputNames(path);\n\n        /* Otherwise it's a source file. */\n        else\n            drv.inputSrcs.insert(path);\n    }\n\n    /* Do we have all required attributes? */\n    if (drv.builder == \"\")\n        throw EvalError(format(\"required attribute 'builder' missing, at %1%\") % posDrvName);\n    if (drv.platform == \"\")\n        throw EvalError(format(\"required attribute 'system' missing, at %1%\") % posDrvName);\n\n    /* Check whether the derivation name is valid. */\n    checkStoreName(drvName);\n    if (isDerivation(drvName))\n        throw EvalError(format(\"derivation names are not allowed to end in '%1%', at %2%\")\n            % drvExtension % posDrvName);\n\n    if (outputHash) {\n        /* Handle fixed-output derivations. */\n        if (outputs.size() != 1 || *(outputs.begin()) != \"out\")\n            throw Error(format(\"multiple outputs are not supported in fixed-output derivations, at %1%\") % posDrvName);\n\n        HashType ht = parseHashType(outputHashAlgo);\n        if (ht == htUnknown)\n            throw EvalError(format(\"unknown hash algorithm '%1%', at %2%\") % outputHashAlgo % posDrvName);\n        Hash h(*outputHash, ht);\n        outputHash = h.to_string(Base16, false);\n        if (outputHashRecursive) outputHashAlgo = \"r:\" + outputHashAlgo;\n\n        Path outPath = state.store->makeFixedOutputPath(outputHashRecursive, h, drvName);\n        if (!jsonObject) drv.env[\"out\"] = outPath;\n        drv.outputs[\"out\"] = DerivationOutput(outPath, outputHashAlgo, *outputHash);\n    }\n\n    else {\n        /* Construct the \"masked\" store derivation, which is the final\n           one except that in the list of outputs, the output paths\n           are empty, and the corresponding environment variables have\n           an empty value.  This ensures that changes in the set of\n           output names do get reflected in the hash. */\n        for (auto & i : outputs) {\n            if (!jsonObject) drv.env[i] = \"\";\n            drv.outputs[i] = DerivationOutput(\"\", \"\", \"\");\n        }\n\n        /* Use the masked derivation expression to compute the output\n           path. */\n        Hash h = hashDerivationModulo(*state.store, drv);\n\n        for (auto & i : drv.outputs)\n            if (i.second.path == \"\") {\n                Path outPath = state.store->makeOutputPath(i.first, h, drvName);\n                if (!jsonObject) drv.env[i.first] = outPath;\n                i.second.path = outPath;\n            }\n    }\n\n    /* Write the resulting term into the Nix store directory. */\n    Path drvPath = writeDerivation(state.store, drv, drvName, state.repair);\n\n    printMsg(lvlChatty, format(\"instantiated '%1%' -> '%2%'\")\n        % drvName % drvPath);\n\n    /* Optimisation, but required in read-only mode! because in that\n       case we don't actually write store derivations, so we can't\n       read them later. */\n    drvHashes[drvPath] = hashDerivationModulo(*state.store, drv);\n\n    state.mkAttrs(v, 1 + drv.outputs.size());\n    mkString(*state.allocAttr(v, state.sDrvPath), drvPath, {\"=\" + drvPath});\n    for (auto & i : drv.outputs) {\n        mkString(*state.allocAttr(v, state.symbols.create(i.first)),\n            i.second.path, {\"!\" + i.first + \"!\" + drvPath});\n    }\n    v.attrs->sort();\n}\n\n\n/* Return a placeholder string for the specified output that will be\n   substituted by the corresponding output path at build time. For\n   example, 'placeholder \"out\"' returns the string\n   /1rz4g4znpzjwh1xymhjpm42vipw92pr73vdgl6xs1hycac8kf2n9. At build\n   time, any occurence of this string in an derivation attribute will\n   be replaced with the concrete path in the Nix store of the output\n   \u2018out\u2019. */\nstatic void prim_placeholder(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    mkString(v, hashPlaceholder(state.forceStringNoCtx(*args[0], pos)));\n}\n\n\n/*************************************************************\n * Paths\n *************************************************************/\n\n\n/* Convert the argument to a path.  !!! obsolete? */\nstatic void prim_toPath(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    Path path = state.coerceToPath(pos, *args[0], context);\n    mkString(v, canonPath(path), context);\n}\n\n\n/* Allow a valid store path to be used in an expression.  This is\n   useful in some generated expressions such as in nix-push, which\n   generates a call to a function with an already existing store path\n   as argument.  You don't want to use `toPath' here because it copies\n   the path to the Nix store, which yields a copy like\n   /nix/store/newhash-oldhash-oldname.  In the past, `toPath' had\n   special case behaviour for store paths, but that created weird\n   corner cases. */\nstatic void prim_storePath(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    Path path = state.checkSourcePath(state.coerceToPath(pos, *args[0], context));\n    /* Resolve symlinks in \u2018path\u2019, unless \u2018path\u2019 itself is a symlink\n       directly in the store.  The latter condition is necessary so\n       e.g. nix-push does the right thing. */\n    if (!state.store->isStorePath(path)) path = canonPath(path, true);\n    if (!state.store->isInStore(path))\n        throw EvalError(format(\"path '%1%' is not in the Nix store, at %2%\") % path % pos);\n    Path path2 = state.store->toStorePath(path);\n    if (!settings.readOnlyMode)\n        state.store->ensurePath(path2);\n    context.insert(path2);\n    mkString(v, path, context);\n}\n\n\nstatic void prim_pathExists(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    Path path = state.coerceToPath(pos, *args[0], context);\n    if (!context.empty())\n        throw EvalError(format(\"string '%1%' cannot refer to other paths, at %2%\") % path % pos);\n    try {\n        mkBool(v, pathExists(state.checkSourcePath(path)));\n    } catch (SysError & e) {\n        /* Don't give away info from errors while canonicalising\n           \u2018path\u2019 in restricted mode. */\n        mkBool(v, false);\n    } catch (RestrictedPathError & e) {\n        mkBool(v, false);\n    }\n}\n\n\n/* Return the base name of the given string, i.e., everything\n   following the last slash. */\nstatic void prim_baseNameOf(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    mkString(v, baseNameOf(state.coerceToString(pos, *args[0], context, false, false)), context);\n}\n\n\n/* Return the directory of the given path, i.e., everything before the\n   last slash.  Return either a path or a string depending on the type\n   of the argument. */\nstatic void prim_dirOf(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    Path dir = dirOf(state.coerceToPath(pos, *args[0], context));\n    if (args[0]->type == tPath) mkPath(v, dir.c_str()); else mkString(v, dir, context);\n}\n\n\n/* Return the contents of a file as a string. */\nstatic void prim_readFile(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    Path path = state.coerceToPath(pos, *args[0], context);\n    try {\n        state.realiseContext(context);\n    } catch (InvalidPathError & e) {\n        throw EvalError(format(\"cannot read '%1%', since path '%2%' is not valid, at %3%\")\n            % path % e.path % pos);\n    }\n    string s = readFile(state.checkSourcePath(state.toRealPath(path, context)));\n    if (s.find((char) 0) != string::npos)\n        throw Error(format(\"the contents of the file '%1%' cannot be represented as a Nix string\") % path);\n    mkString(v, s.c_str());\n}\n\n\n/* Find a file in the Nix search path. Used to implement <x> paths,\n   which are desugared to 'findFile __nixPath \"x\"'. */\nstatic void prim_findFile(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceList(*args[0], pos);\n\n    SearchPath searchPath;\n\n    for (unsigned int n = 0; n < args[0]->listSize(); ++n) {\n        Value & v2(*args[0]->listElems()[n]);\n        state.forceAttrs(v2, pos);\n\n        string prefix;\n        Bindings::iterator i = v2.attrs->find(state.symbols.create(\"prefix\"));\n        if (i != v2.attrs->end())\n            prefix = state.forceStringNoCtx(*i->value, pos);\n\n        i = v2.attrs->find(state.symbols.create(\"path\"));\n        if (i == v2.attrs->end())\n            throw EvalError(format(\"attribute 'path' missing, at %1%\") % pos);\n\n        PathSet context;\n        string path = state.coerceToString(pos, *i->value, context, false, false);\n\n        try {\n            state.realiseContext(context);\n        } catch (InvalidPathError & e) {\n            throw EvalError(format(\"cannot find '%1%', since path '%2%' is not valid, at %3%\")\n                % path % e.path % pos);\n        }\n\n        searchPath.emplace_back(prefix, path);\n    }\n\n    string path = state.forceStringNoCtx(*args[1], pos);\n\n    mkPath(v, state.checkSourcePath(state.findFile(searchPath, path, pos)).c_str());\n}\n\n/* Read a directory (without . or ..) */\nstatic void prim_readDir(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet ctx;\n    Path path = state.coerceToPath(pos, *args[0], ctx);\n    try {\n        state.realiseContext(ctx);\n    } catch (InvalidPathError & e) {\n        throw EvalError(format(\"cannot read '%1%', since path '%2%' is not valid, at %3%\")\n            % path % e.path % pos);\n    }\n\n    DirEntries entries = readDirectory(state.checkSourcePath(path));\n    state.mkAttrs(v, entries.size());\n\n    for (auto & ent : entries) {\n        Value * ent_val = state.allocAttr(v, state.symbols.create(ent.name));\n        if (ent.type == DT_UNKNOWN)\n            ent.type = getFileType(path + \"/\" + ent.name);\n        mkStringNoCopy(*ent_val,\n            ent.type == DT_REG ? \"regular\" :\n            ent.type == DT_DIR ? \"directory\" :\n            ent.type == DT_LNK ? \"symlink\" :\n            \"unknown\");\n    }\n\n    v.attrs->sort();\n}\n\n\n/*************************************************************\n * Creating files\n *************************************************************/\n\n\n/* Convert the argument (which can be any Nix expression) to an XML\n   representation returned in a string.  Not all Nix expressions can\n   be sensibly or completely represented (e.g., functions). */\nstatic void prim_toXML(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    std::ostringstream out;\n    PathSet context;\n    printValueAsXML(state, true, false, *args[0], out, context);\n    mkString(v, out.str(), context);\n}\n\n\n/* Convert the argument (which can be any Nix expression) to a JSON\n   string.  Not all Nix expressions can be sensibly or completely\n   represented (e.g., functions). */\nstatic void prim_toJSON(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    std::ostringstream out;\n    PathSet context;\n    printValueAsJSON(state, true, *args[0], out, context);\n    mkString(v, out.str(), context);\n}\n\n\n/* Parse a JSON string to a value. */\nstatic void prim_fromJSON(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    string s = state.forceStringNoCtx(*args[0], pos);\n    parseJSON(state, s, v);\n}\n\n\n/* Store a string in the Nix store as a source file that can be used\n   as an input by derivations. */\nstatic void prim_toFile(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    string name = state.forceStringNoCtx(*args[0], pos);\n    string contents = state.forceString(*args[1], context, pos);\n\n    PathSet refs;\n\n    for (auto path : context) {\n        if (path.at(0) == '=') path = string(path, 1);\n        if (isDerivation(path)) {\n            /* See prim_unsafeDiscardOutputDependency. */\n            if (path.at(0) != '~')\n                throw EvalError(format(\"in 'toFile': the file '%1%' cannot refer to derivation outputs, at %2%\") % name % pos);\n            path = string(path, 1);\n        }\n        refs.insert(path);\n    }\n\n    Path storePath = settings.readOnlyMode\n        ? state.store->computeStorePathForText(name, contents, refs)\n        : state.store->addTextToStore(name, contents, refs, state.repair);\n\n    /* Note: we don't need to add `context' to the context of the\n       result, since `storePath' itself has references to the paths\n       used in args[1]. */\n\n    mkString(v, storePath, {storePath});\n}\n\n\nstatic void addPath(EvalState & state, const Pos & pos, const string & name, const Path & path_,\n    Value * filterFun, bool recursive, const Hash & expectedHash, Value & v)\n{\n    const auto path = settings.pureEval && expectedHash ?\n        path_ :\n        state.checkSourcePath(path_);\n    PathFilter filter = filterFun ? ([&](const Path & path) {\n        auto st = lstat(path);\n\n        /* Call the filter function.  The first argument is the path,\n           the second is a string indicating the type of the file. */\n        Value arg1;\n        mkString(arg1, path);\n\n        Value fun2;\n        state.callFunction(*filterFun, arg1, fun2, noPos);\n\n        Value arg2;\n        mkString(arg2,\n            S_ISREG(st.st_mode) ? \"regular\" :\n            S_ISDIR(st.st_mode) ? \"directory\" :\n            S_ISLNK(st.st_mode) ? \"symlink\" :\n            \"unknown\" /* not supported, will fail! */);\n\n        Value res;\n        state.callFunction(fun2, arg2, res, noPos);\n\n        return state.forceBool(res, pos);\n    }) : defaultPathFilter;\n\n    Path expectedStorePath;\n    if (expectedHash) {\n        expectedStorePath =\n            state.store->makeFixedOutputPath(recursive, expectedHash, name);\n    }\n    Path dstPath;\n    if (!expectedHash || !state.store->isValidPath(expectedStorePath)) {\n        dstPath = settings.readOnlyMode\n            ? state.store->computeStorePathForPath(name, path, recursive, htSHA256, filter).first\n            : state.store->addToStore(name, path, recursive, htSHA256, filter, state.repair);\n        if (expectedHash && expectedStorePath != dstPath) {\n            throw Error(format(\"store path mismatch in (possibly filtered) path added from '%1%'\") % path);\n        }\n    } else\n        dstPath = expectedStorePath;\n\n    mkString(v, dstPath, {dstPath});\n}\n\n\nstatic void prim_filterSource(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    Path path = state.coerceToPath(pos, *args[1], context);\n    if (!context.empty())\n        throw EvalError(format(\"string '%1%' cannot refer to other paths, at %2%\") % path % pos);\n\n    state.forceValue(*args[0]);\n    if (args[0]->type != tLambda)\n        throw TypeError(format(\"first argument in call to 'filterSource' is not a function but %1%, at %2%\") % showType(*args[0]) % pos);\n\n    addPath(state, pos, baseNameOf(path), path, args[0], true, Hash(), v);\n}\n\nstatic void prim_path(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceAttrs(*args[0], pos);\n    Path path;\n    string name;\n    Value * filterFun = nullptr;\n    auto recursive = true;\n    Hash expectedHash;\n\n    for (auto & attr : *args[0]->attrs) {\n        const string & n(attr.name);\n        if (n == \"path\") {\n            PathSet context;\n            path = state.coerceToPath(*attr.pos, *attr.value, context);\n            if (!context.empty())\n                throw EvalError(format(\"string '%1%' cannot refer to other paths, at %2%\") % path % *attr.pos);\n        } else if (attr.name == state.sName)\n            name = state.forceStringNoCtx(*attr.value, *attr.pos);\n        else if (n == \"filter\") {\n            state.forceValue(*attr.value);\n            filterFun = attr.value;\n        } else if (n == \"recursive\")\n            recursive = state.forceBool(*attr.value, *attr.pos);\n        else if (n == \"sha256\")\n            expectedHash = Hash(state.forceStringNoCtx(*attr.value, *attr.pos), htSHA256);\n        else\n            throw EvalError(format(\"unsupported argument '%1%' to 'addPath', at %2%\") % attr.name % *attr.pos);\n    }\n    if (path.empty())\n        throw EvalError(format(\"'path' required, at %1%\") % pos);\n    if (name.empty())\n        name = baseNameOf(path);\n\n    addPath(state, pos, name, path, filterFun, recursive, expectedHash, v);\n}\n\n\n/*************************************************************\n * Sets\n *************************************************************/\n\n\n/* Return the names of the attributes in a set as a sorted list of\n   strings. */\nstatic void prim_attrNames(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceAttrs(*args[0], pos);\n\n    state.mkList(v, args[0]->attrs->size());\n\n    size_t n = 0;\n    for (auto & i : *args[0]->attrs)\n        mkString(*(v.listElems()[n++] = state.allocValue()), i.name);\n\n    std::sort(v.listElems(), v.listElems() + n,\n              [](Value * v1, Value * v2) { return strcmp(v1->string.s, v2->string.s) < 0; });\n}\n\n\n/* Return the values of the attributes in a set as a list, in the same\n   order as attrNames. */\nstatic void prim_attrValues(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceAttrs(*args[0], pos);\n\n    state.mkList(v, args[0]->attrs->size());\n\n    unsigned int n = 0;\n    for (auto & i : *args[0]->attrs)\n        v.listElems()[n++] = (Value *) &i;\n\n    std::sort(v.listElems(), v.listElems() + n,\n        [](Value * v1, Value * v2) { return (string) ((Attr *) v1)->name < (string) ((Attr *) v2)->name; });\n\n    for (unsigned int i = 0; i < n; ++i)\n        v.listElems()[i] = ((Attr *) v.listElems()[i])->value;\n}\n\n\n/* Dynamic version of the `.' operator. */\nvoid prim_getAttr(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    string attr = state.forceStringNoCtx(*args[0], pos);\n    state.forceAttrs(*args[1], pos);\n    // !!! Should we create a symbol here or just do a lookup?\n    Bindings::iterator i = args[1]->attrs->find(state.symbols.create(attr));\n    if (i == args[1]->attrs->end())\n        throw EvalError(format(\"attribute '%1%' missing, at %2%\") % attr % pos);\n    // !!! add to stack trace?\n    if (state.countCalls && i->pos) state.attrSelects[*i->pos]++;\n    state.forceValue(*i->value);\n    v = *i->value;\n}\n\n\n/* Return position information of the specified attribute. */\nvoid prim_unsafeGetAttrPos(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    string attr = state.forceStringNoCtx(*args[0], pos);\n    state.forceAttrs(*args[1], pos);\n    Bindings::iterator i = args[1]->attrs->find(state.symbols.create(attr));\n    if (i == args[1]->attrs->end())\n        mkNull(v);\n    else\n        state.mkPos(v, i->pos);\n}\n\n\n/* Dynamic version of the `?' operator. */\nstatic void prim_hasAttr(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    string attr = state.forceStringNoCtx(*args[0], pos);\n    state.forceAttrs(*args[1], pos);\n    mkBool(v, args[1]->attrs->find(state.symbols.create(attr)) != args[1]->attrs->end());\n}\n\n\n/* Determine whether the argument is a set. */\nstatic void prim_isAttrs(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    mkBool(v, args[0]->type == tAttrs);\n}\n\n\nstatic void prim_removeAttrs(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceAttrs(*args[0], pos);\n    state.forceList(*args[1], pos);\n\n    /* Get the attribute names to be removed. */\n    std::set<Symbol> names;\n    for (unsigned int i = 0; i < args[1]->listSize(); ++i) {\n        state.forceStringNoCtx(*args[1]->listElems()[i], pos);\n        names.insert(state.symbols.create(args[1]->listElems()[i]->string.s));\n    }\n\n    /* Copy all attributes not in that set.  Note that we don't need\n       to sort v.attrs because it's a subset of an already sorted\n       vector. */\n    state.mkAttrs(v, args[0]->attrs->size());\n    for (auto & i : *args[0]->attrs) {\n        if (names.find(i.name) == names.end())\n            v.attrs->push_back(i);\n    }\n}\n\n\n/* Builds a set from a list specifying (name, value) pairs.  To be\n   precise, a list [{name = \"name1\"; value = value1;} ... {name =\n   \"nameN\"; value = valueN;}] is transformed to {name1 = value1;\n   ... nameN = valueN;}.  In case of duplicate occurences of the same\n   name, the first takes precedence. */\nstatic void prim_listToAttrs(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceList(*args[0], pos);\n\n    state.mkAttrs(v, args[0]->listSize());\n\n    std::set<Symbol> seen;\n\n    for (unsigned int i = 0; i < args[0]->listSize(); ++i) {\n        Value & v2(*args[0]->listElems()[i]);\n        state.forceAttrs(v2, pos);\n\n        Bindings::iterator j = v2.attrs->find(state.sName);\n        if (j == v2.attrs->end())\n            throw TypeError(format(\"'name' attribute missing in a call to 'listToAttrs', at %1%\") % pos);\n        string name = state.forceStringNoCtx(*j->value, pos);\n\n        Symbol sym = state.symbols.create(name);\n        if (seen.find(sym) == seen.end()) {\n            Bindings::iterator j2 = v2.attrs->find(state.symbols.create(state.sValue));\n            if (j2 == v2.attrs->end())\n                throw TypeError(format(\"'value' attribute missing in a call to 'listToAttrs', at %1%\") % pos);\n\n            v.attrs->push_back(Attr(sym, j2->value, j2->pos));\n            seen.insert(sym);\n        }\n    }\n\n    v.attrs->sort();\n}\n\n\n/* Return the right-biased intersection of two sets as1 and as2,\n   i.e. a set that contains every attribute from as2 that is also a\n   member of as1. */\nstatic void prim_intersectAttrs(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceAttrs(*args[0], pos);\n    state.forceAttrs(*args[1], pos);\n\n    state.mkAttrs(v, std::min(args[0]->attrs->size(), args[1]->attrs->size()));\n\n    for (auto & i : *args[0]->attrs) {\n        Bindings::iterator j = args[1]->attrs->find(i.name);\n        if (j != args[1]->attrs->end())\n            v.attrs->push_back(*j);\n    }\n}\n\n\n/* Collect each attribute named `attr' from a list of attribute sets.\n   Sets that don't contain the named attribute are ignored.\n\n   Example:\n     catAttrs \"a\" [{a = 1;} {b = 0;} {a = 2;}]\n     => [1 2]\n*/\nstatic void prim_catAttrs(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    Symbol attrName = state.symbols.create(state.forceStringNoCtx(*args[0], pos));\n    state.forceList(*args[1], pos);\n\n    Value * res[args[1]->listSize()];\n    unsigned int found = 0;\n\n    for (unsigned int n = 0; n < args[1]->listSize(); ++n) {\n        Value & v2(*args[1]->listElems()[n]);\n        state.forceAttrs(v2, pos);\n        Bindings::iterator i = v2.attrs->find(attrName);\n        if (i != v2.attrs->end())\n            res[found++] = i->value;\n    }\n\n    state.mkList(v, found);\n    for (unsigned int n = 0; n < found; ++n)\n        v.listElems()[n] = res[n];\n}\n\n\n/* Return a set containing the names of the formal arguments expected\n   by the function `f'.  The value of each attribute is a Boolean\n   denoting whether the corresponding argument has a default value.  For instance,\n\n      functionArgs ({ x, y ? 123}: ...)\n   => { x = false; y = true; }\n\n   \"Formal argument\" here refers to the attributes pattern-matched by\n   the function.  Plain lambdas are not included, e.g.\n\n      functionArgs (x: ...)\n   => { }\n*/\nstatic void prim_functionArgs(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    if (args[0]->type != tLambda)\n        throw TypeError(format(\"'functionArgs' requires a function, at %1%\") % pos);\n\n    if (!args[0]->lambda.fun->matchAttrs) {\n        state.mkAttrs(v, 0);\n        return;\n    }\n\n    state.mkAttrs(v, args[0]->lambda.fun->formals->formals.size());\n    for (auto & i : args[0]->lambda.fun->formals->formals)\n        // !!! should optimise booleans (allocate only once)\n        mkBool(*state.allocAttr(v, i.name), i.def);\n    v.attrs->sort();\n}\n\n\n/*************************************************************\n * Lists\n *************************************************************/\n\n\n/* Determine whether the argument is a list. */\nstatic void prim_isList(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    mkBool(v, args[0]->isList());\n}\n\n\nstatic void elemAt(EvalState & state, const Pos & pos, Value & list, int n, Value & v)\n{\n    state.forceList(list, pos);\n    if (n < 0 || (unsigned int) n >= list.listSize())\n        throw Error(format(\"list index %1% is out of bounds, at %2%\") % n % pos);\n    state.forceValue(*list.listElems()[n]);\n    v = *list.listElems()[n];\n}\n\n\n/* Return the n-1'th element of a list. */\nstatic void prim_elemAt(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    elemAt(state, pos, *args[0], state.forceInt(*args[1], pos), v);\n}\n\n\n/* Return the first element of a list. */\nstatic void prim_head(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    elemAt(state, pos, *args[0], 0, v);\n}\n\n\n/* Return a list consisting of everything but the first element of\n   a list.  Warning: this function takes O(n) time, so you probably\n   don't want to use it!  */\nstatic void prim_tail(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceList(*args[0], pos);\n    if (args[0]->listSize() == 0)\n        throw Error(format(\"'tail' called on an empty list, at %1%\") % pos);\n    state.mkList(v, args[0]->listSize() - 1);\n    for (unsigned int n = 0; n < v.listSize(); ++n)\n        v.listElems()[n] = args[0]->listElems()[n + 1];\n}\n\n\n/* Apply a function to every element of a list. */\nstatic void prim_map(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceFunction(*args[0], pos);\n    state.forceList(*args[1], pos);\n\n    state.mkList(v, args[1]->listSize());\n\n    for (unsigned int n = 0; n < v.listSize(); ++n)\n        mkApp(*(v.listElems()[n] = state.allocValue()),\n            *args[0], *args[1]->listElems()[n]);\n}\n\n\n/* Filter a list using a predicate; that is, return a list containing\n   every element from the list for which the predicate function\n   returns true. */\nstatic void prim_filter(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceFunction(*args[0], pos);\n    state.forceList(*args[1], pos);\n\n    // FIXME: putting this on the stack is risky.\n    Value * vs[args[1]->listSize()];\n    unsigned int k = 0;\n\n    bool same = true;\n    for (unsigned int n = 0; n < args[1]->listSize(); ++n) {\n        Value res;\n        state.callFunction(*args[0], *args[1]->listElems()[n], res, noPos);\n        if (state.forceBool(res, pos))\n            vs[k++] = args[1]->listElems()[n];\n        else\n            same = false;\n    }\n\n    if (same)\n        v = *args[1];\n    else {\n        state.mkList(v, k);\n        for (unsigned int n = 0; n < k; ++n) v.listElems()[n] = vs[n];\n    }\n}\n\n\n/* Return true if a list contains a given element. */\nstatic void prim_elem(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    bool res = false;\n    state.forceList(*args[1], pos);\n    for (unsigned int n = 0; n < args[1]->listSize(); ++n)\n        if (state.eqValues(*args[0], *args[1]->listElems()[n])) {\n            res = true;\n            break;\n        }\n    mkBool(v, res);\n}\n\n\n/* Concatenate a list of lists. */\nstatic void prim_concatLists(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceList(*args[0], pos);\n    state.concatLists(v, args[0]->listSize(), args[0]->listElems(), pos);\n}\n\n\n/* Return the length of a list.  This is an O(1) time operation. */\nstatic void prim_length(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceList(*args[0], pos);\n    mkInt(v, args[0]->listSize());\n}\n\n\n/* Reduce a list by applying a binary operator, from left to\n   right. The operator is applied strictly. */\nstatic void prim_foldlStrict(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceFunction(*args[0], pos);\n    state.forceList(*args[2], pos);\n\n    Value * vCur = args[1];\n\n    if (args[2]->listSize())\n        for (unsigned int n = 0; n < args[2]->listSize(); ++n) {\n            Value vTmp;\n            state.callFunction(*args[0], *vCur, vTmp, pos);\n            vCur = n == args[2]->listSize() - 1 ? &v : state.allocValue();\n            state.callFunction(vTmp, *args[2]->listElems()[n], *vCur, pos);\n        }\n    else\n        v = *vCur;\n\n    state.forceValue(v);\n}\n\n\nstatic void anyOrAll(bool any, EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceFunction(*args[0], pos);\n    state.forceList(*args[1], pos);\n\n    Value vTmp;\n    for (unsigned int n = 0; n < args[1]->listSize(); ++n) {\n        state.callFunction(*args[0], *args[1]->listElems()[n], vTmp, pos);\n        bool res = state.forceBool(vTmp, pos);\n        if (res == any) {\n            mkBool(v, any);\n            return;\n        }\n    }\n\n    mkBool(v, !any);\n}\n\n\nstatic void prim_any(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    anyOrAll(true, state, pos, args, v);\n}\n\n\nstatic void prim_all(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    anyOrAll(false, state, pos, args, v);\n}\n\n\nstatic void prim_genList(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceFunction(*args[0], pos);\n    auto len = state.forceInt(*args[1], pos);\n\n    if (len < 0)\n        throw EvalError(format(\"cannot create list of size %1%, at %2%\") % len % pos);\n\n    state.mkList(v, len);\n\n    for (unsigned int n = 0; n < (unsigned int) len; ++n) {\n        Value * arg = state.allocValue();\n        mkInt(*arg, n);\n        mkApp(*(v.listElems()[n] = state.allocValue()), *args[0], *arg);\n    }\n}\n\n\nstatic void prim_lessThan(EvalState & state, const Pos & pos, Value * * args, Value & v);\n\n\nstatic void prim_sort(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceFunction(*args[0], pos);\n    state.forceList(*args[1], pos);\n\n    auto len = args[1]->listSize();\n    state.mkList(v, len);\n    for (unsigned int n = 0; n < len; ++n) {\n        state.forceValue(*args[1]->listElems()[n]);\n        v.listElems()[n] = args[1]->listElems()[n];\n    }\n\n\n    auto comparator = [&](Value * a, Value * b) {\n        /* Optimization: if the comparator is lessThan, bypass\n           callFunction. */\n        if (args[0]->type == tPrimOp && args[0]->primOp->fun == prim_lessThan)\n            return CompareValues()(a, b);\n\n        Value vTmp1, vTmp2;\n        state.callFunction(*args[0], *a, vTmp1, pos);\n        state.callFunction(vTmp1, *b, vTmp2, pos);\n        return state.forceBool(vTmp2, pos);\n    };\n\n    /* FIXME: std::sort can segfault if the comparator is not a strict\n       weak ordering. What to do? std::stable_sort() seems more\n       resilient, but no guarantees... */\n    std::stable_sort(v.listElems(), v.listElems() + len, comparator);\n}\n\n\nstatic void prim_partition(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceFunction(*args[0], pos);\n    state.forceList(*args[1], pos);\n\n    auto len = args[1]->listSize();\n\n    ValueVector right, wrong;\n\n    for (unsigned int n = 0; n < len; ++n) {\n        auto vElem = args[1]->listElems()[n];\n        state.forceValue(*vElem);\n        Value res;\n        state.callFunction(*args[0], *vElem, res, pos);\n        if (state.forceBool(res, pos))\n            right.push_back(vElem);\n        else\n            wrong.push_back(vElem);\n    }\n\n    state.mkAttrs(v, 2);\n\n    Value * vRight = state.allocAttr(v, state.sRight);\n    state.mkList(*vRight, right.size());\n    memcpy(vRight->listElems(), right.data(), sizeof(Value *) * right.size());\n\n    Value * vWrong = state.allocAttr(v, state.sWrong);\n    state.mkList(*vWrong, wrong.size());\n    memcpy(vWrong->listElems(), wrong.data(), sizeof(Value *) * wrong.size());\n\n    v.attrs->sort();\n}\n\n\n/*************************************************************\n * Integer arithmetic\n *************************************************************/\n\n\nstatic void prim_add(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    if (args[0]->type == tFloat || args[1]->type == tFloat)\n        mkFloat(v, state.forceFloat(*args[0], pos) + state.forceFloat(*args[1], pos));\n    else\n        mkInt(v, state.forceInt(*args[0], pos) + state.forceInt(*args[1], pos));\n}\n\n\nstatic void prim_sub(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    if (args[0]->type == tFloat || args[1]->type == tFloat)\n        mkFloat(v, state.forceFloat(*args[0], pos) - state.forceFloat(*args[1], pos));\n    else\n        mkInt(v, state.forceInt(*args[0], pos) - state.forceInt(*args[1], pos));\n}\n\n\nstatic void prim_mul(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    if (args[0]->type == tFloat || args[1]->type == tFloat)\n        mkFloat(v, state.forceFloat(*args[0], pos) * state.forceFloat(*args[1], pos));\n    else\n        mkInt(v, state.forceInt(*args[0], pos) * state.forceInt(*args[1], pos));\n}\n\n\nstatic void prim_div(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    NixFloat f2 = state.forceFloat(*args[1], pos);\n    if (f2 == 0) throw EvalError(format(\"division by zero, at %1%\") % pos);\n\n    if (args[0]->type == tFloat || args[1]->type == tFloat) {\n        mkFloat(v, state.forceFloat(*args[0], pos) / state.forceFloat(*args[1], pos));\n    } else {\n        NixInt i1 = state.forceInt(*args[0], pos);\n        NixInt i2 = state.forceInt(*args[1], pos);\n        /* Avoid division overflow as it might raise SIGFPE. */\n        if (i1 == std::numeric_limits<NixInt>::min() && i2 == -1)\n            throw EvalError(format(\"overflow in integer division, at %1%\") % pos);\n        mkInt(v, i1 / i2);\n    }\n}\n\n\nstatic void prim_lessThan(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceValue(*args[0]);\n    state.forceValue(*args[1]);\n    CompareValues comp;\n    mkBool(v, comp(args[0], args[1]));\n}\n\n\n/*************************************************************\n * String manipulation\n *************************************************************/\n\n\n/* Convert the argument to a string.  Paths are *not* copied to the\n   store, so `toString /foo/bar' yields `\"/foo/bar\"', not\n   `\"/nix/store/whatever...\"'. */\nstatic void prim_toString(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    string s = state.coerceToString(pos, *args[0], context, true, false);\n    mkString(v, s, context);\n}\n\n\n/* `substring start len str' returns the substring of `str' starting\n   at character position `min(start, stringLength str)' inclusive and\n   ending at `min(start + len, stringLength str)'.  `start' must be\n   non-negative. */\nstatic void prim_substring(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    int start = state.forceInt(*args[0], pos);\n    int len = state.forceInt(*args[1], pos);\n    PathSet context;\n    string s = state.coerceToString(pos, *args[2], context);\n\n    if (start < 0) throw EvalError(format(\"negative start position in 'substring', at %1%\") % pos);\n\n    mkString(v, (unsigned int) start >= s.size() ? \"\" : string(s, start, len), context);\n}\n\n\nstatic void prim_stringLength(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    string s = state.coerceToString(pos, *args[0], context);\n    mkInt(v, s.size());\n}\n\n\nstatic void prim_unsafeDiscardStringContext(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    string s = state.coerceToString(pos, *args[0], context);\n    mkString(v, s, PathSet());\n}\n\n\nstatic void prim_hasContext(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    state.forceString(*args[0], context, pos);\n    mkBool(v, !context.empty());\n}\n\n\n/* Sometimes we want to pass a derivation path (i.e. pkg.drvPath) to a\n   builder without causing the derivation to be built (for instance,\n   in the derivation that builds NARs in nix-push, when doing\n   source-only deployment).  This primop marks the string context so\n   that builtins.derivation adds the path to drv.inputSrcs rather than\n   drv.inputDrvs. */\nstatic void prim_unsafeDiscardOutputDependency(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n    string s = state.coerceToString(pos, *args[0], context);\n\n    PathSet context2;\n    for (auto & p : context)\n        context2.insert(p.at(0) == '=' ? \"~\" + string(p, 1) : p);\n\n    mkString(v, s, context2);\n}\n\n\n/* Return the cryptographic hash of a string in base-16. */\nstatic void prim_hashString(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    string type = state.forceStringNoCtx(*args[0], pos);\n    HashType ht = parseHashType(type);\n    if (ht == htUnknown)\n      throw Error(format(\"unknown hash type '%1%', at %2%\") % type % pos);\n\n    PathSet context; // discarded\n    string s = state.forceString(*args[1], context, pos);\n\n    mkString(v, hashString(ht, s).to_string(Base16, false), context);\n}\n\n\n/* Match a regular expression against a string and return either\n   \u2018null\u2019 or a list containing substring matches. */\nstatic void prim_match(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    auto re = state.forceStringNoCtx(*args[0], pos);\n\n    try {\n\n        std::regex regex(re, std::regex::extended);\n\n        PathSet context;\n        const std::string str = state.forceString(*args[1], context, pos);\n\n        std::smatch match;\n        if (!std::regex_match(str, match, regex)) {\n            mkNull(v);\n            return;\n        }\n\n        // the first match is the whole string\n        const size_t len = match.size() - 1;\n        state.mkList(v, len);\n        for (size_t i = 0; i < len; ++i) {\n            if (!match[i+1].matched)\n                mkNull(*(v.listElems()[i] = state.allocValue()));\n            else\n                mkString(*(v.listElems()[i] = state.allocValue()), match[i + 1].str().c_str());\n        }\n\n    } catch (std::regex_error &e) {\n        if (e.code() == std::regex_constants::error_space) {\n          // limit is _GLIBCXX_REGEX_STATE_LIMIT for libstdc++\n          throw EvalError(\"memory limit exceeded by regular expression '%s', at %s\", re, pos);\n        } else {\n          throw EvalError(\"invalid regular expression '%s', at %s\", re, pos);\n        }\n    }\n}\n\n\n/* Split a string with a regular expression, and return a list of the\n   non-matching parts interleaved by the lists of the matching groups. */\nstatic void prim_split(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    auto re = state.forceStringNoCtx(*args[0], pos);\n\n    try {\n\n        std::regex regex(re, std::regex::extended);\n\n        PathSet context;\n        const std::string str = state.forceString(*args[1], context, pos);\n\n        auto begin = std::sregex_iterator(str.begin(), str.end(), regex);\n        auto end = std::sregex_iterator();\n\n        // Any matches results are surrounded by non-matching results.\n        const size_t len = std::distance(begin, end);\n        state.mkList(v, 2 * len + 1);\n        size_t idx = 0;\n        Value * elem;\n\n        if (len == 0) {\n            v.listElems()[idx++] = args[1];\n            return;\n        }\n\n        for (std::sregex_iterator i = begin; i != end; ++i) {\n            assert(idx <= 2 * len + 1 - 3);\n            std::smatch match = *i;\n\n            // Add a string for non-matched characters.\n            elem = v.listElems()[idx++] = state.allocValue();\n            mkString(*elem, match.prefix().str().c_str());\n\n            // Add a list for matched substrings.\n            const size_t slen = match.size() - 1;\n            elem = v.listElems()[idx++] = state.allocValue();\n\n            // Start at 1, beacause the first match is the whole string.\n            state.mkList(*elem, slen);\n            for (size_t si = 0; si < slen; ++si) {\n                if (!match[si + 1].matched)\n                    mkNull(*(elem->listElems()[si] = state.allocValue()));\n                else\n                    mkString(*(elem->listElems()[si] = state.allocValue()), match[si + 1].str().c_str());\n            }\n\n            // Add a string for non-matched suffix characters.\n            if (idx == 2 * len) {\n                elem = v.listElems()[idx++] = state.allocValue();\n                mkString(*elem, match.suffix().str().c_str());\n            }\n        }\n        assert(idx == 2 * len + 1);\n\n    } catch (std::regex_error &e) {\n        if (e.code() == std::regex_constants::error_space) {\n          // limit is _GLIBCXX_REGEX_STATE_LIMIT for libstdc++\n          throw EvalError(\"memory limit exceeded by regular expression '%s', at %s\", re, pos);\n        } else {\n          throw EvalError(\"invalid regular expression '%s', at %s\", re, pos);\n        }\n    }\n}\n\n\nstatic void prim_concatStringSep(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    PathSet context;\n\n    auto sep = state.forceString(*args[0], context, pos);\n    state.forceList(*args[1], pos);\n\n    string res;\n    res.reserve((args[1]->listSize() + 32) * sep.size());\n    bool first = true;\n\n    for (unsigned int n = 0; n < args[1]->listSize(); ++n) {\n        if (first) first = false; else res += sep;\n        res += state.coerceToString(pos, *args[1]->listElems()[n], context);\n    }\n\n    mkString(v, res, context);\n}\n\n\nstatic void prim_replaceStrings(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    state.forceList(*args[0], pos);\n    state.forceList(*args[1], pos);\n    if (args[0]->listSize() != args[1]->listSize())\n        throw EvalError(format(\"'from' and 'to' arguments to 'replaceStrings' have different lengths, at %1%\") % pos);\n\n    vector<string> from;\n    from.reserve(args[0]->listSize());\n    for (unsigned int n = 0; n < args[0]->listSize(); ++n)\n        from.push_back(state.forceString(*args[0]->listElems()[n], pos));\n\n    vector<std::pair<string, PathSet>> to;\n    to.reserve(args[1]->listSize());\n    for (unsigned int n = 0; n < args[1]->listSize(); ++n) {\n        PathSet ctx;\n        auto s = state.forceString(*args[1]->listElems()[n], ctx, pos);\n        to.push_back(std::make_pair(std::move(s), std::move(ctx)));\n    }\n\n    PathSet context;\n    auto s = state.forceString(*args[2], context, pos);\n\n    string res;\n    // Loops one past last character to handle the case where 'from' contains an empty string.\n    for (size_t p = 0; p <= s.size(); ) {\n        bool found = false;\n        auto i = from.begin();\n        auto j = to.begin();\n        for (; i != from.end(); ++i, ++j)\n            if (s.compare(p, i->size(), *i) == 0) {\n                found = true;\n                res += j->first;\n                if (i->empty()) {\n                    if (p < s.size())\n                        res += s[p];\n                    p++;\n                } else {\n                    p += i->size();\n                }\n                for (auto& path : j->second)\n                    context.insert(path);\n                j->second.clear();\n                break;\n            }\n        if (!found) {\n            if (p < s.size())\n                res += s[p];\n            p++;\n        }\n    }\n\n    mkString(v, res, context);\n}\n\n\n/*************************************************************\n * Versions\n *************************************************************/\n\n\nstatic void prim_parseDrvName(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    string name = state.forceStringNoCtx(*args[0], pos);\n    DrvName parsed(name);\n    state.mkAttrs(v, 2);\n    mkString(*state.allocAttr(v, state.sName), parsed.name);\n    mkString(*state.allocAttr(v, state.symbols.create(\"version\")), parsed.version);\n    v.attrs->sort();\n}\n\n\nstatic void prim_compareVersions(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    string version1 = state.forceStringNoCtx(*args[0], pos);\n    string version2 = state.forceStringNoCtx(*args[1], pos);\n    mkInt(v, compareVersions(version1, version2));\n}\n\n\nstatic void prim_splitVersion(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    string version = state.forceStringNoCtx(*args[0], pos);\n    auto iter = version.cbegin();\n    Strings components;\n    while (iter != version.cend()) {\n        auto component = nextComponent(iter, version.cend());\n        if (component.empty())\n            break;\n        components.emplace_back(std::move(component));\n    }\n    state.mkList(v, components.size());\n    unsigned int n = 0;\n    for (auto & component : components) {\n        auto listElem = v.listElems()[n++] = state.allocValue();\n        mkString(*listElem, std::move(component));\n    }\n}\n\n\n/*************************************************************\n * Networking\n *************************************************************/\n\n\nvoid fetch(EvalState & state, const Pos & pos, Value * * args, Value & v,\n    const string & who, bool unpack, const std::string & defaultName)\n{\n    string url;\n    Hash expectedHash;\n    string name = defaultName;\n\n    state.forceValue(*args[0]);\n\n    if (args[0]->type == tAttrs) {\n\n        state.forceAttrs(*args[0], pos);\n\n        for (auto & attr : *args[0]->attrs) {\n            string n(attr.name);\n            if (n == \"url\")\n                url = state.forceStringNoCtx(*attr.value, *attr.pos);\n            else if (n == \"sha256\")\n                expectedHash = Hash(state.forceStringNoCtx(*attr.value, *attr.pos), htSHA256);\n            else if (n == \"name\")\n                name = state.forceStringNoCtx(*attr.value, *attr.pos);\n            else\n                throw EvalError(format(\"unsupported argument '%1%' to '%2%', at %3%\") % attr.name % who % attr.pos);\n        }\n\n        if (url.empty())\n            throw EvalError(format(\"'url' argument required, at %1%\") % pos);\n\n    } else\n        url = state.forceStringNoCtx(*args[0], pos);\n\n    state.checkURI(url);\n\n    if (settings.pureEval && !expectedHash)\n        throw Error(\"in pure evaluation mode, '%s' requires a 'sha256' argument\", who);\n\n    Path res = getDownloader()->downloadCached(state.store, url, unpack, name, expectedHash);\n\n    if (state.allowedPaths)\n        state.allowedPaths->insert(res);\n\n    mkString(v, res, PathSet({res}));\n}\n\n\nstatic void prim_fetchurl(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    fetch(state, pos, args, v, \"fetchurl\", false, \"\");\n}\n\n\nstatic void prim_fetchTarball(EvalState & state, const Pos & pos, Value * * args, Value & v)\n{\n    fetch(state, pos, args, v, \"fetchTarball\", true, \"source\");\n}\n\n\n/*************************************************************\n * Primop registration\n *************************************************************/\n\n\nRegisterPrimOp::PrimOps * RegisterPrimOp::primOps;\n\n\nRegisterPrimOp::RegisterPrimOp(std::string name, size_t arity, PrimOpFun fun)\n{\n    if (!primOps) primOps = new PrimOps;\n    primOps->emplace_back(name, arity, fun);\n}\n\n\nvoid EvalState::createBaseEnv()\n{\n    baseEnv.up = 0;\n\n    /* Add global constants such as `true' to the base environment. */\n    Value v;\n\n    /* `builtins' must be first! */\n    mkAttrs(v, 128);\n    addConstant(\"builtins\", v);\n\n    mkBool(v, true);\n    addConstant(\"true\", v);\n\n    mkBool(v, false);\n    addConstant(\"false\", v);\n\n    mkNull(v);\n    addConstant(\"null\", v);\n\n    auto vThrow = addPrimOp(\"throw\", 1, prim_throw);\n\n    auto addPurityError = [&](const std::string & name) {\n        Value * v2 = allocValue();\n        mkString(*v2, fmt(\"'%s' is not allowed in pure evaluation mode\", name));\n        mkApp(v, *vThrow, *v2);\n        addConstant(name, v);\n    };\n\n    if (!settings.pureEval) {\n        mkInt(v, time(0));\n        addConstant(\"__currentTime\", v);\n    }\n\n    if (!settings.pureEval) {\n        mkString(v, settings.thisSystem);\n        addConstant(\"__currentSystem\", v);\n    }\n\n    mkString(v, nixVersion);\n    addConstant(\"__nixVersion\", v);\n\n    mkString(v, store->storeDir);\n    addConstant(\"__storeDir\", v);\n\n    /* Language version.  This should be increased every time a new\n       language feature gets added.  It's not necessary to increase it\n       when primops get added, because you can just use `builtins ?\n       primOp' to check. */\n    mkInt(v, 5);\n    addConstant(\"__langVersion\", v);\n\n    // Miscellaneous\n    auto vScopedImport = addPrimOp(\"scopedImport\", 2, prim_scopedImport);\n    Value * v2 = allocValue();\n    mkAttrs(*v2, 0);\n    mkApp(v, *vScopedImport, *v2);\n    forceValue(v);\n    addConstant(\"import\", v);\n    if (settings.enableNativeCode) {\n        addPrimOp(\"__importNative\", 2, prim_importNative);\n        addPrimOp(\"__exec\", 1, prim_exec);\n    }\n    addPrimOp(\"__typeOf\", 1, prim_typeOf);\n    addPrimOp(\"isNull\", 1, prim_isNull);\n    addPrimOp(\"__isFunction\", 1, prim_isFunction);\n    addPrimOp(\"__isString\", 1, prim_isString);\n    addPrimOp(\"__isInt\", 1, prim_isInt);\n    addPrimOp(\"__isFloat\", 1, prim_isFloat);\n    addPrimOp(\"__isBool\", 1, prim_isBool);\n    addPrimOp(\"__genericClosure\", 1, prim_genericClosure);\n    addPrimOp(\"abort\", 1, prim_abort);\n    addPrimOp(\"__addErrorContext\", 2, prim_addErrorContext);\n    addPrimOp(\"__tryEval\", 1, prim_tryEval);\n    addPrimOp(\"__getEnv\", 1, prim_getEnv);\n\n    // Strictness\n    addPrimOp(\"__seq\", 2, prim_seq);\n    addPrimOp(\"__deepSeq\", 2, prim_deepSeq);\n\n    // Debugging\n    addPrimOp(\"__trace\", 2, prim_trace);\n    addPrimOp(\"__valueSize\", 1, prim_valueSize);\n\n    // Paths\n    addPrimOp(\"__toPath\", 1, prim_toPath);\n    if (settings.pureEval)\n        addPurityError(\"__storePath\");\n    else\n        addPrimOp(\"__storePath\", 1, prim_storePath);\n    addPrimOp(\"__pathExists\", 1, prim_pathExists);\n    addPrimOp(\"baseNameOf\", 1, prim_baseNameOf);\n    addPrimOp(\"dirOf\", 1, prim_dirOf);\n    addPrimOp(\"__readFile\", 1, prim_readFile);\n    addPrimOp(\"__readDir\", 1, prim_readDir);\n    addPrimOp(\"__findFile\", 2, prim_findFile);\n\n    // Creating files\n    addPrimOp(\"__toXML\", 1, prim_toXML);\n    addPrimOp(\"__toJSON\", 1, prim_toJSON);\n    addPrimOp(\"__fromJSON\", 1, prim_fromJSON);\n    addPrimOp(\"__toFile\", 2, prim_toFile);\n    addPrimOp(\"__filterSource\", 2, prim_filterSource);\n    addPrimOp(\"__path\", 1, prim_path);\n\n    // Sets\n    addPrimOp(\"__attrNames\", 1, prim_attrNames);\n    addPrimOp(\"__attrValues\", 1, prim_attrValues);\n    addPrimOp(\"__getAttr\", 2, prim_getAttr);\n    addPrimOp(\"__unsafeGetAttrPos\", 2, prim_unsafeGetAttrPos);\n    addPrimOp(\"__hasAttr\", 2, prim_hasAttr);\n    addPrimOp(\"__isAttrs\", 1, prim_isAttrs);\n    addPrimOp(\"removeAttrs\", 2, prim_removeAttrs);\n    addPrimOp(\"__listToAttrs\", 1, prim_listToAttrs);\n    addPrimOp(\"__intersectAttrs\", 2, prim_intersectAttrs);\n    addPrimOp(\"__catAttrs\", 2, prim_catAttrs);\n    addPrimOp(\"__functionArgs\", 1, prim_functionArgs);\n\n    // Lists\n    addPrimOp(\"__isList\", 1, prim_isList);\n    addPrimOp(\"__elemAt\", 2, prim_elemAt);\n    addPrimOp(\"__head\", 1, prim_head);\n    addPrimOp(\"__tail\", 1, prim_tail);\n    addPrimOp(\"map\", 2, prim_map);\n    addPrimOp(\"__filter\", 2, prim_filter);\n    addPrimOp(\"__elem\", 2, prim_elem);\n    addPrimOp(\"__concatLists\", 1, prim_concatLists);\n    addPrimOp(\"__length\", 1, prim_length);\n    addPrimOp(\"__foldl'\", 3, prim_foldlStrict);\n    addPrimOp(\"__any\", 2, prim_any);\n    addPrimOp(\"__all\", 2, prim_all);\n    addPrimOp(\"__genList\", 2, prim_genList);\n    addPrimOp(\"__sort\", 2, prim_sort);\n    addPrimOp(\"__partition\", 2, prim_partition);\n\n    // Integer arithmetic\n    addPrimOp(\"__add\", 2, prim_add);\n    addPrimOp(\"__sub\", 2, prim_sub);\n    addPrimOp(\"__mul\", 2, prim_mul);\n    addPrimOp(\"__div\", 2, prim_div);\n    addPrimOp(\"__lessThan\", 2, prim_lessThan);\n\n    // String manipulation\n    addPrimOp(\"toString\", 1, prim_toString);\n    addPrimOp(\"__substring\", 3, prim_substring);\n    addPrimOp(\"__stringLength\", 1, prim_stringLength);\n    addPrimOp(\"__hasContext\", 1, prim_hasContext);\n    addPrimOp(\"__unsafeDiscardStringContext\", 1, prim_unsafeDiscardStringContext);\n    addPrimOp(\"__unsafeDiscardOutputDependency\", 1, prim_unsafeDiscardOutputDependency);\n    addPrimOp(\"__hashString\", 2, prim_hashString);\n    addPrimOp(\"__match\", 2, prim_match);\n    addPrimOp(\"__split\", 2, prim_split);\n    addPrimOp(\"__concatStringsSep\", 2, prim_concatStringSep);\n    addPrimOp(\"__replaceStrings\", 3, prim_replaceStrings);\n\n    // Versions\n    addPrimOp(\"__parseDrvName\", 1, prim_parseDrvName);\n    addPrimOp(\"__compareVersions\", 2, prim_compareVersions);\n    addPrimOp(\"__splitVersion\", 1, prim_splitVersion);\n\n    // Derivations\n    addPrimOp(\"derivationStrict\", 1, prim_derivationStrict);\n    addPrimOp(\"placeholder\", 1, prim_placeholder);\n\n    // Networking\n    addPrimOp(\"__fetchurl\", 1, prim_fetchurl);\n    addPrimOp(\"fetchTarball\", 1, prim_fetchTarball);\n\n    /* Add a wrapper around the derivation primop that computes the\n       `drvPath' and `outPath' attributes lazily. */\n    string path = canonPath(settings.nixDataDir + \"/nix/corepkgs/derivation.nix\", true);\n    sDerivationNix = symbols.create(path);\n    evalFile(path, v);\n    addConstant(\"derivation\", v);\n\n    /* Add a value containing the current Nix expression search path. */\n    mkList(v, searchPath.size());\n    int n = 0;\n    for (auto & i : searchPath) {\n        v2 = v.listElems()[n++] = allocValue();\n        mkAttrs(*v2, 2);\n        mkString(*allocAttr(*v2, symbols.create(\"path\")), i.second);\n        mkString(*allocAttr(*v2, symbols.create(\"prefix\")), i.first);\n        v2->attrs->sort();\n    }\n    addConstant(\"__nixPath\", v);\n\n    if (RegisterPrimOp::primOps)\n        for (auto & primOp : *RegisterPrimOp::primOps)\n            addPrimOp(std::get<0>(primOp), std::get<1>(primOp), std::get<2>(primOp));\n\n    /* Now that we've added all primops, sort the `builtins' set,\n       because attribute lookups expect it to be sorted. */\n    baseEnv.values[0]->attrs->sort();\n}\n\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/src/libstore/globals.cc": "#include \"globals.hh\"\n#include \"util.hh\"\n#include \"archive.hh\"\n#include \"args.hh\"\n\n#include <algorithm>\n#include <map>\n#include <thread>\n#include <dlfcn.h>\n\n\nnamespace nix {\n\n\n/* The default location of the daemon socket, relative to nixStateDir.\n   The socket is in a directory to allow you to control access to the\n   Nix daemon by setting the mode/ownership of the directory\n   appropriately.  (This wouldn't work on the socket itself since it\n   must be deleted and recreated on startup.) */\n#define DEFAULT_SOCKET_PATH \"/daemon-socket/socket\"\n\n/* chroot-like behavior from Apple's sandbox */\n#if __APPLE__\n    #define DEFAULT_ALLOWED_IMPURE_PREFIXES \"/System/Library /usr/lib /dev /bin/sh\"\n#else\n    #define DEFAULT_ALLOWED_IMPURE_PREFIXES \"\"\n#endif\n\nSettings settings;\n\nSettings::Settings()\n    : Config({})\n    , nixPrefix(NIX_PREFIX)\n    , nixStore(canonPath(getEnv(\"NIX_STORE_DIR\", getEnv(\"NIX_STORE\", NIX_STORE_DIR))))\n    , nixDataDir(canonPath(getEnv(\"NIX_DATA_DIR\", NIX_DATA_DIR)))\n    , nixLogDir(canonPath(getEnv(\"NIX_LOG_DIR\", NIX_LOG_DIR)))\n    , nixStateDir(canonPath(getEnv(\"NIX_STATE_DIR\", NIX_STATE_DIR)))\n    , nixConfDir(canonPath(getEnv(\"NIX_CONF_DIR\", NIX_CONF_DIR)))\n    , nixLibexecDir(canonPath(getEnv(\"NIX_LIBEXEC_DIR\", NIX_LIBEXEC_DIR)))\n    , nixBinDir(canonPath(getEnv(\"NIX_BIN_DIR\", NIX_BIN_DIR)))\n    , nixManDir(canonPath(NIX_MAN_DIR))\n    , nixDaemonSocketFile(canonPath(nixStateDir + DEFAULT_SOCKET_PATH))\n{\n    buildUsersGroup = getuid() == 0 ? \"nixbld\" : \"\";\n    lockCPU = getEnv(\"NIX_AFFINITY_HACK\", \"1\") == \"1\";\n\n    caFile = getEnv(\"NIX_SSL_CERT_FILE\", getEnv(\"SSL_CERT_FILE\", \"\"));\n    if (caFile == \"\") {\n        for (auto & fn : {\"/etc/ssl/certs/ca-certificates.crt\", \"/nix/var/nix/profiles/default/etc/ssl/certs/ca-bundle.crt\"})\n            if (pathExists(fn)) {\n                caFile = fn;\n                break;\n            }\n    }\n\n    /* Backwards compatibility. */\n    auto s = getEnv(\"NIX_REMOTE_SYSTEMS\");\n    if (s != \"\") {\n        Strings ss;\n        for (auto & p : tokenizeString<Strings>(s, \":\"))\n            ss.push_back(\"@\" + p);\n        builders = concatStringsSep(\" \", ss);\n    }\n\n#if defined(__linux__) && defined(SANDBOX_SHELL)\n    sandboxPaths = tokenizeString<StringSet>(\"/bin/sh=\" SANDBOX_SHELL);\n#endif\n\n    allowedImpureHostPrefixes = tokenizeString<StringSet>(DEFAULT_ALLOWED_IMPURE_PREFIXES);\n}\n\nvoid Settings::loadConfFile()\n{\n    applyConfigFile(nixConfDir + \"/nix.conf\");\n\n    /* We only want to send overrides to the daemon, i.e. stuff from\n       ~/.nix/nix.conf or the command line. */\n    resetOverriden();\n\n    applyConfigFile(getConfigDir() + \"/nix/nix.conf\");\n}\n\nvoid Settings::set(const string & name, const string & value)\n{\n    Config::set(name, value);\n}\n\nunsigned int Settings::getDefaultCores()\n{\n    return std::max(1U, std::thread::hardware_concurrency());\n}\n\nconst string nixVersion = PACKAGE_VERSION;\n\ntemplate<> void BaseSetting<SandboxMode>::set(const std::string & str)\n{\n    if (str == \"true\") value = smEnabled;\n    else if (str == \"relaxed\") value = smRelaxed;\n    else if (str == \"false\") value = smDisabled;\n    else throw UsageError(\"option '%s' has invalid value '%s'\", name, str);\n}\n\ntemplate<> std::string BaseSetting<SandboxMode>::to_string()\n{\n    if (value == smEnabled) return \"true\";\n    else if (value == smRelaxed) return \"relaxed\";\n    else if (value == smDisabled) return \"false\";\n    else abort();\n}\n\ntemplate<> void BaseSetting<SandboxMode>::toJSON(JSONPlaceholder & out)\n{\n    AbstractSetting::toJSON(out);\n}\n\ntemplate<> void BaseSetting<SandboxMode>::convertToArg(Args & args, const std::string & category)\n{\n    args.mkFlag()\n        .longName(name)\n        .description(\"Enable sandboxing.\")\n        .handler([=](std::vector<std::string> ss) { override(smEnabled); })\n        .category(category);\n    args.mkFlag()\n        .longName(\"no-\" + name)\n        .description(\"Disable sandboxing.\")\n        .handler([=](std::vector<std::string> ss) { override(smDisabled); })\n        .category(category);\n    args.mkFlag()\n        .longName(\"relaxed-\" + name)\n        .description(\"Enable sandboxing, but allow builds to disable it.\")\n        .handler([=](std::vector<std::string> ss) { override(smRelaxed); })\n        .category(category);\n}\n\nvoid MaxBuildJobsSetting::set(const std::string & str)\n{\n    if (str == \"auto\") value = std::max(1U, std::thread::hardware_concurrency());\n    else if (!string2Int(str, value))\n        throw UsageError(\"configuration setting '%s' should be 'auto' or an integer\", name);\n}\n\n\nvoid initPlugins()\n{\n    for (const auto & pluginFile : settings.pluginFiles.get()) {\n        Paths pluginFiles;\n        try {\n            auto ents = readDirectory(pluginFile);\n            for (const auto & ent : ents)\n                pluginFiles.emplace_back(pluginFile + \"/\" + ent.name);\n        } catch (SysError & e) {\n            if (e.errNo != ENOTDIR)\n                throw;\n            pluginFiles.emplace_back(pluginFile);\n        }\n        for (const auto & file : pluginFiles) {\n            /* handle is purposefully leaked as there may be state in the\n               DSO needed by the action of the plugin. */\n            void *handle =\n                dlopen(file.c_str(), RTLD_LAZY | RTLD_LOCAL);\n            if (!handle)\n                throw Error(\"could not dynamically open plugin file '%s': %s\", file, dlerror());\n        }\n    }\n    /* We handle settings registrations here, since plugins can add settings */\n    if (RegisterSetting::settingRegistrations) {\n        for (auto & registration : *RegisterSetting::settingRegistrations)\n            settings.addSetting(registration);\n        delete RegisterSetting::settingRegistrations;\n    }\n    settings.handleUnknownSettings();\n}\n\nRegisterSetting::SettingRegistrations * RegisterSetting::settingRegistrations;\n\nRegisterSetting::RegisterSetting(AbstractSetting * s)\n{\n    if (!settingRegistrations)\n        settingRegistrations = new SettingRegistrations;\n    settingRegistrations->emplace_back(s);\n}\n\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/doc/manual/expressions/language-values.xml": "<section xmlns=\"http://docbook.org/ns/docbook\"\n      xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n      xmlns:xi=\"http://www.w3.org/2001/XInclude\"\n      version=\"5.0\"\n      xml:id='ssec-values'>\n\n<title>Values</title>\n\n\n<simplesect><title>Simple Values</title>\n\n<para>Nix has the following basic data types:\n\n<itemizedlist>\n\n  <listitem>\n\n    <para><emphasis>Strings</emphasis> can be written in three\n    ways.</para>\n\n    <para>The most common way is to enclose the string between double\n    quotes, e.g., <literal>\"foo bar\"</literal>.  Strings can span\n    multiple lines.  The special characters <literal>\"</literal> and\n    <literal>\\</literal> and the character sequence\n    <literal>${</literal> must be escaped by prefixing them with a\n    backslash (<literal>\\</literal>).  Newlines, carriage returns and\n    tabs can be written as <literal>\\n</literal>,\n    <literal>\\r</literal> and <literal>\\t</literal>,\n    respectively.</para>\n\n    <para>You can include the result of an expression into a string by\n    enclosing it in\n    <literal>${<replaceable>...</replaceable>}</literal>, a feature\n    known as <emphasis>antiquotation</emphasis>.  The enclosed\n    expression must evaluate to something that can be coerced into a\n    string (meaning that it must be a string, a path, or a\n    derivation).  For instance, rather than writing\n\n<programlisting>\n\"--with-freetype2-library=\" + freetype + \"/lib\"</programlisting>\n\n    (where <varname>freetype</varname> is a derivation), you can\n    instead write the more natural\n\n<programlisting>\n\"--with-freetype2-library=${freetype}/lib\"</programlisting>\n\n    The latter is automatically translated to the former.  A more\n    complicated example (from the Nix expression for <link\n    xlink:href='http://www.trolltech.com/products/qt'>Qt</link>):\n\n<programlisting>\nconfigureFlags = \"\n  -system-zlib -system-libpng -system-libjpeg\n  ${if openglSupport then \"-dlopen-opengl\n    -L${mesa}/lib -I${mesa}/include\n    -L${libXmu}/lib -I${libXmu}/include\" else \"\"}\n  ${if threadSupport then \"-thread\" else \"-no-thread\"}\n\";</programlisting>\n\n    Note that Nix expressions and strings can be arbitrarily nested;\n    in this case the outer string contains various antiquotations that\n    themselves contain strings (e.g., <literal>\"-thread\"</literal>),\n    some of which in turn contain expressions (e.g.,\n    <literal>${mesa}</literal>).</para>\n\n    <para>The second way to write string literals is as an\n    <emphasis>indented string</emphasis>, which is enclosed between\n    pairs of <emphasis>double single-quotes</emphasis>, like so:\n\n<programlisting>\n''\n  This is the first line.\n  This is the second line.\n    This is the third line.\n''</programlisting>\n\n    This kind of string literal intelligently strips indentation from\n    the start of each line.  To be precise, it strips from each line a\n    number of spaces equal to the minimal indentation of the string as\n    a whole (disregarding the indentation of empty lines).  For\n    instance, the first and second line are indented two space, while\n    the third line is indented four spaces.  Thus, two spaces are\n    stripped from each line, so the resulting string is\n\n<programlisting>\n\"This is the first line.\\nThis is the second line.\\n  This is the third line.\\n\"</programlisting>\n\n    </para>\n\n    <para>Note that the whitespace and newline following the opening\n    <literal>''</literal> is ignored if there is no non-whitespace\n    text on the initial line.</para>\n\n    <para>Antiquotation\n    (<literal>${<replaceable>expr</replaceable>}</literal>) is\n    supported in indented strings.</para>\n\n    <para>Since <literal>${</literal> and <literal>''</literal> have\n    special meaning in indented strings, you need a way to quote them.\n    <literal>$</literal> can be escaped by prefixing it with\n    <literal>''</literal> (that is, two single quotes), i.e.,\n    <literal>''$</literal>. <literal>''</literal> can be escaped by\n    prefixing it with <literal>'</literal>, i.e.,\n    <literal>'''</literal>. <literal>$</literal> removes any special meaning\n    from the following <literal>$</literal>. Linefeed, carriage-return and tab\n    characters can be written as <literal>''\\n</literal>,\n    <literal>''\\r</literal>, <literal>''\\t</literal>, and <literal>''\\</literal>\n    escapes any other character.\n\n    </para>\n\n    <para>Indented strings are primarily useful in that they allow\n    multi-line string literals to follow the indentation of the\n    enclosing Nix expression, and that less escaping is typically\n    necessary for strings representing languages such as shell scripts\n    and configuration files because <literal>''</literal> is much less\n    common than <literal>\"</literal>.  Example:\n\n<programlisting>\nstdenv.mkDerivation {\n  <replaceable>...</replaceable>\n  postInstall =\n    ''\n      mkdir $out/bin $out/etc\n      cp foo $out/bin\n      echo \"Hello World\" > $out/etc/foo.conf\n      ${if enableBar then \"cp bar $out/bin\" else \"\"}\n    '';\n  <replaceable>...</replaceable>\n}\n</programlisting>\n\n    </para>\n\n    <para>Finally, as a convenience, <emphasis>URIs</emphasis> as\n    defined in appendix B of <link\n    xlink:href='http://www.ietf.org/rfc/rfc2396.txt'>RFC 2396</link>\n    can be written <emphasis>as is</emphasis>, without quotes.  For\n    instance, the string\n    <literal>\"http://example.org/foo.tar.bz2\"</literal>\n    can also be written as\n    <literal>http://example.org/foo.tar.bz2</literal>.</para>\n\n  </listitem>\n\n  <listitem><para>Numbers, which can be <emphasis>integers</emphasis> (like\n  <literal>123</literal>) or <emphasis>floating point</emphasis> (like\n  <literal>123.43</literal> or <literal>.27e13</literal>).</para>\n\n  <para>Numbers are type-compatible: pure integer operations will always\n  return integers, whereas any operation involving at least one floating point\n  number will have a floating point number as a result.</para></listitem>\n\n  <listitem><para><emphasis>Paths</emphasis>, e.g.,\n  <filename>/bin/sh</filename> or <filename>./builder.sh</filename>.\n  A path must contain at least one slash to be recognised as such; for\n  instance, <filename>builder.sh</filename> is not a\n  path<footnote><para>It's parsed as an expression that selects the\n  attribute <varname>sh</varname> from the variable\n  <varname>builder</varname>.</para></footnote>.  If the file name is\n  relative, i.e., if it does not begin with a slash, it is made\n  absolute at parse time relative to the directory of the Nix\n  expression that contained it.  For instance, if a Nix expression in\n  <filename>/foo/bar/bla.nix</filename> refers to\n  <filename>../xyzzy/fnord.nix</filename>, the absolute path is\n  <filename>/foo/xyzzy/fnord.nix</filename>.</para>\n\n  <para>If the first component of a path is a <literal>~</literal>,\n  it is interpreted as if the rest of the path were relative to the\n  user's home directory. e.g. <filename>~/foo</filename> would be\n  equivalent to <filename>/home/edolstra/foo</filename> for a user\n  whose home directory is <filename>/home/edolstra</filename>.\n  </para>\n\n  <para>Paths can also be specified between angle brackets, e.g.\n  <literal>&lt;nixpkgs&gt;</literal>. This means that the directories\n  listed in the environment variable\n  <envar linkend=\"env-NIX_PATH\">NIX_PATH</envar> will be searched\n  for the given file or directory name.\n  </para>\n\n  </listitem>\n\n  <listitem><para><emphasis>Booleans</emphasis> with values\n  <literal>true</literal> and\n  <literal>false</literal>.</para></listitem>\n\n  <listitem><para>The null value, denoted as\n  <literal>null</literal>.</para></listitem>\n\n</itemizedlist>\n\n</para>\n\n</simplesect>\n\n\n<simplesect><title>Lists</title>\n\n<para>Lists are formed by enclosing a whitespace-separated list of\nvalues between square brackets.  For example,\n\n<programlisting>\n[ 123 ./foo.nix \"abc\" (f { x = y; }) ]</programlisting>\n\ndefines a list of four elements, the last being the result of a call\nto the function <varname>f</varname>.  Note that function calls have\nto be enclosed in parentheses.  If they had been omitted, e.g.,\n\n<programlisting>\n[ 123 ./foo.nix \"abc\" f { x = y; } ]</programlisting>\n\nthe result would be a list of five elements, the fourth one being a\nfunction and the fifth being a set.</para>\n\n<para>Note that lists are only lazy in values, and they are strict in length.\n</para>\n\n</simplesect>\n\n\n<simplesect><title>Sets</title>\n\n<para>Sets are really the core of the language, since ultimately the\nNix language is all about creating derivations, which are really just\nsets of attributes to be passed to build scripts.</para>\n\n<para>Sets are just a list of name/value pairs (called\n<emphasis>attributes</emphasis>) enclosed in curly brackets, where\neach value is an arbitrary expression terminated by a semicolon.  For\nexample:\n\n<programlisting>\n{ x = 123;\n  text = \"Hello\";\n  y = f { bla = 456; };\n}</programlisting>\n\nThis defines a set with attributes named <varname>x</varname>,\n<varname>text</varname>, <varname>y</varname>.  The order of the\nattributes is irrelevant.  An attribute name may only occur\nonce.</para>\n\n<para>Attributes can be selected from a set using the\n<literal>.</literal> operator.  For instance,\n\n<programlisting>\n{ a = \"Foo\"; b = \"Bar\"; }.a</programlisting>\n\nevaluates to <literal>\"Foo\"</literal>.  It is possible to provide a\ndefault value in an attribute selection using the\n<literal>or</literal> keyword.  For example,\n\n<programlisting>\n{ a = \"Foo\"; b = \"Bar\"; }.c or \"Xyzzy\"</programlisting>\n\nwill evaluate to <literal>\"Xyzzy\"</literal> because there is no\n<varname>c</varname> attribute in the set.</para>\n\n<para>You can use arbitrary double-quoted strings as attribute\nnames:\n\n<programlisting>\n{ \"foo ${bar}\" = 123; \"nix-1.0\" = 456; }.\"foo ${bar}\"\n</programlisting>\n\nThis will evaluate to <literal>123</literal> (Assuming\n<literal>bar</literal> is antiquotable). In the case where an\nattribute name is just a single antiquotation, the quotes can be\ndropped:\n\n<programlisting>\n{ foo = 123; }.${bar} or 456 </programlisting>\n\nThis will evaluate to <literal>123</literal> if\n<literal>bar</literal> evaluates to <literal>\"foo\"</literal> when\ncoerced to a string and <literal>456</literal> otherwise (again\nassuming <literal>bar</literal> is antiquotable).</para>\n\n<para>In the special case where an attribute name inside of a set declaration\nevaluates to <literal>null</literal> (which is normally an error, as\n<literal>null</literal> is not antiquotable), that attribute is simply not\nadded to the set:\n\n<programlisting>\n{ ${if foo then \"bar\" else null} = true; }</programlisting>\n\nThis will evaluate to <literal>{}</literal> if <literal>foo</literal>\nevaluates to <literal>false</literal>.</para>\n\n<para>A set that has a <literal>__functor</literal> attribute whose value\nis callable (i.e. is itself a function or a set with a\n<literal>__functor</literal> attribute whose value is callable) can be\napplied as if it were a function, with the set itself passed in first\n, e.g.,\n\n<programlisting>\nlet add = { __functor = self: x: x + self.x; };\n    inc = add // { x = 1; };\nin inc 1\n</programlisting>\n\nevaluates to <literal>2</literal>. This can be used to attach metadata to a\nfunction without the caller needing to treat it specially, or to implement\na form of object-oriented programming, for example.\n\n</para>\n\n</simplesect>\n\n\n</section>\n",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/doc/manual/command-ref/conf-file.xml": "<refentry xmlns=\"http://docbook.org/ns/docbook\"\n          xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n          xmlns:xi=\"http://www.w3.org/2001/XInclude\"\n          xml:id=\"sec-conf-file\">\n\n<refmeta>\n  <refentrytitle>nix.conf</refentrytitle>\n  <manvolnum>5</manvolnum>\n  <refmiscinfo class=\"source\">Nix</refmiscinfo>\n  <refmiscinfo class=\"version\"><xi:include href=\"../version.txt\" parse=\"text\"/></refmiscinfo>\n</refmeta>\n\n<refnamediv>\n  <refname>nix.conf</refname>\n  <refpurpose>Nix configuration file</refpurpose>\n</refnamediv>\n\n<refsection><title>Description</title>\n\n<para>Nix reads settings from two configuration files:</para>\n\n<itemizedlist>\n\n  <listitem>\n    <para>The system-wide configuration file\n    <filename><replaceable>sysconfdir</replaceable>/nix/nix.conf</filename>\n    (i.e. <filename>/etc/nix/nix.conf</filename> on most systems), or\n    <filename>$NIX_CONF_DIR/nix.conf</filename> if\n    <envar>NIX_CONF_DIR</envar> is set.</para>\n  </listitem>\n\n  <listitem>\n    <para>The user configuration file\n    <filename>$XDG_CONFIG_HOME/nix/nix.conf</filename>, or\n    <filename>~/.config/nix/nix.conf</filename> if\n    <envar>XDG_CONFIG_HOME</envar> is not set.</para>\n  </listitem>\n\n</itemizedlist>\n\n<para>The configuration files consist of\n<literal><replaceable>name</replaceable> =\n<replaceable>value</replaceable></literal> pairs, one per line. Other\nfiles can be included with a line like <literal>include\n<replaceable>path</replaceable></literal>, where\n<replaceable>path</replaceable> is interpreted relative to the current\nconf file and a missing file is an error unless\n<literal>!include</literal> is used instead.\nComments start with a <literal>#</literal> character.  Here is an\nexample configuration file:</para>\n\n<programlisting>\nkeep-outputs = true       # Nice for developers\nkeep-derivations = true   # Idem\n</programlisting>\n\n<para>You can override settings on the command line using the\n<option>--option</option> flag, e.g. <literal>--option keep-outputs\nfalse</literal>.</para>\n\n<para>The following settings are currently available:\n\n<variablelist>\n\n\n  <varlistentry xml:id=\"conf-allowed-uris\"><term><literal>allowed-uris</literal></term>\n\n    <listitem>\n\n      <para>A list of URI prefixes to which access is allowed in\n      restricted evaluation mode. For example, when set to\n      <literal>https://github.com/NixOS</literal>, builtin functions\n      such as <function>fetchGit</function> are allowed to access\n      <literal>https://github.com/NixOS/patchelf.git</literal>.</para>\n\n    </listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-allow-import-from-derivation\"><term><literal>allow-import-from-derivation</literal></term>\n\n    <listitem><para>By default, Nix allows you to <function>import</function> from a derivation,\n    allowing building at evaluation time. With this option set to false, Nix will throw an error\n    when evaluating an expression that uses this feature, allowing users to ensure their evaluation\n    will not require any builds to take place.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-allow-new-privileges\"><term><literal>allow-new-privileges</literal></term>\n\n    <listitem><para>(Linux-specific.) By default, builders on Linux\n    cannot acquire new privileges by calling setuid/setgid programs or\n    programs that have file capabilities. For example, programs such\n    as <command>sudo</command> or <command>ping</command> will\n    fail. (Note that in sandbox builds, no such programs are available\n    unless you bind-mount them into the sandbox via the\n    <option>sandbox-paths</option> option.) You can allow the\n    use of such programs by enabling this option. This is impure and\n    usually undesirable, but may be useful in certain scenarios\n    (e.g. to spin up containers or set up userspace network interfaces\n    in tests).</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-allowed-users\"><term><literal>allowed-users</literal></term>\n\n    <listitem>\n\n      <para>A list of names of users (separated by whitespace) that\n      are allowed to connect to the Nix daemon. As with the\n      <option>trusted-users</option> option, you can specify groups by\n      prefixing them with <literal>@</literal>. Also, you can allow\n      all users by specifying <literal>*</literal>. The default is\n      <literal>*</literal>.</para>\n\n      <para>Note that trusted users are always allowed to connect.</para>\n\n    </listitem>\n\n  </varlistentry>\n\n\n  <varlistentry><term><literal>auto-optimise-store</literal></term>\n\n    <listitem><para>If set to <literal>true</literal>, Nix\n    automatically detects files in the store that have identical\n    contents, and replaces them with hard links to a single copy.\n    This saves disk space.  If set to <literal>false</literal> (the\n    default), you can still run <command>nix-store\n    --optimise</command> to get rid of duplicate\n    files.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-builders\">\n    <term><literal>builders</literal></term>\n    <listitem>\n      <para>A list of machines on which to perform builds. <phrase\n      condition=\"manual\">See <xref linkend=\"chap-distributed-builds\"\n      /> for details.</phrase></para>\n    </listitem>\n  </varlistentry>\n\n\n  <varlistentry><term><literal>builders-use-substitutes</literal></term>\n\n    <listitem><para>If set to <literal>true</literal>, Nix will instruct\n    remote build machines to use their own binary substitutes if available. In\n    practical terms, this means that remote hosts will fetch as many build\n    dependencies as possible from their own substitutes (e.g, from\n    <literal>cache.nixos.org</literal>), instead of waiting for this host to\n    upload them all. This can drastically reduce build times if the network\n    connection between this computer and the remote build host is slow. Defaults\n    to <literal>false</literal>.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-build-users-group\"><term><literal>build-users-group</literal></term>\n\n    <listitem><para>This options specifies the Unix group containing\n    the Nix build user accounts.  In multi-user Nix installations,\n    builds should not be performed by the Nix account since that would\n    allow users to arbitrarily modify the Nix store and database by\n    supplying specially crafted builders; and they cannot be performed\n    by the calling user since that would allow him/her to influence\n    the build result.</para>\n\n    <para>Therefore, if this option is non-empty and specifies a valid\n    group, builds will be performed under the user accounts that are a\n    member of the group specified here (as listed in\n    <filename>/etc/group</filename>).  Those user accounts should not\n    be used for any other purpose!</para>\n\n    <para>Nix will never run two builds under the same user account at\n    the same time.  This is to prevent an obvious security hole: a\n    malicious user writing a Nix expression that modifies the build\n    result of a legitimate Nix expression being built by another user.\n    Therefore it is good to have as many Nix build user accounts as\n    you can spare.  (Remember: uids are cheap.)</para>\n\n    <para>The build users should have permission to create files in\n    the Nix store, but not delete them.  Therefore,\n    <filename>/nix/store</filename> should be owned by the Nix\n    account, its group should be the group specified here, and its\n    mode should be <literal>1775</literal>.</para>\n\n    <para>If the build users group is empty, builds will be performed\n    under the uid of the Nix process (that is, the uid of the caller\n    if <envar>NIX_REMOTE</envar> is empty, the uid under which the Nix\n    daemon runs if <envar>NIX_REMOTE</envar> is\n    <literal>daemon</literal>).  Obviously, this should not be used in\n    multi-user settings with untrusted users.</para>\n\n    </listitem>\n\n  </varlistentry>\n\n\n  <varlistentry><term><literal>compress-build-log</literal></term>\n\n    <listitem><para>If set to <literal>true</literal> (the default),\n    build logs written to <filename>/nix/var/log/nix/drvs</filename>\n    will be compressed on the fly using bzip2.  Otherwise, they will\n    not be compressed.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-connect-timeout\"><term><literal>connect-timeout</literal></term>\n\n    <listitem>\n\n      <para>The timeout (in seconds) for establishing connections in\n      the binary cache substituter.  It corresponds to\n      <command>curl</command>\u2019s <option>--connect-timeout</option>\n      option.</para>\n\n    </listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-cores\"><term><literal>cores</literal></term>\n\n    <listitem><para>Sets the value of the\n    <envar>NIX_BUILD_CORES</envar> environment variable in the\n    invocation of builders.  Builders can use this variable at their\n    discretion to control the maximum amount of parallelism.  For\n    instance, in Nixpkgs, if the derivation attribute\n    <varname>enableParallelBuilding</varname> is set to\n    <literal>true</literal>, the builder passes the\n    <option>-j<replaceable>N</replaceable></option> flag to GNU Make.\n    It can be overridden using the <option\n    linkend='opt-cores'>--cores</option> command line switch and\n    defaults to <literal>1</literal>.  The value <literal>0</literal>\n    means that the builder should use all available CPU cores in the\n    system.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-extra-sandbox-paths\">\n    <term><literal>extra-sandbox-paths</literal></term>\n\n    <listitem><para>A list of additional paths appended to\n    <option>sandbox-paths</option>. Useful if you want to extend\n    its default value.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry><term><literal>extra-substituters</literal></term>\n\n    <listitem><para>Additional binary caches appended to those\n    specified in <option>substituters</option>.  When used by\n    unprivileged users, untrusted substituters (i.e. those not listed\n    in <option>trusted-substituters</option>) are silently\n    ignored.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry><term><literal>fallback</literal></term>\n\n    <listitem><para>If set to <literal>true</literal>, Nix will fall\n    back to building from source if a binary substitute fails.  This\n    is equivalent to the <option>--fallback</option> flag.  The\n    default is <literal>false</literal>.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry><term><literal>fsync-metadata</literal></term>\n\n    <listitem><para>If set to <literal>true</literal>, changes to the\n    Nix store metadata (in <filename>/nix/var/nix/db</filename>) are\n    synchronously flushed to disk.  This improves robustness in case\n    of system crashes, but reduces performance.  The default is\n    <literal>true</literal>.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-hashed-mirrors\"><term><literal>hashed-mirrors</literal></term>\n\n    <listitem><para>A list of web servers used by\n    <function>builtins.fetchurl</function> to obtain files by\n    hash. The default is\n    <literal>http://tarballs.nixos.org/</literal>. Given a hash type\n    <replaceable>ht</replaceable> and a base-16 hash\n    <replaceable>h</replaceable>, Nix will try to download the file\n    from\n    <literal>hashed-mirror/<replaceable>ht</replaceable>/<replaceable>h</replaceable></literal>.\n    This allows files to be downloaded even if they have disappeared\n    from their original URI. For example, given the default mirror\n    <literal>http://tarballs.nixos.org/</literal>, when building the derivation\n\n<programlisting>\nbuiltins.fetchurl {\n  url = https://example.org/foo-1.2.3.tar.xz;\n  sha256 = \"2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\";\n}\n</programlisting>\n\n    Nix will attempt to download this file from\n    <literal>http://tarballs.nixos.org/sha256/2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae</literal>\n    first. If it is not available there, if will try the original URI.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry><term><literal>http-connections</literal></term>\n\n    <listitem><para>The maximum number of parallel TCP connections\n    used to fetch files from binary caches and by other downloads. It\n    defaults to 25. 0 means no limit.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry><term><literal>keep-build-log</literal></term>\n\n    <listitem><para>If set to <literal>true</literal> (the default),\n    Nix will write the build log of a derivation (i.e. the standard\n    output and error of its builder) to the directory\n    <filename>/nix/var/log/nix/drvs</filename>.  The build log can be\n    retrieved using the command <command>nix-store -l\n    <replaceable>path</replaceable></command>.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-keep-derivations\"><term><literal>keep-derivations</literal></term>\n\n    <listitem><para>If <literal>true</literal> (default), the garbage\n    collector will keep the derivations from which non-garbage store\n    paths were built.  If <literal>false</literal>, they will be\n    deleted unless explicitly registered as a root (or reachable from\n    other roots).</para>\n\n    <para>Keeping derivation around is useful for querying and\n    traceability (e.g., it allows you to ask with what dependencies or\n    options a store path was built), so by default this option is on.\n    Turn it off to save a bit of disk space (or a lot if\n    <literal>keep-outputs</literal> is also turned on).</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry><term><literal>keep-env-derivations</literal></term>\n\n    <listitem><para>If <literal>false</literal> (default), derivations\n    are not stored in Nix user environments.  That is, the derivation\n    any build-time-only dependencies may be garbage-collected.</para>\n\n    <para>If <literal>true</literal>, when you add a Nix derivation to\n    a user environment, the path of the derivation is stored in the\n    user environment.  Thus, the derivation will not be\n    garbage-collected until the user environment generation is deleted\n    (<command>nix-env --delete-generations</command>).  To prevent\n    build-time-only dependencies from being collected, you should also\n    turn on <literal>keep-outputs</literal>.</para>\n\n    <para>The difference between this option and\n    <literal>keep-derivations</literal> is that this one is\n    \u201csticky\u201d: it applies to any user environment created while this\n    option was enabled, while <literal>keep-derivations</literal>\n    only applies at the moment the garbage collector is\n    run.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-keep-outputs\"><term><literal>keep-outputs</literal></term>\n\n    <listitem><para>If <literal>true</literal>, the garbage collector\n    will keep the outputs of non-garbage derivations.  If\n    <literal>false</literal> (default), outputs will be deleted unless\n    they are GC roots themselves (or reachable from other roots).</para>\n\n    <para>In general, outputs must be registered as roots separately.\n    However, even if the output of a derivation is registered as a\n    root, the collector will still delete store paths that are used\n    only at build time (e.g., the C compiler, or source tarballs\n    downloaded from the network).  To prevent it from doing so, set\n    this option to <literal>true</literal>.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-max-build-log-size\"><term><literal>max-build-log-size</literal></term>\n\n    <listitem>\n\n      <para>This option defines the maximum number of bytes that a\n      builder can write to its stdout/stderr.  If the builder exceeds\n      this limit, it\u2019s killed.  A value of <literal>0</literal> (the\n      default) means that there is no limit.</para>\n\n    </listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-max-jobs\"><term><literal>max-jobs</literal></term>\n\n    <listitem><para>This option defines the maximum number of jobs\n    that Nix will try to build in parallel.  The default is\n    <literal>1</literal>. The special value <literal>auto</literal>\n    causes Nix to use the number of CPUs in your system.  It can be\n    overridden using the <option\n    linkend='opt-max-jobs'>--max-jobs</option> (<option>-j</option>)\n    command line switch.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-max-silent-time\"><term><literal>max-silent-time</literal></term>\n\n    <listitem>\n\n      <para>This option defines the maximum number of seconds that a\n      builder can go without producing any data on standard output or\n      standard error.  This is useful (for instance in an automated\n      build system) to catch builds that are stuck in an infinite\n      loop, or to catch remote builds that are hanging due to network\n      problems.  It can be overridden using the <option\n      linkend=\"opt-max-silent-time\">--max-silent-time</option> command\n      line switch.</para>\n\n      <para>The value <literal>0</literal> means that there is no\n      timeout.  This is also the default.</para>\n\n    </listitem>\n\n  </varlistentry>\n\n\n  <varlistentry><term><literal>netrc-file</literal></term>\n\n    <listitem><para>If set to an absolute path to a <filename>netrc</filename>\n    file, Nix will use the HTTP authentication credentials in this file when\n    trying to download from a remote host through HTTP or HTTPS. Defaults to\n    <filename>$NIX_CONF_DIR/netrc</filename>.</para>\n\n    <para>The <filename>netrc</filename> file consists of a list of\n    accounts in the following format:\n\n<screen>\nmachine <replaceable>my-machine</replaceable>\nlogin <replaceable>my-username</replaceable>\npassword <replaceable>my-password</replaceable>\n</screen>\n\n    For the exact syntax, see <link\n    xlink:href=\"https://ec.haxx.se/usingcurl-netrc.html\">the\n    <literal>curl</literal> documentation.</link></para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-plugin-files\">\n    <term><literal>plugin-files</literal></term>\n    <listitem>\n      <para>\n        A list of plugin files to be loaded by Nix. Each of these\n        files will be dlopened by Nix, allowing them to affect\n        execution through static initialization. In particular, these\n        plugins may construct static instances of RegisterPrimOp to\n        add new primops or constants to the expression language,\n        RegisterStoreImplementation to add new store implementations,\n        RegisterCommand to add new subcommands to the\n        <literal>nix</literal> command, and RegisterSetting to add new\n        nix config settings. See the constructors for those types for\n        more details.\n      </para>\n      <para>\n        Since these files are loaded into the same address space as\n        Nix itself, they must be DSOs compatible with the instance of\n        Nix running at the time (i.e. compiled against the same\n        headers, not linked to any incompatible libraries). They\n        should not be linked to any Nix libs directly, as those will\n        be available already at load time.\n      </para>\n      <para>\n        If an entry in the list is a directory, all files in the\n        directory are loaded as plugins (non-recursively).\n      </para>\n    </listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-pre-build-hook\"><term><literal>pre-build-hook</literal></term>\n\n    <listitem>\n\n\n      <para>If set, the path to a program that can set extra\n      derivation-specific settings for this system. This is used for settings\n      that can't be captured by the derivation model itself and are too variable\n      between different versions of the same system to be hard-coded into nix.\n      </para>\n\n      <para>The hook is passed the derivation path and, if sandboxes are enabled,\n      the sandbox directory. It can then modify the sandbox and send a series of\n      commands to modify various settings to stdout. The currently recognized\n      commands are:</para>\n\n      <variablelist>\n        <varlistentry xml:id=\"extra-sandbox-paths\">\n          <term><literal>extra-sandbox-paths</literal></term>\n\n          <listitem>\n\n            <para>Pass a list of files and directories to be included in the\n            sandbox for this build. One entry per line, terminated by an empty\n            line. Entries have the same format as\n            <literal>sandbox-paths</literal>.</para>\n\n          </listitem>\n\n        </varlistentry>\n      </variablelist>\n    </listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-repeat\"><term><literal>repeat</literal></term>\n\n    <listitem><para>How many times to repeat builds to check whether\n    they are deterministic. The default value is 0. If the value is\n    non-zero, every build is repeated the specified number of\n    times. If the contents of any of the runs differs from the\n    previous ones, the build is rejected and the resulting store paths\n    are not registered as \u201cvalid\u201d in Nix\u2019s database.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry><term><literal>require-sigs</literal></term>\n\n    <listitem><para>If set to <literal>true</literal> (the default),\n    any non-content-addressed path added or copied to the Nix store\n    (e.g. when substituting from a binary cache) must have a valid\n    signature, that is, be signed using one of the keys listed in\n    <option>trusted-public-keys</option> or\n    <option>secret-key-files</option>. Set to <literal>false</literal>\n    to disable signature checking.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-restrict-eval\"><term><literal>restrict-eval</literal></term>\n\n    <listitem>\n\n      <para>If set to <literal>true</literal>, the Nix evaluator will\n      not allow access to any files outside of the Nix search path (as\n      set via the <envar>NIX_PATH</envar> environment variable or the\n      <option>-I</option> option), or to URIs outside of\n      <option>allowed-uri</option>. The default is\n      <literal>false</literal>.</para>\n\n    </listitem>\n\n  </varlistentry>\n\n\n  <varlistentry><term><literal>sandbox</literal></term>\n\n    <listitem><para>If set to <literal>true</literal>, builds will be\n    performed in a <emphasis>sandboxed environment</emphasis>, i.e.,\n    they\u2019re isolated from the normal file system hierarchy and will\n    only see their dependencies in the Nix store, the temporary build\n    directory, private versions of <filename>/proc</filename>,\n    <filename>/dev</filename>, <filename>/dev/shm</filename> and\n    <filename>/dev/pts</filename> (on Linux), and the paths configured with the\n    <link linkend='conf-sandbox-paths'><literal>sandbox-paths</literal>\n    option</link>. This is useful to prevent undeclared dependencies\n    on files in directories such as <filename>/usr/bin</filename>. In\n    addition, on Linux, builds run in private PID, mount, network, IPC\n    and UTS namespaces to isolate them from other processes in the\n    system (except that fixed-output derivations do not run in private\n    network namespace to ensure they can access the network).</para>\n\n    <para>Currently, sandboxing only work on Linux and macOS. The use\n    of a sandbox requires that Nix is run as root (so you should use\n    the <link linkend='conf-build-users-group'>\u201cbuild users\u201d\n    feature</link> to perform the actual builds under different users\n    than root).</para>\n\n    <para>If this option is set to <literal>relaxed</literal>, then\n    fixed-output derivations and derivations that have the\n    <varname>__noChroot</varname> attribute set to\n    <literal>true</literal> do not run in sandboxes.</para>\n\n    <para>The default is <literal>false</literal>.</para>\n\n    </listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-sandbox-dev-shm-size\"><term><literal>sandbox-dev-shm-size</literal></term>\n\n    <listitem><para>This option determines the maximum size of the\n    <literal>tmpfs</literal> filesystem mounted on\n    <filename>/dev/shm</filename> in Linux sandboxes. For the format,\n    see the description of the <option>size</option> option of\n    <literal>tmpfs</literal> in\n    <citerefentry><refentrytitle>mount</refentrytitle><manvolnum>8</manvolnum></citerefentry>. The\n    default is <literal>50%</literal>.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-sandbox-paths\">\n    <term><literal>sandbox-paths</literal></term>\n\n    <listitem><para>A list of paths bind-mounted into Nix sandbox\n    environments. You can use the syntax\n    <literal><replaceable>target</replaceable>=<replaceable>source</replaceable></literal>\n    to mount a path in a different location in the sandbox; for\n    instance, <literal>/bin=/nix-bin</literal> will mount the path\n    <literal>/nix-bin</literal> as <literal>/bin</literal> inside the\n    sandbox. If <replaceable>source</replaceable> is followed by\n    <literal>?</literal>, then it is not an error if\n    <replaceable>source</replaceable> does not exist; for example,\n    <literal>/dev/nvidiactl?</literal> specifies that\n    <filename>/dev/nvidiactl</filename> will only be mounted in the\n    sandbox if it exists in the host filesystem.</para>\n\n    <para>Depending on how Nix was built, the default value for this option\n    may be empty or provide <filename>/bin/sh</filename> as a\n    bind-mount of <command>bash</command>.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry><term><literal>secret-key-files</literal></term>\n\n    <listitem><para>A whitespace-separated list of files containing\n    secret (private) keys. These are used to sign locally-built\n    paths. They can be generated using <command>nix-store\n    --generate-binary-cache-key</command>. The corresponding public\n    key can be distributed to other users, who can add it to\n    <option>trusted-public-keys</option> in their\n    <filename>nix.conf</filename>.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-show-trace\"><term><literal>show-trace</literal></term>\n\n    <listitem><para>Causes Nix to print out a stack trace in case of Nix\n    expression evaluation errors.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry><term><literal>substitute</literal></term>\n\n    <listitem><para>If set to <literal>true</literal> (default), Nix\n    will use binary substitutes if available.  This option can be\n    disabled to force building from source.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry><term><literal>substituters</literal></term>\n\n    <listitem><para>A list of URLs of substituters, separated by\n    whitespace.  The default is\n    <literal>https://cache.nixos.org</literal>.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry><term><literal>system</literal></term>\n\n    <listitem><para>This option specifies the canonical Nix system\n    name of the current installation, such as\n    <literal>i686-linux</literal> or\n    <literal>x86_64-darwin</literal>.  Nix can only build derivations\n    whose <literal>system</literal> attribute equals the value\n    specified here.  In general, it never makes sense to modify this\n    value from its default, since you can use it to \u2018lie\u2019 about the\n    platform you are building on (e.g., perform a Mac OS build on a\n    Linux machine; the result would obviously be wrong).  It only\n    makes sense if the Nix binaries can run on multiple platforms,\n    e.g., \u2018universal binaries\u2019 that run on <literal>x86_64-linux</literal> and\n    <literal>i686-linux</literal>.</para>\n\n    <para>It defaults to the canonical Nix system name detected by\n    <filename>configure</filename> at build time.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-timeout\"><term><literal>timeout</literal></term>\n\n    <listitem>\n\n      <para>This option defines the maximum number of seconds that a\n      builder can run.  This is useful (for instance in an automated\n      build system) to catch builds that are stuck in an infinite loop\n      but keep writing to their standard output or standard error.  It\n      can be overridden using the <option\n      linkend=\"opt-timeout\">--timeout</option> command line\n      switch.</para>\n\n      <para>The value <literal>0</literal> means that there is no\n      timeout.  This is also the default.</para>\n\n    </listitem>\n\n  </varlistentry>\n\n\n  <varlistentry><term><literal>trusted-public-keys</literal></term>\n\n    <listitem><para>A whitespace-separated list of public keys. When\n    paths are copied from another Nix store (such as a binary cache),\n    they must be signed with one of these keys. For example:\n    <literal>cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY=\n    hydra.nixos.org-1:CNHJZBh9K4tP3EKF6FkkgeVYsS3ohTl+oS0Qa8bezVs=</literal>.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry><term><literal>trusted-substituters</literal></term>\n\n    <listitem><para>A list of URLs of substituters, separated by\n    whitespace.  These are not used by default, but can be enabled by\n    users of the Nix daemon by specifying <literal>--option\n    substituters <replaceable>urls</replaceable></literal> on the\n    command line.  Unprivileged users are only allowed to pass a\n    subset of the URLs listed in <literal>substituters</literal> and\n    <literal>trusted-substituters</literal>.</para></listitem>\n\n  </varlistentry>\n\n\n  <varlistentry xml:id=\"conf-trusted-users\"><term><literal>trusted-users</literal></term>\n\n    <listitem>\n\n      <para>A list of names of users (separated by whitespace) that\n      have additional rights when connecting to the Nix daemon, such\n      as the ability to specify additional binary caches, or to import\n      unsigned NARs. You can also specify groups by prefixing them\n      with <literal>@</literal>; for instance,\n      <literal>@wheel</literal> means all users in the\n      <literal>wheel</literal> group. The default is\n      <literal>root</literal>.</para>\n\n      <warning><para>Adding a user to <option>trusted-users</option>\n      is essentially equivalent to giving that user root access to the\n      system. For example, the user can set\n      <option>sandbox-paths</option> and thereby obtain read access to\n      directories that are otherwise inacessible to\n      them.</para></warning>\n\n    </listitem>\n\n  </varlistentry>\n\n\n</variablelist>\n\n</para>\n\n</refsection>\n\n</refentry>\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/src/boost/format.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/src/boost/format/internals.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/src/boost/format/feed_args.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/src/boost/format/exceptions.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/src/boost/format/internals_fwd.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/src/boost/format/format_fwd.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/src/boost/format/group.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/src/boost/format/macros_default.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/src/boost/format/format_class.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/src/boost/format/format_implementation.cc",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/src/boost/format/free_funcs.cc",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/doc/manual/images/callouts/3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/doc/manual/images/callouts/12.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/doc/manual/images/callouts/5.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/doc/manual/images/callouts/8.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/doc/manual/images/callouts/4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/doc/manual/images/callouts/13.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/doc/manual/images/callouts/11.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/doc/manual/images/callouts/14.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/doc/manual/images/callouts/2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/doc/manual/images/callouts/9.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/doc/manual/images/callouts/15.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/doc/manual/images/callouts/6.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/doc/manual/images/callouts/7.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/doc/manual/images/callouts/10.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/doc/manual/images/callouts/1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/doc/manual/figures/user-environments.png",
        "/tmp/vanessa/spack-stage/spack-stage-nix-2.0.4-bs2hhdfogvq27fizf4zdwi2c2as5unuo/spack-src/doc/manual/figures/user-environments.sxd"
    ],
    "total_files": 698
}