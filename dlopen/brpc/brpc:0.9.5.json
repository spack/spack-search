{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/src/butil/debug/stack_trace_posix.cc": "// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"butil/debug/stack_trace.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <map>\n#include <ostream>\n#include <string>\n#include <vector>\n\n#if defined(__GLIBCXX__)\n#include <cxxabi.h>\n#endif\n#if !defined(__UCLIBC__)\n#include <execinfo.h>\n#endif\n\n#if defined(OS_MACOSX)\n#include <AvailabilityMacros.h>\n#endif\n\n#include \"butil/basictypes.h\"\n#include \"butil/debug/debugger.h\"\n#include \"butil/debug/proc_maps_linux.h\"\n#include \"butil/logging.h\"\n#include \"butil/memory/scoped_ptr.h\"\n#include \"butil/memory/singleton.h\"\n#include \"butil/numerics/safe_conversions.h\"\n#include \"butil/posix/eintr_wrapper.h\"\n#include \"butil/strings/string_number_conversions.h\"\n#include \"butil/build_config.h\"\n\n#if defined(USE_SYMBOLIZE)\n#include \"butil/third_party/symbolize/symbolize.h\"\n#endif\n\nnamespace butil {\nnamespace debug {\n\nnamespace {\n\nvolatile sig_atomic_t in_signal_handler = 0;\n\n#if !defined(USE_SYMBOLIZE) && defined(__GLIBCXX__)\n// The prefix used for mangled symbols, per the Itanium C++ ABI:\n// http://www.codesourcery.com/cxx-abi/abi.html#mangling\nconst char kMangledSymbolPrefix[] = \"_Z\";\n\n// Characters that can be used for symbols, generated by Ruby:\n// (('a'..'z').to_a+('A'..'Z').to_a+('0'..'9').to_a + ['_']).join\nconst char kSymbolCharacters[] =\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\";\n#endif  // !defined(USE_SYMBOLIZE) && defined(__GLIBCXX__)\n\n#if !defined(USE_SYMBOLIZE)\n// Demangles C++ symbols in the given text. Example:\n//\n// \"out/Debug/base_unittests(_ZN10StackTraceC1Ev+0x20) [0x817778c]\"\n// =>\n// \"out/Debug/base_unittests(StackTrace::StackTrace()+0x20) [0x817778c]\"\nvoid DemangleSymbols(std::string* text) {\n  // Note: code in this function is NOT async-signal safe (std::string uses\n  // malloc internally).\n\n#if defined(__GLIBCXX__) && !defined(__UCLIBC__)\n\n  std::string::size_type search_from = 0;\n  while (search_from < text->size()) {\n    // Look for the start of a mangled symbol, from search_from.\n    std::string::size_type mangled_start =\n        text->find(kMangledSymbolPrefix, search_from);\n    if (mangled_start == std::string::npos) {\n      break;  // Mangled symbol not found.\n    }\n\n    // Look for the end of the mangled symbol.\n    std::string::size_type mangled_end =\n        text->find_first_not_of(kSymbolCharacters, mangled_start);\n    if (mangled_end == std::string::npos) {\n      mangled_end = text->size();\n    }\n    std::string mangled_symbol =\n        text->substr(mangled_start, mangled_end - mangled_start);\n\n    // Try to demangle the mangled symbol candidate.\n    int status = 0;\n    scoped_ptr<char, butil::FreeDeleter> demangled_symbol(\n        abi::__cxa_demangle(mangled_symbol.c_str(), NULL, 0, &status));\n    if (status == 0) {  // Demangling is successful.\n      // Remove the mangled symbol.\n      text->erase(mangled_start, mangled_end - mangled_start);\n      // Insert the demangled symbol.\n      text->insert(mangled_start, demangled_symbol.get());\n      // Next time, we'll start right after the demangled symbol we inserted.\n      search_from = mangled_start + strlen(demangled_symbol.get());\n    } else {\n      // Failed to demangle.  Retry after the \"_Z\" we just found.\n      search_from = mangled_start + 2;\n    }\n  }\n\n#endif  // defined(__GLIBCXX__) && !defined(__UCLIBC__)\n}\n#endif  // !defined(USE_SYMBOLIZE)\n\nclass BacktraceOutputHandler {\n public:\n  virtual void HandleOutput(const char* output) = 0;\n\n protected:\n  virtual ~BacktraceOutputHandler() {}\n};\n\nvoid OutputPointer(void* pointer, BacktraceOutputHandler* handler) {\n  // This should be more than enough to store a 64-bit number in hex:\n  // 16 hex digits + 1 for null-terminator.\n  char buf[17] = { '\\0' };\n  handler->HandleOutput(\"0x\");\n  internal::itoa_r(reinterpret_cast<intptr_t>(pointer),\n                   buf, sizeof(buf), 16, 12);\n  handler->HandleOutput(buf);\n}\n\n#if defined(USE_SYMBOLIZE)\nvoid OutputFrameId(intptr_t frame_id, BacktraceOutputHandler* handler) {\n  // Max unsigned 64-bit number in decimal has 20 digits (18446744073709551615).\n  // Hence, 30 digits should be more than enough to represent it in decimal\n  // (including the null-terminator).\n  char buf[30] = { '\\0' };\n  handler->HandleOutput(\"#\");\n  internal::itoa_r(frame_id, buf, sizeof(buf), 10, 1);\n  handler->HandleOutput(buf);\n}\n#endif  // defined(USE_SYMBOLIZE)\n\nvoid ProcessBacktrace(void *const *trace,\n                      size_t size,\n                      BacktraceOutputHandler* handler) {\n  // NOTE: This code MUST be async-signal safe (it's used by in-process\n  // stack dumping signal handler). NO malloc or stdio is allowed here.\n\n#if defined(USE_SYMBOLIZE)\n  for (size_t i = 0; i < size; ++i) {\n    OutputFrameId(i, handler);\n    handler->HandleOutput(\" \");\n    OutputPointer(trace[i], handler);\n    handler->HandleOutput(\" \");\n\n    char buf[1024] = { '\\0' };\n\n    // Subtract by one as return address of function may be in the next\n    // function when a function is annotated as noreturn.\n    void* address = static_cast<char*>(trace[i]) - 1;\n    if (google::Symbolize(address, buf, sizeof(buf)))\n      handler->HandleOutput(buf);\n    else\n      handler->HandleOutput(\"<unknown>\");\n\n    handler->HandleOutput(\"\\n\");\n  }\n#elif !defined(__UCLIBC__)\n  bool printed = false;\n\n  // Below part is async-signal unsafe (uses malloc), so execute it only\n  // when we are not executing the signal handler.\n  if (in_signal_handler == 0) {\n    scoped_ptr<char*, FreeDeleter>\n        trace_symbols(backtrace_symbols(trace, size));\n    if (trace_symbols.get()) {\n      for (size_t i = 0; i < size; ++i) {\n        std::string trace_symbol = trace_symbols.get()[i];\n        DemangleSymbols(&trace_symbol);\n        handler->HandleOutput(trace_symbol.c_str());\n        handler->HandleOutput(\"\\n\");\n      }\n\n      printed = true;\n    }\n  }\n\n  if (!printed) {\n    for (size_t i = 0; i < size; ++i) {\n      handler->HandleOutput(\" [\");\n      OutputPointer(trace[i], handler);\n      handler->HandleOutput(\"]\\n\");\n    }\n  }\n#endif  // defined(USE_SYMBOLIZE)\n}\n\nvoid PrintToStderr(const char* output) {\n  // NOTE: This code MUST be async-signal safe (it's used by in-process\n  // stack dumping signal handler). NO malloc or stdio is allowed here.\n  ignore_result(HANDLE_EINTR(write(STDERR_FILENO, output, strlen(output))));\n}\n\nvoid StackDumpSignalHandler(int signal, siginfo_t* info, void* void_context) {\n  // NOTE: This code MUST be async-signal safe.\n  // NO malloc or stdio is allowed here.\n\n  // Record the fact that we are in the signal handler now, so that the rest\n  // of StackTrace can behave in an async-signal-safe manner.\n  in_signal_handler = 1;\n\n  if (BeingDebugged())\n    BreakDebugger();\n\n  PrintToStderr(\"Received signal \");\n  char buf[1024] = { 0 };\n  internal::itoa_r(signal, buf, sizeof(buf), 10, 0);\n  PrintToStderr(buf);\n  if (signal == SIGBUS) {\n    if (info->si_code == BUS_ADRALN)\n      PrintToStderr(\" BUS_ADRALN \");\n    else if (info->si_code == BUS_ADRERR)\n      PrintToStderr(\" BUS_ADRERR \");\n    else if (info->si_code == BUS_OBJERR)\n      PrintToStderr(\" BUS_OBJERR \");\n    else\n      PrintToStderr(\" <unknown> \");\n  } else if (signal == SIGFPE) {\n    if (info->si_code == FPE_FLTDIV)\n      PrintToStderr(\" FPE_FLTDIV \");\n    else if (info->si_code == FPE_FLTINV)\n      PrintToStderr(\" FPE_FLTINV \");\n    else if (info->si_code == FPE_FLTOVF)\n      PrintToStderr(\" FPE_FLTOVF \");\n    else if (info->si_code == FPE_FLTRES)\n      PrintToStderr(\" FPE_FLTRES \");\n    else if (info->si_code == FPE_FLTSUB)\n      PrintToStderr(\" FPE_FLTSUB \");\n    else if (info->si_code == FPE_FLTUND)\n      PrintToStderr(\" FPE_FLTUND \");\n    else if (info->si_code == FPE_INTDIV)\n      PrintToStderr(\" FPE_INTDIV \");\n    else if (info->si_code == FPE_INTOVF)\n      PrintToStderr(\" FPE_INTOVF \");\n    else\n      PrintToStderr(\" <unknown> \");\n  } else if (signal == SIGILL) {\n    if (info->si_code == ILL_BADSTK)\n      PrintToStderr(\" ILL_BADSTK \");\n    else if (info->si_code == ILL_COPROC)\n      PrintToStderr(\" ILL_COPROC \");\n    else if (info->si_code == ILL_ILLOPN)\n      PrintToStderr(\" ILL_ILLOPN \");\n    else if (info->si_code == ILL_ILLADR)\n      PrintToStderr(\" ILL_ILLADR \");\n    else if (info->si_code == ILL_ILLTRP)\n      PrintToStderr(\" ILL_ILLTRP \");\n    else if (info->si_code == ILL_PRVOPC)\n      PrintToStderr(\" ILL_PRVOPC \");\n    else if (info->si_code == ILL_PRVREG)\n      PrintToStderr(\" ILL_PRVREG \");\n    else\n      PrintToStderr(\" <unknown> \");\n  } else if (signal == SIGSEGV) {\n    if (info->si_code == SEGV_MAPERR)\n      PrintToStderr(\" SEGV_MAPERR \");\n    else if (info->si_code == SEGV_ACCERR)\n      PrintToStderr(\" SEGV_ACCERR \");\n    else\n      PrintToStderr(\" <unknown> \");\n  }\n  if (signal == SIGBUS || signal == SIGFPE ||\n      signal == SIGILL || signal == SIGSEGV) {\n    internal::itoa_r(reinterpret_cast<intptr_t>(info->si_addr),\n                     buf, sizeof(buf), 16, 12);\n    PrintToStderr(buf);\n  }\n  PrintToStderr(\"\\n\");\n\n  debug::StackTrace().Print();\n\n#if defined(OS_LINUX)\n#if ARCH_CPU_X86_FAMILY\n  ucontext_t* context = reinterpret_cast<ucontext_t*>(void_context);\n  const struct {\n    const char* label;\n    greg_t value;\n  } registers[] = {\n#if ARCH_CPU_32_BITS\n    { \"  gs: \", context->uc_mcontext.gregs[REG_GS] },\n    { \"  fs: \", context->uc_mcontext.gregs[REG_FS] },\n    { \"  es: \", context->uc_mcontext.gregs[REG_ES] },\n    { \"  ds: \", context->uc_mcontext.gregs[REG_DS] },\n    { \" edi: \", context->uc_mcontext.gregs[REG_EDI] },\n    { \" esi: \", context->uc_mcontext.gregs[REG_ESI] },\n    { \" ebp: \", context->uc_mcontext.gregs[REG_EBP] },\n    { \" esp: \", context->uc_mcontext.gregs[REG_ESP] },\n    { \" ebx: \", context->uc_mcontext.gregs[REG_EBX] },\n    { \" edx: \", context->uc_mcontext.gregs[REG_EDX] },\n    { \" ecx: \", context->uc_mcontext.gregs[REG_ECX] },\n    { \" eax: \", context->uc_mcontext.gregs[REG_EAX] },\n    { \" trp: \", context->uc_mcontext.gregs[REG_TRAPNO] },\n    { \" err: \", context->uc_mcontext.gregs[REG_ERR] },\n    { \"  ip: \", context->uc_mcontext.gregs[REG_EIP] },\n    { \"  cs: \", context->uc_mcontext.gregs[REG_CS] },\n    { \" efl: \", context->uc_mcontext.gregs[REG_EFL] },\n    { \" usp: \", context->uc_mcontext.gregs[REG_UESP] },\n    { \"  ss: \", context->uc_mcontext.gregs[REG_SS] },\n#elif ARCH_CPU_64_BITS\n    { \"  r8: \", context->uc_mcontext.gregs[REG_R8] },\n    { \"  r9: \", context->uc_mcontext.gregs[REG_R9] },\n    { \" r10: \", context->uc_mcontext.gregs[REG_R10] },\n    { \" r11: \", context->uc_mcontext.gregs[REG_R11] },\n    { \" r12: \", context->uc_mcontext.gregs[REG_R12] },\n    { \" r13: \", context->uc_mcontext.gregs[REG_R13] },\n    { \" r14: \", context->uc_mcontext.gregs[REG_R14] },\n    { \" r15: \", context->uc_mcontext.gregs[REG_R15] },\n    { \"  di: \", context->uc_mcontext.gregs[REG_RDI] },\n    { \"  si: \", context->uc_mcontext.gregs[REG_RSI] },\n    { \"  bp: \", context->uc_mcontext.gregs[REG_RBP] },\n    { \"  bx: \", context->uc_mcontext.gregs[REG_RBX] },\n    { \"  dx: \", context->uc_mcontext.gregs[REG_RDX] },\n    { \"  ax: \", context->uc_mcontext.gregs[REG_RAX] },\n    { \"  cx: \", context->uc_mcontext.gregs[REG_RCX] },\n    { \"  sp: \", context->uc_mcontext.gregs[REG_RSP] },\n    { \"  ip: \", context->uc_mcontext.gregs[REG_RIP] },\n    { \" efl: \", context->uc_mcontext.gregs[REG_EFL] },\n    { \" cgf: \", context->uc_mcontext.gregs[REG_CSGSFS] },\n    { \" erf: \", context->uc_mcontext.gregs[REG_ERR] },\n    { \" trp: \", context->uc_mcontext.gregs[REG_TRAPNO] },\n    { \" msk: \", context->uc_mcontext.gregs[REG_OLDMASK] },\n    { \" cr2: \", context->uc_mcontext.gregs[REG_CR2] },\n#endif\n  };\n\n#if ARCH_CPU_32_BITS\n  const int kRegisterPadding = 8;\n#elif ARCH_CPU_64_BITS\n  const int kRegisterPadding = 16;\n#endif\n\n  for (size_t i = 0; i < ARRAYSIZE_UNSAFE(registers); i++) {\n    PrintToStderr(registers[i].label);\n    internal::itoa_r(registers[i].value, buf, sizeof(buf),\n                     16, kRegisterPadding);\n    PrintToStderr(buf);\n\n    if ((i + 1) % 4 == 0)\n      PrintToStderr(\"\\n\");\n  }\n  PrintToStderr(\"\\n\");\n#endif\n#elif defined(OS_MACOSX)\n  // TODO(shess): Port to 64-bit, and ARM architecture (32 and 64-bit).\n#if ARCH_CPU_X86_FAMILY && ARCH_CPU_32_BITS\n  ucontext_t* context = reinterpret_cast<ucontext_t*>(void_context);\n  size_t len;\n\n  // NOTE: Even |snprintf()| is not on the approved list for signal\n  // handlers, but buffered I/O is definitely not on the list due to\n  // potential for |malloc()|.\n  len = static_cast<size_t>(\n      snprintf(buf, sizeof(buf),\n               \"ax: %x, bx: %x, cx: %x, dx: %x\\n\",\n               context->uc_mcontext->__ss.__eax,\n               context->uc_mcontext->__ss.__ebx,\n               context->uc_mcontext->__ss.__ecx,\n               context->uc_mcontext->__ss.__edx));\n  write(STDERR_FILENO, buf, std::min(len, sizeof(buf) - 1));\n\n  len = static_cast<size_t>(\n      snprintf(buf, sizeof(buf),\n               \"di: %x, si: %x, bp: %x, sp: %x, ss: %x, flags: %x\\n\",\n               context->uc_mcontext->__ss.__edi,\n               context->uc_mcontext->__ss.__esi,\n               context->uc_mcontext->__ss.__ebp,\n               context->uc_mcontext->__ss.__esp,\n               context->uc_mcontext->__ss.__ss,\n               context->uc_mcontext->__ss.__eflags));\n  write(STDERR_FILENO, buf, std::min(len, sizeof(buf) - 1));\n\n  len = static_cast<size_t>(\n      snprintf(buf, sizeof(buf),\n               \"ip: %x, cs: %x, ds: %x, es: %x, fs: %x, gs: %x\\n\",\n               context->uc_mcontext->__ss.__eip,\n               context->uc_mcontext->__ss.__cs,\n               context->uc_mcontext->__ss.__ds,\n               context->uc_mcontext->__ss.__es,\n               context->uc_mcontext->__ss.__fs,\n               context->uc_mcontext->__ss.__gs));\n  write(STDERR_FILENO, buf, std::min(len, sizeof(buf) - 1));\n#endif  // ARCH_CPU_32_BITS\n#endif  // defined(OS_MACOSX)\n  _exit(1);\n}\n\nclass PrintBacktraceOutputHandler : public BacktraceOutputHandler {\n public:\n  PrintBacktraceOutputHandler() {}\n\n  virtual void HandleOutput(const char* output) OVERRIDE {\n    // NOTE: This code MUST be async-signal safe (it's used by in-process\n    // stack dumping signal handler). NO malloc or stdio is allowed here.\n    PrintToStderr(output);\n  }\n\n private:\n  DISALLOW_COPY_AND_ASSIGN(PrintBacktraceOutputHandler);\n};\n\nclass StreamBacktraceOutputHandler : public BacktraceOutputHandler {\n public:\n  explicit StreamBacktraceOutputHandler(std::ostream* os) : os_(os) {\n  }\n\n  virtual void HandleOutput(const char* output) OVERRIDE {\n    (*os_) << output;\n  }\n\n private:\n  std::ostream* os_;\n\n  DISALLOW_COPY_AND_ASSIGN(StreamBacktraceOutputHandler);\n};\n\nvoid WarmUpBacktrace() {\n  // Warm up stack trace infrastructure. It turns out that on the first\n  // call glibc initializes some internal data structures using pthread_once,\n  // and even backtrace() can call malloc(), leading to hangs.\n  //\n  // Example stack trace snippet (with tcmalloc):\n  //\n  // #8  0x0000000000a173b5 in tc_malloc\n  //             at ./third_party/tcmalloc/chromium/src/debugallocation.cc:1161\n  // #9  0x00007ffff7de7900 in _dl_map_object_deps at dl-deps.c:517\n  // #10 0x00007ffff7ded8a9 in dl_open_worker at dl-open.c:262\n  // #11 0x00007ffff7de9176 in _dl_catch_error at dl-error.c:178\n  // #12 0x00007ffff7ded31a in _dl_open (file=0x7ffff625e298 \"libgcc_s.so.1\")\n  //             at dl-open.c:639\n  // #13 0x00007ffff6215602 in do_dlopen at dl-libc.c:89\n  // #14 0x00007ffff7de9176 in _dl_catch_error at dl-error.c:178\n  // #15 0x00007ffff62156c4 in dlerror_run at dl-libc.c:48\n  // #16 __GI___libc_dlopen_mode at dl-libc.c:165\n  // #17 0x00007ffff61ef8f5 in init\n  //             at ../sysdeps/x86_64/../ia64/backtrace.c:53\n  // #18 0x00007ffff6aad400 in pthread_once\n  //             at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S:104\n  // #19 0x00007ffff61efa14 in __GI___backtrace\n  //             at ../sysdeps/x86_64/../ia64/backtrace.c:104\n  // #20 0x0000000000752a54 in butil::debug::StackTrace::StackTrace\n  //             at butil/debug/stack_trace_posix.cc:175\n  // #21 0x00000000007a4ae5 in\n  //             butil::(anonymous namespace)::StackDumpSignalHandler\n  //             at butil/process_util_posix.cc:172\n  // #22 <signal handler called>\n  StackTrace stack_trace;\n}\n\n}  // namespace\n\n#if defined(USE_SYMBOLIZE)\n\n// class SandboxSymbolizeHelper.\n//\n// The purpose of this class is to prepare and install a \"file open\" callback\n// needed by the stack trace symbolization code\n// (butil/third_party/symbolize/symbolize.h) so that it can function properly\n// in a sandboxed process.  The caveat is that this class must be instantiated\n// before the sandboxing is enabled so that it can get the chance to open all\n// the object files that are loaded in the virtual address space of the current\n// process.\nclass SandboxSymbolizeHelper {\n public:\n  // Returns the singleton instance.\n  static SandboxSymbolizeHelper* GetInstance() {\n    return Singleton<SandboxSymbolizeHelper>::get();\n  }\n\n private:\n  friend struct DefaultSingletonTraits<SandboxSymbolizeHelper>;\n\n  SandboxSymbolizeHelper()\n      : is_initialized_(false) {\n    Init();\n  }\n\n  ~SandboxSymbolizeHelper() {\n    UnregisterCallback();\n    CloseObjectFiles();\n  }\n\n  // Returns a O_RDONLY file descriptor for |file_path| if it was opened\n  // sucessfully during the initialization.  The file is repositioned at\n  // offset 0.\n  // IMPORTANT: This function must be async-signal-safe because it can be\n  // called from a signal handler (symbolizing stack frames for a crash).\n  int GetFileDescriptor(const char* file_path) {\n    int fd = -1;\n\n#if !defined(NDEBUG)\n    if (file_path) {\n      // The assumption here is that iterating over std::map<std::string, int>\n      // using a const_iterator does not allocate dynamic memory, hense it is\n      // async-signal-safe.\n      std::map<std::string, int>::const_iterator it;\n      for (it = modules_.begin(); it != modules_.end(); ++it) {\n        if (strcmp((it->first).c_str(), file_path) == 0) {\n          // POSIX.1-2004 requires an implementation to guarantee that dup()\n          // is async-signal-safe.\n          fd = dup(it->second);\n          break;\n        }\n      }\n      // POSIX.1-2004 requires an implementation to guarantee that lseek()\n      // is async-signal-safe.\n      if (fd >= 0 && lseek(fd, 0, SEEK_SET) < 0) {\n        // Failed to seek.\n        fd = -1;\n      }\n    }\n#endif  // !defined(NDEBUG)\n\n    return fd;\n  }\n\n  // Searches for the object file (from /proc/self/maps) that contains\n  // the specified pc.  If found, sets |start_address| to the start address\n  // of where this object file is mapped in memory, sets the module base\n  // address into |base_address|, copies the object file name into\n  // |out_file_name|, and attempts to open the object file.  If the object\n  // file is opened successfully, returns the file descriptor.  Otherwise,\n  // returns -1.  |out_file_name_size| is the size of the file name buffer\n  // (including the null terminator).\n  // IMPORTANT: This function must be async-signal-safe because it can be\n  // called from a signal handler (symbolizing stack frames for a crash).\n  static int OpenObjectFileContainingPc(uint64_t pc, uint64_t& start_address,\n                                        uint64_t& base_address, char* file_path,\n                                        int file_path_size) {\n    // This method can only be called after the singleton is instantiated.\n    // This is ensured by the following facts:\n    // * This is the only static method in this class, it is private, and\n    //   the class has no friends (except for the DefaultSingletonTraits).\n    //   The compiler guarantees that it can only be called after the\n    //   singleton is instantiated.\n    // * This method is used as a callback for the stack tracing code and\n    //   the callback registration is done in the constructor, so logically\n    //   it cannot be called before the singleton is created.\n    SandboxSymbolizeHelper* instance = GetInstance();\n\n    // The assumption here is that iterating over\n    // std::vector<MappedMemoryRegion> using a const_iterator does not allocate\n    // dynamic memory, hence it is async-signal-safe.\n    std::vector<MappedMemoryRegion>::const_iterator it;\n    bool is_first = true;\n    for (it = instance->regions_.begin(); it != instance->regions_.end();\n         ++it, is_first = false) {\n      const MappedMemoryRegion& region = *it;\n      if (region.start <= pc && pc < region.end) {\n        start_address = region.start;\n        // Don't subtract 'start_address' from the first entry:\n        // * If a binary is compiled w/o -pie, then the first entry in\n        //   process maps is likely the binary itself (all dynamic libs\n        //   are mapped higher in address space). For such a binary,\n        //   instruction offset in binary coincides with the actual\n        //   instruction address in virtual memory (as code section\n        //   is mapped to a fixed memory range).\n        // * If a binary is compiled with -pie, all the modules are\n        //   mapped high at address space (in particular, higher than\n        //   shadow memory of the tool), so the module can't be the\n        //   first entry.\n        base_address = (is_first ? 0U : start_address) - region.offset;\n        if (file_path && file_path_size > 0) {\n          strncpy(file_path, region.path.c_str(), file_path_size);\n          // Ensure null termination.\n          file_path[file_path_size - 1] = '\\0';\n        }\n        return instance->GetFileDescriptor(region.path.c_str());\n      }\n    }\n    return -1;\n  }\n\n  // Parses /proc/self/maps in order to compile a list of all object file names\n  // for the modules that are loaded in the current process.\n  // Returns true on success.\n  bool CacheMemoryRegions() {\n    // Reads /proc/self/maps.\n    std::string contents;\n    if (!ReadProcMaps(&contents)) {\n      LOG(ERROR) << \"Failed to read /proc/self/maps\";\n      return false;\n    }\n\n    // Parses /proc/self/maps.\n    if (!ParseProcMaps(contents, &regions_)) {\n      LOG(ERROR) << \"Failed to parse the contents of /proc/self/maps\";\n      return false;\n    }\n\n    is_initialized_ = true;\n    return true;\n  }\n\n    // FIXME(gejun): Missing O_CLOEXEC from our linux headers. The flag should\n    // work on majority machines which installed 2.6.23 or newer kernels. But\n    // if the kernel is older, I'm not sure that open() will fail or ignore\n    // the flag.\n#ifndef O_CLOEXEC\n#define O_CLOEXEC 02000000\n#endif\n    \n  // Opens all object files and caches their file descriptors.\n  void OpenSymbolFiles() {\n    // Pre-opening and caching the file descriptors of all loaded modules is\n    // not considered safe for retail builds.  Hence it is only done in debug\n    // builds.  For more details, take a look at: http://crbug.com/341966\n    // Enabling this to release mode would require approval from the security\n    // team.\n#if !defined(NDEBUG)\n    // Open the object files for all read-only executable regions and cache\n    // their file descriptors.\n    std::vector<MappedMemoryRegion>::const_iterator it;\n    for (it = regions_.begin(); it != regions_.end(); ++it) {\n      const MappedMemoryRegion& region = *it;\n      // Only interesed in read-only executable regions.\n      if ((region.permissions & MappedMemoryRegion::READ) ==\n              MappedMemoryRegion::READ &&\n          (region.permissions & MappedMemoryRegion::WRITE) == 0 &&\n          (region.permissions & MappedMemoryRegion::EXECUTE) ==\n              MappedMemoryRegion::EXECUTE) {\n        if (region.path.empty()) {\n          // Skip regions with empty file names.\n          continue;\n        }\n        if (region.path[0] == '[') {\n          // Skip pseudo-paths, like [stack], [vdso], [heap], etc ...\n          continue;\n        }\n        // Avoid duplicates.\n        if (modules_.find(region.path) == modules_.end()) {\n          int fd = open(region.path.c_str(), O_RDONLY | O_CLOEXEC);\n          if (fd >= 0) {\n            modules_.insert(std::make_pair(region.path, fd));\n          } else {\n            LOG(WARNING) << \"Failed to open file: \" << region.path\n                         << \"\\n  Error: \" << strerror(errno);\n          }\n        }\n      }\n    }\n#endif  // !defined(NDEBUG)\n  }\n\n  // Initializes and installs the symbolization callback.\n  void Init() {\n    if (CacheMemoryRegions()) {\n      OpenSymbolFiles();\n      google::InstallSymbolizeOpenObjectFileCallback(\n          &OpenObjectFileContainingPc);\n    }\n  }\n\n  // Unregister symbolization callback.\n  void UnregisterCallback() {\n    if (is_initialized_) {\n      google::InstallSymbolizeOpenObjectFileCallback(NULL);\n      is_initialized_ = false;\n    }\n  }\n\n  // Closes all file descriptors owned by this instance.\n  void CloseObjectFiles() {\n#if !defined(NDEBUG)\n    std::map<std::string, int>::iterator it;\n    for (it = modules_.begin(); it != modules_.end(); ++it) {\n      int ret = IGNORE_EINTR(close(it->second));\n      DCHECK(!ret);\n      it->second = -1;\n    }\n    modules_.clear();\n#endif  // !defined(NDEBUG)\n  }\n\n  // Set to true upon successful initialization.\n  bool is_initialized_;\n\n#if !defined(NDEBUG)\n  // Mapping from file name to file descriptor.  Includes file descriptors\n  // for all successfully opened object files and the file descriptor for\n  // /proc/self/maps.  This code is not safe for release builds so\n  // this is only done for DEBUG builds.\n  std::map<std::string, int> modules_;\n#endif  // !defined(NDEBUG)\n\n  // Cache for the process memory regions.  Produced by parsing the contents\n  // of /proc/self/maps cache.\n  std::vector<MappedMemoryRegion> regions_;\n\n  DISALLOW_COPY_AND_ASSIGN(SandboxSymbolizeHelper);\n};\n#endif  // USE_SYMBOLIZE\n\nbool EnableInProcessStackDumpingForSandbox() {\n#if defined(USE_SYMBOLIZE)\n  SandboxSymbolizeHelper::GetInstance();\n#endif  // USE_SYMBOLIZE\n\n  return EnableInProcessStackDumping();\n}\n\nbool EnableInProcessStackDumping() {\n  // When running in an application, our code typically expects SIGPIPE\n  // to be ignored.  Therefore, when testing that same code, it should run\n  // with SIGPIPE ignored as well.\n  struct sigaction sigpipe_action;\n  memset(&sigpipe_action, 0, sizeof(sigpipe_action));\n  sigpipe_action.sa_handler = SIG_IGN;\n  sigemptyset(&sigpipe_action.sa_mask);\n  bool success = (sigaction(SIGPIPE, &sigpipe_action, NULL) == 0);\n\n  // Avoid hangs during backtrace initialization, see above.\n  WarmUpBacktrace();\n\n  struct sigaction action;\n  memset(&action, 0, sizeof(action));\n  action.sa_flags = SA_RESETHAND | SA_SIGINFO;\n  action.sa_sigaction = &StackDumpSignalHandler;\n  sigemptyset(&action.sa_mask);\n\n  success &= (sigaction(SIGILL, &action, NULL) == 0);\n  success &= (sigaction(SIGABRT, &action, NULL) == 0);\n  success &= (sigaction(SIGFPE, &action, NULL) == 0);\n  success &= (sigaction(SIGBUS, &action, NULL) == 0);\n  success &= (sigaction(SIGSEGV, &action, NULL) == 0);\n// On Linux, SIGSYS is reserved by the kernel for seccomp-bpf sandboxing.\n#if !defined(OS_LINUX)\n  success &= (sigaction(SIGSYS, &action, NULL) == 0);\n#endif  // !defined(OS_LINUX)\n\n  return success;\n}\n\nStackTrace::StackTrace() {\n  // NOTE: This code MUST be async-signal safe (it's used by in-process\n  // stack dumping signal handler). NO malloc or stdio is allowed here.\n\n#if !defined(__UCLIBC__)\n  // Though the backtrace API man page does not list any possible negative\n  // return values, we take no chance.\n  count_ = butil::saturated_cast<size_t>(backtrace(trace_, arraysize(trace_)));\n#else\n  count_ = 0;\n#endif\n}\n\nvoid StackTrace::Print() const {\n  // NOTE: This code MUST be async-signal safe (it's used by in-process\n  // stack dumping signal handler). NO malloc or stdio is allowed here.\n\n#if !defined(__UCLIBC__)\n  PrintBacktraceOutputHandler handler;\n  ProcessBacktrace(trace_, count_, &handler);\n#endif\n}\n\n#if !defined(__UCLIBC__)\nvoid StackTrace::OutputToStream(std::ostream* os) const {\n  StreamBacktraceOutputHandler handler(os);\n  ProcessBacktrace(trace_, count_, &handler);\n}\n#endif\n\nnamespace internal {\n\n// NOTE: code from sandbox/linux/seccomp-bpf/demo.cc.\nchar *itoa_r(intptr_t i, char *buf, size_t sz, int base, size_t padding) {\n  // Make sure we can write at least one NUL byte.\n  size_t n = 1;\n  if (n > sz)\n    return NULL;\n\n  if (base < 2 || base > 16) {\n    buf[0] = '\\000';\n    return NULL;\n  }\n\n  char *start = buf;\n\n  uintptr_t j = i;\n\n  // Handle negative numbers (only for base 10).\n  if (i < 0 && base == 10) {\n    j = -i;\n\n    // Make sure we can write the '-' character.\n    if (++n > sz) {\n      buf[0] = '\\000';\n      return NULL;\n    }\n    *start++ = '-';\n  }\n\n  // Loop until we have converted the entire number. Output at least one\n  // character (i.e. '0').\n  char *ptr = start;\n  do {\n    // Make sure there is still enough space left in our output buffer.\n    if (++n > sz) {\n      buf[0] = '\\000';\n      return NULL;\n    }\n\n    // Output the next digit.\n    *ptr++ = \"0123456789abcdef\"[j % base];\n    j /= base;\n\n    if (padding > 0)\n      padding--;\n  } while (j > 0 || padding > 0);\n\n  // Terminate the output with a NUL character.\n  *ptr = '\\000';\n\n  // Conversion to ASCII actually resulted in the digits being in reverse\n  // order. We can't easily generate them in forward order, as we can't tell\n  // the number of characters needed until we are done converting.\n  // So, now, we reverse the string (except for the possible \"-\" sign).\n  while (--ptr > start) {\n    char ch = *ptr;\n    *ptr = *start;\n    *start++ = ch;\n  }\n  return buf;\n}\n\n}  // namespace internal\n\n}  // namespace debug\n}  // namespace butil\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/pchan.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/echo_cpu_profiling.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/register_ns.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/302.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/connection_timedout.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/ubrpc_compare_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/apicontrol_compare_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/rpc_view_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/bthread_concurrency_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/backup_request_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/short_conn.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/baidu_dsp_compare_5.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/rpcz_6.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/qps_vs_threadnum.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/multi_client_latency_cdf.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/baidu_dsp_compare_4.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/status.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/version_service.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/baidu_dsp_compare_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/growth_profiler.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/bvar_dump_flags.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/rpc_replay_4.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/rpcz_7.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/baidu_dsp_compare_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/set_flag_with_form_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/chash.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/lalb_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/latency_cdf.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/baidu_dsp_compare_6.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/rpc_replay_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/bvar_noah2.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/vars_7.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/ns_filter.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/apicontrol_compare_5.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/rpcz_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/vars_6.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/raft_contention_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/reloadable_flags.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/set_flag_reject.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/restful_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/ubrpc_compare_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/twolevel_server_latency_cdf.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/set_flag_with_form.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/vars_4.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/heap_profiler_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/dummy_server_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/ns.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/rpc_replay_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/rpc_replay_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/backup_request_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/vars_3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/resource_pool.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/rpc_press_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/single_conn.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/bthread_creation_qps.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/bthread_concurrency_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/qps_vs_reqsize.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/apicontrol_compare_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/threading_overview_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/bvar_dump_flags_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/set_flag_with_form_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/bthread_concurrency_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/status_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/baidu_dsp_compare_7.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/lalb_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/rpc_view_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/dummy_server_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/baidu_dsp_compare_9.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/rpcz_4.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/server_side.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/restful_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/rpc_replay_5.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/backup_request_4.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/bvar_noah1.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/full_worker_usage.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/client_side.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/lalb_5.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/high_cpu_usage.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/heap_profiler_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/the_r_after_flag.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/tcmalloc_stuck.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/health_service.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/backup_request_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/foobar_bvar.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/builtin_service_from_console.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/lalb_4.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/protobufs_service.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/qps_vs_multi_client.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/rpc.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/builtin_service_more.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/register_lb.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/bvar_noah3.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/baidu_dsp_compare_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/threading_overview_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/baidu_dsp_compare_8.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/dummy_server_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/rpcz_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/trace_printf.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/restful_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/apicontrol_compare_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/rpcz.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/lalb_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/normal_worker_usage.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/set_flag_invalid_value.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/normal_cpu_usage.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/vars_5.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/rpc_flow.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/raft_contention_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/write.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/vlog_service.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/baidu_dsp_compare_10.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/vars_2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/full_worker_usage_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/heap_profiler_3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/bvar_perf.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/rpc_press_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/vars_1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/pooled_conn.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/flag_setvalue.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/lb.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/ns_access_interval.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/rpc_view_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/rpcz_5.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/apicontrol_compare_4.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/bvar_flow.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/multi_server_latency_cdf.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/foobar_latency_cdf.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/images/raft_contention_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/cn/brpc_intro.pptx",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/en/brpc_internal.pptx",
        "/tmp/vanessa/spack-stage/spack-stage-brpc-0.9.5-u4pa2c5n6n6ozr4teu3577a27jfjeoub/spack-src/docs/en/tutorial_on_building_services.pptx"
    ],
    "total_files": 1364
}