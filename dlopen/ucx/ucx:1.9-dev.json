{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/.gitignore": ".gitignore\n.project\n.cproject\n.settings\nTAGS\ntest/test\nMakefile\nMakefile.in\naclocal.m4\ncompile\nconfig.guess\nconfig.h.in\nconfig.h.in~\nconfig.sub\nconfig/m4/libtool.m4\nconfig/m4/ltoptions.m4\nconfig/m4/ltsugar.m4\nconfig/m4/ltversion.m4\nconfig/m4/lt~obsolete.m4\nconfig/aux\nconfigure\ninstall-sh\nltmain.sh\nmissing\nconfig.h\nconfig.log\nconfig.status\nlibtool\nstamp-h1\nsrc/uct/api/version.h\nautom4te.cache\ndepcomp\n.libs\n*.la\n.deps\n.dirstamp\n*.lo\n*.o\ncontrib/rpmdef.sh\nbindings/java/pom.xml\nsrc/ucs/ucs_stats_parser\ntest/gtest/gtest\ntest/perf/ucx_perftest\nbuild-*\nucx*tar.gz\nsrc/tools/info/build_config.h\nsrc/tools/info/ucx_info\nsrc/tools/perf/ucx_perftest\nsrc/tools/profile/ucx_read_profile\ntest/apps/test_dlopen_cfg_print\ntest/apps/test_link_map\ntest/apps/test_ucp_dlopen\ntest/apps/test_ucs_dlopen\ntest/apps/sockaddr/sa\ntest/examples/ucp_client_server\ntest/examples/ucp_hello_world\ntest/examples/uct_hello_world\ntest/examples/ucx_profiling\nrpm-dist\ncov_build*\ndebian/changelog\ndebian/control\ndebian/rules\ndebian/ucx.postinst\nucx.spec\nucx.pc\ndoc/doxygen-doc\ndoc/uml/uct.pdf\ndoc/doxygen/header.tex\ntest-driver\nsrc/ucp/api/ucp_version.h\nsrc/ucp/core/ucp_version.c\ntest/mpi/run_mpi.sh\n*.tap\nvalgrind.xml\ntags\n.pydevproject\n/ucx-*.*.*\n/v*.*.*\norg_openucx_jucx_*.h\nGPATH\nGRTAGS\nGTAGS\n/modules\n*.swp\ncompile_commands.json\ndocs/_build\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/config/m4/ucs.m4": "#\n# Copyright (C) Mellanox Technologies Ltd. 2001-2014.  ALL RIGHTS RESERVED.\n# Copyright (C) UT-Battelle, LLC. 2015. ALL RIGHTS RESERVED.\n# Copyright (C) ARM, Ltd. 2016. ALL RIGHTS RESERVED.\n# See file LICENSE for terms.\n#\n\n\n#\n# Internal profiling support.\n# This option may affect perofrmance so it is off by default.\n#\nAC_ARG_ENABLE([profiling],\n\tAS_HELP_STRING([--enable-profiling], [Enable profiling support, default: NO]),\n\t[],\n\t[enable_profiling=no])\n\nAS_IF([test \"x$enable_profiling\" = xyes],\n\t[AS_MESSAGE([enabling profiling])\n\t AC_DEFINE([HAVE_PROFILING], [1], [Enable profiling])\n\t HAVE_PROFILING=yes]\n\t[:]\n)\nAM_CONDITIONAL([HAVE_PROFILING],[test \"x$HAVE_PROFILING\" = \"xyes\"])\n\n\n#\n# Detailed backtrace with debug information.\n# This option requires binutils-devel package.\n#\nAC_ARG_ENABLE([backtrace-detail],\n\tAS_HELP_STRING([--disable-backtrace-detail], [Disable detailed backtrace support, default: NO]),\n\t[],\n\t[enable_backtrace_detail=yes])\n\t\nAS_IF([test \"x$enable_backtrace_detail\" = xyes],\n\t[\n\tBT=1\n\tAC_CHECK_HEADER([bfd.h], [], [AC_MSG_WARN([binutils headers not found])]; BT=0)\n\tAC_CHECK_LIB(bfd, bfd_openr,  LIBS=\"$LIBS -lbfd\", [AC_MSG_WARN([bfd library not found])];BT=0)\n\tAC_CHECK_LIB(dl, dlopen, LIBS=\"$LIBS -ldl\", [AC_MSG_WARN([dl library not found])];BT=0)\n\tAC_CHECK_LIB(intl, main, LIBS=\"$LIBS -lintl\", [AC_MSG_WARN([intl library not found])])\n\tAC_CHECK_TYPES([struct dl_phdr_info], [], [AC_MSG_WARN([struct dl_phdr_info not defined])];BT=0,\n\t\t\t\t\t[#define _GNU_SOURCE 1\n\t\t\t\t\t #include <link.h>]) \n\tAC_CHECK_DECLS([bfd_get_section_flags, bfd_section_flags, bfd_get_section_vma, bfd_section_vma],\n\t\t       [], [], [#include <bfd.h>])\n\n\tAC_MSG_CHECKING([bfd_section_size API version])\n\tAC_LANG_PUSH([C])\n\tSAVE_CFLAGS=\"$CFLAGS\"\n\tAC_COMPILE_IFELSE([AC_LANG_SOURCE([[\n\t\t#include <bfd.h>\n\t\tint main(int argc, char** argv) {\n\t\t\tasection *sec = malloc(sizeof(*sec));\n\t\t\tbfd_section_size(sec);\n\t\t\tfree(sec);\n\t\t\treturn 0;\n\t\t} ]])],\n\t\t[AC_MSG_RESULT([1-arg API])\n\t\t AC_DEFINE([HAVE_1_ARG_BFD_SECTION_SIZE], [1],\n\t\t\t   [bfd_section_size 1-arg version])],\n\t\t[AC_MSG_RESULT([2-args API])\n\t\t AC_DEFINE([HAVE_1_ARG_BFD_SECTION_SIZE], [0],\n\t\t\t   [bfd_section_size 2-args version])])\n\tCFLAGS=\"$SAVE_CFLAGS\"\n\tAC_LANG_POP([C])\n\n\tif test \"x$BT\" = \"x1\"; then\n\t\tAC_CHECK_FUNCS([cplus_demangle])\n\t\tAC_DEFINE([HAVE_DETAILED_BACKTRACE], 1, [Enable detailed backtrace])\n        case ${host} in\n            aarch64*) CFLAGS=\"$CFLAGS -funwind-tables\" ;;\n        esac\n\telse\n\t\tAC_MSG_WARN([detailed backtrace is not supported])\n\tfi\n\t]\n)\n\n\n#\n# Enable statistics and counters\n#\nAC_ARG_ENABLE([stats],\n\tAS_HELP_STRING([--enable-stats], \n\t               [Enable statistics, useful for profiling, default: NO]),\n\t[],\n\t[enable_stats=no])\n\t\nAS_IF([test \"x$enable_stats\" = xyes],\n\t  [AS_MESSAGE([enabling statistics])\n\t   AC_DEFINE([ENABLE_STATS], [1], [Enable statistics])\n\t   HAVE_STATS=yes],\n\t  [:]\n  )\nAM_CONDITIONAL([HAVE_STATS],[test \"x$HAVE_STATS\" = \"xyes\"])\n\n\n#\n# Enable tuning params at runtime\n#\nAC_ARG_ENABLE([tuning],\n\tAS_HELP_STRING([--enable-tuning], \n\t               [Enable parameter tuning in run-time, default: NO]),\n\t[],\n\t[enable_tuning=no])\n\t\nAS_IF([test \"x$enable_tuning\" = xyes],\n\t  [AS_MESSAGE([enabling tuning])\n\t   AC_DEFINE([ENABLE_TUNING], [1], [Enable tuning])\n\t   HAVE_TUNING=yes],\n\t  [:]\n  )\nAM_CONDITIONAL([HAVE_TUNING],[test \"x$HAVE_TUNING\" = \"xyes\"])\n\n\n#\n# Enable memory tracking\n#\nAC_ARG_ENABLE([memtrack],\n\tAS_HELP_STRING([--enable-memtrack], \n\t               [Enable memory tracking, useful for profiling, default: NO]),\n\t[],\n\t[enable_memtrack=no])\n\t\nAS_IF([test \"x$enable_memtrack\" = xyes],\n\t  [AS_MESSAGE([enabling memory tracking])\n\t   AC_DEFINE([ENABLE_MEMTRACK], [1], [Enable memory tracking])\n\t   HAVE_MEMTRACK=yes],\n\t  [:]\n  )\nAM_CONDITIONAL([HAVE_MEMTRACK],[test \"x$HAVE_MEMTRACK\" = \"xyes\"])\n\n\n#\n# Disable logging levels below INFO\n#\nAC_ARG_ENABLE([logging],\n\tAS_HELP_STRING([--enable-logging],\n\t               [Enable debug logging, default: YES])\n\t)\n\nAS_IF([test \"x$enable_logging\" != xno],\n        [AC_DEFINE([UCS_MAX_LOG_LEVEL], [UCS_LOG_LEVEL_TRACE_POLL], [Highest log level])],\n        [AC_DEFINE([UCS_MAX_LOG_LEVEL], [UCS_LOG_LEVEL_INFO], [Highest log level])]\n    )\n\n#\n# Disable assertions\n#\nAC_ARG_ENABLE([assertions],\n\tAS_HELP_STRING([--disable-assertions], \n\t               [Disable code assertions, default: NO])\n\t)\n\nAS_IF([test \"x$enable_assertions\" != xno],\n\t\tAC_DEFINE([ENABLE_ASSERT], [1], [Enable assertions])\n\t)\n\n#\n# Check if __attribute__((constructor)) works\n#\nAC_MSG_CHECKING([__attribute__((constructor))])\nCHECK_CROSS_COMP([AC_LANG_SOURCE([static int rc = 1;\n                  static void constructor_test() __attribute__((constructor));\n                  static void constructor_test() { rc = 0; }\n                  int main(int argc, char** argv) { return rc; }])],\n                [AC_MSG_RESULT([yes])],\n                [AC_MSG_ERROR([Cannot continue. Please use compiler that\n                             supports __attribute__((constructor))])]\n                )\n\n\n#\n# Manual configuration of cacheline size\n#\nAC_ARG_WITH([cache-line-size],\n        [AC_HELP_STRING([--with-cache-line-size=SIZE],\n            [Build UCX with cache line size defined by user. This parameter\n             overwrites default cache line sizes defines in\n             UCX (x86-64: 64, Power: 128, ARMv8: 64/128). The supported values are: 64, 128])],\n        [],\n        [with_cache_line_size=no])\n\nAS_IF([test \"x$with_cache_line_size\" != xno],[\n\t     case ${with_cache_line_size} in\n                 64)\n\t\t     AC_MSG_RESULT(The cache line size is set to 64B)\n\t\t     AC_DEFINE([HAVE_CACHE_LINE_SIZE], 64, [user defined cache line size])\n\t\t     ;;\n\t\t 128)\n\t\t     AC_MSG_RESULT(The cache line size is set to 128B)\n\t\t     AC_DEFINE([HAVE_CACHE_LINE_SIZE], 128, [user defined cache line size])\n\t\t     ;;\n\t\t @<:@0-9@:>@*)\n\t\t     AC_MSG_WARN(Unusual cache cache line size was specified: [$with_cache_line_size])\n\t\t     AC_DEFINE_UNQUOTED([HAVE_CACHE_LINE_SIZE], [$with_cache_line_size], [user defined cache line size])\n\t\t     ;;\n\t\t *)\n\t\t     AC_MSG_ERROR(Cannot continue. Unsupported cache line size [$with_cache_line_size].)\n\t\t     ;;\n             esac],\n\t     [])\n\n\n#\n# Architecture specific checks\n#\ncase ${host} in\n    aarch64*)\n    AC_MSG_CHECKING([support for CNTVCT_EL0 on aarch64])\n    AC_RUN_IFELSE([AC_LANG_PROGRAM(\n                  [[#include <stdint.h>]],\n                  [[uint64_t tmp; asm volatile(\"mrs %0, cntvct_el0\" : \"=r\" (tmp));]])],\n                  [AC_MSG_RESULT([yes])]\n\t\t  [AC_DEFINE([HAVE_HW_TIMER], [1], [high-resolution hardware timer enabled])],\n\t\t  [AC_MSG_RESULT([no])]\n\t\t  [AC_DEFINE([HAVE_HW_TIMER], [0], [high-resolution hardware timer disabled])]\n                 );;\n    *)\n    # HW timer is supported for all other architectures\n    AC_DEFINE([HAVE_HW_TIMER], [1], [high-resolution hardware timer disabled])\nesac\n\n#\n# Enable built-in memcpy\n#\nAC_ARG_ENABLE([builtin-memcpy],\n\tAS_HELP_STRING([--enable-builtin-memcpy],\n\t               [Enable builtin memcpy routine, default: YES]),\n\t[],\n\t[enable_builtin_memcpy=yes])\n\nAS_IF([test \"x$enable_builtin_memcpy\" != xno],\n\t  [AS_MESSAGE([enabling builtin memcpy])\n\t   AC_DEFINE([ENABLE_BUILTIN_MEMCPY], [1], [Enable builtin memcpy])],\n\t  [AC_DEFINE([ENABLE_BUILTIN_MEMCPY], [0], [Enable builtin memcpy])]\n  )\n\nAC_CHECK_FUNCS([__clear_cache], [], [])\nAC_CHECK_FUNCS([__aarch64_sync_cache_range], [], [])\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/src/ucm/util/sys.c": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2001-2016.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#ifndef _GNU_SOURCE\n#  define _GNU_SOURCE /* for dladdr */\n#endif\n\n#include \"sys.h\"\n\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif\n\n#include <ucm/api/ucm.h>\n#include <ucm/util/log.h>\n#include <ucm/event/event.h>\n#include <ucm/mmap/mmap.h>\n#include <ucs/sys/math.h>\n#include <ucs/sys/topo.h>\n#include <linux/mman.h>\n#include <sys/mman.h>\n#include <pthread.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dlfcn.h>\n\n\n#define UCM_PROC_SELF_MAPS \"/proc/self/maps\"\n\nucm_global_config_t ucm_global_opts = {\n    .log_level                  = UCS_LOG_LEVEL_WARN,\n    .enable_events              = 1,\n    .mmap_hook_mode             = UCM_DEFAULT_HOOK_MODE,\n    .enable_malloc_hooks        = 1,\n    .enable_malloc_reloc        = 0,\n    .enable_cuda_reloc          = 1,\n    .enable_dynamic_mmap_thresh = 1,\n    .alloc_alignment            = 16,\n    .dlopen_process_rpath       = 1\n};\n\nsize_t ucm_get_page_size()\n{\n    static long page_size = -1;\n    long value;\n\n    if (page_size == -1) {\n        value = sysconf(_SC_PAGESIZE);\n        if (value < 0) {\n            page_size = 4096;\n        } else {\n            page_size = value;\n        }\n    }\n    return page_size;\n}\n\nstatic void *ucm_sys_complete_alloc(void *ptr, size_t size)\n{\n    *(size_t*)ptr = size;\n    return UCS_PTR_BYTE_OFFSET(ptr, sizeof(size_t));\n}\n\nvoid *ucm_sys_malloc(size_t size)\n{\n    size_t sys_size;\n    void *ptr;\n\n    sys_size = ucs_align_up_pow2(size + sizeof(size_t), ucm_get_page_size());\n    ptr = ucm_orig_mmap(NULL, sys_size, PROT_READ|PROT_WRITE,\n                        MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    if (ptr == MAP_FAILED) {\n        ucm_error(\"mmap(size=%zu) failed: %m\", sys_size);\n        return NULL;\n    }\n\n    return ucm_sys_complete_alloc(ptr, sys_size);\n}\n\nvoid *ucm_sys_calloc(size_t nmemb, size_t size)\n{\n    size_t total_size = size * nmemb;\n    void *ptr;\n\n    ptr = ucm_sys_malloc(total_size);\n    if (ptr == NULL) {\n        return NULL;\n    }\n\n    memset(ptr, 0, total_size);\n    return ptr;\n}\n\nvoid ucm_sys_free(void *ptr)\n{\n    size_t size;\n\n    if (ptr == NULL) {\n        return;\n    }\n\n    /* Do not use UCS_PTR_BYTE_OFFSET macro here due to coverity\n     * false positive.\n     * TODO: check for false positive on newer coverity. */\n    ptr  = (char*)ptr - sizeof(size_t);\n    size = *(size_t*)ptr;\n    munmap(ptr, size);\n}\n\nvoid *ucm_sys_realloc(void *ptr, size_t size)\n{\n    size_t oldsize, sys_size;\n    void *oldptr, *newptr;\n\n    if (ptr == NULL) {\n        return ucm_sys_malloc(size);\n    }\n\n    oldptr   = UCS_PTR_BYTE_OFFSET(ptr, -sizeof(size_t));\n    oldsize  = *(size_t*)oldptr;\n    sys_size = ucs_align_up_pow2(size + sizeof(size_t), ucm_get_page_size());\n\n    if (sys_size == oldsize) {\n        return ptr;\n    }\n\n    newptr = ucm_orig_mremap(oldptr, oldsize, sys_size, MREMAP_MAYMOVE);\n    if (newptr == MAP_FAILED) {\n        ucm_error(\"mremap(oldptr=%p oldsize=%zu, newsize=%zu) failed: %m\",\n                  oldptr, oldsize, sys_size);\n        return NULL;\n    }\n\n    return ucm_sys_complete_alloc(newptr, sys_size);\n}\n\nvoid ucm_parse_proc_self_maps(ucm_proc_maps_cb_t cb, void *arg)\n{\n    static char  *buffer         = MAP_FAILED;\n    static size_t buffer_size    = 32768;\n    static pthread_rwlock_t lock = PTHREAD_RWLOCK_INITIALIZER;\n    ssize_t read_size, offset;\n    unsigned long start, end;\n    char prot_c[4];\n    int line_num;\n    int prot;\n    char *ptr, *newline;\n    int maps_fd;\n    int ret;\n    int n;\n\n    maps_fd = open(UCM_PROC_SELF_MAPS, O_RDONLY);\n    if (maps_fd < 0) {\n        ucm_fatal(\"cannot open %s for reading: %m\", UCM_PROC_SELF_MAPS);\n    }\n\n    /* read /proc/self/maps fully into the buffer */\n    pthread_rwlock_wrlock(&lock);\n\n    if (buffer == MAP_FAILED) {\n        buffer = ucm_orig_mmap(NULL, buffer_size, PROT_READ|PROT_WRITE,\n                               MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n        if (buffer == MAP_FAILED) {\n            ucm_fatal(\"failed to allocate maps buffer(size=%zu): %m\", buffer_size);\n        }\n    }\n\n    offset = 0;\n    for (;;) {\n        read_size = read(maps_fd, buffer + offset, buffer_size - offset);\n        if (read_size < 0) {\n            /* error */\n            if (errno != EINTR) {\n                ucm_fatal(\"failed to read from %s: %m\", UCM_PROC_SELF_MAPS);\n            }\n        } else if (read_size == buffer_size - offset) {\n            /* enlarge buffer */\n            buffer = ucm_orig_mremap(buffer, buffer_size, buffer_size * 2,\n                                     MREMAP_MAYMOVE);\n            if (buffer == MAP_FAILED) {\n                ucm_fatal(\"failed to allocate maps buffer(size=%zu)\", buffer_size);\n            }\n            buffer_size *= 2;\n\n            /* read again from the beginning of the file */\n            ret = lseek(maps_fd, 0, SEEK_SET);\n            if (ret < 0) {\n               ucm_fatal(\"failed to lseek(0): %m\");\n            }\n            offset = 0;\n        } else if (read_size == 0) {\n            /* finished reading */\n            buffer[offset] = '\\0';\n            break;\n        } else {\n            /* more data could be available even if the buffer is not full */\n            offset += read_size;\n        }\n    }\n    pthread_rwlock_unlock(&lock);\n\n    close(maps_fd);\n\n    pthread_rwlock_rdlock(&lock);\n\n    ptr      = buffer;\n    line_num = 1;\n    while ( (newline = strchr(ptr, '\\n')) != NULL ) {\n        /* address           perms offset   dev   inode   pathname\n         * 00400000-0040b000 r-xp  00001a00 0a:0b 12345   /dev/mydev\n         */\n        *newline = '\\0';\n        ret = sscanf(ptr, \"%lx-%lx %4c %*x %*x:%*x %*d %n\",\n                     &start, &end, prot_c,\n                     /* ignore offset, dev, inode */\n                     &n /* save number of chars before path begins */);\n        if (ret < 3) {\n            ucm_warn(\"failed to parse %s line %d: '%s'\",\n                     UCM_PROC_SELF_MAPS, line_num, ptr);\n        } else {\n            prot = 0;\n            if (prot_c[0] == 'r') {\n                prot |= PROT_READ;\n            }\n            if (prot_c[1] == 'w') {\n                prot |= PROT_WRITE;\n            }\n            if (prot_c[2] == 'x') {\n                prot |= PROT_EXEC;\n            }\n\n            if (cb(arg, (void*)start, end - start, prot, ptr + n)) {\n                goto out;\n            }\n        }\n\n        ptr = newline + 1;\n        ++line_num;\n    }\n\nout:\n    pthread_rwlock_unlock(&lock);\n}\n\ntypedef struct {\n    const void   *shmaddr;\n    size_t       seg_size;\n} ucm_get_shm_seg_size_ctx_t;\n\nstatic int ucm_get_shm_seg_size_cb(void *arg, void *addr, size_t length,\n                                   int prot, const char *path)\n{\n    ucm_get_shm_seg_size_ctx_t *ctx = arg;\n    if (addr == ctx->shmaddr) {\n        ctx->seg_size = length;\n        return 1;\n    }\n    return 0;\n}\n\nsize_t ucm_get_shm_seg_size(const void *shmaddr)\n{\n    ucm_get_shm_seg_size_ctx_t ctx = { shmaddr, 0 };\n    ucm_parse_proc_self_maps(ucm_get_shm_seg_size_cb, &ctx);\n    return ctx.seg_size;\n}\n\nvoid ucm_strerror(int eno, char *buf, size_t max)\n{\n#if STRERROR_R_CHAR_P\n    char *ret = strerror_r(eno, buf, max);\n    if (ret != buf) {\n        strncpy(buf, ret, max);\n    }\n#else\n    (void)strerror_r(eno, buf, max);\n#endif\n}\n\nvoid ucm_prevent_dl_unload()\n{\n    Dl_info info;\n    void *dl;\n    int ret;\n\n    /* Get the path to current library by current function pointer */\n    (void)dlerror();\n    ret = dladdr(ucm_prevent_dl_unload, &info);\n    if (ret == 0) {\n        ucm_warn(\"could not find address of current library: %s\", dlerror());\n        return;\n    }\n\n    /* Load the current library with NODELETE flag, to prevent it from being\n     * unloaded. This will create extra reference to the library, but also add\n     * NODELETE flag to the dynamic link map.\n     */\n    (void)dlerror();\n    dl = dlopen(info.dli_fname, RTLD_LOCAL|RTLD_LAZY|RTLD_NODELETE);\n    if (dl == NULL) {\n        ucm_warn(\"failed to load '%s': %s\", info.dli_fname, dlerror());\n        return;\n    }\n\n    ucm_debug(\"reloaded '%s' at %p with NODELETE flag\", info.dli_fname, dl);\n\n    /* Now we drop our reference to the lib, and it won't be unloaded anymore */\n    dlclose(dl);\n}\n\nchar *ucm_concat_path(char *buffer, size_t max, const char *dir, const char *file)\n{\n    size_t len;\n\n    len = strlen(dir);\n    while (len && (dir[len - 1] == '/')) {\n        len--; /* trim closing '/' */\n    }\n\n    len = ucs_min(len, max);\n    memcpy(buffer, dir, len);\n    max -= len;\n    if (max < 2) { /* buffer is shorter than dir - copy dir only */\n        buffer[len - 1] = '\\0';\n        return buffer;\n    }\n\n    buffer[len] = '/';\n    max--;\n\n    while (file[0] == '/') {\n        file++; /* trim beginning '/' */\n    }\n\n    strncpy(buffer + len + 1, file, max);\n    buffer[max + len] = '\\0'; /* force close string */\n\n    return buffer;\n}\n\nucs_status_t ucm_get_mem_type_current_device_info(ucs_memory_type_t memtype, ucs_sys_bus_id_t *bus_id)\n{\n    ucs_status_t status = UCS_ERR_UNSUPPORTED;\n    ucm_event_installer_t *event_installer;\n\n    ucs_list_for_each(event_installer, &ucm_event_installer_list, list) {\n        if (NULL == event_installer->get_mem_type_current_device_info) {\n            continue;\n        }\n\n        status = event_installer->get_mem_type_current_device_info(bus_id, memtype);\n        if (UCS_OK == status) {\n            break;\n        }\n    }\n\n    return status; \n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/src/ucm/util/reloc.c": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2001-2015.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif\n\n#ifndef NVALGRIND\n#  include <valgrind/memcheck.h>\n#else\n#  define RUNNING_ON_VALGRIND 0\n#endif\n\n#include \"reloc.h\"\n\n#include <ucs/datastruct/khash.h>\n#include <ucs/sys/compiler.h>\n#include <ucs/sys/string.h>\n#include <ucs/sys/sys.h>\n#include <ucm/util/sys.h>\n\n#include <sys/fcntl.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <link.h>\n#include <limits.h>\n\ntypedef void * (*ucm_reloc_dlopen_func_t)(const char *, int);\ntypedef int    (*ucm_reloc_dlclose_func_t)(void *);\n\ntypedef struct ucm_auxv {\n    long               type;\n    long               value;\n} UCS_S_PACKED ucm_auxv_t;\n\n\ntypedef struct ucm_reloc_dl_iter_context {\n    ucm_reloc_patch_t  *patch;\n    ucs_status_t       status;\n    ElfW(Addr)         libucm_base_addr;  /* Base address to store previous value */\n} ucm_reloc_dl_iter_context_t;\n\n\n/* Hash of symbols in a dynamic object */\nKHASH_MAP_INIT_STR(ucm_dl_symbol_hash, void*);\n\n/* Hash of loaded dynamic objects */\ntypedef struct {\n    khash_t(ucm_dl_symbol_hash) symbols;\n} ucm_dl_info_t;\n\nKHASH_MAP_INIT_INT64(ucm_dl_info_hash, ucm_dl_info_t)\n\n/* List of patches to be applied to additional libraries */\nstatic UCS_LIST_HEAD(ucm_reloc_patch_list);\nstatic pthread_mutex_t ucm_reloc_patch_list_lock = PTHREAD_MUTEX_INITIALIZER;\n\nstatic khash_t(ucm_dl_info_hash) ucm_dl_info_hash;\nstatic ucm_reloc_dlopen_func_t  ucm_reloc_orig_dlopen  = NULL;\nstatic ucm_reloc_dlclose_func_t ucm_reloc_orig_dlclose = NULL;\n\n/* forward declaration */\nstatic void ucm_reloc_get_orig_dl_funcs();\n\nstatic uintptr_t\nucm_reloc_get_entry(ElfW(Addr) base, const ElfW(Phdr) *dphdr, ElfW(Sxword) tag)\n{\n    ElfW(Dyn) *entry;\n    for (entry = (void*)(base + dphdr->p_vaddr); entry->d_tag != 0; ++entry) {\n        if (entry->d_tag == tag) {\n            return entry->d_un.d_val;\n        }\n    }\n    return 0;\n}\n\nstatic void ucm_reloc_file_lock(int fd, int l_type)\n{\n    struct flock fl = { l_type, SEEK_SET, 0, 0};\n    int ret;\n\n    ret = fcntl(fd, F_SETLKW, &fl);\n    if (ret < 0) {\n        ucm_warn(\"fcntl(fd=%d, F_SETLKW, l_type=%d) failed: %m\", fd, l_type);\n    }\n}\n\nstatic ucs_status_t ucm_reloc_get_aux_phsize(int *phsize_p)\n{\n#define UCM_RELOC_AUXV_BUF_LEN 16\n    static const char *proc_auxv_filename = \"/proc/self/auxv\";\n    static int phsize = 0;\n    ucm_auxv_t buffer[UCM_RELOC_AUXV_BUF_LEN];\n    ucm_auxv_t *auxv;\n    unsigned count;\n    ssize_t nread;\n    int found;\n    int fd;\n\n    /* Can avoid lock here - worst case we'll read the file more than once */\n    if (phsize != 0) {\n        *phsize_p = phsize;\n        return UCS_OK;\n    }\n\n    fd = open(proc_auxv_filename, O_RDONLY);\n    if (fd < 0) {\n        ucm_error(\"failed to open '%s' for reading: %m\", proc_auxv_filename);\n        return UCS_ERR_IO_ERROR;\n    }\n\n    if (RUNNING_ON_VALGRIND) {\n        /* Work around a bug caused by valgrind's fake /proc/self/auxv -\n         * every time this file is opened when running with valgrind, a\n         * a duplicate of the same fd is returned, so all share the same\n         * file offset.\n         */\n        ucm_reloc_file_lock(fd, F_WRLCK);\n        lseek(fd, 0, SEEK_SET);\n    }\n\n    /* Use small buffer on the stack, avoid using malloc() */\n    found = 0;\n    do {\n        nread = read(fd, buffer, sizeof(buffer));\n        if (nread < 0) {\n            ucm_error(\"failed to read %lu bytes from %s (ret=%ld): %m\",\n                      sizeof(buffer), proc_auxv_filename, nread);\n            break;\n        }\n\n        count = nread / sizeof(buffer[0]);\n        for (auxv = buffer; (auxv < (buffer + count)) && (auxv->type != AT_NULL);\n             ++auxv)\n        {\n            if ((auxv->type == AT_PHENT) && (auxv->value > 0)) {\n                found  = 1;\n                phsize = auxv->value;\n                ucm_debug(\"read phent from %s: %d\", proc_auxv_filename, phsize);\n                if (phsize == 0) {\n                    ucm_error(\"phsize is 0\");\n                }\n                break;\n            }\n        }\n    } while ((count > 0) && !found);\n\n    if (RUNNING_ON_VALGRIND) {\n        ucm_reloc_file_lock(fd, F_UNLCK);\n    }\n    close(fd);\n\n    if (!found) {\n        ucm_error(\"AT_PHENT entry not found in %s\", proc_auxv_filename);\n        return UCS_ERR_NO_ELEM;\n    }\n\n    *phsize_p = phsize;\n    return UCS_OK;\n}\n\nElfW(Rela) *ucm_reloc_find_sym(void *table, size_t table_size, const char *symbol,\n                               void *strtab, ElfW(Sym) *symtab)\n{\n    ElfW(Rela) *reloc;\n    char *elf_sym;\n\n    for (reloc = table;\n         (void*)reloc < UCS_PTR_BYTE_OFFSET(table, table_size);\n         ++reloc) {\n        elf_sym = (char*)strtab + symtab[ELF64_R_SYM(reloc->r_info)].st_name;\n        if (!strcmp(symbol, elf_sym)) {\n            return reloc;\n        }\n    }\n    return NULL;\n}\n\nstatic ucs_status_t\nucm_reloc_dl_apply_patch(const ucm_dl_info_t *dl_info, const char *dl_basename,\n                         int store_prev, ucm_reloc_patch_t *patch)\n{\n    void *prev_value;\n    khiter_t khiter;\n    long page_size;\n    void **entry;\n    void *page;\n    int ret;\n\n    /* find symbol in our hash table */\n    khiter = kh_get(ucm_dl_symbol_hash, &dl_info->symbols, patch->symbol);\n    if (khiter == kh_end(&dl_info->symbols)) {\n        ucm_trace(\"symbol '%s' not found in %s\", patch->symbol, dl_basename);\n        return UCS_OK;\n    }\n\n    /* get entry address from hash table */\n    entry      = kh_val(&dl_info->symbols, khiter);\n    prev_value = *entry;\n\n    if (prev_value == patch->value) {\n        ucm_trace(\"symbol '%s' in %s at [%p] up-to-date\", patch->symbol,\n                  dl_basename, entry);\n        return UCS_OK;\n    }\n\n    /* enable writing to the page */\n    page_size = ucm_get_page_size();\n    page      = ucs_align_down_pow2_ptr(entry, page_size);\n    ret       = mprotect(page, page_size, PROT_READ|PROT_WRITE);\n    if (ret < 0) {\n        ucm_error(\"failed to modify %s page %p to rw: %m\", dl_basename, page);\n        return UCS_ERR_UNSUPPORTED;\n    }\n\n    /* modify the relocation to the new value */\n    *entry = patch->value;\n    ucm_debug(\"symbol '%s' in %s at [%p] modified from %p to %p\",\n              patch->symbol, dl_basename, entry, prev_value, patch->value);\n\n    /* store default entry to prev_value to guarantee valid pointers\n     * throughout life time of the process */\n    if (store_prev) {\n        patch->prev_value = prev_value;\n        ucm_debug(\"'%s' prev_value is %p\", patch->symbol, prev_value);\n    }\n\n    return UCS_OK;\n}\n\nstatic unsigned\nucm_dl_populate_symbols(ucm_dl_info_t *dl_info, uintptr_t dlpi_addr, void *table,\n                        size_t table_size, void *strtab, ElfW(Sym) *symtab,\n                        const char *dl_name)\n{\n    ElfW(Rela) *reloc;\n    khiter_t khiter;\n    unsigned count;\n    char *elf_sym;\n    int ret;\n\n    count = 0;\n    for (reloc = table; (void*)reloc < UCS_PTR_BYTE_OFFSET(table, table_size);\n         ++reloc) {\n        elf_sym = (char*)strtab + symtab[ELF64_R_SYM(reloc->r_info)].st_name;\n        if (*elf_sym == '\\0') {\n            /* skip empty symbols */\n            continue;\n        }\n\n        khiter = kh_put(ucm_dl_symbol_hash, &dl_info->symbols, elf_sym, &ret);\n        if ((ret == UCS_KH_PUT_BUCKET_EMPTY) ||\n            (ret == UCS_KH_PUT_BUCKET_CLEAR)) {\n            /* do not override previous values */\n            kh_val(&dl_info->symbols, khiter) = (void*)(dlpi_addr +\n                                                        reloc->r_offset);\n            ++count;\n        } else if (ret == UCS_KH_PUT_KEY_PRESENT) {\n            ucm_trace(\"ignoring duplicate symbol '%s' in %s\", elf_sym, dl_name);\n        } else {\n            ucm_debug(\"failed to add symbol '%s' in %s\", elf_sym, dl_name);\n        }\n    }\n\n    return count;\n}\n\nstatic ucs_status_t ucm_reloc_dl_info_get(const struct dl_phdr_info *phdr_info,\n                                          const char *dl_name,\n                                          const ucm_dl_info_t **dl_info_p)\n{\n    uintptr_t dlpi_addr = phdr_info->dlpi_addr;\n    unsigned UCS_V_UNUSED num_symbols;\n    void *jmprel, *rela, *strtab;\n    size_t pltrelsz, relasz;\n    ucm_dl_info_t *dl_info;\n    ucs_status_t status;\n    ElfW(Phdr) *dphdr;\n    ElfW(Sym) *symtab;\n    khiter_t khiter;\n    int i, ret;\n    int phsize;\n\n    status = ucm_reloc_get_aux_phsize(&phsize);\n    if (status != UCS_OK) {\n        return status;\n    }\n\n    khiter = kh_put(ucm_dl_info_hash, &ucm_dl_info_hash, dlpi_addr, &ret);\n    if (ret == UCS_KH_PUT_FAILED) {\n        ucm_error(\"failed to add dl info hash entry\");\n        return UCS_ERR_NO_MEMORY;\n    }\n\n    dl_info = &kh_val(&ucm_dl_info_hash, khiter);\n    if (ret == UCS_KH_PUT_KEY_PRESENT) {\n        /* exists */\n        goto out;\n    }\n\n    kh_init_inplace(ucm_dl_symbol_hash, &dl_info->symbols);\n\n    /* find PT_DYNAMIC */\n    dphdr = NULL;\n    for (i = 0; i < phdr_info->dlpi_phnum; ++i) {\n        dphdr = UCS_PTR_BYTE_OFFSET(phdr_info->dlpi_phdr, phsize * i);\n        if (dphdr->p_type == PT_DYNAMIC) {\n            break;\n        }\n    }\n    if (dphdr == NULL) {\n        /* No dynamic section */\n        ucm_debug(\"%s has no dynamic section - skipping\", dl_name)\n        goto out;\n    }\n\n    /* Get ELF tables pointers */\n    symtab = (void*)ucm_reloc_get_entry(dlpi_addr, dphdr, DT_SYMTAB);\n    strtab = (void*)ucm_reloc_get_entry(dlpi_addr, dphdr, DT_STRTAB);\n    if ((symtab == NULL) || (strtab == NULL)) {\n        /* no DT_SYMTAB or DT_STRTAB sections are defined */\n        ucm_debug(\"%s has no dynamic symbols - skipping\", dl_name)\n        goto out;\n    }\n\n    num_symbols = 0;\n\n    /* populate .got.plt */\n    jmprel = (void*)ucm_reloc_get_entry(dlpi_addr, dphdr, DT_JMPREL);\n    if (jmprel != NULL) {\n        pltrelsz     = ucm_reloc_get_entry(dlpi_addr, dphdr, DT_PLTRELSZ);\n        num_symbols += ucm_dl_populate_symbols(dl_info, dlpi_addr, jmprel,\n                                               pltrelsz, strtab, symtab, dl_name);\n    }\n\n    /* populate .got */\n    rela = (void*)ucm_reloc_get_entry(dlpi_addr, dphdr, DT_RELA);\n    if (rela != NULL) {\n        relasz       = ucm_reloc_get_entry(dlpi_addr, dphdr, DT_RELASZ);\n        num_symbols += ucm_dl_populate_symbols(dl_info, dlpi_addr, rela, relasz,\n                                               strtab, symtab, dl_name);\n    }\n\n    ucm_debug(\"added dl_info %p for %s with %u symbols\", dl_info,\n              ucs_basename(dl_name), num_symbols);\n\nout:\n    *dl_info_p = dl_info;\n    return UCS_OK;\n}\n\nstatic void ucm_reloc_dl_info_cleanup(ElfW(Addr) dlpi_addr, const char *dl_name)\n{\n    ucm_dl_info_t *dl_info;\n    khiter_t khiter;\n\n    khiter = kh_get(ucm_dl_info_hash, &ucm_dl_info_hash, dlpi_addr);\n    if (khiter == kh_end(&ucm_dl_info_hash)) {\n        ucm_debug(\"no dl_info entry for address 0x%lx\", dlpi_addr);\n        return;\n    }\n\n    /* destroy symbols hash table */\n    dl_info = &kh_val(&ucm_dl_info_hash, khiter);\n    kh_destroy_inplace(ucm_dl_symbol_hash, &dl_info->symbols);\n\n    /* delete entry in dl_info hash */\n    kh_del(ucm_dl_info_hash, &ucm_dl_info_hash, khiter);\n\n    ucm_debug(\"removed dl_info %p for %s\", dl_info, ucs_basename(dl_name));\n}\n\nstatic int\nucm_reloc_patch_is_dl_blacklisted(const char *dlpi_name,\n                                  const ucm_reloc_patch_t *patch)\n{\n    unsigned i;\n\n    if (patch->blacklist == NULL) {\n        return 0;\n    }\n\n    for (i = 0; patch->blacklist[i] != NULL; i++) {\n        if (strstr(dlpi_name, patch->blacklist[i])) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\nstatic const char*\nucm_reloc_get_dl_name(const char *dlpi_name, ElfW(Addr) dlpi_addr, char *buf,\n                      size_t max)\n{\n    if (strcmp(dlpi_name, \"\")) {\n        return dlpi_name;\n    } else {\n        snprintf(buf, max, \"(anonymous dl @ 0x%lx)\", dlpi_addr);\n        return buf;\n    }\n}\n\nstatic int ucm_reloc_phdr_iterator(struct dl_phdr_info *phdr_info, size_t size,\n                                   void *data)\n{\n    ucm_reloc_dl_iter_context_t *ctx = data;\n    const ucm_dl_info_t *dl_info;\n    char dl_name_buffer[256];\n    const char *dl_name;\n    int store_prev;\n\n    /* check if shared object is black-listed for this patch */\n    if (ucm_reloc_patch_is_dl_blacklisted(phdr_info->dlpi_name, ctx->patch)) {\n        return 0;\n    }\n\n    dl_name = ucm_reloc_get_dl_name(phdr_info->dlpi_name, phdr_info->dlpi_addr,\n                                    dl_name_buffer, sizeof(dl_name_buffer));\n\n    ctx->status = ucm_reloc_dl_info_get(phdr_info, dl_name, &dl_info);\n    if (ctx->status != UCS_OK) {\n        return -1; /* stop iteration if got a real error */\n    }\n\n    store_prev  = phdr_info->dlpi_addr == ctx->libucm_base_addr;\n    ctx->status = ucm_reloc_dl_apply_patch(dl_info, ucs_basename(dl_name),\n                                           store_prev, ctx->patch);\n    if (ctx->status != UCS_OK) {\n        return -1; /* stop iteration if got a real error */\n    }\n\n    /* Continue iteration and patch all remaining objects. */\n    return 0;\n}\n\n/* called with lock held */\nstatic ucs_status_t ucm_reloc_apply_patch(ucm_reloc_patch_t *patch,\n                                          ElfW(Addr) libucm_base_addr)\n{\n    ucm_reloc_dl_iter_context_t ctx;\n\n    ctx.patch              = patch;\n    ctx.status             = UCS_OK;\n    ctx.libucm_base_addr   = libucm_base_addr;\n\n    /* Avoid locks here because we don't modify ELF data structures.\n     * Worst case the same symbol will be written more than once.\n     */\n    ucm_trace(\"patch symbol '%s'\", patch->symbol);\n    (void)dl_iterate_phdr(ucm_reloc_phdr_iterator, &ctx);\n    return ctx.status;\n}\n\n/* read serinfo from 'module_path', result buffer must be destroyed\n * by free() call */\nstatic Dl_serinfo *ucm_dlopen_load_serinfo(const char *module_path)\n{\n    Dl_serinfo *serinfo = NULL;\n    Dl_serinfo serinfo_size;\n    void *module;\n    int res;\n\n    module = ucm_reloc_orig_dlopen(module_path, RTLD_LAZY);\n    if (module == NULL) { /* requested module can't be loaded */\n        ucm_debug(\"failed to open %s: %s\", module_path, dlerror());\n        return NULL;\n    }\n\n    /* try to get search info from requested module */\n    res = dlinfo(module, RTLD_DI_SERINFOSIZE, &serinfo_size);\n    if (res) {\n        ucm_debug(\"dlinfo(RTLD_DI_SERINFOSIZE) failed\");\n        goto close_module;\n    }\n\n    serinfo = malloc(serinfo_size.dls_size);\n    if (serinfo == NULL) {\n        ucm_error(\"failed to allocate %zu bytes for Dl_serinfo\",\n                  serinfo_size.dls_size);\n        goto close_module;\n    }\n\n    *serinfo = serinfo_size;\n    res      = dlinfo(module, RTLD_DI_SERINFO, serinfo);\n    if (res) {\n        ucm_debug(\"dlinfo(RTLD_DI_SERINFO) failed\");\n        free(serinfo);\n        serinfo = NULL;\n    }\n\nclose_module:\n    ucm_reloc_orig_dlclose(module);\n    return serinfo;\n}\n\nvoid *ucm_dlopen(const char *filename, int flag)\n{\n    void *handle;\n    ucm_reloc_patch_t *patch;\n    Dl_serinfo *serinfo;\n    Dl_info dl_info;\n    int res;\n    int i;\n    char file_path[PATH_MAX];\n    struct stat file_stat;\n\n    ucm_debug(\"open module: %s, flag: %x\", filename, flag);\n\n    ucm_reloc_get_orig_dl_funcs();\n\n    if (!ucm_global_opts.dlopen_process_rpath) {\n        goto fallback_load_lib;\n    }\n\n    if (filename == NULL) {\n        /* return handle to main program */\n        goto fallback_load_lib;\n    }\n\n    /* failed to open module directly, try to use RPATH from from caller\n     * to locate requested module */\n    if (filename[0] == '/') { /* absolute path - fallback to legacy mode */\n        goto fallback_load_lib;\n    }\n\n    /* try to get module info */\n    res = dladdr(__builtin_return_address(0), &dl_info);\n    if (!res) {\n        ucm_debug(\"dladdr failed\");\n        goto fallback_load_lib;\n    }\n\n    serinfo = ucm_dlopen_load_serinfo(dl_info.dli_fname);\n    if (serinfo == NULL) {\n        /* failed to load serinfo, try just dlopen */\n        goto fallback_load_lib;\n    }\n\n    for (i = 0; i < serinfo->dls_cnt; i++) {\n        ucm_concat_path(file_path, sizeof(file_path),\n                        serinfo->dls_serpath[i].dls_name, filename);\n        ucm_debug(\"check for %s\", file_path);\n\n        res = stat(file_path, &file_stat);\n        if (res) {\n            continue;\n        }\n\n        free(serinfo);\n        /* ok, file exists, let's try to load it */\n        handle = ucm_reloc_orig_dlopen(file_path, flag);\n        if (handle == NULL) {\n            return NULL;\n        }\n\n        goto out_apply_patches;\n    }\n\n    free(serinfo);\n    /* ok, we can't lookup module in dirs listed in caller module,\n     * let's fallback to legacy mode */\nfallback_load_lib:\n    handle = ucm_reloc_orig_dlopen(filename, flag);\n    if (handle == NULL) {\n        return NULL;\n    }\n\nout_apply_patches:\n    /*\n     * Every time a new shared object is loaded, we must update its relocations\n     * with our list of patches (including dlopen itself). We have to go over\n     * the entire list of shared objects, since there more objects could be\n     * loaded due to dependencies.\n     */\n\n    ucm_trace(\"dlopen(%s) = %p\", filename, handle);\n\n    pthread_mutex_lock(&ucm_reloc_patch_list_lock);\n    ucs_list_for_each(patch, &ucm_reloc_patch_list, list) {\n        ucm_debug(\"in dlopen(%s), re-applying '%s' to %p\", filename,\n                  patch->symbol, patch->value);\n        ucm_reloc_apply_patch(patch, 0);\n    }\n    pthread_mutex_unlock(&ucm_reloc_patch_list_lock);\n\n    return handle;\n}\n\nstatic int ucm_dlclose(void *handle)\n{\n    struct link_map *lm_entry;\n    char dl_name_buffer[256];\n    const char *dl_name;\n    int ret;\n\n    ucm_trace(\"dlclose(%p)\", handle);\n\n    ret = dlinfo(handle, RTLD_DI_LINKMAP, &lm_entry);\n    if (ret != 0) {\n        ucm_warn(\"dlinfo(handle=%p) failed during dlclose() hook, symbol\"\n                 \"table may become unreliable\", handle);\n    } else {\n        /*\n         * Cleanup the cached information about the library.\n         * NOTE: The library may not actually be unloaded (if its reference\n         * count is > 1). Since we have no safe way to know it, we remove the\n         * cached information anyway, and it may be re-added on the next call to\n         * ucm_reloc_apply_patch().\n         */\n        dl_name = ucm_reloc_get_dl_name(lm_entry->l_name, lm_entry->l_addr,\n                                        dl_name_buffer, sizeof(dl_name_buffer));\n        pthread_mutex_lock(&ucm_reloc_patch_list_lock);\n        ucm_reloc_dl_info_cleanup(lm_entry->l_addr, dl_name);\n        pthread_mutex_unlock(&ucm_reloc_patch_list_lock);\n    }\n\n    ucm_reloc_get_orig_dl_funcs();\n\n    return ucm_reloc_orig_dlclose(handle);\n}\n\nstatic ucm_reloc_patch_t ucm_dlopen_reloc_patches[] = {\n    { .symbol = \"dlopen\",  .value  = ucm_dlopen  },\n    { .symbol = \"dlclose\", .value  = ucm_dlclose }\n};\n\nstatic void ucm_reloc_get_orig_dl_funcs()\n{\n    ucm_reloc_patch_t *patch;\n\n    /* pointer to original dlopen() */\n    if (ucm_reloc_orig_dlopen == NULL) {\n        patch                 = &ucm_dlopen_reloc_patches[0];\n        ucm_reloc_orig_dlopen = (ucm_reloc_dlopen_func_t)\n                                ucm_reloc_get_orig(patch->symbol, patch->value);\n        if (ucm_reloc_orig_dlopen == NULL) {\n            ucm_fatal(\"ucm_reloc_orig_dlopen is NULL\");\n        }\n    }\n\n    /* pointer to original dlclose() */\n    if (ucm_reloc_orig_dlclose == NULL) {\n        patch                  = &ucm_dlopen_reloc_patches[1];\n        ucm_reloc_orig_dlclose = (ucm_reloc_dlclose_func_t)\n                                 ucm_reloc_get_orig(patch->symbol, patch->value);\n        if (ucm_reloc_orig_dlclose == NULL) {\n            ucm_fatal(\"ucm_reloc_orig_dlclose is NULL\");\n        }\n    }\n}\n\n/* called with lock held */\nstatic ucs_status_t ucm_reloc_install_dl_hooks()\n{\n    static int installed = 0;\n    ucs_status_t status;\n    size_t i;\n\n    if (installed) {\n        return UCS_OK;\n    }\n\n    for (i = 0; i < ucs_array_size(ucm_dlopen_reloc_patches); ++i) {\n        status = ucm_reloc_apply_patch(&ucm_dlopen_reloc_patches[i], 0);\n        if (status != UCS_OK) {\n            return status;\n        }\n\n        ucs_list_add_tail(&ucm_reloc_patch_list, &ucm_dlopen_reloc_patches[i].list);\n    }\n\n    installed = 1;\n    return UCS_OK;\n}\n\nucs_status_t ucm_reloc_modify(ucm_reloc_patch_t *patch)\n{\n    ucs_status_t status;\n    Dl_info dl_info;\n    int ret;\n\n    ucm_reloc_get_orig_dl_funcs();\n\n    /* Take default symbol value from the current library */\n    ret = dladdr(ucm_reloc_modify, &dl_info);\n    if (!ret) {\n        ucm_error(\"dladdr() failed to query current library\");\n        return UCS_ERR_UNSUPPORTED;\n    }\n\n    /* Take lock first to handle a possible race where dlopen() is called\n     * from another thread and we may end up not patching it.\n     */\n    pthread_mutex_lock(&ucm_reloc_patch_list_lock);\n\n    status = ucm_reloc_install_dl_hooks();\n    if (status != UCS_OK) {\n        goto out_unlock;\n    }\n\n    status = ucm_reloc_apply_patch(patch, (uintptr_t)dl_info.dli_fbase);\n    if (status != UCS_OK) {\n        goto out_unlock;\n    }\n\n    ucs_list_add_tail(&ucm_reloc_patch_list, &patch->list);\n\nout_unlock:\n    pthread_mutex_unlock(&ucm_reloc_patch_list_lock);\n    return status;\n}\n\nUCS_STATIC_INIT {\n    kh_init_inplace(ucm_dl_info_hash, &ucm_dl_info_hash);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/src/ucm/api/ucm.h": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2001-2015.  ALL RIGHTS RESERVED.\n * Copyright (C) Advanced Micro Devices, Inc. 2019. ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n\n#ifndef UCM_H_\n#define UCM_H_\n\n#include <ucs/sys/compiler_def.h>\n\nBEGIN_C_DECLS\n\n#include <ucs/config/types.h>\n#include <ucs/memory/memory_type.h>\n#include <ucs/type/status.h>\n\n#include <sys/types.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdint.h>\n\n\n/**\n * @brief Memory event types\n */\ntypedef enum ucm_event_type {\n    /* Default initialization value */\n    UCM_EVENT_NONE            = 0,\n    /* Native events */\n    UCM_EVENT_MMAP            = UCS_BIT(0),\n    UCM_EVENT_MUNMAP          = UCS_BIT(1),\n    UCM_EVENT_MREMAP          = UCS_BIT(2),\n    UCM_EVENT_SHMAT           = UCS_BIT(3),\n    UCM_EVENT_SHMDT           = UCS_BIT(4),\n    UCM_EVENT_SBRK            = UCS_BIT(5),\n    UCM_EVENT_MADVISE         = UCS_BIT(6),\n\n    /* Aggregate events */\n    UCM_EVENT_VM_MAPPED       = UCS_BIT(16),\n    UCM_EVENT_VM_UNMAPPED     = UCS_BIT(17),\n\n    /* Non-accessible memory alloc/free events */\n    UCM_EVENT_MEM_TYPE_ALLOC  = UCS_BIT(20),\n    UCM_EVENT_MEM_TYPE_FREE   = UCS_BIT(21),\n\n    /* Add event handler, but don't install new hooks */\n    UCM_EVENT_FLAG_NO_INSTALL = UCS_BIT(24),\n\n    /* When the event handler is added, generate approximated events for\n     * existing memory allocations.\n     * Currently implemented only for @ref UCM_EVENT_MEM_TYPE_ALLOC.\n     */\n    UCM_EVENT_FLAG_EXISTING_ALLOC = UCS_BIT(25)\n\n} ucm_event_type_t;\n\n\n/**\n * @brief MMAP hook modes\n */\ntypedef enum ucm_mmap_hook_mode {\n    UCM_MMAP_HOOK_NONE,\n    UCM_MMAP_HOOK_RELOC,\n    UCM_MMAP_HOOK_BISTRO,\n    UCM_MMAP_HOOK_LAST\n} ucm_mmap_hook_mode_t;\n\n/**\n * @brief Memory event parameters and result.\n */\ntypedef union ucm_event {\n    /*\n     * UCM_EVENT_MMAP\n     * mmap() is called.\n     * callbacks: pre, post\n     */\n    struct {\n        void               *result;\n        void               *address;\n        size_t             size;\n        int                prot;\n        int                flags;\n        int                fd;\n        off_t              offset;\n    } mmap;\n\n    /*\n     * UCM_EVENT_MUNMAP\n     * munmap() is called.\n     */\n    struct {\n        int                result;\n        void               *address;\n        size_t             size;\n    } munmap;\n\n    /*\n     * UCM_EVENT_MREMAP\n     * mremap() is called.\n     */\n    struct {\n        void               *result;\n        void               *address;\n        size_t             old_size;\n        size_t             new_size;\n        int                flags;\n    } mremap;\n\n    /*\n     * UCM_EVENT_SHMAT\n     * shmat() is called.\n     */\n    struct {\n        void               *result;\n        int                shmid;\n        const void         *shmaddr;\n        int                shmflg;\n    } shmat;\n\n    /*\n     * UCM_EVENT_SHMDT\n     * shmdt() is called.\n     */\n    struct {\n        int                result;\n        const void         *shmaddr;\n    } shmdt;\n\n    /*\n     * UCM_EVENT_SBRK\n     * sbrk() is called.\n     */\n    struct {\n        void               *result;\n        intptr_t           increment;\n    } sbrk;\n\n    /*\n     * UCM_EVENT_MADVISE\n     * madvise() is called.\n     */\n    struct {\n        int                result;\n        void               *addr;\n        size_t             length;\n        int                advice;\n    } madvise;\n\n    /*\n     * UCM_EVENT_VM_MAPPED, UCM_EVENT_VM_UNMAPPED\n     *\n     * This is a \"read-only\" event which is called whenever memory is mapped\n     * or unmapped from process address space, in addition to the other events.\n     * It can return only UCM_EVENT_STATUS_NEXT.\n     *\n     * For UCM_EVENT_VM_MAPPED, callbacks are post\n     * For UCM_EVENT_VM_UNMAPPED, callbacks are pre\n     */\n    struct {\n        void               *address;\n        size_t             size;\n    } vm_mapped, vm_unmapped;\n\n    /*\n     * UCM_EVENT_MEM_TYPE_ALLOC, UCM_EVENT_MEM_TYPE_FREE\n     *\n     * Memory type allocation and deallocation event.\n     * If mem_type is @ref UCS_MEMORY_TYPE_LAST, the memory type is unknown, and\n     * further memory type detection is required.\n     */\n    struct {\n        void               *address;\n        size_t             size;\n        ucs_memory_type_t  mem_type;\n    } mem_type;\n\n} ucm_event_t;\n\n\n/**\n * @brief Global UCM configuration.\n *\n * Can be safely modified before using UCM functions.\n */\ntypedef struct ucm_global_config {\n    ucs_log_level_t      log_level;                   /* Logging level */\n    int                  enable_events;               /* Enable memory events */\n    ucm_mmap_hook_mode_t mmap_hook_mode;              /* MMAP hook mode */\n    int                  enable_malloc_hooks;         /* Enable installing malloc hooks */\n    int                  enable_malloc_reloc;         /* Enable installing malloc relocations */\n    int                  enable_cuda_reloc;           /* Enable installing CUDA relocations */\n    int                  enable_dynamic_mmap_thresh;  /* Enable adaptive mmap threshold */\n    size_t               alloc_alignment;             /* Alignment for memory allocations */\n    int                  dlopen_process_rpath;        /* Process RPATH section in dlopen hook */\n} ucm_global_config_t;\n\n\n/* Global UCM configuration */\nextern ucm_global_config_t ucm_global_opts;\n\n\n/**\n * @brief Memory event callback.\n *\n *  This type describes a callback which handles memory events in the current process.\n *\n * @param [in]     event_type  Type of the event being fired. see @ref ucm_event_type_t.\n * @param [inout]  event       Event information. This structure can be updated by\n *                               this callback, as described below.\n * @param [in]     arg         User-defined argument as passed to @ref ucm_set_event_handler.\n *\n *\n *  Events are dispatched in order of callback priority (low to high).\n *\n * The fields of the relevant part of the union are initialized as follows:\n *  - \"result\" - to an invalid erroneous return value (depends on the specific event).\n *  - the rest - to the input parameters of the event.\n *\n *  The callback is allowed to modify the fields, and those modifications will\n * be passed to the next callback. Also, the callback is allowed to modify the\n * result, but **only if it's currently invalid**. A valid result indicates that\n * a previous callback already performed the requested memory operation, so a\n * callback should **refrain from actions with side-effects** in this case.\n *\n *  If the result is still invalid after all callbacks are called, the parameters,\n * possibly modified by the callbacks, will be passed to the original handler.\n *\n *\n * Important Note: The callback must not call any memory allocation routines, or\n *       anything which may trigger or wait for memory allocation, because it\n *       may lead to deadlock or infinite recursion.\n *\n * @todo describe use cases\n *\n */\ntypedef void (*ucm_event_callback_t)(ucm_event_type_t event_type,\n                                     ucm_event_t *event, void *arg);\n\n\n/**\n * @brief Install a handler for memory events.\n *\n * @param [in]  events     Bit-mask of events to handle.\n * @param [in]  priority   Priority value which defines the order in which event\n *                          callbacks are called.\n *                           <  0 - called before the original implementation,\n *                           >= 0 - called after the original implementation.\n * @param [in]  cb         Event-handling callback.\n * @param [in]  arg        User-defined argument for the callback.\n *\n * @note If UCM_EVENT_FLAG_NO_INSTALL flag is passed in @a events argument,\n *       only @cb handler will be registered for @a events. No memory\n *       events/hooks will be installed.\n *\n * @return Status code.\n */\nucs_status_t ucm_set_event_handler(int events, int priority,\n                                   ucm_event_callback_t cb, void *arg);\n\n\n/**\n * @brief Remove a handler for memory events.\n *\n * @param [in]  events     Which events to remove. The handler is removed\n *                          completely when all its events are removed.\n * @param [in]  cb         Event-handling callback.\n * @param [in]  arg        User-defined argument for the callback.\n */\nvoid ucm_unset_event_handler(int events, ucm_event_callback_t cb, void *arg);\n\n\n/**\n * @brief Add memory events to the external events list.\n *\n * When the event is set to be external, it means that user is responsible for\n * handling it. So, setting a handler for external event will not trigger\n * installing of UCM memory hooks (if they were not installed before). In this\n * case the corresponding UCM function needs to be invoked to trigger event\n * handlers.\n * Usage example is when the user disables UCM memory hooks (he may have its\n * own hooks, like Open MPI), but it wants to use some UCM based functionality,\n * e.g. IB registration cache. IB registration cache needs to be notified about\n * UCM_EVENT_VM_UNMAPPED events, therefore it adds specific handler for it.\n * In this case user needs to declare UCM_EVENT_VM_UNMAPPED event as external\n * and explicitly call ucm_vm_munmap() when some memory release operation\n * occurs.\n *\n * @param [in]  events    Bit-mask of events which are supposed to be handled\n *                        externally.\n *\n * @note To take an effect, the event should be set external prior to adding\n *       event handlers for it.\n */\nvoid ucm_set_external_event(int events);\n\n\n/**\n * @brief Remove memory events from the external events list.\n *\n * When the event is removed from the external events list, any subsequent call\n * to ucm_set_event_handler() for that event will trigger installing of UCM\n * memory hooks (if they are enabled and were not installed before).\n *\n * @param [in]  events     Which events to remove from the external events list.\n */\nvoid ucm_unset_external_event(int events);\n\n\n/**\n * @brief Test event handlers\n *\n * This routine checks if event handlers are called when corresponding system API\n * is invoked.\n *\n * @param [in]  events    Bit-mask of events which are supposed to be handled\n *                        externally.\n *\n * @return Status code.\n */\nucs_status_t ucm_test_events(int events);\n\n\n/**\n * @brief Test event external handlers\n *\n * This routine checks if external events, as set by @ref ucm_set_external_event,\n * are actually being reported (by calling APIs such as @ref ucm_vm_munmap).\n *\n * @param [in]  events    Bit-mask of events which are supposed to be handled\n *                        externally.\n *\n * @return Status code.\n */\nucs_status_t ucm_test_external_events(int events);\n\n\n/**\n * @brief Call the original implementation of @ref mmap without triggering events.\n */\nvoid *ucm_orig_mmap(void *addr, size_t length, int prot, int flags, int fd,\n                    off_t offset);\n\n\n/**\n * @brief Call the original implementation of @ref munmap without triggering events.\n */\nint ucm_orig_munmap(void *addr, size_t length);\n\n\n/**\n * @brief Call the original implementation of @ref mremap without triggering events.\n */\nvoid *ucm_orig_mremap(void *old_address, size_t old_size, size_t new_size,\n                      int flags);\n\n\n/**\n * @brief Call the original implementation of @ref shmat without triggering events.\n */\nvoid *ucm_orig_shmat(int shmid, const void *shmaddr, int shmflg);\n\n\n/**\n * @brief Call the original implementation of @ref shmdt without triggering events.\n */\nint ucm_orig_shmdt(const void *shmaddr);\n\n\n/**\n * @brief Call the original implementation of @ref sbrk without triggering events.\n */\nvoid *ucm_orig_sbrk(intptr_t increment);\n\n\n/**\n * @brief Call the original implementation of @ref brk without triggering events.\n */\nint ucm_orig_brk(void *addr);\n\n\n/**\n * @brief Call the original implementation of @ref madvise without triggering events.\n */\nint ucm_orig_madvise(void *addr, size_t length, int advice);\n\n\n/**\n * @brief Call the original implementation of @ref mmap and all handlers\n * associated with it.\n */\nvoid *ucm_mmap(void *addr, size_t length, int prot, int flags, int fd,\n               off_t offset);\n\n\n/**\n * @brief Call the original implementation of @ref munmap and all handlers\n * associated with it.\n */\nint ucm_munmap(void *addr, size_t length);\n\n\n/**\n * @brief Call the handlers registered for aggregated VM_MMAP event.\n */\nvoid ucm_vm_mmap(void *addr, size_t length);\n\n\n/**\n * @brief Call the handlers registered for aggregated VM_MUNMAP event.\n */\nvoid ucm_vm_munmap(void *addr, size_t length);\n\n\n/**\n * @brief Call the original implementation of @ref mremap and all handlers\n * associated with it.\n */\nvoid *ucm_mremap(void *old_address, size_t old_size, size_t new_size, int flags);\n\n\n/**\n * @brief Call the original implementation of @ref shmat and all handlers\n * associated with it.\n */\nvoid *ucm_shmat(int shmid, const void *shmaddr, int shmflg);\n\n\n/**\n * @brief Call the original implementation of @ref shmdt and all handlers\n * associated with it.\n */\nint ucm_shmdt(const void *shmaddr);\n\n\n/**\n * @brief Call the original implementation of @ref sbrk and all handlers\n * associated with it.\n */\nvoid *ucm_sbrk(intptr_t increment);\n\n\n/**\n * @brief Call the original implementation of @ref brk and all handlers\n * associated with it.\n */\nint ucm_brk(void *addr);\n\n\n/**\n * @brief Call the original implementation of @ref madvise and all handlers\n * associated with it.\n */\nint ucm_madvise(void *addr, size_t length, int advice);\n\n\n/**\n * @brief Call the original implementation of @ref dlopen and all handlers\n * associated with it.\n */\nvoid *ucm_dlopen(const char *filename, int flag);\n\n\nEND_C_DECLS\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/src/ucs/config/ucm_opts.c": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2001-2018.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif\n\n#include \"parser.h\"\n\n#include <ucm/api/ucm.h>\n#include <ucm/util/log.h>\n#include <ucm/mmap/mmap.h>\n#include <ucs/sys/compiler.h>\n\n\n#define UCM_CONFIG_PREFIX   \"MEM_\"\n\nstatic const char *ucm_mmap_hook_modes[] = {\n    [UCM_MMAP_HOOK_NONE]   = \"none\",\n    [UCM_MMAP_HOOK_RELOC]  = UCM_MMAP_HOOK_RELOC_STR,\n#if UCM_BISTRO_HOOKS\n    [UCM_MMAP_HOOK_BISTRO] = UCM_MMAP_HOOK_BISTRO_STR,\n#endif\n    [UCM_MMAP_HOOK_LAST]   = NULL\n};\n\nstatic ucs_config_field_t ucm_global_config_table[] = {\n  {\"LOG_LEVEL\", \"warn\",\n   \"Logging level for memory events\", ucs_offsetof(ucm_global_config_t, log_level),\n   UCS_CONFIG_TYPE_ENUM(ucm_log_level_names)},\n\n  {\"ALLOC_ALIGN\", \"16\",\n   \"Minimal alignment of allocated blocks\",\n   ucs_offsetof(ucm_global_config_t, alloc_alignment), UCS_CONFIG_TYPE_MEMUNITS},\n\n  {\"EVENTS\", \"yes\",\n   \"Enable memory events\",\n   ucs_offsetof(ucm_global_config_t, enable_events), UCS_CONFIG_TYPE_BOOL},\n\n  {\"MMAP_HOOK_MODE\", UCM_DEFAULT_HOOK_MODE_STR,\n   \"MMAP hook mode\\n\"\n   \" none   - don't set mmap hooks.\\n\"\n   \" reloc  - use ELF relocation table to set hooks.\\n\"\n#if UCM_BISTRO_HOOKS\n   \" bistro - use binary instrumentation to set hooks.\\n\"\n#endif\n   ,ucs_offsetof(ucm_global_config_t, mmap_hook_mode), UCS_CONFIG_TYPE_ENUM(ucm_mmap_hook_modes)},\n\n  {\"MALLOC_HOOKS\", \"yes\",\n   \"Enable using glibc malloc hooks\",\n   ucs_offsetof(ucm_global_config_t, enable_malloc_hooks),\n   UCS_CONFIG_TYPE_BOOL},\n\n  {\"MALLOC_RELOC\", \"yes\",\n   \"Enable installing malloc symbols in the relocation table.\\n\"\n   \"This is unsafe and off by default, because sometimes glibc\\n\"\n   \"calls malloc/free without going through the relocation table,\\n\"\n   \"which would use the original implementation and not ours.\",\n   ucs_offsetof(ucm_global_config_t, enable_malloc_reloc), UCS_CONFIG_TYPE_BOOL},\n\n  {\"CUDA_RELOC\", \"yes\",\n   \"Enable installing CUDA symbols in the relocation table\",\n   ucs_offsetof(ucm_global_config_t, enable_cuda_reloc),\n   UCS_CONFIG_TYPE_BOOL},\n\n  {\"DYNAMIC_MMAP_THRESH\", \"yes\",\n   \"Enable dynamic mmap threshold: for every released block, the\\n\"\n   \"mmap threshold is adjusted upward to the size of the size of\\n\"\n   \"the block, and trim threshold is adjust to twice the size of\\n\"\n   \"the dynamic mmap threshold.\\n\"\n   \"Note: dynamic mmap threshold is disabled when running on valgrind.\",\n   ucs_offsetof(ucm_global_config_t, enable_dynamic_mmap_thresh),\n   UCS_CONFIG_TYPE_BOOL},\n\n  {\"DLOPEN_PROCESS_RPATH\", \"yes\",\n   \"Process RPATH section of caller module during dynamic libraries opening.\",\n   ucs_offsetof(ucm_global_config_t, dlopen_process_rpath),\n   UCS_CONFIG_TYPE_BOOL},\n\n  {NULL}\n};\n\nUCS_CONFIG_REGISTER_TABLE(ucm_global_config_table, \"UCM\", UCM_CONFIG_PREFIX,\n                          ucm_global_config_t)\n\nUCS_STATIC_INIT {\n    (void)ucs_config_parser_fill_opts(&ucm_global_opts, ucm_global_config_table,\n                                      UCS_DEFAULT_ENV_PREFIX, UCM_CONFIG_PREFIX, 0);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/src/ucs/sys/module.c": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2001-2019.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif\n\n#ifndef _GNU_SOURCE\n#  define _GNU_SOURCE /* for dladdr(3) */\n#endif\n\n#include \"module.h\"\n\n#include <ucs/sys/preprocessor.h>\n#include <ucs/debug/memtrack.h>\n#include <ucs/debug/assert.h>\n#include <ucs/debug/log.h>\n#include <ucs/sys/string.h>\n#include <ucs/sys/math.h>\n#include <string.h>\n#include <limits.h>\n#include <dlfcn.h>\n#include <link.h>\n#include <libgen.h>\n\n\n#define UCS_MODULE_PATH_MEMTRACK_NAME   \"module_path\"\n#define UCS_MODULE_SRCH_PATH_MAX        2\n\n#define ucs_module_debug(_fmt, ...) \\\n    ucs_log(ucs_min(UCS_LOG_LEVEL_DEBUG, ucs_global_opts.module_log_level), \\\n            _fmt, ##  __VA_ARGS__)\n#define ucs_module_trace(_fmt, ...) \\\n    ucs_log(ucs_min(UCS_LOG_LEVEL_TRACE, ucs_global_opts.module_log_level), \\\n            _fmt, ##  __VA_ARGS__)\n\nstatic struct {\n    ucs_init_once_t  init;\n    char             module_ext[NAME_MAX];\n    unsigned         srchpath_cnt;\n    char             *srch_path[UCS_MODULE_SRCH_PATH_MAX];\n} ucs_module_loader_state = {\n    .init         = UCS_INIT_ONCE_INITIALIZER,\n    .module_ext   = \".so\", /* default extension */\n    .srchpath_cnt = 0,\n    .srch_path    = { NULL, NULL}\n};\n\n/* Should be called with lock held */\nstatic void ucs_module_loader_add_dl_dir()\n{\n    char *dlpath_dup = NULL;\n    size_t max_length;\n    Dl_info dl_info;\n    char *p, *path;\n    int ret;\n\n    (void)dlerror();\n    ret = dladdr((void*)&ucs_module_loader_state, &dl_info);\n    if (ret == 0) {\n        ucs_error(\"dladdr failed: %s\", dlerror());\n        return;\n    }\n\n    ucs_module_debug(\"ucs library path: %s\", dl_info.dli_fname);\n\n    /* copy extension */\n    dlpath_dup = ucs_strdup(dl_info.dli_fname,\n                            UCS_MODULE_PATH_MEMTRACK_NAME);\n    if (dlpath_dup == NULL) {\n        return;\n    }\n\n    p = basename(dlpath_dup);\n    p = strchr(p, '.');\n    if (p != NULL) {\n        strncpy(ucs_module_loader_state.module_ext, p,\n                sizeof(ucs_module_loader_state.module_ext) - 1);\n    }\n    ucs_free(dlpath_dup);\n\n    /* copy directory component */\n    dlpath_dup = ucs_strdup(dl_info.dli_fname,\n                            UCS_MODULE_PATH_MEMTRACK_NAME);\n    if (dlpath_dup == NULL) {\n        return;\n    }\n\n    /* construct module directory path */\n    max_length = strlen(dlpath_dup) +         /* directory */\n                 1 +                          /* '/' */\n                 strlen(UCX_MODULE_SUBDIR) +  /* sub-directory */\n                 1;                           /* '\\0' */\n    path = ucs_malloc(max_length, UCS_MODULE_PATH_MEMTRACK_NAME);\n    if (path == NULL) {\n        goto out;\n    }\n\n    snprintf(path, max_length, \"%s/%s\", dirname(dlpath_dup), UCX_MODULE_SUBDIR);\n    ucs_module_loader_state.srch_path[ucs_module_loader_state.srchpath_cnt++] = path;\n\nout:\n    ucs_free(dlpath_dup);\n}\n\n/* Should be called with lock held */\nstatic void ucs_module_loader_add_install_dir()\n{\n    ucs_module_loader_state.srch_path[ucs_module_loader_state.srchpath_cnt++] =\n                    ucs_global_opts.module_dir;\n}\n\nstatic void ucs_module_loader_init_paths()\n{\n    UCS_INIT_ONCE(&ucs_module_loader_state.init) {\n        ucs_assert(ucs_module_loader_state.srchpath_cnt == 0);\n        ucs_module_loader_add_dl_dir();\n        ucs_module_loader_add_install_dir();\n        ucs_assert(ucs_module_loader_state.srchpath_cnt <= UCS_MODULE_SRCH_PATH_MAX);\n    }\n}\n\n/* Perform shallow search for a symbol */\nstatic void *ucs_module_dlsym_shallow(const char *module_path, void *dl,\n                                      const char *symbol)\n{\n    struct link_map *lm_entry;\n    Dl_info dl_info;\n    void *addr;\n    int ret;\n\n    addr = dlsym(dl, symbol);\n    if (addr == NULL) {\n        return NULL;\n    }\n\n    (void)dlerror();\n    ret = dladdr(addr, &dl_info);\n    if (ret == 0) {\n        ucs_module_debug(\"dladdr(%p) [%s] failed: %s\", addr, symbol, dlerror());\n        return NULL;\n    }\n\n    (void)dlerror();\n    ret = dlinfo(dl, RTLD_DI_LINKMAP, &lm_entry);\n    if (ret) {\n        ucs_module_debug(\"dlinfo(%p) [%s] failed: %s\", dl, module_path, dlerror());\n        return NULL;\n    }\n\n    /* return the symbol only if it was found in the requested library, and not,\n     * for example, in one of its dependencies.\n     */\n    if (lm_entry->l_addr != (uintptr_t)dl_info.dli_fbase) {\n        ucs_module_debug(\"ignoring '%s' (%p) from %s (%p), expected in %s (%lx)\",\n                         symbol, addr, ucs_basename(dl_info.dli_fname),\n                         dl_info.dli_fbase, ucs_basename(module_path),\n                         lm_entry->l_addr);\n        return NULL;\n    }\n\n    return addr;\n}\n\nstatic void ucs_module_init(const char *module_path, void *dl)\n{\n    typedef ucs_status_t (*init_func_t)();\n\n    const char *module_init_name =\n                    UCS_PP_MAKE_STRING(UCS_MODULE_CONSTRUCTOR_NAME);\n    char *fullpath, buffer[PATH_MAX];\n    init_func_t init_func;\n    ucs_status_t status;\n\n    fullpath = realpath(module_path, buffer);\n    ucs_module_trace(\"loaded %s [%p]\", fullpath, dl);\n\n    init_func = (init_func_t)ucs_module_dlsym_shallow(module_path, dl,\n                                                      module_init_name);\n    if (init_func == NULL) {\n        ucs_module_trace(\"not calling constructor '%s' in %s\", module_init_name,\n                         module_path);\n        return;\n    }\n\n    ucs_module_trace(\"calling '%s' in '%s': [%p]\", module_init_name, fullpath,\n                     init_func);\n    status = init_func();\n    if (status != UCS_OK) {\n        ucs_module_debug(\"initializing '%s' failed: %s, unloading\", fullpath,\n                         ucs_status_string(status));\n        dlclose(dl);\n    }\n}\n\nstatic void ucs_module_load_one(const char *framework, const char *module_name,\n                                unsigned flags)\n{\n    char module_path[PATH_MAX] = {0};\n    const char *error;\n    unsigned i;\n    void *dl;\n    int mode;\n\n    mode = RTLD_LAZY;\n    if (flags & UCS_MODULE_LOAD_FLAG_NODELETE) {\n        mode |= RTLD_NODELETE;\n    }\n    if (flags & UCS_MODULE_LOAD_FLAG_GLOBAL) {\n        mode |= RTLD_GLOBAL;\n    } else {\n        mode |= RTLD_LOCAL;\n    }\n\n    for (i = 0; i < ucs_module_loader_state.srchpath_cnt; ++i) {\n        snprintf(module_path, sizeof(module_path) - 1, \"%s/lib%s_%s%s\",\n                 ucs_module_loader_state.srch_path[i], framework, module_name,\n                 ucs_module_loader_state.module_ext);\n\n        /* Clear error state */\n        (void)dlerror();\n        dl = dlopen(module_path, mode);\n        if (dl != NULL) {\n            ucs_module_init(module_path, dl);\n            break;\n        } else {\n            /* If a module fails to load, silently give up */\n            error = dlerror();\n            ucs_module_debug(\"dlopen('%s', mode=0x%x) failed: %s\", module_path,\n                             mode, error ? error : \"Unknown error\");\n        }\n    }\n\n    /* coverity[leaked_storage] : a loaded module is never unloaded */\n}\n\nvoid ucs_load_modules(const char *framework, const char *modules,\n                      ucs_init_once_t *init_once, unsigned flags)\n{\n    char *modules_str;\n    char *saveptr;\n    char *module_name;\n\n    ucs_module_loader_init_paths();\n\n    UCS_INIT_ONCE(init_once) {\n        ucs_module_debug(\"loading modules for %s\", framework);\n        modules_str = ucs_strdup(modules, \"modules_list\");\n        if (modules_str != NULL) {\n            saveptr     = NULL;\n            module_name = strtok_r(modules_str, \":\", &saveptr);\n            while (module_name != NULL) {\n                ucs_module_load_one(framework, module_name, flags);\n                module_name = strtok_r(NULL, \":\", &saveptr);\n            }\n            ucs_free(modules_str);\n        } else {\n            ucs_error(\"failed to allocate module names list\");\n        }\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/src/ucs/sys/module.h": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2001-2019.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n\n#ifndef UCS_MODULE_H_\n#define UCS_MODULE_H_\n\n#include <ucs/type/init_once.h>\n#include <ucs/sys/compiler_def.h>\n\n\n/**\n * Flags for @ref UCS_MODULE_FRAMEWORK_LOAD\n */\ntypedef enum {\n    UCS_MODULE_LOAD_FLAG_NODELETE = UCS_BIT(0), /**< Never unload */\n    UCS_MODULE_LOAD_FLAG_GLOBAL   = UCS_BIT(1)  /**< Load to global scope */\n} ucs_module_load_flags_t;\n\n\n/**\n * Declare a \"framework\", which is a context for a specific collection of\n * loadable modules. Usually the modules in a particular framework provide\n * alternative implementations of the same internal interface.\n *\n * @param [in] _name  Framework name (as a token)\n */\n#define UCS_MODULE_FRAMEWORK_DECLARE(_name) \\\n    static ucs_init_once_t ucs_framework_init_once_##_name = \\\n        UCS_INIT_ONCE_INITIALIZER\n\n\n/**\n * Load all modules in a particular framework.\n *\n * @param [in]  _name   Framework name, same as passed to\n *                      @ref UCS_MODULE_FRAMEWORK_DECLARE\n * @param [in]  _flags  Modules load flags, see @ref ucs_module_load_flags_t\n *\n * The modules in the framework are loaded by dlopen(). The shared library name\n * of a module is: \"lib<framework>_<module>.so.<version>\", where:\n * - <framework> is the framework name\n * - <module> is the module name. The list of all modules in a framework is\n *   defined by the preprocessor macro <framework>_MODULES in the auto-generated\n *   config.h file, for example: #define foo_MODULES \":bar1:bar2\".\n * - <version> is the shared library version of the module, as generated by\n *   libtool. It's extracted from the full path of the current library (libucs).\n *\n * Module shared libraries are searched in the following locations (in order of\n * priority):\n *  1. 'ucx' sub-directory inside the directory of the current shared library (libucs)\n *  2. ${libdir}/ucx, where ${libdir} is the directory where libraries are installed\n * Note that if libucs is loaded from its installation path, (1) and (2) are the\n * same location. Only if libucs is moved or ran from build directory, the paths\n * will be different, in which case we prefer the 'local' library rather than the\n * 'installed' one.\n *\n * @param [in] _name  Framework name (as a token)\n */\n#define UCS_MODULE_FRAMEWORK_LOAD(_name, _flags) \\\n    ucs_load_modules(#_name, _name##_MODULES, &ucs_framework_init_once_##_name, \\\n                     _flags)\n\n\n/**\n * Define a function to be called when a module is loaded.\n * Some things can't be done in shared library constructor, and need to be done\n * only after dlopen() completes. For example, loading another shared library\n * which uses symbols from the current module.\n *\n * Usage:\n *    UCS_MODULE_INIT() { ... code ... }\n */\n#define UCS_MODULE_INIT() \\\n    ucs_status_t __attribute__((visibility(\"protected\"))) \\\n    UCS_MODULE_CONSTRUCTOR_NAME(void)\n\n\n/**\n * Define the name of a loadable module global constructor\n */\n#define UCS_MODULE_CONSTRUCTOR_NAME \\\n    ucs_module_global_init\n\n\n/**\n * Internal function. Please use @ref UCS_MODULE_FRAMEWORK_LOAD macro instead.\n */\nvoid ucs_load_modules(const char *framework, const char *modules,\n                      ucs_init_once_t *init_once, unsigned flags);\n\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/test/mpi/test_memhooks.c": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2001-2015.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n#define _GNU_SOURCE /* For basename */\n#include <mpi.h>\n\n#include <ucs/sys/preprocessor.h>\n#include <ucm/api/ucm.h>\n#include <sys/mman.h>\n#include <sys/shm.h>\n#include <malloc.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define CHKERR_JUMP(cond, msg, label) \\\n    do { \\\n        if (cond) { \\\n            printf(\"%s:%d: %s\\n\", basename(__FILE__), __LINE__, msg); \\\n            goto label; \\\n        } \\\n    } while (0)\n\n#define DL_FIND_FUNC(dl, func_name, func, err_action) \\\n    do { \\\n        char *error; \\\n        dlerror(); /* clear existing errors */ \\\n        func = dlsym(dl, func_name); \\\n        if (((error = dlerror()) != NULL) || (func == NULL)) { \\\n            error = error ? error : \"not found\"; \\\n            fprintf(stderr, \"Failed to resolve symbol '%s': %s\\n\", \\\n                    func_name, error); \\\n            err_action; \\\n        } \\\n    } while (0);\n\n#define SHMAT_FAILED ((void*)-1)\n\nvoid* open_dyn_lib(const char *lib_path);\nvoid* flag_no_install_init(const char *path);\nint malloc_hooks_run_all(void *dl);\nint malloc_hooks_run_unmapped(void *dl);\nint ext_event_run(void *dl);\nvoid *ext_event_init(const char *path);\n\ntypedef struct memtest_type {\n    const char *name;\n    void*      (*init)(const char *path);\n    int        (*run) (void *arg);\n} memtest_type_t;\n\nmemtest_type_t tests[] = {\n    {\"malloc_hooks\",          open_dyn_lib,         malloc_hooks_run_all},\n    {\"malloc_hooks_unmapped\", open_dyn_lib,         malloc_hooks_run_unmapped},\n    {\"external_events\",       ext_event_init,       ext_event_run},\n    {\"flag_no_install\",       flag_no_install_init, ext_event_run},\n    {NULL}\n};\n\nstatic volatile size_t total_mapped = 0;\nstatic volatile size_t total_unmapped = 0;\n\nstatic void usage() {\n    printf(\"Usage: test_memhooks [options]\\n\");\n    printf(\"Options are:\\n\");\n    printf(\"  -h         Print this info.\\n\");\n    printf(\"  -t <name>  Test name to execute (malloc_hooks)\\n\");\n    printf(\"                 malloc_hooks          : General UCM test for VM_MAPPED and VM_UNMAPPED\\n\");\n    printf(\"                 malloc_hooks_unmapped : Test VM_UNMAPPED event only\\n\");\n    printf(\"                 external_events       : Test of ucm_set_external_event() API\\n\");\n    printf(\"                 flag_no_install       : Test of UCM_EVENT_FLAG_NO_INSTALL flag\\n\");\n    printf(\"\\n\");\n}\n\nstatic void event_callback(ucm_event_type_t event_type, ucm_event_t *event,\n                           void *arg)\n{\n    if (event_type == UCM_EVENT_VM_MAPPED) {\n        total_mapped += event->vm_mapped.size;\n    } else if (event_type == UCM_EVENT_VM_UNMAPPED) {\n        total_unmapped += event->vm_unmapped.size;\n    }\n}\n\nstatic ucs_status_t set_event_handler(void *dl, int events)\n{\n    ucs_status_t (*set_handler)(int events, int priority,\n                                ucm_event_callback_t cb, void *arg);\n\n    DL_FIND_FUNC(dl, \"ucm_set_event_handler\", set_handler,\n                 return UCS_ERR_UNSUPPORTED);\n\n    return set_handler(events, 0, event_callback, NULL);\n}\n\nstatic ucs_status_t disable_memory_hooks(void *dl)\n{\n    setenv(\"UCX_MEM_MALLOC_HOOKS\", \"n\", 1);\n    setenv(\"UCX_MEM_MMAP_RELOC\",   \"n\", 1);\n    return UCS_OK;\n}\n\nvoid* open_dyn_lib(const char *lib_path)\n{\n    void *dl = dlopen(lib_path, RTLD_LAZY);\n    char *error;\n\n    if (dl == NULL) {\n        error = dlerror();\n        error = error ? error : \"unknown error\";\n        fprintf(stderr, \"Failed to load '%s': %s\\n\", lib_path, error);\n    }\n    return dl;\n}\n\n\nvoid *ext_event_init(const char *path)\n{\n    void (*set_ext_event)(int events);\n    ucs_status_t status;\n    void *dl_ucm;\n\n    dl_ucm = open_dyn_lib(path);\n    if (dl_ucm == NULL) {\n        return NULL;\n    }\n\n    status = disable_memory_hooks(dl_ucm);\n    CHKERR_JUMP(status != UCS_OK, \"Failed to disable memory hooks\", fail);\n\n    DL_FIND_FUNC(dl_ucm, \"ucm_set_external_event\", set_ext_event, goto fail);\n    set_ext_event(UCM_EVENT_VM_MAPPED | UCM_EVENT_VM_UNMAPPED);\n\n    status = set_event_handler(dl_ucm, UCM_EVENT_VM_MAPPED |\n                                       UCM_EVENT_VM_UNMAPPED);\n    CHKERR_JUMP(status != UCS_OK, \"Failed to set event handler\", fail);\n\n    return dl_ucm;\n\nfail:\n    dlclose(dl_ucm);\n    return NULL;\n}\n\nvoid* flag_no_install_init(const char *path)\n{\n    void *dl_ucm;\n    ucs_status_t status;\n\n    dl_ucm = open_dyn_lib(path);\n    if (dl_ucm == NULL) {\n        return NULL;\n    }\n\n    status = disable_memory_hooks(dl_ucm);\n    CHKERR_JUMP(status != UCS_OK, \"Failed to disable memory hooks\", fail);\n\n    status = set_event_handler(dl_ucm, UCM_EVENT_VM_MAPPED   |\n                                       UCM_EVENT_VM_UNMAPPED |\n                                       UCM_EVENT_FLAG_NO_INSTALL);\n    CHKERR_JUMP(status != UCS_OK, \"Failed to set event handler\", fail);\n    return dl_ucm;\n\nfail:\n    dlclose(dl_ucm);\n    return NULL;\n}\n\nint malloc_hooks_run_flags(void *dl, ucm_event_type_t events)\n{\n    ucs_status_t status;\n    void *ptr_malloc_core = NULL;\n    void *ptr_malloc_mmap = NULL;\n    void *ptr_direct_mmap = MAP_FAILED;\n    int  shmid            = -1;\n    void *ptr_shmat       = SHMAT_FAILED;\n    void *dl_test;\n    const size_t size = 1024 * 1024;\n    const char *lib_path = UCS_PP_MAKE_STRING(TEST_LIB_DIR) \"/\" \"libtest_memhooks.so\";\n    const char *cust_mmap_name  = \"memhook_test_lib_call_mmap\";\n    void * (*cust_mmap)(size_t size);\n\n    status = set_event_handler(dl, events);\n    CHKERR_JUMP(status != UCS_OK, \"Failed to set event handler\", fail_close_ucm);\n\n    printf(\"Allocating memory\\n\");\n\n    /* Create SysV segment */\n    shmid = shmget(IPC_PRIVATE, size, IPC_CREAT|SHM_R|SHM_W);\n    CHKERR_JUMP(shmid == -1, \"Failed to create shared memory segment: %m\",\n                fail_close_ucm);\n\n    /*\n     * Test shmat/shmdt before malloc() because shmat() add entires to an internal\n     * hash of pointers->size, which makes previous pointers un-releasable\n     */\n\n    /* Attach SysV segment */\n    total_mapped = 0;\n    ptr_shmat = shmat(shmid, NULL, 0);\n    CHKERR_JUMP(ptr_shmat == SHMAT_FAILED, \"Failed to attach shared memory segment\",\n                fail_close_ucm);\n    if (events & UCM_EVENT_VM_MAPPED) {\n        CHKERR_JUMP(total_mapped < size, \"No callback for shmat\", fail_close_ucm);\n    }\n    printf(\"After shmat: reported mapped=%zu\\n\", total_mapped);\n\n    /* Detach SysV segment */\n    total_unmapped = 0;\n    shmdt(ptr_shmat);\n    ptr_shmat = SHMAT_FAILED;\n    if (events & UCM_EVENT_VM_UNMAPPED) {\n        CHKERR_JUMP(total_unmapped < size, \"No callback for shmdt\", fail_close_ucm);\n    }\n    printf(\"After shmdt: reported unmapped=%zu\\n\", total_unmapped);\n\n    /* Attach SysV segment at fixed address */\n    total_mapped = 0;\n    total_unmapped = 0;\n    ptr_shmat = shmat(shmid, (void*)0xff000000, SHM_REMAP);\n    CHKERR_JUMP(ptr_shmat == SHMAT_FAILED, \"Failed to attach shared memory segment\",\n                fail_close_ucm);\n    if (events & UCM_EVENT_VM_MAPPED) {\n        CHKERR_JUMP(total_mapped < size, \"No map callback for shmat(REMAP)\", fail_close_ucm);\n    }\n    if (events & UCM_EVENT_VM_UNMAPPED) {\n        CHKERR_JUMP(total_unmapped < size, \"No unmap callback for shmat(REMAP)\",\n                    fail_close_ucm);\n    }\n    printf(\"After shmat(REMAP): reported mapped=%zu unmapped=%zu\\n\", total_mapped,\n           total_unmapped);\n\n    /* Detach SysV segment */\n    total_unmapped = 0;\n    shmdt(ptr_shmat);\n    ptr_shmat = SHMAT_FAILED;\n    if (events & UCM_EVENT_VM_UNMAPPED) {\n        CHKERR_JUMP(total_unmapped < size, \"No callback for shmdt\", fail_close_ucm);\n    }\n    printf(\"After shmdt: reported unmapped=%zu\\n\", total_unmapped);\n\n    /* Destroy SysV segment */\n    shmctl(shmid, IPC_RMID, NULL);\n    shmid = -1;\n\n    /* Allocate using morecore */\n    mallopt(M_MMAP_THRESHOLD, size * 2);\n    mallopt(M_TRIM_THRESHOLD, size / 2);\n    total_mapped = 0;\n    ptr_malloc_core = malloc(1024 * 1024);\n    if (events & UCM_EVENT_VM_MAPPED) {\n        CHKERR_JUMP(total_mapped == 0, \"No callback for core malloc\",\n                    fail_close_ucm);\n    }\n    printf(\"After core malloc: reported mapped=%zu\\n\", total_mapped);\n\n    /* Allocate using mmap */\n    mallopt(M_MMAP_THRESHOLD, size / 2);\n    total_mapped = 0;\n    ptr_malloc_mmap = malloc(2 * 1024 * 1024);\n    if (events & UCM_EVENT_VM_MAPPED) {\n        CHKERR_JUMP(total_mapped == 0, \"No callback for mmap malloc\",\n                    fail_close_ucm);\n    }\n    printf(\"After mmap malloc: reported mapped=%zu\\n\", total_mapped);\n\n    /* Allocate directly with mmap */\n    total_mapped = 0;\n    ptr_direct_mmap = mmap(NULL, size, PROT_READ|PROT_WRITE,\n                           MAP_PRIVATE|MAP_ANON, -1, 0);\n    if (events & UCM_EVENT_VM_MAPPED) {\n        CHKERR_JUMP(total_mapped < size, \"No callback for mmap\", fail_close_ucm);\n    }\n    printf(\"After mmap: reported mapped=%zu\\n\", total_mapped);\n\n    /* Remap */\n    total_unmapped = 0;\n    ptr_direct_mmap = mmap(ptr_direct_mmap, size, PROT_READ|PROT_WRITE,\n                           MAP_PRIVATE|MAP_ANON|MAP_FIXED, -1, 0);\n    if (events & UCM_EVENT_VM_UNMAPPED) {\n        CHKERR_JUMP(total_unmapped < size, \"No unmap callback for mmap(FIXED)\",\n                    fail_close_ucm);\n    }\n    printf(\"After mmap(FIXED): reported unmapped=%zu\\n\", total_unmapped);\n\n    /* Call munmap directly */\n    total_unmapped = 0;\n    munmap(ptr_direct_mmap, size);\n    if (events & UCM_EVENT_VM_UNMAPPED) {\n        CHKERR_JUMP(total_unmapped == 0, \"No callback for munmap\", fail_close_ucm);\n    }\n    printf(\"After munmap: reported unmapped=%zu\\n\", total_unmapped);\n\n    /* Release indirectly */\n    total_unmapped = 0;\n    free(ptr_malloc_mmap);\n    ptr_malloc_mmap = NULL;\n    malloc_trim(0);\n    if (events & UCM_EVENT_VM_UNMAPPED) {\n        CHKERR_JUMP(total_unmapped == 0, \"No callback for munmap from free\",\n                    fail_close_ucm);\n    }\n    printf(\"After mmap free + trim: reported unmapped=%zu\\n\", total_unmapped);\n\n    /* Call mmap from a library we load after hooks are installed */\n    dl_test = open_dyn_lib(lib_path);\n    CHKERR_JUMP(dl_test == NULL, \"Failed to load test lib\", fail_close_ucm);\n\n    DL_FIND_FUNC(dl_test, cust_mmap_name, cust_mmap, goto fail_close_all);\n    total_mapped = 0;\n    ptr_direct_mmap = cust_mmap(size);\n    CHKERR_JUMP(ptr_direct_mmap == MAP_FAILED, \"Failed to mmap from dynamic lib\",\n                fail_close_all);\n    if (events & UCM_EVENT_VM_MAPPED) {\n        CHKERR_JUMP(total_mapped == 0,\"No callback for mmap from dynamic lib\",\n                    fail_close_all);\n    }\n    printf(\"After another mmap from dynamic lib: reported mapped=%zu\\n\", total_mapped);\n    munmap(ptr_direct_mmap, size);\n    ptr_direct_mmap = MAP_FAILED;\n\n    /*\n     * Test closing UCM.\n     * The library should not really be unloaded, because the memory hooks still\n     * point to functions inside it.\n     */\n    total_unmapped = 0;\n    dlclose(dl);\n    dlclose(dl_test);\n    free(ptr_malloc_core); /* This should still work */\n    ptr_malloc_core = NULL;\n    malloc_trim(0);\n    if (events & UCM_EVENT_VM_UNMAPPED) {\n        CHKERR_JUMP(total_unmapped == 0, \"No callback for munmap from malloc\", fail);\n    }\n    printf(\"After core malloc free: reported unmapped=%zu\\n\", total_unmapped);\n\n    return 0;\n\nfail_close_all:\n    dlclose(dl_test);\nfail_close_ucm:\n    dlclose(dl);\nfail:\n    if (ptr_shmat != SHMAT_FAILED) {\n        shmdt(ptr_shmat);\n    }\n    if (shmid != -1) {\n        shmctl(shmid, IPC_RMID, NULL);\n    }\n    free(ptr_malloc_mmap);\n    free(ptr_malloc_core);\n    if (ptr_direct_mmap != MAP_FAILED) {\n        munmap(ptr_direct_mmap, size);\n    }\n\n    return  -1;\n}\n\nint malloc_hooks_run_all(void *dl)\n{\n    return malloc_hooks_run_flags(dl, UCM_EVENT_VM_MAPPED | UCM_EVENT_VM_UNMAPPED);\n}\n\nint malloc_hooks_run_unmapped(void *dl)\n{\n    return malloc_hooks_run_flags(dl, UCM_EVENT_VM_UNMAPPED);\n}\n\nint ext_event_run(void *dl)\n{\n    void *ptr_direct_mmap;\n    void (*ucm_event)(void *addr, size_t length);\n    const size_t size = 1024 * 1024;\n    int ret = -1;\n\n    /* Allocate directly with mmap */\n    total_mapped = 0;\n    ptr_direct_mmap = mmap(NULL, size, PROT_READ|PROT_WRITE,\n                           MAP_PRIVATE|MAP_ANON, -1, 0);\n    printf(\"totmapped %lu\\n\", total_mapped);\n    /* No callback should be called as we registered events to be external */\n    CHKERR_JUMP(total_mapped != 0,\n                \"Callback for mmap invoked, while hooks were not set\", fail);\n    DL_FIND_FUNC(dl, \"ucm_vm_mmap\", ucm_event, goto fail);\n    ucm_event(ptr_direct_mmap, size);\n    CHKERR_JUMP(total_mapped == 0, \"Callback for mmap is not called\", fail);\n    printf(\"After ucm_vm_mmap called: mapped=%zu\\n\", total_mapped);\n\n    /* Call munmap directly */\n    total_unmapped = 0;\n    munmap(ptr_direct_mmap, size);\n    CHKERR_JUMP(total_unmapped != 0,\n                \"Callback for munmap invoked, while hooks were not set\\n\", fail);\n\n    DL_FIND_FUNC(dl, \"ucm_vm_munmap\", ucm_event, goto fail);\n    ucm_event(ptr_direct_mmap, size);\n    CHKERR_JUMP(total_unmapped == 0, \"Callback for mmap is not called\", fail);\n    printf(\"After ucm_vm_munmap: unmapped=%zu\\n\", total_unmapped);\n\n    ret = 0;\n\nfail:\n    dlclose(dl);\n    return ret;\n}\n\nint main(int argc, char **argv)\n{\n    const char *ucm_path = UCS_PP_MAKE_STRING(UCM_LIB_DIR) \"/\" \"libucm.so\";\n    memtest_type_t *test = tests;\n    void *dl;\n    int ret;\n    int c;\n\n    while ((c = getopt(argc, argv, \"t:h\")) != -1) {\n        switch (c) {\n        case 't':\n            for (test = tests; test->name != NULL; ++test) {\n                if (!strcmp(test->name, optarg)){\n                    break;\n                }\n            }\n            if (test->name == NULL) {\n                fprintf(stderr, \"Wrong test name %s\\n\", optarg);\n                return -1;\n            }\n            break;\n        case 'h':\n        default:\n            usage();\n            return -1;\n        }\n    }\n\n    /* Some tests need to modify UCM config before to call ucp_init,\n     * which may be called by MPI_Init */\n    dl = test->init(ucm_path);\n    if (dl == NULL) {\n        return -1;\n    }\n\n    printf(\"%s: initialized\\n\", test->name);\n\n    MPI_Init(&argc, &argv);\n\n    ret = test->run(dl);\n\n    printf(\"%s: %s\\n\", test->name, ret == 0 ? \"PASS\" : \"FAIL\");\n\n    MPI_Finalize();\n    return ret;\n}\n\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/test/gtest/configure.m4": "#\n# Copyright (C) Mellanox Technologies Ltd. 2001-2019.  ALL RIGHTS RESERVED.\n#\n# See file LICENSE for terms.\n#\n\nAC_LANG_PUSH([C++])\n\nCHECK_COMPILER_FLAG([-fno-tree-vectorize], [-fno-tree-vectorize],\n                    [AC_LANG_SOURCE([[int main(int argc, char** argv){return 0;}]])],\n                    [GTEST_CXXFLAGS=\"$GTEST_CXXFLAGS -fno-tree-vectorize\"],\n                    [])\n\n# error #236: controlling expression is constant\nCHECK_COMPILER_FLAG([--diag_suppress 236], [--diag_suppress 236],\n                    [AC_LANG_SOURCE([[int main(int argc, char** argv){return 0;}]])],\n                    [GTEST_CXXFLAGS=\"$GTEST_CXXFLAGS --diag_suppress 236\"],\n                    [])\n\nAC_LANG_POP([C++])\n\nAC_SUBST([GTEST_CXXFLAGS], [$GTEST_CXXFLAGS])\n\ntest_modules=\"\"\nm4_include([test/gtest/ucm/test_dlopen/configure.m4])\nm4_include([test/gtest/ucm/test_dlopen/rpath-subdir/configure.m4])\nm4_include([test/gtest/ucs/test_module/configure.m4])\nAC_DEFINE_UNQUOTED([test_MODULES], [\"${test_modules}\"], [Test loadable modules])\nAC_CONFIG_FILES([test/gtest/Makefile])\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/test/gtest/Makefile.am": "#\n# Copyright (C) Mellanox Technologies Ltd. 2001-2014.  ALL RIGHTS RESERVED.\n# Copyright (C) UT-Battelle, LLC. 2015. ALL RIGHTS RESERVED.\n# Copyright (C) The University of Tennessee and the University of Tennessee Research Foundation. 2016. ALL RIGHTS RESERVED.\n# Copyright (C) Los Alamos National Security, LLC. 2018 ALL RIGHTS RESERVED.\n# Copyright (C) Advanced Micro Devices, Inc. 2019. ALL RIGHTS RESERVED.\n#\n# See file LICENSE for terms.\n#\n\nif HAVE_GTEST\n\n# Set default configuration for running tests\nUCX_HANDLE_ERRORS        ?= freeze\nUCX_LOG_LEVEL            ?= warn\nUCX_LOG_PRINT_ENABLE     ?= y\nGTEST_FILTER             ?= *\nGTEST_EXTRA_ARGS         ?=\nLAUNCHER                 ?=\nVALGRIND_EXTRA_ARGS      ?=\n\nSUBDIRS = ucs/test_module ucm/test_dlopen\n\nexport UCX_HANDLE_ERRORS\nexport UCX_LOG_LEVEL\nexport UCX_LOG_PRINT_ENABLE\n\nGTEST_ARGS = \\\n\t--gtest_filter=$(GTEST_FILTER) \\\n\t$(GTEST_EXTRA_ARGS)\n\nVALGRIND_ARGS = \\\n\t--tool=memcheck \\\n\t--leak-check=full \\\n\t--track-origins=yes \\\n\t--fair-sched=try \\\n\t--num-callers=25 \\\n\t--error-exitcode=1 \\\n\t--child-silent-after-fork=yes \\\n\t--suppressions=$(top_srcdir)/contrib/valgrind.supp \\\n\t$(VALGRIND_EXTRA_ARGS)\n\nnoinst_PROGRAMS = gtest\n\ngtestdir  = $(includedir)\ngtest_LDADD = \\\n\t$(top_builddir)/src/ucs/libucs.la \\\n\t$(top_builddir)/src/uct/libuct.la \\\n\t$(top_builddir)/src/ucm/libucm.la \\\n\t$(top_builddir)/src/ucp/libucp.la \\\n\t$(top_builddir)/src/tools/perf/lib/libucxperf.la \\\n\t$(OPENMP_CFLAGS) \\\n\t$(GTEST_LIBS)\n\n\ngtest_CPPFLAGS = \\\n\t$(BASE_CPPFLAGS) \\\n\t-I$(top_srcdir)/src \\\n\t-I$(top_srcdir)/test \\\n\t-I$(top_builddir)/src \\\n\t-I$(top_srcdir)/test/gtest \\\n\t$(GTEST_CPPFLAGS) \\\n\t$(OPENMP_CFLAGS)\n\ngtest_LDFLAGS  = $(GTEST_LDFLAGS) -no-install -Wl,-dynamic-list-data\ngtest_CFLAGS   = $(BASE_CFLAGS)\ngtest_CXXFLAGS = \\\n\t$(BASE_CXXFLAGS) $(GTEST_CXXFLAGS) \\\n\t-DGTEST_UCM_HOOK_LIB_DIR=\"\\\"${abs_builddir}/ucm/test_dlopen/.libs\\\"\"\n\ngtest_SOURCES = \\\n\tcommon/gtest-all.cc \\\n\tcommon/main.cc \\\n\tcommon/test_gtest_cmn.cc \\\n\tcommon/mem_buffer.cc \\\n\tcommon/test_helpers.cc \\\n\tcommon/test_obj_size.cc \\\n\tcommon/test_watchdog.cc \\\n\tcommon/test_perf.cc \\\n\tcommon/test.cc \\\n\t\\\n\tucm/malloc_hook.cc \\\n\t\\\n\tuct/test_amo.cc \\\n\tuct/test_amo_add_xor.cc \\\n\tuct/test_amo_and_or.cc \\\n\tuct/test_amo_cswap.cc \\\n\tuct/test_amo_fadd_fxor.cc \\\n\tuct/test_amo_fand_for.cc \\\n\tuct/test_amo_swap.cc \\\n\tuct/test_event.cc \\\n\tuct/test_fence.cc \\\n\tuct/test_flush.cc \\\n\tuct/test_many2one_am.cc \\\n\tuct/test_md.cc \\\n\tuct/test_mm.cc \\\n\tuct/test_mem.cc \\\n\tuct/test_p2p_am.cc \\\n\tuct/test_p2p_err.cc \\\n\tuct/test_p2p_mix.cc \\\n\tuct/test_p2p_rma.cc \\\n\tuct/test_pending.cc \\\n\tuct/test_progress.cc \\\n\tuct/test_uct_ep.cc \\\n\tuct/test_uct_perf.cc \\\n\tuct/test_zcopy_comp.cc \\\n\tuct/uct_p2p_test.cc \\\n\tuct/uct_test.cc \\\n\tuct/test_stats.cc \\\n\tucs/test_event_set.cc \\\n\tucs/test_stats_filter.cc \\\n\tuct/test_peer_failure.cc \\\n\tuct/test_tag.cc \\\n\tuct/tcp/test_tcp.cc \\\n\t\\\n\tucp/test_ucp_am.cc \\\n\tucp/test_ucp_stream.cc \\\n\tucp/test_ucp_peer_failure.cc \\\n\tucp/test_ucp_atomic.cc \\\n\tucp/test_ucp_dt.cc \\\n\tucp/test_ucp_memheap.cc \\\n\tucp/test_ucp_mmap.cc \\\n\tucp/test_ucp_mem_type.cc \\\n\tucp/test_ucp_perf.cc \\\n\tucp/test_ucp_proto.cc \\\n\tucp/test_ucp_rma.cc \\\n\tucp/test_ucp_rma_mt.cc \\\n\tucp/test_ucp_tag_cancel.cc \\\n\tucp/test_ucp_tag_match.cc \\\n\tucp/test_ucp_tag_offload.cc \\\n\tucp/test_ucp_tag_mt.cc \\\n\tucp/test_ucp_tag_perf.cc \\\n\tucp/test_ucp_tag_probe.cc \\\n\tucp/test_ucp_tag_xfer.cc \\\n\tucp/test_ucp_tag_mem_type.cc \\\n\tucp/test_ucp_tag.cc \\\n\tucp/test_ucp_context.cc \\\n\tucp/test_ucp_wireup.cc \\\n\tucp/test_ucp_wakeup.cc \\\n\tucp/test_ucp_fence.cc \\\n\tucp/test_ucp_sockaddr.cc \\\n\tucp/ucp_test.cc \\\n\tucp/ucp_datatype.cc \\\n\t\\\n\tucs/test_algorithm.cc \\\n\tucs/test_arbiter.cc \\\n\tucs/test_async.cc \\\n\tucs/test_callbackq.cc \\\n\tucs/test_class.cc \\\n\tucs/test_config.cc \\\n\tucs/test_datatype.cc \\\n\tucs/test_debug.cc \\\n\tucs/test_memtrack.cc \\\n\tucs/test_math.cc \\\n\tucs/test_mpmc.cc \\\n\tucs/test_mpool.cc \\\n\tucs/test_pgtable.cc \\\n\tucs/test_profile.cc \\\n\tucs/test_rcache.cc \\\n\tucs/test_memtype_cache.cc \\\n\tucs/test_stats.cc \\\n\tucs/test_strided_alloc.cc \\\n\tucs/test_string.cc \\\n\tucs/test_sys.cc \\\n\tucs/test_topo.cc \\\n\tucs/test_sock.cc \\\n\tucs/test_time.cc \\\n\tucs/test_twheel.cc \\\n\tucs/test_frag_list.cc \\\n\tucs/test_type.cc \\\n\tucs/test_log.cc \\\n\tucs/test_iov.cc \\\n\tucs/arch/test_x86_64.cc\n\nif HAVE_IB\ngtest_SOURCES += \\\n\tuct/ib/test_ib.cc \\\n\tuct/ib/test_ib_md.cc \\\n\tuct/ib/test_cq_moderation.cc \\\n\tuct/ib/test_ib_xfer.cc \\\n\tuct/ib/test_ib_pkey.cc \\\n\tuct/ib/test_ib_event.cc\ngtest_CPPFLAGS += \\\n\t$(IBVERBS_CPPFLAGS)\ngtest_LDADD += \\\n\t$(IBVERBS_LDFLAGS) \\\n\t$(top_builddir)/src/uct/ib/libuct_ib.la\nif HAVE_DEVX\ngtest_SOURCES += \\\n\tuct/ib/test_devx.cc\nendif\nif HAVE_TL_UD\ngtest_SOURCES += \\\n\tuct/ib/ud_base.cc \\\n\tuct/ib/test_ud.cc \\\n\tuct/ib/test_ud_timer.cc \\\n\tuct/ib/test_ud_pending.cc \\\n\tuct/ib/test_ud_ds.cc\nendif\nif HAVE_TL_RC\ngtest_SOURCES += \\\n\tuct/ib/test_rc.cc\nendif\t\nif HAVE_TL_DC\ngtest_SOURCES += \\\n\tuct/ib/test_dc.cc\nendif\nif HAVE_RDMACM\ngtest_SOURCES += \\\n\tuct/ib/test_sockaddr.cc\nendif\nendif # HAVE_IB\n\nif HAVE_CUDA\ngtest_SOURCES += \\\n\tucm/cuda_hooks.cc\ngtest_CPPFLAGS += \\\n\t$(CUDA_CPPFLAGS)\ngtest_LDADD += \\\n\t$(CUDA_LDFLAGS) \\\n\t$(top_builddir)/src/uct/cuda/libuct_cuda.la\nendif\n\nif HAVE_HIP\nif HAVE_GNUXX11\ngtest_SOURCES += \\\n\tucm/rocm_hooks.cc\ngtest_CPPFLAGS += \\\n\t$(HIP_CPPFLAGS)\ngtest_CXXFLAGS += \\\n\t$(HIP_CXXFLAGS)\ngtest_LDADD += \\\n\t$(HIP_LDFLAGS) \\\n\t$(HIP_LIBS) \\\n\t$(top_builddir)/src/uct/rocm/libuct_rocm.la\nendif\nendif\n\nnoinst_HEADERS = \\\n\tcommon/gtest.h \\\n\tcommon/mem_buffer.h \\\n\tcommon/test.h \\\n\tcommon/test_helpers.h \\\n\tcommon/test_perf.h \\\n\tcommon/tap.h \\\n\t\\\n\tuct/ib/test_rc.h \\\n\tuct/ib/ud_base.h \\\n\tuct/ib/test_ib.h \\\n\tuct/test_amo.h \\\n\tuct/test_p2p_mix.h \\\n\tuct/test_p2p_rma.h \\\n\tuct/uct_p2p_test.h \\\n\tuct/uct_test.h \\\n\tuct/test_md.h \\\n\t\\\n\tucp/test_ucp_atomic.h \\\n\tucp/test_ucp_memheap.h \\\n\tucp/test_ucp_tag.h \\\n\tucp/ucp_test.h \\\n\tucp/ucp_datatype.h\n\n.PHONY: test test gdb valgrind fix_rpath ucx\n\n\nall-local: gtest\n\nucx:\n\t$(MAKE) -C $(top_builddir)\n\n\nhelp:\n\t@echo\n\t@echo \"Targets:\"\n\t@echo \"  list          : List unit tests.\"\n\t@echo \"  test          : Run unit tests.\"\n\t@echo \"  test_gdb      : Run unit tests with GDB.\"\n\t@echo \"  test_valgrind : Run unit tests with Valgrind.\"\n\t@echo\n\t@echo \"Environment variables:\"\n\t@echo \"  GTEST_FILTER        : Unit tests filter (\\\"$(GTEST_FILTER)\\\")\"\n\t@echo \"  GTEST_EXTRA_ARGS    : Additional arguments for gtest (\\\"$(GTEST_EXTRA_ARGS)\\\")\"\n\t@echo \"  LAUNCHER            : Custom launcher for gtest executable (\\\"$(LAUNCHER)\\\")\"\n\t@echo \"  VALGRIND_EXTRA_ARGS : Additional arguments for Valgrind (\\\"$(VALGRIND_EXTRA_ARGS)\\\")\"\n\t@echo\n\n#\n# List unit tests\n#\nlist: gtest\n\t$(abs_builddir)/gtest --gtest_list_tests $(GTEST_ARGS)\n\n#\n# Run unit tests\n#\ntest: ucx gtest\n\t@rm -f core.*\n\t$(LAUNCHER) stdbuf -e0 -o0 $(abs_builddir)/gtest $(GTEST_ARGS)\n\n#\n# Run unit tests with GDB\n#\ntest_gdb: ucx gtest\n\techo -e 'r\\ninit-if-undefined $$_exitcode=-1\\nif $$_exitcode>=0\\n\\tq\\nend' > .gdbcommands\n\t$(LAUNCHER) env UCX_HANDLE_ERRORS=none \\\n\t\tgdb -x .gdbcommands --args $(GDB_ARGS) \\\n\t\t\t$(abs_builddir)/gtest $(GTEST_ARGS)\n\n#\n# Run unit tests with valgrind\n#\ntest_valgrind: ucx gtest\n\t$(LAUNCHER) env LD_LIBRARY_PATH=\"$(VALGRIND_LIBPATH):${LD_LIBRARY_PATH}\" \\\n\tstdbuf -e0 -o0 valgrind $(VALGRIND_ARGS) $(abs_builddir)/gtest $(GTEST_ARGS)\nendif\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/test/gtest/ucm/malloc_hook.cc": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2001-2018.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#define __STDC_LIMIT_MACROS\n\n#include <ucm/api/ucm.h>\n\n#include <ucs/arch/atomic.h>\n#include <ucs/type/status.h>\n#include <common/test.h>\n#include <common/test_helpers.h>\n#include <pthread.h>\n#include <sstream>\n#include <stdint.h>\n#include <dlfcn.h>\n#include <libgen.h>\n\nextern \"C\" {\n#include <ucs/time/time.h>\n#include <ucm/malloc/malloc_hook.h>\n#include <ucm/bistro/bistro.h>\n#include <ucs/sys/sys.h>\n#include <malloc.h>\n}\n\n#if HAVE_MALLOC_SET_STATE && HAVE_MALLOC_GET_STATE\n#  define HAVE_MALLOC_STATES 1\n#endif /* HAVE_MALLOC_SET_STATE && HAVE_MALLOC_GET_STATE */\n\n#define EXPECT_INCREASED(_value, _prev, _size, _name)  \\\n    {                                                  \\\n        EXPECT_GE(_value, (_prev) + (_size)) << _name; \\\n        _prev = _value;                                \\\n    }\n\n\nclass malloc_hook_test_no_events : public ucs::test {\nprotected:\n    virtual ~malloc_hook_test_no_events()\n    {\n    }\n\n    static void empty_event_callback(ucm_event_type_t event_type,\n                                     ucm_event_t *event, void *arg)\n    {\n    }\n\n    virtual void init()\n    {\n        ucs::test::init();\n        m_enable_events = ucm_global_opts.enable_events;\n        ucm_global_opts.enable_events = 0;\n    }\n\n    virtual void cleanup()\n    {\n        ucm_global_opts.enable_events = m_enable_events;\n        ucs::test::cleanup();\n    }\n\n    int m_enable_events;\n};\n\nUCS_TEST_F(malloc_hook_test_no_events, empty_event) {\n    ucs_status_t status;\n    status = ucm_set_event_handler(0, 0, empty_event_callback, NULL);\n    ASSERT_UCS_OK(status);\n    ucm_unset_event_handler(0, empty_event_callback, NULL);\n}\n\n\ntemplate <class T>\nclass mhook_thread {\npublic:\n    mhook_thread(T *test): m_test(test)\n    {\n        pthread_create(&m_thread, NULL, thread_func, reinterpret_cast<void*>(m_test));\n    }\n\n    ~mhook_thread() {\n        join();\n        delete m_test;\n    }\n\n    void join() {\n        void *retval;\n        pthread_join(m_thread, &retval);\n    }\n\nprotected:\n    T         *m_test;\n    pthread_t m_thread;\n\n    static void *thread_func(void *arg) {\n        T *test = reinterpret_cast<T*>(arg);\n        test->test();\n        return NULL;\n    }\n};\n\ntemplate <class T>\nclass mmap_event {\npublic:\n    mmap_event(T *test): m_test(test), m_events(0), m_external_events(0)\n    {\n    }\n\n    ~mmap_event()\n    {\n        unset();\n        unset_external();\n    }\n\n    ucs_status_t set(int events)\n    {\n        ucs_status_t status;\n\n        status = ucm_set_event_handler(events, 0, mem_event_callback,\n                                       reinterpret_cast<void*>(m_test));\n        ASSERT_UCS_OK(status);\n        m_events |= events;\n        return status;\n    }\n\n    ucs_status_t set_external(int events)\n    {\n        ucm_set_external_event(events);\n        m_external_events |= events;\n        return UCS_OK;\n    }\n\n    void unset()\n    {\n        if (m_events) {\n            ucm_unset_event_handler(m_events, mem_event_callback,\n                                    reinterpret_cast<void*>(m_test));\n            m_events = 0;\n        }\n    }\n\n    void unset_external()\n    {\n        if (m_external_events) {\n            ucm_unset_external_event(m_external_events);\n            m_external_events = 0;\n        }\n    }\n\nprotected:\n    T   *m_test;\n    int m_events;\n    int m_external_events;\n\n    static void mem_event_callback(ucm_event_type_t event_type,\n                                   ucm_event_t *event,\n                                   void *arg)\n    {\n        T *test = reinterpret_cast<T*>(arg);\n        test->mem_event(event_type, event);\n    }\n};\n\n\nclass malloc_hook : public ucs::test {\n    friend class mmap_event<malloc_hook>;\nprotected:\n    /* use template argument to call/not call vm_unmap handler */\n    /* GCC 4.4.7 doesn't allow to define template static function\n     * with integer template argument. using template inner class\n     * to define static function */\n    template <int C> class bistro_hook {\n    public:\n        static int munmap(void *addr, size_t length)\n        {\n            UCM_BISTRO_PROLOGUE;\n            malloc_hook::bistro_call_counter++;\n            if (C) {\n                /* notify aggregate vm_munmap event only */\n                ucm_vm_munmap(addr, length);\n            }\n            int res = (intptr_t)syscall(SYS_munmap, addr, length);\n            UCM_BISTRO_EPILOGUE;\n            return res;\n        }\n\n        static int madvise(void *addr, size_t length, int advise)\n        {\n            UCM_BISTRO_PROLOGUE;\n            malloc_hook::bistro_call_counter++;\n            if (C) {\n                /* notify aggregate vm_munmap event only */\n                ucm_vm_munmap(addr, length);\n            }\n            int res = (intptr_t)syscall(SYS_madvise, addr, length, advise);\n            UCM_BISTRO_EPILOGUE;\n            return res;\n        }\n    };\n\n    class bistro_patch {\n    public:\n        bistro_patch(const char* symbol, void *hook)\n        {\n            ucs_status_t status;\n\n            status = ucm_bistro_patch(symbol, hook, &m_rp);\n            ASSERT_UCS_OK(status);\n            EXPECT_NE((intptr_t)m_rp, 0);\n        }\n\n        ~bistro_patch()\n        {\n            ucm_bistro_restore(m_rp);\n        }\n\n    protected:\n        ucm_bistro_restore_point_t *m_rp;\n    };\n\n    void mem_event(ucm_event_type_t event_type, ucm_event_t *event)\n    {\n        m_got_event = 1;\n    }\n\n    virtual void init() {\n        ucs_status_t status;\n        mmap_event<malloc_hook> event(this);\n\n        ucs::skip_on_address_sanitizer();\n\n        m_got_event = 0;\n        ucm_malloc_state_reset(128 * 1024, 128 * 1024);\n        malloc_trim(0);\n        status = event.set(UCM_EVENT_VM_MAPPED);\n        ASSERT_UCS_OK(status);\n\n        for (;;) {\n            void *ptr = malloc(small_alloc_size);\n            if (m_got_event) {\n                /* If the heap grew, the minimal size is the previous one */\n                free(ptr);\n                break;\n            } else {\n                m_pts.push_back(ptr);\n            }\n        }\n        event.unset();\n    }\n\npublic:\n    static int            small_alloc_count;\n    static const size_t   small_alloc_size = 10000;\n    ucs::ptr_vector<void> m_pts;\n    int                   m_got_event;\n    static volatile int   bistro_call_counter;\n};\n\nstatic bool skip_on_bistro() {\n    return (ucm_global_opts.mmap_hook_mode == UCM_MMAP_HOOK_BISTRO);\n}\n\nstatic bool skip_on_bistro_without_valgrind() {\n    /* BISTRO is disabled under valgrind, we may run tests */\n    return (skip_on_bistro() && !RUNNING_ON_VALGRIND);\n}\n\nint malloc_hook::small_alloc_count            = 1000 / ucs::test_time_multiplier();\nvolatile int malloc_hook::bistro_call_counter = 0;\n\nclass test_thread {\npublic:\n    test_thread(const std::string& name, int num_threads, pthread_barrier_t *barrier,\n                malloc_hook *test, void (test_thread::*test_func)() = &test_thread::test) :\n        m_name(name), m_num_threads(num_threads), m_barrier(barrier),\n        m_map_size(0), m_unmap_size(0), m_test(test), m_event(this)\n    {\n        pthread_mutex_init(&m_stats_lock, NULL);\n    }\n\n    ~test_thread() {\n        pthread_mutex_destroy(&m_stats_lock);\n    }\n\n    void test();\n    void mem_event(ucm_event_type_t event_type, ucm_event_t *event);\n\nprivate:\n    typedef std::pair<void*, void*> range;\n\n    bool is_ptr_in_range(void *ptr, size_t size, const std::vector<range> &ranges) {\n        for (std::vector<range>::const_iterator iter = ranges.begin(); iter != ranges.end(); ++iter) {\n            if ((ptr >= iter->first) && ((char*)ptr < iter->second)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    static pthread_mutex_t   lock;\n    static pthread_barrier_t barrier;\n\n    std::string        m_name;\n    int                m_num_threads;\n    pthread_barrier_t  *m_barrier;\n\n    pthread_mutex_t    m_stats_lock;\n    size_t             m_map_size;\n    size_t             m_unmap_size;\n    std::vector<range> m_map_ranges;\n    std::vector<range> m_unmap_ranges;\n\n    malloc_hook        *m_test;\n    mmap_event<test_thread> m_event;\n};\n\npthread_mutex_t test_thread::lock = PTHREAD_MUTEX_INITIALIZER;\n\nvoid test_thread::mem_event(ucm_event_type_t event_type, ucm_event_t *event)\n{\n    pthread_mutex_lock(&m_stats_lock);\n    switch (event_type) {\n    case UCM_EVENT_VM_MAPPED:\n        m_map_ranges.push_back(range(event->vm_mapped.address,\n                                     (char*)event->vm_mapped.address + event->vm_mapped.size));\n        m_map_size += event->vm_mapped.size;\n        break;\n    case UCM_EVENT_VM_UNMAPPED:\n        m_unmap_ranges.push_back(range(event->vm_unmapped.address,\n                                       (char*)event->vm_unmapped.address + event->vm_unmapped.size));\n        m_unmap_size += event->vm_unmapped.size;\n        break;\n    default:\n        break;\n    }\n    pthread_mutex_unlock(&m_stats_lock);\n}\n\nvoid test_thread::test() {\n    static const size_t large_alloc_size = 40 * 1024 * 1024;\n    ucs_status_t result;\n    ucs::ptr_vector<void> old_ptrs;\n    ucs::ptr_vector<void> new_ptrs;\n    void *ptr_r;\n    size_t small_map_size;\n    const size_t small_alloc_size = malloc_hook::small_alloc_size;\n    int num_ptrs_in_range;\n    static volatile uint32_t total_ptrs_in_range = 0;\n    char *test_str;\n\n    /* Allocate some pointers with old heap manager */\n    for (unsigned i = 0; i < 10; ++i) {\n        old_ptrs.push_back(malloc(small_alloc_size));\n    }\n\n    ptr_r = malloc(small_alloc_size);\n\n    m_map_ranges.reserve  ((m_test->small_alloc_count * 8 + 10) * m_num_threads);\n    m_unmap_ranges.reserve((m_test->small_alloc_count * 8 + 10) * m_num_threads);\n\n    total_ptrs_in_range = 0;\n\n    pthread_barrier_wait(m_barrier);\n\n    /* Install memory hooks */\n    result = m_event.set(UCM_EVENT_VM_MAPPED|UCM_EVENT_VM_UNMAPPED);\n    ASSERT_UCS_OK(result);\n\n    /* Allocate small pointers with new heap manager */\n    for (int i = 0; i < m_test->small_alloc_count; ++i) {\n        new_ptrs.push_back(malloc(small_alloc_size));\n    }\n    small_map_size = m_map_size;\n\n    /* If this test runs more than once, then sbrk may not really allocate new\n     * memory\n     */\n    EXPECT_GT(m_map_size, 0lu) << m_name;\n\n    num_ptrs_in_range = 0;\n    for (ucs::ptr_vector<void>::const_iterator iter = new_ptrs.begin();\n                    iter != new_ptrs.end(); ++iter)\n    {\n        if (is_ptr_in_range(*iter, small_alloc_size, m_map_ranges)) {\n            ++num_ptrs_in_range;\n        }\n    }\n\n    /* Need at least one ptr in the mapped ranges in one the threads */\n    ucs_atomic_add32(&total_ptrs_in_range, num_ptrs_in_range);\n    pthread_barrier_wait(m_barrier);\n\n    EXPECT_GT(total_ptrs_in_range, 0u);\n\n    /* Allocate large chunk */\n    void *ptr = malloc(large_alloc_size);\n    EXPECT_GE(m_map_size, large_alloc_size + small_map_size) << m_name;\n    EXPECT_TRUE(is_ptr_in_range(ptr, large_alloc_size, m_map_ranges)) << m_name;\n    EXPECT_GE(malloc_usable_size(ptr), large_alloc_size);\n\n    free(ptr);\n    EXPECT_GE(m_unmap_size, large_alloc_size) << m_name;\n    /* coverity[pass_freed_arg] */\n    EXPECT_TRUE(is_ptr_in_range(ptr, large_alloc_size, m_unmap_ranges)) << m_name;\n\n    /* Test strdup */\n    void *s = strdup(\"test\");\n    free(s);\n\n    /* Test setenv */\n    pthread_mutex_lock(&lock);\n    setenv(\"TEST\", \"VALUE\", 1);\n    test_str = getenv(\"TEST\");\n    if (test_str != NULL) {\n        EXPECT_EQ(std::string(\"VALUE\"), test_str);\n    } else {\n        UCS_TEST_ABORT(\"getenv(\\\"TEST\\\") returned NULL\");\n    }\n    pthread_mutex_unlock(&lock);\n\n    /* Test username */\n    ucs_get_user_name();\n\n    /* Test usable size */\n    EXPECT_GE(malloc_usable_size(ptr_r), small_alloc_size);\n\n    /* Test realloc */\n    ptr_r = realloc(ptr_r, small_alloc_size / 2);\n    free(ptr_r);\n\n    /* Test C++ allocations */\n    {\n        std::vector<char> vec(large_alloc_size, 0);\n        ptr = &vec[0];\n        EXPECT_TRUE(is_ptr_in_range(ptr, large_alloc_size, m_map_ranges)) << m_name;\n    }\n\n    /* coverity[use_after_free] - we don't dereference ptr, just search it*/\n    EXPECT_TRUE(is_ptr_in_range(ptr, large_alloc_size, m_unmap_ranges)) << m_name;\n\n    /* Release old pointers (should not crash) */\n    old_ptrs.clear();\n\n    m_map_ranges.clear();\n    m_unmap_ranges.clear();\n\n    /* Don't release pointers before other threads exit, so they will map new memory\n     * and not reuse memory from other threads.\n     */\n    pthread_barrier_wait(m_barrier);\n\n    /* This must be done when all other threads are inactive, otherwise we may leak */\n#if HAVE_MALLOC_STATES\n    if (!RUNNING_ON_VALGRIND) {\n        pthread_mutex_lock(&lock);\n        void *state = malloc_get_state();\n        malloc_set_state(state);\n        free(state);\n        pthread_mutex_unlock(&lock);\n    }\n#endif /* HAVE_MALLOC_STATES */\n\n    pthread_barrier_wait(m_barrier);\n\n    /* Release new pointers  */\n    new_ptrs.clear();\n\n    /* Call several malloc routines */\n    malloc_trim(0);\n\n    ptr = malloc(large_alloc_size);\n\n    free(ptr);\n\n    /* shmat/shmdt */\n    size_t shm_seg_size = ucs_get_page_size() * 2;\n    int shmid = shmget(IPC_PRIVATE, shm_seg_size, IPC_CREAT | SHM_R | SHM_W);\n    EXPECT_NE(-1, shmid) << strerror(errno);\n\n    ptr = shmat(shmid, NULL, 0);\n    EXPECT_NE(MAP_FAILED, ptr) << strerror(errno);\n\n    shmdt(ptr);\n    shmctl(shmid, IPC_RMID, NULL);\n\n    EXPECT_TRUE(is_ptr_in_range(ptr, shm_seg_size, m_unmap_ranges));\n\n    ptr = mmap(NULL, shm_seg_size, PROT_READ|PROT_WRITE,\n               MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    ASSERT_NE(MAP_FAILED, ptr) << strerror(errno);\n    madvise(ptr, shm_seg_size, MADV_DONTNEED);\n\n    EXPECT_TRUE(is_ptr_in_range(ptr, shm_seg_size, m_unmap_ranges));\n    munmap(ptr, shm_seg_size);\n\n    /* Print results */\n    pthread_mutex_lock(&lock);\n    UCS_TEST_MESSAGE << m_name\n                     << \": small mapped: \" << small_map_size\n                     <<  \", total mapped: \" << m_map_size\n                     <<  \", total unmapped: \" << m_unmap_size;\n    std::cout.flush();\n    pthread_mutex_unlock(&lock);\n\n    m_event.unset();\n}\n\nUCS_TEST_SKIP_COND_F(malloc_hook, single_thread,\n                     skip_on_bistro_without_valgrind()) {\n    pthread_barrier_t barrier;\n    pthread_barrier_init(&barrier, NULL, 1);\n    {\n        mhook_thread<test_thread>(new test_thread(\"single-thread\", 1, &barrier, this));\n    }\n    pthread_barrier_destroy(&barrier);\n}\n\nUCS_TEST_SKIP_COND_F(malloc_hook, multi_threads,\n                     skip_on_bistro_without_valgrind()) {\n    typedef mhook_thread<test_thread> thread_t;\n\n    static const int num_threads = 8;\n    ucs::ptr_vector<thread_t> threads;\n    pthread_barrier_t barrier;\n\n    malloc_trim(0);\n\n    pthread_barrier_init(&barrier, NULL, num_threads);\n    for (int i = 0; i < num_threads; ++i) {\n        std::stringstream ss;\n        ss << \"thread \" << i << \"/\" << num_threads;\n        threads.push_back(new thread_t(new test_thread(ss.str(), num_threads, &barrier, this)));\n    }\n\n    threads.clear();\n    pthread_barrier_destroy(&barrier);\n}\n\nUCS_TEST_F(malloc_hook, asprintf) {\n    /* Install memory hooks */\n    (void)dlerror();\n}\n\nUCS_TEST_SKIP_COND_F(malloc_hook, fork, \"broken\") {\n    static const int num_processes = 4;\n    pthread_barrier_t barrier;\n    std::vector<pid_t> pids;\n    pid_t pid;\n\n    for (int i = 0; i < num_processes; ++i) {\n        pid = fork();\n        if (pid == 0) {\n            pthread_barrier_init(&barrier, NULL, 1);\n            {\n                std::stringstream ss;\n                ss << \"process \" << i << \"/\" << num_processes;\n                test_thread thread(ss.str(), 1, &barrier, this);\n            }\n            pthread_barrier_destroy(&barrier);\n            throw ucs::exit_exception(HasFailure());\n        }\n        pids.push_back(pid);\n    }\n\n    for (int i = 0; i < num_processes; ++i) {\n        int status;\n        waitpid(pids[i], &status, 0);\n        EXPECT_EQ(0, WEXITSTATUS(status)) << \"Process \" << i << \" failed\";\n    }\n}\n\nclass malloc_hook_cplusplus : public malloc_hook {\npublic:\n\n    malloc_hook_cplusplus() :\n        m_mapped_size(0), m_unmapped_size(0),\n        m_dynamic_mmap_config(ucm_global_opts.enable_dynamic_mmap_thresh),\n        m_event(this) {\n    }\n\n    ~malloc_hook_cplusplus() {\n        ucm_global_opts.enable_dynamic_mmap_thresh = m_dynamic_mmap_config;\n    }\n\n    void set() {\n        ucs_status_t status;\n        status = m_event.set(UCM_EVENT_VM_MAPPED|UCM_EVENT_VM_UNMAPPED);\n        ASSERT_UCS_OK(status);\n    }\n\n    void unset() {\n        m_event.unset();\n    }\n\n    void mem_event(ucm_event_type_t event_type, ucm_event_t *event)\n    {\n        switch (event_type) {\n        case UCM_EVENT_VM_MAPPED:\n            m_mapped_size   += event->vm_mapped.size;\n            break;\n        case UCM_EVENT_VM_UNMAPPED:\n            m_unmapped_size += event->vm_unmapped.size;\n            break;\n        default:\n            break;\n        }\n    }\n\nprotected:\n    double measure_alloc_time(size_t size, unsigned iters)\n    {\n        ucs_time_t start_time = ucs_get_time();\n        for (unsigned i = 0; i < iters; ++i) {\n            void *ptr = malloc(size);\n            /* prevent the compiler from optimizing-out the memory allocation */\n            *(volatile char*)ptr = '5';\n            free(ptr);\n        }\n        return ucs_time_to_sec(ucs_get_time() - start_time);\n    }\n\n    void test_dynamic_mmap_thresh()\n    {\n        const size_t size = 8 * UCS_MBYTE;\n\n        set();\n\n        std::vector<std::string> strs;\n\n        m_mapped_size = 0;\n        while (m_mapped_size < size) {\n            strs.push_back(std::string(size, 't'));\n        }\n\n        m_unmapped_size = 0;\n        strs.clear();\n        EXPECT_GE(m_unmapped_size, size);\n\n        m_mapped_size = 0;\n        while (m_mapped_size < size) {\n            strs.push_back(std::string());\n            strs.back().resize(size);\n        }\n\n        m_unmapped_size = 0;\n        strs.clear();\n        if (ucm_global_opts.enable_dynamic_mmap_thresh) {\n            EXPECT_EQ(0ul, m_unmapped_size);\n        } else {\n            EXPECT_GE(m_unmapped_size, size);\n        }\n\n        unset();\n    }\n\n    size_t m_mapped_size;\n    size_t m_unmapped_size;\n    int    m_dynamic_mmap_config;\n    mmap_event<malloc_hook_cplusplus> m_event;\n};\n\n\nclass mmap_hooks {\npublic:\n    mmap_hooks(const std::string& name, int num_threads, pthread_barrier_t *barrier):\n        m_num_threads(num_threads), m_mapped_size(0), m_unmapped_size(0),\n        m_search_ptr(NULL), m_is_ptr_found(false), m_name(name),\n        m_barrier(barrier), m_event(this)\n    {\n        pthread_spin_init(&m_lock,0);\n    }\n\n    void mem_event(ucm_event_type_t event_type, ucm_event_t *event)\n    {\n        pthread_spin_lock(&m_lock);\n        switch (event_type) {\n        case UCM_EVENT_VM_MAPPED:\n            m_mapped_size += event->vm_mapped.size;\n            break;\n        case UCM_EVENT_VM_UNMAPPED:\n            m_unmapped_size += event->vm_unmapped.size;\n            if (m_search_ptr == event->vm_unmapped.address) {\n                m_is_ptr_found = true;\n            }\n            break;\n        default:\n            break;\n        }\n        pthread_spin_unlock(&m_lock);\n    }\n\n    void test()\n    {\n        /*\n         * Test memory mapping functions which override an existing mapping\n         */\n        size_t size          = ucs_get_page_size() * 800;\n        size_t mapped_size   = 0;\n        size_t unmapped_size = 0;\n        void *buffer;\n        int shmid;\n        ucs_status_t status;\n        int num_threads;\n\n        EXPECT_EQ(0u, m_mapped_size) << m_name;\n        EXPECT_EQ(0u, m_unmapped_size) << m_name;\n\n        status = m_event.set(UCM_EVENT_VM_MAPPED|UCM_EVENT_VM_UNMAPPED);\n        ASSERT_UCS_OK(status);\n\n        pthread_barrier_wait(m_barrier);\n\n        /* 1. Map a large buffer */\n        {\n            buffer = mmap(NULL, size, PROT_READ|PROT_WRITE,\n                                MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n            ASSERT_NE(MAP_FAILED, buffer) << strerror(errno);\n\n            EXPECT_INCREASED(m_mapped_size, mapped_size, size, m_name);\n            EXPECT_INCREASED(m_unmapped_size, unmapped_size, 0, m_name);\n        }\n\n        /*\n         * 2. Map another buffer in the same place.\n         *    Expected behavior: unmap event on the old buffer\n         */\n        {\n            void *remap = mmap(buffer, size, PROT_READ|PROT_WRITE,\n                               MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);\n            ASSERT_EQ(buffer, remap);\n\n            EXPECT_INCREASED(m_mapped_size, mapped_size, size, m_name);\n            EXPECT_INCREASED(m_unmapped_size, unmapped_size, size, m_name);\n        }\n\n        /* 3. Create a shared memory segment */\n        {\n            shmid = shmget(IPC_PRIVATE, size, IPC_CREAT | SHM_R | SHM_W);\n            ASSERT_NE(-1, shmid) << strerror(errno) << m_name;\n        }\n\n        /*\n         * 4. Attach the segment at the same buffer address.\n         *    Expected behavior: unmap event on the old buffer\n         */\n        {\n            m_is_ptr_found = false;\n            m_search_ptr   = buffer;\n\n            /* Make sure every thread will have a unique value of 'buffer' - no\n             * thread will release its buffer before all others already\n             * allocated theirs */\n            pthread_barrier_wait(m_barrier);\n\n            /* adding 0x1 to 'buffer' with SHM_RND flag should still send event\n             * for 'buffer', because it aligns to SHMLBA\n             */\n            void *shmaddr = shmat(shmid, (char*)buffer + 0x1, SHM_REMAP | SHM_RND);\n            ASSERT_EQ(buffer, shmaddr) << m_name;\n\n            if (SHMLBA > 0x1) {\n                EXPECT_TRUE(m_is_ptr_found);\n            }\n            EXPECT_INCREASED(m_mapped_size, mapped_size, size, m_name);\n            EXPECT_INCREASED(m_unmapped_size, unmapped_size, size, m_name);\n        }\n\n        /* 5. Detach the sysv segment */\n        {\n            shmdt(buffer);\n\n            EXPECT_INCREASED(m_unmapped_size, unmapped_size, size, m_name);\n        }\n\n        /* 6. Remove the shared memory segment */\n        {\n            int ret = shmctl(shmid, IPC_RMID, NULL);\n            ASSERT_NE(-1, ret) << strerror(errno);\n        }\n\n        /* 7. Unmap the buffer */\n        {\n            munmap(buffer, size);\n\n            EXPECT_INCREASED(m_unmapped_size, unmapped_size, size, m_name);\n        }\n\n        /* 8. sbrk call - single thread only */\n        if (!RUNNING_ON_VALGRIND && (m_num_threads < 2)) {\n            num_threads = 0;\n            ucs_sys_enum_threads(enum_threads_cb, &num_threads);\n            // use sbrk() only if there are 3 threads in the system:\n            //   1. main thread\n            //   2. watchdog thread\n            //   3. test thread\n            // otherwise, another thread can call use malloc/free in same time,\n            // leading to heap corruption\n\n            if (num_threads <= 3) {\n                /* valgrind failed when sbrk is called directly,\n                 * also sbrk is not thread safe */\n\n                /* sbrk call is used to extend/cut memory heap,\n                 * don't add any evaluations between calls sbrk+/sbrk- - it\n                 * may break heap */\n                sbrk(size);\n                sbrk(-size);\n\n                EXPECT_INCREASED(m_mapped_size, mapped_size, size, m_name);\n                EXPECT_INCREASED(m_unmapped_size, unmapped_size, size, m_name);\n            }\n        }\n        pthread_barrier_wait(m_barrier);\n    }\n\nprotected:\n    int                     m_num_threads;\n    size_t                  m_mapped_size;\n    size_t                  m_unmapped_size;\n    void                    *m_search_ptr;\n    bool                    m_is_ptr_found;\n    pthread_spinlock_t      m_lock;\n    std::string             m_name;\n    pthread_barrier_t       *m_barrier;\n    mmap_event<mmap_hooks>  m_event;\n\n    static ucs_status_t enum_threads_cb(pid_t tid, void *ctx)\n    {\n        (*(int*)ctx)++;\n        return UCS_OK;\n    }\n};\n\n\nUCS_TEST_F(malloc_hook_cplusplus, new_delete) {\n    const size_t size = 8 * 1000 * 1000;\n\n    set();\n\n    {\n        std::vector<char> vec1(size, 0);\n        std::vector<char> vec2(size, 0);\n        std::vector<char> vec3(size, 0);\n    }\n\n    {\n        std::vector<char> vec1(size, 0);\n        std::vector<char> vec2(size, 0);\n        std::vector<char> vec3(size, 0);\n    }\n\n    malloc_trim(0);\n\n    EXPECT_GE(m_unmapped_size, size);\n\n    unset();\n}\n\nUCS_TEST_SKIP_COND_F(malloc_hook_cplusplus, dynamic_mmap_enable,\n                     RUNNING_ON_VALGRIND || skip_on_bistro()) {\n    EXPECT_TRUE(ucm_global_opts.enable_dynamic_mmap_thresh);\n    test_dynamic_mmap_thresh();\n}\n\nUCS_TEST_SKIP_COND_F(malloc_hook_cplusplus, dynamic_mmap_disable,\n                     skip_on_bistro_without_valgrind()) {\n    ucm_global_opts.enable_dynamic_mmap_thresh = 0;\n\n    test_dynamic_mmap_thresh();\n}\n\nextern \"C\" {\n    int ucm_dlmallopt_get(int);\n};\n\nUCS_TEST_SKIP_COND_F(malloc_hook_cplusplus, mallopt,\n                     skip_on_bistro_without_valgrind()) {\n\n    int v;\n    int trim_thresh, mmap_thresh;\n    char *p;\n    size_t size;\n\n    /* This test can not be run with the other\n     * tests because it assumes that malloc hooks\n     * are not initialized\n     */\n    p = getenv(\"MALLOC_TRIM_THRESHOLD_\");\n    if (p == NULL) {\n        UCS_TEST_SKIP_R(\"MALLOC_TRIM_THRESHOLD_ is not set\");\n    }\n    trim_thresh = atoi(p);\n\n    p = getenv(\"MALLOC_MMAP_THRESHOLD_\");\n    if (p == NULL) {\n        UCS_TEST_SKIP_R(\"MALLOC_MMAP_THRESHOLD_ is not set\");\n    }\n    mmap_thresh = atoi(p);\n\n    /* make sure that rcache is explicitly disabled so\n     * that the malloc hooks are installed after the setenv()\n     */\n    p = getenv(\"UCX_IB_RCACHE\");\n    if ((p == NULL) || (p[0] != 'n')) {\n        UCS_TEST_SKIP_R(\"rcache must be disabled\");\n    }\n\n    set();\n\n    v = ucm_dlmallopt_get(M_TRIM_THRESHOLD);\n    EXPECT_EQ(trim_thresh, v);\n\n    v = ucm_dlmallopt_get(M_MMAP_THRESHOLD);\n    EXPECT_EQ(mmap_thresh, v);\n\n    /* give a lot of extra space since the same block\n     * can be also used by other allocations\n     */\n    if (trim_thresh > 0) {\n        size = trim_thresh/2;\n    } else if (mmap_thresh > 0) {\n        size = mmap_thresh/2;\n    } else {\n        size = 10 * 1024 * 1024;\n    }\n\n    UCS_TEST_MESSAGE << \"trim_thresh=\" << trim_thresh << \" mmap_thresh=\" << mmap_thresh <<\n                        \" allocating=\" << size;\n    p = new char [size];\n    ASSERT_TRUE(p != NULL);\n    delete [] p;\n\n    EXPECT_EQ(m_unmapped_size, size_t(0));\n\n    unset();\n}\n\nUCS_TEST_SKIP_COND_F(malloc_hook_cplusplus, mmap_ptrs, RUNNING_ON_VALGRIND) {\n    ucm_global_opts.enable_dynamic_mmap_thresh = 0;\n    set();\n\n    const size_t   size    = ucm_dlmallopt_get(M_MMAP_THRESHOLD) * 2;\n    const size_t   max_mem = ucs_min(ucs_get_phys_mem_size() / 4, 4 * UCS_GBYTE);\n    const unsigned count   = ucs_min(400000ul, max_mem / size);\n    const unsigned iters   = 100000;\n\n    std::vector< std::vector<char> > ptrs;\n\n    size_t large_blocks = 0;\n\n    /* Allocate until we get MMAP event\n     * Lock memory to avoid going to swap and ensure consistet test results.\n     */\n    while (m_mapped_size == 0) {\n        std::vector<char> str(size, 'r');\n        ptrs.push_back(str);\n        ++large_blocks;\n    }\n\n    /* Remove memory off the heap top, to ensure the following large allocations\n     * will use mmap()\n     */\n    malloc_trim(0);\n\n    /* Measure allocation time with \"clear\" heap state */\n    double alloc_time = measure_alloc_time(size, iters);\n    UCS_TEST_MESSAGE << \"With \" << large_blocks << \" large blocks:\"\n                     << \" allocated \" << iters << \" buffers of \" << size\n                     << \" bytes in \" << alloc_time << \" sec\";\n\n    /* Allocate many large strings to trigger mmap() based allocation. */\n    ptrs.resize(count);\n    for (unsigned i = 0; i < count; ++i) {\n        ptrs[i].resize(size, 't');\n        ++large_blocks;\n    }\n\n    /* Measure allocation time with many large blocks on the heap */\n    bool success = false;\n    unsigned attempt = 0;\n    while (!success && (attempt < 5)) {\n        double alloc_time_with_ptrs = measure_alloc_time(size, iters);\n        UCS_TEST_MESSAGE << \"With \" << large_blocks << \" large blocks:\"\n                         << \" allocated \" << iters << \" buffers of \" << size\n                         << \" bytes in \" << alloc_time_with_ptrs << \" sec\";\n\n        /* Allow up to 75% difference */\n        success = (alloc_time < 0.25) || (alloc_time_with_ptrs < (1.75 * alloc_time));\n        ++attempt;\n    }\n\n    if (!success) {\n        ADD_FAILURE() << \"Failed after \" << attempt << \" attempts\";\n    }\n\n    ptrs.clear();\n\n    unset();\n\n}\n\nUCS_TEST_F(malloc_hook_cplusplus, remap_override_single_thread) {\n    pthread_barrier_t barrier;\n    pthread_barrier_init(&barrier, NULL, 1);\n    {\n        mhook_thread<mmap_hooks>(new mmap_hooks(\"single-thread\", 1, &barrier));\n    }\n    pthread_barrier_destroy(&barrier);\n}\n\nUCS_TEST_F(malloc_hook_cplusplus, remap_override_multi_threads) {\n    typedef mhook_thread<mmap_hooks> thread_t;\n\n    static const int num_threads = 8;\n    ucs::ptr_vector<thread_t> threads;\n    pthread_barrier_t barrier;\n\n    pthread_barrier_init(&barrier, NULL, num_threads);\n    for (int i = 0; i < num_threads; ++i) {\n        std::stringstream ss;\n        ss << \"thread \" << i << \"/\" << num_threads;\n        threads.push_back(new thread_t(new mmap_hooks(ss.str(), num_threads, &barrier)));\n    }\n\n    threads.clear();\n    pthread_barrier_destroy(&barrier);\n}\n\ntypedef int (munmap_f_t)(void *addr, size_t len);\n\nUCS_TEST_SKIP_COND_F(malloc_hook, bistro_patch, RUNNING_ON_VALGRIND) {\n    const char *symbol = \"munmap\";\n    ucm_bistro_restore_point_t *rp = NULL;\n    ucs_status_t status;\n    munmap_f_t *munmap_f;\n    void *ptr;\n    int res;\n    uint64_t UCS_V_UNUSED patched;\n    uint64_t UCS_V_UNUSED origin;\n\n    /* set hook to mmap call */\n    status = ucm_bistro_patch(symbol, (void*)bistro_hook<0>::munmap, &rp);\n    ASSERT_UCS_OK(status);\n    EXPECT_NE((intptr_t)rp, 0);\n\n    munmap_f = (munmap_f_t*)ucm_bistro_restore_addr(rp);\n    EXPECT_NE((intptr_t)munmap_f, 0);\n\n    /* save partial body of patched function */\n    patched = *(uint64_t*)munmap_f;\n\n    bistro_call_counter = 0;\n    ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);\n    EXPECT_NE(ptr, MAP_FAILED);\n\n    /* try to call munmap, we should jump into munmap_hook instead */\n    res = munmap_f(ptr, 4096);\n    EXPECT_EQ(res, 0);\n    /* due to cache coherency issues on ARM systems could be executed\n     * original function body, so, skip counter evaluation */\n    EXPECT_GT(bistro_call_counter, 0);\n\n    /* restore original mmap body */\n    status = ucm_bistro_restore(rp);\n    ASSERT_UCS_OK(status);\n\n    bistro_call_counter = 0;\n    /* now try to call mmap, we should NOT jump into mmap_hook */\n    ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);\n    EXPECT_NE(ptr, MAP_FAILED);\n    res = munmap_f(ptr, 4096);\n    EXPECT_EQ(res, 0);\n    EXPECT_EQ(bistro_call_counter, 0);  /* hook is not called */\n    /* save partial body of restored function */\n    origin = *(uint64_t*)munmap_f;\n\n#if !defined (__powerpc64__)\n    EXPECT_NE(patched, origin);\n#endif\n}\n\nUCS_TEST_SKIP_COND_F(malloc_hook, test_event, RUNNING_ON_VALGRIND) {\n    mmap_event<malloc_hook> event(this);\n    ucs_status_t status;\n\n    status = event.set(UCM_EVENT_VM_MAPPED | UCM_EVENT_VM_UNMAPPED);\n    ASSERT_UCS_OK(status);\n\n    status = ucm_test_events(UCM_EVENT_VM_MAPPED | UCM_EVENT_VM_UNMAPPED);\n    ASSERT_UCS_OK(status);\n}\n\nUCS_TEST_SKIP_COND_F(malloc_hook, test_event_failed,\n                     RUNNING_ON_VALGRIND || !skip_on_bistro()) {\n    mmap_event<malloc_hook> event(this);\n    ucs_status_t status;\n    const char *symbol_munmap  = \"munmap\";\n    const char *symbol_madvise = \"madvise\";\n\n    status = event.set(UCM_EVENT_MUNMAP | UCM_EVENT_VM_UNMAPPED);\n    ASSERT_UCS_OK(status);\n\n    /* set hook to munmap call */\n    {\n        bistro_patch patch(symbol_munmap, (void*)bistro_hook<0>::munmap);\n        EXPECT_TRUE(ucm_test_events(UCM_EVENT_MUNMAP)      == UCS_ERR_UNSUPPORTED);\n        EXPECT_TRUE(ucm_test_events(UCM_EVENT_VM_UNMAPPED) == UCS_ERR_UNSUPPORTED);\n        EXPECT_TRUE(ucm_test_events(UCM_EVENT_MUNMAP | UCM_EVENT_VM_UNMAPPED) ==\n                    UCS_ERR_UNSUPPORTED);\n    }\n    /* set hook to madvise call */\n    {\n        bistro_patch patch(symbol_madvise, (void*)bistro_hook<0>::madvise);\n        EXPECT_TRUE(ucm_test_events(UCM_EVENT_MADVISE)     == UCS_ERR_UNSUPPORTED);\n        EXPECT_TRUE(ucm_test_events(UCM_EVENT_VM_UNMAPPED) == UCS_ERR_UNSUPPORTED);\n    }\n}\n\nUCS_TEST_SKIP_COND_F(malloc_hook, test_external_event,\n                     RUNNING_ON_VALGRIND || !skip_on_bistro()) {\n    mmap_event<malloc_hook> event(this);\n    ucs_status_t status;\n    const char *symbol_munmap  = \"munmap\";\n    const char *symbol_madvise = \"madvise\";\n\n    status = event.set_external(UCM_EVENT_VM_UNMAPPED);\n    ASSERT_UCS_OK(status);\n\n    /* set hook to munmap call */\n    {\n        bistro_patch patch(symbol_munmap, (void*)bistro_hook<0>::munmap);\n        /* OK due to UCM_EVENT_MUNMAP is not external */\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_MUNMAP)      == UCS_OK);\n        /* should fail */\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_VM_UNMAPPED) == UCS_ERR_UNSUPPORTED);\n        /* should fail */\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_MUNMAP | UCM_EVENT_VM_UNMAPPED) ==\n                    UCS_ERR_UNSUPPORTED);\n    }\n    /* set hook to madvise call */\n    {\n        bistro_patch patch(symbol_madvise, (void*)bistro_hook<0>::madvise);\n        /* OK due to UCM_EVENT_MADVISE is not external */\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_MADVISE)     == UCS_OK);\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_VM_UNMAPPED) == UCS_ERR_UNSUPPORTED);\n    }\n    /* set hook to munmap/madvise call which notify vm_unmap */\n    {\n        bistro_patch patch_unmap(symbol_munmap, (void*)bistro_hook<1>::munmap);\n        bistro_patch patch_advise(symbol_madvise, (void*)bistro_hook<1>::madvise);\n        /* OK due to UCM_EVENT_MUNMAP is not external */\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_MUNMAP)      == UCS_OK);\n        /* OK due to UCM_EVENT_MADVISE is not external */\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_MADVISE)     == UCS_OK);\n        /* should be OK */\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_VM_UNMAPPED) == UCS_OK);\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_MUNMAP | UCM_EVENT_VM_UNMAPPED) ==\n                    UCS_OK);\n    }\n    /* set hook to munmap & madvise call, but madvise does NOT notify vm_unmap */\n    {\n        bistro_patch patch_unmap(symbol_munmap, (void*)bistro_hook<1>::munmap);\n        bistro_patch patch_advise(symbol_madvise, (void*)bistro_hook<0>::madvise);\n        /* OK due to UCM_EVENT_MUNMAP is not external */\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_MUNMAP)      == UCS_OK);\n        /* OK due to UCM_EVENT_MADVISE is not external */\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_MADVISE)     == UCS_OK);\n        /* should fail */\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_VM_UNMAPPED) == UCS_ERR_UNSUPPORTED);\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_MUNMAP | UCM_EVENT_VM_UNMAPPED) ==\n                    UCS_ERR_UNSUPPORTED);\n    }\n}\n\nUCS_TEST_SKIP_COND_F(malloc_hook, test_event_unmap,\n                     RUNNING_ON_VALGRIND || !skip_on_bistro()) {\n    mmap_event<malloc_hook> event(this);\n    ucs_status_t status;\n    const char *symbol = \"munmap\";\n\n    status = event.set(UCM_EVENT_MMAP | UCM_EVENT_MUNMAP | UCM_EVENT_VM_UNMAPPED);\n    ASSERT_UCS_OK(status);\n\n    /* set hook to mmap call */\n    bistro_patch patch(symbol, (void*)bistro_hook<1>::munmap);\n\n    /* munmap should be broken */\n    status = ucm_test_events(UCM_EVENT_MUNMAP);\n    EXPECT_TRUE(status == UCS_ERR_UNSUPPORTED);\n\n    /* vm_unmap should be broken as well, because munmap is broken */\n    status = ucm_test_events(UCM_EVENT_MUNMAP);\n    EXPECT_TRUE(status == UCS_ERR_UNSUPPORTED);\n\n    /* mmap should still work */\n    status = ucm_test_events(UCM_EVENT_MMAP);\n    EXPECT_TRUE(status == UCS_OK);\n}\n\nclass malloc_hook_dlopen : public malloc_hook {\nprotected:\n    class library {\n    public:\n        typedef void* (*loader_t)(const char*, int);\n\n        library(loader_t loader, const std::string &name = \"\"):\n            m_loader(loader), m_name(name), m_lib(NULL)\n        {\n        }\n\n        ~library()\n        {\n            close();\n        }\n\n        void *open(const std::string name = \"\")\n        {\n            if (!name.empty()) {\n                m_name = name;\n            }\n\n            close();\n\n            return (m_lib = m_loader(m_name.empty() ? NULL : m_name.c_str(), RTLD_NOW));\n        }\n\n        void attach(void *lib)\n        {\n            close();\n            m_lib = lib;\n        }\n\n        void close()\n        {\n            if (m_lib != NULL) {\n                dlclose(m_lib);\n                m_lib = NULL;\n            }\n        }\n\n        operator bool()\n        {\n            return m_lib != NULL;\n        }\n\n        void* sym(const char *name)\n        {\n            return dlsym(m_lib, name);\n        }\n\n    protected:\n        loader_t    m_loader;\n        std::string m_name;\n        void       *m_lib;\n    };\n\npublic:\n    typedef library::loader_t loader_t;\n\n    static std::string get_lib_dir() {\n#ifndef GTEST_UCM_HOOK_LIB_DIR\n#  error \"Missing build configuration\"\n#else\n        return GTEST_UCM_HOOK_LIB_DIR;\n#endif\n    }\n\n    static std::string get_lib_path_do_load() {\n        return get_lib_dir() + \"/libdlopen_test_do_load.so\";\n    }\n\n    static std::string get_lib_path_do_mmap() {\n        return get_lib_dir() + \"/libdlopen_test_do_mmap.so\";\n    }\n\n    static std::string get_lib_path_do_load_rpath() {\n        return get_lib_dir() + \"/libdlopen_test_do_load_rpath.so\";\n    }\n\n    static std::string get_lib_path_do_load_sub_rpath() {\n        return \"libdlopen_test_rpath.so\"; // library should be located using rpath\n    }\n\n    /* test for mmap events are fired from non-direct load modules\n     * we are trying to load lib1, from lib1 load lib2, and\n     * fire mmap event from lib2 */\n    void test_indirect_dlopen(loader_t loader)\n    {\n        typedef void (*fire_mmap_f)(void);\n        typedef void* (*load_lib_f)(const char *path, void* (*func)(const char*, int));\n\n        const char *load_lib  = \"load_lib\";\n        const char *fire_mmap = \"fire_mmap\";\n\n        library lib(loader, get_lib_path_do_load());\n        library lib2(NULL); // lib2 is used for attach only\n        load_lib_f load;\n        fire_mmap_f fire;\n        ucs_status_t status;\n        mmap_event<malloc_hook> event(this);\n\n        status = event.set(UCM_EVENT_VM_MAPPED);\n        ASSERT_UCS_OK(status);\n\n        lib.open();\n        ASSERT_TRUE(lib);\n\n        load = (load_lib_f)lib.sym(load_lib);\n        ASSERT_TRUE(load != NULL);\n\n        lib2.attach(load(get_lib_path_do_mmap().c_str(), loader));\n        ASSERT_TRUE(lib2);\n\n        fire = (fire_mmap_f)lib2.sym(fire_mmap);\n        ASSERT_TRUE(fire != NULL);\n\n        m_got_event = 0;\n        fire();\n        EXPECT_GT(m_got_event, 0);\n    }\n\n    /* Test for rpath section of caller module is processes */\n    void test_rpath_dlopen(loader_t loader)\n    {\n        typedef void* (*load_lib_f)(const char *path, void* (*func)(const char*, int));\n\n        const char *load_lib = \"load_lib\";\n\n        library lib(loader);\n        library lib2(NULL); // lib2 is used for attach only\n        load_lib_f load;\n        ucs_status_t status;\n        mmap_event<malloc_hook> event(this);\n\n        /* in case if reloc mode is used - it force hook dlopen */\n        status = event.set(UCM_EVENT_VM_MAPPED);\n        ASSERT_UCS_OK(status);\n\n        /* first check that without rpath library located in subdirectory could not be loaded */\n        lib.open(get_lib_path_do_load());\n        ASSERT_TRUE(lib);\n        if (!lib) {\n            return;\n        }\n\n        load = (load_lib_f)lib.sym(load_lib);\n        ASSERT_TRUE(load != NULL);\n\n        lib2.attach(load(get_lib_path_do_load_sub_rpath().c_str(), loader));\n        ASSERT_FALSE(lib2);\n\n        /* next check that rpath helps to load library located in subdirectory */\n        /* don't care about opened libs - it will be closed automatically */\n        lib.open(get_lib_path_do_load_rpath());\n        ASSERT_TRUE(lib);\n        if (!lib) {\n            return;\n        }\n\n        load = (load_lib_f)lib.sym(load_lib);\n        ASSERT_TRUE(load != NULL);\n\n        lib2.attach(load(get_lib_path_do_load_sub_rpath().c_str(), loader));\n        ASSERT_TRUE(lib2);\n    }\n\n    void test_dlopen_null(loader_t loader)\n    {\n        library lib(loader);\n\n        lib.open();\n        ASSERT_TRUE(lib);\n    }\n};\n\nUCS_TEST_F(malloc_hook_dlopen, indirect_dlopen) {\n    test_indirect_dlopen(dlopen);\n}\n\nUCS_TEST_F(malloc_hook_dlopen, indirect_ucm_dlopen) {\n    test_indirect_dlopen(ucm_dlopen);\n}\n\nUCS_TEST_F(malloc_hook_dlopen, rpath_dlopen) {\n    test_rpath_dlopen(dlopen);\n}\n\nUCS_TEST_F(malloc_hook_dlopen, rpath_ucm_dlopen) {\n    test_rpath_dlopen(ucm_dlopen);\n}\n\nUCS_TEST_F(malloc_hook_dlopen, ucm_dlopen_null_dlopen) {\n    test_dlopen_null(dlopen);\n}\n\nUCS_TEST_F(malloc_hook_dlopen, ucm_dlopen_null_ucm_dlopen) {\n    test_dlopen_null(ucm_dlopen);\n}\n\nUCS_MT_TEST_F(malloc_hook_dlopen, dlopen_mt_with_memtype, 2) {\n#ifndef GTEST_UCM_HOOK_LIB_DIR\n#  error \"Missing build configuration\"\n#endif\n    mmap_event<malloc_hook> event(this);\n\n    ucs_status_t status = event.set(UCM_EVENT_VM_MAPPED |\n                                    UCM_EVENT_MEM_TYPE_ALLOC |\n                                    UCM_EVENT_MEM_TYPE_FREE);\n    ASSERT_UCS_OK(status);\n\n    const std::string path = get_lib_path_do_mmap();\n    static uint32_t count = 0;\n\n    for (int i = 0; i < 100 / ucs::test_time_multiplier(); ++i) {\n        /* Tests that calling dlopen() from 2 threads does not deadlock, if for\n         * example we install memtype relocation patches and call dladdr() while\n         * iterating over loaded libraries.\n         */\n        if (ucs_atomic_fadd32(&count, 1) % 2) {\n            void *lib1 = dlopen(get_lib_path_do_mmap().c_str(), RTLD_LAZY);\n            ASSERT_TRUE(lib1 != NULL);\n            dlclose(lib1);\n        } else {\n            void *lib2 = dlopen(get_lib_path_do_load().c_str(), RTLD_LAZY);\n            ASSERT_TRUE(lib2 != NULL);\n            dlclose(lib2);\n        }\n\n        barrier();\n    }\n\n    event.unset();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/test/gtest/ucm/test_dlopen/configure.m4": "#\n# Copyright (C) Mellanox Technologies Ltd. 2001-2019.  ALL RIGHTS RESERVED.\n#\n# See file LICENSE for terms.\n#\n\nAC_CONFIG_FILES([test/gtest/ucm/test_dlopen/Makefile])\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/test/gtest/ucm/test_dlopen/dlopen_test_do_load.c": "/**\n * Copyright (C) Mellanox Technologies Ltd.      2018.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#include <ucs/sys/compiler.h>\n\n#include <dlfcn.h>\n\nUCS_F_NOOPTIMIZE /* prevent using tail recursion unwind */\nvoid* load_lib(const char *path, void* (*load_func)(const char*, int))\n{\n    return (load_func ? load_func : dlopen)(path, RTLD_NOW);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/test/gtest/ucm/test_dlopen/Makefile.am": "#\n# Copyright (C) Mellanox Technologies Ltd. 2001-2018.  ALL RIGHTS RESERVED.\n#\n# See file LICENSE for terms.\n#\n\n\nnoinst_lib_LTLIBRARIES = \\\n\tlibdlopen_test_do_mmap.la \\\n\tlibdlopen_test_do_load.la \\\n\tlibdlopen_test_do_load_rpath.la\n\nlibdlopen_test_do_mmap_la_SOURCES       = dlopen_test_do_mmap.c\nlibdlopen_test_do_load_la_SOURCES       = dlopen_test_do_load.c\nlibdlopen_test_do_load_rpath_la_SOURCES = dlopen_test_do_load.c\nnoinst_libdir = ${PWD}/.noinst\n\nlibdlopen_test_do_load_rpath_la_CPPFLAGS = -I$(top_srcdir)/src\nlibdlopen_test_do_load_la_CPPFLAGS       = -I$(top_srcdir)/src\nlibdlopen_test_do_load_rpath_la_LDFLAGS  = -R=${PWD}/rpath-subdir/.libs\n\nSUBDIRS = rpath-subdir\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/test/gtest/ucm/test_dlopen/rpath-subdir/configure.m4": "#\n# Copyright (C) Mellanox Technologies Ltd. 2019. ALL RIGHTS RESERVED.\n#\n# See file LICENSE for terms.\n#\n\nAC_CONFIG_FILES([test/gtest/ucm/test_dlopen/rpath-subdir/Makefile])\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/test/gtest/ucm/test_dlopen/rpath-subdir/Makefile.am": "#\n# Copyright (C) Mellanox Technologies Ltd. 2019. ALL RIGHTS RESERVED.\n#\n# See file LICENSE for terms.\n#\n\n\nnoinst_lib_LTLIBRARIES = \\\n\tlibdlopen_test_rpath.la\n\nlibdlopen_test_rpath_la_SOURCES = dlopen_test_rpath.c\nnoinst_libdir = ${PWD}/.noinst\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/test/apps/test_link_map.c": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2019.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif\n\n#include <ucp/api/ucp.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n\nint main(int argc, char **argv)\n{\n    ucp_params_t params;\n    ucs_status_t status;\n    ucp_context_h context;\n\n    params.field_mask = UCP_PARAM_FIELD_FEATURES;\n    params.features   = UCP_FEATURE_TAG;\n\n    status = ucp_init(&params, NULL, &context);\n    if (status != UCS_OK) {\n        return -1;\n    }\n\n    /* This could segfault if libucm_cuda.so is marked as linker nodelete but\n     * could not be loaded due to libcuda dependency, because of a corrupted\n     * link_map in the program.\n     */\n    dlopen(\"libgcc_s.so.1\", RTLD_LAZY);\n\n    ucp_cleanup(context);\n\n    printf(\"SUCCESS\\n\");\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/test/apps/test_tcmalloc.c": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2001-2018.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#include <ucp/api/ucp.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n\nint main(int argc, char **argv)\n{\n    ucp_params_t params;\n    ucs_status_t status;\n    ucp_context_h context;\n\n    params.field_mask = UCP_PARAM_FIELD_FEATURES;\n    params.features   = UCP_FEATURE_TAG;\n\n    status = ucp_init(&params, NULL, &context);\n    if (status != UCS_OK) {\n        return -1;\n    }\n\n    dlopen(\"libselinux.so\", RTLD_LAZY);\n\n    ucp_cleanup(context);\n\n    printf(\"SUCCESS\\n\");\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/test/apps/test_dlopen_cfg_print.c": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2019.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#define _QUOTE(x) #x\n#define QUOTE(x) _QUOTE(x)\n\n\nstatic void* do_dlopen_or_exit(const char *filename)\n{\n    void *handle;\n\n    (void)dlerror();\n    printf(\"opening '%s'\\n\", filename);\n    handle = dlopen(filename, RTLD_LAZY);\n    if (handle == NULL) {\n        fprintf(stderr, \"failed to open %s: %s\\n\", filename,\n                dlerror());\n        exit(1);\n    }\n\n    return handle;\n}\n\nint main(int argc, char **argv)\n{\n    typedef void (*print_all_opts_func_t)(FILE*, const char *, int);\n\n    const char *ucs_filename = QUOTE(UCS_LIB_PATH);\n    const char *uct_filename = QUOTE(UCT_LIB_PATH);\n    void *ucs_handle, *uct_handle;\n    int i;\n\n    /* unload and reload uct while ucs is loaded\n     * would fail if uct global vars are kept on global lists in ucs */\n    ucs_handle = do_dlopen_or_exit(ucs_filename);\n    for (i = 0; i < 2; ++i) {\n        uct_handle = do_dlopen_or_exit(uct_filename);\n        dlclose(uct_handle);\n    }\n\n    /* print all config table, to force going over the global list in ucs */\n    print_all_opts_func_t print_all_opts =\n        (print_all_opts_func_t)dlsym(ucs_handle, \"ucs_config_parser_print_all_opts\");\n    print_all_opts(stdout, \"TEST_\", 0);\n    dlclose(ucs_handle);\n\n    printf(\"done\\n\");\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/test/apps/test_ucs_dlopen.c": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2019.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif\n\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n\n#include <ucm/api/ucm.h>\n\n#define _QUOTE(x) #x\n#define QUOTE(x) _QUOTE(x)\n\n\nstatic void vm_unmap_cb(ucm_event_type_t event_type, ucm_event_t *event,\n                        void *arg)\n{\n}\n\nint test_ucm_set_event_handler(void *handle)\n{\n    typedef ucs_status_t (*ucm_set_event_handler_func_t)(int events,\n                                                         int priority,\n                                                         ucm_event_callback_t cb,\n                                                         void *arg);\n\n    ucm_set_event_handler_func_t ucm_set_event_handler_f;\n    ucs_status_t status;\n\n    dlerror();\n    ucm_set_event_handler_f = (ucm_set_event_handler_func_t)dlsym(handle,\n                                                                  \"ucm_set_event_handler\");\n    if (ucm_set_event_handler_f == NULL) {\n        fprintf(stderr, \"failed to resolve ucm_set_event_handler(): %s\\n\",\n                dlerror());\n        return -1;\n    }\n\n    status = ucm_set_event_handler_f(UCM_EVENT_VM_UNMAPPED, 0, vm_unmap_cb,\n                                     NULL);\n    if (status != UCS_OK) {\n        fprintf(stderr, \"ucm_set_event_handler() failed\\n\");\n        return -1;\n    }\n\n    return 0;\n}\n\nint main(int argc, char **argv)\n{\n    const char *filename = QUOTE(LIB_PATH);\n    void *handle;\n    void *ptr1, *ptr2;\n    size_t alloc_size;\n    long ret;\n\n    /* get page size */\n    ret = sysconf(_SC_PAGESIZE);\n    if (ret < 0) {\n        fprintf(stderr, \"sysconf(_SC_PAGESIZE) failed: %m\\n\");\n        return -1;\n    }\n    alloc_size = ret;\n\n    /* allocate some memory */\n    ptr1 = malloc(alloc_size);\n    if (!ptr1) {\n        fprintf(stderr, \"malloc() failed\\n\");\n        return -1;\n    }\n\n    ptr2 = mmap(NULL, alloc_size, PROT_READ|PROT_WRITE,\n                MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    if (ptr2 == MAP_FAILED) {\n        fprintf(stderr, \"mmmap() failed: %m\\n\");\n        ret = -1;\n        goto failed_mmap;\n    }\n\n    /* load ucm */\n    printf(\"opening '%s'\\n\", filename);\n    dlerror();\n    handle = dlopen(filename, RTLD_NOW);\n    if (handle == NULL) {\n        fprintf(stderr, \"failed to open %s: %s\\n\", filename, dlerror());\n        ret = -1;\n        goto failed_dlopen;\n    }\n\n    /* init ucm */\n    ret = test_ucm_set_event_handler(handle);\n\n    /* unload ucp */\n    dlclose(handle);\n\nfailed_dlopen:\n    /* release the memory - could break if UCM is unloaded */\n    munmap(ptr2, alloc_size);\nfailed_mmap:\n    free(ptr1);\n\n    printf(\"done\\n\");\n    return ret;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/test/apps/Makefile.am": "#\n# Copyright (C) Mellanox Technologies Ltd. 2001-2014.  ALL RIGHTS RESERVED.\n# Copyright (C) UT-Battelle, LLC. 2015. ALL RIGHTS RESERVED.\n# Copyright (C) ARM Ltd. 2017.  ALL RIGHTS RESERVED.\n#\n# See file LICENSE for terms.\n#\n\nSUBDIRS = profiling\n\nif HAVE_GLIBCXX_NOTHROW\nSUBDIRS += iodemo\nendif\n\nif HAVE_CXX11\nSUBDIRS += sockaddr\nendif\n\nnoinst_PROGRAMS = \\\n\ttest_ucp_dlopen \\\n\ttest_ucs_dlopen \\\n\ttest_link_map \\\n\ttest_dlopen_cfg_print\n\nobjdir = $(shell sed -n -e 's/^objdir=\\(.*\\)$$/\\1/p' $(LIBTOOL))\n\ntest_ucs_dlopen_SOURCES  = test_ucs_dlopen.c\ntest_ucs_dlopen_CPPFLAGS = $(BASE_CPPFLAGS) \\\n                           -DLIB_PATH=$(abs_top_builddir)/src/ucs/$(objdir)/libucs.so\ntest_ucs_dlopen_CFLAGS   = $(BASE_CFLAGS)\ntest_ucs_dlopen_LDADD    = -ldl\n\ntest_ucp_dlopen_SOURCES  = test_ucp_dlopen.c\ntest_ucp_dlopen_CPPFLAGS = $(BASE_CPPFLAGS) \\\n                           -DLIB_PATH=$(abs_top_builddir)/src/ucp/$(objdir)/libucp.so\ntest_ucp_dlopen_CFLAGS   = $(BASE_CFLAGS)\ntest_ucp_dlopen_LDADD    = -ldl\n\ntest_link_map_SOURCES  = test_link_map.c\ntest_link_map_CPPFLAGS = $(BASE_CPPFLAGS)\ntest_link_map_CFLAGS   = $(BASE_CFLAGS)\ntest_link_map_LDADD    = -ldl $(top_builddir)/src/ucp/libucp.la\n\ntest_dlopen_cfg_print_SOURCES  = test_dlopen_cfg_print.c\ntest_dlopen_cfg_print_CPPFLAGS = $(BASE_CPPFLAGS) -g \\\n\t-DUCS_LIB_PATH=$(abs_top_builddir)/src/ucs/$(objdir)/libucs.so \\\n\t-DUCT_LIB_PATH=$(abs_top_builddir)/src/uct/$(objdir)/libuct.so\ntest_dlopen_cfg_print_CFLAGS   = $(BASE_CFLAGS)\ntest_dlopen_cfg_print_LDADD    = -ldl\n\nif HAVE_TCMALLOC\nnoinst_PROGRAMS       += test_tcmalloc\ntest_tcmalloc_SOURCES  = test_tcmalloc.c\ntest_tcmalloc_CPPFLAGS = $(BASE_CPPFLAGS)\ntest_tcmalloc_CFLAGS   = $(BASE_CFLAGS)\ntest_tcmalloc_LDADD    = -ldl $(TCMALLOC_LIB) \\\n                          $(top_builddir)/src/ucp/libucp.la\nendif\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/test/apps/test_ucp_dlopen.c": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2019.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif\n\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n\n#include <ucp/api/ucp.h>\n\n#define _QUOTE(x) #x\n#define QUOTE(x) _QUOTE(x)\n\n\nint test_ucp_init(void *handle)\n{\n    typedef ucs_status_t (*ucp_init_version_func_t)(unsigned, unsigned,\n                                                    const ucp_params_t *,\n                                                    const ucp_config_t *,\n                                                    ucp_context_h *);\n    typedef void (*ucp_context_print_info_func_t)(const ucp_context_h, FILE*);\n    typedef void (*ucp_cleanup_func_t)(ucp_context_h);\n\n    ucp_init_version_func_t ucp_init_version_f;\n    ucp_context_print_info_func_t ucp_context_print_info_f;\n    ucp_cleanup_func_t ucp_cleanup_f;\n    ucp_params_t ucp_params;\n    ucs_status_t status;\n    ucp_context_h ucph;\n\n    ucp_init_version_f       = (ucp_init_version_func_t)dlsym(handle,\n                                                              \"ucp_init_version\");\n    ucp_cleanup_f            = (ucp_cleanup_func_t)dlsym(handle, \"ucp_cleanup\");\n    ucp_context_print_info_f = (ucp_context_print_info_func_t)dlsym(handle,\n                                                                    \"ucp_context_print_info\");\n\n    if (!ucp_init_version_f || !ucp_cleanup_f || !ucp_context_print_info_f) {\n        fprintf(stderr, \"failed to get UCP function pointers\\n\");\n        return -1;\n    }\n\n    ucp_params.field_mask = UCP_PARAM_FIELD_FEATURES;\n    ucp_params.features   = UCP_FEATURE_RMA;\n    status = ucp_init_version_f(UCP_API_MAJOR, UCP_API_MINOR, &ucp_params,\n                                NULL, &ucph);\n    if (status != UCS_OK) {\n        fprintf(stderr, \"ucp_init_version() failed\\n\");\n        return -1;\n    }\n\n    ucp_context_print_info_f(ucph, stdout);\n    ucp_cleanup_f(ucph);\n\n    return 0;\n}\n\nint main(int argc, char **argv)\n{\n    const char *filename = QUOTE(LIB_PATH);\n    void *handle;\n    void *ptr1, *ptr2;\n    size_t alloc_size;\n    long ret;\n\n    /* get page size */\n    ret = sysconf(_SC_PAGESIZE);\n    if (ret < 0) {\n        fprintf(stderr, \"sysconf(_SC_PAGESIZE) failed: %m\\n\");\n        return -1;\n    }\n    alloc_size = ret;\n\n    /* allocate some memory */\n    ptr1 = malloc(alloc_size);\n    if (!ptr1) {\n        fprintf(stderr, \"malloc() failed\\n\");\n        return -1;\n    }\n\n    ptr2 = mmap(NULL, alloc_size, PROT_READ|PROT_WRITE,\n                MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    if (ptr2 == MAP_FAILED) {\n        fprintf(stderr, \"mmmap() failed: %m\\n\");\n        ret = -1;\n        goto failed_mmap;\n    }\n\n    /* load ucp */\n    printf(\"opening '%s'\\n\", filename);\n    handle = dlopen(filename, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n        fprintf(stderr, \"failed to open %s: %m\\n\", filename);\n        ret = -1;\n        goto failed_dlopen;\n    }\n\n    /* init ucp */\n    ret = test_ucp_init(handle);\n\n    /* unload ucp */\n    dlclose(handle);\n\nfailed_dlopen:\n    /* relase the memory - could break if UCM is unloaded */\n    munmap(ptr2, alloc_size);\nfailed_mmap:\n    free(ptr1);\n\n    printf(\"done\\n\");\n    return ret;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/contrib/test_jenkins.sh": "#!/bin/bash -eExl\n#\n# Testing script for OpenUCX, to run from Jenkins CI\n#\n# Copyright (C) Mellanox Technologies Ltd. 2001-2017.  ALL RIGHTS RESERVED.\n# Copyright (C) ARM Ltd. 2016-2018.  ALL RIGHTS RESERVED.\n#\n# See file LICENSE for terms.\n#\n#\n# Environment variables set by Jenkins CI:\n#  - WORKSPACE           : path to work dir\n#  - BUILD_NUMBER        : jenkins build number\n#  - JOB_URL             : jenkins job url\n#  - EXECUTOR_NUMBER     : number of executor within the test machine\n#  - JENKINS_RUN_TESTS   : whether to run unit tests\n#  - RUN_TESTS           : same as JENKINS_RUN_TESTS, but for Azure\n#  - JENKINS_TEST_PERF   : whether to validate performance\n#  - JENKINS_NO_VALGRIND : set this to disable valgrind tests\n#\n# Optional environment variables (could be set by job configuration):\n#  - nworkers : number of parallel executors\n#  - worker   : number of current parallel executor\n#  - COV_OPT  : command line options for Coverity static checker\n#\n\nWORKSPACE=${WORKSPACE:=$PWD}\nucx_inst=${WORKSPACE}/install\nCUDA_MODULE=\"dev/cuda11.0\"\nGDRCOPY_MODULE=\"dev/gdrcopy2.0_cuda11.0\"\n\nif [ -z \"$BUILD_NUMBER\" ]; then\n\techo \"Running interactive\"\n\tBUILD_NUMBER=1\n\tWS_URL=file://$WORKSPACE\n\tJENKINS_RUN_TESTS=yes\n\tJENKINS_TEST_PERF=1\n\tTIMEOUT=\"\"\n\tTIMEOUT_VALGRIND=\"\"\nelse\n\techo \"Running under jenkins\"\n\tWS_URL=$JOB_URL/ws\n\tTIMEOUT=\"timeout 160m\"\n\tTIMEOUT_VALGRIND=\"timeout 200m\"\nfi\n\n\n#\n# Set affinity to 2 cores according to Jenkins executor number.\n# Affinity is inherited from agent in Azure CI.\n# TODO: remove or rename after CI migration.\n#\nif [ -n \"$EXECUTOR_NUMBER\" ] && [ -n \"$JENKINS_RUN_TESTS\" ]\nthen\n\tAFFINITY=\"taskset -c $(( 2 * EXECUTOR_NUMBER ))\",\"$(( 2 * EXECUTOR_NUMBER + 1))\"\nelse\n\tAFFINITY=\"\"\nfi\n\n#\n# Parallel build command runs with 4 tasks, or number of cores on the system,\n# whichever is lowest\n#\nnum_cpus=$(lscpu -p | grep -v '^#' | wc -l)\n[ -z $num_cpus ] && num_cpus=1\nparallel_jobs=4\n[ $parallel_jobs -gt $num_cpus ] && parallel_jobs=$num_cpus\nnum_pinned_threads=$(nproc)\n[ $parallel_jobs -gt $num_pinned_threads ] && parallel_jobs=$num_pinned_threads\n\nMAKE=\"make\"\nMAKEP=\"make -j${parallel_jobs}\"\nexport AUTOMAKE_JOBS=$parallel_jobs\n\n\n#\n# Set up parallel test execution - \"worker\" and \"nworkers\" should be set by jenkins\n#\nif [ -z \"$worker\" ] || [ -z \"$nworkers\" ]\nthen\n\tworker=0\n\tnworkers=1\nfi\necho \"==== Running on $(hostname), worker $worker / $nworkers ====\"\n\n#\n# cleanup ucx\n#\nmake_clean() {\n        rm -rf ${ucx_inst}\n        $MAKEP ${1:-clean}\n}\n\n#\n# Test if an environment module exists and load it if yes.\n# Otherwise, return error code.\n#\nmodule_load() {\n\tset +x\n\tmodule=$1\n\tm_avail=\"$(module avail $module 2>&1)\" || true\n\n\tif module avail -t 2>&1 | grep -q \"^$module\\$\"\n\tthen\n\t\tmodule load $module\n\t\tset -x\n\t\treturn 0\n\telse\n\t\tset -x\n\t\treturn 1\n\tfi\n}\n\n#\n# Safe unload for env modules (even if it doesn't exist)\n#\nmodule_unload() {\n\tmodule=$1\n\tmodule unload \"${module}\" || true\n}\n\n#\n# try load cuda modules if nvidia driver is installed\n#\ntry_load_cuda_env() {\n\tnum_gpus=0\n\thave_cuda=no\n\thave_gdrcopy=no\n\tif [ -f \"/proc/driver/nvidia/version\" ]; then\n\t\thave_cuda=yes\n\t\thave_gdrcopy=yes\n\t\tmodule_load $CUDA_MODULE    || have_cuda=no\n\t\tmodule_load $GDRCOPY_MODULE || have_gdrcopy=no\n\t\tnum_gpus=$(nvidia-smi -L | wc -l)\n\tfi\n}\n\nunload_cuda_env() {\n\tmodule_unload $CUDA_MODULE\n\tmodule_unload $GDRCOPY_MODULE\n}\n\n#\n# Check whether this test should do a task with given index,\n# according to the parallel test execution parameters.\n#\nshould_do_task() {\n\tset +x\n\ttask=$1\n\tntasks=$2\n\ttasks_per_worker=$(( (ntasks + nworkers - 1) / nworkers ))\n\tmy_tasks_begin=$((tasks_per_worker * worker))\n\tmy_tasks_end=$((my_tasks_begin + tasks_per_worker))\n\n\t# set return value to 0 (success) iff ($my_tasks_begin <= $task < $my_tasks_end)\n\t[ $task -ge $my_tasks_begin ] && [ $task -lt $my_tasks_end ]\n\trc=$?\n\tset -x\n\treturn $rc\n}\n\n#\n# Do a given task only if the current worker is supposed to do it.\n#\ndo_distributed_task() {\n\tset +x\n\ttask=$1\n\tntasks=$2\n\tshift 2\n\tif should_do_task $task $ntasks\n\tthen\n\t\techo \"==== Running '$@' (task $task/$ntasks) ====\"\n\t\tset -x\n\t\t$@\n\telse\n\t\techo \"==== Skipping '$@' (task $task/$ntasks) ====\"\n\t\tset -x\n\tfi\n}\n\n#\n# Take a list of tasks, and return only the ones this worker should do\n#\nget_my_tasks() {\n\ttask_list=$@\n\tntasks=$(echo $task_list|wc -w)\n\ttask=0\n\tmy_task_list=\"\"\n\tfor item in $task_list\n\tdo\n\t\tshould_do_task $task $ntasks && my_task_list=\"$my_task_list $item\"\n\t\ttask=$((task + 1))\n\tdone\n\techo $my_task_list\n}\n\n#\n# Get list of active IB devices\n#\nget_active_ib_devices() {\n\tdevice_list=$(ibv_devinfo -l | tail -n +2 | sed -e 's/^[ \\t]*//' | head -n -1)\n\tfor ibdev in $device_list\n\tdo\n\t\tport=1\n\t\t(ibv_devinfo -d $ibdev -i $port | grep -q PORT_ACTIVE) && echo \"$ibdev:$port\" || true\n\tdone\n}\n\n#\n# Get list of active IP interfaces\n#\nget_active_ip_ifaces() {\n\tdevice_list=$(ip addr | awk '/state UP/ {print $2}' | sed s/://)\n\tfor netdev in ${device_list}\n\tdo\n\t\t(ip addr show ${netdev} | grep -q 'inet ') && echo ${netdev} || true\n\tdone\n}\n\n#\n# Get IP addr for a given IP iface\n# Argument is the IP iface\n#\nget_ifaddr() {\n\tiface=$1\n\techo $(ip addr show ${iface} | awk '/inet /{print $2}' | awk -F '/' '{print $1}')\n}\n\nget_rdma_device_ip_addr() {\n\tif [ ! -r /dev/infiniband/rdma_cm  ]\n\tthen\n\t\treturn\n\tfi\n\n\tif ! which ibdev2netdev >&/dev/null\n\tthen\n\t\treturn\n\tfi\n\n\tiface=`ibdev2netdev | grep Up | awk '{print $5}' | head -1`\n\tif [ -n \"$iface\" ]\n\tthen\n\t\tipaddr=$(get_ifaddr ${iface})\n\tfi\n\n\tif [ -z \"$ipaddr\" ]\n\tthen\n\t\t# if there is no inet (IPv4) address, escape\n\t\treturn\n\tfi\n\n\tibdev=`ibdev2netdev | grep $iface | awk '{print $1}'`\n\tnode_guid=`cat /sys/class/infiniband/$ibdev/node_guid`\n\tif [ $node_guid == \"0000:0000:0000:0000\" ]\n\tthen\n\t\treturn\n\tfi\n\n\techo $ipaddr\n}\n\n#\n# Prepare build environment\n#\nprepare() {\n\techo \" ==== Prepare ====\"\n\tenv\n\tcd ${WORKSPACE}\n\tif [ -d build-test ]\n\tthen\n\t\tchmod u+rwx build-test -R\n\t\trm -rf build-test\n\tfi\n\t./autogen.sh\n\tmkdir -p build-test\n\tcd build-test\n}\n\n#\n# Build documentation\n#\nbuild_docs() {\n\tdoxy_ready=0\n\tdoxy_target_version=\"1.8.11\"\n\tdoxy_version=\"$(doxygen --version)\" || true\n\n\t# Try load newer doxygen if native is older than 1.8.11\n\tif ! (echo $doxy_target_version; echo $doxy_version) | sort -CV\n\tthen\n\t\tif module_load tools/doxygen-1.8.11\n\t\tthen\n\t\t\tdoxy_ready=1\n\t\telse\n\t\t\techo \" doxygen was not found\"\n\t\tfi\n\telse\n\t\tdoxy_ready=1\n\tfi\n\n\tif [ $doxy_ready -eq 1 ]\n\tthen\n\t\techo \" ==== Build docs only ====\"\n\t\t../configure --prefix=$ucx_inst --with-docs-only\n\t\tmake_clean\n\t\t$MAKE  docs\n\t\tmake_clean # FIXME distclean does not work with docs-only\n\tfi\n}\n\n#\n# Building java docs\n#\nbuild_java_docs() {\n\techo \" ==== Building java docs ====\"\n\tif module_load dev/jdk && module_load dev/mvn\n\tthen\n\t\t../configure --prefix=$ucx_inst --with-java\n\t\t$MAKE -C ../build-test/bindings/java/src/main/native docs\n\t\tmodule unload dev/jdk\n\t\tmodule unload dev/mvn\n\telse\n\t\techo \"No jdk and mvn module, failed to build docs\".\n\tfi\n}\n\n#\n# Build without verbs\n#\nbuild_no_verbs() {\n\techo \"==== Build without IB verbs ====\"\n\t../contrib/configure-release --prefix=$ucx_inst --without-verbs\n\tmake_clean\n\t$MAKEP\n\tmake_clean distclean\n}\n\n#\n# Build without numa support check\n#\nbuild_disable_numa() {\n\techo \"==== Check --disable-numa compilation option ====\"\n\t../contrib/configure-release --prefix=$ucx_inst --disable-numa\n\tmake_clean\n\t$MAKEP\n\tmake_clean distclean\n}\n\n#\n# Build a package in release mode\n#\nbuild_release_pkg() {\n\techo \"==== Build release ====\"\n\t../contrib/configure-release\n\tmake_clean\n\t$MAKEP\n\t$MAKEP distcheck\n\n\t# Show UCX info\n\t./src/tools/info/ucx_info -s -f -c -v -y -d -b -p -w -e -uart -m 20M\n\n\tif [ -f /etc/redhat-release -o -f /etc/fedora-release ]; then\n\t\trpm_based=yes\n\telif [ `cat /etc/os-release | grep -i \"ubuntu\\|mint\"|wc -l` -gt 0 ]; then\n\t\trpm_based=no\n\telse\n\t\t# try rpm tool to detect distro\n\t\tset +e\n\t\tout=$(rpm -q rpm 2>/dev/null)\n\t\trc=$?\n\t\tset -e\n\t\trpm_based=yes\n\t\tif [[ $rc != 0 || \"$out\" == *\"not installed\"* ]]; then\n\t\t\trpm_based=no\n\t\tfi\n\tfi\n\n\tif [[ \"$rpm_based\" == \"no\" && -x /usr/bin/dpkg-buildpackage ]]; then\n\t\techo \"==== Build debian package ====\"\n\t\tdpkg-buildpackage -us -uc\n\telse\n\t\techo \"==== Build RPM ====\"\n\t\t../contrib/buildrpm.sh -s -b --nodeps --define \"_topdir $PWD\"\n\tfi\n\n\t# check that UCX version is present in spec file\n\tcd ${WORKSPACE}\n\t# extract version from configure.ac and convert to MAJOR.MINOR.PATCH representation\n\tversion=$(grep -P \"define\\S+ucx_ver\" configure.ac | awk '{print $2}' | sed 's,),,' | xargs echo | tr ' ' '.')\n\tif ! grep -q \"$version\" ucx.spec.in; then\n\t\techo \"Current UCX version ($version) is not present in ucx.spec.in changelog\"\n\t\texit 1\n\tfi\n\tcd -\n\n\tmake_clean distclean\n}\n\n#\n# Build with Intel compiler\n#\nbuild_icc() {\n\techo 1..1 > build_icc.tap\n\tif module_load intel/ics && icc -v\n\tthen\n\t\techo \"==== Build with Intel compiler ====\"\n\t\t../contrib/configure-devel --prefix=$ucx_inst CC=icc CXX=icpc\n\t\tmake_clean\n\t\t$MAKEP\n\t\tmake_clean distclean\n\t\techo \"==== Build with Intel compiler (clang) ====\"\n\t\t../contrib/configure-devel --prefix=$ucx_inst CC=clang CXX=clang++\n\t\tmake_clean\n\t\t$MAKEP\n\t\tmake_clean distclean\n\t\techo \"ok 1 - build successful \" >> build_icc.tap\n\telse\n\t\techo \"==== Not building with Intel compiler ====\"\n\t\techo \"ok 1 - # SKIP because Intel compiler not installed\" >> build_icc.tap\n\tfi\n\tmodule_unload intel/ics\n}\n\n#\n# Build with PGI compiler\n#\nbuild_pgi() {\n\techo 1..1 > build_pgi.tap\n\tpgi_test_file=$(mktemp ./XXXXXX).c\n\techo \"int main() {return 0;}\" > ${pgi_test_file}\n\n\tif module_load pgi/latest && pgcc18 --version && pgcc18 ${pgi_test_file} -o ${pgi_test_file}.out\n\tthen\n\t\techo \"==== Build with PGI compiler ====\"\n\t\t# PGI failed to build valgrind headers, disable it for now\n\t\t# TODO: Using non-default PGI compiler - pgcc18 which is going to be default\n\t\t#       in next versions.\n\t\t#       Switch to default CC compiler after pgcc18 is default for pgi module\n\t\t../contrib/configure-devel --prefix=$ucx_inst CC=pgcc18 --without-valgrind\n\t\tmake_clean\n\t\t$MAKEP\n\t\tmake_clean distclean\n\t\techo \"ok 1 - build successful \" >> build_pgi.tap\n\telse\n\t\techo \"==== Not building with PGI compiler ====\"\n\t\techo \"ok 1 - # SKIP because PGI compiler not installed\" >> build_pgi.tap\n\tfi\n\n\trm -rf ${pgi_test_file} ${pgi_test_file}.out\n\tmodule_unload pgi/latest\n}\n\n#\n# Build debug version\n#\nbuild_debug() {\n\techo \"==== Build with --enable-debug option ====\"\n\t../contrib/configure-devel --prefix=$ucx_inst --enable-debug --enable-examples\n\tmake_clean\n\t$MAKEP\n\tmake_clean distclean\n}\n\n#\n# Build prof\n#\nbuild_prof() {\n\techo \"==== Build configure-prof ====\"\n\t../contrib/configure-prof --prefix=$ucx_inst\n\tmake_clean\n\t$MAKEP\n\tmake_clean distclean\n}\n\n#\n# Build UGNI\n#\nbuild_ugni() {\n\techo 1..1 > build_ugni.tap\n\n\techo \"==== Build with cray-ugni ====\"\n\t#\n\t# Point pkg-config to contrib/cray-ugni-mock, and replace\n\t# PKG_CONFIG_TOP_BUILD_DIR with source dir, since the mock .pc files contain\n\t# relative paths.\n\t#\n\t../contrib/configure-devel --prefix=$ucx_inst --with-ugni \\\n\t\tPKG_CONFIG_PATH=$PKG_CONFIG_PATH:$PWD/../contrib/cray-ugni-mock \\\n\t\tPKG_CONFIG_TOP_BUILD_DIR=$PWD/..\n\tmake_clean\n\t$MAKEP\n\n\t# make sure UGNI transport is enabled\n\tgrep '#define HAVE_TL_UGNI 1' config.h\n\n\t$MAKE  distcheck\n\tmake_clean distclean\n\n\tmodule_unload dev/cray-ugni\n\techo \"ok 1 - build successful \" >> build_ugni.tap\n}\n\n#\n# Build CUDA\n#\nbuild_cuda() {\n\techo 1..1 > build_cuda.tap\n\tif module_load $CUDA_MODULE\n\tthen\n\t\tif module_load $GDRCOPY_MODULE\n\t\tthen\n\t\t\techo \"==== Build with enable cuda, gdr_copy ====\"\n\t\t\t../contrib/configure-devel --prefix=$ucx_inst --with-cuda --with-gdrcopy\n\t\t\tmake_clean\n\t\t\t$MAKEP\n\t\t\tmake_clean distclean\n\n\t\t\t../contrib/configure-release --prefix=$ucx_inst --with-cuda --with-gdrcopy\n\t\t\tmake_clean\n\t\t\t$MAKEP\n\t\t\tmake_clean distclean\n\t\t\tmodule unload $GDRCOPY_MODULE\n\t\tfi\n\n\t\techo \"==== Build with enable cuda, w/o gdr_copy ====\"\n\t\t../contrib/configure-devel --prefix=$ucx_inst --with-cuda --without-gdrcopy\n\t\tmake_clean\n\t\t$MAKEP\n\n\t\tmodule unload $CUDA_MODULE\n\n\t\techo \"==== Running test_link_map with cuda build but no cuda module ====\"\n\t\tenv UCX_HANDLE_ERRORS=bt ./test/apps/test_link_map\n\n\t\tmake_clean distclean\n\t\techo \"ok 1 - build successful \" >> build_cuda.tap\n\telse\n\t\techo \"==== Not building with cuda flags ====\"\n\t\techo \"ok 1 - # SKIP because cuda not installed\" >> build_cuda.tap\n\tfi\n\tunload_cuda_env\n}\n\n#\n# Build with clang compiler\n#\nbuild_clang() {\n\techo 1..1 > build_clang.tap\n\tif which clang > /dev/null 2>&1\n\tthen\n\t\techo \"==== Build with clang compiler ====\"\n\t\t../contrib/configure-devel --prefix=$ucx_inst CC=clang CXX=clang++\n\t\tmake_clean\n\t\t$MAKEP\n\t\t$MAKEP install\n\t\tUCX_HANDLE_ERRORS=bt,freeze UCX_LOG_LEVEL_TRIGGER=ERROR $ucx_inst/bin/ucx_info -d\n\t\tmake_clean distclean\n\t\techo \"ok 1 - build successful \" >> build_clang.tap\n\telse\n\t\techo \"==== Not building with clang compiler ====\"\n\t\techo \"ok 1 - # SKIP because clang not installed\" >> build_clang.tap\n\tfi\n}\n\n#\n# Build with gcc-latest module\n#\nbuild_gcc_latest() {\n\techo 1..1 > build_gcc_latest.tap\n\t#If the glibc version on the host is older than 2.14, don't run\n\t#check the glibc version with the ldd version since it comes with glibc\n\t#see https://www.linuxquestions.org/questions/linux-software-2/how-to-check-glibc-version-263103/\n\t#see https://benohead.com/linux-check-glibc-version/\n\t#see https://stackoverflow.com/questions/9705660/check-glibc-version-for-a-particular-gcc-compiler\n\tldd_ver=\"$(ldd --version | awk '/ldd/{print $NF}')\"\n\tif (echo \"2.14\"; echo $ldd_ver) | sort -CV\n\tthen\n\t\tif module_load dev/gcc-latest\n\t\tthen\n\t\t\techo \"==== Build with GCC compiler ($(gcc --version|head -1)) ====\"\n\t\t\t../contrib/configure-devel --prefix=$ucx_inst\n\t\t\tmake_clean\n\t\t\t$MAKEP\n\t\t\t$MAKEP install\n\t\t\tUCX_HANDLE_ERRORS=bt,freeze UCX_LOG_LEVEL_TRIGGER=ERROR $ucx_inst/bin/ucx_info -d\n\t\t\tmake_clean distclean\n\t\t\techo \"ok 1 - build successful \" >> build_gcc_latest.tap\n\t\t\tmodule unload dev/gcc-latest\n\t\telse\n\t\t\techo \"==== Not building with latest gcc compiler ====\"\n\t\t\techo \"ok 1 - # SKIP because dev/gcc-latest module is not available\" >> build_gcc_latest.tap\n\t\tfi\n\telse\n\t\techo \"==== Not building with gcc compiler ====\"\n\t\techo \"Required glibc version is too old ($ldd_ver)\"\n\t\techo \"ok 1 - # SKIP because glibc version is older than 2.14\" >> build_gcc_latest.tap\n\tfi\n}\n\n#\n# Install and check experimental headers\n#\nbuild_experimental_api() {\n\t# Experimental header file should not be installed by regular build\n\techo \"==== Install WITHOUT experimental API ====\"\n\t../contrib/configure-release --prefix=$ucx_inst\n\tmake_clean\n\t$MAKEP install\n\t! test -e $ucx_inst/include/ucp/api/ucpx.h\n\n\t# Experimental header file should be installed by --enable-experimental-api\n\techo \"==== Install WITH experimental API ====\"\n\t../contrib/configure-release --prefix=$ucx_inst --enable-experimental-api\n\tmake_clean\n\t$MAKEP install\n\ttest -e $ucx_inst/include/ucp/api/ucpx.h\n}\n\n#\n# Builds jucx\n#\nbuild_jucx() {\n\techo 1..1 > build_jucx.tap\n\tif module_load dev/jdk && module_load dev/mvn\n\tthen\n\t\techo \"==== Building JUCX bindings (java api for ucx) ====\"\n\t\t../contrib/configure-release --prefix=$ucx_inst --with-java\n\t\tmake_clean\n\t\t$MAKEP\n\t\t$MAKEP install\n\t\tmake_clean distclean\n\t\techo \"ok 1 - build successful \" >> build_jucx.tap\n\t\tmodule unload dev/jdk\n\t\tmodule unload dev/mvn\n\telse\n\t\techo \"==== No jdk and mvn modules ==== \"\n\t\techo \"ok 1 - # SKIP because dev/jdk and dev/mvn modules are not available\" >> build_jucx.tap\n\tfi\n}\n\n#\n# Build with armclang compiler\n#\nbuild_armclang() {\n\techo 1..1 > build_armclang.tap\n\tarmclang_test_file=$(mktemp ./XXXXXX).c\n\techo \"int main() {return 0;}\" > ${armclang_test_file}\n\tif module_load arm-compiler/latest && armclang --version && armclang ${armclang_test_file} -o ${armclang_test_file}.out\n\tthen\n\t\techo \"==== Build with armclang compiler ====\"\n\t\t../contrib/configure-devel --prefix=$ucx_inst CC=armclang CXX=armclang++\n\t\tmake_clean\n\t\t$MAKEP\n\t\t$MAKEP install\n\t\tUCX_HANDLE_ERRORS=bt,freeze UCX_LOG_LEVEL_TRIGGER=ERROR $ucx_inst/bin/ucx_info -d\n\t\tmake_clean distclean\n\t\techo \"ok 1 - build successful \" >> build_armclang.tap\n\telse\n\t\techo \"==== Not building with armclang compiler ====\"\n\t\techo \"ok 1 - # SKIP because armclang not installed\" >> build_armclang.tap\n\tfi\n\n\trm -rf ${armclang_test_file} ${armclang_test_file}.out\n\tmodule_unload arm-compiler/latest\n}\n\ncheck_inst_headers() {\n\techo 1..1 > inst_headers.tap\n\techo \"==== Testing installed headers ====\"\n\n\t../contrib/configure-release --prefix=$PWD/install\n\tmake_clean\n\t$MAKEP install\n\t../contrib/check_inst_headers.sh $PWD/install/include\n\tmake_clean distclean\n\n\techo \"ok 1 - build successful \" >> inst_headers.tap\n}\n\ncheck_make_distcheck() {\n\techo 1..1 > make_distcheck.tap\n\n\t# If the gcc version on the host is older than 4.8.5, don't run\n\t# due to a compiler bug that reproduces when building with gtest\n\t# https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61886\n\tif (echo \"4.8.5\"; gcc --version | head -1 | awk '{print $3}') | sort -CV\n\tthen\n\t\techo \"==== Testing make distcheck ====\"\n\t\tmake_clean && make_clean distclean\n\t\t../contrib/configure-release --prefix=$PWD/install\n\t\t$MAKEP DISTCHECK_CONFIGURE_FLAGS=\"--enable-gtest\" distcheck\n\telse\n\t\techo \"Not testing make distcheck: GCC version is too old ($(gcc --version|head -1))\"\n\tfi\n}\n\ncheck_config_h() {\n\techo 1..1 > check_config_h.tap\n\n\tsrcdir=$PWD/../src\n\n\t# Check if all .c files include config.h\n\techo \"==== Checking for config.h files in directory $srcdir ====\"\n\n\tmissing=`find $srcdir -name \\*.c -o -name \\*.cc | xargs grep -LP '\\#\\s*include\\s+\"config.h\"'`\n\n\tif [ `echo $missing | wc -w` -eq 0 ]\n\tthen\n\t\techo \"ok 1 - check successful \" >> check_config_h.tap\n\telse\n\t\techo \"Error: missing include config.h in files: $missing\"\n\t\texit 1\n\tfi\n}\n\n#\n# Expands a CPU list such as \"0-3,17\" to \"0 1 2 3 17\" (each cpu in a new line)\n#\nexpand_cpulist() {\n\tcpulist=$1\n\ttokens=$(echo ${cpulist} | tr ',' ' ')\n\tfor token in ${tokens}\n\tdo\n\t\t# if there is no '-', first and last would be equal\n\t\tfirst=$(echo ${token} | cut -d'-' -f1)\n\t\tlast=$( echo ${token} | cut -d'-' -f2)\n\n\t\tfor ((cpu=${first};cpu<=${last};++cpu))\n\t\tdo\n\t\t\techo ${cpu}\n\t\tdone\n\tdone\n}\n\n#\n# Get the N'th CPU that the current process can run on\n#\nslice_affinity() {\n\tn=$1\n\n\t# get affinity mask of the current process\n\tcompact_cpulist=$($AFFINITY bash -c 'taskset -cp $$' | cut -d: -f2)\n\tcpulist=$(expand_cpulist ${compact_cpulist})\n\n\techo \"${cpulist}\" | head -n $((n + 1)) | tail -1\n}\n\n#\n# `rename` has a binary and Perl flavors. Ubuntu comes with Perl one and\n# requires different usage.\n#\nrename_files() {\n\texpr=$1; shift\n\treplacement=$1; shift\n\tfiles=$*\n\tif rename --version | grep 'util-linux'; then\n\t\trename \"${expr}\" \"${replacement}\" $files\n\t\treturn\n\tfi\n\n\trename \"s/\\\\${expr}\\$/${replacement}/\" \"${files}\"\n}\n\nrun_client_server_app() {\n\ttest_name=$1\n\ttest_args=$2\n\tserver_addr_arg=$3\n\tkill_server=$4\n\terror_emulation=$5\n\n\tserver_port=$((10000 + EXECUTOR_NUMBER))\n\tserver_port_arg=\"-p $server_port\"\n\n\taffinity_server=$(slice_affinity 0)\n\taffinity_client=$(slice_affinity 1)\n\n\ttaskset -c $affinity_server ${test_name} ${test_args} ${server_port_arg} &\n\tserver_pid=$!\n\n\tsleep 15\n\n\tif [ $error_emulation -eq 1 ]\n\tthen\n\t\tset +Ee\n\tfi\n\n\ttaskset -c $affinity_client ${test_name} ${test_args} ${server_addr_arg} ${server_port_arg} &\n\tclient_pid=$!\n\n\twait ${client_pid}\n\n\tif [ $error_emulation -eq 1 ]\n\tthen\n\t\tset -eE\n\tfi\n\n\tif [ $kill_server -eq 1 ]\n\tthen\n\t\tkill -9 ${server_pid}\n\telse\n\t\twait ${server_pid}\n\tfi\n}\n\nrun_hello() {\n\tapi=$1\n\tshift\n\ttest_args=\"$@\"\n\ttest_name=${api}_hello_world\n\n\tif [ ! -x ${test_name} ]\n\tthen\n\t\t$MAKEP -C examples ${test_name}\n\tfi\n\n\t# set smaller timeouts so the test will complete faster\n\tif [[ ${test_args} == *\"-e\"* ]]\n\tthen\n\t\texport UCX_UD_TIMEOUT=15s\n\t\texport UCX_RC_TIMEOUT=1ms\n\t\texport UCX_RC_RETRY_COUNT=4\n\tfi\n\n\tif [[ ${test_args} == *\"-e\"* ]]\n\tthen\n\t\terror_emulation=1\n\telse\n\t\terror_emulation=0\n\tfi\n\n\trun_client_server_app \"./examples/${test_name}\" \"${test_args}\" \"-n $(hostname)\" 0 $error_emulation\n\n\tif [[ ${test_args} == *\"-e\"* ]]\n\tthen\n\t\tunset UCX_UD_TIMEOUT\n\t\tunset UCX_RC_TIMEOUT\n\t\tunset UCX_RC_RETRY_COUNT\n\tfi\n}\n\n#\n# Compile and run UCP hello world example\n#\nrun_ucp_hello() {\n\tif ./src/tools/info/ucx_info -e -u twe|grep ERROR\n\tthen\n\t\treturn # skip if cannot create ucp ep\n\tfi\n\n\tmem_types_list=\"host \"\n\n\tif [ \"X$have_cuda\" == \"Xyes\" ]\n\tthen\n\t\tmem_types_list+=\"cuda cuda-managed \"\n\tfi\n\n\tfor test_mode in -w -f -b -e\n\tdo\n\t\tfor mem_type in $mem_types_list\n\t\tdo\n\t\t\techo \"==== Running UCP hello world with mode ${test_mode} and \\\"${mem_type}\\\" memory type ====\"\n\t\t\trun_hello ucp ${test_mode} -m ${mem_type}\n\t\tdone\n\tdone\n\trm -f ./ucp_hello_world\n}\n\n#\n# Compile and run UCT hello world example\n#\nrun_uct_hello() {\n\tmem_types_list=\"host \"\n\n\tif [ \"X$have_cuda\" == \"Xyes\" ] && [ -f \"/sys/kernel/mm/memory_peers/nv_mem/version\" ]\n\tthen\n\t\tmem_types_list+=\"cuda-managed \"\n\t\tif [ -f \"/sys/kernel/mm/memory_peers/nv_mem/version\" ]\n\t\tthen\n\t\t\t# test RDMA GPUDirect\n\t\t\tmem_types_list+=\"cuda \"\n\t\tfi\n\tfi\n\n\tfor send_func in -i -b -z\n\tdo\n\t\tfor ucx_dev in $(get_active_ib_devices)\n\t\tdo\n\t\t\tfor mem_type in $mem_types_list\n\t\t\tdo\n\t\t\t\techo \"==== Running UCT hello world server on rc/${ucx_dev} with sending ${send_func} and \\\"${mem_type}\\\" memory type ====\"\n\t\t\t\trun_hello uct -d ${ucx_dev} -t \"rc_verbs\" ${send_func} -m ${mem_type}\n\t\t\tdone\n\t\tdone\n\t\tfor ucx_dev in $(get_active_ip_iface)\n\t\tdo\n\t\t\techo \"==== Running UCT hello world server on tcp/${ucx_dev} with sending ${send_func} ====\"\n\t\t\trun_hello uct -d ${ucx_dev} -t \"tcp\" ${send_func}\n\t\tdone\n\tdone\n\trm -f ./uct_hello_world\n}\n\nrun_client_server() {\n\ttest_name=ucp_client_server\n\n\tif [ ! -x ${test_name} ]\n\tthen\n\t\tgcc -o ${test_name} ${ucx_inst}/share/ucx/examples/${test_name}.c \\\n\t\t\t-lucp -lucs -I${ucx_inst}/include -L${ucx_inst}/lib \\\n\t\t\t-Wl,-rpath=${ucx_inst}/lib\n\tfi\n\n\tserver_ip=$(get_rdma_device_ip_addr)\n\tif [ \"$server_ip\" == \"\" ]\n\tthen\n\t\treturn\n\tfi\n\n\trun_client_server_app \"./${test_name}\" \"\" \"-a ${server_ip}\" 1 0\n}\n\nrun_ucp_client_server() {\n\techo \"==== Running UCP client-server  ====\"\n\trun_client_server\n\n\trm -f ./ucp_client_server\n}\n\nrun_io_demo() {\n\tserver_ip=$(get_rdma_device_ip_addr)\n\tif [ \"$server_ip\" == \"\" ]\n\tthen\n\t\treturn\n\tfi\n\n\techo \"==== Running UCP IO demo  ====\"\n\n\ttest_args=\"$@ -o write,read -d 128:4194304 -i 10000 -w 10\"\n\ttest_name=io_demo\n\n\tif [ ! -x ${test_name} ]\n\tthen\n\t\t$MAKEP -C test/apps/iodemo ${test_name}\n\tfi\n\n\texport UCX_SOCKADDR_CM_ENABLE=y\n\trun_client_server_app \"./test/apps/iodemo/${test_name}\" \"${test_args}\" \"${server_ip}\" 1 0\n\n\tunset UCX_SOCKADDR_CM_ENABLE\n\tmake_clean\n}\n\n#\n# Run UCX performance test\n# Note: If requested running with MPI, MPI has to be initialized before\n# The function accepts 0 (default value) or 1 that means launching w/ or w/o MPI\n#\nrun_ucx_perftest() {\n\tif [ $# -eq 0 ]\n\tthen\n\t\twith_mpi=0\n\telse\n\t\twith_mpi=$1\n\tfi\n\tucx_inst_ptest=$ucx_inst/share/ucx/perftest\n\n\t# hack for perftest, no way to override params used in batch\n\t# todo: fix in perftest\n\tsed -s 's,-n [0-9]*,-n 100,g' $ucx_inst_ptest/msg_pow2 | sort -R > $ucx_inst_ptest/msg_pow2_short\n\tcat $ucx_inst_ptest/test_types_uct |                sort -R > $ucx_inst_ptest/test_types_short_uct\n\tcat $ucx_inst_ptest/test_types_ucp | grep -v cuda | sort -R > $ucx_inst_ptest/test_types_short_ucp\n\n\tucx_perftest=\"$ucx_inst/bin/ucx_perftest\"\n\tuct_test_args=\"-b $ucx_inst_ptest/test_types_short_uct \\\n\t\t\t\t-b $ucx_inst_ptest/msg_pow2_short -w 1\"\n\n\tucp_test_args=\"-b $ucx_inst_ptest/test_types_short_ucp \\\n\t\t\t\t-b $ucx_inst_ptest/msg_pow2_short -w 1\"\n\n\t# IP ifaces\n\tip_ifaces=$(get_active_ip_ifaces)\n\n\t# shared memory, IB devices, IP ifaces\n\tdevices=\"memory $(get_active_ib_devices) ${ip_ifaces}\"\n\n\t# Run on all devices\n\tmy_devices=$(get_my_tasks $devices)\n\tfor ucx_dev in $my_devices\n\tdo\n\t\tif [[ $ucx_dev =~ .*mlx5.* ]]; then\n\t\t\topt_transports=\"-b $ucx_inst_ptest/transports\"\n\t\t\ttls=`awk '{print $3 }' $ucx_inst_ptest/transports | tr '\\n' ',' | sed -r 's/,$//; s/mlx5/x/g'`\n\t\t\tdev=$ucx_dev\n\t\telif [[ $ucx_dev =~ memory ]]; then\n\t\t\topt_transports=\"-x posix\"\n\t\t\ttls=\"shm\"\n\t\t\tdev=\"all\"\n\t\telif [[ \" ${ip_ifaces[*]} \" == *\" ${ucx_dev} \"* ]]; then\n\t\t\topt_transports=\"-x tcp\"\n\t\t\ttls=\"tcp\"\n\t\t\tdev=$ucx_dev\n\t\telse\n\t\t\topt_transports=\"-x rc_verbs\"\n\t\t\ttls=\"rc_v\"\n\t\t\tdev=$ucx_dev\n\t\tfi\n\n\t\techo \"==== Running ucx_perf kit on $ucx_dev ====\"\n\t\tif [ $with_mpi -eq 1 ]\n\t\tthen\n\t\t\t# Run UCT performance test\n\t\t\t$MPIRUN -np 2 $AFFINITY $ucx_perftest $uct_test_args -d $ucx_dev $opt_transports\n\n\t\t\t# Run UCP performance test\n\t\t\t$MPIRUN -np 2 -x UCX_NET_DEVICES=$dev -x UCX_TLS=$tls $AFFINITY $ucx_perftest $ucp_test_args\n\n\t\t\t# Run UCP performance test with 2 threads\n\t\t\t$MPIRUN -np 2 -x UCX_NET_DEVICES=$dev -x UCX_TLS=$tls $AFFINITY $ucx_perftest $ucp_test_args -T 2\n\t\telse\n\t\t\texport UCX_NET_DEVICES=$dev\n\t\t\texport UCX_TLS=$tls\n\n\t\t\t# Run UCT performance test\n\t\t\trun_client_server_app \"$ucx_perftest\" \"$uct_test_args -d ${ucx_dev} ${opt_transports}\" \\\n\t\t\t\t\t\t\t\t\"$(hostname)\" 0 0\n\n\t\t\t# Run UCP performance test\n\t\t\trun_client_server_app \"$ucx_perftest\" \"$ucp_test_args\" \"$(hostname)\" 0 0\n\n\t\t\t# Run UCP performance test with 2 threads\n\t\t\trun_client_server_app \"$ucx_perftest\" \"$ucp_test_args -T 2\" \"$(hostname)\" 0 0\n\n\t\t\tunset UCX_NET_DEVICES\n\t\t\tunset UCX_TLS\n\t\tfi\n\tdone\n\n\t# run cuda tests if cuda module was loaded and GPU is found\n\tif [ \"X$have_cuda\" == \"Xyes\" ]\n\tthen\n\t\ttls_list=\"all \"\n\t\tgdr_options=\"n \"\n\t\tif (lsmod | grep -q \"nv_peer_mem\")\n\t\tthen\n\t\t\techo \"GPUDirectRDMA module (nv_peer_mem) is present..\"\n\t\t\ttls_list+=\"rc,cuda_copy \"\n\t\t\tgdr_options+=\"y \"\n\t\tfi\n\n\t\tif  [ \"X$have_gdrcopy\" == \"Xyes\" ] && (lsmod | grep -q \"gdrdrv\")\n\t\tthen\n\t\t\techo \"GDRCopy module (gdrdrv) is present...\"\n\t\t\ttls_list+=\"rc,cuda_copy,gdr_copy \"\n\t\tfi\n\n\t\tif [ $num_gpus -gt 1 ]; then\n\t\t\texport CUDA_VISIBLE_DEVICES=$(($worker%$num_gpus)),$(($(($worker+1))%$num_gpus))\n\t\tfi\n\n\t\tcat $ucx_inst_ptest/test_types_ucp | grep cuda | sort -R > $ucx_inst_ptest/test_types_short_ucp\n\t\tsed -s 's,-n [0-9]*,-n 10 -w 1,g' $ucx_inst_ptest/msg_pow2 | sort -R > $ucx_inst_ptest/msg_pow2_short\n\n\t\techo \"==== Running ucx_perf with cuda memory====\"\n\n\t\tfor tls in $tls_list\n\t\tdo\n\t\t\tfor memtype_cache in y n\n\t\t\tdo\n\t\t\t\tfor gdr in $gdr_options\n\t\t\t\tdo\n\t\t\t\t\tif [ $with_mpi -eq 1 ]\n\t\t\t\t\tthen\n\t\t\t\t\t\t$MPIRUN -np 2 -x UCX_TLS=$tls -x UCX_MEMTYPE_CACHE=$memtype_cache \\\n\t\t\t\t\t\t\t\t\t -x UCX_IB_GPU_DIRECT_RDMA=$gdr $AFFINITY $ucx_perftest $ucp_test_args\n\t\t\t\t\telse\n\t\t\t\t\t\texport UCX_TLS=$tls\n\t\t\t\t\t\texport UCX_MEMTYPE_CACHE=$memtype_cache\n\t\t\t\t\t\texport UCX_IB_GPU_DIRECT_RDMA=$gdr\n\t\t\t\t\t\trun_client_server_app \"$ucx_perftest\" \"$ucp_test_args\" \"$(hostname)\" 0 0\n\t\t\t\t\t\tunset UCX_TLS\n\t\t\t\t\t\tunset UCX_MEMTYPE_CACHE\n\t\t\t\t\t\tunset UCX_IB_GPU_DIRECT_RDMA\n\t\t\t\t\tfi\n\t\t\t\tdone\n\t\t\tdone\n\t\tdone\n\n\t\tif [ $with_mpi -eq 1 ]\n\t\tthen\n\t\t\t$MPIRUN -np 2 -x UCX_TLS=self,shm,cma,cuda_copy $AFFINITY $ucx_perftest $ucp_test_args\n\t\t\t$MPIRUN -np 2 -x UCX_TLS=self,sm,cuda_ipc,cuda_copy $AFFINITY $ucx_perftest $ucp_test_args\n\t\t\t$MPIRUN -np 2 $AFFINITY $ucx_perftest $ucp_test_args\n\t\telse\n\t\t\texport UCX_TLS=self,shm,cma,cuda_copy\n\t\t\trun_client_server_app \"$ucx_perftest\" \"$ucp_test_args\" \"$(hostname)\" 0 0\n\t\t\tunset UCX_TLS\n\n\t\t\trun_client_server_app \"$ucx_perftest\" \"$ucp_test_args\" \"$(hostname)\" 0 0\n\t\tfi\n\n\t\t# Specifically test cuda_ipc for large message sizes\n\t        cat $ucx_inst_ptest/test_types_ucp | grep -v cuda | sort -R > $ucx_inst_ptest/test_types_cuda_ucp\n\t\tucp_test_args_large=\"-b $ucx_inst_ptest/test_types_cuda_ucp \\\n\t\t\t             -b $ucx_inst_ptest/msg_pow2_large -w 1\"\n\t\tif [ $with_mpi -eq 1 ]\n\t\tthen\n\t\t\tfor ipc_cache in y n\n\t\t\tdo\n\t\t\t\t$MPIRUN -np 2 -x UCX_TLS=self,sm,cuda_copy,cuda_ipc \\\n\t\t\t\t\t-x UCX_CUDA_IPC_CACHE=$ipc_cache $AFFINITY $ucx_perftest $ucp_test_args_large\n\t\t\tdone\n\t\telse\n\t\t\tfor ipc_cache in y n\n\t\t\tdo\n\t\t\t\texport UCX_TLS=self,sm,cuda_copy,cuda_ipc\n\t\t\t\texport UCX_CUDA_IPC_CACHE=$ipc_cache\n\t\t\t\trun_client_server_app \"$ucx_perftest\" \"$ucp_test_args_large\" \"$(hostname)\" 0 0\n\t\t\t\tunset UCX_TLS\n\t\t\t\tunset UCX_CUDA_IPC_CACHE\n\t\t\tdone\n\t\tfi\n\n\t\tunset CUDA_VISIBLE_DEVICES\n\tfi\n}\n\n#\n# Test malloc hooks with mpi\n#\ntest_malloc_hooks_mpi() {\n\tfor tname in malloc_hooks malloc_hooks_unmapped external_events flag_no_install\n\tdo\n\t\techo \"==== Running memory hook (${tname}) on MPI ====\"\n\t\t$MPIRUN -np 1 $AFFINITY ./test/mpi/test_memhooks -t $tname\n\tdone\n\n\techo \"==== Running memory hook (malloc_hooks) on MPI with LD_PRELOAD ====\"\n\tucm_lib=$PWD/src/ucm/.libs/libucm.so\n\tls -l $ucm_lib\n\t$MPIRUN -np 1 -x LD_PRELOAD=$ucm_lib $AFFINITY ./test/mpi/test_memhooks -t malloc_hooks\n}\n\n#\n# Run tests with MPI library\n#\nrun_mpi_tests() {\n\techo \"1..2\" > mpi_tests.tap\n\tif module_load hpcx-gcc && mpirun --version\n\tthen\n\t\t# Prevent our tests from using UCX libraries from hpcx module by prepending\n\t\t# our local library path first\n\t\texport LD_LIBRARY_PATH=${ucx_inst}/lib:$LD_LIBRARY_PATH\n\n\t\t../contrib/configure-release --prefix=$ucx_inst --with-mpi # TODO check in -devel mode as well\n\t\tmake_clean\n\t\t$MAKEP install\n\t\t$MAKEP installcheck # check whether installation is valid (it compiles examples at least)\n\n\t\tMPIRUN=\"mpirun \\\n\t\t\t\t--bind-to none \\\n\t\t\t\t-x UCX_ERROR_SIGNALS \\\n\t\t\t\t-x UCX_HANDLE_ERRORS \\\n\t\t\t\t-mca pml ob1 \\\n\t\t\t\t-mca btl tcp,self \\\n\t\t\t\t-mca btl_tcp_if_include lo \\\n\t\t\t\t-mca orte_allowed_exit_without_sync 1 \\\n\t\t\t\t-mca coll ^hcoll,ml\"\n\n\t\trun_ucx_perftest 1\n\t\techo \"ok 1 - ucx perftest\" >> mpi_tests.tap\n\n\t\ttest_malloc_hooks_mpi\n\t\techo \"ok 2 - malloc hooks\" >> mpi_tests.tap\n\n\t\tmake_clean distclean\n\n\t\tmodule unload hpcx-gcc\n\telse\n\t\techo \"==== Not running MPI tests ====\"\n\t\techo \"ok 1 - # SKIP because MPI not installed\" >> mpi_tests.tap\n\t\techo \"ok 2 - # SKIP because MPI not installed\" >> mpi_tests.tap\n\tfi\n}\n\nbuild_ucx_profiling() {\n\t# compile the profiling example code\n\tgcc -o ucx_profiling ../test/apps/profiling/ucx_profiling.c \\\n\t\t-lm -lucs -I${ucx_inst}/include -L${ucx_inst}/lib -Wl,-rpath=${ucx_inst}/lib\n}\n\n#\n# Test profiling infrastructure\n#\ntest_profiling() {\n\techo \"==== Running profiling example  ====\"\n\n\t# configure release mode, application profiling should work\n\t../contrib/configure-release --prefix=$ucx_inst\n\tmake_clean\n\t$MAKEP\n\t$MAKEP install\n\n\tbuild_ucx_profiling\n\n\tUCX_PROFILE_MODE=log UCX_PROFILE_FILE=ucx_jenkins.prof ./ucx_profiling\n\n\tUCX_READ_PROFILE=${ucx_inst}/bin/ucx_read_profile\n\t$UCX_READ_PROFILE -r ucx_jenkins.prof | grep \"printf\" -C 20\n\t$UCX_READ_PROFILE -r ucx_jenkins.prof | grep -q \"calc_pi\"\n\t$UCX_READ_PROFILE -r ucx_jenkins.prof | grep -q \"print_pi\"\n}\n\ntest_ucs_load() {\n\t../contrib/configure-release --prefix=$ucx_inst\n\tmake_clean\n\t$MAKEP\n\t$MAKEP install\n\n\tbuild_ucx_profiling\n\n\t# Make sure UCS library constructor does not call socket()\n\techo \"==== Running UCS library loading test ====\"\n\tstrace ./ucx_profiling &> strace.log\n\t! grep '^socket' strace.log\n}\n\ntest_ucs_dlopen() {\n\t$MAKEP\n\n\t# Make sure UCM is not unloaded\n\techo \"==== Running UCS dlopen test with memhooks ====\"\n\t./test/apps/test_ucs_dlopen\n\n\t# Test global config list integrity after loading/unloading of UCT\n\techo \"==== Running test_dlopen_cfg_print ====\"\n\t./test/apps/test_dlopen_cfg_print\n}\n\ntest_ucp_dlopen() {\n\t../contrib/configure-release --prefix=$ucx_inst\n\tmake_clean\n\t$MAKEP\n        $MAKEP install\n\n\t# Make sure UCP library, when opened with dlopen(), loads CMA module\n\tLIB_CMA=`find ${ucx_inst} -name libuct_cma.so.0`\n\tif [ -n \"$LIB_CMA\" ]\n\tthen\n\t\techo \"==== Running UCP library loading test ====\"\n\t\t./test/apps/test_ucp_dlopen # just to save output to log\n\t\t./test/apps/test_ucp_dlopen | grep 'cma/memory'\n\telse\n\t\techo \"==== Not running UCP library loading test ====\"\n\tfi\n}\n\ntest_memtrack() {\n\t../contrib/configure-devel --prefix=$ucx_inst\n\tmake_clean\n\t$MAKEP\n\n\techo \"==== Running memtrack test ====\"\n\tUCX_MEMTRACK_DEST=stdout ./test/gtest/gtest --gtest_filter=test_memtrack.sanity\n}\n\ntest_unused_env_var() {\n\t# We must create a UCP worker to get the warning about unused variables\n\techo \"==== Running ucx_info env vars test ====\"\n\tUCX_IB_PORTS=mlx5_0:1 ./src/tools/info/ucx_info -epw -u t | grep \"unused\" | grep -q \"UCX_IB_PORTS\"\n}\n\ntest_env_var_aliases() {\n\techo \"==== Running MLX5 env var aliases test ====\"\n\tif [[ `./src/tools/info/ucx_info -b | grep -P 'HW_TM *1$'` ]]\n\tthen\n\t\tvars=( \"TM_ENABLE\" \"TM_LIST_SIZE\" \"TX_MAX_BB\" )\n\t\tfor var in \"${vars[@]}\"\n\t\tdo\n\t\t\tfor tl in \"RC_MLX5\" \"DC_MLX5\"\n\t\t\tdo\n\t\t\t\tval=$(./src/tools/info/ucx_info -c | grep \"${tl}_${var}\" | cut -d'=' -f2)\n\t\t\t\tif [ -z $val ]\n\t\t\t\tthen\n\t\t\t\t\techo \"UCX_${tl}_${var} does not exist in UCX config\"\n\t\t\t\t\texit 1\n\t\t\t\tfi\n\t\t\t\t# To check that changing env var takes an effect,\n\t\t\t\t# create some value, which is different from the default.\n\t\t\t\tmagic_val=`echo $val | sed -e ' s/inf\\|auto/15/; s/n/swap/; s/y/n/; s/swap/y/; s/\\([0-9]\\)/\\11/'`\n\n\t\t\t\t# Check that both (tl name and common RC) aliases work\n\t\t\t\tfor var_alias in \"RC\" $tl\n\t\t\t\tdo\n\t\t\t\t\tvar_name=UCX_${var_alias}_${var}\n\t\t\t\t\tval_set=$(export $var_name=$magic_val; ./src/tools/info/ucx_info -c | grep \"${tl}_${var}\" | cut -d'=' -f2)\n\t\t\t\t\tif [ \"$val_set\" != \"$magic_val\" ]\n\t\t\t\t\tthen\n\t\t\t\t\t\techo \"Can't set $var_name\"\n\t\t\t\t\t\texit 1\n\t\t\t\t\tfi\n\t\t\t\tdone\n\t\t\tdone\n\t\tdone\n\telse\n\t\techo \"HW TM is not compiled in UCX\"\n\tfi\n}\n\ntest_malloc_hook() {\n\techo \"==== Running malloc hooks test ====\"\n\tif [ -x ./test/apps/test_tcmalloc ]\n\tthen\n\t\t./test/apps/test_tcmalloc\n\tfi\n}\n\ntest_jucx() {\n\techo \"==== Running jucx test ====\"\n\techo \"1..2\" > jucx_tests.tap\n\tiface=`ibdev2netdev | grep Up | awk '{print $5}' | head -1`\n\tif [ -z \"$iface\" ]\n        then\n\t\techo \"Failed to find active ib devices.\" >> jucx_tests.tap\n\t\treturn\n\telif module_load dev/jdk && module_load dev/mvn\n\tthen\n\t\tjucx_port=$((20000 + EXECUTOR_NUMBER))\n\t\texport JUCX_TEST_PORT=$jucx_port\n\t\texport UCX_MEM_EVENTS=no\n\t\t$MAKE -C bindings/java/src/main/native test\n\t        ifaces=`ibdev2netdev | grep Up | awk '{print $5}'`\n\t\tif [ -n \"$ifaces\" ]\n\t\tthen\n                        $MAKE -C bindings/java/src/main/native package\n\t\tfi\n\t\tfor iface in $ifaces\n\t\tdo\n\t\t\tif [ -n \"$iface\" ]\n                \tthen\n                   \t\tserver_ip=$(get_ifaddr ${iface})\n                \tfi\n\n                \tif [ -z \"$server_ip\" ]\n                \tthen\n\t\t   \t   \techo \"Interface $iface has no IPv4\"\n                   \t   \tcontinue\n                        fi\n                        echo \"Running standalone benchamrk on $iface\"\n\n                        java -XX:ErrorFile=$WORKSPACE/hs_err_${BUILD_NUMBER}_%p.log  \\\n                                -XX:OnError=\"cat $WORKSPACE/hs_err_${BUILD_NUMBER}_%p.log\" \\\n\t\t\t         -cp \"bindings/java/resources/:bindings/java/src/main/native/build-java/*\" \\\n\t\t\t\t org.openucx.jucx.examples.UcxReadBWBenchmarkReceiver \\\n\t\t\t\t s=$server_ip p=$JUCX_TEST_PORT &\n                        java_pid=$!\n\t\t\t sleep 10\n                        java -XX:ErrorFile=$WORKSPACE/hs_err_${BUILD_NUMBER}_%p.log \\\n\t\t\t\t -XX:OnError=\"cat $WORKSPACE/hs_err_${BUILD_NUMBER}_%p.log\" \\\n\t\t\t         -cp \"bindings/java/resources/:bindings/java/src/main/native/build-java/*\"  \\\n\t\t\t\t org.openucx.jucx.examples.UcxReadBWBenchmarkSender \\\n\t\t\t\t s=$server_ip p=$JUCX_TEST_PORT t=10000000\n\t\t\t wait $java_pid\n\t\tdone\n\n\t\tunset JUCX_TEST_PORT\n\t\tunset UCX_MEM_EVENTS\n\t\tmodule unload dev/jdk\n\t\tmodule unload dev/mvn\n\t\techo \"ok 1 - jucx test\" >> jucx_tests.tap\n\telse\n\t\techo \"Failed to load dev/jdk and dev/mvn modules.\" >> jucx_tests.tap\n\tfi\n}\n\n#\n# Run Coverity and report errors\n# The argument is a UCX build type: devel or release\n#\nrun_coverity() {\n\techo 1..1 > coverity.tap\n\tif module_load tools/cov\n\tthen\n\t\tucx_build_type=$1\n\n\t\techo \"==== Running coverity ====\"\n\t\t../contrib/configure-$ucx_build_type --prefix=$ucx_inst\n\t\tmake_clean\n\t\tcov_build_id=\"cov_build_${ucx_build_type}_${BUILD_NUMBER}\"\n\t\tcov_build=\"$WORKSPACE/$cov_build_id\"\n\t\trm -rf $cov_build\n\t\tcov-build --dir $cov_build $MAKEP all\n\t\tcov-analyze --jobs $parallel_jobs $COV_OPT --security --concurrency --dir $cov_build\n\t\tnerrors=$(cov-format-errors --dir $cov_build | awk '/Processing [0-9]+ errors?/ { print $2 }')\n\t\trc=$(($rc+$nerrors))\n\n\t\tindex_html=$(cd $cov_build && find . -name index.html | cut -c 3-)\n\t\tif [ -z \"$BUILD_URL\" ]; then\n\t\t\tcov_url=\"${WS_URL}/${cov_build_id}/${index_html}\"\n\t\telse\n\t\t\tcov_url=\"${BUILD_URL}/artifact/${cov_build_id}/${index_html}\"\n\t\tfi\n\t\trm -f jenkins_sidelinks.txt\n\t\tif [ $nerrors -gt 0 ]; then\n\t\t\tcov-format-errors --dir $cov_build --emacs-style\n\t\t\techo \"not ok 1 Coverity Detected $nerrors failures # $cov_url\" >> coverity.tap\n\t\telse\n\t\t\techo \"ok 1 Coverity found no issues\" >> coverity.tap\n\t\t\trm -rf $cov_build\n\t\tfi\n\n\t\techo Coverity report: $cov_url\n\t\tprintf \"%s\\t%s\\n\" Coverity $cov_url >> jenkins_sidelinks.txt\n\t\tmodule unload tools/cov\n\n\t\treturn $rc\n\telse\n\t\techo \"==== Not running Coverity ====\"\n\t\techo \"ok 1 - # SKIP because Coverity not installed\" >> coverity.tap\n\tfi\n}\n\nrun_gtest_watchdog_test() {\n\twatchdog_timeout=$1\n\tsleep_time=$2\n\texpected_runtime=$3\n\texpected_err_str=\"Connection timed out - abort testing\"\n\n\tmake -C test/gtest\n\n\tstart_time=`date +%s`\n\n\tenv WATCHDOG_GTEST_TIMEOUT_=$watchdog_timeout \\\n\t\tWATCHDOG_GTEST_SLEEP_TIME_=$sleep_time \\\n\t\tGTEST_FILTER=test_watchdog.watchdog_timeout \\\n\t\t./test/gtest/gtest 2>&1 | tee watchdog_timeout_test &\n\tpid=$!\n\twait $pid\n\n\tend_time=`date +%s`\n\n\tres=\"$(grep -x \"$expected_err_str\" watchdog_timeout_test)\" || true\n\n\trm -f watchdog_timeout_test\n\n\tif [ \"$res\" != \"$expected_err_str\" ]\n\tthen\n\t\techo \"didn't find [$expected_err_str] string in the test output\"\n\t\texit 1\n\tfi\n\n\truntime=$(($end_time-$start_time))\n\n\tif [ $runtime -gt $expected_runtime ]\n\tthen\n\t\techo \"Watchdog timeout test takes $runtime seconds that\" \\\n\t\t\t\"is greater than expected $expected_runtime seconds\"\n\t\texit 1\n\tfi\n}\n\n#\n# Run the test suite (gtest)\n# Arguments: <compiler-name> [configure-flags]\n#\nrun_gtest() {\n\tcompiler_name=$1\n\tshift\n\t../contrib/configure-devel --prefix=$ucx_inst $@\n\tmake_clean\n\t$MAKEP\n\n\techo \"==== Running watchdog timeout test, $compiler_name compiler ====\"\n\trun_gtest_watchdog_test 5 60 300\n\n\texport GTEST_SHARD_INDEX=$worker\n\texport GTEST_TOTAL_SHARDS=$nworkers\n\texport GTEST_RANDOM_SEED=0\n\texport GTEST_SHUFFLE=1\n\texport GTEST_TAP=2\n\texport GTEST_REPORT_DIR=$WORKSPACE/reports/tap\n\t# Run UCT tests for TCP over fastest device only\n\texport GTEST_UCT_TCP_FASTEST_DEV=1\n\t# Report TOP-20 longest test at the end of testing\n\texport GTEST_REPORT_LONGEST_TESTS=20\n\texport OMP_NUM_THREADS=4\n\n\tif [ $num_gpus -gt 0 ]; then\n\t\texport CUDA_VISIBLE_DEVICES=$(($worker%$num_gpus))\n\tfi\n\n\tGTEST_EXTRA_ARGS=\"\"\n\tif [ \"$JENKINS_TEST_PERF\" == 1 ]\n\tthen\n\t\t# Check performance with 10 retries and 2 seconds interval\n\t\tGTEST_EXTRA_ARGS=\"$GTEST_EXTRA_ARGS -p 10 -i 2.0\"\n\tfi\n\texport GTEST_EXTRA_ARGS\n\n\tmkdir -p $GTEST_REPORT_DIR\n\n\techo \"==== Running unit tests, $compiler_name compiler ====\"\n\t$AFFINITY $TIMEOUT make -C test/gtest test\n\t(cd test/gtest && rename_files .tap _gtest.tap *.tap && mv *.tap $GTEST_REPORT_DIR)\n\n\techo \"==== Running malloc hooks mallopt() test, $compiler_name compiler ====\"\n\t# gtest returns with non zero exit code if there were no\n\t# tests to run. As a workaround run a single test on every\n\t# shard.\n\t$AFFINITY $TIMEOUT \\\n\t\tenv UCX_IB_RCACHE=n \\\n\t\tMALLOC_TRIM_THRESHOLD_=-1 \\\n\t\tMALLOC_MMAP_THRESHOLD_=-1 \\\n\t\tGTEST_SHARD_INDEX=0 \\\n\t\tGTEST_TOTAL_SHARDS=1 \\\n\t\tGTEST_FILTER=malloc_hook_cplusplus.mallopt \\\n\t\tmake -C test/gtest test\n\t(cd test/gtest && rename_files .tap _mallopt_gtest.tap malloc_hook_cplusplus.tap && mv *.tap $GTEST_REPORT_DIR)\n\n\techo \"==== Running malloc hooks mmap_ptrs test with MMAP_THRESHOLD=16384, $compiler_name compiler ====\"\n\t$AFFINITY $TIMEOUT \\\n\t\tenv MALLOC_MMAP_THRESHOLD_=16384 \\\n\t\tGTEST_SHARD_INDEX=0 \\\n\t\tGTEST_TOTAL_SHARDS=1 \\\n\t\tGTEST_FILTER=malloc_hook_cplusplus.mmap_ptrs \\\n\t\tmake -C test/gtest test\n\t(cd test/gtest && rename_files .tap _mmap_ptrs_gtest.tap malloc_hook_cplusplus.tap && mv *.tap $GTEST_REPORT_DIR)\n\n\tif ! [[ $(uname -m) =~ \"aarch\" ]] && ! [[ $(uname -m) =~ \"ppc\" ]] && \\\n\t   ! [[ -n \"${JENKINS_NO_VALGRIND}\" ]]\n\tthen\n\t\techo \"==== Running valgrind tests, $compiler_name compiler ====\"\n\n\t\t# Load newer valgrind if naative is older than 3.10\n\t\tif ! (echo \"valgrind-3.10.0\"; valgrind --version) | sort -CV\n\t\tthen\n\t\t\tmodule load tools/valgrind-latest\n\t\tfi\n\n\t\t$AFFINITY $TIMEOUT_VALGRIND make -C test/gtest test_valgrind\n\t\t(cd test/gtest && rename_files .tap _vg.tap *.tap && mv *.tap $GTEST_REPORT_DIR)\n\t\tmodule unload tools/valgrind-latest\n\telse\n\t\techo \"==== Not running valgrind tests with $compiler_name compiler ====\"\n\t\techo \"1..1\"                                          > vg_skipped.tap\n\t\techo \"ok 1 - # SKIP because running on $(uname -m)\" >> vg_skipped.tap\n\tfi\n\n\tunset OMP_NUM_THREADS\n\tunset GTEST_UCT_TCP_FASTEST_DEV\n\tunset GTEST_SHARD_INDEX\n\tunset GTEST_TOTAL_SHARDS\n\tunset GTEST_RANDOM_SEED\n\tunset GTEST_SHUFFLE\n\tunset GTEST_TAP\n\tunset GTEST_REPORT_DIR\n\tunset GTEST_EXTRA_ARGS\n\tunset CUDA_VISIBLE_DEVICES\n}\n\nrun_gtest_default() {\n\trun_gtest \"default\"\n}\n\nrun_gtest_armclang() {\n\tif module_load arm-compiler/arm-hpc-compiler && armclang -v\n\tthen\n\t\trun_gtest \"armclang\" CC=armclang CXX=armclang++\n\telse\n\t\techo \"==== Not running with armclang compiler ====\"\n\t\techo \"1..1\"                                          > armclang_skipped.tap\n\t\techo \"ok 1 - # SKIP because armclang not found\"     >> armclang_skipped.tap\n\tfi\n\tmodule unload arm-compiler/arm-hpc-compiler\n}\n\n\n#\n# Run the test suite (gtest) in release configuration\n#\nrun_gtest_release() {\n\n\techo \"1..1\" > gtest_release.tap\n\n\t../contrib/configure-release --prefix=$ucx_inst --enable-gtest\n\tmake_clean\n\t$MAKEP\n\n\texport GTEST_SHARD_INDEX=0\n\texport GTEST_TOTAL_SHARDS=1\n\texport GTEST_RANDOM_SEED=0\n\texport GTEST_SHUFFLE=1\n\texport GTEST_TAP=2\n\texport GTEST_REPORT_DIR=$WORKSPACE/reports/tap\n\texport OMP_NUM_THREADS=4\n\n\techo \"==== Running unit tests (release configuration) ====\"\n\t# Check:\n\t# - Important object sizes\n\t# - Unexpected RNDV test, to cover rkey handling in tag offload flow\n\t#   (see GH #3827 for details)\n\tenv GTEST_FILTER=\\*test_obj_size\\*:\\*test_ucp_tag_match.rndv_rts_unexp\\* \\\n\t\t$AFFINITY $TIMEOUT make -C test/gtest test\n\techo \"ok 1\" >> gtest_release.tap\n\n\tunset OMP_NUM_THREADS\n\tunset GTEST_SHARD_INDEX\n\tunset GTEST_TOTAL_SHARDS\n\tunset GTEST_RANDOM_SEED\n\tunset GTEST_SHUFFLE\n\tunset GTEST_TAP\n\tunset GTEST_REPORT_DIR\n}\n\nrun_ucx_tl_check() {\n\n\techo \"1..1\" > ucx_tl_check.tap\n\n\t../test/apps/test_ucx_tls.py -p $ucx_inst\n\n\tif [ $? -ne 0 ]; then\n\t\techo \"not ok 1\" >> ucx_tl_check.tap\n\telse\n\t\techo \"ok 1\" >> ucx_tl_check.tap\n\tfi\n}\n\n#\n# Run all tests\n#\nrun_tests() {\n\texport UCX_HANDLE_ERRORS=freeze,bt\n\texport UCX_ERROR_SIGNALS=SIGILL,SIGSEGV,SIGBUS,SIGFPE,SIGPIPE,SIGABRT\n\texport UCX_ERROR_MAIL_TO=$ghprbActualCommitAuthorEmail\n\texport UCX_ERROR_MAIL_FOOTER=$JOB_URL/$BUILD_NUMBER/console\n\n\t# test cuda build if cuda modules available\n\tdo_distributed_task 2 4 build_cuda\n\n\t# load cuda env only if GPU available for remaining tests\n\ttry_load_cuda_env\n\n\tdo_distributed_task 0 4 build_icc\n\tdo_distributed_task 0 4 build_pgi\n\tdo_distributed_task 1 4 build_debug\n\tdo_distributed_task 1 4 build_prof\n\tdo_distributed_task 1 4 build_ugni\n\tdo_distributed_task 3 4 build_clang\n\tdo_distributed_task 0 4 build_armclang\n\tdo_distributed_task 1 4 build_gcc_latest\n\tdo_distributed_task 2 4 build_experimental_api\n\tdo_distributed_task 0 4 build_jucx\n\n\t# all are running mpi tests\n\trun_mpi_tests\n\n\tif module_load dev/jdk && module_load dev/mvn\n\tthen\n\t\t../contrib/configure-devel --prefix=$ucx_inst --with-java\n\telse\n\t\t../contrib/configure-devel --prefix=$ucx_inst\n\tfi\n\t$MAKEP\n\t$MAKEP install\n\n\trun_ucx_tl_check\n\n\tdo_distributed_task 1 4 run_ucp_hello\n\tdo_distributed_task 2 4 run_uct_hello\n\tdo_distributed_task 1 4 run_ucp_client_server\n\tdo_distributed_task 2 4 run_ucx_perftest\n\tdo_distributed_task 1 4 run_io_demo\n\tdo_distributed_task 3 4 test_profiling\n\tdo_distributed_task 0 3 test_jucx\n\tdo_distributed_task 1 4 test_ucs_dlopen\n\tdo_distributed_task 3 4 test_ucs_load\n\tdo_distributed_task 3 4 test_memtrack\n\tdo_distributed_task 0 4 test_unused_env_var\n\tdo_distributed_task 2 4 test_env_var_aliases\n\tdo_distributed_task 1 3 test_malloc_hook\n\tdo_distributed_task 0 4 test_ucp_dlopen\n\n\t# all are running gtest\n\trun_gtest_default\n\trun_gtest_armclang\n\n\tdo_distributed_task 3 4 run_coverity release\n\tdo_distributed_task 0 4 run_coverity devel\n\tdo_distributed_task 1 4 run_gtest_release\n}\n\nprepare\ntry_load_cuda_env\ndo_distributed_task 0 4 build_docs\ndo_distributed_task 0 4 build_java_docs\ndo_distributed_task 0 4 build_disable_numa\ndo_distributed_task 1 4 build_no_verbs\ndo_distributed_task 2 4 build_release_pkg\ndo_distributed_task 3 4 check_inst_headers\ndo_distributed_task 1 4 check_make_distcheck\ndo_distributed_task 2 4 check_config_h\nif [ -n \"$JENKINS_RUN_TESTS\" ] || [ -n \"$RUN_TESTS\" ]\nthen\n\trun_tests\nfi\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/.git/objects/pack/pack-0f47f55f3921e335951715271a730b95bb72bf75.pack",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/.git/objects/pack/pack-0f47f55f3921e335951715271a730b95bb72bf75.idx",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/docs/source/_static/ucxlogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/docs/source/_static/UCX_Layers.png",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/docs/doxygen/Architecture.png",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/docs/doxygen/Architecture.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/docs/doxygen/UCX_Logo_930x933.png",
        "/tmp/vanessa/spack-stage/spack-stage-ucx-1.9-dev-li4x2vqav4odyolcqylalut6u37elidt/spack-src/docs/doxygen/UCX_Logo_80x80.png"
    ],
    "total_files": 869
}