{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/numpy/_build_utils/src/apple_sgemv_fix.c": "/* This is a collection of ugly hacks to circumvent a bug in\n * Apple Accelerate framework's SGEMV subroutine.\n *\n * See: https://github.com/numpy/numpy/issues/4007\n *\n * SGEMV in Accelerate framework will segfault on MacOS X version 10.9\n * (aka Mavericks) if arrays are not aligned to 32 byte boundaries\n * and the CPU supports AVX instructions. This can produce segfaults\n * in np.dot.\n *\n * This patch overshadows the symbols cblas_sgemv, sgemv_ and sgemv\n * exported by Accelerate to produce the correct behavior. The MacOS X\n * version and CPU specs are checked on module import. If Mavericks and\n * AVX are detected the call to SGEMV is emulated with a call to SGEMM\n * if the arrays are not 32 byte aligned. If the exported symbols cannot\n * be overshadowed on module import, a fatal error is produced and the\n * process aborts. All the fixes are in a self-contained C file\n * and do not alter the multiarray C code. The patch is not applied\n * unless NumPy is configured to link with Apple's Accelerate\n * framework.\n *\n */\n\n#define NPY_NO_DEPRECATED_API NPY_API_VERSION\n#include \"Python.h\"\n#include \"numpy/arrayobject.h\"\n\n#include <string.h>\n#include <dlfcn.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/sysctl.h>\n#include <string.h>\n\n/* ----------------------------------------------------------------- */\n/* Original cblas_sgemv */\n\n#define VECLIB_FILE \"/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/vecLib\"\n\nenum CBLAS_ORDER {CblasRowMajor=101, CblasColMajor=102};\nenum CBLAS_TRANSPOSE {CblasNoTrans=111, CblasTrans=112, CblasConjTrans=113};\nextern void cblas_xerbla(int info, const char *rout, const char *form, ...);\n\ntypedef void cblas_sgemv_t(const enum CBLAS_ORDER order,\n                 const enum CBLAS_TRANSPOSE TransA, const int M, const int N,\n                 const float alpha, const float  *A, const int lda,\n                 const float  *X, const int incX,\n                 const float beta, float  *Y, const int incY);\n\ntypedef void cblas_sgemm_t(const enum CBLAS_ORDER order,\n                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB,\n                 const int M, const int N, const int K,\n                 const float alpha, const float  *A, const int lda,\n                 const float  *B, const int ldb,\n                 const float beta, float  *C, const int incC);\n\ntypedef void fortran_sgemv_t( const char* trans, const int* m, const int* n,\n             const float* alpha, const float* A, const int* ldA,\n             const float* X, const int* incX,\n             const float* beta, float* Y, const int* incY );\n\nstatic void *veclib = NULL;\nstatic cblas_sgemv_t *accelerate_cblas_sgemv = NULL;\nstatic cblas_sgemm_t *accelerate_cblas_sgemm = NULL;\nstatic fortran_sgemv_t *accelerate_sgemv = NULL;\nstatic int AVX_and_10_9 = 0;\n\n/* Dynamic check for AVX support\n * __builtin_cpu_supports(\"avx\") is available in gcc 4.8,\n * but clang and icc do not currently support it. */\nstatic inline int \ncpu_supports_avx() \n{\n    int enabled, r;\n    size_t length = sizeof(enabled);\n    r = sysctlbyname(\"hw.optional.avx1_0\", &enabled, &length, NULL, 0);\n    if ( r == 0 && enabled != 0) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\n\t\n/* Check if we are using MacOS X version 10.9 */\nstatic inline int \nusing_mavericks() \n{\n    int r;\n    char str[32] = {0};\n    size_t size = sizeof(str);\n    r = sysctlbyname(\"kern.osproductversion\", str, &size, NULL, 0);\n    if ( r == 0 && strncmp(str, \"10.9\", strlen(\"10.9\")) == 0) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\n\n__attribute__((destructor))\nstatic void unloadlib(void)\n{\n    if (veclib) dlclose(veclib);\n}\n\n__attribute__((constructor))\nstatic void loadlib()\n/* automatically executed on module import */\n{\n    char errormsg[1024];\n    int AVX, MAVERICKS;\n    memset((void*)errormsg, 0, sizeof(errormsg));\n    /* check if the CPU supports AVX */\n    AVX = cpu_supports_avx();\n    /* check if the OS is MacOS X Mavericks */\n    MAVERICKS = using_mavericks();\n    /* we need the workaround when the CPU supports\n     * AVX and the OS version is Mavericks */\n    AVX_and_10_9 = AVX && MAVERICKS;\n    /* load vecLib */\n    veclib = dlopen(VECLIB_FILE, RTLD_LOCAL | RTLD_FIRST);\n    if (!veclib) {\n        veclib = NULL;\n        snprintf(errormsg, sizeof(errormsg),\n                 \"Failed to open vecLib from location '%s'.\", VECLIB_FILE);\n        Py_FatalError(errormsg); /* calls abort() and dumps core */\n    }\n    /* resolve Fortran SGEMV from Accelerate */\n    accelerate_sgemv = (fortran_sgemv_t*) dlsym(veclib, \"sgemv_\");\n    if (!accelerate_sgemv) {\n        unloadlib();\n        Py_FatalError(\"Failed to resolve symbol 'sgemv_'.\");\n    }\n    /* resolve cblas_sgemv from Accelerate */\n    accelerate_cblas_sgemv = (cblas_sgemv_t*) dlsym(veclib, \"cblas_sgemv\");\n    if (!accelerate_cblas_sgemv) {\n        unloadlib();\n        Py_FatalError(\"Failed to resolve symbol 'cblas_sgemv'.\");\n    }\n    /* resolve cblas_sgemm from Accelerate */\n    accelerate_cblas_sgemm = (cblas_sgemm_t*) dlsym(veclib, \"cblas_sgemm\");\n    if (!accelerate_cblas_sgemm) {\n        unloadlib();\n        Py_FatalError(\"Failed to resolve symbol 'cblas_sgemm'.\");\n    }\n}\n\n/* ----------------------------------------------------------------- */\n/* Fortran SGEMV override */\n\nvoid sgemv_( const char* trans, const int* m, const int* n,\n             const float* alpha, const float* A, const int* ldA,\n             const float* X, const int* incX,\n             const float* beta, float* Y, const int* incY )\n{\n    /* It is safe to use the original SGEMV if we are not using AVX on Mavericks\n     * or the input arrays A, X and Y are all aligned on 32 byte boundaries. */\n    #define BADARRAY(x) (((npy_intp)(void*)x) % 32)\n    const int use_sgemm = AVX_and_10_9 && (BADARRAY(A) || BADARRAY(X) || BADARRAY(Y));\n    if (!use_sgemm) {\n        accelerate_sgemv(trans,m,n,alpha,A,ldA,X,incX,beta,Y,incY);\n        return;\n    }\n\n    /* Arrays are misaligned, the CPU supports AVX, and we are running\n     * Mavericks.\n     *\n     * Emulation of SGEMV with SGEMM:\n     *\n     * SGEMV allows vectors to be strided. SGEMM requires all arrays to be\n     * contiguous along the leading dimension. To emulate striding in SGEMV\n     * with the leading dimension arguments in SGEMM we compute\n     *\n     *    Y = alpha * op(A) @ X + beta * Y\n     *\n     * as\n     *\n     *    Y.T = alpha * X.T @ op(A).T + beta * Y.T\n     *\n     * Because Fortran uses column major order and X.T and Y.T are row vectors,\n     * the leading dimensions of X.T and Y.T in SGEMM become equal to the\n     * strides of the column vectors X and Y in SGEMV. */\n\n    switch (*trans) {\n        case 'T':\n        case 't':\n        case 'C':\n        case 'c':\n            accelerate_cblas_sgemm( CblasColMajor, CblasNoTrans, CblasNoTrans,\n                1, *n, *m, *alpha, X, *incX, A, *ldA, *beta, Y, *incY );\n            break;\n        case 'N':\n        case 'n':\n            accelerate_cblas_sgemm( CblasColMajor, CblasNoTrans, CblasTrans,\n                1, *m, *n, *alpha, X, *incX, A, *ldA, *beta, Y, *incY );\n            break;\n        default:\n            cblas_xerbla(1, \"SGEMV\", \"Illegal transpose setting: %c\\n\", *trans);\n    }\n}\n\n/* ----------------------------------------------------------------- */\n/* Override for an alias symbol for sgemv_ in Accelerate */\n\nvoid sgemv (char *trans,\n            const int *m, const int *n,\n            const float *alpha,\n            const float *A, const int *lda,\n            const float *B, const int *incB,\n            const float *beta,\n            float *C, const int *incC)\n{\n    sgemv_(trans,m,n,alpha,A,lda,B,incB,beta,C,incC);\n}\n\n/* ----------------------------------------------------------------- */\n/* cblas_sgemv override, based on Netlib CBLAS code */\n\nvoid cblas_sgemv(const enum CBLAS_ORDER order,\n                 const enum CBLAS_TRANSPOSE TransA, const int M, const int N,\n                 const float alpha, const float  *A, const int lda,\n                 const float  *X, const int incX, const float beta,\n                 float  *Y, const int incY)\n{\n    char TA;\n    if (order == CblasColMajor)\n    {\n        if (TransA == CblasNoTrans) TA = 'N';\n        else if (TransA == CblasTrans) TA = 'T';\n        else if (TransA == CblasConjTrans) TA = 'C';\n        else\n        {\n            cblas_xerbla(2, \"cblas_sgemv\",\"Illegal TransA setting, %d\\n\", TransA);\n        }\n        sgemv_(&TA, &M, &N, &alpha, A, &lda, X, &incX, &beta, Y, &incY);\n    }\n    else if (order == CblasRowMajor)\n    {\n        if (TransA == CblasNoTrans) TA = 'T';\n        else if (TransA == CblasTrans) TA = 'N';\n        else if (TransA == CblasConjTrans) TA = 'N';\n        else\n        {\n            cblas_xerbla(2, \"cblas_sgemv\", \"Illegal TransA setting, %d\\n\", TransA);\n            return;\n        }\n        sgemv_(&TA, &N, &M, &alpha, A, &lda, X, &incX, &beta, Y, &incY);\n    }\n    else\n        cblas_xerbla(1, \"cblas_sgemv\", \"Illegal Order setting, %d\\n\", order);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/numpy/random/_examples/cffi/extending.py": "\"\"\"\nUse cffi to access any of the underlying C functions from distributions.h\n\"\"\"\nimport os\nimport numpy as np\nimport cffi\nfrom .parse import parse_distributions_h\nffi = cffi.FFI()\n\ninc_dir = os.path.join(np.get_include(), 'numpy')\n\n# Basic numpy types\nffi.cdef('''\n    typedef intptr_t npy_intp;\n    typedef unsigned char npy_bool;\n\n''')\n\nparse_distributions_h(ffi, inc_dir)\n\nlib = ffi.dlopen(np.random._generator.__file__)\n\n# Compare the distributions.h random_standard_normal_fill to\n# Generator.standard_random\nbit_gen = np.random.PCG64()\nrng = np.random.Generator(bit_gen)\nstate = bit_gen.state\n\ninterface = rng.bit_generator.cffi\nn = 100\nvals_cffi = ffi.new('double[%d]' % n)\nlib.random_standard_normal_fill(interface.bit_generator, n, vals_cffi)\n\n# reset the state\nbit_gen.state = state\n\nvals = rng.standard_normal(n)\n\nfor i in range(n):\n    assert vals[i] == vals_cffi[i]\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/numpy/random/_examples/numba/extending_distributions.py": "r\"\"\"\nBuilding the required library in this example requires a source distribution\nof NumPy or clone of the NumPy git repository since distributions.c is not\nincluded in binary distributions.\n\nOn *nix, execute in numpy/random/src/distributions\n\nexport ${PYTHON_VERSION}=3.8 # Python version\nexport PYTHON_INCLUDE=#path to Python's include folder, usually \\\n    ${PYTHON_HOME}/include/python${PYTHON_VERSION}m\nexport NUMPY_INCLUDE=#path to numpy's include folder, usually \\\n    ${PYTHON_HOME}/lib/python${PYTHON_VERSION}/site-packages/numpy/core/include\ngcc -shared -o libdistributions.so -fPIC distributions.c \\\n    -I${NUMPY_INCLUDE} -I${PYTHON_INCLUDE}\nmv libdistributions.so ../../_examples/numba/\n\nOn Windows\n\nrem PYTHON_HOME and PYTHON_VERSION are setup dependent, this is an example\nset PYTHON_HOME=c:\\Anaconda\nset PYTHON_VERSION=38\ncl.exe /LD .\\distributions.c -DDLL_EXPORT \\\n    -I%PYTHON_HOME%\\lib\\site-packages\\numpy\\core\\include \\\n    -I%PYTHON_HOME%\\include %PYTHON_HOME%\\libs\\python%PYTHON_VERSION%.lib\nmove distributions.dll ../../_examples/numba/\n\"\"\"\nimport os\n\nimport numba as nb\nimport numpy as np\nfrom cffi import FFI\n\nfrom numpy.random import PCG64\n\nffi = FFI()\nif os.path.exists('./distributions.dll'):\n    lib = ffi.dlopen('./distributions.dll')\nelif os.path.exists('./libdistributions.so'):\n    lib = ffi.dlopen('./libdistributions.so')\nelse:\n    raise RuntimeError('Required DLL/so file was not found.')\n\nffi.cdef(\"\"\"\ndouble random_standard_normal(void *bitgen_state);\n\"\"\")\nx = PCG64()\nxffi = x.cffi\nbit_generator = xffi.bit_generator\n\nrandom_standard_normal = lib.random_standard_normal\n\n\ndef normals(n, bit_generator):\n    out = np.empty(n)\n    for i in range(n):\n        out[i] = random_standard_normal(bit_generator)\n    return out\n\n\nnormalsj = nb.jit(normals, nopython=True)\n\n# Numba requires a memory address for void *\n# Can also get address from x.ctypes.bit_generator.value\nbit_generator_address = int(ffi.cast('uintptr_t', bit_generator))\n\nnorm = normalsj(1000, bit_generator_address)\nprint(norm[:12])\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/reference/random/extending.rst": ".. currentmodule:: numpy.random\n\n.. _extending:\n\nExtending\n---------\nThe BitGenerators have been designed to be extendable using standard tools for\nhigh-performance Python -- numba and Cython.  The `~Generator` object can also\nbe used with user-provided BitGenerators as long as these export a small set of\nrequired functions.\n\nNumba\n=====\nNumba can be used with either CTypes or CFFI.  The current iteration of the\nBitGenerators all export a small set of functions through both interfaces.\n\nThis example shows how numba can be used to produce gaussian samples using\na pure Python implementation which is then compiled.  The random numbers are\nprovided by ``ctypes.next_double``.\n\n.. literalinclude:: ../../../../numpy/random/_examples/numba/extending.py\n    :language: python\n    :end-before: example 2\n\nBoth CTypes and CFFI allow the more complicated distributions to be used\ndirectly in Numba after compiling the file distributions.c into a ``DLL`` or\n``so``.  An example showing the use of a more complicated distribution is in\nthe `examples` section below.\n\n.. _random_cython:\n\nCython\n======\n\nCython can be used to unpack the ``PyCapsule`` provided by a BitGenerator.\nThis example uses `PCG64` and the example from above.  The usual caveats\nfor writing high-performance code using Cython -- removing bounds checks and\nwrap around, providing array alignment information -- still apply.\n\n.. literalinclude:: ../../../../numpy/random/_examples/cython/extending_distributions.pyx\n    :language: cython\n    :end-before: example 2\n\nThe BitGenerator can also be directly accessed using the members of the ``bitgen_t``\nstruct.\n\n.. literalinclude:: ../../../../numpy/random/_examples/cython/extending_distributions.pyx\n    :language: cython\n    :start-after: example 2\n    :end-before: example 3\n\nCython can be used to directly access the functions in\n``numpy/random/c_distributions.pxd``. This requires linking with the\n``npyrandom`` library located in ``numpy/random/lib``.\n\n.. literalinclude:: ../../../../numpy/random/_examples/cython/extending_distributions.pyx\n    :language: cython\n    :start-after: example 3\n\nSee :ref:`extending_cython_example` for the complete listings of these examples\nand a minimal ``setup.py`` to build the c-extension modules.\n\nCFFI\n====\n\nCFFI can be used to directly access the functions in\n``include/numpy/random/distributions.h``. Some \"massaging\" of the header\nfile is required:\n\n.. literalinclude:: ../../../../numpy/random/_examples/cffi/extending.py\n    :language: python\n    :end-before: dlopen\n\nOnce the header is parsed by ``ffi.cdef``, the functions can be accessed\ndirectly from the ``_generator`` shared object, using the `BitGenerator.cffi` interface.\n\n.. literalinclude:: ../../../../numpy/random/_examples/cffi/extending.py\n    :language: python\n    :start-after: dlopen\n\n\nNew Bit Generators\n==================\n`~Generator` can be used with user-provided `~BitGenerator`\\ s. The simplest\nway to write a new BitGenerator is to examine the pyx file of one of the\nexisting BitGenerators. The key structure that must be provided is the\n``capsule`` which contains a ``PyCapsule`` to a struct pointer of type\n``bitgen_t``,\n\n.. code-block:: c\n\n  typedef struct bitgen {\n    void *state;\n    uint64_t (*next_uint64)(void *st);\n    uint32_t (*next_uint32)(void *st);\n    double (*next_double)(void *st);\n    uint64_t (*next_raw)(void *st);\n  } bitgen_t;\n\nwhich provides 5 pointers. The first is an opaque pointer to the data structure\nused by the BitGenerators.  The next three are function pointers which return\nthe next 64- and 32-bit unsigned integers, the next random double and the next\nraw value.  This final function is used for testing and so can be set to\nthe next 64-bit unsigned integer function if not needed. Functions inside\n``Generator`` use this structure as in\n\n.. code-block:: c\n\n  bitgen_state->next_uint64(bitgen_state->state)\n\nExamples\n========\n\n.. toctree::\n    Numba <examples/numba>\n    CFFI + Numba <examples/numba_cffi> \n    Cython <examples/cython/index>\n    CFFI <examples/cffi>\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/numpy/lib/tests/data/python3.npy",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/numpy/lib/tests/data/win64python2.npy",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/numpy/lib/tests/data/py2-objarr.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/numpy/lib/tests/data/py3-objarr.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/numpy/lib/tests/data/py2-objarr.npy",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/numpy/lib/tests/data/py3-objarr.npy",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/numpy/core/tests/data/recarray_from_file.fits",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/numpy/core/tests/data/astype_copy.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/tools/allocation_tracking/sorttable.js",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/neps/_static/nep-0040_dtype-hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/neps/_static/nep0013_image3.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/neps/_static/nep0013_image2.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/neps/_static/nep0013_image1.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/neps/_static/nep-0000.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/scipy-sphinx-theme/_theme/scipy/static/img/scipy_org_logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/scipy-sphinx-theme/_theme/scipy/static/img/glyphicons-halflings.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/scipy-sphinx-theme/_theme/scipy/static/img/glyphicons-halflings-white.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/scipy-sphinx-theme/_static/scipyshiny_small.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/dev/pull_button.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/dev/gitwash/forking_button.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/_static/numpy_logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/reference/figures/dtype-hierarchy.dia",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/reference/figures/dtype-hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/reference/figures/dtype-hierarchy.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/reference/figures/threefundamental.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/reference/figures/threefundamental.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/theory.broadcast_4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/theory.broadcast_3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/theory.broadcast_1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/theory.broadcast_5.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/theory.broadcast_2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_MSE_formula.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_ones_zeros_random.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_pandas.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_transposing_reshaping.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_matrix_broadcasting.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_matrix_aggregation.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_MSE_explanation2.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_matrix_aggregation_row.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_readcsv.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_sub_mult_divide.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_array.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_multiply_broadcasting.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_mse_viz1.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_array_data_ones.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_create_array.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_ones_zeros_matrix.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_mse_viz2.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_matrix_arithmetic.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_MSE_explanation.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_create_matrix.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_array_dataones.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_MSE_implementation.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_aggregation.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_data_plus_ones.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_matrix_indexing.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_indexing.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.19.3-ztbm5f445nwys5mh6iunvy3z3rzeu3do/spack-src/doc/source/user/images/np_reshape.png"
    ],
    "total_files": 1338
}