{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-kcov-38-ddxhtubpsosofobjsm3xie2uvjhjpgyb/spack-src/src/solib-parser/lib.c": "#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\n#endif\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include <phdr_data.h>\n\nstatic struct phdr_data *phdr_data;\n\nstatic int phdrCallback(struct dl_phdr_info *info, size_t size, void *data)\n{\n\t// the first entry is used to determine the executable's \"base address\"\n\t// (which is actually the relocation for PIE)\n\tif (phdr_data->n_entries == 0)\n\t{\n\t\tphdr_data->relocation = info->dlpi_addr;\n\t}\n\n\tphdr_data_add(phdr_data, info);\n\n\treturn 0;\n}\n\nstatic int phdrSizeCallback(struct dl_phdr_info *info, size_t size, void *data)\n{\n\tsize_t *ps = (size_t *)data;\n\n\t*ps += sizeof(struct phdr_data_entry);\n\n\treturn 0;\n}\n\nstatic void parse_solibs(void)\n{\n\tchar *kcov_solib_path;\n\tvoid *p;\n\tssize_t written;\n\tsize_t allocSize;\n\tsize_t sz;\n\tint fd;\n\n\tkcov_solib_path = getenv(\"KCOV_SOLIB_PATH\");\n\tif (!kcov_solib_path)\n\t\treturn;\n\n\tallocSize = sizeof(struct phdr_data);\n\tdl_iterate_phdr(phdrSizeCallback, &allocSize);\n\n\tphdr_data = phdr_data_new(allocSize);\n\tif (!phdr_data)\n\t{\n\t\tfprintf(stderr, \"kcov-solib: Can't allocate %zu bytes\\n\", allocSize);\n\t\treturn;\n\t}\n\n\n\tdl_iterate_phdr(phdrCallback, NULL);\n\n\tp = phdr_data_marshal(phdr_data, &sz);\n\n\tfd = open(kcov_solib_path, O_WRONLY);\n\tif (fd < 0)\n\t{\n\t\tfprintf(stderr, \"kcov-solib: Can't open %s\\n\", kcov_solib_path);\n\t\treturn;\n\t}\n\twritten = write(fd, p, sz);\n\n\tif (written != sz)\n\t\tfprintf(stderr, \"kcov-solib: Can't write to solib FIFO (%zu)\\n\", written);\n\n\tphdr_data_free(p);\n\n\tclose(fd);\n}\n\nstatic void force_breakpoint(void)\n{\n\tasm volatile(\n#if defined(__i386__) || defined(__x86_64__)\n\t\t\t\"int3\\n\"\n#elif defined(__powerpc__)\n\t\t\t\".long 0x7fe00008\\n\" /* trap instruction */\n#elif defined(__arm__)\n\t\t\t\".long 0xfedeffe7\\n\" /* undefined insn */\n#elif defined(__aarch64__)\n\t\t\t\".long 0xd4200000\\n\" /* From https://github.com/scottt/debugbreak */\n#else\n# error Unsupported architecture\n#endif\n\t\t\t);\n}\n\nstatic void *(*orig_dlopen)(const char *, int);\nvoid *dlopen(const char *filename, int flag)\n{\n\tvoid *out;\n\n\tif (!orig_dlopen)\n\t\torig_dlopen = dlsym(RTLD_NEXT, \"dlopen\");\n\n\tout = orig_dlopen(filename, flag);\n\n\tparse_solibs();\n\tforce_breakpoint();\n\n\treturn out;\n}\n\n\nvoid  __attribute__((constructor))kcov_solib_at_startup(void)\n{\n\tparse_solibs();\n\tforce_breakpoint();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-kcov-38-ddxhtubpsosofobjsm3xie2uvjhjpgyb/spack-src/tests/CMakeLists.txt": "cmake_minimum_required (VERSION 2.8.4)\nproject (kcov-tests)\n\nenable_language(ASM)\n\nif (POLICY CMP0042)\n    # MACOSX_RPATH is enabled by default.\n    cmake_policy (SET CMP0042 NEW)\nendif (POLICY CMP0042)\n\nif (NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n    set (CMAKE_BUILD_TYPE Debug CACHE STRING\n        \"Choose the type of build, options are None Debug Release RelWithDebInfo MinSizeRel\"\n        FORCE\n    )\n    set_property (CACHE CMAKE_BUILD_TYPE PROPERTY\n        STRINGS None Debug Release RelWithDebInfo MinSizeRel\n    )\nendif (NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n\nset (CMAKE_THREAD_PREFER_PTHREAD ON)\nfind_package (Threads REQUIRED)\n\nfind_package (ZLIB REQUIRED)\n\nif (CMAKE_SYSTEM_NAME STREQUAL FreeBSD)\nset (DL_LIBRARY \"\")\nelse (CMAKE_SYSTEM_NAME STREQUAL FreeBSD)\nfind_library (DL_LIBRARY NAMES dl)\nif (DL_LIBRARY)\n    message (STATUS \"Found DL: ${DL_LIBRARY}\")\nelse (DL_LIBRARY)\n    message (FATAL_ERROR \"Could NOT find DL\")\nendif (DL_LIBRARY)\nendif (CMAKE_SYSTEM_NAME STREQUAL FreeBSD)\n\nfind_library (M_LIBRARY NAMES m)\nif (M_LIBRARY)\n    message (STATUS \"Found M: ${M_LIBRARY}\")\nelse (M_LIBRARY)\n    message (FATAL_ERROR \"Could NOT find M\")\nendif (M_LIBRARY)\n\ninclude_directories(\n    \"${CMAKE_CURRENT_BINARY_DIR}\"\n    ../src/include\n)\nset (CMAKE_CXX_FLAGS \"-std=c++0x -Wall -D_GLIBCXX_USE_NANOSLEEP -DKCOV_LIBRARY_PREFIX=${KCOV_LIBRARY_PREFIX}\")\n\nadd_custom_command (OUTPUT multi-fork-generated.c\n    COMMAND \"${CMAKE_CURRENT_SOURCE_DIR}/multi-fork/generate-functions.py\"\n            \"${CMAKE_CURRENT_SOURCE_DIR}/multi-fork/code-template.c\"\n            1024\n        > \"${CMAKE_CURRENT_BINARY_DIR}/multi-fork-generated.c\"\n    DEPENDS\n        \"${CMAKE_CURRENT_SOURCE_DIR}/multi-fork/generate-functions.py\"\n)\n\nadd_custom_target(multi-fork-generated ALL\n    DEPENDS multi-fork-generated.c\n)\nset_property(SOURCE multi-fork/test-multi-fork.c APPEND PROPERTY\n    OBJECT_DEPENDS \"${CMAKE_CURRENT_BINARY_DIR}/multi-fork-generated.c\"\n)\n\n\nset (main_tests_SRCS\n    main.cc\n    subdir/file.c\n    subdir2/file2.c\n)\n\nset (argv_dependent_SRCS\n    argv-dependent.c\n)\n\nset (fork_SRCS\n    fork/fork.c\n)\n\nset (fork_no_wait_SRCS\n    fork/fork-no-wait.c\n)\n\nset (signals_SRCS\n    signals/test-signals.c\n)\n\nset (multi_fork_SRCS\n    multi-fork/test-multi-fork.c\n)\n\nset (recursive-ptrace_SRCS\n    recursive-ptrace/main.cc\n)\n\nset (shared_library_test_SRCS\n    shared-library/main.c\n)\n\nset (test_popen_SRCS\n    popen/test-popen.c\n)\n\nset (global_constructors_SRCS\n    global-constructors/test-global-ctors.cc\n)\n\nset (daemon_SRCS\n    daemon/test-daemon.cc\n)\n\nadd_library(shared_library SHARED\n    shared-library/big-symbol.S\n    shared-library/solib.c\n)\n\nadd_executable(main-tests ${main_tests_SRCS})\nadd_executable(fork ${fork_SRCS})\nadd_executable(fork_no_wait ${fork_no_wait_SRCS})\nadd_executable(vfork fork/vfork.c)\nadd_executable(signals ${signals_SRCS})\n\nadd_executable(multi_fork ${multi_fork_SRCS})\ntarget_link_libraries(multi_fork \"${M_LIBRARY}\")\n\nadd_executable(shared_library_test ${shared_library_test_SRCS})\ntarget_link_libraries(shared_library_test shared_library)\n\nadd_executable(argv_dependent ${argv_dependent_SRCS})\nadd_executable(test_popen ${test_popen_SRCS})\n\nadd_executable(global-constructors ${global_constructors_SRCS})\ntarget_link_libraries(global-constructors shared_library)\n\nadd_executable(test_daemon ${daemon_SRCS})\nadd_executable(multi_1 merge-tests/file.c merge-tests/main_1.c)\nadd_executable(multi_2 merge-tests/file.c merge-tests/main_2.c)\n\nadd_executable(setpgid-kill setpgid-kill/setpgid-kill-main.cc ../src/utils.cc)\ntarget_link_libraries(setpgid-kill ${ZLIB_LIBRARIES})\n\nadd_executable(issue31 daemon/test-issue31.cc)\ntarget_link_libraries(issue31 ${CMAKE_THREAD_LIBS_INIT})\n\nadd_executable(dlopen dlopen/dlopen.cc dlopen/dlopen-main.cc)\ntarget_link_libraries(dlopen \"${DL_LIBRARY}\")\n\nadd_executable(s short-file.c)\nadd_executable(fork+exec fork/fork+exec.c)\n\nadd_executable(thread-test threads/thread-main.c)\ntarget_link_libraries(thread-test ${CMAKE_THREAD_LIBS_INIT})\n\n#if (CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n#    add_executable(sanitizer-coverage sanitizer-coverage.c)\n#    set_target_properties(sanitizer-coverage PROPERTIES COMPILE_FLAGS \"-g -fsanitize=address -fsanitize-coverage=bb\")\n#    set_target_properties(sanitizer-coverage PROPERTIES LINK_FLAGS \"-fsanitize=address -fsanitize-coverage=bb\")\n#endif (CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n\nadd_executable (pie pie.c)\nif (CMAKE_VERSION VERSION_LESS \"2.8.9\")\n    set_target_properties (pie PROPERTIES COMPILE_FLAGS -fPIE)\nelse (CMAKE_VERSION VERSION_LESS \"2.8.9\")\n    set_target_properties (pie PROPERTIES POSITION_INDEPENDENT_CODE ON)\nendif (CMAKE_VERSION VERSION_LESS \"2.8.9\")\n\nadd_executable (pie-test argv-dependent.c)\nif (CMAKE_VERSION VERSION_LESS \"2.8.9\")\n    set_target_properties (pie-test PROPERTIES COMPILE_FLAGS -fPIE)\nelse (CMAKE_VERSION VERSION_LESS \"2.8.9\")\n    set_target_properties (pie-test PROPERTIES POSITION_INDEPENDENT_CODE ON)\nendif (CMAKE_VERSION VERSION_LESS \"2.8.9\")\n\nif (NOT(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\"))\n    add_executable(recursive-ptrace ${recursive-ptrace_SRCS})\n    add_custom_target (illegal-insn ALL\n        COMMAND \"${CMAKE_C_COMPILER}\"\n            -nostdlib\n            \"${CMAKE_CURRENT_SOURCE_DIR}/assembly/illegal-insn.S\"\n            -o \"${CMAKE_CURRENT_BINARY_DIR}/illegal-insn\"\n    )\n\n    add_custom_target (fork-32 ALL\n        COMMAND \"${CMAKE_C_COMPILER}\" -g -m32\n            \"${CMAKE_CURRENT_SOURCE_DIR}/fork/fork.c\"\n            -o \"${CMAKE_CURRENT_BINARY_DIR}/fork-32\"\n    )\nendif (NOT(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\"))\n\nadd_custom_target(tests-stripped ALL\n    COMMAND \"${CMAKE_STRIP}\" -o tests-stripped main-tests\n    DEPENDS main-tests)\n",
        "/tmp/vanessa/spack-stage/spack-stage-kcov-38-ddxhtubpsosofobjsm3xie2uvjhjpgyb/spack-src/tests/dlopen/dlopen.cc": "#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid do_dlopen()\n{\n\tvoid *handle;\n\tint (*sym)(int);\n\n\thandle = dlopen(\"libshared_library.so\", RTLD_LAZY);\n\tif (!handle) {\n\t\tprintf(\"Can't dlopen\\n\");\n\t\texit(1);\n\t}\n\n\tdlerror();\n\tsym = (int (*)(int))dlsym(handle, \"vobb\");\n\tif (!sym) {\n\t\tprintf(\"No symbol\\n\");\n\t\tdlclose(handle);\n\t\texit(1);\n\t}\n\n\tint a = sym(5);\n\tprintf(\"from shared lib: %d\\n\", a);\n\n\tdlclose(handle);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-kcov-38-ddxhtubpsosofobjsm3xie2uvjhjpgyb/spack-src/tests/dlopen/dlopen-main.cc": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nextern void do_dlopen();\n\nint main(int argc, const char *argv[])\n{\n\tdo_dlopen();\n\tsleep(1);\n\n\treturn 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-kcov-38-ddxhtubpsosofobjsm3xie2uvjhjpgyb/spack-src/tests/tools/compiled.py": "import testbase\nimport unittest\nimport parse_cobertura\nimport sys\nimport os\n\nclass illegal_insn(testbase.KcovTestCase):\n    @unittest.skipIf(sys.platform.startswith(\"darwin\"), \"Not for OSX\")\n    def runTest(self):\n        self.setUp()\n        rv, output = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/illegal-insn\", False)\n        assert rv != 0\n        assert b'Illegal instructions are' in output\n\nclass fork_no_wait(testbase.KcovTestCase):\n    @unittest.skipIf(sys.platform.startswith(\"darwin\"), \"Not for OSX\")\n    def runTest(self):\n        self.setUp()\n        noKcovRv,o = self.do(testbase.testbuild + \"/fork_no_wait\", False)\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/fork_no_wait\", False)\n        assert rv == noKcovRv\n\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/fork_no_wait/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"fork-no-wait.c\", 20) >= 1\n        assert parse_cobertura.hitsPerLine(dom, \"fork-no-wait.c\", 22) >= 1\n        assert parse_cobertura.hitsPerLine(dom, \"fork-no-wait.c\", 24) >= 1\n\nclass ForkBase(testbase.KcovTestCase):\n    def doTest(self, binary):\n        self.setUp()\n        noKcovRv,o = self.do(testbase.testbuild + \"/\" + binary, False)\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/\" + binary, False)\n        assert rv == noKcovRv\n\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/\" + binary + \"/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"fork.c\", 21) == 0\n        assert parse_cobertura.hitsPerLine(dom, \"fork.c\", 26) >= 1\n        assert parse_cobertura.hitsPerLine(dom, \"fork.c\", 34) >= 1\n        assert parse_cobertura.hitsPerLine(dom, \"fork.c\", 37) >= 1\n        assert parse_cobertura.hitsPerLine(dom, \"fork.c\", 46) >= 1\n\nclass fork_64(ForkBase):\n    @unittest.skipIf(sys.platform.startswith(\"darwin\"), \"Not for OSX\")\n    def runTest(self):\n        self.doTest(\"fork\")\n\nclass fork_32(ForkBase):\n    @unittest.skipIf(sys.platform.startswith(\"darwin\"), \"Not for OSX\")\n    def runTest(self):\n        self.doTest(\"fork-32\")\n\nclass vfork(testbase.KcovTestCase):\n    def runTest(self):\n        self.setUp()\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/vfork\", False)\n        assert rv == 0\n\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/vfork/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"vfork.c\", 12) >= 1\n        assert parse_cobertura.hitsPerLine(dom, \"vfork.c\", 18) >= 1\n\nclass shared_library(testbase.KcovTestCase):\n    def runTest(self):\n        self.setUp()\n        noKcovRv,o = self.do(testbase.testbuild + \"/shared_library_test\", False)\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/shared_library_test\", False)\n        assert rv == noKcovRv\n\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/shared_library_test/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"main.c\", 9) >= 1\n        assert parse_cobertura.hitsPerLine(dom, \"solib.c\", 5) == 1\n\nclass shared_library_skip(testbase.KcovTestCase):\n    @unittest.skipIf(sys.platform.startswith(\"darwin\"), \"Not for OSX, Issue #157\")\n    def runTest(self):\n        self.setUp()\n        rv,o = self.do(testbase.kcov + \" --skip-solibs \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/shared_library_test\", False)\n        assert rv == 0\n\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/shared_library_test/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"main.c\", 9) == 1\n        assert parse_cobertura.hitsPerLine(dom, \"solib.c\", 5) == None\n\n\nclass shared_library_filter_out(testbase.KcovTestCase):\n    @unittest.skipIf(sys.platform.startswith(\"darwin\"), \"Not for OSX, Issue #157\")\n    def runTest(self):\n        self.setUp()\n        rv,o = self.do(testbase.kcov + \" --exclude-pattern=solib \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/shared_library_test\", False)\n        assert rv == 0\n\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/shared_library_test/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"main.c\", 9) == 1\n        assert parse_cobertura.hitsPerLine(dom, \"solib.c\", 5) == None\n\n\nclass shared_library_accumulate(testbase.KcovTestCase):\n    @unittest.skipIf(sys.platform.startswith(\"darwin\"), \"Not for OSX, Issue #157\")\n    def runTest(self):\n        self.setUp()\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/shared_library_test 5\", False)\n        assert rv == 0\n\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/shared_library_test/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"main.c\", 9) == 1\n        assert parse_cobertura.hitsPerLine(dom, \"solib.c\", 5) == 1\n        assert parse_cobertura.hitsPerLine(dom, \"solib.c\", 10) == 1\n\nclass MainTestBase(testbase.KcovTestCase):\n    def doTest(self, verify):\n        self.setUp()\n\n        noKcovRv,o = self.do(testbase.testbuild + \"/main-tests\", False)\n        rv,o = self.do(testbase.kcov + \" \" + verify + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/main-tests 5\", False)\n        assert rv == noKcovRv\n\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/main-tests/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"main.cc\", 9) == 1\n        assert parse_cobertura.hitsPerLine(dom, \"main.cc\", 14) == None\n        assert parse_cobertura.hitsPerLine(dom, \"main.cc\", 18) >= 1\n        assert parse_cobertura.hitsPerLine(dom, \"main.cc\", 25) == 1\n        assert parse_cobertura.hitsPerLine(dom, \"file.c\", 6) >= 1\n        assert parse_cobertura.hitsPerLine(dom, \"file2.c\", 7) == 0\n\n\nclass main_test(MainTestBase):\n    def runTest(self):\n        self.doTest(\"\")\n\nclass main_test_verify(MainTestBase):\n    def runTest(self):\n        self.doTest(\"--verify\")\n\nclass main_test_lldb_raw_breakpoints(MainTestBase):\n    def runTest(self):\n        self.doTest(\"--configure=lldb-use-raw-breakpoint-writes=1\")\n\nclass popen_test(testbase.KcovTestCase):\n    def runTest(self):\n        self.setUp()\n        noKcovRv,o = self.do(testbase.testbuild + \"/test_popen\", False)\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/test_popen\", False)\n        assert rv == noKcovRv\n\n        assert b\"popen OK\" in o\n\nclass short_filename(testbase.KcovTestCase):\n    @unittest.expectedFailure\n    def runTest(self):\n        self.setUp()\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov ./s\", False)\n        assert rv == 99\n\n\nclass Pie(testbase.KcovTestCase):\n    def runTest(self):\n        self.setUp()\n        noKcovRv,o = self.do(testbase.testbuild + \"/pie\", False)\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/pie\", False)\n        assert rv == noKcovRv\n\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/pie/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"pie.c\", 5) == 1\n\nclass pie_argv_basic(testbase.KcovTestCase):\n    def runTest(self):\n        self.setUp()\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/pie-test\", False)\n        assert rv == 0\n\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/pie-test/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"argv-dependent.c\", 5) == 1\n        assert parse_cobertura.hitsPerLine(dom, \"argv-dependent.c\", 11) == 0\n\nclass pie_accumulate(testbase.KcovTestCase):\n    def runTest(self):\n        self.setUp()\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/pie-test\", False)\n        assert rv == 0\n\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/pie-test/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"argv-dependent.c\", 5) == 1\n        assert parse_cobertura.hitsPerLine(dom, \"argv-dependent.c\", 11) == 0\n\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/pie-test a\", False)\n        assert rv == 0\n\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/pie-test/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"argv-dependent.c\", 5) == 1\n        assert parse_cobertura.hitsPerLine(dom, \"argv-dependent.c\", 11) == 1\n\n\nclass global_ctors(testbase.KcovTestCase):\n    def runTest(self):\n        self.setUp()\n        noKcovRv,o = self.do(testbase.testbuild + \"/global-constructors\", False)\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/global-constructors\", False)\n        assert rv == noKcovRv\n\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/global-constructors/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"test-global-ctors.cc\", 4) >= 1\n\nclass daemon_wait_for_last_child(testbase.KcovTestCase):\n    @unittest.skipIf(sys.platform.startswith(\"darwin\"), \"Not for OSX, Issue #158\")\n    def runTest(self):\n        self.setUp()\n        noKcovRv,o = self.do(testbase.testbuild + \"/test_daemon\", False)\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/test_daemon\", False)\n        assert rv == 4\n        assert noKcovRv == 2\n\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/test_daemon/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"test-daemon.cc\", 31) == 1\n\nclass SignalsBase(testbase.KcovTestCase):\n    def SignalsBase():\n        self.m_self = \"\";\n\n    def cmpOne(self, sig):\n        noKcovRv,o = self.do(testbase.testbuild + \"/signals \" + sig + \" \" + self.m_self, False)\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/signals \" + sig + \" \" + self.m_self, False)\n        assert rv == noKcovRv\n\n        return parse_cobertura.parseFile(testbase.outbase + \"/kcov/signals/cobertura.xml\")\n\n    def doTest(self):\n        self.setUp()\n\n        dom = self.cmpOne(\"hup\")\n        assert parse_cobertura.hitsPerLine(dom, \"test-signals.c\", 14) == 1\n\n        dom = self.cmpOne(\"int\")\n        assert parse_cobertura.hitsPerLine(dom, \"test-signals.c\", 19) == 1\n\n        dom = self.cmpOne(\"quit\")\n        assert parse_cobertura.hitsPerLine(dom, \"test-signals.c\", 24) == 1\n\n        dom = self.cmpOne(\"bus\")\n        assert parse_cobertura.hitsPerLine(dom, \"test-signals.c\", 44) == 1\n\n        dom = self.cmpOne(\"fpe\")\n        assert parse_cobertura.hitsPerLine(dom, \"test-signals.c\", 49) == 1\n\n        dom = self.cmpOne(\"term\")\n        assert parse_cobertura.hitsPerLine(dom, \"test-signals.c\", 84) == 1\n\nclass signals(SignalsBase):\n    @unittest.skipIf(sys.platform.startswith(\"darwin\"), \"Not for OSX, Issue #158\")\n\n    def runTest(self):\n        self.m_self = \"\"\n        self.doTest()\n\nclass signals_self(SignalsBase):\n\n    def runTest(self):\n        self.m_self = \"self\"\n        self.doTest()\n\nclass signals_crash(testbase.KcovTestCase):\n    def runTest(self):\n        self.setUp()\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/signals segv self\", False)\n        assert b\"kcov: Process exited with signal 11\" in o\n\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/signals abrt self\", False)\n        assert b\"kcov: Process exited with signal 6\" in o\n\nclass collect_and_report_only(testbase.KcovTestCase):\n    # Cannot work with combined Engine / Parser\n    @unittest.skipIf(sys.platform.startswith(\"darwin\"), \"Not for OSX\")\n    def runTest(self):\n        self.setUp()\n        noKcovRv,o = self.do(testbase.testbuild + \"/main-tests \", False)\n        rv,o = self.do(testbase.kcov + \" --collect-only \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/main-tests\", False)\n        assert rv == noKcovRv\n\n        try:\n            dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/main-tests/cobertura.xml\")\n            self.fail(\"File unexpectedly found\")\n        except:\n            # Exception is expected here\n            pass\n\n        rv,o = self.do(testbase.kcov + \" --report-only \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/main-tests\", False)\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/main-tests/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"main.cc\", 9) == 1\n\nclass setpgid_kill(testbase.KcovTestCase):\n    def runTest(self):\n        self.setUp()\n        noKcovRv,o = self.do(testbase.sources + \"/tests/setpgid-kill/test-script.sh \" + testbase.testbuild + \"/setpgid-kill\", False)\n        assert b\"SUCCESS\" in o\n        rv,o = self.do(testbase.sources + \"/tests/setpgid-kill/test-script.sh \" + testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/setpgid-kill\", False)\n        assert b\"SUCCESS\" in o\n\nclass attach_process_with_threads(testbase.KcovTestCase):\n    @unittest.skipIf(sys.platform.startswith(\"darwin\"), \"Not for OSX\")\n    def runTest(self):\n        self.setUp()\n        rv,o = self.do(testbase.sources + \"/tests/daemon/test-script.sh \" + testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/issue31\", False)\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/issue31/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"test-issue31.cc\", 28) >= 1\n        assert parse_cobertura.hitsPerLine(dom, \"test-issue31.cc\", 11) >= 1\n        assert parse_cobertura.hitsPerLine(dom, \"test-issue31.cc\", 9) == 0\n\nclass attach_process_with_threads_creates_threads(testbase.KcovTestCase):\n    @unittest.skipIf(sys.platform.startswith(\"darwin\"), \"Not for OSX\")\n    def runTest(self):\n        self.setUp()\n        rv,o = self.do(testbase.sources + \"/tests/daemon/test-script.sh \" + testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/thread-test\", False)\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/thread-test/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"thread-main.c\", 21) >= 1\n        assert parse_cobertura.hitsPerLine(dom, \"thread-main.c\", 9) >= 1\n\nclass merge_same_file_in_multiple_binaries(testbase.KcovTestCase):\n    def runTest(self):\n        self.setUp()\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/multi_1\", False)\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/multi_1/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"main_1.c\", 10) == 0\n        assert parse_cobertura.hitsPerLine(dom, \"file.c\", 3) == 0\n\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/multi_2\", False)\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/kcov-merged/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"main_2.c\", 9) == 1\n        assert parse_cobertura.hitsPerLine(dom, \"file.c\", 3) == 0\n        assert parse_cobertura.hitsPerLine(dom, \"file.c\", 8) == 0\n\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/multi_2 1\", False)\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/kcov-merged/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"file.c\", 3) == 0\n        assert parse_cobertura.hitsPerLine(dom, \"file.c\", 8) == 1\n\n\nclass debuglink(testbase.KcovTestCase):\n    @unittest.skipIf(sys.platform.startswith(\"darwin\"), \"Not for OSX\")\n    def runTest(self):\n        self.setUp()\n        os.system(\"rm -rf %s/.debug\" % (testbase.outbase))\n        os.system(\"cp %s/main-tests %s/main-tests-debug-file\" % (testbase.testbuild, testbase.testbuild))\n        os.system(\"objcopy --only-keep-debug %s/main-tests-debug-file %s/main-tests-debug-file.debug\" % (testbase.testbuild, testbase.testbuild))\n        os.system(\"cp %s/main-tests-debug-file.debug %s/main-tests-debug-file1.debug\" % (testbase.testbuild, testbase.testbuild))\n        os.system(\"cp %s/main-tests-debug-file.debug %s/main-tests-debug-file12.debug\" % (testbase.testbuild, testbase.testbuild))\n        os.system(\"cp %s/main-tests-debug-file.debug %s/main-tests-debug-file123.debug\" % (testbase.testbuild, testbase.testbuild))\n        os.system(\"cp %s/main-tests-debug-file %s/main-tests-debug-file1\" % (testbase.testbuild, testbase.testbuild))\n        os.system(\"cp %s/main-tests-debug-file %s/main-tests-debug-file2\" % (testbase.testbuild, testbase.testbuild))\n        os.system(\"cp %s/main-tests-debug-file %s/main-tests-debug-file3\" % (testbase.testbuild, testbase.testbuild))\n        os.system(\"strip -g %s/main-tests-debug-file\" % (testbase.testbuild))\n        os.system(\"strip -g %s/main-tests-debug-file1\" % (testbase.testbuild))\n        os.system(\"strip -g %s/main-tests-debug-file2\" % (testbase.testbuild))\n        os.system(\"strip -g %s/main-tests-debug-file3\" % (testbase.testbuild))\n        os.system(\"objcopy --add-gnu-debuglink=%s/main-tests-debug-file.debug %s/main-tests-debug-file\" % (testbase.testbuild, testbase.testbuild))\n        os.system(\"objcopy --add-gnu-debuglink=%s/main-tests-debug-file1.debug %s/main-tests-debug-file1\" % (testbase.testbuild, testbase.testbuild))\n        os.system(\"objcopy --add-gnu-debuglink=%s/main-tests-debug-file12.debug %s/main-tests-debug-file2\" % (testbase.testbuild, testbase.testbuild))\n        os.system(\"objcopy --add-gnu-debuglink=%s/main-tests-debug-file123.debug %s/main-tests-debug-file3\" % (testbase.testbuild, testbase.testbuild))\n\n        noKcovRv,o = self.do(testbase.testbuild + \"/main-tests-debug-file\", False)\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/main-tests-debug-file\", False)\n        assert rv == noKcovRv\n\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/main-tests-debug-file/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"main.cc\", 9) == 1\n\n        # Check alignment\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/main-tests-debug-file1\", False)\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/main-tests-debug-file1/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"main.cc\", 9) == 1\n\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/main-tests-debug-file2\", False)\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/main-tests-debug-file2/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"main.cc\", 9) == 1\n\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/main-tests-debug-file3\", False)\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/main-tests-debug-file3/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"main.cc\", 9) == 1\n\n        # Look in .debug\n        os.system(\"rm -rf %s/kcov\" % (testbase.outbase))\n        os.system(\"mkdir -p %s/.debug\" % (testbase.testbuild))\n        os.system(\"mv %s/main-tests-debug-file.debug %s/.debug\" % (testbase.testbuild, testbase.testbuild))\n\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/main-tests-debug-file\", False)\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/main-tests-debug-file/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"main.cc\", 9) == 1\n\n        os.system(\"rm -rf %s/kcov\" % (testbase.outbase))\n        os.system(\"echo 'abc' >> %s/.debug/main-tests-debug-file.debug\" % (testbase.testbuild))\n\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/main-tests-debug-file\", False)\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/main-tests-debug-file/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"main.cc\", 9) == None\n\t# Todo: Look in /usr/lib/debug as well\n\nclass collect_no_source(testbase.KcovTestCase):\n    @unittest.expectedFailure\n    def runTest(self):\n        self.setUp()\n\n        os.system(\"cp %s/tests/short-file.c %s/main.cc\" % (testbase.sources, testbase.testbuild))\n        os.system(\"gcc -g -o %s/main-collect-only %s/main.cc\" % (testbase.testbuild, testbase.testbuild))\n        os.system(\"mv %s/main.cc %s/tmp-main.cc\" % (testbase.testbuild, testbase.testbuild))\n\n        rv,o = self.do(testbase.kcov + \" --collect-only \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/main-collect-only\", False)\n\n        os.system(\"mv %s/tmp-main.cc %s/main.cc\" % (testbase.testbuild, testbase.testbuild))\n        rv,o = self.do(testbase.kcov + \" --report-only \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/main-collect-only\")\n\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/main-collect-only/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"main.cc\", 1) == 1\n\nclass dlopen(testbase.KcovTestCase):\n    @unittest.expectedFailure\n    def runTest(self):\n        self.setUp()\n        noKcovRv,o = self.do(testbase.testbuild + \"/dlopen\", False)\n        rv,o = self.do(testbase.kcov + \" \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/dlopen\", False)\n\n        assert noKcovRv == rv\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/dlopen/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"dlopen.cc\", 11) == 1\n        assert parse_cobertura.hitsPerLine(dom, \"dlopen.cc\", 12) == 0\n        assert parse_cobertura.hitsPerLine(dom, \"solib.c\", 5) == 1\n        assert parse_cobertura.hitsPerLine(dom, \"solib.c\", 12) == 0\n\n\nclass dlopen_in_ignored_source_file(testbase.KcovTestCase):\n    @unittest.expectedFailure\n    def runTest(self):\n        self.setUp()\n        rv,o = self.do(testbase.kcov + \" --exclude-pattern=dlopen.cc \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/dlopen\", False)\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/dlopen/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"dlopen-main.cc\", 10) == 1\n        assert parse_cobertura.hitsPerLine(dom, \"solib.c\", 5) == 1\n        assert parse_cobertura.hitsPerLine(dom, \"solib.c\", 12) == 0\n\nclass daemon_no_wait_for_last_child(testbase.KcovTestCase):\n    @unittest.skipIf(sys.platform.startswith(\"darwin\"), \"Not for OSX\")\n    @unittest.expectedFailure\n    def runTest(self):\n        self.setUp()\n        noKcovRv,o = self.do(testbase.testbuild + \"/test_daemon\", False)\n        rv,o = self.do(testbase.kcov + \" --output-interval=1 --exit-first-process \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/test_daemon\", False)\n\n        assert noKcovRv == rv\n        time.sleep(2)\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/test_daemon/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"test-daemon.cc\", 31) == 0\n\n        time.sleep(5)\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/test_daemon/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"test-daemon.cc\", 31) == 1\n\n\nclass address_sanitizer_coverage(testbase.KcovTestCase):\n    @unittest.skipIf(sys.platform.startswith(\"darwin\"), \"Not for OSX\")\n    @unittest.expectedFailure\n    def runTest(self):\n        self.setUp()\n        if (not os.path.isfile(testbase.testbuild + \"/sanitizer-coverage\")):\n            print(\"Clang-only\")\n            assert False\n        rv,o = self.do(testbase.kcov + \" --clang \" + testbase.outbase + \"/kcov \" + testbase.testbuild + \"/sanitizer-coverage\", False)\n\n        dom = parse_cobertura.parseFile(testbase.outbase + \"/kcov/sanitizer-coverage/cobertura.xml\")\n        assert parse_cobertura.hitsPerLine(dom, \"sanitizer-coverage.c\", 5) == 1\n        assert parse_cobertura.hitsPerLine(dom, \"sanitizer-coverage.c\", 7) == 1\n        assert parse_cobertura.hitsPerLine(dom, \"sanitizer-coverage.c\", 8) == 1\n\n        assert parse_cobertura.hitsPerLine(dom, \"sanitizer-coverage.c\", 16) == 1\n        assert parse_cobertura.hitsPerLine(dom, \"sanitizer-coverage.c\", 18) == 1\n\n        assert parse_cobertura.hitsPerLine(dom, \"sanitizer-coverage.c\", 22) == 0\n        assert parse_cobertura.hitsPerLine(dom, \"sanitizer-coverage.c\", 25) == 0\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-kcov-38-ddxhtubpsosofobjsm3xie2uvjhjpgyb/spack-src/data/glass.png",
        "/tmp/vanessa/spack-stage/spack-stage-kcov-38-ddxhtubpsosofobjsm3xie2uvjhjpgyb/spack-src/data/amber.png"
    ],
    "total_files": 283
}