{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/meson_options.txt": "# Please keep these options sorted alphabetically.\n\noption('armv8_crypto_dir', type: 'string', value: '',\n\tdescription: 'path to the armv8_crypto library installation directory')\noption('disable_drivers', type: 'string', value: '',\n\tdescription: 'Comma-separated list of drivers to explicitly disable.')\noption('drivers_install_subdir', type: 'string', value: 'dpdk/pmds-<VERSION>',\n\tdescription: 'Subdirectory of libdir where to install PMDs. Defaults to using a versioned subdirectory.')\noption('enable_docs', type: 'boolean', value: false,\n\tdescription: 'build documentation')\noption('enable_kmods', type: 'boolean', value: false,\n\tdescription: 'build kernel modules')\noption('examples', type: 'string', value: '',\n\tdescription: 'Comma-separated list of examples to build by default')\noption('flexran_sdk', type: 'string', value: '',\n\tdescription: 'Path to FlexRAN SDK optional Libraries for BBDEV device')\noption('ibverbs_link', type: 'combo', choices : ['static', 'shared', 'dlopen'], value: 'shared',\n\tdescription: 'Linkage method (static/shared/dlopen) for Mellanox PMDs with ibverbs dependencies.')\noption('include_subdir_arch', type: 'string', value: '',\n\tdescription: 'subdirectory where to install arch-dependent headers')\noption('kernel_dir', type: 'string', value: '',\n\tdescription: 'Path to the kernel for building kernel modules. Headers must be in $kernel_dir/build. Modules will be installed in $DEST_DIR/$kernel_dir/extra/dpdk.')\noption('lib_musdk_dir', type: 'string', value: '',\n\tdescription: 'path to the MUSDK library installation directory')\noption('machine', type: 'string', value: 'native',\n\tdescription: 'set the target machine type')\noption('max_ethports', type: 'integer', value: 32,\n\tdescription: 'maximum number of Ethernet devices')\noption('max_lcores', type: 'integer', value: 128,\n\tdescription: 'maximum number of cores/threads supported by EAL')\noption('max_numa_nodes', type: 'integer', value: 4,\n\tdescription: 'maximum number of NUMA nodes supported by EAL')\noption('tests', type: 'boolean', value: true,\n\tdescription: 'build unit tests')\noption('use_hpet', type: 'boolean', value: false,\n\tdescription: 'use HPET timer in EAL')\n",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/lib/librte_eal/common/eal_common_options.c": "/* SPDX-License-Identifier: BSD-3-Clause\n * Copyright(c) 2010-2014 Intel Corporation.\n * Copyright(c) 2014 6WIND S.A.\n */\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#ifndef RTE_EXEC_ENV_WINDOWS\n#include <syslog.h>\n#endif\n#include <ctype.h>\n#include <limits.h>\n#include <errno.h>\n#include <getopt.h>\n#ifndef RTE_EXEC_ENV_WINDOWS\n#include <dlfcn.h>\n#endif\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <dirent.h>\n\n#include <rte_string_fns.h>\n#include <rte_eal.h>\n#include <rte_log.h>\n#include <rte_lcore.h>\n#include <rte_memory.h>\n#include <rte_tailq.h>\n#include <rte_version.h>\n#include <rte_devargs.h>\n#include <rte_memcpy.h>\n\n#include \"eal_internal_cfg.h\"\n#include \"eal_options.h\"\n#include \"eal_filesystem.h\"\n#include \"eal_private.h\"\n\n#define BITS_PER_HEX 4\n#define LCORE_OPT_LST 1\n#define LCORE_OPT_MSK 2\n#define LCORE_OPT_MAP 3\n\nconst char\neal_short_options[] =\n\t\"b:\" /* pci-blacklist */\n\t\"c:\" /* coremask */\n\t\"s:\" /* service coremask */\n\t\"d:\" /* driver */\n\t\"h\"  /* help */\n\t\"l:\" /* corelist */\n\t\"S:\" /* service corelist */\n\t\"m:\" /* memory size */\n\t\"n:\" /* memory channels */\n\t\"r:\" /* memory ranks */\n\t\"v\"  /* version */\n\t\"w:\" /* pci-whitelist */\n\t;\n\nconst struct option\neal_long_options[] = {\n\t{OPT_BASE_VIRTADDR,     1, NULL, OPT_BASE_VIRTADDR_NUM    },\n\t{OPT_CREATE_UIO_DEV,    0, NULL, OPT_CREATE_UIO_DEV_NUM   },\n\t{OPT_FILE_PREFIX,       1, NULL, OPT_FILE_PREFIX_NUM      },\n\t{OPT_HELP,              0, NULL, OPT_HELP_NUM             },\n\t{OPT_HUGE_DIR,          1, NULL, OPT_HUGE_DIR_NUM         },\n\t{OPT_HUGE_UNLINK,       0, NULL, OPT_HUGE_UNLINK_NUM      },\n\t{OPT_IOVA_MODE,\t        1, NULL, OPT_IOVA_MODE_NUM        },\n\t{OPT_LCORES,            1, NULL, OPT_LCORES_NUM           },\n\t{OPT_LOG_LEVEL,         1, NULL, OPT_LOG_LEVEL_NUM        },\n\t{OPT_MASTER_LCORE,      1, NULL, OPT_MASTER_LCORE_NUM     },\n\t{OPT_MBUF_POOL_OPS_NAME, 1, NULL, OPT_MBUF_POOL_OPS_NAME_NUM},\n\t{OPT_NO_HPET,           0, NULL, OPT_NO_HPET_NUM          },\n\t{OPT_NO_HUGE,           0, NULL, OPT_NO_HUGE_NUM          },\n\t{OPT_NO_PCI,            0, NULL, OPT_NO_PCI_NUM           },\n\t{OPT_NO_SHCONF,         0, NULL, OPT_NO_SHCONF_NUM        },\n\t{OPT_IN_MEMORY,         0, NULL, OPT_IN_MEMORY_NUM        },\n\t{OPT_PCI_BLACKLIST,     1, NULL, OPT_PCI_BLACKLIST_NUM    },\n\t{OPT_PCI_WHITELIST,     1, NULL, OPT_PCI_WHITELIST_NUM    },\n\t{OPT_PROC_TYPE,         1, NULL, OPT_PROC_TYPE_NUM        },\n\t{OPT_SOCKET_MEM,        1, NULL, OPT_SOCKET_MEM_NUM       },\n\t{OPT_SOCKET_LIMIT,      1, NULL, OPT_SOCKET_LIMIT_NUM     },\n\t{OPT_SYSLOG,            1, NULL, OPT_SYSLOG_NUM           },\n\t{OPT_VDEV,              1, NULL, OPT_VDEV_NUM             },\n\t{OPT_VFIO_INTR,         1, NULL, OPT_VFIO_INTR_NUM        },\n\t{OPT_VMWARE_TSC_MAP,    0, NULL, OPT_VMWARE_TSC_MAP_NUM   },\n\t{OPT_LEGACY_MEM,        0, NULL, OPT_LEGACY_MEM_NUM       },\n\t{OPT_SINGLE_FILE_SEGMENTS, 0, NULL, OPT_SINGLE_FILE_SEGMENTS_NUM},\n\t{OPT_MATCH_ALLOCATIONS, 0, NULL, OPT_MATCH_ALLOCATIONS_NUM},\n\t{0,                     0, NULL, 0                        }\n};\n\nTAILQ_HEAD(shared_driver_list, shared_driver);\n\n/* Definition for shared object drivers. */\nstruct shared_driver {\n\tTAILQ_ENTRY(shared_driver) next;\n\n\tchar    name[PATH_MAX];\n\tvoid*   lib_handle;\n};\n\n/* List of external loadable drivers */\nstatic struct shared_driver_list solib_list =\nTAILQ_HEAD_INITIALIZER(solib_list);\n\n/* Default path of external loadable drivers */\nstatic const char *default_solib_dir = RTE_EAL_PMD_PATH;\n\n/*\n * Stringified version of solib path used by dpdk-pmdinfo.py\n * Note: PLEASE DO NOT ALTER THIS without making a corresponding\n * change to usertools/dpdk-pmdinfo.py\n */\nstatic const char dpdk_solib_path[] __attribute__((used)) =\n\"DPDK_PLUGIN_PATH=\" RTE_EAL_PMD_PATH;\n\nTAILQ_HEAD(device_option_list, device_option);\n\nstruct device_option {\n\tTAILQ_ENTRY(device_option) next;\n\n\tenum rte_devtype type;\n\tchar arg[];\n};\n\nstatic struct device_option_list devopt_list =\nTAILQ_HEAD_INITIALIZER(devopt_list);\n\nstatic int master_lcore_parsed;\nstatic int mem_parsed;\nstatic int core_parsed;\n\nstatic int\neal_option_device_add(enum rte_devtype type, const char *optarg)\n{\n\tstruct device_option *devopt;\n\tsize_t optlen;\n\tint ret;\n\n\toptlen = strlen(optarg) + 1;\n\tdevopt = calloc(1, sizeof(*devopt) + optlen);\n\tif (devopt == NULL) {\n\t\tRTE_LOG(ERR, EAL, \"Unable to allocate device option\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdevopt->type = type;\n\tret = strlcpy(devopt->arg, optarg, optlen);\n\tif (ret < 0) {\n\t\tRTE_LOG(ERR, EAL, \"Unable to copy device option\\n\");\n\t\tfree(devopt);\n\t\treturn -EINVAL;\n\t}\n\tTAILQ_INSERT_TAIL(&devopt_list, devopt, next);\n\treturn 0;\n}\n\nint\neal_option_device_parse(void)\n{\n\tstruct device_option *devopt;\n\tvoid *tmp;\n\tint ret = 0;\n\n\tTAILQ_FOREACH_SAFE(devopt, &devopt_list, next, tmp) {\n\t\tif (ret == 0) {\n\t\t\tret = rte_devargs_add(devopt->type, devopt->arg);\n\t\t\tif (ret)\n\t\t\t\tRTE_LOG(ERR, EAL, \"Unable to parse device '%s'\\n\",\n\t\t\t\t\tdevopt->arg);\n\t\t}\n\t\tTAILQ_REMOVE(&devopt_list, devopt, next);\n\t\tfree(devopt);\n\t}\n\treturn ret;\n}\n\nconst char *\neal_get_hugefile_prefix(void)\n{\n\tif (internal_config.hugefile_prefix != NULL)\n\t\treturn internal_config.hugefile_prefix;\n\treturn HUGEFILE_PREFIX_DEFAULT;\n}\n\nvoid\neal_reset_internal_config(struct internal_config *internal_cfg)\n{\n\tint i;\n\n\tinternal_cfg->memory = 0;\n\tinternal_cfg->force_nrank = 0;\n\tinternal_cfg->force_nchannel = 0;\n\tinternal_cfg->hugefile_prefix = NULL;\n\tinternal_cfg->hugepage_dir = NULL;\n\tinternal_cfg->force_sockets = 0;\n\t/* zero out the NUMA config */\n\tfor (i = 0; i < RTE_MAX_NUMA_NODES; i++)\n\t\tinternal_cfg->socket_mem[i] = 0;\n\tinternal_cfg->force_socket_limits = 0;\n\t/* zero out the NUMA limits config */\n\tfor (i = 0; i < RTE_MAX_NUMA_NODES; i++)\n\t\tinternal_cfg->socket_limit[i] = 0;\n\t/* zero out hugedir descriptors */\n\tfor (i = 0; i < MAX_HUGEPAGE_SIZES; i++) {\n\t\tmemset(&internal_cfg->hugepage_info[i], 0,\n\t\t\t\tsizeof(internal_cfg->hugepage_info[0]));\n\t\tinternal_cfg->hugepage_info[i].lock_descriptor = -1;\n\t}\n\tinternal_cfg->base_virtaddr = 0;\n\n#ifdef LOG_DAEMON\n\tinternal_cfg->syslog_facility = LOG_DAEMON;\n#endif\n\n\t/* if set to NONE, interrupt mode is determined automatically */\n\tinternal_cfg->vfio_intr_mode = RTE_INTR_MODE_NONE;\n\n#ifdef RTE_LIBEAL_USE_HPET\n\tinternal_cfg->no_hpet = 0;\n#else\n\tinternal_cfg->no_hpet = 1;\n#endif\n\tinternal_cfg->vmware_tsc_map = 0;\n\tinternal_cfg->create_uio_dev = 0;\n\tinternal_cfg->iova_mode = RTE_IOVA_DC;\n\tinternal_cfg->user_mbuf_pool_ops_name = NULL;\n\tCPU_ZERO(&internal_cfg->ctrl_cpuset);\n\tinternal_cfg->init_complete = 0;\n}\n\nstatic int\neal_plugin_add(const char *path)\n{\n\tstruct shared_driver *solib;\n\n\tsolib = malloc(sizeof(*solib));\n\tif (solib == NULL) {\n\t\tRTE_LOG(ERR, EAL, \"malloc(solib) failed\\n\");\n\t\treturn -1;\n\t}\n\tmemset(solib, 0, sizeof(*solib));\n\tstrlcpy(solib->name, path, PATH_MAX-1);\n\tsolib->name[PATH_MAX-1] = 0;\n\tTAILQ_INSERT_TAIL(&solib_list, solib, next);\n\n\treturn 0;\n}\n\nstatic int\neal_plugindir_init(const char *path)\n{\n\tDIR *d = NULL;\n\tstruct dirent *dent = NULL;\n\tchar sopath[PATH_MAX];\n\n\tif (path == NULL || *path == '\\0')\n\t\treturn 0;\n\n\td = opendir(path);\n\tif (d == NULL) {\n\t\tRTE_LOG(ERR, EAL, \"failed to open directory %s: %s\\n\",\n\t\t\tpath, strerror(errno));\n\t\treturn -1;\n\t}\n\n\twhile ((dent = readdir(d)) != NULL) {\n\t\tstruct stat sb;\n\n\t\tsnprintf(sopath, sizeof(sopath), \"%s/%s\", path, dent->d_name);\n\n\t\tif (!(stat(sopath, &sb) == 0 && S_ISREG(sb.st_mode)))\n\t\t\tcontinue;\n\n\t\tif (eal_plugin_add(sopath) == -1)\n\t\t\tbreak;\n\t}\n\n\tclosedir(d);\n\t/* XXX this ignores failures from readdir() itself */\n\treturn (dent == NULL) ? 0 : -1;\n}\n\nint\neal_plugins_init(void)\n{\n#ifndef RTE_EXEC_ENV_WINDOWS\n\tstruct shared_driver *solib = NULL;\n\tstruct stat sb;\n\n\tif (*default_solib_dir != '\\0' && stat(default_solib_dir, &sb) == 0 &&\n\t\t\t\tS_ISDIR(sb.st_mode))\n\t\teal_plugin_add(default_solib_dir);\n\n\tTAILQ_FOREACH(solib, &solib_list, next) {\n\n\t\tif (stat(solib->name, &sb) == 0 && S_ISDIR(sb.st_mode)) {\n\t\t\tif (eal_plugindir_init(solib->name) == -1) {\n\t\t\t\tRTE_LOG(ERR, EAL,\n\t\t\t\t\t\"Cannot init plugin directory %s\\n\",\n\t\t\t\t\tsolib->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tRTE_LOG(DEBUG, EAL, \"open shared lib %s\\n\",\n\t\t\t\tsolib->name);\n\t\t\tsolib->lib_handle = dlopen(solib->name, RTLD_NOW);\n\t\t\tif (solib->lib_handle == NULL) {\n\t\t\t\tRTE_LOG(ERR, EAL, \"%s\\n\", dlerror());\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t}\n\treturn 0;\n#endif\n}\n\n/*\n * Parse the coremask given as argument (hexadecimal string) and fill\n * the global configuration (core role and core count) with the parsed\n * value.\n */\nstatic int xdigit2val(unsigned char c)\n{\n\tint val;\n\n\tif (isdigit(c))\n\t\tval = c - '0';\n\telse if (isupper(c))\n\t\tval = c - 'A' + 10;\n\telse\n\t\tval = c - 'a' + 10;\n\treturn val;\n}\n\nstatic int\neal_parse_service_coremask(const char *coremask)\n{\n\tstruct rte_config *cfg = rte_eal_get_configuration();\n\tint i, j, idx = 0;\n\tunsigned int count = 0;\n\tchar c;\n\tint val;\n\tuint32_t taken_lcore_count = 0;\n\n\tif (coremask == NULL)\n\t\treturn -1;\n\t/* Remove all blank characters ahead and after .\n\t * Remove 0x/0X if exists.\n\t */\n\twhile (isblank(*coremask))\n\t\tcoremask++;\n\tif (coremask[0] == '0' && ((coremask[1] == 'x')\n\t\t|| (coremask[1] == 'X')))\n\t\tcoremask += 2;\n\ti = strlen(coremask);\n\twhile ((i > 0) && isblank(coremask[i - 1]))\n\t\ti--;\n\n\tif (i == 0)\n\t\treturn -1;\n\n\tfor (i = i - 1; i >= 0 && idx < RTE_MAX_LCORE; i--) {\n\t\tc = coremask[i];\n\t\tif (isxdigit(c) == 0) {\n\t\t\t/* invalid characters */\n\t\t\treturn -1;\n\t\t}\n\t\tval = xdigit2val(c);\n\t\tfor (j = 0; j < BITS_PER_HEX && idx < RTE_MAX_LCORE;\n\t\t\t\tj++, idx++) {\n\t\t\tif ((1 << j) & val) {\n\t\t\t\t/* handle master lcore already parsed */\n\t\t\t\tuint32_t lcore = idx;\n\t\t\t\tif (master_lcore_parsed &&\n\t\t\t\t\t\tcfg->master_lcore == lcore) {\n\t\t\t\t\tRTE_LOG(ERR, EAL,\n\t\t\t\t\t\t\"lcore %u is master lcore, cannot use as service core\\n\",\n\t\t\t\t\t\tidx);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (eal_cpu_detected(idx) == 0) {\n\t\t\t\t\tRTE_LOG(ERR, EAL,\n\t\t\t\t\t\t\"lcore %u unavailable\\n\", idx);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (cfg->lcore_role[idx] == ROLE_RTE)\n\t\t\t\t\ttaken_lcore_count++;\n\n\t\t\t\tlcore_config[idx].core_role = ROLE_SERVICE;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (; i >= 0; i--)\n\t\tif (coremask[i] != '0')\n\t\t\treturn -1;\n\n\tfor (; idx < RTE_MAX_LCORE; idx++)\n\t\tlcore_config[idx].core_index = -1;\n\n\tif (count == 0)\n\t\treturn -1;\n\n\tif (core_parsed && taken_lcore_count != count) {\n\t\tRTE_LOG(WARNING, EAL,\n\t\t\t\"Not all service cores are in the coremask. \"\n\t\t\t\"Please ensure -c or -l includes service cores\\n\");\n\t}\n\n\tcfg->service_lcore_count = count;\n\treturn 0;\n}\n\nstatic int\neal_service_cores_parsed(void)\n{\n\tint idx;\n\tfor (idx = 0; idx < RTE_MAX_LCORE; idx++) {\n\t\tif (lcore_config[idx].core_role == ROLE_SERVICE)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\nupdate_lcore_config(int *cores)\n{\n\tstruct rte_config *cfg = rte_eal_get_configuration();\n\tunsigned int count = 0;\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < RTE_MAX_LCORE; i++) {\n\t\tif (cores[i] != -1) {\n\t\t\tif (eal_cpu_detected(i) == 0) {\n\t\t\t\tRTE_LOG(ERR, EAL, \"lcore %u unavailable\\n\", i);\n\t\t\t\tret = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcfg->lcore_role[i] = ROLE_RTE;\n\t\t\tcount++;\n\t\t} else {\n\t\t\tcfg->lcore_role[i] = ROLE_OFF;\n\t\t}\n\t\tlcore_config[i].core_index = cores[i];\n\t}\n\tif (!ret)\n\t\tcfg->lcore_count = count;\n\treturn ret;\n}\n\nstatic int\neal_parse_coremask(const char *coremask, int *cores)\n{\n\tunsigned count = 0;\n\tint i, j, idx;\n\tint val;\n\tchar c;\n\n\tfor (idx = 0; idx < RTE_MAX_LCORE; idx++)\n\t\tcores[idx] = -1;\n\tidx = 0;\n\n\t/* Remove all blank characters ahead and after .\n\t * Remove 0x/0X if exists.\n\t */\n\twhile (isblank(*coremask))\n\t\tcoremask++;\n\tif (coremask[0] == '0' && ((coremask[1] == 'x')\n\t\t|| (coremask[1] == 'X')))\n\t\tcoremask += 2;\n\ti = strlen(coremask);\n\twhile ((i > 0) && isblank(coremask[i - 1]))\n\t\ti--;\n\tif (i == 0)\n\t\treturn -1;\n\n\tfor (i = i - 1; i >= 0 && idx < RTE_MAX_LCORE; i--) {\n\t\tc = coremask[i];\n\t\tif (isxdigit(c) == 0) {\n\t\t\t/* invalid characters */\n\t\t\treturn -1;\n\t\t}\n\t\tval = xdigit2val(c);\n\t\tfor (j = 0; j < BITS_PER_HEX && idx < RTE_MAX_LCORE; j++, idx++)\n\t\t{\n\t\t\tif ((1 << j) & val) {\n\t\t\t\tcores[idx] = count;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (; i >= 0; i--)\n\t\tif (coremask[i] != '0')\n\t\t\treturn -1;\n\tif (count == 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int\neal_parse_service_corelist(const char *corelist)\n{\n\tstruct rte_config *cfg = rte_eal_get_configuration();\n\tint i, idx = 0;\n\tunsigned count = 0;\n\tchar *end = NULL;\n\tint min, max;\n\tuint32_t taken_lcore_count = 0;\n\n\tif (corelist == NULL)\n\t\treturn -1;\n\n\t/* Remove all blank characters ahead and after */\n\twhile (isblank(*corelist))\n\t\tcorelist++;\n\ti = strlen(corelist);\n\twhile ((i > 0) && isblank(corelist[i - 1]))\n\t\ti--;\n\n\t/* Get list of cores */\n\tmin = RTE_MAX_LCORE;\n\tdo {\n\t\twhile (isblank(*corelist))\n\t\t\tcorelist++;\n\t\tif (*corelist == '\\0')\n\t\t\treturn -1;\n\t\terrno = 0;\n\t\tidx = strtoul(corelist, &end, 10);\n\t\tif (errno || end == NULL)\n\t\t\treturn -1;\n\t\twhile (isblank(*end))\n\t\t\tend++;\n\t\tif (*end == '-') {\n\t\t\tmin = idx;\n\t\t} else if ((*end == ',') || (*end == '\\0')) {\n\t\t\tmax = idx;\n\t\t\tif (min == RTE_MAX_LCORE)\n\t\t\t\tmin = idx;\n\t\t\tfor (idx = min; idx <= max; idx++) {\n\t\t\t\tif (cfg->lcore_role[idx] != ROLE_SERVICE) {\n\t\t\t\t\t/* handle master lcore already parsed */\n\t\t\t\t\tuint32_t lcore = idx;\n\t\t\t\t\tif (cfg->master_lcore == lcore &&\n\t\t\t\t\t\t\tmaster_lcore_parsed) {\n\t\t\t\t\t\tRTE_LOG(ERR, EAL,\n\t\t\t\t\t\t\t\"Error: lcore %u is master lcore, cannot use as service core\\n\",\n\t\t\t\t\t\t\tidx);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (cfg->lcore_role[idx] == ROLE_RTE)\n\t\t\t\t\t\ttaken_lcore_count++;\n\n\t\t\t\t\tlcore_config[idx].core_role =\n\t\t\t\t\t\t\tROLE_SERVICE;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin = RTE_MAX_LCORE;\n\t\t} else\n\t\t\treturn -1;\n\t\tcorelist = end + 1;\n\t} while (*end != '\\0');\n\n\tif (count == 0)\n\t\treturn -1;\n\n\tif (core_parsed && taken_lcore_count != count) {\n\t\tRTE_LOG(WARNING, EAL,\n\t\t\t\"Not all service cores were in the coremask. \"\n\t\t\t\"Please ensure -c or -l includes service cores\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int\neal_parse_corelist(const char *corelist, int *cores)\n{\n\tunsigned count = 0;\n\tchar *end = NULL;\n\tint min, max;\n\tint idx;\n\n\tfor (idx = 0; idx < RTE_MAX_LCORE; idx++)\n\t\tcores[idx] = -1;\n\n\t/* Remove all blank characters ahead */\n\twhile (isblank(*corelist))\n\t\tcorelist++;\n\n\t/* Get list of cores */\n\tmin = RTE_MAX_LCORE;\n\tdo {\n\t\twhile (isblank(*corelist))\n\t\t\tcorelist++;\n\t\tif (*corelist == '\\0')\n\t\t\treturn -1;\n\t\terrno = 0;\n\t\tidx = strtol(corelist, &end, 10);\n\t\tif (errno || end == NULL)\n\t\t\treturn -1;\n\t\tif (idx < 0 || idx >= RTE_MAX_LCORE)\n\t\t\treturn -1;\n\t\twhile (isblank(*end))\n\t\t\tend++;\n\t\tif (*end == '-') {\n\t\t\tmin = idx;\n\t\t} else if ((*end == ',') || (*end == '\\0')) {\n\t\t\tmax = idx;\n\t\t\tif (min == RTE_MAX_LCORE)\n\t\t\t\tmin = idx;\n\t\t\tfor (idx = min; idx <= max; idx++) {\n\t\t\t\tif (cores[idx] == -1) {\n\t\t\t\t\tcores[idx] = count;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin = RTE_MAX_LCORE;\n\t\t} else\n\t\t\treturn -1;\n\t\tcorelist = end + 1;\n\t} while (*end != '\\0');\n\n\tif (count == 0)\n\t\treturn -1;\n\treturn 0;\n}\n\n/* Changes the lcore id of the master thread */\nstatic int\neal_parse_master_lcore(const char *arg)\n{\n\tchar *parsing_end;\n\tstruct rte_config *cfg = rte_eal_get_configuration();\n\n\terrno = 0;\n\tcfg->master_lcore = (uint32_t) strtol(arg, &parsing_end, 0);\n\tif (errno || parsing_end[0] != 0)\n\t\treturn -1;\n\tif (cfg->master_lcore >= RTE_MAX_LCORE)\n\t\treturn -1;\n\tmaster_lcore_parsed = 1;\n\n\t/* ensure master core is not used as service core */\n\tif (lcore_config[cfg->master_lcore].core_role == ROLE_SERVICE) {\n\t\tRTE_LOG(ERR, EAL,\n\t\t\t\"Error: Master lcore is used as a service core\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Parse elem, the elem could be single number/range or '(' ')' group\n * 1) A single number elem, it's just a simple digit. e.g. 9\n * 2) A single range elem, two digits with a '-' between. e.g. 2-6\n * 3) A group elem, combines multiple 1) or 2) with '( )'. e.g (0,2-4,6)\n *    Within group elem, '-' used for a range separator;\n *                       ',' used for a single number.\n */\nstatic int\neal_parse_set(const char *input, rte_cpuset_t *set)\n{\n\tunsigned idx;\n\tconst char *str = input;\n\tchar *end = NULL;\n\tunsigned min, max;\n\n\tCPU_ZERO(set);\n\n\twhile (isblank(*str))\n\t\tstr++;\n\n\t/* only digit or left bracket is qualify for start point */\n\tif ((!isdigit(*str) && *str != '(') || *str == '\\0')\n\t\treturn -1;\n\n\t/* process single number or single range of number */\n\tif (*str != '(') {\n\t\terrno = 0;\n\t\tidx = strtoul(str, &end, 10);\n\t\tif (errno || end == NULL || idx >= CPU_SETSIZE)\n\t\t\treturn -1;\n\t\telse {\n\t\t\twhile (isblank(*end))\n\t\t\t\tend++;\n\n\t\t\tmin = idx;\n\t\t\tmax = idx;\n\t\t\tif (*end == '-') {\n\t\t\t\t/* process single <number>-<number> */\n\t\t\t\tend++;\n\t\t\t\twhile (isblank(*end))\n\t\t\t\t\tend++;\n\t\t\t\tif (!isdigit(*end))\n\t\t\t\t\treturn -1;\n\n\t\t\t\terrno = 0;\n\t\t\t\tidx = strtoul(end, &end, 10);\n\t\t\t\tif (errno || end == NULL || idx >= CPU_SETSIZE)\n\t\t\t\t\treturn -1;\n\t\t\t\tmax = idx;\n\t\t\t\twhile (isblank(*end))\n\t\t\t\t\tend++;\n\t\t\t\tif (*end != ',' && *end != '\\0')\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (*end != ',' && *end != '\\0' &&\n\t\t\t    *end != '@')\n\t\t\t\treturn -1;\n\n\t\t\tfor (idx = RTE_MIN(min, max);\n\t\t\t     idx <= RTE_MAX(min, max); idx++)\n\t\t\t\tCPU_SET(idx, set);\n\n\t\t\treturn end - input;\n\t\t}\n\t}\n\n\t/* process set within bracket */\n\tstr++;\n\twhile (isblank(*str))\n\t\tstr++;\n\tif (*str == '\\0')\n\t\treturn -1;\n\n\tmin = RTE_MAX_LCORE;\n\tdo {\n\n\t\t/* go ahead to the first digit */\n\t\twhile (isblank(*str))\n\t\t\tstr++;\n\t\tif (!isdigit(*str))\n\t\t\treturn -1;\n\n\t\t/* get the digit value */\n\t\terrno = 0;\n\t\tidx = strtoul(str, &end, 10);\n\t\tif (errno || end == NULL || idx >= CPU_SETSIZE)\n\t\t\treturn -1;\n\n\t\t/* go ahead to separator '-',',' and ')' */\n\t\twhile (isblank(*end))\n\t\t\tend++;\n\t\tif (*end == '-') {\n\t\t\tif (min == RTE_MAX_LCORE)\n\t\t\t\tmin = idx;\n\t\t\telse /* avoid continuous '-' */\n\t\t\t\treturn -1;\n\t\t} else if ((*end == ',') || (*end == ')')) {\n\t\t\tmax = idx;\n\t\t\tif (min == RTE_MAX_LCORE)\n\t\t\t\tmin = idx;\n\t\t\tfor (idx = RTE_MIN(min, max);\n\t\t\t     idx <= RTE_MAX(min, max); idx++)\n\t\t\t\tCPU_SET(idx, set);\n\n\t\t\tmin = RTE_MAX_LCORE;\n\t\t} else\n\t\t\treturn -1;\n\n\t\tstr = end + 1;\n\t} while (*end != '\\0' && *end != ')');\n\n\t/*\n\t * to avoid failure that tail blank makes end character check fail\n\t * in eal_parse_lcores( )\n\t */\n\twhile (isblank(*str))\n\t\tstr++;\n\n\treturn str - input;\n}\n\nstatic int\ncheck_cpuset(rte_cpuset_t *set)\n{\n\tunsigned int idx;\n\n\tfor (idx = 0; idx < CPU_SETSIZE; idx++) {\n\t\tif (!CPU_ISSET(idx, set))\n\t\t\tcontinue;\n\n\t\tif (eal_cpu_detected(idx) == 0) {\n\t\t\tRTE_LOG(ERR, EAL, \"core %u \"\n\t\t\t\t\"unavailable\\n\", idx);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * The format pattern: --lcores='<lcores[@cpus]>[<,lcores[@cpus]>...]'\n * lcores, cpus could be a single digit/range or a group.\n * '(' and ')' are necessary if it's a group.\n * If not supply '@cpus', the value of cpus uses the same as lcores.\n * e.g. '1,2@(5-7),(3-5)@(0,2),(0,6),7-8' means start 9 EAL thread as below\n *   lcore 0 runs on cpuset 0x41 (cpu 0,6)\n *   lcore 1 runs on cpuset 0x2 (cpu 1)\n *   lcore 2 runs on cpuset 0xe0 (cpu 5,6,7)\n *   lcore 3,4,5 runs on cpuset 0x5 (cpu 0,2)\n *   lcore 6 runs on cpuset 0x41 (cpu 0,6)\n *   lcore 7 runs on cpuset 0x80 (cpu 7)\n *   lcore 8 runs on cpuset 0x100 (cpu 8)\n */\nstatic int\neal_parse_lcores(const char *lcores)\n{\n\tstruct rte_config *cfg = rte_eal_get_configuration();\n\trte_cpuset_t lcore_set;\n\tunsigned int set_count;\n\tunsigned idx = 0;\n\tunsigned count = 0;\n\tconst char *lcore_start = NULL;\n\tconst char *end = NULL;\n\tint offset;\n\trte_cpuset_t cpuset;\n\tint lflags;\n\tint ret = -1;\n\n\tif (lcores == NULL)\n\t\treturn -1;\n\n\t/* Remove all blank characters ahead and after */\n\twhile (isblank(*lcores))\n\t\tlcores++;\n\n\tCPU_ZERO(&cpuset);\n\n\t/* Reset lcore config */\n\tfor (idx = 0; idx < RTE_MAX_LCORE; idx++) {\n\t\tcfg->lcore_role[idx] = ROLE_OFF;\n\t\tlcore_config[idx].core_index = -1;\n\t\tCPU_ZERO(&lcore_config[idx].cpuset);\n\t}\n\n\t/* Get list of cores */\n\tdo {\n\t\twhile (isblank(*lcores))\n\t\t\tlcores++;\n\t\tif (*lcores == '\\0')\n\t\t\tgoto err;\n\n\t\tlflags = 0;\n\n\t\t/* record lcore_set start point */\n\t\tlcore_start = lcores;\n\n\t\t/* go across a complete bracket */\n\t\tif (*lcore_start == '(') {\n\t\t\tlcores += strcspn(lcores, \")\");\n\t\t\tif (*lcores++ == '\\0')\n\t\t\t\tgoto err;\n\t\t}\n\n\t\t/* scan the separator '@', ','(next) or '\\0'(finish) */\n\t\tlcores += strcspn(lcores, \"@,\");\n\n\t\tif (*lcores == '@') {\n\t\t\t/* explicit assign cpuset and update the end cursor */\n\t\t\toffset = eal_parse_set(lcores + 1, &cpuset);\n\t\t\tif (offset < 0)\n\t\t\t\tgoto err;\n\t\t\tend = lcores + 1 + offset;\n\t\t} else { /* ',' or '\\0' */\n\t\t\t/* haven't given cpuset, current loop done */\n\t\t\tend = lcores;\n\n\t\t\t/* go back to check <number>-<number> */\n\t\t\toffset = strcspn(lcore_start, \"(-\");\n\t\t\tif (offset < (end - lcore_start) &&\n\t\t\t    *(lcore_start + offset) != '(')\n\t\t\t\tlflags = 1;\n\t\t}\n\n\t\tif (*end != ',' && *end != '\\0')\n\t\t\tgoto err;\n\n\t\t/* parse lcore_set from start point */\n\t\tif (eal_parse_set(lcore_start, &lcore_set) < 0)\n\t\t\tgoto err;\n\n\t\t/* without '@', by default using lcore_set as cpuset */\n\t\tif (*lcores != '@')\n\t\t\trte_memcpy(&cpuset, &lcore_set, sizeof(cpuset));\n\n\t\tset_count = CPU_COUNT(&lcore_set);\n\t\t/* start to update lcore_set */\n\t\tfor (idx = 0; idx < RTE_MAX_LCORE; idx++) {\n\t\t\tif (!CPU_ISSET(idx, &lcore_set))\n\t\t\t\tcontinue;\n\t\t\tset_count--;\n\n\t\t\tif (cfg->lcore_role[idx] != ROLE_RTE) {\n\t\t\t\tlcore_config[idx].core_index = count;\n\t\t\t\tcfg->lcore_role[idx] = ROLE_RTE;\n\t\t\t\tcount++;\n\t\t\t}\n\n\t\t\tif (lflags) {\n\t\t\t\tCPU_ZERO(&cpuset);\n\t\t\t\tCPU_SET(idx, &cpuset);\n\t\t\t}\n\n\t\t\tif (check_cpuset(&cpuset) < 0)\n\t\t\t\tgoto err;\n\t\t\trte_memcpy(&lcore_config[idx].cpuset, &cpuset,\n\t\t\t\t   sizeof(rte_cpuset_t));\n\t\t}\n\n\t\t/* some cores from the lcore_set can't be handled by EAL */\n\t\tif (set_count != 0)\n\t\t\tgoto err;\n\n\t\tlcores = end + 1;\n\t} while (*end != '\\0');\n\n\tif (count == 0)\n\t\tgoto err;\n\n\tcfg->lcore_count = count;\n\tret = 0;\n\nerr:\n\n\treturn ret;\n}\n\n#ifndef RTE_EXEC_ENV_WINDOWS\nstatic int\neal_parse_syslog(const char *facility, struct internal_config *conf)\n{\n\tint i;\n\tstatic const struct {\n\t\tconst char *name;\n\t\tint value;\n\t} map[] = {\n\t\t{ \"auth\", LOG_AUTH },\n\t\t{ \"cron\", LOG_CRON },\n\t\t{ \"daemon\", LOG_DAEMON },\n\t\t{ \"ftp\", LOG_FTP },\n\t\t{ \"kern\", LOG_KERN },\n\t\t{ \"lpr\", LOG_LPR },\n\t\t{ \"mail\", LOG_MAIL },\n\t\t{ \"news\", LOG_NEWS },\n\t\t{ \"syslog\", LOG_SYSLOG },\n\t\t{ \"user\", LOG_USER },\n\t\t{ \"uucp\", LOG_UUCP },\n\t\t{ \"local0\", LOG_LOCAL0 },\n\t\t{ \"local1\", LOG_LOCAL1 },\n\t\t{ \"local2\", LOG_LOCAL2 },\n\t\t{ \"local3\", LOG_LOCAL3 },\n\t\t{ \"local4\", LOG_LOCAL4 },\n\t\t{ \"local5\", LOG_LOCAL5 },\n\t\t{ \"local6\", LOG_LOCAL6 },\n\t\t{ \"local7\", LOG_LOCAL7 },\n\t\t{ NULL, 0 }\n\t};\n\n\tfor (i = 0; map[i].name; i++) {\n\t\tif (!strcmp(facility, map[i].name)) {\n\t\t\tconf->syslog_facility = map[i].value;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n#endif\n\nstatic int\neal_parse_log_priority(const char *level)\n{\n\tstatic const char * const levels[] = {\n\t\t[RTE_LOG_EMERG]   = \"emergency\",\n\t\t[RTE_LOG_ALERT]   = \"alert\",\n\t\t[RTE_LOG_CRIT]    = \"critical\",\n\t\t[RTE_LOG_ERR]     = \"error\",\n\t\t[RTE_LOG_WARNING] = \"warning\",\n\t\t[RTE_LOG_NOTICE]  = \"notice\",\n\t\t[RTE_LOG_INFO]    = \"info\",\n\t\t[RTE_LOG_DEBUG]   = \"debug\",\n\t};\n\tsize_t len = strlen(level);\n\tunsigned long tmp;\n\tchar *end;\n\tunsigned int i;\n\n\tif (len == 0)\n\t\treturn -1;\n\n\t/* look for named values, skip 0 which is not a valid level */\n\tfor (i = 1; i < RTE_DIM(levels); i++) {\n\t\tif (strncmp(levels[i], level, len) == 0)\n\t\t\treturn i;\n\t}\n\n\t/* not a string, maybe it is numeric */\n\terrno = 0;\n\ttmp = strtoul(level, &end, 0);\n\n\t/* check for errors */\n\tif (errno != 0 || end == NULL || *end != '\\0' ||\n\t    tmp >= UINT32_MAX)\n\t\treturn -1;\n\n\treturn tmp;\n}\n\nstatic int\neal_parse_log_level(const char *arg)\n{\n\tconst char *pattern = NULL;\n\tconst char *regex = NULL;\n\tchar *str, *level;\n\tint priority;\n\n\tstr = strdup(arg);\n\tif (str == NULL)\n\t\treturn -1;\n\n\tif ((level = strchr(str, ','))) {\n\t\tregex = str;\n\t\t*level++ = '\\0';\n\t} else if ((level = strchr(str, ':'))) {\n\t\tpattern = str;\n\t\t*level++ = '\\0';\n\t} else {\n\t\tlevel = str;\n\t}\n\n\tpriority = eal_parse_log_priority(level);\n\tif (priority < 0) {\n\t\tfprintf(stderr, \"invalid log priority: %s\\n\", level);\n\t\tgoto fail;\n\t}\n\n\tif (regex) {\n\t\tif (rte_log_set_level_regexp(regex, priority) < 0) {\n\t\t\tfprintf(stderr, \"cannot set log level %s,%d\\n\",\n\t\t\t\tpattern, priority);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (rte_log_save_regexp(regex, priority) < 0)\n\t\t\tgoto fail;\n\t} else if (pattern) {\n\t\tif (rte_log_set_level_pattern(pattern, priority) < 0) {\n\t\t\tfprintf(stderr, \"cannot set log level %s:%d\\n\",\n\t\t\t\tpattern, priority);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (rte_log_save_pattern(pattern, priority) < 0)\n\t\t\tgoto fail;\n\t} else {\n\t\trte_log_set_global_level(priority);\n\t}\n\n\tfree(str);\n\treturn 0;\n\nfail:\n\tfree(str);\n\treturn -1;\n}\n\nstatic enum rte_proc_type_t\neal_parse_proc_type(const char *arg)\n{\n\tif (strncasecmp(arg, \"primary\", sizeof(\"primary\")) == 0)\n\t\treturn RTE_PROC_PRIMARY;\n\tif (strncasecmp(arg, \"secondary\", sizeof(\"secondary\")) == 0)\n\t\treturn RTE_PROC_SECONDARY;\n\tif (strncasecmp(arg, \"auto\", sizeof(\"auto\")) == 0)\n\t\treturn RTE_PROC_AUTO;\n\n\treturn RTE_PROC_INVALID;\n}\n\nstatic int\neal_parse_iova_mode(const char *name)\n{\n\tint mode;\n\n\tif (name == NULL)\n\t\treturn -1;\n\n\tif (!strcmp(\"pa\", name))\n\t\tmode = RTE_IOVA_PA;\n\telse if (!strcmp(\"va\", name))\n\t\tmode = RTE_IOVA_VA;\n\telse\n\t\treturn -1;\n\n\tinternal_config.iova_mode = mode;\n\treturn 0;\n}\n\nstatic int\neal_parse_base_virtaddr(const char *arg)\n{\n\tchar *end;\n\tuint64_t addr;\n\n\terrno = 0;\n\taddr = strtoull(arg, &end, 16);\n\n\t/* check for errors */\n\tif ((errno != 0) || (arg[0] == '\\0') || end == NULL || (*end != '\\0'))\n\t\treturn -1;\n\n\t/* make sure we don't exceed 32-bit boundary on 32-bit target */\n#ifndef RTE_ARCH_64\n\tif (addr >= UINTPTR_MAX)\n\t\treturn -1;\n#endif\n\n\t/* align the addr on 16M boundary, 16MB is the minimum huge page\n\t * size on IBM Power architecture. If the addr is aligned to 16MB,\n\t * it can align to 2MB for x86. So this alignment can also be used\n\t * on x86 and other architectures.\n\t */\n\tinternal_config.base_virtaddr =\n\t\tRTE_PTR_ALIGN_CEIL((uintptr_t)addr, (size_t)RTE_PGSIZE_16M);\n\n\treturn 0;\n}\n\n/* caller is responsible for freeing the returned string */\nstatic char *\navailable_cores(void)\n{\n\tchar *str = NULL;\n\tint previous;\n\tint sequence;\n\tchar *tmp;\n\tint idx;\n\n\t/* find the first available cpu */\n\tfor (idx = 0; idx < RTE_MAX_LCORE; idx++) {\n\t\tif (eal_cpu_detected(idx) == 0)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (idx >= RTE_MAX_LCORE)\n\t\treturn NULL;\n\n\t/* first sequence */\n\tif (asprintf(&str, \"%d\", idx) < 0)\n\t\treturn NULL;\n\tprevious = idx;\n\tsequence = 0;\n\n\tfor (idx++ ; idx < RTE_MAX_LCORE; idx++) {\n\t\tif (eal_cpu_detected(idx) == 0)\n\t\t\tcontinue;\n\n\t\tif (idx == previous + 1) {\n\t\t\tprevious = idx;\n\t\t\tsequence = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* finish current sequence */\n\t\tif (sequence) {\n\t\t\tif (asprintf(&tmp, \"%s-%d\", str, previous) < 0) {\n\t\t\t\tfree(str);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfree(str);\n\t\t\tstr = tmp;\n\t\t}\n\n\t\t/* new sequence */\n\t\tif (asprintf(&tmp, \"%s,%d\", str, idx) < 0) {\n\t\t\tfree(str);\n\t\t\treturn NULL;\n\t\t}\n\t\tfree(str);\n\t\tstr = tmp;\n\t\tprevious = idx;\n\t\tsequence = 0;\n\t}\n\n\t/* finish last sequence */\n\tif (sequence) {\n\t\tif (asprintf(&tmp, \"%s-%d\", str, previous) < 0) {\n\t\t\tfree(str);\n\t\t\treturn NULL;\n\t\t}\n\t\tfree(str);\n\t\tstr = tmp;\n\t}\n\n\treturn str;\n}\n\nint\neal_parse_common_option(int opt, const char *optarg,\n\t\t\tstruct internal_config *conf)\n{\n\tstatic int b_used;\n\tstatic int w_used;\n\n\tswitch (opt) {\n\t/* blacklist */\n\tcase 'b':\n\t\tif (w_used)\n\t\t\tgoto bw_used;\n\t\tif (eal_option_device_add(RTE_DEVTYPE_BLACKLISTED_PCI,\n\t\t\t\toptarg) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tb_used = 1;\n\t\tbreak;\n\t/* whitelist */\n\tcase 'w':\n\t\tif (b_used)\n\t\t\tgoto bw_used;\n\t\tif (eal_option_device_add(RTE_DEVTYPE_WHITELISTED_PCI,\n\t\t\t\toptarg) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tw_used = 1;\n\t\tbreak;\n\t/* coremask */\n\tcase 'c': {\n\t\tint lcore_indexes[RTE_MAX_LCORE];\n\n\t\tif (eal_service_cores_parsed())\n\t\t\tRTE_LOG(WARNING, EAL,\n\t\t\t\t\"Service cores parsed before dataplane cores. Please ensure -c is before -s or -S\\n\");\n\t\tif (eal_parse_coremask(optarg, lcore_indexes) < 0) {\n\t\t\tRTE_LOG(ERR, EAL, \"invalid coremask syntax\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (update_lcore_config(lcore_indexes) < 0) {\n\t\t\tchar *available = available_cores();\n\n\t\t\tRTE_LOG(ERR, EAL,\n\t\t\t\t\"invalid coremask, please check specified cores are part of %s\\n\",\n\t\t\t\tavailable);\n\t\t\tfree(available);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (core_parsed) {\n\t\t\tRTE_LOG(ERR, EAL, \"Option -c is ignored, because (%s) is set!\\n\",\n\t\t\t\t(core_parsed == LCORE_OPT_LST) ? \"-l\" :\n\t\t\t\t(core_parsed == LCORE_OPT_MAP) ? \"--lcore\" :\n\t\t\t\t\"-c\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tcore_parsed = LCORE_OPT_MSK;\n\t\tbreak;\n\t}\n\t/* corelist */\n\tcase 'l': {\n\t\tint lcore_indexes[RTE_MAX_LCORE];\n\n\t\tif (eal_service_cores_parsed())\n\t\t\tRTE_LOG(WARNING, EAL,\n\t\t\t\t\"Service cores parsed before dataplane cores. Please ensure -l is before -s or -S\\n\");\n\n\t\tif (eal_parse_corelist(optarg, lcore_indexes) < 0) {\n\t\t\tRTE_LOG(ERR, EAL, \"invalid core list syntax\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (update_lcore_config(lcore_indexes) < 0) {\n\t\t\tchar *available = available_cores();\n\n\t\t\tRTE_LOG(ERR, EAL,\n\t\t\t\t\"invalid core list, please check specified cores are part of %s\\n\",\n\t\t\t\tavailable);\n\t\t\tfree(available);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (core_parsed) {\n\t\t\tRTE_LOG(ERR, EAL, \"Option -l is ignored, because (%s) is set!\\n\",\n\t\t\t\t(core_parsed == LCORE_OPT_MSK) ? \"-c\" :\n\t\t\t\t(core_parsed == LCORE_OPT_MAP) ? \"--lcore\" :\n\t\t\t\t\"-l\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tcore_parsed = LCORE_OPT_LST;\n\t\tbreak;\n\t}\n\t/* service coremask */\n\tcase 's':\n\t\tif (eal_parse_service_coremask(optarg) < 0) {\n\t\t\tRTE_LOG(ERR, EAL, \"invalid service coremask\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t/* service corelist */\n\tcase 'S':\n\t\tif (eal_parse_service_corelist(optarg) < 0) {\n\t\t\tRTE_LOG(ERR, EAL, \"invalid service core list\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t/* size of memory */\n\tcase 'm':\n\t\tconf->memory = atoi(optarg);\n\t\tconf->memory *= 1024ULL;\n\t\tconf->memory *= 1024ULL;\n\t\tmem_parsed = 1;\n\t\tbreak;\n\t/* force number of channels */\n\tcase 'n':\n\t\tconf->force_nchannel = atoi(optarg);\n\t\tif (conf->force_nchannel == 0) {\n\t\t\tRTE_LOG(ERR, EAL, \"invalid channel number\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t/* force number of ranks */\n\tcase 'r':\n\t\tconf->force_nrank = atoi(optarg);\n\t\tif (conf->force_nrank == 0 ||\n\t\t    conf->force_nrank > 16) {\n\t\t\tRTE_LOG(ERR, EAL, \"invalid rank number\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t/* force loading of external driver */\n\tcase 'd':\n\t\tif (eal_plugin_add(optarg) == -1)\n\t\t\treturn -1;\n\t\tbreak;\n\tcase 'v':\n\t\t/* since message is explicitly requested by user, we\n\t\t * write message at highest log level so it can always\n\t\t * be seen\n\t\t * even if info or warning messages are disabled */\n\t\tRTE_LOG(CRIT, EAL, \"RTE Version: '%s'\\n\", rte_version());\n\t\tbreak;\n\n\t/* long options */\n\tcase OPT_HUGE_UNLINK_NUM:\n\t\tconf->hugepage_unlink = 1;\n\t\tbreak;\n\n\tcase OPT_NO_HUGE_NUM:\n\t\tconf->no_hugetlbfs = 1;\n\t\t/* no-huge is legacy mem */\n\t\tconf->legacy_mem = 1;\n\t\tbreak;\n\n\tcase OPT_NO_PCI_NUM:\n\t\tconf->no_pci = 1;\n\t\tbreak;\n\n\tcase OPT_NO_HPET_NUM:\n\t\tconf->no_hpet = 1;\n\t\tbreak;\n\n\tcase OPT_VMWARE_TSC_MAP_NUM:\n\t\tconf->vmware_tsc_map = 1;\n\t\tbreak;\n\n\tcase OPT_NO_SHCONF_NUM:\n\t\tconf->no_shconf = 1;\n\t\tbreak;\n\n\tcase OPT_IN_MEMORY_NUM:\n\t\tconf->in_memory = 1;\n\t\t/* in-memory is a superset of noshconf and huge-unlink */\n\t\tconf->no_shconf = 1;\n\t\tconf->hugepage_unlink = 1;\n\t\tbreak;\n\n\tcase OPT_PROC_TYPE_NUM:\n\t\tconf->process_type = eal_parse_proc_type(optarg);\n\t\tbreak;\n\n\tcase OPT_MASTER_LCORE_NUM:\n\t\tif (eal_parse_master_lcore(optarg) < 0) {\n\t\t\tRTE_LOG(ERR, EAL, \"invalid parameter for --\"\n\t\t\t\t\tOPT_MASTER_LCORE \"\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\n\tcase OPT_VDEV_NUM:\n\t\tif (eal_option_device_add(RTE_DEVTYPE_VIRTUAL,\n\t\t\t\toptarg) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\n#ifndef RTE_EXEC_ENV_WINDOWS\n\tcase OPT_SYSLOG_NUM:\n\t\tif (eal_parse_syslog(optarg, conf) < 0) {\n\t\t\tRTE_LOG(ERR, EAL, \"invalid parameters for --\"\n\t\t\t\t\tOPT_SYSLOG \"\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase OPT_LOG_LEVEL_NUM: {\n\t\tif (eal_parse_log_level(optarg) < 0) {\n\t\t\tRTE_LOG(ERR, EAL,\n\t\t\t\t\"invalid parameters for --\"\n\t\t\t\tOPT_LOG_LEVEL \"\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\tcase OPT_LCORES_NUM:\n\t\tif (eal_parse_lcores(optarg) < 0) {\n\t\t\tRTE_LOG(ERR, EAL, \"invalid parameter for --\"\n\t\t\t\tOPT_LCORES \"\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (core_parsed) {\n\t\t\tRTE_LOG(ERR, EAL, \"Option --lcore is ignored, because (%s) is set!\\n\",\n\t\t\t\t(core_parsed == LCORE_OPT_LST) ? \"-l\" :\n\t\t\t\t(core_parsed == LCORE_OPT_MSK) ? \"-c\" :\n\t\t\t\t\"--lcore\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tcore_parsed = LCORE_OPT_MAP;\n\t\tbreak;\n\tcase OPT_LEGACY_MEM_NUM:\n\t\tconf->legacy_mem = 1;\n\t\tbreak;\n\tcase OPT_SINGLE_FILE_SEGMENTS_NUM:\n\t\tconf->single_file_segments = 1;\n\t\tbreak;\n\tcase OPT_IOVA_MODE_NUM:\n\t\tif (eal_parse_iova_mode(optarg) < 0) {\n\t\t\tRTE_LOG(ERR, EAL, \"invalid parameters for --\"\n\t\t\t\tOPT_IOVA_MODE \"\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase OPT_BASE_VIRTADDR_NUM:\n\t\tif (eal_parse_base_virtaddr(optarg) < 0) {\n\t\t\tRTE_LOG(ERR, EAL, \"invalid parameter for --\"\n\t\t\t\t\tOPT_BASE_VIRTADDR \"\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\n\t/* don't know what to do, leave this to caller */\n\tdefault:\n\t\treturn 1;\n\n\t}\n\n\treturn 0;\nbw_used:\n\tRTE_LOG(ERR, EAL, \"Options blacklist (-b) and whitelist (-w) \"\n\t\t\"cannot be used at the same time\\n\");\n\treturn -1;\n}\n\nstatic void\neal_auto_detect_cores(struct rte_config *cfg)\n{\n\tunsigned int lcore_id;\n\tunsigned int removed = 0;\n\trte_cpuset_t affinity_set;\n\n\tif (pthread_getaffinity_np(pthread_self(), sizeof(rte_cpuset_t),\n\t\t\t\t&affinity_set))\n\t\tCPU_ZERO(&affinity_set);\n\n\tfor (lcore_id = 0; lcore_id < RTE_MAX_LCORE; lcore_id++) {\n\t\tif (cfg->lcore_role[lcore_id] == ROLE_RTE &&\n\t\t    !CPU_ISSET(lcore_id, &affinity_set)) {\n\t\t\tcfg->lcore_role[lcore_id] = ROLE_OFF;\n\t\t\tremoved++;\n\t\t}\n\t}\n\n\tcfg->lcore_count -= removed;\n}\n\nstatic void\ncompute_ctrl_threads_cpuset(struct internal_config *internal_cfg)\n{\n\trte_cpuset_t *cpuset = &internal_cfg->ctrl_cpuset;\n\trte_cpuset_t default_set;\n\tunsigned int lcore_id;\n\n\tfor (lcore_id = 0; lcore_id < RTE_MAX_LCORE; lcore_id++) {\n\t\tif (rte_lcore_has_role(lcore_id, ROLE_OFF))\n\t\t\tcontinue;\n\t\tRTE_CPU_OR(cpuset, cpuset, &lcore_config[lcore_id].cpuset);\n\t}\n\tRTE_CPU_NOT(cpuset, cpuset);\n\n\tif (pthread_getaffinity_np(pthread_self(), sizeof(rte_cpuset_t),\n\t\t\t\t&default_set))\n\t\tCPU_ZERO(&default_set);\n\n\tRTE_CPU_AND(cpuset, cpuset, &default_set);\n\n\t/* if no remaining cpu, use master lcore cpu affinity */\n\tif (!CPU_COUNT(cpuset)) {\n\t\tmemcpy(cpuset, &lcore_config[rte_get_master_lcore()].cpuset,\n\t\t\tsizeof(*cpuset));\n\t}\n}\n\nint\neal_cleanup_config(struct internal_config *internal_cfg)\n{\n\tif (internal_cfg->hugefile_prefix != NULL)\n\t\tfree(internal_cfg->hugefile_prefix);\n\tif (internal_cfg->hugepage_dir != NULL)\n\t\tfree(internal_cfg->hugepage_dir);\n\tif (internal_cfg->user_mbuf_pool_ops_name != NULL)\n\t\tfree(internal_cfg->user_mbuf_pool_ops_name);\n\n\treturn 0;\n}\n\nint\neal_adjust_config(struct internal_config *internal_cfg)\n{\n\tint i;\n\tstruct rte_config *cfg = rte_eal_get_configuration();\n\n\tif (!core_parsed)\n\t\teal_auto_detect_cores(cfg);\n\n\tif (internal_config.process_type == RTE_PROC_AUTO)\n\t\tinternal_config.process_type = eal_proc_type_detect();\n\n\t/* default master lcore is the first one */\n\tif (!master_lcore_parsed) {\n\t\tcfg->master_lcore = rte_get_next_lcore(-1, 0, 0);\n\t\tif (cfg->master_lcore >= RTE_MAX_LCORE)\n\t\t\treturn -1;\n\t\tlcore_config[cfg->master_lcore].core_role = ROLE_RTE;\n\t}\n\n\tcompute_ctrl_threads_cpuset(internal_cfg);\n\n\t/* if no memory amounts were requested, this will result in 0 and\n\t * will be overridden later, right after eal_hugepage_info_init() */\n\tfor (i = 0; i < RTE_MAX_NUMA_NODES; i++)\n\t\tinternal_cfg->memory += internal_cfg->socket_mem[i];\n\n\treturn 0;\n}\n\nint\neal_check_common_options(struct internal_config *internal_cfg)\n{\n\tstruct rte_config *cfg = rte_eal_get_configuration();\n\n\tif (cfg->lcore_role[cfg->master_lcore] != ROLE_RTE) {\n\t\tRTE_LOG(ERR, EAL, \"Master lcore is not enabled for DPDK\\n\");\n\t\treturn -1;\n\t}\n\n\tif (internal_cfg->process_type == RTE_PROC_INVALID) {\n\t\tRTE_LOG(ERR, EAL, \"Invalid process type specified\\n\");\n\t\treturn -1;\n\t}\n\tif (internal_cfg->hugefile_prefix != NULL &&\n\t\t\tstrlen(internal_cfg->hugefile_prefix) < 1) {\n\t\tRTE_LOG(ERR, EAL, \"Invalid length of --\" OPT_FILE_PREFIX \" option\\n\");\n\t\treturn -1;\n\t}\n\tif (internal_cfg->hugepage_dir != NULL &&\n\t\t\tstrlen(internal_cfg->hugepage_dir) < 1) {\n\t\tRTE_LOG(ERR, EAL, \"Invalid length of --\" OPT_HUGE_DIR\" option\\n\");\n\t\treturn -1;\n\t}\n\tif (internal_cfg->user_mbuf_pool_ops_name != NULL &&\n\t\t\tstrlen(internal_cfg->user_mbuf_pool_ops_name) < 1) {\n\t\tRTE_LOG(ERR, EAL, \"Invalid length of --\" OPT_MBUF_POOL_OPS_NAME\" option\\n\");\n\t\treturn -1;\n\t}\n\tif (index(eal_get_hugefile_prefix(), '%') != NULL) {\n\t\tRTE_LOG(ERR, EAL, \"Invalid char, '%%', in --\"OPT_FILE_PREFIX\" \"\n\t\t\t\"option\\n\");\n\t\treturn -1;\n\t}\n\tif (mem_parsed && internal_cfg->force_sockets == 1) {\n\t\tRTE_LOG(ERR, EAL, \"Options -m and --\"OPT_SOCKET_MEM\" cannot \"\n\t\t\t\"be specified at the same time\\n\");\n\t\treturn -1;\n\t}\n\tif (internal_cfg->no_hugetlbfs && internal_cfg->force_sockets == 1) {\n\t\tRTE_LOG(ERR, EAL, \"Option --\"OPT_SOCKET_MEM\" cannot \"\n\t\t\t\"be specified together with --\"OPT_NO_HUGE\"\\n\");\n\t\treturn -1;\n\t}\n\tif (internal_cfg->no_hugetlbfs && internal_cfg->hugepage_unlink &&\n\t\t\t!internal_cfg->in_memory) {\n\t\tRTE_LOG(ERR, EAL, \"Option --\"OPT_HUGE_UNLINK\" cannot \"\n\t\t\t\"be specified together with --\"OPT_NO_HUGE\"\\n\");\n\t\treturn -1;\n\t}\n\tif (internal_config.force_socket_limits && internal_config.legacy_mem) {\n\t\tRTE_LOG(ERR, EAL, \"Option --\"OPT_SOCKET_LIMIT\n\t\t\t\" is only supported in non-legacy memory mode\\n\");\n\t}\n\tif (internal_cfg->single_file_segments &&\n\t\t\tinternal_cfg->hugepage_unlink &&\n\t\t\t!internal_cfg->in_memory) {\n\t\tRTE_LOG(ERR, EAL, \"Option --\"OPT_SINGLE_FILE_SEGMENTS\" is \"\n\t\t\t\"not compatible with --\"OPT_HUGE_UNLINK\"\\n\");\n\t\treturn -1;\n\t}\n\tif (internal_cfg->legacy_mem &&\n\t\t\tinternal_cfg->in_memory) {\n\t\tRTE_LOG(ERR, EAL, \"Option --\"OPT_LEGACY_MEM\" is not compatible \"\n\t\t\t\t\"with --\"OPT_IN_MEMORY\"\\n\");\n\t\treturn -1;\n\t}\n\tif (internal_cfg->legacy_mem && internal_cfg->match_allocations) {\n\t\tRTE_LOG(ERR, EAL, \"Option --\"OPT_LEGACY_MEM\" is not compatible \"\n\t\t\t\t\"with --\"OPT_MATCH_ALLOCATIONS\"\\n\");\n\t\treturn -1;\n\t}\n\tif (internal_cfg->no_hugetlbfs && internal_cfg->match_allocations) {\n\t\tRTE_LOG(ERR, EAL, \"Option --\"OPT_NO_HUGE\" is not compatible \"\n\t\t\t\t\"with --\"OPT_MATCH_ALLOCATIONS\"\\n\");\n\t\treturn -1;\n\t}\n\tif (internal_cfg->legacy_mem && internal_cfg->memory == 0) {\n\t\tRTE_LOG(NOTICE, EAL, \"Static memory layout is selected, \"\n\t\t\t\"amount of reserved memory can be adjusted with \"\n\t\t\t\"-m or --\"OPT_SOCKET_MEM\"\\n\");\n\t}\n\n\treturn 0;\n}\n\nvoid\neal_common_usage(void)\n{\n\tprintf(\"[options]\\n\\n\"\n\t       \"EAL common options:\\n\"\n\t       \"  -c COREMASK         Hexadecimal bitmask of cores to run on\\n\"\n\t       \"  -l CORELIST         List of cores to run on\\n\"\n\t       \"                      The argument format is <c1>[-c2][,c3[-c4],...]\\n\"\n\t       \"                      where c1, c2, etc are core indexes between 0 and %d\\n\"\n\t       \"  --\"OPT_LCORES\" COREMAP    Map lcore set to physical cpu set\\n\"\n\t       \"                      The argument format is\\n\"\n\t       \"                            '<lcores[@cpus]>[<,lcores[@cpus]>...]'\\n\"\n\t       \"                      lcores and cpus list are grouped by '(' and ')'\\n\"\n\t       \"                      Within the group, '-' is used for range separator,\\n\"\n\t       \"                      ',' is used for single number separator.\\n\"\n\t       \"                      '( )' can be omitted for single element group,\\n\"\n\t       \"                      '@' can be omitted if cpus and lcores have the same value\\n\"\n\t       \"  -s SERVICE COREMASK Hexadecimal bitmask of cores to be used as service cores\\n\"\n\t       \"  --\"OPT_MASTER_LCORE\" ID   Core ID that is used as master\\n\"\n\t       \"  --\"OPT_MBUF_POOL_OPS_NAME\" Pool ops name for mbuf to use\\n\"\n\t       \"  -n CHANNELS         Number of memory channels\\n\"\n\t       \"  -m MB               Memory to allocate (see also --\"OPT_SOCKET_MEM\")\\n\"\n\t       \"  -r RANKS            Force number of memory ranks (don't detect)\\n\"\n\t       \"  -b, --\"OPT_PCI_BLACKLIST\" Add a PCI device in black list.\\n\"\n\t       \"                      Prevent EAL from using this PCI device. The argument\\n\"\n\t       \"                      format is <domain:bus:devid.func>.\\n\"\n\t       \"  -w, --\"OPT_PCI_WHITELIST\" Add a PCI device in white list.\\n\"\n\t       \"                      Only use the specified PCI devices. The argument format\\n\"\n\t       \"                      is <[domain:]bus:devid.func>. This option can be present\\n\"\n\t       \"                      several times (once per device).\\n\"\n\t       \"                      [NOTE: PCI whitelist cannot be used with -b option]\\n\"\n\t       \"  --\"OPT_VDEV\"              Add a virtual device.\\n\"\n\t       \"                      The argument format is <driver><id>[,key=val,...]\\n\"\n\t       \"                      (ex: --vdev=net_pcap0,iface=eth2).\\n\"\n\t       \"  --\"OPT_IOVA_MODE\"   Set IOVA mode. 'pa' for IOVA_PA\\n\"\n\t       \"                      'va' for IOVA_VA\\n\"\n\t       \"  -d LIB.so|DIR       Add a driver or driver directory\\n\"\n\t       \"                      (can be used multiple times)\\n\"\n\t       \"  --\"OPT_VMWARE_TSC_MAP\"    Use VMware TSC map instead of native RDTSC\\n\"\n\t       \"  --\"OPT_PROC_TYPE\"         Type of this process (primary|secondary|auto)\\n\"\n#ifndef RTE_EXEC_ENV_WINDOWS\n\t       \"  --\"OPT_SYSLOG\"            Set syslog facility\\n\"\n#endif\n\t       \"  --\"OPT_LOG_LEVEL\"=<int>   Set global log level\\n\"\n\t       \"  --\"OPT_LOG_LEVEL\"=<type-match>:<int>\\n\"\n\t       \"                      Set specific log level\\n\"\n\t       \"  -v                  Display version information on startup\\n\"\n\t       \"  -h, --help          This help\\n\"\n\t       \"  --\"OPT_IN_MEMORY\"   Operate entirely in memory. This will\\n\"\n\t       \"                      disable secondary process support\\n\"\n\t       \"  --\"OPT_BASE_VIRTADDR\"     Base virtual address\\n\"\n\t       \"\\nEAL options for DEBUG use only:\\n\"\n\t       \"  --\"OPT_HUGE_UNLINK\"       Unlink hugepage files after init\\n\"\n\t       \"  --\"OPT_NO_HUGE\"           Use malloc instead of hugetlbfs\\n\"\n\t       \"  --\"OPT_NO_PCI\"            Disable PCI\\n\"\n\t       \"  --\"OPT_NO_HPET\"           Disable HPET\\n\"\n\t       \"  --\"OPT_NO_SHCONF\"         No shared config (mmap'd files)\\n\"\n\t       \"\\n\", RTE_MAX_LCORE);\n\trte_option_usage();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/drivers/common/mlx5/meson.build": "# SPDX-License-Identifier: BSD-3-Clause\n# Copyright 2019 Mellanox Technologies, Ltd\n\nif not is_linux\n\tbuild = false\n\treason = 'only supported on Linux'\n\tsubdir_done()\nendif\n\nstatic_ibverbs = (get_option('ibverbs_link') == 'static')\ndlopen_ibverbs = (get_option('ibverbs_link') == 'dlopen')\nLIB_GLUE_BASE = 'librte_pmd_mlx5_glue.so'\nLIB_GLUE_VERSION = '20.02.0'\nLIB_GLUE = LIB_GLUE_BASE + '.' + LIB_GLUE_VERSION\nif dlopen_ibverbs\n\tdpdk_conf.set('RTE_IBVERBS_LINK_DLOPEN', 1)\n\tcflags += [\n\t\t'-DMLX5_GLUE=\"@0@\"'.format(LIB_GLUE),\n\t\t'-DMLX5_GLUE_VERSION=\"@0@\"'.format(LIB_GLUE_VERSION),\n\t]\nendif\n\nlibnames = [ 'mlx5', 'ibverbs' ]\nlibs = []\nforeach libname:libnames\n\tlib = dependency('lib' + libname, static:static_ibverbs, required:false)\n\tif not lib.found() and not static_ibverbs\n\t\tlib = cc.find_library(libname, required:false)\n\tendif\n\tif lib.found()\n\t\tlibs += lib\n\t\tif not static_ibverbs and not dlopen_ibverbs\n\t\t\text_deps += lib\n\t\tendif\n\telse\n\t\tbuild = false\n\t\treason = 'missing dependency, \"' + libname + '\"'\n\t\tsubdir_done()\n\tendif\nendforeach\nif static_ibverbs or dlopen_ibverbs\n\t# Build without adding shared libs to Requires.private\n\tibv_cflags = run_command(pkgconf, '--cflags', 'libibverbs').stdout()\n\text_deps += declare_dependency(compile_args: ibv_cflags.split())\nendif\nif static_ibverbs\n\t# Add static deps ldflags to internal apps and Libs.private\n\tibv_ldflags = run_command(ldflags_ibverbs_static, check:true).stdout()\n\text_deps += declare_dependency(link_args:ibv_ldflags.split())\nendif\n\nallow_experimental_apis = true\ndeps += ['hash', 'pci', 'net', 'eal', 'kvargs']\nsources = files(\n\t'mlx5_devx_cmds.c',\n\t'mlx5_common.c',\n\t'mlx5_nl.c',\n)\nif not dlopen_ibverbs\n\tsources += files('mlx5_glue.c')\nendif\ncflags_options = [\n\t'-std=c11',\n\t'-Wno-strict-prototypes',\n\t'-D_BSD_SOURCE',\n\t'-D_DEFAULT_SOURCE',\n\t'-D_XOPEN_SOURCE=600'\n]\nforeach option:cflags_options\n\tif cc.has_argument(option)\n\t\tcflags += option\n\tendif\nendforeach\nif get_option('buildtype').contains('debug')\n\tcflags += [ '-pedantic', '-DPEDANTIC' ]\nelse\n\tcflags += [ '-UPEDANTIC' ]\nendif\n# To maintain the compatibility with the make build system\n# mlx5_autoconf.h file is still generated.\n# input array for meson member search:\n# [ \"MACRO to define if found\", \"header for the search\",\n#   \"symbol to search\", \"struct member to search\" ]\nhas_member_args = [\n\t[ 'HAVE_IBV_MLX5_MOD_SWP', 'infiniband/mlx5dv.h',\n\t'struct mlx5dv_sw_parsing_caps', 'sw_parsing_offloads' ],\n\t[ 'HAVE_IBV_DEVICE_COUNTERS_SET_V42', 'infiniband/verbs.h',\n\t'struct ibv_counter_set_init_attr', 'counter_set_id' ],\n\t[ 'HAVE_IBV_DEVICE_COUNTERS_SET_V45', 'infiniband/verbs.h',\n\t'struct ibv_counters_init_attr', 'comp_mask' ],\n]\n# input array for meson symbol search:\n# [ \"MACRO to define if found\", \"header for the search\",\n#   \"symbol to search\" ]\nhas_sym_args = [\n\t[ 'HAVE_IBV_DEVICE_STRIDING_RQ_SUPPORT', 'infiniband/mlx5dv.h',\n\t'MLX5DV_CQE_RES_FORMAT_CSUM_STRIDX' ],\n\t[ 'HAVE_IBV_DEVICE_TUNNEL_SUPPORT', 'infiniband/mlx5dv.h',\n\t'MLX5DV_CONTEXT_MASK_TUNNEL_OFFLOADS' ],\n\t[ 'HAVE_IBV_MLX5_MOD_MPW', 'infiniband/mlx5dv.h',\n\t'MLX5DV_CONTEXT_FLAGS_MPW_ALLOWED' ],\n\t[ 'HAVE_IBV_MLX5_MOD_CQE_128B_COMP', 'infiniband/mlx5dv.h',\n\t'MLX5DV_CONTEXT_FLAGS_CQE_128B_COMP' ],\n\t[ 'HAVE_IBV_MLX5_MOD_CQE_128B_PAD', 'infiniband/mlx5dv.h',\n\t'MLX5DV_CQ_INIT_ATTR_FLAGS_CQE_PAD' ],\n\t[ 'HAVE_IBV_FLOW_DV_SUPPORT', 'infiniband/mlx5dv.h',\n\t'mlx5dv_create_flow_action_packet_reformat' ],\n\t[ 'HAVE_IBV_DEVICE_MPLS_SUPPORT', 'infiniband/verbs.h',\n\t'IBV_FLOW_SPEC_MPLS' ],\n\t[ 'HAVE_IBV_WQ_FLAGS_PCI_WRITE_END_PADDING', 'infiniband/verbs.h',\n\t'IBV_WQ_FLAGS_PCI_WRITE_END_PADDING' ],\n\t[ 'HAVE_IBV_WQ_FLAG_RX_END_PADDING', 'infiniband/verbs.h',\n\t'IBV_WQ_FLAG_RX_END_PADDING' ],\n\t[ 'HAVE_MLX5DV_DR_DEVX_PORT', 'infiniband/mlx5dv.h',\n\t'mlx5dv_query_devx_port' ],\n\t[ 'HAVE_IBV_DEVX_OBJ', 'infiniband/mlx5dv.h',\n\t'mlx5dv_devx_obj_create' ],\n\t[ 'HAVE_IBV_FLOW_DEVX_COUNTERS', 'infiniband/mlx5dv.h',\n\t'MLX5DV_FLOW_ACTION_COUNTERS_DEVX' ],\n\t[ 'HAVE_IBV_DEVX_ASYNC', 'infiniband/mlx5dv.h',\n\t'mlx5dv_devx_obj_query_async' ],\n\t[ 'HAVE_MLX5DV_DR_ACTION_DEST_DEVX_TIR', 'infiniband/mlx5dv.h',\n\t'mlx5dv_dr_action_create_dest_devx_tir' ],\n\t[ 'HAVE_IBV_DEVX_EVENT', 'infiniband/mlx5dv.h',\n\t'mlx5dv_devx_get_event' ],\n\t[ 'HAVE_MLX5_DR_CREATE_ACTION_FLOW_METER', 'infiniband/mlx5dv.h',\n\t'mlx5dv_dr_action_create_flow_meter' ],\n\t[ 'HAVE_MLX5DV_MMAP_GET_NC_PAGES_CMD', 'infiniband/mlx5dv.h',\n\t'MLX5_MMAP_GET_NC_PAGES_CMD' ],\n\t[ 'HAVE_MLX5DV_DR', 'infiniband/mlx5dv.h',\n\t'MLX5DV_DR_DOMAIN_TYPE_NIC_RX' ],\n\t[ 'HAVE_MLX5DV_DR_ESWITCH', 'infiniband/mlx5dv.h',\n\t'MLX5DV_DR_DOMAIN_TYPE_FDB' ],\n\t[ 'HAVE_MLX5DV_DR_VLAN', 'infiniband/mlx5dv.h',\n\t'mlx5dv_dr_action_create_push_vlan' ],\n\t[ 'HAVE_IBV_VAR', 'infiniband/mlx5dv.h', 'mlx5dv_alloc_var' ],\n\t[ 'HAVE_SUPPORTED_40000baseKR4_Full', 'linux/ethtool.h',\n\t'SUPPORTED_40000baseKR4_Full' ],\n\t[ 'HAVE_SUPPORTED_40000baseCR4_Full', 'linux/ethtool.h',\n\t'SUPPORTED_40000baseCR4_Full' ],\n\t[ 'HAVE_SUPPORTED_40000baseSR4_Full', 'linux/ethtool.h',\n\t'SUPPORTED_40000baseSR4_Full' ],\n\t[ 'HAVE_SUPPORTED_40000baseLR4_Full', 'linux/ethtool.h',\n\t'SUPPORTED_40000baseLR4_Full' ],\n\t[ 'HAVE_SUPPORTED_56000baseKR4_Full', 'linux/ethtool.h',\n\t'SUPPORTED_56000baseKR4_Full' ],\n\t[ 'HAVE_SUPPORTED_56000baseCR4_Full', 'linux/ethtool.h',\n\t'SUPPORTED_56000baseCR4_Full' ],\n\t[ 'HAVE_SUPPORTED_56000baseSR4_Full', 'linux/ethtool.h',\n\t'SUPPORTED_56000baseSR4_Full' ],\n\t[ 'HAVE_SUPPORTED_56000baseLR4_Full', 'linux/ethtool.h',\n\t'SUPPORTED_56000baseLR4_Full' ],\n\t[ 'HAVE_ETHTOOL_LINK_MODE_25G', 'linux/ethtool.h',\n\t'ETHTOOL_LINK_MODE_25000baseCR_Full_BIT' ],\n\t[ 'HAVE_ETHTOOL_LINK_MODE_50G', 'linux/ethtool.h',\n\t'ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT' ],\n\t[ 'HAVE_ETHTOOL_LINK_MODE_100G', 'linux/ethtool.h',\n\t'ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT' ],\n\t[ 'HAVE_IFLA_NUM_VF', 'linux/if_link.h',\n\t'IFLA_NUM_VF' ],\n\t[ 'HAVE_IFLA_EXT_MASK', 'linux/if_link.h',\n\t'IFLA_EXT_MASK' ],\n\t[ 'HAVE_IFLA_PHYS_SWITCH_ID', 'linux/if_link.h',\n\t'IFLA_PHYS_SWITCH_ID' ],\n\t[ 'HAVE_IFLA_PHYS_PORT_NAME', 'linux/if_link.h',\n\t'IFLA_PHYS_PORT_NAME' ],\n\t[ 'HAVE_RDMA_NL_NLDEV', 'rdma/rdma_netlink.h',\n\t'RDMA_NL_NLDEV' ],\n\t[ 'HAVE_RDMA_NLDEV_CMD_GET', 'rdma/rdma_netlink.h',\n\t'RDMA_NLDEV_CMD_GET' ],\n\t[ 'HAVE_RDMA_NLDEV_CMD_PORT_GET', 'rdma/rdma_netlink.h',\n\t'RDMA_NLDEV_CMD_PORT_GET' ],\n\t[ 'HAVE_RDMA_NLDEV_ATTR_DEV_INDEX', 'rdma/rdma_netlink.h',\n\t'RDMA_NLDEV_ATTR_DEV_INDEX' ],\n\t[ 'HAVE_RDMA_NLDEV_ATTR_DEV_NAME', 'rdma/rdma_netlink.h',\n\t'RDMA_NLDEV_ATTR_DEV_NAME' ],\n\t[ 'HAVE_RDMA_NLDEV_ATTR_PORT_INDEX', 'rdma/rdma_netlink.h',\n\t'RDMA_NLDEV_ATTR_PORT_INDEX' ],\n\t[ 'HAVE_RDMA_NLDEV_ATTR_NDEV_INDEX', 'rdma/rdma_netlink.h',\n\t'RDMA_NLDEV_ATTR_NDEV_INDEX' ],\n\t[ 'HAVE_MLX5_DR_FLOW_DUMP', 'infiniband/mlx5dv.h',\n\t'mlx5dv_dump_dr_domain'],\n\t[ 'HAVE_DEVLINK', 'linux/devlink.h', 'DEVLINK_GENL_NAME' ],\n]\nconfig = configuration_data()\nforeach arg:has_sym_args\n\tconfig.set(arg[0], cc.has_header_symbol(arg[1], arg[2],\n\t\tdependencies: libs))\nendforeach\nforeach arg:has_member_args\n\tfile_prefix = '#include <' + arg[1] + '>'\n\tconfig.set(arg[0], cc.has_member(arg[2], arg[3],\n\t\tprefix : file_prefix, dependencies: libs))\nendforeach\nconfigure_file(output : 'mlx5_autoconf.h', configuration : config)\n\n# Build Glue Library\nif dlopen_ibverbs\n\tdlopen_name = 'mlx5_glue'\n\tdlopen_lib_name = 'rte_pmd_@0@'.format(dlopen_name)\n\tdlopen_so_version = LIB_GLUE_VERSION\n\tdlopen_sources = files('mlx5_glue.c')\n\tdlopen_install_dir = [ eal_pmd_path + '-glue' ]\n\tdlopen_includes = [global_inc]\n\tdlopen_includes += include_directories(\n\t\t'../../../lib/librte_eal/common/include/generic',\n\t)\n\tshared_lib = shared_library(\n\t\tdlopen_lib_name,\n\t\tdlopen_sources,\n\t\tinclude_directories: dlopen_includes,\n\t\tc_args: cflags,\n\t\tdependencies: libs,\n\t\tlink_args: [\n\t\t'-Wl,-export-dynamic',\n\t\t'-Wl,-h,@0@'.format(LIB_GLUE),\n\t\t],\n\t\tsoversion: dlopen_so_version,\n\t\tinstall: true,\n\t\tinstall_dir: dlopen_install_dir,\n\t)\nendif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/drivers/common/mlx5/mlx5_common.c": "/* SPDX-License-Identifier: BSD-3-Clause\n * Copyright 2019 Mellanox Technologies, Ltd\n */\n\n#include <dlfcn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n\n#include <rte_errno.h>\n\n#include \"mlx5_common.h\"\n#include \"mlx5_common_utils.h\"\n#include \"mlx5_glue.h\"\n\n\nint mlx5_common_logtype;\n\n\n/**\n * Get PCI information by sysfs device path.\n *\n * @param dev_path\n *   Pointer to device sysfs folder name.\n * @param[out] pci_addr\n *   PCI bus address output buffer.\n *\n * @return\n *   0 on success, a negative errno value otherwise and rte_errno is set.\n */\nint\nmlx5_dev_to_pci_addr(const char *dev_path,\n\t\t     struct rte_pci_addr *pci_addr)\n{\n\tFILE *file;\n\tchar line[32];\n\tMKSTR(path, \"%s/device/uevent\", dev_path);\n\n\tfile = fopen(path, \"rb\");\n\tif (file == NULL) {\n\t\trte_errno = errno;\n\t\treturn -rte_errno;\n\t}\n\twhile (fgets(line, sizeof(line), file) == line) {\n\t\tsize_t len = strlen(line);\n\t\tint ret;\n\n\t\t/* Truncate long lines. */\n\t\tif (len == (sizeof(line) - 1))\n\t\t\twhile (line[(len - 1)] != '\\n') {\n\t\t\t\tret = fgetc(file);\n\t\t\t\tif (ret == EOF)\n\t\t\t\t\tbreak;\n\t\t\t\tline[(len - 1)] = ret;\n\t\t\t}\n\t\t/* Extract information. */\n\t\tif (sscanf(line,\n\t\t\t   \"PCI_SLOT_NAME=\"\n\t\t\t   \"%\" SCNx32 \":%\" SCNx8 \":%\" SCNx8 \".%\" SCNx8 \"\\n\",\n\t\t\t   &pci_addr->domain,\n\t\t\t   &pci_addr->bus,\n\t\t\t   &pci_addr->devid,\n\t\t\t   &pci_addr->function) == 4) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(file);\n\treturn 0;\n}\n\nstatic int\nmlx5_class_check_handler(__rte_unused const char *key, const char *value,\n\t\t\t void *opaque)\n{\n\tenum mlx5_class *ret = opaque;\n\n\tif (strcmp(value, \"vdpa\") == 0) {\n\t\t*ret = MLX5_CLASS_VDPA;\n\t} else if (strcmp(value, \"net\") == 0) {\n\t\t*ret = MLX5_CLASS_NET;\n\t} else {\n\t\tDRV_LOG(ERR, \"Invalid mlx5 class %s. Maybe typo in device\"\n\t\t\t\" class argument setting?\", value);\n\t\t*ret = MLX5_CLASS_INVALID;\n\t}\n\treturn 0;\n}\n\nenum mlx5_class\nmlx5_class_get(struct rte_devargs *devargs)\n{\n\tstruct rte_kvargs *kvlist;\n\tconst char *key = MLX5_CLASS_ARG_NAME;\n\tenum mlx5_class ret = MLX5_CLASS_NET;\n\n\tif (devargs == NULL)\n\t\treturn ret;\n\tkvlist = rte_kvargs_parse(devargs->args, NULL);\n\tif (kvlist == NULL)\n\t\treturn ret;\n\tif (rte_kvargs_count(kvlist, key))\n\t\trte_kvargs_process(kvlist, key, mlx5_class_check_handler, &ret);\n\trte_kvargs_free(kvlist);\n\treturn ret;\n}\n\n/**\n * Extract port name, as a number, from sysfs or netlink information.\n *\n * @param[in] port_name_in\n *   String representing the port name.\n * @param[out] port_info_out\n *   Port information, including port name as a number and port name\n *   type if recognized\n *\n * @return\n *   port_name field set according to recognized name format.\n */\nvoid\nmlx5_translate_port_name(const char *port_name_in,\n\t\t\t struct mlx5_switch_info *port_info_out)\n{\n\tchar pf_c1, pf_c2, vf_c1, vf_c2;\n\tchar *end;\n\tint sc_items;\n\n\t/*\n\t * Check for port-name as a string of the form pf0vf0\n\t * (support kernel ver >= 5.0 or OFED ver >= 4.6).\n\t */\n\tsc_items = sscanf(port_name_in, \"%c%c%d%c%c%d\",\n\t\t\t  &pf_c1, &pf_c2, &port_info_out->pf_num,\n\t\t\t  &vf_c1, &vf_c2, &port_info_out->port_name);\n\tif (sc_items == 6 &&\n\t    pf_c1 == 'p' && pf_c2 == 'f' &&\n\t    vf_c1 == 'v' && vf_c2 == 'f') {\n\t\tport_info_out->name_type = MLX5_PHYS_PORT_NAME_TYPE_PFVF;\n\t\treturn;\n\t}\n\t/*\n\t * Check for port-name as a string of the form p0\n\t * (support kernel ver >= 5.0, or OFED ver >= 4.6).\n\t */\n\tsc_items = sscanf(port_name_in, \"%c%d\",\n\t\t\t  &pf_c1, &port_info_out->port_name);\n\tif (sc_items == 2 && pf_c1 == 'p') {\n\t\tport_info_out->name_type = MLX5_PHYS_PORT_NAME_TYPE_UPLINK;\n\t\treturn;\n\t}\n\t/* Check for port-name as a number (support kernel ver < 5.0 */\n\terrno = 0;\n\tport_info_out->port_name = strtol(port_name_in, &end, 0);\n\tif (!errno &&\n\t    (size_t)(end - port_name_in) == strlen(port_name_in)) {\n\t\tport_info_out->name_type = MLX5_PHYS_PORT_NAME_TYPE_LEGACY;\n\t\treturn;\n\t}\n\tport_info_out->name_type = MLX5_PHYS_PORT_NAME_TYPE_UNKNOWN;\n\treturn;\n}\n\n#ifdef RTE_IBVERBS_LINK_DLOPEN\n\n/**\n * Suffix RTE_EAL_PMD_PATH with \"-glue\".\n *\n * This function performs a sanity check on RTE_EAL_PMD_PATH before\n * suffixing its last component.\n *\n * @param buf[out]\n *   Output buffer, should be large enough otherwise NULL is returned.\n * @param size\n *   Size of @p out.\n *\n * @return\n *   Pointer to @p buf or @p NULL in case suffix cannot be appended.\n */\nstatic char *\nmlx5_glue_path(char *buf, size_t size)\n{\n\tstatic const char *const bad[] = { \"/\", \".\", \"..\", NULL };\n\tconst char *path = RTE_EAL_PMD_PATH;\n\tsize_t len = strlen(path);\n\tsize_t off;\n\tint i;\n\n\twhile (len && path[len - 1] == '/')\n\t\t--len;\n\tfor (off = len; off && path[off - 1] != '/'; --off)\n\t\t;\n\tfor (i = 0; bad[i]; ++i)\n\t\tif (!strncmp(path + off, bad[i], (int)(len - off)))\n\t\t\tgoto error;\n\ti = snprintf(buf, size, \"%.*s-glue\", (int)len, path);\n\tif (i == -1 || (size_t)i >= size)\n\t\tgoto error;\n\treturn buf;\nerror:\n\tRTE_LOG(ERR, PMD, \"unable to append \\\"-glue\\\" to last component of\"\n\t\t\" RTE_EAL_PMD_PATH (\\\"\" RTE_EAL_PMD_PATH \"\\\"), please\"\n\t\t\" re-configure DPDK\");\n\treturn NULL;\n}\n#endif\n\n/**\n * Initialization routine for run-time dependency on rdma-core.\n */\nRTE_INIT_PRIO(mlx5_glue_init, CLASS)\n{\n\tvoid *handle = NULL;\n\n\t/* Initialize common log type. */\n\tmlx5_common_logtype = rte_log_register(\"pmd.common.mlx5\");\n\tif (mlx5_common_logtype >= 0)\n\t\trte_log_set_level(mlx5_common_logtype, RTE_LOG_NOTICE);\n\t/*\n\t * RDMAV_HUGEPAGES_SAFE tells ibv_fork_init() we intend to use\n\t * huge pages. Calling ibv_fork_init() during init allows\n\t * applications to use fork() safely for purposes other than\n\t * using this PMD, which is not supported in forked processes.\n\t */\n\tsetenv(\"RDMAV_HUGEPAGES_SAFE\", \"1\", 1);\n\t/* Match the size of Rx completion entry to the size of a cacheline. */\n\tif (RTE_CACHE_LINE_SIZE == 128)\n\t\tsetenv(\"MLX5_CQE_SIZE\", \"128\", 0);\n\t/*\n\t * MLX5_DEVICE_FATAL_CLEANUP tells ibv_destroy functions to\n\t * cleanup all the Verbs resources even when the device was removed.\n\t */\n\tsetenv(\"MLX5_DEVICE_FATAL_CLEANUP\", \"1\", 1);\n\t/* The glue initialization was done earlier by mlx5 common library. */\n#ifdef RTE_IBVERBS_LINK_DLOPEN\n\tchar glue_path[sizeof(RTE_EAL_PMD_PATH) - 1 + sizeof(\"-glue\")];\n\tconst char *path[] = {\n\t\t/*\n\t\t * A basic security check is necessary before trusting\n\t\t * MLX5_GLUE_PATH, which may override RTE_EAL_PMD_PATH.\n\t\t */\n\t\t(geteuid() == getuid() && getegid() == getgid() ?\n\t\t getenv(\"MLX5_GLUE_PATH\") : NULL),\n\t\t/*\n\t\t * When RTE_EAL_PMD_PATH is set, use its glue-suffixed\n\t\t * variant, otherwise let dlopen() look up libraries on its\n\t\t * own.\n\t\t */\n\t\t(*RTE_EAL_PMD_PATH ?\n\t\t mlx5_glue_path(glue_path, sizeof(glue_path)) : \"\"),\n\t};\n\tunsigned int i = 0;\n\tvoid **sym;\n\tconst char *dlmsg;\n\n\twhile (!handle && i != RTE_DIM(path)) {\n\t\tconst char *end;\n\t\tsize_t len;\n\t\tint ret;\n\n\t\tif (!path[i]) {\n\t\t\t++i;\n\t\t\tcontinue;\n\t\t}\n\t\tend = strpbrk(path[i], \":;\");\n\t\tif (!end)\n\t\t\tend = path[i] + strlen(path[i]);\n\t\tlen = end - path[i];\n\t\tret = 0;\n\t\tdo {\n\t\t\tchar name[ret + 1];\n\n\t\t\tret = snprintf(name, sizeof(name), \"%.*s%s\" MLX5_GLUE,\n\t\t\t\t       (int)len, path[i],\n\t\t\t\t       (!len || *(end - 1) == '/') ? \"\" : \"/\");\n\t\t\tif (ret == -1)\n\t\t\t\tbreak;\n\t\t\tif (sizeof(name) != (size_t)ret + 1)\n\t\t\t\tcontinue;\n\t\t\tDRV_LOG(DEBUG, \"Looking for rdma-core glue as \"\n\t\t\t\t\"\\\"%s\\\"\", name);\n\t\t\thandle = dlopen(name, RTLD_LAZY);\n\t\t\tbreak;\n\t\t} while (1);\n\t\tpath[i] = end + 1;\n\t\tif (!*end)\n\t\t\t++i;\n\t}\n\tif (!handle) {\n\t\trte_errno = EINVAL;\n\t\tdlmsg = dlerror();\n\t\tif (dlmsg)\n\t\t\tDRV_LOG(WARNING, \"Cannot load glue library: %s\", dlmsg);\n\t\tgoto glue_error;\n\t}\n\tsym = dlsym(handle, \"mlx5_glue\");\n\tif (!sym || !*sym) {\n\t\trte_errno = EINVAL;\n\t\tdlmsg = dlerror();\n\t\tif (dlmsg)\n\t\t\tDRV_LOG(ERR, \"Cannot resolve glue symbol: %s\", dlmsg);\n\t\tgoto glue_error;\n\t}\n\tmlx5_glue = *sym;\n#endif /* RTE_IBVERBS_LINK_DLOPEN */\n#ifdef RTE_LIBRTE_MLX5_DEBUG\n\t/* Glue structure must not contain any NULL pointers. */\n\t{\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i != sizeof(*mlx5_glue) / sizeof(void *); ++i)\n\t\t\tMLX5_ASSERT(((const void *const *)mlx5_glue)[i]);\n\t}\n#endif\n\tif (strcmp(mlx5_glue->version, MLX5_GLUE_VERSION)) {\n\t\trte_errno = EINVAL;\n\t\tDRV_LOG(ERR, \"rdma-core glue \\\"%s\\\" mismatch: \\\"%s\\\" is \"\n\t\t\t\"required\", mlx5_glue->version, MLX5_GLUE_VERSION);\n\t\tgoto glue_error;\n\t}\n\tmlx5_glue->fork_init();\n\treturn;\nglue_error:\n\tif (handle)\n\t\tdlclose(handle);\n\tDRV_LOG(WARNING, \"Cannot initialize MLX5 common due to missing\"\n\t\t\" run-time dependency on rdma-core libraries (libibverbs,\"\n\t\t\" libmlx5)\");\n\tmlx5_glue = NULL;\n\treturn;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/drivers/net/mlx4/meson.build": "# SPDX-License-Identifier: BSD-3-Clause\n# Copyright 2018 6WIND S.A.\n# Copyright 2018 Mellanox Technologies, Ltd\n\nif not is_linux\n\tbuild = false\n\treason = 'only supported on Linux'\n\tsubdir_done()\nendif\n\nstatic_ibverbs = (get_option('ibverbs_link') == 'static')\ndlopen_ibverbs = (get_option('ibverbs_link') == 'dlopen')\nLIB_GLUE_BASE = 'librte_pmd_mlx4_glue.so'\nLIB_GLUE_VERSION = '18.02.0'\nLIB_GLUE = LIB_GLUE_BASE + '.' + LIB_GLUE_VERSION\nif dlopen_ibverbs\n\tdpdk_conf.set('RTE_IBVERBS_LINK_DLOPEN', 1)\n\tcflags += [\n\t\t'-DMLX4_GLUE=\"@0@\"'.format(LIB_GLUE),\n\t\t'-DMLX4_GLUE_VERSION=\"@0@\"'.format(LIB_GLUE_VERSION),\n\t]\nendif\n\nlibnames = [ 'mlx4', 'ibverbs' ]\nlibs = []\nforeach libname:libnames\n\tlib = dependency('lib' + libname, static:static_ibverbs, required:false)\n\tif not lib.found() and not static_ibverbs\n\t\tlib = cc.find_library(libname, required:false)\n\tendif\n\tif lib.found()\n\t\tlibs += lib\n\t\tif not static_ibverbs and not dlopen_ibverbs\n\t\t\text_deps += lib\n\t\tendif\n\telse\n\t\tbuild = false\n\t\treason = 'missing dependency, \"' + libname + '\"'\n\t\tsubdir_done()\n\tendif\nendforeach\nif static_ibverbs or dlopen_ibverbs\n\t# Build without adding shared libs to Requires.private\n\tibv_cflags = run_command(pkgconf, '--cflags', 'libibverbs').stdout()\n\text_deps += declare_dependency(compile_args: ibv_cflags.split())\nendif\nif static_ibverbs\n\t# Add static deps ldflags to internal apps and Libs.private\n\tibv_ldflags = run_command(ldflags_ibverbs_static, check:true).stdout()\n\text_deps += declare_dependency(link_args:ibv_ldflags.split())\nendif\n\nallow_experimental_apis = true\nsources = files(\n\t'mlx4.c',\n\t'mlx4_ethdev.c',\n\t'mlx4_flow.c',\n\t'mlx4_intr.c',\n\t'mlx4_mp.c',\n\t'mlx4_mr.c',\n\t'mlx4_rxq.c',\n\t'mlx4_rxtx.c',\n\t'mlx4_txq.c',\n\t'mlx4_utils.c',\n)\nif not dlopen_ibverbs\n\tsources += files('mlx4_glue.c')\nendif\ncflags_options = [\n\t'-std=c11',\n\t'-Wno-strict-prototypes',\n\t'-D_BSD_SOURCE',\n\t'-D_DEFAULT_SOURCE',\n\t'-D_XOPEN_SOURCE=600'\n]\nforeach option:cflags_options\n\tif cc.has_argument(option)\n\t\tcflags += option\n\tendif\nendforeach\nif get_option('buildtype').contains('debug')\n\tcflags += [ '-pedantic', '-DPEDANTIC' ]\nelse\n\tcflags += [ '-UPEDANTIC' ]\nendif\n# To maintain the compatibility with the make build system\n# mlx4_autoconf.h file is still generated.\n# input array for meson member search:\n# [ \"MACRO to define if found\", \"header for the search\",\n#   \"symbol to search\", \"struct member to search\" ]\n#\nhas_member_args = [\n\t[ 'HAVE_IBV_MLX4_WQE_LSO_SEG', 'infiniband/mlx4dv.h',\n\t'struct mlx4_wqe_lso_seg', 'mss_hdr_size' ],\n]\n# input array for meson symbol search:\n# [ \"MACRO to define if found\", \"header for the search\",\n#   \"symbol to search\" ]\nhas_sym_args = [\n\t[ 'HAVE_IBV_MLX4_BUF_ALLOCATORS', 'infiniband/mlx4dv.h',\n\t'MLX4DV_SET_CTX_ATTR_BUF_ALLOCATORS' ],\n\t[ 'HAVE_IBV_MLX4_UAR_MMAP_OFFSET', 'infiniband/mlx4dv.h',\n\t'MLX4DV_QP_MASK_UAR_MMAP_OFFSET' ],\n]\nconfig = configuration_data()\nforeach arg:has_sym_args\n\tconfig.set(arg[0], cc.has_header_symbol(arg[1], arg[2],\n\t\tdependencies: libs))\nendforeach\nforeach arg:has_member_args\n\tfile_prefix = '#include <' + arg[1] + '>'\n\tconfig.set(arg[0], cc.has_member(arg[2], arg[3],\n\t\tprefix: file_prefix, dependencies: libs))\nendforeach\nconfigure_file(output : 'mlx4_autoconf.h', configuration : config)\n\n# Build Glue Library\nif dlopen_ibverbs\n\tdlopen_name = 'mlx4_glue'\n\tdlopen_lib_name = driver_name_fmt.format(dlopen_name)\n\tdlopen_so_version = LIB_GLUE_VERSION\n\tdlopen_sources = files('mlx4_glue.c')\n\tdlopen_install_dir = [ eal_pmd_path + '-glue' ]\n\tshared_lib = shared_library(\n\t\tdlopen_lib_name,\n\t\tdlopen_sources,\n\t\tinclude_directories: global_inc,\n\t\tc_args: cflags,\n\t\tdependencies: libs,\n\t\tlink_args: [\n\t\t'-Wl,-export-dynamic',\n\t\t'-Wl,-h,@0@'.format(LIB_GLUE),\n\t\t],\n\t\tsoversion: dlopen_so_version,\n\t\tinstall: true,\n\t\tinstall_dir: dlopen_install_dir,\n\t)\nendif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/drivers/net/mlx4/mlx4.c": "/* SPDX-License-Identifier: BSD-3-Clause\n * Copyright 2012 6WIND S.A.\n * Copyright 2012 Mellanox Technologies, Ltd\n */\n\n/**\n * @file\n * mlx4 driver initialization.\n */\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n\n/* Verbs headers do not support -pedantic. */\n#ifdef PEDANTIC\n#pragma GCC diagnostic ignored \"-Wpedantic\"\n#endif\n#include <infiniband/verbs.h>\n#ifdef PEDANTIC\n#pragma GCC diagnostic error \"-Wpedantic\"\n#endif\n\n#include <rte_common.h>\n#include <rte_dev.h>\n#include <rte_errno.h>\n#include <rte_ethdev_driver.h>\n#include <rte_ethdev_pci.h>\n#include <rte_ether.h>\n#include <rte_flow.h>\n#include <rte_interrupts.h>\n#include <rte_kvargs.h>\n#include <rte_malloc.h>\n#include <rte_mbuf.h>\n\n#include \"mlx4.h\"\n#include \"mlx4_glue.h\"\n#include \"mlx4_flow.h\"\n#include \"mlx4_mr.h\"\n#include \"mlx4_rxtx.h\"\n#include \"mlx4_utils.h\"\n\nstatic const char *MZ_MLX4_PMD_SHARED_DATA = \"mlx4_pmd_shared_data\";\n\n/* Shared memory between primary and secondary processes. */\nstruct mlx4_shared_data *mlx4_shared_data;\n\n/* Spinlock for mlx4_shared_data allocation. */\nstatic rte_spinlock_t mlx4_shared_data_lock = RTE_SPINLOCK_INITIALIZER;\n\n/* Process local data for secondary processes. */\nstatic struct mlx4_local_data mlx4_local_data;\n\n/** Driver-specific log messages type. */\nint mlx4_logtype;\n\n/** Configuration structure for device arguments. */\nstruct mlx4_conf {\n\tstruct {\n\t\tuint32_t present; /**< Bit-field for existing ports. */\n\t\tuint32_t enabled; /**< Bit-field for user-enabled ports. */\n\t} ports;\n\tint mr_ext_memseg_en;\n\t/** Whether memseg should be extended for MR creation. */\n};\n\n/* Available parameters list. */\nconst char *pmd_mlx4_init_params[] = {\n\tMLX4_PMD_PORT_KVARG,\n\tMLX4_MR_EXT_MEMSEG_EN_KVARG,\n\tNULL,\n};\n\nstatic void mlx4_dev_stop(struct rte_eth_dev *dev);\n\n/**\n * Initialize shared data between primary and secondary process.\n *\n * A memzone is reserved by primary process and secondary processes attach to\n * the memzone.\n *\n * @return\n *   0 on success, a negative errno value otherwise and rte_errno is set.\n */\nstatic int\nmlx4_init_shared_data(void)\n{\n\tconst struct rte_memzone *mz;\n\tint ret = 0;\n\n\trte_spinlock_lock(&mlx4_shared_data_lock);\n\tif (mlx4_shared_data == NULL) {\n\t\tif (rte_eal_process_type() == RTE_PROC_PRIMARY) {\n\t\t\t/* Allocate shared memory. */\n\t\t\tmz = rte_memzone_reserve(MZ_MLX4_PMD_SHARED_DATA,\n\t\t\t\t\t\t sizeof(*mlx4_shared_data),\n\t\t\t\t\t\t SOCKET_ID_ANY, 0);\n\t\t\tif (mz == NULL) {\n\t\t\t\tERROR(\"Cannot allocate mlx4 shared data\\n\");\n\t\t\t\tret = -rte_errno;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmlx4_shared_data = mz->addr;\n\t\t\tmemset(mlx4_shared_data, 0, sizeof(*mlx4_shared_data));\n\t\t\trte_spinlock_init(&mlx4_shared_data->lock);\n\t\t} else {\n\t\t\t/* Lookup allocated shared memory. */\n\t\t\tmz = rte_memzone_lookup(MZ_MLX4_PMD_SHARED_DATA);\n\t\t\tif (mz == NULL) {\n\t\t\t\tERROR(\"Cannot attach mlx4 shared data\\n\");\n\t\t\t\tret = -rte_errno;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmlx4_shared_data = mz->addr;\n\t\t\tmemset(&mlx4_local_data, 0, sizeof(mlx4_local_data));\n\t\t}\n\t}\nerror:\n\trte_spinlock_unlock(&mlx4_shared_data_lock);\n\treturn ret;\n}\n\n#ifdef HAVE_IBV_MLX4_BUF_ALLOCATORS\n/**\n * Verbs callback to allocate a memory. This function should allocate the space\n * according to the size provided residing inside a huge page.\n * Please note that all allocation must respect the alignment from libmlx4\n * (i.e. currently sysconf(_SC_PAGESIZE)).\n *\n * @param[in] size\n *   The size in bytes of the memory to allocate.\n * @param[in] data\n *   A pointer to the callback data.\n *\n * @return\n *   Allocated buffer, NULL otherwise and rte_errno is set.\n */\nstatic void *\nmlx4_alloc_verbs_buf(size_t size, void *data)\n{\n\tstruct mlx4_priv *priv = data;\n\tvoid *ret;\n\tsize_t alignment = sysconf(_SC_PAGESIZE);\n\tunsigned int socket = SOCKET_ID_ANY;\n\n\tif (priv->verbs_alloc_ctx.type == MLX4_VERBS_ALLOC_TYPE_TX_QUEUE) {\n\t\tconst struct txq *txq = priv->verbs_alloc_ctx.obj;\n\n\t\tsocket = txq->socket;\n\t} else if (priv->verbs_alloc_ctx.type ==\n\t\t   MLX4_VERBS_ALLOC_TYPE_RX_QUEUE) {\n\t\tconst struct rxq *rxq = priv->verbs_alloc_ctx.obj;\n\n\t\tsocket = rxq->socket;\n\t}\n\tMLX4_ASSERT(data != NULL);\n\tret = rte_malloc_socket(__func__, size, alignment, socket);\n\tif (!ret && size)\n\t\trte_errno = ENOMEM;\n\treturn ret;\n}\n\n/**\n * Verbs callback to free a memory.\n *\n * @param[in] ptr\n *   A pointer to the memory to free.\n * @param[in] data\n *   A pointer to the callback data.\n */\nstatic void\nmlx4_free_verbs_buf(void *ptr, void *data __rte_unused)\n{\n\tMLX4_ASSERT(data != NULL);\n\trte_free(ptr);\n}\n#endif\n\n/**\n * Initialize process private data structure.\n *\n * @param dev\n *   Pointer to Ethernet device structure.\n *\n * @return\n *   0 on success, a negative errno value otherwise and rte_errno is set.\n */\nstatic int\nmlx4_proc_priv_init(struct rte_eth_dev *dev)\n{\n\tstruct mlx4_proc_priv *ppriv;\n\tsize_t ppriv_size;\n\n\t/*\n\t * UAR register table follows the process private structure. BlueFlame\n\t * registers for Tx queues are stored in the table.\n\t */\n\tppriv_size = sizeof(struct mlx4_proc_priv) +\n\t\t     dev->data->nb_tx_queues * sizeof(void *);\n\tppriv = rte_malloc_socket(\"mlx4_proc_priv\", ppriv_size,\n\t\t\t\t  RTE_CACHE_LINE_SIZE, dev->device->numa_node);\n\tif (!ppriv) {\n\t\trte_errno = ENOMEM;\n\t\treturn -rte_errno;\n\t}\n\tppriv->uar_table_sz = ppriv_size;\n\tdev->process_private = ppriv;\n\treturn 0;\n}\n\n/**\n * Un-initialize process private data structure.\n *\n * @param dev\n *   Pointer to Ethernet device structure.\n */\nstatic void\nmlx4_proc_priv_uninit(struct rte_eth_dev *dev)\n{\n\tif (!dev->process_private)\n\t\treturn;\n\trte_free(dev->process_private);\n\tdev->process_private = NULL;\n}\n\n/**\n * DPDK callback for Ethernet device configuration.\n *\n * @param dev\n *   Pointer to Ethernet device structure.\n *\n * @return\n *   0 on success, negative errno value otherwise and rte_errno is set.\n */\nstatic int\nmlx4_dev_configure(struct rte_eth_dev *dev)\n{\n\tstruct mlx4_priv *priv = dev->data->dev_private;\n\tstruct rte_flow_error error;\n\tint ret;\n\n\tif (dev->data->dev_conf.rxmode.mq_mode & ETH_MQ_RX_RSS_FLAG)\n\t\tdev->data->dev_conf.rxmode.offloads |= DEV_RX_OFFLOAD_RSS_HASH;\n\n\t/* Prepare internal flow rules. */\n\tret = mlx4_flow_sync(priv, &error);\n\tif (ret) {\n\t\tERROR(\"cannot set up internal flow rules (code %d, \\\"%s\\\"),\"\n\t\t      \" flow error type %d, cause %p, message: %s\",\n\t\t      -ret, strerror(-ret), error.type, error.cause,\n\t\t      error.message ? error.message : \"(unspecified)\");\n\t\tgoto exit;\n\t}\n\tret = mlx4_intr_install(priv);\n\tif (ret) {\n\t\tERROR(\"%p: interrupt handler installation failed\",\n\t\t      (void *)dev);\n\t\tgoto exit;\n\t}\n\tret = mlx4_proc_priv_init(dev);\n\tif (ret) {\n\t\tERROR(\"%p: process private data allocation failed\",\n\t\t      (void *)dev);\n\t\tgoto exit;\n\t}\nexit:\n\treturn ret;\n}\n\n/**\n * DPDK callback to start the device.\n *\n * Simulate device start by initializing common RSS resources and attaching\n * all configured flows.\n *\n * @param dev\n *   Pointer to Ethernet device structure.\n *\n * @return\n *   0 on success, negative errno value otherwise and rte_errno is set.\n */\nstatic int\nmlx4_dev_start(struct rte_eth_dev *dev)\n{\n\tstruct mlx4_priv *priv = dev->data->dev_private;\n\tstruct rte_flow_error error;\n\tint ret;\n\n\tif (priv->started)\n\t\treturn 0;\n\tDEBUG(\"%p: attaching configured flows to all RX queues\", (void *)dev);\n\tpriv->started = 1;\n\tret = mlx4_rss_init(priv);\n\tif (ret) {\n\t\tERROR(\"%p: cannot initialize RSS resources: %s\",\n\t\t      (void *)dev, strerror(-ret));\n\t\tgoto err;\n\t}\n#ifdef RTE_LIBRTE_MLX4_DEBUG\n\tmlx4_mr_dump_dev(dev);\n#endif\n\tret = mlx4_rxq_intr_enable(priv);\n\tif (ret) {\n\t\tERROR(\"%p: interrupt handler installation failed\",\n\t\t     (void *)dev);\n\t\tgoto err;\n\t}\n\tret = mlx4_flow_sync(priv, &error);\n\tif (ret) {\n\t\tERROR(\"%p: cannot attach flow rules (code %d, \\\"%s\\\"),\"\n\t\t      \" flow error type %d, cause %p, message: %s\",\n\t\t      (void *)dev,\n\t\t      -ret, strerror(-ret), error.type, error.cause,\n\t\t      error.message ? error.message : \"(unspecified)\");\n\t\tgoto err;\n\t}\n\trte_wmb();\n\tdev->tx_pkt_burst = mlx4_tx_burst;\n\tdev->rx_pkt_burst = mlx4_rx_burst;\n\t/* Enable datapath on secondary process. */\n\tmlx4_mp_req_start_rxtx(dev);\n\treturn 0;\nerr:\n\tmlx4_dev_stop(dev);\n\treturn ret;\n}\n\n/**\n * DPDK callback to stop the device.\n *\n * Simulate device stop by detaching all configured flows.\n *\n * @param dev\n *   Pointer to Ethernet device structure.\n */\nstatic void\nmlx4_dev_stop(struct rte_eth_dev *dev)\n{\n\tstruct mlx4_priv *priv = dev->data->dev_private;\n\n\tif (!priv->started)\n\t\treturn;\n\tDEBUG(\"%p: detaching flows from all RX queues\", (void *)dev);\n\tpriv->started = 0;\n\tdev->tx_pkt_burst = mlx4_tx_burst_removed;\n\tdev->rx_pkt_burst = mlx4_rx_burst_removed;\n\trte_wmb();\n\t/* Disable datapath on secondary process. */\n\tmlx4_mp_req_stop_rxtx(dev);\n\tmlx4_flow_sync(priv, NULL);\n\tmlx4_rxq_intr_disable(priv);\n\tmlx4_rss_deinit(priv);\n}\n\n/**\n * DPDK callback to close the device.\n *\n * Destroy all queues and objects, free memory.\n *\n * @param dev\n *   Pointer to Ethernet device structure.\n */\nstatic void\nmlx4_dev_close(struct rte_eth_dev *dev)\n{\n\tstruct mlx4_priv *priv = dev->data->dev_private;\n\tunsigned int i;\n\n\tDEBUG(\"%p: closing device \\\"%s\\\"\",\n\t      (void *)dev,\n\t      ((priv->ctx != NULL) ? priv->ctx->device->name : \"\"));\n\tdev->rx_pkt_burst = mlx4_rx_burst_removed;\n\tdev->tx_pkt_burst = mlx4_tx_burst_removed;\n\trte_wmb();\n\t/* Disable datapath on secondary process. */\n\tmlx4_mp_req_stop_rxtx(dev);\n\tmlx4_flow_clean(priv);\n\tmlx4_rss_deinit(priv);\n\tfor (i = 0; i != dev->data->nb_rx_queues; ++i)\n\t\tmlx4_rx_queue_release(dev->data->rx_queues[i]);\n\tfor (i = 0; i != dev->data->nb_tx_queues; ++i)\n\t\tmlx4_tx_queue_release(dev->data->tx_queues[i]);\n\tmlx4_proc_priv_uninit(dev);\n\tmlx4_mr_release(dev);\n\tif (priv->pd != NULL) {\n\t\tMLX4_ASSERT(priv->ctx != NULL);\n\t\tclaim_zero(mlx4_glue->dealloc_pd(priv->pd));\n\t\tclaim_zero(mlx4_glue->close_device(priv->ctx));\n\t} else\n\t\tMLX4_ASSERT(priv->ctx == NULL);\n\tmlx4_intr_uninstall(priv);\n\tmemset(priv, 0, sizeof(*priv));\n}\n\nstatic const struct eth_dev_ops mlx4_dev_ops = {\n\t.dev_configure = mlx4_dev_configure,\n\t.dev_start = mlx4_dev_start,\n\t.dev_stop = mlx4_dev_stop,\n\t.dev_set_link_down = mlx4_dev_set_link_down,\n\t.dev_set_link_up = mlx4_dev_set_link_up,\n\t.dev_close = mlx4_dev_close,\n\t.link_update = mlx4_link_update,\n\t.promiscuous_enable = mlx4_promiscuous_enable,\n\t.promiscuous_disable = mlx4_promiscuous_disable,\n\t.allmulticast_enable = mlx4_allmulticast_enable,\n\t.allmulticast_disable = mlx4_allmulticast_disable,\n\t.mac_addr_remove = mlx4_mac_addr_remove,\n\t.mac_addr_add = mlx4_mac_addr_add,\n\t.mac_addr_set = mlx4_mac_addr_set,\n\t.set_mc_addr_list = mlx4_set_mc_addr_list,\n\t.stats_get = mlx4_stats_get,\n\t.stats_reset = mlx4_stats_reset,\n\t.fw_version_get = mlx4_fw_version_get,\n\t.dev_infos_get = mlx4_dev_infos_get,\n\t.dev_supported_ptypes_get = mlx4_dev_supported_ptypes_get,\n\t.vlan_filter_set = mlx4_vlan_filter_set,\n\t.rx_queue_setup = mlx4_rx_queue_setup,\n\t.tx_queue_setup = mlx4_tx_queue_setup,\n\t.rx_queue_release = mlx4_rx_queue_release,\n\t.tx_queue_release = mlx4_tx_queue_release,\n\t.flow_ctrl_get = mlx4_flow_ctrl_get,\n\t.flow_ctrl_set = mlx4_flow_ctrl_set,\n\t.mtu_set = mlx4_mtu_set,\n\t.filter_ctrl = mlx4_filter_ctrl,\n\t.rx_queue_intr_enable = mlx4_rx_intr_enable,\n\t.rx_queue_intr_disable = mlx4_rx_intr_disable,\n\t.is_removed = mlx4_is_removed,\n};\n\n/* Available operations from secondary process. */\nstatic const struct eth_dev_ops mlx4_dev_sec_ops = {\n\t.stats_get = mlx4_stats_get,\n\t.stats_reset = mlx4_stats_reset,\n\t.fw_version_get = mlx4_fw_version_get,\n\t.dev_infos_get = mlx4_dev_infos_get,\n};\n\n/**\n * Get PCI information from struct ibv_device.\n *\n * @param device\n *   Pointer to Ethernet device structure.\n * @param[out] pci_addr\n *   PCI bus address output buffer.\n *\n * @return\n *   0 on success, negative errno value otherwise and rte_errno is set.\n */\nstatic int\nmlx4_ibv_device_to_pci_addr(const struct ibv_device *device,\n\t\t\t    struct rte_pci_addr *pci_addr)\n{\n\tFILE *file;\n\tchar line[32];\n\tMKSTR(path, \"%s/device/uevent\", device->ibdev_path);\n\n\tfile = fopen(path, \"rb\");\n\tif (file == NULL) {\n\t\trte_errno = errno;\n\t\treturn -rte_errno;\n\t}\n\twhile (fgets(line, sizeof(line), file) == line) {\n\t\tsize_t len = strlen(line);\n\t\tint ret;\n\n\t\t/* Truncate long lines. */\n\t\tif (len == (sizeof(line) - 1))\n\t\t\twhile (line[(len - 1)] != '\\n') {\n\t\t\t\tret = fgetc(file);\n\t\t\t\tif (ret == EOF)\n\t\t\t\t\tbreak;\n\t\t\t\tline[(len - 1)] = ret;\n\t\t\t}\n\t\t/* Extract information. */\n\t\tif (sscanf(line,\n\t\t\t   \"PCI_SLOT_NAME=\"\n\t\t\t   \"%\" SCNx32 \":%\" SCNx8 \":%\" SCNx8 \".%\" SCNx8 \"\\n\",\n\t\t\t   &pci_addr->domain,\n\t\t\t   &pci_addr->bus,\n\t\t\t   &pci_addr->devid,\n\t\t\t   &pci_addr->function) == 4) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(file);\n\treturn 0;\n}\n\n/**\n * Verify and store value for device argument.\n *\n * @param[in] key\n *   Key argument to verify.\n * @param[in] val\n *   Value associated with key.\n * @param[in, out] conf\n *   Shared configuration data.\n *\n * @return\n *   0 on success, negative errno value otherwise and rte_errno is set.\n */\nstatic int\nmlx4_arg_parse(const char *key, const char *val, struct mlx4_conf *conf)\n{\n\tunsigned long tmp;\n\n\terrno = 0;\n\ttmp = strtoul(val, NULL, 0);\n\tif (errno) {\n\t\trte_errno = errno;\n\t\tWARN(\"%s: \\\"%s\\\" is not a valid integer\", key, val);\n\t\treturn -rte_errno;\n\t}\n\tif (strcmp(MLX4_PMD_PORT_KVARG, key) == 0) {\n\t\tuint32_t ports = rte_log2_u32(conf->ports.present + 1);\n\n\t\tif (tmp >= ports) {\n\t\t\tERROR(\"port index %lu outside range [0,%\" PRIu32 \")\",\n\t\t\t      tmp, ports);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(conf->ports.present & (1 << tmp))) {\n\t\t\trte_errno = EINVAL;\n\t\t\tERROR(\"invalid port index %lu\", tmp);\n\t\t\treturn -rte_errno;\n\t\t}\n\t\tconf->ports.enabled |= 1 << tmp;\n\t} else if (strcmp(MLX4_MR_EXT_MEMSEG_EN_KVARG, key) == 0) {\n\t\tconf->mr_ext_memseg_en = !!tmp;\n\t} else {\n\t\trte_errno = EINVAL;\n\t\tWARN(\"%s: unknown parameter\", key);\n\t\treturn -rte_errno;\n\t}\n\treturn 0;\n}\n\n/**\n * Parse device parameters.\n *\n * @param devargs\n *   Device arguments structure.\n *\n * @return\n *   0 on success, negative errno value otherwise and rte_errno is set.\n */\nstatic int\nmlx4_args(struct rte_devargs *devargs, struct mlx4_conf *conf)\n{\n\tstruct rte_kvargs *kvlist;\n\tunsigned int arg_count;\n\tint ret = 0;\n\tint i;\n\n\tif (devargs == NULL)\n\t\treturn 0;\n\tkvlist = rte_kvargs_parse(devargs->args, pmd_mlx4_init_params);\n\tif (kvlist == NULL) {\n\t\trte_errno = EINVAL;\n\t\tERROR(\"failed to parse kvargs\");\n\t\treturn -rte_errno;\n\t}\n\t/* Process parameters. */\n\tfor (i = 0; pmd_mlx4_init_params[i]; ++i) {\n\t\targ_count = rte_kvargs_count(kvlist, pmd_mlx4_init_params[i]);\n\t\twhile (arg_count-- > 0) {\n\t\t\tret = rte_kvargs_process(kvlist,\n\t\t\t\t\t\t pmd_mlx4_init_params[i],\n\t\t\t\t\t\t (int (*)(const char *,\n\t\t\t\t\t\t\t  const char *,\n\t\t\t\t\t\t\t  void *))\n\t\t\t\t\t\t mlx4_arg_parse,\n\t\t\t\t\t\t conf);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto free_kvlist;\n\t\t}\n\t}\nfree_kvlist:\n\trte_kvargs_free(kvlist);\n\treturn ret;\n}\n\n/**\n * Interpret RSS capabilities reported by device.\n *\n * This function returns the set of usable Verbs RSS hash fields, kernel\n * quirks taken into account.\n *\n * @param ctx\n *   Verbs context.\n * @param pd\n *   Verbs protection domain.\n * @param device_attr_ex\n *   Extended device attributes to interpret.\n *\n * @return\n *   Usable RSS hash fields mask in Verbs format.\n */\nstatic uint64_t\nmlx4_hw_rss_sup(struct ibv_context *ctx, struct ibv_pd *pd,\n\t\tstruct ibv_device_attr_ex *device_attr_ex)\n{\n\tuint64_t hw_rss_sup = device_attr_ex->rss_caps.rx_hash_fields_mask;\n\tstruct ibv_cq *cq = NULL;\n\tstruct ibv_wq *wq = NULL;\n\tstruct ibv_rwq_ind_table *ind = NULL;\n\tstruct ibv_qp *qp = NULL;\n\n\tif (!hw_rss_sup) {\n\t\tWARN(\"no RSS capabilities reported; disabling support for UDP\"\n\t\t     \" RSS and inner VXLAN RSS\");\n\t\treturn IBV_RX_HASH_SRC_IPV4 | IBV_RX_HASH_DST_IPV4 |\n\t\t\tIBV_RX_HASH_SRC_IPV6 | IBV_RX_HASH_DST_IPV6 |\n\t\t\tIBV_RX_HASH_SRC_PORT_TCP | IBV_RX_HASH_DST_PORT_TCP;\n\t}\n\tif (!(hw_rss_sup & IBV_RX_HASH_INNER))\n\t\treturn hw_rss_sup;\n\t/*\n\t * Although reported as supported, missing code in some Linux\n\t * versions (v4.15, v4.16) prevents the creation of hash QPs with\n\t * inner capability.\n\t *\n\t * There is no choice but to attempt to instantiate a temporary RSS\n\t * context in order to confirm its support.\n\t */\n\tcq = mlx4_glue->create_cq(ctx, 1, NULL, NULL, 0);\n\twq = cq ? mlx4_glue->create_wq\n\t\t(ctx,\n\t\t &(struct ibv_wq_init_attr){\n\t\t\t.wq_type = IBV_WQT_RQ,\n\t\t\t.max_wr = 1,\n\t\t\t.max_sge = 1,\n\t\t\t.pd = pd,\n\t\t\t.cq = cq,\n\t\t }) : NULL;\n\tind = wq ? mlx4_glue->create_rwq_ind_table\n\t\t(ctx,\n\t\t &(struct ibv_rwq_ind_table_init_attr){\n\t\t\t.log_ind_tbl_size = 0,\n\t\t\t.ind_tbl = &wq,\n\t\t\t.comp_mask = 0,\n\t\t }) : NULL;\n\tqp = ind ? mlx4_glue->create_qp_ex\n\t\t(ctx,\n\t\t &(struct ibv_qp_init_attr_ex){\n\t\t\t.comp_mask =\n\t\t\t\t(IBV_QP_INIT_ATTR_PD |\n\t\t\t\t IBV_QP_INIT_ATTR_RX_HASH |\n\t\t\t\t IBV_QP_INIT_ATTR_IND_TABLE),\n\t\t\t.qp_type = IBV_QPT_RAW_PACKET,\n\t\t\t.pd = pd,\n\t\t\t.rwq_ind_tbl = ind,\n\t\t\t.rx_hash_conf = {\n\t\t\t\t.rx_hash_function = IBV_RX_HASH_FUNC_TOEPLITZ,\n\t\t\t\t.rx_hash_key_len = MLX4_RSS_HASH_KEY_SIZE,\n\t\t\t\t.rx_hash_key = mlx4_rss_hash_key_default,\n\t\t\t\t.rx_hash_fields_mask = hw_rss_sup,\n\t\t\t},\n\t\t }) : NULL;\n\tif (!qp) {\n\t\tWARN(\"disabling unusable inner RSS capability due to kernel\"\n\t\t     \" quirk\");\n\t\thw_rss_sup &= ~IBV_RX_HASH_INNER;\n\t} else {\n\t\tclaim_zero(mlx4_glue->destroy_qp(qp));\n\t}\n\tif (ind)\n\t\tclaim_zero(mlx4_glue->destroy_rwq_ind_table(ind));\n\tif (wq)\n\t\tclaim_zero(mlx4_glue->destroy_wq(wq));\n\tif (cq)\n\t\tclaim_zero(mlx4_glue->destroy_cq(cq));\n\treturn hw_rss_sup;\n}\n\nstatic struct rte_pci_driver mlx4_driver;\n\n/**\n * PMD global initialization.\n *\n * Independent from individual device, this function initializes global\n * per-PMD data structures distinguishing primary and secondary processes.\n * Hence, each initialization is called once per a process.\n *\n * @return\n *   0 on success, a negative errno value otherwise and rte_errno is set.\n */\nstatic int\nmlx4_init_once(void)\n{\n\tstruct mlx4_shared_data *sd;\n\tstruct mlx4_local_data *ld = &mlx4_local_data;\n\tint ret = 0;\n\n\tif (mlx4_init_shared_data())\n\t\treturn -rte_errno;\n\tsd = mlx4_shared_data;\n\tMLX4_ASSERT(sd);\n\trte_spinlock_lock(&sd->lock);\n\tswitch (rte_eal_process_type()) {\n\tcase RTE_PROC_PRIMARY:\n\t\tif (sd->init_done)\n\t\t\tbreak;\n\t\tLIST_INIT(&sd->mem_event_cb_list);\n\t\trte_rwlock_init(&sd->mem_event_rwlock);\n\t\trte_mem_event_callback_register(\"MLX4_MEM_EVENT_CB\",\n\t\t\t\t\t\tmlx4_mr_mem_event_cb, NULL);\n\t\tret = mlx4_mp_init_primary();\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tsd->init_done = 1;\n\t\tbreak;\n\tcase RTE_PROC_SECONDARY:\n\t\tif (ld->init_done)\n\t\t\tbreak;\n\t\tret = mlx4_mp_init_secondary();\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t++sd->secondary_cnt;\n\t\tld->init_done = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\nout:\n\trte_spinlock_unlock(&sd->lock);\n\treturn ret;\n}\n\n/**\n * DPDK callback to register a PCI device.\n *\n * This function creates an Ethernet device for each port of a given\n * PCI device.\n *\n * @param[in] pci_drv\n *   PCI driver structure (mlx4_driver).\n * @param[in] pci_dev\n *   PCI device information.\n *\n * @return\n *   0 on success, negative errno value otherwise and rte_errno is set.\n */\nstatic int\nmlx4_pci_probe(struct rte_pci_driver *pci_drv, struct rte_pci_device *pci_dev)\n{\n\tstruct ibv_device **list;\n\tstruct ibv_device *ibv_dev;\n\tint err = 0;\n\tstruct ibv_context *attr_ctx = NULL;\n\tstruct ibv_device_attr device_attr;\n\tstruct ibv_device_attr_ex device_attr_ex;\n\tstruct mlx4_conf conf = {\n\t\t.ports.present = 0,\n\t\t.mr_ext_memseg_en = 1,\n\t};\n\tunsigned int vf;\n\tint i;\n\tchar ifname[IF_NAMESIZE];\n\n\t(void)pci_drv;\n\terr = mlx4_init_once();\n\tif (err) {\n\t\tERROR(\"unable to init PMD global data: %s\",\n\t\t      strerror(rte_errno));\n\t\treturn -rte_errno;\n\t}\n\tMLX4_ASSERT(pci_drv == &mlx4_driver);\n\tlist = mlx4_glue->get_device_list(&i);\n\tif (list == NULL) {\n\t\trte_errno = errno;\n\t\tMLX4_ASSERT(rte_errno);\n\t\tif (rte_errno == ENOSYS)\n\t\t\tERROR(\"cannot list devices, is ib_uverbs loaded?\");\n\t\treturn -rte_errno;\n\t}\n\tMLX4_ASSERT(i >= 0);\n\t/*\n\t * For each listed device, check related sysfs entry against\n\t * the provided PCI ID.\n\t */\n\twhile (i != 0) {\n\t\tstruct rte_pci_addr pci_addr;\n\n\t\t--i;\n\t\tDEBUG(\"checking device \\\"%s\\\"\", list[i]->name);\n\t\tif (mlx4_ibv_device_to_pci_addr(list[i], &pci_addr))\n\t\t\tcontinue;\n\t\tif ((pci_dev->addr.domain != pci_addr.domain) ||\n\t\t    (pci_dev->addr.bus != pci_addr.bus) ||\n\t\t    (pci_dev->addr.devid != pci_addr.devid) ||\n\t\t    (pci_dev->addr.function != pci_addr.function))\n\t\t\tcontinue;\n\t\tvf = (pci_dev->id.device_id ==\n\t\t      PCI_DEVICE_ID_MELLANOX_CONNECTX3VF);\n\t\tINFO(\"PCI information matches, using device \\\"%s\\\" (VF: %s)\",\n\t\t     list[i]->name, (vf ? \"true\" : \"false\"));\n\t\tattr_ctx = mlx4_glue->open_device(list[i]);\n\t\terr = errno;\n\t\tbreak;\n\t}\n\tif (attr_ctx == NULL) {\n\t\tmlx4_glue->free_device_list(list);\n\t\tswitch (err) {\n\t\tcase 0:\n\t\t\trte_errno = ENODEV;\n\t\t\tERROR(\"cannot access device, is mlx4_ib loaded?\");\n\t\t\treturn -rte_errno;\n\t\tcase EINVAL:\n\t\t\trte_errno = EINVAL;\n\t\t\tERROR(\"cannot use device, are drivers up to date?\");\n\t\t\treturn -rte_errno;\n\t\t}\n\t\tMLX4_ASSERT(err > 0);\n\t\trte_errno = err;\n\t\treturn -rte_errno;\n\t}\n\tibv_dev = list[i];\n\tDEBUG(\"device opened\");\n\tif (mlx4_glue->query_device(attr_ctx, &device_attr)) {\n\t\terr = ENODEV;\n\t\tgoto error;\n\t}\n\tINFO(\"%u port(s) detected\", device_attr.phys_port_cnt);\n\tconf.ports.present |= (UINT64_C(1) << device_attr.phys_port_cnt) - 1;\n\tif (mlx4_args(pci_dev->device.devargs, &conf)) {\n\t\tERROR(\"failed to process device arguments\");\n\t\terr = EINVAL;\n\t\tgoto error;\n\t}\n\t/* Use all ports when none are defined */\n\tif (!conf.ports.enabled)\n\t\tconf.ports.enabled = conf.ports.present;\n\t/* Retrieve extended device attributes. */\n\tif (mlx4_glue->query_device_ex(attr_ctx, NULL, &device_attr_ex)) {\n\t\terr = ENODEV;\n\t\tgoto error;\n\t}\n\tMLX4_ASSERT(device_attr.max_sge >= MLX4_MAX_SGE);\n\tfor (i = 0; i < device_attr.phys_port_cnt; i++) {\n\t\tuint32_t port = i + 1; /* ports are indexed from one */\n\t\tstruct ibv_context *ctx = NULL;\n\t\tstruct ibv_port_attr port_attr;\n\t\tstruct ibv_pd *pd = NULL;\n\t\tstruct mlx4_priv *priv = NULL;\n\t\tstruct rte_eth_dev *eth_dev = NULL;\n\t\tstruct rte_ether_addr mac;\n\t\tchar name[RTE_ETH_NAME_MAX_LEN];\n\n\t\t/* If port is not enabled, skip. */\n\t\tif (!(conf.ports.enabled & (1 << i)))\n\t\t\tcontinue;\n\t\tDEBUG(\"using port %u\", port);\n\t\tctx = mlx4_glue->open_device(ibv_dev);\n\t\tif (ctx == NULL) {\n\t\t\terr = ENODEV;\n\t\t\tgoto port_error;\n\t\t}\n\t\tsnprintf(name, sizeof(name), \"%s port %u\",\n\t\t\t mlx4_glue->get_device_name(ibv_dev), port);\n\t\tif (rte_eal_process_type() == RTE_PROC_SECONDARY) {\n\t\t\teth_dev = rte_eth_dev_attach_secondary(name);\n\t\t\tif (eth_dev == NULL) {\n\t\t\t\tERROR(\"can not attach rte ethdev\");\n\t\t\t\trte_errno = ENOMEM;\n\t\t\t\terr = rte_errno;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tpriv = eth_dev->data->dev_private;\n\t\t\tif (!priv->verbs_alloc_ctx.enabled) {\n\t\t\t\tERROR(\"secondary process is not supported\"\n\t\t\t\t      \" due to lack of external allocator\"\n\t\t\t\t      \" from Verbs\");\n\t\t\t\trte_errno = ENOTSUP;\n\t\t\t\terr = rte_errno;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\teth_dev->device = &pci_dev->device;\n\t\t\teth_dev->dev_ops = &mlx4_dev_sec_ops;\n\t\t\terr = mlx4_proc_priv_init(eth_dev);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\t/* Receive command fd from primary process. */\n\t\t\terr = mlx4_mp_req_verbs_cmd_fd(eth_dev);\n\t\t\tif (err < 0) {\n\t\t\t\terr = rte_errno;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Remap UAR for Tx queues. */\n\t\t\terr = mlx4_tx_uar_init_secondary(eth_dev, err);\n\t\t\tif (err) {\n\t\t\t\terr = rte_errno;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Ethdev pointer is still required as input since\n\t\t\t * the primary device is not accessible from the\n\t\t\t * secondary process.\n\t\t\t */\n\t\t\teth_dev->tx_pkt_burst = mlx4_tx_burst;\n\t\t\teth_dev->rx_pkt_burst = mlx4_rx_burst;\n\t\t\tclaim_zero(mlx4_glue->close_device(ctx));\n\t\t\trte_eth_copy_pci_info(eth_dev, pci_dev);\n\t\t\trte_eth_dev_probing_finish(eth_dev);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Check port status. */\n\t\terr = mlx4_glue->query_port(ctx, port, &port_attr);\n\t\tif (err) {\n\t\t\terr = ENODEV;\n\t\t\tERROR(\"port query failed: %s\", strerror(err));\n\t\t\tgoto port_error;\n\t\t}\n\t\tif (port_attr.link_layer != IBV_LINK_LAYER_ETHERNET) {\n\t\t\terr = ENOTSUP;\n\t\t\tERROR(\"port %d is not configured in Ethernet mode\",\n\t\t\t      port);\n\t\t\tgoto port_error;\n\t\t}\n\t\tif (port_attr.state != IBV_PORT_ACTIVE)\n\t\t\tDEBUG(\"port %d is not active: \\\"%s\\\" (%d)\",\n\t\t\t      port, mlx4_glue->port_state_str(port_attr.state),\n\t\t\t      port_attr.state);\n\t\t/* Make asynchronous FD non-blocking to handle interrupts. */\n\t\terr = mlx4_fd_set_non_blocking(ctx->async_fd);\n\t\tif (err) {\n\t\t\tERROR(\"cannot make asynchronous FD non-blocking: %s\",\n\t\t\t      strerror(err));\n\t\t\tgoto port_error;\n\t\t}\n\t\t/* Allocate protection domain. */\n\t\tpd = mlx4_glue->alloc_pd(ctx);\n\t\tif (pd == NULL) {\n\t\t\terr = ENOMEM;\n\t\t\tERROR(\"PD allocation failure\");\n\t\t\tgoto port_error;\n\t\t}\n\t\t/* from rte_ethdev.c */\n\t\tpriv = rte_zmalloc(\"ethdev private structure\",\n\t\t\t\t   sizeof(*priv),\n\t\t\t\t   RTE_CACHE_LINE_SIZE);\n\t\tif (priv == NULL) {\n\t\t\terr = ENOMEM;\n\t\t\tERROR(\"priv allocation failure\");\n\t\t\tgoto port_error;\n\t\t}\n\t\tpriv->ctx = ctx;\n\t\tpriv->device_attr = device_attr;\n\t\tpriv->port = port;\n\t\tpriv->pd = pd;\n\t\tpriv->mtu = RTE_ETHER_MTU;\n\t\tpriv->vf = vf;\n\t\tpriv->hw_csum =\t!!(device_attr.device_cap_flags &\n\t\t\t\t   IBV_DEVICE_RAW_IP_CSUM);\n\t\tDEBUG(\"checksum offloading is %ssupported\",\n\t\t      (priv->hw_csum ? \"\" : \"not \"));\n\t\t/* Only ConnectX-3 Pro supports tunneling. */\n\t\tpriv->hw_csum_l2tun =\n\t\t\tpriv->hw_csum &&\n\t\t\t(device_attr.vendor_part_id ==\n\t\t\t PCI_DEVICE_ID_MELLANOX_CONNECTX3PRO);\n\t\tDEBUG(\"L2 tunnel checksum offloads are %ssupported\",\n\t\t      priv->hw_csum_l2tun ? \"\" : \"not \");\n\t\tpriv->hw_rss_sup = mlx4_hw_rss_sup(priv->ctx, priv->pd,\n\t\t\t\t\t\t   &device_attr_ex);\n\t\tDEBUG(\"supported RSS hash fields mask: %016\" PRIx64,\n\t\t      priv->hw_rss_sup);\n\t\tpriv->hw_rss_max_qps =\n\t\t\tdevice_attr_ex.rss_caps.max_rwq_indirection_table_size;\n\t\tDEBUG(\"MAX RSS queues %d\", priv->hw_rss_max_qps);\n\t\tpriv->hw_fcs_strip = !!(device_attr_ex.raw_packet_caps &\n\t\t\t\t\tIBV_RAW_PACKET_CAP_SCATTER_FCS);\n\t\tDEBUG(\"FCS stripping toggling is %ssupported\",\n\t\t      priv->hw_fcs_strip ? \"\" : \"not \");\n\t\tpriv->tso =\n\t\t\t((device_attr_ex.tso_caps.max_tso > 0) &&\n\t\t\t (device_attr_ex.tso_caps.supported_qpts &\n\t\t\t  (1 << IBV_QPT_RAW_PACKET)));\n\t\tif (priv->tso)\n\t\t\tpriv->tso_max_payload_sz =\n\t\t\t\t\tdevice_attr_ex.tso_caps.max_tso;\n\t\tDEBUG(\"TSO is %ssupported\",\n\t\t      priv->tso ? \"\" : \"not \");\n\t\tpriv->mr_ext_memseg_en = conf.mr_ext_memseg_en;\n\t\t/* Configure the first MAC address by default. */\n\t\terr = mlx4_get_mac(priv, &mac.addr_bytes);\n\t\tif (err) {\n\t\t\tERROR(\"cannot get MAC address, is mlx4_en loaded?\"\n\t\t\t      \" (error: %s)\", strerror(err));\n\t\t\tgoto port_error;\n\t\t}\n\t\tINFO(\"port %u MAC address is %02x:%02x:%02x:%02x:%02x:%02x\",\n\t\t     priv->port,\n\t\t     mac.addr_bytes[0], mac.addr_bytes[1],\n\t\t     mac.addr_bytes[2], mac.addr_bytes[3],\n\t\t     mac.addr_bytes[4], mac.addr_bytes[5]);\n\t\t/* Register MAC address. */\n\t\tpriv->mac[0] = mac;\n\n\t\tif (mlx4_get_ifname(priv, &ifname) == 0) {\n\t\t\tDEBUG(\"port %u ifname is \\\"%s\\\"\",\n\t\t\t      priv->port, ifname);\n\t\t\tpriv->if_index = if_nametoindex(ifname);\n\t\t} else {\n\t\t\tDEBUG(\"port %u ifname is unknown\", priv->port);\n\t\t}\n\n\t\t/* Get actual MTU if possible. */\n\t\tmlx4_mtu_get(priv, &priv->mtu);\n\t\tDEBUG(\"port %u MTU is %u\", priv->port, priv->mtu);\n\t\teth_dev = rte_eth_dev_allocate(name);\n\t\tif (eth_dev == NULL) {\n\t\t\terr = ENOMEM;\n\t\t\tERROR(\"can not allocate rte ethdev\");\n\t\t\tgoto port_error;\n\t\t}\n\t\teth_dev->data->dev_private = priv;\n\t\teth_dev->data->mac_addrs = priv->mac;\n\t\teth_dev->device = &pci_dev->device;\n\t\trte_eth_copy_pci_info(eth_dev, pci_dev);\n\t\t/* Initialize local interrupt handle for current port. */\n\t\tpriv->intr_handle = (struct rte_intr_handle){\n\t\t\t.fd = -1,\n\t\t\t.type = RTE_INTR_HANDLE_EXT,\n\t\t};\n\t\t/*\n\t\t * Override ethdev interrupt handle pointer with private\n\t\t * handle instead of that of the parent PCI device used by\n\t\t * default. This prevents it from being shared between all\n\t\t * ports of the same PCI device since each of them is\n\t\t * associated its own Verbs context.\n\t\t *\n\t\t * Rx interrupts in particular require this as the PMD has\n\t\t * no control over the registration of queue interrupts\n\t\t * besides setting up eth_dev->intr_handle, the rest is\n\t\t * handled by rte_intr_rx_ctl().\n\t\t */\n\t\teth_dev->intr_handle = &priv->intr_handle;\n\t\tpriv->dev_data = eth_dev->data;\n\t\teth_dev->dev_ops = &mlx4_dev_ops;\n#ifdef HAVE_IBV_MLX4_BUF_ALLOCATORS\n\t\t/* Hint libmlx4 to use PMD allocator for data plane resources */\n\t\tstruct mlx4dv_ctx_allocators alctr = {\n\t\t\t.alloc = &mlx4_alloc_verbs_buf,\n\t\t\t.free = &mlx4_free_verbs_buf,\n\t\t\t.data = priv,\n\t\t};\n\t\terr = mlx4_glue->dv_set_context_attr\n\t\t\t(ctx, MLX4DV_SET_CTX_ATTR_BUF_ALLOCATORS,\n\t\t\t (void *)((uintptr_t)&alctr));\n\t\tif (err)\n\t\t\tWARN(\"Verbs external allocator is not supported\");\n\t\telse\n\t\t\tpriv->verbs_alloc_ctx.enabled = 1;\n#endif\n\t\t/* Bring Ethernet device up. */\n\t\tDEBUG(\"forcing Ethernet interface up\");\n\t\tmlx4_dev_set_link_up(eth_dev);\n\t\t/* Update link status once if waiting for LSC. */\n\t\tif (eth_dev->data->dev_flags & RTE_ETH_DEV_INTR_LSC)\n\t\t\tmlx4_link_update(eth_dev, 0);\n\t\t/*\n\t\t * Once the device is added to the list of memory event\n\t\t * callback, its global MR cache table cannot be expanded\n\t\t * on the fly because of deadlock. If it overflows, lookup\n\t\t * should be done by searching MR list linearly, which is slow.\n\t\t */\n\t\terr = mlx4_mr_btree_init(&priv->mr.cache,\n\t\t\t\t\t MLX4_MR_BTREE_CACHE_N * 2,\n\t\t\t\t\t eth_dev->device->numa_node);\n\t\tif (err) {\n\t\t\t/* rte_errno is already set. */\n\t\t\tgoto port_error;\n\t\t}\n\t\t/* Add device to memory callback list. */\n\t\trte_rwlock_write_lock(&mlx4_shared_data->mem_event_rwlock);\n\t\tLIST_INSERT_HEAD(&mlx4_shared_data->mem_event_cb_list,\n\t\t\t\t priv, mem_event_cb);\n\t\trte_rwlock_write_unlock(&mlx4_shared_data->mem_event_rwlock);\n\t\trte_eth_dev_probing_finish(eth_dev);\n\t\tcontinue;\nport_error:\n\t\trte_free(priv);\n\t\tif (eth_dev != NULL)\n\t\t\teth_dev->data->dev_private = NULL;\n\t\tif (pd)\n\t\t\tclaim_zero(mlx4_glue->dealloc_pd(pd));\n\t\tif (ctx)\n\t\t\tclaim_zero(mlx4_glue->close_device(ctx));\n\t\tif (eth_dev != NULL) {\n\t\t\t/* mac_addrs must not be freed because part of dev_private */\n\t\t\teth_dev->data->mac_addrs = NULL;\n\t\t\trte_eth_dev_release_port(eth_dev);\n\t\t}\n\t\tbreak;\n\t}\n\t/*\n\t * XXX if something went wrong in the loop above, there is a resource\n\t * leak (ctx, pd, priv, dpdk ethdev) but we can do nothing about it as\n\t * long as the dpdk does not provide a way to deallocate a ethdev and a\n\t * way to enumerate the registered ethdevs to free the previous ones.\n\t */\nerror:\n\tif (attr_ctx)\n\t\tclaim_zero(mlx4_glue->close_device(attr_ctx));\n\tif (list)\n\t\tmlx4_glue->free_device_list(list);\n\tif (err)\n\t\trte_errno = err;\n\treturn -err;\n}\n\nstatic const struct rte_pci_id mlx4_pci_id_map[] = {\n\t{\n\t\tRTE_PCI_DEVICE(PCI_VENDOR_ID_MELLANOX,\n\t\t\t       PCI_DEVICE_ID_MELLANOX_CONNECTX3)\n\t},\n\t{\n\t\tRTE_PCI_DEVICE(PCI_VENDOR_ID_MELLANOX,\n\t\t\t       PCI_DEVICE_ID_MELLANOX_CONNECTX3PRO)\n\t},\n\t{\n\t\tRTE_PCI_DEVICE(PCI_VENDOR_ID_MELLANOX,\n\t\t\t       PCI_DEVICE_ID_MELLANOX_CONNECTX3VF)\n\t},\n\t{\n\t\t.vendor_id = 0\n\t}\n};\n\nstatic struct rte_pci_driver mlx4_driver = {\n\t.driver = {\n\t\t.name = MLX4_DRIVER_NAME\n\t},\n\t.id_table = mlx4_pci_id_map,\n\t.probe = mlx4_pci_probe,\n\t.drv_flags = RTE_PCI_DRV_INTR_LSC | RTE_PCI_DRV_INTR_RMV,\n};\n\n#ifdef RTE_IBVERBS_LINK_DLOPEN\n\n/**\n * Suffix RTE_EAL_PMD_PATH with \"-glue\".\n *\n * This function performs a sanity check on RTE_EAL_PMD_PATH before\n * suffixing its last component.\n *\n * @param buf[out]\n *   Output buffer, should be large enough otherwise NULL is returned.\n * @param size\n *   Size of @p out.\n *\n * @return\n *   Pointer to @p buf or @p NULL in case suffix cannot be appended.\n */\nstatic char *\nmlx4_glue_path(char *buf, size_t size)\n{\n\tstatic const char *const bad[] = { \"/\", \".\", \"..\", NULL };\n\tconst char *path = RTE_EAL_PMD_PATH;\n\tsize_t len = strlen(path);\n\tsize_t off;\n\tint i;\n\n\twhile (len && path[len - 1] == '/')\n\t\t--len;\n\tfor (off = len; off && path[off - 1] != '/'; --off)\n\t\t;\n\tfor (i = 0; bad[i]; ++i)\n\t\tif (!strncmp(path + off, bad[i], (int)(len - off)))\n\t\t\tgoto error;\n\ti = snprintf(buf, size, \"%.*s-glue\", (int)len, path);\n\tif (i == -1 || (size_t)i >= size)\n\t\tgoto error;\n\treturn buf;\nerror:\n\tERROR(\"unable to append \\\"-glue\\\" to last component of\"\n\t      \" RTE_EAL_PMD_PATH (\\\"\" RTE_EAL_PMD_PATH \"\\\"),\"\n\t      \" please re-configure DPDK\");\n\treturn NULL;\n}\n\n/**\n * Initialization routine for run-time dependency on rdma-core.\n */\nstatic int\nmlx4_glue_init(void)\n{\n\tchar glue_path[sizeof(RTE_EAL_PMD_PATH) - 1 + sizeof(\"-glue\")];\n\tconst char *path[] = {\n\t\t/*\n\t\t * A basic security check is necessary before trusting\n\t\t * MLX4_GLUE_PATH, which may override RTE_EAL_PMD_PATH.\n\t\t */\n\t\t(geteuid() == getuid() && getegid() == getgid() ?\n\t\t getenv(\"MLX4_GLUE_PATH\") : NULL),\n\t\t/*\n\t\t * When RTE_EAL_PMD_PATH is set, use its glue-suffixed\n\t\t * variant, otherwise let dlopen() look up libraries on its\n\t\t * own.\n\t\t */\n\t\t(*RTE_EAL_PMD_PATH ?\n\t\t mlx4_glue_path(glue_path, sizeof(glue_path)) : \"\"),\n\t};\n\tunsigned int i = 0;\n\tvoid *handle = NULL;\n\tvoid **sym;\n\tconst char *dlmsg;\n\n\twhile (!handle && i != RTE_DIM(path)) {\n\t\tconst char *end;\n\t\tsize_t len;\n\t\tint ret;\n\n\t\tif (!path[i]) {\n\t\t\t++i;\n\t\t\tcontinue;\n\t\t}\n\t\tend = strpbrk(path[i], \":;\");\n\t\tif (!end)\n\t\t\tend = path[i] + strlen(path[i]);\n\t\tlen = end - path[i];\n\t\tret = 0;\n\t\tdo {\n\t\t\tchar name[ret + 1];\n\n\t\t\tret = snprintf(name, sizeof(name), \"%.*s%s\" MLX4_GLUE,\n\t\t\t\t       (int)len, path[i],\n\t\t\t\t       (!len || *(end - 1) == '/') ? \"\" : \"/\");\n\t\t\tif (ret == -1)\n\t\t\t\tbreak;\n\t\t\tif (sizeof(name) != (size_t)ret + 1)\n\t\t\t\tcontinue;\n\t\t\tDEBUG(\"looking for rdma-core glue as \\\"%s\\\"\", name);\n\t\t\thandle = dlopen(name, RTLD_LAZY);\n\t\t\tbreak;\n\t\t} while (1);\n\t\tpath[i] = end + 1;\n\t\tif (!*end)\n\t\t\t++i;\n\t}\n\tif (!handle) {\n\t\trte_errno = EINVAL;\n\t\tdlmsg = dlerror();\n\t\tif (dlmsg)\n\t\t\tWARN(\"cannot load glue library: %s\", dlmsg);\n\t\tgoto glue_error;\n\t}\n\tsym = dlsym(handle, \"mlx4_glue\");\n\tif (!sym || !*sym) {\n\t\trte_errno = EINVAL;\n\t\tdlmsg = dlerror();\n\t\tif (dlmsg)\n\t\t\tERROR(\"cannot resolve glue symbol: %s\", dlmsg);\n\t\tgoto glue_error;\n\t}\n\tmlx4_glue = *sym;\n\treturn 0;\nglue_error:\n\tif (handle)\n\t\tdlclose(handle);\n\tWARN(\"cannot initialize PMD due to missing run-time\"\n\t     \" dependency on rdma-core libraries (libibverbs,\"\n\t     \" libmlx4)\");\n\treturn -rte_errno;\n}\n\n#endif\n\n/**\n * Driver initialization routine.\n */\nRTE_INIT(rte_mlx4_pmd_init)\n{\n\t/* Initialize driver log type. */\n\tmlx4_logtype = rte_log_register(\"pmd.net.mlx4\");\n\tif (mlx4_logtype >= 0)\n\t\trte_log_set_level(mlx4_logtype, RTE_LOG_NOTICE);\n\n\t/*\n\t * MLX4_DEVICE_FATAL_CLEANUP tells ibv_destroy functions we\n\t * want to get success errno value in case of calling them\n\t * when the device was removed.\n\t */\n\tsetenv(\"MLX4_DEVICE_FATAL_CLEANUP\", \"1\", 1);\n\t/*\n\t * RDMAV_HUGEPAGES_SAFE tells ibv_fork_init() we intend to use\n\t * huge pages. Calling ibv_fork_init() during init allows\n\t * applications to use fork() safely for purposes other than\n\t * using this PMD, which is not supported in forked processes.\n\t */\n\tsetenv(\"RDMAV_HUGEPAGES_SAFE\", \"1\", 1);\n#ifdef RTE_IBVERBS_LINK_DLOPEN\n\tif (mlx4_glue_init())\n\t\treturn;\n\tMLX4_ASSERT(mlx4_glue);\n#endif\n#ifdef RTE_LIBRTE_MLX4_DEBUG\n\t/* Glue structure must not contain any NULL pointers. */\n\t{\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i != sizeof(*mlx4_glue) / sizeof(void *); ++i)\n\t\t\tMLX4_ASSERT(((const void *const *)mlx4_glue)[i]);\n\t}\n#endif\n\tif (strcmp(mlx4_glue->version, MLX4_GLUE_VERSION)) {\n\t\tERROR(\"rdma-core glue \\\"%s\\\" mismatch: \\\"%s\\\" is required\",\n\t\t      mlx4_glue->version, MLX4_GLUE_VERSION);\n\t\treturn;\n\t}\n\tmlx4_glue->fork_init();\n\trte_pci_register(&mlx4_driver);\n}\n\nRTE_PMD_EXPORT_NAME(net_mlx4, __COUNTER__);\nRTE_PMD_REGISTER_PCI_TABLE(net_mlx4, mlx4_pci_id_map);\nRTE_PMD_REGISTER_KMOD_DEP(net_mlx4,\n\t\"* ib_uverbs & mlx4_en & mlx4_core & mlx4_ib\");\n",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/drivers/net/ark/ark_ethdev.c": "/* SPDX-License-Identifier: BSD-3-Clause\n * Copyright (c) 2015-2018 Atomic Rules LLC\n */\n\n#include <unistd.h>\n#include <sys/stat.h>\n#include <dlfcn.h>\n\n#include <rte_bus_pci.h>\n#include <rte_ethdev_pci.h>\n#include <rte_kvargs.h>\n\n#include \"ark_global.h\"\n#include \"ark_logs.h\"\n#include \"ark_ethdev_tx.h\"\n#include \"ark_ethdev_rx.h\"\n#include \"ark_mpu.h\"\n#include \"ark_ddm.h\"\n#include \"ark_udm.h\"\n#include \"ark_rqp.h\"\n#include \"ark_pktdir.h\"\n#include \"ark_pktgen.h\"\n#include \"ark_pktchkr.h\"\n\n/*  Internal prototypes */\nstatic int eth_ark_check_args(struct ark_adapter *ark, const char *params);\nstatic int eth_ark_dev_init(struct rte_eth_dev *dev);\nstatic int ark_config_device(struct rte_eth_dev *dev);\nstatic int eth_ark_dev_uninit(struct rte_eth_dev *eth_dev);\nstatic int eth_ark_dev_configure(struct rte_eth_dev *dev);\nstatic int eth_ark_dev_start(struct rte_eth_dev *dev);\nstatic void eth_ark_dev_stop(struct rte_eth_dev *dev);\nstatic void eth_ark_dev_close(struct rte_eth_dev *dev);\nstatic int eth_ark_dev_info_get(struct rte_eth_dev *dev,\n\t\t\t\tstruct rte_eth_dev_info *dev_info);\nstatic int eth_ark_dev_link_update(struct rte_eth_dev *dev,\n\t\t\t\t   int wait_to_complete);\nstatic int eth_ark_dev_set_link_up(struct rte_eth_dev *dev);\nstatic int eth_ark_dev_set_link_down(struct rte_eth_dev *dev);\nstatic int eth_ark_dev_stats_get(struct rte_eth_dev *dev,\n\t\t\t\t  struct rte_eth_stats *stats);\nstatic int eth_ark_dev_stats_reset(struct rte_eth_dev *dev);\nstatic int eth_ark_set_default_mac_addr(struct rte_eth_dev *dev,\n\t\t\t\t\t struct rte_ether_addr *mac_addr);\nstatic int eth_ark_macaddr_add(struct rte_eth_dev *dev,\n\t\t\t       struct rte_ether_addr *mac_addr,\n\t\t\t       uint32_t index,\n\t\t\t       uint32_t pool);\nstatic void eth_ark_macaddr_remove(struct rte_eth_dev *dev,\n\t\t\t\t   uint32_t index);\nstatic int  eth_ark_set_mtu(struct rte_eth_dev *dev, uint16_t size);\n\n/*\n * The packet generator is a functional block used to generate packet\n * patterns for testing.  It is not intended for nominal use.\n */\n#define ARK_PKTGEN_ARG \"Pkt_gen\"\n\n/*\n * The packet checker is a functional block used to verify packet\n * patterns for testing.  It is not intended for nominal use.\n */\n#define ARK_PKTCHKR_ARG \"Pkt_chkr\"\n\n/*\n * The packet director is used to select the internal ingress and\n * egress packets paths during testing.  It is not intended for\n * nominal use.\n */\n#define ARK_PKTDIR_ARG \"Pkt_dir\"\n\n/* Devinfo configurations */\n#define ARK_RX_MAX_QUEUE (4096 * 4)\n#define ARK_RX_MIN_QUEUE (512)\n#define ARK_RX_MAX_PKT_LEN ((16 * 1024) - 128)\n#define ARK_RX_MIN_BUFSIZE (1024)\n\n#define ARK_TX_MAX_QUEUE (4096 * 4)\n#define ARK_TX_MIN_QUEUE (256)\n\nint ark_logtype;\n\nstatic const char * const valid_arguments[] = {\n\tARK_PKTGEN_ARG,\n\tARK_PKTCHKR_ARG,\n\tARK_PKTDIR_ARG,\n\tNULL\n};\n\nstatic const struct rte_pci_id pci_id_ark_map[] = {\n\t{RTE_PCI_DEVICE(0x1d6c, 0x100d)},\n\t{RTE_PCI_DEVICE(0x1d6c, 0x100e)},\n\t{.vendor_id = 0, /* sentinel */ },\n};\n\nstatic int\neth_ark_pci_probe(struct rte_pci_driver *pci_drv __rte_unused,\n\t\tstruct rte_pci_device *pci_dev)\n{\n\tstruct rte_eth_dev *eth_dev;\n\tint ret;\n\n\teth_dev = rte_eth_dev_pci_allocate(pci_dev, sizeof(struct ark_adapter));\n\n\tif (eth_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tret = eth_ark_dev_init(eth_dev);\n\tif (ret)\n\t\trte_eth_dev_pci_release(eth_dev);\n\n\treturn ret;\n}\n\nstatic int\neth_ark_pci_remove(struct rte_pci_device *pci_dev)\n{\n\treturn rte_eth_dev_pci_generic_remove(pci_dev, eth_ark_dev_uninit);\n}\n\nstatic struct rte_pci_driver rte_ark_pmd = {\n\t.id_table = pci_id_ark_map,\n\t.drv_flags = RTE_PCI_DRV_NEED_MAPPING | RTE_PCI_DRV_INTR_LSC,\n\t.probe = eth_ark_pci_probe,\n\t.remove = eth_ark_pci_remove,\n};\n\nstatic const struct eth_dev_ops ark_eth_dev_ops = {\n\t.dev_configure = eth_ark_dev_configure,\n\t.dev_start = eth_ark_dev_start,\n\t.dev_stop = eth_ark_dev_stop,\n\t.dev_close = eth_ark_dev_close,\n\n\t.dev_infos_get = eth_ark_dev_info_get,\n\n\t.rx_queue_setup = eth_ark_dev_rx_queue_setup,\n\t.rx_queue_count = eth_ark_dev_rx_queue_count,\n\t.tx_queue_setup = eth_ark_tx_queue_setup,\n\n\t.link_update = eth_ark_dev_link_update,\n\t.dev_set_link_up = eth_ark_dev_set_link_up,\n\t.dev_set_link_down = eth_ark_dev_set_link_down,\n\n\t.rx_queue_start = eth_ark_rx_start_queue,\n\t.rx_queue_stop = eth_ark_rx_stop_queue,\n\n\t.tx_queue_start = eth_ark_tx_queue_start,\n\t.tx_queue_stop = eth_ark_tx_queue_stop,\n\n\t.stats_get = eth_ark_dev_stats_get,\n\t.stats_reset = eth_ark_dev_stats_reset,\n\n\t.mac_addr_add = eth_ark_macaddr_add,\n\t.mac_addr_remove = eth_ark_macaddr_remove,\n\t.mac_addr_set = eth_ark_set_default_mac_addr,\n\n\t.mtu_set = eth_ark_set_mtu,\n};\n\nstatic int\ncheck_for_ext(struct ark_adapter *ark)\n{\n\tint found = 0;\n\n\t/* Get the env */\n\tconst char *dllpath = getenv(\"ARK_EXT_PATH\");\n\n\tif (dllpath == NULL) {\n\t\tPMD_DEBUG_LOG(DEBUG, \"ARK EXT NO dll path specified\\n\");\n\t\treturn 0;\n\t}\n\tPMD_DRV_LOG(INFO, \"ARK EXT found dll path at %s\\n\", dllpath);\n\n\t/* Open and load the .so */\n\tark->d_handle = dlopen(dllpath, RTLD_LOCAL | RTLD_LAZY);\n\tif (ark->d_handle == NULL) {\n\t\tPMD_DRV_LOG(ERR, \"Could not load user extension %s\\n\",\n\t\t\t    dllpath);\n\t\treturn -1;\n\t}\n\tPMD_DRV_LOG(INFO, \"SUCCESS: loaded user extension %s\\n\",\n\t\t\t    dllpath);\n\n\t/* Get the entry points */\n\tark->user_ext.dev_init =\n\t\t(void *(*)(struct rte_eth_dev *, void *, int))\n\t\tdlsym(ark->d_handle, \"dev_init\");\n\tPMD_DEBUG_LOG(DEBUG, \"device ext init pointer = %p\\n\",\n\t\t      ark->user_ext.dev_init);\n\tark->user_ext.dev_get_port_count =\n\t\t(int (*)(struct rte_eth_dev *, void *))\n\t\tdlsym(ark->d_handle, \"dev_get_port_count\");\n\tark->user_ext.dev_uninit =\n\t\t(void (*)(struct rte_eth_dev *, void *))\n\t\tdlsym(ark->d_handle, \"dev_uninit\");\n\tark->user_ext.dev_configure =\n\t\t(int (*)(struct rte_eth_dev *, void *))\n\t\tdlsym(ark->d_handle, \"dev_configure\");\n\tark->user_ext.dev_start =\n\t\t(int (*)(struct rte_eth_dev *, void *))\n\t\tdlsym(ark->d_handle, \"dev_start\");\n\tark->user_ext.dev_stop =\n\t\t(void (*)(struct rte_eth_dev *, void *))\n\t\tdlsym(ark->d_handle, \"dev_stop\");\n\tark->user_ext.dev_close =\n\t\t(void (*)(struct rte_eth_dev *, void *))\n\t\tdlsym(ark->d_handle, \"dev_close\");\n\tark->user_ext.link_update =\n\t\t(int (*)(struct rte_eth_dev *, int, void *))\n\t\tdlsym(ark->d_handle, \"link_update\");\n\tark->user_ext.dev_set_link_up =\n\t\t(int (*)(struct rte_eth_dev *, void *))\n\t\tdlsym(ark->d_handle, \"dev_set_link_up\");\n\tark->user_ext.dev_set_link_down =\n\t\t(int (*)(struct rte_eth_dev *, void *))\n\t\tdlsym(ark->d_handle, \"dev_set_link_down\");\n\tark->user_ext.stats_get =\n\t\t(int (*)(struct rte_eth_dev *, struct rte_eth_stats *,\n\t\t\t  void *))\n\t\tdlsym(ark->d_handle, \"stats_get\");\n\tark->user_ext.stats_reset =\n\t\t(void (*)(struct rte_eth_dev *, void *))\n\t\tdlsym(ark->d_handle, \"stats_reset\");\n\tark->user_ext.mac_addr_add =\n\t\t(void (*)(struct rte_eth_dev *, struct rte_ether_addr *,\n\t\t\tuint32_t, uint32_t, void *))\n\t\tdlsym(ark->d_handle, \"mac_addr_add\");\n\tark->user_ext.mac_addr_remove =\n\t\t(void (*)(struct rte_eth_dev *, uint32_t, void *))\n\t\tdlsym(ark->d_handle, \"mac_addr_remove\");\n\tark->user_ext.mac_addr_set =\n\t\t(void (*)(struct rte_eth_dev *, struct rte_ether_addr *,\n\t\t\t  void *))\n\t\tdlsym(ark->d_handle, \"mac_addr_set\");\n\tark->user_ext.set_mtu =\n\t\t(int (*)(struct rte_eth_dev *, uint16_t,\n\t\t\t  void *))\n\t\tdlsym(ark->d_handle, \"set_mtu\");\n\n\treturn found;\n}\n\nstatic int\neth_ark_dev_init(struct rte_eth_dev *dev)\n{\n\tstruct ark_adapter *ark = dev->data->dev_private;\n\tstruct rte_pci_device *pci_dev;\n\tint ret;\n\tint port_count = 1;\n\tint p;\n\n\tark->eth_dev = dev;\n\n\tPMD_FUNC_LOG(DEBUG, \"\\n\");\n\n\t/* Check to see if there is an extension that we need to load */\n\tret = check_for_ext(ark);\n\tif (ret)\n\t\treturn ret;\n\tpci_dev = RTE_ETH_DEV_TO_PCI(dev);\n\trte_eth_copy_pci_info(dev, pci_dev);\n\n\t/* Use dummy function until setup */\n\tdev->rx_pkt_burst = &eth_ark_recv_pkts_noop;\n\tdev->tx_pkt_burst = &eth_ark_xmit_pkts_noop;\n\t/* Let rte_eth_dev_close() release the port resources */\n\tdev->data->dev_flags |= RTE_ETH_DEV_CLOSE_REMOVE;\n\n\tark->bar0 = (uint8_t *)pci_dev->mem_resource[0].addr;\n\tark->a_bar = (uint8_t *)pci_dev->mem_resource[2].addr;\n\n\tark->sysctrl.v  = (void *)&ark->bar0[ARK_SYSCTRL_BASE];\n\tark->mpurx.v  = (void *)&ark->bar0[ARK_MPU_RX_BASE];\n\tark->udm.v  = (void *)&ark->bar0[ARK_UDM_BASE];\n\tark->mputx.v  = (void *)&ark->bar0[ARK_MPU_TX_BASE];\n\tark->ddm.v  = (void *)&ark->bar0[ARK_DDM_BASE];\n\tark->cmac.v  = (void *)&ark->bar0[ARK_CMAC_BASE];\n\tark->external.v  = (void *)&ark->bar0[ARK_EXTERNAL_BASE];\n\tark->pktdir.v  = (void *)&ark->bar0[ARK_PKTDIR_BASE];\n\tark->pktgen.v  = (void *)&ark->bar0[ARK_PKTGEN_BASE];\n\tark->pktchkr.v  = (void *)&ark->bar0[ARK_PKTCHKR_BASE];\n\n\tark->rqpacing =\n\t\t(struct ark_rqpace_t *)(ark->bar0 + ARK_RCPACING_BASE);\n\tark->started = 0;\n\n\tPMD_DEBUG_LOG(INFO, \"Sys Ctrl Const = 0x%x  HW Commit_ID: %08x\\n\",\n\t\t      ark->sysctrl.t32[4],\n\t\t      rte_be_to_cpu_32(ark->sysctrl.t32[0x20 / 4]));\n\tPMD_DRV_LOG(INFO, \"Arkville HW Commit_ID: %08x\\n\",\n\t\t    rte_be_to_cpu_32(ark->sysctrl.t32[0x20 / 4]));\n\n\t/* If HW sanity test fails, return an error */\n\tif (ark->sysctrl.t32[4] != 0xcafef00d) {\n\t\tPMD_DRV_LOG(ERR,\n\t\t\t    \"HW Sanity test has failed, expected constant\"\n\t\t\t    \" 0x%x, read 0x%x (%s)\\n\",\n\t\t\t    0xcafef00d,\n\t\t\t    ark->sysctrl.t32[4], __func__);\n\t\treturn -1;\n\t}\n\tif (ark->sysctrl.t32[3] != 0) {\n\t\tif (ark_rqp_lasped(ark->rqpacing)) {\n\t\t\tPMD_DRV_LOG(ERR, \"Arkville Evaluation System - \"\n\t\t\t\t    \"Timer has Expired\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tPMD_DRV_LOG(WARNING, \"Arkville Evaluation System - \"\n\t\t\t    \"Timer is Running\\n\");\n\t}\n\n\tPMD_DRV_LOG(INFO,\n\t\t    \"HW Sanity test has PASSED, expected constant\"\n\t\t    \" 0x%x, read 0x%x (%s)\\n\",\n\t\t    0xcafef00d, ark->sysctrl.t32[4], __func__);\n\n\t/* We are a single function multi-port device. */\n\tret = ark_config_device(dev);\n\tif (ret)\n\t\treturn -1;\n\n\tdev->dev_ops = &ark_eth_dev_ops;\n\n\tdev->data->mac_addrs = rte_zmalloc(\"ark\", RTE_ETHER_ADDR_LEN, 0);\n\tif (!dev->data->mac_addrs) {\n\t\tPMD_DRV_LOG(ERR,\n\t\t\t    \"Failed to allocated memory for storing mac address\"\n\t\t\t    );\n\t}\n\n\tif (ark->user_ext.dev_init) {\n\t\tark->user_data[dev->data->port_id] =\n\t\t\tark->user_ext.dev_init(dev, ark->a_bar, 0);\n\t\tif (!ark->user_data[dev->data->port_id]) {\n\t\t\tPMD_DRV_LOG(INFO,\n\t\t\t\t    \"Failed to initialize PMD extension!\"\n\t\t\t\t    \" continuing without it\\n\");\n\t\t\tmemset(&ark->user_ext, 0, sizeof(struct ark_user_ext));\n\t\t\tdlclose(ark->d_handle);\n\t\t}\n\t}\n\n\tif (pci_dev->device.devargs)\n\t\tret = eth_ark_check_args(ark, pci_dev->device.devargs->args);\n\telse\n\t\tPMD_DRV_LOG(INFO, \"No Device args found\\n\");\n\n\tif (ret)\n\t\tgoto error;\n\t/*\n\t * We will create additional devices based on the number of requested\n\t * ports\n\t */\n\tif (ark->user_ext.dev_get_port_count)\n\t\tport_count =\n\t\t\tark->user_ext.dev_get_port_count(dev,\n\t\t\t\t ark->user_data[dev->data->port_id]);\n\tark->num_ports = port_count;\n\n\tfor (p = 0; p < port_count; p++) {\n\t\tstruct rte_eth_dev *eth_dev;\n\t\tchar name[RTE_ETH_NAME_MAX_LEN];\n\n\t\tsnprintf(name, sizeof(name), \"arketh%d\",\n\t\t\t dev->data->port_id + p);\n\n\t\tif (p == 0) {\n\t\t\t/* First port is already allocated by DPDK */\n\t\t\teth_dev = ark->eth_dev;\n\t\t\trte_eth_dev_probing_finish(eth_dev);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* reserve an ethdev entry */\n\t\teth_dev = rte_eth_dev_allocate(name);\n\t\tif (!eth_dev) {\n\t\t\tPMD_DRV_LOG(ERR,\n\t\t\t\t    \"Could not allocate eth_dev for port %d\\n\",\n\t\t\t\t    p);\n\t\t\tgoto error;\n\t\t}\n\n\t\teth_dev->device = &pci_dev->device;\n\t\teth_dev->data->dev_private = ark;\n\t\teth_dev->dev_ops = ark->eth_dev->dev_ops;\n\t\teth_dev->tx_pkt_burst = ark->eth_dev->tx_pkt_burst;\n\t\teth_dev->rx_pkt_burst = ark->eth_dev->rx_pkt_burst;\n\n\t\trte_eth_copy_pci_info(eth_dev, pci_dev);\n\n\t\teth_dev->data->mac_addrs = rte_zmalloc(name,\n\t\t\t\t\t\tRTE_ETHER_ADDR_LEN, 0);\n\t\tif (!eth_dev->data->mac_addrs) {\n\t\t\tPMD_DRV_LOG(ERR,\n\t\t\t\t    \"Memory allocation for MAC failed!\"\n\t\t\t\t    \" Exiting.\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (ark->user_ext.dev_init) {\n\t\t\tark->user_data[eth_dev->data->port_id] =\n\t\t\t\tark->user_ext.dev_init(dev, ark->a_bar, p);\n\t\t}\n\n\t\trte_eth_dev_probing_finish(eth_dev);\n\t}\n\n\treturn ret;\n\nerror:\n\trte_free(dev->data->mac_addrs);\n\tdev->data->mac_addrs = NULL;\n\treturn -1;\n}\n\n/*\n *Initial device configuration when device is opened\n * setup the DDM, and UDM\n * Called once per PCIE device\n */\nstatic int\nark_config_device(struct rte_eth_dev *dev)\n{\n\tstruct ark_adapter *ark = dev->data->dev_private;\n\tuint16_t num_q, i;\n\tstruct ark_mpu_t *mpu;\n\n\t/*\n\t * Make sure that the packet director, generator and checker are in a\n\t * known state\n\t */\n\tark->start_pg = 0;\n\tark->pg = ark_pktgen_init(ark->pktgen.v, 0, 1);\n\tif (ark->pg == NULL)\n\t\treturn -1;\n\tark_pktgen_reset(ark->pg);\n\tark->pc = ark_pktchkr_init(ark->pktchkr.v, 0, 1);\n\tif (ark->pc == NULL)\n\t\treturn -1;\n\tark_pktchkr_stop(ark->pc);\n\tark->pd = ark_pktdir_init(ark->pktdir.v);\n\tif (ark->pd == NULL)\n\t\treturn -1;\n\n\t/* Verify HW */\n\tif (ark_udm_verify(ark->udm.v))\n\t\treturn -1;\n\tif (ark_ddm_verify(ark->ddm.v))\n\t\treturn -1;\n\n\t/* UDM */\n\tif (ark_udm_reset(ark->udm.v)) {\n\t\tPMD_DRV_LOG(ERR, \"Unable to stop and reset UDM\\n\");\n\t\treturn -1;\n\t}\n\t/* Keep in reset until the MPU are cleared */\n\n\t/* MPU reset */\n\tmpu = ark->mpurx.v;\n\tnum_q = ark_api_num_queues(mpu);\n\tark->rx_queues = num_q;\n\tfor (i = 0; i < num_q; i++) {\n\t\tark_mpu_reset(mpu);\n\t\tmpu = RTE_PTR_ADD(mpu, ARK_MPU_QOFFSET);\n\t}\n\n\tark_udm_stop(ark->udm.v, 0);\n\tark_udm_configure(ark->udm.v,\n\t\t\t  RTE_PKTMBUF_HEADROOM,\n\t\t\t  RTE_MBUF_DEFAULT_DATAROOM,\n\t\t\t  ARK_RX_WRITE_TIME_NS);\n\tark_udm_stats_reset(ark->udm.v);\n\tark_udm_stop(ark->udm.v, 0);\n\n\t/* TX -- DDM */\n\tif (ark_ddm_stop(ark->ddm.v, 1))\n\t\tPMD_DRV_LOG(ERR, \"Unable to stop DDM\\n\");\n\n\tmpu = ark->mputx.v;\n\tnum_q = ark_api_num_queues(mpu);\n\tark->tx_queues = num_q;\n\tfor (i = 0; i < num_q; i++) {\n\t\tark_mpu_reset(mpu);\n\t\tmpu = RTE_PTR_ADD(mpu, ARK_MPU_QOFFSET);\n\t}\n\n\tark_ddm_reset(ark->ddm.v);\n\tark_ddm_stats_reset(ark->ddm.v);\n\n\tark_ddm_stop(ark->ddm.v, 0);\n\tark_rqp_stats_reset(ark->rqpacing);\n\n\treturn 0;\n}\n\nstatic int\neth_ark_dev_uninit(struct rte_eth_dev *dev)\n{\n\tstruct ark_adapter *ark = dev->data->dev_private;\n\n\tif (rte_eal_process_type() != RTE_PROC_PRIMARY)\n\t\treturn 0;\n\n\tif (ark->user_ext.dev_uninit)\n\t\tark->user_ext.dev_uninit(dev,\n\t\t\t ark->user_data[dev->data->port_id]);\n\n\tark_pktgen_uninit(ark->pg);\n\tark_pktchkr_uninit(ark->pc);\n\n\tdev->dev_ops = NULL;\n\tdev->rx_pkt_burst = NULL;\n\tdev->tx_pkt_burst = NULL;\n\treturn 0;\n}\n\nstatic int\neth_ark_dev_configure(struct rte_eth_dev *dev)\n{\n\tPMD_FUNC_LOG(DEBUG, \"\\n\");\n\tstruct ark_adapter *ark = dev->data->dev_private;\n\n\teth_ark_dev_set_link_up(dev);\n\tif (ark->user_ext.dev_configure)\n\t\treturn ark->user_ext.dev_configure(dev,\n\t\t\t   ark->user_data[dev->data->port_id]);\n\treturn 0;\n}\n\nstatic void *\ndelay_pg_start(void *arg)\n{\n\tstruct ark_adapter *ark = (struct ark_adapter *)arg;\n\n\t/* This function is used exclusively for regression testing, We\n\t * perform a blind sleep here to ensure that the external test\n\t * application has time to setup the test before we generate packets\n\t */\n\tusleep(100000);\n\tark_pktgen_run(ark->pg);\n\treturn NULL;\n}\n\nstatic int\neth_ark_dev_start(struct rte_eth_dev *dev)\n{\n\tstruct ark_adapter *ark = dev->data->dev_private;\n\tint i;\n\n\tPMD_FUNC_LOG(DEBUG, \"\\n\");\n\n\t/* RX Side */\n\t/* start UDM */\n\tark_udm_start(ark->udm.v);\n\n\tfor (i = 0; i < dev->data->nb_rx_queues; i++)\n\t\teth_ark_rx_start_queue(dev, i);\n\n\t/* TX Side */\n\tfor (i = 0; i < dev->data->nb_tx_queues; i++)\n\t\teth_ark_tx_queue_start(dev, i);\n\n\t/* start DDM */\n\tark_ddm_start(ark->ddm.v);\n\n\tark->started = 1;\n\t/* set xmit and receive function */\n\tdev->rx_pkt_burst = &eth_ark_recv_pkts;\n\tdev->tx_pkt_burst = &eth_ark_xmit_pkts;\n\n\tif (ark->start_pg)\n\t\tark_pktchkr_run(ark->pc);\n\n\tif (ark->start_pg && (dev->data->port_id == 0)) {\n\t\tpthread_t thread;\n\n\t\t/* Delay packet generatpr start allow the hardware to be ready\n\t\t * This is only used for sanity checking with internal generator\n\t\t */\n\t\tif (pthread_create(&thread, NULL, delay_pg_start, ark)) {\n\t\t\tPMD_DRV_LOG(ERR, \"Could not create pktgen \"\n\t\t\t\t    \"starter thread\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (ark->user_ext.dev_start)\n\t\tark->user_ext.dev_start(dev,\n\t\t\tark->user_data[dev->data->port_id]);\n\n\treturn 0;\n}\n\nstatic void\neth_ark_dev_stop(struct rte_eth_dev *dev)\n{\n\tuint16_t i;\n\tint status;\n\tstruct ark_adapter *ark = dev->data->dev_private;\n\tstruct ark_mpu_t *mpu;\n\n\tPMD_FUNC_LOG(DEBUG, \"\\n\");\n\n\tif (ark->started == 0)\n\t\treturn;\n\tark->started = 0;\n\n\t/* Stop the extension first */\n\tif (ark->user_ext.dev_stop)\n\t\tark->user_ext.dev_stop(dev,\n\t\t       ark->user_data[dev->data->port_id]);\n\n\t/* Stop the packet generator */\n\tif (ark->start_pg)\n\t\tark_pktgen_pause(ark->pg);\n\n\tdev->rx_pkt_burst = &eth_ark_recv_pkts_noop;\n\tdev->tx_pkt_burst = &eth_ark_xmit_pkts_noop;\n\n\t/* STOP TX Side */\n\tfor (i = 0; i < dev->data->nb_tx_queues; i++) {\n\t\tstatus = eth_ark_tx_queue_stop(dev, i);\n\t\tif (status != 0) {\n\t\t\tuint16_t port = dev->data->port_id;\n\t\t\tPMD_DRV_LOG(ERR,\n\t\t\t\t    \"tx_queue stop anomaly\"\n\t\t\t\t    \" port %u, queue %u\\n\",\n\t\t\t\t    port, i);\n\t\t}\n\t}\n\n\t/* Stop DDM */\n\t/* Wait up to 0.1 second.  each stop is up to 1000 * 10 useconds */\n\tfor (i = 0; i < 10; i++) {\n\t\tstatus = ark_ddm_stop(ark->ddm.v, 1);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t}\n\tif (status || i != 0) {\n\t\tPMD_DRV_LOG(ERR, \"DDM stop anomaly. status:\"\n\t\t\t    \" %d iter: %u. (%s)\\n\",\n\t\t\t    status,\n\t\t\t    i,\n\t\t\t    __func__);\n\t\tark_ddm_dump(ark->ddm.v, \"Stop anomaly\");\n\n\t\tmpu = ark->mputx.v;\n\t\tfor (i = 0; i < ark->tx_queues; i++) {\n\t\t\tark_mpu_dump(mpu, \"DDM failure dump\", i);\n\t\t\tmpu = RTE_PTR_ADD(mpu, ARK_MPU_QOFFSET);\n\t\t}\n\t}\n\n\t/* STOP RX Side */\n\t/* Stop UDM  multiple tries attempted */\n\tfor (i = 0; i < 10; i++) {\n\t\tstatus = ark_udm_stop(ark->udm.v, 1);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t}\n\tif (status || i != 0) {\n\t\tPMD_DRV_LOG(ERR, \"UDM stop anomaly. status %d iter: %u. (%s)\\n\",\n\t\t\t    status, i, __func__);\n\t\tark_udm_dump(ark->udm.v, \"Stop anomaly\");\n\n\t\tmpu = ark->mpurx.v;\n\t\tfor (i = 0; i < ark->rx_queues; i++) {\n\t\t\tark_mpu_dump(mpu, \"UDM Stop anomaly\", i);\n\t\t\tmpu = RTE_PTR_ADD(mpu, ARK_MPU_QOFFSET);\n\t\t}\n\t}\n\n\tark_udm_dump_stats(ark->udm.v, \"Post stop\");\n\tark_udm_dump_perf(ark->udm.v, \"Post stop\");\n\n\tfor (i = 0; i < dev->data->nb_rx_queues; i++)\n\t\teth_ark_rx_dump_queue(dev, i, __func__);\n\n\t/* Stop the packet checker if it is running */\n\tif (ark->start_pg) {\n\t\tark_pktchkr_dump_stats(ark->pc);\n\t\tark_pktchkr_stop(ark->pc);\n\t}\n}\n\nstatic void\neth_ark_dev_close(struct rte_eth_dev *dev)\n{\n\tstruct ark_adapter *ark = dev->data->dev_private;\n\tuint16_t i;\n\n\tif (ark->user_ext.dev_close)\n\t\tark->user_ext.dev_close(dev,\n\t\t ark->user_data[dev->data->port_id]);\n\n\teth_ark_dev_stop(dev);\n\teth_ark_udm_force_close(dev);\n\n\t/*\n\t * TODO This should only be called once for the device during shutdown\n\t */\n\tark_rqp_dump(ark->rqpacing);\n\n\tfor (i = 0; i < dev->data->nb_tx_queues; i++) {\n\t\teth_ark_tx_queue_release(dev->data->tx_queues[i]);\n\t\tdev->data->tx_queues[i] = 0;\n\t}\n\n\tfor (i = 0; i < dev->data->nb_rx_queues; i++) {\n\t\teth_ark_dev_rx_queue_release(dev->data->rx_queues[i]);\n\t\tdev->data->rx_queues[i] = 0;\n\t}\n\n\trte_free(dev->data->mac_addrs);\n\tdev->data->mac_addrs = 0;\n}\n\nstatic int\neth_ark_dev_info_get(struct rte_eth_dev *dev,\n\t\t     struct rte_eth_dev_info *dev_info)\n{\n\tstruct ark_adapter *ark = dev->data->dev_private;\n\tstruct ark_mpu_t *tx_mpu = RTE_PTR_ADD(ark->bar0, ARK_MPU_TX_BASE);\n\tstruct ark_mpu_t *rx_mpu = RTE_PTR_ADD(ark->bar0, ARK_MPU_RX_BASE);\n\tuint16_t ports = ark->num_ports;\n\n\tdev_info->max_rx_pktlen = ARK_RX_MAX_PKT_LEN;\n\tdev_info->min_rx_bufsize = ARK_RX_MIN_BUFSIZE;\n\n\tdev_info->max_rx_queues = ark_api_num_queues_per_port(rx_mpu, ports);\n\tdev_info->max_tx_queues = ark_api_num_queues_per_port(tx_mpu, ports);\n\n\tdev_info->rx_desc_lim = (struct rte_eth_desc_lim) {\n\t\t.nb_max = ARK_RX_MAX_QUEUE,\n\t\t.nb_min = ARK_RX_MIN_QUEUE,\n\t\t.nb_align = ARK_RX_MIN_QUEUE}; /* power of 2 */\n\n\tdev_info->tx_desc_lim = (struct rte_eth_desc_lim) {\n\t\t.nb_max = ARK_TX_MAX_QUEUE,\n\t\t.nb_min = ARK_TX_MIN_QUEUE,\n\t\t.nb_align = ARK_TX_MIN_QUEUE}; /* power of 2 */\n\n\t/* ARK PMD supports all line rates, how do we indicate that here ?? */\n\tdev_info->speed_capa = (ETH_LINK_SPEED_1G |\n\t\t\t\tETH_LINK_SPEED_10G |\n\t\t\t\tETH_LINK_SPEED_25G |\n\t\t\t\tETH_LINK_SPEED_40G |\n\t\t\t\tETH_LINK_SPEED_50G |\n\t\t\t\tETH_LINK_SPEED_100G);\n\n\treturn 0;\n}\n\nstatic int\neth_ark_dev_link_update(struct rte_eth_dev *dev, int wait_to_complete)\n{\n\tPMD_DEBUG_LOG(DEBUG, \"link status = %d\\n\",\n\t\t\tdev->data->dev_link.link_status);\n\tstruct ark_adapter *ark = dev->data->dev_private;\n\n\tif (ark->user_ext.link_update) {\n\t\treturn ark->user_ext.link_update\n\t\t\t(dev, wait_to_complete,\n\t\t\t ark->user_data[dev->data->port_id]);\n\t}\n\treturn 0;\n}\n\nstatic int\neth_ark_dev_set_link_up(struct rte_eth_dev *dev)\n{\n\tdev->data->dev_link.link_status = 1;\n\tstruct ark_adapter *ark = dev->data->dev_private;\n\n\tif (ark->user_ext.dev_set_link_up)\n\t\treturn ark->user_ext.dev_set_link_up(dev,\n\t\t\t     ark->user_data[dev->data->port_id]);\n\treturn 0;\n}\n\nstatic int\neth_ark_dev_set_link_down(struct rte_eth_dev *dev)\n{\n\tdev->data->dev_link.link_status = 0;\n\tstruct ark_adapter *ark = dev->data->dev_private;\n\n\tif (ark->user_ext.dev_set_link_down)\n\t\treturn ark->user_ext.dev_set_link_down(dev,\n\t\t       ark->user_data[dev->data->port_id]);\n\treturn 0;\n}\n\nstatic int\neth_ark_dev_stats_get(struct rte_eth_dev *dev, struct rte_eth_stats *stats)\n{\n\tuint16_t i;\n\tstruct ark_adapter *ark = dev->data->dev_private;\n\n\tstats->ipackets = 0;\n\tstats->ibytes = 0;\n\tstats->opackets = 0;\n\tstats->obytes = 0;\n\tstats->imissed = 0;\n\tstats->oerrors = 0;\n\n\tfor (i = 0; i < dev->data->nb_tx_queues; i++)\n\t\teth_tx_queue_stats_get(dev->data->tx_queues[i], stats);\n\tfor (i = 0; i < dev->data->nb_rx_queues; i++)\n\t\teth_rx_queue_stats_get(dev->data->rx_queues[i], stats);\n\tif (ark->user_ext.stats_get)\n\t\treturn ark->user_ext.stats_get(dev, stats,\n\t\t\tark->user_data[dev->data->port_id]);\n\treturn 0;\n}\n\nstatic int\neth_ark_dev_stats_reset(struct rte_eth_dev *dev)\n{\n\tuint16_t i;\n\tstruct ark_adapter *ark = dev->data->dev_private;\n\n\tfor (i = 0; i < dev->data->nb_tx_queues; i++)\n\t\teth_tx_queue_stats_reset(dev->data->tx_queues[i]);\n\tfor (i = 0; i < dev->data->nb_rx_queues; i++)\n\t\teth_rx_queue_stats_reset(dev->data->rx_queues[i]);\n\tif (ark->user_ext.stats_reset)\n\t\tark->user_ext.stats_reset(dev,\n\t\t\t  ark->user_data[dev->data->port_id]);\n\n\treturn 0;\n}\n\nstatic int\neth_ark_macaddr_add(struct rte_eth_dev *dev,\n\t\t    struct rte_ether_addr *mac_addr,\n\t\t    uint32_t index,\n\t\t    uint32_t pool)\n{\n\tstruct ark_adapter *ark = dev->data->dev_private;\n\n\tif (ark->user_ext.mac_addr_add) {\n\t\tark->user_ext.mac_addr_add(dev,\n\t\t\t\t\t   mac_addr,\n\t\t\t\t\t   index,\n\t\t\t\t\t   pool,\n\t\t\t   ark->user_data[dev->data->port_id]);\n\t\treturn 0;\n\t}\n\treturn -ENOTSUP;\n}\n\nstatic void\neth_ark_macaddr_remove(struct rte_eth_dev *dev, uint32_t index)\n{\n\tstruct ark_adapter *ark = dev->data->dev_private;\n\n\tif (ark->user_ext.mac_addr_remove)\n\t\tark->user_ext.mac_addr_remove(dev, index,\n\t\t\t      ark->user_data[dev->data->port_id]);\n}\n\nstatic int\neth_ark_set_default_mac_addr(struct rte_eth_dev *dev,\n\t\t\t     struct rte_ether_addr *mac_addr)\n{\n\tstruct ark_adapter *ark = dev->data->dev_private;\n\n\tif (ark->user_ext.mac_addr_set) {\n\t\tark->user_ext.mac_addr_set(dev, mac_addr,\n\t\t\t   ark->user_data[dev->data->port_id]);\n\t\treturn 0;\n\t}\n\treturn -ENOTSUP;\n}\n\nstatic int\neth_ark_set_mtu(struct rte_eth_dev *dev, uint16_t  size)\n{\n\tstruct ark_adapter *ark = dev->data->dev_private;\n\n\tif (ark->user_ext.set_mtu)\n\t\treturn ark->user_ext.set_mtu(dev, size,\n\t\t\t     ark->user_data[dev->data->port_id]);\n\n\treturn -ENOTSUP;\n}\n\nstatic inline int\nprocess_pktdir_arg(const char *key, const char *value,\n\t\t   void *extra_args)\n{\n\tPMD_FUNC_LOG(DEBUG, \"key = %s, value = %s\\n\",\n\t\t    key, value);\n\tstruct ark_adapter *ark =\n\t\t(struct ark_adapter *)extra_args;\n\n\tark->pkt_dir_v = strtol(value, NULL, 16);\n\tPMD_FUNC_LOG(DEBUG, \"pkt_dir_v = 0x%x\\n\", ark->pkt_dir_v);\n\treturn 0;\n}\n\nstatic inline int\nprocess_file_args(const char *key, const char *value, void *extra_args)\n{\n\tPMD_FUNC_LOG(DEBUG, \"key = %s, value = %s\\n\",\n\t\t    key, value);\n\tchar *args = (char *)extra_args;\n\n\t/* Open the configuration file */\n\tFILE *file = fopen(value, \"r\");\n\tchar line[ARK_MAX_ARG_LEN];\n\tint  size = 0;\n\tint first = 1;\n\n\tif (file == NULL) {\n\t\tPMD_DRV_LOG(ERR, \"Unable to open \"\n\t\t\t    \"config file %s\\n\", value);\n\t\treturn -1;\n\t}\n\n\twhile (fgets(line, sizeof(line), file)) {\n\t\tsize += strlen(line);\n\t\tif (size >= ARK_MAX_ARG_LEN) {\n\t\t\tPMD_DRV_LOG(ERR, \"Unable to parse file %s args, \"\n\t\t\t\t    \"parameter list is too long\\n\", value);\n\t\t\tfclose(file);\n\t\t\treturn -1;\n\t\t}\n\t\tif (first) {\n\t\t\tstrncpy(args, line, ARK_MAX_ARG_LEN);\n\t\t\tfirst = 0;\n\t\t} else {\n\t\t\tstrncat(args, line, ARK_MAX_ARG_LEN);\n\t\t}\n\t}\n\tPMD_FUNC_LOG(DEBUG, \"file = %s\\n\", args);\n\tfclose(file);\n\treturn 0;\n}\n\nstatic int\neth_ark_check_args(struct ark_adapter *ark, const char *params)\n{\n\tstruct rte_kvargs *kvlist;\n\tunsigned int k_idx;\n\tstruct rte_kvargs_pair *pair = NULL;\n\tint ret = -1;\n\n\tkvlist = rte_kvargs_parse(params, valid_arguments);\n\tif (kvlist == NULL)\n\t\treturn 0;\n\n\tark->pkt_gen_args[0] = 0;\n\tark->pkt_chkr_args[0] = 0;\n\n\tfor (k_idx = 0; k_idx < kvlist->count; k_idx++) {\n\t\tpair = &kvlist->pairs[k_idx];\n\t\tPMD_FUNC_LOG(DEBUG, \"**** Arg passed to PMD = %s:%s\\n\",\n\t\t\t     pair->key,\n\t\t\t     pair->value);\n\t}\n\n\tif (rte_kvargs_process(kvlist,\n\t\t\t       ARK_PKTDIR_ARG,\n\t\t\t       &process_pktdir_arg,\n\t\t\t       ark) != 0) {\n\t\tPMD_DRV_LOG(ERR, \"Unable to parse arg %s\\n\", ARK_PKTDIR_ARG);\n\t\tgoto free_kvlist;\n\t}\n\n\tif (rte_kvargs_process(kvlist,\n\t\t\t       ARK_PKTGEN_ARG,\n\t\t\t       &process_file_args,\n\t\t\t       ark->pkt_gen_args) != 0) {\n\t\tPMD_DRV_LOG(ERR, \"Unable to parse arg %s\\n\", ARK_PKTGEN_ARG);\n\t\tgoto free_kvlist;\n\t}\n\n\tif (rte_kvargs_process(kvlist,\n\t\t\t       ARK_PKTCHKR_ARG,\n\t\t\t       &process_file_args,\n\t\t\t       ark->pkt_chkr_args) != 0) {\n\t\tPMD_DRV_LOG(ERR, \"Unable to parse arg %s\\n\", ARK_PKTCHKR_ARG);\n\t\tgoto free_kvlist;\n\t}\n\n\tPMD_DRV_LOG(INFO, \"packet director set to 0x%x\\n\", ark->pkt_dir_v);\n\t/* Setup the packet director */\n\tark_pktdir_setup(ark->pd, ark->pkt_dir_v);\n\n\t/* Setup the packet generator */\n\tif (ark->pkt_gen_args[0]) {\n\t\tPMD_DRV_LOG(INFO, \"Setting up the packet generator\\n\");\n\t\tark_pktgen_parse(ark->pkt_gen_args);\n\t\tark_pktgen_reset(ark->pg);\n\t\tark_pktgen_setup(ark->pg);\n\t\tark->start_pg = 1;\n\t}\n\n\t/* Setup the packet checker */\n\tif (ark->pkt_chkr_args[0]) {\n\t\tark_pktchkr_parse(ark->pkt_chkr_args);\n\t\tark_pktchkr_setup(ark->pc);\n\t}\n\n\tret = 0;\n\nfree_kvlist:\n\trte_kvargs_free(kvlist);\n\n\treturn ret;\n}\n\nRTE_PMD_REGISTER_PCI(net_ark, rte_ark_pmd);\nRTE_PMD_REGISTER_KMOD_DEP(net_ark, \"* igb_uio | uio_pci_generic \");\nRTE_PMD_REGISTER_PCI_TABLE(net_ark, pci_id_ark_map);\nRTE_PMD_REGISTER_PARAM_STRING(net_ark,\n\t\t\t      ARK_PKTGEN_ARG \"=<filename> \"\n\t\t\t      ARK_PKTCHKR_ARG \"=<filename> \"\n\t\t\t      ARK_PKTDIR_ARG \"=<bitmap>\");\n\nRTE_INIT(ark_init_log)\n{\n\tark_logtype = rte_log_register(\"pmd.net.ark\");\n\tif (ark_logtype >= 0)\n\t\trte_log_set_level(ark_logtype, RTE_LOG_NOTICE);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/nics/mlx4.rst": "..  SPDX-License-Identifier: BSD-3-Clause\n    Copyright 2012 6WIND S.A.\n    Copyright 2015 Mellanox Technologies, Ltd\n\nMLX4 poll mode driver library\n=============================\n\nThe MLX4 poll mode driver library (**librte_pmd_mlx4**) implements support\nfor **Mellanox ConnectX-3** and **Mellanox ConnectX-3 Pro** 10/40 Gbps adapters\nas well as their virtual functions (VF) in SR-IOV context.\n\nInformation and documentation about this family of adapters can be found on\nthe `Mellanox website <http://www.mellanox.com>`_. Help is also provided by\nthe `Mellanox community <http://community.mellanox.com/welcome>`_.\n\nThere is also a `section dedicated to this poll mode driver\n<http://www.mellanox.com/page/products_dyn?product_family=209&mtag=pmd_for_dpdk>`_.\n\n.. note::\n\n   Due to external dependencies, this driver is disabled by default. It must\n   be enabled manually by setting ``CONFIG_RTE_LIBRTE_MLX4_PMD=y`` and\n   recompiling DPDK.\n\nImplementation details\n----------------------\n\nMost Mellanox ConnectX-3 devices provide two ports but expose a single PCI\nbus address, thus unlike most drivers, librte_pmd_mlx4 registers itself as a\nPCI driver that allocates one Ethernet device per detected port.\n\nFor this reason, one cannot white/blacklist a single port without also\nwhite/blacklisting the others on the same device.\n\nBesides its dependency on libibverbs (that implies libmlx4 and associated\nkernel support), librte_pmd_mlx4 relies heavily on system calls for control\noperations such as querying/updating the MTU and flow control parameters.\n\nFor security reasons and robustness, this driver only deals with virtual\nmemory addresses. The way resources allocations are handled by the kernel\ncombined with hardware specifications that allow it to handle virtual memory\naddresses directly ensure that DPDK applications cannot access random\nphysical memory (or memory that does not belong to the current process).\n\nThis capability allows the PMD to coexist with kernel network interfaces\nwhich remain functional, although they stop receiving unicast packets as\nlong as they share the same MAC address.\n\nThe :ref:`flow_isolated_mode` is supported.\n\nCompiling librte_pmd_mlx4 causes DPDK to be linked against libibverbs.\n\nConfiguration\n-------------\n\nCompilation options\n~~~~~~~~~~~~~~~~~~~\n\nThese options can be modified in the ``.config`` file.\n\n- ``CONFIG_RTE_LIBRTE_MLX4_PMD`` (default **n**)\n\n  Toggle compilation of librte_pmd_mlx4 itself.\n\n- ``CONFIG_RTE_IBVERBS_LINK_DLOPEN`` (default **n**)\n\n  Build PMD with additional code to make it loadable without hard\n  dependencies on **libibverbs** nor **libmlx4**, which may not be installed\n  on the target system.\n\n  In this mode, their presence is still required for it to run properly,\n  however their absence won't prevent a DPDK application from starting (with\n  ``CONFIG_RTE_BUILD_SHARED_LIB`` disabled) and they won't show up as\n  missing with ``ldd(1)``.\n\n  It works by moving these dependencies to a purpose-built rdma-core \"glue\"\n  plug-in which must either be installed in a directory whose name is based\n  on ``CONFIG_RTE_EAL_PMD_PATH`` suffixed with ``-glue`` if set, or in a\n  standard location for the dynamic linker (e.g. ``/lib``) if left to the\n  default empty string (``\"\"``).\n\n  This option has no performance impact.\n\n- ``CONFIG_RTE_IBVERBS_LINK_STATIC`` (default **n**)\n\n  Embed static flavor of the dependencies **libibverbs** and **libmlx4**\n  in the PMD shared library or the executable static binary.\n\n- ``CONFIG_RTE_LIBRTE_MLX4_DEBUG`` (default **n**)\n\n  Toggle debugging code and stricter compilation flags. Enabling this option\n  adds additional run-time checks and debugging messages at the cost of\n  lower performance.\n\nThis option is available in meson:\n\n- ``ibverbs_link`` can be ``static``, ``shared``, or ``dlopen``.\n\nEnvironment variables\n~~~~~~~~~~~~~~~~~~~~~\n\n- ``MLX4_GLUE_PATH``\n\n  A list of directories in which to search for the rdma-core \"glue\" plug-in,\n  separated by colons or semi-colons.\n\n  Only matters when compiled with ``CONFIG_RTE_IBVERBS_LINK_DLOPEN``\n  enabled and most useful when ``CONFIG_RTE_EAL_PMD_PATH`` is also set,\n  since ``LD_LIBRARY_PATH`` has no effect in this case.\n\nRun-time configuration\n~~~~~~~~~~~~~~~~~~~~~~\n\n- librte_pmd_mlx4 brings kernel network interfaces up during initialization\n  because it is affected by their state. Forcing them down prevents packets\n  reception.\n\n- **ethtool** operations on related kernel interfaces also affect the PMD.\n\n- ``port`` parameter [int]\n\n  This parameter provides a physical port to probe and can be specified multiple\n  times for additional ports. All ports are probed by default if left\n  unspecified.\n\n- ``mr_ext_memseg_en`` parameter [int]\n\n  A nonzero value enables extending memseg when registering DMA memory. If\n  enabled, the number of entries in MR (Memory Region) lookup table on datapath\n  is minimized and it benefits performance. On the other hand, it worsens memory\n  utilization because registered memory is pinned by kernel driver. Even if a\n  page in the extended chunk is freed, that doesn't become reusable until the\n  entire memory is freed.\n\n  Enabled by default.\n\nKernel module parameters\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe **mlx4_core** kernel module has several parameters that affect the\nbehavior and/or the performance of librte_pmd_mlx4. Some of them are described\nbelow.\n\n- **num_vfs** (integer or triplet, optionally prefixed by device address\n  strings)\n\n  Create the given number of VFs on the specified devices.\n\n- **log_num_mgm_entry_size** (integer)\n\n  Device-managed flow steering (DMFS) is required by DPDK applications. It is\n  enabled by using a negative value, the last four bits of which have a\n  special meaning.\n\n  - **-1**: force device-managed flow steering (DMFS).\n  - **-7**: configure optimized steering mode to improve performance with the\n    following limitation: VLAN filtering is not supported with this mode.\n    This is the recommended mode in case VLAN filter is not needed.\n\nLimitations\n-----------\n\n- For secondary process:\n\n  - Forked secondary process not supported.\n  - External memory unregistered in EAL memseg list cannot be used for DMA\n    unless such memory has been registered by ``mlx4_mr_update_ext_mp()`` in\n    primary process and remapped to the same virtual address in secondary\n    process. If the external memory is registered by primary process but has\n    different virtual address in secondary process, unexpected error may happen.\n\n- CRC stripping is supported by default and always reported as \"true\".\n  The ability to enable/disable CRC stripping requires OFED version\n  4.3-1.5.0.0 and above  or rdma-core version v18 and above.\n\n- TSO (Transmit Segmentation Offload) is supported in OFED version\n  4.4 and above.\n\nPrerequisites\n-------------\n\nThis driver relies on external libraries and kernel drivers for resources\nallocations and initialization. The following dependencies are not part of\nDPDK and must be installed separately:\n\n- **libibverbs** (provided by rdma-core package)\n\n  User space verbs framework used by librte_pmd_mlx4. This library provides\n  a generic interface between the kernel and low-level user space drivers\n  such as libmlx4.\n\n  It allows slow and privileged operations (context initialization, hardware\n  resources allocations) to be managed by the kernel and fast operations to\n  never leave user space.\n\n- **libmlx4** (provided by rdma-core package)\n\n  Low-level user space driver library for Mellanox ConnectX-3 devices,\n  it is automatically loaded by libibverbs.\n\n  This library basically implements send/receive calls to the hardware\n  queues.\n\n- **Kernel modules**\n\n  They provide the kernel-side verbs API and low level device drivers that\n  manage actual hardware initialization and resources sharing with user\n  space processes.\n\n  Unlike most other PMDs, these modules must remain loaded and bound to\n  their devices:\n\n  - mlx4_core: hardware driver managing Mellanox ConnectX-3 devices.\n  - mlx4_en: Ethernet device driver that provides kernel network interfaces.\n  - mlx4_ib: InifiniBand device driver.\n  - ib_uverbs: user space driver for verbs (entry point for libibverbs).\n\n- **Firmware update**\n\n  Mellanox OFED releases include firmware updates for ConnectX-3 adapters.\n\n  Because each release provides new features, these updates must be applied to\n  match the kernel modules and libraries they come with.\n\n.. note::\n\n   Both libraries are BSD and GPL licensed. Linux kernel modules are GPL\n   licensed.\n\nDepending on system constraints and user preferences either RDMA core library\nwith a recent enough Linux kernel release (recommended) or Mellanox OFED,\nwhich provides compatibility with older releases.\n\nCurrent RDMA core package and Linux kernel (recommended)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n- Minimal Linux kernel version: 4.14.\n- Minimal RDMA core version: v15 (see `RDMA core installation documentation`_).\n\n- Starting with rdma-core v21, static libraries can be built::\n\n    cd build\n    CFLAGS=-fPIC cmake -DIN_PLACE=1 -DENABLE_STATIC=1 -GNinja ..\n    ninja\n\n.. _`RDMA core installation documentation`: https://raw.githubusercontent.com/linux-rdma/rdma-core/master/README.md\n\nIf rdma-core libraries are built but not installed, DPDK makefile can link them,\nthanks to these environment variables:\n\n   - ``EXTRA_CFLAGS=-I/path/to/rdma-core/build/include``\n   - ``EXTRA_LDFLAGS=-L/path/to/rdma-core/build/lib``\n   - ``PKG_CONFIG_PATH=/path/to/rdma-core/build/lib/pkgconfig``\n\n.. _Mellanox_OFED_as_a_fallback:\n\nMellanox OFED as a fallback\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n- `Mellanox OFED`_ version: **4.4, 4.5, 4.6**.\n- firmware version: **2.42.5000** and above.\n\n.. _`Mellanox OFED`: http://www.mellanox.com/page/products_dyn?product_family=26&mtag=linux_sw_drivers\n\n.. note::\n\n   Several versions of Mellanox OFED are available. Installing the version\n   this DPDK release was developed and tested against is strongly\n   recommended. Please check the `prerequisites`_.\n\nInstalling Mellanox OFED\n^^^^^^^^^^^^^^^^^^^^^^^^\n\n1. Download latest Mellanox OFED.\n\n2. Install the required libraries and kernel modules either by installing\n   only the required set, or by installing the entire Mellanox OFED:\n\n   For bare metal use::\n\n        ./mlnxofedinstall --dpdk --upstream-libs\n\n   For SR-IOV hypervisors use::\n\n        ./mlnxofedinstall --dpdk --upstream-libs --enable-sriov --hypervisor\n\n   For SR-IOV virtual machine use::\n\n        ./mlnxofedinstall --dpdk --upstream-libs --guest\n\n3. Verify the firmware is the correct one::\n\n        ibv_devinfo\n\n4. Set all ports links to Ethernet, follow instructions on the screen::\n\n        connectx_port_config\n\n5. Continue with :ref:`section 2 of the Quick Start Guide <QSG_2>`.\n\n.. _qsg:\n\nQuick Start Guide\n-----------------\n\n1. Set all ports links to Ethernet::\n\n        PCI=<NIC PCI address>\n        echo eth > \"/sys/bus/pci/devices/$PCI/mlx4_port0\"\n        echo eth > \"/sys/bus/pci/devices/$PCI/mlx4_port1\"\n\n   .. note::\n\n        If using Mellanox OFED one can permanently set the port link\n        to Ethernet using connectx_port_config tool provided by it.\n        :ref:`Mellanox_OFED_as_a_fallback`:\n\n.. _QSG_2:\n\n2. In case of bare metal or hypervisor, configure optimized steering mode\n   by adding the following line to ``/etc/modprobe.d/mlx4_core.conf``::\n\n        options mlx4_core log_num_mgm_entry_size=-7\n\n   .. note::\n\n        If VLAN filtering is used, set log_num_mgm_entry_size=-1.\n        Performance degradation can occur on this case.\n\n3. Restart the driver::\n\n        /etc/init.d/openibd restart\n\n   or::\n\n        service openibd restart\n\n4. Compile DPDK and you are ready to go. See instructions on\n   :ref:`Development Kit Build System <Development_Kit_Build_System>`\n\nPerformance tuning\n------------------\n\n1. Verify the optimized steering mode is configured::\n\n        cat /sys/module/mlx4_core/parameters/log_num_mgm_entry_size\n\n2. Use the CPU near local NUMA node to which the PCIe adapter is connected,\n   for better performance. For VMs, verify that the right CPU\n   and NUMA node are pinned according to the above. Run::\n\n        lstopo-no-graphics\n\n   to identify the NUMA node to which the PCIe adapter is connected.\n\n3. If more than one adapter is used, and root complex capabilities allow\n   to put both adapters on the same NUMA node without PCI bandwidth degradation,\n   it is recommended to locate both adapters on the same NUMA node.\n   This in order to forward packets from one to the other without\n   NUMA performance penalty.\n\n4. Disable pause frames::\n\n        ethtool -A <netdev> rx off tx off\n\n5. Verify IO non-posted prefetch is disabled by default. This can be checked\n   via the BIOS configuration. Please contact you server provider for more\n   information about the settings.\n\n.. note::\n\n        On some machines, depends on the machine integrator, it is beneficial\n        to set the PCI max read request parameter to 1K. This can be\n        done in the following way:\n\n        To query the read request size use::\n\n                setpci -s <NIC PCI address> 68.w\n\n        If the output is different than 3XXX, set it by::\n\n                setpci -s <NIC PCI address> 68.w=3XXX\n\n        The XXX can be different on different systems. Make sure to configure\n        according to the setpci output.\n\n6. To minimize overhead of searching Memory Regions:\n\n   - '--socket-mem' is recommended to pin memory by predictable amount.\n   - Configure per-lcore cache when creating Mempools for packet buffer.\n   - Refrain from dynamically allocating/freeing memory in run-time.\n\nUsage example\n-------------\n\nThis section demonstrates how to launch **testpmd** with Mellanox ConnectX-3\ndevices managed by librte_pmd_mlx4.\n\n#. Load the kernel modules::\n\n      modprobe -a ib_uverbs mlx4_en mlx4_core mlx4_ib\n\n   Alternatively if MLNX_OFED is fully installed, the following script can\n   be run::\n\n      /etc/init.d/openibd restart\n\n   .. note::\n\n      User space I/O kernel modules (uio and igb_uio) are not used and do\n      not have to be loaded.\n\n#. Make sure Ethernet interfaces are in working order and linked to kernel\n   verbs. Related sysfs entries should be present::\n\n      ls -d /sys/class/net/*/device/infiniband_verbs/uverbs* | cut -d / -f 5\n\n   Example output::\n\n      eth2\n      eth3\n      eth4\n      eth5\n\n#. Optionally, retrieve their PCI bus addresses for whitelisting::\n\n      {\n          for intf in eth2 eth3 eth4 eth5;\n          do\n              (cd \"/sys/class/net/${intf}/device/\" && pwd -P);\n          done;\n      } |\n      sed -n 's,.*/\\(.*\\),-w \\1,p'\n\n   Example output::\n\n      -w 0000:83:00.0\n      -w 0000:83:00.0\n      -w 0000:84:00.0\n      -w 0000:84:00.0\n\n   .. note::\n\n      There are only two distinct PCI bus addresses because the Mellanox\n      ConnectX-3 adapters installed on this system are dual port.\n\n#. Request huge pages::\n\n      echo 1024 > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages/nr_hugepages\n\n#. Start testpmd with basic parameters::\n\n      testpmd -l 8-15 -n 4 -w 0000:83:00.0 -w 0000:84:00.0 -- --rxq=2 --txq=2 -i\n\n   Example output::\n\n      [...]\n      EAL: PCI device 0000:83:00.0 on NUMA socket 1\n      EAL:   probe driver: 15b3:1007 librte_pmd_mlx4\n      PMD: librte_pmd_mlx4: PCI information matches, using device \"mlx4_0\" (VF: false)\n      PMD: librte_pmd_mlx4: 2 port(s) detected\n      PMD: librte_pmd_mlx4: port 1 MAC address is 00:02:c9:b5:b7:50\n      PMD: librte_pmd_mlx4: port 2 MAC address is 00:02:c9:b5:b7:51\n      EAL: PCI device 0000:84:00.0 on NUMA socket 1\n      EAL:   probe driver: 15b3:1007 librte_pmd_mlx4\n      PMD: librte_pmd_mlx4: PCI information matches, using device \"mlx4_1\" (VF: false)\n      PMD: librte_pmd_mlx4: 2 port(s) detected\n      PMD: librte_pmd_mlx4: port 1 MAC address is 00:02:c9:b5:ba:b0\n      PMD: librte_pmd_mlx4: port 2 MAC address is 00:02:c9:b5:ba:b1\n      Interactive-mode selected\n      Configuring Port 0 (socket 0)\n      PMD: librte_pmd_mlx4: 0x867d60: TX queues number update: 0 -> 2\n      PMD: librte_pmd_mlx4: 0x867d60: RX queues number update: 0 -> 2\n      Port 0: 00:02:C9:B5:B7:50\n      Configuring Port 1 (socket 0)\n      PMD: librte_pmd_mlx4: 0x867da0: TX queues number update: 0 -> 2\n      PMD: librte_pmd_mlx4: 0x867da0: RX queues number update: 0 -> 2\n      Port 1: 00:02:C9:B5:B7:51\n      Configuring Port 2 (socket 0)\n      PMD: librte_pmd_mlx4: 0x867de0: TX queues number update: 0 -> 2\n      PMD: librte_pmd_mlx4: 0x867de0: RX queues number update: 0 -> 2\n      Port 2: 00:02:C9:B5:BA:B0\n      Configuring Port 3 (socket 0)\n      PMD: librte_pmd_mlx4: 0x867e20: TX queues number update: 0 -> 2\n      PMD: librte_pmd_mlx4: 0x867e20: RX queues number update: 0 -> 2\n      Port 3: 00:02:C9:B5:BA:B1\n      Checking link statuses...\n      Port 0 Link Up - speed 10000 Mbps - full-duplex\n      Port 1 Link Up - speed 40000 Mbps - full-duplex\n      Port 2 Link Up - speed 10000 Mbps - full-duplex\n      Port 3 Link Up - speed 40000 Mbps - full-duplex\n      Done\n      testpmd>\n",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/nics/mlx5.rst": "..  SPDX-License-Identifier: BSD-3-Clause\n    Copyright 2015 6WIND S.A.\n    Copyright 2015 Mellanox Technologies, Ltd\n\n.. include:: <isonum.txt>\n\nMLX5 poll mode driver\n=====================\n\nThe MLX5 poll mode driver library (**librte_pmd_mlx5**) provides support\nfor **Mellanox ConnectX-4**, **Mellanox ConnectX-4 Lx** , **Mellanox\nConnectX-5**, **Mellanox ConnectX-6**, **Mellanox ConnectX-6 Dx** and\n**Mellanox BlueField** families of 10/25/40/50/100/200 Gb/s adapters\nas well as their virtual functions (VF) in SR-IOV context.\n\nInformation and documentation about these adapters can be found on the\n`Mellanox website <http://www.mellanox.com>`__. Help is also provided by the\n`Mellanox community <http://community.mellanox.com/welcome>`__.\n\nThere is also a `section dedicated to this poll mode driver\n<http://www.mellanox.com/page/products_dyn?product_family=209&mtag=pmd_for_dpdk>`__.\n\n.. note::\n\n   Due to external dependencies, this driver is disabled in default configuration\n   of the \"make\" build. It can be enabled with ``CONFIG_RTE_LIBRTE_MLX5_PMD=y``\n   or by using \"meson\" build system which will detect dependencies.\n\nDesign\n------\n\nBesides its dependency on libibverbs (that implies libmlx5 and associated\nkernel support), librte_pmd_mlx5 relies heavily on system calls for control\noperations such as querying/updating the MTU and flow control parameters.\n\nFor security reasons and robustness, this driver only deals with virtual\nmemory addresses. The way resources allocations are handled by the kernel,\ncombined with hardware specifications that allow to handle virtual memory\naddresses directly, ensure that DPDK applications cannot access random\nphysical memory (or memory that does not belong to the current process).\n\nThis capability allows the PMD to coexist with kernel network interfaces\nwhich remain functional, although they stop receiving unicast packets as\nlong as they share the same MAC address.\nThis means legacy linux control tools (for example: ethtool, ifconfig and\nmore) can operate on the same network interfaces that owned by the DPDK\napplication.\n\nThe PMD can use libibverbs and libmlx5 to access the device firmware\nor directly the hardware components.\nThere are different levels of objects and bypassing abilities\nto get the best performances:\n\n- Verbs is a complete high-level generic API\n- Direct Verbs is a device-specific API\n- DevX allows to access firmware objects\n- Direct Rules manages flow steering at low-level hardware layer\n\nEnabling librte_pmd_mlx5 causes DPDK applications to be linked against\nlibibverbs.\n\nFeatures\n--------\n\n- Multi arch support: x86_64, POWER8, ARMv8, i686.\n- Multiple TX and RX queues.\n- Support for scattered TX and RX frames.\n- IPv4, IPv6, TCPv4, TCPv6, UDPv4 and UDPv6 RSS on any number of queues.\n- RSS using different combinations of fields: L3 only, L4 only or both,\n  and source only, destination only or both.\n- Several RSS hash keys, one for each flow type.\n- Default RSS operation with no hash key specification.\n- Configurable RETA table.\n- Link flow control (pause frame).\n- Support for multiple MAC addresses.\n- VLAN filtering.\n- RX VLAN stripping.\n- TX VLAN insertion.\n- RX CRC stripping configuration.\n- Promiscuous mode on PF and VF.\n- Multicast promiscuous mode on PF and VF.\n- Hardware checksum offloads.\n- Flow director (RTE_FDIR_MODE_PERFECT, RTE_FDIR_MODE_PERFECT_MAC_VLAN and\n  RTE_ETH_FDIR_REJECT).\n- Flow API, including :ref:`flow_isolated_mode`.\n- Multiple process.\n- KVM and VMware ESX SR-IOV modes are supported.\n- RSS hash result is supported.\n- Hardware TSO for generic IP or UDP tunnel, including VXLAN and GRE.\n- Hardware checksum Tx offload for generic IP or UDP tunnel, including VXLAN and GRE.\n- RX interrupts.\n- Statistics query including Basic, Extended and per queue.\n- Rx HW timestamp.\n- Tunnel types: VXLAN, L3 VXLAN, VXLAN-GPE, GRE, MPLSoGRE, MPLSoUDP, IP-in-IP, Geneve, GTP.\n- Tunnel HW offloads: packet type, inner/outer RSS, IP and UDP checksum verification.\n- NIC HW offloads: encapsulation (vxlan, gre, mplsoudp, mplsogre), NAT, routing, TTL\n  increment/decrement, count, drop, mark. For details please see :ref:`mlx5_offloads_support`.\n- Flow insertion rate of more then million flows per second, when using Direct Rules.\n- Support for multiple rte_flow groups.\n- Per packet no-inline hint flag to disable packet data copying into Tx descriptors.\n- Hardware LRO.\n\nLimitations\n-----------\n\n- For secondary process:\n\n  - Forked secondary process not supported.\n  - External memory unregistered in EAL memseg list cannot be used for DMA\n    unless such memory has been registered by ``mlx5_mr_update_ext_mp()`` in\n    primary process and remapped to the same virtual address in secondary\n    process. If the external memory is registered by primary process but has\n    different virtual address in secondary process, unexpected error may happen.\n\n- When using Verbs flow engine (``dv_flow_en`` = 0), flow pattern without any\n  specific VLAN will match for VLAN packets as well:\n\n  When VLAN spec is not specified in the pattern, the matching rule will be created with VLAN as a wild card.\n  Meaning, the flow rule::\n\n        flow create 0 ingress pattern eth / vlan vid is 3 / ipv4 / end ...\n\n  Will only match vlan packets with vid=3. and the flow rule::\n\n        flow create 0 ingress pattern eth / ipv4 / end ...\n\n  Will match any ipv4 packet (VLAN included).\n\n- VLAN pop offload command:\n\n  - Flow rules having a VLAN pop offload command as one of their actions and\n    are lacking a match on VLAN as one of their items are not supported.\n  - The command is not supported on egress traffic.\n\n- VLAN push offload is not supported on ingress traffic.\n\n- VLAN set PCP offload is not supported on existing headers.\n\n- A multi segment packet must have not more segments than reported by dev_infos_get()\n  in tx_desc_lim.nb_seg_max field. This value depends on maximal supported Tx descriptor\n  size and ``txq_inline_min`` settings and may be from 2 (worst case forced by maximal\n  inline settings) to 58.\n\n- Flows with a VXLAN Network Identifier equal (or ends to be equal)\n  to 0 are not supported.\n\n- VXLAN TSO and checksum offloads are not supported on VM.\n\n- L3 VXLAN and VXLAN-GPE tunnels cannot be supported together with MPLSoGRE and MPLSoUDP.\n\n- Match on Geneve header supports the following fields only:\n\n     - VNI\n     - OAM\n     - protocol type\n     - options length\n       Currently, the only supported options length value is 0.\n\n- VF: flow rules created on VF devices can only match traffic targeted at the\n  configured MAC addresses (see ``rte_eth_dev_mac_addr_add()``).\n\n- Match on GTP tunnel header item supports the following fields only:\n\n     - msg_type\n     - teid\n\n- No Tx metadata go to the E-Switch steering domain for the Flow group 0.\n  The flows within group 0 and set metadata action are rejected by hardware.\n\n.. note::\n\n   MAC addresses not already present in the bridge table of the associated\n   kernel network device will be added and cleaned up by the PMD when closing\n   the device. In case of ungraceful program termination, some entries may\n   remain present and should be removed manually by other means.\n\n- When Multi-Packet Rx queue is configured (``mprq_en``), a Rx packet can be\n  externally attached to a user-provided mbuf with having EXT_ATTACHED_MBUF in\n  ol_flags. As the mempool for the external buffer is managed by PMD, all the\n  Rx mbufs must be freed before the device is closed. Otherwise, the mempool of\n  the external buffers will be freed by PMD and the application which still\n  holds the external buffers may be corrupted.\n\n- If Multi-Packet Rx queue is configured (``mprq_en``) and Rx CQE compression is\n  enabled (``rxq_cqe_comp_en``) at the same time, RSS hash result is not fully\n  supported. Some Rx packets may not have PKT_RX_RSS_HASH.\n\n- IPv6 Multicast messages are not supported on VM, while promiscuous mode\n  and allmulticast mode are both set to off.\n  To receive IPv6 Multicast messages on VM, explicitly set the relevant\n  MAC address using rte_eth_dev_mac_addr_add() API.\n\n- To support a mixed traffic pattern (some buffers from local host memory, some\n  buffers from other devices) with high bandwidth, a mbuf flag is used.\n\n  An application hints the PMD whether or not it should try to inline the\n  given mbuf data buffer. PMD should do the best effort to act upon this request.\n\n  The hint flag ``RTE_PMD_MLX5_FINE_GRANULARITY_INLINE`` is dynamic,\n  registered by application with rte_mbuf_dynflag_register(). This flag is\n  purely driver-specific and declared in PMD specific header ``rte_pmd_mlx5.h``,\n  which is intended to be used by the application.\n\n  To query the supported specific flags in runtime,\n  the function ``rte_pmd_mlx5_get_dyn_flag_names`` returns the array of\n  currently (over present hardware and configuration) supported specific flags.\n  The \"not inline hint\" feature operating flow is the following one:\n\n    - application starts\n    - probe the devices, ports are created\n    - query the port capabilities\n    - if port supporting the feature is found\n    - register dynamic flag ``RTE_PMD_MLX5_FINE_GRANULARITY_INLINE``\n    - application starts the ports\n    - on ``dev_start()`` PMD checks whether the feature flag is registered and\n      enables the feature support in datapath\n    - application might set the registered flag bit in ``ol_flags`` field\n      of mbuf being sent and PMD will handle ones appropriately.\n\n- The amount of descriptors in Tx queue may be limited by data inline settings.\n  Inline data require the more descriptor building blocks and overall block\n  amount may exceed the hardware supported limits. The application should\n  reduce the requested Tx size or adjust data inline settings with\n  ``txq_inline_max`` and ``txq_inline_mpw`` devargs keys.\n\n- E-Switch decapsulation Flow:\n\n  - can be applied to PF port only.\n  - must specify VF port action (packet redirection from PF to VF).\n  - optionally may specify tunnel inner source and destination MAC addresses.\n\n- E-Switch  encapsulation Flow:\n\n  - can be applied to VF ports only.\n  - must specify PF port action (packet redirection from VF to PF).\n\n- Raw encapsulation:\n\n  - The input buffer, used as outer header, is not validated.\n\n- Raw decapsulation:\n\n  - The decapsulation is always done up to the outermost tunnel detected by the HW.\n  - The input buffer, providing the removal size, is not validated.\n  - The buffer size must match the length of the headers to be removed.\n\n- ICMP/ICMP6 code/type matching, IP-in-IP and MPLS flow matching are all\n  mutually exclusive features which cannot be supported together\n  (see :ref:`mlx5_firmware_config`).\n\n- LRO:\n\n  - Requires DevX and DV flow to be enabled.\n  - KEEP_CRC offload cannot be supported with LRO.\n  - The first mbuf length, without head-room,  must be big enough to include the\n    TCP header (122B).\n  - Rx queue with LRO offload enabled, receiving a non-LRO packet, can forward\n    it with size limited to max LRO size, not to max RX packet length.\n\nStatistics\n----------\n\nMLX5 supports various methods to report statistics:\n\nPort statistics can be queried using ``rte_eth_stats_get()``. The received and sent statistics are through SW only and counts the number of packets received or sent successfully by the PMD. The imissed counter is the amount of packets that could not be delivered to SW because a queue was full. Packets not received due to congestion in the bus or on the NIC can be queried via the rx_discards_phy xstats counter.\n\nExtended statistics can be queried using ``rte_eth_xstats_get()``. The extended statistics expose a wider set of counters counted by the device. The extended port statistics counts the number of packets received or sent successfully by the port. As Mellanox NICs are using the :ref:`Bifurcated Linux Driver <linux_gsg_linux_drivers>` those counters counts also packet received or sent by the Linux kernel. The counters with ``_phy`` suffix counts the total events on the physical port, therefore not valid for VF.\n\nFinally per-flow statistics can by queried using ``rte_flow_query`` when attaching a count action for specific flow. The flow counter counts the number of packets received successfully by the port and match the specific flow.\n\nConfiguration\n-------------\n\nCompilation options\n~~~~~~~~~~~~~~~~~~~\n\nThese options can be modified in the ``.config`` file.\n\n- ``CONFIG_RTE_LIBRTE_MLX5_PMD`` (default **n**)\n\n  Toggle compilation of librte_pmd_mlx5 itself.\n\n- ``CONFIG_RTE_IBVERBS_LINK_DLOPEN`` (default **n**)\n\n  Build PMD with additional code to make it loadable without hard\n  dependencies on **libibverbs** nor **libmlx5**, which may not be installed\n  on the target system.\n\n  In this mode, their presence is still required for it to run properly,\n  however their absence won't prevent a DPDK application from starting (with\n  ``CONFIG_RTE_BUILD_SHARED_LIB`` disabled) and they won't show up as\n  missing with ``ldd(1)``.\n\n  It works by moving these dependencies to a purpose-built rdma-core \"glue\"\n  plug-in which must either be installed in a directory whose name is based\n  on ``CONFIG_RTE_EAL_PMD_PATH`` suffixed with ``-glue`` if set, or in a\n  standard location for the dynamic linker (e.g. ``/lib``) if left to the\n  default empty string (``\"\"``).\n\n  This option has no performance impact.\n\n- ``CONFIG_RTE_IBVERBS_LINK_STATIC`` (default **n**)\n\n  Embed static flavor of the dependencies **libibverbs** and **libmlx5**\n  in the PMD shared library or the executable static binary.\n\n- ``CONFIG_RTE_LIBRTE_MLX5_DEBUG`` (default **n**)\n\n  Toggle debugging code and stricter compilation flags. Enabling this option\n  adds additional run-time checks and debugging messages at the cost of\n  lower performance.\n\n.. note::\n\n   For BlueField, target should be set to ``arm64-bluefield-linux-gcc``. This\n   will enable ``CONFIG_RTE_LIBRTE_MLX5_PMD`` and set ``RTE_CACHE_LINE_SIZE`` to\n   64. Default armv8a configuration of make build and meson build set it to 128\n   then brings performance degradation.\n\nThis option is available in meson:\n\n- ``ibverbs_link`` can be ``static``, ``shared``, or ``dlopen``.\n\nEnvironment variables\n~~~~~~~~~~~~~~~~~~~~~\n\n- ``MLX5_GLUE_PATH``\n\n  A list of directories in which to search for the rdma-core \"glue\" plug-in,\n  separated by colons or semi-colons.\n\n  Only matters when compiled with ``CONFIG_RTE_IBVERBS_LINK_DLOPEN``\n  enabled and most useful when ``CONFIG_RTE_EAL_PMD_PATH`` is also set,\n  since ``LD_LIBRARY_PATH`` has no effect in this case.\n\n- ``MLX5_SHUT_UP_BF``\n\n  Configures HW Tx doorbell register as IO-mapped.\n\n  By default, the HW Tx doorbell is configured as a write-combining register.\n  The register would be flushed to HW usually when the write-combining buffer\n  becomes full, but it depends on CPU design.\n\n  Except for vectorized Tx burst routines, a write memory barrier is enforced\n  after updating the register so that the update can be immediately visible to\n  HW.\n\n  When vectorized Tx burst is called, the barrier is set only if the burst size\n  is not aligned to MLX5_VPMD_TX_MAX_BURST. However, setting this environmental\n  variable will bring better latency even though the maximum throughput can\n  slightly decline.\n\nRun-time configuration\n~~~~~~~~~~~~~~~~~~~~~~\n\n- librte_pmd_mlx5 brings kernel network interfaces up during initialization\n  because it is affected by their state. Forcing them down prevents packets\n  reception.\n\n- **ethtool** operations on related kernel interfaces also affect the PMD.\n\n- ``rxq_cqe_comp_en`` parameter [int]\n\n  A nonzero value enables the compression of CQE on RX side. This feature\n  allows to save PCI bandwidth and improve performance. Enabled by default.\n\n  Supported on:\n\n  - x86_64 with ConnectX-4, ConnectX-4 Lx, ConnectX-5, ConnectX-6, ConnectX-6 Dx\n    and BlueField.\n  - POWER9 and ARMv8 with ConnectX-4 Lx, ConnectX-5, ConnectX-6, ConnectX-6 Dx\n    and BlueField.\n\n- ``rxq_cqe_pad_en`` parameter [int]\n\n  A nonzero value enables 128B padding of CQE on RX side. The size of CQE\n  is aligned with the size of a cacheline of the core. If cacheline size is\n  128B, the CQE size is configured to be 128B even though the device writes\n  only 64B data on the cacheline. This is to avoid unnecessary cache\n  invalidation by device's two consecutive writes on to one cacheline.\n  However in some architecture, it is more beneficial to update entire\n  cacheline with padding the rest 64B rather than striding because\n  read-modify-write could drop performance a lot. On the other hand,\n  writing extra data will consume more PCIe bandwidth and could also drop\n  the maximum throughput. It is recommended to empirically set this\n  parameter. Disabled by default.\n\n  Supported on:\n\n  - CPU having 128B cacheline with ConnectX-5 and BlueField.\n\n- ``rxq_pkt_pad_en`` parameter [int]\n\n  A nonzero value enables padding Rx packet to the size of cacheline on PCI\n  transaction. This feature would waste PCI bandwidth but could improve\n  performance by avoiding partial cacheline write which may cause costly\n  read-modify-copy in memory transaction on some architectures. Disabled by\n  default.\n\n  Supported on:\n\n  - x86_64 with ConnectX-4, ConnectX-4 Lx, ConnectX-5, ConnectX-6, ConnectX-6 Dx\n    and BlueField.\n  - POWER8 and ARMv8 with ConnectX-4 Lx, ConnectX-5, ConnectX-6, ConnectX-6 Dx\n    and BlueField.\n\n- ``mprq_en`` parameter [int]\n\n  A nonzero value enables configuring Multi-Packet Rx queues. Rx queue is\n  configured as Multi-Packet RQ if the total number of Rx queues is\n  ``rxqs_min_mprq`` or more and Rx scatter isn't configured. Disabled by\n  default.\n\n  Multi-Packet Rx Queue (MPRQ a.k.a Striding RQ) can further save PCIe bandwidth\n  by posting a single large buffer for multiple packets. Instead of posting a\n  buffers per a packet, one large buffer is posted in order to receive multiple\n  packets on the buffer. A MPRQ buffer consists of multiple fixed-size strides\n  and each stride receives one packet. MPRQ can improve throughput for\n  small-packet traffic.\n\n  When MPRQ is enabled, max_rx_pkt_len can be larger than the size of\n  user-provided mbuf even if DEV_RX_OFFLOAD_SCATTER isn't enabled. PMD will\n  configure large stride size enough to accommodate max_rx_pkt_len as long as\n  device allows. Note that this can waste system memory compared to enabling Rx\n  scatter and multi-segment packet.\n\n- ``mprq_log_stride_num`` parameter [int]\n\n  Log 2 of the number of strides for Multi-Packet Rx queue. Configuring more\n  strides can reduce PCIe traffic further. If configured value is not in the\n  range of device capability, the default value will be set with a warning\n  message. The default value is 4 which is 16 strides per a buffer, valid only\n  if ``mprq_en`` is set.\n\n  The size of Rx queue should be bigger than the number of strides.\n\n- ``mprq_max_memcpy_len`` parameter [int]\n\n  The maximum length of packet to memcpy in case of Multi-Packet Rx queue. Rx\n  packet is mem-copied to a user-provided mbuf if the size of Rx packet is less\n  than or equal to this parameter. Otherwise, PMD will attach the Rx packet to\n  the mbuf by external buffer attachment - ``rte_pktmbuf_attach_extbuf()``.\n  A mempool for external buffers will be allocated and managed by PMD. If Rx\n  packet is externally attached, ol_flags field of the mbuf will have\n  EXT_ATTACHED_MBUF and this flag must be preserved. ``RTE_MBUF_HAS_EXTBUF()``\n  checks the flag. The default value is 128, valid only if ``mprq_en`` is set.\n\n- ``rxqs_min_mprq`` parameter [int]\n\n  Configure Rx queues as Multi-Packet RQ if the total number of Rx queues is\n  greater or equal to this value. The default value is 12, valid only if\n  ``mprq_en`` is set.\n\n- ``txq_inline`` parameter [int]\n\n  Amount of data to be inlined during TX operations. This parameter is\n  deprecated and converted to the new parameter ``txq_inline_max`` providing\n  partial compatibility.\n\n- ``txqs_min_inline`` parameter [int]\n\n  Enable inline data send only when the number of TX queues is greater or equal\n  to this value.\n\n  This option should be used in combination with ``txq_inline_max`` and\n  ``txq_inline_mpw`` below and does not affect ``txq_inline_min`` settings above.\n\n  If this option is not specified the default value 16 is used for BlueField\n  and 8 for other platforms\n\n  The data inlining consumes the CPU cycles, so this option is intended to\n  auto enable inline data if we have enough Tx queues, which means we have\n  enough CPU cores and PCI bandwidth is getting more critical and CPU\n  is not supposed to be bottleneck anymore.\n\n  The copying data into WQE improves latency and can improve PPS performance\n  when PCI back pressure is detected and may be useful for scenarios involving\n  heavy traffic on many queues.\n\n  Because additional software logic is necessary to handle this mode, this\n  option should be used with care, as it may lower performance when back\n  pressure is not expected.\n\n  If inline data are enabled it may affect the maximal size of Tx queue in\n  descriptors because the inline data increase the descriptor size and\n  queue size limits supported by hardware may be exceeded.\n\n- ``txq_inline_min`` parameter [int]\n\n  Minimal amount of data to be inlined into WQE during Tx operations. NICs\n  may require this minimal data amount to operate correctly. The exact value\n  may depend on NIC operation mode, requested offloads, etc. It is strongly\n  recommended to omit this parameter and use the default values. Anyway,\n  applications using this parameter should take into consideration that\n  specifying an inconsistent value may prevent the NIC from sending packets.\n\n  If ``txq_inline_min`` key is present the specified value (may be aligned\n  by the driver in order not to exceed the limits and provide better descriptor\n  space utilization) will be used by the driver and it is guaranteed that\n  requested amount of data bytes are inlined into the WQE beside other inline\n  settings. This key also may update ``txq_inline_max`` value (default\n  or specified explicitly in devargs) to reserve the space for inline data.\n\n  If ``txq_inline_min`` key is not present, the value may be queried by the\n  driver from the NIC via DevX if this feature is available. If there is no DevX\n  enabled/supported the value 18 (supposing L2 header including VLAN) is set\n  for ConnectX-4 and ConnectX-4 Lx, and 0 is set by default for ConnectX-5\n  and newer NICs. If packet is shorter the ``txq_inline_min`` value, the entire\n  packet is inlined.\n\n  For ConnectX-4 NIC, driver does not allow specifying value below 18\n  (minimal L2 header, including VLAN), error will be raised.\n\n  For ConnectX-4 Lx NIC, it is allowed to specify values below 18, but\n  it is not recommended and may prevent NIC from sending packets over\n  some configurations.\n\n  Please, note, this minimal data inlining disengages eMPW feature (Enhanced\n  Multi-Packet Write), because last one does not support partial packet inlining.\n  This is not very critical due to minimal data inlining is mostly required\n  by ConnectX-4 and ConnectX-4 Lx, these NICs do not support eMPW feature.\n\n- ``txq_inline_max`` parameter [int]\n\n  Specifies the maximal packet length to be completely inlined into WQE\n  Ethernet Segment for ordinary SEND method. If packet is larger than specified\n  value, the packet data won't be copied by the driver at all, data buffer\n  is addressed with a pointer. If packet length is less or equal all packet\n  data will be copied into WQE. This may improve PCI bandwidth utilization for\n  short packets significantly but requires the extra CPU cycles.\n\n  The data inline feature is controlled by number of Tx queues, if number of Tx\n  queues is larger than ``txqs_min_inline`` key parameter, the inline feature\n  is engaged, if there are not enough Tx queues (which means not enough CPU cores\n  and CPU resources are scarce), data inline is not performed by the driver.\n  Assigning ``txqs_min_inline`` with zero always enables the data inline.\n\n  The default ``txq_inline_max`` value is 290. The specified value may be adjusted\n  by the driver in order not to exceed the limit (930 bytes) and to provide better\n  WQE space filling without gaps, the adjustment is reflected in the debug log.\n  Also, the default value (290) may be decreased in run-time if the large transmit\n  queue size is requested and hardware does not support enough descriptor\n  amount, in this case warning is emitted. If ``txq_inline_max`` key is\n  specified and requested inline settings can not be satisfied then error\n  will be raised.\n\n- ``txq_inline_mpw`` parameter [int]\n\n  Specifies the maximal packet length to be completely inlined into WQE for\n  Enhanced MPW method. If packet is large the specified value, the packet data\n  won't be copied, and data buffer is addressed with pointer. If packet length\n  is less or equal, all packet data will be copied into WQE. This may improve PCI\n  bandwidth utilization for short packets significantly but requires the extra\n  CPU cycles.\n\n  The data inline feature is controlled by number of TX queues, if number of Tx\n  queues is larger than ``txqs_min_inline`` key parameter, the inline feature\n  is engaged, if there are not enough Tx queues (which means not enough CPU cores\n  and CPU resources are scarce), data inline is not performed by the driver.\n  Assigning ``txqs_min_inline`` with zero always enables the data inline.\n\n  The default ``txq_inline_mpw`` value is 268. The specified value may be adjusted\n  by the driver in order not to exceed the limit (930 bytes) and to provide better\n  WQE space filling without gaps, the adjustment is reflected in the debug log.\n  Due to multiple packets may be included to the same WQE with Enhanced Multi\n  Packet Write Method and overall WQE size is limited it is not recommended to\n  specify large values for the ``txq_inline_mpw``. Also, the default value (268)\n  may be decreased in run-time if the large transmit queue size is requested\n  and hardware does not support enough descriptor amount, in this case warning\n  is emitted. If ``txq_inline_mpw`` key is  specified and requested inline\n  settings can not be satisfied then error will be raised.\n\n- ``txqs_max_vec`` parameter [int]\n\n  Enable vectorized Tx only when the number of TX queues is less than or\n  equal to this value. This parameter is deprecated and ignored, kept\n  for compatibility issue to not prevent driver from probing.\n\n- ``txq_mpw_hdr_dseg_en`` parameter [int]\n\n  A nonzero value enables including two pointers in the first block of TX\n  descriptor. The parameter is deprecated and ignored, kept for compatibility\n  issue.\n\n- ``txq_max_inline_len`` parameter [int]\n\n  Maximum size of packet to be inlined. This limits the size of packet to\n  be inlined. If the size of a packet is larger than configured value, the\n  packet isn't inlined even though there's enough space remained in the\n  descriptor. Instead, the packet is included with pointer. This parameter\n  is deprecated and converted directly to ``txq_inline_mpw`` providing full\n  compatibility. Valid only if eMPW feature is engaged.\n\n- ``txq_mpw_en`` parameter [int]\n\n  A nonzero value enables Enhanced Multi-Packet Write (eMPW) for ConnectX-5,\n  ConnectX-6, ConnectX-6 Dx and BlueField. eMPW allows the TX burst function to pack\n  up multiple packets in a single descriptor session in order to save PCI bandwidth\n  and improve performance at the cost of a slightly higher CPU usage. When\n  ``txq_inline_mpw`` is set along with ``txq_mpw_en``, TX burst function copies\n  entire packet data on to TX descriptor instead of including pointer of packet.\n\n  The Enhanced Multi-Packet Write feature is enabled by default if NIC supports\n  it, can be disabled by explicit specifying 0 value for ``txq_mpw_en`` option.\n  Also, if minimal data inlining is requested by non-zero ``txq_inline_min``\n  option or reported by the NIC, the eMPW feature is disengaged.\n\n- ``tx_db_nc`` parameter [int]\n\n  The rdma core library can map doorbell register in two ways, depending on the\n  environment variable \"MLX5_SHUT_UP_BF\":\n\n  - As regular cached memory (usually with write combining attribute), if the\n    variable is either missing or set to zero.\n  - As non-cached memory, if the variable is present and set to not \"0\" value.\n\n  The type of mapping may slightly affect the Tx performance, the optimal choice\n  is strongly relied on the host architecture and should be deduced practically.\n\n  If ``tx_db_nc`` is set to zero, the doorbell is forced to be mapped to regular\n  memory (with write combining), the PMD will perform the extra write memory barrier\n  after writing to doorbell, it might increase the needed CPU clocks per packet\n  to send, but latency might be improved.\n\n  If ``tx_db_nc`` is set to one, the doorbell is forced to be mapped to non\n  cached memory, the PMD will not perform the extra write memory barrier\n  after writing to doorbell, on some architectures it might improve the\n  performance.\n\n  If ``tx_db_nc`` is set to two, the doorbell is forced to be mapped to regular\n  memory, the PMD will use heuristics to decide whether write memory barrier\n  should be performed. For bursts with size multiple of recommended one (64 pkts)\n  it is supposed the next burst is coming and no need to issue the extra memory\n  barrier (it is supposed to be issued in the next coming burst, at least after\n  descriptor writing). It might increase latency (on some hosts till next\n  packets transmit) and should be used with care.\n\n  If ``tx_db_nc`` is omitted or set to zero, the preset (if any) environment\n  variable \"MLX5_SHUT_UP_BF\" value is used. If there is no \"MLX5_SHUT_UP_BF\",\n  the default ``tx_db_nc`` value is zero for ARM64 hosts and one for others.\n\n- ``tx_vec_en`` parameter [int]\n\n  A nonzero value enables Tx vector on ConnectX-5, ConnectX-6, ConnectX-6 Dx\n  and BlueField NICs if the number of global Tx queues on the port is less than\n  ``txqs_max_vec``. The parameter is deprecated and ignored.\n\n- ``rx_vec_en`` parameter [int]\n\n  A nonzero value enables Rx vector if the port is not configured in\n  multi-segment otherwise this parameter is ignored.\n\n  Enabled by default.\n\n- ``vf_nl_en`` parameter [int]\n\n  A nonzero value enables Netlink requests from the VF to add/remove MAC\n  addresses or/and enable/disable promiscuous/all multicast on the Netdevice.\n  Otherwise the relevant configuration must be run with Linux iproute2 tools.\n  This is a prerequisite to receive this kind of traffic.\n\n  Enabled by default, valid only on VF devices ignored otherwise.\n\n- ``l3_vxlan_en`` parameter [int]\n\n  A nonzero value allows L3 VXLAN and VXLAN-GPE flow creation. To enable\n  L3 VXLAN or VXLAN-GPE, users has to configure firmware and enable this\n  parameter. This is a prerequisite to receive this kind of traffic.\n\n  Disabled by default.\n\n- ``dv_xmeta_en`` parameter [int]\n\n  A nonzero value enables extensive flow metadata support if device is\n  capable and driver supports it. This can enable extensive support of\n  ``MARK`` and ``META`` item of ``rte_flow``. The newly introduced\n  ``SET_TAG`` and ``SET_META`` actions do not depend on ``dv_xmeta_en``.\n\n  There are some possible configurations, depending on parameter value:\n\n  - 0, this is default value, defines the legacy mode, the ``MARK`` and\n    ``META`` related actions and items operate only within NIC Tx and\n    NIC Rx steering domains, no ``MARK`` and ``META`` information crosses\n    the domain boundaries. The ``MARK`` item is 24 bits wide, the ``META``\n    item is 32 bits wide and match supported on egress only.\n\n  - 1, this engages extensive metadata mode, the ``MARK`` and ``META``\n    related actions and items operate within all supported steering domains,\n    including FDB, ``MARK`` and ``META`` information may cross the domain\n    boundaries. The ``MARK`` item is 24 bits wide, the ``META`` item width\n    depends on kernel and firmware configurations and might be 0, 16 or\n    32 bits. Within NIC Tx domain ``META`` data width is 32 bits for\n    compatibility, the actual width of data transferred to the FDB domain\n    depends on kernel configuration and may be vary. The actual supported\n    width can be retrieved in runtime by series of rte_flow_validate()\n    trials.\n\n  - 2, this engages extensive metadata mode, the ``MARK`` and ``META``\n    related actions and items operate within all supported steering domains,\n    including FDB, ``MARK`` and ``META`` information may cross the domain\n    boundaries. The ``META`` item is 32 bits wide, the ``MARK`` item width\n    depends on kernel and firmware configurations and might be 0, 16 or\n    24 bits. The actual supported width can be retrieved in runtime by\n    series of rte_flow_validate() trials.\n\n  +------+-----------+-----------+-------------+-------------+\n  | Mode | ``MARK``  | ``META``  | ``META`` Tx | FDB/Through |\n  +======+===========+===========+=============+=============+\n  | 0    | 24 bits   | 32 bits   | 32 bits     | no          |\n  +------+-----------+-----------+-------------+-------------+\n  | 1    | 24 bits   | vary 0-32 | 32 bits     | yes         |\n  +------+-----------+-----------+-------------+-------------+\n  | 2    | vary 0-32 | 32 bits   | 32 bits     | yes         |\n  +------+-----------+-----------+-------------+-------------+\n\n  If there is no E-Switch configuration the ``dv_xmeta_en`` parameter is\n  ignored and the device is configured to operate in legacy mode (0).\n\n  Disabled by default (set to 0).\n\n  The Direct Verbs/Rules (engaged with ``dv_flow_en`` = 1) supports all\n  of the extensive metadata features. The legacy Verbs supports FLAG and\n  MARK metadata actions over NIC Rx steering domain only.\n\n- ``dv_flow_en`` parameter [int]\n\n  A nonzero value enables the DV flow steering assuming it is supported\n  by the driver (RDMA Core library version is rdma-core-24.0 or higher).\n\n  Enabled by default if supported.\n\n- ``dv_esw_en`` parameter [int]\n\n  A nonzero value enables E-Switch using Direct Rules.\n\n  Enabled by default if supported.\n\n- ``mr_ext_memseg_en`` parameter [int]\n\n  A nonzero value enables extending memseg when registering DMA memory. If\n  enabled, the number of entries in MR (Memory Region) lookup table on datapath\n  is minimized and it benefits performance. On the other hand, it worsens memory\n  utilization because registered memory is pinned by kernel driver. Even if a\n  page in the extended chunk is freed, that doesn't become reusable until the\n  entire memory is freed.\n\n  Enabled by default.\n\n- ``representor`` parameter [list]\n\n  This parameter can be used to instantiate DPDK Ethernet devices from\n  existing port (or VF) representors configured on the device.\n\n  It is a standard parameter whose format is described in\n  :ref:`ethernet_device_standard_device_arguments`.\n\n  For instance, to probe port representors 0 through 2::\n\n    representor=[0-2]\n\n- ``max_dump_files_num`` parameter [int]\n\n  The maximum number of files per PMD entity that may be created for debug information.\n  The files will be created in /var/log directory or in current directory.\n\n  set to 128 by default.\n\n- ``lro_timeout_usec`` parameter [int]\n\n  The maximum allowed duration of an LRO session, in micro-seconds.\n  PMD will set the nearest value supported by HW, which is not bigger than\n  the input ``lro_timeout_usec`` value.\n  If this parameter is not specified, by default PMD will set\n  the smallest value supported by HW.\n\n.. _mlx5_firmware_config:\n\nFirmware configuration\n~~~~~~~~~~~~~~~~~~~~~~\n\nFirmware features can be configured as key/value pairs.\n\nThe command to set a value is::\n\n  mlxconfig -d <device> set <key>=<value>\n\nThe command to query a value is::\n\n  mlxconfig -d <device> query | grep <key>\n\nThe device name for the command ``mlxconfig`` can be either the PCI address,\nor the mst device name found with::\n\n  mst status\n\nBelow are some firmware configurations listed.\n\n- link type::\n\n    LINK_TYPE_P1\n    LINK_TYPE_P2\n    value: 1=Infiniband 2=Ethernet 3=VPI(auto-sense)\n\n- enable SR-IOV::\n\n    SRIOV_EN=1\n\n- maximum number of SR-IOV virtual functions::\n\n    NUM_OF_VFS=<max>\n\n- enable DevX (required by Direct Rules and other features)::\n\n    UCTX_EN=1\n\n- aggressive CQE zipping::\n\n    CQE_COMPRESSION=1\n\n- L3 VXLAN and VXLAN-GPE destination UDP port::\n\n    IP_OVER_VXLAN_EN=1\n    IP_OVER_VXLAN_PORT=<udp dport>\n\n- enable IP-in-IP tunnel flow matching::\n\n    FLEX_PARSER_PROFILE_ENABLE=0\n\n- enable MPLS flow matching::\n\n    FLEX_PARSER_PROFILE_ENABLE=1\n\n- enable ICMP/ICMP6 code/type fields matching::\n\n    FLEX_PARSER_PROFILE_ENABLE=2\n\n- enable Geneve flow matching::\n\n   FLEX_PARSER_PROFILE_ENABLE=0\n\n- enable GTP flow matching::\n\n   FLEX_PARSER_PROFILE_ENABLE=3\n\nPrerequisites\n-------------\n\nThis driver relies on external libraries and kernel drivers for resources\nallocations and initialization. The following dependencies are not part of\nDPDK and must be installed separately:\n\n- **libibverbs**\n\n  User space Verbs framework used by librte_pmd_mlx5. This library provides\n  a generic interface between the kernel and low-level user space drivers\n  such as libmlx5.\n\n  It allows slow and privileged operations (context initialization, hardware\n  resources allocations) to be managed by the kernel and fast operations to\n  never leave user space.\n\n- **libmlx5**\n\n  Low-level user space driver library for Mellanox\n  ConnectX-4/ConnectX-5/ConnectX-6/BlueField devices, it is automatically loaded\n  by libibverbs.\n\n  This library basically implements send/receive calls to the hardware\n  queues.\n\n- **Kernel modules**\n\n  They provide the kernel-side Verbs API and low level device drivers that\n  manage actual hardware initialization and resources sharing with user\n  space processes.\n\n  Unlike most other PMDs, these modules must remain loaded and bound to\n  their devices:\n\n  - mlx5_core: hardware driver managing Mellanox\n    ConnectX-4/ConnectX-5/ConnectX-6/BlueField devices and related Ethernet kernel\n    network devices.\n  - mlx5_ib: InifiniBand device driver.\n  - ib_uverbs: user space driver for Verbs (entry point for libibverbs).\n\n- **Firmware update**\n\n  Mellanox OFED/EN releases include firmware updates for\n  ConnectX-4/ConnectX-5/ConnectX-6/BlueField adapters.\n\n  Because each release provides new features, these updates must be applied to\n  match the kernel modules and libraries they come with.\n\n.. note::\n\n   Both libraries are BSD and GPL licensed. Linux kernel modules are GPL\n   licensed.\n\nInstallation\n~~~~~~~~~~~~\n\nEither RDMA Core library with a recent enough Linux kernel release\n(recommended) or Mellanox OFED/EN, which provides compatibility with older\nreleases.\n\nRDMA Core with Linux Kernel\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n- Minimal kernel version : v4.14 or the most recent 4.14-rc (see `Linux installation documentation`_)\n- Minimal rdma-core version: v15+ commit 0c5f5765213a (\"Merge pull request #227 from yishaih/tm\")\n  (see `RDMA Core installation documentation`_)\n- When building for i686 use:\n\n  - rdma-core version 18.0 or above built with 32bit support.\n  - Kernel version 4.14.41 or above.\n\n- Starting with rdma-core v21, static libraries can be built::\n\n    cd build\n    CFLAGS=-fPIC cmake -DIN_PLACE=1 -DENABLE_STATIC=1 -GNinja ..\n    ninja\n\n.. _`Linux installation documentation`: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/plain/Documentation/admin-guide/README.rst\n.. _`RDMA Core installation documentation`: https://raw.githubusercontent.com/linux-rdma/rdma-core/master/README.md\n\nIf rdma-core libraries are built but not installed, DPDK makefile can link them,\nthanks to these environment variables:\n\n   - ``EXTRA_CFLAGS=-I/path/to/rdma-core/build/include``\n   - ``EXTRA_LDFLAGS=-L/path/to/rdma-core/build/lib``\n   - ``PKG_CONFIG_PATH=/path/to/rdma-core/build/lib/pkgconfig``\n\nMellanox OFED/EN\n^^^^^^^^^^^^^^^^\n\n- Mellanox OFED version: ** 4.5, 4.6** /\n  Mellanox EN version: **4.5, 4.6**\n- firmware version:\n\n  - ConnectX-4: **12.21.1000** and above.\n  - ConnectX-4 Lx: **14.21.1000** and above.\n  - ConnectX-5: **16.21.1000** and above.\n  - ConnectX-5 Ex: **16.21.1000** and above.\n  - ConnectX-6: **20.99.5374** and above.\n  - ConnectX-6 Dx: **22.27.0090** and above.\n  - BlueField: **18.25.1010** and above.\n\nWhile these libraries and kernel modules are available on OpenFabrics\nAlliance's `website <https://www.openfabrics.org/>`__ and provided by package\nmanagers on most distributions, this PMD requires Ethernet extensions that\nmay not be supported at the moment (this is a work in progress).\n\n`Mellanox OFED\n<http://www.mellanox.com/page/products_dyn?product_family=26&mtag=linux>`__ and\n`Mellanox EN\n<http://www.mellanox.com/page/products_dyn?product_family=27&mtag=linux>`__\ninclude the necessary support and should be used in the meantime. For DPDK,\nonly libibverbs, libmlx5, mlnx-ofed-kernel packages and firmware updates are\nrequired from that distribution.\n\n.. note::\n\n   Several versions of Mellanox OFED/EN are available. Installing the version\n   this DPDK release was developed and tested against is strongly\n   recommended. Please check the `prerequisites`_.\n\nSupported NICs\n--------------\n\nThe following Mellanox device families are supported by the same mlx5 driver:\n\n  - ConnectX-4\n  - ConnectX-4 Lx\n  - ConnectX-5\n  - ConnectX-5 Ex\n  - ConnectX-6\n  - ConnectX-6 Dx\n  - BlueField\n\nBelow are detailed device names:\n\n* Mellanox\\ |reg| ConnectX\\ |reg|-4 10G MCX4111A-XCAT (1x10G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-4 10G MCX412A-XCAT (2x10G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-4 25G MCX4111A-ACAT (1x25G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-4 25G MCX412A-ACAT (2x25G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-4 40G MCX413A-BCAT (1x40G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-4 40G MCX4131A-BCAT (1x40G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-4 40G MCX415A-BCAT (1x40G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-4 50G MCX413A-GCAT (1x50G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-4 50G MCX4131A-GCAT (1x50G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-4 50G MCX414A-BCAT (2x50G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-4 50G MCX415A-GCAT (1x50G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-4 50G MCX416A-BCAT (2x50G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-4 50G MCX416A-GCAT (2x50G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-4 50G MCX415A-CCAT (1x100G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-4 100G MCX416A-CCAT (2x100G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-4 Lx 10G MCX4111A-XCAT (1x10G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-4 Lx 10G MCX4121A-XCAT (2x10G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-4 Lx 25G MCX4111A-ACAT (1x25G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-4 Lx 25G MCX4121A-ACAT (2x25G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-4 Lx 40G MCX4131A-BCAT (1x40G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-5 100G MCX556A-ECAT (2x100G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-5 Ex EN 100G MCX516A-CDAT (2x100G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-6 200G MCX654106A-HCAT (2x200G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-6 Dx EN 100G MCX623106AN-CDAT (2x100G)\n* Mellanox\\ |reg| ConnectX\\ |reg|-6 Dx EN 200G MCX623105AN-VDAT (1x200G)\n\nQuick Start Guide on OFED/EN\n----------------------------\n\n1. Download latest Mellanox OFED/EN. For more info check the  `prerequisites`_.\n\n\n2. Install the required libraries and kernel modules either by installing\n   only the required set, or by installing the entire Mellanox OFED/EN::\n\n        ./mlnxofedinstall --upstream-libs --dpdk\n\n3. Verify the firmware is the correct one::\n\n        ibv_devinfo\n\n4. Verify all ports links are set to Ethernet::\n\n        mlxconfig -d <mst device> query | grep LINK_TYPE\n        LINK_TYPE_P1                        ETH(2)\n        LINK_TYPE_P2                        ETH(2)\n\n   Link types may have to be configured to Ethernet::\n\n        mlxconfig -d <mst device> set LINK_TYPE_P1/2=1/2/3\n\n        * LINK_TYPE_P1=<1|2|3> , 1=Infiniband 2=Ethernet 3=VPI(auto-sense)\n\n   For hypervisors, verify SR-IOV is enabled on the NIC::\n\n        mlxconfig -d <mst device> query | grep SRIOV_EN\n        SRIOV_EN                            True(1)\n\n   If needed, configure SR-IOV::\n\n        mlxconfig -d <mst device> set SRIOV_EN=1 NUM_OF_VFS=16\n        mlxfwreset -d <mst device> reset\n\n5. Restart the driver::\n\n        /etc/init.d/openibd restart\n\n   or::\n\n        service openibd restart\n\n   If link type was changed, firmware must be reset as well::\n\n        mlxfwreset -d <mst device> reset\n\n   For hypervisors, after reset write the sysfs number of virtual functions\n   needed for the PF.\n\n   To dynamically instantiate a given number of virtual functions (VFs)::\n\n        echo [num_vfs] > /sys/class/infiniband/mlx5_0/device/sriov_numvfs\n\n6. Compile DPDK and you are ready to go. See instructions on\n   :ref:`Development Kit Build System <Development_Kit_Build_System>`\n\nEnable switchdev mode\n---------------------\n\nSwitchdev mode is a mode in E-Switch, that binds between representor and VF.\nRepresentor is a port in DPDK that is connected to a VF in such a way\nthat assuming there are no offload flows, each packet that is sent from the VF\nwill be received by the corresponding representor. While each packet that is\nsent to a representor will be received by the VF.\nThis is very useful in case of SRIOV mode, where the first packet that is sent\nby the VF will be received by the DPDK application which will decide if this\nflow should be offloaded to the E-Switch. After offloading the flow packet\nthat the VF that are matching the flow will not be received any more by\nthe DPDK application.\n\n1. Enable SRIOV mode::\n\n        mlxconfig -d <mst device> set SRIOV_EN=true\n\n2. Configure the max number of VFs::\n\n        mlxconfig -d <mst device> set NUM_OF_VFS=<num of vfs>\n\n3. Reset the FW::\n\n        mlxfwreset -d <mst device> reset\n\n3. Configure the actual number of VFs::\n\n        echo <num of vfs > /sys/class/net/<net device>/device/sriov_numvfs\n\n4. Unbind the device (can be rebind after the switchdev mode)::\n\n        echo -n \"<device pci address\" > /sys/bus/pci/drivers/mlx5_core/unbind\n\n5. Enbale switchdev mode::\n\n        echo switchdev > /sys/class/net/<net device>/compat/devlink/mode\n\nPerformance tuning\n------------------\n\n1. Configure aggressive CQE Zipping for maximum performance::\n\n        mlxconfig -d <mst device> s CQE_COMPRESSION=1\n\n  To set it back to the default CQE Zipping mode use::\n\n        mlxconfig -d <mst device> s CQE_COMPRESSION=0\n\n2. In case of virtualization:\n\n   - Make sure that hypervisor kernel is 3.16 or newer.\n   - Configure boot with ``iommu=pt``.\n   - Use 1G huge pages.\n   - Make sure to allocate a VM on huge pages.\n   - Make sure to set CPU pinning.\n\n3. Use the CPU near local NUMA node to which the PCIe adapter is connected,\n   for better performance. For VMs, verify that the right CPU\n   and NUMA node are pinned according to the above. Run::\n\n        lstopo-no-graphics\n\n   to identify the NUMA node to which the PCIe adapter is connected.\n\n4. If more than one adapter is used, and root complex capabilities allow\n   to put both adapters on the same NUMA node without PCI bandwidth degradation,\n   it is recommended to locate both adapters on the same NUMA node.\n   This in order to forward packets from one to the other without\n   NUMA performance penalty.\n\n5. Disable pause frames::\n\n        ethtool -A <netdev> rx off tx off\n\n6. Verify IO non-posted prefetch is disabled by default. This can be checked\n   via the BIOS configuration. Please contact you server provider for more\n   information about the settings.\n\n.. note::\n\n        On some machines, depends on the machine integrator, it is beneficial\n        to set the PCI max read request parameter to 1K. This can be\n        done in the following way:\n\n        To query the read request size use::\n\n                setpci -s <NIC PCI address> 68.w\n\n        If the output is different than 3XXX, set it by::\n\n                setpci -s <NIC PCI address> 68.w=3XXX\n\n        The XXX can be different on different systems. Make sure to configure\n        according to the setpci output.\n\n7. To minimize overhead of searching Memory Regions:\n\n   - '--socket-mem' is recommended to pin memory by predictable amount.\n   - Configure per-lcore cache when creating Mempools for packet buffer.\n   - Refrain from dynamically allocating/freeing memory in run-time.\n\n.. _mlx5_offloads_support:\n\nSupported hardware offloads\n---------------------------\n\n.. table:: Minimal SW/HW versions for queue offloads\n\n   ============== ===== ===== ========= ===== ========== ==========\n   Offload        DPDK  Linux rdma-core OFED   firmware   hardware\n   ============== ===== ===== ========= ===== ========== ==========\n   common base    17.11  4.14    16     4.2-1 12.21.1000 ConnectX-4\n   checksums      17.11  4.14    16     4.2-1 12.21.1000 ConnectX-4\n   Rx timestamp   17.11  4.14    16     4.2-1 12.21.1000 ConnectX-4\n   TSO            17.11  4.14    16     4.2-1 12.21.1000 ConnectX-4\n   LRO            19.08  N/A     N/A    4.6-4 16.25.6406 ConnectX-5\n   ============== ===== ===== ========= ===== ========== ==========\n\n.. table:: Minimal SW/HW versions for rte_flow offloads\n\n   +-----------------------+-----------------+-----------------+\n   | Offload               | with E-Switch   | with NIC        |\n   +=======================+=================+=================+\n   | Count                 | | DPDK 19.05    | | DPDK 19.02    |\n   |                       | | OFED 4.6      | | OFED 4.6      |\n   |                       | | rdma-core 24  | | rdma-core 23  |\n   |                       | | ConnectX-5    | | ConnectX-5    |\n   +-----------------------+-----------------+-----------------+\n   | Drop                  | | DPDK 19.05    | | DPDK 18.11    |\n   |                       | | OFED 4.6      | | OFED 4.5      |\n   |                       | | rdma-core 24  | | rdma-core 23  |\n   |                       | | ConnectX-5    | | ConnectX-4    |\n   +-----------------------+-----------------+-----------------+\n   | Queue / RSS           | |               | | DPDK 18.11    |\n   |                       | |     N/A       | | OFED 4.5      |\n   |                       | |               | | rdma-core 23  |\n   |                       | |               | | ConnectX-4    |\n   +-----------------------+-----------------+-----------------+\n   | Encapsulation         | | DPDK 19.05    | | DPDK 19.02    |\n   | (VXLAN / NVGRE / RAW) | | OFED 4.7-1    | | OFED 4.6      |\n   |                       | | rdma-core 24  | | rdma-core 23  |\n   |                       | | ConnectX-5    | | ConnectX-5    |\n   +-----------------------+-----------------+-----------------+\n   | Encapsulation         | | DPDK 19.11    | | DPDK 19.11    |\n   | GENEVE                | | OFED 4.7-3    | | OFED 4.7-3    |\n   |                       | | rdma-core 27  | | rdma-core 27  |\n   |                       | | ConnectX-5    | | ConnectX-5    |\n   +-----------------------+-----------------+-----------------+\n   | | Header rewrite      | | DPDK 19.05    | | DPDK 19.02    |\n   | | (set_ipv4_src /     | | OFED 4.7-1    | | OFED 4.7-1    |\n   | | set_ipv4_dst /      | | rdma-core 24  | | rdma-core 24  |\n   | | set_ipv6_src /      | | ConnectX-5    | | ConnectX-5    |\n   | | set_ipv6_dst /      | |               | |               |\n   | | set_tp_src /        | |               | |               |\n   | | set_tp_dst /        | |               | |               |\n   | | dec_ttl /           | |               | |               |\n   | | set_ttl /           | |               | |               |\n   | | set_mac_src /       | |               | |               |\n   | | set_mac_dst)        | |               | |               |\n   +-----------------------+-----------------+-----------------+\n   | | Header rewrite      | | DPDK 20.02    | | DPDK 20.02    |\n   | | (set_dscp)          | | OFED 5.0      | | OFED 5.0      |\n   | |                     | | rdma-core 24  | | rdma-core 24  |\n   | |                     | | ConnectX-5    | | ConnectX-5    |\n   +-----------------------+-----------------+-----------------+\n   | Jump                  | | DPDK 19.05    | | DPDK 19.02    |\n   |                       | | OFED 4.7-1    | | OFED 4.7-1    |\n   |                       | | rdma-core 24  | | N/A           |\n   |                       | | ConnectX-5    | | ConnectX-5    |\n   +-----------------------+-----------------+-----------------+\n   | Mark / Flag           | | DPDK 19.05    | | DPDK 18.11    |\n   |                       | | OFED 4.6      | | OFED 4.5      |\n   |                       | | rdma-core 24  | | rdma-core 23  |\n   |                       | | ConnectX-5    | | ConnectX-4    |\n   +-----------------------+-----------------+-----------------+\n   | Port ID               | | DPDK 19.05    |     | N/A       |\n   |                       | | OFED 4.7-1    |     | N/A       |\n   |                       | | rdma-core 24  |     | N/A       |\n   |                       | | ConnectX-5    |     | N/A       |\n   +-----------------------+-----------------+-----------------+\n   | | VLAN                | | DPDK 19.11    | | DPDK 19.11    |\n   | | (of_pop_vlan /      | | OFED 4.7-1    | | OFED 4.7-1    |\n   | | of_push_vlan /      | | ConnectX-5    | | ConnectX-5    |\n   | | of_set_vlan_pcp /   | |               | |               |\n   | | of_set_vlan_vid)    | |               | |               |\n   +-----------------------+-----------------+-----------------+\n   | Hairpin               | |               | | DPDK 19.11    |\n   |                       | |     N/A       | | OFED 4.7-3    |\n   |                       | |               | | rdma-core 26  |\n   |                       | |               | | ConnectX-5    |\n   +-----------------------+-----------------+-----------------+\n   | Meta data             | |  DPDK 19.11   | | DPDK 19.11    |\n   |                       | |  OFED 4.7-3   | | OFED 4.7-3    |\n   |                       | |  rdma-core 26 | | rdma-core 26  |\n   |                       | |  ConnectX-5   | | ConnectX-5    |\n   +-----------------------+-----------------+-----------------+\n   | Metering              | |  DPDK 19.11   | | DPDK 19.11    |\n   |                       | |  OFED 4.7-3   | | OFED 4.7-3    |\n   |                       | |  rdma-core 26 | | rdma-core 26  |\n   |                       | |  ConnectX-5   | | ConnectX-5    |\n   +-----------------------+-----------------+-----------------+\n\nNotes for testpmd\n-----------------\n\nCompared to librte_pmd_mlx4 that implements a single RSS configuration per\nport, librte_pmd_mlx5 supports per-protocol RSS configuration.\n\nSince ``testpmd`` defaults to IP RSS mode and there is currently no\ncommand-line parameter to enable additional protocols (UDP and TCP as well\nas IP), the following commands must be entered from its CLI to get the same\nbehavior as librte_pmd_mlx4::\n\n   > port stop all\n   > port config all rss all\n   > port start all\n\nUsage example\n-------------\n\nThis section demonstrates how to launch **testpmd** with Mellanox\nConnectX-4/ConnectX-5/ConnectX-6/BlueField devices managed by librte_pmd_mlx5.\n\n#. Load the kernel modules::\n\n      modprobe -a ib_uverbs mlx5_core mlx5_ib\n\n   Alternatively if MLNX_OFED/MLNX_EN is fully installed, the following script\n   can be run::\n\n      /etc/init.d/openibd restart\n\n   .. note::\n\n      User space I/O kernel modules (uio and igb_uio) are not used and do\n      not have to be loaded.\n\n#. Make sure Ethernet interfaces are in working order and linked to kernel\n   verbs. Related sysfs entries should be present::\n\n      ls -d /sys/class/net/*/device/infiniband_verbs/uverbs* | cut -d / -f 5\n\n   Example output::\n\n      eth30\n      eth31\n      eth32\n      eth33\n\n#. Optionally, retrieve their PCI bus addresses for whitelisting::\n\n      {\n          for intf in eth2 eth3 eth4 eth5;\n          do\n              (cd \"/sys/class/net/${intf}/device/\" && pwd -P);\n          done;\n      } |\n      sed -n 's,.*/\\(.*\\),-w \\1,p'\n\n   Example output::\n\n      -w 0000:05:00.1\n      -w 0000:06:00.0\n      -w 0000:06:00.1\n      -w 0000:05:00.0\n\n#. Request huge pages::\n\n      echo 1024 > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages/nr_hugepages\n\n#. Start testpmd with basic parameters::\n\n      testpmd -l 8-15 -n 4 -w 05:00.0 -w 05:00.1 -w 06:00.0 -w 06:00.1 -- --rxq=2 --txq=2 -i\n\n   Example output::\n\n      [...]\n      EAL: PCI device 0000:05:00.0 on NUMA socket 0\n      EAL:   probe driver: 15b3:1013 librte_pmd_mlx5\n      PMD: librte_pmd_mlx5: PCI information matches, using device \"mlx5_0\" (VF: false)\n      PMD: librte_pmd_mlx5: 1 port(s) detected\n      PMD: librte_pmd_mlx5: port 1 MAC address is e4:1d:2d:e7:0c:fe\n      EAL: PCI device 0000:05:00.1 on NUMA socket 0\n      EAL:   probe driver: 15b3:1013 librte_pmd_mlx5\n      PMD: librte_pmd_mlx5: PCI information matches, using device \"mlx5_1\" (VF: false)\n      PMD: librte_pmd_mlx5: 1 port(s) detected\n      PMD: librte_pmd_mlx5: port 1 MAC address is e4:1d:2d:e7:0c:ff\n      EAL: PCI device 0000:06:00.0 on NUMA socket 0\n      EAL:   probe driver: 15b3:1013 librte_pmd_mlx5\n      PMD: librte_pmd_mlx5: PCI information matches, using device \"mlx5_2\" (VF: false)\n      PMD: librte_pmd_mlx5: 1 port(s) detected\n      PMD: librte_pmd_mlx5: port 1 MAC address is e4:1d:2d:e7:0c:fa\n      EAL: PCI device 0000:06:00.1 on NUMA socket 0\n      EAL:   probe driver: 15b3:1013 librte_pmd_mlx5\n      PMD: librte_pmd_mlx5: PCI information matches, using device \"mlx5_3\" (VF: false)\n      PMD: librte_pmd_mlx5: 1 port(s) detected\n      PMD: librte_pmd_mlx5: port 1 MAC address is e4:1d:2d:e7:0c:fb\n      Interactive-mode selected\n      Configuring Port 0 (socket 0)\n      PMD: librte_pmd_mlx5: 0x8cba80: TX queues number update: 0 -> 2\n      PMD: librte_pmd_mlx5: 0x8cba80: RX queues number update: 0 -> 2\n      Port 0: E4:1D:2D:E7:0C:FE\n      Configuring Port 1 (socket 0)\n      PMD: librte_pmd_mlx5: 0x8ccac8: TX queues number update: 0 -> 2\n      PMD: librte_pmd_mlx5: 0x8ccac8: RX queues number update: 0 -> 2\n      Port 1: E4:1D:2D:E7:0C:FF\n      Configuring Port 2 (socket 0)\n      PMD: librte_pmd_mlx5: 0x8cdb10: TX queues number update: 0 -> 2\n      PMD: librte_pmd_mlx5: 0x8cdb10: RX queues number update: 0 -> 2\n      Port 2: E4:1D:2D:E7:0C:FA\n      Configuring Port 3 (socket 0)\n      PMD: librte_pmd_mlx5: 0x8ceb58: TX queues number update: 0 -> 2\n      PMD: librte_pmd_mlx5: 0x8ceb58: RX queues number update: 0 -> 2\n      Port 3: E4:1D:2D:E7:0C:FB\n      Checking link statuses...\n      Port 0 Link Up - speed 40000 Mbps - full-duplex\n      Port 1 Link Up - speed 40000 Mbps - full-duplex\n      Port 2 Link Up - speed 10000 Mbps - full-duplex\n      Port 3 Link Up - speed 10000 Mbps - full-duplex\n      Done\n      testpmd>\n\nHow to dump flows\n-----------------\n\nThis section demonstrates how to dump flows. Currently, it's possible to dump\nall flows with assistance of external tools.\n\n#. 2 ways to get flow raw file:\n\n   - Using testpmd CLI:\n\n   .. code-block:: console\n\n       testpmd> flow dump <port> <output_file>\n\n   - call rte_flow_dev_dump api:\n\n   .. code-block:: console\n\n       rte_flow_dev_dump(port, file, NULL);\n\n#. Dump human-readable flows from raw file:\n\n   Get flow parsing tool from: https://github.com/Mellanox/mlx_steering_dump\n\n   .. code-block:: console\n\n       mlx_steering_dump.py -f <output_file>\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/nics/img/forward_stats.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/nics/img/console.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/nics/img/host_vm_comms.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/nics/img/fast_pkt_proc.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/nics/img/perf_benchmark.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/nics/img/vm_vm_comms.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/nics/img/vswitch_vm.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/nics/img/host_vm_comms_qemu.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/nics/img/inter_vm_comms.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/nics/img/vmxnet3_int.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/nics/img/single_port_nic.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/sample_app_ug/img/load_bal_app_arch.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/sample_app_ug/img/quickassist_block_diagram.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/sample_app_ug/img/l2_fwd_virtenv_benchmark_setup.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/sample_app_ug/img/pipeline_overview.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/sample_app_ug/img/kernel_nic.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/sample_app_ug/img/example_rules.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/sample_app_ug/img/client_svr_sym_multi_proc_app.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/sample_app_ug/img/sym_multi_proc_app.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/sample_app_ug/img/test_pipeline_app.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/sample_app_ug/img/ring_pipeline_perf_setup.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/sample_app_ug/img/qos_sched_app_arch.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/sample_app_ug/img/ipv4_acl_rule.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/sample_app_ug/img/threads_pipelines.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/ex_data_flow_tru_dropper.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/figure35.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/figure33.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/m_definition.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/ewma_filter_eq_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/kernel_nic_intf.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/prefetch_pipeline.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/drop_probability_eq3.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/packet_distributor2.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/pkt_flow_kni.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/tbl24_tbl8_tbl8.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/packet_distributor1.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/hier_sched_blk.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/ewma_filter_eq_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/eq2_factor.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/figure34.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/kni_traffic_flow.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/pkt_drop_probability.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/pipe_prefetch_sm.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/data_struct_per_port.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/drop_probability_eq4.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/vhost_net_arch.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/flow_tru_droppper.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/figure39.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/pkt_proc_pipeline_qos.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/figure32.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/tbl24_tbl8.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/figure38.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/blk_diag_dropper.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/eq2_expression.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/figure37.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/guides/prog_guide/img/drop_probability_graph.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/logo/DPDK_logo_vertical_rev_small.png",
        "/tmp/vanessa/spack-stage/spack-stage-dpdk-20.02-vatcqxnchicpxv3lf547pfzhoqumu5wb/spack-src/doc/logo/DPDK_logo_horizontal_tag.png"
    ],
    "total_files": 3923
}