{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-kokkos-3.2.00-aoz24nijj3bbjkhfddyqizckxdsdf23n/spack-src/core/src/impl/Kokkos_Profiling.cpp": "/*\n//@HEADER\n// ************************************************************************\n//\n//                        Kokkos v. 3.0\n//       Copyright (2020) National Technology & Engineering\n//               Solutions of Sandia, LLC (NTESS).\n//\n// Under the terms of Contract DE-NA0003525 with NTESS,\n// the U.S. Government retains certain rights in this software.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// 1. Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n// notice, this list of conditions and the following disclaimer in the\n// documentation and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the Corporation nor the names of the\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY NTESS \"AS IS\" AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NTESS OR THE\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Questions? Contact Christian R. Trott (crtrott@sandia.gov)\n//\n// ************************************************************************\n//@HEADER\n*/\n\n#include <Kokkos_Macros.hpp>\n#include <impl/Kokkos_Profiling.hpp>\n#if defined(KOKKOS_ENABLE_LIBDL)\n#include <dlfcn.h>\n#endif\n\n#include <cstring>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <vector>\n#include <array>\n#include <stack>\n#include <iostream>\n\nnamespace Kokkos {\n\nnamespace Tools {\n\nnamespace Experimental {\n#ifdef KOKKOS_ENABLE_TUNING\nstatic size_t kernel_name_context_variable_id;\nstatic size_t kernel_type_context_variable_id;\nstatic std::unordered_map<size_t, std::unordered_set<size_t>>\n    features_per_context;\nstatic std::unordered_set<size_t> active_features;\nstatic std::unordered_map<size_t, VariableValue> feature_values;\nstatic std::unordered_map<size_t, VariableInfo> variable_metadata;\n#endif\n\nstatic EventSet current_callbacks;\nstatic EventSet backup_callbacks;\nstatic EventSet no_profiling;\n\nbool eventSetsEqual(const EventSet& l, const EventSet& r) {\n  return l.init == r.init && l.finalize == r.finalize &&\n         l.begin_parallel_for == r.begin_parallel_for &&\n         l.end_parallel_for == r.end_parallel_for &&\n         l.begin_parallel_reduce == r.begin_parallel_reduce &&\n         l.end_parallel_reduce == r.end_parallel_reduce &&\n         l.begin_parallel_scan == r.begin_parallel_scan &&\n         l.end_parallel_scan == r.end_parallel_scan &&\n         l.push_region == r.push_region && l.pop_region == r.pop_region &&\n         l.allocate_data == r.allocate_data &&\n         l.deallocate_data == r.deallocate_data &&\n         l.create_profile_section == r.create_profile_section &&\n         l.start_profile_section == r.start_profile_section &&\n         l.stop_profile_section == r.stop_profile_section &&\n         l.destroy_profile_section == r.destroy_profile_section &&\n         l.profile_event == r.profile_event &&\n         l.begin_deep_copy == r.begin_deep_copy &&\n         l.end_deep_copy == r.end_deep_copy &&\n         l.declare_input_type == r.declare_input_type &&\n         l.declare_output_type == r.declare_output_type &&\n         l.end_tuning_context == r.end_tuning_context &&\n         l.begin_tuning_context == r.begin_tuning_context &&\n         l.request_output_values == r.request_output_values &&\n         l.declare_optimization_goal == r.declare_optimization_goal;\n}\n}  // namespace Experimental\nbool profileLibraryLoaded() {\n  return !Experimental::eventSetsEqual(Experimental::current_callbacks,\n                                       Experimental::no_profiling);\n}\n\nvoid beginParallelFor(const std::string& kernelPrefix, const uint32_t devID,\n                      uint64_t* kernelID) {\n  if (Experimental::current_callbacks.begin_parallel_for != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.begin_parallel_for)(kernelPrefix.c_str(),\n                                                          devID, kernelID);\n#ifdef KOKKOS_ENABLE_TUNING\n    auto context_id = Experimental::get_new_context_id();\n    Experimental::begin_context(context_id);\n    Experimental::VariableValue contextValues[] = {\n        Experimental::make_variable_value(\n            Experimental::kernel_name_context_variable_id, kernelPrefix),\n        Experimental::make_variable_value(\n            Experimental::kernel_type_context_variable_id, \"parallel_for\")};\n    Experimental::set_input_values(context_id, 2, contextValues);\n#endif\n  }\n}\n\nvoid endParallelFor(const uint64_t kernelID) {\n  if (Experimental::current_callbacks.end_parallel_for != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.end_parallel_for)(kernelID);\n#ifdef KOKKOS_ENABLE_TUNING\n    Experimental::end_context(Experimental::get_current_context_id());\n#endif\n  }\n}\n\nvoid beginParallelScan(const std::string& kernelPrefix, const uint32_t devID,\n                       uint64_t* kernelID) {\n  if (Experimental::current_callbacks.begin_parallel_scan != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.begin_parallel_scan)(kernelPrefix.c_str(),\n                                                           devID, kernelID);\n#ifdef KOKKOS_ENABLE_TUNING\n    auto context_id = Experimental::get_new_context_id();\n    Experimental::begin_context(context_id);\n    Experimental::VariableValue contextValues[] = {\n        Experimental::make_variable_value(\n            Experimental::kernel_name_context_variable_id, kernelPrefix),\n        Experimental::make_variable_value(\n            Experimental::kernel_type_context_variable_id, \"parallel_for\")};\n    Experimental::set_input_values(context_id, 2, contextValues);\n#endif\n  }\n}\n\nvoid endParallelScan(const uint64_t kernelID) {\n  if (Experimental::current_callbacks.end_parallel_scan != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.end_parallel_scan)(kernelID);\n#ifdef KOKKOS_ENABLE_TUNING\n    Experimental::end_context(Experimental::get_current_context_id());\n#endif\n  }\n}\n\nvoid beginParallelReduce(const std::string& kernelPrefix, const uint32_t devID,\n                         uint64_t* kernelID) {\n  if (Experimental::current_callbacks.begin_parallel_reduce != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.begin_parallel_reduce)(\n        kernelPrefix.c_str(), devID, kernelID);\n#ifdef KOKKOS_ENABLE_TUNING\n    auto context_id = Experimental::get_new_context_id();\n    Experimental::begin_context(context_id);\n    Experimental::VariableValue contextValues[] = {\n        Experimental::make_variable_value(\n            Experimental::kernel_name_context_variable_id, kernelPrefix),\n        Experimental::make_variable_value(\n            Experimental::kernel_type_context_variable_id, \"parallel_for\")};\n    Experimental::set_input_values(context_id, 2, contextValues);\n#endif\n  }\n}\n\nvoid endParallelReduce(const uint64_t kernelID) {\n  if (Experimental::current_callbacks.end_parallel_reduce != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.end_parallel_reduce)(kernelID);\n#ifdef KOKKOS_ENABLE_TUNING\n    Experimental::end_context(Experimental::get_current_context_id());\n#endif\n  }\n}\n\nvoid pushRegion(const std::string& kName) {\n  if (Experimental::current_callbacks.push_region != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.push_region)(kName.c_str());\n  }\n}\n\nvoid popRegion() {\n  if (Experimental::current_callbacks.pop_region != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.pop_region)();\n  }\n}\n\nvoid allocateData(const SpaceHandle space, const std::string label,\n                  const void* ptr, const uint64_t size) {\n  if (Experimental::current_callbacks.allocate_data != nullptr) {\n    (*Experimental::current_callbacks.allocate_data)(space, label.c_str(), ptr,\n                                                     size);\n  }\n}\n\nvoid deallocateData(const SpaceHandle space, const std::string label,\n                    const void* ptr, const uint64_t size) {\n  if (Experimental::current_callbacks.deallocate_data != nullptr) {\n    (*Experimental::current_callbacks.deallocate_data)(space, label.c_str(),\n                                                       ptr, size);\n  }\n}\n\nvoid beginDeepCopy(const SpaceHandle dst_space, const std::string dst_label,\n                   const void* dst_ptr, const SpaceHandle src_space,\n                   const std::string src_label, const void* src_ptr,\n                   const uint64_t size) {\n  if (Experimental::current_callbacks.begin_deep_copy != nullptr) {\n    (*Experimental::current_callbacks.begin_deep_copy)(\n        dst_space, dst_label.c_str(), dst_ptr, src_space, src_label.c_str(),\n        src_ptr, size);\n#ifdef KOKKOS_ENABLE_TUNING\n    auto context_id = Experimental::get_new_context_id();\n    Experimental::begin_context(context_id);\n    Experimental::VariableValue contextValues[] = {\n        Experimental::make_variable_value(\n            Experimental::kernel_name_context_variable_id, \"deep_copy_kernel\"),\n        Experimental::make_variable_value(\n            Experimental::kernel_type_context_variable_id, \"deep_copy\")};\n    Experimental::set_input_values(context_id, 2, contextValues);\n#endif\n  }\n}\n\nvoid endDeepCopy() {\n  if (Experimental::current_callbacks.end_deep_copy != nullptr) {\n    (*Experimental::current_callbacks.end_deep_copy)();\n#ifdef KOKKOS_ENABLE_TUNING\n    Experimental::end_context(Experimental::get_current_context_id());\n#endif\n  }\n}\n\nvoid createProfileSection(const std::string& sectionName, uint32_t* secID) {\n  if (Experimental::current_callbacks.create_profile_section != nullptr) {\n    (*Experimental::current_callbacks.create_profile_section)(\n        sectionName.c_str(), secID);\n  }\n}\n\nvoid startSection(const uint32_t secID) {\n  if (Experimental::current_callbacks.start_profile_section != nullptr) {\n    (*Experimental::current_callbacks.start_profile_section)(secID);\n  }\n}\n\nvoid stopSection(const uint32_t secID) {\n  if (Experimental::current_callbacks.stop_profile_section != nullptr) {\n    (*Experimental::current_callbacks.stop_profile_section)(secID);\n  }\n}\n\nvoid destroyProfileSection(const uint32_t secID) {\n  if (Experimental::current_callbacks.destroy_profile_section != nullptr) {\n    (*Experimental::current_callbacks.destroy_profile_section)(secID);\n  }\n}\n\nvoid markEvent(const std::string& eventName) {\n  if (Experimental::current_callbacks.profile_event != nullptr) {\n    (*Experimental::current_callbacks.profile_event)(eventName.c_str());\n  }\n}\n\nSpaceHandle make_space_handle(const char* space_name) {\n  SpaceHandle handle;\n  strncpy(handle.name, space_name, 63);\n  return handle;\n}\n\nvoid initialize() {\n  // Make sure initialize calls happens only once\n  static int is_initialized = 0;\n  if (is_initialized) return;\n  is_initialized = 1;\n\n#ifdef KOKKOS_ENABLE_LIBDL\n  void* firstProfileLibrary = nullptr;\n\n  char* envProfileLibrary = getenv(\"KOKKOS_PROFILE_LIBRARY\");\n\n  // If we do not find a profiling library in the environment then exit\n  // early.\n  if (envProfileLibrary == nullptr) {\n    return;\n  }\n\n  char* envProfileCopy =\n      (char*)malloc(sizeof(char) * (strlen(envProfileLibrary) + 1));\n  sprintf(envProfileCopy, \"%s\", envProfileLibrary);\n\n  char* profileLibraryName = strtok(envProfileCopy, \";\");\n\n  if ((profileLibraryName != nullptr) &&\n      (strcmp(profileLibraryName, \"\") != 0)) {\n    firstProfileLibrary = dlopen(profileLibraryName, RTLD_NOW | RTLD_GLOBAL);\n\n    if (firstProfileLibrary == nullptr) {\n      std::cerr << \"Error: Unable to load KokkosP library: \"\n                << profileLibraryName << std::endl;\n      std::cerr << \"dlopen(\" << profileLibraryName\n                << \", RTLD_NOW | RTLD_GLOBAL) failed with \" << dlerror()\n                << '\\n';\n    } else {\n#ifdef KOKKOS_ENABLE_PROFILING_LOAD_PRINT\n      std::cout << \"KokkosP: Library Loaded: \" << profileLibraryName\n                << std::endl;\n#endif\n      // dlsym returns a pointer to an object, while we want to assign to\n      // pointer to function A direct cast will give warnings hence, we have to\n      // workaround the issue by casting pointer to pointers.\n      auto p1 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_for\");\n      Experimental::set_begin_parallel_for_callback(\n          *reinterpret_cast<beginFunction*>(&p1));\n      auto p2 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_scan\");\n      Experimental::set_begin_parallel_scan_callback(\n          *reinterpret_cast<beginFunction*>(&p2));\n      auto p3 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_reduce\");\n      Experimental::set_begin_parallel_reduce_callback(\n          *reinterpret_cast<beginFunction*>(&p3));\n\n      auto p4 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_scan\");\n      Experimental::set_end_parallel_scan_callback(\n          *reinterpret_cast<endFunction*>(&p4));\n      auto p5 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_for\");\n      Experimental::set_end_parallel_for_callback(\n          *reinterpret_cast<endFunction*>(&p5));\n      auto p6 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_reduce\");\n      Experimental::set_end_parallel_reduce_callback(\n          *reinterpret_cast<endFunction*>(&p6));\n\n      auto p7 = dlsym(firstProfileLibrary, \"kokkosp_init_library\");\n      Experimental::set_init_callback(*reinterpret_cast<initFunction*>(&p7));\n      auto p8 = dlsym(firstProfileLibrary, \"kokkosp_finalize_library\");\n      Experimental::set_finalize_callback(\n          *reinterpret_cast<finalizeFunction*>(&p8));\n\n      auto p9 = dlsym(firstProfileLibrary, \"kokkosp_push_profile_region\");\n      Experimental::set_push_region_callback(\n          *reinterpret_cast<pushFunction*>(&p9));\n      auto p10 = dlsym(firstProfileLibrary, \"kokkosp_pop_profile_region\");\n      Experimental::set_pop_region_callback(\n          *reinterpret_cast<popFunction*>(&p10));\n\n      auto p11 = dlsym(firstProfileLibrary, \"kokkosp_allocate_data\");\n      Experimental::set_allocate_data_callback(\n          *reinterpret_cast<allocateDataFunction*>(&p11));\n      auto p12 = dlsym(firstProfileLibrary, \"kokkosp_deallocate_data\");\n      Experimental::set_deallocate_data_callback(\n          *reinterpret_cast<deallocateDataFunction*>(&p12));\n\n      auto p13 = dlsym(firstProfileLibrary, \"kokkosp_begin_deep_copy\");\n      Experimental::set_begin_deep_copy_callback(\n          *reinterpret_cast<beginDeepCopyFunction*>(&p13));\n      auto p14 = dlsym(firstProfileLibrary, \"kokkosp_end_deep_copy\");\n      Experimental::set_end_deep_copy_callback(\n          *reinterpret_cast<endDeepCopyFunction*>(&p14));\n\n      auto p15 = dlsym(firstProfileLibrary, \"kokkosp_create_profile_section\");\n      Experimental::set_create_profile_section_callback(\n          *(reinterpret_cast<createProfileSectionFunction*>(&p15)));\n      auto p16 = dlsym(firstProfileLibrary, \"kokkosp_start_profile_section\");\n      Experimental::set_start_profile_section_callback(\n          *reinterpret_cast<startProfileSectionFunction*>(&p16));\n      auto p17 = dlsym(firstProfileLibrary, \"kokkosp_stop_profile_section\");\n      Experimental::set_stop_profile_section_callback(\n          *reinterpret_cast<stopProfileSectionFunction*>(&p17));\n      auto p18 = dlsym(firstProfileLibrary, \"kokkosp_destroy_profile_section\");\n      Experimental::set_destroy_profile_section_callback(\n          *(reinterpret_cast<destroyProfileSectionFunction*>(&p18)));\n\n      auto p19 = dlsym(firstProfileLibrary, \"kokkosp_profile_event\");\n      Experimental::set_profile_event_callback(\n          *reinterpret_cast<profileEventFunction*>(&p19));\n\n#ifdef KOKKOS_ENABLE_TUNING\n      auto p20 = dlsym(firstProfileLibrary, \"kokkosp_declare_output_type\");\n      Experimental::set_declare_output_type_callback(\n          *reinterpret_cast<Experimental::outputTypeDeclarationFunction*>(\n              &p20));\n\n      auto p21 = dlsym(firstProfileLibrary, \"kokkosp_declare_input_type\");\n      Experimental::set_declare_input_type_callback(\n          *reinterpret_cast<Experimental::inputTypeDeclarationFunction*>(&p21));\n      auto p22 = dlsym(firstProfileLibrary, \"kokkosp_request_values\");\n      Experimental::set_request_output_values_callback(\n          *reinterpret_cast<Experimental::requestValueFunction*>(&p22));\n      auto p23 = dlsym(firstProfileLibrary, \"kokkosp_end_context\");\n      Experimental::set_end_context_callback(\n          *reinterpret_cast<Experimental::contextEndFunction*>(&p23));\n      auto p24 = dlsym(firstProfileLibrary, \"kokkosp_begin_context\");\n      Experimental::set_begin_context_callback(\n          *reinterpret_cast<Experimental::contextBeginFunction*>(&p24));\n      auto p25 =\n          dlsym(firstProfileLibrary, \"kokkosp_declare_optimization_goal\");\n      Experimental::set_declare_optimization_goal_callback(\n          *reinterpret_cast<Experimental::optimizationGoalDeclarationFunction*>(\n              &p25));\n#endif  // KOKKOS_ENABLE_TUNING\n    }\n  }\n#endif  // KOKKOS_ENABLE_LIBDL\n  if (Experimental::current_callbacks.init != nullptr) {\n    (*Experimental::current_callbacks.init)(\n        0, (uint64_t)KOKKOSP_INTERFACE_VERSION, (uint32_t)0, nullptr);\n  }\n\n#ifdef KOKKOS_ENABLE_TUNING\n  Experimental::VariableInfo kernel_name;\n  kernel_name.type = Experimental::ValueType::kokkos_value_string;\n  kernel_name.category =\n      Experimental::StatisticalCategory::kokkos_value_categorical;\n  kernel_name.valueQuantity =\n      Experimental::CandidateValueType::kokkos_value_unbounded;\n\n  std::array<std::string, 4> candidate_values = {\n      \"parallel_for\",\n      \"parallel_reduce\",\n      \"parallel_scan\",\n      \"parallel_copy\",\n  };\n\n  Experimental::SetOrRange kernel_type_variable_candidates =\n      Experimental::make_candidate_set(4, candidate_values.data());\n\n  Experimental::kernel_name_context_variable_id =\n      Experimental::declare_input_type(\"kokkos.kernel_name\", kernel_name);\n\n  Experimental::VariableInfo kernel_type;\n  kernel_type.type = Experimental::ValueType::kokkos_value_string;\n  kernel_type.category =\n      Experimental::StatisticalCategory::kokkos_value_categorical;\n  kernel_type.valueQuantity =\n      Experimental::CandidateValueType::kokkos_value_set;\n  kernel_type.candidates = kernel_type_variable_candidates;\n  Experimental::kernel_type_context_variable_id =\n      Experimental::declare_input_type(\"kokkos.kernel_type\", kernel_type);\n\n#endif\n\n  Experimental::no_profiling.init     = nullptr;\n  Experimental::no_profiling.finalize = nullptr;\n\n  Experimental::no_profiling.begin_parallel_for    = nullptr;\n  Experimental::no_profiling.begin_parallel_scan   = nullptr;\n  Experimental::no_profiling.begin_parallel_reduce = nullptr;\n  Experimental::no_profiling.end_parallel_scan     = nullptr;\n  Experimental::no_profiling.end_parallel_for      = nullptr;\n  Experimental::no_profiling.end_parallel_reduce   = nullptr;\n\n  Experimental::no_profiling.push_region     = nullptr;\n  Experimental::no_profiling.pop_region      = nullptr;\n  Experimental::no_profiling.allocate_data   = nullptr;\n  Experimental::no_profiling.deallocate_data = nullptr;\n\n  Experimental::no_profiling.begin_deep_copy = nullptr;\n  Experimental::no_profiling.end_deep_copy   = nullptr;\n\n  Experimental::no_profiling.create_profile_section  = nullptr;\n  Experimental::no_profiling.start_profile_section   = nullptr;\n  Experimental::no_profiling.stop_profile_section    = nullptr;\n  Experimental::no_profiling.destroy_profile_section = nullptr;\n\n  Experimental::no_profiling.profile_event = nullptr;\n\n  Experimental::no_profiling.declare_input_type    = nullptr;\n  Experimental::no_profiling.declare_output_type   = nullptr;\n  Experimental::no_profiling.request_output_values = nullptr;\n  Experimental::no_profiling.end_tuning_context    = nullptr;\n#ifdef KOKKOS_ENABLE_LIBDL\n  free(envProfileCopy);\n#endif\n}\n\nvoid finalize() {\n  // Make sure finalize calls happens only once\n  static int is_finalized = 0;\n  if (is_finalized) return;\n  is_finalized = 1;\n\n  if (Experimental::current_callbacks.finalize != nullptr) {\n    (*Experimental::current_callbacks.finalize)();\n\n    Experimental::pause_tools();\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  // clean up string candidate set\n  for (auto& metadata_pair : Experimental::variable_metadata) {\n    auto metadata = metadata_pair.second;\n    if ((metadata.type == Experimental::ValueType::kokkos_value_string) &&\n        (metadata.valueQuantity ==\n         Experimental::CandidateValueType::kokkos_value_set)) {\n      auto candidate_set = metadata.candidates.set;\n      delete[] candidate_set.values.string_value;\n    }\n  }\n#endif\n}\n\n}  // namespace Tools\n\nnamespace Tools {\nnamespace Experimental {\nvoid set_init_callback(initFunction callback) {\n  current_callbacks.init = callback;\n}\nvoid set_finalize_callback(finalizeFunction callback) {\n  current_callbacks.finalize = callback;\n}\nvoid set_begin_parallel_for_callback(beginFunction callback) {\n  current_callbacks.begin_parallel_for = callback;\n}\nvoid set_end_parallel_for_callback(endFunction callback) {\n  current_callbacks.end_parallel_for = callback;\n}\nvoid set_begin_parallel_reduce_callback(beginFunction callback) {\n  current_callbacks.begin_parallel_reduce = callback;\n}\nvoid set_end_parallel_reduce_callback(endFunction callback) {\n  current_callbacks.end_parallel_reduce = callback;\n}\nvoid set_begin_parallel_scan_callback(beginFunction callback) {\n  current_callbacks.begin_parallel_scan = callback;\n}\nvoid set_end_parallel_scan_callback(endFunction callback) {\n  current_callbacks.end_parallel_scan = callback;\n}\nvoid set_push_region_callback(pushFunction callback) {\n  current_callbacks.push_region = callback;\n}\nvoid set_pop_region_callback(popFunction callback) {\n  current_callbacks.pop_region = callback;\n}\nvoid set_allocate_data_callback(allocateDataFunction callback) {\n  current_callbacks.allocate_data = callback;\n}\nvoid set_deallocate_data_callback(deallocateDataFunction callback) {\n  current_callbacks.deallocate_data = callback;\n}\nvoid set_create_profile_section_callback(\n    createProfileSectionFunction callback) {\n  current_callbacks.create_profile_section = callback;\n}\nvoid set_start_profile_section_callback(startProfileSectionFunction callback) {\n  current_callbacks.start_profile_section = callback;\n}\nvoid set_stop_profile_section_callback(stopProfileSectionFunction callback) {\n  current_callbacks.stop_profile_section = callback;\n}\nvoid set_destroy_profile_section_callback(\n    destroyProfileSectionFunction callback) {\n  current_callbacks.destroy_profile_section = callback;\n}\nvoid set_profile_event_callback(profileEventFunction callback) {\n  current_callbacks.profile_event = callback;\n}\nvoid set_begin_deep_copy_callback(beginDeepCopyFunction callback) {\n  current_callbacks.begin_deep_copy = callback;\n}\nvoid set_end_deep_copy_callback(endDeepCopyFunction callback) {\n  current_callbacks.end_deep_copy = callback;\n}\n\nvoid set_declare_output_type_callback(outputTypeDeclarationFunction callback) {\n  current_callbacks.declare_output_type = callback;\n}\nvoid set_declare_input_type_callback(inputTypeDeclarationFunction callback) {\n  current_callbacks.declare_input_type = callback;\n}\nvoid set_request_output_values_callback(requestValueFunction callback) {\n  current_callbacks.request_output_values = callback;\n}\nvoid set_end_context_callback(contextEndFunction callback) {\n  current_callbacks.end_tuning_context = callback;\n}\nvoid set_begin_context_callback(contextBeginFunction callback) {\n  current_callbacks.begin_tuning_context = callback;\n}\nvoid set_declare_optimization_goal_callback(\n    optimizationGoalDeclarationFunction callback) {\n  current_callbacks.declare_optimization_goal = callback;\n}\n\nvoid pause_tools() {\n  backup_callbacks  = current_callbacks;\n  current_callbacks = no_profiling;\n}\n\nvoid resume_tools() { current_callbacks = backup_callbacks; }\n\nEventSet get_callbacks() { return current_callbacks; }\nvoid set_callbacks(EventSet new_events) { current_callbacks = new_events; }\n}  // namespace Experimental\n}  // namespace Tools\n\nnamespace Profiling {\nbool profileLibraryLoaded() { return Kokkos::Tools::profileLibraryLoaded(); }\n\nvoid beginParallelFor(const std::string& kernelPrefix, const uint32_t devID,\n                      uint64_t* kernelID) {\n  Kokkos::Tools::beginParallelFor(kernelPrefix, devID, kernelID);\n}\nvoid beginParallelReduce(const std::string& kernelPrefix, const uint32_t devID,\n                         uint64_t* kernelID) {\n  Kokkos::Tools::beginParallelReduce(kernelPrefix, devID, kernelID);\n}\nvoid beginParallelScan(const std::string& kernelPrefix, const uint32_t devID,\n                       uint64_t* kernelID) {\n  Kokkos::Tools::beginParallelScan(kernelPrefix, devID, kernelID);\n}\nvoid endParallelFor(const uint64_t kernelID) {\n  Kokkos::Tools::endParallelFor(kernelID);\n}\nvoid endParallelReduce(const uint64_t kernelID) {\n  Kokkos::Tools::endParallelReduce(kernelID);\n}\nvoid endParallelScan(const uint64_t kernelID) {\n  Kokkos::Tools::endParallelScan(kernelID);\n}\n\nvoid pushRegion(const std::string& kName) { Kokkos::Tools::pushRegion(kName); }\nvoid popRegion() { Kokkos::Tools::popRegion(); }\n\nvoid createProfileSection(const std::string& sectionName, uint32_t* secID) {\n  Kokkos::Tools::createProfileSection(sectionName, secID);\n}\nvoid destroyProfileSection(const uint32_t secID) {\n  Kokkos::Tools::destroyProfileSection(secID);\n}\n\nvoid startSection(const uint32_t secID) { Kokkos::Tools::startSection(secID); }\n\nvoid stopSection(const uint32_t secID) { Kokkos::Tools::stopSection(secID); }\n\nvoid markEvent(const std::string& eventName) {\n  Kokkos::Tools::markEvent(eventName);\n}\nvoid allocateData(const SpaceHandle handle, const std::string name,\n                  const void* data, const uint64_t size) {\n  Kokkos::Tools::allocateData(handle, name, data, size);\n}\nvoid deallocateData(const SpaceHandle space, const std::string label,\n                    const void* ptr, const uint64_t size) {\n  Kokkos::Tools::deallocateData(space, label, ptr, size);\n}\n\nvoid beginDeepCopy(const SpaceHandle dst_space, const std::string dst_label,\n                   const void* dst_ptr, const SpaceHandle src_space,\n                   const std::string src_label, const void* src_ptr,\n                   const uint64_t size) {\n  Kokkos::Tools::beginDeepCopy(dst_space, dst_label, dst_ptr, src_space,\n                               src_label, src_ptr, size);\n}\nvoid endDeepCopy() { Kokkos::Tools::endDeepCopy(); }\n\nvoid finalize() { Kokkos::Tools::finalize(); }\nvoid initialize() { Kokkos::Tools::initialize(); }\n\nSpaceHandle make_space_handle(const char* space_name) {\n  return Kokkos::Tools::make_space_handle(space_name);\n}\n}  // namespace Profiling\n\n}  // namespace Kokkos\n\n// Tuning\n\nnamespace Kokkos {\nnamespace Tools {\nnamespace Experimental {\nstatic size_t& get_context_counter() {\n  static size_t x;\n  return x;\n}\nstatic size_t& get_variable_counter() {\n  static size_t x;\n  return ++x;\n}\n\nsize_t get_new_context_id() { return ++get_context_counter(); }\nsize_t get_current_context_id() { return get_context_counter(); }\nvoid decrement_current_context_id() { --get_context_counter(); }\nsize_t get_new_variable_id() { return get_variable_counter(); }\n\nsize_t declare_output_type(const std::string& variableName, VariableInfo info) {\n  size_t variableId = get_new_variable_id();\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Experimental::current_callbacks.declare_output_type != nullptr) {\n    (*Experimental::current_callbacks.declare_output_type)(variableName.c_str(),\n                                                           variableId, &info);\n  }\n  variable_metadata[variableId] = info;\n#else\n  (void)variableName;\n  (void)info;\n#endif\n  return variableId;\n}\n\nsize_t declare_input_type(const std::string& variableName, VariableInfo info) {\n  size_t variableId = get_new_variable_id();\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Experimental::current_callbacks.declare_input_type != nullptr) {\n    (*Experimental::current_callbacks.declare_input_type)(variableName.c_str(),\n                                                          variableId, &info);\n  }\n  variable_metadata[variableId] = info;\n#else\n  (void)variableName;\n  (void)info;\n#endif\n  return variableId;\n}\n\nvoid set_input_values(size_t contextId, size_t count, VariableValue* values) {\n#ifdef KOKKOS_ENABLE_TUNING\n  if (features_per_context.find(contextId) == features_per_context.end()) {\n    features_per_context[contextId] = std::unordered_set<size_t>();\n  }\n  for (size_t x = 0; x < count; ++x) {\n    values[x].metadata = &variable_metadata[values[x].type_id];\n    features_per_context[contextId].insert(values[x].type_id);\n    active_features.insert(values[x].type_id);\n    feature_values[values[x].type_id] = values[x];\n  }\n#else\n  (void)contextId;\n  (void)count;\n  (void)values;\n#endif\n}\n#include <iostream>\nvoid request_output_values(size_t contextId, size_t count,\n                           VariableValue* values) {\n#ifdef KOKKOS_ENABLE_TUNING\n  std::vector<size_t> context_ids;\n  std::vector<VariableValue> context_values;\n  for (auto id : active_features) {\n    context_values.push_back(feature_values[id]);\n  }\n  if (Experimental::current_callbacks.request_output_values != nullptr) {\n    for (size_t x = 0; x < count; ++x) {\n      values[x].metadata = &variable_metadata[values[x].type_id];\n    }\n    (*Experimental::current_callbacks.request_output_values)(\n        contextId, context_values.size(), context_values.data(), count, values);\n  }\n#else\n  (void)contextId;\n  (void)count;\n  (void)values;\n#endif\n}\n\nstatic std::unordered_map<size_t, size_t> optimization_goals;\n\nvoid begin_context(size_t contextId) {\n  if (Experimental::current_callbacks.begin_tuning_context != nullptr) {\n    (*Experimental::current_callbacks.begin_tuning_context)(contextId);\n  }\n}\nvoid end_context(size_t contextId) {\n#ifdef KOKKOS_ENABLE_TUNING\n  for (auto id : features_per_context[contextId]) {\n    active_features.erase(id);\n  }\n  if (Experimental::current_callbacks.end_tuning_context != nullptr) {\n    (*Experimental::current_callbacks.end_tuning_context)(\n        contextId, feature_values[optimization_goals[contextId]]);\n  }\n  optimization_goals.erase(contextId);\n  decrement_current_context_id();\n#else\n  (void)contextId;\n#endif\n}\n\nbool have_tuning_tool() {\n#ifdef KOKKOS_ENABLE_TUNING\n  return (Experimental::current_callbacks.request_output_values != nullptr);\n#else\n  return false;\n#endif\n}\n\nVariableValue make_variable_value(size_t id, int64_t val) {\n  VariableValue variable_value;\n  variable_value.type_id         = id;\n  variable_value.value.int_value = val;\n  return variable_value;\n}\nVariableValue make_variable_value(size_t id, double val) {\n  VariableValue variable_value;\n  variable_value.type_id            = id;\n  variable_value.value.double_value = val;\n  return variable_value;\n}\nVariableValue make_variable_value(size_t id, const std::string& val) {\n  VariableValue variable_value;\n  variable_value.type_id = id;\n  strncpy(variable_value.value.string_value, val.c_str(),\n          KOKKOS_TOOLS_TUNING_STRING_LENGTH - 1);\n  return variable_value;\n}\nSetOrRange make_candidate_set(size_t size, std::string* data) {\n  SetOrRange value_set;\n  value_set.set.values.string_value = new TuningString[size];\n  for (size_t x = 0; x < size; ++x) {\n    strncpy(value_set.set.values.string_value[x], data[x].c_str(),\n            KOKKOS_TOOLS_TUNING_STRING_LENGTH - 1);\n  }\n  value_set.set.size = size;\n  return value_set;\n}\nSetOrRange make_candidate_set(size_t size, int64_t* data) {\n  SetOrRange value_set;\n  value_set.set.size             = size;\n  value_set.set.values.int_value = data;\n  return value_set;\n}\nSetOrRange make_candidate_set(size_t size, double* data) {\n  SetOrRange value_set;\n  value_set.set.size                = size;\n  value_set.set.values.double_value = data;\n  return value_set;\n}\nSetOrRange make_candidate_range(double lower, double upper, double step,\n                                bool openLower = false,\n                                bool openUpper = false) {\n  SetOrRange value_range;\n  value_range.range.lower.double_value = lower;\n  value_range.range.upper.double_value = upper;\n  value_range.range.step.double_value  = step;\n  value_range.range.openLower          = openLower;\n  value_range.range.openUpper          = openUpper;\n  return value_range;\n}\n\nSetOrRange make_candidate_range(int64_t lower, int64_t upper, int64_t step,\n                                bool openLower = false,\n                                bool openUpper = false) {\n  SetOrRange value_range;\n  value_range.range.lower.int_value = lower;\n  value_range.range.upper.int_value = upper;\n  value_range.range.step.int_value  = step;\n  value_range.range.openLower       = openLower;\n  value_range.range.openUpper       = openUpper;\n  return value_range;\n}\n\nsize_t get_new_context_id();\nsize_t get_current_context_id();\nvoid decrement_current_context_id();\nsize_t get_new_variable_id();\nvoid declare_optimization_goal(const size_t context,\n                               const OptimizationGoal& goal) {\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Experimental::current_callbacks.declare_optimization_goal != nullptr) {\n    (*Experimental::current_callbacks.declare_optimization_goal)(context, goal);\n  }\n  optimization_goals[context] = goal.type_id;\n#else\n  (void)context;\n  (void)goal;\n#endif\n}\n}  // end namespace Experimental\n}  // end namespace Tools\n\n}  // end namespace Kokkos\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-kokkos-3.2.00-aoz24nijj3bbjkhfddyqizckxdsdf23n/spack-src/doc/SAND2017-10464-Kokkos-Task-DAG.pdf"
    ],
    "total_files": 1316
}