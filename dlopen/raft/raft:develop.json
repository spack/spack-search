{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-raft-develop-avjrki7w7nqtdsid6ntx6dnvvlhhkxqd/spack-src/src/common/inc/cuda_drvapi_dynlink.c": "/**\n * Copyright 1993-2013 NVIDIA Corporation.  All rights reserved.\n *\n * Please refer to the NVIDIA end user license agreement (EULA) associated\n * with this source code for terms and conditions that govern your use of\n * this software. Any use, reproduction, disclosure, or distribution of\n * this software and related documentation outside the terms of the EULA\n * is strictly prohibited.\n *\n */\n\n// With these flags defined, this source file will dynamically\n// load the corresponding functions.  Disabled by default.\n//#define CUDA_INIT_D3D9\n//#define CUDA_INIT_D3D10\n//#define CUDA_INIT_D3D11\n//#define CUDA_INIT_OPENGL\n\n#include <stdio.h>\n#include \"cuda_drvapi_dynlink.h\"\n\ntcuInit                               *_cuInit;\ntcuDriverGetVersion                   *cuDriverGetVersion;\ntcuDeviceGet                          *cuDeviceGet;\ntcuDeviceGetCount                     *cuDeviceGetCount;\ntcuDeviceGetName                      *cuDeviceGetName;\ntcuDeviceComputeCapability            *cuDeviceComputeCapability;\ntcuDeviceTotalMem                     *cuDeviceTotalMem;\ntcuDeviceGetProperties                *cuDeviceGetProperties;\ntcuDeviceGetAttribute                 *cuDeviceGetAttribute;\ntcuCtxCreate                          *cuCtxCreate;\ntcuCtxDestroy                         *cuCtxDestroy;\ntcuCtxAttach                          *cuCtxAttach;\ntcuCtxDetach                          *cuCtxDetach;\ntcuCtxPushCurrent                     *cuCtxPushCurrent;\ntcuCtxPopCurrent                      *cuCtxPopCurrent;\ntcuCtxGetCurrent                      *cuCtxGetCurrent;\ntcuCtxSetCurrent                      *cuCtxSetCurrent;\ntcuCtxGetDevice                       *cuCtxGetDevice;\ntcuCtxSynchronize                     *cuCtxSynchronize;\ntcuModuleLoad                         *cuModuleLoad;\ntcuModuleLoadData                     *cuModuleLoadData;\ntcuModuleLoadDataEx                   *cuModuleLoadDataEx;\ntcuModuleLoadFatBinary                *cuModuleLoadFatBinary;\ntcuModuleUnload                       *cuModuleUnload;\ntcuModuleGetFunction                  *cuModuleGetFunction;\ntcuModuleGetGlobal                    *cuModuleGetGlobal;\ntcuModuleGetTexRef                    *cuModuleGetTexRef;\ntcuModuleGetSurfRef                   *cuModuleGetSurfRef;\ntcuMemGetInfo                         *cuMemGetInfo;\ntcuMemAlloc                           *cuMemAlloc;\ntcuMemAllocPitch                      *cuMemAllocPitch;\ntcuMemFree                            *cuMemFree;\ntcuMemGetAddressRange                 *cuMemGetAddressRange;\ntcuMemAllocHost                       *cuMemAllocHost;\ntcuMemFreeHost                        *cuMemFreeHost;\ntcuMemHostAlloc                       *cuMemHostAlloc;\ntcuMemHostGetDevicePointer            *cuMemHostGetDevicePointer;\ntcuMemHostRegister                    *cuMemHostRegister;\ntcuMemHostUnregister                  *cuMemHostUnregister;\ntcuMemcpyHtoD                         *cuMemcpyHtoD;\ntcuMemcpyDtoH                         *cuMemcpyDtoH;\ntcuMemcpyDtoD                         *cuMemcpyDtoD;\ntcuMemcpyDtoA                         *cuMemcpyDtoA;\ntcuMemcpyAtoD                         *cuMemcpyAtoD;\ntcuMemcpyHtoA                         *cuMemcpyHtoA;\ntcuMemcpyAtoH                         *cuMemcpyAtoH;\ntcuMemcpyAtoA                         *cuMemcpyAtoA;\ntcuMemcpy2D                           *cuMemcpy2D;\ntcuMemcpy2DUnaligned                  *cuMemcpy2DUnaligned;\ntcuMemcpy3D                           *cuMemcpy3D;\ntcuMemcpyHtoDAsync                    *cuMemcpyHtoDAsync;\ntcuMemcpyDtoHAsync                    *cuMemcpyDtoHAsync;\ntcuMemcpyDtoDAsync                    *cuMemcpyDtoDAsync;\ntcuMemcpyHtoAAsync                    *cuMemcpyHtoAAsync;\ntcuMemcpyAtoHAsync                    *cuMemcpyAtoHAsync;\ntcuMemcpy2DAsync                      *cuMemcpy2DAsync;\ntcuMemcpy3DAsync                      *cuMemcpy3DAsync;\ntcuMemcpy                             *cuMemcpy;\ntcuMemcpyPeer                         *cuMemcpyPeer;\ntcuMemsetD8                           *cuMemsetD8;\ntcuMemsetD16                          *cuMemsetD16;\ntcuMemsetD32                          *cuMemsetD32;\ntcuMemsetD2D8                         *cuMemsetD2D8;\ntcuMemsetD2D16                        *cuMemsetD2D16;\ntcuMemsetD2D32                        *cuMemsetD2D32;\ntcuFuncSetBlockShape                  *cuFuncSetBlockShape;\ntcuFuncSetSharedSize                  *cuFuncSetSharedSize;\ntcuFuncGetAttribute                   *cuFuncGetAttribute;\ntcuFuncSetCacheConfig                 *cuFuncSetCacheConfig;\ntcuLaunchKernel                       *cuLaunchKernel;\ntcuArrayCreate                        *cuArrayCreate;\ntcuArrayGetDescriptor                 *cuArrayGetDescriptor;\ntcuArrayDestroy                       *cuArrayDestroy;\ntcuArray3DCreate                      *cuArray3DCreate;\ntcuArray3DGetDescriptor               *cuArray3DGetDescriptor;\ntcuTexRefCreate                       *cuTexRefCreate;\ntcuTexRefDestroy                      *cuTexRefDestroy;\ntcuTexRefSetArray                     *cuTexRefSetArray;\ntcuTexRefSetAddress                   *cuTexRefSetAddress;\ntcuTexRefSetAddress2D                 *cuTexRefSetAddress2D;\ntcuTexRefSetFormat                    *cuTexRefSetFormat;\ntcuTexRefSetAddressMode               *cuTexRefSetAddressMode;\ntcuTexRefSetFilterMode                *cuTexRefSetFilterMode;\ntcuTexRefSetFlags                     *cuTexRefSetFlags;\ntcuTexRefGetAddress                   *cuTexRefGetAddress;\ntcuTexRefGetArray                     *cuTexRefGetArray;\ntcuTexRefGetAddressMode               *cuTexRefGetAddressMode;\ntcuTexRefGetFilterMode                *cuTexRefGetFilterMode;\ntcuTexRefGetFormat                    *cuTexRefGetFormat;\ntcuTexRefGetFlags                     *cuTexRefGetFlags;\ntcuSurfRefSetArray                    *cuSurfRefSetArray;\ntcuSurfRefGetArray                    *cuSurfRefGetArray;\ntcuParamSetSize                       *cuParamSetSize;\ntcuParamSeti                          *cuParamSeti;\ntcuParamSetf                          *cuParamSetf;\ntcuParamSetv                          *cuParamSetv;\ntcuParamSetTexRef                     *cuParamSetTexRef;\ntcuLaunch                             *cuLaunch;\ntcuLaunchGrid                         *cuLaunchGrid;\ntcuLaunchGridAsync                    *cuLaunchGridAsync;\ntcuEventCreate                        *cuEventCreate;\ntcuEventRecord                        *cuEventRecord;\ntcuEventQuery                         *cuEventQuery;\ntcuEventSynchronize                   *cuEventSynchronize;\ntcuEventDestroy                       *cuEventDestroy;\ntcuEventElapsedTime                   *cuEventElapsedTime;\ntcuStreamCreate                       *cuStreamCreate;\ntcuStreamQuery                        *cuStreamQuery;\ntcuStreamSynchronize                  *cuStreamSynchronize;\ntcuStreamDestroy                      *cuStreamDestroy;\ntcuGraphicsUnregisterResource         *cuGraphicsUnregisterResource;\ntcuGraphicsSubResourceGetMappedArray  *cuGraphicsSubResourceGetMappedArray;\ntcuGraphicsResourceGetMappedPointer   *cuGraphicsResourceGetMappedPointer;\ntcuGraphicsResourceSetMapFlags        *cuGraphicsResourceSetMapFlags;\ntcuGraphicsMapResources               *cuGraphicsMapResources;\ntcuGraphicsUnmapResources             *cuGraphicsUnmapResources;\ntcuGetExportTable                     *cuGetExportTable;\ntcuCtxSetLimit                        *cuCtxSetLimit;\ntcuCtxGetLimit                        *cuCtxGetLimit;\ntcuMemHostGetFlags                    *cuMemHostGetFlags;\n\n#ifdef CUDA_INIT_D3D9\n// D3D9/CUDA interop (CUDA 1.x compatible API). These functions\n// are deprecated; please use the ones below\ntcuD3D9Begin                          *cuD3D9Begin;\ntcuD3D9End                            *cuD3DEnd;\ntcuD3D9RegisterVertexBuffer           *cuD3D9RegisterVertexBuffer;\ntcuD3D9MapVertexBuffer                *cuD3D9MapVertexBuffer;\ntcuD3D9UnmapVertexBuffer              *cuD3D9UnmapVertexBuffer;\ntcuD3D9UnregisterVertexBuffer         *cuD3D9UnregisterVertexBuffer;\n\n// D3D9/CUDA interop (CUDA 2.x compatible)\ntcuD3D9GetDirect3DDevice              *cuD3D9GetDirect3DDevice;\ntcuD3D9RegisterResource               *cuD3D9RegisterResource;\ntcuD3D9UnregisterResource             *cuD3D9UnregisterResource;\ntcuD3D9MapResources                   *cuD3D9MapResources;\ntcuD3D9UnmapResources                 *cuD3D9UnmapResources;\ntcuD3D9ResourceSetMapFlags            *cuD3D9ResourceSetMapFlags;\ntcuD3D9ResourceGetSurfaceDimensions   *cuD3D9ResourceGetSurfaceDimensions;\ntcuD3D9ResourceGetMappedArray         *cuD3D9ResourceGetMappedArray;\ntcuD3D9ResourceGetMappedPointer       *cuD3D9ResourceGetMappedPointer;\ntcuD3D9ResourceGetMappedSize          *cuD3D9ResourceGetMappedSize;\ntcuD3D9ResourceGetMappedPitch         *cuD3D9ResourceGetMappedPitch;\n\n// D3D9/CUDA interop (CUDA 2.0+)\ntcuD3D9GetDevice                      *cuD3D9GetDevice;\ntcuD3D9CtxCreate                      *cuD3D9CtxCreate;\ntcuGraphicsD3D9RegisterResource       *cuGraphicsD3D9RegisterResource;\n#endif\n\n#ifdef CUDA_INIT_D3D10\n// D3D10/CUDA interop (CUDA 3.0+)\ntcuD3D10GetDevice                     *cuD3D10GetDevice;\ntcuD3D10CtxCreate                     *cuD3D10CtxCreate;\ntcuGraphicsD3D10RegisterResource      *cuGraphicsD3D10RegisterResource;\n#endif\n\n\n#ifdef CUDA_INIT_D3D11\n// D3D11/CUDA interop (CUDA 3.0+)\ntcuD3D11GetDevice                     *cuD3D11GetDevice;\ntcuD3D11CtxCreate                     *cuD3D11CtxCreate;\ntcuGraphicsD3D11RegisterResource      *cuGraphicsD3D11RegisterResource;\n#endif\n\n// GL/CUDA interop\n#ifdef CUDA_INIT_OPENGL\ntcuGLCtxCreate                        *cuGLCtxCreate;\ntcuGraphicsGLRegisterBuffer           *cuGraphicsGLRegisterBuffer;\ntcuGraphicsGLRegisterImage            *cuGraphicsGLRegisterImage;\n#if defined(WIN32) || defined(_WIN32) || defined(WIN64) || defined(_WIN64)\ntcuWGLGetDevice                       *cuWGLGetDevice;\n#endif\n#endif\n\n#define STRINGIFY(X) #X\n\n#if defined(WIN32) || defined(_WIN32) || defined(WIN64) || defined(_WIN64)\n#include <Windows.h>\n\n#ifdef UNICODE\nstatic LPCWSTR __CudaLibName = L\"nvcuda.dll\";\n#else\nstatic LPCSTR __CudaLibName = \"nvcuda.dll\";\n#endif\n\ntypedef HMODULE CUDADRIVER;\n\nstatic CUresult LOAD_LIBRARY(CUDADRIVER *pInstance)\n{\n    *pInstance = LoadLibrary(__CudaLibName);\n\n    if (*pInstance == NULL)\n    {\n        printf(\"LoadLibrary \\\"%s\\\" failed!\\n\", __CudaLibName);\n        return CUDA_ERROR_UNKNOWN;\n    }\n\n    return CUDA_SUCCESS;\n}\n\n#define GET_PROC_EX(name, alias, required)                     \\\n    alias = (t##name *)GetProcAddress(CudaDrvLib, #name);               \\\n    if (alias == NULL && required) {                                    \\\n        printf(\"Failed to find required function \\\"%s\\\" in %s\\n\",       \\\n               #name, __CudaLibName);                                  \\\n        return CUDA_ERROR_UNKNOWN;                                      \\\n    }\n\n#define GET_PROC_EX_V2(name, alias, required)                           \\\n    alias = (t##name *)GetProcAddress(CudaDrvLib, STRINGIFY(name##_v2));\\\n    if (alias == NULL && required) {                                    \\\n        printf(\"Failed to find required function \\\"%s\\\" in %s\\n\",       \\\n               STRINGIFY(name##_v2), __CudaLibName);                       \\\n        return CUDA_ERROR_UNKNOWN;                                      \\\n    }\n\n#elif defined(__unix__) || defined(__APPLE__) || defined(__MACOSX)\n\n#include <dlfcn.h>\n\n#if defined(__APPLE__) || defined(__MACOSX)\nstatic char __CudaLibName[] = \"/usr/local/cuda/lib/libcuda.dylib\";\n#else\nstatic char __CudaLibName[] = \"libcuda.so\";\n#endif\n\ntypedef void *CUDADRIVER;\n\nstatic CUresult LOAD_LIBRARY(CUDADRIVER *pInstance)\n{\n    *pInstance = dlopen(__CudaLibName, RTLD_NOW);\n\n    if (*pInstance == NULL)\n    {\n        printf(\"dlopen \\\"%s\\\" failed!\\n\", __CudaLibName);\n        return CUDA_ERROR_UNKNOWN;\n    }\n\n    return CUDA_SUCCESS;\n}\n\n#define GET_PROC_EX(name, alias, required)                              \\\n    alias = (t##name *)dlsym(CudaDrvLib, #name);                        \\\n    if (alias == NULL && required) {                                    \\\n        printf(\"Failed to find required function \\\"%s\\\" in %s\\n\",       \\\n               #name, __CudaLibName);                                  \\\n        return CUDA_ERROR_UNKNOWN;                                      \\\n    }\n\n#define GET_PROC_EX_V2(name, alias, required)                           \\\n    alias = (t##name *)dlsym(CudaDrvLib, STRINGIFY(name##_v2));         \\\n    if (alias == NULL && required) {                                    \\\n        printf(\"Failed to find required function \\\"%s\\\" in %s\\n\",       \\\n               STRINGIFY(name##_v2), __CudaLibName);                    \\\n        return CUDA_ERROR_UNKNOWN;                                      \\\n    }\n\n#else\n#error unsupported platform\n#endif\n\n#define CHECKED_CALL(call)              \\\n    do {                                \\\n        CUresult result = (call);       \\\n        if (CUDA_SUCCESS != result) {   \\\n            return result;              \\\n        }                               \\\n    } while(0)\n\n#define GET_PROC_REQUIRED(name) GET_PROC_EX(name,name,1)\n#define GET_PROC_OPTIONAL(name) GET_PROC_EX(name,name,0)\n#define GET_PROC(name)          GET_PROC_REQUIRED(name)\n#define GET_PROC_V2(name)       GET_PROC_EX_V2(name,name,1)\n\nCUresult CUDAAPI cuInit(unsigned int Flags, int cudaVersion)\n{\n    CUDADRIVER CudaDrvLib;\n    int driverVer = 1000;\n\n    CHECKED_CALL(LOAD_LIBRARY(&CudaDrvLib));\n\n    // cuInit is required; alias it to _cuInit\n    GET_PROC_EX(cuInit, _cuInit, 1);\n    CHECKED_CALL(_cuInit(Flags));\n\n    // available since 2.2. if not present, version 1.0 is assumed\n    GET_PROC_OPTIONAL(cuDriverGetVersion);\n\n    if (cuDriverGetVersion)\n    {\n        CHECKED_CALL(cuDriverGetVersion(&driverVer));\n    }\n\n    // fetch all function pointers\n    GET_PROC(cuDeviceGet);\n    GET_PROC(cuDeviceGetCount);\n    GET_PROC(cuDeviceGetName);\n    GET_PROC(cuDeviceComputeCapability);\n    GET_PROC(cuDeviceGetProperties);\n    GET_PROC(cuDeviceGetAttribute);\n    GET_PROC(cuCtxDestroy);\n    GET_PROC(cuCtxAttach);\n    GET_PROC(cuCtxDetach);\n    GET_PROC(cuCtxPushCurrent);\n    GET_PROC(cuCtxPopCurrent);\n    GET_PROC(cuCtxGetDevice);\n    GET_PROC(cuCtxSynchronize);\n    GET_PROC(cuModuleLoad);\n    GET_PROC(cuModuleLoadData);\n    GET_PROC(cuModuleUnload);\n    GET_PROC(cuModuleGetFunction);\n    GET_PROC(cuModuleGetTexRef);\n    GET_PROC(cuMemFreeHost);\n    GET_PROC(cuMemHostAlloc);\n    GET_PROC(cuFuncSetBlockShape);\n    GET_PROC(cuFuncSetSharedSize);\n    GET_PROC(cuFuncGetAttribute);\n    GET_PROC(cuArrayDestroy);\n    GET_PROC(cuTexRefCreate);\n    GET_PROC(cuTexRefDestroy);\n    GET_PROC(cuTexRefSetArray);\n    GET_PROC(cuTexRefSetFormat);\n    GET_PROC(cuTexRefSetAddressMode);\n    GET_PROC(cuTexRefSetFilterMode);\n    GET_PROC(cuTexRefSetFlags);\n    GET_PROC(cuTexRefGetArray);\n    GET_PROC(cuTexRefGetAddressMode);\n    GET_PROC(cuTexRefGetFilterMode);\n    GET_PROC(cuTexRefGetFormat);\n    GET_PROC(cuTexRefGetFlags);\n    GET_PROC(cuParamSetSize);\n    GET_PROC(cuParamSeti);\n    GET_PROC(cuParamSetf);\n    GET_PROC(cuParamSetv);\n    GET_PROC(cuParamSetTexRef);\n    GET_PROC(cuLaunch);\n    GET_PROC(cuLaunchGrid);\n    GET_PROC(cuLaunchGridAsync);\n    GET_PROC(cuEventCreate);\n    GET_PROC(cuEventRecord);\n    GET_PROC(cuEventQuery);\n    GET_PROC(cuEventSynchronize);\n    GET_PROC(cuEventDestroy);\n    GET_PROC(cuEventElapsedTime);\n    GET_PROC(cuStreamCreate);\n    GET_PROC(cuStreamQuery);\n    GET_PROC(cuStreamSynchronize);\n    GET_PROC(cuStreamDestroy);\n\n    // These could be _v2 interfaces\n    if (cudaVersion >= 4000 && __CUDA_API_VERSION >= 4000)\n    {\n        GET_PROC_V2(cuCtxDestroy);\n        GET_PROC_V2(cuCtxPopCurrent);\n        GET_PROC_V2(cuCtxPushCurrent);\n        GET_PROC_V2(cuStreamDestroy);\n        GET_PROC_V2(cuEventDestroy);\n    }\n\n    if (cudaVersion >= 3020 && __CUDA_API_VERSION >= 3020)\n    {\n        GET_PROC_V2(cuDeviceTotalMem);\n        GET_PROC_V2(cuCtxCreate);\n        GET_PROC_V2(cuModuleGetGlobal);\n        GET_PROC_V2(cuMemGetInfo);\n        GET_PROC_V2(cuMemAlloc);\n        GET_PROC_V2(cuMemAllocPitch);\n        GET_PROC_V2(cuMemFree);\n        GET_PROC_V2(cuMemGetAddressRange);\n        GET_PROC_V2(cuMemAllocHost);\n        GET_PROC_V2(cuMemHostGetDevicePointer);\n        GET_PROC_V2(cuMemcpyHtoD);\n        GET_PROC_V2(cuMemcpyDtoH);\n        GET_PROC_V2(cuMemcpyDtoD);\n        GET_PROC_V2(cuMemcpyDtoA);\n        GET_PROC_V2(cuMemcpyAtoD);\n        GET_PROC_V2(cuMemcpyHtoA);\n        GET_PROC_V2(cuMemcpyAtoH);\n        GET_PROC_V2(cuMemcpyAtoA);\n        GET_PROC_V2(cuMemcpy2D);\n        GET_PROC_V2(cuMemcpy2DUnaligned);\n        GET_PROC_V2(cuMemcpy3D);\n        GET_PROC_V2(cuMemcpyHtoDAsync);\n        GET_PROC_V2(cuMemcpyDtoHAsync);\n        GET_PROC_V2(cuMemcpyHtoAAsync);\n        GET_PROC_V2(cuMemcpyAtoHAsync);\n        GET_PROC_V2(cuMemcpy2DAsync);\n        GET_PROC_V2(cuMemcpy3DAsync);\n        GET_PROC_V2(cuMemsetD8);\n        GET_PROC_V2(cuMemsetD16);\n        GET_PROC_V2(cuMemsetD32);\n        GET_PROC_V2(cuMemsetD2D8);\n        GET_PROC_V2(cuMemsetD2D16);\n        GET_PROC_V2(cuMemsetD2D32);\n        GET_PROC_V2(cuArrayCreate);\n        GET_PROC_V2(cuArrayGetDescriptor);\n        GET_PROC_V2(cuArray3DCreate);\n        GET_PROC_V2(cuArray3DGetDescriptor);\n        GET_PROC_V2(cuTexRefSetAddress);\n        GET_PROC_V2(cuTexRefSetAddress2D);\n        GET_PROC_V2(cuTexRefGetAddress);\n    }\n    else\n    {\n        GET_PROC(cuDeviceTotalMem);\n        GET_PROC(cuCtxCreate);\n        GET_PROC(cuModuleGetGlobal);\n        GET_PROC(cuMemGetInfo);\n        GET_PROC(cuMemAlloc);\n        GET_PROC(cuMemAllocPitch);\n        GET_PROC(cuMemFree);\n        GET_PROC(cuMemGetAddressRange);\n        GET_PROC(cuMemAllocHost);\n        GET_PROC(cuMemHostGetDevicePointer);\n        GET_PROC(cuMemcpyHtoD);\n        GET_PROC(cuMemcpyDtoH);\n        GET_PROC(cuMemcpyDtoD);\n        GET_PROC(cuMemcpyDtoA);\n        GET_PROC(cuMemcpyAtoD);\n        GET_PROC(cuMemcpyHtoA);\n        GET_PROC(cuMemcpyAtoH);\n        GET_PROC(cuMemcpyAtoA);\n        GET_PROC(cuMemcpy2D);\n        GET_PROC(cuMemcpy2DUnaligned);\n        GET_PROC(cuMemcpy3D);\n        GET_PROC(cuMemcpyHtoDAsync);\n        GET_PROC(cuMemcpyDtoHAsync);\n        GET_PROC(cuMemcpyHtoAAsync);\n        GET_PROC(cuMemcpyAtoHAsync);\n        GET_PROC(cuMemcpy2DAsync);\n        GET_PROC(cuMemcpy3DAsync);\n        GET_PROC(cuMemsetD8);\n        GET_PROC(cuMemsetD16);\n        GET_PROC(cuMemsetD32);\n        GET_PROC(cuMemsetD2D8);\n        GET_PROC(cuMemsetD2D16);\n        GET_PROC(cuMemsetD2D32);\n        GET_PROC(cuArrayCreate);\n        GET_PROC(cuArrayGetDescriptor);\n        GET_PROC(cuArray3DCreate);\n        GET_PROC(cuArray3DGetDescriptor);\n        GET_PROC(cuTexRefSetAddress);\n        GET_PROC(cuTexRefSetAddress2D);\n        GET_PROC(cuTexRefGetAddress);\n    }\n\n    // The following functions are specific to CUDA versions\n    if (driverVer >= 2010)\n    {\n        GET_PROC(cuModuleLoadDataEx);\n        GET_PROC(cuModuleLoadFatBinary);\n#ifdef CUDA_INIT_OPENGL\n        GET_PROC(cuGLCtxCreate);\n        GET_PROC(cuGraphicsGLRegisterBuffer);\n        GET_PROC(cuGraphicsGLRegisterImage);\n#  ifdef WIN32\n        GET_PROC(cuWGLGetDevice);\n#  endif\n#endif\n#ifdef CUDA_INIT_D3D9\n        GET_PROC(cuD3D9GetDevice);\n        GET_PROC(cuD3D9CtxCreate);\n        GET_PROC(cuGraphicsD3D9RegisterResource);\n#endif\n    }\n\n    if (driverVer >= 2030)\n    {\n        GET_PROC(cuMemHostGetFlags);\n#ifdef CUDA_INIT_D3D10\n        GET_PROC(cuD3D10GetDevice);\n        GET_PROC(cuD3D10CtxCreate);\n        GET_PROC(cuGraphicsD3D10RegisterResource);\n#endif\n#ifdef CUDA_INIT_OPENGL\n        GET_PROC(cuGraphicsGLRegisterBuffer);\n        GET_PROC(cuGraphicsGLRegisterImage);\n#endif\n    }\n\n    if (driverVer >= 3000)\n    {\n        GET_PROC(cuMemcpyDtoDAsync);\n        GET_PROC(cuFuncSetCacheConfig);\n#ifdef CUDA_INIT_D3D11\n        GET_PROC(cuD3D11GetDevice);\n        GET_PROC(cuD3D11CtxCreate);\n        GET_PROC(cuGraphicsD3D11RegisterResource);\n#endif\n        GET_PROC(cuGraphicsUnregisterResource);\n        GET_PROC(cuGraphicsSubResourceGetMappedArray);\n\n        if (cudaVersion >= 3020 && __CUDA_API_VERSION >= 3020)\n        {\n            GET_PROC_V2(cuGraphicsResourceGetMappedPointer);\n        }\n        else\n        {\n            GET_PROC(cuGraphicsResourceGetMappedPointer);\n        }\n\n        GET_PROC(cuGraphicsResourceSetMapFlags);\n        GET_PROC(cuGraphicsMapResources);\n        GET_PROC(cuGraphicsUnmapResources);\n        GET_PROC(cuGetExportTable);\n    }\n\n    if (driverVer >= 3010)\n    {\n        GET_PROC(cuModuleGetSurfRef);\n        GET_PROC(cuSurfRefSetArray);\n        GET_PROC(cuSurfRefGetArray);\n        GET_PROC(cuCtxSetLimit);\n        GET_PROC(cuCtxGetLimit);\n    }\n\n    if (driverVer >= 4000)\n    {\n        GET_PROC(cuCtxSetCurrent);\n        GET_PROC(cuCtxGetCurrent);\n        GET_PROC(cuMemHostRegister);\n        GET_PROC(cuMemHostUnregister);\n        GET_PROC(cuMemcpy);\n        GET_PROC(cuMemcpyPeer);\n        GET_PROC(cuLaunchKernel);\n    }\n\n    return CUDA_SUCCESS;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-raft-develop-avjrki7w7nqtdsid6ntx6dnvvlhhkxqd/spack-src/src/pipeline/.raft_pipeline_processingFunctions.cu.swp",
        "/tmp/vanessa/spack-stage/spack-stage-raft-develop-avjrki7w7nqtdsid6ntx6dnvvlhhkxqd/spack-src/.git/objects/pack/pack-3da29a948fec79c8add10a816ea91f08dacdf10f.pack",
        "/tmp/vanessa/spack-stage/spack-stage-raft-develop-avjrki7w7nqtdsid6ntx6dnvvlhhkxqd/spack-src/.git/objects/pack/pack-3da29a948fec79c8add10a816ea91f08dacdf10f.idx"
    ],
    "total_files": 112
}