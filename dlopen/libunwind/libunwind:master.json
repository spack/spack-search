{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libunwind-master-dwt2qxx3j4hnf4kmav7v6l2hhs5xwxbz/spack-src/configure.ac": "define(pkg_major, 1)\ndefine(pkg_minor, 5)\ndefine(pkg_extra, -rc1)\ndefine(pkg_maintainer, libunwind-devel@nongnu.org)\ndefine(mkvers, $1.$2$3)\ndnl Process this file with autoconf to produce a configure script.\nAC_INIT([libunwind],[mkvers(pkg_major, pkg_minor, pkg_extra)],[pkg_maintainer])\nAC_CONFIG_SRCDIR(src/mi/backtrace.c)\nAC_CONFIG_AUX_DIR(config)\nAC_CANONICAL_TARGET\nAM_INIT_AUTOMAKE([1.6 subdir-objects])\nAM_MAINTAINER_MODE\nAC_CONFIG_HEADERS([include/config.h])\n\ndnl Checks for programs.\nAC_PROG_CC\nAC_PROG_CXX\nAC_PROG_INSTALL\nAC_PROG_MAKE_SET\nm4_ifdef([AM_PROG_AR], [AM_PROG_AR])\nLT_INIT\nAM_PROG_AS\nAM_PROG_CC_C_O\n\ndnl Checks for libraries.\nAC_CHECK_LIB(uca, __uc_get_grs)\nOLD_LIBS=${LIBS}\nAC_SEARCH_LIBS(dlopen, dl)\nLIBS=${OLD_LIBS}\ncase \"$ac_cv_search_dlopen\" in\n  -l*) DLLIB=$ac_cv_search_dlopen;;\n  *) DLLIB=\"\";;\nesac\n\ndnl Checks for header files.\nAC_HEADER_STDC\nAC_CHECK_HEADERS(asm/ptrace_offsets.h endian.h sys/endian.h sys/param.h \\\n\t\texecinfo.h ia64intrin.h sys/uc_access.h unistd.h signal.h sys/types.h \\\n\t\tsys/procfs.h sys/ptrace.h sys/syscall.h byteswap.h elf.h sys/elf.h \\\n\t\tlink.h sys/link.h)\n\ndnl Checks for typedefs, structures, and compiler characteristics.\nAC_C_CONST\nAC_C_INLINE\nAC_TYPE_SIZE_T\nAC_CHECK_SIZEOF(off_t)\n\nCPPFLAGS=\"${CPPFLAGS} -D_GNU_SOURCE\"\n\nAC_CHECK_MEMBERS([struct dl_phdr_info.dlpi_subs],,,[#include <link.h>])\nAC_CHECK_TYPES([struct elf_prstatus, struct prstatus], [], [],\n[$ac_includes_default\n#if HAVE_SYS_PROCFS_H\n# include <sys/procfs.h>\n#endif\n])\n\nAC_CHECK_DECLS([PTRACE_POKEUSER, PTRACE_POKEDATA, PTRACE_SETREGSET,\nPTRACE_TRACEME, PTRACE_CONT, PTRACE_SINGLESTEP,\nPTRACE_SYSCALL, PT_IO, PT_GETREGS,\nPT_GETFPREGS, PT_CONTINUE, PT_TRACE_ME,\nPT_STEP, PT_SYSCALL], [], [],\n[$ac_includes_default\n#if HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#include <sys/ptrace.h>\n])\n\ndnl Checks for library functions.\nAC_CHECK_FUNCS(dl_iterate_phdr dl_phdr_removals_counter dlmodinfo getunwind \\\n\t\tttrace mincore pipe2)\n\nAC_MSG_CHECKING([if building with AltiVec])\nAC_COMPILE_IFELSE([AC_LANG_SOURCE([[\n#ifndef __ALTIVEC__\n# error choke\n#endif\n]])], [use_altivec=yes],[use_altivec=no])\nAM_CONDITIONAL(USE_ALTIVEC, [test x$use_altivec = xyes])\nAC_MSG_RESULT([$use_altivec])\n\nAC_COMPILE_IFELSE([AC_LANG_SOURCE([[\n#ifndef __powerpc64__\n# error choke\n#endif\n]])], [ppc_bits=64], [ppc_bits=32])\n\nAC_DEFUN([SET_ARCH],[\n    AS_CASE([$1],\n        [aarch64*],[$2=aarch64],\n        [arm*],[$2=arm],\n        [i?86],[$2=x86],\n        [hppa*],[$2=hppa],\n        [mips*],[$2=mips],\n        [powerpc*],[$2=ppc$ppc_bits],\n        [sh*],[$2=sh],\n        [amd64],[$2=x86_64],\n        [tile*],[$2=tilegx],\n        [$2=$1])\n]) dnl SET_ARCH\n\nSET_ARCH([$build_cpu],[build_arch])\nSET_ARCH([$host_cpu],[host_arch])\nSET_ARCH([$target_cpu],[target_arch])\n\n# Check for Android\nAC_MSG_CHECKING([for Android])\nandroid=\"no\"\ncase \"$host_os\" in\n  *android*)\n    android=\"yes\"\n    AC_MSG_RESULT([yes])\n    ;;\n  *)\n    AC_MSG_RESULT([no])\n    ;;\nesac\n\nAC_ARG_ENABLE(coredump,\n\tAS_HELP_STRING([--enable-coredump],[building libunwind-coredump library]),,\n        [AS_CASE([$host_arch], [aarch64*|arm*|mips*|sh*|x86*|tile*], [enable_coredump=yes], [enable_coredump=no])]\n)\n\nAC_MSG_CHECKING([if we should build libunwind-coredump])\nAC_MSG_RESULT([$enable_coredump])\n\nAC_ARG_ENABLE(ptrace,\n\tAS_HELP_STRING([--enable-ptrace],[building libunwind-ptrace library]),,\n        [AC_CHECK_HEADER([sys/ptrace.h], [enable_ptrace=yes], [enable_ptrace=no])]\n)\n\nAC_MSG_CHECKING([if we should build libunwind-ptrace])\nAC_MSG_RESULT([$enable_ptrace])\n\nAC_ARG_ENABLE(setjmp,\n\tAS_HELP_STRING([--enable-setjmp],[building libunwind-setjmp library]),,\n        [AS_IF([test x$target_arch == x$host_arch], [enable_setjmp=yes], [enable_setjmp=no])]\n)\n\nAC_ARG_ENABLE(documentation,\n\tAS_HELP_STRING([--disable-documentation],[Disable generating the man pages]),,\n\t[enable_documentation=yes])\n\nAC_ARG_ENABLE(tests,\n AS_HELP_STRING([--disable-tests],[Disable tests build]),,\n [enable_tests=yes])\n\nAC_ARG_ENABLE(weak-backtrace,\n AS_HELP_STRING([--disable-weak-backtrace],[Do not provide the weak 'backtrace' symbol.]),,\n [enable_weak_backtrace=yes])\n\nAC_ARG_ENABLE(unwind-header,\n AS_HELP_STRING([--disable-unwind-header],[Do not export the 'unwind.h' header]),,\n [enable_unwind_header=yes])\n\nAC_MSG_CHECKING([if we should export unwind.h])\nAC_MSG_RESULT([$enable_unwind_header])\n\nAC_MSG_CHECKING([if we should build libunwind-setjmp])\nAC_MSG_RESULT([$enable_setjmp])\n\nAC_MSG_CHECKING([for build architecture])\nAC_MSG_RESULT([$build_arch])\nAC_MSG_CHECKING([for host architecture])\nAC_MSG_RESULT([$host_arch])\nAC_MSG_CHECKING([for target architecture])\nAC_MSG_RESULT([$target_arch])\nAC_MSG_CHECKING([for target operating system])\nAC_MSG_RESULT([$target_os])\n\nAM_CONDITIONAL(BUILD_COREDUMP, test x$enable_coredump = xyes)\nAM_CONDITIONAL(BUILD_PTRACE, test x$enable_ptrace = xyes)\nAM_CONDITIONAL(BUILD_SETJMP, test x$enable_setjmp = xyes)\nAM_CONDITIONAL(BUILD_UNWIND_HEADER, test \"x$enable_unwind_header\" = xyes)\nAM_CONDITIONAL(NO_PTRACE_TEST, test x$build_arch != x$host_arch)\nAM_CONDITIONAL(REMOTE_ONLY, test x$target_arch != x$host_arch)\nAM_CONDITIONAL(ARCH_AARCH64, test x$target_arch = xaarch64)\nAM_CONDITIONAL(ARCH_ARM, test x$target_arch = xarm)\nAM_CONDITIONAL(ARCH_IA64, test x$target_arch = xia64)\nAM_CONDITIONAL(ARCH_HPPA, test x$target_arch = xhppa)\nAM_CONDITIONAL(ARCH_MIPS, test x$target_arch = xmips)\nAM_CONDITIONAL(ARCH_X86, test x$target_arch = xx86)\nAM_CONDITIONAL(ARCH_X86_64, test x$target_arch = xx86_64)\nAM_CONDITIONAL(ARCH_PPC32, test x$target_arch = xppc32)\nAM_CONDITIONAL(ARCH_PPC64, test x$target_arch = xppc64)\nAM_CONDITIONAL(ARCH_SH, test x$target_arch = xsh)\nAM_CONDITIONAL(ARCH_TILEGX, test x$target_arch = xtilegx)\nAM_CONDITIONAL(ARCH_S390X, test x$target_arch = xs390x)\nAM_CONDITIONAL(OS_LINUX, expr x$target_os : xlinux >/dev/null)\nAM_CONDITIONAL(OS_HPUX, expr x$target_os : xhpux >/dev/null)\nAM_CONDITIONAL(OS_FREEBSD, expr x$target_os : xfreebsd >/dev/null)\nAM_CONDITIONAL(OS_QNX, expr x$target_os : xnto-qnx >/dev/null)\nAM_CONDITIONAL(OS_SOLARIS, expr x$target_os : xsolaris >/dev/null)\n\nAC_MSG_CHECKING([for ELF helper width])\ncase \"${target_arch}\" in\n(arm|hppa|ppc32|x86|sh) use_elf32=yes; AC_MSG_RESULT([32]);;\n(aarch64|ia64|ppc64|x86_64|s390x|tilegx)  use_elf64=yes; AC_MSG_RESULT([64]);;\n(mips)                 use_elfxx=yes; AC_MSG_RESULT([xx]);;\n*)                     AC_MSG_ERROR([Unknown ELF target: ${target_arch}])\nesac\nAM_CONDITIONAL(USE_ELF32, [test x$use_elf32 = xyes])\nAM_CONDITIONAL(USE_ELF64, [test x$use_elf64 = xyes])\nAM_CONDITIONAL(USE_ELFXX, [test x$use_elfxx = xyes])\n\nAC_MSG_CHECKING([whether to include DWARF support])\nif test x$target_arch != xia64; then\n  use_dwarf=yes\nelse\n  use_dwarf=no\nfi\nAM_CONDITIONAL(USE_DWARF, [test x$use_dwarf = xyes])\nAC_MSG_RESULT([$use_dwarf])\n\nif test x$target_arch = xppc64; then\n        libdir='${exec_prefix}/lib64'\n        AC_MSG_NOTICE([PowerPC64 detected, lib will be installed ${libdir}]);\n        AC_SUBST([libdir])\nfi\n\nAC_MSG_CHECKING([whether to restrict build to remote support])\nif test x$target_arch != x$host_arch; then\n  CPPFLAGS=\"${CPPFLAGS} -DUNW_REMOTE_ONLY\"\n  remote_only=yes\nelse\n  remote_only=no\nfi\nAC_MSG_RESULT([$remote_only])\n\nAC_MSG_CHECKING([whether to enable debug support])\nAC_ARG_ENABLE(debug,\nAS_HELP_STRING([--enable-debug],[turn on debug support (slows down execution)]))\nif test x$enable_debug = xyes; then\n  CPPFLAGS=\"${CPPFLAGS} -DDEBUG\"\nelse\n  CPPFLAGS=\"${CPPFLAGS} -DNDEBUG\"\nfi\nAC_MSG_RESULT([$enable_debug])\n\nAC_MSG_CHECKING([whether to enable C++ exception support])\nAC_ARG_ENABLE(cxx_exceptions,\nAS_HELP_STRING([--enable-cxx-exceptions],[use libunwind to handle C++ exceptions]),,\n[\n# C++ exception handling doesn't work too well on x86\ncase $target_arch in\n  x86*) enable_cxx_exceptions=no;;\n  aarch64*) enable_cxx_exceptions=no;;\n  arm*) enable_cxx_exceptions=no;;\n  mips*) enable_cxx_exceptions=no;;\n  tile*) enable_cxx_exceptions=no;;\n  *) enable_cxx_exceptions=yes;;\nesac\n])\n\nAM_CONDITIONAL([SUPPORT_CXX_EXCEPTIONS], [test x$enable_cxx_exceptions = xyes])\nAC_MSG_RESULT([$enable_cxx_exceptions])\n\nAC_MSG_CHECKING([whether to load .debug_frame sections])\nAC_ARG_ENABLE(debug_frame,\nAS_HELP_STRING([--enable-debug-frame],[Load the \".debug_frame\" section if available]),, [\ncase \"${target_arch}\" in\n  (arm) enable_debug_frame=yes;;\n  (aarch64) enable_debug_frame=yes;;\n  (*)   enable_debug_frame=no;;\nesac])\nif test x$enable_debug_frame = xyes; then\n  AC_DEFINE([CONFIG_DEBUG_FRAME], [], [Enable Debug Frame])\nfi\nAC_MSG_RESULT([$enable_debug_frame])\n\nAC_MSG_CHECKING([whether to block signals during mutex ops])\nAC_ARG_ENABLE(block_signals,\nAS_HELP_STRING([--enable-block-signals],[Block signals before performing mutex operations]),,\n[enable_block_signals=yes])\nif test x$enable_block_signals = xyes; then\n  AC_DEFINE([CONFIG_BLOCK_SIGNALS], [], [Block signals before mutex operations])\nfi\nAC_MSG_RESULT([$enable_block_signals])\n\nAC_MSG_CHECKING([whether to validate memory addresses before use])\nAC_ARG_ENABLE(conservative_checks,\nAS_HELP_STRING([--enable-conservative-checks],[Validate all memory addresses before use]),,\n[enable_conservative_checks=yes])\nif test x$enable_conservative_checks = xyes; then\n  AC_DEFINE(CONSERVATIVE_CHECKS, 1,\n\t[Define to 1 if you want every memory access validated])\nfi\nAC_MSG_RESULT([$enable_conservative_checks])\n\nAC_MSG_CHECKING([whether to enable msabi support])\nAC_ARG_ENABLE(msabi_support,\nAS_HELP_STRING([--enable-msabi-support],[Enables support for Microsoft ABI extensions]))\nif test x$enable_msabi_support = xyes; then\n  AC_DEFINE([CONFIG_MSABI_SUPPORT], [], [Support for Microsoft ABI extensions])\nfi\nAC_MSG_RESULT([$enable_msabi_support])\n\nLIBLZMA=\nAC_MSG_CHECKING([whether to support LZMA-compressed symbol tables])\nAC_ARG_ENABLE(minidebuginfo,\nAS_HELP_STRING([--enable-minidebuginfo], [Enables support for LZMA-compressed symbol tables]),, [enable_minidebuginfo=auto])\nAC_MSG_RESULT([$enable_minidebuginfo])\nif test x$enable_minidebuginfo != xno; then\n   AC_CHECK_LIB([lzma], [lzma_mf_is_supported],\n   [LIBLZMA=-llzma\n    AC_DEFINE([HAVE_LZMA], [1], [Define if you have liblzma])\n    enable_minidebuginfo=yes],\n   [if test x$enable_minidebuginfo = xyes; then\n      AC_MSG_FAILURE([liblzma not found])\n    fi])\nfi\nAC_SUBST([LIBLZMA])\nAM_CONDITIONAL(HAVE_LZMA, test x$enable_minidebuginfo = xyes)\n\nLIBZ=\nAC_MSG_CHECKING([whether to support ZLIB-compressed symbol tables])\nAC_ARG_ENABLE(zlibdebuginfo,\nAS_HELP_STRING([--enable-zlibdebuginfo], [Enables support for ZLIB-compressed symbol tables]),, [enable_zlibdebuginfo=auto])\nAC_MSG_RESULT([$enable_zlibdebuginfo])\nif test x$enable_zlibdebuginfo != xno; then\n   AC_CHECK_LIB([z], [uncompress],\n   [LIBZ=-lz\n    AC_DEFINE([HAVE_ZLIB], [1], [Define if you have libz])\n    enable_zlibdebuginfo=yes],\n   [if test x$enable_zlibdebuginfo = xyes; then\n      AC_MSG_FAILURE([libz not found])\n    fi])\nfi\nAC_SUBST([LIBZ])\nAM_CONDITIONAL(HAVE_ZLIB, test x$enable_zlibdebuginfo = xyes)\n\nAC_MSG_CHECKING([whether to support UNW_CACHE_PER_THREAD])\nAC_ARG_ENABLE([per-thread-cache],\nAS_HELP_STRING([--enable-per-thread-cache], [build with support for UNW_CACHE_PER_THREAD (which imposes a hight TLS memory usage) (default: disabled)]))\nAC_MSG_RESULT([$enable_per_thread_cache])\nAS_IF([test x$enable_per_thread_cache = xyes], [\n  AC_DEFINE(HAVE___CACHE_PER_THREAD, 1,\n\t[Define to 1 if --enable-per-thread-cache])\n])\n\nAC_MSG_CHECKING([for Intel compiler])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[#ifndef __INTEL_COMPILER\n#error choke me\n#endif]])],[intel_compiler=yes],[intel_compiler=no])\n\nif test x$GCC = xyes -a x$intel_compiler != xyes; then\n  CFLAGS=\"${CFLAGS} -fexceptions -Wall -Wsign-compare\"\nfi\nAC_MSG_RESULT([$intel_compiler])\n\nAC_MSG_CHECKING([if building on Solaris then define __EXTENSIONS__ macro])\nif $OS_SOLARIS; then\n  CFLAGS=\"${CFLAGS} -D__EXTENSIONS__\"\n  AC_MSG_RESULT([yes])\nelse\n  AC_MSG_RESULT([no])\nfi\n\nAC_MSG_CHECKING([for QCC compiler])\nAS_CASE([$CC], [qcc*|QCC*], [qcc_compiler=yes], [qcc_compiler=no])\nAC_MSG_RESULT([$qcc_compiler])\n\nif test x$intel_compiler = xyes; then\n  AC_MSG_CHECKING([if linker supports -static-libcxa])\n  save_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS -static-libcxa\"\n  AC_LINK_IFELSE([AC_LANG_PROGRAM([[]], [[]])],[have_static_libcxa=yes],[have_static_libcxa=no])\n  LDFLAGS=\"$save_LDFLAGS\"\n  if test \"x$have_static_libcxa\" = xyes; then\n    LDFLAGS_STATIC_LIBCXA=\"-XCClinker -static-libcxa\"\n  fi\n  AC_MSG_RESULT([$have_static_libcxa])\nfi\n\nif test x$qcc_compiler = xyes; then\n    LDFLAGS_NOSTARTFILES=\"-XCClinker -Wc,-nostartfiles\"\nelse\n    LDFLAGS_NOSTARTFILES=\"-XCClinker -nostartfiles\"\nfi\n\nif test x$GCC = xyes -a x$intel_compiler != xyes -a x$qcc_compiler != xyes -a x$android != xyes; then\n  LIBCRTS=\"-lgcc_s\"\nfi\n\nAC_MSG_CHECKING([for __builtin___clear_cache])\nAC_LINK_IFELSE(\n  [AC_LANG_PROGRAM([[]], [[__builtin___clear_cache(0, 0)]])],\n  [have__builtin___clear_cache=yes],\n  [have__builtin___clear_cache=no])\nif test x$have__builtin___clear_cache = xyes; then\n  AC_DEFINE([HAVE__BUILTIN___CLEAR_CACHE], [1],\n            [Defined if __builtin___clear_cache() is available])\nfi\nAC_MSG_RESULT([$have__builtin___clear_cache])\n\nAC_MSG_CHECKING([for __builtin_unreachable])\nAC_LINK_IFELSE(\n  [AC_LANG_PROGRAM([[]], [[__builtin_unreachable()]])],\n  [have__builtin_unreachable=yes],\n  [have__builtin_unreachable=no])\nif test x$have__builtin_unreachable = xyes; then\n  AC_DEFINE([HAVE__BUILTIN_UNREACHABLE], [1],\n            [Defined if __builtin_unreachable() is available])\nfi\nAC_MSG_RESULT([$have__builtin_unreachable])\n\nCCASFLAGS=\"${CCASFLAGS} ${CPPFLAGS}\"\n\narch=\"$target_arch\"\nARCH=`echo $target_arch | tr [a-z] [A-Z]`\n\ndnl create shell variables from the M4 macros:\nPKG_MAJOR=pkg_major\nPKG_MINOR=pkg_minor\nPKG_EXTRA=pkg_extra\nPKG_MAINTAINER=pkg_maintainer\n\nold_LIBS=\"$LIBS\"\nLIBS=\"\"\nAC_SEARCH_LIBS(backtrace, execinfo)\nLIBS=\"$old_LIBS\"\ncase \"$ac_cv_search_backtrace\" in\n  -l*) BACKTRACELIB=$ac_cv_search_backtrace;;\n  *) BACKTRACELIB=\"\";;\nesac\n\n\nAC_SUBST(build_arch)\nAC_SUBST(target_os)\nAC_SUBST(arch)\nAC_SUBST(ARCH)\nAC_SUBST(LDFLAGS_STATIC_LIBCXA)\nAC_SUBST(LDFLAGS_NOSTARTFILES)\nAC_SUBST(LIBCRTS)\nAC_SUBST(PKG_MAJOR)\nAC_SUBST(PKG_MINOR)\nAC_SUBST(PKG_EXTRA)\nAC_SUBST(PKG_MAINTAINER)\nAC_SUBST(enable_cxx_exceptions)\nAC_SUBST(enable_debug_frame)\nAC_SUBST(DLLIB)\nAC_SUBST(BACKTRACELIB)\n\nAC_PATH_PROG([LATEX2MAN],[latex2man])\nif test \"x$LATEX2MAN\" = \"x\"; then\n  AC_MSG_WARN([latex2man not found. Install latex2man. Disabling docs.])\n  enable_documentation=\"no\";\nfi\n\nAM_CONDITIONAL([CONFIG_DOCS], [test x$enable_documentation = xyes])\nif test \"x$enable_documentation\" = \"xyes\"; then\n  AC_CONFIG_FILES(doc/Makefile doc/common.tex)\nfi\n\nAM_CONDITIONAL([CONFIG_TESTS], [test x$enable_tests = xyes])\nif test \"x$enable_tests\" = \"xyes\"; then\n  AC_CONFIG_FILES(tests/Makefile tests/check-namespace.sh)\nfi\n\nAM_CONDITIONAL([CONFIG_WEAK_BACKTRACE], [test \"x$enable_weak_backtrace\" = xyes])\nAM_COND_IF([CONFIG_WEAK_BACKTRACE], [\n  AC_DEFINE([CONFIG_WEAK_BACKTRACE], [1], [Define if the weak 'backtrace' symbol is provided.])\n])\n\nAC_CONFIG_FILES(Makefile src/Makefile\n                include/libunwind-common.h\n                include/libunwind.h include/tdep/libunwind_i.h)\nAC_CONFIG_FILES(src/unwind/libunwind.pc src/coredump/libunwind-coredump.pc\n                src/ptrace/libunwind-ptrace.pc src/setjmp/libunwind-setjmp.pc\n                src/libunwind-generic.pc)\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-libunwind-master-dwt2qxx3j4hnf4kmav7v6l2hhs5xwxbz/spack-src/doc/libunwind-dynamic.tex": "\\documentclass{article}\n\\usepackage[fancyhdr,pdf]{latex2man}\n\n\\input{common.tex}\n\n\\begin{document}\n\n\\begin{Name}{3}{libunwind-dynamic}{David Mosberger-Tang}{Programming Library}{Introduction to dynamic unwind-info}libunwind-dynamic -- libunwind-support for runtime-generated code\n\\end{Name}\n\n\\section{Introduction}\n\nFor \\Prog{libunwind} to do its job, it needs to be able to reconstruct\nthe \\emph{frame state} of each frame in a call-chain.  The frame state\ndescribes the subset of the machine-state that consists of the\n\\emph{frame registers} (typically the instruction-pointer and the\nstack-pointer) and all callee-saved registers (preserved registers).\nThe frame state describes each register either by providing its\ncurrent value (for frame registers) or by providing the location at\nwhich the current value is stored (callee-saved registers).\n\nFor statically generated code, the compiler normally takes care of\nemitting \\emph{unwind-info} which provides the minimum amount of\ninformation needed to reconstruct the frame-state for each instruction\nin a procedure.  For dynamically generated code, the runtime code\ngenerator must use the dynamic unwind-info interface provided by\n\\Prog{libunwind} to supply the equivalent information.  This manual\npage describes the format of this information in detail.\n\nFor the purpose of this discussion, a \\emph{procedure} is defined to\nbe an arbitrary piece of \\emph{contiguous} code.  Normally, each\nprocedure directly corresponds to a function in the source-language\nbut this is not strictly required.  For example, a runtime\ncode-generator could translate a given function into two separate\n(discontiguous) procedures: one for frequently-executed (hot) code and\none for rarely-executed (cold) code.  Similarly, simple\nsource-language functions (usually leaf functions) may get translated\ninto code for which the default unwind-conventions apply and for such\ncode, it is not strictly necessary to register dynamic unwind-info.\n\nA procedure logically consists of a sequence of \\emph{regions}.\nRegions are nested in the sense that the frame state at the end of one\nregion is, by default, assumed to be the frame state for the next\nregion.  Each region is thought of as being divided into a\n\\emph{prologue}, a \\emph{body}, and an \\emph{epilogue}.  Each of them\ncan be empty.  If non-empty, the prologue sets up the frame state for\nthe body.  For example, the prologue may need to allocate some space\non the stack and save certain callee-saved registers.  The body\nperforms the actual work of the procedure but does not change the\nframe state in any way.  If non-empty, the epilogue restores the\nprevious frame state and as such it undoes or cancels the effect of\nthe prologue.  In fact, a single epilogue may undo the effect of the\nprologues of several (nested) regions.\n\nWe should point out that even though the prologue, body, and epilogue\nare logically separate entities, optimizing code-generators will\ngenerally interleave instructions from all three entities.  For this\nreason, the dynamic unwind-info interface of \\Prog{libunwind} makes no\ndistinction whatsoever between prologue and body.  Similarly, the\nexact set of instructions that make up an epilogue is also irrelevant.\nThe only point in the epilogue that needs to be described explicitly\nby the dynamic unwind-info is the point at which the stack-pointer\ngets restored.  The reason this point needs to be described is that\nonce the stack-pointer is restored, all values saved in the\ndeallocated portion of the stack frame become invalid and hence\n\\Prog{libunwind} needs to know about it.  The portion of the frame\nstate not saved on the stack is assume to remain valid through the end\nof the region.  For this reason, there is usually no need to describe\ninstructions which restore the contents of callee-saved registers.\n\nWithin a region, each instruction that affects the frame state in some\nfashion needs to be described with an operation descriptor.  For this\npurpose, each instruction in the region is assigned a unique index.\nExactly how this index is derived depends on the architecture.  For\nexample, on RISC and EPIC-style architecture, instructions have a\nfixed size so it's possible to simply number the instructions.  In\ncontrast, most CISC use variable-length instruction encodings, so it\nis usually necessary to use a byte-offset as the index.  Given the\ninstruction index, the operation descriptor specifies the effect of\nthe instruction in an abstract manner.  For example, it might express\nthat the instruction stores calle-saved register \\Var{r1} at offset 16\nin the stack frame.\n\n\\section{Procedures}\n\nA runtime code-generator registers the dynamic unwind-info of a\nprocedure by setting up a structure of type \\Type{unw\\_dyn\\_info\\_t}\nand calling \\Func{\\_U\\_dyn\\_register}(), passing the address of the\nstructure as the sole argument.  The members of the\n\\Type{unw\\_dyn\\_info\\_t} structure are described below:\n\\begin{itemize}\n\\item[\\Type{void~*}next] Private to \\Prog{libunwind}.  Must not be used\n  by the application.\n\\item[\\Type{void~*}prev] Private to \\Prog{libunwind}.  Must not be used\n  by the application.\n\\item[\\Type{unw\\_word\\_t} \\Var{start\\_ip}] The start-address of the\n  instructions of the procedure (remember: procedure are defined to be\n  contiguous pieces of code, so a single code-range is sufficient).\n\\item[\\Type{unw\\_word\\_t} \\Var{end\\_ip}] The end-address of the\n  instructions of the procedure (non-inclusive, that is,\n  \\Var{end\\_ip}-\\Var{start\\_ip} is the size of the procedure in\n  bytes).\n\\item[\\Type{unw\\_word\\_t} \\Var{gp}] The global-pointer value in use\n  for this procedure.  The exact meaing of the global-pointer is\n  architecture-specific and on some architecture, it is not used at\n  all.\n\\item[\\Type{int32\\_t} \\Var{format}] The format of the unwind-info.\n  This member can be one of \\Const{UNW\\_INFO\\_FORMAT\\_DYNAMIC},\n  \\Const{UNW\\_INFO\\_FORMAT\\_TABLE}, or\n  \\Const{UNW\\_INFO\\_FORMAT\\_REMOTE\\_TABLE}.\n\\item[\\Type{union} \\Var{u}] This union contains one sub-member\n  structure for every possible unwind-info format:\n  \\begin{description}\n  \\item[\\Type{unw\\_dyn\\_proc\\_info\\_t} \\Var{pi}] This member is used\n    for format \\Const{UNW\\_INFO\\_FORMAT\\_DYNAMIC}.\n  \\item[\\Type{unw\\_dyn\\_table\\_info\\_t} \\Var{ti}] This member is used\n    for format \\Const{UNW\\_INFO\\_FORMAT\\_TABLE}.\n  \\item[\\Type{unw\\_dyn\\_remote\\_table\\_info\\_t} \\Var{rti}] This member\n    is used for format \\Const{UNW\\_INFO\\_FORMAT\\_REMOTE\\_TABLE}.\n  \\end{description}\\\n  The format of these sub-members is described in detail below.\n\\end{itemize}\n\n\\subsection{Proc-info format}\n\nThis is the preferred dynamic unwind-info format and it is generally\nthe one used by full-blown runtime code-generators.  In this format,\nthe details of a procedure are described by a structure of type\n\\Type{unw\\_dyn\\_proc\\_info\\_t}.  This structure contains the following\nmembers:\n\\begin{description}\n\n\\item[\\Type{unw\\_word\\_t} \\Var{name\\_ptr}] The address of a\n  (human-readable) name of the procedure or 0 if no such name is\n  available.  If non-zero, The string stored at this address must be\n  ASCII NUL terminated.  For source languages that use name-mangling\n  (such as C++ or Java) the string stored at this address should be\n  the \\emph{demangled} version of the name.\n\n\\item[\\Type{unw\\_word\\_t} \\Var{handler}] The address of the\n  personality-routine for this procedure.  Personality-routines are\n  used in conjunction with exception handling.  See the C++ ABI draft\n  (http://www.codesourcery.com/cxx-abi/) for an overview and a\n  description of the personality routine.  If the procedure has no\n  personality routine, \\Var{handler} must be set to 0.\n\n\\item[\\Type{uint32\\_t} \\Var{flags}] A bitmask of flags.  At the\n  moment, no flags have been defined and this member must be\n  set to 0.\n\n\\item[\\Type{unw\\_dyn\\_region\\_info\\_t~*}\\Var{regions}] A NULL-terminated\n  linked list of region-descriptors.  See section ``Region\n  descriptors'' below for more details.\n\n\\end{description}\n\n\\subsection{Table-info format}\n\nThis format is generally used when the dynamically generated code was\nderived from static code and the unwind-info for the dynamic and the\nstatic versions is identical.  For example, this format can be useful\nwhen loading statically-generated code into an address-space in a\nnon-standard fashion (i.e., through some means other than\n\\Func{dlopen}()).  In this format, the details of a group of procedures\nis described by a structure of type \\Type{unw\\_dyn\\_table\\_info}.\nThis structure contains the following members:\n\\begin{description}\n\n\\item[\\Type{unw\\_word\\_t} \\Var{name\\_ptr}] The address of a\n  (human-readable) name of the procedure or 0 if no such name is\n  available.  If non-zero, The string stored at this address must be\n  ASCII NUL terminated.  For source languages that use name-mangling\n  (such as C++ or Java) the string stored at this address should be\n  the \\emph{demangled} version of the name.\n\n\\item[\\Type{unw\\_word\\_t} \\Var{segbase}] The segment-base value\n  that needs to be added to the segment-relative values stored in the\n  unwind-info.  The exact meaning of this value is\n  architecture-specific.\n\n\\item[\\Type{unw\\_word\\_t} \\Var{table\\_len}] The length of the\n  unwind-info (\\Var{table\\_data}) counted in units of words\n  (\\Type{unw\\_word\\_t}).\n\n\\item[\\Type{unw\\_word\\_t} \\Var{table\\_data}] A pointer to the actual\n  data encoding the unwind-info.  The exact format is\n  architecture-specific (see architecture-specific sections below).\n\n\\end{description}\n\n\\subsection{Remote table-info format}\n\nThe remote table-info format has the same basic purpose as the regular\ntable-info format.  The only difference is that when \\Prog{libunwind}\nuses the unwind-info, it will keep the table data in the target\naddress-space (which may be remote).  Consequently, the type of the\n\\Var{table\\_data} member is \\Type{unw\\_word\\_t} rather than a pointer.\nThis implies that \\Prog{libunwind} will have to access the table-data\nvia the address-space's \\Func{access\\_mem}() call-back, rather than\nthrough a direct memory reference.\n\nFrom the point of view of a runtime-code generator, the remote\ntable-info format offers no advantage and it is expected that such\ngenerators will describe their procedures either with the proc-info\nformat or the normal table-info format.  The main reason that the\nremote table-info format exists is to enable the\naddress-space-specific \\Func{find\\_proc\\_info}() callback (see\n\\SeeAlso{unw\\_create\\_addr\\_space}(3)) to return unwind tables whose\ndata remains in remote memory.  This can speed up unwinding (e.g., for\na debugger) because it reduces the amount of data that needs to be\nloaded from remote memory.\n\n\\section{Regions descriptors}\n\nA region descriptor is a variable length structure that describes how\neach instruction in the region affects the frame state.  Of course,\nmost instructions in a region usualy do not change the frame state and\nfor those, nothing needs to be recorded in the region descriptor.  A\nregion descriptor is a structure of type\n\\Type{unw\\_dyn\\_region\\_info\\_t} and has the following members:\n\\begin{description}\n\\item[\\Type{unw\\_dyn\\_region\\_info\\_t~*}\\Var{next}] A pointer to the\n  next region.  If this is the last region, \\Var{next} is \\Const{NULL}.\n\\item[\\Type{int32\\_t} \\Var{insn\\_count}] The length of the region in\n  instructions.  Each instruction is assumed to have a fixed size (see\n  architecture-specific sections for details).  The value of\n  \\Var{insn\\_count} may be negative in the last region of a procedure\n  (i.e., it may be negative only if \\Var{next} is \\Const{NULL}).  A\n  negative value indicates that the region covers the last \\emph{N}\n  instructions of the procedure, where \\emph{N} is the absolute value\n  of \\Var{insn\\_count}.\n\\item[\\Type{uint32\\_t} \\Var{op\\_count}] The (allocated) length of\n  the \\Var{op\\_count} array.\n\\item[\\Type{unw\\_dyn\\_op\\_t} \\Var{op}] An array of dynamic unwind\n  directives.  See Section ``Dynamic unwind directives'' for a\n  description of the directives.\n\\end{description}\nA region descriptor with an \\Var{insn\\_count} of zero is an\n\\emph{empty region} and such regions are perfectly legal.  In fact,\nempty regions can be useful to establish a particular frame state\nbefore the start of another region.\n\nA single region list can be shared across multiple procedures provided\nthose procedures share a common prologue and epilogue (their bodies\nmay differ, of course).  Normally, such procedures consist of a canned\nprologue, the body, and a canned epilogue.  This could be described by\ntwo regions: one covering the prologue and one covering the epilogue.\nSince the body length is variable, the latter region would need to\nspecify a negative value in \\Var{insn\\_count} such that\n\\Prog{libunwind} knows that the region covers the end of the procedure\n(up to the address specified by \\Var{end\\_ip}).\n\nThe region descriptor is a variable length structure to make it\npossible to allocate all the necessary memory with a single\nmemory-allocation request.  To facilitate the allocation of a region\ndescriptors \\Prog{libunwind} provides a helper routine with the\nfollowing synopsis:\n\n\\noindent\n\\Type{size\\_t} \\Func{\\_U\\_dyn\\_region\\_size}(\\Type{int} \\Var{op\\_count});\n\nThis routine returns the number of bytes needed to hold a region\ndescriptor with space for \\Var{op\\_count} unwind directives.  Note\nthat the length of the \\Var{op} array does not have to match exactly\nwith the number of directives in a region.  Instead, it is sufficient\nif the \\Var{op} array contains at least as many entries as there are\ndirectives, since the end of the directives can always be indicated\nwith the \\Const{UNW\\_DYN\\_STOP} directive.\n\n\\section{Dynamic unwind directives}\n\nA dynamic unwind directive describes how the frame state changes\nat a particular point within a region.  The description is in\nthe form of a structure of type \\Type{unw\\_dyn\\_op\\_t}.  This\nstructure has the following members:\n\\begin{description}\n\\item[\\Type{int8\\_t} \\Var{tag}] The operation tag.  Must be one\n  of the \\Type{unw\\_dyn\\_operation\\_t} values described below.\n\\item[\\Type{int8\\_t} \\Var{qp}] The qualifying predicate that controls\n  whether or not this directive is active.  This is useful for\n  predicated architecturs such as IA-64 or ARM, where the contents of\n  another (callee-saved) register determines whether or not an\n  instruction is executed (takes effect).  If the directive is always\n  active, this member should be set to the manifest constant\n  \\Const{\\_U\\_QP\\_TRUE} (this constant is defined for all\n  architectures, predicated or not).\n\\item[\\Type{int16\\_t} \\Var{reg}] The number of the register affected\n  by the instruction.\n\\item[\\Type{int32\\_t} \\Var{when}] The region-relative number of\n  the instruction to which this directive applies.  For example,\n  a value of 0 means that the effect described by this directive\n  has taken place once the first instruction in the region has\n  executed.\n\\item[\\Type{unw\\_word\\_t} \\Var{val}] The value to be applied by the\n  operation tag.  The exact meaning of this value varies by tag.  See\n  Section ``Operation tags'' below.\n\\end{description}\nIt is perfectly legitimate to specify multiple dynamic unwind\ndirectives with the same \\Var{when} value, if a particular instruction\nhas a complex effect on the frame state.\n\nEmpty regions by definition contain no actual instructions and as such\nthe directives are not tied to a particular instruction.  By\nconvention, the \\Var{when} member should be set to 0, however.\n\nThere is no need for the dynamic unwind directives to appear\nin order of increasing \\Var{when} values.  If the directives happen to\nbe sorted in that order, it may result in slightly faster execution,\nbut a runtime code-generator should not go to extra lengths just to\nensure that the directives are sorted.\n\nIMPLEMENTATION NOTE: should \\Prog{libunwind} implementations for\ncertain architectures prefer the list of unwind directives to be\nsorted, it is recommended that such implementations first check\nwhether the list happens to be sorted already and, if not, sort the\ndirectives explicitly before the first use.  With this approach, the\noverhead of explicit sorting is only paid when there is a real benefit\nand if the runtime code-generator happens to generated sorted lists\nnaturally, the performance penalty is limited to a simple O(N) check.\n\n\\subsection{Operations tags}\n\nThe possible operation tags are defined by enumeration type\n\\Type{unw\\_dyn\\_operation\\_t} which defines the following\nvalues:\n\\begin{description}\n\n\\item[\\Const{UNW\\_DYN\\_STOP}] Marks the end of the dynamic unwind\n  directive list.  All remaining entries in the \\Var{op} array of the\n  region-descriptor are ignored.  This tag is guaranteed to have a\n  value of 0.\n\n\\item[\\Const{UNW\\_DYN\\_SAVE\\_REG}] Marks an instruction which saves\n  register \\Var{reg} to register \\Var{val}.\n\n\\item[\\Const{UNW\\_DYN\\_SPILL\\_FP\\_REL}] Marks an instruction which\n  spills register \\Var{reg} to a frame-pointer-relative location.  The\n  frame-pointer-relative offset is given by the value stored in member\n  \\Var{val}.  See the architecture-specific sections for a description\n  of the stack frame layout.\n\n\\item[\\Const{UNW\\_DYN\\_SPILL\\_SP\\_REL}] Marks an instruction which\n  spills register \\Var{reg} to a stack-pointer-relative location.  The\n  stack-pointer-relative offset is given by the value stored in member\n  \\Var{val}.  See the architecture-specific sections for a description\n  of the stack frame layout.\n\n\\item[\\Const{UNW\\_DYN\\_ADD}] Marks an instruction which adds\n  the constant value \\Var{val} to register \\Var{reg}.  To add subtract\n  a constant value, store the two's-complement of the value in\n  \\Var{val}.  The set of registers that can be specified for this tag\n  is described in the architecture-specific sections below.\n\n\\item[\\Const{UNW\\_DYN\\_POP\\_FRAMES}]\n\n\\item[\\Const{UNW\\_DYN\\_LABEL\\_STATE}]\n\n\\item[\\Const{UNW\\_DYN\\_COPY\\_STATE}]\n\n\\item[\\Const{UNW\\_DYN\\_ALIAS}]\n\n\\end{description}\n\nunw\\_dyn\\_op\\_t\n\n\\_U\\_dyn\\_op\\_save\\_reg();\n\\_U\\_dyn\\_op\\_spill\\_fp\\_rel();\n\\_U\\_dyn\\_op\\_spill\\_sp\\_rel();\n\\_U\\_dyn\\_op\\_add();\n\\_U\\_dyn\\_op\\_pop\\_frames();\n\\_U\\_dyn\\_op\\_label\\_state();\n\\_U\\_dyn\\_op\\_copy\\_state();\n\\_U\\_dyn\\_op\\_alias();\n\\_U\\_dyn\\_op\\_stop();\n\n\\section{IA-64 specifics}\n\n- meaning of segbase member in table-info/table-remote-info format\n- format of table\\_data in table-info/table-remote-info format\n- instruction size: each bundle is counted as 3 instructions, regardless\n  of template (MLX)\n- describe stack-frame layout, especially with regards to sp-relative\n  and fp-relative addressing\n- UNW\\_DYN\\_ADD can only add to ``sp'' (always a negative value); use\n  POP\\_FRAMES otherwise\n\n\\section{See Also}\n\n\\SeeAlso{libunwind(3)},\n\\SeeAlso{\\_U\\_dyn\\_register(3)},\n\\SeeAlso{\\_U\\_dyn\\_cancel(3)}\n\n\\section{Author}\n\n\\noindent\nDavid Mosberger-Tang\\\\\nEmail: \\Email{dmosberger@gmail.com}\\\\\nWWW: \\URL{http://www.nongnu.org/libunwind/}.\n\\LatexManEnd\n\n\\end{document}\n",
        "/tmp/vanessa/spack-stage/spack-stage-libunwind-master-dwt2qxx3j4hnf4kmav7v6l2hhs5xwxbz/spack-src/doc/libunwind-dynamic.man": "'\\\" t\n.\\\" Manual page created with latex2man on Thu Aug 16 09:44:44 MDT 2007\n.\\\" NOTE: This file is generated, DO NOT EDIT.\n.de Vb\n.ft CW\n.nf\n..\n.de Ve\n.ft R\n\n.fi\n..\n.TH \"LIBUNWIND\\-DYNAMIC\" \"3\" \"16 August 2007\" \"Programming Library \" \"Programming Library \"\n.SH NAME\nlibunwind\\-dynamic\n\\-\\- libunwind\\-support for runtime\\-generated code \n.PP\n.SH INTRODUCTION\n\n.PP\nFor libunwind\nto do its job, it needs to be able to reconstruct \nthe \\fIframe state\\fP\nof each frame in a call\\-chain. The frame state \ndescribes the subset of the machine\\-state that consists of the \n\\fIframe registers\\fP\n(typically the instruction\\-pointer and the \nstack\\-pointer) and all callee\\-saved registers (preserved registers). \nThe frame state describes each register either by providing its \ncurrent value (for frame registers) or by providing the location at \nwhich the current value is stored (callee\\-saved registers). \n.PP\nFor statically generated code, the compiler normally takes care of \nemitting \\fIunwind\\-info\\fP\nwhich provides the minimum amount of \ninformation needed to reconstruct the frame\\-state for each instruction \nin a procedure. For dynamically generated code, the runtime code \ngenerator must use the dynamic unwind\\-info interface provided by \nlibunwind\nto supply the equivalent information. This manual \npage describes the format of this information in detail. \n.PP\nFor the purpose of this discussion, a \\fIprocedure\\fP\nis defined to \nbe an arbitrary piece of \\fIcontiguous\\fP\ncode. Normally, each \nprocedure directly corresponds to a function in the source\\-language \nbut this is not strictly required. For example, a runtime \ncode\\-generator could translate a given function into two separate \n(discontiguous) procedures: one for frequently\\-executed (hot) code and \none for rarely\\-executed (cold) code. Similarly, simple \nsource\\-language functions (usually leaf functions) may get translated \ninto code for which the default unwind\\-conventions apply and for such \ncode, it is not strictly necessary to register dynamic unwind\\-info. \n.PP\nA procedure logically consists of a sequence of \\fIregions\\fP\\&.\nRegions are nested in the sense that the frame state at the end of one \nregion is, by default, assumed to be the frame state for the next \nregion. Each region is thought of as being divided into a \n\\fIprologue\\fP,\na \\fIbody\\fP,\nand an \\fIepilogue\\fP\\&.\nEach of them \ncan be empty. If non\\-empty, the prologue sets up the frame state for \nthe body. For example, the prologue may need to allocate some space \non the stack and save certain callee\\-saved registers. The body \nperforms the actual work of the procedure but does not change the \nframe state in any way. If non\\-empty, the epilogue restores the \nprevious frame state and as such it undoes or cancels the effect of \nthe prologue. In fact, a single epilogue may undo the effect of the \nprologues of several (nested) regions. \n.PP\nWe should point out that even though the prologue, body, and epilogue \nare logically separate entities, optimizing code\\-generators will \ngenerally interleave instructions from all three entities. For this \nreason, the dynamic unwind\\-info interface of libunwind\nmakes no \ndistinction whatsoever between prologue and body. Similarly, the \nexact set of instructions that make up an epilogue is also irrelevant. \nThe only point in the epilogue that needs to be described explicitly \nby the dynamic unwind\\-info is the point at which the stack\\-pointer \ngets restored. The reason this point needs to be described is that \nonce the stack\\-pointer is restored, all values saved in the \ndeallocated portion of the stack frame become invalid and hence \nlibunwind\nneeds to know about it. The portion of the frame \nstate not saved on the stack is assume to remain valid through the end \nof the region. For this reason, there is usually no need to describe \ninstructions which restore the contents of callee\\-saved registers. \n.PP\nWithin a region, each instruction that affects the frame state in some \nfashion needs to be described with an operation descriptor. For this \npurpose, each instruction in the region is assigned a unique index. \nExactly how this index is derived depends on the architecture. For \nexample, on RISC and EPIC\\-style architecture, instructions have a \nfixed size so it\\&'s possible to simply number the instructions. In \ncontrast, most CISC use variable\\-length instruction encodings, so it \nis usually necessary to use a byte\\-offset as the index. Given the \ninstruction index, the operation descriptor specifies the effect of \nthe instruction in an abstract manner. For example, it might express \nthat the instruction stores calle\\-saved register r1\nat offset 16 \nin the stack frame. \n.PP\n.SH PROCEDURES\n\n.PP\nA runtime code\\-generator registers the dynamic unwind\\-info of a \nprocedure by setting up a structure of type unw_dyn_info_t\nand calling _U_dyn_register(),\npassing the address of the \nstructure as the sole argument. The members of the \nunw_dyn_info_t\nstructure are described below: \n.TP\nvoid *next\n Private to libunwind\\&.\nMust not be used \nby the application. \n.TP\nvoid *prev\n Private to libunwind\\&.\nMust not be used \nby the application. \n.TP\nunw_word_t start_ip\n The start\\-address of the \ninstructions of the procedure (remember: procedure are defined to be \ncontiguous pieces of code, so a single code\\-range is sufficient). \n.TP\nunw_word_t end_ip\n The end\\-address of the \ninstructions of the procedure (non\\-inclusive, that is, \nend_ip\\-start_ip\nis the size of the procedure in \nbytes). \n.TP\nunw_word_t gp\n The global\\-pointer value in use \nfor this procedure. The exact meaing of the global\\-pointer is \narchitecture\\-specific and on some architecture, it is not used at \nall. \n.TP\nint32_t format\n The format of the unwind\\-info. \nThis member can be one of UNW_INFO_FORMAT_DYNAMIC,\nUNW_INFO_FORMAT_TABLE,\nor \nUNW_INFO_FORMAT_REMOTE_TABLE\\&.\n.TP\nunion u\n This union contains one sub\\-member \nstructure for every possible unwind\\-info format: \n.RS\n.TP\nunw_dyn_proc_info_t pi\n This member is used \nfor format UNW_INFO_FORMAT_DYNAMIC\\&.\n.TP\nunw_dyn_table_info_t ti\n This member is used \nfor format UNW_INFO_FORMAT_TABLE\\&.\n.TP\nunw_dyn_remote_table_info_t rti\n This member \nis used for format UNW_INFO_FORMAT_REMOTE_TABLE\\&.\n.RE\n.RS\n.PP\nThe format of these sub\\-members is described in detail below. \n.RE\n.PP\n.SS PROC\\-INFO FORMAT\n.PP\nThis is the preferred dynamic unwind\\-info format and it is generally \nthe one used by full\\-blown runtime code\\-generators. In this format, \nthe details of a procedure are described by a structure of type \nunw_dyn_proc_info_t\\&.\nThis structure contains the following \nmembers: \n.PP\n.RE\n.TP\nunw_word_t name_ptr\n The address of a \n(human\\-readable) name of the procedure or 0 if no such name is \navailable. If non\\-zero, The string stored at this address must be \nASCII NUL terminated. For source languages that use name\\-mangling \n(such as C++ or Java) the string stored at this address should be \nthe \\fIdemangled\\fP\nversion of the name. \n.PP\n.TP\nunw_word_t handler\n The address of the \npersonality\\-routine for this procedure. Personality\\-routines are \nused in conjunction with exception handling. See the C++ ABI draft \n(http://www.codesourcery.com/cxx\\-abi/) for an overview and a \ndescription of the personality routine. If the procedure has no \npersonality routine, handler\nmust be set to 0. \n.PP\n.TP\nuint32_t flags\n A bitmask of flags. At the \nmoment, no flags have been defined and this member must be \nset to 0. \n.PP\n.TP\nunw_dyn_region_info_t *regions\n A NULL\\-terminated \nlinked list of region\\-descriptors. See section ``Region \ndescriptors\\&'' below for more details. \n.PP\n.SS TABLE\\-INFO FORMAT\n.PP\nThis format is generally used when the dynamically generated code was \nderived from static code and the unwind\\-info for the dynamic and the \nstatic versions is identical. For example, this format can be useful \nwhen loading statically\\-generated code into an address\\-space in a \nnon\\-standard fashion (i.e., through some means other than \ndlopen()).\nIn this format, the details of a group of procedures \nis described by a structure of type unw_dyn_table_info\\&.\nThis structure contains the following members: \n.PP\n.TP\nunw_word_t name_ptr\n The address of a \n(human\\-readable) name of the procedure or 0 if no such name is \navailable. If non\\-zero, The string stored at this address must be \nASCII NUL terminated. For source languages that use name\\-mangling \n(such as C++ or Java) the string stored at this address should be \nthe \\fIdemangled\\fP\nversion of the name. \n.PP\n.TP\nunw_word_t segbase\n The segment\\-base value \nthat needs to be added to the segment\\-relative values stored in the \nunwind\\-info. The exact meaning of this value is \narchitecture\\-specific. \n.PP\n.TP\nunw_word_t table_len\n The length of the \nunwind\\-info (table_data)\ncounted in units of words \n(unw_word_t).\n.PP\n.TP\nunw_word_t table_data\n A pointer to the actual \ndata encoding the unwind\\-info. The exact format is \narchitecture\\-specific (see architecture\\-specific sections below). \n.PP\n.SS REMOTE TABLE\\-INFO FORMAT\n.PP\nThe remote table\\-info format has the same basic purpose as the regular \ntable\\-info format. The only difference is that when libunwind\nuses the unwind\\-info, it will keep the table data in the target \naddress\\-space (which may be remote). Consequently, the type of the \ntable_data\nmember is unw_word_t\nrather than a pointer. \nThis implies that libunwind\nwill have to access the table\\-data \nvia the address\\-space\\&'s access_mem()\ncall\\-back, rather than \nthrough a direct memory reference. \n.PP\nFrom the point of view of a runtime\\-code generator, the remote \ntable\\-info format offers no advantage and it is expected that such \ngenerators will describe their procedures either with the proc\\-info \nformat or the normal table\\-info format. The main reason that the \nremote table\\-info format exists is to enable the \naddress\\-space\\-specific find_proc_info()\ncallback (see \nunw_create_addr_space(3))\nto return unwind tables whose \ndata remains in remote memory. This can speed up unwinding (e.g., for \na debugger) because it reduces the amount of data that needs to be \nloaded from remote memory. \n.PP\n.SH REGIONS DESCRIPTORS\n\n.PP\nA region descriptor is a variable length structure that describes how \neach instruction in the region affects the frame state. Of course, \nmost instructions in a region usualy do not change the frame state and \nfor those, nothing needs to be recorded in the region descriptor. A \nregion descriptor is a structure of type \nunw_dyn_region_info_t\nand has the following members: \n.TP\nunw_dyn_region_info_t *next\n A pointer to the \nnext region. If this is the last region, next\nis NULL\\&.\n.TP\nint32_t insn_count\n The length of the region in \ninstructions. Each instruction is assumed to have a fixed size (see \narchitecture\\-specific sections for details). The value of \ninsn_count\nmay be negative in the last region of a procedure \n(i.e., it may be negative only if next\nis NULL).\nA \nnegative value indicates that the region covers the last \\fIN\\fP\ninstructions of the procedure, where \\fIN\\fP\nis the absolute value \nof insn_count\\&.\n.TP\nuint32_t op_count\n The (allocated) length of \nthe op_count\narray. \n.TP\nunw_dyn_op_t op\n An array of dynamic unwind \ndirectives. See Section ``Dynamic unwind directives\\&'' for a \ndescription of the directives. \n.PP\nA region descriptor with an insn_count\nof zero is an \n\\fIempty region\\fP\nand such regions are perfectly legal. In fact, \nempty regions can be useful to establish a particular frame state \nbefore the start of another region. \n.PP\nA single region list can be shared across multiple procedures provided \nthose procedures share a common prologue and epilogue (their bodies \nmay differ, of course). Normally, such procedures consist of a canned \nprologue, the body, and a canned epilogue. This could be described by \ntwo regions: one covering the prologue and one covering the epilogue. \nSince the body length is variable, the latter region would need to \nspecify a negative value in insn_count\nsuch that \nlibunwind\nknows that the region covers the end of the procedure \n(up to the address specified by end_ip).\n.PP\nThe region descriptor is a variable length structure to make it \npossible to allocate all the necessary memory with a single \nmemory\\-allocation request. To facilitate the allocation of a region \ndescriptors libunwind\nprovides a helper routine with the \nfollowing synopsis: \n.PP\nsize_t\n_U_dyn_region_size(int\nop_count);\n.PP\nThis routine returns the number of bytes needed to hold a region \ndescriptor with space for op_count\nunwind directives. Note \nthat the length of the op\narray does not have to match exactly \nwith the number of directives in a region. Instead, it is sufficient \nif the op\narray contains at least as many entries as there are \ndirectives, since the end of the directives can always be indicated \nwith the UNW_DYN_STOP\ndirective. \n.PP\n.SH DYNAMIC UNWIND DIRECTIVES\n\n.PP\nA dynamic unwind directive describes how the frame state changes \nat a particular point within a region. The description is in \nthe form of a structure of type unw_dyn_op_t\\&.\nThis \nstructure has the following members: \n.TP\nint8_t tag\n The operation tag. Must be one \nof the unw_dyn_operation_t\nvalues described below. \n.TP\nint8_t qp\n The qualifying predicate that controls \nwhether or not this directive is active. This is useful for \npredicated architecturs such as IA\\-64 or ARM, where the contents of \nanother (callee\\-saved) register determines whether or not an \ninstruction is executed (takes effect). If the directive is always \nactive, this member should be set to the manifest constant \n_U_QP_TRUE\n(this constant is defined for all \narchitectures, predicated or not). \n.TP\nint16_t reg\n The number of the register affected \nby the instruction. \n.TP\nint32_t when\n The region\\-relative number of \nthe instruction to which this directive applies. For example, \na value of 0 means that the effect described by this directive \nhas taken place once the first instruction in the region has \nexecuted. \n.TP\nunw_word_t val\n The value to be applied by the \noperation tag. The exact meaning of this value varies by tag. See \nSection ``Operation tags\\&'' below. \n.PP\nIt is perfectly legitimate to specify multiple dynamic unwind \ndirectives with the same when\nvalue, if a particular instruction \nhas a complex effect on the frame state. \n.PP\nEmpty regions by definition contain no actual instructions and as such \nthe directives are not tied to a particular instruction. By \nconvention, the when\nmember should be set to 0, however. \n.PP\nThere is no need for the dynamic unwind directives to appear \nin order of increasing when\nvalues. If the directives happen to \nbe sorted in that order, it may result in slightly faster execution, \nbut a runtime code\\-generator should not go to extra lengths just to \nensure that the directives are sorted. \n.PP\nIMPLEMENTATION NOTE: should libunwind\nimplementations for \ncertain architectures prefer the list of unwind directives to be \nsorted, it is recommended that such implementations first check \nwhether the list happens to be sorted already and, if not, sort the \ndirectives explicitly before the first use. With this approach, the \noverhead of explicit sorting is only paid when there is a real benefit \nand if the runtime code\\-generator happens to generated sorted lists \nnaturally, the performance penalty is limited to a simple O(N) check. \n.PP\n.SS OPERATIONS TAGS\n.PP\nThe possible operation tags are defined by enumeration type \nunw_dyn_operation_t\nwhich defines the following \nvalues: \n.PP\n.TP\nUNW_DYN_STOP\n Marks the end of the dynamic unwind \ndirective list. All remaining entries in the op\narray of the \nregion\\-descriptor are ignored. This tag is guaranteed to have a \nvalue of 0. \n.PP\n.TP\nUNW_DYN_SAVE_REG\n Marks an instruction which saves \nregister reg\nto register val\\&.\n.PP\n.TP\nUNW_DYN_SPILL_FP_REL\n Marks an instruction which \nspills register reg\nto a frame\\-pointer\\-relative location. The \nframe\\-pointer\\-relative offset is given by the value stored in member \nval\\&.\nSee the architecture\\-specific sections for a description \nof the stack frame layout. \n.PP\n.TP\nUNW_DYN_SPILL_SP_REL\n Marks an instruction which \nspills register reg\nto a stack\\-pointer\\-relative location. The \nstack\\-pointer\\-relative offset is given by the value stored in member \nval\\&.\nSee the architecture\\-specific sections for a description \nof the stack frame layout. \n.PP\n.TP\nUNW_DYN_ADD\n Marks an instruction which adds \nthe constant value val\nto register reg\\&.\nTo add subtract \na constant value, store the two\\&'s\\-complement of the value in \nval\\&.\nThe set of registers that can be specified for this tag \nis described in the architecture\\-specific sections below. \n.PP\n.TP\nUNW_DYN_POP_FRAMES\n .PP\n.TP\nUNW_DYN_LABEL_STATE\n .PP\n.TP\nUNW_DYN_COPY_STATE\n .PP\n.TP\nUNW_DYN_ALIAS\n .PP\nunw_dyn_op_t \n.PP\n_U_dyn_op_save_reg(); \n_U_dyn_op_spill_fp_rel(); \n_U_dyn_op_spill_sp_rel(); \n_U_dyn_op_add(); \n_U_dyn_op_pop_frames(); \n_U_dyn_op_label_state(); \n_U_dyn_op_copy_state(); \n_U_dyn_op_alias(); \n_U_dyn_op_stop(); \n.PP\n.SH IA\\-64 SPECIFICS\n\n.PP\n\\- meaning of segbase member in table\\-info/table\\-remote\\-info format \n\\- format of table_data in table\\-info/table\\-remote\\-info format \n\\- instruction size: each bundle is counted as 3 instructions, regardless \nof template (MLX) \n\\- describe stack\\-frame layout, especially with regards to sp\\-relative \nand fp\\-relative addressing \n\\- UNW_DYN_ADD can only add to ``sp\\&'' (always a negative value); use \nPOP_FRAMES otherwise \n.PP\n.SH SEE ALSO\n\n.PP\nlibunwind(3),\n_U_dyn_register(3),\n_U_dyn_cancel(3)\n.PP\n.SH AUTHOR\n\n.PP\nDavid Mosberger\\-Tang\n.br\nEmail: \\fBdmosberger@gmail.com\\fP\n.br\nWWW: \\fBhttp://www.nongnu.org/libunwind/\\fP\\&.\n.\\\" NOTE: This file is generated, DO NOT EDIT.\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-libunwind-master-dwt2qxx3j4hnf4kmav7v6l2hhs5xwxbz/spack-src/.git/objects/pack/pack-f509623374d679db4f723eafad79296bd508d430.idx",
        "/tmp/vanessa/spack-stage/spack-stage-libunwind-master-dwt2qxx3j4hnf4kmav7v6l2hhs5xwxbz/spack-src/.git/objects/pack/pack-f509623374d679db4f723eafad79296bd508d430.pack"
    ],
    "total_files": 829
}