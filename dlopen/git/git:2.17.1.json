{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-git-2.17.1-i5gynr5bqi4u5vpyb6wokjpmcj7nsk7e/spack-src/usage.c": "/*\n * GIT - The information manager from hell\n *\n * Copyright (C) Linus Torvalds, 2005\n */\n#include \"git-compat-util.h\"\n#include \"cache.h\"\n\nvoid vreportf(const char *prefix, const char *err, va_list params)\n{\n\tchar msg[4096];\n\tchar *p;\n\n\tvsnprintf(msg, sizeof(msg), err, params);\n\tfor (p = msg; *p; p++) {\n\t\tif (iscntrl(*p) && *p != '\\t' && *p != '\\n')\n\t\t\t*p = '?';\n\t}\n\tfprintf(stderr, \"%s%s\\n\", prefix, msg);\n}\n\nstatic NORETURN void usage_builtin(const char *err, va_list params)\n{\n\tvreportf(\"usage: \", err, params);\n\texit(129);\n}\n\nstatic NORETURN void die_builtin(const char *err, va_list params)\n{\n\tvreportf(\"fatal: \", err, params);\n\texit(128);\n}\n\nstatic void error_builtin(const char *err, va_list params)\n{\n\tvreportf(\"error: \", err, params);\n}\n\nstatic void warn_builtin(const char *warn, va_list params)\n{\n\tvreportf(\"warning: \", warn, params);\n}\n\nstatic int die_is_recursing_builtin(void)\n{\n\tstatic int dying;\n\t/*\n\t * Just an arbitrary number X where \"a < x < b\" where \"a\" is\n\t * \"maximum number of pthreads we'll ever plausibly spawn\" and\n\t * \"b\" is \"something less than Inf\", since the point is to\n\t * prevent infinite recursion.\n\t */\n\tstatic const int recursion_limit = 1024;\n\n\tdying++;\n\tif (dying > recursion_limit) {\n\t\treturn 1;\n\t} else if (dying == 2) {\n\t\twarning(\"die() called many times. Recursion error or racy threaded death!\");\n\t\treturn 0;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n/* If we are in a dlopen()ed .so write to a global variable would segfault\n * (ugh), so keep things static. */\nstatic NORETURN_PTR void (*usage_routine)(const char *err, va_list params) = usage_builtin;\nstatic NORETURN_PTR void (*die_routine)(const char *err, va_list params) = die_builtin;\nstatic void (*error_routine)(const char *err, va_list params) = error_builtin;\nstatic void (*warn_routine)(const char *err, va_list params) = warn_builtin;\nstatic int (*die_is_recursing)(void) = die_is_recursing_builtin;\n\nvoid set_die_routine(NORETURN_PTR void (*routine)(const char *err, va_list params))\n{\n\tdie_routine = routine;\n}\n\nvoid set_error_routine(void (*routine)(const char *err, va_list params))\n{\n\terror_routine = routine;\n}\n\nvoid (*get_error_routine(void))(const char *err, va_list params)\n{\n\treturn error_routine;\n}\n\nvoid set_warn_routine(void (*routine)(const char *warn, va_list params))\n{\n\twarn_routine = routine;\n}\n\nvoid (*get_warn_routine(void))(const char *warn, va_list params)\n{\n\treturn warn_routine;\n}\n\nvoid set_die_is_recursing_routine(int (*routine)(void))\n{\n\tdie_is_recursing = routine;\n}\n\nvoid NORETURN usagef(const char *err, ...)\n{\n\tva_list params;\n\n\tva_start(params, err);\n\tusage_routine(err, params);\n\tva_end(params);\n}\n\nvoid NORETURN usage(const char *err)\n{\n\tusagef(\"%s\", err);\n}\n\nvoid NORETURN die(const char *err, ...)\n{\n\tva_list params;\n\n\tif (die_is_recursing()) {\n\t\tfputs(\"fatal: recursion detected in die handler\\n\", stderr);\n\t\texit(128);\n\t}\n\n\tva_start(params, err);\n\tdie_routine(err, params);\n\tva_end(params);\n}\n\nstatic const char *fmt_with_err(char *buf, int n, const char *fmt)\n{\n\tchar str_error[256], *err;\n\tint i, j;\n\n\terr = strerror(errno);\n\tfor (i = j = 0; err[i] && j < sizeof(str_error) - 1; ) {\n\t\tif ((str_error[j++] = err[i++]) != '%')\n\t\t\tcontinue;\n\t\tif (j < sizeof(str_error) - 1) {\n\t\t\tstr_error[j++] = '%';\n\t\t} else {\n\t\t\t/* No room to double the '%', so we overwrite it with\n\t\t\t * '\\0' below */\n\t\t\tj--;\n\t\t\tbreak;\n\t\t}\n\t}\n\tstr_error[j] = 0;\n\tsnprintf(buf, n, \"%s: %s\", fmt, str_error);\n\treturn buf;\n}\n\nvoid NORETURN die_errno(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list params;\n\n\tif (die_is_recursing()) {\n\t\tfputs(\"fatal: recursion detected in die_errno handler\\n\",\n\t\t\tstderr);\n\t\texit(128);\n\t}\n\n\tva_start(params, fmt);\n\tdie_routine(fmt_with_err(buf, sizeof(buf), fmt), params);\n\tva_end(params);\n}\n\n#undef error_errno\nint error_errno(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list params;\n\n\tva_start(params, fmt);\n\terror_routine(fmt_with_err(buf, sizeof(buf), fmt), params);\n\tva_end(params);\n\treturn -1;\n}\n\n#undef error\nint error(const char *err, ...)\n{\n\tva_list params;\n\n\tva_start(params, err);\n\terror_routine(err, params);\n\tva_end(params);\n\treturn -1;\n}\n\nvoid warning_errno(const char *warn, ...)\n{\n\tchar buf[1024];\n\tva_list params;\n\n\tva_start(params, warn);\n\twarn_routine(fmt_with_err(buf, sizeof(buf), warn), params);\n\tva_end(params);\n}\n\nvoid warning(const char *warn, ...)\n{\n\tva_list params;\n\n\tva_start(params, warn);\n\twarn_routine(warn, params);\n\tva_end(params);\n}\n\nstatic NORETURN void BUG_vfl(const char *file, int line, const char *fmt, va_list params)\n{\n\tchar prefix[256];\n\n\t/* truncation via snprintf is OK here */\n\tif (file)\n\t\tsnprintf(prefix, sizeof(prefix), \"BUG: %s:%d: \", file, line);\n\telse\n\t\tsnprintf(prefix, sizeof(prefix), \"BUG: \");\n\n\tvreportf(prefix, fmt, params);\n\tabort();\n}\n\n#ifdef HAVE_VARIADIC_MACROS\nNORETURN void BUG_fl(const char *file, int line, const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tBUG_vfl(file, line, fmt, ap);\n\tva_end(ap);\n}\n#else\nNORETURN void BUG(const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tBUG_vfl(NULL, 0, fmt, ap);\n\tva_end(ap);\n}\n#endif\n\n#ifdef SUPPRESS_ANNOTATED_LEAKS\nvoid unleak_memory(const void *ptr, size_t len)\n{\n\tstatic struct suppressed_leak_root {\n\t\tstruct suppressed_leak_root *next;\n\t\tchar data[FLEX_ARRAY];\n\t} *suppressed_leaks;\n\tstruct suppressed_leak_root *root;\n\n\tFLEX_ALLOC_MEM(root, data, ptr, len);\n\troot->next = suppressed_leaks;\n\tsuppressed_leaks = root;\n}\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-git-2.17.1-i5gynr5bqi4u5vpyb6wokjpmcj7nsk7e/spack-src/gitweb/static/git-favicon.png",
        "/tmp/vanessa/spack-stage/spack-stage-git-2.17.1-i5gynr5bqi4u5vpyb6wokjpmcj7nsk7e/spack-src/gitweb/static/git-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-git-2.17.1-i5gynr5bqi4u5vpyb6wokjpmcj7nsk7e/spack-src/git-gui/lib/git-gui.ico",
        "/tmp/vanessa/spack-stage/spack-stage-git-2.17.1-i5gynr5bqi4u5vpyb6wokjpmcj7nsk7e/spack-src/git-gui/macosx/git-gui.icns",
        "/tmp/vanessa/spack-stage/spack-stage-git-2.17.1-i5gynr5bqi4u5vpyb6wokjpmcj7nsk7e/spack-src/t/t4201-shortlog.sh",
        "/tmp/vanessa/spack-stage/spack-stage-git-2.17.1-i5gynr5bqi4u5vpyb6wokjpmcj7nsk7e/spack-src/t/test-binary-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-git-2.17.1-i5gynr5bqi4u5vpyb6wokjpmcj7nsk7e/spack-src/t/t7813-grep-icase-iso.sh",
        "/tmp/vanessa/spack-stage/spack-stage-git-2.17.1-i5gynr5bqi4u5vpyb6wokjpmcj7nsk7e/spack-src/t/test-binary-1.png",
        "/tmp/vanessa/spack-stage/spack-stage-git-2.17.1-i5gynr5bqi4u5vpyb6wokjpmcj7nsk7e/spack-src/t/t3900/ISO8859-1.txt",
        "/tmp/vanessa/spack-stage/spack-stage-git-2.17.1-i5gynr5bqi4u5vpyb6wokjpmcj7nsk7e/spack-src/t/t3900/UTF-16.txt",
        "/tmp/vanessa/spack-stage/spack-stage-git-2.17.1-i5gynr5bqi4u5vpyb6wokjpmcj7nsk7e/spack-src/t/t3900/eucJP.txt",
        "/tmp/vanessa/spack-stage/spack-stage-git-2.17.1-i5gynr5bqi4u5vpyb6wokjpmcj7nsk7e/spack-src/t/t3901/8859-1.txt",
        "/tmp/vanessa/spack-stage/spack-stage-git-2.17.1-i5gynr5bqi4u5vpyb6wokjpmcj7nsk7e/spack-src/t/t0013/shattered-1.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-git-2.17.1-i5gynr5bqi4u5vpyb6wokjpmcj7nsk7e/spack-src/t/t5004/big-pack.zip",
        "/tmp/vanessa/spack-stage/spack-stage-git-2.17.1-i5gynr5bqi4u5vpyb6wokjpmcj7nsk7e/spack-src/t/t5004/empty.zip",
        "/tmp/vanessa/spack-stage/spack-stage-git-2.17.1-i5gynr5bqi4u5vpyb6wokjpmcj7nsk7e/spack-src/t/t5003/infozip-symlinks.zip",
        "/tmp/vanessa/spack-stage/spack-stage-git-2.17.1-i5gynr5bqi4u5vpyb6wokjpmcj7nsk7e/spack-src/t/t8005/sjis.txt",
        "/tmp/vanessa/spack-stage/spack-stage-git-2.17.1-i5gynr5bqi4u5vpyb6wokjpmcj7nsk7e/spack-src/t/t8005/euc-japan.txt"
    ],
    "total_files": 3058
}