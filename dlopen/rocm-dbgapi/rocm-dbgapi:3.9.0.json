{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-rocm-dbgapi-3.9.0-2zk444qcympvanbfjmjvvnqfoqvvvpqo/spack-src/include/amd-dbgapi.h.in": "/* Copyright (c) 2019-2020 Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n/** \\mainpage AMD Debugger API Specification\n *\n * \\section introduction Introduction\n *\n * The amd-dbgapi is a library that implements an AMD GPU debugger application\n * programming interface (API).  It provides the support necessary for a client\n * of the library to control the execution and inspect the state of supported\n * commercially available AMD GPU devices.\n *\n * The term \\e client is used to refer to the application that uses this API.\n *\n * The term \\e library is used to refer to the implementation of this interface\n * being used by the client.\n *\n * The term <em>AMD GPU</em> is used to refer to commercially available AMD GPU\n * devices supported by the library.\n *\n * The term \\e inferior is used to refer to the process being debugged.\n *\n * The library does not provide any operations to perform symbolic mappings,\n * code object decoding, or stack unwinding.  The client must use the AMD GPU\n * code object ELF ABI defined in [User Guide for AMDGPU Backend - Code Object]\n * (https://llvm.org/docs/AMDGPUUsage.html#code-object), together with the AMD\n * GPU debug information DWARF and call frame information CFI ABI define in\n * [User Guide for AMDGPU Backend - Code Object - DWARF]\n * (https://llvm.org/docs/AMDGPUUsage.html#dwarf) to perform those tasks.\n *\n * The library does not provide operations for inserting or managing\n * breakpoints.  The client must write the architecture specific breakpoint\n * instruction provided by the\n * ::AMD_DBGAPI_ARCHITECTURE_INFO_BREAKPOINT_INSTRUCTION query into the loaded\n * code object memory to set breakpoints.  For resuming from breakpoints the\n * client must use the displaced stepping mechanism provided by\n * ::amd_dbgapi_displaced_stepping_start and\n * ::amd_dbgapi_displaced_stepping_complete in conjunction with the\n * ::amd_dbgapi_wave_resume in single step mode.  In order to determine the\n * location of stopped waves the client must read the architecture specific\n * program counter register available using the\n * ::AMD_DBGAPI_ARCHITECTURE_INFO_PC_REGISTER query and adjust it by the amount\n * specified by the\n * ::AMD_DBGAPI_ARCHITECTURE_INFO_BREAKPOINT_INSTRUCTION_PC_ADJUST query.\n *\n * The client is responsible for checking that only a single thread at a time\n * invokes a function provided by the library.  A callback (see \\ref\n * callbacks_group) invoked by the library must not itself invoke any function\n * provided by the library.\n *\n * The library implementation uses the native operating system to inspect and\n * control the inferior.  Therefore, the library must be executed on the same\n * machine as the inferior.\n *\n * The library implementation creates an internal native operating system\n * thread for its own internal use.\n *\n * The library uses opaque handles to refer to the entities that it manages.\n * These should not be modified directly.  See the handle definitions for\n * information on the lifetime and scope of handles of that type.  If a handle\n * becomes invalidated it is undefined to use it with any library operations.\n * A handle value is unique within its scope for the lifetime of its owning\n * entity.  This is true even if the handle becomes invalidated: handle values\n * are not reused within their scope and lifetime.  Every handle with \\p handle\n * of 0 is reserved to indicate the handle does not reference an entity.\n *\n * For example, a wave handle type is unique within a process.  Every wave\n * handle relating to a process will have a unique value but may have the same\n * value as wave handles of another process.  No wave handle will have the same\n * value of another wave handle for the same process, even if the wave handle\n * is invalidated due to the wave terminating.  When the process is detached\n * its lifetime ends and all associated wave handles lifetime ends.\n *\n * When the library is first loaded it is in the uninitialized state with the\n * logging level set to ::AMD_DBGAPI_LOG_LEVEL_NONE.\n *\n * \\section amd_gpu_execution_model AMD GPU Execution Model\n *\n * In this section the AMD GPU execution model is described to provide\n * background to the reader if they are not familiar with this environment.\n * The AMD GPU execution model is more complicated than that of a traditional\n * CPU because of how GPU hardware is used to accelerate and schedule the very\n * large number of threads of execution that are created on GPUs.\n *\n * Chapter 2 of the [HSA Programmer's Reference Manual][hsa-prm] provides an\n * introduction to this execution model.  Note that the AMD ROCm compilers\n * compile directly to ISA and do not use the HSAIL intermediate language.\n * However, the ROCr low-level runtime and ROCgdb debugger use the same\n * terminology.\n *\n * In this model, a CPU process may interact with multiple AMD GPU devices,\n * which are termed agents.  A Process Address Space Identifier (PASID) is\n * created for each process that interacts with agents.  An agent can be\n * executing code for multiple processes at once.  This is achieved by mapping\n * the PASID to one of a limited set of Virtual Memory Identifiers (VMIDs).\n * Each VMID is associated with its own page table.\n *\n * The AMD GPU device driver for Linux, termed the Kernel Mode Driver (KMD),\n * manages the page tables used by each GPU so they correlate with the CPU page\n * table for the corresponding process.  The CPU and GPU page tables do not\n * necessarily map all the same memory pages but pages they do have in common\n * have the same virtual address.  Therefore, the CPU and GPUs have a unified\n * address space.\n *\n * Each GPU includes one or more Microcode Engines (ME) that can execute\n * microcode firmware.  This firmware includes a Hardware Scheduler (HWS) that,\n * in collaboration with the KMD, manages which processes, identified by a\n * PASID, are mapped onto the GPU using one of the limited VMIDs.  This mapping\n * configures the VMID to use the GPU page table that corresponds to the PASID.\n * In this way, the code executing on the GPU from different processes is\n * isolated.\n *\n * Multiple software submission queues may be created for each agent.  The GPU\n * hardware has a limited number of pipes, each of which has a fixed number of\n * hardware queues.  The HWS, in collaboration with the KMD, is responsible for\n * mapping software queues onto hardware queues.  This is done by multiplexing\n * the software queues onto hardware queues using time slicing.  The software\n * queues provide a virtualized abstraction, allowing for more queues than are\n * directly supported by the hardware.  Each ME manages its own set of pipes\n * and their associated hardware queues.\n *\n * To execute code on the GPU, a packet must be created and placed in a\n * software queue.  This is achieved using regular user space atomic memory\n * operations.  No Linux kernel call is required.  For this reason, the queues\n * are termed user mode queues.\n *\n * The AMD ROCm platform uses the Asynchronous Queuing Language (AQL) packet\n * format defined in the [HSA Platform System Architecture\n * Specification][hsa-sysarch].  Packets can request GPU management actions\n * (for example, manage memory coherence) and the execution of kernel\n * functions.  The ME firmware includes the Command Processor (CP) which,\n * together with fixed-function hardware support, is responsible for detecting\n * when packets are added to software queues that are mapped to hardware\n * queues.  Once detected, CP is responsible for initiating actions requested\n * by the packet, using the appropriate VMID when performing all memory\n * operations.\n *\n * Dispatch packets are used to request the execution of a kernel function.\n * Each dispatch packet specifies the address of a kernel descriptor, the\n * address of the kernel argument block holding the arguments to the kernel\n * function, and the number of threads of execution to create to execute the\n * kernel function.  The kernel descriptor describes how the CP must configure\n * the hardware to execute the kernel function and the starting address of the\n * kernel function code.  The compiler generates a kernel descriptor in the\n * code object for each kernel function and determines the kernel argument\n * block layout.  The number of threads of execution is specified as a grid,\n * such that each thread of execution can identify its position in the grid.\n * Conceptually, each of these threads executes the same kernel code, with the\n * same arguments.\n *\n * The dispatch grid is organized as a three-dimensional collection of\n * work-groups, where each work-group is the same size (except for potential\n * boundary partial work-groups).  The work-groups form a three-dimensional\n * collection of work-items.  The work-items are the threads of execution.  The\n * position of a work-item is its zero-based three-dimensional position in a\n * work-group, termed its work-item ID, plus its work-group's three-dimensional\n * position in the dispatch grid, termed its work-group ID.  These\n * three-dimensional IDs can also be expressed as a zero-based one-dimensional\n * ID, termed a flat ID, by simply numbering the elements in a natural manner\n * akin to linearizing a multi-dimensional array.\n *\n * Consecutive work-items, in flat work-item ID order, of a work-group are\n * organized into fixed size wavefronts, or waves for short.  Each work-item\n * position in the wave is termed a lane, and has a zero-base lane ID.  The\n * hardware imposes an upper limit on the number of work-items in a work-group\n * but does not limit the number of work-groups in a dispatch grid.  The\n * hardware executes instructions for waves independently.  But the lanes of a\n * wave all execute the same instruction jointly.  This is termed Single\n * Instruction Multiple Thread (SIMT) execution.\n *\n * Each hardware wave has a set of registers that are shared by all lanes of\n * the wave, termed scalar registers.  There is only one set of scalar\n * registers for the whole wave.  Instructions that act on the whole wave,\n * which typically use scalar registers, are termed scalar instructions.\n *\n * Additionally, each wave also has a set of vector registers that are\n * replicated so each lane has its own copy.  A set of vector registers can be\n * viewed as a vector with each element of the vector belonging to the\n * corresponding lane of the wave.  Instructions that act on vector registers,\n * which produce independent results for each lane, are termed vector\n * instructions.\n *\n * Each hardware wave has an execution mask that controls if the execution of a\n * vector instruction should change the state of a particular lane.  If the\n * lane is masked off, no changes are made for that lane and the instruction is\n * effectively ignored.  The compiler generates code to update the execution\n * mask which emulates independent work-item execution.  However, the lanes of\n * a wave do not execute instructions independently.  If two subsets of lanes\n * in a wave need to execute different code, the compiler will generate code to\n * set the execution mask to execute the subset of lanes for one path, then\n * generate instructions for that path.  The compiler will then generate code\n * to change the execution mask to enable the other subset of lanes, then\n * generate code for those lanes.  If both subsets of lanes execute the same\n * code, the compiler will generate code to set the execution mask to include\n * both subsets of lanes, then generate code as usual.  When only a subset of\n * lanes is enabled, they are said to be executing divergent control flow.\n * When all lanes are enabled, they are said to be executing wave uniform\n * control flow.\n *\n * Not all MEs have the hardware to execute kernel functions.  One such ME is\n * used to execute the HWS microcode and to execute microcode that manages a\n * service queue that is used to update GPU state.  If the ME does support\n * kernel function execution it uses fixed-function hardware to initiate the\n * creation of waves.  This is accomplished by sending requests to create\n * work-groups to one or more Compute Units (CUs).  Requests are sent to create\n * all the work-groups of a dispatch grid.  Each CU has resources to hold a\n * fixed number of waves and has fixed-function hardware to schedule execution\n * of these waves.  The scheduler may execute multiple waves concurrently and\n * will hide latency by switching between the waves that are ready to execute.\n * At any point of time, a subset of the waves belonging to work-groups in a\n * dispatch may be actively executing.  As waves complete, the waves of\n * subsequent work-group requests are created.\n *\n * Each CU has a fixed amount of memory from which it allocates vector and\n * scalar registers.  The kernel descriptor specifies how many registers to\n * allocate for a wave.  There is a tradeoff between how many waves can be\n * created on a CU and the number of registers each can use.\n *\n * The CU also has a fixed size Local Data Store (LDS).  A dispatch packet\n * specifies how much LDS each work-group is allocated.  All waves in a\n * work-group are created on the same CU.  This allows the LDS to be used to\n * share data between the waves of the same work-group.  There is a tradeoff\n * between how much LDS a work-group can allocate, and the number of\n * work-groups that can fit on a CU.  The address of a location in a work-group\n * LDS allocation is zero-based and is a different address space than the\n * global virtual memory.  There are specific instructions that take an LDS\n * address to access it.  There are also flat address instructions that map the\n * LDS address range into an unused fixed aperture range of the global virtual\n * address range.  An LDS address can be converted to or from a flat address by\n * offsetting by the base of the aperture.  Note that a flat address in the LDS\n * aperture only accesses the LDS work-group allocation for the wave that uses\n * it.  The same address will access different LDS allocations if used by waves\n * in different work-groups.\n *\n * The dispatch packet specifies the amount of scratch memory that must be\n * allocated for a work-item.  This is used for work-item private memory.\n * Fixed-function hardware in the CU manages per wave allocation of scratch\n * memory from pre-allocated global virtual memory mapped to GPU device memory.\n * Like an LDS address, a scratch address is zero-based, but is per work-item\n * instead of per work-group.  It maps to an aperture in a flat address.  The\n * hardware swizzles this address so that adjacent lanes access adjacent DWORDs\n * (4 bytes) in global memory for better cache performance.\n *\n * For an AMD Radeon Instinct\u2122 MI60 GPU the work-group size limit is 1,024\n * work-items, the wave size is 64, and the CU count is 64.  A CU can hold up\n * to 40 waves (this is limited to 32 if using scratch memory).  Therefore, a\n * work-group can comprise between 1 and 16 waves inclusive, and there can be\n * up to 2,560 waves, making a maximum of 163,840 work-items.  A CU is\n * organized as 4 Execution Units (EUs) also referred to as Single Instruction\n * Multiple Data units (SIMDs) that can each hold 10 waves.  Each SIMD has 256\n * 64-wide DWORD vector registers and each CU has 800 DWORD scalar registers.\n * A single wave can access up to 256 64-wide vector registers and 112 scalar\n * registers.  A CU has 64KiB of LDS.\n *\n * \\section supported_amd_gpu_architectures Supported AMD GPU Architectures\n *\n * The following AMD GPU architectures are supported:\n *\n * - GFX9\n *   - gfx900 (Vega 10)\n *   - gfx906 (Vega 7nm also referred to as Vega 20)\n *\n * For more information about the AMD ROCm ecosystem, please refer to:\n *\n * - https://rocmdocs.amd.com/\n *\n * \\section known_limitations Known Limitations and Restrictions\n *\n * The AMD Debugger API library implementation is currently a prototype and has\n * the following restrictions.  Future releases aim to address these\n * restrictions.\n *\n * 1.  The following *_get_info queries are not yet implemented:\n *\n *     - AMD_DBGAPI_QUEUE_INFO_ERROR_REASON\n *     - AMD_DBGAPI_QUEUE_INFO_STATE\n *\n * 2.  On a AMD_DBGAPI_STATUS_FATAL error the library does fully reset the\n *     internal state and so subsequent functions may not operate correctly.\n *\n * 3.  Detaching from a process does not currently generate events for\n *     outstanding wave requests.\n *\n * 4.  The AMD_DBGAPI_MEMORY_PRECISION_PRECISE memory precision is not\n *     supported. The default memory precision is\n *     AMD_DBGAPI_MEMORY_PRECISION_NONE.\n *\n * 5.  amd_dbgapi_next_pending_event returns AMD_DBGAPI_EVENT_KIND_WAVE_STOP\n *     events only for AQL queues.  PM4 queues that launch wavefronts are not\n *     supported.\n *\n * 6.  amd_dbgapi_queue_packet_list returns packets only for AQL queues.\n *\n * \\section references References\n *\n * 1. Advanced Micro Devices: [www.amd.com] (https://www.amd.com/)\n * 2. AMD ROCm Ecosystem: [rocmdocs.amd.com] (https://rocmdocs.amd.com/)\n * 3. Bus:Device.Function (BDF) Notation:\n *    [wiki.xen.org/wiki/Bus:Device.Function_(BDF)_Notation]\n *    (https://wiki.xen.org/wiki/Bus:Device.Function_(BDF)_Notation)\n * 4. HSA Platform System Architecture Specification:\n *    [www.hsafoundation.com/html_spec111/HSA_Library.htm#SysArch/Topics/SysArch_title_page.htm]\n *    (http://www.hsafoundation.com/html_spec111/HSA_Library.htm#SysArch/Topics/SysArch_title_page.htm)\n * 5. HSA Programmer's Reference Manual:\n *    [www.hsafoundation.com/html_spec111/HSA_Library.htm#PRM/Topics/PRM_title_page.htm]\n *    (http://www.hsafoundation.com/html_spec111/HSA_Library.htm#PRM/Topics/PRM_title_page.htm)\n * 6. Semantic Versioning: [semver.org] (https://semver.org)\n * 7. The LLVM Compiler Infrastructure: [llvm.org] (https://llvm.org/)\n * 8. User Guide for AMDGPU LLVM Backend: [llvm.org/docs/AMDGPUUsage.html]\n *    (https://llvm.org/docs/AMDGPUUsage.html)\n *\n * \\section disclaimer Disclaimer\n *\n * The information contained herein is for informational purposes only, and is\n * subject to change without notice.  While every precaution has been taken in\n * the preparation of this document, it may contain technical inaccuracies,\n * omissions and typographical errors, and AMD is under no obligation to update\n * or otherwise correct this information.  Advanced Micro Devices, Inc. makes\n * no representations or warranties with respect to the accuracy or\n * completeness of the contents of this document, and assumes no liability of\n * any kind, including the implied warranties of noninfringement,\n * merchantability or fitness for particular purposes, with respect to the\n * operation or use of AMD hardware, software or other products described\n * herein.  No license, including implied or arising by estoppel, to any\n * intellectual property rights is granted by this document.  Terms and\n * limitations applicable to the purchase or use of AMD\u2019s products are as set\n * forth in a signed agreement between the parties or in AMD's Standard Terms\n * and Conditions of Sale.\n *\n * AMD\u00ae, the AMD Arrow logo, ROCm\u00ae and combinations thereof are trademarks of\n * Advanced Micro Devices, Inc.  Linux\u00ae is the registered trademark of Linus\n * Torvalds in the U.S. and other countries.  PCIe\u00ae is a registered trademark\n * of PCI-SIG Corporation.  Other product names used in this publication are\n * for identification purposes only and may be trademarks of their respective\n * companies.\n *\n * Copyright (c) 2019-2020 Advanced Micro Devices, Inc.  All rights reserved.\n */\n\n/**\n * [amd]:\n * https://www.amd.com/\n * \"Advanced Micro Devices\"\n *\n * [bdf]:\n * https://wiki.xen.org/wiki/Bus:Device.Function_(BDF)_Notation\n * \"[Bus:Device.Function (BDF) Notation]\"\n *\n * [hsa-prm]:\n * http://www.hsafoundation.com/html_spec111/HSA_Library.htm#PRM/Topics/PRM_title_page.htm\n * \"HSA Programmer's Reference Manual\"\n *\n * [hsa-sysarch]:\n * http://www.hsafoundation.com/html_spec111/HSA_Library.htm#SysArch/Topics/SysArch_title_page.htm\n * \"HSA Platform System Architecture Specification\"\n *\n * [llvm]:\n * https://llvm.org/\n * \"The LLVM Compiler Infrastructure\"\n *\n * [llvm-amdgpu]:\n * https://llvm.org/docs/AMDGPUUsage.html\n * \"User Guide for AMDGPU LLVM Backend\"\n *\n * [rocm]:\n * https://rocmdocs.amd.com/\n * \"AMD ROCm Ecosystem\"\n *\n * [semver]:\n * https://semver.org/\n * \"Semantic Versioning\"\n */\n\n/**\n * \\file\n * AMD debugger API interface.\n */\n\n#ifndef AMD_DBGAPI_H\n#define AMD_DBGAPI_H 1\n\n/* Placeholder for calling convention and import/export macros */\n#if !defined(AMD_DBGAPI_CALL)\n#define AMD_DBGAPI_CALL\n#endif /* !defined (AMD_DBGAPI_CALL) */\n\n#if !defined(AMD_DBGAPI_EXPORT_DECORATOR)\n#if defined(__GNUC__)\n#define AMD_DBGAPI_EXPORT_DECORATOR __attribute__ ((visibility (\"default\")))\n#elif defined(_MSC_VER)\n#define AMD_DBGAPI_EXPORT_DECORATOR __declspec(dllexport)\n#endif /* defined (_MSC_VER) */\n#endif /* !defined (AMD_DBGAPI_EXPORT_DECORATOR) */\n\n#if !defined(AMD_DBGAPI_IMPORT_DECORATOR)\n#if defined(__GNUC__)\n#define AMD_DBGAPI_IMPORT_DECORATOR\n#elif defined(_MSC_VER)\n#define AMD_DBGAPI_IMPORT_DECORATOR __declspec(dllimport)\n#endif /* defined (_MSC_VER) */\n#endif /* !defined (AMD_DBGAPI_IMPORT_DECORATOR) */\n\n#define AMD_DBGAPI_EXPORT AMD_DBGAPI_EXPORT_DECORATOR AMD_DBGAPI_CALL\n#define AMD_DBGAPI_IMPORT AMD_DBGAPI_IMPORT_DECORATOR AMD_DBGAPI_CALL\n\n#if !defined(AMD_DBGAPI)\n#if defined(AMD_DBGAPI_EXPORTS)\n#define AMD_DBGAPI AMD_DBGAPI_EXPORT\n#else /* !defined (AMD_DBGAPI_EXPORTS) */\n#define AMD_DBGAPI AMD_DBGAPI_IMPORT\n#endif /* !defined (AMD_DBGAPI_EXPORTS) */\n#endif /* !defined (AMD_DBGAPI) */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* defined (__cplusplus) */\n\n#if defined(__linux__)\n#include <sys/types.h>\n#endif /* __linux__ */\n\n#include <stddef.h>\n#include <stdint.h>\n\n/** \\defgroup symbol_versions_group Symbol Versions\n *\n * The names used for the shared library versioned symbols.\n *\n * Every function is annotated with one of the version macros defined in this\n * section.  Each macro specifies a corresponding symbol version string.  After\n * dynamically loading the shared library with \\p dlopen, the address of each\n * function can be obtained using \\p dlvsym with the name of the function and\n * its corresponding symbol version string.  An error will be reported by \\p\n * dlvsym if the installed library does not support the version for the\n * function specified in this version of the interface.\n *\n * @{\n */\n\n/**\n * The function was introduced in version 0.24 of the interface and has the\n * symbol version string of ``\"@AMD_DBGAPI_NAME@_0.24\"``.\n */\n#define AMD_DBGAPI_VERSION_0_24\n\n/**\n * The function was introduced in version 0.30 of the interface and has the\n * symbol version string of ``\"@AMD_DBGAPI_NAME@_0.30\"``.\n */\n#define AMD_DBGAPI_VERSION_0_30\n\n/**\n * The function was introduced in version 0.36 of the interface and has the\n * symbol version string of ``\"@AMD_DBGAPI_NAME@_0.36\"``.\n */\n#define AMD_DBGAPI_VERSION_0_36\n\n/** @} */\n\n/** \\ingroup callbacks_group\n * Forward declaration of callbacks used to specify services that must be\n * provided by the client.\n */\ntypedef struct amd_dbgapi_callbacks_s amd_dbgapi_callbacks_t;\n\n/** \\defgroup basic_group Basic Types\n *\n * Types used for common properties.\n *\n * Note that in some cases enumeration types are used as output parameters for\n * functions using pointers.  The C language does not define the underlying\n * type used for enumeration types.  This interface requires that:\n *\n * - For all enumeration types except \\p amd_dbgapi_wave_stop_reason_t and \\p\n *   amd_dbgapi_queue_error_reason_t, the underlying type used by the client\n *   will be \\p int with a size of 32 bits.\n * - For the enumeration types \\p amd_dbgapi_wave_stop_reason_t and \\p\n *   amd_dbgapi_queue_error_reason_t, the  underlying type used by the client\n *   will be \\p unsigned \\p long \\p long with a size of 64 bits.\n *\n * In addition, it requires that enumeration types passed by value to\n * functions, or returned as values from functions, will have the platform\n * function ABI representation.\n *\n * @{\n */\n\n/**\n * Integral type used for a global virtual memory address in the inferior\n * process.\n */\ntypedef uint64_t amd_dbgapi_global_address_t;\n\n/**\n * Integral type used for sizes, including memory allocations, in the inferior.\n */\ntypedef uint64_t amd_dbgapi_size_t;\n\n/**\n * Indication of if a value has changed.\n */\ntypedef enum\n{\n  /**\n   * The value has not changed.\n   */\n  AMD_DBGAPI_CHANGED_NO = 0,\n  /**\n   * The value has changed.\n   */\n  AMD_DBGAPI_CHANGED_YES = 1\n} amd_dbgapi_changed_t;\n\n/**\n * Native operating system process ID.\n *\n * This is the process ID used by the operating system that is executing the\n * library.  It is used in the implementation of the library to interact with\n * the operating system AMD GPU device driver.\n */\n#if defined(__linux__)\ntypedef pid_t amd_dbgapi_os_process_id_t;\n#endif /* __linux__ */\n\n/**\n * Type used to notify the client of the library that a process may have\n * pending events.\n *\n * A notifier is created when ::amd_dbgapi_process_attach is used to\n * successfully attach to a process.  It is obtained using the\n * ::AMD_DBGAPI_PROCESS_INFO_NOTIFIER query.  If the notifier indicates there\n * may be pending events, then ::amd_dbgapi_next_pending_event can be used to\n * retrieve them.\n *\n * For Linux<sup>&reg;</sup> this is a file descriptor number that can be used\n * with the \\p poll call to wait on events from multiple sources.  The file\n * descriptor is made to have data available when events may be added to the\n * pending events.  The client can flush the file descriptor and read the\n * pending events until none are available.  Note that the file descriptor may\n * become ready spuriously when no pending events are available, in which case\n * the client should simply wait again.  If new pending events are added while\n * reading the pending events, then the file descriptor will again have data\n * available.  The amount of data on the file descriptor is not an indication\n * of the number of pending events as the file may become full and so no\n * further data will be added.  The file descriptor is simply a robust way to\n * determine if there may be some pending events.\n */\n#if defined(__linux__)\ntypedef int amd_dbgapi_notifier_t;\n#endif /* __linux__ */\n\n/**\n * Native operating system agent ID.\n *\n * This is the agent ID used by the operating system AMD GPU device driver that\n * is executing the library to specify the AMD GPU agents accessible to a\n * process.\n */\n#if defined(__linux__)\ntypedef uint64_t amd_dbgapi_os_agent_id_t;\n#endif /* __linux__ */\n\n/**\n * Native operating system queue ID.\n *\n * This is the queue ID used by the operating system AMD GPU device driver that\n * is executing the library to specify the AMD GPU queues of a process.\n */\n#if defined(__linux__)\ntypedef uint64_t amd_dbgapi_os_queue_id_t;\n#endif /* __linux__ */\n\n/**\n * Native operating system queue packet ID.\n *\n * This is the queue packet ID used by the operating system AMD GPU device\n * driver that is executing the library to specify the AMD GPU packets of a\n * queue of a process.  The meaning of the queue packet ID is dependent on the\n * queue type.  See ::amd_dbgapi_os_queue_type_t.\n */\n#if defined(__linux__)\ntypedef uint64_t amd_dbgapi_os_queue_packet_id_t;\n#endif /* __linux__ */\n\n/**\n * Native operating system queue type.\n *\n * This is used by the operating system AMD GPU device driver that is executing\n * the library to specify the AMD GPU queue mechanics supported by the queues\n * of a process.\n */\n#if defined(__linux__)\ntypedef enum\n{\n  /**\n   * Unknown queue type.\n   */\n  AMD_DBGAPI_OS_QUEUE_TYPE_UNKNOWN = 0,\n  /**\n   * Queue supports the HSA kernel dispatch with multiple producers protocol.\n   *\n   * This follows the multiple producers mechanics described by [HSA Platform\n   * System Architecture Specification: Requirement: User mode queuing]\n   * (http://www.hsafoundation.com/html_spec111/HSA_Library.htm#SysArch/Topics/02_Details/req_user_mode_queuing.htm)\n   * and uses the HSA Architected Queuing Language (AQL) packet format\n   * described in [HSA Platform System Architecture Specification: Requirement:\n   * Architected Queuing Language (AQL)]\n   * (http://www.hsafoundation.com/html_spec111/HSA_Library.htm#SysArch/Topics/02_Details/req_architected_queuing_language_AQL.htm).\n   *\n   * For this queue type the AQL dispatch ID is used for\n   * ::amd_dbgapi_os_queue_packet_id_t.\n   */\n  AMD_DBGAPI_OS_QUEUE_TYPE_HSA_KERNEL_DISPATCH_MULTIPLE_PRODUCER = 1,\n  /**\n   * Queue supports the HSA kernel dispatch with single producer protocol.\n   *\n   * This follows the single producer mechanics described by [HSA Platform\n   * System Architecture Specification: Requirement: User mode queuing]\n   * (http://www.hsafoundation.com/html_spec111/HSA_Library.htm#SysArch/Topics/02_Details/req_user_mode_queuing.htm)\n   * and uses the HSA Architected Queuing Language (AQL) packet format\n   * described in [HSA Platform System Architecture Specification: Requirement:\n   * Architected Queuing Language (AQL)]\n   * (http://www.hsafoundation.com/html_spec111/HSA_Library.htm#SysArch/Topics/02_Details/req_architected_queuing_language_AQL.htm).\n   *\n   * For this queue type the AQL dispatch ID is used for\n   * ::amd_dbgapi_os_queue_packet_id_t.  It is only unique within a single queue\n   * of a single process.\n   */\n  AMD_DBGAPI_OS_QUEUE_TYPE_HSA_KERNEL_DISPATCH_SINGLE_PRODUCER = 2,\n  /**\n   * Queue supports HSA kernel dispatch with multiple producers protocol that\n   * supports cooperative dispatches.\n   *\n   * Queues of this type follow the same protocol as\n   * ::AMD_DBGAPI_OS_QUEUE_TYPE_HSA_KERNEL_DISPATCH_MULTIPLE_PRODUCER.  In\n   * addition, dispatches are able to use global wave synchronization (GWS)\n   * operations.\n   */\n  AMD_DBGAPI_OS_QUEUE_TYPE_HSA_KERNEL_DISPATCH_COOPERATIVE = 3,\n  /**\n   * Queue supports the AMD PM4 protocol.\n   */\n  AMD_DBGAPI_OS_QUEUE_TYPE_AMD_PM4 = 257,\n  /**\n   * Queue supports the AMD SDMA protocol.\n   */\n  AMD_DBGAPI_OS_QUEUE_TYPE_AMD_SDMA = 513,\n  /**\n   * Queue supports the AMD SDMA XGMI protocol.\n   */\n  AMD_DBGAPI_OS_QUEUE_TYPE_AMD_SDMA_XGMI = 514\n} amd_dbgapi_os_queue_type_t;\n#endif /* __linux__ */\n\n/** @} */\n\n/** \\defgroup status_codes_group Status Codes\n *\n * Most operations return a status code to indicate success or error.\n *\n * @{\n */\n\n/**\n * AMD debugger API status codes.\n */\ntypedef enum\n{\n  /**\n   * The function has executed successfully.\n   */\n  AMD_DBGAPI_STATUS_SUCCESS = 0,\n  /**\n   * A generic error has occurred.\n   */\n  AMD_DBGAPI_STATUS_ERROR = -1,\n  /**\n   * A fatal error has occurred.\n   *\n   * The library encountered an error from which it cannot recover.  All\n   * processes are detached.  All breakpoints inserted by\n   * amd_dbgapi_callbacks_s::insert_breakpoint are attempted to be removed.\n   * All handles are invalidated.  The library is left in an uninitialized\n   * state.  The logging level is reset to ::AMD_DBGAPI_LOG_LEVEL_NONE.\n   *\n   * To resume using the library the client must re-initialize the\n   * library; re-attach to any processes; re-fetch the list of code objects,\n   * agents, queues, dispatches, and waves; and update the state of all waves\n   * as appropriate.  While in the uninitialized state the inferior processes\n   * will continue executing but any execution of a breakpoint instruction will\n   * put the queue into an error state, aborting any executing waves.  Note\n   * that recovering from a fatal error most likely will require the user of\n   * the client to re-start their session.\n   *\n   * The cause of possible fatal errors is that resources became exhausted or\n   * unique handle numbers became exhausted.\n   */\n  AMD_DBGAPI_STATUS_FATAL = -2,\n  /**\n   * The operation is not currently implemented.  This error may be reported by\n   * any function.  Check the \\ref known_limitations section to determine the\n   * status of the library implementation of the interface.\n   */\n  AMD_DBGAPI_STATUS_ERROR_UNIMPLEMENTED = -3,\n  /**\n   * The operation is not supported.\n   */\n  AMD_DBGAPI_STATUS_ERROR_NOT_SUPPORTED = -4,\n  /**\n   * An invalid argument was given to the function.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT = -5,\n  /**\n   * An invalid size was given to the function.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT_SIZE = -6,\n  /**\n   * The library is already initialized.\n   */\n  AMD_DBGAPI_STATUS_ERROR_ALREADY_INITIALIZED = -7,\n  /**\n   * The library is not initialized.\n   */\n  AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED = -8,\n  /**\n   * There is a restriction error that prevents debugging the process.  Reasons\n   * include:\n   *\n   * - The installed AMD GPU driver version is not compatible with the library.\n   * - The installed AMD GPU driver's debug support version is not compatible\n   *   with the library.\n   * - The AMD GPU runtime version is not compatible with the library.\n   * - One of the AMD GPU agents has an architecture not supported by the\n   *   library.\n   * - The firmware version of one of the AMD GPU agents is not compatible with\n   *   the library.\n   * - A limitation on the number of debuggers that can be active for an\n   *   AMD GPU agent has been exceeded.\n   */\n  AMD_DBGAPI_STATUS_ERROR_RESTRICTION = -9,\n  /**\n   * The process is already attached to the given inferior process.\n   */\n  AMD_DBGAPI_STATUS_ERROR_ALREADY_ATTACHED = -10,\n  /**\n   * The architecture handle is invalid.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_ARCHITECTURE_ID = -11,\n  /**\n   * The bytes being disassembled are not a legal instruction.\n   */\n  AMD_DBGAPI_STATUS_ERROR_ILLEGAL_INSTRUCTION = -12,\n  /**\n   * The code object handle is invalid.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_CODE_OBJECT_ID = -13,\n  /**\n   * The ELF AMD GPU machine value is invalid or unsupported.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_ELF_AMDGPU_MACHINE = -14,\n  /**\n   * The process handle is invalid.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID = -15,\n  /**\n   * The agent handle is invalid.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_AGENT_ID = -16,\n  /**\n   * The queue handle is invalid.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_QUEUE_ID = -17,\n  /**\n   * The dispatch handle is invalid.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_DISPATCH_ID = -18,\n  /**\n   * The wave handle is invalid.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_WAVE_ID = -19,\n  /**\n   * The wave is not stopped.\n   */\n  AMD_DBGAPI_STATUS_ERROR_WAVE_NOT_STOPPED = -20,\n  /**\n   * The wave is stopped.\n   */\n  AMD_DBGAPI_STATUS_ERROR_WAVE_STOPPED = -21,\n  /**\n   * The wave has an outstanding stop request.\n   */\n  AMD_DBGAPI_STATUS_ERROR_WAVE_OUTSTANDING_STOP = -22,\n  /**\n   * The wave cannot be resumed.\n   */\n  AMD_DBGAPI_STATUS_ERROR_WAVE_NOT_RESUMABLE = -23,\n  /**\n   * The displaced stepping handle is invalid.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_DISPLACED_STEPPING_ID = -24,\n  /**\n   * No more displaced stepping buffers are available that are suitable for the\n   * requested wave.\n   */\n  AMD_DBGAPI_STATUS_ERROR_DISPLACED_STEPPING_BUFFER_UNAVAILABLE = -25,\n  /**\n   * The watchpoint handle is invalid.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_WATCHPOINT_ID = -26,\n  /**\n   * No more watchpoints available.\n   */\n  AMD_DBGAPI_STATUS_ERROR_NO_WATCHPOINT_AVAILABLE = -27,\n  /**\n   * The register class handle is invalid.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_REGISTER_CLASS_ID = -28,\n  /**\n   * The register handle is invalid.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_REGISTER_ID = -29,\n  /**\n   * The lane handle is invalid.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_LANE_ID = -30,\n  /**\n   * The address class handle is invalid.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_ADDRESS_CLASS_ID = -31,\n  /**\n   * The address space handle is invalid.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_ADDRESS_SPACE_ID = -32,\n  /**\n   * An error occurred while trying to access memory in the inferior.\n   */\n  AMD_DBGAPI_STATUS_ERROR_MEMORY_ACCESS = -33,\n  /**\n   * The segment address cannot be converted to the requested address space.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_ADDRESS_SPACE_CONVERSION = -34,\n  /**\n   * The event handle is invalid.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_EVENT_ID = -35,\n  /**\n   * The shared library handle is invalid.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_SHARED_LIBRARY_ID = -36,\n  /**\n   * The breakpoint handle is invalid.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_BREAKPOINT_ID = -37,\n  /**\n   * A callback to the client reported an error.\n   */\n  AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK = -38,\n  /**\n   * The client process handle is invalid.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_CLIENT_PROCESS_ID = -39,\n  /**\n   * The native operating system process associated with a client process has\n   * exited.\n   */\n  AMD_DBGAPI_STATUS_ERROR_PROCESS_EXITED = -40,\n  /**\n   * The shared library is not currently loaded.\n   */\n  AMD_DBGAPI_STATUS_ERROR_LIBRARY_NOT_LOADED = -41,\n  /**\n   * The symbol was not found.\n   */\n  AMD_DBGAPI_STATUS_ERROR_SYMBOL_NOT_FOUND = -42,\n  /**\n   * The address is not within the shared library.\n   */\n  AMD_DBGAPI_STATUS_ERROR_INVALID_ADDRESS = -43\n} amd_dbgapi_status_t;\n\n/**\n * Query a textual description of a status code.\n *\n * This function can be used even when the library is uninitialized.\n *\n * \\param[in] status Status code.\n *\n * \\param[out] status_string A NUL terminated string that describes the\n * status code.  The string is read only and owned by the library.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully.  \\p status_string has been updated.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p status is an invalid\n * status code or \\p status_string is NULL.  \\p status_string is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_get_status_string (\n    amd_dbgapi_status_t status,\n    const char **status_string) AMD_DBGAPI_VERSION_0_24;\n\n/** @} */\n\n/** \\defgroup versioning_group Versioning\n *\n * Version information about the interface and the associated installed\n * library.\n *\n * @{\n */\n\n/**\n * The semantic version of the interface following\n * [semver.org][semver] rules.\n *\n * A client that uses this interface is only compatible with the installed\n * library if the major version numbers match and the interface minor version\n * number is less than or equal to the installed library minor version number.\n */\n\n/**\n * The major version of the interface as a macro so it can be used by the\n * preprocessor.\n */\n#define AMD_DBGAPI_VERSION_MAJOR @AMD_DBGAPI_VERSION_MAJOR@\n\n/**\n * The minor version of the interface as a macro so it can be used by the\n * preprocessor.\n */\n#define AMD_DBGAPI_VERSION_MINOR @AMD_DBGAPI_VERSION_MINOR@\n\n/**\n * Query the version of the installed library.\n *\n * Return the version of the installed library.  This can be used to check if\n * it is compatible with this interface version.  This function can be used\n * even when the library is not initialized.\n *\n * \\param[out] major The major version number is stored if non-NULL.\n *\n * \\param[out] minor The minor version number is stored if non-NULL.\n *\n * \\param[out] patch The patch version number is stored if non-NULL.\n */\nvoid AMD_DBGAPI amd_dbgapi_get_version (\n    uint32_t *major, uint32_t *minor, uint32_t *patch) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Query the installed library build name.\n *\n * This function can be used even when the library is not initialized.\n *\n * \\return Returns a string describing the build version of the library.  The\n * string is owned by the library.\n */\nconst char AMD_DBGAPI *\namd_dbgapi_get_build_name (void) AMD_DBGAPI_VERSION_0_24;\n\n/** @} */\n\n/** \\defgroup initialization_group Initialization and Finalization\n *\n * Operations to control initializing and finalizing the library.\n *\n * When the library is first loaded it is in the uninitialized state.  Before\n * any operation can be used, the library must be initialized.  The exception\n * is the status operation in \\ref status_codes_group and the version\n * operations in \\ref versioning_group which can be used regardless of whether\n * the library is initialized.\n *\n * @{\n */\n\n/**\n * Initialize the library.\n *\n * Initialize the library so that the library functions can be used to control\n * the AMD GPU devices accessed by processes.\n *\n * Initializing the library does not change the logging level (see\n * \\ref logging_group).\n *\n * \\param[in] callbacks A set of callbacks must be provided.  These\n * are invoked by certain operations.  They are described in\n * ::amd_dbgapi_callbacks_t.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the library is now initialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library\n * remains uninitialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_ALREADY_INITIALIZED The library is\n * already initialized.  The library is left initialized and the callbacks are\n * not changed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p callbacks is NULL\n * or has fields that are NULL.  The library remains uninitialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be\n * reported if any of the amd_dbgapi_callbacks_s callbacks used return an\n * error.  The library remains uninitialized.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_initialize (\n    amd_dbgapi_callbacks_t *callbacks) AMD_DBGAPI_VERSION_0_30;\n\n/**\n * Finalize the library.\n *\n * Finalizing the library invalidates all handles previously returned by any\n * operation.  It is undefined to use any such handle even if the library is\n * subsequently initialized with ::amd_dbgapi_initialize.  Finalizing the\n * library implicitly detaches from any processes currently attached.  It is\n * allowed to initialize and finalize the library multiple times.  Finalizing\n * the library does not changed the logging level (see \\ref logging_group).\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the library is now uninitialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library\n * is left uninitialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be reported if\n * any of the ::amd_dbgapi_callbacks_s callbacks used return an error.  The\n * library is still left uninitialized, but the client may be in\n * an inconsistent state.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_finalize (void)\n    AMD_DBGAPI_VERSION_0_24;\n\n/** @} */\n\n/** \\defgroup architecture_group Architectures\n *\n * Operations related to AMD GPU architectures.\n *\n * The library supports a family of AMD GPU devices.  Each device has its own\n * architectural properties.  The operations in this section provide\n * information about the supported architectures.\n *\n * @{\n */\n\n/**\n * Opaque architecture handle.\n *\n * An architecture handle is unique for each AMD GPU model supported by the\n * library.  They are only valid while the library is initialized and are\n * invalidated when the library is uninitialized.\n */\ntypedef struct\n{\n  uint64_t handle;\n} amd_dbgapi_architecture_id_t;\n\n/**\n * The NULL architecture handle.\n */\n#define AMD_DBGAPI_ARCHITECTURE_NONE (amd_dbgapi_architecture_id_t{ 0 })\n\n/**\n * Architecture queries that are supported by\n * ::amd_dbgapi_architecture_get_info.\n *\n * Each query specifies the type of data returned in the \\p value argument to\n * ::amd_dbgapi_architecture_get_info.\n */\ntypedef enum\n{\n  /**\n   * Return the architecture name.  The type of this attribute is a\n   * pointer to a NUL terminated \\p char*.  It is allocated by the\n   * amd_dbgapi_callbacks_s::allocate_memory callback and is owned by the\n   * client.\n   */\n  AMD_DBGAPI_ARCHITECTURE_INFO_NAME = 1,\n  /**\n   * Return the AMD GPU ELF \\p EF_AMDGPU_MACH value corresponding to the\n   * architecture.  This is defined as a bit field in the \\p e_flags AMD GPU\n   * ELF header.  See [User Guide for AMDGPU Backend - Code Object - Header]\n   * (https://llvm.org/docs/AMDGPUUsage.html#header).  The type of this\n   * attribute is \\p uint32_t.\n   */\n  AMD_DBGAPI_ARCHITECTURE_INFO_ELF_AMDGPU_MACHINE = 2,\n  /**\n   * Return the largest instruction size in bytes for the architecture.  The\n   * type of this attribute is ::amd_dbgapi_size_t.\n   */\n  AMD_DBGAPI_ARCHITECTURE_INFO_LARGEST_INSTRUCTION_SIZE = 3,\n  /**\n   * Return the minimum instruction alignment in bytes for the architecture.\n   * The returned value will be a power of two.  The type of this attribute is\n   * ::amd_dbgapi_size_t.\n   */\n  AMD_DBGAPI_ARCHITECTURE_INFO_MINIMUM_INSTRUCTION_ALIGNMENT = 4,\n  /**\n   * Return the breakpoint instruction size in bytes for the architecture.  The\n   * type of this attribute is ::amd_dbgapi_size_t.\n   */\n  AMD_DBGAPI_ARCHITECTURE_INFO_BREAKPOINT_INSTRUCTION_SIZE = 5,\n  /**\n   * Return the breakpoint instruction for the architecture.  The type of this\n   * attribute is pointer to \\p N bytes where \\p N is the value returned by the\n   * ::AMD_DBGAPI_ARCHITECTURE_INFO_BREAKPOINT_INSTRUCTION_SIZE query.  It is\n   * allocated by the amd_dbgapi_callbacks_s::allocate_memory callback and is\n   * owned by the client.\n   */\n  AMD_DBGAPI_ARCHITECTURE_INFO_BREAKPOINT_INSTRUCTION = 6,\n  /**\n   * Return the number of bytes to subtract from the PC after stopping due to a\n   * breakpoint instruction to get the address of the breakpoint instruction\n   * for the architecture.  The type of this attribute is ::amd_dbgapi_size_t.\n   */\n  AMD_DBGAPI_ARCHITECTURE_INFO_BREAKPOINT_INSTRUCTION_PC_ADJUST = 7,\n  /**\n   * Return the register handle for the PC for the architecture.  The type of\n   * this attribute is ::amd_dbgapi_register_id_t.\n   */\n  AMD_DBGAPI_ARCHITECTURE_INFO_PC_REGISTER = 8\n} amd_dbgapi_architecture_info_t;\n\n/**\n * Query information about an architecture.\n *\n * ::amd_dbgapi_architecture_info_t specifies the queries supported and the\n * type returned using the \\p value argument.\n *\n * \\param[in] architecture_id The architecture being queried.\n *\n * \\param[in] query The query being requested.\n *\n * \\param[in] value_size Size of the memory pointed to by \\p value.  Must be\n * equal to the byte size of the query result.\n *\n * \\param[out] value Pointer to memory where the query result is stored.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p value.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARCHITECTURE_ID \\p\n * architecture_id is invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p value is NULL or\n * \\p query is invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT_SIZE \\p value_size does\n * not match the size of the result.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be\n * reported if the amd_dbgapi_callbacks_s::allocate_memory callback used to\n * allocate \\p value returns NULL.  \\p value is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_architecture_get_info (\n    amd_dbgapi_architecture_id_t architecture_id,\n    amd_dbgapi_architecture_info_t query, size_t value_size,\n    void *value) AMD_DBGAPI_VERSION_0_30;\n\n/**\n * Get an architecture from the AMD GPU ELF \\p EF_AMDGPU_MACH value\n * corresponding to the architecture.  This is defined as a bit field in the \\p\n * e_flags AMD GPU ELF header.  See [User Guide for AMDGPU Backend - Code\n * Object\n * - Header] (https://llvm.org/docs/AMDGPUUsage.html#header).\n *\n * \\param[in] elf_amdgpu_machine The AMD GPU ELF \\p EF_AMDGPU_MACH value.\n *\n * \\param[out] architecture_id The corresponding architecture.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p architecture_id.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library\n * is left uninitialized and \\p architecture_id is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p architecture_id is\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ELF_AMDGPU_MACHINE \\p\n * elf_amdgpu_machine is invalid or unsupported.  \\p architecture_id is\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p architecture_id is\n * NULL.  \\p architecture_id is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_get_architecture (\n    uint32_t elf_amdgpu_machine,\n    amd_dbgapi_architecture_id_t *architecture_id) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Opaque client symbolizer handle.\n *\n * A pointer to client data associated with a symbolizer.  This pointer is\n * passed to the ::amd_dbgapi_disassemble_instruction \\p symbolizer callback.\n */\ntypedef struct amd_dbgapi_symbolizer_id_s *amd_dbgapi_symbolizer_id_t;\n\n/**\n * Disassemble a single instruction.\n *\n * \\param[in] architecture_id The architecture to use to perform the\n * disassembly.\n *\n * \\param[in] address The address of the first byte of the instruction.\n *\n * \\param[in,out] size Pass in the number of bytes available in \\p memory which\n * must be greater than 0.  Return the number of bytes consumed to decode the\n * instruction.\n *\n * \\param[in] memory The bytes to decode as an instruction.  Must point to an\n * array of at least \\p size bytes.  The\n * ::AMD_DBGAPI_ARCHITECTURE_INFO_LARGEST_INSTRUCTION_SIZE query for \\p\n * architecture_id can be used to determine the number of bytes of the largest\n * instruction.  By making \\p size at least this size ensures that the\n * instruction can be decoded if legal.  However, \\p size may need to be\n * smaller if no memory exists at the address of \\p address plus \\p size.\n *\n * \\param[out] instruction_text If NULL then only the instruction \\p size is\n * returned.\n *\n * If non-NULL then set to a pointer to a NUL terminated string that contains\n * the disassembled textual representation of the instruction.  The memory is\n * allocated using the amd_dbgapi_callbacks_s::allocate_memory callback and is\n * owned by the client.\n *\n * \\param[in] symbolizer_id The client handle that is passed to any invocation\n * of the \\p symbolizer callback made while disassembling the instruction.\n *\n * \\param[in] symbolizer A callback that is invoked for any operand of the\n * disassembled instruction that is a memory address.  It allows the client to\n * provide a symbolic representation of the address as a textual symbol that\n * will be used in the returned \\p instruction_text.\n *\n * If \\p symbolizer is NULL, then no symbolization will be performed and any\n * memory addresses will be shown as their numeric address.\n *\n * If \\p symbolizer is non-NULL, the \\p symbolizer function will be called with\n * \\p symbolizer_id having the value of the above \\p symbolizer_id operand, and\n * with \\p address having the value of the address of the disassembled\n * instruction's operand.\n *\n * If the \\p symbolizer callback wishes to report a symbol text it must\n * allocate and assign memory for a non-empty NUL terminated \\p char* string\n * using a memory allocator that can be deallocated using the\n * amd_dbgapi_callbacks_s::deallocate_memory callback.  If must assign the\n * pointer to \\p symbol_text, and return ::AMD_DBGAPI_STATUS_SUCCESS.\n *\n * If the \\p symbolizer callback does not wish to report a symbol it must\n * return ::AMD_DBGAPI_STATUS_ERROR_SYMBOL_NOT_FOUND.\n *\n * Any \\p symbol_text strings returned by the \\p symbolizer callbacks reporting\n * ::AMD_DBGAPI_STATUS_SUCCESS are deallocated using the\n * amd_dbgapi_callbacks_s::deallocate_memory callback before\n * ::amd_dbgapi_disassemble_instruction returns.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p size and \\p instruction_text.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p size and \\p instruction_text are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p size and \\p\n * instruction_text are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARCHITECTURE_ID \\p architecture_id\n * is invalid.  \\p size and \\p instruction_text are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p size or \\p memory are\n * NULL; or \\p size is 0.  \\p size and \\p instruction_text are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR Encountered an error disassembling the\n * instruction, a \\p symbolizer callback returned ::AMD_DBGAPI_STATUS_SUCCESS\n * with a NULL or empty \\p symbol_text string. The bytes may or may not be a\n * legal instruction. \\p size and \\p instruction_text are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_ILLEGAL_INSTRUCTION The bytes starting at\n * \\p address, when up to \\p size bytes are available, are not a legal\n * instruction for the architecture.  \\p size and \\p instruction_text are\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be reported if\n * the amd_dbgapi_callbacks_s::allocate_memory callback used to allocate \\p\n * instruction_text returns NULL, or a \\p symbolizer callback returns a status\n * other than ::AMD_DBGAPI_STATUS_SUCCESS and\n * ::AMD_DBGAPI_STATUS_ERROR_SYMBOL_NOT_FOUND.  \\p size and \\p instruction_text\n * are unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_disassemble_instruction (\n    amd_dbgapi_architecture_id_t architecture_id,\n    amd_dbgapi_global_address_t address, amd_dbgapi_size_t *size,\n    const void *memory, char **instruction_text,\n    amd_dbgapi_symbolizer_id_t symbolizer_id,\n    amd_dbgapi_status_t (*symbolizer) (\n        amd_dbgapi_symbolizer_id_t symbolizer_id,\n        amd_dbgapi_global_address_t address,\n        char **symbol_text)) AMD_DBGAPI_VERSION_0_30;\n\n/**\n * The kinds of instruction classifications.\n */\ntypedef enum\n{\n  /**\n   * The instruction classification is unknown.  The instruction has no\n   * properties.\n   */\n  AMD_DBGAPI_INSTRUCTION_KIND_UNKNOWN = 0,\n  /**\n   * The instruction executes sequentially.  It performs no control flow and\n   * the next instruction executed is the following one.  The instruction has\n   * no properties.\n   */\n  AMD_DBGAPI_INSTRUCTION_KIND_SEQUENTIAL = 1,\n  /**\n   * The instruction unconditionally branches to a literal address.  The\n   * instruction properties is of type ::amd_dbgapi_global_address_t with the\n   * value of the target address of the branch.\n   */\n  AMD_DBGAPI_INSTRUCTION_KIND_DIRECT_BRANCH = 2,\n  /**\n   * The instruction conditionally branches to a literal address.  If the\n   * condition is not satisfied then the next instruction is the following one.\n   * The instruction properties is of type ::amd_dbgapi_global_address_t with\n   * the value of the target address of the branch if taken.\n   */\n  AMD_DBGAPI_INSTRUCTION_KIND_DIRECT_BRANCH_CONDITIONAL = 3,\n  /**\n   * The instruction unconditionally branches to an address held in a pair of\n   * registers.  The instruction properties is of type\n   * ::amd_dbgapi_register_id_t[2] with the value of the register IDs for the\n   * registers.  The first register holds the least significant address bits,\n   * and the second register holds the most significant address bits.\n   */\n  AMD_DBGAPI_INSTRUCTION_KIND_INDIRECT_BRANCH_REGISTER_PAIR = 4,\n  /**\n   * The instruction unconditionally branches to a literal address and the\n   * address of the following instruction is saved in a pair of registers.  The\n   * instruction properties is of type ::amd_dbgapi_register_id_t[2] with the\n   * value of the register IDs for the registers.  The register with index 0\n   * holds the least significant address bits, and the register with index 1\n   * holds the most significant address bits.\n   */\n  AMD_DBGAPI_INSTRUCTION_KIND_DIRECT_CALL_REGISTER_PAIR = 5,\n  /**\n   * The instruction unconditionally branches to an address held in a pair of\n   * source registers and the address of the following instruction is saved in\n   * a pair of destintion registers.  The instruction properties is of type\n   * ::amd_dbgapi_register_id_t[4] with the source register IDs in indicies 0\n   * and 1, and the destination register IDs in indicies 2 and 3. The registers\n   * with indicies 0 and 2 hold the least significant address bits, and the\n   * registers with indicies 1 and 3 hold the most significant address bits.\n   */\n  AMD_DBGAPI_INSTRUCTION_KIND_INDIRECT_CALL_REGISTER_PAIRS = 6,\n  /**\n   * The instruction terminates the wave execution.  The instruction has no\n   * properties.\n   */\n  AMD_DBGAPI_INSTRUCTION_KIND_TERMINATE = 7,\n  /**\n   * The instruction enters the trap handler.  The trap handler may return to\n   * resume execution, may halt the wave and create an event for\n   * ::amd_dbgapi_next_pending_event to report, or may terminate the wave.  The\n   * library cannot report execution in the trap handler.  If single stepping\n   * the trap instruction reports the ::AMD_DBGAPI_WAVE_STOP_REASON_SINGLE_STEP\n   * reason, then the program counter will be at the instruction following the\n   * trap instruction, it will not be at the first instruction of the trap\n   * handler. It is undefined to set a breakpoint in the trap handler, and will\n   * likely cause the inferior to report errors and stop executing correctly.\n   * The instruction properties is of type \\p uint64_t with the value of the\n   * trap code.\n   */\n  AMD_DBGAPI_INSTRUCTION_KIND_TRAP = 8,\n  /**\n   * The instruction unconditionally halts the wave.  The instruction has no\n   * properties.\n   */\n  AMD_DBGAPI_INSTRUCTION_KIND_HALT = 9,\n  /**\n   * The instruction performs some kind of execution barrier which may result\n   * in the wave being halted until other waves allow it to continue.  Such\n   * instructions include wave execution barriers, wave synchronization\n   * barriers, and wave semephores.  The instruction has no properties.\n   */\n  AMD_DBGAPI_INSTRUCTION_KIND_BARRIER = 10,\n  /**\n   * The instruction causes the wave to stop executing for some period of time,\n   * before continuing execution with the next instruction.  The instruction\n   * has no properties.\n   */\n  AMD_DBGAPI_INSTRUCTION_KIND_SLEEP = 11,\n  /**\n   * The instruction has some form of special behavior not covered by any of\n   * the other instruction kinds.  This likely makes it unsuitable to assume it\n   * will execute sequentially.  This may include instructions that can affect\n   * the execution of other waves waiting at wave synchronization barriers,\n   * that may send interrupts, and so forth.  The instruction has no\n   * properties.\n   */\n  AMD_DBGAPI_INSTRUCTION_KIND_SPECIAL = 12\n} amd_dbgapi_instruction_kind_t;\n\n/**\n * Classify a single instruction.\n *\n * \\param[in] architecture_id The architecture to use to perform the\n * classification.\n *\n * \\param[in] address The address of the first byte of the instruction.\n *\n * \\param[in,out] size Pass in the number of bytes available in \\p memory which\n * must be greater than 0.  Return the number of bytes consumed to decode the\n * instruction.\n *\n * \\param[in] memory The bytes to decode as an instruction.  Must point to an\n * array of at least \\p size bytes.  The\n * ::AMD_DBGAPI_ARCHITECTURE_INFO_LARGEST_INSTRUCTION_SIZE query for \\p\n * architecture_id can be used to determine the number of bytes of the largest\n * instruction.  By making \\p size at least this size ensures that the\n * instruction can be decoded if legal.  However, \\p size may need to be\n * smaller if no memory exists at the address of \\p address plus \\p size.\n *\n * \\param[out] instruction_kind The classification kind of the instruction.\n *\n * \\param[out] instruction_properties Pointer to the instruction properties\n * that corresponds to the value of \\p instruction_kind.\n * ::amd_dbgapi_instruction_kind_t defines the type of the instruction\n * properties for each instruction kind value.  If the instruction has no\n * properties then NULL is returned.  The memory is allocated using the\n * amd_dbgapi_callbacks_s::allocate_memory callback and is owned by the client.\n * If NULL, no value is returned.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully; and the result is stored in \\p instruction_kind, and \\p\n * instruction_properties.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized; and \\p size, \\p instruction_kind, and \\p\n * instruction_properties are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized; and \\p size and \\p\n * classification are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARCHITECTURE_ID \\p architecture_id\n * is invalid.  \\p size, \\p instruction_kind, and \\p instruction_properties are\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p size, \\p memory, or \\p\n * instruction_kind are NULL; or \\p size is 0.  \\p size, \\p instruction_kind,\n * and \\p instruction_properties are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR Encountered an error disassembling the\n * instruction.  The bytes may or may not be a legal instruction.  \\p size and\n * \\p classification are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_ILLEGAL_INSTRUCTION The bytes starting at\n * \\p address, when up to \\p size bytes are available, are not a legal\n * instruction for the architecture.  \\p size, \\p instruction_kind, and \\p\n * instruction_properties are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be reported if\n * the amd_dbgapi_callbacks_s::allocate_memory callback used to allocate \\p\n * instruction_text and \\p address_operands returns NULL.  \\p size and \\p\n * classification are unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_classify_instruction (\n    amd_dbgapi_architecture_id_t architecture_id,\n    amd_dbgapi_global_address_t address, amd_dbgapi_size_t *size,\n    const void *memory, amd_dbgapi_instruction_kind_t *instruction_kind,\n    void **instruction_properties) AMD_DBGAPI_VERSION_0_24;\n\n/** @} */\n\n/** \\defgroup process_group Processes\n *\n * Operations related to establishing AMD GPU debug control of a process.\n *\n * The library supports AMD GPU debug control of multiple operating system\n * processes.  Each process can have access to multiple AMD GPU devices, but\n * each process uses the AMD GPU devices independently of other processes.\n *\n * @{\n */\n\n/**\n * Opaque client process handle.\n *\n * A pointer to client data associated with a process.  This pointer is passed\n * to the process specific callbacks (see \\ref callbacks_group) to allow the\n * client of the library to identify the process.  Each process must have a\n * single unique value.\n */\ntypedef struct amd_dbgapi_client_process_s *amd_dbgapi_client_process_id_t;\n\n/**\n * Opaque process handle.\n *\n * Unique for a single library initialization.\n *\n * All operations that control an AMD GPU specify the process that is using the\n * AMD GPU with the process handle.  It is undefined to use handles returned by\n * operations performed for one process, with operations performed for a\n * different process.\n */\ntypedef struct\n{\n  uint64_t handle;\n} amd_dbgapi_process_id_t;\n\n/**\n * The NULL process handle.\n */\n#define AMD_DBGAPI_PROCESS_NONE (amd_dbgapi_process_id_t{ 0 })\n\n/**\n * Process queries that are supported by ::amd_dbgapi_process_get_info.\n *\n * Each query specifies the type of data returned in the \\p value argument to\n * ::amd_dbgapi_process_get_info.\n */\ntypedef enum\n{\n  /**\n   * The notifier for the process that indicates if pending events are\n   * available.  The type of this attributes is ::amd_dbgapi_notifier_t.\n   */\n  AMD_DBGAPI_PROCESS_INFO_NOTIFIER = 1,\n  /**\n   * Return the number of data watchpoints supported by the process.  Zero\n   * is returned if data watchpoints are not supported.  The type of this\n   * attribute is \\p size_t.\n   */\n  AMD_DBGAPI_PROCESS_INFO_WATCHPOINT_COUNT = 2,\n  /**\n   * Return how watchpoints are shared between processes.  The type of this\n   * attribute is \\p uint32_t with the values defined by\n   * ::amd_dbgapi_watchpoint_share_kind_t.\n   */\n  AMD_DBGAPI_PROCESS_INFO_WATCHPOINT_SHARE = 3,\n  /**\n   * Return if the architectures of all the agents of a process support\n   * controlling memory precision.  The type of this attribute is \\p uint32_t\n   * with the values defined by ::amd_dbgapi_memory_precision_t.\n   */\n  AMD_DBGAPI_PROCESS_INFO_PRECISE_MEMORY_SUPPORTED = 4,\n  /**\n   * Native operating system process ID.  The type of this attribute is\n   * ::amd_dbgapi_os_process_id_t.\n   */\n  AMD_DBGAPI_PROCESS_INFO_OS_ID = 5\n} amd_dbgapi_process_info_t;\n\n/**\n * Query information about a process.\n *\n * ::amd_dbgapi_process_info_t specifies the queries supported and the\n * type returned using the \\p value argument.\n *\n * \\param[in] process_id The process being queried.\n *\n * \\param[in] query The query being requested.\n *\n * \\param[in] value_size Size of the memory pointed to by \\p value.  Must be\n * equal to the byte size of the query result.\n *\n * \\param[out] value Pointer to memory where the query result is stored.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p value.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p value is NULL or\n * \\p query is invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT_SIZE \\p value_size does\n * not match the size of the result.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be\n * reported if the amd_dbgapi_callbacks_s::allocate_memory callback used to\n * allocate \\p value returns NULL.  \\p value is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_process_get_info (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_process_info_t query,\n    size_t value_size, void *value) AMD_DBGAPI_VERSION_0_36;\n\n/**\n * Attach to a process in order to provide debug control of the AMD GPUs it\n * uses.\n *\n * Attaching can be performed on processes that have not started executing, as\n * well as those that are already executing.\n *\n * The process progress is initialized to ::AMD_DBGAPI_PROGRESS_NORMAL.  All\n * agents accessed by the process are configured to\n * ::AMD_DBGAPI_MEMORY_PRECISION_NONE.\n *\n * The client proccess handle must have been associated with a native operating\n * system process, and the amd_dbgapi_callbacks_s::get_os_pid callback is used\n * to obtain it.\n *\n * If the associated native operating system process exits while the library is\n * attached to it, appropriate actions are taken to reflect that the inferior\n * process no longer has any state.  For example, pending events are created\n * for wave command termination if there are pending wave stop or wave single\n * step requests; a pending code object list updated event is created if there\n * were codes objects previously loaded; a pending runtime event is created to\n * indicate the runtime support has been unloaded if previously loaded; and\n * queries on agents, queues, dispatches, waves, and code objects will report\n * none exist.  The process handle remains valid until\n * ::amd_dbgapi_process_detach is used to detach from the client process.\n *\n * If the associated native operating system process has already exited when\n * attaching, then the attach is still successful, but any queries on agents,\n * queues, dispatches, waves, and code objects will report none exist.\n *\n * If the associated native operating system process exits while a library\n * operation is being executed, then the operation behaves as if the process\n * exited before it was invoked.  For example, a wave operation will report an\n * invalid wave handle, a list query will report an empty list, and so forth.\n *\n * \\param[in] client_process_id The client handle for the process.  It is\n * passed as an argument to any callbacks performed to indicate the process\n * being requested.\n *\n * \\param[out] process_id The process handle to use for all operations related\n * to this process.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the process is now attached returning \\p process_id.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p process_id is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p process_id is\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_ALREADY_ATTACHED The process is already\n * attached.  The process remains attached and \\p process_id is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_RESTRICTION There is a restriction error\n * that prevents debugging process \\p client_process_id.  See\n * ::AMD_DBGAPI_STATUS_ERROR_RESTRICTION for possible reasons.  The process is\n * not attached and \\p process_id is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p client_process_id or\n * \\p process_id are NULL.  The process is not attached and \\p process_id is\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR Encountered some other error while\n * attaching to the process.  The process is not attached and \\p process_id is\n * unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_process_attach (\n    amd_dbgapi_client_process_id_t client_process_id,\n    amd_dbgapi_process_id_t *process_id) AMD_DBGAPI_VERSION_0_30;\n\n/**\n * Detach from a process and no longer have debug control of the AMD GPU\n * devices it uses.\n *\n * If the associated native operating system process has already exited, or\n * exits while being detached, then the process is trivially detached.\n *\n * Otherwise, detaching causes execution of the associated native operating\n * system process to continue unaffected by the library.  Any waves with a\n * displaced stepping buffer are stopped and the displaced stepping buffer\n * completed.  Any data watchpoints are removed.  All agents are configured to\n * ::AMD_DBGAPI_MEMORY_PRECISION_NONE.  Any waves in the stopped or single step\n * state are resumed in non-single step mode.  Any pending events are\n * discarded.\n *\n * After detaching, the process handle becomes invalid.  It is undefined to use\n * any handles returned by previous operations performed with a process handle\n * that has become invalid.\n *\n * A native operating system process can be attached and detached multiple\n * times.  Each attach returns a unique process handle even for the same native\n * operating system process.\n *\n * The client is responsible for removing any inserted breakpoints before\n * detaching.  Failing to do so will cause execution of a breakpoint\n * instruction to put the queue into an error state, aborting any executing\n * waves for dispatches on that queue.\n *\n * \\param process_id The process handle that is being detached.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the process has been detached from the associated native\n * operating system process, or the associated native operating system process\n * has already exited.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID The \\p process_id is\n * invalid.  No process is detached.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_process_detach (\n    amd_dbgapi_process_id_t process_id) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * The kinds of progress supported by the library.\n *\n * In performing operations, the library may make both waves it needs to\n * access, as well as other waves, unavailable for hardware execution.  After\n * completing the operation, it will make all waves available for hardware\n * execution.  This is termed pausing and unpausing wave execution\n * respectively.  Pausing and unpausing waves for each command separately works\n * but can result in longer latency than if several commands could be performed\n * while the waves are paused.  Debugging the very large number of waves that\n * can exist on an AMD GPU can involve many operations, making batching\n * commands even more beneficial.  The progress setting allows controlling this\n * behavior.\n */\ntypedef enum\n{\n  /**\n   * Normal progress is needed.  Commands are issued immediately.  After\n   * completing each command all non-stopped waves will be unpaused.  Switching\n   * from another progress mode to this will unpause any waves that are paused.\n   */\n  AMD_DBGAPI_PROGRESS_NORMAL = 0,\n  /**\n   * No forward progress is needed.  Commands are issued immediately.  After\n   * completing each command, non-stopped waves may be left paused.  The waves\n   * left paused may include both the wave(s) the command operates on, as well\n   * as other waves.  While in ::AMD_DBGAPI_PROGRESS_NO_FORWARD mode, paused\n   * waves may remain paused, or may be unpaused at any point.  Only by leaving\n   * ::AMD_DBGAPI_PROGRESS_NO_FORWARD mode will the library not leave any\n   * waves paused after completing a command.\n   *\n   * Note that the events that ::amd_dbgapi_wave_stop causes to be reported\n   * will occur when in ::AMD_DBGAPI_PROGRESS_NO_FORWARD mode.  It is not\n   * necessary to change the progress mode to ::AMD_DBGAPI_PROGRESS_NORMAL for\n   * those events to be reported.\n   *\n   * This can result in a series of commands completing far faster than in\n   * ::AMD_DBGAPI_PROGRESS_NORMAL mode.  Also, any queries for lists such as\n   * ::amd_dbgapi_wave_list may return \\p unchanged as true more often,\n   * reducing the work needed to parse the lists to determine what has changed.\n   * With large lists this can be significant.  If the client needs a wave to\n   * complete a single step resume, then it must leave\n   * ::AMD_DBGAPI_PROGRESS_NO_FORWARD mode in order to prevent that wave from\n   * remaining paused.\n   */\n  AMD_DBGAPI_PROGRESS_NO_FORWARD = 1\n} amd_dbgapi_progress_t;\n\n/**\n * Set the progress required for a process.\n *\n * \\param[in] process_id The process being controlled.\n *\n * \\param[in] progress The progress being set.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the progress has been set.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  The progress setting is not changed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p progress is invalid.\n * The progress setting is not changed.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_process_set_progress (\n    amd_dbgapi_process_id_t process_id,\n    amd_dbgapi_progress_t progress) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * The kinds of wave creation supported by the hardware.\n *\n * The hardware creates new waves asynchronously as it executes dispatch\n * packets.  If the client requires that all waves are stopped, it needs to\n * first request that the hardware stops creating new waves, followed by\n * halting all already created waves.  The wave creation setting allows\n * controlling how the hardware creates new waves for dispatch packets on\n * queues associated with agents belonging to a specific process.  It has no\n * affect on waves that have already been created.\n */\ntypedef enum\n{\n  /**\n   * Normal wave creation allows new waves to be created.\n   */\n  AMD_DBGAPI_WAVE_CREATION_NORMAL = 0,\n  /**\n   * Stop wave creation prevents new waves from being created.\n   */\n  AMD_DBGAPI_WAVE_CREATION_STOP = 1\n} amd_dbgapi_wave_creation_t;\n\n/**\n * Set the wave creation mode for a process.\n *\n * The setting applies to all agents of the specified process.\n *\n * \\param[in] process_id The process being controlled.\n *\n * \\param[in] creation The wave creation mode being set.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the wave creation mode has been set.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  The wave creation mode setting is not changed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p creation is invalid.\n * The wave creation setting is not changed.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_process_set_wave_creation (\n    amd_dbgapi_process_id_t process_id,\n    amd_dbgapi_wave_creation_t creation) AMD_DBGAPI_VERSION_0_24;\n\n/** @} */\n\n/** \\defgroup code_object_group Code Objects\n *\n * Operations related to AMD GPU code objects loaded into a process.\n *\n * AMD GPU code objects are standard ELF shared libraries defined in\n * [User Guide for AMDGPU Backend - Code Object]\n * (https://llvm.org/docs/AMDGPUUsage.html#code-object).\n *\n * AMD GPU code objects can be embedded in the host executable code object\n * that is loaded into memory or be in a separate file in the file system.\n * The AMD GPU loader supports loading either from memory or from files.  The\n * loader selects the segments to put into memory that contain the code and\n * data necessary for AMD GPU code execution.  It allocates global memory to\n * map these segments and performs necessary relocations to create the loaded\n * code object.\n *\n * @{\n */\n\n/**\n * Opaque code object handle.\n *\n * Only unique within a single process.\n */\ntypedef struct\n{\n  uint64_t handle;\n} amd_dbgapi_code_object_id_t;\n\n/**\n * The NULL code object handle.\n */\n#define AMD_DBGAPI_CODE_OBJECT_NONE (amd_dbgapi_code_object_id_t{ 0 })\n\n/**\n * Code object queries that are supported by ::amd_dbgapi_code_object_get_info.\n *\n * Each query specifies the type of data returned in the \\p value argument to\n * ::amd_dbgapi_code_object_get_info.\n */\ntypedef enum\n{\n  /**\n   * The URI name of the ELF shared object from which the code object was\n   * loaded.  Note that the code object is the in memory loaded relocated form\n   * of the ELF shared object.  Multiple code objects may be loaded at\n   * different memory addresses in the same process from the same ELF shared\n   * object.\n   *\n   * The type of this attribute is a NUL terminated \\p char*.  It is allocated\n   * by the amd_dbgapi_callbacks_s::allocate_memory callback and is owned by\n   * the client.\n   *\n   * The URI name syntax is defined by the following BNF syntax:\n   *\n   *     code_object_uri ::== file_uri | memory_uri\n   *     file_uri        ::== \"file://\" file_path [ range_specifier ]\n   *     memory_uri      ::== \"memory://\" process_id range_specifier\n   *     range_specifier ::== [ \"#\" | \"?\" ] \"offset=\" number \"&\" \"size=\" number\n   *     file_path       ::== URI_ENCODED_OS_FILE_PATH\n   *     process_id      ::== DECIMAL_NUMBER\n   *     number          ::== HEX_NUMBER | DECIMAL_NUMBER | OCTAL_NUMBER\n   *\n   * ``number`` is a C integral literal where hexadecimal values are prefixed\n   * by \"0x\" or \"0X\", and octal values by \"0\".\n   *\n   * ``file_path`` is the file's path specified as a URI encoded UTF-8 string.\n   * In URI encoding, every character that is not in the regular expression\n   * ``[a-zA-Z0-9/_.~-]`` is encoded as two uppercase hexidecimal digits\n   * proceeded by \"%\".  Directories in the path are separated by \"/\".\n   *\n   * ``offset`` is a 0-based byte offset to the start of the code object.  For\n   * a file URI, it is from the start of the file specified by the\n   * ``file_path``, and if omitted defaults to 0. For a memory URI, it is the\n   * memory address and is required.\n   *\n   * ``size`` is the number of bytes in the code object.  For a file URI, if\n   * omitted it defaults to the size of the file.  It is required for a memory\n   * URI.\n   *\n   * ``process_id`` is the identity of the process owning the memory.  For\n   * Linux it is the C unsigned integral decimal literal for the process ID\n   * (PID).\n   *\n   * For example:\n   *\n   *     file:///dir1/dir2/file1\n   *     file:///dir3/dir4/file2#offset=0x2000&size=3000\n   *     memory://1234#offset=0x20000&size=3000\n   */\n  AMD_DBGAPI_CODE_OBJECT_INFO_URI_NAME = 1,\n  /**\n   * The difference between the address in the ELF shared object and the\n   * address the code object is loaded in memory.  The type of this attributes\n   * is \\p ptrdiff_t.\n   */\n  AMD_DBGAPI_CODE_OBJECT_INFO_LOAD_ADDRESS = 2\n} amd_dbgapi_code_object_info_t;\n\n/**\n * Query information about a code object.\n *\n * ::amd_dbgapi_code_object_info_t specifies the queries supported and the\n * type returned using the \\p value argument.\n *\n * \\param[in] process_id The process to which the code object belongs.\n *\n * \\param[in] code_object_id The handle of the code object being queried.\n *\n * \\param[in] query The query being requested.\n *\n * \\param[in] value_size Size of the memory pointed to by \\p value.  Must be\n * equal to the byte size of the query result.\n *\n * \\param[out] value Pointer to memory where the query result is stored.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p value.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_CODE_OBJECT_ID \\p code_object_id\n * is invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p value is NULL or\n * \\p query is invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT_SIZE \\p value_size does\n * not match the size of the result.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be\n * reported if the amd_dbgapi_callbacks_s::allocate_memory callback used to\n * allocate \\p value returns NULL.  \\p value is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_code_object_get_info (\n    amd_dbgapi_process_id_t process_id,\n    amd_dbgapi_code_object_id_t code_object_id,\n    amd_dbgapi_code_object_info_t query, size_t value_size,\n    void *value) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Return the list of loaded code objects for a process.\n *\n * The order of the code object handles in the list is unspecified and can vary\n * between calls.\n *\n * \\param[in] process_id The process for which the code object list is\n * requested.\n *\n * \\param[out] code_object_count The number of code objects currently loaded.\n *\n * \\param[out] code_objects If \\p changed is not NULL and the code object list\n * has not changed since the last call to ::amd_dbgapi_code_object_list then\n * return NULL.  Otherwise, return a pointer to an array of\n * ::amd_dbgapi_code_object_id_t with \\p code_object_count elements.  It is\n * allocated by the amd_dbgapi_callbacks_s::allocate_memory callback and is\n * owned by the client.\n *\n * \\param[in,out] changed If NULL then left unaltered.  If non-NULL, set to\n * ::AMD_DBGAPI_CHANGED_NO if the list of code objects is the same as when\n * ::amd_dbgapi_code_object_list was last called, otherwise set to\n * ::AMD_DBGAPI_CHANGED_YES.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p changed, \\p code_object_count,\n * and \\p code_objects.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized; and \\p code_object_count, \\p code_objects, and \\p\n * changed are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized; and \\p code_object_count,\n * \\p code_objects, and \\p changed are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  \\p code_object_count, \\p code_objects, and \\p changed are\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p code_object_count or\n * \\p code_objects are NULL, or \\p changed is invalid.  \\p code_object_count,\n * \\p code_objects, and \\p changed are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be reported if\n * the amd_dbgapi_callbacks_s::allocate_memory callback used to allocate \\p\n * code_objects returns NULL.  \\p code_object_count, \\p code_objects, and \\p\n * changed are unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_code_object_list (\n    amd_dbgapi_process_id_t process_id, size_t *code_object_count,\n    amd_dbgapi_code_object_id_t **code_objects,\n    amd_dbgapi_changed_t *changed) AMD_DBGAPI_VERSION_0_24;\n\n/** @} */\n\n/** \\defgroup agent_group Agents\n *\n * Operations related to AMD GPU agents accessible to a process.\n *\n * Agent is the term for AMD GPU devices that can be accessed by the process.\n *\n * @{\n */\n\n/**\n * Opaque agent handle.\n *\n * Only unique within a single process.\n */\ntypedef struct\n{\n  uint64_t handle;\n} amd_dbgapi_agent_id_t;\n\n/**\n * The NULL agent handle.\n */\n#define AMD_DBGAPI_AGENT_NONE (amd_dbgapi_agent_id_t{ 0 })\n\n/**\n * Agent queries that are supported by ::amd_dbgapi_agent_get_info.\n *\n * Each query specifies the type of data returned in the \\p value argument to\n * ::amd_dbgapi_agent_get_info.\n */\ntypedef enum\n{\n  /**\n   * Agent name.  The type of this attribute is a poiter to a NUL terminated\n   * \\p char*.  It is allocated by amd_dbgapi_callbacks_s::allocate_memory and\n   * is owned by the client.\n   */\n  AMD_DBGAPI_AGENT_INFO_NAME = 1,\n  /**\n   * Return the architecture of this agent.  The type of this attribute is\n   * ::amd_dbgapi_architecture_id_t.\n   */\n  AMD_DBGAPI_AGENT_INFO_ARCHITECTURE = 2,\n  /**\n   * PCI slot of the agent in BDF format (see [Bus:Device.Function (BDF)\n   * Notation][bfd].\n   * The type of this attribute is \\p uint16_t.\n   */\n  AMD_DBGAPI_AGENT_INFO_PCI_SLOT = 3,\n  /**\n   * PCI vendor ID of the agent.  The type of this attribute is \\p uint32_t.\n   */\n  AMD_DBGAPI_AGENT_INFO_PCI_VENDOR_ID = 4,\n  /**\n   * PCI device ID of the agent.  The type of this attribute is \\p uint32_t.\n   */\n  AMD_DBGAPI_AGENT_INFO_PCI_DEVICE_ID = 5,\n  /**\n   * Total number of Execution Units (EUs) available in the agent.  The type of\n   * this attribute is \\p size_t.\n   */\n  AMD_DBGAPI_AGENT_INFO_EXECUTION_UNIT_COUNT = 6,\n  /**\n   * Maximum number of waves supported by an execution unit.  The type of this\n   * attribute is \\p size_t.\n   */\n  AMD_DBGAPI_AGENT_INFO_MAX_WAVES_PER_EXECUTION_UNIT = 7,\n  /**\n   * Native operating system agent ID.  The type of this attribute is\n   * ::amd_dbgapi_os_agent_id_t.\n   */\n  AMD_DBGAPI_AGENT_INFO_OS_ID = 8\n} amd_dbgapi_agent_info_t;\n\n/**\n * Query information about an agent.\n *\n * ::amd_dbgapi_agent_info_t specifies the queries supported and the type\n * returned using the \\p value argument.\n *\n * \\param[in] process_id The process to which the agent belongs.\n *\n * \\param[in] agent_id The handle of the agent being queried.\n *\n * \\param[in] query The query being requested.\n *\n * \\param[in] value_size Size of the memory pointed to by \\p value.  Must be\n * equal to the byte size of the query result.\n *\n * \\param[out] value Pointer to memory where the query result is stored.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p value.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_AGENT_ID \\p agent_id is invalid.\n * \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p value is NULL or\n * \\p query is invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT_SIZE \\p value_size does\n * not match the size of the result.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be\n * reported if the amd_dbgapi_callbacks_s::allocate_memory callback used to\n * allocate \\p value returns NULL.  \\p value is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_agent_get_info (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_agent_id_t agent_id,\n    amd_dbgapi_agent_info_t query, size_t value_size,\n    void *value) AMD_DBGAPI_VERSION_0_36;\n\n/**\n * Return the list of agents for a process.\n *\n * The order of the agent handles in the list is unspecified and can vary\n * between calls.\n *\n * \\param[in] process_id The process for which the agent list is requested.\n *\n * \\param[out] agent_count The number of agents accessed by the process.\n *\n * \\param[out] agents If \\p changed is not NULL and the agent list has not\n * changed since the last call to ::amd_dbgapi_agent_list then return NULL.\n * Otherwise, return a pointer to an array of ::amd_dbgapi_agent_id_t with \\p\n * agent_count elements.  It is allocated by the\n * amd_dbgapi_callbacks_s::allocate_memory callback and is owned by the client.\n *\n * \\param[in,out] changed If NULL then left unaltered.  If non-NULL, set to\n * ::AMD_DBGAPI_CHANGED_NO if the list of agents is the same as when\n * ::amd_dbgapi_agent_list was last called, otherwise set to\n * ::AMD_DBGAPI_CHANGED_YES.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p changed, \\p agent_count, and \\p\n * agents.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized; and \\p agent_count, \\p agents, and \\p changed are\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized; and \\p agent_count, \\p\n * agents, and \\p changed are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  \\p agent_count, \\p agents, and \\p changed are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p agent_count or \\p\n * agents are NULL, or \\p changed is invalid.  \\p agent_count, \\p agents, and\n * \\p changed are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be reported if\n * the amd_dbgapi_callbacks_s::allocate_memory callback used to allocate \\p\n * agents returns NULL.  \\p agent_count, \\p agents, and \\p changed are\n * unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI\namd_dbgapi_agent_list (amd_dbgapi_process_id_t process_id, size_t *agent_count,\n                       amd_dbgapi_agent_id_t **agents,\n                       amd_dbgapi_changed_t *changed) AMD_DBGAPI_VERSION_0_24;\n\n/** @} */\n\n/** \\defgroup queue_group Queues\n *\n * Operations related to AMD GPU queues.\n *\n * Queues are user mode data structures that allow packets to be inserted that\n * control the AMD GPU agents.  The dispatch packet is used to initiate the\n * execution of a grid of waves.\n *\n * @{\n */\n\n/**\n * Opaque queue handle.\n *\n * Only unique within a single process.\n */\ntypedef struct\n{\n  uint64_t handle;\n} amd_dbgapi_queue_id_t;\n\n/**\n * The NULL queue handle.\n */\n#define AMD_DBGAPI_QUEUE_NONE (amd_dbgapi_queue_id_t{ 0 })\n\n/**\n * Queue queries that are supported by ::amd_dbgapi_queue_get_info.\n *\n * Each query specifies the type of data returned in the \\p value argument to\n * ::amd_dbgapi_queue_get_info.\n */\ntypedef enum\n{\n  /**\n   * Return the agent to which this queue belongs.  The type of this attribute\n   * is ::amd_dbgapi_agent_id_t.\n   */\n  AMD_DBGAPI_QUEUE_INFO_AGENT = 1,\n  /**\n   * Return the architecture of this queue.  The type of this attribute is\n   * ::amd_dbgapi_architecture_id_t.\n   */\n  AMD_DBGAPI_QUEUE_INFO_ARCHITECTURE = 2,\n  /**\n   * Return the queue type.  The type of this attribute is \\p uint32_t with\n   * values from ::amd_dbgapi_os_queue_type_t.\n   */\n  AMD_DBGAPI_QUEUE_INFO_TYPE = 3,\n  /**\n   * Return the queue state.  The type of this attribute is \\p uint32_t with\n   * values from ::amd_dbgapi_queue_state_t.\n   */\n  AMD_DBGAPI_QUEUE_INFO_STATE = 4,\n  /**\n   * Return the reason the queue is in error as a bit set. If the queue is not\n   * in the error state then ::AMD_DBGAPI_QUEUE_ERROR_REASON_NONE is returned.\n   * The type of this attribute is \\p uint64_t with values defined by\n   * ::amd_dbgapi_queue_error_reason_t.\n   */\n  AMD_DBGAPI_QUEUE_INFO_ERROR_REASON = 5,\n  /**\n   * Return the base address of the memory holding the queue packets.  The type\n   * of this attribute is ::amd_dbgapi_global_address_t.\n   */\n  AMD_DBGAPI_QUEUE_INFO_ADDRESS = 6,\n  /**\n   * Return the size in bytes of the memory holding the queue packets.  The\n   * type of this attribute is ::amd_dbgapi_size_t.\n   */\n  AMD_DBGAPI_QUEUE_INFO_SIZE = 7,\n  /**\n   * Native operating system queue ID.  The type of this attribute is\n   * ::amd_dbgapi_os_queue_id_t.\n   */\n  AMD_DBGAPI_QUEUE_INFO_OS_ID = 8\n} amd_dbgapi_queue_info_t;\n\n/**\n * Query information about a queue.\n *\n * ::amd_dbgapi_queue_info_t specifies the queries supported and the type\n * returned using the \\p value argument.\n *\n * \\param[in] process_id The process to which the queue belongs.\n *\n * \\param[in] queue_id The handle of the queue being queried.\n *\n * \\param[in] query The query being requested.\n *\n * \\param[out] value Pointer to memory where the query result is stored.\n *\n * \\param[in] value_size Size of the memory pointed to by \\p value.  Must be\n * equal to the byte size of the query result.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p value.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_QUEUE_ID \\p queue_id is invalid.\n * \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p value is NULL or\n * \\p query is invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT_SIZE \\p value_size does\n * not match the size of the result.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be\n * reported if the amd_dbgapi_callbacks_s::allocate_memory callback used to\n * allocate \\p value returns NULL.  \\p value is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_queue_get_info (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_queue_id_t queue_id,\n    amd_dbgapi_queue_info_t query, size_t value_size,\n    void *value) AMD_DBGAPI_VERSION_0_36;\n\n/**\n * Queue state.\n */\ntypedef enum\n{\n  /**\n   * Queue is in a valid state.\n   */\n  AMD_DBGAPI_QUEUE_STATE_VALID = 1,\n  /**\n   * Queue is in an error state.\n   *\n   * When a queue enters the error state, a wave stop event will be created for\n   * all non-stopped waves.  All waves of the queue will include the\n   * ::AMD_DBGAPI_WAVE_STOP_REASON_QUEUE_ERROR stop reason.\n   */\n  AMD_DBGAPI_QUEUE_STATE_ERROR = 2\n} amd_dbgapi_queue_state_t;\n\n/**\n * A bit mask of the reasons that a queue is in error.\n */\ntypedef enum\n{\n  /**\n   * If none of the bits are set, then the queue is not in the error state.\n   */\n  AMD_DBGAPI_QUEUE_ERROR_REASON_NONE = 0ULL,\n  /**\n   * A packet on the queue is invalid.\n   */\n  AMD_DBGAPI_QUEUE_ERROR_REASON_INVALID_PACKET = (1ULL << 0),\n  /**\n   * A wave on the queue had a memory violation.\n   */\n  AMD_DBGAPI_QUEUE_ERROR_REASON_MEMORY_VIOLATION = (1ULL << 1),\n  /**\n   * A wave on the queue had an assert trap.\n   */\n  AMD_DBGAPI_QUEUE_ERROR_REASON_ASSERT_TRAP = (1ULL << 2),\n  /**\n   * A wave on the queue executed an instruction that caused an error.  The\n   * ::AMD_DBGAPI_WAVE_INFO_STOP_REASON query can be used on the waves of the\n   * queue to determine the exact reason.\n   */\n  AMD_DBGAPI_QUEUE_ERROR_REASON_WAVE_ERROR = (1ULL << 3),\n  /**\n   * A reserved value only present to ensure that the underlying representation\n   * of this enumeration type is \\p uint64_t.\n   */\n  AMD_DBGAPI_QUEUE_ERROR_REASON_RESERVED = (1ULL << 63)\n} amd_dbgapi_queue_error_reason_t;\n\n/**\n * Return the list of queues for a process.\n *\n * The order of the queue handles in the list is unspecified and can vary\n * between calls.\n *\n * \\param[in] process_id The process for which the queue list is requested.\n *\n * \\param[out] queue_count The number of queues accessed by the process.\n *\n * \\param[out] queues If \\p changed is not NULL and the queue list has not\n * changed since the last call to ::amd_dbgapi_queue_list then return NULL.\n * Otherwise, return a pointer to an array of ::amd_dbgapi_queue_id_t with \\p\n * queue_count elements.  It is allocated by the\n * amd_dbgapi_callbacks_s::allocate_memory callback and is owned by the client.\n *\n * \\param[in,out] changed If NULL then left unaltered.  If non-NULL, set to\n * ::AMD_DBGAPI_CHANGED_NO if the list of queues is the same as when\n * ::amd_dbgapi_queue_list was last called, otherwise set to\n * ::AMD_DBGAPI_CHANGED_YES.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p changed, \\p queue_count, and \\p\n * queues.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized; and \\p queue_count, \\p queues, and \\p changed are\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized; and \\p queue_count, \\p\n * queues, and \\p changed are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  \\p queue_count, \\p queues, and \\p changed are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p queue_count or \\p\n * queues are NULL, or \\p changed is invalid.  \\p queue_count, \\p queues, and\n * \\p changed are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be reported if\n * the amd_dbgapi_callbacks_s::allocate_memory callback used to allocate \\p\n * queues returns NULL.  \\p queue_count, \\p queues, and \\p changed are\n * unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI\namd_dbgapi_queue_list (amd_dbgapi_process_id_t process_id, size_t *queue_count,\n                       amd_dbgapi_queue_id_t **queues,\n                       amd_dbgapi_changed_t *changed) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Return the packets for a queue of a process.\n *\n * Since the AMD GPU is asynchronously reading the packets this is only a\n * snapshot of the packets present in the queue, and only includes the packets\n * that the producer has made available to the queue.  In obtaining the\n * snapshot the library may pause the queue processing in order to get a\n * consistent snapshot.\n *\n * The queue packets are returned as a byte block that the client must\n * interpret according to the packet ABI determined by the queue type available\n * using the ::AMD_DBGAPI_QUEUE_TYPE query.  See ::amd_dbgapi_os_queue_type_t.\n *\n * \\param[in] process_id The process of the queue for which the packet list is\n * requested.\n *\n * \\param[in] queue_id The queue for which the packet list is requested.\n *\n * \\param[out] read_packet_id The packet ID for the next packet to be read from\n * the queue. It corresponds to the first packet in \\p packets_bytes.  If \\p\n * packets_byte_size is zero, then the packet ID for the next packet added to\n * the queue.\n *\n * \\param[out] write_packet_id The packet ID for the next packet to be written\n * to the queue. It corresponds to the next packet after the last packet in \\p\n * packets_bytes.  If \\p packets_byte_size is zero, then the packet ID for the\n * next packet added to the queue.\n *\n * \\param[out] packets_byte_size The number of bytes of packets on the queue.\n *\n * \\param[out] packets_bytes If non-NULL, it references a pointer to an array\n * of \\p packets_byte_size bytes which is allocated by the\n * amd_dbgapi_callbacks_s::allocate_memory callback and is owned by the client.\n * If NULL, the packet bytes are not returned, just \\p packets_byte_size.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p read_packet_id, \\p\n * write_packet_id, \\p packets_byte_size and \\p packets_bytes.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized; and \\p read_packet_id, \\p write_packet_id, \\p\n * packets_byte_size and \\p packets_bytes are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized; and \\p read_packet_id, \\p\n * write_packet_id, \\p packets_byte_size and \\p packets_bytes are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  \\p read_packet_id, \\p write_packet_id, \\p packets_byte_size and \\p\n * packets_bytes are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p read_packet_id, \\p\n * write_packet_id, or \\p packets_byte_size are NULL.  \\p read_packet_id, \\p\n * write_packet_id, \\p packets_byte_size and \\p packets_bytes are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_SUPPORTED \\p queue_id has a queue\n * type that is not supported.  \\p read_packet_id, \\p write_packet_id, \\p\n * packets_byte_size and \\p packets_bytes are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR An error was encountered when attempting\n * to access the queue \\p queue_id.  For example, the queue may be corrupted.\n * \\p read_packet_id, \\p write_packet_id, \\p packets_byte_size and \\p\n * packets_bytes are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be reported if\n * the amd_dbgapi_callbacks_s::allocate_memory callback used to allocate \\p\n * packets_bytes returns NULL.  \\p read_packet_id, \\p write_packet_id, \\p\n * packets_byte_size and \\p packets_bytes are unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_queue_packet_list (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_queue_id_t queue_id,\n    amd_dbgapi_os_queue_packet_id_t *read_packet_id, amd_dbgapi_os_queue_packet_id_t *write_packet_id,\n    size_t *packets_byte_size, void **packets_bytes) AMD_DBGAPI_VERSION_0_36;\n\n/** @} */\n\n/** \\defgroup dispatch_group Dispatches\n *\n * Operations related to AMD GPU dispatches.\n *\n * Dispatches are initiated by queue dispatch packets in the format supported\n * by the queue.  See ::amd_dbgapi_os_queue_type_t.  Dispatches are the means that\n * waves are created on the AMD GPU.\n *\n * @{\n */\n\n/**\n * Opaque dispatch handle.\n *\n * Only unique within a single process.\n */\ntypedef struct\n{\n  uint64_t handle;\n} amd_dbgapi_dispatch_id_t;\n\n/**\n * The NULL dispatch handle.\n */\n#define AMD_DBGAPI_DISPATCH_NONE (amd_dbgapi_dispatch_id_t{ 0 })\n\n/**\n * Dispatch queries that are supported by ::amd_dbgapi_dispatch_get_info.\n *\n * Each query specifies the type of data returned in the \\p value argument to\n * ::amd_dbgapi_queue_get_info.\n */\ntypedef enum\n{\n  /**\n   * Return the queue to which this dispatch belongs.  The type of this\n   * attribute is ::amd_dbgapi_queue_id_t.\n   */\n  AMD_DBGAPI_DISPATCH_INFO_QUEUE = 1,\n  /**\n   * Return the agent to which this queue belongs.  The type of this attribute\n   * is\n   * ::amd_dbgapi_agent_id_t.\n   */\n  AMD_DBGAPI_DISPATCH_INFO_AGENT = 2,\n  /**\n   * Return the architecture of this dispatch.  The type of this attribute is\n   * ::amd_dbgapi_architecture_id_t.\n   */\n  AMD_DBGAPI_DISPATCH_INFO_ARCHITECTURE = 3,\n  /**\n   * Return the queue packet ID of the dispatch packet that initiated the\n   * dispatch.  The type of this attribute is \\p\n   * amd_dbgapi_os_queue_packet_id_t.\n   */\n  AMD_DBGAPI_DISPATCH_INFO_OS_QUEUE_PACKET_ID = 4,\n  /**\n   * Return the dispatch barrier setting.  The type of this attribute is\n   * \\p uint32_t with values defined by ::amd_dbgapi_dispatch_barrier_t.\n   */\n  AMD_DBGAPI_DISPATCH_INFO_BARRIER = 5,\n  /**\n   * Return the dispatch acquire fence.  The type of this attribute is\n   * \\p uint32_t with values defined by ::amd_dbgapi_dispatch_fence_scope_t.\n   */\n  AMD_DBGAPI_DISPATCH_INFO_ACQUIRE_FENCE = 6,\n  /**\n   * Return the dispatch release fence.  The type of this attribute is\n   * \\p uint32_t with values defined by ::amd_dbgapi_dispatch_fence_scope_t.\n   */\n  AMD_DBGAPI_DISPATCH_INFO_RELEASE_FENCE = 7,\n  /**\n   * Return the dispatch grid dimensionality.  The type of this attribute is\n   * \\p uint32 with a value of 1, 2, or 3.\n   */\n  AMD_DBGAPI_DISPATCH_INFO_GRID_DIMENSIONS = 8,\n  /**\n   * Return the dispatch workgroup size (work-items) in the X, Y, and Z\n   * dimensions.  The type of this attribute is \\p uint16_t[3].\n   */\n  AMD_DBGAPI_DISPATCH_INFO_WORK_GROUP_SIZES = 9,\n  /**\n   * Return the dispatch grid size (work-items) in the X, Y, and Z dimensions.\n   * The type of this attribute is \\p uint32_t[3].\n   */\n  AMD_DBGAPI_DISPATCH_INFO_GRID_SIZES = 10,\n  /**\n   * Return the dispatch private segment size in bytes.  The type of this\n   * attribute is ::amd_dbgapi_size_t.\n   */\n  AMD_DBGAPI_DISPATCH_INFO_PRIVATE_SEGMENT_SIZE = 11,\n  /**\n   * Return the dispatch group segment size in bytes.  The type of this\n   * attribute is ::amd_dbgapi_size_t.\n   */\n  AMD_DBGAPI_DISPATCH_INFO_GROUP_SEGMENT_SIZE = 12,\n  /**\n   * Return the dispatch kernel argument segment address.  The type of this\n   * attribute is ::amd_dbgapi_global_address_t.\n   */\n  AMD_DBGAPI_DISPATCH_INFO_KERNEL_ARGUMENT_SEGMENT_ADDRESS = 13,\n  /**\n   * Return the dispatch kernel descriptor address.  The type of this attribute\n   * is ::amd_dbgapi_global_address_t.\n   */\n  AMD_DBGAPI_DISPATCH_INFO_KERNEL_DESCRIPTOR_ADDRESS = 14,\n  /**\n   * Return the dispatch kernel code entry address.  The type of this attribute\n   * is ::amd_dbgapi_global_address_t.\n   */\n  AMD_DBGAPI_DISPATCH_INFO_KERNEL_CODE_ENTRY_ADDRESS = 15,\n  /**\n   * Return the dispatch completion event address.  The type of this attribute\n   * is ::amd_dbgapi_global_address_t.  The ABI of the completion event varies\n   * depending on the queue type available using the ::AMD_DBGAPI_QUEUE_TYPE\n   * query.  See ::amd_dbgapi_os_queue_type_t.  If the queue type does not use\n   * completion events, or the dispatch packet does not define a completion\n   * event, then ::amd_dbgapi_dispatch_get_info will return\n   * ::AMD_DBGAPI_STATUS_ERROR_NOT_SUPPORTED.\n   */\n  AMD_DBGAPI_DISPATCH_INFO_KERNEL_COMPLETION_ADDRESS = 16\n} amd_dbgapi_dispatch_info_t;\n\n/**\n * Query information about a dispatch.\n *\n * ::amd_dbgapi_dispatch_info_t specifies the queries supported and the type\n * returned using the \\p value argument.\n *\n * \\param[in] process_id The process to which the queue belongs.\n *\n * \\param[in] dispatch_id The handle of the dispatch being queried.\n *\n * \\param[in] query The query being requested.\n *\n * \\param[in] value_size Size of the memory pointed to by \\p value.  Must be\n * equal to the byte size of the query result.\n *\n * \\param[out] value Pointer to memory where the query result is stored.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p value.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_DISPATCH_ID \\p queue_id is\n * invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_SUPPORTED The requested \\p query is\n * not supported for the specified \\p dispatch_id.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p value is NULL or\n * \\p query is invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT_SIZE \\p value_size does\n * not match the size of the result.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be\n * reported if the amd_dbgapi_callbacks_s::allocate_memory callback used to\n * allocate \\p value returns NULL.  \\p value is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_dispatch_get_info (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_dispatch_id_t dispatch_id,\n    amd_dbgapi_dispatch_info_t query, size_t value_size,\n    void *value) AMD_DBGAPI_VERSION_0_36;\n\n/**\n * Dispatch barrier.\n *\n * Controls when the dispatch will start being executed relative to previous\n * packets on the queue.\n */\ntypedef enum\n{\n  /**\n   * Dispatch has no barrier.\n   */\n  AMD_DBGAPI_DISPATCH_BARRIER_NONE = 0,\n  /**\n   * Dispatch has a barrier.  The dispatch will not be executed until all\n   * proceeding packets on the queue have completed.\n   */\n  AMD_DBGAPI_DISPATCH_BARRIER_PRESENT = 1\n} amd_dbgapi_dispatch_barrier_t;\n\n/**\n * Dispatch memory fence scope.\n *\n * Controls how memory is acquired before a dispatch starts executing and\n * released after the dispatch completes execution.\n */\ntypedef enum\n{\n  /**\n   * There is no fence.\n   */\n  AMD_DBGAPI_DISPATCH_FENCE_SCOPE_NONE = 0,\n  /**\n   * There is a fence with agent memory scope.\n   */\n  AMD_DBGAPI_DISPATCH_FENCE_SCOPE_AGENT = 1,\n  /**\n   * There is a fence with system memory scope.\n   */\n  AMD_DBGAPI_DISPATCH_FENCE_SCOPE_SYSTEM = 2\n} amd_dbgapi_dispatch_fence_scope_t;\n\n/**\n * Return the list of dispatches for a process.\n *\n * The order of the dispatch handles in the list is unspecified and can vary\n * between calls.\n *\n * \\param[in] process_id The process for which the dispatch list is requested.\n *\n * \\param[out] dispatch_count The number of dispatches active for a process.\n *\n * \\param[out] dispatches If \\p changed is not NULL and the dispatch list has\n * not changed since the last call to ::amd_dbgapi_dispatch_list then return\n * NULL.  Otherwise, return a pointer to an array of ::amd_dbgapi_dispatch_id_t\n * with \\p dispatch_count elements.  It is allocated by the\n * amd_dbgapi_callbacks_s::allocate_memory callback and is owned by the client.\n *\n * \\param[in,out] changed If NULL then left unaltered.  If non-NULL, set to\n * ::AMD_DBGAPI_CHANGED_NO if the list of agents is the same as when\n * ::amd_dbgapi_agent_list was last called, otherwise set to\n * ::AMD_DBGAPI_CHANGED_YES.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p changed, \\p dispatch_count, and\n * \\p dispatches.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized; and \\p changed, \\p dispatch_count, and \\p dispatches are\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized; and \\p changed, \\p\n * dispatch_count, and \\p dispatches are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  \\p dispatch_count, \\p dispatches, and \\p changed are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p dispatch_count or \\p\n * dispatches are NULL, or \\p changed is invalid.  \\p dispatch_count, \\p\n * dispatches, and \\p changed are unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_dispatch_list (\n    amd_dbgapi_process_id_t process_id, size_t *dispatch_count,\n    amd_dbgapi_dispatch_id_t **dispatches,\n    amd_dbgapi_changed_t *changed) AMD_DBGAPI_VERSION_0_24;\n\n/** @} */\n\n/** \\defgroup wave_group Wave\n *\n * Operations related to AMD GPU waves.\n *\n * @{\n */\n\n/**\n * Opaque wave handle.\n *\n * Waves are the way the AMD GPU executes code.\n *\n * Only unique within a single process.\n */\ntypedef struct\n{\n  uint64_t handle;\n} amd_dbgapi_wave_id_t;\n\n/**\n * The NULL wave handle.\n */\n#define AMD_DBGAPI_WAVE_NONE (amd_dbgapi_wave_id_t{ 0 })\n\n/**\n * Wave queries that are supported by ::amd_dbgapi_wave_get_info.\n *\n * Each query specifies the type of data returned in the \\p value argument to\n * ::amd_dbgapi_wave_get_info.\n */\ntypedef enum\n{\n  /**\n   * Return the wave's state.  The type of this attribute is \\p uint32_t with\n   * values define by ::amd_dbgapi_wave_state_t.\n   */\n  AMD_DBGAPI_WAVE_INFO_STATE = 1,\n  /**\n   * Return the reason the wave stopped as a bit set.  The type of this\n   * attribute is \\p uint64_t with values defined by\n   * ::amd_dbgapi_wave_stop_reason_t.  The wave must be stopped to make this\n   * query.\n   */\n  AMD_DBGAPI_WAVE_INFO_STOP_REASON = 2,\n  /**\n   * Return the watchpoint(s) the wave triggered.  The type of this attribute\n   * is ::amd_dbgapi_watchpoint_list_t.  The\n   * amd_dbgapi_watchpoint_list_t::count field is set to the number of\n   * watchpoints that were triggered.  The\n   * amd_dbgapi_watchpoint_list_t::watchpoint_ids field is set to a pointer to\n   * an array of ::amd_dbgapi_watchpoint_id_t with\n   * amd_dbgapi_watchpoint_list_t::count elements comprising the triggered\n   * watchpoint handles.  The array is allocated by the\n   * amd_dbgapi_callbacks_s::allocate_memory callback and is owned by the\n   * client.  The wave must be stopped to make this query.\n   */\n  AMD_DBGAPI_WAVE_INFO_WATCHPOINTS = 3,\n  /**\n   * Return the dispatch to which this wave belongs.  The type of this\n   * attribute is ::amd_dbgapi_dispatch_id_t.\n   *\n   * If the dispatch associated with a wave is not available then\n   * ::AMD_DBGAPI_DISPATCH_NONE is returned.  If a wave has no associated\n   * dispatch then the the ::AMD_DBGAPI_WAVE_INFO_WORK_GROUP_COORD query may\n   * return incorrect information.  Note that a wave may not have an associated\n   * dispatch if attaching to a process with already existing waves.\n   */\n  AMD_DBGAPI_WAVE_INFO_DISPATCH = 4,\n  /**\n   * Return the queue to which this wave belongs.  The type of this attribute\n   * is\n   * ::amd_dbgapi_queue_id_t.\n   */\n  AMD_DBGAPI_WAVE_INFO_QUEUE = 5,\n  /**\n   * Return the agent to which this wave belongs.  The type of this attribute\n   * is\n   * ::amd_dbgapi_agent_id_t.\n   */\n  AMD_DBGAPI_WAVE_INFO_AGENT = 6,\n  /**\n   * Return the architecture of this wave.  The type of this attribute is\n   * ::amd_dbgapi_architecture_id_t.\n   */\n  AMD_DBGAPI_WAVE_INFO_ARCHITECTURE = 7,\n  /**\n   * Return the current program counter value of the wave.  The type of this\n   * attribute is ::amd_dbgapi_global_address_t.  The wave must be stopped to\n   * make this query.\n   */\n  AMD_DBGAPI_WAVE_INFO_PC = 8,\n  /**\n   * Return the current execution mask of the wave.  Each bit of the mask maps\n   * to a lane with the least significant bit corresponding to the lane with a\n   * ::amd_dbgapi_lane_id_t value of 0 and so forth.  If the bit is 1 then the\n   * lane is active, otherwise the lane is not active.  The type of this\n   * attribute is \\p uint64_t.  The wave must be stopped to make this query.\n   */\n  AMD_DBGAPI_WAVE_INFO_EXEC_MASK = 9,\n  /**\n   * The wave workgroup coordinate in the dispatch grid dimensions.  The type\n   * of this attribute is \\p uint32_t[3] with elements 1, 2, and 3\n   * corresponding to the X, Y, and Z coordinates respectively.\n   */\n  AMD_DBGAPI_WAVE_INFO_WORK_GROUP_COORD = 10,\n  /**\n   * The wave's number in the workgroup.  The type of this attribute is\n   * \\p uint32_t.  The work-items of a workgroup are mapped to the lanes of the\n   * waves of the workgroup in flattened work-item ID order, with the first\n   * work-item corresponding to lane 0 of wave 0, and so forth.\n   */\n  AMD_DBGAPI_WAVE_INFO_WAVE_NUMBER_IN_WORK_GROUP = 11,\n  /**\n   * The number of lanes supported by the wave.  The type of this attribute is\n   * \\p size_t.\n   */\n  AMD_DBGAPI_WAVE_INFO_LANE_COUNT = 12\n} amd_dbgapi_wave_info_t;\n\n/**\n * Query information about a wave.\n *\n * ::amd_dbgapi_wave_info_t specifies the queries supported and the type\n * returned using the \\p value argument.\n *\n * \\param[in] process_id The process to which the queue belongs.\n *\n * \\param[in] wave_id The handle of the wave being queried.\n *\n * \\param[in] query The query being requested.\n *\n * \\param[in] value_size Size of the memory pointed to by \\p value.  Must be\n * equal to the byte size of the query result.\n *\n * \\param[out] value Pointer to memory where the query result is stored.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p value.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_WAVE_ID \\p wave_id is invalid. \\p\n * value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p value is NULL or \\p\n * query is invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT_SIZE \\p value_size does\n * not match the size of the result.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_WAVE_NOT_STOPPED \\p query has a value of\n * ::amd_dbgapi_wave_info_t that requires the wave to be stopped, but the wave\n * is not stopped.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be reported if\n * the amd_dbgapi_callbacks_s::allocate_memory callback used to allocate \\p\n * value returns NULL.  \\p value is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_wave_get_info (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_wave_id_t wave_id,\n    amd_dbgapi_wave_info_t query, size_t value_size,\n    void *value) AMD_DBGAPI_VERSION_0_30;\n\n/**\n * The execution state of a wave.\n */\ntypedef enum\n{\n  /**\n   * The wave is running.\n   */\n  AMD_DBGAPI_WAVE_STATE_RUN = 1,\n  /**\n   * The wave is running in single-step mode.  It will execute a single\n   * instruction and then stop.\n   */\n  AMD_DBGAPI_WAVE_STATE_SINGLE_STEP = 2,\n  /**\n   * The wave is stopped.\n   *\n   * Note that a wave may stop at any time due to the instructions it executes\n   * or because the queue it is executing on enters the error state.  This will\n   * cause a ::AMD_DBGAPI_EVENT_KIND_WAVE_STOP event to be created.  However,\n   * until ::amd_dbgapi_next_pending_event returns the event, the wave will\n   * continue to be reported as in the ::AMD_DBGAPI_WAVE_STATE_RUN state.  Only\n   * when the ::AMD_DBGAPI_EVENT_KIND_WAVE_STOP event is returned by\n   * ::amd_dbgapi_next_pending_event will the wave will be reported in the\n   * ::AMD_DBGAPI_WAVE_STATE_STOP state.\n   */\n  AMD_DBGAPI_WAVE_STATE_STOP = 3\n} amd_dbgapi_wave_state_t;\n\n/**\n * A bit mask of the reasons that a wave stopped.\n *\n * The stop reason of a wave is available using the\n * ::AMD_DBGAPI_WAVE_INFO_STOP_REASON query.\n */\ntypedef enum\n{\n  /**\n   * If none of the bits are set, then ::amd_dbgapi_wave_stop stopped the\n   * wave.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_NONE = 0ULL,\n  /**\n   * The wave stopped due to executing a breakpoint instruction.  Use the\n   * ::AMD_DBGAPI_ARCHITECTURE_INFO_BREAKPOINT_INSTRUCTION_PC_ADJUST query to\n   * determine the address of the breakpoint instruction.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_BREAKPOINT = (1ULL << 0),\n  /**\n   * The wave stopped due to triggering a data watchpoint.  The\n   * ::AMD_DBGAPI_WAVE_INFO_WATCHPOINTS query can be used to determine which\n   * watchpoint(s) were triggered.\n   *\n   * The program counter may not be positioned at the instruction that caused\n   * the watchpoint(s) to be triggered as the AMD GPU can continue executing\n   * instructions after initiating a memory operation.  If the architecture\n   * supports it, the ::amd_dbgapi_set_memory_precision can be used to control\n   * the precision, but may significantly reduce performance.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_WATCHPOINT = (1ULL << 1),\n  /**\n   * The wave stopped due to completing an instruction single-step.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_SINGLE_STEP = (1ULL << 2),\n  /**\n   * The wave belongs to a queue that is in the error state.\n   *\n   * This is set in both waves that were stopped due to a queue error, as well\n   * as waves that were already stopped when the queue went into the queue\n   * error state.\n   *\n   * A wave that includes this stop reason cannot be resumed using\n   * ::amd_dbgapi_wave_resume.  The wave's queue will be in the queue error\n   * state.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_QUEUE_ERROR = (1ULL << 3),\n  /**\n   * The wave stopped due to triggering an enabled floating point input\n   * denormal exception.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_FP_INPUT_DENORMAL = (1ULL << 4),\n  /**\n   * The wave stopped due to triggering an enabled floating point divide by\n   * zero exception.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_FP_DIVIDE_BY_0 = (1ULL << 5),\n  /**\n   * The wave stopped due to triggering an enabled floating point overflow\n   * exception.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_FP_OVERFLOW = (1ULL << 6),\n  /**\n   * The wave stopped due to triggering an enabled floating point underflow\n   * exception.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_FP_UNDERFLOW = (1ULL << 7),\n  /**\n   * The wave stopped due to triggering an enabled floating point inexact\n   * exception.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_FP_INEXACT = (1ULL << 8),\n  /**\n   * The wave stopped due to triggering an enabled floating point invalid\n   * operation exception.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_FP_INVALID_OPERATION = (1ULL << 9),\n  /**\n   * The wave stopped due to triggering an enabled integer divide by zero\n   * exception.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_INT_DIVIDE_BY_0 = (1ULL << 10),\n  /**\n   * The wave stopped due to executing a debug trap instruction.  The program\n   * counter is left positioned after the trap instruction.  The wave can be\n   * resumed using ::amd_dbgapi_wave_resume.\n   *\n   * The debug trap instruction can be generated using the \\p llvm.debugtrap\n   * compiler intrinsic.  See [User Guide for AMDGPU Backend - Code Conventions\n   * - AMDHSA - Trap Handler ABI]\n   * (https://llvm.org/docs/AMDGPUUsage.html#trap-handler-abi).\n   *\n   * A debug trap can be used to explicitly insert stop points in a program to\n   * help debugging.  They behave as no operations if a debugger is not\n   * connected and stop the wave if executed with the debugger attached.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_DEBUG_TRAP = (1ULL << 11),\n  /**\n   * The wave stopped due to executing an assert trap instruction.  The program\n   * counter is left positioned at the assert trap instruction.\n   *\n   * The trap instruction can be generated using the \\p llvm.trap\n   * compiler intrinsic.  See [User Guide for AMDGPU Backend - Code Conventions\n   * - AMDHSA - Trap Handler ABI]\n   * (https://llvm.org/docs/AMDGPUUsage.html#trap-handler-abi).\n   *\n   * An assert trap can be used to abort the execution of the dispatches\n   * executing on a queue.\n   *\n   * A wave that includes this stop reason cannot be resumed using\n   * ::amd_dbgapi_wave_resume.  The wave's queue will enter the queue error\n   * state and include the ::AMD_DBGAPI_QUEUE_ERROR_REASON_ASSERT_TRAP queue\n   * error reason.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_ASSERT_TRAP = (1ULL << 12),\n  /**\n   * The wave stopped due to executing an trap instruction other than the\n   * ::AMD_DBGAPI_WAVE_STOP_REASON_DEBUG_TRAP or\n   * ::AMD_DBGAPI_WAVE_STOP_REASON_ASSERT_TRAP trap instruction.  The program\n   * counter is left positioned at the trap instruction.\n   *\n   * A wave that includes this stop reason cannot be resumed using\n   * ::amd_dbgapi_wave_resume.  The wave's queue will enter the queue error\n   * state and include the ::AMD_DBGAPI_QUEUE_ERROR_REASON_WAVE_ERROR queue\n   * error reason.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_TRAP = (1ULL << 13),\n  /**\n   * The wave stopped due to triggering a memory violation.\n   *\n   * The program counter may not be positioned at the instruction that caused\n   * the memory violation as the AMD GPU can continue executing instructions\n   * after initiating a memory operation.  If the architecture supports it, the\n   * ::amd_dbgapi_set_memory_precision can be used to control the precision,\n   * but may significantly reduce performance.\n   *\n   * A wave that includes this stop reason cannot be resumed using\n   * ::amd_dbgapi_wave_resume.  The wave's queue will enter the queue error\n   * state and include the ::AMD_DBGAPI_QUEUE_ERROR_REASON_MEMORY_VIOLATION\n   * queue error reason.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_MEMORY_VIOLATION = (1ULL << 14),\n  /**\n   * The wave stopped due to executing an illegal instruction.  The program\n   * counter is left positioned at the illegal instruction.\n   *\n   * A wave that includes this stop reason cannot be resumed using\n   * ::amd_dbgapi_wave_resume.  The wave's queue will enter the queue error\n   * state and include the ::AMD_DBGAPI_QUEUE_ERROR_REASON_WAVE_ERROR queue\n   * error reason.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_ILLEGAL_INSTRUCTION = (1ULL << 15),\n  /**\n   * The wave stopped due to detecting an unrecoverable ECC error.\n   *\n   * The program counter may not be positioned at the instruction that caused\n   * the memory violation as the AMD GPU can continue executing instructions\n   * after initiating a memory operation.  If the architecture supports it, the\n   * ::amd_dbgapi_set_memory_precision can be used to control the precision,\n   * but may significantly reduce performance.\n   *\n   * A wave that includes this stop reason cannot be resumed using\n   * ::amd_dbgapi_wave_resume.  The wave's queue will enter the queue error\n   * state and include the ::AMD_DBGAPI_QUEUE_ERROR_REASON_WAVE_ERROR queue\n   * error reason.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_ECC_ERROR = (1ULL << 16),\n  /**\n   * The wave stopped after causing a hardware fatal halt.\n   *\n   * A wave that includes this stop reason cannot be resumed using\n   * ::amd_dbgapi_wave_resume.  The wave's queue will enter the queue error\n   * state and include the ::AMD_DBGAPI_QUEUE_ERROR_REASON_WAVE_ERROR queue\n   * error reason.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_FATAL_HALT = (1ULL << 17),\n  /**\n   * The wave stopped with an XNACK error.\n   *\n   * A wave that includes this stop reason cannot be resumed using\n   * ::amd_dbgapi_wave_resume.  The wave's queue will enter the queue error\n   * state and include the ::AMD_DBGAPI_QUEUE_ERROR_REASON_WAVE_ERROR queue\n   * error reason.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_XNACK_ERROR = (1ULL << 18),\n  /**\n   * A reserved value only present to ensure that the underlying representation\n   * of this enumeration type is \\p uint64_t.\n   */\n  AMD_DBGAPI_WAVE_STOP_REASON_RESERVED = (1ULL << 63)\n} amd_dbgapi_wave_stop_reason_t;\n\n/**\n * Return the list of existing waves for a process.\n *\n * The order of the wave handles in the list is unspecified and can vary\n * between calls.\n *\n * \\param[in] process_id The process for which the wave list is requested.\n *\n * \\param[out] wave_count The number of waves executing in the process.\n *\n * \\param[out] waves If \\p changed is not NULL and the wave list has not\n * changed since the last call to ::amd_dbgapi_wave_list then return NULL.\n * Otherwise, return a pointer to an array of ::amd_dbgapi_wave_id_t with \\p\n * wave_count elements.  It is allocated by the\n * amd_dbgapi_callbacks_s::allocate_memory callback and is owned by the client.\n *\n * \\param[in,out] changed If NULL then left unaltered.  If non-NULL, set to\n * ::AMD_DBGAPI_CHANGED_NO if the list of waves is the same as when\n * ::amd_dbgapi_wave_list was last called, otherwise set to\n * ::AMD_DBGAPI_CHANGED_YES.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p changed, \\p wave_count, and \\p\n * waves.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized; and \\p changed, \\p wave_count, and \\p waves are\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized; and \\p wave_count, \\p\n * waves, and \\p changed are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  \\p wave_count, \\p waves, and \\p unchanged are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p wave_count or \\p waves\n * are NULL, or \\p changed is invalid.  \\p wave_count, \\p waves, and \\p changed\n * are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be reported if\n * the amd_dbgapi_callbacks_s::allocate_memory callback used to allocate \\p\n * waves returns NULL.  \\p wave_count, \\p waves, and \\p changed are unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI\namd_dbgapi_wave_list (amd_dbgapi_process_id_t process_id, size_t *wave_count,\n                      amd_dbgapi_wave_id_t **waves,\n                      amd_dbgapi_changed_t *changed) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Request a wave to stop executing.\n *\n * The wave may or may not immediately stop.  If the wave does not immediately\n * stop, the stop request is termed outstanding until the wave does stop or the\n * wave terminates before stopping.  When the wave does stop it will create a\n * ::AMD_DBGAPI_EVENT_KIND_WAVE_STOP event.  If the wave terminates before\n * stopping it will create a ::AMD_DBGAPI_EVENT_KIND_WAVE_COMMAND_TERMINATED\n * event.\n *\n * A process in the ::AMD_DBGAPI_PROGRESS_NO_FORWARD progress mode will report\n * the ::AMD_DBGAPI_EVENT_KIND_WAVE_STOP or\n * ::AMD_DBGAPI_EVENT_KIND_WAVE_COMMAND_TERMINATED event.  It is not necessary\n * to change the progress mode to ::AMD_DBGAPI_PROGRESS_NORMAL for these events\n * to be reported.\n *\n * It is not necessary for the process  ::AMD_DBGAPI_PROGRESS_NO_FORWARD\n *\n * It is an error to request a wave to stop that has terminated.  The wave\n * handle will be reported as invalid.  It is up to the client to use\n * ::amd_dbgapi_wave_list to determine what waves have been created and\n * terminated.  No event is reported when a wave is created or terminates.\n *\n * It is an error to request a wave to stop that is already in the\n * ::AMD_DBGAPI_WAVE_STATE_STOP state.\n *\n * It is an error to request a wave to stop for which there is an outstanding\n * ::amd_dbgapi_wave_stop request.\n *\n * Sending a stop request to a wave that has already stopped, but whose\n * ::AMD_DBGAPI_EVENT_KIND_WAVE_STOP event has not yet been returned by\n * ::amd_dbgapi_next_pending_event, is allowed since the wave is still in the\n * ::AMD_DBGAPI_WAVE_STATE_RUN state.  In this case the wave is not affected\n * and the already existing ::AMD_DBGAPI_EVENT_KIND_WAVE_STOP will notify the\n * client that the stop request has completed.  The client must be prepared\n * that a wave may stop for other reasons in response to a stop request.  It\n * can use the ::AMD_DBGAPI_WAVE_INFO_STOP_REASON query to determine if there\n * are other reason(s).  See ::AMD_DBGAPI_WAVE_STATE_STOP for more information.\n *\n * Sending a stop request to a wave that is in the\n * ::AMD_DBGAPI_WAVE_STATE_SINGLE_STEP state will attempt to stop the wave and\n * either report a ::AMD_DBGAPI_EVENT_KIND_WAVE_STOP or\n * ::AMD_DBGAPI_EVENT_KIND_WAVE_COMMAND_TERMINATED event.  If the wave did\n * stop, the setting of the ::AMD_DBGAPI_WAVE_STOP_REASON_SINGLE_STEP stop\n * reason will indicate whether the wave completed the single step.  If the\n * single step does complete, but terminates the wave, then\n * ::AMD_DBGAPI_EVENT_KIND_WAVE_COMMAND_TERMINATED will be reported.\n *\n * Sending a stop request to a wave that is present at the time of the request,\n * and does stop, will result in a ::AMD_DBGAPI_EVENT_KIND_WAVE_STOP event.\n *\n * Sending a stop request to a wave that is present at the time of the request,\n * but terminates before completing the stop request, will result in a\n * ::AMD_DBGAPI_EVENT_KIND_WAVE_COMMAND_TERMINATED event.\n *\n * \\param[in] process_id The process to which the wave belongs.\n *\n * \\param[in] wave_id The wave being requested to stop.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the wave will either report a\n * ::AMD_DBGAPI_EVENT_KIND_WAVE_STOP or\n * ::AMD_DBGAPI_EVENT_KIND_WAVE_COMMAND_TERMINATED event.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library\n * is left uninitialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and no wave is stopped.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  No wave is stopped.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_WAVE_ID \\p wave_id is invalid.  No\n * wave is stopped.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_WAVE_STOPPED The wave is already stopped.\n * The wave remains stopped.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_WAVE_OUTSTANDING_STOP The wave already\n * has an outstanding stop request.  This stop request is ignored and the\n * previous stop request continues to stop the wave.\n */\namd_dbgapi_status_t AMD_DBGAPI\namd_dbgapi_wave_stop (amd_dbgapi_process_id_t process_id,\n                      amd_dbgapi_wave_id_t wave_id) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * The mode in which to resuming the execution of a wave.\n */\ntypedef enum\n{\n  /**\n   * Resume normal execution.\n   */\n  AMD_DBGAPI_RESUME_MODE_NORMAL = 0,\n  /**\n   * Resume execution in in single step mode.\n   */\n  AMD_DBGAPI_RESUME_MODE_SINGLE_STEP = 1\n} amd_dbgapi_resume_mode_t;\n\n/**\n * Resume execution of a stopped wave.\n *\n * The wave can be resumed normally in which case it will be in the\n * ::AMD_DBGAPI_WAVE_STATE_RUN state and be available for the hardware to\n * execute instructions.  Just because it is in the run state does not mean the\n * hardware will start executing instructions immediately as that depends on\n * the AMD GPU hardware scheduler.\n *\n * If while in the ::AMD_DBGAPI_WAVE_STATE_RUN state, the wave encounters\n * something that stops its execution, or ::amd_dbgapi_wave_stop is used to\n * stop the wave execution, then a ::AMD_DBGAPI_EVENT_KIND_WAVE_STOP event will\n * be created.\n *\n * If while in the ::AMD_DBGAPI_WAVE_STATE_RUN state the wave terminates, no\n * event is created.\n *\n * The wave can be resumed in single step mode in which case it will be in the\n * ::AMD_DBGAPI_WAVE_STATE_SINGLE_STEP state.  It is available for the hardware\n * to execute one instruction.  After completing execution of a regular\n * instruction, a ::AMD_DBGAPI_EVENT_KIND_WAVE_STOP event will be created that\n * indicates the wave has stopped.  The stop reason of the wave will include\n * ::AMD_DBGAPI_WAVE_STOP_REASON_SINGLE_STEP.  After completing execution of a\n * wave termination instruction, a\n * ::AMD_DBGAPI_EVENT_KIND_WAVE_COMMAND_TERMINATED event will be created that\n * indicates that the wave has terminated.  On some architectures, a single\n * step that completes with the wave positioned at a wave termination\n * instruction may also report the\n * ::AMD_DBGAPI_EVENT_KIND_WAVE_COMMAND_TERMINATED event.\n *\n * Resuming a wave in single step mode does not necessarily cause it to execute\n * any instructions as it is up to the AMD GPU hardware scheduler to decide\n * what waves to execute.  For example, the AMD GPU hardware scheduler may not\n * execute any instructions of a wave until other waves have terminated.  If\n * the client has stopped other waves this can prevent a wave from ever\n * performing a single step.  The client should handle this gracefully and not\n * rely on a single step request always resulting in a\n * ::AMD_DBGAPI_EVENT_KIND_WAVE_STOP event.  If necessary, the client should\n * respond to the stop events of other waves to allow them to make forward\n * progress, and handle the single step stop request when it finally arrives.\n * If necessary, the client can cancel the single step request by using\n * ::amd_dbgapi_wave_stop and allow the user to attempt it again later when\n * other waves have terminated.\n *\n * It is an error to resume a wave that has terminated.  The wave handle will\n * be reported as invalid.  It is up to the client to use\n * ::amd_dbgapi_wave_list to determine what waves have been created and\n * terminated.  No event is reported when a wave is created or terminates.\n *\n * It is an error to request a wave to resume that is not in the\n * ::AMD_DBGAPI_WAVE_STATE_STOP state, or is in the\n * ::AMD_DBGAPI_WAVE_STATE_STOP state but the ::AMD_DBGAPI_EVENT_KIND_WAVE_STOP\n * event that put it in the stop state has not yet been completed using the\n * ::amd_dbgapi_event_processed operation.  Therefore, it is not allowed to\n * execute multiple resume requests as all but the first one will give an\n * error.\n *\n * It also means it is an error to resume a wave that has already stopped, but\n * whose ::AMD_DBGAPI_EVENT_KIND_WAVE_STOP event has not yet been returned by\n * ::amd_dbgapi_next_pending_event, since the wave is still in the\n * ::AMD_DBGAPI_WAVE_STATE_RUN state.  The ::AMD_DBGAPI_EVENT_KIND_WAVE_STOP\n * must be processed first.\n *\n * Since a resume request can only be sent to a wave that has stopped, there is\n * no issue of the wave terminating while making the request.  However, the\n * wave may terminate after being resumed.  Except for single stepping the wave\n * termination instruction described above, no event is reported when the wave\n * terminates.\n *\n * Sending a resume request to a wave that includes a stop reason that cannot\n * be resumed will report an error.  See ::amd_dbgapi_wave_stop_reason_t.\n *\n * \\param[in] process_id The process to which the wave belongs.\n *\n * \\param[in] wave_id The wave being requested to resume.\n *\n * \\param[in] resume_mode If ::AMD_DBGAPI_RESUME_MODE_NORMAL, then resume\n * normal execution of the wave.  If ::AMD_DBGAPI_RESUME_MODE_SINGLE_STEP, then\n * resume the wave in single step mode.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the wave will either terminate or be stopped.  In either\n * case a ::AMD_DBGAPI_EVENT_KIND_WAVE_STOP event will be reported.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and no wave is resumed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  No wave is resumed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_WAVE_ID \\p wave_id is invalid.  No\n * wave is resumed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p resume_mode is\n * invalid.  No wave is resumed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_WAVE_NOT_STOPPED \\p wave_id is not\n * stopped.  The wave remains running.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_WAVE_NOT_RESUMABLE \\p wave_id is stopped\n * with a reason that includes one that cannot be resumed.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_wave_resume (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_wave_id_t wave_id,\n    amd_dbgapi_resume_mode_t resume_mode) AMD_DBGAPI_VERSION_0_24;\n\n/** @} */\n\n/** \\defgroup displaced_stepping_group Displaced Stepping\n *\n * Operations related to AMD GPU breakpoint displaced stepping.\n *\n * The library supports displaced stepping buffers.  These allow an instruction\n * that is overwritten by a breakpoint instruction to be copied to a buffer and\n * single stepped in that buffer.  This avoids needing to remove the breakpoint\n * instruction by replacing it with the original instruction bytes, single\n * stepping the original instruction, and finally restoring the breakpoint\n * instruction.\n *\n * This allows a client to support non-stop debugging where waves are left\n * executing while others are halted after hitting a breakpoint.  If resuming\n * from a breakpoint involved removing the breakpoint, it could result in the\n * running waves missing the removed breakpoint.\n *\n * When an instruction is copied into a displaced stepping buffer, it may be\n * necessary to modify the instruction, or its register inputs to account for\n * the fact that it is executing at a different address.  Similarly, after\n * single stepping it, registers and program counter may need adjusting.  It\n * may also be possible to know the effect of an instruction and avoid single\n * stepping it at all and simply update the wave state directly.  For example,\n * branches can be trivial to emulate this way.\n *\n * The operations in this section allow displaced stepping buffers to be\n * allocated and used.  They will take care of all the architecture specific\n * details described above.\n *\n * The number of displaced stepping buffers supported by the library is\n * unspecified, but there is always at least one.  It may be possible for the\n * library to share the same displaced stepping buffer with multiple waves. For\n * example, if the waves are at the same breakpoint.  The library will\n * determine when this is possible, but the client should not rely on this.\n * Some waves at the same breakpoint may be able to share while others may not.\n * In general, it is best for the client to single step as many waves as\n * possible to minimize the time to get all waves stepped over the breakpoints.\n *\n * The client may be able to maximize the number of waves it can single step at\n * once by requesting displaced stepping buffers for all waves at the same\n * breakpoint.  Just because there is no displaced stepping buffer for one\n * wave, does not mean another wave cannot be assigned to a displaced stepping\n * buffer through sharing, or through buffers being associated with specific\n * agents or queues.\n *\n * If allocating a displaced stepping buffer indicates that the wave has\n * already been single stepped over the breakpoint, the client can simply\n * resume the wave normally.\n *\n * If allocating a displaced stepping buffer is successful, then the client\n * must resume the wave in single step mode.  When the single step has\n * completed, the buffer can be released, and the wave resumed normally.\n *\n * If the wave does not complete the single step, then the wave can be stopped,\n * and the buffer released.  If the single step did not complete then this will\n * leave the wave still at the breakpoint, and the client can retry stepping\n * over the breakpoint later.\n *\n * If allocating a displaced stepping buffer indicates no more are available,\n * the client must complete using the previously allocated buffers.  It can do\n * that by ensuring the allocated waves are resumed in single step mode, ensure\n * that the waves will make forward progress, and process any reported pending\n * events.  This allows waves to perform the single step, report the single\n * step has completed by an event, and the client's processing of the event\n * will complete the displaced stepping buffer.  That may free up a displaced\n * stepping buffer for use by the client for other waves.  Since there is\n * always at least one displaced stepping buffer, in general, the worst case is\n * that one wave at a time can be single stepped over a breakpoint using a\n * displaced stepping buffer.\n *\n * However, the weak forward progress of AMD GPU execution can result in no\n * waves that have successfully been allocated a displaced stepping buffer from\n * actually reporting completion of the single step.  For example, this can\n * happen if the waves being single stepped are prevented from becoming\n * resident on the hardware due to other waves that are halted.  The waves\n * being single stepped can be stopped before completing the single step to\n * release the displaced stepping buffer for use by a different set of waves.\n * In the worst case, the user may have to continue halted waves and allow them\n * to terminate before other waves can make forward progress to complete the\n * single step using a displaced stepping buffer.\n *\n * \\sa ::amd_dbgapi_wave_resume, ::amd_dbgapi_wave_stop,\n * ::amd_dbgapi_process_set_progress, ::amd_dbgapi_next_pending_event\n *\n * @{\n */\n\n/**\n * Opaque displaced stepping handle.\n *\n * Only unique within a single process.\n */\ntypedef struct\n{\n  uint64_t handle;\n} amd_dbgapi_displaced_stepping_id_t;\n\n/**\n * The NULL displaced stepping handle.\n */\n#define AMD_DBGAPI_DISPLACED_STEPPING_NONE                                    \\\n  (amd_dbgapi_displaced_stepping_id_t{ 0 })\n\n/**\n * Create a displaced stepping buffer.\n *\n * The wave must be stopped.\n *\n * Displaced stepping buffers are intended to be used to step over breakpoints.\n * In that case, the wave will be stopped with a program counter set to a\n * breakpoint instruction that was placed by the client overwriting all or part\n * of the original instruction where the breakpoint was placed.  The client\n * must provide the overwritten bytes of the original instruction.\n *\n * If ::AMD_DBGAPI_DISPLACED_STEPPING_NONE is returned successfully it\n * indicates the wave has been single stepped over the breakpoint.  The wave is\n * still stopped and is available to be resumed normally.\n *\n * If a displaced stepping handle is returned successfully, the wave is still\n * stopped.  The wave program counter and other registers may be changed so the\n * client should flush any cached register values.  The client should resume\n * the wave in single step mode using ::amd_dbgapi_wave_resume.  Once the\n * single step is complete as indicated by the\n * ::AMD_DBGAPI_EVENT_KIND_WAVE_STOP event with a stop reason that includes\n * ::AMD_DBGAPI_WAVE_STOP_REASON_SINGLE_STEP, the client should use\n * ::amd_dbgapi_displaced_stepping_complete to release the displaced stepping\n * buffer.  The wave can then be resumed normally using\n * ::amd_dbgapi_wave_resume.\n *\n * If the single step is cancelled by stopping the wave, the client must\n * determine if the wave completed the single step to determine if the wave can\n * be resumed or must retry the displaced stepping later.  See\n * ::amd_dbgapi_wave_stop.\n *\n * \\param[in] process_id The process to which the wave belongs.\n *\n * \\param[in] wave_id The wave to create a displaced stepping buffer.\n *\n * \\param[in] saved_instruction_bytes The original instruction bytes that the\n * breakpoint instruction replaced.  The number of bytes must be\n * ::AMD_DBGAPI_ARCHITECTURE_INFO_BREAKPOINT_INSTRUCTION_SIZE.\n *\n * \\param[out] displaced_stepping The displace stepping handle, or\n * ::AMD_DBGAPI_DISPLACED_STEPPING_NONE.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and \\p displaced_stepping is set to\n * ::AMD_DBGAPI_DISPLACED_STEPPING_NONE or to a valid displaced stepping\n * handle.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized, no displaced stepping buffer is allocated, and \\p\n * displaced_stepping is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized, no displaced stepping\n * buffer is allocated, and \\p displaced_stepping is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  No displaced stepping buffer is allocated and \\p\n * displaced_stepping is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_WAVE_ID \\p wave_id is invalid.  No\n * displaced stepping buffer is allocated and \\p displaced_stepping is\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_WAVE_NOT_STOPPED \\p wave_id is not\n * stopped.  No displaced stepping buffer is allocated and \\p\n * displaced_stepping is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_DISPLACED_STEPPING_BUFFER_UNAVAILABLE No\n * more displaced stepping buffers are available that are suitable for use by\n * \\p wave_id.  No displaced stepping buffer is allocated and \\p\n * displaced_stepping is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p original_instruction\n * or \\p displaced_stepping are NULL.  No displaced stepping buffer is\n * allocated and \\p displaced_stepping is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_displaced_stepping_start (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_wave_id_t wave_id,\n    const void *saved_instruction_bytes,\n    amd_dbgapi_displaced_stepping_id_t *displaced_stepping)\n    AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Complete a displaced stepping buffer for a wave.\n *\n * The wave must be stopped and have been set to use the stepping buffer by\n * using ::amd_dbgapi_displaced_stepping_start.\n *\n * If the wave single step has not completed the wave state is reset to what it\n * was before ::amd_dbgapi_displaced_stepping_start.  The wave is left stopped\n * and the client can retry stepping over the breakpoint again later.\n *\n * If the single step has completed, then the wave state is updated to be after\n * the instruction at which the breakpoint instruction is placed.  The wave\n * program counter and other registers may be changed so the client should\n * flush any cached register values.  The wave is left stopped and can be\n * resumed normally by the client.\n *\n * If the wave is the last one using the displaced stepping buffer, the buffer\n * is freed and the handle invalidated.\n *\n * \\param[in] process_id The process to which the wave belongs.\n *\n * \\param[in] wave_id The wave using the displaced stepping buffer.\n *\n * \\param[in] displaced_stepping The displaced stepping buffer to complete.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully.  The displaced stepping buffer is completed, and the wave is\n * either stepped over the breakpoint, or still at the breakpoint.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized, and no displaced stepping buffer is completed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized, no displaced stepping\n * buffer completed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  No displaced stepping buffer is completed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_WAVE_ID \\p wave_id is invalid.  No\n * displaced stepping buffer is completed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_DISPLACED_STEPPING_ID \\p\n * displaced_stepping is invalid or not in use by \\p wave_id.  No displaced\n * stepping buffer is completed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_WAVE_NOT_STOPPED \\p wave_id is not\n * stopped.  No displaced stepping buffer is completed.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_displaced_stepping_complete (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_wave_id_t wave_id,\n    amd_dbgapi_displaced_stepping_id_t displaced_stepping)\n    AMD_DBGAPI_VERSION_0_24;\n\n/** @} */\n\n/** \\defgroup watchpoint_group Watchpoints\n *\n * Operations related to AMD GPU hardware data watchpoints.\n *\n * A data watchpoint is a hardware supported mechanism to generate wave stop\n * events after a wave accesses memory in a certain way in a certain address\n * range.  The memory access will have been completed before the event is\n * reported.\n *\n * The number of watchpoints, the granularity of base address, and the address\n * range is process specific.  If a process has multiple agents, then the\n * values are the lowest common denominator of the capabilities of the\n * architectures of all the agents of a process.\n *\n * The number of watchpoints supported by a process is available using the\n * ::AMD_DBGAPI_PROCESS_INFO_WATCHPOINT_COUNT query and may be 0.  The\n * ::AMD_DBGAPI_PROCESS_INFO_WATCHPOINT_SHARE query can be used to determine if\n * watchpoints are shared between processes.\n *\n * When a wave stops due to a data watchpoint the stop reason will include\n * ::AMD_DBGAPI_WAVE_STOP_REASON_WATCHPOINT.  The set of watchpoints triggered\n * can be queried using ::AMD_DBGAPI_WAVE_INFO_WATCHPOINTS.\n *\n * @{\n */\n\n/**\n * Opaque hardware data watchpoint handle.\n *\n * Only unique within a single process.\n */\ntypedef struct\n{\n  uint64_t handle;\n} amd_dbgapi_watchpoint_id_t;\n\n/**\n * The NULL hardware data watchpoint handle.\n */\n#define AMD_DBGAPI_WATCHPOINT_NONE (amd_dbgapi_watchpoint_id_t{ 0 })\n\n/**\n * The way watchpoints are shared between processes.\n *\n * The ::AMD_DBGAPI_ARCHITECTURE_INFO_WATCHPOINT_SHARE query can be used to\n * determine the watchpoint sharing for an architecture.\n */\ntypedef enum\n{\n  /**\n   * Watchpoints are not supported.\n   */\n  AMD_DBGAPI_WATCHPOINT_SHARE_KIND_UNSUPPORTED = 0,\n  /**\n   * The watchpoints are not shared across processes.  Every process can use\n   * all\n   * ::AMD_DBGAPI_PROCESS_INFO_WATCHPOINT_COUNT watchpoints.\n   */\n  AMD_DBGAPI_WATCHPOINT_SHARE_KIND_UNSHARED = 1,\n  /**\n   * The watchpoints of a process are shared between all processes.  The number\n   * of watchpoints available to a process may be reduced if watchpoints are\n   * used by another process.\n   */\n  AMD_DBGAPI_WATCHPOINT_SHARE_KIND_SHARED = 2\n} amd_dbgapi_watchpoint_share_kind_t;\n\n/**\n * Watchpoint memory access kinds.\n *\n * The watchpoint is triggered only when the memory instruction is of the\n * specified kind.\n */\ntypedef enum\n{\n  /**\n   * Read access by load instructions.\n   */\n  AMD_DBGAPI_WATCHPOINT_KIND_LOAD = 1,\n  /**\n   * Write access by store instructions or read-modify-write access by atomic\n   * instructions.\n   */\n  AMD_DBGAPI_WATCHPOINT_KIND_STORE_AND_RMW = 2,\n  /**\n   * Read-modify-write access by atomic instructions.\n   */\n  AMD_DBGAPI_WATCHPOINT_KIND_RMW = 3,\n  /**\n   * Read, write, or read-modify-write access by load, store, or atomic\n   * instructions.\n   */\n  AMD_DBGAPI_WATCHPOINT_KIND_ALL = 4\n} amd_dbgapi_watchpoint_kind_t;\n\n/**\n * A set of watchpoints.\n *\n * Used by the ::AMD_DBGAPI_WAVE_INFO_WATCHPOINTS query to report the\n * watchpoint(s) triggered by a wave.\n */\ntypedef struct\n{\n  size_t count;\n  amd_dbgapi_watchpoint_id_t *watchpoint_ids;\n} amd_dbgapi_watchpoint_list_t;\n\n/**\n * Set a hardware data watchpoint.\n *\n * The AMD GPU has limitations on the base address and size of hardware data\n * watchpoints that can be set, and the limitations may vary by architecture. A\n * watchpoint is created with the smallest range, supported by the\n * architectures of all the agents of a process, that covers the requested\n * range specified by \\p address and \\p size.\n *\n * If the requested range is larger than is supported by the architectures of\n * all the agents of a process, then a watchpoint is created with the smallest\n * range that includes \\p address and covers as much of the requested range as\n * possible.\n *\n * The range of the created watchpoint is returned in \\p watchpoint_address and\n * \\p watchpoint_size.  The client is responsible for determining if the\n * created watchpoint completely covers the requested range.  If it does not,\n * the client can attempt to create additional watchpoints for the uncovered\n * portion of the requested range.\n *\n * When a watchpoint is triggered, the client is responsible for determining if\n * the access was to the requested range.  For example, for writes the client\n * can compare the original value with the current value to determine if it\n * changed.\n *\n * Each process has its own set of watchpoints.  Only waves executing on the\n * agents of a process will trigger the watchpoints set on that process.\n *\n * \\param[in] process_id The process on which to set the watchpoint.\n *\n * \\param[in] address The base address of memory area to set a watchpoint.\n *\n * \\param[in] size The non-zero number of bytes that the watchpoint should\n * cover.\n *\n * \\param[in] kind The kind of memory access that should trigger the\n * watchpoint.\n *\n * \\param[out] watchpoint_id The watchpoint created.\n *\n * \\param[out] watchpoint_address The base address of the created watchpoint.\n *\n * \\param[out] watchpoint_size The byte size of the created watchpoint.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the watchpoint has been created with handle \\p\n * watchpoint_id that covers the range specified by \\p watchpoint_address and\n * \\p watchpoint_size.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized; and \\p watchpoint_id, \\p watchpoint_address, and \\p\n * watchpoint_size are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized; and \\p watchpoint_id, \\p\n * watchpoint_address, and \\p watchpoint_size are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  No watchpoint is set and \\p watchpoint_id, \\p watchpoint_address,\n * and \\p watchpoint_size are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NO_WATCHPOINT_AVAILABLE No more\n * watchpoints are available.  No watchpoint is set and \\p watchpoint_id, \\p\n * watchpoint_address, and \\p watchpoint_size are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_SUPPORTED Watchpoints are not\n * supported for the architectures of all the agents.  No watchpoint is set and\n * \\p watchpoint_id, \\p watchpoint_address, and \\p watchpoint_size are\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p kind is invalid; \\p\n * size is 0; or \\p watchpoint_id, \\p watchpoint_address, or \\p watchpoint_size\n * are NULL.  No watchpoint is set and \\p watchpoint_id, \\p watchpoint_address,\n * and \\p watchpoint_size are unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_set_watchpoint (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_global_address_t address,\n    amd_dbgapi_size_t size, amd_dbgapi_watchpoint_kind_t kind,\n    amd_dbgapi_watchpoint_id_t *watchpoint_id,\n    amd_dbgapi_global_address_t *watchpoint_address,\n    amd_dbgapi_size_t *watchpoint_size) AMD_DBGAPI_VERSION_0_36;\n\n/**\n * Remove a hardware data watchpoint previously set by\n * ::amd_dbgapi_set_watchpoint.\n *\n * \\param[in] process_id The process that owns the watchpoint.\n *\n * \\param[in] watchpoint_id The watchpoint to remove.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the watchpoint has been removed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and no watchpoint is\n * removed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  No watchpoint is removed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_WATCHPOINT_ID \\p watchpoint_id is\n * invalid.  No watchpoint is removed.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_remove_watchpoint (\n    amd_dbgapi_process_id_t process_id,\n    amd_dbgapi_watchpoint_id_t watchpoint_id) AMD_DBGAPI_VERSION_0_24;\n\n/** @} */\n\n/** \\defgroup register_group Registers\n *\n * Operations related to AMD GPU register access.\n *\n * @{\n */\n\n/**\n * Opaque register class handle.\n *\n * A handle that denotes the set of classes of hardware registers supported by\n * an architecture.  The registers of the architecture all belong to one or\n * more register classes.  The register classes are a convenience for grouping\n * registers that have similar uses and properties.  They can be useful when\n * presenting register lists to a user.  For example, there could be a register\n * class for \\e system, \\e general, and \\e vector.\n *\n * The handle is only unique within a specific architecture.\n */\ntypedef struct\n{\n  uint64_t handle;\n} amd_dbgapi_register_class_id_t;\n\n/**\n * The NULL register class handle.\n */\n#define AMD_DBGAPI_REGISTER_CLASS_NONE (amd_dbgapi_register_class_id_t{ 0 })\n\n/**\n * Register class queries that are supported by\n * ::amd_dbgapi_architecture_register_class_get_info.\n *\n * Each query specifies the type of data returned in the \\p value argument to\n * ::amd_dbgapi_architecture_register_class_get_info.\n */\ntypedef enum\n{\n  /**\n   * Return the register class name.  The type of this attribute is a pointer\n   * to a NUL terminated \\p char.  It is allocated by the\n   * amd_dbgapi_callbacks_s::allocate_memory callback and is owned by the\n   * client.\n   */\n  AMD_DBGAPI_REGISTER_CLASS_INFO_NAME = 1\n} amd_dbgapi_register_class_info_t;\n\n/**\n * Query information about a register class of an architecture.\n *\n * ::amd_dbgapi_register_class_info_t specifies the queries supported and the\n * type returned using the \\p value argument.\n *\n * \\param[in] architecture_id The architecture to which the register class\n * belongs.\n *\n * \\param[in] register_class_id The handle of the register class being queried.\n *\n * \\param[in] query The query being requested.\n *\n * \\param[in] value_size Size of the memory pointed to by \\p value.  Must be\n * equal to the byte size of the query result.\n *\n * \\param[out] value Pointer to memory where the query result is stored.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p value.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARCHITECTURE_ID \\p\n * architecture_id is invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_REGISTER_CLASS_ID \\p\n * register_class_id is invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p value is NULL or\n * \\p query is invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT_SIZE \\p value_size does\n * not match the size of the result.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be\n * reported if the amd_dbgapi_callbacks_s::allocate_memory callback used to\n * allocate \\p value returns NULL.  \\p value is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI\namd_dbgapi_architecture_register_class_get_info (\n    amd_dbgapi_architecture_id_t architecture_id,\n    amd_dbgapi_register_class_id_t register_class_id,\n    amd_dbgapi_register_class_info_t query, size_t value_size,\n    void *value) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Report the list of register classes supported by the architecture.\n *\n * The order of the register handles in the list is stable between calls.\n *\n * \\param[in] architecture_id The architecture being queried.\n *\n * \\param[out] register_class_count The number of architecture register\n * classes.\n *\n * \\param[out] register_classes A pointer to an array of\n * ::amd_dbgapi_register_class_id_t with \\p register_class_count elements.  It\n * is allocated by the amd_dbgapi_callbacks_s::allocate_memory callback and\n * is owned by the client.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p register_class_count and\n * \\p register_classes.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized; and \\p register_class_count and \\p register_classes are\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized; and \\p register_class_count\n * and \\p register_classes are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARCHITECTURE_ID \\p\n * architecture_id is invalid.  \\p register_class_count and \\p register_classes\n * are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p register_class_count\n * or \\p register_classes are NULL.  \\p register_class_count and\n * \\p register_classes are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be\n * reported if the amd_dbgapi_callbacks_s::allocate_memory callback used to\n * allocate \\p register_classes returns NULL.  \\p register_class_count and\n * \\p register_classes are unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_architecture_register_class_list (\n    amd_dbgapi_architecture_id_t architecture_id, size_t *register_class_count,\n    amd_dbgapi_register_class_id_t **register_classes) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Opaque register handle.\n *\n * A handle that denotes the set of hardware registers supported by an\n * architecture.\n *\n * The handle is only unique within a specific architecture.\n */\ntypedef struct\n{\n  uint64_t handle;\n} amd_dbgapi_register_id_t;\n\n/**\n * The NULL register handle.\n */\n#define AMD_DBGAPI_REGISTER_NONE (amd_dbgapi_register_id_t{ 0 })\n\n/**\n * Register queries that are supported by\n * ::amd_dbgapi_architecture_register_get_info and\n * ::amd_dbgapi_wave_register_get_info.\n *\n * Each query specifies the type of data returned in the \\p value argument to\n * ::amd_dbgapi_architecture_register_get_info and\n * ::amd_dbgapi_wave_register_get_info.\n */\ntypedef enum\n{\n  /**\n   * Return the register name.  The type of this attribute is a pointer to a\n   * NUL terminated \\p char.  It is allocated by the\n   * amd_dbgapi_callbacks_s::allocate_memory callback and is owned by the\n   * client.\n   */\n  AMD_DBGAPI_REGISTER_INFO_NAME = 1,\n  /**\n   * Return the size of the register in bytes.  The size of a register may vary\n   * depending on the lane count of the wave which can be obtained by the\n   * ::AMD_DBGAPI_WAVE_INFO_LANE_COUNT query.  For example, the execution mask\n   * register, condition code register, and all vector registers vary by the\n   * lane count of the wave.  Not supported for the\n   * ::amd_dbgapi_architecture_register_get_info.  The type of this attribute\n   * is ::amd_dbgapi_size_t.\n   */\n  AMD_DBGAPI_REGISTER_INFO_SIZE = 2,\n  /**\n   * Return the register type as a C style type string.  This can be used as\n   * the default type to use when displaying values of the register.  The type\n   * string syntax is defined by the following BNF syntax:\n   *\n   *     type ::= integer_type  | float_type | array_type | function_type\n   *     integer_type ::= \"uint32\" | \"uint64\"\n   *     float_type ::=  \"float\" | \"double\"\n   *     array_type ::= ( integer_type | float_type ) \"[\" integer \"]\"\n   *     function_type ::= \"void(void)\"\n   *     integer ::= digit | ( digit integer )\n   *     digit ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"\n   *\n   * The type size matches the size of the register.  \\p uint32 and \\p float\n   * types are 4 bytes.  \\p unit64 and \\p double types are 8 bytes.  \\p\n   * void(void) is the size of a global address.\n   *\n   * The type of this attribute is a pointer to a NUL terminated \\p char.  It\n   * is allocated by the amd_dbgapi_callbacks_s::allocate_memory callback and\n   * is owned by the client.\n   */\n  AMD_DBGAPI_REGISTER_INFO_TYPE = 3\n} amd_dbgapi_register_info_t;\n\n/**\n * Query information about a register of an architecture.\n *\n * ::amd_dbgapi_register_info_t specifies the queries supported and the type\n * returned using the \\p value argument.\n *\n * \\param[in] architecture_id The architecture to which the register belongs.\n *\n * \\param[in] register_id The handle of the register being queried.\n *\n * \\param[in] query The query being requested.\n *\n * \\param[in] value_size Size of the memory pointed to by \\p value.  Must be\n * equal to the byte size of the query result.\n *\n * \\param[out] value Pointer to memory where the query result is stored.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p value.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARCHITECTURE_ID \\p wave_id is\n * invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_REGISTER_ID \\p register_id is\n * invalid for \\p architecture_id.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p value is NULL, or \\p\n * query is invalid or not supported for an architecture.  \\p value is\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT_SIZE \\p value_size does\n * not match the size of the result.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be reported if\n * the amd_dbgapi_callbacks_s::allocate_memory callback used to allocate \\p\n * value returns NULL.  \\p value is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_architecture_register_get_info (\n    amd_dbgapi_architecture_id_t architecture_id,\n    amd_dbgapi_register_id_t register_id, amd_dbgapi_register_info_t query,\n    size_t value_size, void *value) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Query information about a register of a wave.\n *\n * ::amd_dbgapi_register_info_t specifies the queries supported and the\n * type returned using the \\p value argument.\n *\n * \\param[in] process_id The process to which the wave belongs.\n *\n * \\param[in] wave_id The wave to which the register belongs.\n *\n * \\param[in] register_id The handle of the register being queried.\n *\n * \\param[in] query The query being requested.\n *\n * \\param[in] value_size Size of the memory pointed to by \\p value.  Must be\n * equal to the byte size of the query result.\n *\n * \\param[out] value Pointer to memory where the query result is stored.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p value.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_WAVE_ID \\p wave_id is invalid.\n * \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_REGISTER_ID \\p register_id is\n * invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p value is NULL or\n * \\p query is invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT_SIZE \\p value_size does\n * not match the size of the result.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be\n * reported if the amd_dbgapi_callbacks_s::allocate_memory callback used to\n * allocate \\p value returns NULL.  \\p value is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_wave_register_get_info (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_wave_id_t wave_id,\n    amd_dbgapi_register_id_t register_id, amd_dbgapi_register_info_t query,\n    size_t value_size, void *value) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Report the list of registers supported by the architecture.\n *\n * This list is all the registers the architecture can support, but a specific\n * wave may not have all these registers.  For example, AMD GPU architectures\n * can specify the number of vector and scalar registers when a wave is\n * created.  Use the ::amd_dbgapi_wave_register_list operation to determine the\n * registers supported by a specific wave.\n *\n * The order of the register handles in the list is stable between calls and\n * registers on the same major class are contiguous in ascending hardware\n * number order.\n *\n * \\param[in] architecture_id The architecture being queried.\n *\n * \\param[out] register_count The number of architecture registers.\n *\n * \\param[out] registers A pointer to an array of ::amd_dbgapi_register_id_t\n * with \\p register_count elements.  It is allocated by the\n * amd_dbgapi_callbacks_s::allocate_memory callback and is owned by the\n * client.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p register_count and \\p registers.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library\n * is left uninitialized; and \\p register_count and \\p registers are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized; and \\p register_count and\n * \\p registers are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARCHITECTURE_ID \\p\n * architecture_id is invalid.  \\p register_count and \\p registers are\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p register_count or\n * \\p registers are NULL.  \\p register_count and \\p registers are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be\n * reported if the amd_dbgapi_callbacks_s::allocate_memory callback used to\n * allocate \\p registers returns NULL.  \\p register_count and \\p registers are\n * unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_architecture_register_list (\n    amd_dbgapi_architecture_id_t architecture_id, size_t *register_count,\n    amd_dbgapi_register_id_t **registers) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Report the list of registers supported by a wave.\n *\n * This list is the registers allocated for a specific wave and may not be all\n * the registers supported by the architecture.  For example, AMD GPU\n * architectures can specify the number of vector and scalar registers when a\n * wave is created.  Use the ::amd_dbgapi_architecture_register_list operation\n * to determine the full set of registers supported by the architecture.\n *\n * The order of the register handles in the list is stable between calls.\n * It is equal to, or a subset of, those returned by\n * ::amd_dbgapi_architecture_register_list and in the same order.\n *\n * \\param[in] process_id The process to which the wave belongs.\n *\n * \\param[in] wave_id The wave being queried.\n *\n * \\param[out] register_count The number of wave registers.\n *\n * \\param[out] registers A pointer to an array of ::amd_dbgapi_register_id_t\n * with \\p register_count elements.  It is allocated by the\n * amd_dbgapi_callbacks_s::allocate_memory callback and is owned by the\n * client.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p register_count and \\p registers.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized; and \\p register_count and \\p registers are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized; and \\p register_count and\n * \\p registers are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARCHITECTURE_ID \\p\n * architecture_id is invalid.  \\p register_count and \\p registers are\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p register_count or\n * \\p registers are NULL.  \\p register_count and \\p registers are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be\n * reported if the amd_dbgapi_callbacks_s::allocate_memory callback used to\n * allocate \\p registers returns NULL.  \\p register_count and \\p registers are\n * unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_wave_register_list (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_wave_id_t wave_id,\n    size_t *register_count,\n    amd_dbgapi_register_id_t **registers) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Return a register handle from an AMD GPU DWARF register number.\n *\n * See [User Guide for AMDGPU Backend - Code Object - DWARF - Register Mapping]\n * (https://llvm.org/docs/AMDGPUUsage.html#register-mapping).\n *\n * \\param[in] architecture_id The architecture of the DWARF register.\n *\n * \\param[in] dwarf_register The AMD GPU DWARF register number.\n *\n * \\param[out] register_id The register handle that corresponds to the DWARF\n * register ID.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p register_id.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p register_id is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p register_id is\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARCHITECTURE_ID \\p\n * architecture_id is invalid.  \\p register_id is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p dwarf_register_id is\n * not valid for the architecture or \\p register_id is NULL.  \\p register_id is\n * unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_dwarf_register_to_register (\n    amd_dbgapi_architecture_id_t architecture_id, uint64_t dwarf_register,\n    amd_dbgapi_register_id_t *register_id) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Indication of whether a register is a member of a register class.\n */\ntypedef enum\n{\n  /**\n   * The register is not a member of the register class.\n   */\n  AMD_DBGAPI_REGISTER_CLASS_STATE_NOT_MEMBER = 0,\n  /**\n   * The register is a member of the register class.\n   */\n  AMD_DBGAPI_REGISTER_CLASS_STATE_MEMBER = 1\n} amd_dbgapi_register_class_state_t;\n\n/**\n * Determine if a register is a member of a register class.\n *\n * The register and register class must both belong to the same architecture.\n *\n * \\param[in] architecture_id The architecture of the register class and\n * register.\n *\n * \\param[in] register_id The handle of the register being queried.\n *\n * \\param[in] register_class_id The handle of the register class being queried.\n *\n * \\param[out] register_class_state\n * ::AMD_DBGAPI_REGISTER_CLASS_STATE_NOT_MEMBER if the register is not in the\n * register class.\n * ::AMD_DBGAPI_REGISTER_CLASS_STATE_MEMBER if the register is in the register\n * class.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p register_class_state.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p register_class_state is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p register_class_state\n * is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARCHITECTURE_ID \\p architecture_id\n * is invalid.  \\p register_class_state is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_REGISTER_ID \\p register_id is\n * invalid for \\p architecture_id.  \\p register_class_state is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_REGISTER_CLASS_ID \\p\n * register_class_id is invalid for \\p architecture_id.  \\p\n * register_class_state is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p register_class_state\n * is NULL.  \\p register_class_state is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_register_is_in_register_class (\n    amd_dbgapi_architecture_id_t architecture_id,\n    amd_dbgapi_register_id_t register_id,\n    amd_dbgapi_register_class_id_t register_class_id,\n    amd_dbgapi_register_class_state_t *register_class_state)\n    AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Read a register.\n *\n * \\p value_size bytes are read from the register starting at \\p offset into \\p\n * value.\n *\n * The wave must be stopped.\n *\n * The register handle must be valid for the architecture, and the wave must\n * have allocated that register.\n *\n * The size of the register can vary depending on the wave.  The register size\n * can be obtained using ::amd_dbgapi_wave_register_get_info with the\n * ::AMD_DBGAPI_REGISTER_INFO_SIZE query.\n *\n * \\param[in] process_id The process to which the wave belongs.\n *\n * \\param[in] wave_id The wave to being queried for the register.\n *\n * \\param[in] register_id The register being requested.\n *\n * \\param[in] offset The first byte to start reading the register.  The offset\n * is zero based starting from the least significant byte of the register.\n *\n * \\param[in] value_size The number of bytes to read from the register which\n * must be greater than 0 and less than the size of the register minus \\p\n * offset.\n *\n * \\param[out] value The bytes read from the register.  Must point to an array\n * of at least \\p value_size bytes.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and \\p value is set to \\p value_size bytes starting at \\p\n * offset from the contents of the register.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  \\p value are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_WAVE_ID \\p wave_id is invalid.  \\p\n * value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_REGISTER_ID \\p register_id is\n * invalid for the architecture of \\p wave_id, or not allocated for \\p\n * wave_id.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_WAVE_NOT_STOPPED \\p wave_id is not\n * stopped.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p value is NULL.  \\p\n * value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT_SIZE \\p value_size is 0\n * or greater than the size of the register minus \\p offset.  \\p value is\n * unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_read_register (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_wave_id_t wave_id,\n    amd_dbgapi_register_id_t register_id, amd_dbgapi_size_t offset,\n    amd_dbgapi_size_t value_size, void *value) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Write a register.\n *\n * \\p value_size bytes are written into the register starting at \\p offset.\n *\n * The wave must be stopped.\n *\n * The register handle must be valid for the architecture, and the wave must\n * have allocated that register.\n *\n * The size of the register can vary depending on the wave.  The register size\n * can be obtained using ::amd_dbgapi_wave_register_get_info with the\n * ::AMD_DBGAPI_REGISTER_INFO_SIZE query.\n *\n * \\param[in] process_id The process to which the wave belongs.\n *\n * \\param[in] wave_id The wave to being queried for the register.\n *\n * \\param[in] register_id The register being requested.\n *\n * \\param[in] offset The first byte to start writing the register.  The offset\n * is zero based starting from the least significant byte of the register.\n *\n * \\param[in] value_size The number of bytes to write to the register which\n * must be greater than 0 and less than the size of the register minus \\p\n * offset.\n *\n * \\param[in] value The bytes to write to the register.  Must point to an array\n * of at least \\p value_size bytes.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and \\p value_size bytes have been written to the contents of\n * the register starting at \\p offset.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and the register is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized.  The register is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  The register is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_WAVE_ID \\p wave_id is invalid.\n * The register is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_REGISTER_ID \\p register_id is\n * invalid for the architecture of \\p wave_id, or not allocated for \\p\n * wave_id.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_WAVE_NOT_STOPPED \\p wave_id is not\n * stopped.  The register is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p value is NULL.  The\n * register is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT_SIZE \\p value_size is 0\n * or greater than the size of the register minus \\p offset.  The register is\n * unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_write_register (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_wave_id_t wave_id,\n    amd_dbgapi_register_id_t register_id, amd_dbgapi_size_t offset,\n    amd_dbgapi_size_t value_size, const void *value) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Prefetch register values.\n *\n * A hint to indicate that a range of registers may be read using\n * ::amd_dbgapi_read_register in the future.  This can improve the performance\n * of reading registers as the library may be able to batch the prefetch\n * requests into one request.\n *\n * The wave must be stopped.  If the wave is resumed, then any prefetch\n * requests for registers that were not subsequently read may be discarded and\n * so provide no performance benefit.  Prefetch requests for registers that are\n * never subsequently read may in fact reduce performance.\n *\n * The registers to prefetch are specified as the first register and the number\n * of registers.  The first register can be any register supported by the wave.\n * The number of registers is in terms of the wave register order returned by\n * ::amd_dbgapi_wave_register_list.  If the number exceeds the number of wave\n * registers, then only up to the last wave register is prefetched.\n *\n * The register handle must be valid for the architecture, and the wave must\n * have allocated that register.\n *\n * \\param[in] process_id The process to which the wave belongs.\n *\n * \\param[in] wave_id The wave being queried for the register.\n *\n * \\param[in] register_id The first register being requested.\n *\n * \\param[in] register_count The number of registers being requested.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully.  Registers may be prefetched.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  No registers are prefetched.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_WAVE_ID \\p wave_id is invalid.  No\n * registers are prefetched.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_REGISTER_ID \\p register_id is\n * invalid for the architecture of \\p wave_id, or not allocated for \\p wave_id.\n * \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_WAVE_NOT_STOPPED \\p wave_id is not\n * stopped.  No registers are prefetched.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_prefetch_register (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_wave_id_t wave_id,\n    amd_dbgapi_register_id_t register_id,\n    amd_dbgapi_size_t register_count) AMD_DBGAPI_VERSION_0_24;\n\n/** @} */\n\n/** \\defgroup memory_group Memory\n *\n * Operations related to AMD GPU memory access.\n *\n * The AMD GPU supports allocating memory in different address spaces.  See\n * [User Guide for AMDGPU Backend - LLVM - Address Spaces]\n * (https://llvm.org/docs/AMDGPUUsage.html#address-spaces).\n *\n * @{\n */\n\n/**\n * A wave lane handle.\n *\n * A wave can have one or more lanes controlled by an execution mask.  Vector\n * instructions will be performed for each lane of the wave that the execution\n * mask has enabled.  Vector instructions can access registers that are vector\n * registers.  A vector register has a separate value for each lane, and vector\n * instructions will access the corresponding component for each lane's\n * evaluation of the instruction.\n *\n * The number of lanes of a wave can be obtained with the\n * ::AMD_DBGAPI_WAVE_INFO_LANE_COUNT query.  Different waves of the same\n * architecture can have different lane counts.\n *\n * The AMD GPU compiler may map source language threads of execution to lanes\n * of a wave.  The DWARF debug information which maps such source languages to\n * the generated architecture specific code must include information about the\n * lane mapping.\n *\n * The ::AMD_DBGAPI_ADDRESS_SPACE_LANE address space supports memory\n * allocated independently for each lane of a wave.\n *\n * Lanes are numbered from 0 to ::AMD_DBGAPI_WAVE_INFO_LANE_COUNT minus 1.\n *\n * Only unique for a single wave of a single process.\n */\ntypedef uint32_t amd_dbgapi_lane_id_t;\n\n/**\n * The NULL lane handle.\n */\n#define AMD_DBGAPI_LANE_NONE ((amd_dbgapi_lane_id_t) (-1))\n\n/**\n * Opaque source language address class handle.\n *\n * A source language address class describes the source language address\n * spaces.  It is used to define source language pointer and reference types.\n * Each architecture has its own mapping of them to the architecture specific\n * address spaces.\n *\n * The handle is only unique within a specific architecture.\n *\n * See [User Guide for AMDGPU Backend - Code Object - DWARF - Address Class\n * Mapping] (https://llvm.org/docs/AMDGPUUsage.html#address-class-mapping).\n */\ntypedef struct\n{\n  uint64_t handle;\n} amd_dbgapi_address_class_id_t;\n\n/**\n * The NULL address class handle.\n */\n#define AMD_DBGAPI_ADDRESS_CLASS_NONE (amd_dbgapi_address_class_id_t{ 0 })\n\n/**\n * Source language address class queries that are supported by\n * ::amd_dbgapi_architecture_address_class_get_info.\n *\n * Each query specifies the type of data returned in the \\p value argument to\n * ::amd_dbgapi_architecture_address_class_get_info.\n */\ntypedef enum\n{\n  /**\n   * Return the source language address class name.  The type of this attribute\n   * is a pointer to a NUL terminated \\p char.  It is allocated by the\n   * amd_dbgapi_callbacks_s::allocate_memory callback and is owned by the\n   * client.\n   */\n  AMD_DBGAPI_ADDRESS_CLASS_INFO_NAME = 1,\n  /**\n   * Return the architecture specific address space that is used to implement a\n   * pointer or reference to the source language address class.  The type of\n   * this attribute is ::amd_dbgapi_address_class_id_t.\n   *\n   * See [User Guide for AMDGPU Backend - Code Object - DWARF - Address Class\n   * Mapping] (https://llvm.org/docs/AMDGPUUsage.html#address-class-mapping).\n   */\n  AMD_DBGAPI_ADDRESS_CLASS_INFO_ADDRESS_SPACE = 2\n} amd_dbgapi_address_class_info_t;\n\n/**\n * Query information about a source language address class of an architecture.\n *\n * ::amd_dbgapi_address_class_info_t specifies the queries supported and the\n * type returned using the \\p value argument.\n *\n * \\param[in] architecture_id The architecture to which the source language\n * address class belongs.\n *\n * \\param[in] address_class_id The handle of the source language address class\n * being queried.\n *\n * \\param[in] query The query being requested.\n *\n * \\param[in] value_size Size of the memory pointed to by \\p value.  Must be\n * equal to the byte size of the query result.\n *\n * \\param[out] value Pointer to memory where the query result is stored.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p value.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARCHITECTURE_ID \\p architecture_id\n * is invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ADDRESS_CLASS_ID \\p\n * address_class_id is invalid for the architecture of \\p architecture_id.  \\p\n * value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p value is NULL or \\p\n * query is invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT_SIZE \\p value_size does\n * not match the size of the result.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be reported if\n * the amd_dbgapi_callbacks_s::allocate_memory callback used to allocate \\p\n * value returns NULL.  \\p value is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_architecture_address_class_get_info (\n    amd_dbgapi_architecture_id_t architecture_id,\n    amd_dbgapi_address_class_id_t address_class_id,\n    amd_dbgapi_address_class_info_t query, size_t value_size,\n    void *value) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Report the list of source language address classes supported by the\n * architecture.\n *\n * The order of the source language address class handles in the list is stable\n * between calls.\n *\n * \\param[in] architecture_id The architecture being queried.\n *\n * \\param[out] address_class_count The number of architecture source language\n * address classes.\n *\n * \\param[out] address_classes A pointer to an array of\n * ::amd_dbgapi_address_class_id_t with \\p address_class_count elements.  It is\n * allocated by the amd_dbgapi_callbacks_s::allocate_memory callback and is\n * owned by the client.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p address_class_count and \\p\n * address_classes.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized; and \\p address_class_count and \\p address_classes are\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized; and \\p address_class_count\n * and \\p address_classes are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARCHITECTURE_ID \\p architecture_id\n * is invalid.  \\p address_class_count and \\p address_classes are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p address_class_count or\n * \\p address_classes are NULL.  \\p address_class_count and \\p address_classes\n * are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be reported if\n * the amd_dbgapi_callbacks_s::allocate_memory callback used to allocate \\p\n * address_classes returns NULL.  \\p address_class_count and \\p address_classes\n * are unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_architecture_address_class_list (\n    amd_dbgapi_architecture_id_t architecture_id, size_t *address_class_count,\n    amd_dbgapi_address_class_id_t **address_classes) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Return the architecture source language address class from a DWARF address\n * class number.\n *\n * See [User Guide for AMDGPU Backend - Code Object - DWARF - Address Class\n * Mapping] (https://llvm.org/docs/AMDGPUUsage.html#address-class-mapping).\n *\n * \\param[in] architecture_id The architecture of the source language address\n * class.\n *\n * \\param[in] dwarf_address_class The DWARF source language address class.\n *\n * \\param[out] address_class_id The source language address class that\n * corresponds to the DWARF address class for the architecture.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p address_class_id.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p address_class_id is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p address_class_id is\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARCHITECTURE_ID \\p architecture_id\n * is invalid.  \\p address_class_id is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p dwarf_address_class is\n * not valid for \\p architecture_id or \\p address_class_id is NULL.  \\p\n * address_class_id is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI\namd_dbgapi_dwarf_address_class_to_address_class (\n    amd_dbgapi_architecture_id_t architecture_id, uint64_t dwarf_address_class,\n    amd_dbgapi_address_class_id_t *address_class_id) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Opaque address space handle.\n *\n * A handle that denotes the set of address spaces supported by an\n * architecture.\n *\n * The handle is only unique within a specific architecture.\n *\n * See [User Guide for AMDGPU Backend - LLVM - Address Spaces]\n * (https://llvm.org/docs/AMDGPUUsage.html#address-spaces).\n */\ntypedef struct\n{\n  uint64_t handle;\n} amd_dbgapi_address_space_id_t;\n\n/**\n * The NULL address space handle.\n */\n#define AMD_DBGAPI_ADDRESS_SPACE_NONE (amd_dbgapi_address_space_id_t{ 0 })\n\n/**\n * The global address space handle.\n *\n * Every architecture supports a global address space that uses the same\n * address space ID.\n */\n#define AMD_DBGAPI_ADDRESS_SPACE_GLOBAL (amd_dbgapi_address_space_id_t{ 1 })\n\n/**\n * Indication of how the address space is accessed.\n */\ntypedef enum\n{\n  /**\n   * The address space supports all accesses.  Values accessed can change\n   * during the lifetie of the program.\n   */\n  AMD_DBGAPI_ADDRESS_SPACE_ACCESS_ALL = 1,\n  /**\n   * The address space is read only.  Values accessed are always the same\n   * value for the lifetime of the program execution.\n   */\n  AMD_DBGAPI_ADDRESS_SPACE_ACCESS_PROGRAM_CONSTANT = 2,\n  /**\n   * The address space is only read the waves of a kernel dispatch.  Values\n   * accessed are always the same value for the lifetime of the dispatch.\n   */\n  AMD_DBGAPI_ADDRESS_SPACE_ACCESS_DISPATCH_CONSTANT = 3\n} amd_dbgapi_address_space_access_t;\n\n/**\n * Address space queries that are supported by\n * ::amd_dbgapi_address_space_get_info.\n *\n * Each query specifies the type of data returned in the \\p value argument to\n * ::amd_dbgapi_address_space_get_info.\n */\ntypedef enum\n{\n  /**\n   * Return the address space name.  The type of this attribute is a pointer to\n   * a NUL terminated \\p char*.  It is allocated by the\n   * amd_dbgapi_callbacks_s::allocate_memory callback and is owned by the\n   * client.\n   */\n  AMD_DBGAPI_ADDRESS_SPACE_INFO_NAME = 1,\n  /**\n   * Return the byte size of an address in the address space.  The type of this\n   * attribute is ::amd_dbgapi_size_t.\n   */\n  AMD_DBGAPI_ADDRESS_SPACE_INFO_ADDRESS_SIZE = 2,\n  /**\n   * Return the NULL segment address value in the address space.  The type of\n   * this attribute is \\p amd_dbgapi_segment_address_t.\n   */\n  AMD_DBGAPI_ADDRESS_SPACE_INFO_NULL_ADDRESS = 3,\n  /**\n   * Return the address space access.  The type of this attribute is \\p\n   * uint32_t with values defined by ::amd_dbgapi_address_space_access_t.\n   */\n  AMD_DBGAPI_ADDRESS_SPACE_INFO_ACCESS = 4\n} amd_dbgapi_address_space_info_t;\n\n/**\n * Query information about an address space.\n *\n * ::amd_dbgapi_address_space_info_t specifies the queries supported and the\n * type returned using the \\p value argument.\n *\n * \\param[in] architecture_id The architecture of the address space.\n *\n * \\param[in] address_space_id The address space.\n *\n * \\param[in] query The query being requested.\n *\n * \\param[in] value_size Size of the memory pointed to by \\p value.  Must be\n * equal to the byte size of the query result.\n *\n * \\param[out] value Pointer to memory where the query result is stored.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p value.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARCHITECTURE_ID \\p architecture_id\n * is invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ADDRESS_SPACE_ID \\p\n * address_space_id is invalid for \\p architecture_id.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p query is invalid or \\p\n * value is NULL.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT_SIZE \\p value_size does\n * not match the size of the result.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be reported if\n * the amd_dbgapi_callbacks_s::allocate_memory callback used to allocate \\p\n * value returns NULL.  \\p value is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_address_space_get_info (\n    amd_dbgapi_architecture_id_t architecture_id,\n    amd_dbgapi_address_space_id_t address_space_id,\n    amd_dbgapi_address_space_info_t query, size_t value_size,\n    void *value) AMD_DBGAPI_VERSION_0_30;\n\n/**\n * Report the list of address spaces supported by the architecture.\n *\n * The order of the address space handles in the list is stable between calls.\n *\n * \\param[in] architecture_id The architecture being queried.\n *\n * \\param[out] address_space_count The number of architecture address spaces.\n *\n * \\param[out] address_spaces A pointer to an array of\n * ::amd_dbgapi_address_space_id_t with \\p address_space_count elements.  It is\n * allocated by the amd_dbgapi_callbacks_s::allocate_memory callback and is\n * owned by the client.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p address_space_count and \\p\n * address_spaces.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized; and \\p address_space_count and \\p address_spaces are\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized; and \\p address_space_count\n * and \\p address_spaces are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARCHITECTURE_ID \\p architecture_id\n * is invalid.  \\p address_space_count and \\p address_spaces are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p address_space_count\n * and \\p address_spaces are NULL.  \\p address_space_count and \\p\n * address_spaces are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be reported if\n * the amd_dbgapi_callbacks_s::allocate_memory callback used to allocate \\p\n * address_spaces returns NULL.  \\p address_space_count and \\p address_spaces\n * are unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_architecture_address_space_list (\n    amd_dbgapi_architecture_id_t architecture_id, size_t *address_space_count,\n    amd_dbgapi_address_space_id_t **address_spaces) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Return the address space from an AMD GPU DWARF address space number.\n *\n * A DWARF address space describes the architecture specific address spaces.\n * If is used in DWARF location expressions that calculate addresses.  See\n * [User Guide for AMDGPU Backend - Code Object - DWARF - Address Space\n * Mapping] (https://llvm.org/docs/AMDGPUUsage.html#address-space-mapping).\n *\n * \\param[in] architecture_id The architecture of the address space.\n *\n * \\param[in] dwarf_address_space The AMD GPU DWARF address space.\n *\n * \\param[out] address_space_id The address space that corresponds to the DWARF\n * address space for the architecture \\p architecture_id.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p address_space_id.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p address_space_id is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p address_space_id is\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARCHITECTURE_ID \\p architecture_id\n * is invalid.  \\p address_space_id is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p dwarf_address_space is\n * not valid for \\p architecture_id, or \\p address_space_id is NULL.  \\p\n * address_space_id is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI\namd_dbgapi_dwarf_address_space_to_address_space (\n    amd_dbgapi_architecture_id_t architecture_id, uint64_t dwarf_address_space,\n    amd_dbgapi_address_space_id_t *address_space_id) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Indication of whether addresses in two address spaces may alias.\n */\ntypedef enum\n{\n  /**\n   * No addresses in the address spaces can alias.\n   */\n  AMD_DBGAPI_ADDRESS_SPACE_ALIAS_NONE = 0,\n  /**\n   * Addresses in the address spaces may alias.\n   */\n  AMD_DBGAPI_ADDRESS_SPACE_ALIAS_MAY = 1\n} amd_dbgapi_address_space_alias_t;\n\n/**\n * Determine if an address in one address space may alias an address in another\n * address space.\n *\n * If addresses in one address space may alias the addresses in another, and if\n * memory locations are updated using an address in one, then any cached\n * information about values in the other needs to be invalidated.\n *\n * The address spaces must match the architecture.\n *\n * \\param[in] architecture_id The architecture to which the address spaces\n * belong.\n *\n * \\param[in] address_space_id1 An address space.\n *\n * \\param[in] address_space_id2 An address space.\n *\n * \\param[out] address_space_alias ::AMD_DBGAPI_ADDRESS_SPACE_ALIAS_NONE if the\n * address spaces do not alias.  ::AMD_DBGAPI_ADDRESS_SPACE_ALIAS_MAY if the\n * address spaces may alias.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p address_space_alias.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p address_space_alias is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p address_space_alias\n * is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARCHITECTURE_ID \\p architecture_id\n * is invalid.  \\p address_space_alias is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ADDRESS_SPACE_ID \\p\n * address_space_id1 or \\p address_space_id2 are invalid for \\p\n * architecture_id.  \\p address_space_alias is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p address_space_alias is\n * NULL.  \\p address_space_alias is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_address_spaces_may_alias (\n    amd_dbgapi_architecture_id_t architecture_id,\n    amd_dbgapi_address_space_id_t address_space_id1,\n    amd_dbgapi_address_space_id_t address_space_id2,\n    amd_dbgapi_address_space_alias_t *address_space_alias)\n    AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Each address space has its own linear address to access it termed a segment\n * address.\n *\n * Different address spaces may have memory locations that alias each other,\n * but the segment address for such memory locations may be different in each\n * address space.  Consequently a segment address is specific to an address\n * space.\n *\n * Some address spaces may access memory that is allocated independently for\n * each work-group, for each wave, or for each lane of of a wave.  Consequently\n * a segment address may be specific to a wave or lane of a wave.\n *\n * See [User Guide for AMDGPU Backend - LLVM - Address Spaces]\n * (https://llvm.org/docs/AMDGPUUsage.html#address-spaces).\n */\ntypedef uint64_t amd_dbgapi_segment_address_t;\n\n/**\n * Convert a source segment address in the source address space into a\n * destination segment address in the destination address space.\n *\n * If the source segment address is the NULL value in the source address space\n * then it is converted to the NULL value in the destination address space.\n * The NULL address is provided by the\n * ::AMD_DBGAPI_ADDRESS_SPACE_INFO_NULL_ADDRESS query.\n *\n * An error is returned if the source segment address has no corresponding\n * segment address in the destination address space.  The source and\n * destination address spaces must have the same linear ordering.  For example,\n * a swizzled address space is not the same linear ordering as an unswizzled\n * address space.  The source and destination address spaces must either both\n * depend on the active lane, both depend on the same lane, or both not depend\n * on the lane.\n *\n * \\param[in] process_id The process to which the \\p wave_id belongs.\n *\n * \\param[in] wave_id The wave that is using the address.\n *\n * \\param[in] lane_id The lane of the \\p wave_id that is using the address.\n *\n * \\param[in] source_address_space The address space of the \\p\n * source_segment_address.\n *\n * \\param[in] source_segment_address The integral value of the source segment\n * address.  Only the bits corresponding to the address size for the \\p\n * source_address_space requested are used.  The address size is provided by\n * the\n * ::AMD_DBGAPI_ADDRESS_SPACE_INFO_ADDRESS_SIZE query.\n *\n * \\param[in] destination_address_space The address space to which to convert\n * \\p source_segment_address that is in \\p source_address_space.\n *\n * \\param[out] destination_segment_address The integral value of the segment\n * address in \\p destination_address_space that corresponds to \\p\n * source_segment_address in \\p source_address_space.  The bits corresponding\n * to the address size for the \\p destination_address_space are updated, and\n * any remaining bits are set to zero.  The address size is provided by the\n * ::AMD_DBGAPI_ADDRESS_SPACE_INFO_ADDRESS_SIZE query.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p destination_segment_address.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p destination_segment_address is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p\n * destination_segment_address is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  \\p destination_segment_address is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_WAVE_ID \\p wave_id is invalid.  \\p\n * destination_segment_address is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_LANE_ID \\p lane_id is invalid, or\n * \\p lane_id is ::AMD_DBGAPI_LANE_NONE and \\p source_address_space depends on\n * the active lane.  \\p destination_segment_address is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ADDRESS_SPACE_ID \\p\n * source_address_space_id or \\p destination_address_space_id are invalid for\n * the architecture of \\p wave_id.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ADDRESS_SPACE_CONVERSION The \\p\n * source_segment_address in the \\p source_address_space_id is not an address\n * that can be represented in the \\p destination_address_space_id.  \\p\n * destination_segment_address is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p\n * destination_segment_address is NULL.  \\p destination_segment_address is\n * unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_convert_address_space (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_wave_id_t wave_id,\n    amd_dbgapi_lane_id_t lane_id,\n    amd_dbgapi_address_space_id_t source_address_space_id,\n    amd_dbgapi_segment_address_t source_segment_address,\n    amd_dbgapi_address_space_id_t destination_address_space_id,\n    amd_dbgapi_segment_address_t *destination_segment_address)\n    AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Indication of whether a segment address in an address space is a member of\n * an source language address class.\n */\ntypedef enum\n{\n  /**\n   * The segment address in the address space is not a member of the source\n   * language address class.\n   */\n  AMD_DBGAPI_ADDRESS_CLASS_STATE_NOT_MEMBER = 0,\n  /**\n   * The segment address in the address space is a member of the source\n   * language address class.\n   */\n  AMD_DBGAPI_ADDRESS_CLASS_STATE_MEMBER = 1\n} amd_dbgapi_address_class_state_t;\n\n/**\n * Determine if a segment address in an address space is a member of a source\n * language address class.\n *\n * The address space and source language address class must both belong to the\n * same architecture.\n *\n * The address space, source language address class, and wave must all belong\n * to the same architecture.\n *\n * \\param[in] process_id The process to which the \\p wave_id belongs.\n *\n * \\param[in] wave_id The wave that is using the address.\n *\n * \\param[in] lane_id The lane of the \\p wave_id that is using the address.\n *\n * \\param[in] address_space_id The address space of the \\p segment_address.  If\n * the address space is dependent on: the active lane then the \\p lane_id with\n * in the \\p wave_id is used; the active work-group then the work-group of \\p\n * wave_id is used; or the active wave then the \\p wave_id is used.\n *\n * \\param[in] segment_address The integral value of the segment address.  Only\n * the bits corresponding to the address size for the \\p address_space\n * requested are used.  The address size is provided by the\n * ::AMD_DBGAPI_ADDRESS_SPACE_INFO_ADDRESS_SIZE query.\n *\n * \\param[in] address_class_id The handle of the source language address class.\n *\n * \\param[out] address_class_state ::AMD_DBGAPI_ADDRESS_CLASS_STATE_NOT_MEMBER\n * if the address is not in the address class.\n * ::AMD_DBGAPI_ADDRESS_CLASS_STATE_MEMBER if the address is in the address\n * class.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p address_class_state.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p address_class_state is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p address_class_state\n * is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  \\p address_class_state is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_WAVE_ID \\p wave_id is invalid.  \\p\n * address_class_state is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_LANE_ID \\p lane_id is invalid.  \\p\n * address_class_state is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ADDRESS_SPACE_ID \\p\n * address_space_id is invalid for the architecture of \\p wave_id.  \\p\n * address_class_state is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ADDRESS_CLASS_ID \\p\n * address_class_id is invalid for the architecture of \\p wave_id.  \\p\n * address_class_state is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p address_class_state is\n * NULL.  \\p address_class_state is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_address_is_in_address_class (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_wave_id_t wave_id,\n    amd_dbgapi_lane_id_t lane_id,\n    amd_dbgapi_address_space_id_t address_space_id,\n    amd_dbgapi_segment_address_t segment_address,\n    amd_dbgapi_address_class_id_t address_class_id,\n    amd_dbgapi_address_class_state_t *address_class_state)\n    AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Read memory.\n *\n * The memory bytes in \\p address_space are read starting at \\p segment_address\n * sequentially into \\p value until \\p value_size bytes have been read or an\n * invalid memory address is reached.  \\p value_size is set to the number of\n * bytes read successfully.\n *\n * The wave must be stopped.\n *\n * The library performs all necessary hardware cache management so that the\n * memory values read are coherent with the \\p wave_id.\n *\n * \\param[in] process_id The process to which the \\p wave_id belongs.\n *\n * \\param[in] wave_id The wave that is accessing the memory.  If the \\p\n * address_space is ::AMD_DBGAPI_ADDRESS_SPACE_GLOBAL then \\p wave_id is\n * ignored and may be ::AMD_DBGAPI_WAVE_NONE as the address space does not\n * depend on the active wave.\n *\n * \\param[in] lane_id The lane of \\p wave_id that is accessing the memory.  If\n * the \\p address_space does not depend on the active lane then this is ignored\n * and may be ::AMD_DBGAPI_LANE_NONE.  For example, the\n * ::AMD_DBGAPI_ADDRESS_SPACE_GLOBAL address space does not depend on the lane.\n *\n * \\param[in] address_space_id The address space of the \\p segment_address.  If\n * the address space is dependent on: the active lane then the \\p lane_id with\n * in the \\p wave_id is used; the active work-group then the work-group of \\p\n * wave_id is used; or the active wave then the \\p wave_id is used.\n *\n * \\param[in] segment_address The integral value of the segment address.  Only\n * the bits corresponding to the address size for the \\p address_space\n * requested are used.  The address size is provided by the\n * ::AMD_DBGAPI_ADDRESS_SPACE_INFO_ADDRESS_SIZE query.\n *\n * \\param[in,out] value_size Pass in the number of bytes to read from memory.\n * Return the number of bytes successfully read from memory.\n *\n * \\param[out] value Pointer to memory where the result is stored.  Must be an\n * array of at least input \\p value_size bytes.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS Either the input \\p value_size was 0, or\n * the input \\p value_size was greater than 0 and one or more bytes have been\n * read successfully.  The output \\p value_size is set to the number of bytes\n * successfully read, which will be 0 if the input \\p value_size was 0.  The\n * first output \\p value_size bytes of \\p value are set to the bytes\n * successfully read, all other bytes in \\p value are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized; and \\p value_size and \\p value are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized; and \\p value_size and \\p\n * value are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  \\p value_size and \\p value are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_WAVE_ID \\p wave_id is invalid, or\n * \\p wave_id is ::AMD_DBGAPI_WAVE_NONE and \\p address_space is not\n * ::AMD_DBGAPI_ADDRESS_SPACE_GLOBAL.  \\p value_size and \\p value are\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_LANE_ID \\p lane_id is invalid, or\n * \\p lane_id is ::AMD_DBGAPI_LANE_NONE and \\p address_space depends on the\n * active lane.  \\p value_size and \\p value are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ADDRESS_SPACE_ID \\p\n * address_space_id is invalid for the architecture of \\p wave_id.  \\p value is\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_WAVE_NOT_STOPPED \\p wave_id is not\n * stopped.  \\p value_size and \\p value are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p value or \\p value_size\n * are NULL.  \\p value_size and \\p value are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_MEMORY_ACCESS The input \\p value_size was\n * greater than 0 and no bytes were successfully read.  The output \\p\n * value_size is set to 0.  All bytes in \\p value are unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_read_memory (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_wave_id_t wave_id,\n    amd_dbgapi_lane_id_t lane_id,\n    amd_dbgapi_address_space_id_t address_space_id,\n    amd_dbgapi_segment_address_t segment_address,\n    amd_dbgapi_size_t *value_size, void *value) AMD_DBGAPI_VERSION_0_30;\n\n/**\n * Write memory.\n *\n * The memory bytes in \\p address_space are written starting at \\p\n * segment_address sequentially from \\p value until \\p value_size bytes have\n * been written or an invalid memory address is reached.  \\p value_size is set\n * to the number of bytes written successfully.\n *\n * The wave must be stopped.\n *\n * The library performs all necessary hardware cache management so that the\n * memory values written are coherent with the \\p wave_id.\n *\n * \\param[in] process_id The process to which the \\p wave_id belongs.\n *\n * \\param[in] wave_id The wave that is accessing the memory.  If the \\p\n * address_space is ::AMD_DBGAPI_ADDRESS_SPACE_GLOBAL then \\p wave_id is\n * ignored and may be ::AMD_DBGAPI_WAVE_NONE as the address space does not\n * depend on the active wave.\n *\n * \\param[in] lane_id The lane of \\p wave_id that is accessing the memory.  If\n * the \\p address_space does not depend on the active lane then this is ignored\n * and may be ::AMD_DBGAPI_LANE_NONE.  For example, the\n * ::AMD_DBGAPI_ADDRESS_SPACE_GLOBAL address space does not depend on the lane.\n *\n * \\param[in] address_space_id The address space of the \\p segment_address.  If\n * the address space is dependent on: the active lane then the \\p lane_id with\n * in the \\p wave_id is used; the active work-group then the work-group of \\p\n * wave_id is used; or the active wave then the \\p wave_id is used.\n *\n * \\param[in] segment_address The integral value of the segment address.  Only\n * the bits corresponding to the address size for the \\p address_space\n * requested are used.  The address size is provided by the\n * ::AMD_DBGAPI_ADDRESS_SPACE_INFO_ADDRESS_SIZE query.\n *\n * \\param[in,out] value_size Pass in the number of bytes to write to memory.\n * Return the number of bytes successfully written to memory.\n *\n * \\param[in] value The bytes to write to memory.  Must point to an array of at\n * least input \\p value_size bytes.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS Either the input \\p value_size was 0, or\n * the input \\p value_size was greater than 0 and one or more bytes have been\n * written successfully.  The output \\p value_size is set to the number of\n * bytes successfully written, which will be 0 if the input \\p value_size was\n * 0.  The first output \\p value_size bytes of memory starting at \\p\n * segment_address are updated, all other memory is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized; and the memory and \\p value_size are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized;  the memory and \\p\n * value_size are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  The memory and \\p value_size are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_WAVE_ID \\p wave_id is invalid, or\n * \\p wave_id is ::AMD_DBGAPI_WAVE_NONE and \\p address_space is\n * ::AMD_DBGAPI_ADDRESS_SPACE_GLOBAL.  The memory and \\p value_size are\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_LANE_ID \\p lane_id is invalid, or\n * \\p lane_id is ::AMD_DBGAPI_LANE_NONE and \\p address_space depends on the\n * active lane.  The memory and \\p value_size are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ADDRESS_SPACE_ID \\p\n * address_space_id is invalid for the architecture of \\p wave_id.  The memory\n * and \\p value_size are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_WAVE_NOT_STOPPED \\p wave_id is not\n * stopped.  The memory and \\p value_size are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p value or \\p value_size\n * are NULL.  The memory and \\p value_size are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_MEMORY_ACCESS The input \\p value_size was\n * greater than 0 and no bytes were successfully written.  The output \\p\n * value_size is set to 0.  The memory is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_write_memory (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_wave_id_t wave_id,\n    amd_dbgapi_lane_id_t lane_id,\n    amd_dbgapi_address_space_id_t address_space_id,\n    amd_dbgapi_segment_address_t segment_address,\n    amd_dbgapi_size_t *value_size, const void *value) AMD_DBGAPI_VERSION_0_30;\n\n/**\n * Memory access precision.\n *\n * The AMD GPU can overlap the execution of memory instructions with other\n * instructions.  This can result in a wave stopping due to a memory violation\n * or hardware data watchpoint hit with a program counter beyond the\n * instruction that caused the wave to stop.\n *\n * Some architectures allow the hardware to be configured to always wait for\n * memory operations to complete before continuing.  This will result in the\n * wave stopping at the instruction immediately after the one that caused the\n * stop event.  Enabling this mode can make execution of waves significantly\n * slower.\n *\n * The ::AMD_DBGAPI_PROCESS_INFO_PRECISE_MEMORY_SUPPORTED query can be used to\n * determine if the architectures of all the agents of a process support\n * controlling precise memory accesses.\n */\ntypedef enum\n{\n  /**\n   * Memory instructions execute normally and a wave does not wait for the\n   * memory access to complete.\n   */\n  AMD_DBGAPI_MEMORY_PRECISION_NONE = 0,\n  /**\n   * A wave waits for memory instructions to complete before executing further\n   * instructions.  This can cause a wave to execute significantly slower.\n   */\n  AMD_DBGAPI_MEMORY_PRECISION_PRECISE = 1\n} amd_dbgapi_memory_precision_t;\n\n/**\n * Control precision of memory access reporting.\n *\n * A process can be set to ::AMD_DBGAPI_MEMORY_PRECISION_NONE to disable\n * precise memory reporting.  Use the\n * ::AMD_DBGAPI_PROCESS_INFO_PRECISE_MEMORY_SUPPORTED query to determine if the\n * architectures of all the agents of a process support another memory\n * precision.\n *\n * The memory precision is set independently for each process, and only affects\n * the waves executing on the agents of that process.  The setting may be\n * changed at any time, including when waves are executing, and takes effect\n * immediately.\n *\n * \\param[in] process_id The process being configured.\n *\n * \\param[in] memory_precision The memory precision to set.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the agents of the process have been configured.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and no configuration is\n * changed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID \\p process_id is\n * invalid.  No configuration is changed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p memory_precision is\n * an invalid value.  No configuration is changed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_SUPPORTED The requested \\p\n * memory_precision is not supported by the architecture of all the agents of\n * \\p process_id.  No configuration is changed.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_set_memory_precision (\n    amd_dbgapi_process_id_t process_id,\n    amd_dbgapi_memory_precision_t memory_precision) AMD_DBGAPI_VERSION_0_24;\n\n/** @} */\n\n/** \\defgroup event_group Events\n *\n * Asynchronous event management.\n *\n * Events can occur asynchronously.  The library maintains a list of pending\n * events that have happened but not yet been reported to the client.  Events\n * are maintained independently for each process.\n *\n * When ::amd_dbgapi_process_attach successfully attaches to a process a\n * ::amd_dbgapi_notifier_t notifier is created that is available using the\n * ::AMD_DBGAPI_PROCESS_INFO_NOTIFIER query.  When this indicates there\n * may be pending events for the process, ::amd_dbgapi_next_pending_event can\n * be used to retrieve the pending events.\n *\n * The notifier must be reset before retrieving pending events so that the\n * notifier will always conservatively indicate there may be pending events.\n * After the client has processed an event it must report completion using\n * ::amd_dbgapi_event_processed.\n *\n * \\sa ::amd_dbgapi_notifier_t\n *\n * @{\n */\n\n/**\n * Opaque event handle.\n *\n * Only unique within a single process.\n */\ntypedef struct\n{\n  uint64_t handle;\n} amd_dbgapi_event_id_t;\n\n/**\n * The NULL event handle.\n */\n#define AMD_DBGAPI_EVENT_NONE (amd_dbgapi_event_id_t{ 0 })\n\n/**\n * The event kinds.\n */\ntypedef enum\n{\n  /**\n   * No event.\n   */\n  AMD_DBGAPI_EVENT_KIND_NONE = 0,\n  /**\n   * A wave has stopped.\n   */\n  AMD_DBGAPI_EVENT_KIND_WAVE_STOP = 1,\n  /**\n   * A command for a wave was not able to complete because the wave has\n   * terminated.\n   *\n   * Commands that can result in this event are ::amd_dbgapi_wave_stop and\n   * ::amd_dbgapi_wave_resume in single step mode.  Since the wave terminated\n   * before stopping, this event will be reported instead of\n   * ::AMD_DBGAPI_EVENT_KIND_WAVE_STOP.\n   *\n   * The wave that terminated is available by the ::AMD_DBGAPI_EVENT_INFO_WAVE\n   * query.  However, the wave will be invalid since it has already terminated.\n   * It is the client's responsibility to know what command was being performed\n   * and was unable to complete due to the wave terminating.\n   */\n  AMD_DBGAPI_EVENT_KIND_WAVE_COMMAND_TERMINATED = 2,\n  /**\n   * The list of code objects has changed.\n   *\n   * The thread that caused the code object list to change will be stopped\n   * until the event is reported as processed.  Before reporting the event has\n   * been processed, the client must set any pending breakpoints for newly\n   * loaded code objects so that breakpoints will be set before any code in the\n   * code object is executed.\n   *\n   * When the event is reported as complete, a\n   * ::AMD_DBGAPI_EVENT_KIND_BREAKPOINT_RESUME event may be created which must\n   * be processed to resume the thread that caused the code object list to\n   * change.  Leaving the thread stopped may prevent the inferior runtime from\n   * servicing requests from other threads.\n   */\n  AMD_DBGAPI_EVENT_KIND_CODE_OBJECT_LIST_UPDATED = 3,\n  /**\n   * Request to resume a host breakpoint.\n   *\n   * If ::amd_dbgapi_report_breakpoint_hit returns with \\p resume as\n   * false then it indicates that events must be processed before the thread\n   * hitting the breakpoint can be resumed.  When the necessary event(s) are\n   * reported as processed, this event will be added to the pending events.\n   * The breakpoint and client thread can then be queried by\n   * ::amd_dbgapi_event_get_info using ::AMD_DBGAPI_EVENT_INFO_BREAKPOINT\n   * and ::AMD_DBGAPI_EVENT_INFO_CLIENT_THREAD respectively.  The client must\n   * then resume execution of the thread.\n   */\n  AMD_DBGAPI_EVENT_KIND_BREAKPOINT_RESUME = 4,\n  /**\n   * The runtime support in the inferior has been loaded or unloaded.  Until it\n   * has been successfully loaded no code objects will be loaded and no waves\n   * will be created.  The client can use this event to determine when to\n   * activate and deactivate AMD GPU debugging functionality.  This event\n   * reports the load status, the version, and if it is compatible with this\n   * library.  If it is not compatible, then no code objects or waves will be\n   * reported to exist.\n   */\n  AMD_DBGAPI_EVENT_KIND_RUNTIME = 5,\n  /**\n   * An event has occurred that is causing the queue to enter the error\n   * state.\n   *\n   * All non-stopped waves executing on the queue will have been stopped and a\n   * ::AMD_DBGAPI_EVENT_KIND_WAVE_STOP event will proceed this event.  All\n   * waves on the queue will include the\n   * ::AMD_DBGAPI_WAVE_STOP_REASON_QUEUE_ERROR stop reason.  No further waves\n   * will be started on the queue.  The ::AMD_DBGAPI_QUEUE_INFO_ERROR_REASON\n   * query will include the union of the reasons that were reported.  Some\n   * waves may be stopped before they were able to report a queue error\n   * condition.  The wave stop reason will only include the reasons that were\n   * reported.\n   *\n   * For example, if many waves encounter a memory violation at the same time,\n   * only some of the waves may report it before all the waves in the queue are\n   * stopped.  Only the waves that were able to report the memory violation\n   * before all the waves were stopped will include the\n   * ::AMD_DBGAPI_WAVE_STOP_REASON_MEMORY_VIOLATION stop reason.\n   *\n   * The queue error will not be reported to the inferior runtime until this\n   * event is reported as complete by calling ::amd_dbgapi_event_processed.\n   * Once reported to the inferior runtime, it may cause the application to be\n   * notified which may delete and re-create the queue in order to continue\n   * submitting dispatches to the AMD GPU.  If the application deletes a queue\n   * then all information about the waves executing on the queue will be lost,\n   * preventing the user from determining if a wave caused the error.\n   *\n   * Therefore, the client may choose to stop inferior threads before reporting\n   * the event as complete.  This would prevent the queue error from causing\n   * the queue to be deleted, allowing the user to inspect all the waves in the\n   * queue.  Alternatively, the client may not report the event as complete\n   * until the user explicitly requests the queue error to be passed on to the\n   * inferior runtime.\n   */\n  AMD_DBGAPI_EVENT_KIND_QUEUE_ERROR = 6\n} amd_dbgapi_event_kind_t;\n\n/**\n * Obtain the next pending event for a process.\n *\n * \\param[in] process_id The process from which to retrieve pending events.\n *\n * \\param[out] event_id The event handle of the next pending event.  Each event\n * is only returned once.  If there are no pending events the\n * ::AMD_DBGAPI_EVENT_NONE handle is returned.\n *\n * \\param[out] kind The kind of the returned event.  If there are no pending\n * events, then ::AMD_DBGAPI_EVENT_KIND_NONE is returned.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and an event or the NULL event has been returned.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized; and \\p event_id and \\p kind are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized; and \\p event_id and \\p kind\n * are unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID The \\p process_id is\n * invalid.  No event is retrieved and \\p event_id and \\p kind are\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p event_id or \\p kind\n * are NULL.  No event is retrieved and \\p event_id and \\p kind are unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_next_pending_event (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_event_id_t *event_id,\n    amd_dbgapi_event_kind_t *kind) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Inferior runtime state.\n */\ntypedef enum\n{\n  /**\n   * The runtime has been loaded and debugging is supported by the library.\n   */\n  AMD_DBGAPI_RUNTIME_STATE_LOADED_SUCCESS = 1,\n  /**\n   * The runtime has been unloaded.\n   */\n  AMD_DBGAPI_RUNTIME_STATE_UNLOADED = 2,\n  /**\n   * The runtime has been loaded but there is a restriction error that prevents\n   * debugging the process.  See ::AMD_DBGAPI_STATUS_ERROR_RESTRICTION for\n   * possible reasons.\n   */\n  AMD_DBGAPI_RUNTIME_STATE_LOADED_ERROR_RESTRICTION = 3\n} amd_dbgapi_runtime_state_t;\n\n/**\n * Event queries that are supported by ::amd_dbgapi_event_get_info.\n *\n * Each query specifies the type of data returned in the \\p value argument to\n * ::amd_dbgapi_event_get_info.\n */\ntypedef enum\n{\n  /**\n   * Return the event kind.  The type of this attribute is\n   * ::amd_dbgapi_event_kind_t.\n   */\n  AMD_DBGAPI_EVENT_INFO_KIND = 1,\n  /**\n   * Return the wave of a ::AMD_DBGAPI_EVENT_KIND_WAVE_STOP or\n   * ::AMD_DBGAPI_EVENT_KIND_WAVE_COMMAND_TERMINATED event.  The type of this\n   * attribute is a ::amd_dbgapi_wave_id_t.\n   */\n  AMD_DBGAPI_EVENT_INFO_WAVE = 2,\n  /**\n   * Return the breakpoint of a ::AMD_DBGAPI_EVENT_KIND_BREAKPOINT_RESUME\n   * event.  The type of this attribute is a ::amd_dbgapi_breakpoint_id_t.\n   */\n  AMD_DBGAPI_EVENT_INFO_BREAKPOINT = 3,\n  /**\n   * Return the client thread of a ::AMD_DBGAPI_EVENT_KIND_BREAKPOINT_RESUME\n   * event.  The type of this attribute is a ::amd_dbgapi_client_thread_id_t.\n   */\n  AMD_DBGAPI_EVENT_INFO_CLIENT_THREAD = 4,\n  /**\n   * Return if the runtime loaded in the inferior is supported by the library\n   * for a ::AMD_DBGAPI_EVENT_KIND_RUNTIME event.  The type of this\n   * attribute is \\p uint32_t with a value defined by\n   * ::amd_dbgapi_runtime_state_t.\n   */\n  AMD_DBGAPI_EVENT_INFO_RUNTIME_STATE = 5\n} amd_dbgapi_event_info_t;\n\n/**\n * Query information about an event.\n *\n * ::amd_dbgapi_event_info_t specifies the queries supported and the\n * type returned using the \\p value argument.\n *\n * \\param[in] process_id The process to which \\p event_id belongs.\n *\n * \\param[in] event_id The event being queried.\n *\n * \\param[in] query The query being requested.\n *\n * \\param[in] value_size Size of the memory pointed to by \\p value.  Must be\n * equal to the byte size of the query result.\n *\n * \\param[out] value Pointer to memory where the query result is stored.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the result is stored in \\p value.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID The \\p process_id is\n * invalid.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_EVENT_ID \\p event_id is invalid\n * or the NULL event.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p value is NULL or\n * \\p query is for an attribute not present for the kind of the event.\n * \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT_SIZE \\p value_size does\n * not match the size of the result.  \\p value is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_CLIENT_CALLBACK This will be\n * reported if the amd_dbgapi_callbacks_s::allocate_memory callback used to\n * allocate \\p value returns NULL.  \\p value is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_event_get_info (\n    amd_dbgapi_process_id_t process_id, amd_dbgapi_event_id_t event_id,\n    amd_dbgapi_event_info_t query, size_t value_size,\n    void *value) AMD_DBGAPI_VERSION_0_30;\n\n/**\n * Report that an event has been processed.\n *\n * Every event returned by ::amd_dbgapi_next_pending_event must be reported\n * as processed exactly once.\n *\n * \\param[in] process_id The process to which \\p event_id belongs.\n *\n * \\param[in] event_id The event that has been processed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and the event has been reported as processed.  The \\p event_id\n * is invalidated.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID The \\p process_id is\n * invalid.  No event is marked as processed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_EVENT_ID The \\p event_id is\n * invalid or the NULL event.  No event is marked as processed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p event_id or \\p kind\n * are NULL.  No event is marked as processed.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_event_processed (\n    amd_dbgapi_process_id_t process_id,\n    amd_dbgapi_event_id_t event_id) AMD_DBGAPI_VERSION_0_24;\n\n/** @} */\n\n/** \\defgroup logging_group Logging\n *\n * Control logging.\n *\n * When the library is initially loaded the logging level is set to\n * ::AMD_DBGAPI_LOG_LEVEL_NONE.  The log level is not changed by\n * ::amd_dbgapi_initialize or ::amd_dbgapi_finalize.\n *\n * The log messages are delivered to the client using the\n * amd_dbgapi_callbacks_s::log_message call back.\n *\n * Note that logging can be helpful for debugging.\n *\n * @{\n */\n\n/**\n * The logging levels supported.\n */\ntypedef enum\n{\n  /**\n   * Print no messages.\n   */\n  AMD_DBGAPI_LOG_LEVEL_NONE = 0,\n  /**\n   * Print fatal error messages.  Any library function that returns the\n   * ::AMD_DBGAPI_STATUS_FATAL status code also logs a message with this level.\n   */\n  AMD_DBGAPI_LOG_LEVEL_FATAL_ERROR = 1,\n  /**\n   * Print fatal error and warning messages.\n   */\n  AMD_DBGAPI_LOG_LEVEL_WARNING = 2,\n  /**\n   * Print fatal error, warning, and info messages.\n   */\n  AMD_DBGAPI_LOG_LEVEL_INFO = 3,\n  /**\n   * Print fatal error, warning, info, and verbose messages.\n   */\n  AMD_DBGAPI_LOG_LEVEL_VERBOSE = 4\n} amd_dbgapi_log_level_t;\n\n/**\n * Set the logging level.\n *\n * Internal logging messages less than the set logging level will not be\n * reported.  If ::AMD_DBGAPI_LOG_LEVEL_NONE then no messages will be reported.\n *\n * This function can be used even when the library is uninitialized.  However,\n * no messages will be reported until the library is initialized when the\n * callbacks are provided.\n *\n * \\param[in] level The logging level to set.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p level is invalid.  The\n * logging level is ot changed.\n */\nvoid AMD_DBGAPI amd_dbgapi_set_log_level (amd_dbgapi_log_level_t level)\n    AMD_DBGAPI_VERSION_0_24;\n\n/** @} */\n\n/** \\defgroup callbacks_group Callbacks\n *\n * The library requires the client to provide a number of services.  These\n * services are specified by providing callbacks when initializing\n * the library using ::amd_dbgapi_initialize.\n *\n * The callbacks defined in this section are invoked by the library and must\n * not themselves invoke any function provided by the library before returning.\n *\n * @{\n */\n\n/**\n * Opaque shared library handle.\n *\n * Only unique within a single process.\n *\n * The implementation of the library requests the client to notify it when a\n * specific shared library is loaded and unloaded.  This allows the library to\n * set breakpoints within the shared library and access global variable data\n * within it.\n */\ntypedef struct\n{\n  uint64_t handle;\n} amd_dbgapi_shared_library_id_t;\n\n/**\n * The state of a shared library.\n */\ntypedef enum\n{\n  /**\n   * The shared library is loaded.\n   */\n  AMD_DBGAPI_SHARED_LIBRARY_STATE_LOADED = 1,\n  /**\n   * The shared library is unloaded.\n   */\n  AMD_DBGAPI_SHARED_LIBRARY_STATE_UNLOADED = 2\n} amd_dbgapi_shared_library_state_t;\n\n/**\n * The NULL shared library handle.\n */\n#define AMD_DBGAPI_SHARED_LIBRARY_NONE (amd_dbgapi_shared_library_id_t{ 0 })\n\n/**\n * Report that a shared library enabled by the\n * amd_dbgapi_callbacks_s::enable_notify_shared_library callback has been\n * loaded or unloaded.\n *\n * The thread that is performing the shared library load or unload must remain\n * halted while this function executes.  This allows the library to use the\n * amd_dbgapi_callbacks_s::get_symbol_address,\n * amd_dbgapi_callbacks_s::insert_breakpoint and\n * amd_dbgapi_callbacks_s::remove_breakpoint callbacks to add or remove\n * breakpoints on library load or unload respectively.  The breakpoints must be\n * inserted before any code can execute in the shared library.\n *\n * \\param[in] process_id The process to which the \\p shared_library_id belongs.\n *\n * \\param[in] shared_library_id The shared library that has been loaded or\n * unloaded.\n *\n * \\param[in] shared_library_state The shared library state.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The amd-dbgapi\n * library is left uninitialized and \\p resume is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The amd-dbgapi library is\n * not initialized.  The amd-dbgapi library is left uninitialized.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID The \\p process_id is\n * invalid.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_SHARED_LIBRARY_ID The \\p\n * shared_library_id is invalid.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p shared_library_state\n * is invalid.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR \\p shared_library_state is not consistent\n * with the previously reported load state.  For example, it is reported as\n * loaded when previously also reported as loaded.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_report_shared_library (\n    amd_dbgapi_process_id_t process_id,\n    amd_dbgapi_shared_library_id_t shared_library_id,\n    amd_dbgapi_shared_library_state_t shared_library_state)\n    AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Opaque breakpoint handle.\n *\n * Every breakpoint added within a process will have a unique handle.  Only\n * unique within a single process.\n *\n * The implementation of the library requests the client to insert breakpoints\n * in certain functions so that it can be notified when certain actions are\n * being performed, and to stop the thread performing the action.  This allows\n * the data to be retrieved and updated without conflicting with the thread.\n * The library will resume the thread when it has completed the access.\n */\ntypedef struct\n{\n  uint64_t handle;\n} amd_dbgapi_breakpoint_id_t;\n\n/**\n * The NULL breakpoint handle.\n */\n#define AMD_DBGAPI_BREAKPOINT_NONE ((amd_dbgapi_breakpoint_id_t) (0))\n\n/**\n * The action to perform after reporting a breakpoint has been hit.\n */\ntypedef enum\n{\n  /**\n   * Resume execution.\n   */\n  AMD_DBGAPI_BREAKPOINT_ACTION_RESUME = 1,\n  /**\n   * Leave execution halted.\n   */\n  AMD_DBGAPI_BREAKPOINT_ACTION_HALT = 2\n} amd_dbgapi_breakpoint_action_t;\n\n/**\n * Opaque client thread handle.\n *\n * A pointer to client data associated with a thread.  This pointer is\n * passed in to the ::amd_dbgapi_report_breakpoint_hit so it can be\n * passed out by the ::AMD_DBGAPI_EVENT_KIND_BREAKPOINT_RESUME event to\n * allow the client of the library to identify the thread that must be\n * resumed.\n */\ntypedef struct amd_dbgapi_client_thread_s *amd_dbgapi_client_thread_id_t;\n\n/**\n * Report that a breakpoint inserted by the\n * amd_dbgapi_callbacks_s::insert_breakpoint calback has been hit.\n *\n * The thread that hit the breakpoint must remain halted while this\n * function executes, at which point it must be resumed if\n * \\p breakpoint_action is ::AMD_DBGAPI_BREAKPOINT_ACTION_RESUME.  If\n * \\p breakpoint_action is :AMD_DBGAPI_BREAKPOINT_ACTION_HALT then the client\n * should process pending events which will cause a\n * ::AMD_DBGAPI_EVENT_KIND_BREAKPOINT_RESUME event to be added which specifies\n * that the thread should now be resumed.\n *\n * \\param[in] process_id The process to which the \\p client_thread_id hitting\n * the breakpoint belongs.\n *\n * \\param[in] breakpoint_id The breakpoint that has been hit.\n *\n * \\param[in] client_thread_id The client identification of the thread that\n * hit the breakpoint.\n *\n * \\param[out] breakpoint_action Indicate if the thread hitting the breakpoint\n * should be resumed or remain halted when this function returns.\n *\n * \\retval ::AMD_DBGAPI_STATUS_SUCCESS The function has been executed\n * successfully and \\p breakpoint_action indicates if the thread hitting the\n * breakpoint should be resumed.\n *\n * \\retval ::AMD_DBGAPI_STATUS_FATAL A fatal error occurred.  The library is\n * left uninitialized and \\p breakpoint_action is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_NOT_INITIALIZED The library is not\n * initialized.  The library is left uninitialized and \\p breakpoint_action is\n * unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_PROCESS_ID The \\p process_id is\n * invalid.  \\p breakpoint_action is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_BREAKPOINT_ID The\n * \\p breakpoint_id is invalid.  \\p breakpoint_action is unaltered.\n *\n * \\retval ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT \\p breakpoint_action is\n * NULL.  \\p breakpoint_action is unaltered.\n */\namd_dbgapi_status_t AMD_DBGAPI amd_dbgapi_report_breakpoint_hit (\n    amd_dbgapi_process_id_t process_id,\n    amd_dbgapi_breakpoint_id_t breakpoint_id,\n    amd_dbgapi_client_thread_id_t client_thread_id,\n    amd_dbgapi_breakpoint_action_t *breakpoint_action) AMD_DBGAPI_VERSION_0_24;\n\n/**\n * Callbacks that the client of the library must provide.\n *\n * The client implementation of the callbacks must not invoke any operation of\n * the library.\n */\nstruct amd_dbgapi_callbacks_s\n{\n\n  /**\n   * Allocate memory to be used to return a value from the library that is then\n   * owned by the client.\n   *\n   * The memory should be suitably aligned for any type.  If \\p byte_size is 0\n   * or if unable to allocate memory of the byte size specified by \\p byte_size\n   * then return NULL and allocate no memory.  The client is responsible for\n   * deallocating this memory, and so is responsible for tracking the size of\n   * the allocation.  Note that these requirements can be met by implementing\n   * using \\p malloc.\n   */\n  void *(*allocate_memory) (size_t byte_size);\n\n  /**\n   * Deallocate memory that was allocated by\n   * amd_dbgapi_callbacks_s::allocate_memory.\n   *\n   * \\p data will be a pointer returned by\n   * amd_dbgapi_callbacks_s::allocate_memory that will not be returned to the\n   * client.  If \\p data is NULL then it indicates the allocation failed or was\n   * for 0 bytes: in either case the callback is required to take no action.\n   * If \\p data is not NULL then it will not have been deallocated by a\n   * previous call to amd_dbgapi_callbacks_s::allocate_memory.  Note that these\n   * requirements can be met by implementing using \\p free.\n   *\n   * Note this callback may be used by the library implementation if it\n   * encounters an error after using amd_dbgapi_callbacks_s::allocate_memory to\n   * allocate memory.\n   */\n  void (*deallocate_memory) (void *data);\n\n  /**\n   * Return the native operating system process handle for the process\n   * identified by the client process handle.  This value is required to not\n   * change during the lifetime of the process associated with the client\n   * process handle.\n   *\n   * For Linux<sup>&reg;</sup> this is the \\p pid_t from \\p sys/types.h and is\n   * required to have already been \\p ptrace enabled.\n   *\n   * \\p client_process_id is the client handle of the process for which the\n   * operating system process handle is being queried.\n   *\n   * \\p os_pid must be set to the native operating system process handle.\n   *\n   * Return ::AMD_DBGAPI_STATUS_SUCCESS if successful and \\p os_pid is updated.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR_INVALID_CLIENT_PROCESS_ID if the \\p\n   * client_process_id handle is invalid.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR_PROCESS_EXITED if the \\p\n   * client_process_id handle is associated with a native operating system\n   * process that has already exited.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT if \\p os_pid is NULL.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR if an error was encountered.\n   */\n  amd_dbgapi_status_t (*get_os_pid) (\n      amd_dbgapi_client_process_id_t client_process_id,\n      amd_dbgapi_os_process_id_t *os_pid);\n\n  /**\n   * Request to be notified when a shared library is loaded and unloaded.\n   *\n   * If multiple shared libraries match the name, then the client must only\n   * associate \\p shared_library_id with a single shared library, and only\n   * invoke ::amd_dbgapi_report_shared_library for that single shared library.\n   *\n   * \\p client_process_id is the client handle of the process in which loading\n   * of the shared library must be notified.\n   *\n   * \\p shared_library_name is the name of the shared library being requested.\n   * The memory is owned by the library and is only valid while the callback\n   * executes.  On Linux this is the \\p SONAME of the library.\n   *\n   * \\p shared_library_id is the handle to identify this shared library which\n   * must be specified when ::amd_dbgapi_report_shared_library is used to\n   * report a shared library load or unload.\n   *\n   * \\p shared_library_state must be set to a value that indicates whether the\n   * shared library is already loaded.\n   *\n   * Return ::AMD_DBGAPI_STATUS_SUCCESS if successful.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR_INVALID_CLIENT_PROCESS_ID if the\n   * \\p client_process_id handle is invalid.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT if\n   * \\p shared_library_name or \\p shared_library_state are NULL or\n   * \\p shared_library_name is an invalid library name.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR if the \\p shared_library_name shared\n   * library is already enabled for notifications or another error was\n   * encountered.\n   */\n  amd_dbgapi_status_t (*enable_notify_shared_library) (\n      amd_dbgapi_client_process_id_t client_process_id,\n      const char *shared_library_name,\n      amd_dbgapi_shared_library_id_t shared_library_id,\n      amd_dbgapi_shared_library_state_t *shared_library_state);\n\n  /**\n   * Request to stop being notified for a shared library previously set by\n   * amd_dbgapi_callbacks_s::enable_notify_shared_library.\n   *\n   * \\p shared_library_id is invalidated.\n   *\n   * \\p client_process_id is the client handle of the process in which loading\n   * of the shared library is being notified.\n   *\n   * \\p shared_library_id is the handle of the shared library to stop being\n   * notified.\n   *\n   * Return ::AMD_DBGAPI_STATUS_SUCCESS if successful.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR_INVALID_CLIENT_PROCESS_ID if the\n   * \\p client_process_id handle is invalid.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR_INVALID_SHARED_LIBRARY_ID if the\n   * \\p shared_library_id handle is invalid.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR if an error was encountered.\n   */\n  amd_dbgapi_status_t (*disable_notify_shared_library) (\n      amd_dbgapi_client_process_id_t client_process_id,\n      amd_dbgapi_shared_library_id_t shared_library_id);\n  /**\n   * Return the address of a symbol in a shared library.\n   *\n   * \\p client_process_id is the client handle of the process being queried.\n   *\n   * \\p shared_library_id is the shared library that contains the symbol.\n   *\n   * \\p symbol_name is the name of the symbol being requested.  The memory is\n   * owned by the library and is only valid while the callback executes.\n   *\n   * \\p address must be updated with the address of the symbol.\n   *\n   * Return ::AMD_DBGAPI_STATUS_SUCCESS if successful.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR_INVALID_CLIENT_PROCESS_ID if the\n   * \\p client_process_id handle is invalid.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR_INVALID_SHARED_LIBRARY_ID if the\n   * \\p shared_library_id handle is invalid.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR_LIBRARY_NOT_LOADED if\n   * \\p shared_library_id shared library is not currently loaded.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR_SYMBOL_NOT_FOUND if\n   * \\p shared_library_id shared library is loaded but does not contain\n   * \\p symbol_name.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR_INVALID_ARGUMENT if \\p symbol_name or\n   * \\p address are NULL.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR if an error was encountered.\n   */\n  amd_dbgapi_status_t (*get_symbol_address) (\n      amd_dbgapi_client_process_id_t client_process_id,\n      amd_dbgapi_shared_library_id_t shared_library_id,\n      const char *symbol_name, amd_dbgapi_global_address_t *address);\n\n  /**\n   * Insert a breakpoint in a shared library using a global address.\n   *\n   * The library only inserts breakpoints in loaded shared libraries.  It will\n   * request to be notified when the shared library is unloaded, and will\n   * remove any breakpoints it has inserted when notified that the shared\n   * library is unloaded.\n   *\n   * It is the client's responsibility to to actually insert the breakpoint.\n   *\n   * \\p client_process_id is the client handle of the process in which the\n   * breakpoint is to be added.\n   *\n   * \\p shared_library_id is the shared library that contains the \\p address.\n   *\n   * \\p address is the global address to add the breakpoint.\n   *\n   * \\p breakpoint_id is the handle to identify this breakpoint.  Each\n   * added breakpoint for a process will have a unique handle, multiple\n   * breakpoints for the same process will not be added with the same handle.\n   * It must be specified when ::amd_dbgapi_report_breakpoint_hit is used to\n   * report a breakpoint hit, and in the\n   * ::AMD_DBGAPI_EVENT_KIND_BREAKPOINT_RESUME event that may be used to resume\n   * the thread.\n   *\n   * Return ::AMD_DBGAPI_STATUS_SUCCESS if successful.  The breakpoint is\n   * added.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR_INVALID_CLIENT_PROCESS_ID if the \\p\n   * client_process_id handle is invalid.  No breakpoint is added.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR_INVALID_SHARED_LIBRARY_ID if the \\p\n   * shared_library_id handle is invalid.  No breakpoint is added.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR_LIBRARY_NOT_LOADED if \\p\n   * shared_library_id shared library is not currently loaded.  No breakpoint\n   * is added.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR_INVALID_ADDRESS if \\p address is not an\n   * address in shared library \\p shared_library_id.  No breakpoint is added.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR_INVALID_BREAKPOINT_ID if there is a\n   * breakpoint already added with \\p breakpoint_id.  No breakpoint is added.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR if another error was encountered.  No\n   * breakpoint is inserted and the \\p breakpoint_id handle is invalidated.\n   */\n  amd_dbgapi_status_t (*insert_breakpoint) (\n      amd_dbgapi_client_process_id_t client_process_id,\n      amd_dbgapi_shared_library_id_t shared_library_id,\n      amd_dbgapi_global_address_t address,\n      amd_dbgapi_breakpoint_id_t breakpoint_id);\n\n  /**\n   * Remove a breakpoint previously inserted by\n   * amd_dbgapi_callbacks_s::insert_breakpoint.\n   *\n   * It is the client's responsibility to to actually remove the breakpoint.\n   *\n   * \\p breakpoint_id is invalidated.\n   *\n   * \\p client_process_id is the client handle of the process in which the\n   * breakpoint is to be removed.\n   *\n   * \\p breakpoint_id is the breakpoint handle of the breakpoint to remove.\n   *\n   * Return ::AMD_DBGAPI_STATUS_SUCCESS if successful.  The breakpoint is\n   * removed.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR_INVALID_CLIENT_PROCESS_ID if the\n   * \\p client_process_id handle is invalid.  No breakpoint is removed.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR_INVALID_BREAKPOINT_ID if \\p breakpoint_id\n   * handle is invalid.  No breakpoint is removed.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR_LIBRARY_NOT_LOADED if the\n   * shared library containing the breakpoint is not currently loaded.  The\n   * breakpoint will already have been removed.\n   *\n   * Return ::AMD_DBGAPI_STATUS_ERROR if another error was encountered.  The\n   * breakpoint is considered removed and the \\p breakpoint_id\n   * handle is invalidated.\n   */\n  amd_dbgapi_status_t (*remove_breakpoint) (\n      amd_dbgapi_client_process_id_t client_process_id,\n      amd_dbgapi_breakpoint_id_t breakpoint_id);\n\n  /**\n   * Report a log message.\n   *\n   * \\p level is the log level.\n   *\n   * \\p message is a NUL terminated string to print that is owned by the\n   * library and is only valid while the callback executes.\n   */\n  void (*log_message) (amd_dbgapi_log_level_t level, const char *message);\n};\n\n/** @} */\n\n#if defined(__cplusplus)\n} /* extern \"C\" */\n#endif /* defined (__cplusplus) */\n\n#endif /* amd-dbgapi.h */\n"
    },
    "skipped": [],
    "total_files": 48
}