{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-i7toh3zidlll7lxwnp72zprwcwg4ub7m/spack-src/configure.ac": "# -*- shell-script -*-\n#\n# Copyright (c) 2004-2009 The Trustees of Indiana University and Indiana\n#                         University Research and Technology\n#                         Corporation.  All rights reserved.\n# Copyright (c) 2004-2015 The University of Tennessee and The University\n#                         of Tennessee Research Foundation.  All rights\n#                         reserved.\n# Copyright (c) 2004-2007 High Performance Computing Center Stuttgart,\n#                         University of Stuttgart.  All rights reserved.\n# Copyright (c) 2004-2005 The Regents of the University of California.\n#                         All rights reserved.\n# Copyright (c) 2006-2020 Cisco Systems, Inc.  All rights reserved\n# Copyright (c) 2006-2008 Sun Microsystems, Inc.  All rights reserved.\n# Copyright (c) 2006-2017 Los Alamos National Security, LLC.  All rights\n#                         reserved.\n# Copyright (c) 2009      Oak Ridge National Labs.  All rights reserved.\n# Copyright (c) 2011-2013 NVIDIA Corporation.  All rights reserved.\n# Copyright (c) 2012      Oracle and/or its affiliates.  All rights reserved.\n# Copyright (c) 2013      Mellanox Technologies, Inc.\n#                         All rights reserved.\n# Copyright (c) 2013-2020 Intel, Inc.  All rights reserved.\n# Copyright (c) 2014-2019 Research Organization for Information Science\n#                         and Technology (RIST).  All rights reserved.\n# Copyright (c) 2016-2017 IBM Corporation.  All rights reserved.\n# Copyright (c) 2018      Amazon.com, Inc. or its affiliates.\n#                         All Rights reserved.\n# $COPYRIGHT$\n#\n# Additional copyrights may follow\n#\n# $HEADER$\n#\n\n############################################################################\n# Initialization, version number, and other random setup/init stuff\n############################################################################\n\n# Load in everything found by autogen.pl\nm4_include([config/autogen_found_items.m4])\n\n# Load the version number code\nm4_include([config/prte_get_version.m4])\nAC_LANG([C])\n\n# Init autoconf\n# We don't have the version number to put in here yet, and we can't\n# call PRTE_GET_VERSION (etc.) before AC_INIT.  So use the shell\n# version.  project_name_* comes from config/project_list.m4, which\n# was set during autogen.pl.\n\nAC_INIT([project_name_long],\n        [m4_normalize(esyscmd([config/prte_get_version.sh VERSION --tarball]))],\n        [https://github.com/openpmix/prte/], [project_name_short])\n\nAC_PREREQ(2.60)\nAC_CONFIG_AUX_DIR(config)\nAC_CONFIG_MACRO_DIR(config)\nPRTE_CAPTURE_CONFIGURE_CLI([PRTE_CONFIGURE_CLI])\n\n# Get our platform support file.  This has to be done very, very early\n# because it twiddles random bits of autoconf\nPRTE_LOAD_PLATFORM\n\n#\n# Start it up\n#\n\nPRTE_CONFIGURE_SETUP\n\nprte_show_title \"Configuring PRTE\"\n\n#\n# Setup some things that must be done before AM-INIT-AUTOMAKE\n#\n\nprte_show_subtitle \"Startup tests\"\n\nAC_CHECK_PROG([PERL],[perl],[perl],[no])\nAS_IF([test \"X$PERL\" = \"Xno\"],\n      [AC_MSG_ERROR([\"PRTE requires perl. Aborting\"])])\n\nAC_CANONICAL_HOST\nAC_CANONICAL_TARGET\nAC_DEFINE_UNQUOTED(PRTE_ARCH, \"$target\", [PRTE architecture string])\n\nAS_IF([test \"$host\" != \"$target\"],\n      [AC_MSG_WARN([Cross-compile detected])\n       AC_MSG_WARN([Cross-compiling is only partially supported])\n       AC_MSG_WARN([Proceed at your own risk!])])\n\n# AC_USE_SYSTEM_EXTENSIONS alters CFLAGS (e.g., adds -g -O2)\n\nPRTE_VAR_SCOPE_PUSH([CFLAGS_save])\nCFLAGS_save=$CFLAGS\nAC_USE_SYSTEM_EXTENSIONS\n\n# AC_USE_SYSTEM_EXTENSIONS will modify CFLAGS if nothing was in there\n# beforehand.  We don't want that.  So if there was nothing in\n# CFLAGS, put nothing back in there.\n\nAS_IF([test -z \"$CFLAGS_save\"], [CFLAGS=])\n\nPRTE_VAR_SCOPE_POP\n\n#\n# Init automake\n#\n\nAM_INIT_AUTOMAKE([foreign dist-bzip2 subdir-objects no-define 1.12.2])\n\n# SILENT_RULES is new in AM 1.11, but we require 1.11 or higher via\n# autogen.  Limited testing shows that calling SILENT_RULES directly\n# works in more cases than adding \"silent-rules\" to INIT_AUTOMAKE\n# (even though they're supposed to be identical).  Shrug.\n\nAM_SILENT_RULES([yes])\n\n# Make configure depend on the VERSION file, since it's used in AC_INIT\nAC_SUBST([CONFIGURE_DEPENDENCIES], ['$(top_srcdir)/VERSION'])\n\n# Sanity checks\nAC_DEFUN([PRTE_CHECK_DIR_FOR_SPACES],[\n    dir=\"$1\"\n    article=\"$2\"\n    label=\"$3\"\n\n    AC_MSG_CHECKING([directory of $label])\n    AC_MSG_RESULT([$dir])\n    AS_IF([test -n \"`echo $dir | grep ' '`\"],\n          [AC_MSG_WARN([This version of PRRTE does not support $article $label])\n           AC_MSG_WARN([with a path that contains spaces])\n           AC_MSG_ERROR([Cannot continue.])])\n])\n\nAC_DEFUN([PRTE_CANONICALIZE_PATH],[\n    case $host_os in\n    darwin*)\n        # MacOS does not have \"readlink -f\" or realpath (at least as\n        # of MacOS Cataline / 10.15).  Instead, use Python, because we\n        # know MacOS comes with a /usr/bin/python that has\n        # os.path.realpath.\n        $2=`/usr/bin/python -c 'import os; print os.path.realpath(\"'$1'\")'`\n        ;;\n    *)\n        $2=`readlink -f $1`\n        ;;\n    esac\n])\n\nPRTE_VAR_SCOPE_PUSH(prte_checkdir)\nPRTE_CHECK_DIR_FOR_SPACES([$srcdir], [a], [source tree])\nPRTE_CANONICALIZE_PATH([$srcdir], [prte_checkdir])\nPRTE_CHECK_DIR_FOR_SPACES([$prte_checkdir], [an], [absolute source tree])\nPRTE_CANONICALIZE_PATH([.], [prte_checkdir])\nPRTE_CHECK_DIR_FOR_SPACES([$prte_checkdir], [a], [build tree])\nPRTE_CHECK_DIR_FOR_SPACES([$prefix], [a], [prefix])\nPRTE_CANONICALIZE_PATH([$prefix], [prte_checkdir])\nPRTE_CHECK_DIR_FOR_SPACES([$prte_checkdir], [an], [absolute prefix])\nPRTE_VAR_SCOPE_POP\n\nprte_show_subtitle \"Checking versions\"\n\n# Get the version of PRTE that we are installing\nPRTE_SAVE_VERSION([PRTE], [PMIx Reference Run-Time Environment],\n                          [$srcdir/VERSION],\n                          [src/include/version.h])\n\n# Get shared library version numbers\n. $srcdir/VERSION\n\nAC_SUBST(libprrte_so_version)\nAC_SUBST(libprrte_common_alps_so_version)\n\n#\n# Get the versions of the autotools that were used to bootstrap us\n# (helpful for debugging reports)\n#\n\nAC_MSG_CHECKING([for bootstrap Autoconf version])\nacversion=`grep \"Generated by GNU Autoconf\" $0 | head -n 1 | awk '{ print $6 }'`\nAC_MSG_RESULT([$acversion])\n\nAC_MSG_CHECKING([for bootstrap Automake version])\nAC_MSG_RESULT([$am__api_version])\n\nAC_MSG_CHECKING([for boostrap Libtool version])\nltversion=`grep VERSION= $srcdir/config/ltmain.sh | head -n 1 | cut -d= -f2`\nAC_MSG_RESULT([$ltversion])\n\n# List header files to generate\n\nAC_CONFIG_HEADERS([src/include/prte_config.h])\n\nprte_show_subtitle \"Initialization, setup\"\n\nPRTE_TOP_BUILDDIR=\"`pwd`\"\nAC_SUBST(PRTE_TOP_BUILDDIR)\ncd \"$srcdir\"\nPRTE_TOP_SRCDIR=\"`pwd`\"\nAC_SUBST(PRTE_TOP_SRCDIR)\ncd \"$PRTE_TOP_BUILDDIR\"\nAC_MSG_NOTICE([builddir: $PRTE_TOP_BUILDDIR])\nAC_MSG_NOTICE([srcdir: $PRTE_TOP_SRCDIR])\n\nif test \"$PRTE_TOP_BUILDDIR\" != \"$PRTE_TOP_SRCDIR\"; then\n    AC_MSG_NOTICE([Detected VPATH build])\nfi\n\n# Setup the top of the src/include/prte_config.h file\n\nAH_TOP([/* -*- c -*-\n *\n * Copyright (c) 2004-2005 The Trustees of Indiana University.\n *                         All rights reserved.\n * Copyright (c) 2004-2005 The Trustees of the University of Tennessee.\n *                         All rights reserved.\n * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,\n *                         University of Stuttgart.  All rights reserved.\n * Copyright (c) 2004-2005 The Regents of the University of California.\n *                         All rights reserved.\n * Copyright (c) 2014      Intel, Inc. All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n *\n * Function: - OS, CPU and compiler dependent configuration\n */\n\n#ifndef PRTE_CONFIG_H\n#define PRTE_CONFIG_H\n\n#include \"prte_config_top.h\"\n])\n\nAH_BOTTOM([\n#include \"prte_config_bottom.h\"\n#endif /* PRTE_CONFIG_H */\n])\n\n# Other basic setup stuff (shared with components)\n\nPRTE_BASIC_SETUP\n\nPRTE_TOP_SRCDIR=\"$PRTE_TOP_SRCDIR\"\nPRTE_TOP_BUILDDIR=\"$PRTE_TOP_BUILDDIR\"\nAC_SUBST(PRTE_TOP_SRCDIR)\nAC_SUBST(PRTE_TOP_BUILDDIR)\n\n############################################################################\n# Configuration options\n############################################################################\n\nPRTE_CHECK_OS_FLAVORS\nPRTE_CONFIGURE_OPTIONS\n\nif test \"$enable_binaries\" = \"no\" && test \"$enable_dist\" = \"yes\"; then\n    AC_MSG_WARN([--disable-binaries is incompatible with --enable dist])\n    AC_MSG_ERROR([Cannot continue])\nfi\n\n\n############################################################################\n# Libtool: part one\n# (before C compiler setup)\n############################################################################\n\n#\n# Part one of libtool magic.  Default to: enable shared, disable static.\n#\n\nAM_ENABLE_SHARED\nAM_DISABLE_STATIC\nPRTE_SETUP_WRAPPER_INIT\n\n##################################\n# Check for known incompatibility\n##################################\n\n# Do *not* print a message that we're checking the OS because this\n# test is *not* meant to be an all-inclusive \"if it passes this test,\n# then configure must succeed\" test.  This test is *only* mean to\n# screen out the versions of OS X where we know OMPI will cause kernel\n# panics because of bad implementations of pty's.  See\n# https://svn.open-mpi.org/trac/ompi/ticket/1637 for details.\n#   OS X name         OS X Version    $host_os value\n# OS X Tiger             10.4.x           darwin8.x\n# OS X Leopard           10.5.x           darwin9.x\n# OS X Snow Leopard      10.6.x           darwin10.x\n# OS X Lion              10.7.x           darwin11.x\n# We do not support OS X before version 10.5 (Leopard)\ncase $host_os in\n# Corresponds to OS X 10.0 - 10.4 (additional [] quoting for m4)\ndarwin[[45678]]*)\n    AC_MSG_WARN([PRTE does not support OS X prior to version 10.5 (Leopard)])\n    AC_MSG_ERROR([Cannot continue])\nesac\n\n############################################################################\n# Check for compilers and preprocessors\n############################################################################\n\nprte_show_title \"Compiler and preprocessor tests\"\n\n##################################\n# C compiler characteristics\n##################################\n\nPRTE_SETUP_CC\n\n# Does the compiler support \"ident\"-like constructs?\n\nPRTE_CHECK_IDENT([CC], [CFLAGS], [c], [C])\n\n#\n# Check for some types\n#\n\nAC_CHECK_TYPES(int8_t)\nAC_CHECK_TYPES(uint8_t)\nAC_CHECK_TYPES(int16_t)\nAC_CHECK_TYPES(uint16_t)\nAC_CHECK_TYPES(int32_t)\nAC_CHECK_TYPES(uint32_t)\nAC_CHECK_TYPES(int64_t)\nAC_CHECK_TYPES(uint64_t)\nAC_CHECK_TYPES(int128_t)\nAC_CHECK_TYPES(__int128)\nAC_CHECK_TYPES(uint128_t)\nAC_CHECK_TYPES(long long)\nAC_CHECK_TYPES(__float128)\nAC_CHECK_TYPES(long double)\n# We only need these types if we're building the OMPI project, but\n# PRTE currently doesn't protect for their lack of presence well.\nAC_CHECK_HEADERS(complex.h)\nAC_CHECK_TYPES(float _Complex)\nAC_CHECK_TYPES(double _Complex)\nAC_CHECK_TYPES(long double _Complex)\nAC_CHECK_TYPES(intptr_t)\nAC_CHECK_TYPES(uintptr_t)\nAC_CHECK_TYPES(mode_t)\nAC_CHECK_TYPES(ssize_t)\nAC_CHECK_TYPES(ptrdiff_t)\n\n#\n# Check for type sizes\n#\n\nAC_CHECK_SIZEOF(_Bool)\nAC_CHECK_SIZEOF(char)\nAC_CHECK_SIZEOF(short)\nAC_CHECK_SIZEOF(int)\nAC_CHECK_SIZEOF(long)\nAC_CHECK_SIZEOF(long long)\nAC_CHECK_SIZEOF(float)\nAC_CHECK_SIZEOF(double)\n\nif test \"$ac_cv_type_long_double\" = yes; then\n    AC_CHECK_SIZEOF(long double)\nfi\n\nAC_CHECK_SIZEOF(long double)\nif test \"$ac_cv_type___float128\" = yes; then\n    AC_CHECK_SIZEOF(__float128)\nfi\n\n# We only need these types if we're building the OMPI project, but\n# PRTE currently doesn't protect for their lack of presence well.\nAC_CHECK_SIZEOF(float _Complex)\nAC_CHECK_SIZEOF(double _Complex)\nAC_CHECK_SIZEOF(long double _Complex)\n\nAC_CHECK_SIZEOF(void *)\nAC_CHECK_SIZEOF(size_t)\n\nif test \"$ac_cv_type_ssize_t\" = yes ; then\n    AC_CHECK_SIZEOF(ssize_t)\nfi\n\nif test \"$ac_cv_type_ptrdiff_t\" = yes; then\n    AC_CHECK_SIZEOF(ptrdiff_t)\nelse\n    AC_MSG_ERROR([ptrdiff_t type is not available, this is required by C99 standard.  Cannot continue])\nfi\n\nAC_CHECK_SIZEOF(wchar_t)\nAC_CHECK_SIZEOF(pid_t)\n\n# Check sizes of atomic types so we can define fixed-width types in PRTE\nAC_CHECK_SIZEOF(atomic_short, [],[[#include <stdatomic.h>]])\nAC_CHECK_SIZEOF(atomic_int,[],[[#include <stdatomic.h>]])\nAC_CHECK_SIZEOF(atomic_long,[],[[#include <stdatomic.h>]])\nAC_CHECK_SIZEOF(atomic_llong,[],[[#include <stdatomic.h>]])\n\n#\n# Check for type alignments\n#\n\nPRTE_C_GET_ALIGNMENT(bool, PRTE_ALIGNMENT_BOOL)\nPRTE_C_GET_ALIGNMENT(int8_t, PRTE_ALIGNMENT_INT8)\nPRTE_C_GET_ALIGNMENT(int16_t, PRTE_ALIGNMENT_INT16)\nPRTE_C_GET_ALIGNMENT(int32_t, PRTE_ALIGNMENT_INT32)\nPRTE_C_GET_ALIGNMENT(int64_t, PRTE_ALIGNMENT_INT64)\n\nif test \"$ac_cv_type_int128_t\" = yes ; then\n  PRTE_C_GET_ALIGNMENT(int128_t, PRTE_ALIGNMENT_INT128)\nfi\n\nPRTE_C_GET_ALIGNMENT(char, PRTE_ALIGNMENT_CHAR)\nPRTE_C_GET_ALIGNMENT(short, PRTE_ALIGNMENT_SHORT)\nPRTE_C_GET_ALIGNMENT(wchar_t, PRTE_ALIGNMENT_WCHAR)\nPRTE_C_GET_ALIGNMENT(int, PRTE_ALIGNMENT_INT)\nPRTE_C_GET_ALIGNMENT(long, PRTE_ALIGNMENT_LONG)\nPRTE_C_GET_ALIGNMENT(long long, PRTE_ALIGNMENT_LONG_LONG)\nPRTE_C_GET_ALIGNMENT(float, PRTE_ALIGNMENT_FLOAT)\nPRTE_C_GET_ALIGNMENT(double, PRTE_ALIGNMENT_DOUBLE)\nPRTE_C_GET_ALIGNMENT(long double, PRTE_ALIGNMENT_LONG_DOUBLE)\nif test \"$ac_cv_type___float128\" = yes; then\n    PRTE_C_GET_ALIGNMENT(__float128, PRTE_ALIGNMENT___FLOAT128)\nfi\n\n# We only need these types if we're building the OMPI project, but\n# PRTE currently doesn't protect for their lack of presence well.\nPRTE_C_GET_ALIGNMENT(float _Complex, PRTE_ALIGNMENT_FLOAT_COMPLEX)\nPRTE_C_GET_ALIGNMENT(double _Complex, PRTE_ALIGNMENT_DOUBLE_COMPLEX)\nPRTE_C_GET_ALIGNMENT(long double _Complex, PRTE_ALIGNMENT_LONG_DOUBLE_COMPLEX)\n\nPRTE_C_GET_ALIGNMENT(void *, PRTE_ALIGNMENT_VOID_P)\nPRTE_C_GET_ALIGNMENT(size_t, PRTE_ALIGNMENT_SIZE_T)\n\n#\n# Check for other compiler characteristics\n#\n\nPRTE_C_WEAK_SYMBOLS\nPRTE_C_MACRO_WEAK_SYMBOLS\n\n\nif test \"x$CC\" = \"xicc\"; then\n    PRTE_CHECK_ICC_VARARGS\nfi\n\n# Check if we support the offsetof compiler directive\nPRTE_CHECK_OFFSETOF\n\n##################################\n# Only after setting up C check compiler attributes.\n##################################\n\nprte_show_subtitle \"Compiler characteristics\"\n\nPRTE_CHECK_ATTRIBUTES\nPRTE_CHECK_COMPILER_VERSION_ID\n\n##################################\n# Assembler Configuration\n##################################\n\nprte_show_subtitle \"Assembler\"\n\nAM_PROG_AS\nPRTE_CONFIG_ASM\n\n##################################\n# Header files\n##################################\n\nprte_show_title \"Header file tests\"\n\nAC_CHECK_HEADERS([alloca.h aio.h arpa/inet.h dirent.h \\\n    dlfcn.h endian.h execinfo.h err.h fcntl.h grp.h libgen.h \\\n    libutil.h memory.h netdb.h netinet/in.h netinet/tcp.h \\\n    poll.h pthread.h pty.h pwd.h sched.h \\\n    strings.h stropts.h linux/ethtool.h linux/sockios.h \\\n    sys/fcntl.h sys/ipc.h sys/shm.h \\\n    sys/ioctl.h sys/mman.h sys/param.h sys/queue.h \\\n    sys/resource.h sys/select.h sys/socket.h sys/sockio.h \\\n    sys/stat.h sys/statfs.h sys/statvfs.h sys/time.h sys/tree.h \\\n    sys/types.h sys/uio.h sys/un.h net/uio.h sys/utsname.h sys/vfs.h sys/wait.h syslog.h \\\n    termios.h ulimit.h unistd.h util.h utmp.h malloc.h \\\n    ifaddrs.h crt_externs.h regex.h mntent.h paths.h \\\n    ioLib.h sockLib.h hostLib.h shlwapi.h sys/synch.h db.h ndbm.h zlib.h ieee754.h])\n\nAC_CHECK_HEADERS([sys/mount.h], [], [],\n[AC_INCLUDES_DEFAULT\n#if HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n])\n\nAC_CHECK_HEADERS([sys/sysctl.h], [], [],\n[AC_INCLUDES_DEFAULT\n#if HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n])\n\n# Needed to work around Darwin requiring sys/socket.h for\n# net/if.h\n\nAC_CHECK_HEADERS([net/if.h], [], [],\n    [#include <stdio.h>\n#if STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#else\n# if HAVE_STDLIB_H\n#  include <stdlib.h>\n# endif\n#endif\n#if HAVE_SYS_SOCKET_H\n# include <sys/socket.h>\n#endif\n])\n\n# checkpoint results\nAC_CACHE_SAVE\n\n##################################\n# Types\n##################################\n\nprte_show_title \"Type tests\"\n\nAC_CHECK_TYPES([socklen_t, struct sockaddr_in, struct sockaddr_in6,\n                struct sockaddr_storage, struct ifreq, struct ethtool_cmd],\n               [], [], [AC_INCLUDES_DEFAULT\n#if HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#ifdef HAVE_LINUX_ETHTOOL_H\n#include <linux/ethtool.h>\n#endif\n#ifdef HAVE_NET_IF_H\n#include <net/if.h>\n#endif])\n\nAC_CHECK_DECLS([ethtool_cmd_speed, SIOCETHTOOL],\n               [], [], [AC_INCLUDES_DEFAULT\n#ifdef HAVE_LINUX_ETHTOOL_H\n#include <linux/ethtool.h>\n#endif\n#ifdef HAVE_LINUX_SOCKIOS_H\n#include <linux/sockios.h>\n#endif])\n\nAC_CHECK_MEMBERS([struct ethtool_cmd.speed_hi],\n               [], [], [AC_INCLUDES_DEFAULT\n#ifdef HAVE_LINUX_ETHTOOL_H\n#include <linux/ethtool.h>\n#endif\n#ifdef HAVE_LINUX_SOCKIOS_H\n#include <linux/sockios.h>\n#endif])\n\nAC_CHECK_MEMBERS([struct ethtool_cmd.speed_hi],\n               [], [], [AC_INCLUDES_DEFAULT\n#ifdef HAVE_LINUX_ETHTOOL_H\n#include <linux/ethtool.h>\n#endif\n#ifdef HAVE_LINUX_SOCKIOS_H\n#include <linux/sockios.h>\n#endif])\n\nAC_CHECK_MEMBERS([struct ethtool_cmd.speed_hi],\n               [], [], [AC_INCLUDES_DEFAULT\n#ifdef HAVE_LINUX_ETHTOOL_H\n#include <linux/ethtool.h>\n#endif\n#ifdef HAVE_LINUX_SOCKIOS_H\n#include <linux/sockios.h>\n#endif])\n\nAC_CHECK_MEMBERS([struct ethtool_cmd.speed_hi],\n               [], [], [AC_INCLUDES_DEFAULT\n#ifdef HAVE_LINUX_ETHTOOL_H\n#include <linux/ethtool.h>\n#endif\n#ifdef HAVE_LINUX_SOCKIOS_H\n#include <linux/sockios.h>\n#endif])\n\nAC_CHECK_DECLS([AF_UNSPEC, PF_UNSPEC, AF_INET6, PF_INET6],\n               [], [], [AC_INCLUDES_DEFAULT\n#if HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif])\n\n# SA_RESTART in signal.h\n\nPRTE_VAR_SCOPE_PUSH([MSG])\nAC_MSG_CHECKING([if SA_RESTART defined in signal.h])\nAC_EGREP_CPP(yes, [\n#include <signal.h>\n#ifdef SA_RESTART\n    yes\n#endif ], [MSG=yes VALUE=1], [MSG=no VALUE=0])\nAC_DEFINE_UNQUOTED(PRTE_HAVE_SA_RESTART, $VALUE,\n    [Whether we have SA_RESTART in <signal.h> or not])\nAC_MSG_RESULT([$MSG])\nPRTE_VAR_SCOPE_POP\n\nAC_CHECK_MEMBERS([struct sockaddr.sa_len], [], [], [\n#include <sys/types.h>\n#if HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif])\n\nAC_CHECK_MEMBERS([struct dirent.d_type], [], [], [\n#include <sys/types.h>\n#include <dirent.h>])\n\nAC_CHECK_MEMBERS([siginfo_t.si_fd],,,[#include <signal.h>])\n\nAC_CHECK_MEMBERS([siginfo_t.si_band],,,[#include <signal.h>])\n\n#\n# Checks for struct member names in struct statfs\n#\n\nAC_CHECK_MEMBERS([struct statfs.f_type], [], [], [\nAC_INCLUDES_DEFAULT\n#ifdef HAVE_SYS_VFS_H\n#include <sys/vfs.h>\n#endif\n#ifdef HAVE_SYS_STATFS_H\n#include <sys/statfs.h>\n#endif\n])\n\nAC_CHECK_MEMBERS([struct statfs.f_fstypename], [], [], [\nAC_INCLUDES_DEFAULT\n#ifdef HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n#ifdef HAVE_SYS_MOUNT_H\n#include <sys/mount.h>\n#endif\n#ifdef HAVE_SYS_VFS_H\n#include <sys/vfs.h>\n#endif\n#ifdef HAVE_SYS_STATFS_H\n#include <sys/statfs.h>\n#endif\n])\n\n#\n# Checks for struct member names in struct statvfs\n#\n\nAC_CHECK_MEMBERS([struct statvfs.f_basetype], [], [], [\nAC_INCLUDES_DEFAULT\n#ifdef HAVE_SYS_STATVFS_H\n#include <sys/statvfs.h>\n#endif\n])\n\nAC_CHECK_MEMBERS([struct statvfs.f_fstypename], [], [], [\nAC_INCLUDES_DEFAULT\n#ifdef HAVE_SYS_STATVFS_H\n#include <sys/statvfs.h>\n#endif\n])\n\n#\n# Check for ptrdiff type.  Yes, there are platforms where\n# sizeof(void*) != sizeof(long) (64 bit Windows, apparently).\n#\n\nAC_MSG_CHECKING([for pointer diff type])\nif test $ac_cv_type_ptrdiff_t = yes ; then\n    prte_ptrdiff_t=\"ptrdiff_t\"\n    prte_ptrdiff_size=$ac_cv_sizeof_ptrdiff_t\nelif test $ac_cv_sizeof_void_p -eq $ac_cv_sizeof_long ; then\n    prte_ptrdiff_t=\"long\"\n    prte_ptrdiff_size=$ac_cv_sizeof_long\nelif test $ac_cv_type_long_long = yes && test $ac_cv_sizeof_void_p -eq $ac_cv_sizeof_long_long ; then\n    prte_ptrdiff_t=\"long long\"\n    prte_ptrdiff_size=$ac_cv_sizeof_long_long\nelse\n    AC_MSG_ERROR([Could not find datatype to emulate ptrdiff_t.  Cannot continue])\nfi\n\nAC_DEFINE_UNQUOTED([PRTE_PTRDIFF_TYPE], [$prte_ptrdiff_t],\n    [type to use for ptrdiff_t])\nAC_MSG_RESULT([$prte_ptrdiff_t (size: $prte_ptrdiff_size)])\n\n#\n# Find corresponding types for MPI_Aint, MPI_Count, and MPI_Offset.\n# And if relevant, find the corresponding MPI_ADDRESS_KIND,\n# MPI_COUNT_KIND, and MPI_OFFSET_KIND.\n#\n\n# checkpoint results\nAC_CACHE_SAVE\n\n##################################\n# Linker characteristics\n##################################\n\nAC_MSG_CHECKING([the linker for support for the -fini option])\nPRTE_VAR_SCOPE_PUSH([LDFLAGS_save])\nLDFLAGS_save=$LDFLAGS\nLDFLAGS=\"$LDFLAGS_save -Wl,-fini -Wl,finalize\"\nAC_TRY_LINK([void finalize (void) {}], [], [AC_MSG_RESULT([yes])\n        prte_ld_have_fini=1], [AC_MSG_RESULT([no])\n        prte_ld_have_fini=0])\nLDFLAGS=$LDFLAGS_save\nPRTE_VAR_SCOPE_POP\n\n##################################\n# Libraries\n##################################\n\nprte_show_title \"Library and Function tests\"\n\n# Darwin doesn't need -lutil, as it's something other than this -lutil.\nPRTE_SEARCH_LIBS_CORE([openpty], [util])\n\nPRTE_SEARCH_LIBS_CORE([gethostbyname], [nsl])\n\nPRTE_SEARCH_LIBS_CORE([socket], [socket])\n\n# Solaris has sched_yield in -lrt, usually in libc\nPRTE_SEARCH_LIBS_CORE([sched_yield], [rt])\n\n# IRIX and CentOS have dirname in -lgen, usually in libc\nPRTE_SEARCH_LIBS_CORE([dirname], [gen])\n\n# Darwin doesn't need -lm, as it's a symlink to libSystem.dylib\nPRTE_SEARCH_LIBS_CORE([ceil], [m])\n\n# -lrt might be needed for clock_gettime\nPRTE_SEARCH_LIBS_CORE([clock_gettime], [rt])\n\nAC_CHECK_FUNCS([asprintf snprintf vasprintf vsnprintf openpty isatty getpwuid fork waitpid execve pipe ptsname setsid mmap tcgetpgrp posix_memalign strsignal sysconf syslog vsyslog regcmp regexec regfree _NSGetEnviron socketpair strncpy_s usleep mkfifo dbopen dbm_open statfs statvfs setpgid setenv __malloc_initialize_hook])\n\n# Sanity check: ensure that we got at least one of statfs or statvfs.\n\nif test $ac_cv_func_statfs = no && test $ac_cv_func_statvfs = no; then\n    AC_MSG_WARN([neither statfs() and statvfs() were found])\n    AC_MSG_ERROR([Cannot continue])\nfi\n\n# On some hosts, htonl is a define, so the AC_CHECK_FUNC will get\n# confused.  On others, it's in the standard library, but stubbed with\n# the magic glibc foo as not implemented.  and on other systems, it's\n# just not there.  This covers all cases.\n\nAC_CACHE_CHECK([for htonl define],\n  [ompi_cv_htonl_define],\n  [AC_PREPROC_IFELSE([AC_LANG_PROGRAM([\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif],[\n#ifndef ntohl\n#error \"ntohl not defined\"\n#endif\n])], [prte_cv_htonl_define=yes], [prte_cv_htonl_define=no])])\n\nAC_CHECK_FUNC([htonl], [prte_have_htonl=yes], [prte_have_htonl=no])\n\nAS_IF([test \"$prte_cv_htonl_define\" = \"yes\" || test \"$prte_have_htonl\" = \"yes\"],\n    [AC_DEFINE_UNQUOTED([HAVE_UNIX_BYTESWAP], [1],\n        [whether unix byteswap routines -- htonl, htons, nothl, ntohs -- are available])])\n\n#\n# Make sure we can copy va_lists (need check declared, not linkable)\n#\n\nAC_CHECK_DECL(va_copy, PRTE_HAVE_VA_COPY=1, PRTE_HAVE_VA_COPY=0,\n    [#include <stdarg.h>])\n\nAC_DEFINE_UNQUOTED(PRTE_HAVE_VA_COPY, $PRTE_HAVE_VA_COPY,\n    [Whether we have va_copy or not])\n\nAC_CHECK_DECL(__va_copy, PRTE_HAVE_UNDERSCORE_VA_COPY=1,\n    PRTE_HAVE_UNDERSCORE_VA_COPY=0, [#include <stdarg.h>])\n\nAC_DEFINE_UNQUOTED(PRTE_HAVE_UNDERSCORE_VA_COPY, $PRTE_HAVE_UNDERSCORE_VA_COPY,\n    [Whether we have __va_copy or not])\n\nAC_CHECK_DECLS(__func__)\n\n# checkpoint results\nAC_CACHE_SAVE\n\n##################################\n# System-specific tests\n##################################\n\nprte_show_title \"System-specific tests\"\n\n# Do we have _SC_NPROCESSORS_ONLN? (only going to pass if we also have\n# <unistd.h> and sysconf(), which is ok) OS X 10.4 has <unistd.h> and\n# sysconf(), but does not have _SC_NPROCESSORS_ONLN.  Doh!\n\nAC_CACHE_CHECK([for _SC_NPROCESSORS_ONLN],\n  [ompi_cv_have__SC_NPROCESSORS_ONLN],\n  [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([\nAC_INCLUDES_DEFAULT\n#include <unistd.h>\n],\n     [int i = _SC_NPROCESSORS_ONLN;])],\n     [ompi_cv_have__SC_NPROCESSORS_ONLN=\"yes\"],\n     [ompi_cv_have__SC_NPROCESSORS_ONLN=\"no\"])])\n\nAS_IF([test \"$ompi_cv_have__SC_NPROCESSORS_ONLN\" = \"yes\"],\n      [result=1], [result=0])\n\nAC_DEFINE_UNQUOTED([PRTE_HAVE__SC_NPROCESSORS_ONLN], [$result],\n  [Define to 1 ifyou have the declaration of _SC_NPROCESSORS_ONLN, and to 0 otherwise])\n\n# all: endian\nAC_C_BIGENDIAN\n\nPRTE_CHECK_BROKEN_QSORT\n\n#\n# Check out what thread support we have\n#\n\nPRTE_CONFIG_THREADS\n\nCFLAGS=\"$CFLAGS $THREAD_CFLAGS\"\nLDFLAGS=\"$LDFLAGS $THREAD_LDFLAGS\"\nLIBS=\"$LIBS $THREAD_LIBS\"\n\nPRTE_WRAPPER_FLAGS_ADD([CFLAGS], [$THREAD_CFLAGS])\nPRTE_WRAPPER_FLAGS_ADD([LDFLAGS], [$THREAD_LDFLAGS])\n\n# no need to update WRAPPER_EXTRA_LIBS - we'll get it from LT later\n#\n# What is the local equivalent of \"ln -s\"\n#\n\nAC_PROG_LN_S\nAC_PROG_GREP\nAC_PROG_EGREP\n\n#\n# We need as and lex\n#\n\nAM_PROG_AS\nAM_PROG_LEX\n\n# If we don't have Flex and we don't have a generated .c file\n# (distribution tarballs will have the .c file included, but git\n# clones will not), then error.  Must have Flex -- other versions of\n# Lex are not workable (all things being equal, since this is *only*\n# required for developers, we decided that it really was not worth it\n# to be portable between different versions of lex ;-).\n\nif test -z \"$LEX\" || \\\n   test -n \"`echo $LEX | $GREP missing`\" || \\\n   test \"`basename $LEX`\" != \"flex\"; then\n    if test ! -f \"$srcdir/prte/util/show_help_lex.c\"; then\n        AC_MSG_WARN([*** Could not find Flex on your system.])\n        AC_MSG_WARN([*** Flex is required for developer builds of PRTE.])\n        AC_MSG_WARN([*** Other versions of Lex are not supported.])\n        AC_MSG_WARN([*** NOTE: If you are building from a tarball downloaded from the PRTE web site, you do not need Flex.])\n        AC_MSG_ERROR([Cannot continue])\n    fi\nfi\n\n#\n# Look for ps command and arguments\n#\nPRTE_PS_FLAVOR_CHECK\n\n#\n# File system case sensitivity\n#\n\nPRTE_CASE_SENSITIVE_FS_SETUP\n\n#\n# Do we have RLIMIT_NPROC in <sys/resources.h>? (e.g., Solaris does not)\n#\n\nAC_CHECK_DECLS([RLIMIT_NPROC], [], [], [\nAC_INCLUDES_DEFAULT\n#if HAVE_SYS_RESOURCE_H\n#include <sys/resource.h>\n#endif])\n\n#\n# Do we have RLIMIT_MEMLOCK in <sys/resources.h>? (e.g., Solaris does not)\n#\n\nAC_CHECK_DECLS([RLIMIT_MEMLOCK], [], [], [\nAC_INCLUDES_DEFAULT\n#if HAVE_SYS_RESOURCE_H\n#include <sys/resource.h>\n#endif])\n\n#\n# Do we have RLIMIT_NOFILE in <sys/resources.h>? (e.g., Solaris does not)\n#\n\nAC_CHECK_DECLS([RLIMIT_NOFILE], [], [], [\nAC_INCLUDES_DEFAULT\n#if HAVE_SYS_RESOURCE_H\n#include <sys/resource.h>\n#endif])\n\n#\n# Do we have RLIMIT_MEMLOCK in <sys/resources.h>? (e.g., Solaris does not)\n#\n\nAC_CHECK_DECLS([RLIMIT_FSIZE], [], [], [\nAC_INCLUDES_DEFAULT\n#if HAVE_SYS_RESOURCE_H\n#include <sys/resource.h>\n#endif])\n\n#\n# Do we have RLIMIT_CORE in <sys/resources.h>? (e.g., Solaris does not)\n#\n\nAC_CHECK_DECLS([RLIMIT_CORE], [], [], [\nAC_INCLUDES_DEFAULT\n#if HAVE_SYS_RESOURCE_H\n#include <sys/resource.h>\n#endif])\n\n#\n# Do we have RLIMIT_STACK in <sys/resources.h>? (e.g., Solaris does not)\n#\n\nAC_CHECK_DECLS([RLIMIT_STACK], [], [], [\nAC_INCLUDES_DEFAULT\n#if HAVE_SYS_RESOURCE_H\n#include <sys/resource.h>\n#endif])\n\n#\n# Do we have RLIMIT_AS in <sys/resources.h>? (e.g., Solaris does not)\n#\n\nAC_CHECK_DECLS([RLIMIT_AS], [], [], [\nAC_INCLUDES_DEFAULT\n#if HAVE_SYS_RESOURCE_H\n#include <sys/resource.h>\n#endif])\n\n# checkpoint results\nAC_CACHE_SAVE\n\n##################################\n# Libevent\n##################################\n\nprte_show_title \"Configure event library support - libev\"\n\nPRTE_LIBEV_CONFIG\n\nprte_show_title \"Configure event library support - libevent\"\n\nPRTE_LIBEVENT_CONFIG\n\nAS_IF([test $prte_libevent_support -eq 1 && test $prte_libev_support -eq 1],\n      [AC_MSG_WARN([Both libevent and libev support have been specified.])\n       AC_MSG_WARN([Only one can be configured against at a time. Please])\n       AC_MSG_WARN([remove one from the configure command line.])\n       AC_MSG_ERROR([Cannot continue])])\n\nAS_IF([test $prte_libevent_support -eq 0 && test $prte_libev_support -eq 0],\n      [AC_MSG_WARN([Either libevent or libev support is required, but neither])\n       AC_MSG_WARN([was found. Please use the configure options to point us])\n       AC_MSG_WARN([to where we can find one or the other library])\n       AC_MSG_ERROR([Cannot continue])])\n\n##################################\n# PMIx\n##################################\n\nprte_show_title \"Configure PMIx\"\n\nPRTE_CHECK_PMIX\n\n##################################\n# HWLOC\n##################################\n\nprte_show_title \"Configure HWLOC\"\n\nPRTE_HWLOC_CONFIG\n\n##################################\n# MCA\n##################################\n\nprte_show_title \"Modular Component Architecture (MCA) setup\"\n\nAC_MSG_CHECKING([for subdir args])\nPRTE_CONFIG_SUBDIR_ARGS([prte_subdir_args])\nAC_MSG_RESULT([$prte_subdir_args])\n\nPRTE_MCA\n\n# checkpoint results\nAC_CACHE_SAVE\n\n##################################\n# Visibility\n##################################\n# Check the visibility declspec at the end to avoid problem with\n# the previous tests that are not necessarily prepared for\n# the visibility feature.\n\nprte_show_title \"Symbol visibility feature\"\n\nPRTE_CHECK_VISIBILITY\n\n##################################\n# STOP-ON-EXEC\n##################################\n# Check ptrace support for stop-on-exec\n\nprte_show_title \"Ptrace stop-on-exec support\"\n\nPRTE_CHECK_PTRACE\n\n############################################################################\n# Final top-level PRTE configuration\n############################################################################\n\nprte_show_title \"Final top-level PRTE configuration\"\n\n############################################################################\n# Libtool: part two\n# (after C compiler setup = no compiler/linker tests after this)\n############################################################################\nprte_show_subtitle \"Libtool configuration\"\n\n# Use the undocumented solaris_use_stlport4 libtool variable to turn off any\n# Cstd/stlport4 linkage. This allows PRTE to be C++ STL agnostic.\nif test \"x$prte_cv_c_compiler_vendor\" = \"xsun\"; then\n    solaris_use_stlport4=\"yes\"\nfi\n\nLT_INIT([dlopen win32-dll])\n\n\n# What's the suffix of shared libraries?  Inspired by generated\n# Libtool code (even though we don't support several of these\n# platforms, there didn't seem to be any harm in leaving in some of\n# them, alhtough I did remove some that we have never/will never\n# support, like OS/2).\nPRTE_DYN_LIB_PREFIX=lib\ncase $host_os in\ncygwin*)\n    PRTE_DYN_LIB_PREFIX=cyg\n    PRTE_DYN_LIB_SUFFIX=dll\n    ;;\nmingw* | pw32* | cegcc*)\n    PRTE_DYN_LIB_SUFFIX=dll\n    ;;\ndarwin* | rhapsody*)\n    PRTE_DYN_LIB_SUFFIX=dylib\n    ;;\nhpux9* | hpux10* | hpux11*)\n    case $host_cpu in\n        ia64*)\n        PRTE_DYN_LIB_SUFFIX=so\n        ;;\n    *)\n        PRTE_DYN_LIB_SUFFIX=sl\n        ;;\n    esac\n    ;;\n*)\n   PRTE_DYN_LIB_SUFFIX=so\n   ;;\nesac\n\nAC_SUBST(PRTE_DYN_LIB_PREFIX)\nAC_SUBST(PRTE_DYN_LIB_SUFFIX)\n\n# Need the libtool binary before the rpathify stuff\nLT_OUTPUT\n\n############################################################################\n# final compiler config\n############################################################################\nprte_show_subtitle \"Compiler flags\"\n\n#\n# This is needed for VPATH builds, so that it will -I the appropriate\n# include directory.  We delayed doing it until now just so that\n# '-I$(top_srcdir)' doesn't show up in any of the configure output --\n# purely aesthetic.\n#\n\n# Because prte_config.h is created by AC_CONFIG_HEADERS, we\n# don't need to -I the builddir for prte/include. However, we do\n# need to add it for prte as it doesn't have an AC_CONFIG_HEADERS that\n# will install it for us. If we VPATH building, we do need to include the\n# source directories, however.\n#\n\nif test \"$PRTE_TOP_BUILDDIR\" != \"$PRTE_TOP_SRCDIR\"; then\n    # Note the embedded m4 directives here -- we must embed them\n    # rather than have successive assignments to these shell\n    # variables, lest the $(foo) names try to get evaluated here.\n    # Yuck!\n    cpp_includes=\"$PRTE_TOP_SRCDIR $PRTE_TOP_BUILDDIR $PRTE_TOP_SRCDIR/src/include $PRTE_TOP_BUILDDIR/src/include\"\nelse\n    cpp_includes=\"$PRTE_TOP_SRCDIR $PRTE_TOP_SRCDIR/src/include\"\nfi\nCPP_INCLUDES=\"$(echo $cpp_includes | $SED 's/[[^ \\]]* */'\"$prte_cc_iquote\"'&/g')\"\nCPPFLAGS=\"$CPP_INCLUDES $CPPFLAGS $PRTE_FINAL_CPPFLAGS\"\nLDFLAGS=\"$LDFLAGS $PRTE_FINAL_LDFLAGS\"\nLIBS=\"$LIBS $PRTE_FINAL_LIBS\"\n\n#\n# Delayed the substitution of CFLAGS and CXXFLAGS until now because\n# they may have been modified throughout the course of this script.\n#\n\nAC_SUBST(CFLAGS)\n\n#\n# Aggregate MCA parameters directory\n#\nAC_SUBST([AMCA_PARAM_SETS_DIR], ['$(prtedatadir)/amca-param-sets'])\n\n############################################################################\n# final wrapper compiler config\n############################################################################\nprte_show_subtitle \"Wrapper compiler final setup\"\n\nPRTE_SETUP_WRAPPER_FINAL\n\n# If there is a local hook, call it.\nm4_ifdef([prte_CONFIG_LOCAL], [prte_CONFIG_LOCAL])\n\n############################################################################\n# Check for building man pages\n############################################################################\nprte_show_subtitle \"Man page setup\"\nPRTE_SETUP_MAN_PAGES\n\n\n############################################################################\n# Party on\n############################################################################\n\nAC_MSG_CHECKING([if libtool needs -no-undefined flag to build shared libraries])\n\ncase \"`uname`\" in\n  CYGWIN*|MINGW*|AIX*)\n    ## Add in the -no-undefined flag to LDFLAGS for libtool.\n    AC_MSG_RESULT([yes])\n    LDFLAGS=\"$LDFLAGS -no-undefined\"\n    ;;\n  *)\n    ## Don't add in anything.\n    AC_MSG_RESULT([no])\n    ;;\nesac\n\n# prtedatadir, prtelibdir, and prteinclude are essentially the same as\n# pkg*dir, but will always be */prte.\n\nprtedatadir='${datadir}/prte'\nprtelibdir='${libdir}/prte'\nprteincludedir='${includedir}/prte'\nAC_SUBST(prtedatadir)\nAC_SUBST(prtelibdir)\nAC_SUBST(prteincludedir)\n\nPRTE_SET_MCA_PREFIX([PRTE_MCA_])\nPRTE_SET_MCA_CMD_LINE_ID([mca])\n\nprte_want_prd=0\n\nprte_show_subtitle \"Final output\"\n\nAC_CONFIG_FILES([\n    Makefile\n    config/Makefile\n    contrib/Makefile\n])\n\nPRTE_CONFIG_FILES\n\nPRTE_CHECK_LIBNL_SUMMARY\n\nAC_OUTPUT\n\nPRTE_SUMMARY_PRINT\n",
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-i7toh3zidlll7lxwnp72zprwcwg4ub7m/spack-src/config/prte_configure_options.m4": "dnl -*- shell-script -*-\ndnl\ndnl Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana\ndnl                         University Research and Technology\ndnl                         Corporation.  All rights reserved.\ndnl Copyright (c) 2004-2005 The University of Tennessee and The University\ndnl                         of Tennessee Research Foundation.  All rights\ndnl                         reserved.\ndnl Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,\ndnl                         University of Stuttgart.  All rights reserved.\ndnl Copyright (c) 2004-2005 The Regents of the University of California.\ndnl                         All rights reserved.\ndnl Copyright (c) 2006-2020 Cisco Systems, Inc.  All rights reserved\ndnl Copyright (c) 2007      Sun Microsystems, Inc.  All rights reserved.\ndnl Copyright (c) 2009      IBM Corporation.  All rights reserved.\ndnl Copyright (c) 2009-2013 Los Alamos National Security, LLC.  All rights\ndnl                         reserved.\ndnl Copyright (c) 2009      Oak Ridge National Labs.  All rights reserved.\ndnl\ndnl Copyright (c) 2016-2020 Intel, Inc.  All rights reserved.\ndnl $COPYRIGHT$\ndnl\ndnl Additional copyrights may follow\ndnl\ndnl $HEADER$\ndnl\n\n\nAC_DEFUN([PRTE_CONFIGURE_OPTIONS],[\nprte_show_subtitle \"PRTE Configuration options\"\n\n#\n# Do we want prte's --prefix behavior to be enabled by default?\n#\nAC_MSG_CHECKING([if want prte \"--prefix\" behavior to be enabled by default])\nAC_ARG_ENABLE([prte-prefix-by-default],\n    [AC_HELP_STRING([--enable-prte-prefix-by-default],\n        [Make \"prte ...\" behave exactly the same as \"prte --prefix \\$prefix\" (where \\$prefix is the value given to --prefix in configure)])])\nif test \"$enable_prte_prefix_by_default\" = \"yes\"; then\n    AC_MSG_RESULT([yes])\n    prte_want_prte_prefix_by_default=1\nelse\n    AC_MSG_RESULT([no])\n    prte_want_prte_prefix_by_default=0\nfi\nAC_DEFINE_UNQUOTED([PRTE_WANT_PRTE_PREFIX_BY_DEFAULT],\n                   [$prte_want_prte_prefix_by_default],\n                   [Whether we want prte to effect \"--prefix $prefix\" by default])\n\n#\n# Is this a developer copy?\n#\n\nif test -d .git; then\n    PRTE_DEVEL=1\nelse\n    PRTE_DEVEL=0\nfi\n\n#\n# Developer picky compiler options\n#\n\nAC_MSG_CHECKING([if want developer-level compiler pickyness])\nAC_ARG_ENABLE(picky,\n    AC_HELP_STRING([--enable-picky],\n                   [enable developer-level compiler pickyness when building Open MPI (default: disabled, unless a .git directory is found in the build tree)]))\nif test \"$enable_picky\" = \"yes\"; then\n    AC_MSG_RESULT([yes])\n    WANT_PICKY_COMPILER=1\nelse\n    AC_MSG_RESULT([no])\n    WANT_PICKY_COMPILER=0\nfi\n#################### Developer default override ####################\nif test \"$WANT_PICKY_COMPILER\" = \"0\" && test -z \"$enable_picky\" && test \"$PRTE_DEVEL\" = 1; then\n    WANT_PICKY_COMPILER=1\n    echo \"--> developer override: enable picky compiler by default\"\nfi\n#################### Developer default override ####################\n\n#\n# Developer debugging\n#\nAC_MSG_CHECKING([if want developer-level debugging code])\nAC_ARG_ENABLE(debug,\n    AC_HELP_STRING([--enable-debug],\n                   [enable developer-level debugging code (not for general MPI users!) (default: disabled)]))\nif test \"$enable_debug\" = \"yes\"; then\n    AC_MSG_RESULT([yes])\n    WANT_DEBUG=1\nelse\n    AC_MSG_RESULT([no])\n    WANT_DEBUG=0\nfi\n\n\nif test \"$WANT_DEBUG\" = \"0\"; then\n    CFLAGS=\"-DNDEBUG $CFLAGS\"\n    CXXFLAGS=\"-DNDEBUG $CXXFLAGS\"\nfi\nAC_DEFINE_UNQUOTED(PRTE_ENABLE_DEBUG, $WANT_DEBUG,\n    [Whether we want developer-level debugging code or not])\n\nAC_ARG_ENABLE(debug-symbols,\n    AC_HELP_STRING([--disable-debug-symbols],\n        [Disable adding compiler flags to enable debugging symbols if --enable-debug is specified.  For non-debugging builds, this flag has no effect.]))\n\n#\n# Do we want to install the internal devel headers?\n#\nAC_MSG_CHECKING([if want to install project-internal header files])\nAC_ARG_WITH(devel-headers,\n    AC_HELP_STRING([--with-devel-headers],\n                   [Normal PRTE users/applications do not need this.  Developer headers are only necessary for authors doing deeper integration (default: disabled).]))\nif test \"$with_devel_headers\" = \"yes\"; then\n    AC_MSG_RESULT([yes])\n    WANT_INSTALL_HEADERS=1\nelse\n    AC_MSG_RESULT([no])\n    WANT_INSTALL_HEADERS=0\nfi\nAM_CONDITIONAL(WANT_INSTALL_HEADERS, test \"$WANT_INSTALL_HEADERS\" = 1)\n\n#\n# Do we want the pretty-print stack trace feature?\n#\n\nAC_MSG_CHECKING([if want pretty-print stacktrace])\nAC_ARG_ENABLE([pretty-print-stacktrace],\n    [AC_HELP_STRING([--enable-pretty-print-stacktrace],\n                    [Pretty print stacktrace on process signal (default: enabled)])])\nif test \"$enable_pretty_print_stacktrace\" = \"no\" ; then\n    AC_MSG_RESULT([no])\n    WANT_PRETTY_PRINT_STACKTRACE=0\nelse\n    AC_MSG_RESULT([yes])\n    WANT_PRETTY_PRINT_STACKTRACE=1\nfi\nAC_DEFINE_UNQUOTED([PRTE_WANT_PRETTY_PRINT_STACKTRACE],\n                   [$WANT_PRETTY_PRINT_STACKTRACE],\n                   [if want pretty-print stack trace feature])\n\n\n#\n# Do we want PTY support?\n#\n\nAC_MSG_CHECKING([if want pty support])\nAC_ARG_ENABLE(pty-support,\n    AC_HELP_STRING([--enable-pty-support],\n                   [Enable/disable PTY support for STDIO forwarding.  (default: enabled)]))\nif test \"$enable_pty_support\" = \"no\" ; then\n    AC_MSG_RESULT([no])\n    PRTE_ENABLE_PTY_SUPPORT=0\nelse\n    AC_MSG_RESULT([yes])\n    PRTE_ENABLE_PTY_SUPPORT=1\nfi\nAC_DEFINE_UNQUOTED([PRTE_ENABLE_PTY_SUPPORT], [$PRTE_ENABLE_PTY_SUPPORT],\n                   [Whether user wants PTY support or not])\n\n\n#\n# Do we want to allow DLOPEN?\n#\n\nAC_MSG_CHECKING([if want dlopen support])\nAC_ARG_ENABLE([dlopen],\n    [AC_HELP_STRING([--enable-dlopen],\n                    [Whether build should attempt to use dlopen (or\n                     similar) to dynamically load components.\n                     Disabling dlopen implies --disable-mca-dso.\n                     (default: enabled)])])\nif test \"$enable_dlopen\" = \"no\" ; then\n    enable_mca_dso=no\n    enable_mca_static=yes\n    PRTE_ENABLE_DLOPEN_SUPPORT=0\n    AC_MSG_RESULT([no])\nelse\n    PRTE_ENABLE_DLOPEN_SUPPORT=1\n    AC_MSG_RESULT([yes])\nfi\nAC_DEFINE_UNQUOTED(PRTE_ENABLE_DLOPEN_SUPPORT, $PRTE_ENABLE_DLOPEN_SUPPORT,\n    [Whether we want to enable dlopen support])\n\n\n#\n# Do we want to show component load error messages by default?\n#\n\nAC_MSG_CHECKING([for default value of mca_base_component_show_load_errors])\nAC_ARG_ENABLE([show-load-errors-by-default],\n    [AC_HELP_STRING([--enable-show-load-errors-by-default],\n                    [Set the default value for the MCA parameter\n                     mca_base_component_show_load_errors (but can be\n                     overridden at run time by the usual\n                     MCA-variable-setting mechansism).  This MCA variable\n                     controls whether warnings are displayed when an MCA\n                     component fails to load at run time due to an error.\n                     (default: enabled in --enable-debug builds, meaning that\n                      mca_base_component_show_load_errors is enabled\n                      by default when configured with --enable-debug])])\nif test \"$enable_show_load_errors_by_default\" = \"no\" ; then\n    PRTE_SHOW_LOAD_ERRORS_DEFAULT=0\n    AC_MSG_RESULT([disabled by default])\nelse\n    PRTE_SHOW_LOAD_ERRORS_DEFAULT=$WANT_DEBUG\n    if test \"$WANT_DEBUG\" = \"1\"; then\n        AC_MSG_RESULT([enabled by default])\n    else\n        AC_MSG_RESULT([disabled by default])\n    fi\nfi\nAC_DEFINE_UNQUOTED(PRTE_SHOW_LOAD_ERRORS_DEFAULT, $PRTE_SHOW_LOAD_ERRORS_DEFAULT,\n                   [Default value for mca_base_component_show_load_errors MCA variable])\n\n\n#\n# Handle embedded version strings\n#\nAC_MSG_CHECKING([if a proxy version string for prte is required])\nAC_ARG_WITH(proxy-version-string,\n    AC_HELP_STRING([--with-proxy-version-string],\n                   [Return the provided string when prte is used in proxy mode and the version is requested]))\nif test -n \"$with_proxy_version_string\"; then\n    AC_MSG_RESULT([yes])\n    PRTE_PROXY_VERSION_STRING=$with_proxy_version_string\nelse\n    AC_MSG_RESULT([no])\n    PRTE_PROXY_VERSION_STRING=$PRTE_VERSION\nfi\nAC_DEFINE_UNQUOTED(PRTE_PROXY_VERSION_STRING, \"$PRTE_PROXY_VERSION_STRING\",\n                   [Version string to be returned by prte when in proxy mode])\n\nAC_MSG_CHECKING([if a proxy package name for prte is required])\nAC_ARG_WITH(proxy-package-name,\n    AC_HELP_STRING([--with-proxy-package-name],\n                   [Return the provided string when prte is used in proxy mode and the package name is requested]))\nif test -n \"$with_proxy_package_name\"; then\n    AC_MSG_RESULT([yes])\n    PRTE_PROXY_PACKAGE_NAME=$with_proxy_package_name\nelse\n    AC_MSG_RESULT([no])\n    PRTE_PROXY_PACKAGE_NAME=\"PMIx Reference RunTime Environment\"\nfi\nAC_DEFINE_UNQUOTED(PRTE_PROXY_PACKAGE_NAME, \"$PRTE_PROXY_PACKAGE_NAME\",\n                   [Package name to be returned by prte when in proxy mode])\n\nAC_MSG_CHECKING([if a proxy bugreport path for prte is required])\nAC_ARG_WITH(proxy-bugreport,\n    AC_HELP_STRING([--with-proxy-bugreport],\n                   [Return the provided string when prte is used in proxy mode and the PACKAGE_BUGREPORT is requested]))\nif test -n \"$with_proxy_bugreport\"; then\n    AC_MSG_RESULT([yes])\n    PRTE_PROXY_BUGREPORT=$with_proxy_bugreport\nelse\n    AC_MSG_RESULT([no])\n    PRTE_PROXY_BUGREPORT=https://github.com/openpmix/prte/\nfi\nAC_DEFINE_UNQUOTED(PRTE_PROXY_BUGREPORT, \"$PRTE_PROXY_BUGREPORT\",\n                   [Bugreport string to be returned by prte when in proxy mode])\n\n\n#\n# Support per-user config files?\n#\nAC_ARG_ENABLE([per-user-config-files],\n   [AC_HELP_STRING([--enable-per-user-config-files],\n      [Disable per-user configuration files, to save disk accesses during job start-up.  This is likely desirable for large jobs.  Note that this can also be achieved by environment variables at run-time.  (default: enabled)])])\nif test \"$enable_per_user_config_files\" = \"no\" ; then\n  result=0\nelse\n  result=1\nfi\nAC_DEFINE_UNQUOTED([PRTE_WANT_HOME_CONFIG_FILES], [$result],\n     [Enable per-user config files])\n\n#\n# Do we want to enable IPv6 support?\n#\nAC_MSG_CHECKING([if want IPv6 support])\nAC_ARG_ENABLE([ipv6],\n    [AC_HELP_STRING([--enable-ipv6],\n        [Enable IPv6 support, but only if the underlying system supports it (default: disabled)])])\nif test \"$enable_ipv6\" = \"yes\"; then\n    AC_MSG_RESULT([yes])\n    prte_want_ipv6=1\nelse\n    AC_MSG_RESULT([no])\n    prte_want_ipv6=0\nfi\nAC_DEFINE_UNQUOTED([PRTE_ENABLE_IPV6], [$prte_want_ipv6],\n                   [Enable IPv6 support, but only if the underlying system supports it])\n\n\n# Add any extra lib?\nAC_ARG_WITH([prte-extra-lib],\n            AC_HELP_STRING([--with-prte-extra-lib=LIB],\n                           [Link the output PRTE library to this extra lib (used in embedded mode)]))\nAC_MSG_CHECKING([for extra lib])\nAS_IF([test ! -z \"$with_prte_extra_lib\"],\n      [AS_IF([test \"$with_prte_extra_lib\" = \"yes\" || test \"$with_prte_extra_lib\" = \"no\"],\n             [AC_MSG_RESULT([ERROR])\n              AC_MSG_WARN([Invalid value for --with-extra-prte-lib:])\n              AC_MSG_WARN([    $with_prte_extra_lib])\n              AC_MSG_WARN([Must be path name of the library to add])\n              AC_MSG_ERROR([Cannot continue])],\n             [AC_MSG_RESULT([$with_prte_extra_lib])\n              PRTE_EXTRA_LIB=$with_prte_extra_lib])],\n      [AC_MSG_RESULT([no])\n       PRTE_EXTRA_LIB=])\nAC_SUBST(PRTE_EXTRA_LIB)\n\n# Add any extra libtool lib?\nAC_ARG_WITH([prte-extra-ltlib],\n            AC_HELP_STRING([--with-prte-extra-ltlib=LIB],\n                           [Link any embedded components/tools that require it to the provided libtool lib (used in embedded mode)]))\nAC_MSG_CHECKING([for extra ltlib])\nAS_IF([test ! -z \"$with_prte_extra_ltlib\"],\n      [AS_IF([test \"$with_prte_extra_ltlib\" = \"yes\" || test \"$with_prte_extra_ltlib\" = \"no\"],\n             [AC_MSG_RESULT([ERROR])\n              AC_MSG_WARN([Invalid value for --with-prte-extra-ltlib:])\n              AC_MSG_WARN([    $with_prte_extra_ltlib])\n              AC_MSG_WARN([Must be path name of the library to add])\n              AC_MSG_ERROR([Cannot continue])],\n             [AC_MSG_RESULT([$with_prte_extra_ltlib])\n              PRTE_EXTRA_LTLIB=$with_prte_extra_ltlib])],\n      [AC_MSG_RESULT([no])\n       PRTE_EXTRA_LTLIB=])\nAC_SUBST(PRTE_EXTRA_LTLIB)\n\n# Add any extra LDFLAGS for the extra libs?\nAC_ARG_WITH([prte-extra-lib-ldflags],\n            AC_HELP_STRING([--with-prte-extra-lib-ldflags=flags],\n                           [Where to find the extra libs]))\nAC_MSG_CHECKING([for extra lib LDFLAGS])\nAS_IF([test ! -z \"$with_prte_extra_lib_ldflags\"],\n      [AS_IF([test \"$with_prte_extra_lib_ldflags\" = \"yes\" || test \"$with_prte_extra_lib_ldflags\" = \"no\"],\n             [AC_MSG_RESULT([ERROR])\n              AC_MSG_WARN([Invalid value for --with-prte-extra-lib-ldflags:])\n              AC_MSG_WARN([    $with_prte_extra_lib_ldflags])\n              AC_MSG_WARN([Must be path name pointing to the libs to add])\n              AC_MSG_ERROR([Cannot continue])],\n             [AC_MSG_RESULT([$with_prte_extra_lib_ldflags])\n              PRTE_EXTRA_LIB_LDFLAGS=$with_prte_extra_lib_ldflags])],\n      [AC_MSG_RESULT([no])\n       PRTE_EXTRA_LIB_LDFLAGS=])\nAC_SUBST(PRTE_EXTRA_LIB_LDFLAGS)\n\n#\n# Package/brand string\n#\nAC_MSG_CHECKING([if want package/brand string])\nAC_ARG_WITH([package-string],\n     [AC_HELP_STRING([--with-package-string=STRING],\n                     [Use a branding string throughout Open MPI])])\nif test \"$with_package_string\" = \"\" || test \"$with_package_string\" = \"no\"; then\n    with_package_string=\"Open MPI $PRTE_CONFIGURE_USER@$PRTE_CONFIGURE_HOST Distribution\"\nfi\nAC_DEFINE_UNQUOTED([PRTE_PACKAGE_STRING], [\"$with_package_string\"],\n     [package/branding string for Open MPI])\nAC_MSG_RESULT([$with_package_string])\n\n#\n# Ident string\n#\nAC_MSG_CHECKING([if want ident string])\nAC_ARG_WITH([ident-string],\n     [AC_HELP_STRING([--with-ident-string=STRING],\n                     [Embed an ident string into Open MPI object files])])\nif test \"$with_ident_string\" = \"\" || test \"$with_ident_string\" = \"no\"; then\n    with_ident_string=\"%VERSION%\"\nfi\n# This is complicated, because $PRTE_VERSION may have spaces in it.\n# So put the whole sed expr in single quotes -- i.e., directly\n# substitute %VERSION% for (not expanded) $PRTE_VERSION.\nwith_ident_string=\"`echo $with_ident_string | sed -e 's/%VERSION%/$PRTE_VERSION/'`\"\n\n# Now eval an echo of that so that the \"$PRTE_VERSION\" token is\n# replaced with its value.  Enclose the whole thing in \"\" so that it\n# ends up as 1 token.\nwith_ident_string=\"`eval echo $with_ident_string`\"\n\nAC_DEFINE_UNQUOTED([PRTE_IDENT_STRING], [\"$with_ident_string\"],\n     [ident string for Open MPI])\nAC_MSG_RESULT([$with_ident_string])\n\n\n# some systems don't want/like getpwuid\nAC_MSG_CHECKING([if want getpwuid support])\nAC_ARG_ENABLE([getpwuid],\n    [AC_HELP_STRING([--disable-getpwuid],\n        [Disable getpwuid support (default: enabled)])])\nif test \"$enable_getpwuid\" = \"no\"; then\n    AC_MSG_RESULT([no])\n    prte_want_getpwuid=0\nelse\n    AC_MSG_RESULT([yes])\n    prte_want_getpwuid=1\nfi\nAC_DEFINE_UNQUOTED([PRTE_ENABLE_GETPWUID], [$prte_want_getpwuid],\n                   [Disable getpwuid support (default: enabled)])\n\ndnl Check for zlib support\nPRTE_ZLIB_CONFIG\n\ndnl Check for FT\nAC_MSG_CHECKING([if want fault tolerance support])\nAC_ARG_ENABLE([prte-ft],\n    [AC_HELP_STRING([--enable-prte-ft],\n        [ENable PRRTE fault tolerance support (default: disabled)])])\nif test \"$enable_prte_ft\" = \"yes\"; then\n    AC_MSG_RESULT([yes])\n    prte_enable_ft=1\n    PRTE_SUMMARY_ADD([[Options]],[[Fault tolerance]], [prte_ft], [yes])\nelse\n    AC_MSG_RESULT([no])\n    prte_enable_ft=0\n    PRTE_SUMMARY_ADD([[Options]],[[Fault tolerance]], [prte_ft], [no])\nfi\nAC_DEFINE_UNQUOTED([PRTE_ENABLE_FT], [$prte_enable_ft],\n                   [Enable PRRTE fault tolerance support (default: disabled)])\n\n\n])dnl\n",
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-i7toh3zidlll7lxwnp72zprwcwg4ub7m/spack-src/src/mca/plm/alps/plm_alps_module.c": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana\n *                         University Research and Technology\n *                         Corporation.  All rights reserved.\n * Copyright (c) 2004-2006 The University of Tennessee and The University\n *                         of Tennessee Research Foundation.  All rights\n *                         reserved.\n * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,\n *                         University of Stuttgart.  All rights reserved.\n * Copyright (c) 2004-2005 The Regents of the University of California.\n *                         All rights reserved.\n * Copyright (c) 2006-2020 Cisco Systems, Inc.  All rights reserved\n * Copyright (c) 2007-2015 Los Alamos National Security, LLC.  All rights\n *                         reserved.\n * Copyright (c) 2014-2020 Intel, Inc.  All rights reserved.\n * Copyright (c) 2017-2019 Research Organization for Information Science\n *                         and Technology (RIST).  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n *\n * These symbols are in a file by themselves to provide nice linker\n * semantics.  Since linkers generally pull in symbols by object\n * files, keeping these symbols as the only symbols in this file\n * prevents utility programs such as \"ompi_info\" from having to import\n * entire components just to query their version and parameters.\n */\n\n#include \"prte_config.h\"\n#include \"constants.h\"\n#include \"types.h\"\n\n#include <sys/types.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n\n#include \"src/mca/base/base.h\"\n#include \"src/mca/prteinstalldirs/prteinstalldirs.h\"\n#include \"src/util/argv.h\"\n#include \"src/util/output.h\"\n#include \"src/util/prte_environ.h\"\n#include \"src/util/path.h\"\n#include \"src/util/basename.h\"\n\n#include \"src/runtime/prte_globals.h\"\n#include \"src/util/name_fns.h\"\n#include \"src/util/show_help.h\"\n#include \"src/threads/threads.h\"\n#include \"src/runtime/prte_wait.h\"\n#include \"src/mca/errmgr/errmgr.h\"\n#include \"src/mca/rmaps/rmaps.h\"\n#include \"src/mca/schizo/schizo.h\"\n#include \"src/mca/state/state.h\"\n\n#include \"src/mca/plm/plm.h\"\n#include \"src/mca/plm/base/base.h\"\n#include \"src/mca/plm/base/plm_private.h\"\n#include \"plm_alps.h\"\n\n\n/*\n * Local functions\n */\nstatic int plm_alps_init(void);\nstatic int plm_alps_launch_job(prte_job_t *jdata);\nstatic int plm_alps_terminate_orteds(void);\nstatic int plm_alps_signal_job(prte_jobid_t jobid, int32_t signal);\nstatic int plm_alps_finalize(void);\n\nstatic int plm_alps_start_proc(int argc, char **argv, char **env,\n                                char *prefix);\n\n\n/*\n * Global variable\n */\nprte_plm_base_module_t prte_plm_alps_module = {\n    plm_alps_init,\n    prte_plm_base_set_hnp_name,\n    plm_alps_launch_job,\n    NULL,\n    prte_plm_base_prted_terminate_job,\n    plm_alps_terminate_orteds,\n    prte_plm_base_prted_kill_local_procs,\n    plm_alps_signal_job,\n    plm_alps_finalize\n};\n\n/*\n * Local variables\n */\nstatic prte_proc_t *alpsrun = NULL;\nstatic bool failed_launch;\nstatic void launch_daemons(int fd, short args, void *cbdata);\n\n\n/**\n* Init the module\n */\nstatic int plm_alps_init(void)\n{\n    int rc;\n\n    if (PRTE_SUCCESS != (rc = prte_plm_base_comm_start())) {\n        PRTE_ERROR_LOG(rc);\n        return rc;\n    }\n\n    if (prte_do_not_launch) {\n        /* must map daemons since we won't be launching them */\n        prte_plm_globals.daemon_nodes_assigned_at_launch = true;\n    } else {\n        /* we do NOT assign daemons to nodes at launch - we will\n         * determine that mapping when the daemon\n         * calls back. This is required because alps does\n         * its own mapping of proc-to-node, and we cannot know\n         * in advance which daemon will wind up on which node\n         */\n        prte_plm_globals.daemon_nodes_assigned_at_launch = false;\n    }\n\n    /* point to our launch command */\n    if (PRTE_SUCCESS != (rc = prte_state.add_job_state(PRTE_JOB_STATE_LAUNCH_DAEMONS,\n                                                       launch_daemons, PRTE_SYS_PRI))) {\n        PRTE_ERROR_LOG(rc);\n        return rc;\n    }\n\n    return rc;\n}\n\n\n/* When working in this function, ALWAYS jump to \"cleanup\" if\n * you encounter an error so that prun will be woken up and\n * the job can cleanly terminate\n */\nstatic int plm_alps_launch_job(prte_job_t *jdata)\n{\n\n    if (PRTE_FLAG_TEST(jdata, PRTE_JOB_FLAG_RESTART)) {\n        /* this is a restart situation - skip to the mapping stage */\n        PRTE_ACTIVATE_JOB_STATE(jdata, PRTE_JOB_STATE_MAP);\n    } else {\n        /* new job - set it up */\n        PRTE_ACTIVATE_JOB_STATE(jdata, PRTE_JOB_STATE_INIT);\n    }\n    return PRTE_SUCCESS;\n}\n\nstatic void launch_daemons(int fd, short args, void *cbdata)\n{\n    prte_job_map_t *map;\n    char *param;\n    char **argv = NULL;\n    int argc;\n    int rc;\n    char *tmp;\n    char** env = NULL;\n    char *nodelist_flat;\n    char **nodelist_argv;\n    int nodelist_argc;\n    char *vpid_string;\n    char **custom_strings;\n    int num_args, i;\n    char *cur_prefix;\n    int proc_vpid_index;\n    prte_app_context_t *app;\n    prte_node_t *node;\n    int32_t nnode;\n    prte_job_t *daemons;\n    prte_state_caddy_t *state = (prte_state_caddy_t*)cbdata;\n    char *ltmp;\n\n    PRTE_ACQUIRE_OBJECT(state);\n\n    /* if we are launching debugger daemons, then just go\n     * do it - no new daemons will be launched\n     */\n    if (PRTE_FLAG_TEST(state->jdata, PRTE_JOB_FLAG_DEBUGGER_DAEMON)) {\n        state->jdata->state = PRTE_JOB_STATE_DAEMONS_LAUNCHED;\n        PRTE_ACTIVATE_JOB_STATE(state->jdata, PRTE_JOB_STATE_DAEMONS_REPORTED);\n        PRTE_RELEASE(state);\n        return;\n    }\n\n    /* start by setting up the virtual machine */\n    daemons = prte_get_job_data_object(PRTE_PROC_MY_NAME->jobid);\n    if (PRTE_SUCCESS != (rc = prte_plm_base_setup_virtual_machine(state->jdata))) {\n        PRTE_ERROR_LOG(rc);\n        goto cleanup;\n    }\n\n   /* if we don't want to launch, then don't attempt to\n     * launch the daemons - the user really wants to just\n     * look at the proposed process map\n     */\n    if (prte_do_not_launch) {\n        /* set the state to indicate the daemons reported - this\n         * will trigger the daemons_reported event and cause the\n         * job to move to the following step\n         */\n        state->jdata->state = PRTE_JOB_STATE_DAEMONS_LAUNCHED;\n        PRTE_ACTIVATE_JOB_STATE(state->jdata, PRTE_JOB_STATE_DAEMONS_REPORTED);\n        PRTE_RELEASE(state);\n        return;\n    }\n\n    /* Get the map for this job */\n    if (NULL == (map = daemons->map)) {\n        PRTE_ERROR_LOG(PRTE_ERR_NOT_FOUND);\n        rc = PRTE_ERR_NOT_FOUND;\n        goto cleanup;\n    }\n\n    if (0 == map->num_new_daemons) {\n        /* set the state to indicate the daemons reported - this\n         * will trigger the daemons_reported event and cause the\n         * job to move to the following step\n         */\n        PRTE_OUTPUT_VERBOSE((1, prte_plm_base_framework.framework_output,\n                             \"%s plm:alps: no new daemons to launch\",\n                             PRTE_NAME_PRINT(PRTE_PROC_MY_NAME)));\n        state->jdata->state = PRTE_JOB_STATE_DAEMONS_LAUNCHED;\n        PRTE_ACTIVATE_JOB_STATE(state->jdata, PRTE_JOB_STATE_DAEMONS_REPORTED);\n        PRTE_RELEASE(state);\n        return;\n    }\n\n    /*\n     * start building argv array\n     */\n    argv = NULL;\n    argc = 0;\n\n    /*\n     * ALPS aprun  OPTIONS\n     */\n\n    /* protect against launchers that forward the entire environment */\n    if (NULL != getenv(\"PMIX_LAUNCHER_PAUSE_FOR_TOOL\")) {\n        unsetenv(\"PMIX_LAUNCHER_PAUSE_FOR_TOOL\");\n    }\n    if (NULL != getenv(\"PMIX_LAUNCHER_RENDEZVOUS_FILE\")) {\n        unsetenv(\"PMIX_LAUNCHER_RENDEZVOUS_FILE\");\n    }\n\n    /* add the aprun command */\n    prte_argv_append(&argc, &argv, prte_plm_alps_component.aprun_cmd);\n\n    /* Append user defined arguments to aprun */\n    if ( NULL != prte_plm_alps_component.custom_args ) {\n        custom_strings = prte_argv_split(prte_plm_alps_component.custom_args, ' ');\n        num_args       = prte_argv_count(custom_strings);\n        for (i = 0; i < num_args; ++i) {\n            prte_argv_append(&argc, &argv, custom_strings[i]);\n        }\n        prte_argv_free(custom_strings);\n    }\n\n    /* number of processors needed */\n    prte_argv_append(&argc, &argv, \"-n\");\n    prte_asprintf(&tmp, \"%lu\", (unsigned long) map->num_new_daemons);\n    prte_argv_append(&argc, &argv, tmp);\n    free(tmp);\n    prte_argv_append(&argc, &argv, \"-N\");\n    prte_argv_append(&argc, &argv, \"1\");\n    prte_argv_append(&argc, &argv, \"-cc\");\n    prte_argv_append(&argc, &argv, \"none\");\n    /*\n     * stuff below is necessary in the event that we've sadly configured PRTE with --disable-dlopen,\n     * which results in the orted's being linked against all kinds of unnecessary cray libraries, including\n     * the cray pmi, which has a ctor that cause bad things if run when using mpirun/orted based launch.\n     *\n     * Code below adds env. variables for aprun to forward which suppresses the action of the Cray PMI ctor.\n     */\n    prte_argv_append(&argc, &argv, \"-e\");\n    prte_argv_append(&argc, &argv, \"PMI_NO_PREINITIALIZE=1\");\n    prte_argv_append(&argc, &argv, \"-e\");\n    prte_argv_append(&argc, &argv, \"PMI_NO_FORK=1\");\n    prte_argv_append(&argc, &argv, \"-e\");\n    prte_argv_append(&argc, &argv, \"OMPI_NO_USE_CRAY_PMI=1\");\n\n    /* if we are using all allocated nodes, then alps\n     * doesn't need a nodelist, or if running without a batch scheduler\n     */\n    if ((map->num_new_daemons < prte_num_allocated_nodes) || (prte_num_allocated_nodes == 0)) {\n        /* create nodelist */\n        nodelist_argv = NULL;\n        nodelist_argc = 0;\n\n        for (nnode=0; nnode < map->nodes->size; nnode++) {\n            if (NULL == (node = (prte_node_t*)prte_pointer_array_get_item(map->nodes, nnode))) {\n                continue;\n            }\n\n            /* if the daemon already exists on this node, then\n             * don't include it\n             */\n            if (PRTE_FLAG_TEST(node, PRTE_NODE_FLAG_DAEMON_LAUNCHED)) {\n                continue;\n            }\n\n            /* otherwise, add it to the list of nodes upon which\n             * we need to launch a daemon\n             */\n            prte_argv_append(&nodelist_argc, &nodelist_argv, node->name);\n        }\n        if (0 == prte_argv_count(nodelist_argv)) {\n            prte_show_help(\"help-plm-alps.txt\", \"no-hosts-in-list\", true);\n            rc = PRTE_ERR_FAILED_TO_START;\n            goto cleanup;\n        }\n        nodelist_flat = prte_argv_join(nodelist_argv, ',');\n        prte_argv_free(nodelist_argv);\n\n        prte_argv_append(&argc, &argv, \"-L\");\n        prte_argv_append(&argc, &argv, nodelist_flat);\n        free(nodelist_flat);\n    }\n\n\n    /*\n     * PRTED OPTIONS\n     */\n\n    /* add the daemon command (as specified by user) */\n    prte_plm_base_setup_prted_cmd(&argc, &argv);\n\n    /* Add basic orted command line options, including debug flags */\n    prte_plm_base_prted_append_basic_args(&argc, &argv,\n                                           NULL,\n                                           &proc_vpid_index);\n\n    /* tell the new daemons the base of the name list so they can compute\n     * their own name on the other end\n     */\n    rc = prte_util_convert_vpid_to_string(&vpid_string, map->daemon_vpid_start);\n    if (PRTE_SUCCESS != rc) {\n        prte_output(0, \"plm_alps: unable to create process name\");\n        goto cleanup;\n    }\n\n    free(argv[proc_vpid_index]);\n    argv[proc_vpid_index] = strdup(vpid_string);\n    free(vpid_string);\n\n    if (prte_plm_alps_component.debug) {\n        param = prte_argv_join(argv, ' ');\n        if (NULL != param) {\n            prte_output(0, \"plm:alps: final top-level argv:\");\n            prte_output(0, \"plm:alps:     %s\", param);\n            free(param);\n        }\n    }\n\n    /* Copy the prefix-directory specified in the\n       corresponding app_context.  If there are multiple,\n       different prefix's in the app context, complain (i.e., only\n       allow one --prefix option for the entire alps run -- we\n       don't support different --prefix'es for different nodes in\n       the ALPS plm) */\n    cur_prefix = NULL;\n    for (i=0; i < state->jdata->apps->size; i++) {\n        char *app_prefix_dir = NULL;\n        if (NULL == (app = (prte_app_context_t*)prte_pointer_array_get_item(state->jdata->apps, i))) {\n            continue;\n        }\n        prte_get_attribute(&app->attributes, PRTE_APP_PREFIX_DIR, (void**)&app_prefix_dir, PRTE_STRING);\n        /* Check for already set cur_prefix_dir -- if different,\n           complain */\n        if (NULL != app_prefix_dir) {\n            if (NULL != cur_prefix &&\n                0 != strcmp (cur_prefix, app_prefix_dir)) {\n                prte_show_help(\"help-plm-alps.txt\", \"multiple-prefixes\",\n                               true, cur_prefix, app_prefix_dir);\n                goto cleanup;\n            }\n\n            /* If not yet set, copy it; iff set, then it's the\n               same anyway */\n            if (NULL == cur_prefix) {\n                cur_prefix = strdup(app_prefix_dir);\n                if (prte_plm_alps_component.debug) {\n                    prte_output (0, \"plm:alps: Set prefix:%s\",\n                                 cur_prefix);\n                }\n            }\n            free(app_prefix_dir);\n        }\n    }\n\n    /* protect the args in case someone has a script wrapper around aprun */\n    prte_schizo.wrap_args(argv);\n\n    /* setup environment */\n    env = prte_argv_copy(prte_launch_environ);\n\n    if (0 < prte_output_get_verbosity(prte_plm_base_framework.framework_output)) {\n        param = prte_argv_join(argv, ' ');\n        PRTE_OUTPUT_VERBOSE((1, prte_plm_base_framework.framework_output,\n                             \"%s plm:alps: final top-level argv:\\n\\t%s\",\n                             PRTE_NAME_PRINT(PRTE_PROC_MY_NAME),\n                             (NULL == param) ? \"NULL\" : param));\n        if (NULL != param) free(param);\n    }\n\n    /* exec the daemon(s) */\n    if (PRTE_SUCCESS != (rc = plm_alps_start_proc(argc, argv, env, cur_prefix))) {\n        PRTE_ERROR_LOG(rc);\n        goto cleanup;\n    }\n\n    /* indicate that the daemons for this job were launched */\n    state->jdata->state = PRTE_JOB_STATE_DAEMONS_LAUNCHED;\n    daemons->state = PRTE_JOB_STATE_DAEMONS_LAUNCHED;\n\n    /* flag that launch was successful, so far as we currently know */\n    failed_launch = false;\n\n cleanup:\n    if (NULL != argv) {\n        prte_argv_free(argv);\n    }\n    if (NULL != env) {\n        prte_argv_free(env);\n    }\n\n    /* cleanup the caddy */\n    PRTE_RELEASE(state);\n\n    /* check for failed launch - if so, force terminate */\n    if (failed_launch) {\n        PRTE_FORCED_TERMINATE(PRTE_ERROR_DEFAULT_EXIT_CODE);\n    }\n}\n\n\n\n/**\n* Terminate the orteds for a given job\n */\nstatic int plm_alps_terminate_orteds(void)\n{\n    int rc;\n    prte_job_t *jdata;\n\n    PRTE_OUTPUT_VERBOSE((10, prte_plm_base_framework.framework_output,\n                            \"%s plm:alps: terminating orteds\",\n                             PRTE_NAME_PRINT(PRTE_PROC_MY_NAME)));\n\n    /* deregister the waitpid callback to ensure we don't make it look like\n     * alps failed when it didn't. Since the alps may have already completed,\n     * do NOT ERROR_LOG any return code to avoid confusing, duplicate error\n     * messages\n     */\n    if (NULL != alpsrun) {\n        prte_wait_cb_cancel(alpsrun);\n    }\n\n    /* now tell them to die */\n    if (PRTE_SUCCESS != (rc = prte_plm_base_prted_exit(PRTE_DAEMON_EXIT_CMD))) {\n        PRTE_ERROR_LOG(rc);\n    }\n\n    jdata = prte_get_job_data_object(PRTE_PROC_MY_NAME->jobid);\n    PRTE_ACTIVATE_JOB_STATE(jdata, PRTE_JOB_STATE_DAEMONS_TERMINATED);\n\n    PRTE_OUTPUT_VERBOSE((10, prte_plm_base_framework.framework_output,\n                            \"%s plm:alps: terminated orteds\",\n                             PRTE_NAME_PRINT(PRTE_PROC_MY_NAME)));\n    return rc;\n}\n\n\n/**\n * Signal all the processes in the child alps by sending the signal directly to it\n */\nstatic int plm_alps_signal_job(prte_jobid_t jobid, int32_t signal)\n{\n    if (NULL != alpsrun && 0 != alpsrun->pid) {\n        kill(alpsrun->pid, (int)signal);\n   }\n    return PRTE_SUCCESS;\n}\n\n\nstatic int plm_alps_finalize(void)\n{\n    int rc;\n\n    if (NULL != alpsrun) {\n        PRTE_RELEASE(alpsrun);\n    }\n\n    /* cleanup any pending recvs */\n    if (PRTE_SUCCESS != (rc = prte_plm_base_comm_stop())) {\n        PRTE_ERROR_LOG(rc);\n    }\n\n    return PRTE_SUCCESS;\n}\n\n\nstatic void alps_wait_cb(int sd, short args, void *cbdata) {\n    prte_wait_tracker_t *t2 = (prte_wait_tracker_t*)cbdata;\n    prte_proc_t *proc = t2->child;\n    prte_job_t *jdata;\n\n    /* According to the ALPS folks, alps always returns the highest exit\n       code of our remote processes. Thus, a non-zero exit status doesn't\n       necessarily mean that alps failed - it could be that an orted returned\n       a non-zero exit status. Of course, that means the orted failed(!), so\n       the end result is the same - the job didn't start.\n\n       As a result, we really can't do much with the exit status itself - it\n       could be something in errno (if alps itself failed), or it could be\n       something returned by an orted, or it could be something returned by\n       the OS (e.g., couldn't find the orted binary). Somebody is welcome\n       to sort out all the options and pretty-print a better error message. For\n       now, though, the only thing that really matters is that\n       alps failed. Report the error and make sure that prun\n       wakes up - otherwise, do nothing!\n    */\n    jdata = prte_get_job_data_object(PRTE_PROC_MY_NAME->jobid);\n\n    if (0 != proc->exit_code) {\n        if (failed_launch) {\n            /* report that the daemon has failed so we break out of the daemon\n             * callback receive and exit\n             */\n            PRTE_ACTIVATE_JOB_STATE(jdata, PRTE_JOB_STATE_FAILED_TO_START);\n        } else {\n            /* an orted must have died unexpectedly after launch - report\n             * that the daemon has failed so we exit\n             */\n            PRTE_ACTIVATE_JOB_STATE(jdata, PRTE_JOB_STATE_ABORTED);\n        }\n    }\n    PRTE_RELEASE(t2);\n}\n\n\nstatic int plm_alps_start_proc(int argc, char **argv, char **env,\n                                char *prefix)\n{\n    int fd;\n    pid_t alps_pid;\n    char *exec_argv = prte_path_findv(argv[0], 0, env, NULL);\n\n    if (NULL == exec_argv) {\n        return PRTE_ERR_NOT_FOUND;\n    }\n\n    alps_pid = fork();\n    if (-1 == alps_pid) {\n        PRTE_ERROR_LOG(PRTE_ERR_SYS_LIMITS_CHILDREN);\n        return PRTE_ERR_SYS_LIMITS_CHILDREN;\n    }\n\n    alpsrun = PRTE_NEW(prte_proc_t);\n    alpsrun->pid = alps_pid;\n    /* be sure to mark it as alive so we don't instantly fire */\n    PRTE_FLAG_SET(alpsrun, PRTE_PROC_FLAG_ALIVE);\n    /* setup the waitpid so we can find out if alps succeeds! */\n    prte_wait_cb(alpsrun, alps_wait_cb, prte_event_base, NULL);\n\n    if (0 == alps_pid) {  /* child */\n        char *bin_base = NULL, *lib_base = NULL;\n\n        /* Figure out the basenames for the libdir and bindir.  There\n           is a lengthy comment about this in plm_rsh_module.c\n           explaining all the rationale for how / why we're doing\n           this. */\n\n        lib_base = prte_basename(prte_install_dirs.libdir);\n        bin_base = prte_basename(prte_install_dirs.bindir);\n\n        /* If we have a prefix, then modify the PATH and\n           LD_LIBRARY_PATH environment variables.  */\n        if (NULL != prefix) {\n            char *oldenv, *newenv;\n\n            /* Reset PATH */\n            oldenv = getenv(\"PATH\");\n            if (NULL != oldenv) {\n                prte_asprintf(&newenv, \"%s/%s:%s\", prefix, bin_base, oldenv);\n            } else {\n                prte_asprintf(&newenv, \"%s/%s\", prefix, bin_base);\n            }\n            prte_setenv(\"PATH\", newenv, true, &env);\n            if (prte_plm_alps_component.debug) {\n                prte_output(0, \"plm:alps: reset PATH: %s\", newenv);\n            }\n            free(newenv);\n\n            /* Reset LD_LIBRARY_PATH */\n            oldenv = getenv(\"LD_LIBRARY_PATH\");\n            if (NULL != oldenv) {\n                prte_asprintf(&newenv, \"%s/%s:%s\", prefix, lib_base, oldenv);\n            } else {\n                prte_asprintf(&newenv, \"%s/%s\", prefix, lib_base);\n            }\n            prte_setenv(\"LD_LIBRARY_PATH\", newenv, true, &env);\n            if (prte_plm_alps_component.debug) {\n                prte_output(0, \"plm:alps: reset LD_LIBRARY_PATH: %s\",\n                            newenv);\n            }\n            free(newenv);\n        }\n\n        fd = open(\"/dev/null\", O_CREAT|O_WRONLY|O_TRUNC, 0666);\n        if(fd > 0) {\n            dup2(fd, 0);\n        }\n\n        /* When not in debug mode and --debug-daemons was not passed,\n         * tie stdout/stderr to dev null so we don't see messages from orted */\n        if (0 == prte_plm_alps_component.debug && !prte_debug_daemons_flag) {\n            if (fd >= 0) {\n                if (fd != 1) {\n                    dup2(fd,1);\n                }\n                if (fd != 2) {\n                    dup2(fd,2);\n                }\n            }\n        }\n\n        if (fd > 2) {\n            close(fd);\n        }\n\n        /* get the alps process out of prun's process group so that\n           signals sent from the shell (like those resulting from\n           cntl-c) don't get sent to alps */\n        setpgid(0, 0);\n\n\n        execve(exec_argv, argv, env);\n\n        prte_output(0, \"plm:alps:start_proc: exec failed\");\n        /* don't return - need to exit - returning would be bad -\n           we're not in the calling process anymore */\n        exit(1);\n    } else {  /* parent */\n        /* just in case, make sure that the alps process is not in our\n        process group any more.  Stevens says always do this on both\n        sides of the fork... */\n        setpgid(alps_pid, alps_pid);\n\n        free(exec_argv);\n    }\n\n    return PRTE_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-i7toh3zidlll7lxwnp72zprwcwg4ub7m/spack-src/src/mca/base/base.h": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2004-2008 The Trustees of Indiana University and Indiana\n *                         University Research and Technology\n *                         Corporation.  All rights reserved.\n * Copyright (c) 2004-2007 The University of Tennessee and The University\n *                         of Tennessee Research Foundation.  All rights\n *                         reserved.\n * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,\n *                         University of Stuttgart.  All rights reserved.\n * Copyright (c) 2004-2005 The Regents of the University of California.\n *                         All rights reserved.\n * Copyright (c) 2009-2020 Cisco Systems, Inc.  All rights reserved\n * Copyright (c) 2013-2015 Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2015      Research Organization for Information Science\n *                         and Technology (RIST). All rights reserved.\n * Copyright (c) 2017 IBM Corporation.  All rights reserved.\n * Copyright (c) 2018      Triad National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2019-2020 Intel, Inc.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#ifndef PRTE_MCA_BASE_H\n#define PRTE_MCA_BASE_H\n\n#include \"prte_config.h\"\n\n#include \"src/class/prte_object.h\"\n#include \"src/class/prte_list.h\"\n\n/*\n * These units are large enough to warrant their own .h files\n */\n#include \"src/mca/mca.h\"\n#include \"src/mca/base/prte_mca_base_var.h\"\n#include \"src/mca/base/prte_mca_base_framework.h\"\n#include \"src/util/cmd_line.h\"\n#include \"src/util/output.h\"\n\nBEGIN_C_DECLS\n\n/*\n * Structure for making plain lists of components\n */\nstruct prte_mca_base_component_list_item_t {\n    prte_list_item_t super;\n    const prte_mca_base_component_t *cli_component;\n};\ntypedef struct prte_mca_base_component_list_item_t prte_mca_base_component_list_item_t;\nPRTE_EXPORT PRTE_CLASS_DECLARATION(prte_mca_base_component_list_item_t);\n\n/*\n * Structure for making priority lists of components\n */\nstruct prte_mca_base_component_priority_list_item_t {\n    prte_mca_base_component_list_item_t super;\n    int cpli_priority;\n};\ntypedef struct prte_mca_base_component_priority_list_item_t\n    prte_mca_base_component_priority_list_item_t;\n\nPRTE_EXPORT PRTE_CLASS_DECLARATION(prte_mca_base_component_priority_list_item_t);\n\n/*\n * Public variables\n */\nPRTE_EXPORT extern char *prte_mca_base_component_path;\nPRTE_EXPORT extern bool prte_mca_base_component_show_load_errors;\nPRTE_EXPORT extern bool prte_mca_base_component_track_load_errors;\nPRTE_EXPORT extern bool prte_mca_base_component_disable_dlopen;\nPRTE_EXPORT extern char *prte_mca_base_system_default_path;\nPRTE_EXPORT extern char *prte_mca_base_user_default_path;\n\n/*\n * Standard verbosity levels\n */\nenum {\n    /** total silence */\n    PRTE_MCA_BASE_VERBOSE_NONE  = -1,\n    /** only errors are printed */\n    PRTE_MCA_BASE_VERBOSE_ERROR = 0,\n    /** emit messages about component selection, open, and unloading */\n    PRTE_MCA_BASE_VERBOSE_COMPONENT = 10,\n    /** also emit warnings */\n    PRTE_MCA_BASE_VERBOSE_WARN  = 20,\n    /** also emit general, user-relevant information, such as rationale as to why certain choices\n     * or code paths were taken, information gleaned from probing the local system, etc. */\n    PRTE_MCA_BASE_VERBOSE_INFO  = 40,\n    /** also emit relevant tracing information (e.g., which functions were invoked /\n     * call stack entry/exit info) */\n    PRTE_MCA_BASE_VERBOSE_TRACE = 60,\n    /** also emit PRTE-developer-level (i.e,. highly detailed) information */\n    PRTE_MCA_BASE_VERBOSE_DEBUG = 80,\n    /** also output anything else that might be useful */\n    PRTE_MCA_BASE_VERBOSE_MAX   = 100,\n};\n\n/*\n * Public functions\n */\n\n/**\n * First function called in the MCA.\n *\n * @return PRTE_SUCCESS Upon success\n * @return PRTE_ERROR Upon failure\n *\n * This function starts up the entire MCA.  It initializes a bunch\n * of built-in MCA parameters, and initialized the MCA component\n * repository.\n *\n * It must be the first MCA function invoked.  It is normally\n * invoked during the initialization stage and specifically\n * invoked in the special case of the *_info command.\n */\nPRTE_EXPORT int prte_mca_base_open(void);\n\n/**\n * Last function called in the MCA\n *\n * @return PRTE_SUCCESS Upon success\n * @return PRTE_ERROR Upon failure\n *\n * This function closes down the entire MCA.  It clears all MCA\n * parameters and closes down the MCA component respository.\n *\n * It must be the last MCA function invoked.  It is normally invoked\n * during the finalize stage.\n */\nPRTE_EXPORT void prte_mca_base_close(void);\n\n/**\n * A generic select function\n *\n */\nPRTE_EXPORT int prte_mca_base_select(const char *type_name, int output_id,\n                                  prte_list_t *components_available,\n                                  prte_mca_base_module_t **best_module,\n                                  prte_mca_base_component_t **best_component,\n                                  int *priority_out);\n\n/**\n * A function for component query functions to discover if they have\n * been explicitly required to or requested to be selected.\n *\n * exclusive: If the specified component is the only component that is\n *            available for selection.\n *\n */\nPRTE_EXPORT int prte_mca_base_is_component_required(prte_list_t *components_available,\n                                                 prte_mca_base_component_t *component,\n                                                 bool exclusive,\n                                                 bool *is_required);\n\n/* prte_mca_base_component_compare.c */\n\nPRTE_EXPORT int prte_mca_base_component_compare_priority(prte_mca_base_component_priority_list_item_t *a,\n                                                      prte_mca_base_component_priority_list_item_t *b);\nPRTE_EXPORT int prte_mca_base_component_compare(const prte_mca_base_component_t *a,\n                                             const prte_mca_base_component_t *b);\nPRTE_EXPORT int prte_mca_base_component_compatible(const prte_mca_base_component_t *a,\n                                                const prte_mca_base_component_t *b);\nPRTE_EXPORT char * prte_mca_base_component_to_string(const prte_mca_base_component_t *a);\n\n/* prte_mca_base_component_find.c */\n\nPRTE_EXPORT int prte_mca_base_component_find (const char *directory, prte_mca_base_framework_t *framework,\n                                           bool ignore_requested, bool open_dso_components);\n\n/**\n * Parse the requested component string and return an prte_argv of the requested\n * (or not requested) components.\n */\nint prte_mca_base_component_parse_requested (const char *requested, bool *include_mode,\n                                        char ***requested_component_names);\n\n/**\n * Filter a list of components based on a comma-delimted list of names and/or\n * a set of meta-data flags.\n *\n * @param[in,out] components List of components to filter\n * @param[in] output_id Output id to write to for error/warning/debug messages\n * @param[in] filter_names Comma delimited list of components to use. Negate with ^.\n * May be NULL.\n * @param[in] filter_flags Metadata flags components are required to have set (CR ready)\n *\n * @returns PRTE_SUCCESS On success\n * @returns PRTE_ERR_NOT_FOUND If some component in {filter_names} is not found in\n * {components}. Does not apply to negated filters.\n * @returns prte error code On other error.\n *\n * This function closes and releases any components that do not match the filter_name and\n * filter flags.\n */\nPRTE_EXPORT int prte_mca_base_components_filter (prte_mca_base_framework_t *framework, uint32_t filter_flags);\n\n\n\n/* Safely release some memory allocated by prte_mca_base_component_find()\n   (i.e., is safe to call even if you never called\n   prte_mca_base_component_find()). */\nPRTE_EXPORT int prte_mca_base_component_find_finalize(void);\n\n/* prte_mca_base_components_register.c */\nPRTE_EXPORT int prte_mca_base_framework_components_register (struct prte_mca_base_framework_t *framework,\n                                                          prte_mca_base_register_flag_t flags);\n\n/* prte_mca_base_components_open.c */\nPRTE_EXPORT int prte_mca_base_framework_components_open (struct prte_mca_base_framework_t *framework,\n                                                      prte_mca_base_open_flag_t flags);\n\nPRTE_EXPORT int prte_mca_base_components_open(const char *type_name, int output_id,\n                                           const prte_mca_base_component_t **static_components,\n                                           prte_list_t *components_available,\n                                           bool open_dso_components);\n\n/* prte_mca_base_components_close.c */\n/**\n * Close and release a component.\n *\n * @param[in] component Component to close\n * @param[in] output_id Output id for debugging output\n *\n * After calling this function the component may no longer be used.\n */\nPRTE_EXPORT void prte_mca_base_component_close (const prte_mca_base_component_t *component, int output_id);\n\n/**\n * Release a component without closing it.\n * @param[in] component Component to close\n * @param[in] output_id Output id for debugging output\n *\n * After calling this function the component may no longer be used.\n */\nvoid prte_mca_base_component_unload (const prte_mca_base_component_t *component, int output_id);\n\nPRTE_EXPORT int prte_mca_base_components_close(int output_id, prte_list_t *components_available,\n                                            const prte_mca_base_component_t *skip);\n\nPRTE_EXPORT int prte_mca_base_framework_components_close (struct prte_mca_base_framework_t *framework,\n\t\t\t\t\t\t       const prte_mca_base_component_t *skip);\n\nEND_C_DECLS\n\n#endif /* MCA_BASE_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-i7toh3zidlll7lxwnp72zprwcwg4ub7m/spack-src/src/mca/base/prte_mca_base_component_repository.c": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana\n *                         University Research and Technology\n *                         Corporation.  All rights reserved.\n * Copyright (c) 2004-2005 The University of Tennessee and The University\n *                         of Tennessee Research Foundation.  All rights\n *                         reserved.\n * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,\n *                         University of Stuttgart.  All rights reserved.\n * Copyright (c) 2004-2005 The Regents of the University of California.\n *                         All rights reserved.\n * Copyright (c) 2008-2020 Cisco Systems, Inc.  All rights reserved\n * Copyright (c) 2015      Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2015-2019 Research Organization for Information Science\n *                         and Technology (RIST).  All rights reserved.\n * Copyright (c) 2017      IBM Corporation.  All rights reserved.\n * Copyright (c) 2018      Amazon.com, Inc. or its affiliates.  All Rights reserved.\n * Copyright (c) 2019-2020 Intel, Inc.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n\n#include \"prte_config.h\"\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include \"src/class/prte_list.h\"\n#include \"src/mca/mca.h\"\n#include \"src/mca/base/base.h\"\n#include \"src/mca/base/prte_mca_base_component_repository.h\"\n#include \"src/mca/prtedl/base/base.h\"\n#include \"constants.h\"\n#include \"src/class/prte_hash_table.h\"\n#include \"src/util/basename.h\"\n#include \"src/util/string_copy.h\"\n#include \"src/util/printf.h\"\n\n#if PRTE_HAVE_DL_SUPPORT\n\n/*\n * Private types\n */\nstatic void ri_constructor(prte_mca_base_component_repository_item_t *ri);\nstatic void ri_destructor(prte_mca_base_component_repository_item_t *ri);\nPRTE_CLASS_INSTANCE(prte_mca_base_component_repository_item_t, prte_list_item_t,\n                   ri_constructor, ri_destructor);\n\n#endif /* PRTE_HAVE_DL_SUPPORT */\n\nstatic void clf_constructor(prte_object_t *obj);\nstatic void clf_destructor(prte_object_t *obj);\n\nPRTE_CLASS_INSTANCE(prte_mca_base_failed_component_t, prte_list_item_t,\n                   clf_constructor, clf_destructor);\n\n\nstatic void clf_constructor(prte_object_t *obj)\n{\n    prte_mca_base_failed_component_t *cli = (prte_mca_base_failed_component_t *) obj;\n    cli->comp = NULL;\n    cli->error_msg = NULL;\n}\n\nstatic void clf_destructor(prte_object_t *obj)\n{\n    prte_mca_base_failed_component_t *cli = (prte_mca_base_failed_component_t *) obj;\n    cli->comp = NULL;\n    if( NULL != cli->error_msg ) {\n        free(cli->error_msg);\n        cli->error_msg = NULL;\n    }\n}\n\n/*\n * Private variables\n */\nstatic bool initialized = false;\n\n\n#if PRTE_HAVE_DL_SUPPORT\n\nstatic prte_hash_table_t prte_mca_base_component_repository;\n\n/* two-level macro for stringifying a number */\n#define STRINGIFYX(x) #x\n#define STRINGIFY(x) STRINGIFYX(x)\n\nstatic int process_repository_item (const char *filename, void *data)\n{\n    char name[PRTE_MCA_BASE_MAX_COMPONENT_NAME_LEN + 1];\n    char type[PRTE_MCA_BASE_MAX_TYPE_NAME_LEN + 1];\n    prte_mca_base_component_repository_item_t *ri;\n    prte_list_t *component_list;\n    char *base;\n    int ret;\n\n    base = prte_basename (filename);\n    if (NULL == base) {\n        return PRTE_ERROR;\n    }\n\n    /* check if the plugin has the appropriate prefix */\n    if (0 != strncmp (base, \"mca_\", 4)) {\n        free (base);\n        return PRTE_SUCCESS;\n    }\n\n    /* read framework and component names. framework names may not include an _\n     * but component names may */\n    ret = sscanf (base, \"mca_%\" STRINGIFY(PRTE_MCA_BASE_MAX_TYPE_NAME_LEN) \"[^_]_%\"\n                  STRINGIFY(PRTE_MCA_BASE_MAX_COMPONENT_NAME_LEN) \"s\", type, name);\n    if (0 > ret) {\n        /* does not patch the expected template. skip */\n        free(base);\n        return PRTE_SUCCESS;\n    }\n\n    /* lookup the associated framework list and create if it doesn't already exist */\n    ret = prte_hash_table_get_value_ptr (&prte_mca_base_component_repository, type,\n                                         strlen (type), (void **) &component_list);\n    if (PRTE_SUCCESS != ret) {\n        component_list = PRTE_NEW(prte_list_t);\n        if (NULL == component_list) {\n            free (base);\n            /* OOM. nothing to do but fail */\n            return PRTE_ERR_OUT_OF_RESOURCE;\n        }\n\n        ret = prte_hash_table_set_value_ptr (&prte_mca_base_component_repository, type,\n                                             strlen (type), (void *) component_list);\n        if (PRTE_SUCCESS != ret) {\n            free (base);\n            PRTE_RELEASE(component_list);\n            return ret;\n        }\n    }\n\n    /* check for duplicate components */\n    PRTE_LIST_FOREACH(ri, component_list, prte_mca_base_component_repository_item_t) {\n        if (0 == strcmp (ri->ri_name, name)) {\n            /* already scanned this component */\n            free (base);\n            return PRTE_SUCCESS;\n        }\n    }\n\n    ri = PRTE_NEW(prte_mca_base_component_repository_item_t);\n    if (NULL == ri) {\n        free (base);\n        return PRTE_ERR_OUT_OF_RESOURCE;\n    }\n\n    ri->ri_base = base;\n\n    ri->ri_path = strdup (filename);\n    if (NULL == ri->ri_path) {\n        PRTE_RELEASE(ri);\n        return PRTE_ERR_OUT_OF_RESOURCE;\n    }\n\n    prte_string_copy (ri->ri_type, type, PRTE_MCA_BASE_MAX_TYPE_NAME_LEN);\n    prte_string_copy (ri->ri_name, name, PRTE_MCA_BASE_MAX_COMPONENT_NAME_LEN);\n\n    prte_list_append (component_list, &ri->super);\n\n    return PRTE_SUCCESS;\n}\n\nstatic int file_exists(const char *filename, const char *ext)\n{\n    char *final;\n    int ret;\n\n    if (NULL == ext) {\n        return access (filename, F_OK) == 0;\n    }\n\n    ret = prte_asprintf(&final, \"%s.%s\", filename, ext);\n    if (0 > ret || NULL == final) {\n        return 0;\n    }\n\n    ret = access (final, F_OK);\n    free(final);\n    return (0 == ret);\n}\n\n#endif /* PRTE_HAVE_DL_SUPPORT */\n\nint prte_mca_base_component_repository_add (const char *path)\n{\n#if PRTE_HAVE_DL_SUPPORT\n    char *path_to_use = NULL, *dir, *ctx;\n    const char sep[] = {PRTE_ENV_SEP, '\\0'};\n\n    if (NULL == path) {\n        /* nothing to do */\n        return PRTE_SUCCESS;\n    }\n\n    path_to_use = strdup (path);\n\n    dir = strtok_r (path_to_use, sep, &ctx);\n    do {\n        if (0 == strcmp(dir, \"USER_DEFAULT\") || 0 == strcmp(dir, \"USR_DEFAULT\")) {\n            if (NULL == prte_mca_base_user_default_path) {\n                continue;\n            }\n            dir = prte_mca_base_user_default_path;\n        } else if (0 == strcmp(dir, \"SYS_DEFAULT\") ||\n                   0 == strcmp(dir, \"SYSTEM_DEFAULT\")) {\n            if (NULL == prte_mca_base_system_default_path) {\n                continue;\n            }\n            dir = prte_mca_base_system_default_path;\n        }\n\n        if (0 != prte_dl_foreachfile(dir, process_repository_item, NULL)) {\n            break;\n        }\n    } while (NULL != (dir = strtok_r (NULL, sep, &ctx)));\n\n    free (path_to_use);\n\n#endif /* PRTE_HAVE_DL_SUPPORT */\n\n    return PRTE_SUCCESS;\n}\n\n\n/*\n * Initialize the repository\n */\nint prte_mca_base_component_repository_init(void)\n{\n  /* Setup internal structures */\n\n  if (!initialized) {\n#if PRTE_HAVE_DL_SUPPORT\n\n    /* Initialize the dl framework */\n    int ret = prte_mca_base_framework_open(&prte_prtedl_base_framework, PRTE_MCA_BASE_OPEN_DEFAULT);\n    if (PRTE_SUCCESS != ret) {\n        prte_output(0, \"%s %d:%s failed -- process will likely abort (open the dl framework returned %d instead of PRTE_SUCCESS)\\n\",\n                    __FILE__, __LINE__, __func__, ret);\n        return ret;\n    }\n    prte_dl_base_select();\n\n    PRTE_CONSTRUCT(&prte_mca_base_component_repository, prte_hash_table_t);\n    ret = prte_hash_table_init (&prte_mca_base_component_repository, 128);\n    if (PRTE_SUCCESS != ret) {\n        (void) prte_mca_base_framework_close (&prte_prtedl_base_framework);\n        return ret;\n    }\n\n    ret = prte_mca_base_component_repository_add (prte_mca_base_component_path);\n    if (PRTE_SUCCESS != ret) {\n        prte_output(0, \"ERROR ON REPO ADD\");\n        PRTE_DESTRUCT(&prte_mca_base_component_repository);\n        (void) prte_mca_base_framework_close (&prte_prtedl_base_framework);\n        return ret;\n    }\n#endif\n\n    initialized = true;\n  }\n\n  /* All done */\n\n  return PRTE_SUCCESS;\n}\n\nint prte_mca_base_component_repository_get_components (prte_mca_base_framework_t *framework,\n                                                        prte_list_t **framework_components)\n{\n    *framework_components = NULL;\n#if PRTE_HAVE_DL_SUPPORT\n    return prte_hash_table_get_value_ptr (&prte_mca_base_component_repository, framework->framework_name,\n                                          strlen (framework->framework_name), (void **) framework_components);\n#else\n    return PRTE_ERR_NOT_FOUND;\n#endif\n}\n\n#if PRTE_HAVE_DL_SUPPORT\nstatic void prte_mca_base_component_repository_release_internal (prte_mca_base_component_repository_item_t *ri) {\n    int group_id;\n\n    group_id = prte_mca_base_var_group_find (NULL, ri->ri_type, ri->ri_name);\n    if (0 <= group_id) {\n        /* ensure all variables are deregistered before we dlclose the component */\n        prte_mca_base_var_group_deregister (group_id);\n    }\n\n    /* Close the component (and potentially unload it from memory */\n    if (ri->ri_dlhandle) {\n        prte_dl_close(ri->ri_dlhandle);\n        ri->ri_dlhandle = NULL;\n    }\n}\n#endif\n\n#if PRTE_HAVE_DL_SUPPORT\nstatic prte_mca_base_component_repository_item_t *find_component (const char *type, const char *name)\n{\n    prte_mca_base_component_repository_item_t *ri;\n    prte_list_t *component_list;\n    int ret;\n\n    ret = prte_hash_table_get_value_ptr (&prte_mca_base_component_repository, type,\n                                         strlen (type), (void **) &component_list);\n    if (PRTE_SUCCESS != ret) {\n        /* component does not exist in the repository */\n        return NULL;\n    }\n\n    PRTE_LIST_FOREACH(ri, component_list, prte_mca_base_component_repository_item_t) {\n        if (0 == strcmp (ri->ri_name, name)) {\n            return ri;\n        }\n    }\n\n    return NULL;\n}\n#endif\n\nvoid prte_mca_base_component_repository_release(const prte_mca_base_component_t *component)\n{\n#if PRTE_HAVE_DL_SUPPORT\n    prte_mca_base_component_repository_item_t *ri;\n\n    ri = find_component (component->mca_type_name, component->mca_component_name);\n    if (NULL != ri && !(--ri->ri_refcnt)) {\n        prte_mca_base_component_repository_release_internal (ri);\n    }\n#endif\n}\n\nint prte_mca_base_component_repository_retain_component (const char *type, const char *name)\n{\n#if PRTE_HAVE_DL_SUPPORT\n    prte_mca_base_component_repository_item_t *ri = find_component(type, name);\n\n    if (NULL != ri) {\n        ++ri->ri_refcnt;\n        return PRTE_SUCCESS;\n    }\n\n    return PRTE_ERR_NOT_FOUND;\n#else\n    return PRTE_ERR_NOT_SUPPORTED;\n#endif\n}\n\nint prte_mca_base_component_repository_open (prte_mca_base_framework_t *framework,\n                                              prte_mca_base_component_repository_item_t *ri)\n{\n#if PRTE_HAVE_DL_SUPPORT\n    prte_mca_base_component_t *component_struct;\n    prte_mca_base_component_list_item_t *mitem = NULL;\n    char *struct_name = NULL;\n    int vl, ret;\n\n    prte_output_verbose(PRTE_MCA_BASE_VERBOSE_INFO, 0, \"mca_base_component_repository_open: examining dynamic \"\n                        \"%s MCA component \\\"%s\\\" at path %s\", ri->ri_type, ri->ri_name, ri->ri_path);\n\n    vl = prte_mca_base_component_show_load_errors ? PRTE_MCA_BASE_VERBOSE_ERROR : PRTE_MCA_BASE_VERBOSE_INFO;\n\n    /* Ensure that this component is not already loaded (should only happen\n       if it was statically loaded).  It's an error if it's already\n       loaded because we're evaluating this file -- not this component.\n       Hence, returning PRTE_ERR_PARAM indicates that the *file* failed\n       to load, not the component. */\n\n    PRTE_LIST_FOREACH(mitem, &framework->framework_components, prte_mca_base_component_list_item_t) {\n        if (0 == strcmp(mitem->cli_component->mca_component_name, ri->ri_name)) {\n            prte_output_verbose (PRTE_MCA_BASE_VERBOSE_INFO, 0, \"mca_base_component_repository_open: already loaded (ignored)\");\n            return PRTE_ERR_BAD_PARAM;\n        }\n    }\n\n    /* silence coverity issue (invalid free) */\n    mitem = NULL;\n\n    if (NULL != ri->ri_dlhandle) {\n        prte_output_verbose (PRTE_MCA_BASE_VERBOSE_INFO, 0, \"mca_base_component_repository_open: already loaded. returning cached component\");\n        mitem = PRTE_NEW(prte_mca_base_component_list_item_t);\n        if (NULL == mitem) {\n            return PRTE_ERR_OUT_OF_RESOURCE;\n        }\n\n        mitem->cli_component = ri->ri_component_struct;\n        prte_list_append (&framework->framework_components, &mitem->super);\n\n        return PRTE_SUCCESS;\n    }\n\n    if (0 != strcmp (ri->ri_type, framework->framework_name)) {\n        /* shouldn't happen. attempting to open a component belonging to\n         * another framework. if this happens it is likely a MCA base\n         * bug so assert */\n        assert (0);\n        return PRTE_ERR_NOT_SUPPORTED;\n    }\n\n    /* Now try to load the component */\n\n    char *err_msg = NULL;\n    if (PRTE_SUCCESS != prte_dl_open(ri->ri_path, true, false, &ri->ri_dlhandle, &err_msg)) {\n        if (NULL == err_msg) {\n            err_msg = strdup(\"prte_dl_open() error message was NULL!\");\n        } else if (file_exists(ri->ri_path, \"lo\") ||\n                   file_exists(ri->ri_path, \"so\") ||\n                   file_exists(ri->ri_path, \"dylib\") ||\n                   file_exists(ri->ri_path, \"dll\")) {\n            /* Because libltdl erroneously says \"file not found\" for any\n             * type of error -- which is especially misleading when the file\n             * is actually there but cannot be opened for some other reason\n             * (e.g., missing symbol) -- do some simple huersitics and if\n             * the file [probably] does exist, print a slightly better error\n             * message. */\n            err_msg = strdup(\"perhaps a missing symbol, or compiled for a different version of PRRTE?\");\n        }\n        prte_output_verbose(vl, 0, \"prte_mca_base_component_repository_open: unable to open %s: %s (ignored)\",\n                            ri->ri_base, err_msg);\n\n        if( prte_mca_base_component_track_load_errors ) {\n            prte_mca_base_failed_component_t *f_comp = PRTE_NEW(prte_mca_base_failed_component_t);\n            f_comp->comp = ri;\n            if (0 > asprintf(&(f_comp->error_msg), \"%s\", err_msg)) {\n                PRTE_RELEASE(f_comp);\n                free(err_msg);\n                return PRTE_ERR_BAD_PARAM;\n            }\n            prte_list_append(&framework->framework_failed_components, &f_comp->super);\n        }\n\n        free(err_msg);\n        return PRTE_ERR_BAD_PARAM;\n    }\n\n    /* Successfully opened the component; now find the public struct.\n       Malloc out enough space for it. */\n\n    do {\n        ret = prte_asprintf (&struct_name, \"prte_%s_%s_component\", ri->ri_type, ri->ri_name);\n        if (0 > ret) {\n            ret = PRTE_ERR_OUT_OF_RESOURCE;\n            break;\n        }\n\n        mitem = PRTE_NEW(prte_mca_base_component_list_item_t);\n        if (NULL == mitem) {\n            ret = PRTE_ERR_OUT_OF_RESOURCE;\n            break;\n        }\n\n        err_msg = NULL;\n        ret = prte_dl_lookup(ri->ri_dlhandle, struct_name, (void**) &component_struct, &err_msg);\n        if (PRTE_SUCCESS != ret || NULL == component_struct) {\n            if (NULL == err_msg) {\n                err_msg = \"prte_dl_loookup() error message was NULL!\";\n            }\n            prte_output_verbose(vl, 0, \"mca_base_component_repository_open: \\\"%s\\\" does not appear to be a valid \"\n                                \"%s MCA dynamic component (ignored): %s. ret %d\", ri->ri_base, ri->ri_type, err_msg, ret);\n\n            ret = PRTE_ERR_BAD_PARAM;\n            break;\n        }\n\n        /* done with the structure name */\n        free (struct_name);\n        struct_name = NULL;\n\n        /* We found the public struct.  Make sure its MCA major.minor\n           version is the same as ours. TODO -- add checks for project version (from framework) */\n        if (!(PRTE_MCA_BASE_VERSION_MAJOR == component_struct->mca_major_version &&\n              PRTE_MCA_BASE_VERSION_MINOR == component_struct->mca_minor_version)) {\n            prte_output_verbose(vl, 0, \"mca_base_component_repository_open: %s \\\"%s\\\" uses an MCA interface that is \"\n                                \"not recognized (component MCA v%d.%d.%d != supported MCA v%d.%d.%d) -- ignored\",\n                                ri->ri_type, ri->ri_path, component_struct->mca_major_version,\n                                component_struct->mca_minor_version, component_struct->mca_release_version,\n                                PRTE_MCA_BASE_VERSION_MAJOR, PRTE_MCA_BASE_VERSION_MINOR, PRTE_MCA_BASE_VERSION_RELEASE);\n            ret = PRTE_ERR_BAD_PARAM;\n            break;\n        }\n\n        /* Also check that the component struct framework and component\n           names match the expected names from the filename */\n        if (0 != strcmp(component_struct->mca_type_name, ri->ri_type) ||\n            0 != strcmp(component_struct->mca_component_name, ri->ri_name)) {\n            prte_output_verbose(vl, 0, \"Component file data does not match filename: %s (%s / %s) != %s %s -- ignored\",\n                                ri->ri_path, ri->ri_type, ri->ri_name,\n                                component_struct->mca_type_name,\n                                component_struct->mca_component_name);\n            ret = PRTE_ERR_BAD_PARAM;\n            break;\n        }\n\n        /* Alles gut.  Save the component struct, and register this\n           component to be closed later. */\n\n        ri->ri_component_struct = mitem->cli_component = component_struct;\n        ri->ri_refcnt = 1;\n        prte_list_append(&framework->framework_components, &mitem->super);\n\n        prte_output_verbose (PRTE_MCA_BASE_VERBOSE_INFO, 0, \"mca_base_component_repository_open: opened dynamic %s MCA \"\n                             \"component \\\"%s\\\"\", ri->ri_type, ri->ri_name);\n\n        return PRTE_SUCCESS;\n    } while (0);\n\n    if (mitem) {\n        PRTE_RELEASE(mitem);\n    }\n\n    if (struct_name) {\n        free (struct_name);\n    }\n\n    prte_dl_close (ri->ri_dlhandle);\n    ri->ri_dlhandle = NULL;\n\n    return ret;\n#else\n\n    /* no dlopen support */\n    return PRTE_ERR_NOT_SUPPORTED;\n#endif\n}\n\n/*\n * Finalize the repository -- close everything that's still open.\n */\nvoid prte_mca_base_component_repository_finalize(void)\n{\n    if (!initialized) {\n        return;\n    }\n\n    initialized = false;\n\n#if PRTE_HAVE_DL_SUPPORT\n    prte_list_t *component_list;\n    void *node, *key;\n    size_t key_size;\n    int ret;\n\n    ret = prte_hash_table_get_first_key_ptr (&prte_mca_base_component_repository, &key, &key_size,\n                                             (void **) &component_list, &node);\n    while (PRTE_SUCCESS == ret) {\n        PRTE_LIST_RELEASE(component_list);\n        ret = prte_hash_table_get_next_key_ptr (&prte_mca_base_component_repository, &key,\n                                                &key_size, (void **) &component_list,\n                                                node, &node);\n    }\n\n    (void) prte_mca_base_framework_close(&prte_prtedl_base_framework);\n    PRTE_DESTRUCT(&prte_mca_base_component_repository);\n#endif\n}\n\n#if PRTE_HAVE_DL_SUPPORT\n\n/*\n * Basic sentinel values, and construct the inner list\n */\nstatic void ri_constructor (prte_mca_base_component_repository_item_t *ri)\n{\n    memset(ri->ri_type, 0, sizeof(ri->ri_type));\n    ri->ri_dlhandle = NULL;\n    ri->ri_component_struct = NULL;\n    ri->ri_path = NULL;\n}\n\n\n/*\n * Close a component\n */\nstatic void ri_destructor (prte_mca_base_component_repository_item_t *ri)\n{\n    /* dlclose the component if it is still open */\n    prte_mca_base_component_repository_release_internal (ri);\n\n    /* It should be obvious, but I'll state it anyway because it bit me\n       during debugging: after the dlclose(), the prte_mca_base_component_t\n       pointer is no longer valid because it has [potentially] been\n       unloaded from memory.  So don't try to use it.  :-) */\n\n    if (ri->ri_path) {\n        free (ri->ri_path);\n    }\n\n    if (ri->ri_base) {\n        free (ri->ri_base);\n    }\n}\n\n#endif /* PRTE_HAVE_DL_SUPPORT */\n",
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-i7toh3zidlll7lxwnp72zprwcwg4ub7m/spack-src/src/mca/base/prte_mca_base_open.c": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana\n *                         University Research and Technology\n *                         Corporation.  All rights reserved.\n * Copyright (c) 2004-2017 The University of Tennessee and The University\n *                         of Tennessee Research Foundation.  All rights\n *                         reserved.\n * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,\n *                         University of Stuttgart.  All rights reserved.\n * Copyright (c) 2004-2005 The Regents of the University of California.\n *                         All rights reserved.\n * Copyright (c) 2011-2020 Cisco Systems, Inc.  All rights reserved\n * Copyright (c) 2015      Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2017      IBM Corporation.  All rights reserved.\n * Copyright (c) 2018      Amazon.com, Inc. or its affiliates.  All Rights reserved.\n * Copyright (c) 2018      Triad National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2019-2020 Intel, Inc.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"prte_config.h\"\n\n#include <stdio.h>\n#include <string.h>\n#ifdef HAVE_SYSLOG_H\n#include <syslog.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include \"src/runtime/runtime.h\"\n#include \"src/mca/prteinstalldirs/prteinstalldirs.h\"\n#include \"src/util/output.h\"\n#include \"src/util/printf.h\"\n#include \"src/util/proc_info.h\"\n#include \"src/mca/mca.h\"\n#include \"src/mca/base/base.h\"\n#include \"src/mca/base/prte_mca_base_component_repository.h\"\n#include \"src/mca/base/prte_mca_base_var.h\"\n#include \"constants.h\"\n#include \"src/util/prte_environ.h\"\n\n/*\n * Public variables\n */\nchar *prte_mca_base_component_path = NULL;\nint prte_mca_base_opened = 0;\nchar *prte_mca_base_system_default_path = NULL;\nchar *prte_mca_base_user_default_path = NULL;\nbool prte_mca_base_component_show_load_errors =\n    (bool) PRTE_SHOW_LOAD_ERRORS_DEFAULT;\nbool prte_mca_base_component_track_load_errors = false;\nbool prte_mca_base_component_disable_dlopen = false;\n\nstatic char *prte_mca_base_verbose = NULL;\n\n/*\n * Private functions\n */\nstatic void set_defaults(prte_output_stream_t *lds);\nstatic void parse_verbose(char *e, prte_output_stream_t *lds);\n\n\n/*\n * Main MCA initialization.\n */\nint prte_mca_base_open(void)\n{\n    char *value;\n    prte_output_stream_t lds;\n\n    if (prte_mca_base_opened++) {\n        return PRTE_SUCCESS;\n    }\n\n    if (PRTE_PROC_IS_MASTER) {\n        /* define the system and user default paths */\n    #if PRTE_WANT_HOME_CONFIG_FILES\n        prte_mca_base_system_default_path = strdup(prte_install_dirs.prtelibdir);\n        value = (char*)prte_home_directory();\n        if (NULL == value) {\n             prte_output(0, \"Error: Unable to get the user home directory\\n\");\n            return PRTE_ERROR;\n        }\n        prte_asprintf(&prte_mca_base_user_default_path, \"%s\"PRTE_PATH_SEP\".prte\"PRTE_PATH_SEP\"components\", value);\n    #else\n        prte_asprintf(&prte_mca_base_system_default_path, \"%s\", prte_install_dirs.prtelibdir);\n    #endif\n\n        /* see if the user wants to override the defaults */\n        if (NULL == prte_mca_base_user_default_path) {\n            value = strdup(prte_mca_base_system_default_path);\n        } else {\n            prte_asprintf(&value, \"%s%c%s\", prte_mca_base_system_default_path,\n                     PRTE_ENV_SEP, prte_mca_base_user_default_path);\n        }\n    } else {\n        prte_asprintf(&prte_mca_base_system_default_path, \"%s\", prte_install_dirs.prtelibdir);\n        value = strdup(prte_mca_base_system_default_path);\n    }\n\n    prte_mca_base_component_path = value;\n    prte_mca_base_var_register(\"prte\", \"mca\", \"base\", \"component_path\",\n                                \"Path where to look for additional components\",\n                                PRTE_MCA_BASE_VAR_TYPE_STRING, NULL, 0,\n                                PRTE_MCA_BASE_VAR_FLAG_NONE,\n                                PRTE_INFO_LVL_9,\n                                PRTE_MCA_BASE_VAR_SCOPE_READONLY,\n                                &prte_mca_base_component_path);\n    free(value);\n\n    prte_mca_base_component_show_load_errors =\n        (bool) PRTE_SHOW_LOAD_ERRORS_DEFAULT;\n    prte_mca_base_var_register(\"prte\", \"mca\", \"base\", \"component_show_load_errors\",\n                                \"Whether to show errors for components that failed to load or not\",\n                                PRTE_MCA_BASE_VAR_TYPE_BOOL, NULL, 0,\n                                PRTE_MCA_BASE_VAR_FLAG_NONE,\n                                PRTE_INFO_LVL_9,\n                                PRTE_MCA_BASE_VAR_SCOPE_READONLY,\n                                &prte_mca_base_component_show_load_errors);\n\n    prte_mca_base_component_track_load_errors = false;\n    prte_mca_base_var_register(\"prte\", \"mca\", \"base\", \"component_track_load_errors\",\n                                \"Whether to track errors for components that failed to load or not\",\n                                PRTE_MCA_BASE_VAR_TYPE_BOOL, NULL, 0,\n                                PRTE_MCA_BASE_VAR_FLAG_NONE,\n                                PRTE_INFO_LVL_9,\n                                PRTE_MCA_BASE_VAR_SCOPE_READONLY,\n                                &prte_mca_base_component_track_load_errors);\n\n    prte_mca_base_component_disable_dlopen = false;\n    prte_mca_base_var_register(\"prte\", \"mca\", \"base\", \"component_disable_dlopen\",\n                                \"Whether to attempt to disable opening dynamic components or not\",\n                                PRTE_MCA_BASE_VAR_TYPE_BOOL, NULL, 0,\n                                PRTE_MCA_BASE_VAR_FLAG_NONE,\n                                PRTE_INFO_LVL_9,\n                                PRTE_MCA_BASE_VAR_SCOPE_READONLY,\n                                &prte_mca_base_component_disable_dlopen);\n\n    /* What verbosity level do we want for the default 0 stream? */\n    char *str = getenv(\"PRTE_OUTPUT_INTERNAL_TO_STDOUT\");\n    if (NULL != str && str[0] == '1') {\n        prte_mca_base_verbose = \"stdout\";\n    }\n    else {\n        prte_mca_base_verbose = \"stderr\";\n    }\n    prte_mca_base_var_register(\"prte\", \"mca\", \"base\", \"verbose\",\n                                \"Specifies where the default error output stream goes (this is separate from distinct help messages).  Accepts a comma-delimited list of: stderr, stdout, syslog, syslogpri:<notice|info|debug>, syslogid:<str> (where str is the prefix string for all syslog notices), file[:filename] (if filename is not specified, a default filename is used), fileappend (if not specified, the file is opened for truncation), level[:N] (if specified, integer verbose level; otherwise, 0 is implied)\",\n                                PRTE_MCA_BASE_VAR_TYPE_STRING, NULL, 0,\n                                PRTE_MCA_BASE_VAR_FLAG_NONE,\n                                PRTE_INFO_LVL_9,\n                                PRTE_MCA_BASE_VAR_SCOPE_READONLY,\n                                &prte_mca_base_verbose);\n\n    memset(&lds, 0, sizeof(lds));\n    if (NULL != prte_mca_base_verbose) {\n        parse_verbose(prte_mca_base_verbose, &lds);\n    } else {\n        set_defaults(&lds);\n    }\n    prte_asprintf(&lds.lds_prefix, \"[%s:%05d] \", prte_process_info.nodename, getpid());\n    prte_output_reopen(0, &lds);\n    prte_output_verbose (PRTE_MCA_BASE_VERBOSE_COMPONENT, 0, \"mca: base: opening components\");\n    free(lds.lds_prefix);\n\n    /* Open up the component repository */\n    return prte_mca_base_component_repository_init();\n}\n\n\n/*\n * Set sane default values for the lds\n */\nstatic void set_defaults(prte_output_stream_t *lds)\n{\n\n    /* Load up defaults */\n\n    PRTE_CONSTRUCT(lds, prte_output_stream_t);\n#if defined(HAVE_SYSLOG) && defined(HAVE_SYSLOG_H)\n    lds->lds_syslog_priority = LOG_INFO;\n    lds->lds_syslog_ident = \"prte\";\n#endif\n    lds->lds_want_stderr = true;\n}\n\n\n/*\n * Parse the value of an environment variable describing verbosity\n */\nstatic void parse_verbose(char *e, prte_output_stream_t *lds)\n{\n    char *edup;\n    char *ptr, *next;\n    bool have_output = false;\n\n    if (NULL == e) {\n        return;\n    }\n\n    edup = strdup(e);\n    ptr = edup;\n\n    /* Now parse the environment variable */\n\n    while (NULL != ptr && strlen(ptr) > 0) {\n        next = strchr(ptr, ',');\n        if (NULL != next) {\n            *next = '\\0';\n        }\n\n        if (0 == strcasecmp(ptr, \"syslog\")) {\n#if defined(HAVE_SYSLOG) && defined(HAVE_SYSLOG_H)\n            lds->lds_want_syslog = true;\n            have_output = true;\n#else\n            prte_output(0, \"syslog support requested but not available on this system\");\n#endif  /* defined(HAVE_SYSLOG) && defined(HAVE_SYSLOG_H) */\n        }\n        else if (strncasecmp(ptr, \"syslogpri:\", 10) == 0) {\n#if defined(HAVE_SYSLOG) && defined(HAVE_SYSLOG_H)\n            lds->lds_want_syslog = true;\n            have_output = true;\n            if (strcasecmp(ptr + 10, \"notice\") == 0)\n                lds->lds_syslog_priority = LOG_NOTICE;\n            else if (strcasecmp(ptr + 10, \"INFO\") == 0)\n                lds->lds_syslog_priority = LOG_INFO;\n            else if (strcasecmp(ptr + 10, \"DEBUG\") == 0)\n                lds->lds_syslog_priority = LOG_DEBUG;\n#else\n            prte_output(0, \"syslog support requested but not available on this system\");\n#endif  /* defined(HAVE_SYSLOG) && defined(HAVE_SYSLOG_H) */\n        } else if (strncasecmp(ptr, \"syslogid:\", 9) == 0) {\n#if defined(HAVE_SYSLOG) && defined(HAVE_SYSLOG_H)\n            lds->lds_want_syslog = true;\n            lds->lds_syslog_ident = ptr + 9;\n#else\n            prte_output(0, \"syslog support requested but not available on this system\");\n#endif  /* defined(HAVE_SYSLOG) && defined(HAVE_SYSLOG_H) */\n        }\n\n        else if (strcasecmp(ptr, \"stdout\") == 0) {\n            lds->lds_want_stdout = true;\n            have_output = true;\n        } else if (strcasecmp(ptr, \"stderr\") == 0) {\n            lds->lds_want_stderr = true;\n            have_output = true;\n        }\n\n        else if (strcasecmp(ptr, \"file\") == 0 || strcasecmp(ptr, \"file:\") == 0) {\n            lds->lds_want_file = true;\n            have_output = true;\n        } else if (strncasecmp(ptr, \"file:\", 5) == 0) {\n            lds->lds_want_file = true;\n            lds->lds_file_suffix = strdup(ptr + 5);\n            have_output = true;\n        } else if (strcasecmp(ptr, \"fileappend\") == 0) {\n            lds->lds_want_file = true;\n            lds->lds_want_file_append = 1;\n            have_output = true;\n        }\n\n        else if (strncasecmp(ptr, \"level\", 5) == 0) {\n            lds->lds_verbose_level = 0;\n            if (ptr[5] == PRTE_ENV_SEP)\n                lds->lds_verbose_level = atoi(ptr + 6);\n        }\n\n        if (NULL == next) {\n            break;\n        }\n        ptr = next + 1;\n    }\n\n    /* If we didn't get an output, default to stderr */\n\n    if (!have_output) {\n        lds->lds_want_stderr = true;\n    }\n\n    /* All done */\n\n    free(edup);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-i7toh3zidlll7lxwnp72zprwcwg4ub7m/spack-src/src/mca/base/prte_mca_base_component_find.c": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana\n *                         University Research and Technology\n *                         Corporation.  All rights reserved.\n * Copyright (c) 2004-2007 The University of Tennessee and The University\n *                         of Tennessee Research Foundation.  All rights\n *                         reserved.\n * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,\n *                         University of Stuttgart.  All rights reserved.\n * Copyright (c) 2004-2005 The Regents of the University of California.\n *                         All rights reserved.\n * Copyright (c) 2008-2020 Cisco Systems, Inc.  All rights reserved\n * Copyright (c) 2008      Sun Microsystems, Inc.  All rights reserved.\n * Copyright (c) 2015      Research Organization for Information Science\n *                         and Technology (RIST). All rights reserved.\n * Copyright (c) 2014-2015 Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2019-2020 Intel, Inc.  All rights reserved.\n * Copyright (c) 2021      Nanook Consulting.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"prte_config.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#ifdef HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif\n\n#include \"src/mca/prteinstalldirs/prteinstalldirs.h\"\n#include \"src/util/prte_environ.h\"\n#include \"src/util/proc_info.h\"\n#include \"src/util/output.h\"\n#include \"src/util/argv.h\"\n#include \"src/util/show_help.h\"\n#include \"src/class/prte_list.h\"\n#include \"src/mca/mca.h\"\n#include \"src/mca/base/base.h\"\n#include \"src/mca/base/prte_mca_base_alias.h\"\n#include \"src/mca/base/prte_mca_base_component_repository.h\"\n#include \"constants.h\"\n#include \"src/mca/prtedl/base/base.h\"\n\n#if PRTE_HAVE_DL_SUPPORT\n/*\n * Private functions\n */\nstatic void find_dyn_components(const char *path, prte_mca_base_framework_t *framework,\n                                const char **names, bool include_mode);\n\n#endif /* PRTE_HAVE_DL_SUPPORT */\n\nstatic int component_find_check (prte_mca_base_framework_t *framework, char **requested_component_names);\n\n/*\n * Dummy structure for casting for open_only logic\n */\nstruct prte_mca_base_open_only_dummy_component_t {\n    /** MCA base component */\n    prte_mca_base_component_t version;\n    /** MCA base data */\n    prte_mca_base_component_data_t data;\n};\ntypedef struct prte_mca_base_open_only_dummy_component_t prte_mca_base_open_only_dummy_component_t;\n\nstatic char negate[] = \"^\";\n\nstatic bool use_component(const prte_mca_base_framework_t *framework,\n                          const bool include_mode,\n                          const char **requested_component_names,\n                          const char *component_name);\n\n\n/*\n * Function to find as many components of a given type as possible.  This\n * includes statically-linked in components as well as opening up a\n * directory and looking for shared-library MCA components of the\n * appropriate type (load them if available).\n *\n * Return one consolidated array of (prte_mca_base_component_t*) pointing to all\n * available components.\n */\nint prte_mca_base_component_find (const char *directory, prte_mca_base_framework_t *framework,\n                                   bool ignore_requested, bool open_dso_components)\n{\n    const prte_mca_base_component_t **static_components = framework->framework_static_components;\n    char **requested_component_names = NULL;\n    prte_mca_base_component_list_item_t *cli;\n    bool include_mode = true;\n    int ret;\n\n    if (!ignore_requested) {\n        ret = prte_mca_base_component_parse_requested (framework->framework_selection, &include_mode,\n                                                        &requested_component_names);\n        if (PRTE_SUCCESS != ret) {\n            return ret;\n        }\n    }\n\n    /* Find all the components that were statically linked in */\n    if (static_components) {\n        for (int i = 0 ; NULL != static_components[i]; ++i) {\n            if ( use_component(framework, include_mode,\n                               (const char**)requested_component_names,\n                               static_components[i]->mca_component_name) ) {\n                cli = PRTE_NEW(prte_mca_base_component_list_item_t);\n                if (NULL == cli) {\n                    ret = PRTE_ERR_OUT_OF_RESOURCE;\n                    goto component_find_out;\n                }\n                cli->cli_component = static_components[i];\n                prte_list_append(&framework->framework_components, (prte_list_item_t *) cli);\n            }\n        }\n    }\n\n#if PRTE_HAVE_DL_SUPPORT\n    /* Find any available dynamic components in the specified directory */\n    if (open_dso_components && !prte_mca_base_component_disable_dlopen) {\n        find_dyn_components(directory, framework, (const char**)requested_component_names,\n                            include_mode);\n    } else {\n        prte_output_verbose (PRTE_MCA_BASE_VERBOSE_INFO, 0,\n                            \"mca: base: component_find: dso loading for %s MCA components disabled\",\n                            framework->framework_name);\n    }\n#endif\n\n    if (include_mode) {\n        ret = component_find_check (framework, requested_component_names);\n    } else {\n        ret = PRTE_SUCCESS;\n    }\n\ncomponent_find_out:\n\n    if (NULL != requested_component_names) {\n        prte_argv_free(requested_component_names);\n    }\n\n    /* All done */\n\n    return ret;\n}\n\nint prte_mca_base_component_find_finalize(void)\n{\n    return PRTE_SUCCESS;\n}\n\nint prte_mca_base_components_filter (prte_mca_base_framework_t *framework, uint32_t filter_flags)\n{\n    prte_list_t *components = &framework->framework_components;\n    int output_id = framework->framework_output;\n    prte_mca_base_component_list_item_t *cli, *next;\n    char **requested_component_names = NULL;\n    bool include_mode, can_use;\n    int ret;\n\n    assert (NULL != components);\n\n    if (0 == filter_flags && NULL == framework->framework_selection) {\n        return PRTE_SUCCESS;\n    }\n\n    ret = prte_mca_base_component_parse_requested (framework->framework_selection, &include_mode,\n                                                    &requested_component_names);\n    if (PRTE_SUCCESS != ret) {\n        return ret;\n    }\n\n    PRTE_LIST_FOREACH_SAFE(cli, next, components, prte_mca_base_component_list_item_t) {\n        const prte_mca_base_component_t *component = cli->cli_component;\n        prte_mca_base_open_only_dummy_component_t *dummy =\n            (prte_mca_base_open_only_dummy_component_t *) cli->cli_component;\n\n        can_use = use_component (framework, include_mode, (const char **) requested_component_names,\n                                 cli->cli_component->mca_component_name);\n\n        if (!can_use || (filter_flags & dummy->data.param_field) != filter_flags) {\n            if (can_use && (filter_flags & PRTE_MCA_BASE_METADATA_PARAM_CHECKPOINT) &&\n                !(PRTE_MCA_BASE_METADATA_PARAM_CHECKPOINT & dummy->data.param_field)) {\n                prte_output_verbose (PRTE_MCA_BASE_VERBOSE_COMPONENT, output_id,\n                                     \"mca: base: components_filter: \"\n                                     \"(%s) Component %s is *NOT* Checkpointable - Disabled\",\n                                     component->reserved,\n                                     component->mca_component_name);\n            }\n\n            prte_list_remove_item (components, &cli->super);\n\n            prte_mca_base_component_unload (component, output_id);\n\n            PRTE_RELEASE(cli);\n        } else if (filter_flags & PRTE_MCA_BASE_METADATA_PARAM_CHECKPOINT) {\n            prte_output_verbose (PRTE_MCA_BASE_VERBOSE_COMPONENT, output_id,\n                                 \"mca: base: components_filter: \"\n                                 \"(%s) Component %s is Checkpointable\",\n                                 component->reserved,\n                                 component->mca_component_name);\n        }\n    }\n\n    if (include_mode) {\n        ret = component_find_check (framework, requested_component_names);\n    } else {\n        ret = PRTE_SUCCESS;\n    }\n\n    if (NULL != requested_component_names) {\n        prte_argv_free (requested_component_names);\n    }\n\n    return ret;\n}\n\n#if PRTE_HAVE_DL_SUPPORT\n\n/*\n * Open up all directories in a given path and search for components of\n * the specified type (and possibly of a given name).\n *\n * Note that we use our own path iteration functionality because we\n * need to look at companion .ompi_info files in the same directory as\n * the library to generate dependencies, etc.\n */\nstatic void find_dyn_components(const char *path, prte_mca_base_framework_t *framework,\n                                const char **names, bool include_mode)\n{\n    prte_mca_base_component_repository_item_t *ri;\n    prte_list_t *dy_components;\n    int ret;\n\n    if (NULL != path) {\n        ret = prte_mca_base_component_repository_add (path);\n        if (PRTE_SUCCESS != ret) {\n            return;\n        }\n    }\n\n    ret = prte_mca_base_component_repository_get_components (framework, &dy_components);\n    if (PRTE_SUCCESS != ret) {\n        return;\n    }\n\n    /* Iterate through the repository and find components that can be included */\n    PRTE_LIST_FOREACH(ri, dy_components, prte_mca_base_component_repository_item_t) {\n        if (use_component(framework, include_mode, names, ri->ri_name)) {\n            prte_mca_base_component_repository_open (framework, ri);\n        }\n    }\n}\n\n#endif /* PRTE_HAVE_DL_SUPPORT */\n\nstatic bool component_in_list (const char **requested_component_names,\n                               const char *component_name)\n{\n    for (int i = 0 ; requested_component_names[i] ; ++i) {\n        if (strcmp(component_name, requested_component_names[i]) == 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nstatic bool use_component(const prte_mca_base_framework_t *framework,\n                          const bool include_mode,\n                          const char **requested_component_names,\n                          const char *component_name)\n{\n    /*\n     * If no selection is specified then we use all components\n     * we can find.\n     */\n    if (NULL == requested_component_names) {\n        return true;\n    }\n\n    bool found = component_in_list (requested_component_names, component_name);\n\n    if (!found) {\n        const prte_mca_base_alias_t *alias = prte_mca_base_alias_lookup (framework->framework_project,\n                                                               framework->framework_name, component_name);\n        if (alias) {\n            PRTE_LIST_FOREACH_DECL(alias_item, &alias->component_aliases, prte_mca_base_alias_item_t) {\n                found = component_in_list (requested_component_names, alias_item->component_alias);\n                if (found) {\n                    break;\n                }\n            }\n        }\n    }\n\n    /*\n     * include_mode  found |   use\n     * --------------------+------\n     *            0      0 |  true\n     *            0      1 | false\n     *            1      0 | false\n     *            1      1 |  true\n     *\n     * -> inverted xor\n     * As xor is a binary operator let's implement it manually before\n     * a compiler screws it up.\n     */\n\n    return (include_mode && found) || !(include_mode || found);\n}\n\n/* Ensure that *all* requested components exist.  Print a warning\n   and abort if they do not. */\nstatic int component_find_check (prte_mca_base_framework_t *framework, char **requested_component_names)\n{\n    prte_list_t *components = &framework->framework_components;\n    prte_mca_base_component_list_item_t *cli;\n\n    if (NULL == requested_component_names) {\n        return PRTE_SUCCESS;\n    }\n\n    for (int i = 0; NULL != requested_component_names[i]; ++i) {\n        bool found = false;\n\n        PRTE_LIST_FOREACH(cli, components, prte_mca_base_component_list_item_t) {\n            if (0 == strcmp(requested_component_names[i],\n                            cli->cli_component->mca_component_name)) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            prte_show_help(\"help-prte-mca-base.txt\",\n                           \"find-available:not-valid\", true,\n                           prte_process_info.nodename, framework->framework_name, requested_component_names[i]);\n            return PRTE_ERR_NOT_FOUND;\n        }\n    }\n\n    return PRTE_SUCCESS;\n}\n\nint prte_mca_base_component_parse_requested (const char *requested, bool *include_mode,\n                                              char ***requested_component_names)\n{\n    const char *requested_orig = requested;\n\n    *requested_component_names = NULL;\n    *include_mode = true;\n\n    /* See if the user requested anything */\n    if (NULL == requested || 0 == strlen (requested)) {\n        return PRTE_SUCCESS;\n    }\n\n    /* Are we including or excluding?  We only allow the negate\n       character to be the *first* character of the value (but be nice\n       and allow any number of negate characters in the beginning). */\n    *include_mode = requested[0] != negate[0];\n\n    /* skip over all negate symbols at the beginning */\n    requested += strspn (requested, negate);\n\n    /* Double check to ensure that the user did not specify the negate\n       character anywhere else in the value. */\n    if (NULL != strstr (requested, negate)) {\n        prte_show_help(\"help-prte-mca-base.txt\",\n                       \"framework-param:too-many-negates\",\n                       true, requested_orig);\n        return PRTE_ERROR;\n    }\n\n    /* Split up the value into individual component names */\n    *requested_component_names = prte_argv_split(requested, ',');\n\n    /* All done */\n    return PRTE_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-i7toh3zidlll7lxwnp72zprwcwg4ub7m/spack-src/src/mca/prtedl/configure.m4": "dnl -*- shell-script -*-\ndnl\ndnl Copyright (c) 2010-2020 Cisco Systems, Inc.  All rights reserved\ndnl Copyright (c) 2019-2020 Intel, Inc.  All rights reserved.\ndnl $COPYRIGHT$\ndnl\ndnl Additional copyrights may follow\ndnl\ndnl $HEADER$\ndnl\n\ndnl There will only be one component used in this framework, and it will\ndnl be selected at configure time by priority.  Components must set\ndnl their priorities in their configure.m4 file.\n\ndnl We only want one winning component (vs. STOP_AT_FIRST_PRIORITY,\ndnl which will allow all components of the same priority who succeed to\ndnl win)\nm4_define(MCA_prte_prtedl_CONFIGURE_MODE, STOP_AT_FIRST)\n\nAC_DEFUN([MCA_prte_prtedl_CONFIG],[\n    PRTE_HAVE_DL_SUPPORT=0\n\n    # If --disable-prtedlopen was used, then have all the components fail\n    # (we still need to configure them all so that things like \"make\n    # dist\" work\", but we just want the MCA system to (artificially)\n    # conclude that it can't build any of the components.\n    AS_IF([test \"$enable_prtedlopen\" = \"no\"],\n          [want_prtedl=0], [want_prtedl=1])\n\n    MCA_CONFIGURE_FRAMEWORK([prtedl], [$want_prtedl])\n\n    # If we found no suitable static prtedl component and prtedlopen support\n    # was not specifically disabled, this is an error.\n    AS_IF([test \"$MCA_prte_prtedl_STATIC_COMPONENTS\" = \"\" && \\\n           test \"$enable_prtedlopen\" != \"no\"],\n          [AC_MSG_WARN([Did not find a suitable static prte prtedl component])\n           AC_MSG_WARN([You might need to install libltld (and its headers) or])\n           AC_MSG_WARN([specify --disable-prtedlopen to configure.])\n           AC_MSG_ERROR([Cannot continue])])\n\n    # If we have a winning component (which, per above, will only\n    # happen if --disable-prtedlopen was *not* specified), do some more\n    # logic.\n    AS_IF([test \"$MCA_prte_prtedl_STATIC_COMPONENTS\" != \"\"],\n       [ # We had a winner -- w00t!\n\n        PRTE_HAVE_DL_SUPPORT=1\n        # If we added any -L flags to ADD_LDFLAGS, then we (might)\n        # need to add those directories to LD_LIBRARY_PATH.\n        # Otherwise, if we try to AC RUN_IFELSE anything here in\n        # configure, it might die because it can't find the libraries\n        # we just linked against.\n        PRTE_VAR_SCOPE_PUSH([prte_prtedl_base_found_l prte_prtedl_base_token prte_prtedl_base_tmp prte_prtedl_base_dir])\n        prte_prtedl_base_found_l=0\n        eval \"prte_prtedl_base_tmp=\\$prte_prtedl_${prte_prtedl_winner}_ADD_LIBS\"\n        for prte_prtedl_base_token in $prte_prtedl_base_tmp; do\n            case $prte_prtedl_base_token in\n            -l*) prte_prtedl_base_found_l=1 ;;\n            esac\n        done\n        AS_IF([test $prte_prtedl_base_found_l -eq 1],\n              [eval \"prte_prtedl_base_tmp=\\$prte_prtedl_${prte_prtedl_winner}_ADD_LDFLAGS\"\n               for prte_prtedl_base_token in $prte_prtedl_base_tmp; do\n                   case $prte_prtedl_base_token in\n                   -L*)\n                       prte_prtedl_base_dir=`echo $prte_prtedl_base_token | cut -c3-`\n                       export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$prte_prtedl_base_dir\n                       AC_MSG_WARN([Adding to LD_LIBRARY_PATH: $prte_prtedl_base_dir])\n                       ;;\n                   esac\n               done])\n        PRTE_VAR_SCOPE_POP\n    ])\n\n    AC_DEFINE_UNQUOTED([PRTE_HAVE_DL_SUPPORT], [$PRTE_HAVE_DL_SUPPORT],\n                       [Whether the PRTE DL framework is functional or not])\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-i7toh3zidlll7lxwnp72zprwcwg4ub7m/spack-src/src/mca/prtedl/prtedl.h": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2015-2020 Cisco Systems, Inc.  All rights reserved\n * Copyright (c) 2015      Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2019-2020 Intel, Inc.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n/**\n * @file\n *\n * Dynamic library framework\n *\n * General Description:\n *\n * This framework provides portable access to prtedlopen- and prtedlsym-like\n * functionality, very similar to Libtool's libltprtedl.  Indeed, one of\n * the components in this framework will use libltprtedl, if it is\n * present/available.  However, on some common types systems where\n * libltprtedl headers and libraries are *not* available, we can support\n * plugins via this simple framework.\n *\n * This is a compile-time framework: a single component will be\n * selected by the priority that its configure.m4 provides.  All other\n * components will be ignored (i.e., not built/not part of the\n * installation).  Meaning: the static_components of the prtedl framework\n * will always contain 0 or 1 components.\n *\n * SIDENOTE: PRTE used to embed libltprtedl.  However, as of early\n * 2015, this became problematic, for a variety of complex and\n * uninteresting reasons (see the following if you care about the\n * details: https://github.com/open-mpi/ompi/issues/311,\n * http://debbugs.gnu.org/cgi/bugreport.cgi?bug=19370,\n * https://github.com/open-mpi/ompi/pull/366,\n * https://github.com/open-mpi/ompi/pull/390).  That being said, we,\n * as a developer community, still wanted to be able to natively use\n * DSOs by default.  A small/simple framework for DL functionality,\n * along with a simple component that supports prtedlopen/prtedlsym on POSIX\n * platforms and another component that natively uses libltprtedl seemed\n * like a good solution.\n */\n\n#ifndef PRTE_MCA_DL_DL_H\n#define PRTE_MCA_DL_DL_H\n\n#include \"prte_config.h\"\n\n#include \"src/mca/mca.h\"\n#include \"src/mca/base/base.h\"\n\nBEGIN_C_DECLS\n\n/**\n * Handle for an opened file\n */\nstruct prte_dl_handle_t;\ntypedef struct prte_dl_handle_t prte_dl_handle_t;\n\n/**\n * Dynamically open the file specified.\n *\n * Arguments:\n *   fname   = Base filename to open.  If NULL, open this process.\n *   use_ext = If true, try various filename suffixes that are\n *       relevant on this platform (e.g., .so, .prtedll, .dylib).  If\n *       false, just use exactly whatever was passed as fname.\n *   private = If true, open the file in a private namespace.\n *       Otherwise, open the file in a global namespace.\n *   handle = Upon successful open, a handle to the opened file will\n *       be returned.\n *   err_msg= if non-NULL and !=PRTE_SUCCESS is returned, will point to a\n *       string error message\n *\n * Returns:\n *   PRTE_SUCCESS on success, or PRTE_ERROR\n *\n * Space for the handle must be allocated by the module (it can be\n * freed during the call to prte_prtedl_base_module_prtedlclose_fn_t).\n *\n * The err_msg points to an internal string and should not be altered\n * or freed by the caller.  The contents of the err_msg string may\n * change after successive calls to prte_prtedl API calls.\n */\ntypedef int (*prte_prtedl_base_module_open_fn_t)\n    (const char *fname, bool use_ext, bool private_namespace,\n     prte_dl_handle_t **handle, char **err_msg);\n\n/**\n * Lookup a symbol in an opened file.\n *\n * Arguments:\n *   handle = handle of a previously dynamically opened file\n *   symbol = name of the symbol to lookup\n *   ptr    = if found, a pointer to the symbol.  Otherwise, NULL.\n *   err_msg= if non-NULL and !=PRTE_SUCCESS is returned, will point to a\n *            string error message\n * Returns:\n *   PRTE_SUCCESS on success, or PRTE_ERROR\n *\n *\n * The err_msg points to an internal string and should not be altered\n * or freed by the caller.  The contents of the err_msg string may\n * change after successive calls to prte_prtedl API calls.\n */\ntypedef int (*prte_prtedl_base_module_lookup_fn_t)\n    (prte_dl_handle_t *handle, const char *symbol, void **ptr, char **err_msg);\n\n/**\n * Dynamically close a previously dynamically-opened file.\n *\n * Arguments:\n *   handle = handle of a previously dynamically opened file.\n * Returns:\n *   PRTE_SUCCESS on success, or PRTE_ERROR\n *\n * This function should close the file and free and resources\n * associated with it (e.g., whatever is cached on the handle).\n */\ntypedef int (*prte_prtedl_base_module_close_fn_t)\n    (prte_dl_handle_t *handle);\n\n/**\n * Search through a path of directories, invoking a callback on each\n * unique regular (non-Libtool) file basename found (e.g., will only\n * be invoked once for the files \"foo.la\" and \"foo.so\", with the\n * parameter \"foo\").\n *\n * Arguments:\n *   path   = PRTE_ENV_SEP-delimited list of directories\n *   cb_func= function to invoke on each filename found\n *   data   = context for callback function\n * Returns:\n *   PRTE_SUCESS on success, PRTE_ERR* otherwise\n */\ntypedef int (*prte_prtedl_base_module_foreachfile_fn_t)\n    (const char *search_path,\n     int (*cb_func)(const char *filename, void *context),\n     void *context);\n\n/**\n * Structure for DL components.\n */\nstruct prte_prtedl_base_component_1_0_0_t {\n    /** MCA base component */\n    prte_mca_base_component_t base_version;\n    /** MCA base data */\n    prte_mca_base_component_data_t base_data;\n\n    /** Default priority */\n    int priority;\n};\ntypedef struct prte_prtedl_base_component_1_0_0_t prte_prtedl_base_component_1_0_0_t;\ntypedef struct prte_prtedl_base_component_1_0_0_t prte_prtedl_base_component_t;\n\n/**\n * Structure for DL modules\n */\nstruct prte_prtedl_base_module_1_0_0_t {\n    prte_mca_base_module_2_0_0_t                 super;\n\n    /** Open / close */\n    prte_prtedl_base_module_open_fn_t           open;\n    prte_prtedl_base_module_close_fn_t          close;\n\n    /** Lookup a symbol */\n    prte_prtedl_base_module_lookup_fn_t         lookup;\n\n    /** Iterate looking for files */\n    prte_prtedl_base_module_foreachfile_fn_t    foreachfile;\n};\ntypedef struct prte_prtedl_base_module_1_0_0_t prte_prtedl_base_module_1_0_0_t;\ntypedef struct prte_prtedl_base_module_1_0_0_t prte_prtedl_base_module_t;\n\n/**\n * Macro for use in components that are of type DL\n */\n#define PRTE_DL_BASE_VERSION_1_0_0              \\\n    PRTE_MCA_BASE_VERSION_2_1_0(\"prtedl\", 1, 0, 0)\n\nEND_C_DECLS\n\n#endif /* PRTE_MCA_DL_DL_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-i7toh3zidlll7lxwnp72zprwcwg4ub7m/spack-src/src/mca/prtedl/dlopen/prtedl_dlopen.h": "/*\n * Copyright (c) 2015-2020 Cisco Systems, Inc.  All rights reserved\n * Copyright (c) 2019-2020 Intel, Inc.  All rights reserved.\n * Copyright (c) 2019      Research Organization for Information Science\n *                         and Technology (RIST).  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#ifndef PRTE_DL_DLOPEN\n#define PRTE_DL_DLOPEN\n\n#include \"prte_config.h\"\n\n#include \"src/mca/prtedl/prtedl.h\"\n\nPRTE_EXPORT extern prte_prtedl_base_module_t prte_prtedl_dlopen_module;\n\n/*\n * Dynamic library handles generated by this component.\n *\n * If we're debugging, keep a copy of the name of the file we've opened.\n */\nstruct prte_dl_handle_t {\n    void *dlopen_handle;\n#if PRTE_ENABLE_DEBUG\n    void *filename;\n#endif\n};\n\ntypedef struct {\n    prte_prtedl_base_component_t base;\n\n    char *filename_suffixes_mca_storage;\n    char **filename_suffixes;\n} prte_prtedl_dlopen_component_t;\n\nPRTE_EXPORT extern prte_prtedl_dlopen_component_t prte_prtedl_dlopen_component;\n\n#endif /* PRTE_DL_DLOPEN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-i7toh3zidlll7lxwnp72zprwcwg4ub7m/spack-src/src/mca/prtedl/dlopen/configure.m4": "# -*- shell-script -*-\n#\n# Copyright (c) 2009-2020 Cisco Systems, Inc.  All rights reserved\n#\n# Copyright (c) 2017-2020 Intel, Inc.  All rights reserved.\n# $COPYRIGHT$\n#\n# Additional copyrights may follow\n#\n# $HEADER$\n#\n\nAC_DEFUN([MCA_prte_prtedl_dlopen_PRIORITY], [80])\n\n#\n# Force this component to compile in static-only mode\n#\nAC_DEFUN([MCA_prte_prtedl_dlopen_COMPILE_MODE], [\n    AC_MSG_CHECKING([for MCA component $1:$2 compile mode])\n    $3=\"static\"\n    AC_MSG_RESULT([$$3])\n])\n\n# MCA_prtedl_dlopen_CONFIG([action-if-can-compile],\n#                      [action-if-cant-compile])\n# ------------------------------------------------\nAC_DEFUN([MCA_prte_prtedl_dlopen_CONFIG],[\n    AC_CONFIG_FILES([src/mca/prtedl/dlopen/Makefile])\n\n    dnl This is effectively a back-door for PRTE developers to\n    dnl force the use of the libltprtedl prtedl component.\n    AC_ARG_ENABLE([prtedl-dlopen],\n        [AS_HELP_STRING([--disable-prtedl-dlopen],\n            [Disable the \"dlopen\" PRTE DL component (and probably force the use of the \"libltdl\" DL component).  This option should really only be used by PRTE developers.  You are probably actually looking for the \"--disable-prtedlopen\" option, which disables all dlopen-like functionality from PRTE.])\n        ])\n\n    prte_prtedl_prtedlopen_happy=no\n    AS_IF([test \"$enable_prtedl_prtedlopen\" != \"no\"],\n          [PRTE_CHECK_PACKAGE([prte_prtedl_dlopen],\n              [dlfcn.h],\n              [dl],\n              [dlopen],\n              [],\n              [],\n              [],\n              [prte_prtedl_dlopen_happy=yes],\n              [prte_prtedl_dlopen_happy=no])\n          ])\n\n    AS_IF([test \"$prte_prtedl_dlopen_happy\" = \"yes\"],\n          [prtedl_dlopen_ADD_LIBS=$prte_prtedl_dlopen_LIBS\n           prtedl_dlopen_WRAPPER_EXTRA_LIBS=$prte_prtedl_dlopen_LIBS\n           $1],\n          [$2])\n\n    AC_SUBST(prte_prtedl_dlopen_LIBS)\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-i7toh3zidlll7lxwnp72zprwcwg4ub7m/spack-src/src/mca/prtedl/dlopen/prtedl_dlopen_module.c": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2015-2020 Cisco Systems, Inc.  All rights reserved\n * Copyright (c) 2015      Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2016      IBM Corporation.  All rights reserved.\n * Copyright (c) 2018      Amazon.com, Inc. or its affiliates.  All Rights reserved.\n * Copyright (c) 2018-2020 Intel, Inc.  All rights reserved.\n * Copyright (c) 2019      Research Organization for Information Science\n *                         and Technology (RIST).  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"prte_config.h\"\n\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include \"constants.h\"\n#include \"src/mca/prtedl/prtedl.h\"\n#include \"src/util/argv.h\"\n#include \"src/util/printf.h\"\n\n#include \"prtedl_dlopen.h\"\n\n\n/*\n * Trivial helper function to avoid replicating code\n */\nstatic void do_dlopen(const char *fname, int flags,\n                      void **handle, char **err_msg)\n{\n    assert(handle);\n\n    *handle = dlopen(fname, flags);\n\n    if (NULL != err_msg) {\n        if (NULL != *handle) {\n            *err_msg = NULL;\n        } else {\n            *err_msg = dlerror();\n        }\n    }\n}\n\n\nstatic int dlopen_open(const char *fname, bool use_ext, bool private_namespace,\n                       prte_dl_handle_t **handle, char **err_msg)\n{\n    assert(handle);\n\n    *handle = NULL;\n\n    /* Setup the prtedlopen flags */\n    int flags = RTLD_LAZY;\n    if (private_namespace) {\n        flags |= RTLD_LOCAL;\n    } else {\n        flags |= RTLD_GLOBAL;\n    }\n\n    /* If the caller wants to use filename extensions, loop through\n       them */\n    void *local_handle = NULL;\n    if (use_ext && NULL != fname) {\n        int i, rc;\n        char *ext;\n\n        for (i = 0, ext = prte_prtedl_dlopen_component.filename_suffixes[i];\n             NULL != ext;\n             ext = prte_prtedl_dlopen_component.filename_suffixes[++i]) {\n            char *name;\n\n            prte_asprintf(&name, \"%s%s\", fname, ext);\n            if (NULL == name) {\n                return PRTE_ERR_IN_ERRNO;\n            }\n\n            /* Does the file exist? */\n            struct stat buf;\n            if (stat(name, &buf) < 0) {\n                if (NULL != err_msg) {\n                    rc = asprintf(err_msg, \"File %s not found\", name);\n                    if (0 > rc) {\n                        free(name);\n                        return PRTE_ERR_OUT_OF_RESOURCE;\n                    }\n                }\n                free(name);\n                continue;\n            }\n\n            /* Yes, the file exists -- try to prtedlopen it.  If we can't\n               prtedlopen it, bail. */\n            do_dlopen(name, flags, &local_handle, err_msg);\n            free(name);\n            break;\n        }\n    }\n\n    /* Otherwise, the caller does not want to use filename extensions,\n       so just use the single filename that the caller provided */\n    else {\n        do_dlopen(fname, flags, &local_handle, err_msg);\n    }\n\n    if (NULL != local_handle) {\n        *handle = calloc(1, sizeof(prte_dl_handle_t));\n        (*handle)->dlopen_handle = local_handle;\n\n#if PRTE_ENABLE_DEBUG\n        if( NULL != fname ) {\n            (*handle)->filename = strdup(fname);\n        }\n        else {\n            (*handle)->filename = strdup(\"(null)\");\n        }\n#endif\n    }\n    return (NULL != local_handle) ? PRTE_SUCCESS : PRTE_ERROR;\n}\n\n\nstatic int dlopen_lookup(prte_dl_handle_t *handle, const char *symbol,\n                         void **ptr, char **err_msg)\n{\n    assert(handle);\n    assert(handle->dlopen_handle);\n    assert(symbol);\n    assert(ptr);\n\n    *ptr = dlsym(handle->dlopen_handle, symbol);\n    if (NULL != *ptr) {\n        return PRTE_SUCCESS;\n    }\n\n    if (NULL != err_msg) {\n        *err_msg = dlerror();\n    }\n    return PRTE_ERROR;\n}\n\n\nstatic int dlopen_close(prte_dl_handle_t *handle)\n{\n    assert(handle);\n\n    int ret;\n    ret = dlclose(handle->dlopen_handle);\n\n#if PRTE_ENABLE_DEBUG\n    free(handle->filename);\n#endif\n    free(handle);\n\n    return ret;\n}\n\n/*\n * Scan all the files in a directory (or path) and invoke a callback\n * on each one.\n */\nstatic int dlopen_foreachfile(const char *search_path,\n                              int (*func)(const char *filename, void *data),\n                              void *data)\n{\n    int ret;\n    DIR *dp = NULL;\n    char **dirs = NULL;\n    char **good_files = NULL;\n\n    dirs = prte_argv_split(search_path, PRTE_ENV_SEP);\n    for (int i = 0; NULL != dirs && NULL != dirs[i]; ++i) {\n\n        dp = opendir(dirs[i]);\n        if (NULL == dp) {\n            ret = PRTE_ERR_IN_ERRNO;\n            goto error;\n        }\n\n        struct dirent *de;\n        while (NULL != (de = readdir(dp))) {\n\n            /* Make the absolute path name */\n            char *abs_name = NULL;\n            prte_asprintf(&abs_name, \"%s/%s\", dirs[i], de->d_name);\n            if (NULL == abs_name) {\n                ret = PRTE_ERR_IN_ERRNO;\n                goto error;\n            }\n\n            /* Stat the file */\n            struct stat buf;\n            if (stat(abs_name, &buf) < 0) {\n                free(abs_name);\n                ret = PRTE_ERR_IN_ERRNO;\n                goto error;\n            }\n\n            /* Skip if not a file */\n            if (!S_ISREG(buf.st_mode)) {\n                free(abs_name);\n                continue;\n            }\n\n            /* Find the suffix */\n            char *ptr = strrchr(abs_name, '.');\n            if (NULL != ptr) {\n\n                /* Skip libtool files */\n                if (strcmp(ptr, \".la\") == 0 ||\n                    strcmp(ptr, \".lo\") == 0) {\n                    free (abs_name);\n                    continue;\n                }\n\n                *ptr = '\\0';\n            }\n\n            /* Have we already found this file?  Or already found a\n               file with the same basename (but different suffix)? */\n            bool found = false;\n            for (int j = 0; NULL != good_files &&\n                     NULL != good_files[j]; ++j) {\n                if (strcmp(good_files[j], abs_name) == 0) {\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) {\n                prte_argv_append_nosize(&good_files, abs_name);\n            }\n            free(abs_name);\n        }\n        closedir(dp);\n    }\n    dp = NULL;\n\n    /* Invoke the callback on all the found files */\n    if (NULL != good_files) {\n        for (int i = 0; NULL != good_files[i]; ++i) {\n            ret = func(good_files[i], data);\n            if (PRTE_SUCCESS != ret) {\n                goto error;\n            }\n        }\n    }\n\n    ret = PRTE_SUCCESS;\n\n error:\n    if (NULL != dp) {\n        closedir(dp);\n    }\n    if (NULL != dirs) {\n        prte_argv_free(dirs);\n    }\n    if (NULL != good_files) {\n        prte_argv_free(good_files);\n    }\n\n    return ret;\n}\n\n\n/*\n * Module definition\n */\nprte_prtedl_base_module_t prte_prtedl_dlopen_module = {\n    .open = dlopen_open,\n    .lookup = dlopen_lookup,\n    .close = dlopen_close,\n    .foreachfile = dlopen_foreachfile\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-i7toh3zidlll7lxwnp72zprwcwg4ub7m/spack-src/src/mca/prtedl/dlopen/prtedl_dlopen_component.c": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2015-2020 Cisco Systems, Inc.  All rights reserved\n * Copyright (c) 2015      Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2019-2020 Intel, Inc.  All rights reserved.\n * Copyright (c) 2019      Research Organization for Information Science\n *                         and Technology (RIST).  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"prte_config.h\"\n\n#include \"constants.h\"\n#include \"src/mca/prtedl/prtedl.h\"\n#include \"src/util/argv.h\"\n\n#include \"prtedl_dlopen.h\"\n\n\n/*\n * Public string showing the sysinfo ompi_linux component version number\n */\nconst char *prte_prtedl_dlopen_component_version_string =\n    \"PRTE prtedl dlopen MCA component version \" PRTE_VERSION;\n\n\n/*\n * Local functions\n */\nstatic int dlopen_component_register(void);\nstatic int dlopen_component_open(void);\nstatic int dlopen_component_close(void);\nstatic int dlopen_component_query(prte_mca_base_module_t **module, int *priority);\n\n/*\n * Instantiate the public struct with all of our public information\n * and pointers to our public functions in it\n */\n\nprte_prtedl_dlopen_component_t prte_prtedl_dlopen_component = {\n\n    /* Fill in the mca_prtedl_base_component_t */\n    .base = {\n\n        /* First, the mca_component_t struct containing meta information\n           about the component itself */\n        .base_version = {\n            PRTE_DL_BASE_VERSION_1_0_0,\n\n            /* Component name and version */\n            .mca_component_name = \"dlopen\",\n            PRTE_MCA_BASE_MAKE_VERSION(component, PRTE_MAJOR_VERSION, PRTE_MINOR_VERSION,\n                                        PRTE_RELEASE_VERSION),\n\n            /* Component functions */\n            .mca_register_component_params = dlopen_component_register,\n            .mca_open_component = dlopen_component_open,\n            .mca_close_component = dlopen_component_close,\n            .mca_query_component = dlopen_component_query,\n        },\n\n        .base_data = {\n            /* The component is checkpoint ready */\n            PRTE_MCA_BASE_METADATA_PARAM_CHECKPOINT\n        },\n\n        /* The prtedl framework members */\n        .priority = 80\n    },\n};\n\n\nstatic int dlopen_component_register(void)\n{\n    int ret;\n\n    prte_prtedl_dlopen_component.filename_suffixes_mca_storage = \".so,.dylib,.dll,.sl\";\n    ret =\n        prte_mca_base_component_var_register(&prte_prtedl_dlopen_component.base.base_version,\n                                        \"filename_suffixes\",\n                                        \"Comma-delimited list of filename suffixes that the PRTE dlopen component will try\",\n                                        PRTE_MCA_BASE_VAR_TYPE_STRING,\n                                        NULL,\n                                        0,\n                                        PRTE_MCA_BASE_VAR_FLAG_SETTABLE,\n                                        PRTE_INFO_LVL_5,\n                                        PRTE_MCA_BASE_VAR_SCOPE_LOCAL,\n                                        &prte_prtedl_dlopen_component.filename_suffixes_mca_storage);\n    if (ret < 0) {\n        return ret;\n    }\n    prte_prtedl_dlopen_component.filename_suffixes =\n        prte_argv_split(prte_prtedl_dlopen_component.filename_suffixes_mca_storage,\n                        ',');\n\n    return PRTE_SUCCESS;\n}\n\nstatic int dlopen_component_open(void)\n{\n    return PRTE_SUCCESS;\n}\n\n\nstatic int dlopen_component_close(void)\n{\n    if (NULL != prte_prtedl_dlopen_component.filename_suffixes) {\n        prte_argv_free(prte_prtedl_dlopen_component.filename_suffixes);\n        prte_prtedl_dlopen_component.filename_suffixes = NULL;\n    }\n\n    return PRTE_SUCCESS;\n}\n\n\nstatic int dlopen_component_query(prte_mca_base_module_t **module, int *priority)\n{\n    /* The priority value is somewhat meaningless here; by\n       src/mca/prtedl/configure.m4, there's at most one component\n       available. */\n    *priority = prte_prtedl_dlopen_component.base.priority;\n    *module = &prte_prtedl_dlopen_module.super;\n\n    return PRTE_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-i7toh3zidlll7lxwnp72zprwcwg4ub7m/spack-src/src/mca/prtedl/dlopen/Makefile.am": "#\n# Copyright (c) 2004-2010 The Trustees of Indiana University.\n#                         All rights reserved.\n# Copyright (c) 2014-2020 Cisco Systems, Inc.  All rights reserved\n# Copyright (c) 2019-2020 Intel, Inc.  All rights reserved.\n# $COPYRIGHT$\n#\n# Additional copyrights may follow\n#\n# $HEADER$\n#\n\nsources = \\\n        prtedl_dlopen.h \\\n        prtedl_dlopen_component.c \\\n        prtedl_dlopen_module.c\n\n# This component will only ever be built statically -- never as a DSO.\n\nnoinst_LTLIBRARIES = libmca_prtedl_dlopen.la\n\nlibmca_prtedl_dlopen_la_SOURCES = $(sources)\nlibmca_prtedl_dlopen_la_LDFLAGS = -module -avoid-version\nlibmca_prtedl_dlopen_la_LIBADD = $(prte_prtedl_dlopen_LIBS)\n",
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-i7toh3zidlll7lxwnp72zprwcwg4ub7m/spack-src/src/mca/prtedl/libltdl/configure.m4": "# -*- shell-script -*-\n#\n# Copyright (c) 2009-2020 Cisco Systems, Inc.  All rights reserved\n#\n# Copyright (c) 2017-2020 Intel, Inc.  All rights reserved.\n# $COPYRIGHT$\n#\n# Additional copyrights may follow\n#\n# $HEADER$\n#\n\nAC_DEFUN([MCA_prte_prtedl_libltdl_PRIORITY], [50])\n\n#\n# Force this component to compile in static-only mode\n#\nAC_DEFUN([MCA_prte_prtedl_libltdl_COMPILE_MODE], [\n    AC_MSG_CHECKING([for MCA component $1:$2 compile mode])\n    $3=\"static\"\n    AC_MSG_RESULT([$$3])\n])\n\n# MCA_prte_prtedl_libltdl_POST_CONFIG()\n# ---------------------------------\nAC_DEFUN([MCA_prte_prtedl_libltdl_POST_CONFIG],[\n    # If we won, then do all the rest of the setup\n    AS_IF([test \"$1\" = \"1\"],\n          [\n           # Add some stuff to CPPFLAGS so that the rest of the source\n           # tree can be built\n           LDFLAGS=\"$LDFLAGS $prte_prtedl_libltdl_ADD_LDFLAGS\"\n           LIBS=\"$LIBS $prte_prtedl_libltdl_ADD_LIBS\"\n          ])\n])dnl\n\n# MCA_prtedl_libltdl_CONFIG([action-if-can-compile],\n#                       [action-if-cant-compile])\n# ------------------------------------------------\nAC_DEFUN([MCA_prte_prtedl_libltdl_CONFIG],[\n    PRTE_VAR_SCOPE_PUSH([CPPFLAGS_save LDFLAGS_save LIBS_save])\n    AC_CONFIG_FILES([src/mca/prtedl/libltdl/Makefile])\n\n    # Add --with options\n    AC_ARG_WITH([libltdl],\n        [AC_HELP_STRING([--with-libltdl(=DIR)],\n             [Build libltdl support, optionally adding DIR/include, DIR/lib, and DIR/lib64 to the search path for headers and libraries])])\n    AC_ARG_WITH([libltdl-libdir],\n       [AC_HELP_STRING([--with-libltdl-libdir=DIR],\n             [Search for libltdl libraries in DIR])])\n\n    # Sanity check the --with values\n    PRTE_CHECK_WITHDIR([libltdl], [$with_libltdl],\n                       [include/ltprtedl.h])\n    PRTE_CHECK_WITHDIR([libltdl-libdir], [$with_libltdl_libdir],\n                       [libltdl.*])\n\n    # Defaults\n    prte_check_libltdl_dir_msg=\"compiler default\"\n    prte_check_libltdl_libdir_msg=\"linker default\"\n\n    # Save directory names if supplied\n    AS_IF([test ! -z \"$with_libltdl\" && test \"$with_libltdl\" != \"yes\"],\n          [prte_check_libltdl_dir=$with_libltdl\n           prte_check_libltdl_dir_msg=\"$prte_check_libltdl_dir (from --with-libltdl)\"])\n    AS_IF([test ! -z \"$with_libltdl_libdir\" && test \"$with_libltdl_libdir\" != \"yes\"],\n          [prte_check_libltdl_libdir=$with_libltdl_libdir\n           prte_check_libltdl_libdir_msg=\"$prte_check_libltdl_libdir (from --with-libltdl-libdir)\"])\n\n    prte_prtedl_libltdl_happy=no\n    AS_IF([test \"$with_libltdl\" != \"no\"],\n          [AC_MSG_CHECKING([for libltdl dir])\n           AC_MSG_RESULT([$prte_check_libltdl_dir_msg])\n           AC_MSG_CHECKING([for libltdl library dir])\n           AC_MSG_RESULT([$prte_check_libltdl_libdir_msg])\n\n           PRTE_CHECK_PACKAGE([prte_prtedl_libltdl],\n                  [ltprtedl.h],\n                  [ltprtedl],\n                  [lt_prtedlopen],\n                  [],\n                  [$prte_check_libltdl_dir],\n                  [$prte_check_libltdl_libdir],\n                  [prte_prtedl_libltdl_happy=yes],\n                  [prte_prtedl_libltdl_happy=no])\n              ])\n\n    # If we have libltdl, do we have lt_dladvise?\n    prte_prtedl_libltdl_have_lt_dladvise=0\n    AS_IF([test \"$prte_prtedl_libltdl_happy\" = \"yes\"],\n          [CPPFLAGS_save=$CPPFLAGS\n           LDFLAGS_save=$LDFLAGS\n           LIBS_save=$LIBS\n\n           CPPFLAGS=\"$prte_prtedl_libltdl_CPPFLAGS $CPPFLAGS\"\n           LDFLAGS=\"$prte_prtedl_libltdl_LDFLAGS $LDFLAGS\"\n           LIBS=\"$prte_prtedl_libltdl_LIBS $LIBS\"\n           AC_CHECK_FUNC([lt_dladvise_init],\n                         [prte_prtedl_libltdl_have_lt_dladvise=1])\n           CPPFLAGS=$CPPFLAGS_save\n           LDFLAGS=$LDFLAGS_save\n           LIBS=$LIBS_save\n          ])\n    AC_DEFINE_UNQUOTED(PRTE_DL_LIBLTDL_HAVE_LT_DLADVISE,\n        [$prte_prtedl_libltdl_have_lt_dladvise],\n        [Whether we have lt_dladvise or not])\n\n    AS_IF([test \"$prte_prtedl_libltdl_happy\" = \"yes\"],\n          [prte_prtedl_libltdl_ADD_CPPFLAGS=$prte_prtedl_libltdl_CPPFLAGS\n           prte_prtedl_libltdl_ADD_LDFLAGS=$prte_prtedl_libltdl_LDFLAGS\n           prte_prtedl_libltdl_ADD_LIBS=$prte_prtedl_libltdl_LIBS\n           $1],\n          [AS_IF([test ! -z \"$with_libltdl\" && \\\n                  test \"$with_libltdl\" != \"no\"],\n                 [AC_MSG_WARN([Libltdl support requested (via --with-libltdl) but not found.])\n                  AC_MSG_ERROR([Cannot continue.])])\n           $2])\n\n    AC_SUBST(prte_prtedl_libltdl_CPPFLAGS)\n    AC_SUBST(prte_prtedl_libltdl_LDFLAGS)\n    AC_SUBST(prte_prtedl_libltdl_LIBS)\n\n    PRTE_VAR_SCOPE_POP\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-i7toh3zidlll7lxwnp72zprwcwg4ub7m/spack-src/src/mca/prtedl/libltdl/prtedl_libltdl_module.c": "/*\n * Copyright (c) 2015-2020 Cisco Systems, Inc.  All rights reserved\n * Copyright (c) 2016      IBM Corporation.  All rights reserved.\n * Copyright (c) 2019-2020 Intel, Inc.  All rights reserved.\n * Copyright (c) 2019      Research Organization for Information Science\n *                         and Technology (RIST).  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"prte_config.h\"\n\n#include \"constants.h\"\n#include \"src/mca/prtedl/prtedl.h\"\n\n#include \"prtedl_libltdl.h\"\n\n\nstatic int libltdl_open(const char *fname, bool use_ext, bool private_namespace,\n                       prte_dl_handle_t **handle, char **err_msg)\n{\n    assert(handle);\n\n    *handle = NULL;\n    if (NULL != err_msg) {\n        *err_msg = NULL;\n    }\n\n    lt_prtedlhandle local_handle;\n\n#if PRTE_DL_LIBLTDL_HAVE_LT_DLADVISE\n    prte_prtedl_libltdl_component_t *c = &prte_prtedl_libltdl_component;\n\n    if (use_ext && private_namespace) {\n        local_handle = lt_dlopenadvise(fname, c->advise_private_ext);\n    } else if (use_ext && !private_namespace) {\n        local_handle = lt_dlopenadvise(fname, c->advise_public_ext);\n    } else if (!use_ext && private_namespace) {\n        local_handle = lt_dlopenadvise(fname, c->advise_private_noext);\n    } else if (!use_ext && !private_namespace) {\n        local_handle = lt_dlopenadvise(fname, c->advise_public_noext);\n    }\n#else\n    if (use_ext) {\n        local_handle = lt_dlopenext(fname);\n    } else {\n        local_handle = lt_dlopen(fname);\n    }\n#endif\n\n    if (NULL != local_handle) {\n        *handle = calloc(1, sizeof(prte_dl_handle_t));\n        (*handle)->ltdl_handle = local_handle;\n\n#if PRTE_ENABLE_DEBUG\n        if( NULL != fname ) {\n            (*handle)->filename = strdup(fname);\n        }\n        else {\n            (*handle)->filename = strdup(\"(null)\");\n        }\n#endif\n\n        return PRTE_SUCCESS;\n    }\n\n    if (NULL != err_msg) {\n        *err_msg = strdup((char*) lt_dlerror());\n    }\n    return PRTE_ERROR;\n}\n\n\nstatic int libltdl_lookup(prte_dl_handle_t *handle, const char *symbol,\n                         void **ptr, char **err_msg)\n{\n    assert(handle);\n    assert(handle->ltdl_handle);\n    assert(symbol);\n    assert(ptr);\n\n    if (NULL != err_msg) {\n        *err_msg = NULL;\n    }\n\n    *ptr = lt_dlsym(handle->ltdl_handle, symbol);\n    if (NULL != *ptr) {\n        return PRTE_SUCCESS;\n    }\n\n    if (NULL != err_msg) {\n        *err_msg = (char*) lt_dlerror();\n    }\n    return PRTE_ERROR;\n}\n\n\nstatic int libltdl_close(prte_dl_handle_t *handle)\n{\n    assert(handle);\n\n    int ret;\n    ret = lt_dlclose(handle->ltdl_handle);\n\n#if PRTE_ENABLE_DEBUG\n    free(handle->filename);\n#endif\n    free(handle);\n\n    return ret;\n}\n\nstatic int libltdl_foreachfile(const char *search_path,\n                               int (*func)(const char *filename, void *data),\n                               void *data)\n{\n    assert(search_path);\n    assert(func);\n\n    int ret = lt_dlforeachfile(search_path, func, data);\n    return (0 == ret) ? PRTE_SUCCESS : PRTE_ERROR;\n}\n\n\n/*\n * Module definition\n */\nprte_prtedl_base_module_t prte_prtedl_libltdl_module = {\n    .open = libltdl_open,\n    .lookup = libltdl_lookup,\n    .close = libltdl_close,\n    .foreachfile = libltdl_foreachfile\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-i7toh3zidlll7lxwnp72zprwcwg4ub7m/spack-src/src/tools/prte_info/param.c": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2004-2009 The Trustees of Indiana University and Indiana\n *                         University Research and Technology\n *                         Corporation.  All rights reserved.\n * Copyright (c) 2004-2006 The University of Tennessee and The University\n *                         of Tennessee Research Foundation.  All rights\n *                         reserved.\n * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,\n *                         University of Stuttgart.  All rights reserved.\n * Copyright (c) 2004-2005 The Regents of the University of California.\n *                         All rights reserved.\n * Copyright (c) 2007-2020 Cisco Systems, Inc.  All rights reserved\n * Copyright (c) 2009      Oak Ridge National Labs.  All rights reserved.\n * Copyright (c) 2015-2016 Research Organization for Information Science\n *                         and Technology (RIST). All rights reserved.\n * Copyright (c) 2018-2020 Intel, Inc.  All rights reserved.\n * Copyright (c) 2018      Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2018      Intel, Inc.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"prte_config.h\"\n\n#include <string.h>\n#include <ctype.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#ifdef HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif\n\n#include \"src/include/version.h\"\n#include \"src/mca/prteinstalldirs/prteinstalldirs.h\"\n#include \"src/class/prte_value_array.h\"\n#include \"src/class/prte_pointer_array.h\"\n#include \"src/util/printf.h\"\n#include \"src/include/prte_portable_platform.h\"\n\n#include \"src/util/show_help.h\"\n\n\n#include \"src/tools/prte_info/pinfo.h\"\n\n\n/*\n * Public variables\n */\n\nconst char *prte_info_component_all = \"all\";\nconst char *prte_info_param_all = \"all\";\n\nconst char *prte_info_path_prefix = \"prefix\";\nconst char *prte_info_path_bindir = \"bindir\";\nconst char *prte_info_path_libdir = \"libdir\";\nconst char *prte_info_path_incdir = \"incdir\";\nconst char *prte_info_path_mandir = \"mandir\";\nconst char *prte_info_path_pkglibdir = \"pkglibdir\";\nconst char *prte_info_path_sysconfdir = \"sysconfdir\";\nconst char *prte_info_path_exec_prefix = \"exec_prefix\";\nconst char *prte_info_path_sbindir = \"sbindir\";\nconst char *prte_info_path_libexecdir = \"libexecdir\";\nconst char *prte_info_path_datarootdir = \"datarootdir\";\nconst char *prte_info_path_datadir = \"datadir\";\nconst char *prte_info_path_sharedstatedir = \"sharedstatedir\";\nconst char *prte_info_path_localstatedir = \"localstatedir\";\nconst char *prte_info_path_infodir = \"infodir\";\nconst char *prte_info_path_pkgdatadir = \"pkgdatadir\";\nconst char *prte_info_path_pkgincludedir = \"pkgincludedir\";\n\nvoid prte_info_do_params(bool want_all_in, bool want_internal)\n{\n    int count;\n    char *type, *component, *str;\n    bool found;\n    int i;\n    bool want_all = false;\n    prte_value_t *pval;\n\n    prte_info_components_open();\n\n    if (want_all_in) {\n        want_all = true;\n    } else {\n        /* See if the special param \"all\" was givin to --param; that\n         * superceeds any individual type\n         */\n        count = prte_cmd_line_get_ninsts(prte_info_cmd_line, \"param\");\n        for (i = 0; i < count; ++i) {\n            pval = prte_cmd_line_get_param(prte_info_cmd_line, \"param\", (int)i, 0);\n            if (0 == strcmp(prte_info_type_all, pval->data.string)) {\n                want_all = true;\n                break;\n            }\n        }\n    }\n\n    /* Show the params */\n    if (want_all) {\n        for (i = 0; i < mca_types.size; ++i) {\n            if (NULL == (type = (char *)prte_pointer_array_get_item(&mca_types, i))) {\n                continue;\n            }\n            prte_info_show_mca_params(type, prte_info_component_all, want_internal);\n        }\n    } else {\n        for (i = 0; i < count; ++i) {\n            pval = prte_cmd_line_get_param(prte_info_cmd_line, \"param\", (int)i, 0);\n            type = pval->data.string;\n            pval = prte_cmd_line_get_param(prte_info_cmd_line, \"param\", (int)i, 1);\n            component = pval->data.string;\n\n            for (found = false, i = 0; i < mca_types.size; ++i) {\n                if (NULL == (str = (char *)prte_pointer_array_get_item(&mca_types, i))) {\n                    continue;\n                }\n                if (0 == strcmp(str, type)) {\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) {\n                char *usage = prte_cmd_line_get_usage_msg(prte_info_cmd_line, false);\n                prte_show_help(\"help-pinfo.txt\", \"not-found\", true, type);\n                free(usage);\n                exit(1);\n            }\n\n            prte_info_show_mca_params(type, component, want_internal);\n        }\n    }\n}\n\nstatic void prte_info_show_mca_group_params(const prte_mca_base_var_group_t *group, bool want_internal)\n{\n    const prte_mca_base_var_t *var;\n    const int *variables;\n    int ret, i, j, count;\n    const int *groups;\n    char **strings;\n\n    variables = PRTE_VALUE_ARRAY_GET_BASE(&group->group_vars, const int);\n    count = prte_value_array_get_size((prte_value_array_t *)&group->group_vars);\n\n    for (i = 0 ; i < count ; ++i) {\n        ret = prte_mca_base_var_get(variables[i], &var);\n        if (PRTE_SUCCESS != ret || ((var->mbv_flags & PRTE_MCA_BASE_VAR_FLAG_INTERNAL) &&\n                                    !want_internal)) {\n            continue;\n        }\n\n        ret = prte_mca_base_var_dump(variables[i], &strings, !prte_info_pretty ? PRTE_MCA_BASE_VAR_DUMP_PARSABLE : PRTE_MCA_BASE_VAR_DUMP_READABLE);\n        if (PRTE_SUCCESS != ret) {\n            continue;\n        }\n\n        for (j = 0 ; strings[j] ; ++j) {\n            if (0 == j && prte_info_pretty) {\n                char *message;\n\n                prte_asprintf (&message, \"MCA %s\", group->group_framework);\n                prte_info_out(message, message, strings[j]);\n                free(message);\n            } else {\n                prte_info_out(\"\", \"\", strings[j]);\n            }\n            free(strings[j]);\n        }\n        free(strings);\n    }\n\n    groups = PRTE_VALUE_ARRAY_GET_BASE(&group->group_subgroups, const int);\n    count = prte_value_array_get_size((prte_value_array_t *)&group->group_subgroups);\n\n    for (i = 0 ; i < count ; ++i) {\n        ret = prte_mca_base_var_group_get(groups[i], &group);\n        if (PRTE_SUCCESS != ret) {\n            continue;\n        }\n        prte_info_show_mca_group_params(group, want_internal);\n    }\n}\n\nvoid prte_info_show_mca_params(const char *type, const char *component,\n                               bool want_internal)\n{\n    const prte_mca_base_var_group_t *group;\n    int ret;\n\n    if (0 == strcmp (component, \"all\")) {\n        ret = prte_mca_base_var_group_find(\"*\", type, NULL);\n        if (0 > ret) {\n            return;\n        }\n\n        (void) prte_mca_base_var_group_get(ret, &group);\n\n        prte_info_show_mca_group_params(group, want_internal);\n    } else {\n        ret = prte_mca_base_var_group_find(\"*\", type, component);\n        if (0 > ret) {\n            return;\n        }\n\n        (void) prte_mca_base_var_group_get(ret, &group);\n        prte_info_show_mca_group_params(group, want_internal);\n    }\n}\n\nvoid prte_info_do_path(bool want_all, prte_cmd_line_t *cmd_line)\n{\n    int i, count;\n    char *scope;\n    prte_value_t *pval;\n\n    /* Check bozo case */\n    count = prte_cmd_line_get_ninsts(cmd_line, \"path\");\n    for (i = 0; i < count; ++i) {\n        pval = prte_cmd_line_get_param(cmd_line, \"path\", i, 0);\n        scope = pval->data.string;\n        if (0 == strcmp(\"all\", scope)) {\n            want_all = true;\n            break;\n        }\n    }\n\n    if (want_all) {\n        prte_info_show_path(prte_info_path_prefix, prte_install_dirs.prefix);\n        prte_info_show_path(prte_info_path_exec_prefix, prte_install_dirs.exec_prefix);\n        prte_info_show_path(prte_info_path_bindir, prte_install_dirs.bindir);\n        prte_info_show_path(prte_info_path_sbindir, prte_install_dirs.sbindir);\n        prte_info_show_path(prte_info_path_libdir, prte_install_dirs.libdir);\n        prte_info_show_path(prte_info_path_incdir, prte_install_dirs.includedir);\n        prte_info_show_path(prte_info_path_mandir, prte_install_dirs.mandir);\n        prte_info_show_path(prte_info_path_pkglibdir, prte_install_dirs.prtelibdir);\n        prte_info_show_path(prte_info_path_libexecdir, prte_install_dirs.libexecdir);\n        prte_info_show_path(prte_info_path_datarootdir, prte_install_dirs.datarootdir);\n        prte_info_show_path(prte_info_path_datadir, prte_install_dirs.datadir);\n        prte_info_show_path(prte_info_path_sysconfdir, prte_install_dirs.sysconfdir);\n        prte_info_show_path(prte_info_path_sharedstatedir, prte_install_dirs.sharedstatedir);\n        prte_info_show_path(prte_info_path_localstatedir, prte_install_dirs.localstatedir);\n        prte_info_show_path(prte_info_path_infodir, prte_install_dirs.infodir);\n        prte_info_show_path(prte_info_path_pkgdatadir, prte_install_dirs.prtedatadir);\n        prte_info_show_path(prte_info_path_pkglibdir, prte_install_dirs.prtelibdir);\n        prte_info_show_path(prte_info_path_pkgincludedir, prte_install_dirs.prteincludedir);\n    } else {\n        count = prte_cmd_line_get_ninsts(cmd_line, \"path\");\n        for (i = 0; i < count; ++i) {\n            pval = prte_cmd_line_get_param(cmd_line, \"path\", i, 0);\n            scope = pval->data.string;\n\n            if (0 == strcmp(prte_info_path_prefix, scope)) {\n                prte_info_show_path(prte_info_path_prefix, prte_install_dirs.prefix);\n            } else if (0 == strcmp(prte_info_path_bindir, scope)) {\n                prte_info_show_path(prte_info_path_bindir, prte_install_dirs.bindir);\n            } else if (0 == strcmp(prte_info_path_libdir, scope)) {\n                prte_info_show_path(prte_info_path_libdir, prte_install_dirs.libdir);\n            } else if (0 == strcmp(prte_info_path_incdir, scope)) {\n                prte_info_show_path(prte_info_path_incdir, prte_install_dirs.includedir);\n            } else if (0 == strcmp(prte_info_path_mandir, scope)) {\n                prte_info_show_path(prte_info_path_mandir, prte_install_dirs.mandir);\n            } else if (0 == strcmp(prte_info_path_pkglibdir, scope)) {\n                prte_info_show_path(prte_info_path_pkglibdir, prte_install_dirs.prtelibdir);\n            } else if (0 == strcmp(prte_info_path_sysconfdir, scope)) {\n                prte_info_show_path(prte_info_path_sysconfdir, prte_install_dirs.sysconfdir);\n            } else if (0 == strcmp(prte_info_path_exec_prefix, scope)) {\n                prte_info_show_path(prte_info_path_exec_prefix, prte_install_dirs.exec_prefix);\n            } else if (0 == strcmp(prte_info_path_sbindir, scope)) {\n                prte_info_show_path(prte_info_path_sbindir, prte_install_dirs.sbindir);\n            } else if (0 == strcmp(prte_info_path_libexecdir, scope)) {\n                prte_info_show_path(prte_info_path_libexecdir, prte_install_dirs.libexecdir);\n            } else if (0 == strcmp(prte_info_path_datarootdir, scope)) {\n                prte_info_show_path(prte_info_path_datarootdir, prte_install_dirs.datarootdir);\n            } else if (0 == strcmp(prte_info_path_datadir, scope)) {\n                prte_info_show_path(prte_info_path_datadir, prte_install_dirs.datadir);\n            } else if (0 == strcmp(prte_info_path_sharedstatedir, scope)) {\n                prte_info_show_path(prte_info_path_sharedstatedir, prte_install_dirs.sharedstatedir);\n            } else if (0 == strcmp(prte_info_path_localstatedir, scope)) {\n                prte_info_show_path(prte_info_path_localstatedir, prte_install_dirs.localstatedir);\n            } else if (0 == strcmp(prte_info_path_infodir, scope)) {\n                prte_info_show_path(prte_info_path_infodir, prte_install_dirs.infodir);\n            } else if (0 == strcmp(prte_info_path_pkgdatadir, scope)) {\n                prte_info_show_path(prte_info_path_pkgdatadir, prte_install_dirs.prtedatadir);\n            } else if (0 == strcmp(prte_info_path_pkgincludedir, scope)) {\n                prte_info_show_path(prte_info_path_pkgincludedir, prte_install_dirs.prteincludedir);\n            } else {\n                char *usage = prte_cmd_line_get_usage_msg(cmd_line, false);\n                prte_show_help(\"help-pinfo.txt\", \"usage\", true, usage);\n                free(usage);\n                exit(1);\n            }\n        }\n    }\n}\n\n\nvoid prte_info_show_path(const char *type, const char *value)\n{\n    char *pretty, *path;\n\n    pretty = strdup(type);\n    pretty[0] = toupper(pretty[0]);\n\n    prte_asprintf(&path, \"path:%s\", type);\n    prte_info_out(pretty, path, value);\n    free(pretty);\n    free(path);\n}\n\n\nvoid prte_info_do_arch()\n{\n    prte_info_out(\"Configured architecture\", \"config:arch\", PRTE_ARCH);\n}\n\n\nvoid prte_info_do_hostname()\n{\n    prte_info_out(\"Configure host\", \"config:host\", PRTE_CONFIGURE_HOST);\n}\n\n\n/*\n * do_config\n * Accepts:\n *      - want_all: boolean flag; TRUE -> display all options\n *                                FALSE -> display selected options\n *\n * This function displays all the options with which the current\n * installation of prte was configured. There are many options here\n * that are carried forward from PRTE-7 and are not mca parameters\n * in PRTE-10. I have to dig through the invalid options and replace\n * them with PRTE-10 options.\n */\nvoid prte_info_do_config(bool want_all)\n{\n    char *debug;\n    char *have_dl;\n    char *prun_prefix_by_default;\n    char *symbol_visibility;\n    char *manpages;\n    char *resilience;\n\n    /* setup the strings that don't require allocations*/\n    debug = PRTE_ENABLE_DEBUG ? \"yes\" : \"no\";\n    have_dl = PRTE_HAVE_DL_SUPPORT ? \"yes\" : \"no\";\n    prun_prefix_by_default = PRTE_WANT_PRTE_PREFIX_BY_DEFAULT ? \"yes\" : \"no\";\n    symbol_visibility = PRTE_C_HAVE_VISIBILITY ? \"yes\" : \"no\";\n    manpages = PRTE_ENABLE_MAN_PAGES ? \"yes\" : \"no\";\n    resilience = PRTE_ENABLE_FT ? \"yes\" : \"no\";\n\n    /* output values */\n    prte_info_out(\"Configured by\", \"config:user\", PRTE_CONFIGURE_USER);\n    prte_info_out(\"Configured on\", \"config:timestamp\", PRTE_CONFIGURE_DATE);\n    prte_info_out(\"Configure host\", \"config:host\", PRTE_CONFIGURE_HOST);\n    prte_info_out(\"Configure command line\", \"config:cli\", PRTE_CONFIGURE_CLI);\n\n    prte_info_out(\"Built by\", \"build:user\", PRTE_BUILD_USER);\n    prte_info_out(\"Built on\", \"build:timestamp\", PRTE_BUILD_DATE);\n    prte_info_out(\"Built host\", \"build:host\", PRTE_BUILD_HOST);\n\n    prte_info_out(\"C compiler\", \"compiler:c:command\", PRTE_CC);\n    prte_info_out(\"C compiler absolute\", \"compiler:c:absolute\", PRTE_CC_ABSOLUTE);\n    prte_info_out(\"C compiler family name\", \"compiler:c:familyname\", _STRINGIFY(PLATFORM_COMPILER_FAMILYNAME));\n    prte_info_out(\"C compiler version\", \"compiler:c:version\", _STRINGIFY(PLATFORM_COMPILER_VERSION_STR));\n\n    if (want_all) {\n        prte_info_out_int(\"C char size\", \"compiler:c:sizeof:char\", sizeof(char));\n        prte_info_out_int(\"C bool size\", \"compiler:c:sizeof:bool\", sizeof(bool));\n        prte_info_out_int(\"C short size\", \"compiler:c:sizeof:short\", sizeof(short));\n        prte_info_out_int(\"C int size\", \"compiler:c:sizeof:int\", sizeof(int));\n        prte_info_out_int(\"C long size\", \"compiler:c:sizeof:long\", sizeof(long));\n        prte_info_out_int(\"C float size\", \"compiler:c:sizeof:float\", sizeof(float));\n        prte_info_out_int(\"C double size\", \"compiler:c:sizeof:double\", sizeof(double));\n        prte_info_out_int(\"C pointer size\", \"compiler:c:sizeof:pointer\", sizeof(void *));\n        prte_info_out_int(\"C char align\", \"compiler:c:align:char\", PRTE_ALIGNMENT_CHAR);\n        prte_info_out(\"C bool align\", \"compiler:c:align:bool\", \"skipped\");\n        prte_info_out_int(\"C int align\", \"compiler:c:align:int\", PRTE_ALIGNMENT_INT);\n        prte_info_out_int(\"C float align\", \"compiler:c:align:float\", PRTE_ALIGNMENT_FLOAT);\n        prte_info_out_int(\"C double align\", \"compiler:c:align:double\", PRTE_ALIGNMENT_DOUBLE);\n    }\n\n    prte_info_out(\"Thread support\", \"option:threads\", \"posix\");\n\n    if (want_all) {\n\n\n        prte_info_out(\"Build CFLAGS\", \"option:build:cflags\", PRTE_BUILD_CFLAGS);\n        prte_info_out(\"Build LDFLAGS\", \"option:build:ldflags\", PRTE_BUILD_LDFLAGS);\n        prte_info_out(\"Build LIBS\", \"option:build:libs\", PRTE_BUILD_LIBS);\n\n        prte_info_out(\"Wrapper extra CFLAGS\", \"option:wrapper:extra_cflags\",\n                      PRTE_WRAPPER_EXTRA_CFLAGS);\n        prte_info_out(\"Wrapper extra LDFLAGS\", \"option:wrapper:extra_ldflags\",\n                      PRTE_WRAPPER_EXTRA_LDFLAGS);\n        prte_info_out(\"Wrapper extra LIBS\", \"option:wrapper:extra_libs\",\n                      PRTE_WRAPPER_EXTRA_LIBS);\n    }\n\n    prte_info_out(\"Internal debug support\", \"option:debug\", debug);\n    prte_info_out(\"dl support\", \"option:dlopen\", have_dl);\n    prte_info_out(\"prun default --prefix\", \"prun:prefix_by_default\",\n                  prun_prefix_by_default);\n    prte_info_out(\"Symbol vis. support\", \"options:visibility\", symbol_visibility);\n    prte_info_out(\"Manpages built\", \"options:man-pages\", manpages);\n    prte_info_out(\"Resilience support\", \"options:ft\", resilience);\n\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-i7toh3zidlll7lxwnp72zprwcwg4ub7m/spack-src/.git/objects/pack/pack-18d8f7978d01e0d16f38810bbb1d8cb703969431.pack",
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-i7toh3zidlll7lxwnp72zprwcwg4ub7m/spack-src/.git/objects/pack/pack-18d8f7978d01e0d16f38810bbb1d8cb703969431.idx"
    ],
    "total_files": 1121
}